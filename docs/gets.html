<!DOCTYPE html><html><head><title>Help for package gets</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gets}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gets-package'><p>General-to-Specific (GETS) and Indicator Saturation (ISAT) Modelling</p></a></li>
<li><a href='#arx'><p>Estimate an AR-X model with log-ARCH-X errors</p></a></li>
<li><a href='#as.arx'><p>Convert an object to class 'arx'</p></a></li>
<li><a href='#as.lm'><p>Convert to 'lm' object</p></a></li>
<li><a href='#biascorr'><p>Bias-correction of coefficients following general-to-specific model selection</p></a></li>
<li><a href='#blocksFun'><p> Block-based General-to-Specific (GETS) modelling</p></a></li>
<li><a href='#coef.arx'><p>Extraction functions for 'arx' objects</p></a></li>
<li><a href='#coef.gets'><p>Extraction functions for 'gets' objects</p></a></li>
<li><a href='#coef.isat'><p>Extraction functions for 'isat' objects</p></a></li>
<li><a href='#coef.logitx'><p>Extraction functions for 'logitx' objects</p></a></li>
<li><a href='#diagnostics'><p>Diagnostics tests</p></a></li>
<li><a href='#distorttest'><p>Jiao-Pretis-Schwarz Outlier Distortion Test</p></a></li>
<li><a href='#distorttestboot'><p>Bootstrapped Jiao-Pretis-Schwarz Outlier Distortion Test</p></a></li>
<li><a href='#dropvar'><p>Drop variable</p></a></li>
<li><a href='#eqwma'><p>Equally Weighted Moving Average (EqWMA) of the pth. exponentiated values</p></a></li>
<li><a href='#ES'><p>Conditional Value-at-Risk (VaR) and Expected Shortfall (ES)</p></a></li>
<li><a href='#eviews'><p>Exporting results to EViews and STATA</p></a></li>
<li><a href='#gets'><p>General-to-Specific (GETS) Modelling</p></a></li>
<li><a href='#gets.isat'><p>General-to-Specific (GETS) Modelling 'isat' objects</p></a></li>
<li><a href='#gets.lm'><p>General-to-Specific (GETS) Modelling 'lm' objects</p></a></li>
<li><a href='#gets.logitx'><p>General-to-Specific (GETS) Modelling of objects of class 'logitx'</p></a></li>
<li><a href='#getsFun'><p>General-to-Specific (GETS) modelling function</p></a></li>
<li><a href='#getsm'><p>General-to-Specific (GETS) Modelling of an AR-X model (the mean specification) with log-ARCH-X errors (the log-variance specification).</p></a></li>
<li><a href='#gmm'><p>Generalised Method of Moment (GMM) estimation of linear models</p></a></li>
<li><a href='#hpdata'><p>Hoover and Perez (1999) data</p></a></li>
<li><a href='#iim'><p>Make Indicator Matrices (Impulses, Steps, Trends)</p></a></li>
<li><a href='#infldata'><p>Quarterly Norwegian year-on-year CPI inflation</p></a></li>
<li><a href='#infocrit'><p>Computes the Average Value of an Information Criterion</p></a></li>
<li><a href='#isat'><p>Indicator Saturation</p></a></li>
<li><a href='#isatdates'><p>Extracting Indicator Saturation Breakdates</p></a></li>
<li><a href='#isatloop'><p>Repeated Impulse Indicator Saturation</p></a></li>
<li><a href='#isattest'><p>Indicator Saturation Test</p></a></li>
<li><a href='#isatvar'><p>Variance of the coefficient path</p></a></li>
<li><a href='#isatvarcorrect'><p>Consistency and Efficiency Correction for Impulse Indicator Saturation</p></a></li>
<li><a href='#isvarcor'><p>IIS Consistency Correction</p></a></li>
<li><a href='#isvareffcor'><p>IIS Efficiency Correction</p></a></li>
<li><a href='#logit'><p>Estimation of a logit model</p></a></li>
<li><a href='#logitx'><p>Estimate an autoregressive logit model with covariates</p></a></li>
<li><a href='#logitxSim'><p>Simulate from a dynamic logit-x model</p></a></li>
<li><a href='#mvrnormsim'><p>Simulate from a Multivariate Normal Distribution</p></a></li>
<li><a href='#ols'><p>OLS estimation</p></a></li>
<li><a href='#outlierscaletest'><p>Sum and Sup Scaling Outlier Tests</p></a></li>
<li><a href='#outliertest'><p>Jiao and Pretis Outlier Proportion and Count Tests</p></a></li>
<li><a href='#paths'><p>Extraction functions for 'arx', 'gets' and 'isat' objects</p></a></li>
<li><a href='#periodicdummies'><p>Make matrix of periodicity (e.g. seasonal) dummies</p></a></li>
<li><a href='#predict.arx'><p>Forecasting with 'arx' models</p></a></li>
<li><a href='#printtex'><p>Generate LaTeX code of an estimation result</p></a></li>
<li><a href='#recursive'><p>Recursive estimation</p></a></li>
<li><a href='#regressorsMean'><p>Create the regressors of the mean equation</p></a></li>
<li><a href='#regressorsVariance'><p>Create the regressors of the variance equation</p></a></li>
<li><a href='#so2data'>
<p>UK SO2 Data</p></a></li>
<li><a href='#sp500data'>
<p>Daily Standard and Poor's 500 index data</p></a></li>
<li><a href='#vargaugeiis'><p>Variance of the Impulse Indicator Saturation Gauge</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>General-to-Specific (GETS) Modelling and Indicator Saturation
Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>0.37</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-04</td>
</tr>
<tr>
<td>Author:</td>
<td>Genaro Sucarrat [aut, cre], Felix Pretis [aut], James Reade [aut], Jonas Kurle [ctb], Moritz Schwarz [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Genaro Sucarrat &lt;genaro.sucarrat@bi.no&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Automated General-to-Specific (GETS) modelling of the mean and variance of a regression, and indicator saturation methods for detecting and testing for structural breaks in the mean, see Pretis, Reade and Sucarrat (2018) &lt;<a href="https://doi.org/10.18637%2Fjss.v086.i03">doi:10.18637/jss.v086.i03</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0), zoo, parallel</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lgarch, xtable, Matrix, microbenchmark</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gsucarrat/gets/issues">https://github.com/gsucarrat/gets/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://CRAN.R-project.org/package=gets">https://CRAN.R-project.org/package=gets</a>,
<a href="http://www.sucarrat.net/R/gets/">http://www.sucarrat.net/R/gets/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-04 08:39:14 UTC; sucarrat</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-09 20:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='gets-package'>General-to-Specific (GETS) and Indicator Saturation (ISAT) Modelling</h2><span id='topic+gets-package'></span>

<h3>Description</h3>

<p>The <span class="pkg">gets</span> package provides functions and methods for General-to-Specific (GETS) and Indicator Saturation (ISAT) modelling. GETS modelling is a powerful and flexible variable selection algorithm that returns a parsimonious and interpretable model. It is ideally suited for the development of models that can be used for counterfactual and predictive scenario analysis (e.g. conditional forecasting). ISAT modelling provides a comprehensive, flexible and powerful approach to the identification of structural breaks and outliers.<br />
</p>
<p>The code of the package originated in relation with the research project G. Sucarrat and A. Escribano (2012). In 2014, Felix Pretis and James Reade joined for the development of the <code><a href="#topic+isat">isat</a></code> code and related functions. Moritz Schwarz and Jonas Kurle joined the development team in 2020.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
	Version: </td><td style="text-align: left;"> 0.37</td>
</tr>
<tr>
 <td style="text-align: left;">
	Date: </td><td style="text-align: left;"> 2022-10-04</td>
</tr>
<tr>
 <td style="text-align: left;">
	Licence: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>GETS modelling</h3>

<p>GETS methods are available for the following model classes:<br />
</p>

<ul>
<li><p> Linear regression, both static and dynamic, see <code><a href="#topic+arx">arx</a></code>, <code><a href="#topic+gets.arx">gets.arx</a></code> and <code><a href="#topic+gets.lm">gets.lm</a></code>
</p>
</li>
<li><p> Variance models, both static and dynamic, see <code><a href="#topic+arx">arx</a></code>
</p>
</li>
<li><p> Logit models, both static and dynamic, see <code><a href="#topic+logitx">logitx</a></code> and <code><a href="#topic+gets.logitx">gets.logitx</a></code>
</p>
</li></ul>

<p>The function <code>arx</code> estimates a static linear regression, or a dynamic AR-X model with (optionally) a log-variance specification. The log-variance specification can either be static or a dynamic log-variance model with covariates (a 'log-ARCH-X' model). For the statistical details of the model, see Section 4 in Pretis, Reade and Sucarrat (2018). The function <code><a href="#topic+logitx">logitx</a></code> estimates a static logit model, or a dynamic logit model with covariates (optionally). For complete user-specified GETS modelling, see <code><a href="#topic+getsFun">getsFun</a></code>.<br />
</p>


<h3>ISAT modelling</h3>

<p>ISAT methods are available for:<br />
</p>

<ul>
<li><p> Linear regression, both static and dynamic, see <code><a href="#topic+isat">isat</a></code>
</p>
</li></ul>

<p>The <code>isat</code> function undertakes GETS model selection of an indicator saturated mean specification. Extraction functions (mainly S3 methods) are also available, together with additional auxiliary functions. For complete user-specified ISAT modelling, see <code><a href="#topic+blocksFun">blocksFun</a></code>.<br />
</p>


<h3>Vignettes</h3>

<p>Two vignettes are available in the package (type <code>browseVignettes("gets")</code> to access them):<br />
</p>

<ul>
<li><p> An introduction to the <em>gets</em> package
</p>
</li>
<li><p> User-Specified General-to-Specific (GETS) and Indicator Saturation (ISAT) Methods
</p>
</li></ul>

<p>The former is a mildly modified version of Pretis, Reade and Sucarrat (2018), whereas the latter is an updated version of Sucarrat (2020).
</p>


<h3>Author(s)</h3>


<table>
<tr>
 <td style="text-align: left;">
	Jonas Kurle: </td><td style="text-align: left;"> </td><td style="text-align: left;"> <a href="https://www.jonaskurle.com/">https://www.jonaskurle.com/</a></td>
</tr>
<tr>
 <td style="text-align: left;">
	Felix Pretis: </td><td style="text-align: left;"> </td><td style="text-align: left;"> <a href="http://www.felixpretis.org/">http://www.felixpretis.org/</a></td>
</tr>
<tr>
 <td style="text-align: left;">
	James Reade: </td><td style="text-align: left;"> </td><td style="text-align: left;"> <a href="https://sites.google.com/site/jjamesreade/">https://sites.google.com/site/jjamesreade/</a></td>
</tr>
<tr>
 <td style="text-align: left;">
	Moritz Schwarz: </td><td style="text-align: left;"> </td><td style="text-align: left;">  <a href="https://www.inet.ox.ac.uk/people/moritz-schwarz/">https://www.inet.ox.ac.uk/people/moritz-schwarz/</a></td>
</tr>
<tr>
 <td style="text-align: left;">
	Genaro Sucarrat: </td><td style="text-align: left;"> </td><td style="text-align: left;"> <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Maintainer: Genaro Sucarrat            
</p>


<h3>References</h3>

<p>Jurgen A. Doornik, David F. Hendry, and Felix Pretis (2013): 'Step Indicator Saturation', Oxford Economics Discussion Paper, 658. <a href="https://ideas.repec.org/p/oxf/wpaper/658.html">https://ideas.repec.org/p/oxf/wpaper/658.html</a>
</p>
<p>Felix Pretis, James Reade and Genaro Sucarrat (2018): 'Automated General-to-Specific (GETS) Regression Modeling and Indicator Saturation for Outliers and Structural Breaks'. Journal of Statistical Software 86, Number 3, pp. 1-44. <a href="https://doi.org/10.18637/jss.v086.i03">doi:10.18637/jss.v086.i03</a>
</p>
<p>Carlos Santos, David F. Hendry and Soren Johansen (2007):  'Automatic selection of indicators in a fully saturated regression'. Computational Statistics, vol 23:1, pp.317-335. <a href="https://doi.org/10.1007/s00180-007-0054-z">doi:10.1007/s00180-007-0054-z</a>
</p>
<p>Genaro Sucarrat (2020): 'User-Specified General-to-Specific and Indicator Saturation Methods'. The R Journal 12:2, pages 388-401. <a href="https://journal.r-project.org/archive/2021/RJ-2021-024/">https://journal.r-project.org/archive/2021/RJ-2021-024/</a>
</p>
<p>Genaro Sucarrat and Alvaro Escribano (2012): 'Automated Financial Model Selection: General-to-Specific Modelling of the Mean and Volatility Specifications', Oxford Bulletin of Economics and Statistics 74, Issue 5 (October), pp. 716-735.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arx">arx</a></code>, <code><a href="#topic+gets.arx">gets.arx</a></code>, <code><a href="#topic+getsm">getsm</a></code>, <code><a href="#topic+getsv">getsv</a></code>, <code><a href="#topic+isat">isat</a></code>, <code><a href="#topic+getsFun">getsFun</a></code>, <code><a href="#topic+blocksFun">blocksFun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Simulate from an AR(1):
set.seed(123)
y &lt;- arima.sim(list(ar=0.4), 60)

##Estimate an AR(2) with intercept as mean specification
##and a log-ARCH(4) as log-volatility specification:
myModel &lt;- arx(y, mc=TRUE, ar=1:2, arch=1:4)

##GETS modelling of the mean of myModel:
simpleMean &lt;- getsm(myModel)

##GETS modelling of the log-variance of myModel:
simpleVar &lt;- getsv(myModel)

##results:
print(simpleMean)
print(simpleVar)

##step indicator saturation of an iid normal series:
set.seed(123)
y &lt;- rnorm(30)
isat(y)

</code></pre>

<hr>
<h2 id='arx'>Estimate an AR-X model with log-ARCH-X errors</h2><span id='topic+arx'></span>

<h3>Description</h3>

<p>Estimation by OLS, two-step OLS if a variance specification is specified: In the first the mean specification (AR-X) is estimated, whereas in the second step the log-variance specification (log-ARCH-X) is estimated.
</p>
<p>The AR-X mean specification can contain an intercept, AR-terms, lagged moving averages of the regressand and other conditioning covariates ('X'). The log-variance specification can contain log-ARCH terms, asymmetry or 'leverage' terms, log(EqWMA) where EqWMA is a lagged equally weighted moving average of past squared residuals (a volatility proxy) and other conditioning covariates ('X').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arx(y, mc=TRUE, ar=NULL, ewma=NULL, mxreg=NULL, vc=FALSE,
  arch=NULL, asym=NULL, log.ewma=NULL, vxreg=NULL, zero.adj=0.1,
  vc.adj=TRUE, vcov.type=c("ordinary", "white", "newey-west"),
  qstat.options=NULL, normality.JarqueB=FALSE, user.estimator=NULL,
  user.diagnostics=NULL, tol=1e-07, LAPACK=FALSE, singular.ok=TRUE,
  plot=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arx_+3A_y">y</code></td>
<td>
<p>numeric vector, time-series or <code><a href="zoo.html#topic+zoo">zoo</a></code> object. Missing values in the beginning and at the end of the series is allowed, as they are removed with the <code><a href="zoo.html#topic+na.trim">na.trim</a></code> command</p>
</td></tr>
<tr><td><code id="arx_+3A_mc">mc</code></td>
<td>
<p>logical. <code>TRUE</code> (default) includes an intercept in the mean specification, whereas <code>FALSE</code> does not</p>
</td></tr>
<tr><td><code id="arx_+3A_ar">ar</code></td>
<td>
<p>either <code>NULL</code> (default) or an integer vector, say, <code>c(2,4)</code> or <code>1:4</code>. The AR-lags to include in the mean specification. If <code>NULL</code>, then no lags are included</p>
</td></tr>
<tr><td><code id="arx_+3A_ewma">ewma</code></td>
<td>
<p>either <code>NULL</code> (default) or a <code><a href="base.html#topic+list">list</a></code> with arguments sent to the <code><a href="#topic+eqwma">eqwma</a></code> function. In the latter case a lagged moving average of <code>y</code> is included as a regressor</p>
</td></tr>
<tr><td><code id="arx_+3A_mxreg">mxreg</code></td>
<td>
<p>either <code>NULL</code> (default) or a numeric vector or matrix, say, a <code><a href="zoo.html#topic+zoo">zoo</a></code> object, of conditioning variables. Note that, if both <code>y</code> and <code>mxreg</code> are <code>zoo</code> objects, then their samples are chosen to match</p>
</td></tr>
<tr><td><code id="arx_+3A_vc">vc</code></td>
<td>
<p>logical. <code>TRUE</code> includes an intercept in the log-variance specification, whereas <code>FALSE</code> (default) does not. If the log-variance specification contains any other item but the log-variance intercept, then vc is set to <code>TRUE</code> </p>
</td></tr>
<tr><td><code id="arx_+3A_arch">arch</code></td>
<td>
<p>either <code>NULL</code> (default) or an integer vector, say, <code>c(1,3)</code> or <code>2:5</code>. The log-ARCH lags to include in the log-variance specification</p>
</td></tr>
<tr><td><code id="arx_+3A_asym">asym</code></td>
<td>
<p>either <code>NULL</code> (default) or an integer vector, say, <code>c(1)</code> or <code>1:3</code>. The asymmetry (i.e. 'leverage') terms to include in the log-variance specification</p>
</td></tr>
<tr><td><code id="arx_+3A_log.ewma">log.ewma</code></td>
<td>
<p>either <code>NULL</code> (default) or a vector of the lengths of the volatility proxies, see <code><a href="#topic+leqwma">leqwma</a></code> </p>
</td></tr>
<tr><td><code id="arx_+3A_vxreg">vxreg</code></td>
<td>
<p>either <code>NULL</code> (default) or a numeric vector or matrix, say, a <code><a href="zoo.html#topic+zoo">zoo</a></code> object, of conditioning variables. If both <code>y</code> and <code>mxreg</code> are <code>zoo</code> objects, then their samples are chosen to match</p>
</td></tr>
<tr><td><code id="arx_+3A_zero.adj">zero.adj</code></td>
<td>
<p>numeric value between 0 and 1. The quantile adjustment for zero values. The default 0.1 means the zero residuals are replaced by the 10 percent quantile of the absolute residuals before taking the logarithm</p>
</td></tr>
<tr><td><code id="arx_+3A_vc.adj">vc.adj</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), then the log-variance intercept is adjusted by the estimate of E[ln(z^2)], where z is the standardised error. This adjustment is needed for the conditional scale to be equal to the conditional standard deviation. If <code>FALSE</code>, then the log-variance intercept is not adjusted</p>
</td></tr>
<tr><td><code id="arx_+3A_vcov.type">vcov.type</code></td>
<td>
<p>character vector, &quot;ordinary&quot; (default), &quot;white&quot; or &quot;newey-west&quot;. If &quot;ordinary&quot;, then the ordinary variance-covariance matrix is used for inference. If &quot;white&quot;, then the White (1980) heteroscedasticity-robust matrix is used. If &quot;newey-west&quot;, then the Newey and West (1987) heteroscedasticity and autocorrelation-robust matrix is used</p>
</td></tr>
<tr><td><code id="arx_+3A_qstat.options">qstat.options</code></td>
<td>
<p><code>NULL</code> (default) or an integer vector of length two, say, <code>c(1,1)</code>. The first value sets the lag-order of the AR diagnostic test, whereas the second value sets the lag-order of the ARCH diagnostic test. If <code>NULL</code>, then the two values of the vector are set automatically</p>
</td></tr>
<tr><td><code id="arx_+3A_normality.jarqueb">normality.JarqueB</code></td>
<td>
<p><code>FALSE</code> (default) or <code>TRUE</code>. If <code>TRUE</code>, then the results of the Jarque and Bera (1980) test for non-normality in the residuals are included in the estimation results. </p>
</td></tr>
<tr><td><code id="arx_+3A_user.estimator">user.estimator</code></td>
<td>
<p><code>NULL</code> (default) or a <code><a href="base.html#topic+list">list</a></code> with one entry, <code>name</code>, containing the name of the user-defined estimator. Additional items, if any, are passed on as arguments to the estimator in question </p>
</td></tr>
<tr><td><code id="arx_+3A_user.diagnostics">user.diagnostics</code></td>
<td>
<p><code>NULL</code> (default) or a <code><a href="base.html#topic+list">list</a></code> with two entries, <code>name</code> and <code>pval</code>, see the <code>user.fun</code> argument in <code><a href="#topic+diagnostics">diagnostics</a></code> </p>
</td></tr>
<tr><td><code id="arx_+3A_tol">tol</code></td>
<td>
<p>numeric value (<code>default = 1e-07</code>). The tolerance for detecting linear dependencies in the columns of the regressors (see <code><a href="base.html#topic+qr">qr</a></code> function). Only used if <code>LAPACK</code> is <code>FALSE</code> (default) and <code>user.estimator</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="arx_+3A_lapack">LAPACK</code></td>
<td>
<p>logical. If <code>TRUE</code>, then use LAPACK. If <code>FALSE</code> (default), then use LINPACK (see <code><a href="base.html#topic+qr">qr</a></code> function). Only used if <code>user.estimator</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="arx_+3A_singular.ok">singular.ok</code></td>
<td>
<p>logical. If <code>TRUE</code>, then the regressors are checked for singularity, and the ones causing it are automatically removed. </p>
</td></tr>
<tr><td><code id="arx_+3A_plot">plot</code></td>
<td>
<p><code>NULL</code> or logical. If <code>TRUE</code>, then the fitted values and the residuals are plotted. If <code>NULL</code> (default), then the value set by <code><a href="base.html#topic+options">options</a></code> determines whether a plot is produced or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an overview of the AR-X model with log-ARCH-X errors, see Pretis, Reade and Sucarrat (2018): <a href="https://doi.org/10.18637/jss.v086.i03">doi:10.18637/jss.v086.i03</a>.<br />
</p>
<p>The arguments <code>user.estimator</code> and <code>user.diagnostics</code> enables the specification of user-defined estimators and user-defined diagnostics. To this end, the principles of the same arguments in <code><a href="#topic+getsFun">getsFun</a></code> are followed, see its documentation under &quot;Details&quot;, and Sucarrat (2020): <a href="https://journal.r-project.org/archive/2021/RJ-2021-024/">https://journal.r-project.org/archive/2021/RJ-2021-024/</a>.
</p>


<h3>Value</h3>

<p>A list of class 'arx'</p>


<h3>Author(s)</h3>


<table>
<tr>
 <td style="text-align: left;">
	Jonas Kurle: </td><td style="text-align: left;"> </td><td style="text-align: left;"> <a href="https://www.jonaskurle.com/">https://www.jonaskurle.com/</a></td>
</tr>
<tr>
 <td style="text-align: left;">
	Moritz Schwarz: </td><td style="text-align: left;"> </td><td style="text-align: left;">  <a href="https://www.inet.ox.ac.uk/people/moritz-schwarz/">https://www.inet.ox.ac.uk/people/moritz-schwarz/</a></td>
</tr>
<tr>
 <td style="text-align: left;">
	Genaro Sucarrat: </td><td style="text-align: left;"> </td><td style="text-align: left;"> <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>References</h3>

<p>C. Jarque and A. Bera (1980): 'Efficient Tests for Normality, Homoscedasticity and Serial Independence'. Economics Letters 6, pp. 255-259. <a href="https://doi.org/10.1016/0165-1765%2880%2990024-5">doi:10.1016/0165-1765(80)90024-5</a>
</p>
<p>Felix Pretis, James Reade and Genaro Sucarrat (2018): 'Automated General-to-Specific (GETS) Regression Modeling and Indicator Saturation for Outliers and Structural Breaks'. Journal of Statistical Software 86, Number 3, pp. 1-44. <a href="https://doi.org/10.18637/jss.v086.i03">doi:10.18637/jss.v086.i03</a>
</p>
<p>Genaro Sucarrat (2020): 'User-Specified General-to-Specific and Indicator Saturation Methods'. The R Journal 12:2, pages 388-401. <a href="https://journal.r-project.org/archive/2021/RJ-2021-024/">https://journal.r-project.org/archive/2021/RJ-2021-024/</a>
</p>
<p>Halbert White (1980): 'A Heteroskedasticity-Consistent Covariance Matrix Estimator and a Direct Test for Heteroskedasticity', Econometrica 48, pp. 817-838.
</p>
<p>Whitney K. Newey and Kenned D. West (1987): 'A Simple, Positive Semi-Definite, Heteroskedasticity and Autocorrelation Consistent Covariance Matrix', Econometrica 55, pp. 703-708.
</p>


<h3>See Also</h3>

<p>Extraction functions (mostly S3 methods): <code><a href="#topic+coef.arx">coef.arx</a></code>, <code><a href="#topic+ES">ES</a></code>, <code><a href="#topic+fitted.arx">fitted.arx</a></code>, <code><a href="#topic+plot.arx">plot.arx</a></code>, <br />
<code><a href="#topic+print.arx">print.arx</a></code>, <code><a href="#topic+recursive">recursive</a></code>, <code><a href="#topic+residuals.arx">residuals.arx</a></code>, <code><a href="#topic+sigma.arx">sigma.arx</a></code>, <code><a href="#topic+rsquared">rsquared</a></code>,<br />
<code><a href="#topic+summary.arx">summary.arx</a></code>, <code><a href="#topic+VaR">VaR</a></code> and <code><a href="#topic+vcov.arx">vcov.arx</a></code><br />
</p>
<p>Related functions: <code><a href="#topic+getsm">getsm</a></code>, <code><a href="#topic+getsv">getsv</a></code>, <code><a href="#topic+isat">isat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Simulate from an AR(1):
set.seed(123)
y &lt;- arima.sim(list(ar=0.4), 70)

##estimate an AR(2) with intercept:
arx(y, mc=TRUE, ar=1:2)

##Simulate four independent Gaussian regressors:
xregs &lt;- matrix(rnorm(4*70), 70, 4)

##estimate an AR(2) with intercept and four conditioning
##regressors in the mean:
arx(y, ar=1:2, mxreg=xregs)

##estimate a log-variance specification with a log-ARCH(4)
##structure:
arx(y, mc=FALSE, arch=1:4)

##estimate a log-variance specification with a log-ARCH(4)
##structure and an asymmetry/leverage term:
arx(y, mc=FALSE, arch=1:4, asym=1)

##estimate a log-variance specification with a log-ARCH(4)
##structure, an asymmetry or leverage term, a 10-period log(EWMA) as
##volatility proxy, and the log of the squareds of the conditioning
##regressors in the log-variance specification:
arx(y, mc=FALSE,
  arch=1:4, asym=1, log.ewma=list(length=10), vxreg=log(xregs^2))

##estimate an AR(2) with intercept and four conditioning regressors
##in the mean, and a log-variance specification with a log-ARCH(4)
##structure, an asymmetry or leverage term, a 10-period log(EWMA) as
##volatility proxy, and the log of the squareds of the conditioning
##regressors in the log-variance specification:
arx(y, ar=1:2, mxreg=xregs,
  arch=1:4, asym=1, log.ewma=list(length=10), vxreg=log(xregs^2))
</code></pre>

<hr>
<h2 id='as.arx'>Convert an object to class 'arx'</h2><span id='topic+as.arx'></span><span id='topic+as.arx.lm'></span>

<h3>Description</h3>

<p>The function <code>as.arx</code> is a generic function and its methods returns an object of class <code><a href="#topic+arx">arx</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.arx(object, ...)

##S3 method for objects of class 'lm':
## S3 method for class 'lm'
as.arx(object, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.arx_+3A_object">object</code></td>
<td>
<p>object of class <code><a href="stats.html#topic+lm">lm</a></code> </p>
</td></tr>
<tr><td><code id="as.arx_+3A_...">...</code></td>
<td>
<p>arguments passed on to and from other methods </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code><a href="#topic+arx">arx</a></code> </p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a><br /><br />
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="#topic+arx">arx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##generate some data:
set.seed(123) #for reproducibility
y &lt;- rnorm(30) #generate Y
x &lt;- matrix(rnorm(30*10), 30, 10) #create matrix of Xs

##typical situation:
mymodel &lt;- lm(y ~ x)
as.arx(mymodel)
                                 
##use hetero-robust vcov:
as.arx(mymodel, vcov.type="white")

##add ar-dynamics:
as.arx(mymodel, ar=1:2)

##add log-variance specification:
as.arx(mymodel, arch=1:2)

</code></pre>

<hr>
<h2 id='as.lm'>Convert to 'lm' object</h2><span id='topic+as.lm'></span>

<h3>Description</h3>

<p>Convert 'arx'/'gets'/'isat' object to 'lm' object</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.lm(object)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.lm_+3A_object">object</code></td>
<td>
<p>object of class <code><a href="#topic+arx">arx</a></code>, <code><a href="#topic+gets">gets</a></code> or <code><a href="#topic+isat">isat</a></code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code><a href="stats.html#topic+lm">lm</a></code> </p>


<h3>Author(s)</h3>

<p>Moritz Schwarz, <a href="https://www.inet.ox.ac.uk/people/moritz-schwarz/">https://www.inet.ox.ac.uk/people/moritz-schwarz/</a><br />
Genaro Sucarrat <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a><br /><br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arx">arx</a></code>, <code><a href="#topic+gets">gets</a></code>, <code><a href="#topic+isat">isat</a></code>, <code><a href="stats.html#topic+lm">lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##generate data, estimate model of class 'arx':
set.seed(123)
y &lt;- rnorm(30)
arxmod &lt;- arx(y, mc=TRUE, ar=1:3)
as.lm(arxmod)

##from 'gets' to 'lm':
getsmod &lt;- getsm(arxmod, keep=1)
as.lm(getsmod)

##from 'isat' to 'lm':
isatmod &lt;- isat(y)
as.lm(isatmod)
</code></pre>

<hr>
<h2 id='biascorr'>Bias-correction of coefficients following general-to-specific model selection</h2><span id='topic+biascorr'></span>

<h3>Description</h3>

<p>Takes a vector of coefficients (valid for orthogonal variables), their standard errors, the significance level the variables were selected at, and the sample size, to return bias-corrected coefficient estimates to account for the bias induced by model selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  biascorr(b, b.se, p.alpha, T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biascorr_+3A_b">b</code></td>
<td>
<p>a Kx1 vector of coefficients.</p>
</td></tr>
<tr><td><code id="biascorr_+3A_b.se">b.se</code></td>
<td>
<p>a Kx1 vector of standard errors of the coefficients in 'b'.</p>
</td></tr>
<tr><td><code id="biascorr_+3A_p.alpha">p.alpha</code></td>
<td>
<p>numeric value between 0 and 1, the significance level at which selection was conducted.</p>
</td></tr>
<tr><td><code id="biascorr_+3A_t">T</code></td>
<td>
<p>integer, the sample size of the original model selection regression.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the bias-corrected estimates of coefficients in regression models post general-to-specific model selection using the approach by Hendry and Krolzig (2005). The results are valid for orthogonal regressors only. Bias correction can be applied to the coefficient path in <code><a href="#topic+isat">isat</a></code> models where the only additional covariate besides indicators is an intercept - see Pretis (2015).</p>


<h3>Value</h3>

<p>Returns a Kx3 matrix, where the first column lists the original coefficients, the second column the one-step corrected coefficients, and the third column the two-step bias-corrected coefficients.</p>


<h3>Author(s)</h3>

<p>Felix Pretis, <a href="http://www.felixpretis.org/">http://www.felixpretis.org/</a>
</p>


<h3>References</h3>

<p>Hendry, D.F. and Krolzig, H.M. (2005): 'The properties of automatic Gets modelling'. Economic Journal, 115, C32-C61.
</p>
<p>Pretis, F. (2015): 'Testing for time-varying predictive accuracy using bias-corrected indicator saturation'. Oxford Department of Economics Discussion Paper.
</p>
<p>Pretis, Felix, Reade, James and Sucarrat, Genaro (2018): 'Automated General-to-Specific (GETS) Regression Modeling and Indicator Saturation for Outliers and Structural Breaks'. Journal of Statistical Software 86, Number 3, pp. 1-44
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isat">isat</a></code>, <code><a href="#topic+coef.gets">coef.gets</a></code>, <code><a href="#topic+plot.gets">plot.gets</a></code>, <code><a href="#topic+isatvar">isatvar</a></code>, <code><a href="#topic+isattest">isattest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###Bias-correction of the coefficient path of the Nile data
#nile &lt;- as.zoo(Nile)
#isat.nile &lt;- isat(nile, sis=TRUE, iis=FALSE, plot=TRUE, t.pval=0.005)
#var &lt;- isatvar(isat.nile)
#biascorr(b=var$const.path, b.se=var$const.se, p.alpha=0.005, T=length(var$const.path))

##Bias-correction of the coefficient path on artificial data
#set.seed(123)
#d &lt;- matrix(0,100,1)
#d[35:55] &lt;- 1
#e &lt;- rnorm(100, 0, 1)
#y &lt;- d*1  +e
  
#ys &lt;- isat(y, sis=TRUE, iis=FALSE, t.pval=0.01)
#var &lt;- isatvar(ys)
#biascorr(b=var$const.path, b.se=var$const.se, p.alpha=0.01, T=length(var$const.path))
</code></pre>

<hr>
<h2 id='blocksFun'> Block-based General-to-Specific (GETS) modelling </h2><span id='topic+blocksFun'></span>

<h3>Description</h3>

<p>Auxiliary function (i.e. not intended for the average user) that enables block-based GETS-modelling with user-specified estimator, diagnostics and goodness-of-fit criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blocksFun(y, x, untransformed.residuals=NULL, blocks=NULL,
  no.of.blocks=NULL, max.block.size=30, ratio.threshold=0.8,
  gets.of.union=TRUE, force.invertibility=FALSE,
  user.estimator=list(name="ols"), t.pval=0.001, wald.pval=t.pval,
  do.pet=FALSE, ar.LjungB=NULL, arch.LjungB=NULL, normality.JarqueB=NULL,
  user.diagnostics=NULL, gof.function=list(name="infocrit"),
  gof.method=c("min", "max"), keep=NULL, include.gum=FALSE,
  include.1cut=FALSE, include.empty=FALSE, max.paths=NULL,
  turbo=FALSE, parallel.options=NULL, tol=1e-07, LAPACK=FALSE,
  max.regs=NULL, print.searchinfo=TRUE, alarm=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blocksFun_+3A_y">y</code></td>
<td>
<p>a numeric vector (with no missing values, i.e. no non-numeric 'holes') </p>
</td></tr>
<tr><td><code id="blocksFun_+3A_x">x</code></td>
<td>
<p>a <code>matrix</code>, or a <code>list</code> of matrices </p>
</td></tr>
<tr><td><code id="blocksFun_+3A_untransformed.residuals">untransformed.residuals</code></td>
<td>
<p><code>NULL</code> (default) or, when <code><a href="#topic+ols">ols</a></code> is used with <code>method=6</code> in <code>user.estimator</code>, a numeric vector containing the untransformed residuals </p>
</td></tr>
<tr><td><code id="blocksFun_+3A_blocks">blocks</code></td>
<td>
<p><code>NULL</code> (default) or a <code>list</code> of lists with vectors of integers that indicate how blocks should be put together. If <code>NULL</code>, then the block composition is undertaken automatically by an internal algorithm that depends on <code>no.of.blocks</code>, <code>max.block.size</code> and <code>ratio.threshold</code> </p>
</td></tr>
<tr><td><code id="blocksFun_+3A_no.of.blocks">no.of.blocks</code></td>
<td>
<p><code>NULL</code> (default) or <code>integer</code>. If <code>NULL</code>, then the number of blocks is determined automatically by an internal algorithm </p>
</td></tr>
<tr><td><code id="blocksFun_+3A_max.block.size">max.block.size</code></td>
<td>
<p><code>integer</code> that controls the size of blocks </p>
</td></tr>
<tr><td><code id="blocksFun_+3A_ratio.threshold">ratio.threshold</code></td>
<td>
<p><code>numeric</code> between 0 and 1 that controls the minimum ratio of variables in each block to total observations </p>
</td></tr>
<tr><td><code id="blocksFun_+3A_gets.of.union">gets.of.union</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> (default), then GETS modelling is undertaken of the union of retained variables. Otherwise it is not </p>
</td></tr>
<tr><td><code id="blocksFun_+3A_force.invertibility">force.invertibility</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, then the x-matrix is ensured to have full row-rank before it is passed on to <code><a href="#topic+getsFun">getsFun</a></code> </p>
</td></tr>
<tr><td><code id="blocksFun_+3A_user.estimator">user.estimator</code></td>
<td>
<p><code>list</code>, see <code><a href="#topic+getsFun">getsFun</a></code> for the details </p>
</td></tr>
<tr><td><code id="blocksFun_+3A_t.pval">t.pval</code></td>
<td>
<p><code>numeric</code> value between 0 and 1. The significance level used for the two-sided coefficient significance t-tests </p>
</td></tr>
<tr><td><code id="blocksFun_+3A_wald.pval">wald.pval</code></td>
<td>
<p><code>numeric</code> value between 0 and 1. The significance level used for the Parsimonious Encompassing Tests (PETs) </p>
</td></tr>
<tr><td><code id="blocksFun_+3A_do.pet">do.pet</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, then a Parsimonious Encompassing Test (PET) against the GUM is undertaken at each variable removal for the joint significance of all the deleted regressors along the current GETS path. If <code>FALSE</code>, then a PET is not undertaken at each removal</p>
</td></tr>
<tr><td><code id="blocksFun_+3A_ar.ljungb">ar.LjungB</code></td>
<td>
<p>a two element <code>vector</code>, or <code>NULL</code>. In the former case, the first element contains the AR-order, the second element the significance level. If <code>NULL</code>, then a test for autocorrelation in the residuals is not conducted </p>
</td></tr>
<tr><td><code id="blocksFun_+3A_arch.ljungb">arch.LjungB</code></td>
<td>
<p>a two element <code>vector</code>, or <code>NULL</code>. In the former case, the first element contains the ARCH-order, the second element the significance level. If <code>NULL</code>, then a test for ARCH in the residuals is not conducted </p>
</td></tr>
<tr><td><code id="blocksFun_+3A_normality.jarqueb">normality.JarqueB</code></td>
<td>
<p><code>NULL</code> or a <code>numeric</code> value between 0 and 1. In the latter case, a test for non-normality in the residuals is conducted using a significance level equal to<br /> <code>normality.JarqueB</code>. If <code>NULL</code>, then no test for non-normality is conducted </p>
</td></tr>
<tr><td><code id="blocksFun_+3A_user.diagnostics">user.diagnostics</code></td>
<td>
<p><code>NULL</code> (default) or a <code>list</code> with two entries, <code>name</code> and <code>pval</code>. See <code><a href="#topic+getsFun">getsFun</a></code> for the details </p>
</td></tr>
<tr><td><code id="blocksFun_+3A_gof.function">gof.function</code></td>
<td>
<p><code>list</code>. The first item should be named <code>name</code> and contain the name (a character) of the Goodness-of-Fit (GOF) function used. Additional items in the list <code>gof.function</code> are passed on as arguments to the GOF-function. . See <code><a href="#topic+getsFun">getsFun</a></code> for the details </p>
</td></tr>
<tr><td><code id="blocksFun_+3A_gof.method">gof.method</code></td>
<td>
<p><code>character</code>. Determines whether the best Goodness-of-Fit is a minimum (default) or maximum </p>
</td></tr>
<tr><td><code id="blocksFun_+3A_keep">keep</code></td>
<td>
<p><code>NULL</code> (default), <code>vector</code> of integers or a <code>list</code> of vectors of integers. In the latter case, the number of vectors should be equal to the number of matrices in <code>x</code> </p>
</td></tr>
<tr><td><code id="blocksFun_+3A_include.gum">include.gum</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, then the GUM (i.e. the starting model) is included among the terminal models </p>
</td></tr>
<tr><td><code id="blocksFun_+3A_include.1cut">include.1cut</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, then the 1-cut model is added to the list of terminal models </p>
</td></tr>
<tr><td><code id="blocksFun_+3A_include.empty">include.empty</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, then the empty model is added to the list of terminal models </p>
</td></tr>
<tr><td><code id="blocksFun_+3A_max.paths">max.paths</code></td>
<td>
<p><code>NULL</code> (default) or <code>integer</code> greater than 0. If <code>NULL</code>, then there is no limit to the number of paths. If <code>integer</code> (e.g. 1), then this integer constitutes the maximum number of paths searched (e.g. a single path) </p>
</td></tr>
<tr><td><code id="blocksFun_+3A_turbo">turbo</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, then (parts of) paths are not searched twice (or more) unnecessarily in each GETS modelling. Setting <code>turbo</code> to <code>TRUE</code> entails a small additional computational costs, but may be outweighed substantially if estimation is slow, or if the number of variables to delete in each path is large </p>
</td></tr>
<tr><td><code id="blocksFun_+3A_parallel.options">parallel.options</code></td>
<td>
<p><code>NULL</code> or <code>integer</code> that indicates the number of cores/threads to use for parallel computing (implemented w/<code>makeCluster</code> and <code>parLapply</code>)</p>
</td></tr>
<tr><td><code id="blocksFun_+3A_tol">tol</code></td>
<td>
<p><code>numeric</code> value, the tolerance for detecting linear dependencies in the columns of the variance-covariance matrix when computing the Wald-statistic used in the Parsimonious Encompassing Tests (PETs), see the <code><a href="base.html#topic+qr.solve">qr.solve</a></code> function</p>
</td></tr>
<tr><td><code id="blocksFun_+3A_lapack">LAPACK</code></td>
<td>
<p>currently not used</p>
</td></tr>
<tr><td><code id="blocksFun_+3A_max.regs">max.regs</code></td>
<td>
<p><code>integer</code>. The maximum number of regressions along a deletion path. Do not alter unless you know what you are doing! </p>
</td></tr>
<tr><td><code id="blocksFun_+3A_print.searchinfo">print.searchinfo</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> (default), then a print is returned whenever simiplification along a new path is started </p>
</td></tr>
<tr><td><code id="blocksFun_+3A_alarm">alarm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, then a sound or beep is emitted (in order to alert the user) when the model selection ends </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>blocksFun</code> undertakes block-based GETS modelling by a repeated but structured call to <code>getsFun</code>. For the details of how to user-specify an estimator via <code>user.estimator</code>, diagnostics via
<code>user.diagnostics</code> and a goodness-of-fit function via <code>gof.function</code>, see documentation of <code><a href="#topic+getsFun">getsFun</a></code> under &quot;Details&quot;.
</p>
<p>The algorithm of <code>blocksFun</code> is similar to that of <code><a href="#topic+isat">isat</a></code>, but more flexible. The main use of <code>blocksFun</code> is the creation of user-specified methods that employs block-based GETS modelling, e.g. indicator saturation techniques.
</p>


<h3>Value</h3>

<p> A <code><a href="base.html#topic+list">list</a></code> with the results of the block-based GETS-modelling. </p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, with contributions from Jonas kurle, Felix Pretis and James Reade <br />
</p>


<h3>References</h3>

<p>F. Pretis, J. Reade and G. Sucarrat (2018): 'Automated General-to-Specific (GETS) Regression Modeling and Indicator Saturation for Outliers and Structural Breaks'. Journal of Statistical Software 86, Number 3, pp. 1-44
</p>
<p>G. sucarrat (2020): 'User-Specified General-to-Specific and Indicator Saturation Methods'.  The R Journal 12 issue 2, pp. 388-401, <a href="https://journal.r-project.org/archive/2021/RJ-2021-024/">https://journal.r-project.org/archive/2021/RJ-2021-024/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getsFun">getsFun</a></code>, <code><a href="#topic+ols">ols</a></code>, <code><a href="#topic+diagnostics">diagnostics</a></code>, <code><a href="#topic+infocrit">infocrit</a></code> and <code><a href="#topic+isat">isat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## more variables than observations:
y &lt;- rnorm(20)
x &lt;- matrix(rnorm(length(y)*40), length(y), 40)
blocksFun(y, x)

## 'x' as list of matrices:
z &lt;- matrix(rnorm(length(y)*40), length(y), 40)
blocksFun(y, list(x,z))

## ensure regressor no. 3 in matrix no. 2 is not removed:
blocksFun(y, list(x,z), keep=list(integer(0), 3))

</code></pre>

<hr>
<h2 id='coef.arx'>Extraction functions for 'arx' objects</h2><span id='topic+coef.arx'></span><span id='topic+fitted.arx'></span><span id='topic+logLik.arx'></span><span id='topic+model.matrix.arx'></span><span id='topic+plot.arx'></span><span id='topic+print.arx'></span><span id='topic+residuals.arx'></span><span id='topic+sigma.arx'></span><span id='topic+summary.arx'></span><span id='topic+vcov.arx'></span>

<h3>Description</h3>

<p>Extraction functions for objects of class 'arx'</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'arx'
coef(object, spec=NULL, ...)
  ## S3 method for class 'arx'
fitted(object, spec=NULL, ...)
  ## S3 method for class 'arx'
logLik(object, ...)
  ## S3 method for class 'arx'
model.matrix(object, spec=c("mean","variance"), response=FALSE, as.zoo=TRUE, ...)
  ## S3 method for class 'arx'
plot(x, spec=NULL, col=c("red","blue"),
    lty=c("solid","solid"), lwd=c(1,1), ...)
  ## S3 method for class 'arx'
print(x, signif.stars=TRUE, ...)
  ## S3 method for class 'arx'
residuals(object, std=FALSE, ...)
  ## S3 method for class 'arx'
sigma(object, ...)
  ## S3 method for class 'arx'
summary(object, ...)
  ## S3 method for class 'arx'
vcov(object, spec=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.arx_+3A_object">object</code></td>
<td>
<p>an object of class 'arx'</p>
</td></tr>
<tr><td><code id="coef.arx_+3A_x">x</code></td>
<td>
<p>an object of class 'arx'</p>
</td></tr>
<tr><td><code id="coef.arx_+3A_spec">spec</code></td>
<td>
<p><code>NULL</code>, <code>"mean"</code>, <code>"variance"</code> or, in some instances, &quot;both&quot;. When <code>NULL</code> is a valid value, then it is automatically determined whether information pertaining to the mean or variance specification should be returned</p>
</td></tr>
<tr><td><code id="coef.arx_+3A_response">response</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, then the response is included in the first column</p>
</td></tr>
<tr><td><code id="coef.arx_+3A_as.zoo">as.zoo</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> (default), then the returned matrix is of class <code><a href="zoo.html#topic+zoo">zoo</a></code> </p>
</td></tr>
<tr><td><code id="coef.arx_+3A_signif.stars">signif.stars</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, then p-values are additionally encoded visually, 
see <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code> </p>
</td></tr>
<tr><td><code id="coef.arx_+3A_std">std</code></td>
<td>
<p><code>logical</code>. If <code>FALSE</code> (default), then the mean residuals are returned. If TRUE, then the standardised residuals are returned</p>
</td></tr>
<tr><td><code id="coef.arx_+3A_col">col</code></td>
<td>
<p>colours of actual (default=blue) and fitted (default=red) lines</p>
</td></tr>
<tr><td><code id="coef.arx_+3A_lty">lty</code></td>
<td>
<p>types of actual (default=solid) and fitted (default=solid) lines</p>
</td></tr>
<tr><td><code id="coef.arx_+3A_lwd">lwd</code></td>
<td>
<p>widths of actual (default=1) and fitted (default=1) lines</p>
</td></tr>
<tr><td><code id="coef.arx_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>coef:</code></td>
<td>
<p>a numeric vector containing parameter estimates</p>
</td></tr>
<tr><td><code>fitted:</code></td>
<td>
<p>a <code><a href="zoo.html#topic+zoo">zoo</a></code> object with fitted values</p>
</td></tr>
<tr><td><code>logLik:</code></td>
<td>
<p>log-likelihood (normal density)</p>
</td></tr>
<tr><td><code>model.matrix:</code></td>
<td>
<p>a matrix with the regressors and, optionally, the response</p>
</td></tr>
<tr><td><code>plot:</code></td>
<td>
<p>a plot of the fitted values and the residuals</p>
</td></tr>
<tr><td><code>print:</code></td>
<td>
<p>a print of the estimation results</p>
</td></tr>
<tr><td><code>residuals:</code></td>
<td>
<p>a <code><a href="zoo.html#topic+zoo">zoo</a></code> object with the residuals</p>
</td></tr>
<tr><td><code>sigma:</code></td>
<td>
<p>the regression standard error ('SE of regression')</p>
</td></tr>
<tr><td><code>summary:</code></td>
<td>
<p>a print of the items in the <code><a href="#topic+arx">arx</a></code> object</p>
</td></tr>
<tr><td><code>vcov:</code></td>
<td>
<p>variance-covariance matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Felix Pretis, <a href="http://www.felixpretis.org/">http://www.felixpretis.org/</a><br />
James Reade, <a href="https://sites.google.com/site/jjamesreade/">https://sites.google.com/site/jjamesreade/</a><br />
Moritz Schwarz, <a href="https://www.inet.ox.ac.uk/people/moritz-schwarz/">https://www.inet.ox.ac.uk/people/moritz-schwarz/</a><br />
Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arx">arx</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##simulate from an AR(1):
set.seed(123)
y &lt;- arima.sim(list(ar=0.4), 40)

##simulate four independent Gaussian regressors:
xregs &lt;- matrix(rnorm(4*40), 40, 4)

##estimate an 'arx' model: An AR(2) with intercept and four conditioning
##regressors in the mean, and log-ARCH(3) in the variance:
mymod &lt;- arx(y, mc=TRUE, ar=1:2, mxreg=xregs, arch=1:3)

##print results:
print(mymod)

##plot the fitted vs. actual values, and the residuals:
plot(mymod)

##print the entries of object 'mymod':
summary(mymod)

##extract coefficient estimates (automatically determined):
coef(mymod)

##extract mean coefficients only:
coef(mymod, spec="mean")

##extract log-variance coefficients only:
coef(mymod, spec="variance")

##extract all coefficient estimates:
coef(mymod, spec="both")

##extract regression standard error:
sigma(mymod)

##extract log-likelihood:
logLik(mymod)

##extract variance-covariance matrix of mean equation:
vcov(mymod)

##extract variance-covariance matrix of log-variance equation:
vcov(mymod, spec="variance")

##extract and plot the fitted mean values (automatically determined):
mfit &lt;- fitted(mymod)
plot(mfit)

##extract and plot the fitted variance values:
vfit &lt;- fitted(mymod, spec="variance")
plot(vfit)

##extract and plot both the fitted mean and variance values:
vfit &lt;- fitted(mymod, spec="both")
plot(vfit)

##extract and plot the fitted mean values:
vfit &lt;- fitted(mymod, spec="mean")
plot(vfit)

##extract and plot residuals:
epshat &lt;- residuals(mymod)
plot(epshat)

##extract and plot standardised residuals:
zhat &lt;- residuals(mymod, std=TRUE)
plot(zhat)

</code></pre>

<hr>
<h2 id='coef.gets'>Extraction functions for 'gets' objects</h2><span id='topic+coef.gets'></span><span id='topic+fitted.gets'></span><span id='topic+logLik.gets'></span><span id='topic+plot.gets'></span><span id='topic+predict.gets'></span><span id='topic+print.gets'></span><span id='topic+residuals.gets'></span><span id='topic+sigma.gets'></span><span id='topic+summary.gets'></span><span id='topic+vcov.gets'></span>

<h3>Description</h3>

<p>Extraction functions for objects of class 'gets'</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'gets'
coef(object, spec=NULL, ...)
  ## S3 method for class 'gets'
fitted(object, spec=NULL, ...)
  ## S3 method for class 'gets'
logLik(object, ...)
  ## S3 method for class 'gets'
plot(x, spec=NULL, col=c("red","blue"),
    lty=c("solid","solid"), lwd=c(1,1), ...)
  ## S3 method for class 'gets'
predict(object, spec=NULL, n.ahead=12, newmxreg=NULL,
    newvxreg=NULL, newindex=NULL, n.sim=5000, innov=NULL, probs=NULL,
    ci.levels=NULL, quantile.type=7, return=TRUE, verbose=FALSE, plot=NULL,
    plot.options=list(), ...)
  ## S3 method for class 'gets'
print(x, signif.stars=TRUE, ...)
  ## S3 method for class 'gets'
residuals(object, std=NULL, ...)
  ## S3 method for class 'gets'
sigma(object, ...)
  ## S3 method for class 'gets'
summary(object, ...)
  ## S3 method for class 'gets'
vcov(object, spec=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.gets_+3A_object">object</code></td>
<td>
<p>an object of class 'gets'</p>
</td></tr>
<tr><td><code id="coef.gets_+3A_x">x</code></td>
<td>
<p>an object of class 'gets'</p>
</td></tr>
<tr><td><code id="coef.gets_+3A_spec">spec</code></td>
<td>
<p>NULL, &quot;mean&quot;, &quot;variance&quot; or, in some instances, &quot;both&quot;. When <code>NULL</code> is a valid value, then it is automatically determined whether information pertaining to the mean or variance specification should be returned</p>
</td></tr>
<tr><td><code id="coef.gets_+3A_signif.stars">signif.stars</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, then p-values are additionally encoded visually, 
see <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code> </p>
</td></tr>
<tr><td><code id="coef.gets_+3A_std">std</code></td>
<td>
<p><code>logical</code>. If <code>FALSE</code> (default), then the mean residuals are returned. If TRUE, then the standardised residuals are returned</p>
</td></tr>
<tr><td><code id="coef.gets_+3A_n.ahead">n.ahead</code></td>
<td>
<p><code>integer</code> that determines how many steps ahead predictions should be generated (the default is 12)</p>
</td></tr>
<tr><td><code id="coef.gets_+3A_newmxreg">newmxreg</code></td>
<td>
<p>a <code>matrix</code> of <code>n.ahead</code> rows and <code>NCOL(mxreg)</code> columns with the out-of-sample values of the <code>mxreg</code> regressors</p>
</td></tr>
<tr><td><code id="coef.gets_+3A_newvxreg">newvxreg</code></td>
<td>
<p>a <code>matrix</code> of <code>n.ahead</code> rows and <code>NCOL(vxreg)</code> columns with the out-of-sample values of the <code>vxreg</code> regressors</p>
</td></tr>
<tr><td><code id="coef.gets_+3A_newindex">newindex</code></td>
<td>
<p><code>NULL</code> (default) or the date-index for the <code>zoo</code> object returned by <code>predict.arx</code>. If <code>NULL</code>, then the function uses the in-sample <code>index</code> to generate the out-of-sample index</p>
</td></tr>
<tr><td><code id="coef.gets_+3A_n.sim">n.sim</code></td>
<td>
<p><code>integer</code>, the number of replications used for the generation of the forecasts</p>
</td></tr>
<tr><td><code id="coef.gets_+3A_innov">innov</code></td>
<td>
<p><code>NULL</code> (default) or a vector of length <code>n.ahead * n.sim</code> containing the standardised errors (that is, zero mean and unit variance) used for the forecast simulations. If <code>NULL</code>, then a classica bootstrap procedure is used to draw from the standardised in-sample residuals</p>
</td></tr>
<tr><td><code id="coef.gets_+3A_probs">probs</code></td>
<td>
<p><code>NULL</code> (default) or a <code>vector</code> with the quantile-levels (values strictly between 0 and 1) of the forecast distribution. If <code>NULL</code>, then no quantiles are returned unless <code>ci.levels</code> is non-<code>NULL</code></p>
</td></tr>
<tr><td><code id="coef.gets_+3A_ci.levels">ci.levels</code></td>
<td>
<p><code>NULL</code> (default) or a <code>vector</code> with the confidence levels (expressed as values strictly between 0 and 1) of the forecast distribution. The upper and lower values of the confidence interval(s) are returned as quantiles</p>
</td></tr>
<tr><td><code id="coef.gets_+3A_quantile.type">quantile.type</code></td>
<td>
<p>an integer between 1 and 9 that selects which algorithm to be used in computing the quantiles, see the argument <code>type</code> in <code><a href="stats.html#topic+quantile">quantile</a></code> </p>
</td></tr>
<tr><td><code id="coef.gets_+3A_return">return</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> (default), then the out-of-sample predictions are returned. The value <code>FALSE</code>, which does not return the predictions, may be of interest if only a prediction plot is of interest</p>
</td></tr>
<tr><td><code id="coef.gets_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> with default <code>FALSE</code>. If <code>TRUE</code>, then additional information (typically the quantiles and/or the simulated series) used in the generation of forecasts is returned. If <code>FALSE</code>, then only the forecasts are returned</p>
</td></tr>
<tr><td><code id="coef.gets_+3A_plot">plot</code></td>
<td>
<p><code>NULL</code> (default) or logical. If <code>NULL</code>, then the value set by <code>options$plot</code> (see <code><a href="base.html#topic+options">options</a></code>) determines whether a plot is produced or not. If <code>TRUE</code>, then the out-of-sample forecasts are plotted.</p>
</td></tr>
<tr><td><code id="coef.gets_+3A_plot.options">plot.options</code></td>
<td>
<p>a <code>list</code> of options related to the plotting of forecasts, see 'Details'</p>
</td></tr>
<tr><td><code id="coef.gets_+3A_col">col</code></td>
<td>
<p>colours of fitted (default=red) and actual (default=blue) lines</p>
</td></tr>
<tr><td><code id="coef.gets_+3A_lty">lty</code></td>
<td>
<p>types of fitted (default=solid) and actual (default=solid) lines</p>
</td></tr>
<tr><td><code id="coef.gets_+3A_lwd">lwd</code></td>
<td>
<p>widths of fitted (default=1) and actual (default=1) lines</p>
</td></tr>
<tr><td><code id="coef.gets_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot.options</code> argument is a <code>list</code> that controls the prediction plot, see 'Details' in <code><a href="#topic+predict.arx">predict.arx</a></code>
</p>


<h3>Value</h3>

<table>
<tr><td><code>coef:</code></td>
<td>
<p>a numeric vector containing parameter estimates</p>
</td></tr>
<tr><td><code>fitted:</code></td>
<td>
<p>a <code><a href="zoo.html#topic+zoo">zoo</a></code> object with fitted values</p>
</td></tr>
<tr><td><code>logLik:</code></td>
<td>
<p>a numeric, the log-likelihood (normal density)</p>
</td></tr>
<tr><td><code>plot:</code></td>
<td>
<p>a plot of the fitted values and the residuals</p>
</td></tr>
<tr><td><code>predict:</code></td>
<td>
<p>a <code>vector</code> of class <code><a href="zoo.html#topic+zoo">zoo</a></code> containing the out-of-sample forecasts, or a <code>matrix</code> of class <code><a href="zoo.html#topic+zoo">zoo</a></code> containing the out-of-sample forecasts together with prediction-quantiles, or - if <code>return=FALSE</code> - <code>NULL</code> </p>
</td></tr>
<tr><td><code>print:</code></td>
<td>
<p>a print of the estimation results</p>
</td></tr>
<tr><td><code>residuals:</code></td>
<td>
<p>a <code><a href="zoo.html#topic+zoo">zoo</a></code> object with the residuals</p>
</td></tr>
<tr><td><code>sigma:</code></td>
<td>
<p>the regression standard error ('SE of regression')</p>
</td></tr>
<tr><td><code>summary:</code></td>
<td>
<p>a print of the items in the <code><a href="#topic+gets">gets</a></code> object</p>
</td></tr>
<tr><td><code>vcov:</code></td>
<td>
<p>a variance-covariance matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Felix Pretis, <a href="http://www.felixpretis.org/">http://www.felixpretis.org/</a><br />
James Reade, <a href="https://sites.google.com/site/jjamesreade/">https://sites.google.com/site/jjamesreade/</a><br />
Moritz Schwarz, <a href="https://www.inet.ox.ac.uk/people/moritz-schwarz/">https://www.inet.ox.ac.uk/people/moritz-schwarz/</a><br />
Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+getsm">getsm</a></code>, <code><a href="#topic+getsv">getsv</a></code>, <code><a href="#topic+isat">isat</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>##Simulate from an AR(1):
set.seed(123)
y &lt;- arima.sim(list(ar=0.4), 100)

##Simulate four independent Gaussian regressors:
xregs &lt;- matrix(rnorm(4*100), 100, 4)

##estimate an AR(2) with intercept and four conditioning
##regressors in the mean, and a log-ARCH(3) in the variance:
mymod &lt;- arx(y, mc=TRUE, ar=1:2, mxreg=xregs, arch=1:3)

##General-to-Specific (GETS) model selection of the mean:
meanmod &lt;- getsm(mymod)

##General-to-Specific (GETS) model selection of the variance:
varmod &lt;- getsv(mymod)

##print results:
print(meanmod)
print(varmod)

##plot the fitted vs. actual values, and the residuals:
plot(meanmod)
plot(varmod)

##generate and plot predictions of the mean:
predict(meanmod, plot=TRUE)

##print the entries of object 'gets':
summary(meanmod)
summary(varmod)

##extract coefficients of the simplified (specific) model:
coef(meanmod) #mean spec
coef(varmod) #variance spec

##extract log-likelihood:
logLik(mymod)

##extract coefficient-covariance matrix of simplified
##(specific) model:
vcov(meanmod) #mean spec
vcov(varmod) #variance spec

##extract and plot the fitted values:
mfit &lt;- fitted(meanmod) #mean fit
plot(mfit)
vfit &lt;- fitted(varmod) #variance fit
plot(vfit)

##extract and plot residuals:
epshat &lt;- residuals(meanmod)
plot(epshat)

##extract and plot standardised residuals:
zhat &lt;- residuals(varmod)
plot(zhat)

</code></pre>

<hr>
<h2 id='coef.isat'>Extraction functions for 'isat' objects</h2><span id='topic+coef.isat'></span><span id='topic+fitted.isat'></span><span id='topic+logLik.isat'></span><span id='topic+plot.isat'></span><span id='topic+predict.isat'></span><span id='topic+print.isat'></span><span id='topic+residuals.isat'></span><span id='topic+sigma.isat'></span><span id='topic+summary.isat'></span><span id='topic+vcov.isat'></span>

<h3>Description</h3>

<p>Extraction functions for objects of class 'isat'</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'isat'
coef(object, ...)
  ## S3 method for class 'isat'
fitted(object, ...)
  ## S3 method for class 'isat'
logLik(object, ...)
  ## S3 method for class 'isat'
plot(x, col=c("red","blue"), lty=c("solid","solid"),
    lwd=c(1,1), coef.path=TRUE, ...)
  ## S3 method for class 'isat'
predict(object, n.ahead=12, newmxreg=NULL, newindex=NULL,
    n.sim=2000, probs=NULL, ci.levels=NULL, quantile.type=7,
    return=TRUE, verbose=FALSE, plot=NULL, plot.options=list(), ...)
  ## S3 method for class 'isat'
print(x, signif.stars=TRUE, ...)
  ## S3 method for class 'isat'
residuals(object, std=FALSE, ...)
  ## S3 method for class 'isat'
sigma(object, ...)
  ## S3 method for class 'isat'
summary(object, ...)
  ## S3 method for class 'isat'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.isat_+3A_object">object</code></td>
<td>
<p>an object of class 'isat'</p>
</td></tr>
<tr><td><code id="coef.isat_+3A_x">x</code></td>
<td>
<p>an object of class 'isat'</p>
</td></tr>
<tr><td><code id="coef.isat_+3A_std">std</code></td>
<td>
<p>logical. If <code>FALSE</code> (default), then the mean residuals are returned. If TRUE, then the standardised residuals are returned</p>
</td></tr>
<tr><td><code id="coef.isat_+3A_n.ahead">n.ahead</code></td>
<td>
<p><code>integer</code> that determines how many steps ahead predictions should be generated (the default is 12)</p>
</td></tr>
<tr><td><code id="coef.isat_+3A_newmxreg">newmxreg</code></td>
<td>
<p>a <code>matrix</code> of <code>n.ahead</code> rows and <code>NCOL(mxreg)</code> columns with the out-of-sample values of the <code>mxreg</code> regressors</p>
</td></tr>
<tr><td><code id="coef.isat_+3A_newindex">newindex</code></td>
<td>
<p><code>NULL</code> (default) or the date-index for the <code>zoo</code> object returned by <code>predict.arx</code>. If <code>NULL</code>, then the function uses the in-sample <code>index</code> to generate the out-of-sample index</p>
</td></tr>
<tr><td><code id="coef.isat_+3A_n.sim">n.sim</code></td>
<td>
<p><code>integer</code>, the number of replications used for the generation of the forecasts</p>
</td></tr>
<tr><td><code id="coef.isat_+3A_probs">probs</code></td>
<td>
<p><code>NULL</code> (default) or a <code>vector</code> with the quantile-levels (values strictly between 0 and 1) of the forecast distribution. If <code>NULL</code>, then no quantiles are returned unless <code>ci.levels</code> is non-<code>NULL</code></p>
</td></tr>
<tr><td><code id="coef.isat_+3A_ci.levels">ci.levels</code></td>
<td>
<p><code>NULL</code> (default) or a <code>vector</code> with the confidence levels (expressed as values strictly between 0 and 1) of the forecast distribution. The upper and lower values of the confidence interval(s) are returned as quantiles</p>
</td></tr>
<tr><td><code id="coef.isat_+3A_quantile.type">quantile.type</code></td>
<td>
<p>an integer between 1 and 9 that selects which algorithm to be used in computing the quantiles, see the argument <code>type</code> in <code><a href="stats.html#topic+quantile">quantile</a></code> </p>
</td></tr>
<tr><td><code id="coef.isat_+3A_return">return</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), then the out-of-sample predictions are returned. The value <code>FALSE</code>, which does not return the predictions, may be of interest if only a prediction plot is of interest</p>
</td></tr>
<tr><td><code id="coef.isat_+3A_verbose">verbose</code></td>
<td>
<p>logical with default <code>FALSE</code>. If <code>TRUE</code>, then additional information (typically the quantiles and/or the simulated series) used in the generation of forecasts is returned. If <code>FALSE</code>, then only the forecasts are returned</p>
</td></tr>
<tr><td><code id="coef.isat_+3A_plot">plot</code></td>
<td>
<p><code>NULL</code> (default) or logical. If <code>NULL</code>, then the value set by <code>options$plot</code> (see <code><a href="base.html#topic+options">options</a></code>) determines whether a plot is produced or not. If <code>TRUE</code>, then the out-of-sample forecasts are plotted.</p>
</td></tr>
<tr><td><code id="coef.isat_+3A_plot.options">plot.options</code></td>
<td>
<p>a <code>list</code> of options related to the plotting of forecasts, see 'Details'</p>
</td></tr>
<tr><td><code id="coef.isat_+3A_col">col</code></td>
<td>
<p>colours of fitted (default=red) and actual (default=blue) lines</p>
</td></tr>
<tr><td><code id="coef.isat_+3A_lty">lty</code></td>
<td>
<p>types of fitted (default=solid) and actual (default=solid) lines</p>
</td></tr>
<tr><td><code id="coef.isat_+3A_lwd">lwd</code></td>
<td>
<p>widths of fitted (default=1) and actual (default=1) lines</p>
</td></tr>
<tr><td><code id="coef.isat_+3A_coef.path">coef.path</code></td>
<td>
<p>logical. Only applicable if there are retained indicators after the application of <code>isat</code></p>
</td></tr>
<tr><td><code id="coef.isat_+3A_signif.stars">signif.stars</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, then p-values are additionally encoded visually, 
see <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code> </p>
</td></tr>
<tr><td><code id="coef.isat_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot.options</code> argument is a <code>list</code> that controls the prediction plot, see 'Details' in <code><a href="#topic+predict.arx">predict.arx</a></code>
</p>


<h3>Value</h3>

<table>
<tr><td><code>coef:</code></td>
<td>
<p>numeric vector containing parameter estimates</p>
</td></tr>
<tr><td><code>fitted:</code></td>
<td>
<p>a <code><a href="zoo.html#topic+zoo">zoo</a></code> object with fitted values</p>
</td></tr>
<tr><td><code>logLik:</code></td>
<td>
<p>a numeric, the log-likelihood (normal density)</p>
</td></tr>
<tr><td><code>plot:</code></td>
<td>
<p>plot of the fitted values and the residuals</p>
</td></tr>
<tr><td><code>predict:</code></td>
<td>
<p>a <code>vector</code> of class <code><a href="zoo.html#topic+zoo">zoo</a></code> containing the out-of-sample forecasts, or a <code>matrix</code> of class <code><a href="zoo.html#topic+zoo">zoo</a></code> containing the out-of-sample forecasts together with prediction-quantiles, or - if <code>return=FALSE</code> - <code>NULL</code> </p>
</td></tr>
<tr><td><code>print:</code></td>
<td>
<p>a print of the estimation results</p>
</td></tr>
<tr><td><code>residuals:</code></td>
<td>
<p>a <code><a href="zoo.html#topic+zoo">zoo</a></code> object with the residuals</p>
</td></tr>
<tr><td><code>sigma:</code></td>
<td>
<p>the regression standard error ('SE of regression')</p>
</td></tr>
<tr><td><code>summary:</code></td>
<td>
<p>a print of the items in the <code><a href="#topic+isat">isat</a></code> object</p>
</td></tr>
<tr><td><code>vcov:</code></td>
<td>
<p>variance-covariance matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Felix Pretis, <a href="http://www.felixpretis.org/">http://www.felixpretis.org/</a><br />
James Reade, <a href="https://sites.google.com/site/jjamesreade/">https://sites.google.com/site/jjamesreade/</a><br />
Moritz Schwarz, <a href="https://www.inet.ox.ac.uk/people/moritz-schwarz/">https://www.inet.ox.ac.uk/people/moritz-schwarz/</a><br />
Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+paths">paths</a></code>, <code><a href="#topic+terminals">terminals</a></code>, <code><a href="#topic+coef.gets">coef.gets</a></code>, <code><a href="#topic+getsm">getsm</a></code>, <code><a href="#topic+arx">arx</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>##step indicator saturation:
set.seed(123)
y &lt;- rnorm(30)
isatmod &lt;- isat(y)

##print results:
print(isatmod)

##plot the fitted vs. actual values, and the residuals:
plot(isatmod)

##print the entries of object 'isatmod':
summary(isatmod)

##extract coefficients of the simplified (specific) model:
coef(isatmod)

##extract log-likelihood:
logLik(isatmod)

##extract the coefficient-covariance matrix of simplified
##(specific) model:
vcov(isatmod)

##extract and plot the fitted values:
mfit &lt;- fitted(isatmod)
plot(mfit)

##extract and plot (mean) residuals:
epshat &lt;- residuals(isatmod)
plot(epshat)

##extract and plot standardised residuals:
zhat &lt;- residuals(isatmod, std=TRUE)
plot(zhat)

##generate forecasts of the simplified (specific) model:
predict(isatmod, newmxreg=matrix(1,12,1), plot=TRUE)

</code></pre>

<hr>
<h2 id='coef.logitx'>Extraction functions for 'logitx' objects</h2><span id='topic+coef.logitx'></span><span id='topic+fitted.logitx'></span><span id='topic+logLik.logitx'></span><span id='topic+plot.logitx'></span><span id='topic+print.logitx'></span><span id='topic+summary.logitx'></span><span id='topic+toLatex.logitx'></span><span id='topic+vcov.logitx'></span>

<h3>Description</h3>

<p>Extraction functions (of type S3 methods) for objects of class 'logitx'</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'logitx'
coef(object, ...)
  ## S3 method for class 'logitx'
fitted(object, zero.prob=FALSE, ...)
  ## S3 method for class 'logitx'
logLik(object, ...)
  ## S3 method for class 'logitx'
plot(x, ...)
  ## S3 method for class 'logitx'
print(x, signif.stars=TRUE, ...)
  ## S3 method for class 'logitx'
summary(object, ...)
  ## S3 method for class 'logitx'
toLatex(object, digits = 4, gof = TRUE, nonumber = FALSE, nobs = "T", ...)
  ## S3 method for class 'logitx'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.logitx_+3A_object">object</code></td>
<td>
<p>an object of class 'logitx'</p>
</td></tr>
<tr><td><code id="coef.logitx_+3A_x">x</code></td>
<td>
<p>an object of class 'logitx'</p>
</td></tr>
<tr><td><code id="coef.logitx_+3A_zero.prob">zero.prob</code></td>
<td>
<p><code>logical</code>. If <code>FALSE</code> (default), then the probabilities of a one are returned as fitted values. If <code>TRUE</code>, then the zero probabilities are returned as fitted values </p>
</td></tr>
<tr><td><code id="coef.logitx_+3A_signif.stars">signif.stars</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, then p-values are additionally encoded visually, see <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code> </p>
</td></tr>
<tr><td><code id="coef.logitx_+3A_digits">digits</code></td>
<td>
<p>integer, the number of digits in the LaTeX print</p>
</td></tr>
<tr><td><code id="coef.logitx_+3A_gof">gof</code></td>
<td>
<p>logical that determines whether goodness-of-fit information should be included in the LaTeX print</p>
</td></tr>
<tr><td><code id="coef.logitx_+3A_nonumber">nonumber</code></td>
<td>
<p>logical that determines whether a &quot;nonumber&quot; tag should be added to each equation in the LaTeX print</p>
</td></tr>
<tr><td><code id="coef.logitx_+3A_nobs">nobs</code></td>
<td>
<p>character that determines the label for the number of observations in the LaTeX print</p>
</td></tr>
<tr><td><code id="coef.logitx_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Various, depending on the method</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logitx">logitx</a></code>, <code><a href="#topic+logitxSim">logitxSim</a></code>, <code><a href="#topic+gets.logitx">gets.logitx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##simulate from ar(1):
set.seed(123) #for reproducibility
y &lt;- logitxSim(100, ar=0.3)

##estimate and store result:
mymod &lt;- logitx(y, ar=1)

##extract stuff:
coef(mymod)
fitted(mymod)
logLik(mymod)
plot(mymod)
print(mymod)
summary(mymod)
toLatex(mymod)

</code></pre>

<hr>
<h2 id='diagnostics'>Diagnostics tests</h2><span id='topic+diagnostics'></span>

<h3>Description</h3>

<p>Auxiliary function (i.e. not intended for the average user) called by the <code><a href="#topic+arx">arx</a></code>, <code><a href="#topic+getsm">getsm</a></code>, <code><a href="#topic+getsv">getsv</a></code>, <code><a href="#topic+isat">isat</a></code>, <code><a href="#topic+getsFun">getsFun</a></code> and <code><a href="#topic+blocksFun">blocksFun</a></code> functions. The <code>diagnostics</code> function undertakes tests for autocorrelation, ARCH and non-normality in a residual series, and user-defined diagnostics provided via the <code>user.fun</code> argument (see details). The autocorrelation and ARCH tests are conducted as Ljung and Box (1979) tests for autocorrelation in the residuals and squared residuals, respectively, whereas the test for non-normality is that of Jarque and Bera (1980).</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnostics(x, ar.LjungB=c(1, 0.025), arch.LjungB=c(1, 0.025),
  normality.JarqueB=NULL, verbose=TRUE, user.fun=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnostics_+3A_x">x</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code>, for example the estimation result of <code><a href="#topic+ols">ols</a></code>. The tests for serial correlation, ARCH and normality look for an entry in the list named <code>std.residuals</code> or <code>residuals</code></p>
</td></tr>
<tr><td><code id="diagnostics_+3A_ar.ljungb">ar.LjungB</code></td>
<td>
<p>a two element vector or <code>NULL</code>. In the former case, the first element contains the AR-order, the second element the significance level. If <code>NULL</code>, then a test for autocorrelation is not conducted</p>
</td></tr>
<tr><td><code id="diagnostics_+3A_arch.ljungb">arch.LjungB</code></td>
<td>
<p>a two element vector or <code>NULL</code>. In the former case, the first element contains the ARCH-order, the second element the significance level. If <code>NULL</code>, then a test for ARCH is not conducted</p>
</td></tr>
<tr><td><code id="diagnostics_+3A_normality.jarqueb">normality.JarqueB</code></td>
<td>
<p><code>NULL</code> (the default) or a value between 0 and 1. In the latter case, a test for non-normality is conducted using a significance level equal to <code>normality.JarqueB</code>. If <code>NULL</code>, then no test for non-normality is conducted</p>
</td></tr>
<tr><td><code id="diagnostics_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, then a <code><a href="base.html#topic+data.frame">data.frame</a></code> with the results of the diagnostics is returned. If <code>FALSE</code>, then the return-value is a <code>logical</code> that indicates whether the model passes the diagnostics (<code>TRUE</code> if it does, otherwise <code>FALSE</code>) </p>
</td></tr>
<tr><td><code id="diagnostics_+3A_user.fun">user.fun</code></td>
<td>
<p><code>NULL</code> or a <code><a href="base.html#topic+list">list</a></code> with at least one entry, <code>name</code> (must be of class <code>character</code>), which should contain the name of the user-defined function. See details </p>
</td></tr>
<tr><td><code id="diagnostics_+3A_...">...</code></td>
<td>
<p>further arguments (ignored) to accommodate deleted arguments from past versions of the functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>user.fun</code> enables the user to specify additional diagnostics. To do this, the argument should be a <code><a href="base.html#topic+list">list</a></code> with at least one entry, <code>name</code> (of class <code>character</code>), that contains the name of the user-defined function. The call to this function is executed with <code><a href="base.html#topic+do.call">do.call</a></code>, whose default value on <code>envir</code> is <code>parent.frame()</code>. Usually, this will be the global environment (<code>.GlobalEnv</code>), but it can be changed by adding an entry named <code>envir</code> to the list that indicates where the user-defined function resides. If the <code>verbose</code> argument is set to <code>FALSE</code>, then an entry named <code>pval</code> must be provided. This entry should contain the chosen significance level or levels, i.e. either a scalar or a vector of length equal to the number of <em>p</em>-values returned by the user-defined diagnostics function (see examples). The user can also specify whether a rejection of the tests should cause the diagnostics to fail (default behaviour) or whether a rejection is desirable. For that purpose, a named entry <code>is.reject.bad</code> can be added that stores a logical vector of length equal to the number of tests conducted in the user diagnostics function. The first entry of the vector governs the diagnostic decision for the first row that the user diagnostics function returns, the second entry the decision for the second row etc. Additional entries in the <code>list</code> are passed on as arguments to the user-defined function.
</p>
<p>The user-defined function should refer to the named items of the estimation result <code>x</code> (see examples), and the value returned by the user-defined function should be a matrix of dimension <em>m</em> x 3. Here, <em>m</em> is the number of diagnostic tests performed by the user-defined function. For example, if only a single test is performed, then <em>m</em> = 1 and so the returned value should be a 1 x 3 matrix (or a vector of length 3). The three columns of the <em>m</em> x 3 matrix should contain, in the following order, 1) the value(s) of the test-statistic(s) (or <code>NA</code>), 2) the degree(s) of freedom(s) (or <code>NA</code>) of the tests, and 3) the <em>p</em>-value(s) of the test(s). When checking whether the model passes the diagnostics or not, the <em>p</em>-value(s) is(are) checked against the value(s) in the entry named <code>pval</code> in the <code>list</code> provided to <code>user.fun</code>. By default, a calculated <em>p</em>-value below the corresponding element in <code>pval</code> causes the diagnostics to fail. If a named entry <code>is.reject.bad</code> exists, this decision rule is only applied to tests whose corresponding entry is <code>TRUE</code> while the decision rule is reversed for those with entry <code>FALSE</code>. For these tests, the diagnostics fail if the hypothesis cannot be rejected.
</p>


<h3>Value</h3>

<table>
<tr><td><code>verbose=TRUE</code></td>
<td>
<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> that contains the diagnostics results</p>
</td></tr>
<tr><td><code>verbose=FALSE</code></td>
<td>
<p>a <code>logical</code> (of length one) indicating whether the residuals and/or model passes ALL the diagnostics (<code>TRUE</code> if it does, <code>FALSE</code> otherwise)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a><br />
Jonas Kurle, <a href="https://www.jonaskurle.com/">https://www.jonaskurle.com/</a>
</p>


<h3>References</h3>

<p>C. Jarque and A. Bera (1980): 'Efficient Tests for Normality,
Homoscedasticity and Serial Independence'. Economics Letters 6,
pp. 255-259
</p>
<p>G. Ljung and G. Box (1979): 'On a Measure of Lack of Fit in Time
Series Models'. Biometrika 66, pp. 265-270
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arx">arx</a></code>, <code><a href="#topic+getsm">getsm</a></code>, <code><a href="#topic+getsv">getsv</a></code>, <code><a href="#topic+isat">isat</a></code>, <code><a href="#topic+getsFun">getsFun</a></code>, <code><a href="#topic+blocksFun">blocksFun</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##generate some data:
set.seed(123)
vY &lt;- rnorm(20) #the regressand
mX &lt;- matrix(rnorm(3*20), 20, 3) #the regressors
est &lt;- ols(vY,mX)

##return a data-frame with autocorrelation and ARCH diagnostics (default),
##and check whether they pass (the default p-value is 0.025):
diagnostics(est)
diagnostics(est, verbose=FALSE)

##add the Jarque-Bera normality test to the diagnostics (w/p-value=0.05):
diagnostics(est, normality.JarqueB=0.05)
diagnostics(est, normality.JarqueB=0.05, verbose=FALSE)

##user-defined Shapiro-Wilks test for non-normality of the residuals:
SWtest &lt;- function(x, ...){
  tmp &lt;- shapiro.test(x$residuals)
  return( c(tmp$statistic, NA, tmp$p.value) )
}
diagnostics(est, user.fun=list(name="SWtest", pval=0.05))
diagnostics(est, user.fun=list(name="SWtest", pval=0.05), verbose=FALSE)

##user-defined test but diagnostics fail if do not reject (illustration only)
diagnostics(est, user.fun=list(name="SWtest", pval=0.05, is.reject.bad = FALSE))
diagnostics(est, user.fun=list(name="SWtest", pval=0.05, is.reject.bad = FALSE),
  verbose=FALSE)

</code></pre>

<hr>
<h2 id='distorttest'>Jiao-Pretis-Schwarz Outlier Distortion Test</h2><span id='topic+distorttest'></span>

<h3>Description</h3>

<p>Implements the Jiao-Pretis-Schwarz test for coefficient distortion due to outliers by comparing coefficient estimates obtained using OLS to estimates obtained using the robust IIS estimator implemented using <code>isat</code>. See the referenced Jiao-Pretis-Schwarz Paper below for more information.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>  distorttest(x, coef = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distorttest_+3A_x">x</code></td>
<td>
<p>object of class <code><a href="#topic+isat">isat</a></code> </p>
</td></tr>
<tr><td><code id="distorttest_+3A_coef">coef</code></td>
<td>
<p>Either &quot;all&quot; (Default) to test the distortion on all coefficients or a character vector of explanatory variable names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code><a href="#topic+isat">isat</a></code> </p>


<h3>Author(s)</h3>

<p>Xiyu Jiao <a href="https://sites.google.com/view/xiyujiao">https://sites.google.com/view/xiyujiao</a><br /><br />
Felix Pretis <a href="http://www.felixpretis.org">http://www.felixpretis.org</a> <br /><br />
Moritz Schwarz <a href="https://moritzschwarz.org">https://moritzschwarz.org</a><br /><br />
</p>


<h3>References</h3>

<p>Xiyu Jiao, Felix Pretis,and Moritz Schwarz. Testing for Coefficient Distortion due to Outliers with an Application to the Economic Impacts of Climate Change. Available at SSRN: <a href="https://www.ssrn.com/abstract=3915040">https://www.ssrn.com/abstract=3915040</a> or <a href="https://doi.org/10.2139/ssrn.3915040">doi:10.2139/ssrn.3915040</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isat">isat</a>, <a href="#topic+distorttestboot">distorttestboot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:   
data(Nile)
nile &lt;- isat(Nile, sis=FALSE, iis=TRUE, plot=TRUE, t.pval=0.01)
distorttest(nile)

data("hpdata")
# Another example with co-variates
dat &lt;- hpdata[,c("GD", "GNPQ", "FSDJ")]
Y &lt;- ts(dat$GD,start = 1959, frequency = 4)
mxreg &lt;- ts(dat[,c("GNPQ","FSDJ")],start = 1959, frequency = 4)
m1 &lt;- isat(y = Y, mc = TRUE, sis = FALSE, iis = TRUE)
m2 &lt;- isat(y = Y, mc = TRUE, sis = FALSE, iis = TRUE, ar = 1)
m3 &lt;- isat(y = Y, mxreg = mxreg, mc = TRUE, sis = FALSE, iis = TRUE)
m4 &lt;- isat(y = Y, mxreg = mxreg, mc = TRUE, sis = FALSE, iis = TRUE, ar = 1, t.pval = 0.01)
distorttest(m1, coef = "all")
distorttest(m2, coef = "all")
distorttest(m3, coef = "GNPQ")
distorttest(m4, coef = c("ar1", "FSDJ"))
 
## End(Not run) 
</code></pre>

<hr>
<h2 id='distorttestboot'>Bootstrapped Jiao-Pretis-Schwarz Outlier Distortion Test</h2><span id='topic+distorttestboot'></span><span id='topic+print.distorttestboot'></span>

<h3>Description</h3>

<p>Implements the Jiao-Pretis-Schwarz bootstrap test for coefficient distortion due to outliers by comparing coefficient estimates obtained using OLS to estimates obtained using the robust IIS estimator implemented using <code>isat</code>. Three bootstrap schemes are available - using the original sample (not recommended), the clean (outlier-removed) data, and using the clean (outlier-removed) sample with scaled cut-offs used to detect outliers in IIS implemented using isat. See the referenced Jiao-Pretis-Schwarz Paper below for more information.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>
distorttestboot(x, nboot, clean.sample = TRUE, parametric = FALSE, scale.t.pval = 1, 
parallel.options = NULL, quantiles = c(0.90, 0.95, 0.99), ...)

##S3 printing method for objects of class 'distorttestboot':
## S3 method for class 'distorttestboot'
print(x, print.proportion = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distorttestboot_+3A_x">x</code></td>
<td>
<p>object of class <code><a href="#topic+isat">isat</a></code> or the output of the <code><a href="#topic+distorttest">distorttest</a></code> function. </p>
</td></tr>
<tr><td><code id="distorttestboot_+3A_nboot">nboot</code></td>
<td>
<p>numeric. Number of bootstrap replications. A high number of replications are recommended for final estimation (more than 200 at least).</p>
</td></tr>
<tr><td><code id="distorttestboot_+3A_clean.sample">clean.sample</code></td>
<td>
<p>logical. Whether the outlier-removed sample should be used in resampling.</p>
</td></tr>
<tr><td><code id="distorttestboot_+3A_parametric">parametric</code></td>
<td>
<p>logical. Whether to use a parametric bootstrap. Default is non-parametric (FALSE). Parametric currently not implemented for autoregressive models.</p>
</td></tr>
<tr><td><code id="distorttestboot_+3A_scale.t.pval">scale.t.pval</code></td>
<td>
<p>numeric. Scaled target p-value (for selection) relative to the initial p-value used in isat. Default is 1. E.g. a value of 0.5 would scale an initial target p-value of 0.05 to 0.025.</p>
</td></tr>
<tr><td><code id="distorttestboot_+3A_parallel.options">parallel.options</code></td>
<td>
<p>NULL (Default) or an integer, i.e. the number of cores/threads to be used for parallel computing (implemented w/makeCluster and parLapply).</p>
</td></tr>
<tr><td><code id="distorttestboot_+3A_print.proportion">print.proportion</code></td>
<td>
<p>logical. Should the bootstraped Jiao-Pretis Outlier Proportion Test be printed. Default is FALSE.</p>
</td></tr>
<tr><td><code id="distorttestboot_+3A_quantiles">quantiles</code></td>
<td>
<p>numeric vector. Quantiles to be shown based on the bootstrapped results. Default is c(0.90, 0.95, 0.99).</p>
</td></tr>
<tr><td><code id="distorttestboot_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+isat">isat</a></code>.</p>
</td></tr></table>


<h3>Value</h3>

<p>A list including an object of class <code>h-test</code>.</p>


<h3>Author(s)</h3>

<p>Xiyu Jiao <a href="https://sites.google.com/view/xiyujiao">https://sites.google.com/view/xiyujiao</a><br /><br />
Felix Pretis <a href="http://www.felixpretis.org">http://www.felixpretis.org</a> <br /><br />
Moritz Schwarz <a href="https://moritzschwarz.org">https://moritzschwarz.org</a><br /><br />
</p>


<h3>References</h3>

<p>Xiyu Jiao, Felix Pretis,and Moritz Schwarz. Testing for Coefficient Distortion due to Outliers with an Application to the Economic Impacts of Climate Change. Available at SSRN: <a href="https://www.ssrn.com/abstract=3915040">https://www.ssrn.com/abstract=3915040</a> or <a href="https://doi.org/10.2139/ssrn.3915040">doi:10.2139/ssrn.3915040</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isat">isat</a>, <a href="#topic+distorttest">distorttest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
  data(Nile)
  nile &lt;- isat(Nile, sis=FALSE, iis=TRUE, plot=TRUE, t.pval=0.01)
  
  distorttest(nile)
  # bootstrap (with nboot = 5 to save time. Higher replications are recommended)
  distorttestboot(nile, nboot = 5)
  
  data("hpdata")
  # Another example with co-variates
  dat &lt;- hpdata[,c("GD", "GNPQ", "FSDJ")]
  Y &lt;- ts(dat$GD,start = 1959, frequency = 4)
  mxreg &lt;- ts(dat[,c("GNPQ","FSDJ")],start = 1959, frequency = 4)
  m1 &lt;- isat(y = Y, mc = TRUE, sis = FALSE, iis = TRUE)
  m2 &lt;- isat(y = Y, mc = TRUE, sis = FALSE, iis = TRUE, ar = 1)
  m3 &lt;- isat(y = Y, mxreg = mxreg, mc = TRUE, sis = FALSE, iis = TRUE)
  m4 &lt;- isat(y = Y, mxreg = mxreg, mc = TRUE, sis = FALSE, iis = TRUE, ar = 1, t.pval = 0.01)
  distorttest(m1, coef = "all")
  distorttest(m2, coef = "all")
  distorttest(m3, coef = "GNPQ")
  distorttest(m4, coef = c("ar1", "FSDJ"))
  
  # bootstrap (with nboot = 5 to save time. Higher replications are recommended)
  distorttestboot(m1, nboot = 5)
  distorttestboot(m2, nboot = 5)
  distorttestboot(m3, nboot = 5)
  distorttestboot(m4, nboot = 5)
  distorttestboot(m4, nboot = 5, parametric = TRUE, scale.t.pval = 0.5)

  
## End(Not run)
</code></pre>

<hr>
<h2 id='dropvar'>Drop variable</h2><span id='topic+dropvar'></span>

<h3>Description</h3>

<p>Drops columns in a matrix to avoid perfect multicollinearity.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropvar(x, tol=1e-07, LAPACK=FALSE, silent=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dropvar_+3A_x">x</code></td>
<td>
<p>a matrix, possibly less than full column rank.</p>
</td></tr>
<tr><td><code id="dropvar_+3A_tol">tol</code></td>
<td>
<p>numeric value. The tolerance for detecting linear dependencies among regressors, see <code><a href="base.html#topic+qr">qr</a></code> function. Only used if LAPACK is FALSE</p>
</td></tr>
<tr><td><code id="dropvar_+3A_lapack">LAPACK</code></td>
<td>
<p>logical, TRUE or FALSE (default). If true use LAPACK otherwise use LINPACK, see <code><a href="base.html#topic+qr">qr</a></code> function</p>
</td></tr>
<tr><td><code id="dropvar_+3A_silent">silent</code></td>
<td>
<p>logical, TRUE (default) or FALSE. Whether to print a notification whenever a regressor is removed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Original function <code>drop.coef</code> developed by Rune Haubo B. Christensen in package <code>ordinal</code>, <a href="https://cran.r-project.org/package=ordinal">https://cran.r-project.org/package=ordinal</a>.
</p>


<h3>Value</h3>

<p>a matrix whose regressors linearly independent</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen, with modifications by Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a>
</p>


<h3>References</h3>

<p>Rune H.B. Christensen (2014): 'ordinal: Regression Models for Ordinal Data'. <a href="https://cran.r-project.org/package=ordinal">https://cran.r-project.org/package=ordinal</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isat">isat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x &lt;- matrix(rnorm(20), 5)
dropvar(x) #full rank, none are dropped

x[,4] &lt;- x[,1]*2
dropvar(x) #less than full rank, last column dropped
</code></pre>

<hr>
<h2 id='eqwma'>Equally Weighted Moving Average (EqWMA) of the pth. exponentiated values</h2><span id='topic+eqwma'></span><span id='topic+leqwma'></span>

<h3>Description</h3>

<p>The function <code>eqwma</code> returns an Equally Weighted Moving Average (EqWMA) of the pth. exponentiated values lagged <code>k</code> times (the default of <code>k</code> is 1). Optionally, the absolute values are computed before averaging if <code>abs=TRUE</code>, and the natural log of the values is returned if <code>log=TRUE</code>. The function <code>leqwma</code> is a wrapper to <code>eqwma</code> with <code>abs=TRUE</code> and <code>log=TRUE</code>.
</p>
<p>If x is financial return (possibly mean-corrected) and p=2, then this gives the socalled 'historical' model, also known as an integrated ARCH model where the ARCH coefficients all have the same value with sum equal to one. In the log-variance specification the lag of log(EqWMA) is thus a financial volatility proxy. It may be an imperfect proxy compared with high-frequency data (which can also be included as regressors), but - in contrast to high-frequency data - is always available and easy to compute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eqwma(x, length=5, k=1, p=1, abs=FALSE, log=FALSE,  as.vector=FALSE,
  lag=NULL, start=NULL)
leqwma(x, length=5, k=1, p=2, as.vector=FALSE, lag=NULL, start=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eqwma_+3A_x">x</code></td>
<td>
<p>numeric vector, time-series or <code>zoo</code> object</p>
</td></tr>
<tr><td><code id="eqwma_+3A_length">length</code></td>
<td>
<p>integer or vector of integers each equal to or greater than 1. The length or lengths of the moving window or windows of averages</p>
</td></tr>
<tr><td><code id="eqwma_+3A_k">k</code></td>
<td>
<p>integer that determines how many periods the term(s) should be lagged. If 0 (or smaller), then the moving averages are not lagged</p>
</td></tr>
<tr><td><code id="eqwma_+3A_p">p</code></td>
<td>
<p>numeric value. The exponent p in x^p when <code>abs=FALSE</code>, and in abs(x)^p when <code>abs=TRUE</code> </p>
</td></tr>
<tr><td><code id="eqwma_+3A_log">log</code></td>
<td>
<p>logical with default <code>FALSE</code>. If <code>TRUE</code>, then the logarithm of the moving average is returned</p>
</td></tr>
<tr><td><code id="eqwma_+3A_abs">abs</code></td>
<td>
<p>logical with default <code>FALSE</code>. If <code>TRUE</code>, then x is transformed to absolute values before x is exponentiated</p>
</td></tr>
<tr><td><code id="eqwma_+3A_as.vector">as.vector</code></td>
<td>
<p>logical with default <code>FALSE</code>. If <code>TRUE</code>, and if <code>length(length)==1</code>, then the result is returned as a vector. Otherwise the returned value is always a matrix</p>
</td></tr>
<tr><td><code id="eqwma_+3A_lag">lag</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="eqwma_+3A_start">start</code></td>
<td>
<p>deprecated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The intended primary use of <code>eqwma</code> is to construct mixed frequency regressors for the mean specification of an <code><a href="#topic+arx">arx</a></code> model.
</p>
<p>The intended primary use of <code>leqwma</code> is to construct volatility proxies for the log-variance specification in an <code><a href="#topic+arx">arx</a></code> model. In the latter case, the default is the lagged log of an equally weighted moving average of the squared residuals, where each average is made up of m observations. This is equivalent to an integrated ARCH(p) model where the p coefficients are all equal. For further details on the use of log(EqWMA) as a volatility proxy, see Sucarrat and Escribano (2012).
</p>


<h3>Value</h3>

<p>numeric matrix, vector or <code><a href="zoo.html#topic+zoo">zoo</a></code> object</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a> </p>


<h3>References</h3>

<p>Genaro Sucarrat and Alvaro Escribano (2012): 'Automated Financial
Model Selection: General-to-Specific Modelling of the Mean and
Volatility Specifications', Oxford Bulletin of Economics and
Statistics 74, Issue no. 5 (October), pp. 716-735
</p>
<p>Pretis, Felix, Reade, James and Sucarrat, Genaro (2018): 'Automated General-to-Specific (GETS) Regression Modeling and Indicator Saturation for Outliers and Structural Breaks'. Journal of Statistical Software 86, Number 3, pp. 1-44
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+zoo">zoo</a></code>, <code><a href="#topic+arx">arx</a></code>, <code><a href="#topic+getsm">getsm</a></code>, <code><a href="#topic+getsv">getsv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##generate an iid normal series:
set.seed(123)
x &lt;- rnorm(100)

##compute lag of EqWMA(20) for x^2:
eqwma(x, p=2)

##compute lag of EqWMA(5) and lag of EqWMA(10) for x:
eqwma(x, length=c(5,10))

##compute lag of log(EqWMA(20)) for x^2:
leqwma(x)

#compute lag of log(EqWMA(5)) and lag of log(EqWMA(8))
#for abs(x)^2:
leqwma(x, length=c(4,8))

</code></pre>

<hr>
<h2 id='ES'>Conditional Value-at-Risk (VaR) and Expected Shortfall (ES)</h2><span id='topic+ES'></span><span id='topic+VaR'></span>

<h3>Description</h3>

<p>Extract the in-sample conditional Value-at-Risk, or the in-sample conditional Expected Shortfall for the chosen risk level(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ES(object, level=0.99, type=7, ...)
VaR(object, level=0.99, type=7, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ES_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+arx">arx</a></code> or <code>gets</code> object</p>
</td></tr>
<tr><td><code id="ES_+3A_level">level</code></td>
<td>
<p>the risk level(s), must be between 0 and 1</p>
</td></tr>
<tr><td><code id="ES_+3A_type">type</code></td>
<td>
<p>the method used to compute the empirical quantiles of the standardised residuals</p>
</td></tr>
<tr><td><code id="ES_+3A_...">...</code></td>
<td>
<p>arguments passed on (currently not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or matrix containing either the conditional Value-at-Risk (VaR) or the conditional Expected Shortfall (ES) for the chosen risk level(s).
</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+arx">arx</a></code>, <code><a href="#topic+getsm">getsm</a></code>, <code><a href="#topic+getsv">getsv</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>##generate random variates, estimate model:
y &lt;- rnorm(50)
mymodel &lt;- arx(y, arch=1)

##extract 99% expected shortfall:
ES(mymodel)

##extract 99%, 95% and 90% expected shortfalls:
ES(mymodel, level=c(0.99, 0.95, 0.9))

##extract 99% value-at-risk:
VaR(mymodel)

##extract 99%, 95% and 90% values-at-risk:
VaR(mymodel, level=c(0.99, 0.95, 0.9))
</code></pre>

<hr>
<h2 id='eviews'>Exporting results to EViews and STATA</h2><span id='topic+eviews'></span><span id='topic+stata'></span>

<h3>Description</h3>

<p>Functions that facilitate the export of results to the commercial econometric softwares EViews and STATA, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eviews(object, file=NULL, print=TRUE, return=FALSE)
stata(object, file=NULL, print=TRUE, return=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eviews_+3A_object">object</code></td>
<td>
<p>an <code>arx</code>, <code>gets</code> or <code>isat</code> object</p>
</td></tr>
<tr><td><code id="eviews_+3A_file">file</code></td>
<td>
<p>filename, i.e. the destination of the exported data</p>
</td></tr>
<tr><td><code id="eviews_+3A_print">print</code></td>
<td>
<p>logical. If TRUE, then the estimation code in EViews (or STATA) is printed</p>
</td></tr>
<tr><td><code id="eviews_+3A_return">return</code></td>
<td>
<p>logical. If TRUE, then a list is returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either printed text or a <code>list</code> (if return=TRUE)</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arx">arx</a></code>, <code><a href="#topic+getsm">getsm</a></code>, <code><a href="#topic+getsv">getsv</a></code>, <code><a href="#topic+isat">isat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##simulate random variates, estimate model:
y &lt;- rnorm(30)
mX &lt;- matrix(rnorm(30*2), 30, 2)
mymod &lt;- arx(y, mc=TRUE, mxreg=mX)

##print EViews code:
eviews(mymod)

##print Stata code:
stata(mymod)
</code></pre>

<hr>
<h2 id='gets'>General-to-Specific (GETS) Modelling</h2><span id='topic+gets'></span><span id='topic+gets.arx'></span>

<h3>Description</h3>

<p>For an overview of the <b>gets</b> package, see <code><a href="#topic+gets-package">gets-package</a></code>. Here, documentation of generic functions for GETS modelling is provided. Note that <code>gets.arx</code> is a convenience wrapper to <code><a href="#topic+getsm">getsm</a></code> and <code><a href="#topic+getsv">getsv</a></code>. For specific GETS methods for <code>lm</code>, <code>logitx</code> and <code>isat</code> models, see <code><a href="#topic+gets.lm">gets.lm</a></code>, <code><a href="#topic+gets.logitx">gets.logitx</a></code> and <code><a href="#topic+gets.isat">gets.isat</a></code>, respectively. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gets(x, ...)

## S3 method for class 'arx'
gets(x, spec=NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gets_+3A_x">x</code></td>
<td>
<p>an object to be subjected to GETS modelling</p>
</td></tr>
<tr><td><code id="gets_+3A_spec">spec</code></td>
<td>
<p><code>NULL</code> (default), <code>"mean"</code> or <code>"variance"</code>. If <code>"mean"</code>, then <code><a href="#topic+getsm">getsm</a></code> is called. If <code>"variance"</code>, then <code><a href="#topic+getsv">getsv</a></code> is called. If <code>NULL</code>, then it is automatically determined whether GETS-modelling of the mean or log-variance specification should be undertaken.</p>
</td></tr>
<tr><td><code id="gets_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>gets.arx</code> is a convenience wrapper to <code><a href="#topic+getsm">getsm</a></code> and <code><a href="#topic+getsv">getsv</a></code>. 
</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getsm">getsm</a></code>, <code><a href="#topic+getsv">getsv</a></code>, <code><a href="#topic+getsFun">getsFun</a></code>, <code><a href="#topic+blocksFun">blocksFun</a></code>
</p>

<hr>
<h2 id='gets.isat'>General-to-Specific (GETS) Modelling 'isat' objects</h2><span id='topic+gets.isat'></span>

<h3>Description</h3>

<p>General-to-Specific (GETS) Modelling of a objects of class <code><a href="#topic+isat">isat</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'isat'
gets(x, t.pval=0.05, wald.pval=t.pval, vcov.type=NULL,
  do.pet=TRUE, ar.LjungB=list(lag=NULL, pval=0.025),
  arch.LjungB=list(lag=NULL, pval=0.025), normality.JarqueB=NULL,
  user.diagnostics=NULL, info.method=c("sc","aic","aicc","hq"),
  gof.function=NULL, gof.method=NULL, keep=NULL, include.gum=FALSE,
  include.1cut=TRUE, include.empty=FALSE, max.paths=NULL, tol=1e-07,
  turbo=FALSE, print.searchinfo=TRUE, plot=NULL, alarm=FALSE,...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gets.isat_+3A_x">x</code></td>
<td>
<p>an object of class 'isat'</p>
</td></tr>
<tr><td><code id="gets.isat_+3A_t.pval">t.pval</code></td>
<td>
<p>numeric value between 0 and 1. The significance level used for the two-sided regressor significance t-tests</p>
</td></tr>
<tr><td><code id="gets.isat_+3A_wald.pval">wald.pval</code></td>
<td>
<p>numeric value between 0 and 1. The significance level used for the Parsimonious Encompassing Tests (PETs). By default, it is the same as <code>t.pval</code></p>
</td></tr>
<tr><td><code id="gets.isat_+3A_vcov.type">vcov.type</code></td>
<td>
<p>the type of variance-covariance matrix used. If <code>NULL</code> (default), then the type used in the estimation of the 'arx' object is used. This can be overridden by either &quot;ordinary&quot; (i.e. the ordinary variance-covariance matrix) or &quot;white&quot; (i.e. the White (1980) heteroscedasticity robust variance-covariance matrix)</p>
</td></tr>
<tr><td><code id="gets.isat_+3A_do.pet">do.pet</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), then a Parsimonious Encompassing Test (PET) against the GUM is undertaken at each regressor removal for the joint significance of all the deleted regressors along the current path. If <code>FALSE</code>, then a PET is not undertaken at each regressor removal</p>
</td></tr>
<tr><td><code id="gets.isat_+3A_ar.ljungb">ar.LjungB</code></td>
<td>
<p>a two-item list with names <code>lag</code> and <code>pval</code>, or <code>NULL</code>. In the former case <code>lag</code> contains the order of the Ljung and Box (1979) test for serial correlation in the standardised residuals, and <code>pval</code> contains the significance level. If <code>lag=NULL</code> (default), then the order used is that of the estimated 'arx' object. If <code>ar.Ljungb=NULL</code>, then the standardised residuals are not checked for serial correlation</p>
</td></tr>
<tr><td><code id="gets.isat_+3A_arch.ljungb">arch.LjungB</code></td>
<td>
<p>a two-item list with names <code>lag</code> and <code>pval</code>, or <code>NULL</code>. In the former case, <code>lag</code> contains the order of the Ljung and Box (1979) test for serial correlation in the squared standardised residuals, and <code>pval</code> contains the significance level. If <code>lag=NULL</code> (default), then the order used is that of the estimated 'arx' object. If <code>arch.Ljungb=NULL</code>, then the standardised residuals are not checked for ARCH</p>
</td></tr>
<tr><td><code id="gets.isat_+3A_normality.jarqueb">normality.JarqueB</code></td>
<td>
<p>a value between 0 and 1, or <code>NULL</code>. In the former case, the Jarque and Bera (1980) test for non-normality is conducted using a significance level equal to the numeric value. If <code>NULL</code>, then no test for non-normality is undertaken</p>
</td></tr>
<tr><td><code id="gets.isat_+3A_user.diagnostics">user.diagnostics</code></td>
<td>
<p><code>NULL</code> or a <code><a href="base.html#topic+list">list</a></code> with two entries, <code>name</code> and <code>pval</code>, see the <code>user.fun</code> argument in <code><a href="#topic+diagnostics">diagnostics</a></code> </p>
</td></tr>
<tr><td><code id="gets.isat_+3A_info.method">info.method</code></td>
<td>
<p>character string, &quot;sc&quot; (default), &quot;aic&quot; or &quot;hq&quot;, which determines the information criterion to be used when selecting among terminal models. The abbreviations are short for the Schwarz or Bayesian information criterion (sc), the Akaike information criterion (aic) and the Hannan-Quinn (hq) information criterion</p>
</td></tr>
<tr><td><code id="gets.isat_+3A_gof.function">gof.function</code></td>
<td>
<p><code>NULL</code> (default) or a <code>list</code>, see <code><a href="#topic+getsFun">getsFun</a></code>. If <code>NULL</code>, then <code><a href="#topic+infocrit">infocrit</a></code> is used </p>
</td></tr>
<tr><td><code id="gets.isat_+3A_gof.method">gof.method</code></td>
<td>
<p><code>NULL</code> (default) or a <code>character</code>, see <code><a href="#topic+getsFun">getsFun</a></code>. If <code>NULL</code> and <code>gof.function</code> is also <code>NULL</code>, then the best goodness-of-fit is characterised by a minimum value</p>
</td></tr>
<tr><td><code id="gets.isat_+3A_keep">keep</code></td>
<td>
<p>the regressors to be excluded from removal in the specification search. Note that <code>keep=c(1)</code> is obligatory when using <code>getsv</code>. This excludes the log-variance intercept from removal. The regressor numbering is contained in the <code>reg.no</code> column of the GUM</p>
</td></tr>
<tr><td><code id="gets.isat_+3A_include.gum">include.gum</code></td>
<td>
<p>logical. If <code>TRUE</code>, then the GUM (i.e. the starting model) is included among the terminal models. If <code>FALSE</code> (default), then the GUM is not included</p>
</td></tr>
<tr><td><code id="gets.isat_+3A_include.1cut">include.1cut</code></td>
<td>
<p>logical. If <code>TRUE</code>, then the 1-cut model is added to the list of terminal models. If <code>FALSE</code> (default), then the 1-cut is not added, unless it is a terminal model in one of the paths </p>
</td></tr>
<tr><td><code id="gets.isat_+3A_include.empty">include.empty</code></td>
<td>
<p>logical. If <code>TRUE</code>, then an empty model is included among the terminal models, if it passes the diagnostic tests, even if it is not equal to one of the terminals. If <code>FALSE</code> (default), then the empty model is not included (unless it is one of the terminals)</p>
</td></tr>
<tr><td><code id="gets.isat_+3A_max.paths">max.paths</code></td>
<td>
<p><code>NULL</code> (default) or an integer greater than 0. If <code>NULL</code>, then there is no limit to the number of paths. If an integer (e.g. 1), then this integer constitutes the maximum number of paths searched (e.g. a single path) </p>
</td></tr>
<tr><td><code id="gets.isat_+3A_tol">tol</code></td>
<td>
<p>numeric value. The tolerance for detecting linear dependencies in the columns of the variance-covariance matrix when computing the Wald-statistic used in the Parsimonious Encompassing Tests (PETs), see the <code><a href="base.html#topic+qr.solve">qr.solve</a></code> function</p>
</td></tr>
<tr><td><code id="gets.isat_+3A_turbo">turbo</code></td>
<td>
<p>logical. If <code>TRUE</code>, then (parts of) paths are not searched twice (or more) unnecessarily, thus yielding a significant potential for speed-gain. However, the checking of whether the search has arrived at a point it has already been comes with a slight computational overhead. Accordingly, if <code>turbo=TRUE</code>, then the total search time might in fact be higher than if <code>turbo=FALSE</code>. This happens if estimation is very fast, say, less than quarter of a second. Hence the default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="gets.isat_+3A_print.searchinfo">print.searchinfo</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), then a print is returned whenever simiplification along a new path is started</p>
</td></tr>
<tr><td><code id="gets.isat_+3A_plot">plot</code></td>
<td>
<p><code>NULL</code> or logical. If <code>TRUE</code>, then the fitted values and the residuals of the final model are plotted after model selection. If <code>FALSE</code>, then they are not. If <code>NULL</code> (default), then the value set by <code><a href="base.html#topic+options">options</a></code> determines whether a plot is produced or not</p>
</td></tr>
<tr><td><code id="gets.isat_+3A_alarm">alarm</code></td>
<td>
<p>logical. If <code>TRUE</code>, then a sound or beep is emitted (in order to alert the user) when the model selection ends</p>
</td></tr>
<tr><td><code id="gets.isat_+3A_...">...</code></td>
<td>
<p>further arguments passed on to and from methods </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, <code>gets.isat</code> invokes <code><a href="#topic+getsm">getsm</a></code> for the GETS-modelling.
</p>


<h3>Value</h3>

<p>A list of class <code><a href="#topic+gets">gets</a></code>.  </p>


<h3>Author(s)</h3>

<p>Moritz Schwarz, <a href="https://www.inet.ox.ac.uk/people/moritz-schwarz/">https://www.inet.ox.ac.uk/people/moritz-schwarz/</a><br />
Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isat">isat</a></code>, <code><a href="#topic+getsm">getsm</a></code>, <code><a href="#topic+getsFun">getsFun</a></code>, <code><a href="#topic+paths">paths</a></code> and <code><a href="#topic+terminals">terminals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##generate some data:
#set.seed(123) #for reproducibility
#y &lt;- rnorm(30) #generate Y
#isatmod &lt;- isat(y)
#gets(isatmot)

</code></pre>

<hr>
<h2 id='gets.lm'>General-to-Specific (GETS) Modelling 'lm' objects</h2><span id='topic+gets.lm'></span>

<h3>Description</h3>

<p>General-to-Specific (GETS) Modelling of objects of class <code><a href="stats.html#topic+lm">lm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm'
gets(x, keep = NULL, include.1cut = TRUE, print.searchinfo = TRUE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gets.lm_+3A_x">x</code></td>
<td>
<p>an object of class 'lm', see <code><a href="stats.html#topic+lm">lm</a></code> </p>
</td></tr>
<tr><td><code id="gets.lm_+3A_keep">keep</code></td>
<td>
<p><code>NULL</code> or a vector of integers that determines which regressors to be excluded from removal in the specification search </p>
</td></tr>
<tr><td><code id="gets.lm_+3A_include.1cut">include.1cut</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> (default), then the 1-cut model is added to the list of terminal models. If <code>FALSE</code>, then the 1-cut is not added, unless it is a terminal model in one of the paths </p>
</td></tr>
<tr><td><code id="gets.lm_+3A_print.searchinfo">print.searchinfo</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> (default), then selected info is printed during search </p>
</td></tr>
<tr><td><code id="gets.lm_+3A_...">...</code></td>
<td>
<p>further arguments passed on to <code><a href="#topic+getsFun">getsFun</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, <code>gets.lm</code> invokes <code><a href="#topic+getsFun">getsFun</a></code> for the GETS-modelling, which is also invoked by <code><a href="#topic+getsm">getsm</a></code>. See their help pages for more information.
</p>


<h3>Value</h3>

<p>A list of class <code><a href="stats.html#topic+lm">lm</a></code>. Note that the 'top' of the list contains information (paths and terminal models) from the GETS modelling, see <code><a href="#topic+paths">paths</a></code> and <code><a href="#topic+terminals">terminals</a></code> </p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="#topic+getsFun">getsFun</a></code>, <code><a href="#topic+getsm">getsm</a></code>, <code><a href="#topic+paths">paths</a></code> and <code><a href="#topic+terminals">terminals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##generate some data:
set.seed(123) #for reproducibility
y &lt;- rnorm(30) #generate Y
x &lt;- matrix(rnorm(30*10), 30, 10) #matrix of Xs
colnames(x) &lt;- paste0("var", 1:NCOL(x))

##estimate model:
mymod &lt;- lm(y ~ x)

##do gets modelling:
gets(mymod)

##ensure intercept is not removed:
gets(mymod, keep=1)

</code></pre>

<hr>
<h2 id='gets.logitx'>General-to-Specific (GETS) Modelling of objects of class 'logitx'</h2><span id='topic+gets.logitx'></span>

<h3>Description</h3>

<p>General-to-Specific (GETS) Modelling of a dynamic Autoregressive (AR) logit model with covariates ('X') of class 'dlogitx'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'logitx'
gets(x, t.pval = 0.05, wald.pval = t.pval, do.pet = TRUE, 
    user.diagnostics = NULL, keep = NULL, include.gum = FALSE,
    include.1cut = TRUE, include.empty = FALSE, max.paths = NULL,
    turbo = TRUE, print.searchinfo = TRUE, plot = NULL, alarm = FALSE,
    ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gets.logitx_+3A_x">x</code></td>
<td>
<p>an object of class 'logitx', see <code><a href="#topic+logitx">logitx</a></code> </p>
</td></tr>
<tr><td><code id="gets.logitx_+3A_t.pval">t.pval</code></td>
<td>
<p>numeric value between 0 and 1. The significance level used for the two-sided regressor significance t-tests</p>
</td></tr>
<tr><td><code id="gets.logitx_+3A_wald.pval">wald.pval</code></td>
<td>
<p>numeric value between 0 and 1. The significance level used for the Parsimonious Encompassing Tests (PETs). By default, it is the same as <code>t.pval</code></p>
</td></tr>
<tr><td><code id="gets.logitx_+3A_do.pet">do.pet</code></td>
<td>
<p><code>logical</code> that determines whether a Parsimonious Encompassing Test (PET) against the GUM should be undertaken at each regressor removal for the joint significance of all the deleted regressors along the current path. If <code>FALSE</code>, then a PET is not undertaken at each regressor removal </p>
</td></tr>
<tr><td><code id="gets.logitx_+3A_user.diagnostics">user.diagnostics</code></td>
<td>
<p><code>NULL</code> (default) or a <code>list</code> with two entries, <code>name</code> and <code>pval</code>, see <code><a href="#topic+getsFun">getsFun</a></code></p>
</td></tr>
<tr><td><code id="gets.logitx_+3A_keep">keep</code></td>
<td>
<p><code>NULL</code> or a vector of integers that determines which regressors to be excluded from removal in the specification search </p>
</td></tr>
<tr><td><code id="gets.logitx_+3A_include.gum">include.gum</code></td>
<td>
<p><code>logical</code> that determines whether the GUM (i.e. the starting model) should be included among the terminal models. If <code>FALSE</code> (default), then the GUM is not included </p>
</td></tr>
<tr><td><code id="gets.logitx_+3A_include.1cut">include.1cut</code></td>
<td>
<p><code>logical</code> that determines whether the 1-cut model should be added to the list of terminal models. If <code>FALSE</code> (default), then the 1-cut is not added, unless it is a terminal model in one of the paths </p>
</td></tr>
<tr><td><code id="gets.logitx_+3A_include.empty">include.empty</code></td>
<td>
<p><code>logical</code> that determines whether an empty model should be added to the list of terminal models, if it passes the diagnostic tests. If <code>FALSE</code> (default), then the empty model is not added, unless it is a terminal model in one of the paths </p>
</td></tr>
<tr><td><code id="gets.logitx_+3A_max.paths">max.paths</code></td>
<td>
<p><code>NULL</code> (default) or an integer greater than 0. If <code>NULL</code>, then there is no limit to the number of paths. If an integer (e.g. 1), then this integer constitutes the maximum number of paths searched (e.g. a single path) </p>
</td></tr>
<tr><td><code id="gets.logitx_+3A_turbo">turbo</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> (the default), then (parts of) paths are not searched twice (or more) unnecessarily, thus yielding a significant potential for speed-gain. The checking of whether the search has arrived at a point it has already been at comes with a slight computational overhead. So faster search is not guaranteed when <code>turbo=TRUE</code> </p>
</td></tr>
<tr><td><code id="gets.logitx_+3A_print.searchinfo">print.searchinfo</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> (default), then a print is returned whenever simiplification along a new path is started</p>
</td></tr>
<tr><td><code id="gets.logitx_+3A_plot">plot</code></td>
<td>
<p><code>NULL</code> or logical. If <code>TRUE</code>, then a plot is produced. If <code>NULL</code> (default), then the value set by <code><a href="base.html#topic+options">options</a></code> determines whether a plot is produced or not</p>
</td></tr>
<tr><td><code id="gets.logitx_+3A_alarm">alarm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, then a sound or beep is emitted (in order to alert the user) when the model selection ends </p>
</td></tr>
<tr><td><code id="gets.logitx_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model of class 'logitx' is a dynamic Autoregressive (AR) logit model with (optional) covariates ('X') proposed by Kauppi and Saikkonen (2008). Internally, <code>gets.logitx</code> undertakes the General-to-Specific (GETS) modelling with the <code><a href="#topic+getsFun">getsFun</a></code> function, see Sucarrat (2020). 
</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a>
</p>


<h3>References</h3>

<p>Heikki Kauppi and Penti Saikkonen (2008): 'Predicting U.S. Recessions with Dynamic Binary Response Models'. The Review of Economic Statistics 90, pp. 777-791
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logitx">logitx</a></code>, <code><a href="#topic+logitxSim">logitxSim</a></code>, <code><a href="#topic+coef.logitx">coef.logitx</a></code>, <code><a href="#topic+getsFun">getsFun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##simulate from ar(1), create covariates:
set.seed(123) #for reproducibility
y &lt;- logitxSim(100, ar=0.3)
x &lt;- matrix(rnorm(5*100), 100, 5)

##estimate model:
mymod &lt;- logitx(y, ar=1:4, xreg=x)

##do gets modelling:
gets(mymod)

</code></pre>

<hr>
<h2 id='getsFun'>General-to-Specific (GETS) modelling function</h2><span id='topic+getsFun'></span>

<h3>Description</h3>

<p>Auxiliary function (i.e. not intended for the average user) that enables fast and efficient GETS-modelling with user-specified estimators and models, and user-specified diagnostics and goodness-of-fit criteria. The function is called by and relied upon by <code><a href="#topic+getsm">getsm</a></code>, <code><a href="#topic+getsv">getsv</a></code>, <code><a href="#topic+isat">isat</a></code> and <code><a href="#topic+blocksFun">blocksFun</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getsFun(y, x, untransformed.residuals=NULL,
  user.estimator=list(name="ols"), gum.result=NULL, t.pval=0.05,
  wald.pval=t.pval, do.pet=TRUE, ar.LjungB=NULL, arch.LjungB=NULL,
  normality.JarqueB=NULL, user.diagnostics=NULL,
  gof.function=list(name="infocrit"), gof.method=c("min", "max"),
  keep=NULL, include.gum=FALSE, include.1cut=FALSE,
  include.empty=FALSE, max.paths=NULL, turbo=FALSE, tol=1e-07,
  LAPACK=FALSE, max.regs=NULL, print.searchinfo=TRUE, alarm=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getsFun_+3A_y">y</code></td>
<td>
<p>a numeric vector (with no missing values, i.e. no non-numeric 'holes')</p>
</td></tr>
<tr><td><code id="getsFun_+3A_x">x</code></td>
<td>
<p>a <code>matrix</code> or <code>NULL</code> </p>
</td></tr>
<tr><td><code id="getsFun_+3A_untransformed.residuals">untransformed.residuals</code></td>
<td>
<p><code>NULL</code> (default) or, when <code><a href="#topic+ols">ols</a></code> is used with <code>method=6</code> in <code>user.estimator</code>, a numeric vector containing the untransformed residuals </p>
</td></tr>
<tr><td><code id="getsFun_+3A_user.estimator">user.estimator</code></td>
<td>
<p>a <code>list</code>. The first item should be named <code>name</code> and contain the name (a character) of the estimation function (the default is <code>"ols"</code>). Additional items, if any, in the list <code>user.estimator</code> are passed on as arguments to the estimator in question. Optionally, the list can also contain an item named <code>envir</code>, a character, which indicates the environment in which the user-specified estimator resides. The value returned by the user-specified estimator should be a <code>list</code>, see details </p>
</td></tr>
<tr><td><code id="getsFun_+3A_gum.result">gum.result</code></td>
<td>
<p>a <code>list</code> with the estimation results of the General Unrestricted Model (GUM), or <code>NULL</code> (default). If the estimation results of the GUM are already available, then re-estimation of the GUM is skipped if the estimation results are provided via this argument</p>
</td></tr>
<tr><td><code id="getsFun_+3A_t.pval">t.pval</code></td>
<td>
<p><code>numeric</code> value between 0 and 1. The significance level used for the two-sided regressor significance t-tests </p>
</td></tr>
<tr><td><code id="getsFun_+3A_wald.pval">wald.pval</code></td>
<td>
<p><code>numeric</code> value between 0 and 1. The significance level used for the Parsimonious Encompassing Tests (PETs) </p>
</td></tr>
<tr><td><code id="getsFun_+3A_do.pet">do.pet</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> (default), then a Parsimonious Encompassing Test (PET) against the GUM is undertaken at each regressor removal for the joint significance of all the deleted regressors along the current path. If <code>FALSE</code>, then a PET is not undertaken at each regressor removal</p>
</td></tr>
<tr><td><code id="getsFun_+3A_ar.ljungb">ar.LjungB</code></td>
<td>
<p>a two element <code>vector</code> or <code>NULL</code> (default). In the former case, the first element contains the AR-order, the second element the significance level. If <code>NULL</code>, then a test for autocorrelation is not conducted</p>
</td></tr>
<tr><td><code id="getsFun_+3A_arch.ljungb">arch.LjungB</code></td>
<td>
<p>a two element <code>vector</code> or <code>NULL</code> (default). In the former case, the first element contains the ARCH-order, the second element the significance level. If <code>NULL</code>, then a test for ARCH is not conducted</p>
</td></tr>
<tr><td><code id="getsFun_+3A_normality.jarqueb">normality.JarqueB</code></td>
<td>
<p><code>NULL</code> or a <code>numeric</code> value between 0 and 1. In the latter case, a test for non-normality is conducted using a significance level equal to <code>normality.JarqueB</code>. If <code>NULL</code>, then no test for non-normality is conducted</p>
</td></tr>
<tr><td><code id="getsFun_+3A_user.diagnostics">user.diagnostics</code></td>
<td>
<p><code>NULL</code> (default) or a <code>list</code> with two entries, <code>name</code> and <code>pval</code>. The first item (<code>name</code>) should contain the name of the user-defined function, and must be of class <code>character</code>. The second item should contain the chosen significance level or levels, i.e. either a scalar or a vector of length equal to the number of p-values returned by the user-defined diagnostics function, see details. Optionally, the list <code>user.diagnostics</code> can also contain a third item named <code>envir</code>, a character, which indicates the environment in which the user-defined function resides </p>
</td></tr>
<tr><td><code id="getsFun_+3A_gof.function">gof.function</code></td>
<td>
<p>a <code>list</code>. The first item should be named <code>name</code> and contain the name (a character) of the Goodness-of-Fit (GOF) function used. Additional items in the list <code>gof.function</code> are passed on as arguments to the GOF-function. The value returned by the GOF-function should be a numeric value (of length 1). Optionally, the list <code>gof.function</code> can also contain an item named <code>envir</code>, a character, which indicates the environment in which the user-defined function resides </p>
</td></tr>
<tr><td><code id="getsFun_+3A_gof.method">gof.method</code></td>
<td>
<p>a <code>character</code>. Determines whether the best Goodness-of-Fit is a minimum or maximum</p>
</td></tr>
<tr><td><code id="getsFun_+3A_keep">keep</code></td>
<td>
<p><code>NULL</code> or an integer vector that indicates which regressors to be excluded from removal in the search</p>
</td></tr>
<tr><td><code id="getsFun_+3A_include.gum">include.gum</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, then the GUM (i.e. the starting model) is included among the terminal models. If <code>FALSE</code> (default), then the GUM is not included</p>
</td></tr>
<tr><td><code id="getsFun_+3A_include.1cut">include.1cut</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, then the 1-cut model is added to the list of terminal models. If <code>FALSE</code> (default), then the 1-cut is not added, unless it is a terminal model in one of the paths </p>
</td></tr>
<tr><td><code id="getsFun_+3A_include.empty">include.empty</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, then the empty model is added to the list of terminal models. If <code>FALSE</code> (default), then the empty model is not added, unless it is a terminal model in one of the paths </p>
</td></tr>
<tr><td><code id="getsFun_+3A_max.paths">max.paths</code></td>
<td>
<p><code>NULL</code> (default) or an integer greater than 0. If <code>NULL</code>, then there is no limit to the number of paths. If an integer (e.g. 1), then this integer constitutes the maximum number of paths searched (e.g. a single path) </p>
</td></tr>
<tr><td><code id="getsFun_+3A_turbo">turbo</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, then (parts of) paths are not searched twice (or more) unnecessarily, thus yielding a significant potential for speed-gain. However, the checking of whether the search has arrived at a point it has already been comes with a slight computational overhead. Accordingly, if <code>turbo=TRUE</code>, then the total search time might in fact be higher than if <code>turbo=FALSE</code>. This happens if estimation is very fast, say, less than quarter of a second. Hence the default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="getsFun_+3A_tol">tol</code></td>
<td>
<p>numeric value (<code>default = 1e-07</code>). The tolerance for detecting linear dependencies in the columns of the variance-covariance matrix when computing the Wald-statistic used in the Parsimonious Encompassing Tests (PETs), see the <code><a href="base.html#topic+qr.solve">qr.solve</a></code> function</p>
</td></tr>
<tr><td><code id="getsFun_+3A_lapack">LAPACK</code></td>
<td>
<p>currently not used</p>
</td></tr>
<tr><td><code id="getsFun_+3A_max.regs">max.regs</code></td>
<td>
<p><code>integer</code>. The maximum number of regressions along a deletion path. Do not alter unless you know what you are doing! </p>
</td></tr>
<tr><td><code id="getsFun_+3A_print.searchinfo">print.searchinfo</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> (default), then a print is returned whenever simiplification along a new path is started</p>
</td></tr>
<tr><td><code id="getsFun_+3A_alarm">alarm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, then a sound or beep is emitted (in order to alert the user) when the model selection ends </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value returned by the estimator specified in <code>user.estimator</code> should be a <code><a href="base.html#topic+list">list</a></code> containing at least six items: &quot;coefficients&quot;, &quot;df&quot;, &quot;vcov&quot;, &quot;logl&quot;, &quot;n&quot; and &quot;k&quot;. The item &quot;coefficients&quot; should be a vector of length <code>NCOL(x)</code> containing the estimated coefficients. The item named &quot;df&quot; is used to compute the <em>p</em>-values associated with the <em>t</em>-statistics, i.e. coef/std.err. The item named &quot;vcov&quot; contains the (symmetric) coefficient-covariance matrix of the estimated coefficients. The items &quot;logl&quot; (the log-likelihood), &quot;n&quot; (the number of observations) and &quot;k&quot; (the number of estimated parameters; not necessarily equal to the number of coefficients) are used to compute the information criterion. Finally, the estimator MUST be able to handle empty regressor-matrices (i.e. <code>is.null(x)=TRUE</code> or <code>NCOL(x)=0</code>). In this case, then the first three items (i.e. &quot;coefficients&quot;, &quot;df&quot; and &quot;vcov&quot;) can - and should - be <code>NULL</code>.
</p>
<p>The argument <code>user.estimator</code> enables the user to specify an estimator that differs from the default (<code><a href="#topic+ols">ols</a></code>). To do this, the argument should be a list with at least one entry, name (of class character), that contains the name of the user-defined function. The call to this function is executed with <code><a href="base.html#topic+do.call">do.call</a></code>, whose default value on <code>envir</code> is <code>parent.frame()</code>. Usually, this will be the global environment (<code>.GlobalEnv</code>), but it can be changed by adding an entry named <code>envir</code> to the list that indicates where the user-defined function resides. 
</p>
<p>The argument <code>user.diagnostics</code> enables the user to specify additional - or alternative - diagnostics, see <code><a href="#topic+diagnostics">diagnostics</a></code>.
</p>
<p>The argument <code>gof.function</code> enables the user to specify a goodness-of-fit function that differs from the default (<code><a href="#topic+infocrit">infocrit</a></code>). The principles to follow are the same as that of <code>user.estimator</code>: The argument should be a <code>list</code> with at least one entry, name, that contains the name of the user-defined function, additional entries in the list are passed on to the user-specified goodness-of-fit function, and optionally an entry named <code>envir</code> may indicate where the user-defined function resides.   
</p>


<h3>Value</h3>

<p>A <code>list</code> with the results of the specification search.</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a> </p>


<h3>References</h3>

<p>C. Jarque and A. Bera (1980): 'Efficient Tests for Normality, Homoscedasticity and Serial Independence'. Economics Letters 6, pp. 255-259
</p>
<p>G. Ljung and G. Box (1979): 'On a Measure of Lack of Fit in Time Series Models'. Biometrika 66, pp. 265-270
</p>
<p>F. Pretis, J. Reade and G. Sucarrat (2018): 'Automated General-to-Specific (GETS) Regression Modeling and Indicator Saturation for Outliers and Structural Breaks'. Journal of Statistical Software 86, Number 3, pp. 1-44
</p>
<p>G. sucarrat (2019): 'User-Specified General-to-Specific and Indicator Saturation Methods', Munich Personal RePEc Archive: <a href="https://mpra.ub.uni-muenchen.de/96653/">https://mpra.ub.uni-muenchen.de/96653/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ols">ols</a></code>, <code><a href="#topic+diagnostics">diagnostics</a></code>, <code><a href="#topic+infocrit">infocrit</a></code>, <code><a href="#topic+getsv">getsv</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##aim: do gets on the x-part (i.e. the covariates) of an arma-x model.
##create the user-defined estimator (essentially adding, renaming
##and re-organising the items returned by the estimator):
myEstimator &lt;- function(y, x)
{
  tmp &lt;- arima(y, order=c(1,0,1), xreg=x)

  #rename and re-organise:
  result &lt;- list()
  result$coefficients &lt;- tmp$coef[-c(1:3)]
  result$vcov &lt;- tmp$var.coef
  result$vcov &lt;- result$vcov[-c(1:3),-c(1:3)]
  result$logl &lt;- tmp$loglik
  result$n &lt;- tmp$nobs
  result$k &lt;- NCOL(x)
  result$df &lt;- result$n - result$k
  
  return(result)
}

##generate some data:
##a series w/structural break and eleven step-dummies near the break
set.seed(123)
eps &lt;- arima.sim(list(ar=0.4, ma=0.1), 60)
x &lt;- coredata(sim(eps, which.ones=25:35)) #eleven step-dummies
y &lt;- 4*x[,"sis30"] + eps #create shift upwards at observation 30
plot(y)

##estimate the gum and then do gets in a single step:
##getsFun(y, x, user.estimator=list(name="myEstimator"))

##estimate the gum and then do gets in two steps:
#mygum &lt;- myEstimator(y, x)
##getsFun(y, x, user.estimator=list(name="myEstimator"), gum.result=mygum)

</code></pre>

<hr>
<h2 id='getsm'>General-to-Specific (GETS) Modelling of an AR-X model (the mean specification) with log-ARCH-X errors (the log-variance specification).</h2><span id='topic+getsm'></span><span id='topic+getsv'></span>

<h3>Description</h3>

<p>The starting model, an object of the 'arx' class, is referred to as the General Unrestricted Model (GUM). The <code>getsm</code> function undertakes multi-path GETS modelling of the mean specification, whereas <code>getsv</code> does the same for the log-variance specification. The diagnostic tests are undertaken on the standardised residuals, and the <code>keep</code> option enables regressors to be excluded from possible removal.</p>


<h3>Usage</h3>

<pre><code class='language-R'>##GETS-modelling of mean specification:
getsm(object, t.pval=0.05, wald.pval=t.pval, vcov.type=NULL, 
    do.pet=TRUE, ar.LjungB=list(lag=NULL, pval=0.025), 
    arch.LjungB=list(lag=NULL, pval=0.025), normality.JarqueB=NULL, 
    user.diagnostics=NULL, info.method=c("sc","aic","aicc", "hq"),
    gof.function=NULL, gof.method=NULL, keep=NULL, include.gum=FALSE,
    include.1cut=TRUE, include.empty=FALSE, max.paths=NULL, tol=1e-07,
    turbo=FALSE, print.searchinfo=TRUE, plot=NULL, alarm=FALSE)

##GETS modelling of log-variance specification:
getsv(object, t.pval=0.05, wald.pval=t.pval,
    do.pet=TRUE, ar.LjungB=list(lag=NULL, pval=0.025),
    arch.LjungB=list(lag=NULL, pval=0.025), normality.JarqueB=NULL,
    user.diagnostics=NULL, info.method=c("sc","aic","aicc","hq"),
    gof.function=NULL, gof.method=NULL, keep=c(1), include.gum=FALSE,
    include.1cut=TRUE, include.empty=FALSE, max.paths=NULL, tol=1e-07,
    turbo=FALSE, print.searchinfo=TRUE, plot=NULL, alarm=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getsm_+3A_object">object</code></td>
<td>
<p>an object of class 'arx'</p>
</td></tr>
<tr><td><code id="getsm_+3A_t.pval">t.pval</code></td>
<td>
<p>numeric value between 0 and 1. The significance level used for the two-sided regressor significance t-tests</p>
</td></tr>
<tr><td><code id="getsm_+3A_wald.pval">wald.pval</code></td>
<td>
<p>numeric value between 0 and 1. The significance level used for the Parsimonious Encompassing Tests (PETs). By default, it is the same as <code>t.pval</code></p>
</td></tr>
<tr><td><code id="getsm_+3A_vcov.type">vcov.type</code></td>
<td>
<p>the type of variance-covariance matrix used. If <code>NULL</code> (default), then the type used in the estimation of the 'arx' object is used. This can be overridden by either &quot;ordinary&quot; (i.e. the ordinary variance-covariance matrix) or &quot;white&quot; (i.e. the White (1980) heteroscedasticity robust variance-covariance matrix)</p>
</td></tr>
<tr><td><code id="getsm_+3A_do.pet">do.pet</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), then a Parsimonious Encompassing Test (PET) against the GUM is undertaken at each regressor removal for the joint significance of all the deleted regressors along the current path. If <code>FALSE</code>, then a PET is not undertaken at each regressor removal</p>
</td></tr>
<tr><td><code id="getsm_+3A_ar.ljungb">ar.LjungB</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> with named items <code>lag</code> and <code>pval</code>, a two-element numeric vector where the first element contains the lag and the second the p-value, or <code>NULL</code>. In the first case, <code>lag</code> contains the order of the Ljung and Box (1979) test for serial correlation in the standardised residuals, and <code>pval</code> contains the significance level. If <code>lag=NULL</code> (default), then the order used is that of the estimated 'arx' object. If <code>ar.Ljungb=NULL</code>, then the standardised residuals are not checked for serial correlation</p>
</td></tr>
<tr><td><code id="getsm_+3A_arch.ljungb">arch.LjungB</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> with named items <code>lag</code> and <code>pval</code>, a two-element numeric vector where the first element contains the lag and the second the p-value, or <code>NULL</code>. In the first case, <code>lag</code> contains the order of the Ljung and Box (1979) test for serial correlation in the squared standardised residuals, and <code>pval</code> contains the significance level. If <code>lag=NULL</code> (default), then the order used is that of the estimated 'arx' object. If <code>arch.Ljungb=NULL</code>, then the standardised residuals are not checked for ARCH</p>
</td></tr>
<tr><td><code id="getsm_+3A_normality.jarqueb">normality.JarqueB</code></td>
<td>
<p>a value between 0 and 1, or <code>NULL</code>. In the former case, the Jarque and Bera (1980) test for non-normality is conducted using a significance level equal to the numeric value. If <code>NULL</code>, then no test for non-normality is undertaken</p>
</td></tr>
<tr><td><code id="getsm_+3A_user.diagnostics">user.diagnostics</code></td>
<td>
<p><code>NULL</code> or a <code><a href="base.html#topic+list">list</a></code> with two entries, <code>name</code> and <code>pval</code>, see the <code>user.fun</code> argument in <code><a href="#topic+diagnostics">diagnostics</a></code> </p>
</td></tr>
<tr><td><code id="getsm_+3A_info.method">info.method</code></td>
<td>
<p>character string, &quot;sc&quot; (default), &quot;aic&quot; or &quot;hq&quot;, which determines the information criterion to be used when selecting among terminal models. The abbreviations are short for the Schwarz or Bayesian information criterion (sc), the Akaike information criterion (aic) and the Hannan-Quinn (hq) information criterion</p>
</td></tr>
<tr><td><code id="getsm_+3A_gof.function">gof.function</code></td>
<td>
<p><code>NULL</code> (default) or a <code>list</code>, see <code><a href="#topic+getsFun">getsFun</a></code>. If <code>NULL</code>, then <code><a href="#topic+infocrit">infocrit</a></code> is used </p>
</td></tr>
<tr><td><code id="getsm_+3A_gof.method">gof.method</code></td>
<td>
<p><code>NULL</code> (default) or a <code>character</code>, see <code><a href="#topic+getsFun">getsFun</a></code>. If <code>NULL</code> and <code>gof.function</code> is also <code>NULL</code>, then the best goodness-of-fit is characterised by a minimum value</p>
</td></tr>
<tr><td><code id="getsm_+3A_keep">keep</code></td>
<td>
<p>the regressors to be excluded from removal in the specification search. Note that <code>keep=c(1)</code> is obligatory when using <code>getsv</code>. This excludes the log-variance intercept from removal. The regressor numbering is contained in the <code>reg.no</code> column of the GUM</p>
</td></tr>
<tr><td><code id="getsm_+3A_include.gum">include.gum</code></td>
<td>
<p>logical. If <code>TRUE</code>, then the GUM (i.e. the starting model) is included among the terminal models. If <code>FALSE</code> (default), then the GUM is not included</p>
</td></tr>
<tr><td><code id="getsm_+3A_include.1cut">include.1cut</code></td>
<td>
<p>logical. If <code>TRUE</code>, then the 1-cut model is added to the list of terminal models. If <code>FALSE</code> (default), then the 1-cut is not added, unless it is a terminal model in one of the paths </p>
</td></tr>
<tr><td><code id="getsm_+3A_include.empty">include.empty</code></td>
<td>
<p>logical. If <code>TRUE</code>, then an empty model is included among the terminal models, if it passes the diagnostic tests, even if it is not equal to one of the terminals. If <code>FALSE</code> (default), then the empty model is not included (unless it is one of the terminals)</p>
</td></tr>
<tr><td><code id="getsm_+3A_max.paths">max.paths</code></td>
<td>
<p><code>NULL</code> (default) or an integer greater than 0. If <code>NULL</code>, then there is no limit to the number of paths. If an integer (e.g. 1), then this integer constitutes the maximum number of paths searched (e.g. a single path) </p>
</td></tr>
<tr><td><code id="getsm_+3A_tol">tol</code></td>
<td>
<p>numeric value. The tolerance for detecting linear dependencies in the columns of the variance-covariance matrix when computing the Wald-statistic used in the Parsimonious Encompassing Tests (PETs), see the <code><a href="base.html#topic+qr.solve">qr.solve</a></code> function</p>
</td></tr>
<tr><td><code id="getsm_+3A_turbo">turbo</code></td>
<td>
<p>logical. If <code>TRUE</code>, then (parts of) paths are not searched twice (or more) unnecessarily, thus yielding a significant potential for speed-gain. However, the checking of whether the search has arrived at a point it has already been comes with a slight computational overhead. Accordingly, if <code>turbo=TRUE</code>, then the total search time might in fact be higher than if <code>turbo=FALSE</code>. This happens if estimation is very fast, say, less than quarter of a second. Hence the default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="getsm_+3A_print.searchinfo">print.searchinfo</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), then a print is returned whenever simiplification along a new path is started</p>
</td></tr>
<tr><td><code id="getsm_+3A_plot">plot</code></td>
<td>
<p><code>NULL</code> or logical. If <code>TRUE</code>, then the fitted values and the residuals of the final model are plotted after model selection. If <code>FALSE</code>, then they are not. If <code>NULL</code> (default), then the value set by <code><a href="base.html#topic+options">options</a></code> determines whether a plot is produced or not</p>
</td></tr>
<tr><td><code id="getsm_+3A_alarm">alarm</code></td>
<td>
<p>logical. If <code>TRUE</code>, then a sound or beep is emitted (in order to alert the user) when the model selection ends</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an overview, see Pretis, Reade and Sucarrat (2018): <a href="https://doi.org/10.18637/jss.v086.i03">doi:10.18637/jss.v086.i03</a>.<br />
</p>
<p>The arguments <code>user.diagnostics</code> and <code>gof.function</code> enable the specification of user-defined diagnostics and a user-defined goodness-of-fit function. For the former, see the documentation of <code><a href="#topic+diagnostics">diagnostics</a></code>. For the latter, the principles of the same arguments in <code><a href="#topic+getsFun">getsFun</a></code> are followed, see its documentation under &quot;Details&quot;, and Sucarrat (2020): <a href="https://journal.r-project.org/archive/2021/RJ-2021-024/">https://journal.r-project.org/archive/2021/RJ-2021-024/</a>.
</p>


<h3>Value</h3>

<p>A list of class 'gets'</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a> </p>


<h3>References</h3>

<p>C. Jarque and A. Bera (1980): 'Efficient Tests for Normality, Homoscedasticity and Serial Independence'. Economics Letters 6, pp. 255-259. <a href="https://doi.org/10.1016/0165-1765%2880%2990024-5">doi:10.1016/0165-1765(80)90024-5</a>
</p>
<p>G. Ljung and G. Box (1979): 'On a Measure of Lack of Fit in Time Series Models'. Biometrika 66, pp. 265-270
</p>
<p>Felix Pretis, James Reade and Genaro Sucarrat (2018): 'Automated General-to-Specific (GETS) Regression Modeling and Indicator Saturation for Outliers and Structural Breaks'. Journal of Statistical Software 86, Number 3, pp. 1-44. <a href="https://doi.org/10.18637/jss.v086.i03">doi:10.18637/jss.v086.i03</a>
</p>
<p>Genaro Sucarrat (2020): 'User-Specified General-to-Specific and Indicator Saturation Methods'. The R Journal 12:2, pages 388-401. <a href="https://journal.r-project.org/archive/2021/RJ-2021-024/">https://journal.r-project.org/archive/2021/RJ-2021-024/</a>
</p>


<h3>See Also</h3>

<p>Extraction functions: <code><a href="#topic+coef.gets">coef.gets</a></code>, <code><a href="#topic+fitted.gets">fitted.gets</a></code>, <code><a href="#topic+paths">paths</a></code>, <code><a href="#topic+plot.gets">plot.gets</a></code>, <code><a href="#topic+print.gets">print.gets</a></code>,<br />
<code><a href="#topic+residuals.gets">residuals.gets</a></code>, <code><a href="#topic+summary.gets">summary.gets</a></code>, <code><a href="#topic+terminals">terminals</a></code>, <code><a href="#topic+vcov.gets">vcov.gets</a></code><br />
</p>
<p>Related functions: <code><a href="#topic+arx">arx</a></code>, <code><a href="#topic+eqwma">eqwma</a></code>, <code><a href="#topic+leqwma">leqwma</a></code>, <code><a href="zoo.html#topic+zoo">zoo</a></code>, <code><a href="#topic+getsFun">getsFun</a></code>, <code><a href="base.html#topic+qr.solve">qr.solve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Simulate from an AR(1):
set.seed(123)
y &lt;- arima.sim(list(ar=0.4), 80)

##Simulate four independent Gaussian regressors:
xregs &lt;- matrix(rnorm(2*80), 80, 2)

##estimate an AR(2) with intercept and four conditioning
##regressors in the mean, and a log-ARCH(3) with log(xregs^2) as
##regressors in the log-variance:
gum01 &lt;- arx(y, mc=TRUE, ar=1:2, mxreg=xregs, arch=1:3,
  vxreg=log(xregs^2))

##GETS model selection of the mean:
meanmod01 &lt;- getsm(gum01)

##GETS model selection of the log-variance:
varmod01 &lt;- getsv(gum01)

##GETS model selection of the mean with the mean intercept
##excluded from removal:
meanmod02 &lt;- getsm(gum01, keep=1)

##GETS model selection of the mean with non-default
#serial-correlation diagnostics settings:
meanmod03 &lt;- getsm(gum01, ar.LjungB=list(pval=0.05))

##GETS model selection of the mean with very liberal
##(20 percent) significance levels:
meanmod04 &lt;- getsm(gum01, t.pval=0.2)

##GETS model selection of log-variance with all the
##log-ARCH terms excluded from removal:
varmod03 &lt;- getsv(gum01, keep=2:4)

</code></pre>

<hr>
<h2 id='gmm'>Generalised Method of Moment (GMM) estimation of linear models</h2><span id='topic+gmm'></span>

<h3>Description</h3>

<p>Generalised Method of Moment (GMM) estimation of linear models with either ordinary (homoscedastic error) or robust (heteroscedastic error) coefficient-covariance, see Hayashi (2000) chapter 3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmm(y, x, z, tol = .Machine$double.eps,
  weighting.matrix = c("efficient", "2sls", "identity"),
  vcov.type = c("ordinary", "robust"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmm_+3A_y">y</code></td>
<td>
<p>numeric vector, the regressand</p>
</td></tr>
<tr><td><code id="gmm_+3A_x">x</code></td>
<td>
<p>numeric matrix, the regressors</p>
</td></tr>
<tr><td><code id="gmm_+3A_z">z</code></td>
<td>
<p>numeric matrix, the instruments</p>
</td></tr>
<tr><td><code id="gmm_+3A_tol">tol</code></td>
<td>
<p>numeric value. The tolerance for detecting linear dependencies in the columns of the matrices that are inverted, see the <code><a href="base.html#topic+solve">solve</a></code> function</p>
</td></tr>
<tr><td><code id="gmm_+3A_weighting.matrix">weighting.matrix</code></td>
<td>
<p>a character that determines the weighting matrix to bee used, see &quot;details&quot;</p>
</td></tr>
<tr><td><code id="gmm_+3A_vcov.type">vcov.type</code></td>
<td>
<p>a character that determines the expression for the coefficient-covariance, see &quot;details&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>weighting.matrix = "identity"</code> corresponds to the Instrumental Variables (IV) estimator, <code>weighting.matrix = "2sls"</code> corresponds to the 2 Stage Least Squares (2SLS) estimator, whereas <code>weighting.matrix = "efficient"</code> corresponds to the efficient GMM estimator, see chapter 3 in Hayashi(2000).
</p>
<p><code>vcov.type = "ordinary"</code> returns the ordinary expression for the coefficient-covariance, which is valid under conditionally homoscedastic errors. <code>vcov.type = "robust"</code> returns an expression that is also valid under conditional heteroscedasticity, see chapter 3 in Hayashi (2000).
</p>


<h3>Value</h3>

<p>A list with, amongst other, the following items:
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>number of regressors</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom, i.e. n-k</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a vector with the coefficient estimates</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>a vector with the fitted values</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector with the residuals</p>
</td></tr>
<tr><td><code>residuals2</code></td>
<td>
<p>a vector with the squared residuals</p>
</td></tr>      
<tr><td><code>rss</code></td>
<td>
<p>the residual sum of squares</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>the regression variance</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>the coefficient-covariance matrix</p>
</td></tr>
<tr><td><code>logl</code></td>
<td>
<p>the normal log-likelihood</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>References</h3>

<p>F. Hayashi (2000): 'Econometrics'. Princeton: Princeton University Press
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+solve">solve</a></code>, <code><a href="#topic+ols">ols</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
##generate data where regressor is correlated with error:
set.seed(123) #for reproducibility
n &lt;- 100
z1 &lt;- rnorm(n) #instrument
eps &lt;- rnorm(n) #ensures cor(z,eps)=0
x1 &lt;- 0.5*z1 + 0.5*eps #ensures cor(x,eps) is strong
y &lt;- 0.4 + 0.8*x1 + eps #the dgp
cor(x1, eps) #check correlatedness of regressor
cor(z1, eps) #check uncorrelatedness of instrument

x &lt;- cbind(1,x1) #regressor matrix
z &lt;- cbind(1,z1) #matrix with instruments

##efficient gmm estimation:
mymod &lt;- gmm(y, x, z)
mymod$coefficients

##ols (for comparison):
mymod &lt;- ols(y,x)
mymod$coefficients

</code></pre>

<hr>
<h2 id='hpdata'>Hoover and Perez (1999) data</h2><span id='topic+hpdata'></span>

<h3>Description</h3>

<p>Data used by Hoover and Perez (1999) in their evaluation of General-to-Specific (GETS) modelling. A detailed description of the data is found in their Table 1 (page 172). The data are quarterly, comprise 20 variables (the first variable is the quarterly index) and runs from 1959:1 to 1995:1. This corresponds to 145 observations. The original source of the data is Citibank.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hpdata)</code></pre>


<h3>Format</h3>


<dl>
<dt><code>Date</code></dt><dd><p>a factor that contains the (quarterly) dates of the observations</p>
</dd>
<dt><code>DCOINC</code></dt><dd><p>index of four coincident indicators</p>
</dd>
<dt><code>GD</code></dt><dd><p>GNP price deflator</p>
</dd>
<dt><code>GGEQ</code></dt><dd><p>government purchases of goods and services</p>
</dd>
<dt><code>GGFEQ</code></dt><dd><p>federal purchases of goods and services</p>
</dd>
<dt><code>GGFR</code></dt><dd><p>federal government receipts</p>
</dd>
<dt><code>GNPQ</code></dt><dd><p>GNP</p>
</dd>
<dt><code>GYDQ</code></dt><dd><p>disposable personal income</p>
</dd>
<dt><code>GPIQ</code></dt><dd><p>gross private domestic investment</p>
</dd>
<dt><code>FMRRA</code></dt><dd><p>total member bank reserves</p>
</dd>
<dt><code>FMBASE</code></dt><dd><p>monetary base (feredal reserve bank of St. Louis)</p>
</dd>
<dt><code>FM1DQ</code></dt><dd><p>M1</p>
</dd>
<dt><code>FM2DQ</code></dt><dd><p>M2</p>
</dd>
<dt><code>FSDJ</code></dt><dd><p>Dow Jones stock price</p>
</dd>
<dt><code>FYAAAC</code></dt><dd><p>Moody's AAA corporate bond yield</p>
</dd>
<dt><code>LHC</code></dt><dd><p>labour force (16 years+, civilian)</p>
</dd>
<dt><code>LHUR</code></dt><dd><p>unemployment rate</p>
</dd>
<dt><code>MU</code></dt><dd><p>unfilled orders (manufacturing, all industries)</p>
</dd>
<dt><code>MO</code></dt><dd><p>new orders (manufacturing, all industries)</p>
</dd>
<dt><code>GCQ</code></dt><dd><p>personal consumption expenditure</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data have been used for comparison and illustration of GETS model selection in several studies of the GETS methodology, including Hendry and Krolzig (1999, 2005), Doornik (2009) and Sucarrat and Escribano (2012).
</p>


<h3>Source</h3>

<p>Retrieved 14 October 2014 from:
<a href="https://www.csus.edu/indiv/p/perezs/data/data.htm">https://www.csus.edu/indiv/p/perezs/data/data.htm</a>
</p>


<h3>References</h3>

<p>David F. Hendry and Hans-Martin Krolzig (1999): 'Improving on 'Data
mining reconsidered' by K.D. Hoover and S.J Perez', Econometrics
Journal, Vol. 2, pp. 202-219.
</p>
<p>David F. Hendry and Hans-Martin Krolzig (2005): 'The properties of
automatic Gets modelling', Economic Journal 115, C32-C61.
</p>
<p>Jurgen Doornik (2009): 'Autometrics', in Jennifer L. Castle and Neil
Shephard (eds), 'The Methodology and Practice of Econometrics: A
Festschrift in Honour of David F. Hendry', Oxford University Press,
Oxford, pp. 88-121.
</p>
<p>Pretis, Felix, Reade, James and Sucarrat, Genaro (2018): 'Automated General-to-Specific (GETS) Regression Modeling and Indicator Saturation for Outliers and Structural Breaks'. Journal of Statistical Software 86, Number 3, pp. 1-44.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##load Hoover and Perez (1999) data:
data(hpdata)

##make quarterly data-matrix of zoo type:
newhpdata &lt;- zooreg(hpdata[,-1], start=c(1959,1), frequency=4)

##plot data:
plot(newhpdata)

##transform data to log-differences in percent:
dloghpdata &lt;- diff(log(newhpdata))*100

##plot log-differenced data:
plot(dloghpdata)
</code></pre>

<hr>
<h2 id='iim'>Make Indicator Matrices (Impulses, Steps, Trends)</h2><span id='topic+iim'></span><span id='topic+sim'></span><span id='topic+tim'></span>

<h3>Description</h3>

<p>Auxiliary functions to make, respectively, matrices of impulse indicators (<code>iim</code>), step indicators (<code>sim</code>) and trend indicators (<code>tim</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>##make matrix of impulse indicators:
iim(x, which.ones = NULL)

##make matrix of step indicators:
sim(x, which.ones = NULL)

##make matrix of trend indicators:
tim(x, which.ones = NULL, log.trend = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iim_+3A_x">x</code></td>
<td>
<p>either an integer (the length of the series in question) or a series (a vector or matrix) from which to use the time-series index to make indicators of</p>
</td></tr>
<tr><td><code id="iim_+3A_which.ones">which.ones</code></td>
<td>
<p>the locations of the impulses. If NULL (the default), then all impulses are returned</p>
</td></tr>
<tr><td><code id="iim_+3A_log.trend">log.trend</code></td>
<td>
<p>logical. If TRUE, then the natural log is applied on the trends</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a series or vector of observations, then the index of <code>x</code> will be used for the labelling of the impulses, and in the returned <code><a href="zoo.html#topic+zoo">zoo</a></code> object.
</p>
<p>Note: For <code>sim</code> and <code>tim</code> the first indicator is removed, since it is exactly colinear with the others.
</p>


<h3>Value</h3>

<p>A <code><a href="zoo.html#topic+zoo">zoo</a></code> matrix containing the impulses
</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+isat">isat</a></code>, <code><a href="zoo.html#topic+zoo">zoo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##generate series:
y &lt;- rnorm(40)

##make matrix of impulse indicators:
mIIM &lt;- iim(40)

##make matrix of step-indicators, but only every third:
mSIM &lt;- sim(y, which.ones=seq(1,40,3))

##give quarterly time-series attributes to y-series:
y &lt;- zooreg(y, frequency=4, end=c(2015,4))

##make matrix of trend-indicators with quarterly labels:
mTIM &lt;- tim(y)

</code></pre>

<hr>
<h2 id='infldata'>Quarterly Norwegian year-on-year CPI inflation</h2><span id='topic+infldata'></span>

<h3>Description</h3>

<p>Quarterly Norwegian year-on-year CPI inflation from 1989(1) to 2015(4).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("infldata")</code></pre>


<h3>Format</h3>

<p>A data frame with 108 observations on the following 5 variables:
</p>

<dl>
<dt><code>date</code></dt><dd><p>a factor containing the dates</p>
</dd>
<dt><code>infl</code></dt><dd><p>year-on-year inflation</p>
</dd>
<dt><code>q2dum</code></dt><dd><p>a dummy variable equal to 1 in quarter 2 and 0 otherwise</p>
</dd>
<dt><code>q3dum</code></dt><dd><p>a dummy variable equal to 1 in quarter 3 and 0 otherwise</p>
</dd>
<dt><code>q4dum</code></dt><dd><p>a dummy variable equal to 1 in quarter 4 and 0 otherwise</p>
</dd>
</dl>



<h3>Source</h3>

<p>Statistics Norway (SSB): <a href="https://www.ssb.no/">https://www.ssb.no/</a>. The raw data comprise monthly CPI data obtained via <a href="https://www.ssb.no/statbank/table/08183">https://www.ssb.no/statbank/table/08183</a>.
</p>


<h3>References</h3>

<p>Pretis, Felix, Reade, James and Sucarrat, Genaro (2018): 'Automated General-to-Specific (GETS) Regression Modeling and Indicator Saturation for Outliers and Structural Breaks'. Journal of Statistical Software 86, Number 3, pp. 1-44
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(infldata)
infldata &lt;- zooreg(infldata[,-1], frequency=4, start=c(1989,1))
plot(infldata[,"infl"])
</code></pre>

<hr>
<h2 id='infocrit'>Computes the Average Value of an Information Criterion</h2><span id='topic+infocrit'></span><span id='topic+info.criterion'></span>

<h3>Description</h3>

<p>Given a log-likelihood, the number of observations and the number of estimated parameters, the average value of a chosen information criterion is computed. This facilitates comparison of models that are estimated with a different number of observations, e.g. due to different lags.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infocrit(x, method=c("sc","aic","aicc","hq"))

info.criterion(logl, n=NULL, k=NULL, method=c("sc","aic","aicc","hq"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infocrit_+3A_x">x</code></td>
<td>
<p>a <code>list</code> that contains, at least, three items: <code>logl</code> (a numeric, the log-likelihood), <code>k</code> (a numeric, usually the number of estimated parameters) and <code>n</code> (a numeric, the number of observations)</p>
</td></tr>
<tr><td><code id="infocrit_+3A_method">method</code></td>
<td>
<p>character, either &quot;sc&quot; (default), &quot;aic&quot;, &quot;aicc&quot; or &quot;hq&quot;</p>
</td></tr>
<tr><td><code id="infocrit_+3A_logl">logl</code></td>
<td>
<p>numeric, the value of the log-likelihood</p>
</td></tr>
<tr><td><code id="infocrit_+3A_n">n</code></td>
<td>
<p>integer, number of observations</p>
</td></tr>
<tr><td><code id="infocrit_+3A_k">k</code></td>
<td>
<p>integer, number of parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Contrary to <code><a href="stats.html#topic+AIC">AIC</a></code> and <code><a href="stats.html#topic+BIC">BIC</a></code>, <code>info.criterion</code> computes the average criterion value (i.e. division by the number of observations). This facilitates comparison of models that are estimated with a different number of observations, e.g. due to different lags.
</p>


<h3>Value</h3>

<p><code>infocrit</code>: a numeric (i.e. the value of the chosen information criterion)
</p>
<p><code>info.criterion</code>: a list with elements
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p>type of information criterion</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>number of parameters</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>the value on the information criterion</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>References</h3>

<p>H. Akaike (1974): 'A new look at the statistical model identification'.
IEEE Transactions on Automatic Control 19, pp. 716-723
</p>
<p>E. Hannan and B. Quinn (1979): 'The determination of the order of an
autoregression'. Journal of the Royal Statistical Society B 41, pp. 190-195
</p>
<p>C.M. Hurvich and C.-L. Tsai (1989): 'Regression and Time Series Model
Selection in Small Samples'. Biometrika 76, pp. 297-307
</p>
<p>Pretis, Felix, Reade, James and Sucarrat, Genaro (2018): 'Automated General-to-Specific (GETS) Regression Modeling and Indicator Saturation for Outliers and Structural Breaks'. Journal of Statistical Software 86, Number 3, pp. 1-44
</p>
<p>G. Schwarz (1978): 'Estimating the dimension of a model'. The Annals of
Statistics 6, pp. 461-464
</p>

<hr>
<h2 id='isat'>Indicator Saturation</h2><span id='topic+isat'></span><span id='topic+isat.default'></span><span id='topic+isat.lm'></span><span id='topic+isat.arx'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+isat">isat</a></code> function undertakes multi-path indicator saturation to detect outliers and mean-shifts using impulses (IIS), step-shifts (SIS), or trend-indicators (TIS). Indicators are partitioned into blocks and selected over at a chosen level of significance (<code>t.pval</code>) using the <code><a href="#topic+getsm">getsm</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isat(y, ...)

##default S3 method:
## Default S3 method:
isat(y, mc=TRUE, ar=NULL, ewma=NULL, mxreg=NULL, iis=FALSE, sis=TRUE,
  tis=FALSE, uis=FALSE, blocks=NULL, ratio.threshold=0.8, max.block.size=30,
  t.pval=0.001, wald.pval=t.pval,
  vcov.type= c("ordinary","white","newey-west"), do.pet=FALSE, ar.LjungB=NULL,
  arch.LjungB=NULL, normality.JarqueB=NULL, info.method=c("sc","aic","hq"),
  user.diagnostics=NULL, user.estimator=NULL, gof.function=NULL,
  gof.method = c("min", "max"), include.gum=NULL, include.1cut=FALSE,
  include.empty=FALSE, max.paths=NULL, parallel.options=NULL, turbo=FALSE,
  tol=1e-07, LAPACK=FALSE, max.regs=NULL, print.searchinfo=TRUE, plot=NULL,
  alarm=FALSE, ...)
  
##S3 method for objects of class 'lm':
## S3 method for class 'lm'
isat(y, ar=NULL, ewma=NULL, iis=FALSE, sis=TRUE,
  tis=FALSE, uis=FALSE, blocks=NULL, ratio.threshold=0.8, max.block.size=30,
  t.pval=0.001, wald.pval=t.pval,
  vcov.type= c("ordinary","white","newey-west"), do.pet=FALSE, ar.LjungB=NULL,
  arch.LjungB=NULL, normality.JarqueB=NULL, info.method=c("sc","aic","hq"),
  user.diagnostics=NULL, user.estimator=NULL, gof.function=NULL,
  gof.method = c("min", "max"), include.gum=NULL, include.1cut=FALSE,
  include.empty=FALSE, max.paths=NULL, parallel.options=NULL, turbo=FALSE,
  tol=1e-07, LAPACK=FALSE, max.regs=NULL, print.searchinfo=TRUE, plot=NULL,
  alarm=FALSE, ...)

##S3 method for objects of class 'arx':
## S3 method for class 'arx'
isat(y, mc=TRUE, ar=NULL, ewma=NULL, iis=FALSE, sis=TRUE,
  tis=FALSE, uis=FALSE, blocks=NULL, ratio.threshold=0.8, max.block.size=30,
  t.pval=0.001, wald.pval=t.pval,
  vcov.type= c("ordinary","white","newey-west"), do.pet=FALSE, ar.LjungB=NULL,
  arch.LjungB=NULL, normality.JarqueB=NULL, info.method=c("sc","aic","hq"),
  user.diagnostics=NULL, user.estimator=NULL, gof.function=NULL,
  gof.method = c("min", "max"), include.gum=NULL, include.1cut=FALSE,
  include.empty=FALSE, max.paths=NULL, parallel.options=NULL, turbo=FALSE,
  tol=1e-07, LAPACK=FALSE, max.regs=NULL, print.searchinfo=TRUE, plot=NULL,
  alarm=FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isat_+3A_y">y</code></td>
<td>
<p>numeric vector, time-series, <code><a href="zoo.html#topic+zoo">zoo</a></code>, or object of class <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="#topic+arx">arx</a></code>. Missing values in the beginning and at the end of the series is allowed, as they are removed with the <code><a href="zoo.html#topic+na.trim">na.trim</a></code> command</p>
</td></tr>
<tr><td><code id="isat_+3A_mc">mc</code></td>
<td>
<p>logical. <code>TRUE</code> (default) includes an intercept in the mean specification, whereas FALSE does not</p>
</td></tr>
<tr><td><code id="isat_+3A_ar">ar</code></td>
<td>
<p>integer vector, say, c(2,4) or 1:4. The AR-lags to include in the mean specification</p>
</td></tr>
<tr><td><code id="isat_+3A_ewma">ewma</code></td>
<td>
<p>either NULL (default) or a list with arguments sent to the <code><a href="#topic+eqwma">eqwma</a></code> function. In the latter case a lagged moving average of y is included as a regressor</p>
</td></tr>
<tr><td><code id="isat_+3A_mxreg">mxreg</code></td>
<td>
<p>numeric vector or matrix, say, a <code><a href="zoo.html#topic+zoo">zoo</a></code> object, of conditioning variables. Note that missing values in the beginning or at the end of the series is allowed, as they are removed with the <code><a href="zoo.html#topic+na.trim">na.trim</a></code> command. Note also that, if both <code>y</code> and <code>mxreg</code> are <code>zoo</code> objects, then their samples are chosen to match</p>
</td></tr>
<tr><td><code id="isat_+3A_iis">iis</code></td>
<td>
<p>logical. If <code>TRUE</code>, impulse indicator saturation is performed.</p>
</td></tr>
<tr><td><code id="isat_+3A_sis">sis</code></td>
<td>
<p>logical. If <code>TRUE</code>, step indicator saturation is performed.</p>
</td></tr>
<tr><td><code id="isat_+3A_tis">tis</code></td>
<td>
<p>logical. If <code>TRUE</code>, trend indicator saturation is performed.</p>
</td></tr>
<tr><td><code id="isat_+3A_uis">uis</code></td>
<td>
<p>a matrix of regressors, or a list of matrices.</p>
</td></tr>
<tr><td><code id="isat_+3A_blocks">blocks</code></td>
<td>
<p><code>NULL</code> (default), an integer (the number of blocks) or a user-specified <code>list</code> that indicates how blocks should be put together. If <code>NULL</code>, then the number of blocks is determined automatically</p>
</td></tr>
<tr><td><code id="isat_+3A_ratio.threshold">ratio.threshold</code></td>
<td>
<p>Minimum ratio of variables in each block to total observations to determine the block size, default=0.8. Only relevant if blocks = <code>NULL</code> </p>
</td></tr>
<tr><td><code id="isat_+3A_max.block.size">max.block.size</code></td>
<td>
<p>Maximum size of block of variables to be selected over, default=30. Block size used is the maximum of given by either the ratio.threshold and max.block.size </p>
</td></tr>
<tr><td><code id="isat_+3A_t.pval">t.pval</code></td>
<td>
<p>numeric value between 0 and 1. The significance level used for the two-sided regressor significance t-tests</p>
</td></tr>
<tr><td><code id="isat_+3A_wald.pval">wald.pval</code></td>
<td>
<p>numeric value between 0 and 1. The significance level used for the Parsimonious Encompassing Tests (PETs)</p>
</td></tr>
<tr><td><code id="isat_+3A_vcov.type">vcov.type</code></td>
<td>
<p>the type of variance-covariance matrix used. If NULL (default), then the type used is that of the 'arx' object. This can be overridden by either &quot;ordinary&quot; (i.e. the ordinary variance-covariance matrix) or &quot;white&quot; (i.e. the White (1980) heteroscedasticity robust variance-covariance matrix)</p>
</td></tr>
<tr><td><code id="isat_+3A_do.pet">do.pet</code></td>
<td>
<p>logical. If <code>TRUE</code>, then a Parsimonious Encompassing Test (PET) against the GUM is undertaken at each regressor removal for the joint significance of all the deleted regressors along the current path. If FALSE (default), then a PET is not undertaken at each regressor removal. By default, the numeric value is the same as that of <code>t.pval</code></p>
</td></tr>
<tr><td><code id="isat_+3A_ar.ljungb">ar.LjungB</code></td>
<td>
<p>a two-item list with names <code>lag</code> and <code>pval</code>, or NULL (default). In the former case <code>lag</code> contains the order of the Ljung and Box (1979) test for serial correlation in the standardised residuals, and <code>pval</code> contains the significance level. If <code>lag=NULL</code> (default), then the order used is that of the estimated 'arx' object. If <code>ar.Ljungb=NULL</code>, then the standardised residuals are not checked for serial correlation</p>
</td></tr>
<tr><td><code id="isat_+3A_arch.ljungb">arch.LjungB</code></td>
<td>
<p>a two-item list with names <code>lag</code> and <code>pval</code>, or NULL (default). In the former case, <code>lag</code> contains the order of the Ljung and Box (1979) test for serial correlation in the squared standardised residuals, and <code>pval</code> contains the significance level. If <code>lag=NULL</code> (default), then the order used is that of the estimated 'arx' object. If <code>arch.Ljungb=NULL</code>, then the standardised residuals are not checked for ARCH</p>
</td></tr>
<tr><td><code id="isat_+3A_normality.jarqueb">normality.JarqueB</code></td>
<td>
<p><code>NULL</code> (the default) or a value between 0 and 1. In the latter case, a test for non-normality is conducted using a significance level equal to <code>normality.JarqueB</code>. If <code>NULL</code>, then no test for non-normality is conducted</p>
</td></tr>
<tr><td><code id="isat_+3A_info.method">info.method</code></td>
<td>
<p>character string, &quot;sc&quot; (default), &quot;aic&quot; or &quot;hq&quot;, which determines the information criterion to be used when selecting among terminal models. The abbreviations are short for the Schwarz or Bayesian information criterion (sc), the Akaike information criterion (aic) and the Hannan-Quinn (hq) information criterion</p>
</td></tr>
<tr><td><code id="isat_+3A_user.diagnostics">user.diagnostics</code></td>
<td>
<p><code>NULL</code> or a <code><a href="base.html#topic+list">list</a></code> with two entries, <code>name</code> and <code>pval</code>, see the <code>user.fun</code> argument in <code><a href="#topic+diagnostics">diagnostics</a></code> </p>
</td></tr>
<tr><td><code id="isat_+3A_user.estimator">user.estimator</code></td>
<td>
<p><code>NULL</code> or a <code><a href="base.html#topic+list">list</a></code> with at least one entry, <code>name</code>, see the <code>user.estimator</code> argument in <code><a href="#topic+getsFun">getsFun</a></code> </p>
</td></tr>
<tr><td><code id="isat_+3A_gof.function">gof.function</code></td>
<td>
<p><code>NULL</code> or a <code><a href="base.html#topic+list">list</a></code> with at least one entry, <code>name</code>, see the <code>user.estimator</code> argument in <code><a href="#topic+getsFun">getsFun</a></code> </p>
</td></tr>
<tr><td><code id="isat_+3A_gof.method">gof.method</code></td>
<td>
<p><code>NULL</code> or a <code>character</code> that determines whether the best Goodness-of-Fit is a minimum or maximum </p>
</td></tr>
<tr><td><code id="isat_+3A_include.gum">include.gum</code></td>
<td>
<p>ignored (temporarily deprecated)</p>
</td></tr>
<tr><td><code id="isat_+3A_include.1cut">include.1cut</code></td>
<td>
<p>logical. If <code>TRUE</code>, then the 1-cut model is included among the terminal models, if it passes the diagnostic tests, even if it is not equal to one of the terminals. If FALSE (default), then the 1-cut model is not included (unless it is one of the terminals)</p>
</td></tr>
<tr><td><code id="isat_+3A_include.empty">include.empty</code></td>
<td>
<p>logical. If <code>TRUE</code>, then an empty model is included among the terminal models, if it passes the diagnostic tests, even if it is not equal to one of the terminals. If FALSE (default), then the empty model is not included (unless it is one of the terminals)</p>
</td></tr>
<tr><td><code id="isat_+3A_max.paths">max.paths</code></td>
<td>
<p><code>NULL</code> (default) or an integer indicating the maximum number of paths to search</p>
</td></tr>
<tr><td><code id="isat_+3A_parallel.options">parallel.options</code></td>
<td>
<p><code>NULL</code> or an integer, i.e. the number of cores/threads to be used for parallel computing (implemented w/<code>makeCluster</code> and <code>parLapply</code>)</p>
</td></tr>
<tr><td><code id="isat_+3A_turbo">turbo</code></td>
<td>
<p>logical. If <code>TRUE</code>, then (parts of) paths are not searched twice (or more) unnecessarily, thus yielding a significant potential for speed-gain. However, the checking of whether the search has arrived at a point it has already been comes with a slight computational overhead. Accordingly, if <code>turbo=TRUE</code>, then the total search time might in fact be higher than if <code>turbo=FALSE</code>. This happens if estimation is very fast, say, less than quarter of a second. Hence the default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="isat_+3A_tol">tol</code></td>
<td>
<p>numeric value (default = 1e-07). The tolerance for detecting linear dependencies in the columns of the regressors (see <code><a href="base.html#topic+qr">qr</a></code> function). Only used if LAPACK is FALSE (default)</p>
</td></tr>
<tr><td><code id="isat_+3A_lapack">LAPACK</code></td>
<td>
<p>logical. If <code>TRUE</code>, then use LAPACK. If <code>FALSE</code> (default), then use LINPACK (see <code><a href="base.html#topic+qr">qr</a></code> function)</p>
</td></tr>
<tr><td><code id="isat_+3A_max.regs">max.regs</code></td>
<td>
<p>integer. The maximum number of regressions along a deletion path. It is not recommended that this is altered</p>
</td></tr>
<tr><td><code id="isat_+3A_print.searchinfo">print.searchinfo</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), then a print is returned whenever simiplification along a new path is started, and whenever regressors are dropped due to exact multicolinearity</p>
</td></tr>
<tr><td><code id="isat_+3A_plot">plot</code></td>
<td>
<p>NULL or logical. If <code>TRUE</code>, then the fitted values and the residuals of the final model are plotted after model selection. If NULL (default), then the value set by <code><a href="base.html#topic+options">options</a></code> determines whether a plot is produced or not.</p>
</td></tr>
<tr><td><code id="isat_+3A_alarm">alarm</code></td>
<td>
<p>logical. If <code>TRUE</code>, then a sound is emitted (in order to alert the user) when the model selection ends</p>
</td></tr>
<tr><td><code id="isat_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Multi-path indicator saturation using impulses (IIS), step-shifts (SIS), or trend-indicators (TIS). Indicators are partitioned into sequential blocks (as of beta version 0.7) where the block intervals are defined by the ratio of variables to observations in each block and a specified maximum block size. Indicators are selected over using the <code><a href="#topic+getsm">getsm</a></code> function. Retained indicators in each block are combined and re-selected over. Fixed covariates that are not selected over can be included in the regression model either in the mxreg matrix, or for auto-regressive terms through the ar specification. See Hendry, Johansen and Santos (2007) and Castle, Doornik, Hendry, and Pretis (2015)</p>


<h3>Value</h3>

<p>A list of class 'isat'</p>


<h3>Author(s)</h3>

<p>Jonas Kurle, <a href="https://www.jonaskurle.com/">https://www.jonaskurle.com/</a><br />
Felix Pretis, <a href="http://www.felixpretis.org/">http://www.felixpretis.org/</a><br />
James Reade,  <a href="https://sites.google.com/site/jjamesreade/">https://sites.google.com/site/jjamesreade/</a><br />
Moritz Schwarz, <a href="https://www.inet.ox.ac.uk/people/moritz-schwarz/">https://www.inet.ox.ac.uk/people/moritz-schwarz/</a><br />
Genaro Sucarrat <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a><br /><br />
</p>


<h3>References</h3>

<p>Castle, Jennifer, L., Doornik, Jurgen, A., Hendry, David F., and Pretis, Felix (2015): 'Detecting Location Shifts during Model Selection by Step-Indicator Saturation', Econometrics, vol 3:2, 240-264.
</p>
<p>Hendry, David, F., Johansen, Soren, and Santos, Carlos (2007):  'Automatic selection of indicators in a fully saturated regression'. Computational Statistics, vol 23:1, pp.317-335.
</p>
<p>Pretis, Felix, Reade, James and Sucarrat, Genaro (2018): 'Automated General-to-Specific (GETS) Regression Modeling and Indicator Saturation for Outliers and Structural Breaks'. Journal of Statistical Software 86, Number 3, pp. 1-44
</p>


<h3>See Also</h3>

<p>Extraction functions for 'isat' objects: <code><a href="#topic+coef.isat">coef.isat</a></code>, <code><a href="#topic+fitted.isat">fitted.isat</a></code>, <code><a href="#topic+paths">paths</a></code>, <code><a href="#topic+plot.isat">plot.isat</a></code>, <code><a href="#topic+print.isat">print.isat</a></code>,<br />
<code><a href="#topic+residuals.isat">residuals.isat</a></code>, <code><a href="#topic+summary.isat">summary.isat</a></code>, <code><a href="#topic+terminals">terminals</a></code>, <code><a href="#topic+vcov.isat">vcov.isat</a></code><br />
</p>
<p>Related functions: <code><a href="#topic+arx">arx</a></code>, <code><a href="#topic+eqwma">eqwma</a></code>, <code><a href="#topic+leqwma">leqwma</a></code>, <code><a href="zoo.html#topic+zoo">zoo</a></code>, <code><a href="#topic+getsFun">getsFun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##SIS using the Nile data
data(Nile)
isat(Nile, sis=TRUE, iis=FALSE, plot=TRUE, t.pval=0.005)

##SIS using the Nile data in an autoregressive model
#isat(Nile, ar=1:2, sis=TRUE, iis=FALSE, plot=TRUE, t.pval=0.005)

##HP Data
##load Hoover and Perez (1999) data:
#data(hpdata)

##make quarterly data-matrix of zoo type
##(GCQ = personal consumption expenditure):
#y &lt;- zooreg(hpdata$GCQ, 1959, frequency=4)

##transform data to log-differences:
#dlogy &lt;- diff(log(y))

##run isat with step impulse saturation on four
##lags and a constant 1 percent significance level:
#isat(dlogy, ar=1:4, sis=TRUE, t.pval =0.01)

##Example with additional covariates entering through mxreg:

##(GYDQ = disposable personal income):
#x &lt;- zooreg(hpdata$GYDQ, 1959, frequency=4)

##transform data to log-differences:
#dlogx &lt;- diff(log(x))

##run isat with step impulse saturation on four
##lags and a constant 1 percent significance level:
#isat(dlogy, mxreg=dlogx, ar=1:4, sis=TRUE, t.pval =0.01)

</code></pre>

<hr>
<h2 id='isatdates'>Extracting Indicator Saturation Breakdates</h2><span id='topic+isatdates'></span>

<h3>Description</h3>

<p>Takes an <code><a href="#topic+isat">isat</a></code> object and extracts the break dates together with their estimated coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  isatdates(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isatdates_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+isat">isat</a></code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function extracts the breakdates determined by <code><a href="#topic+isat">isat</a></code> for <code>iis</code>, <code>sis</code>, and <code>tis</code>, together with their estimated coefficients and standard errors.</p>


<h3>Value</h3>

<p>Returns a list of three elements (one for <code>iis</code>, <code>sis</code>, and <code>tis</code>). Each element lists the name of the break variable, the time index of the break (labelled 'date'), the index of the break date, the estimated coefficient, the standard error of the estimated coefficient, as well as the corresponding t-statistic and p-value.</p>


<h3>Author(s)</h3>

<p>Felix Pretis, <a href="http://www.felixpretis.org/">http://www.felixpretis.org/</a>
</p>


<h3>References</h3>

<p>Pretis, F., Reade, J., &amp; Sucarrat, G. (2018). Automated General-to-Specific (GETS) regression modeling and indicator saturation methods for the detection of outliers and structural breaks. Journal of Statistical Software, 86(3).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isat">isat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###Break date extraction of the Nile data
nile &lt;- as.zoo(Nile)
isat.nile &lt;- isat(nile, sis=TRUE, iis=FALSE, plot=TRUE, t.pval=0.005)
isatdates(isat.nile)
</code></pre>

<hr>
<h2 id='isatloop'>Repeated Impulse Indicator Saturation</h2><span id='topic+isatloop'></span>

<h3>Description</h3>

<p>Runs <code><a href="#topic+isat">isat</a></code> repeatedly at pre-specified significance levels to yield multiple iterations used in<br />
<code><a href="#topic+outlierscaletest">outlierscaletest</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  isatloop(num=c(seq(from=20, to=1, by=-1)), t.pval.spec = FALSE,  
  print=FALSE, y, ar=NULL, iis=TRUE, sis=FALSE, ...)
  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isatloop_+3A_num">num</code></td>
<td>
<p>numeric, target expected number of outliers under the null hypothesis, or target proportion of outliers if <code>t.pval.spec==TRUE</code></p>
</td></tr>
<tr><td><code id="isatloop_+3A_t.pval.spec">t.pval.spec</code></td>
<td>
<p>logical, if <code>TRUE</code>, then <code>num</code> specifies proportion rather than number of targeted outliers</p>
</td></tr>
<tr><td><code id="isatloop_+3A_print">print</code></td>
<td>
<p>logical, if <code>TRUE</code>, then iterations are printed</p>
</td></tr>
<tr><td><code id="isatloop_+3A_y">y</code></td>
<td>
<p>numeric vector, time-series or <code><a href="zoo.html#topic+zoo">zoo</a></code> object. Missing values in the beginning and at the end of the series is allowed, as they are removed with the <code><a href="zoo.html#topic+na.trim">na.trim</a></code> command</p>
</td></tr>
<tr><td><code id="isatloop_+3A_ar">ar</code></td>
<td>
<p>integer vector, say, c(2,4) or 1:4. The AR-lags to include in the mean specification</p>
</td></tr>
<tr><td><code id="isatloop_+3A_iis">iis</code></td>
<td>
<p>logical, whether to use <code>iis</code></p>
</td></tr>
<tr><td><code id="isatloop_+3A_sis">sis</code></td>
<td>
<p>logical, whether to use <code>sis</code>, default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="isatloop_+3A_...">...</code></td>
<td>
<p>any argument from <code><a href="#topic+isat">isat</a></code> can also be used in <code>isatloop</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function repeatedly runs <code><a href="#topic+isat">isat</a></code> detecting outliers in a model of <code>y</code> at different chosen target levels of significance speciefied in <code>num</code>.  The output of this function is used as the input for the <code><a href="#topic+outlierscaletest">outlierscaletest</a></code> function. All additional arguments from <code><a href="#topic+isat">isat</a></code> can be passed to <code>isatloop</code>.</p>


<h3>Value</h3>

<p>Returns a list of two items. The first item is the number of observations. The second item is a dataframe containing the expected and observed proportion (and number of outliers) for each specified significance level of selection.</p>


<h3>Author(s)</h3>

<p>Felix Pretis, <a href="http://www.felixpretis.org/">http://www.felixpretis.org/</a>
</p>


<h3>References</h3>

<p>Jiao, X. &amp; Pretis, F. (2019). Testing the Presence of Outliers in Regression Models. Discussion Paper.
</p>
<p>Pretis, F., Reade, J., &amp; Sucarrat, G. (2018). Automated General-to-Specific (GETS) regression modeling and indicator saturation methods for the detection of outliers and structural breaks. Journal of Statistical Software, 86(3).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isat">isat</a></code>, <code><a href="#topic+outlierscaletest">outlierscaletest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ###Repeated isat models using the Nile dataset
  ### where p-values are chosen such that the expected number of outliers under the null
  ### corresponds to 1, 2, 3, 4 and 5.
  nile &lt;- as.zoo(Nile)
  isat.nile.loop &lt;- isatloop(y=nile, iis=TRUE, num=c(1,2, 3, 4, 5))
  
</code></pre>

<hr>
<h2 id='isattest'>Indicator Saturation Test</h2><span id='topic+isattest'></span>

<h3>Description</h3>

<p>Takes an 'isat' object returned by the <code>isat</code> function as input and returns the results of a hypothesis test on the time-varying intercept or long-run equilibrium against a specified null-hypothesis for a chosen level of significance - see Pretis (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  isattest(x, hnull=0, lr=FALSE, ci.pval=0.99, plot=NULL, plot.turn=FALSE,
    conscorr=FALSE, effcorr=FALSE, mcor = 1, biascorr=FALSE, mxfull = NULL,
    mxbreak=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isattest_+3A_x">x</code></td>
<td>
<p>a 'gets' object obtained with the <code><a href="#topic+isat">isat</a></code> function</p>
</td></tr>
<tr><td><code id="isattest_+3A_hnull">hnull</code></td>
<td>
<p>numeric. the null-hypothesis value to be tested against.</p>
</td></tr>
<tr><td><code id="isattest_+3A_lr">lr</code></td>
<td>
<p>logical. If TRUE and 'x' contains autoregressive elements, then <code>isattest</code> tests on the long-run equilibrium path. See Pretis (2015).</p>
</td></tr>
<tr><td><code id="isattest_+3A_ci.pval">ci.pval</code></td>
<td>
<p>numeric between 0 and 1. Default is 0.99, the level of significance for the confidence interval of the test against 'hnull'.</p>
</td></tr>
<tr><td><code id="isattest_+3A_plot">plot</code></td>
<td>
<p>logical. If TRUE, then a plot showing the coefficient path and bias relative to 'hnull' is shown.</p>
</td></tr>
<tr><td><code id="isattest_+3A_plot.turn">plot.turn</code></td>
<td>
<p>logical. If TRUE, then the plot output adds the time of the breaks to the plot showing the bias relative to 'hnull'.</p>
</td></tr>
<tr><td><code id="isattest_+3A_biascorr">biascorr</code></td>
<td>
<p>logical. If TRUE, then the coefficient path is bias-corrected using <code><a href="#topic+biascorr">biascorr</a></code>. This is only valid for the non-dynamic test without additional covariates.</p>
</td></tr>
<tr><td><code id="isattest_+3A_conscorr">conscorr</code></td>
<td>
<p>logical. If TRUE then the Johansen and Nielsen (2016) impulse-indicator consistency correction is applied to estimated residual variance.</p>
</td></tr>
<tr><td><code id="isattest_+3A_effcorr">effcorr</code></td>
<td>
<p>logical. If TRUE then the Johansen and Nielsen (2016) m-step efficiency correction is applied to estimated standard errors of &lsquo;fixed&rsquo; regressors.</p>
</td></tr>
<tr><td><code id="isattest_+3A_mcor">mcor</code></td>
<td>
<p>integer. The m-step efficiency correction factor, where m=mcor.</p>
</td></tr>
<tr><td><code id="isattest_+3A_mxfull">mxfull</code></td>
<td>
<p>string. The name of the full-sample variable when constructing the coefficient path of user-specified break variables.</p>
</td></tr>
<tr><td><code id="isattest_+3A_mxbreak">mxbreak</code></td>
<td>
<p>string. The name of the break variables used to construct the coefficient path of user-specified break variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function tests the coefficient path (or long-run equilibrium path) against a specified null hypothesis at a chosen level of significance. If conducted on an <code><a href="#topic+isat">isat</a></code> model of a forecast error or relative forecast differential, then this corresponds to the test of time-varying predictive accuracy of Pretis (2015). The resulting output plot shows the coefficient path in the top panel (where 'hnull' is plotted as dotted lines), with the bias (significant difference relative to 'hnull') in the lower panel. If <code>mxfull</code> and <code>mxbreak</code> are specified, then the function tests on the coefficient path of the user-specified variable, where <code>mxfull</code> denotes the ful-sample variable name, to which the <code>mxbreak</code> variables are added. To correct for the under-estimation of the residual variance, the argument <code>conscorr</code> implements the Johansen and Nielsen (2016) consistency correction, and <code>effcorr</code> adds the efficiency correction for standard errors on fixed regressors which are not selected over.</p>


<h3>Value</h3>

<p>A Tx4 matrix (with T = number of observations) where the first two columns denote the confidence interval of the coefficient path (or the long-run equilibrium path if 'lr=TRUE'). The third and fourth column denote the bias of the coefficient path relative to the chosen null-hypothesis, where 'bias.high' denotes the bias when the series tested is above the hypothesized value, and 'bias.low' denotes the bias when the series tested is significantly below the hypothesized value.</p>


<h3>Author(s)</h3>

<p>Felix Pretis, <a href="http://www.felixpretis.org/">http://www.felixpretis.org/</a><br />
</p>


<h3>References</h3>

<p>Johansen, S., &amp; Nielsen, B. (2016): 'Asymptotic theory of outlier detection algorithms for linear time series regression models.' Scandinavian Journal of Statistics, 43(2), 321-348.
</p>
<p>Pretis, F. (2015): 'Testing for time-varying predictive accuracy using bias-corrected indicator saturation'. Oxford Department of Economics Discussion Paper.
</p>
<p>Hendry, David, F., Johansen, Soren, and Santos, Carlos (2007):  'Automatic selection of indicators in a fully saturated regression'. Computational Statistics, vol 23:1, pp.317-335.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isat">isat</a></code>, <code><a href="#topic+coef.gets">coef.gets</a></code>, <code><a href="#topic+plot.gets">plot.gets</a></code>, <code><a href="#topic+biascorr">biascorr</a></code>, <code><a href="#topic+isatvar">isatvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Using artificial data:
#set.seed(123)
#d &lt;- matrix(0,100,1)
#d[35:55] &lt;- 1
#e &lt;- rnorm(100, 0, 1)
#y &lt;- d*2  +e 
#plot(y, type="l")

##Static Test against hnull=0 using bias-correction:

#ys &lt;- isat(y, sis=TRUE, iis=FALSE, tis=FALSE, t.pval=0.01)
#isattest(ys, hnull=0, lr=FALSE, ci.pval = 0.99, plot.turn = FALSE, biascorr=TRUE)

##Dynamic Test of the long-run equilibrium against hnull=2 with breakpoints
##labelled in the plot:

#ys &lt;- isat(y, sis=TRUE, iis=FALSE, tis=FALSE, t.pval=0.01, ar=1:2)
#isattest(ys, hnull=2, lr=TRUE, ci.pval = 0.99, plot.turn = TRUE, biascorr=FALSE)
</code></pre>

<hr>
<h2 id='isatvar'>Variance of the coefficient path</h2><span id='topic+isatvar'></span>

<h3>Description</h3>

<p>Takes an 'isat' object returned by the <code>isat</code> function as input and returns the coefficient path of the constant (and long-run equilibrium if 'lr' is specified) together with its approximate variance and standard errors. If <code>mxfull</code> and <code>mxbreak</code> are specified, then the function returns the coefficient path of the user-specified variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  isatvar(x, lr=FALSE, conscorr=FALSE, effcorr=FALSE, mcor = 1, 
    mxfull = NULL, mxbreak=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isatvar_+3A_x">x</code></td>
<td>
<p>a 'gets' object obtained with the <code><a href="#topic+isat">isat</a></code> function</p>
</td></tr>
<tr><td><code id="isatvar_+3A_lr">lr</code></td>
<td>
<p>logical. If TRUE and 'x' contains autoregressive elements, then <code>isatvar</code> also returns the long-run equilibrium coefficient path with its variance and standard deviation. See Pretis (2015).</p>
</td></tr>
<tr><td><code id="isatvar_+3A_conscorr">conscorr</code></td>
<td>
<p>logical. If TRUE then the Johansen and Nielsen (2016) impulse-indicator consistency correction is applied to estimated residual variance.</p>
</td></tr>
<tr><td><code id="isatvar_+3A_effcorr">effcorr</code></td>
<td>
<p>logical. If TRUE then the Johansen and Nielsen (2016) m-step efficiency correction is applied to estimated standard errors of &lsquo;fixed&rsquo; regressors.</p>
</td></tr>
<tr><td><code id="isatvar_+3A_mcor">mcor</code></td>
<td>
<p>integer. The m-step efficiency correction factor, where m=mcor.</p>
</td></tr>
<tr><td><code id="isatvar_+3A_mxfull">mxfull</code></td>
<td>
<p>string. The name of the full-sample variable when constructing the coefficient path of user-specified break variables.</p>
</td></tr>
<tr><td><code id="isatvar_+3A_mxbreak">mxbreak</code></td>
<td>
<p>string. The name of the break variables used to construct the coefficient path of user-specified break variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the approximate variance and standard errors of the intercept term with structural breaks determined by <code><a href="#topic+isat">isat</a></code>. This permits hypothesis testing and plotting of approximate confidence intervals for the intercept in the presence of structural breaks. For dynamic autoregressive models in <code><a href="#topic+isat">isat</a></code> the <code>lr</code> argument returns the time-varying long-run equilibrium together with its approximate variance and standard errors. If <code>mxfull</code> and <code>mxbreak</code> are specified, then the function returns the coefficient path of the user-specified variable, where <code>mxfull</code> denotes the ful-sample variable name, to which the <code>mxbreak</code> variables are added. To correct for the under-estimation of the residual variance, the argument <code>conscorr</code> implements the Johansen and Nielsen (2016) consistency correction, and <code>effcorr</code> adds the efficiency correction for standard errors on fixed regressors which are not selected over.</p>


<h3>Value</h3>

<p>If <code>lr=FALSE</code>: A Tx4 matrix (with T = number of observations) where the first column denotes the coefficient path relative to the full sample coefficient, the second column the coefficient path of the intercept, the third the approximate variance of the coefficient path, and the fourth column the approximate standard errors of the coefficient path. If <code>lr=TRUE</code>: A Tx7 matrix where the first four columns are identical to the <code>lr=FALSE</code> case, and the additional columns denote the long-run equilibrium coefficient path, together with the approximate variance and standard errors of the long-run equilibrium coefficient path.</p>


<h3>Author(s)</h3>

<p>Felix Pretis, <a href="http://www.felixpretis.org/">http://www.felixpretis.org/</a><br />
James Reade, <a href="https://sites.google.com/site/jjamesreade/">https://sites.google.com/site/jjamesreade/</a>
</p>


<h3>References</h3>

<p>Pretis, F. (2015): 'Testing for time-varying predictive accuracy using bias-corrected indicator saturation'. Oxford Department of Economics ???orking Paper.
</p>
<p>Johansen, S., &amp; Nielsen, B. (2016): 'Asymptotic theory of outlier detection algorithms for linear time series regression models.' Scandinavian Journal of Statistics, 43(2), 321-348.
</p>
<p>Pretis, Felix, Reade, James and Sucarrat, Genaro (2018): 'Automated General-to-Specific (GETS) Regression Modeling and Indicator Saturation for Outliers and Structural Breaks'. Journal of Statistical Software 86, Number 3, pp. 1-44
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isat">isat</a></code>, <code><a href="#topic+coef.gets">coef.gets</a></code>, <code><a href="#topic+plot.gets">plot.gets</a></code>, <code><a href="#topic+biascorr">biascorr</a></code>, <code><a href="#topic+isattest">isattest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Variance in presence of a break
#nile &lt;- as.zoo(Nile)
#isat.nile &lt;- isat(nile, sis=TRUE, iis=FALSE, plot=FALSE, t.pval=0.005)
#var &lt;- isatvar(isat.nile)

#plot(nile)
#lines(isat.nile$mean.fit, col="red")
#lines(isat.nile$mean.fit + 2*var$const.se, col="blue", lty=3)
#lines(isat.nile$mean.fit - 2*var$const.se, col="blue", lty=3)

##Variance when there is no break
#set.seed(1)
#x &lt;- as.zoo(rnorm(100, 0, 1))
#isat.x &lt;- isat(x, sis=TRUE, iis=FALSE, plot=TRUE, t.pval=0.005)
#var.x &lt;- isatvar(isat.x)

#plot(x)
#lines(isat.x$mean.fit, col="red")
#lines(isat.x$mean.fit + 2*var.x[,2], col="blue", lty=3)
#lines(isat.x$mean.fit - 2*var.x[,2], col="blue", lty=3)

##Variance of the long-run equilibrium coefficient path

#nile &lt;- as.zoo(Nile)
#isat.nile &lt;- isat(nile, sis=TRUE, iis=FALSE, plot=TRUE, t.pval=0.005, ar=1:2)
#var &lt;- isatvar(isat.nile, lr=TRUE)
</code></pre>

<hr>
<h2 id='isatvarcorrect'>Consistency and Efficiency Correction for Impulse Indicator Saturation</h2><span id='topic+isatvarcorrect'></span>

<h3>Description</h3>

<p>Takes an <code><a href="#topic+isat">isat</a></code> object and corrects the estimates of the error variance and the estimated standard errors of 'forced' regressors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  isatvarcorrect(x, mcor=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isatvarcorrect_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+isat">isat</a></code> object</p>
</td></tr>
<tr><td><code id="isatvarcorrect_+3A_mcor">mcor</code></td>
<td>
<p>integer, number of iterations in the correction. Default = 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Impulse indicator saturation results in an under-estimation of the error variance as well as the variance of regressors not selected over. The magnitude of the inconsistency increases with the p-value of selection (<code>t.pval</code>). The function takes an <code><a href="#topic+isat">isat</a></code> object and applies the impulse indicator consistency (<code><a href="#topic+isvarcor">isvarcor</a></code>) and efficiency correction (<code><a href="#topic+isvareffcor">isvareffcor</a></code>) of the estimated error variance and the estimated variance of regressors not selected over. See Johansen and Nielsen (2016a) and (2016b).</p>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+isat">isat</a></code> object in which the estimated standard errors, t-statistics, p-values, standard error of the regression, and log-likelihood are consistency and efficiency corrected when using impulse indicator saturation (<code>iis=TRUE</code>).</p>


<h3>Author(s)</h3>

<p>Felix Pretis, <a href="http://www.felixpretis.org/">http://www.felixpretis.org/</a>
</p>


<h3>References</h3>

<p>Johansen, S., &amp; Nielsen, B. (2016a). Asymptotic theory of outlier detection algorithms for linear time series regression models. Scandinavian Journal of Statistics, 43(2), 321-348.
</p>
<p>Johansen, S., &amp; Nielsen, B. (2016b). Rejoinder: Asymptotic Theory of Outlier Detection Algorithms for Linear. Scandinavian Journal of Statistics, 43(2), 374-381.
</p>
<p>Pretis, F., Reade, J., &amp; Sucarrat, G. (2018). Automated General-to-Specific (GETS) regression modeling and indicator saturation methods for the detection of outliers and structural breaks. Journal of Statistical Software, 86(3).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isat">isat</a></code>, <code><a href="#topic+isvarcor">isvarcor</a></code>, <code><a href="#topic+isvareffcor">isvareffcor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###Consistency and Efficiency Correction of Impulse Indicator Estimates
nile &lt;- as.zoo(Nile)
isat.nile &lt;- isat(nile, sis=FALSE, iis=TRUE, plot=TRUE, t.pval=0.1)
isat.nile.corrected &lt;- isatvarcorrect(isat.nile)

isat.nile$sigma2
isat.nile.corrected$sigma2
</code></pre>

<hr>
<h2 id='isvarcor'>IIS Consistency Correction</h2><span id='topic+isvarcor'></span>

<h3>Description</h3>

<p>Consistency correction for estimate of residual variance when using impulse indicator saturation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>isvarcor(t.pval, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isvarcor_+3A_t.pval">t.pval</code></td>
<td>
<p>numeric value. the p-value of selection in the impulse indicator saturation model.</p>
</td></tr>
<tr><td><code id="isvarcor_+3A_sigma">sigma</code></td>
<td>
<p>numeric value. The estimated standard deviation of the residuals from the impulse indicator saturation model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Johansen and Nielsen (2016) impulse-indicator consistency correction for the estimated residual standard deviation.
</p>


<h3>Value</h3>

<p>a data frame containing the corrected standard deviation <code>$sigma.cor</code> and the correction factor used <code>$corxi</code></p>


<h3>Author(s)</h3>

<p>Felix Pretis, <a href="http://www.felixpretis.org/">http://www.felixpretis.org/</a>
</p>


<h3>References</h3>

<p>Johansen, S., &amp; Nielsen, B. (2016): 'Asymptotic theory of outlier detection algorithms for linear time series regression models.' Scandinavian Journal of Statistics, 43(2), 321-348.
</p>
<p>Pretis, Felix, Reade, James and Sucarrat, Genaro (2018): 'Automated General-to-Specific (GETS) Regression Modeling and Indicator Saturation for Outliers and Structural Breaks'. Journal of Statistical Software 86, Number 3, pp. 1-44
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isatvar">isatvar</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
isvarcor(t.pval=0.05, sigma=2)

</code></pre>

<hr>
<h2 id='isvareffcor'>IIS Efficiency Correction</h2><span id='topic+isvareffcor'></span>

<h3>Description</h3>

<p>Efficiency correction for the estimates of coefficient standard errors on fixed regressors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>isvareffcor(t.pval, se, m=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isvareffcor_+3A_t.pval">t.pval</code></td>
<td>
<p>numeric value. the p-value of selection in the impulse indicator saturation model.</p>
</td></tr>
<tr><td><code id="isvareffcor_+3A_se">se</code></td>
<td>
<p>numeric value or vector. The estimated standard errors of the coefficients on fixed regressors in impulse indicator saturation model.</p>
</td></tr>
<tr><td><code id="isvareffcor_+3A_m">m</code></td>
<td>
<p>integer. The m-step correction factor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Johansen and Nielsen (2016) impulse-indicator efficiency correction for the estimated standard errors on fixed regressors in impulse indicator models.
</p>


<h3>Value</h3>

<p>a data frame containing the corrected standard deviation <code>$se.cor</code> and the correction factor used <code>$eta.m</code></p>


<h3>Author(s)</h3>

<p>Felix Pretis, <a href="http://www.felixpretis.org/">http://www.felixpretis.org/</a>
</p>


<h3>References</h3>

<p>Johansen, S., &amp; Nielsen, B. (2016): 'Asymptotic theory of outlier detection algorithms for linear time series regression models.' Scandinavian Journal of Statistics, 43(2), 321-348.
</p>
<p>Pretis, Felix, Reade, James and Sucarrat, Genaro (2018): 'Automated General-to-Specific (GETS) Regression Modeling and Indicator Saturation for Outliers and Structural Breaks'. Journal of Statistical Software 86, Number 3, pp. 1-44
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isatvar">isatvar</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
isvareffcor(t.pval=0.05, se=2, m=1)

</code></pre>

<hr>
<h2 id='logit'>Estimation of a logit model</h2><span id='topic+logit'></span>

<h3>Description</h3>

<p>Maximum Likelihood (ML) estimation of a logit model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(y, x, initial.values = NULL, lower = -Inf, upper = Inf, 
    method = 2, lag.length = NULL, control = list(), eps.tol = .Machine$double.eps, 
    solve.tol = .Machine$double.eps )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logit_+3A_y">y</code></td>
<td>
<p>numeric vector, the binary process</p>
</td></tr>
<tr><td><code id="logit_+3A_x">x</code></td>
<td>
<p>numeric matrix, the regressors</p>
</td></tr>
<tr><td><code id="logit_+3A_initial.values">initial.values</code></td>
<td>
<p><code>NULL</code> or a numeric vector with the initial parameter values passed on to the optimisation routine, <code><a href="stats.html#topic+nlminb">nlminb</a></code>. If <code>NULL</code>, the default, then the values are chosen automatically </p>
</td></tr>
<tr><td><code id="logit_+3A_lower">lower</code></td>
<td>
<p>numeric vector, either of length 1 or the number of parameters to be estimated, see <code><a href="stats.html#topic+nlminb">nlminb</a></code> </p>
</td></tr>
<tr><td><code id="logit_+3A_upper">upper</code></td>
<td>
<p>numeric vector, either of length 1 or the number of parameters to be estimated, see <code><a href="stats.html#topic+nlminb">nlminb</a></code> </p>
</td></tr>
<tr><td><code id="logit_+3A_method">method</code></td>
<td>
<p>an integer that determines the expression for the coefficient-covariance, see &quot;details&quot;</p>
</td></tr>
<tr><td><code id="logit_+3A_lag.length">lag.length</code></td>
<td>
<p><code>NULL</code> or an integer that determines the lag-length used in the robust coefficient covariance. If <code>lag.length</code> is an integer, then it is ignored unless <code>method = 3</code> </p>
</td></tr>
<tr><td><code id="logit_+3A_control">control</code></td>
<td>
<p>a <code>list</code> passed on to the control argument of <code><a href="stats.html#topic+nlminb">nlminb</a></code> </p>
</td></tr>
<tr><td><code id="logit_+3A_eps.tol">eps.tol</code></td>
<td>
<p>numeric, a small value that ensures the fitted zero-probabilities are not too small when the log-transformation is applied when computing the log-likelihood </p>
</td></tr>
<tr><td><code id="logit_+3A_solve.tol">solve.tol</code></td>
<td>
<p>numeric value passed on to the <code>tol</code> argument of <code><a href="base.html#topic+solve">solve</a></code>, which is called whenever the coefficient-coariance matrix is computed. The value controls the toleranse for detecting linear dependence between columns when inverting a matrix </p>
</td></tr>
</table>


<h3>Details</h3>

<p>No details for the moment.</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code>.</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>References</h3>

<p>No references for the moment.</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+nlminb">nlminb</a></code>, <code><a href="base.html#topic+solve">solve</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>##no examples for the moment
</code></pre>

<hr>
<h2 id='logitx'>Estimate an autoregressive logit model with covariates</h2><span id='topic+logitx'></span><span id='topic+dlogitx'></span>

<h3>Description</h3>

<p>Estimate a dynamic Autoregressive (AR) logit model with covariates ('X') by maximising the logit likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logitx(y, intercept = TRUE, ar = NULL, ewma = NULL, xreg = NULL, 
    vcov.type = c("ordinary", "robust"), lag.length = NULL, 
    initial.values = NULL, lower = -Inf, upper = Inf, control = list(), 
    eps.tol = .Machine$double.eps, solve.tol = .Machine$double.eps,
    singular.ok = TRUE, plot = NULL)

dlogitx(y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logitx_+3A_y">y</code></td>
<td>
<p>a binary numeric vector, time-series or <code><a href="zoo.html#topic+zoo">zoo</a></code> object. Missing values in the beginning and at the end of the series is allowed, as they are removed with the <code><a href="zoo.html#topic+na.trim">na.trim</a></code> command</p>
</td></tr>
<tr><td><code id="logitx_+3A_intercept">intercept</code></td>
<td>
<p>logical. <code>TRUE</code>, the default, includes an intercept in the logit specification, whereas <code>FALSE</code> does not</p>
</td></tr>
<tr><td><code id="logitx_+3A_ar">ar</code></td>
<td>
<p>either <code>NULL</code> (default) or an integer vector, say, <code>c(2,4)</code> or <code>1:4</code>. The AR-lags to include in the logit specification. If <code>NULL</code>, then no lags are included</p>
</td></tr>
<tr><td><code id="logitx_+3A_ewma">ewma</code></td>
<td>
<p>either <code>NULL</code> (default) or a <code><a href="base.html#topic+list">list</a></code> with arguments sent to the <code><a href="#topic+eqwma">eqwma</a></code> function. In the latter case a lagged moving average of <code>y</code> is included as a regressor</p>
</td></tr>
<tr><td><code id="logitx_+3A_xreg">xreg</code></td>
<td>
<p>either <code>NULL</code> (default) or a numeric vector or matrix, say, a <code><a href="zoo.html#topic+zoo">zoo</a></code> object, of covariates. Note that, if both <code>y</code> and <code>xreg</code> are <code>zoo</code> objects, then their samples are chosen to match</p>
</td></tr>
<tr><td><code id="logitx_+3A_vcov.type">vcov.type</code></td>
<td>
<p>character vector of length 1, either &quot;ordinary&quot; (default) or &quot;robust&quot;. Partial matching is allowed. If &quot;ordinary&quot;, then the ordinary variance-covariance matrix is used for inference. If &quot;robust&quot;, then a robust coefficient-covariance of the Newey and West (1987) type is used </p>
</td></tr>
<tr><td><code id="logitx_+3A_lag.length">lag.length</code></td>
<td>
<p><code>NULL</code> or an integer that determines the lag-length used in the robust coefficient covariance. If <code>lag.length</code> is an integer, then it is ignored unless <code>method = 3</code> </p>
</td></tr>
<tr><td><code id="logitx_+3A_initial.values">initial.values</code></td>
<td>
<p><code>NULL</code> or a numeric vector with the initial parameter values passed on to the optimisation routine, <code><a href="stats.html#topic+nlminb">nlminb</a></code>. If <code>NULL</code>, the default, then the values are chosen automatically </p>
</td></tr>
<tr><td><code id="logitx_+3A_lower">lower</code></td>
<td>
<p>numeric vector, either of length 1 or the number of parameters to be estimated, see <code><a href="stats.html#topic+nlminb">nlminb</a></code> </p>
</td></tr>
<tr><td><code id="logitx_+3A_upper">upper</code></td>
<td>
<p>numeric vector, either of length 1 or the number of parameters to be estimated, see <code><a href="stats.html#topic+nlminb">nlminb</a></code> </p>
</td></tr>
<tr><td><code id="logitx_+3A_control">control</code></td>
<td>
<p>a <code>list</code> passed on to the control argument of <code><a href="stats.html#topic+nlminb">nlminb</a></code> </p>
</td></tr>
<tr><td><code id="logitx_+3A_eps.tol">eps.tol</code></td>
<td>
<p>numeric, a small value that ensures the fitted zero-probabilities are not too small when the log-transformation is applied when computing the log-likelihood </p>
</td></tr>
<tr><td><code id="logitx_+3A_solve.tol">solve.tol</code></td>
<td>
<p>numeric value passed on to the <code>tol</code> argument of <code><a href="base.html#topic+solve">solve</a></code>, which is called whenever the coefficient-coariance matrix is computed. The value controls the toleranse for detecting linear dependence between columns when inverting a matrix </p>
</td></tr>
<tr><td><code id="logitx_+3A_singular.ok">singular.ok</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), then the regressors causing the singularity are dropped (using <code><a href="#topic+dropvar">dropvar</a></code>) before estimation. If <code>FALSE</code>, singularity returns error</p>
</td></tr>
<tr><td><code id="logitx_+3A_plot">plot</code></td>
<td>
<p><code>NULL</code> or logical. If <code>TRUE</code>, then a plot is produced. If <code>NULL</code> (default), then the value set by <code><a href="base.html#topic+options">options</a></code> determines whether a plot is produced or not.</p>
</td></tr>
<tr><td><code id="logitx_+3A_...">...</code></td>
<td>
<p>arguments passed on to <code>logitx</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimates a dynamic Autoregressive (AR) logit model with (optionally) covariates ('X') by maximising the logit likelihood. The estimated model is an augmented version of the model considered by Kauppi and Saikkonen (2008). Also, they considered estimation is by maximisation of the probit likelihood. Here, by contrast, estimation is by maximisation of the logit likelihood.
</p>


<h3>Value</h3>

<p>A list of class 'logitx'.</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>References</h3>

<p>Heikki Kauppi and Pentti Saikkonen (2008): 'Predicting U.S. Recessions with Dynamic Binary Response Models'. The Review of Economics and Statistics 90, pp. 777-791
</p>
<p>Whitney K. Newey and Kenned D. West (1987): 'A Simple, Positive Semi-Definite, Heteroskedasticity and Autocorrelation Consistent Covariance Matrix', Econometrica 55, pp. 703-708
</p>


<h3>See Also</h3>

<p>Methods: <code><a href="#topic+coef.logitx">coef.logitx</a></code>, <code><a href="#topic+fitted.logitx">fitted.logitx</a></code>, <code><a href="#topic+gets.logitx">gets.logitx</a></code>, <br />
<code><a href="#topic+logLik.logitx">logLik.logitx</a></code>, <code><a href="#topic+plot.logitx">plot.logitx</a></code>, <code><a href="#topic+print.logitx">print.logitx</a></code>, <code><a href="#topic+summary.logitx">summary.logitx</a></code>, <code><a href="#topic+toLatex.logitx">toLatex.logitx</a></code> and <code><a href="#topic+vcov.logitx">vcov.logitx</a></code><br />
</p>
<p>Related functions: <code><a href="#topic+logitxSim">logitxSim</a></code>, <code><a href="#topic+logit">logit</a></code>, <code><a href="stats.html#topic+nlminb">nlminb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##simulate from ar(1):
set.seed(123) #for reproducibility
y &lt;- logitxSim(100, ar=0.3)

##estimate ar(1) and store result:
mymod &lt;- logitx(y, ar=1)

##estimate ar(4) and store result:
mymod &lt;- logitx(y, ar=1:4)

##create some more data, estimate new model:
x &lt;- matrix(rnorm(5*100), 100, 5)
mymod &lt;- logitx(y, ar=1:4, xreg=x)

</code></pre>

<hr>
<h2 id='logitxSim'>Simulate from a dynamic logit-x model</h2><span id='topic+logitxSim'></span><span id='topic+dlogitxSim'></span>

<h3>Description</h3>

<p>Simulate from a dynamic Autoregressive (AR) logit model with covariates ('X'). This model is essentially a logit-version of the model of Kauppi and Saikkonen (2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logitxSim(n, intercept = 0, ar = NULL, xreg = NULL, verbose = FALSE, 
    as.zoo = TRUE)

dlogitxSim(n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logitxSim_+3A_n">n</code></td>
<td>
<p>integer, the number of observations to generate</p>
</td></tr>
<tr><td><code id="logitxSim_+3A_intercept">intercept</code></td>
<td>
<p>numeric, the value of the intercept in the logit specification</p>
</td></tr>
<tr><td><code id="logitxSim_+3A_ar">ar</code></td>
<td>
<p><code>NULL</code> or a numeric vector with the autoregressive parameters</p>
</td></tr>
<tr><td><code id="logitxSim_+3A_xreg">xreg</code></td>
<td>
<p><code>NULL</code> or numeric vector with the values of the X-term</p>
</td></tr>
<tr><td><code id="logitxSim_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>. If <code>FALSE</code>, then only the binary process (a vector) is returned. If <code>TRUE</code>, then a matrix with all the simulated information is returned (binary process, probabilities, etc.)</p>
</td></tr>
<tr><td><code id="logitxSim_+3A_as.zoo">as.zoo</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, then the returned object - a vector or matrix - will be of class <code><a href="zoo.html#topic+zoo">zoo</a></code> </p>
</td></tr>
<tr><td><code id="logitxSim_+3A_...">...</code></td>
<td>
<p>arguments passed on to <code>logitxSim</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>No details, for the moment.</p>


<h3>Value</h3>

<p>A vector or matrix, depending on whether <code>verbose</code> is <code>FALSE</code> or <code>TRUE</code>, of class <code><a href="zoo.html#topic+zoo">zoo</a></code>, depending on whether <code>as.zoo</code> is <code>TRUE</code> or <code>FALSE</code>
</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>References</h3>

<p>Heikki Kauppi and Penti Saikkonen (2008): 'Predicting U.S. Recessions with Dynamic Binary Response Models'. The Review of Economic Statistics 90, pp. 777-791
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logitx">logitx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##simulate from ar(1):
set.seed(123) #for reproducibility
y &lt;- logitxSim(100, ar=0.3)

##more output (value, probability, logit):
set.seed(123) #for reproducibility
y &lt;- logitxSim(100, ar=0.3, verbose=TRUE)

</code></pre>

<hr>
<h2 id='mvrnormsim'>Simulate from a Multivariate Normal Distribution</h2><span id='topic+mvrnormsim'></span>

<h3>Description</h3>

<p>Produces one or more samples from the specified multivariate normal distribution. Used
in<br />
<code><a href="#topic+outlierscaletest">outlierscaletest</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvrnormsim(n = 1, mu, Sigma, tol = 1e-6, empirical = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvrnormsim_+3A_n">n</code></td>
<td>
<p>the number of samples required.</p>
</td></tr>
<tr><td><code id="mvrnormsim_+3A_mu">mu</code></td>
<td>
<p>a vector giving the means of the variables.</p>
</td></tr>
<tr><td><code id="mvrnormsim_+3A_sigma">Sigma</code></td>
<td>
<p>a positive-definite symmetric matrix specifying the covariance matrix of the variables.</p>
</td></tr>
<tr><td><code id="mvrnormsim_+3A_tol">tol</code></td>
<td>
<p>tolerance (relative to largest variance) for numerical lack of positive-definiteness in Sigma.</p>
</td></tr>
<tr><td><code id="mvrnormsim_+3A_empirical">empirical</code></td>
<td>
<p>logical. If true, mu and Sigma specify the empirical not population mean and covariance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Original function <code>mvrnorm</code> developed by Venables, W. N. &amp; Ripley. in package <code>MASS</code>, <a href="https://CRAN.R-project.org/package=MASS">https://CRAN.R-project.org/package=MASS</a>.
</p>


<h3>Value</h3>

<p>If n = 1 a vector of the same length as mu, otherwise an n by length(mu) matrix with one sample in each row.</p>


<h3>Author(s)</h3>

<p>Venables, W. N. &amp; Ripley, with modifications by Felix Pretis, <a href="http://www.felixpretis.org/">http://www.felixpretis.org/</a>
</p>


<h3>References</h3>

<p>Venables, W. N. &amp; Ripley, B. D. (2019): 'MASS: Support Functions and Datasets for Venables and Ripley's MASS'. <a href="https://CRAN.R-project.org/package=MASS">https://CRAN.R-project.org/package=MASS</a>
</p>
<p>Venables, W. N. &amp; Ripley, B. D. (2002) Modern Applied Statistics with S. Fourth Edition. Springer, New York. ISBN 0-387-95457-0
</p>


<h3>See Also</h3>

<p><code><a href="#topic+outlierscaletest">outlierscaletest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Sigma &lt;- matrix(c(3,2,1,7),2,2)
mvrnormsim(n=2, mu=c(1,2), Sigma)
</code></pre>

<hr>
<h2 id='ols'>OLS estimation</h2><span id='topic+ols'></span>

<h3>Description</h3>

<p>OLS estimation with the QR decomposition and, for some options, computation of variance-
covariance matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ols(y, x, untransformed.residuals=NULL, tol=1e-07, LAPACK=FALSE, method=3, 
  variance.spec=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ols_+3A_y">y</code></td>
<td>
<p>numeric vector, the regressand</p>
</td></tr>
<tr><td><code id="ols_+3A_x">x</code></td>
<td>
<p>numeric matrix, the regressors</p>
</td></tr>
<tr><td><code id="ols_+3A_untransformed.residuals">untransformed.residuals</code></td>
<td>
<p><code>NULL</code> (default) or, when <code><a href="#topic+ols">ols</a></code> is used with <code>method=6</code>, a numeric vector containing the untransformed residuals</p>
</td></tr>
<tr><td><code id="ols_+3A_tol">tol</code></td>
<td>
<p>numeric value. The tolerance for detecting linear dependencies in the columns of the regressors, see the <code><a href="base.html#topic+qr">qr</a></code> function. Only used if <code>LAPACK</code> is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="ols_+3A_lapack">LAPACK</code></td>
<td>
<p>logical, <code>TRUE</code> or <code>FALSE</code> (default). If true use LAPACK otherwise use LINPACK, see the <code><a href="base.html#topic+qr">qr</a></code> function </p>
</td></tr>
<tr><td><code id="ols_+3A_method">method</code></td>
<td>
<p>an integer, 1 to 6, that determines the estimation method</p>
</td></tr>
<tr><td><code id="ols_+3A_variance.spec">variance.spec</code></td>
<td>
<p><code>NULL</code> or a <code><a href="base.html#topic+list">list</a></code> with items that specifies the log-variance model to be estimated, see <code><a href="#topic+arx">arx</a></code> </p>
</td></tr>
<tr><td><code id="ols_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>method = 1</code> or <code>method = 2</code> only returns the OLS coefficient estimates together with the QR-
information, the former being slightly faster. <code>method=3</code> returns, in addition, the ordinary variance-covariance matrix of the OLS estimator. <code>method=4</code> returns the White (1980) heteroscedasticity robust variance-covariance matrix in addition to the information returned by <code>method=3</code>, whereas <code>method=5</code> does the same except that the variance-covariance matrix now is that of Newey and West (1987). <code>method=6</code> undertakes OLS estimation of a log-variance model, see Pretis, Reade and Sucarrat (2018, Section 4). Alternatively, for <code>method</code> 1 to 5, a log-variance model is also estimated if <code>variance.spec</code> is not <code>NULL</code>.
</p>


<h3>Value</h3>

<p>A list with items depending on <code>method</code></p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>References</h3>

<p>W. Newey and K. West (1987): 'A Simple Positive Semi-Definite, Heteroskedasticity and Autocorrelation Consistent Covariance Matrix', Econometrica 55, pp. 703-708.
</p>
<p>F. Pretis, J. Reade and G. Sucarrat (2018): 'Automated General-to-Specific (GETS) Regression Modeling and Indicator Saturation for Outliers and Structural Breaks', Journal of Statistical Software 86, Issue 3, pp. 1-44, DOI: https://doi.org/10.18637/jss.v086.i03
</p>
<p>H. White (1980): 'A Heteroskedasticity-Consistent Covariance Matrix and a Direct Test for Heteroskedasticity', Econometrica 48, pp. 817-838.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+qr">qr</a></code>, <code><a href="base.html#topic+solve.qr">solve.qr</a></code>, <code><a href="#topic+arx">arx</a></code> </p>

<hr>
<h2 id='outlierscaletest'>Sum and Sup Scaling Outlier Tests</h2><span id='topic+outlierscaletest'></span>

<h3>Description</h3>

<p>Computes the Sum and Supremum Scaling Tests for the overall presence of outliers based on Jiao and Pretis (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  outlierscaletest(x, nsim = 10000)
  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outlierscaletest_+3A_x">x</code></td>
<td>
<p>list, output of the <code><a href="#topic+isatloop">isatloop</a></code> function</p>
</td></tr>
<tr><td><code id="outlierscaletest_+3A_nsim">nsim</code></td>
<td>
<p>integer, number of replications to simulate critical values for the Sup test</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes the output of the <code><a href="#topic+isatloop">isatloop</a></code> function and computes the Scaling Sum and Supremum Tests for the presence of outliers from Jiao and Pretis (2019). The test compares the expected and observed proportion of outliers over the range of different significance levels of selection specified in <code><a href="#topic+isatloop">isatloop</a></code>. The Sum test compares the sum of deviations against the standard normal distribution, the Sup test compares the supremum of deviations against critical values simulated with <code>nsim</code> replications. The null hypothesis is that the observed proportion of outliers scales with the proportion of outliers under the null of no outliers.</p>


<h3>Value</h3>

<p>Returns a list of two <code>htest</code> objects. The first providing the results of the Sum test on the sum of the deviation of outliers against a standard normal distribution. The second providing the results on the supremum of the deviation of outliers against simulated critical values.</p>


<h3>Author(s)</h3>

<p>Xiyu Jiao, &amp; Felix Pretis, <a href="http://www.felixpretis.org/">http://www.felixpretis.org/</a>
</p>


<h3>References</h3>

<p>Jiao, X. &amp; Pretis, F. (2019). Testing the Presence of Outliers in Regression Models. Discussion Paper.
</p>
<p>Pretis, F., Reade, J., &amp; Sucarrat, G. (2018). Automated General-to-Specific (GETS) regression modeling and indicator saturation methods for the detection of outliers and structural breaks. Journal of Statistical Software, 86(3).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isat">isat</a></code>, <code><a href="#topic+isatloop">isatloop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ###Repeated isat models using the Nile dataset
  ### where p-values are chosen such that the expected number of outliers under the null
  ### corresponds to 1, 2, ..., 20. Then computing the Outlier Scaling Tests:
  
  #nile &lt;- as.zoo(Nile)
  #isat.nile.loop &lt;- isatloop(y=nile)
  #outlierscaletest(isat.nile.loop)
  
</code></pre>

<hr>
<h2 id='outliertest'>Jiao and Pretis Outlier Proportion and Count Tests</h2><span id='topic+outliertest'></span>

<h3>Description</h3>

<p>Tests whether the proportion (or number) of outliers detected using impulse indicator saturation is different from the proportion (or number) of outliers expected under the null hypothesis of no outliers using the Jiao and Pretis (2019) proportion and count outlier tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  outliertest(x, noutl=NULL, t.pval=NULL, T=NULL, 
  m=1, infty=FALSE, alternative="two.sided")
  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outliertest_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+isat">isat</a></code> object</p>
</td></tr>
<tr><td><code id="outliertest_+3A_noutl">noutl</code></td>
<td>
<p>integer, number of detected outliers if no <code><a href="#topic+isat">isat</a></code> object is provided i.e. x=NULL</p>
</td></tr>
<tr><td><code id="outliertest_+3A_t.pval">t.pval</code></td>
<td>
<p>numeric, between 0 and 1. Selection p-value used in indicator saturation if no <code><a href="#topic+isat">isat</a></code> object is provided i.e. x=NULL</p>
</td></tr>
<tr><td><code id="outliertest_+3A_t">T</code></td>
<td>
<p>integer, sample sized used in indicator saturation if no <code><a href="#topic+isat">isat</a></code> object is provided i.e. x=NULL</p>
</td></tr>
<tr><td><code id="outliertest_+3A_m">m</code></td>
<td>
<p>integer, number of iterations in variance computation, default=1</p>
</td></tr>
<tr><td><code id="outliertest_+3A_infty">infty</code></td>
<td>
<p>logical, argument used for variance computation</p>
</td></tr>
<tr><td><code id="outliertest_+3A_alternative">alternative</code></td>
<td>
<p>&quot;two-sided&quot;, &quot;less&quot;, &quot;greater&quot;, alternative hypothesis of outlier test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the estimated proportion of outliers (gauge) based on impulse indicator saturation and constructs the proportion and count outlier test statistics from Jiao and Pretis (2019). The null hypothesis is that the proportion (or count) of outliers is not different than the proportion (or count) of outliers detected under the null hypothesis of no outliers. The first test compares the estimated proportion of outliers scaled by its estimated variance against a standard normal distribution. The second test compares the number of outliers against a Poisson distribution.
If an <code><a href="#topic+isat">isat</a></code> object is provided in <code>x</code>, then the function automatically extracts the detected impulses and computes the estimated outlier proportion. If no <code><a href="#topic+isat">isat</a></code> object is provided and <code>x=NULL</code>, then the tests can be conducted manually by providing the number of detected outliers (<code>noutl</code>), the sample size (<code>T</code>), and the chosen level of signficance used to detect outliers (<code>t.pval</code>).</p>


<h3>Value</h3>

<p>Returns a list of two <code>htest</code> objects. The first providing the results of the test on the proportion of outliers against a standard normal distribution. The second providing the results on the number of outliers against the Poisson distribution.</p>


<h3>Author(s)</h3>

<p>Xiyu Jiao, &amp; Felix Pretis, <a href="http://www.felixpretis.org/">http://www.felixpretis.org/</a>
</p>


<h3>References</h3>

<p>Jiao, X. &amp; Pretis, F. (2019). Testing the Presence of Outliers in Regression Models. Discussion Paper.
</p>
<p>Pretis, F., Reade, J., &amp; Sucarrat, G. (2018). Automated General-to-Specific (GETS) regression modeling and indicator saturation methods for the detection of outliers and structural breaks. Journal of Statistical Software, 86(3).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isat">isat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ###Testing the Presence of Outliers in the Nile Data
  nile &lt;- as.zoo(Nile)
  isat.nile &lt;- isat(nile, sis=FALSE, iis=TRUE, plot=TRUE, t.pval=0.1)
  outliertest(isat.nile)
  
  ###Testing the number of outliers when the sample is T=200, 
  ### with 7 detected outliers at t.pval=0.05 if no isat object is provided:
  outliertest(x=NULL, noutl=7, t.pval=0.05, T=200)
  
</code></pre>

<hr>
<h2 id='paths'>Extraction functions for 'arx', 'gets' and 'isat' objects</h2><span id='topic+paths'></span><span id='topic+rsquared'></span><span id='topic+terminals'></span>

<h3>Description</h3>

<p>Extraction functions for objects of class 'arx', 'gets' and 'isat'</p>


<h3>Usage</h3>

<pre><code class='language-R'>paths(object, ...)
terminals(object, ...)
rsquared(object, adjusted=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paths_+3A_object">object</code></td>
<td>
<p>an object of class 'arx', 'gets' or 'isat'</p>
</td></tr>
<tr><td><code id="paths_+3A_adjusted">adjusted</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> the adjusted R-squared is returned </p>
</td></tr>
<tr><td><code id="paths_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>paths</code> and <code>terminals</code> can only be applied on objects of class 'gets' and 'isat'
</p>


<h3>Value</h3>

<table>
<tr><td><code>paths:</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> with the paths searched (each number refers to a regressor in the GUM)</p>
</td></tr>
<tr><td><code>terminals:</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> with the terminal models (each number refers to a regressor in the GUM)</p>
</td></tr>
<tr><td><code>rsquared:</code></td>
<td>
<p>a <code><a href="base.html#topic+numeric">numeric</a></code>, the R-squared of the regression, or adjusted R-squared if <code>adjusted</code> is set to <code>TRUE</code> </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+getsm">getsm</a></code>, <code><a href="#topic+getsm">getsm</a></code>, <code><a href="#topic+getsv">getsv</a></code>, <code><a href="#topic+isat">isat</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>##Simulate from an AR(1):
set.seed(123)
y &lt;- arima.sim(list(ar=0.4), 50)

##Simulate four independent Gaussian regressors:
xregs &lt;- matrix(rnorm(4*50), 50, 4)

##estimate an AR(2) with intercept and four conditioning
##regressors in the mean:
mymod &lt;- arx(y, mc=TRUE, ar=1:2, mxreg=xregs)
rsquared(mymod)
rsquared(mymod, adjusted=TRUE)

##General-to-Specific (GETS) modelling of the mean:
meanmod &lt;- getsm(mymod)
rsquared(meanmod)
rsquared(meanmod, adjusted=TRUE)

##extract the paths searched:
paths(meanmod)

##extract the terminal models:
terminals(meanmod)
</code></pre>

<hr>
<h2 id='periodicdummies'>Make matrix of periodicity (e.g. seasonal) dummies</h2><span id='topic+periodicdummies'></span>

<h3>Description</h3>

<p>Auxiliary function that generates periodicity dummies (e.g. seasonal dummies) for regular time series. The function is similar to, but more general than, the <code>seasonaldummy</code> function in the forecast package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>periodicdummies(x, values=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="periodicdummies_+3A_x">x</code></td>
<td>
<p>a regular time series (vector or matrix)</p>
</td></tr>
<tr><td><code id="periodicdummies_+3A_values">values</code></td>
<td>
<p>numeric of length 1 (default) or numeric vector of length equal to frequency(x) </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of class zoo with the periodicity dummies</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a>
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+is.regular">is.regular</a></code>, <code><a href="zoo.html#topic+zooreg">zooreg</a></code>, <code><a href="zoo.html#topic+zoo">zoo</a></code>, <code><a href="stats.html#topic+ts">ts</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>##quarterly dummies:
x &lt;- zooreg(rnorm(30), start=2000, frequency=4)
periodicdummies(x)

##monthly dummies:
y &lt;- zooreg(rnorm(30), start=c(2000,1), frequency=12)
periodicdummies(y)

</code></pre>

<hr>
<h2 id='predict.arx'>Forecasting with 'arx' models</h2><span id='topic+predict.arx'></span>

<h3>Description</h3>

<p>Generate out-of-sample forecasts up to n steps ahead for objects of class <code><a href="#topic+arx">arx</a></code>. Optionally, quantiles of the forecasts are also returned if any of the arguments <code>ci.levels</code> or <code>probs</code> are specified. The forecasts, confidence intervals and quantiles are obtained via simulation. By default, 5000 simulations is used, but this can be changed via the <code>n.sim</code> argument. Also by default, the simulations uses a classical bootstrap to sample from the standardised residuals. To use an alternative set of standardised innovations, for example the standard normal, use the <code>innov</code> argument. If <code>plot=TRUE</code>, then a plot of the forecasts is created.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'arx'
predict(object, spec=NULL, n.ahead=12, newmxreg=NULL,
    newvxreg=NULL, newindex=NULL, n.sim=5000, innov=NULL, probs=NULL,
    ci.levels=NULL, quantile.type=7, return=TRUE, verbose=FALSE,
    plot=NULL, plot.options=list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.arx_+3A_object">object</code></td>
<td>
<p>an object of class 'arx'</p>
</td></tr>
<tr><td><code id="predict.arx_+3A_spec">spec</code></td>
<td>
<p><code>NULL</code> (default), <code>"mean"</code>, <code>"variance"</code> or <code>"both"</code>. If <code>NULL</code>, then it is automatically determined whether information pertaining to the mean or variance specification should be returned</p>
</td></tr>
<tr><td><code id="predict.arx_+3A_n.ahead">n.ahead</code></td>
<td>
<p><code>integer</code> that determines how many steps ahead predictions should be generated (the default is 12)</p>
</td></tr>
<tr><td><code id="predict.arx_+3A_newmxreg">newmxreg</code></td>
<td>
<p>a <code>matrix</code> of <code>n.ahead</code> rows and <code>NCOL(mxreg)</code> columns with the out-of-sample values of the <code>mxreg</code> regressors</p>
</td></tr>
<tr><td><code id="predict.arx_+3A_newvxreg">newvxreg</code></td>
<td>
<p>a <code>matrix</code> of <code>n.ahead</code> rows and <code>NCOL(vxreg)</code> columns with the out-of-sample values of the <code>vxreg</code> regressors</p>
</td></tr>
<tr><td><code id="predict.arx_+3A_newindex">newindex</code></td>
<td>
<p><code>NULL</code> (default) or the date-index for the <code>zoo</code> object returned by <code>predict.arx</code>. If <code>NULL</code>, then the function uses the in-sample <code>index</code> to generate the out-of-sample index</p>
</td></tr>
<tr><td><code id="predict.arx_+3A_n.sim">n.sim</code></td>
<td>
<p><code>integer</code>, the number of replications used for the generation of the forecasts</p>
</td></tr>
<tr><td><code id="predict.arx_+3A_innov">innov</code></td>
<td>
<p><code>NULL</code> (default) or a vector of length <code>n.ahead * n.sim</code> containing the standardised errors (that is, zero mean and unit variance) used for the forecast simulations. If <code>NULL</code>, then a classica bootstrap procedure is used to draw from the standardised in-sample residuals</p>
</td></tr>
<tr><td><code id="predict.arx_+3A_probs">probs</code></td>
<td>
<p><code>NULL</code> (default) or a <code>vector</code> with the quantile-levels (values strictly between 0 and 1) of the forecast distribution. If <code>NULL</code>, then no quantiles are returned unless <code>ci.levels</code> is non-<code>NULL</code></p>
</td></tr>
<tr><td><code id="predict.arx_+3A_ci.levels">ci.levels</code></td>
<td>
<p><code>NULL</code> (default) or a <code>vector</code> with the confidence levels (expressed as values strictly between 0 and 1) of the forecast distribution. The upper and lower values of the confidence interval(s) are returned as quantiles</p>
</td></tr>
<tr><td><code id="predict.arx_+3A_quantile.type">quantile.type</code></td>
<td>
<p>an integer between 1 and 9 that selects which algorithm to be used in computing the quantiles, see the argument <code>type</code> in <code><a href="stats.html#topic+quantile">quantile</a></code> </p>
</td></tr>
<tr><td><code id="predict.arx_+3A_return">return</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), then the out-of-sample predictions are returned. The value <code>FALSE</code>, which does not return the predictions, may be of interest if only a prediction plot is of interest</p>
</td></tr>
<tr><td><code id="predict.arx_+3A_verbose">verbose</code></td>
<td>
<p>logical with default <code>FALSE</code>. If <code>TRUE</code>, then additional information (typically the quantiles and/or the simulated series) used in the generation of forecasts is returned. If <code>FALSE</code>, then only the forecasts are returned</p>
</td></tr>
<tr><td><code id="predict.arx_+3A_plot">plot</code></td>
<td>
<p><code>NULL</code> (default) or logical. If <code>NULL</code>, then the value set by <code>options$plot</code> (see <code><a href="base.html#topic+options">options</a></code>) determines whether a plot is produced or not. If <code>TRUE</code>, then the out-of-sample forecasts are plotted.</p>
</td></tr>
<tr><td><code id="predict.arx_+3A_plot.options">plot.options</code></td>
<td>
<p>a <code>list</code> of options related to the plotting of forecasts, see 'Details'</p>
</td></tr>
<tr><td><code id="predict.arx_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot.options</code> argument is a <code>list</code> that, optionally, can contain any of the following arguments:<br />
</p>

<ul>
<li> <p><code>keep</code>: integer greater than zero (the default is 12) that controls the number of in-sample actual values to plot<br />
</p>
</li>
<li> <p><code>line.at.origin</code>: logical. If <code>TRUE</code>, then a vertical line is drawn at the forecast origin, that is, at the last in-sample observation<br />
</p>
</li>
<li> <p><code>start.at.origin</code>: logical. If <code>TRUE</code>, then the drawing of the forecast line starts at the actual value of the forecast origin<br />
</p>
</li>
<li> <p><code>dot.at.origin</code>: logical. If <code>TRUE</code>, then a dot is drawn at the forecast origin<br />
</p>
</li>
<li> <p><code>hlines</code>: numeric vector that indicates where to draw grey horisontal grid lines<br />
</p>
</li>
<li> <p><code>col</code>: numeric vector of length two that controls the colour of the plotted lines. The first value controls the colour of the forecasts and the fitted values, whereas the second controls the colour of the actual values<br />
</p>
</li>
<li> <p><code>lty</code>: numeric vector of length two that controls the line type. The first value controls the line type of the forecast, whereas the second controls the line type of the actual and fitted values<br />
</p>
</li>
<li> <p><code>lwd</code>: an integer that controls the width of the plotted lines (the default is 1)<br />
</p>
</li>
<li> <p><code>ylim</code>: numeric vector of length two that contains the limits of the y-axis of the prediction plot<br />
</p>
</li>
<li> <p><code>ylab</code>: a character that controls the text on the y-axis<br />
</p>
</li>
<li> <p><code>main</code>: a character that controls the text in the overall title<br />
</p>
</li>
<li> <p><code>legend.text</code>: a character vector of length two that controls how the forecast and actual lines should be named or referred to in the legend of the plot<br />
</p>
</li>
<li> <p><code>fitted</code>: If <code>TRUE</code>, then the fitted values as well as actual values are plotted in-sample<br />
</p>
</li>
<li> <p><code>newmactual</code>: numeric vector or <code>NULL</code> (default). Enables the plotting of actual values out-of-sample in the mean in addition to the forecasts<br />
</p>
</li>
<li> <p><code>newvactual</code>: numeric vector or <code>NULL</code> (default). Enables the plotting of squared residuals ('actual values') out-of-sample in addition to the forecasts<br />
</p>
</li>
<li> <p><code>shades</code>: numeric vector of length <code>length(ci.levels)</code> that contains the shades of grey associated with the confidence intervals in the prediction plot. The shades can range from 100 (white) to 0 (black)<br />
</p>
</li></ul>



<h3>Value</h3>

<p>a <code>vector</code> of class <code><a href="zoo.html#topic+zoo">zoo</a></code> containing the out-of-sample forecasts, or a <code>matrix</code> of class <code><a href="zoo.html#topic+zoo">zoo</a></code> containing the out-of-sample forecasts together with prediction-quantiles, or <code>NULL</code> if <code>return=FALSE</code>
</p>


<h3>Author(s)</h3>

<p>Felix Pretis, <a href="http://www.felixpretis.org/">http://www.felixpretis.org/</a><br />
James Reade, <a href="https://sites.google.com/site/jjamesreade/">https://sites.google.com/site/jjamesreade/</a><br />
Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arx">arx</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##simulate from an AR(1):
set.seed(123)
y &lt;- arima.sim(list(ar=0.4), 40)

##estimate AR(2) model with intercept:
mymod &lt;- arx(y, mc=TRUE, ar=c(1,2))

##generate out-of-sample forecasts:
predict(mymod)

##same, but plot the predictions in addition:
#predict(mymod, plot=TRUE)

##same, but return also the quantiles of the confidence intervals:
#predict(mymod, ci.levels=c(0.50,0.90), plot=TRUE)

##same, but with non-default levels on the confidence intervals:
#predict(mymod, ci.levels=c(0.20,0.80, 0.99), plot=TRUE)

##same, but with more confidence intervals:
#predict(mymod, ci.levels=seq(0.20, 0.95, by=0.05), plot=TRUE)

##same, but with less rugged ci's (achieved by increasing n.sim):
##predict(mymod, ci.levels=seq(0.20, 0.95, by=0.05), n.sim=50000, plot=TRUE)

##same, but using standard normals (instead of bootstrap) in the simulations:
#n.sim &lt;- 2000
#n.ahead &lt;- 12 #the default on n.ahead
#predict(mymod, ci.levels=seq(0.20, 0.95, by=0.05), n.sim=n.sim,
#  innov=rnorm(n.ahead*n.sim), plot=TRUE)

##make x-regressors:
x &lt;- matrix(rnorm(40*3), 40, 3)

##estimate AR(1) model with intercept and covariates:
mymod &lt;- arx(y, mc=TRUE, ar=1, mxreg=x)

##predict up to 5 steps ahead, setting x's to 0 out-of-sample:
predict(mymod, n.ahead=5, newmxreg=matrix(0,5,NCOL(x)))

##same, but do also plot:
#predict(mymod, n.ahead=5, newmxreg=matrix(0,5,NCOL(x)),
#  plot=TRUE)

##estimate an AR(2) model w/intercept and a log-ARCH(1) specification
##on the variance:
#mymodel &lt;- arx(y, mc=TRUE, ar=1:2, arch=1)

##generate forecasts of the conditional variances:
#predict(mymodel, spec="variance")

##same, but do also plot:
#predict(mymodel, spec="variance", plot=TRUE)

##illustrations of the usage of plot.options:
#mymodel &lt;- arx(y, mc=TRUE, ar=1)
#predict(mymodel, plot=TRUE, plot.options=list(keep=1))
#predict(mymodel, plot=TRUE, plot.options=list(line.at.origin=TRUE))
#predict(mymodel, plot=TRUE, plot.options=list(start.at.origin=FALSE))
#predict(mymodel, plot=TRUE, 
#  plot.options=list(start.at.origin=FALSE, fitted=TRUE))
#predict(mymodel, plot=TRUE, plot.options=list(dot.at.origin=FALSE))
#predict(mymodel, plot=TRUE, plot.options=list(hlines=c(-2,-1,0,1,2)))
#predict(mymodel, plot=TRUE, plot.options=list(col=c("darkred","green")))
#predict(mymodel, plot=TRUE, plot.options=list(lty=c(3,2)))
#predict(mymodel, plot=TRUE, plot.options=list(lwd=3))
#predict(mymodel, plot=TRUE, plot.options=list(ylim=c(-8,8)))
#predict(mymodel, plot=TRUE, plot.options=list(ylab="User-specified y-axis"))
#predict(mymodel, plot=TRUE, 
#  plot.options=list(main="User-specified overall title"))
#predict(mymodel, plot=TRUE, 
#  plot.options=list(legend.text=c("User-specified 1","User-specified 2")))
#predict(mymodel, plot=TRUE, plot.options=list(fitted=TRUE))
#predict(mymodel, plot=TRUE, plot.options=list(newmactual=rep(0,6)))
#predict(mymodel, plot=TRUE, plot.options=list(shades.of.grey=c(95,50)))
#predict(mymodel, plot=TRUE, plot.options=list(shades.of.grey=c(50,95))) #invert shades

</code></pre>

<hr>
<h2 id='printtex'>Generate LaTeX code of an estimation result</h2><span id='topic+printtex'></span><span id='topic+toLatex.arx'></span><span id='topic+toLatex.gets'></span>

<h3>Description</h3>

<p>Convenience functions that generates LaTeX-code of an estimation result in equation-form. <code>printtex</code> can, in principle, be applied to any object for which <code>coef</code>, <code>vcov</code> and <code>logLik</code> methods exist. Note: The generated LaTeX-code contains an <code>eqnarray</code> environment, which requires that the <code>amsmath</code> package is loaded in the preamble of the LaTeX document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  printtex(x, fitted.name=NULL, xreg.names=NULL, digits=4,
      intercept=TRUE, gof=TRUE, diagnostics=TRUE, nonumber=FALSE,
      nobs="T", index="t", dec=NULL, print.info=TRUE)
  ## S3 method for class 'arx'
toLatex(object, ...)
  ## S3 method for class 'gets'
toLatex(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printtex_+3A_x">x</code></td>
<td>
<p>an estimation result, e.g. <code><a href="#topic+arx">arx</a></code>, <code>gets</code> or <code>isat</code> object </p>
</td></tr>
<tr><td><code id="printtex_+3A_object">object</code></td>
<td>
<p>an estimation result of class <code><a href="#topic+arx">arx</a></code> or <code>gets</code> </p>
</td></tr>
<tr><td><code id="printtex_+3A_fitted.name">fitted.name</code></td>
<td>
<p><code>NULL</code> or a user-specified name of left-hand side variable</p>
</td></tr>
<tr><td><code id="printtex_+3A_xreg.names">xreg.names</code></td>
<td>
<p><code>NULL</code> or a user-specified character vector with the names of regressors</p>
</td></tr>
<tr><td><code id="printtex_+3A_digits">digits</code></td>
<td>
<p>integer, the number of digits to be printed</p>
</td></tr>
<tr><td><code id="printtex_+3A_intercept">intercept</code></td>
<td>
<p>logical or numeric. The argument determines whether one of the regressors is an intercept or not, or its location. If <code>TRUE</code>, then the intercept is assumed to be located at <code>coef(x)[1]</code>, and hence the regressor-name of location 1 is excluded from the print. If <code>FALSE</code>, then it is assumed that there is no intercept among the regressors. If numeric, then it is assumed that the regressors contain an intercept at the location equal to the numeric value</p>
</td></tr>
<tr><td><code id="printtex_+3A_gof">gof</code></td>
<td>
<p>logical, whether to include goodness-of-fit in the print</p>
</td></tr>
<tr><td><code id="printtex_+3A_diagnostics">diagnostics</code></td>
<td>
<p>logical, whether to include diagnostics in the print</p>
</td></tr>
<tr><td><code id="printtex_+3A_nonumber">nonumber</code></td>
<td>
<p>logical, whether to remove or not (default) the equation-numbering</p>
</td></tr>
<tr><td><code id="printtex_+3A_nobs">nobs</code></td>
<td>
<p>character, the notation to use to denote the number of observations</p>
</td></tr>
<tr><td><code id="printtex_+3A_index">index</code></td>
<td>
<p><code>NULL</code> or a <code><a href="base.html#topic+character">character</a></code>, only relevant if <code>fitted.name</code> is not <code>NULL</code>, and if the object in question is of class <code><a href="#topic+arx">arx</a></code>, <code><a href="#topic+gets">gets</a></code> or <code><a href="#topic+isat">isat</a></code> </p>
</td></tr>
<tr><td><code id="printtex_+3A_dec">dec</code></td>
<td>
<p><code>NULL</code> or a <code><a href="base.html#topic+character">character</a></code> (for example <code>","</code>). In the latter case, an attempt is made to replace the dot separator <code>.</code> with the character in <code>dec</code> </p>
</td></tr>
<tr><td><code id="printtex_+3A_print.info">print.info</code></td>
<td>
<p><code>logical</code>, whether to print the info at the start or not</p>
</td></tr>
<tr><td><code id="printtex_+3A_...">...</code></td>
<td>
<p>arguments passed on to <code>printtex</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>toLatex.arx</code> and <code>toLatex.gets</code> are simply wrappers to <code>printtex</code> </p>


<h3>Value</h3>

<p>LaTeX code of an estimation result</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arx">arx</a></code>, <code><a href="#topic+logitx">logitx</a></code>, <code><a href="#topic+getsm">getsm</a></code>, <code><a href="#topic+getsv">getsv</a></code>, <code><a href="#topic+isat">isat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##simulate random variates, estimate model:
y &lt;- rnorm(30)
mX &lt;- matrix(rnorm(30*2), 30, 2)
mymod &lt;- arx(y, ar=1:3, mxreg=mX)

##print latex code of estimation result:
printtex(mymod)

##add intercept, at the end, to regressor matrix:
mX &lt;- cbind(mX,1)
colnames(mX) &lt;- c("xreg1", "xreg2", "intercept")
mymod &lt;- arx(y, mc=FALSE, mxreg=mX)

##set intercept location to 3:
printtex(mymod, intercept=3)

</code></pre>

<hr>
<h2 id='recursive'>Recursive estimation</h2><span id='topic+recursive'></span>

<h3>Description</h3>

<p>Recursive estimation of coefficients and standard errors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recursive(object, spec="mean", std.errors=TRUE, from=40, tol=1e-07,
  LAPACK=FALSE, plot=TRUE, return=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recursive_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+arx">arx</a></code>, <code>gets</code> or <code>isat</code> object</p>
</td></tr>
<tr><td><code id="recursive_+3A_spec">spec</code></td>
<td>
<p>'mean' or 'variance'. If 'mean' (default), the the recursive estimates of the mean-equation are estimated</p>
</td></tr>
<tr><td><code id="recursive_+3A_std.errors">std.errors</code></td>
<td>
<p>logical. If TRUE (default), then the coefficient standard errors are also computed</p>
</td></tr>
<tr><td><code id="recursive_+3A_from">from</code></td>
<td>
<p>integer. The starting point of the recursion</p>
</td></tr>
<tr><td><code id="recursive_+3A_tol">tol</code></td>
<td>
<p>numeric. The tolerance for linear dependency among regressors</p>
</td></tr>
<tr><td><code id="recursive_+3A_lapack">LAPACK</code></td>
<td>
<p>logical, TRUE or FALSE (default). If true use LAPACK otherwise use LINPACK, see <code><a href="base.html#topic+qr">qr</a></code> function</p>
</td></tr>
<tr><td><code id="recursive_+3A_plot">plot</code></td>
<td>
<p>NULL or logical. If TRUE, then the recursive coefficient estimates are plotted. If NULL (default), then the value set by <code><a href="base.html#topic+options">options</a></code> determines whether a plot is produced or not.</p>
</td></tr>
<tr><td><code id="recursive_+3A_return">return</code></td>
<td>
<p>logical. If TRUE (default), then the recursive estimates are returned in a list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>return=TRUE</code>, then a <code><a href="base.html#topic+list">list</a></code> is returned with the following components:
</p>
<table>
<tr><td><code>estimates</code></td>
<td>
<p>a <code><a href="zoo.html#topic+zoo">zoo</a></code> matrix with the recursive estimates</p>
</td></tr>
<tr><td><code>standard.errors</code></td>
<td>
<p>a <code><a href="zoo.html#topic+zoo">zoo</a></code> matrix with the standard errors</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ols">ols</a></code>, <code><a href="base.html#topic+qr">qr</a></code>, <code><a href="base.html#topic+solve.qr">solve.qr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##generate random variates, estimate model:
y &lt;- rnorm(100)
mX &lt;- matrix(rnorm(4*100), 100, 4)
mymodel &lt;- arx(y, mc=TRUE, mxreg=mX)

##compute recursive estimates and plot them:
recursive(mymodel)
</code></pre>

<hr>
<h2 id='regressorsMean'>Create the regressors of the mean equation</h2><span id='topic+regressorsMean'></span>

<h3>Description</h3>

<p>The function generates the regressors of the mean equation in an <code><a href="#topic+arx">arx</a></code> model. The returned value is a <code>matrix</code> with the regressors and, by default, the regressand in column one. By default, observations (rows) with missing values are removed in the beginning and the end with <code><a href="zoo.html#topic+na.trim">na.trim</a></code>, and the returned matrix is a <code><a href="zoo.html#topic+zoo">zoo</a></code> object. </p>


<h3>Usage</h3>

<pre><code class='language-R'>regressorsMean(y, mc = FALSE, ar = NULL, ewma = NULL, mxreg = NULL,
  prefix="m", return.regressand = TRUE, return.as.zoo = TRUE, na.trim = TRUE,
  na.omit=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regressorsMean_+3A_y">y</code></td>
<td>
<p>numeric vector, time-series or <code><a href="zoo.html#topic+zoo">zoo</a></code> object. </p>
</td></tr>
<tr><td><code id="regressorsMean_+3A_mc">mc</code></td>
<td>
<p>logical. <code>TRUE</code> includes an intercept, whereas <code>FALSE</code> (default) does not. </p>
</td></tr>
<tr><td><code id="regressorsMean_+3A_ar">ar</code></td>
<td>
<p>either <code>NULL</code> (default) or an integer vector, say, <code>c(2,4)</code> or <code>1:4</code> with the AR-lags to include in the mean specification. If <code>NULL</code>, then no lags are included. </p>
</td></tr>
<tr><td><code id="regressorsMean_+3A_ewma">ewma</code></td>
<td>
<p>either <code>NULL</code> (default) or a <code><a href="base.html#topic+list">list</a></code> with arguments sent to the <code><a href="#topic+eqwma">eqwma</a></code> function. In the latter case a lagged moving average of <code>y</code> is included as a regressor. </p>
</td></tr>
<tr><td><code id="regressorsMean_+3A_mxreg">mxreg</code></td>
<td>
<p>either <code>NULL</code> (default), numeric vector or matrix, say, a <code><a href="zoo.html#topic+zoo">zoo</a></code> object, or <code><a href="base.html#topic+data.frame">data.frame</a></code> containing conditioning variables (covariates). Note that, if both <code>y</code> and <code>mxreg</code> are <code>zoo</code> objects, then their samples are matched. </p>
</td></tr>
<tr><td><code id="regressorsMean_+3A_prefix">prefix</code></td>
<td>
<p>character, possibly of length zero, e.g. <code>""</code> or <code>character(0)</code>. The prefix added to the constant and covariate labels. The default is <code>"m"</code>, so that the default labels are <code>"mconst"</code> and <code>"mxreg"</code>. </p>
</td></tr>
<tr><td><code id="regressorsMean_+3A_return.regressand">return.regressand</code></td>
<td>
<p>logical. <code>TRUE</code>, the default, includes the regressand as column one in the returned matrix. </p>
</td></tr>
<tr><td><code id="regressorsMean_+3A_return.as.zoo">return.as.zoo</code></td>
<td>
<p><code>TRUE</code>, the default, returns the matrix as a <code><a href="zoo.html#topic+zoo">zoo</a></code> object. </p>
</td></tr>
<tr><td><code id="regressorsMean_+3A_na.trim">na.trim</code></td>
<td>
<p><code>TRUE</code>, the default, removes observations with <code>NA</code>-values in the beginning and the end with <code><a href="zoo.html#topic+na.trim">na.trim</a></code>. </p>
</td></tr>
<tr><td><code id="regressorsMean_+3A_na.omit">na.omit</code></td>
<td>
<p><code>TRUE</code>, the non-default, removes observations with <code>NA</code>-values, not necessarily in the beginning or in the end, with <code><a href="stats.html#topic+na.omit">na.omit</a></code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix, by default of class <code><a href="zoo.html#topic+zoo">zoo</a></code>, with the regressand as column one (the default). </p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>References</h3>

<p>Pretis, Felix, Reade, James and Sucarrat, Genaro (2018): 'Automated General-to-Specific (GETS) Regression Modeling and Indicator Saturation for Outliers and Structural Breaks'. Journal of Statistical Software 86, Number 3, pp. 1-44. DOI: https://www.jstatsoft.org/article/view/v086i03
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arx">arx</a></code>, <code><a href="#topic+isat">isat</a></code>, <code><a href="#topic+regressorsVariance">regressorsVariance</a></code>, <code><a href="zoo.html#topic+zoo">zoo</a></code>, <code><a href="#topic+eqwma">eqwma</a></code>, <code><a href="zoo.html#topic+na.trim">na.trim</a></code> and <code><a href="zoo.html#topic+na.trim">na.trim</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>
##generate some data:
y &lt;- rnorm(10) #regressand
x &lt;- matrix(rnorm(10*5), 10, 5) #regressors

##create regressors (examples):
regressorsMean(y, mxreg=x)
regressorsMean(y, mxreg=x, return.regressand=FALSE)
regressorsMean(y, mc=TRUE, ar=1:3, mxreg=x)
regressorsMean(log(y^2), mc=TRUE, ar=c(2,4))

##let y and x be time-series:
y &lt;- ts(y, frequency=4, end=c(2018,4))
x &lt;- ts(x, frequency=4, end=c(2018,4))
regressorsMean(y, mxreg=x)
regressorsMean(y, mc=TRUE, ar=1:3, mxreg=x)
regressorsMean(log(y^2), mc=TRUE, ar=c(2,4))

##missing values (NA):
y[1] &lt;- NA
x[10,3] &lt;- NA
regressorsMean(y, mxreg=x)
regressorsMean(y, mxreg=x, na.trim=FALSE)

</code></pre>

<hr>
<h2 id='regressorsVariance'>Create the regressors of the variance equation</h2><span id='topic+regressorsVariance'></span>

<h3>Description</h3>

<p>The function generates the regressors of the log-variance equation in an <code><a href="#topic+arx">arx</a></code> model. The returned value is a <code>matrix</code> with the regressors and, by default, the regressand in column one. By default, observations (rows) with missing values are removed in the beginning and the end with <code><a href="zoo.html#topic+na.trim">na.trim</a></code>, and the returned matrix is a <code><a href="zoo.html#topic+zoo">zoo</a></code> object. </p>


<h3>Usage</h3>

<pre><code class='language-R'>regressorsVariance(e, vc = TRUE, arch = NULL, asym = NULL,
  log.ewma = NULL, vxreg = NULL, zero.adj = 0.1, vc.adj = TRUE,
  return.regressand = TRUE, return.as.zoo = TRUE, na.trim = TRUE,
  na.omit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regressorsVariance_+3A_e">e</code></td>
<td>
<p>numeric vector, time-series or <code><a href="zoo.html#topic+zoo">zoo</a></code> object.</p>
</td></tr>
<tr><td><code id="regressorsVariance_+3A_vc">vc</code></td>
<td>
<p>logical. <code>TRUE</code> includes an intercept in the log-variance specification, whereas <code>FALSE</code> (default) does not. If the log-variance specification contains any other item but the log-variance intercept, then vc is set to <code>TRUE</code> </p>
</td></tr>
<tr><td><code id="regressorsVariance_+3A_arch">arch</code></td>
<td>
<p>either <code>NULL</code> (default) or an integer vector, say, <code>c(1,3)</code> or <code>2:5</code>. The log-ARCH lags to include in the log-variance specification</p>
</td></tr>
<tr><td><code id="regressorsVariance_+3A_asym">asym</code></td>
<td>
<p>either <code>NULL</code> (default) or an integer vector, say, <code>c(1)</code> or <code>1:3</code>. The asymmetry (i.e. 'leverage') terms to include in the log-variance specification</p>
</td></tr>
<tr><td><code id="regressorsVariance_+3A_log.ewma">log.ewma</code></td>
<td>
<p>either <code>NULL</code> (default) or a vector of the lengths of the volatility proxies, see <code><a href="#topic+leqwma">leqwma</a></code> </p>
</td></tr>
<tr><td><code id="regressorsVariance_+3A_vxreg">vxreg</code></td>
<td>
<p>either <code>NULL</code> (default) or a numeric vector or matrix, say, a <code><a href="zoo.html#topic+zoo">zoo</a></code> object, of conditioning variables. If both <code>y</code> and <code>mxreg</code> are <code>zoo</code> objects, then their samples are chosen to match</p>
</td></tr>
<tr><td><code id="regressorsVariance_+3A_zero.adj">zero.adj</code></td>
<td>
<p>numeric value between 0 and 1. The quantile adjustment for zero values. The default 0.1 means the zero residuals are replaced by the 10 percent quantile of the absolute residuals before taking the logarithm</p>
</td></tr>
<tr><td><code id="regressorsVariance_+3A_vc.adj">vc.adj</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), then the log-variance intercept is adjusted by the estimate of E[ln(z^2)], where z is the standardised error. This adjustment is needed for the conditional scale to be equal to the conditional standard deviation. If <code>FALSE</code>, then the log-variance intercept is not adjusted</p>
</td></tr>
<tr><td><code id="regressorsVariance_+3A_return.regressand">return.regressand</code></td>
<td>
<p>logical. <code>TRUE</code>, the default, includes the regressand as column one in the returned matrix. </p>
</td></tr>
<tr><td><code id="regressorsVariance_+3A_return.as.zoo">return.as.zoo</code></td>
<td>
<p><code>TRUE</code>, the default, returns the matrix as a <code><a href="zoo.html#topic+zoo">zoo</a></code> object. </p>
</td></tr>
<tr><td><code id="regressorsVariance_+3A_na.trim">na.trim</code></td>
<td>
<p><code>TRUE</code>, the default, removes observations with <code>NA</code>-values in the beginning and the end with <code><a href="zoo.html#topic+na.trim">na.trim</a></code>. </p>
</td></tr>
<tr><td><code id="regressorsVariance_+3A_na.omit">na.omit</code></td>
<td>
<p><code>TRUE</code>, the non-default, removes observations with <code>NA</code>-values, not necessarily in the beginning or in the end, with <code><a href="stats.html#topic+na.omit">na.omit</a></code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix, by default of class <code><a href="zoo.html#topic+zoo">zoo</a></code>, with the regressand as column one (the default). </p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>References</h3>

<p>Pretis, Felix, Reade, James and Sucarrat, Genaro (2018): 'Automated General-to-Specific (GETS) Regression Modeling and Indicator Saturation for Outliers and Structural Breaks'. Journal of Statistical Software 86, Number 3, pp. 1-44. DOI: https://www.jstatsoft.org/article/view/v086i03
</p>
<p>Sucarrat, Genaro and Escribano, Alvaro (2012): 'Automated Financial Model Selection: General-to-Specific Modelling of the Mean and Volatility Specifications', Oxford Bulletin of Economics and Statistics 74, Issue 5 (October), pp. 716-735
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regressorsMean">regressorsMean</a></code>, <code><a href="#topic+arx">arx</a></code>, <code><a href="zoo.html#topic+zoo">zoo</a></code>, <code><a href="#topic+leqwma">leqwma</a></code>, <code><a href="zoo.html#topic+na.trim">na.trim</a></code> and <code><a href="stats.html#topic+na.omit">na.omit</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>
##generate some data:
eps &lt;- rnorm(10) #error term
x &lt;- matrix(rnorm(10*5), 10, 5) #regressors

##create regressors (examples):
regressorsVariance(eps, vxreg=x)
regressorsVariance(eps, vxreg=x, return.regressand=FALSE)
regressorsVariance(eps, arch=1:3, vxreg=x)
regressorsVariance(eps, arch=1:2, asym=1, vxreg=x)
regressorsVariance(eps, arch=1:2, asym=1, log.ewma=5)

##let eps and x be time-series:
eps &lt;- ts(eps, frequency=4, end=c(2018,4))
x &lt;- ts(x, frequency=4, end=c(2018,4))
regressorsVariance(eps, vxreg=x)
regressorsVariance(eps, arch=1:3, vxreg=x)
regressorsVariance(eps, arch=1:2, asym=1, vxreg=x)
regressorsVariance(eps, arch=1:2, asym=1, log.ewma=5)

</code></pre>

<hr>
<h2 id='so2data'>
UK SO2 Data
</h2><span id='topic+so2data'></span>

<h3>Description</h3>

<p>UK Annual Total Anthropogenic Sulphur Dioxide (SO2) Emissions 1946-2005.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("so2data")</code></pre>


<h3>Format</h3>

<p>A data frame with 60 observations on the following 4 variables.
</p>

<dl>
<dt><code>year</code></dt><dd><p>Year of observation</p>
</dd>
<dt><code>uk_tot_so2</code></dt><dd><p>UK annual total anthropogenic SO2 emissions in gigagrams</p>
</dd>
<dt><code>Luk_tot_so2</code></dt><dd><p>Log of UK annual total anthropogenic SO2 emissions</p>
</dd>
<dt><code>DLuk_tot_so2</code></dt><dd><p>First difference of Log UK annual total anthropogenic SO2 emissions</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data reports the total estimated anthropogenic SO2 emissions aggregated over coal, petroleum, biomass combustion, smelting, fuel processing, and other processes.
</p>


<h3>Source</h3>

<p>Smith, SJ, J van Aardenne, Z Klimont, RJ Andres, A Volke, and S Delgado Arias. (2011). Anthropogenic Sulfur Dioxide Emissions, 1850-2005: National and Regional Data Set by Source Category, Version 2.86. Data distributed by the NASA Socioeconomic Data and Applications Center (SEDAC), CIESIN, Columbia University, Palisades, New York. Available at
</p>
<p>http://sedac.ciesin.columbia.edu/data/set/haso2-anthro-sulfur-dioxide-emissions-1850-2005-v2-86
</p>


<h3>References</h3>

<p>Pretis, Felix, Reade, James and Sucarrat, Genaro (2018): 'Automated General-to-Specific (GETS) Regression Modeling and Indicator Saturation for Outliers and Structural Breaks'. Journal of Statistical Software 86, Number 3, pp. 1-44
</p>
<p>Smith, SJ, J van Aardenne, Z Klimont, RJ Andres, A Volke, and S Delgado Arias. (2011). Anthropogenic Sulfur Dioxide Emissions: 1850-2005, Atmospheric Chemistry and Physics, 11:1101-1116.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(so2data)

##create annual zoo object:
newso2data&lt;- zooreg(so2data[,-1], start=1946, frequency=1)

##plot UK annual total anthropogenic SO2 emissions:
plot(newso2data$uk_tot_so2)

</code></pre>

<hr>
<h2 id='sp500data'>
Daily Standard and Poor's 500 index data
</h2><span id='topic+sp500data'></span>

<h3>Description</h3>

<p>Daily Standard and Poor's 500 (SP500) index data from 3 January 1950 to 8 March 2016.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("sp500data")</code></pre>


<h3>Format</h3>

<p>A data frame with 16652 observations on the following 7 variables:
</p>

<dl>
<dt><code>Date</code></dt><dd><p>the dates</p>
</dd>
<dt><code>Open</code></dt><dd><p>the opening values of the index</p>
</dd>
<dt><code>High</code></dt><dd><p>the daily maximum value of the index</p>
</dd>
<dt><code>Low</code></dt><dd><p>the daily minimum value of the index</p>
</dd>
<dt><code>Close</code></dt><dd><p>the closing values of the index</p>
</dd>
<dt><code>Volume</code></dt><dd><p>the traded volume</p>
</dd>
<dt><code>Adj.Close</code></dt><dd><p>the adjusted closing values of the index</p>
</dd>
</dl>



<h3>Source</h3>

<p>Yahoo Finance, retrieved 9 March 2016
</p>


<h3>References</h3>

<p>Pretis, Felix, Reade, James and Sucarrat, Genaro (2018): 'Automated General-to-Specific (GETS) Regression Modeling and Indicator Saturation for Outliers and Structural Breaks'. Journal of Statistical Software 86, Number 3, pp. 1-44
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sp500data)
sp500data &lt;- zoo(sp500data[, -1], order.by = as.Date(sp500data[, "Date"]))
plot(window(sp500data, start = as.Date("2000-01-03")))
</code></pre>

<hr>
<h2 id='vargaugeiis'>Variance of the Impulse Indicator Saturation Gauge</h2><span id='topic+vargaugeiis'></span>

<h3>Description</h3>

<p>Computes the variance of the gauge (false-positive rate of outliers under the null of no outliers) in impulse indicator saturation based on Jiao and Pretis (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  vargaugeiis(t.pval, T, infty=FALSE, m=1)
  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vargaugeiis_+3A_t.pval">t.pval</code></td>
<td>
<p>numeric, between 0 and 1. Selection p-value used in indicator saturation.</p>
</td></tr>
<tr><td><code id="vargaugeiis_+3A_t">T</code></td>
<td>
<p>integer, sample sized used in indicator saturation.</p>
</td></tr>
<tr><td><code id="vargaugeiis_+3A_m">m</code></td>
<td>
<p>integer, number of iterations in variance computation, default=1</p>
</td></tr>
<tr><td><code id="vargaugeiis_+3A_infty">infty</code></td>
<td>
<p>logical, argument used for variance computation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the variance of the Gauge (false-positive rate of outliers in impulse indicator saturation) for a given level of significance of selection (<code>t.pval</code>) and sample size (<code>T</code>) based on Jiao and Pretis (2019). This is an auxilliary function used within the <code><a href="#topic+outliertest">outliertest</a></code> function.</p>


<h3>Value</h3>

<p>Returns a dataframe of the variance and standard deviation of the gauge, as well the asymptotic variance and standard deviation.</p>


<h3>Author(s)</h3>

<p>Felix Pretis, <a href="http://www.felixpretis.org/">http://www.felixpretis.org/</a>
</p>


<h3>References</h3>

<p>Jiao, X. &amp; Pretis, F. (2019). Testing the Presence of Outliers in Regression Models. Discussion Paper.
</p>
<p>Pretis, F., Reade, J., &amp; Sucarrat, G. (2018). Automated General-to-Specific (GETS) regression modeling and indicator saturation methods for the detection of outliers and structural breaks. Journal of Statistical Software, 86(3).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isat">isat</a></code>, <code><a href="#topic+outliertest">outliertest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ###Computing the variance of the gauge under the null for a sample of T=200 observations:
  vargaugeiis(t.pval=0.05, T=200, infty=FALSE, m=1)
  
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
