<!DOCTYPE html><html lang="en"><head><title>Help for package TexExamRandomizer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TexExamRandomizer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#TexExamRandomizer-package'><p>Generating Random Exams from 'LaTeX' documents</p></a></li>
<li><a href='#catDocument'><p>Output with listed documents</p></a></li>
<li><a href='#compilation_options'><p>Define compilations options</p></a></li>
<li><a href='#compile_latex_directory'><p>Compile LatexDirectory</p></a></li>
<li><a href='#CompileDocument'><p>Compile Document</p></a></li>
<li><a href='#CompileLatexDir'><p>Compiling function</p></a></li>
<li><a href='#ConstructAnswerSheet'><p>ConstructAnswerSheet</p></a></li>
<li><a href='#CountNumberOfSections'><p>CountNumberOfSections</p></a></li>
<li><a href='#CreateRandomExams'><p>CreateRandomExams</p></a></li>
<li><a href='#DivideFile'><p>DivideFile</p></a></li>
<li><a href='#FindExamAnswers'><p>FindExamAnswers</p></a></li>
<li><a href='#FindMatchingRow'><p>FindMatchingRow</p></a></li>
<li><a href='#FindStructure'><p>Structuring functions</p></a></li>
<li><a href='#fun_from_folder'><p>Apply function within a folder</p></a></li>
<li><a href='#GenerateHomework'><p>Generate Homework</p></a></li>
<li><a href='#GenerateShortAnswerSheet'><p>Generating a short answer sheet</p></a></li>
<li><a href='#GetLayerSampleIndexes'><p>GetLayerSampleIndexes</p></a></li>
<li><a href='#GradeExams'><p>GradeExams</p></a></li>
<li><a href='#IsWellSectioned'><p>IsWellSectioned</p></a></li>
<li><a href='#jsonexamparser'><p>Json Exam Document Parser</p></a></li>
<li><a href='#jsonhwparser'><p>Json Homework Parser</p></a></li>
<li><a href='#ObtainExamStats'><p>Obtaining exam statistics</p></a></li>
<li><a href='#ParsePreambleForOptions'><p>ParsePreambleForOptions</p></a></li>
<li><a href='#RandomizeDocument'><p>Randomizing documents.</p></a></li>
<li><a href='#ReplaceFromTable'><p>ReplaceFromTable</p></a></li>
<li><a href='#ReplacePreambleCommand'><p>ReplacePreambleCommand</p></a></li>
<li><a href='#StructureDocument'><p>Structure Document</p></a></li>
<li><a href='#SubsetWithAtributes'><p>Subsetting Document</p></a></li>
<li><a href='#testclass'><p>Sample class table</p></a></li>
<li><a href='#testdoc'><p>Test document</p></a></li>
<li><a href='#WhichAnswerOriginal'><p>WhichAnswerOriginal</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Personalizes and Randomizes Exams Written in 'LaTeX'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.7</td>
</tr>
<tr>
<td>Author:</td>
<td>Alejandro Gonzalez Recuenco</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alejandro Gonzalez Recuenco &lt;alejandrogonzalezrecuenco@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Randomizing exams with 'LaTeX'.
    If you can compile your main document with 'LaTeX', the program should be able to compile the randomized
    versions without much extra effort when creating the document.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/alexrecuenco/TexExamRandomizer">https://github.com/alexrecuenco/TexExamRandomizer</a>,
<a href="https://alexrecuenco.github.io/TexExamRandomizer/">https://alexrecuenco.github.io/TexExamRandomizer/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/alexrecuenco/TexExamRandomizer/issues">https://github.com/alexrecuenco/TexExamRandomizer/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.13), assertthat, stringr, jsonlite, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>optparse, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-23 01:58:58 UTC; alexrecuenco</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-23 08:22:50 UTC</td>
</tr>
</table>
<hr>
<h2 id='TexExamRandomizer-package'>Generating Random Exams from 'LaTeX' documents</h2><span id='topic+TexExamRandomizer'></span><span id='topic+TexExamRandomizer-package'></span>

<h3>Description</h3>

<p>This package is designed with exams and homework created in 'LaTeX' in mind. It allows to randomize and personalize exams and homework and it aids the user with grading them.
</p>


<h3>Details</h3>

<p>If you are using the exam class from 'LaTeX' already, it is likely that this program works as it is.
</p>
<p>If you just want to randomize your exams,
</p>

<ul>
<li><p> Look at <code>vignette("BasicUse", package = "TexExamRandomizer")</code> for an introduction of the concept behind this library and a quick way to start using it.
</p>
</li>
<li><p> Look at <code>vignette("ExamOptions", package = "TexExamRandomizer")</code> for a more detailed explanations of what options can be used on a document.
</p>
</li></ul>

<p>If instead you are trying to use the library to create your own randomizer for a certain use you might have, you should start by looking at <code><a href="#topic+CreateRandomExams">CreateRandomExams</a></code> and <code><a href="#topic+GenerateHomework">GenerateHomework</a></code>.
</p>


<h3>Author(s)</h3>

<p>Alejandro Gonzalez Recuenco
</p>
<p>e-mail: alejandrogonzalezrecuenco@gmail.com
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/alexrecuenco/TexExamRandomizer">https://github.com/alexrecuenco/TexExamRandomizer</a>
</p>
</li>
<li> <p><a href="https://alexrecuenco.github.io/TexExamRandomizer/">https://alexrecuenco.github.io/TexExamRandomizer/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/alexrecuenco/TexExamRandomizer/issues">https://github.com/alexrecuenco/TexExamRandomizer/issues</a>
</p>
</li></ul>


<hr>
<h2 id='catDocument'>Output with listed documents</h2><span id='topic+catDocument'></span>

<h3>Description</h3>

<p>Behaves like <code><a href="base.html#topic+cat">cat</a></code>, but it first automatically unlists the exam to print the document.
</p>
<p>Since the document is kept as a tree of lists, it simply abstract the idea of outputting the document. with one document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catDocument(FullDocument, sep = "\n", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="catDocument_+3A_fulldocument">FullDocument</code></td>
<td>
<p>Document as structure by <code><a href="#topic+StructureDocument">StructureDocument</a></code></p>
</td></tr>
<tr><td><code id="catDocument_+3A_sep">sep</code></td>
<td>
<p>The separation character(s) between each line.</p>
</td></tr>
<tr><td><code id="catDocument_+3A_...">...</code></td>
<td>
<p>all extra arguments get passed along to the command &quot;<code><a href="base.html#topic+cat">cat</a></code>&quot;</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>catDocument(TexExamRandomizer::testdoc)


</code></pre>

<hr>
<h2 id='compilation_options'>Define compilations options</h2><span id='topic+compilation_options'></span>

<h3>Description</h3>

<p>This function provides the compilation options that can be passed to the jsonexamparser
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compilation_options(
  file = NULL,
  table = NULL,
  noutput = NULL,
  nquestions = NULL,
  seed = NULL,
  compile = NULL,
  xelatex = NULL,
  debug = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compilation_options_+3A_file">file</code></td>
<td>
<p>Input file name</p>
</td></tr>
<tr><td><code id="compilation_options_+3A_table">table</code></td>
<td>
<p>Input table with student name and information</p>
</td></tr>
<tr><td><code id="compilation_options_+3A_noutput">noutput</code></td>
<td>
<p>Number of *different* exams/homeworks produced</p>
</td></tr>
<tr><td><code id="compilation_options_+3A_nquestions">nquestions</code></td>
<td>
<p>Number of questions on each exam (Only on exams)</p>
</td></tr>
<tr><td><code id="compilation_options_+3A_seed">seed</code></td>
<td>
<p>Pseudorandom seed to be used (This allows the result to be deterministic)</p>
</td></tr>
<tr><td><code id="compilation_options_+3A_compile">compile</code></td>
<td>
<p>If TRUE, it tries to compile</p>
</td></tr>
<tr><td><code id="compilation_options_+3A_xelatex">xelatex</code></td>
<td>
<p>If TRUE, it uses 'XeLaTeX'</p>
</td></tr>
<tr><td><code id="compilation_options_+3A_debug">debug</code></td>
<td>
<p>If TRUE, it doesn't remove auxiliary files generated by 'LaTeX' when compiling</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of options to be passed to <code><a href="#topic+jsonexamparser">jsonexamparser</a></code>, <code><a href="#topic+jsonhwparser">jsonhwparser</a></code>.
</p>


<h3>See Also</h3>

<p>Other jsoncompiler: 
<code><a href="#topic+ParsePreambleForOptions">ParsePreambleForOptions</a>()</code>,
<code><a href="#topic+jsonexamparser">jsonexamparser</a>()</code>,
<code><a href="#topic+jsonhwparser">jsonhwparser</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

file &lt;-
    system.file(
        "extdata",
        "ExampleTexDocuments",
        "exam_testing_nquestions.tex", #Test exam that doesn't require a table
        package = "TexExamRandomizer")

temporalfile &lt;- paste(tempfile(), ".tex", sep = "")

file.copy(file, temporalfile)
opt &lt;- compilation_options(file = temporalfile)
jsonhwparser(opt)


## End(Not run)
</code></pre>

<hr>
<h2 id='compile_latex_directory'>Compile LatexDirectory</h2><span id='topic+compile_latex_directory'></span>

<h3>Description</h3>

<p>Internal function wrapping the options to compile a directory holding some text files into pdf files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compile_latex_directory(
  options = list(),
  input_directory,
  output_directory = input_directory,
  main_directory
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compile_latex_directory_+3A_options">options</code></td>
<td>
<p>See details</p>
</td></tr>
<tr><td><code id="compile_latex_directory_+3A_input_directory">input_directory</code></td>
<td>
<p>Input directory where the tex files are found</p>
</td></tr>
<tr><td><code id="compile_latex_directory_+3A_output_directory">output_directory</code></td>
<td>
<p>Output directory where  the pdf files will be placed</p>
</td></tr>
<tr><td><code id="compile_latex_directory_+3A_main_directory">main_directory</code></td>
<td>
<p>Directory we will compile from</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'options' is a list containing the possible options. The possible options are
</p>

<ul>
<li><p> compile: Should it compile the tex files
</p>
</li>
<li><p> debug: Should we use debugging information. Otherwise, it will clean up the temporary files created by latex.
</p>
</li>
<li><p> xelatex: Should it use the xelatex engine
</p>
</li></ul>

<p>The options can be defined directly given by using the other parameters to this function. (Note that those paramenters have precedence)
</p>


<h3>Value</h3>

<p>No return value
</p>

<hr>
<h2 id='CompileDocument'>Compile Document</h2><span id='topic+CompileDocument'></span>

<h3>Description</h3>

<p>Function that takes a set of lines, <code>x</code>, that represent a file or a document. And divides it in subsequent layers, structures as a list, as described on the detail section.
</p>
<p>It assumes <code>x</code> is representing a 'LaTeX' file that can be compiled as it is before we make any modifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompileDocument(x, layersNames, layersCmd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CompileDocument_+3A_x">x</code></td>
<td>
<p>A character vector, each element represents one line of the latex document</p>
</td></tr>
<tr><td><code id="CompileDocument_+3A_layersnames">layersNames</code></td>
<td>
<p>A character vector, with each element representating the environment name to be searched as <code>cmdName</code> as describe in <code><a href="#topic+FindBegin">FindBegin</a></code> and <code><a href="#topic+FindEnd">FindEnd</a></code></p>
</td></tr>
<tr><td><code id="CompileDocument_+3A_layerscmd">layersCmd</code></td>
<td>
<p>A character vector, with the same length as <code>layersNames</code>. with each element representing the environment command to be serached as <code>cmdName</code> as described in <code><a href="#topic+FindCommand">FindCommand</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both <code>layersNames</code> and <code>layersCmd</code> must have the same length, since for each index, <code>i</code>, <code>layersNames[i]</code> and <code>layersCmd[i]</code> refer to one layer of the tree structure of the document. Consequent layers must be found inside previous layers.
</p>
<p>If it finds the structure of the document to not be completed, it will throw an error.
</p>


<h3>Value</h3>

<p>It returns a list, with each element having a name. Recreating the tree structure identified by  <code>layersNames</code> and <code>layersCmd</code> in the text file <code>x</code>.
</p>
<p>It first divides the document into two lists:
</p>

<dl>
<dt>preamble</dt><dd><p>Contains a character vector identifying everything before the \begin{document}</p>
</dd>
<dt>document</dt><dd><p>Contains the tree structure identifying the document</p>
</dd>
</dl>

<p>Now, the naming convention for each layer of the document is as follows. We will use the convention <code>&lt;layerName&gt;</code>,  <code>&lt;layerCmd&gt;</code>.
</p>
<p>Note the convention first, everything that it finds prior to the first environment, it throws it into a character vector that it calls <code>prior_to_&lt;layesName&gt;</code>.
After the first environment <code>&lt;layerName&gt;</code> ends, it assumes that everything from that <code>\end{&lt;layerName&gt;}</code> onwards corresponding to the next environment, and it will throw it to the prior part of that one.
<code>post_to_&lt;layerName&gt;</code>
</p>

<dl>
<dt><code>prior_to_layersName</code></dt><dd><p>Includes everything up to the first <code>\begin{&lt;layerName&gt;</code> without including that line</p>
</dd>
<dt><code>1_&lt;layerName&gt;_begin_&lt;layerName&gt;</code></dt><dd>
<p>Includes the <code>\begin{layerName}</code> for the 1st section, and everything until it finds the first <code>\&lt;layerCmd&gt;</code></p>
</dd>
<dt><code>1_&lt;layerName&gt;_1_&lt;layerCmd&gt;</code></dt><dd>
<p>Includes everything from the 1<code class="reqn">^{st}</code> <code>\&lt;layerCmd&gt;</code> until the second <code>\&lt;layerCmd&gt;</code>, without including the line in which the second command is found
</p>
</dd>
<dt><code>1_&lt;layerName&gt;_2_&lt;layerCmd&gt;</code></dt><dd>
<p>Same thing... and it keeps going until the last  <code>\&lt;layerCmd&gt;</code> is found
</p>
</dd>
<dt><code>1_&lt;layerName&gt;_end_&lt;layerName&gt;</code></dt><dd>
<p>It includes the <code>\end{&lt;layerName&gt;}</code> for the 1st section.
</p>
</dd>
<dt>...</dt><dd>
<p>It then repeats the same structure for the next environment, changing the naming convention to start with 2_&lt;...&gt; and so on until it does the last environemt</p>
</dd>
<dt><code>post_to_&lt;layerName&gt;</code></dt><dd>
<p>After the last layer ends with <code>\end{layerName}</code>, it throws the rest of the lines into this last character vector</p>
</dd>
</dl>

<p>This structure is applied recursively to each <code>i_&lt;layerName&gt;_j_&lt;layerCmd&gt;</code> of the previous layer to find the structure for the next layer.
The result is a tree of lists, with names that identify the whole structure, and the ending node of each branch is always a character vector
</p>
<p><strong>IMPORTANT NOTE:</strong> Note that this function only rearranges the lines of the document, it can't split a document between a line. So if you want to make sure something always stays together, put them both in the same line. This is intentional, to force a more clear structure on the document that will be parsed
</p>
<p>In Summary, the sketch of the tree structure would be:
</p>

<ul>
<li><p> preamble
</p>
</li>
<li><p> Document
</p>

<ul>
<li><p> prior_to_LayerName[1]
</p>
</li>
<li><p> 1_layerName[1]_begin_layerName[1]
</p>
</li>
<li><p> 1_layerName[1]_1_layerCmd[1]
</p>

<ul>
<li><p> prior_to_LayerName[2]
</p>
</li>
<li><p> 1_layerName[2]_begin_layerName[2]
</p>
</li>
<li><p> 1_layerName[2]_1_layerCmd[2]
</p>

<ul>
<li><p> Continues...
</p>
</li></ul>

</li>
<li><p> 1_layerName[2]_2_layerCmd[2]
</p>

<ul>
<li><p> Continues...
</p>
</li></ul>

</li>
<li><p> ...
</p>
</li>
<li><p>  post_to_layerName[2]
</p>
</li></ul>

</li>
<li><p> 2_layerName[1]_begin_layerName[1]
</p>
</li>
<li><p> 2_layerName[1]_1_layerCmd[1]
</p>

<ul>
<li><p> ...
</p>
</li></ul>

</li>
<li><p> ...
</p>
</li>
<li><p> n_layerName[1]_end_layerName[1]
</p>
</li>
<li><p>  post_to_layerName[1]
</p>
</li></ul>

</li></ul>

<p>If a  <code>\&lt;layerCmd&gt;</code> is not found inside an environment, everything inside that environment is thrown into the begin_layerName part and instead of the numbered environments, an empty character list is added in the middle, with name <code>empty_&lt;layerCmd&gt;</code> section.
</p>


<h3>See Also</h3>

<p><a href="#topic+FindStructure">FindStructure</a> for more information on the details of how the layers are found.
</p>
<p>Other Structuring Document: 
<code><a href="#topic+DivideFile">DivideFile</a>()</code>,
<code><a href="#topic+FindStructure">FindStructure</a></code>,
<code><a href="#topic+IsWellSectioned">IsWellSectioned</a>()</code>,
<code><a href="#topic+StructureDocument">StructureDocument</a>()</code>
</p>

<hr>
<h2 id='CompileLatexDir'>Compiling function</h2><span id='topic+CompileLatexDir'></span><span id='topic+CompileLatexDirEXAM'></span><span id='topic+CompileLatexDirHW'></span>

<h3>Description</h3>

<p>This function calls latexmk, which must be part of the system commands, a directory where tex files are found and outputs their pdf and other things in the pdf.dir.out
The functions <code><a href="#topic+CompileLatexDirEXAM">CompileLatexDirEXAM</a></code> and <code><a href="#topic+CompileLatexDirHW">CompileLatexDirHW</a></code> are identical wrappers of the same function, <code><a href="#topic+CompileLatexDir">CompileLatexDir</a></code>. Do not use them, they are just kept for &quot;backwards&quot; compatibility
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompileLatexDir(
  pdf.dir.out,
  latex.dir.in,
  engine = "xelatex",
  compile.dir = NULL,
  extracmdoptions = NULL
)

CompileLatexDirEXAM(
  pdf.dir.out,
  latex.dir.in,
  engine = "xelatex",
  compile.dir = NULL,
  extracmdoptions = NULL
)

CompileLatexDirHW(
  pdf.dir.out,
  latex.dir.in,
  engine = "xelatex",
  compile.dir = NULL,
  extracmdoptions = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CompileLatexDir_+3A_pdf.dir.out">pdf.dir.out</code></td>
<td>
<p>Directory where the pdf output will be sent to</p>
</td></tr>
<tr><td><code id="CompileLatexDir_+3A_latex.dir.in">latex.dir.in</code></td>
<td>
<p>Directory where all the tex files are found.</p>
</td></tr>
<tr><td><code id="CompileLatexDir_+3A_engine">engine</code></td>
<td>
<p>Engine to use when compiling. Currently the options are <code>xelatex</code>, <code>lualatex</code>, <code>latex</code> and <code>pdflatex</code>
</p>
<p><code>xelatex</code> is the default value. However, if the value is not recognized, <code>pdflatex</code> is used instead.</p>
</td></tr>
<tr><td><code id="CompileLatexDir_+3A_compile.dir">compile.dir</code></td>
<td>
<p>Directory from which compilation is invoked, if not specified, it defaults to the latex.dir.in.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Write the tex files relative paths to other files as to be read from the directory in which latex.dir.in is found
This function is intended to be use to compile a bunch of files which are stemmed from an original one. That is why the directory
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Alejandro Recuenco <a href="mailto:alejandrogonzalezrecuenco@gmail.com">alejandrogonzalezrecuenco@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
input_folder &lt;- system.file(
    "extdata",
    "ExampleTexDocuments",
    package = "TexExamRandomizer")


TexExamRandomizer::CompileLatexDir(
    pdf.dir.out = tempdir(),
    engine= "pdf",
    latex.dir.in = input_folder,
    extracmdoptions = "-C")
    # The "-C" option makes sure we simulate we use the command, but the command
    # doesnt run compiling the document, it only tries to clean up

</code></pre>

<hr>
<h2 id='ConstructAnswerSheet'>ConstructAnswerSheet</h2><span id='topic+ConstructAnswerSheet'></span>

<h3>Description</h3>

<p>Constructs an answer sheet given a document as generated by <code><a href="#topic+StructureDocument">StructureDocument</a></code> by finding in the items the correct and wrong tags and describing where it found them.
</p>
<p>Note that you must provide the document part only, <code>StructureDocument</code> gives back a <code>$preamble</code> and <code>$document</code>.
</p>
<p>If <code>wrongTag</code> is left <code>NULL</code>, the answer sheet only shows information of the correct answers.
</p>
<p>This answer sheet provides information for what answers are correct or incorrect, as well as their position within the original document, before any shuffling was done. (It uses the names of the document to decide whether the document was shuffled or not, since subsetting a list removes all attributes except for the names, this is the &quot;safest&quot; way to do it)
</p>
<p>The intent of this function is to make it easy to find the answers for a randomized version of an exam.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConstructAnswerSheet(Document, correctTag, wrongTag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ConstructAnswerSheet_+3A_document">Document</code></td>
<td>
<p>Document, as defined in <code><a href="#topic+StructureDocument">StructureDocument</a></code>. Remember however that the function <code><a href="#topic+StructureDocument">StructureDocument</a></code> returns the document and the preamble together in a list.</p>
</td></tr>
<tr><td><code id="ConstructAnswerSheet_+3A_correcttag">correctTag</code></td>
<td>
<p>Tag to identify the correct items.</p>
</td></tr>
<tr><td><code id="ConstructAnswerSheet_+3A_wrongtag">wrongTag</code></td>
<td>
<p>Tag that identifies the wrong items.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tags are just command of the type &quot;<code>\Tag</code>&quot; that must be found somewhere that is not commented out inside the last item at the end of the tree structure. Usually you will want to use the tags that already identify the document items for this.
</p>
<p>(For example, in the exam class, the tags <code>\choice</code> and <code>\CorrectChoice</code> could be used naturally, without having to introduce extra commands in the document)
</p>


<h3>Value</h3>

<p>Data Frame. With the following columns
</p>

<dl>
<dt>index</dt><dd><p>Just an index running from 1 to <code class="reqn">n</code>, where <code class="reqn">n</code> is the numbe of rows</p>
</dd>
<dt>For each layer of depth in the document:</dt><dd>
<p>Four columns,
</p>

<dl>
<dt><code>&lt;name of section&gt;_original</code></dt><dd><p>Contains an integer identifying the numbering of this section in the original layer, as identified by the naming convention</p>
</dd>
<dt><code>&lt;name of section command&gt;_original</code></dt><dd><p>Contains an integer identifying the numbering of this item in the original section, as identified by the naming convention</p>
</dd>
<dt><code>&lt;name of section&gt;</code></dt><dd><p>Contains an integer identifying the numbering of this section in the current layer, as identified by the ordering of the  document inputted on this function</p>
</dd>
<dt><code>&lt;name of section command&gt;</code></dt><dd><p>Contains an integer identifying the numbering of this item in the current section, as identified by the ordering of the  document inputted on this function</p>
</dd>
</dl>

</dd>
<dt>For the last layer of depth</dt><dd>
<p>5 columns if the wrongTag is not NULL, 4 columns otherwise,
</p>

<dl>
<dt><code>&lt;name of section&gt;_original</code></dt><dd><p>Contains an integer identifying the numbering of this section in the original layer, as identified by the naming convention</p>
</dd>
<dt><code>&lt;name of section command&gt;_original</code></dt><dd><p>Contains an integer identifying the numbering of this item in the original section, as identified by the naming convention</p>
</dd>
<dt><code>&lt;name of section&gt;</code></dt><dd><p>Contains an integer identifying the numbering of this section in the current layer, as identified by the ordering of the  document inputted on this function</p>
</dd>
<dt><code>&lt;correctTag&gt;</code></dt><dd>
<p>Contains an integer identifying the numbering of this item in the current section, , as identified by the ordering of the  document inputted on this function
</p>
<p>If the <code>correctTag</code> wasn't found in this item, it will show <code>NA</code> instead. (This will only happen if <code>wrongTag</code> is not <code>NULL</code>, since otherwise this elements are omitted)</p>
</dd>
<dt><code>&lt;wrongTag&gt;</code></dt><dd>
<p>Contains an integer identifying the numbering of this item in the current section, as identified by the ordering of the  document inputted on this function
</p>
<p>If the <code>wrongTag</code> wasn't found in this item, it will show <code>NA</code> instead. (This will only happen if <code>wrongTag</code> is not <code>NULL</code>, since otherwise this elements are omitted)</p>
</dd>
</dl>

</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+FindExamAnswers">FindExamAnswers</a></code> for the exact underlying messy algorithm that controls how the table is created.
</p>
<p>Other Extracting information: 
<code><a href="#topic+CountNumberOfSections">CountNumberOfSections</a>()</code>,
<code><a href="#topic+FindExamAnswers">FindExamAnswers</a>()</code>,
<code><a href="#topic+GenerateShortAnswerSheet">GenerateShortAnswerSheet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ConstructAnswerSheet(
    TexExamRandomizer::testdoc$document,
    "CorrectChoice",
    "choice"
)
</code></pre>

<hr>
<h2 id='CountNumberOfSections'>CountNumberOfSections</h2><span id='topic+CountNumberOfSections'></span>

<h3>Description</h3>

<p>It counts the number of subparts in each section and outputs the result as a table. It doesn't act recursively, it only does the outermost layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CountNumberOfSections(Document)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CountNumberOfSections_+3A_document">Document</code></td>
<td>
<p>Document, as defined in <code><a href="#topic+StructureDocument">StructureDocument</a></code>. Remember however that the function <code><a href="#topic+StructureDocument">StructureDocument</a></code> returns the document and the preamble together in a list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The regular expression that defines this methods behaviour is the following
</p>
<p><code>"^[^[:digit:]]*([[:digit:]]+)_([^[:digit:]]+)_([[:digit:]]+)_(.*)"</code>
</p>
<p>The replacement is simply <code>"\1"</code>.
</p>
<p>It tries to first find whether there exist attributes command and section that explain the command and section, before starting to use regexs on the names.
</p>


<h3>Value</h3>

<p>A table, counting the number of &quot;<code>\cmdName</code>&quot; items in which the document was divided when parsed for every begin-end section. It doesn't act resursively.
</p>
<p>It will return a table with an integer that identifies the section, and a count, with how many items it found on that section. If it doesn't find any items or sections, it will return an empty table.
</p>


<h3>See Also</h3>

<p>Other Extracting information: 
<code><a href="#topic+ConstructAnswerSheet">ConstructAnswerSheet</a>()</code>,
<code><a href="#topic+FindExamAnswers">FindExamAnswers</a>()</code>,
<code><a href="#topic+GenerateShortAnswerSheet">GenerateShortAnswerSheet</a>()</code>
</p>

<hr>
<h2 id='CreateRandomExams'>CreateRandomExams</h2><span id='topic+CreateRandomExams'></span>

<h3>Description</h3>

<p>This function creates a series of randomized exams from a tex document and personalizes the information from a table (if a table is given) and a series of command names where thae information shoudl be replaced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateRandomExams(
  x,
  layersNames = c("questions", "choices"),
  layersCmd = c("question", "(choice|CorrectChoice)"),
  outputBaseName,
  outputDirectory,
  cmdReorder = rep_len(TRUE, length(layersNames)),
  sectionReorder = FALSE,
  infoTable = NULL,
  colNames = NULL,
  cmdNames = NULL,
  nOutputVersions = nrow(infoTable),
  nOutputQuestions = "max",
  answerSheetCorrectTag = NULL,
  answerSheetWrongTag = NULL,
  optionList = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CreateRandomExams_+3A_x">x</code></td>
<td>
<p>A character vector, each element represents one line of the latex document</p>
</td></tr>
<tr><td><code id="CreateRandomExams_+3A_layersnames">layersNames</code></td>
<td>
<p>A character vector, with each element representating the environment name to be searched as <code>cmdName</code> as describe in <code><a href="#topic+FindBegin">FindBegin</a></code> and <code><a href="#topic+FindEnd">FindEnd</a></code></p>
</td></tr>
<tr><td><code id="CreateRandomExams_+3A_layerscmd">layersCmd</code></td>
<td>
<p>A character vector, with the same length as <code>layersNames</code>. with each element representing the environment command to be serached as <code>cmdName</code> as described in <code><a href="#topic+FindCommand">FindCommand</a></code>.</p>
</td></tr>
<tr><td><code id="CreateRandomExams_+3A_outputbasename">outputBaseName</code></td>
<td>
<p>String, The basename for the output files.</p>
</td></tr>
<tr><td><code id="CreateRandomExams_+3A_outputdirectory">outputDirectory</code></td>
<td>
<p>String, The output directory.</p>
</td></tr>
<tr><td><code id="CreateRandomExams_+3A_cmdreorder">cmdReorder</code>, <code id="CreateRandomExams_+3A_sectionreorder">sectionReorder</code></td>
<td>
<p>Logical vector, the length of <code>cmdReorder</code> determines how many layers deep are we going to dig and randomize. For that reason, if <code>sectionReorder</code> is just a scalar, it will assume that it repeats for every <code>cmdReorder</code> that is given. See <code><a href="#topic+RandomizeDocument">RandomizeDocument</a></code> for extra details on these parameters.</p>
</td></tr>
<tr><td><code id="CreateRandomExams_+3A_infotable">infoTable</code></td>
<td>
<p>Table with information, if NULL, no information is added to the exams</p>
</td></tr>
<tr><td><code id="CreateRandomExams_+3A_colnames">colNames</code></td>
<td>
<p>Character vector, Column names from the <code>infoTable</code> from which we will extract the information.
</p>
<p>It first tries to find the column names literally, if ti couldn't find them like that, it will try to use them as a regular expression to find a column that matches the column.</p>
</td></tr>
<tr><td><code id="CreateRandomExams_+3A_cmdnames">cmdNames</code></td>
<td>
<p>Character vector, Names of the commands on the tex file, <code>\&lt;cmdNames[i]&gt;</code>, that are to be matched with the columns to replace the information from the table in those commands. For extra info see also <code><a href="#topic+ReplaceFromTable">ReplaceFromTable</a></code></p>
</td></tr>
<tr><td><code id="CreateRandomExams_+3A_noutputversions">nOutputVersions</code></td>
<td>
<p>Number of different random versions of the exam to be outputted</p>
</td></tr>
<tr><td><code id="CreateRandomExams_+3A_noutputquestions">nOutputQuestions</code></td>
<td>
<p>Number of &quot;questions&quot; on the output exams. If the input is a scalar, the program will decide how to more evenly split the questions between all the sections, otherwise one can directly provide an integer vector specifying how many questions from each section are needed. (this only searches the &quot;items&quot; of the outermost layer)</p>
</td></tr>
<tr><td><code id="CreateRandomExams_+3A_answersheetcorrecttag">answerSheetCorrectTag</code>, <code id="CreateRandomExams_+3A_answersheetwrongtag">answerSheetWrongTag</code></td>
<td>
<p>If the tags are not given, the output answersheet will be <code>NULL</code>. In other cases, these tags can be regular expressions</p>
</td></tr>
<tr><td><code id="CreateRandomExams_+3A_optionlist">optionList</code></td>
<td>
<p>Instead of writing the options on the function. Options could be given to optionList, and it will add those options. As long as the names are correct</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the output exams are named with <code>outputBaseName</code> followed by 00i identifying the number of the exam (The number of zeros is the minimum that allows for all the exams to have a different number) and <code>"_Version_"</code> followed by the version number of the exam and &quot;<code>.tex</code>&quot;. That is:
</p>
<p><code>&lt;outputDirectory&gt;/&lt;outputBaseName&gt;00i_Version_j.tex</code>
</p>
<p>The number of exams outputted will always be the same as the number of versions if no table is given. However, if a table is added as input. It will create one exam for each row of the table, and it will try to divide as evenly as possible how to give the versions between the different rows. (Having one exam for each row, which will probably represent a student)
</p>


<h3>Value</h3>

<p>A list that contains
</p>

<dl>
<dt><code>outputDirectory</code></dt><dd><p>The output directory</p>
</dd>
<dt><code>outputFiles</code></dt><dd><p>A character vector that contains all the output names</p>
</dd>
<dt><code>FullAnswerSheet</code></dt><dd><p>The full answer sheet of all the exams.
</p>
<p>Each answer sheet is created as described by <code><a href="#topic+ConstructAnswerSheet">ConstructAnswerSheet</a></code>, and all the answer sheets are joined together with a version number in front as an added column to bind them all together. The original version has the number 0, all the output versions have sequential numbers as Version
</p>
<p>This wrapper function assumes equal depth on all branches of the tree structure, so that the number of columns is always identical in the answer sheet
</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+ConstructAnswerSheet">ConstructAnswerSheet</a></code>, <code><a href="#topic+ReplaceFromTable">ReplaceFromTable</a></code>, <code><a href="#topic+RandomizeDocument">RandomizeDocument</a></code> for extra details. . To see examples of how to use it, look at the code in <code><a href="#topic+jsonhwparser">jsonhwparser</a></code>
</p>

<hr>
<h2 id='DivideFile'>DivideFile</h2><span id='topic+DivideFile'></span>

<h3>Description</h3>

<p>Function that takes a vector of text lines, <code>x</code>, and divides it in preamble and document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DivideFile(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DivideFile_+3A_x">x</code></td>
<td>
<p>A character vector, each element represents one line of the latex document</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It ignores everything after the first end document command and it will throw and error if it finds more than one begin document command before that
</p>


<h3>Value</h3>

<p>Returns a list with two character vectors:
</p>

<dl>
<dt>preamble</dt><dd><p>A character vector that includes <em>every line</em> of <code>x</code> up the begin document command</p>
</dd>
<dt>document</dt><dd><p>A character vector that includes <em>every line</em> from the begin document command to the first end document command</p>
</dd> </dl>



<h3>See Also</h3>

<p>Other Structuring Document: 
<code><a href="#topic+CompileDocument">CompileDocument</a>()</code>,
<code><a href="#topic+FindStructure">FindStructure</a></code>,
<code><a href="#topic+IsWellSectioned">IsWellSectioned</a>()</code>,
<code><a href="#topic+StructureDocument">StructureDocument</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- system.file(
    "extdata",
    "ExampleTexDocuments",
    "exam_testing_jsonparser.tex",
    package = "TexExamRandomizer"
)
x &lt;- readLines(file)
DivideFile(x)
</code></pre>

<hr>
<h2 id='FindExamAnswers'>FindExamAnswers</h2><span id='topic+FindExamAnswers'></span>

<h3>Description</h3>

<p>It finds the answer for a certain document, given a correct and wrong tag. The output character vector is a collection of all those matches, with the text identifying the section and item that it was found inside the tree structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindExamAnswers(Document, correctTag, wrongTag = NULL, OutputStartingName = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FindExamAnswers_+3A_document">Document</code></td>
<td>
<p>Document, as defined in <code><a href="#topic+StructureDocument">StructureDocument</a></code>. Remember however that the function <code><a href="#topic+StructureDocument">StructureDocument</a></code> returns the document and the preamble together in a list.</p>
</td></tr>
<tr><td><code id="FindExamAnswers_+3A_correcttag">correctTag</code></td>
<td>
<p>String, it should be the name (or regular expression) defining the tag that items that hold a correct answer will have. <code>\&lt;correctTag&gt;</code>.</p>
</td></tr>
<tr><td><code id="FindExamAnswers_+3A_wrongtag">wrongTag</code></td>
<td>
<p>String, leave as <code>NULL</code>, unless you went the output to explicitly show those questions that are incorrect. Again, it could be a</p>
</td></tr>
<tr><td><code id="FindExamAnswers_+3A_outputstartingname">OutputStartingName</code></td>
<td>
<p>Internal argument, (it should really be removed after testing that it really does nothing). In theory, this argument starts up the recursive search into the tree for matches. Since the output name will start with this string and a dash afterwards.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the document, a correct or wrong item should be identified with a tag. Which shall be a latex command. &quot;<code>\correct</code>&quot; &quot;<code>\wrong</code>&quot; or whichever. It must be placed somewhere that is not commented-out. (Similar to how the exam class uses the <code>\CorrectChoice</code> command to identify a correct answer, instead of using a <code>\choice</code>, both tags could be used for this class).
</p>
<p>(This is internally used by <code><a href="#topic+ConstructAnswerSheet">ConstructAnswerSheet</a></code> to construct that DF of answers by then parsing the vector output from this function and getting that way the output)
</p>
<p>If <code>wrongTag</code> is not null it also provides the information of where a wrong tag is found.
</p>
<p>Each output character vectors has a name that identifies all the information necessary to understand where the match was found, relative to both the original document, and the current document we are analizing even if the order of the current document is different.
</p>
<p>The name of each element starts with <code>&lt;OutputStartingName&gt;</code>. After that, for each layer that it digs into, it pastes the following name on the right of the name that it already has:
</p>
<p><code>_&lt;originalname&gt;_&lt;addedname&gt;</code>
</p>

<ul>
<li>
<p>Where <code>&lt;originalname&gt;</code> is the name that identifies that list at that depth as the naming convention described in <code><a href="#topic+StructureDocument">StructureDocument</a></code> defines. It identifies therefore the section and subsection refering to the original document. The string <code>"_original"</code> is added at the end of the name of the environment and the name of the command name to differentitate it.
</p>
</li>
<li>
<p>And where <code>&lt;addedname&gt;</code> is the name that identifies that list at that depth as the naming convention described in <code><a href="#topic+StructureDocument">StructureDocument</a></code> defines.
However, this name has section and item numbers refering to the <strong>current</strong> ordering of the document, not  the original ordering.
</p>
</li></ul>

<p>In the last layer, when it finally find the correct or wrong tag. It modifies the <code>&lt;addedname&gt;</code> that should look like <code>i_secName_j_cmdName</code> and it replaces cmdName with the correct or wrong tag respectively.
</p>
<p>Therefore, each element is a pretty long string identifying all the layers that it took to traverse to get down to the answer. This function was basically used to prevent the use of attributes that bug out unexpectedly, since when passing functions and parsing things looses the attributes.
</p>


<h3>Value</h3>

<p>Character vector. Each element identifies one match. The text of the element identifies where that match was found, in terms of the path walked on the tree that it took to get here. The naming convention is specified on details.
</p>


<h3>See Also</h3>

<p>Other Extracting information: 
<code><a href="#topic+ConstructAnswerSheet">ConstructAnswerSheet</a>()</code>,
<code><a href="#topic+CountNumberOfSections">CountNumberOfSections</a>()</code>,
<code><a href="#topic+GenerateShortAnswerSheet">GenerateShortAnswerSheet</a>()</code>
</p>

<hr>
<h2 id='FindMatchingRow'>FindMatchingRow</h2><span id='topic+FindMatchingRow'></span>

<h3>Description</h3>

<p>It outputs a logical vector identifying which rows in <code>DF</code> have the same values as the values on <code>rowtoMatch</code>. It ignores all columns that are not found on <code>rowtoMatch</code> when doing the matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindMatchingRow(rowtoMatch, DF)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FindMatchingRow_+3A_rowtomatch">rowtoMatch</code></td>
<td>
<p>One row of a data frame. If the length is longer, it won't output it.</p>
</td></tr>
<tr><td><code id="FindMatchingRow_+3A_df">DF</code></td>
<td>
<p>Dataframe in which we want to find the matches.
</p>
<p>It doesn't search that both the row of Df and rowtoMatch matches exactly, it only checks whether the columns that are found on rowtoMatch are found on DF with the same values (It decides which columns are &quot;the same column&quot; by looking at the names of the columns).
</p>
<p>It will throw an error if the names of the columns on <code>rowtoMatch</code> are not all found on <code>DF</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Note:</strong> It matches using the name of columns from <code>rowtoMatch</code>, matching them to the names of the <code>DF</code>.
</p>
<p>It will output <code>logical(0)</code> if the <code>rowtoMatch</code> is null, or if is a data frame with 0 rows.
</p>


<h3>Value</h3>

<p>Logical vector, with the same length as the number of rows in <code>DF</code>. It outputs <code>TRUE</code> if that row matched the <code>rowtoMatch</code>, <code>FALSE</code> otherwise
</p>

<hr>
<h2 id='FindStructure'>Structuring functions</h2><span id='topic+FindStructure'></span><span id='topic+FindBegin'></span><span id='topic+FindEnd'></span><span id='topic+FindCommand'></span>

<h3>Description</h3>

<p>These internal functions provide functionality to find environment names and their use
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindBegin(x, cmdName)

FindEnd(x, cmdName)

FindCommand(x, cmdName)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FindStructure_+3A_x">x</code></td>
<td>
<p>string vector, each line should represent one line of a text file or a section fo a text file.</p>
</td></tr>
<tr><td><code id="FindStructure_+3A_cmdname">cmdName</code></td>
<td>
<p>Command to search for in <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code><a href="#topic+FindBegin">FindBegin</a></code> and <code><a href="#topic+FindEnd">FindEnd</a></code>, <code>cmdName</code> refers to the name of the command that would start an environment. Following the 'LaTeX' convention of &quot;\begin{<code>cmdName</code>}&quot; or &quot;\end{<code>cmdName</code>}&quot; respectively. However, it is not a full throrough check.
They will only be found by this class if they are only preceded by alphanumeric characters and spaces, this is to force the user to use begin and end environments at the start of a new line. TODO: CONSIDER AYBE CHANGING THIS THIS, IT IS EASY.
</p>
<p>On the other hand, in the function  <code><a href="#topic+FindCommand">FindCommand</a></code>. It finds the command &quot;\<code>cmdName</code>&quot;. And in this case it is less rescrittive, as long as the line is not commented, it will find it.
Make sure to not write slashes before the &quot;\<code>cmdName</code>&quot;, since you might bug the program if it thinks you wrote the command but you just wrote some slashes and then the command name afterwards.
</p>
<p>All functions don't search for commands if the commands have been commented with the latex comment command in the same line... don't try to use multiple line comments on latex please...
</p>
<p><strong>IMPORTANT</strong>, instead of just writing something alphanumeric, these function actually use the  <code>cmdName</code> as a regular expression, which might be useful in many cases, but be careful with this.
</p>
<p>TODO: Implement options for regular expressions
</p>


<h3>Value</h3>

<p>Returns a numeric vector, indicating each occurrance of a start of a environment that looks like \begin{<code>cmdName</code>}
</p>
<p>Returns a numeric vector, indicating each occurrence of a start of a environment that looks like \end{<code>cmdName</code>}
</p>
<p>Returns a numeric vector, indicating each occurrence of the command \<code>cmdName</code> found in the document.
</p>


<h3>See Also</h3>

<p>Other Structuring Document: 
<code><a href="#topic+CompileDocument">CompileDocument</a>()</code>,
<code><a href="#topic+DivideFile">DivideFile</a>()</code>,
<code><a href="#topic+IsWellSectioned">IsWellSectioned</a>()</code>,
<code><a href="#topic+StructureDocument">StructureDocument</a>()</code>
</p>

<hr>
<h2 id='fun_from_folder'>Apply function within a folder</h2><span id='topic+fun_from_folder'></span>

<h3>Description</h3>

<p>It executes the function <code>fun</code> by first switching directories temporarily to the folder <code>folder</code> and then returning to the working directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun_from_folder(folder, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fun_from_folder_+3A_folder">folder</code></td>
<td>
<p>The folder of execution that the function is switched to before executing <code>fun</code></p>
</td></tr>
<tr><td><code id="fun_from_folder_+3A_fun">fun</code></td>
<td>
<p>Function to be executed from the relative path</p>
</td></tr>
<tr><td><code id="fun_from_folder_+3A_...">...</code></td>
<td>
<p>Options to be passed to <code>fun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return value of <code>fun(...)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>list.files()
fun_from_folder(system.file("data", package = "TexExamRandomizer"), list.files)
list.files()
</code></pre>

<hr>
<h2 id='GenerateHomework'>Generate Homework</h2><span id='topic+GenerateHomework'></span>

<h3>Description</h3>

<p>This function personalizes a 'LaTeX' document with data from a table,
generating a new file for each row which is saved on the <code>outputDirectory</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenerateHomework(
  x,
  Table,
  CommandNames,
  ColumnNames,
  outputDirectory,
  outputBaseName
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GenerateHomework_+3A_x">x</code></td>
<td>
<p>A character vector, each element represents one line of the latex document</p>
</td></tr>
<tr><td><code id="GenerateHomework_+3A_table">Table</code></td>
<td>
<p>Data frame from which to extract the information</p>
</td></tr>
<tr><td><code id="GenerateHomework_+3A_commandnames">CommandNames</code></td>
<td>
<p>Character vector with the same length as <code>columnNames</code></p>
</td></tr>
<tr><td><code id="GenerateHomework_+3A_columnnames">ColumnNames</code></td>
<td>
<p>Character vector with the names of the columns to be used</p>
</td></tr>
<tr><td><code id="GenerateHomework_+3A_outputdirectory">outputDirectory</code></td>
<td>
<p>The directory in which the output will be placed</p>
</td></tr>
<tr><td><code id="GenerateHomework_+3A_outputbasename">outputBaseName</code></td>
<td>
<p>The starting name for the output files
</p>
<p>The files will look like
</p>
<p><code>&lt;outputDirectory&gt;/&lt;outputBaseName&gt;_00&lt;number&gt;.tex</code>
</p>
<p>Where the number of zeros is the minimum number of zeros required to have a different version number for each file. (i.e., if there is only 45 files, it is 01-45; but with 132 files, it would be 001-132)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The command names should be 'LaTeX' commands that are being defined through
</p>
<p><code>\newcommand{\&lt;CommandNames[i]&gt;}{&lt;previous definition&gt;}</code>
</p>
<p>The definition of these commands will be changed to be
</p>
<p><code>\newcommand{\&lt;CommandNames[i]&gt;}{&lt;Table[ColumnNames[i]][file #]&gt;}</code>
</p>
<p>And it will output one file for each command.
</p>
<p>The intent of this function was to populate information into a generic homework to personalize it for every student using 'LaTeX'.
(It actually generalizes to maybe other problems).
</p>


<h3>Value</h3>

<p>Character vector with the file names of the output.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ReplaceFromTable">ReplaceFromTable</a></code> to get a better idea of how the replacement is made. To see examples of how to use it, look at the code in <code><a href="#topic+jsonhwparser">jsonhwparser</a></code>
</p>

<hr>
<h2 id='GenerateShortAnswerSheet'>Generating a short answer sheet</h2><span id='topic+GenerateShortAnswerSheet'></span>

<h3>Description</h3>

<p>Given a number of answer sheets generated by <code><a href="#topic+ConstructAnswerSheet">ConstructAnswerSheet</a></code> that have been binded together. And that have a column, <code>versionColName</code>, that identifies each version. It collects all the answers together and places all the answers together for each exam.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenerateShortAnswerSheet(
  ExamSheet,
  versionColName = "Version",
  correctColName = "CorrectChoice"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GenerateShortAnswerSheet_+3A_examsheet">ExamSheet</code></td>
<td>
<p>a exam sheet that contains all versions, similar to <code><a href="#topic+CreateRandomExams">CreateRandomExams</a></code></p>
</td></tr>
<tr><td><code id="GenerateShortAnswerSheet_+3A_versioncolname">versionColName</code></td>
<td>
<p>The name of the column in the original exam that contains the version number</p>
</td></tr>
<tr><td><code id="GenerateShortAnswerSheet_+3A_correctcolname">correctColName</code></td>
<td>
<p>The name of the column that contains the last index for the correct tag, or NA if it is not a correct choice.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that if the version number is 0, it is ignored, since it understands that version 0 is the reference version.
</p>
<p>If the document has more than two layers, keep in mind that it just shows the top most layer numbering and then the inner most number of the correct answers.
</p>
<p>Note how this implies as well that an exam with more than one possible answer can not be simplified into a short answer sheet.
</p>
<p>IMPORTANTLY, If a certain exam has less answers than other exams, the are just cited sequentially. Which may cause confusion. To clarify. This may happen if a certain question has more than one solution marked as &quot;correct&quot;, or if a certain question has no solutions marked as correct. In that case, The short answer sheet just sequentially names all the correct answers, disregarding which questions they are referring to. (This is a very special case that will only come up in a real scenario if you are writing a short answer question in the middle of a multiple choice test. Or if you are writing some questions to have multiple correct answers, but only a few of them, and those questions are not included in all exams... (So evil))
</p>


<h3>Value</h3>

<p>A data frame </p>

<ul>
<li><p> Each row identifies one version of the answer sheet
</p>
</li>
<li><p> the first column is the version number, the rest of the columns are the questions,
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Extracting information: 
<code><a href="#topic+ConstructAnswerSheet">ConstructAnswerSheet</a>()</code>,
<code><a href="#topic+CountNumberOfSections">CountNumberOfSections</a>()</code>,
<code><a href="#topic+FindExamAnswers">FindExamAnswers</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
csvfile &lt;- system.file(
    "extdata",
    "ExampleTables",
    "ExampleAnswerSheet.csv",
    package = "TexExamRandomizer"
)
testASheet &lt;- read.csv(
    csvfile,
    header = TRUE,
    stringsAsFactors = FALSE,
    na.strings = c("", "NA", "Na"),
    strip.white = TRUE
)

GenerateShortAnswerSheet(testASheet)
</code></pre>

<hr>
<h2 id='GetLayerSampleIndexes'>GetLayerSampleIndexes</h2><span id='topic+GetLayerSampleIndexes'></span>

<h3>Description</h3>

<p>Function to randomize the names of a list to sample, as provided by <code><a href="#topic+StructureDocument">StructureDocument</a></code>. It takes the names of the list, not the list itself, and it provides the indexes needed to resample the original list judging by those names. It doesn't output a resampled list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetLayerSampleIndexes(
  section_vector,
  command_vector,
  sampleSectionOrder = FALSE,
  randomizeSection = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetLayerSampleIndexes_+3A_command_vector">command_vector</code></td>
<td>
<p>The names of each element on the list we want to sample, with the original order. The usual use would be <code>NamesOfListToSample = names(list)</code>.
</p>
<p>Being specific, the names that are provided will be matched with the regular expression <code>"^[[:digit:]]+_.+[[:digit:]]+_"</code>.</p>
</td></tr>
<tr><td><code id="GetLayerSampleIndexes_+3A_samplesectionorder">sampleSectionOrder</code></td>
<td>
<p>Should it also move around the sections or not? Look at the details for a more detailed explanation</p>
</td></tr>
<tr><td><code id="GetLayerSampleIndexes_+3A_randomizesection">randomizeSection</code></td>
<td>
<p>If this is set to false, it will not randomize the list, it will just output <code>1:length(command_vector)</code>. It handles properly when the list is of length 0, by outputting <code>integer(0)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Following the prescription from <code><a href="#topic+StructureDocument">StructureDocument</a></code>, it keeps the &quot;prior_to&quot; and &quot;post_to&quot; parts fixed. And within each section it keeps the &quot;begin_&quot; and &quot;end_&quot; parts fixed. Then, it resamples everything within each section, and afterwards resamples the order of the sections if <code>sampleSectionOrder</code> is true
</p>
<p>Note how the names of the list are expected to represent the structure described in <code><a href="#topic+StructureDocument">StructureDocument</a></code>
</p>


<h3>Value</h3>

<p>An integer vector, that would provide a random reordering of the list.
</p>

<hr>
<h2 id='GradeExams'>GradeExams</h2><span id='topic+GradeExams'></span>

<h3>Description</h3>

<p>Grades an exam given a parsed list by <code><a href="#topic+WhichAnswerOriginal">WhichAnswerOriginal</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GradeExams(
  ExamAnswerParsedList,
  name.ColCorrect,
  name.ColIncorrect,
  MaxOutputGrade = 100,
  ExtraPoints = 0,
  ExtraPointsForAll = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GradeExams_+3A_examanswerparsedlist">ExamAnswerParsedList</code></td>
<td>
<p>List parsed by <code><a href="#topic+WhichAnswerOriginal">WhichAnswerOriginal</a></code></p>
</td></tr>
<tr><td><code id="GradeExams_+3A_name.colcorrect">name.ColCorrect</code>, <code id="GradeExams_+3A_name.colincorrect">name.ColIncorrect</code></td>
<td>
<p>The names of the correct and incorrect columns in each answer sheet of the <code>ExamAnswerParsedList</code> respectively.</p>
</td></tr>
<tr><td><code id="GradeExams_+3A_maxoutputgrade">MaxOutputGrade</code></td>
<td>
<p>Maximum score that one should get if you get a perfect score, before couning the <code>ExtraPoints</code></p>
</td></tr>
<tr><td><code id="GradeExams_+3A_extrapoints">ExtraPoints</code></td>
<td>
<p>Extra points to be added after scoring the exam. This points are added after the scaling is done with <code>MaxOutputGrade</code>.</p>
</td></tr>
<tr><td><code id="GradeExams_+3A_extrapointsforall">ExtraPointsForAll</code></td>
<td>
<p>Scalar numeric value, extra points to be given to all student.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The score is first added on the base of the number of questions that are found on every parsed list.
</p>
<p>If a question is removed from an exam, not all students may have that question as explained in the &quot;Removing questions from the exam&quot; section. If the total rows of a certain student list is <code class="reqn">n</code>, the score is </p>
<p style="text-align: center;"><code class="reqn">c / n * MaxOutputGrade</code>
</p>
<p>, where <code class="reqn">c</code> is the number of correct answers.
</p>
<p>After that is done, the <code>ExtraPoints</code> are added.
</p>


<h3>Value</h3>

<p>It returns the <code>StudentInfo</code> attribute of the parsed list adding the following columns to it
</p>

<dl>
<dt><code>$addedPoints</code></dt><dd><p>Individual part of ExtraPoints</p>
</dd>
<dt><code>$addedAllPoints</code></dt><dd><p>Extra Points For All</p>
</dd>
<dt><code>$maxGrade</code></dt><dd><p> Max number of questions for the exam. (It would be different if when removing a question, some students didn't have a question in that exam)</p>
</dd>
<dt><code>$Grade</code></dt><dd><p>Number of correct answers that a student wrote in an exam</p>
</dd>
<dt><code>$Grade_Total_Exam</code></dt><dd><p>This is the <code>total_grade</code> as explained on the Extra Points section.</p>
</dd>
</dl>



<h3>Extra Points</h3>

<p>The structure of <code>ExtraPoints</code> and the convention on how the score is calculated taking it into account is worth mentioning in it's own section.
The score is calculated as:
</p>
<p style="text-align: center;"><code class="reqn">total_{grade} = (c + extra_{all}) / (maxn + extra_{all}) * MaxOutputGrade + extra_{individual}</code>
</p>

<p>Where </p>

<dl>
<dt><code>c</code></dt><dd><p>Number of correct questions</p>
</dd>
<dt><code>extra_all</code></dt><dd><p>Number of extra points for all.
</p>
<p>This is thought of to be used as a question that you removed from the exam last minute,
but that you want to actually count it as correct for every single student. I.e., a question that everyone got correct but it is not taken into consideration in the grading.</p>
</dd>
<dt><code>extra_individual</code></dt><dd><p>Number of extra points for that student.</p>
</dd>
<dt><code>max_n</code></dt><dd><p>Maximum number of questions in the students exam, which may differ from other students if you had to removed a bugged questions that not everyone had</p>
</dd>
<dt><code>MaxOutputGrade</code></dt><dd><p>The scaling to be done. This should be the maximum grade any student &quot;should&quot; get. (The individual extra points are added after the scaling is done)</p>
</dd>
</dl>



<h3>Removing Questions from the exam</h3>

<p>Note that if after creating the exam, you found that a question is bugged and can't be used to grade the exam, all you have to do is tell the student to answer &quot;something&quot; and you only have to remove it from the original/reference version in the Full Answer Sheet. When you apply the grading function, that question will then be ignored.
</p>
<p>Notice how this creates output lists with different lengths in the case that two students didn't have that same question in their exam.
</p>
<p>For example, if a exam has 15 questions out of a 50 question document. If student A has a bugged question and student B doesn't, the answer sheet produced for student A will have 14 rows while the one for student B will have 15 rows.
</p>


<h3>See Also</h3>

<p>Other Grading Exams: 
<code><a href="#topic+ObtainExamStats">ObtainExamStats</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#First part coming from FindMatchingRow example

asheet_file &lt;-
    system.file(
        "extdata",
        "ExampleTables",
        "ExampleAnswerSheet.csv",
        package = "TexExamRandomizer")
responses_file &lt;-
    system.file(
        "extdata",
        "ExampleTables",
        "ExampleResponses.csv",
        package = "TexExamRandomizer")
FullAnswerSheet &lt;-
    read.csv(
        asheet_file,
        header = TRUE,
        stringsAsFactors = FALSE,
        na.strings = c("", "NA", "Na"),
        strip.white = TRUE)
Responses &lt;- read.csv(
    responses_file,
    header = TRUE,
    stringsAsFactors = FALSE,
    na.strings = c("", "NA", "Na"),
    strip.white = TRUE)
compiledanswers &lt;-
    WhichAnswerOriginal(
        StudentAnswers = Responses,
        FullExamAnswerSheet = FullAnswerSheet,
        names.StudentAnswerQCols = grep(
            names(Responses),
            pattern = "^Q.*[[:digit:]]",
            value = TRUE),
        names.StudentAnswerExamVersion = grep(
            names(Responses),
            pattern = "Version",
            value = TRUE),
        OriginalExamVersion = 0,
        names.FullExamVersion = "Version",
        names.FullExamOriginalCols = grep(
            names(FullAnswerSheet),
            pattern = "_original",
            value = TRUE),
        names.CorrectAndIncorrectCols = c(
            "choice",
            "CorrectChoice")
    )
# Actual Code


ExtraPoints_individual &lt;- runif(nrow(Responses), min = 1, max = 10)
ExtraPoints_forall &lt;- 2
GradedStudentTable &lt;-
    GradeExams(
        compiledanswers,
        name.ColCorrect = "CorrectChoice",
        name.ColIncorrect = "choice",
        MaxOutputGrade = 100,
        ExtraPoints = ExtraPoints_individual,
        ExtraPointsForAll = ExtraPoints_forall
    )




</code></pre>

<hr>
<h2 id='IsWellSectioned'>IsWellSectioned</h2><span id='topic+IsWellSectioned'></span>

<h3>Description</h3>

<p>Function to assure a set of sections is well sectioned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IsWellSectioned(u, v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IsWellSectioned_+3A_u">u</code></td>
<td>
<p>Vector, it assumes it is ordered in ascending ordered</p>
</td></tr>
<tr><td><code id="IsWellSectioned_+3A_v">v</code></td>
<td>
<p>Vector, it assumes it is ordered in ascending ordered</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basically it makes sure that, <code class="reqn">u[1]&lt;v[1]&lt;u[2]&lt;v[2]</code>, etc
</p>


<h3>Value</h3>

<p>Logical value, TRUE if it is well ordered, FALSE it is not
</p>


<h3>Author(s)</h3>

<p>Alejandro Recuenco <a href="mailto:alejandrogonzalezrecuenco@gmail.com">alejandrogonzalezrecuenco@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other Structuring Document: 
<code><a href="#topic+CompileDocument">CompileDocument</a>()</code>,
<code><a href="#topic+DivideFile">DivideFile</a>()</code>,
<code><a href="#topic+FindStructure">FindStructure</a></code>,
<code><a href="#topic+StructureDocument">StructureDocument</a>()</code>
</p>

<hr>
<h2 id='jsonexamparser'>Json Exam Document Parser</h2><span id='topic+jsonexamparser'></span>

<h3>Description</h3>

<p>This function takes a series of options as obtained from <code><a href="optparse.html#topic+parse_args">parse_args</a></code> through the parameter <code>opt</code>. The &quot;examples&quot; section provides all the options that it can parse.
</p>
<p>From within those options, a <code>--file</code> option is mandatory.
</p>
<p>The file option provides a 'LaTeX' file name in which to search for lines on the preamble <code>%!TexExamRandomizer</code> within the first 200 lines.
</p>
<p>With those options that it finds through tags, it passes the function <code><a href="#topic+CreateRandomExams">CreateRandomExams</a></code>.
</p>
<p>Note that the tags must respect the JSON format, that is. It <em>needs</em> to be written within double quotes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jsonexamparser(opt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jsonexamparser_+3A_opt">opt</code></td>
<td>
<p>Options as parsed from <code><a href="optparse.html#topic+parse_args">parse_args</a></code>. The function expects a series of options, the example code exemplifies those options that the function understands.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the options can be found on
</p>
<p><code>vignette("ExamOptions", package = "TexExamRandomizer")</code>
</p>
<p>The options that are called &quot;command line&quot; options in the vignette are those that are given to the function through <code>opt</code>, the rest of the options are read directly from the document specified with <code>--file &lt;filename&gt;</code>
</p>


<h3>See Also</h3>

<p>Other jsoncompiler: 
<code><a href="#topic+ParsePreambleForOptions">ParsePreambleForOptions</a>()</code>,
<code><a href="#topic+compilation_options">compilation_options</a>()</code>,
<code><a href="#topic+jsonhwparser">jsonhwparser</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#!/bin/Rscript
#This example showcases the type of script this jsonparser might be used on.
# You can still use it without a script,
# just by adding a list that has the same names as the list provided in opt
library(optparse)
option_list &lt;- list(
    make_option(
        c("--file"),
        action = "store",
        default = NULL,
        type = 'character',
        help = "Filename of the Tex File"
    ),
    make_option(
        c("--table"),
        action = "store",
        default = NULL,
        type = 'character',
        help = "Filename of the table to break down. It overwrites the values written on the file"
    ),
    make_option(
        c("-n", "--noutput"),
        action = "store",
        default = NULL,
        type = "integer",
        help = "Number of output Versions"
    ),
    make_option(
        c("-q", "--nquestions"),
        action = "store",
        default = NULL,
        type = "character",
        help = "Number of output questions"
    ),
    make_option(
        c("-s", "--seed"),
        action = "store",
        default = NULL,
        type = "integer",
        help = "Seed for any randomization done"
    ),
    make_option(
        c("-c", "--compile"),
        action = "store_true",
        default = FALSE,
        type = "logical",
        help = "Should the output folder be compiled or not"
    ),
    make_option(
        c("--xelatex"),
        action = "store_true",
        default = FALSE,
        type = "logical",
        help = "Should we use xelatex to compile or not"
    ),
    make_option(
        c("-d", "--debug"),
        action = "store_true",
        default = FALSE,
        type = "logical",
        help = "If debugging, it doesn't remove auxiliary files"
    )
)


#### PARSING OPTIONS ####
####
opt &lt;-
    parse_args(
        OptionParser(option_list = option_list),
        positional_arguments = TRUE
    )

# Let's assume the file was the example file
testfile &lt;-
    system.file(
        "extdata",
        "ExampleTexDocuments",
        "exam_testing_nquestions.tex", #Test exam that doesn't require a table
        package = "TexExamRandomizer")

# To prevent modifying the file system in examples
temporalfile &lt;- paste(tempfile(), ".tex", sep = "")

file.copy(testfile, temporalfile)

opt$options$file &lt;- temporalfile



jsonexamparser(opt)

## End(Not run)

</code></pre>

<hr>
<h2 id='jsonhwparser'>Json Homework Parser</h2><span id='topic+jsonhwparser'></span>

<h3>Description</h3>

<p>This function takes a series of options as obtained from <code><a href="optparse.html#topic+parse_args">parse_args</a></code> through the parameter <code>opt</code>. The &quot;examples&quot; section provides all the options that it can parse.
</p>
<p>From within those options, a <code>--file</code> option is mandatory.
</p>
<p>The file option provides a 'LaTeX' file name in which to search for lines on the preamble <code>%!TexExamRandomizer</code> within the first 200 lines.
</p>
<p>With those options that it finds through tags, it passes the function <code><a href="#topic+GenerateHomework">GenerateHomework</a></code>.
</p>
<p>Note that the tags must respect the JSON format, that is. It <em>needs</em> to be written within double quotes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jsonhwparser(opt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jsonhwparser_+3A_opt">opt</code></td>
<td>
<p>Options as parsed from <code><a href="optparse.html#topic+parse_args">parse_args</a></code>. The function expects a series of options, the example code exemplifies those options that the function understands.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It acts similarly to <code>link{jsonexamparser}</code>, but with the exception of not providing any randomiation option, it only provides the personalization options.
</p>
<p>Look at <code>vignette("ExamOptions", package = "TexExamRandomizer")</code> to see the details of the options that it accepts.
</p>


<h3>See Also</h3>

<p>Other jsoncompiler: 
<code><a href="#topic+ParsePreambleForOptions">ParsePreambleForOptions</a>()</code>,
<code><a href="#topic+compilation_options">compilation_options</a>()</code>,
<code><a href="#topic+jsonexamparser">jsonexamparser</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#!/bin/Rscript
#This example showcases the type of script this jsonparser might be used on.
# You can still use it without a script,
# just by adding a list that has the same names as the list provided in opt
library(optparse)
option_list &lt;- list(
    make_option(
        c("--file"),
        action = "store",
        default = NULL,
        type = 'character',
        help = "Filename of the Tex File"
    ),
    make_option(
        c("--table"),
        action = "store",
        default = NULL,
        type = 'character',
        help = "Filename of the table to break down. It overwrites the values written on the file"
    ),
    make_option(
        c("-s", "--seed"),
        action = "store",
        default = NULL,
        type = "integer",
        help = "Seed for any randomization done"
    ),
    make_option(
        c("-c", "--compile"),
        action = "store_true",
        default = FALSE,
        type = "logical",
        help = "Should the output folder be compiled or not"
    ),
    make_option(
        c("--xelatex"),
        action = "store_true",
        default = FALSE,
        type = "logical",
        help = "Should we use xelatex to compile or not"
    ),
    make_option(
        c("-d", "--debug"),
        action = "store_true",
        default = FALSE,
        type = "logical",
        help = "If debugging, it doesn't remove auxiliary files"
    )
)


#### PARSING OPTIONS ####
####
opt &lt;-
    parse_args(
        OptionParser(option_list = option_list),
        positional_arguments = TRUE
    )

# Let's assume the file was the example file
testfile &lt;-
    system.file(
        "extdata",
        "ExampleTexDocuments",
        "exam_testing_nquestions.tex", #Test exam that doesn't require a table
        package = "TexExamRandomizer")

# To prevent modifying the file system in examples
temporalfile &lt;- paste(tempfile(), ".tex", sep = "")

file.copy(testfile, temporalfile)

opt$options$file &lt;- temporalfile



jsonhwparser(opt)

## End(Not run)

</code></pre>

<hr>
<h2 id='ObtainExamStats'>Obtaining exam statistics</h2><span id='topic+ObtainExamStats'></span>

<h3>Description</h3>

<p>This function gets an answer sheet of the original version of the exam as a data frame, and a parsed list, which is obtained from <code><a href="#topic+GradeExams">GradeExams</a></code> and it outputs the statistics of how many answers are parsed exam, that is graded and obtains from there
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ObtainExamStats(
  OriginalExamAnswerSheet,
  ExamAnswerParsedList,
  names.FullExamOriginalCols
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ObtainExamStats_+3A_originalexamanswersheet">OriginalExamAnswerSheet</code></td>
<td>
<p>The answer sheet of the original exam. (In this package the convention is the exam version &quot;0&quot;)</p>
</td></tr>
<tr><td><code id="ObtainExamStats_+3A_examanswerparsedlist">ExamAnswerParsedList</code></td>
<td>
<p>A parsed list for every student, as outputted by <code><a href="#topic+GradeExams">GradeExams</a></code></p>
</td></tr>
<tr><td><code id="ObtainExamStats_+3A_names.fullexamoriginalcols">names.FullExamOriginalCols</code></td>
<td>
<p>Names of those columns that in the answer sheet identify for all versions where that item is found on the original columns, (i.e., as ordered from the original version exam)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code>OriginalExamAnswerSheet</code> with a column added to it, named &quot;<code>ExamAnswerCount</code>&quot; that counts the number of answers for each question
</p>


<h3>See Also</h3>

<p>Other Grading Exams: 
<code><a href="#topic+GradeExams">GradeExams</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
asheet_file &lt;-
    system.file(
        "extdata",
        "ExampleTables",
        "ExampleAnswerSheet.csv",
        package = "TexExamRandomizer")
responses_file &lt;-
    system.file(
        "extdata",
        "ExampleTables",
        "ExampleResponses.csv",
        package = "TexExamRandomizer")
FullAnswerSheet &lt;-
    read.csv(
        asheet_file,
        header = TRUE,
        stringsAsFactors = FALSE,
        na.strings = c("", "NA", "Na"),
        strip.white = TRUE)
Responses &lt;- read.csv(
    responses_file,
    header = TRUE,
    stringsAsFactors = FALSE,
    na.strings = c("", "NA", "Na"),
    strip.white = TRUE)
compiledanswers &lt;-
    WhichAnswerOriginal(
        StudentAnswers = Responses,
        FullExamAnswerSheet = FullAnswerSheet,
        names.StudentAnswerQCols = grep(
            names(Responses),
            pattern = "^Q.*[[:digit:]]",
            value = TRUE),
        names.StudentAnswerExamVersion = grep(
            names(Responses),
            pattern = "Version",
            value = TRUE),
        OriginalExamVersion = 0,
        names.FullExamVersion = "Version",
        names.FullExamOriginalCols = grep(
            names(FullAnswerSheet),
            pattern = "_original",
            value = TRUE),
        names.CorrectAndIncorrectCols = c(
            "choice",
            "CorrectChoice")
    )
OriginalAnswerSheet &lt;- FullAnswerSheet[FullAnswerSheet$Version == 0,]
ExamStats &lt;-
    ObtainExamStats(
        OriginalExamAnswerSheet = OriginalAnswerSheet,
        ExamAnswerParsedList = compiledanswers,
        names.FullExamOriginalCols =  grep(
            names(FullAnswerSheet),
            pattern = "_original",
            value = TRUE)
    )
</code></pre>

<hr>
<h2 id='ParsePreambleForOptions'>ParsePreambleForOptions</h2><span id='topic+ParsePreambleForOptions'></span>

<h3>Description</h3>

<p>This function parses a preamble of a document trying to read options handed to the package TexExamRandomizer to be used in compiling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ParsePreambleForOptions(preamble)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ParsePreambleForOptions_+3A_preamble">preamble</code></td>
<td>
<p>character vector identifying the preamble from which to pass the JSON readon through</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It find all <code>%!TexExamRandomizer = {}</code> lines. It then uses the function  <code><a href="jsonlite.html#topic+fromJSON">fromJSON</a></code> to parse them, and it concatenates all those options.
</p>
<p>If more than one option with the same name is given, it tries to concatenate those.
However, it doesn't do that recursively, only if the names of the outer layer are the same... therefore, in nested structure you might end up with a list that have twice the same name. Keep in mind that in those cases, the default behaviour of R is to select the first one.
</p>


<h3>Value</h3>

<p>Returns a list, that concatenates all the lists of options described on the file.
</p>


<h3>See Also</h3>

<p>Other jsoncompiler: 
<code><a href="#topic+compilation_options">compilation_options</a>()</code>,
<code><a href="#topic+jsonexamparser">jsonexamparser</a>()</code>,
<code><a href="#topic+jsonhwparser">jsonhwparser</a>()</code>
</p>

<hr>
<h2 id='RandomizeDocument'>Randomizing documents.</h2><span id='topic+RandomizeDocument'></span>

<h3>Description</h3>

<p>Function to randomize a Document, as created by <code><a href="#topic+StructureDocument">StructureDocument</a></code>.
</p>
<p>It Randomizes each layer according to the prescriptions involved in the internal function <code><a href="#topic+GetLayerSampleIndexes">GetLayerSampleIndexes</a></code>. Which, in summary, randomizes each section inside, and then randomizes the orders of the sections.
</p>
<p><strong>Important note:</strong> One must provide to this function the <em>document</em> part of the structure. Since <code><a href="#topic+StructureDocument">StructureDocument</a></code> provides as the outer most layer a split between the preamble and the document, one must just supply the document part to this function, (or a subsection of it).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RandomizeDocument(
  Document,
  isSectionReordered.vector,
  isLayerRandomized.vector
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RandomizeDocument_+3A_document">Document</code></td>
<td>
<p>Document to randomize, as generated by <code><a href="#topic+StructureDocument">StructureDocument</a></code>. The names of the structure are used to determine how to randomize the document.</p>
</td></tr>
<tr><td><code id="RandomizeDocument_+3A_issectionreordered.vector">isSectionReordered.vector</code></td>
<td>
<p>Logical vector, specifying if the order of sections should be also randomized at a certain depth level.
</p>
<p><strong>Note</strong> that if <code>isLayerRandomized</code> is set to false for a certain layer, <code>isSectionReorder</code> will have no effect. (Probably this isn't the best behaviour)</p>
</td></tr>
<tr><td><code id="RandomizeDocument_+3A_islayerrandomized.vector">isLayerRandomized.vector</code></td>
<td>
<p>Logical vector, specifying if you should randomize the order of the items, (denoted by <code>\cmdName</code>) or not at a certain depth level.
</p>
<p>This vector should have the same length as the depth at most, otherwise it will raise an error if you try to &quot;dig deeper than it can&quot;. And <em>isSectionReordered.vector</em> should have matching elements for each element of <em>isLayerRandomized.vector</em>
</p>
<p>(Maybe we could change this to a warning instead? To allow for structures with different depths within different branches of the tree)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It keeps randomizing recursively inner layers of the structure until it runs out of elements on the logical vectors <code>isSectionReordered.vector</code> and <code>isLayerRandomized.vector</code>.
</p>
<p>A &quot;section&quot; denotes the content within a begin-end environment in the document.
Each section is then assumed to be divided in a beginning and end parts, that should be fixed in place, and the parts denoted by the command <code>\cmdName</code> as explained on <code><a href="#topic+StructureDocument">StructureDocument</a></code>.
</p>
<p>We will denote those parts as &quot;items.&quot;
Analogously to itemize environments in 'LaTeX'.
</p>
<p>The purpose of this function is therefore to randomize the items from the structure, fixing the begin and end parts within a section. And then to reorder each section while keeping the pre- and post- parts fixed, and to do so recursively until we exhaust the <code>isLayerRandomized.vector</code>
</p>
<p><code>isSectionReordered.vector</code> specifies whether to order sections for a certain depth, while <code>isLayerRandomized.vector</code> specifies whether to order the items within a section of that same depth.
</p>
<p>In some cases you may want to reorder the sections, for example, using the examdesign class. Over there, questions use the begin-end question format.
</p>
<p>In others cases you may want to preserve the order of sections while still modifying the order of the items, like when you are using the exam class, or when creating your own list of questions with an <code>\itemize</code> environment.
</p>
<p>For efficiency, if you don't want to randomize to the full depth of your tree, just make those logical vectors of your desired length, rather than making them of length <code class="reqn">n</code> and then setting every layer after the last one you want to randomize to false. That will prevent the program from walking down the whole tree checking everything.
</p>


<h3>Value</h3>

<p>A document structure, as provided by <code><a href="#topic+StructureDocument">StructureDocument</a></code>.
</p>
<p>However, the names of the structure will no longer be sequential,
the naming convention in the new structure will refer to the original structure that was inputted into this function. Which is very useful when you want to keep track of where things have moved.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+StructureDocument">StructureDocument</a></code>, TODO: Add reference to extracting info functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rndDoc &lt;- RandomizeDocument(
    TexExamRandomizer::testdoc$document,
    c(FALSE,TRUE),
    c(TRUE, TRUE)
    )
</code></pre>

<hr>
<h2 id='ReplaceFromTable'>ReplaceFromTable</h2><span id='topic+ReplaceFromTable'></span>

<h3>Description</h3>

<p>Given a 'LaTeX' file represented as a character vecotr with <code>x</code>, it replaces from a table the commands given by <code>commandNames</code>. for the values found on the table.
</p>
<p><code>\newcommand{\commandName[i]}{table[tableRow, columnName[i]]}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReplaceFromTable(x, table, tableRow, columnNames, commandNames)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ReplaceFromTable_+3A_x">x</code></td>
<td>
<p>A character vector, each element is suppose to represent a line</p>
</td></tr>
<tr><td><code id="ReplaceFromTable_+3A_table">table</code></td>
<td>
<p>Data frame from which to extract the information</p>
</td></tr>
<tr><td><code id="ReplaceFromTable_+3A_tablerow">tableRow</code></td>
<td>
<p>Integer, row of the <code>table</code> to be used</p>
</td></tr>
<tr><td><code id="ReplaceFromTable_+3A_columnnames">columnNames</code></td>
<td>
<p>Character vector with the names of the columns to be used</p>
</td></tr>
<tr><td><code id="ReplaceFromTable_+3A_commandnames">commandNames</code></td>
<td>
<p>Character vector with the same length as <code>columnNames</code>. Contains the names of the 'LaTeX' commands to be replaced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To do the replacement for each item, it uses the function <code><a href="#topic+ReplacePreambleCommand">ReplacePreambleCommand</a></code>. See the details in that function for more information.
</p>


<h3>Value</h3>

<p>A character vector, representing the text <code>x</code>, where all instances of
<code> \newcommand\commandNames[i]{&lt;random text&gt;}</code> have been replaced with
<code> \newcommand\commandNames[i]{table[tableRow, columnName[i]}</code>.
</p>


<h3>See Also</h3>

<p>Other Preamble adjustment: 
<code><a href="#topic+ReplacePreambleCommand">ReplacePreambleCommand</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
custom_preambles &lt;- list()
for (i in 1:nrow(TexExamRandomizer::testclass)) {
    custom_preambles &lt;-
        c(
            custom_preambles,
            list(
                TexExamRandomizer::ReplaceFromTable(
                    TexExamRandomizer::testdoc$preamble,
                    table = TexExamRandomizer::testclass,
                    tableRow = i,
                    columnNames = c("Class", "Roll.Number", "Nickname"),
                    commandNames = c("class", "rollnumber", "nickname")
                )
            )

        )

}
</code></pre>

<hr>
<h2 id='ReplacePreambleCommand'>ReplacePreambleCommand</h2><span id='topic+ReplacePreambleCommand'></span>

<h3>Description</h3>

<p>This functions gets a character vector in which each element represents a line of
a preamble of a 'LaTeX' document, and it replaces the definition of the command <code>\commandName</code> to have the value <code>commandValue</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReplacePreambleCommand(x, commandName, commandValue)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ReplacePreambleCommand_+3A_x">x</code></td>
<td>
<p>A character vector, each element is suppose to represent a line</p>
</td></tr>
<tr><td><code id="ReplacePreambleCommand_+3A_commandname">commandName</code></td>
<td>
<p>A string identifying either the command name</p>
</td></tr>
<tr><td><code id="ReplacePreambleCommand_+3A_commandvalue">commandValue</code></td>
<td>
<p>Replacement for the definition of commandName</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It only modifies the value of the command by replacing instances of
</p>
<p><code>\newcommand{\commandName}{&lt;previous definition&gt;}</code> with instances of
</p>
<p><code>\newcommand{\commandName}{&lt;commandValue&gt;}</code>.
</p>
<p>Keep in mind that both <code>commandName</code> and <code>commandValue</code> are placed directly inside a regex.
</p>
<p>If you want to &quot;hide&quot; a certain definition of a command from being found and replaced by this function,  simply define it by using <code>\def</code> or <code>\newcommand*</code> or a <code>\renewcommand</code> when you define them.
</p>
<p>Make sure you are using a one-line definition in commands that you want replaced, since this won't be able to detect commands that are defined in multiple lines in 'LaTeX'.
</p>
<p>Also, note how certain invalid things in 'LaTeX' would still be matched by this regex,
however you should find those errors before you start using this program since those errors would not allow you to compile the 'LaTeX' document on the first place.
</p>
<p>Lastly, if it doesn't find a command on the document, it silently ignores it.
</p>


<h3>Value</h3>

<p>A character vector, with the preamble, replacing all instances of
<code> \newcommand\commandName{&lt;random text&gt;}</code> with
<code> \newcommand\commandName{commandValue}</code>
</p>


<h3>See Also</h3>

<p>Other Preamble adjustment: 
<code><a href="#topic+ReplaceFromTable">ReplaceFromTable</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new_preamble &lt;- ReplacePreambleCommand( TexExamRandomizer::testdoc$preamble, "nickname", "Alex")
</code></pre>

<hr>
<h2 id='StructureDocument'>Structure Document</h2><span id='topic+StructureDocument'></span>

<h3>Description</h3>

<p>Function that takes a character vector, <code>x</code>, representing a 'LaTeX' file and it outputs a tree structure with the structure specified by <code>layersNames</code> and <code>layersCmd</code>.
</p>
<p>It assumes <code>x</code> is representing a 'LaTeX' file that can has been checked it compiles apropitaly before we make anymodification.
</p>
<p>Note however that this function only moves lines around, it doesn't split a line in two.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StructureDocument(x, layersNames, layersCmd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="StructureDocument_+3A_x">x</code></td>
<td>
<p>A character vector, each element represents one line of the latex document</p>
</td></tr>
<tr><td><code id="StructureDocument_+3A_layersnames">layersNames</code></td>
<td>
<p>A character vector, with each element representating the environment name to be searched as <code>cmdName</code> as describe in <code><a href="#topic+FindBegin">FindBegin</a></code> and <code><a href="#topic+FindEnd">FindEnd</a></code></p>
</td></tr>
<tr><td><code id="StructureDocument_+3A_layerscmd">layersCmd</code></td>
<td>
<p>A character vector, with the same length as <code>layersNames</code>. with each element representing the environment command to be serached as <code>cmdName</code> as described in <code><a href="#topic+FindCommand">FindCommand</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both <code>layersNames</code> and <code>layersCmd</code> must have the same length, since for each index, <code>i</code>, <code>layersNames[i]</code> and <code>layersCmd[i]</code> refer to one layer of the tree structure of the document. Consequent layers must be found inside previous layers.
</p>
<p>If it finds the structure of the document to not be completed, it will throw an error.
</p>


<h3>Value</h3>

<p>It returns a list, with each element having a name. Recreating the tree structure identified by  <code>layersNames</code> and <code>layersCmd</code> in the text file <code>x</code>.
</p>
<p>It first divides the document into two lists:
</p>

<dl>
<dt>preamble</dt><dd><p>Contains a character vector identifying everything before the \begin{document}</p>
</dd>
<dt>document</dt><dd><p>Contains the tree structure identifying the document</p>
</dd>
</dl>

<p>Now, the naming convention for each layer of the document is as follows. We will use the convention <code>&lt;layerName&gt;</code>,  <code>&lt;layerCmd&gt;</code>.
</p>
<p>Note the convention first, everything that it finds prior to the first environment, it throws it into a character vector that it calls <code>prior_to_&lt;layesName&gt;</code>.
After the first environment <code>&lt;layerName&gt;</code> ends, it assumes that everything from that <code>\end{&lt;layerName&gt;}</code> onwards corresponding to the next environment, and it will throw it to the prior part of that one.
<code>post_to_&lt;layerName&gt;</code>
</p>

<dl>
<dt><code>prior_to_layersName</code></dt><dd><p>Includes everything up to the first <code>\begin{&lt;layerName&gt;</code> without including that line</p>
</dd>
<dt><code>1_&lt;layerName&gt;_begin_&lt;layerName&gt;</code></dt><dd>
<p>Includes the <code>\begin{layerName}</code> for the 1st section, and everything until it finds the first <code>\&lt;layerCmd&gt;</code></p>
</dd>
<dt><code>1_&lt;layerName&gt;_1_&lt;layerCmd&gt;</code></dt><dd>
<p>Includes everything from the 1<code class="reqn">^{st}</code> <code>\&lt;layerCmd&gt;</code> until the second <code>\&lt;layerCmd&gt;</code>, without including the line in which the second command is found
</p>
</dd>
<dt><code>1_&lt;layerName&gt;_2_&lt;layerCmd&gt;</code></dt><dd>
<p>Same thing... and it keeps going until the last  <code>\&lt;layerCmd&gt;</code> is found
</p>
</dd>
<dt><code>1_&lt;layerName&gt;_end_&lt;layerName&gt;</code></dt><dd>
<p>It includes the <code>\end{&lt;layerName&gt;}</code> for the 1st section.
</p>
</dd>
<dt>...</dt><dd>
<p>It then repeats the same structure for the next environment, changing the naming convention to start with 2_&lt;...&gt; and so on until it does the last environemt</p>
</dd>
<dt><code>post_to_&lt;layerName&gt;</code></dt><dd>
<p>After the last layer ends with <code>\end{layerName}</code>, it throws the rest of the lines into this last character vector</p>
</dd>
</dl>

<p>This structure is applied recursively to each <code>i_&lt;layerName&gt;_j_&lt;layerCmd&gt;</code> of the previous layer to find the structure for the next layer.
The result is a tree of lists, with names that identify the whole structure, and the ending node of each branch is always a character vector
</p>
<p><strong>IMPORTANT NOTE:</strong> Note that this function only rearranges the lines of the document, it can't split a document between a line. So if you want to make sure something always stays together, put them both in the same line. This is intentional, to force a more clear structure on the document that will be parsed
</p>
<p>In Summary, the sketch of the tree structure would be:
</p>

<ul>
<li><p> preamble
</p>
</li>
<li><p> Document
</p>

<ul>
<li><p> prior_to_LayerName[1]
</p>
</li>
<li><p> 1_layerName[1]_begin_layerName[1]
</p>
</li>
<li><p> 1_layerName[1]_1_layerCmd[1]
</p>

<ul>
<li><p> prior_to_LayerName[2]
</p>
</li>
<li><p> 1_layerName[2]_begin_layerName[2]
</p>
</li>
<li><p> 1_layerName[2]_1_layerCmd[2]
</p>

<ul>
<li><p> Continues...
</p>
</li></ul>

</li>
<li><p> 1_layerName[2]_2_layerCmd[2]
</p>

<ul>
<li><p> Continues...
</p>
</li></ul>

</li>
<li><p> ...
</p>
</li>
<li><p>  post_to_layerName[2]
</p>
</li></ul>

</li>
<li><p> 2_layerName[1]_begin_layerName[1]
</p>
</li>
<li><p> 2_layerName[1]_1_layerCmd[1]
</p>

<ul>
<li><p> ...
</p>
</li></ul>

</li>
<li><p> ...
</p>
</li>
<li><p> n_layerName[1]_end_layerName[1]
</p>
</li>
<li><p>  post_to_layerName[1]
</p>
</li></ul>

</li></ul>

<p>If a  <code>\&lt;layerCmd&gt;</code> is not found inside an environment, everything inside that environment is thrown into the begin_layerName part and instead of the numbered environments, an empty character list is added in the middle, with name <code>empty_&lt;layerCmd&gt;</code> section.
</p>


<h3>See Also</h3>

<p><a href="#topic+FindStructure">FindStructure</a> for more information on the details of how the layers are found.
</p>
<p>Other Structuring Document: 
<code><a href="#topic+CompileDocument">CompileDocument</a>()</code>,
<code><a href="#topic+DivideFile">DivideFile</a>()</code>,
<code><a href="#topic+FindStructure">FindStructure</a></code>,
<code><a href="#topic+IsWellSectioned">IsWellSectioned</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- system.file(
    "extdata",
    "ExampleTexDocuments",
    "exam_testing_jsonparser.tex",
    package = "TexExamRandomizer"
)
x &lt;- readLines(file)
layersNames &lt;- c("questions", "choices")
layersCmd &lt;- c("question", "(choice|CorrectChoice)")
doc &lt;- StructureDocument(x, layersNames, layersCmd)
</code></pre>

<hr>
<h2 id='SubsetWithAtributes'>Subsetting Document</h2><span id='topic+SubsetWithAtributes'></span>

<h3>Description</h3>

<p>If you use a function such as A[vector], it only preserves the names attribute, it doesn't preserve any other attribute. This Function attempts to &quot;fix&quot; that manually, for lack of a better solution, instead of using S3 classes. Therefore, it can be used with other documents.
</p>
<p>It subsets the attributes that have the same length as the Document itself and preserve all other attributes with length 0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SubsetWithAtributes(Document, vector)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SubsetWithAtributes_+3A_document">Document</code></td>
<td>
<p>Document that we want to subset</p>
</td></tr>
<tr><td><code id="SubsetWithAtributes_+3A_vector">vector</code></td>
<td>
<p>The vector that provides the subsetting, like <code>`[`</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although this function was created with documents in mind, it can work with any R array that holds attributes and has a subsetting <code>`[`</code> function call.
</p>

<hr>
<h2 id='testclass'>Sample class table</h2><span id='topic+testclass'></span>

<h3>Description</h3>

<p>Sample class for testing with five students. The variables stored for each student are as follows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testclass
</code></pre>


<h3>Format</h3>

<p>A dataframe with 5 rows and 4 columns
</p>


<h3>Details</h3>


<ul>
<li><p> Class
</p>
</li>
<li><p> Roll.Number
</p>
</li>
<li><p> Nickname
</p>
</li>
<li><p> Name
</p>
</li></ul>



<h3>Source</h3>

<p>self
</p>

<hr>
<h2 id='testdoc'>Test document</h2><span id='topic+testdoc'></span>

<h3>Description</h3>

<p>A simple sample TeX document to test the package easily before deploying solutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testdoc
</code></pre>


<h3>Format</h3>

<p>A list with the format described in <code><a href="#topic+StructureDocument">StructureDocument</a></code>
</p>


<h3>Source</h3>

<p>Created between me and my students in Suankularbwittayalai Rangsit School
</p>

<hr>
<h2 id='WhichAnswerOriginal'>WhichAnswerOriginal</h2><span id='topic+WhichAnswerOriginal'></span>

<h3>Description</h3>

<p>Given the answers of the students gathered in a table, and a full answer sheet of all versions (Including a &quot;reference/original&quot; version), it finds where those answers are found in the original exam, by copying from the original version the matching rows and binding them in order for every student. It then combines all of them in a list, and includes as well all the remaining student information in the attribute &quot;StudentInfo&quot;.
</p>
<p>It is intended as an internal function to generate the grades, and to identify in a very general way where the answers of the students are (relative to the reference/original version).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WhichAnswerOriginal(
  StudentAnswers,
  FullExamAnswerSheet,
  OriginalExamVersion = 0,
  names.FullExamVersion = "Version",
  names.FullExamOriginalCols,
  names.CorrectAndIncorrectCols,
  names.StudentAnswerQCols,
  names.StudentAnswerExamVersion
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WhichAnswerOriginal_+3A_studentanswers">StudentAnswers</code></td>
<td>
<p>DataFrame, each row is a student, each column is some information about said student. Any column not included in <code>names.StudentAnswerQCols</code> will be understood as information of the student and will be saved as part of the information table when we output the result.</p>
</td></tr>
<tr><td><code id="WhichAnswerOriginal_+3A_fullexamanswersheet">FullExamAnswerSheet</code></td>
<td>
<p>Answer sheet of all the exam versions, following the conventions of the <code>FullAnswerSheet</code> outputted by <code><a href="#topic+CreateRandomExams">CreateRandomExams</a></code></p>
</td></tr>
<tr><td><code id="WhichAnswerOriginal_+3A_originalexamversion">OriginalExamVersion</code></td>
<td>
<p>The version of the original exam, without randomization, as stored on the <code>FullExamAnswerSheet</code>. The default value is <code>0</code>, as that is the convention on <code><a href="#topic+CreateRandomExams">CreateRandomExams</a></code></p>
</td></tr>
<tr><td><code id="WhichAnswerOriginal_+3A_names.fullexamversion">names.FullExamVersion</code></td>
<td>
<p>The name of the column in which the version of the exam is stored on the <code>FullExamAnswerSheet</code>. The default value is &quot;<code>Version</code>&quot;, as that is the convention on <code><a href="#topic+CreateRandomExams">CreateRandomExams</a></code></p>
</td></tr>
<tr><td><code id="WhichAnswerOriginal_+3A_names.fullexamoriginalcols">names.FullExamOriginalCols</code></td>
<td>
<p>The names of the columns that contain the information of the items relative to where they were positioned in the original ordering of the exam, before randomizing the exam. The convention from <code><a href="#topic+CreateRandomExams">CreateRandomExams</a></code> is to finish all of them by  &quot;<code>_original</code>&quot;.</p>
</td></tr>
<tr><td><code id="WhichAnswerOriginal_+3A_names.correctandincorrectcols">names.CorrectAndIncorrectCols</code></td>
<td>
<p>It should be a character vector. The names of the columns in the <code>FullExamAnswerSheet</code> that contain the correct and incorrect answers, in that order. This column should have an integer value if it is indeed a correct value in the correct column and a incorrect value in the incorrect value, and <code>NA</code> otherwise. (The should be &quot;complementary&quot;)</p>
</td></tr>
<tr><td><code id="WhichAnswerOriginal_+3A_names.studentanswerqcols">names.StudentAnswerQCols</code></td>
<td>
<p>The names in the <code>StudentAnswers</code> that store the answers from every student to the exam, ordered. These columns should contain integers values. Where 1 refers to the first answer, and n refers to the nth answers in <strong>their exam</strong>.</p>
</td></tr>
<tr><td><code id="WhichAnswerOriginal_+3A_names.studentanswerexamversion">names.StudentAnswerExamVersion</code></td>
<td>
<p>The name of the column in the <code>StudentAnswers</code> that identifies the version of the exam</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>StudentAnswers</code> should be a data frame with one student answers represented by every row. The answers of the student to the exam should be ordered.
</p>
<p>It is important that the colums named <code>names.StudentAnswerQCols</code> should contain all their answers, if a student didn't answer a question leave a <code>NA</code> or an invalid integer value as an answer, like 0, or a number larger than the number of answers to that question, so that is is found as out of bounds.
</p>


<h3>Value</h3>

<p>It returns a list. Each element of the list is a dataframe, and there is one dataframe for each student in the <code>StudentInfo</code> table provided.
</p>
<p>All the columns that are not in the columns <code>names.StudentAnswerQCols</code>  are regarded as &quot;<code>StudentInfo</code>&quot;, and they are added to the attribute &quot;<code>StudentInfo</code>&quot; of the output as a data frame.
</p>

<dl>
<dt>List elements:</dt><dd>
<p>They are outputted in order, that is to say, for <code>StudentAnswers[i,]</code> the list that provides the information for that row will be <code>outputlist[[i]]</code>.
</p>
<p><code>outputlist[[i]]</code> is a dataframe that identifies the rows that the student answered as they are found on the original/reference version. Therefore, if a student answeres a certain value, and that value is not reflected on the original version, it get's ignored.
</p>
</dd>
<dt><code>StudentInfo</code> attribute</dt><dd><p>A dataframe containing all the student information that wasn't their answers.</p>
</dd>
</dl>



<h3>Underlying algorithm</h3>

<p>To identify the rows on the original exam it does the following:
</p>

<ol>
<li><p> It first finds their exam in the full answer sheet by their exam version.
</p>
</li>
<li><p> After that, it  removes from their exam the rows that identify the correct/incorrect choices.
</p>
</li>
<li><p> By trying to match that row with a row on the reference exam it can tell where that quesiton is found on the original exam.
</p>
</li>
<li><p>  Then it identifies where that question is found on the original version, and it finds there which of the possible correct/incorrect choices is found.
</p>
</li>
<li><p> If it didn't find any correct/incorrect choice matching the value given by the student, it marks it as out of bounds and replaces both correct and incorrect columns with <code>NA</code>.
</p>
</li>
<li><p> If it still doesn't find the row, it simply ignores it, and the output will have one less row.
</p>
</li>
<li><p> Now you can tell how many questions the student answered correctly by looking at how many values are not NA in the correct choice column of the output list.
</p>
</li></ol>



<h3>Removing Questions from the exam</h3>

<p>Note that if after creating the exam, you found that a question is bugged and can't be used to grade the exam, all you have to do is tell the student to answer &quot;something&quot; and you only have to remove it from the original/reference version in the Full Answer Sheet. When you apply the grading function, that question will then be ignored.
</p>
<p>Notice how this creates output lists with different lengths in the case that two students didn't have that same question in their exam.
</p>
<p>For example, if a exam has 15 questions out of a 50 question document. If student A has a bugged question and student B doesn't, the answer sheet produced for student A will have 14 rows while the one for student B will have 15 rows.
</p>


<h3>Notes</h3>

<p><strong>Note1:</strong> Remember that in the original answer sheet there are two columns, one with correctchoice, another one with wrong choice. If the value is NA of one of those two columns it SHOULD NOT be NA on the other row.
</p>
<p><strong>Note2:</strong>  The idea is that the data frames can be read to know the score of the student by counting the number of values that are not NAs on the correct choice column. (The numbers on the correct/incorrect columns themselves can be used for statistical purposes, to tell how many students answered each question).
</p>
<p><strong>Note3:</strong> The data frames can be used for many other statistical purposes very easily.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GradeExams">GradeExams</a></code> and <code><a href="#topic+ObtainExamStats">ObtainExamStats</a></code> for examples on how to use the output of this function to obtain more detailed information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

asheet_file &lt;-
    system.file(
        "extdata",
        "ExampleTables",
        "ExampleAnswerSheet.csv",
        package = "TexExamRandomizer")
responses_file &lt;-
    system.file(
        "extdata",
        "ExampleTables",
        "ExampleResponses.csv",
        package = "TexExamRandomizer")
FullAnswerSheet &lt;-
    read.csv(
        asheet_file,
        header = TRUE,
        stringsAsFactors = FALSE,
        na.strings = c("", "NA", "Na"),
        strip.white = TRUE)
Responses &lt;- read.csv(
    responses_file,
    header = TRUE,
    stringsAsFactors = FALSE,
    na.strings = c("", "NA", "Na"),
    strip.white = TRUE)
compiledanswers &lt;-
    WhichAnswerOriginal(
        StudentAnswers = Responses,
        FullExamAnswerSheet = FullAnswerSheet,
        names.StudentAnswerQCols = grep(
            names(Responses),
            pattern = "^Q.*[[:digit:]]",
            value = TRUE),
        names.StudentAnswerExamVersion = grep(
            names(Responses),
            pattern = "Version",
            value = TRUE),
        OriginalExamVersion = 0,
        names.FullExamVersion = "Version",
        names.FullExamOriginalCols = grep(
            names(FullAnswerSheet),
            pattern = "_original",
             value = TRUE),
        names.CorrectAndIncorrectCols = c(
            "choice",
            "CorrectChoice")
    )
nicknames &lt;- attr(compiledanswers, "StudentInfo")$Nickname

for (i in 1:length(compiledanswers)) {
    cat("Student\t", nicknames[i], " got\t",
        sum(!is.na(compiledanswers[[i]]$CorrectChoice)),
        " questions correctly\n", sep = "")
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
