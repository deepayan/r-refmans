<!DOCTYPE html><html lang="en-US"><head><title>Help for package frscore</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {frscore}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#frscore-package'><p>frscore: Functions for Calculating Fit-Robustness of CNA-Solutions</p></a></li>
<li><a href='#causal_submodel'><p>Determine if a model is a causal submodel of another model</p></a></li>
<li><a href='#d.error'><p>Simulated data of sixteen cases with measurement error in one case</p></a></li>
<li><a href='#frscore'><p>frscore</p></a></li>
<li><a href='#frscored_cna'><p>frscored_cna</p></a></li>
<li><a href='#rean_cna'><p>rean_cna</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Functions for Calculating Fit-Robustness of CNA-Solutions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for automatically performing 
             a reanalysis series
             on a data set using CNA, and for calculating the fit-robustness
             of the resulting models, as described in 
             Parkkinen and Baumgartner (2021) &lt;<a href="https://doi.org/10.1177%2F0049124120986200">doi:10.1177/0049124120986200</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, Rfast, magrittr, rlang, withr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), cna (&ge; 3.5.1), lifecycle (&ge; 1.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spelling, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-11 11:42:00 UTC; lbl</td>
</tr>
<tr>
<td>Author:</td>
<td>Veli-Pekka Parkkinen [aut, cre, cph],
  Michael Baumgartner [aut, cph],
  Mathias Ambuehl [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Veli-Pekka Parkkinen &lt;parkkinenv@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-11 12:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='frscore-package'>frscore: Functions for Calculating Fit-Robustness of CNA-Solutions</h2><span id='topic+frscore-package'></span>

<h3>Description</h3>

<p>Functions for automatically performing a reanalysis series on a data set using CNA, and for calculating the fit-robustness of the resulting models, as described in Parkkinen and Baumgartner (2021) <a href="https://doi.org/10.1177/0049124120986200">doi:10.1177/0049124120986200</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Veli-Pekka Parkkinen <a href="mailto:parkkinenv@gmail.com">parkkinenv@gmail.com</a> [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Michael Baumgartner <a href="mailto:michael.baumgartner@uib.no">michael.baumgartner@uib.no</a> [copyright holder]
</p>
</li>
<li><p> Mathias Ambuehl [copyright holder]
</p>
</li></ul>


<hr>
<h2 id='causal_submodel'>Determine if a model is a causal submodel of another model</h2><span id='topic+causal_submodel'></span>

<h3>Description</h3>

<p>Determine whether the causal relevance ascriptions made by
<em>candidate</em> solution/model <code>x</code> are contained in the causal
relevance ascriptions made by <em>target</em> model <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>causal_submodel(x, y, dat = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="causal_submodel_+3A_x">x</code></td>
<td>
<p>A string that specifies a valid <code>cna</code> model.</p>
</td></tr>
<tr><td><code id="causal_submodel_+3A_y">y</code></td>
<td>
<p>A string that specifies a valid <code>cna</code> model.</p>
</td></tr>
<tr><td><code id="causal_submodel_+3A_dat">dat</code></td>
<td>
<p>A <code>configTable</code>, a data frame, a matrix, or a list that
specifies the range of admissible factor values for the factors featured in
<code>x</code> and <code>y</code>. Only needed when the models <code>x</code> and <code>y</code> are
multi-valued, otherwise ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>causal_submodel()</code> checks whether the causal relevance claims
made by the candidate model <code>x</code> are contained within the causal
relevance claims made by the target model <code>y</code>. When <code>x</code> and
<code>y</code> are multi-valued models, a further argument <code>dat</code> must be
provided to determine the admissible factor values for the factors featured
in <code>x</code> and <code>y</code>. This would typically be the data set that <code>x</code>
and <code>y</code> were inferred from. <code>causal_submodel()</code> is similar to, and
based on <code><a href="cna.html#topic+is.submodel">is.submodel()</a></code> from the
<code><a href="cna.html#topic+cna-package">cna</a></code> package, with one important difference.
<code><a href="cna.html#topic+is.submodel">is.submodel()</a></code> checks whether a model is a syntactic
submodel of another, and can thus be used to check whether all syntactically
explicit causal ascriptions, i.e. claims about direct causation only, of one
model are contained in another. <code>causal_submodel()</code> checks if <em>all</em> causal
<em>relevance</em> claims made by <code>x</code>, i.e. claims of either direct or indirect
causation, have a counterpart causal relevance ascription in <code>y</code>. In case
when all causal relevance claims of <code>x</code> have a suitable (see below)
counterpart in <code>y</code>, <code>x</code> is a <em>causal</em> submodel of <code>y</code>.
</p>
<p>For <code>x</code> to be causal submodel of <code>y</code>, (1), every ascription of
direct causal relevance made by <code>x</code> must either have a counterpart
direct causal ascription in <code>y</code>, or a counterpart indirect causal
ascription in <code>y</code> such that <code>x</code> omits any factors that mediate the
relation according to <code>y</code>. (2), every ascription of indirect causal
relevance made by <code>x</code> must have a counterpart indirect causal
ascription in <code>y</code>. That is, every pair of factors represented as direct
cause and effect in <code>x</code> must either be represented as direct cause and
effect in <code>y</code>, or be connected by a transitive chain of direct causal
relations according to <code>y</code>. In the latter case, <code>x</code> must in addition
omit the factors that according to <code>y</code> mediate the causal relation in
question. Direct causal relations are those causal relations that can be
read off from the explicit syntax of an atomic solution/model (&quot;asf&quot;). For
example, according to <code>A*F+B&lt;-&gt;C</code>, <code>A</code> and <code>B</code> are direct
causes of <code>C</code> on alternative paths. Furthermore, candidate model
<code>A+B&lt;-&gt;C</code> is a causal submodel of the target <code>A*F+B&lt;-&gt;C</code>, but
<code>A+B*U&lt;-&gt;C</code> is not, since the latter makes a claim about the causal
relevance of <code>U</code> to <code>C</code> which is not made by the target. Each
direct cause is a difference-maker for its effect in some circumstances
where alternative sufficient causes of the effect are not present, and the
<em>co-factors</em> located on the same path are present. For example,
<code>A*F+B&lt;-&gt;C</code> claims that when <code>B</code> is absent and <code>F</code> is
present, difference in the presence of <code>A</code> will associate with
differences in <code>C</code>, given some suitable configuration of factors not
explicitly represented in <code>A*F+B&lt;-&gt;C</code>. When both <code>x</code> and <code>y</code>
are asfs, i.e. represent direct causal relations only, <code>x</code> is a causal
submodel of <code>y</code> if, and only if <code>x</code> is is a <a href="cna.html#topic+is.submodel">syntactic submodel</a> of <code>y</code>, as the syntax of an asf is such
that every causal ascription is explicitly represented.
</p>
<p>Judgments of direct vs. indirect causation are relative to the set of
factors included in a model. <code style="white-space: pre;">&#8288;A+B&lt;-&gt;E&#8288;</code> describes <code>A</code> and <code>B</code> as direct
causes of <code>E</code>, but another model that includes additional factors besides
<code style="white-space: pre;">&#8288;{A,B,E}&#8288;</code> might describe these causal relations as causal chains that
include intermediate steps, as in <code>(A+B&lt;-&gt;C)*(C+D&lt;-&gt;E)</code>. <code style="white-space: pre;">&#8288;A+B&lt;-&gt;E&#8288;</code>
makes no claim that would contradict the chain model; it merely says that
<em>relative</em> to the factor set <code style="white-space: pre;">&#8288;{A,B,E}&#8288;</code>, the factors are causally ordered so
that <code>A</code> and <code>B</code> are causes of <code>E</code>, and there is no causal relation between
<code>A</code> and <code>B</code>. Causal order refers to the ordering of the factors by the
relation of direct causation that determines what is causally &quot;upstream&quot; and
&quot;downstream&quot; of what. The exogenous factors <code style="white-space: pre;">&#8288;{A,B,D}&#8288;</code> are top-level upstream
causes in <code>(A+B&lt;-&gt;C)*(C+D&lt;-&gt;E)</code>, as they are not caused by any other
factor included in the model. Endogenous factors <code>C</code> and <code>E</code> are downstream
of of <code style="white-space: pre;">&#8288;{A,B}&#8288;</code> by one and two levels respectively, and <code>E</code> is one level
downstream of <code>D</code>. The chain model agrees with the direct cause model on the
causal ordering of <code style="white-space: pre;">&#8288;{A,B,E}&#8288;</code> &ndash; <code>A</code> and <code>B</code> are upstream of <code>E</code> and not
causes of each other &ndash; but also includes an additional cause of <code>E</code>, <code>C</code>,
that is ordered between <code style="white-space: pre;">&#8288;{A,B}&#8288;</code> and <code>E</code> along a chain of direct causal
relations. <code>(A+B&lt;-&gt;C)*(C+D&lt;-&gt;E)</code> represents a <em>transitive</em> causal
chain where <code>A</code> and <code>B</code> are indirectly causally relevant for
<code>E</code> in virtue of being causes of <code>E</code>'s more proximate cause
<code>C</code> and the difference-making ability they have on <code>E</code> via
<code>C</code>. <code>A+B&lt;-&gt;E</code> is a causal submodel of <code>(A+B&lt;-&gt;C)*(C+D&lt;-&gt;E)</code>,
as the models agree on the causal relevance ascriptions over <code style="white-space: pre;">&#8288;{A,B,E}&#8288;</code>, and
the former makes no claims whatsoever about the additional factors <code style="white-space: pre;">&#8288;{C,D}&#8288;</code>
included in the latter model. Both models can be seen as descriptions of the
same causal structure, one more complete in detail than the other. An
<em>in</em>transitive chain is a causal chain where the influence of some
upstream causes is not transmitted to some downstream effects. For example,
<code>(A+B&lt;-&gt;C)*(C*a+D&lt;-&gt;E)</code> represents a chain where <code>A</code> is not
causally relevant to <code>E</code> despite being a cause of one of <code>E</code>'s
direct causes (<code>C</code>). That is, according to this model, <code>A</code> is not
a difference-maker for <code>E</code>, and <code>A+B&lt;-&gt;E</code>, which makes this claim,
is not its causal submodel.
</p>
<p>Besides avoiding causal relevance ascriptions that are not present in the
target at all, the candidate should also attribute causal relevance
correctly in the sense of causally ordering the represented causes in a way
that is compatible with the target. Factors that appear as direct causes of
the same outcome both in the target and the candidate should be grouped into
alternative disjuncts similarly in both. Analogously, causes that appear on
different levels in a causal chain according to the target should not be
represented as same-level causes by the candidate. Say, for example, that
the target is <code>(A+B&lt;-&gt;C)*(C+D&lt;-&gt;E)*(E+F&lt;-&gt;G)</code>. Candidate models
<code>(A+B&lt;-&gt;G)</code> and <code>(A+B&lt;-&gt;E)*(E+F&lt;-&gt;G)</code> are both causal submodels of
this target. By contrast, neither of <code>(A+C&lt;-&gt;G)</code> and
<code>(A+B&lt;-&gt;C)*(C+E&lt;-&gt;G)</code> is a causal submodel of the target. Both of the
latter two models commit the error of representing as same-level causes
factors that the target represents as cause and effect. For example,
<code>(A+C&lt;-&gt;G)</code> claims that <code>A</code> and <code>C</code> are same-level causes of
<code>G</code>, whereas the target says <code>A</code> is a cause of <code>C</code>. In other
words, relative to a factor set that include <code>C</code>, the candidate claims that
<code>A</code> is a direct cause of <code>E</code>, which is false according to the target. It is
instructive to consider the difference in implications for
difference-making: <code>(A+C&lt;-&gt;G)</code> claims that differences in <code>A</code>
associate with differences in <code>G</code> when <code>C</code> is fixed absent, but
the target claims that this is impossible.
</p>
<p>Finally, a causal submodel relation requires that any claims of indirect
causal relevance made by a candidate model are claims made by the target
also. Consider the target model <code>(A+B*D&lt;-&gt;C)*(C+D&lt;-&gt;G)</code> and a candidate
<code>(A+B*D&lt;-&gt;C)*(C&lt;-&gt;G)</code>. Despite superficial similarity (the candidate is
a syntactic submodel of the target), the candidate is not a causal submodel
of the target. Namely, the candidate makes a claim that <code>B</code> is
indirectly causally relevant for <code>G</code>, a claim that is not made by the
target. Again, it is best to examine the specific difference-making claim in
question. The candidate model claims that differences in <code>B</code> make a
difference to the presence of <code>G</code> when <code>D</code> is fixed to be present.
But this is false according to the target. The target claims that <code>G</code>
is always present whenever <code>D</code> is: <code>B</code> is not causally relevant
for <code>G</code> despite being a cause of an intermediary factor <code>C</code>.
</p>
<p>In its implementation, <code>causal_submodel()</code> relies on the fact that when
both the target and candidate are asfs, a syntactic submodel relation that
can be verified with <code><a href="cna.html#topic+is.submodel">is.submodel()</a></code> is a necessary and
sufficient condition for causal submodel relation. If both the candidate and
the target are asfs, a check for syntactic submodel relation is performed,
and the result returned. When the target, or both the target and candidate
comprise more than one asf, the process is more complicated. First,
<code>causal_submodel()</code> checks if the component asfs of the candidate are
syntactic submodels of the target <em>as is</em>. If yes for all, each of the
candidate's direct causal relevance ascriptions is contained in the target,
and the function proceeds to the second phase. For those direct causal
relations that are not contained in the target, the function searches for
counterpart indirect relations in the target. Since <code>cna</code> models do not
represent indirect relations explicitly, these are explicated by
syntactically manipulating the target. This involves finding asfs in the
target with the same outcomes as those candidate asfs that are not syntactic
submodels of the target <em>as is</em>. For each such component asf of the
target, factors in the disjunction on the left hand side of the equivalence
sign (&quot;&lt;-&gt;&quot;) are substituted with the disjunctions, if any, that according
to the target represent their causes. The resulting expression is then
minimized to render it causally interpretable. What is left is an asf
representing some of the target's indirect causal claims as direct causal
claims. Then, the candidate asfs that are not syntactic submodels of the
target <em>as is</em> are tested against the manipulated target asfs for
syntactic submodel relation. This process is repeated until all the submodel
checks return <code>TRUE</code>, or no further substitutions are possible. In the
former case, the function proceeds to the second phase. In the latter case,
the candidate is deemed not to be a causal submodel of the target, and the
function returns <code>FALSE</code>.
</p>
<p>An example is in order to illustrate the procedure so far. Say that the
target and candidate are <code>(A+B&lt;-&gt;C)*(C+D&lt;-&gt;E)</code> and <code>A+B&lt;-&gt;E</code>,
respectively. Since the sole candidate asf is not a syntactic submodel of
the target, one then attempts to find indirect causal relevance ascriptions
in the target to license the direct causal claims made by the candidate asf.
By the procedure described above, one focuses on the second asf of the
target, <code>C+D&lt;-&gt;E</code>, and seeks to syntactically manipulate that until it
is transformed into a syntactic supermodel of <code>A+B&lt;-&gt;E</code>, or until no
transformation is possible. According to the first component asf of the
target, <code>C</code> is equivalent to (caused by) <code>A+B</code>. Hence, <code>C</code> in
<code>C+D&lt;-&gt;E</code> can be replaced with <code>A+B</code>, which yields
<code>(A+B)+D&lt;-&gt;E</code>, reducing simply to <code>A+B+D&lt;-&gt;E</code>. Since
<code>A+B&lt;-&gt;E</code> is a syntactic submodel of <code>A+B+D&lt;-&gt;E</code>, we have shown
that the causal relevance claims made by the candidate are contained in the
target.
</p>
<p>The purpose of the second phase is to check that all indirect causal claims
made by the <em>candidate</em> model have a counterpart in the target. This
involves doing all the substitutions of left-hand side factors by their
causes in the candidate model, to generate expressions that explicitly
represent the indirect claims of the candidate. The asfs generated by such
manipulations of the candidate model are then tested for causal
compatibility with the target, following the exact same procedure described
above. For example, say that <code>(A+B*D&lt;-&gt;C)*(C+D&lt;-&gt;G)</code> and
<code>(A+B*D&lt;-&gt;C)*(C&lt;-&gt;G)</code> are the target and the candidate, respectively.
Here, each candidate asf <code>A+B*D&lt;-&gt;C</code> and <code>C&lt;-&gt;G</code> has a supermodel
in one of the target asfs <code>A+B*D&lt;-&gt;C</code> and <code>C+D&lt;-&gt;G</code>, i.e. each
direct causal claim of the candidate has a counterpart direct causal claim
in the target, and the function proceeds to the second phase. In the second
phase, the indirect causal claims of the candidate are first made explicit.
By substituting <code>A+B*D</code> in place of <code>C</code> in the second asf of the
candidate and minimizing, one gets <code>A+B*D&lt;-&gt;G</code>, which represents the
indirect causal relevance, as claimed by the candidate, of <code>A+B*D</code> on
<code>G</code>. This expression is then tested against the target as in the first
phase: the target asf with <code>G</code> as the outcome is manipulated to reflect
the indirect claims that the target makes about <code>G</code>, based on what the
target says about the indirect causes of <code>G</code>. After substitution and
minimization, we get <code>A+D&lt;-&gt;G</code>, meaning that the target does <em>not</em>
make a claim of indirect causal relevance of <code>B</code> for <code>G</code>. That the
candidate's indirect causal ascriptions are not contained in the target is
shown by the fact that <code>A+B*D&lt;-&gt;G</code> is not a syntactic submodel of
<code>A+D&lt;-&gt;G</code>, and the function returns <code>FALSE</code>.
</p>
<p>Due to the computational demands of some of the steps in the above
procedure, <code>causal_submodel()</code> is an approximation of a strictly
speaking valid check for causal submodel relations. Since the syntactic
manipulations and especially the minimization of the resulting expressions
is so costly, <code>causal_submodel()</code> relies on the
<code><a href="cna.html#topic+rreduce">rreduce()</a></code> function from the <code><a href="cna.html#topic+cna-package">cna</a></code>
package for minimization. <code><a href="cna.html#topic+rreduce">rreduce()</a></code> randomly chooses a
single reduction path to produce only one minimal form of an expression
whenever more than one exists, i.e. when the expression is ambiguous in its
causal claims. In the case of ambiguous models, the output of
<code>causal_submodel()</code> may depend on which reduction path(s) were chosen.
These cases are rare enough to not significantly affect the intended use of
<code>causal_submodel()</code> in the context of <code>frscore</code>. Another instance of
<code>causal_submodel()</code> taking a shortcut is when processing cyclic models
like <code>(A+B&lt;-&gt;C)*(C+D&lt;-&gt;A)</code>. Here the problems are as much philosophical
as computational. It is clear that a cyclic candidate model cannot be a
causal submodel of a non-cyclic target. However, problems arise when testing
a non-cyclic candidate against a cyclic target: it is not clear what counts
as an incompatibility in causal ordering, given that a cyclic target model
includes factors that are causally relevant for themselves. Since many
conclusions can be argued for here but some approach must be taken to ensure
that <code>causal_submodel()</code> works on all valid <code>cna</code> models,
<code>causal_submodel()</code> takes the least costly option and simply checks
whether the candidate is a syntactic submodel of the target, and returns the
result.
</p>


<h3>Value</h3>

<p>Named logical.
</p>


<h3>See Also</h3>

<p><code><a href="cna.html#topic+is.submodel">cna::is.submodel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>target &lt;- "(A+B&lt;-&gt;C)*(C+D&lt;-&gt;E)"
candidate1 &lt;- "A+B&lt;-&gt;E"
causal_submodel(candidate1, target) # TRUE
candidate2 &lt;- "A+C&lt;-&gt;E"
causal_submodel(candidate2, target) # FALSE

dat &lt;- cna::d.pban
target_mv &lt;- "C=1 + F=2 + T=1 + C=0*F=1 &lt;-&gt; PB=1"
candidate_mv &lt;- "C=1 + F=2 + T=1 &lt;-&gt; PB=1"
causal_submodel(candidate_mv, target_mv, dat = dat) # mv models require the 'dat' argument

</code></pre>

<hr>
<h2 id='d.error'>Simulated data of sixteen cases with measurement error in one case</h2><span id='topic+d.error'></span>

<h3>Description</h3>

<p>A simulated set of crisp-set configurational data
that conforms to the structure
A + B*C &lt;-&gt; E except for one case, 'c16',
which simulates measurement error in that case,
and including one irrelevant factor &quot;D&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d.error
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 16 rows and 5 columns.
</p>

<hr>
<h2 id='frscore'>frscore</h2><span id='topic+frscore'></span>

<h3>Description</h3>

<p>Calculate fit-robustness scores for a set of <code>cna</code>
solutions/models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frscore(
  sols,
  dat = NULL,
  scoretype = c("full", "supermodel", "submodel"),
  normalize = c("truemax", "idealmax", "none"),
  maxsols = 50,
  verbose = FALSE,
  print.all = FALSE,
  comp.method = c("causal_submodel", "is.submodel")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="frscore_+3A_sols">sols</code></td>
<td>
<p>Character vector of class &quot;stdAtomic&quot; or &quot;stdComplex&quot; (as generated by <code><a href="cna.html#topic+cna">cna()</a></code>) that contains the solutions/models to be scored.</p>
</td></tr>
<tr><td><code id="frscore_+3A_dat">dat</code></td>
<td>
<p>A <code>configTable</code>, a data frame, a matrix, or a list that specifies the range of admissible factor values
for the factors featured in the models included in <code>sols</code>. Only needed when the models in
<code>sols</code> are multi-valued, otherwise ignored.</p>
</td></tr>
<tr><td><code id="frscore_+3A_scoretype">scoretype</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>  String specifying the scoring method: <code>"full"</code>
(default; scoring is based on counting sub- and supermodel relations), <code>"supermodel"</code>
(count supermodels only), <code>"submodel"</code> (count
submodels only). Allowed for backward compatibility only, due to be dropped
in next version.</p>
</td></tr>
<tr><td><code id="frscore_+3A_normalize">normalize</code></td>
<td>
<p>String that determines the method used in
normalizing the scores. <code>"truemax"</code> (default) normalizes by the highest score among the elements of <code>sols</code>,
such that the highest scoring solution types get score 1. <code>"idealmax"</code>
normalizes by a theoretical maximum score (see Details). </p>
</td></tr>
<tr><td><code id="frscore_+3A_maxsols">maxsols</code></td>
<td>
<p>Integer determining the maximum number of unique solution
types found in <code>sols</code> to be included in the scoring (see Details).</p>
</td></tr>
<tr><td><code id="frscore_+3A_verbose">verbose</code></td>
<td>
<p>Logical; if <code>TRUE</code>, additional
information about causal compatibility relations among the unique solution types found
in <code>sols</code> is printed. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="frscore_+3A_print.all">print.all</code></td>
<td>
<p>Logical, controls the number of entries printed when
printing the results. If <code>TRUE</code>, results are printed as when using the defaults of
<code>print.data.frame</code>. If <code>FALSE</code>, 20 highest scoring
solutions/models are printed.</p>
</td></tr>
<tr><td><code id="frscore_+3A_comp.method">comp.method</code></td>
<td>
<p>String that determines how the models in <code>sols</code> are compared
to determine their fr-score. <code>"causal_submodel"</code> (the default) checks for causal submodel relations using <code>causal_submodel()</code>,
<code>"is.submodel"</code> checks for syntactic submodel relations with <code>is.submodel()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>frscore()</code> implements fit-robustness scoring as introduced in Parkkinen and Baumgartner (2021). The function calculates the
fit-robustness scores of Boolean solutions/models output by the <code><a href="cna.html#topic+cna">cna()</a></code> function of the <span class="pkg">cna</span> package. The solutions are given to <code>frscore()</code> as a character vector <code>sols</code> obtained by reanalyzing
a data set repeatedly, e.g. with <code>rean_cna()</code>, using different consistency and coverage
thresholds in each analysis.
</p>
<p>For multi-valued
models, the range of admissible values for the factors featured
in the models must be provided via the argument <code>dat</code>, which accepts a data
frame, <code>configTable</code>, or a list of factor-value ranges as its value,
in the same manner as <code><a href="cna.html#topic+full.ct">cna::full.ct()</a></code>.
Typically, one would use the data set that the models in <code>sols</code>
were inferred from, and this is what is done automatically when
<code>frscore()</code> is called within <code>frscored_cna()</code>. When the models in <code>sols</code>
are binary, <code>dat</code> should be left to its default value <code>NULL</code>,
and will in any case be ignored.
</p>
<p>The argument <code>scoretype</code> is deprecated as of <code>frscore</code> 0.3.1, and will be dropped
in the next version.
Giving it a non-default value
is allowed so that older code can be run without errors, but doing this is otherwise discouraged.
When set to its default value <code>"full"</code>,
the score of each <code>sols[i]</code> is calculated by counting the (either syntactic or
causal) sub- and supermodel relations <code>sols[i]</code> has to the other elements
of <code>sols</code>. Setting scoretype to <code>"supermodel"</code> or <code>"submodel"</code> forces the scoring to be based on,
respectively, supermodel and submodel relations only. Whether causal or syntactic submodel relations
are counted depends on the value of <code>comp.method</code>: <code>"causal_submodel"</code> (default)
counts causal submodel relations using <code><a href="#topic+causal_submodel">causal_submodel()</a></code>,
<code>"is.submodel"</code> counts syntactic submodel relations using <code><a href="cna.html#topic+is.submodel">cna::is.submodel()</a></code>.
In future versions of <code>frscore</code>, fit-robustness
scores will always be calculated as with <code>scoretype = "full"</code>, and
changing this will not be possible. If additional information about the numbers of
sub- vs. supermodel relations a particular model has to other models is needed, this
can be acquired by inspecting the <code>"verbout"</code> element of the output of <code>frscore()</code>.
</p>
<p>The fit-robustness scores can be normalized in two ways. In the default setting <code>normalize = "truemax"</code>, the score of each <code>sols[i]</code> is divided by the maximum score obtained by an element of <code>sols</code>. In case of <code>normalize = "idealmax"</code>, the score is normalized not by an actually obtained
maximum but by an idealized maximum, which is calculated by assuming that all solutions of equal
complexity in <code>sols</code> are identical and that for every <code>sols[i]</code> of a given complexity, all less complex
elements of <code>sols</code> are its submodels and all more complex elements of <code>sols</code> are its supermodels.
When normalization is applied, the normalized score is shown in its own column <code>norm.score</code> in
the results. The raw scores are shown in the column <code>score</code>.
</p>
<p>If the size of the consistency and coverage interval scanned in the reanalysis series generating <code>sols</code> is large or there are many model ambiguities, <code>sols</code> may contain so many different types of solutions/models that robustness cannot be calculated for all of them in reasonable time. In that case, the argument <code>maxsols</code> allows for capping the number of solution types to be included in the scoring (defaults to 50). <code>frscore()</code> then selects the most frequent solutions/models in <code>sols</code> of each complexity level until  <code>maxsols</code> is reached and only scores the thus selected elements of <code>sols</code>.
</p>
<p>If the argument <code>verbose</code> is set to <code>TRUE</code>, <code>frscore()</code> also prints a list indicating for each <code>sols[i]</code> how many raw score points it receives from which elements of <code>sols</code>. The verbose list is ordered with decreasing fit robustness scores.
</p>


<h3>Value</h3>

<p>A named list where the first element is a data frame containing
the unique solution/model types and their scores. Rest of the elements
contain additional information about the submodel relations among
the unique solutions types and about how
the function was called.
</p>


<h3>References</h3>

<p>V.P. Parkkinen and M. Baumgartner (2021), &ldquo;Robustness and Model Selection in Configurational Causal Modeling,&rdquo; <em>Sociological Methods and Research</em>, doi:10.1177/0049124120986200.
</p>
<p>Basurto, Xavier. 2013. &ldquo;Linking Multi-Level Governance to Local Common-Pool
Resource Theory using Fuzzy-Set Qualitative Comparative Analysis: Insights from
Twenty Years of Biodiversity Conservation in Costa Rica.&rdquo; <em>Global Environmental Change</em> <strong>23</strong> (3):573-87.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rean_cna">rean_cna()</a></code>, <code><a href="cna.html#topic+cna">cna()</a></code>,
<code><a href="#topic+causal_submodel">causal_submodel()</a></code>, <code><a href="cna.html#topic+is.submodel">is.submodel()</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Artificial data from Parkkinen and Baumgartner (2021)
sols1 &lt;- rean_cna(d.error, attempt = seq(1, 0.8, -0.1))
sols1 &lt;- do.call(rbind, sols1)
frscore(sols1$condition)


# Real fuzzy-set data from Basurto (2013)
sols2 &lt;- rean_cna(d.autonomy, type="fs", ordering = list("EM", "SP"),
         strict = TRUE, maxstep = c(3,3,9))
sols2 &lt;- do.call(rbind, sols2)$condition  # there are 217 solutions
# At the default maxsols only 50 of those solutions are scored.
frscore(sols2)
# By increasing maxsols the number of solutions to be scored can be controlled.
frscore(sols2, maxsols = 100)


# Multi-valued data/models (data from Hartmann and Kemmerzell (2010))
# Short reanalysis series, change `attempt` value to mimick a more realistic use case
sols3 &lt;- rean_cna(d.pban, outcome = "PB=1", attempt = seq(0.8, 0.7, -0.1), type = "mv")
sols3 &lt;- do.call(rbind, sols3)$condition
# For mv data, frscore() needs the data to determine admissible factor values
frscore(sols3, dat = d.pban)

# Changing the normalization
frscore(sols2, normalize = "none")
frscore(sols2, normalize = "truemax")
frscore(sols2, normalize = "idealmax")

# verbose
frscore(sols2, maxsols = 20, verbose = TRUE)




</code></pre>

<hr>
<h2 id='frscored_cna'>frscored_cna</h2><span id='topic+frscored_cna'></span>

<h3>Description</h3>

<p>Perform a reanalysis series on a data set and calculate the
fit-robustness scores of the resulting solutions/models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frscored_cna(
  x,
  fit.range = c(1, 0.7),
  granularity = 0.1,
  output = c("csf", "asf", "msc"),
  scoretype = c("full", "supermodel", "submodel"),
  normalize = c("truemax", "idealmax", "none"),
  verbose = FALSE,
  maxsols = 50,
  test.model = NULL,
  print.all = FALSE,
  comp.method = c("causal_submodel", "is.submodel"),
  n.init = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="frscored_cna_+3A_x">x</code></td>
<td>
<p>A <code>data.frame</code> or <code>configTable</code> to be analyzed with
<code><a href="cna.html#topic+cna">cna()</a></code>. In case of multi-value or fuzzy-set data, the data type must be indicated by <code>type = "mv"</code> and <code>type = "fs"</code>, respectively.</p>
</td></tr>
<tr><td><code id="frscored_cna_+3A_fit.range">fit.range</code></td>
<td>
<p>Numeric vector of length 2; determines the maximum and
minimum values of the interval of consistency and coverage thresholds used in the
reanalysis series. Defaults to <code>c(1, 0.7)</code>.</p>
</td></tr>
<tr><td><code id="frscored_cna_+3A_granularity">granularity</code></td>
<td>
<p>Numeric scalar; consistency and coverage are varied by
this value in the reanalysis series. Defaults to <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="frscored_cna_+3A_output">output</code></td>
<td>
<p>String that determines whether csfs, asfs, or mscs are
returned; <code>"csf"</code> (default) returns csfs, <code>"asf"</code> asfs,
and <code>"msc"</code> mscs.</p>
</td></tr>
<tr><td><code id="frscored_cna_+3A_scoretype">scoretype</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> String specifying the scoring method: <code>"full"</code>
(default; scoring is based on counting sub- and supermodel relations), <code>"supermodel"</code>
(count supermodels only), <code>"submodel"</code> (count
submodels only). Allowed for backward compatibility only, due to be dropped
in next version.</p>
</td></tr>
<tr><td><code id="frscored_cna_+3A_normalize">normalize</code></td>
<td>
<p>String that determines the method used in
normalizing the scores. <code>"truemax"</code> (default) normalizes by the highest score among the elements of <code>sols</code>,
such that the highest scoring solution types get score 1. <code>"idealmax"</code>
normalizes by a theoretical maximum score (see Details). </p>
</td></tr>
<tr><td><code id="frscored_cna_+3A_verbose">verbose</code></td>
<td>
<p>Logical; if <code>TRUE</code>, additional
information about causal compatibility relations among the unique solution types found
in <code>sols</code> is printed. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="frscored_cna_+3A_maxsols">maxsols</code></td>
<td>
<p>Integer determining the maximum number of unique solution
types found in the reanalysis series to be included in the scoring (see Details).</p>
</td></tr>
<tr><td><code id="frscored_cna_+3A_test.model">test.model</code></td>
<td>
<p>String that specifies a single candidate
<code>cna()</code> solution/model whose fit-robustness score is calculated against
the results of the reanalysis series.</p>
</td></tr>
<tr><td><code id="frscored_cna_+3A_print.all">print.all</code></td>
<td>
<p>Logical that controls the number of entries printed when
printing the results. If <code>TRUE</code>, results are printed as when using the defaults of
<code>print.data.frame</code>. If <code>FALSE</code>, 20 highest scoring
solutions/models are printed.</p>
</td></tr>
<tr><td><code id="frscored_cna_+3A_comp.method">comp.method</code></td>
<td>
<p>String that determines how the models in <code>sols</code> are compared
to determine their fr-score. <code>"causal_submodel"</code> (the default) checks for
causal submodel relations using <code>causal_submodel()</code>,
<code>"is.submodel"</code> checks for syntactic submodel relations with <code>is.submodel()</code></p>
</td></tr>
<tr><td><code id="frscored_cna_+3A_n.init">n.init</code></td>
<td>
<p>Integer that determines the maximum number of csfs built in
the analyses, see <code><a href="cna.html#topic+csf">cna::csf()</a></code>. Only applied when <code>output = "csf"</code>.</p>
</td></tr>
<tr><td><code id="frscored_cna_+3A_...">...</code></td>
<td>
<p>Any arguments to be passed to <code><a href="cna.html#topic+cna">cna()</a></code> except <code>con</code>, <code>cov</code> or
<code>con.msc</code>. The effect of argument <code>what</code> is overriden
by <code>output</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>frscored_cna()</code> is a wrapper function that sequentially executes <code><a href="#topic+rean_cna">rean_cna()</a></code> and <code><a href="#topic+frscore">frscore()</a></code>, meaning it performs both computational phases of fit-robustness scoring as introduced in Parkkinen and Baumgartner (2021). In the first phase, the function conducts a reanalysis series on the input data <code>x</code> at all combinatorially possible combinations of fit thresholds that can be generated from the interval given by <code>fit.range</code> at increments given by <code>granularity</code> and collects all solutions/models in a set <strong>M</strong>. In the second phase, it calculates the fit-robustness scores of the atomic (asf) and/or complex (csf) solution formulas in <strong>M</strong>.
The argument <code>output</code> allows for controlling whether csf or only asf are built, the latter normally being  faster but less complete.
</p>
<p>The argument <code>scoretype</code> is deprecated as of <code>frscore</code> 0.3.1, and will be dropped
from future versions of the package.
Giving it a non-default value
is allowed so that older code can be run without errors, but doing this is otherwise discouraged.
The permissible values of <code>scoretype</code> have the following effects.
When set to its default value <code>"full"</code>, the score of each solution/model <strong>m</strong> in <strong>M</strong> is calculated by counting
the number of the (either causal or syntactic) sub- and supermodel relations <strong>m</strong> has to the other elements of <strong>M</strong>. Whether causal or syntactic submodel relations
are counted depends on the value of <code>comp.method</code>: <code>"causal_submodel"</code> (default)
counts causal submodel relations using <code><a href="#topic+causal_submodel">causal_submodel()</a></code>,
<code>"is.submodel"</code> counts syntactic submodel relations using <code><a href="cna.html#topic+is.submodel">cna::is.submodel()</a></code>.
Setting <code>scoretype</code> to <code>"supermodel"</code> or <code>"submodel"</code> forces the scoring to be based on, respectively, supermodel and submodel relations only. In future versions of <code>frscore</code>, fit-robustness
scores will always be calculated as with <code>scoretype = "full"</code>, and
changing this will not be possible. If additional information about the numbers of
sub- vs. supermodel relations a particular model has to other models is needed, this
can be acquired by inspecting the <code>"verbout"</code> element of the output of <code>frscored_cna()</code>.
</p>
<p>The fit-robustness scores can be normalized in two ways. In the default setting <code>normalize = "truemax"</code>, the score of each <code>sols[i]</code> is divided by the maximum score obtained by an element of <code>sols</code>. In case of <code>normalize = "idealmax"</code>, the score is normalized not by an actually obtained
maximum but by an idealized maximum, which is calculated by assuming that all solutions of equal
complexity in <code>sols</code> are identical and that for every <code>sols[i]</code> of a given complexity, all less complex
elements of <code>sols</code> are its submodels and all more complex elements of <code>sols</code> are its supermodels.
When normalization is applied, the normalized score is shown in its own column <code>norm.score</code> in
the results. The raw scores are shown in the column <code>score</code>.
</p>
<p>If the argument <code>verbose</code> is set to <code>TRUE</code>, <code>frscored_cna()</code> also
prints a list indicating for each solution/model how many raw score points it receives from which elements of <strong>M</strong>. The verbose list is ordered with decreasing fit robustness scores.
</p>
<p>If the size of the consistency and coverage range scanned in the reanalysis series generating <strong>M</strong> is large or there are many model ambiguities, <strong>M</strong> may contain so many different types of solutions that robustness cannot be calculated for all of them in reasonable time. In that case, the argument <code>maxsols</code> allows for capping the number of solution types to be included in the scoring (defaults to 50). <code>frscored_cna()</code> then selects the most frequent solutions in <strong>M</strong> of each complexity level until <code>maxsols</code> is reached and only scores the thus selected elements of <strong>M</strong>.
</p>
<p>If the user is interested in the robustness of one specific candidate model, that model can be given to <code>frscored_cna()</code> by the argument <code>test.model</code>. The result for that model will then be printed separately, provided the model is found in the
reanalysis series, if not, the function stops.
</p>


<h3>Value</h3>

<p>A list whose first element is a data frame that contains the model types
returned from a reanalysis series of the input data, their details
such as consistency and coverage, together with the unadjusted fit-robustness score
of each model type shown in column 'score', and a normalized score in column
'norm.score' in case <code>normalize = "truemax"</code> or <code>normalize = "idealmax"</code>. The other elements
contain additional information about the submodel relations among
the unique solution types and about how
the function was called.
</p>


<h3>References</h3>

<p>P. Emmenegger (2011) &ldquo;Job Security Regulations in Western Democracies:
A Fuzzy Set Analysis.&rdquo; <em>European Journal of Political Research</em> 50(3):336-64.
</p>
<p>C. Hartmann and J. Kemmerzell (2010) &ldquo;Understanding Variations
in Party Bans in Africa.&rdquo; <em>Democratization</em> 17(4):642-65.
doi:10.1080/13510347.2010.491189.
</p>
<p>V.P. Parkkinen and M. Baumgartner (2021), &ldquo;Robustness and Model Selection in Configurational Causal Modeling,&rdquo; <em>Sociological Methods and Research</em>, doi:10.1177/0049124120986200.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frscore">frscore()</a></code>, <code><a href="#topic+rean_cna">rean_cna()</a></code>,
<code><a href="#topic+causal_submodel">causal_submodel()</a></code>, <code><a href="cna.html#topic+is.submodel">cna::is.submodel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Robustness analysis from sect. 4 of Parkkinen and Baumgartner (2021)
frscored_cna(d.error, fit.range = c(1, 0.75), granularity = 0.05,
             ordering = list("E"), strict = TRUE)

# Multi-value data from Hartmann and Kemmerzell (2010)
frscored_cna(d.pban, type = "mv", fit.range = c(0.9, 0.7), granularity = 0.1,
                  normalize = "none", ordering = list("T", "PB"), strict = TRUE)

# Fuzzy-set data from Emmenegger (2011)
frscored_cna(d.jobsecurity, type = "fs", fit.range = c(0.9, 0.6), granularity = 0.05,
                  scoretype = "submodel", ordering = list("JSR"), strict = TRUE)

# Artificial data
dat &lt;- data.frame(
  A = c(1,1,0,0,0,0,1,1),
  B = c(0,1,0,0,0,0,1,1),
  C = c(1,0,1,0,1,0,1,0),
  D = c(1,1,0,0,1,1,0,0),
  E = c(1,1,1,1,0,0,0,0))
frscored_cna(dat)
frscored_cna(dat, output = "asf")
frscored_cna(dat, maxsols = 10)
frscored_cna(dat, test.model = "(b*e+A*E&lt;-&gt;D)*(B&lt;-&gt;A)")

</code></pre>

<hr>
<h2 id='rean_cna'>rean_cna</h2><span id='topic+rean_cna'></span>

<h3>Description</h3>

<p>Perform a reanalysis series on a data set with <code><a href="cna.html#topic+cna">cna()</a></code> using
all combinations of consistency and coverage threshold values in a given
range of values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rean_cna(x, attempt = seq(1, 0.7, -0.1), ncsf = deprecated(),
output = c("csf", "asf", "msc"),
n.init = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rean_cna_+3A_x">x</code></td>
<td>
<p>A <code>data.frame</code> or <code>configTable</code> to be analyzed with <code><a href="cna.html#topic+cna">cna()</a></code>. In case of multi-value or fuzzy-set data, the data type must be indicated by <code>type = "mv"</code> and <code>type = "fs"</code>, respectively.</p>
</td></tr>
<tr><td><code id="rean_cna_+3A_attempt">attempt</code></td>
<td>
<p>Numeric vector that contains the values from which
combinations of consistency and coverage thresholds are formed, to be used
in the analyses.</p>
</td></tr>
<tr><td><code id="rean_cna_+3A_ncsf">ncsf</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Allowed for backward compatibility, due to be dropped in future
versions. Please use <code>n.init</code> instead.</p>
</td></tr>
<tr><td><code id="rean_cna_+3A_output">output</code></td>
<td>
<p>Character vector that determines whether csfs, asfs, or mscs are
returned; <code>"csf"</code> (default) returns csfs, <code>"asf"</code> asfs,
and <code>"msc"</code> mscs.</p>
</td></tr>
<tr><td><code id="rean_cna_+3A_n.init">n.init</code></td>
<td>
<p>Integer that determines the maximum number of csfs built in
the analyses. See <code><a href="cna.html#topic+csf">csf()</a></code></p>
</td></tr>
<tr><td><code id="rean_cna_+3A_...">...</code></td>
<td>
<p>Any arguments to be passed to <code><a href="cna.html#topic+cna">cna()</a></code> except <code>con</code>, <code>cov</code> or
<code>con.msc</code>. The effect of argument <code>what</code> is overriden
by <code>output</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rean_cna()</code> performs a reanalysis series of a data set <code>x</code>, which constitutes the first
computational phase of fit-robustness scoring as introduced in Parkkinen and Baumgartner (2021). The  series consists of <code><a href="cna.html#topic+cna">cna()</a></code> calls at all combinatorially possible consistency and coverage settings drawn from the vector <code>attempt</code>. If the <code>output</code> argument is set to its default value <code>"csf"</code>, <code>rean_cna()</code> returns complex solutions formulas (csf), in case of <code>"asf"</code> only atomic solution formulas (&quot;asf&quot;) are built, which is faster. The argument <code>n.init</code> allows for controlling the number of csf to be built, if <code>output = "csf"</code>.
</p>


<h3>Value</h3>

<p>A list where each element is a data frame containing the results of
a single analysis of the input data set with <code>cna()</code>, each using a
different combination of consistency and coverage threshold values. These
values are added to the output as extra columns 'cnacon' and 'cnacov'.
</p>


<h3>References</h3>

<p>V.P. Parkkinen and M. Baumgartner (2021), &ldquo;Robustness and Model Selection in Configurational Causal Modeling,&rdquo; <em>Sociological Methods and Research</em>, doi:10.1177/0049124120986200.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frscore">frscore()</a></code>, <code><a href="cna.html#topic+cna">cna()</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Crisp-set data
sols1 &lt;- rean_cna(d.error, attempt = seq(1, 0.8, -0.1))
sols1 &lt;- do.call(rbind, sols1)
sols1

# Multi-value data
sols2 &lt;- rean_cna(d.pban, type = "mv", attempt = seq(0.9, 0.7, -0.1),
                  ordering = list("T", "PB"), strict = TRUE)
sols2 &lt;- do.call(rbind, sols2)
sols2

# Fuzzy-set data
sols3 &lt;- rean_cna(d.jobsecurity, type = "fs", attempt = seq(0.9, 0.7, -0.1),
                  ordering = list("JSR"), strict = TRUE) # execution takes a couple of seconds
sols3 &lt;- do.call(rbind, sols2)
sols3
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
