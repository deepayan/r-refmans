<!DOCTYPE html><html lang="en"><head><title>Help for package gyro</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gyro}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#changesOfSign'><p>Changes of sign</p></a></li>
<li><a href='#gyroABt'><p>Point on a gyroline</p></a></li>
<li><a href='#gyrocentroid'><p>Gyrocentroid</p></a></li>
<li><a href='#gyrodemos'><p>Examples of the 'gyro' package</p></a></li>
<li><a href='#gyromidpoint'><p>Gyromidpoint</p></a></li>
<li><a href='#gyroray'><p>Gyroray</p></a></li>
<li><a href='#gyroreflection'><p>Gyroreflection</p></a></li>
<li><a href='#gyrosegment'><p>Gyrosegment</p></a></li>
<li><a href='#gyrotriangle'><p>Gyrotriangle in 3D space</p></a></li>
<li><a href='#gyrotube'><p>Gyrotube (tubular gyrosegment)</p></a></li>
<li><a href='#hdelaunay'><p>Hyperbolic Delaunay triangulation</p></a></li>
<li><a href='#hreflection'><p>Hyperbolic reflection</p></a></li>
<li><a href='#PhiMU'><p>Isomorphism from Ungar gyrovector space to Möbius gyrovector space</p></a></li>
<li><a href='#PhiUM'><p>Isomorphism from Möbius gyrovector space to Ungar gyrovector space</p></a></li>
<li><a href='#plotGyrohull3d'><p>Plot hyperbolic convex hull</p></a></li>
<li><a href='#plotGyroMesh'><p>Plot hyperbolic mesh</p></a></li>
<li><a href='#plotHdelaunay'><p>Plot hyperbolic Delaunay triangulation</p></a></li>
<li><a href='#tiling'><p>Hyperbolic tiling</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Hyperbolic Geometry</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Stéphane Laurent</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stéphane Laurent &lt;laurent_step@outlook.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Hyperbolic geometry in the Minkowski model and the Poincaré
    model. The methods are based on the gyrovector space theory developed
    by A. A. Ungar that can be found in the book 'Analytic Hyperbolic
    Geometry: Mathematical Foundations And Applications'
    &lt;<a href="https://doi.org/10.1142%2F5914">doi:10.1142/5914</a>&gt;. The package provides functions to plot
    three-dimensional hyperbolic polyhedra and to plot hyperbolic tilings
    of the Poincaré disk.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stla/gyro">https://github.com/stla/gyro</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stla/gyro/issues">https://github.com/stla/gyro/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>clipr, colorsGen, cxhull (&ge; 0.3.0), graphics, grDevices,
Morpho, plotrix, Polychrome, purrr, Rcpp, rgl, rstudioapi,
Rvcg, RCDT</td>
</tr>
<tr>
<td>Suggests:</td>
<td>arrangements, knitr, rmarkdown, trekcolors, uniformly</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-30 16:58:07 UTC; SDL96354</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-30 17:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='changesOfSign'>Changes of sign</h2><span id='topic+changesOfSign'></span>

<h3>Description</h3>

<p>Sometimes, the coordinates of the vertices of a polyhedron are
given with changes of sign (with a symbol <strong>+/-</strong>). This function
performs the changes of sign.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>changesOfSign(M, changes = "all")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="changesOfSign_+3A_m">M</code></td>
<td>
<p>a numeric matrix of coordinates of some points (one point per row)</p>
</td></tr>
<tr><td><code id="changesOfSign_+3A_changes">changes</code></td>
<td>
<p>either the indices of the columns of <code>M</code> where the
changes of sign must be done, or <code>"all"</code> to select all the indices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix, <code>M</code> transformed by the changes of sign.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gyro)
library(rgl)
## ~~ rhombicosidodecahedron ~~##
phi &lt;- (1 + sqrt(5)) / 2
vs1 &lt;- rbind(
  c(1, 1, phi^3),
  c(phi^2, phi, 2 * phi),
  c(2 + phi, 0, phi^2)
)
vs2 &lt;- rbind(vs1, vs1[, c(2, 3, 1)], vs1[, c(3, 1, 2)]) # even permutations
vs &lt;- changesOfSign(vs2)
open3d(windowRect = c(50, 50, 562, 562), zoom = 0.65)
plotGyrohull3d(vs)
</code></pre>

<hr>
<h2 id='gyroABt'>Point on a gyroline</h2><span id='topic+gyroABt'></span>

<h3>Description</h3>

<p>Point of coordinate <code>t</code> on the gyroline passing through
two given points <code>A</code> and <code>B</code>. This is <code>A</code> for <code>t=0</code>
and this is <code>B</code> for <code>t=1</code>. For <code>t=1/2</code> this is the
gyromidpoint of the gyrosegment joining <code>A</code> and <code>B</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gyroABt(A, B, t, s = 1, model = "U")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gyroABt_+3A_a">A</code>, <code id="gyroABt_+3A_b">B</code></td>
<td>
<p>two distinct points</p>
</td></tr>
<tr><td><code id="gyroABt_+3A_t">t</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="gyroABt_+3A_s">s</code></td>
<td>
<p>positive number, the radius of the Poincaré ball if
<code>model="M"</code>, otherwise, if <code>model="U"</code>, this number
defines the hyperbolic curvature</p>
</td></tr>
<tr><td><code id="gyroABt_+3A_model">model</code></td>
<td>
<p>the hyperbolic model, either <code>"M"</code> (Möbius model, i.e.
Poincaré model) or <code>"U"</code> (Ungar model, i.e. hyperboloid model)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A point.
</p>

<hr>
<h2 id='gyrocentroid'>Gyrocentroid</h2><span id='topic+gyrocentroid'></span>

<h3>Description</h3>

<p>Gyrocenroid of a triangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gyrocentroid(A, B, C, s = 1, model = "U")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gyrocentroid_+3A_a">A</code>, <code id="gyrocentroid_+3A_b">B</code>, <code id="gyrocentroid_+3A_c">C</code></td>
<td>
<p>three distinct points</p>
</td></tr>
<tr><td><code id="gyrocentroid_+3A_s">s</code></td>
<td>
<p>positive number, the radius of the Poincaré ball if
<code>model="M"</code>, otherwise, if <code>model="U"</code>, this number
defines the hyperbolic curvature (the smaller, the more curved)</p>
</td></tr>
<tr><td><code id="gyrocentroid_+3A_model">model</code></td>
<td>
<p>the hyperbolic model, either <code>"M"</code> (Möbius model, i.e.
Poincaré model) or <code>"U"</code> (Ungar model, i.e. hyperboloid model)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A point, the gyrocentroid of the triangle <code>ABC</code>.
</p>

<hr>
<h2 id='gyrodemos'>Examples of the 'gyro' package</h2><span id='topic+gyrodemos'></span>

<h3>Description</h3>

<p>Some examples of hyperbolic polyhedra realized with the 'gyro'
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gyrodemos()
</code></pre>


<h3>Value</h3>

<p>No value. The function firstly copies the demo files in a
temporary directory. If you use RStudio, the function opens these files.
Otherwise it prints a message giving the instructions to access to these
files.
</p>


<h3>Note</h3>

<p>The <em>BarthLike</em> file has this name because the figure it
generates looks like the Barth sextic (drawing by Patrice Jeener):
</p>

<p><img src="../help/figures/SextiqueDeBarth.png" style="max-width:75%; display: block; text-align: center;" alt="SextiqueDeBarth.png" />
</p>



<hr>
<h2 id='gyromidpoint'>Gyromidpoint</h2><span id='topic+gyromidpoint'></span>

<h3>Description</h3>

<p>The gyromidpoint of a <code><a href="#topic+gyrosegment">gyrosegment</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gyromidpoint(A, B, s = 1, model = "U")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gyromidpoint_+3A_a">A</code>, <code id="gyromidpoint_+3A_b">B</code></td>
<td>
<p>two distinct points (of the same dimension)</p>
</td></tr>
<tr><td><code id="gyromidpoint_+3A_s">s</code></td>
<td>
<p>positive number, the radius of the Poincaré ball if
<code>model="M"</code>, otherwise, if <code>model="U"</code>, this number
defines the hyperbolic curvature</p>
</td></tr>
<tr><td><code id="gyromidpoint_+3A_model">model</code></td>
<td>
<p>the hyperbolic model, either <code>"M"</code> (Möbius model, i.e.
Poincaré model) or <code>"U"</code> (Ungar model, i.e. hyperboloid model)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A point, the gyromidpoint of a the <code><a href="#topic+gyrosegment">gyrosegment</a></code>
joining <code>A</code> and <code>B</code>.
</p>


<h3>Note</h3>

<p>This is the same as <code>gyroABt(A, B, 1/2, s)</code> but the
calculation is more efficient.
</p>

<hr>
<h2 id='gyroray'>Gyroray</h2><span id='topic+gyroray'></span>

<h3>Description</h3>

<p>Gyroray given an origin and a point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gyroray(O, A, s = 1, tmax = 20, OtoA = TRUE, model = "U", n = 300)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gyroray_+3A_o">O</code>, <code id="gyroray_+3A_a">A</code></td>
<td>
<p>two distinct points (of the same dimension); the point
<code>O</code> is the origin of the gyroray</p>
</td></tr>
<tr><td><code id="gyroray_+3A_s">s</code></td>
<td>
<p>positive number, the radius of the Poincaré ball if
<code>model="M"</code>, otherwise, if <code>model="U"</code>, this number
defines the hyperbolic curvature</p>
</td></tr>
<tr><td><code id="gyroray_+3A_tmax">tmax</code></td>
<td>
<p>positive number controlling the length of the gyroray</p>
</td></tr>
<tr><td><code id="gyroray_+3A_otoa">OtoA</code></td>
<td>
<p>Boolean, whether the gyroray must be directed from
<code>O</code> to <code>A</code> or must be the opposite one</p>
</td></tr>
<tr><td><code id="gyroray_+3A_model">model</code></td>
<td>
<p>the hyperbolic model, either <code>"M"</code> (Möbius model, i.e.
Poincaré model) or <code>"U"</code> (Ungar model, i.e. hyperboloid model)</p>
</td></tr>
<tr><td><code id="gyroray_+3A_n">n</code></td>
<td>
<p>number of points forming the gyroray</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with <code>n</code> rows. Each row is a point of the
gyroray with origin <code>O</code> (the first row) and passing through <code>A</code>
or not, according to <code>OtoA</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gyro)
# a 2D example ####
O &lt;- c(1, 2); A &lt;- c(1, 1)
opar &lt;- par(mar = c(2, 2, 2, 0.5))
plot(rbind(O, A), type = "p", pch = 19, xlab = NA, ylab = NA,
     xlim = c(0, 2), ylim = c(0, 3), main = "s = 0.3")
s &lt;- 0.3
ray &lt;- gyroray(O, A, s)
lines(ray, col = "blue", lwd = 2)
text(t(O), expression(italic(O)), pos = 2)
text(t(A), expression(italic(A)), pos = 3)
# opposite gyroray
yar &lt;- gyroray(O, A, s, OtoA = FALSE)
lines(yar, col = "red", lwd = 2)
par(opar)
</code></pre>

<hr>
<h2 id='gyroreflection'>Gyroreflection</h2><span id='topic+gyroreflection'></span>

<h3>Description</h3>

<p>Gyroreflection of a point with respect to a gyroline in
a 2D gyrospace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gyroreflection(A, B, M, s, model = "U")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gyroreflection_+3A_a">A</code>, <code id="gyroreflection_+3A_b">B</code>, <code id="gyroreflection_+3A_m">M</code></td>
<td>
<p>three 2D points</p>
</td></tr>
<tr><td><code id="gyroreflection_+3A_s">s</code></td>
<td>
<p>the gyroparameter (radius of the Poincaré disk if <code>model="M"</code>)</p>
</td></tr>
<tr><td><code id="gyroreflection_+3A_model">model</code></td>
<td>
<p>the hyperbolic model, either <code>"M"</code> (Möbius model, i.e.
Poincaré model) or <code>"U"</code> (Ungar model, i.e. Minkowski model)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2D point, the image of <code>M</code> by the reflection with respect to
the gyroline passing through <code>A</code> and <code>B</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gyro)
A &lt;- c(1.5, 2); B &lt;- c(2, 1)
opar &lt;- par(mar = c(2, 2, 2, 0.5))
plot(rbind(A, B), type = "p", pch = 19, xlab = NA, ylab = NA,
     xlim = c(0.3, 2), ylim = c(0, 2.5), main = "s = 0.3")
s &lt;- 0.3
seg &lt;- gyrosegment(A, B, s = s, model = "U")
lines(seg, col = "blue", lwd = 2)
text(t(A), expression(italic(A)), pos = 3)
text(t(B), expression(italic(B)), pos = 3)
M &lt;- c(1.3, 1.1)
rM &lt;- gyroreflection(A, B, M, s = s, model = "U")
points(rbind(M, rM), type = "p", pch = 19)
text(t(M), expression(italic(M)), pos = 3)
text(t(rM), expression(italic(r(M))), pos = 3)
par(opar)
</code></pre>

<hr>
<h2 id='gyrosegment'>Gyrosegment</h2><span id='topic+gyrosegment'></span>

<h3>Description</h3>

<p>Gyrosegment joining two given points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gyrosegment(A, B, s = 1, model = "U", n = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gyrosegment_+3A_a">A</code>, <code id="gyrosegment_+3A_b">B</code></td>
<td>
<p>two distinct points (of the same dimension)</p>
</td></tr>
<tr><td><code id="gyrosegment_+3A_s">s</code></td>
<td>
<p>positive number, the radius of the Poincaré ball if
<code>model="M"</code>, otherwise, if <code>model="U"</code>, this number
defines the hyperbolic curvature</p>
</td></tr>
<tr><td><code id="gyrosegment_+3A_model">model</code></td>
<td>
<p>the hyperbolic model, either <code>"M"</code> (Möbius model, i.e.
Poincaré model) or <code>"U"</code> (Ungar model, i.e. hyperboloid model)</p>
</td></tr>
<tr><td><code id="gyrosegment_+3A_n">n</code></td>
<td>
<p>number of points forming the gyrosegment from <code>A</code> to <code>B</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with <code>n</code> rows. Each row is a point of the
gyrosegment from <code>A</code> (the first row) to <code>B</code> (the last row).
</p>


<h3>Note</h3>

<p>The gyrosegment is obtained from <code><a href="#topic+gyroABt">gyroABt</a></code> by varying
<code>t</code> from <code>0</code> to <code>1</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gyro)
# a 2D example ####
A &lt;- c(1, 2); B &lt;- c(1, 1)
opar &lt;- par(mfrow = c(1, 2), mar = c(2, 2, 2, 0.5))
plot(rbind(A, B), type = "p", pch = 19, xlab = NA, ylab = NA,
     xlim = c(0, 2), ylim = c(0, 2), main = "s = 0.2")
s &lt;- 0.2
AB &lt;- gyrosegment(A, B, s)
lines(AB, col = "blue", lwd = 2)
text(t(A), expression(italic(A)), pos = 2)
text(t(B), expression(italic(B)), pos = 3)
# this is an hyperbola whose asymptotes meet at the origin
# approximate asymptotes
lines(rbind(c(0, 0), gyroABt(A, B, t = -20, s)), lty = "dashed")
lines(rbind(c(0, 0), gyroABt(A, B, t = 20, s)), lty = "dashed")
# plot the gyromidoint
points(
 rbind(gyromidpoint(A, B, s)),
 type = "p", pch = 19, col = "red"
)
# another one, with a different `s`
plot(rbind(A, B), type = "p", pch = 19, xlab = NA, ylab = NA,
     xlim = c(0, 2), ylim = c(0, 2), main = "s = 0.1")
s &lt;- 0.1
AB &lt;- gyrosegment(A, B, s)
lines(AB, col = "blue", lwd = 2)
text(t(A), expression(italic(A)), pos = 2)
text(t(B), expression(italic(B)), pos = 3)
# approximate asymptotes
lines(rbind(c(0, 0), gyroABt(A, B, t = -20, s)), lty = "dashed")
lines(rbind(c(0, 0), gyroABt(A, B, t = 20, s)), lty = "dashed")
# plot the gyromidoint
points(
 rbind(gyromidpoint(A, B, s)),
 type = "p", pch = 19, col = "red"
)

# a 3D hyperbolic triangle ####
library(rgl)
A &lt;- c(1, 0, 0); B &lt;- c(0, 1, 0); C &lt;- c(0, 0, 1)
s &lt;- 0.3
AB &lt;- gyrosegment(A, B, s)
AC &lt;- gyrosegment(A, C, s)
BC &lt;- gyrosegment(B, C, s)
view3d(30, 30, zoom = 0.75)
lines3d(AB, lwd = 3); lines3d(AC, lwd = 3); lines3d(BC, lwd = 3)
</code></pre>

<hr>
<h2 id='gyrotriangle'>Gyrotriangle in 3D space</h2><span id='topic+gyrotriangle'></span>

<h3>Description</h3>

<p>3D gyrotriangle as a mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gyrotriangle(
  A,
  B,
  C,
  s = 1,
  model = "U",
  iterations = 5,
  palette = NULL,
  bias = 1,
  interpolate = "linear",
  g = identity
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gyrotriangle_+3A_a">A</code>, <code id="gyrotriangle_+3A_b">B</code>, <code id="gyrotriangle_+3A_c">C</code></td>
<td>
<p>three distinct 3D points</p>
</td></tr>
<tr><td><code id="gyrotriangle_+3A_s">s</code></td>
<td>
<p>positive number, the radius of the Poincaré ball if
<code>model="M"</code>, otherwise, if <code>model="U"</code>, this number
defines the hyperbolic curvature (the smaller, the more curved)</p>
</td></tr>
<tr><td><code id="gyrotriangle_+3A_model">model</code></td>
<td>
<p>the hyperbolic model, either <code>"M"</code> (Möbius model, i.e.
Poincaré model) or <code>"U"</code> (Ungar model, i.e. hyperboloid model)</p>
</td></tr>
<tr><td><code id="gyrotriangle_+3A_iterations">iterations</code></td>
<td>
<p>the gyrotriangle is constructed by iterated subdivisions,
this argument is the number of iterations</p>
</td></tr>
<tr><td><code id="gyrotriangle_+3A_palette">palette</code></td>
<td>
<p>a vector of colors to decorate the triangle, or <code>NULL</code>
if you don't want to use a color palette</p>
</td></tr>
<tr><td><code id="gyrotriangle_+3A_bias">bias</code>, <code id="gyrotriangle_+3A_interpolate">interpolate</code></td>
<td>
<p>if <code>palette</code> is not <code>NULL</code>, these
arguments are passed to <code><a href="grDevices.html#topic+colorRamp">colorRamp</a></code></p>
</td></tr>
<tr><td><code id="gyrotriangle_+3A_g">g</code></td>
<td>
<p>a function from [0,1] to [0,1]; if <code>palette</code> is not
<code>NULL</code>, this function is applied to the scalars defining the colors
(the normalized gyrodistances to the gyrocentroid of the gyrotriangle)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="rgl.html#topic+mesh3d">mesh3d</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gyro)
library(rgl)
A &lt;- c(1, 0, 0); B &lt;- c(0, 1, 0); C &lt;- c(0, 0, 1)
ABC &lt;- gyrotriangle(A, B, C, s = 0.3)
open3d(windowRect = c(50, 50, 562, 562))
view3d(30, 30, zoom = 0.75)
shade3d(ABC, color = "navy", specular = "cyan")

# using a color palette ####
if(require("trekcolors")) {
  pal &lt;- trek_pal("klingon")
} else {
  pal &lt;- hcl.colors(32L, palette = "Rocket")
}
ABC &lt;- gyrotriangle(
  A, B, C, s = 0.5,
  palette = pal, bias = 1.5, interpolate = "spline"
)
open3d(windowRect = c(50, 50, 562, 562))
view3d(zoom = 0.75)
shade3d(ABC)

# hyperbolic icosahedron ####
library(rgl)
library(Rvcg) # to get the edges with the `vcgGetEdge` function
icosahedron &lt;- icosahedron3d() # mesh with 12 vertices, 20 triangles
vertices &lt;- t(icosahedron$vb[-4, ])
triangles &lt;- t(icosahedron$it)
edges &lt;- as.matrix(vcgGetEdge(icosahedron)[, c("vert1", "vert2")])
s &lt;- 0.3
open3d(windowRect = c(50, 50, 562, 562))
view3d(zoom = 0.75)
for(i in 1:nrow(triangles)){
  triangle &lt;- triangles[i, ]
  A &lt;- vertices[triangle[1], ]
  B &lt;- vertices[triangle[2], ]
  C &lt;- vertices[triangle[3], ]
  gtriangle &lt;- gyrotriangle(A, B, C, s)
  shade3d(gtriangle, color = "midnightblue")
}
for(i in 1:nrow(edges)){
  edge &lt;- edges[i, ]
  A &lt;- vertices[edge[1], ]
  B &lt;- vertices[edge[2], ]
  gtube &lt;- gyrotube(A, B, s, radius = 0.03)
  shade3d(gtube, color = "lemonchiffon")
}
spheres3d(vertices, radius = 0.05, color = "lemonchiffon")
</code></pre>

<hr>
<h2 id='gyrotube'>Gyrotube (tubular gyrosegment)</h2><span id='topic+gyrotube'></span>

<h3>Description</h3>

<p>Tubular gyrosegment joining two given 3D points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gyrotube(A, B, s = 1, model = "U", n = 100, radius, sides = 90, caps = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gyrotube_+3A_a">A</code>, <code id="gyrotube_+3A_b">B</code></td>
<td>
<p>distinct 3D points</p>
</td></tr>
<tr><td><code id="gyrotube_+3A_s">s</code></td>
<td>
<p>positive number, the radius of the Poincaré ball if
<code>model="M"</code>, otherwise, if <code>model="U"</code>, this number
defines the hyperbolic curvature (higher value, less curved)</p>
</td></tr>
<tr><td><code id="gyrotube_+3A_model">model</code></td>
<td>
<p>the hyperbolic model, either <code>"M"</code> (Möbius model, i.e.
Poincaré model) or <code>"U"</code> (Ungar model, i.e. hyperboloid model)</p>
</td></tr>
<tr><td><code id="gyrotube_+3A_n">n</code></td>
<td>
<p>number of points forming the gyrosegment</p>
</td></tr>
<tr><td><code id="gyrotube_+3A_radius">radius</code></td>
<td>
<p>radius of the tube around the gyrosegment</p>
</td></tr>
<tr><td><code id="gyrotube_+3A_sides">sides</code></td>
<td>
<p>number of sides in the polygon cross section</p>
</td></tr>
<tr><td><code id="gyrotube_+3A_caps">caps</code></td>
<td>
<p>Boolean, whether to put caps on the ends of the tube</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="rgl.html#topic+mesh3d">mesh3d</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gyro)
library(rgl)
A &lt;- c(1, 2, 0); B &lt;- c(1, 1, 0)
tube &lt;- gyrotube(A, B, s = 0.2, radius = 0.02)
shade3d(tube, color = "orangered")

# a 3D hyperbolic triangle ####
library(rgl)
A &lt;- c(1, 0, 0); B &lt;- c(0, 1, 0); C &lt;- c(0, 0, 1)
s &lt;- 0.3
r &lt;- 0.03
AB &lt;- gyrotube(A, B, s, radius = r)
AC &lt;- gyrotube(A, C, s, radius = r)
BC &lt;- gyrotube(B, C, s, radius = r)
view3d(30, 30, zoom = 0.75)
shade3d(AB, color = "gold")
shade3d(AC, color = "gold")
shade3d(BC, color = "gold")
spheres3d(rbind(A, B, C), radius = 0.04, color = "gold")
</code></pre>

<hr>
<h2 id='hdelaunay'>Hyperbolic Delaunay triangulation</h2><span id='topic+hdelaunay'></span>

<h3>Description</h3>

<p>Computes the hyperbolic Delaunay triangulation of a set of
points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdelaunay(points, model = "M")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hdelaunay_+3A_points">points</code></td>
<td>
<p>points in the unit disk given as a numeric matrix with
two columns</p>
</td></tr>
<tr><td><code id="hdelaunay_+3A_model">model</code></td>
<td>
<p>the hyperbolic model, either <code>"M"</code> (Möbius model, i.e.
Poincaré model) or <code>"U"</code> (Ungar model, i.e. hyperboloid model)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with five fields <code>vertices</code>, <code>edges</code>,
<code>triangles</code>, <code>ntriangles</code>, and <code>centroids</code>, a matrix
giving the gyrocentroids of the triangles.
The input <code>points</code> matrix and the output <code>vertices</code> matrix
are the same up to the order of the rows if <code>model="M"</code>, and if
<code>model="U"</code>, the points in the output <code>vertices</code> matrix are
obtained by isomorphism.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotHdelaunay">plotHdelaunay</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gyro)
library(uniformly)
set.seed(666)
points &lt;- runif_in_sphere(10L, d = 2)
hdelaunay(points)
</code></pre>

<hr>
<h2 id='hreflection'>Hyperbolic reflection</h2><span id='topic+hreflection'></span>

<h3>Description</h3>

<p>Hyperbolic reflection in the Poincaré disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hreflection(A, B, M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hreflection_+3A_a">A</code>, <code id="hreflection_+3A_b">B</code></td>
<td>
<p>two points in the Poincaré disk defining the reflection line</p>
</td></tr>
<tr><td><code id="hreflection_+3A_m">M</code></td>
<td>
<p>a point in the Poincaré disk to be reflected</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A point in the Poincaré disk, the image of <code>M</code> by the
hyperbolic reflection with respect to the line passing through
<code>A</code> and <code>B</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gyro)
library(plotrix)
A &lt;- c(0.45, 0.78)
B &lt;- c(0.1, -0.5)
M &lt;- c(0.7, 0)
opar &lt;- par(mar = c(0, 0, 0, 0))
plot(NULL, type = "n", xlim = c(-1, 1), ylim = c(-1, 1), asp = 1,
     axes = FALSE, xlab = NA, ylab = NA)
draw.circle(0, 0, radius = 1, lwd = 2)
lines(gyrosegment(A, B, model = "M"))
points(rbind(A, B), pch = 19)
points(rbind(M), pch = 19, col = "blue")
P &lt;- hreflection(A, B, M)
points(rbind(P), pch = 19, col = "red")
par(opar)
</code></pre>

<hr>
<h2 id='PhiMU'>Isomorphism from Ungar gyrovector space to Möbius gyrovector space</h2><span id='topic+PhiMU'></span>

<h3>Description</h3>

<p>Isomorphism from the Ungar gyrovector space to
the Möbius gyrovector space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhiMU(A, s = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PhiMU_+3A_a">A</code></td>
<td>
<p>a point in the Ungar vector space with curvature <code>s</code></p>
</td></tr>
<tr><td><code id="PhiMU_+3A_s">s</code></td>
<td>
<p>a positive number, the hyperbolic curvature of the Ungar
vector space</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The point of the Poincaré ball of radius <code>s</code> corresponding
to <code>A</code> by isomorphism.
</p>

<hr>
<h2 id='PhiUM'>Isomorphism from Möbius gyrovector space to Ungar gyrovector space</h2><span id='topic+PhiUM'></span>

<h3>Description</h3>

<p>Isomorphism from the Möbius gyrovector space to
the Ungar gyrovector space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhiUM(A, s = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PhiUM_+3A_a">A</code></td>
<td>
<p>a point whose norm is lower than <code>s</code></p>
</td></tr>
<tr><td><code id="PhiUM_+3A_s">s</code></td>
<td>
<p>positive number, the radius of the Poincaré ball</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The point of the Ungar gyrovector space corresponding to <code>A</code>
by isomorphism.
</p>

<hr>
<h2 id='plotGyrohull3d'>Plot hyperbolic convex hull</h2><span id='topic+plotGyrohull3d'></span>

<h3>Description</h3>

<p>Plot the hyperbolic convex hull of a set of 3D points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGyrohull3d(
  points,
  s = 1,
  model = "U",
  iterations = 5,
  n = 100,
  edgesAsTubes = TRUE,
  verticesAsSpheres = edgesAsTubes,
  edgesColor = "yellow",
  spheresColor = edgesColor,
  tubesRadius = 0.03,
  spheresRadius = 0.05,
  facesColor = "navy",
  bias = 1,
  interpolate = "linear",
  g = identity
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotGyrohull3d_+3A_points">points</code></td>
<td>
<p>matrix of 3D points, one point per row</p>
</td></tr>
<tr><td><code id="plotGyrohull3d_+3A_s">s</code></td>
<td>
<p>positive number, the radius of the Poincaré ball if
<code>model="M"</code>, otherwise, if <code>model="U"</code>, this number
defines the hyperbolic curvature (the smaller, the more curved)</p>
</td></tr>
<tr><td><code id="plotGyrohull3d_+3A_model">model</code></td>
<td>
<p>the hyperbolic model, either <code>"M"</code> (Möbius model, i.e.
Poincaré model) or <code>"U"</code> (Ungar model, i.e. hyperboloid model)</p>
</td></tr>
<tr><td><code id="plotGyrohull3d_+3A_iterations">iterations</code></td>
<td>
<p>argument passed to <code><a href="#topic+gyrotriangle">gyrotriangle</a></code></p>
</td></tr>
<tr><td><code id="plotGyrohull3d_+3A_n">n</code></td>
<td>
<p>argument passed to <code><a href="#topic+gyrotube">gyrotube</a></code> or
<code><a href="#topic+gyrosegment">gyrosegment</a></code>, the number of points for each edge</p>
</td></tr>
<tr><td><code id="plotGyrohull3d_+3A_edgesastubes">edgesAsTubes</code></td>
<td>
<p>Boolean, whether to represent tubular edges</p>
</td></tr>
<tr><td><code id="plotGyrohull3d_+3A_verticesasspheres">verticesAsSpheres</code></td>
<td>
<p>Boolean, whether to represent the vertices as
spheres</p>
</td></tr>
<tr><td><code id="plotGyrohull3d_+3A_edgescolor">edgesColor</code></td>
<td>
<p>a color for the edges</p>
</td></tr>
<tr><td><code id="plotGyrohull3d_+3A_spherescolor">spheresColor</code></td>
<td>
<p>a color for the spheres, if
<code>verticesAsSpheres = TRUE</code></p>
</td></tr>
<tr><td><code id="plotGyrohull3d_+3A_tubesradius">tubesRadius</code></td>
<td>
<p>radius of the tubes, if <code>edgesAsTubes = TRUE</code></p>
</td></tr>
<tr><td><code id="plotGyrohull3d_+3A_spheresradius">spheresRadius</code></td>
<td>
<p>radius of the spheres,
if <code>verticesAsSpheres = TRUE</code></p>
</td></tr>
<tr><td><code id="plotGyrohull3d_+3A_facescolor">facesColor</code></td>
<td>
<p>this argument sets the color of the faces; it can be
either a single color or a color palette, i.e. a vector of colors; if it
is a color palette, it will be passed to the argument <code>palette</code> of
<code><a href="#topic+gyrotriangle">gyrotriangle</a></code></p>
</td></tr>
<tr><td><code id="plotGyrohull3d_+3A_bias">bias</code>, <code id="plotGyrohull3d_+3A_interpolate">interpolate</code>, <code id="plotGyrohull3d_+3A_g">g</code></td>
<td>
<p>these arguments are passed to
<code><a href="#topic+gyrotriangle">gyrotriangle</a></code> in the case when <code>facesColor</code> is a color
palette</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value, called for plotting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gyro)
library(rgl)
# Triangular orthobicopula ####
points &lt;- rbind(
  c(1, -1/sqrt(3), sqrt(8/3)),
  c(1, -1/sqrt(3), -sqrt(8/3)),
  c(-1, -1/sqrt(3), sqrt(8/3)),
  c(-1, -1/sqrt(3), -sqrt(8/3)),
  c(0, 2/sqrt(3), sqrt(8/3)),
  c(0, 2/sqrt(3), -sqrt(8/3)),
  c(1, sqrt(3), 0),
  c(1, -sqrt(3), 0),
  c(-1, sqrt(3), 0),
  c(-1, -sqrt(3), 0),
  c(2, 0, 0),
  c(-2, 0, 0)
)
open3d(windowRect = c(50, 50, 562, 562))
view3d(zoom = 0.7)
plotGyrohull3d(points, s = 0.4)

# a non-convex polyhedron with triangular faces ####
vertices &lt;- rbind(
  c(-2.1806973249, -2.1806973249, -2.1806973249),
  c(-3.5617820682, 0.00000000000, 0.00000000000),
  c(0.00000000000, -3.5617820682, 0.00000000000),
  c(0.00000000000, 0.00000000000, -3.5617820682),
  c(-2.1806973249, -2.1806973249, 2.18069732490),
  c(0.00000000000, 0.00000000000, 3.56178206820),
  c(-2.1806973249, 2.18069732490, -2.1806973249),
  c(0.00000000000, 3.56178206820, 0.00000000000),
  c(-2.1806973249, 2.18069732490, 2.18069732490),
  c(2.18069732490, -2.1806973249, -2.1806973249),
  c(3.56178206820, 0.00000000000, 0.00000000000),
  c(2.18069732490, -2.1806973249, 2.18069732490),
  c(2.18069732490, 2.18069732490, -2.1806973249),
  c(2.18069732490, 2.18069732490, 2.18069732490))
triangles &lt;- 1 + rbind(
  c(3, 2, 0),
  c(0, 1, 3),
  c(2, 1, 0),
  c(4, 2, 5),
  c(5, 1, 4),
  c(4, 1, 2),
  c(6, 7, 3),
  c(3, 1, 6),
  c(6, 1, 7),
  c(5, 7, 8),
  c(8, 1, 5),
  c(7, 1, 8),
  c(9, 2, 3),
  c(3, 10, 9),
  c(9, 10, 2),
  c(5, 2, 11),
  c(11, 10, 5),
  c(2, 10, 11),
  c(3, 7, 12),
  c(12, 10, 3),
  c(7, 10, 12),
  c(13, 7, 5),
  c(5, 10, 13),
  c(13, 10, 7))
edges0 &lt;- do.call(c, lapply(1:nrow(triangles), function(i){
  face &lt;- triangles[i, ]
  list(
    sort(c(face[1], face[2])),
    sort(c(face[1], face[3])),
    sort(c(face[2], face[3]))
  )
}))
edges &lt;- do.call(rbind, edges0)
edges &lt;- edges[!duplicated(edges), ]
s &lt;- 2
library(rgl)
open3d(windowRect = c(50, 50, 1074, 562))
mfrow3d(1, 2)
view3d(zoom = 0.65)
for(i in 1:nrow(triangles)){
  triangle &lt;- triangles[i, ]
  A &lt;- vertices[triangle[1], ]
  B &lt;- vertices[triangle[2], ]
  C &lt;- vertices[triangle[3], ]
  gtriangle &lt;- gyrotriangle(A, B, C, s)
  shade3d(gtriangle, color = "violetred")
}
for(i in 1:nrow(edges)){
  edge &lt;- edges[i, ]
  A &lt;- vertices[edge[1], ]
  B &lt;- vertices[edge[2], ]
  gtube &lt;- gyrotube(A, B, s, radius = 0.06)
  shade3d(gtube, color = "darkviolet")
}
spheres3d(vertices, radius = 0.09, color = "deeppink")
# now plot the hyperbolic convex hull
next3d()
view3d(zoom = 0.65)
plotGyrohull3d(vertices, s)

# an example of color palette ####
if(require("trekcolors")) {
  pal &lt;- trek_pal("lcars_series")
} else {
  pal &lt;- hcl.colors(32L, palette = "Rocket")
}
set.seed(666) # 50 random points on sphere
if(require("uniformly")) {
  points &lt;- runif_on_sphere(50L, d = 3L)
} else {
  points &lt;- matrix(rnorm(50L * 3L), nrow = 50L, ncol = 3L)
  points &lt;- points / sqrt(apply(points, 1L, crossprod))
}
open3d(windowRect = c(50, 50, 562, 562))
plotGyrohull3d(
  points, edgesColor = "brown",
  facesColor = pal, g = function(u) 1-u^2
)
</code></pre>

<hr>
<h2 id='plotGyroMesh'>Plot hyperbolic mesh</h2><span id='topic+plotGyroMesh'></span>

<h3>Description</h3>

<p>Plot the hyperbolic version of a triangle 3D mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGyroMesh(
  mesh,
  s = 1,
  model = "U",
  iterations = 5,
  n = 100,
  edges = TRUE,
  edgesAsTubes = TRUE,
  edgesColor = "yellow",
  tubesRadius = 0.03,
  verticesAsSpheres = edgesAsTubes,
  spheresColor = edgesColor,
  spheresRadius = 0.05,
  facesColor = "navy",
  bias = 1,
  interpolate = "linear",
  g = identity
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotGyroMesh_+3A_mesh">mesh</code></td>
<td>
<p>there are two possibilities for this argument; it can be a
triangle <strong>rgl</strong> mesh (class <code>mesh3d</code>) or a list with (at least)
two fields: <code>vertices</code>, a numeric matrix with three columns, and
<code>faces</code>, an integer matrix with three columns</p>
</td></tr>
<tr><td><code id="plotGyroMesh_+3A_s">s</code></td>
<td>
<p>positive number, the radius of the Poincaré ball if
<code>model="M"</code>, otherwise, if <code>model="U"</code>, this number
defines the hyperbolic curvature (the smaller, the more curved)</p>
</td></tr>
<tr><td><code id="plotGyroMesh_+3A_model">model</code></td>
<td>
<p>the hyperbolic model, either <code>"M"</code> (Möbius model, i.e.
Poincaré model) or <code>"U"</code> (Ungar model, i.e. hyperboloid model)</p>
</td></tr>
<tr><td><code id="plotGyroMesh_+3A_iterations">iterations</code></td>
<td>
<p>argument passed to <code><a href="#topic+gyrotriangle">gyrotriangle</a></code></p>
</td></tr>
<tr><td><code id="plotGyroMesh_+3A_n">n</code></td>
<td>
<p>argument passed to <code><a href="#topic+gyrotube">gyrotube</a></code> or
<code><a href="#topic+gyrosegment">gyrosegment</a></code>, the number of points for each edge</p>
</td></tr>
<tr><td><code id="plotGyroMesh_+3A_edges">edges</code></td>
<td>
<p>Boolean, whether to plot the edges (as tubes or as lines)</p>
</td></tr>
<tr><td><code id="plotGyroMesh_+3A_edgesastubes">edgesAsTubes</code></td>
<td>
<p>Boolean, whether to plot tubular edges; if <code>FALSE</code>,
the edges are plotted as lines</p>
</td></tr>
<tr><td><code id="plotGyroMesh_+3A_edgescolor">edgesColor</code></td>
<td>
<p>a color for the edges</p>
</td></tr>
<tr><td><code id="plotGyroMesh_+3A_tubesradius">tubesRadius</code></td>
<td>
<p>radius of the tubes, if <code>edgesAsTubes = TRUE</code></p>
</td></tr>
<tr><td><code id="plotGyroMesh_+3A_verticesasspheres">verticesAsSpheres</code></td>
<td>
<p>Boolean, whether to plot the vertices as
spheres; if <code>FALSE</code>, the vertices are not plotted</p>
</td></tr>
<tr><td><code id="plotGyroMesh_+3A_spherescolor">spheresColor</code></td>
<td>
<p>a color for the spheres, if
<code>verticesAsSpheres = TRUE</code></p>
</td></tr>
<tr><td><code id="plotGyroMesh_+3A_spheresradius">spheresRadius</code></td>
<td>
<p>radius of the spheres,
if <code>verticesAsSpheres = TRUE</code></p>
</td></tr>
<tr><td><code id="plotGyroMesh_+3A_facescolor">facesColor</code></td>
<td>
<p>this argument sets the color of the faces; it can be
either a single color or a color palette, i.e. a vector of colors; if it
is a color palette, it will be passed to the argument <code>palette</code> of
<code><a href="#topic+gyrotriangle">gyrotriangle</a></code></p>
</td></tr>
<tr><td><code id="plotGyroMesh_+3A_bias">bias</code>, <code id="plotGyroMesh_+3A_interpolate">interpolate</code>, <code id="plotGyroMesh_+3A_g">g</code></td>
<td>
<p>these arguments are passed to
<code><a href="#topic+gyrotriangle">gyrotriangle</a></code> in the case when <code>facesColor</code> is a color
palette</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value, called for plotting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># hyperbolic great stellated dodecahedron
library(gyro)
library(rgl)
GSD &lt;- system.file(
  "extdata", "greatStellatedDodecahedron.ply", package = "gyro"
)
mesh &lt;- Rvcg::vcgPlyRead(GSD, updateNormals = FALSE, clean = FALSE)
open3d(windowRect = c(50, 50, 562, 562), zoom = 0.7)
plotGyroMesh(
  mesh,
  edgesAsTubes = FALSE, edgesColor = "black",
  facesColor = "firebrick1"
)
</code></pre>

<hr>
<h2 id='plotHdelaunay'>Plot hyperbolic Delaunay triangulation</h2><span id='topic+plotHdelaunay'></span>

<h3>Description</h3>

<p>Plot a hyperbolic Delaunay triangulation obtained
with <code><a href="#topic+hdelaunay">hdelaunay</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHdelaunay(
  hdel,
  vertices = TRUE,
  edges = TRUE,
  circle = TRUE,
  color = "random",
  distinctArgs = list(seedcolors = c("#ff0000", "#00ff00", "#0000ff")),
  randomArgs = list(hue = "random", luminosity = "bright")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotHdelaunay_+3A_hdel">hdel</code></td>
<td>
<p>an output of <code><a href="#topic+hdelaunay">hdelaunay</a></code></p>
</td></tr>
<tr><td><code id="plotHdelaunay_+3A_vertices">vertices</code></td>
<td>
<p>Boolean, whether to plot the vertices</p>
</td></tr>
<tr><td><code id="plotHdelaunay_+3A_edges">edges</code></td>
<td>
<p>Boolean, whether to plot the edges</p>
</td></tr>
<tr><td><code id="plotHdelaunay_+3A_circle">circle</code></td>
<td>
<p>Boolean, whether to plot the unit circle; ignored for the
Ungar model</p>
</td></tr>
<tr><td><code id="plotHdelaunay_+3A_color">color</code></td>
<td>
<p>this argument controls the colors of the triangles; it can be
<code>NA</code> for no color, <code>"random"</code> for random colors generated
with <code><a href="colorsGen.html#topic+randomColor">randomColor</a></code>, <code>"distinct"</code> for
distinct colors generated with
<code><a href="Polychrome.html#topic+createPalette">createPalette</a></code>, a single color,
a vector of colors (color <code>i</code> attributed to the <code>i</code>-th
triangle), or a vectorized function mapping each point in the unit
interval to a color</p>
</td></tr>
<tr><td><code id="plotHdelaunay_+3A_distinctargs">distinctArgs</code></td>
<td>
<p>if <code>color = "distinct"</code>, a list of arguments
passed to <code><a href="Polychrome.html#topic+createPalette">createPalette</a></code></p>
</td></tr>
<tr><td><code id="plotHdelaunay_+3A_randomargs">randomArgs</code></td>
<td>
<p>if <code>color = "random"</code>, a list of arguments passed
to <code><a href="colorsGen.html#topic+randomColor">randomColor</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No returned value, just generates a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gyro)
library(uniformly)
set.seed(666)

points &lt;- runif_in_sphere(35L, d = 2)
hdel &lt;- hdelaunay(points, model = "M")
plotHdelaunay(hdel)

points &lt;- runif_in_sphere(35L, d = 2, r = 0.7)
hdel &lt;- hdelaunay(points, model = "U")
plotHdelaunay(hdel)

# example with colors given by a function ####
library(gyro)
if(require("trekcolors")) {
  pal &lt;- trek_pal("klingon")
} else {
  pal &lt;- hcl.colors(32L, palette = "Rocket")
}

phi &lt;- (1 + sqrt(5)) / 2
theta &lt;- head(seq(0, pi/2, length.out = 11), -1L)
a &lt;- phi^((2*theta/pi)^0.8 - 1)
u &lt;- a * cos(theta)
v &lt;- a * sin(theta)
x &lt;- c(0, u, -v, -u, v)
y &lt;- c(0, v, u, -v, -u)
pts &lt;- cbind(x, y) / 1.03

hdel &lt;- hdelaunay(pts, model = "M")

fcolor &lt;- function(t){
  RGB &lt;- colorRamp(pal)(t)
  rgb(RGB[, 1L], RGB[, 2L], RGB[, 3L], maxColorValue = 255)
}

plotHdelaunay(
  hdel, vertices = FALSE, circle = FALSE, color = fcolor
)
</code></pre>

<hr>
<h2 id='tiling'>Hyperbolic tiling</h2><span id='topic+tiling'></span>

<h3>Description</h3>

<p>Draw a hyperbolic tiling of the Poincaré disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tiling(n, p, depth = 4, colors = c("navy", "yellow"), circle = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tiling_+3A_n">n</code>, <code id="tiling_+3A_p">p</code></td>
<td>
<p>two positive integers satisfying <code>1/n + 1/p &lt; 1/2</code></p>
</td></tr>
<tr><td><code id="tiling_+3A_depth">depth</code></td>
<td>
<p>positive integer, the number of recursions</p>
</td></tr>
<tr><td><code id="tiling_+3A_colors">colors</code></td>
<td>
<p>two colors to fill the hyperbolic tiling</p>
</td></tr>
<tr><td><code id="tiling_+3A_circle">circle</code></td>
<td>
<p>Boolean, whether to draw the unit circle</p>
</td></tr>
<tr><td><code id="tiling_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="plotrix.html#topic+draw.circle">draw.circle</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No returned value, just draws the hyperbolic tiling.
</p>


<h3>Note</h3>

<p>The higher value of <code>n</code>, the slower. And of course
increasing <code>depth</code> slows down the rendering. The value of <code>p</code>
has no influence on the speed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gyro)
tiling(3, 7, border = "orange")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
