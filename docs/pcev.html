<!DOCTYPE html><html><head><title>Help for package pcev</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pcev}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#computePCEV'><p>Principal Component of Explained Variance</p></a></li>
<li><a href='#estimatePcev'><p>Estimation of PCEV</p></a></li>
<li><a href='#methylation'><p>Methylation values around BLK gene</p></a></li>
<li><a href='#pcev-package'><p>pcev: A package for computing principal components of explained variance.</p></a></li>
<li><a href='#PcevObj'><p>Constructor functions for the different pcev objects</p></a></li>
<li><a href='#permutePval'><p>Permutation p-value</p></a></li>
<li><a href='#roysPval'><p>Roy's largest root exact test</p></a></li>
<li><a href='#wilksPval'><p>Wilks' lambda exact test</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Principal Component of Explained Variance</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Principal component of explained variance (PCEV) is a statistical
    tool for the analysis of a multivariate response vector. It is a dimension-
    reduction technique, similar to Principal component analysis (PCA), that seeks
    to maximize the proportion of variance (in the response vector) being explained
    by a set of covariates.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>RMTstat, stats, corpcor</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://github.com/GreenwoodLab/pcev">http://github.com/GreenwoodLab/pcev</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="http://github.com/GreenwoodLab/pcev/issues">http://github.com/GreenwoodLab/pcev/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-02-03 23:05:56 UTC; mturgeon</td>
</tr>
<tr>
<td>Author:</td>
<td>Maxime Turgeon [aut, cre],
  Aurelie Labbe [aut],
  Karim Oualkacha [aut],
  Stepan Grinek [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maxime Turgeon &lt;maxime.turgeon@mail.mcgill.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-02-03 23:14:47 UTC</td>
</tr>
</table>
<hr>
<h2 id='computePCEV'>Principal Component of Explained Variance</h2><span id='topic+computePCEV'></span>

<h3>Description</h3>

<p><code>computePCEV</code> computes the first PCEV and tests its significance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computePCEV(response, covariate, confounder, estimation = c("all", "block",
  "singular"), inference = c("exact", "permutation"), index = "adaptive",
  shrink = FALSE, nperm = 1000, Wilks = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computePCEV_+3A_response">response</code></td>
<td>
<p>A matrix of response variables.</p>
</td></tr>
<tr><td><code id="computePCEV_+3A_covariate">covariate</code></td>
<td>
<p>An array or a data frame of covariates.</p>
</td></tr>
<tr><td><code id="computePCEV_+3A_confounder">confounder</code></td>
<td>
<p>An array or data frame of confounders.</p>
</td></tr>
<tr><td><code id="computePCEV_+3A_estimation">estimation</code></td>
<td>
<p>Character string specifying which estimation method to use: <code>"all"</code>, 
<code>"block"</code> or <code>"singular"</code>. Default value is <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="computePCEV_+3A_inference">inference</code></td>
<td>
<p>Character string specifying which inference method to use: <code>"exact"</code> or 
<code>"permutation"</code>. Default value is <code>"exact"</code>.</p>
</td></tr>
<tr><td><code id="computePCEV_+3A_index">index</code></td>
<td>
<p>Only used if <code>estimation = "block"</code>. Default value is <code>"adapative"</code>. See 
details.</p>
</td></tr>
<tr><td><code id="computePCEV_+3A_shrink">shrink</code></td>
<td>
<p>Should we use a shrinkage estimate of the residual variance? Default value is 
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="computePCEV_+3A_nperm">nperm</code></td>
<td>
<p>The number of permutations to perform if <code>inference = "permutation"</code> or for the
Tracy-Widom empirical estimate (if <code>estimation = "singular"</code>).</p>
</td></tr>
<tr><td><code id="computePCEV_+3A_wilks">Wilks</code></td>
<td>
<p>Should we use a Wilks test instead of Roy's largest test? This is only implemented 
for a single covariate and with <code>estimation = "all"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main function. It computes the PCEV using either the classical method, block approach
or singular. A p-value is also computed, testing the significance of the PCEV.
</p>
<p>The p-value is computed using either a permutation approach or an exact test. The implemented 
exact tests use Wilks' Lambda (only for a single covariate) or Roy's Largest Root. The latter 
uses Johnstone's approximation to the null distribution. Note that for the block approach, only 
p-values obtained from a permutation procedure are available.
</p>
<p>When <code>estimation = "singular"</code>, the p-value is computed using a heuristic: using the method 
of moments and a small number of permutations (i.e. 25), a location-scale family of the 
Tracy-Widom distribution of order 1 is fitted to the null distribution. This fitted distribution 
is then used to compute p-values.
</p>
<p>When <code>estimation = "block"</code>, there are three different ways of specifying the blocks: 1) if 
<code>index</code> is a vector of the same length as the number of columns in <code>response</code>, then it 
is used to match each response to a block. 2) If <code>index</code> is a single positive integer, it is
understood as the number of blocks, and each response is matched to a block randomly. 3) If 
<code>index = "adaptive"</code> (the default), the number of blocks is chosen so that there are about 
n/2 responses per block, and each response is match to a block randomly. All other values of 
<code>index</code> should result in an error.
</p>


<h3>Value</h3>

<p>An object of class <code>Pcev</code> containing the first PCEV, the p-value, the estimate of 
the shrinkage factor, etc.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimatePcev">estimatePcev</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)
Y &lt;- matrix(rnorm(100*20), nrow=100)
X &lt;- rnorm(100)
pcev_out &lt;- computePCEV(Y, X)
pcev_out2 &lt;- computePCEV(Y, X, shrink = TRUE)
</code></pre>

<hr>
<h2 id='estimatePcev'>Estimation of PCEV</h2><span id='topic+estimatePcev'></span><span id='topic+estimatePcev.default'></span><span id='topic+estimatePcev.PcevClassical'></span><span id='topic+estimatePcev.PcevBlock'></span><span id='topic+estimatePcev.PcevSingular'></span>

<h3>Description</h3>

<p><code>estimatePcev</code> estimates the PCEV.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimatePcev(pcevObj, ...)

## Default S3 method:
estimatePcev(pcevObj, ...)

## S3 method for class 'PcevClassical'
estimatePcev(pcevObj, shrink, index, ...)

## S3 method for class 'PcevBlock'
estimatePcev(pcevObj, shrink, index, ...)

## S3 method for class 'PcevSingular'
estimatePcev(pcevObj, shrink, index, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimatePcev_+3A_pcevobj">pcevObj</code></td>
<td>
<p>A pcev object of class <code>PcevClassical</code>, <code>PcevBlock</code> or
<code>PcevSingular</code></p>
</td></tr>
<tr><td><code id="estimatePcev_+3A_...">...</code></td>
<td>
<p>Extra parameters.</p>
</td></tr>
<tr><td><code id="estimatePcev_+3A_shrink">shrink</code></td>
<td>
<p>Should we use a shrinkage estimate of the residual variance?</p>
</td></tr>
<tr><td><code id="estimatePcev_+3A_index">index</code></td>
<td>
<p>If <code>pcevObj</code> is of class <code>PcevBlock</code>, <code>index</code> is a vector
describing the block to which individual response variables correspond.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the variance components, the first PCEV, the 
eigenvalues of <code class="reqn">V_R^{-1}V_M</code> and the estimate of the shrinkage 
parameter <code class="reqn">\rho</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computePCEV">computePCEV</a></code>
</p>

<hr>
<h2 id='methylation'>Methylation values around BLK gene</h2><span id='topic+methylation'></span><span id='topic+pheno'></span><span id='topic+position'></span><span id='topic+index'></span><span id='topic+pheno2'></span><span id='topic+position2'></span><span id='topic+methylation2'></span>

<h3>Description</h3>

<p>A dataset containing methylation values for cell-separated samples. The methylation was measured
using bisulfite sequencing. The data also contains the genomic position of these CpG sites, as
well as a binary phenotype (i.e. whether the sample comes from a B cell).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>methylation

pheno

position

index

pheno2

position2

methylation2
</code></pre>


<h3>Format</h3>

<p>The data comes in four objects: 
</p>
 
<dl>
<dt>methylation</dt><dd><p>Matrix of methylation
values at 5,986 sites measured on 40 samples</p>
</dd> 
<dt>pheno</dt><dd><p>Vector of phenotype, indicating
whether the sample comes from a B cell</p>
</dd> 
<dt>position</dt><dd><p>Data frame recording the position of
each CpG site along the chromosome</p>
</dd> 
<dt>index</dt><dd><p>Index vector used in the computation of
PCEV-block</p>
</dd> 
<dt>methylation2</dt><dd><p>Matrix of methylation values at 1000 sites measured on 40
samples</p>
</dd> 
<dt>pheno2</dt><dd><p>Vector of phenotype, indicating the cell type of the sample (B cell, T cell, or Monocyte)</p>
</dd> 
<dt>position2</dt><dd><p>Data frame recording the position of each CpG site along the chromosome</p>
</dd> </dl>


<h3>Details</h3>

<p>Methylation was first measured at 24,068 sites, on 40 samples. Filtering was performed to keep
the 25% most variable sites. See the vignette for more detail.
</p>
<p>A second sample of the methylation dataset was extracted. This second dataset contains
methylation values at 1000 CpG dinucleotides.
</p>


<h3>Source</h3>

<p>Tomi Pastinen, McGill University, Genome Quebec.
</p>

<hr>
<h2 id='pcev-package'>pcev: A package for computing principal components of explained variance.</h2><span id='topic+pcev-package'></span>

<h3>Description</h3>

<p>PCEV is a statistical tool for the analysis of a multivariate response vector.
It is a dimension-reduction technique, similar to Principal Components
Analysis (PCA), which seeks the maximize the proportion of variance (in the
response vector) being explained by a set of covariates.
</p>


<h3>pcev functions</h3>

<p><code><a href="#topic+estimatePcev">estimatePcev</a></code>
<code><a href="#topic+computePCEV">computePCEV</a></code>
<code><a href="#topic+PcevObj">PcevObj</a></code>
<code><a href="#topic+permutePval">permutePval</a></code>
<code><a href="#topic+wilksPval">wilksPval</a></code>
<code><a href="#topic+roysPval">roysPval</a></code>
</p>

<hr>
<h2 id='PcevObj'>Constructor functions for the different pcev objects</h2><span id='topic+PcevObj'></span><span id='topic+PcevClassical'></span><span id='topic+PcevBlock'></span><span id='topic+PcevSingular'></span>

<h3>Description</h3>

<p><code>PcevClassical</code>, <code>PcevBlock</code> and <code>PcevSingular</code> create the pcev objects from the 
provided data that are necessary to compute the PCEV according to the user's 
parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PcevClassical(response, covariate, confounder)

PcevBlock(response, covariate, confounder)

PcevSingular(response, covariate, confounder)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PcevObj_+3A_response">response</code></td>
<td>
<p>A matrix of response variables.</p>
</td></tr>
<tr><td><code id="PcevObj_+3A_covariate">covariate</code></td>
<td>
<p>A matrix or a data frame of covariates.</p>
</td></tr>
<tr><td><code id="PcevObj_+3A_confounder">confounder</code></td>
<td>
<p>A matrix or data frame of confounders</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pcev object, of the class that corresponds to the estimation 
method. These objects are lists that contain the data necessary for
computation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimatePcev">estimatePcev</a></code>, <code><a href="#topic+computePCEV">computePCEV</a></code>
</p>

<hr>
<h2 id='permutePval'>Permutation p-value</h2><span id='topic+permutePval'></span><span id='topic+permutePval.default'></span><span id='topic+permutePval.PcevClassical'></span><span id='topic+permutePval.PcevBlock'></span><span id='topic+permutePval.PcevSingular'></span>

<h3>Description</h3>

<p>Computes a p-value using a permutation procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permutePval(pcevObj, ...)

## Default S3 method:
permutePval(pcevObj, ...)

## S3 method for class 'PcevClassical'
permutePval(pcevObj, shrink, index, nperm, ...)

## S3 method for class 'PcevBlock'
permutePval(pcevObj, shrink, index, nperm, ...)

## S3 method for class 'PcevSingular'
permutePval(pcevObj, shrink, index, nperm, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permutePval_+3A_pcevobj">pcevObj</code></td>
<td>
<p>A pcev object of class <code>PcevClassical</code> or <code>PcevSingular</code> 
<code>PcevBlock</code></p>
</td></tr>
<tr><td><code id="permutePval_+3A_...">...</code></td>
<td>
<p>Extra parameters.</p>
</td></tr>
<tr><td><code id="permutePval_+3A_shrink">shrink</code></td>
<td>
<p>Should we use a shrinkage estimate of the residual variance?</p>
</td></tr>
<tr><td><code id="permutePval_+3A_index">index</code></td>
<td>
<p>If <code>pcevObj</code> is of class <code>PcevBlock</code>, <code>index</code> is a
vector describing the block to which individual response variables
correspond.</p>
</td></tr>
<tr><td><code id="permutePval_+3A_nperm">nperm</code></td>
<td>
<p>The number of permutations to perform.</p>
</td></tr>
</table>

<hr>
<h2 id='roysPval'>Roy's largest root exact test</h2><span id='topic+roysPval'></span><span id='topic+roysPval.default'></span><span id='topic+roysPval.PcevClassical'></span><span id='topic+roysPval.PcevSingular'></span><span id='topic+roysPval.PcevBlock'></span>

<h3>Description</h3>

<p>In the classical domain of PCEV applicability this function uses Johnstone's
approximation to the null distribution of ' Roy's Largest Root statistic.
It uses a location-scale variant of the Tracy-Widom distribution of order 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roysPval(pcevObj, ...)

## Default S3 method:
roysPval(pcevObj, ...)

## S3 method for class 'PcevClassical'
roysPval(pcevObj, shrink, index, ...)

## S3 method for class 'PcevSingular'
roysPval(pcevObj, shrink, index, nperm, ...)

## S3 method for class 'PcevBlock'
roysPval(pcevObj, shrink, index, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roysPval_+3A_pcevobj">pcevObj</code></td>
<td>
<p>A pcev object of class <code>PcevClassical</code> or 
<code>PcevBlock</code></p>
</td></tr>
<tr><td><code id="roysPval_+3A_...">...</code></td>
<td>
<p>Extra parameters.</p>
</td></tr>
<tr><td><code id="roysPval_+3A_shrink">shrink</code></td>
<td>
<p>Should we use a shrinkage estimate of the residual variance?</p>
</td></tr>
<tr><td><code id="roysPval_+3A_index">index</code></td>
<td>
<p>If <code>pcevObj</code> is of class <code>PcevBlock</code>, <code>index</code> is
a vector describing the block to which individual response variables 
correspond</p>
</td></tr>
<tr><td><code id="roysPval_+3A_nperm">nperm</code></td>
<td>
<p>Number of permutations for Tracy-Widom empirical estimate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that if <code>shrink</code> is set to <code>TRUE</code>, the location-scale 
parameters are estimated using a small number of permutations.
</p>

<hr>
<h2 id='wilksPval'>Wilks' lambda exact test</h2><span id='topic+wilksPval'></span><span id='topic+wilksPval.default'></span><span id='topic+wilksPval.PcevClassical'></span><span id='topic+wilksPval.PcevSingular'></span><span id='topic+wilksPval.PcevBlock'></span>

<h3>Description</h3>

<p>Computes a p-value using Wilks' Lambda.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wilksPval(pcevObj, ...)

## Default S3 method:
wilksPval(pcevObj, ...)

## S3 method for class 'PcevClassical'
wilksPval(pcevObj, shrink, index, ...)

## S3 method for class 'PcevSingular'
wilksPval(pcevObj, shrink, index, ...)

## S3 method for class 'PcevBlock'
wilksPval(pcevObj, shrink, index, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wilksPval_+3A_pcevobj">pcevObj</code></td>
<td>
<p>A pcev object of class <code>PcevClassical</code> or 
<code>PcevBlock</code></p>
</td></tr>
<tr><td><code id="wilksPval_+3A_...">...</code></td>
<td>
<p>Extra parameters.</p>
</td></tr>
<tr><td><code id="wilksPval_+3A_shrink">shrink</code></td>
<td>
<p>Should we use a shrinkage estimate of the residual variance?</p>
</td></tr>
<tr><td><code id="wilksPval_+3A_index">index</code></td>
<td>
<p>If <code>pcevObj</code> is of class <code>PcevBlock</code>, <code>index</code> is
a vector describing the block to which individual response variables 
correspond.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null distribution of this test statistic is only known in the case of a
single covariate, and therefore this is the only case implemented.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
