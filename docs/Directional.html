<!DOCTYPE html><html><head><title>Help for package Directional</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Directional}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Directional-package'>
<p>This is an R package that provides methods for the statistical analysis of directional data, including massive (very large scale) directional data.</p></a></li>
<li><a href='#A+20test+20for+20testing+20the+20equality+20of+20the+20concentration+20parameters+20for+20ciruclar+20data'>
<p>A test for testing the equality of the concentration parameter among g samples, where g &gt;= 2 for ciruclar data</p></a></li>
<li><a href='#Angular+20central+20Gaussian+20random+20values+20simulation'>
<p>Angular central Gaussian random values simulation</p></a></li>
<li><a href='#Anova+20for+20+28hyper-+29spherical+20data'>
<p>Analysis of variance for (hyper-)spherical data</p></a></li>
<li><a href='#Anova+20for+20circular+20data'>
<p>Analysis of variance for circular data</p></a></li>
<li><a href='#BIC+20for+20the+20model+20based+20clustering+20using+20mixtures+20of+20von+20Mises-Fisher+20distributions'>
<p>BIC to choose the number of components in a model based clustering using mixtures of von Mises-Fisher distributions</p></a></li>
<li><a href='#Bootstrap+202-sample+20mean+20test+20for+20+28hyper-+29spherical+20data'>
<p>Bootstrap 2-sample mean test for (hyper-)spherical data</p></a></li>
<li><a href='#Bootstrap+202-sample+20mean+20test+20for+20circular+20data'>
<p>Bootstrap 2-sample mean test for circular data</p></a></li>
<li><a href='#Bootstrap+20ANOVA+20for+20+28hyper-+29spherical+20data'>
<p>Bootstrap ANOVA for (hyper-)spherical data</p></a></li>
<li><a href='#Bootstrap+20ANOVA+20for+20circular+20data'>
<p>Bootstrap ANOVA for circular data</p></a></li>
<li><a href='#Check+20visually+20whether+20matrix+20Fisher+20samples+20is+20correctly+20generated+20or+20not'>
<p>Check visually whether matrix Fisher samples is correctly generated or not.</p></a></li>
<li><a href='#Circular+20correlations+20between+20one+20and+20many+20circular+20variables'><p>Circular correlations between two circular variables</p></a></li>
<li><a href='#Circular+20correlations+20between+20two+20circular+20variables'><p>Circular correlations between two circular variables</p></a></li>
<li><a href='#Circular+20distance+20correlation+20between+20two+20circular+20variables'><p>Circular distance correlation between two circular variables</p></a></li>
<li><a href='#Circular+20or+20angular+20regression'>
<p>Circular or angular regression</p></a></li>
<li><a href='#Circular-linear+20correlation'>
<p>Circular-linear correlation</p></a></li>
<li><a href='#Column-wise+20MLE+20of+20the+20angular+20Gaussian+20and+20the+20von+20Mises+20Fisher+20distributions'>
<p>Column-wise MLE of the angular Gaussian and the von Mises Fisher distributions</p></a></li>
<li><a href='#Column-wise+20uniformity+20Watson+20test+20for+20circular+20data'>
<p>Column-wise uniformity tests for circular data</p></a></li>
<li><a href='#Contour+20plot+20+28on+20the+20plane+29+20of+20the+20ESAG+20and+20Kent+20distributions+20without+20any+20data'>
<p>Contour plot (on the plane) of the ESAG and Kent and ESAG distributions without any data</p></a></li>
<li><a href='#Contour+20plot+20+28on+20the+20sphere+29+20of+20a+20mixture+20of+20von+20Mises-Fisher+20distributions'>
<p>Contour plot (on the sphere) of a mixture of von Mises-Fisher distributions</p></a></li>
<li><a href='#Contour+20plot+20+28on+20the+20sphere+29+20of+20some+20spherical+20rotationally+20symmetric+20distributions'>
<p>Contour plot (on the sphere) of some spherical rotationally symmetric distributions</p></a></li>
<li><a href='#Contour+20plot+20+28on+20the+20sphere+29+20of+20the+20ESAG+20and+20Kent+20distributions'>
<p>Contour plot (on the sphere) of the ESAG and Kent distributions</p></a></li>
<li><a href='#Contour+20plot+20+28on+20the+20sphere+29+20of+20the+20SESPC+20distribution'>
<p>Contour plot (on the sphere) of the SESPC distribution</p></a></li>
<li><a href='#Contour+20plot+20of+20a+20mixture+20of+20von+20Mises-Fisher+20distributions+20model'>
<p>Contour plot of a mixture of von Mises-Fisher distributions model for spherical data only.</p></a></li>
<li><a href='#Contour+20plot+20of+20spherical+20data+20using+20a+20von+20Mises-Fisher+20kernel+20density+20estimate'>
<p>Contour plot of spherical data using a von Mises-Fisher kernel density estimate</p></a></li>
<li><a href='#Contour+20plots+20of+20some+20rotationally+20symmetric+20distributions'>
<p>Contour plots of some rotationally symmetric distributions</p></a></li>
<li><a href='#Conversion+20of+20cosines+20to+20azimuth+20and+20plunge'>
<p>Conversion of cosines to azimuth and plunge</p></a></li>
<li><a href='#Converting+20a+20rotation+20matrix+20on+20SO+283+29+20to+20an+20unsigned+20unit+20quaternion'>
<p>Converting a rotation matrix on SO(3) to an unsigned unit quaternion</p></a></li>
<li><a href='#Converting+20an+20unsigned+20unit+20quaternion+20to+20rotation+20matrix+20on+20SO+283+29'>
<p>Converting an unsigned unit quaternion to rotation matrix on SO(3)</p></a></li>
<li><a href='#Cross+20validation+20for+20estimating+20the+20classification+20rate'>
<p>Cross validation for estimating the classification rate</p></a></li>
<li><a href='#Cross+20validation+20in+20von+20Mises-Fisher+20discrminant+20analysis'>
<p>Cross validation for estimating the classification rate of a discrminant analysis for directional data assuming a von Mises-Fisher distribution</p></a></li>
<li><a href='#Cross+20validation+20with+20ESAG+20discrminant+20analysis'>
<p>Cross validation for estimating the classification rate of a discrminant analysis for directional data assuming an ESAG distribution</p></a></li>
<li><a href='#Cross+20validation+20with+20Purkayastha+20discrminant+20analysis'>
<p>Cross validation for estimating the classification rate of a discrminant analysis for directional data assuming a Purkayastha distribution</p></a></li>
<li><a href='#Cumulative+20distribution+20function+20of+20circular+20distributions'>
<p>Cumulative distribution function of circular distributions</p></a></li>
<li><a href='#Density+20of+20a+20mixture+20of+20von+20Mises-Fisher+20distributions'>
<p>Density of a mixture of von Mises-Fisher distributions</p></a></li>
<li><a href='#Density+20of+20some+20+28hyper-+29spherical+20distributions'>
<p>Density of some (hyper-)spherical distributions</p></a></li>
<li><a href='#Density+20of+20some+20circular+20distributions'>
<p>Density of some circular distributions</p></a></li>
<li><a href='#Density+20of+20the+20SESPC+20distribution'>
<p>Density of the SESPC distribution</p></a></li>
<li><a href='#Density+20of+20the+20spherical+20ESAG+20and+20Kent+20distributions'>
<p>Density of the spherical ESAG and Kent distributions</p></a></li>
<li><a href='#Density+20of+20the+20Wood+20bimodal+20distribution+20on+20the+20sphere'>
<p>Density of the Wood bimodal distribution on the sphere</p></a></li>
<li><a href='#Euclidean+20transformation'>
<p>Euclidean transformation</p></a></li>
<li><a href='#Euler+20angles+20+20from+20a+20rotation+20matrix+20on+20SO+283+29'>
<p>Compute the Euler angles from a rotation matrix on SO(3).</p></a></li>
<li><a href='#Forward+20Backward+20Early+20Dropping+20selection+20for+20circular+20data+20using+20the+20SPML+20regression'>
<p>Forward Backward Early Dropping selection for circular data using the SPML regression</p></a></li>
<li><a href='#Generate+20random+20folds+20for+20cross-validation'>
<p>Generate random folds for cross-validation</p></a></li>
<li><a href='#Generation+20of+20unit+20vector+28s+29+20with+20a+20given+20angle'>
<p>Generation of unit vector(s) with a given angle</p></a></li>
<li><a href='#Goodness+20of+20fit+20test+20for+20grouped+20data'>
<p>Goodness of fit test for grouped data</p></a></li>
<li><a href='#Habeck+27s+20rotation+20matrix+20generation'>
<p>Generation of three-dimensional random rotations using Habeck's algorithm.</p></a></li>
<li><a href='#Haversine+20distance+20matrix'>
<p>Harvesine distance matrix</p></a></li>
<li><a href='#Hypothesis+20test+20for+20IAG+20distribution+20over+20the+20ESAG+20distribution'>
<p>Hypothesis test for IAG distribution over the ESAG distribution</p></a></li>
<li><a href='#Hypothesis+20test+20for+20SIPC+20distribution+20over+20the+20SESPC+20distribution'>
<p>Hypothesis test for SIPC distribution over the SESPC distribution</p></a></li>
<li><a href='#Hypothesis+20test+20for+20von+20Mises-Fisher+20distribution+20over+20Kent+20distribution'>
<p>Hypothesis test for von Mises-Fisher distribution over Kent distribution</p></a></li>
<li><a href='#Interactive+203D+20plot+20of+20spherical+20data'>
<p>Interactive 3D plot of spherical data</p></a></li>
<li><a href='#Inverse+20of+20Lambert+27s+20equal+20area+20projection'>
<p>Inverse of Lambert's equal area projection</p></a></li>
<li><a href='#Inverse+20of+20the+20Euclidean+20transformation'>
<p>Inverse of the Euclidean transformation</p></a></li>
<li><a href='#k-NN+20algorithm+20using+20the+20arc+20cosinus+20distance'>
<p>k-NN algorithm using the arc cosinus distance</p></a></li>
<li><a href='#k-NN+20regression'>
<p>k-NN regression with Euclidean or (hyper-)spherical response and or predictor variables</p></a></li>
<li><a href='#Lambert+27s+20equal+20area+20projection'>
<p>Lambert's equal area projection</p></a></li>
<li><a href='#Logarithm+20of+20the+20Kent+20distribution+20normalizing+20constant'>
<p>Logarithm of the Kent distribution normalizing constant</p></a></li>
<li><a href='#Many+20simple+20circular+20or+20angular+20regressions'>
<p>Many simple circular or angular regressions</p></a></li>
<li><a href='#Maps+20of+20the+20world+20and+20the+20continents'>
<p>maps of the world and the continents</p></a></li>
<li><a href='#Mixtures+20of+20Von+20Mises-Fisher+20distributions'>
<p>Mixtures of Von Mises-Fisher distributions</p></a></li>
<li><a href='#MLE+20of+20+28hyper-+29spherical+20rotationally+20symmetric+20distributions'>
<p>MLE of (hyper-)spherical rotationally symmetric distributions</p></a></li>
<li><a href='#MLE+20of+20some+20circular+20distributions'>
<p>MLE of some circular distributions</p></a></li>
<li><a href='#MLE+20of+20some+20circular+20distributions+20with+20multiple+20samples'>
<p>MLE of some circular distributions with multiple samples</p></a></li>
<li><a href='#MLE+20of+20the+20ESAG+20distribution'>
<p>MLE of the ESAG distribution</p></a></li>
<li><a href='#MLE+20of+20the+20Kent+20distribution'>
<p>MLe of the Kent distribution</p></a></li>
<li><a href='#MLE+20of+20the+20Matrix+20Fisher+20distribution+20on+20SO+283+29'>
<p>MLE of the Matrix Fisher distribution on SO(3)</p></a></li>
<li><a href='#MLE+20of+20the+20Purkayashta+20distribution'><p>MLE of the Purkayashta distribution</p></a></li>
<li><a href='#MLE+20of+20the+20SESPC+20distribution'>
<p>MLE of the SESPC distribution</p></a></li>
<li><a href='#MLE+20of+20the+20Wood+20bimodal+20distribution+20on+20the+20sphere'>
<p>MLE of the Wood bimodal distribution on the sphere</p></a></li>
<li><a href='#Naive+20Bayes+20classifiers+20for+20circular+20data'>
<p>Naive Bayes classifiers for directional data</p></a></li>
<li><a href='#Normalised+20spatial+20median+20for+20directional+20data'>
<p>Normalised spatial median for directional data</p></a></li>
<li><a href='#Permutation+20based+202-sample+20mean+20test+20for+20+28hyper-+29spherical+20data'>
<p>Permutation based 2-sample mean test for (hyper-)spherical data</p></a></li>
<li><a href='#Permutation+20based+202-sample+20mean+20test+20for+20circular+20data'>
<p>Permutation based 2-sample mean test for circular data</p></a></li>
<li><a href='#Prediction+20in+20discriminant+20analysis+20based+20on+20ESAG+20distribution'>
<p>Prediction of a new observation using discriminant analysis based on ESAG distribution</p></a></li>
<li><a href='#Prediction+20in+20discriminant+20analysis+20based+20on+20Purkayastha+20distribution'>
<p>Prediction of a new observation using discriminant analysis based on Purkayastha distribution</p></a></li>
<li><a href='#Prediction+20in+20discriminant+20analysis+20based+20on+20von+20Mises-Fisher+20distribution'>
<p>Prediction of a new observation using discriminant analysis based on von Mises-Fisher distribution</p></a></li>
<li><a href='#Prediction+20with+20some+20naive+20Bayes+20classifiers+20for+20circular+20data'>
<p>Prediction with some naive Bayes classifiers for circular data</p></a></li>
<li><a href='#Projections+20based+20test+20of+20uniformity'>
<p>Projections based test of uniformity</p></a></li>
<li><a href='#Random+20sample+20of+20matrices+20in+20SO+28p+29'>
<p>Random sample of matrices in SO(p)</p></a></li>
<li><a href='#Rayleigh+27s+20test+20of+20uniformity'>
<p>Rayleigh's test of uniformity</p></a></li>
<li><a href='#Read+20a+20file+20as+20a+20Filebacked+20Big+20Matrix'>
<p>Read a file as a Filebacked Big Matrix</p></a></li>
<li><a href='#Rotation+20axis+20and+20angle+20of+20rotation+20given+20a+20rotation+20matrix'>
<p>Rotation axis and angle of rotation given a rotation matrix</p></a></li>
<li><a href='#Rotation+20matrix+20from+20a+20rotation+20axis+20and+20angle+20of+20rotation'>
<p>Rotation matrix from a rotation axis and angle of rotation</p></a></li>
<li><a href='#Rotation+20matrix+20on+20SO+283+29+20from+20three+20Euler+20angles'>
<p>Construct a rotation matrix on SO(3) from the Euler angles.</p></a></li>
<li><a href='#Rotation+20matrix+20to+20rotate+20a+20spherical+20vector+20along+20the+20direction+20of+20another'>
<p>Rotation matrix to rotate a spherical vector along the direction of another</p></a></li>
<li><a href='#Saddlepoint+20approximations+20of+20the+20Fisher-Bingham+20distributions'>
<p>Saddlepoint approximations of the Fisher-Bingham distributions</p></a></li>
<li><a href='#Simulation+20from+20a+20Bingham+20distribution+20using+20any+20symmetric+20matrix+20A'>
<p>Simulation from a Bingham distribution using any symmetric matrix A</p></a></li>
<li><a href='#Simulation+20from+20a+20Matrix+20Fisher+20distribution+20on+20SO+283+29'>
<p>Simulation from a Matrix Fisher distribution on SO(3)</p></a></li>
<li><a href='#Simulation+20of+20random+20values+20from+20a+20Bingham+20distribution'>
<p>Simulating from a Bingham distribution</p></a></li>
<li><a href='#Simulation+20of+20random+20values+20from+20a+20mixture+20of+20von+20Mises-Fisher+20distributions'>
<p>Simulation of random values from a mixture of von Mises-Fisher distributions</p></a></li>
<li><a href='#Simulation+20of+20random+20values+20from+20a+20spherical+20Fisher-Bingham+20distribution'>
<p>Simulation of random values from a spherical Fisher-Bingham distribution</p></a></li>
<li><a href='#Simulation+20of+20random+20values+20from+20a+20spherical+20Kent+20distribution'>
<p>Simulation of random values from a spherical Kent distribution</p></a></li>
<li><a href='#Simulation+20of+20random+20values+20from+20rotationally+20symmetric+20distributions'>
<p>Simulation of random values from rotationally symmetric distributions</p></a></li>
<li><a href='#Simulation+20of+20random+20values+20from+20some+20circular+20distributions'>
<p>Simulation of random values from some circular distributions</p></a></li>
<li><a href='#Simulation+20of+20random+20values+20from+20the+20ESAG+20distribution'>
<p>Simulation of random values from the ESAG distribution</p></a></li>
<li><a href='#Simulation+20of+20random+20values+20from+20the+20SESPC+20distribution'>
<p>Simulation of random values from the SESPC distribution</p></a></li>
<li><a href='#Spherical+20and+20hyper-spherical+20distance+20correlation'><p>Spherical and hyper-spherical distance correlation</p></a></li>
<li><a href='#Spherical+20and+20hyperspherical+20median'>
<p>Fast calculation of the spherical and hyperspherical median</p></a></li>
<li><a href='#Spherical+20regression+20using+20rotationally+20symmetric+20distributions'>
<p>Spherical regression using rotationally symmetric distributions</p></a></li>
<li><a href='#Spherical+20regression+20using+20the+20ESAG+20distribution'>
<p>Spherical regression using the ESAG distribution</p></a></li>
<li><a href='#Spherical+20regression+20using+20the+20SESPC+20distribution'>
<p>Spherical regression using the SESPC distribution</p></a></li>
<li><a href='#Spherical-spherical+20correlation'>
<p>Spherical-spherical correlation</p></a></li>
<li><a href='#Spherical-spherical+20regression'>
<p>Spherical-Spherical regression</p></a></li>
<li><a href='#Summary+20statistics+20for+20circular+20data'>
<p>Summary statistics for circular data</p></a></li>
<li><a href='#Summary+20statistics+20for+20grouped+20circular+20data'>
<p>Summary statistics for grouped circular data</p></a></li>
<li><a href='#Test+20for+20a+20given+20mean+20direction'>
<p>Test for a given mean direction</p></a></li>
<li><a href='#Test+20for+20equality+20of+20concentration+20parameters+20for+20spherical+20data'>
<p>Test for equality of concentration parameters for spherical data</p></a></li>
<li><a href='#Test+20of+20equality+20of+20the+20concentration+20parameters+20for+20circular+20data'>
<p>A test for testing the equality of the concentration parameter among g samples, where g &gt;= 2 for ciruclar data</p></a></li>
<li><a href='#The+20k-nearest+20neighbours+20using+20the+20cosinus+20distance'>
<p>The k-nearest neighbours using the cosinus distance</p></a></li>
<li><a href='#Transform+20unit+20vectors+20to+20angular+20data'>
<p>Transform unit vectors to angular data</p></a></li>
<li><a href='#Tuning+20of+20the+20bandwidth+20parameter+20in+20the+20von+20Mises+20kernel'>
<p>Tuning of the bandwidth parameter in the von Mises kernel for circular data</p></a></li>
<li><a href='#Tuning+20of+20the+20bandwidth+20parameter+20in+20the+20von+20Mises-Fisher+20kernel'>
<p>Tuning of the bandwidth parameter in the von Mises-Fisher kernel for (hyper-)spherical data</p></a></li>
<li><a href='#Tuning+20of+20the+20k-NN+20algorithm+20using+20the+20arc+20cosinus+20distance'>
<p>k-NN algorithm using the arc cosinus distance. Tuning the k neigbours</p></a></li>
<li><a href='#Tuning+20of+20the+20k-NN+20regression'>
<p>Tuning of the k-NN regression with Euclidean or (hyper-)spherical response and or predictor variables</p></a></li>
<li><a href='#Uniformity+20test+20for+20circular+20data'>
<p>Uniformity tests for circular data.</p></a></li>
<li><a href='#von+20Mises+20kernel+20density+20estimation'>
<p>Kernel density estimation of circular data with a von Mises kernel</p></a></li>
<li><a href='#von+20Mises-Fisher+20kernel+20density+20estimation+20for+20+28hyper-+29spherical+20data'>
<p>Kernel density estimation for (hyper-)spherical data using a von Mises-Fisher kernel</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Collection of Functions for Directional Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>6.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-05</td>
</tr>
<tr>
<td>Author:</td>
<td>Michail Tsagris, Giorgos Athineou, Christos Adam, Anamul Sajib, Eli Amson, Micah J. Waldstein</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michail Tsagris &lt;mtsagris@uoc.gr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions for directional data (including massive data, with millions of observations) analysis. Hypothesis testing, discriminant and regression analysis, MLE of distributions and more are included. The standard textbook for such data is the "Directional Statistics" by Mardia, K. V. and Jupp, P. E. (2000). Other references include a) Phillip J. Paine, Simon P. Preston Michail Tsagris and Andrew T. A. Wood (2018). "An elliptically symmetric angular Gaussian distribution". Statistics and Computing 28(3): 689-697. &lt;<a href="https://doi.org/10.1007%2Fs11222-017-9756-4">doi:10.1007/s11222-017-9756-4</a>&gt;. b) Tsagris M. and Alenazi A. (2019). "Comparison of discriminant analysis methods on the sphere". Communications in Statistics: Case Studies, Data Analysis and Applications 5(4):467&ndash;491. &lt;<a href="https://doi.org/10.1080%2F23737484.2019.1684854">doi:10.1080/23737484.2019.1684854</a>&gt;. c) P. J. Paine, S. P. Preston, M. Tsagris and Andrew T. A. Wood (2020). "Spherical regression models with general covariates and anisotropic errors". Statistics and Computing 30(1): 153&ndash;165. &lt;<a href="https://doi.org/10.1007%2Fs11222-019-09872-2">doi:10.1007/s11222-019-09872-2</a>&gt;. d) Tsagris M. and Alenazi A. (2024). "An investigation of hypothesis testing procedures for circular and spherical mean vectors". Communications in Statistics-Simulation and Computation, 53(3): 1387&ndash;1408. &lt;<a href="https://doi.org/10.1080%2F03610918.2022.2045499">doi:10.1080/03610918.2022.2045499</a>&gt;. e) Tsagris M. and Alzeley O. (2023). "Circular and spherical projected Cauchy distributions: A Novel Framework for Circular and Directional Data Modeling". &lt;<a href="https://doi.org/10.48550%2FarXiv.2302.02468">doi:10.48550/arXiv.2302.02468</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>bigstatsr, doParallel, foreach, ggplot2, grDevices, magrittr,
parallel, Rfast, Rfast2, Rnanoflann, rgl, rnaturalearth, sf</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bigreadr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-05 09:37:06 UTC; mtsag</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-05 10:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Directional-package'>
This is an R package that provides methods for the statistical analysis of directional data, including massive (very large scale) directional data.
</h2><span id='topic+Directional-package'></span>

<h3>Description</h3>

<p>Circular-linear regression, spherical-spherical regression, spherical regression, discriminant analysis, ANOVA for circular and (hyper-)spherical data, tests for eaquality of conentration parameters, maximum likelihood estimation of the parameters of many distributions, random values generation from various distributions, contour plots and many more functions are included.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> Directional</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 6.7</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-07-05</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Maintainers</h3>

<p>Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>Note</h3>

<p><b>Acknowledgments:</b>
</p>
<p>Professor Andy Wood and Dr Simon Preston from the university of Nottingham are highly appreciated for being my supervisors during my post-doc in directional data analysis.
</p>
<p>Dr Georgios Pappas (former postDoc at the university of Nottingham) helped me construct the contour plots of the von Mises-Fisher and the Kent distribution.
</p>
<p>Dr Christopher Fallaize and Dr Theo Kypraios from the university of Nottingham have provided a function for simulating from the Bingham distribution using rejection sampling.
So any questions regarding this function should be addressed to them.
</p>
<p>Dr Kwang-Rae Kim (post-doc at the university of Nottingham) answered some of my questions.
</p>
<p>Giorgos Borboudakis (PhD student at the university of Crete) pointed out to me a not so clear message in the algorithm of generating random values from the von Mises-Fisher distribution.
</p>
<p>Panagiotis (pronounced Panayiotis) Tzirakis (master student at the department of computer science in Heraklion during the 2013-2015 seasons) showed me how to perform parallel computing in R and he is greatly acknowledged and appreciated not only from me but from all the readers of this document. He also helped me with the vectorization of some contour plot functions.
</p>
<p>Professor John Kent from the university of Leeds is acknowledged for clarifying one thing with the ovalness parameter in his distribution.
</p>
<p>Phillip Paine (postdoc at the university of Nottingham) spotted that the function <code><a href="#topic+rfb">rfb</a></code> is rather slow and he suggested me to change it. The function has changed now and this is also due to Joshua Davis (from Carleton College, Northfield, MN) who spotted that mistakes could occur, due a vector not being a matrix.
</p>
<p>Professor Kurt Hornik from the Vienna university of economics and business is greatly acknowledged for his patience and contast help with this (and not only) R package.
</p>
<p>Manos Papadakis is also acknowledged for his programming tips and for his assistance with the &quot;htest&quot; class object.
</p>
<p>Dr Mojgan Golzy spotted a mistake in the function <code><a href="#topic+desag">desag</a></code> and Michail is very happy for that.
</p>
<p>Lisette de Jonge-Hoekstra from the University of Groningen found a wrong sentence in the help file of function <code><a href="#topic+spml.reg">spml.reg</a></code> which is now deleted.
</p>
<p>Peter Harremoes from the Copenhagen Business College spotted a mistake in the confidence interval of the function  <code><a href="#topic+circ.summary">circ.summary</a></code> which has now been corrected.
</p>
<p>Dr Gregory Emvalomatis from the University of Crete helped me understand better the EM algorithm for mixture models and I fixed a bug in the function <code><a href="#topic+mixvmf.mle">mixvmf.mle</a></code>.
</p>
<p>Kinley Russell, PhD student at the Johns Hopkins University School of Medicine, suggested that I include bootstrap ANOVA functions.
</p>
<p>Sia Ahmadi found a mistake in the function <code><a href="#topic+conc.test">conc.test</a></code> which has now been corrected.
</p>
<p>If you want more information on many of these algorithms see Chapters 9 and 10 in the following document.
https://www.researchgate.net/publication/324363311_Multivariate_data_analysis_in_R
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>, Giorgos Athineou &lt;gioathineou@gmail.com&gt;, Christos Adam <a href="mailto:pada4m4@gmail.com">pada4m4@gmail.com</a>,
Anamul Sajib &lt;sajibstat@du.ac.bd&gt;, Eli Amson &lt;eli.amson1988@gmail.com&gt; and Micah J. Waldstein &lt;micah@waldste.in&gt;.
</p>


<h3>References</h3>

<p>Mardia, K. V. and Jupp, P. E. (2000). Directional statistics. Chicester: John Wiley and Sons.
</p>

<hr>
<h2 id='A+20test+20for+20testing+20the+20equality+20of+20the+20concentration+20parameters+20for+20ciruclar+20data'>
A test for testing the equality of the concentration parameter among g samples, where g &gt;= 2 for ciruclar data
</h2><span id='topic+tang.conc'></span>

<h3>Description</h3>

<p>A test for testing the equality of the concentration parameter among g samples, where g &gt;= 2 for ciruclar data. It is a tangential approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tang.conc(u, ina, rads = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="A+2B20test+2B20for+2B20testing+2B20the+2B20equality+2B20of+2B20the+2B20concentration+2B20parameters+2B20for+2B20ciruclar+2B20data_+3A_u">u</code></td>
<td>

<p>A numeric vector containing the values of all samples.
</p>
</td></tr>
<tr><td><code id="A+2B20test+2B20for+2B20testing+2B20the+2B20equality+2B20of+2B20the+2B20concentration+2B20parameters+2B20for+2B20ciruclar+2B20data_+3A_ina">ina</code></td>
<td>

<p>A numerical variable or factor indicating the groups of each value.
</p>
</td></tr>
<tr><td><code id="A+2B20test+2B20for+2B20testing+2B20the+2B20equality+2B20of+2B20the+2B20concentration+2B20parameters+2B20for+2B20ciruclar+2B20data_+3A_rads">rads</code></td>
<td>

<p>If the data are in radians this should be TRUE and FALSE otherwise.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This test works for circular data.
</p>


<h3>Value</h3>

<p>This is an &quot;htest&quot;class object. Thus it returns a list including:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>

<p>The test statistic value.
</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>

<p>The degrees of freedom of the test.
</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>

<p>The p-value of the test.
</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>

<p>A character with the alternative hypothesis.
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>A character with the test used.
</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>

<p>A character vector with two elements.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Mardia, K. V. and Jupp, P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
Fisher, N. I. (1995). Statistical analysis of circular data. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+embed.circaov">embed.circaov</a>, <a href="#topic+hcf.circaov">hcf.circaov</a>, <a href="#topic+lr.circaov">lr.circaov</a>, <a href="#topic+het.circaov">het.circaov</a>, <a href="#topic+conc.test">conc.test</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvonmises(100, 2.4, 15)
ina &lt;- rep(1:4,each = 25)
tang.conc(x, ina, rads = TRUE)
</code></pre>

<hr>
<h2 id='Angular+20central+20Gaussian+20random+20values+20simulation'>
Angular central Gaussian random values simulation
</h2><span id='topic+racg'></span>

<h3>Description</h3>

<p>Angular central Gaussian random values simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>racg(n, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Angular+2B20central+2B20Gaussian+2B20random+2B20values+2B20simulation_+3A_n">n</code></td>
<td>

<p>The sample size, a numerical value.
</p>
</td></tr>
<tr><td><code id="Angular+2B20central+2B20Gaussian+2B20random+2B20values+2B20simulation_+3A_sigma">sigma</code></td>
<td>

<p>The covariance matrix in <code class="reqn">R^d</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm uses univariate normal random values and transforms them to multivariate via a spectral decomposition.
The vectors are then scaled to have unit length. 
</p>


<h3>Value</h3>

<p>A matrix with the simulated data.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>. 
</p>


<h3>References</h3>

<p>Tyler D. E. (1987). Statistical analysis for the angular central Gaussian distribution on the sphere. Biometrika 74(3): 579&ndash;589. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+acg.mle">acg.mle</a>, <a href="#topic+rvmf">rvmf</a>, <a href="#topic+rvonmises">rvonmises</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- cov( iris[, 1:4] )
x &lt;- racg(100, s)
Directional::acg.mle(x)  
Directional::vmf.mle(x)  
## the concentration parameter, kappa, is very low, close to zero, as expected.
</code></pre>

<hr>
<h2 id='Anova+20for+20+28hyper-+29spherical+20data'>
Analysis of variance for (hyper-)spherical data
</h2><span id='topic+hcf.aov'></span><span id='topic+lr.aov'></span><span id='topic+embed.aov'></span><span id='topic+het.aov'></span><span id='topic+hclr.aov'></span>

<h3>Description</h3>

<p>Analysis of variance for (hyper-)spherical data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hcf.aov(x, ina, fc = TRUE)
hclr.aov(x, ina)
lr.aov(x, ina)
embed.aov(x, ina)
het.aov(x, ina)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Anova+2B20for+2B20+2B28hyper-+2B29spherical+2B20data_+3A_x">x</code></td>
<td>

<p>A matrix with the data in Euclidean coordinates, i.e. unit vectors.
</p>
</td></tr>
<tr><td><code id="Anova+2B20for+2B20+2B28hyper-+2B29spherical+2B20data_+3A_ina">ina</code></td>
<td>

<p>A numerical variable or a factor indicating the group of each vector.
</p>
</td></tr>
<tr><td><code id="Anova+2B20for+2B20+2B28hyper-+2B29spherical+2B20data_+3A_fc">fc</code></td>
<td>

<p>A boolean that indicates whether a corrected F test should be used or not.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The high concentration (hcf.aov), high concentration log-likelihood ratio (hclr.aov),
log-likelihood ratio (lr.aov), embedding approach (embed.aov) or the non equal
concentration parameters approach (het.aov) is used.
</p>


<h3>Value</h3>

<p>This is an &quot;htest&quot;class object. Thus it returns a list including:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>

<p>The test statistic value.
</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>

<p>The degree(s) of freedom of the test.
</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>

<p>The p-value of the test.
</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>

<p>A character with the alternative hypothesis.
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>A character with the test used.
</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>

<p>A character vector with two elements.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>
and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Mardia K. V. and Jupp P. E. (2000). Directional statistics.
Chicester: John Wiley &amp; Sons.
</p>
<p>Rumcheva P. and Presnell B. (2017). An improved test of equality of mean
directions for the Langevin-von Mises-Fisher distribution.
Australian &amp; New Zealand Journal of Statistics, 59(1): 119&ndash;135.
</p>
<p>Tsagris M. and Alenazi A. (2024). An investigation of hypothesis testing procedures for circular
and spherical mean vectors. Communications in Statistics-Simulation and Computation, 53(3): 1387&ndash;1408.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hcf.boot">hcf.boot</a>, <a href="#topic+hcfboot">hcfboot</a>, <a href="#topic+hclr.circaov">hclr.circaov</a>,
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvmf(60, rnorm(3), 15)
ina &lt;- rep(1:3, each = 20)
hcf.aov(x, ina)
hcf.aov(x, ina, fc = FALSE)
lr.aov(x, ina)
embed.aov(x, ina)
het.aov(x, ina)
</code></pre>

<hr>
<h2 id='Anova+20for+20circular+20data'>
Analysis of variance for circular data
</h2><span id='topic+hcf.circaov'></span><span id='topic+hclr.circaov'></span><span id='topic+lr.circaov'></span><span id='topic+embed.circaov'></span><span id='topic+het.circaov'></span>

<h3>Description</h3>

<p>Analysis of variance for circular data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hcf.circaov(u, ina, rads = FALSE)
hclr.circaov(u, ina, rads = FALSE)
lr.circaov(u, ina, rads = FALSE)
het.circaov(u, ina, rads = FALSE)
embed.circaov(u, ina, rads = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Anova+2B20for+2B20circular+2B20data_+3A_u">u</code></td>
<td>

<p>A numeric vector containing the data.
</p>
</td></tr>
<tr><td><code id="Anova+2B20for+2B20circular+2B20data_+3A_ina">ina</code></td>
<td>

<p>A numerical or factor variable indicating the group of each value.
</p>
</td></tr>
<tr><td><code id="Anova+2B20for+2B20circular+2B20data_+3A_rads">rads</code></td>
<td>

<p>If the data are in radians, this should be TRUE and FALSE otherwise.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The high concentration (hcf.circaov), high concentration likelihood ratio (hclr.aov),
log-likelihood ratio (lr.circaov), embedding approach (embed.circaov) or the non equal
concentration parameters approach (het.circaov) is used.
</p>


<h3>Value</h3>

<p>This is an &quot;htest&quot;class object. Thus it returns a list including:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>

<p>The test statistic value.
</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>

<p>The degree(s) of freedom of the test.
</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>

<p>The p-value of the test.
</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>

<p>A character with the alternative hypothesis.
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>A character with the test used.
</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>

<p>A character vector with two elements.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>
and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Mardia, K. V. and Jupp, P. E. (2000). Directional statistics.
Chicester: John Wiley &amp; Sons.
</p>
<p>Rumcheva P. and Presnell B. (2017). An improved test of equality of mean directions for
the Langevin-von Mises-Fisher distribution. Australian &amp; New Zealand Journal of Statistics, 59(1): 119&ndash;135.
</p>
<p>Tsagris M. and Alenazi A. (2024). An investigation of hypothesis testing procedures for circular
and spherical mean vectors. Communications in Statistics-Simulation and Computation, 53(3): 1387&ndash;1408.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hclr.aov">hclr.aov</a>, <a href="#topic+hcfcirc.boot">hcfcirc.boot</a>, <a href="#topic+hcfcircboot">hcfcircboot</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvonmises(100, 2.4, 15)
ina &lt;- rep(1:4,each = 25)
hcf.circaov(x, ina, rads = TRUE)
lr.circaov(x, ina, rads = TRUE)
het.circaov(x, ina, rads = TRUE)
embed.circaov(x, ina, rads = TRUE)
hclr.circaov(x, ina, rads = TRUE)
</code></pre>

<hr>
<h2 id='BIC+20for+20the+20model+20based+20clustering+20using+20mixtures+20of+20von+20Mises-Fisher+20distributions'>
BIC to choose the number of components in a model based clustering using mixtures of von Mises-Fisher distributions
</h2><span id='topic+bic.mixvmf'></span>

<h3>Description</h3>

<p>BIC to choose the number of components in a model based clustering using mixtures of von Mises-Fisher distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bic.mixvmf(x, G = 5, n.start = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BIC+2B20for+2B20the+2B20model+2B20based+2B20clustering+2B20using+2B20mixtures+2B20of+2B20von+2B20Mises-Fisher+2B20distributions_+3A_x">x</code></td>
<td>

<p>A matrix containing directional data.
</p>
</td></tr>
<tr><td><code id="BIC+2B20for+2B20the+2B20model+2B20based+2B20clustering+2B20using+2B20mixtures+2B20of+2B20von+2B20Mises-Fisher+2B20distributions_+3A_g">G</code></td>
<td>

<p>The maximum number of clusters to be tested. Default value is 5.
</p>
</td></tr>
<tr><td><code id="BIC+2B20for+2B20the+2B20model+2B20based+2B20clustering+2B20using+2B20mixtures+2B20of+2B20von+2B20Mises-Fisher+2B20distributions_+3A_n.start">n.start</code></td>
<td>

<p>The number of random starts to try. See also R's built-in function <code><a href="stats.html#topic+kmeans">kmeans</a></code> for more information about this.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the data are not unit vectors, they are transformed into unit vectors.
</p>


<h3>Value</h3>

<p>A plot of the BIC values and a list including:
</p>
<table>
<tr><td><code>BIC</code></td>
<td>

<p>The BIC values for all the models tested.
</p>
</td></tr>
<tr><td><code>runtime</code></td>
<td>

<p>The run time of the algorithm. A numeric vector. The first element is the user time, the second element is the system time and the third element is the elapsed time.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Hornik, K. and Grun, B. (2014). movMF: An R package for fitting mixtures of von Mises-Fisher distributions. Journal of Statistical Software, 58(10):1&ndash;31.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mixvmf.mle">mixvmf.mle</a>, <a href="#topic+rmixvmf">rmixvmf</a>, <a href="#topic+mixvmf.contour">mixvmf.contour</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.matrix( iris[, 1:4] )
x &lt;- x / sqrt( rowSums(x^2) )
bic.mixvmf(x)
</code></pre>

<hr>
<h2 id='Bootstrap+202-sample+20mean+20test+20for+20+28hyper-+29spherical+20data'>
Bootstrap 2-sample mean test for (hyper-)spherical data
</h2><span id='topic+hcf.boot'></span><span id='topic+lr.boot'></span><span id='topic+hclr.boot'></span><span id='topic+embed.boot'></span><span id='topic+het.boot'></span>

<h3>Description</h3>

<p>Bootstrap 2-sample mean test for (hyper-)spherical data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hcf.boot(x1, x2, fc = TRUE, B = 999)
lr.boot(x1, x2, B = 999)
hclr.boot(x1, x2, B = 999)
embed.boot(x1, x2, B = 999)
het.boot(x1, x2, B = 999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bootstrap+2B202-sample+2B20mean+2B20test+2B20for+2B20+2B28hyper-+2B29spherical+2B20data_+3A_x1">x1</code></td>
<td>

<p>A matrix with the data in Euclidean coordinates, i.e. unit vectors.
</p>
</td></tr>
<tr><td><code id="Bootstrap+2B202-sample+2B20mean+2B20test+2B20for+2B20+2B28hyper-+2B29spherical+2B20data_+3A_x2">x2</code></td>
<td>

<p>A matrix with the data in Euclidean coordinates, i.e. unit vectors.
</p>
</td></tr>
<tr><td><code id="Bootstrap+2B202-sample+2B20mean+2B20test+2B20for+2B20+2B28hyper-+2B29spherical+2B20data_+3A_fc">fc</code></td>
<td>

<p>A boolean that indicates whether a corrected F test should be used or not.
</p>
</td></tr>
<tr><td><code id="Bootstrap+2B202-sample+2B20mean+2B20test+2B20for+2B20+2B28hyper-+2B29spherical+2B20data_+3A_b">B</code></td>
<td>

<p>The number of bootstraps to perform.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The high concentration (hcf.boot), log-likelihood ratio (lr.boot), high concentration
log-likelihood ratio (hclr.boot), embedding approach (embed.boot) or the non equal
concentration parameters approach (het.boot) is used.
</p>


<h3>Value</h3>

<p>This is an &quot;htest&quot;class object. Thus it returns a list including:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>

<p>The test statistic value.
</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>

<p>The degrees of freedom of the test. Since these are bootstrap based tests this is &quot;NA&quot;.
</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>

<p>The p-value of the test.
</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>

<p>A character with the alternative hypothesis.
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>A character with the test used.
</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>

<p>A character vector with two elements.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Mardia K. V. and Jupp P. E. (2000). Directional statistics.
Chicester: John Wiley &amp; Sons.
</p>
<p>Rumcheva P. and Presnell B. (2017). An improved test of equality of mean directions
for the Langevin-von Mises-Fisher distribution. Australian &amp; New Zealand Journal of Statistics, 59(1): 119&ndash;135.
</p>
<p>Tsagris M. and Alenazi A. (2024). An investigation of hypothesis testing procedures for circular
and spherical mean vectors. Communications in Statistics-Simulation and Computation, 53(3): 1387&ndash;1408.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hcf.aov">hcf.aov</a>, <a href="#topic+hcf.perm">hcf.perm</a>, <a href="#topic+hcfboot">hcfboot</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvmf(60, rnorm(3), 15)
ina &lt;- rep(1:2, each = 30)
x1 &lt;- x[ina == 1, ]
x2 &lt;- x[ina == 2, ]
hcf.boot(x1, x2)
lr.boot(x1, x2)
het.boot(x1, x2)
</code></pre>

<hr>
<h2 id='Bootstrap+202-sample+20mean+20test+20for+20circular+20data'>
Bootstrap 2-sample mean test for circular data
</h2><span id='topic+hcfcirc.boot'></span><span id='topic+lrcirc.boot'></span><span id='topic+hclrcirc.boot'></span><span id='topic+embedcirc.boot'></span><span id='topic+hetcirc.boot'></span>

<h3>Description</h3>

<p>Bootstrap 2-sample mean test for circular data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hcfcirc.boot(u1, u2, rads = TRUE, B = 999)
lrcirc.boot(u1, u2, rads = TRUE, B = 999)
hclrcirc.boot(u1, u2, rads = TRUE, B = 999)
embedcirc.boot(u1, u2, rads = TRUE, B = 999)
hetcirc.boot(u1, u2, rads = TRUE, B = 999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bootstrap+2B202-sample+2B20mean+2B20test+2B20for+2B20circular+2B20data_+3A_u1">u1</code></td>
<td>

<p>A numeric vector containing the data of the first sample.
</p>
</td></tr>
<tr><td><code id="Bootstrap+2B202-sample+2B20mean+2B20test+2B20for+2B20circular+2B20data_+3A_u2">u2</code></td>
<td>

<p>A numeric vector containing the data of the first sample.
</p>
</td></tr>
<tr><td><code id="Bootstrap+2B202-sample+2B20mean+2B20test+2B20for+2B20circular+2B20data_+3A_rads">rads</code></td>
<td>

<p>If the data are in radians, this should be TRUE and FALSE otherwise.
</p>
</td></tr>
<tr><td><code id="Bootstrap+2B202-sample+2B20mean+2B20test+2B20for+2B20circular+2B20data_+3A_b">B</code></td>
<td>

<p>The number of bootstraps to perform.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The high concentration (hcfcirc.boot), the log-likelihood ratio test (lrcirc.boot),
high concentration log-likelihood ratio (hclrcirc.boot), embedding approach (embedcirc.boot),
or the non equal concentration parameters approach (hetcirc.boot) is used.
</p>


<h3>Value</h3>

<p>This is an &quot;htest&quot;class object. Thus it returns a list including:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>

<p>The test statistic value.
</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>

<p>The degrees of freedom of the test. Since these are bootstrap based tests this is &quot;NA&quot;.
</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>

<p>The p-value of the test.
</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>

<p>A character with the alternative hypothesis.
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>A character with the test used.
</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>

<p>A character vector with two elements.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Mardia K. V. and Jupp P. E. (2000). Directional statistics.
Chicester: John Wiley &amp; Sons.
</p>
<p>Rumcheva P. and Presnell B. (2017). An improved test of equality of mean directions for the
Langevin-von Mises-Fisher distribution. Australian &amp; New Zealand Journal of Statistics, 59(1): 119&ndash;135.
</p>
<p>Tsagris M. and Alenazi A. (2024). An investigation of hypothesis testing procedures for circular
and spherical mean vectors. Communications in Statistics-Simulation and Computation, 53(3): 1387&ndash;1408.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hcf.circaov">hcf.circaov</a>, <a href="#topic+hcfcircboot">hcfcircboot</a>, <a href="#topic+het.aov">het.aov</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u1 &lt;- rvonmises(20, 2.4, 5)
u2 &lt;- rvonmises(20, 2.4, 10)
hcfcirc.boot(u1, u2)
</code></pre>

<hr>
<h2 id='Bootstrap+20ANOVA+20for+20+28hyper-+29spherical+20data'>
Bootstrap ANOVA for (hyper-)spherical data
</h2><span id='topic+hcfboot'></span><span id='topic+hetboot'></span>

<h3>Description</h3>

<p>Bootstrap ANOVA for (hyper-)spherical data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hcfboot(x, ina, B = 999)
hetboot(x, ina, B = 999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bootstrap+2B20ANOVA+2B20for+2B20+2B28hyper-+2B29spherical+2B20data_+3A_x">x</code></td>
<td>

<p>A matrix with the combined data (from all groups) in Euclidean coordinates, i.e. unit vectors.
</p>
</td></tr>
<tr><td><code id="Bootstrap+2B20ANOVA+2B20for+2B20+2B28hyper-+2B29spherical+2B20data_+3A_ina">ina</code></td>
<td>

<p>The grouping variables. A factor or a numerical vector specifying the groups to which each observation belongs to.
</p>
</td></tr>
<tr><td><code id="Bootstrap+2B20ANOVA+2B20for+2B20+2B28hyper-+2B29spherical+2B20data_+3A_b">B</code></td>
<td>

<p>The number of bootstraps to perform.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The high concentration (hcfboot), or the non equal
concentration parameters approach (hetboot) is used.
</p>


<h3>Value</h3>

<p>This is an &quot;htest&quot;class object. Thus it returns a list including:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>

<p>The test statistic value.
</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>

<p>The degrees of freedom of the test. Since these are bootstrap based tests this is &quot;NA&quot;.
</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>

<p>The p-value of the test.
</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>

<p>A character with the alternative hypothesis.
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>A character with the test used.
</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>

<p>A character vector with two elements.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Mardia K. V. and Jupp P. E. (2000). Directional statistics.
Chicester: John Wiley &amp; Sons.
</p>
<p>Rumcheva P. and Presnell B. (2017). An improved test of equality of mean directions
for the Langevin-von Mises-Fisher distribution. Australian &amp; New Zealand Journal of Statistics, 59(1): 119&ndash;135.
</p>
<p>Tsagris M. and Alenazi A. (2024). An investigation of hypothesis testing procedures for circular
and spherical mean vectors. Communications in Statistics-Simulation and Computation, 53(3): 1387&ndash;1408.</p>


<h3>See Also</h3>

<p><code><a href="#topic+hcf.boot">hcf.boot</a>, <a href="#topic+hcf.aov">hcf.aov</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvmf(60, rnorm(3), 10)
ina &lt;- rep(1:3, each = 20)
hcfboot(x, ina)
</code></pre>

<hr>
<h2 id='Bootstrap+20ANOVA+20for+20circular+20data'>
Bootstrap ANOVA for circular data
</h2><span id='topic+hcfcircboot'></span><span id='topic+hetcircboot'></span>

<h3>Description</h3>

<p>Bootstrap ANOVA for circular data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hcfcircboot(u, ina, rads = TRUE, B = 999)
hetcircboot(u, ina, rads = TRUE, B = 999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bootstrap+2B20ANOVA+2B20for+2B20circular+2B20data_+3A_u">u</code></td>
<td>

<p>A numeric vector containing the data of all groups.
</p>
</td></tr>
<tr><td><code id="Bootstrap+2B20ANOVA+2B20for+2B20circular+2B20data_+3A_ina">ina</code></td>
<td>

<p>The grouping variables. A factor or a numerical vector specifying the groups to which each observation belongs to.
</p>
</td></tr>
<tr><td><code id="Bootstrap+2B20ANOVA+2B20for+2B20circular+2B20data_+3A_rads">rads</code></td>
<td>

<p>If the data are in radians, this should be TRUE and FALSE otherwise.
</p>
</td></tr>
<tr><td><code id="Bootstrap+2B20ANOVA+2B20for+2B20circular+2B20data_+3A_b">B</code></td>
<td>

<p>The number of bootstraps to perform.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The high concentration (hcfcircboot), or the non equal concentration
parameters approach (hetcircboot) is used.
</p>


<h3>Value</h3>

<p>This is an &quot;htest&quot;class object. Thus it returns a list including:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>

<p>The test statistic value.
</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>

<p>The degrees of freedom of the test. Since these are bootstrap based tests this is &quot;NA&quot;.
</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>

<p>The p-value of the test.
</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>

<p>A character with the alternative hypothesis.
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>A character with the test used.
</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>

<p>A character vector with two elements.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Mardia K. V. and Jupp P. E. (2000). Directional statistics.
Chicester: John Wiley &amp; Sons.
</p>
<p>Rumcheva P. and Presnell B. (2017). An improved test of equality of mean directions for the
Langevin-von Mises-Fisher distribution. Australian &amp; New Zealand Journal of Statistics, 59(1): 119&ndash;135.
</p>
<p>Tsagris M. and Alenazi A. (2024). An investigation of hypothesis testing procedures for circular
and spherical mean vectors. Communications in Statistics-Simulation and Computation, 53(3): 1387&ndash;1408.</p>


<h3>See Also</h3>

<p><code><a href="#topic+hcf.circaov">hcf.circaov</a>, <a href="#topic+het.aov">het.aov</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u1 &lt;- rvonmises(20, 2.4, 5)
u2 &lt;- rvonmises(20, 2.4, 10)
hcfcirc.boot(u1, u2)
</code></pre>

<hr>
<h2 id='Check+20visually+20whether+20matrix+20Fisher+20samples+20is+20correctly+20generated+20or+20not'>
Check visually whether matrix Fisher samples is correctly generated or not.
</h2><span id='topic+visual.check'></span>

<h3>Description</h3>

<p>It plots the log probability trace of matrix Fisher distribution which should close to the maximum value of the
logarithm of matrix Fisher distribution, if samples are correctly generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visual.check(x, Fa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Check+2B20visually+2B20whether+2B20matrix+2B20Fisher+2B20samples+2B20is+2B20correctly+2B20generated+2B20or+2B20not_+3A_x">x</code></td>
<td>

<p>The simulated data. An array with at least 2 3x3 matrices.
</p>
</td></tr>
<tr><td><code id="Check+2B20visually+2B20whether+2B20matrix+2B20Fisher+2B20samples+2B20is+2B20correctly+2B20generated+2B20or+2B20not_+3A_fa">Fa</code></td>
<td>

<p>An arbitrary 3x3 matrix represents the parameter matrix of this distribution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given parameter matrix Fa, maximum value of the logarithm of matrix Fisher distribution is calculated via
the form of singular value decomposition of <code class="reqn">Fa = U \Lambda V^T</code> which is <code class="reqn">tr(\Lambda)</code>. Multiply the last
column of <code class="reqn">U</code> by <code class="reqn">-1</code> and replace small eigenvalue, say, <code class="reqn">\lambda_3</code> by <code class="reqn">-\lambda_3</code> if <code class="reqn">| UV^T| = -1</code>.
</p>


<h3>Value</h3>

<p>A plot which shows log probability trace of matrix Fisher distribution. The values are also returned.
</p>


<h3>Author(s)</h3>

<p>Anamul Sajib.
</p>
<p>R implementation and documentation: Anamul Sajib &lt;sajibstat@du.ac.bd&gt;.
</p>


<h3>References</h3>

<p>Habeck M. (2009). Generation of three-dimensional random rotations in fitting and matching problems.
Computational Statistics, 24(4):719&ndash;731.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Fa &lt;- matrix( c(85, 11, 41, 78, 39, 60, 43, 64, 48), ncol = 3) / 10
x &lt;- rmatrixfisher(1000, Fa)
a &lt;- visual.check(x, Fa)
</code></pre>

<hr>
<h2 id='Circular+20correlations+20between+20one+20and+20many+20circular+20variables'>Circular correlations between two circular variables
</h2><span id='topic+circ.cors1'></span><span id='topic+circ.cors2'></span>

<h3>Description</h3>

<p>Circular correlations between two circular variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circ.cors1(theta, phi, rads = FALSE)
circ.cors2(theta, phi, rads = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Circular+2B20correlations+2B20between+2B20one+2B20and+2B20many+2B20circular+2B20variables_+3A_theta">theta</code></td>
<td>

<p>The first cirular variable expressed in radians, not degrees.
</p>
</td></tr>
<tr><td><code id="Circular+2B20correlations+2B20between+2B20one+2B20and+2B20many+2B20circular+2B20variables_+3A_phi">phi</code></td>
<td>

<p>The other cirular variable. In the case of &quot;circ.cors1&quot; this is a matrix with many
circular variables. In either case, the values must be in radians, not degrees.
</p>
</td></tr>
<tr><td><code id="Circular+2B20correlations+2B20between+2B20one+2B20and+2B20many+2B20circular+2B20variables_+3A_rads">rads</code></td>
<td>

<p>If the data are expressed in rads, then this should be TRUE. If the data are in degrees, then this is FALSE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Correlation for circular variables using the cosinus and sinus formula of Jammaladaka and SenGupta (1988).
</p>


<h3>Value</h3>

<p>A matrix with two columns, the correlations and the p-values.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Jammalamadaka, R. S. and Sengupta, A. (2001). Topics in circular statistics. World Scientific.
</p>
<p>Jammalamadaka, S. R. and Sarma, Y. R. (1988). A correlation coefficient for angular variables. Statistical Theory and Data Analysis, 2:349&ndash;364.
</p>
<p>Mardia, K. V. and Jupp, P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+spml.reg">spml.reg</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- runif(50, 0, 2 * pi)
x &lt;- matrix(runif(50 * 10, 0, 2 * pi), ncol = 10)
circ.cors1(y, x, rads = TRUE)
</code></pre>

<hr>
<h2 id='Circular+20correlations+20between+20two+20circular+20variables'>Circular correlations between two circular variables
</h2><span id='topic+circ.cor1'></span><span id='topic+circ.cor2'></span>

<h3>Description</h3>

<p>Circular correlations between two circular variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circ.cor1(theta, phi, rads = FALSE)

circ.cor2(theta, phi, rads = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Circular+2B20correlations+2B20between+2B20two+2B20circular+2B20variables_+3A_theta">theta</code></td>
<td>

<p>The first cirular variable.
</p>
</td></tr>
<tr><td><code id="Circular+2B20correlations+2B20between+2B20two+2B20circular+2B20variables_+3A_phi">phi</code></td>
<td>

<p>The other cirular variable.
</p>
</td></tr>
<tr><td><code id="Circular+2B20correlations+2B20between+2B20two+2B20circular+2B20variables_+3A_rads">rads</code></td>
<td>

<p>If the data are expressed in rads, then this should be TRUE. If the data are in degrees, then this is FALSE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>circ.cor1: Correlation for circular variables using the cosinus and sinus formula of Jammaladaka and SenGupta (1988).
</p>
<p>circ.cor2: Correlation for circular variables using the cosinus and sinus formula of Mardia and Jupp (2000).
</p>


<h3>Value</h3>

<p>A vector including:
</p>
<table>
<tr><td><code>rho</code></td>
<td>

<p>The value of the correlation coefficient.
</p>
</td></tr>
<tr><td><code>p-value</code></td>
<td>

<p>The p-value of the zero correlation hypothesis testing.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Jammalamadaka, R. S. and Sengupta, A. (2001). Topics in circular statistics. World Scientific.
</p>
<p>Jammalamadaka, S. R. and Sarma, Y. R. (1988) . A correlation coefficient for angular variables. Statistical Theory and Data Analysis, 2:349&ndash;364.
</p>
<p>Mardia, K. V. and Jupp, P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+circlin.cor">circlin.cor</a>, <a href="#topic+circ.cor2">circ.cor2</a>, <a href="#topic+spml.reg">spml.reg</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- runif(50, 0, 2 * pi)
x &lt;- runif(50, 0, 2 * pi)
circ.cor1(x, y, rads = TRUE)
circ.cor2(x, y, rads = TRUE)
</code></pre>

<hr>
<h2 id='Circular+20distance+20correlation+20between+20two+20circular+20variables'>Circular distance correlation between two circular variables
</h2><span id='topic+circ.dcor'></span>

<h3>Description</h3>

<p>Circular distance correlation between two circular variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circ.dcor(theta, phi, rads = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Circular+2B20distance+2B20correlation+2B20between+2B20two+2B20circular+2B20variables_+3A_theta">theta</code></td>
<td>

<p>The first cirular variable.
</p>
</td></tr>
<tr><td><code id="Circular+2B20distance+2B20correlation+2B20between+2B20two+2B20circular+2B20variables_+3A_phi">phi</code></td>
<td>

<p>The other cirular variable.
</p>
</td></tr>
<tr><td><code id="Circular+2B20distance+2B20correlation+2B20between+2B20two+2B20circular+2B20variables_+3A_rads">rads</code></td>
<td>

<p>If the data are expressed in rads, then this should be TRUE. If the data are in degrees, then this is FALSE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The angular data are transformed to their Euclidean coordinates and then the distance correlation is computed.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>dcov</code></td>
<td>

<p>The distance covariance.
</p>
</td></tr>
<tr><td><code>dvarX</code></td>
<td>

<p>The distance variance of x.
</p>
</td></tr>
<tr><td><code>dvarY</code></td>
<td>

<p>The distance variance of Y.
</p>
</td></tr>
<tr><td><code>dcor</code></td>
<td>

<p>The distance correlation.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>G.J. Szekely, M.L. Rizzo and N. K. Bakirov (2007). Measuring and Testing Independence 
by Correlation of Distances. Annals of Statistics, 35(6):2769-2794.
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+circlin.cor">circlin.cor</a>, <a href="#topic+circ.cor2">circ.cor2</a>, <a href="#topic+spher.dcor">spher.dcor</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- runif(50, 0, 2 * pi)
x &lt;- runif(50, 0, 2 * pi)
circ.dcor(x, y, rads = TRUE)
</code></pre>

<hr>
<h2 id='Circular+20or+20angular+20regression'>
Circular or angular regression
</h2><span id='topic+spml.reg'></span><span id='topic+circpurka.reg'></span><span id='topic+cipc.reg'></span><span id='topic+gcpc.reg'></span>

<h3>Description</h3>

<p>Regression with circular dependent variable and Euclidean or categorical independent variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spml.reg(y, x, rads = TRUE, xnew = NULL, seb = FALSE, tol = 1e-07)
circpurka.reg(y, x, rads = TRUE, xnew = NULL)
cipc.reg(y, x, rads = TRUE, xnew = NULL, tol = 1e-06)
gcpc.reg(y, x, rads = TRUE, reps = 20, xnew = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Circular+2B20or+2B20angular+2B20regression_+3A_y">y</code></td>
<td>

<p>The dependent variable,  a numerical vector, it can be in radians or degrees.
</p>
</td></tr>
<tr><td><code id="Circular+2B20or+2B20angular+2B20regression_+3A_x">x</code></td>
<td>

<p>The independent variable(s). Can be Euclidean or categorical (factor variables).
</p>
</td></tr>
<tr><td><code id="Circular+2B20or+2B20angular+2B20regression_+3A_rads">rads</code></td>
<td>

<p>If the dependent variable is expressed in rads, this should be TRUE and FALSE otherwise.
</p>
</td></tr>
<tr><td><code id="Circular+2B20or+2B20angular+2B20regression_+3A_reps">reps</code></td>
<td>

<p>How many starting values shall the algortihm use? By default it uses 20 different starting values.
</p>
</td></tr>
<tr><td><code id="Circular+2B20or+2B20angular+2B20regression_+3A_xnew">xnew</code></td>
<td>

<p>The new values of some independent variable(s) whose circular values you want to predict. Can be Euclidean or categorical.
If they are categorical, the user must provide them as dummy variables. It does not accept factor variables. If you have no new x values, leave it NULL (default).
</p>
</td></tr>
<tr><td><code id="Circular+2B20or+2B20angular+2B20regression_+3A_seb">seb</code></td>
<td>

<p>a boolean variable. If TRUE, the standard error of the coefficients will be be returned.
Set to FALSE in case of simulation studies or in other cases such as a forward regression
setting for example. In these cases, it can save some time.
</p>
</td></tr>
<tr><td><code id="Circular+2B20or+2B20angular+2B20regression_+3A_tol">tol</code></td>
<td>

<p>The tolerance value to terminate the Newton-Raphson algorithm.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the spml.reg(), the Newton-Raphson algorithm is fitted in this regression as described in Presnell et al. (1998). For the cipc.reg(), the Newton-Raphson algorithm is fitted in this regression as described in Tsagris and Alenazy (2023). Note that the cipc.reg() is the same as the wrapped Cauchy regression. For the circpurka.reg() the optim() function is employed. For the gcpc.reg() the optim() and the optimise() functions are being used.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>runtime</code></td>
<td>

<p>The runtime of the procedure.
</p>
</td></tr>
<tr><td><code>iters</code></td>
<td>

<p>The number of iterations required until convergence of the Newton-Raphson algorithm.
</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>

<p>The regression coefficients.
</p>
</td></tr>
<tr><td><code>seb</code></td>
<td>

<p>The standard errors of the coefficients.
</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>The value of the maximised log-likelihood.
</p>
</td></tr>
<tr><td><code>est</code></td>
<td>

<p>The fitted values expressed in radians if the obsereved data are in radians and in degrees otherwise. If xnew is not NULL, i.e. if you have new x values, then the predicted values of y will be returned.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Presnell Brett, Morrison Scott P. and Littell Ramon C. (1998). Projected multivariate linear models for directional data. Journal of the American Statistical Association, 93(443): 1068-1077.
</p>
<p>Purkayastha S. (1991). A Rotationally Symmetric Directional Distribution: Obtained through Maximum Likelihood Characterization. The Indian Journal of Statistics, Series A, 53(1): 70-83
</p>
<p>Tsagris M. and Alzeley O. (2023). Circular and spherical projected Cauchy distributions: A Novel Framework for Circular and Directional Data Modeling.
https://arxiv.org/pdf/2302.02468.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+circlin.cor">circlin.cor</a>, <a href="#topic+circ.cor1">circ.cor1</a>, <a href="#topic+circ.cor2">circ.cor2</a>, <a href="#topic+spher.cor">spher.cor</a>, <a href="#topic+spher.reg">spher.reg</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
z &lt;- cbind(3 + 2 * x, 1 -3 * x)
y &lt;- cbind( rnorm(100,z[ ,1], 1), rnorm(100, z[ ,2], 1) )
y &lt;- y / sqrt( rowSums(y^2) )
y &lt;- ( atan( y[, 2] / y[, 1] ) + pi * I(y[, 1] &lt; 0) ) %% (2 * pi)
a &lt;- spml.reg(y, x, rads = TRUE, xnew = x)
b &lt;- cipc.reg(y, x, rads = TRUE, xnew = x)
</code></pre>

<hr>
<h2 id='Circular-linear+20correlation'>
Circular-linear correlation
</h2><span id='topic+circlin.cor'></span>

<h3>Description</h3>

<p>It calculates the squared correlation between a circular and one or more linear variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circlin.cor(theta, x, rads = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Circular-linear+2B20correlation_+3A_theta">theta</code></td>
<td>

<p>The circular variable.
</p>
</td></tr>
<tr><td><code id="Circular-linear+2B20correlation_+3A_x">x</code></td>
<td>

<p>The linear variable or a matrix containing many linear variables.
</p>
</td></tr>
<tr><td><code id="Circular-linear+2B20correlation_+3A_rads">rads</code></td>
<td>

<p>If the circualr variable is in rads, this should be TRUE and FALSE otherwise.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The squared correlation between a circular and one or more linear variables is calculated.
</p>


<h3>Value</h3>

<p>A matrix with as many rows as linear variables including:
</p>
<table>
<tr><td><code>R-squared</code></td>
<td>

<p>The value of the squared correlation.
</p>
</td></tr>
<tr><td><code>p-value</code></td>
<td>

<p>The p-value of the zero correlation hypothesis testing.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Mardia, K. V. and Jupp, P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+circ.cor1">circ.cor1</a>, <a href="#topic+circ.cor2">circ.cor2</a>, <a href="#topic+spml.reg">spml.reg</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- rvonmises(50, 2, 20, rads = TRUE)
x &lt;- 2 * phi + rnorm(50)
y &lt;- matrix(rnorm(50 * 5), ncol = 5)
circlin.cor(phi, x, rads = TRUE)
circlin.cor(phi, y, rads = TRUE)
</code></pre>

<hr>
<h2 id='Column-wise+20MLE+20of+20the+20angular+20Gaussian+20and+20the+20von+20Mises+20Fisher+20distributions'>
Column-wise MLE of the angular Gaussian and the von Mises Fisher distributions
</h2><span id='topic+colspml.mle'></span><span id='topic+colvm.mle'></span>

<h3>Description</h3>

<p>Column-wise MLE of the angular Gaussian and the von Mises Fisher distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colspml.mle(x ,tol = 1e-07, maxiters = 100, parallel = FALSE)
colvm.mle(x, tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Column-wise+2B20MLE+2B20of+2B20the+2B20angular+2B20Gaussian+2B20and+2B20the+2B20von+2B20Mises+2B20Fisher+2B20distributions_+3A_x">x</code></td>
<td>

<p>A numerical matrix with data. Each column refers to a different vector of observations of the same distribution.
The values of for Lognormal must be greater than zero, for the logitnormal they must by percentages, exluding 0 and 1,
whereas for the Borel distribution the x must contain integer values greater than 1.
</p>
</td></tr>
<tr><td><code id="Column-wise+2B20MLE+2B20of+2B20the+2B20angular+2B20Gaussian+2B20and+2B20the+2B20von+2B20Mises+2B20Fisher+2B20distributions_+3A_tol">tol</code></td>
<td>

<p>The tolerance value to terminate the Newton-Raphson algorithm.
</p>
</td></tr>
<tr><td><code id="Column-wise+2B20MLE+2B20of+2B20the+2B20angular+2B20Gaussian+2B20and+2B20the+2B20von+2B20Mises+2B20Fisher+2B20distributions_+3A_maxiters">maxiters</code></td>
<td>

<p>The maximum number of iterations that can take place in each regression.
</p>
</td></tr>
<tr><td><code id="Column-wise+2B20MLE+2B20of+2B20the+2B20angular+2B20Gaussian+2B20and+2B20the+2B20von+2B20Mises+2B20Fisher+2B20distributions_+3A_parallel">parallel</code></td>
<td>

<p>Do you want this to be executed in parallel or not. The parallel takes place in C++, and the number of threads
is defined by each system's availiable cores.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each column, spml.mle function is applied that fits the angular Gaussian distribution estimates
its parameters and computes the maximum log-likelihood.
</p>


<h3>Value</h3>

<p>A matrix with four columns. The first two are the mean vector, then the <code class="reqn">\gamma</code> parameter, and the fourth
column contains maximum log-likelihood.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Presnell Brett, Morrison Scott P. and Littell Ramon C. (1998). Projected multivariate linear models for directional data.
Journal of the American Statistical Association, 93(443): 1068&ndash;1077.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spml.mle">spml.mle</a>, <a href="#topic+spml.reg">spml.reg</a>, <a href="#topic+vmf.mle">vmf.mle</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix( runif(100 * 10), ncol = 10)
a &lt;- colspml.mle(x)
b &lt;- colvm.mle(x)
x &lt;- NULL
</code></pre>

<hr>
<h2 id='Column-wise+20uniformity+20Watson+20test+20for+20circular+20data'>
Column-wise uniformity tests for circular data
</h2><span id='topic+colwatsons'></span>

<h3>Description</h3>

<p>Column-wise uniformity tests for circular data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colwatsons(u, rads = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Column-wise+2B20uniformity+2B20Watson+2B20test+2B20for+2B20circular+2B20data_+3A_u">u</code></td>
<td>

<p>A numeric matrix containing the circular data which are expressed in radians.
Each column is a different sample.
</p>
</td></tr>
<tr><td><code id="Column-wise+2B20uniformity+2B20Watson+2B20test+2B20for+2B20circular+2B20data_+3A_rads">rads</code></td>
<td>

<p>A boolean variable. If the data are in radians, put this TRUE.
If the data are expressed in degrees make this FALSE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These tests are used to test the hypothesis that the data come from a circular
uniform distribution.
</p>


<h3>Value</h3>

<p>A matrix with two columns, the value of the test statistic and its associated p-value.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris &lt;mtsagris@uoc.gr&gt;.
</p>


<h3>References</h3>

<p>Jammalamadaka S. Rao and SenGupta A. (2001). Topics in Circular Statistics, pg. 156&ndash;157.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+watson">watson</a>, <a href="#topic+kuiper">kuiper</a>, <a href="#topic+fishkent">fishkent</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix( rvonmises(n = 50 * 10, m = 2, k = 0), ncol = 10 )
res&lt;-colwatsons(x)
x &lt;- NULL
</code></pre>

<hr>
<h2 id='Contour+20plot+20+28on+20the+20plane+29+20of+20the+20ESAG+20and+20Kent+20distributions+20without+20any+20data'>
Contour plot (on the plane) of the ESAG and Kent and ESAG distributions without any data
</h2><span id='topic+esag.contour'></span><span id='topic+kent.contour'></span>

<h3>Description</h3>

<p>The contour plot (on the plane) of the spherical ESAG and Kent distributions is produced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>esag.contour(mu, gam, lat, long)
kent.contour(k, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20plane+2B29+2B20of+2B20the+2B20ESAG+2B20and+2B20Kent+2B20distributions+2B20without+2B20any+2B20data_+3A_k">k</code></td>
<td>

<p>The concentration parameter.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20plane+2B29+2B20of+2B20the+2B20ESAG+2B20and+2B20Kent+2B20distributions+2B20without+2B20any+2B20data_+3A_b">b</code></td>
<td>

<p>The ovalness parameter. It has to be less than k/2 in order for the distribution to be unimodal. Otherwise it is bimodal.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20plane+2B29+2B20of+2B20the+2B20ESAG+2B20and+2B20Kent+2B20distributions+2B20without+2B20any+2B20data_+3A_mu">mu</code></td>
<td>

<p>The mean vector the ESAG distribution, a vector in <code class="reqn">R^3</code>.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20plane+2B29+2B20of+2B20the+2B20ESAG+2B20and+2B20Kent+2B20distributions+2B20without+2B20any+2B20data_+3A_gam">gam</code></td>
<td>

<p>The two gamma parameters of the ESAG distribution.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20plane+2B29+2B20of+2B20the+2B20ESAG+2B20and+2B20Kent+2B20distributions+2B20without+2B20any+2B20data_+3A_lat">lat</code></td>
<td>

<p>A positive number determing the range of degrees to move left and right from the latitude center. See the example to better understand this argument.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20plane+2B29+2B20of+2B20the+2B20ESAG+2B20and+2B20Kent+2B20distributions+2B20without+2B20any+2B20data_+3A_long">long</code></td>
<td>

<p>A positive number determing the range of degrees to move up and down from the longitude center. See the example to better understand this argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The goal of this function is for the user to see how the Kent or the SAG distribution looks like.
</p>


<h3>Value</h3>

<p>A plot containing the contours of the distribution.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris and Christos Adam.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Christos Adam <a href="mailto:pada4m4@gmail.com">pada4m4@gmail.com</a>.
</p>


<h3>References</h3>

<p>Kent John (1982). The Fisher-Bingham distribution on the sphere. Journal of the Royal Statistical Society, Series B, 44(1): 71&ndash;80.
</p>
<p>Paine P.J., Preston S.P., Tsagris M. and Wood A.T.A. (2018). An Elliptically Symmetric Angular
Gaussian Distribution. Statistics and Computing, 28(3):689&ndash;697.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vmf.contour">vmf.contour</a>, <a href="#topic+vmf.kerncontour">vmf.kerncontour</a>, <a href="#topic+spher.esag.contour">spher.esag.contour</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
kent.contour(10, 4)

mu &lt;- colMeans( as.matrix( iris[,1:3] ) )
gam &lt;- c(1,0.5)
esag.contour(mu, gam, 50, 50)
esag.contour(mu, gam, 30, 40)

</code></pre>

<hr>
<h2 id='Contour+20plot+20+28on+20the+20sphere+29+20of+20a+20mixture+20of+20von+20Mises-Fisher+20distributions'>
Contour plot (on the sphere) of a mixture of von Mises-Fisher distributions
</h2><span id='topic+spher.mixvmf.contour'></span>

<h3>Description</h3>

<p>The contour plot (on the sphere) of a mixture of von Mises-Fisher distributions is produced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spher.mixvmf.contour(probs, mu, k, bgcol = "snow", dat = NULL, col = NULL,
lat = 50, long = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20a+2B20mixture+2B20of+2B20von+2B20Mises-Fisher+2B20distributions_+3A_probs">probs</code></td>
<td>

<p>This is avector with the mixing probability of each group.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20a+2B20mixture+2B20of+2B20von+2B20Mises-Fisher+2B20distributions_+3A_mu">mu</code></td>
<td>

<p>A matrix with the mean direction of each group.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20a+2B20mixture+2B20of+2B20von+2B20Mises-Fisher+2B20distributions_+3A_k">k</code></td>
<td>

<p>A vector with the concentration parameter of each group.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20a+2B20mixture+2B20of+2B20von+2B20Mises-Fisher+2B20distributions_+3A_bgcol">bgcol</code></td>
<td>

<p>The color of the surface of the sphere.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20a+2B20mixture+2B20of+2B20von+2B20Mises-Fisher+2B20distributions_+3A_dat">dat</code></td>
<td>

<p>If you have you want to plot supply them here. This has to be a numerical matrix with three columns, i.e. unit vectors.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20a+2B20mixture+2B20of+2B20von+2B20Mises-Fisher+2B20distributions_+3A_col">col</code></td>
<td>

<p>If you supplied data then choose the color of the points. If you did not choose a color, the points will appear in red.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20a+2B20mixture+2B20of+2B20von+2B20Mises-Fisher+2B20distributions_+3A_lat">lat</code></td>
<td>

<p>A positive number determing the range of degrees to move left and right from the latitude center. See the example to better understand this argument.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20a+2B20mixture+2B20of+2B20von+2B20Mises-Fisher+2B20distributions_+3A_long">long</code></td>
<td>

<p>A positive number determing the range of degrees to move up and down from the longitude center. See the example to better understand this argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The goal of this function is for the user to see how the mixtures of von Mises-Fisher look like.
</p>


<h3>Value</h3>

<p>A plot containing the contours of the mixture distribution.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Kurt Hornik and  Bettina Grun (2014). movMF: An R Package for Fitting Mixtures of von Mises-Fisher Distributions
http://cran.r-project.org/web/packages/movMF/vignettes/movMF.pdf
</p>
<p>Mardia K. V. and Jupp, P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
</p>
<p>Sra S. (2012). A short note on parameter approximation for von Mises-Fisher distributions:
and a fast implementation of <code class="reqn">I_s(x)</code>. Computational Statistics, 27(1): 177&ndash;190.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spher.esag.contour">spher.esag.contour</a>, <a href="#topic+spher.vmf.contour">spher.vmf.contour</a>, <a href="#topic+mixvmf.mle">mixvmf.mle</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
k &lt;- runif(3, 4, 20)
probs &lt;- c(0.2, 0.5, 0.3)
mu &lt;- matrix(rnorm(9, 0, 0.5), ncol = 3)
mu &lt;- mu / sqrt( rowSums(mu^2) )
## the lat and long are decreased to 10. Increase them back to 50 to
## see the difference
spher.mixvmf.contour(probs, mu, k, lat = 10, long = 10)

</code></pre>

<hr>
<h2 id='Contour+20plot+20+28on+20the+20sphere+29+20of+20some+20spherical+20rotationally+20symmetric+20distributions'>
Contour plot (on the sphere) of some spherical rotationally symmetric distributions
</h2><span id='topic+spher.vmf.contour'></span><span id='topic+spher.purka.contour'></span><span id='topic+spher.spcauchy.contour'></span><span id='topic+spher.pkbd.contour'></span>

<h3>Description</h3>

<p>The contour plot (on the sphere) of some spherical rotationally symmetric distributions is produced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spher.vmf.contour(mu, k, bgcol = "snow", dat = NULL, col = NULL,
lat = 50, long = 50)
spher.purka.contour(theta, a, bgcol = "snow", dat = NULL, col = NULL,
lat = 50, long = 50)
spher.spcauchy.contour(mu, rho, bgcol = "snow", dat = NULL, col = NULL,
lat = 50, long = 50)
spher.pkbd.contour(mu, rho, bgcol = "snow", dat = NULL, col = NULL,
lat = 50, long = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20some+2B20spherical+2B20rotationally+2B20symmetric+2B20distributions_+3A_mu">mu</code></td>
<td>

<p>The mean or the median direction, depending on the distribution, a unit vector.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20some+2B20spherical+2B20rotationally+2B20symmetric+2B20distributions_+3A_theta">theta</code></td>
<td>

<p>The mean direction (unit vector) of the Purkayastha distribution.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20some+2B20spherical+2B20rotationally+2B20symmetric+2B20distributions_+3A_k">k</code></td>
<td>

<p>The concentration parameter (<code class="reqn">\kappa</code>) of the von Mises-Fisher distribution.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20some+2B20spherical+2B20rotationally+2B20symmetric+2B20distributions_+3A_a">a</code></td>
<td>

<p>The concentration parameter (<code class="reqn">\alpha</code>) of the Purkayastha distribution.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20some+2B20spherical+2B20rotationally+2B20symmetric+2B20distributions_+3A_rho">rho</code></td>
<td>

<p>The concentration parameter (<code class="reqn">\rho</code>) of the spherical Cauchy distribution.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20some+2B20spherical+2B20rotationally+2B20symmetric+2B20distributions_+3A_bgcol">bgcol</code></td>
<td>

<p>The color of the surface of the sphere.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20some+2B20spherical+2B20rotationally+2B20symmetric+2B20distributions_+3A_dat">dat</code></td>
<td>

<p>If you have you want to plot supply them here. This has to be a numerical matrix with three columns, i.e. unit vectors.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20some+2B20spherical+2B20rotationally+2B20symmetric+2B20distributions_+3A_col">col</code></td>
<td>

<p>If you supplied data then choose the color of the points. If you did not choose a color, the points will appear in red.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20some+2B20spherical+2B20rotationally+2B20symmetric+2B20distributions_+3A_lat">lat</code></td>
<td>

<p>A positive number determing the range of degrees to move left and right from the latitude center. See the example to better understand this argument.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20some+2B20spherical+2B20rotationally+2B20symmetric+2B20distributions_+3A_long">long</code></td>
<td>

<p>A positive number determing the range of degrees to move up and down from the longitude center. See the example to better understand this argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The goal of this function is for the user to see how the von Mises-Fisher, the Purkayastha, the spherical Cauchy or the Poisson kernel based distribution looks like.
</p>


<h3>Value</h3>

<p>A plot containing the contours of the distribution.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Mardia K. V. and Jupp, P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
</p>
<p>Sra S. (2012). A short note on parameter approximation for von Mises-Fisher distributions:
and a fast implementation of <code class="reqn">I_s(x)</code>. Computational Statistics, 27(1): 177&ndash;190.
</p>
<p>Purkayastha S. (1991). A Rotationally Symmetric Directional Distribution: Obtained through
Maximum Likelihood Characterization. The Indian Journal of Statistics, Series A, 53(1): 70&ndash;83.
</p>
<p>Cabrera J. and Watson G. S. (1990). On a spherical median related distribution.
Communications in Statistics-Theory and Methods, 19(6): 1973&ndash;1986.
</p>
<p>Kato S. and McCullagh P. (2020). Some properties of a Cauchy family on the sphere derived from the Mobius transformations. 
Bernoulli, 26(4): 3224&ndash;3248.
https://arxiv.org/pdf/1510.07679.pdf
</p>
<p>Golzy M. and Markatou M. (2020). Poisson kernel-based clustering on the sphere:
convergence properties, identifiability, and a method of sampling.
Journal of Computational and Graphical Statistics, 29(4): 758&ndash;770.
</p>
<p>Sablica L., Hornik K. and Leydold J. (2023). Efficient sampling from the PKBD distribution.
Electronic Journal of Statistics, 17(2): 2180&ndash;2209.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spher.esag.contour">spher.esag.contour</a>, <a href="#topic+spher.mixvmf.contour">spher.mixvmf.contour</a>, <a href="#topic+kent.contour">kent.contour</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mu &lt;- colMeans( as.matrix( iris[, 1:3] ) )
mu &lt;- mu / sqrt( sum(mu^2) )
## the lat and long are decreased to 30. Increase them back to 50 to
## see the difference
spher.spcauchy.contour(mu, 0.7, lat = 30, long = 30)

</code></pre>

<hr>
<h2 id='Contour+20plot+20+28on+20the+20sphere+29+20of+20the+20ESAG+20and+20Kent+20distributions'>
Contour plot (on the sphere) of the ESAG and Kent distributions
</h2><span id='topic+spher.esag.contour'></span><span id='topic+spher.kent.contour'></span>

<h3>Description</h3>

<p>The contour plot (on the sphere) of the ESAG and Kent distributions is produced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spher.esag.contour(mu, gam, bgcol = "snow", dat = NULL, col = NULL,
lat = 50, long = 50)
spher.kent.contour(G, param, bgcol = "snow", dat = NULL, col = NULL,
lat = 50, long = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20the+2B20ESAG+2B20and+2B20Kent+2B20distributions_+3A_mu">mu</code></td>
<td>

<p>The mean vector the ESAG distribution, a vector in <code class="reqn">R^3</code>.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20the+2B20ESAG+2B20and+2B20Kent+2B20distributions_+3A_gam">gam</code></td>
<td>

<p>The two gamma parameters of the ESAG distribution.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20the+2B20ESAG+2B20and+2B20Kent+2B20distributions_+3A_g">G</code></td>
<td>

<p>For the Kent distribution, a 3 x 3 matrix whose first column is the mean direction. The second and third columns are the major and minor axes respectively.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20the+2B20ESAG+2B20and+2B20Kent+2B20distributions_+3A_param">param</code></td>
<td>

<p>For the Kent distribution a vector with the concentration <code class="reqn">\kappa</code> and ovalness <code class="reqn">\beta</code> parameters. The angle <code class="reqn">\psi</code> has been absorbed inside the matrix G.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20the+2B20ESAG+2B20and+2B20Kent+2B20distributions_+3A_bgcol">bgcol</code></td>
<td>

<p>The color of the surface of the sphere.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20the+2B20ESAG+2B20and+2B20Kent+2B20distributions_+3A_dat">dat</code></td>
<td>

<p>If you have you want to plot supply them here. This has to be a numerical matrix with three columns, i.e. unit vectors.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20the+2B20ESAG+2B20and+2B20Kent+2B20distributions_+3A_col">col</code></td>
<td>

<p>If you supplied data then choose the color of the points. If you did not choose a color, the points will appear in red.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20the+2B20ESAG+2B20and+2B20Kent+2B20distributions_+3A_lat">lat</code></td>
<td>

<p>A positive number determing the range of degrees to move left and right from the latitude center. See the example to better understand this argument.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20the+2B20ESAG+2B20and+2B20Kent+2B20distributions_+3A_long">long</code></td>
<td>

<p>A positive number determing the range of degrees to move up and down from the longitude center. See the example to better understand this argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The goal of this function is for the user to see how the ESAG or the Kent distribution looks like.
</p>


<h3>Value</h3>

<p>A plot containing the contours of the distribution.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Kent John (1982). The Fisher-Bingham distribution on the sphere.
Journal of the Royal Statistical Society, Series B, 44(1): 71&ndash;80.
</p>
<p>Paine P.J., Preston S.P., Tsagris M. and Wood A.T.A. (2018). An Elliptically Symmetric Angular
Gaussian Distribution. Statistics and Computing, 28(3):689&ndash;697.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+esag.contour">esag.contour</a>, <a href="#topic+spher.purka.contour">spher.purka.contour</a>, <a href="#topic+kent.contour">kent.contour</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mu &lt;- colMeans( as.matrix( iris[, 1:3] ) )
gam &lt;- c(1 ,0.5)
## the lat and long are decreased to 30. Increase them back to 50 to
## see the difference
spher.esag.contour(mu, gam, lat = 30, long = 30)

</code></pre>

<hr>
<h2 id='Contour+20plot+20+28on+20the+20sphere+29+20of+20the+20SESPC+20distribution'>
Contour plot (on the sphere) of the SESPC distribution
</h2><span id='topic+spher.sespc.contour'></span>

<h3>Description</h3>

<p>The contour plot (on the sphere) of the SESPC distribution is produced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spher.sespc.contour(mu, theta, bgcol = "snow", dat = NULL, col = NULL,
lat = 50, long = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20the+2B20SESPC+2B20distribution_+3A_mu">mu</code></td>
<td>

<p>The mean vector the SESPC distribution, a vector in <code class="reqn">R^3</code>.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20the+2B20SESPC+2B20distribution_+3A_theta">theta</code></td>
<td>

<p>The two <code class="reqn">\theta</code> parameters of the SESPC distribution.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20the+2B20SESPC+2B20distribution_+3A_bgcol">bgcol</code></td>
<td>

<p>The color of the surface of the sphere.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20the+2B20SESPC+2B20distribution_+3A_dat">dat</code></td>
<td>

<p>If you have you want to plot supply them here. This has to be a numerical matrix with three columns, i.e. unit vectors.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20the+2B20SESPC+2B20distribution_+3A_col">col</code></td>
<td>

<p>If you supplied data then choose the color of the points. If you did not choose a color, the points will appear in red.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20the+2B20SESPC+2B20distribution_+3A_lat">lat</code></td>
<td>

<p>A positive number determing the range of degrees to move left and right from the latitude center. See the example to better understand this argument.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20+2B28on+2B20the+2B20sphere+2B29+2B20of+2B20the+2B20SESPC+2B20distribution_+3A_long">long</code></td>
<td>

<p>A positive number determing the range of degrees to move up and down from the longitude center. See the example to better understand this argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The goal of this function is for the user to see how the SESPC distribution looks like.
</p>


<h3>Value</h3>

<p>A plot containing the contours of the distribution.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Tsagris M. and Alzeley O. (2023). Circular and spherical projected Cauchy distributions: 
A Novel Framework for Circular and Directional Data Modeling.
https://arxiv.org/pdf/2302.02468.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spher.esag.contour">spher.esag.contour</a>, <a href="#topic+spher.spcauchy.contour">spher.spcauchy.contour</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mu &lt;- colMeans( as.matrix( iris[, 1:3] ) )
theta &lt;- c(1 ,0.5)
## the lat and long are decreased to 30. Increase them back to 50 to
## see the difference
spher.sespc.contour(mu, theta, lat = 30, long = 30)

</code></pre>

<hr>
<h2 id='Contour+20plot+20of+20a+20mixture+20of+20von+20Mises-Fisher+20distributions+20model'>
Contour plot of a mixture of von Mises-Fisher distributions model for spherical data only.
</h2><span id='topic+mixvmf.contour'></span>

<h3>Description</h3>

<p>Contour lines are produced of mixture model for spherical data only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixvmf.contour(u, mod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Contour+2B20plot+2B20of+2B20a+2B20mixture+2B20of+2B20von+2B20Mises-Fisher+2B20distributions+2B20model_+3A_u">u</code></td>
<td>

<p>A two column matrix. The first column is the longitude and the second is the latitude.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20of+2B20a+2B20mixture+2B20of+2B20von+2B20Mises-Fisher+2B20distributions+2B20model_+3A_mod">mod</code></td>
<td>

<p>This is mix.vmf object, actually it is a list. Run a mixture model and save it as mod for example, mod = mix.vmf(x, 3).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The contour plot is displayed with latitude and longitude in the axes. No Lambert projection is used here. This works for  spherical data only which are given as longitude and latitude.
</p>


<h3>Value</h3>

<p>A plot including:
The points and the contour lines.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris and Christos Adam.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Christos Adam <a href="mailto:pada4m4@gmail.com">pada4m4@gmail.com</a>.
</p>


<h3>References</h3>

<p>Kurt Hornik and  Bettina Grun (2014). movMF: An R Package for Fitting Mixtures of von Mises-Fisher Distributions
http://cran.r-project.org/web/packages/movMF/vignettes/movMF.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vmf.kerncontour">vmf.kerncontour</a>, <a href="#topic+vmf.contour">vmf.contour</a>, <a href="#topic+mixvmf.mle">mixvmf.mle</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k &lt;- runif(2, 4, 20)
prob &lt;- c(0.4, 0.6)
mu &lt;- matrix( rnorm(6), ncol = 3 )
mu &lt;- mu / sqrt( rowSums(mu^2) )
x &lt;- rmixvmf(200, prob, mu, k)$x
mod &lt;- mixvmf.mle(x, 2)
y &lt;- euclid.inv(x)
mixvmf.contour(y, mod)
</code></pre>

<hr>
<h2 id='Contour+20plot+20of+20spherical+20data+20using+20a+20von+20Mises-Fisher+20kernel+20density+20estimate'>
Contour plot of spherical data using a von Mises-Fisher kernel density estimate
</h2><span id='topic+vmf.kerncontour'></span>

<h3>Description</h3>

<p>Contour plot of spherical data using a von Mises-Fisher kernel density estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vmf.kerncontour(u, thumb = "none", den.ret = FALSE, full = FALSE, ngrid = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Contour+2B20plot+2B20of+2B20spherical+2B20data+2B20using+2B20a+2B20von+2B20Mises-Fisher+2B20kernel+2B20density+2B20estimate_+3A_u">u</code></td>
<td>

<p>A two column matrix. The first coolumn is the latitude and the second is the longitude.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20of+2B20spherical+2B20data+2B20using+2B20a+2B20von+2B20Mises-Fisher+2B20kernel+2B20density+2B20estimate_+3A_thumb">thumb</code></td>
<td>

<p>This is either 'none' (defualt), or 'rot' for the rule of thumb suggested by Garcia-Portugues (2013).
If it is &quot;none&quot; it is estimated via cross validation, with the fast function <code><a href="#topic+vmfkde.tune">vmfkde.tune</a></code>.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20of+2B20spherical+2B20data+2B20using+2B20a+2B20von+2B20Mises-Fisher+2B20kernel+2B20density+2B20estimate_+3A_den.ret">den.ret</code></td>
<td>

<p>If FALSE (default), plots the contours of the density along with the individual
points. If TRUE, will instead return a list with the Longitudes, Latitudes and
Densities. Look at the 'value' section for details.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20of+2B20spherical+2B20data+2B20using+2B20a+2B20von+2B20Mises-Fisher+2B20kernel+2B20density+2B20estimate_+3A_full">full</code></td>
<td>

<p>If FALSE (default), uses the range of positions from 'u' to calculate and
optionally plot densities. If TRUE, calculates densities covering the entire
sphere.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plot+2B20of+2B20spherical+2B20data+2B20using+2B20a+2B20von+2B20Mises-Fisher+2B20kernel+2B20density+2B20estimate_+3A_ngrid">ngrid</code></td>
<td>

<p>Sets the resolution of the density calculation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It calculates the contour plot using a von Mises-Fisher kernel for spherical data only.
</p>


<h3>Value</h3>

<p>The contour lines of the data. If &quot;den.ret&quot; was set to TRUE a list including:
</p>
<table>
<tr><td><code>lat</code></td>
<td>

<p>The latitude values.
</p>
</td></tr>
<tr><td><code>long</code></td>
<td>

<p>The longitude values.
</p>
</td></tr>
<tr><td><code>h</code></td>
<td>

<p>The optimal bandwidth.
</p>
</td></tr>
<tr><td><code>den</code></td>
<td>

<p>The kernel density estimate contour points.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris, Micah J. Waldstein and Christos Adam.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>,
Micah J. Waldstein <a href="mailto:micah@waldste.in">micah@waldste.in</a> and Christos Adam <a href="mailto:pada4m4@gmail.com">pada4m4@gmail.com</a>.
</p>


<h3>References</h3>

<p>Garcia Portugues, E. (2013). Exact risk improvement of bandwidth selectors for kernel density estimation with directional data.
Electronic Journal of Statistics, 7, 1655&ndash;1685.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vmf.kde">vmf.kde</a>, <a href="#topic+vmfkde.tune">vmfkde.tune</a>, <a href="#topic+vmf.contour">vmf.contour</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvmf(100, rnorm(3), 15)
x &lt;- euclid.inv(x)

vmf.kerncontour(x, "rot")

</code></pre>

<hr>
<h2 id='Contour+20plots+20of+20some+20rotationally+20symmetric+20distributions'>
Contour plots of some rotationally symmetric distributions
</h2><span id='topic+vmf.contour'></span><span id='topic+spcauchy.contour'></span><span id='topic+purka.contour'></span><span id='topic+pkbd.contour'></span>

<h3>Description</h3>

<p>Contour plots of some rotationally symmetric distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vmf.contour(k)
spcauchy.contour(mu, rho, lat = 50, long = 50)
purka.contour(theta, a, lat = 50, long = 50)
pkbd.contour(mu, rho, lat = 50, long = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Contour+2B20plots+2B20of+2B20some+2B20rotationally+2B20symmetric+2B20distributions_+3A_k">k</code></td>
<td>

<p>The concentration parameter.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plots+2B20of+2B20some+2B20rotationally+2B20symmetric+2B20distributions_+3A_mu">mu</code></td>
<td>

<p>The mean direction (unit vector) of the von Mises-Fisher, the IAG, the spherical Cauchy distribution,
or the Poisson kernel based distribution.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plots+2B20of+2B20some+2B20rotationally+2B20symmetric+2B20distributions_+3A_rho">rho</code></td>
<td>

<p>The <code class="reqn">\rho</code> parameter of the spherical Cauchy distribution, or the Poisson kernel based distribution.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plots+2B20of+2B20some+2B20rotationally+2B20symmetric+2B20distributions_+3A_theta">theta</code></td>
<td>

<p>The median direction for the Purkayastha distribution, a unit vector.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plots+2B20of+2B20some+2B20rotationally+2B20symmetric+2B20distributions_+3A_a">a</code></td>
<td>

<p>The concentration parameter of the Purkayastha distribution.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plots+2B20of+2B20some+2B20rotationally+2B20symmetric+2B20distributions_+3A_lat">lat</code></td>
<td>

<p>A positive number determing the range of degrees to move left and right from the latitude center. See the example to better understand this argument.
</p>
</td></tr>
<tr><td><code id="Contour+2B20plots+2B20of+2B20some+2B20rotationally+2B20symmetric+2B20distributions_+3A_long">long</code></td>
<td>

<p>A positive number determing the range of degrees to move up and down from the longitude center. See the example to better understand this argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user specifies the concentration parameter only and not the mean direction or data. This is for illustration purposes only. The graph of the von Mises-Fisher distribution will always contain circles, as this distribution is the analogue of a bivariate normal in two dimensions with a zero covariance.
</p>


<h3>Value</h3>

<p>A contour plot of the distribution.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris and Christos Adam.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Christos Adam <a href="mailto:pada4m4@gmail.com">pada4m4@gmail.com</a>.
</p>


<h3>References</h3>

<p>Mardia K. V. and Jupp P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
</p>
<p>Kato S. and McCullagh P. (2020). Some properties of a Cauchy family on the sphere derived from the Mobius transformations. 
Bernoulli, 26(4): 3224&ndash;3248.
https://arxiv.org/pdf/1510.07679.pdf
</p>
<p>Purkayastha S. (1991). A Rotationally Symmetric Directional Distribution: Obtained through
Maximum Likelihood Characterization. The Indian Journal of Statistics, Series A, 53(1): 70&ndash;83
</p>
<p>Cabrera J. and Watson G. S. (1990). On a spherical median related distribution. 
Communications in Statistics-Theory and Methods, 19(6): 1973&ndash;1986.
</p>
<p>Golzy M. and Markatou M. (2020). Poisson kernel-based clustering on the sphere:
convergence properties, identifiability, and a method of sampling.
Journal of Computational and Graphical Statistics, 29(4): 758&ndash;770.
</p>
<p>Sablica L., Hornik K. and Leydold J. (2023). Efficient sampling from the PKBD distribution.
Electronic Journal of Statistics, 17(2): 2180&ndash;2209.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rvmf">rvmf</a>, <a href="#topic+vmf.mle">vmf.mle</a>, <a href="#topic+vmf.kerncontour">vmf.kerncontour</a>, <a href="#topic+kent.contour">kent.contour</a>, <a href="#topic+sphereplot">sphereplot</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vmf.contour(5)
mu &lt;- colMeans( as.matrix( iris[,1:3] ) )
mu &lt;- mu / sqrt( sum(mu^2) )
spcauchy.contour(mu, 0.7, 30, 30)
spcauchy.contour(mu, 0.7, 60, 60)

</code></pre>

<hr>
<h2 id='Conversion+20of+20cosines+20to+20azimuth+20and+20plunge'>
Conversion of cosines to azimuth and plunge
</h2><span id='topic+cosap'></span>

<h3>Description</h3>

<p>Conversion of cosines to azimuth and plunge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cosap(x,y,z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Conversion+2B20of+2B20cosines+2B20to+2B20azimuth+2B20and+2B20plunge_+3A_x">x</code></td>
<td>

<p>x component of cosine.
</p>
</td></tr>
<tr><td><code id="Conversion+2B20of+2B20cosines+2B20to+2B20azimuth+2B20and+2B20plunge_+3A_y">y</code></td>
<td>

<p>y component of cosine.
</p>
</td></tr>
<tr><td><code id="Conversion+2B20of+2B20cosines+2B20to+2B20azimuth+2B20and+2B20plunge_+3A_z">z</code></td>
<td>

<p>z component of cosine.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Orientation: x&gt;0 is 'eastward', y&gt;0 is 'southward', and z&gt;0 is 'downward'.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>A</code></td>
<td>

<p>The azimuth
</p>
</td></tr>
<tr><td><code>P</code></td>
<td>

<p>The plunge</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eli Amson.
</p>
<p>R implementation and documentation: Eli Amson &lt;eli.amson1988@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Amson E, Arnold P, Van Heteren AH, Cannoville A, Nyakatura JA. Trabecular architecture in the forelimb epiphyses of extant xenarthrans (Mammalia). Frontiers in Zoology.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+euclid">euclid</a>, <a href="#topic+euclid.inv">euclid.inv</a>, <a href="#topic+eul2rot">eul2rot</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cosap(-0.505, 0.510, -0.696)
</code></pre>

<hr>
<h2 id='Converting+20a+20rotation+20matrix+20on+20SO+283+29+20to+20an+20unsigned+20unit+20quaternion'>
Converting a rotation matrix on SO(3) to an unsigned unit quaternion
</h2><span id='topic+rot2quat'></span>

<h3>Description</h3>

<p>It returns an unsigned unite quaternion in <code class="reqn">S^3</code> (the four-dimensional sphere) from a <code class="reqn">3 \times 3</code> 
rotation matrix on SO(3).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rot2quat(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Converting+2B20a+2B20rotation+2B20matrix+2B20on+2B20SO+2B283+2B29+2B20to+2B20an+2B20unsigned+2B20unit+2B20quaternion_+3A_x">X</code></td>
<td>

<p>A rotation matrix in SO(3).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Firstly construct a system of linear equations by equating the corresponding components of the theoretical rotation 
matrix proposed by Prentice (1986), and given a rotation matrix. Finally, the system of linear equations are solved 
by following the tricks mentioned in second reference here in order to achieve numerical accuracy to get quaternion values.
</p>


<h3>Value</h3>

<p>A unsigned unite quaternion.
</p>


<h3>Author(s)</h3>

<p>Anamul Sajib.
</p>
<p>R implementation and documentation: Anamul Sajib &lt;sajibstat@du.ac.bd&gt;.
</p>


<h3>References</h3>

<p>Prentice,M. J. (1986). Orientation statistics without parametric assumptions.Journal of the 
Royal Statistical Society. Series B: Methodological 48(2).  //http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quat2rot">quat2rot</a>, <a href="#topic+rotation">rotation</a>, <a href="#topic+Arotation">Arotation</a> \ link{rot.matrix}
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(4)
x &lt;- x/sqrt( sum(x^2) ) ## an unit quaternion in R4 ##
R &lt;- quat2rot(x)
R
x
rot2quat(R) ## sign is not exact as you can see
</code></pre>

<hr>
<h2 id='Converting+20an+20unsigned+20unit+20quaternion+20to+20rotation+20matrix+20on+20SO+283+29'>
Converting an unsigned unit quaternion to rotation matrix on SO(3)
</h2><span id='topic+quat2rot'></span>

<h3>Description</h3>

<p>It forms a (3 x 3) rotation matrix on SO(3) from an unsigned unite quaternion in <code class="reqn">S^3</code> (the four-dimensional sphere).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quat2rot(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Converting+2B20an+2B20unsigned+2B20unit+2B20quaternion+2B20to+2B20rotation+2B20matrix+2B20on+2B20SO+2B283+2B29_+3A_x">x</code></td>
<td>

<p>An unsigned unit quaternion in <code class="reqn">S^3</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an unsigned unit quaternion in <code class="reqn">S^3</code> it forms a rotation matrix on SO(3), according to the transformation proposed by Prentice (1986).
</p>


<h3>Value</h3>

<p>A rotation matrix.
</p>


<h3>Author(s)</h3>

<p>Anamul Sajib.
</p>
<p>R implementation and documentation: Anamul Sajib &lt;sajibstat@du.ac.bd&gt;.
</p>


<h3>References</h3>

<p>Prentice,M. J. (1986). Orientation statistics without parametric assumptions.Journal of the Royal Statistical Society. Series B: Methodological 48(2).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rot2quat">rot2quat</a>, <a href="#topic+rotation">rotation</a>, <a href="#topic+Arotation">Arotation</a> <a href="#topic+rot.matrix">rot.matrix</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(4)
x &lt;- x/sqrt( sum(x^2) )
x                   ## an unit quaternion in R4 ##
quat2rot(x)
</code></pre>

<hr>
<h2 id='Cross+20validation+20for+20estimating+20the+20classification+20rate'>
Cross validation for estimating the classification rate
</h2><span id='topic+dirda.cv'></span>

<h3>Description</h3>

<p>Cross validation for estimating the classification rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dirda.cv(x, ina, folds = NULL, nfolds = 10, k = 2:10, stratified = FALSE,
         type = c("vmf", "iag", "esag", "kent", "knn"),
         seed = NULL, B = 1000, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cross+2B20validation+2B20for+2B20estimating+2B20the+2B20classification+2B20rate_+3A_x">x</code></td>
<td>

<p>A matrix with the data in Eulcidean coordinates, i.e. unit vectors. The matrix must have three columns, only spherical data are currently supported.
</p>
</td></tr>
<tr><td><code id="Cross+2B20validation+2B20for+2B20estimating+2B20the+2B20classification+2B20rate_+3A_ina">ina</code></td>
<td>

<p>A variable indicating the groupings.
</p>
</td></tr>
<tr><td><code id="Cross+2B20validation+2B20for+2B20estimating+2B20the+2B20classification+2B20rate_+3A_folds">folds</code></td>
<td>

<p>Do you already have a list with the folds? If not, leave this NULL.
</p>
</td></tr>
<tr><td><code id="Cross+2B20validation+2B20for+2B20estimating+2B20the+2B20classification+2B20rate_+3A_nfolds">nfolds</code></td>
<td>

<p>How many folds to create?
</p>
</td></tr>
<tr><td><code id="Cross+2B20validation+2B20for+2B20estimating+2B20the+2B20classification+2B20rate_+3A_k">k</code></td>
<td>

<p>If you choose to use k-NN, what will be the k values?
</p>
</td></tr>
<tr><td><code id="Cross+2B20validation+2B20for+2B20estimating+2B20the+2B20classification+2B20rate_+3A_stratified">stratified</code></td>
<td>

<p>Should the folds be created in a stratified way? i.e. keeping the distribution of the groups 
similar through all folds?
</p>
</td></tr>
<tr><td><code id="Cross+2B20validation+2B20for+2B20estimating+2B20the+2B20classification+2B20rate_+3A_seed">seed</code></td>
<td>

<p>If seed is TRUE, the results will always be the same.
</p>
</td></tr>
<tr><td><code id="Cross+2B20validation+2B20for+2B20estimating+2B20the+2B20classification+2B20rate_+3A_type">type</code></td>
<td>

<p>The type of classifier to use. The avaliable options are &quot;vmf&quot; (von Mises-Fisher distribution),
&quot;esag&quot; (ESAG distribution), &quot;kent&quot; (Kent distribution), &quot;knn&quot; (k-NN algorithm). You can chose 
any of them or all of them. Note that &quot;esag&quot; and &quot;kent&quot; work only with spherical data.
</p>
</td></tr>
<tr><td><code id="Cross+2B20validation+2B20for+2B20estimating+2B20the+2B20classification+2B20rate_+3A_b">B</code></td>
<td>

<p>If you used k-NN, should a bootstrap correction of the bias be applied? If yes, 1000 is a good value.
</p>
</td></tr>
<tr><td><code id="Cross+2B20validation+2B20for+2B20estimating+2B20the+2B20classification+2B20rate_+3A_parallel">parallel</code></td>
<td>

<p>If you want the standard -NN algorithm to take place in parallel set this equal to TRUE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cross-validation for the estimation of the performance of a classifier.
</p>
<p>The estimated performance of the best classifier is overestimated. After the cross-valdiation 
procedure, the predicted values produced by all classifiers are colelcted, from all folds, 
in an <code class="reqn">n \times M</code> matrix, where n is the number of samples and M the number of all 
classifiers used. We sample rows (predictions) with replacement from P and denote them as 
the in-sample values. The non re-sampled rows are denoted as out-of-sample values. The 
performance of each classifier in the insample rows is calculated and the classifier with 
the optimal performance is selected, followed by the calculation of performance in the 
out-of-sample  values. This process is repeated B times and the average performance is returned. 
The only computational overhead is with the repetitive resampling and calculation of the performance, 
i.e. no model or classifier is fitted nor trained. For more information see Tsamardinos et al. (2018). 
This procedure though takes place only for the k-NN algorithm.
</p>
<p>The good thing with the function is that you can run any method you want by supplying the 
folds yourselves using the command <code><a href="#topic+makefolds">makefolds</a></code>. Then suppose you want to run  another method. 
By suppying the same folds you will be able to have comparative results for all methods.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>perf</code></td>
<td>

<p>A vector with the estimated performance of each classifier.
</p>
</td></tr>
<tr><td><code>best</code></td>
<td>

<p>The classifier with the optimal performance.
</p>
</td></tr>
<tr><td><code>boot.perf</code></td>
<td>

<p>The bootstrap bias corrected performance.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Tsagris M. and Alenazi A. (2019). Comparison of discriminant analysis methods on the sphere. 
Communications in Statistics: Case Studies, Data Analysis and Applications, 5(4), 467&ndash;491.
</p>
<p>Mardia, K. V. and Jupp, P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
</p>
<p>Paine P.J., Preston S.P. and Tsagris M. and Wood A.T.A. (2018). An Elliptically Symmetric Angular 
Gaussian Distribution. Statistics and Computing, 28(3):689&ndash;697.
</p>
<p>Morris J. E. and Laycock P. J. (1974). Discriminant analysis of directional data. Biometrika, 61(2): 335&ndash;341.
</p>
<p>Tsamardinos I., Greasidou E. and Borboudakis G. (2018). Machince Learning, 107(12): 1895&ndash;1922.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+esag.da">esag.da</a>, <a href="#topic+vmfda.pred">vmfda.pred</a>, <a href="#topic+dirknn">dirknn</a>, <a href="#topic+knn.reg">knn.reg</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvmf(300, rnorm(3), 10)
ina &lt;- sample.int(4, 300, replace = TRUE)
dirda.cv(x, ina, B = 1000)
</code></pre>

<hr>
<h2 id='Cross+20validation+20in+20von+20Mises-Fisher+20discrminant+20analysis'>
Cross validation for estimating the classification rate of a discrminant analysis for directional data assuming a von Mises-Fisher distribution
</h2><span id='topic+vmf.da'></span>

<h3>Description</h3>

<p>Cross validation for estimating the classification rate of a discrminant analysis for directional data assuming a von Mises-Fisher distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vmf.da(x, ina, fraction = 0.2, R = 200, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cross+2B20validation+2B20in+2B20von+2B20Mises-Fisher+2B20discrminant+2B20analysis_+3A_x">x</code></td>
<td>

<p>A matrix with the data in Eulcidean coordinates, i.e. unit vectors.
</p>
</td></tr>
<tr><td><code id="Cross+2B20validation+2B20in+2B20von+2B20Mises-Fisher+2B20discrminant+2B20analysis_+3A_ina">ina</code></td>
<td>

<p>A variable indicating the groupings.
</p>
</td></tr>
<tr><td><code id="Cross+2B20validation+2B20in+2B20von+2B20Mises-Fisher+2B20discrminant+2B20analysis_+3A_fraction">fraction</code></td>
<td>

<p>The fraction of data to be used as test set.
</p>
</td></tr>
<tr><td><code id="Cross+2B20validation+2B20in+2B20von+2B20Mises-Fisher+2B20discrminant+2B20analysis_+3A_r">R</code></td>
<td>

<p>The number of repetitions.
</p>
</td></tr>
<tr><td><code id="Cross+2B20validation+2B20in+2B20von+2B20Mises-Fisher+2B20discrminant+2B20analysis_+3A_seed">seed</code></td>
<td>

<p>If seed is TRUE, the results will always be the same.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A repeated cross validation procedure is performed to estimate the rate of correct classification.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>percent</code></td>
<td>

<p>The estimated percent of correct classification and two estimated standard deviations. The one is the standard devation of the rates and the other is assuming a binomial distribution.
</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>

<p>Three types of confidence intervals, the standard one, another one based on the binomial distribution and the third one is the empirical one, which calcualtes the upper and lower 2.5% of the rates.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Tsagris M. and Alenazi A. (2019). Comparison of discriminant analysis methods on the sphere. 
Communications in Statistics: Case Studies, Data Analysis and Applications, 5(4): 467&ndash;491.
</p>
<p>Morris J. E. and Laycock P. J. (1974). Discriminant analysis of directional data. 
Biometrika, 61(2): 335&ndash;341.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vmfda.pred">vmfda.pred</a>, <a href="#topic+mixvmf.mle">mixvmf.mle</a>, <a href="#topic+vmf.mle">vmf.mle</a>, <a href="#topic+dirknn">dirknn</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvmf(100, rnorm(4), 15)
ina &lt;- rep(1:2, each = 50)
vmf.da(x, ina, fraction = 0.2, R = 200)
</code></pre>

<hr>
<h2 id='Cross+20validation+20with+20ESAG+20discrminant+20analysis'>
Cross validation for estimating the classification rate of a discrminant analysis for directional data assuming an ESAG distribution
</h2><span id='topic+esag.da'></span>

<h3>Description</h3>

<p>Cross validation for estimating the classification rate of a discrminant analysis for directional data assuming an ESAG distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>esag.da(y, ina, fraction = 0.2, R = 100, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cross+2B20validation+2B20with+2B20ESAG+2B20discrminant+2B20analysis_+3A_y">y</code></td>
<td>

<p>A matrix with the data in Eulcidean coordinates, i.e. unit vectors. The matrix must have three columns, only spherical data are currently supported.
</p>
</td></tr>
<tr><td><code id="Cross+2B20validation+2B20with+2B20ESAG+2B20discrminant+2B20analysis_+3A_ina">ina</code></td>
<td>

<p>A variable indicating the groupings.
</p>
</td></tr>
<tr><td><code id="Cross+2B20validation+2B20with+2B20ESAG+2B20discrminant+2B20analysis_+3A_fraction">fraction</code></td>
<td>

<p>The fraction of data to be used as test set.
</p>
</td></tr>
<tr><td><code id="Cross+2B20validation+2B20with+2B20ESAG+2B20discrminant+2B20analysis_+3A_r">R</code></td>
<td>

<p>The number of repetitions.
</p>
</td></tr>
<tr><td><code id="Cross+2B20validation+2B20with+2B20ESAG+2B20discrminant+2B20analysis_+3A_seed">seed</code></td>
<td>

<p>You can specify your own seed number here or leave it NULL.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A repeated cross validation procedure is performed to estimate the rate of correct classification.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>percent</code></td>
<td>

<p>The estimated percent of correct classification and two estimated standard deviations. The one is the standard devation of the rates and the other is
assuming a binomial distribution.
</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>

<p>Three types of confidence intervals, the standard one, another one based on the binomial distribution and the third one is the empirical one,
which calcualtes the upper and lower 2.5% of the rates.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Tsagris M. and Alenazi A. (2019). Comparison of discriminant analysis methods on the sphere. Communications in Statistics: Case Studies, Data Analysis and Applications, 5(4), 467&ndash;491.
</p>
<p>Paine P.J., Preston S.P., Tsagris M. and Wood A.T.A. (2018). An Elliptically Symmetric Angular
Gaussian Distribution. Statistics and Computing, 28(3):689&ndash;697.
</p>
<p>Mardia, K. V. and Jupp, P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vmf.da">vmf.da</a>, <a href="#topic+vmfda.pred">vmfda.pred</a>, <a href="#topic+dirknn">dirknn</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvmf(100, rnorm(3), 15)
ina &lt;- rep(1:2, each = 50)
esag.da(x, ina, fraction = 0.2, R = 50)
</code></pre>

<hr>
<h2 id='Cross+20validation+20with+20Purkayastha+20discrminant+20analysis'>
Cross validation for estimating the classification rate of a discrminant analysis for directional data assuming a Purkayastha distribution
</h2><span id='topic+purka.da'></span>

<h3>Description</h3>

<p>Cross validation for estimating the classification rate of a discrminant analysis for directional data assuming a Purkayastha distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>purka.da(y, ina, fraction = 0.2, R = 100, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cross+2B20validation+2B20with+2B20Purkayastha+2B20discrminant+2B20analysis_+3A_y">y</code></td>
<td>

<p>A numerical vector with data expressed in radians, or a matrix with two columns (cos and sin) for circular data.
Or a matrix with 3 columns (unit vectors) for spherical data.
</p>
</td></tr>
<tr><td><code id="Cross+2B20validation+2B20with+2B20Purkayastha+2B20discrminant+2B20analysis_+3A_ina">ina</code></td>
<td>

<p>A variable indicating the groupings.
</p>
</td></tr>
<tr><td><code id="Cross+2B20validation+2B20with+2B20Purkayastha+2B20discrminant+2B20analysis_+3A_fraction">fraction</code></td>
<td>

<p>The fraction of data to be used as test set.
</p>
</td></tr>
<tr><td><code id="Cross+2B20validation+2B20with+2B20Purkayastha+2B20discrminant+2B20analysis_+3A_r">R</code></td>
<td>

<p>The number of repetitions.
</p>
</td></tr>
<tr><td><code id="Cross+2B20validation+2B20with+2B20Purkayastha+2B20discrminant+2B20analysis_+3A_seed">seed</code></td>
<td>

<p>You can specify your own seed number here or leave it NULL.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A repeated cross validation procedure is performed to estimate the rate of correct classification.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>percent</code></td>
<td>

<p>The estimated percent of correct classification and two estimated standard deviations. The one is the standard devation of the rates and the other is
assuming a binomial distribution.
</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>

<p>Three types of confidence intervals, the standard one, another one based on the binomial distribution and the third one is the empirical one,
which calcualtes the upper and lower 2.5% of the rates.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Purkayastha S. (1991). A Rotationally Symmetric Directional Distribution: Obtained through Maximum Likelihood Characterization. The Indian Journal of Statistics, Series A, 53(1): 70-83
</p>
<p>Cabrera J. and Watson G. S. (1990). On a spherical median related distribution. Communications in Statistics-Theory and Methods, 19(6): 1973-1986.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vmf.da">vmf.da</a>, <a href="#topic+vmfda.pred">vmfda.pred</a>, <a href="#topic+dirknn">dirknn</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvmf(100, rnorm(3), 15)
ina &lt;- rep(1:2, each = 50)
purka.da(x, ina, fraction = 0.2, R = 50)
</code></pre>

<hr>
<h2 id='Cumulative+20distribution+20function+20of+20circular+20distributions'>
Cumulative distribution function of circular distributions
</h2><span id='topic+pvm'></span><span id='topic+pspml'></span><span id='topic+pwrapcauchy'></span><span id='topic+pcircpurka'></span><span id='topic+pcircbeta'></span><span id='topic+pcardio'></span><span id='topic+pcircexp'></span><span id='topic+pcipc'></span><span id='topic+pcipc'></span><span id='topic+pgcpc'></span><span id='topic+pmmvm'></span>

<h3>Description</h3>

<p>Cumulative probability distribution of circular distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pvm(u, m, k, rads = FALSE)
pspml(u, mu, rads = FALSE)
pwrapcauchy(u, m, rho, rads = FALSE)
pcircpurka(u, m, a, rads = FALSE)
pcircbeta(u, m, a, b, rads = FALSE)
pcardio(u, m, rho, rads = FALSE)
pcircexp(u, lambda, rads = FALSE)
pcipc(u, omega, g, rads = FALSE)
pgcpc(u, omega, g, rho, rads = FALSE)
pmmvm(u, m, k, N, rads = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cumulative+2B20distribution+2B20function+2B20of+2B20circular+2B20distributions_+3A_u">u</code></td>
<td>

<p>A numerical value, either in radians or in degrees.
</p>
</td></tr>
<tr><td><code id="Cumulative+2B20distribution+2B20function+2B20of+2B20circular+2B20distributions_+3A_m">m</code></td>
<td>

<p>The mean direction of the von Mises and the multi-modal von Mises distribution in radians or in degrees.
</p>
</td></tr>
<tr><td><code id="Cumulative+2B20distribution+2B20function+2B20of+2B20circular+2B20distributions_+3A_mu">mu</code></td>
<td>

<p>The mean vector, a vector with two values for the &quot;pspml&quot;.
</p>
</td></tr>
<tr><td><code id="Cumulative+2B20distribution+2B20function+2B20of+2B20circular+2B20distributions_+3A_omega">omega</code></td>
<td>

<p>The location parameter of the CIPC and GCPC distributions.
</p>
</td></tr>
<tr><td><code id="Cumulative+2B20distribution+2B20function+2B20of+2B20circular+2B20distributions_+3A_g">g</code></td>
<td>

<p>The norm of the mean vector for the CIPC and GCPC distributions.
</p>
</td></tr>
<tr><td><code id="Cumulative+2B20distribution+2B20function+2B20of+2B20circular+2B20distributions_+3A_k">k</code></td>
<td>

<p>The concentration parameter, <code class="reqn">\kappa</code>.
</p>
</td></tr>
<tr><td><code id="Cumulative+2B20distribution+2B20function+2B20of+2B20circular+2B20distributions_+3A_lambda">lambda</code></td>
<td>

<p>The <code class="reqn">\lambda</code> parameter of the circular exponential distribution. This must be positive.
</p>
</td></tr>
<tr><td><code id="Cumulative+2B20distribution+2B20function+2B20of+2B20circular+2B20distributions_+3A_a">a</code></td>
<td>

<p>The <code class="reqn">\alpha</code> parameter of the circular Purkayastha distribution or the <code class="reqn">\alpha</code> parameter of the
circular Beta distribution.
</p>
</td></tr>
<tr><td><code id="Cumulative+2B20distribution+2B20function+2B20of+2B20circular+2B20distributions_+3A_b">b</code></td>
<td>

<p>The <code class="reqn">\beta</code> parameter of the circular beta distribution.
</p>
</td></tr>
<tr><td><code id="Cumulative+2B20distribution+2B20function+2B20of+2B20circular+2B20distributions_+3A_rho">rho</code></td>
<td>

<p>The <code class="reqn">\rho</code> parameter of the Cardioid, wrapped Cauchy and GCPC distributions.
</p>
</td></tr>
<tr><td><code id="Cumulative+2B20distribution+2B20function+2B20of+2B20circular+2B20distributions_+3A_n">N</code></td>
<td>

<p>The number of modes to consider in the multi-modal von Mises distribution.
</p>
</td></tr>
<tr><td><code id="Cumulative+2B20distribution+2B20function+2B20of+2B20circular+2B20distributions_+3A_rads">rads</code></td>
<td>

<p>If the data are in radians, this should be TRUE and FALSE otherwise.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This value calculates the probability of u being less than some value <code class="reqn">\theta</code>.
</p>


<h3>Value</h3>

<p>The probability that of u being less than <code class="reqn">\theta</code>, where u follows a circular distribution.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Arthur Pewsey, Markus Neuhauser, and Graeme D. Ruxton (2013). Circular Statistics in R.
</p>
<p>Barnett M. J. and Kingston R. L. (2024). A note on the Hendrickson-Lattman phase probability
distribution and its equivalence to the generalized von Mises distribution.
Journal of Applied Crystallography, 57(2).
</p>
<p>Jammalamadaka S. R. and Kozubowski T. J. (2003). A new family of circular models:
The wrapped Laplace distributions. Advances and Applications in Statistics, 3(1): 77&ndash;103.
</p>
<p>Purkayastha S. (1991). A Rotationally Symmetric Directional Distribution: Obtained through
Maximum Likelihood Characterization. The Indian Journal of Statistics, Series A, 53(1): 70&ndash;83
</p>
<p>Cabrera J. and Watson G. S. (1990). On a spherical median related distribution.
Communications in Statistics&ndash;Theory and Methods, 19(6): 1973&ndash;1986.
</p>
<p>Paula F. V., Nascimento A. D., Amaral G. J. and Cordeiro G. M. (2021).
Generalized Cardioid distributions for circular data analysis. Stats, 4(3): 634&ndash;649.
</p>
<p>Zheng Sun (2009). Comparing measures of fit for circular distributions. MSc Thesis, University of Victoria.
file:///C:/Users/mtsag/Downloads/zhengsun_master_thesis.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+group.gof">group.gof</a>, <a href="#topic+dvm">dvm</a>, <a href="#topic+dcircexp">dcircexp</a>,
<a href="#topic+purka.mle">purka.mle</a>, <a href="#topic+dcircpurka">dcircpurka</a>, <a href="#topic+dmmvm">dmmvm</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pvm(1, 2, 10, rads = TRUE)
pmmvm(1, 2, 10, 3, rads = TRUE)
pcircexp(c(1, 2), 2, rads = TRUE)
pcircpurka(2, 3, 0.3)
</code></pre>

<hr>
<h2 id='Density+20of+20a+20mixture+20of+20von+20Mises-Fisher+20distributions'>
Density of a mixture of von Mises-Fisher distributions
</h2><span id='topic+dmixvmf'></span>

<h3>Description</h3>

<p>Density of a mixture of von Mises-Fisher distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmixvmf(y, probs, mu, k, logden = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Density+2B20of+2B20a+2B20mixture+2B20of+2B20von+2B20Mises-Fisher+2B20distributions_+3A_y">y</code></td>
<td>

<p>A matrix with unit vectors.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20a+2B20mixture+2B20of+2B20von+2B20Mises-Fisher+2B20distributions_+3A_probs">probs</code></td>
<td>

<p>This is avector with the mixing probability of each group.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20a+2B20mixture+2B20of+2B20von+2B20Mises-Fisher+2B20distributions_+3A_mu">mu</code></td>
<td>

<p>A matrix with the mean direction of each group.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20a+2B20mixture+2B20of+2B20von+2B20Mises-Fisher+2B20distributions_+3A_k">k</code></td>
<td>

<p>A vector with the concentration parameter of each group.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20a+2B20mixture+2B20of+2B20von+2B20Mises-Fisher+2B20distributions_+3A_logden">logden</code></td>
<td>

<p>If you the logarithm of the density values set this to TRUE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the density for a given mixture of von Mises-Fisher distributions.
</p>


<h3>Value</h3>

<p>A vector with the (log) density values of y.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Kurt Hornik and  Bettina Grun (2014). movMF: An R Package for Fitting Mixtures of von Mises-Fisher Distributions
http://cran.r-project.org/web/packages/movMF/vignettes/movMF.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mixvmf.mle">mixvmf.mle</a>, <a href="#topic+rvmf">rvmf</a>, <a href="#topic+bic.mixvmf">bic.mixvmf</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k &lt;- runif(3, 4, 6)
probs &lt;- c(0.2, 0.5, 0.3)
mu &lt;- matrix(rnorm(9), ncol = 3)
mu &lt;- mu / sqrt( rowSums(mu^2) )
x &lt;- rmixvmf(200, probs, mu, k)$x
b &lt;- dmixvmf(x, probs, mu, k)
</code></pre>

<hr>
<h2 id='Density+20of+20some+20+28hyper-+29spherical+20distributions'>
Density of some (hyper-)spherical distributions
</h2><span id='topic+dvmf'></span><span id='topic+iagd'></span><span id='topic+dpurka'></span><span id='topic+dspcauchy'></span><span id='topic+dpkbd'></span>

<h3>Description</h3>

<p>Density of some (hyper-)spherical distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dvmf(y, mu, k, logden = FALSE )
iagd(y, mu, logden = FALSE)
dpurka(y, theta, a, logden = FALSE)
dspcauchy(y, mu, rho, logden = FALSE)
dpkbd(y, mu, rho, logden = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Density+2B20of+2B20some+2B20+2B28hyper-+2B29spherical+2B20distributions_+3A_y">y</code></td>
<td>

<p>A matrix or a vector with the data expressed in Euclidean coordinates, i.e. unit vectors.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20some+2B20+2B28hyper-+2B29spherical+2B20distributions_+3A_mu">mu</code></td>
<td>

<p>The mean direction (unit vector) of the von Mises-Fisher, the IAG, the spherical Cauchy distribution,
or of the Poisson kernel based distribution.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20some+2B20+2B28hyper-+2B29spherical+2B20distributions_+3A_theta">theta</code></td>
<td>

<p>The mean direction (unit vector) of the Purkayastha distribution.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20some+2B20+2B28hyper-+2B29spherical+2B20distributions_+3A_k">k</code></td>
<td>

<p>The concentration parameter of the von Mises-Fisher distribution.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20some+2B20+2B28hyper-+2B29spherical+2B20distributions_+3A_a">a</code></td>
<td>

<p>The concentration parameter of the Purkayastha distribution.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20some+2B20+2B28hyper-+2B29spherical+2B20distributions_+3A_rho">rho</code></td>
<td>

<p>The <code class="reqn">\rho</code> parameter of the spherical Cauchy distribution, or of the
Poisson kernel based distribution.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20some+2B20+2B28hyper-+2B29spherical+2B20distributions_+3A_logden">logden</code></td>
<td>

<p>If you the logarithm of the density values set this to TRUE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density of the von Mises-Fisher, of the IAG, of the Purkayastha, of the spherical Cauchy distribution, or of the Poisson kernel based distribution is computed.
</p>


<h3>Value</h3>

<p>A vector with the (log) density values of y.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Mardia K. V. and Jupp P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
</p>
<p>Purkayastha S. (1991). A Rotationally Symmetric Directional Distribution: Obtained through Maximum Likelihood Characterization. The Indian Journal of Statistics, Series A, 53(1): 70&ndash;83
</p>
<p>Cabrera J. and Watson G. S. (1990). On a spherical median related distribution. Communications in Statistics-Theory and Methods, 19(6): 1973&ndash;1986.
</p>
<p>Kato S. and McCullagh P. (2020). Some properties of a Cauchy family on the sphere derived from the Mobius transformations. Bernoulli, 26(4): 3224&ndash;3248.
https://arxiv.org/pdf/1510.07679.pdf
</p>
<p>Golzy M. and Markatou M. (2020). Poisson kernel-based clustering on the sphere:
convergence properties, identifiability, and a method of sampling.
Journal of Computational and Graphical Statistics, 29(4): 758&ndash;770.
</p>
<p>Sablica L., Hornik K. and Leydold J. (2023). Efficient sampling from the PKBD distribution.
Electronic Journal of Statistics, 17(2): 2180&ndash;2209.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kent.mle">kent.mle</a>, <a href="#topic+rkent">rkent</a>, <a href="#topic+esag.mle">esag.mle</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- colMeans( as.matrix( iris[,1:3] ) )
y &lt;- rvmf(1000, m = m, k = 10)
dvmf(y, k=10, m)
</code></pre>

<hr>
<h2 id='Density+20of+20some+20circular+20distributions'>
Density of some circular distributions
</h2><span id='topic+dvm'></span><span id='topic+dspml'></span><span id='topic+dwrapcauchy'></span><span id='topic+dcircpurka'></span><span id='topic+dggvm'></span><span id='topic+dcircbeta'></span><span id='topic+dcardio'></span><span id='topic+dcircexp'></span><span id='topic+dcipc'></span><span id='topic+dgcpc'></span><span id='topic+dmmvm'></span>

<h3>Description</h3>

<p>Density of some circular distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dvm(x, m, k, rads = FALSE, logden = FALSE)
dspml(x, mu, rads = FALSE, logden = FALSE)
dwrapcauchy(x, m, rho, rads = FALSE, logden = FALSE)
dcircpurka(x, m, a, rads = FALSE, logden = FALSE)
dggvm(x, param, rads = FALSE, logden = FALSE)
dcircbeta(x, m, a, b, rads = FALSE, logden = FALSE)
dcardio(x, m, rho, rads = FALSE, logden = FALSE)
dcircexp(x, lambda, rads = FALSE, logden = FALSE)
dcipc(x, omega, g, rads = FALSE, logden = FALSE)
dgcpc(x, omega, g, rho, rads = FALSE, logden = FALSE)
dmmvm(x, m, k, N, rads = FALSE, logden = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Density+2B20of+2B20some+2B20circular+2B20distributions_+3A_x">x</code></td>
<td>

<p>A vector with circular data.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20some+2B20circular+2B20distributions_+3A_m">m</code></td>
<td>

<p>The mean value of the von Mises distribution and of the cardioid, a scalar.
This is the median for the circular Purkayastha distribution.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20some+2B20circular+2B20distributions_+3A_mu">mu</code></td>
<td>

<p>The mean vector, a vector with two values for the &quot;spml&quot; and the GCPC.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20some+2B20circular+2B20distributions_+3A_omega">omega</code></td>
<td>

<p>The location parameter of the CIPC and GCPC distributions.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20some+2B20circular+2B20distributions_+3A_g">g</code></td>
<td>

<p>The norm of the mean vector for the CIPC and GCPC distributions.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20some+2B20circular+2B20distributions_+3A_k">k</code></td>
<td>

<p>The concentration parameter.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20some+2B20circular+2B20distributions_+3A_rho">rho</code></td>
<td>

<p>For the wrapped Cauchy and Cardioid distributions, this is the <code class="reqn">\rho</code> parameter.
For the GCPC distribution this is the eigenvalue parameter, or covariance determinant.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20some+2B20circular+2B20distributions_+3A_a">a</code></td>
<td>

<p>The <code class="reqn">\alpha</code> parameter of the circular Purkayastha distribution or the <code class="reqn">\alpha</code> parameter of the
circular Beta distribution.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20some+2B20circular+2B20distributions_+3A_b">b</code></td>
<td>

<p>The <code class="reqn">\beta</code> parameter of the circular Beta distribution.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20some+2B20circular+2B20distributions_+3A_lambda">lambda</code></td>
<td>

<p>The <code class="reqn">\lambda</code> parameter of the circular (or wrapped) exponential distribution. This must be positive.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20some+2B20circular+2B20distributions_+3A_param">param</code></td>
<td>

<p>The vector of parameters of the GGVM distribution as returned by the function <code><a href="#topic+ggvm.mle">ggvm.mle</a></code>.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20some+2B20circular+2B20distributions_+3A_n">N</code></td>
<td>

<p>The number of modes to consider in the multi-modal von Mises distribution.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20some+2B20circular+2B20distributions_+3A_rads">rads</code></td>
<td>

<p>If the data are in rads, then this should be TRUE, otherwise FALSE.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20some+2B20circular+2B20distributions_+3A_logden">logden</code></td>
<td>

<p>If you the logarithm of the density values set this to TRUE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density of the von Mises, bivariate projected normal, cardio, circular exponential,
wrapped Cauchy, circular Purkayastha, CIPC or GCPC distributions is computed.
</p>


<h3>Value</h3>

<p>A vector with the (log) density values of x.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Mardia K. V. and Jupp P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
</p>
<p>Tsagris M. and Alzeley O. (2023). Circular and spherical projected Cauchy distributions:
A Novel Framework for Circular and Directional Data Modeling.
https://arxiv.org/pdf/2302.02468.pdf
</p>
<p>Presnell B., Morrison S. P. and Littell R. C. (1998). Projected multivariate linear models for
directional data. Journal of the American Statistical Association, 93(443): 1068&ndash;1077.
</p>
<p>Jammalamadaka S. R. and Kozubowski T. J. (2003). A new family of circular models:
The wrapped Laplace distributions. Advances and Applications in Statistics, 3(1): 77&ndash;103.
</p>
<p>Barnett M. J. and Kingston R. L. (2024). A note on the Hendrickson-Lattman phase probability
distribution and its equivalence to the generalized von Mises distribution.
Journal of Applied Crystallography, 57(2).
</p>
<p>Paula F. V., Nascimento A. D., Amaral G. J. and Cordeiro G. M. (2021).
Generalized Cardioid distributions for circular data analysis. Stats, 4(3): 634&ndash;649.
</p>
<p>Zheng Sun (2009). Comparing measures of fit for circular distributions. MSc Thesis, University of Victoria.
file:///C:/Users/mtsag/Downloads/zhengsun_master_thesis.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dkent">dkent</a>, <a href="#topic+rvonmises">rvonmises</a>, <a href="#topic+desag">desag</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvonmises(500, m = 2.5, k = 10, rads = TRUE)
mod &lt;- circ.summary(x, rads = TRUE, plot = FALSE)
den &lt;- dvm(x, mod$mesos, mod$kappa, rads = TRUE, logden = TRUE )
mod$loglik
sum(den)
</code></pre>

<hr>
<h2 id='Density+20of+20the+20SESPC+20distribution'>
Density of the SESPC distribution
</h2><span id='topic+dsespc'></span>

<h3>Description</h3>

<p>Density of the SESPC distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsespc(y, mu, theta, logden = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Density+2B20of+2B20the+2B20SESPC+2B20distribution_+3A_y">y</code></td>
<td>

<p>A matrix or a vector with the data expressed in Euclidean coordinates, i.e. unit vectors.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20the+2B20SESPC+2B20distribution_+3A_mu">mu</code></td>
<td>

<p>The mean vector the SESPC distribution, a vector in <code class="reqn">R^3</code>.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20the+2B20SESPC+2B20distribution_+3A_theta">theta</code></td>
<td>

<p>The two <code class="reqn">\theta</code> parameters of the SESPC distribution.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20the+2B20SESPC+2B20distribution_+3A_logden">logden</code></td>
<td>

<p>If you the logarithm of the density values set this to TRUE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density of the SESPC distribution is computed.
</p>


<h3>Value</h3>

<p>A vector with the (log) density values of y.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Tsagris M. and Alzeley O. (2023). Circular and spherical projected Cauchy distributions: 
A Novel Framework for Circular and Directional Data Modeling.
https://arxiv.org/pdf/2302.02468.pdf
</p>
<p>Mardia K. V. and Jupp P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+desag">desag</a>, <a href="#topic+sespc.mle">sespc.mle</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- colMeans( as.matrix( iris[,1:3] ) )
y &lt;- rsespc(1000, m, c(1, 1))
mod &lt;- sespc.mle(y)
dsespc( y, mod$mu, mod$theta)
</code></pre>

<hr>
<h2 id='Density+20of+20the+20spherical+20ESAG+20and+20Kent+20distributions'>
Density of the spherical ESAG and Kent distributions
</h2><span id='topic+desag'></span><span id='topic+dkent'></span>

<h3>Description</h3>

<p>Density of the spherical ESAG and Kent distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>desag(y, mu, gam, logden = FALSE)
dkent(y, G, param, logden = FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Density+2B20of+2B20the+2B20spherical+2B20ESAG+2B20and+2B20Kent+2B20distributions_+3A_y">y</code></td>
<td>

<p>A matrix or a vector with the data expressed in Euclidean coordinates, i.e. unit vectors.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20the+2B20spherical+2B20ESAG+2B20and+2B20Kent+2B20distributions_+3A_mu">mu</code></td>
<td>

<p>The mean vector the ESAG distribution, a vector in <code class="reqn">R^3</code>.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20the+2B20spherical+2B20ESAG+2B20and+2B20Kent+2B20distributions_+3A_gam">gam</code></td>
<td>

<p>The two <code class="reqn">\gamma</code> parameters of the ESAG distribution.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20the+2B20spherical+2B20ESAG+2B20and+2B20Kent+2B20distributions_+3A_g">G</code></td>
<td>

<p>For the Kent distribution only, a 3 x 3 matrix whose first column is the mean direction. The second and third columns are the major and minor axes respectively.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20the+2B20spherical+2B20ESAG+2B20and+2B20Kent+2B20distributions_+3A_param">param</code></td>
<td>

<p>For the Kent distribution a vector with the concentration <code class="reqn">\kappa</code> and ovalness <code class="reqn">\beta</code> parameters. The <code class="reqn">\psi</code> has been absorbed inside the matrix G.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20the+2B20spherical+2B20ESAG+2B20and+2B20Kent+2B20distributions_+3A_logden">logden</code></td>
<td>

<p>If you the logarithm of the density values set this to TRUE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density of the spherical ESAG or Kent distribution is computed.
</p>


<h3>Value</h3>

<p>A vector with the (log) density values of y.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Mardia K. V. and Jupp P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
</p>
<p>Paine P.J., Preston S.P., Tsagris M. and Wood A.T.A. (2018). An Elliptically Symmetric Angular
Gaussian Distribution. Statistics and Computing, 28(3):689&ndash;697.
</p>
<p>Kent John (1982). The Fisher-Bingham distribution on the sphere. Journal of the Royal Statistical Society,
Series B, 44(1): 71&ndash;80.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kent.mle">kent.mle</a>, <a href="#topic+rkent">rkent</a>, <a href="#topic+esag.mle">esag.mle</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- colMeans( as.matrix( iris[,1:3] ) )
y &lt;- rkent(1000, k = 10, m = m, b = 4)
mod &lt;- kent.mle(y)
dkent( y, G = mod$G, param = mod$param )
</code></pre>

<hr>
<h2 id='Density+20of+20the+20Wood+20bimodal+20distribution+20on+20the+20sphere'>
Density of the Wood bimodal distribution on the sphere
</h2><span id='topic+dwood'></span>

<h3>Description</h3>

<p>Density of the Wood bimodal distribution on the sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwood(y, param, logden = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Density+2B20of+2B20the+2B20Wood+2B20bimodal+2B20distribution+2B20on+2B20the+2B20sphere_+3A_y">y</code></td>
<td>

<p>A matrix containing two columns. The first one is the latitude and the second is the longitude, both expressed in degrees.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20the+2B20Wood+2B20bimodal+2B20distribution+2B20on+2B20the+2B20sphere_+3A_param">param</code></td>
<td>

<p>A vector with the 5 parameters, in the order they are returned by the <code><a href="#topic+wood.mle">wood.mle</a></code> function.
That is, <code class="reqn">(\gamma, \delta, \alpha, \beta, \kappa)</code>.
</p>
</td></tr>
<tr><td><code id="Density+2B20of+2B20the+2B20Wood+2B20bimodal+2B20distribution+2B20on+2B20the+2B20sphere_+3A_logden">logden</code></td>
<td>

<p>If you the logarithm of the density values set this to TRUE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density of the spherical Wood distribution is computed.
</p>


<h3>Value</h3>

<p>A vector with the (log) density values of y.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Wood A.T.A. (1982). A bimodal distribution on the sphere.
Journal of the Royal Statistical Society, Series C, 31(1): 52&ndash;58.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dkent">dkent</a>, <a href="#topic+desag">desag</a>, <a href="#topic+wood.mle">wood.mle</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvmf(100, rnorm(3), 15)
x &lt;- euclid.inv(x)
mod &lt;- wood.mle(x)
d &lt;- dwood(x, mod$info[, 1])
</code></pre>

<hr>
<h2 id='Euclidean+20transformation'>
Euclidean transformation
</h2><span id='topic+euclid'></span>

<h3>Description</h3>

<p>It transforms the data from the spherical coordinates to Euclidean coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euclid(u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Euclidean+2B20transformation_+3A_u">u</code></td>
<td>

<p>A two column matrix or even one single vector, where the first column (or element) is the latitude and the second is the longitude. The order is important.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It takes the matrix of unit vectors of latitude and longitude and  transforms it to unit vectors.
</p>


<h3>Value</h3>

<p>A three column matrix:
</p>
<table>
<tr><td><code>U</code></td>
<td>
<p> The Euclidean coordinates of the latitude and longitude.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+euclid.inv">euclid.inv</a>, <a href="#topic+Arotation">Arotation</a>, <a href="#topic+lambert">lambert</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvmf(10, rnorm(3), 10)
u &lt;- euclid.inv(x)
euclid(u)
x
</code></pre>

<hr>
<h2 id='Euler+20angles+20+20from+20a+20rotation+20matrix+20on+20SO+283+29'>
Compute the Euler angles from a rotation matrix on SO(3).
</h2><span id='topic+rot2eul'></span>

<h3>Description</h3>

<p>It calculates three euler angles <code class="reqn">(\theta_{12}, \theta_{13}, \theta_{23})</code> from a <code class="reqn">(3 \times 3)</code> rotation matrix X, where X is defined as <code class="reqn">X = R_z(\theta_{12})\times R_y(\theta_{13}) \times R_x(\theta_{23})</code>. Here <code class="reqn">R_x(\theta_{23})</code> means a rotation of <code class="reqn">\theta_{23}</code> radians about the x axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rot2eul(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Euler+2B20angles+2B20+2B20from+2B20a+2B20rotation+2B20matrix+2B20on+2B20SO+2B283+2B29_+3A_x">X</code></td>
<td>

<p>A rotation matrix which is defined as a product of three elementary rotations mentioned above.
Here <code class="reqn"> \theta_{12}, \theta_{23} \in (-\pi, \pi)</code> and and <code class="reqn">\theta_{13} \in (-\pi/2, \pi/2)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a rotation matrix X, euler angles are computed by equating each element in X with the
corresponding element in the matrix product defined above. This results in nine equations that
can be used to find the euler angles.
</p>


<h3>Value</h3>

<p>For a given rotation matrix, there are two eqivalent sets of euler angles.
</p>


<h3>Author(s)</h3>

<p>Anamul Sajib &lt;sajibstat@du.ac.bd&gt;.
</p>
<p>R implementation and documentation: Anamul Sajib &lt;sajibstat@du.ac.bd&gt;.
</p>


<h3>References</h3>

<p>Green, P. J. and Mardia, K. V. (2006). Bayesian alignment using hierarchical models, with applications
in proteins bioinformatics. Biometrika, 93(2):235&ndash;254.
</p>
<p>http://www.staff.city.ac.uk/~sbbh653/publications/euler.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eul2rot">eul2rot</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># three euler angles

theta.12 &lt;- sample( seq(-3, 3, 0.3), 1 )
theta.23 &lt;- sample( seq(-3, 3, 0.3), 1 )
theta.13 &lt;- sample( seq(-1.4, 1.4, 0.3), 1 )

theta.12 ; theta.23 ; theta.13

X &lt;- eul2rot(theta.12, theta.23, theta.13)
X  ##  A rotation matrix

e &lt;- rot2eul(X)$v1

theta.12 &lt;- e[3]
theta.23 &lt;- e[2]
theta.13 &lt;- e[1]

theta.12 ; theta.23 ; theta.13
</code></pre>

<hr>
<h2 id='Forward+20Backward+20Early+20Dropping+20selection+20for+20circular+20data+20using+20the+20SPML+20regression'>
Forward Backward Early Dropping selection for circular data using the SPML regression
</h2><span id='topic+spml.fbed'></span>

<h3>Description</h3>

<p>Forward Backward Early Dropping selection for circular data using the SPML regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spml.fbed(y, x, alpha = 0.05, K = 0, backward = FALSE,
         parallel = FALSE, tol = 1e-07, maxiters = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Forward+2B20Backward+2B20Early+2B20Dropping+2B20selection+2B20for+2B20circular+2B20data+2B20using+2B20the+2B20SPML+2B20regression_+3A_y">y</code></td>
<td>

<p>The response variable, a numeric vector expressed in rads.
</p>
</td></tr>
<tr><td><code id="Forward+2B20Backward+2B20Early+2B20Dropping+2B20selection+2B20for+2B20circular+2B20data+2B20using+2B20the+2B20SPML+2B20regression_+3A_x">x</code></td>
<td>

<p>A matrix with continuous independent variables.
</p>
</td></tr>
<tr><td><code id="Forward+2B20Backward+2B20Early+2B20Dropping+2B20selection+2B20for+2B20circular+2B20data+2B20using+2B20the+2B20SPML+2B20regression_+3A_alpha">alpha</code></td>
<td>

<p>The significance threshold value for assessing p-values. Default value is 0.05.
</p>
</td></tr>
<tr><td><code id="Forward+2B20Backward+2B20Early+2B20Dropping+2B20selection+2B20for+2B20circular+2B20data+2B20using+2B20the+2B20SPML+2B20regression_+3A_k">K</code></td>
<td>

<p>How many times should the process be repeated? The default value is 0.
</p>
</td></tr>
<tr><td><code id="Forward+2B20Backward+2B20Early+2B20Dropping+2B20selection+2B20for+2B20circular+2B20data+2B20using+2B20the+2B20SPML+2B20regression_+3A_backward">backward</code></td>
<td>

<p>After the Forward Early Dropping phase, the algorithm proceeds witha the usual Backward Selection phase.
The default value is set to TRUE. It is advised to perform this step as maybe some variables are false positives,
they were wrongly selected. This is rather experimental now and there could be some mistakes in the indices of the
selected variables. <b>Do not use it for now</b>.
</p>
</td></tr>
<tr><td><code id="Forward+2B20Backward+2B20Early+2B20Dropping+2B20selection+2B20for+2B20circular+2B20data+2B20using+2B20the+2B20SPML+2B20regression_+3A_parallel">parallel</code></td>
<td>

<p>If you want the algorithm to run in parallel set this TRUE.
</p>
</td></tr>
<tr><td><code id="Forward+2B20Backward+2B20Early+2B20Dropping+2B20selection+2B20for+2B20circular+2B20data+2B20using+2B20the+2B20SPML+2B20regression_+3A_tol">tol</code></td>
<td>

<p>The tolerance value to terminate the Newton-Raphson algorithm.
</p>
</td></tr>
<tr><td><code id="Forward+2B20Backward+2B20Early+2B20Dropping+2B20selection+2B20for+2B20circular+2B20data+2B20using+2B20the+2B20SPML+2B20regression_+3A_maxiters">maxiters</code></td>
<td>

<p>The maximum number of iterations Newton-Raphson will perform.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm is a variation of the usual forward selection. At every step, the most
significant variable enters the selected variables set. In addition, only the significant
variables stay and are further examined. The non signifcant ones are dropped. This goes
until no variable can enter the set. The user has the option to re-do this step 1 or more times
(the argument K). In the end, a backward selection is performed to remove falsely selected variables.
Note that you may have specified, for example, K=10, but the maximum value FBED used can be 4 for example.
</p>


<h3>Value</h3>

<p>If K is a single number a list including:
Note, that the &quot;gam&quot; argument must be the same though.
</p>
<table>
<tr><td><code>res</code></td>
<td>

<p>A matrix with the selected variables and their test statistic.
</p>
</td></tr>
<tr><td><code>info</code></td>
<td>

<p>A matrix with the number of variables and the number of tests performed
(or models fitted) at each round (value of K). This refers to the
forward phase only.
</p>
</td></tr>
<tr><td><code>runtime</code></td>
<td>

<p>The runtime required.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Borboudakis G. and Tsamardinos I. (2019). Forward-backward selection with early dropping. Journal of Machine Learning Research, 20(8): 1&ndash;39.
</p>
<p>Tsagis M. (2018). Guide on performing feature selection with the R package MXM.
https://f1000research.com/articles/7-1505
</p>
<p>Presnell Brett, Morrison Scott P. and Littell Ramon C. (1998). Projected multivariate linear models for directional data.
Journal of the American Statistical Association, 93(443): 1068&ndash;1077.
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+spml.reg">spml.reg</a>, <a href="#topic+spml.regs">spml.regs</a>, <a href="#topic+spml.mle">spml.mle</a> </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix( runif(100 * 50, 1, 100), ncol = 50 )
y &lt;- runif(100)
a &lt;- spml.fbed(y, x)
</code></pre>

<hr>
<h2 id='Generate+20random+20folds+20for+20cross-validation'>
Generate random folds for cross-validation
</h2><span id='topic+makefolds'></span>

<h3>Description</h3>

<p>Random folds for use in a cross validation are generated. There is the option for stratified splitting as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makefolds(ina, nfolds = 10, stratified = TRUE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Generate+2B20random+2B20folds+2B20for+2B20cross-validation_+3A_ina">ina</code></td>
<td>

<p>A variable indicating the groupings.
</p>
</td></tr>
<tr><td><code id="Generate+2B20random+2B20folds+2B20for+2B20cross-validation_+3A_nfolds">nfolds</code></td>
<td>

<p>The number of folds to produce.
</p>
</td></tr>
<tr><td><code id="Generate+2B20random+2B20folds+2B20for+2B20cross-validation_+3A_stratified">stratified</code></td>
<td>

<p>A boolean variable specifying whether stratified random (TRUE) or simple random (FALSE) sampling is to be used when producing the folds.
</p>
</td></tr>
<tr><td><code id="Generate+2B20random+2B20folds+2B20for+2B20cross-validation_+3A_seed">seed</code></td>
<td>

<p>You can specify your own seed number here or leave it NULL.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>I was inspired by the command in the package <b>TunePareto</b> in order to do the stratified version.
</p>


<h3>Value</h3>

<p>A list with nfolds elements where each elements is a fold containing the indices of the data.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dirda.cv">dirda.cv</a> </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- makefolds(iris[, 5], nfolds = 5, stratified = TRUE)
table(iris[a[[1]], 5])  ## 10 values from each group
</code></pre>

<hr>
<h2 id='Generation+20of+20unit+20vector+28s+29+20with+20a+20given+20angle'>
Generation of unit vector(s) with a given angle
</h2><span id='topic+vec'></span>

<h3>Description</h3>

<p>Generation of unit vector(s) with a given angle from a given unit vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec(x, n = 1, deg = 90)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Generation+2B20of+2B20unit+2B20vector+2B28s+2B29+2B20with+2B20a+2B20given+2B20angle_+3A_x">x</code></td>
<td>

<p>A unit vector. If it is not a unit vector it becomes one.
</p>
</td></tr>
<tr><td><code id="Generation+2B20of+2B20unit+2B20vector+2B28s+2B29+2B20with+2B20a+2B20given+2B20angle_+3A_n">n</code></td>
<td>

<p>The number of unit vectors to return.
</p>
</td></tr>
<tr><td><code id="Generation+2B20of+2B20unit+2B20vector+2B28s+2B29+2B20with+2B20a+2B20given+2B20angle_+3A_deg">deg</code></td>
<td>

<p>The angle between the given vector and the n vectors to be returned. This must be in degrees and it has to be between 0 and 180 degrees.
If the angle is 0, the same unit vector will be returned. If the angle is 180, the same unit vector with the signs changed will be returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user provides a unit vector and the degrees. The function will return n unit vectors whose angle with the given unit vector equals the degrees given.
For example, if you want 10 unit vectors purpendicualr to the x put vec(x, 10, 90).
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>runtime</code></td>
<td>

<p>The runtime of the procedure.
</p>
</td></tr>
<tr><td><code>crit</code></td>
<td>

<p>The calculated angle between the given unit vector and each of the generated unit vectors.
</p>
</td></tr>
<tr><td><code>mat</code></td>
<td>

<p>A matrix with the n unit vectors.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rvmf">rvmf</a>, <a href="#topic+rbingham">rbingham</a>, <a href="#topic+rfb">rfb</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(10)
x &lt;- x / sqrt( sum(x^2) )
a &lt;- vec(x, 20, 90)
</code></pre>

<hr>
<h2 id='Goodness+20of+20fit+20test+20for+20grouped+20data'>
Goodness of fit test for grouped data
</h2><span id='topic+group.gof'></span>

<h3>Description</h3>

<p>Goodness of fit test for grouped data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group.gof(g, ni, m, k, dist = "vm", rads = FALSE, R = 999, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Goodness+2B20of+2B20fit+2B20test+2B20for+2B20grouped+2B20data_+3A_g">g</code></td>
<td>

<p>A vector with the group points, either in radians or in degrees.
</p>
</td></tr>
<tr><td><code id="Goodness+2B20of+2B20fit+2B20test+2B20for+2B20grouped+2B20data_+3A_ni">ni</code></td>
<td>

<p>The frequency of each or group class.
</p>
</td></tr>
<tr><td><code id="Goodness+2B20of+2B20fit+2B20test+2B20for+2B20grouped+2B20data_+3A_m">m</code></td>
<td>

<p>The mean direction in radians or in degrees.
</p>
</td></tr>
<tr><td><code id="Goodness+2B20of+2B20fit+2B20test+2B20for+2B20grouped+2B20data_+3A_k">k</code></td>
<td>

<p>The concentration parameter, <code class="reqn">\kappa</code>.
</p>
</td></tr>
<tr><td><code id="Goodness+2B20of+2B20fit+2B20test+2B20for+2B20grouped+2B20data_+3A_dist">dist</code></td>
<td>

<p>The distribution to be tested, it can be either &quot;vm&quot; or &quot;uniform&quot;.
</p>
</td></tr>
<tr><td><code id="Goodness+2B20of+2B20fit+2B20test+2B20for+2B20grouped+2B20data_+3A_rads">rads</code></td>
<td>

<p>If the data are in radians, this should be TRUE and FALSE otherwise.
</p>
</td></tr>
<tr><td><code id="Goodness+2B20of+2B20fit+2B20test+2B20for+2B20grouped+2B20data_+3A_r">R</code></td>
<td>

<p>The number of bootstrap simulations to perform, set to 999 by default.
</p>
</td></tr>
<tr><td><code id="Goodness+2B20of+2B20fit+2B20test+2B20for+2B20grouped+2B20data_+3A_ncores">ncores</code></td>
<td>

<p>The number of cores to use.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When you have grouped data, you can test whether the data come from the von Mises-Fisher distribution or from a uniform distribution.
</p>


<h3>Value</h3>

<p>This is an &quot;htest&quot;class object. Thus it returns a list including:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>

<p>The test statistic value.
</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>

<p>Since this is a bootstrap based test, there are no degrees of freedom, hence this is &quot;NA&quot;.
</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>

<p>The p-value of the test.
</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>

<p>A character with the alternative hypothesis.
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>A character with the test used.
</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>

<p>A character vector with two elements.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Arthur Pewsey, Markus Neuhauser, and Graeme D. Ruxton (2013). Circular Statistics in R.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pvm">pvm</a>, <a href="#topic+circ.summary">circ.summary</a>, <a href="#topic+rvonmises">rvonmises</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvonmises(100, 2, 10)
g &lt;- seq(min(x) - 0.1, max(x) + 0.1, length = 6)
ni &lt;- as.vector( table( cut(x, g) ) )
group.gof(g, ni, 2, 10, dist = "vm", rads = TRUE, R = 299, ncores = 1)
group.gof(g, ni, 2, 5, dist = "vm", rads = TRUE, R = 299, ncores = 1)
</code></pre>

<hr>
<h2 id='Habeck+27s+20rotation+20matrix+20generation'>
Generation of three-dimensional random rotations using Habeck's algorithm.
</h2><span id='topic+habeck.rot'></span>

<h3>Description</h3>

<p>It generates random rotations in three-dimensional space that follow a probability distribution,
matrix Fisher distribution, arising in fitting and matching problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>habeck.rot(F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Habeck+2B27s+2B20rotation+2B20matrix+2B20generation_+3A_f">F</code></td>
<td>

<p>An arbitrary 3 x 3 matrix represents the parameter matrix of this distribution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Firstly rotation matrices <b>X</b> are chosen which are the closest to F, and then parameterized using euler angles.
Then a Gibbs sampling algorithm is implemented to generate rotation matrices from the resulting disribution of
the euler angles.
</p>


<h3>Value</h3>

<p>A simulated rotation matrix.
</p>


<h3>Author(s)</h3>

<p>Anamul Sajib.
</p>
<p>R implementation and documentation: Anamul Sajib &lt;sajibstat@du.ac.bd&gt;.
</p>


<h3>References</h3>

<p>Habeck M (2009). Generation of three-dimensional random rotations in fitting and matching problems. Computational Statistics, 24, 719&ndash;731.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>F &lt;- 10^(-1) *  matrix( c(85, 11, 41, 78, 39, 60, 43, 64, 48), ncol = 3 )  ## Arbitrary F matrix
X &lt;- habeck.rot(F)
det(X)
</code></pre>

<hr>
<h2 id='Haversine+20distance+20matrix'>
Harvesine distance matrix
</h2><span id='topic+haversine.dist'></span>

<h3>Description</h3>

<p>Haversine distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haversine.dist(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Haversine+2B20distance+2B20matrix_+3A_x">x</code></td>
<td>

<p>A a matrix of two columns. The first column is the latitude and the second the longitude.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the haversine distance between all observations.
</p>


<h3>Value</h3>

<p>A matrix with the haversine distances between all observations.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>https://en.wikipedia.org/wiki/Haversine_formula
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cosnn">cosnn</a>, <a href="#topic+dirknn">dirknn</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvmf(10, rnorm(3), 10)
x &lt;- euclid.inv(x)
haversine.dist(x)
</code></pre>

<hr>
<h2 id='Hypothesis+20test+20for+20IAG+20distribution+20over+20the+20ESAG+20distribution'>
Hypothesis test for IAG distribution over the ESAG distribution
</h2><span id='topic+iagesag'></span>

<h3>Description</h3>

<p>The null hypothesis is whether an IAG distribution fits the data well, where the altenrative is that ESAG distribution is more suitable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iagesag(x, B = 1, tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hypothesis+2B20test+2B20for+2B20IAG+2B20distribution+2B20over+2B20the+2B20ESAG+2B20distribution_+3A_x">x</code></td>
<td>

<p>A numeric matrix with three columns containing the data as unit vectors in Euclidean coordinates.
</p>
</td></tr>
<tr><td><code id="Hypothesis+2B20test+2B20for+2B20IAG+2B20distribution+2B20over+2B20the+2B20ESAG+2B20distribution_+3A_b">B</code></td>
<td>

<p>The number of bootstrap re-samples. By default is set to 999. If it is equal to 1, no bootstrap is performed and the
p-value is obtained throught the asymptotic distribution.
</p>
</td></tr>
<tr><td><code id="Hypothesis+2B20test+2B20for+2B20IAG+2B20distribution+2B20over+2B20the+2B20ESAG+2B20distribution_+3A_tol">tol</code></td>
<td>

<p>The tolerance to accept that the Newton-Raphson algorithm used in the IAG distribution has converged.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Essentially it is a test of rotational symmetry, whether the two <code class="reqn">\gamma</code> parameters are equal to zero.
This works for spherical data only.
</p>


<h3>Value</h3>

<p>This is an &quot;htest&quot;class object. Thus it returns a list including:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>

<p>The test statistic value.
</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>

<p>The degrees of freedom of the test. If bootstrap was employed this is &quot;NA&quot;.
</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>

<p>The p-value of the test.
</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>

<p>A character with the alternative hypothesis.
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>A character with the test used.
</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>

<p>A character vector with two elements.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Paine P.J., Preston S.P., Tsagris M. and Wood A.T.A. (2018). An Elliptically Symmetric Angular
Gaussian Distribution. Statistics and Computing, 28(3):689&ndash;697.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fishkent">fishkent</a>, <a href="#topic+iagesag">iagesag</a>, <a href="#topic+pc.test">pc.test</a>, <a href="#topic+esag.mle">esag.mle</a>, <a href="#topic+kent.mle">kent.mle</a>,
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvmf(100, rnorm(3), 15)
iagesag(x)
fishkent(x, B = 1)
</code></pre>

<hr>
<h2 id='Hypothesis+20test+20for+20SIPC+20distribution+20over+20the+20SESPC+20distribution'>
Hypothesis test for SIPC distribution over the SESPC distribution
</h2><span id='topic+pc.test'></span>

<h3>Description</h3>

<p>The null hypothesis is whether an SIPC distribution fits the data well, where the altenrative is that SESPC distribution is more suitable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pc.test(x, B = 1, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hypothesis+2B20test+2B20for+2B20SIPC+2B20distribution+2B20over+2B20the+2B20SESPC+2B20distribution_+3A_x">x</code></td>
<td>

<p>A numeric matrix with three columns containing the data as unit vectors in Euclidean coordinates.
</p>
</td></tr>
<tr><td><code id="Hypothesis+2B20test+2B20for+2B20SIPC+2B20distribution+2B20over+2B20the+2B20SESPC+2B20distribution_+3A_b">B</code></td>
<td>

<p>The number of bootstrap re-samples. By default is set to 999. If it is equal to 1, no bootstrap is performed and the
p-value is obtained throught the asymptotic distribution.
</p>
</td></tr>
<tr><td><code id="Hypothesis+2B20test+2B20for+2B20SIPC+2B20distribution+2B20over+2B20the+2B20SESPC+2B20distribution_+3A_tol">tol</code></td>
<td>

<p>The tolerance to accept that the Newton-Raphson algorithm used in the IAG distribution has converged.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Essentially it is a test of rotational symmetry, whether the two <code class="reqn">\theta</code> parameters are equal to zero. This works for spherical data only.
</p>


<h3>Value</h3>

<p>This is an &quot;htest&quot;class object. Thus it returns a list including:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>

<p>The test statistic value.
</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>

<p>The degrees of freedom of the test. If bootstrap was employed this is &quot;NA&quot;.
</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>

<p>The p-value of the test.
</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>

<p>A character with the alternative hypothesis.
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>A character with the test used.
</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>

<p>A character vector with two elements.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Tsagris M. and Alzeley O. (2023). Circular and spherical projected Cauchy distributions:
A Novel Framework for Circular and Directional Data Modeling.
https://arxiv.org/pdf/2302.02468.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iagesag">iagesag</a>, <a href="#topic+fishkent">fishkent</a>, <a href="#topic+sespc.mle">sespc.mle</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvmf(100, rnorm(3), 15)
iagesag(x)
pc.test(x)
</code></pre>

<hr>
<h2 id='Hypothesis+20test+20for+20von+20Mises-Fisher+20distribution+20over+20Kent+20distribution'>
Hypothesis test for von Mises-Fisher distribution over Kent distribution
</h2><span id='topic+fishkent'></span>

<h3>Description</h3>

<p>The null hypothesis is whether a von Mises-Fisher distribution fits the data well, where the altenrative is that Kent distribution is more suitable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fishkent(x, B = 999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hypothesis+2B20test+2B20for+2B20von+2B20Mises-Fisher+2B20distribution+2B20over+2B20Kent+2B20distribution_+3A_x">x</code></td>
<td>

<p>A numeric matrix containing the data as unit vectors in Euclidean coordinates.
</p>
</td></tr>
<tr><td><code id="Hypothesis+2B20test+2B20for+2B20von+2B20Mises-Fisher+2B20distribution+2B20over+2B20Kent+2B20distribution_+3A_b">B</code></td>
<td>

<p>The number of bootstrap re-samples. By default is set to 999. If it is equal to 1, no bootstrap is performed and the p-value is obtained throught the asymptotic distribution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Essentially it is a test of rotational symmetry, whether Kent's ovalness parameter (beta) is equal to zero. This works for spherical data only.
</p>


<h3>Value</h3>

<p>This is an &quot;htest&quot;class object. Thus it returns a list including:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>

<p>The test statistic value.
</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>

<p>The degrees of freedom of the test. If bootstrap was employed this is &quot;NA&quot;.
</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>

<p>The p-value of the test.
</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>

<p>A character with the alternative hypothesis.
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>A character with the test used.
</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>

<p>A character vector with two elements.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Rivest L. P. (1986). Modified Kent's statistics for testing goodness of fit for the Fisher distribution 
in small concentrated samples. Statistics &amp; Probability Letters, 4(1): 1&ndash;4.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iagesag">iagesag</a>, <a href="#topic+pc.test">pc.test</a>, <a href="#topic+vmf.mle">vmf.mle</a>, <a href="#topic+kent.mle">kent.mle</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvmf(100, rnorm(3), 15)
fishkent(x)
fishkent(x, B = 1)
iagesag(x)
</code></pre>

<hr>
<h2 id='Interactive+203D+20plot+20of+20spherical+20data'>
Interactive 3D plot of spherical data
</h2><span id='topic+sphereplot'></span>

<h3>Description</h3>

<p>Interactive 3D plot of spherical data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphereplot(dat, col = NULL, bgcol = "snow")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Interactive+2B203D+2B20plot+2B20of+2B20spherical+2B20data_+3A_dat">dat</code></td>
<td>

<p>A matrix with three columns, unit-vectors, spherical data.
</p>
</td></tr>
<tr><td><code id="Interactive+2B203D+2B20plot+2B20of+2B20spherical+2B20data_+3A_col">col</code></td>
<td>

<p>If you want the points to appear with different colours put numbers here, otherwise leave it NULL.
</p>
</td></tr>
<tr><td><code id="Interactive+2B203D+2B20plot+2B20of+2B20spherical+2B20data_+3A_bgcol">bgcol</code></td>
<td>

<p>The color of the surface of the sphere.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An interactive 3D plot of the spherical data will appear.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+lambert">lambert</a>, <a href="#topic+vmf.contour">vmf.contour</a>, <a href="#topic+euclid">euclid</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rvmf(100, rnorm(3), 5)
sphereplot(x)

</code></pre>

<hr>
<h2 id='Inverse+20of+20Lambert+27s+20equal+20area+20projection'>
Inverse of Lambert's equal area projection
</h2><span id='topic+lambert.inv'></span>

<h3>Description</h3>

<p>It takes some points from the cartesian coordinates and maps them onto the sphere. The inverse os the Lambert's equal area projection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambert.inv(z, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Inverse+2B20of+2B20Lambert+2B27s+2B20equal+2B20area+2B20projection_+3A_z">z</code></td>
<td>

<p>A two- column matrix containing the Lambert's equal rea projected data.
</p>
</td></tr>
<tr><td><code id="Inverse+2B20of+2B20Lambert+2B27s+2B20equal+2B20area+2B20projection_+3A_mu">mu</code></td>
<td>

<p>The mean direction of the data on the sphere.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data are first mapped on the sphere with mean direction equal to the north pole. Then, they are rotated to have the given mean direction. It is the inverse of the Lambert's equal are projection.
</p>


<h3>Value</h3>

<p>A matrix containing spherical data (unit vectors).
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Kent, John T. (1982). The Fisher-Bingham distribution on the sphere. 
Journal of the Royal Statistical Society. Series B (Methodological) 44(1):71&ndash;80.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lambert">lambert</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- rnorm(3)
m &lt;- m / sqrt( sum(m^2) )
x &lt;- rvmf(20, m, 19)
mu &lt;- vmf.mle(x)$mu
y &lt;- lambert( euclid.inv(x) )
lambert.inv(y, mu)
euclid.inv(x)
</code></pre>

<hr>
<h2 id='Inverse+20of+20the+20Euclidean+20transformation'>
Inverse of the Euclidean transformation
</h2><span id='topic+euclid.inv'></span>

<h3>Description</h3>

<p>It transforms the data from the Euclidan coordinates to latitude dn longitude.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euclid.inv(U)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Inverse+2B20of+2B20the+2B20Euclidean+2B20transformation_+3A_u">U</code></td>
<td>

<p>A matrix of unit vectors, or even one single unit vector in three dimensions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It takes the matrix of unit vectors and back transforms it to latitude and longitude.
</p>


<h3>Value</h3>

<p>A two column matrix:
</p>
<table>
<tr><td><code>u</code></td>
<td>
<p> The first column is the latitude and the second is the longitude, both expressed in degrees.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+euclid">euclid</a>, <a href="#topic+Arotation">Arotation</a>, <a href="#topic+lambert">lambert</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvmf(10, rnorm(3), 10)
euclid.inv(x)
euclid( euclid.inv(x) )
x
</code></pre>

<hr>
<h2 id='k-NN+20algorithm+20using+20the+20arc+20cosinus+20distance'>
k-NN algorithm using the arc cosinus distance
</h2><span id='topic+dirknn'></span>

<h3>Description</h3>

<p>It classifies new observations to some known groups via the k-NN algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dirknn(xnew, ina, x, k = 5, mesos = TRUE, parallel = FALSE, rann = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="k-NN+2B20algorithm+2B20using+2B20the+2B20arc+2B20cosinus+2B20distance_+3A_xnew">xnew</code></td>
<td>

<p>The new data whose membership is to be predicted, a numeric matrix with unit vectors.
</p>
</td></tr>
<tr><td><code id="k-NN+2B20algorithm+2B20using+2B20the+2B20arc+2B20cosinus+2B20distance_+3A_ina">ina</code></td>
<td>

<p>A variable indicating the groups of the data x.
</p>
</td></tr>
<tr><td><code id="k-NN+2B20algorithm+2B20using+2B20the+2B20arc+2B20cosinus+2B20distance_+3A_x">x</code></td>
<td>

<p>The data, a numeric matrix with unit vectors.
</p>
</td></tr>
<tr><td><code id="k-NN+2B20algorithm+2B20using+2B20the+2B20arc+2B20cosinus+2B20distance_+3A_k">k</code></td>
<td>

<p>The number of nearest neighbours, set to 5 by default. It can also be a vector with many values.
</p>
</td></tr>
<tr><td><code id="k-NN+2B20algorithm+2B20using+2B20the+2B20arc+2B20cosinus+2B20distance_+3A_mesos">mesos</code></td>
<td>

<p>A boolean variable used only in the case of the non standard algorithm (type=&quot;NS&quot;). Should the average of the distances be calculated (TRUE) or not (FALSE)? If it is FALSE, the harmonic mean is calculated.
</p>
</td></tr>
<tr><td><code id="k-NN+2B20algorithm+2B20using+2B20the+2B20arc+2B20cosinus+2B20distance_+3A_parallel">parallel</code></td>
<td>

<p>If you want the standard -NN algorithm to take place in parallel set this equal to TRUE.
</p>
</td></tr>
<tr><td><code id="k-NN+2B20algorithm+2B20using+2B20the+2B20arc+2B20cosinus+2B20distance_+3A_rann">rann</code></td>
<td>

<p>If you have large scale datasets and want a faster k-NN search, you can use kd-trees implemented in the R package &quot;RANN&quot;. In this case you must set this argument equal to TRUE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard algorithm is to keep the k nearest observations and see the groups of these observations. The new observation is allocated to the most frequent seen group. The non standard algorithm is to calculate the classical mean or the harmonic mean of the k nearest observations for each group. The new observation is allocated to the group with the smallest mean distance.
</p>


<h3>Value</h3>

<p>A vector including:
</p>
<table>
<tr><td><code>g</code></td>
<td>

<p>A matrix with the predicted group(s). It has as many columns as the values of k.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Tsagris M. and Alenazi A. (2019). Comparison of discriminant analysis methods on the sphere. Communications in Statistics: Case Studies, Data Analysis and Applications, 5(4), 467&ndash;491.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dirknn.tune">dirknn.tune</a>, <a href="#topic+vmfda.pred">vmfda.pred</a>, <a href="#topic+mixvmf.mle">mixvmf.mle</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k &lt;- runif(4, 4, 20)
prob &lt;- c(0.2, 0.4, 0.3, 0.1)
mu &lt;- matrix(rnorm(16), ncol = 4)
mu &lt;- mu / sqrt( rowSums(mu^2) )
da &lt;- rmixvmf(200, prob, mu, k)
nu &lt;- sample(1:200, 180)
x &lt;- da$x[nu, ]
ina &lt;- da$id[nu]
xx &lt;- da$x[-nu, ]
id &lt;- da$id[-nu]
a1 &lt;- dirknn(xx, ina, x, k = 5, mesos = TRUE)
a2 &lt;- dirknn(xx, ina, x, k = 5, mesos = FALSE)
b &lt;- vmfda.pred(xx, x, ina)
table(id, a1)
table(id, a2)
</code></pre>

<hr>
<h2 id='k-NN+20regression'>
k-NN regression with Euclidean or (hyper-)spherical response and or predictor variables
</h2><span id='topic+knn.reg'></span>

<h3>Description</h3>

<p>k-NN regression with Euclidean or (hyper-)spherical response and or predictor variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knn.reg(xnew, y, x, k = 5, res = "eucl", estim = "arithmetic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="k-NN+2B20regression_+3A_xnew">xnew</code></td>
<td>

<p>The new data, new predictor variables values. A matrix with either euclidean (univariate or multivariate) or (hyper-)spherical data. If you have a circular response, say u, transform it to a unit vector via (cos(u), sin(u)). If xnew = x, you will get the fitted values.
</p>
</td></tr>
<tr><td><code id="k-NN+2B20regression_+3A_y">y</code></td>
<td>

<p>The currently available data, the response variables values. A matrix with either euclidean (univariate or multivariate) or (hyper-)spherical data. If you have a circular response, say u, transform it to a unit vector via (cos(u), sin(u)).
</p>
</td></tr>
<tr><td><code id="k-NN+2B20regression_+3A_x">x</code></td>
<td>

<p>The currently available data, the predictor variables values. A matrix with either euclidean (univariate or multivariate) or (hyper-)spherical data. If you have a circular response, say u, transform it to a unit vector via (cos(u), sin(u)).
</p>
</td></tr>
<tr><td><code id="k-NN+2B20regression_+3A_k">k</code></td>
<td>

<p>The number of nearest neighbours, set to 5 by default. This can also be a vector with many values.
</p>
</td></tr>
<tr><td><code id="k-NN+2B20regression_+3A_res">res</code></td>
<td>

<p>The type of the response variable. If it is Euclidean, set this argument equal to &quot;res&quot;.  If it is a unit vector set it to res=&quot;spher&quot;.
</p>
</td></tr>
<tr><td><code id="k-NN+2B20regression_+3A_estim">estim</code></td>
<td>

<p>Once the k observations whith the smallest distance are discovered, what should the prediction be? The arithmetic average of the corresponding y values be used estim=&quot;arithmetic&quot; or their harmonic average estim=&quot;harmonic&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function covers a broad range of data, Euclidean and spherical, along with their combinations.
</p>


<h3>Value</h3>

<p>A list with as many elements as the number of values of k. Each element in the list contains a matrix (or a vector in the case of Euclidean data) with the predicted response values.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+knnreg.tune">knnreg.tune</a>, <a href="#topic+spher.reg">spher.reg</a>, <a href="#topic+spml.reg">spml.reg</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- iris[, 1]
x &lt;- as.matrix(iris[, 2:4])
x &lt;- x/ sqrt( rowSums(x^2) )  ## Euclidean response
a &lt;- knn.reg(x, y, x, k = 5, res = "eucl", estim = "arithmetic")

y &lt;- iris[, 2:4]
y &lt;- y / sqrt( rowSums(y^2) ) ## Spherical response
x &lt;- iris[, 1]
a &lt;- knn.reg(x, y, x, k = 5, res = "spher", estim = "arithmetic")
</code></pre>

<hr>
<h2 id='Lambert+27s+20equal+20area+20projection'>
Lambert's equal area projection
</h2><span id='topic+lambert'></span>

<h3>Description</h3>

<p>It calculates the Lambert's equal area projection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambert(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lambert+2B27s+2B20equal+2B20area+2B20projection_+3A_y">y</code></td>
<td>

<p>A two column matrix with the data. The first column is the altitude and the second is the longitude.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spherical data are first rotated so that their mean direction is the north pole and then are projectedt on the plane tagent to the sphere at the north pole.
</p>


<h3>Value</h3>

<p>A two-column matrix with the projected points.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Kent, John T. (1982). The Fisher-Bingham distribution on the sphere. Journal of the Royal Statistical Society. Series B (Methodological) 44(1):71-80.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+euclid">euclid</a>, <a href="#topic+lambert.inv">lambert.inv</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvmf(100, rnorm(3), 20)
x &lt;- euclid.inv(x)
a &lt;- lambert(x)
plot(a)
</code></pre>

<hr>
<h2 id='Logarithm+20of+20the+20Kent+20distribution+20normalizing+20constant'>
Logarithm of the Kent distribution normalizing constant
</h2><span id='topic+kent.logcon'></span>

<h3>Description</h3>

<p>Logarithm of the Kent distribution normalizing constant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kent.logcon(k, b, j = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Logarithm+2B20of+2B20the+2B20Kent+2B20distribution+2B20normalizing+2B20constant_+3A_k">k</code></td>
<td>

<p>The conencration parameter, <code class="reqn">\kappa</code>.
</p>
</td></tr>
<tr><td><code id="Logarithm+2B20of+2B20the+2B20Kent+2B20distribution+2B20normalizing+2B20constant_+3A_b">b</code></td>
<td>

<p>The ovalness parameter, <code class="reqn">\beta</code>.
</p>
</td></tr>
<tr><td><code id="Logarithm+2B20of+2B20the+2B20Kent+2B20distribution+2B20normalizing+2B20constant_+3A_j">j</code></td>
<td>

<p>The number of the terms in the sum to use. By default this is 100.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It calculates logarithm of the normalising constant of the Kent distribution.
</p>


<h3>Value</h3>

<p>The value of the logarithm of the normalising constant of the Kent distribution.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Kent John (1982). The Fisher-Bingham distribution on the sphere. 
Journal of the Royal Statistical Society, Series B, 44(1): 71&ndash;80.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fb.saddle">fb.saddle</a>, <a href="#topic+kent.mle">kent.mle</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kent.logcon(10, 2)
fb.saddle( c(0, 10, 0), c(0, -2, 2) )
</code></pre>

<hr>
<h2 id='Many+20simple+20circular+20or+20angular+20regressions'>
Many simple circular or angular regressions
</h2><span id='topic+spml.regs'></span>

<h3>Description</h3>

<p>Many regressions with one circular dependent variable and one Euclidean independent variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spml.regs(y, x, tol = 1e-07, logged = FALSE, maxiters = 100, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Many+2B20simple+2B20circular+2B20or+2B20angular+2B20regressions_+3A_y">y</code></td>
<td>

<p>The dependent variable, it can be a numerical vector with data expressed in radians or it can be a matrix with
two columns, the cosinus and the sinus of the circular data. The benefit of the matrix is that if the function
is to be called multiple times with the same response, there is no need to transform the vector every time into
a matrix.
</p>
</td></tr>
<tr><td><code id="Many+2B20simple+2B20circular+2B20or+2B20angular+2B20regressions_+3A_x">x</code></td>
<td>

<p>A matrix with independent variable.
</p>
</td></tr>
<tr><td><code id="Many+2B20simple+2B20circular+2B20or+2B20angular+2B20regressions_+3A_tol">tol</code></td>
<td>

<p>The tolerance value to terminatate the Newton-Raphson algorithm.
</p>
</td></tr>
<tr><td><code id="Many+2B20simple+2B20circular+2B20or+2B20angular+2B20regressions_+3A_logged">logged</code></td>
<td>

<p>Do you want the logarithm of the p-value be returned? TRUE or FALSE.
</p>
</td></tr>
<tr><td><code id="Many+2B20simple+2B20circular+2B20or+2B20angular+2B20regressions_+3A_maxiters">maxiters</code></td>
<td>

<p>The maximum number of iterations to implement.
</p>
</td></tr>
<tr><td><code id="Many+2B20simple+2B20circular+2B20or+2B20angular+2B20regressions_+3A_parallel">parallel</code></td>
<td>

<p>Do you want the calculations to take plac ein parallel? The default value if FALSE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Newton-Raphson algorithm is fitted in these regression as described in Presnell et al. (1998). For each colum of x a circual
regression model is fitted and the hypothesis testing of no association between y and this variable is performed.
</p>


<h3>Value</h3>

<p>A matrix with two columns, the test statistics and their associated (log) p-values.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Presnell Brett, Morrison Scott P. and Littell Ramon C. (1998). Projected multivariate linear models for
directional data. Journal of the American Statistical Association, 93(443): 1068&ndash;1077.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spml.reg">spml.reg</a>, <a href="#topic+spml.mle">spml.mle</a>, <a href="#topic+iag.mle">iag.mle</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(200)
z &lt;- cbind(3 + 2 * x, 1 -3 * x)
y &lt;- cbind( rnorm(100,z[, 1], 1), rnorm(100, z[, 2], 1) )
y &lt;- y / sqrt( rowSums(y^2) )
x &lt;- matrix( rnorm(100 * 50), ncol = 50 )
a &lt;- Directional::spml.regs(y, x)
x &lt;- NULL
</code></pre>

<hr>
<h2 id='Maps+20of+20the+20world+20and+20the+20continents'>
maps of the world and the continents
</h2><span id='topic+asia'></span><span id='topic+africa'></span><span id='topic+europe'></span><span id='topic+north.america'></span><span id='topic+oceania'></span><span id='topic+south.america'></span><span id='topic+worldmap'></span>

<h3>Description</h3>

<p>It produces maps of the world and the continents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asia(title = "Asia", coords = NULL)
africa(title = "Africa", coords = NULL)
europe(title = "Europe", coords = NULL)
north.america(title = "North America", coords = NULL)
oceania(title = "Oceania", coords = NULL)
south.america(title = "South America", coords = NULL)
worldmap(title = "World map", coords = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Maps+2B20of+2B20the+2B20world+2B20and+2B20the+2B20continents_+3A_title">title</code></td>
<td>

<p>A character vector with the title of the map.
</p>
</td></tr>
<tr><td><code id="Maps+2B20of+2B20the+2B20world+2B20and+2B20the+2B20continents_+3A_coords">coords</code></td>
<td>

<p>If you want specific points to appear on the plot give the coordinates as a matrix, where the first column
contains the longitude and the second column contains the latitude, in degrees.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Maps of the world or the continents are produced. This are experimental functions and plot the countries with specific
colouring at the moment. More functionalities will be added in the future.
</p>


<h3>Value</h3>

<p>A map of the selected continent or the whole world.
</p>


<h3>Author(s)</h3>

<p>Christos Adam.
</p>
<p>R implementation and documentation: Christos Adam <a href="mailto:pada4m4@gmail.com">pada4m4@gmail.com</a> and Michail Tsagris.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sphereplot">sphereplot</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- euclid.inv( rvmf(10, rnorm(3), 5) )
</code></pre>

<hr>
<h2 id='Mixtures+20of+20Von+20Mises-Fisher+20distributions'>
Mixtures of Von Mises-Fisher distributions
</h2><span id='topic+mixvmf.mle'></span>

<h3>Description</h3>

<p>It performs model based clustering for circualr, spherical and hyperspherical data assuming von Mises-Fisher distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixvmf.mle(x, g, n.start = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mixtures+2B20of+2B20Von+2B20Mises-Fisher+2B20distributions_+3A_x">x</code></td>
<td>

<p>A matrix with the data expressed as unit vectors.
</p>
</td></tr>
<tr><td><code id="Mixtures+2B20of+2B20Von+2B20Mises-Fisher+2B20distributions_+3A_g">g</code></td>
<td>

<p>The number of groups to fit. It must be greater than or equal to 2.
</p>
</td></tr>
<tr><td><code id="Mixtures+2B20of+2B20Von+2B20Mises-Fisher+2B20distributions_+3A_n.start">n.start</code></td>
<td>

<p>The number of random starts to try. See also R's built-in function <code><a href="stats.html#topic+kmeans">kmeans</a></code> for more information about this.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initial step of the algorithm is not based on a spherical k-means, but on s imple k-means. The results are comparable to the package movMF.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>param</code></td>
<td>

<p>A matrix with the mean direction, the concetrations parameter and mixing probability of each group.
</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>The value of the maximised log-likelihood.
</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>

<p>The predicted group of each observation.
</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>

<p>The number of iteration required by the EM algorithm.
</p>
</td></tr>
<tr><td><code>runtime</code></td>
<td>

<p>The run time of the algorithm. A numeric vector. The first element is the user time, the second element is the system time and the third element is the elapsed time.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Kurt Hornik and  Bettina Grun (2014). movMF: An R Package for Fitting Mixtures of von Mises-Fisher Distributions
http://cran.r-project.org/web/packages/movMF/vignettes/movMF.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmixvmf">rmixvmf</a>, <a href="#topic+bic.mixvmf">bic.mixvmf</a>, <a href="#topic+mixvmf.contour">mixvmf.contour</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k &lt;- runif(4, 4, 6)
prob &lt;- c(0.2, 0.4, 0.3, 0.1)
mu &lt;- matrix(rnorm(16), ncol = 4)
mu &lt;- mu / sqrt( rowSums(mu^2) )
x &lt;- rmixvmf(200, prob, mu, k)$x
mixvmf.mle(x, 3)
mixvmf.mle(x, 4)
mixvmf.mle(x, 5)
</code></pre>

<hr>
<h2 id='MLE+20of+20+28hyper-+29spherical+20rotationally+20symmetric+20distributions'>
MLE of (hyper-)spherical rotationally symmetric distributions
</h2><span id='topic+vmf.mle'></span><span id='topic+multivmf.mle'></span><span id='topic+iag.mle'></span><span id='topic+spcauchy.mle'></span><span id='topic+spcauchy.mle2'></span><span id='topic+sipc.mle'></span><span id='topic+pkbd.mle'></span><span id='topic+acg.mle'></span>

<h3>Description</h3>

<p>MLE of (hyper-)spherical rotationally symmetric distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vmf.mle(x, fast = FALSE, tol = 1e-07)
multivmf.mle(x, ina, tol = 1e-07, ell = FALSE)
iag.mle(x, tol = 1e-07)
spcauchy.mle(x, tol = 1e-06)
spcauchy.mle2(x, tol = 1e-06)
sipc.mle(x, tol = 1e-6)
pkbd.mle(x, tol = 1e-6)
acg.mle(x, tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MLE+2B20of+2B20+2B28hyper-+2B29spherical+2B20rotationally+2B20symmetric+2B20distributions_+3A_x">x</code></td>
<td>

<p>A matrix with directional data, i.e. unit vectors.
</p>
</td></tr>
<tr><td><code id="MLE+2B20of+2B20+2B28hyper-+2B29spherical+2B20rotationally+2B20symmetric+2B20distributions_+3A_fast">fast</code></td>
<td>

<p>IF you want a faster version, but with fewer information returned, set this equal to TRUE.
</p>
</td></tr>
<tr><td><code id="MLE+2B20of+2B20+2B28hyper-+2B29spherical+2B20rotationally+2B20symmetric+2B20distributions_+3A_ina">ina</code></td>
<td>

<p>A numerical vector with discrete numbers starting from 1, i.e. 1, 2, 3, 4,... or a factor variable. Each number denotes a sample or group.
If you supply a continuous valued vector the function will obviously provide wrong results.
</p>
</td></tr>
<tr><td><code id="MLE+2B20of+2B20+2B28hyper-+2B29spherical+2B20rotationally+2B20symmetric+2B20distributions_+3A_ell">ell</code></td>
<td>

<p>This is for the multivmf.mle only. Do you want the log-likelihood returned? The default value is TRUE.
</p>
</td></tr>
<tr><td><code id="MLE+2B20of+2B20+2B28hyper-+2B29spherical+2B20rotationally+2B20symmetric+2B20distributions_+3A_tol">tol</code></td>
<td>

<p>The tolerance value at which to terminate the iterations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vmf.mle() estimates the mean direction and concentration of a fitted von Mises-Fisher distribution.
</p>
<p>The von Mises-Fisher distribution for groups of data is also implemented.
</p>
<p>The acg.mle() fits the angular central Gaussian distribution. There is a constraint on the estimated covariance matrix; its trace is equal to the number of variables. An iterative algorithm takes place and convergence is guaranteed.
</p>
<p>The iag.mle() implements MLE of the spherical projected normal distribution, for spherical data only.
</p>
<p>The spcauchy.mle() is faster than the spcacuhy.mle() because it employs the Newton-Raphson algortihm.
</p>
<p>The spcauchy.mle2() estimates the parameters of the spherical Cauchy distribution, for any dimension.
Despite the name sounds confusing, it is implemented for arbitrary dimensions, not only the sphere.
The function employs a combination of the fixed points iteration algorithm and the Brent algorithm.
</p>
<p>The pkbd.mle() estimates the parameters of the Poisson kernel based distribution (PKBD), for any dimension.
</p>
<p>The sipc.mle() implements MLE of the spherical independent projected Cauchy distribution, for spherical data only.
</p>


<h3>Value</h3>

<p>For the von Mises-Fisher a list including:
</p>
<table>
<tr><td><code>loglik</code></td>
<td>

<p>The maximum log-likelihood value.
</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>

<p>The mean direction.
</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>

<p>The concentration parameter.
</p>
</td></tr>
</table>
<p>For the multi von Mises-Fisher a list including:
</p>
<table>
<tr><td><code>loglik</code></td>
<td>

<p>A vector with the maximum log-likelihood values if ell is set to TRUE. Otherwise NULL is returned.
</p>
</td></tr>
<tr><td><code>mi</code></td>
<td>

<p>A matrix with the group mean directions.
</p>
</td></tr>
<tr><td><code>ki</code></td>
<td>

<p>A vector with the group concentration parameters.
</p>
</td></tr>
</table>
<p>For the angular central Gaussian a list including:
</p>
<table>
<tr><td><code>iter</code></td>
<td>

<p>The number if iterations required by the algorithm to converge to the solution.
</p>
</td></tr>
<tr><td><code>cova</code></td>
<td>

<p>The estimated covariance matrix.
</p>
</td></tr>
</table>
<p>For the spherical projected normal a list including:
</p>
<table>
<tr><td><code>iters</code></td>
<td>

<p>The number of iteration required by the Newton-Raphson.
</p>
</td></tr>
<tr><td><code>mesi</code></td>
<td>

<p>A matrix with two rows. The first row is the mean direction and the second is the mean vector.
The first comes from the second by normalising to have unit length.
</p>
</td></tr>
<tr><td><code>param</code></td>
<td>

<p>A vector with the elements, the norm of mean vector, the log-likelihood and the log-likelihood of
the spherical uniform distribution. The third value helps in case you want to do a log-likelihood
ratio test for uniformity.
</p>
</td></tr>
</table>
<p>For the spherical Cauchy and the PKBD a list including:
</p>
<table>
<tr><td><code>mesos</code></td>
<td>

<p>The mean in <code class="reqn">R^{d+1}</code>. See Tsagris and Alenazy (2023) for a re-parametrization that
applies in the spherical Cauchy also.
</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>

<p>The mean direction.
</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>

<p>The norm of the mean in <code class="reqn">R^{d+1}</code>. See Tsagris and Alenazy (2023) for a re-parametrization that
applies in the spherical Cauchy also.
</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>

<p>The concetration parameter, this takes values in [0, 1).
</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>The log-likelihood value.
</p>
</td></tr>
</table>
<p>For the SIPC a list including:
</p>
<table>
<tr><td><code>mu</code></td>
<td>

<p>The mean direction.
</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>The log-likelihood value.
</p>
</td></tr>
</table>
<p>For the angular central Gaussian a list including:
</p>
<table>
<tr><td><code>iter</code></td>
<td>

<p>The number of iterations performed.
</p>
</td></tr>
<tr><td><code>cova</code></td>
<td>

<p>The covariance matrix.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Mardia K. V. and Jupp P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
</p>
<p>Sra S. (2012). A short note on parameter approximation for von Mises-Fisher distributions:
and a fast implementation of <code class="reqn">I_s(x)</code>. Computational Statistics, 27(1): 177&ndash;190.
</p>
<p>Tyler D. E. (1987). Statistical analysis for the angular central Gaussian
distribution on the sphere. Biometrika 74(3): 579&ndash;589.
</p>
<p>Paine P.J., Preston S.P., Tsagris M. and Wood A.T.A. (2018). An Elliptically Symmetric
Angular Gaussian Distribution. Statistics and Computing, 28: 689&ndash;697.
</p>
<p>Tsagris M. and Alzeley O. (2023). Circular and spherical projected Cauchy distributions:
A Novel Framework for Circular and Directional Data Modeling.
https://arxiv.org/pdf/2302.02468.pdf
</p>
<p>Kato S. and McCullagh P. (2020). Some properties of a Cauchy family on the sphere derived from the
Mobius transformations. Bernoulli, 26(4): 3224&ndash;3248.
https://arxiv.org/pdf/1510.07679.pdf
</p>
<p>Golzy M. and Markatou M. (2020). Poisson kernel-based clustering on the sphere:
convergence properties, identifiability, and a method of sampling.
Journal of Computational and Graphical Statistics, 29(4): 758&ndash;770.
</p>
<p>Sablica L., Hornik K. and Leydold J. (2023). Efficient sampling from the PKBD distribution.
Electronic Journal of Statistics, 17(2): 2180&ndash;2209.
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+racg">racg</a>, <a href="#topic+rvmf">rvmf</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- c(0, 0, 0, 0)
s &lt;- cov(iris[, 1:4])
x &lt;- racg(100, s)
mod &lt;- acg.mle(x)
mod
cov2cor(mod$cova)  ## estimated covariance matrix turned into a correlation matrix
cov2cor(s)  ## true covariance matrix turned into a correlation matrix
vmf.mle(x)
x &lt;- rbind( rvmf(100,rnorm(4), 10), rvmf(100,rnorm(4), 20) )
a &lt;- multivmf.mle(x, rep(1:2, each = 100) )
</code></pre>

<hr>
<h2 id='MLE+20of+20some+20circular+20distributions'>
MLE of some circular distributions
</h2><span id='topic+spml.mle'></span><span id='topic+wrapcauchy.mle'></span><span id='topic+circexp.mle'></span><span id='topic+circbeta.mle'></span><span id='topic+cardio.mle'></span><span id='topic+ggvm.mle'></span><span id='topic+cipc.mle'></span><span id='topic+gcpc.mle'></span><span id='topic+mmvm.mle'></span>

<h3>Description</h3>

<p>MLE of some circular distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spml.mle(x, rads = FALSE, tol = 1e-07)
wrapcauchy.mle(x, rads = FALSE, tol = 1e-07)
circexp.mle(x, rads = FALSE, tol = 1e-06)
circbeta.mle(x, rads = FALSE)
cardio.mle(x, rads = FALSE)
ggvm.mle(phi, rads = FALSE)
cipc.mle(x, rads = FALSE, tol = 1e-6)
gcpc.mle(x, rads = FALSE)
mmvm.mle(x, N, rads = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MLE+2B20of+2B20some+2B20circular+2B20distributions_+3A_x">x</code></td>
<td>

<p>A numerical vector with the circular data. They can either be expressed in radians or in degrees.
</p>
</td></tr>
<tr><td><code id="MLE+2B20of+2B20some+2B20circular+2B20distributions_+3A_phi">phi</code></td>
<td>

<p>A numerical vector with the circular data. They can either be expressed in radians or in degrees.
</p>
</td></tr>
<tr><td><code id="MLE+2B20of+2B20some+2B20circular+2B20distributions_+3A_n">N</code></td>
<td>

<p>The number of modes to consider in the multi-modal von Mises distribution.
</p>
</td></tr>
<tr><td><code id="MLE+2B20of+2B20some+2B20circular+2B20distributions_+3A_rads">rads</code></td>
<td>

<p>If the data are in radians set this to TRUE.
</p>
</td></tr>
<tr><td><code id="MLE+2B20of+2B20some+2B20circular+2B20distributions_+3A_tol">tol</code></td>
<td>

<p>The tolerance level to stop the iterative process of finding the MLEs.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters of the bivariate angular Gaussian (spml.mle), wrapped Cauchy, circular exponential,
cardioid, circular beta, geometrically generalised von Mises, CIPC (reparametrised version of the
wrapped Cauchy), GCPC (generalisation of the CIPC) and multi-modal von Mises distributions are
estimated. For the Wrapped Cauchy, the iterative procedure described by Kent and Tyler (1988) is
used. The Newton-Raphson algortihm for the angular Gaussian is described in the regression setting
in Presnell et al. (1998). The circular exponential is also known as wrapped exponential distribution.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>iters</code></td>
<td>

<p>The iterations required until convergence.
</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>The value of the maximised log-likelihood.
</p>
</td></tr>
<tr><td><code>param</code></td>
<td>

<p>A vector consisting of the estimates of the two parameters, the mean direction for both distributions
and the concentration parameter <code class="reqn">kappa</code> and the <code class="reqn">rho</code> for the von Mises (and the multi-modal von Mises) and wrapped Cauchy respectively. For the circular beta this contains the mean angle and the <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> parameters. For the cardioid distribution this contains the <code class="reqn">\mu</code> and <code class="reqn">rho</code> parameters. For the generalised von Mises this is a vector consisting of the <code class="reqn">\zeta</code>, <code class="reqn">\kappa</code>, <code class="reqn">\mu</code> and <code class="reqn">\alpha</code> parameters of the generalised von Mises distribution as described in Equation (2.7) of Dietrich and Richter (2017).
</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>

<p>The norm of the mean vector of the angular Gaussian, the CIPC and the GCPC distributions.
</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>

<p>The mean vector of the angular Gaussian, the CIPC and the GCPC distributions.
</p>
</td></tr>
<tr><td><code>mumu</code></td>
<td>

<p>In the case of &quot;angular Gaussian distribution this is the mean angle in radians.
</p>
</td></tr>
<tr><td><code>circmu</code></td>
<td>

<p>In the case of the CIPC and the GCPC this is the mean angle in radians.
</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>

<p>For the GCPC distribution this is the eigenvalue of the covariance matrix, or the covariance determinant.
</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>

<p>The lambda parameter of the circular exponential distribution.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Mardia K. V. and Jupp P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
</p>
<p>Sra S. (2012). A short note on parameter approximation for von Mises-Fisher distributions:
and a fast implementation of <code class="reqn">I_s(x)</code>. Computational Statistics, 27(1): 177&ndash;190.
</p>
<p>Presnell Brett, Morrison Scott P. and Littell Ramon C. (1998). Projected multivariate linear models for directional data.
Journal of the American Statistical Association, 93(443): 1068&ndash;1077.
</p>
<p>Kent J. and Tyler D. (1988). Maximum likelihood estimation for the wrapped Cauchy distribution.
Journal of Applied Statistics, 15(2): 247&ndash;254.
</p>
<p>Dietrich T. and Richter W. D. (2017). Classes of geometrically generalized von Mises distributions.
Sankhya B, 79(1): 21&ndash;59.
</p>
<p>https://en.wikipedia.org/wiki/Wrapped_exponential_distribution
</p>
<p>Jammalamadaka S. R. and Kozubowski T. J. (2003). A new family of circular models:
The wrapped Laplace distributions.
Advances and Applications in Statistics, 3(1), 77-103.
</p>
<p>Tsagris M. and Alzeley O. (2023). Circular and spherical projected Cauchy distributions:
A Novel Framework for Circular and Directional Data Modeling.
https://arxiv.org/pdf/2302.02468.pdf
</p>
<p>Barnett M. J. and Kingston R. L. (2024). A note on the Hendrickson-Lattman phase probability
distribution and its equivalence to the generalized von Mises distribution.
Journal of Applied Crystallography, 57(2).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+circ.summary">circ.summary</a>, <a href="#topic+purka.mle">purka.mle</a>, <a href="#topic+rvonmises">rvonmises</a>, <a href="#topic+vmf.mle">vmf.mle</a>, <a href="#topic+rvmf">rvmf</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvonmises(1000, 3, 9)
spml.mle(x, rads = TRUE)
wrapcauchy.mle(x, rads = TRUE)
circexp.mle(x, rads = TRUE)
ggvm.mle(x, rads = TRUE)
</code></pre>

<hr>
<h2 id='MLE+20of+20some+20circular+20distributions+20with+20multiple+20samples'>
MLE of some circular distributions with multiple samples
</h2><span id='topic+multivm.mle'></span><span id='topic+multispml.mle'></span>

<h3>Description</h3>

<p>MLE of some circular distributions with multiple samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multivm.mle(x, ina, tol = 1e-07, ell = FALSE)
multispml.mle(x, ina, tol = 1e-07, ell = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MLE+2B20of+2B20some+2B20circular+2B20distributions+2B20with+2B20multiple+2B20samples_+3A_x">x</code></td>
<td>

<p>A numerical vector with the circular data. They must be expressed in radians. For the &quot;spml.mle&quot; this can also
be a matrix with two columns, the cosinus and the sinus of the circular data.
</p>
</td></tr>
<tr><td><code id="MLE+2B20of+2B20some+2B20circular+2B20distributions+2B20with+2B20multiple+2B20samples_+3A_ina">ina</code></td>
<td>

<p>A numerical vector with discrete numbers starting from 1, i.e. 1, 2, 3, 4,... or a factor variable. 
Each number denotes a sample or group. If you supply a continuous valued vector the function will 
obviously provide wrong results. 
</p>
</td></tr>
<tr><td><code id="MLE+2B20of+2B20some+2B20circular+2B20distributions+2B20with+2B20multiple+2B20samples_+3A_tol">tol</code></td>
<td>

<p>The tolerance level to stop the iterative process of finding the MLEs.
</p>
</td></tr>
<tr><td><code id="MLE+2B20of+2B20some+2B20circular+2B20distributions+2B20with+2B20multiple+2B20samples_+3A_ell">ell</code></td>
<td>

<p>Do you want the log-likelihood returned? The default value is FALSE. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters of the von Mises and of the bivariate angular Gaussian distributions 
are estimated for multiple samples. 
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>iters</code></td>
<td>

<p>The iterations required until convergence. This is returned in the wrapped Cauchy distribution only.
</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>A vector with the value of the maximised log-likelihood for each sample.
</p>
</td></tr>
<tr><td><code>mi</code></td>
<td>

<p>For the von Mises, this is a vector with the means of each sample. For the angular Gaussian (spml), a matrix with the 
mean vector of each sample
</p>
</td></tr>
<tr><td><code>ki</code></td>
<td>

<p>A vector with the concentration parameter of the von Mises distribution at each sample.
</p>
</td></tr>
<tr><td><code>gi</code></td>
<td>

<p>A vector with the norm of the mean vector of the angular Gaussian distribution at each sample.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Mardia K. V. and Jupp P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
</p>
<p>Sra S. (2012). A short note on parameter approximation for von Mises-Fisher distributions: 
and a fast implementation of <code class="reqn">I_s(x)</code>. Computational Statistics, 27(1): 177&ndash;190.
</p>
<p>Presnell Brett, Morrison Scott P. and Littell Ramon C. (1998). Projected multivariate linear models for directional data.
Journal of the American Statistical Association, 93(443): 1068&ndash;1077.
</p>
<p>Kent J. and Tyler D. (1988). Maximum likelihood estimation for the wrapped Cauchy distribution.
Journal of Applied Statistics, 15(2): 247&ndash;254.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+colspml.mle">colspml.mle</a>, <a href="#topic+purka.mle">purka.mle</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- rcauchy(100, 3, 1)
x &lt;- y 
ina &lt;- rep(1:2, 50)
multivm.mle(x, ina)
multispml.mle(x, ina)
</code></pre>

<hr>
<h2 id='MLE+20of+20the+20ESAG+20distribution'>
MLE of the ESAG distribution
</h2><span id='topic+esag.mle'></span>

<h3>Description</h3>

<p>MLE of the ESAG distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>esag.mle(y, full = FALSE, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MLE+2B20of+2B20the+2B20ESAG+2B20distribution_+3A_y">y</code></td>
<td>

<p>A matrix with the data expressed in Euclidean coordinates, i.e. unit vectors.
</p>
</td></tr>
<tr><td><code id="MLE+2B20of+2B20the+2B20ESAG+2B20distribution_+3A_full">full</code></td>
<td>

<p>If you want some extra information, the inverse of the covariance matrix, the <code class="reqn">rho</code> parameter (smallest eigenvalue of the covariance matrix) and the angle of rotation <code class="reqn">\psi</code>, set this equal to TRUE. Otherwise leave it FALSE.
</p>
</td></tr>
<tr><td><code id="MLE+2B20of+2B20the+2B20ESAG+2B20distribution_+3A_tol">tol</code></td>
<td>

<p>A tolerance value to stop performing successive optimizations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MLE of the MLE of the ESAG distributiontribution, on the sphere, is implemented. ESAG stands for Elliptically Symmetric Angular Gaussian and it was suugested by Paine et al. (2018). Unlike the projected normal distribution this is rotationally symmetric and is a competitor of the spherical Kent distribution (which is also elliptically symmetric).
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>mu</code></td>
<td>

<p>The mean vector in <code class="reqn">R^3</code>.
</p>
</td></tr>
<tr><td><code>gam</code></td>
<td>

<p>The two <code class="reqn">\gamma</code> parameters.
</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>The log-likelihood value.
</p>
</td></tr>
<tr><td><code>vinv</code></td>
<td>

<p>The inverse of the covariance matrix. It is returned if the argument &quot;full&quot; is TRUE.
</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>

<p>The <code class="reqn">rho</code> parameter (smallest eigenvalue of the covariance matrix). It is returned if the argument &quot;full&quot; is TRUE.
</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>

<p>The angle of rotation <code class="reqn">\psi</code> set this equal to TRUE. It is returned if the argument &quot;full&quot; is TRUE.
</p>
</td></tr>
<tr><td><code>iag.loglik</code></td>
<td>

<p>The log-likelihood value of the isotropic angular Gaussian distribution. That is, the projected
normal distribution which is rotationally symmetric.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Paine P.J., Preston S.P., Tsagris M. and Wood A.T.A. (2018). An Elliptically Symmetric Angular
Gaussian Distribution. Statistics and Computing, 28(3):689&ndash;697.
</p>
<p>Mardia, K. V. and Jupp, P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+desag">desag</a>, <a href="#topic+resag">resag</a>, <a href="#topic+iag.mle">iag.mle</a>, <a href="#topic+kent.mle">kent.mle</a>, <a href="#topic+acg.mle">acg.mle</a>, <a href="#topic+circ.summary">circ.summary</a>, <a href="#topic+sphereplot">sphereplot</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- colMeans( as.matrix( iris[,1:3] ) )
y &lt;- resag(1000, m, c(1,0.5) )
esag.mle(y)
</code></pre>

<hr>
<h2 id='MLE+20of+20the+20Kent+20distribution'>
MLe of the Kent distribution
</h2><span id='topic+kent.mle'></span>

<h3>Description</h3>

<p>It estimates the concentration and the ovalness parameter of some directional data assuming the Kent distribution. The mean direction and major and minor axes are also estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kent.mle(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MLE+2B20of+2B20the+2B20Kent+2B20distribution_+3A_x">x</code></td>
<td>

<p>A matrix containing spherical data in Euclidean coordinates.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Kent distribution is fitted to some data and its parameters are estimated.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>runtime</code></td>
<td>

<p>The run time of the procedure.
</p>
</td></tr>
<tr><td><code>G</code></td>
<td>

<p>A 3 x 3 matrix whose first column is the mean direction. The second and third columns are the major and minor axes respectively.
</p>
</td></tr>
<tr><td><code>param</code></td>
<td>

<p>A vector with the concentration <code class="reqn">\kappa</code> and ovalness <code class="reqn">\beta</code> parameters and the angle <code class="reqn">\psi</code> used to rotate <b>H</b>
and hence estimate <b>G</b> as in Kent (1982).
</p>
</td></tr>
<tr><td><code>logcon</code></td>
<td>

<p>The logarithm of the normalising constant, using the third type approximation (Kume and Wood, 2005).
</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>The value of the log-likelihood.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Kent John (1982). The Fisher-Bingham distribution on the sphere. 
Journal of the Royal Statistical Society, Series B, 44(1): 71&ndash;80.
</p>
<p>Kume Alfred and Wood Andrew T.A. (2005). Saddlepoint approximations for the Bingham and Fisher-Bingham normalizing constants.
Biometrika, 92(2):465&ndash;476
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kent.mle">kent.mle</a>, <a href="#topic+fb.saddle">fb.saddle</a>, <a href="#topic+vmf.mle">vmf.mle</a>, <a href="#topic+wood.mle">wood.mle</a>, <a href="#topic+sphereplot">sphereplot</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvmf(200, rnorm(3), 15)
kent.mle(x)
vmf.mle(x)
A &lt;- diag( c(-5, 0, 5) )
x &lt;- rfb(200, 15, rnorm(3), A)
kent.mle(x)
vmf.mle(x)
</code></pre>

<hr>
<h2 id='MLE+20of+20the+20Matrix+20Fisher+20distribution+20on+20SO+283+29'>
MLE of the Matrix Fisher distribution on SO(3)
</h2><span id='topic+matrixfisher.mle'></span>

<h3>Description</h3>

<p>It returns the maximum likelihood estimate of the Matrix Fisher parameter F(3x3).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixfisher.mle(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MLE+2B20of+2B20the+2B20Matrix+2B20Fisher+2B20distribution+2B20on+2B20SO+2B283+2B29_+3A_x">X</code></td>
<td>

<p>An array containing rotation matrices in SO(3).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The components of <code class="reqn"> svd( \bar{X} ) </code>.
</p>


<h3>Author(s)</h3>

<p>Anamul Sajib and Chris Fallaize.
</p>
<p>R implementation and documentation: Anamul Sajib &lt;sajibstat@du.ac.bd&gt; and Chris Fallaize.
</p>


<h3>References</h3>

<p>Prentice M. J. (1986). Orientation statistics without parametric assumptions.
Journal of the Royal Statistical Society. Series B: Methodological 48(2): 214&ndash;222.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmatrixfisher">rmatrixfisher</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>F &lt;- 10^(-1) * matrix( c(85, 11, 41, 78, 39, 60, 43, 64, 48), ncol = 3 )   ### An arbitrary F matrix
X &lt;- rmatrixfisher(5000, F)
matrixfisher.mle(X)
svd(F)
</code></pre>

<hr>
<h2 id='MLE+20of+20the+20Purkayashta+20distribution'>MLE of the Purkayashta distribution
</h2><span id='topic+purka.mle'></span>

<h3>Description</h3>

<p>MLE of the Purkayashta distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>purka.mle(x, tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MLE+2B20of+2B20the+2B20Purkayashta+2B20distribution_+3A_x">x</code></td>
<td>

<p>A numerical vector with data expressed in radians or a matrix with spherical data.
</p>
</td></tr>
<tr><td><code id="MLE+2B20of+2B20the+2B20Purkayashta+2B20distribution_+3A_tol">tol</code></td>
<td>

<p>The tolerance value to terminate the Brent algorithm.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MLE of the Purkayastha distribution is performed.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>theta</code></td>
<td>

<p>The median direction.
</p>
</td></tr>
<tr><td><code>circtheta</code></td>
<td>

<p>In case of circular data the circular mean is also returned.
</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>

<p>The concentration parameter.
</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>The log-likelihood.
</p>
</td></tr>
<tr><td><code>alpha.sd</code></td>
<td>

<p>The standard error of the concentration parameter.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Purkayastha S. (1991).  A Rotationally Symmetric Directional Distribution: Obtained through Maximum
Likelihood Characterization. The Indian Journal of Statistics, Series A, 53(1): 70&ndash;83.
</p>
<p>Cabrera J. and Watson G. S. (1990). On a spherical median related distribution.
Communications in Statistics-Theory and Methods, 19(6): 1973&ndash;1986.
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+circ.cor1">circ.cor1</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- cbind( rnorm(100,1,1), rnorm(100, 2, 1) )
x &lt;- x / sqrt(rowSums(x^2))
purka.mle(x)
</code></pre>

<hr>
<h2 id='MLE+20of+20the+20SESPC+20distribution'>
MLE of the SESPC distribution
</h2><span id='topic+sespc.mle'></span>

<h3>Description</h3>

<p>MLE of the SESPC distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sespc.mle(y, full = FALSE, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MLE+2B20of+2B20the+2B20SESPC+2B20distribution_+3A_y">y</code></td>
<td>

<p>A matrix with the data expressed in Euclidean coordinates, i.e. unit vectors.
</p>
</td></tr>
<tr><td><code id="MLE+2B20of+2B20the+2B20SESPC+2B20distribution_+3A_full">full</code></td>
<td>

<p>If you want some extra information, the inverse of the covariance matrix, set this equal to TRUE. Otherwise leave it FALSE.
</p>
</td></tr>
<tr><td><code id="MLE+2B20of+2B20the+2B20SESPC+2B20distribution_+3A_tol">tol</code></td>
<td>

<p>A tolerance value to stop performing successive optimizations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MLE of the SESPC distribution is implemented. SESPC stands for Spherical Elliptically Symmetric Projected Cauchy
and it was suugested by Tsagris and Alzeley (2023). Unlike the spherical independent projected Cauchy distribution 
this is rotationally symmetric and is a competitor of the spherical ESAG and Kent distributions (which are also ellitpically symmetric).
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>mu</code></td>
<td>

<p>The mean vector in <code class="reqn">R^3</code>.
</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>

<p>The two <code class="reqn">\theta</code> parameters.
</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>The log-likelihood value.
</p>
</td></tr>
<tr><td><code>vinv</code></td>
<td>

<p>The inverse of the covariance matrix. It is returned if the argument &quot;full&quot; is TRUE.
</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>

<p>The <code class="reqn">\lambda_2</code> parameter (smallest eigenvalue of the covariance matrix). It is returned if the argument &quot;full&quot; is TRUE.
</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>

<p>The angle of rotation <code class="reqn">\psi</code> set this equal to TRUE. It is returned if the argument &quot;full&quot; is TRUE.
</p>
</td></tr>
<tr><td><code>sipc.loglik</code></td>
<td>

<p>The log-likelihood value of the isotropic prohected Cuchy distribution, which is rotationally symmetric.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Tsagris M. and Alzeley O. (2023). Circular and spherical projected Cauchy distributions: 
A Novel Framework for Circular and Directional Data Modeling.
https://arxiv.org/pdf/2302.02468.pdf
</p>
<p>Mardia, K. V. and Jupp, P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dsespc">dsespc</a>, <a href="#topic+rsespc">rsespc</a>, <a href="#topic+sipc.mle">sipc.mle</a>, <a href="#topic+esag.mle">esag.mle</a>, <a href="#topic+spher.sespc.contour">spher.sespc.contour</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- colMeans( as.matrix( iris[,1:3] ) )
y &lt;- rsespc(1000, m, c(1,0.5) )
sespc.mle(y)
</code></pre>

<hr>
<h2 id='MLE+20of+20the+20Wood+20bimodal+20distribution+20on+20the+20sphere'>
MLE of the Wood bimodal distribution on the sphere
</h2><span id='topic+wood.mle'></span>

<h3>Description</h3>

<p>It estimates the parameters of the Wood bimodal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wood.mle(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MLE+2B20of+2B20the+2B20Wood+2B20bimodal+2B20distribution+2B20on+2B20the+2B20sphere_+3A_y">y</code></td>
<td>

<p>A matrix containing two columns. The first one is the latitude and the second is the longitude, both expressed in degrees.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Wood distribution is fitted to some data and its parameters are estimated. It is a bimodal distribution which contains 5 parameters, just like the Kent distribution.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>info</code></td>
<td>

<p>A 5 x 3 matrix containing the 5 parameters, <code class="reqn">\gamma</code>, <code class="reqn">\delta</code>, <code class="reqn">\alpha</code>, <code class="reqn">\beta</code> and <code class="reqn">\kappa</code> along with their corresponding 95% confidence intervals all expressed in degrees.
</p>
</td></tr>
<tr><td><code>modes</code></td>
<td>

<p>The two axis of the modes of the distribution expressed in degrees.
</p>
</td></tr>
<tr><td><code>unitvectors</code></td>
<td>

<p>A 3 x 3 matrix with the 3 unit vectors associated with the <code class="reqn">\gamma</code> and <code class="reqn">\delta</code> parameters.
</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>The value of the log-likelihood.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Wood A.T.A. (1982). A bimodal distribution on the sphere.
Journal of the Royal Statistical Society, Series C, 31(1): 52&ndash;58.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kent.mle">kent.mle</a>, <a href="#topic+esag.mle">esag.mle</a>, <a href="#topic+vmf.mle">vmf.mle</a>, <a href="#topic+sphereplot">sphereplot</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvmf(100, rnorm(3), 15)
x &lt;- euclid.inv(x)
wood.mle(x)
</code></pre>

<hr>
<h2 id='Naive+20Bayes+20classifiers+20for+20circular+20data'>
Naive Bayes classifiers for directional data
</h2><span id='topic+vm.nb'></span><span id='topic+spml.nb'></span>

<h3>Description</h3>

<p>Naive Bayes classifiers for directional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vm.nb(xnew = NULL, x, ina, tol = 1e-07)
spml.nb(xnew = NULL, x, ina, tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Naive+2B20Bayes+2B20classifiers+2B20for+2B20circular+2B20data_+3A_xnew">xnew</code></td>
<td>

<p>A numerical matrix with new predictor variables whose group is to be predicted. Each column refers to an angular variable.
</p>
</td></tr>
<tr><td><code id="Naive+2B20Bayes+2B20classifiers+2B20for+2B20circular+2B20data_+3A_x">x</code></td>
<td>

<p>A numerical matrix with observed predictor variables. Each column refers to an angular variable.
</p>
</td></tr>
<tr><td><code id="Naive+2B20Bayes+2B20classifiers+2B20for+2B20circular+2B20data_+3A_ina">ina</code></td>
<td>

<p>A numerical vector with strictly positive numbers, i.e. 1,2,3 indicating the groups of the dataset.
Alternatively this can be a factor variable.
</p>
</td></tr>
<tr><td><code id="Naive+2B20Bayes+2B20classifiers+2B20for+2B20circular+2B20data_+3A_tol">tol</code></td>
<td>

<p>The tolerance value to terminate the Newton-Raphson algorithm.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each column is supposed to contain angular measurements. Thus, for each column a von Mises distribution or an circular angular Gaussian distribution is fitted. The product of the densities is the joint multivariate
distribution.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>mu</code></td>
<td>

<p>A matrix with the mean vectors expressed in radians.
</p>
</td></tr>
<tr><td><code>mu1</code></td>
<td>

<p>A matrix with the first set of mean vectors.
</p>
</td></tr>
<tr><td><code>mu2</code></td>
<td>

<p>A matrix with the second set of mean vectors.
</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>

<p>A matrix with the kappa parameters for the vonMises distribution or with the norm of the
mean vectors for the circular angular Gaussian distribution.
</p>
</td></tr>
<tr><td><code>ni</code></td>
<td>

<p>The sample size of each group in the dataset.
</p>
</td></tr>
<tr><td><code>est</code></td>
<td>

<p>The estimated group of the xnew observations. It returns a numerical value back regardless of the target variable being numerical as well or factor. Hence, it is suggested that you do \&quot;as.numeric(ina)\&quot; in order to see what is the predicted class of the new data.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+vmnb.pred">vmnb.pred</a> </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix( runif( 100, 0, 1 ), ncol = 2 )
ina &lt;- rbinom(50, 1, 0.5) + 1
a &lt;- vm.nb(x, x, ina)
</code></pre>

<hr>
<h2 id='Normalised+20spatial+20median+20for+20directional+20data'>
Normalised spatial median for directional data
</h2><span id='topic+nsmedian'></span>

<h3>Description</h3>

<p>Normalised spatial median for directional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsmedian(x, tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Normalised+2B20spatial+2B20median+2B20for+2B20directional+2B20data_+3A_x">x</code></td>
<td>

<p>A matrix with Euclidean data, continuous variables.
</p>
</td></tr>
<tr><td><code id="Normalised+2B20spatial+2B20median+2B20for+2B20directional+2B20data_+3A_tol">tol</code></td>
<td>

<p>A tolerance level to terminate the process.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spatial median, using a fixed point iterative algorithm, for Euclidean data is calculated. It is a robust location estimate. Then it is normalised to become a unit vector. Generally speaking this might be a better alternative than then <code><a href="#topic+mediandir">mediandir</a></code>.
</p>


<h3>Value</h3>

<p>A vector with the spatial median.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris &lt;mtsagris@uoc.gr&gt;.
</p>


<h3>References</h3>

<p>Ducharme G. R. and Milasevic P. (1987). Spatial median and directional data. Biometrika, 74(1), 212-215.
</p>
<p>Jyrki Mottonen, Klaus Nordhausen and Hannu Oja (2010). Asymptotic theory of the spatial median.
In Nonparametrics and Robustness in Modern Statistical Inference and Time Series Analysis:
A Festschrift in honor of Professor Jana Jureckova.
</p>
<p>T. Karkkaminen and S. Ayramo (2005). On computation of spatial median for robust data mining.
Evolutionary and Deterministic Methods for Design, Optimization and Control with Applications to
Industrial and Societal Problems, EUROGEN 2005, R. Schilling, W.Haase, J. Periaux, H. Baier, G. Bugeda (Eds)
FLM, Munich. http://users.jyu.fi/~samiayr/pdf/ayramo_eurogen05.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mediandir">mediandir</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- rnorm(3)
m &lt;- m / sqrt( sum(m^2) )
x &lt;- rvmf(100, m, 10)
nsmedian(x)
mediandir(x)
</code></pre>

<hr>
<h2 id='Permutation+20based+202-sample+20mean+20test+20for+20+28hyper-+29spherical+20data'>
Permutation based 2-sample mean test for (hyper-)spherical data
</h2><span id='topic+hcf.perm'></span><span id='topic+lr.perm'></span><span id='topic+hclr.perm'></span><span id='topic+embed.perm'></span><span id='topic+het.perm'></span>

<h3>Description</h3>

<p>Permutation based 2-sample mean test for (hyper-)spherical data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hcf.perm(x1, x2, B = 999)
lr.perm(x1, x2, B = 999)
hclr.perm(x1, x2, B = 999)
embed.perm(x1, x2, B = 999)
het.perm(x1, x2, B = 999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Permutation+2B20based+2B202-sample+2B20mean+2B20test+2B20for+2B20+2B28hyper-+2B29spherical+2B20data_+3A_x1">x1</code></td>
<td>

<p>A matrix with the data in Euclidean coordinates, i.e. unit vectors.
</p>
</td></tr>
<tr><td><code id="Permutation+2B20based+2B202-sample+2B20mean+2B20test+2B20for+2B20+2B28hyper-+2B29spherical+2B20data_+3A_x2">x2</code></td>
<td>

<p>A matrix with the data in Euclidean coordinates, i.e. unit vectors.
</p>
</td></tr>
<tr><td><code id="Permutation+2B20based+2B202-sample+2B20mean+2B20test+2B20for+2B20+2B28hyper-+2B29spherical+2B20data_+3A_b">B</code></td>
<td>

<p>The number of permutations to perform.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The high concentration (hcf.perm), log-likelihood ratio (lr.perm), high concentration
log-likelihood ratio (hclr.perm), embedding approach (embed.perm) or the non equal
concentration parameters approach (het.perm) is used.
</p>


<h3>Value</h3>

<p>This is an &quot;htest&quot;class object. Thus it returns a list including:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>

<p>The test statistic value.
</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>

<p>The degrees of freedom of the test. Since these are permutation based tests this is &quot;NA&quot;.
</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>

<p>The p-value of the test.
</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>

<p>A character with the alternative hypothesis.
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>A character with the test used.
</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>

<p>A character vector with two elements.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Mardia K. V. and Jupp P. E. (2000). Directional statistics.
Chicester: John Wiley &amp; Sons.
</p>
<p>Rumcheva P. and Presnell B. (2017). An improved test of equality of mean directions for the
Langevin-von Mises-Fisher distribution. Australian &amp; New Zealand Journal of Statistics, 59(1), 119&ndash;135.
</p>
<p>Tsagris M. and Alenazi A. (2024). An investigation of hypothesis testing procedures for circular
and spherical mean vectors. Communications in Statistics-Simulation and Computation, 53(3): 1387&ndash;1408.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hcf.boot">hcf.boot</a>, <a href="#topic+hcf.aov">hcf.aov</a>, <a href="#topic+spherconc.test">spherconc.test</a>, <a href="#topic+conc.test">conc.test</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvmf(60, rnorm(3), 15)
ina &lt;- rep(1:2, each = 30)
x1 &lt;- x[ina == 1, ]
x2 &lt;- x[ina == 2, ]
hcf.perm(x1, x2)
lr.perm(x1, x2)
het.boot(x1, x2)
</code></pre>

<hr>
<h2 id='Permutation+20based+202-sample+20mean+20test+20for+20circular+20data'>
Permutation based 2-sample mean test for circular data
</h2><span id='topic+hcfcirc.perm'></span><span id='topic+hetcirc.perm'></span><span id='topic+lrcirc.perm'></span><span id='topic+hclrcirc.perm'></span><span id='topic+embedcirc.perm'></span>

<h3>Description</h3>

<p>Permutation based 2-sample mean test for circular data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hcfcirc.perm(u1, u2, rads = TRUE, B = 999)
hetcirc.perm(u1, u2, rads = TRUE, B = 999)
lrcirc.perm(u1, u2, rads = TRUE, B = 999)
hclrcirc.perm(u1, u2, rads = TRUE, B = 999)
embedcirc.perm(u1, u2, rads = TRUE, B = 999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Permutation+2B20based+2B202-sample+2B20mean+2B20test+2B20for+2B20circular+2B20data_+3A_u1">u1</code></td>
<td>

<p>A numeric vector containing the data of the first sample.
</p>
</td></tr>
<tr><td><code id="Permutation+2B20based+2B202-sample+2B20mean+2B20test+2B20for+2B20circular+2B20data_+3A_u2">u2</code></td>
<td>

<p>A numeric vector containing the data of the first sample.
</p>
</td></tr>
<tr><td><code id="Permutation+2B20based+2B202-sample+2B20mean+2B20test+2B20for+2B20circular+2B20data_+3A_rads">rads</code></td>
<td>

<p>If the data are in radians, this should be TRUE and FALSE otherwise.
</p>
</td></tr>
<tr><td><code id="Permutation+2B20based+2B202-sample+2B20mean+2B20test+2B20for+2B20circular+2B20data_+3A_b">B</code></td>
<td>

<p>The number of permutations to perform.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The high concentration (hcfcirc.perm), log-likelihood ratio (lrcirc.perm),
high concentration log-likelihood ratio (hclrcirc.perm), embedding approach (embedcirc.perm)
or the non equal concentration parameters approach (hetcirc.perm) is used.
</p>


<h3>Value</h3>

<p>This is an &quot;htest&quot;class object. Thus it returns a list including:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>

<p>The test statistic value.
</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>

<p>The degrees of freedom of the test. Since these are permutation based tests this is &quot;NA&quot;.
</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>

<p>The p-value of the test.
</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>

<p>A character with the alternative hypothesis.
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>A character with the test used.
</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>

<p>A character vector with two elements.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Mardia K. V. and Jupp P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
</p>
<p>Rumcheva P. and Presnell B. (2017). An improved test of equality of mean directions for
the Langevin-von Mises-Fisher distribution. Australian &amp; New Zealand Journal of Statistics, 59(1): 119&ndash;135.
</p>
<p>Tsagris M. and Alenazi A. (2024). An investigation of hypothesis testing procedures for circular
and spherical mean vectors. Communications in Statistics-Simulation and Computation, 53(3): 1387&ndash;1408.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hcf.circaov">hcf.circaov</a>, <a href="#topic+het.aov">het.aov</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u1 &lt;- rvonmises(20, 2.4, 5)
u2 &lt;- rvonmises(20, 2.4, 10)
hcfcirc.perm(u1, u2)
lrcirc.perm(u1, u2)
</code></pre>

<hr>
<h2 id='Prediction+20in+20discriminant+20analysis+20based+20on+20ESAG+20distribution'>
Prediction of a new observation using discriminant analysis based on ESAG distribution
</h2><span id='topic+esagda.pred'></span>

<h3>Description</h3>

<p>Prediction of a new observation using discriminant analysis based on ESAG distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>esagda.pred(ynew, y, ina)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Prediction+2B20in+2B20discriminant+2B20analysis+2B20based+2B20on+2B20ESAG+2B20distribution_+3A_ynew">ynew</code></td>
<td>

<p>The new observation(s) (unit vector(s)) whose group is to be predicted.
</p>
</td></tr>
<tr><td><code id="Prediction+2B20in+2B20discriminant+2B20analysis+2B20based+2B20on+2B20ESAG+2B20distribution_+3A_y">y</code></td>
<td>

<p>A data matrix with unit vectors, i.e. spherical directional data.
</p>
</td></tr>
<tr><td><code id="Prediction+2B20in+2B20discriminant+2B20analysis+2B20based+2B20on+2B20ESAG+2B20distribution_+3A_ina">ina</code></td>
<td>

<p>A vector indicating the groups of the data y.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prediction of the class of a new spherical vector assuming ESAG distribution.
</p>


<h3>Value</h3>

<p>A vector with the predicted group of each new observation.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Tsagris M. and Alenazi A. (2019). Comparison of discriminant analysis methods on the sphere. 
Communications in Statistics: Case Studies, Data Analysis and Applications, 5(4): 467&ndash;491.
</p>
<p>Paine P.J., Preston S.P. and Tsagris M. and Wood A.T.A. (2018). An Elliptically Symmetric Angular 
Gaussian Distribution. Statistics and Computing, 28(3): 689&ndash;697.
</p>
<p>Mardia K. V. and Jupp P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+esag.da">esag.da</a>, <a href="#topic+vmfda.pred">vmfda.pred</a>, <a href="#topic+dirknn">dirknn</a>, <a href="#topic+knn.reg">knn.reg</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- rnorm(3)
m2 &lt;- rnorm(3) + 0.5
y &lt;- rbind( rvmf(100, m1, 3), rvmf(80, m2, 5) )
ina &lt;- c( rep(1,100), rep(2, 80) )
ynew &lt;- rbind(rvmf(10, m1, 10), rvmf(10, m2, 5))
id &lt;- rep(1:2, each = 10)
g &lt;- esagda.pred(ynew, y, ina)
table(id, g)
</code></pre>

<hr>
<h2 id='Prediction+20in+20discriminant+20analysis+20based+20on+20Purkayastha+20distribution'>
Prediction of a new observation using discriminant analysis based on Purkayastha distribution
</h2><span id='topic+purkada.pred'></span>

<h3>Description</h3>

<p>Prediction of a new observation using discriminant analysis based on Purkayastha distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>purkada.pred(ynew, y, ina)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Prediction+2B20in+2B20discriminant+2B20analysis+2B20based+2B20on+2B20Purkayastha+2B20distribution_+3A_ynew">ynew</code></td>
<td>

<p>The new observation(s) whose group is to be predicted.
A numerical vector with data expressed in radians, or a matrix with two columns (cos and sin) for circular data.
Or a matrix with 3 columns (unit vectors) for spherical data.
</p>
</td></tr>
<tr><td><code id="Prediction+2B20in+2B20discriminant+2B20analysis+2B20based+2B20on+2B20Purkayastha+2B20distribution_+3A_y">y</code></td>
<td>

<p>A numerical vector with data expressed in radians, or a matrix with two columns (cos and sin) for circular data.
Or a matrix with 3 columns (unit vectors) for spherical data.
</p>
</td></tr>
<tr><td><code id="Prediction+2B20in+2B20discriminant+2B20analysis+2B20based+2B20on+2B20Purkayastha+2B20distribution_+3A_ina">ina</code></td>
<td>

<p>A vector indicating the groups of the data y.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prediction of the class of a new spherical vector assuming ESAG distribution.
</p>


<h3>Value</h3>

<p>A vector with the predicted group of each new observation.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Purkayastha S. (1991). A Rotationally Symmetric Directional Distribution: Obtained through Maximum Likelihood Characterization. 
The Indian Journal of Statistics, Series A, 53(1): 70&ndash;83
</p>
<p>Cabrera J. and Watson G. S. (1990). On a spherical median related distribution. 
Communications in Statistics-Theory and Methods, 19(6): 1973&ndash;1986.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+esag.da">esag.da</a>, <a href="#topic+vmfda.pred">vmfda.pred</a>, <a href="#topic+dirknn">dirknn</a>, <a href="#topic+knn.reg">knn.reg</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- rnorm(3)
m2 &lt;- rnorm(3) + 0.5
y &lt;- rbind( rvmf(100, m1, 3), rvmf(80, m2, 5) )
ina &lt;- c( rep(1,100), rep(2, 80) )
ynew &lt;- rbind(rvmf(10, m1, 10), rvmf(10, m2, 5))
id &lt;- rep(1:2, each = 10)
g &lt;- purkada.pred(ynew, y, ina)
table(id, g)
</code></pre>

<hr>
<h2 id='Prediction+20in+20discriminant+20analysis+20based+20on+20von+20Mises-Fisher+20distribution'>
Prediction of a new observation using discriminant analysis based on von Mises-Fisher distribution
</h2><span id='topic+vmfda.pred'></span>

<h3>Description</h3>

<p>Prediction of the class of a new observation using discriminant analysis based on von Mises-Fisher distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vmfda.pred(xnew, x, ina)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Prediction+2B20in+2B20discriminant+2B20analysis+2B20based+2B20on+2B20von+2B20Mises-Fisher+2B20distribution_+3A_xnew">xnew</code></td>
<td>

<p>The new observation(s) (unit vector(s)) whose group is to be predicted.
</p>
</td></tr>
<tr><td><code id="Prediction+2B20in+2B20discriminant+2B20analysis+2B20based+2B20on+2B20von+2B20Mises-Fisher+2B20distribution_+3A_x">x</code></td>
<td>

<p>A data matrix with unit vectors, i.e. directional data.
</p>
</td></tr>
<tr><td><code id="Prediction+2B20in+2B20discriminant+2B20analysis+2B20based+2B20on+2B20von+2B20Mises-Fisher+2B20distribution_+3A_ina">ina</code></td>
<td>

<p>A vector indicating the groups of the data x.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Discriminant analysis assuming von Mises-Fisher distributions.
</p>


<h3>Value</h3>

<p>A vector with the predicted group of each new observation.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Tsagris M. and Alenazi A. (2019). Comparison of discriminant analysis methods on the sphere. 
Communications in Statistics: Case Studies, Data Analysis and Applications, 5(4), 467&ndash;491.
</p>
<p>Morris J. E. and Laycock P. J. (1974). Discriminant analysis of directional data. Biometrika, 61(2): 335&ndash;341.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vmf.da">vmf.da</a>, <a href="#topic+mixvmf.mle">mixvmf.mle</a>, <a href="#topic+dirknn">dirknn</a>, <a href="#topic+knn.reg">knn.reg</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- rnorm(5)
m2 &lt;- rnorm(5)
x &lt;- rbind( rvmf(100, m1, 5), rvmf(80, m2, 10) )
ina &lt;- c( rep(1,100), rep(2, 80) )
y &lt;- rbind(rvmf(10, m1, 10), rvmf(10, m2, 5))
id &lt;- rep(1:2, each = 10)
g &lt;- vmfda.pred(y, x, ina)
table(id, g)
</code></pre>

<hr>
<h2 id='Prediction+20with+20some+20naive+20Bayes+20classifiers+20for+20circular+20data'>
Prediction with some naive Bayes classifiers for circular data
</h2><span id='topic+vmnb.pred'></span><span id='topic+spmlnb.pred'></span>

<h3>Description</h3>

<p>Prediction with some naive Bayes classifiers for circular data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vmnb.pred(xnew, mu, kappa, ni)
spmlnb.pred(xnew, mu1, mu2, ni)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Prediction+2B20with+2B20some+2B20naive+2B20Bayes+2B20classifiers+2B20for+2B20circular+2B20data_+3A_xnew">xnew</code></td>
<td>

<p>A numerical matrix with new predictor variables whose group is to be predicted.
Each column refers to an angular variable.
</p>
</td></tr>
<tr><td><code id="Prediction+2B20with+2B20some+2B20naive+2B20Bayes+2B20classifiers+2B20for+2B20circular+2B20data_+3A_mu">mu</code></td>
<td>

<p>A matrix with the mean vectors expressed in radians.
</p>
</td></tr>
<tr><td><code id="Prediction+2B20with+2B20some+2B20naive+2B20Bayes+2B20classifiers+2B20for+2B20circular+2B20data_+3A_mu1">mu1</code></td>
<td>

<p>A matrix with the first set of mean vectors.
</p>
</td></tr>
<tr><td><code id="Prediction+2B20with+2B20some+2B20naive+2B20Bayes+2B20classifiers+2B20for+2B20circular+2B20data_+3A_mu2">mu2</code></td>
<td>

<p>A matrix with the second set of mean vectors.
</p>
</td></tr>
<tr><td><code id="Prediction+2B20with+2B20some+2B20naive+2B20Bayes+2B20classifiers+2B20for+2B20circular+2B20data_+3A_kappa">kappa</code></td>
<td>

<p>A matrix with the kappa parameters for the vonMises distribution or with the norm of the
mean vectors for the circular angular Gaussian distribution.
</p>
</td></tr>
<tr><td><code id="Prediction+2B20with+2B20some+2B20naive+2B20Bayes+2B20classifiers+2B20for+2B20circular+2B20data_+3A_ni">ni</code></td>
<td>

<p>The sample size of each group in the dataset.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each column is supposed to contain angular measurements. Thus, for each column a von Mises distribution or an circular angular Gaussian distribution is fitted. The product of the densities is the joint multivariate distribution.
</p>


<h3>Value</h3>

<p>A numerical vector with 1, 2, ... denoting the predicted group.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+vm.nb">vm.nb</a> </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix( runif( 100, 0, 1 ), ncol = 2 )
ina &lt;- rbinom(50, 1, 0.5) + 1
a &lt;- vm.nb(x, x, ina)
a2 &lt;- vmnb.pred(x, a$mu, a$kappa, a$ni)
</code></pre>

<hr>
<h2 id='Projections+20based+20test+20of+20uniformity'>
Projections based test of uniformity
</h2><span id='topic+ptest'></span>

<h3>Description</h3>

<p>It checkes whether the data are uniformly distributed on the circle or the (hyper-)sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptest(x, B = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Projections+2B20based+2B20test+2B20of+2B20uniformity_+3A_x">x</code></td>
<td>

<p>A matrix containing the data, unit vectors.
</p>
</td></tr>
<tr><td><code id="Projections+2B20based+2B20test+2B20of+2B20uniformity_+3A_b">B</code></td>
<td>

<p>The number of random uniform projections to use.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details see Cuesta-Albertos, Cuevas and Fraiman (2009).
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>pvalues</code></td>
<td>

<p>The p-values of the Kolmogorov-Smirnov tests.
</p>
</td></tr>
<tr><td><code>pvalue</code></td>
<td>

<p>The p-value of the test based on the Benjamini and Heller (2008) procedure.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Cuesta-Albertos J. A., Cuevas A. and Fraiman, R. (2009).
On projection-based tests for directional and compositional data.
Statistics and Computing, 19: 367&ndash;380.
</p>
<p>Benjamini Y. and Heller R. (2008). Screening for partial conjunction hypotheses.
Biometrics, 64(4): 1215&ndash;1222.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rayleigh">rayleigh</a>, <a href="#topic+kuiper">kuiper</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvmf(100, rnorm(5), 1)  ## Fisher distribution with low concentration
ptest(x)
</code></pre>

<hr>
<h2 id='Random+20sample+20of+20matrices+20in+20SO+28p+29'>
Random sample of matrices in SO(p)
</h2><span id='topic+rsop'></span>

<h3>Description</h3>

<p>Random sample of matrices in SO(p).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsop(n, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Random+2B20sample+2B20of+2B20matrices+2B20in+2B20SO+2B28p+2B29_+3A_n">n</code></td>
<td>

<p>The sample size, the number of matrices you want to generate.
</p>
</td></tr>
<tr><td><code id="Random+2B20sample+2B20of+2B20matrices+2B20in+2B20SO+2B28p+2B29_+3A_p">p</code></td>
<td>

<p>The dimensionality of the matrices.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The idea is very simple. Start with a unit vector pointing at the north pole (1,0,...,0). Then generate random numbers from a standard normal and scale them so that they have a unit length. To put it differently, a sample of n values from the uniform distribution on the sphere is generated. Then calculate the rotation matrix required to go from the north pole to each of a generated vector.
</p>


<h3>Value</h3>

<p>If n = 1 one matrix is returned. If n is greater than 1, an array with n matrices inside.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Amaral G.J.A., Dryden I.L. and Wood A.T.A. (2007).
Pivotal Bootstrap Methods for k-Sample Problems in Directional Statistics and Shape Analysis. 
Journal of the American Statistical Association, 102(478): 695&ndash;707.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rotation">rotation</a>, <a href="#topic+Arotation">Arotation</a>, <a href="#topic+rot.matrix">rot.matrix</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- rsop(1, 3)
x2 &lt;- rsop(10, 3)
x3 &lt;- rsop(100, 10)
</code></pre>

<hr>
<h2 id='Rayleigh+27s+20test+20of+20uniformity'>
Rayleigh's test of uniformity
</h2><span id='topic+rayleigh'></span>

<h3>Description</h3>

<p>It checkes whether the data are uniformly distributed on the circle or the (hyper-)sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rayleigh(x, modif = TRUE, B = 999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rayleigh+2B27s+2B20test+2B20of+2B20uniformity_+3A_x">x</code></td>
<td>

<p>A matrix containing the data, unit vectors.
</p>
</td></tr>
<tr><td><code id="Rayleigh+2B27s+2B20test+2B20of+2B20uniformity_+3A_modif">modif</code></td>
<td>

<p>If modif is TRUE, the modification as suggested by Jupp (2001) is used.
</p>
</td></tr>
<tr><td><code id="Rayleigh+2B27s+2B20test+2B20of+2B20uniformity_+3A_b">B</code></td>
<td>

<p>If B is greater than 1, bootstap calibation os performed. If it is equal to 1, classical theory is used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Rayleigh test of uniformity is not the best, when there are two antipodal mean directions. In this case it will fail. It is good to test whether there is one mean direction or not. To put it differently, it tests whether the concentration parameter of the Fisher distribution is zero or not.
</p>


<h3>Value</h3>

<p>This is an &quot;htest&quot;class object. Thus it returns a list including:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>

<p>The test statistic value.
</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>

<p>The degrees of freedom of the test. If bootstrap was employed this is &quot;NA&quot;.
</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>

<p>The p-value of the test.
</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>

<p>A character with the alternative hypothesis.
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>A character with the test used.
</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>

<p>A character vector with two elements.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Mardia, K. V. and Jupp, P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
</p>
<p>Jupp, P. E. (2001). Modifications of the rayleigh and bingham tests for uniformity of directions. Journal of Multivariate Analysis, 77(2): 1-20.
</p>
<p>Rayleigh, L. (1919). On the problem of random vibrations, and of random flights in one, two, or three dimensions.
The London, Edinburgh, and Dublin Philosophical Magazine and Journal of Science, 37(220): 321&ndash;347.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ptest">ptest</a>, <a href="#topic+kuiper">kuiper</a>, <a href="#topic+iagesag">iagesag</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvmf(100, rnorm(5), 1)  ## Fisher distribution with low concentration
rayleigh(x)
</code></pre>

<hr>
<h2 id='Read+20a+20file+20as+20a+20Filebacked+20Big+20Matrix'>
Read a file as a Filebacked Big Matrix
</h2><span id='topic+read.fbm'></span>

<h3>Description</h3>

<p>Read a file as a Filebacked Big Matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fbm(file, select)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Read+2B20a+2B20file+2B20as+2B20a+2B20Filebacked+2B20Big+2B20Matrix_+3A_file">file</code></td>
<td>

<p>The File to read.
</p>
</td></tr>
<tr><td><code id="Read+2B20a+2B20file+2B20as+2B20a+2B20Filebacked+2B20Big+2B20Matrix_+3A_select">select</code></td>
<td>

<p>Indices of columns to read (sorted).
The length of select will be the number of columns of the resulting FBM.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions read a file as a Filebacked Big Matrix object. For more information see the &quot;bigstatsr&quot; package.
</p>


<h3>Value</h3>

<p>A Filebacked Big Matrix object.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris &lt;mtsagris@uoc.gr&gt;.
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+vmf.mle">vmf.mle</a>, <a href="#topic+kent.mle">kent.mle</a> </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix( runif(50 * 20, 0, 2*pi), ncol = 20 )
</code></pre>

<hr>
<h2 id='Rotation+20axis+20and+20angle+20of+20rotation+20given+20a+20rotation+20matrix'>
Rotation axis and angle of rotation given a rotation matrix
</h2><span id='topic+Arotation'></span>

<h3>Description</h3>

<p>Given a 3 x 3 rotation matrix, the angle and the axis of rotation are calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Arotation(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rotation+2B20axis+2B20and+2B20angle+2B20of+2B20rotation+2B20given+2B20a+2B20rotation+2B20matrix_+3A_a">A</code></td>
<td>

<p>A 3 x 3 rotation matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the user does not supply a rotation matrix a message will appear.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>angle</code></td>
<td>

<p>The angle of rotation expressed in degrees.
</p>
</td></tr>
<tr><td><code>axis</code></td>
<td>

<p>The axis of rotation. A vector of two components, latitude and longitude, expressed in degrees.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Course webpage of Howard E. Haber.
http://scipp.ucsc.edu/~haber/ph216/rotation_12.pdf
</p>
<p>Ted Chang (1986). Spherical Regression. Annals of Statistics, 14(3): 907&ndash;924.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rot.matrix">rot.matrix</a>, <a href="#topic+rotation">rotation</a>, <a href="#topic+rsop">rsop</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ksi &lt;- c(25.31, 24.29)
theta &lt;- 2.38
A &lt;- rot.matrix(ksi, theta, rads = FALSE)
A
Arotation(A)
</code></pre>

<hr>
<h2 id='Rotation+20matrix+20from+20a+20rotation+20axis+20and+20angle+20of+20rotation'>
Rotation matrix from a rotation axis and angle of rotation
</h2><span id='topic+rot.matrix'></span>

<h3>Description</h3>

<p>It calculates a rotation matrix from a rotation axis and angle of rotation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rot.matrix(ksi, theta, rads = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rotation+2B20matrix+2B20from+2B20a+2B20rotation+2B20axis+2B20and+2B20angle+2B20of+2B20rotation_+3A_ksi">ksi</code></td>
<td>

<p>The rotation axis, a vector with two elements, the first is the
latitude and the second is the longitude.
</p>
</td></tr>
<tr><td><code id="Rotation+2B20matrix+2B20from+2B20a+2B20rotation+2B20axis+2B20and+2B20angle+2B20of+2B20rotation_+3A_theta">theta</code></td>
<td>

<p>The angle of rotation.
</p>
</td></tr>
<tr><td><code id="Rotation+2B20matrix+2B20from+2B20a+2B20rotation+2B20axis+2B20and+2B20angle+2B20of+2B20rotation_+3A_rads">rads</code></td>
<td>

<p>If both the ksi and theta are in rads, this should be TRUE. If both the ksi and theta are in degrees, this should be FALSE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function accepts as arguments the rotation axis and the angle of rotation and it calcualtes the requested rotation matrix.
</p>


<h3>Value</h3>

<p>A 3 x 3 rotation matrix.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Course webpage of Howard E. Haber.
http://scipp.ucsc.edu/~haber/ph216/rotation_12.pdf
</p>
<p>Ted Chang (1986). Spherical Regression. Annals of Statistics, 14(3): 907&ndash;924.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Arotation">Arotation</a>, <a href="#topic+rotation">rotation</a>, <a href="#topic+rsop">rsop</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ksi &lt;- c(25.31, 24.29)
theta &lt;- 2.38
A &lt;- rot.matrix(ksi, theta, rads = FALSE)
A
Arotation(A)
</code></pre>

<hr>
<h2 id='Rotation+20matrix+20on+20SO+283+29+20from+20three+20Euler+20angles'>
Construct a rotation matrix on SO(3) from the Euler angles.
</h2><span id='topic+eul2rot'></span>

<h3>Description</h3>

<p>It forms a rotation matrix X on SO(3) by using three Euler angles <code class="reqn">(\theta_{12}, \theta_{13}, \theta_{23})</code>,
where X is defined as <code class="reqn">X=R_z(\theta_{12}) \times R_y(\theta_{13}) \times R_x( \theta_{23} )</code>.
Here <code class="reqn">R_x (\theta_{23})</code> means a rotation of <code class="reqn">\theta_{23}</code> radians about the x axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eul2rot(theta.12, theta.23, theta.13)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rotation+2B20matrix+2B20on+2B20SO+2B283+2B29+2B20from+2B20three+2B20Euler+2B20angles_+3A_theta.12">theta.12</code></td>
<td>

<p>An Euler angle, a number which must lie in <code class="reqn">(-\pi, \pi)</code>.
</p>
</td></tr>
<tr><td><code id="Rotation+2B20matrix+2B20on+2B20SO+2B283+2B29+2B20from+2B20three+2B20Euler+2B20angles_+3A_theta.23">theta.23</code></td>
<td>

<p>An Euler angle, a number which must lie in <code class="reqn">(-\pi, \pi)</code>.
</p>
</td></tr>
<tr><td><code id="Rotation+2B20matrix+2B20on+2B20SO+2B283+2B29+2B20from+2B20three+2B20Euler+2B20angles_+3A_theta.13">theta.13</code></td>
<td>

<p>An Euler angle, a number which must lie in <code class="reqn">(-\pi/2, \pi/2)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given three euler angles a rotation matrix X on SO(3) is formed using the transformation according to
Green and Mardia (2006) which is defined above.
</p>


<h3>Value</h3>

<p>A roation matrix.
</p>


<h3>Author(s)</h3>

<p>Anamul Sajib &lt;sajibstat@du.ac.bd&gt;.
</p>
<p>R implementation and documentation: Anamul Sajib &lt;sajibstat@du.ac.bd&gt;.
</p>


<h3>References</h3>

<p>Green, P. J. and Mardia, K. V. (2006). Bayesian alignment using hierarchical models, with applications in proteins bioinformatics. Biometrika, 93(2):235&ndash;254.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rot2eul">rot2eul</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># three euler angles

theta.12 &lt;- sample( seq(-3, 3, 0.3), 1 )
theta.23 &lt;- sample( seq(-3, 3, 0.3), 1 )
theta.13 &lt;- sample( seq(-1.4, 1.4, 0.3), 1 )

theta.12 ; theta.23 ; theta.13

X &lt;- eul2rot(theta.12, theta.23, theta.13)
X  # A rotation matrix
det(X)

e &lt;- rot2eul(X)$v1

theta.12 &lt;- e[3]
theta.23 &lt;- e[2]
theta.13 &lt;- e[1]

theta.12 ; theta.23 ; theta.13
</code></pre>

<hr>
<h2 id='Rotation+20matrix+20to+20rotate+20a+20spherical+20vector+20along+20the+20direction+20of+20another'>
Rotation matrix to rotate a spherical vector along the direction of another
</h2><span id='topic+rotation'></span>

<h3>Description</h3>

<p>A rotation matrix is calculated to rotate a unit vector along the direction of another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotation(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rotation+2B20matrix+2B20to+2B20rotate+2B20a+2B20spherical+2B20vector+2B20along+2B20the+2B20direction+2B20of+2B20another_+3A_a">a</code></td>
<td>

<p>The initial unit vector.
</p>
</td></tr>
<tr><td><code id="Rotation+2B20matrix+2B20to+2B20rotate+2B20a+2B20spherical+2B20vector+2B20along+2B20the+2B20direction+2B20of+2B20another_+3A_b">b</code></td>
<td>

<p>The target unit vector.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calcualtes a rotation matrix given two vectors. This rotation matrix is the connection between the two spherical only, vectors.
</p>


<h3>Value</h3>

<p>A rotation matrix whose dimension is equal to the length of the unit vectors. 
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Amaral G.J.A., Dryden I.L. and Wood A.T.A. (2007).
Pivotal Bootstrap Methods for k-Sample Problems in Directional Statistics and Shape Analysis. 
Journal of the American Statistical Association, 102(478): 695&ndash;707.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Arotation">Arotation</a>, <a href="#topic+rot.matrix">rot.matrix</a>, <a href="#topic+lambert">lambert</a>, <a href="#topic+lambert.inv">lambert.inv</a>, <a href="#topic+rsop">rsop</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- rnorm(3)
a &lt;- a/sqrt(sum(a^2))
b &lt;- rnorm(3)
b &lt;- b/sqrt(sum(b^2))
A &lt;- rotation(a, b)
A
a  ;  b
a %*% t(A)

a &lt;- rnorm(7)
a &lt;- a/sqrt(sum(a^2))
b &lt;- rnorm(7)
b &lt;- b/sqrt(sum(b^2))
A &lt;- rotation(a, b)
A
a  ;  b
a %*% t(A)
</code></pre>

<hr>
<h2 id='Saddlepoint+20approximations+20of+20the+20Fisher-Bingham+20distributions'>
Saddlepoint approximations of the Fisher-Bingham distributions
</h2><span id='topic+fb.saddle'></span>

<h3>Description</h3>

<p>It calculates the logarithm of the normalising constant of the Fisher-Bingham distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fb.saddle(gam, lam)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Saddlepoint+2B20approximations+2B20of+2B20the+2B20Fisher-Bingham+2B20distributions_+3A_gam">gam</code></td>
<td>

<p>A numeric vector containing the parameters of the Fisher part.
</p>
</td></tr>
<tr><td><code id="Saddlepoint+2B20approximations+2B20of+2B20the+2B20Fisher-Bingham+2B20distributions_+3A_lam">lam</code></td>
<td>

<p>All the eigenvalues of the Bingham part. Not just the non zero ones.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It calculate the three approximations given by Kume and Wood (2005) and it uses the Fisher-Bingham parametrization of that paper.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>first oder</code></td>
<td>

<p>The first order approximation
</p>
</td></tr>
<tr><td><code>second oder</code></td>
<td>

<p>The second order approximation
</p>
</td></tr>
<tr><td><code>third oder</code></td>
<td>

<p>The third order approximation
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Kume Alfred and Wood Andrew T.A. (2005). Saddlepoint approximations for the Bingham and Fisher-Bingham normalizing constants.
Biometrika, 92(2):465-476
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kent.logcon">kent.logcon</a>, <a href="#topic+rfb">rfb</a>, <a href="#topic+kent.mle">kent.mle</a>, <a href="#topic+rbingham">rbingham</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 3  ;  k &lt;- 1
0.5 * p * log(2 * pi) - (p/2 - 1) * log(k) + log( besselI(k, p/2 - 1, expon.scaled = TRUE) ) + k
## normalising constant of the
## von Mises-Fisher distribution
fb.saddle( c(0, k, 0), c(0, 0, 0) ) ## saddlepoint approximation

## Normalising constant of the Kent distribution
fb.saddle( c(0, 10, 0), c(0, -2, 2) )
kent.logcon(10, 2)
</code></pre>

<hr>
<h2 id='Simulation+20from+20a+20Bingham+20distribution+20using+20any+20symmetric+20matrix+20A'>
Simulation from a Bingham distribution using any symmetric matrix A
</h2><span id='topic+rbingham'></span>

<h3>Description</h3>

<p>It simulates random values from a Bingham distribution with any given symmetric matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbingham(n, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Simulation+2B20from+2B20a+2B20Bingham+2B20distribution+2B20using+2B20any+2B20symmetric+2B20matrix+2B20A_+3A_n">n</code></td>
<td>

<p>The sample size.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20from+2B20a+2B20Bingham+2B20distribution+2B20using+2B20any+2B20symmetric+2B20matrix+2B20A_+3A_a">A</code></td>
<td>

<p>A symmetric matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The eigenvalues are fist calcualted and then Chris Fallaize and Theo Kypraio's code (f.rbing) is used. The resulting simulated data anre then right multiplied by the eigenvectors of the matrix A.
</p>


<h3>Value</h3>

<p>A matrix with the siumlated data.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Kent J. T., Ganeiber A. M. and Mardia K. V. (2018). A new unified approach for the simulation of a wide class of directional distributions. 
Journal of Computational and Graphical Statistics, 27(2): 291&ndash;301.
</p>
<p>Kent J.T., Ganeiber A.M. and Mardia K.V. (2013).
A new method to simulate the Bingham and related distributions
in directional data analysis with applications.
http://arxiv.org/pdf/1310.8110v1.pdf
</p>
<p>Fallaize C. J. and Kypraios T. (2016). Exact bayesian inference for the Bingham distribution. 
Statistics and Computing, 26(1): 349&ndash;360.
http://arxiv.org/pdf/1401.2894v1.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+f.rbing">f.rbing</a>, <a href="#topic+rfb">rfb</a>, <a href="#topic+rvmf">rvmf</a>, <a href="#topic+rkent">rkent</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- cov(iris[, 1:3])
x &lt;- rbingham(100, A)
</code></pre>

<hr>
<h2 id='Simulation+20from+20a+20Matrix+20Fisher+20distribution+20on+20SO+283+29'>
Simulation from a Matrix Fisher distribution on SO(3)
</h2><span id='topic+rmatrixfisher'></span>

<h3>Description</h3>

<p>It simulates random samples (rotation matrices) from a Matrix Fisher distribution with any given parameter matrix, F (3x3).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmatrixfisher(n, F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Simulation+2B20from+2B20a+2B20Matrix+2B20Fisher+2B20distribution+2B20on+2B20SO+2B283+2B29_+3A_n">n</code></td>
<td>

<p>the sample size.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20from+2B20a+2B20Matrix+2B20Fisher+2B20distribution+2B20on+2B20SO+2B283+2B29_+3A_f">F</code></td>
<td>

<p>An arbitrary 3x3 matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Firstly corresponding Bingham parameter A is determined for a given Matrix Fisher parameter F using John Kent et al.'s (2013) algorithm and then Bingham samples for parameter A are generated using rbingham code. Finally convert Bingham samples to Matrix Fisher samples according to the Kent (2013) transformation.
</p>


<h3>Value</h3>

<p>An array with simulated rotation matrices.
</p>


<h3>Author(s)</h3>

<p>Anamul Sajib and Chris Fallaize.
</p>
<p>R implementation and documentation: Anamul Sajib &lt;sajibstat@du.ac.bd&gt; and Chris Fallaize.
</p>


<h3>References</h3>

<p>Kent J. T., Ganeiber A. M. and Mardia K. V. (2018). A new unified approach for the simulation of a wide class of directional distributions. 
Journal of Computational and Graphical Statistics, 27(2): 291&ndash;301.
</p>
<p>Kent J.T., Ganeiber A.M. and Mardia K.V. (2013).
A new method to simulate the Bingham and related distributions
in directional data analysis with applications.
http://arxiv.org/pdf/1310.8110v1.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matrixfisher.mle">matrixfisher.mle</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>F &lt;- matrix( c(85, 11, 41, 78, 39, 60, 43, 64, 48), ncol = 3) / 10   ### An arbitrary F matrix
a &lt;- rmatrixfisher(10, F)
</code></pre>

<hr>
<h2 id='Simulation+20of+20random+20values+20from+20a+20Bingham+20distribution'>
Simulating from a Bingham distribution</h2><span id='topic+f.rbing'></span>

<h3>Description</h3>

<p>It simulates from a Bingham distribution using the code suggested by Kent et al. (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f.rbing(n, lam, fast = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20a+2B20Bingham+2B20distribution_+3A_n">n</code></td>
<td>

<p>Sample size.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20a+2B20Bingham+2B20distribution_+3A_lam">lam</code></td>
<td>

<p>Eigenvalues of the diagonal symmetric matrix of the Bingham distribution.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20a+2B20Bingham+2B20distribution_+3A_fast">fast</code></td>
<td>

<p>If you want a fast, efficient simulation set this to TRUE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user must have calculated the eigenvalues of the diagonal symmetric matrix of the Bingham distribution. 
The function accepts the q-1 eigenvalues only. This means, that the user must have subtracted the 
lowest eigenvalue from the rest and give the non zero ones. The function uses rejection sampling and 
it was written by Chris Fallaize and Theo Kypraios (University of Nottingham) and kindly offered. 
Any questions on the code can be addressed to one of the two aforementioned people. 
It is slightly different than the one Kent et al. (2013) suggests.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>X</code></td>
<td>

<p>The simulated data.
</p>
</td></tr>
<tr><td><code>avtry</code></td>
<td>

<p>The estimate of M in the rejection sampling. The average number of simulated values before a value is accepted.
If the argument fast is set to TRUE this information will not appear.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Kent J. T., Ganeiber A. M. and Mardia K. V. (2018). A new unified approach for the simulation of a wide class of directional distributions. 
Journal of Computational and Graphical Statistics, 27(2): 291&ndash;301.
</p>
<p>Kent J.T., Ganeiber A.M. and Mardia K.V. (2013).
A new method to simulate the Bingham and related distributions
in directional data analysis with applications.
http://arxiv.org/pdf/1310.8110v1.pdf
</p>
<p>Fallaize C. J. and Kypraios T. (2016). Exact bayesian inference for the Bingham distribution. 
Statistics and Computing, 26(1): 349&ndash;360.
http://arxiv.org/pdf/1401.2894v1.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rfb">rfb</a>, <a href="#topic+rvmf">rvmf</a>, <a href="#topic+rbingham">rbingham</a>, <a href="#topic+rkent">rkent</a>, link{rsop}
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- f.rbing( 100, c(1, 0.6, 0.1) )
x
</code></pre>

<hr>
<h2 id='Simulation+20of+20random+20values+20from+20a+20mixture+20of+20von+20Mises-Fisher+20distributions'>
Simulation of random values from a mixture of von Mises-Fisher distributions
</h2><span id='topic+rmixvmf'></span>

<h3>Description</h3>

<p>The function simulates random values simulation from a given mixture of von Mises-Fisher distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmixvmf(n, probs, mu, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20a+2B20mixture+2B20of+2B20von+2B20Mises-Fisher+2B20distributions_+3A_n">n</code></td>
<td>

<p>The sample size.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20a+2B20mixture+2B20of+2B20von+2B20Mises-Fisher+2B20distributions_+3A_probs">probs</code></td>
<td>

<p>This is avector with the mixing probability of each group.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20a+2B20mixture+2B20of+2B20von+2B20Mises-Fisher+2B20distributions_+3A_mu">mu</code></td>
<td>

<p>A matrix with the mean direction of each group.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20a+2B20mixture+2B20of+2B20von+2B20Mises-Fisher+2B20distributions_+3A_k">k</code></td>
<td>

<p>A vector with the concentration parameter of each group.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function simulates random values simulation from a given mixture of von Mises-Fisher distributions using the rvmf function.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>id</code></td>
<td>

<p>An indicator of the group of each simulated vector.
</p>
</td></tr>
<tr><td><code>x</code></td>
<td>

<p>A matrix with the simulated data.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Kurt Hornik and  Bettina Grun (2014). movMF: An R Package for Fitting Mixtures of von Mises-Fisher Distributions
http://cran.r-project.org/web/packages/movMF/vignettes/movMF.pdf</p>


<h3>See Also</h3>

<p><code><a href="#topic+mixvmf.mle">mixvmf.mle</a>, <a href="#topic+rvmf">rvmf</a>, <a href="#topic+bic.mixvmf">bic.mixvmf</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k &lt;- runif(3, 4, 20)
probs &lt;- c(0.2, 0.5, 0.3)
mu &lt;- matrix(rnorm(9), ncol = 3)
mu &lt;- mu / sqrt( rowSums(mu^2) )
x &lt;- rmixvmf(200, probs, mu, k)$x
bic.mixvmf(x, 5)
</code></pre>

<hr>
<h2 id='Simulation+20of+20random+20values+20from+20a+20spherical+20Fisher-Bingham+20distribution'>
Simulation of random values from a spherical Fisher-Bingham distribution
</h2><span id='topic+rfb'></span>

<h3>Description</h3>

<p>Simulation of random values from a spherical Fisher-Bingham distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfb(n, k, m, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20a+2B20spherical+2B20Fisher-Bingham+2B20distribution_+3A_n">n</code></td>
<td>

<p>The sample size.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20a+2B20spherical+2B20Fisher-Bingham+2B20distribution_+3A_k">k</code></td>
<td>

<p>The concentraion parameter (Fisher part). It has to be greater than 0.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20a+2B20spherical+2B20Fisher-Bingham+2B20distribution_+3A_m">m</code></td>
<td>

<p>The mean direction (Fisher part).
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20a+2B20spherical+2B20Fisher-Bingham+2B20distribution_+3A_a">A</code></td>
<td>

<p>A symmetric matrix (Bingham part).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Random values from a spherical Fisher-Bingham distribution are generated. This functions included the option of simulating from a Kent distribution also.
</p>


<h3>Value</h3>

<p>A matrix with the simulated data.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Kent J. T., Ganeiber A. M. and Mardia K. V. (2018). A new unified approach for the simulation of a wide class of directional distributions. 
Journal of Computational and Graphical Statistics, 27(2): 291&ndash;301.
</p>
<p>Kent J.T., Ganeiber A.M. and Mardia K.V. (2013).
A new method to simulate the Bingham and related distributions
in directional data analysis with applications.
http://arxiv.org/pdf/1310.8110v1.pdf
</p>
<p>Fallaize C. J. and Kypraios T. (2016). Exact bayesian inference for the Bingham distribution. 
Statistics and Computing, 26(1): 349&ndash;360.
http://arxiv.org/pdf/1401.2894v1.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rbingham">rbingham</a>, <a href="#topic+rvmf">rvmf</a>, <a href="#topic+rkent">rkent</a>, <a href="#topic+f.rbing">f.rbing</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k &lt;- 15
mu &lt;- rnorm(3)
mu &lt;- mu / sqrt( sum(mu^2) )
A &lt;- cov(iris[, 1:3])
x &lt;- rfb(50, k, mu, A)
vmf.mle(x) ## fits a von Mises-Fisher distribution to the simulated data
## Next we simulate from a Kent distribution
A &lt;- diag( c(-5, 0, 5) )
n &lt;- 100
x &lt;- rfb(n, k, mu, A) ## data follow a Kent distribution
kent.mle(x) ## fits a Kent distribution
vmf.mle(x) ## fits a von Mises-Fisher distribution
A &lt;- diag( c(5, 0, -5) )
n &lt;- 100
x &lt;- rfb(n, k, mu, A) ## data follow a Kent distribution
kent.mle(x) ## fits a Kent distribution
vmf.mle(x) ## fits a von Mises-Fisher distribution
</code></pre>

<hr>
<h2 id='Simulation+20of+20random+20values+20from+20a+20spherical+20Kent+20distribution'>
Simulation of random values from a spherical Kent distribution
</h2><span id='topic+rkent'></span>

<h3>Description</h3>

<p>Simulation of random values from a spherical Kent distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rkent(n, k, m, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20a+2B20spherical+2B20Kent+2B20distribution_+3A_n">n</code></td>
<td>

<p>The sample size.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20a+2B20spherical+2B20Kent+2B20distribution_+3A_k">k</code></td>
<td>

<p>The concentraion parameter <code class="reqn">\kappa</code>. It has to be greater than 0.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20a+2B20spherical+2B20Kent+2B20distribution_+3A_m">m</code></td>
<td>

<p>The mean direction (Fisher part).
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20a+2B20spherical+2B20Kent+2B20distribution_+3A_b">b</code></td>
<td>

<p>The ovalness parameter, <code class="reqn">\beta</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Random values from a Kent distribution on the sphere are generated. The function generates from a spherical Kent distribution using <code><a href="#topic+rfb">rfb</a></code> with an arbitrary mean direction and then rotates the data to have the desired mean direction.
</p>


<h3>Value</h3>

<p>A matrix with the simulated data.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Kent J. T., Ganeiber A. M. and Mardia K. V. (2018). A new unified approach for the simulation of a wide class of directional distributions. 
Journal of Computational and Graphical Statistics, 27(2): 291&ndash;301.
</p>
<p>Kent J.T., Ganeiber A.M. and Mardia K.V. (2013).
A new method to simulate the Bingham and related distributions
in directional data analysis with applications.
http://arxiv.org/pdf/1310.8110v1.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rfb">rfb</a>, <a href="#topic+rbingham">rbingham</a>, <a href="#topic+rvmf">rvmf</a>, <a href="#topic+f.rbing">f.rbing</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k &lt;- 15
mu &lt;- rnorm(3)
mu &lt;- mu / sqrt( sum(mu^2) )
A &lt;- diag( c(-5, 0, 5) )
x &lt;- rfb(500, k, mu, A)
kent.mle(x)
y &lt;- rkent(500, k, mu, A[3, 3])
kent.mle(y)
</code></pre>

<hr>
<h2 id='Simulation+20of+20random+20values+20from+20rotationally+20symmetric+20distributions'>
Simulation of random values from rotationally symmetric distributions
</h2><span id='topic+rvmf'></span><span id='topic+riag'></span><span id='topic+rspcauchy'></span><span id='topic+rpkbd'></span>

<h3>Description</h3>

<p>Simulation of random values from rotationally symmetric distributions. The data can be spherical or hyper-spherical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvmf(n, mu, k)
riag(n, mu)
rspcauchy(n, mu, rho)
rpkbd(n, mu, rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20rotationally+2B20symmetric+2B20distributions_+3A_n">n</code></td>
<td>

<p>The sample size.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20rotationally+2B20symmetric+2B20distributions_+3A_mu">mu</code></td>
<td>

<p>A unit vector showing the mean direction for the von Mises-Fisher or the spherical Cauchy distribution. The mean vector of the Independent Angular Gaussian distribution does not have to be a unit vector.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20rotationally+2B20symmetric+2B20distributions_+3A_k">k</code></td>
<td>

<p>The concentration parameter (<code class="reqn">\kappa</code>) of the von Mises-Fisher distribution. If <code class="reqn">\kappa=0</code>, random values from the spherical uniform will be drwan.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20rotationally+2B20symmetric+2B20distributions_+3A_rho">rho</code></td>
<td>

<p>The <code class="reqn">\rho</code> parameter of the spherical Cauchy or the Poisson kernel based distribution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The von Mises-Fisher uses the rejection smapling suggested by Wood (1994). For the Independent Angular Gaussian, values are generated from a multivariate normal distribution with the given mean vector and the identity matrix as the covariance matrix. Then each vector becomes a unit vector. For the spherical Cauchy distribution the algortihm is described in Kato and McCullagh (2020) and for the Poisson kernel based distribution, it is described in Sablica, Hornik and Leydold (2023).
</p>


<h3>Value</h3>

<p>A matrix with the simulated data.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Wood A.T.A. (1994). Simulation of the von Mises Fisher distribution.
Communications in Statistics-Simulation and Computation, 23(1): 157&ndash;164.
</p>
<p>Dhillon I. S. and Sra S. (2003). Modeling data using directional distributions.
Technical Report TR-03-06, Department of Computer Sciences, The University of Texas at Austin.
http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.75.4122&amp;rep=rep1&amp;type=pdf
</p>
<p>Kato S. and McCullagh P. (2020). Some properties of a Cauchy family on the sphere derived from the Mobius transformations. Bernoulli, 26(4): 3224&ndash;3248.
https://arxiv.org/pdf/1510.07679.pdf
</p>
<p>Sablica L., Hornik K. and Leydold J. (2023). Efficient sampling from the PKBD distribution.
Electronic Journal of Statistics, 17(2): 2180&ndash;2209.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vmf.mle">vmf.mle</a>, <a href="#topic+iag.mle">iag.mle</a> <a href="#topic+rfb">rfb</a>, <a href="#topic+racg">racg</a>, <a href="#topic+rvonmises">rvonmises</a>, <a href="#topic+rmixvmf">rmixvmf</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- rnorm(4)
m &lt;- m/sqrt(sum(m^2))
x &lt;- rvmf(100, m, 25)
m
vmf.mle(x)
</code></pre>

<hr>
<h2 id='Simulation+20of+20random+20values+20from+20some+20circular+20distributions'>
Simulation of random values from some circular distributions
</h2><span id='topic+rvonmises'></span><span id='topic+rwrapcauchy'></span><span id='topic+rspml'></span><span id='topic+rcircbeta'></span><span id='topic+rcircpurka'></span><span id='topic+rcircexp'></span><span id='topic+rcipc'></span><span id='topic+rgcpc'></span>

<h3>Description</h3>

<p>Simulation of random values from some circular distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvonmises(n, m, k, rads = TRUE)
rwrapcauchy(n, m, rho, rads = TRUE)
rspml(n, mu, rads = TRUE)
rcircbeta(n, m, a, b, rads = TRUE)
rcircpurka(n, m, a, rads = TRUE)
rcircexp(n, lambda, rads = TRUE)
rcipc(n, mu = NULL, omega, g, rads = TRUE)
rgcpc(n, mu = NULL, omega, g, rho, rads = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20some+2B20circular+2B20distributions_+3A_n">n</code></td>
<td>

<p>The sample size.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20some+2B20circular+2B20distributions_+3A_m">m</code></td>
<td>

<p>The mean angle expressed in radians or degrees.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20some+2B20circular+2B20distributions_+3A_mu">mu</code></td>
<td>

<p>The mean vector of the SPML, CIPC and GCPC in <code class="reqn">R^2</code>. For the CIPC and GCPC, if this argument is not given, 
then the omega and g must be given.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20some+2B20circular+2B20distributions_+3A_omega">omega</code></td>
<td>

<p>The location parameter for the CIPC and the GCPC expressed in radians or degrees.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20some+2B20circular+2B20distributions_+3A_k">k</code></td>
<td>

<p>The concentration parameter of the von Mises distribution.
If k is zero the sample will be generated from the uniform distribution over <code class="reqn">(0, 2\pi)</code>.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20some+2B20circular+2B20distributions_+3A_g">g</code></td>
<td>

<p>The norm of the mean vector for the CIPC and GCPC, if <code>omega</code> is given instead of <code>mu</code>.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20some+2B20circular+2B20distributions_+3A_rho">rho</code></td>
<td>

<p>For the wrapped Cauchy distribution, this is the <code class="reqn">\rho</code> parameter.
For the GCPC distribution this is the eigenvalue parameter, or covariance determinant.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20some+2B20circular+2B20distributions_+3A_a">a</code></td>
<td>

<p>The <code class="reqn">\alpha</code> parameter of the beta distribution.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20some+2B20circular+2B20distributions_+3A_b">b</code></td>
<td>

<p>The <code class="reqn">\beta</code> parameter of the beta distribution.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20some+2B20circular+2B20distributions_+3A_lambda">lambda</code></td>
<td>

<p>The <code class="reqn">\lambda</code> parameter of the circular (wrapped) exponential distribution.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20some+2B20circular+2B20distributions_+3A_rads">rads</code></td>
<td>

<p>If the mean angle is expressed in radians, this should be TRUE and FALSE otherwise.
The simulated data will be expressed in radians or degrees depending on what the mean angle is expressed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the von Mises distribution, the mean direction is transformed to the Euclidean coordinates (i.e. unit vector)
and then the <code><a href="#topic+rvmf">rvmf</a></code> function is employed. It uses a rejection smapling as suggested by Andrew Wood in 1994.
We have mentioned the description of the algorithm as we found it in Dhillon and Sra in 2003.
Finally, the data are transformed to radians or degrees.
</p>
<p>For the wrapped Cauchy and wrapped exponential distributions the function generates Cauchy or exponential values
<code class="reqn">x</code> and then wrapps them around the circle <code class="reqn">x = x(mod 2 \pi)</code>. For the circular beta the function has some
extra steps (see Zheng Sun's master thesis).
</p>
<p>For the CIPC and GCPC distributions, data are generated from the bivariate Cauchy distribution,
normalized to have unit norm and then transformed to angles.
</p>


<h3>Value</h3>

<p>A vector with the simulated data.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Wood A.T.A. (1994). Simulation of the von Mises Fisher distribution.
Communications in Statistics-Simulation and Computation, 23(1): 157-164.
</p>
<p>Dhillon I.S. and Sra S. (2003). Modeling data using directional distributions.
Technical Report TR-03-06, Department of Computer Sciences, The University of Texas at Austin.
http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.75.4122&amp;rep=rep1&amp;type=pdf
</p>
<p>Zheng Sun (2006). Comparing measures of fit for circular distributions. Master thesis, University of Victoria.
https://dspace.library.uvic.ca/bitstream/handle/1828/2698/zhengsun_master_thesis.pdf;sequence=1
</p>
<p>Lai M. (1994). Some results in the statistical analysis of directional data.
Master thesis, University of Hong Kong.
</p>
<p>Presnell B., Morrison S.P. and Littell R.C. (1998). 
Projected multivariate linear models for directional data.
Journal of the American Statistical Association, 93(443): 1068&ndash;1077.
</p>
<p>Purkayastha S. (1991). A Rotationally Symmetric Directional Distribution: 
Obtained through Maximum Likelihood Characterization. 
The Indian Journal of Statistics, Series A, 53(1): 70&ndash;83
</p>
<p>Jammalamadaka S.R. and Kozubowski T.J. (2003). A new family of circular models: 
The wrapped Laplace distributions. Advances and Applications in Statistics, 3(1): 77&ndash;103.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+circ.summary">circ.summary</a>, <a href="#topic+rvmf">rvmf</a>, <a href="#topic+racg">racg</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvonmises(100, 2, 25, rads = TRUE)
circ.summary(x, rads = TRUE)
</code></pre>

<hr>
<h2 id='Simulation+20of+20random+20values+20from+20the+20ESAG+20distribution'>
Simulation of random values from the ESAG distribution
</h2><span id='topic+resag'></span>

<h3>Description</h3>

<p>Simulation of random values from the ESAG distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resag(n, mu, gam)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20the+2B20ESAG+2B20distribution_+3A_n">n</code></td>
<td>

<p>A number; how many vectors you want to generate.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20the+2B20ESAG+2B20distribution_+3A_mu">mu</code></td>
<td>

<p>The mean vector the ESAG distribution, a vector in <code class="reqn">R^3</code>.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20the+2B20ESAG+2B20distribution_+3A_gam">gam</code></td>
<td>

<p>The two <code class="reqn">\gamma</code> parameters of the ESAG distribution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A random sample from the ESAG distribution is generated. In case the <code class="reqn">\gamma_s</code> are zero, the sample is drawn
from the Independent Angular Gaussian (or projected normal).
</p>


<h3>Value</h3>

<p>An <code class="reqn">n \times 3</code> matrix with the simulated unit vectors.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Mardia, K. V. and Jupp, P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
</p>
<p>Paine P.J., Preston S.P., Tsagris M. and Wood A.T.A. (2018). An Elliptically Symmetric Angular
Gaussian Distribution. Statistics and Computing, 28(3):689&ndash;697.
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+esag.mle">esag.mle</a>, <a href="#topic+desag">desag</a>, <a href="#topic+spml.mle">spml.mle</a>, <a href="#topic+acg.mle">acg.mle</a>, <a href="#topic+circ.summary">circ.summary</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- colMeans( as.matrix( iris[,1:3] ) )
y &lt;- resag(1000, m, c(1, 0.5) )
esag.mle(y)
</code></pre>

<hr>
<h2 id='Simulation+20of+20random+20values+20from+20the+20SESPC+20distribution'>
Simulation of random values from the SESPC distribution
</h2><span id='topic+rsespc'></span>

<h3>Description</h3>

<p>Simulation of random values from the SESPC distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsespc(n, mu, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20the+2B20SESPC+2B20distribution_+3A_n">n</code></td>
<td>

<p>A number; how many vectors you want to generate.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20the+2B20SESPC+2B20distribution_+3A_mu">mu</code></td>
<td>

<p>The mean vector the SESPC distribution, a vector in <code class="reqn">R^3</code>.
</p>
</td></tr>
<tr><td><code id="Simulation+2B20of+2B20random+2B20values+2B20from+2B20the+2B20SESPC+2B20distribution_+3A_theta">theta</code></td>
<td>

<p>The two <code class="reqn">\theta</code> parameters of the SESPC distribution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A random sample from the SESPC distribution is generated. In case the <code class="reqn">\theta_s</code> are zero, the sample is drawn
from the SIPC (spherical independent projected Cauchy) distribution.
</p>


<h3>Value</h3>

<p>An <code class="reqn">n \times 3</code> matrix with the simulated unit vectors.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Mardia, K. V. and Jupp, P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+sespc.mle">sespc.mle</a>, <a href="#topic+dsespc">dsespc</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- colMeans( as.matrix( iris[,1:3] ) )
y &lt;- rsespc(1000, m, c(1, 0.5) )
sespc.mle(y)
</code></pre>

<hr>
<h2 id='Spherical+20and+20hyper-spherical+20distance+20correlation'>Spherical and hyper-spherical distance correlation
</h2><span id='topic+spher.dcor'></span>

<h3>Description</h3>

<p>Spherical and hyper-spherical distance correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spher.dcor(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Spherical+2B20and+2B20hyper-spherical+2B20distance+2B20correlation_+3A_x">x</code></td>
<td>

<p>A matrix with directional data, i.e. unit vectors.
</p>
</td></tr>
<tr><td><code id="Spherical+2B20and+2B20hyper-spherical+2B20distance+2B20correlation_+3A_y">y</code></td>
<td>

<p>A matrix with directional data, i.e. unit vectors.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distance correlation between two spherical or hyper-spherical variables is computed.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>dcov</code></td>
<td>

<p>The distance covariance.
</p>
</td></tr>
<tr><td><code>dvarX</code></td>
<td>

<p>The distance variance of x.
</p>
</td></tr>
<tr><td><code>dvarY</code></td>
<td>

<p>The distance variance of Y.
</p>
</td></tr>
<tr><td><code>dcor</code></td>
<td>

<p>The distance correlation.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>G.J. Szekely, M.L. Rizzo and N. K. Bakirov (2007). Measuring and Testing Independence 
by Correlation of Distances. Annals of Statistics, 35(6):2769-2794.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+circ.dcor">circ.dcor</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- rvmf(50, rnorm(3), 4)
x &lt;- rvmf(50, rnorm(3), 4)
spher.dcor(x, y)
</code></pre>

<hr>
<h2 id='Spherical+20and+20hyperspherical+20median'>
Fast calculation of the spherical and hyperspherical median
</h2><span id='topic+mediandir'></span><span id='topic+mediandir_2'></span>

<h3>Description</h3>

<p>It calculates, very fast, the (hyper-)spherical median of a sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mediandir(x)
mediandir_2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Spherical+2B20and+2B20hyperspherical+2B20median_+3A_x">x</code></td>
<td>

<p>The data, a numeric matrix with unit vectors.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;mediandir&quot; employes a fixed poit iterative algorithm stemming from the first derivative (Cabrera and Watson, 1990) to find the median direction as described by Fisher (1985) and Fisher, Lewis and Embleton (1987).
In the big samples this is much much faster than &quot;mediandir_2&quot;, since the search is based on iterations.
</p>


<h3>Value</h3>

<p>The median direction.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Fisher N. I. (1985). Spherical medians. Journal of the Royal Statistical Society. Series B, 47(2): 342&ndash;348.
</p>
<p>Fisher N. I., Lewis T. and Embleton B. J. (1987). Statistical analysis of spherical data. Cambridge university press.
</p>
<p>Cabrera J. and Watson G. S. (1990). On a spherical median related distribution. Communications in Statistics-Theory and Methods, 19(6): 1973&ndash;1986.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nsmedian">nsmedian</a>, <a href="#topic+vmf.mle">vmf.mle</a>, <a href="#topic+kent.mle">kent.mle</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- rnorm(3)
m &lt;- m / sqrt( sum(m^2) )
x &lt;- rvmf(100, m, 10)
mediandir(x)
mediandir_2(x)
nsmedian(x)
</code></pre>

<hr>
<h2 id='Spherical+20regression+20using+20rotationally+20symmetric+20distributions'>
Spherical regression using rotationally symmetric distributions
</h2><span id='topic+iag.reg'></span><span id='topic+vmf.reg'></span><span id='topic+sipc.reg'></span>

<h3>Description</h3>

<p>Spherical regression using rotationally symmetric distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iag.reg(y, x, con = TRUE, xnew = NULL, tol = 1e-06)
vmf.reg(y, x, con = TRUE, xnew = NULL, tol = 1e-06)
sipc.reg(y, x, con = TRUE, xnew = NULL, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Spherical+2B20regression+2B20using+2B20rotationally+2B20symmetric+2B20distributions_+3A_y">y</code></td>
<td>

<p>A matrix with 3 columns containing the (unit vector) spherical data.
</p>
</td></tr>
<tr><td><code id="Spherical+2B20regression+2B20using+2B20rotationally+2B20symmetric+2B20distributions_+3A_x">x</code></td>
<td>

<p>The predictor variable(s), they can be continnuous, spherical, categorical or a mix of them.
</p>
</td></tr>
<tr><td><code id="Spherical+2B20regression+2B20using+2B20rotationally+2B20symmetric+2B20distributions_+3A_con">con</code></td>
<td>

<p>Do you want the constant term in the regression?
</p>
</td></tr>
<tr><td><code id="Spherical+2B20regression+2B20using+2B20rotationally+2B20symmetric+2B20distributions_+3A_xnew">xnew</code></td>
<td>

<p>If you have new data use it, otherwise leave it NULL.
</p>
</td></tr>
<tr><td><code id="Spherical+2B20regression+2B20using+2B20rotationally+2B20symmetric+2B20distributions_+3A_tol">tol</code></td>
<td>

<p>A tolerance value to decide when to stop the successive optimaizations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The second parametrization of the projected normal and of the von Mises-Fisher regression (Paine et al., 2020) is applied. The same is true for the SIPC distribution. For more information see the paper by Paine et al. (2020).
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>loglik</code></td>
<td>

<p>The log-likelihood of the regression model.
</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>

<p>This is a measure of fit of the estimated values, defined as <code class="reqn">\sum_{i=1}^ny_i^T\hat{y}_i</code>. This appears if the argument &quot;xnew&quot; is NULL.
</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>

<p>The beta coefficients.
</p>
</td></tr>
<tr><td><code>seb</code></td>
<td>

<p>The standard error of the beta coefficients.
</p>
</td></tr>
<tr><td><code>ki</code></td>
<td>

<p>The norm of the fitted values. In the von Mises-Fisher regression this is the concentration parameter of each observation. In the projected normal this are the norms of the fitted values before being projected onto the sphere. This is returned if the argument &quot;xnew&quot; is NULL.
</p>
</td></tr>
<tr><td><code>est</code></td>
<td>

<p>The fitted values of xnew if &quot;xnew&quot; is NULL. If it is not NULL, the fitted values for the &quot;xnew&quot; you supplied will be returned.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>P. J. Paine, S. P. Preston, M. Tsagris and Andrew T. A. Wood (2020).
Spherical regression models with general covariates and anisotropic errors.
Statistics and Computing, 30(1): 153&ndash;165.
https://link.springer.com/content/pdf/10.1007
</p>
<p>Tsagris M. and Alzeley O. (2023). Circular and spherical projected Cauchy distributions:
A Novel Framework for Circular and Directional Data Modeling.
https://arxiv.org/pdf/2302.02468.pdf
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+esag.reg">esag.reg</a>, <a href="#topic+esag.mle">esag.mle</a>, <a href="#topic+vmf.mle">vmf.mle</a>, <a href="#topic+spml.reg">spml.reg</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- rvmf(150, rnorm(3), 5)
a1 &lt;- iag.reg(y, iris[, 4])
a2 &lt;- iag.reg(y, iris[, 4:5])

b1 &lt;- vmf.reg(y, iris[, 4])
b2 &lt;- vmf.reg(y, iris[, 4:5])
</code></pre>

<hr>
<h2 id='Spherical+20regression+20using+20the+20ESAG+20distribution'>
Spherical regression using the ESAG distribution
</h2><span id='topic+esag.reg'></span>

<h3>Description</h3>

<p>Spherical regression using the ESAG distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>esag.reg(y, x, con = TRUE, xnew = NULL, lati = 10, longi = 10, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Spherical+2B20regression+2B20using+2B20the+2B20ESAG+2B20distribution_+3A_y">y</code></td>
<td>

<p>A matrix with 3 columns containing the (unit vector) spherical data.
</p>
</td></tr>
<tr><td><code id="Spherical+2B20regression+2B20using+2B20the+2B20ESAG+2B20distribution_+3A_x">x</code></td>
<td>

<p>The predictor variable(s), they can be continnuous, spherical, categorical or a mix of them.
</p>
</td></tr>
<tr><td><code id="Spherical+2B20regression+2B20using+2B20the+2B20ESAG+2B20distribution_+3A_con">con</code></td>
<td>

<p>Do you want the constant term in the regression?
</p>
</td></tr>
<tr><td><code id="Spherical+2B20regression+2B20using+2B20the+2B20ESAG+2B20distribution_+3A_xnew">xnew</code></td>
<td>

<p>If you have new data use it, otherwise leave it NULL.
</p>
</td></tr>
<tr><td><code id="Spherical+2B20regression+2B20using+2B20the+2B20ESAG+2B20distribution_+3A_lati">lati</code></td>
<td>

<p>A positive number determing the range of degrees to move left and right from the latitude center. This number and the next determine the grid of points to search for the Q matrix described in Paine et al. (2020).
</p>
</td></tr>
<tr><td><code id="Spherical+2B20regression+2B20using+2B20the+2B20ESAG+2B20distribution_+3A_longi">longi</code></td>
<td>

<p>A positive number determing the range of degrees to move up and down from the longitude center. This number and the previous determine the grid of points to search for the Q matrix described in Paine et al. (2020).
</p>
</td></tr>
<tr><td><code id="Spherical+2B20regression+2B20using+2B20the+2B20ESAG+2B20distribution_+3A_tol">tol</code></td>
<td>

<p>A tolerance value to decide when to stop the successive optimizations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The second parametrization of the ESAG regression (Paine et al., 2020) is applied.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>loglik</code></td>
<td>

<p>The log-likelihood of the regression model.
</p>
</td></tr>
<tr><td><code>param</code></td>
<td>

<p>A vector with three numbers. A measure of fit of the estimated values, defined as <code class="reqn">\sum_{i=1}^ny_i^T\hat{y}_i</code>. This appears if the argument &quot;xnew&quot; is NULL. The <code class="reqn">\rho \in (0,1]</code> (smallest eigenvalue of the covariance matrix)), and the angle of rotation <code class="reqn">psi</code>.
</p>
</td></tr>
<tr><td><code>gam</code></td>
<td>

<p>The two <code class="reqn">\gamma</code> parameters.
</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>

<p>The beta coefficients.
</p>
</td></tr>
<tr><td><code>seb</code></td>
<td>

<p>The standard error of the beta coefficients.
</p>
</td></tr>
<tr><td><code>est</code></td>
<td>

<p>The fitted values of xnew if &quot;xnew&quot; is NULL. If it is not NULL, the fitted values for the &quot;xnew&quot; you supplied will be returned.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>P. J. Paine, S. P. Preston, M. Tsagris and Andrew T. A. Wood (2020).
Spherical regression models with general covariates and anisotropic errors.
Statistics and Computing, 30(1): 153&ndash;165.
https://link.springer.com/content/pdf/10.1007
</p>


<h3>See Also</h3>

<p><code><a href="#topic+esag.mle">esag.mle</a>, <a href="#topic+iag.reg">iag.reg</a>, <a href="#topic+spml.reg">spml.reg</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- resag( 30, rnorm(3), c(1, 1) )
## this is a small example to pass CRAN's check because the default argument values
## of lati and longi require many seconds
a &lt;- esag.reg(y, iris[1:30, 4], lati = 2, longi = 2)
</code></pre>

<hr>
<h2 id='Spherical+20regression+20using+20the+20SESPC+20distribution'>
Spherical regression using the SESPC distribution
</h2><span id='topic+sespc.reg'></span>

<h3>Description</h3>

<p>Spherical regression using the SESPC distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sespc.reg(y, x, con = TRUE, xnew = NULL, lati = 10, longi = 10, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Spherical+2B20regression+2B20using+2B20the+2B20SESPC+2B20distribution_+3A_y">y</code></td>
<td>

<p>A matrix with 3 columns containing the (unit vector) spherical data.
</p>
</td></tr>
<tr><td><code id="Spherical+2B20regression+2B20using+2B20the+2B20SESPC+2B20distribution_+3A_x">x</code></td>
<td>

<p>The predictor variable(s), they can be continnuous, spherical, categorical or a mix of them.
</p>
</td></tr>
<tr><td><code id="Spherical+2B20regression+2B20using+2B20the+2B20SESPC+2B20distribution_+3A_con">con</code></td>
<td>

<p>Do you want the constant term in the regression?
</p>
</td></tr>
<tr><td><code id="Spherical+2B20regression+2B20using+2B20the+2B20SESPC+2B20distribution_+3A_xnew">xnew</code></td>
<td>

<p>If you have new data use it, otherwise leave it NULL.
</p>
</td></tr>
<tr><td><code id="Spherical+2B20regression+2B20using+2B20the+2B20SESPC+2B20distribution_+3A_lati">lati</code></td>
<td>

<p>A positive number determing the range of degrees to move left and right from the latitude center. This number and the next determine the grid of points to search for the Q matrix described in Tsagris and Alzeley (2023).
</p>
</td></tr>
<tr><td><code id="Spherical+2B20regression+2B20using+2B20the+2B20SESPC+2B20distribution_+3A_longi">longi</code></td>
<td>

<p>A positive number determing the range of degrees to move up and down from the longitude center. This number and the previous determine the grid of points to search for the Q matrix described in Tsagris and Alzeley (2023).
</p>
</td></tr>
<tr><td><code id="Spherical+2B20regression+2B20using+2B20the+2B20SESPC+2B20distribution_+3A_tol">tol</code></td>
<td>

<p>A tolerance value to decide when to stop the successive optimizations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Regression based on the SESPC distribution (Tsagris and Alzeley, 2023) is applied.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>loglik</code></td>
<td>

<p>The log-likelihood of the regression model.
</p>
</td></tr>
<tr><td><code>param</code></td>
<td>

<p>A vector with three numbers. A measure of fit of the estimated values, defined as <code class="reqn">\sum_{i=1}^ny_i^T\hat{y}_i</code>. This appears if the argument &quot;xnew&quot; is NULL. The <code class="reqn">\rho \in (0,1]</code> (smallest eigenvalue of the covariance matrix)), and the angle of rotation <code class="reqn">psi</code>.
</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>

<p>The two <code class="reqn">\theta</code> parameters.
</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>

<p>The beta coefficients.
</p>
</td></tr>
<tr><td><code>seb</code></td>
<td>

<p>The standard error of the beta coefficients.
</p>
</td></tr>
<tr><td><code>est</code></td>
<td>

<p>The fitted values of xnew if &quot;xnew&quot; is NULL. If it is not NULL, the fitted values for the &quot;xnew&quot; you supplied will be returned.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Tsagris M. and Alzeley O. (2023). Circular and spherical projected Cauchy distributions:
A Novel Framework for Circular and Directional Data Modeling.
https://arxiv.org/pdf/2302.02468.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+esag.mle">esag.mle</a>, <a href="#topic+iag.reg">iag.reg</a>, <a href="#topic+spml.reg">spml.reg</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- rsespc( 150, rnorm(3), c(1, 1) )
## this is a small example to pass CRAN's check because the default argument values
## of lati and longi require many seconds
a &lt;- sespc.reg(y, iris[, 4], lati = 2, longi = 2)
</code></pre>

<hr>
<h2 id='Spherical-spherical+20correlation'>
Spherical-spherical correlation
</h2><span id='topic+spher.cor'></span>

<h3>Description</h3>

<p>Correlation between two spherical variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spher.cor(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Spherical-spherical+2B20correlation_+3A_x">x</code></td>
<td>

<p>A spherical variable. A matrix with thre columns, each row is a unit vector.
</p>
</td></tr>
<tr><td><code id="Spherical-spherical+2B20correlation_+3A_y">y</code></td>
<td>

<p>A spherical variable. A matrix with thre columns, each row is a unit vector.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A very similar to the classical correlation is calcualted. In addition, a hypothesis test for no correlation is performed. Note, that this is a squared correlation actually, so negative values will never be returned.
</p>


<h3>Value</h3>

<p>A vector including:
</p>
<table>
<tr><td><code>R-squared</code></td>
<td>

<p>The value of the squared correlation.
</p>
</td></tr>
<tr><td><code>p-value</code></td>
<td>

<p>The p-value of the no correlation hypothesis testing.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Kanti V. Mardia and Peter E. Jupp. Directional statistics, pg. 254&ndash;255.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spher.reg">spher.reg</a>, <a href="#topic+vmf.mle">vmf.mle</a>, <a href="#topic+circ.cor1">circ.cor1</a>, <a href="#topic+circ.cor2">circ.cor2</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvmf(100, rnorm(3), 10)
y &lt;- rvmf(100, rnorm(3), 10)
spher.cor(x, y)
</code></pre>

<hr>
<h2 id='Spherical-spherical+20regression'>
Spherical-Spherical regression
</h2><span id='topic+spher.reg'></span>

<h3>Description</h3>

<p>It performs regression when both the dependent and independent variables are spherical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spher.reg(y, x, rads = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Spherical-spherical+2B20regression_+3A_y">y</code></td>
<td>

<p>The dependent variable; a matrix with either two columns, latitude and longitude, either in radians or in degrees. Alternatively it is a matrix with three columns, unit vectors.
</p>
</td></tr>
<tr><td><code id="Spherical-spherical+2B20regression_+3A_x">x</code></td>
<td>

<p>The dependent variable; a matrix with either two columns, latitude and longitude, either in radians or in degrees. Alternatively it is a matrix with three columns, unit vectors. The two matrices must agree in the scale and dimensions.
</p>
</td></tr>
<tr><td><code id="Spherical-spherical+2B20regression_+3A_rads">rads</code></td>
<td>

<p>If the data are expressed in latitude and longitude then it matter to know if they are in radians or degrees. If they are in radians, then this should be TRUE and FALSE otherwise. If the previous argument, euclidean, is TRUE, this one does not matter what its value is.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spherical regression as proposed by Chang (1986) is implemented. If the estimated rotation matrix has a determinant equal to -1, singualr value decomposition is performed and the last unit vector of the second matrix is multiplied by -1.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>A</code></td>
<td>

<p>The estimated rotation matrix.
</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>

<p>The fitted values in Euclidean coordinates (unit vectors).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Ted Chang (1986). Spherical Regression. Annals of Statistics, 14(3): 907&ndash;924.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spher.cor">spher.cor</a>, <a href="#topic+spml.reg">spml.reg</a>, <a href="#topic+circ.cor1">circ.cor1</a>, <a href="#topic+circ.cor2">circ.cor2</a>, <a href="#topic+sphereplot">sphereplot</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mx &lt;- rnorm(3)
mx &lt;- mx/sqrt( sum(mx^2) )
my &lt;- rnorm(3)
my &lt;- my/sqrt( sum(my^2) )
x &lt;- rvmf(100, mx, 15)
A &lt;- rotation(mx, my)
y &lt;- x %*% t(A)
mod &lt;- spher.reg(y, x)
A
mod$A ## exact match, no noise
y &lt;- x %*% t(A)
y &lt;- y + rvmf(100, colMeans(y), 40)
mod &lt;- spher.reg(y, x)
A
mod$A ## noise added, more relistic example
</code></pre>

<hr>
<h2 id='Summary+20statistics+20for+20circular+20data'>
Summary statistics for circular data
</h2><span id='topic+circ.summary'></span>

<h3>Description</h3>

<p>It produces a few summary measures for circular data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circ.summary(u, rads = FALSE, fast = FALSE, tol = 1e-07, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Summary+2B20statistics+2B20for+2B20circular+2B20data_+3A_u">u</code></td>
<td>

<p>A vector with circular data.
</p>
</td></tr>
<tr><td><code id="Summary+2B20statistics+2B20for+2B20circular+2B20data_+3A_rads">rads</code></td>
<td>

<p>If the data are in rads, then this should be TRUE, otherwise FALSE.
</p>
</td></tr>
<tr><td><code id="Summary+2B20statistics+2B20for+2B20circular+2B20data_+3A_fast">fast</code></td>
<td>

<p>A boolean variable to do a faster implementation.
</p>
</td></tr>
<tr><td><code id="Summary+2B20statistics+2B20for+2B20circular+2B20data_+3A_tol">tol</code></td>
<td>

<p>The tolerance level to stop the Newton-Raphson algorithm for finding kappa.
</p>
</td></tr>
<tr><td><code id="Summary+2B20statistics+2B20for+2B20circular+2B20data_+3A_plot">plot</code></td>
<td>

<p>If you want to see the data plotted on a cicrle make this TRUE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It returns the circular mean, mean resultant length, variance, standard deviation and concentration parameter. So, basically it returns the estimated values of the parameters of the von Mises distribution.
</p>


<h3>Value</h3>

<p>If fast = FALSE a list including all the following. If fast = TRUE less items are returned.
</p>
<table>
<tr><td><code>mesos</code></td>
<td>

<p>The circular mean direction.
</p>
</td></tr>
<tr><td><code>confint</code></td>
<td>

<p>The 95% confidence interval for the circular mean direction.
</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>

<p>The concentration parameter.
</p>
</td></tr>
<tr><td><code>MRL</code></td>
<td>

<p>The mean resultant length.
</p>
</td></tr>
<tr><td><code>circvariance</code></td>
<td>

<p>The circular variance.
</p>
</td></tr>
<tr><td><code>circstd</code></td>
<td>

<p>The circular standard deviation.
</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>The log-likelihood of the fitted von Mises distribution.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Mardia, K. V. and Jupp, P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spml.mle">spml.mle</a>, <a href="#topic+rvonmises">rvonmises</a>, <a href="#topic+vm.kde">vm.kde</a>, <a href="#topic+vmf.mle">vmf.mle</a>, <a href="#topic+group.vm">group.vm</a>, <a href="#topic+hcf.circaov">hcf.circaov</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvonmises(50, 2.5, 15, rads = TRUE)
circ.summary(x, rads = TRUE, plot = TRUE)
</code></pre>

<hr>
<h2 id='Summary+20statistics+20for+20grouped+20circular+20data'>
Summary statistics for grouped circular data
</h2><span id='topic+group.vm'></span>

<h3>Description</h3>

<p>It produces a few summary measures for grouped circular data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group.vm(group, fi, rads = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Summary+2B20statistics+2B20for+2B20grouped+2B20circular+2B20data_+3A_group">group</code></td>
<td>

<p>A matrix denoting the classes. Each row consists of two numbers, the lower and upper points of each class.
</p>
</td></tr>
<tr><td><code id="Summary+2B20statistics+2B20for+2B20grouped+2B20circular+2B20data_+3A_fi">fi</code></td>
<td>

<p>The frequency of each class of data.
</p>
</td></tr>
<tr><td><code id="Summary+2B20statistics+2B20for+2B20grouped+2B20circular+2B20data_+3A_rads">rads</code></td>
<td>

<p>If the data are in rads, then this should be TRUE, otherwise FALSE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It returns the circular mean, mean resultant length, variance, standard deviation and concentration parameter. So, basically it returns the estimated values of the parameters
of the von Mises distribution. The mena resultant length though is group corrected.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>mesos</code></td>
<td>

<p>The circular mean direction.
</p>
</td></tr>
<tr><td><code>confint</code></td>
<td>

<p>The 95% confidence interval for the circular mean direction.
</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>

<p>The concentration parameter.
</p>
</td></tr>
<tr><td><code>MRL</code></td>
<td>

<p>The mean resultant length.
</p>
</td></tr>
<tr><td><code>circvariance</code></td>
<td>

<p>The circular variance.
</p>
</td></tr>
<tr><td><code>circstd</code></td>
<td>

<p>The circular standard deviation.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Pewsey Arthur, Markus Neuhauser and Graeme D. Ruxton (2013). Circular statistics in R. Oxford University Press.
</p>
<p>Mardia K. V. and Jupp P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+circ.summary">circ.summary</a>, <a href="#topic+rvonmises">rvonmises</a>, <a href="#topic+vm.kde">vm.kde</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvonmises(200, 3, 10)
a &lt;- circ.summary(x, rads = TRUE, plot = FALSE)
group &lt;- seq(min(x) - 0.1, max(x) + 0.1, length = 6)
y &lt;- cut(x, breaks = group, length = 6)
group &lt;- matrix( c( group[1], rep(group[2:5], each = 2), group[6]), ncol = 2, byrow = TRUE)
fi &lt;- as.vector( table(y) )
b &lt;- group.vm(group, fi, rads = TRUE)
a
b
</code></pre>

<hr>
<h2 id='Test+20for+20a+20given+20mean+20direction'>
Test for a given mean direction
</h2><span id='topic+meandir.test'></span>

<h3>Description</h3>

<p>A log-likelihood ratio test for testing whether the sample mena direction is equal to some predefined one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meandir.test(x, mu, B = 999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Test+2B20for+2B20a+2B20given+2B20mean+2B20direction_+3A_x">x</code></td>
<td>

<p>A matrix with the data, unit vectors.
</p>
</td></tr>
<tr><td><code id="Test+2B20for+2B20a+2B20given+2B20mean+2B20direction_+3A_mu">mu</code></td>
<td>

<p>A unit vector with the hypothesized mean direction.
</p>
</td></tr>
<tr><td><code id="Test+2B20for+2B20a+2B20given+2B20mean+2B20direction_+3A_b">B</code></td>
<td>

<p>A number either 1, so no bootstrap calibration is performed or more than 1, so bootstrap calibration is performed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The log-likelihood ratio test is employed.
</p>


<h3>Value</h3>

<p>This is an &quot;htest&quot;class object. Thus it returns a list including:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>

<p>The test statistic value.
</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>

<p>The degrees of freedom of the test. If bootstrap was employed this is &quot;NA&quot;.
</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>

<p>The p-value of the test.
</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>

<p>A character with the alternative hypothesis.
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>A character with the test used.
</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>

<p>A character vector with two elements.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Mardia, K. V. and Jupp, P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vmf.mle">vmf.mle</a>, <a href="#topic+kent.mle">kent.mle</a>, <a href="#topic+rayleigh">rayleigh</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- rnorm(5)
mu &lt;- mu / sqrt( sum(mu^2) )
x &lt;- rvmf(100, mu, 10)
meandir.test(x, mu, 1)
meandir.test(x, mu, 499)
</code></pre>

<hr>
<h2 id='Test+20for+20equality+20of+20concentration+20parameters+20for+20spherical+20data'>
Test for equality of concentration parameters for spherical data
</h2><span id='topic+spherconc.test'></span>

<h3>Description</h3>

<p>This tests the equality of concentration parameters for spherical data only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spherconc.test(x, ina)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Test+2B20for+2B20equality+2B20of+2B20concentration+2B20parameters+2B20for+2B20spherical+2B20data_+3A_x">x</code></td>
<td>

<p>A matrix with the data in Euclidean coordinates, i.e. unit vectors
</p>
</td></tr>
<tr><td><code id="Test+2B20for+2B20equality+2B20of+2B20concentration+2B20parameters+2B20for+2B20spherical+2B20data_+3A_ina">ina</code></td>
<td>

<p>A variable indicating the groupings of the observations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test is designed for spherical data only.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>mess</code></td>
<td>

<p>A message stating the value of the mean resultant and which test statistic was used, U1, U2 or U3.
</p>
</td></tr>
<tr><td><code>res</code></td>
<td>

<p>A vector containing the test statistic and its p-value.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Kanti V. Mardia and Peter E. Jupp. Directional statistics, pg. 226&ndash;227.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+het.aov">het.aov</a>, <a href="#topic+lr.aov">lr.aov</a>, <a href="#topic+embed.aov">embed.aov</a>, <a href="#topic+hcf.aov">hcf.aov</a>, <a href="#topic+conc.test">conc.test</a>, <a href="#topic+sphereplot">sphereplot</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvmf(100, rnorm(3), 15)
ina &lt;- rep(1:4, each = 25)
spherconc.test(x, ina)
</code></pre>

<hr>
<h2 id='Test+20of+20equality+20of+20the+20concentration+20parameters+20for+20circular+20data'>
A test for testing the equality of the concentration parameter among g samples, where g &gt;= 2 for ciruclar data
</h2><span id='topic+conc.test'></span>

<h3>Description</h3>

<p>A test for testing the equality of the concentration parameter among g samples, where g &gt;= 2 for ciruclar data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conc.test(u, ina, rads = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Test+2B20of+2B20equality+2B20of+2B20the+2B20concentration+2B20parameters+2B20for+2B20circular+2B20data_+3A_u">u</code></td>
<td>

<p>A numeric vector containing the values of all samples.
</p>
</td></tr>
<tr><td><code id="Test+2B20of+2B20equality+2B20of+2B20the+2B20concentration+2B20parameters+2B20for+2B20circular+2B20data_+3A_ina">ina</code></td>
<td>

<p>A numerical variable or factor indicating the groups of each value.
</p>
</td></tr>
<tr><td><code id="Test+2B20of+2B20equality+2B20of+2B20the+2B20concentration+2B20parameters+2B20for+2B20circular+2B20data_+3A_rads">rads</code></td>
<td>

<p>If the data are in radians this should be TRUE and FALSE otherwise.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This test works for circular data.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>mess</code></td>
<td>

<p>A message informing the use of the test statistic used.
</p>
</td></tr>
<tr><td><code>res</code></td>
<td>

<p>A numeric vector containing the value of the test statistic and its associated p-value.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Mardia, K. V. and Jupp, P. E. (2000). Directional statistics. Chicester: John Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+embed.circaov">embed.circaov</a>, <a href="#topic+hcf.circaov">hcf.circaov</a>, <a href="#topic+lr.circaov">lr.circaov</a>, <a href="#topic+het.circaov">het.circaov</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvonmises(100, 2.4, 15)
ina &lt;- rep(1:4,each = 25)
conc.test(x, ina, rads = TRUE)
</code></pre>

<hr>
<h2 id='The+20k-nearest+20neighbours+20using+20the+20cosinus+20distance'>
The k-nearest neighbours using the cosinus distance
</h2><span id='topic+cosnn'></span>

<h3>Description</h3>

<p>The k-nearest neighbours using the cosinus distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cosnn(xnew, x, k = 5, index = FALSE, rann = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="The+2B20k-nearest+2B20neighbours+2B20using+2B20the+2B20cosinus+2B20distance_+3A_xnew">xnew</code></td>
<td>

<p>The new data whose k-nearest neighbours are to be found.
</p>
</td></tr>
<tr><td><code id="The+2B20k-nearest+2B20neighbours+2B20using+2B20the+2B20cosinus+2B20distance_+3A_x">x</code></td>
<td>

<p>The data, a numeric matrix with unit vectors.
</p>
</td></tr>
<tr><td><code id="The+2B20k-nearest+2B20neighbours+2B20using+2B20the+2B20cosinus+2B20distance_+3A_k">k</code></td>
<td>

<p>The number of nearest neighbours, set to 5 by default. It can also be a vector with many values.
</p>
</td></tr>
<tr><td><code id="The+2B20k-nearest+2B20neighbours+2B20using+2B20the+2B20cosinus+2B20distance_+3A_index">index</code></td>
<td>

<p>If you want the indices of the closest observations set this equal to TRUE.
</p>
</td></tr>
<tr><td><code id="The+2B20k-nearest+2B20neighbours+2B20using+2B20the+2B20cosinus+2B20distance_+3A_rann">rann</code></td>
<td>

<p>If you have large scale datasets and want a faster k-NN search, you can use kd-trees implemented in the R package &quot;RANN&quot;. In this case you must set this argument equal to TRUE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The shortest distances or the indices of the k-nearest neighbours using the cosinus distance are returned.</p>


<h3>Value</h3>

<p>A matrix with the shortest distance of each xnew from x, if index is FALSE, or the indices of the nearest neighbours of each xnew from x, if index is TRUE.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Tsagris M. and Alenazi A. (2019). Comparison of discriminant analysis methods on the sphere. 
Communications in Statistics: Case Studies, Data Analysis and Applications, 5(4): 467&ndash;491.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dirknn">dirknn</a>, <a href="#topic+dirknn.tune">dirknn.tune</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xnew &lt;- rvmf(10, rnorm(3), 5)
x &lt;- rvmf(50, rnorm(3), 5)
a &lt;- cosnn(xnew, x, k = 5)
b &lt;- cosnn(xnew, x, k = 5, index = TRUE)
</code></pre>

<hr>
<h2 id='Transform+20unit+20vectors+20to+20angular+20data'>
Transform unit vectors to angular data
</h2><span id='topic+etoa'></span>

<h3>Description</h3>

<p>Transform unit vectors to angular data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>etoa(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Transform+2B20unit+2B20vectors+2B20to+2B20angular+2B20data_+3A_x">x</code></td>
<td>

<p>A numerical matrix with directional data, i.e. unit verctors.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>from the Euclidean coordinates the data are mapped to angles, expressed in rads.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>mu</code></td>
<td>

<p>A matrix with angles. The number of columns is one less than that of the original matrix.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>https://en.wikipedia.org/wiki/N-sphere#Spherical_coordinates
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+vmnb.pred">vmnb.pred</a> </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvmf(10, rnorm(3), 5)
y &lt;- etoa(x)
</code></pre>

<hr>
<h2 id='Tuning+20of+20the+20bandwidth+20parameter+20in+20the+20von+20Mises+20kernel'>
Tuning of the bandwidth parameter in the von Mises kernel for circular data
</h2><span id='topic+vmkde.tune'></span>

<h3>Description</h3>

<p>Tuning of the bandwidth parameter in the von Mises kernel for circular data. Cross validation is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vmkde.tune(u, low = 0.1, up = 1, rads = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tuning+2B20of+2B20the+2B20bandwidth+2B20parameter+2B20in+2B20the+2B20von+2B20Mises+2B20kernel_+3A_u">u</code></td>
<td>

<p>The data, a numerical vector.
</p>
</td></tr>
<tr><td><code id="Tuning+2B20of+2B20the+2B20bandwidth+2B20parameter+2B20in+2B20the+2B20von+2B20Mises+2B20kernel_+3A_low">low</code></td>
<td>

<p>The lower value of h to search.
</p>
</td></tr>
<tr><td><code id="Tuning+2B20of+2B20the+2B20bandwidth+2B20parameter+2B20in+2B20the+2B20von+2B20Mises+2B20kernel_+3A_up">up</code></td>
<td>

<p>The lower value of h to search.
</p>
</td></tr>
<tr><td><code id="Tuning+2B20of+2B20the+2B20bandwidth+2B20parameter+2B20in+2B20the+2B20von+2B20Mises+2B20kernel_+3A_rads">rads</code></td>
<td>

<p>If the data are in radians this should be TRUE and FALSE otherwise.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tuning of the bandwidth parameter in the von Mises kernel for circula data via cross validation. The procedure is fast because an optimiser is used.
</p>


<h3>Value</h3>

<p>A vector including two elements:
</p>
<table>
<tr><td><code>Optimal h</code></td>
<td>

<p>The best H found.
</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>

<p>The value of the maximised pseudo-likelihood.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Taylor C.C. (2008). Automatic bandwidth selection for circular density estimation. 
Computational Statistics &amp; Data Analysis, 52(7), 3493&ndash;3500.
</p>
<p>Wand M.P. and Jones M.C. (1994). Kernel smoothing. CrC Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vm.kde">vm.kde</a>, <a href="#topic+vmfkde.tune">vmfkde.tune</a>, <a href="#topic+vmf.kde">vmf.kde</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- rvonmises(100, 2.4, 10, rads = TRUE)
vmkde.tune(u)
</code></pre>

<hr>
<h2 id='Tuning+20of+20the+20bandwidth+20parameter+20in+20the+20von+20Mises-Fisher+20kernel'>
Tuning of the bandwidth parameter in the von Mises-Fisher kernel for (hyper-)spherical data
</h2><span id='topic+vmfkde.tune'></span>

<h3>Description</h3>

<p>Tuning of the bandwidth parameter in the von Mises-Fisher kernel for (hyper-)spherical data whit cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vmfkde.tune(x, low = 0.1, up = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tuning+2B20of+2B20the+2B20bandwidth+2B20parameter+2B20in+2B20the+2B20von+2B20Mises-Fisher+2B20kernel_+3A_x">x</code></td>
<td>

<p>A matrix with the data in Euclidean cordinates, i.e. unit vectors.
</p>
</td></tr>
<tr><td><code id="Tuning+2B20of+2B20the+2B20bandwidth+2B20parameter+2B20in+2B20the+2B20von+2B20Mises-Fisher+2B20kernel_+3A_low">low</code></td>
<td>

<p>The lower value of the bandwdith to search.
</p>
</td></tr>
<tr><td><code id="Tuning+2B20of+2B20the+2B20bandwidth+2B20parameter+2B20in+2B20the+2B20von+2B20Mises-Fisher+2B20kernel_+3A_up">up</code></td>
<td>

<p>The upper value of the bandwdith to search.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fast tuning of the bandwidth parameter in the von Mises-Fisher kernel for (hyper-)spherical data via cross validation.
</p>


<h3>Value</h3>

<p>A vector including two elements:
</p>
<table>
<tr><td><code>Optimal h</code></td>
<td>

<p>The best H found.
</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>

<p>The value of the maximised pseudo-likelihood.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Garcia P.E. (2013). Exact risk improvement of bandwidth selectors for kernel density estimation with directional data. Electronic Journal of Statistics, 7, 1655&ndash;1685.
</p>
<p>Wand M.P. and Jones M.C. (1994). Kernel smoothing. Crc Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vmf.kde">vmf.kde</a>,<a href="#topic+vmf.kerncontour">vmf.kerncontour</a>, <a href="#topic+vm.kde">vm.kde</a>, <a href="#topic+vmkde.tune">vmkde.tune</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvmf(100, rnorm(3), 15)
vmfkde.tune(x)
</code></pre>

<hr>
<h2 id='Tuning+20of+20the+20k-NN+20algorithm+20using+20the+20arc+20cosinus+20distance'>
k-NN algorithm using the arc cosinus distance. Tuning the k neigbours
</h2><span id='topic+dirknn.tune'></span>

<h3>Description</h3>

<p>It estimates the percentage of correct classification via an m-fold cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dirknn.tune(ina, x, k = 2:10, mesos = TRUE, nfolds = 10, folds = NULL,
parallel = FALSE, stratified = TRUE, seed = NULL, rann = FALSE, graph = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tuning+2B20of+2B20the+2B20k-NN+2B20algorithm+2B20using+2B20the+2B20arc+2B20cosinus+2B20distance_+3A_x">x</code></td>
<td>

<p>The data, a numeric matrix with unit vectors.
</p>
</td></tr>
<tr><td><code id="Tuning+2B20of+2B20the+2B20k-NN+2B20algorithm+2B20using+2B20the+2B20arc+2B20cosinus+2B20distance_+3A_ina">ina</code></td>
<td>

<p>A variable indicating the groups of the data x.
</p>
</td></tr>
<tr><td><code id="Tuning+2B20of+2B20the+2B20k-NN+2B20algorithm+2B20using+2B20the+2B20arc+2B20cosinus+2B20distance_+3A_nfolds">nfolds</code></td>
<td>

<p>How many folds to create?
</p>
</td></tr>
<tr><td><code id="Tuning+2B20of+2B20the+2B20k-NN+2B20algorithm+2B20using+2B20the+2B20arc+2B20cosinus+2B20distance_+3A_k">k</code></td>
<td>

<p>A vector with the number of nearest neighbours to consider.
</p>
</td></tr>
<tr><td><code id="Tuning+2B20of+2B20the+2B20k-NN+2B20algorithm+2B20using+2B20the+2B20arc+2B20cosinus+2B20distance_+3A_mesos">mesos</code></td>
<td>

<p>A boolean variable used only in the case of the non standard algorithm (type=&quot;NS&quot;). Should the average of the distances be calculated (TRUE) or not (FALSE)? If it is FALSE, the harmonic mean is calculated.
</p>
</td></tr>
<tr><td><code id="Tuning+2B20of+2B20the+2B20k-NN+2B20algorithm+2B20using+2B20the+2B20arc+2B20cosinus+2B20distance_+3A_folds">folds</code></td>
<td>

<p>Do you already have a list with the folds? If not, leave this NULL.
</p>
</td></tr>
<tr><td><code id="Tuning+2B20of+2B20the+2B20k-NN+2B20algorithm+2B20using+2B20the+2B20arc+2B20cosinus+2B20distance_+3A_parallel">parallel</code></td>
<td>

<p>If you want the standard -NN algorithm to take place in parallel set this equal to TRUE.
</p>
</td></tr>
<tr><td><code id="Tuning+2B20of+2B20the+2B20k-NN+2B20algorithm+2B20using+2B20the+2B20arc+2B20cosinus+2B20distance_+3A_stratified">stratified</code></td>
<td>

<p>Should the folds be created in a stratified way? i.e. keeping the distribution of the groups similar through all folds?
</p>
</td></tr>
<tr><td><code id="Tuning+2B20of+2B20the+2B20k-NN+2B20algorithm+2B20using+2B20the+2B20arc+2B20cosinus+2B20distance_+3A_seed">seed</code></td>
<td>

<p>If seed is TRUE, the results will always be the same.
</p>
</td></tr>
<tr><td><code id="Tuning+2B20of+2B20the+2B20k-NN+2B20algorithm+2B20using+2B20the+2B20arc+2B20cosinus+2B20distance_+3A_rann">rann</code></td>
<td>

<p>If you have large scale datasets and want a faster k-NN search, you can use kd-trees implemented in the R package &quot;RANN&quot;. In this case you must set this argument equal to TRUE.
</p>
</td></tr>
<tr><td><code id="Tuning+2B20of+2B20the+2B20k-NN+2B20algorithm+2B20using+2B20the+2B20arc+2B20cosinus+2B20distance_+3A_graph">graph</code></td>
<td>

<p>If this is TRUE a graph with the results will appear.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard algorithm is to keep the k nearest observations and see the groups of these observations. The new observation is allocated to the most frequent seen group. The non standard algorithm is to calculate the classical mean or the harmonic mean of the k nearest observations for each group. The new observation is allocated to the group with the smallest mean distance.
</p>
<p>We have made an eficient (not very much efficient though) memory allocation. Even if you have hundreds of thousands of observations, the computer will not clush, it will only take longer. Instead of calculate the distance matrix once in the beginning we calcualte the distances of the out-of-sample observations from the rest. If we calculated the distance matrix in the beginning, once, the resulting matrix could have dimensions thousands by thousands. This would not fit into the memory. If you have a few hundres of observations, the runtime is about the same (maybe less, maybe more) as calculating the distance matrix in the first place.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>per</code></td>
<td>

<p>The average percent of correct classification across the neighbours.
</p>
</td></tr>
<tr><td><code>percent</code></td>
<td>

<p>The estimated (optimal) percent of correct classification.
</p>
</td></tr>
<tr><td><code>runtime</code></td>
<td>

<p>The run time of the algorithm. A numeric vector. The first element is the user time, the second element is the system time and the third element is the elapsed time.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>References</h3>

<p>Tsagris M. and Alenazi A. (2019). Comparison of discriminant analysis methods on the sphere. Communications in Statistics: Case Studies, Data Analysis and Applications, 5(4), 467&ndash;491.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dirknn">dirknn</a>, <a href="#topic+vmf.da">vmf.da</a>, <a href="#topic+mixvmf.mle">mixvmf.mle</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k &lt;- runif(4, 4, 20)
prob &lt;- c(0.2, 0.4, 0.3, 0.1)
mu &lt;- matrix(rnorm(16), ncol = 4)
mu &lt;- mu / sqrt( rowSums(mu^2) )
da &lt;- rmixvmf(200, prob, mu, k)
x &lt;- da$x
ina &lt;- da$id
dirknn.tune(ina, x, k = 2:6, nfolds = 5, mesos = TRUE)
dirknn.tune(ina, x, k = 2:6, nfolds = 10, mesos = TRUE)
</code></pre>

<hr>
<h2 id='Tuning+20of+20the+20k-NN+20regression'>
Tuning of the k-NN regression with Euclidean or (hyper-)spherical response and or predictor variables
</h2><span id='topic+knnreg.tune'></span>

<h3>Description</h3>

<p>Tuning of the k-NN regression with Euclidean or (hyper-)spherical response and or predictor variables. It estimates the percentage of correct classification via an m-fold cross valdiation. The bias is estimated as well using the algorithm suggested by Tibshirani and Tibshirani (2009) and is subtracted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knnreg.tune(y, x, nfolds = 10, A = 10, ncores = 1, res = "eucl",
estim = "arithmetic", folds = NULL, seed = NULL, graph = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tuning+2B20of+2B20the+2B20k-NN+2B20regression_+3A_y">y</code></td>
<td>

<p>The currently available data, the response variables values. A matrix with either euclidean (univariate or multivariate) or (hyper-)spherical data. If you have a circular response, say u, transform it to a unit vector via (cos(u), sin(u)).
</p>
</td></tr>
<tr><td><code id="Tuning+2B20of+2B20the+2B20k-NN+2B20regression_+3A_x">x</code></td>
<td>

<p>The currently available data, the predictor variables values. A matrix with either euclidean (univariate or multivariate) or (hyper-)spherical data. If you have a circular response, say u, transform it to a unit vector via (cos(u), sin(u)).
</p>
</td></tr>
<tr><td><code id="Tuning+2B20of+2B20the+2B20k-NN+2B20regression_+3A_nfolds">nfolds</code></td>
<td>

<p>How many folds to create?
</p>
</td></tr>
<tr><td><code id="Tuning+2B20of+2B20the+2B20k-NN+2B20regression_+3A_a">A</code></td>
<td>

<p>The maximum number of nearest neighbours, set to 10 by default, starting from the 2nd nearest neighbor.
</p>
</td></tr>
<tr><td><code id="Tuning+2B20of+2B20the+2B20k-NN+2B20regression_+3A_ncores">ncores</code></td>
<td>

<p>How many cores to use. This is taken into account only when the predictor variables are spherical.
</p>
</td></tr>
<tr><td><code id="Tuning+2B20of+2B20the+2B20k-NN+2B20regression_+3A_res">res</code></td>
<td>

<p>The type of the response variable. If it is Euclidean, set this argument equal to &quot;res&quot;.  If it is a unit vector set it to res=&quot;spher&quot;.
</p>
</td></tr>
<tr><td><code id="Tuning+2B20of+2B20the+2B20k-NN+2B20regression_+3A_estim">estim</code></td>
<td>

<p>Once the k observations whith the smallest distance are discovered, what should the prediction be? The arithmetic average of the corresponding y values be used estim=&quot;arithmetic&quot; or their harmonic average estim=&quot;harmonic&quot;.
</p>
</td></tr>
<tr><td><code id="Tuning+2B20of+2B20the+2B20k-NN+2B20regression_+3A_folds">folds</code></td>
<td>

<p>Do you already have a list with the folds? If not, leave this NULL.
</p>
</td></tr>
<tr><td><code id="Tuning+2B20of+2B20the+2B20k-NN+2B20regression_+3A_seed">seed</code></td>
<td>

<p>You can specify your own seed number here or leave it NULL.
</p>
</td></tr>
<tr><td><code id="Tuning+2B20of+2B20the+2B20k-NN+2B20regression_+3A_graph">graph</code></td>
<td>

<p>If this is TRUE a graph with the results will appear.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tuning of the k-NN regression with Euclidean or (hyper-)spherical response and or predictor variables. It estimates the percentage of correct classification via an m-fold cross valdiation. The bias is estimated as well using the algorithm suggested by Tibshirani and Tibshirani (2009) and is subtracted. The sum of squares of prediction is used in the case of Euclidean responses. In the case of spherical responses the <code class="reqn">\sum_i \hat{y}_i^Ty_i</code> is calculated.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>crit</code></td>
<td>

<p>The value of the criterion to minimise/maximise for all values of the nearest neighbours.
</p>
</td></tr>
<tr><td><code>best_k</code></td>
<td>

<p>The best value of the nearest neighbours.
</p>
</td></tr>
<tr><td><code>performance</code></td>
<td>

<p>The bias corrected optimal value of the criterion, along wit the estimated bias. For the case of Euclidean reponse this will be higher than the crit and for the case or spherical responses it will be lower than crit.
</p>
</td></tr>
<tr><td><code>runtime</code></td>
<td>

<p>The run time of the algorithm. A numeric vector. The first element is the user time, the second element is the system time and the third element is the elapsed time.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+knn.reg">knn.reg</a>, <a href="#topic+spher.reg">spher.reg</a>, <a href="#topic+dirknn.tune">dirknn.tune</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- iris[, 1]
x &lt;- iris[, 2:4]
x &lt;- x/ sqrt( rowSums(x^2) )  ## Euclidean response and spherical predictors
knnreg.tune(y, x, A = 5, res = "eucl", estim = "arithmetic")

y &lt;- iris[, 1:3]
y &lt;- y/ sqrt( rowSums(y^2) )  ## Spherical response and Euclidean predictor
x &lt;- iris[, 2]
knnreg.tune(y, x, A = 5, res = "spher", estim = "arithmetic")
</code></pre>

<hr>
<h2 id='Uniformity+20test+20for+20circular+20data'>
Uniformity tests for circular data.
</h2><span id='topic+kuiper'></span><span id='topic+watson'></span>

<h3>Description</h3>

<p>Hypothesis tests of uniformity for circular data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kuiper(u, rads = FALSE, R = 1)
watson(u, rads = FALSE, R = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Uniformity+2B20test+2B20for+2B20circular+2B20data_+3A_u">u</code></td>
<td>

<p>A numeric vector containing the circular data, which cna be expressed in degrees or radians.
</p>
</td></tr>
<tr><td><code id="Uniformity+2B20test+2B20for+2B20circular+2B20data_+3A_rads">rads</code></td>
<td>

<p>A boolean variable. If the data are in radians, put this TRUE. If the data are expressed in degrees make this FALSE.
</p>
</td></tr>
<tr><td><code id="Uniformity+2B20test+2B20for+2B20circular+2B20data_+3A_r">R</code></td>
<td>

<p>If R = 1 the asymptotic p-value will be calcualted. If R is greater than 1 the bootstrap p-value is returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The high concentration (hcf.circaov), log-likelihood ratio (lr.circaov), embedding approach (embed.circaov) or the non equal concentration parameters approach (het.circaov) is used.
</p>


<h3>Value</h3>

<p>This is an &quot;htest&quot;class object. Thus it returns a list including:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>

<p>The test statistic value.
</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>

<p>This is usually the degrees of freedom of the test, but here this is &quot;NA&quot; because the asymptotic based p-value is computed in a different way or because bootstrap was employed.
</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>

<p>The p-value of the test.
</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>

<p>A character with the alternative hypothesis.
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>A character with the test used.
</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>

<p>A character vector with two elements.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, pg. 153&ndash;55 (Kuiper's test) and pg. 156&ndash;157 (Watson's test).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rayleigh">rayleigh</a>, <a href="#topic+ptest">ptest</a>, <a href="#topic+vmf.mle">vmf.mle</a>, <a href="#topic+rvonmises">rvonmises</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvonmises(n = 40, m = 2, k = 10)
kuiper(x, rads = TRUE)
watson(x, rads = TRUE)
x &lt;- rvonmises(40, m = 2, k = 0)
kuiper(x, rads = TRUE)
watson(x, rads = TRUE)
</code></pre>

<hr>
<h2 id='von+20Mises+20kernel+20density+20estimation'>
Kernel density estimation of circular data with a von Mises kernel
</h2><span id='topic+vm.kde'></span>

<h3>Description</h3>

<p>Kernel density estimation of circular data with a von Mises kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vm.kde(u, h, thumb = "none", rads = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="von+2B20Mises+2B20kernel+2B20density+2B20estimation_+3A_u">u</code></td>
<td>

<p>A numeric vector containing the data.
</p>
</td></tr>
<tr><td><code id="von+2B20Mises+2B20kernel+2B20density+2B20estimation_+3A_h">h</code></td>
<td>

<p>The bandwidth.
</p>
</td></tr>
<tr><td><code id="von+2B20Mises+2B20kernel+2B20density+2B20estimation_+3A_thumb">thumb</code></td>
<td>

<p>It can be either &quot;none&quot;, so the bandwidth the user has set will be used, &quot;tay&quot; for the method of Taylor (2008) or &quot;rot&quot; for the method of Garcia-Portugues (2013).
</p>
</td></tr>
<tr><td><code id="von+2B20Mises+2B20kernel+2B20density+2B20estimation_+3A_rads">rads</code></td>
<td>

<p>If the data are in radians, this should be TRUE and FALSE otherwise.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user has the option to use a bandwidth he/she has found in some way (cross-validation) or estimate it as Taylor (2008) or Garcia-Portugues (2013).
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>h</code></td>
<td>

<p>The bandwidth. If the user chose one of &quot;tay&quot; or &quot;rot&quot; the estimated bandwidth will be returned.
</p>
</td></tr>
<tr><td><code>f</code></td>
<td>

<p>The kernel density estimate at the observed points.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou&lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Taylor, C. C. (2008). Automatic bandwidth selection for circular density estimation. Computational Statistics &amp; Data Analysis, 52(7): 3493-3500.
</p>
<p>Garcia Portugues, E. (2013). Exact risk improvement of bandwidth selectors for kernel density estimation with directional data. Electronic Journal of Statistics, 7, 1655-1685.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vmkde.tune">vmkde.tune</a>, <a href="#topic+vmfkde.tune">vmfkde.tune</a>, <a href="#topic+vmf.kde">vmf.kde</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvonmises(100, 2.4, 10, rads = TRUE)
hist(x, freq = FALSE)
f1 &lt;- vm.kde(x, h = 0.1, thumb = "rot", rads = TRUE)$f
f2 &lt;- vm.kde(x, h = 0.1, thumb = "tay", rads = TRUE)$f
h &lt;- vmkde.tune(x)[1]
f3 &lt;- vm.kde(x, h = h, thumb = "none", rads = TRUE)$f
points(x, f1, col = 1)
points(x, f2, col = 2)
points(x, f3, col = 3)
</code></pre>

<hr>
<h2 id='von+20Mises-Fisher+20kernel+20density+20estimation+20for+20+28hyper-+29spherical+20data'>
Kernel density estimation for (hyper-)spherical data using a von Mises-Fisher kernel
</h2><span id='topic+vmf.kde'></span>

<h3>Description</h3>

<p>A von Mises-Fisher kernel is used for the non parametric density estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vmf.kde(x, h, thumb = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="von+2B20Mises-Fisher+2B20kernel+2B20density+2B20estimation+2B20for+2B20+2B28hyper-+2B29spherical+2B20data_+3A_x">x</code></td>
<td>

<p>A matrix with unit vectors, i.e. the data being expressed in Euclidean cordinates.
</p>
</td></tr>
<tr><td><code id="von+2B20Mises-Fisher+2B20kernel+2B20density+2B20estimation+2B20for+2B20+2B28hyper-+2B29spherical+2B20data_+3A_h">h</code></td>
<td>

<p>The bandwidth to be used.
</p>
</td></tr>
<tr><td><code id="von+2B20Mises-Fisher+2B20kernel+2B20density+2B20estimation+2B20for+2B20+2B28hyper-+2B29spherical+2B20data_+3A_thumb">thumb</code></td>
<td>

<p>If this is &quot;none&quot;, the given bandwidth is used. If it is &quot;rot&quot; the rule of thumb suggested by Garcia-Portugues (2013) is used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A von Mises-Fisher kernel is used for the non parametric density estimation.
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr><td><code>h</code></td>
<td>

<p>The bandwidth used.
</p>
</td></tr>
<tr><td><code>f</code></td>
<td>

<p>A vector with the kernel density estimate calculated for each of the data points.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a> and Giorgos Athineou &lt;gioathineou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Garcia Portugues, E. (2013). Exact risk improvement of bandwidth selectors for kernel density estimation with directional data. 
Electronic Journal of Statistics, 7, 1655&ndash;1685.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vmfkde.tune">vmfkde.tune</a>, <a href="#topic+vm.kde">vm.kde</a>, <a href="#topic+vmf.mle">vmf.mle</a>, <a href="#topic+vmkde.tune">vmkde.tune</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvmf(100, rnorm(5), 15)
h &lt;- vmfkde.tune(x)[1]
f1 &lt;- vmf.kde(x, h = h, thumb = "none")
f2 &lt;- vmf.kde(x, h = h, thumb = "rot")
f1$h  ;  f2$h
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
