<!DOCTYPE html><html><head><title>Help for package ape</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ape}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ape-package'>
<p>Analyses of Phylogenetics and Evolution</p></a></li>
<li><a href='#AAbin'><p>Amino Acid Sequences</p></a></li>
<li><a href='#ace'><p>Ancestral Character Estimation</p></a></li>
<li><a href='#add.scale.bar'><p>Add a Scale Bar to a Phylogeny Plot</p></a></li>
<li><a href='#additive'><p>Incomplete Distance Matrix Filling</p></a></li>
<li><a href='#alex'><p>Alignment Explorer With Multiple Devices</p></a></li>
<li><a href='#all.equal.DNAbin'><p>Compare DNA Sets</p></a></li>
<li><a href='#all.equal.phylo'><p>Global Comparison of two Phylogenies</p></a></li>
<li><a href='#alview'><p>Print DNA or AA Sequence Alignement</p></a></li>
<li><a href='#ape-internal'><p>Internal Ape Functions</p></a></li>
<li><a href='#apetools'><p>Tools to Explore Files</p></a></li>
<li><a href='#as.alignment'><p>Conversion Among DNA Sequence Internal Formats</p></a></li>
<li><a href='#as.bitsplits'><p>Split Frequencies and Conversion Among Split Classes</p></a></li>
<li><a href='#as.matching'><p>Conversion Between Phylo and Matching Objects</p></a></li>
<li><a href='#as.phylo'><p>Conversion Among Tree and Network Objects</p></a></li>
<li><a href='#as.phylo.formula'><p>Conversion from Taxonomy Variables to Phylogenetic Trees</p></a></li>
<li><a href='#axisPhylo'><p>Axis on Side of Phylogeny</p></a></li>
<li><a href='#balance'><p>Balance of a Dichotomous Phylogenetic Tree</p></a></li>
<li><a href='#base.freq'><p>Base frequencies from DNA Sequences</p></a></li>
<li><a href='#bd.ext'><p>Extended Version of the Birth-Death Models to Estimate Speciation</p>
and Extinction Rates</a></li>
<li><a href='#bd.time'><p>Time-Dependent Birth-Death Models</p></a></li>
<li><a href='#binaryPGLMM'><p>Phylogenetic Generalized Linear Mixed Model for Binary Data</p></a></li>
<li><a href='#bind.tree'><p>Binds Trees</p></a></li>
<li><a href='#BIONJ'>
<p>Tree Estimation Based on an Improved Version of the NJ Algorithm</p></a></li>
<li><a href='#bird.families'><p>Phylogeny of the Families of Birds From Sibley and Ahlquist</p></a></li>
<li><a href='#bird.orders'><p>Phylogeny of the Orders of Birds From Sibley and Ahlquist</p></a></li>
<li><a href='#birthdeath'><p>Estimation of Speciation and Extinction Rates With Birth-Death Models</p></a></li>
<li><a href='#boot.phylo'><p>Tree Bipartition and Bootstrapping Phylogenies</p></a></li>
<li><a href='#branching.times'><p>Branching Times of a Phylogenetic Tree</p></a></li>
<li><a href='#c.phylo'><p>Building Lists of Trees</p></a></li>
<li><a href='#CADM.global'><p> Congruence among distance matrices</p></a></li>
<li><a href='#carnivora'><p>Carnivora body sizes and life history traits</p></a></li>
<li><a href='#checkAlignment'><p>Check DNA Alignments</p></a></li>
<li><a href='#checkLabel'><p>Checking Labels</p></a></li>
<li><a href='#checkValidPhylo'><p>Check the Structure of a &quot;phylo&quot; Object</p></a></li>
<li><a href='#cherry'><p>Number of Cherries and Null Models of Trees</p></a></li>
<li><a href='#chiroptera'><p>Bat Phylogeny</p></a></li>
<li><a href='#chronoMPL'><p>Molecular Dating With Mean Path Lengths</p></a></li>
<li><a href='#chronopl'><p>Molecular Dating With Penalized Likelihood</p></a></li>
<li><a href='#chronos'><p>Molecular Dating by Penalised Likelihood and Maximum Likelihood</p></a></li>
<li><a href='#clustal'><p>Multiple Sequence Alignment with External Applications</p></a></li>
<li><a href='#coalescent.intervals'><p>Coalescent Intervals</p></a></li>
<li><a href='#collapse.singles'><p>Collapse Single Nodes</p></a></li>
<li><a href='#collapsed.intervals'><p>Collapsed Coalescent Intervals</p></a></li>
<li><a href='#compar.cheverud'><p>Cheverud's Comparative Method</p></a></li>
<li><a href='#compar.gee'><p>Comparative Analysis with GEEs</p></a></li>
<li><a href='#compar.lynch'><p>Lynch's Comparative Method</p></a></li>
<li><a href='#compar.ou'><p>Ornstein&ndash;Uhlenbeck Model for Continuous Characters</p></a></li>
<li><a href='#comparePhylo'><p>Compare Two &quot;phylo&quot; Objects</p></a></li>
<li><a href='#compute.brlen'><p>Branch Lengths Computation</p></a></li>
<li><a href='#compute.brtime'><p>Compute and Set Branching Times</p></a></li>
<li><a href='#consensus'><p>Concensus Trees</p></a></li>
<li><a href='#cophenetic.phylo'><p>Pairwise Distances from a Phylogenetic Tree</p></a></li>
<li><a href='#cophyloplot'><p>Plots two phylogenetic trees face to face with links between the tips.</p></a></li>
<li><a href='#corBlomberg'><p>Blomberg et al.'s Correlation Structure</p></a></li>
<li><a href='#corBrownian'><p>Brownian Correlation Structure</p></a></li>
<li><a href='#corClasses'><p>Phylogenetic Correlation Structures</p></a></li>
<li><a href='#corGrafen'><p>Grafen's (1989) Correlation Structure</p></a></li>
<li><a href='#corMartins'><p>Martins's (1997) Correlation Structure</p></a></li>
<li><a href='#corPagel'><p>Pagel's &ldquo;lambda&rdquo; Correlation Structure</p></a></li>
<li><a href='#corphylo'><p>Correlations among Multiple Traits with Phylogenetic Signal</p></a></li>
<li><a href='#correlogram.formula'><p>Phylogenetic Correlogram</p></a></li>
<li><a href='#data.nex'><p>NEXUS Data Example</p></a></li>
<li><a href='#dbd'><p>Probability Density Under Birth&ndash;Death Models</p></a></li>
<li><a href='#def'><p>Definition of Vectors for Plotting or Annotating</p></a></li>
<li><a href='#degree'><p>Vertex Degrees in Trees and Networks</p></a></li>
<li><a href='#del.gaps'><p>Delete Alignment Gaps in DNA or AA Sequences</p></a></li>
<li><a href='#delta.plot'><p>Delta Plots</p></a></li>
<li><a href='#dist.dna'><p>Pairwise Distances from DNA Sequences</p></a></li>
<li><a href='#dist.gene'><p>Pairwise Distances from Genetic Data</p></a></li>
<li><a href='#dist.topo'><p>Topological Distances Between Two Trees</p></a></li>
<li><a href='#diversi.gof'><p>Tests of Constant Diversification Rates</p></a></li>
<li><a href='#diversi.time'><p>Analysis of Diversification with Survival Models</p></a></li>
<li><a href='#diversity.contrast.test'><p>Diversity Contrast Test</p></a></li>
<li><a href='#DNAbin'><p>Manipulate DNA Sequences in Bit-Level Format</p></a></li>
<li><a href='#DNAbin2indel'><p>Recode Blocks of Indels</p></a></li>
<li><a href='#dnds'><p>dN/dS Ratio</p></a></li>
<li><a href='#drop.tip'><p>Remove Tips in a Phylogenetic Tree</p></a></li>
<li><a href='#edges'><p>Draw Additional Edges on a Plotted Tree</p></a></li>
<li><a href='#evonet'><p>Evolutionary Networks</p></a></li>
<li><a href='#ewLasso'>
<p>Incomplete distances and edge weights of unrooted topology</p></a></li>
<li><a href='#FastME'>
<p>Tree Estimation Based on the Minimum Evolution Algorithm</p></a></li>
<li><a href='#gammaStat'><p>Gamma-Statistic of Pybus and Harvey</p></a></li>
<li><a href='#getAnnotationsGenBank'><p>Read Annotations from GenBank</p></a></li>
<li><a href='#hivtree'><p>Phylogenetic Tree of 193 HIV-1 Sequences</p></a></li>
<li><a href='#howmanytrees'><p>Calculate Numbers of Phylogenetic Trees</p></a></li>
<li><a href='#identify.phylo'><p>Graphical Identification of Nodes and Tips</p></a></li>
<li><a href='#image.DNAbin'><p>Plot of DNA Sequence Alignement</p></a></li>
<li><a href='#Initialize.corPhyl'><p>Initialize a &lsquo;corPhyl&rsquo; Structure Object</p></a></li>
<li><a href='#is.binary'><p>Test for Binary Tree</p></a></li>
<li><a href='#is.compatible'><p>Check Compatibility of Splits</p></a></li>
<li><a href='#is.monophyletic'>
<p>Is Group Monophyletic</p></a></li>
<li><a href='#is.ultrametric'><p>Test if a Tree is Ultrametric</p></a></li>
<li><a href='#kronoviz'><p>Plot Multiple Chronograms on the Same Scale</p></a></li>
<li><a href='#label2table'><p>Label Management</p></a></li>
<li><a href='#ladderize'><p>Ladderize a Tree</p></a></li>
<li><a href='#latag2n'><p>Leading and Trailing Alignment Gaps to N</p></a></li>
<li><a href='#lmorigin'><p> Multiple regression through the origin</p></a></li>
<li><a href='#LTT'><p>Theoretical Lineage-Through Time Plots</p></a></li>
<li><a href='#ltt.plot'><p>Lineages Through Time Plot</p></a></li>
<li><a href='#makeLabel'><p>Label Management</p></a></li>
<li><a href='#makeNodeLabel'><p>Makes Node Labels</p></a></li>
<li><a href='#mantel.test'><p>Mantel Test for Similarity of Two Matrices</p></a></li>
<li><a href='#mat3'><p>Three Matrices</p></a></li>
<li><a href='#mat5M3ID'><p>Five Trees</p></a></li>
<li><a href='#mat5Mrand'><p>Five Independent Trees</p></a></li>
<li><a href='#matexpo'><p>Matrix Exponential</p></a></li>
<li><a href='#mcconwaysims.test'><p>McConway-Sims Test of Homogeneous Diversification</p></a></li>
<li><a href='#mcmc.popsize'><p>Reversible Jump MCMC to Infer Demographic History</p></a></li>
<li><a href='#mixedFontLabel'><p>Mixed Font Labels for Plotting</p></a></li>
<li><a href='#Moran.I'><p>Moran's I Autocorrelation Index</p></a></li>
<li><a href='#MPR'><p>Most Parsimonious Reconstruction</p></a></li>
<li><a href='#mrca'><p>Find Most Recent Common Ancestors Between Pairs</p></a></li>
<li><a href='#mst'><p>Minimum Spanning Tree</p></a></li>
<li><a href='#multi2di'><p>Collapse and Resolve Multichotomies</p></a></li>
<li><a href='#multiphylo'><p>Manipulating Lists of Trees</p></a></li>
<li><a href='#mvr'><p>Minimum Variance Reduction</p></a></li>
<li><a href='#nj'><p>Neighbor-Joining Tree Estimation</p></a></li>
<li><a href='#njs'><p>Tree Reconstruction from Incomplete Distances With NJ* or bio-NJ*</p></a></li>
<li><a href='#node.dating'><p>node.dating</p></a></li>
<li><a href='#node.depth'><p>Depth and Heights of Nodes and Tips</p></a></li>
<li><a href='#nodelabels'><p>Labelling the Nodes, Tips, and Edges of a Tree</p></a></li>
<li><a href='#nodepath'><p>Find Paths of Nodes</p></a></li>
<li><a href='#parafit'><p> Test of host-parasite coevolution</p></a></li>
<li><a href='#pcoa'><p>Principal Coordinate Analysis</p></a></li>
<li><a href='#phydataplot'><p>Tree Annotation</p></a></li>
<li><a href='#phymltest'><p>Fits a Bunch of Models with PhyML</p></a></li>
<li><a href='#pic'><p>Phylogenetically Independent Contrasts</p></a></li>
<li><a href='#pic.ortho'><p>Phylogenetically Independent Orthonormal Contrasts</p></a></li>
<li><a href='#plot.correlogram'><p>Plot a Correlogram</p></a></li>
<li><a href='#plot.phylo'><p>Plot Phylogenies</p></a></li>
<li><a href='#plot.phylo.extra'><p>Extra Fuctions to Plot and Annotate Phylogenies</p></a></li>
<li><a href='#plot.varcomp'><p>Plot Variance Components</p></a></li>
<li><a href='#plotTreeTime'><p>Plot Tree With Time Axis</p></a></li>
<li><a href='#print.phylo'><p>Compact Display of a Phylogeny</p></a></li>
<li><a href='#rDNAbin'><p>Random DNA Sequences</p></a></li>
<li><a href='#read.caic'><p>Read Tree File in CAIC Format</p></a></li>
<li><a href='#read.dna'><p>Read DNA Sequences in a File</p></a></li>
<li><a href='#read.GenBank'><p>Read DNA Sequences from GenBank via Internet</p></a></li>
<li><a href='#read.gff'><p>Read GFF Files</p></a></li>
<li><a href='#read.nexus'><p>Read Tree File in Nexus Format</p></a></li>
<li><a href='#read.nexus.data'>
<p>Read Character Data In NEXUS Format</p></a></li>
<li><a href='#read.tree'><p>Read Tree File in Parenthetic Format</p></a></li>
<li><a href='#reconstruct'><p>Continuous Ancestral Character Estimation</p></a></li>
<li><a href='#reorder.phylo'><p>Internal Reordering of Trees</p></a></li>
<li><a href='#richness.yule.test'><p>Test of Diversification-Shift With the Yule Process</p></a></li>
<li><a href='#rlineage'><p>Tree Simulation Under the Time-Dependent Birth&ndash;Death Models</p></a></li>
<li><a href='#root'><p>Roots Phylogenetic Trees</p></a></li>
<li><a href='#rotate'><p>Swapping Sister Clades</p></a></li>
<li><a href='#rTraitCont'><p>Continuous Character Simulation</p></a></li>
<li><a href='#rTraitDisc'><p>Discrete Character Simulation</p></a></li>
<li><a href='#rTraitMult'><p>Multivariate Character Simulation</p></a></li>
<li><a href='#rtree'><p>Generate Random Trees</p></a></li>
<li><a href='#rtt'><p>Root a Tree by Root-to-Tip Regression</p></a></li>
<li><a href='#SDM'><p>Construction of Consensus Distance Matrix With SDM</p></a></li>
<li><a href='#seg.sites'>
<p>Find Segregating Sites in DNA Sequences</p></a></li>
<li><a href='#skyline'><p>Skyline Plot Estimate of Effective Population Size</p></a></li>
<li><a href='#skylineplot'><p>Drawing Skyline Plot Graphs</p></a></li>
<li><a href='#slowinskiguyer.test'><p>Slowinski-Guyer Test of Homogeneous Diversification</p></a></li>
<li><a href='#solveAmbiguousBases'><p>Solve Ambiguous Bases in DNA Sequences</p></a></li>
<li><a href='#speciesTree'><p>Species Tree Estimation</p></a></li>
<li><a href='#stree'><p>Generates Systematic Regular Trees</p></a></li>
<li><a href='#subtreeplot'><p>Zoom on a Portion of a Phylogeny by Successive Clicks</p></a></li>
<li><a href='#subtrees'><p>All subtrees of a Phylogenetic Tree</p></a></li>
<li><a href='#summary.phylo'><p>Print Summary of a Phylogeny</p></a></li>
<li><a href='#trans'><p>Translation from DNA to Amino Acid Sequences</p></a></li>
<li><a href='#treePop'><p>Tree Popping</p></a></li>
<li><a href='#trex'><p>Tree Explorer With Multiple Devices</p></a></li>
<li><a href='#triangMtd'><p>Tree Reconstruction Based on the Triangles Method</p></a></li>
<li><a href='#unique.multiPhylo'><p>Revomes Duplicate Trees</p></a></li>
<li><a href='#updateLabel'><p>Update Labels</p></a></li>
<li><a href='#varcomp'><p>Compute Variance Component Estimates</p></a></li>
<li><a href='#varCompPhylip'><p>Variance Components with Orthonormal Contrasts</p></a></li>
<li><a href='#vcv'><p>Phylogenetic Variance-covariance or Correlation Matrix</p></a></li>
<li><a href='#vcv2phylo'><p>Variance-Covariance Matrix to Tree</p></a></li>
<li><a href='#weight.taxo'><p>Define Similarity Matrix</p></a></li>
<li><a href='#where'><p>Find Patterns in DNA Sequences</p></a></li>
<li><a href='#which.edge'><p>Identifies Edges of a Tree</p></a></li>
<li><a href='#woodmouse'><p>Cytochrome b Gene Sequences of Woodmice</p></a></li>
<li><a href='#write.dna'><p>Write DNA Sequences in a File</p></a></li>
<li><a href='#write.nexus'><p>Write Tree File in Nexus Format</p></a></li>
<li><a href='#write.nexus.data'><p>Write Character Data in NEXUS Format</p></a></li>
<li><a href='#write.tree'><p>Write Tree File in Parenthetic Format</p></a></li>
<li><a href='#yule'><p>Fits the Yule Model to a Phylogenetic Tree</p></a></li>
<li><a href='#yule.cov'><p>Fits the Yule Model With Covariates</p></a></li>
<li><a href='#yule.time'><p>Fits the Time-Dependent Yule Model</p></a></li>
<li><a href='#zoom'><p>Zoom on a Portion of a Phylogeny</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>5.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-09</td>
</tr>
<tr>
<td>Title:</td>
<td>Analyses of Phylogenetics and Evolution</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gee, expm, igraph, phangorn</td>
</tr>
<tr>
<td>Imports:</td>
<td>nlme, lattice, graphics, methods, stats, utils, parallel, Rcpp
(&ge; 0.12.0), digest</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>ZipData:</td>
<td>no</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for reading, writing, plotting, and manipulating phylogenetic trees, analyses of comparative data in a phylogenetic framework, ancestral character analyses, analyses of diversification and macroevolution, computing distances from DNA sequences, reading and writing nucleotide sequences as well as importing from BioConductor, and several tools such as Mantel's test, generalized skyline plots, graphical exploration of phylogenetic data (alex, trex, kronoviz), estimation of absolute evolutionary rates and clock-like trees using mean path lengths and penalized likelihood, dating trees with non-contemporaneous sequences, translating DNA into AA sequences, and assessing sequence alignments. Phylogeny estimation can be done with the NJ, BIONJ, ME, MVR, SDM, and triangle methods, and several methods handling incomplete distance matrices (NJ*, BIONJ*, MVR*, and the corresponding triangle method). Some functions call external applications (PhyML, Clustal, T-Coffee, Muscle) whose results are returned into R.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/emmanuelparadis/ape">https://github.com/emmanuelparadis/ape</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/emmanuelparadis/ape/issues">https://github.com/emmanuelparadis/ape/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-09 06:21:27 UTC; paradis</td>
</tr>
<tr>
<td>Author:</td>
<td>Emmanuel Paradis <a href="https://orcid.org/0000-0003-3092-2199"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Simon Blomberg <a href="https://orcid.org/0000-0003-1062-0839"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Ben Bolker <a href="https://orcid.org/0000-0002-2127-0443"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph],
  Joseph Brown <a href="https://orcid.org/0000-0002-3835-8062"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Santiago Claramunt
    <a href="https://orcid.org/0000-0002-8926-5974"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cph],
  Julien Claude <a href="https://orcid.org/0000-0002-9267-1228"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Hoa Sien Cuong [aut, cph],
  Richard Desper [aut, cph],
  Gilles Didier <a href="https://orcid.org/0000-0003-0596-9112"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Benoit Durand [aut, cph],
  Julien Dutheil <a href="https://orcid.org/0000-0001-7753-4121"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  RJ Ewing [aut, cph],
  Olivier Gascuel [aut, cph],
  Thomas Guillerme <a href="https://orcid.org/0000-0003-4325-1275"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Christoph Heibl <a href="https://orcid.org/0000-0002-7655-3299"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Anthony Ives <a href="https://orcid.org/0000-0001-9375-9523"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Bradley Jones <a href="https://orcid.org/0000-0003-4498-1069"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Franz Krah <a href="https://orcid.org/0000-0001-7866-7508"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph],
  Daniel Lawson <a href="https://orcid.org/0000-0002-5311-6213"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Vincent Lefort [aut, cph],
  Pierre Legendre <a href="https://orcid.org/0000-0002-3838-3305"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Jim Lemon [aut, cph],
  Guillaume Louvel <a href="https://orcid.org/0000-0002-7745-0785"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Eric Marcon <a href="https://orcid.org/0000-0002-5249-321X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph],
  Rosemary McCloskey
    <a href="https://orcid.org/0000-0002-9772-8553"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cph],
  Johan Nylander [aut, cph],
  Rainer Opgen-Rhein [aut, cph],
  Andrei-Alin Popescu [aut, cph],
  Manuela Royer-Carenzi [aut, cph],
  Klaus Schliep <a href="https://orcid.org/0000-0003-2941-0161"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Korbinian Strimmer
    <a href="https://orcid.org/0000-0001-7917-2056"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cph],
  Damien de Vienne <a href="https://orcid.org/0000-0001-9532-5251"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Emmanuel Paradis &lt;Emmanuel.Paradis@ird.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-11 12:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ape-package'>
Analyses of Phylogenetics and Evolution
</h2><span id='topic+ape-package'></span><span id='topic+ape'></span>

<h3>Description</h3>

<p><span class="pkg">ape</span> provides functions for reading, writing, manipulating,
analysing, and simulating phylogenetic trees and DNA sequences,
computing DNA distances, translating into AA sequences, estimating
trees with distance-based methods, and a range of methods for
comparative analyses and analysis of diversification. Functionalities
are also provided for programming new phylogenetic methods.
</p>
<p>The complete list of functions can be displayed with
<code>library(help = ape)</code>.
</p>
<p>More information on <span class="pkg">ape</span> can be found at
<a href="https://emmanuelparadis.github.io">https://emmanuelparadis.github.io</a>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis, Ben Bolker, Julien Claude, Hoa Sien Cuong, Richard
Desper, Benoit Durand, Julien Dutheil, Olivier Gascuel, Christoph
Heibl, Daniel Lawson, Vincent Lefort, Pierre Legendre, Jim Lemon,
Yvonnick Noel, Johan Nylander, Rainer Opgen-Rhein, Andrei-Alin
Popescu, Klaus Schliep, Korbinian Strimmer, Damien de Vienne
</p>
<p>Maintainer: Emmanuel Paradis &lt;Emmanuel.Paradis@ird.fr&gt;
</p>


<h3>References</h3>

<p>Paradis, E. (2012) <em>Analysis of Phylogenetics and Evolution with
R (Second Edition).</em> New York: Springer.
</p>
<p>Paradis, E., Claude, J. and Strimmer, K. (2004) APE: analyses of
phylogenetics and evolution in R language. <em>Bioinformatics</em>,
<b>20</b>, 289&ndash;290.
</p>
<p>Popescu, A.-A., Huber, K. T. and Paradis, E. (2012) ape 3.0: new tools
for distance based phylogenetics and evolutionary analysis in
R. <em>Bioinformatics</em>, <b>28</b>, 1536&ndash;1537.
</p>
<p>Paradis, E. and Schliep, K. (2019) ape 5.0: an environment for modern
phylogenetics and evolutionary analyses in R. <em>Bioinformatics</em>,
<b>35</b>, 526&ndash;528.
</p>

<hr>
<h2 id='AAbin'>Amino Acid Sequences</h2><span id='topic+AAbin'></span><span id='topic+print.AAbin'></span><span id='topic++5B.AAbin'></span><span id='topic+as.character.AAbin'></span><span id='topic+labels.AAbin'></span><span id='topic+image.AAbin'></span><span id='topic+as.AAbin'></span><span id='topic+as.AAbin.AAString'></span><span id='topic+as.AAbin.AAStringSet'></span><span id='topic+as.AAbin.AAMultipleAlignment'></span><span id='topic+as.AAbin.character'></span><span id='topic+as.phyDat.AAbin'></span><span id='topic+dist.aa'></span><span id='topic+AAsubst'></span><span id='topic+c.AAbin'></span><span id='topic+cbind.AAbin'></span><span id='topic+rbind.AAbin'></span><span id='topic+as.AAbin.list'></span><span id='topic+as.list.AAbin'></span><span id='topic+as.matrix.AAbin'></span>

<h3>Description</h3>

<p>These functions help to create and manipulate AA sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AAbin'
print(x, ...)

## S3 method for class 'AAbin'
x[i, j, drop = FALSE]

## S3 method for class 'AAbin'
c(..., recursive = FALSE)

## S3 method for class 'AAbin'
rbind(...)
## S3 method for class 'AAbin'
cbind(..., check.names = TRUE, fill.with.Xs = FALSE,
             quiet = FALSE)

## S3 method for class 'AAbin'
as.character(x, ...)

## S3 method for class 'AAbin'
labels(object, ...)

## S3 method for class 'AAbin'
image(x, what, col, bg = "white", xlab = "", ylab = "",
      show.labels = TRUE, cex.lab = 1, legend = TRUE, grid = FALSE,
      show.aa = FALSE, aa.cex = 1, aa.font = 1, aa.col = "black",
      scheme = "Ape_AA",...)

as.AAbin(x, ...)
## S3 method for class 'character'
as.AAbin(x, ...)

## S3 method for class 'list'
as.AAbin(x, ...)

## S3 method for class 'AAString'
as.AAbin(x, ...)

## S3 method for class 'AAStringSet'
as.AAbin(x, ...)

## S3 method for class 'AAMultipleAlignment'
as.AAbin(x, ...)

## S3 method for class 'AAbin'
as.list(x, ...)

## S3 method for class 'AAbin'
as.matrix(x, ...)

## S3 method for class 'AAbin'
as.phyDat(x, ...)

dist.aa(x, pairwise.deletion = FALSE, scaled = FALSE)
AAsubst(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AAbin_+3A_x">x</code>, <code id="AAbin_+3A_object">object</code></td>
<td>
<p>an object of class <code>"AAbin"</code> (or else depending on
the function).</p>
</td></tr>
<tr><td><code id="AAbin_+3A_i">i</code>, <code id="AAbin_+3A_j">j</code></td>
<td>
<p>indices of the rows and/or columns to select or to
drop. They may be numeric, logical, or character (in the same way than
for standard <span class="rlang"><b>R</b></span> objects).</p>
</td></tr>
<tr><td><code id="AAbin_+3A_drop">drop</code></td>
<td>
<p>logical; if <code>TRUE</code>, the returned object is of the
lowest possible dimension.</p>
</td></tr>
<tr><td><code id="AAbin_+3A_recursive">recursive</code></td>
<td>
<p>logical; whether to go down lists and concatenate its
elements.</p>
</td></tr>
<tr><td><code id="AAbin_+3A_check.names">check.names</code></td>
<td>
<p>a logical specifying whether to check the rownames
before binding the columns (see details).</p>
</td></tr>
<tr><td><code id="AAbin_+3A_fill.with.xs">fill.with.Xs</code></td>
<td>
<p>a logical indicating whether to keep all
possible individuals as indicating by the rownames, and eventually
filling the missing data with insertion gaps (ignored if
<code>check.names = FALSE</code>).</p>
</td></tr>
<tr><td><code id="AAbin_+3A_quiet">quiet</code></td>
<td>
<p>a logical to switch off warning messages when some rows
are dropped.</p>
</td></tr>
<tr><td><code id="AAbin_+3A_what">what</code></td>
<td>
<p>a vector of characters specifying the amino acids to
visualize. Currently, the only possible choice is to show the three
categories hydrophobic, small, and hydrophilic.</p>
</td></tr>
<tr><td><code id="AAbin_+3A_col">col</code></td>
<td>
<p>a vector of colours. If missing, this is set to &ldquo;red&rdquo;,
&ldquo;yellow&rdquo; and &ldquo;blue&rdquo;.</p>
</td></tr>
<tr><td><code id="AAbin_+3A_bg">bg</code></td>
<td>
<p>the colour used for AA codes not among <code>what</code> (typically
X and *).</p>
</td></tr>
<tr><td><code id="AAbin_+3A_xlab">xlab</code></td>
<td>
<p>the label for the <em>x</em>-axis; none by default.</p>
</td></tr>
<tr><td><code id="AAbin_+3A_ylab">ylab</code></td>
<td>
<p>Idem for the <em>y</em>-axis. Note that by default, the labels
of the sequences are printed on the <em>y</em>-axis (see next option).</p>
</td></tr>
<tr><td><code id="AAbin_+3A_show.labels">show.labels</code></td>
<td>
<p>a logical controlling whether the sequence labels are
printed (<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="AAbin_+3A_cex.lab">cex.lab</code></td>
<td>
<p>a single numeric controlling the size of the sequence
labels. Use <code>cex.axis</code> to control the size of the annotations on
the <em>x</em>-axis.</p>
</td></tr>
<tr><td><code id="AAbin_+3A_legend">legend</code></td>
<td>
<p>a logical controlling whether the legend is plotted
(<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="AAbin_+3A_grid">grid</code></td>
<td>
<p>a logical controlling whether to draw a grid (<code>FALSE</code> by
default).</p>
</td></tr>
<tr><td><code id="AAbin_+3A_show.aa">show.aa</code></td>
<td>
<p>a logical controlling whether to show the AA symbols (<code>FALSE</code> by
default).</p>
</td></tr>
<tr><td><code id="AAbin_+3A_aa.cex">aa.cex</code>, <code id="AAbin_+3A_aa.font">aa.font</code>, <code id="AAbin_+3A_aa.col">aa.col</code></td>
<td>
<p>control the aspect of the AA symbols
(ignored if the previous is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="AAbin_+3A_scheme">scheme</code></td>
<td>
<p>a predefined color scheme. For amino acid options are &quot;Ape_AA&quot;,
&quot;Zappo_AA&quot;, &quot;Clustal&quot; and &quot;Hydrophobicity&quot;, for nucleotides &quot;Ape_NT&quot; and
&quot;RY_NT&quot;.</p>
</td></tr>
<tr><td><code id="AAbin_+3A_pairwise.deletion">pairwise.deletion</code></td>
<td>
<p>a logical indicating whether to delete the
sites with missing data in a pairwise way. The default is to delete the
sites with at least one missing data for all sequences.</p>
</td></tr>
<tr><td><code id="AAbin_+3A_scaled">scaled</code></td>
<td>
<p>a logical value specifying whether to scale the number of
AA differences by the sequence length.</p>
</td></tr>
<tr><td><code id="AAbin_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions help to manipulate amino acid sequences of class
<code>"AAbin"</code>. These objects are stored in vectors, matrices, or lists
which can be manipulated with the usual <code>[</code> operator.
</p>
<p>There is a conversion function to and from characters.
</p>
<p>The function <code>dist.aa</code> computes the number of AA differences
between each pair of sequences in a matrix; this can be scaled by the
sequence length. See the function <code><a href="phangorn.html#topic+dist.ml">dist.ml</a></code> in
<span class="pkg">phangorn</span> for evolutionary distances with AA sequences.
</p>
<p>The function <code>AAsubst</code> returns the indices of the polymorphic sites
(similar to <code><a href="#topic+seg.sites">seg.sites</a></code> for DNA sequences; see examples below).
</p>
<p>The two functions <code>cbind.AAbin</code> and <code>rbind.AAbin</code> work in the
same way than the similar methods for the class <code>"DNAbin"</code>: see
<code><a href="#topic+cbind.DNAbin">cbind.DNAbin</a></code> for more explanations about their respective
behaviours.
</p>


<h3>Value</h3>

<p>an object of class <code>"AAbin"</code>, <code>"character"</code>,
<code>"dist"</code>, or <code>"numeric"</code>, depending on the function.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis, Franz Krah</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.FASTA">read.FASTA</a></code>, <code><a href="#topic+trans">trans</a></code>, <code><a href="#topic+alview">alview</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
AA &lt;- trans(woodmouse, 2)
seg.sites(woodmouse)
AAsubst(AA)
</code></pre>

<hr>
<h2 id='ace'>Ancestral Character Estimation</h2><span id='topic+ace'></span><span id='topic+print.ace'></span><span id='topic+logLik.ace'></span><span id='topic+deviance.ace'></span><span id='topic+AIC.ace'></span><span id='topic+anova.ace'></span>

<h3>Description</h3>

<p><code>ace</code> estimates ancestral character states, and the associated
uncertainty, for continuous and discrete characters. If <code>marginal
    = TRUE</code>, a marginal estimation procedure is used. With this method,
the likelihood values at a given node are computed using only the
information from the tips (and branches) descending from this node.
</p>
<p>The present implementation of marginal reconstruction for discrete
characters does not calculate the most likely state for each node,
integrating over all the possible states, over all the other nodes in
the tree, in proportion to their probability. For more details, see
the Note below.
</p>
<p><code>logLik</code>, <code>deviance</code>, and <code>AIC</code> are generic functions
used to extract the log-likelihood, the deviance, or the Akaike
information criterion of a fitted object. If no such values are
available, <code>NULL</code> is returned.
</p>
<p><code>anova</code> is another generic function which is used to compare
nested models: the significance of the additional parameter(s) is
tested with likelihood ratio tests. You must ensure that the models
are effectively nested (if they are not, the results will be
meaningless). It is better to list the models from the smallest to the
largest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ace(x, phy, type = "continuous", method = if (type == "continuous")
   "REML" else "ML", CI = TRUE,
    model = if (type == "continuous") "BM" else "ER",
    scaled = TRUE, kappa = 1, corStruct = NULL, ip = 0.1,
    use.expm = FALSE, use.eigen = TRUE, marginal = FALSE)
## S3 method for class 'ace'
print(x, digits = 4, ...)
## S3 method for class 'ace'
logLik(object, ...)
## S3 method for class 'ace'
deviance(object, ...)
## S3 method for class 'ace'
AIC(object, ..., k = 2)
## S3 method for class 'ace'
anova(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ace_+3A_x">x</code></td>
<td>
<p>a vector or a factor; an object of class <code>"ace"</code> in the
case of <code>print</code>.</p>
</td></tr>
<tr><td><code id="ace_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="ace_+3A_type">type</code></td>
<td>
<p>the variable type; either <code>"continuous"</code> or
<code>"discrete"</code> (or an abbreviation of these).</p>
</td></tr>
<tr><td><code id="ace_+3A_method">method</code></td>
<td>
<p>a character specifying the method used for
estimation. Four choices are possible: <code>"ML"</code>, <code>"REML"</code>,
<code>"pic"</code>, or <code>"GLS"</code>.</p>
</td></tr>
<tr><td><code id="ace_+3A_ci">CI</code></td>
<td>
<p>a logical specifying whether to return the 95% confidence
intervals of the ancestral state estimates (for continuous
characters) or the likelihood of the different states (for discrete
ones).</p>
</td></tr>
<tr><td><code id="ace_+3A_model">model</code></td>
<td>
<p>a character specifying the model (ignored if <code>method
      = "GLS"</code>), or a numeric matrix if <code>type = "discrete"</code> (see
details).</p>
</td></tr>
<tr><td><code id="ace_+3A_scaled">scaled</code></td>
<td>
<p>a logical specifying whether to scale the contrast
estimate (used only if <code>method = "pic"</code>).</p>
</td></tr>
<tr><td><code id="ace_+3A_kappa">kappa</code></td>
<td>
<p>a positive value giving the exponent transformation of
the branch lengths (see details).</p>
</td></tr>
<tr><td><code id="ace_+3A_corstruct">corStruct</code></td>
<td>
<p>if <code>method = "GLS"</code>, specifies the correlation
structure to be used (this also gives the assumed model).</p>
</td></tr>
<tr><td><code id="ace_+3A_ip">ip</code></td>
<td>
<p>the initial value(s) used for the ML estimation procedure
when <code>type == "discrete"</code> (possibly recycled).</p>
</td></tr>
<tr><td><code id="ace_+3A_use.expm">use.expm</code></td>
<td>
<p>a logical specifying whether to use the package
<span class="pkg">expm</span> to compute the matrix exponential (relevant only if
<code>type = "d"</code>). If <code>FALSE</code>, the function <code>matexpo</code>
from <span class="pkg">ape</span> is used (see details). This option is ignored if
<code>use.eigen = TRUE</code> (see next).</p>
</td></tr>
<tr><td><code id="ace_+3A_use.eigen">use.eigen</code></td>
<td>
<p>a logical (relevant if <code>type = "d"</code>); if
<code>TRUE</code> then the probability matrix is computed with an eigen
decomposition instead of a matrix exponential (see details).</p>
</td></tr>
<tr><td><code id="ace_+3A_marginal">marginal</code></td>
<td>
<p>a logical (relevant if <code>type = "d"</code>). By default,
the joint reconstruction of the ancestral states are done. Set this
option to <code>TRUE</code> if you want the marginal reconstruction (see
details.)</p>
</td></tr>
<tr><td><code id="ace_+3A_digits">digits</code></td>
<td>
<p>the number of digits to be printed.</p>
</td></tr>
<tr><td><code id="ace_+3A_object">object</code></td>
<td>
<p>an object of class <code>"ace"</code>.</p>
</td></tr>
<tr><td><code id="ace_+3A_k">k</code></td>
<td>
<p>a numeric value giving the penalty per estimated parameter;
the default is <code>k = 2</code> which is the classical Akaike
information criterion.</p>
</td></tr>
<tr><td><code id="ace_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>type = "continuous"</code>, the default model is Brownian motion
where characters evolve randomly following a random walk. This model
can be fitted by residual maximum likelihood (the default), maximum
likelihood (Felsenstein 1973, Schluter et al. 1997), least squares
(<code>method = "pic"</code>, Felsenstein 1985), or generalized least
squares (<code>method = "GLS"</code>, Martins and Hansen 1997, Cunningham et
al. 1998). In the last case, the specification of <code>phy</code> and
<code>model</code> are actually ignored: it is instead given through a
correlation structure with the option <code>corStruct</code>.
</p>
<p>In the setting <code>method = "ML"</code> and <code>model = "BM"</code> (this used
to be the default until <span class="pkg">ape</span> 3.0-7) the maximum likelihood
estimation is done simultaneously on the ancestral values and the
variance of the Brownian motion process; these estimates are then used
to compute the confidence intervals in the standard way. The REML
method first estimates the ancestral value at the root (aka, the
phylogenetic mean), then the variance of the Brownian motion process
is estimated by optimizing the residual log-likelihood. The ancestral
values are finally inferred from the likelihood function giving these
two parameters. If <code>method = "pic"</code> or <code>"GLS"</code>, the
confidence intervals are computed using the expected variances under
the model, so they depend only on the tree.
</p>
<p>It could be shown that, with a continous character, REML results in
unbiased estimates of the variance of the Brownian motion process
while ML gives a downward bias. Therefore the former is recommanded.
</p>
<p>For discrete characters (<code>type = "discrete"</code>), only maximum
likelihood estimation is available (Pagel 1994) (see <code><a href="#topic+MPR">MPR</a></code>
for an alternative method). The model is specified through a numeric
matrix with integer values taken as indices of the parameters. The
numbers of rows and of columns of this matrix must be equal, and are
taken to give the number of states of the character. For instance,
<code>matrix(c(0, 1, 1, 0), 2)</code> will represent a model with two
character states and equal rates of transition, <code>matrix(c(0, 1,
  2, 0), 2)</code> a model with unequal rates, <code>matrix(c(0, 1, 1, 1, 0,
  1, 1, 1, 0), 3)</code> a model with three states and equal rates of
transition (the diagonal is always ignored). There are short-cuts to
specify these models: <code>"ER"</code> is an equal-rates model (e.g., the
first and third examples above), <code>"ARD"</code> is an
all-rates-different model (the second example), and <code>"SYM"</code> is a
symmetrical model (e.g., <code>matrix(c(0, 1, 2, 1, 0, 3, 2, 3, 0),
  3)</code>). If a short-cut is used, the number of states is determined from
the data.
</p>
<p>By default, the likelihood of the different ancestral states of
discrete characters are computed with a joint estimation procedure
using a procedure similar to the one described in Pupko et al. (2000).
If <code>marginal = TRUE</code>, a marginal estimation procedure is used
(this was the only choice until <span class="pkg">ape</span> 3.1-1). With this method,
the likelihood values at a given node are computed using only the
information from the tips (and branches) descending from this node.
With the joint estimation, all information is used for each node. The
difference between these two methods is further explained in
Felsenstein (2004, pp. 259-260) and in Yang (2006, pp. 121-126). The
present implementation of the joint estimation uses a &ldquo;two-pass&rdquo;
algorithm which is much faster than stochastic mapping while the
estimates of both methods are very close.
</p>
<p>With discrete characters it is necessary to compute the exponential of
the rate matrix. The only possibility until <span class="pkg">ape</span> 3.0-7 was the
function <code><a href="#topic+matexpo">matexpo</a></code> in <span class="pkg">ape</span>. If <code>use.expm = TRUE</code>
and <code>use.eigen = FALSE</code>, the function <code><a href="expm.html#topic+expm">expm</a></code>,
in the package of the same name, is used. <code>matexpo</code> is faster but
quite inaccurate for large and/or asymmetric matrices. In case of
doubt, use the latter. Since <span class="pkg">ape</span> 3.0-10, it is possible to use
an eigen decomposition avoiding the need to compute the matrix
exponential; see details in Lebl (2013, sect. 3.8.3). This is much
faster and is now the default.
</p>
<p>Since version 5.2 of <span class="pkg">ape</span>, <code>ace</code> can take state uncertainty
for discrete characters into account: this should be coded with <span class="rlang"><b>R</b></span>'s
<code><a href="base.html#topic+NA">NA</a></code> only. More details:
</p>
<p><a href="https://www.mail-archive.com/r-sig-phylo@r-project.org/msg05286.html">https://www.mail-archive.com/r-sig-phylo@r-project.org/msg05286.html</a>
</p>


<h3>Value</h3>

<p>an object of class <code>"ace"</code> with the following elements:
</p>
<table>
<tr><td><code>ace</code></td>
<td>
<p>if <code>type = "continuous"</code>, the estimates of the
ancestral character values.</p>
</td></tr>
<tr><td><code>CI95</code></td>
<td>
<p>if <code>type = "continuous"</code>, the estimated 95%
confidence intervals.</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>if <code>type = "continuous"</code>, <code>model = "BM"</code>, and
<code>method = "ML"</code>, the maximum likelihood estimate of the
Brownian parameter.</p>
</td></tr>
<tr><td><code>rates</code></td>
<td>
<p>if <code>type = "discrete"</code>, the maximum likelihood
estimates of the transition rates.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>if <code>type = "discrete"</code>, the standard-errors of
estimated rates.</p>
</td></tr>
<tr><td><code>index.matrix</code></td>
<td>
<p>if <code>type = "discrete"</code>, gives the indices of
the <code>rates</code> in the rate matrix.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>if <code>method = "ML"</code>, the maximum log-likelihood.</p>
</td></tr>
<tr><td><code>lik.anc</code></td>
<td>
<p>if <code>type = "discrete"</code>, the scaled likelihoods of
each ancestral state.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Liam Revell points out that for discrete characters the ancestral
likelihood values returned with <code>marginal = FALSE</code> are actually
the marginal estimates, while setting <code>marginal = TRUE</code> returns
the conditional (scaled) likelihoods of the subtree:
</p>
<p><a href="http://blog.phytools.org/2015/05/about-how-acemarginaltrue-does-not.html">http://blog.phytools.org/2015/05/about-how-acemarginaltrue-does-not.html</a>
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis, Ben Bolker</p>


<h3>References</h3>

<p>Cunningham, C. W., Omland, K. E. and Oakley, T. H. (1998)
Reconstructing ancestral character states: a critical
reappraisal. <em>Trends in Ecology &amp; Evolution</em>, <b>13</b>,
361&ndash;366.
</p>
<p>Felsenstein, J. (1973) Maximum likelihood estimation
of evolutionary trees from continuous characters. <em>American
Journal of Human Genetics</em>, <b>25</b>, 471&ndash;492.
</p>
<p>Felsenstein, J. (1985) Phylogenies and the comparative
method. <em>American Naturalist</em>, <b>125</b>, 1&ndash;15.
</p>
<p>Felsenstein, J. (2004) <em>Inferring Phylogenies</em>. Sunderland:
Sinauer Associates.
</p>
<p>Lebl, J. (2013) <em>Notes on Diffy Qs: Differential Equations for
Engineers</em>. <a href="https://www.jirka.org/diffyqs/">https://www.jirka.org/diffyqs/</a>.
</p>
<p>Martins, E. P. and Hansen, T. F. (1997) Phylogenies and the
comparative method: a general approach to incorporating phylogenetic
information into the analysis of interspecific data. <em>American
Naturalist</em>, <b>149</b>, 646&ndash;667.
</p>
<p>Pagel, M. (1994) Detecting correlated evolution on phylogenies: a
general method for the comparative analysis of discrete
characters. <em>Proceedings of the Royal Society of London. Series
B. Biological Sciences</em>, <b>255</b>, 37&ndash;45.
</p>
<p>Pupko, T., Pe'er, I, Shamir, R., and Graur, D. (2000) A fast algorithm
for joint reconstruction of ancestral amino acid sequences.
<em>Molecular Biology and Evolution</em>, <b>17</b>, 890&ndash;896.
</p>
<p>Schluter, D., Price, T., Mooers, A. O. and Ludwig, D. (1997)
Likelihood of ancestor states in adaptive radiation. <em>Evolution</em>,
<b>51</b>, 1699&ndash;1711.
</p>
<p>Yang, Z. (2006) <em>Computational Molecular Evolution</em>. Oxford:
Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MPR">MPR</a></code>, <code><a href="#topic+corBrownian">corBrownian</a></code>, <code><a href="#topic+compar.ou">compar.ou</a></code>,
<code><a href="stats.html#topic+anova">anova</a></code>
</p>
<p>Reconstruction of ancestral sequences can be done with the package
<span class="pkg">phangorn</span> (see function <code>?ancestral.pml</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Some random data...
data(bird.orders)
x &lt;- rnorm(23)
### Compare the three methods for continuous characters:
ace(x, bird.orders)
ace(x, bird.orders, method = "pic")
ace(x, bird.orders, method = "GLS",
    corStruct = corBrownian(1, bird.orders))
### For discrete characters:
x &lt;- factor(c(rep(0, 5), rep(1, 18)))
ans &lt;- ace(x, bird.orders, type = "d")
#### Showing the likelihoods on each node:
plot(bird.orders, type = "c", FALSE, label.offset = 1)
co &lt;- c("blue", "yellow")
tiplabels(pch = 22, bg = co[as.numeric(x)], cex = 2, adj = 1)
nodelabels(thermo = ans$lik.anc, piecol = co, cex = 0.75)
</code></pre>

<hr>
<h2 id='add.scale.bar'>Add a Scale Bar to a Phylogeny Plot</h2><span id='topic+add.scale.bar'></span>

<h3>Description</h3>

<p>This function adds a horizontal bar giving the scale of the branch
lengths to a plot of a phylogenetic tree on the current graphical
device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.scale.bar(x, y, length = NULL, ask = FALSE,
              lwd = 1, lcol = "black", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.scale.bar_+3A_x">x</code></td>
<td>
<p>x location of the bar (can be left missing).</p>
</td></tr>
<tr><td><code id="add.scale.bar_+3A_y">y</code></td>
<td>
<p>y location of the bar (can be left missing).</p>
</td></tr>
<tr><td><code id="add.scale.bar_+3A_length">length</code></td>
<td>
<p>a numeric value giving the length of the scale bar. If
none is supplied, a value is calculated from the data.</p>
</td></tr>
<tr><td><code id="add.scale.bar_+3A_ask">ask</code></td>
<td>
<p>a logical; if <code>TRUE</code> the user is asked to click where
to draw the bar. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="add.scale.bar_+3A_lwd">lwd</code></td>
<td>
<p>the width of the bar.</p>
</td></tr>
<tr><td><code id="add.scale.bar_+3A_lcol">lcol</code></td>
<td>
<p>the colour of the bar (use <code>col</code> for the colour of
the text).</p>
</td></tr>
<tr><td><code id="add.scale.bar_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>text</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the bar is placed in a corner of the graph depending on
the direction of the tree. Otherwise both <code>x</code> and <code>y</code> must
be specified (if only one is given it is ignored).
</p>
<p>The further arguments (<code>...</code>) are used to format the text. They
may be <code>font</code>, <code>cex</code>, <code>col</code>, and so on (see examples
below, and the help page on <code><a href="graphics.html#topic+text">text</a></code>).
</p>
<p>The function <code><a href="graphics.html#topic+locator">locator</a></code>  may be used to
determine the <code>x</code> and <code>y</code> arguments.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.phylo">plot.phylo</a></code>, <code><a href="#topic+axisPhylo">axisPhylo</a></code>,
<code><a href="graphics.html#topic+locator">locator</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tr &lt;- rtree(10)
layout(matrix(1:2, 2, 1))
plot(tr)
add.scale.bar()
plot(tr)
add.scale.bar(cex = 0.7, font = 2, col = "red")
layout(1)
</code></pre>

<hr>
<h2 id='additive'>Incomplete Distance Matrix Filling</h2><span id='topic+additive'></span><span id='topic+ultrametric'></span>

<h3>Description</h3>

<p>Fills missing entries from incomplete distance matrix using the
additive or the ultrametric procedure (see reference for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>additive(X)
ultrametric(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="additive_+3A_x">X</code></td>
<td>
<p>a distance matrix or an object of class <code>"dist"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a distance matrix.
</p>


<h3>Author(s)</h3>

<p>Andrei Popescu</p>


<h3>References</h3>

<p>Makarenkov, V. and Lapointe, F.-J. (2004) A weighted least-squares
approach for inferring phylogenies from incomplete distance
matrices. <em>Bioinformatics</em>, <b>20</b>, 2113&ndash;2121.
</p>

<hr>
<h2 id='alex'>Alignment Explorer With Multiple Devices</h2><span id='topic+alex'></span>

<h3>Description</h3>

<p>This function helps to explore DNA alignments by zooming in. The user
clicks twice defining the opposite corners of the portion which is
extracted and drawned on a new window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alex(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alex_+3A_x">x</code></td>
<td>
<p>an object of class <code>"DNAbin"</code>.</p>
</td></tr>
<tr><td><code id="alex_+3A_...">...</code></td>
<td>
<p>further arguments to pass to <code>image.DNAbin</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works with a DNA alignment (freshly) plotted on an
interactive graphical device (i.e., not a file) with <code>image</code>.
After calling <code>alex</code>, the user clicks twice defining a rectangle
in the alignment, then this portion of the alignment is extacted and
plotted on a <em>new</em> window. The user can click as many times on
the alignment. The process is stopped by a right-click. If the user
clicks twice outside the alignment, a message &ldquo;Try again!&rdquo; is
printed.
</p>
<p>Each time <code>alex</code> is called, the alignment is plotted on a new
window without closing or deleting those possibly already plotted.
</p>
<p>In all cases, the device where <code>x</code> is plotted is the active
window after the operation. It should <em>not</em> be closed during the
whole process.
</p>


<h3>Value</h3>

<p>NULL</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+image.DNAbin">image.DNAbin</a></code>, <code><a href="#topic+trex">trex</a></code>, <code><a href="#topic+alview">alview</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(woodmouse)
image(woodmouse)
alex(woodmouse)

## End(Not run)</code></pre>

<hr>
<h2 id='all.equal.DNAbin'>Compare DNA Sets</h2><span id='topic+all.equal.DNAbin'></span>

<h3>Description</h3>

<p>Comparison of DNA sequence sets, particularly when aligned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DNAbin'
all.equal(target, current, plot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all.equal.DNAbin_+3A_target">target</code>, <code id="all.equal.DNAbin_+3A_current">current</code></td>
<td>
<p>the two sets of sequences to be compared.</p>
</td></tr>
<tr><td><code id="all.equal.DNAbin_+3A_plot">plot</code></td>
<td>
<p>a logical value specifying whether to plot the sites that
are different (only if the labels of both alignments are the same).</p>
</td></tr>
<tr><td><code id="all.equal.DNAbin_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+image.DNAbin">image.DNAbin</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the two sets of DNA sequences are exactly identical, this function
returns <code>TRUE</code>. Otherwise, a detailed comparison is made only if
the labels (i.e., rownames) of <code>target</code> and <code>current</code> are the
same (possibly in different orders). In all other cases, a brief
description of the differences is returned (sometimes with
recommendations to make further comparisons).
</p>
<p>This function can be used for testing in programs using
<code><a href="base.html#topic+isTRUE">isTRUE</a></code> (see examples below).
</p>


<h3>Value</h3>

<p><code>TRUE</code> if the two sets are identical; a list with two elements
(message and different.sites) if a detailed comparison is done; or a
vector of mode character.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+image.DNAbin">image.DNAbin</a></code>, <code><a href="#topic+clustal">clustal</a></code>,
<code><a href="#topic+checkAlignment">checkAlignment</a></code>,
the generic function: <code><a href="base.html#topic+all.equal">all.equal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
woodm2 &lt;- woodmouse
woodm2[1, c(1:5, 10:12, 30:40)] &lt;- as.DNAbin("g")
res &lt;- all.equal(woodmouse, woodm2, plot = TRUE)
str(res)

## if used for testing in R programs:
isTRUE(all.equal(woodmouse, woodmouse)) # TRUE
isTRUE(all.equal(woodmouse, woodm2)) # FALSE

all.equal(woodmouse, woodmouse[15:1, ])
all.equal(woodmouse, woodmouse[-1, ])
all.equal(woodmouse, woodmouse[, -1])

## Not run: 
## To run the followings you need internet and Clustal and MUSCLE
## correctly installed.
## Data from Johnson et al. (2006, Science)
refs &lt;- paste("DQ082", 505:545, sep = "")
DNA &lt;- read.GenBank(refs)
DNA.clustal &lt;- clustal(DNA)
DNA.muscle &lt;- muscle(DNA)
isTRUE(all.equal(DNA.clustal, DNA.muscle)) # FALSE
all.equal(DNA.clustal, DNA.muscle, TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='all.equal.phylo'>Global Comparison of two Phylogenies</h2><span id='topic+all.equal.phylo'></span>

<h3>Description</h3>

<p>This function makes a global comparison of two phylogenetic trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phylo'
all.equal(target, current, use.edge.length = TRUE,
                   use.tip.label = TRUE, index.return = FALSE,
                   tolerance = .Machine$double.eps ^ 0.5,
                   scale = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all.equal.phylo_+3A_target">target</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="all.equal.phylo_+3A_current">current</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="all.equal.phylo_+3A_use.edge.length">use.edge.length</code></td>
<td>
<p>if <code>FALSE</code> only the topologies are
compared; the default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="all.equal.phylo_+3A_use.tip.label">use.tip.label</code></td>
<td>
<p>if <code>FALSE</code> the unlabelled trees are
compared; the default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="all.equal.phylo_+3A_index.return">index.return</code></td>
<td>
<p>if <code>TRUE</code> the function returns a two-column
matrix giving the correspondence between the nodes of both trees.</p>
</td></tr>
<tr><td><code id="all.equal.phylo_+3A_tolerance">tolerance</code></td>
<td>
<p>the numeric tolerance used to compare the branch
lengths.</p>
</td></tr>
<tr><td><code id="all.equal.phylo_+3A_scale">scale</code></td>
<td>
<p>a positive number, comparison of branch lengths is made
after scaling (i.e., dividing) them by this number.</p>
</td></tr>
<tr><td><code id="all.equal.phylo_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is meant to be an adaptation of the generic function
<code>all.equal</code> for the comparison of phylogenetic trees.
</p>
<p>A single phylogenetic tree may have several representations in the Newick
format and in the <code>"phylo"</code> class of objects used in &lsquo;ape&rsquo;. One
aim of the present function is to be able to identify whether two
objects of class <code>"phylo"</code> represent the same phylogeny.
</p>


<h3>Value</h3>

<p>A logical value, or a two-column matrix.
</p>


<h3>Note</h3>

<p>The algorithm used here does not work correctly for the comparison of
topologies (i.e., ignoring tip labels) of unrooted trees. This also
affects <code><a href="#topic+unique.multiPhylo">unique.multiPhylo</a></code> which calls the present function. See:
</p>
<p><a href="https://www.mail-archive.com/r-sig-phylo@r-project.org/msg01445.html">https://www.mail-archive.com/r-sig-phylo@r-project.org/msg01445.html</a>.
</p>


<h3>Author(s)</h3>

<p>Benoît Durand <a href="mailto:b.durand@alfort.AFSSA.FR">b.durand@alfort.AFSSA.FR</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+all.equal">all.equal</a></code> for the generic <span class="rlang"><b>R</b></span> function, <code><a href="#topic+comparePhylo">comparePhylo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### maybe the simplest example of two representations
### for the same rooted tree...:
t1 &lt;- read.tree(text = "(a:1,b:1);")
t2 &lt;- read.tree(text = "(b:1,a:1);")
all.equal(t1, t2)
### ... compare with this:
identical(t1, t2)
### one just slightly more complicated...:
t3 &lt;- read.tree(text = "((a:1,b:1):1,c:2);")
t4 &lt;- read.tree(text = "(c:2,(a:1,b:1):1);")
all.equal(t3, t4) # == all.equal.phylo(t3, t4)
### ... here we force the comparison as lists:
all.equal.list(t3, t4)
</code></pre>

<hr>
<h2 id='alview'>Print DNA or AA Sequence Alignement</h2><span id='topic+alview'></span>

<h3>Description</h3>

<p>This function displays in the console or a file an alignment of DNA or
AAsequences. The first sequence is printed on the first row and the
bases of the other sequences are replaced by dots if they are
identical with the first sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alview(x, file = "", uppercase = TRUE, showpos = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alview_+3A_x">x</code></td>
<td>
<p>a matrix or a list of DNA sequences (class <code>"DNAbin"</code>)
or a matrix of AA sequences (class <code>"AAbin"</code>).</p>
</td></tr>
<tr><td><code id="alview_+3A_file">file</code></td>
<td>
<p>a character string giving the name of the file where to print the sequences; by default, they are printed in the console.</p>
</td></tr>
<tr><td><code id="alview_+3A_uppercase">uppercase</code></td>
<td>
<p>a logical specifying whether to print the bases as
uppercase letters.</p>
</td></tr>
<tr><td><code id="alview_+3A_showpos">showpos</code></td>
<td>
<p>either a logical value specifying whether to display
the site positions, or a numeric vector giving these positions (see
examples).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first line of the output shows the position of the last column of the printed alignment.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+DNAbin">DNAbin</a></code>, <code><a href="#topic+image.DNAbin">image.DNAbin</a></code>, <code><a href="#topic+alex">alex</a></code>,
<code><a href="#topic+clustal">clustal</a></code>, <code><a href="#topic+checkAlignment">checkAlignment</a></code>, <code><a href="#topic+all.equal.DNAbin">all.equal.DNAbin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
alview(woodmouse[, 1:50])
alview(woodmouse[, 1:50], uppercase = FALSE)
## display only some sites:
j &lt;- c(10, 49, 125, 567) # just random
x &lt;- woodmouse[, j]
alview(x, showpos = FALSE) # no site position displayed
alview(x, showpos = j)
## Not run: 
alview(woodmouse, file = "woodmouse.txt")

## End(Not run)
</code></pre>

<hr>
<h2 id='ape-internal'>Internal Ape Functions</h2><span id='topic+.PlotPhyloEnv'></span><span id='topic+perm.rowscols'></span><span id='topic+phylogram.plot'></span><span id='topic+cladogram.plot'></span><span id='topic+circular.plot'></span><span id='topic+unrooted.xy'></span><span id='topic+BOTHlabels'></span><span id='topic+floating.pie.asp'></span><span id='topic+plotPhyloCoor'></span><span id='topic+postprocess.prop.part'></span><span id='topic+ONEwise'></span><span id='topic+SHORTwise'></span><span id='topic+reorderRcpp'></span><span id='topic+polar2rect'></span><span id='topic+rect2polar'></span><span id='topic+node_depth'></span><span id='topic+node_depth_edgelength'></span><span id='topic+node_height'></span><span id='topic+node_height_clado'></span><span id='topic+seq_root2tip'></span>

<h3>Description</h3>

<p>Internal <span class="pkg">ape</span> functions which are undocumented but still exported
because called by other packages. Use with care!
</p>

<hr>
<h2 id='apetools'>Tools to Explore Files</h2><span id='topic+apetools'></span><span id='topic+Xplorefiles'></span><span id='topic+Xplor'></span><span id='topic+editFileExtensions'></span><span id='topic+bydir'></span>

<h3>Description</h3>

<p>These functions help to find files on the local disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Xplorefiles(from = "HOME", recursive = TRUE, ignore.case = TRUE)
editFileExtensions()
bydir(x)
Xplor(from = "HOME")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apetools_+3A_from">from</code></td>
<td>
<p>the directory where to start the file search; by default,
the &lsquo;HOME&rsquo; directory. Use <code>from = getwd()</code> to start from the
current working directory.</p>
</td></tr>
<tr><td><code id="apetools_+3A_recursive">recursive</code></td>
<td>
<p>whether to search the subdirectories; <code>TRUE</code> by
default.</p>
</td></tr>
<tr><td><code id="apetools_+3A_ignore.case">ignore.case</code></td>
<td>
<p>whether to ignore the case of the file extensions;
<code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="apetools_+3A_x">x</code></td>
<td>
<p>a list returned by <code>Xplorefiles</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Xplorefiles</code> looks for all files with a specified extension in
their names. The default is to look for the following file types:
CLUSTAL (.aln), FASTA (.fas, .fasta), FASTQ (.fq, .fastq), NEWICK
(.nwk, .newick, .tre, .tree), NEXUS (.nex, .nexus), and PHYLIP
(.phy). This list can be modified with <code>editFileExtensions</code>.
</p>
<p><code>bydir</code> sorts the list of files by directories.
</p>
<p><code>Xplor</code> combines the other operations and opens the results in
a Web browser with clickable links to the directories and files.
</p>


<h3>Value</h3>

<p><code>Xplorefiles</code> returns a list. <code>bydir</code> prints the file
listings on the console.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- Xplorefiles()
x # all data files on your disk
bydir(x) # sorted by directories
bydir(x["fasta"]) # only the FASTA files
Xplorefiles(getwd(), recursive = FALSE) # look only in current dir
Xplor()

## End(Not run)</code></pre>

<hr>
<h2 id='as.alignment'>Conversion Among DNA Sequence Internal Formats</h2><span id='topic+as.alignment'></span><span id='topic+as.DNAbin'></span><span id='topic+as.DNAbin.character'></span><span id='topic+as.DNAbin.list'></span><span id='topic+as.DNAbin.alignment'></span><span id='topic+as.character.DNAbin'></span><span id='topic+as.DNAbin.DNAString'></span><span id='topic+as.DNAbin.DNAStringSet'></span><span id='topic+as.DNAbin.PairwiseAlignmentsSingleSubject'></span><span id='topic+as.DNAbin.DNAMultipleAlignment'></span>

<h3>Description</h3>

<p>These functions transform a set of DNA sequences among various
internal formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.alignment(x)
as.DNAbin(x, ...)

## S3 method for class 'character'
as.DNAbin(x, ...)

## S3 method for class 'list'
as.DNAbin(x, ...)

## S3 method for class 'alignment'
as.DNAbin(x, ...)

## S3 method for class 'DNAString'
as.DNAbin(x, ...)

## S3 method for class 'DNAStringSet'
as.DNAbin(x, ...)

## S3 method for class 'PairwiseAlignmentsSingleSubject'
as.DNAbin(x, ...)

## S3 method for class 'DNAMultipleAlignment'
as.DNAbin(x, ...)

## S3 method for class 'DNAbin'
as.character(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.alignment_+3A_x">x</code></td>
<td>
<p>a matrix or a list containing the DNA sequences, or an object
of class <code>"alignment"</code>.</p>
</td></tr>
<tr><td><code id="as.alignment_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>as.alignment</code>, the sequences given as argument should be
stored as matrices or lists of single-character strings (the format
used in <span class="pkg">ape</span> before version 1.10). The returned object is in the
format used in the package <span class="pkg">seqinr</span> to store aligned sequences.
</p>
<p><code>as.DNAbin</code> is a generic function with methods so that it works
with sequences stored into vectors, matrices, or lists. It can convert
some S4 classes from the package <span class="pkg">Biostrings</span> in BioConductor. For
consistency within <span class="pkg">ape</span>, this uses an S3-style syntax. To convert
objects of class <code>"DNAStringSetList"</code>, see the examples.
</p>
<p><code>as.character</code> is a generic function: the present method
converts objects of class <code>"DNAbin"</code> into the format used
before <span class="pkg">ape</span> 1.10 (matrix of single characters, or list of vectors
of single characters). This function must be used first to convert
objects of class <code>"DNAbin"</code> into the class <code>"alignment"</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>"alignment"</code> in the case of
<code>"as.alignment"</code>; an object of class <code>"DNAbin"</code> in the case
of <code>"as.DNAbin"</code>; a matrix of mode character or a list containing
vectors of mode character in the case of <code>"as.character"</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+DNAbin">DNAbin</a></code>, <code><a href="#topic+read.dna">read.dna</a></code>,
<code><a href="#topic+read.GenBank">read.GenBank</a></code>, <code><a href="#topic+write.dna">write.dna</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
x &lt;- as.character(woodmouse)
x[, 1:20]
str(as.alignment(x))
identical(as.DNAbin(x), woodmouse)
### conversion from BioConductor:
## Not run: 
if (require(Biostrings)) {
data(phiX174Phage)
X &lt;- as.DNAbin(phiX174Phage)
## base frequencies:
base.freq(X) # from ape
alphabetFrequency(phiX174Phage) # from Biostrings
### for objects of class "DNAStringSetList"
X &lt;- lapply(x, as.DNAbin) # a list of lists
### to put all sequences in a single list:
X &lt;- unlist(X, recursive = FALSE)
class(X) &lt;- "DNAbin"
}

## End(Not run)
</code></pre>

<hr>
<h2 id='as.bitsplits'>Split Frequencies and Conversion Among Split Classes</h2><span id='topic+as.bitsplits'></span><span id='topic+as.bitsplits.prop.part'></span><span id='topic+print.bitsplits'></span><span id='topic+sort.bitsplits'></span><span id='topic+bitsplits'></span><span id='topic+countBipartitions'></span><span id='topic+as.prop.part'></span><span id='topic+as.prop.part.bitsplits'></span>

<h3>Description</h3>

<p><code>bitsplits</code> returns the bipartitions (aka splits) for a single
tree or a list of trees. If at least one tree is rooted, an error is
returned.
</p>
<p><code>countBipartitions</code> returns the frequencies of the bipartitions
from a reference tree (phy) observed in a list of trees (X), all unrooted.
</p>
<p><code>as.bitsplits</code> and <code>as.prop.part</code> are generic functions for
converting between the <code>"bitsplits"</code> and <code>"prop.part"</code>
classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bitsplits(x)
countBipartitions(phy, X)
as.bitsplits(x)
## S3 method for class 'prop.part'
as.bitsplits(x)
## S3 method for class 'bitsplits'
print(x, ...)
## S3 method for class 'bitsplits'
sort(x, decreasing = FALSE, ...)
as.prop.part(x, ...)
## S3 method for class 'bitsplits'
as.prop.part(x, include.trivial = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.bitsplits_+3A_x">x</code></td>
<td>
<p>an object of the appropriate class.</p>
</td></tr>
<tr><td><code id="as.bitsplits_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="as.bitsplits_+3A_x">X</code></td>
<td>
<p>an object of class <code>"multiPhylo"</code>.</p>
</td></tr>
<tr><td><code id="as.bitsplits_+3A_decreasing">decreasing</code></td>
<td>
<p>a logical value to sort the bipartitions in
increasing (the default) or decreasing order of their frequency.</p>
</td></tr>
<tr><td><code id="as.bitsplits_+3A_include.trivial">include.trivial</code></td>
<td>
<p>a logical value specifying whether to include
the trivial split with all tips in the returned object.</p>
</td></tr>
<tr><td><code id="as.bitsplits_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions count bipartitions as defined by internal branches, so
they work only with unrooted trees. The structure of the class
<code>"bitsplits"</code> is described in a separate document on ape's web
site.
</p>
<p>This data structure has a memory requirement proportional to
<code class="reqn">n^2</code>, so it can be inefficient with large trees (&gt; 1000 tips),
particularly if they are very different (i.e., with few shared
splits). In any case, an error occurs if the product of the number of
tips by the number of nodes is greater than <code class="reqn">2^{31}-1</code> (~2.1
billion). A warning message is given if the tree(s) has(ve) more than
46,341 tips. It may happen that the search for splits is interrupted
if the data structure is full (with a warning message).
</p>


<h3>Value</h3>

<p><code>bitsplits</code>, <code>as.bitsplits</code>, and <code>sort</code> return an object
of class <code>"bitsplits"</code>.
</p>
<p><code>countBipartitions</code> returns a vector of integers.
</p>
<p><code>as.prop.part</code> returns an object of class <code>"prop.part"</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+prop.part">prop.part</a></code>, <code><a href="#topic+is.compatible">is.compatible</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>tr &lt;- rtree(20)
pp &lt;- prop.part(tr)
as.bitsplits(pp)
## works only with unrooted trees (ape 5.5):
countBipartitions(rtree(10, rooted = FALSE), rmtree(100, 10, rooted = FALSE))
</code></pre>

<hr>
<h2 id='as.matching'>Conversion Between Phylo and Matching Objects</h2><span id='topic+as.matching'></span><span id='topic+matching'></span><span id='topic+as.matching.phylo'></span><span id='topic+as.phylo.matching'></span>

<h3>Description</h3>

<p>These functions convert objects between the classes <code>"phylo"</code> and
<code>"matching"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.matching(x, ...)
## S3 method for class 'phylo'
as.matching(x, labels = TRUE, ...)
## S3 method for class 'matching'
as.phylo(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matching_+3A_x">x</code></td>
<td>
<p>an object to convert as an object of class <code>"matching"</code>
or of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="as.matching_+3A_labels">labels</code></td>
<td>
<p>a logical specifying whether the tip and node labels
should be included in the returned matching.</p>
</td></tr>
<tr><td><code id="as.matching_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A matching is a representation where each tip and each node are given
a number, and sibling groups are grouped in a &ldquo;matching pair&rdquo; (see
Diaconis and Holmes 1998, for details). This coding system can be used
only for binary (fully dichotomous) trees.
</p>
<p>Diaconis and Holmes (1998) gave some conventions to insure that a
given tree has a unique representation as a matching. I have tried to
follow them in the present functions.
</p>


<h3>Value</h3>

<p><code>as.matching</code> returns an object of class <code>"matching"</code> with
the following component:
</p>
<table>
<tr><td><code>matching</code></td>
<td>
<p>a two-column numeric matrix where the columns
represent the sibling pairs.</p>
</td></tr>
<tr><td><code>tip.label</code></td>
<td>
<p>(optional) a character vector giving the tip labels
where the ith element is the label of the tip numbered i in
<code>matching</code>.</p>
</td></tr>
<tr><td><code>node.label</code></td>
<td>
<p>(optional) a character vector giving the node
labels in the same order than in <code>matching</code> (i.e. the ith
element is the label of the node numbered i + n in <code>matching</code>,
with n the number of tips).</p>
</td></tr>
</table>
<p><code>as.phylo.matching</code> returns an object of class <code>"phylo"</code>.
</p>


<h3>Note</h3>

<p>Branch lengths are not supported in the present version.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Diaconis, P. W. and Holmes, S. P. (1998) Matchings and phylogenetic
trees. <em>Proceedings of the National Academy of Sciences USA</em>,
<b>95</b>, 14600&ndash;14602.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.phylo">as.phylo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bird.orders)
m &lt;- as.matching(bird.orders)
str(m)
m
tr &lt;- as.phylo(m)
all.equal(tr, bird.orders, use.edge.length = FALSE)
</code></pre>

<hr>
<h2 id='as.phylo'>Conversion Among Tree and Network Objects</h2><span id='topic+as.phylo'></span><span id='topic+as.phylo.default'></span><span id='topic+as.phylo.hclust'></span><span id='topic+as.phylo.phylog'></span><span id='topic+as.hclust.phylo'></span><span id='topic+old2new.phylo'></span><span id='topic+new2old.phylo'></span><span id='topic+as.network.phylo'></span><span id='topic+as.igraph'></span><span id='topic+as.igraph.phylo'></span>

<h3>Description</h3>

<p><code>as.phylo</code> is a generic function which converts an object into a
tree of class <code>"phylo"</code>. There are currently two methods for
objects of class <code>"hclust"</code> and of class <code>"phylog"</code>
(implemented in the package <span class="pkg">ade4</span>). The default method is for any
object inheriting the class <code>"phylo"</code> which is returned unchanged.
</p>
<p><code>as.hclust.phylo</code> is a method of the generic
<code><a href="stats.html#topic+as.hclust">as.hclust</a></code> which converts an object of class
<code>"phylo"</code> into one of class <code>"hclust"</code>. This can used to
convert an object of class <code>"phylo"</code> into one of class
<code>"dendrogram"</code> (see examples).
</p>
<p><code>as.network</code> and <code>as.igraph</code> convert trees of class
<code>"phylo"</code> into these respective classes defined in the packages
of the same names (where the generics are defined).
</p>
<p><code>old2new.phylo</code> and <code>new2old.phylo</code> are utility functions
for converting between the old and new coding of the class
<code>"phylo"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.phylo(x, ...)
## Default S3 method:
as.phylo(x, ...)
## S3 method for class 'hclust'
as.phylo(x, ...)
## S3 method for class 'phylog'
as.phylo(x, ...)
## S3 method for class 'phylo'
as.hclust(x, ...)
old2new.phylo(phy)
new2old.phylo(phy)
## S3 method for class 'phylo'
as.network(x, directed = is.rooted(x), ...)
## S3 method for class 'phylo'
as.igraph(x, directed = is.rooted(x), use.labels = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.phylo_+3A_x">x</code></td>
<td>
<p>an object to be converted into another class.</p>
</td></tr>
<tr><td><code id="as.phylo_+3A_directed">directed</code></td>
<td>
<p>a logical value: should the network be directed? By
default, this depends on whether the tree is rooted or not.</p>
</td></tr>
<tr><td><code id="as.phylo_+3A_use.labels">use.labels</code></td>
<td>
<p>a logical specifying whether to use labels to build
the network of class <code>"igraph"</code>. If <code>TRUE</code> and the tree
has no node labels, then some default labels are created first. If
<code>FALSE</code>, the network is built with integers.</p>
</td></tr>
<tr><td><code id="as.phylo_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
<tr><td><code id="as.phylo_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"hclust"</code>, <code>"phylo"</code>, <code>"network"</code>,
or <code>"igraph"</code>.
</p>


<h3>Note</h3>

<p>In an object of class <code>"hclust"</code>, the <code>height</code> gives the
distance between the two sets that are being agglomerated. So these
distances are divided by two when setting the branch lengths of a
phylogenetic tree.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="stats.html#topic+as.hclust">as.hclust</a></code>,
<code><a href="stats.html#topic+dendrogram">dendrogram</a></code>, <code><a href="#topic+as.phylo.formula">as.phylo.formula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bird.orders)
hc &lt;- as.hclust(bird.orders)
tr &lt;- as.phylo(hc)
all.equal(bird.orders, tr) # TRUE

### shows the three plots for tree objects:
dend &lt;- as.dendrogram(hc)
layout(matrix(c(1:3, 3), 2, 2))
plot(bird.orders, font = 1)
plot(hc)
par(mar = c(8, 0, 0, 0)) # leave space for the labels
plot(dend)

### how to get identical plots with
### plot.phylo and plot.dendrogram:
layout(matrix(1:2, 2, 1))
plot(bird.orders, font = 1, no.margin = TRUE, label.offset = 0.4)
par(mar = c(0, 0, 0, 8))
plot(dend, horiz = TRUE)
layout(1)

## Not run: 
### convert into networks:
if (require(network)) {
    x &lt;- as.network(rtree(10))
    print(x)
    plot(x, vertex.cex = 1:4)
    plot(x, displaylabels = TRUE)
}
tr &lt;- rtree(5)
if (require(igraph)) {
    print((x &lt;- as.igraph(tr)))
    plot(x)
    print(as.igraph(tr, TRUE, FALSE))
    print(as.igraph(tr, FALSE, FALSE))
}

## End(Not run)
</code></pre>

<hr>
<h2 id='as.phylo.formula'>Conversion from Taxonomy Variables to Phylogenetic Trees</h2><span id='topic+as.phylo.formula'></span>

<h3>Description</h3>

<p>The function <code>as.phylo.formula</code> (short form <code>as.phylo</code>)
builds a phylogenetic tree (an object of class <code>phylo</code>) from
a set of nested taxonomic variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
as.phylo(x, data = parent.frame(), collapse = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.phylo.formula_+3A_x">x</code></td>
<td>
<p>a right-side formula describing the taxonomic relationship:
<code>~C1/C2/.../Cn</code>.</p>
</td></tr>
<tr><td><code id="as.phylo.formula_+3A_data">data</code></td>
<td>
<p>the data.frame where to look for the variables (default
to user's workspace).</p>
</td></tr>
<tr><td><code id="as.phylo.formula_+3A_collapse">collapse</code></td>
<td>
<p>a logical value specifying whether to collapse single
nodes in the returned tree (see details).</p>
</td></tr>
<tr><td><code id="as.phylo.formula_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Taxonomic variables must be nested and passed in the correct order:
the higher clade must be on the left of the formula, for instance
<code>~Order/Family/Genus/Species</code>. In most cases, the resulting tree
will be unresolved and will contain polytomies.
</p>
<p>The option <code>collapse = FALSE</code> has for effect to add single nodes
in the tree when a given higher level has only one element in the
level below (e.g., a monospecific genus); see the example below.
</p>


<h3>Value</h3>

<p>an object of class <code>"phylo"</code>.
</p>


<h3>Author(s)</h3>

<p>Julien Dutheil <a href="mailto:dutheil@evolbio.mpg.de">dutheil@evolbio.mpg.de</a>, Eric Marcon and
Klaus Schliep</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.phylo">as.phylo</a></code>, <code><a href="#topic+read.tree">read.tree</a></code> for a
description of <code>"phylo"</code> objects, <code><a href="#topic+multi2di">multi2di</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carnivora)
frm &lt;- ~SuperFamily/Family/Genus/Species
tr &lt;- as.phylo(frm, data = carnivora, collapse=FALSE)
tr$edge.length &lt;- rep(1, nrow(tr$edge))
plot(tr, show.node.label=TRUE)
Nnode(tr)
## compare with:
Nnode(as.phylo(frm, data = carnivora, collapse = FALSE))
</code></pre>

<hr>
<h2 id='axisPhylo'>Axis on Side of Phylogeny</h2><span id='topic+axisPhylo'></span>

<h3>Description</h3>

<p>This function adds a scaled axis on the side of a phylogeny plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axisPhylo(side = 1, root.time = NULL, backward = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="axisPhylo_+3A_side">side</code></td>
<td>
<p>a numeric value specifying the side where the axis is
plotted: 1: below, 2: left, 3: above, 4: right.</p>
</td></tr>
<tr><td><code id="axisPhylo_+3A_root.time">root.time</code></td>
<td>
<p>the time assigned to the root node of the tree. By
default, this is taken from the <code>root.time</code> element of the
tree. If it is absent, this is determined from the next option.</p>
</td></tr>
<tr><td><code id="axisPhylo_+3A_backward">backward</code></td>
<td>
<p>a logical value; if TRUE, the most distant tip from
the root is considered as the origin of the time scale; if FALSE,
this is the root node.</p>
</td></tr>
<tr><td><code id="axisPhylo_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>axis</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The further arguments (<code>...</code>) are used to format the axis. They
may be <code>font</code>, <code>cex</code>, <code>col</code>, <code>las</code>, and so on (see
the help pages on <code><a href="graphics.html#topic+axis">axis</a></code> and
<code><a href="graphics.html#topic+par">par</a></code>).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.phylo">plot.phylo</a></code>, <code><a href="#topic+add.scale.bar">add.scale.bar</a></code>,
<code><a href="graphics.html#topic+axis">axis</a></code>, <code><a href="graphics.html#topic+par">par</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tr &lt;- rtree(30)
ch &lt;- rcoal(30)
plot(ch)
axisPhylo()
plot(tr, "c", FALSE, direction = "u")
axisPhylo(2, las = 1)
</code></pre>

<hr>
<h2 id='balance'>Balance of a Dichotomous Phylogenetic Tree</h2><span id='topic+balance'></span>

<h3>Description</h3>

<p>This function computes the balance of a phylogenetic tree, that is for
each node of the tree the numbers of descendants (i.e. tips) on each
of its daughter-branch. The tree must be fully dichotomous.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balance(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balance_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric matrix with two columns and one row for each node of the
tree. The columns give the numbers of descendants on each
daughter-branches (the order of both columns being arbitrary). If the
phylogeny <code>phy</code> has an element <code>node.label</code>, this is used as
rownames for the returned matrix; otherwise the numbers (of mode
character) of the matrix <code>edge</code> of <code>phy</code> are used as rownames.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Aldous, D. J. (2001) Stochastic models and descriptive statistics for
phylogenetic trees, from Yule to today. <em>Statistical Science</em>,
<b>16</b>, 23&ndash;34.
</p>

<hr>
<h2 id='base.freq'>Base frequencies from DNA Sequences</h2><span id='topic+base.freq'></span><span id='topic+GC.content'></span><span id='topic+Ftab'></span>

<h3>Description</h3>

<p><code>base.freq</code> computes the frequencies (absolute or relative) of
the four DNA bases (adenine, cytosine, guanine, and thymidine) from a
sample of sequences.
</p>
<p><code>GC.content</code> computes the proportion of G+C (using the previous
function). All missing or unknown sites are ignored.
</p>
<p><code>Ftab</code> computes the contingency table with the absolute
frequencies of the DNA bases from a pair of sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base.freq(x, freq = FALSE, all = FALSE)
GC.content(x)
Ftab(x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base.freq_+3A_x">x</code></td>
<td>
<p>a vector, a matrix, or a list which contains the DNA
sequences.</p>
</td></tr>
<tr><td><code id="base.freq_+3A_y">y</code></td>
<td>
<p>a vector with a single DNA sequence.</p>
</td></tr>
<tr><td><code id="base.freq_+3A_freq">freq</code></td>
<td>
<p>a logical specifying whether to return the proportions
(the default) or the absolute frequencies (counts).</p>
</td></tr>
<tr><td><code id="base.freq_+3A_all">all</code></td>
<td>
<p>a logical; by default only the counts of A, C, G, and T are
returned. If <code>all = TRUE</code>, all counts of bases, ambiguous codes,
missing data, and alignment gaps are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The base frequencies are computed over all sequences in the
sample.
</p>
<p>For <code>Ftab</code>, if the argument <code>y</code> is given then both <code>x</code>
and <code>y</code> are coerced as vectors and must be of equal length. If
<code>y</code> is not given, <code>x</code> must be a matrix or a list and only
the two first sequences are used.
</p>


<h3>Value</h3>

<p>A numeric vector with names <code>c("a", "c", "g", "t")</code> (and possibly
<code>"r", "m", ...</code>, a single numeric value, or a four by four matrix
with similar dimnames.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+seg.sites">seg.sites</a></code>, <code>nuc.div</code> (in <span class="pkg">pegas</span>), <code><a href="#topic+DNAbin">DNAbin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
base.freq(woodmouse)
base.freq(woodmouse, TRUE)
base.freq(woodmouse, TRUE, TRUE)
GC.content(woodmouse)
Ftab(woodmouse)
Ftab(woodmouse[1, ], woodmouse[2, ]) # same than above
Ftab(woodmouse[14:15, ]) # between the last two
</code></pre>

<hr>
<h2 id='bd.ext'>Extended Version of the Birth-Death Models to Estimate Speciation
and Extinction Rates</h2><span id='topic+bd.ext'></span>

<h3>Description</h3>

<p>This function fits by maximum likelihood a birth-death model to the
combined phylogenetic and taxonomic data of a given clade. The
phylogenetic data are given by a tree, and the taxonomic data by the
number of species for the its tips.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bd.ext(phy, S, conditional = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bd.ext_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="bd.ext_+3A_s">S</code></td>
<td>
<p>a numeric vector giving the number of species for each tip.</p>
</td></tr>
<tr><td><code id="bd.ext_+3A_conditional">conditional</code></td>
<td>
<p>whether probabilities should be conditioned on no
extinction (mainly to compare results with previous analyses; see
details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A re-parametrization of the birth-death model studied by Kendall
(1948) so that the likelihood has to be maximized over <em>d/b</em> and
<em>b - d</em>, where <em>b</em> is the birth rate, and <em>d</em> the death
rate.
</p>
<p>The standard-errors of the estimated parameters are computed using a
normal approximation of the maximum likelihood estimates.
</p>
<p>If the argument <code>S</code> has names, then they are matched to the tip
labels of <code>phy</code>. The user must be careful here since the function
requires that both series of names perfectly match, so this operation
may fail if there is a typing or syntax error. If both series of names
do not match, the values <code>S</code> are taken to be in the same order
than the tip labels of <code>phy</code>, and a warning message is issued.
</p>
<p>Note that the function does not check that the tree is effectively
ultrametric, so if it is not, the returned result may not be
meaningful.
</p>
<p>If <code>conditional = TRUE</code>, the probabilities of the taxonomic data
are calculated conditioned on no extinction (Rabosky et al. 2007). In
previous versions of the present function (until ape 2.6-1),
unconditional probabilities were used resulting in underestimated
extinction rate. Though it does not make much sense to use
<code>conditional = FALSE</code>, this option is provided to compare results
from previous analyses: if the species richnesses are relatively low,
both versions will give similar results (see examples).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Paradis, E. (2003) Analysis of diversification: combining phylogenetic
and taxonomic data. <em>Proceedings of the Royal Society of
London. Series B. Biological Sciences</em>, <b>270</b>, 2499&ndash;2505.
</p>
<p>Rabosky, D. L., Donnellan, S. C., Talaba, A. L. and Lovette,
I. J. (2007) Exceptional among-lineage variation in diversification
rates during the radiation of Australia's most diverse vertebrate
clade. <em>Proceedings of the Royal Society of London. Series
B. Biological Sciences</em>, <b>274</b>, 2915&ndash;2923.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+birthdeath">birthdeath</a></code>, <code><a href="#topic+branching.times">branching.times</a></code>,
<code><a href="#topic+diversi.gof">diversi.gof</a></code>, <code><a href="#topic+diversi.time">diversi.time</a></code>,
<code><a href="#topic+ltt.plot">ltt.plot</a></code>, <code><a href="#topic+yule">yule</a></code>, <code><a href="#topic+yule.cov">yule.cov</a></code>,
<code><a href="#topic+bd.time">bd.time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### An example from Paradis (2003) using the avian orders:
data(bird.orders)
### Number of species in each order from Sibley and Monroe (1990):
S &lt;- c(10, 47, 69, 214, 161, 17, 355, 51, 56, 10, 39, 152,
       6, 143, 358, 103, 319, 23, 291, 313, 196, 1027, 5712)
bd.ext(bird.orders, S)
bd.ext(bird.orders, S, FALSE) # same than older versions
</code></pre>

<hr>
<h2 id='bd.time'>Time-Dependent Birth-Death Models</h2><span id='topic+bd.time'></span>

<h3>Description</h3>

<p>This function fits a used-defined time-dependent birth-death
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bd.time(phy, birth, death, BIRTH = NULL, DEATH = NULL,
        ip, lower, upper, fast = FALSE, boot = 0, trace = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bd.time_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="bd.time_+3A_birth">birth</code></td>
<td>
<p>either a numeric (if speciation rate is assumed
constant), or a (vectorized) function specifying how the birth
(speciation) probability changes through time (see details).</p>
</td></tr>
<tr><td><code id="bd.time_+3A_death">death</code></td>
<td>
<p>id. for extinction probability.</p>
</td></tr>
<tr><td><code id="bd.time_+3A_birth">BIRTH</code></td>
<td>
<p>(optional) a vectorized function giving the primitive
of <code>birth</code>.</p>
</td></tr>
<tr><td><code id="bd.time_+3A_death">DEATH</code></td>
<td>
<p>id. for <code>death</code>.</p>
</td></tr>
<tr><td><code id="bd.time_+3A_ip">ip</code></td>
<td>
<p>a numeric vector used as initial values for the estimation
procedure. If missing, these values are guessed.</p>
</td></tr>
<tr><td><code id="bd.time_+3A_lower">lower</code>, <code id="bd.time_+3A_upper">upper</code></td>
<td>
<p>the lower and upper bounds of the parameters. If
missing, these values are guessed too.</p>
</td></tr>
<tr><td><code id="bd.time_+3A_fast">fast</code></td>
<td>
<p>a logical value specifying whether to use faster
integration (see details).</p>
</td></tr>
<tr><td><code id="bd.time_+3A_boot">boot</code></td>
<td>
<p>the number of bootstrap replicates to assess the
confidence intervals of the parameters. Not run by default.</p>
</td></tr>
<tr><td><code id="bd.time_+3A_trace">trace</code></td>
<td>
<p>an integer value. If non-zero, the fitting procedure is
printed every <code>trace</code> steps. This can be helpful if convergence
is particularly slow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details on how to specify the birth and death functions and their
primitives can be found in the help page of <code><a href="#topic+yule.time">yule.time</a></code>.
</p>
<p>The model is fitted by minimizing the least squares deviation between
the observed and the predicted distributions of branching times. These
computations rely heavily on numerical integrations. If <code>fast =
  FALSE</code>, integrations are done with R's <code><a href="stats.html#topic+integrate">integrate</a></code>
function. If <code>fast = TRUE</code>, a faster but less accurate function
provided in <span class="pkg">ape</span> is used. If fitting a complex model to a large
phylogeny, a strategy might be to first use the latter option, and
then to use the estimates as starting values with <code>fast = FALSE</code>.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>

<ul>
<li><p> par: a vector of estimates with names taken from the parameters
in the specified functions.
</p>
</li>
<li><p> SS: the minimized sum of squares.
</p>
</li>
<li><p> convergence: output convergence criterion from
<code><a href="stats.html#topic+nlminb">nlminb</a></code>.
</p>
</li>
<li><p> message: id.
</p>
</li>
<li><p> iterations: id.
</p>
</li>
<li><p> evaluations: id.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Paradis, E. (2011) Time-dependent speciation and extinction from
phylogenies: a least squares approach. <em>Evolution</em>, <b>65</b>,
661&ndash;672.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ltt.plot">ltt.plot</a></code>, <code><a href="#topic+birthdeath">birthdeath</a></code>,
<code><a href="#topic+yule.time">yule.time</a></code>, <code><a href="#topic+LTT">LTT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(3)
tr &lt;- rbdtree(0.1, 0.02)
bd.time(tr, 0, 0) # fits a simple BD model
bd.time(tr, 0, 0, ip = c(.1, .01)) # 'ip' is useful here
## the classic logistic:
birth.logis &lt;- function(a, b) 1/(1 + exp(-a*t - b))
## Not run: 
bd.time(tr, birth.logis, 0, ip = c(0, -2, 0.01))
## slow to get:
## $par
##            a            b        death
## -0.003486961 -1.995983179  0.016496454
##
## $SS
## [1] 20.73023

## End(Not run)
</code></pre>

<hr>
<h2 id='binaryPGLMM'>Phylogenetic Generalized Linear Mixed Model for Binary Data</h2><span id='topic+binaryPGLMM'></span><span id='topic+binaryPGLMM.sim'></span><span id='topic+print.binaryPGLMM'></span>

<h3>Description</h3>

<p>binaryPGLMM performs linear regression for binary phylogenetic data, estimating regression coefficients with approximate standard errors. It simultaneously estimates the strength of phylogenetic signal in the residuals and gives an approximate conditional likelihood ratio test for the hypothesis that there is no signal. Therefore, when applied without predictor (independent) variables, it gives a test for phylogenetic signal for binary data. The method uses a GLMM approach, alternating between penalized quasi-likelihood (PQL) to estimate the &quot;mean components&quot; and restricted maximum likelihood (REML) to estimate the &quot;variance components&quot; of the model.
</p>
<p>binaryPGLMM.sim is a companion function that simulates binary phylogenetic data of the same structure analyzed by binaryPGLMM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binaryPGLMM(formula, data = list(), phy, s2.init = 0.1,
            B.init = NULL, tol.pql = 10^-6, maxit.pql = 200,
            maxit.reml = 100)

binaryPGLMM.sim(formula, data = list(), phy, s2 = NULL, B = NULL, nrep = 1)

## S3 method for class 'binaryPGLMM'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binaryPGLMM_+3A_formula">formula</code></td>
<td>
<p>a two-sided linear formula object describing the
fixed-effects of the model; for example, Y ~ X.</p>
</td></tr>
<tr><td><code id="binaryPGLMM_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables named in formula.</p>
</td></tr>
<tr><td><code id="binaryPGLMM_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree as an object of class &quot;phylo&quot;.</p>
</td></tr>
<tr><td><code id="binaryPGLMM_+3A_s2.init">s2.init</code></td>
<td>
<p>an initial estimate of s2, the scaling component of the
variance in the PGLMM. A value of s2 = 0 implies no phylogenetic
signal. Note that the variance-covariance matrix given by the
phylogeny phy is scaled to have determinant = 1.</p>
</td></tr>
<tr><td><code id="binaryPGLMM_+3A_b.init">B.init</code></td>
<td>
<p>initial estimates of B, the matrix containing regression
coefficients in the model. This matrix must have
dim(B.init)=c(p+1,1), where p is the number of predictor
(independent) variables; the first element of B corresponds to the
intercept, and the remaining elements correspond in order to the
predictor (independent) variables in the model.</p>
</td></tr>
<tr><td><code id="binaryPGLMM_+3A_tol.pql">tol.pql</code></td>
<td>
<p>a control parameter dictating the tolerance for
convergence for the PQL optimization.</p>
</td></tr>
<tr><td><code id="binaryPGLMM_+3A_maxit.pql">maxit.pql</code></td>
<td>
<p>a control parameter dictating the maximum number of
iterations for the PQL optimization.</p>
</td></tr>
<tr><td><code id="binaryPGLMM_+3A_maxit.reml">maxit.reml</code></td>
<td>
<p>a control parameter dictating the maximum number of
iterations for the REML optimization.</p>
</td></tr>
<tr><td><code id="binaryPGLMM_+3A_x">x</code></td>
<td>
<p>an object of class &quot;binaryPGLMM&quot;.</p>
</td></tr>
<tr><td><code id="binaryPGLMM_+3A_s2">s2</code></td>
<td>
<p>in binaryPGLMM.sim, value of s2. See s2.init.</p>
</td></tr>
<tr><td><code id="binaryPGLMM_+3A_b">B</code></td>
<td>
<p>in binaryPGLMM.sim, value of B, the matrix containing regression coefficients in the model. See B.init.</p>
</td></tr>
<tr><td><code id="binaryPGLMM_+3A_nrep">nrep</code></td>
<td>
<p>in binaryPGLMM.sim,  number of compete data sets produced.</p>
</td></tr>
<tr><td><code id="binaryPGLMM_+3A_digits">digits</code></td>
<td>
<p>the number of digits to print.</p>
</td></tr>
<tr><td><code id="binaryPGLMM_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>print</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimates parameters for the model
</p>
<p style="text-align: center;"><code class="reqn">Pr(Y = 1) = q </code>
</p>

<p style="text-align: center;"><code class="reqn">q = inverse.logit(b0 + b1 * x1 + b2 * x2 + \dots + \epsilon)</code>
</p>

<p style="text-align: center;"><code class="reqn">\epsilon ~ Gaussian(0, s2 * V) </code>
</p>

<p>where <code class="reqn">V</code> is a variance-covariance matrix derived from a phylogeny (typically under the assumption of Brownian motion evolution). Although mathematically there is no requirement for <code class="reqn">V</code> to be ultrametric, forcing <code class="reqn">V</code> into ultrametric form can aide in the interpretation of the model, because in regression for binary dependent variables, only the off-diagonal elements (i.e., covariances) of matrix <code class="reqn">V</code> are biologically meaningful (see Ives &amp; Garland 2014).
</p>
<p>The function converts a phylo tree object into a variance-covariance matrix, and further standardizes this matrix to have determinant = 1. This in effect standardizes the interpretation of the scalar s2. Although mathematically not required, it is a very good idea to standardize the predictor (independent) variables to have mean 0 and variance 1. This will make the function more robust and improve the interpretation of the regression coefficients. For categorical (factor) predictor variables, you will need to construct 0-1 dummy variables, and these should not be standardized (for obvious reasons).
</p>
<p>The estimation method alternates between PQL to obtain estimates of the mean components of the model (this is the standard approach to estimating GLMs) and REML to obtain estimates of the variance components. This method gives relatively fast and robust estimation. Nonetheless, the estimates of the coefficients B will generally be upwards bias, as is typical of estimation for binary data. The standard errors of B are computed from the PQL results conditional on the estimate of s2 and therefore should tend to be too small. The function returns an approximate P-value for the hypothesis of no phylogenetic signal in the residuals (i.e., H0:s2 = 0) using an approximate likelihood ratio test based on the conditional REML likelihood (rather than the marginal likelihood). Simulations have shown that these P-values tend to be high (giving type II errors: failing to identify variances that in fact are statistically significantly different from zero).
</p>
<p>It is a good idea to confirm statistical inferences using parametric bootstrapping, and the companion function binaryPGLMM.sim gives a simply tool for this. See Examples below.
</p>


<h3>Value</h3>

<p>An object of class &quot;binaryPGLMM&quot;.
</p>
<table>
<tr><td><code>formula</code></td>
<td>
<p>formula specifying the regression model.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>estimates of the regression coefficients.</p>
</td></tr>
<tr><td><code>B.se</code></td>
<td>
<p>approximate PQL standard errors of the regression
coefficients.</p>
</td></tr>
<tr><td><code>B.cov</code></td>
<td>
<p>approximate PQL covariance matrix for the regression
coefficients.</p>
</td></tr>
<tr><td><code>B.zscore</code></td>
<td>
<p>approximate PQL Z scores for the regression
coefficients.</p>
</td></tr>
<tr><td><code>B.pvalue</code></td>
<td>
<p>approximate PQL tests for the regression coefficients
being different from zero.</p>
</td></tr>
<tr><td><code>s2</code></td>
<td>
<p>phylogenetic signal measured as the scalar magnitude of the
phylogenetic variance-covariance matrix s2 * V.</p>
</td></tr>
<tr><td><code>P.H0.s2</code></td>
<td>
<p>approximate likelihood ratio test of the hypothesis H0
that s2 = 0. This test is based on the conditional REML (keeping the
regression coefficients fixed) and is prone to inflated type 1 errors.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>for each data point y, the estimate of p that y = 1.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>for each data point y, the estimate of inverse.logit(p).</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the predictor (independent) variables returned in matrix form
(including 1s in the first column).</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>residuals of the form b + (Y - mu)/(mu * (1 - mu)).</p>
</td></tr>
<tr><td><code>B.init</code></td>
<td>
<p>the user-provided initial estimates of B. If B.init is
not provided, these are estimated using glm() assuming no phylogenetic
signal. The glm() estimates can generate convergence problems, so
using small values (e.g., 0.01) is more robust but slower.</p>
</td></tr>
<tr><td><code>VCV</code></td>
<td>
<p>the standardized phylogenetic variance-covariance matrix.</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>estimate of the covariance matrix of H.</p>
</td></tr>
<tr><td><code>convergeflag</code></td>
<td>
<p>flag for cases when convergence failed.</p>
</td></tr>
<tr><td><code>iteration</code></td>
<td>
<p>number of total iterations performed.</p>
</td></tr>
<tr><td><code>converge.test.B</code></td>
<td>
<p>final tolerance for B.</p>
</td></tr>
<tr><td><code>converge.test.s2</code></td>
<td>
<p>final tolerance for s2.</p>
</td></tr>
<tr><td><code>rcondflag</code></td>
<td>
<p>number of times B is reset to 0.01. This is done when
rcond(V) &lt; 10^(-10), which implies that V cannot be inverted.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>in binaryPGLMM.sim, the simulated values of Y.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Anthony R. Ives</p>


<h3>References</h3>

<p>Ives, A. R. and Helmus, M. R. (2011) Generalized linear mixed models
for phylogenetic analyses of community structure. <em>Ecological
Monographs</em>, <b>81</b>, 511&ndash;525.
</p>
<p>Ives, A. R. and Garland, T., Jr. (2014) Phylogenetic regression for
binary dependent variables. Pages 231&ndash;261 <em>in</em> L. Z. Garamszegi,
editor. <em>Modern Phylogenetic Comparative Methods and Their
Application in Evolutionary Biology</em>. Springer-Verlag, Berlin
Heidelberg.
</p>


<h3>See Also</h3>

<p>package <span class="pkg">pez</span> and its function <code>communityPGLMM</code>;
package <span class="pkg">phylolm</span> and its function <code>phyloglm</code>;
package <span class="pkg">MCMCglmm</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Illustration of binaryPGLMM() with simulated data

# Generate random phylogeny

n &lt;- 100
phy &lt;- compute.brlen(rtree(n=n), method = "Grafen", power = 1)

# Generate random data and standardize to have mean 0 and variance 1
X1 &lt;- rTraitCont(phy, model = "BM", sigma = 1)
X1 &lt;- (X1 - mean(X1))/var(X1)

# Simulate binary Y
sim.dat &lt;- data.frame(Y=array(0, dim=n), X1=X1, row.names=phy$tip.label)
sim.dat$Y &lt;- binaryPGLMM.sim(Y ~ X1, phy=phy, data=sim.dat, s2=.5,
                             B=matrix(c(0,.25),nrow=2,ncol=1), nrep=1)$Y

# Fit model
binaryPGLMM(Y ~ X1, phy=phy, data=sim.dat)

## Not run: 
# Compare with phyloglm()
library(phylolm)
summary(phyloglm(Y ~ X1, phy=phy, data=sim.dat))

# Compare with glm() that does not account for phylogeny
summary(glm(Y ~ X1, data=sim.dat, family="binomial"))

# Compare with logistf() that does not account
# for phylogeny but is less biased than glm()
library(logistf)
logistf(Y ~ X1, data=sim.dat)

# Compare with MCMCglmm
library(MCMCglmm)

V &lt;- vcv(phy)
V &lt;- V/max(V)
detV &lt;- exp(determinant(V)$modulus[1])
V &lt;- V/detV^(1/n)

invV &lt;- Matrix(solve(V),sparse=T)
sim.dat$species &lt;- phy$tip.label
rownames(invV) &lt;- sim.dat$species

nitt &lt;- 43000
thin &lt;- 10
burnin &lt;- 3000

prior &lt;- list(R=list(V=1, fix=1), G=list(G1=list(V=1, nu=1000, alpha.mu=0, alpha.V=1)))
summary(MCMCglmm(Y ~ X1, random=~species, ginvers=list(species=invV),
    data=sim.dat, slice=TRUE, nitt=nitt, thin=thin, burnin=burnin,
    family="categorical", prior=prior, verbose=FALSE))

## Examine bias in estimates of B1 and s2 from binaryPGLMM with
# simulated data. Note that this will take a while.

Reps = 1000

s2 &lt;- 0.4
B1 &lt;- 1

meanEsts &lt;- data.frame(n = Inf, B1 = B1, s2 = s2, Pr.s2 = 1, propconverged = 1)

for (n in c(160, 80, 40, 20)) {

  meanEsts.n &lt;- data.frame(B1 = 0, s2 = 0, Pr.s2 = 0, convergefailure = 0)
    for (rep in 1:Reps) {
      phy &lt;- compute.brlen(rtree(n = n), method = "Grafen", power = 1)
      X &lt;- rTraitCont(phy, model = "BM", sigma = 1)
      X &lt;- (X - mean(X))/var(X)

      sim.dat &lt;- data.frame(Y = array(0, dim = n), X = X, row.names = phy$tip.label)
      sim &lt;- binaryPGLMM.sim(Y ~ 1 + X, phy = phy, data = sim.dat, s2 = s2,
                                       B = matrix(c(0,B1), nrow = 2, ncol = 1), nrep = 1)
      sim.dat$Y &lt;- sim$Y

      z &lt;- binaryPGLMM(Y ~ 1 + X, phy = phy, data = sim.dat)

      meanEsts.n[rep, ] &lt;- c(z$B[2], z$s2, z$P.H0.s2, z$convergeflag == "converged")
  }
converged &lt;- meanEsts.n[,4]
meanEsts &lt;- rbind(meanEsts,
                  c(n, mean(meanEsts.n[converged==1,1]),
                            mean(meanEsts.n[converged==1,2]),
                            mean(meanEsts.n[converged==1, 3] &lt; 0.05),
                            mean(converged)))
}
meanEsts

# Results output for B1 = 0.5, s2 = 0.4; n-Inf gives the values used to
# simulate the data
#    n       B1        s2      Pr.s2 propconverged
# 1 Inf 1.000000 0.4000000 1.00000000         1.000
# 2 160 1.012719 0.4479946 0.36153072         0.993
# 3  80 1.030876 0.5992027 0.24623116         0.995
# 4  40 1.110201 0.7425203 0.13373860         0.987
# 5  20 1.249886 0.8774708 0.05727377         0.873


## Examine type I errors for estimates of B0 and s2 from binaryPGLMM()
# with simulated data. Note that this will take a while.

Reps = 1000

s2 &lt;- 0
B0 &lt;- 0
B1 &lt;- 0

H0.tests &lt;- data.frame(n = Inf, B0 = B0, s2 = s2, Pr.B0 = .05,
                       Pr.s2 = .05, propconverged = 1)
for (n in c(160, 80, 40, 20)) {

  ests.n &lt;- data.frame(B1 = 0, s2 = 0, Pr.B0 = 0, Pr.s2 = 0, convergefailure = 0)
  for (rep in 1:Reps) {
    phy &lt;- compute.brlen(rtree(n = n), method = "Grafen", power = 1)
    X &lt;- rTraitCont(phy, model = "BM", sigma = 1)
    X &lt;- (X - mean(X))/var(X)

    sim.dat &lt;- data.frame(Y = array(0, dim = n), X = X, row.names = phy$tip.label)
    sim &lt;- binaryPGLMM.sim(Y ~ 1, phy = phy, data = sim.dat, s2 = s2,
                           B = matrix(B0, nrow = 1, ncol = 1), nrep = 1)
    sim.dat$Y &lt;- sim$Y

    z &lt;- binaryPGLMM(Y ~ 1, phy = phy, data = sim.dat)

    ests.n[rep, ] &lt;- c(z$B[1], z$s2, z$B.pvalue, z$P.H0.s2, z$convergeflag == "converged")
  }

converged &lt;- ests.n[,5]
H0.tests &lt;- rbind(H0.tests,
                  c(n, mean(ests.n[converged==1,1]),
                    mean(ests.n[converged==1,2]),
                    mean(ests.n[converged==1, 3] &lt; 0.05),
                    mean(ests.n[converged==1, 4] &lt; 0.05),
                    mean(converged)))
}
H0.tests

# Results for type I errors for B0 = 0 and s2 = 0; n-Inf gives the values
# used to simulate the data. These results show that binaryPGLMM() tends to
# have lower-than-nominal p-values; fewer than 0.05 of the simulated
# data sets have H0:B0=0 and H0:s2=0 rejected at the alpha=0.05 level.
#     n            B0         s2      Pr.B0      Pr.s2 propconverged
# 1 Inf  0.0000000000 0.00000000 0.05000000 0.05000000         1.000
# 2 160 -0.0009350357 0.07273163 0.02802803 0.04804805         0.999
# 3  80 -0.0085831477 0.12205876 0.04004004 0.03403403         0.999
# 4  40  0.0019303847 0.25486307 0.02206620 0.03711133         0.997
# 5  20  0.0181394905 0.45949266 0.02811245 0.03313253         0.996

## End(Not run)</code></pre>

<hr>
<h2 id='bind.tree'>Binds Trees</h2><span id='topic+bind.tree'></span><span id='topic++2B.phylo'></span>

<h3>Description</h3>

<p>This function binds together two phylogenetic trees to give a single
object of class <code>"phylo"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind.tree(x, y, where = "root", position = 0, interactive = FALSE)
x + y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind.tree_+3A_x">x</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="bind.tree_+3A_y">y</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="bind.tree_+3A_where">where</code></td>
<td>
<p>an integer giving the number of the node or tip of the
tree <code>x</code> where the tree <code>y</code> is binded (<code>"root"</code> is a
short-cut for the root).</p>
</td></tr>
<tr><td><code id="bind.tree_+3A_position">position</code></td>
<td>
<p>a numeric value giving the position from the tip or
node given by <code>node</code> where the tree <code>y</code> is binded;
negative values are ignored.</p>
</td></tr>
<tr><td><code id="bind.tree_+3A_interactive">interactive</code></td>
<td>
<p>if <code>TRUE</code> the user is asked to choose the tip
or node of <code>x</code> by clicking on the tree which must be plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>x</code> can be seen as the receptor tree, whereas
<code>y</code> is the donor tree. The root of <code>y</code> is then grafted on a
location of <code>x</code> specified by <code>where</code> and, possibly,
<code>position</code>. If <code>y</code> has a root edge, this is added as in
internal branch in the resulting tree.
</p>
<p><code>x + y</code> is a shortcut for:
</p>
<pre>
    bind.tree(x, y, position = if (is.null(x$root.edge)) 0 else
    x$root.edge)
  </pre>
<p>If only one of the trees has no branch length, the branch lengths of
the other one are ignored with a warning.
</p>
<p>If one (or both) of the trees has no branch length, it is possible to
specify a value of 'position' to graft 'y' below the node of 'x'
specified by 'where'. In this case, the exact value of 'position' is
not important as long as it is greater than zero. The new node will be
multichotomous if 'y' has no root edge. This can be solved by giving
an arbitrary root edge to 'y' beforehand (e.g., <code>y$root.edge &lt;-
  1</code>): it will be deleted during the binding operation.
</p>


<h3>Value</h3>

<p>an object of class <code>"phylo"</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+drop.tip">drop.tip</a></code>, <code><a href="#topic+root">root</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### binds the two clades of bird orders
treefile1 &lt;- tempfile("tree", fileext = ".tre")
treefile2 &lt;- tempfile("tree", fileext = ".tre")
cat("((Struthioniformes:21.8,Tinamiformes:21.8):4.1,",
    "((Craciformes:21.6,Galliformes:21.6):1.3,Anseriformes:22.9):3.0):2.1;",
    file = treefile1, sep = "\n")
cat("(Turniciformes:27.0,(Piciformes:26.3,((Galbuliformes:24.4,",
    "((Bucerotiformes:20.8,Upupiformes:20.8):2.6,",
    "(Trogoniformes:22.1,Coraciiformes:22.1):1.3):1.0):0.6,",
    "(Coliiformes:24.5,(Cuculiformes:23.7,(Psittaciformes:23.1,",
    "(((Apodiformes:21.3,Trochiliformes:21.3):0.6,",
    "(Musophagiformes:20.4,Strigiformes:20.4):1.5):0.6,",
    "((Columbiformes:20.8,(Gruiformes:20.1,Ciconiiformes:20.1):0.7):0.8,",
    "Passeriformes:21.6):0.9):0.6):0.6):0.8):0.5):1.3):0.7):1.0;",
    file = treefile2, sep = "\n")
tree.bird1 &lt;- read.tree(treefile1)
tree.bird2 &lt;- read.tree(treefile2)
unlink(c(treefile1, treefile2)) # clean-up
(birds &lt;- tree.bird1 + tree.bird2)
layout(matrix(c(1, 2, 3, 3), 2, 2))
plot(tree.bird1)
plot(tree.bird2)
plot(birds)

### examples with random trees
x &lt;- rtree(4, tip.label = LETTERS[1:4])
y &lt;- rtree(4, tip.label = LETTERS[5:8])
x &lt;- makeNodeLabel(x, prefix = "x_")
y &lt;- makeNodeLabel(y, prefix = "y_")
x$root.edge &lt;- y$root.edge &lt;- .2

z &lt;- bind.tree(x, y, po=.2)
plot(y, show.node.label = TRUE, font = 1, root.edge = TRUE)
title("y")
plot(x, show.node.label = TRUE, font = 1, root.edge = TRUE)
title("x")
plot(z, show.node.label = TRUE, font = 1, root.edge = TRUE)
title("z &lt;- bind.tree(x, y, po=.2)")

## make sure the terminal branch length is long enough:
x$edge.length[x$edge[, 2] == 2] &lt;- 0.2

z &lt;- bind.tree(x, y, 2, .1)
plot(y, show.node.label = TRUE, font = 1, root.edge = TRUE)
title("y")
plot(x, show.node.label = TRUE, font = 1, root.edge = TRUE)
title("x")
plot(z, show.node.label = TRUE, font = 1, root.edge = TRUE)
title("z &lt;- bind.tree(x, y, 2, .1)")

x &lt;- rtree(50)
y &lt;- rtree(50)
x$root.edge &lt;- y$root.edge &lt;- .2
z &lt;- x + y
plot(y, show.tip.label = FALSE, root.edge = TRUE); axisPhylo()
title("y")
plot(x, show.tip.label = FALSE, root.edge = TRUE); axisPhylo()
title("x")
plot(z, show.tip.label = FALSE, root.edge = TRUE); axisPhylo()
title("z &lt;- x + y")
layout(1)
</code></pre>

<hr>
<h2 id='BIONJ'>
Tree Estimation Based on an Improved Version of the NJ Algorithm
</h2><span id='topic+bionj'></span>

<h3>Description</h3>

<p>This function performs the BIONJ algorithm of Gascuel (1997).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bionj(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BIONJ_+3A_x">X</code></td>
<td>
<p>a distance matrix; may be an object of class <code>"dist"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"phylo"</code>.
</p>


<h3>Author(s)</h3>

<p>original C code by Hoa Sien Cuong and Olivier Gascuel; adapted and
ported to <span class="rlang"><b>R</b></span> by Vincent Lefort <a href="mailto:vincent.lefort@lirmm.fr">vincent.lefort@lirmm.fr</a>
</p>


<h3>References</h3>

<p>Gascuel, O. (1997) BIONJ: an improved version of the NJ algorithm
based on a simple model of sequence data.
<em>Molecular Biology and Evolution</em>, <b>14:</b>, 685&ndash;695.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nj">nj</a></code>, <code><a href="#topic+fastme">fastme</a></code>, <code><a href="#topic+mvr">mvr</a></code>,
<code><a href="#topic+bionjs">bionjs</a></code>, <code><a href="#topic+SDM">SDM</a></code>, <code><a href="#topic+dist.dna">dist.dna</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### From Saitou and Nei (1987, Table 1):
x &lt;- c(7, 8, 11, 13, 16, 13, 17, 5, 8, 10, 13,
       10, 14, 5, 7, 10, 7, 11, 8, 11, 8, 12,
       5, 6, 10, 9, 13, 8)
M &lt;- matrix(0, 8, 8)
M[lower.tri(M)] &lt;- x
M &lt;- t(M)
M[lower.tri(M)] &lt;- x
dimnames(M) &lt;- list(1:8, 1:8)
tr &lt;- bionj(M)
plot(tr, "u")
### a less theoretical example
data(woodmouse)
trw &lt;- bionj(dist.dna(woodmouse))
plot(trw)
</code></pre>

<hr>
<h2 id='bird.families'>Phylogeny of the Families of Birds From Sibley and Ahlquist</h2><span id='topic+bird.families'></span>

<h3>Description</h3>

<p>This data set describes the phylogenetic relationships of the families
of birds as reported by Sibley and Ahlquist (1990). Sibley and
Ahlquist inferred this phylogeny from an extensive number of DNA/DNA
hybridization experiments. The &ldquo;tapestry&rdquo; reported by these two
authors (more than 1000 species out of the ca. 9000 extant bird
species) generated a lot of debates.
</p>
<p>The present tree is based on the relationships among families. A few
families were not included in the figures in Sibley and Ahlquist, and
thus are not included here as well. The branch lengths were calculated
from the values of <code class="reqn">\Delta T_{50}H</code> as found in Sibley
and Ahlquist (1990, figs. 354, 355, 356, and 369).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bird.families)
</code></pre>


<h3>Format</h3>

<p>The data are stored as an object of class <code>"phylo"</code> which
structure is described in the help page of the function
<code><a href="#topic+read.tree">read.tree</a></code>.
</p>


<h3>Source</h3>

<p>Sibley, C. G. and Ahlquist, J. E. (1990) Phylogeny and classification
of birds: a study in molecular evolution. New Haven: Yale University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.tree">read.tree</a></code>, <code><a href="#topic+bird.orders">bird.orders</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bird.families)
op &lt;- par(cex = 0.3)
plot(bird.families)
par(op)
</code></pre>

<hr>
<h2 id='bird.orders'>Phylogeny of the Orders of Birds From Sibley and Ahlquist</h2><span id='topic+bird.orders'></span>

<h3>Description</h3>

<p>This data set describes the phylogenetic relationships of the orders
of birds as reported by Sibley and Ahlquist (1990). Sibley and
Ahlquist inferred this phylogeny from an extensive number of DNA/DNA
hybridization experiments. The &ldquo;tapestry&rdquo; reported by these two
authors (more than 1000 species out of the ca. 9000 extant bird
species) generated a lot of debates.
</p>
<p>The present tree is based on the relationships among orders. The
branch lengths were calculated from the values of <code class="reqn">\Delta
    T_{50}H</code> as found in Sibley and Ahlquist (1990,
fig. 353).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bird.orders)
</code></pre>


<h3>Format</h3>

<p>The data are stored as an object of class <code>"phylo"</code> which
structure is described in the help page of the function
<code><a href="#topic+read.tree">read.tree</a></code>.
</p>


<h3>Source</h3>

<p>Sibley, C. G. and Ahlquist, J. E. (1990) Phylogeny and classification
of birds: a study in molecular evolution. New Haven: Yale University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.tree">read.tree</a></code>, <code><a href="#topic+bird.families">bird.families</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bird.orders)
plot(bird.orders)
</code></pre>

<hr>
<h2 id='birthdeath'>Estimation of Speciation and Extinction Rates With Birth-Death Models</h2><span id='topic+birthdeath'></span><span id='topic+print.birthdeath'></span>

<h3>Description</h3>

<p>This function fits by maximum likelihood a birth-death model to the
branching times computed from a phylogenetic tree using the method of
Nee et al. (1994).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>birthdeath(phy)
## S3 method for class 'birthdeath'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="birthdeath_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="birthdeath_+3A_x">x</code></td>
<td>
<p>an object of class <code>"birthdeath"</code>.</p>
</td></tr>
<tr><td><code id="birthdeath_+3A_...">...</code></td>
<td>
<p>further arguments passed to the <code>print</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Nee et al. (1994) used a re-parametrization of the birth-death model
studied by Kendall (1948) so that the likelihood has to be maximized
over <em>d/b</em> and <em>b - d</em>, where <em>b</em> is the birth rate,
and <em>d</em> the death rate. This is the approach used by the present
function.
</p>
<p>This function computes the standard-errors of the estimated parameters
using a normal approximations of the maximum likelihood estimates:
this is likely to be inaccurate because of asymmetries of the
likelihood function (Nee et al. 1995). In addition, 95 
intervals of both parameters are computed using profile likelihood:
they are particularly useful if the estimate of <em>d/b</em> is at the
boundary of the parameter space (i.e. 0, which is often the case).
</p>
<p>Note that the function does not check that the tree is effectively
ultrametric, so if it is not, the returned result may not be meaningful.
</p>


<h3>Value</h3>

<p>An object of class <code>"birthdeath"</code> which is a list with the
following components:
</p>
<table>
<tr><td><code>tree</code></td>
<td>
<p>the name of the tree analysed.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>the number of species.</p>
</td></tr>
<tr><td><code>dev</code></td>
<td>
<p>the deviance (= -2 log lik) at its minimum.</p>
</td></tr>
<tr><td><code>para</code></td>
<td>
<p>the estimated parameters.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>the corresponding standard-errors.</p>
</td></tr>
<tr><td><code>CI</code></td>
<td>
<p>the 95% profile-likelihood confidence intervals.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Kendall, D. G. (1948) On the generalized &ldquo;birth-and-death&rdquo;
process. <em>Annals of Mathematical Statistics</em>, <b>19</b>, 1&ndash;15.
</p>
<p>Nee, S., May, R. M. and Harvey, P. H. (1994) The reconstructed
evolutionary process. <em>Philosophical Transactions of the Royal
Society of London. Series B. Biological Sciences</em>, <b>344</b>, 305&ndash;311.
</p>
<p>Nee, S., Holmes, E. C., May, R. M. and Harvey, P. H. (1995) Estimating
extinctions from molecular phylogenies. in <em>Extinction Rates</em>,
eds. Lawton, J. H. and May, R. M., pp. 164&ndash;182, Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+branching.times">branching.times</a></code>, <code><a href="#topic+diversi.gof">diversi.gof</a></code>,
<code><a href="#topic+diversi.time">diversi.time</a></code>, <code><a href="#topic+ltt.plot">ltt.plot</a></code>,
<code><a href="#topic+yule">yule</a></code>, <code><a href="#topic+bd.ext">bd.ext</a></code>, <code><a href="#topic+yule.cov">yule.cov</a></code>,
<code><a href="#topic+bd.time">bd.time</a></code>
</p>

<hr>
<h2 id='boot.phylo'>Tree Bipartition and Bootstrapping Phylogenies</h2><span id='topic+boot.phylo'></span><span id='topic+prop.part'></span><span id='topic+prop.clades'></span><span id='topic+print.prop.part'></span><span id='topic+summary.prop.part'></span><span id='topic+plot.prop.part'></span>

<h3>Description</h3>

<p>These functions analyse bipartitions found in a series of trees.
</p>
<p><code>prop.part</code> counts the number of bipartitions found in a series
of trees given as <code>...</code>. If a single tree is passed, the
returned object is a list of vectors with the tips descending from
each node (i.e., clade compositions indexed by node number).
</p>
<p><code>prop.clades</code> counts the number of times the bipartitions present
in <code>phy</code> are present in a series of trees given as <code>...</code> or
in the list previously computed and given with <code>part</code>.
</p>
<p><code>boot.phylo</code> performs a bootstrap analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.phylo(phy, x, FUN, B = 100, block = 1,
           trees = FALSE, quiet = FALSE,
           rooted = is.rooted(phy), jumble = TRUE,
            mc.cores = 1)
prop.part(..., check.labels = TRUE)
prop.clades(phy, ..., part = NULL, rooted = FALSE)
## S3 method for class 'prop.part'
print(x, ...)
## S3 method for class 'prop.part'
summary(object, ...)
## S3 method for class 'prop.part'
plot(x, barcol = "blue", leftmar = 4, col = "red", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.phylo_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="boot.phylo_+3A_x">x</code></td>
<td>
<p>in the case of <code>boot.phylo</code>: a taxa (rows) by characters
(columns) matrix; in the case of <code>print</code> and <code>plot</code>: an
object of class <code>"prop.part"</code>.</p>
</td></tr>
<tr><td><code id="boot.phylo_+3A_fun">FUN</code></td>
<td>
<p>the function used to estimate <code>phy</code> (see details).</p>
</td></tr>
<tr><td><code id="boot.phylo_+3A_b">B</code></td>
<td>
<p>the number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="boot.phylo_+3A_block">block</code></td>
<td>
<p>the number of columns in <code>x</code> that will be resampled
together (see details).</p>
</td></tr>
<tr><td><code id="boot.phylo_+3A_trees">trees</code></td>
<td>
<p>a logical specifying whether to return the bootstraped
trees (<code>FALSE</code> by default).</p>
</td></tr>
<tr><td><code id="boot.phylo_+3A_quiet">quiet</code></td>
<td>
<p>a logical: a progress bar is displayed by default.</p>
</td></tr>
<tr><td><code id="boot.phylo_+3A_rooted">rooted</code></td>
<td>
<p>a logical specifying whether the trees should be treated
as rooted or not.</p>
</td></tr>
<tr><td><code id="boot.phylo_+3A_jumble">jumble</code></td>
<td>
<p>a logical value. By default, the rows of <code>x</code> are
randomized to avoid artificially too large bootstrap values
associated with very short branches.</p>
</td></tr>
<tr><td><code id="boot.phylo_+3A_mc.cores">mc.cores</code></td>
<td>
<p>the number of cores (CPUs) to be used (passed to
<span class="pkg">parallel</span>).</p>
</td></tr>
<tr><td><code id="boot.phylo_+3A_...">...</code></td>
<td>
<p>either (i) a single object of class <code>"phylo"</code>, (ii) a
series of such objects separated by commas, or (iii) a list
containing such objects. In the case of <code>plot</code> further
arguments for the plot (see details).</p>
</td></tr>
<tr><td><code id="boot.phylo_+3A_check.labels">check.labels</code></td>
<td>
<p>a logical specifying whether to check the labels
of each tree. If <code>FALSE</code>, it is assumed that all trees have the
same tip labels, and that they are in the same order (see details).</p>
</td></tr>
<tr><td><code id="boot.phylo_+3A_part">part</code></td>
<td>
<p>a list of partitions as returned by <code>prop.part</code>; if
this is used then <code>...</code> is ignored.</p>
</td></tr>
<tr><td><code id="boot.phylo_+3A_object">object</code></td>
<td>
<p>an object of class <code>"prop.part"</code>.</p>
</td></tr>
<tr><td><code id="boot.phylo_+3A_barcol">barcol</code></td>
<td>
<p>the colour used for the bars displaying the number of
partitions in the upper panel.</p>
</td></tr>
<tr><td><code id="boot.phylo_+3A_leftmar">leftmar</code></td>
<td>
<p>the size of the margin on the left to display the tip
labels.</p>
</td></tr>
<tr><td><code id="boot.phylo_+3A_col">col</code></td>
<td>
<p>the colour used to visualise the bipartitions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>FUN</code> in <code>boot.phylo</code> must be the function used
to estimate the tree from the original data matrix. Thus, if the tree
was estimated with neighbor-joining (see <code>nj</code>), one maybe wants
something like <code>FUN = function(xx) nj(dist.dna(xx))</code>.
</p>
<p><code>block</code> in <code>boot.phylo</code> specifies the number of columns to
be resampled altogether. For instance, if one wants to resample at the
codon-level, then <code>block = 3</code> must be used.
</p>
<p>Using <code>check.labels = FALSE</code> in <code>prop.part</code> decreases
computing times. This requires that (i) all trees have the same tip
labels, <em>and</em> (ii) these labels are ordered similarly in all
trees (in other words, the element <code>tip.label</code> are identical in
all trees).
</p>
<p>The plot function represents a contingency table of the different
partitions (on the <em>x</em>-axis) in the lower panel, and their observed
numbers in the upper panel. Any further arguments (...) are used to
change the aspects of the points in the lower panel: these may be
<code>pch</code>, <code>col</code>, <code>bg</code>, <code>cex</code>, etc. This function
works only if there is an attribute <code>labels</code> in the object.
</p>
<p>The print method displays the partitions and their numbers. The
summary method extracts the numbers only.
</p>


<h3>Value</h3>

<p><code>prop.part</code> returns an object of class <code>"prop.part"</code> which
is a list with an attribute <code>"number"</code>. The elements of this list
are the observed clades, and the attribute their respective
numbers. If the default <code>check.labels = FALSE</code> is used, an
attribute <code>"labels"</code> is added, and the vectors of the returned
object contains the indices of these labels instead of the labels
themselves.
</p>
<p><code>prop.clades</code> and <code>boot.phylo</code> return a numeric vector
which <em>i</em>th element is the number associated to the <em>i</em>th
node of <code>phy</code>. If <code>trees = TRUE</code>, <code>boot.phylo</code> returns
a list whose first element (named <code>"BP"</code>) is like before, and the
second element (<code>"trees"</code>) is a list with the bootstraped
trees.
</p>
<p><code>summary</code> returns a numeric vector.
</p>


<h3>Note</h3>

<p><code>prop.clades</code> calls internally <code>prop.part</code> with the option
<code>check.labels = TRUE</code>, which may be very slow. If the trees
passed as <code>...</code> fulfills conditions (i) and (ii) above, then it
might be faster to first call, e.g., <code>pp &lt;- prop.part(...)</code>, then
use the option <code>part</code>: <code>prop.clades(phy, part = pp)</code>.
</p>
<p>Since <span class="pkg">ape</span> 3.5, <code>prop.clades</code> should return sensible results
for all values of <code>rooted</code>: if <code>FALSE</code>, the numbers of
bipartitions (or splits); if <code>TRUE</code>, the number of clades (of
hopefully rooted trees).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Efron, B., Halloran, E. and Holmes, S. (1996) Bootstrap confidence
levels for phylogenetic trees. <em>Proceedings of the National
Academy of Sciences USA</em>, <b>93</b>, 13429&ndash;13434.
</p>
<p>Felsenstein, J. (1985) Confidence limits on phylogenies: an approach
using the bootstrap. <em>Evolution</em>, <b>39</b>, 783&ndash;791.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.bitsplits">as.bitsplits</a></code>, <code><a href="#topic+dist.topo">dist.topo</a></code>,
<code><a href="#topic+consensus">consensus</a></code>, <code><a href="#topic+nodelabels">nodelabels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
f &lt;- function(x) nj(dist.dna(x))
tr &lt;- f(woodmouse)
### Are bootstrap values stable?
for (i in 1:5)
  print(boot.phylo(tr, woodmouse, f, quiet = TRUE))
### How many partitions in 100 random trees of 10 labels?...
TR &lt;- rmtree(100, 10)
pp10 &lt;- prop.part(TR)
length(pp10)
### ... and in 100 random trees of 20 labels?
TR &lt;- rmtree(100, 20)
pp20 &lt;- prop.part(TR)
length(pp20)
plot(pp10, pch = "x", col = 2)
plot(pp20, pch = "x", col = 2)

set.seed(2)
tr &lt;- rtree(10) # rooted
## the following used to return a wrong result with ape &lt;= 3.4:
prop.clades(tr, tr)
prop.clades(tr, tr, rooted = TRUE)
tr &lt;- rtree(10, rooted = FALSE)
prop.clades(tr, tr) # correct

### an illustration of the use of prop.clades with bootstrap trees:

fun &lt;- function(x) as.phylo(hclust(dist.dna(x), "average")) # upgma() in phangorn
tree &lt;- fun(woodmouse)
## get 100 bootstrap trees:
bstrees &lt;- boot.phylo(tree, woodmouse, fun, trees = TRUE)$trees
## get proportions of each clade:
clad &lt;- prop.clades(tree, bstrees, rooted = TRUE)
## get proportions of each bipartition:
boot &lt;- prop.clades(tree, bstrees)
layout(1)
par(mar = rep(2, 4))
plot(tree, main = "Bipartition vs. Clade Support Values")
drawSupportOnEdges(boot)
nodelabels(clad)
legend("bottomleft", legend = c("Bipartitions", "Clades"), pch = 22,
       pt.bg = c("green", "lightblue"), pt.cex = 2.5)

## Not run: 
## an example of double bootstrap:
nrep1 &lt;- 100
nrep2 &lt;- 100
p &lt;- ncol(woodmouse)
DB &lt;- 0

for (b in 1:nrep1) {
    X &lt;- woodmouse[, sample(p, p, TRUE)]
    DB &lt;- DB + boot.phylo(tr, X, f, nrep2, quiet = TRUE)
}
DB
## to compare with:
boot.phylo(tr, woodmouse, f, 1e4)

## End(Not run)
</code></pre>

<hr>
<h2 id='branching.times'>Branching Times of a Phylogenetic Tree</h2><span id='topic+branching.times'></span>

<h3>Description</h3>

<p>This function computes the branching times of a phylogenetic tree,
that is the distance from each node to the tips, under the assumption that
the tree is ultrametric. Note that the function does not check that the
tree is effectively ultrametric, so if it is not, the returned result
may not be meaningful.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>branching.times(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="branching.times_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector with the branching times. If the phylogeny <code>phy</code>
has an element <code>node.label</code>, this is used as names for the
returned vector; otherwise the numbers (of mode character) of the
matrix <code>edge</code> of <code>phy</code> are used as names.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.ultrametric">is.ultrametric</a></code>
</p>

<hr>
<h2 id='c.phylo'>Building Lists of Trees</h2><span id='topic+c.phylo'></span><span id='topic+c.multiPhylo'></span><span id='topic+.compressTipLabel'></span><span id='topic+.uncompressTipLabel'></span>

<h3>Description</h3>

<p>These functions help to build lists of trees of class <code>"multiPhylo"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phylo'
c(..., recursive = TRUE)
## S3 method for class 'multiPhylo'
c(..., recursive = TRUE)
.compressTipLabel(x, ref = NULL)
.uncompressTipLabel(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c.phylo_+3A_...">...</code></td>
<td>
<p>one or several objects of class <code>"phylo"</code> and/or
<code>"multiPhylo"</code>.</p>
</td></tr>
<tr><td><code id="c.phylo_+3A_recursive">recursive</code></td>
<td>
<p>see details.</p>
</td></tr>
<tr><td><code id="c.phylo_+3A_x">x</code></td>
<td>
<p>an object of class <code>"phylo"</code> or <code>"multiPhylo"</code>.</p>
</td></tr>
<tr><td><code id="c.phylo_+3A_ref">ref</code></td>
<td>
<p>an optional vector of mode character to constrain the order
of the tips. By default, the order from the first tree is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These <code>c</code> methods check all the arguments, and return by default
a list of single trees unless some objects are not trees or lists of
trees, in which case <code>recursive</code> is switched to FALSE and a
warning message is given. If <code>recursive = FALSE</code>, the objects are
simply concatenated into a list. Before <span class="pkg">ape</span> 4.0, <code>recursive</code>
was always set to FALSE.
</p>
<p><code>.compressTipLabel</code> transforms an object of class
<code>"multiPhylo"</code> by checking that all trees have the same tip
labels and renumbering the tips in the <code>edge</code> matrix so that the
tip numbers are also the same taking the first tree as the reference
(duplicated labels are not allowed). The returned object has a unique
vector of tip labels (<code>attr(x, "TipLabel")</code>).
</p>
<p><code>.uncompressTipLabel</code> does the reverse operation.
</p>


<h3>Value</h3>

<p>An object of class <code>"multiPhylo"</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.phylo">summary.phylo</a></code>, <code><a href="#topic+multiphylo">multiphylo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(rtree(4), rtree(2))
x
y &lt;- c(rtree(4), rtree(4))
z &lt;- c(x, y)
z
print(z, TRUE)
try(.compressTipLabel(x)) # error
a &lt;- .compressTipLabel(y)
.uncompressTipLabel(a) # back to y
## eventually compare str(a) and str(y)
</code></pre>

<hr>
<h2 id='CADM.global'> Congruence among distance matrices </h2><span id='topic+CADM'></span><span id='topic+CADM.global'></span><span id='topic+CADM.post'></span>

<h3>Description</h3>

<p>Function <code><a href="#topic+CADM.global">CADM.global</a></code> compute and test the coefficient of concordance among several distance matrices through a permutation test.
</p>
<p>Function <code><a href="#topic+CADM.post">CADM.post</a></code> carries out a posteriori permutation tests of the contributions of individual distance matrices to the overall concordance of the group.
</p>
<p>Use in phylogenetic analysis: to identify congruence among distance matrices (D) representing different genes or different types of data. Congruent D matrices correspond to data tables that can be used together in a combined phylogenetic or other type of multivariate analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CADM.global(Dmat, nmat, n, nperm=99, make.sym=TRUE, weights=NULL,
            silent=FALSE)
CADM.post  (Dmat, nmat, n, nperm=99, make.sym=TRUE, weights=NULL,
             mult="holm", mantel=FALSE, silent=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CADM.global_+3A_dmat">Dmat</code></td>
<td>
<p> A text file listing the distance matrices one after the other, with or without blank lines in-between. Each matrix is in the form of a square distance matrix with 0's on the diagonal. </p>
</td></tr>
<tr><td><code id="CADM.global_+3A_nmat">nmat</code></td>
<td>
<p> Number of distance matrices in file Dmat. </p>
</td></tr>
<tr><td><code id="CADM.global_+3A_n">n</code></td>
<td>
<p> Number of objects in each distance matrix. All matrices must have the same number of objects. </p>
</td></tr>
<tr><td><code id="CADM.global_+3A_nperm">nperm</code></td>
<td>
<p> Number of permutations for the tests of significance. </p>
</td></tr>
<tr><td><code id="CADM.global_+3A_make.sym">make.sym</code></td>
<td>
<p> TRUE: turn asymmetric matrices into symmetric matrices by averaging the two triangular portions. FALSE: analyse asymmetric matrices as they are. </p>
</td></tr>
<tr><td><code id="CADM.global_+3A_weights">weights</code></td>
<td>
<p> A vector of positive weights for the distance matrices. Example: weights = c(1,2,3). NULL (default): all matrices have same weight in the calculation of W. </p>
</td></tr>
<tr><td><code id="CADM.global_+3A_mult">mult</code></td>
<td>
<p> Method for correcting P-values in multiple testing. The methods are &quot;holm&quot; (default), &quot;sidak&quot;, and &quot;bonferroni&quot;. The Bonferroni correction is overly conservative; it is not recommended. It is included to allow comparisons with the other methods. </p>
</td></tr>
<tr><td><code id="CADM.global_+3A_mantel">mantel</code></td>
<td>
<p> TRUE: Mantel statistics will be computed from ranked distances, as well as permutational P-values. FALSE (default): Mantel statistics and tests will not be computed. </p>
</td></tr>
<tr><td><code id="CADM.global_+3A_silent">silent</code></td>
<td>
<p> TRUE: informative messages will not be printed, but stopping messages will. Option useful for simulation work. FALSE: informative messages will be printed. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Dmat</code> must contain two or more distance matrices, listed one after the other, all of the same size, and corresponding to the same objects in the same order. Raw data tables can be transformed into distance matrices before comparison with other such distance matrices, or with data that have been obtained as distance matrices, e.g. serological or DNA hybridization data. The distances will be transformed to ranks before computation of the coefficient of concordance and other statistics.
</p>
<p><code>CADM.global</code> tests the global null hypothesis that all matrices are incongruent. If the global null is rejected, function <code>CADM.post</code> can be used to identify the concordant (H0 rejected) and discordant matrices (H0 not rejected) in the group. If a distance matrix has a negative value for the <code>Mantel.mean</code> statistic, that matrix clearly does not belong to the group. Remove that matrix (if there are more than one, remove first the matrix that has the most strongly negative value for <code>Mantel.mean</code>) and run the analysis again.
</p>
<p>The corrections used for multiple testing are applied to the list of P-values (P) produced in the a posteriori tests; they take into account the number of tests (k) carried out simulatenously (number of matrices, parameter <code>nmat</code>).
</p>
<p>The Holm correction is computed after ordering the P-values in a list with the smallest value to the left. Compute adjusted P-values as:
</p>
<p style="text-align: center;"><code class="reqn">P_{corr} = (k-i+1)*P</code>
</p>

<p>where i is the position in the ordered list. Final step: from left to right, if an adjusted <code class="reqn">P_{corr}</code> in the ordered list is smaller than the one occurring at its left, make the smallest one equal to the largest one.
</p>
<p>The Sidak correction is:
</p>
<p style="text-align: center;"><code class="reqn">P_{corr} = 1 - (1 - P)^k</code>
</p>

<p>The Bonferonni correction is:
</p>
<p style="text-align: center;"><code class="reqn">P_{corr} = k*P</code>
</p>



<h3>Value</h3>

<p><code>CADM.global</code> produces a small table containing the W, Chi2, and Prob.perm statistics described in the following list.
<code>CADM.post</code> produces a table stored in element <code>A_posteriori_tests</code>, containing Mantel.mean, Prob, and Corrected.prob statistics in rows; the columns correspond to the k distance matrices under study, labeled Dmat.1 to Dmat.k.
If parameter <code>mantel</code> is TRUE, tables of Mantel statistics and P-values are computed among the matrices.
</p>
<table>
<tr><td><code>W</code></td>
<td>
<p>Kendall's coefficient of concordance, W (Kendall and Babington Smith 1939; see also Legendre 2010). </p>
</td></tr>
<tr><td><code>Chi2</code></td>
<td>
<p>Friedman's chi-square statistic (Friedman 1937) used in the permutation test of W. </p>
</td></tr>
<tr><td><code>Prob.perm</code></td>
<td>
<p>Permutational probability. </p>
</td></tr>
<tr><td><code>Mantel.mean</code></td>
<td>
<p>Mean of the Mantel correlations, computed on rank-transformed distances, between the distance matrix under test and all the other matrices in the study. </p>
</td></tr>
<tr><td><code>Prob</code></td>
<td>
<p>Permutational probabilities, uncorrected. </p>
</td></tr>
<tr><td><code>Corrected prob</code></td>
<td>
<p>Permutational probabilities corrected using the method selected in parameter <code>mult</code>. </p>
</td></tr>
<tr><td><code>Mantel.cor</code></td>
<td>
<p>Matrix of Mantel correlations, computed on rank-transformed distances, among the distance matrices. </p>
</td></tr>
<tr><td><code>Mantel.prob</code></td>
<td>
<p>One-tailed P-values associated with the Mantel correlations of the previous table. The probabilities are computed in the right-hand tail. H0 is tested against the alternative one-tailed hypothesis that the Mantel correlation under test is positive. No correction is made for multiple testing. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pierre Legendre, Universite de Montreal</p>


<h3>References</h3>

<p>Campbell, V., Legendre, P. and Lapointe, F.-J. (2009) Assessing congruence among ultrametric distance matrices. <em>Journal of Classification</em>, <b>26</b>, 103&ndash;117.
</p>
<p>Campbell, V., Legendre, P. and Lapointe, F.-J. (2011) The performance of the Congruence Among Distance Matrices (CADM) test in phylogenetic analysis. <em>BMC Evolutionary Biology</em>, <b>11</b>, 64.
</p>
<p>Friedman, M. (1937) The use of ranks to avoid the assumption of normality implicit in the analysis of variance. <em>Journal of the American Statistical Association</em>, <b>32</b>, 675&ndash;701.
</p>
<p>Kendall, M. G. and Babington Smith, B. (1939) The problem of m rankings. <em>Annals of Mathematical Statistics</em>, <b>10</b>, 275&ndash;287.
</p>
<p>Lapointe, F.-J., Kirsch, J. A. W. and Hutcheon, J. M. (1999) Total evidence, consensus, and bat phylogeny: a distance-based approach. <em>Molecular Phylogenetics and Evolution</em>, <b>11</b>, 55&ndash;66.
</p>
<p>Legendre, P. (2010) Coefficient of concordance. Pp. 164-169 in: Encyclopedia of Research Design, Vol. 1. N. J. Salkind, ed. SAGE Publications, Inc., Los Angeles.
</p>
<p>Legendre, P. and Lapointe, F.-J. (2004) Assessing congruence among distance matrices: single malt Scotch whiskies
revisited. <em>Australian and New Zealand Journal of Statistics</em>, <b>46</b>, 615&ndash;629.
</p>
<p>Legendre, P. and Lapointe, F.-J. (2005) Congruence entre matrices de distance. P. 178-181 in: Makarenkov, V., G. Cucumel et F.-J. Lapointe [eds] Comptes rendus des 12emes Rencontres de la Societe Francophone de Classification, Montreal, 30 mai - 1er juin 2005.
</p>
<p>Siegel, S. and Castellan, N. J., Jr. (1988) <em>Nonparametric statistics for the behavioral sciences. 2nd edition</em>. New York: McGraw-Hill.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Examples 1 and 2: 5 genetic distance matrices computed from simulated DNA
# sequences representing 50 taxa having evolved along additive trees with
# identical evolutionary parameters (GTR+ Gamma + I). Distance matrices were
# computed from the DNA sequence matrices using a p distance corrected with the
# same parameters as those used to simulate the DNA sequences. See Campbell et
# al. (2009) for details.

# Example 1: five independent additive trees. Data provided by V. Campbell.

data(mat5Mrand)
res.global &lt;- CADM.global(mat5Mrand, 5, 50)

# Example 2: three partly similar trees, two independent trees.
# Data provided by V. Campbell.

data(mat5M3ID)
res.global &lt;- CADM.global(mat5M3ID, 5, 50)
res.post   &lt;- CADM.post(mat5M3ID, 5, 50, mantel=TRUE)

# Example 3: three matrices respectively representing Serological
# (asymmetric), DNA hybridization (asymmetric) and Anatomical (symmetric)
# distances among 9 families. Data from Lapointe et al. (1999).

data(mat3)
res.global &lt;- CADM.global(mat3, 3, 9, nperm=999)
res.post   &lt;- CADM.post(mat3, 3, 9, nperm=999, mantel=TRUE)

# Example 4, showing how to bind two D matrices (cophenetic matrices
# in this example) into a file using rbind(), then run the global test.

a &lt;- rtree(5)
b &lt;- rtree(5)
A &lt;- cophenetic(a)
B &lt;- cophenetic(b)
x &lt;- rownames(A)
B &lt;- B[x, x]
M &lt;- rbind(A, B)
CADM.global(M, 2, 5)
</code></pre>

<hr>
<h2 id='carnivora'>Carnivora body sizes and life history traits</h2><span id='topic+carnivora'></span>

<h3>Description</h3>

<p>Dataset adapted from Gittleman (1986), including 2 morphological variables (body and brain sizes),  8 life history traits variables and 4 taxonomic variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(carnivora)</code></pre>


<h3>Format</h3>

<p>A data frame with 112 observations on 17 variables.
</p>

<table>
<tr>
 <td style="text-align: right;">
    [,1]  </td><td style="text-align: left;"> Order       </td><td style="text-align: left;"> factor  </td><td style="text-align: left;"> Carnivora order </td>
</tr>
<tr>
 <td style="text-align: right;">
    [,2]  </td><td style="text-align: left;"> SuperFamily </td><td style="text-align: left;"> factor  </td><td style="text-align: left;"> Super family (Caniformia or Feliformia) </td>
</tr>
<tr>
 <td style="text-align: right;">
    [,3]  </td><td style="text-align: left;"> Family      </td><td style="text-align: left;"> factor  </td><td style="text-align: left;"> Carnivora family </td>
</tr>
<tr>
 <td style="text-align: right;">
    [,4]  </td><td style="text-align: left;"> Genus       </td><td style="text-align: left;"> factor  </td><td style="text-align: left;"> Carnivora genus </td>
</tr>
<tr>
 <td style="text-align: right;">
    [,5]  </td><td style="text-align: left;"> Species     </td><td style="text-align: left;"> factor  </td><td style="text-align: left;"> Carnivora species </td>
</tr>
<tr>
 <td style="text-align: right;">
    [,6]  </td><td style="text-align: left;"> FW          </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Female body weight (kg) </td>
</tr>
<tr>
 <td style="text-align: right;">
    [,7]  </td><td style="text-align: left;"> SW          </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Average body weight of adult male and adult female (kg) </td>
</tr>
<tr>
 <td style="text-align: right;">
    [,8]  </td><td style="text-align: left;"> FB          </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Female brain weight (g) </td>
</tr>
<tr>
 <td style="text-align: right;">
    [,9]  </td><td style="text-align: left;"> SB          </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Average brain weight of adult male and adult female (g) </td>
</tr>
<tr>
 <td style="text-align: right;">
    [,10] </td><td style="text-align: left;"> LS          </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Litter size </td>
</tr>
<tr>
 <td style="text-align: right;">
    [,11] </td><td style="text-align: left;"> GL          </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Gestation length (days) </td>
</tr>
<tr>
 <td style="text-align: right;">
    [,12] </td><td style="text-align: left;"> BW          </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Birth weigth (g) </td>
</tr>
<tr>
 <td style="text-align: right;">
    [,13] </td><td style="text-align: left;"> WA          </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Weaning age (days) </td>
</tr>
<tr>
 <td style="text-align: right;">
    [,14] </td><td style="text-align: left;"> AI          </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Age of independance (days) </td>
</tr>
<tr>
 <td style="text-align: right;">
    [,15] </td><td style="text-align: left;"> LY          </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Longevity (months) </td>
</tr>
<tr>
 <td style="text-align: right;">
    [,16] </td><td style="text-align: left;"> AM          </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Age of sexual maturity (days) </td>
</tr>
<tr>
 <td style="text-align: right;">
    [,17] </td><td style="text-align: left;"> IB          </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Inter-birth interval (months) </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Source</h3>

<p>Gittleman, J. L. (1986) Carnivore life history patterns: allometric,
phylogenetic and ecological associations. <em>American Naturalist</em>,
<b>127</b>: 744&ndash;771.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carnivora)
## Fig. 1 in Gittleman (1986):
plot(carnivora$BW ~ carnivora$FW, pch = (1:8)[carnivora$Family], log = "xy",
     xlab = "Female body weight (kg)", ylab = "Birth weigth (g)",
     ylim = c(1, 2000))
legend("bottomright", legend = levels(carnivora$Family), pch = 1:8)
plot(carnivora$BW ~ carnivora$FB, pch = (1:8)[carnivora$Family], log = "xy",
     xlab = "Female brain weight (g)", ylab = "Birth weigth (g)",
     ylim = c(1, 2000))
legend("bottomright", legend = levels(carnivora$Family), pch = 1:8)
</code></pre>

<hr>
<h2 id='checkAlignment'>Check DNA Alignments</h2><span id='topic+checkAlignment'></span>

<h3>Description</h3>

<p>This function performs a series of diagnostics on a DNA alignement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkAlignment(x, check.gaps = TRUE, plot = TRUE, what = 1:4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkAlignment_+3A_x">x</code></td>
<td>
<p>an object of class <code>"DNAbin"</code>.</p>
</td></tr>
<tr><td><code id="checkAlignment_+3A_check.gaps">check.gaps</code></td>
<td>
<p>a logical value specifying whether to check the
distribution of alignment gaps.</p>
</td></tr>
<tr><td><code id="checkAlignment_+3A_plot">plot</code></td>
<td>
<p>a logical value specifying whether to do the plots.</p>
</td></tr>
<tr><td><code id="checkAlignment_+3A_what">what</code></td>
<td>
<p>an integer value giving the plot to be done. By default,
four plots are done on the same figure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function prints on the console a series of diagnostics on the
set a aligned DNA sequences. If alignment gaps are present, their
width distribution is analysed, as well as the width of contiguous
base segments. The pattern of nucleotide diversity on each site is
also analysed, and a relevant table is printed.
</p>
<p>If <code>plot = TRUE</code>, four plots are done: an image of the
alignement, the distribution of gap widths (if present), the Shannon
index of nucleotide diversity along the sequence, and the number of
observed bases along the sequence.
</p>
<p>If the sequences contain many gaps, it might be better to set
<code>check.gaps = FALSE</code> to skip the analysis of contiguous
segments.
</p>


<h3>Value</h3>

<p>NULL</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+alview">alview</a></code>, <code><a href="#topic+image.DNAbin">image.DNAbin</a></code>, <code><a href="#topic+all.equal.DNAbin">all.equal.DNAbin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
checkAlignment(woodmouse)
layout(1)
</code></pre>

<hr>
<h2 id='checkLabel'>Checking Labels</h2><span id='topic+checkLabel'></span>

<h3>Description</h3>

<p>Checking and correcting character strings, particularly before writing
a Newick tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkLabel(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkLabel_+3A_x">x</code></td>
<td>
<p>a vector of mode character.</p>
</td></tr></table>


<h3>Details</h3>

<p>This function deletes the leading and trailing spaces (including
tabulations, new lines, and left or right parentheses at the beginning
or end of the strings), substitutes the spaces inside the strings by
underscores, and substitutes commas, colons, semicolons, and
parentheses inside the strings by dashes.
</p>


<h3>Value</h3>

<p>a vector of mode character.</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeLabel">makeLabel</a></code>, <code><a href="#topic+makeNodeLabel">makeNodeLabel</a></code>,
<code><a href="#topic+mixedFontLabel">mixedFontLabel</a></code>, <code><a href="#topic+stripLabel">stripLabel</a></code>,
<code><a href="#topic+updateLabel">updateLabel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>checkLabel(" Homo sapiens\t(Primates; World)   ")
</code></pre>

<hr>
<h2 id='checkValidPhylo'>Check the Structure of a &quot;phylo&quot; Object</h2><span id='topic+checkValidPhylo'></span>

<h3>Description</h3>

<p>This function takes as single argument an object (phy), checks its
elements, and prints a diagnostic. All problems are printed with a
label: FATAL (will likely cause an error or a crash) or MODERATE (may
cause some problems).
</p>
<p>This function is mainly intended for developers creating
<code>"phylo"</code> objects from scratch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkValidPhylo(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkValidPhylo_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>Examples</h3>

<pre><code class='language-R'>tr &lt;- rtree(3)
checkValidPhylo(tr)
tr$edge[1] &lt;- 0
checkValidPhylo(tr)
</code></pre>

<hr>
<h2 id='cherry'>Number of Cherries and Null Models of Trees</h2><span id='topic+cherry'></span>

<h3>Description</h3>

<p>This function calculates the number of cherries (see definition below)
on a phylogenetic tree, and tests the null hypotheses whether this
number agrees with those predicted from two null models of trees (the
Yule model, and the uniform model).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cherry(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cherry_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A cherry is a pair of adjacent tips on a tree. The tree can be either
rooted or unrooted, but the present function considers only rooted
trees. The probability distribution function of the number of cherries
on a tree depends on the speciation/extinction model that generated
the tree.
</p>
<p>McKenzie and Steel (2000) derived the probability
distribution function of the number of cherries for two models: the
Yule model and the uniform model. Broadly, in the Yule model, each extant
species is equally likely to split into two daughter-species; in the
uniform model, a branch is added to tree on any of the already
existing branches with a uniform probability.
</p>
<p>The probabilities are computed using recursive formulae; however, for
both models, the probability density function converges to a normal
law with increasing number of tips in the tree. The function uses
these normal approximations for a number of tips greater than or equal
to 20.
</p>


<h3>Value</h3>

<p>A NULL value is returned, the results are simply printed.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>McKenzie, A. and Steel, M. (2000) Distributions of cherries for two
models of trees. <em>Mathematical Biosciences</em>, <b>164</b>, 81&ndash;92.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gammaStat">gammaStat</a></code>
</p>

<hr>
<h2 id='chiroptera'>Bat Phylogeny</h2><span id='topic+chiroptera'></span>

<h3>Description</h3>

<p>This phylogeny of bats (Mammalia: Chiroptera) is a supertree (i.e. a
composite phylogeny constructed from several sources; see source for
details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chiroptera)
</code></pre>


<h3>Format</h3>

<p>The data are stored in RData (binary) format.
</p>


<h3>Source</h3>

<p>Jones, K. E., Purvis, A., MacLarnon, A., Bininda-Emonds, O. R. P. and
Simmons, N. B. (2002) A phylogenetic supertree of the bats (Mammalia:
Chiroptera). <em>Biological Reviews of the Cambridge Philosophical
Society</em>, <b>77</b>, 223&ndash;259.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.nexus">read.nexus</a></code>, <code><a href="#topic+zoom">zoom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chiroptera)
str(chiroptera)
op &lt;- par(cex = 0.3)
plot(chiroptera, type = "c")
par(op)
</code></pre>

<hr>
<h2 id='chronoMPL'>Molecular Dating With Mean Path Lengths</h2><span id='topic+chronoMPL'></span>

<h3>Description</h3>

<p>This function estimates the node ages of a tree using the mean path
lengths method of Britton et al. (2002). The branch lengths of the
input tree are interpreted as (mean) numbers of substitutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chronoMPL(phy, se = TRUE, test = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chronoMPL_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="chronoMPL_+3A_se">se</code></td>
<td>
<p>a logical specifying whether to compute the standard-errors
of the node ages (<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="chronoMPL_+3A_test">test</code></td>
<td>
<p>a logical specifying whether to test the molecular clock
at each node (<code>TRUE</code> by default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean path lengths (MPL) method estimates the age of a node with
the mean of the distances from this node to all tips descending from
it. Under the assumption of a molecular clock, standard-errors of the
estimates node ages can be computed (Britton et al. 2002).
</p>
<p>The tests performed if <code>test = TRUE</code> is a comparison of the MPL
of the two subtrees originating from a node; the null hypothesis is
that the rate of substitution was the same in both subtrees (Britton
et al. 2002). The test statistic follows, under the null hypothesis, a
standard normal distribution. The returned <em>P</em>-value is the
probability of observing a greater absolute value (i.e., a two-sided
test). No correction for multiple testing is applied: this is left to
the user.
</p>
<p>Absolute dating can be done by multiplying the edge lengths found by
calibrating one node age.
</p>


<h3>Value</h3>

<p>an object of class <code>"phylo"</code> with branch lengths as estimated by
the function. There are, by default, two attributes:
</p>
<table>
<tr><td><code>stderr</code></td>
<td>
<p>the standard-errors of the node ages.</p>
</td></tr>
<tr><td><code>Pval</code></td>
<td>
<p>the <em>P</em>-value of the test of the molecular clock for
each node.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The present version requires a dichotomous tree.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Britton, T., Oxelman, B., Vinnersten, A. and Bremer, K. (2002)
Phylogenetic dating with confidence intervals using mean path
lengths. <em>Molecular Phylogenetics and Evolution</em>, <b>24</b>,
58&ndash;65.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chronopl">chronopl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tr &lt;- rtree(10)
tr$edge.length &lt;- 5*tr$edge.length
chr &lt;- chronoMPL(tr)
layout(matrix(1:4, 2, 2, byrow = TRUE))
plot(tr)
title("The original tree")
plot(chr)
axisPhylo()
title("The dated MPL tree")
plot(chr)
nodelabels(round(attr(chr, "stderr"), 3))
title("The standard-errors")
plot(tr)
nodelabels(round(attr(chr, "Pval"), 3))
title("The tests")
layout(1)
</code></pre>

<hr>
<h2 id='chronopl'>Molecular Dating With Penalized Likelihood</h2><span id='topic+chronopl'></span>

<h3>Description</h3>

<p>This function estimates the node ages of a tree using a
semi-parametric method based on penalized likelihood (Sanderson
2002). The branch lengths of the input tree are interpreted as mean
numbers of substitutions (i.e., per site).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chronopl(phy, lambda, age.min = 1, age.max = NULL,
         node = "root", S = 1, tol = 1e-8,
         CV = FALSE, eval.max = 500, iter.max = 500, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chronopl_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="chronopl_+3A_lambda">lambda</code></td>
<td>
<p>value of the smoothing parameter.</p>
</td></tr>
<tr><td><code id="chronopl_+3A_age.min">age.min</code></td>
<td>
<p>numeric values specifying the fixed node ages (if
<code>age.max = NULL</code>) or the youngest bound of the nodes known to
be within an interval.</p>
</td></tr>
<tr><td><code id="chronopl_+3A_age.max">age.max</code></td>
<td>
<p>numeric values specifying the oldest bound of the nodes
known to be within an interval.</p>
</td></tr>
<tr><td><code id="chronopl_+3A_node">node</code></td>
<td>
<p>the numbers of the nodes whose ages are given by
<code>age.min</code>; <code>"root"</code> is a short-cut for the root.</p>
</td></tr>
<tr><td><code id="chronopl_+3A_s">S</code></td>
<td>
<p>the number of sites in the sequences; leave the default if
branch lengths are in mean number of substitutions.</p>
</td></tr>
<tr><td><code id="chronopl_+3A_tol">tol</code></td>
<td>
<p>the value below which branch lengths are considered
effectively zero.</p>
</td></tr>
<tr><td><code id="chronopl_+3A_cv">CV</code></td>
<td>
<p>whether to perform cross-validation.</p>
</td></tr>
<tr><td><code id="chronopl_+3A_eval.max">eval.max</code></td>
<td>
<p>the maximal number of evaluations of the penalized
likelihood function.</p>
</td></tr>
<tr><td><code id="chronopl_+3A_iter.max">iter.max</code></td>
<td>
<p>the maximal number of iterations of the optimization
algorithm.</p>
</td></tr>
<tr><td><code id="chronopl_+3A_...">...</code></td>
<td>
<p>further arguments passed to control <code>nlminb</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The idea of this method is to use a trade-off between a parametric
formulation where each branch has its own rate, and a nonparametric
term where changes in rates are minimized between contiguous
branches. A smoothing parameter (lambda) controls this trade-off. If
lambda = 0, then the parametric component dominates and rates vary as
much as possible among branches, whereas for increasing values of
lambda, the variation are smoother to tend to a clock-like model (same
rate for all branches).
</p>
<p><code>lambda</code> must be given. The known ages are given in
<code>age.min</code>, and the correponding node numbers in <code>node</code>.
These two arguments must obviously be of the same length. By default,
an age of 1 is assumed for the root, and the ages of the other nodes
are estimated.
</p>
<p>If <code>age.max = NULL</code> (the default), it is assumed that
<code>age.min</code> gives exactly known ages. Otherwise, <code>age.max</code> and
<code>age.min</code> must be of the same length and give the intervals for
each node. Some node may be known exactly while the others are
known within some bounds: the values will be identical in both
arguments for the former (e.g., <code>age.min = c(10, 5), age.max =
    c(10, 6), node = c(15, 18)</code> means that the age of node 15 is 10
units of time, and the age of node 18 is between 5 and 6).
</p>
<p>If two nodes are linked (i.e., one is the ancestor of the other) and
have the same values of <code>age.min</code> and <code>age.max</code> (say, 10 and
15) this will result in an error because the medians of these values
are used as initial times (here 12.5) giving initial branch length(s)
equal to zero. The easiest way to solve this is to change slightly the
given values, for instance use <code>age.max = 14.9</code> for the youngest
node, or <code>age.max = 15.1</code> for the oldest one (or similarly for
<code>age.min</code>).
</p>
<p>The input tree may have multichotomies. If some internal branches are
of zero-length, they are collapsed (with a warning), and the returned
tree will have less nodes than the input one. The presence of
zero-lengthed terminal branches of results in an error since it makes
little sense to have zero-rate branches.
</p>
<p>The cross-validation used here is different from the one proposed by
Sanderson (2002). Here, each tip is dropped successively and the
analysis is repeated with the reduced tree: the estimated dates for
the remaining nodes are compared with the estimates from the full
data. For the <code class="reqn">i</code>th tip the following is calculated:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{j=1}^{n-2}{\frac{(t_j - t_j^{-i})^2}{t_j}}</code>
</p>
<p>,
</p>
<p>where <code class="reqn">t_j</code> is the estimated date for the <code class="reqn">j</code>th node
with the full phylogeny, <code class="reqn">t_j^{-i}</code> is the estimated date
for the <code class="reqn">j</code>th node after removing tip <code class="reqn">i</code> from the tree,
and <code class="reqn">n</code> is the number of tips.
</p>
<p>The present version uses the <code><a href="stats.html#topic+nlminb">nlminb</a></code> to optimise
the penalized likelihood function: see its help page for details on
parameters controlling the optimisation procedure.
</p>


<h3>Value</h3>

<p>an object of class <code>"phylo"</code> with branch lengths as estimated by
the function. There are three or four further attributes:
</p>
<table>
<tr><td><code>ploglik</code></td>
<td>
<p>the maximum penalized log-likelihood.</p>
</td></tr>
<tr><td><code>rates</code></td>
<td>
<p>the estimated rates for each branch.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>the message returned by <code>nlminb</code> indicating
whether the optimisation converged.</p>
</td></tr>
<tr><td><code>D2</code></td>
<td>
<p>the influence of each observation on overall date
estimates (if <code>CV = TRUE</code>).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The new function <code><a href="#topic+chronos">chronos</a></code> replaces the present one which
is no more maintained.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Sanderson, M. J. (2002) Estimating absolute rates of molecular
evolution and divergence times: a penalized likelihood
approach. <em>Molecular Biology and Evolution</em>, <b>19</b>,
101&ndash;109.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chronos">chronos</a></code>, <code><a href="#topic+chronoMPL">chronoMPL</a></code>
</p>

<hr>
<h2 id='chronos'>Molecular Dating by Penalised Likelihood and Maximum Likelihood</h2><span id='topic+chronos'></span><span id='topic+makeChronosCalib'></span><span id='topic+chronos.control'></span><span id='topic+print.chronos'></span>

<h3>Description</h3>

<p><code>chronos</code> is the main function fitting a chronogram to a
phylogenetic tree whose branch lengths are in number of substitution
per sites.
</p>
<p><code>makeChronosCalib</code> is a tool to prepare data frames with the
calibration points of the phylogenetic tree.
</p>
<p><code>chronos.control</code> creates a list of parameters to be passed
to <code>chronos</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chronos(phy, lambda = 1, model = "correlated", quiet = FALSE,
        calibration = makeChronosCalib(phy),
        control = chronos.control())
## S3 method for class 'chronos'
print(x, ...)
makeChronosCalib(phy, node = "root", age.min = 1,
   age.max = age.min, interactive = FALSE, soft.bounds = FALSE)
chronos.control(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chronos_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="chronos_+3A_lambda">lambda</code></td>
<td>
<p>value of the smoothing parameter.</p>
</td></tr>
<tr><td><code id="chronos_+3A_model">model</code></td>
<td>
<p>a character string specifying the model of substitution
rate variation among branches. The possible choices are:
&ldquo;correlated&rdquo;, &ldquo;relaxed&rdquo;, &ldquo;discrete&rdquo;, &ldquo;clock&rdquo;, or an
unambiguous abbreviation of these.</p>
</td></tr>
<tr><td><code id="chronos_+3A_quiet">quiet</code></td>
<td>
<p>a logical value; by default the calculation progress are
displayed.</p>
</td></tr>
<tr><td><code id="chronos_+3A_calibration">calibration</code></td>
<td>
<p>a data frame (see details).</p>
</td></tr>
<tr><td><code id="chronos_+3A_control">control</code></td>
<td>
<p>a list of parameters controlling the optimisation
procedure (see details).</p>
</td></tr>
<tr><td><code id="chronos_+3A_x">x</code></td>
<td>
<p>an object of class <code>c("chronos", "phylo")</code>.</p>
</td></tr>
<tr><td><code id="chronos_+3A_node">node</code></td>
<td>
<p>a vector of integers giving the node numbers for which a
calibration point is given. The default is a short-cut for the
root.</p>
</td></tr>
<tr><td><code id="chronos_+3A_age.min">age.min</code>, <code id="chronos_+3A_age.max">age.max</code></td>
<td>
<p>vectors of numerical values giving the minimum
and maximum ages of the nodes specified in <code>node</code>.</p>
</td></tr>
<tr><td><code id="chronos_+3A_interactive">interactive</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, then <code>phy</code> is
plotted and the user is asked to click close to a node and enter the
ages on the keyboard.</p>
</td></tr>
<tr><td><code id="chronos_+3A_soft.bounds">soft.bounds</code></td>
<td>
<p>(currently unused)</p>
</td></tr>
<tr><td><code id="chronos_+3A_...">...</code></td>
<td>
<p>in the case of <code>chronos.control</code>: one of the five
parameters controlling optimisation (unused in the case of
<code>print.chronos</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>chronos</code> replaces <code>chronopl</code> but with a different interface
and some extensions (see References).
</p>
<p>The known dates (argument <code>calibration</code>) must be given in a data
frame with the following column names: node, age.min, age.max, and
soft.bounds (the last one is yet unused). For each row, these are,
respectively: the number of the node in the &ldquo;phylo&rdquo; coding standard,
the minimum age for this node, the maximum age, and a logical value
specifying whether the bounds are soft. If age.min = age.max, this
means that the age is exactly known. This data frame can be built with
<code>makeChronosCalib</code> which returns by default a data frame with a
single row giving age = 1 for the root. The data frame can be built
interactively by clicking on the plotted tree.
</p>
<p>The argument <code>control</code> allows one to change some parameters of
the optimisation procedure. This must be a list with names. The
available options with their default values are:
</p>

<ul>
<li><p> tol = 1e-8: tolerance for the estimation of the substitution
rates.
</p>
</li>
<li><p> iter.max = 1e4: the maximum number of iterations at each
optimization step.
</p>
</li>
<li><p> eval.max = 1e4: the maximum number of function evaluations at
each optimization step.
</p>
</li>
<li><p> nb.rate.cat = 10: the number of rate categories if <code>model
	= "discrete"</code> (set this parameter to 1 to fit a strict clock
model).
</p>
</li>
<li><p> dual.iter.max = 20: the maximum number of alternative
iterations between rates and dates.
</p>
</li>
<li><p> epsilon = 1e-6: the convergence diagnostic criterion.
</p>
</li></ul>

<p>Using <code>model = "clock"</code> is actually a short-cut to <code>model =
  "discrete"</code> and setting <code>nb.rate.cat = 1</code> in the list passed to
<code>control</code>.
</p>
<p>The command <code>chronos.control()</code> returns a list with the default
values of these parameters. They may be modified by passing them to
this function, or directly in the list.
</p>


<h3>Value</h3>

<p><code>chronos</code> returns an object of class <code>c("chronos",
  "phylo")</code>. There is a print method for it. There are additional
attributes which can be visualised with <code>str</code> or extracted with
<code>attr</code>.
</p>
<p><code>makeChronosCalib</code> returns a data frame.
</p>
<p><code>chronos.control</code> returns a list.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis, Santiago Claramunt, Guillaume Louvel</p>


<h3>References</h3>

<p>Kim, J. and Sanderson, M. J. (2008) Penalized likelihood phylogenetic
inference: bridging the parsimony-likelihood gap. <em>Systematic
Biology</em>, <b>57</b>, 665&ndash;674.
</p>
<p>Paradis, E. (2013) Molecular dating of phylogenies by likelihood
methods: a comparison of models and a new information
criterion. <em>Molecular Phylogenetics and Evolution</em>, <b>67</b>,
436&ndash;444.
</p>
<p>Sanderson, M. J. (2002) Estimating absolute rates of molecular
evolution and divergence times: a penalized likelihood
approach. <em>Molecular Biology and Evolution</em>, <b>19</b>,
101&ndash;109.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chronoMPL">chronoMPL</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ape)
tr &lt;- rtree(10)
### the default is the correlated rate model:
chr &lt;- chronos(tr)
### strict clock model:
ctrl &lt;- chronos.control(nb.rate.cat = 1)
chr.clock &lt;- chronos(tr, model = "discrete", control = ctrl)
### How different are the rates?
attr(chr, "rates")
attr(chr.clock, "rates")
## Not run: 
cal &lt;- makeChronosCalib(tr, interactive = TRUE)
cal
### if you made mistakes, you can edit the data frame with:
### fix(cal)
chr &lt;- chronos(tr, calibration = cal)

## End(Not run)
</code></pre>

<hr>
<h2 id='clustal'>Multiple Sequence Alignment with External Applications</h2><span id='topic+clustal'></span><span id='topic+clustalomega'></span><span id='topic+muscle'></span><span id='topic+muscle5'></span><span id='topic+tcoffee'></span><span id='topic+efastats'></span><span id='topic+letterconf'></span>

<h3>Description</h3>

<p>These functions call their respective program from <span class="rlang"><b>R</b></span> to align a set
of nucleotide sequences of class <code>"DNAbin"</code> or
<code>"AAbin"</code>. The application(s) must be installed seperately and it
is highly recommended to do this so that the executables are in a
directory located on the PATH of the system.
</p>
<p>This version includes an experimental version of <code>muscle5</code> which
calls MUSCLE5 (see the link to the documentation in the References
below); <code>muscle</code> still calls MUSCLE version 3. Note that the
executable of MUSCLE5 is also named &lsquo;muscle&rsquo; by the default
compilation setting.
</p>
<p>The functions <code>efastats</code> and <code>letterconf</code> require MUSCLE5.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustal(x, y, guide.tree, pw.gapopen = 10, pw.gapext = 0.1,
        gapopen = 10, gapext = 0.2, exec = NULL, MoreArgs = "",
        quiet = TRUE, original.ordering = TRUE, file)
clustalomega(x, y, guide.tree, exec = NULL,MoreArgs = "",
              quiet = TRUE, original.ordering = TRUE, file)
muscle(x, y, guide.tree, exec, MoreArgs = "",
        quiet = TRUE, original.ordering = TRUE, file)
muscle5(x, exec = "muscle", MoreArgs = "", quiet = FALSE,
        file, super5 = FALSE, mc.cores = 1)
tcoffee(x, exec = "t_coffee", MoreArgs = "", quiet = TRUE,
        original.ordering = TRUE)

efastats(X, exec = "muscle", quiet = FALSE)
letterconf(X, exec = "muscle")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustal_+3A_x">x</code></td>
<td>
<p>an object of class <code>"DNAbin"</code> or <code>"AAbin"</code> (can be
missing).</p>
</td></tr>
<tr><td><code id="clustal_+3A_y">y</code></td>
<td>
<p>an object of class <code>"DNAbin"</code> or <code>"AAbin"</code> used for
profile alignment (can be missing).</p>
</td></tr>
<tr><td><code id="clustal_+3A_guide.tree">guide.tree</code></td>
<td>
<p>guide tree, an object of class <code>"phylo"</code> (can
be missing).</p>
</td></tr>
<tr><td><code id="clustal_+3A_pw.gapopen">pw.gapopen</code>, <code id="clustal_+3A_pw.gapext">pw.gapext</code></td>
<td>
<p>gap opening and gap extension penalties
used by Clustal during pairwise alignments.</p>
</td></tr>
<tr><td><code id="clustal_+3A_gapopen">gapopen</code>, <code id="clustal_+3A_gapext">gapext</code></td>
<td>
<p>idem for global alignment.</p>
</td></tr>
<tr><td><code id="clustal_+3A_exec">exec</code></td>
<td>
<p>a character string giving the name of the program, with
its path if necessary. <code>clustal</code> tries to guess this argument
depending on the operating system (see details).</p>
</td></tr>
<tr><td><code id="clustal_+3A_moreargs">MoreArgs</code></td>
<td>
<p>a character string giving additional options.</p>
</td></tr>
<tr><td><code id="clustal_+3A_quiet">quiet</code></td>
<td>
<p>a logical: the default is to not print on <span class="rlang"><b>R</b></span>'s console the
messages from the external program.</p>
</td></tr>
<tr><td><code id="clustal_+3A_original.ordering">original.ordering</code></td>
<td>
<p>a logical specifying whether to return the
aligned sequences in the same order than in <code>x</code> (<code>TRUE</code> by
default).</p>
</td></tr>
<tr><td><code id="clustal_+3A_file">file</code></td>
<td>
<p>a file with its path if results should be stored (can be
missing).</p>
</td></tr>
<tr><td><code id="clustal_+3A_super5">super5</code></td>
<td>
<p>a logical value. By default, the PPP algorithm is used.</p>
</td></tr>
<tr><td><code id="clustal_+3A_mc.cores">mc.cores</code></td>
<td>
<p>the number of cores to be used by MUSCLE5.</p>
</td></tr>
<tr><td><code id="clustal_+3A_x">X</code></td>
<td>
<p>a list with several alignments of the same sequences with
all with the same row order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is highly recommended to install the executables properly so that
they are in a directory located on the PATH (i.e., accessible from any
other directory). Alternatively, the full path to the executable
may be given (e.g., <code>exec = "~/muscle/muscle"</code>), or a (symbolic)
link may be copied in the working directory. For Debian and its
derivatives (e.g., Ubuntu), it is recommended to use the binaries
distributed by Debian.
</p>
<p><code>clustal</code> tries to guess the name of the executable program
depending on the operating system. Specifically, the followings are
used: &ldquo;clustalw&rdquo; under Linux, &ldquo;clustalw2&rdquo; under MacOS, and
&ldquo;clustalw2.exe&rdquo; under Windows. For <code>clustalomega</code>,
&ldquo;clustalo[.exe]&rdquo; is the default on all systems (with no specific
path).
</p>
<p>When called without arguments (i.e., <code>clustal()</code>, ...), the
function prints the options of the program which may be passed to
<code>MoreArgs</code>.
</p>
<p>Since <span class="pkg">ape</span> 5.1, <code>clustal</code>, <code>clustalomega</code>, and
<code>muscle</code> can align AA sequences as well as DNA sequences.
</p>


<h3>Value</h3>

<p>an object of class <code>"DNAbin"</code> or <code>"AAbin"</code> with the aligned
sequences.
</p>
<p><code>efastats</code> returns a data frame.
</p>
<p><code>letterconf</code> opens the default Web brower.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis, Franz Krah</p>


<h3>References</h3>

<p>Chenna, R., Sugawara, H., Koike, T., Lopez, R., Gibson, T. J.,
Higgins, D. G. and Thompson, J. D. (2003) Multiple sequence alignment
with the Clustal series of programs. <em>Nucleic Acids Research</em>
<b>31</b>, 3497&ndash;3500. <a href="http://www.clustal.org/">http://www.clustal.org/</a>
</p>
<p>Edgar, R. C. (2004) MUSCLE: Multiple sequence alignment with high
accuracy and high throughput. <em>Nucleic Acids Research</em>,
<b>32</b>, 1792&ndash;1797.
<a href="http://www.drive5.com/muscle/muscle_userguide3.8.html">http://www.drive5.com/muscle/muscle_userguide3.8.html</a>
</p>
<p>Notredame, C., Higgins, D. and Heringa, J. (2000) T-Coffee: A novel
method for multiple sequence alignments. <em>Journal of Molecular
Biology</em>, <b>302</b>, 205&ndash;217.
<a href="https://tcoffee.org/">https://tcoffee.org/</a>
</p>
<p>Sievers, F., Wilm, A., Dineen, D., Gibson, T. J., Karplus, K., Li, W.,
Lopez, R., McWilliam, H., Remmert, M., S\&quot;oding, J., Thompson,
J. D. and Higgins, D. G. (2011) Fast, scalable generation of
high-quality protein multiple sequence alignments using Clustal
Omega. <em>Molecular Systems Biology</em>, <b>7</b>, 539.
<a href="http://www.clustal.org/">http://www.clustal.org/</a>
</p>
<p><a href="https://drive5.com/muscle5/">https://drive5.com/muscle5/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+image.DNAbin">image.DNAbin</a></code>, <code><a href="#topic+del.gaps">del.gaps</a></code>,
<code><a href="#topic+all.equal.DNAbin">all.equal.DNAbin</a></code>, <code><a href="#topic+alex">alex</a></code>,
<code><a href="#topic+alview">alview</a></code>, <code><a href="#topic+checkAlignment">checkAlignment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### display the options:
clustal()
clustalomega()
muscle()
tcoffee()

data(woodmouse)
### open gaps more easily:
clustal(woodmouse, pw.gapopen = 1, pw.gapext = 1)
### T-Coffee requires negative values (quite slow; muscle() is much faster):
tcoffee(woodmouse,  MoreArgs = "-gapopen=-10 -gapext=-2")

## End(Not run)</code></pre>

<hr>
<h2 id='coalescent.intervals'>Coalescent Intervals</h2><span id='topic+coalescent.intervals'></span><span id='topic+coalescent.intervals.phylo'></span><span id='topic+coalescent.intervals.default'></span>

<h3>Description</h3>

<p>This function extracts or generates information about coalescent intervals
(number of lineages, interval lengths, interval count, total depth) from
a phylogenetic tree or a list of internode distances. The input tree
needs to be ultra-metric (i.e. clock-like).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coalescent.intervals(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coalescent.intervals_+3A_x">x</code></td>
<td>
<p>either an ultra-metric phylogenetic tree (i.e. an object of
class <code>"phylo"</code>) or, alternatively, a vector of interval lengths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"coalescentIntervals"</code> with the following entries:
</p>
<table>
<tr><td><code>lineages</code></td>
<td>
<p> A vector with the number of lineages at the start of each coalescent
interval.</p>
</td></tr>
<tr><td><code>interval.length</code></td>
<td>
<p> A vector with the length of each coalescent
interval.</p>
</td></tr>
<tr><td><code>interval.count</code></td>
<td>
<p> The total number of coalescent
intervals.</p>
</td></tr>
<tr><td><code>total.depth</code></td>
<td>
<p> The sum of the lengths of all coalescent
intervals.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Korbinian Strimmer</p>


<h3>See Also</h3>

<p><code><a href="#topic+branching.times">branching.times</a></code>, <code><a href="#topic+collapsed.intervals">collapsed.intervals</a></code>,
<code><a href="#topic+read.tree">read.tree</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hivtree.newick") # example tree in NH format
tree.hiv &lt;- read.tree(text = hivtree.newick) # load tree
ci &lt;- coalescent.intervals(tree.hiv) # from tree
ci
data("hivtree.table") # same tree, but in table format
ci &lt;- coalescent.intervals(hivtree.table$size) # from vector of interval lengths
ci
</code></pre>

<hr>
<h2 id='collapse.singles'>Collapse Single Nodes</h2><span id='topic+collapse.singles'></span><span id='topic+has.singles'></span>

<h3>Description</h3>

<p><code>collapse.singles</code> deletes the single nodes (i.e., with a single
descendant) in a tree.
</p>
<p><code>has.singles</code> tests for the presence of single node(s) in a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse.singles(tree, root.edge = FALSE)
has.singles(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse.singles_+3A_tree">tree</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="collapse.singles_+3A_root.edge">root.edge</code></td>
<td>
<p>whether to get the singleton edges from the root
until the first bifurcating node and put them as <code>root.edge</code> of
the returned tree. By default, this is ignored or if the tree has no
edge lengths (see examples).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"phylo"</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis, Klaus Schliep</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.phylo">plot.phylo</a></code>, <code><a href="#topic+read.tree">read.tree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a tree with 3 tips and 3 nodes:
e &lt;- c(4L, 6L, 6L, 5L, 5L, 6L, 1L, 5L, 3L, 2L)
dim(e) &lt;- c(5, 2)
tr &lt;- structure(list(edge = e, tip.label = LETTERS[1:3], Nnode = 3L),
                class = "phylo")
tr
has.singles(tr)
## the following shows that node #4 (ie, the root) is a singleton
## and node #6 is the first bifurcating node
tr$edge
## A bifurcating tree has less nodes than it has tips:
## the following used to fail with ape 4.1 or lower:
plot(tr)
collapse.singles(tr) # only 2 nodes
## give branch lengths to use the 'root.edge' option:
tr$edge.length &lt;- runif(5)
str(collapse.singles(tr, TRUE)) # has a 'root.edge'
</code></pre>

<hr>
<h2 id='collapsed.intervals'>Collapsed Coalescent Intervals</h2><span id='topic+collapsed.intervals'></span>

<h3>Description</h3>

<p>This function takes a <code>"coalescentIntervals"</code> objects and collapses neighbouring
coalescent intervals into a single combined interval so that every collapsed interval is
larger than <code>epsilon</code>. Collapsed coalescent intervals are used, e.g., to obtain the
generalized skyline plot (<code><a href="#topic+skyline">skyline</a></code>). For <code>epsilon = 0</code> no interval
is collapsed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapsed.intervals(ci, epsilon=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapsed.intervals_+3A_ci">ci</code></td>
<td>
<p>coalescent intervals (i.e. an object of class <code>"coalescentIntervals"</code>).</p>
</td></tr>
<tr><td><code id="collapsed.intervals_+3A_epsilon">epsilon</code></td>
<td>
<p>collapsing parameter that controls the amount of smoothing
(allowed range: from <code>0</code> to <code>ci$total.depth</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Proceeding from the tips to the root of the tree each small
interval is pooled with the neighboring interval closer to the root. If the
neighboring interval is also small, then pooling continues until the composite
interval is larger than <code>epsilon</code>. Note that this approach prevents the
occurrence of zero-length intervals at the present.
For more details see Strimmer and Pybus (2001).
</p>


<h3>Value</h3>

<p>An object of class <code>"collapsedIntervals"</code> with the following entries:
</p>
<table>
<tr><td><code>lineages</code></td>
<td>
<p> A vector with the number of lineages at the start of each coalescent
interval.</p>
</td></tr>
<tr><td><code>interval.length</code></td>
<td>
<p> A vector with the length of each coalescent
interval.</p>
</td></tr>
<tr><td><code>collapsed.interval</code></td>
<td>
<p>A vector indicating for each coalescent interval to which
collapsed interval it belongs.</p>
</td></tr>
<tr><td><code>interval.count</code></td>
<td>
<p> The total number of coalescent
intervals.</p>
</td></tr>
<tr><td><code>collapsed.interval.count</code></td>
<td>
<p>The number of collapsed intervals.</p>
</td></tr>
<tr><td><code>total.depth</code></td>
<td>
<p> The sum of the lengths of all coalescent
intervals.</p>
</td></tr>
<tr><td><code>epsilon</code></td>
<td>
<p>The value of the underlying smoothing parameter.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Korbinian Strimmer</p>


<h3>References</h3>

<p>Strimmer, K. and Pybus, O. G. (2001) Exploring the demographic history
of DNA sequences using the generalized skyline plot. <em>Molecular
Biology and Evolution</em>, <b>18</b>, 2298&ndash;2305.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coalescent.intervals">coalescent.intervals</a></code>,<code><a href="#topic+skyline">skyline</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hivtree.table") # example tree
# colescent intervals from vector of interval lengths
ci &lt;- coalescent.intervals(hivtree.table$size)
ci
# collapsed intervals
cl1 &lt;- collapsed.intervals(ci,0)
cl2 &lt;- collapsed.intervals(ci,0.0119)
cl1
cl2
</code></pre>

<hr>
<h2 id='compar.cheverud'>Cheverud's Comparative Method</h2><span id='topic+compar.cheverud'></span>

<h3>Description</h3>

<p>This function computes the phylogenetic variance component and the
residual deviation for continous characters, taking into account the
phylogenetic relationships among species, following the comparative
method described in Cheverud et al. (1985). The correction proposed by
Rholf (2001) is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compar.cheverud(y, W, tolerance = 1e-06, gold.tol = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compar.cheverud_+3A_y">y</code></td>
<td>
<p>A vector containing the data to analyse.</p>
</td></tr>
<tr><td><code id="compar.cheverud_+3A_w">W</code></td>
<td>
<p>The phylogenetic connectivity matrix. All diagonal elements
will be ignored.</p>
</td></tr>
<tr><td><code id="compar.cheverud_+3A_tolerance">tolerance</code></td>
<td>
<p>Minimum difference allowed to consider eigenvalues as
distinct.</p>
</td></tr>
<tr><td><code id="compar.cheverud_+3A_gold.tol">gold.tol</code></td>
<td>
<p>Precision to use in golden section search alogrithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Model: </p>
<p style="text-align: center;"><code class="reqn">y = \rho W y + e</code>
</p>

<p>where <code class="reqn">e</code> is the error term, assumed to be normally distributed.
<code class="reqn">\rho</code> is estimated by the maximum likelihood procedure given
in Rohlf (2001), using a golden section search algorithm. The code of
this function is indeed adapted from a MatLab code given in appendix
in Rohlf's article, to correct a mistake in Cheverud's original paper.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>rhohat</code></td>
<td>
<p>The maximum likelihood estimate of <code class="reqn">\rho</code></p>
</td></tr>
<tr><td><code>Wnorm</code></td>
<td>
<p>The normalized version of <code>W</code></p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Error terms (<code class="reqn">e</code>)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Julien Dutheil <a href="mailto:dutheil@evolbio.mpg.de">dutheil@evolbio.mpg.de</a></p>


<h3>References</h3>

<p>Cheverud, J. M., Dow, M. M. and Leutenegger, W. (1985) The quantitative
assessment of phylogenetic constraints in comparative analyses: sexual
dimorphism in body weight among primates. <em>Evolution</em>,
<b>39</b>, 1335&ndash;1351.
</p>
<p>Rohlf, F. J. (2001) Comparative methods for the analysis of continuous
variables: geometric interpretations. <em>Evolution</em>, <b>55</b>,
2143&ndash;2160.
</p>
<p>Harvey, P. H. and Pagel, M. D. (1991) <em>The Comparative Method in
Evolutionary Biology</em>. Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compar.lynch">compar.lynch</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example from Harvey and Pagel's book:
y&lt;-c(10,8,3,4)
W &lt;- matrix(c(1,1/6,1/6,1/6,1/6,1,1/2,1/2,1/6,1/2,1,1,1/6,1/2,1,1), 4)
compar.cheverud(y,W)
### Example from Rohlf's 2001 article:
W&lt;- matrix(c(
  0,1,1,2,0,0,0,0,
  1,0,1,2,0,0,0,0,
  1,1,0,2,0,0,0,0,
  2,2,2,0,0,0,0,0,
  0,0,0,0,0,1,1,2,
  0,0,0,0,1,0,1,2,
  0,0,0,0,1,1,0,2,
  0,0,0,0,2,2,2,0
),8)
W &lt;- 1/W
W[W == Inf] &lt;- 0
y&lt;-c(-0.12,0.36,-0.1,0.04,-0.15,0.29,-0.11,-0.06)
compar.cheverud(y,W)
</code></pre>

<hr>
<h2 id='compar.gee'>Comparative Analysis with GEEs</h2><span id='topic+compar.gee'></span><span id='topic+print.compar.gee'></span><span id='topic+drop1.compar.gee'></span><span id='topic+predict.compar.gee'></span>

<h3>Description</h3>

<p><code>compar.gee</code> performs the comparative analysis using generalized
estimating equations as described by Paradis and Claude (2002).
</p>
<p><code>drop1</code> tests single effects of a fitted model output from
<code>compar.gee</code>.
</p>
<p><code>predict</code> returns the predicted (fitted) values of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compar.gee(formula, data = NULL, family = "gaussian", phy, corStruct,
          scale.fix = FALSE, scale.value = 1)
## S3 method for class 'compar.gee'
drop1(object, scope, quiet = FALSE, ...)
## S3 method for class 'compar.gee'
predict(object, newdata = NULL, type = c("link", "response"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compar.gee_+3A_formula">formula</code></td>
<td>
<p>a formula giving the model to be fitted.</p>
</td></tr>
<tr><td><code id="compar.gee_+3A_data">data</code></td>
<td>
<p>the name of the data frame where the variables in
<code>formula</code> are to be found; by default, the variables are looked
for in the global environment.</p>
</td></tr>
<tr><td><code id="compar.gee_+3A_family">family</code></td>
<td>
<p>a function specifying the distribution assumed for the
response; by default a Gaussian distribution (with link identity) is
assumed (see <code>?family</code> for details on specifying the
distribution, and on changing the link function).</p>
</td></tr>
<tr><td><code id="compar.gee_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code> (ignored if
<code>corStruct</code> is used).</p>
</td></tr>
<tr><td><code id="compar.gee_+3A_corstruct">corStruct</code></td>
<td>
<p>a (phylogenetic) correlation structure.</p>
</td></tr>
<tr><td><code id="compar.gee_+3A_scale.fix">scale.fix</code></td>
<td>
<p>logical, indicates whether the scale parameter should
be fixed (TRUE) or estimated (FALSE, the default).</p>
</td></tr>
<tr><td><code id="compar.gee_+3A_scale.value">scale.value</code></td>
<td>
<p>if <code>scale.fix = TRUE</code>, gives the value for the
scale (default: <code>scale.value = 1</code>).</p>
</td></tr>
<tr><td><code id="compar.gee_+3A_object">object</code></td>
<td>
<p>an object of class <code>"compar.gee"</code> resulting from
fitting <code>compar.gee</code>.</p>
</td></tr>
<tr><td><code id="compar.gee_+3A_scope">scope</code></td>
<td>
<p>&lt;unused&gt;.</p>
</td></tr>
<tr><td><code id="compar.gee_+3A_quiet">quiet</code></td>
<td>
<p>a logical specifying whether to display a warning message
about eventual &ldquo;marginality principle violation&rdquo;.</p>
</td></tr>
<tr><td><code id="compar.gee_+3A_newdata">newdata</code></td>
<td>
<p>a data frame with column names matching the variables
in the formula of the fitted object (see
<code><a href="stats.html#topic+predict">predict</a></code> for details).</p>
</td></tr>
<tr><td><code id="compar.gee_+3A_type">type</code></td>
<td>
<p>a character string specifying the type of predicted
values. By default, the linear (link) prediction is returned.</p>
</td></tr>
<tr><td><code id="compar.gee_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>drop1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a data frame is specified for the argument <code>data</code>, then its
rownames are matched to the tip labels of <code>phy</code>. The user must be
careful here since the function requires that both series of names
perfectly match, so this operation may fail if there is a typing or
syntax error. If both series of names do not match, the values in the
data frame are taken to be in the same order than the tip labels of
<code>phy</code>, and a warning message is issued.
</p>
<p>If <code>data = NULL</code>, then it is assumed that the variables are in
the same order than the tip labels of <code>phy</code>.
</p>


<h3>Value</h3>

<p><code>compar.gee</code> returns an object of class <code>"compar.gee"</code> with
the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the function call, including the formula.</p>
</td></tr>
<tr><td><code>effect.assign</code></td>
<td>
<p>a vector of integers assigning the coefficients
to the effects (used by <code>drop1</code>).</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code>QIC</code></td>
<td>
<p>the quasilikelihood information criterion as defined by Pan
(2001).</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>the estimated coefficients (or regression parameters).</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the regression residuals.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>a character string, the distribution assumed for the response.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>a character string, the link function used for the mean function.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>the scale (or dispersion parameter).</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>the variance-covariance matrix of the estimated coefficients.</p>
</td></tr>
<tr><td><code>dfP</code></td>
<td>
<p>the phylogenetic degrees of freedom (see Paradis and Claude
for details on this).</p>
</td></tr>
</table>
<p><code>drop1</code> returns an object of class <code>"<a href="stats.html#topic+anova">anova</a>"</code>.
</p>
<p><code>predict</code> returns a vector or a data frame if <code>newdata</code> is used.
</p>


<h3>Note</h3>

<p>The calculation of the phylogenetic degrees of freedom is likely to be
approximative for non-Brownian correlation structures (this will be
refined soon).
</p>
<p>The calculation of the quasilikelihood information criterion (QIC)
needs to be tested.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Pan, W. (2001) Akaike's information criterion in generalized
estimating equations. <em>Biometrics</em>, <b>57</b>, 120&ndash;125.
</p>
<p>Paradis, E. and Claude J. (2002) Analysis of comparative data using
generalized estimating equations. <em>Journal of theoretical
Biology</em>, <b>218</b>, 175&ndash;185.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.tree">read.tree</a></code>, <code><a href="#topic+pic">pic</a></code>,
<code><a href="#topic+compar.lynch">compar.lynch</a></code>, <code><a href="stats.html#topic+drop1">drop1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### The example in Phylip 3.5c (originally from Lynch 1991)
### (the same analysis than in help(pic)...)
tr &lt;- "((((Homo:0.21,Pongo:0.21):0.28,Macaca:0.49):0.13,Ateles:0.62):0.38,Galago:1.00);"
tree.primates &lt;- read.tree(text = tr)
X &lt;- c(4.09434, 3.61092, 2.37024, 2.02815, -1.46968)
Y &lt;- c(4.74493, 3.33220, 3.36730, 2.89037, 2.30259)
### Both regressions... the results are quite close to those obtained
### with pic().
compar.gee(X ~ Y, phy = tree.primates)
compar.gee(Y ~ X, phy = tree.primates)
### Now do the GEE regressions through the origin: the results are quite
### different!
compar.gee(X ~ Y - 1, phy = tree.primates)
compar.gee(Y ~ X - 1, phy = tree.primates)
</code></pre>

<hr>
<h2 id='compar.lynch'>Lynch's Comparative Method</h2><span id='topic+compar.lynch'></span>

<h3>Description</h3>

<p>This function computes the heritable additive value and the residual
deviation for continous characters, taking into account the
phylogenetic relationships among species, following the comparative
method described in Lynch (1991).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compar.lynch(x, G, eps = 1e-4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compar.lynch_+3A_x">x</code></td>
<td>
<p>eiher a matrix, a vector, or a data.frame containing the data
with species as rows and variables as columns.</p>
</td></tr>
<tr><td><code id="compar.lynch_+3A_g">G</code></td>
<td>
<p>a matrix that can be interpreted as an among-species correlation
matrix.</p>
</td></tr>
<tr><td><code id="compar.lynch_+3A_eps">eps</code></td>
<td>
<p>a numeric value to detect convergence of the EM algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter estimates are computed following the EM
(expectation-maximization) algorithm. This algorithm usually leads to
convergence but may lead to local optima of the likelihood
function. It is recommended to run several times the function in order
to detect these potential local optima. The &lsquo;optimal&rsquo; value for
<code>eps</code> depends actually on the range of the data and may be
changed by the user in order to check the stability of the parameter
estimates. Convergence occurs when the differences between two
successive iterations of the EM algorithm leads to differences between
both residual and additive values less than or equal to <code>eps</code>.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>vare</code></td>
<td>
<p>estimated residual variance-covariance matrix.</p>
</td></tr>
<tr><td><code>vara</code></td>
<td>
<p>estimated additive effect variance covariance matrix.</p>
</td></tr>
<tr><td><code>u</code></td>
<td>
<p>estimates of the phylogeny-wide means.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>addtitive value estimates.</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>residual values estimates.</p>
</td></tr>
<tr><td><code>lik</code></td>
<td>
<p>logarithm of the likelihood for the entire set of observed
taxon-specific mean.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The present function does not perform the estimation of ancestral
phentoypes as proposed by Lynch (1991). This will be implemented in
a future version.
</p>


<h3>Author(s)</h3>

<p>Julien Claude <a href="mailto:julien.claude@umontpellier.fr">julien.claude@umontpellier.fr</a></p>


<h3>References</h3>

<p>Lynch, M. (1991) Methods for the analysis of comparative data in
evolutionary biology. <em>Evolution</em>, <b>45</b>, 1065&ndash;1080.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pic">pic</a></code>, <code><a href="#topic+compar.gee">compar.gee</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### The example in Lynch (1991)
x &lt;- "((((Homo:0.21,Pongo:0.21):0.28,Macaca:0.49):0.13,Ateles:0.62):0.38,Galago:1.00);"
tree.primates &lt;- read.tree(text = x)
X &lt;- c(4.09434, 3.61092, 2.37024, 2.02815, -1.46968)
Y &lt;- c(4.74493, 3.33220, 3.36730, 2.89037, 2.30259)
compar.lynch(cbind(X, Y),
             G = vcv.phylo(tree.primates, cor = TRUE))
</code></pre>

<hr>
<h2 id='compar.ou'>Ornstein&ndash;Uhlenbeck Model for Continuous Characters</h2><span id='topic+compar.ou'></span>

<h3>Description</h3>

<p>This function fits an Ornstein&ndash;Uhlenbeck model giving a phylogenetic
tree, and a continuous character. The user specifies the node(s) where
the optimum changes. The parameters are estimated by maximum
likelihood; their standard-errors are computed assuming normality of
these estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compar.ou(x, phy, node = NULL, alpha = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compar.ou_+3A_x">x</code></td>
<td>
<p>a numeric vector giving the values of a continuous
character.</p>
</td></tr>
<tr><td><code id="compar.ou_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="compar.ou_+3A_node">node</code></td>
<td>
<p>a vector giving the number(s) of the node(s) where the
parameter &lsquo;theta&rsquo; (the trait optimum) is assumed to change. The
node(s) can be specified with their labels if <code>phy</code> has node
labels. By default there is no change (same optimum thoughout lineages).</p>
</td></tr>
<tr><td><code id="compar.ou_+3A_alpha">alpha</code></td>
<td>
<p>the value of <code class="reqn">\alpha</code> to be used when fitting
the model. By default, this parameter is estimated (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Ornstein&ndash;Uhlenbeck (OU) process can be seen as a generalization
of the Brownian motion process. In the latter, characters are assumed
to evolve randomly under a random walk, that is change is equally
likely in any direction. In the OU model, change is more likely
towards the direction of an optimum (denoted <code class="reqn">\theta</code>) with
a strength controlled by a parameter denoted <code class="reqn">\alpha</code>.
</p>
<p>The present function fits a model where the optimum parameter
<code class="reqn">\theta</code>, is allowed to vary throughout the tree. This is
specified with the argument <code>node</code>: <code class="reqn">\theta</code> changes
after each node whose number is given there. Note that the optimum
changes <em>only</em> for the lineages which are descendants of this
node.
</p>
<p>Hansen (1997) recommends to not estimate <code class="reqn">\alpha</code> together
with the other parameters. The present function allows this by giving
a numeric value to the argument <code>alpha</code>. By default, this
parameter is estimated, but this seems to yield very large
standard-errors, thus validating Hansen's recommendation. In practice,
a &ldquo;poor man estimation&rdquo; of <code class="reqn">\alpha</code> can be done by
repeating the function call with different values of <code>alpha</code>, and
selecting the one that minimizes the deviance (see Hansen 1997 for an
example).
</p>
<p>If <code>x</code> has names, its values are matched to the tip labels of
<code>phy</code>, otherwise its values are taken to be in the same order
than the tip labels of <code>phy</code>.
</p>
<p>The user must be careful here since the function requires that both
series of names perfectly match, so this operation may fail if there
is a typing or syntax error. If both series of names do not match, the
values in the <code>x</code> are taken to be in the same order than the tip
labels of <code>phy</code>, and a warning message is issued.
</p>


<h3>Value</h3>

<p>an object of class <code>"compar.ou"</code> which is list with the following
components:
</p>
<table>
<tr><td><code>deviance</code></td>
<td>
<p>the deviance (= -2 * loglik).</p>
</td></tr>
<tr><td><code>para</code></td>
<td>
<p>a data frame with the maximum likelihood estimates and
their standard-errors.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The inversion of the variance-covariance matrix in the likelihood
function appeared as somehow problematic. The present implementation
uses a Cholevski decomposition with the function
<code><a href="base.html#topic+chol2inv">chol2inv</a></code> instead of the usual function
<code><a href="base.html#topic+solve">solve</a></code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Hansen, T. F. (1997) Stabilizing selection and the comparative
analysis of adaptation. <em>Evolution</em>, <b>51</b>, 1341&ndash;1351.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ace">ace</a></code>, <code><a href="#topic+compar.lynch">compar.lynch</a></code>,
<code><a href="#topic+corBrownian">corBrownian</a></code>, <code><a href="#topic+corMartins">corMartins</a></code>, <code><a href="#topic+pic">pic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bird.orders)
### This is likely to give you estimates close to 0, 1, and 0
### for alpha, sigma^2, and theta, respectively:
compar.ou(x &lt;- rnorm(23), bird.orders)
### Much better with a fixed alpha:
compar.ou(x, bird.orders, alpha = 0.1)
### Let us 'mimick' the effect of different optima
### for the two clades of birds...
x &lt;- c(rnorm(5, 0), rnorm(18, 5))
### ... the model with two optima:
compar.ou(x, bird.orders, node = 25, alpha = .1)
### ... and the model with a single optimum:
compar.ou(x, bird.orders, node = NULL, alpha = .1)
### =&gt; Compare both models with the difference in deviances
##     which follows a chi^2 with df = 1.
</code></pre>

<hr>
<h2 id='comparePhylo'>Compare Two &quot;phylo&quot; Objects</h2><span id='topic+comparePhylo'></span><span id='topic+print.comparePhylo'></span>

<h3>Description</h3>

<p>This function compares two phylogenetic trees, rooted or unrooted, and
returns a detailed report of this comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparePhylo(x, y, plot = FALSE, force.rooted = FALSE,
             use.edge.length = FALSE, commons = TRUE,
             location = "bottomleft", ...)
## S3 method for class 'comparePhylo'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparePhylo_+3A_x">x</code>, <code id="comparePhylo_+3A_y">y</code></td>
<td>
<p>two objects of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="comparePhylo_+3A_plot">plot</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the two trees are plotted
on the same device and their similarities are shown.</p>
</td></tr>
<tr><td><code id="comparePhylo_+3A_force.rooted">force.rooted</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the trees are
considered rooted even if <code>is.rooted</code> returns <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="comparePhylo_+3A_use.edge.length">use.edge.length</code></td>
<td>
<p>a logical value passed to
<code><a href="#topic+plot.phylo">plot.phylo</a></code> (see below).</p>
</td></tr>
<tr><td><code id="comparePhylo_+3A_commons">commons</code></td>
<td>
<p>whether to show the splits (the default), or the splits
specific to each tree (applies only for unrooted trees).</p>
</td></tr>
<tr><td><code id="comparePhylo_+3A_location">location</code></td>
<td>
<p>location of where to position the <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="comparePhylo_+3A_...">...</code></td>
<td>
<p>further parameters used by <code><a href="#topic+plot.phylo">plot.phylo</a></code>, in function
<code>print.comparePhylo</code> unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In all cases, the numbers of tips and of nodes and the tip labels are
compared.
</p>
<p>If both trees are rooted, or if <code>force.rooted = TRUE</code>, the clade
compositions of each tree are compared. If both trees are also
ultrametric, their branching times are compared.
</p>
<p>If both trees are unrooted and have the same number of nodes, the
bipartitions (aka splits) are compared.
</p>
<p>If <code>plot = TRUE</code>, the edge lengths are not used by default
because in some situations with unrooted trees, some splits might not
be visible if the corresponding internal edge length is very short. To
use edge lengths, set <code>use.edge.length = TRUE</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>"comparePhylo"</code> which is a list with messages
from the comparison and, optionally, tables comparing branching times.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis, Klaus Schliep</p>


<h3>See Also</h3>

<p><code><a href="#topic+all.equal.phylo">all.equal.phylo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## two unrooted trees but force comparison as rooted:
a &lt;- read.tree(text = "(a,b,(c,d));")
b &lt;- read.tree(text = "(a,c,(b,d));")
comparePhylo(a, b, plot = TRUE, force.rooted = TRUE)
## two random unrooted trees:
c &lt;- rtree(5, rooted = FALSE)
d &lt;- rtree(5, rooted = FALSE)
comparePhylo(c, d, plot = TRUE)
</code></pre>

<hr>
<h2 id='compute.brlen'>Branch Lengths Computation</h2><span id='topic+compute.brlen'></span>

<h3>Description</h3>

<p>This function computes branch lengths of a tree using different
methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.brlen(phy, method = "Grafen", power = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.brlen_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>phylo</code> representing the tree.</p>
</td></tr>
<tr><td><code id="compute.brlen_+3A_method">method</code></td>
<td>
<p>the method to be used to compute the branch lengths;
this must be one of the followings: (i) <code>"Grafen"</code> (the
default), (ii) a numeric vector, or (iii) a function.</p>
</td></tr>
<tr><td><code id="compute.brlen_+3A_power">power</code></td>
<td>
<p>The power at which heights must be raised (see below).</p>
</td></tr>
<tr><td><code id="compute.brlen_+3A_...">...</code></td>
<td>
<p>further argument(s) to be passed to <code>method</code> if it is
a function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Grafen's (1989) computation of branch lengths: each node is given a
&lsquo;height&rsquo;, namely the number of leaves of the subtree minus one, 0 for
leaves. Each height is scaled so that root height is 1, and then
raised at power 'rho' (&gt; 0). Branch lengths are then computed as the
difference between height of lower node and height of upper node.
</p>
<p>If one or several numeric values are provided as <code>method</code>, they
are recycled if necessary. If a function is given instead, further
arguments are given in place of <code>...</code> (they must be named, see
examples).
</p>
<p>Zero-length branches are not treated as multichotomies, and thus may
need to be collapsed (see <code><a href="#topic+di2multi">di2multi</a></code>).
</p>


<h3>Value</h3>

<p>An object of class <code>phylo</code> with branch lengths.
</p>


<h3>Author(s)</h3>

<p>Julien Dutheil <a href="mailto:dutheil@evolbio.mpg.de">dutheil@evolbio.mpg.de</a> and
Emmanuel Paradis</p>


<h3>References</h3>

<p>Grafen, A. (1989) The phylogenetic regression. <em>Philosophical
Transactions of the Royal society of London. Series B. Biological
Sciences</em>, <b>326</b>, 119&ndash;157.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.tree">read.tree</a></code> for a description of <code>phylo</code> objects,
<code><a href="#topic+di2multi">di2multi</a></code>, <code><a href="#topic+multi2di">multi2di</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bird.orders)
plot(compute.brlen(bird.orders, 1))
plot(compute.brlen(bird.orders, runif, min = 0, max = 5))
layout(matrix(1:4, 2, 2))
plot(compute.brlen(bird.orders, power=1), main=expression(rho==1))
plot(compute.brlen(bird.orders, power=3), main=expression(rho==3))
plot(compute.brlen(bird.orders, power=0.5), main=expression(rho==0.5))
plot(compute.brlen(bird.orders, power=0.1), main=expression(rho==0.1))
layout(1)
</code></pre>

<hr>
<h2 id='compute.brtime'>Compute and Set Branching Times</h2><span id='topic+compute.brtime'></span>

<h3>Description</h3>

<p>This function computes the branch lengths of a tree giving its
branching times (aka node ages or heights).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.brtime(phy, method = "coalescent", force.positive = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.brtime_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="compute.brtime_+3A_method">method</code></td>
<td>
<p>either <code>"coalescent"</code> (the default), or a numeric
vector giving the branching times.</p>
</td></tr>
<tr><td><code id="compute.brtime_+3A_force.positive">force.positive</code></td>
<td>
<p>a logical value (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, a set of random branching times is generated from a simple
coalescent, and the option <code>force.positive</code> is set to <code>TRUE</code>
so that no branch length is negative.
</p>
<p>If a numeric vector is passed to <code>method</code>, it is taken as the
branching times of the nodes with respect to their numbers (i.e., the
first element of <code>method</code> is the branching time of the node
numbered <code class="reqn">n + 1</code> [= the root], the second element of the node
numbered <code class="reqn">n + 2</code>, and so on), so <code>force.positive</code> is set to
<code>FALSE</code>. This may result in negative branch lengths. To avoid
this, one should use <code>force.positive = TRUE</code> in which case the
branching times are eventually reordered.
</p>


<h3>Value</h3>

<p>An object of class <code>"phylo"</code> with branch lengths and ultrametric.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute.brlen">compute.brlen</a></code>, <code><a href="#topic+branching.times">branching.times</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tr &lt;- rtree(10)
layout(matrix(1:4, 2))
plot(compute.brtime(tr)); axisPhylo()
plot(compute.brtime(tr, force.positive = FALSE)); axisPhylo()
plot(compute.brtime(tr, 1:9)); axisPhylo() # a bit nonsense
plot(compute.brtime(tr, 1:9, TRUE)); axisPhylo()
layout(1)
</code></pre>

<hr>
<h2 id='consensus'>Concensus Trees</h2><span id='topic+consensus'></span>

<h3>Description</h3>

<p>Given a series of trees, this function returns the consensus tree. By
default, the strict-consensus tree is computed. To get the
majority-rule consensus tree, use <code>p = 0.5</code>. Any value between
0.5 and 1 can be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consensus(..., p = 1, check.labels = TRUE, rooted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="consensus_+3A_...">...</code></td>
<td>
<p>either (i) a single object of class <code>"phylo"</code>, (ii) a
series of such objects separated by commas, or (iii) a list
containing such objects.</p>
</td></tr>
<tr><td><code id="consensus_+3A_p">p</code></td>
<td>
<p>a numeric value between 0.5 and 1 giving the proportion for a
clade to be represented in the consensus tree.</p>
</td></tr>
<tr><td><code id="consensus_+3A_check.labels">check.labels</code></td>
<td>
<p>a logical specifying whether to check the labels
of each tree. If <code>FALSE</code> (the default), it is assumed that all
trees have the same tip labels, and that they are in the same order
(see details).</p>
</td></tr>
<tr><td><code id="consensus_+3A_rooted">rooted</code></td>
<td>
<p>a logical specifying whether the trees should be treated as
rooted or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using <code>check.labels = FALSE</code> results in
considerable decrease in computing times. This requires that all
trees have the same tip labels, <em>and</em> these labels are
ordered similarly in all trees (in other words, the element
<code>tip.label</code> are identical in all trees).
</p>
<p>Until <span class="pkg">ape</span> 5.6-2, the trees passed to this function were
implicitly treated as rooted, even when the option <code>rooted =
  FALSE</code> was used. This is now fixed (see PR65 on GitHub) so that, by
default, the trees are explicitly treated as unrooted (even if
<code><a href="#topic+is.rooted">is.rooted</a></code> returns <code>TRUE</code>). Thus, it could
be that results now differ from previous analyses (setting
<code>rooted = TRUE</code> might help to replicate previous results).
</p>


<h3>Value</h3>

<p>an object of class <code>"phylo"</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Felsenstein, J. (2004) <em>Inferring Phylogenies</em>. Sunderland:
Sinauer Associates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prop.part">prop.part</a></code>, <code><a href="#topic+dist.topo">dist.topo</a></code>
</p>

<hr>
<h2 id='cophenetic.phylo'>Pairwise Distances from a Phylogenetic Tree</h2><span id='topic+cophenetic.phylo'></span><span id='topic+dist.nodes'></span>

<h3>Description</h3>

<p><code>cophenetic.phylo</code> computes the pairwise distances between the
pairs of tips from a phylogenetic tree using its branch lengths.
</p>
<p><code>dist.nodes</code> does the same but between all nodes, internal and
terminal, of the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phylo'
cophenetic(x)
dist.nodes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cophenetic.phylo_+3A_x">x</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric matrix with colnames and rownames set to the names of the
tips (as given by the element <code>tip.label</code> of the argument
<code>phy</code>), or, in the case of <code>dist.nodes</code>, the numbers of the
tips and the nodes (as given by the element <code>edge</code>).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.tree">read.tree</a></code> to read tree files in Newick format,
<code><a href="stats.html#topic+cophenetic">cophenetic</a></code> for the generic function
</p>

<hr>
<h2 id='cophyloplot'>Plots two phylogenetic trees face to face with links between the tips.</h2><span id='topic+cophyloplot'></span>

<h3>Description</h3>

<p>This function plots two trees face to face with the links if specified. It is possible to rotate the branches of each tree around the nodes by clicking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cophyloplot(x, y, assoc = NULL, use.edge.length = FALSE, space = 0,
       length.line = 1, gap = 2, type = "phylogram", rotate = FALSE,
       col = par("fg"), lwd = par("lwd"), lty = par("lty"),
       show.tip.label = TRUE, font = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cophyloplot_+3A_x">x</code>, <code id="cophyloplot_+3A_y">y</code></td>
<td>
<p>two objects of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="cophyloplot_+3A_assoc">assoc</code></td>
<td>
<p>a matrix with 2 columns specifying the associations
between the tips. If NULL, no links will be drawn.</p>
</td></tr>
<tr><td><code id="cophyloplot_+3A_use.edge.length">use.edge.length</code></td>
<td>
<p>a logical indicating whether the branch lengths
should be used to plot the trees; default is FALSE.</p>
</td></tr>
<tr><td><code id="cophyloplot_+3A_space">space</code></td>
<td>
<p>a positive value that specifies the distance between the
two trees.</p>
</td></tr>
<tr><td><code id="cophyloplot_+3A_length.line">length.line</code></td>
<td>
<p>a positive value that specifies the length of the
horizontal line associated to each taxa. Default is 1.</p>
</td></tr>
<tr><td><code id="cophyloplot_+3A_gap">gap</code></td>
<td>
<p>a value specifying the distance between the tips of the
phylogeny and the lines.</p>
</td></tr>
<tr><td><code id="cophyloplot_+3A_type">type</code></td>
<td>
<p>a character string specifying the type of phylogeny to be
drawn; it must be one of &quot;phylogram&quot; (the default) or &quot;cladogram&quot;.</p>
</td></tr>
<tr><td><code id="cophyloplot_+3A_rotate">rotate</code></td>
<td>
<p>a logical indicating whether the nodes of the phylogeny
can be rotated by clicking. Default is FALSE.</p>
</td></tr>
<tr><td><code id="cophyloplot_+3A_col">col</code></td>
<td>
<p>a character vector indicating the color to be used for the
links; recycled as necessary.</p>
</td></tr>
<tr><td><code id="cophyloplot_+3A_lwd">lwd</code></td>
<td>
<p>id. for the width.</p>
</td></tr>
<tr><td><code id="cophyloplot_+3A_lty">lty</code></td>
<td>
<p>id. for the line type.</p>
</td></tr>
<tr><td><code id="cophyloplot_+3A_show.tip.label">show.tip.label</code></td>
<td>
<p>a logical indicating whether to show the tip
labels on the phylogeny (defaults to 'TRUE', i.e. the labels are
shown).</p>
</td></tr>
<tr><td><code id="cophyloplot_+3A_font">font</code></td>
<td>
<p>an integer specifying the type of font for the
labels: 1 (plain text), 2 (bold), 3 (italic, the default), or 4
(bold italic).</p>
</td></tr>
<tr><td><code id="cophyloplot_+3A_...">...</code></td>
<td>
<p>(unused)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aim of this function is to plot simultaneously two phylogenetic trees with associated taxa. The two trees do not necessarily have the same number of tips and more than one tip in one phylogeny can be associated with a tip in the other.
</p>
<p>The association matrix used to draw the links has to be a matrix with two columns containing the names of the tips. One line in the matrix represents one link on the plot. The first column of the matrix has to contain tip labels of the first tree (<code>phy1</code>) and the second column of the matrix, tip labels of the second tree (<code>phy2</code>). There is no limit (low or high) for the number of lines in the matrix. A matrix with two colums and one line will give a plot with one link.
</p>
<p>Arguments <code>gap</code>, <code>length.line</code> and <code>space</code> have to be changed to get a nice plot of the two phylogenies. Note that the function takes into account the length of the character strings corresponding to the names at the tips, so that the lines do not overwrite those names.
</p>
<p>The <code>rotate</code> argument can be used to transform both phylogenies in order to get the more readable plot (typically by decreasing the number of crossing lines). This can be done by clicking on the nodes. The escape button or right click take back to the console.
</p>


<h3>Author(s)</h3>

<p>Damien de Vienne <a href="mailto:damien.de-vienne@u-psud.fr">damien.de-vienne@u-psud.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.phylo">plot.phylo</a></code>, <code><a href="#topic+rotate">rotate</a></code>, <code><a href="#topic+rotateConstr">rotateConstr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#two random trees
tree1 &lt;- rtree(40)
tree2 &lt;- rtree(20)

#creation of the association matrix:
association &lt;- cbind(tree2$tip.label, tree2$tip.label)

cophyloplot(tree1, tree2, assoc = association,
            length.line = 4, space = 28, gap = 3)

#plot with rotations
## Not run: 
cophyloplot(tree1, tree2, assoc=association, length.line=4, space=28, gap=3, rotate=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='corBlomberg'>Blomberg et al.'s Correlation Structure</h2><span id='topic+corBlomberg'></span><span id='topic+coef.corBlomberg'></span><span id='topic+corMatrix.corBlomberg'></span>

<h3>Description</h3>

<p>The &ldquo;ACDC&rdquo; (accelerated/decelerated) model assumes that continuous
traits evolve under a Brownian motion model which rates accelerates
(if <code class="reqn">g</code> &lt; 1) or decelerates (if <code class="reqn">g</code> &gt; 1) through
time. If <code class="reqn">g</code> = 1, then the model reduces to a Brownian motion
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corBlomberg(value, phy, form = ~1, fixed = FALSE)
## S3 method for class 'corBlomberg'
corMatrix(object, covariate = getCovariate(object),
                   corr = TRUE, ...)
## S3 method for class 'corBlomberg'
coef(object, unconstrained = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corBlomberg_+3A_value">value</code></td>
<td>
<p>the (initial) value of the parameter <code class="reqn">g</code>.</p>
</td></tr>
<tr><td><code id="corBlomberg_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="corBlomberg_+3A_form">form</code></td>
<td>
<p>a one sided formula of the form ~ t, or ~ t | g,
specifying the taxa covariate t and, optionally, a grouping factor
g. A covariate for this correlation structure must be character
valued, with entries matching the tip labels in the phylogenetic
tree. When a grouping factor is present in form, the correlation
structure is assumed to apply only to observations within the same
grouping level; observations with different grouping levels are
assumed to be uncorrelated. Defaults to ~ 1, which corresponds to
using the order of the observations in the data as a covariate, and
no groups.</p>
</td></tr>
<tr><td><code id="corBlomberg_+3A_fixed">fixed</code></td>
<td>
<p>a logical specifying whether <code>gls</code> should
estimate <code class="reqn">\gamma</code> (the default) or keep it fixed.</p>
</td></tr>
<tr><td><code id="corBlomberg_+3A_object">object</code></td>
<td>
<p>an (initialized) object of class <code>"corBlomberg"</code>.</p>
</td></tr>
<tr><td><code id="corBlomberg_+3A_covariate">covariate</code></td>
<td>
<p>an optional covariate vector (matrix), or list of
covariate vectors (matrices), at which values the correlation
matrix, or list of correlation matrices, are to be
evaluated. Defaults to getCovariate(object).</p>
</td></tr>
<tr><td><code id="corBlomberg_+3A_corr">corr</code></td>
<td>
<p>a logical value specifying whether to return the
correlation matrix (the default) or the variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="corBlomberg_+3A_unconstrained">unconstrained</code></td>
<td>
<p>a logical value. If <code>TRUE</code> (the default),
the coefficients are returned in unconstrained form (the same used
in the optimization algorithm). If <code>FALSE</code> the coefficients are
returned in &ldquo;natural&rdquo;, possibly constrained, form.</p>
</td></tr>
<tr><td><code id="corBlomberg_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"corBlomberg"</code>, the coefficients from an
object of this class, or the correlation matrix of an initialized
object of this class. In most situations, only <code>corBlomberg</code> will
be called by the user.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Blomberg, S. P., Garland, Jr, T., and Ives, A. R. (2003) Testing for
phylogenetic signal in comparative data: behavioral traits are more
labile. <em>Evolution</em>, <b>57</b>, 717&ndash;745.
</p>

<hr>
<h2 id='corBrownian'>Brownian Correlation Structure</h2><span id='topic+corBrownian'></span><span id='topic+coef.corBrownian'></span><span id='topic+corMatrix.corBrownian'></span>

<h3>Description</h3>

<p>Expected covariance under a Brownian model (Felsenstein 1985,	Martins
and Hansen 1997)
</p>
<p style="text-align: center;"><code class="reqn">V_{ij} = \gamma \times t_a</code>
</p>

<p>where <code class="reqn">t_a</code> is the distance on the phylogeny between the root
and the most recent common ancestor of taxa <code class="reqn">i</code> and <code class="reqn">j</code>
and <code class="reqn">\gamma</code> is a constant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corBrownian(value=1, phy, form=~1)
## S3 method for class 'corBrownian'
coef(object, unconstrained = TRUE, ...)
## S3 method for class 'corBrownian'
corMatrix(object, covariate = getCovariate(object), corr = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corBrownian_+3A_value">value</code></td>
<td>
<p>The <code class="reqn">\gamma</code> parameter (default to 1). The
exact value has no effect on model fitting with PGLS.</p>
</td></tr>
<tr><td><code id="corBrownian_+3A_phy">phy</code></td>
<td>
<p>An object of class <code>phylo</code> representing the phylogeny
(with branch lengths) to consider.</p>
</td></tr>
<tr><td><code id="corBrownian_+3A_object">object</code></td>
<td>
<p>An (initialized) object of class <code>corBrownian</code>.</p>
</td></tr>
<tr><td><code id="corBrownian_+3A_corr">corr</code></td>
<td>
<p>a logical value. If 'TRUE' the function returns the
correlation matrix, otherwise it returns the variance/covariance matrix.</p>
</td></tr>
<tr><td><code id="corBrownian_+3A_form">form</code></td>
<td>
<p>a one sided formula of the form ~ t, or ~ t | g, specifying the taxa covariate t and, optionally, a grouping factor g. A covariate for this correlation structure must be character valued, with entries matching the tip labels in the phylogenetic tree. When a grouping factor is present in form, the correlation structure is assumed to apply only to observations within the same grouping level; observations with different grouping levels are assumed to be uncorrelated. Defaults to ~ 1, which corresponds to using the order of the observations in the data as a covariate, and no groups.</p>
</td></tr>
<tr><td><code id="corBrownian_+3A_covariate">covariate</code></td>
<td>
<p>an optional covariate vector (matrix), or list of covariate vectors (matrices), at which values the correlation matrix, or list of correlation matrices, are to be evaluated. Defaults to getCovariate(object).</p>
</td></tr>
<tr><td><code id="corBrownian_+3A_unconstrained">unconstrained</code></td>
<td>
<p>a logical value. If 'TRUE' the coefficients are returned
in unconstrained form (the same used in the optimization
algorithm). If 'FALSE' the coefficients are returned in
&quot;natural&quot;, possibly constrained, form. Defaults to 'TRUE'</p>
</td></tr>
<tr><td><code id="corBrownian_+3A_...">...</code></td>
<td>
<p>some methods for these generics require additional arguments.
None are used in these methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>corBrownian</code>, or the coefficient from an
object of this class (actually sends <code>numeric(0)</code>), or the
correlation matrix of an initialized object of this class.
</p>


<h3>Author(s)</h3>

<p>Julien Dutheil <a href="mailto:dutheil@evolbio.mpg.de">dutheil@evolbio.mpg.de</a></p>


<h3>References</h3>

<p>Felsenstein, J. (1985) Phylogenies and the comparative method.
<em>American Naturalist</em>, <b>125</b>, 1&ndash;15.
</p>
<p>Martins, E. P. and Hansen, T. F. (1997) Phylogenies and the comparative
method: a general approach to incorporating phylogenetic information
into the analysis of interspecific data. <em>American Naturalist</em>,
<b>149</b>, 646&ndash;667.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corClasses">corClasses</a></code>
</p>

<hr>
<h2 id='corClasses'>Phylogenetic Correlation Structures</h2><span id='topic+corClasses'></span><span id='topic+corPhyl'></span>

<h3>Description</h3>

<p>Classes of phylogenetic correlation structures (<code>"corPhyl"</code>)
available in <span class="pkg">ape</span>.
</p>

<ul>
<li><p> corBrownian: Brownian motion model (Felsenstein 1985)
</p>
</li>
<li><p> corMartins: The covariance matrix defined in Martins and Hansen
(1997)
</p>
</li>
<li><p> corGrafen: The covariance matrix defined in Grafen (1989)
</p>
</li>
<li><p> corPagel: The covariance matrix defined in Freckelton et al. (2002)
</p>
</li>
<li><p> corBlomberg: The covariance matrix defined in Blomberg et al. (2003)
</p>
</li></ul>

<p>See the help page of each class for references and detailed
description.
</p>


<h3>Author(s)</h3>

<p>Julien Dutheil <a href="mailto:dutheil@evolbio.mpg.de">dutheil@evolbio.mpg.de</a>, Emmanuel
Paradis</p>


<h3>See Also</h3>

<p><code><a href="nlme.html#topic+corClasses">corClasses</a></code> and <code><a href="nlme.html#topic+gls">gls</a></code> in the
<span class="pkg">nlme</span> librarie, <code><a href="#topic+corBrownian">corBrownian</a></code>,
<code><a href="#topic+corMartins">corMartins</a></code>, <code><a href="#topic+corGrafen">corGrafen</a></code>,
<code><a href="#topic+corPagel">corPagel</a></code>, <code><a href="#topic+corBlomberg">corBlomberg</a></code>,
<code><a href="#topic+vcv">vcv</a></code>, <code><a href="#topic+vcv2phylo">vcv2phylo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(nlme)
txt &lt;- "((((Homo:0.21,Pongo:0.21):0.28,Macaca:0.49):0.13,Ateles:0.62):0.38,Galago:1.00);"
tree.primates &lt;- read.tree(text = txt)
X &lt;- c(4.09434, 3.61092, 2.37024, 2.02815, -1.46968)
Y &lt;- c(4.74493, 3.33220, 3.36730, 2.89037, 2.30259)
Species &lt;- c("Homo", "Pongo", "Macaca", "Ateles", "Galago")
dat &lt;- data.frame(Species = Species, X = X, Y = Y)

m1 &lt;- gls(Y ~ X, dat, correlation=corBrownian(1, tree.primates, form = ~Species))
summary(m1)
m2 &lt;- gls(Y ~ X, dat, correlation=corMartins(1, tree.primates, form = ~Species))
summary(m2)
corMatrix(m2$modelStruct$corStruct)
m3 &lt;- gls(Y ~ X, dat, correlation=corGrafen(1, tree.primates, form = ~Species))
summary(m3)
corMatrix(m3$modelStruct$corStruct)
</code></pre>

<hr>
<h2 id='corGrafen'>Grafen's (1989) Correlation Structure</h2><span id='topic+corGrafen'></span><span id='topic+coef.corGrafen'></span><span id='topic+corMatrix.corGrafen'></span>

<h3>Description</h3>

<p>Grafen's (1989) covariance structure. Branch lengths are computed using
Grafen's method (see <code><a href="#topic+compute.brlen">compute.brlen</a></code>). The covariance
matrice is then the traditional variance-covariance matrix for a
phylogeny.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corGrafen(value, phy, form=~1, fixed = FALSE)
## S3 method for class 'corGrafen'
coef(object, unconstrained = TRUE, ...)
## S3 method for class 'corGrafen'
corMatrix(object,
                  covariate = getCovariate(object), corr = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corGrafen_+3A_value">value</code></td>
<td>
<p>The <code class="reqn">\rho</code> parameter</p>
</td></tr>
<tr><td><code id="corGrafen_+3A_phy">phy</code></td>
<td>
<p>An object of class <code>phylo</code> representing the phylogeny
(branch lengths are ignored) to consider</p>
</td></tr>
<tr><td><code id="corGrafen_+3A_object">object</code></td>
<td>
<p>An (initialized) object of class <code>corGrafen</code></p>
</td></tr>
<tr><td><code id="corGrafen_+3A_corr">corr</code></td>
<td>
<p>a logical value. If 'TRUE' the function returns the
correlation matrix, otherwise it returns the variance/covariance
matrix.</p>
</td></tr>
<tr><td><code id="corGrafen_+3A_fixed">fixed</code></td>
<td>
<p>an optional logical value indicating whether the
coefficients should be allowed to vary in the optimization, or kept
fixed at their initial value. Defaults to 'FALSE', in which case the
coefficients are allowed to vary.</p>
</td></tr>
<tr><td><code id="corGrafen_+3A_form">form</code></td>
<td>
<p>a one sided formula of the form ~ t, or ~ t | g, specifying the taxa covariate t and, optionally, a grouping factor g. A covariate for this correlation structure must be character valued, with entries matching the tip labels in the phylogenetic tree. When a grouping factor is present in form, the correlation structure is assumed to apply only to observations within the same grouping level; observations with different grouping levels are assumed to be uncorrelated. Defaults to ~ 1, which corresponds to using the order of the observations in the data as a covariate, and no groups.</p>
</td></tr>
<tr><td><code id="corGrafen_+3A_covariate">covariate</code></td>
<td>
<p>an optional covariate vector (matrix), or list of covariate vectors (matrices), at which values the correlation matrix, or list of correlation matrices, are to be evaluated. Defaults to getCovariate(object).</p>
</td></tr>
<tr><td><code id="corGrafen_+3A_unconstrained">unconstrained</code></td>
<td>
<p>a logical value. If 'TRUE' the coefficients are
returned in unconstrained form (the same used in the optimization
algorithm). If 'FALSE' the coefficients are returned in &quot;natural&quot;,
possibly constrained, form. Defaults to 'TRUE'</p>
</td></tr>
<tr><td><code id="corGrafen_+3A_...">...</code></td>
<td>
<p>some methods for these generics require additional
arguments. None are used in these methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>corGrafen</code> or the rho coefficient from an
object of this class or the correlation matrix of an initialized
object of this class.
</p>


<h3>Author(s)</h3>

<p>Julien Dutheil <a href="mailto:dutheil@evolbio.mpg.de">dutheil@evolbio.mpg.de</a></p>


<h3>References</h3>

<p>Grafen, A. (1989) The phylogenetic regression. <em>Philosophical
Transactions of the Royal society of London. Series B. Biological
Sciences</em>, <b>326</b>, 119&ndash;157.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corClasses">corClasses</a></code>, <code><a href="#topic+compute.brlen">compute.brlen</a></code>, <code><a href="#topic+vcv.phylo">vcv.phylo</a></code>.
</p>

<hr>
<h2 id='corMartins'>Martins's (1997) Correlation Structure</h2><span id='topic+corMartins'></span><span id='topic+coef.corMartins'></span><span id='topic+corMatrix.corMartins'></span>

<h3>Description</h3>

<p>Martins and Hansen's (1997) covariance structure:
</p>
<p style="text-align: center;"><code class="reqn">V_{ij} = \gamma \times e^{-\alpha t_{ij}}</code>
</p>

<p>where <code class="reqn">t_{ij}</code> is the phylogenetic distance between taxa <code class="reqn">i</code> and <code class="reqn">j</code> and <code class="reqn">\gamma</code> is a constant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corMartins(value, phy, form = ~1, fixed = FALSE)
## S3 method for class 'corMartins'
coef(object, unconstrained = TRUE, ...)
## S3 method for class 'corMartins'
corMatrix(object,
		covariate = getCovariate(object), corr = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corMartins_+3A_value">value</code></td>
<td>
<p>The <code class="reqn">\alpha</code> parameter</p>
</td></tr>
<tr><td><code id="corMartins_+3A_phy">phy</code></td>
<td>
<p>An object of class <code>phylo</code> representing the phylogeny
(with branch lengths) to consider</p>
</td></tr>
<tr><td><code id="corMartins_+3A_object">object</code></td>
<td>
<p>An (initialized) object of class <code>corMartins</code></p>
</td></tr>
<tr><td><code id="corMartins_+3A_corr">corr</code></td>
<td>
<p>a logical value. If 'TRUE' the function returns the
correlation matrix, otherwise it returns  the variance/covariance
matrix.</p>
</td></tr>
<tr><td><code id="corMartins_+3A_fixed">fixed</code></td>
<td>
<p>an optional logical value indicating whether the
coefficients should be allowed to vary in the optimization, ok kept
fixed at their initial value. Defaults to 'FALSE', in which case the
coefficients are allowed to vary.</p>
</td></tr>
<tr><td><code id="corMartins_+3A_form">form</code></td>
<td>
<p>a one sided formula of the form ~ t, or ~ t | g, specifying the taxa covariate t and, optionally, a grouping factor g. A covariate for this correlation structure must be character valued, with entries matching the tip labels in the phylogenetic tree. When a grouping factor is present in form, the correlation structure is assumed to apply only to observations within the same grouping level; observations with different grouping levels are assumed to be uncorrelated. Defaults to ~ 1, which corresponds to using the order of the observations in the data as a covariate, and no groups.</p>
</td></tr>
<tr><td><code id="corMartins_+3A_covariate">covariate</code></td>
<td>
<p>an optional covariate vector (matrix), or list of covariate vectors (matrices), at which values the correlation matrix, or list of correlation matrices, are to be evaluated. Defaults to getCovariate(object).</p>
</td></tr>
<tr><td><code id="corMartins_+3A_unconstrained">unconstrained</code></td>
<td>
<p>a logical value. If 'TRUE' the coefficients are returned
in unconstrained form (the same used in the optimization
algorithm). If 'FALSE' the coefficients are returned in
&quot;natural&quot;, possibly constrained, form. Defaults to 'TRUE'</p>
</td></tr>
<tr><td><code id="corMartins_+3A_...">...</code></td>
<td>
<p>some methods for these generics require additional arguments.
None are used in these methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>corMartins</code> or the alpha coefficient from an object of this class
or the correlation matrix of an initialized object of this class.
</p>


<h3>Author(s)</h3>

<p>Julien Dutheil <a href="mailto:dutheil@evolbio.mpg.de">dutheil@evolbio.mpg.de</a></p>


<h3>References</h3>

<p>Martins, E. P. and Hansen, T. F. (1997) Phylogenies and the comparative
method: a general approach to incorporating phylogenetic information
into the analysis of interspecific data. <em>American Naturalist</em>,
<b>149</b>, 646&ndash;667.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corClasses">corClasses</a></code>.
</p>

<hr>
<h2 id='corPagel'>Pagel's &ldquo;lambda&rdquo; Correlation Structure</h2><span id='topic+corPagel'></span><span id='topic+coef.corPagel'></span><span id='topic+corMatrix.corPagel'></span>

<h3>Description</h3>

<p>The correlation structure from the present model is derived from the
Brownian motion model by multiplying the off-diagonal elements (i.e.,
the covariances) by <code class="reqn">\lambda</code>. The variances are thus the
same than for a Brownian motion model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corPagel(value, phy, form = ~1, fixed = FALSE)
## S3 method for class 'corPagel'
corMatrix(object, covariate = getCovariate(object),
                   corr = TRUE, ...)
## S3 method for class 'corPagel'
coef(object, unconstrained = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corPagel_+3A_value">value</code></td>
<td>
<p>the (initial) value of the parameter
<code class="reqn">\lambda</code>.</p>
</td></tr>
<tr><td><code id="corPagel_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="corPagel_+3A_form">form</code></td>
<td>
<p>a one sided formula of the form ~ t, or ~ t | g, specifying the taxa covariate t and, optionally, a grouping factor g. A covariate for this correlation structure must be character valued, with entries matching the tip labels in the phylogenetic tree. When a grouping factor is present in form, the correlation structure is assumed to apply only to observations within the same grouping level; observations with different grouping levels are assumed to be uncorrelated. Defaults to ~ 1, which corresponds to using the order of the observations in the data as a covariate, and no groups.</p>
</td></tr>
<tr><td><code id="corPagel_+3A_fixed">fixed</code></td>
<td>
<p>a logical specifying whether <code>gls</code> should
estimate <code class="reqn">\lambda</code> (the default) or keep it fixed.</p>
</td></tr>
<tr><td><code id="corPagel_+3A_object">object</code></td>
<td>
<p>an (initialized) object of class <code>"corPagel"</code>.</p>
</td></tr>
<tr><td><code id="corPagel_+3A_covariate">covariate</code></td>
<td>
<p>an optional covariate vector (matrix), or list of covariate vectors (matrices), at which values the correlation matrix, or list of correlation matrices, are to be evaluated. Defaults to getCovariate(object).</p>
</td></tr>
<tr><td><code id="corPagel_+3A_corr">corr</code></td>
<td>
<p>a logical value specifying whether to return the
correlation matrix (the default) or the variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="corPagel_+3A_unconstrained">unconstrained</code></td>
<td>
<p>a logical value. If <code>TRUE</code> (the default),
the coefficients are returned in unconstrained form (the same used
in the optimization algorithm). If <code>FALSE</code> the coefficients are
returned in &ldquo;natural&rdquo;, possibly constrained, form.</p>
</td></tr>
<tr><td><code id="corPagel_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"corPagel"</code>, the coefficients from an object
of this class, or the correlation matrix of an initialized object of
this class. In most situations, only <code>corPagel</code> will be called
by the user.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Freckleton, R. P., Harvey, P. H. and M. Pagel, M. (2002) Phylogenetic
analysis and comparative data: a test and review of evidence.
<em>American Naturalist</em>, <b>160</b>, 712&ndash;726.
</p>
<p>Pagel, M. (1999) Inferring the historical patterns of biological
evolution. <em>Nature</em>, <b>401</b>,877&ndash;884.
</p>

<hr>
<h2 id='corphylo'>Correlations among Multiple Traits with Phylogenetic Signal</h2><span id='topic+corphylo'></span><span id='topic+print.corphylo'></span>

<h3>Description</h3>

<p>This function calculates Pearson correlation coefficients for multiple continuous traits that may have phylogenetic signal, allowing users to specify measurement error as the standard error of trait values at the tips of the phylogenetic tree.  Phylogenetic signal for each trait is estimated from the data assuming that trait evolution is given by a Ornstein-Uhlenbeck process.  Thus, the function allows the estimation of phylogenetic signal in multiple traits while incorporating correlations among traits. It is also possible to include independent variables (covariates) for each trait to remove possible confounding effects.  corphylo() returns the correlation matrix for trait values, estimates of phylogenetic signal for each trait, and regression coefficients for independent variables affecting each trait.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corphylo(X, U = list(), SeM = NULL, phy = NULL, REML = TRUE,
method = c("Nelder-Mead", "SANN"), constrain.d = FALSE, reltol = 10^-6,
maxit.NM = 1000, maxit.SA = 1000, temp.SA = 1, tmax.SA = 1, verbose = FALSE)

## S3 method for class 'corphylo'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corphylo_+3A_x">X</code></td>
<td>
<p>a n x p matrix with p columns containing the values for the n taxa. Rows of X should have rownames matching the taxon names in phy.</p>
</td></tr>
<tr><td><code id="corphylo_+3A_u">U</code></td>
<td>
<p>a list of p matrices corresponding to the p columns of X, with each matrix containing independent variables for the corresponding column of X. The rownames of each matrix within U must be the same as X, or alternatively, the order of values in rows must match those in X. If U is omitted, only the mean (aka intercept) for each column of X is estimated. If U[[i]] is NULL, only an intercept is estimated for X[, i]. If all values of U[[i]][j] are the same, this variable is automatically dropped from the analysis (i.e., there is no offset in the regression component of the model).</p>
</td></tr>
<tr><td><code id="corphylo_+3A_sem">SeM</code></td>
<td>
<p>a n x p matrix with p columns containing standard errors of the trait values in X. The rownames of SeM must be the same as X, or alternatively, the order of values in rows must match those in X. If SeM is omitted, the trait values are assumed to be known without error. If only some traits have mesurement errors, the remaining traits can be given zero-valued standard errors.</p>
</td></tr>
<tr><td><code id="corphylo_+3A_phy">phy</code></td>
<td>
<p>a phylo object giving the phylogenetic tree.  The rownames of phy must be the same as X, or alternatively, the order of values in rows must match those in X.</p>
</td></tr>
<tr><td><code id="corphylo_+3A_reml">REML</code></td>
<td>
<p>whether REML or ML is used for model fitting.</p>
</td></tr>
<tr><td><code id="corphylo_+3A_method">method</code></td>
<td>
<p>in optim(), either Nelder-Mead simplex minimization or SANN (simulated annealing) minimization is used. If SANN is used, it is followed by Nelder-Mead minimization.</p>
</td></tr>
<tr><td><code id="corphylo_+3A_constrain.d">constrain.d</code></td>
<td>
<p>if constrain.d is TRUE, the estimates of d are constrained to be between zero and 1. This can make estimation more stable and can be tried if convergence is problematic. This does not necessarily lead to loss of generality of the results, because before using corphylo, branch lengths of phy can be transformed so that the &quot;starter&quot; tree has strong phylogenetic signal.</p>
</td></tr>
<tr><td><code id="corphylo_+3A_reltol">reltol</code></td>
<td>
<p>a control parameter dictating the relative tolerance for convergence in the optimization; see optim().</p>
</td></tr>
<tr><td><code id="corphylo_+3A_maxit.nm">maxit.NM</code></td>
<td>
<p>a control parameter dictating the maximum number of iterations in the optimization with Nelder-Mead minimization; see optim().</p>
</td></tr>
<tr><td><code id="corphylo_+3A_maxit.sa">maxit.SA</code></td>
<td>
<p>a control parameter dictating the maximum number of iterations in the optimization with SANN minimization; see optim().</p>
</td></tr>
<tr><td><code id="corphylo_+3A_temp.sa">temp.SA</code></td>
<td>
<p>a control parameter dictating the starting temperature in the optimization with SANN minimization; see optim().</p>
</td></tr>
<tr><td><code id="corphylo_+3A_tmax.sa">tmax.SA</code></td>
<td>
<p>a control parameter dictating the number of function evaluations at each temperature in the optimization with SANN minimization; see optim().</p>
</td></tr>
<tr><td><code id="corphylo_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, the model logLik and running estimates of the
correlation coefficients and values of d are printed each iteration
during optimization.</p>
</td></tr>
<tr><td><code id="corphylo_+3A_x">x</code></td>
<td>
<p>an objects of class corphylo.</p>
</td></tr>
<tr><td><code id="corphylo_+3A_digits">digits</code></td>
<td>
<p>the number of digits to be printed.</p>
</td></tr>
<tr><td><code id="corphylo_+3A_...">...</code></td>
<td>
<p>arguments passed to and from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the case of two variables, the function estimates parameters for the model of the form, for example,
</p>
<p style="text-align: center;"><code class="reqn">X[1] =  B[1,0] + B[1,1] * u[1,1] + \epsilon[1]</code>
</p>

<p style="text-align: center;"><code class="reqn">X[2] =  B[2,0] + B[2,1] * u[2,1] + \epsilon[2]</code>
</p>

<p style="text-align: center;"><code class="reqn">\epsilon ~ Gaussian(0, V) </code>
</p>

<p>where <code class="reqn">B[1,0]</code>, <code class="reqn">B[1,1]</code>, <code class="reqn">B[2,0]</code>, and <code class="reqn">B[2,1]</code> are regression coefficients, and <code class="reqn">V</code> is a variance-covariance matrix containing the correlation coefficient r, parameters of the OU process <code class="reqn">d1</code> and <code class="reqn">d2</code>, and diagonal matrices <code class="reqn">M1</code> and <code class="reqn">M2</code> of measurement standard errors for <code class="reqn">X[1]</code> and <code class="reqn">X[2]</code>. The matrix <code class="reqn">V</code> is <code class="reqn">2n x 2n</code>, with <code class="reqn">n x n</code> blocks given by
</p>
<p style="text-align: center;"><code class="reqn">V[1,1] = C[1,1](d1) + M1</code>
</p>

<p style="text-align: center;"><code class="reqn">V[1,2] = C[1,2](d1,d2)</code>
</p>

<p style="text-align: center;"><code class="reqn">V[2,1] = C[2,1](d1,d2)</code>
</p>

<p style="text-align: center;"><code class="reqn">V[2,2] = C[2,2](d2) + M2</code>
</p>

<p>where <code class="reqn">C[i,j](d1,d2)</code> are derived from phy under the assumption of joint OU evolutionary processes for each trait (see Zheng et al. 2009).  This formulation extends in the obvious way to more than two traits.
</p>


<h3>Value</h3>

<p>An object of class &quot;corphylo&quot;.
</p>
<table>
<tr><td><code>cor.matrix</code></td>
<td>
<p>the p x p matrix of correlation coefficients.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>values of d from the OU process for each trait.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>estimates of the regression coefficients, including intercepts. Coefficients are named according to the list U. For example, B1.2 is the coefficient corresponding to U[[1]][, 2], and if column 2 in U[[1]] is named &quot;colname2&quot;, then the coefficient will be B1.colname2. Intercepts have the form B1.0.</p>
</td></tr>
<tr><td><code>B.se</code></td>
<td>
<p>standard errors of the regression coefficients.</p>
</td></tr>
<tr><td><code>B.cov</code></td>
<td>
<p>covariance matrix for regression coefficients.</p>
</td></tr>
<tr><td><code>B.zscore</code></td>
<td>
<p>Z scores for the regression coefficients.</p>
</td></tr>
<tr><td><code>B.pvalue</code></td>
<td>
<p>tests for the regression coefficients being different from zero.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>he log likelihood for either the restricted likelihood (REML = TRUE) or the overall likelihood (REML = FALSE).</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>AIC for either the restricted likelihood (REML = TRUE) or the overall likelihood (REML = FALSE).</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>BIC for either the restricted likelihood (REML = TRUE) or the overall likelihood (REML = FALSE).</p>
</td></tr>
<tr><td><code>REML</code></td>
<td>
<p>whether REML is used rather than ML (TRUE or FALSE).</p>
</td></tr>
<tr><td><code>constrain.d</code></td>
<td>
<p>whether or not values of d were constrained to be between 0 and 1 (TRUE or FALSE).</p>
</td></tr>
<tr><td><code>XX</code></td>
<td>
<p>values of X in vectorized form, with each trait X[, i] standardized to have mean zero and standard deviation one.</p>
</td></tr>
<tr><td><code>UU</code></td>
<td>
<p>design matrix with values in UU corresponding to XX; each variable U[[i]][, j] is standardized to have mean zero and standard deviation one.</p>
</td></tr>
<tr><td><code>MM</code></td>
<td>
<p>vector of measurement standard errors corresponding to XX, with the standard errors suitably standardized.</p>
</td></tr>
<tr><td><code>Vphy</code></td>
<td>
<p>the phylogenetic covariance matrix computed from phy and standardized to have determinant equal to one.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>covariance matrix of trait values relative to the standardized values of XX.</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>overall estimated covariance matrix of residuals for XX including trait correlations, phylogenetic signal, and measurement error variances. This matrix can be used to simulate data for parametric bootstrapping. See examples.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>matrix V excluding measurement error variances.</p>
</td></tr>
<tr><td><code>convcode</code></td>
<td>
<p>he convergence code provided by optim().</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>number of iterations performed by optim().</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Anthony R. Ives</p>


<h3>References</h3>

<p>Zheng, L., A. R. Ives, T. Garland, B. R. Larget, Y. Yu, and K. F. Cao. 2009. New multivariate tests for phylogenetic signal and trait correlations applied to ecophysiological phenotypes of nine <em>Manglietia</em> species. <em>Functional Ecology</em> <b>23</b>:1059&ndash;1069.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple example using data without correlations or phylogenetic
## signal. This illustrates the structure of the input data.

phy &lt;- rcoal(10, tip.label = 1:10)
X &lt;- matrix(rnorm(20), nrow = 10, ncol = 2)
rownames(X) &lt;- phy$tip.label
U &lt;- list(NULL, matrix(rnorm(10, mean = 10, sd = 4), nrow = 10, ncol = 1))
rownames(U[[2]]) &lt;- phy$tip.label
SeM &lt;- matrix(c(0.2, 0.4), nrow = 10, ncol = 2)
rownames(SeM) &lt;- phy$tip.label

corphylo(X = X, SeM = SeM, U = U, phy = phy, method = "Nelder-Mead")

## Not run: 
## Simulation example for the correlation between two variables. The
## example compares the estimates of the correlation coefficients from
## corphylo when measurement error is incorporated into the analyses with
## three other cases: (i) when measurement error is excluded, (ii) when
## phylogenetic signal is ignored (assuming a "star" phylogeny), and (iii)
## neither measurement error nor phylogenetic signal are included.

## In the simulations, variable 2 is associated with a single
## independent variable. This requires setting up a list U that has 2
## elements: element U[[1]] is NULL and element U[[2]] is a n x 1 vector
## containing simulated values of the independent variable.

# Set up parameter values for simulating data
n &lt;- 50
phy &lt;- rcoal(n, tip.label = 1:n)

R &lt;- matrix(c(1, 0.7, 0.7, 1), nrow = 2, ncol = 2)
d &lt;- c(0.3, .95)
B2 &lt;- 1

Se &lt;- c(0.2, 1)
SeM &lt;- matrix(Se, nrow = n, ncol = 2, byrow = T)
rownames(SeM) &lt;- phy$tip.label

# Set up needed matrices for the simulations
p &lt;- length(d)

star &lt;- stree(n)
star$edge.length &lt;- array(1, dim = c(n, 1))
star$tip.label &lt;- phy$tip.label

Vphy &lt;- vcv(phy)
Vphy &lt;- Vphy/max(Vphy)
Vphy &lt;- Vphy/exp(determinant(Vphy)$modulus[1]/n)

tau &lt;- matrix(1, nrow = n, ncol = 1) 
C &lt;- matrix(0, nrow = p * n, ncol = p * n)
for (i in 1:p) for (j in 1:p) {
	Cd &lt;- (d[i]^tau * (d[j]^t(tau)) * (1 - (d[i] * d[j])^Vphy))/(1 - d[i] * d[j])
	C[(n * (i - 1) + 1):(i * n), (n * (j - 1) + 1):(j * n)] &lt;- R[i, j] * Cd
}
MM &lt;- matrix(SeM^2, ncol = 1)
V &lt;- C + diag(as.numeric(MM))

## Perform a Cholesky decomposition of Vphy. This is used to generate
## phylogenetic signal: a vector of independent normal random variables,
## when multiplied by the transpose of the Cholesky deposition of Vphy will
## have covariance matrix equal to Vphy.
iD &lt;- t(chol(V))

# Perform Nrep simulations and collect the results
Nrep &lt;- 100
cor.list &lt;- matrix(0, nrow = Nrep, ncol = 1)
cor.noM.list &lt;- matrix(0, nrow = Nrep, ncol = 1)
cor.noP.list &lt;- matrix(0, nrow = Nrep, ncol = 1)
cor.noMP.list &lt;- matrix(0, nrow = Nrep, ncol = 1)
d.list &lt;- matrix(0, nrow = Nrep, ncol = 2)
d.noM.list &lt;- matrix(0, nrow = Nrep, ncol = 2)
B.list &lt;- matrix(0, nrow = Nrep, ncol = 3)
B.noM.list &lt;- matrix(0, nrow = Nrep, ncol = 3)
B.noP.list &lt;- matrix(0, nrow = Nrep, ncol = 3)
for (rep in 1:Nrep) {
	XX &lt;- iD 
	X &lt;- matrix(XX, nrow = n, ncol = 2)
	rownames(X) &lt;- phy$tip.label

	U &lt;- list(NULL, matrix(rnorm(n, mean = 2, sd = 10), nrow = n, ncol = 1))
	rownames(U[[2]]) &lt;- phy$tip.label
	colnames(U[[2]]) &lt;- "V1"
	X[,2] &lt;- X[,2] + B2[1] * U[[2]][,1] - B2[1] * mean(U[[2]][,1])

	z &lt;- corphylo(X = X, SeM = SeM, U = U, phy = phy, method = "Nelder-Mead")
	z.noM &lt;- corphylo(X = X, U = U, phy = phy, method = "Nelder-Mead")
	z.noP &lt;- corphylo(X = X, SeM = SeM, U = U, phy = star, method = "Nelder-Mead")

	cor.list[rep] &lt;- z$cor.matrix[1, 2]
	cor.noM.list[rep] &lt;- z.noM$cor.matrix[1, 2]
	cor.noP.list[rep] &lt;- z.noP$cor.matrix[1, 2]
	cor.noMP.list[rep] &lt;- cor(cbind(lm(X[,1] ~ 1)$residuals, lm(X[,2] ~ U[[2]])$residuals))[1,2]

	d.list[rep, ] &lt;- z$d
	d.noM.list[rep, ] &lt;- z.noM$d

	B.list[rep, ] &lt;- z$B
	B.noM.list[rep, ] &lt;- z.noM$B
	B.noP.list[rep, ] &lt;- z.noP$B

	show(c(rep, z$convcode, z$cor.matrix[1, 2], z$d))
}
correlation &lt;- rbind(R[1, 2], mean(cor.list), mean(cor.noM.list),
                     mean(cor.noP.list), mean(cor.noMP.list))
rownames(correlation) &lt;- c("True", "With SeM and Phy", "Without SeM",
                           "Without Phy", "Without Phy or SeM")
correlation

signal.d &lt;- rbind(d, colMeans(d.list), colMeans(d.noM.list))
rownames(signal.d) &lt;- c("True", "With SeM and Phy", "Without SeM")
signal.d

est.B &lt;- rbind(c(0, 0, B2), colMeans(B.list), colMeans(B.noM.list),
               colMeans(B.noP.list))
rownames(est.B) &lt;- c("True", "With SeM and Phy", "Without SeM", "Without Phy")
colnames(est.B) &lt;- rownames(z$B)
est.B

# Example simulation output
# correlation
                        # [,1]
# True               0.7000000
# With SeM and Phy   0.7055958
# Without SeM        0.3125253
# Without Phy        0.4054043
# Without Phy or SeM 0.3476589

# signal.d
                     # [,1]      [,2]
# True             0.300000 0.9500000
# With SeM and Phy 0.301513 0.9276663
# Without SeM      0.241319 0.4872675

# est.B
                        # B1.0      B2.0     B2.V1
# True              0.00000000 0.0000000 1.0000000
# With SeM and Phy -0.01285834 0.2807215 0.9963163
# Without SeM       0.01406953 0.3059110 0.9977796
# Without Phy       0.02139281 0.3165731 0.9942140

## End(Not run)</code></pre>

<hr>
<h2 id='correlogram.formula'>Phylogenetic Correlogram</h2><span id='topic+correlogram.formula'></span>

<h3>Description</h3>

<p>This function computes a correlogram from taxonomic levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  correlogram.formula(formula, data = NULL, use = "all.obs")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlogram.formula_+3A_formula">formula</code></td>
<td>
<p>a formula of the type <code>y1+..+yn ~ g1/../gn</code>, where
the <code>y</code>'s are the data to analyse and the <code>g</code>'s are the
taxonomic levels.</p>
</td></tr>
<tr><td><code id="correlogram.formula_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables specified in the
formula. If <code>NULL</code>, the variables are sought in the user's
workspace.</p>
</td></tr>
<tr><td><code id="correlogram.formula_+3A_use">use</code></td>
<td>
<p>a character string specifying how to handle missing
values (i.e., <code>NA</code>). This must be one of  &quot;all.obs&quot;,
&quot;complete.obs&quot;, or &quot;pairwise.complete.obs&quot;, or any unambiguous
abbrevation of these. In the first case, the presence of missing
values produces an error. In the second case, all rows with missing
values will be removed before computation. In the last case, missing
values are removed on a case-by-case basis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the vignette in R: <code>vignette("MoranI")</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>correlogram</code> which is a data frame with three
columns:
</p>
<table>
<tr><td><code>obs</code></td>
<td>
<p>the computed Moran's I</p>
</td></tr>
<tr><td><code>p.values</code></td>
<td>
<p>the corresponding P-values</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>the names of each level</p>
</td></tr>
</table>
<p>or an object of class <code>correlogramList</code> containing a list of
objects of class <code>correlogram</code> if several variables are given as
response in <code>formula</code>.
</p>


<h3>Author(s)</h3>

<p>Julien Dutheil <a href="mailto:dutheil@evolbio.mpg.de">dutheil@evolbio.mpg.de</a> and
Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.correlogram">plot.correlogram</a>, <a href="#topic+Moran.I">Moran.I</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carnivora)
### Using the formula interface:
co &lt;- correlogram.formula(SW ~ Order/SuperFamily/Family/Genus,
      data=carnivora)
co
plot(co)
### Several correlograms on the same plot:
cos &lt;- correlogram.formula(SW + FW ~ Order/SuperFamily/Family/Genus,
      data=carnivora)
cos
plot(cos)
</code></pre>

<hr>
<h2 id='data.nex'>NEXUS Data Example</h2><span id='topic+data.nex'></span><span id='topic+cynipids'></span>

<h3>Description</h3>

<p>Example of Protein data in NEXUS format (Maddison et al., 1997).
Data is written in interleaved format using a single DATA block.
Original data from Rokas et al (2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cynipids)</code></pre>


<h3>Format</h3>

<p>ASCII text in NEXUS format</p>


<h3>References</h3>

<p>Maddison, D. R., Swofford, D. L. and Maddison, W. P. (1997) NEXUS: an
extensible file format for systematic information. <em>Systematic
Biology</em>, <b>46</b>, 590&ndash;621.
</p>
<p>Rokas, A., Nylander, J. A. A., Ronquist, F. and Stone, G. N. (2002) A
maximum likelihood analysis of eight phylogenetic markers in Gallwasps
(Hymenoptera: Cynipidae): implications for insect phylogenetic
studies. <em>Molecular Phylogenetics and Evolution</em>, <b>22</b>,
206&ndash;219.
</p>

<hr>
<h2 id='dbd'>Probability Density Under Birth&ndash;Death Models</h2><span id='topic+dyule'></span><span id='topic+dbd'></span><span id='topic+dbdTime'></span>

<h3>Description</h3>

<p>These functions compute the probability density under some
birth&ndash;death models, that is the probability of obtaining <em>x</em>
species after a time <em>t</em> giving how speciation and extinction
probabilities vary through time (these may be constant, or even equal
to zero for extinction).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dyule(x, lambda = 0.1, t = 1, log = FALSE)
dbd(x, lambda, mu, t, conditional = FALSE, log = FALSE)
dbdTime(x, birth, death, t, conditional = FALSE,
        BIRTH = NULL, DEATH = NULL, fast = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbd_+3A_x">x</code></td>
<td>
<p>a numeric vector of species numbers (see Details).</p>
</td></tr>
<tr><td><code id="dbd_+3A_lambda">lambda</code></td>
<td>
<p>a numerical value giving the probability of speciation;
can be a vector with several values for <code>dyule</code>.</p>
</td></tr>
<tr><td><code id="dbd_+3A_mu">mu</code></td>
<td>
<p>id. for extinction.</p>
</td></tr>
<tr><td><code id="dbd_+3A_t">t</code></td>
<td>
<p>id. for the time(s).</p>
</td></tr>
<tr><td><code id="dbd_+3A_log">log</code></td>
<td>
<p>a logical value specifying whether the probabilities should
be returned log-transformed; the default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="dbd_+3A_conditional">conditional</code></td>
<td>
<p>a logical specifying whether the probabilities
should be computed conditional under the assumption of no extinction
after time <code>t</code>.</p>
</td></tr>
<tr><td><code id="dbd_+3A_birth">birth</code>, <code id="dbd_+3A_death">death</code></td>
<td>
<p>a (vectorized) function specifying how the
speciation or extinction probability changes through time (see
<code><a href="#topic+yule.time">yule.time</a></code> and below).</p>
</td></tr>
<tr><td><code id="dbd_+3A_birth">BIRTH</code>, <code id="dbd_+3A_death">DEATH</code></td>
<td>
<p>a (vectorized) function giving the primitive
of <code>birth</code> or <code>death</code>.</p>
</td></tr>
<tr><td><code id="dbd_+3A_fast">fast</code></td>
<td>
<p>a logical value specifying whether to use faster
integration (see <code><a href="#topic+bd.time">bd.time</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These three functions compute the probabilities to observe <code>x</code>
species starting from a single one after time <code>t</code> (assumed to be
continuous). The first function is a short-cut for the second one with
<code>mu = 0</code> and with default values for the two other arguments.
<code>dbdTime</code> is for time-varying <code>lambda</code> and <code>mu</code>
specified as <span class="rlang"><b>R</b></span> functions.
</p>
<p><code>dyule</code> is vectorized simultaneously on its three arguments
<code>x</code>, <code>lambda</code>, and <code>t</code>, according to <span class="rlang"><b>R</b></span>'s rules of
recycling arguments. <code>dbd</code> is vectorized simultaneously <code>x</code>
and <code>t</code> (to make likelihood calculations easy), and
<code>dbdTime</code> is vectorized only on <code>x</code>; the other arguments are
eventually shortened with a warning if necessary.
</p>
<p>The returned value is, logically, zero for values of <code>x</code> out of
range, i.e., negative or zero for <code>dyule</code> or if <code>conditional
  = TRUE</code>. However, it is not checked if the values of <code>x</code> are
positive non-integers and the probabilities are computed and returned.
</p>
<p>The details on the form of the arguments <code>birth</code>, <code>death</code>,
<code>BIRTH</code>, <code>DEATH</code>, and <code>fast</code> can be found in the links
below.
</p>


<h3>Value</h3>

<p>a numeric vector.
</p>


<h3>Note</h3>

<p>If you use these functions to calculate a likelihood function, it is
strongly recommended to compute the log-likelihood with, for instance
in the case of a Yule process, <code>sum(dyule( , log = TRUE))</code> (see
examples).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Kendall, D. G. (1948) On the generalized &ldquo;birth-and-death&rdquo;
process. <em>Annals of Mathematical Statistics</em>, <b>19</b>, 1&ndash;15.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bd.time">bd.time</a></code>,  <code><a href="#topic+yule.time">yule.time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 0:10
plot(x, dyule(x), type = "h", main = "Density of the Yule process")
text(7, 0.85, expression(list(lambda == 0.1, t == 1)))

y &lt;- dbd(x, 0.1, 0.05, 10)
z &lt;- dbd(x, 0.1, 0.05, 10, conditional = TRUE)
d &lt;- rbind(y, z)
colnames(d) &lt;- x
barplot(d, beside = TRUE, ylab = "Density", xlab = "Number of species",
        legend = c("unconditional", "conditional on\nno extinction"),
        args.legend = list(bty = "n"))
title("Density of the birth-death process")
text(17, 0.4, expression(list(lambda == 0.1, mu == 0.05, t == 10)))

## Not run: 
### generate 1000 values from a Yule process with lambda = 0.05
x &lt;- replicate(1e3, Ntip(rlineage(0.05, 0)))

### the correct way to calculate the log-likelihood...:
sum(dyule(x, 0.05, 50, log = TRUE))

### ... and the wrong way:
log(prod(dyule(x, 0.05, 50)))

### a third, less preferred, way:
sum(log(dyule(x, 0.05, 50)))

## End(Not run)</code></pre>

<hr>
<h2 id='def'>Definition of Vectors for Plotting or Annotating</h2><span id='topic+def'></span>

<h3>Description</h3>

<p>This function can be used to define vectors to annotate a set of taxon
names, labels, etc. It should facilitate the (re)definition of colours
or similar attributes for plotting trees or other graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>def(x, ..., default = NULL, regexp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="def_+3A_x">x</code></td>
<td>
<p>a vector of mode character.</p>
</td></tr>
<tr><td><code id="def_+3A_...">...</code></td>
<td>
<p>a series of statements defining the attributes.</p>
</td></tr>
<tr><td><code id="def_+3A_default">default</code></td>
<td>
<p>the default to be used (see details).</p>
</td></tr>
<tr><td><code id="def_+3A_regexp">regexp</code></td>
<td>
<p>a logical value specifying whether the statements
defined in <code>...</code> should be taken as regular expressions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The idea of this function is to make the definition of colours, etc.,
simpler than what is done usually. A typical use is:
</p>
<p><code>def(tr$tip.label, Homo_sapiens = "blue")</code>
</p>
<p>which will return a vector of character strings all &quot;black&quot; except one
matching the tip label &quot;Homo_sapiens&quot; which will be &quot;blue&quot;. Another use
could be:
</p>
<p><code>def(tr$tip.label, Homo_sapiens = 2)</code>
</p>
<p>which will return a vector a numerical values all 1 except for
&quot;Homo_sapiens&quot; which will be 2. Several definitions can be done, e.g.:
</p>
<p><code>def(tr$tip.label, Homo_sapiens = "blue", Pan_paniscus = "red")</code>
</p>
<p>The default value is determined with respect to the mode of the values
given with the <code>...</code> (either &quot;black&quot; or 1).
</p>
<p>If <code>regexp = TRUE</code> is used, then the names of the statements must be
quoted, e.g.:
</p>
<p><code>def(tr$tip.label, "^Pan_" = "red", regexp = TRUE)</code>
</p>
<p>will return &quot;red&quot; for all labels starting with &quot;Pan_&quot;.
</p>


<h3>Value</h3>

<p>a vector of the same length than <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bird.orders)
a &lt;- def(bird.orders$tip.label, Galliformes = 2)
str(a) # numeric
plot(bird.orders, font = a)
co &lt;- def(bird.orders$tip.label, Passeriformes = "red", Trogoniformes = "blue")
str(co) # character
plot(bird.orders, tip.color = co)
### use of a regexp (so we need to quote it) to colour all orders
### with names starting with "C" (and change the default):
co2 &lt;- def(bird.orders$tip.label, "^C" = "gold", default = "grey", regexp = TRUE)
plot(bird.orders, tip.color = co2)
</code></pre>

<hr>
<h2 id='degree'>Vertex Degrees in Trees and Networks</h2><span id='topic+degree'></span><span id='topic+degree.phylo'></span><span id='topic+degree.evonet'></span>

<h3>Description</h3>

<p><code>degree</code> is a generic function to calculate the degree of all
nodes in a tree or in a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degree(x, ...)
## S3 method for class 'phylo'
degree(x, details = FALSE, ...)
## S3 method for class 'evonet'
degree(x, details = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degree_+3A_x">x</code></td>
<td>
<p>an object (tree, network, ...).</p>
</td></tr>
<tr><td><code id="degree_+3A_details">details</code></td>
<td>
<p>whether to return the degree of each node in the tree,
or a summary table (the default).</p>
</td></tr>
<tr><td><code id="degree_+3A_...">...</code></td>
<td>
<p>arguments passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The degree of a node (or vertex) in a network is defined by the number
of branches (or edges) that connect to this node. In a phylogenetic
tree, the tips (or terminal nodes) are of degree one, and the
(internal) nodes are of degree two or more.
</p>
<p>There are currently two methods for the classes <code>"phylo"</code> and
<code>"evonet"</code>. The default of these functions is to return a summary
table with the degrees observed in the tree or network in the first
column, and the number of nodes in the second column. If <code>details
  = TRUE</code>, a vector giving the degree of each node (as numbered in the
<code>edge</code> matrix) is returned.
</p>
<p>The validity of the object is not checked, so <code>degree</code> can be
used to check problems with badly conformed trees.
</p>


<h3>Value</h3>

<p>a data frame if <code>details = FALSE</code>, or a vector of integers
otherwise.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+checkValidPhylo">checkValidPhylo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bird.orders)
degree(bird.orders)
degree(bird.orders, details = TRUE)

data(bird.families)
degree(bird.families)

degree(rtree(10)) # 10, 1, 8
degree(rtree(10, rooted = FALSE)) # 10, 0, 8
degree(stree(10)) # 10 + 1 node of degree 10
</code></pre>

<hr>
<h2 id='del.gaps'>Delete Alignment Gaps in DNA or AA Sequences</h2><span id='topic+del.gaps'></span><span id='topic+del.colgapsonly'></span><span id='topic+del.rowgapsonly'></span>

<h3>Description</h3>

<p>These functions remove gaps (<code>"-"</code>) in a sample of DNA sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>del.gaps(x)
del.colgapsonly(x, threshold = 1, freq.only = FALSE)
del.rowgapsonly(x, threshold = 1, freq.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="del.gaps_+3A_x">x</code></td>
<td>
<p>a matrix, a list, or a vector containing the DNA or AA
sequences; only matrices for <code>del.colgapsonly</code> and for
<code>del.rowgapsonly</code>.</p>
</td></tr>
<tr><td><code id="del.gaps_+3A_threshold">threshold</code></td>
<td>
<p>the largest gap proportion to delete the column or row.</p>
</td></tr>
<tr><td><code id="del.gaps_+3A_freq.only">freq.only</code></td>
<td>
<p>if <code>TRUE</code>, returns only the numbers of gaps for
each column or row.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>del.gaps</code> remove all gaps, so the returned sequences may not
have all the same lengths and are therefore returned in a list.
</p>
<p><code>del.colgapsonly</code> removes the columns with a proportion at least
<code>threshold</code> of gaps. Thus by default, only the columns with gaps
only are removed (useful when a small matrix is extracted from a large
alignment). <code>del.rowgapsonly</code> does the same for the rows.
</p>
<p>The class of the input sequences is respected and kept unchanged,
unless it contains neither <code>"DNAbin"</code> nor <code>"AAbin"</code> in which
case the object is first converted into the class <code>"DNAbin"</code>.
</p>


<h3>Value</h3>

<p><code>del.gaps</code> returns a vector (if there is only one input sequence)
or a list of sequences; <code>del.colgapsonly</code> and
<code>del.rowgapsonly</code> return a matrix of sequences or a numeric
vector (with names for the second function) if <code>freq.only =
  TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+base.freq">base.freq</a></code>, <code><a href="#topic+seg.sites">seg.sites</a></code>,
<code><a href="#topic+image.DNAbin">image.DNAbin</a></code>, <code><a href="#topic+checkAlignment">checkAlignment</a></code>
</p>

<hr>
<h2 id='delta.plot'>Delta Plots</h2><span id='topic+delta.plot'></span>

<h3>Description</h3>

<p>This function makes a <code class="reqn">\delta</code> plot following Holland et
al. (2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta.plot(X, k = 20, plot = TRUE, which = 1:2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delta.plot_+3A_x">X</code></td>
<td>
<p>a distance matrix, may be an object of class &ldquo;dist&rdquo;.</p>
</td></tr>
<tr><td><code id="delta.plot_+3A_k">k</code></td>
<td>
<p>an integer giving the number of intervals in the plot.</p>
</td></tr>
<tr><td><code id="delta.plot_+3A_plot">plot</code></td>
<td>
<p>a logical specifying whether to draw the
<code class="reqn">\delta</code> plot (the default).</p>
</td></tr>
<tr><td><code id="delta.plot_+3A_which">which</code></td>
<td>
<p>a numeric vector indicating which plots are done; 1: the
histogram of the <code class="reqn">\delta_q</code> values, 2: the plot of the
individual <code class="reqn">\bar{\delta}</code> values. By default, both
plots are done.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Holland et al. (2002) for details and interpretation.
</p>
<p>The computing time of this function is proportional to the fourth
power of the number of observations (<code class="reqn">O(n^4)</code>), so calculations
may be very long with only a slight increase in sample size.
</p>


<h3>Value</h3>

<p>This function returns invisibly a named list with two components:
</p>

<ul>
<li><p> counts: the counts for the histogram of
<code class="reqn">\delta_q</code> values
</p>
</li>
<li><p> delta.bar: the mean <code class="reqn">\delta</code> value for each
observation
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Holland, B. R., Huber, K. T., Dress, A. and Moulton, V. (2002) Delta
plots: a tool for analyzing phylogenetic distance data.
<em>Molecular Biology and Evolution</em>, <b>12</b>, 2051&ndash;2059.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist.dna">dist.dna</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
d &lt;- dist.dna(woodmouse)
delta.plot(d)
layout(1)
delta.plot(d, 40, which = 1)
</code></pre>

<hr>
<h2 id='dist.dna'>Pairwise Distances from DNA Sequences</h2><span id='topic+dist.dna'></span>

<h3>Description</h3>

<p>This function computes a matrix of pairwise distances from DNA
sequences using a model of DNA evolution. Eleven substitution models
(and the raw distance) are currently available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.dna(x, model = "K80", variance = FALSE,
         gamma = FALSE, pairwise.deletion = FALSE,
         base.freq = NULL, as.matrix = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.dna_+3A_x">x</code></td>
<td>
<p>a matrix or a list containing the DNA sequences; this must be
of class <code>"DNAbin"</code> (use <code><a href="#topic+as.DNAbin">as.DNAbin</a></code> is they are
stored as character).</p>
</td></tr>
<tr><td><code id="dist.dna_+3A_model">model</code></td>
<td>
<p>a character string specifying the evolutionary model to be
used; must be one of <code>"raw"</code>, <code>"N"</code>, <code>"TS"</code>,
<code>"TV"</code>, <code>"JC69"</code>, <code>"K80"</code> (the default),
<code>"F81"</code>, <code>"K81"</code>, <code>"F84"</code>, <code>"BH87"</code>,
<code>"T92"</code>, <code>"TN93"</code>, <code>"GG95"</code>, <code>"logdet"</code>,
<code>"paralin"</code>, <code>"indel"</code>, or <code>"indelblock"</code>.</p>
</td></tr>
<tr><td><code id="dist.dna_+3A_variance">variance</code></td>
<td>
<p>a logical indicating whether to compute the variances
of the distances; defaults to <code>FALSE</code> so the variances are not
computed.</p>
</td></tr>
<tr><td><code id="dist.dna_+3A_gamma">gamma</code></td>
<td>
<p>a value for the gamma parameter possibly used to apply a
correction to the distances (by default no correction is applied).</p>
</td></tr>
<tr><td><code id="dist.dna_+3A_pairwise.deletion">pairwise.deletion</code></td>
<td>
<p>a logical indicating whether to delete the
sites with missing data in a pairwise way. The default is to delete
the sites with at least one missing data for all sequences (ignored
if <code>model = "indel"</code> or <code>"indelblock"</code>).</p>
</td></tr>
<tr><td><code id="dist.dna_+3A_base.freq">base.freq</code></td>
<td>
<p>the base frequencies to be used in the computations
(if applicable). By default, the base frequencies are computed from
the whole set of sequences.</p>
</td></tr>
<tr><td><code id="dist.dna_+3A_as.matrix">as.matrix</code></td>
<td>
<p>a logical indicating whether to return the results as
a matrix. The default is to return an object of class
<a href="stats.html#topic+dist">dist</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The molecular evolutionary models available through the option
<code>model</code> have been extensively described in the literature. A
brief description is given below; more details can be found in the
references.
</p>

<ul>
<li> <p><code>raw</code>, <code>N</code>: This is simply the proportion or the number of
sites that differ between each pair of sequences. This may be useful
to draw &ldquo;saturation plots&rdquo;. The options <code>variance</code> and
<code>gamma</code> have no effect, but <code>pairwise.deletion</code> may have.
</p>
</li>
<li> <p><code>TS</code>, <code>TV</code>: These are the numbers of transitions and
transversions, respectively.
</p>
</li>
<li> <p><code>JC69</code>: This model was developed by Jukes and Cantor (1969). It
assumes that all substitutions (i.e. a change of a base by another
one) have the same probability. This probability is the same for all
sites along the DNA sequence. This last assumption can be relaxed by
assuming that the substition rate varies among site following a
gamma distribution which parameter must be given by the user. By
default, no gamma correction is applied. Another assumption is that
the base frequencies are balanced and thus equal to 0.25.
</p>
</li>
<li> <p><code>K80</code>: The distance derived by Kimura (1980), sometimes referred
to as &ldquo;Kimura's 2-parameters distance&rdquo;, has the same underlying
assumptions than the Jukes&ndash;Cantor distance except that two kinds of
substitutions are considered: transitions (A &lt;-&gt; G, C &lt;-&gt; T), and
transversions (A &lt;-&gt; C, A &lt;-&gt; T, C &lt;-&gt; G, G &lt;-&gt; T). They are assumed
to have different probabilities. A transition is the substitution of
a purine (C, T) by another one, or the substitution of a pyrimidine
(A, G) by another one. A transversion is the substitution of a
purine by a pyrimidine, or vice-versa. Both transition and
transversion rates are the same for all sites along the DNA
sequence. Jin and Nei (1990) modified the Kimura model to allow for
variation among sites following a gamma distribution. Like for the
Jukes&ndash;Cantor model, the gamma parameter must be given by the
user. By default, no gamma correction is applied.
</p>
</li>
<li> <p><code>F81</code>: Felsenstein (1981) generalized the Jukes&ndash;Cantor model
by relaxing the assumption of equal base frequencies. The formulae
used in this function were taken from McGuire et al. (1999).
</p>
</li>
<li> <p><code>K81</code>: Kimura (1981) generalized his model (Kimura 1980) by
assuming different rates for two kinds of transversions: A &lt;-&gt; C and
G &lt;-&gt; T on one side, and A &lt;-&gt; T and C &lt;-&gt; G on the other. This is
what Kimura called his &ldquo;three substitution types model&rdquo; (3ST), and
is sometimes referred to as &ldquo;Kimura's 3-parameters distance&rdquo;.
</p>
</li>
<li> <p><code>F84</code>: This model generalizes K80 by relaxing the assumption
of equal base frequencies. It was first introduced by Felsenstein in
1984 in Phylip, and is fully described by Felsenstein and Churchill
(1996). The formulae used in this function were taken from McGuire
et al. (1999).
</p>
</li>
<li> <p><code>BH87</code>: Barry and Hartigan (1987) developed a distance based
on the observed proportions of changes among the four bases. This
distance is not symmetric.
</p>
</li>
<li> <p><code>T92</code>: Tamura (1992) generalized the Kimura model by relaxing
the assumption of equal base frequencies. This is done by taking
into account the bias in G+C content in the sequences. The
substitution rates are assumed to be the same for all sites along
the DNA sequence.
</p>
</li>
<li> <p><code>TN93</code>: Tamura and Nei (1993) developed a model which assumes
distinct rates for both kinds of transition (A &lt;-&gt; G versus C &lt;-&gt;
T), and transversions. The base frequencies are not assumed to be
equal and are estimated from the data. A gamma correction of the
inter-site variation in substitution rates is possible.
</p>
</li>
<li> <p><code>GG95</code>: Galtier and Gouy (1995) introduced a model where the
G+C content may change through time. Different rates are assumed for
transitons and transversions.
</p>
</li>
<li> <p><code>logdet</code>: The Log-Det distance, developed by Lockhart et
al. (1994), is related to BH87. However, this distance is
symmetric. Formulae from Gu and Li (1996) are used.
<code>dist.logdet</code> in <span class="pkg">phangorn</span> uses a different
implementation that gives substantially different distances for
low-diverging sequences.
</p>
</li>
<li> <p><code>paralin</code>: Lake (1994) developed the paralinear distance which
can be viewed as another variant of the Barry&ndash;Hartigan distance.
</p>
</li>
<li> <p><code>indel</code>: this counts the number of sites where there is an
insertion/deletion gap in one sequence and not in the other.
</p>
</li>
<li> <p><code>indelblock</code>: same than before but contiguous gaps are
counted as a single unit. Note that the distance between <code>-A-</code> and
<code>A--</code> is 3 because there are three different blocks of gaps, whereas
the &ldquo;indel&rdquo; distance will be 2.
</p>
</li></ul>


<h3>Value</h3>

<p>an object of class <a href="stats.html#topic+dist">dist</a> (by default), or a numeric
matrix if <code>as.matrix = TRUE</code>. If <code>model = "BH87"</code>, a numeric
matrix is returned because the Barry&ndash;Hartigan distance is not
symmetric.
</p>
<p>If <code>variance = TRUE</code> an attribute called <code>"variance"</code> is
given to the returned object.
</p>


<h3>Note</h3>

<p>If the sequences are very different, most evolutionary distances are
undefined and a non-finite value (Inf or NaN) is returned. You may do
<code>dist.dna(, model = "raw")</code> to check whether some values are
higher than 0.75.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Barry, D. and Hartigan, J. A. (1987) Asynchronous distance between
homologous DNA sequences. <em>Biometrics</em>, <b>43</b>, 261&ndash;276.
</p>
<p>Felsenstein, J. (1981) Evolutionary trees from DNA sequences: a
maximum likelihood approach. <em>Journal of Molecular Evolution</em>,
<b>17</b>, 368&ndash;376.
</p>
<p>Felsenstein, J. and Churchill, G. A. (1996) A Hidden Markov model
approach to variation among sites in rate of evolution.
<em>Molecular Biology and Evolution</em>, <b>13</b>, 93&ndash;104.
</p>
<p>Galtier, N. and Gouy, M. (1995) Inferring phylogenies from DNA
sequences of unequal base compositions. <em>Proceedings of the
National Academy of Sciences USA</em>, <b>92</b>, 11317&ndash;11321.
</p>
<p>Gu, X. and Li, W.-H. (1996) Bias-corrected paralinear and LogDet
distances and tests of molecular clocks and phylogenies under
nonstationary nucleotide frequencies. <em>Molecular Biology and
Evolution</em>, <b>13</b>, 1375&ndash;1383.
</p>
<p>Jukes, T. H. and Cantor, C. R. (1969) Evolution of protein
molecules. in <em>Mammalian Protein Metabolism</em>, ed. Munro, H. N.,
pp. 21&ndash;132, New York: Academic Press.
</p>
<p>Kimura, M. (1980) A simple method for estimating evolutionary rates of
base substitutions through comparative studies of nucleotide
sequences. <em>Journal of Molecular Evolution</em>, <b>16</b>, 111&ndash;120.
</p>
<p>Kimura, M. (1981) Estimation of evolutionary distances between
homologous nucleotide sequences. <em>Proceedings of the National
Academy of Sciences USA</em>, <b>78</b>, 454&ndash;458.
</p>
<p>Jin, L. and Nei, M. (1990) Limitations of the evolutionary parsimony
method of phylogenetic analysis. <em>Molecular Biology and
Evolution</em>, <b>7</b>, 82&ndash;102.
</p>
<p>Lake, J. A. (1994) Reconstructing evolutionary trees from DNA and
protein sequences: paralinear distances. <em>Proceedings of the
National Academy of Sciences USA</em>, <b>91</b>, 1455&ndash;1459.
</p>
<p>Lockhart, P. J., Steel, M. A., Hendy, M. D. and Penny, D. (1994)
Recovering evolutionary trees under a more realistic model of sequence
evolution. <em>Molecular Biology and Evolution</em>, <b>11</b>,
605&ndash;602.
</p>
<p>McGuire, G., Prentice, M. J. and Wright, F. (1999). Improved error
bounds for genetic distances from DNA sequences. <em>Biometrics</em>,
<b>55</b>, 1064&ndash;1070.
</p>
<p>Tamura, K. (1992) Estimation of the number of nucleotide substitutions
when there are strong transition-transversion and G + C-content
biases. <em>Molecular Biology and Evolution</em>, <b>9</b>, 678&ndash;687.
</p>
<p>Tamura, K. and Nei, M. (1993) Estimation of the number of nucleotide
substitutions in the control region of mitochondrial DNA in humans and
chimpanzees. <em>Molecular Biology and Evolution</em>, <b>10</b>, 512&ndash;526.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.GenBank">read.GenBank</a></code>, <code><a href="#topic+read.dna">read.dna</a></code>,
<code><a href="#topic+write.dna">write.dna</a></code>,  <code><a href="#topic+DNAbin">DNAbin</a></code>,
<code><a href="#topic+dist.gene">dist.gene</a></code>, <code><a href="#topic+cophenetic.phylo">cophenetic.phylo</a></code>,
<code><a href="stats.html#topic+dist">dist</a></code>
</p>

<hr>
<h2 id='dist.gene'>Pairwise Distances from Genetic Data</h2><span id='topic+dist.gene'></span>

<h3>Description</h3>

<p>This function computes a matrix of distances between pairs of
individuals from a matrix or a data frame of genetic data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.gene(x, method = "pairwise", pairwise.deletion = FALSE,
          variance = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.gene_+3A_x">x</code></td>
<td>
<p>a matrix or a data frame (will be coerced as a matrix).</p>
</td></tr>
<tr><td><code id="dist.gene_+3A_method">method</code></td>
<td>
<p>a character string specifying the method used to compute
the distances; two choices are available: <code>"pairwise"</code> and
<code>"percentage"</code>, or any unambiguous abbreviation of these.</p>
</td></tr>
<tr><td><code id="dist.gene_+3A_pairwise.deletion">pairwise.deletion</code></td>
<td>
<p>a logical indicating whether to delete the
columns with missing data on a pairwise basis. The default is to
delete the columns with at least one missing observation.</p>
</td></tr>
<tr><td><code id="dist.gene_+3A_variance">variance</code></td>
<td>
<p>a logical, indicates whether the variance of the
distances should be returned (default to <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is meant to be very general and accepts different kinds
of data (alleles, haplotypes, SNP, DNA sequences, ...). The rows of
the data matrix represent the individuals, and the columns the loci.
</p>
<p>In the case of the pairwise method, the distance <code class="reqn">d</code> between two
individuals is the number of loci for which they differ, and the
associated variance is <code class="reqn">d(L - d)/L</code>, where <code class="reqn">L</code> is the number
of loci.
</p>
<p>In the case of the percentage method, this distance is divided by <code class="reqn">L</code>,
and the associated variance is <code class="reqn">d(1 - d)/L</code>.
</p>
<p>For more elaborate distances with DNA sequences, see the function
<code>dist.dna</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>dist</code>. If <code>variance = TRUE</code> an
attribute called <code>"variance"</code> is given to the returned object.
</p>


<h3>Note</h3>

<p>Missing data (<code>NA</code>) are coded and treated in R's usual way.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist.dna">dist.dna</a></code>, <code><a href="#topic+cophenetic.phylo">cophenetic.phylo</a></code>,
<code><a href="stats.html#topic+dist">dist</a></code>
</p>

<hr>
<h2 id='dist.topo'>Topological Distances Between Two Trees</h2><span id='topic+dist.topo'></span>

<h3>Description</h3>

<p>This function computes the topological distance between two
phylogenetic trees or among trees in a list (if <code>y = NULL</code> using
different methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.topo(x, y = NULL, method = "PH85", mc.cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.topo_+3A_x">x</code></td>
<td>
<p>an object of class <code>"phylo"</code> or of class
<code>"multiPhylo"</code>.</p>
</td></tr>
<tr><td><code id="dist.topo_+3A_y">y</code></td>
<td>
<p>an (optional) object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="dist.topo_+3A_method">method</code></td>
<td>
<p>a character string giving the method to be used: either
<code>"PH85"</code>, or <code>"score"</code>.</p>
</td></tr>
<tr><td><code id="dist.topo_+3A_mc.cores">mc.cores</code></td>
<td>
<p>the number of cores (CPUs) to be used (passed to
<span class="pkg">parallel</span>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two methods are available: the one by Penny and Hendy (1985,
originally from Robinson and Foulds 1981), and the branch length score
by Kuhner and Felsenstein (1994). The trees are always considered as
unrooted.
</p>
<p>The topological distance is defined as twice the number of internal
branches defining different bipartitions of the tips (Robinson and
Foulds 1981; Penny and Hendy 1985). Rzhetsky and Nei (1992) proposed a
modification of the original formula to take multifurcations into
account.
</p>
<p>The branch length score may be seen as similar to the previous
distance but taking branch lengths into account. Kuhner and
Felsenstein (1994) proposed to calculate the square root of the sum of
the squared differences of the (internal) branch lengths defining
similar bipartitions (or splits) in both trees.
</p>


<h3>Value</h3>

<p>a single numeric value if both <code>x</code> and <code>y</code> are used, an
object of class <code>"dist"</code> otherwise.
</p>


<h3>Note</h3>

<p>The geodesic distance of Billera et al. (2001) has been disabled: see
the package <span class="pkg">distory</span> on CRAN.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Billera, L. J., Holmes, S. P. and Vogtmann, K. (2001) Geometry of the
space of phylogenetic trees. <em>Advances in Applied Mathematics</em>,
<b>27</b>, 733&ndash;767.
</p>
<p>Kuhner, M. K. and Felsenstein, J. (1994) Simulation comparison of
phylogeny algorithms under equal and unequal evolutionary rates.
<em>Molecular Biology and Evolution</em>, <b>11</b>, 459&ndash;468.
</p>
<p>Nei, M. and Kumar, S. (2000) <em>Molecular Evolution and
Phylogenetics</em>. Oxford: Oxford University Press.
</p>
<p>Penny, D. and Hendy, M. D. (1985) The use of tree comparison
metrics. <em>Systemetic Zoology</em>, <b>34</b>, 75&ndash;82.
</p>
<p>Robinson, D. F. and Foulds, L. R. (1981) Comparison of phylogenetic
trees. <em>Mathematical Biosciences</em>, <b>53</b>, 131&ndash;147.
</p>
<p>Rzhetsky, A. and Nei, M. (1992) A simple method for estimating and
testing minimum-evolution trees. <em>Molecular Biology and
Evolution</em>, <b>9</b>, 945&ndash;967.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cophenetic.phylo">cophenetic.phylo</a></code>, <code><a href="#topic+prop.part">prop.part</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ta &lt;- rtree(30, rooted = FALSE)
tb &lt;- rtree(30, rooted = FALSE)
dist.topo(ta, ta) # 0
dist.topo(ta, tb) # unlikely to be 0

## rmtopology() simulated unrooted trees by default:
TR &lt;- rmtopology(100, 10)
## these trees have 7 internal branches, so the maximum distance
## between two of them is 14:
DTR &lt;- dist.topo(TR)
table(DTR)
</code></pre>

<hr>
<h2 id='diversi.gof'>Tests of Constant Diversification Rates</h2><span id='topic+diversi.gof'></span>

<h3>Description</h3>

<p>This function computes two tests of the distribution of branching
times using the Cramér&ndash;von Mises and Anderson&ndash;Darling
goodness-of-fit tests. By default, it is assumed that the
diversification rate is constant, and an exponential distribution is
assumed for the branching times. In this case, the expected
distribution under this model is computed with a rate estimated from
the data. Alternatively, the user may specify an expected cumulative
density function (<code>z</code>): in this case, <code>x</code> and <code>z</code> must
be of the same length. See the examples for how to compute the latter
from a sample of expected branching times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diversi.gof(x, null = "exponential", z = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diversi.gof_+3A_x">x</code></td>
<td>
<p>a numeric vector with the branching times.</p>
</td></tr>
<tr><td><code id="diversi.gof_+3A_null">null</code></td>
<td>
<p>a character string specifying the null distribution for
the branching times. Only two choices are possible: either
<code>"exponential"</code>, or <code>"user"</code>.</p>
</td></tr>
<tr><td><code id="diversi.gof_+3A_z">z</code></td>
<td>
<p>used if <code>null = "user"</code>; gives the expected distribution
under the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Cramér&ndash;von Mises and Anderson&ndash;Darling tests
compare the empirical density function (EDF) of the observations to an
expected cumulative density function. By contrast to the
Kolmogorov&ndash;Smirnov test where the greatest difference between these
two functions is used, in both tests all differences are taken into
account.
</p>
<p>The distributions of both test statistics depend on the null
hypothesis, and on whether or not some parameters were estimated from
the data. However, these distributions are not known precisely and
critical values were determined by Stephens (1974) using
simulations. These critical values were used for the present function.
</p>


<h3>Value</h3>

<p>A NULL value is returned, the results are simply printed.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Paradis, E. (1998) Testing for constant diversification rates using
molecular phylogenies: a general approach based on statistical tests
for goodness of fit. <em>Molecular Biology and Evolution</em>,
<b>15</b>, 476&ndash;479.
</p>
<p>Stephens, M. A. (1974) EDF statistics for goodness of fit and some
comparisons. <em>Journal of the American Statistical Association</em>,
<b>69</b>, 730&ndash;737.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+branching.times">branching.times</a></code>, <code><a href="#topic+diversi.time">diversi.time</a></code>
<code><a href="#topic+ltt.plot">ltt.plot</a></code>, <code><a href="#topic+birthdeath">birthdeath</a></code>, <code><a href="#topic+yule">yule</a></code>,
<code><a href="#topic+yule.cov">yule.cov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bird.families)
x &lt;- branching.times(bird.families)
### suppose we have a sample of expected branching times `y';
### for simplicity, take them from a uniform distribution:
y &lt;- runif(500, 0, max(x) + 1) # + 1 to avoid A2 = Inf
### now compute the expected cumulative distribution:
x &lt;- sort(x)
N &lt;- length(x)
ecdf &lt;- numeric(N)
for (i in 1:N) ecdf[i] &lt;- sum(y &lt;= x[i])/500
### finally do the test:
diversi.gof(x, "user", z = ecdf)
</code></pre>

<hr>
<h2 id='diversi.time'>Analysis of Diversification with Survival Models</h2><span id='topic+diversi.time'></span>

<h3>Description</h3>

<p>This functions fits survival models to a set of branching times, some
of them may be known approximately (censored). Three models are
fitted, Model A assuming constant diversification, Model B assuming
that diversification follows a Weibull law, and Model C assuming that
diversification changes with a breakpoint at time &lsquo;Tc&rsquo;. The models are
fitted by maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diversi.time(x, census = NULL, censoring.codes = c(1, 0), Tc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diversi.time_+3A_x">x</code></td>
<td>
<p>a numeric vector with the branching times.</p>
</td></tr>
<tr><td><code id="diversi.time_+3A_census">census</code></td>
<td>
<p>a vector of the same length than &lsquo;x&rsquo; used as an
indicator variable; thus, it must have only two values, one coding
for accurately known branching times, and the other for censored
branching times. This argument can be of any mode (numeric, character,
logical), or can even be a factor.</p>
</td></tr>
<tr><td><code id="diversi.time_+3A_censoring.codes">censoring.codes</code></td>
<td>
<p>a vector of length two giving the codes used
for <code>census</code>: by default 1 (accurately known times) and 0 (censored
times). The mode must be the same than the one of <code>census</code>.</p>
</td></tr>
<tr><td><code id="diversi.time_+3A_tc">Tc</code></td>
<td>
<p>a single numeric value specifying the break-point time to
fit Model C. If none is provided, then it is set arbitrarily to the
mean of the analysed branching times.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The principle of the method is to consider each branching time as an
event: if the branching time is accurately known, then it is a failure
event; if it is approximately knwon then it is a censoring event. An
analogy is thus made between the failure (or hazard) rate estimated by
the survival models and the diversification rate of the lineage. Time
is here considered from present to past.
</p>
<p>Model B assumes a monotonically changing diversification rate. The
parameter that controls the change of this rate is called beta. If
beta is greater than one, then the diversification rate decreases
through time; if it is lesser than one, the the rate increases through
time. If beta is equal to one, then Model B reduces to Model A.
</p>


<h3>Value</h3>

<p>A NULL value is returned, the results are simply printed.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Paradis, E. (1997) Assessing temporal variations in diversification
rates from phylogenies: estimation and hypothesis
testing. <em>Proceedings of the Royal Society of London. Series
B. Biological Sciences</em>, <b>264</b>, 1141&ndash;1147.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+branching.times">branching.times</a></code>, <code><a href="#topic+diversi.gof">diversi.gof</a></code>
<code><a href="#topic+ltt.plot">ltt.plot</a></code>, <code><a href="#topic+birthdeath">birthdeath</a></code>,
<code><a href="#topic+bd.ext">bd.ext</a></code>, <code><a href="#topic+yule">yule</a></code>, <code><a href="#topic+yule.cov">yule.cov</a></code>
</p>

<hr>
<h2 id='diversity.contrast.test'>Diversity Contrast Test</h2><span id='topic+diversity.contrast.test'></span>

<h3>Description</h3>

<p>This function performs the diversity contrast test comparing pairs of
sister-clades.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diversity.contrast.test(x, method = "ratiolog",
        alternative = "two.sided", nrep = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diversity.contrast.test_+3A_x">x</code></td>
<td>
<p>a matrix or a data frame with at least two columns: the first
one gives the number of species in clades with a trait supposed to
increase or decrease diversification rate, and the second one the
number of species in the sister-clades without the trait. Each row
represents a pair of sister-clades.</p>
</td></tr>
<tr><td><code id="diversity.contrast.test_+3A_method">method</code></td>
<td>
<p>a character string specifying the kind of test:
<code>"ratiolog"</code> (default), <code>"proportion"</code>,
<code>"difference"</code>, <code>"logratio"</code>, or any unambiguous
abbreviation of these.</p>
</td></tr>
<tr><td><code id="diversity.contrast.test_+3A_alternative">alternative</code></td>
<td>
<p>a character string defining the alternative
hypothesis:  <code>"two.sided"</code> (default), <code>"less"</code>,
<code>"greater"</code>, or any unambiguous abbreviation of these.</p>
</td></tr>
<tr><td><code id="diversity.contrast.test_+3A_nrep">nrep</code></td>
<td>
<p>the number of replications of the randomization test; by
default, a Wilcoxon test is done.</p>
</td></tr>
<tr><td><code id="diversity.contrast.test_+3A_...">...</code></td>
<td>
<p>arguments passed to the function
<code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>method = "ratiolog"</code>, the test described in Barraclough et
al. (1996) is performed. If <code>method = "proportion"</code>, the version
in Barraclough et al. (1995) is used. If <code>method = "difference"</code>,
the signed difference is used (Sargent 2004). If <code>method = "logratio"</code>,
then this is Wiegmann et al.'s (1993) version. These
four tests are essentially different versions of the same test (Vamosi
and Vamosi 2005, Vamosi 2007). See Paradis (2012) for a comparison of
their statistical performance with other tests.
</p>
<p>If <code>nrep = 0</code>, a Wilcoxon test is done on the species diversity
contrasts with the null hypothesis is that they are distributed around
zero. If <code>nrep &gt; 0</code>, a randomization procedure is done where the
signs of the diversity contrasts are randomly chosen. This is used to
create a distribution of the test statistic which is compared with the
observed value (the sum of the diversity contrasts).
</p>


<h3>Value</h3>

<p>a single numeric value with the <em>P</em>-value.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Barraclough, T. G., Harvey, P. H. and  Nee, S. (1995) Sexual
selection and taxonomic diversity in passerine birds.
<em>Proceedings of the Royal Society of London. Series B. Biological
Sciences</em>, <b>259</b>, 211&ndash;215.
</p>
<p>Barraclough, T. G., Harvey, P. H., and Nee,  S. (1996) Rate of
<em>rbc</em>L gene sequence evolution and species diversification in
flowering plants (angiosperms). <em>Proceedings of the Royal Society
of London. Series B. Biological Sciences</em>, <b>263</b>, 589&ndash;591.
</p>
<p>Paradis, E. (2012) Shift in diversification in sister-clade
comparisons: a more powerful test. <em>Evolution</em>, <b>66</b>,
288&ndash;295.
</p>
<p>Sargent, R. D. (2004) Floral symmetry affects speciation rates in
angiosperms. <em>Proceedings of the Royal Society of London. Series
B. Biological Sciences</em>, <b>271</b>, 603&ndash;608.
</p>
<p>Vamosi, S. M. (2007) Endless tests: guidelines for analysing non-nested
sister-group comparisons. An addendum. <em>Evolutionary Ecology
Research</em>, <b>9</b>, 717.
</p>
<p>Vamosi, S. M. and Vamosi, J. C. (2005) Endless tests: guidelines for
analysing non-nested sister-group comparisons. <em>Evolutionary
Ecology Research</em>, <b>7</b>, 567&ndash;579.
</p>
<p>Wiegmann, B., Mitter, C. and Farrell, B. 1993. Diversification of
carnivorous parasitic insects: extraordinary radiation or specialized
dead end? <em>American Naturalist</em>, <b>142</b>, 737&ndash;754.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slowinskiguyer.test">slowinskiguyer.test</a></code>, <code><a href="#topic+mcconwaysims.test">mcconwaysims.test</a></code>
<code><a href="#topic+richness.yule.test">richness.yule.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### data from Vamosi &amp; Vamosi (2005):
fleshy &lt;- c(1, 1, 1, 1, 1, 3, 3, 5, 9, 16, 33, 40, 50, 100, 216, 393, 850, 947,1700)
dry &lt;- c(2, 64, 300, 89, 67, 4, 34, 10, 150, 35, 2, 60, 81, 1, 3, 1, 11, 1, 18)
x &lt;- cbind(fleshy, dry)
diversity.contrast.test(x)
diversity.contrast.test(x, alt = "g")
diversity.contrast.test(x, alt = "g", nrep = 1e4)
slowinskiguyer.test(x)
mcconwaysims.test(x)
</code></pre>

<hr>
<h2 id='DNAbin'>Manipulate DNA Sequences in Bit-Level Format</h2><span id='topic+DNAbin'></span><span id='topic+print.DNAbin'></span><span id='topic++5B.DNAbin'></span><span id='topic+rbind.DNAbin'></span><span id='topic+cbind.DNAbin'></span><span id='topic+as.matrix.DNAbin'></span><span id='topic+c.DNAbin'></span><span id='topic+as.list.DNAbin'></span><span id='topic+labels.DNAbin'></span>

<h3>Description</h3>

<p>These functions help to manipulate DNA sequences coded in the
bit-level coding scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DNAbin'
print(x, printlen = 6, digits = 3, ...)
## S3 method for class 'DNAbin'
rbind(...)
## S3 method for class 'DNAbin'
cbind(..., check.names = TRUE, fill.with.gaps = FALSE,
             quiet = FALSE)
## S3 method for class 'DNAbin'
x[i, j, drop = FALSE]
## S3 method for class 'DNAbin'
as.matrix(x, ...)
## S3 method for class 'DNAbin'
c(..., recursive = FALSE)
## S3 method for class 'DNAbin'
as.list(x, ...)
## S3 method for class 'DNAbin'
labels(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DNAbin_+3A_x">x</code>, <code id="DNAbin_+3A_object">object</code></td>
<td>
<p>an object of class <code>"DNAbin"</code>.</p>
</td></tr>
<tr><td><code id="DNAbin_+3A_...">...</code></td>
<td>
<p>either further arguments to be passed to or from other
methods in the case of <code>print</code>, <code>as.matrix</code>, and
<code>labels</code>, or a series of objects of class <code>"DNAbin"</code> in the
case of <code>rbind</code>, <code>cbind</code>, and <code>c</code>.</p>
</td></tr>
<tr><td><code id="DNAbin_+3A_printlen">printlen</code></td>
<td>
<p>the number of labels to print (6 by default).</p>
</td></tr>
<tr><td><code id="DNAbin_+3A_digits">digits</code></td>
<td>
<p>the number of digits to print (3 by default).</p>
</td></tr>
<tr><td><code id="DNAbin_+3A_check.names">check.names</code></td>
<td>
<p>a logical specifying whether to check the rownames
before binding the columns (see details).</p>
</td></tr>
<tr><td><code id="DNAbin_+3A_fill.with.gaps">fill.with.gaps</code></td>
<td>
<p>a logical indicating whether to keep all
possible individuals as indicating by the rownames, and eventually
filling the missing data with insertion gaps (ignored if
<code>check.names = FALSE</code>).</p>
</td></tr>
<tr><td><code id="DNAbin_+3A_quiet">quiet</code></td>
<td>
<p>a logical to switch off warning messages when some rows
are dropped.</p>
</td></tr>
<tr><td><code id="DNAbin_+3A_i">i</code>, <code id="DNAbin_+3A_j">j</code></td>
<td>
<p>indices of the rows and/or columns to select or to drop.
They may be numeric, logical, or character (in the same way than for
standard <span class="rlang"><b>R</b></span> objects).</p>
</td></tr>
<tr><td><code id="DNAbin_+3A_drop">drop</code></td>
<td>
<p>logical; if <code>TRUE</code>, the returned object is of the
lowest possible dimension.</p>
</td></tr>
<tr><td><code id="DNAbin_+3A_recursive">recursive</code></td>
<td>
<p>for compatibility with the generic (unused).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are all &lsquo;methods&rsquo; of generic functions which are here applied to
DNA sequences stored as objects of class <code>"DNAbin"</code>. They are
used in the same way than the standard <span class="rlang"><b>R</b></span> functions to manipulate
vectors, matrices, and lists. Additionally, the operators <code>[[</code>
and <code>$</code> may be used to extract a vector from a list. Note that
the default of <code>drop</code> is not the same than the generic operator:
this is to avoid dropping rownames when selecting a single sequence.
</p>
<p>These functions are provided to manipulate easily DNA sequences coded
with the bit-level coding scheme. The latter allows much faster
comparisons of sequences, as well as storing them in less memory
compared to the format used before <span class="pkg">ape</span> 1.10.
</p>
<p>For <code>cbind</code>, the default behaviour is to keep only individuals
(as indicated by the rownames) for which there are no missing data. If
<code>fill.with.gaps = TRUE</code>, a &lsquo;complete&rsquo; matrix is returned,
enventually with insertion gaps as missing data. If <code>check.names
  = TRUE</code> (the default), the rownames of each matrix are checked, and
the rows are reordered if necessary (if some rownames are duplicated,
an error is returned). If <code>check.names = FALSE</code>, the matrices
must all have the same number of rows, and are simply binded; the
rownames of the first matrix are used. See the examples.
</p>
<p><code>as.matrix</code> may be used to convert DNA sequences (of the same
length) stored in a list into a matrix while keeping the names and the
class. <code>as.list</code> does the reverse operation.
</p>


<h3>Value</h3>

<p>an object of class <code>"DNAbin"</code> in the case of <code>rbind</code>,
<code>cbind</code>, and <code>[</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Paradis, E. (2007) A Bit-Level Coding Scheme for Nucleotides.
<a href="https://emmanuelparadis.github.io/misc/BitLevelCodingScheme_20April2007.pdf">https://emmanuelparadis.github.io/misc/BitLevelCodingScheme_20April2007.pdf</a>
</p>
<p>Paradis, E. (2012) <em>Analysis of Phylogenetics and Evolution with
R (Second Edition).</em> New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.DNAbin">as.DNAbin</a></code>, <code><a href="#topic+read.dna">read.dna</a></code>,
<code><a href="#topic+read.GenBank">read.GenBank</a></code>, <code><a href="#topic+write.dna">write.dna</a></code>,
<code><a href="#topic+image.DNAbin">image.DNAbin</a></code>,<code><a href="#topic+AAbin">AAbin</a></code>
</p>
<p>The corresponding generic functions are documented in the package
<span class="pkg">base</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
woodmouse
print(woodmouse, 15, 6)
print(woodmouse[1:5, 1:300], 15, 6)
### Just to show how distances could be influenced by sampling:
dist.dna(woodmouse[1:2, ])
dist.dna(woodmouse[1:3, ])
### cbind and its options:
x &lt;- woodmouse[1:2, 1:5]
y &lt;- woodmouse[2:4, 6:10]
as.character(cbind(x, y)) # gives warning
as.character(cbind(x, y, fill.with.gaps = TRUE))
## Not run: 
as.character(cbind(x, y, check.names = FALSE)) # gives an error

## End(Not run)
</code></pre>

<hr>
<h2 id='DNAbin2indel'>Recode Blocks of Indels</h2><span id='topic+DNAbin2indel'></span>

<h3>Description</h3>

<p>This function scans a set of aligned DNA sequences and returns a
matrix with information of the localisations and lengths on alignment
gaps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DNAbin2indel(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DNAbin2indel_+3A_x">x</code></td>
<td>
<p>an object of class <code>"DNAbin"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output matrix has the same dimensions than the input one with,
either a numeric value where an alignment gap starts giving the length
of the gap, or zero. The rownames are kept.
</p>


<h3>Value</h3>

<p>a numeric matrix.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+DNAbin">DNAbin</a></code>, <code><a href="#topic+as.DNAbin">as.DNAbin</a></code>, <code><a href="#topic+del.gaps">del.gaps</a></code>,
<code><a href="#topic+seg.sites">seg.sites</a></code>, <code><a href="#topic+image.DNAbin">image.DNAbin</a></code>,
<code><a href="#topic+checkAlignment">checkAlignment</a></code>
</p>

<hr>
<h2 id='dnds'>dN/dS Ratio</h2><span id='topic+dnds'></span>

<h3>Description</h3>

<p>This function computes the pairwise ratios dN/dS for a set of aligned
DNA sequences using Li's (1993) method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnds(x, code = 1, codonstart = 1, quiet = FALSE,
     details = FALSE, return.categories = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dnds_+3A_x">x</code></td>
<td>
<p>an object of class <code>"DNAbin"</code> (matrix or list) with the
aligned sequences.</p>
</td></tr>
<tr><td><code id="dnds_+3A_code">code</code></td>
<td>
<p>an integer value giving the genetic code to be
used. Currently, the codes 1 to 6 are supported.</p>
</td></tr>
<tr><td><code id="dnds_+3A_codonstart">codonstart</code></td>
<td>
<p>an integer giving where to start the translation. This
should be 1, 2, or 3, but larger values are accepted and have for
effect to start the translation further within the sequence.</p>
</td></tr>
<tr><td><code id="dnds_+3A_quiet">quiet</code></td>
<td>
<p>single logical value: whether to indicate progress of
calculations.</p>
</td></tr>
<tr><td><code id="dnds_+3A_details">details</code></td>
<td>
<p>single logical value (see details).</p>
</td></tr>
<tr><td><code id="dnds_+3A_return.categories">return.categories</code></td>
<td>
<p>a logical value: if <code>TRUE</code>, a matrix of
the same size than <code>x</code> is returned giving the degeneracy category
of each base in the original alignment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since <span class="pkg">ape</span> 5.6, the degeneracy of each codon is calculated
directly from the genetic code using the function
<code><a href="#topic+trans">trans</a></code>. A consequence is that ambiguous bases are ignored
(see <code><a href="#topic+solveAmbiguousBases">solveAmbiguousBases</a></code>).
</p>
<p>If <code>details = TRUE</code>, a table is printed for each pair of
sequences giving the numbers of transitions and transversions for each
category of degeneracy (nondegenerate, twofold, and fourfold). This is
helpful when non-meaningful values are returned (e.g., NaN, Inf,
negative values).
</p>


<h3>Value</h3>

<p>an object of class <code>"dist"</code>, or a numeric matrix if
<code>return.categories = TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Li, W.-H. (1993) Unbiased estimation of the rates of synonymous and
nonsynonymous substitution. <em>Journal of Molecular Evolution</em>,
<b>36</b>, 96&ndash;99.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AAbin">AAbin</a></code>, <code><a href="#topic+trans">trans</a></code>, <code><a href="#topic+alview">alview</a></code>,
<code><a href="#topic+solveAmbiguousBases">solveAmbiguousBases</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
res &lt;- dnds(woodmouse, quiet = TRUE) # NOT correct
res2 &lt;- dnds(woodmouse, code = 2, quiet = TRUE) # using the correct code
identical(res, res2) # FALSE...
cor(res, res2) # ... but very close
## There a few N's in the woodmouse data, but this does not affect
## greatly the results:
res3 &lt;- dnds(solveAmbiguousBases(woodmouse), code = 2, quiet = TRUE)
cor(res, res3)

## a simple example showing the usefulness of 'details = TRUE'
X &lt;- as.DNAbin(matrix(c("C", "A", "G", "G", "T", "T"), 2, 3))
alview(X)
dnds(X, quiet = TRUE) # NaN
dnds(X, details = TRUE) # only a TV at a nondegenerate site
</code></pre>

<hr>
<h2 id='drop.tip'>Remove Tips in a Phylogenetic Tree</h2><span id='topic+drop.tip'></span><span id='topic+drop.tip.phylo'></span><span id='topic+drop.tip.multiPhylo'></span><span id='topic+keep.tip'></span><span id='topic+keep.tip.phylo'></span><span id='topic+keep.tip.multiPhylo'></span><span id='topic+extract.clade'></span>

<h3>Description</h3>

<p><code>drop.tip</code> removes the terminal branches of a phylogenetic tree,
possibly removing the corresponding internal branches. <code>keep.tip</code>
does the opposite operation (i.e., returns the induced tree).
</p>
<p><code>extract.clade</code> does the inverse operation: it keeps all the tips
from a given node, and deletes all the other tips.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop.tip(phy, tip, ...)
## S3 method for class 'phylo'
drop.tip(phy, tip, trim.internal = TRUE, subtree = FALSE,
         root.edge = 0, rooted = is.rooted(phy), collapse.singles = TRUE,
         interactive = FALSE, ...)
## S3 method for class 'multiPhylo'
drop.tip(phy, tip, ...)

keep.tip(phy, tip, ...)
## S3 method for class 'phylo'
keep.tip(phy, tip, ...)
## S3 method for class 'multiPhylo'
keep.tip(phy, tip, ...)

extract.clade(phy, node, root.edge = 0, collapse.singles = TRUE,
              interactive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop.tip_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="drop.tip_+3A_tip">tip</code></td>
<td>
<p>a vector of mode numeric or character specifying the tips
to delete.</p>
</td></tr>
<tr><td><code id="drop.tip_+3A_trim.internal">trim.internal</code></td>
<td>
<p>a logical specifying whether to delete the
corresponding internal branches.</p>
</td></tr>
<tr><td><code id="drop.tip_+3A_subtree">subtree</code></td>
<td>
<p>a logical specifying whether to output in the tree how
many tips have been deleted and where.</p>
</td></tr>
<tr><td><code id="drop.tip_+3A_root.edge">root.edge</code></td>
<td>
<p>an integer giving the number of internal branches to
be used to build the new root edge. This has no effect if
<code>trim.internal = FALSE</code>.</p>
</td></tr>
<tr><td><code id="drop.tip_+3A_rooted">rooted</code></td>
<td>
<p>a logical indicating whether the tree must be treated as
rooted or not. This allows to force the tree to be considered as
unrooted (see examples). See details about a possible root.edge
element in the tree.</p>
</td></tr>
<tr><td><code id="drop.tip_+3A_collapse.singles">collapse.singles</code></td>
<td>
<p>a logical specifying whether to delete the
internal nodes of degree 2.</p>
</td></tr>
<tr><td><code id="drop.tip_+3A_node">node</code></td>
<td>
<p>a node number or label.</p>
</td></tr>
<tr><td><code id="drop.tip_+3A_interactive">interactive</code></td>
<td>
<p>if <code>TRUE</code> the user is asked to select the tips
or the node by clicking on the tree which must be plotted.</p>
</td></tr>
<tr><td><code id="drop.tip_+3A_...">...</code></td>
<td>
<p>arguments passed from and to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>tip</code> can be either character or numeric. In the
first case, it gives the labels of the tips to be deleted; in the
second case the numbers of these labels in the vector
<code>phy$tip.label</code> are given.
</p>
<p>This also applies to <code>node</code>, but if this argument is character
and the tree has no node label, this results in an error. If more than
one value is given with <code>node</code> (i.e., a vector of length two or
more), only the first one is used with a warning.
</p>
<p>If <code>trim.internal = FALSE</code>, the new tips are given <code>"NA"</code> as
labels, unless there are node labels in the tree in which case they
are used.
</p>
<p>If <code>subtree = TRUE</code>, the returned tree has one or several
terminal branches named with node labels if available. Otherwise it is
indicated how many tips have been removed (with a label <code>"[x_tips]"</code>).
This is done for as many monophyletic groups that have been deleted.
</p>
<p>Note that <code>subtree = TRUE</code> implies <code>trim.internal = TRUE</code>.
</p>
<p>To undestand how the option <code>root.edge</code> works, see the examples
below. If <code>rooted = FALSE</code> and the tree has a root edge, the
latter is removed in the output.
</p>


<h3>Value</h3>

<p>an object of class <code>"phylo"</code>.</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis, Klaus Schliep, Joseph Brown</p>


<h3>See Also</h3>

<p><code><a href="#topic+bind.tree">bind.tree</a></code>, <code><a href="#topic+root">root</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bird.families)
tip &lt;- c(
"Eopsaltriidae", "Acanthisittidae", "Pittidae", "Eurylaimidae",
"Philepittidae", "Tyrannidae", "Thamnophilidae", "Furnariidae",
"Formicariidae", "Conopophagidae", "Rhinocryptidae", "Climacteridae",
"Menuridae", "Ptilonorhynchidae", "Maluridae", "Meliphagidae",
"Pardalotidae", "Petroicidae", "Irenidae", "Orthonychidae",
"Pomatostomidae", "Laniidae", "Vireonidae", "Corvidae",
"Callaeatidae", "Picathartidae", "Bombycillidae", "Cinclidae",
"Muscicapidae", "Sturnidae", "Sittidae", "Certhiidae",
"Paridae", "Aegithalidae", "Hirundinidae", "Regulidae",
"Pycnonotidae", "Hypocoliidae", "Cisticolidae", "Zosteropidae",
"Sylviidae", "Alaudidae", "Nectariniidae", "Melanocharitidae",
"Paramythiidae","Passeridae", "Fringillidae")
plot(drop.tip(bird.families, tip))
plot(drop.tip(bird.families, tip, trim.internal = FALSE))
data(bird.orders)
plot(drop.tip(bird.orders, 6:23, subtree = TRUE))
plot(drop.tip(bird.orders, c(1:5, 20:23), subtree = TRUE))
plot(drop.tip(bird.orders, c(1:20, 23), subtree = TRUE))
plot(drop.tip(bird.orders, c(1:20, 23), subtree = TRUE, rooted = FALSE))
### Examples of the use of `root.edge'
tr &lt;- read.tree(text = "(A:1,(B:1,(C:1,(D:1,E:1):1):1):1):1;")
drop.tip(tr, c("A", "B"), root.edge = 0) # = (C:1,(D:1,E:1):1);
drop.tip(tr, c("A", "B"), root.edge = 1) # = (C:1,(D:1,E:1):1):1;
drop.tip(tr, c("A", "B"), root.edge = 2) # = (C:1,(D:1,E:1):1):2;
drop.tip(tr, c("A", "B"), root.edge = 3) # = (C:1,(D:1,E:1):1):3;
</code></pre>

<hr>
<h2 id='edges'>Draw Additional Edges on a Plotted Tree</h2><span id='topic+edges'></span><span id='topic+fancyarrows'></span>

<h3>Description</h3>

<p><code>edges</code> draws edges on a plotted tree. <code>fancyarrows</code>
enhances <code><a href="graphics.html#topic+arrows">arrows</a></code> with triangle and harpoon
heads; it can be called from <code>edges</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edges(nodes0, nodes1, arrows = 0, type = "classical", ...)
fancyarrows(x0, y0, x1, y1, length = 0.25, angle = 30, code = 2,
            col = par("fg"), lty = par("lty"), lwd = par("lwd"),
            type = "triangle", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edges_+3A_nodes0">nodes0</code>, <code id="edges_+3A_nodes1">nodes1</code></td>
<td>
<p>vectors of integers giving the tip and/or node
numbers where to start and to end the edges (eventually recycled).</p>
</td></tr>
<tr><td><code id="edges_+3A_arrows">arrows</code></td>
<td>
<p>an integer between 0 and 3; 0: lines (the default); 1:
an arrow head is drawn at <code>nodes0</code>; 2: at <code>nodes1</code>; 3:
both.</p>
</td></tr>
<tr><td><code id="edges_+3A_type">type</code></td>
<td>
<p>if the previous argument is not 0, the type of arrow head:
<code>"classical"</code> (just lines, the default), <code>"triangle"</code>,
<code>"harpoon"</code>, or any unambiguous abbreviations of these. For
<code>fancyarrows</code> only the last two are available.</p>
</td></tr>
<tr><td><code id="edges_+3A_x0">x0</code>, <code id="edges_+3A_y0">y0</code>, <code id="edges_+3A_x1">x1</code>, <code id="edges_+3A_y1">y1</code></td>
<td>
<p>the coordinates of the start and end points for
<code>fancyarrows</code> (these are not recycled and so should be vectors
of the same length).</p>
</td></tr>
<tr><td><code id="edges_+3A_length">length</code>, <code id="edges_+3A_angle">angle</code>, <code id="edges_+3A_code">code</code>, <code id="edges_+3A_col">col</code>, <code id="edges_+3A_lty">lty</code>, <code id="edges_+3A_lwd">lwd</code></td>
<td>
<p>default options similar to
those of <code><a href="graphics.html#topic+arrows">arrows</a></code>.</p>
</td></tr>
<tr><td><code id="edges_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="graphics.html#topic+segments">segments</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first function is helpful when drawing reticulations on a phylogeny,
especially if computed from the edge matrix.
</p>
<p><code>fancyarrows</code> does not work with log-transformed scale(s).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.phylo">plot.phylo</a></code>, <code><a href="#topic+nodelabels">nodelabels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2)
tr &lt;- rcoal(6)
plot(tr, "c")
edges(10, 9, col = "red", lty = 2)
edges(10:11, 8, col = c("blue", "green")) # recycling of 'nodes1'
edges(1, 2, lwd = 2, type = "h", arrows = 3, col = "green")
nodelabels()
</code></pre>

<hr>
<h2 id='evonet'>Evolutionary Networks</h2><span id='topic+evonet'></span><span id='topic+as.evonet'></span><span id='topic+as.evonet.phylo'></span><span id='topic+read.evonet'></span><span id='topic+write.evonet'></span><span id='topic+print.evonet'></span><span id='topic+plot.evonet'></span><span id='topic+reorder.evonet'></span><span id='topic+as.phylo.evonet'></span><span id='topic+as.networx.evonet'></span><span id='topic+as.network.evonet'></span><span id='topic+as.igraph.evonet'></span><span id='topic+Nedge.evonet'></span>

<h3>Description</h3>

<p><code>evonet</code> builds a network from a tree of class
<code>"phylo"</code>. There are <code>print</code>, <code>plot</code>, and
<code>reorder</code> methods as well as a few conversion functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evonet(phy, from, to = NULL)
## S3 method for class 'evonet'
print(x, ...)
## S3 method for class 'evonet'
plot(x, col = "blue", lty = 1, lwd = 1, alpha = 0.5,
              arrows = 0, arrow.type = "classical", ...)
## S3 method for class 'evonet'
Nedge(phy)
## S3 method for class 'evonet'
reorder(x, order = "cladewise", index.only = FALSE, ...)
## S3 method for class 'evonet'
as.phylo(x, ...)
## S3 method for class 'evonet'
as.networx(x, weight = NA, ...)
## S3 method for class 'evonet'
as.network(x, directed = TRUE, ...)
## S3 method for class 'evonet'
as.igraph(x, directed = TRUE, use.labels = TRUE, ...)

as.evonet(x, ...)
## S3 method for class 'phylo'
as.evonet(x, ...)

read.evonet(file = "", text = NULL, comment.char = "", ...)
write.evonet(x, file = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evonet_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="evonet_+3A_x">x</code></td>
<td>
<p>an object of class <code>"evonet"</code>.</p>
</td></tr>
<tr><td><code id="evonet_+3A_from">from</code></td>
<td>
<p>a vector (or a matrix if <code>to = NULL</code>) giving the node
or tip numbers involved in the reticulations.</p>
</td></tr>
<tr><td><code id="evonet_+3A_to">to</code></td>
<td>
<p>a vector of the same length than <code>from</code>.</p>
</td></tr>
<tr><td><code id="evonet_+3A_col">col</code>, <code id="evonet_+3A_lty">lty</code>, <code id="evonet_+3A_lwd">lwd</code></td>
<td>
<p>colors, line type and width of the reticulations
(recycled if necessary).</p>
</td></tr>
<tr><td><code id="evonet_+3A_alpha">alpha</code></td>
<td>
<p>a value between 0 and 1 specifying the transparency of
the reticulations.</p>
</td></tr>
<tr><td><code id="evonet_+3A_arrows">arrows</code>, <code id="evonet_+3A_arrow.type">arrow.type</code></td>
<td>
<p>see <code><a href="#topic+fancyarrows">fancyarrows</a></code>.</p>
</td></tr>
<tr><td><code id="evonet_+3A_order">order</code>, <code id="evonet_+3A_index.only">index.only</code></td>
<td>
<p>see <code><a href="#topic+reorder.phylo">reorder.phylo</a></code>.</p>
</td></tr>
<tr><td><code id="evonet_+3A_weight">weight</code></td>
<td>
<p>a numeric vector giving the weights for the
reticulations when converting to the class <code>"networx"</code>
(recycled or shortened if needed).</p>
</td></tr>
<tr><td><code id="evonet_+3A_directed">directed</code></td>
<td>
<p>a logical: should the network be considered as
directed? <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="evonet_+3A_use.labels">use.labels</code></td>
<td>
<p>a logical specifying whether to use the tip and node
labels when building the network of class <code>"igraph"</code>.</p>
</td></tr>
<tr><td><code id="evonet_+3A_file">file</code>, <code id="evonet_+3A_text">text</code>, <code id="evonet_+3A_comment.char">comment.char</code></td>
<td>
<p>see <code><a href="#topic+read.tree">read.tree</a></code>.</p>
</td></tr>
<tr><td><code id="evonet_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>evonet</code> is a constructor function that checks the arguments.
</p>
<p>The classes <code>"networx"</code>, <code>"network"</code>, and <code>"igraph"</code>
are defined in the packages <span class="pkg">phangorn</span>, <span class="pkg">network</span>, and
<span class="pkg">igraph</span>, respectively.
</p>
<p><code>read.evonet</code> reads networks from files in extended newick format
(Cardona et al. 2008).
</p>


<h3>Value</h3>

<p>an object of class <code>c("evonet", "phylo")</code> which is made of an
object of class <code>"<a href="#topic+phylo">phylo</a>"</code> plus an element
<code>reticulation</code> coding additional edges among nodes and uses the
same coding rules than the <code>edge</code> matrix.
</p>
<p>The conversion functions return an object of the appropriate class.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis, Klaus Schliep</p>


<h3>References</h3>

<p>Cardona, G., Rossell, F., and Valiente, G. (2008) Extended Newick: it
is time for a standard representation of phylogenetic
networks. <em>BMC Bioinformatics</em>, <b>9</b>, 532.
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+as.networx">as.networx</a></code> in package <span class="pkg">phangorn</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tr &lt;- rcoal(5)
(x &lt;- evonet(tr, 6:7, 8:9))
plot(x)
## simple example of extended Newick format:
(enet &lt;- read.evonet(text = "((a:2,(b:1)#H1:1):1,(#H1,c:1):2);"))
plot(enet, arrows=1)
## from Fig. 2 in Cardona et al. 2008:
z &lt;- read.evonet(text =
"((1,((2,(3,(4)Y#H1)g)e,(((Y#H1, 5)h,6)f)X#H2)c)a,((X#H2,7)d,8)b)r;")
z
plot(z)
## Not run: 
if (require(igraph)) {
    plot(as.igraph(z))
}
## End(Not run)</code></pre>

<hr>
<h2 id='ewLasso'>
Incomplete distances and edge weights of unrooted topology
</h2><span id='topic+ewLasso'></span>

<h3>Description</h3>

<p>This function implements a method for checking whether an incomplete
set of distances satisfy certain conditions that might make it
uniquely determine the edge weights of a given topology, T. It prints
information about whether the graph with vertex set the set of leaves,
denoted by X, and edge set the set of non-missing distance pairs,
denoted by L, is connected or strongly non-bipartite. It then also
checks whether L is a triplet cover for T.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ewLasso(X, phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ewLasso_+3A_x">X</code></td>
<td>
<p>a distance matrix.</p>
</td></tr>
<tr><td><code id="ewLasso_+3A_phy">phy</code></td>
<td>
<p>an unrooted tree of class <code>"phylo"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing values must be represented by either <code>NA</code> or a negative value.
</p>
<p>This implements a method for checking whether an incomplete set of
distances satisfies certain conditions that might make it uniquely
determine the edge weights of a given topology, T. It prints
information about whether the graph, G, with vertex set the set of
leaves, denoted by X, and edge set the set of non-missing distance
pairs, denoted by L, is connected or strongly non-bipartite. It also
checks whether L is a triplet cover for T. If G is not connected, then
T does not need to be the only topology satisfying the input
incomplete distances. If G is not strongly non-bipartite then the
edge-weights of the edges of T are not the unique ones for which the
input distance is satisfied. If L is a triplet cover, then the input
distance matrix uniquely determines the edge weights of T. See Dress
et al. (2012) for details.
</p>


<h3>Value</h3>

<p>NULL, the results are printed in the console.
</p>


<h3>Author(s)</h3>

<p>Andrei Popescu</p>


<h3>References</h3>

<p>Dress, A. W. M., Huber, K. T., and Steel, M. (2012) &lsquo;Lassoing&rsquo; a
phylogentic tree I: basic properties, shellings and covers.
<em>Journal of Mathematical Biology</em>, <b>65(1)</b>, 77&ndash;105.
</p>

<hr>
<h2 id='FastME'>
Tree Estimation Based on the Minimum Evolution Algorithm
</h2><span id='topic+FastME'></span><span id='topic+fastme'></span><span id='topic+fastme.bal'></span><span id='topic+fastme.ols'></span>

<h3>Description</h3>

<p>The two FastME functions (balanced and OLS) perform the
minimum evolution algorithm of Desper and Gascuel (2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fastme.bal(X, nni = TRUE, spr = TRUE, tbr = FALSE)
  fastme.ols(X, nni = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FastME_+3A_x">X</code></td>
<td>
<p>a distance matrix; may be an object of class <code>"dist"</code>.</p>
</td></tr>
<tr><td><code id="FastME_+3A_nni">nni</code></td>
<td>
<p>a logical value; TRUE to perform NNIs (default).</p>
</td></tr>
<tr><td><code id="FastME_+3A_spr">spr</code></td>
<td>
<p>ditto for SPRs.</p>
</td></tr>
<tr><td><code id="FastME_+3A_tbr">tbr</code></td>
<td>
<p>ignored (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code to perform topology searches based on TBR (tree bisection and
reconnection) did not run correctly and has been removed after the
release of <span class="pkg">ape</span> 5.3. A warning is issued if <code>tbr = TRUE</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>"phylo"</code>.
</p>


<h3>Author(s)</h3>

<p>original C code by Richard Desper; adapted and ported to R
by Vincent Lefort <a href="mailto:vincent.lefort@lirmm.fr">vincent.lefort@lirmm.fr</a>
</p>


<h3>References</h3>

<p>Desper, R. and Gascuel, O. (2002) Fast and accurate phylogeny
reconstruction algorithms based on the minimum-evolution principle.
<em>Journal of Computational Biology</em>, <b>9</b>, 687&ndash;705.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nj">nj</a></code>, <code><a href="#topic+bionj">bionj</a></code>,
<code><a href="#topic+write.tree">write.tree</a></code>, <code><a href="#topic+read.tree">read.tree</a></code>,
<code><a href="#topic+dist.dna">dist.dna</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### From Saitou and Nei (1987, Table 1):
x &lt;- c(7, 8, 11, 13, 16, 13, 17, 5, 8, 10, 13,
       10, 14, 5, 7, 10, 7, 11, 8, 11, 8, 12,
       5, 6, 10, 9, 13, 8)
M &lt;- matrix(0, 8, 8)
M[lower.tri(M)] &lt;- x
M &lt;- t(M)
M[lower.tri(M)] &lt;- x
dimnames(M) &lt;- list(1:8, 1:8)
tr &lt;- fastme.bal(M)
plot(tr, "u")
### a less theoretical example
data(woodmouse)
trw &lt;- fastme.bal(dist.dna(woodmouse))
plot(trw)
</code></pre>

<hr>
<h2 id='gammaStat'>Gamma-Statistic of Pybus and Harvey</h2><span id='topic+gammaStat'></span>

<h3>Description</h3>

<p>This function computes the gamma-statistic which summarizes the
information contained in the inter-node intervals of a phylogeny. It
is assumed that the tree is ultrametric. Note that the function does
not check that the tree is effectively ultrametric, so if it is not,
the returned result may not be meaningful.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammaStat(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gammaStat_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gamma-statistic is a summary of the information contained in the
inter-node intervals of a phylogeny; it follows, under the assumption
that the clade diversified with constant rates, a normal distribution
with mean zero and standard-deviation unity (Pybus and Harvey
2000). Thus, the null hypothesis that the clade diversified with
constant rates may be tested with <code>2*(1 -
    pnorm(abs(gammaStat(phy))))</code> for a two-tailed test, or <code>1 -
    pnorm(abs(gammaStat(phy)))</code> for a one-tailed test, both returning
the corresponding P-value.
</p>


<h3>Value</h3>

<p>a numeric vector of length one.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Pybus, O. G. and Harvey, P. H. (2000) Testing macro-evolutionary
models using incomplete molecular phylogenies. <em>Proceedings of
the Royal Society of London. Series B. Biological Sciences</em>,
<b>267</b>, 2267&ndash;2272.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+branching.times">branching.times</a></code>, <code><a href="#topic+ltt.plot">ltt.plot</a></code>, <code><a href="#topic+skyline">skyline</a></code>
</p>

<hr>
<h2 id='getAnnotationsGenBank'>Read Annotations from GenBank</h2><span id='topic+getAnnotationsGenBank'></span>

<h3>Description</h3>

<p>This function connects to the GenBank database and reads sequence annotations
using accession number(s) given as argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAnnotationsGenBank(access.nb, quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAnnotationsGenBank_+3A_access.nb">access.nb</code></td>
<td>
<p>a vector of mode character giving the accession
numbers.</p>
</td></tr>
<tr><td><code id="getAnnotationsGenBank_+3A_quiet">quiet</code></td>
<td>
<p>a logical value indicating whether to show the progress
of the downloads.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sequence annotations (a.k.a. feature list) are returned in a data
frame with five or six columns: start, end, type, product, others, and
gene (the last being optional). This is the same information that can
be downloaded from NCBI's Web interface by clicking on &lsquo;Send to:&rsquo;,
&lsquo;File&rsquo;, and then selecting &lsquo;Feature Table&rsquo; under &lsquo;Format&rsquo;.
</p>
<p>A warning is given if some features are incomplete (this information
is then dropped from the returned object).
</p>
<p>A warning is given if some accession numbers are not found on GenBank.
</p>


<h3>Value</h3>

<p>On of the followings: (i) a data frame if <code>access.nb</code> contains a
single accession number; (ii) a list of data frames if
<code>access.nb</code> contains several accession numbers, the names are set
with <code>access.nb</code> (if some accession numbers are not found on
GenBank, the corresponding entries are set to <code>NULL</code>); (iii)
<code>NULL</code> if all accession numbers are not found on GenBank.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>https://www.ncbi.nlm.nih.gov/Sequin/table.html (Note: it
seems this URL is broken; 2022-01-03)</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.GenBank">read.GenBank</a></code>, <code><a href="#topic+read.gff">read.gff</a></code>,
<code><a href="#topic+DNAbin">DNAbin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The 8 sequences of tanagers (Ramphocelus):
ref &lt;- c("U15717", "U15718", "U15719", "U15720",
         "U15721", "U15722", "U15723", "U15724")
## Copy/paste or type the following commands if you
## want to try them.
## Not run: 
annot.rampho &lt;- getAnnotationsGenBank(ref)
annot.rampho
## check all annotations are the same:
unique(do.call(rbind, annot.rampho)[, -5])

## End(Not run)
</code></pre>

<hr>
<h2 id='hivtree'>Phylogenetic Tree of 193 HIV-1 Sequences</h2><span id='topic+hivtree'></span><span id='topic+hivtree.newick'></span><span id='topic+hivtree.table'></span>

<h3>Description</h3>

<p>This data set describes an estimated clock-like phylogeny of 193 HIV-1
group M sequences sampled in the Democratic Republic of Congo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hivtree.newick)
data(hivtree.table)
</code></pre>


<h3>Format</h3>

<p><code>hivtree.newick</code> is a string with the tree in Newick format.
The data frame <code>hivtree.table</code> contains the corresponding internode
distances.
</p>


<h3>Source</h3>

<p>This is a data example from Strimmer and Pybus (2001).</p>


<h3>References</h3>

<p>Strimmer, K. and Pybus, O. G. (2001) Exploring the demographic history
of DNA sequences using the generalized skyline plot. <em>Molecular
Biology and Evolution</em>, <b>18</b>, 2298&ndash;2305.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coalescent.intervals">coalescent.intervals</a></code>, <code><a href="#topic+collapsed.intervals">collapsed.intervals</a></code>
</p>

<hr>
<h2 id='howmanytrees'>Calculate Numbers of Phylogenetic Trees</h2><span id='topic+howmanytrees'></span><span id='topic+LargeNumber'></span><span id='topic+print.LargeNumber'></span>

<h3>Description</h3>

<p><code>howmanytrees</code> calculates the number of possible phylogenetic
trees for a given number of tips.
</p>
<p><code>LargeNumber</code> is a utility function to compute (approximately)
large numbers from the power <code class="reqn">a^b</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>howmanytrees(n, rooted = TRUE, binary = TRUE,
             labeled = TRUE, detail = FALSE)
LargeNumber(a, b)
## S3 method for class 'LargeNumber'
print(x, latex = FALSE, digits = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="howmanytrees_+3A_n">n</code></td>
<td>
<p>a positive numeric integer giving the number of tips.</p>
</td></tr>
<tr><td><code id="howmanytrees_+3A_rooted">rooted</code></td>
<td>
<p>a logical indicating whether the trees are rooted
(default is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="howmanytrees_+3A_binary">binary</code></td>
<td>
<p>a logical indicating whether the trees are bifurcating
(default is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="howmanytrees_+3A_labeled">labeled</code></td>
<td>
<p>a logical indicating whether the trees have tips
labeled (default is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="howmanytrees_+3A_detail">detail</code></td>
<td>
<p>a logical indicating whether the eventual intermediate
calculations should be returned (default is <code>FALSE</code>). This
applies only for the multifurcating trees, and the bifurcating,
rooted, unlabeled trees (aka tree shapes).</p>
</td></tr>
<tr><td><code id="howmanytrees_+3A_a">a</code>, <code id="howmanytrees_+3A_b">b</code></td>
<td>
<p>two numbers.</p>
</td></tr>
<tr><td><code id="howmanytrees_+3A_x">x</code></td>
<td>
<p>an object of class <code>"LargeNumber"</code>.</p>
</td></tr>
<tr><td><code id="howmanytrees_+3A_latex">latex</code></td>
<td>
<p>a logical value specifying whether to print the number in
LaTeX code in addition to return it.</p>
</td></tr>
<tr><td><code id="howmanytrees_+3A_digits">digits</code></td>
<td>
<p>the number of digits printed for the real part of the
large number (unused if <code>latex = FALSE</code>).</p>
</td></tr>
<tr><td><code id="howmanytrees_+3A_...">...</code></td>
<td>
<p>(unused).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the cases of labeled binary trees, the calculation is done directly
and a single numeric value is returned (or an object of class
<code>"LargeNumber"</code>).
</p>
<p>For multifurcating trees, and bifurcating, rooted, unlabeled trees,
the calculation is done iteratively for 1 to <code>n</code> tips. Thus the
user can print all the intermediate values if <code>detail = TRUE</code>, or
only a single value if <code>detail = FALSE</code> (the default).
</p>
<p>For multifurcating trees, if <code>detail = TRUE</code>, a matrix is
returned with the number of tips as rows (named from <code>1</code> to
<code>n</code>), and the number of nodes as columns (named from <code>1</code> to
<code>n - 1</code>). For bifurcating, rooted, unlabeled trees, a vector is
returned with names equal to the number of tips (from <code>1</code> to
<code>n</code>).
</p>
<p>The number of unlabeled trees (aka tree shapes) can be computed only
for the rooted binary cases.
</p>
<p>Note that if an infinite value (<code>Inf</code>) is returned this does not
mean that there is an infinite number of trees (this cannot be if the
number of tips is finite), but that the calculation is beyond the
limits of the computer. Only for the cases of rooted, binary, labeled
topologies an approximate number is returned in the form a
<code>"LargeNumber"</code> object.
</p>


<h3>Value</h3>

<p>a single numeric value, an object of class <code>"LargeNumber"</code>, or in
the case where <code>detail = TRUE</code> is used, a named vector or
matrix.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Felsenstein, J. (2004) <em>Inferring Phylogenies</em>. Sunderland:
Sinauer Associates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Table 3.1 in Felsenstein 2004:
for (i in c(1:20, 30, 40, 50))
  cat(paste(i, howmanytrees(i), sep = "\t"), sep ="\n")
### Table 3.6:
howmanytrees(8, binary = FALSE, detail = TRUE)
</code></pre>

<hr>
<h2 id='identify.phylo'>Graphical Identification of Nodes and Tips</h2><span id='topic+identify.phylo'></span>

<h3>Description</h3>

<p>This function allows to identify a clade on a plotted tree by clicking
on the plot with the mouse. The tree, specified in the argument
<code>x</code>, must be plotted beforehand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phylo'
identify(x, nodes = TRUE, tips = FALSE,
                  labels = FALSE, quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify.phylo_+3A_x">x</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="identify.phylo_+3A_nodes">nodes</code></td>
<td>
<p>a logical specifying whether to identify the node.</p>
</td></tr>
<tr><td><code id="identify.phylo_+3A_tips">tips</code></td>
<td>
<p>a logical specifying whether to return the tip
information.</p>
</td></tr>
<tr><td><code id="identify.phylo_+3A_labels">labels</code></td>
<td>
<p>a logical specifying whether to return the labels; by
default only the numbers are returned.</p>
</td></tr>
<tr><td><code id="identify.phylo_+3A_quiet">quiet</code></td>
<td>
<p>a logical controlling whether to print a message inviting
the user to click on the tree.</p>
</td></tr>
<tr><td><code id="identify.phylo_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the clade is identified by its number as found in the
&lsquo;edge&rsquo; matrix of the tree. If <code>tips = TRUE</code>, the tips descending
from the identified node are returned, possibly together with the
node. If <code>labels = TRUE</code>, the labels are returned (if the tree
has no node labels, then the node numbered is returned).
</p>
<p>The node is identified by the shortest distance where the click
occurs. If the click occurs close to a tip, the function returns its
information.
</p>


<h3>Value</h3>

<p>A list with one or two vectors named <code>"tips"</code> and/or
<code>"nodes"</code> with the identification of the tips and/or of the
nodes.
</p>


<h3>Note</h3>

<p>This function does not add anything on the plot, but it can be wrapped
with, e.g., <code><a href="#topic+nodelabels">nodelabels</a></code> (see example), or its results can
be sent to, e.g., <code><a href="#topic+drop.tip">drop.tip</a></code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.phylo">plot.phylo</a></code>, <code><a href="#topic+nodelabels">nodelabels</a></code>,
<code><a href="graphics.html#topic+identify">identify</a></code> for the generic function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tr &lt;- rtree(20)
f &lt;- function(col) {
    o &lt;- identify(tr)
    nodelabels(node=o$nodes, pch = 19, col = col)
}
plot(tr)
f("red") # click close to a node
f("green")

## End(Not run)
</code></pre>

<hr>
<h2 id='image.DNAbin'>Plot of DNA Sequence Alignement</h2><span id='topic+image.DNAbin'></span>

<h3>Description</h3>

<p>This function plots an image of an alignment of nucleotide sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DNAbin'
image(x, what, col, bg = "white", xlab = "", ylab = "",
      show.labels = TRUE, cex.lab = 1, legend = TRUE,
      grid = FALSE, show.bases = FALSE, base.cex = 1,
      base.font = 1, base.col = "black", scheme = "Ape_NT", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image.DNAbin_+3A_x">x</code></td>
<td>
<p>a matrix of DNA sequences (class <code>"DNAbin"</code>).</p>
</td></tr>
<tr><td><code id="image.DNAbin_+3A_what">what</code></td>
<td>
<p>a vector of characters specifying the bases to
visualize. If missing, this is set to &ldquo;a&rdquo;, &ldquo;g&rdquo;, &ldquo;c&rdquo;, &ldquo;t&rdquo;,
&ldquo;n&rdquo;, and &ldquo;-&rdquo; (in this order).</p>
</td></tr>
<tr><td><code id="image.DNAbin_+3A_col">col</code></td>
<td>
<p>a vector of colours. If missing, this is set to &ldquo;red&rdquo;,
&ldquo;yellow&rdquo;, &ldquo;green&rdquo;, &ldquo;blue&rdquo;, &ldquo;grey&rdquo;, and &ldquo;black&rdquo;. If it is
shorter (or longer) than <code>what</code>, it is recycled (or shortened).</p>
</td></tr>
<tr><td><code id="image.DNAbin_+3A_bg">bg</code></td>
<td>
<p>the colour used for nucleotides whose base is not among
<code>what</code>.</p>
</td></tr>
<tr><td><code id="image.DNAbin_+3A_xlab">xlab</code></td>
<td>
<p>the label for the <em>x</em>-axis; none by default.</p>
</td></tr>
<tr><td><code id="image.DNAbin_+3A_ylab">ylab</code></td>
<td>
<p>Idem for the <em>y</em>-axis. Note that by default, the
labels of the sequences are printed on the <em>y</em>-axis (see next option).</p>
</td></tr>
<tr><td><code id="image.DNAbin_+3A_show.labels">show.labels</code></td>
<td>
<p>a logical controlling whether the sequence labels
are printed (<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="image.DNAbin_+3A_cex.lab">cex.lab</code></td>
<td>
<p>a single numeric controlling the size of the sequence labels.
Use <code>cex.axis</code> to control the size of the annotations on the
<em>x</em>-axis.</p>
</td></tr>
<tr><td><code id="image.DNAbin_+3A_legend">legend</code></td>
<td>
<p>a logical controlling whether the legend is plotted
(<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="image.DNAbin_+3A_grid">grid</code></td>
<td>
<p>a logical controlling whether to draw a grid (<code>FALSE</code>
by default).</p>
</td></tr>
<tr><td><code id="image.DNAbin_+3A_show.bases">show.bases</code></td>
<td>
<p>a logical controlling whether to show the base symbols
(<code>FALSE</code> by default).</p>
</td></tr>
<tr><td><code id="image.DNAbin_+3A_base.cex">base.cex</code>, <code id="image.DNAbin_+3A_base.font">base.font</code>, <code id="image.DNAbin_+3A_base.col">base.col</code></td>
<td>
<p>control the aspect of the base
symbols (ignored if the previous is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="image.DNAbin_+3A_scheme">scheme</code></td>
<td>
<p>a predefined color scheme. For amino acid options are &quot;Ape_AA&quot;,
&quot;Zappo_AA&quot;, &quot;Clustal&quot;, &quot;Polarity&quot; and &quot;Transmembrane_tendency&quot;, for
nucleotides &quot;Ape_NT&quot; and&quot;RY_NT&quot;.</p>
</td></tr>
<tr><td><code id="image.DNAbin_+3A_...">...</code></td>
<td>
<p>further arguments passed to
<code><a href="graphics.html#topic+image.default">image.default</a></code> (e.g., <code>xlab</code>,
<code>cex.axis</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The idea of this function is to allow flexible plotting and colouring
of a nucleotide alignment. By default, the most common bases (a, g, c,
t, and n) and alignment gap are plotted using a standard colour
scheme.
</p>
<p>It is possible to plot only one base specified as <code>what</code> with a
chosen colour: this might be useful to check, for instance, the
distribution of alignment gaps (<code>image(x, "-")</code>) or missing data
(see examples).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis, Klaus Schliep</p>


<h3>See Also</h3>

<p><code><a href="#topic+DNAbin">DNAbin</a></code>, <code><a href="#topic+del.gaps">del.gaps</a></code>, <code><a href="#topic+alex">alex</a></code>,
<code><a href="#topic+alview">alview</a></code>, <code><a href="#topic+all.equal.DNAbin">all.equal.DNAbin</a></code>,
<code><a href="#topic+clustal">clustal</a></code>, <code><a href="graphics.html#topic+grid">grid</a></code>,
<code><a href="#topic+image.AAbin">image.AAbin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
image(woodmouse)
rug(seg.sites(woodmouse), -0.02, 3, 1)
image(woodmouse, "n", "blue") # show missing data
image(woodmouse, c("g", "c"), "green") # G+C
par(mfcol = c(2, 2))
### barcoding style:
for (x in c("a", "g", "c", "t"))
    image(woodmouse, x, "black", cex.lab = 0.5, cex.axis = 0.7)
par(mfcol = c(1, 1))
### zoom on a portion of the data:
image(woodmouse[11:15, 1:50], c("a", "n"), c("blue", "grey"))
grid(50, 5, col = "black")
### see the guanines on a black background:
image(woodmouse, "g", "yellow", "black")
### Amino acid
X &lt;- trans(woodmouse, 2)
image(X) # default ape colors
image(X, scheme="Clustal") # Clustal coloring
</code></pre>

<hr>
<h2 id='Initialize.corPhyl'>Initialize a &lsquo;corPhyl&rsquo; Structure Object</h2><span id='topic+Initialize.corPhyl'></span>

<h3>Description</h3>

<p>Initialize a <code>corPhyl</code> correlation structure object.
Does the same as <code>Initialize.corStruct</code>, but also checks the row names of data and builds an index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S3 method for class 'corPhyl'
Initialize(object, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Initialize.corPhyl_+3A_object">object</code></td>
<td>
<p>An object inheriting from class <code>corPhyl</code>.</p>
</td></tr>
<tr><td><code id="Initialize.corPhyl_+3A_data">data</code></td>
<td>
<p>The data to use. If it contains rownames, they are matched with the tree tip labels, otherwise data are supposed to be in the same order than tip labels and a warning is sent.</p>
</td></tr>
<tr><td><code id="Initialize.corPhyl_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional arguments. None are used in this method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An initialized object of same class as <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Julien Dutheil <a href="mailto:dutheil@evolbio.mpg.de">dutheil@evolbio.mpg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+corClasses">corClasses</a></code>, <code><a href="nlme.html#topic+Initialize.corStruct">Initialize.corStruct</a></code>.
</p>

<hr>
<h2 id='is.binary'>Test for Binary Tree</h2><span id='topic+is.binary'></span><span id='topic+is.binary.phylo'></span><span id='topic+is.binary.multiPhylo'></span><span id='topic+is.binary.tree'></span>

<h3>Description</h3>

<p>This function tests whether a phylogenetic tree is binary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.binary(phy)
## S3 method for class 'phylo'
is.binary(phy)
## S3 method for class 'multiPhylo'
is.binary(phy)
## S3 method for class 'tree'
is.binary(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.binary_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code> or <code>"multiPhylo"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test differs whether the tree is rooted or not. An urooted tree is
considered binary if all its nodes are of degree three (i.e., three
edges connect to each node). A rooted tree is considered binary if all
nodes (including the root node) have exactly two descendant nodes, so
that they are of degree three expect the root which is of degree 2.
</p>
<p>The test ignores branch lengths. Consider using <code><a href="#topic+di2multi">di2multi</a></code>
if you want to treat zero-branch lengths as resulting from
multichotomies.
</p>
<p><code>is.binary.tree</code> is deprecated and will be removed soon:
currently it calls <code>is.binary</code>.
</p>


<h3>Value</h3>

<p>a logical vector.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.rooted">is.rooted</a></code>, <code><a href="#topic+is.ultrametric">is.ultrametric</a></code>, <code><a href="#topic+multi2di">multi2di</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.binary(rtree(10))
is.binary(rtree(10, rooted = FALSE))
is.binary(stree(10))
x &lt;- setNames(rmtree(10, 10), LETTERS[1:10])
is.binary(x)
</code></pre>

<hr>
<h2 id='is.compatible'>Check Compatibility of Splits</h2><span id='topic+is.compatible'></span><span id='topic+is.compatible.bitsplits'></span><span id='topic+arecompatible'></span>

<h3>Description</h3>

<p><code>is.compatible</code> is a generic function with a method for the class
<code>"bitsplits"</code>. It checks whether a set of splits is compatible
using the <code>arecompatible</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.compatible(obj)
## S3 method for class 'bitsplits'
is.compatible(obj)
arecompatible(x, y, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.compatible_+3A_obj">obj</code></td>
<td>
<p>an object of class <code>"bitsplits"</code>.</p>
</td></tr>
<tr><td><code id="is.compatible_+3A_x">x</code>, <code id="is.compatible_+3A_y">y</code></td>
<td>
<p>a vector of mode raw.</p>
</td></tr>
<tr><td><code id="is.compatible_+3A_n">n</code></td>
<td>
<p>the number of taxa in the splits.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the splits are compatible, <code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p>Andrei Popescu</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.bitsplits">as.bitsplits</a></code></p>

<hr>
<h2 id='is.monophyletic'>
Is Group Monophyletic
</h2><span id='topic+is.monophyletic'></span>

<h3>Description</h3>

<p>This function tests whether a list of tip labels is monophyletic on a given tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.monophyletic(phy, tips, reroot = !is.rooted(phy), plot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.monophyletic_+3A_phy">phy</code></td>
<td>

<p>a phylogenetic tree description of class <code>"phylo"</code>.
</p>
</td></tr>
<tr><td><code id="is.monophyletic_+3A_tips">tips</code></td>
<td>

<p>a vector of mode numeric or character specifying the tips to be tested.
</p>
</td></tr>
<tr><td><code id="is.monophyletic_+3A_reroot">reroot</code></td>
<td>

<p>a logical. If <code>FALSE</code>, then the input tree is not unrooted before the test.
</p>
</td></tr>
<tr><td><code id="is.monophyletic_+3A_plot">plot</code></td>
<td>

<p>a logical. If <code>TRUE</code>, then the tree is plotted with the specified group <code>tips</code> highlighted.
</p>
</td></tr>
<tr><td><code id="is.monophyletic_+3A_...">...</code></td>
<td>

<p>further arguments passed to <code>plot</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>phy</code> is rooted, the test is done on the rooted tree, otherwise
the tree is first unrooted, then arbitrarily rerooted, in order to be
independent on the current position of the root. That is, the test
asks if <code>tips</code> could be monophyletic given any favourably rooting
of <code>phy</code>.
</p>
<p>If <code>phy</code> is unrooted the test is done on an unrooted tree, unless
<code>reroot = FALSE</code> is specified.
</p>
<p>If tip labels in the list <code>tips</code> are given as characters, they need
to be spelled as in the object <code>phy</code>.
</p>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Johan Nylander <a href="mailto:jnylander@users.sourceforge.net">jnylander@users.sourceforge.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+which.edge">which.edge</a></code>, <code><a href="#topic+drop.tip">drop.tip</a></code>, <code><a href="#topic+mrca">mrca</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## Test one monophyletic and one paraphyletic group on the bird.orders tree
    ## Not run: data("bird.orders")
    ## Not run: is.monophyletic(phy = bird.orders, tips = c("Ciconiiformes", "Gruiformes"))
    ## Not run: is.monophyletic(bird.orders, c("Passeriformes", "Ciconiiformes", "Gruiformes"))
    
</code></pre>

<hr>
<h2 id='is.ultrametric'>Test if a Tree is Ultrametric</h2><span id='topic+is.ultrametric'></span><span id='topic+is.ultrametric.phylo'></span><span id='topic+is.ultrametric.multiPhylo'></span>

<h3>Description</h3>

<p>This function tests whether a tree is ultrametric using the distances
from each tip to the root.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.ultrametric(phy, ...)
## S3 method for class 'phylo'
is.ultrametric(phy, tol = .Machine$double.eps^0.5, option = 1, ...)
## S3 method for class 'multiPhylo'
is.ultrametric(phy, tol = .Machine$double.eps^0.5, option = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.ultrametric_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code> or <code>"multiPhylo"</code>.</p>
</td></tr>
<tr><td><code id="is.ultrametric_+3A_tol">tol</code></td>
<td>
<p>a numeric &gt;= 0, variation below this value are considered
non-significant.</p>
</td></tr>
<tr><td><code id="is.ultrametric_+3A_option">option</code></td>
<td>
<p>an integer (1 or 2; see details).</p>
</td></tr>
<tr><td><code id="is.ultrametric_+3A_...">...</code></td>
<td>
<p>arguments passed among methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test is based on the distances from each tip to the root and a
criterion: if <code>option = 1</code>, the criterion is the scaled range
((max - min/max)), if <code>option = 2</code>, the variance is used (this
was the method used until ape 3.5). The default criterion is invariant
to linear changes of the branch lengths.
</p>


<h3>Value</h3>

<p>a logical vector.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.binary">is.binary</a></code>, <code><a href="base.html#topic+.Machine">.Machine</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.ultrametric(rtree(10))
is.ultrametric(rcoal(10))
</code></pre>

<hr>
<h2 id='kronoviz'>Plot Multiple Chronograms on the Same Scale</h2><span id='topic+kronoviz'></span>

<h3>Description</h3>

<p>The main argument is a list of (rooted) trees which are plotted on the
same scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kronoviz(x, layout = length(x), horiz = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kronoviz_+3A_x">x</code></td>
<td>
<p>a list of (rooted) trees of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="kronoviz_+3A_layout">layout</code></td>
<td>
<p>an integer giving the number of trees plotted
simultaneously; by default all.</p>
</td></tr>
<tr><td><code id="kronoviz_+3A_horiz">horiz</code></td>
<td>
<p>a logical specifying whether the trees should be plotted
rightwards (the default) or upwards.</p>
</td></tr>
<tr><td><code id="kronoviz_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>plot.phylo</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The size of the individual plots is proportional to the size of the
trees.
</p>


<h3>Value</h3>

<p>NULL</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.phylo">plot.phylo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TR &lt;- replicate(10, rcoal(sample(11:20, size = 1)), simplify = FALSE)
kronoviz(TR)
kronoviz(TR, horiz = FALSE, type = "c", show.tip.label = FALSE)
</code></pre>

<hr>
<h2 id='label2table'>Label Management</h2><span id='topic+label2table'></span><span id='topic+stripLabel'></span><span id='topic+abbreviateGenus'></span>

<h3>Description</h3>

<p>These functions work on a vector of character strings storing bi- or trinomial species names, typically &ldquo;Genus_species_subspecies&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label2table(x, sep = NULL, as.is = FALSE)
stripLabel(x, species = FALSE, subsp = TRUE, sep = NULL)
abbreviateGenus(x, genus = TRUE, species = FALSE, sep = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="label2table_+3A_x">x</code></td>
<td>
<p>a vector of mode character.</p>
</td></tr>
<tr><td><code id="label2table_+3A_sep">sep</code></td>
<td>
<p>the separator (a single character) between the taxonomic levels (see details).</p>
</td></tr>
<tr><td><code id="label2table_+3A_as.is">as.is</code></td>
<td>
<p>a logical specifying whether to convert characters into factors (like in <code><a href="utils.html#topic+read.table">read.table</a></code>).</p>
</td></tr>
<tr><td><code id="label2table_+3A_species">species</code>, <code id="label2table_+3A_subsp">subsp</code>, <code id="label2table_+3A_genus">genus</code></td>
<td>
<p>a logical specifying whether the taxonomic level is concerned by the operation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>label2table</code> returns a data frame with three columns named &ldquo;genus&rdquo;, &ldquo;species&rdquo;, and &ldquo;subspecies&rdquo; (with <code>NA</code> if the level is missing).
</p>
<p><code>stripLabel</code> deletes the subspecies names from the input. If <code>species = TRUE</code>, the species names are also removed, thus returning only the genus names.
</p>
<p><code>abbreviateGenus</code> abbreviates the genus names keeping only the first letter. If <code>species = TRUE</code>, the species names are abbreviated.
</p>
<p>By default, these functions try to guess what is the separator between the genus, species and/or subspecies names. If an underscore is present in the input, then this character is assumed to be the separator; otherwise, a space. If this does not work, you can specify <code>sep</code> to its appropriate value.
</p>


<h3>Value</h3>

<p>A vector of mode character or a data frame.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeLabel">makeLabel</a></code>, <code><a href="#topic+makeNodeLabel">makeNodeLabel</a></code>,
<code><a href="#topic+mixedFontLabel">mixedFontLabel</a></code>, <code><a href="#topic+updateLabel">updateLabel</a></code>,
<code><a href="#topic+checkLabel">checkLabel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("Panthera_leo", "Panthera_pardus", "Panthera_onca", "Panthera_uncia",
       "Panthera_tigris_altaica", "Panthera_tigris_amoyensis")
label2table(x)
stripLabel(x)
stripLabel(x, TRUE)
abbreviateGenus(x)
abbreviateGenus(x, species = TRUE)
abbreviateGenus(x, genus = FALSE, species = TRUE)
</code></pre>

<hr>
<h2 id='ladderize'>Ladderize a Tree</h2><span id='topic+ladderize'></span>

<h3>Description</h3>

<p>This function reorganizes the internal structure of the tree to get
the ladderized effect when plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ladderize(phy, right = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ladderize_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="ladderize_+3A_right">right</code></td>
<td>
<p>a logical specifying whether the smallest clade is on the
right-hand side (when the tree is plotted upwards), or the opposite
(if <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.phylo">plot.phylo</a></code>, <code><a href="#topic+reorder.phylo">reorder.phylo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tr &lt;- rcoal(50)
layout(matrix(1:4, 2, 2))
plot(tr, main = "normal")
plot(ladderize(tr), main = "right-ladderized")
plot(ladderize(tr, FALSE), main = "left-ladderized")
layout(matrix(1, 1))
</code></pre>

<hr>
<h2 id='latag2n'>Leading and Trailing Alignment Gaps to N</h2><span id='topic+latag2n'></span>

<h3>Description</h3>

<p>Substitutes leading and trailing alignment gaps in aligned sequences
into <code>N</code> (i.e., A, C, G, or T). The gaps in the middle of the
sequences are left unchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latag2n(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latag2n_+3A_x">x</code></td>
<td>
<p>an object of class <code>"DNAbin"</code> with the aligned sequences.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called by others in <span class="pkg">ape</span> and in <span class="pkg">pegas</span>. It
is documented here in case it needs to be called by other packages.
</p>


<h3>Value</h3>

<p>an object of class <code>"DNAbin"</code>.</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+DNAbin">DNAbin</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.DNAbin(matrix(c("-", "A", "G", "-", "T", "C"), 2, 3))
y &lt;- latag2n(x)
alview(x)
alview(y)
</code></pre>

<hr>
<h2 id='lmorigin'> Multiple regression through the origin </h2><span id='topic+lmorigin'></span><span id='topic+print.lmorigin'></span><span id='topic+lmorigin.ex1'></span><span id='topic+lmorigin.ex2'></span>

<h3>Description</h3>

<p>Function <code><a href="#topic+lmorigin">lmorigin</a></code> computes a multiple linear regression and performs tests of significance of the equation parameters (F-test of R-square and t-tests of regression coefficients) using permutations.
</p>
<p>The regression line can be forced through the origin. Testing the significance in that case requires a special permutation procedure. This option was developed for the analysis of independent contrasts, which requires regression through the origin. A permutation test, described by Legendre &amp; Desdevises (2009), is needed to analyze contrasts that are not normally distributed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmorigin(formula, data, origin=TRUE, nperm=999, method=NULL, silent=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmorigin_+3A_formula">formula</code></td>
<td>
<p> A formula specifying the bivariate model, as in
<code><a href="stats.html#topic+lm">lm</a></code> and <code><a href="stats.html#topic+aov">aov</a></code>. </p>
</td></tr>
<tr><td><code id="lmorigin_+3A_data">data</code></td>
<td>
<p> A data frame containing the two variables specified in the formula. </p>
</td></tr>
<tr><td><code id="lmorigin_+3A_origin">origin</code></td>
<td>
 <p><code>origin = TRUE</code> (default) to compute regression through the origin; <code>origin = FALSE</code> to compute multiple regression with estimation of the intercept. </p>
</td></tr>
<tr><td><code id="lmorigin_+3A_nperm">nperm</code></td>
<td>
<p> Number of permutations for the tests. If <code>nperm =
   0</code>, permutation tests will not be computed. The default value is <code>nperm = 999</code>. For large data files, the permutation test is rather slow since the permutation procedure is not compiled. </p>
</td></tr>
<tr><td><code id="lmorigin_+3A_method">method</code></td>
<td>
 <p><code>method = "raw"</code> computes t-tests of the regression coefficients by permutation of the raw data. <code>method = "residuals"</code> computes t-tests of the regression coefficients by permutation of the residuals of the full model. If <code>method = NULL</code>, permutation of the raw data is used to test the regression coefficients in regression through the origin; permutation of the residuals of the full model is used to test the regression coefficients in ordinary multiple regression. </p>
</td></tr>
<tr><td><code id="lmorigin_+3A_silent">silent</code></td>
<td>
<p> Informative messages and the time to compute the tests will not be written to the <span class="rlang"><b>R</b></span> console if silent=TRUE. Useful when the function is called by a numerical simulation function. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The permutation F-test of R-square is always done by permutation of the raw data. When there is a single explanatory variable, permutation of the raw data is used for the t-test of the single regression coefficient, whatever the method chosen by the user. The rationale is found in Anderson &amp; Legendre (1999).
</p>
<p>The <code>print.lmorigin</code> function prints out the results of the parametric tests (in all cases) and the results of the permutational tests (when nperm &gt; 0).
</p>


<h3>Value</h3>

<table>
<tr><td><code>reg</code></td>
<td>
<p>The regression output object produced by function <code>lm</code>. </p>
</td></tr>
<tr><td><code>p.param.t.2tail</code></td>
<td>
<p>Parametric probabilities for 2-tailed tests of the regression coefficients. </p>
</td></tr>
<tr><td><code>p.param.t.1tail</code></td>
<td>
<p>Parametric probabilities for 1-tailed tests of the regression coefficients. Each test is carried out in the direction of the sign of the coefficient. </p>
</td></tr>
<tr><td><code>p.perm.t.2tail</code></td>
<td>
<p>Permutational probabilities for 2-tailed tests of the regression coefficients. </p>
</td></tr>
<tr><td><code>p.perm.t.1tail</code></td>
<td>
<p>Permutational probabilities for 1-tailed tests of the regression coefficients. Each test is carried out in the direction of the sign of the coefficient. </p>
</td></tr>
<tr><td><code>p.perm.F</code></td>
<td>
<p>Permutational probability for the F-test of R-square. </p>
</td></tr>
<tr><td><code>origin</code></td>
<td>
<p>TRUE is regression through the origin has been computed, FALSE if multiple regression with estimation of the intercept has been used. </p>
</td></tr>
<tr><td><code>nperm</code></td>
<td>
<p>Number of permutations used in the permutation tests. </p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Permutation method for the t-tests of the regression coefficients: <code>method = "raw"</code> or <code>method = "residuals"</code>.  </p>
</td></tr>
<tr><td><code>var.names</code></td>
<td>
<p>Vector containing the names of the variables used in the regression. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The function call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Pierre Legendre, Universite de Montreal </p>


<h3>References</h3>

<p>Anderson, M. J. and Legendre, P. (1999) An empirical comparison of permutation methods for tests of partial regression coefficients in a linear model. <em>Journal of Statistical Computation and Simulation</em>, <b>62</b>, 271&ndash;303.
</p>
<p>Legendre, P. and Desdevises, Y. (2009) Independent contrasts and regression through the origin. <em>Journal of Theoretical Biology</em>, <b>259</b>, 727&ndash;743.
</p>
<p>Sokal, R. R. and Rohlf, F. J. (1995) <em>Biometry - The principles and
practice of statistics in biological research. Third edition.</em> New
York: W. H. Freeman.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1 from Sokal &amp; Rohlf (1995) Table 16.1
## SO2 air pollution in 41 cities of the USA
data(lmorigin.ex1)
out &lt;- lmorigin(SO2 ~ ., data=lmorigin.ex1, origin=FALSE, nperm=99)
out

## Example 2: Contrasts computed on the phylogenetic tree of Lamellodiscus
## parasites. Response variable: non-specificity index (NSI); explanatory
## variable: maximum host size. Data from Table 1 of Legendre &amp; Desdevises
## (2009).
data(lmorigin.ex2)
out &lt;- lmorigin(NSI ~ MaxHostSize, data=lmorigin.ex2, origin=TRUE, nperm=99)
out

## Example 3: random numbers
y &lt;- rnorm(50)
X &lt;- as.data.frame(matrix(rnorm(250),50,5))
out &lt;- lmorigin(y ~ ., data=X, origin=FALSE, nperm=99)
out

</code></pre>

<hr>
<h2 id='LTT'>Theoretical Lineage-Through Time Plots</h2><span id='topic+LTT'></span>

<h3>Description</h3>

<p>This function draws the lineage-through time (LTT) plots predicted
under a speciation-extinction model (aka birth-death model) with
specified values of speciation and extinction rates (which may vary
with time).
</p>
<p>A prediction interval is plotted by default which requires to define a
sample size (100 by default), and different curves can be combined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LTT(birth = 0.1, death = 0, N = 100, Tmax = 50, PI = 95,
    scaled = TRUE, eps = 0.1, add = FALSE, backward = TRUE,
    ltt.style = list("black", 1, 1), pi.style = list("blue", 1, 2), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LTT_+3A_birth">birth</code></td>
<td>
<p>the speciation rate, this may be either a numeric value
or a funtion of time (named <code>t</code> in the code of the function).</p>
</td></tr>
<tr><td><code id="LTT_+3A_death">death</code></td>
<td>
<p>id. for the extinction rate.</p>
</td></tr>
<tr><td><code id="LTT_+3A_n">N</code></td>
<td>
<p>the size of the tree.</p>
</td></tr>
<tr><td><code id="LTT_+3A_tmax">Tmax</code></td>
<td>
<p>the age of the root of the tree.</p>
</td></tr>
<tr><td><code id="LTT_+3A_pi">PI</code></td>
<td>
<p>the percentage value of the prediction interval; set this
value to 0 to not draw this interval.</p>
</td></tr>
<tr><td><code id="LTT_+3A_scaled">scaled</code></td>
<td>
<p>a logical values specifying whether to scale the
<code class="reqn">y</code>-axis between 0 and 1.</p>
</td></tr>
<tr><td><code id="LTT_+3A_eps">eps</code></td>
<td>
<p>a numerical value giving the resolution of the time axis.</p>
</td></tr>
<tr><td><code id="LTT_+3A_add">add</code></td>
<td>
<p>a logical values specifying whether to make a new plot (the
default).</p>
</td></tr>
<tr><td><code id="LTT_+3A_backward">backward</code></td>
<td>
<p>a logical value: should the time axis be traced from
the present (the default), or from the root of the tree?</p>
</td></tr>
<tr><td><code id="LTT_+3A_ltt.style">ltt.style</code></td>
<td>
<p>a list with three elements giving the style of the
LTT curve with, respectively, the colour (<code>"col"</code>), the line
thickness (<code>"lwd"</code>), and the line type (<code>"lty"</code>).</p>
</td></tr>
<tr><td><code id="LTT_+3A_pi.style">pi.style</code></td>
<td>
<p>id. for the prediction interval.</p>
</td></tr>
<tr><td><code id="LTT_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>plot</code> (e.g., <code>log="y"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the moment, this works well when <code>birth</code> and <code>death</code> are
constant. Some improvements are under progress for time-dependent
rates (but see below for an example).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Hallinan, N. (2012) The generalized time variable reconstructed
birth&ndash;death process. <em>Journal of Theoretical Biology</em>,
<b>300</b>, 265&ndash;276.
</p>
<p>Paradis, E. (2011) Time-dependent speciation and extinction from
phylogenies: a least squares approach. <em>Evolution</em>, <b>65</b>,
661&ndash;672.
</p>
<p>Paradis, E. (2015) Random phylogenies and the distribution of
branching times. <em>Journal of Theoretical Biology</em>, <b>387</b>,
39&ndash;45.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ltt.plot">ltt.plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### predicted LTT plot under a Yule model with lambda = 0.1
### and 50 species after 50 units of time...
LTT(N = 50)
### ... and with a birth-death model with the same rate of
### diversification (try with N = 500):
LTT(0.2, 0.1, N = 50, PI = 0, add = TRUE, ltt.style = list("red", 2, 1))
### predictions under different tree sizes:
layout(matrix(1:4, 2, 2, byrow = TRUE))
for (N in c(50, 100, 500, 1000)) {
    LTT(0.2, 0.1, N = N)
    title(paste("N =", N))
}
layout(1)
## Not run: 
### speciation rate decreasing with time
birth.logis &lt;- function(t) 1/(1 + exp(0.02 * t + 4))
LTT(birth.logis)
LTT(birth.logis, 0.05)
LTT(birth.logis, 0.1)

## End(Not run)
</code></pre>

<hr>
<h2 id='ltt.plot'>Lineages Through Time Plot</h2><span id='topic+ltt.plot'></span><span id='topic+ltt.lines'></span><span id='topic+mltt.plot'></span><span id='topic+ltt.coplot'></span><span id='topic+ltt.plot.coords'></span>

<h3>Description</h3>

<p>These functions provide tools for plotting the numbers of lineages
through time from phylogenetic trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ltt.plot(phy, xlab = "Time", ylab = "N",
         backward = TRUE, tol = 1e-6, ...)
ltt.lines(phy, backward = TRUE, tol = 1e-6, ...)
mltt.plot(phy, ..., dcol = TRUE, dlty = FALSE, legend = TRUE,
          xlab = "Time", ylab = "N", log = "", backward = TRUE,
          tol = 1e-6)
ltt.coplot(phy, backward = TRUE, ...)
ltt.plot.coords(phy, backward = TRUE, tol = 1e-6, type = "S")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ltt.plot_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>; this could be an object
of class <code>"multiPhylo"</code> in the case of <code>mltt.plot</code>.</p>
</td></tr>
<tr><td><code id="ltt.plot_+3A_xlab">xlab</code></td>
<td>
<p>a character string (or a variable of mode character)
giving the label for the <code class="reqn">x</code>-axis (default is &quot;Time&quot;).</p>
</td></tr>
<tr><td><code id="ltt.plot_+3A_ylab">ylab</code></td>
<td>
<p>idem for the <code class="reqn">y</code>-axis (default is &quot;N&quot;).</p>
</td></tr>
<tr><td><code id="ltt.plot_+3A_backward">backward</code></td>
<td>
<p>a logical value: should the time axis be traced from
the present (the default), or from the root of the tree?</p>
</td></tr>
<tr><td><code id="ltt.plot_+3A_tol">tol</code></td>
<td>
<p>a numeric value (see details).</p>
</td></tr>
<tr><td><code id="ltt.plot_+3A_...">...</code></td>
<td>
<p>in the cases of <code>ltt.plot()</code>, <code>ltt.lines()</code>,
or <code>ltt.coplot()</code> these are further (graphical) arguments to be
passed to <code>plot()</code>, <code>lines()</code>, or <code>plot.phylo()</code>,
respectively (see details on how to transform the axes); in
the case of <code>mltt.plot()</code> these are additional trees to be plotted
(see details).</p>
</td></tr>
<tr><td><code id="ltt.plot_+3A_dcol">dcol</code></td>
<td>
<p>a logical specifying whether the different curves should
be differentiated with colors (default is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="ltt.plot_+3A_dlty">dlty</code></td>
<td>
<p>a logical specifying whether the different curves should
be differentiated with patterns of dots and dashes (default is
<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="ltt.plot_+3A_legend">legend</code></td>
<td>
<p>a logical specifying whether a legend should be
plotted.</p>
</td></tr>
<tr><td><code id="ltt.plot_+3A_log">log</code></td>
<td>
<p>a character string specifying which axis(es) to be
log-transformed; must be one of the followings: <code>""</code>,
<code>"x"</code>, <code>"y"</code>, or <code>"xy"</code>.</p>
</td></tr>
<tr><td><code id="ltt.plot_+3A_type">type</code></td>
<td>
<p>either <code>"S"</code> or <code>"s"</code>, the preferred type of step function, corresponding
to argument <code>type</code> of base function <code>plot()</code>. See section &quot;Value&quot; below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ltt.plot</code> does a simple lineages through time (LTT)
plot. Additional arguments (<code>...</code>) may be used to change, for
instance, the limits on the axes (with <code>xlim</code> and/or
<code>ylim</code>) or other graphical settings (<code>col</code> for the color,
<code>lwd</code> for the line thickness, <code>lty</code> for the line type may be
useful; see <code><a href="graphics.html#topic+par">par</a></code> for an exhaustive listing of
graphical parameters). The <code class="reqn">y</code>-axis can be log-transformed by
adding the following option: <code>log = "y"</code>.
</p>
<p>The option <code>tol</code> is used as follows: first the most distant tip
from the root is found, then all tips whose distance to the root is
not different from the previous one more than <code>tol</code> are
considered to be contemporaneous with it.
</p>
<p>If the tree is not ultrametric, the plot is done assuming the tips,
except the most distant from the root, represent extinction events. If
a root edge is present, it is taken into account.
</p>
<p><code>ltt.lines</code> adds a LTT curve to an existing plot. Additional
arguments (<code>...</code>) may be used to change the settings of the added
line.
</p>
<p><code>mltt.plot</code> does a multiple LTT plot taking as arguments one or
several trees. These trees may be given as objects of class
<code>"phylo"</code> (single trees) and/or <code>"multiPhylo"</code> (multiple
trees). Any number of objects may be given. This function is mainly
for exploratory analyses with the advantages that the axes are set
properly to view all lines, and the legend is plotted by default. The
plot will certainly make sense if all trees have their
most-distant-from-the-root tips contemporaneous (i.e., trees with only
extinct lineages will not be represented properly). For more flexible
settings of line drawings, it may be better to combine
<code>ltt.plot()</code> with successive calls of <code>ltt.lines()</code> (see
examples).
</p>
<p><code>ltt.coplot</code> is meant to show how to set a tree and a LTT plots
on the same scales. All extra arguments modify only the appearance of
the tree. The code can be easily edited and tailored.
</p>


<h3>Value</h3>

<p><code>ltt.plot.coords</code> returns a two-column matrix with the time
points and the number of lineages, respectively. 
<code>type = "S"</code> returns the number of lineages to the left of (or &quot;up to&quot;) 
the corresponding point in time, while <code>type = "s"</code> returns the number of
lineages to the right of this point (i.e, between that time and the next).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Harvey, P. H., May, R. M. and Nee, S. (1994) Phylogenies without
fossils. <em>Evolution</em>, <b>48</b>, 523&ndash;529.
</p>
<p>Nee, S., Holmes, E. C., Rambaut, A. and Harvey, P. H. (1995) Inferring
population history from molecular phylogenies. <em>Philosophical
Transactions of the Royal Society of London. Series B. Biological
Sciences</em>, <b>349</b>, 25&ndash;31.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kronoviz">kronoviz</a></code>, <code><a href="#topic+skyline">skyline</a></code>, <code><a href="#topic+LTT">LTT</a></code>,
<code><a href="#topic+branching.times">branching.times</a></code>, <code><a href="#topic+birthdeath">birthdeath</a></code>,
<code><a href="#topic+bd.ext">bd.ext</a></code>, <code><a href="#topic+yule.cov">yule.cov</a></code>, <code><a href="#topic+bd.time">bd.time</a></code>;
<code><a href="graphics.html#topic+plot">plot</a></code> for the basic plotting function in R
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bird.families)
opar &lt;- par(mfrow = c(2, 1))
ltt.plot(bird.families)
title("Lineages Through Time Plot of the Bird Families")
ltt.plot(bird.families, log = "y")
title(main = "Lineages Through Time Plot of the Bird Families",
      sub = "(with logarithmic transformation of the y-axis)")
par(opar)

### to plot the tree and the LTT plot together
data(bird.orders)
layout(matrix(1:4, 2, 2))
plot(bird.families, show.tip.label = FALSE)
ltt.plot(bird.families, main = "Bird families")
plot(bird.orders, show.tip.label = FALSE)
ltt.plot(bird.orders, main = "Bird orders")
layout(1)

### better with ltt.coplot():
ltt.coplot(bird.families, show.tip.label = FALSE, x.lim = 27.5)
data(chiroptera)
chiroptera &lt;- compute.brlen(chiroptera)
ltt.coplot(chiroptera, show.tip.label = FALSE, type = "c")

### with extinct lineages and a root edge:
omar &lt;- par("mar")
set.seed(31)
tr &lt;- rlineage(0.2, 0.15)
tr$root.edge &lt;- 5
ltt.coplot(tr, show.tip.label = FALSE, x.lim = 55)
## compare with:
## ltt.coplot(drop.fossil(tr), show.tip.label = FALSE)
layout(1)
par(mar = omar)

mltt.plot(bird.families, bird.orders)
### Generates 10 random trees with 23 tips:
TR &lt;- replicate(10, rcoal(23), FALSE)
### Give names to each tree:
names(TR) &lt;- paste("random tree", 1:10)
### And specify the class of the list so that mltt.plot()
### does not trash it!
class(TR) &lt;- "multiPhylo"
mltt.plot(TR, bird.orders)
### And now for something (not so) completely different:
ltt.plot(bird.orders, lwd = 2)
for (i in 1:10) ltt.lines(TR[[i]], lty = 2)
legend(-20, 10, lwd = c(2, 1), lty = c(1, 2), bty = "n",
       legend = c("Bird orders", "Random (coalescent) trees"))
</code></pre>

<hr>
<h2 id='makeLabel'>Label Management</h2><span id='topic+makeLabel'></span><span id='topic+makeLabel.character'></span><span id='topic+makeLabel.phylo'></span><span id='topic+makeLabel.multiPhylo'></span><span id='topic+makeLabel.DNAbin'></span>

<h3>Description</h3>

<p>This is a generic function with methods for character vectors, trees
of class <code>"phylo"</code>, lists of trees of class <code>"multiPhylo"</code>,
and DNA sequences of class <code>"DNAbin"</code>. All options for the class
character may be used in the other methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeLabel(x, ...)
## S3 method for class 'character'
makeLabel(x, len = 99, space = "_", make.unique = TRUE,
          illegal = "():;,[]", quote = FALSE, ...)
## S3 method for class 'phylo'
makeLabel(x, tips = TRUE, nodes = TRUE, ...)
## S3 method for class 'multiPhylo'
makeLabel(x, tips = TRUE, nodes = TRUE, ...)
## S3 method for class 'DNAbin'
makeLabel(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeLabel_+3A_x">x</code></td>
<td>
<p>a vector of mode character or an object for which labels are
to be changed.</p>
</td></tr>
<tr><td><code id="makeLabel_+3A_len">len</code></td>
<td>
<p>the maximum length of the labels: those longer than &lsquo;len&rsquo;
will be truncated.</p>
</td></tr>
<tr><td><code id="makeLabel_+3A_space">space</code></td>
<td>
<p>the character to replace spaces, tabulations, and
linebreaks.</p>
</td></tr>
<tr><td><code id="makeLabel_+3A_make.unique">make.unique</code></td>
<td>
<p>a logical specifying whether duplicate labels
should be made unique by appending numerals; <code>TRUE</code> by
default.</p>
</td></tr>
<tr><td><code id="makeLabel_+3A_illegal">illegal</code></td>
<td>
<p>a string specifying the characters to be deleted.</p>
</td></tr>
<tr><td><code id="makeLabel_+3A_quote">quote</code></td>
<td>
<p>a logical specifying whether to quote the labels;
<code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="makeLabel_+3A_tips">tips</code></td>
<td>
<p>a logical specifying whether tip labels are to be
modified; <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="makeLabel_+3A_nodes">nodes</code></td>
<td>
<p>a logical specifying whether node labels are to be
modified; <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="makeLabel_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The option <code>make.unique</code> does not work exactly in the same way
then the function of the same name: numbers are suffixed to all labels
that are identical (without separator). See the examples.
</p>
<p>If there are 10&ndash;99 identical labels, the labels returned are &quot;xxx01&quot;,
&quot;xxx02&quot;, etc, or &quot;xxx001&quot;, &quot;xxx002&quot;, etc, if they are 100&ndash;999, and so
on. The number of digits added preserves the option &lsquo;len&rsquo;.
</p>
<p>The default for &lsquo;len&rsquo; makes labels short enough to be read by
PhyML. Clustal accepts labels up to 30 character long.
</p>


<h3>Value</h3>

<p>An object of the appropriate class.
</p>


<h3>Note</h3>

<p>The current version does not perform well when trying to make very
short unique labels (e.g., less than 5 character long).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeNodeLabel">makeNodeLabel</a></code>, <code><a href="base.html#topic+make.unique">make.unique</a></code>,
<code><a href="base.html#topic+make.names">make.names</a></code>, <code><a href="base.html#topic+abbreviate">abbreviate</a></code>,
<code><a href="#topic+mixedFontLabel">mixedFontLabel</a></code>, <code><a href="#topic+label2table">label2table</a></code>,
<code><a href="#topic+updateLabel">updateLabel</a></code>, <code><a href="#topic+checkLabel">checkLabel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rep("a", 3)
makeLabel(x)
make.unique(x) # &lt;- from R's base
x &lt;- rep("aaaaa", 2)
makeLabel(x, len = 3) # made unique and of length 3
makeLabel(x, len = 3, make.unique = FALSE)
</code></pre>

<hr>
<h2 id='makeNodeLabel'>Makes Node Labels</h2><span id='topic+makeNodeLabel'></span><span id='topic+makeNodeLabel.phylo'></span><span id='topic+makeNodeLabel.multiPhylo'></span>

<h3>Description</h3>

<p>This function makes node labels in a tree in a flexible way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeNodeLabel(phy, ...)
## S3 method for class 'phylo'
makeNodeLabel(phy, method = "number",
                      prefix = "Node", nodeList = list(), ...)
## S3 method for class 'multiPhylo'
makeNodeLabel(phy, method = "number",
                      prefix = "Node", nodeList = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeNodeLabel_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="makeNodeLabel_+3A_method">method</code></td>
<td>
<p>a character string giving the method used to create the
labels. Three choices are possible: <code>"number"</code> (the default),
<code>"md5sum"</code>, and <code>"user"</code>, or any unambiguous abbreviation
of these.</p>
</td></tr>
<tr><td><code id="makeNodeLabel_+3A_prefix">prefix</code></td>
<td>
<p>the prefix used if <code>method = "number"</code>.</p>
</td></tr>
<tr><td><code id="makeNodeLabel_+3A_nodelist">nodeList</code></td>
<td>
<p>a named list specifying how nodes are names if
<code>method = "user"</code> (see details and examples).</p>
</td></tr>
<tr><td><code id="makeNodeLabel_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>grep</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The three methods are described below:
</p>

<ul>
<li><p> &ldquo;number&rdquo;! The labels are created with 1, 2, ... prefixed
with the argument <code>prefix</code>; thus the default is to have
Node1, Node2, ... Set <code>prefix = ""</code> to have only numbers.
</p>
</li>
<li><p> &ldquo;md5sum&rdquo;: For each node, the labels of the tips descendant
from this node are extracted, sorted alphabetically, and written
into a temporary file, then the md5sum of this file is extracted
and used as label. This results in a 32-character string which is
unique (even accross trees) for a given set of tip labels.
</p>
</li>
<li><p> &ldquo;user&rdquo;: the argument <code>nodeList</code> must be a list with
names, the latter will be used as node labels. For each element of
<code>nodeList</code>, the tip labels of the tree are searched for
patterns present in this element: this is done using
<code><a href="base.html#topic+grep">grep</a></code>. Then the most recent common ancestor of
the matching tips is given the corresponding names as labels. This
is repeated for each element of <code>nodeList</code>.
</p>
</li></ul>

<p>The method <code>"user"</code> can be used in combination with either of the
two others (see examples). Note that this method only modifies the
specified node labels (so that if the other nodes have already labels
they are not modified) while the two others change all labels.
</p>


<h3>Value</h3>

<p>an object of class <code>"phylo"</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeLabel">makeLabel</a></code>, <code><a href="base.html#topic+grep">grep</a></code>,
<code><a href="#topic+mixedFontLabel">mixedFontLabel</a></code>, <code><a href="#topic+label2table">label2table</a></code>,
<code><a href="#topic+checkLabel">checkLabel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tr &lt;-
"((Pan_paniscus,Pan_troglodytes),((Homo_sapiens,Homo_erectus),Homo_abilis));"
tr &lt;- read.tree(text = tr)
tr &lt;- makeNodeLabel(tr, "u", nodeList = list(Pan = "Pan", Homo = "Homo"))
plot(tr, show.node.label = TRUE)
### does not erase the previous node labels:
tr &lt;- makeNodeLabel(tr, "u", nodeList = list(Hominid = c("Pan","Homo")))
plot(tr, show.node.label = TRUE)
### the two previous commands could be combined:
L &lt;- list(Pan = "Pan", Homo = "Homo", Hominid = c("Pan","Homo"))
tr &lt;- makeNodeLabel(tr, "u", nodeList = L)
### combining different methods:
tr &lt;- makeNodeLabel(tr, c("n", "u"), prefix = "#", nodeList = list(Hominid = c("Pan","Homo")))
plot(tr, show.node.label = TRUE)
</code></pre>

<hr>
<h2 id='mantel.test'>Mantel Test for Similarity of Two Matrices</h2><span id='topic+mantel.test'></span>

<h3>Description</h3>

<p>This function computes Mantel's permutation test for similarity of two
matrices. It permutes the rows and columns of the second matrix
randomly and calculates a <code class="reqn">Z</code>-statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mantel.test(m1, m2, nperm = 999, graph = FALSE,
            alternative = "two.sided",  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mantel.test_+3A_m1">m1</code></td>
<td>
<p>a numeric matrix giving a measure of pairwise distances,
correlations, or similarities among observations.</p>
</td></tr>
<tr><td><code id="mantel.test_+3A_m2">m2</code></td>
<td>
<p>a second numeric matrix giving another measure of pairwise
distances, correlations, or similarities among observations.</p>
</td></tr>
<tr><td><code id="mantel.test_+3A_nperm">nperm</code></td>
<td>
<p>the number of times to permute the data.</p>
</td></tr>
<tr><td><code id="mantel.test_+3A_graph">graph</code></td>
<td>
<p>a logical indicating whether to produce a summary graph
(by default the graph is not plotted).</p>
</td></tr>
<tr><td><code id="mantel.test_+3A_alternative">alternative</code></td>
<td>
<p>a character string defining the alternative
hypothesis:  <code>"two.sided"</code> (default),  <code>"less"</code>,
<code>"greater"</code>, or any unambiguous abbreviation of these.</p>
</td></tr>
<tr><td><code id="mantel.test_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>plot()</code> (to add a
title, change the axis labels, and so on).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates a <code class="reqn">Z</code>-statistic for the Mantel test, equal to
the sum of the  pairwise product of the lower triangles of the
permuted matrices, for each permutation of rows and columns. It
compares the permuted distribution with the <code class="reqn">Z</code>-statistic observed
for the actual data.
</p>
<p>The present implementation can analyse symmetric as well as (since
version 5.1 of <span class="pkg">ape</span>) asymmetric matrices (see Mantel 1967,
Sects. 4 and 5). The diagonals of both matrices are ignored.
</p>
<p>If <code>graph = TRUE</code>, the functions plots the density estimate of
the permutation distribution along with the observed <code class="reqn">Z</code>-statistic
as a vertical line.
</p>
<p>The <code>...</code> argument allows the user to give further options to
the <code>plot</code> function: the title main be changed with <code>main=</code>,
the axis labels with <code>xlab =</code>, and <code>ylab =</code>, and so on.
</p>


<h3>Value</h3>

<table>
<tr><td><code>z.stat</code></td>
<td>
<p>the <code class="reqn">Z</code>-statistic (sum of rows*columns of lower
triangle) of the data matrices.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p><code class="reqn">P</code>-value (quantile of the observed <code class="reqn">Z</code>-statistic in
the permutation distribution).</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>the alternative hypothesis.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Original code in S by Ben Bolker, ported to <span class="rlang"><b>R</b></span> by Julien Claude
</p>


<h3>References</h3>

<p>Mantel, N. (1967) The detection of disease clustering and a
generalized regression approach. <em>Cancer Research</em>, <b>27</b>,
209&ndash;220.
</p>
<p>Manly, B. F. J. (1986) <em>Multivariate statistical methods: a primer.</em>
London: Chapman &amp; Hall.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q1 &lt;- matrix(runif(36), nrow = 6)
q2 &lt;- matrix(runif(36), nrow = 6)
diag(q1) &lt;- diag(q2) &lt;- 0
mantel.test(q1, q2, graph = TRUE,
            main = "Mantel test: a random example with 6 X 6 matrices
representing asymmetric relationships",
            xlab = "z-statistic", ylab = "Density",
            sub = "The vertical line shows the observed z-statistic")
</code></pre>

<hr>
<h2 id='mat3'>Three Matrices</h2><span id='topic+mat3'></span>

<h3>Description</h3>

<p>Three matrices respectively representing Serological (asymmetric),
DNA hybridization (asymmetric) and Anatomical (symmetric) distances
among 9 families.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mat3)
</code></pre>


<h3>Format</h3>

<p>A data frame with 27 observations and 9 variables.
</p>


<h3>Source</h3>

<p>Lapointe, F.-J., J. A. W. Kirsch and J. M. Hutcheon. 1999. Total
evidence, consensus, and bat phylogeny: a distance-based
approach. Molecular Phylogenetics and Evolution 11: 55-66.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat5Mrand">mat5Mrand</a></code>, <code><a href="#topic+mat5M3ID">mat5M3ID</a></code>
</p>

<hr>
<h2 id='mat5M3ID'>Five Trees</h2><span id='topic+mat5M3ID'></span>

<h3>Description</h3>

<p>Three partly similar trees, two independent trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mat5M3ID)
</code></pre>


<h3>Format</h3>

<p>A data frame with 250 observations and 50 variables.
</p>


<h3>Source</h3>

<p>Data provided by V. Campbell.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat5Mrand">mat5Mrand</a></code>, <code><a href="#topic+mat3">mat3</a></code>
</p>

<hr>
<h2 id='mat5Mrand'>Five Independent Trees</h2><span id='topic+mat5Mrand'></span>

<h3>Description</h3>

<p>Five independent additive trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mat5Mrand)
</code></pre>


<h3>Format</h3>

<p>A data frame with 250 observations and 50 variables.
</p>


<h3>Source</h3>

<p>Data provided by V. Campbell.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat5M3ID">mat5M3ID</a></code>, <code><a href="#topic+mat3">mat3</a></code>
</p>

<hr>
<h2 id='matexpo'>Matrix Exponential</h2><span id='topic+matexpo'></span>

<h3>Description</h3>

<p>This function computes the exponential of a square matrix using a
spectral decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matexpo(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matexpo_+3A_x">x</code></td>
<td>
<p>a square matrix of mode numeric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric matrix of the same dimensions than &lsquo;x&rsquo;.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>Examples</h3>

<pre><code class='language-R'>### a simple rate matrix:
m &lt;- matrix(0.1, 4, 4)
diag(m) &lt;- -0.3
### towards equilibrium:
for (t in c(1, 5, 10, 50)) print(matexpo(m*t))
</code></pre>

<hr>
<h2 id='mcconwaysims.test'>McConway-Sims Test of Homogeneous Diversification</h2><span id='topic+mcconwaysims.test'></span>

<h3>Description</h3>

<p>This function performs the McConway&ndash;Sims test that a trait or
variable does not affect diversification rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcconwaysims.test(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcconwaysims.test_+3A_x">x</code></td>
<td>
<p>a matrix or a data frame with at least two columns: the first
one gives the number of species in clades with a trait supposed to
increase or decrease diversification rate, and the second one the number of
species in the sister-clades without the trait. Each
row represents a pair of sister-clades.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The McConway&ndash;Sims test compares a series of sister-clades where one
of the two is characterized by a trait supposed to affect
diversification rate. The null hypothesis is that the trait does not
affect diversification. The alternative hypothesis is that
diversification rate is increased or decreased by the trait (by
contrast to the Slowinski&ndash;Guyer test). The test is a likelihood-ratio
of a null Yule model and an alternative model with two parameters.
</p>


<h3>Value</h3>

<p>a data frame with the <code class="reqn">\chi^2</code>, the number of degrees of
freedom, and the <em>P</em>-value.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>McConway, K. J. and Sims, H. J. (2004) A likelihood-based method for
testing for nonstochastic variation of diversification rates in
phylogenies. <em>Evolution</em>, <b>58</b>, 12&ndash;23.
</p>
<p>Paradis, E. (2012) Shift in diversification in sister-clade
comparisons: a more powerful test. <em>Evolution</em>, <b>66</b>,
288&ndash;295.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+balance">balance</a></code>, <code><a href="#topic+slowinskiguyer.test">slowinskiguyer.test</a></code>,
<code>rc</code> in <span class="pkg">geiger</span>, <code>shift.test</code> in <span class="pkg">apTreeshape</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### simulate 10 clades with lambda = 0.1 and mu = 0.09:
n0 &lt;- replicate(10, balance(rbdtree(.1, .09, Tmax = 35))[1])
### simulate 10 clades with lambda = 0.15 and mu = 0.1:
n1 &lt;- replicate(10, balance(rbdtree(.15, .1, Tmax = 35))[1])
x &lt;- cbind(n1, n0)
mcconwaysims.test(x)
slowinskiguyer.test(x)
richness.yule.test(x, 35)
</code></pre>

<hr>
<h2 id='mcmc.popsize'>Reversible Jump MCMC to Infer Demographic History</h2><span id='topic+mcmc.popsize'></span><span id='topic+extract.popsize'></span><span id='topic+plot.popsize'></span><span id='topic+lines.popsize'></span>

<h3>Description</h3>

<p>These functions implement a reversible jump MCMC framework to infer the demographic history,
as well as corresponding confidence bands,
from a genealogical tree. The computed demographic history is a continous
and smooth function in time.
<code>mcmc.popsize</code> runs the actual MCMC chain and outputs information about the
sampling steps, <code>extract.popsize</code> generates from this MCMC
output a table of population size in time, and  <code>plot.popsize</code> and <code>lines.popsize</code>
provide utility functions to plot the corresponding demographic functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc.popsize(tree,nstep, thinning=1, burn.in=0,progress.bar=TRUE,
    method.prior.changepoints=c("hierarchical", "fixed.lambda"), max.nodes=30,
   lambda=0.5, gamma.shape=0.5, gamma.scale=2,
    method.prior.heights=c("skyline", "constant", "custom"),
    prior.height.mean,
    prior.height.var)
extract.popsize(mcmc.out, credible.interval=0.95, time.points=200, thinning=1, burn.in=0)
## S3 method for class 'popsize'
plot(x, show.median=TRUE, show.years=FALSE,
             subst.rate, present.year, xlab = NULL,
             ylab = "Effective population size", log = "y", ...)
## S3 method for class 'popsize'
lines(x, show.median=TRUE,show.years=FALSE, subst.rate, present.year, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc.popsize_+3A_tree">tree</code></td>
<td>
<p>Either an ultrametric tree (i.e. an object of class <code>"phylo"</code>),
or coalescent intervals (i.e. an object of class <code>"coalescentIntervals"</code>). </p>
</td></tr>
<tr><td><code id="mcmc.popsize_+3A_nstep">nstep</code></td>
<td>
<p>Number of MCMC steps, i.e. length of the Markov chain (suggested value: 10,000-50,000).</p>
</td></tr>
<tr><td><code id="mcmc.popsize_+3A_thinning">thinning</code></td>
<td>
<p>Thinning factor (suggest value: 10-100).</p>
</td></tr>
<tr><td><code id="mcmc.popsize_+3A_burn.in">burn.in</code></td>
<td>
<p>Number of steps dropped from the chain to allow for a burn-in phase (suggest value: 1000).</p>
</td></tr>
<tr><td><code id="mcmc.popsize_+3A_progress.bar">progress.bar</code></td>
<td>
<p>Show progress bar during the MCMC run.</p>
</td></tr>
<tr><td><code id="mcmc.popsize_+3A_method.prior.changepoints">method.prior.changepoints</code></td>
<td>
<p>If <code>hierarchical</code>is chosen (the default) then the smoothing parameter lambda is drawn from
a gamma distribution with some specified shape and scale parameters.
Alternatively, for <code>fixed.lambda</code> the value of lambda is   a given constant.
</p>
</td></tr>
<tr><td><code id="mcmc.popsize_+3A_max.nodes">max.nodes</code></td>
<td>
<p>Upper limit for the number of internal nodes of the approximating spline (default: 30).</p>
</td></tr>
<tr><td><code id="mcmc.popsize_+3A_lambda">lambda</code></td>
<td>
<p>Smoothing parameter. For <code>method="fixed.lambda"</code> the specifed value of lambda determines
the mean of the prior distribution   for the number of internal nodes of the approximating
spline for the demographic function (suggested value: 0.1-1.0).</p>
</td></tr>
<tr><td><code id="mcmc.popsize_+3A_gamma.shape">gamma.shape</code></td>
<td>
<p>Shape parameter of the gamma function from which <code>lambda</code> is drawn for
<code>method="hierarchical"</code>.</p>
</td></tr>
<tr><td><code id="mcmc.popsize_+3A_gamma.scale">gamma.scale</code></td>
<td>
<p>Scale parameter of the gamma function from which <code>lambda</code> is drawn for
<code>method="hierarchical"</code>.</p>
</td></tr>
<tr><td><code id="mcmc.popsize_+3A_method.prior.heights">method.prior.heights</code></td>
<td>
<p>Determines the prior for the heights of the change points.
If <code>custom</code> is chosen then two functions describing the mean and variance
of the heigths in depence of time have to be specified (via <code>prior.height.mean</code>
and <code>prior.height.var</code> options).  Alternatively, two built-in priors are available:
<code>constant</code> assumes constant population size and variance determined by Felsenstein
(1992), and <code>skyline</code> assumes a skyline plot (see Opgen-Rhein et al. 2004 for
more details).</p>
</td></tr>
<tr><td><code id="mcmc.popsize_+3A_prior.height.mean">prior.height.mean</code></td>
<td>
<p>Function describing the mean of the prior distribution for the heights
(only used if <code>method.prior.heights = custom</code>).</p>
</td></tr>
<tr><td><code id="mcmc.popsize_+3A_prior.height.var">prior.height.var</code></td>
<td>
<p>Function describing the variance of the prior distribution for the heights
(only used if <code>method.prior.heights = custom</code>).</p>
</td></tr>
<tr><td><code id="mcmc.popsize_+3A_mcmc.out">mcmc.out</code></td>
<td>
<p>Output from <code>mcmc.popsize</code> - this is needed as input for <code>extract.popsize</code>.</p>
</td></tr>
<tr><td><code id="mcmc.popsize_+3A_credible.interval">credible.interval</code></td>
<td>
<p>Probability mass of the confidence band (default: 0.95).</p>
</td></tr>
<tr><td><code id="mcmc.popsize_+3A_time.points">time.points</code></td>
<td>
<p>Number of discrete time points in the table output by <code>extract.popsize</code>.</p>
</td></tr>
<tr><td><code id="mcmc.popsize_+3A_x">x</code></td>
<td>
<p>Table with population size versus time, as computed by <code>extract.popsize</code>. </p>
</td></tr>
<tr><td><code id="mcmc.popsize_+3A_show.median">show.median</code></td>
<td>
<p>Plot median rather than mean as point estimate for demographic function (default: TRUE).</p>
</td></tr>
<tr><td><code id="mcmc.popsize_+3A_show.years">show.years</code></td>
<td>
<p>Option that determines whether the time is plotted in units of
of substitutions (default) or in years (requires specification of substution rate
and year of present).</p>
</td></tr>
<tr><td><code id="mcmc.popsize_+3A_subst.rate">subst.rate</code></td>
<td>
<p>Substitution rate (see option show.years).</p>
</td></tr>
<tr><td><code id="mcmc.popsize_+3A_present.year">present.year</code></td>
<td>
<p>Present year (see option show.years).</p>
</td></tr>
<tr><td><code id="mcmc.popsize_+3A_xlab">xlab</code></td>
<td>
<p>label on the x-axis (depends on the value of
<code>show.years</code>).</p>
</td></tr>
<tr><td><code id="mcmc.popsize_+3A_ylab">ylab</code></td>
<td>
<p>label on the y-axis.</p>
</td></tr>
<tr><td><code id="mcmc.popsize_+3A_log">log</code></td>
<td>
<p>log-transformation of axes; by default, the y-axis is
log-transformed.</p>
</td></tr>
<tr><td><code id="mcmc.popsize_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed on  to <code>plot</code> or <code>lines</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please refer to Opgen-Rhein et al. (2005) for methodological details, and the help page of
<code><a href="#topic+skyline">skyline</a></code> for information on a related approach.
</p>


<h3>Author(s)</h3>

<p>Rainer Opgen-Rhein and Korbinian Strimmer. Parts of the rjMCMC
sampling procedure are adapted from <span class="rlang"><b>R</b></span> code by Karl Broman.
</p>


<h3>References</h3>

<p>Opgen-Rhein, R., Fahrmeir, L. and Strimmer, K. 2005. Inference of
demographic history from genealogical trees using reversible jump
Markov chain Monte Carlo. <em>BMC Evolutionary Biology</em>, <b>5</b>,
6.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+skyline">skyline</a></code> and <code><a href="#topic+skylineplot">skylineplot</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'># get tree
data("hivtree.newick") # example tree in NH format
tree.hiv &lt;- read.tree(text = hivtree.newick) # load tree

# run mcmc chain
mcmc.out &lt;- mcmc.popsize(tree.hiv, nstep=100, thinning=1, burn.in=0,progress.bar=FALSE) # toy run
#mcmc.out &lt;- mcmc.popsize(tree.hiv, nstep=10000, thinning=5, burn.in=500) # remove comments!!

# make list of population size versus time
popsize  &lt;- extract.popsize(mcmc.out)

# plot and compare with skyline plot
sk &lt;- skyline(tree.hiv)
plot(sk, lwd=1, lty=3, show.years=TRUE, subst.rate=0.0023, present.year = 1997)
lines(popsize, show.years=TRUE, subst.rate=0.0023, present.year = 1997)
</code></pre>

<hr>
<h2 id='mixedFontLabel'>Mixed Font Labels for Plotting</h2><span id='topic+mixedFontLabel'></span>

<h3>Description</h3>

<p>This function helps to format labels with bits of text in different
font shapes (italics, bold, or bolditalics) and different
separators. The output is intended to be used for plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixedFontLabel(..., sep = " ", italic = NULL, bold = NULL,
               parenthesis = NULL,
               always.upright = c("sp.", "spp.", "ssp."))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixedFontLabel_+3A_...">...</code></td>
<td>
<p>vectors of mode character to be formatted. They may be
of different lengths in which case the shortest ones are
recycled.</p>
</td></tr>
<tr><td><code id="mixedFontLabel_+3A_sep">sep</code></td>
<td>
<p>a vector of mode character giving the separators to be
printed between the elements in <code>...</code>.</p>
</td></tr>
<tr><td><code id="mixedFontLabel_+3A_italic">italic</code></td>
<td>
<p>a vector of integers specifying the elements in
<code>...</code> to be printed in italics.</p>
</td></tr>
<tr><td><code id="mixedFontLabel_+3A_bold">bold</code></td>
<td>
<p>id. in boldface.</p>
</td></tr>
<tr><td><code id="mixedFontLabel_+3A_parenthesis">parenthesis</code></td>
<td>
<p>id. within parentheses.</p>
</td></tr>
<tr><td><code id="mixedFontLabel_+3A_always.upright">always.upright</code></td>
<td>
<p>of vector of mode character giving the strings
to not print in italics. Use <code>always.upright = ""</code> to cancel
this option.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The idea is to have different bits of text in different vectors that
are put together to make a vector of <span class="rlang"><b>R</b></span> expressions. This vector is
interpreted by graphical functions to format the text. A simple use
may be <code>mixedFontLabel(genus, species, italic = 1:2)</code>, but it is
more interesting when mixing fonts (see examples).
</p>
<p>To have an element in bolditalics, its number must given in both
<code>italic</code> and <code>bold</code>.
</p>
<p>The vector returned by this function may be assigned as the
<code>tip.label</code> element of a tree of class <code>"phylo"</code>, or even as
its <code>node.label</code> element.
</p>


<h3>Value</h3>

<p>A vector of mode expression.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeLabel">makeLabel</a></code>, <code><a href="#topic+makeNodeLabel">makeNodeLabel</a></code>,
<code><a href="#topic+label2table">label2table</a></code>, <code><a href="#topic+updateLabel">updateLabel</a></code>,
<code><a href="#topic+checkLabel">checkLabel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tr &lt;- read.tree(text = "((a,(b,c)),d);")
genus &lt;- c("Gorilla", "Pan", "Homo", "Pongo")
species &lt;- c("gorilla", "spp.", "sapiens", "pygmaeus")
geo &lt;- c("Africa", "Africa", "World", "Asia")
tr$tip.label &lt;- mixedFontLabel(genus, species, geo, italic = 1:2,
  parenthesis = 3)
layout(matrix(c(1, 2), 2))
plot(tr)
tr$tip.label &lt;- mixedFontLabel(genus, species, geo, sep = c(" ", " | "),
  italic = 1:2, bold = 3)
plot(tr)
layout(1)
</code></pre>

<hr>
<h2 id='Moran.I'>Moran's I Autocorrelation Index</h2><span id='topic+Moran.I'></span>

<h3>Description</h3>

<p>This function computes Moran's I autocorrelation coefficient of
<code>x</code> giving a matrix of weights using the method described by
Gittleman and Kot (1990).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Moran.I(x, weight, scaled = FALSE, na.rm = FALSE,
          alternative = "two.sided")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Moran.I_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="Moran.I_+3A_weight">weight</code></td>
<td>
<p>a matrix of weights.</p>
</td></tr>
<tr><td><code id="Moran.I_+3A_scaled">scaled</code></td>
<td>
<p>a logical indicating whether the coefficient should be
scaled so that it varies between -1 and +1 (default to
<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="Moran.I_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether missing values should be
removed.</p>
</td></tr>
<tr><td><code id="Moran.I_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative
hypothesis that is tested against the null hypothesis of no
phylogenetic correlation; must be of one &quot;two.sided&quot;, &quot;less&quot;, or
&quot;greater&quot;, or any unambiguous abbrevation of these.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix <code>weight</code> is used as &ldquo;neighbourhood&rdquo; weights, and
Moran's I coefficient is computed using the formula:
</p>
<p style="text-align: center;"><code class="reqn">I = \frac{n}{S_0} \frac{\sum_{i=1}^n\sum_{j=1}^n w_{i,j}(y_i -
      \overline{y})(y_j - \overline{y})}{\sum_{i=1}^n {(y_i -
	\overline{y})}^2}</code>
</p>

<p>with
</p>

<ul>
<li> <p><code class="reqn">y_i</code> = observations
</p>
</li>
<li> <p><code class="reqn">w_{i,j}</code> = distance weight
</p>
</li>
<li> <p><code class="reqn">n</code> = number of observations
</p>
</li>
<li> <p><code class="reqn">S_0</code> = <code class="reqn">\sum_{i=1}^n\sum_{j=1}^n wij</code>
</p>
</li></ul>

<p>The null hypothesis of no phylogenetic correlation is tested assuming
normality of I under this null hypothesis. If the observed value
of I is significantly greater than the expected value, then the values
of <code>x</code> are positively autocorrelated, whereas if Iobserved &lt;
Iexpected, this will indicate negative autocorrelation.
</p>


<h3>Value</h3>

<p>A list containing the elements:
</p>
<table>
<tr><td><code>observed</code></td>
<td>
<p>the computed Moran's I.</p>
</td></tr>
<tr><td><code>expected</code></td>
<td>
<p>the expected value of I under the null hypothesis.</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>the standard deviation of I under the null hypothesis.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the P-value of the test of the null hypothesis against
the alternative hypothesis specified in <code>alternative</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Julien Dutheil <a href="mailto:dutheil@evolbio.mpg.de">dutheil@evolbio.mpg.de</a> and
Emmanuel Paradis</p>


<h3>References</h3>

<p>Gittleman, J. L. and Kot, M. (1990) Adaptation: statistics and a null
model for estimating phylogenetic effects. <em>Systematic Zoology</em>,
<b>39</b>, 227&ndash;241.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+weight.taxo">weight.taxo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>tr &lt;- rtree(30)
x &lt;- rnorm(30)
## weights w[i,j] = 1/d[i,j]:
w &lt;- 1/cophenetic(tr)
## set the diagonal w[i,i] = 0 (instead of Inf...):
diag(w) &lt;- 0
Moran.I(x, w)
Moran.I(x, w, alt = "l")
Moran.I(x, w, alt = "g")
Moran.I(x, w, scaled = TRUE) # usualy the same
</code></pre>

<hr>
<h2 id='MPR'>Most Parsimonious Reconstruction</h2><span id='topic+MPR'></span>

<h3>Description</h3>

<p>This function does ancestral character reconstruction by parsimony as
described in Hanazawa et al. (1995) and modified by Narushima and
Hanazawa (1997).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MPR(x, phy, outgroup)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MPR_+3A_x">x</code></td>
<td>
<p>a vector of integers.</p>
</td></tr>
<tr><td><code id="MPR_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>; the tree must be
unrooted and fully dichotomous.</p>
</td></tr>
<tr><td><code id="MPR_+3A_outgroup">outgroup</code></td>
<td>
<p>an integer or a character string giving the tip of
<code>phy</code> used as outgroup.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hanazawa et al. (1995) and Narushima and Hanazawa (1997) used Farris's
(1970) and Swofford and Maddison's (1987) framework to reconstruct
ancestral states using parsimony. The character is assumed to take
integer values. The algorithm finds the sets of values for each node
as intervals with lower and upper values.
</p>
<p>It is recommended to root the tree with the outgroup before the
analysis, so plotting the values with <code><a href="#topic+nodelabels">nodelabels</a></code> is
simple.
</p>


<h3>Value</h3>

<p>a matrix of integers with two columns named &ldquo;lower&rdquo; and &ldquo;upper&rdquo;
giving the lower and upper values of the reconstructed sets for each
node.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Farris, J. M. (1970) Methods for computing Wagner trees.
<em>Systematic Zoology</em>, <b>19</b>, 83&ndash;92.
</p>
<p>Hanazawa, M., Narushima, H. and Minaka, N. (1995) Generating most
parsimonious reconstructions on a tree: a generalization of the
Farris&ndash;Swofford&ndash;Maddison method. <em>Discrete Applied
Mathematics</em>, <b>56</b>, 245&ndash;265.
</p>
<p>Narushima, H. and Hanazawa, M. (1997) A more efficient algorithm for
MPR problems in phylogeny. <em>Discrete Applied Mathematics</em>,
<b>80</b>, 231&ndash;238.
</p>
<p>Swofford, D. L. and Maddison, W. P. (1987) Reconstructing ancestral
character states under Wagner parsimony. <em>Mathematical
Biosciences</em>, <b>87</b>, 199&ndash;229.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ace">ace</a></code>, <code><a href="#topic+root">root</a></code>, <code><a href="#topic+nodelabels">nodelabels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## the example in Narushima and Hanazawa (1997):
tr &lt;- read.tree(text = "(((i,j)c,(k,l)b)a,(h,g)e,f)d;")
x &lt;- c(1, 3, 0, 6, 5, 2, 4)
names(x) &lt;- letters[6:12]
(o &lt;- MPR(x, tr, "f"))
plot(tr)
nodelabels(paste0("[", o[, 1], ",", o[, 2], "]"))
tiplabels(x[tr$tip.label], adj = -2)
## some random data:
x &lt;- rpois(30, 1)
tr &lt;- rtree(30, rooted = FALSE)
MPR(x, tr, "t1")
</code></pre>

<hr>
<h2 id='mrca'>Find Most Recent Common Ancestors Between Pairs</h2><span id='topic+mrca'></span><span id='topic+getMRCA'></span>

<h3>Description</h3>

<p><code>mrca</code> returns for each pair of tips (and nodes) its most
recent common ancestor (MRCA).
</p>
<p><code>getMRCA</code> returns the MRCA of two or more tips.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrca(phy, full = FALSE)
getMRCA(phy, tip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mrca_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="mrca_+3A_full">full</code></td>
<td>
<p>a logical indicating whether to return the MRCAs among
all tips and nodes (if <code>TRUE</code>); the default is to return only
the MRCAs among tips.</p>
</td></tr>
<tr><td><code id="mrca_+3A_tip">tip</code></td>
<td>
<p>a vector of mode numeric or character specifying the tips;
can also be node numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>mrca</code>, the diagonal is set to the number of the tips (and
nodes if <code>full = TRUE</code>). If <code>full = FALSE</code>, the colnames and
rownames are set with the tip labels of the tree; otherwise the
numbers are given as names.
</p>
<p>For <code>getMRCA</code>, if <code>tip</code> is of length one or zero then
<code>NULL</code> is returned.
</p>


<h3>Value</h3>

<p>a matrix of mode numeric (<code>mrca</code>) or a single numeric value
(<code>getMRCA</code>).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis, Klaus Schliep, Joseph W. Brown</p>

<hr>
<h2 id='mst'>Minimum Spanning Tree</h2><span id='topic+mst'></span><span id='topic+plot.mst'></span>

<h3>Description</h3>

<p>The function <code>mst</code> finds the minimum spanning tree between a set of
observations using a matrix of pairwise distances.
</p>
<p>The <code>plot</code> method plots the minimum spanning tree showing the
links where the observations are identified by their numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mst(X)
## S3 method for class 'mst'
plot(x, graph = "circle", x1 = NULL, x2 = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mst_+3A_x">X</code></td>
<td>
<p>either a matrix that can be interpreted as a distance matrix,
or an object of class <code>"dist"</code>.</p>
</td></tr>
<tr><td><code id="mst_+3A_x">x</code></td>
<td>
<p>an object of class <code>"mst"</code> (e.g. returned by <code>mst()</code>).</p>
</td></tr>
<tr><td><code id="mst_+3A_graph">graph</code></td>
<td>
<p>a character string indicating the type of graph to plot
the minimum spanning tree; two choices are possible: <code>"circle"</code> where
the observations are plotted regularly spaced on a circle, and
<code>"nsca"</code> where the two first axes of a non-symmetric correspondence
analysis are used to plot the observations (see Details below). If
both arguments <code>x1</code> and <code>x2</code> are given, the argument
<code>graph</code> is ignored.</p>
</td></tr>
<tr><td><code id="mst_+3A_x1">x1</code></td>
<td>
<p>a numeric vector giving the coordinates of the observations
on the <em>x</em>-axis. Both <code>x1</code> and <code>x2</code> must be specified
to be used.</p>
</td></tr>
<tr><td><code id="mst_+3A_x2">x2</code></td>
<td>
<p>a numeric vector giving the coordinates of the observations
on the <em>y</em>-axis. Both <code>x1</code> and <code>x2</code> must be specified
to be used.</p>
</td></tr>
<tr><td><code id="mst_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>plot()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions provide two ways to plot the minimum spanning tree which
try to space as much as possible the observations in order to show as
clearly as possible the links. The option <code>graph = "circle"</code>
simply plots regularly the observations on a circle, whereas
<code>graph = "nsca"</code> uses a non-symmetric correspondence analysis
where each observation is represented at the centroid of its neighbours.
</p>
<p>Alternatively, the user may use any system of coordinates for the
obsevations, for instance a principal components analysis (PCA) if the
distances were computed from an original matrix of continous variables.
</p>


<h3>Value</h3>

<p>an object of class <code>"mst"</code> which is a square numeric matrix of size
equal to the number of observations with either <code>1</code> if a link
between the corresponding observations was found, or <code>0</code>
otherwise. The names of the rows  and columns of the distance matrix,
if available, are given as rownames and colnames to the returned object.
</p>


<h3>Author(s)</h3>

<p>Yvonnick Noel <a href="mailto:noel@univ-lille3.fr">noel@univ-lille3.fr</a>,
Julien Claude <a href="mailto:julien.claude@umontpellier.fr">julien.claude@umontpellier.fr</a> and
Emmanuel Paradis
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist.dna">dist.dna</a></code>, <code><a href="#topic+dist.gene">dist.gene</a></code>,
<code><a href="stats.html#topic+dist">dist</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(stats)
X &lt;- matrix(runif(200), 20, 10)
d &lt;- dist(X)
PC &lt;- prcomp(X)
M &lt;- mst(d)
opar &lt;- par(mfcol = c(2, 2))
plot(M)
plot(M, graph = "nsca")
plot(M, x1 = PC$x[, 1], x2 = PC$x[, 2])
par(opar)
</code></pre>

<hr>
<h2 id='multi2di'>Collapse and Resolve Multichotomies</h2><span id='topic+multi2di'></span><span id='topic+multi2di.phylo'></span><span id='topic+multi2di.multiPhylo'></span><span id='topic+di2multi'></span><span id='topic+di2multi.phylo'></span><span id='topic+di2multi.multiPhylo'></span>

<h3>Description</h3>

<p>These two functions collapse or resolve multichotomies in phylogenetic
trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi2di(phy, ...)
## S3 method for class 'phylo'
multi2di(phy, random = TRUE, equiprob = TRUE, ...)
## S3 method for class 'multiPhylo'
multi2di(phy, random = TRUE, equiprob = TRUE, ...)
di2multi(phy, ...)
## S3 method for class 'phylo'
di2multi(phy, tol = 1e-08, ...)
## S3 method for class 'multiPhylo'
di2multi(phy, tol = 1e-08, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi2di_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code> or <code>"multiPhylo"</code>.</p>
</td></tr>
<tr><td><code id="multi2di_+3A_random">random</code></td>
<td>
<p>a logical value specifying whether to resolve the
multichotomies randomly (the default) or in the order they appear in
the tree (if <code>random = FALSE</code>).</p>
</td></tr>
<tr><td><code id="multi2di_+3A_equiprob">equiprob</code></td>
<td>
<p>a logical value: should topologies generated in equal
probabilities; see details in <code><a href="#topic+rtree">rtree</a></code> (ignored if
<code>random = FALSE</code>).</p>
</td></tr>
<tr><td><code id="multi2di_+3A_tol">tol</code></td>
<td>
<p>a numeric value giving the tolerance to consider a branch
length significantly greater than zero.</p>
</td></tr>
<tr><td><code id="multi2di_+3A_...">...</code></td>
<td>
<p>arguments passed among methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>multi2di</code> transforms all multichotomies into a series of
dichotomies with one (or several) branch(es) of length zero.
</p>
<p><code>di2multi</code> deletes all branches smaller than <code>tol</code> and
collapses the corresponding dichotomies into a multichotomy.
</p>


<h3>Value</h3>

<p>an object of the same class than the input.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.binary">is.binary</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bird.families)
is.binary(bird.families)
is.binary(multi2di(bird.families))
all.equal(di2multi(multi2di(bird.families)), bird.families)
### To see the results of randomly resolving a trichotomy:
tr &lt;- read.tree(text = "(a:1,b:1,c:1);")
layout(matrix(1:4, 2, 2))
for (i in 1:4)
  plot(multi2di(tr), use.edge.length = FALSE, cex = 1.5)
layout(1)
</code></pre>

<hr>
<h2 id='multiphylo'>Manipulating Lists of Trees</h2><span id='topic+multiphylo'></span><span id='topic++5B.multiPhylo'></span><span id='topic++5B+5B.multiPhylo'></span><span id='topic++24.multiPhylo'></span><span id='topic++5B+3C-.multiPhylo'></span><span id='topic++5B+5B+3C-.multiPhylo'></span><span id='topic++24+3C-.multiPhylo'></span>

<h3>Description</h3>

<p>These are extraction and replacement operators for lists of trees
stored in the class <code>"multiPhylo"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiPhylo'
x[i]
## S3 method for class 'multiPhylo'
x[[i]]
## S3 method for class 'multiPhylo'
x$name
## S3 replacement method for class 'multiPhylo'
x[i] &lt;- value
## S3 replacement method for class 'multiPhylo'
x[[i]] &lt;- value
## S3 replacement method for class 'multiPhylo'
x$i &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiphylo_+3A_x">x</code>, <code id="multiphylo_+3A_value">value</code></td>
<td>
<p>an object of class <code>"phylo"</code> or <code>"multiPhylo"</code>.</p>
</td></tr>
<tr><td><code id="multiphylo_+3A_i">i</code></td>
<td>
<p>index(ices) of the tree(s) to select from a list; this may be a
vector of integers, logicals, or names.</p>
</td></tr>
<tr><td><code id="multiphylo_+3A_name">name</code></td>
<td>
<p>a character string specifying the tree to be extracted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The subsetting operator <code>[</code> keeps the class correctly
(<code>"multiPhylo"</code>).
</p>
<p>The replacement operators check the labels of <code>value</code> if <code>x</code>
has a single vector of tip labels for all trees (see examples).
</p>


<h3>Value</h3>

<p>An object of class <code>"phylo"</code> (<code>[[</code>, <code>$</code>) or of class
<code>"multiPhylo"</code> (<code>[</code> and the replacement operators).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.phylo">summary.phylo</a></code>, <code><a href="#topic+c.phylo">c.phylo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rmtree(10, 20)
names(x) &lt;- paste("tree", 1:10, sep = "")
x[1:5]
x[1] # subsetting
x[[1]] # extraction
x$tree1 # same than above
x[[1]] &lt;- rtree(20)

y &lt;- .compressTipLabel(x)
## up to here 'x' and 'y' have exactly the same information
## but 'y' has a unique vector of tip labels for all the trees
x[[1]] &lt;- rtree(10) # no error
try(y[[1]] &lt;- rtree(10)) # error

try(x[1] &lt;- rtree(20)) # error
## use instead one of the two:
x[1] &lt;- list(rtree(20))
x[1] &lt;- c(rtree(20))

x[1:5] &lt;- rmtree(5, 20) # replacement
x[11:20] &lt;- rmtree(10, 20) # elongation
x # 20 trees
</code></pre>

<hr>
<h2 id='mvr'>Minimum Variance Reduction</h2><span id='topic+mvr'></span><span id='topic+mvrs'></span>

<h3>Description</h3>

<p>Phylogenetic tree construction based on the minimum variance reduction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvr(X, V)
mvrs(X, V, fs = 15)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvr_+3A_x">X</code></td>
<td>
<p>a distance matrix.</p>
</td></tr>
<tr><td><code id="mvr_+3A_v">V</code></td>
<td>
<p>a variance matrix.</p>
</td></tr>
<tr><td><code id="mvr_+3A_fs">fs</code></td>
<td>
<p>agglomeration criterion parameter: it is coerced as an
integer and must at least equal to one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The MVR method can be seen as a version of BIONJ which is not
restricted to the Poison model of variance (Gascuel 2000).
</p>


<h3>Value</h3>

<p>an object of class <code>"phylo"</code>.
</p>


<h3>Author(s)</h3>

<p>Andrei Popescu</p>


<h3>References</h3>

<p>Criscuolo, A. and Gascuel, O. (2008). Fast NJ-like algorithms to deal
with incomplete distance matrices. <em>BMC Bioinformatics</em>, 9.
</p>
<p>Gascuel, O. (2000). Data model and classification by trees: the
minimum variance reduction (MVR) method. <em>Journal of
Classification</em>, <b>17</b>, 67&ndash;99.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bionj">bionj</a></code>, <code><a href="#topic+fastme">fastme</a></code>, <code><a href="#topic+njs">njs</a></code>,
<code><a href="#topic+SDM">SDM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
rt &lt;- dist.dna(woodmouse, variance = TRUE)
v &lt;- attr(rt, "variance")
tr &lt;- mvr(rt, v)
plot(tr, "u")
</code></pre>

<hr>
<h2 id='nj'>Neighbor-Joining Tree Estimation</h2><span id='topic+nj'></span>

<h3>Description</h3>

<p>This function performs the neighbor-joining tree estimation of Saitou
and Nei (1987).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nj(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nj_+3A_x">X</code></td>
<td>
<p>a distance matrix; may be an object of class &ldquo;dist&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"phylo"</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Saitou, N. and Nei, M. (1987) The neighbor-joining method: a new
method for reconstructing phylogenetic trees. <em>Molecular Biology
and Evolution</em>, <b>4</b>, 406&ndash;425.
</p>
<p>Studier, J. A. and Keppler, K. J. (1988) A note on the
neighbor-joining algorithm of Saitou and Nei. <em>Molecular Biology
and Evolution</em>, <b>5</b>, 729&ndash;731.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.tree">write.tree</a></code>, <code><a href="#topic+read.tree">read.tree</a></code>,
<code><a href="#topic+dist.dna">dist.dna</a></code>, <code><a href="#topic+bionj">bionj</a></code>,
<code><a href="#topic+fastme">fastme</a></code>, <code><a href="#topic+njs">njs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### From Saitou and Nei (1987, Table 1):
x &lt;- c(7, 8, 11, 13, 16, 13, 17, 5, 8, 10, 13,
       10, 14, 5, 7, 10, 7, 11, 8, 11, 8, 12,
       5, 6, 10, 9, 13, 8)
M &lt;- matrix(0, 8, 8)
M[lower.tri(M)] &lt;- x
M &lt;- t(M)
M[lower.tri(M)] &lt;- x
dimnames(M) &lt;- list(1:8, 1:8)
tr &lt;- nj(M)
plot(tr, "u")
### a less theoretical example
data(woodmouse)
trw &lt;- nj(dist.dna(woodmouse))
plot(trw)
</code></pre>

<hr>
<h2 id='njs'>Tree Reconstruction from Incomplete Distances With NJ* or bio-NJ*</h2><span id='topic+njs'></span><span id='topic+bionjs'></span>

<h3>Description</h3>

<p>Reconstructs a phylogenetic tree from a distance matrix with possibly
missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>njs(X, fs = 15)
bionjs(X, fs = 15)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="njs_+3A_x">X</code></td>
<td>
<p>a distance matrix.</p>
</td></tr>
<tr><td><code id="njs_+3A_fs">fs</code></td>
<td>
<p>argument <em>s</em> of the agglomerative criterion: it is
coerced as an integer and must at least equal to one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing values represented by either <code>NA</code> or any negative number.
</p>
<p>Basically, the Q* criterion is applied to all the pairs of leaves, and
the <em>s</em> highest scoring ones are chosen for further analysis by
the agglomeration criteria that better handle missing distances (see
references for details).
</p>


<h3>Value</h3>

<p>an object of class <code>"phylo"</code>.
</p>


<h3>Author(s)</h3>

<p>Andrei Popescu</p>


<h3>References</h3>

<p>Criscuolo, A., Gascuel, O. (2008) Fast NJ-like algorithms to deal with
incomplete distance matrices. <em>BMC Bioinformatics</em>, <b>9</b>,
166.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nj">nj</a></code>, <code><a href="#topic+bionj">bionj</a></code>, <code><a href="#topic+triangMtds">triangMtds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
d &lt;- dist.dna(woodmouse)
dm &lt;- d
dm[sample(length(dm), size = 3)] &lt;- NA
dist.topo(njs(dm), nj(d)) # often 0
dm[sample(length(dm), size = 10)] &lt;- NA
dist.topo(njs(dm), nj(d)) # sometimes 0
</code></pre>

<hr>
<h2 id='node.dating'>node.dating</h2><span id='topic+node.dating'></span><span id='topic+estimate.mu'></span><span id='topic+estimate.dates'></span>

<h3>Description</h3>

<p>Estimate the dates of a rooted phylogenetic tree from the tip dates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate.mu(t, node.dates, p.tol = 0.05)
estimate.dates(t, node.dates, mu = estimate.mu(t, node.dates),
               min.date = -.Machine$double.xmax, show.steps = 0,
               opt.tol = 1e-8, nsteps = 1000,
               lik.tol = 0, is.binary = is.binary.phylo(t))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node.dating_+3A_t">t</code></td>
<td>
<p>an object of class &quot;phylo&quot;</p>
</td></tr>
<tr><td><code id="node.dating_+3A_node.dates">node.dates</code></td>
<td>
<p>a numeric vector of dates for the tips, in the same
order as 't$tip.label' or a vector of dates for all of the nodes.</p>
</td></tr>
<tr><td><code id="node.dating_+3A_p.tol">p.tol</code></td>
<td>
<p>p-value cutoff for failed regression.</p>
</td></tr>
<tr><td><code id="node.dating_+3A_mu">mu</code></td>
<td>
<p>mutation rate.</p>
</td></tr>
<tr><td><code id="node.dating_+3A_min.date">min.date</code></td>
<td>
<p>the minimum bound on the dates of nodes</p>
</td></tr>
<tr><td><code id="node.dating_+3A_show.steps">show.steps</code></td>
<td>
<p>print the log likelihood every show.steps. If 0 will
supress output.</p>
</td></tr>
<tr><td><code id="node.dating_+3A_opt.tol">opt.tol</code></td>
<td>
<p>tolerance for optimization precision.</p>
</td></tr>
<tr><td><code id="node.dating_+3A_lik.tol">lik.tol</code></td>
<td>
<p>tolerance for likelihood comparison.</p>
</td></tr>
<tr><td><code id="node.dating_+3A_nsteps">nsteps</code></td>
<td>
<p>the maximum number of steps to run.</p>
</td></tr>
<tr><td><code id="node.dating_+3A_is.binary">is.binary</code></td>
<td>
<p>if TRUE, will run a faster optimization method that
only works if the tree is binary; otherwise will use optimize() as
the optimization method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This code duplicates the functionality of the program Tip.Dates (see references).
The dates of the internal nodes of 't' are estimated using a maximum likelihood
approach.
</p>
<p>'t' must be rooted and have branch lengths in units of expected substitutions per
site.
</p>
<p>'node.dates' can be either a numeric vector of dates for the tips or a numeric
vector for all of the nodes of 't'.  'estimate.mu' will use all of the values
given in 'node.dates' to estimate the mutation rate.  Dates can be censored with
NA. 'node.dates' must contain all of the tip dates when it is a parameter of
'estimate.dates'.  If only tip dates are given, then 'estimate.dates' will run an
initial step to estimate the dates of the internal nodes.  If 'node.dates'
contains dates for some of the nodes, 'estimate.dates' will use those dates as
priors in the inital step.  If all of the dates for nodes are given, then
'estimate.dates' will not run the inital step.
</p>
<p>If 'is.binary' is set to FALSE, 'estimate.dates' uses the &quot;optimize&quot; function as
the optimization method.  By default, R's &quot;optimize&quot; function uses a precision
of &quot;.Machine$double.eps^0.25&quot;, which is about 0.0001 on a 64-bit system.  This
should be set to a smaller value if the branch lengths of 't' are very short.  If
'is.binary' is set to TRUE, estimate dates uses calculus to deterimine the maximum
likelihood at each step, which is faster. The bounds of permissible values are
reduced by 'opt.tol'.
</p>
<p>'estimate.dates' has several criteria to decide how many steps it will run.  If
'lik.tol' and 'nsteps' are both 0, then 'estimate.dates' will only run the initial
step.  If 'lik.tol' is greater than 0 and 'nsteps' is 0, then 'estimate.dates'
will run until the difference between successive steps is less than 'lik.tol'.  If
'lik.tol' is 0 and 'nsteps' is greater than 0, then 'estimate.dates' will run the
inital step and then 'nsteps' steps.  If 'lik.tol' and 'nsteps' are both greater
than 0, then 'estimate.dates' will run the inital step and then either 'nsteps'
steps or until the difference between successive steps is less than 'lik.tol'.
</p>


<h3>Value</h3>

<p>The estimated mutation rate as a numeric vector of length one for estimate.mu.
</p>
<p>The estimated dates of all of the nodes of the tree as a numeric vector with
length equal to the number of nodes in the tree.
</p>


<h3>Note</h3>

<p>This model assumes that the tree follows a molecular clock.  It only performs a
rudimentary statistical test of the molecular clock hypothesis.
</p>


<h3>Author(s)</h3>

<p>Bradley R. Jones &lt;email: brj1@sfu.ca&gt;</p>


<h3>References</h3>

<p>Felsenstein, J. (1981) Evolutionary trees from DNA sequences: a maximum likelihood
approach. <em>Journal of Molecular Evolution</em>, <b>17</b>, 368&ndash;376.
</p>
<p>Rambaut, A. (2000) Estimating the rate of molecular evolution:
incorporating non-contemporaneous sequences into maximum likelihood
phylogenies. <em>Bioinformatics</em>, <b>16</b>, 395&ndash;399.
</p>
<p>Jones, Bradley R., and Poon, Art F. Y. (2016)
node.dating: dating ancestors in phylogenetic trees in R
<em>Bioinformatics</em>, <b>33</b>, 932&ndash;934.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optimize">optimize</a>, <a href="#topic+rtt">rtt</a></code>,
<code><a href="#topic+plotTreeTime">plotTreeTime</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- rtree(100)
tip.date &lt;- rnorm(t$tip.label, mean = node.depth.edgelength(t)[1:Ntip(t)])^2
t &lt;- rtt(t, tip.date)
mu &lt;- estimate.mu(t, tip.date)

## Run for 100 steps
node.date &lt;- estimate.dates(t, tip.date, mu, nsteps = 100)

## Run until the difference between successive log likelihoods is
## less than $10^{-4}$ starting with the 100th step's results
node.date &lt;- estimate.dates(t, node.date, mu, nsteps = 0, lik.tol = 1e-4)

## To rescale the tree over time
t$edge.length &lt;- node.date[t$edge[, 2]] - node.date[t$edge[, 1]]
</code></pre>

<hr>
<h2 id='node.depth'>Depth and Heights of Nodes and Tips</h2><span id='topic+node.depth'></span><span id='topic+node.depth.edgelength'></span><span id='topic+node.height'></span>

<h3>Description</h3>

<p>These functions return the depths or heights of nodes and tips.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node.depth(phy, method = 1)
node.depth.edgelength(phy)
node.height(phy, clado.style = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node.depth_+3A_phy">phy</code></td>
<td>
<p>an object of class &quot;phylo&quot;.</p>
</td></tr>
<tr><td><code id="node.depth_+3A_method">method</code></td>
<td>
<p>an integer value (1 or 2); 1: the node depths are
proportional to the number of tips descending from each node, 2:
they are evenly spaced.</p>
</td></tr>
<tr><td><code id="node.depth_+3A_clado.style">clado.style</code></td>
<td>
<p>a logical value; if <code>TRUE</code>, the node heights
are calculated for a cladogram.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>node.depth</code> computes the depth of a node depending on the value
of <code>method</code> (see the option <code>node.depth</code> in
<code><a href="#topic+plot.phylo">plot.phylo</a></code>). The value of 1 is given to the tips.
</p>
<p><code>node.depth.edgelength</code> does the same but using branch lengths.
</p>
<p><code>node.height</code> computes the heights of nodes and tips as plotted
by a phylogram or a cladogram.
</p>


<h3>Value</h3>

<p>A numeric vector indexed with the node numbers of the matrix &lsquo;edge&rsquo; of
<code>phy</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.phylo">plot.phylo</a></code></p>

<hr>
<h2 id='nodelabels'>Labelling the Nodes, Tips, and Edges of a Tree</h2><span id='topic+nodelabels'></span><span id='topic+tiplabels'></span><span id='topic+edgelabels'></span>

<h3>Description</h3>

<p>These functions add labels to or near the nodes, the tips, or the
edges of a tree using text or plotting symbols. The text can be
framed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodelabels(text, node, adj = c(0.5, 0.5), frame = "rect",
           pch = NULL, thermo = NULL, pie = NULL, piecol = NULL,
           col = "black", bg = "lightblue", horiz = FALSE,
           width = NULL, height = NULL, ...)
tiplabels(text, tip, adj = c(0.5, 0.5), frame = "rect",
          pch = NULL, thermo = NULL, pie = NULL, piecol = NULL,
          col = "black", bg = "yellow", horiz = FALSE,
          width = NULL, height = NULL, offset = 0, ...)
edgelabels(text, edge, adj = c(0.5, 0.5), frame = "rect",
           pch = NULL, thermo = NULL, pie = NULL, piecol = NULL,
           col = "black", bg = "lightgreen", horiz = FALSE,
           width = NULL, height = NULL, date = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodelabels_+3A_text">text</code></td>
<td>
<p>a vector of mode character giving the text to be
printed. Can be left empty.</p>
</td></tr>
<tr><td><code id="nodelabels_+3A_node">node</code></td>
<td>
<p>a vector of mode numeric giving the numbers of the nodes
where the text or the symbols are to be printed. Can be left empty.</p>
</td></tr>
<tr><td><code id="nodelabels_+3A_tip">tip</code></td>
<td>
<p>a vector of mode numeric giving the numbers of the tips
where the text or the symbols are to be printed. Can be left empty.</p>
</td></tr>
<tr><td><code id="nodelabels_+3A_edge">edge</code></td>
<td>
<p>a vector of mode numeric giving the numbers of the edges
where the text or the symbols are to be printed. Can be left empty.</p>
</td></tr>
<tr><td><code id="nodelabels_+3A_adj">adj</code></td>
<td>
<p>one or two numeric values specifying the horizontal and
vertical, respectively, justification of the text or symbols. By
default, the text is centered horizontally and vertically. If a
single value is given, this alters only the horizontal position of
the text.</p>
</td></tr>
<tr><td><code id="nodelabels_+3A_frame">frame</code></td>
<td>
<p>a character string specifying the kind of frame to be
printed around the text. This must be one of &quot;rect&quot; (the default),
&quot;circle&quot;, &quot;none&quot;, or any unambiguous abbreviation of these.</p>
</td></tr>
<tr><td><code id="nodelabels_+3A_pch">pch</code></td>
<td>
<p>a numeric giving the type of plotting symbol to be used;
this is eventually recycled. See <code><a href="graphics.html#topic+par">par</a></code> for R's
plotting symbols. If <code>pch</code> is used, then <code>text</code> is
ignored.</p>
</td></tr>
<tr><td><code id="nodelabels_+3A_thermo">thermo</code></td>
<td>
<p>a numeric vector giving some proportions (values between
0 and 1) for each node, or a numeric matrix giving some proportions
(the rows must sum to one). It can be a data frame which is then
converted into a matrix.</p>
</td></tr>
<tr><td><code id="nodelabels_+3A_pie">pie</code></td>
<td>
<p>same than <code>thermo</code>.</p>
</td></tr>
<tr><td><code id="nodelabels_+3A_piecol">piecol</code></td>
<td>
<p>a list of colours (given as a character vector) to be
used by <code>thermo</code> or <code>pie</code>; if left <code>NULL</code>, a series
of colours given by the function <code>rainbow</code> is used.</p>
</td></tr>
<tr><td><code id="nodelabels_+3A_col">col</code></td>
<td>
<p>a character string giving the color to be used for the
text or the plotting symbols; this is eventually recycled.</p>
</td></tr>
<tr><td><code id="nodelabels_+3A_bg">bg</code></td>
<td>
<p>a character string giving the color to be used for the
background of the text frames or of the plotting symbols if it
applies; this is eventually recycled.</p>
</td></tr>
<tr><td><code id="nodelabels_+3A_...">...</code></td>
<td>
<p>further arguments passed to the <code>text</code> or
<code>points</code> functions (e.g. <code>cex</code> to alter the size of the
text or the symbols, or <code>font</code> for the text; see the examples
below).</p>
</td></tr>
<tr><td><code id="nodelabels_+3A_horiz">horiz</code>, <code id="nodelabels_+3A_width">width</code>, <code id="nodelabels_+3A_height">height</code></td>
<td>
<p>parameters controlling the aspect of
thermometers; by default, their width and height are determined
automatically.</p>
</td></tr>
<tr><td><code id="nodelabels_+3A_offset">offset</code></td>
<td>
<p>offset of the tip labels (can be negative).</p>
</td></tr>
<tr><td><code id="nodelabels_+3A_date">date</code></td>
<td>
<p>specifies the positions of labels on edges of chronograms
with respect to the time scale.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These three functions have the same optional arguments and the same
functioning.
</p>
<p>If the arguments <code>text</code> is missing and <code>pch</code> and
<code>thermo</code> are left as <code>NULL</code>, then the numbers of the nodes
(or of the tips) are printed.
</p>
<p>If <code>node</code>, <code>tip</code>, or <code>edge</code> is missing, then the text
or the symbols are printed on all nodes, tips, or edges.
</p>
<p>The option <code>cex</code> can be used to change the size of all types of
labels.
</p>
<p>A simple call of these functions with no arguments (e.g.,
<code>nodelabels()</code>) prints the numbers of all nodes (or tips).
</p>
<p>In the case of <code>tiplabels</code>, it would be useful to play with the
options <code>x.lim</code> and <code>label.offset</code> (and possibly
<code>show.tip.label</code>) of <code>plot.phylo</code> in most cases (see the
examples).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis, Ben Bolker, and Jim Lemon</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.phylo">plot.phylo</a></code>, <code><a href="#topic+edges">edges</a></code>,
<code><a href="#topic+mixedFontLabel">mixedFontLabel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tr &lt;- read.tree(text = "((Homo,Pan),Gorilla);")
plot(tr)
nodelabels("7.3 Ma", 4, frame = "r", bg = "yellow", adj = 0)
nodelabels("5.4 Ma", 5, frame = "c", bg = "tomato", font = 3)

## A trick by Liam Revell when there are many categories:
plot(tr, x.lim = c(-1, 4))
nodelabels(node = 4, pie = matrix(rep(1, 100), 1), cex = 5)
op &lt;- par(fg = "transparent")
nodelabels(node = 5, pie = matrix(rep(1, 100), 1), cex = 5)
par(op)

data(bird.orders)
plot(bird.orders, use.edge.length = FALSE, font = 1)
bs &lt;- round(runif(22, 90, 100), 0) # some imaginary bootstrap values
bs2 &lt;- round(runif(22, 90, 100), 0)
bs3 &lt;- round(runif(22, 90, 100), 0)
nodelabels(bs, adj = 1.2)
nodelabels(bs2, adj = -0.2, bg = "yellow")

### something more classical
plot(bird.orders, use.edge.length = FALSE, font = 1)
nodelabels(bs, adj = -0.2, frame = "n", cex = 0.8)
nodelabels(bs2, adj = c(1.2, 1), frame = "n", cex = 0.8)
nodelabels(bs3, adj = c(1.2, -0.2), frame = "n", cex = 0.8)

### the same but we play with the font
plot(bird.orders, use.edge.length = FALSE, font = 1)
nodelabels(bs, adj = -0.2, frame = "n", cex = 0.8, font = 2)
nodelabels(bs2, adj = c(1.2, 1), frame = "n", cex = 0.8, font = 3)
nodelabels(bs3, adj = c(1.2, -0.2), frame = "n", cex = 0.8)

plot(bird.orders, "c", use.edge.length = FALSE, font = 1)
nodelabels(thermo = runif(22), cex = .8)

plot(bird.orders, "u", FALSE, font = 1, lab4ut = "a")
nodelabels(cex = .75, bg = "yellow")

### representing two characters at the tips (you could have as many
### as you want)
plot(bird.orders, "c", FALSE, font = 1, label.offset = 3,
     x.lim = 31, no.margin = TRUE)
tiplabels(pch = 21, bg = gray(1:23/23), cex = 2, adj = 1.4)
tiplabels(pch = 19, col = c("yellow", "red", "blue"), adj = 2.5, cex = 2)
### This can be used to highlight tip labels:
plot(bird.orders, font = 1)
i &lt;- c(1, 7, 18)
tiplabels(bird.orders$tip.label[i], i, adj = 0)
### Some random data to compare piecharts and thermometres:
tr &lt;- rtree(15)
x &lt;- runif(14, 0, 0.33)
y &lt;- runif(14, 0, 0.33)
z &lt;- runif(14, 0, 0.33)
x &lt;- cbind(x, y, z, 1 - x - y - z)
layout(matrix(1:2, 1, 2))
plot(tr, "c", FALSE, no.margin = TRUE)
nodelabels(pie = x, cex = 1.3)
text(4.5, 15, "Are you \"pie\"...", font = 4, cex = 1.5)
plot(tr, "c", FALSE, no.margin = TRUE)
nodelabels(thermo = x, col = rainbow(4), cex = 1.3)
text(4.5, 15, "... or \"thermo\"?", font = 4, cex = 1.5)
plot(tr, "c", FALSE, no.margin = TRUE)
nodelabels(thermo = x, col = rainbow(4), cex = 1.3)
plot(tr, "c", FALSE, no.margin = TRUE)
nodelabels(thermo = x, col = rainbow(4), width = 3, horiz = TRUE)
layout(1)
plot(tr, main = "Showing Edge Lengths")
edgelabels(round(tr$edge.length, 3), srt = 90)
plot(tr, "p", FALSE)
edgelabels("above", adj = c(0.5, -0.25), bg = "yellow")
edgelabels("below", adj = c(0.5, 1.25), bg = "lightblue")
</code></pre>

<hr>
<h2 id='nodepath'>Find Paths of Nodes</h2><span id='topic+nodepath'></span>

<h3>Description</h3>

<p>This function finds paths of nodes in a tree. The nodes can be
internal and/or terminal (i.e., tips).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodepath(phy, from = NULL, to = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodepath_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="nodepath_+3A_from">from</code>, <code id="nodepath_+3A_to">to</code></td>
<td>
<p>integers giving node or tip numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, this function returns all the paths from the root to each
tip of the tree. If both arguments <code>from</code> and <code>to</code> are
specified, the shortest path of nodes linking them is returned.
</p>


<h3>Value</h3>

<p>a list of vectors of integers (by default), or a single vector of
integers.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+getMRCA">getMRCA</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>tr &lt;- rtree(2)
nodepath(tr)
nodepath(tr, 1, 2)
</code></pre>

<hr>
<h2 id='parafit'> Test of host-parasite coevolution </h2><span id='topic+parafit'></span><span id='topic+print.parafit'></span><span id='topic+gopher.D'></span><span id='topic+lice.D'></span><span id='topic+HP.links'></span>

<h3>Description</h3>

<p>Function <code><a href="#topic+parafit">parafit</a></code> tests the hypothesis of coevolution between a clade of hosts and a clade of parasites. The null hypothesis (H0) of the global test is that the evolution of the two groups, as revealed by the two phylogenetic trees and the set of host-parasite association links, has been independent. Tests of individual host-parasite links are also available as an option.
</p>
<p>The method, which is described in detail in Legendre et al. (2002), requires some estimates of the phylogenetic trees or phylogenetic distances, and also a description of the host-parasite associations (H-P links) observed in nature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parafit(host.D, para.D, HP, nperm = 999, test.links = FALSE,
        seed = NULL, correction = "none", silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parafit_+3A_host.d">host.D</code></td>
<td>
<p> A matrix of phylogenetic or patristic distances among the hosts (object class: <code>matrix</code>, <code>data.frame</code> or <code>dist</code>). A matrix of patristic distances exactly represents the information in a phylogenetic tree. </p>
</td></tr>
<tr><td><code id="parafit_+3A_para.d">para.D</code></td>
<td>
<p> A matrix of phylogenetic or patristic distances among the parasites (object class: <code>matrix</code>, <code>data.frame</code> or <code>dist</code>). A matrix of patristic distances exactly represents the information in a phylogenetic tree. </p>
</td></tr>
<tr><td><code id="parafit_+3A_hp">HP</code></td>
<td>
<p> A rectangular matrix with hosts as rows and parasites as columns. The matrix contains 1's when a host-parasite link has been observed in nature between the host in the row and the parasite in the column, and 0's otherwise. </p>
</td></tr>
<tr><td><code id="parafit_+3A_nperm">nperm</code></td>
<td>
<p> Number of permutations for the tests. If <code>nperm =
   0</code>, permutation tests will not be computed. The default value is <code>nperm = 999</code>. For large data files, the permutation test is rather slow since the permutation procedure is not compiled. </p>
</td></tr>
<tr><td><code id="parafit_+3A_test.links">test.links</code></td>
<td>
 <p><code>test.links = TRUE</code> will test the significance of individual host-parasite links. Default: <code>test.links = FALSE</code>. </p>
</td></tr>
<tr><td><code id="parafit_+3A_seed">seed</code></td>
<td>
 <p><code>seed = NULL</code> (default): a seed is chosen at random by the function. That seed is used as the starting point for all tests of significance, i.e. the global H-P test and the tests of individual H-P links if they are requested. Users can select a seed of their choice by giving any integer value to <code>seed</code>, for example <code>seed = -123456</code>. Running the function again with the same seed value will produce the exact same test results. </p>
</td></tr>
<tr><td><code id="parafit_+3A_correction">correction</code></td>
<td>
<p> Correction methods for negative eigenvalues (details below): <code>correction="lingoes"</code> and <code>correction="cailliez"</code>. Default value: <code>"none"</code>.  </p>
</td></tr>
<tr><td><code id="parafit_+3A_silent">silent</code></td>
<td>
<p> Informative messages and the time to compute the tests will not be written to the <span class="rlang"><b>R</b></span> console if silent=TRUE. Useful when the function is called by a numerical simulation function. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two types of test are produced by the program: a global test of coevolution and, optionally, a test on the individual host-parasite (H-P) link.
</p>
<p>The function computes principal coordinates for the host and the parasite distance matrices. The principal coordinates (all of them) act as a complete representation of either the phylogenetic distance matrix or the phylogenetic tree.
</p>
<p>Phylogenetic distance matrices are normally Euclidean. Patristic distance matrices are additive, thus they are metric and Euclidean. Euclidean matrices are fully represented by real-valued principal coordinate axes. For non-Euclidean matrices, negative eigenvalues are produced; complex principal coordinate axes are associated with the negative eigenvalues. So, the program rejects matrices that are not Euclidean and stops.
</p>
<p>Negative eigenvalues can be corrected for by one of two methods: the Lingoes or the Caillez correction. It is up to the user to decide which correction method should be applied. This is done by selecting the option <code>correction="lingoes"</code> or <code>correction="cailliez"</code>. Details on these correction methods are given in the help file of the <code>pcoa</code> function.
</p>
<p>The principle of the global test is the following (H0: independent evolution of the hosts and parasites): (1) Compute matrix D = C t(A) B. Note: D is a fourth-corner matrix (sensu Legendre et al. 1997), where A is the H-P link matrix, B is the matrix of principal coordinates computed from the host.D matrix, and C is the matrix of principal coordinates computed from the para.D matrix. (2) Compute the statistic ParaFitGlobal, the sum of squares of all values in matrix D. (3) Permute at random, separately, each row of matrix A, obtaining matrix A.perm. Compute D.perm = C 
</p>
<p>The test of each individual H-P link is carried out as follows (H0: this particular link is random): (1) Remove one link (k) from matrix A. (2) Compute matrix D = C t(A) B. (3a) Compute trace(k), the sum of squares of all values in matrix D. (3b) Compute the statistic ParaFitLink1 = (trace - trace(k)) where trace is the ParaFitGlobal statistic. (3c) Compute the statistic ParaFitLink2 = (trace - trace(k)) / (tracemax - trace) where tracemax is the maximum value that can be taken by trace. (4) Permute at random, separately, each row of matrix A, obtaining A.perm. Use the same sequences of permutations as were used in the test of ParaFitGlobal. Using the values of trace and trace.perm saved during the global test, compute the permuted values of the two statistics, ParaFit1.perm and ParaFit2.perm. (5) Repeat step 4 a large number of times. (6) Add the reference value of ParaFit1 to the distribution of ParaFit1.perm values; add the reference value of ParaFit2 to the distribution of ParaFit2.perm values. Calculate the permutational probabilities associated to ParaFit1 and ParaFit2.
</p>
<p>The <code>print.parafit</code> function prints out the results of the global test and, optionally, the results of the tests of the individual host-parasite links.
</p>


<h3>Value</h3>

<table>
<tr><td><code>ParaFitGlobal</code></td>
<td>
<p>The statistic of the global H-P test. </p>
</td></tr>
<tr><td><code>p.global</code></td>
<td>
<p>The permutational p-value associated with the ParaFitGlobal statistic. </p>
</td></tr>
<tr><td><code>link.table</code></td>
<td>
<p>The results of the tests of individual H-P links, including the ParaFitLink1 and ParaFitLink2 statistics and the p-values obtained from their respective permutational tests. </p>
</td></tr>
<tr><td><code>para.per.host</code></td>
<td>
<p>Number of parasites per host. </p>
</td></tr>
<tr><td><code>host.per.para</code></td>
<td>
<p>Number of hosts per parasite. </p>
</td></tr>
<tr><td><code>nperm</code></td>
<td>
<p>Number of permutations for the tests. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Pierre Legendre, Universite de Montreal </p>


<h3>References</h3>

<p>Hafner, M. S, P. D. Sudman, F. X. Villablanca, T. A. Spradling, J. W. Demastes and S. A. Nadler. 1994. Disparate rates of molecular evolution in cospeciating hosts and parasites. <em>Science</em>, <b>265</b>, 1087&ndash;1090.
</p>
<p>Legendre, P., Y. Desdevises and E. Bazin. 2002. A statistical test for host-parasite coevolution. <em>Systematic Biology</em>, <b>51(2)</b>, 217&ndash;234.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcoa">pcoa</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Gopher and lice data from Hafner et al. (1994)

data(gopher.D)
data(lice.D)
data(HP.links)

res &lt;- parafit(gopher.D, lice.D, HP.links, nperm=99, test.links=TRUE)
# res     # or else: print(res)
</code></pre>

<hr>
<h2 id='pcoa'>Principal Coordinate Analysis</h2><span id='topic+pcoa'></span><span id='topic+biplot.pcoa'></span>

<h3>Description</h3>

<p>Function <code><a href="#topic+pcoa">pcoa</a></code> computes principal coordinate decomposition
(also called classical scaling) of a distance matrix D (Gower 1966). It
implements two correction methods for negative eigenvalues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcoa(D, correction="none", rn=NULL)

## S3 method for class 'pcoa'
biplot(x, Y=NULL, plot.axes = c(1,2), dir.axis1=1,
       dir.axis2=1, rn=NULL, main=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcoa_+3A_d">D</code></td>
<td>
<p>A distance matrix of class <code>dist</code> or <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="pcoa_+3A_correction">correction</code></td>
<td>
<p>Correction methods for negative eigenvalues (details
below): <code>"lingoes"</code> and <code>"cailliez"</code>. Default value:
<code>"none"</code>.</p>
</td></tr>
<tr><td><code id="pcoa_+3A_rn">rn</code></td>
<td>
<p>An optional vector of row names, of length n, for the n
objects.</p>
</td></tr>
<tr><td><code id="pcoa_+3A_x">x</code></td>
<td>
<p>Output object from <code><a href="#topic+pcoa">pcoa</a></code>.</p>
</td></tr>
<tr><td><code id="pcoa_+3A_y">Y</code></td>
<td>
<p>Any rectangular data table containing explanatory variables
to be projected onto the ordination plot. That table may contain,
for example, the community composition data used to compute D, or
any transformation of these data; see examples.</p>
</td></tr>
<tr><td><code id="pcoa_+3A_plot.axes">plot.axes</code></td>
<td>
<p>The two PCoA axes to plot.</p>
</td></tr>
<tr><td><code id="pcoa_+3A_dir.axis1">dir.axis1</code></td>
<td>
<p>= -1 to revert axis 1 for the projection of points
and variables. Default value: +1.</p>
</td></tr>
<tr><td><code id="pcoa_+3A_dir.axis2">dir.axis2</code></td>
<td>
<p>= -1 to revert axis 2 for the projection of points
and variables. Default value: +1.</p>
</td></tr>
<tr><td><code id="pcoa_+3A_main">main</code></td>
<td>
<p>An optional title.</p>
</td></tr>
<tr><td><code id="pcoa_+3A_...">...</code></td>
<td>
<p>Other graphical arguments passed to function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements two methods for correcting for negative
values in principal coordinate analysis (PCoA). Negative eigenvalues
can be produced in PCoA when decomposing distance matrices produced by
coefficients that are not Euclidean (Gower and Legendre 1986,Legendre
and Legendre 1998).
</p>
<p>In <code>pcoa</code>, when negative eigenvalues are present in the
decomposition results, the distance matrix D can be modified using
either the Lingoes or the Cailliez procedure to produce results
without negative eigenvalues.
</p>
<p>In the Lingoes (1971) procedure, a constant c1, equal to twice
absolute value of the largest negative value of the original principal
coordinate analysis, is added to each original squared distance in the
distance matrix, except the diagonal values. A newe principal
coordinate analysis, performed on the modified distances, has at most
(n-2) positive eigenvalues, at least 2 null eigenvalues, and no
negative eigenvalue.
</p>
<p>In the Cailliez (1983) procedure, a constant c2 is added to the
original distances in the distance matrix, except the diagonal
values. The calculation of c2 is described in Legendre and Legendre
(1998). A new principal coordinate analysis, performed on the modified
distances, has at most (n-2) positive eigenvalues, at least 2 null
eigenvalues, and no negative eigenvalue.
</p>
<p>In all cases, only the eigenvectors corresponding to positive
eigenvalues are shown in the output list. The eigenvectors are scaled
to the square root of the corresponding eigenvalues. Gower (1966) has
shown that eigenvectors scaled in that way preserve the original
distance (in the D matrix) among the objects. These eigenvectors can
be used to plot ordination graphs of the objects.
</p>
<p>We recommend not to use PCoA to produce ordinations from the chord,
chi-square, abundance profile, or Hellinger distances. It is easier to
first transform the community composition data using the following
transformations, available in the <code>decostand</code> function of the
<code>vegan</code> package, and then carry out a principal component
analysis (PCA) on the transformed data:
</p>

<ul>
<li><p> Chord transformation: decostand(spiders,&quot;normalize&quot;)
</p>
</li>
<li><p> Transformation to relative abundance profiles:
decostand(spiders,&quot;total&quot;)
</p>
</li>
<li><p> Hellinger transformation: decostand(spiders,&quot;hellinger&quot;)
</p>
</li>
<li><p> Chi-square transformation: decostand(spiders,&quot;chi.square&quot;)
</p>
</li></ul>

<p>The ordination results will be identical and the calculations
shorter. This two-step ordination method, called transformation-based
PCA (tb-PCA), was described by Legendre and Gallagher (2001).
</p>
<p>The <code>biplot.pcoa</code> function produces plots for any pair of
principal coordinates. The original variables can be projected onto
the ordination plot.
</p>


<h3>Value</h3>

<table>
<tr><td><code>correction</code></td>
<td>
<p>The values of parameter <code>correction</code> and
variable 'correct' in the function.</p>
</td></tr>
<tr><td><code>note</code></td>
<td>
<p>A note describing the type of correction done, if any.</p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p>The eigenvalues and related information:</p>
</td></tr>
<tr><td><code>Eigenvalues</code></td>
<td>
<p>All eigenvalues (positive, null, negative).</p>
</td></tr>
<tr><td><code>Relative_eig</code></td>
<td>
<p>Relative eigenvalues.</p>
</td></tr>
<tr><td><code>Corr_eig</code></td>
<td>
<p>Corrected eigenvalues (Lingoes correction); Legendre
and Legendre (1998, p. 438, eq. 9.27).</p>
</td></tr>
<tr><td><code>Rel_corr_eig</code></td>
<td>
<p>Relative eigenvalues after Lingoes or Cailliez
correction.</p>
</td></tr>
<tr><td><code>Broken_stick</code></td>
<td>
<p>Expected fractions of variance under the broken
stick model.</p>
</td></tr>
<tr><td><code>Cumul_eig</code></td>
<td>
<p>Cumulative relative eigenvalues.</p>
</td></tr>
<tr><td><code>Cum_corr_eig</code></td>
<td>
<p>Cumulative corrected relative eigenvalues.</p>
</td></tr>
<tr><td><code>Cumul_br_stick</code></td>
<td>
<p>Cumulative broken stick fractions.</p>
</td></tr>
<tr><td><code>vectors</code></td>
<td>
<p>The principal coordinates with positive eigenvalues.</p>
</td></tr>
<tr><td><code>trace</code></td>
<td>
<p>The trace of the distance matrix. This is also the sum of
all eigenvalues, positive and negative.</p>
</td></tr>
<tr><td><code>vectors.cor</code></td>
<td>
<p>The principal coordinates with positive
eigenvalues from the distance matrix corrected using the method
specified by parameter <code>correction</code>.</p>
</td></tr>
<tr><td><code>trace.cor</code></td>
<td>
<p>The trace of the corrected distance matrix. This is
also the sum of its eigenvalues.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pierre Legendre, Universite de Montreal</p>


<h3>References</h3>

<p>Cailliez, F. (1983) The analytical solution of the additive constant
problem. <em>Psychometrika</em>, <b>48</b>, 305&ndash;308.
</p>
<p>Gower, J. C. (1966) Some distance properties of latent root and vector
methods used in multivariate analysis. <em>Biometrika</em>, <b>53</b>,
325&ndash;338.
</p>
<p>Gower, J. C. and Legendre, P. (1986) Metric and Euclidean properties
of dissimilarity coefficients. <em>Journal of Classification</em>,
<b>3</b>, 5&ndash;48.
</p>
<p>Legendre, P. and Gallagher, E. D. (2001) Ecologically meaningful
transformations for ordination of species data. <em>Oecologia</em>,
<b>129</b>, 271&ndash;280.
</p>
<p>Legendre, P. and Legendre, L. (1998) <em>Numerical Ecology, 2nd
English edition.</em> Amsterdam: Elsevier Science BV.
</p>
<p>Lingoes, J. C. (1971) Some boundary conditions for a monotone analysis
of symmetric matrices. <em>Psychometrika</em>, <b>36</b>, 195&ndash;203.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Oribatid mite data from Borcard and Legendre (1994)

## Not run: 
if (require(vegan)) {
data(mite) # Community composition data, 70 peat cores, 35 species

## Select rows 1:30. Species 35 is absent from these rows. Transform to log
mite.log &lt;- log(mite[1:30, -35] + 1)  # Equivalent: log1p(mite[1:30, -35])

## Principal coordinate analysis and simple ordination plot
mite.D &lt;- vegdist(mite.log, "bray")
res &lt;- pcoa(mite.D)
res$values
biplot(res)

## Project unstandardized and standardized species on the PCoA ordination plot
mite.log.st = apply(mite.log, 2, scale, center=TRUE, scale=TRUE)

par(mfrow=c(1,2))
biplot(res, mite.log)
biplot(res, mite.log.st)

# Reverse the ordination axes in the  plot
par(mfrow=c(1,2))
biplot(res, mite.log, dir.axis1=-1, dir.axis2=-1)
biplot(res, mite.log.st, dir.axis1=-1, dir.axis2=-1)
}
## End(Not run)</code></pre>

<hr>
<h2 id='phydataplot'>Tree Annotation</h2><span id='topic+phydataplot'></span><span id='topic+ring'></span>

<h3>Description</h3>

<p><code>phydataplot</code> plots data on a tree in a way that adapts to the
type of tree. <code>ring</code> does the same for circular trees.
</p>
<p>Both functions match the data with the labels of the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phydataplot(x, phy, style = "bars", offset = 1, scaling = 1,
            continuous = FALSE, width = NULL, legend = "below",
            funcol = rainbow, ...)
ring(x, phy, style = "ring", offset = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phydataplot_+3A_x">x</code></td>
<td>
<p>a vector, a factor, a matrix, or a data frame.</p>
</td></tr>
<tr><td><code id="phydataplot_+3A_phy">phy</code></td>
<td>
<p>the tree (which must be already plotted).</p>
</td></tr>
<tr><td><code id="phydataplot_+3A_style">style</code></td>
<td>
<p>a character string specifying the type of graphics; can
be abbreviated (see details).</p>
</td></tr>
<tr><td><code id="phydataplot_+3A_offset">offset</code></td>
<td>
<p>the space between the tips of the tree and the plot.</p>
</td></tr>
<tr><td><code id="phydataplot_+3A_scaling">scaling</code></td>
<td>
<p>the scaling factor to apply to the data.</p>
</td></tr>
<tr><td><code id="phydataplot_+3A_continuous">continuous</code></td>
<td>
<p>(used if style=&quot;mosaic&quot;) a logical specifying
whether to treat the values in <code>x</code> as continuous or not; can be
an integer value giving the number of categories.</p>
</td></tr>
<tr><td><code id="phydataplot_+3A_width">width</code></td>
<td>
<p>(used if style = &quot;mosaic&quot;) the width of the cells; by
default, all the available space is used.</p>
</td></tr>
<tr><td><code id="phydataplot_+3A_legend">legend</code></td>
<td>
<p>(used if style = &quot;mosaic&quot;) the place where to draw the
legend; one of <code>"below"</code> (the default), <code>"side"</code>, or
<code>"none"</code>, or an unambiguous abbreviation of these.</p>
</td></tr>
<tr><td><code id="phydataplot_+3A_funcol">funcol</code></td>
<td>
<p>(used if style = &quot;mosaic&quot;) the function used to generate
the colours (see details and examples).</p>
</td></tr>
<tr><td><code id="phydataplot_+3A_...">...</code></td>
<td>
<p>further arguments passed to the graphical functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The possible values for <code>style</code> are &ldquo;bars&rdquo;, &ldquo;segments&rdquo;,
&ldquo;image&rdquo;, &ldquo;arrows&rdquo;, &ldquo;boxplot&rdquo;, &ldquo;dotchart&rdquo;, or &ldquo;mosaic&rdquo; for
<code>phydataplot</code>, and &ldquo;ring&rdquo;, &ldquo;segments&rdquo;, or &ldquo;arrows&rdquo; for
<code>ring</code>.
</p>
<p><code>style = "image"</code> works only with square matrices (e.g.,
similarities). If you want to plot a DNA alignment in the same way
than <code><a href="#topic+image.DNAbin">image.DNAbin</a></code>, try <code>style = "mosaic"</code>.
</p>
<p><code>style = "mosaic"</code> can plot any kind of matrices, possibly after
discretizing its values (using <code>continuous</code>). The default colour
palette is taken from the function <code><a href="grDevices.html#topic+rainbow">rainbow</a></code>.
If you want to use specified colours, a function simply returning the
vector of colours must be used, possibly with names if you want to
assign a specific colour to each value (see examples).
</p>


<h3>Note</h3>

<p>For the moment, only rightwards trees are supported (does not apply to
circular trees).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.phylo">plot.phylo</a></code>, <code><a href="#topic+nodelabels">nodelabels</a></code>,
<code><a href="#topic+fancyarrows">fancyarrows</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## demonstrates matching with names:
tr &lt;- rcoal(n &lt;- 10)
x &lt;- 1:n
names(x) &lt;- tr$tip.label
plot(tr, x.lim = 11)
phydataplot(x, tr)
## shuffle x but matching names with tip labels reorders them:
phydataplot(sample(x), tr, "s", lwd = 3, lty = 3)

## adapts to the tree:
plot(tr, "f", x.l = c(-11, 11), y.l = c(-11, 11))
phydataplot(x, tr, "s")

## leave more space with x.lim to show a barplot and a dotchart:
plot(tr, x.lim = 22)
phydataplot(x, tr, col = "yellow")
phydataplot(x, tr, "d", offset = 13)

ts &lt;- rcoal(N &lt;- 100)
X &lt;- rTraitCont(ts) # names are set
dd &lt;- dist(X)
op &lt;- par(mar = rep(0, 4))
plot(ts, x.lim = 10, cex = 0.4, font = 1)
phydataplot(as.matrix(dd), ts, "i", offset = 0.2)

par(xpd = TRUE, mar = op$mar)
co &lt;- c("blue", "red"); l &lt;- c(-2, 2)
X &lt;- X + abs(min(X)) # move scale so X &gt;= 0
plot(ts, "f", show.tip.label = FALSE, x.lim = l, y.lim = l, open.angle = 30)
phydataplot(X, ts, "s", col = co, offset = 0.05)
ring(X, ts, "ring", col = co, offset = max(X) + 0.1) # the same info as a ring

## as many rings as you want...
co &lt;- c("blue", "yellow")
plot(ts, "r", show.tip.label = FALSE, x.l = c(-1, 1), y.l = c(-1, 1))
for (o in seq(0, 0.4, 0.2)) {
    co &lt;- rev(co)
    ring(0.2, ts, "r", col = rep(co, each = 5), offset = o)
}

lim &lt;- c(-5, 5)
co &lt;- rgb(0, 0.4, 1, alpha = 0.1)
y &lt;- seq(0.01, 1, 0.01)
plot(ts, "f", x.lim = lim, y.lim = lim, show.tip.label = FALSE)
ring(y, ts, offset = 0, col = co, lwd = 0.1)
for (i in 1:3) {
    y &lt;- y + 1
    ring(y, ts, offset = 0, col = co, lwd = 0.1)
}

## rings can be in the background
plot(ts, "r", plot = FALSE)
ring(1, ts, "r", col = rainbow(100), offset = -1)
par(new = TRUE)
plot(ts, "r", font = 1, edge.color = "white")

## might be more useful:
co &lt;- c("lightblue", "yellow")
plot(ts, "r", plot = FALSE)
ring(0.1, ts, "r", col = sample(co, size = N, rep = TRUE), offset = -.1)
par(new = TRUE)
plot(ts, "r", font = 1)

## if x is matrix:
tx &lt;- rcoal(m &lt;- 20)
X &lt;- runif(m, 0, 0.5); Y &lt;- runif(m, 0, 0.5)
X &lt;- cbind(X, Y, 1 - X - Y)
rownames(X) &lt;- tx$tip.label
plot(tx, x.lim = 6)
co &lt;- rgb(diag(3))
phydataplot(X, tx, col = co)
## a variation:
plot(tx, show.tip.label = FALSE, x.lim = 5)
phydataplot(X, tx, col = co, offset = 0.05, border = NA)

plot(tx, "f", show.tip.label = FALSE, open.angle = 180)
ring(X, tx, col = co, offset = 0.05)

Z &lt;- matrix(rnorm(m * 5), m)
rownames(Z) &lt;- rownames(X)
plot(tx, x.lim = 5)
phydataplot(Z, tx, "bo", scaling = .5, offset = 0.5,
            boxfill = c("gold", "skyblue"))

## plot an alignment with a NJ tree:
data(woodmouse)
trw &lt;- nj(dist.dna(woodmouse))
plot(trw, x.lim = 0.1, align.tip = TRUE, font = 1)
phydataplot(woodmouse[, 1:50], trw, "m", 0.02, border = NA)

## use type = "mosaic" on a 30x5 matrix:
tr &lt;- rtree(n &lt;- 30)
p &lt;- 5
x &lt;- matrix(sample(3, size = n*p, replace = TRUE), n, p)
dimnames(x) &lt;- list(paste0("t", 1:n), LETTERS[1:p])
plot(tr, x.lim = 35, align.tip = TRUE, adj = 1)
phydataplot(x, tr, "m", 2)
## change the aspect:
plot(tr, x.lim = 35, align.tip = TRUE, adj = 1)
phydataplot(x, tr, "m", 2, width = 2, border = "white", lwd = 3, legend = "side")
## user-defined colour:
f &lt;- function(n) c("yellow", "blue", "red")
phydataplot(x, tr, "m", 18, width = 2, border = "white", lwd = 3,
            legend = "side", funcol = f)

## alternative colour function...:
## fb &lt;- function(n) c("3" = "red", "2" = "blue", "1" = "yellow")
## ... but since the values are sorted alphabetically,
## both f and fb will produce the same plot.

## use continuous = TRUE with two different scales:
x[] &lt;- 1:(n*p)
plot(tr, x.lim = 35, align.tip = TRUE, adj = 1)
phydataplot(x, tr, "m", 2, width = 1.5, continuous = TRUE, legend = "side",
            funcol = colorRampPalette(c("white", "darkgreen")))
phydataplot(x, tr, "m", 18, width = 1.5, continuous = 5, legend = "side",
            funcol = topo.colors)
</code></pre>

<hr>
<h2 id='phymltest'>Fits a Bunch of Models with PhyML</h2><span id='topic+phymltest'></span><span id='topic+print.phymltest'></span><span id='topic+summary.phymltest'></span><span id='topic+plot.phymltest'></span>

<h3>Description</h3>

<p>This function calls PhyML and fits successively 28 models of DNA
evolution. The results are saved on disk, as PhyML usually does, and
returned in <span class="rlang"><b>R</b></span> as a vector with the log-likelihood value of each model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phymltest(seqfile, format = "interleaved", itree = NULL,
          exclude = NULL, execname = NULL, append = TRUE)
## S3 method for class 'phymltest'
print(x, ...)
## S3 method for class 'phymltest'
summary(object, ...)
## S3 method for class 'phymltest'
plot(x, main = NULL, col = "blue", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phymltest_+3A_seqfile">seqfile</code></td>
<td>
<p>a character string giving the name of the file that
contains the DNA sequences to be analysed by PhyML.</p>
</td></tr>
<tr><td><code id="phymltest_+3A_format">format</code></td>
<td>
<p>a character string specifying the format of the DNA
sequences: either <code>"interleaved"</code> (the default), or
<code>"sequential"</code>.</p>
</td></tr>
<tr><td><code id="phymltest_+3A_itree">itree</code></td>
<td>
<p>a character string giving the name of a file with a tree
in Newick format to be used as an initial tree by PhyML. If
<code>NULL</code> (the default), PhyML uses a &ldquo;BIONJ&rdquo; tree.</p>
</td></tr>
<tr><td><code id="phymltest_+3A_exclude">exclude</code></td>
<td>
<p>a vector of mode character giving the models to be
excluded from the analysis. These must be among those below, and
follow the same syntax.</p>
</td></tr>
<tr><td><code id="phymltest_+3A_execname">execname</code></td>
<td>
<p>a character string specifying the name of the PhyML
executable. This argument can be left as <code>NULL</code> if PhyML's
default names are used: <code>"phyml_3.0_linux32"</code>,
<code>"phyml_3.0_macintel"</code>, or <code>"phyml_3.0_win32.exe"</code>, under
Linux, MacOS, or Windows respectively.</p>
</td></tr>
<tr><td><code id="phymltest_+3A_append">append</code></td>
<td>
<p>a logical indicating whether to erase previous PhyML
output files if present; the default is to not erase.</p>
</td></tr>
<tr><td><code id="phymltest_+3A_x">x</code></td>
<td>
<p>an object of class <code>"phymltest"</code>.</p>
</td></tr>
<tr><td><code id="phymltest_+3A_object">object</code></td>
<td>
<p>an object of class <code>"phymltest"</code>.</p>
</td></tr>
<tr><td><code id="phymltest_+3A_main">main</code></td>
<td>
<p>a title for the plot; if left <code>NULL</code>, a title is made
with the name of the object (use <code>main = ""</code> to have no
title).</p>
</td></tr>
<tr><td><code id="phymltest_+3A_col">col</code></td>
<td>
<p>a colour used for the segments showing the AIC values (blue
by default).</p>
</td></tr>
<tr><td><code id="phymltest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The present function requires version 3.0.1 of PhyML; it won't work with
older versions.
</p>
<p>The user must take care to set correctly the three different paths
involved here: the path to PhyML's binary, the path to the sequence
file, and the path to R's working directory. The function should work
if all three paths are different. Obviously, there should be no problem
if they are all the same.
</p>
<p>The following syntax is used for the models:
</p>
<p>&quot;X[Y][Z]00[+I][+G]&quot;
</p>
<p>where &quot;X&quot; is the first letter of the author of the model, &quot;Y&quot; and &quot;Z&quot;
are possibly other co-authors of the model, &quot;00&quot; is the year of the
publication of the model, and &quot;+I&quot; and &quot;+G&quot; indicates whether the
presence of invariant sites and/or a gamma distribution of
substitution rates have been specified. Thus, Kimura's model is
denoted &quot;K80&quot; and not &quot;K2P&quot;. The exception to this rule is the general
time-reversible model which is simply denoted &quot;GTR&quot; model.
</p>
<p>The seven substitution models used are: &quot;JC69&quot;, &quot;K80&quot;, &quot;F81&quot;, &quot;F84&quot;,
&quot;HKY85&quot;, &quot;TN93&quot;, and &quot;GTR&quot;. These models are then altered by adding
the &quot;+I&quot; and/or &quot;+G&quot;, resulting thus in four variants for each of them
(e.g., &quot;JC69&quot;, &quot;JC69+I&quot;, &quot;JC69+G&quot;, &quot;JC69+I+G&quot;). Some of these models
are described in the help page of <code><a href="#topic+dist.dna">dist.dna</a></code>.
</p>
<p>When a gamma distribution of substitution rates is specified, four
categories are used (which is PhyML's default behaviour), and the
&ldquo;alpha&rdquo; parameter is estimated from the data.
</p>
<p>For the models with a different substition rate for transitions and
transversions, these rates are left free and estimated from the data
(and not constrained with a ratio of 4 as in PhyML's default).
</p>
<p>The option <code>path2exec</code> has been removed in the present version:
the path to PhyML's executable can be specified with the option
<code>execname</code>.
</p>


<h3>Value</h3>

<p><code>phymltest</code> returns an object of class <code>"phymltest"</code>: a
numeric vector with the models as names.
</p>
<p>The <code>print</code> method prints an object of class <code>"phymltest"</code>
as matrix with the name of the models, the number of free parameters,
the log-likelihood value, and the value of the Akaike information
criterion (AIC = -2 * loglik + 2 * number of free parameters)
</p>
<p>The <code>summary</code> method prints all the possible likelihood ratio
tests for an object of class <code>"phymltest"</code>.
</p>
<p>The <code>plot</code> method plots the values of AIC of an object of class
<code>"phymltest"</code> on a vertical scale.
</p>


<h3>Note</h3>

<p>It is important to note that the models fitted by this function is
only a small fraction of the models possible with PhyML. For instance,
it is possible to vary the number of categories in the (discretized)
gamma distribution of substitution rates, and many parameters can be
fixed by the user. The results from the present function should rather
be taken as indicative of a best model.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Posada, D. and Crandall, K. A. (2001) Selecting the best-fit model of
nucleotide substitution. <em>Systematic Biology</em>, <b>50</b>,
580&ndash;601.
</p>
<p>Guindon, S. and Gascuel, O. (2003) A simple, fast, and accurate
algorithm to estimate large phylogenies by maximum likelihood.
<em>Systematic Biology</em>, <b>52</b>, 696&ndash;704.
<a href="http://www.atgc-montpellier.fr/phyml/">http://www.atgc-montpellier.fr/phyml/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.tree">read.tree</a></code>, <code><a href="#topic+write.tree">write.tree</a></code>,
<code><a href="#topic+dist.dna">dist.dna</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### A `fake' example with random likelihood values: it does not
### make sense, but does not need PhyML and gives you a flavour
### of what the output looks like:
x &lt;- runif(28, -100, -50)
names(x) &lt;- ape:::.phymltest.model
class(x) &lt;- "phymltest"
x
summary(x)
plot(x)
plot(x, main = "", col = "red")
### This example needs PhyML, copy/paste or type the
### following commands if you want to try them, eventually
### changing setwd() and the options of phymltest()
## Not run: 
setwd("D:/phyml_v2.4/exe") # under Windows
data(woodmouse)
write.dna(woodmouse, "woodmouse.txt")
X &lt;- phymltest("woodmouse.txt")
X
summary(X)
plot(X)

## End(Not run)
</code></pre>

<hr>
<h2 id='pic'>Phylogenetically Independent Contrasts</h2><span id='topic+pic'></span>

<h3>Description</h3>

<p>Compute the phylogenetically independent contrasts using the method
described by Felsenstein (1985).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pic(x, phy, scaled = TRUE, var.contrasts = FALSE,
    rescaled.tree = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pic_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="pic_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="pic_+3A_scaled">scaled</code></td>
<td>
<p>logical, indicates whether the contrasts should be
scaled with their expected variances (default to <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="pic_+3A_var.contrasts">var.contrasts</code></td>
<td>
<p>logical, indicates whether the expected
variances of the contrasts should be returned (default to
<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="pic_+3A_rescaled.tree">rescaled.tree</code></td>
<td>
<p>logical, if <code>TRUE</code> the rescaled tree is
returned together with the main results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> has names, its values are matched to the tip labels of
<code>phy</code>, otherwise its values are taken to be in the same order
than the tip labels of <code>phy</code>.
</p>
<p>The user must be careful here since the function requires that both
series of names perfectly match. If both series of names do not match,
the values in the <code>x</code> are taken to be in the same order than the
tip labels of <code>phy</code>, and a warning message is issued.
</p>


<h3>Value</h3>

<p>either a vector of phylogenetically independent contrasts (if
<code>var.contrasts = FALSE</code>), or a two-column matrix with the
phylogenetically independent contrasts in the first column and their
expected variance in the second column (if <code>var.contrasts =
  TRUE</code>). If the tree has node labels, these are used as labels of the
returned object.
</p>
<p>If <code>rescaled.tree = TRUE</code>, a list is returned with two elements
named &ldquo;contr&rdquo; with the above results and &ldquo;rescaled.tree&rdquo; with the
tree and its rescaled branch lengths (see Felsenstein 1985).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Felsenstein, J. (1985) Phylogenies and the comparative method.
<em>American Naturalist</em>, <b>125</b>, 1&ndash;15.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.tree">read.tree</a></code>, <code><a href="#topic+compar.gee">compar.gee</a></code>,
<code><a href="#topic+compar.lynch">compar.lynch</a></code>, <code><a href="#topic+pic.ortho">pic.ortho</a></code>,
<code><a href="#topic+varCompPhylip">varCompPhylip</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### The example in Phylip 3.5c (originally from Lynch 1991)
x &lt;- "((((Homo:0.21,Pongo:0.21):0.28,Macaca:0.49):0.13,Ateles:0.62):0.38,Galago:1.00);"
tree.primates &lt;- read.tree(text = x)
X &lt;- c(4.09434, 3.61092, 2.37024, 2.02815, -1.46968)
Y &lt;- c(4.74493, 3.33220, 3.36730, 2.89037, 2.30259)
names(X) &lt;- names(Y) &lt;- c("Homo", "Pongo", "Macaca", "Ateles", "Galago")
pic.X &lt;- pic(X, tree.primates)
pic.Y &lt;- pic(Y, tree.primates)
cor.test(pic.X, pic.Y)
lm(pic.Y ~ pic.X - 1) # both regressions
lm(pic.X ~ pic.Y - 1) # through the origin
</code></pre>

<hr>
<h2 id='pic.ortho'>Phylogenetically Independent Orthonormal Contrasts</h2><span id='topic+pic.ortho'></span>

<h3>Description</h3>

<p>This function computes the orthonormal contrasts using the method
described by Felsenstein (2008). Only a single trait can be analyzed;
there can be several observations per species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pic.ortho(x, phy, var.contrasts = FALSE, intra = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pic.ortho_+3A_x">x</code></td>
<td>
<p>a numeric vector or a list of numeric vectors.</p>
</td></tr>
<tr><td><code id="pic.ortho_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="pic.ortho_+3A_var.contrasts">var.contrasts</code></td>
<td>
<p>logical, indicates whether the expected
variances of the contrasts should be returned (default to
<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="pic.ortho_+3A_intra">intra</code></td>
<td>
<p>logical, whether to return the intraspecific contrasts.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data <code>x</code> can be in two forms: a vector if there is a single
observation for each species, or a list whose elements are vectors
containing the individual observations for each species. These vectors
may be of different lengths.
</p>
<p>If <code>x</code> has names, its values are matched to the tip labels of
<code>phy</code>, otherwise its values are taken to be in the same order
than the tip labels of <code>phy</code>.
</p>


<h3>Value</h3>

<p>either a vector of contrasts, or a two-column matrix with the
contrasts in the first column and their expected variances in the
second column (if <code>var.contrasts = TRUE</code>). If the tree has node
labels, these are used as labels of the returned object.
</p>
<p>If <code>intra = TRUE</code>, the attribute <code>"intra"</code>, a list of
vectors with the intraspecific contrasts or <code>NULL</code> for the
species with a one observation, is attached to the returned object.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Felsenstein, J. (2008) Comparative methods with sampling error and
within-species variation: Contrasts revisited and revised.
<em>American Naturalist</em>, <b>171</b>, 713&ndash;725.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pic">pic</a></code>, <code><a href="#topic+varCompPhylip">varCompPhylip</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tr &lt;- rcoal(30)
### a single observation per species:
x &lt;- rTraitCont(tr)
pic.ortho(x, tr)
pic.ortho(x, tr, TRUE)
### different number of observations per species:
x &lt;- lapply(sample(1:5, 30, TRUE), rnorm)
pic.ortho(x, tr, intra = TRUE)
</code></pre>

<hr>
<h2 id='plot.correlogram'>Plot a Correlogram</h2><span id='topic+plot.correlogram'></span><span id='topic+plot.correlogramList'></span>

<h3>Description</h3>

<p>These functions plot correlagrams previously computed with
<code><a href="#topic+correlogram.formula">correlogram.formula</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'correlogram'
plot(x, legend = TRUE, test.level = 0.05,
                col = c("grey", "red"), type = "b", xlab = "",
                ylab = "Moran's I", pch = 21, cex = 2, ...)
  ## S3 method for class 'correlogramList'
plot(x, lattice = TRUE, legend = TRUE,
                test.level = 0.05, col = c("grey", "red"),
                xlab = "", ylab = "Moran's I",
                type = "b", pch = 21, cex = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.correlogram_+3A_x">x</code></td>
<td>
<p>an object of class <code>"correlogram"</code> or of class
<code>"correlogramList"</code> (both produced by
<code><a href="#topic+correlogram.formula">correlogram.formula</a></code>).</p>
</td></tr>
<tr><td><code id="plot.correlogram_+3A_legend">legend</code></td>
<td>
<p>should a legend be added on the plot?</p>
</td></tr>
<tr><td><code id="plot.correlogram_+3A_test.level">test.level</code></td>
<td>
<p>the level used to discriminate the plotting symbols
with colours considering the P-values.</p>
</td></tr>
<tr><td><code id="plot.correlogram_+3A_col">col</code></td>
<td>
<p>two colours for the plotting symbols: the first one is used
if the P-value is greater than or equal to <code>test.level</code>, the
second one otherwise.</p>
</td></tr>
<tr><td><code id="plot.correlogram_+3A_type">type</code></td>
<td>
<p>the type of plot to produce (see
<code><a href="graphics.html#topic+plot">plot</a></code> for possible choices).</p>
</td></tr>
<tr><td><code id="plot.correlogram_+3A_xlab">xlab</code></td>
<td>
<p>an optional character string for the label on the x-axis
(none by default).</p>
</td></tr>
<tr><td><code id="plot.correlogram_+3A_ylab">ylab</code></td>
<td>
<p>the default label on the y-axis.</p>
</td></tr>
<tr><td><code id="plot.correlogram_+3A_pch">pch</code></td>
<td>
<p>the type of plotting symbol.</p>
</td></tr>
<tr><td><code id="plot.correlogram_+3A_cex">cex</code></td>
<td>
<p>the default size for the plotting symbols.</p>
</td></tr>
<tr><td><code id="plot.correlogram_+3A_lattice">lattice</code></td>
<td>
<p>when plotting several correlograms, should they be
plotted in trellis-style with lattice (the default), or together on
the same plot?</p>
</td></tr>
<tr><td><code id="plot.correlogram_+3A_...">...</code></td>
<td>
<p>other parameters passed to the <code>plot</code> or <code>lines</code>
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When plotting several correlograms with lattice, some options have no
effect: <code>legend</code>, <code>type</code>, and <code>pch</code> (<code>pch=19</code> is
always used in this situation).
</p>
<p>When using <code>pch</code> between 1 and 20 (i.e., non-filled symbols, the
colours specified in <code>col</code> are also used for the lines joining
the points. To keep black lines, it is better to leave <code>pch</code>
between 21 and 25.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+correlogram.formula">correlogram.formula</a></code>, <code><a href="#topic+Moran.I">Moran.I</a></code>
</p>

<hr>
<h2 id='plot.phylo'>Plot Phylogenies</h2><span id='topic+plot.phylo'></span><span id='topic+plot.multiPhylo'></span>

<h3>Description</h3>

<p>These functions plot phylogenetic trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phylo'
plot(x, type = "phylogram", use.edge.length = TRUE,
     node.pos = NULL, show.tip.label = TRUE,
     show.node.label = FALSE, edge.color = NULL, edge.width
     = NULL, edge.lty = NULL, node.color = NULL, node.width
     = NULL, node.lty = NULL, font = 3, cex = par("cex"),
     adj = NULL, srt = 0, no.margin = FALSE, root.edge =
     FALSE, label.offset = 0, underscore = FALSE, x.lim =
     NULL, y.lim = NULL, direction = "rightwards", lab4ut =
     NULL, tip.color = par("col"), plot = TRUE, rotate.tree
     = 0, open.angle = 0, node.depth = 1, align.tip.label =
     FALSE, ...)
## S3 method for class 'multiPhylo'
plot(x, layout = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.phylo_+3A_x">x</code></td>
<td>
<p>an object of class <code>"phylo"</code> or of class
<code>"multiPhylo"</code>.</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_type">type</code></td>
<td>
<p>a character string specifying the type of phylogeny to be
drawn; it must be one of &quot;phylogram&quot; (the default), &quot;cladogram&quot;,
&quot;fan&quot;, &quot;unrooted&quot;, &quot;radial&quot;, &quot;tidy&quot;, or any unambiguous abbreviation
of these.</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_use.edge.length">use.edge.length</code></td>
<td>
<p>a logical indicating whether to use the edge
lengths of the phylogeny to draw the branches (the default) or not
(if <code>FALSE</code>). This option has no effect if the object of class
<code>"phylo"</code> has no &lsquo;edge.length&rsquo; element.</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_node.pos">node.pos</code></td>
<td>
<p>a numeric taking the value 1 or 2 which specifies the
vertical position of the nodes with respect to their descendants. If
<code>NULL</code> (the default), then the value is determined in relation
to &lsquo;type&rsquo; and &lsquo;use.edge.length&rsquo; (see details).</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_show.tip.label">show.tip.label</code></td>
<td>
<p>a logical indicating whether to show the tip
labels on the phylogeny (defaults to <code>TRUE</code>, i.e. the labels
are shown).</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_show.node.label">show.node.label</code></td>
<td>
<p>a logical indicating whether to show the node
labels on the phylogeny (defaults to <code>FALSE</code>, i.e. the labels
are not shown).</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_edge.color">edge.color</code></td>
<td>
<p>a vector of mode character giving the colours used
to draw the branches of the plotted phylogeny. These are taken to be
in the same order than the component <code>edge</code> of <code>phy</code>. If
fewer colours are given than the length of <code>edge</code>, then the
colours are recycled.</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_edge.width">edge.width</code></td>
<td>
<p>a numeric vector giving the width of the branches of
the plotted phylogeny. These are taken to be in the same order than
the component <code>edge</code> of <code>phy</code>. If fewer widths are given
than the length of <code>edge</code>, then these are recycled.</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_edge.lty">edge.lty</code></td>
<td>
<p>same as the previous argument but for line types;
1: plain, 2: dashed, 3: dotted, 4: dotdash, 5: longdash, 6: twodash.</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_node.color">node.color</code></td>
<td>
<p>a vector of mode character giving the colours used
to draw the perpendicular lines associated with each node of the
plotted phylogeny. These are taken to be
in the same order than the component <code>node</code> of <code>phy</code>. If
fewer colours are given than the length of <code>node</code>, then the
colours are recycled.</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_node.width">node.width</code></td>
<td>
<p>as the previous argument, but for line widths.</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_node.lty">node.lty</code></td>
<td>
<p>as the previous argument, but for line types;
1: plain, 2: dashed, 3: dotted, 4: dotdash, 5: longdash, 6: twodash.</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_font">font</code></td>
<td>
<p>an integer specifying the type of font for the labels: 1
(plain text), 2 (bold), 3 (italic, the default), or 4 (bold
italic).</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_cex">cex</code></td>
<td>
<p>a numeric value giving the factor scaling of the tip and
node labels (Character EXpansion). The default is to take the
current value from the graphical parameters.</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_adj">adj</code></td>
<td>
<p>a numeric specifying the justification of the text strings
of the labels: 0 (left-justification), 0.5 (centering), or 1
(right-justification). This option has no effect if <code>type =
      "unrooted"</code>. If <code>NULL</code> (the default) the value is set with
respect of <code>direction</code> (see details).</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_srt">srt</code></td>
<td>
<p>a numeric giving how much the labels are rotated in degrees
(negative values are allowed resulting in clock-like rotation); the
value has an effect respectively to the value of
<code>direction</code> (see Examples). This option has no effect if
<code>type = "unrooted"</code>.</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_no.margin">no.margin</code></td>
<td>
<p>a logical. If <code>TRUE</code>, the margins are set to
zero and the plot uses all the space of the device (note that this
was the behaviour of <code>plot.phylo</code> up to version 0.2-1 of &lsquo;ape&rsquo;
with no way to modify it by the user, at least easily).</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_root.edge">root.edge</code></td>
<td>
<p>a logical indicating whether to draw the root edge
(defaults to FALSE); this has no effect if &lsquo;use.edge.length = FALSE&rsquo;
or if &lsquo;type = &quot;unrooted&quot;&rsquo;.</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_label.offset">label.offset</code></td>
<td>
<p>a numeric giving the space between the nodes and
the tips of the phylogeny and their corresponding labels. This
option has no effect if <code>type = "unrooted"</code>.</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_underscore">underscore</code></td>
<td>
<p>a logical specifying whether the underscores in tip
labels should be written as spaces (the default) or left as are (if
<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_x.lim">x.lim</code></td>
<td>
<p>a numeric vector of length one or two giving the limit(s)
of the x-axis. If <code>NULL</code>, this is computed with respect to
various parameters such as the string lengths of the labels and the
branch lengths. If a single value is given, this is taken as the
upper limit.</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_y.lim">y.lim</code></td>
<td>
<p>same than above for the y-axis.</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_direction">direction</code></td>
<td>
<p>a character string specifying the direction of the
tree. Four values are possible: &quot;rightwards&quot; (the default),
&quot;leftwards&quot;, &quot;upwards&quot;, and &quot;downwards&quot;.</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_lab4ut">lab4ut</code></td>
<td>
<p>(= labels for unrooted trees) a character string
specifying the display of tip labels for unrooted trees (can be
abbreviated): either <code>"horizontal"</code> where all labels are
horizontal (the default if <code>type = "u"</code>), or <code>"axial"</code>
where the labels are displayed in the axis of the corresponding
terminal branches. This option has an effect if <code>type = "u"</code>,
<code>"f"</code>, or <code>"r"</code>.</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_tip.color">tip.color</code></td>
<td>
<p>the colours used for the tip labels, eventually
recycled (see examples).</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_plot">plot</code></td>
<td>
<p>a logical controlling whether to draw the tree. If
<code>FALSE</code>, the graphical device is set as if the tree was
plotted, and the coordinates are saved as well.</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_rotate.tree">rotate.tree</code></td>
<td>
<p>for &quot;fan&quot;, &quot;unrooted&quot;, or &quot;radial&quot; trees: the
rotation of the whole tree in degrees (negative values are
accepted).</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_open.angle">open.angle</code></td>
<td>
<p>if <code>type = "f"</code> or <code>"r"</code>, the angle in
degrees left blank. Use a non-zero value if you want to call
<code><a href="#topic+axisPhylo">axisPhylo</a></code> after the tree is plotted.</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_node.depth">node.depth</code></td>
<td>
<p>an integer value (1 or 2) used if branch lengths are
not used to plot the tree; 1: the node depths are proportional to
the number of tips descending from each node (the default and was the
only possibility previously), 2: they are evenly spaced.</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_align.tip.label">align.tip.label</code></td>
<td>
<p>a logical value or an integer. If <code>TRUE</code>,
the tips are aligned and dotted lines are drawn between the tips of
the tree and the labels. If an integer, the tips are aligned and
this gives the type of the lines (<code>lty</code>).</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_layout">layout</code></td>
<td>
<p>the number of trees to be plotted simultaneously.</p>
</td></tr>
<tr><td><code id="plot.phylo_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>plot</code> or to
<code>plot.phylo</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a list of trees (i.e., an object of class
<code>"multiPhylo"</code>), then any further argument may be passed with
<code>...</code> and could be any one of those listed above for a single
tree.
</p>
<p>The font format of the labels of the nodes and the tips is the same.
</p>
<p>If <code>no.margin = TRUE</code>, the margins are set to zero and are not
restored after plotting the tree, so that the user can access the
coordinates system of the plot.
</p>
<p>The option &lsquo;node.pos&rsquo; allows the user to alter the vertical position
(i.e., ordinates) of the nodes. If <code>node.pos = 1</code>, then the
ordinate of a node is the mean of the ordinates of its direct
descendants (nodes and/or tips). If <code>node.pos = 2</code>, then the
ordinate of a node is the mean of the ordinates of all the tips of
which it is the ancestor. If <code>node.pos = NULL</code> (the default),
then its value is determined with respect to other options: if
<code>type = "phylogram"</code> then &lsquo;node.pos = 1&rsquo;; if <code>type =
    "cladogram"</code> and <code>use.edge.length = FALSE</code> then &lsquo;node.pos = 2&rsquo;;
if <code>type = "cladogram"</code> and <code>use.edge.length = TRUE</code> then
&lsquo;node.pos = 1&rsquo;. Remember that in this last situation, the branch
lengths make sense when projected on the x-axis.
</p>
<p>If <code>adj</code> is not specified, then the value is determined with
respect to <code>direction</code>: if <code>direction = "leftwards"</code> then
<code>adj = 1</code> (0 otherwise).
</p>
<p>If the arguments <code>x.lim</code> and <code>y.lim</code> are not specified by the
user, they are determined roughly by the function. This may not always
give a nice result: the user may check these values with the
(invisibly) returned list (see &ldquo;Value:&rdquo;).
</p>
<p>If you use <code>align.tip.label = TRUE</code> with <code>type = "fan"</code>, you
will have certainly to set  <code>x.lim</code> and <code>y.lim</code> manually.
</p>
<p>If you resize manually the graphical device (windows or X11) you may
need to replot the tree.
</p>


<h3>Value</h3>

<p><code>plot.phylo</code> returns invisibly a list with the following
components which values are those used for the current plot:
</p>
<table>
<tr><td><code>type</code></td>
<td>
</td></tr>
<tr><td><code>use.edge.length</code></td>
<td>
</td></tr>
<tr><td><code>node.pos</code></td>
<td>
</td></tr>
<tr><td><code>node.depth</code></td>
<td>
</td></tr>
<tr><td><code>show.tip.label</code></td>
<td>
</td></tr>
<tr><td><code>show.node.label</code></td>
<td>
</td></tr>
<tr><td><code>font</code></td>
<td>
</td></tr>
<tr><td><code>cex</code></td>
<td>
</td></tr>
<tr><td><code>adj</code></td>
<td>
</td></tr>
<tr><td><code>srt</code></td>
<td>
</td></tr>
<tr><td><code>no.margin</code></td>
<td>
</td></tr>
<tr><td><code>label.offset</code></td>
<td>
</td></tr>
<tr><td><code>x.lim</code></td>
<td>
</td></tr>
<tr><td><code>y.lim</code></td>
<td>
</td></tr>
<tr><td><code>direction</code></td>
<td>
</td></tr>
<tr><td><code>tip.color</code></td>
<td>
</td></tr>
<tr><td><code>Ntip</code></td>
<td>
</td></tr>
<tr><td><code>Nnode</code></td>
<td>
</td></tr>
<tr><td><code>root.time</code></td>
<td>
</td></tr>
<tr><td><code>align.tip.label</code></td>
<td>
</td></tr>
</table>


<h3>Note</h3>

<p>The argument <code>asp</code> cannot be passed with <code>...</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis, Martin Smith, Damien de Vienne</p>


<h3>References</h3>

<p>van der Ploeg, A. (2014) Drawing non-layered tidy trees in linear
time. <em>Journal of Software: Practice and Experience</em>, <b>44</b>,
1467&ndash;1484.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.tree">read.tree</a></code>, <code><a href="#topic+trex">trex</a></code>, <code><a href="#topic+kronoviz">kronoviz</a></code>,
<code><a href="#topic+add.scale.bar">add.scale.bar</a></code>, <code><a href="#topic+axisPhylo">axisPhylo</a></code>,
<code><a href="#topic+nodelabels">nodelabels</a></code>, <code><a href="#topic+edges">edges</a></code>,
<code><a href="graphics.html#topic+plot">plot</a></code> for the basic plotting function in R
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### An extract from Sibley and Ahlquist (1990)
x &lt;- "(((Strix_aluco:4.2,Asio_otus:4.2):3.1,Athene_noctua:7.3):6.3,Tyto_alba:13.5);"
tree.owls &lt;- read.tree(text= x)
plot(tree.owls)

### Show the types of trees.
layout(matrix(1:6, 3, 2))
plot(tree.owls, main = "With branch lengths")
plot(tree.owls, type = "c")
plot(tree.owls, type = "u")
plot(tree.owls, use.edge.length = FALSE, main = "Without branch lengths")
plot(tree.owls, type = "c", use.edge.length = FALSE)
plot(tree.owls, type = "u", use.edge.length = FALSE)
layout(1)

data(bird.orders)
### using random colours and thickness
plot(bird.orders,
     edge.color = sample(colors(), length(bird.orders$edge)/2),
     edge.width = sample(1:10, length(bird.orders$edge)/2, replace = TRUE))
title("Random colours and branch thickness")
### rainbow colouring...
X &lt;- c("red", "orange", "yellow", "green", "blue", "purple")
plot(bird.orders,
     edge.color = sample(X, length(bird.orders$edge)/2, replace = TRUE),
     edge.width = sample(1:10, length(bird.orders$edge)/2, replace = TRUE))
title("Rainbow colouring")
plot(bird.orders, type = "c", use.edge.length = FALSE,
     edge.color = sample(X, length(bird.orders$edge)/2, replace = TRUE),
     edge.width = rep(5, length(bird.orders$edge)/2))
segments(rep(0, 6), 6.5:1.5, rep(2, 6), 6.5:1.5, lwd = 5, col = X)
text(rep(2.5, 6), 6.5:1.5, paste(X, "..."), adj = 0)
title("Character mapping...")
plot(bird.orders, "u", font = 1, cex = 0.75)
data(bird.families)
plot(bird.families, "u", lab4ut = "axial", font = 1, cex = 0.5)
plot(bird.families, "r", font = 1, cex = 0.5)
### cladogram with oblique tip labels
plot(bird.orders, "c", FALSE, direction = "u", srt = -40, x.lim = 25.5)
### facing trees with different informations...
tr &lt;- bird.orders
tr$tip.label &lt;- rep("", 23)
layout(matrix(1:2, 1, 2), c(5, 4))
plot(bird.orders, "c", FALSE, adj = 0.5, no.margin = TRUE, label.offset = 0.8,
     edge.color = sample(X, length(bird.orders$edge)/2, replace = TRUE),
     edge.width = rep(5, length(bird.orders$edge)/2))
text(7.5, 23, "Facing trees with\ndifferent informations", font = 2)
plot(tr, "p", direction = "l", no.margin = TRUE,
     edge.width = sample(1:10, length(bird.orders$edge)/2, replace = TRUE))
### Recycling of arguments gives a lot of possibilities
### for tip labels:
plot(bird.orders, tip.col = c(rep("red", 5), rep("blue", 18)),
     font = c(rep(3, 5), rep(2, 17), 1))
plot(bird.orders, tip.col = c("blue", "green"),
     cex = 23:1/23 + .3, font = 1:3)
co &lt;- c(rep("blue", 9), rep("green", 35))
plot(bird.orders, "f", edge.col = co)
plot(bird.orders, edge.col = co)
layout(1)

## tidy trees
tr &lt;- rtree(100)
layout(matrix(1:2, 2))
plot(tr)
axis(2)
plot(tr, "t")
axis(2)
## around 20 percent gain on the y-axis
</code></pre>

<hr>
<h2 id='plot.phylo.extra'>Extra Fuctions to Plot and Annotate Phylogenies</h2><span id='topic+plot.phylo.extra'></span><span id='topic+plotBreakLongEdges'></span><span id='topic+drawSupportOnEdges'></span>

<h3>Description</h3>

<p>These are extra functions to plot and annotate phylogenies, mostly
calling basic graphical functions in <span class="pkg">ape</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBreakLongEdges(phy, n = 1, ...)
drawSupportOnEdges(value, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.phylo.extra_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="plot.phylo.extra_+3A_n">n</code></td>
<td>
<p>the numner of long branches to be broken.</p>
</td></tr>
<tr><td><code id="plot.phylo.extra_+3A_value">value</code></td>
<td>
<p>the values to be printed on the internal branches of the tree.</p>
</td></tr>
<tr><td><code id="plot.phylo.extra_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>plot.phylo</code> or to
<code>edgelabels</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>drawSupportOnEdges</code> assumes the tree is unrooted, so the vector
<code>value</code> should have as many values than the number of internal
branches (= number of nodes - 1). If there is one additional value, it
is assumed that it relates to the root node and is dropped (see examples).
</p>


<h3>Value</h3>

<p>NULL</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.phylo">plot.phylo</a></code>, <code><a href="#topic+edgelabels">edgelabels</a></code>,
<code><a href="#topic+boot.phylo">boot.phylo</a></code>, <code><a href="#topic+plotTreeTime">plotTreeTime</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tr &lt;- rtree(10)
tr$edge.length[c(1, 18)] &lt;- 100
op &lt;- par(mfcol = 1:2)
plot(tr); axisPhylo()
plotBreakLongEdges(tr, 2); axisPhylo()

## from ?boot.phylo:
f &lt;- function(x) nj(dist.dna(x))
data(woodmouse)
tw &lt;- f(woodmouse) # NJ tree with K80 distance
set.seed(1)
## bootstrap with 100 replications:
(bp &lt;- boot.phylo(tw, woodmouse, f, quiet = TRUE))
## the first value relates to the root node and is always 100
## it is ignored below:
plot(tw, "u")
drawSupportOnEdges(bp)
## more readable but the tree is really unrooted:
plot(tw)
drawSupportOnEdges(bp)
par(op)
</code></pre>

<hr>
<h2 id='plot.varcomp'>Plot Variance Components</h2><span id='topic+plot.varcomp'></span>

<h3>Description</h3>

<p>Plot previously estimated variance components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varcomp'
plot(x, xlab = "Levels", ylab = "Variance", type = "b", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.varcomp_+3A_x">x</code></td>
<td>
<p> A <var>varcomp</var> object</p>
</td></tr>
<tr><td><code id="plot.varcomp_+3A_xlab">xlab</code></td>
<td>
<p> x axis label</p>
</td></tr>
<tr><td><code id="plot.varcomp_+3A_ylab">ylab</code></td>
<td>
<p> y axis label </p>
</td></tr>
<tr><td><code id="plot.varcomp_+3A_type">type</code></td>
<td>
<p> plot type (&quot;l&quot;, &quot;p&quot; or &quot;b&quot;, see <code><a href="base.html#topic+plot">plot</a></code>)</p>
</td></tr>
<tr><td><code id="plot.varcomp_+3A_...">...</code></td>
<td>
<p>Further argument sent to the <code><a href="lattice.html#topic+xyplot">xyplot</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same as <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
</p>


<h3>Author(s)</h3>

<p>Julien Dutheil <a href="mailto:dutheil@evolbio.mpg.de">dutheil@evolbio.mpg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+varcomp">varcomp</a></code></p>

<hr>
<h2 id='plotTreeTime'>Plot Tree With Time Axis</h2><span id='topic+plotTreeTime'></span>

<h3>Description</h3>

<p>This function plots a non-ultrametric tree where the tips are not
contemporary together with their dates on the x-axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTreeTime(phy, tip.dates, show.tip.label = FALSE, y.lim = NULL,
             color = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTreeTime_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="plotTreeTime_+3A_tip.dates">tip.dates</code></td>
<td>
<p>a vector of the same length than the number of tips
in <code>phy</code> (see details).</p>
</td></tr>
<tr><td><code id="plotTreeTime_+3A_show.tip.label">show.tip.label</code></td>
<td>
<p>a logical value; see <code><a href="#topic+plot.phylo">plot.phylo</a></code>.</p>
</td></tr>
<tr><td><code id="plotTreeTime_+3A_y.lim">y.lim</code></td>
<td>
<p>by default, one fifth of the plot is left below the tree;
use this option to change this behaviour.</p>
</td></tr>
<tr><td><code id="plotTreeTime_+3A_color">color</code></td>
<td>
<p>a logical value specifying whether to use colors for the
lines linking the tips to the time axis. If <code>FALSE</code>, a grey
scale is used.</p>
</td></tr>
<tr><td><code id="plotTreeTime_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to <code>plot.phylo</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vector <code>tip.dates</code> may be numeric or of class
&ldquo;<a href="base.html#topic+Date">Date</a>&rdquo;. In either case, the time axis is set
accordingly. The length of this vector must be equal to the number of
tips of the tree: the dates are matched to the tips numbers. Missing
values are allowed.
</p>


<h3>Value</h3>

<p>NULL</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.phylo">plot.phylo</a></code>, <code><a href="#topic+estimate.dates">estimate.dates</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dates &lt;- as.Date(.leap.seconds)
tr &lt;- rtree(length(dates))
plotTreeTime(tr, dates)

## handling NA's:
dates[11:26] &lt;- NA
plotTreeTime(tr, dates)

## dates can be on an arbitrary scale, e.g., [-1, 1]:
plotTreeTime(tr, runif(Ntip(tr), -1, 1))
</code></pre>

<hr>
<h2 id='print.phylo'>Compact Display of a Phylogeny</h2><span id='topic+print.phylo'></span><span id='topic+print.multiPhylo'></span><span id='topic+str.multiPhylo'></span>

<h3>Description</h3>

<p>These functions prints a compact summary of a phylogeny, or a list of
phylogenies, on the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phylo'
print(x, printlen = 6 ,...)
## S3 method for class 'multiPhylo'
print(x, details = FALSE ,...)
## S3 method for class 'multiPhylo'
str(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.phylo_+3A_x">x</code></td>
<td>
<p>an object of class <code>"phylo"</code> or <code>"multiPhylo"</code>.</p>
</td></tr>
<tr><td><code id="print.phylo_+3A_object">object</code></td>
<td>
<p>an object of class <code>"multiPhylo"</code>.</p>
</td></tr>
<tr><td><code id="print.phylo_+3A_printlen">printlen</code></td>
<td>
<p>the number of labels to print (6 by default).</p>
</td></tr>
<tr><td><code id="print.phylo_+3A_details">details</code></td>
<td>
<p>a logical indicating whether to print information on
all trees.</p>
</td></tr>
<tr><td><code id="print.phylo_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL.
</p>


<h3>Author(s)</h3>

<p>Ben Bolker and Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.tree">read.tree</a></code>, <code><a href="#topic+summary.phylo">summary.phylo</a></code>,
<code><a href="base.html#topic+print">print</a></code> for the generic <span class="rlang"><b>R</b></span> function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rtree(10)
print(x)
print(x, printlen = 10)
x &lt;- rmtree(2, 10)
print(x)
print(x, TRUE)
str(x)
</code></pre>

<hr>
<h2 id='rDNAbin'>Random DNA Sequences</h2><span id='topic+rDNAbin'></span>

<h3>Description</h3>

<p>This function generates random sets of DNA sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rDNAbin(n, nrow, ncol, base.freq = rep(0.25, 4), prefix = "Ind_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rDNAbin_+3A_n">n</code></td>
<td>
<p>a vector of integers giving the lengths of the sequences. Can
be missing in which case <code>nrow</code> and <code>ncol</code> must be given.</p>
</td></tr>
<tr><td><code id="rDNAbin_+3A_nrow">nrow</code>, <code id="rDNAbin_+3A_ncol">ncol</code></td>
<td>
<p>two single integer values giving the number of
sequences and the number of sites, respectively (ignored if <code>n</code>
is given).</p>
</td></tr>
<tr><td><code id="rDNAbin_+3A_base.freq">base.freq</code></td>
<td>
<p>the base frequencies.</p>
</td></tr>
<tr><td><code id="rDNAbin_+3A_prefix">prefix</code></td>
<td>
<p>the prefix used to give labels to the sequences; by
default these are Ind_1, ... Ind_n (or Ind_nrow).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>n</code> is used, this function generates a list with sequence lengths given by the values in <code>n</code>. If <code>n</code> is missing, a matrix is
generated.
</p>
<p>The purpose of this function is to generate a set of sequences of a
specific size. To simulate sequences on a phylogenetic tree, see
<code><a href="phangorn.html#topic+simSeq">simSeq</a></code> in <span class="pkg">phangorn</span> (very efficient), and
the package <span class="pkg">phylosim</span> (more for pedagogy).
</p>


<h3>Value</h3>

<p>an object of class <code>"DNAbin"</code>.
</p>


<h3>Note</h3>

<p>It is not recommended to use this function to generate objects larger
than two billion bases (2 Gb).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+DNAbin">DNAbin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rDNAbin(1:10)
rDNAbin(rep(10, 10))
rDNAbin(nrow = 10, ncol = 10)
</code></pre>

<hr>
<h2 id='read.caic'>Read Tree File in CAIC Format</h2><span id='topic+read.caic'></span>

<h3>Description</h3>

<p>This function reads one tree from a CAIC file.
A second file containing branch lengths values may also be passed (experimental).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.caic(file, brlen = NULL, skip = 0, comment.char = "#", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.caic_+3A_file">file</code></td>
<td>
<p>a file name specified by either a variable of mode character, or a double-quoted string.</p>
</td></tr>
<tr><td><code id="read.caic_+3A_brlen">brlen</code></td>
<td>
<p>a file name for the branch lengths file.</p>
</td></tr>
<tr><td><code id="read.caic_+3A_skip">skip</code></td>
<td>
<p>the number of lines of the input file to skip before beginning to read data (this is passed directly to scan()).</p>
</td></tr>
<tr><td><code id="read.caic_+3A_comment.char">comment.char</code></td>
<td>
<p>a single character, the remaining of the line after this character is ignored (this is passed directly to scan()).</p>
</td></tr>
<tr><td><code id="read.caic_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to scan().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Read a tree from a file in the format used by the CAIC and MacroCAIc program.
</p>


<h3>Value</h3>

<p>an object of class <code>"phylo"</code>.
</p>


<h3>Warning</h3>

<p>The branch length support is still experimental and was not fully tested.</p>


<h3>Author(s)</h3>

<p>Julien Dutheil <a href="mailto:dutheil@evolbio.mpg.de">dutheil@evolbio.mpg.de</a></p>


<h3>References</h3>

<p>Purvis, A. and Rambaut, A. (1995) Comparative analysis by independent
contrasts (CAIC): an Apple Macintosh application for analysing
comparative data. <em>CABIOS</em>, <b>11</b> :241&ndash;251.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.tree">read.tree</a></code>, <code><a href="#topic+read.nexus">read.nexus</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## The same example than in read.tree, without branch lengths.
## An extract from Sibley and Ahlquist (1990)
fl &lt;- tempfile("tree", fileext = ".tre")
cat("AAA","Strix_aluco","AAB","Asio_otus",
   "AB","Athene_noctua","B","Tyto_alba",
   file = fl, sep = "\n")
tree.owls &lt;- read.caic(fl)
plot(tree.owls)
tree.owls
unlink(fl) # delete the file "ex.tre"
</code></pre>

<hr>
<h2 id='read.dna'>Read DNA Sequences in a File</h2><span id='topic+read.dna'></span><span id='topic+read.FASTA'></span><span id='topic+read.fastq'></span>

<h3>Description</h3>

<p>These functions read DNA sequences in a file, and returns a matrix or a
list of DNA sequences with the names of the taxa read in the file as
rownames or names, respectively. By default, the sequences are returned
in binary format, otherwise (if <code>as.character = TRUE</code>) in
lowercase.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.dna(file, format = "interleaved", skip = 0,
         nlines = 0, comment.char = "#",
         as.character = FALSE, as.matrix = NULL)
read.FASTA(file, type = "DNA")
read.fastq(file, offset = -33)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.dna_+3A_file">file</code></td>
<td>
<p>a file name specified by either a variable of mode character,
or a double-quoted string. Can also be a <a href="base.html#topic+connection">connection</a> (which
will be opened for reading if necessary, and if so
<code><a href="base.html#topic+close">close</a></code>d (and hence destroyed) at the end of the
function call). Files compressed with GZIP can be read (the name
must end with .gz), as well as remote files.</p>
</td></tr>
<tr><td><code id="read.dna_+3A_format">format</code></td>
<td>
<p>a character string specifying the format of the DNA
sequences. Four choices are possible: <code>"interleaved"</code>,
<code>"sequential"</code>, <code>"clustal"</code>, or <code>"fasta"</code>, or any
unambiguous abbreviation of these.</p>
</td></tr>
<tr><td><code id="read.dna_+3A_skip">skip</code></td>
<td>
<p>the number of lines of the input file to skip before
beginning to read data (ignored for FASTA files; see below).</p>
</td></tr>
<tr><td><code id="read.dna_+3A_nlines">nlines</code></td>
<td>
<p>the number of lines to be read (by default the file is
read untill its end; ignored for FASTA files)).</p>
</td></tr>
<tr><td><code id="read.dna_+3A_comment.char">comment.char</code></td>
<td>
<p>a single character, the remaining of the line
after this character is ignored (ignored for FASTA files).</p>
</td></tr>
<tr><td><code id="read.dna_+3A_as.character">as.character</code></td>
<td>
<p>a logical controlling whether to return the
sequences as an object of class <code>"DNAbin"</code> (the default).</p>
</td></tr>
<tr><td><code id="read.dna_+3A_as.matrix">as.matrix</code></td>
<td>
<p>(used if <code>format = "fasta"</code>) one of the three
followings: (i) <code>NULL</code>: returns the sequences in a matrix if
they are of the same length, otherwise in a list; (ii) <code>TRUE</code>:
returns the sequences in a matrix, or stops with an error if they
are of different lengths; (iii) <code>FALSE</code>: always returns the
sequences in a list.</p>
</td></tr>
<tr><td><code id="read.dna_+3A_type">type</code></td>
<td>
<p>a character string giving the type of the sequences: one of
<code>"DNA"</code> or <code>"AA"</code> (case-independent, can be abbreviated).</p>
</td></tr>
<tr><td><code id="read.dna_+3A_offset">offset</code></td>
<td>
<p>the value to be added to the quality scores (the default
applies to the Sanger format and should work for most recent FASTQ
files).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>read.dna</code> follows the interleaved and sequential formats defined
in PHYLIP (Felsenstein, 1993) but with the original feature than there
is no restriction on the lengths of the taxa names. For these two
formats, the first line of the file must contain the dimensions of the
data (the numbers of taxa and the numbers of nucleotides); the
sequences are considered as aligned and thus must be of the same
lengths for all taxa. For the FASTA and FASTQ formats, the conventions
defined in the references are followed; the sequences are taken as
non-aligned. For all formats, the nucleotides can be arranged in any
way with blanks and line-breaks inside (with the restriction that the
first ten nucleotides must be contiguous for the interleaved and
sequential formats, see below). The names of the sequences are read in
the file. Particularities for each format are detailed below.
</p>

<ul>
<li><p> Interleaved: the function starts to read the sequences after it
finds one or more spaces (or tabulations). All characters before the
sequences are taken as the taxa names after removing the leading and
trailing spaces (so spaces in taxa names are not allowed). It is
assumed that the taxa names are not repeated in the subsequent
blocks of nucleotides.
</p>
</li>
<li><p> Sequential: the same criterion than for the interleaved format
is used to start reading the sequences and the taxa names; the
sequences are then read until the number of nucleotides specified in
the first line of the file is reached. This is repeated for each taxa.
</p>
</li>
<li><p> Clustal: this is the format output by the Clustal programs
(.aln). It is close to the interleaved format: the differences are
that the dimensions of the data are not indicated in the file, and
the names of the sequences are repeated in each block.
</p>
</li>
<li><p> FASTA: this looks like the sequential format but the taxa names
(or a description of the sequence) are on separate lines beginning
with a &lsquo;greater than&rsquo; character &lsquo;&gt;&rsquo; (there may be leading spaces
before this character). These lines are taken as taxa names after
removing the &lsquo;&gt;&rsquo; and the possible leading and trailing spaces. All
the data in the file before the first sequence are ignored.
</p>
</li></ul>

<p>The FASTQ format is explained in the references.
</p>
<p>Compressed files must be read through connections (see examples).
<code>read.fastq</code> can read compressed files directly (see
examples).
</p>


<h3>Value</h3>

<p>a matrix or a list (if <code>format = "fasta"</code>) of DNA sequences
stored in binary format, or of mode character (if <code>as.character =
    "TRUE"</code>).
</p>
<p><code>read.FASTA</code> always returns a list of class <code>"DNAbin"</code> or
<code>"AAbin"</code>.
</p>
<p><code>read.fastq</code> returns a list of class <code>"DNAbin"</code> with an
atrribute <code>"QUAL"</code> (see examples).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis and RJ Ewing</p>


<h3>References</h3>

<p>Anonymous. FASTA format. <a href="https://en.wikipedia.org/wiki/FASTA_format">https://en.wikipedia.org/wiki/FASTA_format</a>
</p>
<p>Anonymous. FASTQ format. <a href="https://en.wikipedia.org/wiki/FASTQ_format">https://en.wikipedia.org/wiki/FASTQ_format</a>
</p>
<p>Felsenstein, J. (1993) Phylip (Phylogeny Inference Package) version
3.5c. Department of Genetics, University of Washington.
<a href="http://evolution.genetics.washington.edu/phylip/phylip.html">http://evolution.genetics.washington.edu/phylip/phylip.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.GenBank">read.GenBank</a></code>, <code><a href="#topic+write.dna">write.dna</a></code>,
<code><a href="#topic+DNAbin">DNAbin</a></code>, <code><a href="#topic+dist.dna">dist.dna</a></code>, <code><a href="#topic+woodmouse">woodmouse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1. Simple text files

TEXTfile &lt;- tempfile("exdna", fileext = ".txt")

## 1a. Extract from data(woodmouse) in sequential format:
cat("3 40",
"No305     NTTCGAAAAACACACCCACTACTAAAANTTATCAGTCACT",
"No304     ATTCGAAAAACACACCCACTACTAAAAATTATCAACCACT",
"No306     ATTCGAAAAACACACCCACTACTAAAAATTATCAATCACT",
file = TEXTfile, sep = "\n")
ex.dna &lt;- read.dna(TEXTfile, format = "sequential")
str(ex.dna)
ex.dna

## 1b. The same data in interleaved format, ...
cat("3 40",
"No305     NTTCGAAAAA CACACCCACT",
"No304     ATTCGAAAAA CACACCCACT",
"No306     ATTCGAAAAA CACACCCACT",
"          ACTAAAANTT ATCAGTCACT",
"          ACTAAAAATT ATCAACCACT",
"          ACTAAAAATT ATCAATCACT",
file = TEXTfile, sep = "\n")
ex.dna2 &lt;- read.dna(TEXTfile)

## 1c. ... in clustal format, ...
cat("CLUSTAL (ape) multiple sequence alignment", "",
"No305     NTTCGAAAAACACACCCACTACTAAAANTTATCAGTCACT",
"No304     ATTCGAAAAACACACCCACTACTAAAAATTATCAACCACT",
"No306     ATTCGAAAAACACACCCACTACTAAAAATTATCAATCACT",
"           ************************** ******  ****",
file = TEXTfile, sep = "\n")
ex.dna3 &lt;- read.dna(TEXTfile, format = "clustal")

## 1d. ... and in FASTA format
FASTAfile &lt;- tempfile("exdna", fileext = ".fas")
cat("&gt;No305",
"NTTCGAAAAACACACCCACTACTAAAANTTATCAGTCACT",
"&gt;No304",
"ATTCGAAAAACACACCCACTACTAAAAATTATCAACCACT",
"&gt;No306",
"ATTCGAAAAACACACCCACTACTAAAAATTATCAATCACT",
file = FASTAfile, sep = "\n")
ex.dna4 &lt;- read.dna(FASTAfile, format = "fasta")

## The 4 data objects are the same:
identical(ex.dna, ex.dna2)
identical(ex.dna, ex.dna3)
identical(ex.dna, ex.dna4)

## 2. How to read GZ compressed files

## create a GZ file and open a connection:
GZfile &lt;- tempfile("exdna", fileext = ".fas.gz")
con &lt;- gzfile(GZfile, "wt")
## write the data using the connection:
cat("&gt;No305", "NTTCGAAAAACACACCCACTACTAAAANTTATCAGTCACT",
    "&gt;No304", "ATTCGAAAAACACACCCACTACTAAAAATTATCAACCACT",
    "&gt;No306", "ATTCGAAAAACACACCCACTACTAAAAATTATCAATCACT",
    file = con, sep = "\n")
close(con) # close the connection

## read the GZ'ed file:
ex.dna5 &lt;- read.dna(gzfile(GZfile), "fasta")

## This example is with a FASTA file but this works as well
## with the other formats described above.

## All 5 data objects are identical:
identical(ex.dna, ex.dna5)

unlink(c(TEXTfile, FASTAfile, GZfile)) # clean-up

## Not run: 
## 3. How to read files from a ZIP archive

## NOTE: since ape 5.7-1, all files in these examples are written
## in the temporary directory, thus the following commands work
## best when run in the user's working directory.

## write the woodmouse data in a FASTA file:
data(woodmouse)
write.dna(woodmouse, "woodmouse.fas", "fasta")
## archive a FASTA file in a ZIP file:
zip("myarchive.zip", "woodmouse.fas")
## Note: the file myarchive.zip is created if necessary

## Read the FASTA file from the ZIP archive without extraction:
wood2 &lt;- read.dna(unz("myarchive.zip", "woodmouse.fas"), "fasta")

## Alternatively, unzip the archive:
fl &lt;- unzip("myarchive.zip")
## the previous command eventually creates locally
## the fullpath archived with 'woodmouse.fas'
wood3 &lt;- read.dna(fl, "fasta")

identical(woodmouse, wood2)
identical(woodmouse, wood3)

## End(Not run)

## read a FASTQ file from 1000 Genomes:
## Not run: 
a &lt;- "https://ftp.1000genomes.ebi.ac.uk/vol1/ftp/phase3/data/HG00096/sequence_read/"
file &lt;- "SRR062641.filt.fastq.gz"
URL &lt;- paste0(a, file)
download.file(URL, file)
## If the above command doesn't work, you may copy/paste URL in
## a Web browser instead.
X &lt;- read.fastq(file)
X # 109,811 sequences
## get the qualities of the first sequence:
(qual1 &lt;- attr(X, "QUAL")[[1]])
## the corresponding probabilities:
10^(-qual1/10)
## get the mean quality for each sequence:
mean.qual &lt;- sapply(attr(X, "Q"), mean)
## can do the same for var, sd, ...

## End(Not run)</code></pre>

<hr>
<h2 id='read.GenBank'>Read DNA Sequences from GenBank via Internet</h2><span id='topic+read.GenBank'></span>

<h3>Description</h3>

<p>This function connects to the GenBank database, and reads nucleotide
sequences using accession numbers given as arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.GenBank(access.nb, seq.names = access.nb, species.names = TRUE,
             as.character = FALSE, chunk.size = 400, quiet = TRUE,
             type = "DNA")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.GenBank_+3A_access.nb">access.nb</code></td>
<td>
<p>a vector of mode character giving the accession numbers.</p>
</td></tr>
<tr><td><code id="read.GenBank_+3A_seq.names">seq.names</code></td>
<td>
<p>the names to give to each sequence; by default the
accession numbers are used.</p>
</td></tr>
<tr><td><code id="read.GenBank_+3A_species.names">species.names</code></td>
<td>
<p>a logical indicating whether to attribute the
species names to the returned object.</p>
</td></tr>
<tr><td><code id="read.GenBank_+3A_as.character">as.character</code></td>
<td>
<p>a logical controlling whether to return the
sequences as an object of class <code>"DNAbin"</code> (the default).</p>
</td></tr>
<tr><td><code id="read.GenBank_+3A_chunk.size">chunk.size</code></td>
<td>
<p>the number of sequences downloaded together (see
details).</p>
</td></tr>
<tr><td><code id="read.GenBank_+3A_quiet">quiet</code></td>
<td>
<p>a logical value indicating whether to show the progress
of the downloads. If <code>TRUE</code>, will also print the (full) name of
the FASTA file containing the downloaded sequences.</p>
</td></tr>
<tr><td><code id="read.GenBank_+3A_type">type</code></td>
<td>
<p>a character specifying to download &quot;DNA&quot; (nucleotide) or
&quot;AA&quot; (amino acid) sequences.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the site <a href="https://www.ncbi.nlm.nih.gov/">https://www.ncbi.nlm.nih.gov/</a> from
where the sequences are retrieved.
</p>
<p>If <code>species.names = TRUE</code>, the returned list has an attribute
<code>"species"</code> containing the names of the species taken from the
field &ldquo;ORGANISM&rdquo; in GenBank.
</p>
<p>Since <span class="pkg">ape</span> 3.6, this function retrieves the sequences in FASTA
format: this is more efficient and more flexible (scaffolds and
contigs can be read) than what was done in previous versions. The
option <code>gene.names</code> has been removed in <span class="pkg">ape</span> 5.4; this
information is also present in the description.
</p>
<p>Setting <code>species.names = FALSE</code> is much faster (could be useful
if you read a series of scaffolds or contigs, or if you already have
the species names).
</p>
<p>The argument <code>chunk.size</code> is set by default to 400 which is
likely to work in many cases. If an error occurs such as &ldquo;Cannot open
file ...&rdquo; showing the list of the accession numbers, then you may
try decreasing <code>chunk.size</code> to 200 or 300.
</p>
<p>If <code>quiet = FALSE</code>, the display is done chunk by chunk, so the
message &ldquo;Downloading sequences: 400 / 400 ...&rdquo; means that the
download from sequence 1 to sequence 400 is under progress (it is not
possible to display a more accurate message because the download
method depends on the platform).
</p>


<h3>Value</h3>

<p>A list of DNA sequences made of vectors of class <code>"DNAbin"</code>, or
of single characters (if <code>as.character = TRUE</code>) with two
attributes (species and description).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis and Klaus Schliep</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.dna">read.dna</a></code>, <code><a href="#topic+write.dna">write.dna</a></code>,
<code><a href="#topic+dist.dna">dist.dna</a></code>, <code><a href="#topic+DNAbin">DNAbin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This won't work if your computer is not connected
## to the Internet

## Get the 8 sequences of tanagers (Ramphocelus)
## as used in Paradis (1997)
ref &lt;- c("U15717", "U15718", "U15719", "U15720",
         "U15721", "U15722", "U15723", "U15724")
## Copy/paste or type the following commands if you
## want to try them.
## Not run: 
Rampho &lt;- read.GenBank(ref)
## get the species names:
attr(Rampho, "species")
## build a matrix with the species names and the accession numbers:
cbind(attr(Rampho, "species"), names(Rampho))
## print the first sequence
## (can be done with `Rampho$U15717' as well)
Rampho[[1]]
## the description from each FASTA sequence:
attr(Rampho, "description")

## End(Not run)
</code></pre>

<hr>
<h2 id='read.gff'>Read GFF Files</h2><span id='topic+read.gff'></span>

<h3>Description</h3>

<p>This function reads a file in general feature format version 3 (GFF3)
and returns a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.gff(file, na.strings = c(".", "?"), GFF3 = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.gff_+3A_file">file</code></td>
<td>
<p>a file name specified by a character string.</p>
</td></tr>
<tr><td><code id="read.gff_+3A_na.strings">na.strings</code></td>
<td>
<p>the strings in the GFF file that will be converted
as NA's (missing values).</p>
</td></tr>
<tr><td><code id="read.gff_+3A_gff3">GFF3</code></td>
<td>
<p>a logical value specifying whether if the file is
formatted according to version 3 of GFF.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned data frame has its (column) names correctly set (see
References) and the categorical variables (seqid, source, type,
strand, and phase) set as factors.
</p>
<p>This function should be more efficient than using <code>read.delim</code>.
</p>
<p>GFF2 (aka GTF) files can also be read: use <code>GFF3 = FALSE</code> to have
the correct field names. Note that GFF2 files and GFF3 files have the
same structure, although some fields are slightly different (see
reference).
</p>
<p>The file can be gz-compressed (see examples), but not zipped.
</p>


<h3>Value</h3>

<p>NULL</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/General_feature_format">https://en.wikipedia.org/wiki/General_feature_format</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## requires to be connected on Internet
d &lt;- "https://ftp.ensembl.org/pub/release-86/gff3/homo_sapiens/"
f &lt;- "Homo_sapiens.GRCh38.86.chromosome.MT.gff3.gz"
download.file(paste0(d, f), "mt_gff3.gz")
## If the above command doesn't work, you may copy/paste the full URL in
## a Web browser instead.
gff.mito &lt;- read.gff("mt_gff3.gz")
## the lengths of the sequence features:
gff.mito$end - (gff.mito$start - 1)
table(gff.mito$type)
## where the exons start:
gff.mito$start[gff.mito$type == "exon"]

## End(Not run)
</code></pre>

<hr>
<h2 id='read.nexus'>Read Tree File in Nexus Format</h2><span id='topic+read.nexus'></span>

<h3>Description</h3>

<p>This function reads one or several trees in a NEXUS file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.nexus(file, tree.names = NULL, force.multi = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.nexus_+3A_file">file</code></td>
<td>
<p>a file name specified by either a variable of mode character,
or a double-quoted string.</p>
</td></tr>
<tr><td><code id="read.nexus_+3A_tree.names">tree.names</code></td>
<td>
<p>if there are several trees to be read, a vector of
mode character giving names to the individual trees (by default,
this uses the labels in the NEXUS file if these are present).</p>
</td></tr>
<tr><td><code id="read.nexus_+3A_force.multi">force.multi</code></td>
<td>
<p>a logical value; if <code>TRUE</code>, an object of class
<code>"multiPhylo"</code> is always returned even if the file contains a
single tree (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The present implementation tries to follow as much as possible the
NEXUS standard (but see the restriction below on TRANSLATION
tables). Only the block &ldquo;TREES&rdquo; is read; the other data can be read
with other functions (e.g., <code><a href="#topic+read.dna">read.dna</a></code>,
<code><a href="utils.html#topic+read.table">read.table</a></code>, ...).
</p>
<p>If a TRANSLATION table is present it is assumed that only the tip
labels are translated and they are all translated with integers
without gap. Consequently, if nodes have labels in the tree(s) they
are read as they are and not looked for in the translation table. The
logic behind this is that in the vast majority of cases, node labels
will be support values rather than proper taxa names. This is
consistent with <code><a href="#topic+write.nexus">write.nexus</a></code> which translates only the
tip labels.
</p>
<p>Using <code>force.multi = TRUE</code> when the file contains a single tree
makes possible to keep the tree name (as names of the list).
</p>
<p>&lsquo;read.nexus&rsquo; tries to represent correctly trees with a badly
represented root edge (i.e. with an extra pair of parentheses). For
instance, the tree &quot;((A:1,B:1):10);&quot; will be read like &quot;(A:1,B:1):10;&quot;
but a warning message will be issued in the former case as this is
apparently not a valid Newick format. If there are two root edges
(e.g., &quot;(((A:1,B:1):10):10);&quot;), then the tree is not read and an error
message is issued.
</p>


<h3>Value</h3>

<p>an object of class <code>"phylo"</code> or <code>"multiPhylo"</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Maddison, D. R., Swofford, D. L. and Maddison, W. P. (1997) NEXUS: an
extensible file format for systematic information. <em>Systematic
Biology</em>, <b>46</b>, 590&ndash;621.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.tree">read.tree</a></code>, <code><a href="#topic+write.nexus">write.nexus</a></code>,
<code><a href="#topic+write.tree">write.tree</a></code>, <code><a href="#topic+read.nexus.data">read.nexus.data</a></code>,
<code><a href="#topic+write.nexus.data">write.nexus.data</a></code>
</p>

<hr>
<h2 id='read.nexus.data'>
Read Character Data In NEXUS Format
</h2><span id='topic+read.nexus.data'></span><span id='topic+nexus2DNAbin'></span>

<h3>Description</h3>

<p><code>read.nexus.data</code> reads a file with sequences in the NEXUS
format. <code>nexus2DNAbin</code> is a helper function to convert the output
from the previous function into the class <code>"DNAbin"</code>.
</p>
<p>For the moment, only sequence data (DNA or protein) are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.nexus.data(file)
nexus2DNAbin(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.nexus.data_+3A_file">file</code></td>
<td>
<p>a file name specified by either a variable of mode
character, or a double-quoted string.</p>
</td></tr>
<tr><td><code id="read.nexus.data_+3A_x">x</code></td>
<td>
<p>an object output by <code>read.nexus.data</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This parser tries to read data from a file written in a
<em>restricted</em> NEXUS format (see examples below).
</p>
<p>Please see files &lsquo;<span class="file">data.nex</span>&rsquo; and &lsquo;<span class="file">taxacharacters.nex</span>&rsquo; for
examples of formats that will work.
</p>
<p>Some noticeable exceptions from the NEXUS standard (non-exhaustive
list):
</p>

<ul>
<li> <p><b>I</b>: Comments must be either on separate lines or at the
end of lines. Examples:<br />
<code>[Comment]</code> <b>&mdash; OK</b><br />
<code>Taxon ACGTACG [Comment]</code> <b>&mdash; OK</b><br />
<code>[Comment line 1</code>
</p>
<p><code>Comment line 2]</code> <b>&mdash; NOT OK!</b><br />
<code>Tax[Comment]on ACG[Comment]T</code> <b>&mdash; NOT OK!</b>
</p>
</li>
<li> <p><b>II</b>: No spaces (or comments) are allowed in the
sequences. Examples:<br />
<code>name ACGT</code> <b>&mdash; OK</b><br />
<code>name AC GT</code> <b>&mdash; NOT OK!</b>
</p>
</li>
<li> <p><b>III</b>: No spaces are allowed in taxon names, not even if
names are in single quotes. That is, single-quoted names are not
treated as such by the parser. Examples:<br />
<code>Genus_species</code> <b>&mdash; OK</b><br />
<code>'Genus_species'</code> <b>&mdash; OK</b><br />
<code>'Genus species'</code> <b>&mdash; NOT OK!</b>
</p>
</li>
<li> <p><b>IV</b>: The trailing <code>end</code> that closes the
<code>matrix</code> must be on a separate line. Examples:<br />
<code>taxon AACCGGT</code>
</p>
<p><code>end;</code> <b>&mdash; OK</b><br />
<code>taxon AACCGGT;</code>
</p>
<p><code>end;</code> <b>&mdash; OK</b><br />
<code>taxon AACCCGT; end;</code> <b>&mdash; NOT OK!</b>
</p>
</li>
<li> <p><b>V</b>: Multistate characters are not allowed. That is,
NEXUS allows you to specify multiple character states at a
character position either as an uncertainty, <code>(XY)</code>, or as an
actual appearance of multiple states, <code>{XY}</code>. This is
information is not handled by the parser. Examples:<br />
<code>taxon 0011?110</code> <b>&mdash; OK</b><br />
<code>taxon 0011{01}110</code> <b>&mdash; NOT OK!</b><br />
<code>taxon 0011(01)110</code> <b>&mdash; NOT OK!</b>
</p>
</li>
<li> <p><b>VI</b>: The number of taxa must be on the same line as
<code>ntax</code>. The same applies to <code>nchar</code>. Examples:<br />
<code>ntax = 12</code> <b>&mdash; OK</b><br />
<code>ntax =</code>
</p>
<p><code>12</code> <b>&mdash; NOT OK!</b>
</p>
</li>
<li> <p><b>VII</b>: The word &ldquo;matrix&rdquo; can not occur anywhere in
the file before the actual <code>matrix</code> command, unless it is in
a comment. Examples:<br />
<code>BEGIN CHARACTERS;</code>
</p>
<p><code>TITLE 'Data in file "03a-cytochromeB.nex"';</code>
</p>
<p><code>DIMENSIONS  NCHAR=382;</code>
</p>
<p><code>FORMAT DATATYPE=Protein GAP=- MISSING=?;</code>
</p>
<p><code>["This is The Matrix"]</code> <b>&mdash; OK</b>
</p>
<p><code>MATRIX</code><br />
</p>
<p><code>BEGIN CHARACTERS;</code>
</p>
<p><code>TITLE 'Matrix in file "03a-cytochromeB.nex"';</code> <b>&mdash; NOT OK!</b>
</p>
<p><code>DIMENSIONS  NCHAR=382;</code>
</p>
<p><code>FORMAT DATATYPE=Protein GAP=- MISSING=?;</code>
</p>
<p><code>MATRIX</code>
</p>
</li></ul>



<h3>Value</h3>

<p>A list of sequences each made of a single vector of mode character
where each element is a (phylogenetic) character state.
</p>


<h3>Author(s)</h3>

<p>Johan Nylander, Thomas Guillerme, and Klaus Schliep</p>


<h3>References</h3>

<p>Maddison, D. R., Swofford, D. L. and Maddison, W. P. (1997) NEXUS: an
extensible file format for systematic information. <em>Systematic
Biology</em>, <b>46</b>, 590&ndash;621.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.nexus">read.nexus</a></code>, <code><a href="#topic+write.nexus">write.nexus</a></code>,
<code><a href="#topic+write.nexus.data">write.nexus.data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use read.nexus.data to read a file in NEXUS format into object x
## Not run: x &lt;- read.nexus.data("file.nex")
</code></pre>

<hr>
<h2 id='read.tree'>Read Tree File in Parenthetic Format</h2><span id='topic+read.tree'></span><span id='topic+phylo'></span>

<h3>Description</h3>

<p>This function reads a file which contains one or several trees in
parenthetic format known as the Newick or New Hampshire format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.tree(file = "", text = NULL, tree.names = NULL, skip = 0,
    comment.char = "", keep.multi = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.tree_+3A_file">file</code></td>
<td>
<p>a file name specified by either a variable of mode character,
or a double-quoted string; if <code>file = ""</code> (the default) then the
tree is input on the keyboard, the entry being terminated with a
blank line.</p>
</td></tr>
<tr><td><code id="read.tree_+3A_text">text</code></td>
<td>
<p>alternatively, the name of a variable of mode character
which contains the tree(s) in parenthetic format. By default, this
is ignored (set to <code>NULL</code>, meaning that the tree is read in a
file); if <code>text</code> is not <code>NULL</code>, then the argument
<code>file</code> is ignored.</p>
</td></tr>
<tr><td><code id="read.tree_+3A_tree.names">tree.names</code></td>
<td>
<p>if there are several trees to be read, a vector of
mode character that gives names to the individual trees; if
<code>NULL</code> (the default), the trees are named <code>"tree1"</code>,
<code>"tree2"</code>, ...</p>
</td></tr>
<tr><td><code id="read.tree_+3A_skip">skip</code></td>
<td>
<p>the number of lines of the input file to skip before
beginning to read data (this is passed directly to<code> scan()</code>).</p>
</td></tr>
<tr><td><code id="read.tree_+3A_comment.char">comment.char</code></td>
<td>
<p>a single character, the remaining of the line
after this character is ignored (this is passed directly to
<code>scan()</code>).</p>
</td></tr>
<tr><td><code id="read.tree_+3A_keep.multi">keep.multi</code></td>
<td>
<p>if <code>TRUE</code> and <code>tree.names = NULL</code> then
single trees are returned in <code>"multiPhylo"</code> format, with any
name that is present (see details). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="read.tree_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>scan()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default option for <code>file</code> allows to type directly the tree on
the keyboard (or possibly to copy from an editor and paste in R's
console) with, e.g., <code>mytree &lt;- read.tree()</code>.
</p>
<p>&lsquo;read.tree&rsquo; tries to represent correctly trees with a badly
represented root edge (i.e. with an extra pair of parentheses). For
instance, the tree &quot;((A:1,B:1):10);&quot; will be read like &quot;(A:1,B:1):10;&quot;
but a warning message will be issued in the former case as this is
apparently not a valid Newick format. If there are two root edges
(e.g., &quot;(((A:1,B:1):10):10);&quot;), then the tree is not read and an error
message is issued.
</p>
<p>If there are any characters preceding the first &quot;(&quot; in a line then
this is assigned to the name. This is returned when a &quot;multiPhylo&quot;
object is returned and <code>tree.names = NULL</code>.
</p>
<p>Until <span class="pkg">ape</span> 4.1, the default of <code>comment.char</code> was <code>"#"</code>
(as in <code>scan</code>). This has been changed so that extended Newick
files can be read.
</p>


<h3>Value</h3>

<p>an object of class <code>"phylo"</code> with the following components:
</p>
<table>
<tr><td><code>edge</code></td>
<td>
<p>a two-column matrix of mode numeric where each row
represents an edge of the tree; the nodes and the tips are
symbolized with numbers; the tips are numbered 1, 2, ..., and the
nodes are numbered after the tips. For each row, the first column
gives the ancestor.</p>
</td></tr>
<tr><td><code>edge.length</code></td>
<td>
<p>(optional) a numeric vector giving the lengths of the
branches given by <code>edge</code>.</p>
</td></tr>
<tr><td><code>tip.label</code></td>
<td>
<p>a vector of mode character giving the names of the
tips; the order of the names in this vector corresponds to the
(positive) number in <code>edge</code>.</p>
</td></tr>
<tr><td><code>Nnode</code></td>
<td>
<p>the number of (internal) nodes.</p>
</td></tr>
<tr><td><code>node.label</code></td>
<td>
<p>(optional) a vector of mode character giving the
names of the nodes.</p>
</td></tr>
<tr><td><code>root.edge</code></td>
<td>
<p>(optional) a numeric value giving the length of the
branch at the root if it exists.</p>
</td></tr>
</table>
<p>If several trees are read in the file, the returned object is of class
<code>"multiPhylo"</code>, and is a list of objects of class <code>"phylo"</code>.
The name of each tree can be specified by <code>tree.names</code>, or can be
read from the file (see details).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis and Daniel Lawson <a href="mailto:dan.lawson@bristol.ac.uk">dan.lawson@bristol.ac.uk</a></p>


<h3>References</h3>

<p>Felsenstein, J. The Newick tree format.
<a href="http://evolution.genetics.washington.edu/phylip/newicktree.html">http://evolution.genetics.washington.edu/phylip/newicktree.html</a>
</p>
<p>Olsen, G. Interpretation of the &quot;Newick's 8:45&quot; tree format standard.
<a href="http://evolution.genetics.washington.edu/phylip/newick_doc.html">http://evolution.genetics.washington.edu/phylip/newick_doc.html</a>
</p>
<p>Paradis, E. (2020) Definition of Formats for Coding Phylogenetic Trees
in R. <a href="https://emmanuelparadis.github.io/misc/FormatTreeR.pdf">https://emmanuelparadis.github.io/misc/FormatTreeR.pdf</a>
</p>
<p>Paradis, E. (2012) <em>Analysis of Phylogenetics and Evolution with
R (Second Edition).</em> New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.tree">write.tree</a></code>, <code><a href="#topic+read.nexus">read.nexus</a></code>,
<code><a href="#topic+write.nexus">write.nexus</a></code>, <code><a href="base.html#topic+scan">scan</a></code> for the basic R
function to read data in a file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### An extract from Sibley and Ahlquist (1990)
s &lt;- "owls(((Strix_aluco:4.2,Asio_otus:4.2):3.1,Athene_noctua:7.3):6.3,Tyto_alba:13.5);"
treefile &lt;- tempfile("tree", fileext = ".tre")
cat(s, file = treefile, sep = "\n")
tree.owls &lt;- read.tree(treefile)
str(tree.owls)
tree.owls
tree.owls &lt;- read.tree(treefile, keep.multi = TRUE)
tree.owls
names(tree.owls)
unlink(treefile) # clean-up
### Only the first three species using the option `text'
TREE &lt;- "((Strix_aluco:4.2,Asio_otus:4.2):3.1,Athene_noctua:7.3);"
TREE
tree.owls.bis &lt;- read.tree(text = TREE)
str(tree.owls.bis)
tree.owls.bis

## tree with singleton nodes:
ts &lt;- read.tree(text = "((((a))),d);")
plot(ts, node.depth = 2) # the default will overlap the singleton node with the tip
nodelabels()

## 'skeleton' tree with a singleton node:
tx &lt;- read.tree(text = "(((,)),);")
plot(tx, node.depth = 2)
nodelabels()

## a tree with single quoted labels (the 2nd label is not quoted
## because it has no white spaces):
z &lt;- "(('a: France, Spain (Europe)',b),'c: Australia [Outgroup]');"
tz &lt;- read.tree(text = z)
plot(tz, font = 1)
</code></pre>

<hr>
<h2 id='reconstruct'>Continuous Ancestral Character Estimation</h2><span id='topic+reconstruct'></span>

<h3>Description</h3>

<p>This function estimates ancestral character states, and the associated
uncertainty, for continuous characters. It mainly works as the ace
function, from which it differs, first, in the fact that computations
are not performed by numerical optimisation but through matrix
calculus. Second, besides classical Brownian-based reconstruction
methods, it reconstructs ancestral states under Arithmetic Brownian
Motion (ABM, i.e. Brownian with linear trend) and Ornstein-Uhlenbeck
process (OU, i.e. Brownian with an attractive optimum).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconstruct(x, phyInit, method = "ML", alpha = NULL,
            low_alpha = 0.0001, up_alpha = 1, CI = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reconstruct_+3A_x">x</code></td>
<td>
<p>a numerical vector.</p>
</td></tr>
<tr><td><code id="reconstruct_+3A_phyinit">phyInit</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="reconstruct_+3A_method">method</code></td>
<td>
<p>a character specifying the method used for
estimation. Six choices are possible: <code>"ML"</code>, <code>"REML"</code>, <code>"GLS"</code>, <code>"GLS_ABM"</code>, <code>"GLS_OU"</code> or <code>"GLS_OUS"</code>.</p>
</td></tr>
<tr><td><code id="reconstruct_+3A_alpha">alpha</code></td>
<td>
<p>a numerical value which accounts for the attractive strength parameter of <code>"GLS_OU"</code> or <code>"GLS_OUS"</code> (used only in these cases). If alpha = NULL (the default), then it is estimated by maximum likelihood using <code>optim</code>, with <code>low_alpha</code> (resp. <code>up_alpha</code>) as lower value (resp. upper value), which may lead to convergence issue.</p>
</td></tr>
<tr><td><code id="reconstruct_+3A_low_alpha">low_alpha</code></td>
<td>
<p>a lower bound for alpha, used only with methods <code>"GLS_OU"</code> or <code>"GLS_OUS"</code>. It has to be positive.</p>
</td></tr>
<tr><td><code id="reconstruct_+3A_up_alpha">up_alpha</code></td>
<td>
<p>an upper bound for alpha, used only with methods <code>"GLS_OU"</code> or <code>"GLS_OUS"</code>. It has to be positive.</p>
</td></tr>
<tr><td><code id="reconstruct_+3A_ci">CI</code></td>
<td>
<p>a logical specifying whether to return the 95% confidence
intervals of the ancestral state estimates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>"ML"</code>, <code>"REML"</code> and <code>"GLS"</code>, the default model is Brownian motion. This model
can be fitted by maximum
likelihood (<code>method = "ML"</code>, Felsenstein 1973, Schluter et al. 1997) - the default, residual maximum likelihood (<code>method = "REML"</code>), or generalized least
squares (<code>method = "GLS"</code>, Martins and Hansen 1997, Garland T and Ives AR 2000).
<code>"GLS_ABM"</code> is based on Brownian motion with trend model. Both <code>"GLS_OU"</code> and <code>"GLS_OUS"</code> are based on Ornstein-Uhlenbeck model.
<code>"GLS_OU"</code> and <code>"GLS_OUS"</code> differs in the fact that <code>"GLS_OUS"</code> assume that the process starts from the optimum, while the root state has to be estimated for <code>"GLS_OU"</code>, which may rise some issues (see Royer-Carenzi and Didier, 2016). Users may provide the attractive strength parameter <code>alpha</code>, for these two models.
<code>"GLS_ABM"</code>, <code>"GLS_OU"</code> and <code>"GLS_OUS"</code> are all fitted by generalized least squares (Royer-Carenzi and Didier, 2016).
</p>


<h3>Value</h3>

<p>an object of class <code>"ace"</code> with the following elements:
</p>
<table>
<tr><td><code>ace</code></td>
<td>
<p>the estimates of the
ancestral character values.</p>
</td></tr>
<tr><td><code>CI95</code></td>
<td>
<p>the estimated 95%
confidence intervals.</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>if
<code>method = "ML"</code>, the maximum likelihood estimate of the
Brownian parameter.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>if <code>method = "ML"</code>, the maximum log-likelihood.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>GLS_ABM</code> should not be used on ultrametric tree.
</p>
<p><code>GLS_OU</code> may lead to aberrant reconstructions.
</p>


<h3>Author(s)</h3>

<p>Manuela Royer-Carenzi, Gilles Didier</p>


<h3>References</h3>

<p>Felsenstein, J. (1973) Maximum likelihood estimation of evolutionary
trees from continuous characters. <em>American Journal of Human
Genetics</em>, <b>25</b>, 471&ndash;492.
</p>
<p>Garland T. and Ives A.R. (2000) Using the past to predict the present:
confidence intervals for regression equations in phylogenetic
comparative methods. <em>American Naturalist</em>, <b>155</b>,
346&ndash;364.
</p>
<p>Martins, E. P. and Hansen, T. F. (1997) Phylogenies and the
comparative method: a general approach to incorporating phylogenetic
information into the analysis of interspecific data. <em>American
Naturalist</em>, <b>149</b>, 646&ndash;667.
</p>
<p>Royer-Carenzi, M. and Didier, G. (2016) A comparison of ancestral
state reconstruction methods for quantitative
characters. <em>Journal of Theoretical Biology</em>, <b>404</b>,
126&ndash;142.
</p>
<p>Schluter, D., Price, T., Mooers, A. O. and Ludwig, D. (1997)
Likelihood of ancestor states in adaptive radiation. <em>Evolution</em>,
<b>51</b>, 1699&ndash;1711.
</p>
<p>Yang, Z. (2006) <em>Computational Molecular Evolution</em>. Oxford:
Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MPR">MPR</a></code>, <code><a href="#topic+corBrownian">corBrownian</a></code>, <code><a href="#topic+compar.ou">compar.ou</a></code>
</p>
<p>Reconstruction of ancestral sequences can be done with the package
<span class="pkg">phangorn</span> (see function <code>?ancestral.pml</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Some random data...
data(bird.orders)
x &lt;- rnorm(23, m=100)
### Reconstruct ancestral quantitative characters:
reconstruct(x, bird.orders)
reconstruct(x, bird.orders, method = "GLS_OUS", alpha=NULL)
</code></pre>

<hr>
<h2 id='reorder.phylo'>Internal Reordering of Trees</h2><span id='topic+reorder.phylo'></span><span id='topic+reorder.multiPhylo'></span><span id='topic+cladewise'></span><span id='topic+postorder'></span>

<h3>Description</h3>

<p><code>reorder</code> changes the internal structure of a phylogeny stored as
an object of class <code>"phylo"</code>. The tree returned is the same than
the one input, but the ordering of the edges could be different.
</p>
<p><code>cladewise</code> and <code>postorder</code> are convenience functions to
return only the indices of the reordered edge matrices (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phylo'
reorder(x, order = "cladewise", index.only = FALSE, ...)
## S3 method for class 'multiPhylo'
reorder(x, order = "cladewise", ...)
cladewise(x)
postorder(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reorder.phylo_+3A_x">x</code></td>
<td>
<p>an object of class <code>"phylo"</code> or <code>"multiPhylo"</code>.</p>
</td></tr>
<tr><td><code id="reorder.phylo_+3A_order">order</code></td>
<td>
<p>a character string: either <code>"cladewise"</code> (the
default), <code>"postorder"</code>, <code>"pruningwise"</code>, or any
unambiguous abbreviation of these.</p>
</td></tr>
<tr><td><code id="reorder.phylo_+3A_index.only">index.only</code></td>
<td>
<p>should the function return only the ordered indices
of the rows of the edge matrix?</p>
</td></tr>
<tr><td><code id="reorder.phylo_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because in a tree coded as an object of class <code>"phylo"</code> each
branch is represented by a row in the element &lsquo;edge&rsquo;, there is an
arbitrary choice for the ordering of these rows. <code>reorder</code> allows
to reorder these rows according to three rules: in the
<code>"cladewise"</code> order each clade is formed by a series of
contiguous rows. In the <code>"postorder"</code> order, the rows are
arranged so that computations following pruning-like algorithm the
tree (or postorder tree traversal) can be done by descending along
these rows (conversely, a preorder tree traversal can be performed by
moving from the last to the first row). The <code>"pruningwise"</code> order
is an alternative &ldquo;pruning&rdquo; order which is actually a bottom-up
traversal order (Valiente 2002). (This third choice might be removed
in the future as it merely duplicates the second one which is more
efficient.) The possible multichotomies and branch lengths are preserved.
</p>
<p>Note that for a given order, there are several possible orderings of
the rows of &lsquo;edge&rsquo;.
</p>


<h3>Value</h3>

<p>an object of class <code>"phylo"</code> (with the attribute <code>"order"</code>
set accordingly), or a numeric vector if <code>index.only = TRUE</code>; if
<code>x</code> is of class <code>"multiPhylo"</code>, then an object of the same
class.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Valiente, G. (2002) <em>Algorithms on Trees and Graphs.</em> New York:
Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.tree">read.tree</a></code> to read tree files in Newick format,
<code><a href="stats.html#topic+reorder">reorder</a></code> for the generic function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bird.families)
tr &lt;- reorder(bird.families, "postorder")
all.equal(bird.families, tr) # uses all.equal.phylo actually
all.equal.list(bird.families, tr) # bypasses the generic

## get the number of descendants for each tip or node:
nr_desc &lt;-  function(x) {
    res &lt;- numeric(max(x$edge))
    res[1:Ntip(x)] &lt;- 1L
    for (i in postorder(x)) {
       tmp &lt;- x$edge[i,1]
       res[tmp] &lt;- res[tmp] + res[x$edge[i, 2]]
   }
   res
}
## apply it to a random tree:
tree &lt;- rtree(10)
plot(tree, show.tip.label = FALSE)
tiplabels()
nodelabels()
nr_desc(tree)
</code></pre>

<hr>
<h2 id='richness.yule.test'>Test of Diversification-Shift With the Yule Process</h2><span id='topic+richness.yule.test'></span>

<h3>Description</h3>

<p>This function performs a test of shift in diversification rate using
probabilities from the Yule process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>richness.yule.test(x, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="richness.yule.test_+3A_x">x</code></td>
<td>
<p>a matrix or a data frame with at least two columns: the first
one gives the number of species in clades with a trait supposed to
increase or decrease diversification rate, and the second one the number of
species in the sister-clades without the trait. Each
row represents a pair of sister-clades.</p>
</td></tr>
<tr><td><code id="richness.yule.test_+3A_t">t</code></td>
<td>
<p>a numeric vector giving the divergence times of each pair of
clades in <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with the <code class="reqn">\chi^2</code>, the number of degrees of
freedom (= 1), and the <em>P</em>-value.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Paradis, E. (2012) Shift in diversification in sister-clade
comparisons: a more powerful test. <em>Evolution</em>, <b>66</b>,
288&ndash;295.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slowinskiguyer.test">slowinskiguyer.test</a></code>, <code><a href="#topic+mcconwaysims.test">mcconwaysims.test</a></code>,
<code><a href="#topic+diversity.contrast.test">diversity.contrast.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### see example(mcconwaysims.test)
</code></pre>

<hr>
<h2 id='rlineage'>Tree Simulation Under the Time-Dependent Birth&ndash;Death Models</h2><span id='topic+rlineage'></span><span id='topic+rbdtree'></span><span id='topic+rphylo'></span><span id='topic+drop.fossil'></span>

<h3>Description</h3>

<p>These three functions simulate phylogenies under any time-dependent
birth&ndash;death model: <code>rlineage</code> generates a complete tree including
the species going extinct before present; <code>rbdtree</code> generates a
tree with only the species living at present (thus the tree is
ultrametric); <code>rphylo</code> generates a tree with a fixed number of
species at present time. <code>drop.fossil</code> is a utility function to
remove the extinct species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlineage(birth, death, Tmax = 50, BIRTH = NULL,
         DEATH = NULL, eps = 1e-6)
rbdtree(birth, death, Tmax = 50, BIRTH = NULL,
        DEATH = NULL, eps = 1e-6)
rphylo(n, birth, death, BIRTH = NULL, DEATH = NULL,
       T0 = 50, fossils = FALSE, eps = 1e-06)
drop.fossil(phy, tol = 1e-8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlineage_+3A_birth">birth</code>, <code id="rlineage_+3A_death">death</code></td>
<td>
<p>a numeric value or a (vectorized) function
specifying how speciation and extinction rates vary through time.</p>
</td></tr>
<tr><td><code id="rlineage_+3A_tmax">Tmax</code></td>
<td>
<p>a numeric value giving the length of the simulation.</p>
</td></tr>
<tr><td><code id="rlineage_+3A_birth">BIRTH</code>, <code id="rlineage_+3A_death">DEATH</code></td>
<td>
<p>a (vectorized) function which is the primitive
of <code>birth</code> or <code>death</code>. This can be used to speed-up the
computation. By default, a numerical integration is done.</p>
</td></tr>
<tr><td><code id="rlineage_+3A_eps">eps</code></td>
<td>
<p>a numeric value giving the time resolution of the
simulation; this may be increased (e.g., 0.001) to shorten
computation times.</p>
</td></tr>
<tr><td><code id="rlineage_+3A_n">n</code></td>
<td>
<p>the number of species living at present time.</p>
</td></tr>
<tr><td><code id="rlineage_+3A_t0">T0</code></td>
<td>
<p>the time at present (for the backward-in-time algorithm).</p>
</td></tr>
<tr><td><code id="rlineage_+3A_fossils">fossils</code></td>
<td>
<p>a logical value specifying whether to output the
lineages going extinct.</p>
</td></tr>
<tr><td><code id="rlineage_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="rlineage_+3A_tol">tol</code></td>
<td>
<p>a numeric value giving the tolerance to consider a species
as extinct.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These three functions use continuous-time algorithms: <code>rlineage</code>
and <code>rbdtree</code> use the forward-in-time algorithms described in
Paradis (2011), whereas <code>rphylo</code> uses a backward-in-time
algorithm from Stadler (2011). The models are time-dependent
birth&ndash;death models as  described in Kendall (1948). Speciation
(birth) and extinction (death) rates may be constant or vary through
time according to an <span class="rlang"><b>R</b></span> function specified by the user. In the latter
case, <code>BIRTH</code> and/or <code>DEATH</code> may be used if the primitives
of <code>birth</code> and <code>death</code> are known. In these functions time is
the formal argument and must be named <code>t</code>.
</p>
<p>Note that <code>rphylo</code> simulates trees in a way similar to what
the package <span class="pkg">TreeSim</span> does, the difference is in the
parameterization of the time-dependent models which is here the same
than used in the two other functions. In this parameterization scheme,
time is measured from past to present (see details in Paradis 2015
which includes a comparison of these algorithms).
</p>
<p>The difference between <code>rphylo</code> and <code>rphylo(... fossils
    = TRUE)</code> is the same than between <code>rbdtree</code> and <code>rlineage</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"phylo"</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Kendall, D. G. (1948) On the generalized &ldquo;birth-and-death&rdquo;
process. <em>Annals of Mathematical Statistics</em>, <b>19</b>, 1&ndash;15.
</p>
<p>Paradis, E. (2011) Time-dependent speciation and extinction from
phylogenies: a least squares approach. <em>Evolution</em>, <b>65</b>,
661&ndash;672.
</p>
<p>Paradis, E. (2015) Random phylogenies and the distribution of
branching times. <em>Journal of Theoretical Biology</em>, <b>387</b>,
39&ndash;45.
</p>
<p>Stadler, T. (2011) Simulating trees with a fixed number of extant
species. <em>Systematic Biology</em>, <b>60</b>, 676&ndash;684.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+yule">yule</a></code>, <code><a href="#topic+yule.time">yule.time</a></code>, <code><a href="#topic+birthdeath">birthdeath</a></code>,
<code><a href="#topic+rtree">rtree</a></code>, <code><a href="#topic+stree">stree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
plot(rlineage(0.1, 0)) # Yule process with lambda = 0.1
plot(rlineage(0.1, 0.05)) # simple birth-death process
b &lt;- function(t) 1/(1 + exp(0.2*t - 1)) # logistic
layout(matrix(0:3, 2, byrow = TRUE))
curve(b, 0, 50, xlab = "Time", ylab = "")
mu &lt;- 0.07
segments(0, mu, 50, mu, lty = 2)
legend("topright", c(expression(lambda), expression(mu)),
       lty = 1:2, bty = "n")
plot(rlineage(b, mu), show.tip.label = FALSE)
title("Simulated with 'rlineage'")
plot(rbdtree(b, mu), show.tip.label = FALSE)
title("Simulated with 'rbdtree'")
</code></pre>

<hr>
<h2 id='root'>Roots Phylogenetic Trees</h2><span id='topic+root'></span><span id='topic+root.phylo'></span><span id='topic+root.multiPhylo'></span><span id='topic+unroot'></span><span id='topic+unroot.phylo'></span><span id='topic+unroot.multiPhylo'></span><span id='topic+is.rooted'></span><span id='topic+is.rooted.phylo'></span><span id='topic+is.rooted.multiPhylo'></span>

<h3>Description</h3>

<p><code>root</code> reroots a phylogenetic tree with respect to the specified
outgroup or at the node specified in <code>node</code>.
</p>
<p><code>unroot</code> unroots a phylogenetic tree, or returns it unchanged if
it is already unrooted.
</p>
<p><code>is.rooted</code> tests whether a tree is rooted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>root(phy, ...)
## S3 method for class 'phylo'
root(phy, outgroup, node = NULL, resolve.root = FALSE,
     interactive = FALSE, edgelabel = FALSE, ...)
## S3 method for class 'multiPhylo'
root(phy, outgroup, ...)

unroot(phy, ...)
## S3 method for class 'phylo'
unroot(phy, collapse.singles = FALSE,
        keep.root.edge = FALSE, ...)
## S3 method for class 'multiPhylo'
unroot(phy, collapse.singles = FALSE,
        keep.root.edge = FALSE, ...)

is.rooted(phy)
## S3 method for class 'phylo'
is.rooted(phy)
## S3 method for class 'multiPhylo'
is.rooted(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="root_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code> or <code>"multiPhylo"</code>.</p>
</td></tr>
<tr><td><code id="root_+3A_outgroup">outgroup</code></td>
<td>
<p>a vector of mode numeric or character specifying the
new outgroup.</p>
</td></tr>
<tr><td><code id="root_+3A_node">node</code></td>
<td>
<p>alternatively, a node number where to root the tree.</p>
</td></tr>
<tr><td><code id="root_+3A_resolve.root">resolve.root</code></td>
<td>
<p>a logical specifying whether to resolve the new
root as a bifurcating node.</p>
</td></tr>
<tr><td><code id="root_+3A_interactive">interactive</code></td>
<td>
<p>if <code>TRUE</code> the user is asked to select the node
by clicking on the tree which must be plotted.</p>
</td></tr>
<tr><td><code id="root_+3A_edgelabel">edgelabel</code></td>
<td>
<p>a logical value specifying whether to treat node
labels as edge labels and thus eventually switching them so that
they are associated with the correct edges when using
<code><a href="#topic+drawSupportOnEdges">drawSupportOnEdges</a></code> (see Czech et al. 2016).</p>
</td></tr>
<tr><td><code id="root_+3A_collapse.singles">collapse.singles</code></td>
<td>
<p>a logical value specifying wether to call
<code><a href="#topic+collapse.singles">collapse.singles</a></code> before proceeding to unrooting the
tree.</p>
</td></tr>
<tr><td><code id="root_+3A_keep.root.edge">keep.root.edge</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the
<code>root.edge</code> element of the tree is added in the edge matrix as
a terminal edge. The default is to delete this element.</p>
</td></tr>
<tr><td><code id="root_+3A_...">...</code></td>
<td>
<p>arguments passed among methods (e.g., when rooting lists
of trees).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>outgroup</code> can be either character or numeric. In
the first case, it gives the labels of the tips of the new outgroup;
in the second case the numbers of these labels in the vector
<code>phy$tip.label</code> are given.
</p>
<p>If <code>outgroup</code> is of length one (i.e., a single value), then the
tree is rerooted using the node below this tip as the new root.
</p>
<p>If <code>outgroup</code> is of length two or more, the most recent common
ancestor (MRCA) <em>of the ingroup</em> is used as the new root. Note
that the tree is unrooted before being rerooted, so that if
<code>outgroup</code> is already the outgroup, then the returned tree is not
the same than the original one (see examples). If <code>outgroup</code> is
not monophyletic, the operation fails and an error message is issued.
</p>
<p>If <code>resolve.root = TRUE</code>, <code>root</code> adds a zero-length branch
below the MRCA of the ingroup.
</p>
<p>A tree is considered rooted if either only two branches connect to the
root, or if there is a <code>root.edge</code> element. In all other cases,
<code>is.rooted</code> returns <code>FALSE</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>"phylo"</code> or <code>"multiPhylo"</code> for
<code>root</code> and <code>unroot</code>; a logical vector for <code>is.rooted</code>.
</p>


<h3>Note</h3>

<p>The use of <code>resolve.root = TRUE</code> together with <code>node = </code>
gives an error if the specified node is the current root of the
tree. This is because there is an ambiguity when resolving a node in
an unrooted tree with no explicit outgroup. If the node is not the
current root, the ambiguity is solved arbitrarily by considering the
clade on the right of <code>node</code> (when the tree is plotted by
default) as the ingroup. See a detailed explanation there:
</p>
<p><a href="https://www.mail-archive.com/r-sig-phylo@r-project.org/msg03805.html">https://www.mail-archive.com/r-sig-phylo@r-project.org/msg03805.html</a>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Czech, L., Huerta-Cepas, J. and Stamatakis, A. (2017) A critical
review on the use of support values in tree viewers and bioinformatics
toolkits. <em>Molecular Biology and Evolution</em>, <b>34</b>,
1535&ndash;1542. <a href="https://doi.org/10.1093/molbev/msx055">doi:10.1093/molbev/msx055</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bind.tree">bind.tree</a></code>, <code><a href="#topic+drop.tip">drop.tip</a></code>,
<code><a href="#topic+nodelabels">nodelabels</a></code>, <code><a href="#topic+identify.phylo">identify.phylo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bird.orders)
plot(root(bird.orders, 1))
plot(root(bird.orders, 1:5))

tr &lt;- root(bird.orders, 1)
is.rooted(bird.orders) # yes
is.rooted(tr)          # no
### This is because the tree has been unrooted first before rerooting.
### You can delete the outgroup...
is.rooted(drop.tip(tr, "Struthioniformes"))
### ... or resolve the basal trichotomy in two ways:
is.rooted(multi2di(tr))
is.rooted(root(bird.orders, 1, r = TRUE))
### To keep the basal trichotomy but forcing the tree as rooted:
tr$root.edge &lt;- 0
is.rooted(tr)

x &lt;- setNames(rmtree(10, 10), LETTERS[1:10])
is.rooted(x)
</code></pre>

<hr>
<h2 id='rotate'>Swapping Sister Clades</h2><span id='topic+rotate'></span><span id='topic+rotateConstr'></span>

<h3>Description</h3>

<p>For a given node, <code>rotate</code> exchanges the position of two clades
descending from this node. It can handle dichotomies as well as
polytomies. In the latter case, two clades from the polytomy are
selected for swapping.
</p>
<p><code>rotateConstr</code> rotates internal branches giving a constraint on
the order of the tips.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate(phy, node, polytom = c(1, 2))
rotateConstr(phy, constraint)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="rotate_+3A_node">node</code></td>
<td>
<p>a vector of mode numeric or character specifying the
number of the node.</p>
</td></tr>
<tr><td><code id="rotate_+3A_polytom">polytom</code></td>
<td>
<p>a vector of mode numeric and length two specifying the
two clades that should be exchanged in a polytomy.</p>
</td></tr>
<tr><td><code id="rotate_+3A_constraint">constraint</code></td>
<td>
<p>a vector of mode character specifying the order of
the tips as they should appear when plotting the tree (from bottom
to top).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>phy</code> can be either rooted or unrooted, contain polytomies and lack
branch lengths. In the presence of very short branch lengths it is
convenient to plot the phylogenetic tree without branch lengths in order
to identify the number of the node in question.
</p>
<p><code>node</code> can be any of the interior nodes of a phylogenetic tree
including the root node. Number of the nodes can be identified by the
nodelabels function. Alternatively, you can specify a vector of length
two that contains either the number or the names of two tips that
coalesce in the node of interest.
</p>
<p>If the node subtends a polytomy, any two clades of the the polytomy
can be chosen by polytom. On a plotted phylogeny, the clades are
numbered from bottom to top and polytom is used to index the two
clades one likes to swop.
</p>


<h3>Value</h3>

<p>an object of class <code>"phylo"</code>.
</p>


<h3>Author(s)</h3>

<p>Christoph Heibl <a href="mailto:heibl@lmu.de">heibl@lmu.de</a>, Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.phylo">plot.phylo</a></code>, <code><a href="#topic+nodelabels">nodelabels</a></code>,
<code><a href="#topic+root">root</a></code>, <code><a href="#topic+drop.tip">drop.tip</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># create a random tree:
tre &lt;- rtree(25)

# visualize labels of internal nodes:
plot(tre, use.edge.length=FALSE)
nodelabels()

# rotate clades around node 30:
tre.new &lt;- rotate(tre, 30)

# compare the results:
par(mfrow=c(1,2)) # split graphical device
plot(tre) # plot old tre
plot(tre.new) # plot new tree

# visualize labels of terminal nodes:
plot(tre)
tiplabels()

# rotate clades containing nodes 12 and 20:
tre.new &lt;- rotate(tre, c(12, 21))

# compare the results:
par(mfrow=c(1,2)) # split graphical device
plot(tre) # plot old tre
plot(tre.new) # plot new tree

# or you migth just specify tiplabel names:
tre.new &lt;- rotate(tre, c("t3", "t14"))

# compare the results:
par(mfrow=c(1,2)) # devide graphical device
plot(tre) # plot old tre
plot(tre.new) # plot new tree

# a simple example for rotateConstr:
A &lt;- read.tree(text = "((A,B),(C,D));")
B &lt;- read.tree(text = "(((D,C),B),A);")
B &lt;- rotateConstr(B, A$tip.label)
plot(A); plot(B, d = "l")

# something more interesting (from ?cophyloplot):
tr1 &lt;- rtree(40)
## drop 20 randomly chosen tips:
tr2 &lt;- drop.tip(tr1, sample(tr1$tip.label, size = 20))
## rotate the root and reorder the whole:
tr2 &lt;- rotate(tr2, 21)
tr2 &lt;- read.tree(text = write.tree(tr2))
X &lt;- cbind(tr2$tip.label, tr2$tip.label) # association matrix
cophyloplot(tr1, tr2, assoc = X, space = 28)
## before reordering tr2 we have to find the constraint:
co &lt;- tr2$tip.label[order(match(tr2$tip.label, tr1$tip.label))]
newtr2 &lt;- rotateConstr(tr2, co)
cophyloplot(tr1, newtr2, assoc = X, space = 28)
</code></pre>

<hr>
<h2 id='rTraitCont'>Continuous Character Simulation</h2><span id='topic+rTraitCont'></span>

<h3>Description</h3>

<p>This function simulates the evolution of a continuous character along a
phylogeny. The calculation is done recursively from the root. See
Paradis (2012, pp. 232 and 324) for an introduction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rTraitCont(phy, model = "BM", sigma = 0.1, alpha = 1, theta = 0,
           ancestor = FALSE, root.value = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rTraitCont_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="rTraitCont_+3A_model">model</code></td>
<td>
<p>a character (either <code>"BM"</code> or <code>"OU"</code>) or a
function specifying the model (see details).</p>
</td></tr>
<tr><td><code id="rTraitCont_+3A_sigma">sigma</code></td>
<td>
<p>a numeric vector giving the standard-deviation of the
random component for each branch (can be a single value).</p>
</td></tr>
<tr><td><code id="rTraitCont_+3A_alpha">alpha</code></td>
<td>
<p>if <code>model = "OU"</code>, a numeric vector giving the
strength of the selective constraint for each branch (can be a
single value).</p>
</td></tr>
<tr><td><code id="rTraitCont_+3A_theta">theta</code></td>
<td>
<p>if <code>model = "OU"</code>, a numeric vector giving the
optimum for each branch (can be a single value).</p>
</td></tr>
<tr><td><code id="rTraitCont_+3A_ancestor">ancestor</code></td>
<td>
<p>a logical value specifying whether to return the
values at the nodes as well (by default, only the values at the tips
are returned).</p>
</td></tr>
<tr><td><code id="rTraitCont_+3A_root.value">root.value</code></td>
<td>
<p>a numeric giving the value at the root.</p>
</td></tr>
<tr><td><code id="rTraitCont_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>model</code> if it is a
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three possibilities to specify <code>model</code>:
</p>

<ul>
<li> <p><code>"BM"</code>: a Browian motion model is used. If the arguments
<code>sigma</code> has more than one value, its length must be equal to the
the branches of the tree. This allows to specify a model with variable
rates of evolution. You must be careful that branch numbering is done
with the tree in &ldquo;postorder&rdquo; order: to see the order of the branches
you can use: <code>tr &lt;- reorder(tr, "po"); plor(tr); edgelabels()</code>.
The arguments <code>alpha</code> and <code>theta</code> are ignored.
</p>
</li>
<li> <p><code>"OU"</code>: an Ornstein-Uhlenbeck model is used. The above
indexing rule is used for the three parameters <code>sigma</code>,
<code>alpha</code>, and <code>theta</code>. This may be interesting for the last
one to model varying phenotypic optima. The exact updating formula
from Gillespie (1996) are used which are reduced to BM formula if
<code>alpha = 0</code>.
</p>
</li>
<li><p> A function: it must be of the form <code>foo(x, l)</code> where
<code>x</code> is the trait of the ancestor and <code>l</code> is the branch
length. It must return the value of the descendant. The arguments
<code>sigma</code>, <code>alpha</code>, and <code>theta</code> are ignored.
</p>
</li></ul>


<h3>Value</h3>

<p>A numeric vector with names taken from the tip labels of
<code>phy</code>. If <code>ancestor = TRUE</code>, the node labels are used if
present, otherwise, &ldquo;Node1&rdquo;, &ldquo;Node2&rdquo;, etc.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Gillespie, D. T. (1996) Exact numerical simulation of the
Ornstein-Uhlenbeck process and its integral. <em>Physical Review E</em>,
<b>54</b>, 2084&ndash;2091.
</p>
<p>Paradis, E. (2012) <em>Analysis of Phylogenetics and Evolution with
R (Second Edition).</em> New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rTraitDisc">rTraitDisc</a></code>, <code><a href="#topic+rTraitMult">rTraitMult</a></code>, <code><a href="#topic+ace">ace</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bird.orders)
rTraitCont(bird.orders) # BM with sigma = 0.1
### OU model with two optima:
tr &lt;- reorder(bird.orders, "postorder")
plot(tr)
edgelabels()
theta &lt;- rep(0, Nedge(tr))
theta[c(1:4, 15:16, 23:24)] &lt;- 2
## sensitive to 'alpha' and 'sigma':
rTraitCont(tr, "OU", theta = theta, alpha=.1, sigma=.01)
### an imaginary model with stasis 0.5 time unit after a node, then
### BM evolution with sigma = 0.1:
foo &lt;- function(x, l) {
    if (l &lt;= 0.5) return(x)
    x + (l - 0.5)*rnorm(1, 0, 0.1)
}
tr &lt;- rcoal(20, br = runif)
rTraitCont(tr, foo, ancestor = TRUE)
### a cumulative Poisson process:
bar &lt;- function(x, l) x + rpois(1, l)
(x &lt;- rTraitCont(tr, bar, ancestor = TRUE))
plot(tr, show.tip.label = FALSE)
Y &lt;- x[1:20]
A &lt;- x[-(1:20)]
nodelabels(A)
tiplabels(Y)
</code></pre>

<hr>
<h2 id='rTraitDisc'>Discrete Character Simulation</h2><span id='topic+rTraitDisc'></span>

<h3>Description</h3>

<p>This function simulates the evolution of a discrete character along a
phylogeny. If <code>model</code> is a character or a matrix, evolution is
simulated with a Markovian model; the transition probabilities are
calculated for each branch with <code class="reqn">P = e^{Qt}</code> where <code class="reqn">Q</code> is the
rate matrix given by <code>model</code> and <code class="reqn">t</code> is the branch length.
The calculation is done recursively from the root. See Paradis (2006,
p. 101) for a general introduction applied to evolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rTraitDisc(phy, model = "ER", k = if (is.matrix(model)) ncol(model) else 2,
           rate = 0.1, states = LETTERS[1:k], freq = rep(1/k, k),
           ancestor = FALSE, root.value = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rTraitDisc_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="rTraitDisc_+3A_model">model</code></td>
<td>
<p>a character, a square numeric matrix, or a function
specifying the model (see details).</p>
</td></tr>
<tr><td><code id="rTraitDisc_+3A_k">k</code></td>
<td>
<p>the number of states of the character.</p>
</td></tr>
<tr><td><code id="rTraitDisc_+3A_rate">rate</code></td>
<td>
<p>the rate of change used if <code>model</code> is a character; it
is <em>not</em> recycled if <code>model = "ARD"</code> of <code>model =
      "SYM"</code>.</p>
</td></tr>
<tr><td><code id="rTraitDisc_+3A_states">states</code></td>
<td>
<p>the labels used for the states; by default &ldquo;A&rdquo;, &ldquo;B&rdquo;,
...</p>
</td></tr>
<tr><td><code id="rTraitDisc_+3A_freq">freq</code></td>
<td>
<p>a numeric vector giving the equilibrium relative
frequencies of each state; by default the frequencies are equal.</p>
</td></tr>
<tr><td><code id="rTraitDisc_+3A_ancestor">ancestor</code></td>
<td>
<p>a logical value specifying whether to return the
values at the nodes as well (by default, only the values at the tips
are returned).</p>
</td></tr>
<tr><td><code id="rTraitDisc_+3A_root.value">root.value</code></td>
<td>
<p>an integer giving the value at the root (by default,
it's the first state). To have a random value, use <code>root.value
      = sample(k)</code>.</p>
</td></tr>
<tr><td><code id="rTraitDisc_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>model</code> if it is a
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three possibilities to specify <code>model</code>:
</p>

<ul>
<li><p> A matrix: it must be a numeric square matrix; the diagonal is
always ignored. The arguments <code>k</code> and <code>rate</code> are ignored.
</p>
</li>
<li><p> A character: these are the same short-cuts than in the function
<code><a href="#topic+ace">ace</a></code>: <code>"ER"</code> is an equal-rates model, <code>"ARD"</code>
is an all-rates-different model, and <code>"SYM"</code> is a symmetrical
model. Note that the argument <code>rate</code> must be of the appropriate
length, i.e., 1, <code class="reqn">k(k - 1)</code>, or <code class="reqn">k(k - 1)/2</code> for the three models,
respectively. The rate matrix <code class="reqn">Q</code> is then filled column-wise.
</p>
</li>
<li><p> A function: it must be of the form <code>foo(x, l)</code> where
<code>x</code> is the trait of the ancestor and <code>l</code> is the branch
length. It must return the value of the descendant as an integer.
</p>
</li></ul>


<h3>Value</h3>

<p>A factor with names taken from the tip labels of <code>phy</code>. If
<code>ancestor = TRUE</code>, the node labels are used if present,
otherwise, &ldquo;Node1&rdquo;, &ldquo;Node2&rdquo;, etc.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Paradis, E. (2006) <em>Analyses of Phylogenetics and Evolution with
R.</em> New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rTraitCont">rTraitCont</a></code>, <code><a href="#topic+rTraitMult">rTraitMult</a></code>, <code><a href="#topic+ace">ace</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bird.orders)
### the two followings are the same:
rTraitDisc(bird.orders)
rTraitDisc(bird.orders, model = matrix(c(0, 0.1, 0.1, 0), 2))

### two-state model with irreversibility:
rTraitDisc(bird.orders, model = matrix(c(0, 0, 0.1, 0), 2))

### simple two-state model:
tr &lt;- rcoal(n &lt;- 40, br = runif)
x &lt;- rTraitDisc(tr, ancestor = TRUE)
plot(tr, show.tip.label = FALSE)
nodelabels(pch = 19, col = x[-(1:n)])
tiplabels(pch = 19, col = x[1:n])

### an imaginary model with stasis 0.5 time unit after a node, then
### random evolution:
foo &lt;- function(x, l) {
    if (l &lt; 0.5) return(x)
    sample(2, size = 1)
}
tr &lt;- rcoal(20, br = runif)
x &lt;- rTraitDisc(tr, foo, ancestor = TRUE)
plot(tr, show.tip.label = FALSE)
co &lt;- c("blue", "yellow")
cot &lt;- c("white", "black")
Y &lt;- x[1:20]
A &lt;- x[-(1:20)]
nodelabels(A, bg = co[A], col = cot[A])
tiplabels(Y, bg = co[Y], col = cot[Y])
</code></pre>

<hr>
<h2 id='rTraitMult'>Multivariate Character Simulation</h2><span id='topic+rTraitMult'></span>

<h3>Description</h3>

<p>This function simulates the evolution of a multivariate set of traits
along a phylogeny. The calculation is done recursively from the
root.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rTraitMult(phy, model, p = 1, root.value = rep(0, p), ancestor = FALSE,
           asFactor = NULL, trait.labels = paste("x", 1:p, sep = ""), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rTraitMult_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="rTraitMult_+3A_model">model</code></td>
<td>
<p>a function specifying the model (see details).</p>
</td></tr>
<tr><td><code id="rTraitMult_+3A_p">p</code></td>
<td>
<p>an integer giving the number of traits.</p>
</td></tr>
<tr><td><code id="rTraitMult_+3A_root.value">root.value</code></td>
<td>
<p>a numeric vector giving the values at the root.</p>
</td></tr>
<tr><td><code id="rTraitMult_+3A_ancestor">ancestor</code></td>
<td>
<p>a logical value specifying whether to return the
values at the nodes as well (by default, only the values at the tips
are returned).</p>
</td></tr>
<tr><td><code id="rTraitMult_+3A_asfactor">asFactor</code></td>
<td>
<p>the indices of the traits that are returned as factors
(discrete traits).</p>
</td></tr>
<tr><td><code id="rTraitMult_+3A_trait.labels">trait.labels</code></td>
<td>
<p>a vector of mode character giving the names of the
traits.</p>
</td></tr>
<tr><td><code id="rTraitMult_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>model</code> if it is a
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is specified with an <span class="rlang"><b>R</b></span> function of the form <code>foo(x,
    l)</code> where <code>x</code> is a vector of the traits of the ancestor and
<code>l</code> is the branch length. Other arguments may be added. The
function must return a vector of length <code>p</code>.
</p>


<h3>Value</h3>

<p>A data frame with <code>p</code> columns whose names are given by
<code>trait.labels</code> and row names taken from the labels of the tree.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+rTraitCont">rTraitCont</a></code>, <code><a href="#topic+rTraitDisc">rTraitDisc</a></code>, <code><a href="#topic+ace">ace</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## correlated evolution of 2 continuous traits:
mod &lt;- function(x, l) {
    y1 &lt;- rnorm(1, x[1] + 0.5*x[2], 0.1)
    y2 &lt;- rnorm(1, 0.5*x[1] + x[2], 0.1)
    c(y1, y2)
}
set.seed(11)
tr &lt;- makeNodeLabel(rcoal(20))
x &lt;- rTraitMult(tr, mod, 2, ancestor = TRUE)
op &lt;- par(mfcol = c(2, 1))
plot(x, type = "n")
text(x, labels = rownames(x), cex = 0.7)
oq &lt;- par(mar = c(0, 1, 0, 1), xpd = TRUE)
plot(tr, font = 1, cex = 0.7)
nodelabels(tr$node.label, cex = 0.7, adj = 1)
par(c(op, oq))
</code></pre>

<hr>
<h2 id='rtree'>Generate Random Trees</h2><span id='topic+rtree'></span><span id='topic+rcoal'></span><span id='topic+rmtree'></span><span id='topic+rtopology'></span><span id='topic+rmtopology'></span>

<h3>Description</h3>

<p>These functions generate trees by splitting randomly the edges
(<code>rtree</code> and <code>rtopology</code>) or randomly clustering the tips
(<code>rcoal</code>). <code>rtree</code> and <code>rtopology</code> generate general
trees, and <code>rcoal</code> generates coalescent trees. The algorithms are
described in Paradis (2012) and in a vignette in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtree(n, rooted = TRUE, tip.label = NULL, br = runif, equiprob = FALSE, ...)
rtopology(n, rooted = FALSE, tip.label = NULL, br = runif, ...)
rcoal(n, tip.label = NULL, br = "coalescent", ...)
rmtree(N, n, rooted = TRUE, tip.label = NULL, br = runif,
       equiprob = FALSE, ...)
rmtopology(N, n, rooted = FALSE, tip.label = NULL, br = runif, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtree_+3A_n">n</code></td>
<td>
<p>an integer giving the number of tips in the tree.</p>
</td></tr>
<tr><td><code id="rtree_+3A_rooted">rooted</code></td>
<td>
<p>a logical indicating whether the tree should be rooted
(the default).</p>
</td></tr>
<tr><td><code id="rtree_+3A_tip.label">tip.label</code></td>
<td>
<p>a character vector giving the tip labels; if not
specified, the tips &quot;t1&quot;, &quot;t2&quot;, ..., are given.</p>
</td></tr>
<tr><td><code id="rtree_+3A_br">br</code></td>
<td>
<p>one of the following: (i) an <span class="rlang"><b>R</b></span> function used to generate the
branch lengths (<code>rtree</code>; use <code>NULL</code> to simulate only a
topology), or the coalescence times (<code>rcoal</code>); (ii) a character
to simulate a genuine coalescent tree for <code>rcoal</code> (the
default); or (iii) a numeric vector for the branch lengths or the
coalescence times.</p>
</td></tr>
<tr><td><code id="rtree_+3A_equiprob">equiprob</code></td>
<td>
<p>(new since <span class="pkg">ape</span> 5.4-1) a logical specifying
whether topologies are generated in equal frequencies. If,
<code>FALSE</code>, the unbalanced topologies are generated in higher
proportions than the balanced ones.</p>
</td></tr>
<tr><td><code id="rtree_+3A_...">...</code></td>
<td>
<p>further argument(s) to be passed to <code>br</code>.</p>
</td></tr>
<tr><td><code id="rtree_+3A_n">N</code></td>
<td>
<p>an integer giving the number of trees to generate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The trees generated are bifurcating. If <code>rooted = FALSE</code> in
(<code>rtree</code>), the tree is trifurcating at its root.
</p>
<p>The option <code>equiprob = TRUE</code> generates <em>unlabelled</em>
topologies in equal frequencies. This is more complicated for the
labelled topologies (see the vignette &ldquo;RandomTopologies&rdquo;).
</p>
<p>The default function to generate branch lengths in <code>rtree</code> is
<code>runif</code>. If further arguments are passed to <code>br</code>, they need
to be tagged (e.g., <code>min = 0, max = 10</code>).
</p>
<p><code>rmtree</code> calls successively <code>rtree</code> and set the class of
the returned object appropriately.
</p>


<h3>Value</h3>

<p>An object of class <code>"phylo"</code> or of class <code>"multiPhylo"</code> in
the case of <code>rmtree</code> or <code>rmtopology</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Paradis, E. (2012) <em>Analysis of Phylogenetics and Evolution with
R (Second Edition).</em> New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stree">stree</a></code>, <code><a href="#topic+rlineage">rlineage</a></code>, vignette
&ldquo;RandomTopologies&rdquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>layout(matrix(1:9, 3, 3))
### Nine random trees:
for (i in 1:9) plot(rtree(20))
### Nine random cladograms:
for (i in 1:9) plot(rtree(20, FALSE), type = "c")
### generate 4 random trees of bird orders:
data(bird.orders)
layout(matrix(1:4, 2, 2))
for (i in 1:4)
  plot(rcoal(23, tip.label = bird.orders$tip.label), no.margin = TRUE)
layout(1)
par(mar = c(5, 4, 4, 2))
</code></pre>

<hr>
<h2 id='rtt'>Root a Tree by Root-to-Tip Regression</h2><span id='topic+rtt'></span>

<h3>Description</h3>

<p>This function roots a phylogenetic tree with dated tips in the location
most compatible with the assumption of a strict molecular clock.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtt(t, tip.dates, ncpu = 1, objective = correlation,
    opt.tol = .Machine$double.eps^0.25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtt_+3A_t">t</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="rtt_+3A_tip.dates">tip.dates</code></td>
<td>
<p>a vector of sampling times associated to the tips of
<code>t</code>, in the same order as <code>t$tip.label</code>.</p>
</td></tr>
<tr><td><code id="rtt_+3A_ncpu">ncpu</code></td>
<td>
<p>number of cores to use.</p>
</td></tr>
<tr><td><code id="rtt_+3A_objective">objective</code></td>
<td>
<p>one of <code>"correlation"</code>, <code>"rms"</code>, or
<code>"rsquared"</code>.</p>
</td></tr>
<tr><td><code id="rtt_+3A_opt.tol">opt.tol</code></td>
<td>
<p>tolerance for optimization precision.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function duplicates one part the functionality of the program
Path-O-Gen (see references). The root position is chosen to produce
the best linear regression of root-to-tip distances against sampling
times.
</p>
<p><code>t</code> must have branch lengths in units of expected substitutions
per site.
</p>
<p><code>tip.dates</code> should be a vector of sampling times, in any time
unit, with time increasing toward the present. For example, this may
be in units of &ldquo;days since study start&rdquo; or &ldquo;years since 10,000
BCE&rdquo;, but not &ldquo;millions of yearsago&rdquo;.
</p>
<p>Setting <code>ncpu</code> to a value larger than 1 requires the <code>parallel</code>
library.
</p>
<p><code>objective</code> is the measure which will be used to define the
&ldquo;goodness&rdquo; of a regression fit. It may be one of <code>"correlation"</code>
(strongest correlation between tip date and distance from root),
<code>"rms"</code> (lowest root-mean-squared error), or <code>"rsquared"</code>
(highest R-squared value).
</p>
<p><code>opt.tol</code> is used to optimize the location of the root along the best
branch. By default, R's <code>optimize</code> function uses a precision of
<code>.Machine$double.eps^0.25</code>, which is about 0.0001 on a 64-bit system.
This should be set to a smaller value if the branch lengths of <code>t</code> are
very short.
</p>


<h3>Value</h3>

<p>an object of class <code>"phylo"</code>.
</p>


<h3>Note</h3>

<p>This function only chooses the best root. It does not rescale the branch
lengths to time, or perform a statistical test of the molecular clock
hypothesis.
</p>


<h3>Author(s)</h3>

<p>Rosemary McCloskey<a href="mailto:rmccloskey@cfenet.ubc.ca">rmccloskey@cfenet.ubc.ca</a>,
Emmanuel Paradis
</p>


<h3>References</h3>

<p>Rambaut, A. (2009). Path-O-Gen: temporal signal investigation
tool.
</p>
<p>Rambaut, A. (2000). Estimating the rate of molecular evolution:
incorporating non-contemporaneous sequences into maximum likelihood
phylogenies. <em>Bioinformatics</em>, <b>16</b>, 395-399.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- rtree(100)
tip.date &lt;- rnorm(t$tip.label)^2
rtt(t, tip.date)
</code></pre>

<hr>
<h2 id='SDM'>Construction of Consensus Distance Matrix With SDM</h2><span id='topic+SDM'></span>

<h3>Description</h3>

<p>This function implements the SDM method of Criscuolo et al. (2006) for
a set of n distance matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SDM(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SDM_+3A_...">...</code></td>
<td>
<p>2n elements (with n &gt; 1), the first n elements are the
distance matrices: these can be (symmetric) matrices, objects of
class <code>"dist"</code>, or a mix of both. The next n elements are the
sequence length from which the matrices have been estimated (can be
seen as a degree of confidence in matrices).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reconstructs a consensus distance matrix from a set of input distance
matrices on overlapping sets of taxa. Potentially missing values in
the supermatrix are represented by <code>NA</code>. An error is returned if
the input distance matrices can not resolve to a consensus matrix.
</p>


<h3>Value</h3>

<p>a 2-element list containing a distance matrix labelled by the union of
the set of taxa of the input distance matrices, and a variance matrix
associated to the returned distance matrix.
</p>


<h3>Author(s)</h3>

<p>Andrei Popescu</p>


<h3>References</h3>

<p>Criscuolo, A., Berry, V., Douzery, E. J. P. , and Gascuel, O. (2006)
SDM: A fast distance-based approach for (super)tree building in
phylogenomics. <em>Systematic Biology</em>, <b>55</b>, 740&ndash;755.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bionj">bionj</a></code>, <code><a href="#topic+fastme">fastme</a></code>, <code><a href="#topic+njs">njs</a></code>,
<code><a href="#topic+mvrs">mvrs</a></code>, <code><a href="#topic+triangMtd">triangMtd</a></code>
</p>

<hr>
<h2 id='seg.sites'>
Find Segregating Sites in DNA Sequences
</h2><span id='topic+seg.sites'></span>

<h3>Description</h3>

<p>This function gives the indices of segregating (polymorphic) sites in
a sample of DNA sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seg.sites(x, strict = FALSE, trailingGapsAsN = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seg.sites_+3A_x">x</code></td>
<td>
<p>a matrix or a list which contains the DNA sequences.</p>
</td></tr>
<tr><td><code id="seg.sites_+3A_strict">strict</code></td>
<td>
<p>a logical value; if <code>TRUE</code>, ambiguities and gaps in
the sequences are not interpreted in the usual way.</p>
</td></tr>
<tr><td><code id="seg.sites_+3A_trailinggapsasn">trailingGapsAsN</code></td>
<td>
<p>a logical value; if <code>TRUE</code> (the default),
the leading and trailing alignment gaps are considered as unknown
bases (i.e., N).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the sequences are in a list, they must all be of the same length.
</p>
<p>If <code>strict = FALSE</code> (the default), the following rule is used to
determine if a site is polymorphic or not in the presence of ambiguous
bases: &lsquo;A&rsquo; and &lsquo;R&rsquo; are not interpreted as different, &lsquo;A&rsquo; and &lsquo;Y&rsquo; are
interpreted as different, and &lsquo;N&rsquo; and any other base (ambiguous or
not) are interpreted as not different. If <code>strict = TRUE</code>, all
letters are considered different.
</p>
<p>Alignment gaps are considered different from all letters except for
the leading and trailing gaps if <code>trailingGapsAsN = TRUE</code> (which
is the default).
</p>


<h3>Value</h3>

<p>A numeric (integer) vector giving the indices of the segregating
sites.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+base.freq">base.freq</a></code>, <code>theta.s</code>, <code>nuc.div</code> (last two in <span class="pkg">pegas</span>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
y &lt;- seg.sites(woodmouse)
y
length(y)
</code></pre>

<hr>
<h2 id='skyline'>Skyline Plot Estimate of Effective Population Size</h2><span id='topic+skyline'></span><span id='topic+skyline.phylo'></span><span id='topic+skyline.coalescentIntervals'></span><span id='topic+skyline.collapsedIntervals'></span><span id='topic+find.skyline.epsilon'></span>

<h3>Description</h3>

<p><code>skyline</code> computes the <em>generalized skyline plot</em> estimate of effective population size
from an estimated phylogeny.  The demographic history is approximated by
a step-function.  The number of parameters of the skyline plot (i.e. its smoothness)
is controlled by a parameter <code>epsilon</code>.
</p>
<p><code>find.skyline.epsilon</code> searches for an optimal value of the <code>epsilon</code> parameter,
i.e. the value that maximizes the AICc-corrected log-likelihood (<code>logL.AICc</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skyline(x, ...)
## S3 method for class 'phylo'
skyline(x, ...)
## S3 method for class 'coalescentIntervals'
skyline(x, epsilon=0, ...)
## S3 method for class 'collapsedIntervals'
skyline(x, old.style=FALSE, ...)
find.skyline.epsilon(ci, GRID=1000, MINEPS=1e-6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skyline_+3A_x">x</code></td>
<td>
<p>Either an ultrametric tree (i.e. an object of class
<code>"phylo"</code>), or coalescent intervals (i.e. an object of class
<code>"coalescentIntervals"</code>), or collapsed coalescent intervals
(i.e. an object of class <code>"collapsedIntervals"</code>).</p>
</td></tr>
<tr><td><code id="skyline_+3A_epsilon">epsilon</code></td>
<td>
<p>collapsing parameter that controls the amount of smoothing
(allowed range: from <code>0</code> to <code>ci$total.depth</code>, default value: 0). This is the same parameter as in
<a href="#topic+collapsed.intervals">collapsed.intervals</a>.</p>
</td></tr>
<tr><td><code id="skyline_+3A_old.style">old.style</code></td>
<td>
<p>Parameter to choose between two slightly different variants of the
generalized skyline plot (Strimmer and Pybus, pers. comm.). The default value <code>FALSE</code> is
recommended.</p>
</td></tr>
<tr><td><code id="skyline_+3A_ci">ci</code></td>
<td>
<p>coalescent intervals (i.e. an object of class <code>"coalescentIntervals"</code>)</p>
</td></tr>
<tr><td><code id="skyline_+3A_grid">GRID</code></td>
<td>
<p>Parameter for the grid search for <code>epsilon</code> in <code>find.skyline.epsilon</code>.</p>
</td></tr>
<tr><td><code id="skyline_+3A_mineps">MINEPS</code></td>
<td>
<p>Parameter for the grid search for <code>epsilon</code> in <code>find.skyline.epsilon</code>.</p>
</td></tr>
<tr><td><code id="skyline_+3A_...">...</code></td>
<td>
<p>Any of the above parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>skyline</code> implements the <em>generalized skyline plot</em>  introduced in
Strimmer and Pybus (2001).  For <code>epsilon = 0</code> the
generalized skyline plot degenerates to the
<em>classic skyline plot</em> described in
Pybus et al. (2000).  The latter is in turn directly related to lineage-through-time plots
(Nee et al., 1995).
</p>


<h3>Value</h3>

<p><code>skyline</code> returns an object of class <code>"skyline"</code> with the following entries:
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p> A vector with the time at the end of each coalescent
interval (i.e. the accumulated interval lengths from the beginning of the first interval
to the end of an interval)</p>
</td></tr>
<tr><td><code>interval.length</code></td>
<td>
<p> A vector with the length of each interval.</p>
</td></tr>
<tr><td><code>population.size</code></td>
<td>
<p>A vector with the effective population size of each interval.</p>
</td></tr>
<tr><td><code>parameter.count</code></td>
<td>
<p> Number of free parameters in the skyline plot.</p>
</td></tr>
<tr><td><code>epsilon</code></td>
<td>
<p>The value of the underlying smoothing parameter.</p>
</td></tr>
<tr><td><code>logL</code></td>
<td>
<p>Log-likelihood of skyline plot (see Strimmer and Pybus, 2001).</p>
</td></tr>
<tr><td><code>logL.AICc</code></td>
<td>
<p>AICc corrected log-likelihood (see Strimmer and Pybus, 2001).</p>
</td></tr>
</table>
<p><code>find.skyline.epsilon</code> returns the value of the <code>epsilon</code> parameter
that maximizes <code>logL.AICc</code>.
</p>


<h3>Author(s)</h3>

<p>Korbinian Strimmer</p>


<h3>References</h3>

<p>Strimmer, K. and Pybus, O. G. (2001) Exploring the demographic history
of DNA sequences using the generalized skyline plot. <em>Molecular
Biology and Evolution</em>, <b>18</b>, 2298&ndash;2305.
</p>
<p>Pybus, O. G, Rambaut, A. and Harvey, P. H. (2000) An integrated
framework for the inference of viral population history from
reconstructed genealogies. <em>Genetics</em>, <b>155</b>, 1429&ndash;1437.
</p>
<p>Nee, S., Holmes, E. C., Rambaut, A. and Harvey, P. H. (1995) Inferring
population history from molecular phylogenies. <em>Philosophical
Transactions of the Royal Society of London. Series B. Biological
Sciences</em>, <b>349</b>, 25&ndash;31.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coalescent.intervals">coalescent.intervals</a></code>, <code><a href="#topic+collapsed.intervals">collapsed.intervals</a></code>,
<code><a href="#topic+skylineplot">skylineplot</a></code>, <code><a href="#topic+ltt.plot">ltt.plot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get tree
data("hivtree.newick") # example tree in NH format
tree.hiv &lt;- read.tree(text = hivtree.newick) # load tree

# corresponding coalescent intervals
ci &lt;- coalescent.intervals(tree.hiv) # from tree

# collapsed intervals
cl1 &lt;- collapsed.intervals(ci,0)
cl2 &lt;- collapsed.intervals(ci,0.0119)

#### classic skyline plot ####
sk1 &lt;- skyline(cl1)        # from collapsed intervals 
sk1 &lt;- skyline(ci)         # from coalescent intervals
sk1 &lt;- skyline(tree.hiv)   # from tree
sk1

plot(skyline(tree.hiv))
skylineplot(tree.hiv) # shortcut

plot(sk1, show.years=TRUE, subst.rate=0.0023, present.year = 1997)

#### generalized skyline plot ####

sk2 &lt;- skyline(cl2)              # from collapsed intervals
sk2 &lt;- skyline(ci, 0.0119)       # from coalescent intervals
sk2 &lt;- skyline(tree.hiv, 0.0119) # from tree
sk2

plot(sk2)

# classic and generalized skyline plot together in one plot
plot(sk1, show.years=TRUE, subst.rate=0.0023, present.year = 1997, col=c(grey(.8),1))
lines(sk2,  show.years=TRUE, subst.rate=0.0023, present.year = 1997)
legend(.15,500, c("classic", "generalized"), col=c(grey(.8),1),lty=1)


# find optimal epsilon parameter using AICc criterion
find.skyline.epsilon(ci)

sk3 &lt;- skyline(ci, -1) # negative epsilon also triggers estimation of epsilon
sk3$epsilon
</code></pre>

<hr>
<h2 id='skylineplot'>Drawing Skyline Plot Graphs</h2><span id='topic+skylineplot'></span><span id='topic+plot.skyline'></span><span id='topic+lines.skyline'></span><span id='topic+skylineplot.deluxe'></span>

<h3>Description</h3>

<p>These functions provide various ways to draw <em>skyline plot</em> graphs
on the current graphical device. Note that <code>skylineplot(z, ...)</code> is simply
a shortcut for <code>plot(skyline(z, ...))</code>.
The skyline plot itself is an estimate of effective population size through time,
and is computed using the function <code><a href="#topic+skyline">skyline</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'skyline'
plot(x, show.years=FALSE, subst.rate, present.year, ...)
## S3 method for class 'skyline'
lines(x, show.years=FALSE, subst.rate, present.year, ...)
skylineplot(z, ...)
skylineplot.deluxe(tree, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skylineplot_+3A_x">x</code></td>
<td>
<p>skyline plot data (i.e. an object of class <code>"skyline"</code>).</p>
</td></tr>
<tr><td><code id="skylineplot_+3A_z">z</code></td>
<td>
<p>Either an ultrametric tree (i.e. an object of class <code>"phylo"</code>),
or coalescent intervals (i.e. an object of class <code>"coalescentIntervals"</code>), or
collapsed coalescent intervals (i.e. an object of class <code>"collapsedIntervals"</code>).</p>
</td></tr>
<tr><td><code id="skylineplot_+3A_tree">tree</code></td>
<td>
<p>ultrametric tree (i.e. an object of class <code>"phylo"</code>).</p>
</td></tr>
<tr><td><code id="skylineplot_+3A_show.years">show.years</code></td>
<td>
<p>option that determines whether the time is plotted in units of
of substitutions (default) or in years (requires specification of substution rate
and year of present).</p>
</td></tr>
<tr><td><code id="skylineplot_+3A_subst.rate">subst.rate</code></td>
<td>
<p>substitution rate (see option show.years).</p>
</td></tr>
<tr><td><code id="skylineplot_+3A_present.year">present.year</code></td>
<td>
<p>present year (see option show.years).</p>
</td></tr>
<tr><td><code id="skylineplot_+3A_...">...</code></td>
<td>
<p>further arguments to be passed on to <code>skyline()</code> and <code>plot()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+skyline">skyline</a></code> for more details (incl. references) about the skyline plot method.
</p>


<h3>Author(s)</h3>

<p>Korbinian Strimmer</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+plot">plot</a></code> and <code><a href="graphics.html#topic+lines">lines</a></code> for the basic plotting
function in R, <code><a href="#topic+coalescent.intervals">coalescent.intervals</a></code>, <code><a href="#topic+skyline">skyline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get tree
data("hivtree.newick") # example tree in NH format
tree.hiv &lt;- read.tree(text = hivtree.newick) # load tree

#### classic skyline plot
skylineplot(tree.hiv) # shortcut

#### plot classic and generalized skyline plots and estimate epsilon
sk.opt &lt;- skylineplot.deluxe(tree.hiv)
sk.opt$epsilon

#### classic and generalized skyline plot ####
sk1 &lt;- skyline(tree.hiv)
sk2 &lt;- skyline(tree.hiv, 0.0119)

# use years rather than substitutions as unit for the time axis
plot(sk1, show.years=TRUE, subst.rate=0.0023, present.year = 1997, col=c(grey(.8),1))
lines(sk2,  show.years=TRUE, subst.rate=0.0023, present.year = 1997)
legend(.15,500, c("classic", "generalized"), col=c(grey(.8),1),lty=1)

#### various skyline plots for different epsilons
layout(mat= matrix(1:6,2,3,byrow=TRUE))
ci &lt;- coalescent.intervals(tree.hiv)
plot(skyline(ci, 0.0));title(main="0.0")
plot(skyline(ci, 0.007));title(main="0.007")
plot(skyline(ci, 0.0119),col=4);title(main="0.0119")
plot(skyline(ci, 0.02));title(main="0.02")
plot(skyline(ci, 0.05));title(main="0.05")
plot(skyline(ci, 0.1));title(main="0.1")
layout(mat= matrix(1:1,1,1,byrow=TRUE))
</code></pre>

<hr>
<h2 id='slowinskiguyer.test'>Slowinski-Guyer Test of Homogeneous Diversification</h2><span id='topic+slowinskiguyer.test'></span>

<h3>Description</h3>

<p>This function performs the Slowinski&ndash;Guyer test that a trait or
variable does not increase diversification rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slowinskiguyer.test(x, detail = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slowinskiguyer.test_+3A_x">x</code></td>
<td>
<p>a matrix or a data frame with at least two columns: the first
one gives the number of species in clades with a trait supposed to
increase diversification rate, and the second one the number of
species in the corresponding sister-clade without the trait. Each
row represents a pair of sister-clades.</p>
</td></tr>
<tr><td><code id="slowinskiguyer.test_+3A_detail">detail</code></td>
<td>
<p>if <code>TRUE</code>, the individual P-values are appended.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Slowinski&ndash;Guyer test compares a series of sister-clades where one
of the two is characterized by a trait supposed to increase
diversification rate. The null hypothesis is that the trait does not
affect diversification. If the trait decreased diversification rate,
then the null hypothesis cannot be rejected.
</p>
<p>The present function has mainly a historical interest. The
Slowinski&ndash;Guyer test generally performs poorly: see Paradis (2012)
alternatives and the functions cited below.
</p>


<h3>Value</h3>

<p>a data frame with the <code class="reqn">\chi^2</code>, the number of degrees of
freedom, and the <em>P</em>-value. If <code>detail = TRUE</code>, a list is
returned with the data frame and a vector of individual
<em>P</em>-values for each pair of sister-clades.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Paradis, E. (2012) Shift in diversification in sister-clade
comparisons: a more powerful test. <em>Evolution</em>, <b>66</b>,
288&ndash;295.
</p>
<p>Slowinski, J. B. and Guyer, C. (1993) Testing whether certain traits
have caused amplified diversification: an improved method based on a
model of random speciation and extinction. <em>American Naturalist</em>,
<b>142</b>, 1019&ndash;1024.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+balance">balance</a></code>, <code><a href="#topic+mcconwaysims.test">mcconwaysims.test</a></code>,
<code><a href="#topic+diversity.contrast.test">diversity.contrast.test</a></code>,
<code><a href="#topic+richness.yule.test">richness.yule.test</a></code>,
<code>rc</code> in <span class="pkg">geiger</span>, <code>shift.test</code> in <span class="pkg">apTreeshape</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### from Table 1 in Slowinski and Guyer(1993):
viviparous &lt;- c(98, 8, 193, 36, 7, 128, 2, 3, 23, 70)
oviparous &lt;- c(234, 17, 100, 4, 1, 12, 6, 1, 481, 11)
x &lt;- data.frame(viviparous, oviparous)
slowinskiguyer.test(x, TRUE) # 'P ~ 0.32' in the paper
xalt &lt;- x
xalt[3, 2] &lt;- 1
slowinskiguyer.test(xalt)
</code></pre>

<hr>
<h2 id='solveAmbiguousBases'>Solve Ambiguous Bases in DNA Sequences</h2><span id='topic+solveAmbiguousBases'></span>

<h3>Description</h3>

<p>Replaces ambiguous bases in DNA sequences (R, Y, W, ...) by A, G, C,
or T.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solveAmbiguousBases(x, method = "columnwise", random = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solveAmbiguousBases_+3A_x">x</code></td>
<td>
<p>a matrix of class <code>"DNAbin"</code>; a list is accepted and is
converted into a matrix.</p>
</td></tr>
<tr><td><code id="solveAmbiguousBases_+3A_method">method</code></td>
<td>
<p>the method used (no other choice than the default for
the moment; see details).</p>
</td></tr>
<tr><td><code id="solveAmbiguousBases_+3A_random">random</code></td>
<td>
<p>a logical value (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The replacements of ambiguous bases are done columwise. First, the
base frequencies are counted: if no ambiguous base is found in the
column, nothing is done. By default (i.e., if <code>random = TRUE</code>),
the replacements are done by random sampling using the frequencies of
the observed compatible, non-ambiguous bases. For instance, if the
ambiguous base is Y, it is replaced by either C or T using their
observed frequencies as probabilities. If <code>random = FALSE</code>, the
greatest of these frequencies is used. If there are no compatible
bases in the column, equal probabilities are used. For instance, if
the ambiguous base is R, and only C and T are observed, then it is
replaced by either A or G with equal probabilities.
</p>
<p>Alignment gaps are not changed; see the function <code><a href="#topic+latag2n">latag2n</a></code>
to change the leading and trailing gaps.
</p>


<h3>Value</h3>

<p>a matrix of class <code>"DNAbin"</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+base.freq">base.freq</a></code>, <code><a href="#topic+latag2n">latag2n</a></code>, <code><a href="#topic+dnds">dnds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- as.DNAbin(matrix(c("A", "G", "G", "R"), ncol = 1))
alview(solveAmbiguousBases(X)) # R replaced by either A or G
alview(solveAmbiguousBases(X, random = FALSE)) # R always replaced by G
</code></pre>

<hr>
<h2 id='speciesTree'>Species Tree Estimation</h2><span id='topic+speciesTree'></span>

<h3>Description</h3>

<p>This function calculates the species tree from a set of gene trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>speciesTree(x, FUN = min)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="speciesTree_+3A_x">x</code></td>
<td>
<p>a list of trees, e.g., an object of class
<code>"multiPhylo"</code>.</p>
</td></tr>
<tr><td><code id="speciesTree_+3A_fun">FUN</code></td>
<td>
<p>a function used to compute the divergence times of each
pair of tips.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all trees in <code>x</code>, the divergence time of each pair of tips is
calculated: these are then &lsquo;summarized&rsquo; with <code>FUN</code> to build a new
distance matrix used to calculate the species tree with a
single-linkage hierarchical clustering. The default for <code>FUN</code>
computes the maximum tree (maxtree) of Liu et al. (2010). Using
<code>FUN = mean</code> gives the shallowest divergence tree of Maddison and
Knowles (2006).
</p>


<h3>Value</h3>

<p>an object of class <code>"phylo"</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Liu, L., Yu, L. and Pearl, D. K. (2010) Maximum tree: a consistent
estimator of the species tree. <em>Journal of Mathematical Biology</em>,
<b>60</b>, 95&ndash;106.
</p>
<p>Maddison, W. P. and Knowles, L. L. (2006) Inferring phylogeny despite
incomplete lineage sorting. <em>Systematic Biology</em>, <b>55</b>, 21&ndash;30.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### example in Liu et al. (2010):
tr1 &lt;- read.tree(text = "(((B:0.05,C:0.05):0.01,D:0.06):0.04,A:0.1);")
tr2 &lt;- read.tree(text = "(((A:0.07,C:0.07):0.02,D:0.09):0.03,B:0.12);")
TR &lt;- c(tr1, tr2)
TSmax &lt;- speciesTree(TR) # MAXTREE
TSsha &lt;- speciesTree(TR, mean) # shallowest divergence

kronoviz(c(tr1, tr2, TSmax, TSsha), horiz = FALSE,
         type = "c", cex = 1.5, font = 1)
mtext(c("Gene tree 1", "Gene tree 2", "Species tree - MAXTREE"),
      at = -c(7.5, 4, 1))
mtext("Species tree - Shallowest Divergence")
layout(1)
</code></pre>

<hr>
<h2 id='stree'>Generates Systematic Regular Trees</h2><span id='topic+stree'></span>

<h3>Description</h3>

<p>This function generates trees with regular shapes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stree(n, type = "star", tip.label = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stree_+3A_n">n</code></td>
<td>
<p>an integer giving the number of tips in the tree.</p>
</td></tr>
<tr><td><code id="stree_+3A_type">type</code></td>
<td>
<p>a character string specifying the type of tree to
generate; four choices are possible: <code>"star"</code>,
<code>"balanced"</code>, <code>"left"</code>, <code>"right"</code>, or any unambiguous
abbreviation of these.</p>
</td></tr>
<tr><td><code id="stree_+3A_tip.label">tip.label</code></td>
<td>
<p>a character vector giving the tip labels; if not
specified, the tips &quot;t1&quot;, &quot;t2&quot;, ..., are given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The types of trees generated are:
</p>

<ul>
<li><p> &ldquo;star&rdquo;: a star (or comb) tree with a single internal node.
</p>
</li>
<li><p> &ldquo;balanced&rdquo;: a fully balanced dichotomous rooted tree;
<code>n</code> must be a power of 2 (2, 4, 8, ...).
</p>
</li>
<li><p> &ldquo;left&rdquo;: a fully unbalanced rooted tree where the largest
clade is on the left-hand side when the tree is plotted upwards.
</p>
</li>
<li><p> &ldquo;right&rdquo;: same than above but in the other direction.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>"phylo"</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute.brlen">compute.brlen</a></code>, <code><a href="#topic+rtree">rtree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>layout(matrix(1:4, 2, 2))
plot(stree(100))
plot(stree(128, "balanced"))
plot(stree(100, "left"))
plot(stree(100, "right"))
</code></pre>

<hr>
<h2 id='subtreeplot'>Zoom on a Portion of a Phylogeny by Successive Clicks</h2><span id='topic+subtreeplot'></span>

<h3>Description</h3>

<p>This function plots simultaneously a whole phylogenetic tree
(supposedly large) and a portion of it determined by clicking on the nodes of the phylogeny. On exit, returns the last subtree visualized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subtreeplot(x, wait=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subtreeplot_+3A_x">x</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="subtreeplot_+3A_wait">wait</code></td>
<td>
<p>a logical indicating whether the node beeing processed should be printed (useful for big phylogenies).</p>
</td></tr>
<tr><td><code id="subtreeplot_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>plot.phylo</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function aims at easily exploring very large trees. The main argument is
a phylogenetic tree, and the second one is a logical indicating whether a waiting message should be printed while the calculation is being processed. 
</p>
<p>The whole tree is plotted on the left-hand side in half of the device. The
subtree is plotted on the right-hand side in the other half. The user clicks on the nodes in the complete tree and the subtree corresponding to this node is ploted in the right-hand side. There is no limit for the number of clicks that can be done. On exit, the subtree on the right hand side is returned. 
</p>
<p>To use a subtree as the new tree in which to zoom, the user has to use the function many times. This can however be done in a single command line (see example 2).
</p>


<h3>Author(s)</h3>

<p>Damien de Vienne <a href="mailto:damien.de-vienne@u-psud.fr">damien.de-vienne@u-psud.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.phylo">plot.phylo</a></code>, <code><a href="#topic+drop.tip">drop.tip</a></code>, <code><a href="#topic+subtrees">subtrees</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#example 1: simple
tree1 &lt;- rtree(50)
tree2 &lt;- subtreeplot(tree1, wait = TRUE) # on exit, tree2 will be a subtree of tree1

#example 2: more than one zoom
tree1 &lt;- rtree(60)
tree2 &lt;- subtreeplot(subtreeplot(subtreeplot(tree1))) # allow three succssive zooms

## End(Not run)
</code></pre>

<hr>
<h2 id='subtrees'>All subtrees of a Phylogenetic Tree</h2><span id='topic+subtrees'></span>

<h3>Description</h3>

<p>This function returns a list of all the subtrees of a phylogenetic tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subtrees(tree, wait=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subtrees_+3A_tree">tree</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="subtrees_+3A_wait">wait</code></td>
<td>
<p>a logical indicating whether the node beeing processed should be printed (useful for big phylogenies).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>subtrees</code> returns a list of trees of class <code>"phylo"</code> and
returns invisibly for each subtree a list with the following
components:
</p>
<table>
<tr><td><code>tip.label</code></td>
<td>
</td></tr>
<tr><td><code>node.label</code></td>
<td>
</td></tr>
<tr><td><code>Ntip</code></td>
<td>
</td></tr>
<tr><td><code>Nnode</code></td>
<td>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Damien de Vienne <a href="mailto:damien.de-vienne@u-psud.fr">damien.de-vienne@u-psud.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+zoom">zoom</a></code>, <code><a href="#topic+subtreeplot">subtreeplot</a></code> for functions extracting particular subtrees.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Random tree with 12 leaves
phy&lt;-rtree(12)
par(mfrow=c(4,3))
plot(phy, sub="Complete tree")

### Extract the subtrees
l&lt;-subtrees(phy)

### plot all the subtrees
for (i in 1:11) plot(l[[i]], sub=paste("Node", l[[i]]$node.label[1]))
par(mfrow=c(1,1))
</code></pre>

<hr>
<h2 id='summary.phylo'>Print Summary of a Phylogeny</h2><span id='topic+summary.phylo'></span><span id='topic+Ntip'></span><span id='topic+Ntip.phylo'></span><span id='topic+Ntip.multiPhylo'></span><span id='topic+Nnode'></span><span id='topic+Nnode.phylo'></span><span id='topic+Nnode.multiPhylo'></span><span id='topic+Nedge'></span><span id='topic+Nedge.phylo'></span><span id='topic+Nedge.multiPhylo'></span>

<h3>Description</h3>

<p>The first function prints a compact summary of a phylogenetic tree (an
object of class <code>"phylo"</code>). The three other functions return the
number of tips, nodes, or edges, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phylo'
summary(object, ...)

Ntip(phy)
## S3 method for class 'phylo'
Ntip(phy)
## S3 method for class 'multiPhylo'
Ntip(phy)

Nnode(phy, ...)
## S3 method for class 'phylo'
Nnode(phy, internal.only = TRUE, ...)
## S3 method for class 'multiPhylo'
Nnode(phy, internal.only = TRUE, ...)

Nedge(phy)
## S3 method for class 'phylo'
Nedge(phy)
## S3 method for class 'multiPhylo'
Nedge(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.phylo_+3A_object">object</code>, <code id="summary.phylo_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code> or
<code>"multiPhylo"</code>.</p>
</td></tr>
<tr><td><code id="summary.phylo_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.phylo_+3A_internal.only">internal.only</code></td>
<td>
<p>a logical indicating whether to return the number
of internal nodes only (the default), or of internal and terminal
(tips) nodes (if <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The summary includes the numbers of tips and of nodes, summary
statistics of the branch lengths (if they are available) with mean,
variance, minimum, first quartile, median, third quartile, and
maximum, listing of the first ten tip labels, and (if available) of
the first ten node labels. It is also printed whether some of these
optional elements (branch lengths, node labels, and root edge) are not
found in the tree.
</p>
<p><code>summary</code> simply prints its results on the standard output and is
not meant for programming.
</p>


<h3>Value</h3>

<p>A NULL value in the case of <code>summary</code>, a single numeric value for
the three other functions.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.tree">read.tree</a></code>, <code><a href="base.html#topic+summary">summary</a></code> for the generic R
function, <code><a href="#topic+multiphylo">multiphylo</a></code>, <code><a href="#topic+c.phylo">c.phylo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bird.families)
summary(bird.families)
Ntip(bird.families)
Nnode(bird.families)
Nedge(bird.families)
</code></pre>

<hr>
<h2 id='trans'>Translation from DNA to Amino Acid Sequences</h2><span id='topic+trans'></span><span id='topic+complement'></span>

<h3>Description</h3>

<p><code>trans</code> translates DNA sequences into amino acids.
<code>complement</code> returns the (reverse) complement sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trans(x, code = 1, codonstart = 1)
complement(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trans_+3A_x">x</code></td>
<td>
<p>an object of class <code>"DNAbin"</code> (vector, matrix or list).</p>
</td></tr>
<tr><td><code id="trans_+3A_code">code</code></td>
<td>
<p>an integer value giving the genetic code to be
used. Currently only the genetic codes  1 to 6 are supported.</p>
</td></tr>
<tr><td><code id="trans_+3A_codonstart">codonstart</code></td>
<td>
<p>an integer giving where to start the translation. This
should be 1, 2, or 3, but larger values are accepted and have for
effect to start the translation further towards the 3'-end of the sequence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With <code>trans</code>, if the sequence length is not a multiple of three,
a warning message is printed. Alignment gaps are simply ignored (i.e.,
<code>AG-</code> returns <code>X</code> with no special warning or message). Base
ambiguities are taken into account where relevant: for instance,
<code>GGN</code>, <code>GGA</code>, <code>GGR</code>, etc, all return <code>G</code>.
</p>
<p>See the link given in the References for details about the taxonomic
coverage and alternative codons of each code.
</p>


<h3>Value</h3>

<p>an object of class <code>"AAbin"</code> or <code>"DNAbin"</code>, respectively.
</p>


<h3>Note</h3>

<p>These functions are equivalent to <code>translate</code> and <code>comp</code> in
the package <span class="pkg">seqinr</span> with the difference that there is no need to
convert the sequences into character strings.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p><a href="https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes">https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AAbin">AAbin</a></code>, <code><a href="#topic+checkAlignment">checkAlignment</a></code>, <code><a href="#topic+alview">alview</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
X &lt;- trans(woodmouse) # not correct
X2 &lt;- trans(woodmouse, 2) # using the correct code
identical(X, X2)
alview(X[1:2, 1:60]) # some 'Stop' codons (*)
alview(X2[, 1:60])
X2
</code></pre>

<hr>
<h2 id='treePop'>Tree Popping</h2><span id='topic+treePop'></span>

<h3>Description</h3>

<p>Method for reconstructing phylogenetic trees from an object of class
splits using tree popping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treePop(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treePop_+3A_obj">obj</code></td>
<td>
<p>an object of class <code>"bitsplit"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;phylo&quot; which displays all the splits
in the input object.
</p>


<h3>Author(s)</h3>

<p>Andrei Popescu</p>

<hr>
<h2 id='trex'>Tree Explorer With Multiple Devices</h2><span id='topic+trex'></span>

<h3>Description</h3>

<p>This function requires a plotted tree: the user is invited to click
close to a node and the corresponding subtree (or clade) is plotted on
a new window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trex(phy, title = TRUE, subbg = "lightyellow3",
     return.tree = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trex_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="trex_+3A_title">title</code></td>
<td>
<p>a logical or a character string (see details).</p>
</td></tr>
<tr><td><code id="trex_+3A_subbg">subbg</code></td>
<td>
<p>a character string giving the background colour for the
subtree.</p>
</td></tr>
<tr><td><code id="trex_+3A_return.tree">return.tree</code></td>
<td>
<p>a logical: if <code>TRUE</code>, the subtree is returned
after being plotted and the operation is stopped.</p>
</td></tr>
<tr><td><code id="trex_+3A_...">...</code></td>
<td>
<p>further arguments to pass to <code>plot.phylo</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works with a tree (freshly) plotted on an interactive
graphical device (i.e., not a file). After calling <code>trex</code>, the
user clicks close to a node of the tree, then the clade from this node
is plotted on a <em>new</em> window. The user can click as many times on
the main tree: the clades are plotted successively on the <em>same</em>
new window. The process is stopped by a right-click. If the user clicks
too close to the tips, a message &ldquo;Try again!&rdquo; is printed.
</p>
<p>Each time <code>trex</code> is called, the subtree is plotted on a new
window without closing or deleting those possibly already
plotted. They may be distinguished with the options <code>title</code>
and/or <code>subbg</code>.
</p>
<p>In all cases, the device where <code>phy</code> is plotted is the active
window after the operation. It should <em>not</em> be closed during the
whole process.
</p>
<p>If <code>title = TRUE</code>, a default title is printed on the new window
using the node label, or the node number if there are no node labels
in the tree. If <code>title = FALSE</code>, no title is printed. If
<code>title</code> is a character string, it is used for the title.
</p>


<h3>Value</h3>

<p>an object of class <code>"phylo"</code> if <code>return.tree = TRUE</code>
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.phylo">plot.phylo</a></code>, <code><a href="#topic+identify.phylo">identify.phylo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tr &lt;- rcoal(1000)
plot(tr, show.tip.label = FALSE)
trex(tr) # left-click as many times as you want, then right-click
tr &lt;- makeNodeLabel(tr)
trex(tr, subbg = "lightgreen") # id.

## generate a random colour with control on the darkness:
rRGB &lt;- function(a, b)
    rgb(runif(1, a, b), runif(1, a, b), runif(1, a, b))

### with a random pale background:
trex(tr, subbg = rRGB(0.8, 1))
## the above can be called many times...
graphics.off() # close all graphical devices

## End(Not run)</code></pre>

<hr>
<h2 id='triangMtd'>Tree Reconstruction Based on the Triangles Method</h2><span id='topic+triangMtd'></span><span id='topic+triangMtds'></span>

<h3>Description</h3>

<p>Fast distance-based construction method. Should only be used when
distance measures are fairly reliable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangMtd(X)
triangMtds(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangMtd_+3A_x">X</code></td>
<td>
<p>a distance matrix</p>
</td></tr></table>
<p>.
</p>


<h3>Value</h3>

<p>an object of class <code>"phylo"</code>.
</p>


<h3>Author(s)</h3>

<p>Andrei Popescu</p>


<h3>References</h3>

<p><a href="http://archive.numdam.org/ARCHIVE/RO/RO_2001__35_2/RO_2001__35_2_283_0/RO_2001__35_2_283_0.pdf">http://archive.numdam.org/ARCHIVE/RO/RO_2001__35_2/RO_2001__35_2_283_0/RO_2001__35_2_283_0.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nj">nj</a></code>, <code><a href="#topic+bionj">bionj</a></code>, <code><a href="#topic+fastme">fastme</a></code>,
<code><a href="#topic+njs">njs</a></code>, <code><a href="#topic+mvrs">mvrs</a></code>, <code><a href="#topic+SDM">SDM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
tr &lt;- triangMtd(dist.dna(woodmouse))
plot(tr)
</code></pre>

<hr>
<h2 id='unique.multiPhylo'>Revomes Duplicate Trees</h2><span id='topic+unique.multiPhylo'></span>

<h3>Description</h3>

<p>This function scans a list of trees, and returns a list with the
duplicate trees removed. By default the labelled topologies are
compared.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiPhylo'
unique(x, incomparables = FALSE,
        use.edge.length = FALSE,
        use.tip.label = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unique.multiPhylo_+3A_x">x</code></td>
<td>
<p>an object of class <code>"multiPhylo"</code>.</p>
</td></tr>
<tr><td><code id="unique.multiPhylo_+3A_incomparables">incomparables</code></td>
<td>
<p>unused (for compatibility with the generic).</p>
</td></tr>
<tr><td><code id="unique.multiPhylo_+3A_use.edge.length">use.edge.length</code></td>
<td>
<p>a logical specifying whether to consider the edge
lengths in the comparisons; the default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="unique.multiPhylo_+3A_use.tip.label">use.tip.label</code></td>
<td>
<p>a logical specifying whether to consider the tip
labels in the comparisons; the default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="unique.multiPhylo_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"multiPhylo"</code> with an attribute
<code>"old.index"</code> indicating which trees of the original list are
similar (the tree of smaller index is taken as reference).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code>all.equal.phylo</code>, <code><a href="base.html#topic+unique">unique</a></code> for the generic R
function, <code>read.tree</code>, <code>read.nexus</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TR &lt;- rmtree(50, 4)
length(unique(TR)) # not always 15...
howmanytrees(4)
</code></pre>

<hr>
<h2 id='updateLabel'>Update Labels</h2><span id='topic+updateLabel'></span><span id='topic+updateLabel.DNAbin'></span><span id='topic+updateLabel.AAbin'></span><span id='topic+updateLabel.character'></span><span id='topic+updateLabel.phylo'></span><span id='topic+updateLabel.evonet'></span><span id='topic+updateLabel.data.frame'></span><span id='topic+updateLabel.matrix'></span>

<h3>Description</h3>

<p>This function changes labels (names or rownames) giving two vectors (<code>old</code> and <code>new</code>). It is a generic function with several methods as described below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateLabel(x, old, new, ...)
## S3 method for class 'character'
updateLabel(x, old, new, exact = TRUE, ...)
## S3 method for class 'DNAbin'
updateLabel(x, old, new, exact = TRUE, ...)
## S3 method for class 'AAbin'
updateLabel(x, old, new, exact = TRUE, ...)
## S3 method for class 'phylo'
updateLabel(x, old, new, exact = TRUE, nodes = FALSE, ...)
## S3 method for class 'evonet'
updateLabel(x, old, new, exact = TRUE, nodes = FALSE, ...)
## S3 method for class 'data.frame'
updateLabel(x, old, new, exact = TRUE, ...)
## S3 method for class 'matrix'
updateLabel(x, old, new, exact = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateLabel_+3A_x">x</code></td>
<td>
<p>an object where to change the labels.</p>
</td></tr>
<tr><td><code id="updateLabel_+3A_old">old</code>, <code id="updateLabel_+3A_new">new</code></td>
<td>
<p>two vectors of mode character (must be of the same length).</p>
</td></tr>
<tr><td><code id="updateLabel_+3A_exact">exact</code></td>
<td>
<p>a logical value (see details).</p>
</td></tr>
<tr><td><code id="updateLabel_+3A_nodes">nodes</code></td>
<td>
<p>a logical value specifying whether to also update the node labels of the tree or network.</p>
</td></tr>
<tr><td><code id="updateLabel_+3A_...">...</code></td>
<td>
<p>further arguments passed to and from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to change some of the labels (see examples) or all of them if their ordering is not sure.
</p>
<p>If <code>exact = TRUE</code> (the default), the values in <code>old</code> are matched exactly with the labels; otherwise (<code>exact = FALSE</code>), the values in <code>old</code> are considered as regular expressions and searched in the labels with <code><a href="base.html#topic+grep">grep</a></code>.
</p>


<h3>Value</h3>

<p>an object of the same class than <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeLabel">makeLabel</a></code>, <code><a href="#topic+makeNodeLabel">makeNodeLabel</a></code>,
<code><a href="#topic+mixedFontLabel">mixedFontLabel</a></code>, <code><a href="#topic+stripLabel">stripLabel</a></code>,
<code><a href="#topic+checkLabel">checkLabel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## the tree by Nyakatura &amp; Bininda-Emonds (2012, BMC Biology)
x &lt;- "https://static-content.springer.com/esm/art"
y &lt;- "3A10.1186"
z &lt;- "2F1741-7007-10-12/MediaObjects/12915_2011_534_MOESM5_ESM.NEX"
## The commande below may not print correctly in HTML because of the
## percentage symbol; see the text or PDF help page.
url &lt;- paste(x, y, z, sep = "
TC &lt;- read.nexus(url)
tr &lt;- TC$carnivoreST_bestEstimate
old &lt;- c("Uncia_uncia", "Felis_manul", "Leopardus_jacobitus")
new &lt;- c("Panthera_uncia", "Otocolobus_manul", "Leopardus_jacobita")
tr.updated &lt;- updateLabel(tr, old, new)

## End(Not run)

tr &lt;- rtree(6)
## the order of the labels are randomized by this function
old &lt;- paste0("t", 1:6)
new &lt;- paste0("x", 1:6)
updateLabel(tr, old, new)
tr
</code></pre>

<hr>
<h2 id='varcomp'>Compute Variance Component Estimates</h2><span id='topic+varcomp'></span>

<h3>Description</h3>

<p>Get variance component estimates from a fitted <code>lme</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varcomp(x, scale = FALSE, cum = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varcomp_+3A_x">x</code></td>
<td>
<p>A fitted <code>lme</code> object</p>
</td></tr>
<tr><td><code id="varcomp_+3A_scale">scale</code></td>
<td>
<p>Scale all variance so that they sum to 1</p>
</td></tr>
<tr><td><code id="varcomp_+3A_cum">cum</code></td>
<td>
<p>Send cumulative variance components.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Variance computations is done as in Venables and Ripley (2002).
</p>


<h3>Value</h3>

<p>A named vector of class <code>varcomp</code> with estimated variance components.
</p>


<h3>Author(s)</h3>

<p>Julien Dutheil <a href="mailto:dutheil@evolbio.mpg.de">dutheil@evolbio.mpg.de</a></p>


<h3>References</h3>

<p>Venables, W. N. and Ripley, B. D. (2002) <em>Modern Applied Statistics
with S (Fourth Edition)</em>. New York: Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="nlme.html#topic+lme">lme</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carnivora)
library(nlme)
m &lt;- lme(log10(SW) ~ 1, random = ~ 1|Order/SuperFamily/Family/Genus, data=carnivora)
v &lt;- varcomp(m, TRUE, TRUE)
plot(v)
</code></pre>

<hr>
<h2 id='varCompPhylip'>Variance Components with Orthonormal Contrasts</h2><span id='topic+varCompPhylip'></span>

<h3>Description</h3>

<p>This function calls Phylip's contrast program and returns the
phylogenetic and phenotypic variance-covariance components for one or
several traits. There can be several observations per species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varCompPhylip(x, phy, exec = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varCompPhylip_+3A_x">x</code></td>
<td>
<p>a numeric vector, a matrix (or data frame), or a list.</p>
</td></tr>
<tr><td><code id="varCompPhylip_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="varCompPhylip_+3A_exec">exec</code></td>
<td>
<p>a character string giving the name of the executable
contrast program (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data <code>x</code> can be in several forms: (i) a numeric vector if
there is single trait and one observation per species; (ii) a
matrix or data frame if there are several traits (as columns) and a
single observation of each trait for each species; (iii) a list of
vectors if there is a single trait and several observations per
species; (iv) a list of matrices or data frames: same than (ii) but
with several traits and the rows are individuals.
</p>
<p>If <code>x</code> has names, its values are matched to the tip labels of
<code>phy</code>, otherwise its values are taken to be in the same order
than the tip labels of <code>phy</code>.
</p>
<p>Phylip (version 3.68 or higher) must be accessible on your computer. If
you have a Unix-like operating system, the executable name is assumed
to be <code>"phylip contrast"</code> (as in Debian); otherwise it is set
to <code>"contrast"</code>. If this doesn't suit your system, use the
option <code>exec</code> accordingly. If the executable is not in the path, you
may need to specify it, e.g., <code>exec = "C:/Program Files/Phylip/contrast"</code>.
</p>


<h3>Value</h3>

<p>a list with elements <code>varA</code> and <code>varE</code> with the phylogenetic
(additive) and phenotypic (environmental) variance-covariance
matrices. If a single trait is analyzed, these contains its variances.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Felsenstein, J. (2004) Phylip (Phylogeny Inference Package) version
3.68. Department of Genetics, University of Washington, Seattle, USA.
<a href="http://evolution.genetics.washington.edu/phylip/phylip.html">http://evolution.genetics.washington.edu/phylip/phylip.html</a>.
</p>
<p>Felsenstein, J. (2008) Comparative methods with sampling error and
within-species variation: Contrasts revisited and revised.
<em>American Naturalist</em>, <b>171</b>, 713&ndash;725.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pic">pic</a></code>, <code><a href="#topic+pic.ortho">pic.ortho</a></code>, <code><a href="#topic+compar.lynch">compar.lynch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tr &lt;- rcoal(30)
### Five traits, one observation per species:
x &lt;- replicate(5, rTraitCont(tr, sigma = 1))
varCompPhylip(x, tr) # varE is small
x &lt;- replicate(5, rnorm(30))
varCompPhylip(x, tr) # varE is large
### Five traits, ten observations per species:
x &lt;- replicate(30, replicate(5, rnorm(10)), simplify = FALSE)
varCompPhylip(x, tr)

## End(Not run)</code></pre>

<hr>
<h2 id='vcv'>Phylogenetic Variance-covariance or Correlation Matrix</h2><span id='topic+vcv'></span><span id='topic+vcv.phylo'></span><span id='topic+vcv.corPhyl'></span>

<h3>Description</h3>

<p>This function computes the expected variances and covariances of a
continuous trait assuming it evolves under a given model.
</p>
<p>This is a generic function with methods for objects of class
<code>"phylo"</code> and <code>"corPhyl"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcv(phy, ...)
## S3 method for class 'phylo'
vcv(phy, model = "Brownian", corr = FALSE, ...)
## S3 method for class 'corPhyl'
vcv(phy, corr = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcv_+3A_phy">phy</code></td>
<td>
<p>an object of the correct class (see above).</p>
</td></tr>
<tr><td><code id="vcv_+3A_model">model</code></td>
<td>
<p>a character giving the model used to compute the
variances and covariances; only <code>"Brownian"</code> is available (for
other models, a correlation structure may be used).</p>
</td></tr>
<tr><td><code id="vcv_+3A_corr">corr</code></td>
<td>
<p>a logical indicating whether the correlation matrix should
be returned (<code>TRUE</code>); by default the variance-covariance matrix
is returned (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="vcv_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric matrix with the names of the tips as colnames and rownames.
</p>


<h3>Note</h3>

<p>Do not confuse this function with <code><a href="stats.html#topic+vcov">vcov</a></code> which
computes the variance-covariance matrix among parameters of a fitted
model object.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Garland, T. Jr. and Ives, A. R. (2000) Using the past to predict the
present: confidence intervals for regression equations in phylogenetic
comparative methods. <em>American Naturalist</em>, <b>155</b>, 346&ndash;364.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corBrownian">corBrownian</a></code>, <code><a href="#topic+corMartins">corMartins</a></code>,
<code><a href="#topic+corGrafen">corGrafen</a></code>, <code><a href="#topic+corPagel">corPagel</a></code>,
<code><a href="#topic+corBlomberg">corBlomberg</a></code>, <code><a href="#topic+vcv2phylo">vcv2phylo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tr &lt;- rtree(5)
## all are the same:
vcv(tr)
vcv(corBrownian(1, tr))
vcv(corPagel(1, tr))
</code></pre>

<hr>
<h2 id='vcv2phylo'>Variance-Covariance Matrix to Tree</h2><span id='topic+vcv2phylo'></span>

<h3>Description</h3>

<p>This function transforms a variance-covariance matrix into a
phylogenetic tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcv2phylo(mat, tolerance = 1e-7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcv2phylo_+3A_mat">mat</code></td>
<td>
<p>a square symmetric (positive-definite) matrix.</p>
</td></tr>
<tr><td><code id="vcv2phylo_+3A_tolerance">tolerance</code></td>
<td>
<p>the numeric tolerance used to compare the branch
lengths.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function tests if the matrix is symmetric and positive-definite
(i.e., all its eigenvalues positive within the specified tolerance).
</p>


<h3>Value</h3>

<p>an object of class <code>"phylo"</code>.
</p>


<h3>Author(s)</h3>

<p>Simon Blomberg</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcv">vcv</a></code>, <code><a href="#topic+corPhyl">corPhyl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tr &lt;- rtree(10)
V &lt;- vcv(tr) # VCV matrix assuming Brownian motion
z &lt;- vcv2phylo(V)
identical(tr, z) # FALSE
all.equal(tr, z) # TRUE
</code></pre>

<hr>
<h2 id='weight.taxo'>Define Similarity Matrix</h2><span id='topic+weight.taxo'></span><span id='topic+weight.taxo2'></span>

<h3>Description</h3>

<p><code>weight.taxo</code> computes a matrix whose entries [i, j] are set to 1
if x[i] == x[j], 0 otherwise.
</p>
<p><code>weight.taxo2</code> computes a matrix whose entries [i, j] are set to 1
if x[i] == x[j] AND y[i] != y[j], 0 otherwise.
</p>
<p>The diagonal [i, i] is always set to 0.
</p>
<p>The returned matrix can be used as a weight matrix in
<code><a href="#topic+Moran.I">Moran.I</a></code>. <code>x</code> and <code>y</code> may be vectors of
factors.
</p>
<p>See further details in <code>vignette("MoranI")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  weight.taxo(x)
  weight.taxo2(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weight.taxo_+3A_x">x</code>, <code id="weight.taxo_+3A_y">y</code></td>
<td>
<p>a vector or a factor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a square numeric matrix.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+Moran.I">Moran.I</a></code>, <code><a href="#topic+correlogram.formula">correlogram.formula</a></code>
</p>

<hr>
<h2 id='where'>Find Patterns in DNA Sequences</h2><span id='topic+where'></span>

<h3>Description</h3>

<p>This function finds patterns in a single or a set of DNA or AA sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>where(x, pattern)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="where_+3A_x">x</code></td>
<td>
<p>an object inheriting the class either <code>"DNAbin"</code> or
<code>"AAbin"</code>.</p>
</td></tr>
<tr><td><code id="where_+3A_pattern">pattern</code></td>
<td>
<p>a character string to be searched in <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a vector, the function returns a single vector giving
the position(s) where the pattern was found. If <code>x</code> is a matrix
or a list, it returns a list with the positions of the pattern for
each sequence.
</p>
<p>Patterns may be overlapping. For instance, if <code>pattern = "tata"</code>
and the sequence starts with &lsquo;tatata&rsquo;, then the output will be c(1, 3).
</p>


<h3>Value</h3>

<p>a vector of integers or a list of such vectors.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+DNAbin">DNAbin</a></code>, <code><a href="#topic+image.DNAbin">image.DNAbin</a></code>, <code><a href="#topic+AAbin">AAbin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
where(woodmouse, "tata")
## with AA sequences:
x &lt;- trans(woodmouse, 2)
where(x, "irk")
</code></pre>

<hr>
<h2 id='which.edge'>Identifies Edges of a Tree</h2><span id='topic+which.edge'></span>

<h3>Description</h3>

<p>This function identifies the edges that belong to a group (possibly
non-monophyletic) specified as a set of tips.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which.edge(phy, group)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which.edge_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="which.edge_+3A_group">group</code></td>
<td>
<p>a vector of mode numeric or character specifying the tips
for which the edges are to be identified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The group of tips specified in &lsquo;group&rsquo; may be non-monophyletic
(paraphyletic or polyphyletic), in which case all edges from the tips
to their most recent common ancestor are identified.
</p>
<p>The identification is made with the indices of the rows of the matrix
&lsquo;edge&rsquo; of the tree.
</p>


<h3>Value</h3>

<p>a numeric vector.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+bind.tree">bind.tree</a></code>, <code><a href="#topic+drop.tip">drop.tip</a></code>, <code><a href="#topic+root">root</a></code>
</p>

<hr>
<h2 id='woodmouse'>Cytochrome b Gene Sequences of Woodmice</h2><span id='topic+woodmouse'></span>

<h3>Description</h3>

<p>This is a set of 15 sequences of the mitochondrial gene cytochrome
<em>b</em> of the woodmouse (<em>Apodemus sylvaticus</em>) which is a
subset of the data analysed by Michaux et al. (2003). The full data
set is available through GenBank (accession numbers AJ511877 to
AJ511987).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(woodmouse)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"DNAbin"</code>.
</p>


<h3>Source</h3>

<p>Michaux, J. R., Magnanou, E., Paradis, E., Nieberding, C. and Libois,
R. (2003) Mitochondrial phylogeography of the Woodmouse
(<em>Apodemus sylvaticus</em>) in the Western Palearctic region.
<em>Molecular Ecology</em>, <b>12</b>, 685&ndash;697.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.dna">read.dna</a></code>, <code><a href="#topic+DNAbin">DNAbin</a></code>, <code><a href="#topic+dist.dna">dist.dna</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
str(woodmouse)
</code></pre>

<hr>
<h2 id='write.dna'>Write DNA Sequences in a File</h2><span id='topic+write.dna'></span><span id='topic+write.FASTA'></span>

<h3>Description</h3>

<p>These functions write in a file a list of DNA sequences in sequential,
interleaved, or FASTA format. <code>write.FASTA</code> can write either DNA
or AA sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.dna(x, file, format = "interleaved", append = FALSE,
          nbcol = 6, colsep = " ", colw = 10, indent = NULL,
          blocksep = 1)
write.FASTA(x, file, header = NULL, append = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.dna_+3A_x">x</code></td>
<td>
<p>a list or a matrix of DNA sequences, or of AA sequences for
<code>write.FASTA</code>.</p>
</td></tr>
<tr><td><code id="write.dna_+3A_file">file</code></td>
<td>
<p>a file name specified by either a variable of mode character,
or a double-quoted string.</p>
</td></tr>
<tr><td><code id="write.dna_+3A_format">format</code></td>
<td>
<p>a character string specifying the format of the DNA
sequences. Three choices are possible: <code>"interleaved"</code>,
<code>"sequential"</code>, or <code>"fasta"</code>, or any unambiguous
abbreviation of these.</p>
</td></tr>
<tr><td><code id="write.dna_+3A_append">append</code></td>
<td>
<p>a logical, if <code>TRUE</code> the data are appended to the
file without erasing the data possibly existing in the file,
otherwise the file (if it exists) is overwritten (<code>FALSE</code> the
default).</p>
</td></tr>
<tr><td><code id="write.dna_+3A_nbcol">nbcol</code></td>
<td>
<p>a numeric specifying the number of columns per row (6 by
default); may be negative implying that the nucleotides are printed
on a single line.</p>
</td></tr>
<tr><td><code id="write.dna_+3A_colsep">colsep</code></td>
<td>
<p>a character used to separate the columns (a single
space by default).</p>
</td></tr>
<tr><td><code id="write.dna_+3A_colw">colw</code></td>
<td>
<p>a numeric specifying the number of nucleotides per column
(10 by default).</p>
</td></tr>
<tr><td><code id="write.dna_+3A_indent">indent</code></td>
<td>
<p>a numeric or a character specifying how the blocks of
nucleotides are indented (see details).</p>
</td></tr>
<tr><td><code id="write.dna_+3A_blocksep">blocksep</code></td>
<td>
<p>a numeric specifying the number of lines between the
blocks of nucleotides (this has an effect only if 'format =
&quot;interleaved&quot;').</p>
</td></tr>
<tr><td><code id="write.dna_+3A_header">header</code></td>
<td>
<p>a vector of mode character giving the header to be
written in the FASTA file before the sequences. By default, there is
no header.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Three formats are supported in the present function: see the help page
of <code><a href="#topic+read.dna">read.dna</a></code> and the references below for a description.
</p>
<p>If the sequences have no names, then they are given &quot;1&quot;, &quot;2&quot;, ... as
labels in the file.
</p>
<p>With the interleaved and sequential formats, the sequences must be all
of the same length. The names of the sequences are not truncated.
</p>
<p>The argument <code>indent</code> specifies how the rows of nucleotides are
indented. In the interleaved and sequential formats, the rows with
the taxon names are never indented; the subsequent rows are indented
with 10 spaces by default (i.e., if <code>indent = NULL</code>). In the FASTA
format, the rows are not indented by default. This default behaviour
can be modified by specifying a value to <code>indent</code>: the rows are then
indented with &ldquo;indent&rdquo; (if it is a character) or &lsquo;indent&rsquo; spaces (if
it is a numeric). For example, specifying <code>indent = "   "</code> or
<code>indent = 3</code> will have the same effect (use <code>indent = "\t"</code>
for a tabulation).
</p>
<p>The different options are intended to give flexibility in formatting
the sequences. For instance, if the sequences are very long it may be
judicious to remove all the spaces beween columns (colsep = &quot;&quot;), in
the margins (indent = 0), and between the blocks (blocksep = 0) to
produce a smaller file.
</p>
<p><code>write.dna(, format = "fasta")</code> can be very slow if the sequences
are long (&gt; 10 kb). <code>write.FASTA</code> is much faster in this
situation but the formatting is not flexible: each sequence is printed
on a single line, which is OK for big files that are not intended to
be open with a text editor.
</p>


<h3>Value</h3>

<p>None (invisible &lsquo;NULL&rsquo;).
</p>


<h3>Note</h3>

<p>Specifying a negative value for &lsquo;nbcol&rsquo; (meaning that the nucleotides
are printed on a single line) gives the same output for the
interleaved and sequential formats.
</p>
<p>The names of the sequences can be truncated with the function
<code><a href="#topic+makeLabel">makeLabel</a></code>. In particular, Clustal is limited to 30
characters, and PHYML seems limited to 99 characters.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Anonymous. FASTA format. <a href="https://en.wikipedia.org/wiki/FASTA_format">https://en.wikipedia.org/wiki/FASTA_format</a>
</p>
<p>Felsenstein, J. (1993) Phylip (Phylogeny Inference Package) version
3.5c. Department of Genetics, University of Washington.
<a href="http://evolution.genetics.washington.edu/phylip/phylip.html">http://evolution.genetics.washington.edu/phylip/phylip.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.dna">read.dna</a></code>, <code><a href="#topic+read.GenBank">read.GenBank</a></code>,
<code><a href="#topic+makeLabel">makeLabel</a></code>
</p>

<hr>
<h2 id='write.nexus'>Write Tree File in Nexus Format</h2><span id='topic+write.nexus'></span>

<h3>Description</h3>

<p>This function writes trees in a file with the NEXUS format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.nexus(..., file = "", translate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.nexus_+3A_...">...</code></td>
<td>
<p>either (i) a single object of class <code>"phylo"</code>, (ii) a
series of such objects separated by commas, or (iii) a list
containing such objects.</p>
</td></tr>
<tr><td><code id="write.nexus_+3A_file">file</code></td>
<td>
<p>a file name specified by either a variable of mode character,
or a double-quoted string; if <code>file = ""</code> (the default) then the
tree is written on the standard output connection.</p>
</td></tr>
<tr><td><code id="write.nexus_+3A_translate">translate</code></td>
<td>
<p>a logical, if <code>TRUE</code> (the default) a translation
of the tip labels is done which are replaced in the parenthetic
representation with tokens.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If several trees are given, they must all have the same tip labels.
</p>
<p>If among the objects given some are not trees of class <code>"phylo"</code>,
they are simply skipped and not written in the file.
</p>
<p>See <code><a href="#topic+write.tree">write.tree</a></code> for details on how tip (and node) labels
are checked before being printed.
</p>


<h3>Value</h3>

<p>None (invisible &lsquo;NULL&rsquo;).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Maddison, D. R., Swofford, D. L. and Maddison, W. P. (1997) NEXUS: an
extensible file format for systematic information. <em>Systematic
Biology</em>, <b>46</b>, 590&ndash;621.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.nexus">read.nexus</a></code>, <code><a href="#topic+read.tree">read.tree</a></code>,
<code><a href="#topic+write.tree">write.tree</a></code>, <code><a href="#topic+read.nexus.data">read.nexus.data</a></code>,
<code><a href="#topic+write.nexus.data">write.nexus.data</a></code>
</p>

<hr>
<h2 id='write.nexus.data'>Write Character Data in NEXUS Format</h2><span id='topic+write.nexus.data'></span>

<h3>Description</h3>

<p>This function writes in a file a list of data in the NEXUS format. The
names of the vectors of the list are used as taxon names.
</p>
<p>For the moment, only sequence data (DNA or protein) are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.nexus.data(x, file, format = "dna", datablock = TRUE,
                 interleaved = TRUE, charsperline = NULL,
                 gap = NULL, missing = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.nexus.data_+3A_x">x</code></td>
<td>
<p>a matrix or a list of data each made of a single vector
of mode character where each element is a character state (e.g.,
&ldquo;A&rdquo;, &ldquo;C&rdquo;, ...) Objects of class of &ldquo;DNAbin&rdquo;
are accepted.</p>
</td></tr>
<tr><td><code id="write.nexus.data_+3A_file">file</code></td>
<td>
<p>a file name specified by either a variable of mode
character, or a double-quoted string.</p>
</td></tr>
<tr><td><code id="write.nexus.data_+3A_format">format</code></td>
<td>
<p>a character string specifying the format of the
sequences. Four choices are possible: <code>"dna"</code> (the default)
<code>"protein"</code>, <code>"standard"</code> or <code>"continuous"</code> or any
unambiguous abbreviation of these (case insensitive).</p>
</td></tr>
<tr><td><code id="write.nexus.data_+3A_datablock">datablock</code></td>
<td>
<p>a logical, if <code>TRUE</code> the data are written in a
single DATA block. If <code>FALSE</code>, the data are written in TAXA and
CHARACTER blocks. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="write.nexus.data_+3A_interleaved">interleaved</code></td>
<td>
<p>a logical, if <code>TRUE</code> the data is written in
interleaved format with number of characters per line as specified
with <code>charsperline = numerical_value</code>. If <code>FALSE</code>, the
data are written in sequential format. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="write.nexus.data_+3A_charsperline">charsperline</code></td>
<td>
<p>a numeric value specifying the number of
characters per line when used with <code>interleaved =
      TRUE</code>. Default is 80.</p>
</td></tr>
<tr><td><code id="write.nexus.data_+3A_gap">gap</code></td>
<td>
<p>a character specifying the symbol for gap. Default is
&ldquo;<code>-</code>&rdquo;.</p>
</td></tr>
<tr><td><code id="write.nexus.data_+3A_missing">missing</code></td>
<td>
<p>a character specifying the symbol for missing
data. Default is &ldquo;<code>?</code>&rdquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the sequences have no names, then they are given &ldquo;1&rdquo;,
&ldquo;2&rdquo;, ..., as names in the file.
</p>
<p>Sequences must be all of the same length.
</p>


<h3>Value</h3>

<p>None (invisible &lsquo;NULL&rsquo;).
</p>


<h3>Author(s)</h3>

<p>Johan Nylander <a href="mailto:nylander@scs.fsu.edu">nylander@scs.fsu.edu</a> and Thomas Guillerme</p>


<h3>References</h3>

<p>Maddison, D. R., Swofford, D. L. and Maddison, W. P. (1997) NEXUS: an
extensible file format for systematic information. <em>Systematic
Biology</em>, <b>46</b>, 590&ndash;621.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.nexus">read.nexus</a></code>,<code><a href="#topic+write.nexus">write.nexus</a></code>,
<code><a href="#topic+read.nexus.data">read.nexus.data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Write interleaved DNA data with 100 characters per line in a DATA block
data(woodmouse)
write.nexus.data(woodmouse, file= "wood.ex.nex", interleaved = TRUE, charsperline = 100)
## Write sequential DNA data in TAXA and CHARACTERS blocks
data(cynipids)
write.nexus.data(cynipids, file = "cyn.ex.nex", format = "protein",
                 datablock = FALSE, interleaved = FALSE)
unlink(c("wood.ex.nex", "cyn.ex.nex"))

## End(Not run)</code></pre>

<hr>
<h2 id='write.tree'>Write Tree File in Parenthetic Format</h2><span id='topic+write.tree'></span>

<h3>Description</h3>

<p>This function writes in a file a tree in parenthetic format using the
Newick (also known as New Hampshire) format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.tree(phy, file = "", append = FALSE,
           digits = 10, tree.names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.tree_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code> or <code>"multiPhylo"</code>.</p>
</td></tr>
<tr><td><code id="write.tree_+3A_file">file</code></td>
<td>
<p>a file name specified by either a variable of mode character,
or a double-quoted string; if <code>file = ""</code> (the default) then the
tree is written on the standard output connection (i.e. the console).</p>
</td></tr>
<tr><td><code id="write.tree_+3A_append">append</code></td>
<td>
<p>a logical, if <code>TRUE</code> the tree is appended to the file
without erasing the data possibly existing in the file, otherwise
the file (if it exists) is overwritten (<code>FALSE</code> the default).</p>
</td></tr>
<tr><td><code id="write.tree_+3A_digits">digits</code></td>
<td>
<p>a numeric giving the number of digits used for printing
branch lengths.</p>
</td></tr>
<tr><td><code id="write.tree_+3A_tree.names">tree.names</code></td>
<td>
<p>either a logical or a vector of mode character. If
<code>TRUE</code> then any tree names will be written prior to the tree on
each line. If character, specifies the name of <code>"phylo"</code>
objects which can be written to the file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The node labels and the root edge length, if available, are written in
the file.
</p>
<p>If <code>tree.names == TRUE</code> then a variant of the Newick format is
written for which the name of a tree precedes the Newick format tree
(parentheses are eventually deleted beforehand). The tree names are
taken from the <code>names</code> attribute if present (they are ignored if
<code>tree.names</code> is a character vector).
</p>
<p>The tip labels (and the node labels if present) are checked before
being printed: the leading and trailing spaces, and the leading left
and trailing right parentheses are deleted; the other spaces are
replaced by underscores; the commas, colons, semicolons, and the other
parentheses are replaced with dashes.
</p>


<h3>Value</h3>

<p>a vector of mode character if <code>file = ""</code>, none (invisible
<code>NULL</code>) otherwise.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis, Daniel Lawson
<a href="mailto:dan.lawson@bristol.ac.uk">dan.lawson@bristol.ac.uk</a>, and Klaus Schliep
<a href="mailto:kschliep@snv.jussieu.fr">kschliep@snv.jussieu.fr</a></p>


<h3>References</h3>

<p>Felsenstein, J. The Newick tree format.
<a href="http://evolution.genetics.washington.edu/phylip/newicktree.html">http://evolution.genetics.washington.edu/phylip/newicktree.html</a>
</p>
<p>Olsen, G. Interpretation of the &quot;Newick's 8:45&quot; tree format standard.
<a href="http://evolution.genetics.washington.edu/phylip/newick_doc.html">http://evolution.genetics.washington.edu/phylip/newick_doc.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.tree">read.tree</a></code>, <code><a href="#topic+read.nexus">read.nexus</a></code>,
<code><a href="#topic+write.nexus">write.nexus</a></code>
</p>

<hr>
<h2 id='yule'>Fits the Yule Model to a Phylogenetic Tree</h2><span id='topic+yule'></span>

<h3>Description</h3>

<p>This function fits by maximum likelihood a Yule model, i.e., a
birth-only model to the branching times computed from a phylogenetic
tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yule(phy, use.root.edge = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yule_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="yule_+3A_use.root.edge">use.root.edge</code></td>
<td>
<p>a logical specifying whether to consider the root
edge in the calculations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tree must be fully dichotomous.
</p>
<p>The maximum likelihood estimate of the speciation rate is obtained by
the ratio of the number of speciation events on the cumulative number
of species through time; these two quantities are obtained with the
number of nodes in the tree, and the sum of the branch lengths,
respectively.
</p>
<p>If there is a &lsquo;root.edge&rsquo; element in the phylogenetic tree, and
<code>use.root.edge = TRUE</code>, then it is assumed that it has a
biological meaning and is counted as a branch length, and the root is
counted as a speciation event; otherwise the number of speciation
events is the number of nodes - 1.
</p>
<p>The standard-error of lambda is computed with the second derivative of
the log-likelihood function.
</p>


<h3>Value</h3>

<p>An object of class &quot;yule&quot; which is a list with the following
components:
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>the maximum likelihood estimate of the speciation
(birth) rate.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>the standard-error of lambda.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>the log-likelihood at its maximum.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+branching.times">branching.times</a></code>, <code><a href="#topic+diversi.gof">diversi.gof</a></code>,
<code><a href="#topic+diversi.time">diversi.time</a></code>, <code><a href="#topic+ltt.plot">ltt.plot</a></code>,
<code><a href="#topic+birthdeath">birthdeath</a></code>, <code><a href="#topic+bd.ext">bd.ext</a></code>, <code><a href="#topic+yule.cov">yule.cov</a></code>
</p>

<hr>
<h2 id='yule.cov'>Fits the Yule Model With Covariates</h2><span id='topic+yule.cov'></span>

<h3>Description</h3>

<p>This function fits by maximum likelihood the Yule model with
covariates, that is a birth-only model where speciation rate is
determined by a generalized linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yule.cov(phy, formula, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yule.cov_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="yule.cov_+3A_formula">formula</code></td>
<td>
<p>a formula specifying the model to be fitted.</p>
</td></tr>
<tr><td><code id="yule.cov_+3A_data">data</code></td>
<td>
<p>the name of the data frame where the variables in
<code>formula</code> are to be found; by default, the variables are looked
for in the global environment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model fitted is a generalization of the Yule model where the
speciation rate is determined by:
</p>
<p style="text-align: center;"><code class="reqn">\ln\frac{\lambda_i}{1 - \lambda_i} = \beta_1 x_{i1} + \beta_2 x_{i2}
    + \dots + \alpha </code>
</p>

<p>where <code class="reqn">\lambda_i</code> is the speciation rate for species i,
<code class="reqn">x_{i1}, x_{i2}, \dots</code> are species-specific
variables, and <code class="reqn">\beta_1, \beta_2, \dots, \alpha</code>
are parameters to be estimated. The term on the left-hand side above
is a logit function often used in generalized linear models for
binomial data (see <code><a href="stats.html#topic+family">family</a></code>). The above model can
be written in matrix form:
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{logit} \lambda_i = x_i' \beta</code>
</p>

<p>The standard-errors of the parameters are computed with the second
derivatives of the log-likelihood function. (See References for other
details on the estimation procedure.)
</p>
<p>The function needs three things:
</p>

<ul>
<li><p> a phylogenetic tree which may contain multichotomies;
</p>
</li>
<li><p> a formula which specifies the predictors of the model described
above: this is given as a standard <span class="rlang"><b>R</b></span> formula and has no response (no
left-hand side term), for instance: <code>~ x + y</code>, it can include
interactions (<code>~ x + a * b</code>) (see <code><a href="stats.html#topic+formula">formula</a></code>
for details);
</p>
</li>
<li><p> the predictors specified in the formula must be accessible to
the function (either in the global space, or though the <code>data</code>
option); they can be numeric vectors or factors. The length and the
order of these data are important: the number of values (length) must
be equal to the number of tips of the tree + the number of nodes. The
order is the following: first the values for the tips in the same
order than for the labels, then the values for the nodes sequentially
from the root to the most terminal nodes (i.e., in the order given by
<code>phy$edge</code>).
</p>
</li></ul>

<p>The user must obtain the values for the nodes separately.
</p>
<p>Note that the method in its present implementation assumes that the
change in a species trait is more or less continuous between two nodes
or between a node and a tip. Thus reconstructing the ancestral values
with a Brownian motion model may be consistent with the present
method. This can be done with the function <code><a href="#topic+ace">ace</a></code>.
</p>


<h3>Value</h3>

<p>A NULL value is returned, the results are simply printed. The output
includes the deviance of the null (intercept-only) model and a
likelihood-ratio test of the fitted model against the null model.
Note that the deviance of the null model is different from the one
returned by <code><a href="#topic+yule">yule</a></code> because of the different parametrizations.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Paradis, E. (2005) Statistical analysis of diversification with
species traits. <em>Evolution</em>, <b>59</b>, 1&ndash;12.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+branching.times">branching.times</a></code>, <code><a href="#topic+diversi.gof">diversi.gof</a></code>,
<code><a href="#topic+diversi.time">diversi.time</a></code>, <code><a href="#topic+ltt.plot">ltt.plot</a></code>,
<code><a href="#topic+birthdeath">birthdeath</a></code>, <code><a href="#topic+bd.ext">bd.ext</a></code>, <code><a href="#topic+yule">yule</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### a simple example with some random data
data(bird.orders)
x &lt;- rnorm(45) # the tree has 23 tips and 22 nodes
### the standard-error for x should be as large as
### the estimated parameter
yule.cov(bird.orders, ~ x)
### another example with a tree that has a multichotomy
data(bird.families)
y &lt;- rnorm(272) # 137 tips + 135 nodes
yule.cov(bird.families, ~ y)
</code></pre>

<hr>
<h2 id='yule.time'>Fits the Time-Dependent Yule Model</h2><span id='topic+yule.time'></span>

<h3>Description</h3>

<p>This function fits by maximum likelihood the time-dependent Yule
model. The time is measured from the past (<code>root.time</code>) to the
present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yule.time(phy, birth, BIRTH = NULL, root.time = 0, opti = "nlm", start = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yule.time_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="yule.time_+3A_birth">birth</code></td>
<td>
<p>a (vectorized) function specifying how the birth
(speciation) probability changes through time (see details).</p>
</td></tr>
<tr><td><code id="yule.time_+3A_birth">BIRTH</code></td>
<td>
<p>a (vectorized) function giving the primitive of
<code>birth</code>.</p>
</td></tr>
<tr><td><code id="yule.time_+3A_root.time">root.time</code></td>
<td>
<p>a numeric value giving the time of the root node
(time is measured from the past towards the present).</p>
</td></tr>
<tr><td><code id="yule.time_+3A_opti">opti</code></td>
<td>
<p>a character string giving the function used for
optimisation of the likelihood function. Three choices are possible:
<code>"nlm"</code>, <code>"nlminb"</code>, or <code>"optim"</code>, or any unambiguous
abbreviation of these.</p>
</td></tr>
<tr><td><code id="yule.time_+3A_start">start</code></td>
<td>
<p>the initial values used in the optimisation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model fitted is a straightforward extension of the Yule model with
covariates (see <code><a href="#topic+yule.cov">yule.cov</a></code>). Rather than having
heterogeneity among lineages, the speciation probability is the same
for all lineages at a given time, but can change through time.
</p>
<p>The function <code>birth</code> <em>must</em> meet these two requirements: (i)
the parameters to be estimated are the formal arguments; (ii) time is
named <code>t</code> in the body of the function. However, this is the
opposite for the primitive <code>BIRTH</code>: <code>t</code> is the formal
argument, and the parameters are used in its body. See the examples.
</p>
<p>It is recommended to use <code>BIRTH</code> if possible, and required if
speciation probability is constant on some time interval. If this
primitive cannot be provided, a numerical integration is done with
<code><a href="stats.html#topic+integrate">integrate</a></code>.
</p>
<p>The standard-errors of the parameters are computed with the Hessian of
the log-likelihood function.
</p>


<h3>Value</h3>

<p>An object of class <code>"yule"</code> (see <code><a href="#topic+yule">yule</a></code>).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Hubert, N., Paradis, E., Bruggemann, H. and Planes, S. (2011) Community
assembly and diversification in Indo-Pacific coral reef
fishes. <em>Ecology and Evolution</em>, <b>1</b>, 229&ndash;277.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+branching.times">branching.times</a></code>, <code><a href="#topic+ltt.plot">ltt.plot</a></code>,
<code><a href="#topic+birthdeath">birthdeath</a></code>, <code><a href="#topic+yule">yule</a></code>, <code><a href="#topic+yule.cov">yule.cov</a></code>,
<code><a href="#topic+bd.time">bd.time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### define two models...
birth.logis &lt;- function(a, b) 1/(1 + exp(-a*t - b)) # logistic
birth.step &lt;- function(l1, l2, Tcl) { # 2 rates with one break-point
    ans &lt;- rep(l1, length(t))
    ans[t &gt; Tcl] &lt;- l2
    ans
}
### ... and their primitives:
BIRTH.logis &lt;- function(t) log(exp(-a*t) + exp(b))/a + t
BIRTH.step &lt;- function(t)
{
    out &lt;- numeric(length(t))
    sel &lt;- t &lt;= Tcl
    if (any(sel)) out[sel] &lt;- t[sel] * l1
    if (any(!sel)) out[!sel] &lt;- Tcl * l1 + (t[!sel] - Tcl) * l2
    out
}
data(bird.families)
### fit both models:
yule.time(bird.families, birth.logis)
yule.time(bird.families, birth.logis, BIRTH.logis) # same but faster
## Not run: yule.time(bird.families, birth.step)  # fails
yule.time(bird.families, birth.step, BIRTH.step,
          opti = "nlminb", start = c(.01, .01, 100))
</code></pre>

<hr>
<h2 id='zoom'>Zoom on a Portion of a Phylogeny</h2><span id='topic+zoom'></span>

<h3>Description</h3>

<p>This function plots simultaneously a whole phylogenetic tree
(supposedly large) and a portion of it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zoom(phy, focus, subtree = FALSE, col = rainbow, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zoom_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="zoom_+3A_focus">focus</code></td>
<td>
<p>a vector, either numeric or character, or a list of
vectors specifying the tips to be focused on.</p>
</td></tr>
<tr><td><code id="zoom_+3A_subtree">subtree</code></td>
<td>
<p>a logical indicating whether to show the context of the
extracted subtrees.</p>
</td></tr>
<tr><td><code id="zoom_+3A_col">col</code></td>
<td>
<p>a vector of colours used to show where the subtrees are in
the main tree, or a function .</p>
</td></tr>
<tr><td><code id="zoom_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>plot.phylo</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function aims at exploring very large trees. The main argument is
a phylogenetic tree, and the second one is a vector or a list of
vectors specifying the tips to be focused on. The vector(s) can be
either numeric and thus taken as the indices of the tip labels, or
character in which case it is taken as the corresponding tip labels.
</p>
<p>The whole tree is plotted on the left-hand side in a narrower
sub-window (about a quarter of the device) without tip labels. The
subtrees consisting of the tips in &lsquo;focus&rsquo; are extracted and plotted
on the right-hand side starting from the top left corner and
successively column-wise.
</p>
<p>If the argument &lsquo;col&rsquo; is a vector of colours, as many colours as the
number of subtrees must be given. The alternative is to give a
function that will create colours or grey levels from the number of
subtrees: see <code><a href="grDevices.html#topic+rainbow">rainbow</a></code> for some possibilities
with colours.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.phylo">plot.phylo</a></code>, <code><a href="#topic+drop.tip">drop.tip</a></code>,
<code><a href="graphics.html#topic+layout">layout</a></code>, <code><a href="grDevices.html#topic+rainbow">rainbow</a></code>,
<code><a href="grDevices.html#topic+grey">grey</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(chiroptera)
zoom(chiroptera, 1:20, subtree = TRUE)
zoom(chiroptera, grep("Plecotus", chiroptera$tip.label))
zoom(chiroptera, list(grep("Plecotus", chiroptera$tip.label),
                      grep("Pteropus", chiroptera$tip.label)))

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
