<!DOCTYPE html><html><head><title>Help for package squeezy</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {squeezy}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dminML.LA.ridgeGLM'>

<p>Partial derivatives of -log(ML) of ridge penalised GLMs</p></a></li>
<li><a href='#mAIC.LA.ridgeGLM'>

<p>Marginal AIC of a multi-group, ridge penalised GLM</p></a></li>
<li><a href='#minML.LA.ridgeGLM'>

<p>-log(ML) of ridge penalised GLMs</p></a></li>
<li><a href='#normalityCheckQQ'>

<p>Visual posterior check of multivariate normality of the linear predictors</p></a></li>
<li><a href='#squeezy'>

<p>Fit a group-adaptive elastic net penalised linear or logistic model</p></a></li>
<li><a href='#squeezy-package'>
<p>Group-Adaptive Elastic Net Penalised Generalised Linear Models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Group-Adaptive Elastic Net Penalised Generalised Linear Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-13</td>
</tr>
<tr>
<td>Author:</td>
<td>Mirrelijn M. van Nee [aut, cre],
  Tim van de Brug [aut],
  Mark A. van de Wiel [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mirrelijn M. van Nee &lt;m.vannee@amsterdamumc.nl&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>glmnet, stats, Matrix, multiridge (&ge; 1.5), mvtnorm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, ecpc</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit linear and logistic regression models penalised with group-adaptive elastic net penalties.
  The group penalties correspond to groups of covariates defined by a co-data group set.
  The method accommodates inclusion of unpenalised covariates and overlapping groups.
  See Van Nee et al. (2021) &lt;<a href="https://arxiv.org/abs/2101.03875">arXiv:2101.03875</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://arxiv.org/abs/2101.03875">https://arxiv.org/abs/2101.03875</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-13 12:55:27 UTC; VNOB-0728</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-13 14:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dminML.LA.ridgeGLM'>

Partial derivatives of -log(ML) of ridge penalised GLMs
</h2><span id='topic+dminML.LA.ridgeGLM'></span>

<h3>Description</h3>


<p>Returns the partial derivatives (w.r.t. 'loglambdas') of the minus log Laplace approximation (LA) of the marginal likelihood of ridge penalised generalised linear models. Note: currently only implemented for linear and logistic regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dminML.LA.ridgeGLM(loglambdas, XXblocks, Y, sigmasq = 1, 
                  Xunpen = NULL, intrcpt = TRUE, model, minlam = 0, 
                  opt.sigma = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dminML.LA.ridgeGLM_+3A_loglambdas">loglambdas</code></td>
<td>


<p>Logarithm of the ridge penalties as returned by ecpc or squeezy; Gx1 vector.
</p>
</td></tr>
<tr><td><code id="dminML.LA.ridgeGLM_+3A_xxblocks">XXblocks</code></td>
<td>


<p>List of sample covariance matrices X_g %*% t(X_g) for groups g = 1,..., G.
</p>
</td></tr>
<tr><td><code id="dminML.LA.ridgeGLM_+3A_y">Y</code></td>
<td>


<p>Response data; n-dimensional vector (n: number of samples) for linear and logistic outcomes.
</p>
</td></tr>
<tr><td><code id="dminML.LA.ridgeGLM_+3A_sigmasq">sigmasq</code></td>
<td>


<p>(linear model only) Noise level (Y~N(X*beta,sd=sqrt(sigmasq))).
</p>
</td></tr>
<tr><td><code id="dminML.LA.ridgeGLM_+3A_xunpen">Xunpen</code></td>
<td>


<p>Unpenalised variables; nxp_1-dimensional matrix for p_1 unpenalised variables.
</p>
</td></tr>
<tr><td><code id="dminML.LA.ridgeGLM_+3A_intrcpt">intrcpt</code></td>
<td>


<p>Should an intercept be included? Set to TRUE by default.
</p>
</td></tr>
<tr><td><code id="dminML.LA.ridgeGLM_+3A_model">model</code></td>
<td>


<p>Type of model for the response; linear or logistic. 
</p>
</td></tr>
<tr><td><code id="dminML.LA.ridgeGLM_+3A_minlam">minlam</code></td>
<td>


<p>Minimum value of lambda that is added to exp(loglambdas); set to 0 as default.
</p>
</td></tr>
<tr><td><code id="dminML.LA.ridgeGLM_+3A_opt.sigma">opt.sigma</code></td>
<td>


<p>(linear model only) TRUE/FALSE if log(sigmasq) is given as first argument of 
loglambdas for optimisation purposes
</p>
</td></tr>
</table>


<h3>Value</h3>






<p>Partial derivatives of the Laplace approximation of the minus log marginal likelihood to the model parameters 'loglambdas';
</p>
<p>For opt.sigma=FALSE: Gx1-dimensional vector for the G log(group ridge penalties). 
</p>
<p>For opt.sigma=TRUE (linear model only): (G+1)x1-dimensional vector for the partial derivative to log(sigmasq) (first element) and for the G log(group ridge penalties). 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simulate toy data
n&lt;-100
p&lt;-300
X &lt;- matrix(rnorm(n*p),n,p)
Y &lt;- rnorm(n)
groupset &lt;- list(1:(p/2),(p/2+1):p)
sigmahat &lt;- 2
alpha &lt;- 0.5
tauMR &lt;- c(0.01,0.005)

XXblocks &lt;- lapply(groupset, function(x)X[,x]%*%t(X[,x]))

#compute partial derivatives of the minus log marginal likelihood to the penalties only
dminML.LA.ridgeGLM(loglambdas = log(sigmahat/tauMR), 
                  XXblocks, Y, sigmasq = sigmahat, 
                  model="linear",opt.sigma=FALSE)

#additionally, compute the partial derivative to the linear regression noise parameter sigma^2
dminML.LA.ridgeGLM(loglambdas = log(c(sigmahat,sigmahat/tauMR)), 
                   XXblocks, Y, sigmasq = sigmahat, 
                   model="linear",opt.sigma=TRUE)
</code></pre>

<hr>
<h2 id='mAIC.LA.ridgeGLM'>

Marginal AIC of a multi-group, ridge penalised GLM
</h2><span id='topic+mAIC.LA.ridgeGLM'></span>

<h3>Description</h3>


<p>Compute the marginal AIC for the marginal likelihood (ML) of multi-group, ridge penalised generalised linear models. Note: currently only implemented for linear and logistic regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mAIC.LA.ridgeGLM(loglambdas, XXblocks, Y, sigmasq = 1, 
                Xunpen = NULL, intrcpt = TRUE, model, minlam = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mAIC.LA.ridgeGLM_+3A_loglambdas">loglambdas</code></td>
<td>


<p>Logarithm of the ridge penalties as returned by ecpc or squeezy; Gx1 vector.
</p>
</td></tr>
<tr><td><code id="mAIC.LA.ridgeGLM_+3A_xxblocks">XXblocks</code></td>
<td>


<p>List of sample covariance matrices X_g %*% t(X_g) for groups g = 1,..., G.
</p>
</td></tr>
<tr><td><code id="mAIC.LA.ridgeGLM_+3A_y">Y</code></td>
<td>


<p>Response data; n-dimensional vector (n: number of samples) for linear and logistic outcomes.
</p>
</td></tr>
<tr><td><code id="mAIC.LA.ridgeGLM_+3A_sigmasq">sigmasq</code></td>
<td>


<p>(linear model only) Noise level (Y~N(X*beta,sd=sqrt(sigmasq))).
</p>
</td></tr>
<tr><td><code id="mAIC.LA.ridgeGLM_+3A_xunpen">Xunpen</code></td>
<td>


<p>Unpenalised variables; nxp_1-dimensional matrix for p_1 unpenalised variables.
</p>
</td></tr>
<tr><td><code id="mAIC.LA.ridgeGLM_+3A_intrcpt">intrcpt</code></td>
<td>


<p>Should an intercept be included? Set to TRUE by default.
</p>
</td></tr>
<tr><td><code id="mAIC.LA.ridgeGLM_+3A_model">model</code></td>
<td>


<p>Type of model for the response; linear or logistic. 
</p>
</td></tr>
<tr><td><code id="mAIC.LA.ridgeGLM_+3A_minlam">minlam</code></td>
<td>


<p>Minimum value of lambda that is added to exp(loglambdas); set to 0 as default.
</p>
</td></tr>
</table>


<h3>Value</h3>






<table>
<tr><td><code>mAIC</code></td>
<td>
<p>mAIC of the model</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Simulate toy data
n&lt;-100
p&lt;-300
X &lt;- matrix(rnorm(n*p),n,p)
Y &lt;- rnorm(n)
groupset &lt;- list(1:(p/2),(p/2+1):p)
sigmahat &lt;- 2
alpha &lt;- 0.5
tauMR &lt;- c(0.01,0.005)

XXblocks &lt;- lapply(groupset, function(x)X[,x]%*%t(X[,x]))

#compute the mAIC of a co-data model with multiple groups
mAIC.LA.ridgeGLM(loglambdas=log(sigmahat/tauMR), XXblocks=XXblocks, 
                 Y = Y, sigmasq = sigmahat, model="linear")

#compute the mAIC of a co-data agnostic model, i.e. only one group of covariates
mAIC.LA.ridgeGLM(loglambdas=log(sigmahat/median(tauMR)), 
                 XXblocks=list(X%*%t(X)), 
                 Y = Y, sigmasq = sigmahat, model="linear")
</code></pre>

<hr>
<h2 id='minML.LA.ridgeGLM'>

-log(ML) of ridge penalised GLMs
</h2><span id='topic+minML.LA.ridgeGLM'></span>

<h3>Description</h3>


<p>Returns the Laplace approximation (LA) of the minus log marginal likelihood of ridge penalised generalised linear models. Note: currently only implemented for linear and logistic regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minML.LA.ridgeGLM(loglambdas, XXblocks, Y, sigmasq = 1, 
                  Xunpen = NULL, intrcpt = TRUE, model, minlam = 0, 
                  opt.sigma = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minML.LA.ridgeGLM_+3A_loglambdas">loglambdas</code></td>
<td>


<p>Logarithm of the ridge penalties as returned by ecpc or squeezy; Gx1 vector.
</p>
</td></tr>
<tr><td><code id="minML.LA.ridgeGLM_+3A_xxblocks">XXblocks</code></td>
<td>


<p>List of sample covariance matrices X_g %*% t(X_g) for groups g = 1,...,G.
</p>
</td></tr>
<tr><td><code id="minML.LA.ridgeGLM_+3A_y">Y</code></td>
<td>


<p>Response data; n-dimensional vector (n: number of samples) for linear and logistic outcomes.
</p>
</td></tr>
<tr><td><code id="minML.LA.ridgeGLM_+3A_sigmasq">sigmasq</code></td>
<td>


<p>(linear model only) Noise level (Y~N(X*beta,sd=sqrt(sigmasq))).
</p>
</td></tr>
<tr><td><code id="minML.LA.ridgeGLM_+3A_xunpen">Xunpen</code></td>
<td>


<p>Unpenalised variables; nxp_1-dimensional matrix for p_1 unpenalised variables.
</p>
</td></tr>
<tr><td><code id="minML.LA.ridgeGLM_+3A_intrcpt">intrcpt</code></td>
<td>


<p>Should an intercept be included? Set to TRUE by default.
</p>
</td></tr>
<tr><td><code id="minML.LA.ridgeGLM_+3A_model">model</code></td>
<td>


<p>Type of model for the response; linear or logistic. 
</p>
</td></tr>
<tr><td><code id="minML.LA.ridgeGLM_+3A_minlam">minlam</code></td>
<td>


<p>Minimum value of lambda that is added to exp(loglambdas); set to 0 as default.
</p>
</td></tr>
<tr><td><code id="minML.LA.ridgeGLM_+3A_opt.sigma">opt.sigma</code></td>
<td>


<p>(linear model only) TRUE/FALSE if log(sigmasq) is given as first argument of 
loglambdas for optimisation purposes
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Laplace approximation of the minus log marginal likelihood for the ridge penalised GLM with model parameters 'loglambdas' and 'sigmasq' (for linear regression).





</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simulate toy data
n&lt;-100
p&lt;-300
X &lt;- matrix(rnorm(n*p),n,p)
Y &lt;- rnorm(n)
groupset &lt;- list(1:(p/2),(p/2+1):p)
sigmahat &lt;- 2
alpha &lt;- 0.5
tauMR &lt;- c(0.01,0.005)

XXblocks &lt;- lapply(groupset, function(x)X[,x]%*%t(X[,x]))

#compute minus log marginal likelihood
minML.LA.ridgeGLM(loglambdas = log(sigmahat/tauMR), 
                  XXblocks, Y, sigmasq = sigmahat, 
                  model="linear")
</code></pre>

<hr>
<h2 id='normalityCheckQQ'>

Visual posterior check of multivariate normality of the linear predictors
</h2><span id='topic+normalityCheckQQ'></span>

<h3>Description</h3>


<p>Produce a qq-plot to visually check whether the assumption of multivariate normality of the linear predictors is valid for the data and model fit with 'squeezy'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalityCheckQQ(X,groupset,fit.squeezy,nSim=500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalityCheckQQ_+3A_x">X</code></td>
<td>


<p>Observed data; (nxp)-dimensional matrix (p: number of covariates) with each row the observed high-dimensional feature vector of a sample.
</p>
</td></tr>
<tr><td><code id="normalityCheckQQ_+3A_groupset">groupset</code></td>
<td>


<p>Co-data group set; list with G groups.  Each group is a vector containing the indices of the covariates in that group.
</p>
</td></tr>
<tr><td><code id="normalityCheckQQ_+3A_fit.squeezy">fit.squeezy</code></td>
<td>


<p>Model fit obtained by the function <a href="#topic+squeezy">squeezy</a>.
</p>
</td></tr>
<tr><td><code id="normalityCheckQQ_+3A_nsim">nSim</code></td>
<td>


<p>Number of simulated vectors of linear predictors.
</p>
</td></tr>
</table>


<h3>Value</h3>






<p>The qqplot of the empirical versus theoretical quantiles is plotted. If &lsquo;ggplot2&rsquo; is installed, the plot is returned as &lsquo;ggplot&rsquo; object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simulate toy data
n&lt;-100
p&lt;-300
X &lt;- matrix(rnorm(n*p),n,p)
Y &lt;- rnorm(n)
groupset &lt;- list(1:(p/2),(p/2+1):p)
sigmahat &lt;- 2
alpha &lt;- 0.5
tauMR &lt;- c(0.01,0.005)

#Fit group-regularised elastic net model with squeezy
fit.squeezy &lt;- squeezy(Y,X,groupset,alpha=alpha,
                       lambdas=sigmahat/tauMR,sigmasq=sigmahat,
                       lambdaglobal=mean(sigmahat/tauMR))
                       
#Check qq-plot
normalityCheckQQ(X,groupset,fit.squeezy)
</code></pre>

<hr>
<h2 id='squeezy'>

Fit a group-adaptive elastic net penalised linear or logistic model
</h2><span id='topic+squeezy'></span>

<h3>Description</h3>


<p>Estimate group-specific elastic net penalties and fit a linear or logistic regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>squeezy(Y, X, groupset, alpha = 1, model = NULL, X2 = NULL, 
        Y2 = NULL, unpen = NULL, intrcpt = TRUE, 
        method = c("ecpcEN", "MML", "MML.noDeriv", "CV"), 
        fold = 10, compareMR = TRUE, selectAIC = FALSE, fit.ecpc = NULL, 
        lambdas = NULL, lambdaglobal = NULL, lambdasinit = NULL, 
        sigmasq = NULL, ecpcinit = TRUE, SANN = FALSE, minlam = 10^-3, 
        standardise_Y = NULL, reCV = NULL, opt.sigma = NULL, 
        resultsAICboth = FALSE, silent=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="squeezy_+3A_y">Y</code></td>
<td>


<p>Response data; n-dimensional vector (n: number of samples) for linear and logistic outcomes.
</p>
</td></tr>
<tr><td><code id="squeezy_+3A_x">X</code></td>
<td>


<p>Observed data; (nxp)-dimensional matrix (p: number of covariates) with each row the observed high-dimensional feature vector of a sample.
</p>
</td></tr>
<tr><td><code id="squeezy_+3A_groupset">groupset</code></td>
<td>


<p>Co-data group set; list with G groups.  Each group is a vector containing the indices of the covariates in that group.
</p>
</td></tr>
<tr><td><code id="squeezy_+3A_alpha">alpha</code></td>
<td>


<p>Elastic net penalty mixing parameter.
</p>
</td></tr>
<tr><td><code id="squeezy_+3A_model">model</code></td>
<td>


<p>Type of model for the response; linear or logistic.
</p>
</td></tr>
<tr><td><code id="squeezy_+3A_x2">X2</code></td>
<td>


<p>(optional) Independent observed data for which response is predicted.
</p>
</td></tr>
<tr><td><code id="squeezy_+3A_y2">Y2</code></td>
<td>


<p>(optional) Independent response data to compare with predicted response.
</p>
</td></tr>
<tr><td><code id="squeezy_+3A_unpen">unpen</code></td>
<td>


<p>Unpenalised covariates; vector with indices of covariates that should not be penalised.
</p>
</td></tr>
<tr><td><code id="squeezy_+3A_intrcpt">intrcpt</code></td>
<td>


<p>Should an intercept be included? Included by default for linear and logistic, excluded for Cox for which the baseline hazard is estimated.
</p>
</td></tr>
<tr><td><code id="squeezy_+3A_method">method</code></td>
<td>


<p>Which method should be used to estimate the group-specific penalties? Default MML.
</p>
</td></tr>
<tr><td><code id="squeezy_+3A_fold">fold</code></td>
<td>


<p>Number of folds used in inner cross-validation to estimate (initial) global ridge penalty lambda (if not given).
</p>
</td></tr>
<tr><td><code id="squeezy_+3A_comparemr">compareMR</code></td>
<td>


<p>TRUE/FALSE to fit the multi-ridge model and return results for comparison.
</p>
</td></tr>
<tr><td><code id="squeezy_+3A_selectaic">selectAIC</code></td>
<td>


<p>TRUE/FALSE to select the single-group model or multi-group model.
</p>
</td></tr>
<tr><td><code id="squeezy_+3A_fit.ecpc">fit.ecpc</code></td>
<td>


<p>(optional) Model fit obtained by the function ecpc (from the ecpc R-package)
</p>
</td></tr>
<tr><td><code id="squeezy_+3A_lambdas">lambdas</code></td>
<td>


<p>(optional) Group-specific ridge penalty parameters. If given, these are transformed to elastic net penalties.
</p>
</td></tr>
<tr><td><code id="squeezy_+3A_lambdaglobal">lambdaglobal</code></td>
<td>


<p>(optional) Global ridge penalty parameter used for initialising the optimisation.
</p>
</td></tr>
<tr><td><code id="squeezy_+3A_lambdasinit">lambdasinit</code></td>
<td>


<p>(optional) Group-specific ridge penalty parameters used for initialising the optimisation.
</p>
</td></tr>
<tr><td><code id="squeezy_+3A_sigmasq">sigmasq</code></td>
<td>


<p>(linear model only) If given, noise level is fixed (Y~N(X*beta,sd=sqrt(sigmasq))).
</p>
</td></tr>
<tr><td><code id="squeezy_+3A_ecpcinit">ecpcinit</code></td>
<td>


<p>TRUE/FALSE for using group-specific ridge penalties as given in &lsquo;fit.ecpc&rsquo; for initialising the optimisation.
</p>
</td></tr>
<tr><td><code id="squeezy_+3A_sann">SANN</code></td>
<td>


<p>('method'=MML.noDeriv only) TRUE/FALSE to use simulated annealing in optimisation of the ridge penalties.
</p>
</td></tr>
<tr><td><code id="squeezy_+3A_minlam">minlam</code></td>
<td>


<p>Minimal value of group-specific ridge penalty used in the optimisation.
</p>
</td></tr>
<tr><td><code id="squeezy_+3A_standardise_y">standardise_Y</code></td>
<td>


<p>TRUE/FALSE should Y be standardised?
</p>
</td></tr>
<tr><td><code id="squeezy_+3A_recv">reCV</code></td>
<td>


<p>TRUE/FALSE should the elastic net penalties be recalibrated by cross-validation of a global rescaling penalty?
</p>
</td></tr>
<tr><td><code id="squeezy_+3A_opt.sigma">opt.sigma</code></td>
<td>


<p>(linear model only) TRUE/FALSE to optimise sigmasq jointly with the ridge penalties.
</p>
</td></tr>
<tr><td><code id="squeezy_+3A_resultsaicboth">resultsAICboth</code></td>
<td>


<p>(selectAIC=TRUE only) TRUE/FALSE to return results of both the single-group and multi-group model.
</p>
</td></tr>
<tr><td><code id="squeezy_+3A_silent">silent</code></td>
<td>


<p>Should output messages be suppressed (default FALSE)?
</p>
</td></tr>
</table>


<h3>Value</h3>






<table>
<tr><td><code>betaApprox</code></td>
<td>

<p>Estimated regression coefficients of the group-adaptive elastic net model; p-dimensional vector.
</p>
</td></tr>
<tr><td><code>a0Approx</code></td>
<td>

<p>Estimated intercept of the group-adaptive elastic net model; scalar.
</p>
</td></tr>
<tr><td><code>lambdaApprox</code></td>
<td>

<p>Estimated group penalty parameters of the group-adaptive elastic net model; G-dimensional vector.
</p>
</td></tr>
<tr><td><code>lambdapApprox</code></td>
<td>

<p>Estimated elastic net penalty parameter of the group-adaptive elastic net model for all covariates; p-dimensional vector.
</p>
</td></tr>
<tr><td><code>tauMR</code></td>
<td>

<p>Estimated group variances of the multi-ridge model; G-dimensional vector.
</p>
</td></tr>
<tr><td><code>lambdaMR</code></td>
<td>

<p>Estimated group penalties of the multi-ridge model; G-dimensional vector.
</p>
</td></tr>
<tr><td><code>lambdaglobal</code></td>
<td>

<p>Estimated global ridge penalty; scalar. Note: only optimised if selectAIC=TRUE or compareMR=TRUE, else the returned crude estimate is sufficient for initialisation of squeezy.
</p>
</td></tr>
<tr><td><code>sigmahat</code></td>
<td>

<p>(linear model) Estimated sigma^2; scalar.
</p>
</td></tr>
<tr><td><code>MLinit</code></td>
<td>

<p>Min log marginal likelihood value at initial group penalties; scalar.
</p>
</td></tr>
<tr><td><code>MLfinal</code></td>
<td>

<p>Min log marginal likelihood value at estimated group penalties; scalar.
</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>

<p>Value used for the elastic net mixing parameter alpha; scalar.
</p>
</td></tr>
<tr><td><code>glmnet.fit</code></td>
<td>

<p>Fit of the &lsquo;glmnet&rsquo; function to obtain the regression coefficients.
</p>
</td></tr>
</table>
<p>If &lsquo;compareMR&rsquo;=TRUE, multi-ridge model is returned as well:
</p>
<table>
<tr><td><code>betaMR</code></td>
<td>

<p>Estimated regression coefficients of the multi-ridge model; p-dimensional vector.
</p>
</td></tr>
<tr><td><code>a0MR</code></td>
<td>

<p>Estimated intercept of the multi-ridge model; scalar.
</p>
</td></tr>
</table>
<p>If independent test set &lsquo;X2&rsquo; is given, predictions and MSE are returned:
</p>
<table>
<tr><td><code>YpredApprox</code></td>
<td>

<p>Predictions for the test set of the estimated group-adaptive elastic net model.
</p>
</td></tr>
<tr><td><code>MSEApprox</code></td>
<td>

<p>Mean squared error on the test set of the estimated group-adaptive elastic net model.
</p>
</td></tr>
<tr><td><code>YpredMR</code></td>
<td>

<p>Predictions for the test set of the estimated group-adaptive multi-ridge model.
</p>
</td></tr>
<tr><td><code>MSEMR</code></td>
<td>

<p>Mean squared error on the test set of the estimated group-adaptive multi-ridge model.
</p>
</td></tr>
</table>
<p>If &lsquo;selectAIC&rsquo;=TRUE, the multi-group or single-group model with best AIC is selected.
Results in &lsquo;betaApprox&rsquo;, &lsquo;a0Approx&rsquo;, &lsquo;lambdaApprox&rsquo; contain those results of the best model.
Summary results of both models are included as well:
</p>
<table>
<tr><td><code>AICmodels</code></td>
<td>

<p>List with elements &ldquo;multigroup&quot; and &ldquo;onegroup&quot;.- Each element is a list with results of the multi-group or single-group model, containing the group penalties (&lsquo;lambdas&rsquo;), sigma^2 (&lsquo;sigmahat&rsquo;, linear model only), and AIC (&lsquo;AIC&rsquo;).
</p>
<p>If besides &lsquo;selectAIC&rsquo;=TRUE, also &lsquo;resultsAICboth&rsquo;=TRUE, the fit of both the single-group model and multi-group model as obtained with <a href="#topic+squeezy">squeezy</a> are returned (&lsquo;fit&rsquo;).
</p>
</td></tr>
<tr><td><code>modelbestAIC</code></td>
<td>

<p>Either &ldquo;onegroup&quot; or &ldquo;multigroup&quot; for the selected model.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>


<p>Mirrelijn M. van Nee, Tim van de Brug, Mark A. van de Wiel
</p>


<h3>References</h3>


<p>Mirrelijn M. van Nee, Tim van de Brug, Mark A. van de Wiel, &quot;Fast marginal likelihood estimation of penalties for group-adaptive elastic net&quot;, arXiv preprint, arXiv:2101.03875 (2021).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####################
# Simulate toy data #
#####################
p&lt;-100 #number of covariates
n&lt;-50 #sample size training data set
n2&lt;-100 #sample size test data set
G&lt;- 5 #number of groups

taugrp &lt;- rep(c(0.05,0.1,0.2,0.5,1),each=p/G) #ridge prior variance
groupIndex &lt;- rep(1:G,each=p/G) #groups for co-data
groupset &lt;- lapply(1:G,function(x){which(groupIndex==x)}) #group set with each element one group
sigmasq &lt;- 2 #linear regression noise
lambda1 &lt;- sqrt(taugrp/2) #corresponding lasso penalty
#A Laplace(0,b) variate can also be generated as the difference of two i.i.d.
#Exponential(1/b) random variables
betas &lt;-   rexp(p, 1/lambda1) -  rexp(p, 1/lambda1) #regression coefficients
X &lt;- matrix(rnorm(n*p),n,p) #simulate training data
Y &lt;- rnorm(n,X%*%betas,sd=sqrt(sigmasq))
X2 &lt;- matrix(rnorm(n*p),n,p) #simulate test data
Y2 &lt;- rnorm(n,X2%*%betas,sd=sqrt(sigmasq))

###############
# Fit squeezy #
###############
#may be fit directly..
res.squeezy &lt;- squeezy(Y,X,groupset=groupset,Y2=Y2,X2=X2,
                       model="linear",alpha=0.5)


  #..or with ecpc-fit as initialisation
  if(requireNamespace("ecpc")){
    res.ecpc &lt;- ecpc::ecpc(Y,X, #observed data and response to train model
                     groupsets=list(groupset), #informative co-data group set
                     Y2=Y2,X2=X2, #test data
                     model="linear",
                     hypershrinkage="none",postselection = FALSE)
    res.squeezy &lt;- squeezy(Y,X, #observed data and response to train model
                           groupset=groupset, #informative co-data group set
                           Y2=Y2,X2=X2, #test data
                           fit.ecpc = res.ecpc, #ecpc-fit for initial values
                           model="linear", #type of model for the response
                           alpha=0.5) #elastic net mixing parameter
  }



summary(res.squeezy$betaApprox) #estimated elastic net regression coefficients
summary(res.squeezy$betaMR) #estimated multi-ridge regression coefficients
res.squeezy$lambdaApprox #estimated group elastic net penalties
res.squeezy$tauMR #multi-ridge group variances
res.squeezy$MSEApprox #MSE group-elastic net model
res.squeezy$MSEMR #MSE group-ridge model

#once fit, quickly find model fit for different values of alpha:
res.squeezy2 &lt;- squeezy(Y,X, #observed data and response to train model
                        groupset=groupset, #informative co-data groupset
                        Y2=Y2,X2=X2, #test data
                        lambdas = res.squeezy$lambdaMR, #fix lambdas at multi-ridge estimate
                        model="linear", #type of model for the response
                        alpha=0.9) #elastic net mixing parameter


  #Select single-group model or multi-group model based on best mAIC
  res.squeezy &lt;- squeezy(Y,X, #observed data and response to train model
                         groupset=groupset, #informative co-data group set
                         Y2=Y2,X2=X2, #test data
                         fit.ecpc = res.ecpc, #ecpc-fit for initial values
                         model="linear", #type of model for the response
                         alpha=0.5, #elastic net mixing parameter
                         selectAIC = TRUE,resultsAICboth = TRUE)
  
  res.squeezy$modelbestAIC #selected model
  res.squeezy$AICmodels$multigroup$fit$MSEApprox #MSE on test set of multi-group model
  res.squeezy$AICmodels$onegroup$fit$MSEApprox #MSE on test set of single-group model


</code></pre>

<hr>
<h2 id='squeezy-package'>
Group-Adaptive Elastic Net Penalised Generalised Linear Models
</h2><span id='topic+squeezy-package'></span>

<h3>Description</h3>

<p>Fit linear and logistic regression models penalised with group-adaptive elastic net penalties.
  The group penalties correspond to groups of covariates defined by a co-data group set.
  The method accommodates inclusion of unpenalised covariates and overlapping groups.
  See Van Nee et al. (2021) &lt;arXiv:2101.03875&gt;.
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+squeezy">squeezy</a></code> for example code.
</p>


<h3>Author(s)</h3>

<p>Mirrelijn M. van Nee [aut, cre], 
  Tim van de Brug [aut], 
  Mark A. van de Wiel [aut]
</p>
<p>Maintainer: Mirrelijn M. van Nee &lt;m.vannee@amsterdamumc.nl&gt;
</p>


<h3>References</h3>

<p>Mirrelijn M. van Nee, Tim van de Brug, Mark A. van de Wiel, &quot;Fast marginal likelihood estimation of penalties for group-adaptive elastic net.&quot;, 2021
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
