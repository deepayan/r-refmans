<!DOCTYPE html><html lang="en-US"><head><title>Help for package FBMS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FBMS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#FBMS-package'>
<p>Flexible Bayesian Model Selection and Model Averaging</p></a></li>
<li><a href='#abalone'><p>Physical measurements of 4177 abalones, a species of sea snail.</p></a></li>
<li><a href='#breastcancer'><p>Breast Cancer Wisconsin (Diagnostic) Data Set</p></a></li>
<li><a href='#compute_effects'><p>Compute effects for specified in labels covariates using a fitted model.</p></a></li>
<li><a href='#cos_deg'><p>Cosine function for degrees</p></a></li>
<li><a href='#diagn_plot'><p>Plot convergence of best/median/mean/other summary log posteriors in time</p></a></li>
<li><a href='#erf'><p>erf function</p></a></li>
<li><a href='#exoplanet'><p>Excerpt from the Open Exoplanet Catalogue data set</p></a></li>
<li><a href='#exp_dbl'><p>Double exponential function</p></a></li>
<li><a href='#fbms'><p>Fit a BGNLM  model using Genetically Modified Mode Jumping Markov Chain Monte Carlo (MCMC) sampling.</p>
Or Fit a BGLM model using Modified Mode Jumping Markov Chain Monte Carlo (MCMC) sampling.</a></li>
<li><a href='#gauss'><p>Gaussian function</p></a></li>
<li><a href='#gaussian.loglik'><p>Log likelihood function for gaussian regression with a prior p(m)=r*sum(total_width).</p></a></li>
<li><a href='#gaussian.loglik.alpha'><p>Log likelihood function for gaussian regression for alpha calculation</p>
This function is just the bare likelihood function
Note that it only gives a proportional value and is equivalent to least squares</a></li>
<li><a href='#gelu'><p>GELU function</p></a></li>
<li><a href='#gen.params.gmjmcmc'><p>Generate a parameter list for GMJMCMC (Genetically Modified MJMCMC)</p></a></li>
<li><a href='#gen.params.mjmcmc'><p>Generate a parameter list for MJMCMC (Mode Jumping MCMC)</p></a></li>
<li><a href='#gen.probs.gmjmcmc'><p>Generate a probability list for GMJMCMC (Genetically Modified MJMCMC)</p></a></li>
<li><a href='#gen.probs.mjmcmc'><p>Generate a probability list for MJMCMC (Mode Jumping MCMC)</p></a></li>
<li><a href='#get.best.model'><p>Extract the Best Model from MJMCMC or GMJMCMC Results</p></a></li>
<li><a href='#get.mpm.model'><p>Retrieve the Median Probability Model (MPM)</p></a></li>
<li><a href='#gmjmcmc'><p>Main algorithm for GMJMCMC (Genetically Modified MJMCMC)</p></a></li>
<li><a href='#gmjmcmc.parallel'><p>Run multiple gmjmcmc (Genetically Modified MJMCMC) runs in parallel returning a list of all results.</p></a></li>
<li><a href='#hs'><p>heavy side function</p></a></li>
<li><a href='#linear.g.prior.loglik'><p>Log likelihood function for linear regression using Zellners g-prior</p></a></li>
<li><a href='#log_prior'><p>Log model prior function</p></a></li>
<li><a href='#logistic.loglik'><p>Log likelihood function for logistic regression with a prior p(m)=sum(total_width)</p>
This function is created as an example of how to create an estimator that is used
to calculate the marginal likelihood of a model.</a></li>
<li><a href='#logistic.loglik.ala'><p>Log likelihood function for logistic regression with an approximate Laplace approximations used</p>
This function is created as an example of how to create an estimator that is used
to calculate the marginal likelihood of a model.</a></li>
<li><a href='#logistic.loglik.alpha'><p>Log likelihood function for logistic regression for alpha calculation</p>
This function is just the bare likelihood function</a></li>
<li><a href='#marginal.probs'><p>Function for calculating marginal inclusion probabilities of features given a list of models</p></a></li>
<li><a href='#merge_results'><p>Merge a list of multiple results from many runs</p>
This function will weight the features based on the best marginal posterior in that population
and merge the results together, simplifying by merging equivalent features (having high correlation).</a></li>
<li><a href='#mjmcmc'><p>Main algorithm for MJMCMC (Genetically Modified MJMCMC)</p></a></li>
<li><a href='#mjmcmc.parallel'><p>Run multiple mjmcmc runs in parallel, merging the results before returning.</p></a></li>
<li><a href='#model.string'><p>Function to generate a function string for a model consisting of features</p></a></li>
<li><a href='#ngelu'><p>Negative GELU function</p></a></li>
<li><a href='#nhs'><p>negative heavy side function</p></a></li>
<li><a href='#not'><p>not x</p></a></li>
<li><a href='#nrelu'><p>negative ReLu function</p></a></li>
<li><a href='#p0'><p>p0 polynomial term</p></a></li>
<li><a href='#p05'><p>p05 polynomial term</p></a></li>
<li><a href='#p0p0'><p>p0p0 polynomial term</p></a></li>
<li><a href='#p0p05'><p>p0p05 polynomial term</p></a></li>
<li><a href='#p0p1'><p>p0p1 polynomial term</p></a></li>
<li><a href='#p0p2'><p>p0p2 polynomial term</p></a></li>
<li><a href='#p0p3'><p>p0p3 polynomial term</p></a></li>
<li><a href='#p0pm05'><p>p0pm05 polynomial term</p></a></li>
<li><a href='#p0pm1'><p>p0pm1 polynomial terms</p></a></li>
<li><a href='#p0pm2'><p>p0pm2 polynomial term</p></a></li>
<li><a href='#p2'><p>p2 polynomial term</p></a></li>
<li><a href='#p3'><p>p3 polynomial term</p></a></li>
<li><a href='#plot.gmjmcmc'><p>Function to plot the results, works both for results from gmjmcmc and</p>
merged results from merge.results</a></li>
<li><a href='#plot.gmjmcmc_merged'><p>Plot a gmjmcmc_merged run</p></a></li>
<li><a href='#plot.mjmcmc'><p>Function to plot the results, works both for results from gmjmcmc and</p>
merged results from merge.results</a></li>
<li><a href='#plot.mjmcmc_parallel'><p>Plot a mjmcmc_parallel run</p></a></li>
<li><a href='#pm05'><p>pm05 polynomial term</p></a></li>
<li><a href='#pm1'><p>pm1 polynomial term</p></a></li>
<li><a href='#pm2'><p>pm2 polynomial term</p></a></li>
<li><a href='#predict.bgnlm_model'><p>Predict responses from a BGNLM model</p></a></li>
<li><a href='#predict.gmjmcmc'><p>Predict using a gmjmcmc result object.</p></a></li>
<li><a href='#predict.gmjmcmc_merged'><p>Predict using a merged gmjmcmc result object.</p></a></li>
<li><a href='#predict.gmjmcmc_parallel'><p>Predict using a gmjmcmc result object from a parallel run.</p></a></li>
<li><a href='#predict.mjmcmc'><p>Predict using a mjmcmc result object.</p></a></li>
<li><a href='#predict.mjmcmc_parallel'><p>Predict using a mjmcmc result object from a parallel run.</p></a></li>
<li><a href='#print.feature'><p>Print method for &quot;feature&quot; class</p></a></li>
<li><a href='#relu'><p>ReLu function</p></a></li>
<li><a href='#rmclapply'><p>rmclapply: Cross-platform mclapply/forking hack for Windows</p></a></li>
<li><a href='#SangerData2'><p>Gene expression data lymphoblastoid cell lines of all 210 unrelated HapMap</p>
individuals from four populations</a></li>
<li><a href='#set.transforms'><p>Set the transformations option for GMJMCMC (Genetically Modified MJMCMC),</p>
this is also done when running the algorithm, but this function allows for it to be done manually.</a></li>
<li><a href='#sigmoid'><p>Sigmoid function</p></a></li>
<li><a href='#sin_deg'><p>Sine function for degrees</p></a></li>
<li><a href='#sqroot'><p>Square root function</p></a></li>
<li><a href='#string.population'><p>Function to get a character representation of a list of features</p></a></li>
<li><a href='#string.population.models'><p>Function to get a character representation of a list of models</p></a></li>
<li><a href='#summary.gmjmcmc'><p>Function to print a quick summary of the results</p></a></li>
<li><a href='#summary.gmjmcmc_merged'><p>Function to print a quick summary of the results</p></a></li>
<li><a href='#summary.mjmcmc'><p>Function to print a quick summary of the results</p></a></li>
<li><a href='#summary.mjmcmc_parallel'><p>Function to print a quick summary of the results</p></a></li>
<li><a href='#to23'><p>To the 2.3  power function</p></a></li>
<li><a href='#to25'><p>To 2.5 power</p></a></li>
<li><a href='#to35'><p>To 3.5 power</p></a></li>
<li><a href='#to72'><p>To the 7/2  power function</p></a></li>
<li><a href='#troot'><p>Cube root function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Flexible Bayesian Model Selection and Model Averaging</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-26</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the Mode Jumping Markov Chain Monte Carlo algorithm described in &lt;<a href="https://doi.org/10.1016%2Fj.csda.2018.05.020">doi:10.1016/j.csda.2018.05.020</a>&gt; and its Genetically Modified counterpart described in &lt;<a href="https://doi.org/10.1613%2Fjair.1.13047">doi:10.1613/jair.1.13047</a>&gt; as well as the sub-sampling versions described in &lt;<a href="https://doi.org/10.1016%2Fj.ijar.2022.08.018">doi:10.1016/j.ijar.2022.08.018</a>&gt; for flexible Bayesian model selection and model averaging.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), fastglm, GenSA, parallel, methods, stats,
graphics, r2r</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, markdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-26 20:45:23 UTC; jonlachmann</td>
</tr>
<tr>
<td>Author:</td>
<td>Jon Lachmann [cre, aut],
  Aliaksandr Hubin [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jon Lachmann &lt;jon@lachmann.nu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-26 21:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='FBMS-package'>
Flexible Bayesian Model Selection and Model Averaging
</h2><span id='topic+FBMS-package'></span><span id='topic+FBMS'></span>

<h3>Description</h3>

<p>Implements the Mode Jumping Markov Chain Monte Carlo algorithm described in &lt;doi:10.1016/j.csda.2018.05.020&gt; and its Genetically Modified counterpart described in &lt;doi:10.1613/jair.1.13047&gt; as well as the sub-sampling versions described in &lt;doi:10.1016/j.ijar.2022.08.018&gt; for flexible Bayesian model selection and model averaging.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jon Lachmann <a href="mailto:jon@lachmann.nu">jon@lachmann.nu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Jon Lachmann <a href="mailto:jon@lachmann.nu">jon@lachmann.nu</a>
</p>
</li>
<li><p> Aliaksandr Hubin <a href="mailto:aliaksah@math.uio.no">aliaksah@math.uio.no</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Florian Frommlet <a href="mailto:florian.frommlet@meduniwien.ac.at">florian.frommlet@meduniwien.ac.at</a> [contributor]
</p>
</li>
<li><p> Geir Storvik <a href="mailto:geirs@math.uio.no">geirs@math.uio.no</a> [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Lachmann, J., Storvik, G., Frommlet, F., &amp; Hubin, A. (2022).
A subsampling approach for Bayesian model selection.
International Journal of Approximate Reasoning, 151, 33-63. Elsevier.
</p>
<p>Hubin, A., Storvik, G., &amp; Frommlet, F. (2021).
Flexible Bayesian Nonlinear Model Configuration.
Journal of Artificial Intelligence Research, 72, 901-942.
</p>
<p>Hubin, A., Frommlet, F., &amp; Storvik, G. (2021).
Reversible Genetically Modified MJMCMC.
Under review in EYSM 2021.
</p>
<p>Hubin, A., &amp; Storvik, G. (2018).
Mode jumping MCMC for Bayesian variable selection in GLMM.
Computational Statistics &amp; Data Analysis, 127, 281-297. Elsevier.
</p>

<hr>
<h2 id='abalone'>Physical measurements of 4177 abalones, a species of sea snail.</h2><span id='topic+abalone'></span>

<h3>Description</h3>

<p>%% ~~ A concise (1-5 lines) description of the dataset. ~~
</p>


<h3>Format</h3>

<p>A data frame with 4177 observations on the following 9 variables.
</p>

<dl>
<dt>Diameter</dt><dd><p>Diameter Perpendicular to length, continuous</p>
</dd>
<dt>Height</dt><dd><p>Height with with meat in shell, continuous.</p>
</dd>
<dt>Length</dt><dd><p>Longest shell measurement, continuous</p>
</dd>
<dt>Rings</dt><dd><p>+1.5 gives the age in years, integer</p>
</dd>
<dt>Sex</dt><dd><p>Sex of the abalone, <code>F</code> is female, <code>M</code> male, and <code>I</code> infant, categorical.</p>
</dd>
<dt>Weight_S</dt><dd><p>Grams after being dried, continuous.</p>
</dd>
<dt>Weight_Sh</dt><dd><p>Grams weight of meat, continuous.</p>
</dd>
<dt>Weight_V</dt><dd><p>Grams gut weight (after bleeding), continuous.</p>
</dd>
<dt>Weight_W</dt><dd><p>Grams whole abalone, continuous.</p>
</dd> </dl>



<h3>Details</h3>

<p>See the web page <a href="https://archive.ics.uci.edu/ml/datasets/Abalone">https://archive.ics.uci.edu/ml/datasets/Abalone</a> for
more information about the data set.
</p>


<h3>Source</h3>

<p>Dua, D. and Graff, C. (2019). UCI Machine Learning Repository
<a href="https://archive.ics.uci.edu/ml/">https://archive.ics.uci.edu/ml/</a>. Irvine, CA: University of California,
School of Information and Computer Science.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(abalone)
## maybe str(abalone) ; plot(abalone) ...

</code></pre>

<hr>
<h2 id='breastcancer'>Breast Cancer Wisconsin (Diagnostic) Data Set</h2><span id='topic+breastcancer'></span>

<h3>Description</h3>

<p>Features are computed from a digitized image of a fine needle aspirate (FNA) of a breast mass.
They describe characteristics of the cell nuclei present in the image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(breastcancer)
</code></pre>


<h3>Format</h3>

<p>A data frame with 569 rows and 32 variables
</p>


<h3>Details</h3>

<p>Separating plane described above was obtained using Multisurface Method-Tree (MSM-T)
(K. P. Bennett, &quot;Decision Tree Construction Via Linear Programming.&quot; Proceedings of the 4th Midwest Artificial
Intelligence and Cognitive Science Society, pp. 97-101, 1992), a classification method which uses linear programming to
construct a decision tree. Relevant features were selected using an exhaustive search in the space of 1-4 features
and 1-3 separating planes.
</p>
<p>The actual linear program used to obtain the separating plane in the 3-dimensional space is that described in:
(K. P. Bennett and O. L. Mangasarian: &quot;Robust Linear Programming Discrimination of Two Linearly Inseparable Sets&quot;,
Optimization Methods and Software 1, 1992, 23-34).
</p>
<p>The variables are as follows:
</p>

<ul>
<li><p> ID number
</p>
</li>
<li><p> Diagnosis (1 = malignant, 0 = benign)
</p>
</li>
<li><p> Ten real-valued features are computed for each cell nucleus
</p>
</li></ul>



<h3>Source</h3>

<p>Dataset downloaded from the UCI Machine Learning Repository.
<a href="http://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Wisconsin+(Diagnostic)">http://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Wisconsin+(Diagnostic)</a>
</p>
<p>Creators:
</p>

<ol>
<li><p> Dr. William H. Wolberg, General Surgery Dept.
University of Wisconsin, Clinical Sciences Center
Madison, WI 53792
wolberg 'at' eagle.surgery.wisc.edu
</p>
</li>
<li><p> W. Nick Street, Computer Sciences Dept.
University of Wisconsin, 1210 West Dayton St., Madison, WI 53706
street 'at' cs.wisc.edu 608-262-6619
</p>
</li>
<li><p> Olvi L. Mangasarian, Computer Sciences Dept.
University of Wisconsin, 1210 West Dayton St., Madison, WI 53706
olvi 'at' cs.wisc.edu
</p>
</li></ol>

<p>Donor: Nick Street
</p>


<h3>References</h3>

<p>W.N. Street, W.H. Wolberg and O.L. Mangasarian. Nuclear feature extraction for breast tumor diagnosis.
IS&amp;T/SPIE 1993 International Symposium on Electronic Imaging: Science and Technology, volume 1905, pages 861-870, San Jose, CA, 1993.
</p>
<p>Lichman, M. (2013). UCI Machine Learning Repository <a href="http://archive.ics.uci.edu/ml">http://archive.ics.uci.edu/ml</a>.
Irvine, CA: University of California, School of Information and Computer Science.
</p>

<hr>
<h2 id='compute_effects'>Compute effects for specified in labels covariates using a fitted model.</h2><span id='topic+compute_effects'></span>

<h3>Description</h3>

<p>This function computes model averaged effects for specified covariates using a fitted model object.
The effects are expected change in the BMA linear predictor having an increase of the corresponding covariate by one unit, while other covariates are fixed to 0.
Users can provide custom labels and specify quantiles for the computation of effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_effects(object, labels, quantiles = c(0.025, 0.5, 0.975))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_effects_+3A_object">object</code></td>
<td>
<p>A fitted model object, typically the result of a regression or predictive modeling.</p>
</td></tr>
<tr><td><code id="compute_effects_+3A_labels">labels</code></td>
<td>
<p>A vector of labels for which effects are to be computed.</p>
</td></tr>
<tr><td><code id="compute_effects_+3A_quantiles">quantiles</code></td>
<td>
<p>A numeric vector specifying the quantiles to be calculated. Default is c(0.025, 0.5, 0.975).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of treatment effects for the specified labels, with rows corresponding to labels and columns to quantiles.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict">predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- data.frame(matrix(rnorm(600), 100))
result &lt;- mjmcmc.parallel(runs = 2, cores = 1, data, gaussian.loglik)
compute_effects(result,labels = names(data)[-1])

</code></pre>

<hr>
<h2 id='cos_deg'>Cosine function for degrees</h2><span id='topic+cos_deg'></span>

<h3>Description</h3>

<p>Cosine function for degrees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cos_deg(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cos_deg_+3A_x">x</code></td>
<td>
<p>The vector of values in degrees</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cosine of x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cos_deg(0)

</code></pre>

<hr>
<h2 id='diagn_plot'>Plot convergence of best/median/mean/other summary log posteriors in time</h2><span id='topic+diagn_plot'></span>

<h3>Description</h3>

<p>Plot convergence of best/median/mean/other summary log posteriors in time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagn_plot(res, FUN = median, conf = 0.95, burnin = 0, window = 5, ylim = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diagn_plot_+3A_res">res</code></td>
<td>
<p>Object corresponding gmjmcmc output</p>
</td></tr>
<tr><td><code id="diagn_plot_+3A_fun">FUN</code></td>
<td>
<p>The summary statistics to check convergence</p>
</td></tr>
<tr><td><code id="diagn_plot_+3A_conf">conf</code></td>
<td>
<p>which confidence intervals to plot</p>
</td></tr>
<tr><td><code id="diagn_plot_+3A_burnin">burnin</code></td>
<td>
<p>how many first populations to skip</p>
</td></tr>
<tr><td><code id="diagn_plot_+3A_window">window</code></td>
<td>
<p>sliding window for computing the standard deviation</p>
</td></tr>
<tr><td><code id="diagn_plot_+3A_ylim">ylim</code></td>
<td>
<p>limits for the plotting range, if unspecified, min and max of confidence intervals will be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of summary statistics for checking convergence with given confidence intervals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc(matrix(rnorm(600), 100), P = 2, gaussian.loglik, NULL, c("p0", "exp_dbl"))
diagnstats &lt;- diagn_plot(result)

</code></pre>

<hr>
<h2 id='erf'>erf function</h2><span id='topic+erf'></span>

<h3>Description</h3>

<p>erf function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>erf(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="erf_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>2 * pnorm(x * sqrt(2)) - 1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>erf(2)

</code></pre>

<hr>
<h2 id='exoplanet'>Excerpt from the Open Exoplanet Catalogue data set</h2><span id='topic+exoplanet'></span>

<h3>Description</h3>

<p>Data fields include planet and host star attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(exoplanet)
</code></pre>


<h3>Format</h3>

<p>A data frame with 223 rows and 11 variables
</p>


<h3>Details</h3>

<p>The variables are as follows:
</p>

<ul>
<li><p> TypeFlag: Flag indicating the type of data
</p>
</li>
<li><p> PlanetaryMassJpt: Mass of the planetary object in Jupiter masses
</p>
</li>
<li><p> RadiusJpt: Radius of the planetary object in Jupiter radii
</p>
</li>
<li><p> PeriodDays: Orbital period of the planetary object in days
</p>
</li>
<li><p> SemiMajorAxisAU: Semi-major axis of the planetary object's orbit in astronomical units
</p>
</li>
<li><p> Eccentricity: Eccentricity of the planetary object's orbit
</p>
</li>
<li><p> HostStarMassSlrMass: Mass of the host star in solar masses
</p>
</li>
<li><p> HostStarRadiusSlrRad: Radius of the host star in solar radii
</p>
</li>
<li><p> HostStarMetallicity: Metallicity of the host star
</p>
</li>
<li><p> HostStarTempK: Effective temperature of the host star in Kelvin
</p>
</li>
<li><p> PlanetaryDensJpt: Density of the planetary object up to a constant
</p>
</li></ul>



<h3>Source</h3>

<p>Dataset downloaded from the Open Exoplanet Catalogue Repository.
<a href="https://github.com/OpenExoplanetCatalogue/oec_tables/">https://github.com/OpenExoplanetCatalogue/oec_tables/</a>
</p>
<p>Creators:
</p>

<ol>
<li><p> Prof. Hanno Rein, Department for Physical and Environmental Sciences.
University of Toronto at Scarborough
Toronto, Ontario M1C 1A4
hanno.rein 'at' utoronto.ca
</p>
</li></ol>


<hr>
<h2 id='exp_dbl'>Double exponential function</h2><span id='topic+exp_dbl'></span>

<h3>Description</h3>

<p>Double exponential function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exp_dbl(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exp_dbl_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>e^(-abs(x))
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp_dbl(2)

</code></pre>

<hr>
<h2 id='fbms'>Fit a BGNLM  model using Genetically Modified Mode Jumping Markov Chain Monte Carlo (MCMC) sampling.
Or Fit a BGLM model using Modified Mode Jumping Markov Chain Monte Carlo (MCMC) sampling.</h2><span id='topic+fbms'></span>

<h3>Description</h3>

<p>This function fits a model using the relevant MCMC sampling. The user can specify the formula,
family, data, transforms, and other parameters to customize the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbms(
  formula = NULL,
  family = "gaussian",
  data = NULL,
  impute = FALSE,
  loglik.pi = gaussian.loglik,
  method = "mjmcmc",
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fbms_+3A_formula">formula</code></td>
<td>
<p>A formula object specifying the model structure. Default is NULL.</p>
</td></tr>
<tr><td><code id="fbms_+3A_family">family</code></td>
<td>
<p>The distribution family of the response variable. Currently supports &quot;gaussian&quot;, &quot;binomial&quot; and  &quot;custom&quot;. Default is &quot;gaussian&quot;.</p>
</td></tr>
<tr><td><code id="fbms_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the model. If NULL, the variables are taken from the environment of the formula. Default is NULL.</p>
</td></tr>
<tr><td><code id="fbms_+3A_impute">impute</code></td>
<td>
<p>TRUE  means imputation combined with adding a dummy column with indicators of imputed values, FALSE (default) means only full data is used.</p>
</td></tr>
<tr><td><code id="fbms_+3A_loglik.pi">loglik.pi</code></td>
<td>
<p>Custom function to compute the logarithm of the posterior mode based on logarithm of marginal likelihood and logarithm of prior functions (needs specification only used if family = &quot;custom&quot;)</p>
</td></tr>
<tr><td><code id="fbms_+3A_method">method</code></td>
<td>
<p>Which fitting algorithm should be used, currently implemented options include &quot;gmjmcmc&quot;, &quot;gmjmcmc.parallel&quot;, &quot;mjmcmc&quot; and &quot;mjmcmc.parallel&quot; with &quot;mjmcmc&quot; being the default and 'mjmcmc' means that only linear models will be estimated</p>
</td></tr>
<tr><td><code id="fbms_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, print detailed progress information during the fitting process. Default is TRUE.</p>
</td></tr>
<tr><td><code id="fbms_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to the underlying method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object containing the results of the fitted model and MCMC sampling.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mjmcmc">mjmcmc</a></code>, <code><a href="#topic+gmjmcmc">gmjmcmc</a></code>, <code><a href="#topic+gmjmcmc.parallel">gmjmcmc.parallel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fit a Gaussian multivariate time series model
fbms_result &lt;- fbms(
 X1 ~ .,
 family = "gaussian",
 method = "gmjmcmc.parallel",
 data = data.frame(matrix(rnorm(600), 100)),
 transforms = c("sin","cos"),
 P = 10,
 runs = 1,
 cores = 1
)
summary(fbms_result)
plot(fbms_result)


</code></pre>

<hr>
<h2 id='gauss'>Gaussian function</h2><span id='topic+gauss'></span>

<h3>Description</h3>

<p>Gaussian function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gauss(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gauss_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>e^(-x^2)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gauss(2)

</code></pre>

<hr>
<h2 id='gaussian.loglik'>Log likelihood function for gaussian regression with a prior p(m)=r*sum(total_width).</h2><span id='topic+gaussian.loglik'></span>

<h3>Description</h3>

<p>Log likelihood function for gaussian regression with a prior p(m)=r*sum(total_width).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian.loglik(y, x, model, complex, params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gaussian.loglik_+3A_y">y</code></td>
<td>
<p>A vector containing the dependent variable</p>
</td></tr>
<tr><td><code id="gaussian.loglik_+3A_x">x</code></td>
<td>
<p>The matrix containing the precalculated features</p>
</td></tr>
<tr><td><code id="gaussian.loglik_+3A_model">model</code></td>
<td>
<p>The model to estimate as a logical vector</p>
</td></tr>
<tr><td><code id="gaussian.loglik_+3A_complex">complex</code></td>
<td>
<p>A list of complexity measures for the features</p>
</td></tr>
<tr><td><code id="gaussian.loglik_+3A_params">params</code></td>
<td>
<p>A list of parameters for the log likelihood, supplied by the user</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the log marginal likelihood combined with the log prior (crit) and the posterior mode of the coefficients (coefs).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gaussian.loglik(rnorm(100), matrix(rnorm(100)), TRUE, list(oc = 1), NULL)
  

</code></pre>

<hr>
<h2 id='gaussian.loglik.alpha'>Log likelihood function for gaussian regression for alpha calculation
This function is just the bare likelihood function
Note that it only gives a proportional value and is equivalent to least squares</h2><span id='topic+gaussian.loglik.alpha'></span>

<h3>Description</h3>

<p>Log likelihood function for gaussian regression for alpha calculation
This function is just the bare likelihood function
Note that it only gives a proportional value and is equivalent to least squares
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian.loglik.alpha(a, data, mu_func)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gaussian.loglik.alpha_+3A_a">a</code></td>
<td>
<p>A vector of the alphas to be used</p>
</td></tr>
<tr><td><code id="gaussian.loglik.alpha_+3A_data">data</code></td>
<td>
<p>The data to be used for calculation</p>
</td></tr>
<tr><td><code id="gaussian.loglik.alpha_+3A_mu_func">mu_func</code></td>
<td>
<p>The function linking the mean to the covariates,
as a string with the alphas as a[i].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric with the log likelihood.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gaussian.loglik.alpha(my_alpha,my_data,my_mu)

## End(Not run)
</code></pre>

<hr>
<h2 id='gelu'>GELU function</h2><span id='topic+gelu'></span>

<h3>Description</h3>

<p>GELU function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gelu(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gelu_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x*pnorm(x)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gelu(2)

</code></pre>

<hr>
<h2 id='gen.params.gmjmcmc'>Generate a parameter list for GMJMCMC (Genetically Modified MJMCMC)</h2><span id='topic+gen.params.gmjmcmc'></span>

<h3>Description</h3>

<p>This function generates the full list of parameters required for the Generalized Mode Jumping Markov Chain Monte Carlo (GMJMCMC) algorithm, building upon the parameters from <code>gen.params.mjmcmc</code>. The generated parameter list includes feature generation settings, population control parameters, and optimization controls for the search process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.params.gmjmcmc(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen.params.gmjmcmc_+3A_data">data</code></td>
<td>
<p>A data frame containing the dataset with covariates and response variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of parameters for controlling GMJMCMC behavior:
</p>


<h3>Feature Generation Parameters (<code>feat</code>)</h3>


<dl>
<dt><code>feat$D</code></dt><dd><p>Maximum feature depth, default <code>5</code>. Limits the number of recursive feature transformations. For fractional polynomials, it is recommended to set <code>D = 1</code>.</p>
</dd>
<dt><code>feat$L</code></dt><dd><p>Maximum number of features per model, default <code>15</code>. Increase for complex models.</p>
</dd>
<dt><code>feat$alpha</code></dt><dd><p>Strategy for generating $alpha$ parameters in non-linear projections:
</p>

<dl>
<dt><code>"unit"</code></dt><dd><p>(Default) Sets all components to 1.</p>
</dd>
<dt><code>"deep"</code></dt><dd><p>Optimizes $alpha$ across all feature layers.</p>
</dd>
<dt><code>"random"</code></dt><dd><p>Samples $alpha$ from the prior for a fully Bayesian approach.</p>
</dd>
</dl>
</dd>
<dt><code>feat$pop.max</code></dt><dd><p>Maximum feature population size per iteration. Defaults to <code>min(100, as.integer(1.5 * p))</code>, where <code>p</code> is the number of covariates.</p>
</dd>
<dt><code>feat$keep.org</code></dt><dd><p>Logical flag; if <code>TRUE</code>, original covariates remain in every population (default <code>FALSE</code>).</p>
</dd>
<dt><code>feat$prel.filter</code></dt><dd><p>Threshold for pre-filtering covariates before the first population generation. Default <code>0</code> disables filtering.</p>
</dd>
<dt><code>feat$prel.select</code></dt><dd><p>Indices of covariates to include initially. Default <code>NULL</code> includes all.</p>
</dd>
<dt><code>feat$keep.min</code></dt><dd><p>Minimum proportion of features to retain during population updates. Default <code>0.8</code>.</p>
</dd>
<dt><code>feat$eps</code></dt><dd><p>Threshold for feature inclusion probability during generation. Default <code>0.05</code>.</p>
</dd>
<dt><code>feat$check.col</code></dt><dd><p>Logical; if <code>TRUE</code> (default), checks for collinearity during feature generation.</p>
</dd>
<dt><code>feat$max.proj.size</code></dt><dd><p>Maximum number of existing features used to construct a new one. Default <code>15</code>.</p>
</dd>
</dl>



<h3>Scaling Option</h3>


<dl>
<dt><code>rescale.large</code></dt><dd><p>Logical flag for rescaling large data values for numerical stability. Default <code>FALSE</code>.</p>
</dd>
</dl>



<h3>MJMCMC Parameters</h3>


<dl>
<dt><code>burn_in</code></dt><dd><p>The burn-in period for the MJMCMC algorithm, which is set to 100 iterations by default.</p>
</dd>
<dt><code>mh</code></dt><dd><p>A list containing parameters for the regular Metropolis-Hastings (MH) kernel:
</p>

<dl>
<dt><code>neigh.size</code></dt><dd><p>The size of the neighborhood for MH proposals with fixed proposal size, default set to 1.</p>
</dd>
<dt><code>neigh.min</code></dt><dd><p>The minimum neighborhood size for random proposal size, default set to 1.</p>
</dd>
<dt><code>neigh.max</code></dt><dd><p>The maximum neighborhood size for random proposal size, default set to 2.</p>
</dd>
</dl>

</dd>
<dt><code>large</code></dt><dd><p>A list containing parameters for the large jump kernel:
</p>

<dl>
<dt><code>neigh.size</code></dt><dd><p>The size of the neighborhood for large jump proposals with fixed neighborhood size, default set to the smaller of <code>0.35 * p</code> and <code>35</code>, where <code class="reqn">p</code> is the number of covariates.</p>
</dd>
<dt><code>neigh.min</code></dt><dd><p>The minimum neighborhood size for large jumps with random size of the neighborhood, default set to the smaller of <code>0.25 * p</code> and <code>25</code>.</p>
</dd>
<dt><code>neigh.max</code></dt><dd><p>The maximum neighborhood size for large jumps with random size of the neighborhood, default set to the smaller of <code>0.45 * p</code> and <code>45</code>.</p>
</dd>
</dl>

</dd>
<dt><code>random</code></dt><dd><p>A list containing a parameter for the randomization kernel:
</p>

<dl>
<dt><code>prob</code></dt><dd><p>The small probability of changing the component around the mode, default set to 0.01.</p>
</dd>
</dl>

</dd>
<dt><code>sa</code></dt><dd><p>A list containing parameters for the simulated annealing kernel:
</p>

<dl>
<dt><code>probs</code></dt><dd><p>A numeric vector of length 6 specifying the probabilities for different types of proposals in the simulated annealing algorithm.</p>
</dd>
<dt><code>neigh.size</code></dt><dd><p>The size of the neighborhood for the simulated annealing proposals, default set to 1.</p>
</dd>
<dt><code>neigh.min</code></dt><dd><p>The minimum neighborhood size, default set to 1.</p>
</dd>
<dt><code>neigh.max</code></dt><dd><p>The maximum neighborhood size, default set to 2.</p>
</dd>
<dt><code>t.init</code></dt><dd><p>The initial temperature for simulated annealing, default set to 10.</p>
</dd>
<dt><code>t.min</code></dt><dd><p>The minimum temperature for simulated annealing, default set to 0.0001.</p>
</dd>
<dt><code>dt</code></dt><dd><p>The temperature decrement factor, default set to 3.</p>
</dd>
<dt><code>M</code></dt><dd><p>The number of iterations in the simulated annealing process, default set to 12.</p>
</dd>
</dl>

</dd>
<dt><code>greedy</code></dt><dd><p>A list containing parameters for the greedy algorithm:
</p>

<dl>
<dt><code>probs</code></dt><dd><p>A numeric vector of length 6 specifying the probabilities for different types of proposals in the greedy algorithm.</p>
</dd>
<dt><code>neigh.size</code></dt><dd><p>The size of the neighborhood for greedy algorithm proposals, set to 1.</p>
</dd>
<dt><code>neigh.min</code></dt><dd><p>The minimum neighborhood size for greedy proposals, set to 1.</p>
</dd>
<dt><code>neigh.max</code></dt><dd><p>The maximum neighborhood size for greedy proposals, set to 2.</p>
</dd>
<dt><code>steps</code></dt><dd><p>The number of steps for the greedy algorithm, set to 20.</p>
</dd>
<dt><code>tries</code></dt><dd><p>The number of tries for the greedy algorithm, set to 3.</p>
</dd>
</dl>

</dd>
<dt><code>loglik</code></dt><dd><p>A list to store log-likelihood values, which is by default empty.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+gen.params.mjmcmc">gen.params.mjmcmc</a></code>, <code><a href="#topic+gmjmcmc">gmjmcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(y = rnorm(100), x1 = rnorm(100), x2 = rnorm(100))
params &lt;- gen.params.gmjmcmc(data)
str(params)

</code></pre>

<hr>
<h2 id='gen.params.mjmcmc'>Generate a parameter list for MJMCMC (Mode Jumping MCMC)</h2><span id='topic+gen.params.mjmcmc'></span>

<h3>Description</h3>

<p>Generate a parameter list for MJMCMC (Mode Jumping MCMC)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.params.mjmcmc(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen.params.mjmcmc_+3A_data">data</code></td>
<td>
<p>The dataset that will be used in the algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of parameters to use when running the mjmcmc function.
</p>
<p>The list contains the following elements:
</p>

<dl>
<dt><code>burn_in</code></dt><dd><p>The burn-in period for the MJMCMC algorithm, which is set to 100 iterations by default.</p>
</dd>
<dt><code>mh</code></dt><dd><p>A list containing parameters for the regular Metropolis-Hastings (MH) kernel:
</p>

<dl>
<dt><code>neigh.size</code></dt><dd><p>The size of the neighborhood for MH proposals with fixed proposal size, default set to 1.</p>
</dd>
<dt><code>neigh.min</code></dt><dd><p>The minimum neighborhood size for random proposal size, default set to 1.</p>
</dd>
<dt><code>neigh.max</code></dt><dd><p>The maximum neighborhood size for random proposal size, default set to 2.</p>
</dd>
</dl>

</dd>
<dt><code>large</code></dt><dd><p>A list containing parameters for the large jump kernel:
</p>

<dl>
<dt><code>neigh.size</code></dt><dd><p>The size of the neighborhood for large jump proposals with fixed neighborhood size, default set to the smaller of 0.35 <code class="reqn">\times p</code>  and 35, where <code class="reqn">p</code> is the number of covariates.</p>
</dd>
<dt><code>neigh.min</code></dt><dd><p>The minimum neighborhood size for large jumps with random size of the neighborhood, default set to the smaller of 0.25 <code class="reqn">\times p</code>  and 25.</p>
</dd>
<dt><code>neigh.max</code></dt><dd><p>The maximum neighborhood size for large jumps with random size of the neighborhood, default set to the smaller of 0.45 <code class="reqn">\times p</code>  and 45.</p>
</dd>
</dl>

</dd>
<dt><code>random</code></dt><dd><p>A list containing a parameter for the randomization kernel:
</p>

<dl>
<dt><code>prob</code></dt><dd><p>The small probability of changing the component around the mode, default set to 0.01.</p>
</dd>
</dl>

</dd>
<dt><code>sa</code></dt><dd><p>A list containing parameters for the simulated annealing kernel:
</p>

<dl>
<dt><code>probs</code></dt><dd><p>A numeric vector of length 6 specifying the probabilities for different types of proposals in the simulated annealing algorithm.</p>
</dd>
<dt><code>neigh.size</code></dt><dd><p>The size of the neighborhood for the simulated annealing proposals, default set to 1.</p>
</dd>
<dt><code>neigh.min</code></dt><dd><p>The minimum neighborhood size, default set to 1.</p>
</dd>
<dt><code>neigh.max</code></dt><dd><p>The maximum neighborhood size, default set to 2.</p>
</dd>
<dt><code>t.init</code></dt><dd><p>The initial temperature for simulated annealing, default set to 10.</p>
</dd>
<dt><code>t.min</code></dt><dd><p>The minimum temperature for simulated annealing, default set to 0.0001.</p>
</dd>
<dt><code>dt</code></dt><dd><p>The temperature decrement factor, default set to 3.</p>
</dd>
<dt><code>M</code></dt><dd><p>The number of iterations in the simulated annealing process, default set to 12.</p>
</dd>
</dl>

</dd>
<dt><code>greedy</code></dt><dd><p>A list containing parameters for the greedy algorithm:
</p>

<dl>
<dt><code>probs</code></dt><dd><p>A numeric vector of length 6 specifying the probabilities for different types of proposals in the greedy algorithm.</p>
</dd>
<dt><code>neigh.size</code></dt><dd><p>The size of the neighborhood for greedy algorithm proposals, set to 1.</p>
</dd>
<dt><code>neigh.min</code></dt><dd><p>The minimum neighborhood size for greedy proposals, set to 1.</p>
</dd>
<dt><code>neigh.max</code></dt><dd><p>The maximum neighborhood size for greedy proposals, set to 2.</p>
</dd>
<dt><code>steps</code></dt><dd><p>The number of steps for the greedy algorithm, set to 20.</p>
</dd>
<dt><code>tries</code></dt><dd><p>The number of tries for the greedy algorithm, set to 3.</p>
</dd>
</dl>

</dd>
<dt><code>loglik</code></dt><dd><p>A list to store log-likelihood values, which is by default empty.</p>
</dd>
</dl>

<p>Note that the <code style="white-space: pre;">&#8288;$loglik&#8288;</code> item is an empty list, which is passed to the log likelihood function of the model,
intended to store parameters that the estimator function should use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gen.params.mjmcmc(matrix(rnorm(600), 100))


</code></pre>

<hr>
<h2 id='gen.probs.gmjmcmc'>Generate a probability list for GMJMCMC (Genetically Modified MJMCMC)</h2><span id='topic+gen.probs.gmjmcmc'></span>

<h3>Description</h3>

<p>Generate a probability list for GMJMCMC (Genetically Modified MJMCMC)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.probs.gmjmcmc(transforms)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen.probs.gmjmcmc_+3A_transforms">transforms</code></td>
<td>
<p>A list of the transformations used (to get the count).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with eight elements:
</p>

<dl>
<dt><code>large</code></dt><dd><p>The probability of a large jump kernel in the MJMCMC algorithm.
With this probability, a large jump proposal will be made; otherwise, a local
Metropolis-Hastings proposal will be used. One needs to consider good mixing
around and between modes when specifying this parameter.</p>
</dd>
<dt><code>large.kern</code></dt><dd><p>A numeric vector of length 4 specifying the probabilities
for different types of large jump kernels.
The four components correspond to:
</p>

<ol>
<li><p> Random change with random neighborhood size
</p>
</li>
<li><p> Random change with fixed neighborhood size
</p>
</li>
<li><p> Swap with random neighborhood size
</p>
</li>
<li><p> Swap with fixed neighborhood size
</p>
</li></ol>

<p>These probabilities will be automatically normalized if they do not sum to 1.</p>
</dd>
<dt><code>localopt.kern</code></dt><dd><p>A numeric vector of length 2 specifying the probabilities
for different local optimization methods during large jumps. The first value represents
the probability of using simulated annealing, while the second corresponds to the
greedy optimizer. These probabilities will be normalized if needed.</p>
</dd>
<dt><code>random.kern</code></dt><dd><p>A numeric vector of length 2 specifying the probabilities
of first two randomization kernels applied after local optimization. These correspond
to the same kernel types as in <code>large.kern</code> but are used for local proposals
where type and 2 only are allowed.</p>
</dd>
<dt><code>mh</code></dt><dd><p>A numeric vector specifying the probabilities of different standard Metropolis-Hastings kernels, where the first four as the same as for other kernels, while fifths and sixes components are uniform addition/deletion of a covariate.</p>
</dd>
<dt><code>filter</code></dt><dd><p>A numeric value controlling the filtering of features
with low posterior probabilities in the current population. Features with
posterior probabilities below this threshold will be removed with a probability
proportional to <code class="reqn">1 - P(\text{feature} \mid \text{population})</code>.</p>
</dd>
<dt><code>gen</code></dt><dd><p>A numeric vector of length 4 specifying the probabilities of different
feature generation operators. These determine how new nonlinear features are introduced.
The first entry gives the probability for an interaction, followed by modification,
nonlinear projection, and a mutation operator, which reintroduces discarded features.
If these probabilities do not sum to 1, they are automatically normalized.</p>
</dd>
<dt><code>trans</code></dt><dd><p>A numeric vector of length equal to the number of elements in <code>transforms</code>,
specifying the probabilities of selecting each nonlinear transformation from <code class="reqn">\mathcal{G}</code>.
By default, a uniform distribution is assigned, but this can be modified by providing a specific
<code>transforms</code> argument.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>gen.probs.gmjmcmc(c("p0", "exp_dbl"))


</code></pre>

<hr>
<h2 id='gen.probs.mjmcmc'>Generate a probability list for MJMCMC (Mode Jumping MCMC)</h2><span id='topic+gen.probs.mjmcmc'></span>

<h3>Description</h3>

<p>Generate a probability list for MJMCMC (Mode Jumping MCMC)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.probs.mjmcmc()
</code></pre>


<h3>Value</h3>

<p>A named list with five elements:
</p>

<dl>
<dt><code>large</code></dt><dd><p>A numeric value representing the probability of making a large jump. If a large jump is not made, a local MH (Metropolis-Hastings) proposal is used instead.</p>
</dd>
<dt><code>large.kern</code></dt><dd><p>A numeric vector of length 4 specifying the probabilities for different types of large jump kernels. The four components correspond to:
</p>

<ol>
<li><p> Random change with random neighborhood size
</p>
</li>
<li><p> Random change with fixed neighborhood size
</p>
</li>
<li><p> Swap with random neighborhood size
</p>
</li>
<li><p> Swap with fixed neighborhood size
</p>
</li></ol>

<p>These probabilities will be automatically normalized if they do not sum to 1.</p>
</dd>
<dt><code>localopt.kern</code></dt><dd><p>A numeric vector of length 2 specifying the probabilities for different local optimization methods during large jumps. The first value represents the probability of using simulated annealing, while the second corresponds to the greedy optimizer. These probabilities will be normalized if needed.</p>
</dd>
<dt><code>random.kern</code></dt><dd><p>A numeric vector of length 2 specifying the probabilities of different randomization kernels applied after local optimization of type one or two. These correspond to the first two kernel types as in <code>large.kern</code> but are used for local proposals with different neighborhood sizes.</p>
</dd>
<dt><code>mh</code></dt><dd><p>A numeric vector specifying the probabilities of different standard Metropolis-Hastings kernels, where the first four as the same as for other kernels, while fifths and sixes components are uniform addition/deletion of a covariate.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>gen.probs.mjmcmc()

</code></pre>

<hr>
<h2 id='get.best.model'>Extract the Best Model from MJMCMC or GMJMCMC Results</h2><span id='topic+get.best.model'></span>

<h3>Description</h3>

<p>This function retrieves the best model from the results of MJMCMC, MJMCMC parallel, GMJMCMC, or GMJMCMC merged runs
based on the maximum criterion value (<code>crit</code>). The returned list includes the model probability, selected features,
criterion value, intercept parameter, and named coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.best.model(result, labels = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.best.model_+3A_result">result</code></td>
<td>
<p>An object of class <code>"mjmcmc"</code>, <code>"mjmcmc_parallel"</code>, <code>"gmjmcmc"</code>, or <code>"gmjmcmc_merged"</code>,
containing the results from the corresponding model search algorithms.</p>
</td></tr>
<tr><td><code id="get.best.model_+3A_labels">labels</code></td>
<td>
<p>Logical; if <code>TRUE</code>, uses labeled feature names when naming the model coefficients. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function identifies the best model by selecting the one with the highest <code>crit</code> value. Selection logic depends on the class of the <code>result</code> object:
</p>

<dl>
<dt><code>"mjmcmc"</code></dt><dd><p>Selects the top model from a single MJMCMC run.</p>
</dd>
<dt><code>"mjmcmc_parallel"</code></dt><dd><p>Identifies the best chain, then selects the best model from that chain.</p>
</dd>
<dt><code>"gmjmcmc"</code></dt><dd><p>Selects the best population and model within that population.</p>
</dd>
<dt><code>"gmjmcmc_merged"</code></dt><dd><p>Finds the best chain and population before extracting the top model.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list containing the details of the best model:
</p>

<dl>
<dt><code>prob</code></dt><dd><p>A numeric value representing the model's probability.</p>
</dd>
<dt><code>model</code></dt><dd><p>A logical vector indicating which features are included in the best model.</p>
</dd>
<dt><code>crit</code></dt><dd><p>The criterion value used for model selection (e.g., marginal likelihood or posterior probability).</p>
</dd>
<dt><code>alpha</code></dt><dd><p>The intercept parameter of the best model.</p>
</dd>
<dt><code>coefs</code></dt><dd><p>A named numeric vector of model coefficients, including the intercept and selected features.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc(matrix(rnorm(600), 100), P = 2, gaussian.loglik, NULL, c("p0", "exp_dbl"))
get.best.model(result)

</code></pre>

<hr>
<h2 id='get.mpm.model'>Retrieve the Median Probability Model (MPM)</h2><span id='topic+get.mpm.model'></span>

<h3>Description</h3>

<p>This function extracts the Median Probability Model (MPM) from a fitted model object.
The MPM includes features with marginal posterior inclusion probabilities greater than 0.5.
It constructs the corresponding model matrix and computes the model fit using the specified likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.mpm.model(
  result,
  y,
  x,
  labels = F,
  family = "gaussian",
  loglik.pi = gaussian.loglik,
  params = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.mpm.model_+3A_result">result</code></td>
<td>
<p>A fitted model object (e.g., from <code>mjmcmc</code>, <code>gmjmcmc</code>, or related classes) containing the summary statistics and marginal probabilities.</p>
</td></tr>
<tr><td><code id="get.mpm.model_+3A_y">y</code></td>
<td>
<p>A numeric vector of response values. For <code>family = "binomial"</code>, it should contain binary (0/1) responses.</p>
</td></tr>
<tr><td><code id="get.mpm.model_+3A_x">x</code></td>
<td>
<p>A <code>data.frame</code> of predictor variables. Columns must correspond to features considered during model fitting.</p>
</td></tr>
<tr><td><code id="get.mpm.model_+3A_labels">labels</code></td>
<td>
<p>If specified, custom labels of covariates can be used. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get.mpm.model_+3A_family">family</code></td>
<td>
<p>Character string specifying the model family. Supported options are:
</p>

<ul>
<li> <p><code>"gaussian"</code> (default) - for continuous outcomes.
</p>
</li>
<li> <p><code>"binomial"</code> - for binary outcomes.
</p>
</li>
<li> <p><code>"custom"</code> - for user-defined likelihood functions.
</p>
</li></ul>

<p>If an unsupported family is provided, a warning is issued and the Gaussian likelihood is used by default.</p>
</td></tr>
<tr><td><code id="get.mpm.model_+3A_loglik.pi">loglik.pi</code></td>
<td>
<p>A function that computes the log-likelihood. Defaults to <code>gaussian.loglik</code> unless <code>family = "binomial"</code>, in which case <code>logistic.loglik</code> is used. for custom family the user must specify the same likelihood that was used in the inference.</p>
</td></tr>
<tr><td><code id="get.mpm.model_+3A_params">params</code></td>
<td>
<p>Parameters of <code>loglik.pi</code>, if not specified NULL will be used by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>bgnlm_model</code> object containing:
</p>

<dl>
<dt><code>prob</code></dt><dd><p>The log marginal likelihood of the MPM.</p>
</dd>
<dt><code>model</code></dt><dd><p>A logical vector indicating included features.</p>
</dd>
<dt><code>crit</code></dt><dd><p>Criterion label set to <code>"MPM"</code>.</p>
</dd>
<dt><code>coefs</code></dt><dd><p>A named numeric vector of model coefficients, including the intercept.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Simulate data
set.seed(42)
x &lt;- data.frame(
  PlanetaryMassJpt = rnorm(100),
  RadiusJpt = rnorm(100),
  PeriodDays = rnorm(100)
)
y &lt;- 1 + 0.5 * x$PlanetaryMassJpt - 0.3 * x$RadiusJpt + rnorm(100)

# Assume 'result' is a fitted object from gmjmcmc or mjmcmc
result &lt;- mjmcmc(cbind(y,x))  

# Get the MPM
mpm_model &lt;- get.mpm.model(result, y, x, family = "gaussian")

# Access coefficients
mpm_model$coefs

## End(Not run)

</code></pre>

<hr>
<h2 id='gmjmcmc'>Main algorithm for GMJMCMC (Genetically Modified MJMCMC)</h2><span id='topic+gmjmcmc'></span>

<h3>Description</h3>

<p>Main algorithm for GMJMCMC (Genetically Modified MJMCMC)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmjmcmc(
  data,
  loglik.pi = gaussian.loglik,
  loglik.alpha = gaussian.loglik.alpha,
  transforms,
  P = 10,
  N.init = 100,
  N.final = 100,
  probs = NULL,
  params = NULL,
  sub = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gmjmcmc_+3A_data">data</code></td>
<td>
<p>A matrix containing the data to use in the algorithm,
first column should be the dependent variable,
and the rest of the columns should be the independent variables.</p>
</td></tr>
<tr><td><code id="gmjmcmc_+3A_loglik.pi">loglik.pi</code></td>
<td>
<p>The (log) density to explore</p>
</td></tr>
<tr><td><code id="gmjmcmc_+3A_loglik.alpha">loglik.alpha</code></td>
<td>
<p>The likelihood function to use for alpha calculation</p>
</td></tr>
<tr><td><code id="gmjmcmc_+3A_transforms">transforms</code></td>
<td>
<p>A Character vector including the names of the non-linear functions to be used by the modification
and the projection operator.</p>
</td></tr>
<tr><td><code id="gmjmcmc_+3A_p">P</code></td>
<td>
<p>The number of generations for GMJMCMC (Genetically Modified MJMCMC).
The default value is $P = 10$.
A larger value like $P = 50$ might be more realistic for more complicated examples where one expects a lot of non-linear structures.</p>
</td></tr>
<tr><td><code id="gmjmcmc_+3A_n.init">N.init</code></td>
<td>
<p>The number of iterations per population (total iterations = (T-1)*N.init+N.final)</p>
</td></tr>
<tr><td><code id="gmjmcmc_+3A_n.final">N.final</code></td>
<td>
<p>The number of iterations for the final population (total iterations = (T-1)*N.init+N.final)</p>
</td></tr>
<tr><td><code id="gmjmcmc_+3A_probs">probs</code></td>
<td>
<p>A list of the various probability vectors to use</p>
</td></tr>
<tr><td><code id="gmjmcmc_+3A_params">params</code></td>
<td>
<p>A list of the various parameters for all the parts of the algorithm</p>
</td></tr>
<tr><td><code id="gmjmcmc_+3A_sub">sub</code></td>
<td>
<p>An indicator that if the likelihood is inexact and should be improved each model visit (EXPERIMENTAL!)</p>
</td></tr>
<tr><td><code id="gmjmcmc_+3A_verbose">verbose</code></td>
<td>
<p>A logical denoting if messages should be printed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>models</code></td>
<td>
<p>All models per population.</p>
</td></tr>
<tr><td><code>lo.models</code></td>
<td>
<p>All local optimization models per population.</p>
</td></tr>
<tr><td><code>populations</code></td>
<td>
<p>All features per population.</p>
</td></tr>
<tr><td><code>marg.probs</code></td>
<td>
<p>Marginal feature probabilities per population.</p>
</td></tr>
<tr><td><code>model.probs</code></td>
<td>
<p>Marginal feature probabilities per population.</p>
</td></tr>
<tr><td><code>model.probs.idx</code></td>
<td>
<p>Marginal feature probabilities per population.</p>
</td></tr>
<tr><td><code>best.margs</code></td>
<td>
<p>Best marginal model probability per population.</p>
</td></tr>
<tr><td><code>accept</code></td>
<td>
<p>Acceptance rate per population.</p>
</td></tr>
<tr><td><code>accept.tot</code></td>
<td>
<p>Overall acceptance rate.</p>
</td></tr>
<tr><td><code>best</code></td>
<td>
<p>Best marginal model probability throughout the run, represented as the maximum value in <code>unlist(best.margs)</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc(matrix(rnorm(600), 100), P = 2, gaussian.loglik, NULL, c("p0", "exp_dbl"))
summary(result)
plot(result)

</code></pre>

<hr>
<h2 id='gmjmcmc.parallel'>Run multiple gmjmcmc (Genetically Modified MJMCMC) runs in parallel returning a list of all results.</h2><span id='topic+gmjmcmc.parallel'></span>

<h3>Description</h3>

<p>Run multiple gmjmcmc (Genetically Modified MJMCMC) runs in parallel returning a list of all results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmjmcmc.parallel(
  runs = 2,
  cores = getOption("mc.cores", 2L),
  merge.options = list(populations = "best", complex.measure = 2, tol = 1e-07),
  data,
  loglik.pi = gaussian.loglik,
  loglik.alpha = gaussian.loglik.alpha,
  transforms,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gmjmcmc.parallel_+3A_runs">runs</code></td>
<td>
<p>The number of runs to run</p>
</td></tr>
<tr><td><code id="gmjmcmc.parallel_+3A_cores">cores</code></td>
<td>
<p>The number of cores to run on</p>
</td></tr>
<tr><td><code id="gmjmcmc.parallel_+3A_merge.options">merge.options</code></td>
<td>
<p>A list of options to pass to the <code><a href="#topic+merge_results">merge_results()</a></code> function run after the</p>
</td></tr>
<tr><td><code id="gmjmcmc.parallel_+3A_data">data</code></td>
<td>
<p>A matrix containing the data to use in the algorithm,
first column should be the dependent variable,
and the rest of the columns should be the independent variables.</p>
</td></tr>
<tr><td><code id="gmjmcmc.parallel_+3A_loglik.pi">loglik.pi</code></td>
<td>
<p>The (log) density to explore</p>
</td></tr>
<tr><td><code id="gmjmcmc.parallel_+3A_loglik.alpha">loglik.alpha</code></td>
<td>
<p>The likelihood function to use for alpha calculation</p>
</td></tr>
<tr><td><code id="gmjmcmc.parallel_+3A_transforms">transforms</code></td>
<td>
<p>A Character vector including the names of the non-linear functions to be used by the modification
and the projection operator.</p>
</td></tr>
<tr><td><code id="gmjmcmc.parallel_+3A_...">...</code></td>
<td>
<p>Further parameters passed to mjmcmc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Results from multiple gmjmcmc runs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc.parallel(
  runs = 1,
  cores = 1,
  list(populations = "best", complex.measure = 2, tol = 0.0000001),
  matrix(rnorm(600), 100),
  P = 2,
  gaussian.loglik,
  loglik.alpha = gaussian.loglik.alpha,
  c("p0", "exp_dbl")
)

summary(result)

plot(result)

</code></pre>

<hr>
<h2 id='hs'>heavy side function</h2><span id='topic+hs'></span>

<h3>Description</h3>

<p>heavy side function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hs(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hs_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>as.integer(x&gt;0)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hs(2)

</code></pre>

<hr>
<h2 id='linear.g.prior.loglik'>Log likelihood function for linear regression using Zellners g-prior</h2><span id='topic+linear.g.prior.loglik'></span>

<h3>Description</h3>

<p>Log likelihood function for linear regression using Zellners g-prior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear.g.prior.loglik(y, x, model, complex, params = list(g = 4))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linear.g.prior.loglik_+3A_y">y</code></td>
<td>
<p>A vector containing the dependent variable</p>
</td></tr>
<tr><td><code id="linear.g.prior.loglik_+3A_x">x</code></td>
<td>
<p>The matrix containing the precalculated features</p>
</td></tr>
<tr><td><code id="linear.g.prior.loglik_+3A_model">model</code></td>
<td>
<p>The model to estimate as a logical vector</p>
</td></tr>
<tr><td><code id="linear.g.prior.loglik_+3A_complex">complex</code></td>
<td>
<p>A list of complexity measures for the features</p>
</td></tr>
<tr><td><code id="linear.g.prior.loglik_+3A_params">params</code></td>
<td>
<p>A list of parameters for the log likelihood, supplied by the user</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the log marginal likelihood combined with the log prior (crit) and the posterior mode of the coefficients (coefs).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>linear.g.prior.loglik(rnorm(100), matrix(rnorm(100)), TRUE, list(oc=1))

</code></pre>

<hr>
<h2 id='log_prior'>Log model prior function</h2><span id='topic+log_prior'></span>

<h3>Description</h3>

<p>Log model prior function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_prior(params, complex)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_prior_+3A_params">params</code></td>
<td>
<p>list of passed parameters of the likelihood in GMJMCMC</p>
</td></tr>
<tr><td><code id="log_prior_+3A_complex">complex</code></td>
<td>
<p>list of complexity measures of the features included into the model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric with the log model prior.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>log_prior(params = list(r=2), complex = list(oc = 2))

</code></pre>

<hr>
<h2 id='logistic.loglik'>Log likelihood function for logistic regression with a prior p(m)=sum(total_width)
This function is created as an example of how to create an estimator that is used
to calculate the marginal likelihood of a model.</h2><span id='topic+logistic.loglik'></span>

<h3>Description</h3>

<p>Log likelihood function for logistic regression with a prior p(m)=sum(total_width)
This function is created as an example of how to create an estimator that is used
to calculate the marginal likelihood of a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logistic.loglik(y, x, model, complex, params = list(r = exp(-0.5)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logistic.loglik_+3A_y">y</code></td>
<td>
<p>A vector containing the dependent variable</p>
</td></tr>
<tr><td><code id="logistic.loglik_+3A_x">x</code></td>
<td>
<p>The matrix containing the precalculated features</p>
</td></tr>
<tr><td><code id="logistic.loglik_+3A_model">model</code></td>
<td>
<p>The model to estimate as a logical vector</p>
</td></tr>
<tr><td><code id="logistic.loglik_+3A_complex">complex</code></td>
<td>
<p>A list of complexity measures for the features</p>
</td></tr>
<tr><td><code id="logistic.loglik_+3A_params">params</code></td>
<td>
<p>A list of parameters for the log likelihood, supplied by the user</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the log marginal likelihood combined with the log prior (crit) and the posterior mode of the coefficients (coefs).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logistic.loglik(as.integer(rnorm(100) &gt; 0), matrix(rnorm(100)), TRUE, list(oc = 1))


</code></pre>

<hr>
<h2 id='logistic.loglik.ala'>Log likelihood function for logistic regression with an approximate Laplace approximations used
This function is created as an example of how to create an estimator that is used
to calculate the marginal likelihood of a model.</h2><span id='topic+logistic.loglik.ala'></span>

<h3>Description</h3>

<p>Log likelihood function for logistic regression with an approximate Laplace approximations used
This function is created as an example of how to create an estimator that is used
to calculate the marginal likelihood of a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logistic.loglik.ala(y, x, model, complex, params = list(r = exp(-0.5)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logistic.loglik.ala_+3A_y">y</code></td>
<td>
<p>A vector containing the dependent variable</p>
</td></tr>
<tr><td><code id="logistic.loglik.ala_+3A_x">x</code></td>
<td>
<p>The matrix containing the precalculated features</p>
</td></tr>
<tr><td><code id="logistic.loglik.ala_+3A_model">model</code></td>
<td>
<p>The model to estimate as a logical vector</p>
</td></tr>
<tr><td><code id="logistic.loglik.ala_+3A_complex">complex</code></td>
<td>
<p>A list of complexity measures for the features</p>
</td></tr>
<tr><td><code id="logistic.loglik.ala_+3A_params">params</code></td>
<td>
<p>A list of parameters for the log likelihood, supplied by the user</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the log marginal likelihood combined with the log prior (crit) and the posterior mode of the coefficients (coefs).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logistic.loglik.ala(as.integer(rnorm(100) &gt; 0), matrix(rnorm(100)), TRUE, list(oc = 1))


</code></pre>

<hr>
<h2 id='logistic.loglik.alpha'>Log likelihood function for logistic regression for alpha calculation
This function is just the bare likelihood function</h2><span id='topic+logistic.loglik.alpha'></span>

<h3>Description</h3>

<p>Log likelihood function for logistic regression for alpha calculation
This function is just the bare likelihood function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logistic.loglik.alpha(a, data, mu_func)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logistic.loglik.alpha_+3A_a">a</code></td>
<td>
<p>A vector of the alphas to be used</p>
</td></tr>
<tr><td><code id="logistic.loglik.alpha_+3A_data">data</code></td>
<td>
<p>The data to be used for calculation</p>
</td></tr>
<tr><td><code id="logistic.loglik.alpha_+3A_mu_func">mu_func</code></td>
<td>
<p>The function linking the mean to the covariates,
as a string with the alphas as a[i].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric with the log likelihood.
</p>

<hr>
<h2 id='marginal.probs'>Function for calculating marginal inclusion probabilities of features given a list of models</h2><span id='topic+marginal.probs'></span>

<h3>Description</h3>

<p>Function for calculating marginal inclusion probabilities of features given a list of models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginal.probs(models)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="marginal.probs_+3A_models">models</code></td>
<td>
<p>The list of models to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of marginal model probabilities based on relative frequencies of model visits in MCMC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc(matrix(rnorm(600), 100), P = 2, gaussian.loglik, NULL, c("p0", "exp_dbl"))
marginal.probs(result$models[[1]])

</code></pre>

<hr>
<h2 id='merge_results'>Merge a list of multiple results from many runs
This function will weight the features based on the best marginal posterior in that population
and merge the results together, simplifying by merging equivalent features (having high correlation).</h2><span id='topic+merge_results'></span>

<h3>Description</h3>

<p>Merge a list of multiple results from many runs
This function will weight the features based on the best marginal posterior in that population
and merge the results together, simplifying by merging equivalent features (having high correlation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_results(
  results,
  populations = NULL,
  complex.measure = NULL,
  tol = NULL,
  data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge_results_+3A_results">results</code></td>
<td>
<p>A list containing multiple results from GMJMCMC (Genetically Modified MJMCMC).</p>
</td></tr>
<tr><td><code id="merge_results_+3A_populations">populations</code></td>
<td>
<p>Which populations should be merged from the results, can be &quot;all&quot;, &quot;last&quot; (default) or &quot;best&quot;.</p>
</td></tr>
<tr><td><code id="merge_results_+3A_complex.measure">complex.measure</code></td>
<td>
<p>The complex measure to use when finding the simplest equivalent feature,
1=total width, 2=operation count and 3=depth.</p>
</td></tr>
<tr><td><code id="merge_results_+3A_tol">tol</code></td>
<td>
<p>The tolerance to use for the correlation when finding equivalent features, default is 0.0000001</p>
</td></tr>
<tr><td><code id="merge_results_+3A_data">data</code></td>
<td>
<p>Data to use when comparing features, default is NULL meaning that mock data will be generated,
if data is supplied it should be of the same form as is required by gmjmcmc, i.e. with both x, y and an intercept.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;gmjmcmc_merged&quot; containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>features</code></td>
<td>
<p>The features where equivalent features are represented in their simplest form.</p>
</td></tr>
<tr><td><code>marg.probs</code></td>
<td>
<p>Importance of features.</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>Counts of how many versions that were present of each feature.</p>
</td></tr>
<tr><td><code>results</code></td>
<td>
<p>Results as they were passed to the function.</p>
</td></tr>
<tr><td><code>pop.best</code></td>
<td>
<p>The population in the results which contained the model with the highest log marginal posterior.</p>
</td></tr>
<tr><td><code>thread.best</code></td>
<td>
<p>The thread in the results which contained the model with the highest log marginal posterior.</p>
</td></tr>
<tr><td><code>crit.best</code></td>
<td>
<p>The highest log marginal posterior for any model in the results.</p>
</td></tr>
<tr><td><code>reported</code></td>
<td>
<p>The highest log marginal likelihood for the reported populations as defined in the populations argument.</p>
</td></tr>
<tr><td><code>rep.pop</code></td>
<td>
<p>The index of the population which contains reported.</p>
</td></tr>
<tr><td><code>best.log.posteriors</code></td>
<td>
<p>A matrix where the first column contains the population indices and the second column contains the model with the highest log marginal posterior within that population.</p>
</td></tr>
<tr><td><code>rep.thread</code></td>
<td>
<p>The index of the thread which contains reported.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc.parallel(
 runs = 1,
 cores = 1,
 list(populations = "best", complex.measure = 2, tol = 0.0000001),
 matrix(rnorm(600), 100),
 P = 2,
 gaussian.loglik,
 loglik.alpha = gaussian.loglik.alpha,
 c("p0", "exp_dbl")
)

summary(result)

plot(result)

merge_results(result$results)

</code></pre>

<hr>
<h2 id='mjmcmc'>Main algorithm for MJMCMC (Genetically Modified MJMCMC)</h2><span id='topic+mjmcmc'></span>

<h3>Description</h3>

<p>Main algorithm for MJMCMC (Genetically Modified MJMCMC)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mjmcmc(
  data,
  loglik.pi = gaussian.loglik,
  N = 100,
  probs = NULL,
  params = NULL,
  sub = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mjmcmc_+3A_data">data</code></td>
<td>
<p>A matrix containing the data to use in the algorithm,
first column should be the dependent variable,
and the rest of the columns should be the independent variables.</p>
</td></tr>
<tr><td><code id="mjmcmc_+3A_loglik.pi">loglik.pi</code></td>
<td>
<p>The (log) density to explore</p>
</td></tr>
<tr><td><code id="mjmcmc_+3A_n">N</code></td>
<td>
<p>The number of iterations to run for</p>
</td></tr>
<tr><td><code id="mjmcmc_+3A_probs">probs</code></td>
<td>
<p>A list of the various probability vectors to use</p>
</td></tr>
<tr><td><code id="mjmcmc_+3A_params">params</code></td>
<td>
<p>A list of the various parameters for all the parts of the algorithm</p>
</td></tr>
<tr><td><code id="mjmcmc_+3A_sub">sub</code></td>
<td>
<p>An indicator that if the likelihood is inexact and should be improved each model visit (EXPERIMENTAL!)</p>
</td></tr>
<tr><td><code id="mjmcmc_+3A_verbose">verbose</code></td>
<td>
<p>A logical denoting if messages should be printed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>models</code></td>
<td>
<p>All visited models.</p>
</td></tr>
<tr><td><code>accept</code></td>
<td>
<p>Average acceptance rate of the chain.</p>
</td></tr>
<tr><td><code>lo.models</code></td>
<td>
<p>All models visited during local optimization.</p>
</td></tr>
<tr><td><code>best.crit</code></td>
<td>
<p>The highest log marginal probability of the visited models.</p>
</td></tr>
<tr><td><code>marg.probs</code></td>
<td>
<p>Marginal probabilities of the features.</p>
</td></tr>
<tr><td><code>model.probs</code></td>
<td>
<p>Marginal probabilities of all of the visited models.</p>
</td></tr>
<tr><td><code>model.probs.idx</code></td>
<td>
<p>Indices of unique visited models.</p>
</td></tr>
<tr><td><code>populations</code></td>
<td>
<p>The covariates represented as a list of features.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- mjmcmc(matrix(rnorm(600), 100), gaussian.loglik)
summary(result)
plot(result)

</code></pre>

<hr>
<h2 id='mjmcmc.parallel'>Run multiple mjmcmc runs in parallel, merging the results before returning.</h2><span id='topic+mjmcmc.parallel'></span>

<h3>Description</h3>

<p>Run multiple mjmcmc runs in parallel, merging the results before returning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mjmcmc.parallel(runs = 2, cores = getOption("mc.cores", 2L), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mjmcmc.parallel_+3A_runs">runs</code></td>
<td>
<p>The number of runs to run</p>
</td></tr>
<tr><td><code id="mjmcmc.parallel_+3A_cores">cores</code></td>
<td>
<p>The number of cores to run on</p>
</td></tr>
<tr><td><code id="mjmcmc.parallel_+3A_...">...</code></td>
<td>
<p>Further parameters passed to mjmcmc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Merged results from multiple mjmcmc runs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- mjmcmc.parallel(runs = 1, cores = 1, matrix(rnorm(600), 100), gaussian.loglik)
summary(result)
plot(result)

</code></pre>

<hr>
<h2 id='model.string'>Function to generate a function string for a model consisting of features</h2><span id='topic+model.string'></span>

<h3>Description</h3>

<p>Function to generate a function string for a model consisting of features
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.string(model, features, link = "I", round = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model.string_+3A_model">model</code></td>
<td>
<p>A logical vector indicating which features to include</p>
</td></tr>
<tr><td><code id="model.string_+3A_features">features</code></td>
<td>
<p>The population of features</p>
</td></tr>
<tr><td><code id="model.string_+3A_link">link</code></td>
<td>
<p>The link function to use, as a string</p>
</td></tr>
<tr><td><code id="model.string_+3A_round">round</code></td>
<td>
<p>Rounding error for the features in the printed format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character representation of a model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc(matrix(rnorm(600), 100), P = 2, gaussian.loglik, NULL, c("p0", "exp_dbl"))
summary(result)
plot(result)
model.string(c(TRUE, FALSE, TRUE, FALSE, TRUE), result$populations[[1]])
model.string(result$models[[1]][1][[1]]$model, result$populations[[1]])

</code></pre>

<hr>
<h2 id='ngelu'>Negative GELU function</h2><span id='topic+ngelu'></span>

<h3>Description</h3>

<p>Negative GELU function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ngelu(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ngelu_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>-x*pnorm(-x)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ngelu(2)

</code></pre>

<hr>
<h2 id='nhs'>negative heavy side function</h2><span id='topic+nhs'></span>

<h3>Description</h3>

<p>negative heavy side function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nhs(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nhs_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>as.integer(x&lt;0)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nhs(2)

</code></pre>

<hr>
<h2 id='not'>not x</h2><span id='topic+not'></span>

<h3>Description</h3>

<p>not x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>not(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="not_+3A_x">x</code></td>
<td>
<p>The vector of binary values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1-x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>not(TRUE)

</code></pre>

<hr>
<h2 id='nrelu'>negative ReLu function</h2><span id='topic+nrelu'></span>

<h3>Description</h3>

<p>negative ReLu function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nrelu(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nrelu_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>max(-x,0)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nrelu(2)

</code></pre>

<hr>
<h2 id='p0'>p0 polynomial term</h2><span id='topic+p0'></span>

<h3>Description</h3>

<p>p0 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p0(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p0_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log(abs(x) + .Machine$double.eps)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p0(2)

</code></pre>

<hr>
<h2 id='p05'>p05 polynomial term</h2><span id='topic+p05'></span>

<h3>Description</h3>

<p>p05 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p05(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p05_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(abs(x)+.Machine$double.eps)^(0.5)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p05(2)

</code></pre>

<hr>
<h2 id='p0p0'>p0p0 polynomial term</h2><span id='topic+p0p0'></span>

<h3>Description</h3>

<p>p0p0 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p0p0(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p0p0_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p0(x)*p0(x)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p0p0(2)

</code></pre>

<hr>
<h2 id='p0p05'>p0p05 polynomial term</h2><span id='topic+p0p05'></span>

<h3>Description</h3>

<p>p0p05 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p0p05(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p0p05_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p0(x)*(abs(x)+.Machine$double.eps)^(0.5)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p0p05(2)

</code></pre>

<hr>
<h2 id='p0p1'>p0p1 polynomial term</h2><span id='topic+p0p1'></span>

<h3>Description</h3>

<p>p0p1 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p0p1(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p0p1_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p0(x)*x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p0p1(2)

</code></pre>

<hr>
<h2 id='p0p2'>p0p2 polynomial term</h2><span id='topic+p0p2'></span>

<h3>Description</h3>

<p>p0p2 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p0p2(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p0p2_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p0(x)*x^(2)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p0p2(2)

</code></pre>

<hr>
<h2 id='p0p3'>p0p3 polynomial term</h2><span id='topic+p0p3'></span>

<h3>Description</h3>

<p>p0p3 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p0p3(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p0p3_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p0(x)*x^(3)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p0p3(2)

</code></pre>

<hr>
<h2 id='p0pm05'>p0pm05 polynomial term</h2><span id='topic+p0pm05'></span>

<h3>Description</h3>

<p>p0pm05 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p0pm05(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p0pm05_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p0(x)<em>sign(x)</em>(abs(x)+.Machine$double.eps)^(-0.5)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p0pm05(2)

</code></pre>

<hr>
<h2 id='p0pm1'>p0pm1 polynomial terms</h2><span id='topic+p0pm1'></span>

<h3>Description</h3>

<p>p0pm1 polynomial terms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p0pm1(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p0pm1_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p0(x)*(x+.Machine$double.eps)^(-1)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p0pm1(2)

</code></pre>

<hr>
<h2 id='p0pm2'>p0pm2 polynomial term</h2><span id='topic+p0pm2'></span>

<h3>Description</h3>

<p>p0pm2 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p0pm2(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p0pm2_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p0(x)<em>sign(x)</em>(abs(x)+.Machine$double.eps)^(-2)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p0pm2(2)

</code></pre>

<hr>
<h2 id='p2'>p2 polynomial term</h2><span id='topic+p2'></span>

<h3>Description</h3>

<p>p2 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p2(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p2_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x^(2)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p2(2)

</code></pre>

<hr>
<h2 id='p3'>p3 polynomial term</h2><span id='topic+p3'></span>

<h3>Description</h3>

<p>p3 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p3(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p3_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x^(3)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p3(2)

</code></pre>

<hr>
<h2 id='plot.gmjmcmc'>Function to plot the results, works both for results from gmjmcmc and
merged results from merge.results</h2><span id='topic+plot.gmjmcmc'></span>

<h3>Description</h3>

<p>Function to plot the results, works both for results from gmjmcmc and
merged results from merge.results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmjmcmc'
plot(x, count = "all", pop = "best", tol = 1e-07, data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.gmjmcmc_+3A_x">x</code></td>
<td>
<p>The results to use</p>
</td></tr>
<tr><td><code id="plot.gmjmcmc_+3A_count">count</code></td>
<td>
<p>The number of features to plot, defaults to all</p>
</td></tr>
<tr><td><code id="plot.gmjmcmc_+3A_pop">pop</code></td>
<td>
<p>The population to plot, defaults to last</p>
</td></tr>
<tr><td><code id="plot.gmjmcmc_+3A_tol">tol</code></td>
<td>
<p>The tolerance to use for the correlation when finding equivalent features, default is 0.0000001</p>
</td></tr>
<tr><td><code id="plot.gmjmcmc_+3A_data">data</code></td>
<td>
<p>Data to merge on, important if pre-filtering was used</p>
</td></tr>
<tr><td><code id="plot.gmjmcmc_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, just creates a plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc(matrix(rnorm(600), 100), P = 2, gaussian.loglik, NULL, c("p0", "exp_dbl"))
plot(result)


</code></pre>

<hr>
<h2 id='plot.gmjmcmc_merged'>Plot a gmjmcmc_merged run</h2><span id='topic+plot.gmjmcmc_merged'></span>

<h3>Description</h3>

<p>Plot a gmjmcmc_merged run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmjmcmc_merged'
plot(x, count = "all", pop = NULL, tol = 1e-07, data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.gmjmcmc_merged_+3A_x">x</code></td>
<td>
<p>The results to use</p>
</td></tr>
<tr><td><code id="plot.gmjmcmc_merged_+3A_count">count</code></td>
<td>
<p>The number of features to plot, defaults to all</p>
</td></tr>
<tr><td><code id="plot.gmjmcmc_merged_+3A_pop">pop</code></td>
<td>
<p>The population to plot, defaults to last</p>
</td></tr>
<tr><td><code id="plot.gmjmcmc_merged_+3A_tol">tol</code></td>
<td>
<p>The tolerance to use for the correlation when finding equivalent features, default is 0.0000001</p>
</td></tr>
<tr><td><code id="plot.gmjmcmc_merged_+3A_data">data</code></td>
<td>
<p>Data to merge on, important if pre-filtering was used</p>
</td></tr>
<tr><td><code id="plot.gmjmcmc_merged_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, just creates a plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc.parallel(
 runs = 1,
 cores = 1,
 list(populations = "best", complex.measure = 2, tol = 0.0000001),
 matrix(rnorm(600), 100),
 P = 2,
 gaussian.loglik,
 loglik.alpha = gaussian.loglik.alpha,
 c("p0", "exp_dbl")
)
plot(result)

</code></pre>

<hr>
<h2 id='plot.mjmcmc'>Function to plot the results, works both for results from gmjmcmc and
merged results from merge.results</h2><span id='topic+plot.mjmcmc'></span>

<h3>Description</h3>

<p>Function to plot the results, works both for results from gmjmcmc and
merged results from merge.results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjmcmc'
plot(x, count = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mjmcmc_+3A_x">x</code></td>
<td>
<p>The results to use</p>
</td></tr>
<tr><td><code id="plot.mjmcmc_+3A_count">count</code></td>
<td>
<p>The number of features to plot, defaults to all</p>
</td></tr>
<tr><td><code id="plot.mjmcmc_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, just creates a plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- mjmcmc(matrix(rnorm(600), 100), gaussian.loglik)
plot(result)

</code></pre>

<hr>
<h2 id='plot.mjmcmc_parallel'>Plot a mjmcmc_parallel run</h2><span id='topic+plot.mjmcmc_parallel'></span>

<h3>Description</h3>

<p>Plot a mjmcmc_parallel run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjmcmc_parallel'
plot(x, count = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mjmcmc_parallel_+3A_x">x</code></td>
<td>
<p>The results to use</p>
</td></tr>
<tr><td><code id="plot.mjmcmc_parallel_+3A_count">count</code></td>
<td>
<p>The number of features to plot, defaults to all</p>
</td></tr>
<tr><td><code id="plot.mjmcmc_parallel_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, just creates a plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- mjmcmc.parallel(runs = 1, cores = 1, matrix(rnorm(600), 100), gaussian.loglik)
plot(result)

</code></pre>

<hr>
<h2 id='pm05'>pm05 polynomial term</h2><span id='topic+pm05'></span>

<h3>Description</h3>

<p>pm05 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pm05(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pm05_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(abs(x)+.Machine$double.eps)^(-0.5)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pm05(2)

</code></pre>

<hr>
<h2 id='pm1'>pm1 polynomial term</h2><span id='topic+pm1'></span>

<h3>Description</h3>

<p>pm1 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pm1(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pm1_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sign(x)*(abs(x)+.Machine$double.eps)^(-1)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pm1(2)

</code></pre>

<hr>
<h2 id='pm2'>pm2 polynomial term</h2><span id='topic+pm2'></span>

<h3>Description</h3>

<p>pm2 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pm2(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pm2_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sign(x)*(abs(x)+.Machine$double.eps)^(-2)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pm2(2)

</code></pre>

<hr>
<h2 id='predict.bgnlm_model'>Predict responses from a BGNLM model</h2><span id='topic+predict.bgnlm_model'></span>

<h3>Description</h3>

<p>This function generates predictions from a fitted <code>bgnlm_model</code> object given a new dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgnlm_model'
predict(
  object,
  x,
  link = function(x) {
     x
 },
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.bgnlm_model_+3A_object">object</code></td>
<td>
<p>A fitted <code>bgnlm_model</code> object obtained from the BGNLM fitting procedure.
It should contain the estimated coefficients in <code>model$coefs</code>.</p>
</td></tr>
<tr><td><code id="predict.bgnlm_model_+3A_x">x</code></td>
<td>
<p>A <code>data.frame</code> containing the new data for which predictions are to be made.
The variables in <code>x</code> must match the features used in the model.</p>
</td></tr>
<tr><td><code id="predict.bgnlm_model_+3A_link">link</code></td>
<td>
<p>A link function to apply to the linear predictor.
By default, it is the identity function <code>function(x){x}</code>,
but it can be any function such as <code>plogis</code> for logistic regression models.</p>
</td></tr>
<tr><td><code id="predict.bgnlm_model_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to prediction function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of predicted values for the given data <code>x</code>.
These predictions are calculated as <code class="reqn">\hat{y} = \text{link}(X \beta)</code>,
where <code class="reqn">X</code> is the design matrix and <code class="reqn">\beta</code> are the model coefficients.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example with simulated data
set.seed(123)
x_train &lt;- data.frame(PlanetaryMassJpt = rnorm(100), RadiusJpt = rnorm(100))
model &lt;- list(
  coefs = c(Intercept = -0.5, PlanetaryMassJpt = 0.2, RadiusJpt = -0.1),
  class = "bgnlm_model"
)
class(model) &lt;- "bgnlm_model"

# New data for prediction
x_new &lt;- data.frame(PlanetaryMassJpt = c(0.1, -0.3), RadiusJpt = c(0.2, -0.1))

# Predict using the identity link (default)
preds &lt;- predict.bgnlm_model(model, x_new)

## End(Not run)

</code></pre>

<hr>
<h2 id='predict.gmjmcmc'>Predict using a gmjmcmc result object.</h2><span id='topic+predict.gmjmcmc'></span>

<h3>Description</h3>

<p>Predict using a gmjmcmc result object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmjmcmc'
predict(
  object,
  x,
  link = function(x) x,
  quantiles = c(0.025, 0.5, 0.975),
  pop = NULL,
  tol = 1e-07,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.gmjmcmc_+3A_object">object</code></td>
<td>
<p>The model to use.</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_+3A_x">x</code></td>
<td>
<p>The new data to use for the prediction, a matrix where each row is an observation.</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_+3A_link">link</code></td>
<td>
<p>The link function to use</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_+3A_quantiles">quantiles</code></td>
<td>
<p>The quantiles to calculate credible intervals for the posterior modes (in model space).</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_+3A_pop">pop</code></td>
<td>
<p>The population to plot, defaults to last</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_+3A_tol">tol</code></td>
<td>
<p>The tolerance to use for the correlation when finding equivalent features, default is 0.0000001</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing aggregated predictions and per model predictions.
</p>
<table role = "presentation">
<tr><td><code>aggr</code></td>
<td>
<p>Aggregated predictions with mean and quantiles.</p>
</td></tr>
<tr><td><code>preds</code></td>
<td>
<p>A list of lists containing individual predictions per model per population in object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc(
 matrix(rnorm(600), 100),
 P = 2,
 gaussian.loglik,
 loglik.alpha = gaussian.loglik.alpha,
 c("p0", "exp_dbl")
)
preds &lt;- predict(result, matrix(rnorm(600), 100))


</code></pre>

<hr>
<h2 id='predict.gmjmcmc_merged'>Predict using a merged gmjmcmc result object.</h2><span id='topic+predict.gmjmcmc_merged'></span>

<h3>Description</h3>

<p>Predict using a merged gmjmcmc result object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmjmcmc_merged'
predict(
  object,
  x,
  link = function(x) x,
  quantiles = c(0.025, 0.5, 0.975),
  pop = NULL,
  tol = 1e-07,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.gmjmcmc_merged_+3A_object">object</code></td>
<td>
<p>The model to use.</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_merged_+3A_x">x</code></td>
<td>
<p>The new data to use for the prediction, a matrix where each row is an observation.</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_merged_+3A_link">link</code></td>
<td>
<p>The link function to use</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_merged_+3A_quantiles">quantiles</code></td>
<td>
<p>The quantiles to calculate credible intervals for the posterior modes (in model space).</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_merged_+3A_pop">pop</code></td>
<td>
<p>The population to plot, defaults to last</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_merged_+3A_tol">tol</code></td>
<td>
<p>The tolerance to use for the correlation when finding equivalent features, default is 0.0000001</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_merged_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing aggregated predictions and per model predictions.
</p>
<table role = "presentation">
<tr><td><code>aggr</code></td>
<td>
<p>Aggregated predictions with mean and quantiles.</p>
</td></tr>
<tr><td><code>preds</code></td>
<td>
<p>A list of lists containing individual predictions per model per population in object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc.parallel(
 runs = 1,
 cores = 1,
 list(populations = "best", complex.measure = 2, tol = 0.0000001),
 matrix(rnorm(600), 100),
 P = 2,
 gaussian.loglik,
 loglik.alpha = gaussian.loglik.alpha,
 c("p0", "exp_dbl")
)
preds &lt;- predict(result, matrix(rnorm(600), 100))

</code></pre>

<hr>
<h2 id='predict.gmjmcmc_parallel'>Predict using a gmjmcmc result object from a parallel run.</h2><span id='topic+predict.gmjmcmc_parallel'></span>

<h3>Description</h3>

<p>Predict using a gmjmcmc result object from a parallel run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmjmcmc_parallel'
predict(object, x, link = function(x) x, quantiles = c(0.025, 0.5, 0.975), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.gmjmcmc_parallel_+3A_object">object</code></td>
<td>
<p>The model to use.</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_parallel_+3A_x">x</code></td>
<td>
<p>The new data to use for the prediction, a matrix where each row is an observation.</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_parallel_+3A_link">link</code></td>
<td>
<p>The link function to use</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_parallel_+3A_quantiles">quantiles</code></td>
<td>
<p>The quantiles to calculate credible intervals for the posterior modes (in model space).</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_parallel_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to merge_results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing aggregated predictions and per model predictions.
</p>
<table role = "presentation">
<tr><td><code>aggr</code></td>
<td>
<p>Aggregated predictions with mean and quantiles.</p>
</td></tr>
<tr><td><code>preds</code></td>
<td>
<p>A list of lists containing individual predictions per model per population in object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc.parallel(
 runs = 1,
 cores = 1,
 list(populations = "best", complex.measure = 2, tol = 0.0000001),
 matrix(rnorm(600), 100),
 P = 2,
 gaussian.loglik,
 loglik.alpha = gaussian.loglik.alpha,
 c("p0", "exp_dbl")
)
preds &lt;- predict(result$results, matrix(rnorm(600), 100))

</code></pre>

<hr>
<h2 id='predict.mjmcmc'>Predict using a mjmcmc result object.</h2><span id='topic+predict.mjmcmc'></span>

<h3>Description</h3>

<p>Predict using a mjmcmc result object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjmcmc'
predict(object, x, link = function(x) x, quantiles = c(0.025, 0.5, 0.975), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.mjmcmc_+3A_object">object</code></td>
<td>
<p>The model to use.</p>
</td></tr>
<tr><td><code id="predict.mjmcmc_+3A_x">x</code></td>
<td>
<p>The new data to use for the prediction, a matrix where each row is an observation.</p>
</td></tr>
<tr><td><code id="predict.mjmcmc_+3A_link">link</code></td>
<td>
<p>The link function to use</p>
</td></tr>
<tr><td><code id="predict.mjmcmc_+3A_quantiles">quantiles</code></td>
<td>
<p>The quantiles to calculate credible intervals for the posterior modes (in model space).</p>
</td></tr>
<tr><td><code id="predict.mjmcmc_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing aggregated predictions.
</p>
<table role = "presentation">
<tr><td><code>mean</code></td>
<td>
<p>Mean of aggregated predictions.</p>
</td></tr>
<tr><td><code>quantiles</code></td>
<td>
<p>Quantiles of aggregated predictions.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- mjmcmc(matrix(rnorm(600), 100), gaussian.loglik)
preds &lt;- predict(result, matrix(rnorm(500), 100))

</code></pre>

<hr>
<h2 id='predict.mjmcmc_parallel'>Predict using a mjmcmc result object from a parallel run.</h2><span id='topic+predict.mjmcmc_parallel'></span>

<h3>Description</h3>

<p>Predict using a mjmcmc result object from a parallel run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjmcmc_parallel'
predict(object, x, link = function(x) x, quantiles = c(0.025, 0.5, 0.975), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.mjmcmc_parallel_+3A_object">object</code></td>
<td>
<p>The model to use.</p>
</td></tr>
<tr><td><code id="predict.mjmcmc_parallel_+3A_x">x</code></td>
<td>
<p>The new data to use for the prediction, a matrix where each row is an observation.</p>
</td></tr>
<tr><td><code id="predict.mjmcmc_parallel_+3A_link">link</code></td>
<td>
<p>The link function to use</p>
</td></tr>
<tr><td><code id="predict.mjmcmc_parallel_+3A_quantiles">quantiles</code></td>
<td>
<p>The quantiles to calculate credible intervals for the posterior modes (in model space).</p>
</td></tr>
<tr><td><code id="predict.mjmcmc_parallel_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing aggregated predictions.
</p>
<table role = "presentation">
<tr><td><code>mean</code></td>
<td>
<p>Mean of aggregated predictions.</p>
</td></tr>
<tr><td><code>quantiles</code></td>
<td>
<p>Quantiles of aggregated predictions.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- mjmcmc.parallel(runs = 1, cores = 1, matrix(rnorm(600), 100), gaussian.loglik)
preds &lt;- predict(result, matrix(rnorm(500), 100))

</code></pre>

<hr>
<h2 id='print.feature'>Print method for &quot;feature&quot; class</h2><span id='topic+print.feature'></span>

<h3>Description</h3>

<p>Print method for &quot;feature&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'feature'
print(x, dataset = FALSE, alphas = FALSE, labels = FALSE, round = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.feature_+3A_x">x</code></td>
<td>
<p>An object of class &quot;feature&quot;</p>
</td></tr>
<tr><td><code id="print.feature_+3A_dataset">dataset</code></td>
<td>
<p>Set the regular covariates as columns in a dataset</p>
</td></tr>
<tr><td><code id="print.feature_+3A_alphas">alphas</code></td>
<td>
<p>Print a &quot;?&quot; instead of actual alphas to prepare the output for alpha estimation</p>
</td></tr>
<tr><td><code id="print.feature_+3A_labels">labels</code></td>
<td>
<p>Should the covariates be named, or just referred to as their place in the data.frame.</p>
</td></tr>
<tr><td><code id="print.feature_+3A_round">round</code></td>
<td>
<p>Should numbers be rounded when printing? Default is FALSE, otherwise it can be set to the number of decimal places.</p>
</td></tr>
<tr><td><code id="print.feature_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String representation of a feature
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc(matrix(rnorm(600), 100), P = 2, gaussian.loglik, NULL, c("p0", "exp_dbl"))
print(result$populations[[1]][1])

</code></pre>

<hr>
<h2 id='relu'>ReLu function</h2><span id='topic+relu'></span>

<h3>Description</h3>

<p>ReLu function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relu(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relu_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>max(x,0)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>relu(2)

</code></pre>

<hr>
<h2 id='rmclapply'>rmclapply: Cross-platform mclapply/forking hack for Windows</h2><span id='topic+rmclapply'></span>

<h3>Description</h3>

<p>This function applies a function in parallel to a list or vector (<code>X</code>) using multiple cores.
On Linux/macOS, it uses <code>mclapply</code>, while on Windows it uses a hackish version of parallelism.
The Windows version is based on <code>parLapply</code> to mimic forking following Nathan VanHoudnos.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmclapply(runs, args, fun, mc.cores = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmclapply_+3A_runs">runs</code></td>
<td>
<p>The runs to run</p>
</td></tr>
<tr><td><code id="rmclapply_+3A_args">args</code></td>
<td>
<p>The arguments to pass to fun</p>
</td></tr>
<tr><td><code id="rmclapply_+3A_fun">fun</code></td>
<td>
<p>The function to run</p>
</td></tr>
<tr><td><code id="rmclapply_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Number of cores to use for parallel processing. Defaults to <code>detectCores()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of results, with one element for each element of <code>X</code>.
</p>

<hr>
<h2 id='SangerData2'>Gene expression data lymphoblastoid cell lines of all 210 unrelated HapMap
individuals from four populations</h2><span id='topic+SangerData2'></span>

<h3>Description</h3>

<p>A 210 times 3221 matrix with indviduals along the rows and expression data along the columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SangerData2)
</code></pre>


<h3>Format</h3>

<p>A data frame  with 210 rows and 3221 variables
</p>


<h3>Details</h3>

<p>The first column corresponds to column number 24266 (with name GI_6005726-S) in the original data.
Column names give the name of the variables, row names the &quot;name&quot; of the individuals.
This is a subset of SangerData where the 3220 last rows are select among all original rows following the same
pre-processing procedure as in (section 1.6.1). See also the file  Read_sanger_data.R
</p>


<h3>Source</h3>

<p>Dataset downloaded from
<a href="https://ftp.sanger.ac.uk/pub/genevar/">https://ftp.sanger.ac.uk/pub/genevar/</a>
</p>
<p>References:
</p>
<p>Stranger, BE et al (2007): Relative impact of nucleotide and copy number variation on gene expression phenotypes
Science, 2007science.org
</p>
<p>Bogdan et al (2020): Handbook of Multiple Comparisons, <a href="https://arxiv.org/pdf/2011.12154">https://arxiv.org/pdf/2011.12154</a>
</p>

<hr>
<h2 id='set.transforms'>Set the transformations option for GMJMCMC (Genetically Modified MJMCMC),
this is also done when running the algorithm, but this function allows for it to be done manually.</h2><span id='topic+set.transforms'></span>

<h3>Description</h3>

<p>Set the transformations option for GMJMCMC (Genetically Modified MJMCMC),
this is also done when running the algorithm, but this function allows for it to be done manually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.transforms(transforms)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.transforms_+3A_transforms">transforms</code></td>
<td>
<p>The vector of non-linear transformations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, just sets the gmjmcmc-transformations option
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.transforms(c("p0","p1"))


</code></pre>

<hr>
<h2 id='sigmoid'>Sigmoid function</h2><span id='topic+sigmoid'></span>

<h3>Description</h3>

<p>Sigmoid function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigmoid(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sigmoid_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sigmoid of x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sigmoid(2)


</code></pre>

<hr>
<h2 id='sin_deg'>Sine function for degrees</h2><span id='topic+sin_deg'></span>

<h3>Description</h3>

<p>Sine function for degrees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sin_deg(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sin_deg_+3A_x">x</code></td>
<td>
<p>The vector of values in degrees</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sine of x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sin_deg(0)

</code></pre>

<hr>
<h2 id='sqroot'>Square root function</h2><span id='topic+sqroot'></span>

<h3>Description</h3>

<p>Square root function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqroot(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sqroot_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The square root of the absolute value of x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sqroot(4)

</code></pre>

<hr>
<h2 id='string.population'>Function to get a character representation of a list of features</h2><span id='topic+string.population'></span>

<h3>Description</h3>

<p>Function to get a character representation of a list of features
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string.population(x, round = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="string.population_+3A_x">x</code></td>
<td>
<p>A list of feature objects</p>
</td></tr>
<tr><td><code id="string.population_+3A_round">round</code></td>
<td>
<p>Rounding precision for parameters of the features</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of character representations of the features of a model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc(matrix(rnorm(600), 100), P = 2, gaussian.loglik, NULL, c("p0", "exp_dbl"))
string.population(result$populations[[1]])

</code></pre>

<hr>
<h2 id='string.population.models'>Function to get a character representation of a list of models</h2><span id='topic+string.population.models'></span>

<h3>Description</h3>

<p>Function to get a character representation of a list of models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string.population.models(features, models, round = 2, link = "I")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="string.population.models_+3A_features">features</code></td>
<td>
<p>A list of feature objects on which the models are build</p>
</td></tr>
<tr><td><code id="string.population.models_+3A_models">models</code></td>
<td>
<p>A list of model objects</p>
</td></tr>
<tr><td><code id="string.population.models_+3A_round">round</code></td>
<td>
<p>Rounding precision for parameters of the features</p>
</td></tr>
<tr><td><code id="string.population.models_+3A_link">link</code></td>
<td>
<p>The link function to use, as a string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of character representations of a list of models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc(matrix(rnorm(600), 100), P = 2, gaussian.loglik, NULL, c("p0", "exp_dbl"))
string.population.models(result$populations[[2]], result$models[[2]])

</code></pre>

<hr>
<h2 id='summary.gmjmcmc'>Function to print a quick summary of the results</h2><span id='topic+summary.gmjmcmc'></span>

<h3>Description</h3>

<p>Function to print a quick summary of the results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmjmcmc'
summary(
  object,
  pop = "best",
  tol = 1e-04,
  labels = FALSE,
  effects = NULL,
  data = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.gmjmcmc_+3A_object">object</code></td>
<td>
<p>The results to use</p>
</td></tr>
<tr><td><code id="summary.gmjmcmc_+3A_pop">pop</code></td>
<td>
<p>The population to print for, defaults to last</p>
</td></tr>
<tr><td><code id="summary.gmjmcmc_+3A_tol">tol</code></td>
<td>
<p>The tolerance to use as a threshold when reporting the results.</p>
</td></tr>
<tr><td><code id="summary.gmjmcmc_+3A_labels">labels</code></td>
<td>
<p>Should the covariates be named, or just referred to as their place in the data.frame.</p>
</td></tr>
<tr><td><code id="summary.gmjmcmc_+3A_effects">effects</code></td>
<td>
<p>Quantiles for posterior modes of the effects across models to be reported, if either effects are NULL or if labels are NULL, no effects are reported.</p>
</td></tr>
<tr><td><code id="summary.gmjmcmc_+3A_data">data</code></td>
<td>
<p>Data to merge on, important if pre-filtering was used</p>
</td></tr>
<tr><td><code id="summary.gmjmcmc_+3A_verbose">verbose</code></td>
<td>
<p>If the summary should be printed to the console or just returned, defaults to TRUE</p>
</td></tr>
<tr><td><code id="summary.gmjmcmc_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the following columns:
</p>
<table role = "presentation">
<tr><td><code>feats.strings</code></td>
<td>
<p>Character representation of the features ordered by marginal probabilities.</p>
</td></tr>
<tr><td><code>marg.probs</code></td>
<td>
<p>Marginal probabilities corresponding to the ordered feature strings.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc(matrix(rnorm(600), 100), P = 2, gaussian.loglik, NULL, c("p0", "exp_dbl"))
summary(result, pop = "best")

</code></pre>

<hr>
<h2 id='summary.gmjmcmc_merged'>Function to print a quick summary of the results</h2><span id='topic+summary.gmjmcmc_merged'></span>

<h3>Description</h3>

<p>Function to print a quick summary of the results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmjmcmc_merged'
summary(
  object,
  tol = 1e-04,
  labels = FALSE,
  effects = NULL,
  pop = NULL,
  data = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.gmjmcmc_merged_+3A_object">object</code></td>
<td>
<p>The results to use</p>
</td></tr>
<tr><td><code id="summary.gmjmcmc_merged_+3A_tol">tol</code></td>
<td>
<p>The tolerance to use as a threshold when reporting the results.</p>
</td></tr>
<tr><td><code id="summary.gmjmcmc_merged_+3A_labels">labels</code></td>
<td>
<p>Should the covariates be named, or just referred to as their place in the data.frame.</p>
</td></tr>
<tr><td><code id="summary.gmjmcmc_merged_+3A_effects">effects</code></td>
<td>
<p>Quantiles for posterior modes of the effects across models to be reported, if either effects are NULL or if labels are NULL, no effects are reported.</p>
</td></tr>
<tr><td><code id="summary.gmjmcmc_merged_+3A_pop">pop</code></td>
<td>
<p>If null same as in merge.options for running parallel gmjmcmc otherwise results will be re-merged according to pop that can be &quot;all&quot;, &quot;last&quot;, &quot;best&quot;</p>
</td></tr>
<tr><td><code id="summary.gmjmcmc_merged_+3A_data">data</code></td>
<td>
<p>Data to merge on, important if pre-filtering was used</p>
</td></tr>
<tr><td><code id="summary.gmjmcmc_merged_+3A_verbose">verbose</code></td>
<td>
<p>If the summary should be printed to the console or just returned, defaults to TRUE</p>
</td></tr>
<tr><td><code id="summary.gmjmcmc_merged_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the following columns:
</p>
<table role = "presentation">
<tr><td><code>feats.strings</code></td>
<td>
<p>Character representation of the features ordered by marginal probabilities.</p>
</td></tr>
<tr><td><code>marg.probs</code></td>
<td>
<p>Marginal probabilities corresponding to the ordered feature strings.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc.parallel(
 runs = 1,
 cores = 1,
 list(populations = "best", complex.measure = 2, tol = 0.0000001),
 matrix(rnorm(600), 100),
 P = 2,
 gaussian.loglik,
 loglik.alpha = gaussian.loglik.alpha,
 c("p0", "exp_dbl")
)
summary(result)

</code></pre>

<hr>
<h2 id='summary.mjmcmc'>Function to print a quick summary of the results</h2><span id='topic+summary.mjmcmc'></span>

<h3>Description</h3>

<p>Function to print a quick summary of the results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjmcmc'
summary(
  object,
  tol = 1e-04,
  labels = FALSE,
  effects = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.mjmcmc_+3A_object">object</code></td>
<td>
<p>The results to use</p>
</td></tr>
<tr><td><code id="summary.mjmcmc_+3A_tol">tol</code></td>
<td>
<p>The tolerance to use as a threshold when reporting the results.</p>
</td></tr>
<tr><td><code id="summary.mjmcmc_+3A_labels">labels</code></td>
<td>
<p>Should the covariates be named, or just referred to as their place in the data.frame.</p>
</td></tr>
<tr><td><code id="summary.mjmcmc_+3A_effects">effects</code></td>
<td>
<p>Quantiles for posterior modes of the effects across models to be reported, if either effects are NULL or if labels are NULL, no effects are reported.</p>
</td></tr>
<tr><td><code id="summary.mjmcmc_+3A_verbose">verbose</code></td>
<td>
<p>If the summary should be printed to the console or just returned, defaults to TRUE</p>
</td></tr>
<tr><td><code id="summary.mjmcmc_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the following columns:
</p>
<table role = "presentation">
<tr><td><code>feats.strings</code></td>
<td>
<p>Character representation of the covariates ordered by marginal probabilities.</p>
</td></tr>
<tr><td><code>marg.probs</code></td>
<td>
<p>Marginal probabilities corresponding to the ordered feature strings.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- mjmcmc(matrix(rnorm(600), 100), gaussian.loglik)
summary(result)

</code></pre>

<hr>
<h2 id='summary.mjmcmc_parallel'>Function to print a quick summary of the results</h2><span id='topic+summary.mjmcmc_parallel'></span>

<h3>Description</h3>

<p>Function to print a quick summary of the results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjmcmc_parallel'
summary(
  object,
  tol = 1e-04,
  labels = FALSE,
  effects = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.mjmcmc_parallel_+3A_object">object</code></td>
<td>
<p>The results to use</p>
</td></tr>
<tr><td><code id="summary.mjmcmc_parallel_+3A_tol">tol</code></td>
<td>
<p>The tolerance to use as a threshold when reporting the results.</p>
</td></tr>
<tr><td><code id="summary.mjmcmc_parallel_+3A_labels">labels</code></td>
<td>
<p>Should the covariates be named, or just referred to as their place in the data.frame.</p>
</td></tr>
<tr><td><code id="summary.mjmcmc_parallel_+3A_effects">effects</code></td>
<td>
<p>Quantiles for posterior modes of the effects across models to be reported, if either effects are NULL or if labels are NULL, no effects are reported.</p>
</td></tr>
<tr><td><code id="summary.mjmcmc_parallel_+3A_verbose">verbose</code></td>
<td>
<p>If the summary should be printed to the console or just returned, defaults to TRUE</p>
</td></tr>
<tr><td><code id="summary.mjmcmc_parallel_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the following columns:
</p>
<table role = "presentation">
<tr><td><code>feats.strings</code></td>
<td>
<p>Character representation of the covariates ordered by marginal probabilities.</p>
</td></tr>
<tr><td><code>marg.probs</code></td>
<td>
<p>Marginal probabilities corresponding to the ordered feature strings.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- mjmcmc.parallel(runs = 1, cores = 1, matrix(rnorm(600), 100), gaussian.loglik)
summary(result)

</code></pre>

<hr>
<h2 id='to23'>To the 2.3  power function</h2><span id='topic+to23'></span>

<h3>Description</h3>

<p>To the 2.3  power function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to23(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to23_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x^2.3
</p>


<h3>Examples</h3>

<pre><code class='language-R'>to23(2)

</code></pre>

<hr>
<h2 id='to25'>To 2.5 power</h2><span id='topic+to25'></span>

<h3>Description</h3>

<p>To 2.5 power
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to25(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to25_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x^(2.5)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>to25(2)

</code></pre>

<hr>
<h2 id='to35'>To 3.5 power</h2><span id='topic+to35'></span>

<h3>Description</h3>

<p>To 3.5 power
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to35(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to35_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x^(3.5)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>to35(2)

</code></pre>

<hr>
<h2 id='to72'>To the 7/2  power function</h2><span id='topic+to72'></span>

<h3>Description</h3>

<p>To the 7/2  power function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to72(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to72_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x^(7/2)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>to72(2)

</code></pre>

<hr>
<h2 id='troot'>Cube root function</h2><span id='topic+troot'></span>

<h3>Description</h3>

<p>Cube root function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>troot(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="troot_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cube root of x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>troot(27)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
