<!DOCTYPE html><html><head><title>Help for package FBMS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FBMS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#breastcancer'><p>Breast Cancer Wisconsin (Diagnostic) Data Set</p></a></li>
<li><a href='#compute_effects'><p>Compute effects for specified in labels covariates using a fitted model.</p></a></li>
<li><a href='#cos_deg'><p>Cosine function for degrees</p></a></li>
<li><a href='#diagn_plot'><p>Plot convergence of best/median/mean/other summary log posteriors in time</p></a></li>
<li><a href='#erf'><p>erf function</p></a></li>
<li><a href='#exoplanet'><p>Excerpt from the Open Exoplanet Catalogue data set</p></a></li>
<li><a href='#exp_dbl'><p>Double exponential function</p></a></li>
<li><a href='#fbms'><p>Fit a BGNLM  model using Genetically Modified Mode Jumping Markov Chain Monte Carlo (MCMC) sampling.</p>
Or Fit a BGLM model using Modified Mode Jumping Markov Chain Monte Carlo (MCMC) sampling.</a></li>
<li><a href='#FBMS-package'>
<p>Flexible Bayesian Model Selection and Model Averaging</p></a></li>
<li><a href='#gauss'><p>Gaussian function</p></a></li>
<li><a href='#gaussian.loglik'><p>Log likelihood function for gaussian regression with a prior p(m)=r*sum(total_width).</p></a></li>
<li><a href='#gaussian.loglik.alpha'><p>Log likelihood function for gaussian regression for alpha calculation</p>
This function is just the bare likelihood function
Note that it only gives a proportional value and is equivalent to least squares</a></li>
<li><a href='#gelu'><p>GELU function</p></a></li>
<li><a href='#gen.params.gmjmcmc'><p>Generate a parameter list for GMJMCMC (Genetically Modified MJMCMC)</p></a></li>
<li><a href='#gen.params.mjmcmc'><p>Generate a parameter list for MJMCMC (Mode Jumping MCMC)</p></a></li>
<li><a href='#gen.probs.gmjmcmc'><p>Generate a probability list for GMJMCMC (Genetically Modified MJMCMC)</p></a></li>
<li><a href='#gen.probs.mjmcmc'><p>Generate a probability list for MJMCMC (Mode Jumping MCMC)</p></a></li>
<li><a href='#gmjmcmc'><p>Main algorithm for GMJMCMC (Genetically Modified MJMCMC)</p></a></li>
<li><a href='#gmjmcmc.parallel'><p>Run multiple gmjmcmc (Genetically Modified MJMCMC) runs in parallel returning a list of all results.</p></a></li>
<li><a href='#hs'><p>heavy side function</p></a></li>
<li><a href='#linear.g.prior.loglik'><p>Log likelihood function for linear regression using Zellners g-prior</p></a></li>
<li><a href='#logistic.loglik'><p>Log likelihood function for logistic regression with a prior p(m)=sum(total_width)</p>
This function is created as an example of how to create an estimator that is used
to calculate the marginal likelihood of a model.</a></li>
<li><a href='#logistic.loglik.alpha'><p>Log likelihood function for logistic regression for alpha calculation</p>
This function is just the bare likelihood function</a></li>
<li><a href='#marginal.probs'><p>Function for calculating marginal inclusion probabilities of features given a list of models</p></a></li>
<li><a href='#merge_results'><p>Merge a list of multiple results from many runs</p>
This function will weight the features based on the best mlik in that population
and merge the results together, simplifying by merging equivalent features (having high correlation).</a></li>
<li><a href='#mjmcmc'><p>Main algorithm for MJMCMC (Genetically Modified MJMCMC)</p></a></li>
<li><a href='#mjmcmc.parallel'><p>Run multiple mjmcmc runs in parallel, merging the results before returning.</p></a></li>
<li><a href='#model.string'><p>Function to generate a function string for a model consisting of features</p></a></li>
<li><a href='#ngelu'><p>Negative GELU function</p></a></li>
<li><a href='#nhs'><p>negative heavy side function</p></a></li>
<li><a href='#not'><p>not x</p></a></li>
<li><a href='#nrelu'><p>negative ReLu function</p></a></li>
<li><a href='#p0'><p>p0 polynomial term</p></a></li>
<li><a href='#p05'><p>p05 polynomial term</p></a></li>
<li><a href='#p0p0'><p>p0p0 polynomial term</p></a></li>
<li><a href='#p0p05'><p>p0p05 polynomial term</p></a></li>
<li><a href='#p0p1'><p>p0p1 polynomial term</p></a></li>
<li><a href='#p0p2'><p>p0p2 polynomial term</p></a></li>
<li><a href='#p0p3'><p>p0p3 polynomial term</p></a></li>
<li><a href='#p0pm05'><p>p0pm05 polynomial term</p></a></li>
<li><a href='#p0pm1'><p>p0pm1 polynomial terms</p></a></li>
<li><a href='#p0pm2'><p>p0pm2 polynomial term</p></a></li>
<li><a href='#p2'><p>p2 polynomial term</p></a></li>
<li><a href='#p3'><p>p3 polynomial term</p></a></li>
<li><a href='#plot.gmjmcmc'><p>Function to plot the results, works both for results from gmjmcmc and</p>
merged results from merge.results</a></li>
<li><a href='#plot.gmjmcmc_merged'><p>Plot a gmjmcmc_merged run</p></a></li>
<li><a href='#plot.mjmcmc'><p>Function to plot the results, works both for results from gmjmcmc and</p>
merged results from merge.results</a></li>
<li><a href='#plot.mjmcmc_parallel'><p>Plot a mjmcmc_parallel run</p></a></li>
<li><a href='#pm05'><p>pm05 polynomial term</p></a></li>
<li><a href='#pm1'><p>pm1 polynomial term</p></a></li>
<li><a href='#pm2'><p>pm2 polynomial term</p></a></li>
<li><a href='#predict.gmjmcmc'><p>Predict using a gmjmcmc result object.</p></a></li>
<li><a href='#predict.gmjmcmc_merged'><p>Predict using a merged gmjmcmc result object.</p></a></li>
<li><a href='#predict.gmjmcmc_parallel'><p>Predict using a gmjmcmc result object from a parallel run.</p></a></li>
<li><a href='#predict.mjmcmc'><p>Predict using a mjmcmc result object.</p></a></li>
<li><a href='#predict.mjmcmc_parallel'><p>Predict using a mjmcmc result object from a parallel run.</p></a></li>
<li><a href='#print.feature'><p>Print method for &quot;feature&quot; class</p></a></li>
<li><a href='#relu'><p>ReLu function</p></a></li>
<li><a href='#set.transforms'><p>Set the transformations option for GMJMCMC (Genetically Modified MJMCMC),</p>
this is also done when running the algorithm, but this function allows for it to be done manually.</a></li>
<li><a href='#sigmoid'><p>Sigmoid function</p></a></li>
<li><a href='#sin_deg'><p>Sine function for degrees</p></a></li>
<li><a href='#sqroot'><p>Square root function</p></a></li>
<li><a href='#string.population'><p>Function to get a character respresentation of a list of features</p></a></li>
<li><a href='#string.population.models'><p>Function to get a character respresentation of a list of models</p></a></li>
<li><a href='#summary.gmjmcmc'><p>Function to print a quick summary of the results</p></a></li>
<li><a href='#summary.gmjmcmc_merged'><p>Function to print a quick summary of the results</p></a></li>
<li><a href='#summary.mjmcmc'><p>Function to print a quick summary of the results</p></a></li>
<li><a href='#summary.mjmcmc_parallel'><p>Function to print a quick summary of the results</p></a></li>
<li><a href='#to23'><p>To the 2.3  power function</p></a></li>
<li><a href='#to25'><p>To 2.5 power</p></a></li>
<li><a href='#to35'><p>To 3.5 power</p></a></li>
<li><a href='#to72'><p>To the 7/2  power function</p></a></li>
<li><a href='#troot'><p>Cube root function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Flexible Bayesian Model Selection and Model Averaging</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-20</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements MJMCMC (mode jumping MCMC) described in Hubin and Storvik (2018) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2018.05.020">doi:10.1016/j.csda.2018.05.020</a>&gt; and GMJMCMC (genetically modified MJMCMC) described in Hubin et al. (2021) &lt;<a href="https://doi.org/10.1613%2Fjair.1.13047">doi:10.1613/jair.1.13047</a>&gt; algorithms as well as the subsampling counterpart described in Lachmann et al. (2022) &lt;<a href="https://doi.org/10.1016%2Fj.ijar.2022.08.018">doi:10.1016/j.ijar.2022.08.018</a>&gt; for flexible Bayesian model selection and model averaging.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), fastglm, GenSA, parallel, stats, graphics</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, markdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-20 15:39:57 UTC; jonlachmann</td>
</tr>
<tr>
<td>Author:</td>
<td>Jon Lachmann [cre, aut],
  Aliaksandr Hubin [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jon Lachmann &lt;jon@lachmann.nu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-21 16:30:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='breastcancer'>Breast Cancer Wisconsin (Diagnostic) Data Set</h2><span id='topic+breastcancer'></span>

<h3>Description</h3>

<p>Features are computed from a digitized image of a fine needle aspirate (FNA) of a breast mass.
They describe characteristics of the cell nuclei present in the image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(breastcancer)
</code></pre>


<h3>Format</h3>

<p>A data frame with 569 rows and 32 variables
</p>


<h3>Details</h3>

<p>Separating plane described above was obtained using Multisurface Method-Tree (MSM-T)
(K. P. Bennett, &quot;Decision Tree Construction Via Linear Programming.&quot; Proceedings of the 4th Midwest Artificial
Intelligence and Cognitive Science Society, pp. 97-101, 1992), a classification method which uses linear programming to
construct a decision tree. Relevant features were selected using an exhaustive search in the space of 1-4 features
and 1-3 separating planes.
</p>
<p>The actual linear program used to obtain the separating plane in the 3-dimensional space is that described in:
(K. P. Bennett and O. L. Mangasarian: &quot;Robust Linear Programming Discrimination of Two Linearly Inseparable Sets&quot;,
Optimization Methods and Software 1, 1992, 23-34).
</p>
<p>The variables are as follows:
</p>

<ul>
<li><p> ID number
</p>
</li>
<li><p> Diagnosis (1 = malignant, 0 = benign)
</p>
</li>
<li><p> Ten real-valued features are computed for each cell nucleus
</p>
</li></ul>



<h3>Source</h3>

<p>Dataset downloaded from the UCI Machine Learning Repository.
<a href="http://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Wisconsin+(Diagnostic)">http://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Wisconsin+(Diagnostic)</a>
</p>
<p>Creators:
</p>

<ol>
<li><p> Dr. William H. Wolberg, General Surgery Dept.
University of Wisconsin, Clinical Sciences Center
Madison, WI 53792
wolberg 'at' eagle.surgery.wisc.edu
</p>
</li>
<li><p> W. Nick Street, Computer Sciences Dept.
University of Wisconsin, 1210 West Dayton St., Madison, WI 53706
street 'at' cs.wisc.edu 608-262-6619
</p>
</li>
<li><p> Olvi L. Mangasarian, Computer Sciences Dept.
University of Wisconsin, 1210 West Dayton St., Madison, WI 53706
olvi 'at' cs.wisc.edu
</p>
</li></ol>

<p>Donor: Nick Street
</p>


<h3>References</h3>

<p>W.N. Street, W.H. Wolberg and O.L. Mangasarian. Nuclear feature extraction for breast tumor diagnosis.
IS&amp;T/SPIE 1993 International Symposium on Electronic Imaging: Science and Technology, volume 1905, pages 861-870, San Jose, CA, 1993.
</p>
<p>Lichman, M. (2013). UCI Machine Learning Repository <a href="http://archive.ics.uci.edu/ml">http://archive.ics.uci.edu/ml</a>.
Irvine, CA: University of California, School of Information and Computer Science.
</p>

<hr>
<h2 id='compute_effects'>Compute effects for specified in labels covariates using a fitted model.</h2><span id='topic+compute_effects'></span>

<h3>Description</h3>

<p>This function computes model averaged effects for specified covariates using a fitted model object.
The effects are expected change in the BMA linear predictor having an increase of the corresponding covariate by one unit, while other covariates are fixed to 0.
Users can provide custom labels and specify quantiles for the computation of effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_effects(object, labels, quantiles = c(0.025, 0.5, 0.975))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_effects_+3A_object">object</code></td>
<td>
<p>A fitted model object, typically the result of a regression or predictive modeling.</p>
</td></tr>
<tr><td><code id="compute_effects_+3A_labels">labels</code></td>
<td>
<p>A vector of labels for which effects are to be computed.</p>
</td></tr>
<tr><td><code id="compute_effects_+3A_quantiles">quantiles</code></td>
<td>
<p>A numeric vector specifying the quantiles to be calculated. Default is c(0.025, 0.5, 0.975).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of treatment effects for the specified labels, with rows corresponding to labels and columns to quantiles.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict">predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- data.frame(matrix(rnorm(600), 100))
result &lt;- mjmcmc.parallel(runs = 2, cores = 1, data, gaussian.loglik)
compute_effects(result,labels = names(data)[-1])

</code></pre>

<hr>
<h2 id='cos_deg'>Cosine function for degrees</h2><span id='topic+cos_deg'></span>

<h3>Description</h3>

<p>Cosine function for degrees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cos_deg(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cos_deg_+3A_x">x</code></td>
<td>
<p>The vector of values in degrees</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cosine of x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cos_deg(0)

</code></pre>

<hr>
<h2 id='diagn_plot'>Plot convergence of best/median/mean/other summary log posteriors in time</h2><span id='topic+diagn_plot'></span>

<h3>Description</h3>

<p>Plot convergence of best/median/mean/other summary log posteriors in time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagn_plot(res, FUN = median, conf = 0.95, burnin = 0, window = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagn_plot_+3A_res">res</code></td>
<td>
<p>Object corresponding gmjmcmc output</p>
</td></tr>
<tr><td><code id="diagn_plot_+3A_fun">FUN</code></td>
<td>
<p>The summary statistics to check convergence</p>
</td></tr>
<tr><td><code id="diagn_plot_+3A_conf">conf</code></td>
<td>
<p>which confidence intervals to plot</p>
</td></tr>
<tr><td><code id="diagn_plot_+3A_burnin">burnin</code></td>
<td>
<p>how many first populations to skip</p>
</td></tr>
<tr><td><code id="diagn_plot_+3A_window">window</code></td>
<td>
<p>sliding window for computing the standard deviation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of summary statistics for checking convergence with given confidence intervals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc(matrix(rnorm(600), 100), P = 2, gaussian.loglik, NULL, c("p0", "exp_dbl"))
diagnstats &lt;- diagn_plot(result)

</code></pre>

<hr>
<h2 id='erf'>erf function</h2><span id='topic+erf'></span>

<h3>Description</h3>

<p>erf function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>erf(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="erf_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>2 * pnorm(x * sqrt(2)) - 1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>erf(2)

</code></pre>

<hr>
<h2 id='exoplanet'>Excerpt from the Open Exoplanet Catalogue data set</h2><span id='topic+exoplanet'></span>

<h3>Description</h3>

<p>Data fields include planet and host star attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(exoplanet)
</code></pre>


<h3>Format</h3>

<p>A data frame with 223 rows and 11 variables
</p>


<h3>Details</h3>

<p>The variables are as follows:
</p>

<ul>
<li><p> TypeFlag: Flag indicating the type of data
</p>
</li>
<li><p> PlanetaryMassJpt: Mass of the planetary object in Jupiter masses
</p>
</li>
<li><p> RadiusJpt: Radius of the planetary object in Jupiter radii
</p>
</li>
<li><p> PeriodDays: Orbital period of the planetary object in days
</p>
</li>
<li><p> SemiMajorAxisAU: Semi-major axis of the planetary object's orbit in astronomical units
</p>
</li>
<li><p> Eccentricity: Eccentricity of the planetary object's orbit
</p>
</li>
<li><p> HostStarMassSlrMass: Mass of the host star in solar masses
</p>
</li>
<li><p> HostStarRadiusSlrRad: Radius of the host star in solar radii
</p>
</li>
<li><p> HostStarMetallicity: Metallicity of the host star
</p>
</li>
<li><p> HostStarTempK: Effective temperature of the host star in Kelvin
</p>
</li>
<li><p> PlanetaryDensJpt: Density of the planetary object up to a constant
</p>
</li></ul>



<h3>Source</h3>

<p>Dataset downloaded from the Open Exoplanet Catalogue Repository.
<a href="https://github.com/OpenExoplanetCatalogue/oec_tables/">https://github.com/OpenExoplanetCatalogue/oec_tables/</a>
</p>
<p>Creators:
</p>

<ol>
<li><p> Prof. Hanno Rein, Department for Physical and Environmental Sciences.
University of Toronto at Scarborough
Toronto, Ontario M1C 1A4
hanno.rein 'at' utoronto.ca
</p>
</li></ol>


<hr>
<h2 id='exp_dbl'>Double exponential function</h2><span id='topic+exp_dbl'></span>

<h3>Description</h3>

<p>Double exponential function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exp_dbl(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exp_dbl_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>e^(-abs(x))
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp_dbl(2)

</code></pre>

<hr>
<h2 id='fbms'>Fit a BGNLM  model using Genetically Modified Mode Jumping Markov Chain Monte Carlo (MCMC) sampling.
Or Fit a BGLM model using Modified Mode Jumping Markov Chain Monte Carlo (MCMC) sampling.</h2><span id='topic+fbms'></span>

<h3>Description</h3>

<p>This function fits a model using the relevant MCMC sampling. The user can specify the formula,
family, data, transforms, and other parameters to customize the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbms(
  formula = NULL,
  family = "gaussian",
  data = NULL,
  transforms = NULL,
  loglik.pi = gaussian.loglik,
  loglik.alpha = gaussian.loglik.alpha,
  P = 10,
  runs = 10,
  cores = 1,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fbms_+3A_formula">formula</code></td>
<td>
<p>A formula object specifying the model structure. Default is NULL.</p>
</td></tr>
<tr><td><code id="fbms_+3A_family">family</code></td>
<td>
<p>The distribution family of the response variable. Currently supports &quot;gaussian&quot; and &quot;binomial&quot;. Default is &quot;gaussian&quot;.</p>
</td></tr>
<tr><td><code id="fbms_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the model. If NULL, the variables are taken from the environment of the formula. Default is NULL.</p>
</td></tr>
<tr><td><code id="fbms_+3A_transforms">transforms</code></td>
<td>
<p>A list of transformations for BGNLM model. Default is NULL.</p>
</td></tr>
<tr><td><code id="fbms_+3A_loglik.pi">loglik.pi</code></td>
<td>
<p>The log-likelihood function for estimating the marginal likelihood and posterior modes (only used if family = &quot;custom&quot;)</p>
</td></tr>
<tr><td><code id="fbms_+3A_loglik.alpha">loglik.alpha</code></td>
<td>
<p>The log-likelihood function for the alpha parameter in the model. Default is gaussian.loglik.alpha.</p>
</td></tr>
<tr><td><code id="fbms_+3A_p">P</code></td>
<td>
<p>The number of GMJMCMC generations. Default is 10.</p>
</td></tr>
<tr><td><code id="fbms_+3A_runs">runs</code></td>
<td>
<p>The number of parallel chains in case of parallel processing. Default is 2.</p>
</td></tr>
<tr><td><code id="fbms_+3A_cores">cores</code></td>
<td>
<p>The number of CPU cores to use for parallel processing. Default is 2.</p>
</td></tr>
<tr><td><code id="fbms_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, print detailed progress information during the fitting process. Default is FALSE.</p>
</td></tr>
<tr><td><code id="fbms_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to the underlying MCMC fitting functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object containing the results of the fitted model and MCMC sampling.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mjmcmc">mjmcmc</a></code>, <code><a href="#topic+gmjmcmc">gmjmcmc</a></code>, <code><a href="#topic+gmjmcmc.parallel">gmjmcmc.parallel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fit a Gaussian multivariate time series model
fbms_result &lt;- fbms(
 X1 ~ .,
 family = "gaussian",
 data = data.frame(matrix(rnorm(600), 100)),
 P = 10,
 runs = 1,
 cores = 1
)
summary(fbms_result)
plot(fbms_result)


</code></pre>

<hr>
<h2 id='FBMS-package'>
Flexible Bayesian Model Selection and Model Averaging
</h2><span id='topic+FBMS-package'></span><span id='topic+FBMS'></span>

<h3>Description</h3>

<p>Implements MJMCMC (mode jumping MCMC) described in Hubin and Storvik (2018) &lt;doi:10.1016/j.csda.2018.05.020&gt; and GMJMCMC (genetically modified MJMCMC) described in Hubin et al. (2021) &lt;doi:10.1613/jair.1.13047&gt; algorithms as well as the subsampling counterpart described in Lachmann et al. (2022) &lt;doi:10.1016/j.ijar.2022.08.018&gt; for flexible Bayesian model selection and model averaging.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jon Lachmann <a href="mailto:jon@lachmann.nu">jon@lachmann.nu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Jon Lachmann <a href="mailto:jon@lachmann.nu">jon@lachmann.nu</a>
</p>
</li>
<li><p> Aliaksandr Hubin <a href="mailto:aliaksah@math.uio.no">aliaksah@math.uio.no</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Florian Frommlet <a href="mailto:florian.frommlet@meduniwien.ac.at">florian.frommlet@meduniwien.ac.at</a> [contributor]
</p>
</li>
<li><p> Geir Storvik <a href="mailto:geirs@math.uio.no">geirs@math.uio.no</a> [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Lachmann, J., Storvik, G., Frommlet, F., &amp; Hubin, A. (2022).
A subsampling approach for Bayesian model selection.
International Journal of Approximate Reasoning, 151, 33-63. Elsevier.
</p>
<p>Hubin, A., Storvik, G., &amp; Frommlet, F. (2021).
Flexible Bayesian Nonlinear Model Configuration.
Journal of Artificial Intelligence Research, 72, 901-942.
</p>
<p>Hubin, A., Frommlet, F., &amp; Storvik, G. (2021).
Reversible Genetically Modified MJMCMC.
Under review in EYSM 2021.
</p>
<p>Hubin, A., &amp; Storvik, G. (2018).
Mode jumping MCMC for Bayesian variable selection in GLMM.
Computational Statistics &amp; Data Analysis, 127, 281-297. Elsevier.
</p>

<hr>
<h2 id='gauss'>Gaussian function</h2><span id='topic+gauss'></span>

<h3>Description</h3>

<p>Gaussian function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gauss(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gauss_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>e^(-x^2)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gauss(2)

</code></pre>

<hr>
<h2 id='gaussian.loglik'>Log likelihood function for gaussian regression with a prior p(m)=r*sum(total_width).</h2><span id='topic+gaussian.loglik'></span>

<h3>Description</h3>

<p>Log likelihood function for gaussian regression with a prior p(m)=r*sum(total_width).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian.loglik(y, x, model, complex, params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussian.loglik_+3A_y">y</code></td>
<td>
<p>A vector containing the dependent variable</p>
</td></tr>
<tr><td><code id="gaussian.loglik_+3A_x">x</code></td>
<td>
<p>The matrix containing the precalculated features</p>
</td></tr>
<tr><td><code id="gaussian.loglik_+3A_model">model</code></td>
<td>
<p>The model to estimate as a logical vector</p>
</td></tr>
<tr><td><code id="gaussian.loglik_+3A_complex">complex</code></td>
<td>
<p>A list of complexity measures for the features</p>
</td></tr>
<tr><td><code id="gaussian.loglik_+3A_params">params</code></td>
<td>
<p>A list of parameters for the log likelihood, supplied by the user</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the log marginal likelihood combined with the log prior (crit) and the posterior mode of the coefficients (coefs).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gaussian.loglik(rnorm(100), matrix(rnorm(100)), TRUE, list(oc = 1), NULL)
  

</code></pre>

<hr>
<h2 id='gaussian.loglik.alpha'>Log likelihood function for gaussian regression for alpha calculation
This function is just the bare likelihood function
Note that it only gives a proportional value and is equivalent to least squares</h2><span id='topic+gaussian.loglik.alpha'></span>

<h3>Description</h3>

<p>Log likelihood function for gaussian regression for alpha calculation
This function is just the bare likelihood function
Note that it only gives a proportional value and is equivalent to least squares
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian.loglik.alpha(a, data, mu_func)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussian.loglik.alpha_+3A_a">a</code></td>
<td>
<p>A vector of the alphas to be used</p>
</td></tr>
<tr><td><code id="gaussian.loglik.alpha_+3A_data">data</code></td>
<td>
<p>The data to be used for calculation</p>
</td></tr>
<tr><td><code id="gaussian.loglik.alpha_+3A_mu_func">mu_func</code></td>
<td>
<p>The function linking the mean to the covariates,
as a string with the alphas as a[i].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric with the log likelihood.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gaussian.loglik.alpha(1, matrix(rnorm(100), 50), "a * data[, 2]")

</code></pre>

<hr>
<h2 id='gelu'>GELU function</h2><span id='topic+gelu'></span>

<h3>Description</h3>

<p>GELU function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gelu(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gelu_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x*pnorm(x)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gelu(2)

</code></pre>

<hr>
<h2 id='gen.params.gmjmcmc'>Generate a parameter list for GMJMCMC (Genetically Modified MJMCMC)</h2><span id='topic+gen.params.gmjmcmc'></span>

<h3>Description</h3>

<p>Generate a parameter list for GMJMCMC (Genetically Modified MJMCMC)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.params.gmjmcmc(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.params.gmjmcmc_+3A_data">data</code></td>
<td>
<p>The dataset that will be used in the algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of parameters to use when running the mjmcmc function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gen.params.gmjmcmc(matrix(rnorm(600), 100))


</code></pre>

<hr>
<h2 id='gen.params.mjmcmc'>Generate a parameter list for MJMCMC (Mode Jumping MCMC)</h2><span id='topic+gen.params.mjmcmc'></span>

<h3>Description</h3>

<p>Generate a parameter list for MJMCMC (Mode Jumping MCMC)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.params.mjmcmc(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.params.mjmcmc_+3A_data">data</code></td>
<td>
<p>The dataset that will be used in the algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of parameters to use when running the mjmcmc function.
</p>
<p>Note that the $loglik item is an empty list, which is passed to the log likelihood function of the model,
intended to store parameters that the estimator function should use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gen.params.mjmcmc(matrix(rnorm(600), 100))


</code></pre>

<hr>
<h2 id='gen.probs.gmjmcmc'>Generate a probability list for GMJMCMC (Genetically Modified MJMCMC)</h2><span id='topic+gen.probs.gmjmcmc'></span>

<h3>Description</h3>

<p>Generate a probability list for GMJMCMC (Genetically Modified MJMCMC)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.probs.gmjmcmc(transforms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.probs.gmjmcmc_+3A_transforms">transforms</code></td>
<td>
<p>A list of the transformations used (to get the count).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of probabilities to be used as input for the gmjmcmc function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gen.probs.gmjmcmc(c("p0", "exp_dbl"))


</code></pre>

<hr>
<h2 id='gen.probs.mjmcmc'>Generate a probability list for MJMCMC (Mode Jumping MCMC)</h2><span id='topic+gen.probs.mjmcmc'></span>

<h3>Description</h3>

<p>Generate a probability list for MJMCMC (Mode Jumping MCMC)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.probs.mjmcmc()
</code></pre>


<h3>Value</h3>

<p>A list of probabilities to be used as input for the mjmcmc function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gen.probs.mjmcmc()

</code></pre>

<hr>
<h2 id='gmjmcmc'>Main algorithm for GMJMCMC (Genetically Modified MJMCMC)</h2><span id='topic+gmjmcmc'></span>

<h3>Description</h3>

<p>Main algorithm for GMJMCMC (Genetically Modified MJMCMC)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmjmcmc(
  data,
  loglik.pi = gaussian.loglik,
  loglik.alpha = gaussian.loglik.alpha,
  transforms,
  P = 10,
  N.init = 100,
  N.final = 100,
  probs = NULL,
  params = NULL,
  sub = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmjmcmc_+3A_data">data</code></td>
<td>
<p>A matrix containing the data to use in the algorithm,
first column should be the dependent variable, second should be the intercept
and the rest of the columns should be the independent variables.</p>
</td></tr>
<tr><td><code id="gmjmcmc_+3A_loglik.pi">loglik.pi</code></td>
<td>
<p>The (log) density to explore</p>
</td></tr>
<tr><td><code id="gmjmcmc_+3A_loglik.alpha">loglik.alpha</code></td>
<td>
<p>The likelihood function to use for alpha calculation</p>
</td></tr>
<tr><td><code id="gmjmcmc_+3A_transforms">transforms</code></td>
<td>
<p>A Character vector including the names of the non-linear functions to be used by the modification
and the projection operator.</p>
</td></tr>
<tr><td><code id="gmjmcmc_+3A_p">P</code></td>
<td>
<p>The number of generations for GMJMCMC (Genetically Modified MJMCMC).
The default value is $P = 10$.
A larger value like $P = 50$ might be more realistic for more complicated examples where one expects a lot of non-linear structures.</p>
</td></tr>
<tr><td><code id="gmjmcmc_+3A_n.init">N.init</code></td>
<td>
<p>The number of iterations per population (total iterations = (T-1)*N.init+N.final)</p>
</td></tr>
<tr><td><code id="gmjmcmc_+3A_n.final">N.final</code></td>
<td>
<p>The number of iterations for the final population (total iterations = (T-1)*N.init+N.final)</p>
</td></tr>
<tr><td><code id="gmjmcmc_+3A_probs">probs</code></td>
<td>
<p>A list of the various probability vectors to use</p>
</td></tr>
<tr><td><code id="gmjmcmc_+3A_params">params</code></td>
<td>
<p>A list of the various parameters for all the parts of the algorithm</p>
</td></tr>
<tr><td><code id="gmjmcmc_+3A_sub">sub</code></td>
<td>
<p>An indicator that if the likelihood is inexact and should be improved each model visit (EXPERIMENTAL!)</p>
</td></tr>
<tr><td><code id="gmjmcmc_+3A_verbose">verbose</code></td>
<td>
<p>A logical denoting if messages should be printed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table>
<tr><td><code>models</code></td>
<td>
<p>All models per population.</p>
</td></tr>
<tr><td><code>lo.models</code></td>
<td>
<p>All local optimization models per population.</p>
</td></tr>
<tr><td><code>populations</code></td>
<td>
<p>All features per population.</p>
</td></tr>
<tr><td><code>marg.probs</code></td>
<td>
<p>Marginal feature probabilities per population.</p>
</td></tr>
<tr><td><code>model.probs</code></td>
<td>
<p>Marginal feature probabilities per population.</p>
</td></tr>
<tr><td><code>model.probs.idx</code></td>
<td>
<p>Marginal feature probabilities per population.</p>
</td></tr>
<tr><td><code>best.margs</code></td>
<td>
<p>Best marginal model probability per population.</p>
</td></tr>
<tr><td><code>accept</code></td>
<td>
<p>Acceptance rate per population.</p>
</td></tr>
<tr><td><code>accept.tot</code></td>
<td>
<p>Overall acceptance rate.</p>
</td></tr>
<tr><td><code>best</code></td>
<td>
<p>Best marginal model probability throughout the run, represented as the maximum value in <code>unlist(best.margs)</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc(matrix(rnorm(600), 100), P = 2, gaussian.loglik, NULL, c("p0", "exp_dbl"))
summary(result)
plot(result)

</code></pre>

<hr>
<h2 id='gmjmcmc.parallel'>Run multiple gmjmcmc (Genetically Modified MJMCMC) runs in parallel returning a list of all results.</h2><span id='topic+gmjmcmc.parallel'></span>

<h3>Description</h3>

<p>Run multiple gmjmcmc (Genetically Modified MJMCMC) runs in parallel returning a list of all results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmjmcmc.parallel(
  runs,
  cores = getOption("mc.cores", 2L),
  merge.options = list(populations = "best", complex.measure = 2, tol = 1e-07),
  data,
  loglik.pi = gaussian.loglik,
  loglik.alpha = gaussian.loglik.alpha(),
  transforms,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmjmcmc.parallel_+3A_runs">runs</code></td>
<td>
<p>The number of runs to run</p>
</td></tr>
<tr><td><code id="gmjmcmc.parallel_+3A_cores">cores</code></td>
<td>
<p>The number of cores to run on</p>
</td></tr>
<tr><td><code id="gmjmcmc.parallel_+3A_merge.options">merge.options</code></td>
<td>
<p>A list of options to pass to the <code><a href="#topic+merge_results">merge_results()</a></code> function run after the</p>
</td></tr>
<tr><td><code id="gmjmcmc.parallel_+3A_data">data</code></td>
<td>
<p>A matrix containing the data to use in the algorithm,
first column should be the dependent variable, second should be the intercept
and the rest of the columns should be the independent variables.</p>
</td></tr>
<tr><td><code id="gmjmcmc.parallel_+3A_loglik.pi">loglik.pi</code></td>
<td>
<p>The (log) density to explore</p>
</td></tr>
<tr><td><code id="gmjmcmc.parallel_+3A_loglik.alpha">loglik.alpha</code></td>
<td>
<p>The likelihood function to use for alpha calculation</p>
</td></tr>
<tr><td><code id="gmjmcmc.parallel_+3A_transforms">transforms</code></td>
<td>
<p>A Character vector including the names of the non-linear functions to be used by the modification
and the projection operator.</p>
</td></tr>
<tr><td><code id="gmjmcmc.parallel_+3A_...">...</code></td>
<td>
<p>Further params passed to mjmcmc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Results from multiple gmjmcmc runs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc.parallel(
 runs = 1,
 cores = 1,
 list(populations = "best", complex.measure = 2, tol = 0.0000001),
 matrix(rnorm(600), 100),
 P = 2,
 gaussian.loglik,
 loglik.alpha = gaussian.loglik.alpha,
 c("p0", "exp_dbl")
)

summary(result)

plot(result)


</code></pre>

<hr>
<h2 id='hs'>heavy side function</h2><span id='topic+hs'></span>

<h3>Description</h3>

<p>heavy side function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hs_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>as.integer(x&gt;0)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hs(2)

</code></pre>

<hr>
<h2 id='linear.g.prior.loglik'>Log likelihood function for linear regression using Zellners g-prior</h2><span id='topic+linear.g.prior.loglik'></span>

<h3>Description</h3>

<p>Log likelihood function for linear regression using Zellners g-prior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear.g.prior.loglik(y, x, model, complex, params = list(g = 4))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linear.g.prior.loglik_+3A_y">y</code></td>
<td>
<p>A vector containing the dependent variable</p>
</td></tr>
<tr><td><code id="linear.g.prior.loglik_+3A_x">x</code></td>
<td>
<p>The matrix containing the precalculated features</p>
</td></tr>
<tr><td><code id="linear.g.prior.loglik_+3A_model">model</code></td>
<td>
<p>The model to estimate as a logical vector</p>
</td></tr>
<tr><td><code id="linear.g.prior.loglik_+3A_complex">complex</code></td>
<td>
<p>A list of complexity measures for the features</p>
</td></tr>
<tr><td><code id="linear.g.prior.loglik_+3A_params">params</code></td>
<td>
<p>A list of parameters for the log likelihood, supplied by the user</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the log marginal likelihood combined with the log prior (crit) and the posterior mode of the coefficients (coefs).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>linear.g.prior.loglik(rnorm(100), matrix(rnorm(100)), TRUE, list(oc=1))

</code></pre>

<hr>
<h2 id='logistic.loglik'>Log likelihood function for logistic regression with a prior p(m)=sum(total_width)
This function is created as an example of how to create an estimator that is used
to calculate the marginal likelihood of a model.</h2><span id='topic+logistic.loglik'></span>

<h3>Description</h3>

<p>Log likelihood function for logistic regression with a prior p(m)=sum(total_width)
This function is created as an example of how to create an estimator that is used
to calculate the marginal likelihood of a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logistic.loglik(y, x, model, complex, params = list(r = 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logistic.loglik_+3A_y">y</code></td>
<td>
<p>A vector containing the dependent variable</p>
</td></tr>
<tr><td><code id="logistic.loglik_+3A_x">x</code></td>
<td>
<p>The matrix containing the precalculated features</p>
</td></tr>
<tr><td><code id="logistic.loglik_+3A_model">model</code></td>
<td>
<p>The model to estimate as a logical vector</p>
</td></tr>
<tr><td><code id="logistic.loglik_+3A_complex">complex</code></td>
<td>
<p>A list of complexity measures for the features</p>
</td></tr>
<tr><td><code id="logistic.loglik_+3A_params">params</code></td>
<td>
<p>A list of parameters for the log likelihood, supplied by the user</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the log marginal likelihood combined with the log prior (crit) and the posterior mode of the coefficients (coefs).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logistic.loglik(as.integer(rnorm(100) &gt; 0), matrix(rnorm(100)), TRUE, list(oc = 1))


</code></pre>

<hr>
<h2 id='logistic.loglik.alpha'>Log likelihood function for logistic regression for alpha calculation
This function is just the bare likelihood function</h2><span id='topic+logistic.loglik.alpha'></span>

<h3>Description</h3>

<p>Log likelihood function for logistic regression for alpha calculation
This function is just the bare likelihood function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logistic.loglik.alpha(a, data, mu_func)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logistic.loglik.alpha_+3A_a">a</code></td>
<td>
<p>A vector of the alphas to be used</p>
</td></tr>
<tr><td><code id="logistic.loglik.alpha_+3A_data">data</code></td>
<td>
<p>The data to be used for calculation</p>
</td></tr>
<tr><td><code id="logistic.loglik.alpha_+3A_mu_func">mu_func</code></td>
<td>
<p>The function linking the mean to the covariates,
as a string with the alphas as a[i].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric with the log likelihood.
</p>

<hr>
<h2 id='marginal.probs'>Function for calculating marginal inclusion probabilities of features given a list of models</h2><span id='topic+marginal.probs'></span>

<h3>Description</h3>

<p>Function for calculating marginal inclusion probabilities of features given a list of models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginal.probs(models)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginal.probs_+3A_models">models</code></td>
<td>
<p>The list of models to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of marginal model probabilities based on relative frequencies of model visits in MCMC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc(matrix(rnorm(600), 100), P = 2, gaussian.loglik, NULL, c("p0", "exp_dbl"))
marginal.probs(result$models[[1]])

</code></pre>

<hr>
<h2 id='merge_results'>Merge a list of multiple results from many runs
This function will weight the features based on the best mlik in that population
and merge the results together, simplifying by merging equivalent features (having high correlation).</h2><span id='topic+merge_results'></span>

<h3>Description</h3>

<p>Merge a list of multiple results from many runs
This function will weight the features based on the best mlik in that population
and merge the results together, simplifying by merging equivalent features (having high correlation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_results(
  results,
  populations = NULL,
  complex.measure = NULL,
  tol = NULL,
  data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_results_+3A_results">results</code></td>
<td>
<p>A list containing multiple results from GMJMCMC (Genetically Modified MJMCMC).</p>
</td></tr>
<tr><td><code id="merge_results_+3A_populations">populations</code></td>
<td>
<p>Which populations should be merged from the results, can be &quot;all&quot;, &quot;last&quot; (default) or &quot;best&quot;.</p>
</td></tr>
<tr><td><code id="merge_results_+3A_complex.measure">complex.measure</code></td>
<td>
<p>The complex measure to use when finding the simplest equivalent feature,
1=total width, 2=operation count and 3=depth.</p>
</td></tr>
<tr><td><code id="merge_results_+3A_tol">tol</code></td>
<td>
<p>The tolerance to use for the correlation when finding equivalent features, default is 0.</p>
</td></tr>
<tr><td><code id="merge_results_+3A_data">data</code></td>
<td>
<p>Data to use when comparing features, default is NULL meaning that mock data will be generated,
if data is supplied it should be of the same form as is required by gmjmcmc, i.e. with both x, y and an intercept.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;gmjmcmc_merged&quot; containing the following elements:
</p>
<table>
<tr><td><code>features</code></td>
<td>
<p>The features where equivalent features are represented in their simplest form.</p>
</td></tr>
<tr><td><code>marg.probs</code></td>
<td>
<p>Importance of features.</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>Counts of how many versions that were present of each feature.</p>
</td></tr>
<tr><td><code>results</code></td>
<td>
<p>Results as they were passed to the function.</p>
</td></tr>
<tr><td><code>pop.best</code></td>
<td>
<p>The population in the results which contained the model with the highest log marginal posterior.</p>
</td></tr>
<tr><td><code>thread.best</code></td>
<td>
<p>The thread in the results which contained the model with the highest log marginal posterior.</p>
</td></tr>
<tr><td><code>crit.best</code></td>
<td>
<p>The highest log marginal posterior for any model in the results.</p>
</td></tr>
<tr><td><code>reported</code></td>
<td>
<p>The highest log marginal likelihood for the reported populations as defined in the populations argument.</p>
</td></tr>
<tr><td><code>rep.pop</code></td>
<td>
<p>The index of the population which contains reported.</p>
</td></tr>
<tr><td><code>best.log.posteriors</code></td>
<td>
<p>A matrix where the first column contains the population indices and the second column contains the model with the highest log marginal posterior within that population.</p>
</td></tr>
<tr><td><code>rep.thread</code></td>
<td>
<p>The index of the thread which contains reported.</p>
</td></tr>
</table>
<p>result &lt;- gmjmcmc.parallel(
runs = 1,
cores = 1,
list(populations = &quot;best&quot;, complex.measure = 2, tol = 0.0000001),
matrix(rnorm(600), 100),
P = 2,
gaussian.loglik,
loglik.alpha = gaussian.loglik.alpha,
c(&quot;p0&quot;, &quot;exp_dbl&quot;)
)
</p>
<p>summary(result)
</p>
<p>plot(result)
</p>
<p>merge_results(result$results)
</p>

<hr>
<h2 id='mjmcmc'>Main algorithm for MJMCMC (Genetically Modified MJMCMC)</h2><span id='topic+mjmcmc'></span>

<h3>Description</h3>

<p>Main algorithm for MJMCMC (Genetically Modified MJMCMC)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mjmcmc(
  data,
  loglik.pi,
  N = 100,
  probs = NULL,
  params = NULL,
  sub = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mjmcmc_+3A_data">data</code></td>
<td>
<p>A matrix containing the data to use in the algorithm,
first column should be the dependent variable, second should be the intercept
and the rest of the columns should be the independent variables.</p>
</td></tr>
<tr><td><code id="mjmcmc_+3A_loglik.pi">loglik.pi</code></td>
<td>
<p>The (log) density to explore</p>
</td></tr>
<tr><td><code id="mjmcmc_+3A_n">N</code></td>
<td>
<p>The number of iterations to run for</p>
</td></tr>
<tr><td><code id="mjmcmc_+3A_probs">probs</code></td>
<td>
<p>A list of the various probability vectors to use</p>
</td></tr>
<tr><td><code id="mjmcmc_+3A_params">params</code></td>
<td>
<p>A list of the various parameters for all the parts of the algorithm</p>
</td></tr>
<tr><td><code id="mjmcmc_+3A_sub">sub</code></td>
<td>
<p>An indicator that if the likelihood is inexact and should be improved each model visit (EXPERIMENTAL!)</p>
</td></tr>
<tr><td><code id="mjmcmc_+3A_verbose">verbose</code></td>
<td>
<p>A logical denoting if messages should be printed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table>
<tr><td><code>models</code></td>
<td>
<p>All visited models.</p>
</td></tr>
<tr><td><code>accept</code></td>
<td>
<p>Average acceptance rate of the chain.</p>
</td></tr>
<tr><td><code>lo.models</code></td>
<td>
<p>All models visited during local optimization.</p>
</td></tr>
<tr><td><code>best.crit</code></td>
<td>
<p>The highest log marginal probability of the visited models.</p>
</td></tr>
<tr><td><code>marg.probs</code></td>
<td>
<p>Marginal probabilities of the features.</p>
</td></tr>
<tr><td><code>model.probs</code></td>
<td>
<p>Marginal probabilities of all of the visited models.</p>
</td></tr>
<tr><td><code>model.probs.idx</code></td>
<td>
<p>Indices of unique visited models.</p>
</td></tr>
<tr><td><code>populations</code></td>
<td>
<p>The covariates represented as a list of features.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- mjmcmc(matrix(rnorm(600), 100), gaussian.loglik)
summary(result)
plot(result)

</code></pre>

<hr>
<h2 id='mjmcmc.parallel'>Run multiple mjmcmc runs in parallel, merging the results before returning.</h2><span id='topic+mjmcmc.parallel'></span>

<h3>Description</h3>

<p>Run multiple mjmcmc runs in parallel, merging the results before returning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mjmcmc.parallel(runs, cores = getOption("mc.cores", 2L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mjmcmc.parallel_+3A_runs">runs</code></td>
<td>
<p>The number of runs to run</p>
</td></tr>
<tr><td><code id="mjmcmc.parallel_+3A_cores">cores</code></td>
<td>
<p>The number of cores to run on</p>
</td></tr>
<tr><td><code id="mjmcmc.parallel_+3A_...">...</code></td>
<td>
<p>Further params passed to mjmcmc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Merged results from multiple mjmcmc runs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- mjmcmc.parallel(runs = 1, cores = 1, matrix(rnorm(600), 100), gaussian.loglik)
summary(result)
plot(result)

</code></pre>

<hr>
<h2 id='model.string'>Function to generate a function string for a model consisting of features</h2><span id='topic+model.string'></span>

<h3>Description</h3>

<p>Function to generate a function string for a model consisting of features
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.string(model, features, link = "I", round = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.string_+3A_model">model</code></td>
<td>
<p>A logical vector indicating which features to include</p>
</td></tr>
<tr><td><code id="model.string_+3A_features">features</code></td>
<td>
<p>The population of features</p>
</td></tr>
<tr><td><code id="model.string_+3A_link">link</code></td>
<td>
<p>The link function to use, as a string</p>
</td></tr>
<tr><td><code id="model.string_+3A_round">round</code></td>
<td>
<p>Rounding error for the features in the printed format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character representation of a model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc(matrix(rnorm(600), 100), P = 2, gaussian.loglik, NULL, c("p0", "exp_dbl"))
summary(result)
plot(result)
model.string(c(TRUE, FALSE, TRUE, FALSE, TRUE), result$populations[[1]])
model.string(result$models[[1]][1][[1]]$model, result$populations[[1]])

</code></pre>

<hr>
<h2 id='ngelu'>Negative GELU function</h2><span id='topic+ngelu'></span>

<h3>Description</h3>

<p>Negative GELU function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ngelu(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ngelu_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>-x*pnorm(-x)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ngelu(2)

</code></pre>

<hr>
<h2 id='nhs'>negative heavy side function</h2><span id='topic+nhs'></span>

<h3>Description</h3>

<p>negative heavy side function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nhs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nhs_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>as.integer(x&lt;0)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nhs(2)

</code></pre>

<hr>
<h2 id='not'>not x</h2><span id='topic+not'></span>

<h3>Description</h3>

<p>not x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>not(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="not_+3A_x">x</code></td>
<td>
<p>The vector of binary values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1-x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>not(TRUE)

</code></pre>

<hr>
<h2 id='nrelu'>negative ReLu function</h2><span id='topic+nrelu'></span>

<h3>Description</h3>

<p>negative ReLu function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nrelu(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nrelu_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>max(-x,0)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nrelu(2)

</code></pre>

<hr>
<h2 id='p0'>p0 polynomial term</h2><span id='topic+p0'></span>

<h3>Description</h3>

<p>p0 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p0(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p0_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log(abs(x) + .Machine$double.eps)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p0(2)

</code></pre>

<hr>
<h2 id='p05'>p05 polynomial term</h2><span id='topic+p05'></span>

<h3>Description</h3>

<p>p05 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p05(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p05_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(abs(x)+.Machine$double.eps)^(0.5)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p05(2)

</code></pre>

<hr>
<h2 id='p0p0'>p0p0 polynomial term</h2><span id='topic+p0p0'></span>

<h3>Description</h3>

<p>p0p0 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p0p0(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p0p0_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p0(x)*p0(x)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p0p0(2)

</code></pre>

<hr>
<h2 id='p0p05'>p0p05 polynomial term</h2><span id='topic+p0p05'></span>

<h3>Description</h3>

<p>p0p05 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p0p05(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p0p05_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p0(x)*(abs(x)+.Machine$double.eps)^(0.5)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p0p05(2)

</code></pre>

<hr>
<h2 id='p0p1'>p0p1 polynomial term</h2><span id='topic+p0p1'></span>

<h3>Description</h3>

<p>p0p1 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p0p1(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p0p1_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p0(x)*x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p0p1(2)

</code></pre>

<hr>
<h2 id='p0p2'>p0p2 polynomial term</h2><span id='topic+p0p2'></span>

<h3>Description</h3>

<p>p0p2 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p0p2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p0p2_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p0(x)*x^(2)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p0p2(2)

</code></pre>

<hr>
<h2 id='p0p3'>p0p3 polynomial term</h2><span id='topic+p0p3'></span>

<h3>Description</h3>

<p>p0p3 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p0p3(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p0p3_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p0(x)*x^(3)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p0p3(2)

</code></pre>

<hr>
<h2 id='p0pm05'>p0pm05 polynomial term</h2><span id='topic+p0pm05'></span>

<h3>Description</h3>

<p>p0pm05 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p0pm05(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p0pm05_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p0(x)<em>sign(x)</em>(abs(x)+.Machine$double.eps)^(-0.5)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p0pm05(2)

</code></pre>

<hr>
<h2 id='p0pm1'>p0pm1 polynomial terms</h2><span id='topic+p0pm1'></span>

<h3>Description</h3>

<p>p0pm1 polynomial terms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p0pm1(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p0pm1_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p0(x)*(x+.Machine$double.eps)^(-1)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p0pm1(2)

</code></pre>

<hr>
<h2 id='p0pm2'>p0pm2 polynomial term</h2><span id='topic+p0pm2'></span>

<h3>Description</h3>

<p>p0pm2 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p0pm2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p0pm2_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p0(x)<em>sign(x)</em>(abs(x)+.Machine$double.eps)^(-2)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p0pm2(2)

</code></pre>

<hr>
<h2 id='p2'>p2 polynomial term</h2><span id='topic+p2'></span>

<h3>Description</h3>

<p>p2 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p2_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x^(2)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p2(2)

</code></pre>

<hr>
<h2 id='p3'>p3 polynomial term</h2><span id='topic+p3'></span>

<h3>Description</h3>

<p>p3 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p3(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p3_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x^(3)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p3(2)

</code></pre>

<hr>
<h2 id='plot.gmjmcmc'>Function to plot the results, works both for results from gmjmcmc and
merged results from merge.results</h2><span id='topic+plot.gmjmcmc'></span>

<h3>Description</h3>

<p>Function to plot the results, works both for results from gmjmcmc and
merged results from merge.results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmjmcmc'
plot(x, count = "all", pop = "last", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gmjmcmc_+3A_x">x</code></td>
<td>
<p>The results to use</p>
</td></tr>
<tr><td><code id="plot.gmjmcmc_+3A_count">count</code></td>
<td>
<p>The number of features to plot, defaults to all</p>
</td></tr>
<tr><td><code id="plot.gmjmcmc_+3A_pop">pop</code></td>
<td>
<p>The population to plot, defaults to last</p>
</td></tr>
<tr><td><code id="plot.gmjmcmc_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, just creates a plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc(matrix(rnorm(600), 100), P = 2, gaussian.loglik, NULL, c("p0", "exp_dbl"))
plot(result)


</code></pre>

<hr>
<h2 id='plot.gmjmcmc_merged'>Plot a gmjmcmc_merged run</h2><span id='topic+plot.gmjmcmc_merged'></span>

<h3>Description</h3>

<p>Plot a gmjmcmc_merged run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmjmcmc_merged'
plot(x, count = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gmjmcmc_merged_+3A_x">x</code></td>
<td>
<p>The results to use</p>
</td></tr>
<tr><td><code id="plot.gmjmcmc_merged_+3A_count">count</code></td>
<td>
<p>The number of features to plot, defaults to all</p>
</td></tr>
<tr><td><code id="plot.gmjmcmc_merged_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, just creates a plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc.parallel(
 runs = 1,
 cores = 1,
 list(populations = "best", complex.measure = 2, tol = 0.0000001),
 matrix(rnorm(600), 100),
 P = 2,
 gaussian.loglik,
 loglik.alpha = gaussian.loglik.alpha,
 c("p0", "exp_dbl")
)
plot(result)

</code></pre>

<hr>
<h2 id='plot.mjmcmc'>Function to plot the results, works both for results from gmjmcmc and
merged results from merge.results</h2><span id='topic+plot.mjmcmc'></span>

<h3>Description</h3>

<p>Function to plot the results, works both for results from gmjmcmc and
merged results from merge.results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjmcmc'
plot(x, count = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mjmcmc_+3A_x">x</code></td>
<td>
<p>The results to use</p>
</td></tr>
<tr><td><code id="plot.mjmcmc_+3A_count">count</code></td>
<td>
<p>The number of features to plot, defaults to all</p>
</td></tr>
<tr><td><code id="plot.mjmcmc_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, just creates a plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- mjmcmc(matrix(rnorm(600), 100), gaussian.loglik)
plot(result)

</code></pre>

<hr>
<h2 id='plot.mjmcmc_parallel'>Plot a mjmcmc_parallel run</h2><span id='topic+plot.mjmcmc_parallel'></span>

<h3>Description</h3>

<p>Plot a mjmcmc_parallel run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjmcmc_parallel'
plot(x, count = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mjmcmc_parallel_+3A_x">x</code></td>
<td>
<p>The results to use</p>
</td></tr>
<tr><td><code id="plot.mjmcmc_parallel_+3A_count">count</code></td>
<td>
<p>The number of features to plot, defaults to all</p>
</td></tr>
<tr><td><code id="plot.mjmcmc_parallel_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, just creates a plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- mjmcmc.parallel(runs = 1, cores = 1, matrix(rnorm(600), 100), gaussian.loglik)
plot(result)

</code></pre>

<hr>
<h2 id='pm05'>pm05 polynomial term</h2><span id='topic+pm05'></span>

<h3>Description</h3>

<p>pm05 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pm05(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pm05_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(abs(x)+.Machine$double.eps)^(-0.5)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pm05(2)

</code></pre>

<hr>
<h2 id='pm1'>pm1 polynomial term</h2><span id='topic+pm1'></span>

<h3>Description</h3>

<p>pm1 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pm1(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pm1_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sign(x)*(abs(x)+.Machine$double.eps)^(-1)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pm1(2)

</code></pre>

<hr>
<h2 id='pm2'>pm2 polynomial term</h2><span id='topic+pm2'></span>

<h3>Description</h3>

<p>pm2 polynomial term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pm2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pm2_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sign(x)*(abs(x)+.Machine$double.eps)^(-2)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pm2(2)

</code></pre>

<hr>
<h2 id='predict.gmjmcmc'>Predict using a gmjmcmc result object.</h2><span id='topic+predict.gmjmcmc'></span>

<h3>Description</h3>

<p>Predict using a gmjmcmc result object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmjmcmc'
predict(object, x, link = function(x) x, quantiles = c(0.025, 0.5, 0.975), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.gmjmcmc_+3A_object">object</code></td>
<td>
<p>The model to use.</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_+3A_x">x</code></td>
<td>
<p>The new data to use for the prediction, a matrix where each row is an observation.</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_+3A_link">link</code></td>
<td>
<p>The link function to use</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_+3A_quantiles">quantiles</code></td>
<td>
<p>The quantiles to calculate credible intervals for the posterior moddes (in model space).</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing aggregated predictions and per model predictions.
</p>
<table>
<tr><td><code>aggr</code></td>
<td>
<p>Aggregated predictions with mean and quantiles.</p>
</td></tr>
<tr><td><code>preds</code></td>
<td>
<p>A list of lists containing individual predictions per model per population in object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc(
 matrix(rnorm(600), 100),
 P = 2,
 gaussian.loglik,
 loglik.alpha = gaussian.loglik.alpha,
 c("p0", "exp_dbl")
)
preds &lt;- predict(result, matrix(rnorm(600), 100))


</code></pre>

<hr>
<h2 id='predict.gmjmcmc_merged'>Predict using a merged gmjmcmc result object.</h2><span id='topic+predict.gmjmcmc_merged'></span>

<h3>Description</h3>

<p>Predict using a merged gmjmcmc result object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmjmcmc_merged'
predict(object, x, link = function(x) x, quantiles = c(0.025, 0.5, 0.975), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.gmjmcmc_merged_+3A_object">object</code></td>
<td>
<p>The model to use.</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_merged_+3A_x">x</code></td>
<td>
<p>The new data to use for the prediction, a matrix where each row is an observation.</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_merged_+3A_link">link</code></td>
<td>
<p>The link function to use</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_merged_+3A_quantiles">quantiles</code></td>
<td>
<p>The quantiles to calculate credible intervals for the posterior moddes (in model space).</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_merged_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing aggregated predictions and per model predictions.
</p>
<table>
<tr><td><code>aggr</code></td>
<td>
<p>Aggregated predictions with mean and quantiles.</p>
</td></tr>
<tr><td><code>preds</code></td>
<td>
<p>A list of lists containing individual predictions per model per population in object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc.parallel(
 runs = 1,
 cores = 1,
 list(populations = "best", complex.measure = 2, tol = 0.0000001),
 matrix(rnorm(600), 100),
 P = 2,
 gaussian.loglik,
 loglik.alpha = gaussian.loglik.alpha,
 c("p0", "exp_dbl")
)
preds &lt;- predict(result, matrix(rnorm(600), 100))

</code></pre>

<hr>
<h2 id='predict.gmjmcmc_parallel'>Predict using a gmjmcmc result object from a parallel run.</h2><span id='topic+predict.gmjmcmc_parallel'></span>

<h3>Description</h3>

<p>Predict using a gmjmcmc result object from a parallel run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmjmcmc_parallel'
predict(object, x, link = function(x) x, quantiles = c(0.025, 0.5, 0.975), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.gmjmcmc_parallel_+3A_object">object</code></td>
<td>
<p>The model to use.</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_parallel_+3A_x">x</code></td>
<td>
<p>The new data to use for the prediction, a matrix where each row is an observation.</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_parallel_+3A_link">link</code></td>
<td>
<p>The link function to use</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_parallel_+3A_quantiles">quantiles</code></td>
<td>
<p>The quantiles to calculate credible intervals for the posterior moddes (in model space).</p>
</td></tr>
<tr><td><code id="predict.gmjmcmc_parallel_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to merge_results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing aggregated predictions and per model predictions.
</p>
<table>
<tr><td><code>aggr</code></td>
<td>
<p>Aggregated predictions with mean and quantiles.</p>
</td></tr>
<tr><td><code>preds</code></td>
<td>
<p>A list of lists containing individual predictions per model per population in object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc.parallel(
 runs = 1,
 cores = 1,
 list(populations = "best", complex.measure = 2, tol = 0.0000001),
 matrix(rnorm(600), 100),
 P = 2,
 gaussian.loglik,
 loglik.alpha = gaussian.loglik.alpha,
 c("p0", "exp_dbl")
)
preds &lt;- predict(result$results, matrix(rnorm(600), 100))

</code></pre>

<hr>
<h2 id='predict.mjmcmc'>Predict using a mjmcmc result object.</h2><span id='topic+predict.mjmcmc'></span>

<h3>Description</h3>

<p>Predict using a mjmcmc result object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjmcmc'
predict(object, x, link = function(x) x, quantiles = c(0.025, 0.5, 0.975), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.mjmcmc_+3A_object">object</code></td>
<td>
<p>The model to use.</p>
</td></tr>
<tr><td><code id="predict.mjmcmc_+3A_x">x</code></td>
<td>
<p>The new data to use for the prediction, a matrix where each row is an observation.</p>
</td></tr>
<tr><td><code id="predict.mjmcmc_+3A_link">link</code></td>
<td>
<p>The link function to use</p>
</td></tr>
<tr><td><code id="predict.mjmcmc_+3A_quantiles">quantiles</code></td>
<td>
<p>The quantiles to calculate credible intervals for the posterior moddes (in model space).</p>
</td></tr>
<tr><td><code id="predict.mjmcmc_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing aggregated predictions.
</p>
<table>
<tr><td><code>mean</code></td>
<td>
<p>Mean of aggregated predictions.</p>
</td></tr>
<tr><td><code>quantiles</code></td>
<td>
<p>Quantiles of aggregated predictions.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- mjmcmc(matrix(rnorm(600), 100), gaussian.loglik)
preds &lt;- predict(result, matrix(rnorm(500), 100))

</code></pre>

<hr>
<h2 id='predict.mjmcmc_parallel'>Predict using a mjmcmc result object from a parallel run.</h2><span id='topic+predict.mjmcmc_parallel'></span>

<h3>Description</h3>

<p>Predict using a mjmcmc result object from a parallel run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjmcmc_parallel'
predict(object, x, link = function(x) x, quantiles = c(0.025, 0.5, 0.975), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.mjmcmc_parallel_+3A_object">object</code></td>
<td>
<p>The model to use.</p>
</td></tr>
<tr><td><code id="predict.mjmcmc_parallel_+3A_x">x</code></td>
<td>
<p>The new data to use for the prediction, a matrix where each row is an observation.</p>
</td></tr>
<tr><td><code id="predict.mjmcmc_parallel_+3A_link">link</code></td>
<td>
<p>The link function to use</p>
</td></tr>
<tr><td><code id="predict.mjmcmc_parallel_+3A_quantiles">quantiles</code></td>
<td>
<p>The quantiles to calculate credible intervals for the posterior moddes (in model space).</p>
</td></tr>
<tr><td><code id="predict.mjmcmc_parallel_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing aggregated predictions.
</p>
<table>
<tr><td><code>mean</code></td>
<td>
<p>Mean of aggregated predictions.</p>
</td></tr>
<tr><td><code>quantiles</code></td>
<td>
<p>Quantiles of aggregated predictions.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- mjmcmc.parallel(runs = 1, cores = 1, matrix(rnorm(600), 100), gaussian.loglik)
preds &lt;- predict(result, matrix(rnorm(500), 100))

</code></pre>

<hr>
<h2 id='print.feature'>Print method for &quot;feature&quot; class</h2><span id='topic+print.feature'></span>

<h3>Description</h3>

<p>Print method for &quot;feature&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'feature'
print(x, dataset = FALSE, alphas = FALSE, labels = FALSE, round = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.feature_+3A_x">x</code></td>
<td>
<p>An object of class &quot;feature&quot;</p>
</td></tr>
<tr><td><code id="print.feature_+3A_dataset">dataset</code></td>
<td>
<p>Set the regular covariates as columns in a dataset</p>
</td></tr>
<tr><td><code id="print.feature_+3A_alphas">alphas</code></td>
<td>
<p>Print a &quot;?&quot; instead of actual alphas to prepare the output for alpha estimation</p>
</td></tr>
<tr><td><code id="print.feature_+3A_labels">labels</code></td>
<td>
<p>Should the covariates be named, or just referred to as their place in the data.frame.</p>
</td></tr>
<tr><td><code id="print.feature_+3A_round">round</code></td>
<td>
<p>Should numbers be rounded when printing? Default is FALSE, otherwise it can be set to the number of decimal places.</p>
</td></tr>
<tr><td><code id="print.feature_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String representation of a feature
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc(matrix(rnorm(600), 100), P = 2, gaussian.loglik, NULL, c("p0", "exp_dbl"))
print(result$populations[[1]][1])

</code></pre>

<hr>
<h2 id='relu'>ReLu function</h2><span id='topic+relu'></span>

<h3>Description</h3>

<p>ReLu function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relu(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relu_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>max(x,0)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>relu(2)

</code></pre>

<hr>
<h2 id='set.transforms'>Set the transformations option for GMJMCMC (Genetically Modified MJMCMC),
this is also done when running the algorithm, but this function allows for it to be done manually.</h2><span id='topic+set.transforms'></span>

<h3>Description</h3>

<p>Set the transformations option for GMJMCMC (Genetically Modified MJMCMC),
this is also done when running the algorithm, but this function allows for it to be done manually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.transforms(transforms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.transforms_+3A_transforms">transforms</code></td>
<td>
<p>The vector of non-linear transformations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, just sets the gmjmcmc-transformations option
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.transforms(c("p0","p1"))


</code></pre>

<hr>
<h2 id='sigmoid'>Sigmoid function</h2><span id='topic+sigmoid'></span>

<h3>Description</h3>

<p>Sigmoid function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigmoid(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigmoid_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sigmoid of x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sigmoid(2)


</code></pre>

<hr>
<h2 id='sin_deg'>Sine function for degrees</h2><span id='topic+sin_deg'></span>

<h3>Description</h3>

<p>Sine function for degrees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sin_deg(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sin_deg_+3A_x">x</code></td>
<td>
<p>The vector of values in degrees</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sine of x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sin_deg(0)

</code></pre>

<hr>
<h2 id='sqroot'>Square root function</h2><span id='topic+sqroot'></span>

<h3>Description</h3>

<p>Square root function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqroot(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqroot_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The square root of the absolute value of x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sqroot(4)

</code></pre>

<hr>
<h2 id='string.population'>Function to get a character respresentation of a list of features</h2><span id='topic+string.population'></span>

<h3>Description</h3>

<p>Function to get a character respresentation of a list of features
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string.population(x, round = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="string.population_+3A_x">x</code></td>
<td>
<p>A list of feature objects</p>
</td></tr>
<tr><td><code id="string.population_+3A_round">round</code></td>
<td>
<p>Rounding precision for parameters of the features</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of character representations of the features of a model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc(matrix(rnorm(600), 100), P = 2, gaussian.loglik, NULL, c("p0", "exp_dbl"))
string.population(result$populations[[1]])

</code></pre>

<hr>
<h2 id='string.population.models'>Function to get a character respresentation of a list of models</h2><span id='topic+string.population.models'></span>

<h3>Description</h3>

<p>Function to get a character respresentation of a list of models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string.population.models(features, models, round = 2, link = "I")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="string.population.models_+3A_features">features</code></td>
<td>
<p>A list of feature objects on which the models are build</p>
</td></tr>
<tr><td><code id="string.population.models_+3A_models">models</code></td>
<td>
<p>A list of model objects</p>
</td></tr>
<tr><td><code id="string.population.models_+3A_round">round</code></td>
<td>
<p>Rounding precision for parameters of the features</p>
</td></tr>
<tr><td><code id="string.population.models_+3A_link">link</code></td>
<td>
<p>The link function to use, as a string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of character representations of a list of models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc(matrix(rnorm(600), 100), P = 2, gaussian.loglik, NULL, c("p0", "exp_dbl"))
string.population.models(result$populations[[2]], result$models[[2]])

</code></pre>

<hr>
<h2 id='summary.gmjmcmc'>Function to print a quick summary of the results</h2><span id='topic+summary.gmjmcmc'></span>

<h3>Description</h3>

<p>Function to print a quick summary of the results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmjmcmc'
summary(object, pop = "last", tol = 1e-04, labels = FALSE, effects = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gmjmcmc_+3A_object">object</code></td>
<td>
<p>The results to use</p>
</td></tr>
<tr><td><code id="summary.gmjmcmc_+3A_pop">pop</code></td>
<td>
<p>The population to print for, defaults to last</p>
</td></tr>
<tr><td><code id="summary.gmjmcmc_+3A_tol">tol</code></td>
<td>
<p>The tolerance to use as a threshold when reporting the results.</p>
</td></tr>
<tr><td><code id="summary.gmjmcmc_+3A_labels">labels</code></td>
<td>
<p>Should the covariates be named, or just referred to as their place in the data.frame.</p>
</td></tr>
<tr><td><code id="summary.gmjmcmc_+3A_effects">effects</code></td>
<td>
<p>Quantiles for posterior modes of the effects across models to be reported, if either effects are NULL or if labels are NULL, no effects are reported.</p>
</td></tr>
<tr><td><code id="summary.gmjmcmc_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the following columns:
</p>
<table>
<tr><td><code>feats.strings</code></td>
<td>
<p>Character representation of the features ordered by marginal probabilities.</p>
</td></tr>
<tr><td><code>marg.probs</code></td>
<td>
<p>Marginal probabilities corresponding to the ordered feature strings.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc(matrix(rnorm(600), 100), P = 2, gaussian.loglik, NULL, c("p0", "exp_dbl"))
summary(result)

</code></pre>

<hr>
<h2 id='summary.gmjmcmc_merged'>Function to print a quick summary of the results</h2><span id='topic+summary.gmjmcmc_merged'></span>

<h3>Description</h3>

<p>Function to print a quick summary of the results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmjmcmc_merged'
summary(object, tol = 1e-04, labels = FALSE, effects = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gmjmcmc_merged_+3A_object">object</code></td>
<td>
<p>The results to use</p>
</td></tr>
<tr><td><code id="summary.gmjmcmc_merged_+3A_tol">tol</code></td>
<td>
<p>The tolerance to use as a threshold when reporting the results.</p>
</td></tr>
<tr><td><code id="summary.gmjmcmc_merged_+3A_labels">labels</code></td>
<td>
<p>Should the covariates be named, or just referred to as their place in the data.frame.</p>
</td></tr>
<tr><td><code id="summary.gmjmcmc_merged_+3A_effects">effects</code></td>
<td>
<p>Quantiles for posterior modes of the effects across models to be reported, if either effects are NULL or if labels are NULL, no effects are reported.</p>
</td></tr>
<tr><td><code id="summary.gmjmcmc_merged_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the following columns:
</p>
<table>
<tr><td><code>feats.strings</code></td>
<td>
<p>Character representation of the features ordered by marginal probabilities.</p>
</td></tr>
<tr><td><code>marg.probs</code></td>
<td>
<p>Marginal probabilities corresponding to the ordered feature strings.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- gmjmcmc.parallel(
 runs = 1,
 cores = 1,
 list(populations = "best", complex.measure = 2, tol = 0.0000001),
 matrix(rnorm(600), 100),
 P = 2,
 gaussian.loglik,
 loglik.alpha = gaussian.loglik.alpha,
 c("p0", "exp_dbl")
)
summary(result)

</code></pre>

<hr>
<h2 id='summary.mjmcmc'>Function to print a quick summary of the results</h2><span id='topic+summary.mjmcmc'></span>

<h3>Description</h3>

<p>Function to print a quick summary of the results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjmcmc'
summary(object, tol = 1e-04, labels = FALSE, effects = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mjmcmc_+3A_object">object</code></td>
<td>
<p>The results to use</p>
</td></tr>
<tr><td><code id="summary.mjmcmc_+3A_tol">tol</code></td>
<td>
<p>The tolerance to use as a threshold when reporting the results.</p>
</td></tr>
<tr><td><code id="summary.mjmcmc_+3A_labels">labels</code></td>
<td>
<p>Should the covariates be named, or just referred to as their place in the data.frame.</p>
</td></tr>
<tr><td><code id="summary.mjmcmc_+3A_effects">effects</code></td>
<td>
<p>Quantiles for posterior modes of the effects across models to be reported, if either effects are NULL or if labels are NULL, no effects are reported.</p>
</td></tr>
<tr><td><code id="summary.mjmcmc_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the following columns:
</p>
<table>
<tr><td><code>feats.strings</code></td>
<td>
<p>Character representation of the covariates ordered by marginal probabilities.</p>
</td></tr>
<tr><td><code>marg.probs</code></td>
<td>
<p>Marginal probabilities corresponding to the ordered feature strings.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- mjmcmc(matrix(rnorm(600), 100), gaussian.loglik)
summary(result)

</code></pre>

<hr>
<h2 id='summary.mjmcmc_parallel'>Function to print a quick summary of the results</h2><span id='topic+summary.mjmcmc_parallel'></span>

<h3>Description</h3>

<p>Function to print a quick summary of the results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjmcmc_parallel'
summary(object, tol = 1e-04, labels = FALSE, effects = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mjmcmc_parallel_+3A_object">object</code></td>
<td>
<p>The results to use</p>
</td></tr>
<tr><td><code id="summary.mjmcmc_parallel_+3A_tol">tol</code></td>
<td>
<p>The tolerance to use as a threshold when reporting the results.</p>
</td></tr>
<tr><td><code id="summary.mjmcmc_parallel_+3A_labels">labels</code></td>
<td>
<p>Should the covariates be named, or just referred to as their place in the data.frame.</p>
</td></tr>
<tr><td><code id="summary.mjmcmc_parallel_+3A_effects">effects</code></td>
<td>
<p>Quantiles for posterior modes of the effects across models to be reported, if either effects are NULL or if labels are NULL, no effects are reported.</p>
</td></tr>
<tr><td><code id="summary.mjmcmc_parallel_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the following columns:
</p>
<table>
<tr><td><code>feats.strings</code></td>
<td>
<p>Character representation of the covariates ordered by marginal probabilities.</p>
</td></tr>
<tr><td><code>marg.probs</code></td>
<td>
<p>Marginal probabilities corresponding to the ordered feature strings.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- mjmcmc.parallel(runs = 1, cores = 1, matrix(rnorm(600), 100), gaussian.loglik)
summary(result)

</code></pre>

<hr>
<h2 id='to23'>To the 2.3  power function</h2><span id='topic+to23'></span>

<h3>Description</h3>

<p>To the 2.3  power function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to23(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to23_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x^2.3
</p>


<h3>Examples</h3>

<pre><code class='language-R'>to23(2)

</code></pre>

<hr>
<h2 id='to25'>To 2.5 power</h2><span id='topic+to25'></span>

<h3>Description</h3>

<p>To 2.5 power
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to25(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to25_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x^(2.5)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>to25(2)

</code></pre>

<hr>
<h2 id='to35'>To 3.5 power</h2><span id='topic+to35'></span>

<h3>Description</h3>

<p>To 3.5 power
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to35(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to35_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x^(3.5)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>to35(2)

</code></pre>

<hr>
<h2 id='to72'>To the 7/2  power function</h2><span id='topic+to72'></span>

<h3>Description</h3>

<p>To the 7/2  power function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to72(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to72_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x^(7/2)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>to72(2)

</code></pre>

<hr>
<h2 id='troot'>Cube root function</h2><span id='topic+troot'></span>

<h3>Description</h3>

<p>Cube root function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>troot(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="troot_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cube root of x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>troot(27)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
