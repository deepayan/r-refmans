<!DOCTYPE html><html lang="en"><head><title>Help for package bcROCsurface</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bcROCsurface}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bcROCsurface-package'>
<p>Bias-Corrected Methods for Estimating the ROC Surface of Continuous Diagnostic Tests</p></a></li>
<li><a href='#asy_cov_tcf'><p>Asymptotic variance-covariance estimation for True Class Fractions (TCFs) at the cut point <code class="reqn">(c_1, c_2)</code></p></a></li>
<li><a href='#asy_var_vus'><p>Asymptotic variance estimation for VUS</p></a></li>
<li><a href='#cv_knn'><p>Cross-validation for K nearest-neighbor regression</p></a></li>
<li><a href='#EOC'><p>A sub-data from Pre-PLCO Phase II Dataset</p></a></li>
<li><a href='#pre_data'><p>Preparing monotone ordered disease classes</p></a></li>
<li><a href='#print.vus_mar'><p>Print summary results of VUS</p></a></li>
<li><a href='#psglm'><p>Fitting verification models</p></a></li>
<li><a href='#rho_knn'><p>K nearest-neighbor (KNN) regression</p></a></li>
<li><a href='#rho_mlogit'><p>Fitting disease models via multinomial logistic models</p></a></li>
<li><a href='#ROCsurface'><p>Receiver operating characteristics surface for a continuous diagnostic test</p></a></li>
<li><a href='#vus_mar'><p>Estimation methods for volume under ROC surface (VUS) under MAR</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.0-6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-09</td>
</tr>
<tr>
<td>Title:</td>
<td>Bias-Corrected Methods for Estimating the ROC Surface of
Continuous Diagnostic Tests</td>
</tr>
<tr>
<td>Author:</td>
<td>Duc-Khanh To, with contributions from Monica Chiogna and Gianfranco Adimari</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Duc-Khanh To  &lt;toduc@stat.unipd.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The bias-corrected estimation methods for the receiver operating characteristics
  ROC surface and the volume under ROC surfaces (VUS) under missing at random (MAR)
  assumption.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.5.0), nnet, rgl, boot, stats, utils, graphics, parallel</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.2)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, markdown</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/toduckhanh/bcROCsurface">https://github.com/toduckhanh/bcROCsurface</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/toduckhanh/bcROCsurface/issues">https://github.com/toduckhanh/bcROCsurface/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-09 07:44:55 UTC; duckh</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-09 08:10:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='bcROCsurface-package'>
Bias-Corrected Methods for Estimating the ROC Surface of Continuous Diagnostic Tests
</h2><span id='topic+bcROCsurface-package'></span><span id='topic+bcROCsurface'></span>

<h3>Description</h3>

<p>This package provides tools for correcting verification bias in the evaluation of a continuous diagnostic test. More precisely, five bias-corrected methods for ROC surface and VUS inference are provided under MAR assumption, i.e., full imputation (FI), mean score imputation (MSI), inverse probability weighting (IPW), semiparametric efficient (SPE) and K nearest-neighbor (KNN) estimator.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> bcROCsurface</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0-6</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-09-09</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL 2 | GPL 3</td>
</tr>
<tr>
 <td style="text-align: left;">
Lazy load: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Major functions are <code><a href="#topic+rocs">rocs</a></code> and <code><a href="#topic+vus_mar">vus_mar</a></code>.
</p>


<h3>Author(s)</h3>

<p>Duc-Khanh To, with contributions from Monica Chiogna and Gianfranco Adimari
</p>
<p>Maintainer: Duc-Khanh To &lt;toduc@stat.unipd.it&gt;
</p>


<h3>References</h3>

<p>To Duc, K., Chiogna, M. and Adimari, G. (2020)
Nonparametric estimation of ROC surfaces in presence of verification bias.
<em>REVSTAT-Statistical Journal</em>. <b>18</b>, 5, 697â€“720.
</p>
<p>To Duc, K., Chiogna, M. and Adimari, G. (2016)
Bias-corrected methods for estimating the receiver operating characteristic surface of continuous diagnostic tests.
<em>Electronic Journal of Statistics</em>, <b>10</b>, 3063-3113.
</p>

<hr>
<h2 id='asy_cov_tcf'>Asymptotic variance-covariance estimation for True Class Fractions (TCFs) at the cut point <code class="reqn">(c_1, c_2)</code></h2><span id='topic+asy_cov_tcf'></span>

<h3>Description</h3>

<p><code>asy_cov_tcf</code> computes the asymptotic variance-covariance matrix of full data (FULL) and bias-corrected estimators (i.e. full imputation, mean score imputation, inverse probability weighting, semiparametric efficient and K nearest neighbor) of TCFs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asy_cov_tcf(
  obj_tcf,
  diag_test,
  dise_vec,
  veri_stat = NULL,
  rho_est = NULL,
  pi_est = NULL,
  boot = FALSE,
  n_boot = 250,
  parallel = FALSE,
  ncpus = ifelse(parallel, detectCores()/2, NULL)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="asy_cov_tcf_+3A_obj_tcf">obj_tcf</code></td>
<td>
<p>a result of a call to <code><a href="#topic+rocs.tcf">rocs.tcf</a></code>.</p>
</td></tr>
<tr><td><code id="asy_cov_tcf_+3A_diag_test">diag_test</code></td>
<td>
<p>a numeric vector containing the diagnostic test values. <code>NA</code> values of <code>diag_test</code> are not accepted.</p>
</td></tr>
<tr><td><code id="asy_cov_tcf_+3A_dise_vec">dise_vec</code></td>
<td>
<p>a n * 3  binary matrix with three columns, corresponding to the three classes of the disease status. In row i, 1 in column j indicates that the i-th subject belongs to class j, with j = 1, 2, 3. A row of <code>NA</code> values indicates a non-verified subject.</p>
</td></tr>
<tr><td><code id="asy_cov_tcf_+3A_veri_stat">veri_stat</code></td>
<td>
<p>a binary vector containing the verification status (1 verified, 0 not verified).</p>
</td></tr>
<tr><td><code id="asy_cov_tcf_+3A_rho_est">rho_est</code></td>
<td>
<p>a result of a call to <code><a href="#topic+rho_mlogit">rho_mlogit</a></code> of <code><a href="#topic+rho_knn">rho_knn</a></code> to fit the disease model.</p>
</td></tr>
<tr><td><code id="asy_cov_tcf_+3A_pi_est">pi_est</code></td>
<td>
<p>a result of a call to <code><a href="#topic+psglm">psglm</a></code> to fit the verification model.</p>
</td></tr>
<tr><td><code id="asy_cov_tcf_+3A_boot">boot</code></td>
<td>
<p>a logical value. Default = <code>FALSE</code>. If set to <code>TRUE</code>, a bootstrap resampling is employed to estimate the asymptotic variance-covariance matrix of bias-corrected TCFs.</p>
</td></tr>
<tr><td><code id="asy_cov_tcf_+3A_n_boot">n_boot</code></td>
<td>
<p>the number of bootstrap replicates, used when <code>boot = TRUE</code> or for FULL estimator. Usually this will be a single positive integer. Default 250.</p>
</td></tr>
<tr><td><code id="asy_cov_tcf_+3A_parallel">parallel</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, a parallel computing is employed in the bootstrap resampling process.</p>
</td></tr>
<tr><td><code id="asy_cov_tcf_+3A_ncpus">ncpus</code></td>
<td>
<p>number of processes to be used in parallel computing. Default is half of available cores.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For bias-corrected estimators of TCFs, the asymptotic variance-covariance matrix at a fixed cut point is estimated by using the Delta method. The function <code>asy_cov_tcf</code> implements the explicit forms presented in To Duc et al. (2016, 2020). In addition, the bootstrap procedure is also available.
</p>
<p>For FULL estimator, the asymptotic variance-covariance matrix is computed via bootstrap only.
</p>


<h3>Value</h3>

<p>This function returns an estimated asymptotic variance-covariance matrix for FULL estimator and bias-corrected estimators of TCFs at a fixed cut point.
</p>


<h3>References</h3>

<p>To Duc, K., Chiogna, M. and Adimari, G. (2016)
Bias-corrected methods for estimating the receiver operating characteristic surface of continuous diagnostic tests.
<em>Electronic Journal of Statistics</em>, <b>10</b>, 3063-3113.
</p>
<p>To Duc, K., Chiogna, M. and Adimari, G. (2020)
Nonparametric estimation of ROC surfaces in presence of verification bias.
<em>REVSTAT-Statistical Journal</em>. <b>18</b>, 5, 697â€“720.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EOC)

# FULL data estimator
dise_full &lt;- pre_data(EOC$D.full, EOC$CA125)
dise_vec_full &lt;- dise_full$dise_vec

full_tcf &lt;- rocs.tcf("full", diag_test = EOC$CA125, dise_vec = dise_vec_full,
                     cps = c(2, 4))
full_var &lt;- asy_cov_tcf(full_tcf, diag_test = EOC$CA125,
                        dise_vec = dise_vec_full)

# Preparing the missing disease status
dise_na &lt;- pre_data(EOC$D, EOC$CA125)
dise_vec_na &lt;- dise_na$dise_vec
dise_fact_na &lt;- dise_na$dise

rho_out &lt;- rho_mlogit(dise_fact_na ~ CA125 + CA153 + Age, data = EOC,
                      test = TRUE)

## FI estimator
fi_tcf &lt;- rocs.tcf("fi", diag_test = EOC$CA125, dise_vec = dise_vec_na,
                   veri_stat = EOC$V, rho_est = rho_out, cps = c(2, 4))
fi_var &lt;- asy_cov_tcf(fi_tcf, diag_test = EOC$CA125, dise_vec = dise_vec_na,
                      veri_stat = EOC$V, rho_est = rho_out)

## MSI estimator
msi_tcf &lt;- rocs.tcf("msi", diag_test = EOC$CA125, dise_vec = dise_vec_na,
                    veri_stat = EOC$V, rho_est = rho_out, cps = c(2, 4))
msi_var &lt;- asy_cov_tcf(msi_tcf, diag_test = EOC$CA125,
                       dise_vec = dise_vec_na, veri_stat = EOC$V,
                       rho_est = rho_out)

## IPW estimator
pi_out &lt;- psglm(V ~ CA125 + CA153 + Age, data = EOC, test = TRUE)

ipw_tcf &lt;- rocs.tcf("ipw", diag_test = EOC$CA125, dise_vec = dise_vec_na,
                    veri_stat = EOC$V, pi_est = pi_out, cps = c(2, 4))
ipw_var &lt;- asy_cov_tcf(ipw_tcf, diag_test = EOC$CA125,
                       dise_vec = dise_vec_na, veri_stat = EOC$V,
                       pi_est = pi_out)

## SPE estimator
spe_tcf &lt;- rocs.tcf("spe", diag_test = EOC$CA125, dise_vec = dise_vec_na,
                    veri_stat = EOC$V, rho_est = rho_out, pi_est = pi_out,
                    cps = c(2, 4))
spe_var &lt;- asy_cov_tcf(spe_tcf, diag_test = EOC$CA125,
                       dise_vec = dise_vec_na, veri_stat = EOC$V,
                       rho_est = rho_out, pi_est = pi_out)

## KNN estimators
x_mat &lt;- cbind(EOC$CA125, EOC$CA153, EOC$Age)
rho_1nn &lt;- rho_knn(x_mat = x_mat, dise_vec = dise_vec_na, veri_stat = EOC$V,
                   k = 1, type = "mahala")
knn_tcf &lt;- rocs.tcf("knn", diag_test = EOC$CA125, dise_vec = dise_vec_na,
                    veri_stat = EOC$V, rho_est = rho_1nn, cps = c(2, 4))
knn_var &lt;- asy_cov_tcf(knn_tcf, diag_test = EOC$CA125,
                       dise_vec = dise_vec_na, veri_stat = EOC$V,
                       rho_est = rho_1nn)


</code></pre>

<hr>
<h2 id='asy_var_vus'>Asymptotic variance estimation for VUS</h2><span id='topic+asy_var_vus'></span>

<h3>Description</h3>

<p><code>asy_var_vus</code> computes the asymptotic variance of full data (FULL) and bias-corrected estimators (i.e. full imputation, mean score imputation, inverse probability weighting, semiparametric efficient and K nearest neighbor) of VUS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asy_var_vus(
  obj_vus,
  diag_test,
  dise_vec,
  veri_stat = NULL,
  rho_est = NULL,
  pi_est = NULL,
  boot = FALSE,
  n_boot = 250,
  parallel = FALSE,
  ncpus = ifelse(parallel, detectCores()/2, NULL)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="asy_var_vus_+3A_obj_vus">obj_vus</code></td>
<td>
<p>a result of a call to <code><a href="#topic+vus_mar">vus_mar</a></code>.</p>
</td></tr>
<tr><td><code id="asy_var_vus_+3A_diag_test">diag_test</code></td>
<td>
<p>a numeric vector containing the diagnostic test values. <code>NA</code> values of <code>diag_test</code> are not accepted.</p>
</td></tr>
<tr><td><code id="asy_var_vus_+3A_dise_vec">dise_vec</code></td>
<td>
<p>a n * 3  binary matrix with three columns, corresponding to the three classes of the disease status. In row i, 1 in column j indicates that the i-th subject belongs to class j, with j = 1, 2, 3. A row of <code>NA</code> values indicates a non-verified subject.</p>
</td></tr>
<tr><td><code id="asy_var_vus_+3A_veri_stat">veri_stat</code></td>
<td>
<p>a binary vector containing the verification status (1 verified, 0 not verified).</p>
</td></tr>
<tr><td><code id="asy_var_vus_+3A_rho_est">rho_est</code></td>
<td>
<p>a result of a call to <code><a href="#topic+rho_mlogit">rho_mlogit</a></code> of <code><a href="#topic+rho_knn">rho_knn</a></code> to fit the disease model.</p>
</td></tr>
<tr><td><code id="asy_var_vus_+3A_pi_est">pi_est</code></td>
<td>
<p>a result of a call to <code><a href="#topic+psglm">psglm</a></code> to fit the verification model.</p>
</td></tr>
<tr><td><code id="asy_var_vus_+3A_boot">boot</code></td>
<td>
<p>a logical value. Default = <code>FALSE</code>. If set to <code>TRUE</code>, a bootstrap resampling is employed to estimate the asymptotic variance of the bias-corrected VUS estimators.</p>
</td></tr>
<tr><td><code id="asy_var_vus_+3A_n_boot">n_boot</code></td>
<td>
<p>the number of bootstrap replicates, which is used for FULL or KNN estimators, or option <code>boot = TRUE</code>. The defaut is 250.</p>
</td></tr>
<tr><td><code id="asy_var_vus_+3A_parallel">parallel</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, a parallel computing is employed in the bootstrap resampling process.</p>
</td></tr>
<tr><td><code id="asy_var_vus_+3A_ncpus">ncpus</code></td>
<td>
<p>number of processes to be used in parallel computing. Default is half of available cores.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the FULL estimator, a bootstrap resampling process or Jackknife approach is used to estimate the asymptotic variance, whereas, a bootstrap resampling process is employed to obtain the asymptotic variance of K nearest neighbor estimator.
</p>
<p>For the full imputation, mean score imputation, inverse probability weighting and semiparametric efficient estimators of VUS, the asymptotic variances are computed by using the explicit form. Furthermore, a bootstrap procedure is also available, useful in case of small sample sizes.
</p>


<h3>Value</h3>

<p><code>asy_var_vus</code> returns a estimated value of the asymptotic variance.
</p>


<h3>References</h3>

<p>To Duc, K., Chiogna, M. and Adimari, G. (2020)
Nonparametric estimation of ROC surfaces in presence of verification bias.
<em>REVSTAT-Statistical Journal</em>. <b>18</b>, 5, 697â€“720.
</p>
<p>To Duc, K., Chiogna, M. and Adimari, G. (2016)
Bias-corrected methods for estimating the receiver operating characteristic surface of continuous diagnostic tests.
<em>Electronic Journal of Statistics</em>, <b>10</b>, 3063-3113.
</p>
<p>Guangming, P., Xiping, W. and Wang, Z. (2013)
Non-parameteric statistical inference for $P(X &lt; Y &lt; Z)$.
<em>Sankhya A</em>, <b>75</b>, 1, 118-138.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EOC)

# Preparing the missing disease status
dise_na &lt;- pre_data(EOC$D, EOC$CA125)
dise_vec_na &lt;- dise_na$dise_vec
dise_fact_na &lt;- dise_na$dise

rho_out &lt;- rho_mlogit(dise_fact_na ~ CA125 + CA153 + Age, data = EOC,
                      test = TRUE)
vus_fi &lt;- vus_mar("fi", diag_test = EOC$CA125, dise_vec = dise_vec_na,
                  veri_stat = EOC$V, rho_est = rho_out, ci = FALSE)
var_fi &lt;- asy_var_vus(vus_fi, diag_test = EOC$CA125, dise_vec = dise_vec_na,
                      veri_stat = EOC$V, rho_est = rho_out)



</code></pre>

<hr>
<h2 id='cv_knn'>Cross-validation for K nearest-neighbor regression</h2><span id='topic+cv_knn'></span>

<h3>Description</h3>

<p>This function calculates the estimated cross-validation prediction error for K nearest-neighbor regression and returns a suitable choice for K.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_knn(x_mat, dise_vec, veri_stat, k_list = NULL, type = "eucli", plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv_knn_+3A_x_mat">x_mat</code></td>
<td>
<p>a numeric design matrix, which used in <code><a href="#topic+rho_knn">rho_knn</a></code> to estimate probabilities of the disease status.</p>
</td></tr>
<tr><td><code id="cv_knn_+3A_dise_vec">dise_vec</code></td>
<td>
<p>a n * 3  binary matrix with three columns, corresponding to the three classes of the disease status. In row i, 1 in column j indicates that the i-th subject belongs to class j, with j = 1, 2, 3. A row of <code>NA</code> values indicates a non-verified subject.</p>
</td></tr>
<tr><td><code id="cv_knn_+3A_veri_stat">veri_stat</code></td>
<td>
<p>a binary vector containing the verification status (1 verified, 0 not verified).</p>
</td></tr>
<tr><td><code id="cv_knn_+3A_k_list">k_list</code></td>
<td>
<p>a list of candidate values for K. If <code>NULL</code>(the default), the set <code class="reqn">\{1, 2, ..., n.ver\}</code> is employed, where, <code class="reqn">n.ver</code> is the number of verified subjects.</p>
</td></tr>
<tr><td><code id="cv_knn_+3A_type">type</code></td>
<td>
<p>a type of distance, see <code><a href="#topic+rho_knn">rho_knn</a></code> for more details. Default <code>"eucli"</code>.</p>
</td></tr>
<tr><td><code id="cv_knn_+3A_plot">plot</code></td>
<td>
<p>if <code>TRUE</code>, a plot of cross-validation prediction error is produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data are divided into two groups, the first contains the data corresponding to veri_stat = 1, whereas the second contains the data corresponding to veri_stat = 0. In the first group, the discrepancy between the true disease status and the KNN estimates of the probabilities of the disease status is computed by varying <code>k</code> from 1 to the number of verification subjects, see To Duc et al. (2020). The optimal value of <code>k</code> is the value that corresponds to the smallest value of the discrepancy.
</p>


<h3>Value</h3>

<p>A suitable choice for k is returned.
</p>


<h3>References</h3>

<p>To Duc, K., Chiogna, M. and Adimari, G. (2020)
Nonparametric estimation of ROC surfaces in presence of verification bias.
<em>REVSTAT-Statistical Journal</em>. <b>18</b>, 5, 697â€“720.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EOC)
x_mat &lt;- cbind(EOC$CA125, EOC$CA153, EOC$Age)
dise_na &lt;- pre_data(EOC$D, EOC$CA125)
dise_vec_na &lt;- dise_na$dise_vec
cv_knn(x_mat, dise_vec_na, EOC$V, type = "mahala", plot = TRUE)

</code></pre>

<hr>
<h2 id='EOC'>A sub-data from Pre-PLCO Phase II Dataset</h2><span id='topic+EOC'></span>

<h3>Description</h3>

<p>A subset of the Pre-PLCO Phase II Dataset from the SPORE/Early Detection Network/Prostate, Lung, Colon, and Ovarian Cancer Ovarian Validation Study. This data deals with epithelial ovarian cancer (EOC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EOC
</code></pre>


<h3>Format</h3>

<p>A data frame with 278 observations on the following 6 variables.
</p>

<dl>
<dt><code>D.full</code></dt><dd><p>a factor with 3 levels of disease status, 1, 2, 3. The levels correspond to benign disease, early stage (I and II) and late stage (III and IV).</p>
</dd>
<dt><code>V</code></dt><dd><p>a binary vector containing the verification status. 1 or 0 indicates verified or non verified subject.</p>
</dd>
<dt><code>D</code></dt><dd><p>a copy of <code>D.full</code> with the missing values. <code>NA</code> values correspond to non verified subjects.</p>
</dd>
<dt><code>CA125</code></dt><dd><p>a numeric vector of biomarker CA125 (used as diagnostic test).</p>
</dd>
<dt><code>CA153</code></dt><dd><p>a numeric vector of biomarker CA153 (used as covariate).</p>
</dd>
<dt><code>Age</code></dt><dd><p>a numeric vector containing the age of patients.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The Pre-PLCO datasets contain some demographic variables (Age, Race, ect.) and 59 markers measured by 4 sites (Harvard, FHCRC, MD Anderson, and Pittsburgh). Some interest biomarkers are: CA125, CA153, CA19&ndash;9, CA72&ndash;4, Kallikrein 6 (KLK6), HE4 and Chitinase (YKL40). The original data set consist of control groups and three classes of EOC: benign disease, early stage (I and II) and late stage (III and IV). In the sub data set, the  biomakers CA125 and CA153 (measured at Harvard laboratories), the age of patients, and three classes of EOC are collected. In addition, the verification status and the missing disease status are also added.
</p>
<p>The verification status <code class="reqn">V</code> is generated by using the following selection process:
</p>
<p style="text-align: center;"><code class="reqn"> P(V = 1) = 0.05 + 0.35 I(CA125 &gt; 0.87) + 0.25 I(CA153 &gt; 0.3) + 0.35 I(Age &gt; 45). </code>
</p>

<p>This process leads to 63.4% patients selected to undergo disease verification.
</p>
<p>The missing disease status D are the copies of the full disease status D.full, but some values corresponding to <code class="reqn">V = 0</code> are deleted (refered as <code>NA</code> values).
</p>


<h3>Source</h3>

<p>SPORE/EDRN/PRE-PLCO Ovarian Phase II Validation Study: <a href="https://edrn-labcas.jpl.nasa.gov/labcas-ui/c/index.html?collection_id=Pre-PLCO_Phase_II_Dataset">https://edrn-labcas.jpl.nasa.gov/labcas-ui/c/index.html?collection_id=Pre-PLCO_Phase_II_Dataset</a>.
</p>

<hr>
<h2 id='pre_data'>Preparing monotone ordered disease classes</h2><span id='topic+pre_data'></span>

<h3>Description</h3>

<p><code>pre_data</code> is used to check and make a suitable monotone increasing ordering of the disease classes. In addition, this function also creates a binary matrix format of disease status to pass into the functions of <code>bcROCsurface</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pre_data(dise, diag_test, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pre_data_+3A_dise">dise</code></td>
<td>
<p>a numeric vector/factor containing the disease status.</p>
</td></tr>
<tr><td><code id="pre_data_+3A_diag_test">diag_test</code></td>
<td>
<p>a numeric vector containing the diagnostic test values. <code>NA</code> values are not admitted.</p>
</td></tr>
<tr><td><code id="pre_data_+3A_plot">plot</code></td>
<td>
<p>if TRUE (the default) then a boxplot of diagnostic test based on three ordered groups is produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ROC surface analysis implemented in the package is coherent when the ordering of the diagnostic classes is monotone increasing. That is, for a diagnostic test <code class="reqn">T</code> and three disease classes, 1, 2 and 3, the monotone increasing ordering of interest is <code class="reqn">T_1 &lt; T_2 &lt; T_3</code>. Here, <code class="reqn">T_1</code>, <code class="reqn">T_2</code> and <code class="reqn">T_3</code> are the measurements of diagnostic test <code class="reqn">T</code> corresponding to class 1, 2 and 3, respectively. Note that, if an umbrella or tree ordering is of interest, then the results of ROC surface analysis is not reliable.
</p>
<p>In order to find out the monotone ordering, we compute the medians of <code class="reqn">T_1</code>, <code class="reqn">T_2</code> and <code class="reqn">T_3</code>, and then sort the three medians in ascending order. After that, the three disease classes are reordered corresponding to the order of medians.
</p>
<p>To be used in the functions of package <code>bcROCsurface</code>, the vector of disease status must be presented as a n * 3 binary matrix with the three columns, corresponding to the three classes.
</p>
<p>With real data, the application of this function is the first step in the use of ROC analysis. Note that, if the user is sure that the disease classes follow a monotone increasing ordering and the disease matrix is available, then the use of <code>pre_data</code> is not necessary.
</p>


<h3>Value</h3>

<p>This function returns a list containting a factor <code>dise</code> of ordered disease status and a binary matrix <code>dise_vec</code> of the disease status and a vector <code>order</code> containing the sequence of class labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EOC)
dise_full &lt;- pre_data(EOC$D.full, EOC$CA125)


</code></pre>

<hr>
<h2 id='print.vus_mar'>Print summary results of VUS</h2><span id='topic+print.vus_mar'></span>

<h3>Description</h3>

<p><code>print.vus_mar</code> prints the results for the output of function <code><a href="#topic+vus_mar">vus_mar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vus_mar'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.vus_mar_+3A_x">x</code></td>
<td>
<p>an object of class &quot;vus_mar&quot;, a result of a call to <code><a href="#topic+vus_mar">vus_mar</a></code>.</p>
</td></tr>
<tr><td><code id="print.vus_mar_+3A_digits">digits</code></td>
<td>
<p>minimal number of significant digits, see <code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="print.vus_mar_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="base.html#topic+print">print</a></code> method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.vus_mar</code> shows a nice format of the summary table for the VUS estimate results. Some information on the diagnostic test, the fitted values of VUS, and confidence intervals are shown.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vus_mar">vus_mar</a></code>
</p>

<hr>
<h2 id='psglm'>Fitting verification models</h2><span id='topic+psglm'></span>

<h3>Description</h3>

<p><code>psglm</code> is used to fit generalized linear models to the verification process. This function requires a symbolic formula of the linear predictor, and a specified regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psglm(formula, data, model = "logit", test = FALSE, trace = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psglm_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot;: a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="psglm_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="psglm_+3A_model">model</code></td>
<td>
<p>a specified model to be used in the fitting. The suggestion regression models are logit, probit and threshold. If <code>model</code> is ignored, then <code>psglm</code> use a default model as logit.</p>
</td></tr>
<tr><td><code id="psglm_+3A_test">test</code></td>
<td>
<p>a logical value indicating whether p-values of the regression coefficients should be returned.</p>
</td></tr>
<tr><td><code id="psglm_+3A_trace">trace</code></td>
<td>
<p>switch for tracing estimation process. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="psglm_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code>glm</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>psglm</code> estimates the verification probabilities of the patients. The suggestion model is designed as a list containing: logit, probit and threshold.
</p>


<h3>Value</h3>

<p><code>psglm</code> returns a list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>coeff</code></td>
<td>
<p>a vector of estimated coefficients.</p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p>fitted values of the model.</p>
</td></tr>
<tr><td><code>Hess</code></td>
<td>
<p>the Hessian of the measure of fit at the estimated coefficients.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>a design model matrix.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the formula supplied.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>the model object used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EOC)
out &lt;- psglm(V ~ CA125 + CA153 + Age, data = EOC, test = TRUE)


</code></pre>

<hr>
<h2 id='rho_knn'>K nearest-neighbor (KNN) regression</h2><span id='topic+rho_knn'></span>

<h3>Description</h3>

<p><code>rho_knn</code> uses the KNN approach to estimate the probabilities of the disease status in case of three categories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rho_knn(
  x_mat,
  dise_vec,
  veri_stat,
  k,
  type = c("eucli", "manha", "canber", "lagran", "mahala"),
  trace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rho_knn_+3A_x_mat">x_mat</code></td>
<td>
<p>a numeric design matrix.</p>
</td></tr>
<tr><td><code id="rho_knn_+3A_dise_vec">dise_vec</code></td>
<td>
<p>a n * 3  binary matrix with three columns, corresponding to the three classes of the disease status. In row i, 1 in column j indicates that the i-th subject belongs to class j, with j = 1, 2, 3. A row of <code>NA</code> values indicates a non-verified subject.</p>
</td></tr>
<tr><td><code id="rho_knn_+3A_veri_stat">veri_stat</code></td>
<td>
<p>a binary vector containing the verification status (1 verified, 0 not verified).</p>
</td></tr>
<tr><td><code id="rho_knn_+3A_k">k</code></td>
<td>
<p>an integer value/vector, which indicates the number of nearest neighbors. It should be less than the number of the verification subjects.</p>
</td></tr>
<tr><td><code id="rho_knn_+3A_type">type</code></td>
<td>
<p>a distance measure.</p>
</td></tr>
<tr><td><code id="rho_knn_+3A_trace">trace</code></td>
<td>
<p>switch for tracing estimation process. Default <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>type</code> should be selected as one of <code>"eucli"</code>, <code>"manha"</code>, <code>"canber"</code>, <code>"lagran"</code>, <code>"mahala"</code> corresponding to Euclidean, Manhattan, Canberra, Lagrange and Mahalanobis distance. In practice, the selection of a suitable distance is typically dictated by features of the data and possible subjective evaluations. For example, if the covariates are heterogeneous with respect to their variances (which is particularly true when the variables are measured on heterogeneous scales), the choice of the Mahalanobis distance may be a good choice.
</p>
<p>For the number of nearest neighbors, a small value of <code>k</code>, within the range 1-3, may be a good choice. In general, the choice of <code>k</code> may depend on the dimension of the feature space, and propose to use cross&ndash;validation to find <code>k</code> in case of high&ndash;dimensional covariate. See <code><a href="#topic+cv_knn">cv_knn</a></code>.
</p>


<h3>Value</h3>

<p><code>rho_knn</code> returns a list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>values</code></td>
<td>
<p>estimates of the probabilities.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>a design model matrix.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>the number of nearest neighbors.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>the chosen distance.</p>
</td></tr>
</table>


<h3>References</h3>

<p>To Duc, K., Chiogna, M. and Adimari, G. (2020)
Nonparametric estimation of ROC surfaces in presence of verification bias.
<em>REVSTAT-Statistical Journal</em>. <b>18</b>, 5, 697â€“720.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EOC)
x_mat &lt;- cbind(EOC$CA125, EOC$CA153, EOC$Age)
dise_na &lt;- pre_data(EOC$D, EOC$CA125)
dise_vec_na &lt;- dise_na$dise_vec

## Euclidean distance, k = 1
out_ecul_1nn &lt;- rho_knn(x_mat, dise_vec_na, EOC$V, k = 1, type = "eucli")

## Manhattan distance, k = 1
out_manh_1nn &lt;- rho_knn(x_mat, dise_vec_na, EOC$V, k = 1, type = "manha")

## Canberra distance, k = 3
out_canb_1nn &lt;- rho_knn(x_mat, dise_vec_na, EOC$V, k = 3, type = "canber")

## Lagrange distance, k = 3
out_lagr_1nn &lt;- rho_knn(x_mat, dise_vec_na, EOC$V, k = 3, type = "lagran")

## Mahalanobis distance, k = c(1,3)
out_maha_13nn &lt;- rho_knn(x_mat, dise_vec_na, EOC$V, k = c(1, 3),
                         type = "mahala")

</code></pre>

<hr>
<h2 id='rho_mlogit'>Fitting disease models via multinomial logistic models</h2><span id='topic+rho_mlogit'></span>

<h3>Description</h3>

<p><code>rho_mlogit</code> is used to fit multinomial logistic models to the disease process in the verified subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rho_mlogit(formula, data, test = FALSE, maxit = 500, trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rho_mlogit_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot;: a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="rho_mlogit_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="rho_mlogit_+3A_test">test</code></td>
<td>
<p>a logical value indicating whether p-values of the regression coefficients should be returned. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rho_mlogit_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations. Default 500.</p>
</td></tr>
<tr><td><code id="rho_mlogit_+3A_trace">trace</code></td>
<td>
<p>switch for tracing estimation process. Default <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the formula, the response must be a result of <code><a href="#topic+pre_data">pre_data</a></code>, a factor with three levels, say 1, 2, 3. These levels correspond to three classes of disease status, e.g., non-dieseased, intermediate, diseased. The last class (class 3) is considered as the reference level in multinomal logistic model. In presence of verification bias, the missing (<code>NA</code>) values correspond to non verified subjects.
</p>


<h3>Value</h3>

<p><code>rho_mlogit</code> returns a list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>coeff</code></td>
<td>
<p>a vector of estimated coefficients.</p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p>fitted values of the model.</p>
</td></tr>
<tr><td><code>Hess</code></td>
<td>
<p>the Hessian of the measure of fit at the estimated coefficients.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>the disease status vector used.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>a design model matrix.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the fomular supplied.</p>
</td></tr>
</table>


<h3>References</h3>

<p>To Duc, K., Chiogna, M. and Adimari, G. (2016)
Bias-corrected methods for estimating the receiver operating characteristic surface of continuous diagnostic tests.
<em>Electronic Journal of Statistics</em>, <b>10</b>, 3063-3113.
</p>


<h3>See Also</h3>

<p><code><a href="nnet.html#topic+multinom">multinom</a></code>, <code><a href="nnet.html#topic+nnet">nnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EOC)
dise_na &lt;- pre_data(EOC$D, EOC$CA125)
dise_fact_na &lt;- dise_na$dise
out &lt;- rho_mlogit(dise_fact_na ~ CA125 + CA153 + Age, data = EOC,
                  test = TRUE, trace = TRUE)

</code></pre>

<hr>
<h2 id='ROCsurface'>Receiver operating characteristics surface for a continuous diagnostic test</h2><span id='topic+ROCsurface'></span><span id='topic+rocs.tcf'></span><span id='topic+rocs'></span>

<h3>Description</h3>

<p><code>rocs.tcf</code> is used to obtain bias-corrected estimates of the true class fractions (TCFs) for evaluating the accuracy of a continuous diagnostic test for a given cut point <code class="reqn">(c_1, c_2)</code>, with <code class="reqn">c_1 &lt; c_2</code>.
</p>
<p><code>rocs</code> provides bias-corrected estimates of the ROC surfaces of the continuous diagnostic test by using TCF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rocs.tcf(
  method = "full",
  diag_test,
  dise_vec,
  veri_stat = NULL,
  rho_est = NULL,
  pi_est = NULL,
  cps
)

rocs(
  method = "full",
  diag_test,
  dise_vec,
  veri_stat,
  rho_est = NULL,
  pi_est = NULL,
  ncp = 100,
  plot = TRUE,
  ellipsoid = FALSE,
  cpst = NULL,
  ci_level = 0.95,
  surf_col = c("gray40", "green"),
  boot = FALSE,
  n_boot = 250,
  parallel = FALSE,
  ncpus = ifelse(parallel, detectCores()/2, NULL),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ROCsurface_+3A_method">method</code></td>
<td>
<p>a estimation method to be used for estimating the true class fractions in presence of verification bias. See 'Details'.</p>
</td></tr>
<tr><td><code id="ROCsurface_+3A_diag_test">diag_test</code></td>
<td>
<p>a numeric vector containing the diagnostic test values. <code>NA</code> values are not allowed.</p>
</td></tr>
<tr><td><code id="ROCsurface_+3A_dise_vec">dise_vec</code></td>
<td>
<p>a n * 3  binary matrix with the three columns, corresponding to three classes of the disease status. In row i, 1 in column j indicates that the i-th subject belongs to class j, with j = 1, 2, 3. A row of <code>NA</code> values indicates a non-verified subject.</p>
</td></tr>
<tr><td><code id="ROCsurface_+3A_veri_stat">veri_stat</code></td>
<td>
<p>a binary vector containing the verification status (1 verified, 0 not verified).</p>
</td></tr>
<tr><td><code id="ROCsurface_+3A_rho_est">rho_est</code></td>
<td>
<p>a result of a call to <code><a href="#topic+rho_mlogit">rho_mlogit</a></code> of <code><a href="#topic+rho_knn">rho_knn</a></code> to fit the disease model.</p>
</td></tr>
<tr><td><code id="ROCsurface_+3A_pi_est">pi_est</code></td>
<td>
<p>a result of a call to <code><a href="#topic+psglm">psglm</a></code> to fit the verification model.</p>
</td></tr>
<tr><td><code id="ROCsurface_+3A_cps">cps</code></td>
<td>
<p>a cut point <code class="reqn">(c_1, c_2)</code>, with <code class="reqn">c_1 &lt; c_2</code>, which used to estimate TCFs. If <code>m</code> estimates of TCFs are required, <code>cps</code> must be matrix with <code>m</code> rows and 2 columns.</p>
</td></tr>
<tr><td><code id="ROCsurface_+3A_ncp">ncp</code></td>
<td>
<p>the dimension of cut point grid. It is used to determine the cut points (see 'Details'). Default 100.</p>
</td></tr>
<tr><td><code id="ROCsurface_+3A_plot">plot</code></td>
<td>
<p>if <code>TRUE</code>(the default), a 3D plot of ROC surface is produced.</p>
</td></tr>
<tr><td><code id="ROCsurface_+3A_ellipsoid">ellipsoid</code></td>
<td>
<p>a logical value. If TRUE, adds an ellipsoidal confidence region for TCFs at a specified cut point to current plot of ROC surface.</p>
</td></tr>
<tr><td><code id="ROCsurface_+3A_cpst">cpst</code></td>
<td>
<p>a specified cut point, which used to construct the ellipsoid confidence region. If <code>m</code> ellipsoid confidence regions are required, <code>cpst</code> must be matrix with <code>m</code> rows and 2 columns. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ROCsurface_+3A_ci_level">ci_level</code></td>
<td>
<p>an confidence level to be used for constructing the ellipsoid confidence region; default 0.95.</p>
</td></tr>
<tr><td><code id="ROCsurface_+3A_surf_col">surf_col</code></td>
<td>
<p>color to be used for plotting ROC surface and ellipsoid.</p>
</td></tr>
<tr><td><code id="ROCsurface_+3A_boot">boot</code></td>
<td>
<p>a logical value. Default = <code>FALSE</code>. If set to <code>TRUE</code>, a bootstrap resampling is employed to estimate the asymptotic variance-covariance matrix of TCFs at the cut point <code>cpst</code>. See more details in <code><a href="#topic+asy_cov_tcf">asy_cov_tcf</a></code>.</p>
</td></tr>
<tr><td><code id="ROCsurface_+3A_n_boot">n_boot</code></td>
<td>
<p>the number of bootstrap replicates, which is used for FULL estimator, or option <code>boot = TRUE</code>. Usually this will be a single positive integer. Default 250.</p>
</td></tr>
<tr><td><code id="ROCsurface_+3A_parallel">parallel</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, a parallel computing is employed to the bootstrap resampling process.</p>
</td></tr>
<tr><td><code id="ROCsurface_+3A_ncpus">ncpus</code></td>
<td>
<p>number of processes to be used in parallel computing. Default is half of of available cores.</p>
</td></tr>
<tr><td><code id="ROCsurface_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code><a href="rgl.html#topic+plot3d">plot3d</a></code>, <code><a href="rgl.html#topic+surface3d">surface3d</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a three-class diagnostic problem, quantities used to evaluate the accuracy of a diagnostic test are the true class fractions (TCFs). For a given pair of cut points <code class="reqn">(c_1, c_2)</code> such that <code class="reqn">c_1 &lt; c_2</code>, subjects are classified into class 1 (<code class="reqn">D_1</code>) if <code class="reqn">T &lt; c_1</code>; class 2 (<code class="reqn">D_2</code>) if <code class="reqn">c_1 \le T &lt; c_2</code>; class 3 (<code class="reqn">D_3</code>) otherwise. The true class fractions of the test <code class="reqn">T</code> at <code class="reqn">(c_1, c_2)</code> are defined as
</p>
<p style="text-align: center;"><code class="reqn">TCF_1(c_1) = P(T &lt; c_1| D_1 = 1) = 1 - P(T \ge c_1| D_1 = 1),</code>
</p>

<p style="text-align: center;"><code class="reqn">TCF_2(c_1, c_2) = P(c_1 \le T &lt; c_2| D_2 = 1) = P(T \ge c_1| D_2 = 1) - P(T \ge c_2| D_2 = 1),</code>
</p>

<p style="text-align: center;"><code class="reqn">TCF_3(c_2) = P(T &gt; c_2| D_3 = 1) = P(T \ge c_2| D_3 = 1). </code>
</p>

<p>The receiver operating characteristic (ROC) surface is the plot of <code class="reqn">TCF_1</code>, <code class="reqn">TCF_2</code> and <code class="reqn">TCF_3</code> by varying the cut point <code class="reqn">(c_1, c_2)</code> in the domain of the diagnostic test. The cut points <code class="reqn">(c_1, c_2)</code> are produced by designing a cut point grid with <code>ncp</code> dimension. In this grid, the points satisfying <code class="reqn">c_1 &lt; c_2</code> are selected as the cut points. The number of the cut points are obtained as <code class="reqn">ncp(ncp - 1)/2</code>, for example, the default is 4950.
</p>
<p>These functions implement the bias-corrected estimators in To Duc et al (2016, 2020) for estimating TCF of a three-class continuous diagnostic test in presence of verification bias. The estimators work under MAR assumption. Five methods are provided, namely:
</p>

<ul>
<li><p> Full imputation (FI): uses the fitted values of the disease model to replace the true disease status (both of missing and non-missing values).
</p>
</li>
<li><p> Mean score imputation (MSI): replaces only the missing values by the fitted values of the disease model.
</p>
</li>
<li><p> Inverse probability weighted (IPW): weights each observation in the verification sample by the inverse of the sampling fraction (i.e. the probability that the subject was selected for verification).
</p>
</li>
<li><p> Semiparametric efficient (SPE): replaces the true disease status by the double robust estimates.
</p>
</li>
<li><p> K nearest-neighbor (KNN): uses K nearest-neighbor imputation to obtain the missing values of the true disease status.
</p>
</li></ul>

<p>The argument <code>method</code> must be selected from the collection of the bias-corrected methods, i.e., <code>"full"</code>, <code>"fi"</code>, <code>"msi"</code>, <code>"ipw"</code>, <code>"spe"</code> and <code>"knn"</code>.
</p>
<p>The ellipsoidal confidence region of TCFs at a given cut point can be constructed by using a normal approximation and plotted in the ROC surface space. The confidence level (default) is 0.95.
</p>
<p>Note that, before using the functions <code>rocs</code> and <code>rocs.tcf</code>, the use of <code><a href="#topic+pre_data">pre_data</a></code> might be needed to check the monotone ordering disease classes and to create the matrix format for disease status.
</p>


<h3>Value</h3>

<p><code>rocs</code> returns a list, with the following components:
</p>
<table role = "presentation">
<tr><td><code>vals</code></td>
<td>
<p>the estimates of TCFs at all cut points.</p>
</td></tr>
<tr><td><code>cpoint</code></td>
<td>
<p>the cut points are used to construct the ROC surface.</p>
</td></tr>
<tr><td><code>ncp</code></td>
<td>
<p>dimension of the cut point grid.</p>
</td></tr>
<tr><td><code>cpst</code></td>
<td>
<p>the cut points are used to construct the ellipsoidal confidence regions.</p>
</td></tr>
<tr><td><code>tcf</code></td>
<td>
<p>the estimates of TCFs at the cut points <code>cpst</code>.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>an integer code or vector. 1 indicates the ellipsoidal confidence region is available.</p>
</td></tr>
</table>
<p><code>rocs.tcf</code> returns a vector having estimates of TCFs at a cut point when <code>cps</code> is a vector with two elements, or a list of estimates of TCFs at <code>m</code> cut points when <code>cps</code> is a <code>m*2</code> matrix. In addition, some attributes called <code>theta</code>, <code>beta</code>, <code>cp</code> and <code>name</code> are given. Here, <code>theta</code> is a probability vector, with 3 element, corresponding to the disease prevalence rates of three classes. <code>beta</code> is also a probability vector having 4 components, which are used to compute TCFs, see To Duc el al. (2016, 2020) for more details. <code>cp</code> is the specified cut point that is used to estimate TCFs. <code>name</code> indicates the method used to estimate TCFs. These attributes are required to compute the asymptotic variance-covariance matrix of TCFs at the given cut point.
</p>


<h3>References</h3>

<p>To Duc, K., Chiogna, M. and Adimari, G. (2016)
Bias-corrected methods for estimating the receiver operating characteristic surface of continuous diagnostic tests.
<em>Electronic Journal of Statistics</em>, <b>10</b>, 3063-3113.
</p>
<p>To Duc, K., Chiogna, M. and Adimari, G. (2020)
Nonparametric estimation of ROC surfaces in presence of verification bias.
<em>REVSTAT-Statistical Journal</em>, <b>18</b>, 5, 697â€“720.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psglm">psglm</a></code>, <code><a href="#topic+rho_mlogit">rho_mlogit</a></code>, <code><a href="rgl.html#topic+plot3d">plot3d</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EOC)
head(EOC)

## Not run: 
# FULL data estimator
dise_full &lt;- pre_data(EOC$D.full, EOC$CA125)
dise_vec_full &lt;- dise_full$dise_vec
if(requireNamespace("webshot2", quietly = TRUE)){
   rocs("full", diag_test = EOC$CA125, dise_vec = dise_vec_full, ncp = 30,
        ellipsoid = TRUE, cpst = c(-0.56, 2.31))
}

## End(Not run)

## Not run: 
# Preparing the missing disease status
dise_na &lt;- pre_data(EOC$D, EOC$CA125)
dise_vec_na &lt;- dise_na$dise_vec
dise_fact_na &lt;- dise_na$dise

# FI estimator
rho_out &lt;- rho_mlogit(dise_fact_na ~ CA125 + CA153 + Age, data = EOC,
                      test = TRUE)
if (requireNamespace("webshot2", quietly = TRUE)) {
   rocs("fi", diag_test = EOC$CA125, dise_vec = dise_vec_na,
        veri_stat = EOC$V, rho_est = rho_out, ncp = 30)
}

# Plot ROC surface and add ellipsoid confidence region
if (requireNamespace("webshot2", quietly = TRUE)) {
   rocs("fi", diag_test = EOC$CA125, dise_vec = dise_vec_na,
        veri_stat = EOC$V, rho_est = rho_out, ncp = 30,
        ellipsoid = TRUE, cpst = c(-0.56, 2.31))
}

# MSI estimator
if (requireNamespace("webshot2", quietly = TRUE)) {
   rocs("msi", diag_test = EOC$CA125, dise_vec = dise_vec_na,
        veri_stat = EOC$V, rho_est = rho_out, ncp = 30,
        ellipsoid = TRUE, cpst = c(-0.56, 2.31))
}

# IPW estimator
pi_out &lt;- psglm(V ~ CA125 + CA153 + Age, data = EOC, test = TRUE)
if (requireNamespace("webshot2", quietly = TRUE)) {
   rocs("ipw", diag_test = EOC$CA125, dise_vec = dise_vec_na,
        veri_stat = EOC$V, pi_est = pi_out, ncp = 30,
        ellipsoid = TRUE, cpst = c(-0.56, 2.31))
}

# SPE estimator
if (requireNamespace("webshot2", quietly = TRUE)) {
   rocs("spe", diag_test = EOC$CA125, dise_vec = dise_vec_na,
        veri_stat = EOC$V, rho_est = rho_out, ncp = 30,
        pi_est = pi_out, ellipsoid = TRUE, cpst = c(-0.56, 2.31))
}

# NN estimator
x_mat &lt;- cbind(EOC$CA125, EOC$CA153, EOC$Age)
k_opt &lt;- cv_knn(x_mat = x_mat, dise_vec = dise_vec_na, veri_stat = EOC$V,
                type = "mahala", plot = TRUE)
rho_k_opt &lt;- rho_knn(x_mat = x_mat, dise_vec = dise_vec_na,
                     veri_stat = EOC$V, k = k_opt, type = "mahala")
if (requireNamespace("webshot2", quietly = TRUE)) {
   rocs("knn", diag_test = EOC$CA125, dise_vec = dise_vec_na,
        veri_stat = EOC$V, rho_est = rho_k_opt, ncp = 30,
        ellipsoid = TRUE, cpst = c(-0.56, 2.31))
}

## Compute TCFs at three cut points
cutps &lt;- rbind(c(0, 0.5), c(0, 1), c(0.5, 1))
rocs.tcf("spe", diag_test = EOC$CA125, dise_vec = dise_vec_na,
         veri_stat = EOC$V, rho_est = rho_out, ncp = 30,
         pi_est = pi_out, cps = cutps)

## End(Not run)

</code></pre>

<hr>
<h2 id='vus_mar'>Estimation methods for volume under ROC surface (VUS) under MAR</h2><span id='topic+vus_mar'></span>

<h3>Description</h3>

<p><code>vus_mar</code> computes bias-corrected estimates of the volume under the ROC surface for evaluating the accuracy of a continuous diagnostic test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vus_mar(
  method = "full",
  diag_test,
  dise_vec,
  veri_stat,
  rho_est = NULL,
  pi_est = NULL,
  ci = TRUE,
  ci_level = ifelse(ci, 0.95, NULL),
  boot = FALSE,
  n_boot = ifelse(ci, 250, NULL),
  parallel = FALSE,
  ncpus = ifelse(parallel, detectCores()/2, NULL),
  trace = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vus_mar_+3A_method">method</code></td>
<td>
<p>name of bias-corrected estimation method to be used for estimating the VUS in presence of verification bias. See <code><a href="#topic+rocs">rocs</a></code> for more details.</p>
</td></tr>
<tr><td><code id="vus_mar_+3A_diag_test">diag_test</code></td>
<td>
<p>a numeric vector containing the diagnostic test values. <code>NA</code> values are not admitted.</p>
</td></tr>
<tr><td><code id="vus_mar_+3A_dise_vec">dise_vec</code></td>
<td>
<p>a n * 3  binary matrix with the three columns, corresponding to three classes of the disease status. In row i, 1 in column j indicates that the i-th subject belongs to class j, with j = 1, 2, 3. A row of <code>NA</code> values indicates a non-verified subject.</p>
</td></tr>
<tr><td><code id="vus_mar_+3A_veri_stat">veri_stat</code></td>
<td>
<p>a binary vector containing the verification status (1 verified, 0 not verified).</p>
</td></tr>
<tr><td><code id="vus_mar_+3A_rho_est">rho_est</code></td>
<td>
<p>a result of a call to <code><a href="#topic+rho_mlogit">rho_mlogit</a></code> of <code><a href="#topic+rho_knn">rho_knn</a></code> to fit the disease model.</p>
</td></tr>
<tr><td><code id="vus_mar_+3A_pi_est">pi_est</code></td>
<td>
<p>a result of a call to <code><a href="#topic+psglm">psglm</a></code> to fit the verification model.</p>
</td></tr>
<tr><td><code id="vus_mar_+3A_ci">ci</code></td>
<td>
<p>a logical value. If TRUE (default), computes an confidence interval of VUS and tests the null hypothesis H0: VUS = 1/6.</p>
</td></tr>
<tr><td><code id="vus_mar_+3A_ci_level">ci_level</code></td>
<td>
<p>an confidence level to be used for constructing the confidence interval; default 0.95.</p>
</td></tr>
<tr><td><code id="vus_mar_+3A_boot">boot</code></td>
<td>
<p>a logical value. Default = <code>FALSE</code>. If set to <code>TRUE</code>, a bootstrap resampling is employed to estimate the asymptotic variance of bias-corrected VUS estimates. See <code><a href="#topic+asy_var_vus">asy_var_vus</a></code>.</p>
</td></tr>
<tr><td><code id="vus_mar_+3A_n_boot">n_boot</code></td>
<td>
<p>the number of bootstrap replicates, which is used for FULL or KNN estimator, or option <code>boot = TRUE</code>. Usually this will be a single positive integer.</p>
</td></tr>
<tr><td><code id="vus_mar_+3A_parallel">parallel</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, a parallel computing is employed to the bootstrap resampling process.</p>
</td></tr>
<tr><td><code id="vus_mar_+3A_ncpus">ncpus</code></td>
<td>
<p>number of processes to be used in parallel computing. Default is a half of available cores.</p>
</td></tr>
<tr><td><code id="vus_mar_+3A_trace">trace</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, tracing information on the progress of the estimation is produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements five bias-corrected estimation methods in To Duc et al. (2016, 2020) for estimating VUS of a three-class continuous diagnostic test in presence of verification bias. The estimators are full imputation (FI), mean score imputation (MSI), inverse probability weighted (IPW), semiparametric efficient (SPE) and K nearest-neighbor (KNN), see <code><a href="#topic+rocs">rocs</a></code>. These estimators work under MAR assumption.
</p>
<p>The standard error of the estimates are obtained through the function <code><a href="#topic+asy_var_vus">asy_var_vus</a></code>. In particular, the standard error of the FULL estimate is computed by bootstrap resampling method or by Jackknife approach proposed in Guangming et al. (2013). For the bias-corrected estimates, the standard errors are computed by using asymptotic theory (with respect to FI, MSI, IPW and SPE estimator) or bootstrap resampling method (with respect to KNN estimator). A confidence interval for VUS also is given. A logit transformation is also applied for obtaining the confidence interval.
</p>
<p>The default value of the number of bootstrap replicates is 250.
</p>
<p>Note that, before apply the functions <code>vus_mar</code>, the use of <code><a href="#topic+pre_data">pre_data</a></code> might be needed to check the monotone ordering disease classes and to create the matrix format for disease status.
</p>


<h3>Value</h3>

<p><code>vus_mar</code> returns an object of class inheriting from &quot;vus_mar&quot; class.
</p>
<p>The function <code><a href="#topic+print.vus_mar">print.vus_mar</a></code> can be used to print a summary of the results.
</p>
<p>An object of class &quot;vus_mar&quot; is a list containing at least the following components:
</p>
<table role = "presentation">
<tr><td><code>vus_fit</code></td>
<td>
<p>the estimate of VUS.</p>
</td></tr>
<tr><td><code>std</code></td>
<td>
<p>the standard error, obtained by using asymptotic theory or bootstrap resampling method.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>t_stat</code></td>
<td>
<p>t-statistic.</p>
</td></tr>
<tr><td><code>p_val_norm</code></td>
<td>
<p>p-value correspond to normal-test.</p>
</td></tr>
<tr><td><code>ci_norm</code></td>
<td>
<p>the confidence interval of VUS by using normal approximation.</p>
</td></tr>
<tr><td><code>ci_logit</code></td>
<td>
<p>the confidence interval of VUS via logit transform.</p>
</td></tr>
<tr><td><code>ci_level</code></td>
<td>
<p>the confidence level used.</p>
</td></tr>
<tr><td><code>boot</code></td>
<td>
<p>the value of <code>boot</code>.</p>
</td></tr>
<tr><td><code>n_boot</code></td>
<td>
<p>the number of bootstrap replicates used.</p>
</td></tr>
</table>
<p>In addition, the name of method used to estimate VUS also is given as the attribute of <code>vus_fit</code>.
</p>


<h3>References</h3>

<p>To Duc, K., Chiogna, M. and Adimari, G. (2020)
Nonparametric estimation of ROC surfaces in presence of verification bias.
<em>REVSTAT-Statistical Journal</em>, <b>18</b>, 5, 697â€“720.
</p>
<p>To Duc, K., Chiogna, M. and Adimari, G. (2016)
Bias-corrected methods for estimating the receiver operating characteristic surface of continuous diagnostic tests.
<em>Electronic Journal of Statistics</em>, <b>10</b>, 3063-3113.
</p>
<p>Guangming, P., Xiping, W. and Wang, Z. (2013)
Non-parameteric statistical inference for $P(X &lt; Y &lt; Z)$.
<em>Sankhya A</em>, <b>75</b>, 1, 118-138.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EOC)
head(EOC)


## Not run: 
# FULL data estimator
dise_full &lt;- pre_data(EOC$D.full, EOC$CA125)
dise_vec_full &lt;- dise_full$dise_vec
vus_mar("full", diag_test = EOC$CA125, dise_vec = dise_vec_full)

## End(Not run)

## Not run: 
# Preparing the missing disease status
dise_na &lt;- pre_data(EOC$D, EOC$CA125)
dise_vec_na &lt;- dise_na$dise_vec
dise_fact_na &lt;- dise_na$dise
# FI estimator
rho_out &lt;- rho_mlogit(dise_fact_na ~ CA125 + CA153 + Age, data = EOC,
                      test = TRUE)

vus_mar("fi", diag_test = EOC$CA125, dise_vec = dise_vec_na,
        veri_stat = EOC$V, rho_est = rho_out)

# MSI estimator
vus_mar("msi", diag_test = EOC$CA125, dise_vec = dise_vec_na,
        veri_stat = EOC$V, rho_est = rho_out)

# IPW estimator
pi_out &lt;- psglm(V ~ CA125 + CA153 + Age, data = EOC, test = TRUE)
vus_mar("ipw", diag_test = EOC$CA125, dise_vec = dise_vec_na,
        veri_stat = EOC$V, pi_est = pi_out)

# SPE estimator
vus_mar("spe", diag_test = EOC$CA125, dise_vec = dise_vec_na,
        veri_stat = EOC$V, rho_est = rho_out, pi_est = pi_out)

# KNN estimator, K = 1, Mahalanobis distance
x_mat &lt;- cbind(EOC$CA125, EOC$CA153, EOC$Age)
rho_maha_1nn &lt;- rho_knn(x_mat = x_mat, dise_vec = dise_vec_na,
                        veri_stat = EOC$V, k = 1, type = "mahala")
vus_mar("knn", diag_test = EOC$CA125, dise_vec = dise_vec_na,
        veri_stat = EOC$V, rho_est = rho_maha_1nn)

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
