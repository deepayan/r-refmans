<!DOCTYPE html><html><head><title>Help for package baizer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {baizer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#baizer-package'><p>baizer: Useful Functions for Data Processing</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#%eq%'><p>equal calculation operator, support NA</p></a></li>
<li><a href='#%neq%'><p>not equal calculation operator, support NA</p></a></li>
<li><a href='#%nin%'><p>not in calculation operator</p></a></li>
<li><a href='#adjacent_div'><p>expand a number vector according to the adjacent two numbers</p></a></li>
<li><a href='#alias_arg'><p>use aliases for function arguments</p></a></li>
<li><a href='#as_md_table'><p>trans a tibble into markdown format table</p></a></li>
<li><a href='#as_tibble_md'><p>trans a table in markdown format into tibble</p></a></li>
<li><a href='#atomic_expr'><p>whether the expression is an atomic one</p></a></li>
<li><a href='#broadcast_vector'><p>broadcast the vector into length n</p></a></li>
<li><a href='#c2r'><p>wrapper of tibble::column_to_rownames</p></a></li>
<li><a href='#check_arg'><p>check arguments by custom function</p></a></li>
<li><a href='#cmdargs'><p>get the command line arguments</p></a></li>
<li><a href='#collapse_vector'><p>dump a named vector into character</p></a></li>
<li><a href='#combn_vector'><p>combine multiple vectors into one</p></a></li>
<li><a href='#correct_ratio'><p>correct the numbers to a target ratio</p></a></li>
<li><a href='#cross_count'><p>count two columns as a cross-tabulation table</p></a></li>
<li><a href='#detect_dup'><p>detect possible duplication in a vector, ignore case,</p>
blank and special character</a></li>
<li><a href='#diff_index'><p>the index of different character</p></a></li>
<li><a href='#diff_tb'><p>differences between two tibbles</p></a></li>
<li><a href='#dx_tb'><p>diagnosis a tibble for character NA, NULL, all T/F column, blank in cell</p></a></li>
<li><a href='#empty_dir'><p>detect whether directory is empty recursively</p></a></li>
<li><a href='#empty_file'><p>detect whether file is empty recursively</p></a></li>
<li><a href='#exist_matrix'><p>generate a matrix to show whether the item in each element of a list</p></a></li>
<li><a href='#expr_pileup'><p>pileup the subexpressions which is atomic</p></a></li>
<li><a href='#extract_kv'><p>extract key and values for a character vector</p></a></li>
<li><a href='#fancy_count'><p>fancy count to show an extended column</p></a></li>
<li><a href='#fetch_char'><p>fetch character from strings</p></a></li>
<li><a href='#filterC'><p>apply tbflt on dplyr filter</p></a></li>
<li><a href='#fix_to_regex'><p>trans fixed string into regular expression string</p></a></li>
<li><a href='#float_to_percent'><p>from float number to percent number</p></a></li>
<li><a href='#fps_vector'><p>farthest point sampling (FPS) for a vector</p></a></li>
<li><a href='#full_expand'><p>like <code>dplyr::full_join</code> while ignore the same columns in right tibble</p></a></li>
<li><a href='#gen_char'><p>generate characters</p></a></li>
<li><a href='#gen_combn'><p>generate all combinations</p></a></li>
<li><a href='#gen_outlier'><p>generate outliers from a series of number</p></a></li>
<li><a href='#gen_str'><p>generate strings</p></a></li>
<li><a href='#gen_tb'><p>generate tibbles</p></a></li>
<li><a href='#generate_ticks'><p>generate ticks for a number vector</p></a></li>
<li><a href='#geom_mean'><p>geometric mean</p></a></li>
<li><a href='#group_vector'><p>group character vector by a regex pattern</p></a></li>
<li><a href='#hist_bins'><p>separate numeric x into bins</p></a></li>
<li><a href='#inner_expand'><p>like <code>dplyr::inner_join</code> while ignore the same columns in right tibble</p></a></li>
<li><a href='#int_digits'><p>trans numbers to a fixed integer digit length</p></a></li>
<li><a href='#is.zero'><p>if a number only have zeros</p></a></li>
<li><a href='#left_expand'><p>like <code>dplyr::left_join</code> while ignore the same columns in right tibble</p></a></li>
<li><a href='#list2df'><p>trans list into data.frame</p></a></li>
<li><a href='#max_depth'><p>max depth of a list</p></a></li>
<li><a href='#melt_vector'><p>melt a vector into single value</p></a></li>
<li><a href='#mini_diamond'><p>Minimal tibble dataset adjusted from diamond</p></a></li>
<li><a href='#mm_norm'><p>max-min normalization</p></a></li>
<li><a href='#move_row'><p>move selected rows to target location</p></a></li>
<li><a href='#near_ticks'><p>the ticks near a number</p></a></li>
<li><a href='#nearest_tick'><p>the nearest ticks around a number</p></a></li>
<li><a href='#not.na'><p>not NA</p></a></li>
<li><a href='#not.null'><p>not NULL</p></a></li>
<li><a href='#number_fun_wrapper'><p>wrapper of the functions to process number string with prefix and suffix</p></a></li>
<li><a href='#ordered_slice'><p>slice a tibble by an ordered vector</p></a></li>
<li><a href='#percent_to_float'><p>from percent number to float number</p></a></li>
<li><a href='#pileup_logical'><p>pileup another logical vector on the TRUE values of first vector</p></a></li>
<li><a href='#pkginfo'><p>information of packages</p></a></li>
<li><a href='#pkglib'><p>load packages as a batch</p></a></li>
<li><a href='#pkgver'><p>versions of packages</p></a></li>
<li><a href='#pos_int_split'><p>split a positive integer number as a number vector</p></a></li>
<li><a href='#r2c'><p>wrapper of tibble::rownames_to_column</p></a></li>
<li><a href='#read_excel'><p>read excel file</p></a></li>
<li><a href='#read_excel_list'><p>read multi-sheet excel file as a list of tibbles</p></a></li>
<li><a href='#read_fmmd'><p>read front matter markdown</p></a></li>
<li><a href='#ref_level'><p>relevel a target column by another reference column</p></a></li>
<li><a href='#reg_join'><p>join the matched parts into string</p></a></li>
<li><a href='#reg_match'><p>regex match</p></a></li>
<li><a href='#remove_monocol'><p>remove columns by the ratio of an identical single value (NA supported)</p></a></li>
<li><a href='#remove_nacol'><p>remove columns by the ratio of NA</p></a></li>
<li><a href='#remove_narow'><p>remove rows by the ratio of NA</p></a></li>
<li><a href='#remove_outliers'><p>remove outliers and NA</p></a></li>
<li><a href='#replace_item'><p>replace the items of one object by another</p></a></li>
<li><a href='#rewrite_na'><p>rewrite the NA values in a tibble by another tibble</p></a></li>
<li><a href='#rng2seq'><p>trans range character into seq characters</p></a></li>
<li><a href='#round_string'><p>from float number to fixed digits character</p></a></li>
<li><a href='#roxygen_fmt'><p>add #' into each line of codes for roxygen examples</p></a></li>
<li><a href='#same_index'><p>the index of identical character</p></a></li>
<li><a href='#seriate_df'><p>dataframe rows seriation, which will reorder the rows in a better pattern</p></a></li>
<li><a href='#sftp_connect'><p>connection parameters to remote server via sftp</p></a></li>
<li><a href='#sftp_download'><p>download file from remote server via sftp</p></a></li>
<li><a href='#sftp_ls'><p>list files from remote server via sftp</p></a></li>
<li><a href='#signif_ceiling'><p>signif while use ceiling</p></a></li>
<li><a href='#signif_floor'><p>signif while use floor</p></a></li>
<li><a href='#signif_round_string'><p>signif or round string depend on the character length</p></a></li>
<li><a href='#signif_string'><p>from float number to fixed significant digits character</p></a></li>
<li><a href='#slice_char'><p>slice character vector</p></a></li>
<li><a href='#sortf'><p>sort by a function</p></a></li>
<li><a href='#split_column'><p>split a column and return a longer tibble</p></a></li>
<li><a href='#split_path'><p>split a path into ancestor paths recursively</p></a></li>
<li><a href='#split_vector'><p>split vector into list</p></a></li>
<li><a href='#stat_fc'><p>fold change calculation which returns a extensible tibble</p></a></li>
<li><a href='#stat_phi'><p>calculate phi coefficient of two binary variables</p></a></li>
<li><a href='#stat_test'><p>statistical test which returns a extensible tibble</p></a></li>
<li><a href='#str_replace_loc'><p>replace specific characters in a string by their locations</p></a></li>
<li><a href='#swap_vecname'><p>swap the names and values of a vector</p></a></li>
<li><a href='#tbflt'><p>create a tbflt object to save filter conditions</p></a></li>
<li><a href='#tdf'><p>transpose a dataframe</p></a></li>
<li><a href='#tidyeval'><p>Tidy eval helpers</p></a></li>
<li><a href='#top_item'><p>return top n items with highest frequency</p></a></li>
<li><a href='#uniq'><p>only keep unique vector values and its names</p></a></li>
<li><a href='#uniq_in_cols'><p>count unique values in each column</p></a></li>
<li><a href='#write_excel'><p>write a tibble into an excel file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Useful Functions for Data Processing</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.0</td>
</tr>
<tr>
<td>Description:</td>
<td>In ancient Chinese mythology, Bai Ze is a divine creature that knows the needs of everything.
    'baizer' provides data processing functions frequently used by the author.
    Hope this package also knows what you want!</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>curl, diffobj, dplyr (&ge; 1.1.0), grDevices, magrittr, methods,
openxlsx, purrr, readr, readxl, rematch2, rlang (&ge; 0.4.11),
rmarkdown, seriation, stats, stringr, tibble (&ge; 3.1), tidyr,
utils, vctrs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, roxygen2, testthat (&ge; 3.0.0), withr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://william-swl.github.io/baizer/">https://william-swl.github.io/baizer/</a>,
<a href="https://github.com/william-swl/baizer">https://github.com/william-swl/baizer</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/william-swl/baizer/issues">https://github.com/william-swl/baizer/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-19 08:31:45 UTC; william</td>
</tr>
<tr>
<td>Author:</td>
<td>William Song [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>William Song &lt;william_swl@163.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-19 09:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='baizer-package'>baizer: Useful Functions for Data Processing</h2><span id='topic+baizer'></span><span id='topic+baizer-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>In ancient Chinese mythology, Bai Ze is a divine creature that knows the needs of everything. 'baizer' provides data processing functions frequently used by the author. Hope this package also knows what you want!
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: William Song <a href="mailto:william_swl@163.com">william_swl@163.com</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://william-swl.github.io/baizer/">https://william-swl.github.io/baizer/</a>
</p>
</li>
<li> <p><a href="https://github.com/william-swl/baizer">https://github.com/william-swl/baizer</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/william-swl/baizer/issues">https://github.com/william-swl/baizer/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='+25eq+25'>equal calculation operator, support NA</h2><span id='topic++25eq+25'></span>

<h3>Description</h3>

<p>equal calculation operator, support NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %eq% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25eq+2B25_+3A_x">x</code></td>
<td>
<p>value x</p>
</td></tr>
<tr><td><code id="+2B25eq+2B25_+3A_y">y</code></td>
<td>
<p>value y</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical value, TRUE if x and y are not equal
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NA %eq% NA
</code></pre>

<hr>
<h2 id='+25neq+25'>not equal calculation operator, support NA</h2><span id='topic++25neq+25'></span>

<h3>Description</h3>

<p>not equal calculation operator, support NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %neq% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25neq+2B25_+3A_x">x</code></td>
<td>
<p>value x</p>
</td></tr>
<tr><td><code id="+2B25neq+2B25_+3A_y">y</code></td>
<td>
<p>value y</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical value, TRUE if x and y are not equal
</p>


<h3>Examples</h3>

<pre><code class='language-R'>1 %neq% NA
</code></pre>

<hr>
<h2 id='+25nin+25'>not in calculation operator</h2><span id='topic++25nin+25'></span>

<h3>Description</h3>

<p>not in calculation operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>left %nin% right
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25nin+2B25_+3A_left">left</code></td>
<td>
<p>left element</p>
</td></tr>
<tr><td><code id="+2B25nin+2B25_+3A_right">right</code></td>
<td>
<p>right element</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical value, TRUE if left is not in right
</p>


<h3>Examples</h3>

<pre><code class='language-R'>0 %nin% 1:4
</code></pre>

<hr>
<h2 id='adjacent_div'>expand a number vector according to the adjacent two numbers</h2><span id='topic+adjacent_div'></span>

<h3>Description</h3>

<p>expand a number vector according to the adjacent two numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjacent_div(v, n_div = 10, .unique = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjacent_div_+3A_v">v</code></td>
<td>
<p>number vector</p>
</td></tr>
<tr><td><code id="adjacent_div_+3A_n_div">n_div</code></td>
<td>
<p>how many divisions expanded by two numbers</p>
</td></tr>
<tr><td><code id="adjacent_div_+3A_.unique">.unique</code></td>
<td>
<p>only keep unique numbers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>new number vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adjacent_div(10^c(1:3), n_div = 10)
</code></pre>

<hr>
<h2 id='alias_arg'>use aliases for function arguments</h2><span id='topic+alias_arg'></span>

<h3>Description</h3>

<p>use aliases for function arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alias_arg(..., default = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alias_arg_+3A_...">...</code></td>
<td>
<p>aliases of an argument</p>
</td></tr>
<tr><td><code id="alias_arg_+3A_default">default</code></td>
<td>
<p>a alias with a default value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the finally value of this argument across all aliases
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# set y, z as aliases of x when create a function
func &lt;- function(x = 1, y = NULL, z = NULL) {
  x &lt;- alias_arg(x, y, z, default = x)
  return(x)
}
</code></pre>

<hr>
<h2 id='as_md_table'>trans a tibble into markdown format table</h2><span id='topic+as_md_table'></span>

<h3>Description</h3>

<p>trans a tibble into markdown format table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_md_table(x, show = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_md_table_+3A_x">x</code></td>
<td>
<p>tibble</p>
</td></tr>
<tr><td><code id="as_md_table_+3A_show">show</code></td>
<td>
<p>show result instead of return the markdown string, TRUE as
default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL or markdown string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mini_diamond %&gt;%
  head(5) %&gt;%
  as_md_table()

</code></pre>

<hr>
<h2 id='as_tibble_md'>trans a table in markdown format into tibble</h2><span id='topic+as_tibble_md'></span>

<h3>Description</h3>

<p>trans a table in markdown format into tibble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_tibble_md(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_tibble_md_+3A_x">x</code></td>
<td>
<p>character string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- "
col1 | col2 | col3 |
| ---- | ---- | ---- |
| v1   | v2   | v3   |
| r1   | r2   | r3   |
"

as_tibble_md(x)

</code></pre>

<hr>
<h2 id='atomic_expr'>whether the expression is an atomic one</h2><span id='topic+atomic_expr'></span>

<h3>Description</h3>

<p>whether the expression is an atomic one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atomic_expr(ex)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="atomic_expr_+3A_ex">ex</code></td>
<td>
<p>expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>atomic_expr(rlang::expr(x))

atomic_expr(rlang::expr(!x))

atomic_expr(rlang::expr(x + y))

atomic_expr(rlang::expr(x &gt; 1))

atomic_expr(rlang::expr(!x + y))

atomic_expr(rlang::expr(x &gt; 1 | y &lt; 2))

</code></pre>

<hr>
<h2 id='broadcast_vector'>broadcast the vector into length n</h2><span id='topic+broadcast_vector'></span>

<h3>Description</h3>

<p>broadcast the vector into length n
</p>


<h3>Usage</h3>

<pre><code class='language-R'>broadcast_vector(x, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="broadcast_vector_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="broadcast_vector_+3A_n">n</code></td>
<td>
<p>target length</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>broadcast_vector(1:3, 5)

</code></pre>

<hr>
<h2 id='c2r'>wrapper of tibble::column_to_rownames</h2><span id='topic+c2r'></span>

<h3>Description</h3>

<p>wrapper of tibble::column_to_rownames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c2r(df, col = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c2r_+3A_df">df</code></td>
<td>
<p>tibble</p>
</td></tr>
<tr><td><code id="c2r_+3A_col">col</code></td>
<td>
<p>a col name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mini_diamond %&gt;% c2r("id")
</code></pre>

<hr>
<h2 id='check_arg'>check arguments by custom function</h2><span id='topic+check_arg'></span>

<h3>Description</h3>

<p>check arguments by custom function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_arg(..., n = 2, fun = not.null)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_arg_+3A_...">...</code></td>
<td>
<p>arguments</p>
</td></tr>
<tr><td><code id="check_arg_+3A_n">n</code></td>
<td>
<p>how many arguments should meet the custom conditions</p>
</td></tr>
<tr><td><code id="check_arg_+3A_fun">fun</code></td>
<td>
<p>custom conditions defined by a function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1
y &lt;- 3
z &lt;- NULL

func &lt;- function(x = NULL, y = NULL, z = NULL) {
  if (check_arg(x, y, z, n = 2)) {
    print("As expected, two arguments is not NULL")
  }

  if (check_arg(x, y, z, n = 1, method = ~ .x &lt; 2)) {
    print("As expected, one argument less than 2")
  }
}

</code></pre>

<hr>
<h2 id='cmdargs'>get the command line arguments</h2><span id='topic+cmdargs'></span>

<h3>Description</h3>

<p>get the command line arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmdargs(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmdargs_+3A_x">x</code></td>
<td>
<p>one of 'wd, R_env, script_path, script_dir, env_configs'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of all arguments, or single value of select argument
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cmdargs()

</code></pre>

<hr>
<h2 id='collapse_vector'>dump a named vector into character</h2><span id='topic+collapse_vector'></span>

<h3>Description</h3>

<p>dump a named vector into character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_vector(named_vector, front_name = TRUE, collapse = ",")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_vector_+3A_named_vector">named_vector</code></td>
<td>
<p>a named vector</p>
</td></tr>
<tr><td><code id="collapse_vector_+3A_front_name">front_name</code></td>
<td>
<p>if TRUE, put names to former</p>
</td></tr>
<tr><td><code id="collapse_vector_+3A_collapse">collapse</code></td>
<td>
<p>collapse separator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>collapse_vector(c(e = 1:4), front_name = TRUE, collapse = ";")
</code></pre>

<hr>
<h2 id='combn_vector'>combine multiple vectors into one</h2><span id='topic+combn_vector'></span>

<h3>Description</h3>

<p>combine multiple vectors into one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combn_vector(..., method = "first", invalid = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combn_vector_+3A_...">...</code></td>
<td>
<p>vectors</p>
</td></tr>
<tr><td><code id="combn_vector_+3A_method">method</code></td>
<td>
<p>how to combine, should be one of
<code>first|last</code>, or one of <code>sum|mean|median</code> for numeric vector,
or some characters (e.g. <code style="white-space: pre;">&#8288;,|.| |;&#8288;</code>) for character vector</p>
</td></tr>
<tr><td><code id="combn_vector_+3A_invalid">invalid</code></td>
<td>
<p>invalid value to ignore, <code>NA</code> as default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>combined vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- c(1, 2, NA, NA)
x2 &lt;- c(3, NA, 2, NA)
x3 &lt;- c(4, NA, NA, 3)

combn_vector(x1, x2, x3, method = "sum")

</code></pre>

<hr>
<h2 id='correct_ratio'>correct the numbers to a target ratio</h2><span id='topic+correct_ratio'></span>

<h3>Description</h3>

<p>correct the numbers to a target ratio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correct_ratio(raw, target, digits = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correct_ratio_+3A_raw">raw</code></td>
<td>
<p>the raw numbers</p>
</td></tr>
<tr><td><code id="correct_ratio_+3A_target">target</code></td>
<td>
<p>the target ratio</p>
</td></tr>
<tr><td><code id="correct_ratio_+3A_digits">digits</code></td>
<td>
<p>the result digits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>corrected number vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>correct_ratio(c(10, 10), c(3, 5))

# support ratio as a float
correct_ratio(c(100, 100), c(0.2, 0.8))

# more numbers
correct_ratio(10:13, c(2, 3, 4, 6))

# with digits after decimal point
correct_ratio(c(10, 10), c(1, 4), digits = 1)
</code></pre>

<hr>
<h2 id='cross_count'>count two columns as a cross-tabulation table</h2><span id='topic+cross_count'></span>

<h3>Description</h3>

<p>count two columns as a cross-tabulation table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_count(df, row, col, method = "n", digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_count_+3A_df">df</code></td>
<td>
<p>tibble</p>
</td></tr>
<tr><td><code id="cross_count_+3A_row">row</code></td>
<td>
<p>the column as rownames in the output</p>
</td></tr>
<tr><td><code id="cross_count_+3A_col">col</code></td>
<td>
<p>the column as colnames in the output</p>
</td></tr>
<tr><td><code id="cross_count_+3A_method">method</code></td>
<td>
<p>one of <code style="white-space: pre;">&#8288;n|count, rowr|row_ratio, colr|col_ratio&#8288;</code></p>
</td></tr>
<tr><td><code id="cross_count_+3A_digits">digits</code></td>
<td>
<p>the digits of ratios</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cross_count(mini_diamond, cut, clarity)

# show the ratio in the row
cross_count(mini_diamond, cut, clarity, method = "rowr")

# show the ratio in the col
cross_count(mini_diamond, cut, clarity, method = "colr")

</code></pre>

<hr>
<h2 id='detect_dup'>detect possible duplication in a vector, ignore case,
blank and special character</h2><span id='topic+detect_dup'></span>

<h3>Description</h3>

<p>detect possible duplication in a vector, ignore case,
blank and special character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_dup(vector, index = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect_dup_+3A_vector">vector</code></td>
<td>
<p>vector possibly with duplication</p>
</td></tr>
<tr><td><code id="detect_dup_+3A_index">index</code></td>
<td>
<p>return duplication index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>duplication sub-vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>detect_dup(c("a", "C_", "c -", "#A"))
</code></pre>

<hr>
<h2 id='diff_index'>the index of different character</h2><span id='topic+diff_index'></span>

<h3>Description</h3>

<p>the index of different character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_index(s1, s2, nth = NULL, ignore_case = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff_index_+3A_s1">s1</code></td>
<td>
<p>string1</p>
</td></tr>
<tr><td><code id="diff_index_+3A_s2">s2</code></td>
<td>
<p>string2</p>
</td></tr>
<tr><td><code id="diff_index_+3A_nth">nth</code></td>
<td>
<p>just return nth index</p>
</td></tr>
<tr><td><code id="diff_index_+3A_ignore_case">ignore_case</code></td>
<td>
<p>ignore upper or lower cases</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of different character indices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>diff_index("AAAA", "ABBA")
</code></pre>

<hr>
<h2 id='diff_tb'>differences between two tibbles</h2><span id='topic+diff_tb'></span>

<h3>Description</h3>

<p>differences between two tibbles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_tb(old, new)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff_tb_+3A_old">old</code></td>
<td>
<p>old tibble</p>
</td></tr>
<tr><td><code id="diff_tb_+3A_new">new</code></td>
<td>
<p>new tibble</p>
</td></tr>
</table>


<h3>Value</h3>

<p>differences tibble, 'a, d, c' in <code>diff_type</code> stand for
'add, delete, change' compared to the old tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tb1 &lt;- gen_tb(fill = "int", seed = 1)

tb2 &lt;- gen_tb(fill = "int", seed = 3)

diff_tb(tb1, tb2)

</code></pre>

<hr>
<h2 id='dx_tb'>diagnosis a tibble for character NA, NULL, all T/F column, blank in cell</h2><span id='topic+dx_tb'></span>

<h3>Description</h3>

<p>diagnosis a tibble for character NA, NULL, all T/F column, blank in cell
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dx_tb(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dx_tb_+3A_x">x</code></td>
<td>
<p>tibble</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- tibble::tibble(
  c1 = c("NA", NA, "a", "b"),
  c2 = c("c", "d", "e", "NULL"),
  c3 = c("T", "F", "F", "T"),
  c4 = c("T", "F", "F", NA),
  c5 = c("", " ", "\t", "\n")
)

dx_tb(x)

</code></pre>

<hr>
<h2 id='empty_dir'>detect whether directory is empty recursively</h2><span id='topic+empty_dir'></span>

<h3>Description</h3>

<p>detect whether directory is empty recursively
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empty_dir(dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="empty_dir_+3A_dir">dir</code></td>
<td>
<p>the directory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical value
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create an empty directory
dir.create("some/deep/path/in/a/folder", recursive = TRUE)
empty_dir("some/deep/path/in/a/folder")

# create an empty file
file.create("some/deep/path/in/a/folder/there_is_a_file.txt")
empty_dir("some/deep/path/in/a/folder")
empty_file("some/deep/path/in/a/folder/there_is_a_file.txt", strict = TRUE)

# create a file with only character of length 0
write("", "some/deep/path/in/a/folder/there_is_a_file.txt")
empty_file("some/deep/path/in/a/folder/there_is_a_file.txt", strict = TRUE)
empty_file("some/deep/path/in/a/folder/there_is_a_file.txt")

# clean
unlink("some", recursive = TRUE)

</code></pre>

<hr>
<h2 id='empty_file'>detect whether file is empty recursively</h2><span id='topic+empty_file'></span>

<h3>Description</h3>

<p>detect whether file is empty recursively
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empty_file(path, strict = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="empty_file_+3A_path">path</code></td>
<td>
<p>the path of file</p>
</td></tr>
<tr><td><code id="empty_file_+3A_strict">strict</code></td>
<td>
<p><code>FALSE</code> as default. If <code>TRUE</code>, a file with only one
character of length 0 will be considered as not empty</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical value
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create an empty directory
dir.create("some/deep/path/in/a/folder", recursive = TRUE)
empty_dir("some/deep/path/in/a/folder")

# create an empty file
file.create("some/deep/path/in/a/folder/there_is_a_file.txt")
empty_dir("some/deep/path/in/a/folder")
empty_file("some/deep/path/in/a/folder/there_is_a_file.txt", strict = TRUE)

# create a file with only character of length 0
write("", "some/deep/path/in/a/folder/there_is_a_file.txt")
empty_file("some/deep/path/in/a/folder/there_is_a_file.txt", strict = TRUE)
empty_file("some/deep/path/in/a/folder/there_is_a_file.txt")

# clean
unlink("some", recursive = TRUE)

</code></pre>

<hr>
<h2 id='exist_matrix'>generate a matrix to show whether the item in each element of a list</h2><span id='topic+exist_matrix'></span>

<h3>Description</h3>

<p>generate a matrix to show whether the item in each element of a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exist_matrix(x, n_lim = 0, n_top = NULL, sort_items = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exist_matrix_+3A_x">x</code></td>
<td>
<p>list of character vectors</p>
</td></tr>
<tr><td><code id="exist_matrix_+3A_n_lim">n_lim</code></td>
<td>
<p>n limit to keep items in result</p>
</td></tr>
<tr><td><code id="exist_matrix_+3A_n_top">n_top</code></td>
<td>
<p>only keep top n items in result</p>
</td></tr>
<tr><td><code id="exist_matrix_+3A_sort_items">sort_items</code></td>
<td>
<p>function to sort the items, item frequency by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5 %&gt;% purrr::map(
  ~ gen_char(to = "k", n = 5, random = TRUE, seed = .x)
)
exist_matrix(x)

</code></pre>

<hr>
<h2 id='expr_pileup'>pileup the subexpressions which is atomic</h2><span id='topic+expr_pileup'></span>

<h3>Description</h3>

<p>pileup the subexpressions which is atomic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expr_pileup(ex)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expr_pileup_+3A_ex">ex</code></td>
<td>
<p>expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the character vector of subexpressions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex &lt;- rlang::expr(a == 2 &amp; b == 3 | !b &amp; x + 2)
expr_pileup(ex)

</code></pre>

<hr>
<h2 id='extract_kv'>extract key and values for a character vector</h2><span id='topic+extract_kv'></span>

<h3>Description</h3>

<p>extract key and values for a character vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_kv(v, sep = ": ", key_loc = 1, value_loc = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_kv_+3A_v">v</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="extract_kv_+3A_sep">sep</code></td>
<td>
<p>separator between key and value</p>
</td></tr>
<tr><td><code id="extract_kv_+3A_key_loc">key_loc</code></td>
<td>
<p>key location</p>
</td></tr>
<tr><td><code id="extract_kv_+3A_value_loc">value_loc</code></td>
<td>
<p>value location</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>extract_kv(c("x: 1", "y: 2"))
</code></pre>

<hr>
<h2 id='fancy_count'>fancy count to show an extended column</h2><span id='topic+fancy_count'></span>

<h3>Description</h3>

<p>fancy count to show an extended column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fancy_count(df, ..., ext = NULL, ext_fmt = "count", sort = FALSE, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fancy_count_+3A_df">df</code></td>
<td>
<p>tibble</p>
</td></tr>
<tr><td><code id="fancy_count_+3A_...">...</code></td>
<td>
<p>other arguments from <code>dplyr::count()</code></p>
</td></tr>
<tr><td><code id="fancy_count_+3A_ext">ext</code></td>
<td>
<p>extended column</p>
</td></tr>
<tr><td><code id="fancy_count_+3A_ext_fmt">ext_fmt</code></td>
<td>
<p><code>count|ratio|clean</code>, output format of extended column</p>
</td></tr>
<tr><td><code id="fancy_count_+3A_sort">sort</code></td>
<td>
<p>sort by frequency or not</p>
</td></tr>
<tr><td><code id="fancy_count_+3A_digits">digits</code></td>
<td>
<p>if <code>ext_fmt=ratio</code>, the digits of ratio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>count tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fancy_count(mini_diamond, cut, ext = clarity)

fancy_count(mini_diamond, cut, ext = clarity, ext_fmt = "ratio")

fancy_count(mini_diamond, cut, ext = clarity, ext_fmt = "clean")

fancy_count(mini_diamond, cut, ext = clarity, sort = FALSE)

fancy_count(mini_diamond, cut, clarity, ext = id) %&gt;% head(5)
</code></pre>

<hr>
<h2 id='fetch_char'>fetch character from strings</h2><span id='topic+fetch_char'></span>

<h3>Description</h3>

<p>fetch character from strings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetch_char(s, index_list, na.rm = FALSE, collapse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fetch_char_+3A_s">s</code></td>
<td>
<p>strings</p>
</td></tr>
<tr><td><code id="fetch_char_+3A_index_list">index_list</code></td>
<td>
<p>index of nth character,
can be output of <code>diff_index</code> or <code>same_index</code></p>
</td></tr>
<tr><td><code id="fetch_char_+3A_na.rm">na.rm</code></td>
<td>
<p>remove NA values from results or not</p>
</td></tr>
<tr><td><code id="fetch_char_+3A_collapse">collapse</code></td>
<td>
<p>optional string used to combine
the characters from a same string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of characters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fetch_char(rep("ABC", 3), list(1, 2, 3))
</code></pre>

<hr>
<h2 id='filterC'>apply tbflt on dplyr filter</h2><span id='topic+filterC'></span>

<h3>Description</h3>

<p>apply tbflt on dplyr filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterC(.data, tbflt = NULL, .by = NULL, usecol = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterC_+3A_.data">.data</code></td>
<td>
<p>tibble</p>
</td></tr>
<tr><td><code id="filterC_+3A_tbflt">tbflt</code></td>
<td>
<p>tbflt object</p>
</td></tr>
<tr><td><code id="filterC_+3A_.by">.by</code></td>
<td>
<p>group by, same as <code>.by</code> argument in <code>dplyr::filter</code></p>
</td></tr>
<tr><td><code id="filterC_+3A_usecol">usecol</code></td>
<td>
<p>if <code>TRUE</code> (default), use the default behavior of
<code>dplyr::filter()</code>, which allows the usage of same variable in
colnames, and filter by the data column. If <code>FALSE</code>, will check
whether the variables on the right side of <code style="white-space: pre;">&#8288;==,&gt;,&lt;,&gt;=,&lt;=&#8288;</code> have
same names as columns and raise error, for the sake of
more predictable results. You can always ignore this argument if
you know how to use <code>.env</code> or <code style="white-space: pre;">&#8288;!!&#8288;</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c1 &lt;- tbflt(cut == "Fair")

c2 &lt;- tbflt(x &gt; 8)

mini_diamond %&gt;%
  filterC(c1) %&gt;%
  head(5)

mini_diamond %&gt;% filterC(c1 &amp; c2)



x &lt;- 8
cond &lt;- tbflt(y &gt; x)

# variable `x` not used because of column `x` in `mini_diamond`
filterC(mini_diamond, cond)

# will raise error because `x`  is on the right side of `&gt;`
# filterC(mini_diamond, cond, usecol=FALSE)

# if you know how to use `.env` or `!!`, forget argument `usecol`!
cond &lt;- tbflt(y &gt; !!x)
filterC(mini_diamond, cond)

cond &lt;- tbflt(y &gt; .env$x)
filterC(mini_diamond, cond)

</code></pre>

<hr>
<h2 id='fix_to_regex'>trans fixed string into regular expression string</h2><span id='topic+fix_to_regex'></span>

<h3>Description</h3>

<p>trans fixed string into regular expression string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_to_regex(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix_to_regex_+3A_p">p</code></td>
<td>
<p>raw fixed pattern</p>
</td></tr>
</table>


<h3>Value</h3>

<p>regex pattern
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fix_to_regex("ABC|?(*)")
</code></pre>

<hr>
<h2 id='float_to_percent'>from float number to percent number</h2><span id='topic+float_to_percent'></span>

<h3>Description</h3>

<p>from float number to percent number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>float_to_percent(x, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="float_to_percent_+3A_x">x</code></td>
<td>
<p>number</p>
</td></tr>
<tr><td><code id="float_to_percent_+3A_digits">digits</code></td>
<td>
<p>hold n digits after the decimal point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>percent character of x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>float_to_percent(0.12)
</code></pre>

<hr>
<h2 id='fps_vector'>farthest point sampling (FPS) for a vector</h2><span id='topic+fps_vector'></span>

<h3>Description</h3>

<p>farthest point sampling (FPS) for a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fps_vector(v, n, method = "round")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fps_vector_+3A_v">v</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="fps_vector_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="fps_vector_+3A_method">method</code></td>
<td>
<p><code>round|floor|ceiling</code>, the method used when trans to integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sampled vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fps_vector(1:10, 4)
</code></pre>

<hr>
<h2 id='full_expand'>like <code>dplyr::full_join</code> while ignore the same columns in right tibble</h2><span id='topic+full_expand'></span>

<h3>Description</h3>

<p>like <code>dplyr::full_join</code> while ignore the same columns in right tibble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>full_expand(x, y, by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="full_expand_+3A_x">x</code></td>
<td>
<p>left tibble</p>
</td></tr>
<tr><td><code id="full_expand_+3A_y">y</code></td>
<td>
<p>right tibble</p>
</td></tr>
<tr><td><code id="full_expand_+3A_by">by</code></td>
<td>
<p>columns to join by</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tb1 &lt;- head(mini_diamond, 4)
tb2 &lt;- tibble::tibble(
  id = c("id-2", "id-4", "id-5"),
  carat = 1:3,
  price = c(1000, 2000, 3000),
  newcol = c("new2", "new4", "new5")
)

left_expand(tb1, tb2, by = "id")

full_expand(tb1, tb2, by = "id")

inner_expand(tb1, tb2, by = "id")
</code></pre>

<hr>
<h2 id='gen_char'>generate characters</h2><span id='topic+gen_char'></span>

<h3>Description</h3>

<p>generate characters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_char(
  from = NULL,
  to = NULL,
  n = NULL,
  random = FALSE,
  allow_dup = TRUE,
  add = NULL,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_char_+3A_from">from</code></td>
<td>
<p>left bound, lower case letter</p>
</td></tr>
<tr><td><code id="gen_char_+3A_to">to</code></td>
<td>
<p>right bound, lower case letter</p>
</td></tr>
<tr><td><code id="gen_char_+3A_n">n</code></td>
<td>
<p>number of characters to generate</p>
</td></tr>
<tr><td><code id="gen_char_+3A_random">random</code></td>
<td>
<p>random generation</p>
</td></tr>
<tr><td><code id="gen_char_+3A_allow_dup">allow_dup</code></td>
<td>
<p>allow duplication when random generation</p>
</td></tr>
<tr><td><code id="gen_char_+3A_add">add</code></td>
<td>
<p>add extra characters other than <code>base::letters</code></p>
</td></tr>
<tr><td><code id="gen_char_+3A_seed">seed</code></td>
<td>
<p>random seed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>generated characters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gen_char(from = "g", n = 5)
gen_char(to = "g", n = 5)
gen_char(from = "g", to = "j")
gen_char(from = "t", n = 5, random = TRUE)
gen_char(
  from = "x", n = 5, random = TRUE,
  allow_dup = FALSE, add = c("+", "-")
)

</code></pre>

<hr>
<h2 id='gen_combn'>generate all combinations</h2><span id='topic+gen_combn'></span>

<h3>Description</h3>

<p>generate all combinations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_combn(x, n = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_combn_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="gen_combn_+3A_n">n</code></td>
<td>
<p>numbers of element to combine</p>
</td></tr>
</table>


<h3>Value</h3>

<p>all combinations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gen_combn(1:4, n = 2)

</code></pre>

<hr>
<h2 id='gen_outlier'>generate outliers from a series of number</h2><span id='topic+gen_outlier'></span>

<h3>Description</h3>

<p>generate outliers from a series of number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_outlier(
  x,
  n,
  digits = 0,
  side = "both",
  lim = NULL,
  assign_n = NULL,
  only_out = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_outlier_+3A_x">x</code></td>
<td>
<p>number vector</p>
</td></tr>
<tr><td><code id="gen_outlier_+3A_n">n</code></td>
<td>
<p>number of outliers to generate</p>
</td></tr>
<tr><td><code id="gen_outlier_+3A_digits">digits</code></td>
<td>
<p>the digits of outliers</p>
</td></tr>
<tr><td><code id="gen_outlier_+3A_side">side</code></td>
<td>
<p>should be one of <code style="white-space: pre;">&#8288;both, low, high&#8288;</code></p>
</td></tr>
<tr><td><code id="gen_outlier_+3A_lim">lim</code></td>
<td>
<p>a two-length vector to assign the limitations of the outliers
if method is <code>both</code>, the outliers will be limited in
[lim[1], low_outlier_threshold] and [high_outlier_threshold, lim[2]]
;
if method is <code>low</code>, the outliers will be limited in
[lim[1], min(low_outlier_threshold, lim[2])]
;
if method is <code>high</code>, the outliers will be limited in
[max(high_outlier_threshold, lim[1]), lim[2]]</p>
</td></tr>
<tr><td><code id="gen_outlier_+3A_assign_n">assign_n</code></td>
<td>
<p>manually assign the number of low outliers or
high outliers when method is <code>both</code></p>
</td></tr>
<tr><td><code id="gen_outlier_+3A_only_out">only_out</code></td>
<td>
<p>only return outliers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number vector of outliers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(0, 100, 1)

gen_outlier(x, 10)

# generation limits
gen_outlier(x, 10, lim = c(-80, 160))

# assign the low and high outliers
gen_outlier(x, 10, lim = c(-80, 160), assign_n = c(0.1, 0.9))

# just generate low outliers
gen_outlier(x, 10, side = "low")

# return with raw vector
gen_outlier(x, 10, only_out = FALSE)

</code></pre>

<hr>
<h2 id='gen_str'>generate strings</h2><span id='topic+gen_str'></span>

<h3>Description</h3>

<p>generate strings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_str(n = 1, len = 3, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_str_+3A_n">n</code></td>
<td>
<p>number of strings to generate</p>
</td></tr>
<tr><td><code id="gen_str_+3A_len">len</code></td>
<td>
<p>string length</p>
</td></tr>
<tr><td><code id="gen_str_+3A_seed">seed</code></td>
<td>
<p>random seed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gen_str(n = 2, len = 3)
</code></pre>

<hr>
<h2 id='gen_tb'>generate tibbles</h2><span id='topic+gen_tb'></span>

<h3>Description</h3>

<p>generate tibbles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_tb(nrow = 3, ncol = 4, fill = "float", colnames = NULL, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_tb_+3A_nrow">nrow</code></td>
<td>
<p>number of rows</p>
</td></tr>
<tr><td><code id="gen_tb_+3A_ncol">ncol</code></td>
<td>
<p>number of columns</p>
</td></tr>
<tr><td><code id="gen_tb_+3A_fill">fill</code></td>
<td>
<p>fill by, one of <code style="white-space: pre;">&#8288;float, int, char, str&#8288;</code></p>
</td></tr>
<tr><td><code id="gen_tb_+3A_colnames">colnames</code></td>
<td>
<p>names of columns</p>
</td></tr>
<tr><td><code id="gen_tb_+3A_seed">seed</code></td>
<td>
<p>random seed</p>
</td></tr>
<tr><td><code id="gen_tb_+3A_...">...</code></td>
<td>
<p>parameters of <code style="white-space: pre;">&#8288;rnorm, gen_char, gen_str&#8288;</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gen_tb()

gen_tb(fill = "str", nrow = 3, ncol = 4, len = 3)
</code></pre>

<hr>
<h2 id='generate_ticks'>generate ticks for a number vector</h2><span id='topic+generate_ticks'></span>

<h3>Description</h3>

<p>generate ticks for a number vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_ticks(x, expect_ticks = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_ticks_+3A_x">x</code></td>
<td>
<p>number vector</p>
</td></tr>
<tr><td><code id="generate_ticks_+3A_expect_ticks">expect_ticks</code></td>
<td>
<p>expected number of ticks, may be a little different from
the result</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ticks number
</p>


<h3>Examples</h3>

<pre><code class='language-R'>generate_ticks(c(176, 198, 264))
</code></pre>

<hr>
<h2 id='geom_mean'>geometric mean</h2><span id='topic+geom_mean'></span>

<h3>Description</h3>

<p>geometric mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_mean(x, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_mean_+3A_x">x</code></td>
<td>
<p>value</p>
</td></tr>
<tr><td><code id="geom_mean_+3A_na.rm">na.rm</code></td>
<td>
<p>remove NA or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>geometric mean value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geom_mean(1, 9)
</code></pre>

<hr>
<h2 id='group_vector'>group character vector by a regex pattern</h2><span id='topic+group_vector'></span>

<h3>Description</h3>

<p>group character vector by a regex pattern
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_vector(x, pattern = "\\w")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_vector_+3A_x">x</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="group_vector_+3A_pattern">pattern</code></td>
<td>
<p>regex pattern, '\w' as default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- c(
  stringr::str_c("A", c(1, 2, 9, 10, 11, 12, 99, 101, 102)),
  stringr::str_c("B", c(1, 2, 9, 10, 21, 32, 99, 101, 102))
) %&gt;% sample()

group_vector(v)

group_vector(v, pattern = "\\w\\d")

group_vector(v, pattern = "\\w(\\d)")

# unmatched part will alse be stored
group_vector(v, pattern = "\\d{2}")

</code></pre>

<hr>
<h2 id='hist_bins'>separate numeric x into bins</h2><span id='topic+hist_bins'></span>

<h3>Description</h3>

<p>separate numeric x into bins
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hist_bins(x, bins = 10, lim = c(min(x), max(x)), breaks = NULL, sort = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist_bins_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="hist_bins_+3A_bins">bins</code></td>
<td>
<p>bins number, defaults to 10</p>
</td></tr>
<tr><td><code id="hist_bins_+3A_lim">lim</code></td>
<td>
<p>the min and max limits of bins, default as <code>c(min(x), max(x))</code></p>
</td></tr>
<tr><td><code id="hist_bins_+3A_breaks">breaks</code></td>
<td>
<p>assign breaks directly and will ignore <code>bins</code> and <code>lim</code></p>
</td></tr>
<tr><td><code id="hist_bins_+3A_sort">sort</code></td>
<td>
<p>sort the result tibble</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- dplyr::pull(mini_diamond, price, id)

hist_bins(x, bins = 20)

</code></pre>

<hr>
<h2 id='inner_expand'>like <code>dplyr::inner_join</code> while ignore the same columns in right tibble</h2><span id='topic+inner_expand'></span>

<h3>Description</h3>

<p>like <code>dplyr::inner_join</code> while ignore the same columns in right tibble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inner_expand(x, y, by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inner_expand_+3A_x">x</code></td>
<td>
<p>left tibble</p>
</td></tr>
<tr><td><code id="inner_expand_+3A_y">y</code></td>
<td>
<p>right tibble</p>
</td></tr>
<tr><td><code id="inner_expand_+3A_by">by</code></td>
<td>
<p>columns to join by</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tb1 &lt;- head(mini_diamond, 4)
tb2 &lt;- tibble::tibble(
  id = c("id-2", "id-4", "id-5"),
  carat = 1:3,
  price = c(1000, 2000, 3000),
  newcol = c("new2", "new4", "new5")
)

left_expand(tb1, tb2, by = "id")

full_expand(tb1, tb2, by = "id")

inner_expand(tb1, tb2, by = "id")
</code></pre>

<hr>
<h2 id='int_digits'>trans numbers to a fixed integer digit length</h2><span id='topic+int_digits'></span>

<h3>Description</h3>

<p>trans numbers to a fixed integer digit length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int_digits(x, digits = 2, scale_factor = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="int_digits_+3A_x">x</code></td>
<td>
<p>number</p>
</td></tr>
<tr><td><code id="int_digits_+3A_digits">digits</code></td>
<td>
<p>integer digit length</p>
</td></tr>
<tr><td><code id="int_digits_+3A_scale_factor">scale_factor</code></td>
<td>
<p>return the scale_factor instead of value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number
</p>


<h3>Examples</h3>

<pre><code class='language-R'>int_digits(0.0332, 1)
</code></pre>

<hr>
<h2 id='is.zero'>if a number only have zeros</h2><span id='topic+is.zero'></span>

<h3>Description</h3>

<p>if a number only have zeros
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.zero(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.zero_+3A_x">x</code></td>
<td>
<p>number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>all zero or not
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.zero(c("0.000", "0.102", NA))
</code></pre>

<hr>
<h2 id='left_expand'>like <code>dplyr::left_join</code> while ignore the same columns in right tibble</h2><span id='topic+left_expand'></span>

<h3>Description</h3>

<p>like <code>dplyr::left_join</code> while ignore the same columns in right tibble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>left_expand(x, y, by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="left_expand_+3A_x">x</code></td>
<td>
<p>left tibble</p>
</td></tr>
<tr><td><code id="left_expand_+3A_y">y</code></td>
<td>
<p>right tibble</p>
</td></tr>
<tr><td><code id="left_expand_+3A_by">by</code></td>
<td>
<p>columns to join by</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tb1 &lt;- head(mini_diamond, 4)
tb2 &lt;- tibble::tibble(
  id = c("id-2", "id-4", "id-5"),
  carat = 1:3,
  price = c(1000, 2000, 3000),
  newcol = c("new2", "new4", "new5")
)

left_expand(tb1, tb2, by = "id")

full_expand(tb1, tb2, by = "id")

inner_expand(tb1, tb2, by = "id")
</code></pre>

<hr>
<h2 id='list2df'>trans list into data.frame</h2><span id='topic+list2df'></span>

<h3>Description</h3>

<p>trans list into data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list2df(x, rownames = TRUE, colnames = NULL, method = "row")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list2df_+3A_x">x</code></td>
<td>
<p>list</p>
</td></tr>
<tr><td><code id="list2df_+3A_rownames">rownames</code></td>
<td>
<p>use rownames or not</p>
</td></tr>
<tr><td><code id="list2df_+3A_colnames">colnames</code></td>
<td>
<p>colnames of the output</p>
</td></tr>
<tr><td><code id="list2df_+3A_method">method</code></td>
<td>
<p>one of <code style="white-space: pre;">&#8288;row, col&#8288;</code>, set each item as row or col, default as row</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(
  c("a", "1"),
  c("b", "2"),
  c("c", "3")
)

list2df(x, colnames = c("char", "num"))

x &lt;- list(
  c("a", "b", "c"),
  c("1", "2", "3")
)

list2df(x, method = "col")
</code></pre>

<hr>
<h2 id='max_depth'>max depth of a list</h2><span id='topic+max_depth'></span>

<h3>Description</h3>

<p>max depth of a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_depth(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_depth_+3A_x">x</code></td>
<td>
<p>list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
max_depth(list(a = list(b = list(c = 1), d = 2, e = 3)))

</code></pre>

<hr>
<h2 id='melt_vector'>melt a vector into single value</h2><span id='topic+melt_vector'></span>

<h3>Description</h3>

<p>melt a vector into single value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>melt_vector(x, method = "first", invalid = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="melt_vector_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="melt_vector_+3A_method">method</code></td>
<td>
<p>how to melt, should be one of
<code>first|last</code>, or one of <code>sum|mean|median</code> for numeric vector,
or some characters (e.g. <code style="white-space: pre;">&#8288;,|.| |;&#8288;</code>) for character vector</p>
</td></tr>
<tr><td><code id="melt_vector_+3A_invalid">invalid</code></td>
<td>
<p>invalid value to ignore, <code>NA</code> as default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>melted single value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
melt_vector(c(NA, 2, 3), method = "first")

melt_vector(c(NA, 2, 3), method = "sum")

melt_vector(c(NA, 2, 3), method = ",")

melt_vector(c(NA, 2, Inf), invalid = c(NA, Inf))

</code></pre>

<hr>
<h2 id='mini_diamond'>Minimal tibble dataset adjusted from diamond</h2><span id='topic+mini_diamond'></span>

<h3>Description</h3>

<p>Minimal tibble dataset adjusted from diamond
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mini_diamond
</code></pre>


<h3>Format</h3>



<h4><code>mini_diamond</code></h4>

<p>A data frame with 100 rows and 7 columns:
</p>

<dl>
<dt>id</dt><dd><p>unique id</p>
</dd>
<dt>cut, clarity</dt><dd><p>2 category variables</p>
</dd>
<dt>carat, price, x, y</dt><dd><p>4 continuous variables</p>
</dd>
</dl>
<p>...

</p>



<h3>Source</h3>

<p>adjusted from <code>ggplot2</code>
</p>

<hr>
<h2 id='mm_norm'>max-min normalization</h2><span id='topic+mm_norm'></span>

<h3>Description</h3>

<p>max-min normalization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mm_norm(x, low = 0, high = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mm_norm_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="mm_norm_+3A_low">low</code></td>
<td>
<p>low limit of result, 0 as default</p>
</td></tr>
<tr><td><code id="mm_norm_+3A_high">high</code></td>
<td>
<p>high limit of result, 1 as default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>normed vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mm_norm(c(1, 3, 4))

</code></pre>

<hr>
<h2 id='move_row'>move selected rows to target location</h2><span id='topic+move_row'></span>

<h3>Description</h3>

<p>move selected rows to target location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>move_row(df, rows, .after = FALSE, .before = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="move_row_+3A_df">df</code></td>
<td>
<p>tibble</p>
</td></tr>
<tr><td><code id="move_row_+3A_rows">rows</code></td>
<td>
<p>selected rows indexes</p>
</td></tr>
<tr><td><code id="move_row_+3A_.after">.after</code></td>
<td>
<p><code>TRUE</code> will move selected rows to the last row,
or you can pass a target row index</p>
</td></tr>
<tr><td><code id="move_row_+3A_.before">.before</code></td>
<td>
<p><code>TRUE</code> will move selected rows to the first row,
or you can pass a target row index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>reordered tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>move_row(mini_diamond, 3:5, .after = 8)
</code></pre>

<hr>
<h2 id='near_ticks'>the ticks near a number</h2><span id='topic+near_ticks'></span>

<h3>Description</h3>

<p>the ticks near a number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>near_ticks(x, level = NULL, div = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="near_ticks_+3A_x">x</code></td>
<td>
<p>number</p>
</td></tr>
<tr><td><code id="near_ticks_+3A_level">level</code></td>
<td>
<p>the level of ticks, such as 1, 10, 100, etc.</p>
</td></tr>
<tr><td><code id="near_ticks_+3A_div">div</code></td>
<td>
<p>number of divisions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number vector of ticks
</p>


<h3>Examples</h3>

<pre><code class='language-R'>near_ticks(3462, level = 10)
</code></pre>

<hr>
<h2 id='nearest_tick'>the nearest ticks around a number</h2><span id='topic+nearest_tick'></span>

<h3>Description</h3>

<p>the nearest ticks around a number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearest_tick(x, side = "both", level = NULL, div = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearest_tick_+3A_x">x</code></td>
<td>
<p>number</p>
</td></tr>
<tr><td><code id="nearest_tick_+3A_side">side</code></td>
<td>
<p>default as 'both', can be 'both|left|right'</p>
</td></tr>
<tr><td><code id="nearest_tick_+3A_level">level</code></td>
<td>
<p>the level of ticks, such as 1, 10, 100, etc.</p>
</td></tr>
<tr><td><code id="nearest_tick_+3A_div">div</code></td>
<td>
<p>number of divisions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nearest tick number
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nearest_tick(3462, level = 10)
</code></pre>

<hr>
<h2 id='not.na'>not NA</h2><span id='topic+not.na'></span>

<h3>Description</h3>

<p>not NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>not.na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="not.na_+3A_x">x</code></td>
<td>
<p>value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>not.na(NA)
</code></pre>

<hr>
<h2 id='not.null'>not NULL</h2><span id='topic+not.null'></span>

<h3>Description</h3>

<p>not NULL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>not.null(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="not.null_+3A_x">x</code></td>
<td>
<p>value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>not.null(NULL)
</code></pre>

<hr>
<h2 id='number_fun_wrapper'>wrapper of the functions to process number string with prefix and suffix</h2><span id='topic+number_fun_wrapper'></span>

<h3>Description</h3>

<p>wrapper of the functions to process number string with prefix and suffix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>number_fun_wrapper(
  x,
  fun = ~.x,
  prefix_ext = NULL,
  suffix_ext = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="number_fun_wrapper_+3A_x">x</code></td>
<td>
<p>number string vector with prefix and suffix</p>
</td></tr>
<tr><td><code id="number_fun_wrapper_+3A_fun">fun</code></td>
<td>
<p>process function</p>
</td></tr>
<tr><td><code id="number_fun_wrapper_+3A_prefix_ext">prefix_ext</code></td>
<td>
<p>prefix extension</p>
</td></tr>
<tr><td><code id="number_fun_wrapper_+3A_suffix_ext">suffix_ext</code></td>
<td>
<p>suffix extension</p>
</td></tr>
<tr><td><code id="number_fun_wrapper_+3A_verbose">verbose</code></td>
<td>
<p>print more details</p>
</td></tr>
</table>


<h3>Value</h3>

<p>processed number with prefix and suffix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>number_fun_wrapper("&gt;=2.134%", function(x) round(x, 2))
</code></pre>

<hr>
<h2 id='ordered_slice'>slice a tibble by an ordered vector</h2><span id='topic+ordered_slice'></span>

<h3>Description</h3>

<p>slice a tibble by an ordered vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordered_slice(df, by, ordered_vector, na.rm = FALSE, dup.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordered_slice_+3A_df">df</code></td>
<td>
<p>tibble</p>
</td></tr>
<tr><td><code id="ordered_slice_+3A_by">by</code></td>
<td>
<p>slice by this column, this value must has no duplicated value</p>
</td></tr>
<tr><td><code id="ordered_slice_+3A_ordered_vector">ordered_vector</code></td>
<td>
<p>ordered vector</p>
</td></tr>
<tr><td><code id="ordered_slice_+3A_na.rm">na.rm</code></td>
<td>
<p>remove NA or unknown values from ordered vector</p>
</td></tr>
<tr><td><code id="ordered_slice_+3A_dup.rm">dup.rm</code></td>
<td>
<p>remove duplication values from ordered vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sliced tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ordered_slice(mini_diamond, id, c("id-3", "id-2"))
</code></pre>

<hr>
<h2 id='percent_to_float'>from percent number to float number</h2><span id='topic+percent_to_float'></span>

<h3>Description</h3>

<p>from percent number to float number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>percent_to_float(x, digits = 2, to_double = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="percent_to_float_+3A_x">x</code></td>
<td>
<p>percent number character</p>
</td></tr>
<tr><td><code id="percent_to_float_+3A_digits">digits</code></td>
<td>
<p>hold n digits after the decimal point</p>
</td></tr>
<tr><td><code id="percent_to_float_+3A_to_double">to_double</code></td>
<td>
<p>use double output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>float character or double of x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>percent_to_float("12%")
</code></pre>

<hr>
<h2 id='pileup_logical'>pileup another logical vector on the TRUE values of first vector</h2><span id='topic+pileup_logical'></span>

<h3>Description</h3>

<p>pileup another logical vector on the TRUE values of first vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pileup_logical(x, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pileup_logical_+3A_x">x</code></td>
<td>
<p>logical vector</p>
</td></tr>
<tr><td><code id="pileup_logical_+3A_v">v</code></td>
<td>
<p>another logical vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# first vector have 2 TRUE value
v1 &lt;- c(TRUE, FALSE, TRUE)

# the length of second vector should also be 2
v2 &lt;- c(FALSE, TRUE)

pileup_logical(v1, v2)

</code></pre>

<hr>
<h2 id='pkginfo'>information of packages</h2><span id='topic+pkginfo'></span>

<h3>Description</h3>

<p>information of packages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkginfo(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pkginfo_+3A_...">...</code></td>
<td>
<p>case-insensitive package names</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>baizer::pkginfo(dplyr)
</code></pre>

<hr>
<h2 id='pkglib'>load packages as a batch</h2><span id='topic+pkglib'></span>

<h3>Description</h3>

<p>load packages as a batch
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkglib(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pkglib_+3A_...">...</code></td>
<td>
<p>pkgs</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>baizer::pkglib(dplyr, purrr)
</code></pre>

<hr>
<h2 id='pkgver'>versions of packages</h2><span id='topic+pkgver'></span>

<h3>Description</h3>

<p>versions of packages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkgver(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pkgver_+3A_...">...</code></td>
<td>
<p>case-insensitive package names</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>baizer::pkgver(dplyr, purrr)
</code></pre>

<hr>
<h2 id='pos_int_split'>split a positive integer number as a number vector</h2><span id='topic+pos_int_split'></span>

<h3>Description</h3>

<p>split a positive integer number as a number vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pos_int_split(x, n, method = "average")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pos_int_split_+3A_x">x</code></td>
<td>
<p>positive integer</p>
</td></tr>
<tr><td><code id="pos_int_split_+3A_n">n</code></td>
<td>
<p>length of the output</p>
</td></tr>
<tr><td><code id="pos_int_split_+3A_method">method</code></td>
<td>
<p>should be one of <code style="white-space: pre;">&#8288;average, random&#8288;</code>, or a number vector which
length is n</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pos_int_split(12, 3, method = "average")

pos_int_split(12, 3, method = "random")

pos_int_split(12, 3, method = c(1, 2, 3))

</code></pre>

<hr>
<h2 id='r2c'>wrapper of tibble::rownames_to_column</h2><span id='topic+r2c'></span>

<h3>Description</h3>

<p>wrapper of tibble::rownames_to_column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r2c(df, col = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r2c_+3A_df">df</code></td>
<td>
<p>tibble</p>
</td></tr>
<tr><td><code id="r2c_+3A_col">col</code></td>
<td>
<p>a col name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mini_diamond %&gt;%
  c2r("id") %&gt;%
  r2c("id")
</code></pre>

<hr>
<h2 id='read_excel'>read excel file</h2><span id='topic+read_excel'></span>

<h3>Description</h3>

<p>read excel file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_excel(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_excel_+3A_...">...</code></td>
<td>
<p>arguments of <code>readxl::read_excel</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>

<hr>
<h2 id='read_excel_list'>read multi-sheet excel file as a list of tibbles</h2><span id='topic+read_excel_list'></span>

<h3>Description</h3>

<p>read multi-sheet excel file as a list of tibbles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_excel_list(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_excel_list_+3A_x">x</code></td>
<td>
<p>path</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>

<hr>
<h2 id='read_fmmd'>read front matter markdown</h2><span id='topic+read_fmmd'></span>

<h3>Description</h3>

<p>read front matter markdown
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_fmmd(x, rm_blank_line = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_fmmd_+3A_x">x</code></td>
<td>
<p>path</p>
</td></tr>
<tr><td><code id="read_fmmd_+3A_rm_blank_line">rm_blank_line</code></td>
<td>
<p>remove leading and trailing blank lines</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>

<hr>
<h2 id='ref_level'>relevel a target column by another reference column</h2><span id='topic+ref_level'></span>

<h3>Description</h3>

<p>relevel a target column by another reference column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ref_level(x, col, ref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ref_level_+3A_x">x</code></td>
<td>
<p>tibble</p>
</td></tr>
<tr><td><code id="ref_level_+3A_col">col</code></td>
<td>
<p>target column</p>
</td></tr>
<tr><td><code id="ref_level_+3A_ref">ref</code></td>
<td>
<p>reference column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cut_level &lt;- mini_diamond %&gt;%
  dplyr::pull(cut) %&gt;%
  unique()

mini_diamond %&gt;%
  dplyr::mutate(cut = factor(cut, cut_level)) %&gt;%
  dplyr::mutate(cut0 = stringr::str_c(cut, "xxx")) %&gt;%
  ref_level(cut0, cut)
</code></pre>

<hr>
<h2 id='reg_join'>join the matched parts into string</h2><span id='topic+reg_join'></span>

<h3>Description</h3>

<p>join the matched parts into string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reg_join(x, pattern, sep = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reg_join_+3A_x">x</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="reg_join_+3A_pattern">pattern</code></td>
<td>
<p>regex pattern</p>
</td></tr>
<tr><td><code id="reg_join_+3A_sep">sep</code></td>
<td>
<p>separator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reg_join(c("A_12.B", "C_3.23:2"), "[A-Za-z]+")

reg_join(c("A_12.B", "C_3.23:2"), "\\w+")

reg_join(c("A_12.B", "C_3.23:2"), "\\d+", sep = ",")

reg_join(c("A_12.B", "C_3.23:2"), "\\d", sep = ",")

</code></pre>

<hr>
<h2 id='reg_match'>regex match</h2><span id='topic+reg_match'></span>

<h3>Description</h3>

<p>regex match
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reg_match(x, pattern, group = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reg_match_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="reg_match_+3A_pattern">pattern</code></td>
<td>
<p>regex pattern</p>
</td></tr>
<tr><td><code id="reg_match_+3A_group">group</code></td>
<td>
<p>regex group, 1 as default. when group=-1,
return full matched tibble</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector or tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- stringr::str_c("id", 1:3, c("A", "B", "C"))

reg_match(v, "id(\\d+)(\\w)")

reg_match(v, "id(\\d+)(\\w)", group = 2)

reg_match(v, "id(\\d+)(\\w)", group = -1)

</code></pre>

<hr>
<h2 id='remove_monocol'>remove columns by the ratio of an identical single value (NA supported)</h2><span id='topic+remove_monocol'></span>

<h3>Description</h3>

<p>remove columns by the ratio of an identical single value (NA supported)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_monocol(df, max_ratio = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_monocol_+3A_df">df</code></td>
<td>
<p>tibble</p>
</td></tr>
<tr><td><code id="remove_monocol_+3A_max_ratio">max_ratio</code></td>
<td>
<p>the max single value ratio to keep this column, default is 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'># remove_monocol(df)
</code></pre>

<hr>
<h2 id='remove_nacol'>remove columns by the ratio of NA</h2><span id='topic+remove_nacol'></span>

<h3>Description</h3>

<p>remove columns by the ratio of NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_nacol(df, max_ratio = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_nacol_+3A_df">df</code></td>
<td>
<p>tibble</p>
</td></tr>
<tr><td><code id="remove_nacol_+3A_max_ratio">max_ratio</code></td>
<td>
<p>the max NA ratio to keep this column, default is 1
have NA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'># remove_nacol(df)
</code></pre>

<hr>
<h2 id='remove_narow'>remove rows by the ratio of NA</h2><span id='topic+remove_narow'></span>

<h3>Description</h3>

<p>remove rows by the ratio of NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_narow(df, ..., max_ratio = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_narow_+3A_df">df</code></td>
<td>
<p>tibble</p>
</td></tr>
<tr><td><code id="remove_narow_+3A_...">...</code></td>
<td>
<p>only remove rows according to these columns,
refer to <code>dplyr::select()</code></p>
</td></tr>
<tr><td><code id="remove_narow_+3A_max_ratio">max_ratio</code></td>
<td>
<p>the max NA ratio to keep this row, default is 1
have NA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'># remove_narow(df)
</code></pre>

<hr>
<h2 id='remove_outliers'>remove outliers and NA</h2><span id='topic+remove_outliers'></span>

<h3>Description</h3>

<p>remove outliers and NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_outliers(df, col, .by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_outliers_+3A_df">df</code></td>
<td>
<p>tibble</p>
</td></tr>
<tr><td><code id="remove_outliers_+3A_col">col</code></td>
<td>
<p>columns to remove outliers</p>
</td></tr>
<tr><td><code id="remove_outliers_+3A_.by">.by</code></td>
<td>
<p>group by</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>remove_outliers(mini_diamond, price)
</code></pre>

<hr>
<h2 id='replace_item'>replace the items of one object by another</h2><span id='topic+replace_item'></span>

<h3>Description</h3>

<p>replace the items of one object by another
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_item(x, y, keep_extra = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_item_+3A_x">x</code></td>
<td>
<p>number, character or list</p>
</td></tr>
<tr><td><code id="replace_item_+3A_y">y</code></td>
<td>
<p>another object, the class of y should be same as x</p>
</td></tr>
<tr><td><code id="replace_item_+3A_keep_extra">keep_extra</code></td>
<td>
<p>whether keep extra items in y</p>
</td></tr>
</table>


<h3>Value</h3>

<p>replaced object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- list(A = 1, B = 3)
y &lt;- list(A = 9, C = 10)

replace_item(x, y)

replace_item(x, y, keep_extra = TRUE)

</code></pre>

<hr>
<h2 id='rewrite_na'>rewrite the NA values in a tibble by another tibble</h2><span id='topic+rewrite_na'></span>

<h3>Description</h3>

<p>rewrite the NA values in a tibble by another tibble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rewrite_na(x, y, by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rewrite_na_+3A_x">x</code></td>
<td>
<p>raw tibble</p>
</td></tr>
<tr><td><code id="rewrite_na_+3A_y">y</code></td>
<td>
<p>replace reference tibble</p>
</td></tr>
<tr><td><code id="rewrite_na_+3A_by">by</code></td>
<td>
<p>columns to align the tibbles</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tb1 &lt;- tibble::tibble(
  id = c("id-1", "id-2", "id-3", "id-4"),
  group = c("a", "b", "a", "b"),
  price = c(0, -200, 3000, NA),
  type = c("large", "none", "small", "none")
)

tb2 &lt;- tibble::tibble(
  id = c("id-1", "id-2", "id-3", "id-4"),
  group = c("a", "b", "a", "b"),
  price = c(1, 2, 3, 4),
  type = c("l", "x", "x", "m")
)

rewrite_na(tb1, tb2, by = c("id", "group"))
</code></pre>

<hr>
<h2 id='rng2seq'>trans range character into seq characters</h2><span id='topic+rng2seq'></span>

<h3>Description</h3>

<p>trans range character into seq characters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rng2seq(x, sep = "-")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rng2seq_+3A_x">x</code></td>
<td>
<p>range character</p>
</td></tr>
<tr><td><code id="rng2seq_+3A_sep">sep</code></td>
<td>
<p>range separator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>seq characters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rng2seq(c("1-5", "2"))
</code></pre>

<hr>
<h2 id='round_string'>from float number to fixed digits character</h2><span id='topic+round_string'></span>

<h3>Description</h3>

<p>from float number to fixed digits character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round_string(x, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="round_string_+3A_x">x</code></td>
<td>
<p>number</p>
</td></tr>
<tr><td><code id="round_string_+3A_digits">digits</code></td>
<td>
<p>hold n digits after the decimal point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>round_string(1.1, 2)
</code></pre>

<hr>
<h2 id='roxygen_fmt'>add #' into each line of codes for roxygen examples</h2><span id='topic+roxygen_fmt'></span>

<h3>Description</h3>

<p>add #' into each line of codes for roxygen examples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roxygen_fmt(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roxygen_fmt_+3A_x">x</code></td>
<td>
<p>codes</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
roxygen_fmt(
  "
code line1
code line2
"
)

</code></pre>

<hr>
<h2 id='same_index'>the index of identical character</h2><span id='topic+same_index'></span>

<h3>Description</h3>

<p>the index of identical character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>same_index(s1, s2, nth = NULL, ignore_case = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="same_index_+3A_s1">s1</code></td>
<td>
<p>string1</p>
</td></tr>
<tr><td><code id="same_index_+3A_s2">s2</code></td>
<td>
<p>string2</p>
</td></tr>
<tr><td><code id="same_index_+3A_nth">nth</code></td>
<td>
<p>just return nth index</p>
</td></tr>
<tr><td><code id="same_index_+3A_ignore_case">ignore_case</code></td>
<td>
<p>ignore upper or lower cases</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of identical character indices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>same_index("AAAA", "ABBA")
</code></pre>

<hr>
<h2 id='seriate_df'>dataframe rows seriation, which will reorder the rows in a better pattern</h2><span id='topic+seriate_df'></span>

<h3>Description</h3>

<p>dataframe rows seriation, which will reorder the rows in a better pattern
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seriate_df(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seriate_df_+3A_x">x</code></td>
<td>
<p>dataframe</p>
</td></tr>
</table>


<h3>Value</h3>

<p>seriated dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- mini_diamond %&gt;%
  dplyr::select(id, dplyr::where(is.numeric)) %&gt;%
  dplyr::mutate(
    dplyr::across(
      dplyr::where(is.numeric),
      ~ round(.x / max(.x), 4)
    )
  ) %&gt;%
  c2r("id")

seriate_df(x)

</code></pre>

<hr>
<h2 id='sftp_connect'>connection parameters to remote server via sftp</h2><span id='topic+sftp_connect'></span>

<h3>Description</h3>

<p>connection parameters to remote server via sftp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sftp_connect(
  server = "localhost",
  port = 22,
  user = NULL,
  password = NULL,
  wd = "~"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sftp_connect_+3A_server">server</code></td>
<td>
<p>remote server</p>
</td></tr>
<tr><td><code id="sftp_connect_+3A_port">port</code></td>
<td>
<p>SSH port, 22 as default</p>
</td></tr>
<tr><td><code id="sftp_connect_+3A_user">user</code></td>
<td>
<p>username</p>
</td></tr>
<tr><td><code id="sftp_connect_+3A_password">password</code></td>
<td>
<p>password</p>
</td></tr>
<tr><td><code id="sftp_connect_+3A_wd">wd</code></td>
<td>
<p>workdir</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sftp_connection object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sftp_con &lt;- sftp_connect(server='remote_host', port=22,
#     user='username', password = "password", wd='~')
</code></pre>

<hr>
<h2 id='sftp_download'>download file from remote server via sftp</h2><span id='topic+sftp_download'></span>

<h3>Description</h3>

<p>download file from remote server via sftp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sftp_download(sftp_con, path = NULL, to = basename(path))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sftp_download_+3A_sftp_con">sftp_con</code></td>
<td>
<p>sftp_connection created by sftp_connect()</p>
</td></tr>
<tr><td><code id="sftp_download_+3A_path">path</code></td>
<td>
<p>remote file path</p>
</td></tr>
<tr><td><code id="sftp_download_+3A_to">to</code></td>
<td>
<p>local target path</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># sftp_download(sftp_con,
#   path=c('t1.txt', 't2.txt'),
#   to=c('path1.txt', 'path2.txt')
</code></pre>

<hr>
<h2 id='sftp_ls'>list files from remote server via sftp</h2><span id='topic+sftp_ls'></span>

<h3>Description</h3>

<p>list files from remote server via sftp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sftp_ls(sftp_con, path = NULL, all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sftp_ls_+3A_sftp_con">sftp_con</code></td>
<td>
<p>sftp_connection created by sftp_connect()</p>
</td></tr>
<tr><td><code id="sftp_ls_+3A_path">path</code></td>
<td>
<p>remote directory path</p>
</td></tr>
<tr><td><code id="sftp_ls_+3A_all">all</code></td>
<td>
<p>list hidden files or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>files in the dir
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# sftp_ls(sftp_con, 'your/dir')

</code></pre>

<hr>
<h2 id='signif_ceiling'>signif while use ceiling</h2><span id='topic+signif_ceiling'></span>

<h3>Description</h3>

<p>signif while use ceiling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signif_ceiling(x, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signif_ceiling_+3A_x">x</code></td>
<td>
<p>number</p>
</td></tr>
<tr><td><code id="signif_ceiling_+3A_digits">digits</code></td>
<td>
<p>digits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number
</p>


<h3>Examples</h3>

<pre><code class='language-R'>signif_ceiling(3.11, 2)
</code></pre>

<hr>
<h2 id='signif_floor'>signif while use floor</h2><span id='topic+signif_floor'></span>

<h3>Description</h3>

<p>signif while use floor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signif_floor(x, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signif_floor_+3A_x">x</code></td>
<td>
<p>number</p>
</td></tr>
<tr><td><code id="signif_floor_+3A_digits">digits</code></td>
<td>
<p>digits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number
</p>


<h3>Examples</h3>

<pre><code class='language-R'>signif_floor(3.19, 2)
</code></pre>

<hr>
<h2 id='signif_round_string'>signif or round string depend on the character length</h2><span id='topic+signif_round_string'></span>

<h3>Description</h3>

<p>signif or round string depend on the character length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signif_round_string(
  x,
  digits = 2,
  format = "short",
  full_large = TRUE,
  full_small = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signif_round_string_+3A_x">x</code></td>
<td>
<p>number</p>
</td></tr>
<tr><td><code id="signif_round_string_+3A_digits">digits</code></td>
<td>
<p>signif or round digits</p>
</td></tr>
<tr><td><code id="signif_round_string_+3A_format">format</code></td>
<td>
<p>short or long</p>
</td></tr>
<tr><td><code id="signif_round_string_+3A_full_large">full_large</code></td>
<td>
<p>keep full digits for large number</p>
</td></tr>
<tr><td><code id="signif_round_string_+3A_full_small">full_small</code></td>
<td>
<p>keep full digits for small number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>signif or round strings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>signif_round_string(1.214, 2)
</code></pre>

<hr>
<h2 id='signif_string'>from float number to fixed significant digits character</h2><span id='topic+signif_string'></span>

<h3>Description</h3>

<p>from float number to fixed significant digits character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signif_string(x, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signif_string_+3A_x">x</code></td>
<td>
<p>number</p>
</td></tr>
<tr><td><code id="signif_string_+3A_digits">digits</code></td>
<td>
<p>hold n significant digits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>signif_string(1.1, 2)
</code></pre>

<hr>
<h2 id='slice_char'>slice character vector</h2><span id='topic+slice_char'></span>

<h3>Description</h3>

<p>slice character vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice_char(x, from = x[1], to = x[length(x)], unique = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slice_char_+3A_x">x</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="slice_char_+3A_from">from</code></td>
<td>
<p>from</p>
</td></tr>
<tr><td><code id="slice_char_+3A_to">to</code></td>
<td>
<p>to</p>
</td></tr>
<tr><td><code id="slice_char_+3A_unique">unique</code></td>
<td>
<p>remove the duplicated boundary characters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sliced vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("A", "B", "C", "D", "E")
slice_char(x, "A", "D")
slice_char(x, "D", "A")

x &lt;- c("A", "B", "C", "C", "A", "D", "D", "E", "A")
slice_char(x, "B", "E")
# duplicated element as boundary will throw an error
# slice_char(x, 'A', 'E')
# unique=TRUE to remove the duplicated boundary characters
slice_char(x, "A", "E", unique = TRUE)

</code></pre>

<hr>
<h2 id='sortf'>sort by a function</h2><span id='topic+sortf'></span>

<h3>Description</h3>

<p>sort by a function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortf(x, func, group_pattern = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortf_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="sortf_+3A_func">func</code></td>
<td>
<p>a function used by the sort</p>
</td></tr>
<tr><td><code id="sortf_+3A_group_pattern">group_pattern</code></td>
<td>
<p>a regex pattern to group by, only available if x is a
character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sortf(c(-2, 1, 3), abs)

v &lt;- stringr::str_c("id", c(1, 2, 9, 10, 11, 12, 99, 101, 102)) %&gt;% sample()

sortf(v, function(x) reg_match(x, "\\d+") %&gt;% as.double())

sortf(v, ~ reg_match(.x, "\\d+") %&gt;% as.double())

v &lt;- c(
  stringr::str_c("A", c(1, 2, 9, 10, 11, 12, 99, 101, 102)),
  stringr::str_c("B", c(1, 2, 9, 10, 21, 32, 99, 101, 102))
) %&gt;% sample()

sortf(v, ~ reg_match(.x, "\\d+") %&gt;% as.double(), group_pattern = "\\w")

</code></pre>

<hr>
<h2 id='split_column'>split a column and return a longer tibble</h2><span id='topic+split_column'></span>

<h3>Description</h3>

<p>split a column and return a longer tibble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_column(df, name_col, value_col, sep = ",")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_column_+3A_df">df</code></td>
<td>
<p>tibble</p>
</td></tr>
<tr><td><code id="split_column_+3A_name_col">name_col</code></td>
<td>
<p>repeat this as name column</p>
</td></tr>
<tr><td><code id="split_column_+3A_value_col">value_col</code></td>
<td>
<p>expand by this value column</p>
</td></tr>
<tr><td><code id="split_column_+3A_sep">sep</code></td>
<td>
<p>separator in the string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>expanded tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fancy_count(mini_diamond, cut, ext = clarity) %&gt;%
  split_column(name_col = cut, value_col = clarity)
</code></pre>

<hr>
<h2 id='split_path'>split a path into ancestor paths recursively</h2><span id='topic+split_path'></span>

<h3>Description</h3>

<p>split a path into ancestor paths recursively
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_path(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_path_+3A_path">path</code></td>
<td>
<p>path to split</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vectors of ancestor paths
</p>


<h3>Examples</h3>

<pre><code class='language-R'>split_path("/home/someone/a/test/path.txt")
</code></pre>

<hr>
<h2 id='split_vector'>split vector into list</h2><span id='topic+split_vector'></span>

<h3>Description</h3>

<p>split vector into list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_vector(vector, breaks, bounds = "(]")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_vector_+3A_vector">vector</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="split_vector_+3A_breaks">breaks</code></td>
<td>
<p>split breaks</p>
</td></tr>
<tr><td><code id="split_vector_+3A_bounds">bounds</code></td>
<td>
<p>&quot;(]&quot; as default, can also be &quot;[), []&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>split_vector(1:10, c(3, 7))
split_vector(stringr::str_split("ABCDEFGHIJ", "") %&gt;% unlist(),
  c(3, 7),
  bounds = "[)"
)
</code></pre>

<hr>
<h2 id='stat_fc'>fold change calculation which returns a extensible tibble</h2><span id='topic+stat_fc'></span>

<h3>Description</h3>

<p>fold change calculation which returns a extensible tibble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_fc(
  df,
  y,
  x,
  method = "mean",
  .by = NULL,
  rev_div = FALSE,
  digits = 2,
  fc_fmt = "short",
  suffix = "x"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_fc_+3A_df">df</code></td>
<td>
<p>tibble</p>
</td></tr>
<tr><td><code id="stat_fc_+3A_y">y</code></td>
<td>
<p>value</p>
</td></tr>
<tr><td><code id="stat_fc_+3A_x">x</code></td>
<td>
<p>sample test group</p>
</td></tr>
<tr><td><code id="stat_fc_+3A_method">method</code></td>
<td>
<p><code>'mean'|'median'|'geom_mean'</code>, the summary method</p>
</td></tr>
<tr><td><code id="stat_fc_+3A_.by">.by</code></td>
<td>
<p>super-group</p>
</td></tr>
<tr><td><code id="stat_fc_+3A_rev_div">rev_div</code></td>
<td>
<p>reverse division</p>
</td></tr>
<tr><td><code id="stat_fc_+3A_digits">digits</code></td>
<td>
<p>fold change digits</p>
</td></tr>
<tr><td><code id="stat_fc_+3A_fc_fmt">fc_fmt</code></td>
<td>
<p>fold change format, one of short, signif, round</p>
</td></tr>
<tr><td><code id="stat_fc_+3A_suffix">suffix</code></td>
<td>
<p>suffix of fold change, <code>x</code> as default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fold change result tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stat_fc(mini_diamond, y = price, x = cut, .by = clarity)
</code></pre>

<hr>
<h2 id='stat_phi'>calculate phi coefficient of two binary variables</h2><span id='topic+stat_phi'></span>

<h3>Description</h3>

<p>calculate phi coefficient of two binary variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_phi(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_phi_+3A_x">x</code></td>
<td>
<p>2x2 matrix or dataframe</p>
</td></tr>
</table>


<h3>Value</h3>

<p>phi coefficient
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- matrix(c(10, 8, 14, 18), nrow = 2)
stat_phi(data)
</code></pre>

<hr>
<h2 id='stat_test'>statistical test which returns a extensible tibble</h2><span id='topic+stat_test'></span>

<h3>Description</h3>

<p>statistical test which returns a extensible tibble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_test(
  df,
  y,
  x,
  .by = NULL,
  trans = "identity",
  paired = FALSE,
  paired_by = NULL,
  alternative = "two.sided",
  exclude_func = NULL,
  method = "wilcoxon",
  ns_symbol = "NS",
  digits = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_test_+3A_df">df</code></td>
<td>
<p>tibble</p>
</td></tr>
<tr><td><code id="stat_test_+3A_y">y</code></td>
<td>
<p>value</p>
</td></tr>
<tr><td><code id="stat_test_+3A_x">x</code></td>
<td>
<p>sample test group</p>
</td></tr>
<tr><td><code id="stat_test_+3A_.by">.by</code></td>
<td>
<p>super-group</p>
</td></tr>
<tr><td><code id="stat_test_+3A_trans">trans</code></td>
<td>
<p>scale transformation</p>
</td></tr>
<tr><td><code id="stat_test_+3A_paired">paired</code></td>
<td>
<p>paired samples or not</p>
</td></tr>
<tr><td><code id="stat_test_+3A_paired_by">paired_by</code></td>
<td>
<p>a column for pair</p>
</td></tr>
<tr><td><code id="stat_test_+3A_alternative">alternative</code></td>
<td>
<p>one of &quot;two.sided&quot; (default), &quot;greater&quot; or &quot;less&quot;</p>
</td></tr>
<tr><td><code id="stat_test_+3A_exclude_func">exclude_func</code></td>
<td>
<p>a function has two arguments and return bool value, used
if paired=TRUE and will keep the comparation pairs which return TRUE by this
function.</p>
</td></tr>
<tr><td><code id="stat_test_+3A_method">method</code></td>
<td>
<p>test method, 'wilcoxon' as default, one of <code>t|wilcoxon</code></p>
</td></tr>
<tr><td><code id="stat_test_+3A_ns_symbol">ns_symbol</code></td>
<td>
<p>symbol of nonsignificant, 'NS' as default</p>
</td></tr>
<tr><td><code id="stat_test_+3A_digits">digits</code></td>
<td>
<p>significant figure digits of p value
If the data pair of a single test returns TRUE, then exclude this pair</p>
</td></tr>
</table>


<h3>Value</h3>

<p>test result tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stat_test(mini_diamond, y = price, x = cut, .by = clarity)
</code></pre>

<hr>
<h2 id='str_replace_loc'>replace specific characters in a string by their locations</h2><span id='topic+str_replace_loc'></span>

<h3>Description</h3>

<p>replace specific characters in a string by their locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_replace_loc(x, start = 1, end = nchar(x), replacement = " ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_replace_loc_+3A_x">x</code></td>
<td>
<p>string</p>
</td></tr>
<tr><td><code id="str_replace_loc_+3A_start">start</code></td>
<td>
<p>start</p>
</td></tr>
<tr><td><code id="str_replace_loc_+3A_end">end</code></td>
<td>
<p>end</p>
</td></tr>
<tr><td><code id="str_replace_loc_+3A_replacement">replacement</code></td>
<td>
<p>replacement</p>
</td></tr>
</table>


<h3>Value</h3>

<p>replaced string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str_replace_loc("abcde", 1, 3, "A")
</code></pre>

<hr>
<h2 id='swap_vecname'>swap the names and values of a vector</h2><span id='topic+swap_vecname'></span>

<h3>Description</h3>

<p>swap the names and values of a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swap_vecname(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swap_vecname_+3A_x">x</code></td>
<td>
<p>vector without duplicated values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>swapped vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- c("a" = "A", "b" = "B", "c" = "C")
swap_vecname(v)

</code></pre>

<hr>
<h2 id='tbflt'>create a tbflt object to save filter conditions</h2><span id='topic+tbflt'></span>

<h3>Description</h3>

<p><code>tbflt()</code> can save a series of filter conditions, and support
logical operating among conditions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tbflt(x = expression(), .env = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tbflt_+3A_x">x</code></td>
<td>
<p>any expression</p>
</td></tr>
<tr><td><code id="tbflt_+3A_.env">.env</code></td>
<td>
<p>environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tbflt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c1 &lt;- tbflt(cut == "Fair")

c2 &lt;- tbflt(x &gt; 8)

!c1

c1 | c2

c1 &amp; c2

</code></pre>

<hr>
<h2 id='tdf'>transpose a dataframe</h2><span id='topic+tdf'></span>

<h3>Description</h3>

<p>transpose a dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tdf(x, colnames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tdf_+3A_x">x</code></td>
<td>
<p>dataframe</p>
</td></tr>
<tr><td><code id="tdf_+3A_colnames">colnames</code></td>
<td>
<p>column names of the transposed dataframe</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c2r(mini_diamond, "id")
tdf(x)

</code></pre>

<hr>
<h2 id='tidyeval'>Tidy eval helpers</h2><span id='topic+tidyeval'></span><span id='topic+enquo'></span><span id='topic+enquos'></span><span id='topic+.data'></span><span id='topic++3A+3D'></span><span id='topic+as_name'></span><span id='topic+as_label'></span>

<h3>Description</h3>

<p>This page lists the tidy eval tools reexported in this package from
rlang. To learn about using tidy eval in scripts and packages at a
high level, see the <a href="https://dplyr.tidyverse.org/articles/programming.html">dplyr programming vignette</a>
and the <a href="https://ggplot2.tidyverse.org/articles/ggplot2-in-packages.html">ggplot2 in packages vignette</a>.
The <a href="https://adv-r.hadley.nz/metaprogramming.html">Metaprogramming section</a> of <a href="https://adv-r.hadley.nz">Advanced R</a> may also be useful for a deeper dive.
</p>

<ul>
<li><p> The tidy eval operators <code style="white-space: pre;">&#8288;{{&#8288;</code>, <code style="white-space: pre;">&#8288;!!&#8288;</code>, and <code style="white-space: pre;">&#8288;!!!&#8288;</code> are syntactic
constructs which are specially interpreted by tidy eval functions.
You will mostly need <code style="white-space: pre;">&#8288;{{&#8288;</code>, as <code style="white-space: pre;">&#8288;!!&#8288;</code> and <code style="white-space: pre;">&#8288;!!!&#8288;</code> are more advanced
operators which you should not have to use in simple cases.
</p>
<p>The curly-curly operator <code style="white-space: pre;">&#8288;{{&#8288;</code> allows you to tunnel data-variables
passed from function arguments inside other tidy eval functions.
<code style="white-space: pre;">&#8288;{{&#8288;</code> is designed for individual arguments. To pass multiple
arguments contained in dots, use <code>...</code> in the normal way.
</p>
<div class="sourceCode"><pre>my_function &lt;- function(data, var, ...) {
  data %&gt;%
    group_by(...) %&gt;%
    summarise(mean = mean({{ var }}))
}
</pre></div>
</li>
<li> <p><code><a href="#topic+enquo">enquo()</a></code> and <code><a href="#topic+enquos">enquos()</a></code> delay the execution of one or several
function arguments. The former returns a single expression, the
latter returns a list of expressions. Once defused, expressions
will no longer evaluate on their own. They must be injected back
into an evaluation context with <code style="white-space: pre;">&#8288;!!&#8288;</code> (for a single expression) and
<code style="white-space: pre;">&#8288;!!!&#8288;</code> (for a list of expressions).
</p>
<div class="sourceCode"><pre>my_function &lt;- function(data, var, ...) {
  # Defuse
  var &lt;- enquo(var)
  dots &lt;- enquos(...)

  # Inject
  data %&gt;%
    group_by(!!!dots) %&gt;%
    summarise(mean = mean(!!var))
}
</pre></div>
<p>In this simple case, the code is equivalent to the usage of <code style="white-space: pre;">&#8288;{{&#8288;</code>
and <code>...</code> above. Defusing with <code>enquo()</code> or <code>enquos()</code> is only
needed in more complex cases, for instance if you need to inspect
or modify the expressions in some way.
</p>
</li>
<li><p> The <code>.data</code> pronoun is an object that represents the current
slice of data. If you have a variable name in a string, use the
<code>.data</code> pronoun to subset that variable with <code>[[</code>.
</p>
<div class="sourceCode"><pre>my_var &lt;- "disp"
mtcars %&gt;% summarise(mean = mean(.data[[my_var]]))
</pre></div>
</li>
<li><p> Another tidy eval operator is <code style="white-space: pre;">&#8288;:=&#8288;</code>. It makes it possible to use
glue and curly-curly syntax on the LHS of <code>=</code>. For technical
reasons, the R language doesn't support complex expressions on
the left of <code>=</code>, so we use <code style="white-space: pre;">&#8288;:=&#8288;</code> as a workaround.
</p>
<div class="sourceCode"><pre>my_function &lt;- function(data, var, suffix = "foo") {
  # Use `{{` to tunnel function arguments and the usual glue
  # operator `{` to interpolate plain strings.
  data %&gt;%
    summarise("{{ var }}_mean_{suffix}" := mean({{ var }}))
}
</pre></div>
</li>
<li><p> Many tidy eval functions like <code>dplyr::mutate()</code> or
<code>dplyr::summarise()</code> give an automatic name to unnamed inputs. If
you need to create the same sort of automatic names by yourself,
use <code>as_label()</code>. For instance, the glue-tunnelling syntax above
can be reproduced manually with:
</p>
<div class="sourceCode"><pre>my_function &lt;- function(data, var, suffix = "foo") {
  var &lt;- enquo(var)
  prefix &lt;- as_label(var)
  data %&gt;%
    summarise("{prefix}_mean_{suffix}" := mean(!!var))
}
</pre></div>
<p>Expressions defused with <code>enquo()</code> (or tunnelled with <code style="white-space: pre;">&#8288;{{&#8288;</code>) need
not be simple column names, they can be arbitrarily complex.
<code>as_label()</code> handles those cases gracefully. If your code assumes
a simple column name, use <code>as_name()</code> instead. This is safer
because it throws an error if the input is not a name as expected.
</p>
</li></ul>


<hr>
<h2 id='top_item'>return top n items with highest frequency</h2><span id='topic+top_item'></span>

<h3>Description</h3>

<p>return top n items with highest frequency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>top_item(x, n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="top_item_+3A_x">x</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="top_item_+3A_n">n</code></td>
<td>
<p>top n</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
top_item(c("a", "b", "c", "b"))

</code></pre>

<hr>
<h2 id='uniq'>only keep unique vector values and its names</h2><span id='topic+uniq'></span>

<h3>Description</h3>

<p>only keep unique vector values and its names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniq(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniq_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c(a = 1, b = 2, c = 3, b = 2, a = 1)

uniq(x)

</code></pre>

<hr>
<h2 id='uniq_in_cols'>count unique values in each column</h2><span id='topic+uniq_in_cols'></span>

<h3>Description</h3>

<p>count unique values in each column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniq_in_cols(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniq_in_cols_+3A_x">x</code></td>
<td>
<p>tibble</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
uniq_in_cols(mini_diamond)

</code></pre>

<hr>
<h2 id='write_excel'>write a tibble into an excel file</h2><span id='topic+write_excel'></span>

<h3>Description</h3>

<p>write a tibble into an excel file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_excel(df, filename, sheetname = NULL, creator = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_excel_+3A_df">df</code></td>
<td>
<p>tibble or a list of tibbles</p>
</td></tr>
<tr><td><code id="write_excel_+3A_filename">filename</code></td>
<td>
<p>the output filename</p>
</td></tr>
<tr><td><code id="write_excel_+3A_sheetname">sheetname</code></td>
<td>
<p>the names of sheets. If not given, will use 'sheet1', or
the names of list</p>
</td></tr>
<tr><td><code id="write_excel_+3A_creator">creator</code></td>
<td>
<p>creator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return status
</p>


<h3>Examples</h3>

<pre><code class='language-R'># write_excel(mini_diamond, "mini_diamond.xlsx")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
