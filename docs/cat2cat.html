<!DOCTYPE html><html><head><title>Help for package cat2cat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cat2cat}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cat_apply_freq'><p>Applying frequencies to the object returned by the 'get_mappings' function</p></a></li>
<li><a href='#cat2cat'><p>Automatic mapping in a panel dataset</p></a></li>
<li><a href='#cat2cat_agg'><p>Manual mapping for an aggregated panel dataset</p></a></li>
<li><a href='#cat2cat_ml'><p>The internal function used in the cat2cat one</p></a></li>
<li><a href='#cat2cat_ml_run'><p>Function to check cat2cat ml models performance</p></a></li>
<li><a href='#cross_c2c'><p>Make a combination of weights from different methods</p></a></li>
<li><a href='#dummy_c2c'><p>Add default cat2cat columns to a 'data.frame'</p></a></li>
<li><a href='#get_freqs'><p>Getting frequencies from a vector with an optional multiplier</p></a></li>
<li><a href='#get_mappings'><p>Transforming a mapping (transition) table to two associative lists</p></a></li>
<li><a href='#occup'><p>Occupational dataset</p></a></li>
<li><a href='#occup_small'><p>Occupational dataset - small one</p></a></li>
<li><a href='#plot_c2c'><p>Summary plots for cat2cat results</p></a></li>
<li><a href='#prune_c2c'><p>Pruning which could be useful after the mapping process</p></a></li>
<li><a href='#resolve_frequencies'><p>Resolve the frequencies</p></a></li>
<li><a href='#summary_c2c'><p>Adjusted summary for linear regression when based on replicated dataset</p></a></li>
<li><a href='#trans'><p>trans dataset containing mappings (transitions) between</p>
old (2008) and new (2010) occupational codes.
This table could be used to map encodings in both directions.</a></li>
<li><a href='#validate_cover_cats'><p>Validate if the trans table contains all proper mappings</p></a></li>
<li><a href='#verticals'><p>verticals dataset</p></a></li>
<li><a href='#verticals2'><p>verticals2 dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Handling an Inconsistently Coded Categorical Variable in a
Longitudinal Dataset</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.7</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maciej Nasinski &lt;nasinski.maciej@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Unifying an inconsistently coded categorical variable between two different time points in accordance with a mapping table. 
    The main rule is to replicate the observation if it could be assigned to a few categories. 
    Then using frequencies or statistical methods to approximate the probabilities of being assigned to each of them. 
    This procedure was invented and implemented in the paper by Nasinski, Majchrowska, and Broniatowska (2020) &lt;<a href="https://doi.org/10.24425%2Fcejeme.2020.134747">doi:10.24425/cejeme.2020.134747</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE [expanded from: GPL (&ge; 2) | file LICENSE]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Polkas/cat2cat">https://github.com/Polkas/cat2cat</a>,
<a href="https://polkas.github.io/cat2cat/">https://polkas.github.io/cat2cat/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Polkas/cat2cat/issues">https://github.com/Polkas/cat2cat/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>caret, dplyr, forcats, knitr, magrittr, randomForest,
rmarkdown, testthat (&ge; 3.0.0), tidyr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-22 21:52:58 UTC; maciejnasinski</td>
</tr>
<tr>
<td>Author:</td>
<td>Maciej Nasinski [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-22 22:42:46 UTC</td>
</tr>
</table>
<hr>
<h2 id='cat_apply_freq'>Applying frequencies to the object returned by the 'get_mappings' function</h2><span id='topic+cat_apply_freq'></span>

<h3>Description</h3>

<p>applying frequencies to the object returned by
the 'get_mappings' function.
We will get a symmetric object to the one returned by
the 'get_mappings' function, nevertheless categories are replaced
with frequencies.
Frequencies for each category/key are sum to 1, so could be interpreted
as probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_apply_freq(to_x, freqs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cat_apply_freq_+3A_to_x">to_x</code></td>
<td>
<p>'list' object returned by 'get_mappings'.</p>
</td></tr>
<tr><td><code id="cat_apply_freq_+3A_freqs">freqs</code></td>
<td>
<p>'data.frame' object like the one returned by
the 'get_freqs' function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'list' with a structure like 'to_x' object but with probabilities
for each category.
</p>


<h3>Note</h3>

<p>'freqs' arg first column (keys) and the to_x arg values have to be of
the same type.
The uniform distribution (outcomes are equally likely) is assumed
for no match for all possible categories.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("trans", package = "cat2cat")
data("occup", package = "cat2cat")

mappings &lt;- get_mappings(trans)

mappings$to_old[1:4]
mappings$to_new[1:4]

mapp_p &lt;- cat_apply_freq(
  mappings$to_old,
  get_freqs(
    occup$code[occup$year == "2008"],
    occup$multiplier[occup$year == "2008"]
  )
)
head(data.frame(I(mappings$to_old), I(mapp_p)))
mapp_p &lt;- cat_apply_freq(
  mappings$to_new,
  get_freqs(
    occup$code[occup$year == "2010"],
    occup$multiplier[occup$year == "2010"]
  )
)
head(data.frame(I(mappings$to_new), I(mapp_p)))
</code></pre>

<hr>
<h2 id='cat2cat'>Automatic mapping in a panel dataset</h2><span id='topic+cat2cat'></span>

<h3>Description</h3>

<p>The objective is to unify an inconsistently coded categorical variable
in a panel dataset according to a mapping (transition) table.
The mapping (transition) table is the core element of the process.
The function has a modular design with three arguments 'data', 'mappings', and 'ml'. Each
of these arguments is of a 'list' type, wherein the
'ml' argument is optional. Arguments are separated to
identify the core elements of the 'cat2cat' procedure.
Although this function seems
complex initially, it is built to offer a wide range of
applications for complex tasks. The function contains
many validation checks to prevent incorrect usage.
The function has to be applied iteratively for each two neighboring periods
of a panel dataset.
The <code>prune_c2c</code> function could be needed to limit growing number
of replications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat2cat(
  data = list(old = NULL, new = NULL, time_var = NULL, cat_var = NULL, cat_var_old =
    NULL, cat_var_new = NULL, id_var = NULL, multiplier_var = NULL),
  mappings = list(trans = NULL, direction = NULL, freqs_df = NULL),
  ml = list(data = NULL, cat_var = NULL, method = NULL, features = NULL, args = NULL)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cat2cat_+3A_data">data</code></td>
<td>
<p>'named list' with fields 'old', 'new',
'cat_var' (or 'cat_var_old' and 'cat_var_new'), 'time_var' and
optional 'id_var','multiplier_var'.</p>
</td></tr>
<tr><td><code id="cat2cat_+3A_mappings">mappings</code></td>
<td>
<p>'named list' with 3 fields 'trans', 'direction' and
optional 'freqs_df'.</p>
</td></tr>
<tr><td><code id="cat2cat_+3A_ml">ml</code></td>
<td>
<p>'named list' (optional) with up to 5 fields
'data', 'cat_var', 'method', 'features' and optional 'args'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>data args
</p>

<dl>
<dt>&quot;old&quot;</dt><dd><p> data.frame older time point in a panel</p>
</dd>
<dt>&quot;new&quot;</dt><dd><p> data.frame more recent time point in a panel</p>
</dd>
<dt>&quot;time_var&quot;</dt><dd><p> character(1) name of the time variable.</p>
</dd>
<dt>&quot;cat_var&quot;</dt><dd><p> character(1) name of the categorical variable.</p>
</dd>
<dt>&quot;cat_var_old&quot;</dt><dd>
<p>Optional character(1) name of the categorical variable
in the older time point. Default 'cat_var'.
</p>
</dd>
<dt>&quot;cat_var_new&quot;</dt><dd>
<p>Optional character(1) name of the categorical variable
in the newer time point. Default 'cat_var'.
</p>
</dd>
<dt>&quot;id_var&quot;</dt><dd><p>Optional character(1) name of the unique identifier variable
- if this is specified then for subjects observed in both periods,
the direct mapping is applied.
</p>
</dd>
<dt>&quot;multiplier_var&quot;</dt><dd>
<p>Optional character(1) name of the multiplier variable -
number of replication needed to reproduce the population
</p>
</dd>
<dt>&quot;freqs_df&quot;</dt><dd>
<p>Only for the backward compatibility check the definition in the description
of the mappings argument
</p>
</dd>
</dl>

<p>mappings args
</p>

<dl>
<dt>&quot;trans&quot;</dt><dd><p> data.frame with 2 columns - mapping (transition) table -
all categories for cat_var in old and new datasets have to be included.
First column contains an old encoding and second a new one.
The mapping (transition) table should to have a candidate for each category
from the targeted for an update period.
</p>
</dd>
<dt>&quot;direction&quot;</dt><dd><p> character(1) direction - &quot;backward&quot; or &quot;forward&quot;</p>
</dd>
<dt>&quot;freqs_df&quot;</dt><dd>
<p>Optional - data.frame with 2 columns where first one
is category name (base period) and second counts.
If It is not provided then is assessed automatically.
Artificial counts for each variable level in the base period.
It is optional nevertheless will be often needed, as gives more control.
It will be used to assess the probabilities.
The multiplier variable is omitted so sb has to apply it in this table.
</p>
</dd>
</dl>

<p>Optional ml args
</p>

<dl>
<dt>&quot;data&quot;</dt><dd><p> data.frame - dataset with features and the 'cat_var'.</p>
</dd>
<dt>&quot;cat_var&quot;</dt><dd><p> character(1) - the dependent variable name.</p>
</dd>
<dt>&quot;method&quot;</dt><dd>
<p>character vector - one or a few from
&quot;knn&quot;, &quot;rf&quot; and &quot;lda&quot; methods - &quot;knn&quot; k-NearestNeighbors,
&quot;lda&quot; Linear Discrimination Analysis, &quot;rf&quot; Random Forest
</p>
</dd>
<dt>&quot;features&quot;</dt><dd>
<p>character vector of features names where all
have to be numeric or logical
</p>
</dd>
<dt>&quot;args&quot;</dt><dd><p> optional - list parameters: knn: k ; rf: ntree  </p>
</dd>
</dl>

<p>Without ml section only simple frequencies are assessed.
When ml model is broken then weights from simple frequencies are taken.
'knn' method is recommended for smaller datasets.
</p>


<h3>Value</h3>

<p>'named list' with 2 fields old and new - 2 data.frames.
There will be added additional columns like
index_c2c, g_new_c2c, wei_freq_c2c, rep_c2c, wei_(ml method name)_c2c.
Additional columns will be informative only for a one data.frame
as we always make the changes to one direction.
The new columns are added instead of the additional metadata as
we are working with new datasets
where observations could be replicated.
For the transparency the probability and number of replications are part
of each observation in the 'data.frame'.
</p>


<h3>Note</h3>

<p>'trans' arg columns and the 'cat_var' column have to be of the same type.
The mapping (transition) table should to have a candidate for each category
from the targeted for an update period.
The observation from targeted for an updated period without a matched
category from base period is removed.
If you want to leave NA values add 'c(NA, NA)' row to the 'trans' table.
Please check the vignette for more information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("occup_small", package = "cat2cat")
data("occup", package = "cat2cat")
data("trans", package = "cat2cat")

occup_old &lt;- occup_small[occup_small$year == 2008, ]
occup_new &lt;- occup_small[occup_small$year == 2010, ]

# Adding the dummy level to the mapping table for levels without a candidate
# The best to fill them manually with proper candidates, if possible
# In this case it is only needed for forward mapping, to suppress warnings
trans2 &lt;- rbind(
  trans,
  data.frame(
    old = "no_cat",
    new = setdiff(c(occup_new$code), trans$new)
  )
)

# default only simple frequencies
occup_simple &lt;- cat2cat(
  data = list(
    old = occup_old, new = occup_new, cat_var = "code", time_var = "year"
  ),
  mappings = list(trans = trans2, direction = "forward")
)

mappings &lt;- list(trans = trans, direction = "backward")

ml_setup &lt;- list(
    data = occup_small[occup_small$year &gt;= 2010, ],
    cat_var = "code",
    method = "knn",
    features = c("age", "sex", "edu", "exp", "parttime", "salary"),
    args = list(k = 10)
)

# ml model performance check
print(cat2cat_ml_run(mappings, ml_setup))

# additional probabilities from knn
occup_ml &lt;- cat2cat(
  data = list(
    old = occup_old, new = occup_new, cat_var = "code", time_var = "year"
  ),
  mappings = mappings,
  ml = ml_setup
)

## End(Not run)

</code></pre>

<hr>
<h2 id='cat2cat_agg'>Manual mapping for an aggregated panel dataset</h2><span id='topic+cat2cat_agg'></span>

<h3>Description</h3>

<p>Manual mapping of an inconsistently coded categorical variable
according to the user provided mappings (equations).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat2cat_agg(
  data = list(old = NULL, new = NULL, cat_var_old = NULL, cat_var_new = NULL, time_var =
    NULL, freq_var = NULL),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cat2cat_agg_+3A_data">data</code></td>
<td>
<p>list with 5 named fields
'old', 'new', 'cat_var', 'time_var', 'freq_var'.</p>
</td></tr>
<tr><td><code id="cat2cat_agg_+3A_...">...</code></td>
<td>
<p>mapping equations where direction is set with any of,
'&gt;', '&lt;', '%&gt;%', '%&lt;%'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>data argument - list with fields
</p>

<dl>
<dt>&quot;old&quot;</dt><dd><p> data.frame older time point in the panel</p>
</dd>
<dt>&quot;new&quot;</dt><dd><p> data.frame more recent time point in the panel</p>
</dd>
<dt>&quot;cat_var&quot;</dt><dd>
<p>character - deprecated - name of the categorical variable
</p>
</dd>
<dt>&quot;cat_var_old&quot;</dt><dd>
<p>character name of the categorical variable in the old period
</p>
</dd>
<dt>&quot;cat_var_new&quot;</dt><dd>
<p>character name of the categorical variable in the new period
</p>
</dd>
<dt>&quot;time_var&quot;</dt><dd><p> character name of time variable</p>
</dd>
<dt>&quot;freq_var&quot;</dt><dd><p> character name of frequency variable</p>
</dd>
</dl>



<h3>Value</h3>

<p>'named list' with 2 fields old and new - 2 data.frames.
There will be added additional columns to each.
The new columns are added instead of the additional metadata as
we are working with new datasets
where observations could be replicated.
For the transparency the probability and number of replications are part of
each observation in the 'data.frame'.
</p>


<h3>Note</h3>

<p>All mapping equations have to be valid ones.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("verticals", package = "cat2cat")
agg_old &lt;- verticals[verticals$v_date == "2020-04-01", ]
agg_new &lt;- verticals[verticals$v_date == "2020-05-01", ]

# cat2cat_agg - can map in both directions at once
# although usually we want to have the old or the new representation

agg &lt;- cat2cat_agg(
  data = list(
    old = agg_old,
    new = agg_new,
    cat_var_old = "vertical",
    cat_var_new = "vertical",
    time_var = "v_date",
    freq_var = "counts"
  ),
  Automotive %&lt;% c(Automotive1, Automotive2),
  c(Kids1, Kids2) %&gt;% c(Kids),
  Home %&gt;% c(Home, Supermarket)
)

## possible processing
library("dplyr")
agg %&gt;%
  bind_rows() %&gt;%
  group_by(v_date, vertical) %&gt;%
  summarise(
    sales = sum(sales * prop_c2c),
    counts = sum(counts * prop_c2c),
    v_date = first(v_date)
  )
</code></pre>

<hr>
<h2 id='cat2cat_ml'>The internal function used in the cat2cat one</h2><span id='topic+cat2cat_ml'></span>

<h3>Description</h3>

<p>apply the ml models to the cat2cat data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat2cat_ml(ml, mapp, target_data, cat_var_target)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cat2cat_ml_+3A_ml">ml</code></td>
<td>
<p>'list' the same 'ml' argument as provided to 'cat2cat' function.</p>
</td></tr>
<tr><td><code id="cat2cat_ml_+3A_mapp">mapp</code></td>
<td>
<p>'list' a mapping table</p>
</td></tr>
<tr><td><code id="cat2cat_ml_+3A_target_data">target_data</code></td>
<td>
<p>'data.frame'</p>
</td></tr>
<tr><td><code id="cat2cat_ml_+3A_cat_var_target">cat_var_target</code></td>
<td>
<p>'character(1)' name of the categorical variable
in the target period.</p>
</td></tr>
</table>

<hr>
<h2 id='cat2cat_ml_run'>Function to check cat2cat ml models performance</h2><span id='topic+cat2cat_ml_run'></span><span id='topic+print.cat2cat_ml_run'></span>

<h3>Description</h3>

<p>ml and mappings arguments in <code><a href="#topic+cat2cat">cat2cat</a></code> function can be used to run cross validation across all groups in ml data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat2cat_ml_run(mappings, ml, ...)

## S3 method for class 'cat2cat_ml_run'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cat2cat_ml_run_+3A_mappings">mappings</code></td>
<td>
<p>'named list' with 3 fields 'trans', 'direction' and
optional 'freqs_df'.</p>
</td></tr>
<tr><td><code id="cat2cat_ml_run_+3A_ml">ml</code></td>
<td>
<p>'named list' (optional) with up to 5 fields
'data', 'cat_var', 'method', 'features' and optional 'args'.</p>
</td></tr>
<tr><td><code id="cat2cat_ml_run_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
<tr><td><code id="cat2cat_ml_run_+3A_x">x</code></td>
<td>
<p>cat2cat_ml_run instance created with <code><a href="#topic+cat2cat_ml_run">cat2cat_ml_run</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>argument x invisibly
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cat2cat">cat2cat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("cat2cat")
data("occup", package = "cat2cat")
data("trans", package = "cat2cat")

occup_2006 &lt;- occup[occup$year == 2006, ]
occup_2008 &lt;- occup[occup$year == 2008, ]
occup_2010 &lt;- occup[occup$year == 2010, ]
occup_2012 &lt;- occup[occup$year == 2012, ]

library("caret")
ml_setup &lt;- list(
  data = rbind(occup_2010, occup_2012),
  cat_var = "code",
  method = c("knn", "rf", "lda"),
  features = c("age", "sex", "edu", "exp", "parttime", "salary"),
  args = list(k = 10, ntree = 50)
)
data &lt;- list(
  old = occup_2008, new = occup_2010,
  cat_var_old = "code", cat_var_new = "code", time_var = "year"
)
mappings &lt;- list(trans = trans, direction = "backward")
res &lt;- cat2cat_ml_run(mappings, ml_setup, test_prop = 0.2)
res

## End(Not run)

</code></pre>

<hr>
<h2 id='cross_c2c'>Make a combination of weights from different methods</h2><span id='topic+cross_c2c'></span>

<h3>Description</h3>

<p>adding the additional column which is a mix of weights columns
by each row.
Ensemble of a few methods usually produces more accurate solutions
than a single model would.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_c2c(
  df,
  cols = colnames(df)[grepl("^wei_.*_c2c$", colnames(df))],
  weis = rep(1/length(cols), length(cols)),
  na.rm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_c2c_+3A_df">df</code></td>
<td>
<p>'data.frame' like result of the 'cat2cat' function
for a specific period.</p>
</td></tr>
<tr><td><code id="cross_c2c_+3A_cols">cols</code></td>
<td>
<p>'character' vector default all columns under
the regex &quot;wei_.*_c2c&quot;.</p>
</td></tr>
<tr><td><code id="cross_c2c_+3A_weis">weis</code></td>
<td>
<p>'numeric' vector weighs for columns in the 'cols' argument.
By default a vector of the same length as 'cols' argument and with equally
spaced probability (summing to 1).</p>
</td></tr>
<tr><td><code id="cross_c2c_+3A_na.rm">na.rm</code></td>
<td>
<p>'logical(1)' if 'NA' values should be omitted, default TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'data.frame' with the additional column 'wei_cross_c2c'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("occup_small", package = "cat2cat")
data("occup", package = "cat2cat")
data("trans", package = "cat2cat")

occup_old &lt;- occup_small[occup_small$year == 2008, ]
occup_new &lt;- occup_small[occup_small$year == 2010, ]

# mix of methods - forward direction, try out backward too
occup_mix &lt;- cat2cat(
  data = list(
    old = occup_old, new = occup_new, cat_var = "code", time_var = "year"
  ),
  mappings = list(trans = trans, direction = "backward"),
  ml = list(
    data = occup_new,
    cat_var = "code",
    method = c("knn"),
    features = c("age", "sex", "edu", "exp", "parttime", "salary"),
    args = list(k = 10, ntree = 20)
  )
)
# correlation between ml model
occup_mix_old &lt;- occup_mix$old
cor(
  occup_mix_old[occup_mix_old$rep_c2c != 1, c("wei_knn_c2c", "wei_freq_c2c")]
)
# cross all methods and subset one highest probability category for each obs
occup_old_highest1_mix &lt;- prune_c2c(cross_c2c(occup_mix$old),
  column = "wei_cross_c2c", method = "highest1"
)

## End(Not run)

</code></pre>

<hr>
<h2 id='dummy_c2c'>Add default cat2cat columns to a 'data.frame'</h2><span id='topic+dummy_c2c'></span>

<h3>Description</h3>

<p>a utils function to add default cat2cat columns
to a 'data.frame'.
It will be useful e.g. for a boarder periods which will not have additional
'cat2cat' columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummy_c2c(df, cat_var, ml = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dummy_c2c_+3A_df">df</code></td>
<td>
<p>'data.frame'.</p>
</td></tr>
<tr><td><code id="dummy_c2c_+3A_cat_var">cat_var</code></td>
<td>
<p>'character(1)' a categorical variable name.</p>
</td></tr>
<tr><td><code id="dummy_c2c_+3A_ml">ml</code></td>
<td>
<p>'character' vector of ml models applied,
any of 'c(&quot;knn&quot;, &quot;rf&quot;, &quot;lda&quot;)'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the provided 'data.frame' with additional 'cat2cat' like columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dummy_c2c(airquality, "Month")

data("occup_small", package = "cat2cat")
occup_old &lt;- occup_small[occup_small$year == 2008, ]
dummy_c2c(occup_old, "code")
dummy_c2c(occup_old, "code", "knn")

## End(Not run)
</code></pre>

<hr>
<h2 id='get_freqs'>Getting frequencies from a vector with an optional multiplier</h2><span id='topic+get_freqs'></span>

<h3>Description</h3>

<p>getting frequencies for a vector with an optional multiplier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_freqs(x, multiplier = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_freqs_+3A_x">x</code></td>
<td>
<p>'vector' categorical variable to summarize.</p>
</td></tr>
<tr><td><code id="get_freqs_+3A_multiplier">multiplier</code></td>
<td>
<p>'numeric' vector how many times to repeat certain value,
additional weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'data.frame' with two columns 'input' 'Freq'
</p>


<h3>Note</h3>

<p>without multiplier variable it is a basic 'table' function wrapped with
the 'as.data.frame' function.
The 'table' function is used with the 'useNA = &quot;ifany&quot;' argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("occup", package = "cat2cat")

head(get_freqs(occup$code[occup$year == "2008"]))
head(get_freqs(occup$code[occup$year == "2010"]))

head(
  get_freqs(
    occup$code[occup$year == "2008"],
    occup$multiplier[occup$year == "2008"]
  )
)
head(
  get_freqs(
    occup$code[occup$year == "2010"],
    occup$multiplier[occup$year == "2010"]
  )
)
</code></pre>

<hr>
<h2 id='get_mappings'>Transforming a mapping (transition) table to two associative lists</h2><span id='topic+get_mappings'></span>

<h3>Description</h3>

<p>to rearrange the one classification encoding into another,
an associative list that maps keys to values is used.
More precisely, an association list is used which is a linked list in which
each list element consists of a key and value or values.
An association list where unique categories codes are keys and matching
categories from next or previous time point are values.
A mapping (transition) table is used to build such associative lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mappings(x = data.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mappings_+3A_x">x</code></td>
<td>
<p>'data.frame' or 'matrix' - mapping (transition) table with 2 columns
where first column is assumed to be the older encoding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with 2 named lists 'to_old' and 'to_new'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("trans", package = "cat2cat")

mappings &lt;- get_mappings(trans)
mappings$to_old[1:4]
mappings$to_new[1:4]
</code></pre>

<hr>
<h2 id='occup'>Occupational dataset</h2><span id='topic+occup'></span>

<h3>Description</h3>

<p>Occupational dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occup
</code></pre>


<h3>Format</h3>

<p>A data frame with around 70000 observations and 12 variables.
</p>

<dl>
<dt>id</dt><dd><p>	integer	id</p>
</dd>
<dt>age</dt><dd><p> numeric age of a subject</p>
</dd>
<dt>sex</dt><dd><p> numeric sex of a subject</p>
</dd>
<dt>edu</dt><dd>
<p>integer edu level of education of a subject where lower means
higher - 1 for at least master degree
</p>
</dd>
<dt>exp</dt><dd><p> numeric exp number of experience years for a subject</p>
</dd>
<dt>district</dt><dd><p> integer district</p>
</dd>
<dt>parttime</dt><dd>
<p>numeric contract type regards time where 1 mean full-time
(work a whole week)
</p>
</dd>
<dt>salary</dt><dd><p> numeric salary per year</p>
</dd>
<dt>code</dt><dd><p> character code - occupational code</p>
</dd>
<dt>multiplier</dt><dd>
<p>numeric multiplier for the subject to reproduce a population - how many
of such subjects in population
</p>
</dd>
<dt>year</dt><dd><p>integer year</p>
</dd>
<dt>code4</dt><dd><p> character code - occupational code - first 4 digits</p>
</dd>
</dl>



<h3>Details</h3>

<p>occup dataset is an example of unbalance panel dataset.
This is a simulated data although there are applied a real world
characteristics from national statistical office survey.
The original survey is anonymous and take place every two years.
It is presenting a characteristics from randomly selected company and then
using k step procedure employees are chosen.
</p>
<p>occupational dataset
</p>

<hr>
<h2 id='occup_small'>Occupational dataset - small one</h2><span id='topic+occup_small'></span>

<h3>Description</h3>

<p>Occupational dataset - small one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occup_small
</code></pre>


<h3>Format</h3>

<p>A data frame with around 8000 observations and 12 variables.
</p>

<dl>
<dt>id</dt><dd><p>	integer	id</p>
</dd>
<dt>age</dt><dd><p> numeric age of a subject</p>
</dd>
<dt>sex</dt><dd><p> numeric sex of a subject</p>
</dd>
<dt>edu</dt><dd>
<p>integer edu level of education of a subject where lower means
higher - 1 for at least master degree
</p>
</dd>
<dt>exp</dt><dd><p> numeric exp number of experience years for a subject</p>
</dd>
<dt>district</dt><dd><p> integer district</p>
</dd>
<dt>parttime</dt><dd>
<p>numeric contract type regards time where 1 mean full-time
(work a whole week)
</p>
</dd>
<dt>salary</dt><dd><p> numeric salary per year</p>
</dd>
<dt>code</dt><dd><p> character code - occupational code</p>
</dd>
<dt>multiplier</dt><dd>
<p>numeric multiplier for the subject to reproduce a population -
how many of such subjects in population
</p>
</dd>
<dt>year</dt><dd><p>integer year</p>
</dd>
<dt>code4</dt><dd><p> character code - occupational code - first 4 digits</p>
</dd>
</dl>



<h3>Details</h3>

<p>occup dataset is an example of unbalance panel dataset.
This is a simulated data although there are applied a real world
characteristics from national statistical office survey.
The original survey is anonymous and take place every two years.
It is presenting a characteristics from randomly selected company and
then using k step procedure employees are chosen.
</p>
<p>occupational dataset
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
data("occup", package = "cat2cat")
occup_small &lt;- occup[sort(sample(nrow(occup), 8000)), ]
</code></pre>

<hr>
<h2 id='plot_c2c'>Summary plots for cat2cat results</h2><span id='topic+plot_c2c'></span>

<h3>Description</h3>

<p>This function help to understand properties of cat2cat results.
It is recommended to run it before further processing, like next iterations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_c2c(data, weis = "wei_freq_c2c", type = c("both", "hist", "bar"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_c2c_+3A_data">data</code></td>
<td>
<p>'data.frame' - one of the data.frames returned by
the 'cat2cat' function.</p>
</td></tr>
<tr><td><code id="plot_c2c_+3A_weis">weis</code></td>
<td>
<p>'character(1)' - name of a certain wei_*_c2c column,
added by cat2cat function. Default 'wei_freq_c2c'.</p>
</td></tr>
<tr><td><code id="plot_c2c_+3A_type">type</code></td>
<td>
<p>'character(1)' - one of 3 types '&quot;both&quot;', '&quot;hist&quot;', '&quot;bar&quot;'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>base plot graphics
</p>


<h3>Note</h3>

<p>It will work only for data.frame produced by cat2cat function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("occup_small", package = "cat2cat")
occup_old &lt;- occup_small[occup_small$year == 2008, ]
occup_new &lt;- occup_small[occup_small$year == 2010, ]

occup_2 &lt;- cat2cat(
  data = list(
    old = occup_old, new = occup_new, cat_var = "code", time_var = "year"
  ),
  mappings = list(trans = trans, direction = "backward")
)

plot_c2c(occup_2$old, type = c("both"))
plot_c2c(occup_2$old, type = c("hist"))
plot_c2c(occup_2$old, type = c("bar"))
</code></pre>

<hr>
<h2 id='prune_c2c'>Pruning which could be useful after the mapping process</h2><span id='topic+prune_c2c'></span>

<h3>Description</h3>

<p>user could specify one of four methods to prune replications
created in the cat2cat procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune_c2c(
  df,
  index = "index_c2c",
  column = "wei_freq_c2c",
  method = "nonzero",
  percent = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune_c2c_+3A_df">df</code></td>
<td>
<p>'data.frame' like result of the 'cat2cat' function
for a specific period.</p>
</td></tr>
<tr><td><code id="prune_c2c_+3A_index">index</code></td>
<td>
<p>'character(1)' a column name with the 'cat2cat' identifier.
Should not be updated in most cases. Default 'index_c2c'.</p>
</td></tr>
<tr><td><code id="prune_c2c_+3A_column">column</code></td>
<td>
<p>'character(1)' a column name with weights,
default 'wei_freq_c2c'.</p>
</td></tr>
<tr><td><code id="prune_c2c_+3A_method">method</code></td>
<td>
<p>'character(1)' one of four available methods:
&quot;nonzero&quot; (default), &quot;highest&quot;, &quot;highest1&quot; or &quot;morethan&quot;.</p>
</td></tr>
<tr><td><code id="prune_c2c_+3A_percent">percent</code></td>
<td>
<p>'integer(1)' from 0 to 99</p>
</td></tr>
</table>


<h3>Details</h3>

<p>method - specify a method to reduce number of replications
</p>

<dl>
<dt>&quot;nonzero&quot;</dt><dd><p> remove nonzero probabilities</p>
</dd>
<dt>&quot;highest&quot;</dt><dd>
<p>leave only highest probabilities for each subject- accepting ties
</p>
</dd>
<dt>&quot;highest1&quot;</dt><dd>
<p>leave only highest probabilities for each subject -
not accepting ties so always one is returned
</p>
</dd>
<dt>&quot;morethan&quot;</dt><dd>
<p>leave rows where a probability is higher than value specify
by percent argument
</p>
</dd>
</dl>



<h3>Value</h3>

<p>'data.frame' with the same structure and possibly reduced
number of rows
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("occup_small", package = "cat2cat")
data("occup", package = "cat2cat")
data("trans", package = "cat2cat")

occup_old &lt;- occup_small[occup_small$year == 2008, ]
occup_new &lt;- occup_small[occup_small$year == 2010, ]

occup_ml &lt;- cat2cat(
  data = list(
    old = occup_old, new = occup_new, cat_var = "code", time_var = "year"
  ),
  mappings = list(trans = trans, direction = "backward"),
  ml = list(
    data = occup_new,
    cat_var = "code",
    method = "knn",
    features = c("age", "sex", "edu", "exp", "parttime", "salary"),
    args = list(k = 10)
  )
)

prune_c2c(occup_ml$old, method = "nonzero")
prune_c2c(occup_ml$old, method = "highest")
prune_c2c(occup_ml$old, method = "highest1")
prune_c2c(occup_ml$old, method = "morethan", percent = 90)

prune_c2c(occup_ml$old, column = "wei_knn_c2c", method = "nonzero")

## End(Not run)

</code></pre>

<hr>
<h2 id='resolve_frequencies'>Resolve the frequencies</h2><span id='topic+resolve_frequencies'></span>

<h3>Description</h3>

<p>Resolve the frequencies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolve_frequencies(cat_base_year, cat_var_base, freqs_df, multiplier_var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resolve_frequencies_+3A_cat_base_year">cat_base_year</code></td>
<td>
<p>'data.frame' a base period dataset.</p>
</td></tr>
<tr><td><code id="resolve_frequencies_+3A_cat_var_base">cat_var_base</code></td>
<td>
<p>'character(1)' name of the base period
categorical variable.</p>
</td></tr>
<tr><td><code id="resolve_frequencies_+3A_freqs_df">freqs_df</code></td>
<td>
<p>'data.frame' with 2 columns, the first one with category
and second with counts.</p>
</td></tr>
<tr><td><code id="resolve_frequencies_+3A_multiplier_var">multiplier_var</code></td>
<td>
<p>'character(1)' name of the multiplier variable.</p>
</td></tr>
</table>

<hr>
<h2 id='summary_c2c'>Adjusted summary for linear regression when based on replicated dataset</h2><span id='topic+summary_c2c'></span>

<h3>Description</h3>

<p>adjusting lm object results according to original number of
degree of freedom.
The standard errors, t statistics and p values have to be adjusted because of
replicated observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_c2c(x, df_old, df_new = x$df.residual)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_c2c_+3A_x">x</code></td>
<td>
<p>lm object</p>
</td></tr>
<tr><td><code id="summary_c2c_+3A_df_old">df_old</code></td>
<td>
<p>integer number of d.f in original dataset. For bigger datasets
'nrow' should be sufficient.</p>
</td></tr>
<tr><td><code id="summary_c2c_+3A_df_new">df_new</code></td>
<td>
<p>integer number of d.f in dataset with replicated rows,
Default: x$df.residual</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The size of the correction is equal to sqrt(df_new / df_old).
Where standard errors are multiplied and t statistics divided by it.
In most cases the default <code>df_new</code> value should be used.
</p>


<h3>Value</h3>

<p>data.frame with additional columns over a regular summary.lm output,
like correct and statistics adjusted by it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("occup_small", package = "cat2cat")
data("trans", package = "cat2cat")

occup_old &lt;- occup_small[occup_small$year == 2008, ]
occup_new &lt;- occup_small[occup_small$year == 2010, ]

occup_2 &lt;- cat2cat(
  data = list(
    old = occup_old,
    new = occup_new,
    cat_var = "code",
    time_var = "year"
  ),
  mappings = list(trans = trans, direction = "backward"),
  ml = list(
    data = occup_new,
    cat_var = "code",
    method = "knn",
    features = c("age", "sex", "edu", "exp", "parttime", "salary"),
    args = list(k = 10)
  )
)

# Regression
# we have to adjust size of std as we artificialy enlarge degrees of freedom
lms &lt;- lm(
  formula = I(log(salary)) ~ age + sex + factor(edu) + parttime + exp,
  data = occup_2$old,
  weights = multiplier * wei_freq_c2c
)

summary_c2c(lms, df_old = nrow(occup_old))
</code></pre>

<hr>
<h2 id='trans'>trans dataset containing mappings (transitions) between
old (2008) and new (2010) occupational codes.
This table could be used to map encodings in both directions.</h2><span id='topic+trans'></span>

<h3>Description</h3>

<p>trans dataset containing mappings (transitions) between
old (2008) and new (2010) occupational codes.
This table could be used to map encodings in both directions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trans
</code></pre>


<h3>Format</h3>

<p>A data frame with 2693 observations and 2 variables.
</p>

<dl>
<dt>old</dt><dd><p>	character an old encoding of a certain occupation</p>
</dd>
<dt>new</dt><dd><p>	character a new encoding of a certain occupation</p>
</dd>
</dl>



<h3>Details</h3>

<p>mapping (transition) table for occupations where first column
contains old encodings and second one a new encoding
</p>

<hr>
<h2 id='validate_cover_cats'>Validate if the trans table contains all proper mappings</h2><span id='topic+validate_cover_cats'></span>

<h3>Description</h3>

<p>Validate if the trans table contains all proper mappings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_cover_cats(u_cats_target, mapp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_cover_cats_+3A_u_cats_target">u_cats_target</code></td>
<td>
<p>vector of unique target period categories</p>
</td></tr>
<tr><td><code id="validate_cover_cats_+3A_mapp">mapp</code></td>
<td>
<p>transition (mapping) table process with 'get_mappings',
the &quot;to_base&quot; direction is taken.</p>
</td></tr>
</table>

<hr>
<h2 id='verticals'>verticals dataset</h2><span id='topic+verticals'></span>

<h3>Description</h3>

<p>verticals dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verticals
</code></pre>


<h3>Format</h3>

<p>A data frame with 21 observations and 4 variables.
</p>

<dl>
<dt>vertical</dt><dd><p>	character an certain sales vertical</p>
</dd>
<dt>sales</dt><dd><p>	numeric a size of sale</p>
</dd>
<dt>counts</dt><dd><p>	integer counts size</p>
</dd>
<dt>v_date</dt><dd><p>	character Date</p>
</dd>
</dl>



<h3>Details</h3>

<p>random data - aggregate sales across e-commerce verticals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
agg_old &lt;- data.frame(
  vertical = c(
    "Electronics", "Kids1", "Kids2", "Automotive", "Books",
    "Clothes", "Home", "Fashion", "Health", "Sport"
  ),
  sales = rnorm(10, 100, 10),
  counts = rgeom(10, 0.0001),
  v_date = rep("2020-04-01", 10), stringsAsFactors = FALSE
)

agg_new &lt;- data.frame(
  vertical = c(
    "Electronics", "Supermarket", "Kids", "Automotive1",
    "Automotive2", "Books", "Clothes", "Home", "Fashion", "Health", "Sport"
  ),
  sales = rnorm(11, 100, 10),
  counts = rgeom(11, 0.0001),
  v_date = rep("2020-05-01", 11), stringsAsFactors = FALSE
)
verticals &lt;- rbind(agg_old, agg_new)
</code></pre>

<hr>
<h2 id='verticals2'>verticals2 dataset</h2><span id='topic+verticals2'></span>

<h3>Description</h3>

<p>verticals2 dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verticals2
</code></pre>


<h3>Format</h3>

<p>A data frame with 202 observations and 4 variables.
</p>

<dl>
<dt>ean</dt><dd><p> product ean</p>
</dd>
<dt>vertical</dt><dd><p>	character an certain sales vertical</p>
</dd>
<dt>sales</dt><dd><p>	numeric a size of sale</p>
</dd>
<dt>v_date</dt><dd><p>	character Date</p>
</dd>
</dl>



<h3>Details</h3>

<p>random data - single products sales across e-commerce verticals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
vert_old &lt;- data.frame(
  ean = 90000001:90000020,
  vertical = sample(c(
    "Electronics", "Kids1", "Kids2", "Automotive", "Books",
    "Clothes", "Home", "Fashion", "Health", "Sport"
  ), 20, replace = TRUE),
  sales = rnorm(20, 100, 10),
  v_date = rep("2020-04-01", 20), stringsAsFactors = FALSE
)

vert_old2 &lt;- data.frame(
  ean = 90000021:90000100,
  vertical = sample(c(
    "Electronics", "Kids1", "Kids2", "Automotive", "Books",
    "Clothes", "Home", "Fashion", "Health", "Sport"
  ), 80, replace = TRUE),
  sales = rnorm(80, 100, 10),
  v_date = rep("2020-04-01", 80), stringsAsFactors = FALSE
)

vert_new &lt;- vert_old2
vert_new$sales &lt;- rnorm(nrow(vert_new), 80, 10)
vert_new$v_date &lt;- "2020-05-01"
vert_new$vertical[vert_new$vertical %in% c("Kids1", "Kids2")] &lt;- "Kids"
vert_new$vertical[vert_new$vertical %in% c("Automotive")] &lt;-
  sample(
    c("Automotive1", "Automotive2"),
    sum(vert_new$vertical %in% c("Automotive")),
    replace = TRUE
  )
vert_new$vertical[vert_new$vertical %in% c("Home")] &lt;-
  sample(
    c("Home", "Supermarket"),
    sum(vert_new$vertical %in% c("Home")),
    replace = TRUE
  )

vert_new2 &lt;- data.frame(
  ean = 90000101:90000120,
  vertical = sample(
    c(
      "Electronics", "Supermarket", "Kids", "Automotive1",
      "Automotive2", "Books", "Clothes", "Home",
      "Fashion", "Health", "Sport"
    ), 20,
    replace = TRUE
  ),
  sales = rnorm(20, 100, 10),
  v_date = rep("2020-05-01", 20), stringsAsFactors = FALSE
)

verticals2 &lt;- rbind(
  rbind(vert_old, vert_old2),
  rbind(vert_new, vert_new2)
)
verticals2$vertical &lt;- as.character(verticals2$vertical)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
