<!DOCTYPE html><html lang="en"><head><title>Help for package jamba</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {jamba}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#jamba-package'><p>jamba: Jam Base Methods</p></a></li>
<li><a href='#adjustAxisLabelMargins'><p>Adjust axis label margins</p></a></li>
<li><a href='#alpha2col'><p>set R color alpha value</p></a></li>
<li><a href='#applyCLrange'><p>Apply CL color range</p></a></li>
<li><a href='#applyXlsxCategoricalFormat'><p>Add categorical colors to 'Excel' 'xlsx' worksheets</p></a></li>
<li><a href='#applyXlsxConditionalFormat'><p>Xlsx Conditional formatting</p></a></li>
<li><a href='#asDate'><p>convert date DDmmmYYYY to Date</p></a></li>
<li><a href='#asSize'><p>convert numeric value or R object to human-readable size</p></a></li>
<li><a href='#breakDensity'><p>Calculate more detailed density of numeric values</p></a></li>
<li><a href='#breaksByVector'><p>break a vector into groups</p></a></li>
<li><a href='#call_fn_ellipsis'><p>Safely call a function using ellipsis</p></a></li>
<li><a href='#cell_fun_label'><p>ComplexHeatmap cell function to label heatmap cells</p></a></li>
<li><a href='#check_pkg_installed'><p>Lightweight method to check if an R package is installed</p></a></li>
<li><a href='#checkLightMode'><p>check lightMode for light background color</p></a></li>
<li><a href='#col2alpha'><p>get R color alpha value</p></a></li>
<li><a href='#col2hcl'><p>convert R color to HCL color matrix</p></a></li>
<li><a href='#col2hsl'><p>convert R color to HSL color matrix</p></a></li>
<li><a href='#col2hsv'><p>Convert R color to HSV matrix</p></a></li>
<li><a href='#colNum2excelName'><p>convert column number to 'Excel' column name</p></a></li>
<li><a href='#color_dither'><p>Make dithered color pattern light-dark</p></a></li>
<li><a href='#color2gradient'><p>Make a color gradient</p></a></li>
<li><a href='#coordPresets'><p>Process coordinate adjustment presets</p></a></li>
<li><a href='#cPaste'><p>paste a list into a delimited vector</p></a></li>
<li><a href='#dateToDaysOld'><p>convert date to age in days</p></a></li>
<li><a href='#decideMfrow'><p>Decide plot panel rows, columns for graphics::par(mfrow)</p></a></li>
<li><a href='#deg2rad'><p>Convert degrees to radians</p></a></li>
<li><a href='#drawLabels'><p>Draw text labels on a base R plot</p></a></li>
<li><a href='#exp2signed'><p>exponentiate log2 values with directionality</p></a></li>
<li><a href='#fillBlanks'><p>Fill blank entries in a vector</p></a></li>
<li><a href='#fixYellow'><p>Fix yellow color</p></a></li>
<li><a href='#fixYellowHue'><p>Fix yellow color hue</p></a></li>
<li><a href='#formatInt'><p>Format an integer as a string</p></a></li>
<li><a href='#getAxisLabel'><p>Get axis label for minorLogTicks</p></a></li>
<li><a href='#getColorRamp'><p>get color ramp by name, color, or function</p></a></li>
<li><a href='#getDate'><p>get simple date string</p></a></li>
<li><a href='#getPlotAspect'><p>Get aspect ratio for coordinates, plot, or device</p></a></li>
<li><a href='#grepls'><p>Search for objects in the environment</p></a></li>
<li><a href='#groupedAxis'><p>Draw grouped axis labels</p></a></li>
<li><a href='#gsubOrdered'><p>Global substitution into ordered factor</p></a></li>
<li><a href='#gsubs'><p>Pattern replacement with multiple patterns</p></a></li>
<li><a href='#handleArgsText'><p>Handle function arguments as text</p></a></li>
<li><a href='#hcl2col'><p>convert HCL to R color</p></a></li>
<li><a href='#heads'><p>Apply head() across each element in a list of vectors</p></a></li>
<li><a href='#heatmap_column_order'><p>Return Heatmap column order from ComplexHeatmap heatmap object</p></a></li>
<li><a href='#heatmap_row_order'><p>Return Heatmap row order from ComplexHeatmap heatmap object</p></a></li>
<li><a href='#hsl2col'><p>convert HCL to R color</p></a></li>
<li><a href='#hsv2col'><p>Convert HSV matrix to R color</p></a></li>
<li><a href='#igrep'><p>case-insensitive grep</p></a></li>
<li><a href='#igrepHas'><p>vector contains any case-insensitive grep match</p></a></li>
<li><a href='#igrepl'><p>case-insensitive logical grepl</p></a></li>
<li><a href='#imageByColors'><p>Display color raster image using a matrix of colors</p></a></li>
<li><a href='#imageDefault'><p>Display a color raster image</p></a></li>
<li><a href='#isColor'><p>detect valid R color</p></a></li>
<li><a href='#isFALSEV'><p>Vectorized isFALSE</p></a></li>
<li><a href='#isTRUEV'><p>Vectorized isTRUE</p></a></li>
<li><a href='#jam_rapply'><p>Jam-specific recursive apply</p></a></li>
<li><a href='#jamCalcDensity'><p>Calculate scatter plot point density</p></a></li>
<li><a href='#jargs'><p>Show R function arguments jam-style</p></a></li>
<li><a href='#kable_coloring'><p>Extend kableExtra colorization of 'Rmarkdown' tables</p></a></li>
<li><a href='#list2df'><p>Convert list of vectors to data.frame with item, value, name</p></a></li>
<li><a href='#lldf'><p>Long listing of R session objects</p></a></li>
<li><a href='#log2signed'><p>log2 transformation with directionality</p></a></li>
<li><a href='#make_html_styles'><p>vectorized make_styles for html span output</p></a></li>
<li><a href='#make_styles'><p>vectorized make_styles for crayon output</p></a></li>
<li><a href='#makeColorDarker'><p>make R colors darker (or lighter)</p></a></li>
<li><a href='#makeNames'><p>make unique vector names</p></a></li>
<li><a href='#mergeAllXY'><p>Merge list of data.frames retaining all rows</p></a></li>
<li><a href='#middle'><p>Return the middle portion of data similar to head and tail</p></a></li>
<li><a href='#minorLogTicks'><p>Calculate major and minor tick marks for log-scale axis</p></a></li>
<li><a href='#minorLogTicksAxis'><p>Display major and minor tick marks for log-scale axis</p></a></li>
<li><a href='#mixedOrder'><p>order alphanumeric values keeping numeric values in proper order</p></a></li>
<li><a href='#mixedSort'><p>sort alphanumeric values keeping numeric values in proper order</p></a></li>
<li><a href='#mixedSortDF'><p>sort data.frame keeping numeric values in proper order</p></a></li>
<li><a href='#mixedSorts'><p>sort alphanumeric values within a list format</p></a></li>
<li><a href='#mmixedOrder'><p>order alphanumeric values from a list</p></a></li>
<li><a href='#nameVector'><p>assign unique names for a vector</p></a></li>
<li><a href='#nameVectorN'><p>define a named vector using vector names</p></a></li>
<li><a href='#newestFile'><p>Return the newest file from a vector of files</p></a></li>
<li><a href='#noiseFloor'><p>Apply noise floor and ceiling to numeric vector</p></a></li>
<li><a href='#normScale'><p>Scale a numeric vector from 0 to 1</p></a></li>
<li><a href='#nullPlot'><p>Create a blank plot with optional labels</p></a></li>
<li><a href='#padInteger'><p>prefix integers with leading zeros</p></a></li>
<li><a href='#padString'><p>pad a character string to a fixed length</p></a></li>
<li><a href='#pasteByRow'><p>Paste data.frame rows into character vector</p></a></li>
<li><a href='#pasteByRowOrdered'><p>Paste data.frame rows into an ordered factor</p></a></li>
<li><a href='#plotPolygonDensity'><p>Plot distribution and histogram overlay</p></a></li>
<li><a href='#plotRidges'><p>Plot ridges density plots for numeric matrix input</p></a></li>
<li><a href='#plotSmoothScatter'><p>Smooth scatter plot with enhancements</p></a></li>
<li><a href='#printDebug'><p>print colorized output to R console</p></a></li>
<li><a href='#provigrep'><p>provigrep: progressive case-insensitive value-grep</p></a></li>
<li><a href='#rad2deg'><p>Convert radians to degrees</p></a></li>
<li><a href='#rainbow2'><p>Simple rainbow palette replacement</p></a></li>
<li><a href='#rbindList'><p>rbind a list of vectors into matrix or data.frame</p></a></li>
<li><a href='#readOpenxlsx'><p>Import one or more data.frame from 'Excel' 'xlsx' format</p></a></li>
<li><a href='#relist_named'><p>relist a vector which allows re-ordered names</p></a></li>
<li><a href='#reload_rmarkdown_cache'><p>Reload 'Rmarkdown' cache</p></a></li>
<li><a href='#renameColumn'><p>Rename columns in a data.frame, matrix, tibble, or GRanges object</p></a></li>
<li><a href='#rgb2col'><p>Convert RGB color matrix to R color</p></a></li>
<li><a href='#rlengths'><p>lengths for recursive lists</p></a></li>
<li><a href='#rmInfinite'><p>remove Infinite values</p></a></li>
<li><a href='#rmNA'><p>remove NA values</p></a></li>
<li><a href='#rmNAs'><p>remove NA values from list elements</p></a></li>
<li><a href='#rmNULL'><p>remove NULL entries from list</p></a></li>
<li><a href='#rowGroupMeans'><p>Calculate row group means, or other statistics</p></a></li>
<li><a href='#rowRmMadOutliers'><p>Remove outlier points per row by MAD factor threshold</p></a></li>
<li><a href='#sclass'><p>return the classes of a list of objects</p></a></li>
<li><a href='#sdim'><p>print dimensions of list object elements</p></a></li>
<li><a href='#set_xlsx_colwidths'><p>Set column widths in Xlsx files</p></a></li>
<li><a href='#set_xlsx_rowheights'><p>Set row heights in Xlsx files</p></a></li>
<li><a href='#setCLranges'><p>Get Chroma and Luminance ranges for the given lightMode</p></a></li>
<li><a href='#setPrompt'><p>set R prompt with project name and R version</p></a></li>
<li><a href='#setTextContrastColor'><p>Define visible text color</p></a></li>
<li><a href='#shadowText'><p>Draw text with shadow border</p></a></li>
<li><a href='#shadowText_options'><p>Get and set options for shadowText</p></a></li>
<li><a href='#showColors'><p>Show colors from a vector or list</p></a></li>
<li><a href='#sizeAsNum'><p>convert size to numeric value</p></a></li>
<li><a href='#smoothScatterJam'><p>Smooth scatter plot, Jam style</p></a></li>
<li><a href='#sqrtAxis'><p>Determine square root axis tick mark positions</p></a></li>
<li><a href='#tcount'><p>frequency of entries, ordered by frequency</p></a></li>
<li><a href='#ucfirst'><p>Uppercase the first letter in each word</p></a></li>
<li><a href='#unalpha'><p>Remove alpha transparency from colors</p></a></li>
<li><a href='#unigrep'><p>case-insensitive grep, returning unmatched indices</p></a></li>
<li><a href='#uniques'><p>apply unique to each element of a list</p></a></li>
<li><a href='#unnestList'><p>Un-nest a nested list into a simple list</p></a></li>
<li><a href='#unvigrep'><p>case-insensitive grep, returning unmatched values</p></a></li>
<li><a href='#usrBox'><p>Draw colored box indicating R plot space</p></a></li>
<li><a href='#vgrep'><p>grep, returning values</p></a></li>
<li><a href='#vigrep'><p>case-insensitive grep, returning values</p></a></li>
<li><a href='#warpAroundZero'><p>Warp a vector of numeric values relative to zero</p></a></li>
<li><a href='#warpRamp'><p>Warp colors in a color ramp</p></a></li>
<li><a href='#writeOpenxlsx'><p>Export a data.frame to 'Excel' 'xlsx' format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Just Analysis Methods Base</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Just analysis methods ('jam') base functions
    focused on bioinformatics.
    Version- and gene-centric alphanumeric sort,
    unique name and version assignment, colorized console and 'HTML' output,
    color ramp and palette manipulation,
    'Rmarkdown' cache import, styled 'Excel' worksheet import and export,
    interpolated raster output from smooth scatter and image plots,
    list to delimited vector, efficient list tools.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, grDevices, graphics, stats, utils, colorspace,
RColorBrewer, KernSmooth, withr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>crayon, farver, knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Enhances:</td>
<td>ggplot2, ggridges, IRanges, S4Vectors, openxlsx, kableExtra,
matrixStats, viridisLite, ComplexHeatmap, circlize,
GenomicRanges, igraph, pryr, rstudioapi, Matrix,
sparseMatrixStats</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jmw86069.github.io/jamba/">https://jmw86069.github.io/jamba/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jmw86069/jamba/issues">https://github.com/jmw86069/jamba/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-07 17:13:53 UTC; wardjm</td>
</tr>
<tr>
<td>Author:</td>
<td>James M. Ward <a href="https://orcid.org/0000-0002-9510-2848"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James M. Ward &lt;jmw86069@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-10 14:50:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='jamba-package'>jamba: Jam Base Methods</h2><span id='topic+jamba'></span><span id='topic+jamba-package'></span>

<h3>Description</h3>

<p>The jamba package contains several jam base functions
which are re-usable for routine R analysis work, and are
important dependencies for other Jam R packages.
</p>


<h3>Details</h3>

<p>See the function reference for a complete list of functions.
</p>
<p>The goal is to implement methods as lightweight as possible, so
so inclusion in an analysis workflow will not incur
a noticeable burden.
</p>


<h3>plot functions</h3>


<ul>
<li> <p><code><a href="#topic+plotSmoothScatter">plotSmoothScatter()</a></code> smoothScatter() enhanced for more visual detail
</p>
</li>
<li> <p><code><a href="#topic+imageDefault">imageDefault()</a></code> enhanced rasterized image() with fixed aspect ratio
</p>
</li>
<li> <p><code><a href="#topic+imageByColors">imageByColors()</a></code> for <code>data.frame</code> of colors and optional
labels centered across repeated values.
</p>
</li>
<li> <p><code><a href="#topic+showColors">showColors()</a></code> color display for vector, list, color function,
or mixed formats.
</p>
</li>
<li> <p><code><a href="#topic+nullPlot">nullPlot()</a></code> blank plot that labels the current margin sizes
</p>
</li>
<li> <p><code><a href="#topic+minorLogTicksAxis">minorLogTicksAxis()</a></code> log-scale axis ticks in base R with
custom log base, optional offset, e.g. <code>log2(1 + x)</code>
</p>
</li>
<li> <p><code><a href="#topic+shadowText">shadowText()</a></code> base R text labels with shadow or outline or both,
also <code><a href="#topic+shadowText_options">shadowText_options()</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+getPlotAspect">getPlotAspect()</a></code>, <code><a href="#topic+decideMfrow">decideMfrow()</a></code> convenience base R graphics.
</p>
</li></ul>



<h3>string functions</h3>


<ul>
<li> <p><code><a href="#topic+mixedSort">mixedSort()</a></code>, <code><a href="#topic+mixedOrder">mixedOrder()</a></code>, <code><a href="#topic+mixedSortDF">mixedSortDF()</a></code> - efficient
alphanumeric &quot;version&quot; sort, with options helpful for gene symbols.
</p>
</li>
<li> <p><code><a href="#topic+vgrep">vgrep()</a></code>, <code><a href="#topic+vigrep">vigrep()</a></code>, <code><a href="#topic+igrep">igrep()</a></code>, <code><a href="#topic+vigrep">vigrep()</a></code> fast grep wrappers
for value-return, case-insensitive search.
</p>
</li>
<li> <p><code><a href="#topic+provigrep">provigrep()</a></code>, <code><a href="#topic+proigrep">proigrep()</a></code> - progressive, ordered grep to use
pattern matching to re-order a vector.
</p>
</li>
<li> <p><code><a href="#topic+makeNames">makeNames()</a></code> create unique, versioned names with custom format
</p>
</li>
<li> <p><code><a href="#topic+nameVector">nameVector()</a></code> apply names to vector dynamically
</p>
</li>
<li> <p><code><a href="#topic+nameVectorN">nameVectorN()</a></code> vector of named names useful with <code><a href="base.html#topic+lapply">lapply()</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+pasteByRow">pasteByRow()</a></code>, <code><a href="#topic+pasteByRowOrdered">pasteByRowOrdered()</a></code> paste data.frame and matrix
values by row, skipping blanks, optional factor order.
</p>
</li>
<li> <p><code><a href="#topic+rbindList">rbindList()</a></code> convert list to <code>matrix</code> or <code>data.frame</code>.
</p>
</li>
<li> <p><code><a href="#topic+tcount">tcount()</a></code> extends <code>table()</code> to sort by size and optional minimum
count filter.
</p>
</li></ul>



<h3>color functions</h3>


<ul>
<li> <p><code><a href="#topic+rgb2col">rgb2col()</a></code>, <code><a href="#topic+col2hcl">col2hcl()</a></code>, <code><a href="#topic+col2hcl">col2hcl()</a></code>, <code><a href="#topic+col2hsv">col2hsv()</a></code>, <code><a href="#topic+hsv2col">hsv2col()</a></code> color
interconversion
</p>
</li>
<li> <p><code><a href="#topic+setTextContrastColor">setTextContrastColor()</a></code> text contrast color per given background color
</p>
</li>
<li> <p><code><a href="#topic+getColorRamp">getColorRamp()</a></code> catch-all to get named gradients, or expand
one or more colors to gradient.
</p>
</li>
<li> <p><code><a href="#topic+makeColorDarker">makeColorDarker()</a></code>, <code><a href="#topic+color2gradient">color2gradient()</a></code>, <code><a href="#topic+showColors">showColors()</a></code> color
manipulation and display
</p>
</li></ul>



<h3>miscellaneous helper functions</h3>


<ul>
<li> <p><code><a href="#topic+printDebug">printDebug()</a></code> colored text output to console, 'Rmarkdown', HTML
</p>
</li>
<li> <p><code><a href="#topic+kable_coloring">kable_coloring()</a></code> colored <code>kableExtra::kable()</code> output for 'Rmarkdown'
</p>
</li>
<li> <p><code><a href="#topic+setPrompt">setPrompt()</a></code> colored R prompt
</p>
</li>
<li> <p><code><a href="#topic+deg2rad">deg2rad()</a></code>, <code><a href="#topic+rad2deg">rad2deg()</a></code> interconvert degrees to radians.
</p>
</li>
<li> <p><code><a href="#topic+getDate">getDate()</a></code>, <code><a href="#topic+asDate">asDate()</a></code>, <code><a href="#topic+dateToDaysOld">dateToDaysOld()</a></code> human-readable,
opinionated date formatting
</p>
</li>
<li> <p><code><a href="#topic+padString">padString()</a></code>, <code><a href="#topic+padInteger">padInteger()</a></code> pad character or integer strings
</p>
</li>
<li> <p><code><a href="#topic+rmNA">rmNA()</a></code>, <code><a href="#topic+rmNULL">rmNULL()</a></code>, <code><a href="#topic+rmInfinite">rmInfinite()</a></code> remove or replace missing or NA
values with defined alternatives
</p>
</li></ul>



<h3>export and import functions</h3>


<ul>
<li> <p><code><a href="#topic+readOpenxlsx">readOpenxlsx()</a></code> import worksheets from 'xlsx' 'Excel' files.
</p>
</li>
<li> <p><code><a href="#topic+writeOpenxlsx">writeOpenxlsx()</a></code> export worksheets to 'xlsx' 'Excel' files with color,
formatting, and styling.
</p>
</li></ul>



<h3>Jam options</h3>

<p>The <code>jamba</code> package recognizes some global options, but limits these
options to include only non-analysis options. For example, no global
option should change the numerical manipulation of data.
</p>

<ul>
<li> <p><code>jam.lightMode</code> - <code>logical</code> whether the R console or graphical
background is light or dark, <code>printDebug()</code> limits
the luminance range to maximize visual contrast.
</p>
</li>
<li> <p><code>jam.Crange</code>,<code>jam.Lrange</code> - numerical values used by <code>printDebug()</code>
to maximize visual contrast, used with <code>jam.lightMode</code>.
</p>
</li>
<li> <p><code>jam.shadowColor</code>,<code>jam.shadow.r</code>,<code>jam.shadow.n</code>,<code>jam.alphaShadow</code>,
<code>jam.outline</code>,<code>jam.alphaOutline</code> to customize details for <code>shadowText()</code>,
see <code>shadowText_options()</code> for convenience.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: James M. Ward <a href="mailto:jmw86069@gmail.com">jmw86069@gmail.com</a> (<a href="https://orcid.org/0000-0002-9510-2848">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://jmw86069.github.io/jamba/">https://jmw86069.github.io/jamba/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/jmw86069/jamba/issues">https://github.com/jmw86069/jamba/issues</a>
</p>
</li></ul>


<hr>
<h2 id='adjustAxisLabelMargins'>Adjust axis label margins</h2><span id='topic+adjustAxisLabelMargins'></span>

<h3>Description</h3>

<p>Adjust axis label margins to accommodate axis labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjustAxisLabelMargins(
  x,
  margin = 1,
  maxFig = 1/2,
  cex = graphics::par("cex"),
  cex.axis = graphics::par("cex.axis"),
  prefix = "-- -- ",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjustAxisLabelMargins_+3A_x">x</code></td>
<td>
<p><code>character</code> vector of axis labels</p>
</td></tr>
<tr><td><code id="adjustAxisLabelMargins_+3A_margin">margin</code></td>
<td>
<p><code>integer</code> value indicating which margin to adjust,
using the order by <code>graphics::par("mar")</code>, 1=bottom, 2=left, 3=top,
4=right.</p>
</td></tr>
<tr><td><code id="adjustAxisLabelMargins_+3A_maxfig">maxFig</code></td>
<td>
<p><code>numeric</code> fraction less than 1, indicating the maximum
size of margin relative to the figure size. Setting margins too
large results in an error otherwise.</p>
</td></tr>
<tr><td><code id="adjustAxisLabelMargins_+3A_cex">cex</code></td>
<td>
<p><code>numeric</code> or NULL, default <code>graphics::par("cex")</code>,
used as a convenience with <code>cex * cex.axis</code> passed to
<code>graphics::strwidth()</code>.
However, <code>graphics::axis()</code> itself should use <code>cex.axis</code> when
adjusting axis label font size.</p>
</td></tr>
<tr><td><code id="adjustAxisLabelMargins_+3A_cex.axis">cex.axis</code></td>
<td>
<p><code>numeric</code>, default <code>graphics::par("cex.axis")</code> to define
the axis label font size.</p>
</td></tr>
<tr><td><code id="adjustAxisLabelMargins_+3A_prefix">prefix</code></td>
<td>
<p><code>character</code> string to add whitespace around the axis label
in order to add a &quot;buffer&quot; of whitespace.</p>
</td></tr>
<tr><td><code id="adjustAxisLabelMargins_+3A_...">...</code></td>
<td>
<p>additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a vector of axis labels, and the margin where they
will be used, and adjusts the relevant axis margin to accomodate the
label size, up to a maximum fraction of the figure size as defined by
<code>maxFig</code>.
</p>
<p>Labels are assumed to be perpendicular to the axis, for example
argument <code>las=2</code> when using <code>graphics::text()</code>.
</p>
<p>Note this function does not render labels in the figure, and therefore
does not revert axis margins to their original size. That process
should be performed separately.
</p>


<h3>Value</h3>

<p><code>list</code> named &quot;mai&quot; suitable for use in <code>graphics::par()</code>
to adjust margin size using in inches.
</p>


<h3>See Also</h3>

<p>Other jam plot functions: 
<code><a href="#topic+coordPresets">coordPresets</a>()</code>,
<code><a href="#topic+decideMfrow">decideMfrow</a>()</code>,
<code><a href="#topic+drawLabels">drawLabels</a>()</code>,
<code><a href="#topic+getPlotAspect">getPlotAspect</a>()</code>,
<code><a href="#topic+groupedAxis">groupedAxis</a>()</code>,
<code><a href="#topic+imageByColors">imageByColors</a>()</code>,
<code><a href="#topic+imageDefault">imageDefault</a>()</code>,
<code><a href="#topic+minorLogTicksAxis">minorLogTicksAxis</a>()</code>,
<code><a href="#topic+nullPlot">nullPlot</a>()</code>,
<code><a href="#topic+plotPolygonDensity">plotPolygonDensity</a>()</code>,
<code><a href="#topic+plotRidges">plotRidges</a>()</code>,
<code><a href="#topic+plotSmoothScatter">plotSmoothScatter</a>()</code>,
<code><a href="#topic+shadowText">shadowText</a>()</code>,
<code><a href="#topic+shadowText_options">shadowText_options</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+sqrtAxis">sqrtAxis</a>()</code>,
<code><a href="#topic+usrBox">usrBox</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xlabs &lt;- paste0("item_", (1:20));
ylabs &lt;- paste0("rownum_", (1:20));

# proper adjustment should be done using withr, for example
x_cex &lt;- 0.8;
y_cex &lt;- 1.2;
withr::with_par(adjustAxisLabelMargins(xlabs, 1, cex.axis=x_cex), {
   withr::local_par(adjustAxisLabelMargins(ylabs, 2, cex.axis=y_cex))
   nullPlot(xlim=c(1,20), ylim=c(1,20), doMargins=FALSE);
   graphics::axis(1, at=1:20, labels=xlabs, las=2, cex.axis=x_cex);
   graphics::axis(2, at=1:20, labels=ylabs, las=2, cex.axis=y_cex);
})

withr::with_par(adjustAxisLabelMargins(xlabs, 3, cex.axis=x_cex), {
   withr::local_par(adjustAxisLabelMargins(ylabs, 4, cex.axis=y_cex))
   nullPlot(xlim=c(1,20), ylim=c(1,20), doMargins=FALSE);
   graphics::axis(3, at=1:20, labels=xlabs, las=2);
   graphics::axis(4, at=1:20, labels=ylabs, las=2);
})

par("mar")
</code></pre>

<hr>
<h2 id='alpha2col'>set R color alpha value</h2><span id='topic+alpha2col'></span>

<h3>Description</h3>

<p>Define the alpha transparency per R color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha2col(x, alpha = 1, maxValue = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alpha2col_+3A_x">x</code></td>
<td>
<p>R compatible color, either a color name, or hex value, or
a mixture of the two. Any value compatible with <code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code>.</p>
</td></tr>
<tr><td><code id="alpha2col_+3A_alpha">alpha</code></td>
<td>
<p>numeric alpha transparency to use per x color. alpha is
recycled to length(x) as needed.</p>
</td></tr>
<tr><td><code id="alpha2col_+3A_maxvalue">maxValue</code></td>
<td>
<p>numeric maximum value to return, useful when the downstream
alpha range should be 255. By default maxValue=1 is returned.</p>
</td></tr>
<tr><td><code id="alpha2col_+3A_...">...</code></td>
<td>
<p>Additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character</code> vector of R colors, with alpha values.
</p>


<h3>See Also</h3>

<p>Other jam color functions: 
<code><a href="#topic+applyCLrange">applyCLrange</a>()</code>,
<code><a href="#topic+col2alpha">col2alpha</a>()</code>,
<code><a href="#topic+col2hcl">col2hcl</a>()</code>,
<code><a href="#topic+col2hsl">col2hsl</a>()</code>,
<code><a href="#topic+col2hsv">col2hsv</a>()</code>,
<code><a href="#topic+color2gradient">color2gradient</a>()</code>,
<code><a href="#topic+fixYellow">fixYellow</a>()</code>,
<code><a href="#topic+fixYellowHue">fixYellowHue</a>()</code>,
<code><a href="#topic+getColorRamp">getColorRamp</a>()</code>,
<code><a href="#topic+hcl2col">hcl2col</a>()</code>,
<code><a href="#topic+hsl2col">hsl2col</a>()</code>,
<code><a href="#topic+hsv2col">hsv2col</a>()</code>,
<code><a href="#topic+isColor">isColor</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+makeColorDarker">makeColorDarker</a>()</code>,
<code><a href="#topic+rainbow2">rainbow2</a>()</code>,
<code><a href="#topic+rgb2col">rgb2col</a>()</code>,
<code><a href="#topic+setCLranges">setCLranges</a>()</code>,
<code><a href="#topic+setTextContrastColor">setTextContrastColor</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+unalpha">unalpha</a>()</code>,
<code><a href="#topic+warpRamp">warpRamp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>withr::with_par(list("mfrow"=c(2,2)), {
for (alpha in c(1, 0.8, 0.5, 0.2)) {
   nullPlot(plotAreaTitle=paste0("alpha=", alpha),
      doMargins=FALSE);
   usrBox(fill=alpha2col("yellow",
      alpha=alpha));
}
})

</code></pre>

<hr>
<h2 id='applyCLrange'>Apply CL color range</h2><span id='topic+applyCLrange'></span>

<h3>Description</h3>

<p>Restrict chroma (C) and luminance (L) ranges for a vector of R colors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>applyCLrange(
  x,
  lightMode = NULL,
  Crange = getOption("jam.Crange"),
  Lrange = getOption("jam.Lrange"),
  Cgrey = getOption("jam.Cgrey", 5),
  fixYellow = TRUE,
  CLmethod = c("scale", "floor", "expand"),
  fixup = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="applyCLrange_+3A_x">x</code></td>
<td>
<p>vector of R colors</p>
</td></tr>
<tr><td><code id="applyCLrange_+3A_lightmode">lightMode</code></td>
<td>
<p><code>NULL</code> or <code>logical</code>. When <code>lightMode=NULL</code> then
<code>Crange</code> and <code>Lrange</code> values are used as-is; when <code>lightMode=TRUE</code>
or <code>lightMode=FALSE</code> then default values are used for <code>Crange</code> and
<code>Lrange</code> values, where <code>lightMode=TRUE</code> is intended for colors
to have contrast against a light/bright/white background,
and <code>lightMode=FALSE</code> is intended for colors to have contrast
against a dark background.</p>
</td></tr>
<tr><td><code id="applyCLrange_+3A_crange">Crange</code></td>
<td>
<p><code>NULL</code> or <code>numeric</code> range with minimum and maximum allowed
values for the chroma (C) component.</p>
</td></tr>
<tr><td><code id="applyCLrange_+3A_lrange">Lrange</code></td>
<td>
<p><code>NUL</code>L or <code>numeric</code> range with minimum and maximum allowed
values for the luminance (L) component.</p>
</td></tr>
<tr><td><code id="applyCLrange_+3A_cgrey">Cgrey</code></td>
<td>
<p><code>numeric</code> chroma (C) value, which defines grey colors at or
below this chroma. Any colors at or below the grey cutoff will have
their C values unchanged. This mechanism prevents converting black
to red, for example. To disable the effect, set <code>Cgrey=-1</code>.</p>
</td></tr>
<tr><td><code id="applyCLrange_+3A_fixyellow">fixYellow</code></td>
<td>
<p><code>logical</code> indicating whether to &quot;fix&quot; the darkening of
yellow, which otherwise turns to green. Instead, since JAM can,
JAM will make the yellow slightly more golden before darkening,
which is achieved by calling <code>fixYellowHue()</code>.</p>
</td></tr>
<tr><td><code id="applyCLrange_+3A_clmethod">CLmethod</code></td>
<td>
<p><code>character</code> string indicating how to alter values
outside the respective <code>Crange</code> and <code>Lrange</code> ranges. &quot;scale&quot; will
rescale values only if any are outside of range, and will rescale
the full range of <code>c(Crange, Cvalues)</code> to <code>c(Crange)</code>. In this way,
only values outside the range are rescaled. &quot;floor&quot; will apply a
fixed cutoff, any values outside the range are set to equal the
range boundary itself. &quot;expand&quot; will rescale all values so the
range is equal to <code>Crange</code>.</p>
</td></tr>
<tr><td><code id="applyCLrange_+3A_fixup">fixup</code></td>
<td>
<p><code>logical</code> passed to <code>hcl2col()</code> and subsequently
to <code>colorspace::hex()</code> when converting colors outside the color
gamut (visible range.) When <code>fixup</code> is <code>NULL</code>, the <code>hcl2col()</code>
method applies its own aggressive technique to restrict the color
range.</p>
</td></tr>
<tr><td><code id="applyCLrange_+3A_...">...</code></td>
<td>
<p>additional argyments are passed to <code>fixYellowHue()</code> when
<code>fixYellow</code> is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is primarily intended to restrict the range of brightness
values so they contrast with a background color, particularly when the
background color may be bright or dark.
</p>
<p>Note that output is slightly different when supplying one color,
compared to supplying a vector of colors. One color is simply
restricted to the <code>Crange</code> and <code>Lrange</code>. However, a vector of colors
is scaled within the ranges so that relative <code>C</code> and <code>L</code> values
are maintained, for visual comparison.
</p>
<p>The C and L values are defined by <code>colorspace::polarLUV()</code>, where C is
typically restricted to <code style="white-space: pre;">&#8288;0..100&#8288;</code> and L is typically <code style="white-space: pre;">&#8288;0..100&#8288;</code>. For some
colors, values above 100 are allowed.
</p>
<p>Values are restricted to the given numeric range using one of three
methods, set via the <code>CLmethod</code> argument.
</p>
<p>As an example, consider what should be done when <code>Crange &lt;- c(10,70)</code>
and the C values are <code>Cvalues &lt;- c(50, 60, 70, 80)</code>.
</p>

<ol>
<li><p> &quot;floor&quot; uses <code>jamba::noiseFloor()</code> to apply fixed cutoffs at the
minimum and maximum range. This method has the effect of making all
values outside the range into an equal final value.
</p>
</li>
<li><p> &quot;scale&quot; will apply <code>jamba::normScale()</code> to rescale only values outside
the given range. For example, <code>c(Crange, Cvalues)</code> as the initial range,
it constrains values to <code>c(Crange)</code>.  This method has the effect of
maintaining the relative difference between values.
</p>
</li>
<li><p> &quot;expand&quot; will simply apply <code>jamba::normScale()</code> to fit the values
to the minimum and maximum range values. This method has the effect of
forcing colors to fit the full numeric range, even when the original
differences between values were small.
</p>
</li></ol>

<p>In case (1) above, Cvalues will become <code>c(50, 60, 70, 70)</code>.
In case (2) above, Cvalues will become <code>c(44, 53, 61, 70)</code>
In case (3) above, Cvalues will become <code>c(10, 30, 50, 70)</code>
</p>
<p>Note that colors with C (chroma) values less than <code>Cgrey</code> will not have
the C value changed, in order to maintain colors at a greyscale, without
colorizing them. Particularly for pure <code>grey</code>, which has <code>C=0</code>, but
is still required to have a hue H, it is important not to increase
<code>C</code>.
</p>


<h3>Value</h3>

<p>vector of colors after applying the chroma (C) and luminance (L)
ranges.
</p>


<h3>See Also</h3>

<p>Other jam color functions: 
<code><a href="#topic+alpha2col">alpha2col</a>()</code>,
<code><a href="#topic+col2alpha">col2alpha</a>()</code>,
<code><a href="#topic+col2hcl">col2hcl</a>()</code>,
<code><a href="#topic+col2hsl">col2hsl</a>()</code>,
<code><a href="#topic+col2hsv">col2hsv</a>()</code>,
<code><a href="#topic+color2gradient">color2gradient</a>()</code>,
<code><a href="#topic+fixYellow">fixYellow</a>()</code>,
<code><a href="#topic+fixYellowHue">fixYellowHue</a>()</code>,
<code><a href="#topic+getColorRamp">getColorRamp</a>()</code>,
<code><a href="#topic+hcl2col">hcl2col</a>()</code>,
<code><a href="#topic+hsl2col">hsl2col</a>()</code>,
<code><a href="#topic+hsv2col">hsv2col</a>()</code>,
<code><a href="#topic+isColor">isColor</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+makeColorDarker">makeColorDarker</a>()</code>,
<code><a href="#topic+rainbow2">rainbow2</a>()</code>,
<code><a href="#topic+rgb2col">rgb2col</a>()</code>,
<code><a href="#topic+setCLranges">setCLranges</a>()</code>,
<code><a href="#topic+setTextContrastColor">setTextContrastColor</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+unalpha">unalpha</a>()</code>,
<code><a href="#topic+warpRamp">warpRamp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cl &lt;- c("red", "blue", "navy", "yellow", "orange");
cl_lite &lt;- applyCLrange(cl, lightMode=TRUE);
cl_dark &lt;- applyCLrange(cl, lightMode=FALSE);

# individual colors
cl_lite_ind &lt;- sapply(cl, applyCLrange, lightMode=TRUE);
cl_dark_ind &lt;- sapply(cl, applyCLrange, lightMode=FALSE);

# display colors
showColors(list(`input colors`=cl,
   `lightMode=TRUE, vector`=cl_lite,
   `lightMode=TRUE, individual`=cl_lite_ind,
   `lightMode=FALSE, vector`=cl_dark,
   `lightMode=FALSE, individual`=cl_dark_ind))
printDebug(cl, lightMode=TRUE);

</code></pre>

<hr>
<h2 id='applyXlsxCategoricalFormat'>Add categorical colors to 'Excel' 'xlsx' worksheets</h2><span id='topic+applyXlsxCategoricalFormat'></span>

<h3>Description</h3>

<p>Add categorical colors to 'Excel' 'xlsx' worksheets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>applyXlsxCategoricalFormat(
  xlsxFile,
  sheet = 1,
  rowRange = NULL,
  colRange = NULL,
  colorSub = NULL,
  colorSubText = setTextContrastColor(colorSub),
  trimCatNames = TRUE,
  overwrite = TRUE,
  wrapText = FALSE,
  stack = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="applyXlsxCategoricalFormat_+3A_xlsxfile">xlsxFile</code></td>
<td>
<p><code>character</code> filename to a file with &quot;.xlsx&quot; extension,
or <code>Workbook</code> object defined in the <code>openxlsx</code> package. When
<code>xlsxFile</code> is a <code>Workbook</code> the output is not saved to a file.</p>
</td></tr>
<tr><td><code id="applyXlsxCategoricalFormat_+3A_sheet">sheet</code></td>
<td>
<p><code>integer</code> index of the worksheet or worksheets.</p>
</td></tr>
<tr><td><code id="applyXlsxCategoricalFormat_+3A_rowrange">rowRange</code>, <code id="applyXlsxCategoricalFormat_+3A_colrange">colRange</code></td>
<td>
<p><code>integer</code> vectors of rows and columns
to apply categorical colors in the 'Excel' 'xlsx' worksheet,
passed as <code>openxlsx::readWorkbook(..., rows=rowRange, cols=colRange)</code>.
This step defines which columns are read from each workbook,
however when <code>colorSub</code> is provided as a <code>list</code> whose names
are intended to match <code>colnames()</code>, only matching colnames
are processed.</p>
</td></tr>
<tr><td><code id="applyXlsxCategoricalFormat_+3A_colorsub">colorSub</code></td>
<td>
<p>one of the following types of input:
</p>

<ul>
<li><p> Named <code>character</code> vector of valid R colors, whose
names correspond to values in worksheet cells.
</p>
</li>
<li><p> Named <code>list</code> whose names correspond to colnames one or more
workbooks in <code>sheet</code>. Each list element should be a <code>character</code>
vector named by column values, or color <code>function</code> that takes
column values and returns a <code>character</code> vector of colors for
each value.
</p>
</li></ul>
</td></tr>
<tr><td><code id="applyXlsxCategoricalFormat_+3A_colorsubtext">colorSubText</code></td>
<td>
<p>optional <code>character</code> vector of colors, whose
names correspond to values in the worksheet cells. In
absence of a specific text color, <code>setTextContrastColor()</code>
is used to define a contrasting text color to be visible on
the colored background.</p>
</td></tr>
<tr><td><code id="applyXlsxCategoricalFormat_+3A_trimcatnames">trimCatNames</code></td>
<td>
<p><code>logical</code> whether to trim whitespace and punctuation
from <code>colorSub</code> and from 'Excel' cell fields before matching colors
to 'Excel' values.</p>
</td></tr>
<tr><td><code id="applyXlsxCategoricalFormat_+3A_overwrite">overwrite</code></td>
<td>
<p><code>logical</code> indicating whether new cell color styles
should be forced overwrite of previous cell styles.</p>
</td></tr>
<tr><td><code id="applyXlsxCategoricalFormat_+3A_wraptext">wrapText</code></td>
<td>
<p><code>logical</code> indicating whether to wrap text.</p>
</td></tr>
<tr><td><code id="applyXlsxCategoricalFormat_+3A_stack">stack</code></td>
<td>
<p><code>logical</code> indicating whether new color rules should be
applied above existing styles, many of whose styles may not affect
the specific cell color, for example the font size and font name.</p>
</td></tr>
<tr><td><code id="applyXlsxCategoricalFormat_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating whether to print verbose output.</p>
</td></tr>
<tr><td><code id="applyXlsxCategoricalFormat_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a convenient wrapper for applying categorical
color formatting to cell background colors, and applies a contrasting
color to the text in cells using <code>setTextContrastColor()</code>.
It uses a named character vector of colors supplied as <code>colorSub</code>
to define cell background colors, and optionally <code>colorSubText</code>
to define a specific color for the cell text.
</p>


<h3>Value</h3>

<p><code>Workbook</code> object as defined by the <code>openxlsx</code> package
is returned invisibly with <code>invisible()</code>. This <code>Workbook</code>
can be used in argument <code>wb</code> to provide a speed boost when
saving multiple sheets to the same file.
</p>


<h3>See Also</h3>

<p>Other jam export functions: 
<code><a href="#topic+applyXlsxConditionalFormat">applyXlsxConditionalFormat</a>()</code>,
<code><a href="#topic+readOpenxlsx">readOpenxlsx</a>()</code>,
<code><a href="#topic+set_xlsx_colwidths">set_xlsx_colwidths</a>()</code>,
<code><a href="#topic+set_xlsx_rowheights">set_xlsx_rowheights</a>()</code>,
<code><a href="#topic+writeOpenxlsx">writeOpenxlsx</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># write to tempfile for examples
if (check_pkg_installed("openxlsx")) {
   out_xlsx &lt;- tempfile(pattern="writeOpenxlsx_", fileext=".xlsx")
   df &lt;- data.frame(a=LETTERS[1:5], b=1:5);
   writeOpenxlsx(x=df,
      file=out_xlsx,
      sheetName="jamba_test");

   colorSub &lt;- nameVector(
      rainbow2(5, s=c(0.8, 1), v=c(0.8, 1)),
      LETTERS[1:5]);
   applyXlsxCategoricalFormat(out_xlsx,
      sheet="jamba_test",
      colorSub=colorSub
   )
}

</code></pre>

<hr>
<h2 id='applyXlsxConditionalFormat'>Xlsx Conditional formatting</h2><span id='topic+applyXlsxConditionalFormat'></span>

<h3>Description</h3>

<p>Xlsx Conditional formatting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>applyXlsxConditionalFormat(
  xlsxFile,
  sheet = 1,
  fcColumns = NULL,
  fcGrep = NULL,
  fcStyle = c("#4F81BD", "#EEECE1", "#C0504D"),
  fcRule = c(-6, 0, 6),
  fcType = "colourScale",
  lfcColumns = NULL,
  lfcGrep = NULL,
  lfcStyle = c("#4F81BD", "#EEECE1", "#C0504D"),
  lfcRule = c(-3, 0, 3),
  lfcType = "colourScale",
  hitColumns = NULL,
  hitGrep = NULL,
  hitStyle = c("#4F81BD", "#EEECE1", "#C0504D"),
  hitRule = c(-1.5, 0, 1.5),
  hitType = "colourScale",
  intColumns = NULL,
  intGrep = NULL,
  intStyle = c("#EEECE1", "#FDC99B", "#F77F30"),
  intRule = c(0, 100, 10000),
  intType = "colourScale",
  numColumns = NULL,
  numGrep = NULL,
  numStyle = c("#F2F0F7", "#B4B1D4", "#938EC2"),
  numRule = c(1, 10, 20),
  numType = "colourScale",
  pvalueColumns = NULL,
  pvalueGrep = NULL,
  pvalueStyle = c("#F77F30", "#FDC99B", "#EEECE1"),
  pvalueRule = c(0, 0.01, 0.05),
  pvalueType = "colourScale",
  verbose = FALSE,
  startRow = 2,
  overwrite = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="applyXlsxConditionalFormat_+3A_xlsxfile">xlsxFile</code></td>
<td>
<p><code>character</code> filename to a file with &quot;.xlsx&quot; extension,
or <code>Workbook</code> object defined in the <code>openxlsx</code> package. When
<code>xlsxFile</code> is a <code>Workbook</code> the output is not saved to a file.</p>
</td></tr>
<tr><td><code id="applyXlsxConditionalFormat_+3A_sheet">sheet</code></td>
<td>
<p>integer or character, either the worksheet number, in order
or character worksheet name. This vector can contain multiple values,
which will cause conditional formatting to be applied to each
worksheet in the order given.</p>
</td></tr>
<tr><td><code id="applyXlsxConditionalFormat_+3A_fccolumns">fcColumns</code>, <code id="applyXlsxConditionalFormat_+3A_lfccolumns">lfcColumns</code>, <code id="applyXlsxConditionalFormat_+3A_hitcolumns">hitColumns</code>, <code id="applyXlsxConditionalFormat_+3A_intcolumns">intColumns</code>, <code id="applyXlsxConditionalFormat_+3A_numcolumns">numColumns</code>, <code id="applyXlsxConditionalFormat_+3A_pvaluecolumns">pvalueColumns</code></td>
<td>
<p>integer column indices, or character colnames indicating which columns
are to be treated as each of the various column types.</p>
</td></tr>
<tr><td><code id="applyXlsxConditionalFormat_+3A_fcgrep">fcGrep</code>, <code id="applyXlsxConditionalFormat_+3A_lfcgrep">lfcGrep</code>, <code id="applyXlsxConditionalFormat_+3A_hitgrep">hitGrep</code>, <code id="applyXlsxConditionalFormat_+3A_intgrep">intGrep</code>, <code id="applyXlsxConditionalFormat_+3A_numgrep">numGrep</code>, <code id="applyXlsxConditionalFormat_+3A_pvaluegrep">pvalueGrep</code></td>
<td>
<p>optional character vector which is used by <code><a href="#topic+provigrep">provigrep</a></code> to
colnames(x). This process may be more convenient to apply formatting
to known colname character patterns, rather than supplying exact column
indices or colnames.</p>
</td></tr>
<tr><td><code id="applyXlsxConditionalFormat_+3A_fcstyle">fcStyle</code>, <code id="applyXlsxConditionalFormat_+3A_lfcstyle">lfcStyle</code>, <code id="applyXlsxConditionalFormat_+3A_hitstyle">hitStyle</code>, <code id="applyXlsxConditionalFormat_+3A_intstyle">intStyle</code>, <code id="applyXlsxConditionalFormat_+3A_numstyle">numStyle</code>, <code id="applyXlsxConditionalFormat_+3A_pvaluestyle">pvalueStyle</code></td>
<td>
<p>color vector of length=3, corresponding to the numeric thresholds
defined by the corresponding Rules.</p>
</td></tr>
<tr><td><code id="applyXlsxConditionalFormat_+3A_fcrule">fcRule</code>, <code id="applyXlsxConditionalFormat_+3A_lfcrule">lfcRule</code>, <code id="applyXlsxConditionalFormat_+3A_hitrule">hitRule</code>, <code id="applyXlsxConditionalFormat_+3A_intrule">intRule</code>, <code id="applyXlsxConditionalFormat_+3A_numrule">numRule</code>, <code id="applyXlsxConditionalFormat_+3A_pvaluerule">pvalueRule</code></td>
<td>
<p>numeric vector of length=3, used to define three numeric thresholds
for color gradients to be applied.</p>
</td></tr>
<tr><td><code id="applyXlsxConditionalFormat_+3A_fctype">fcType</code>, <code id="applyXlsxConditionalFormat_+3A_lfctype">lfcType</code>, <code id="applyXlsxConditionalFormat_+3A_hittype">hitType</code>, <code id="applyXlsxConditionalFormat_+3A_inttype">intType</code>, <code id="applyXlsxConditionalFormat_+3A_numtype">numType</code>, <code id="applyXlsxConditionalFormat_+3A_pvaluetype">pvalueType</code></td>
<td>
<p>character string indicating the type of conditional rule to apply,
which in most cases should be &quot;colourScale&quot; which allows three numeric
thresholds, and three corresponding colors. For other allowed values,
see <code>openxlsx::conditionalFormatting()</code>.</p>
</td></tr>
<tr><td><code id="applyXlsxConditionalFormat_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating whether to print verbose output.</p>
</td></tr>
<tr><td><code id="applyXlsxConditionalFormat_+3A_startrow">startRow</code></td>
<td>
<p>integer indicating which row to begin applying conditional
formatting. In most cases startRow=2, which allows one row for column
headers. However, if there are multiple header rows, startRow should be
1 more than the number of header rows.</p>
</td></tr>
<tr><td><code id="applyXlsxConditionalFormat_+3A_overwrite">overwrite</code></td>
<td>
<p>logical indicating whether the original 'Excel' files will
be replaced with the new one, or whether a new file will be created.</p>
</td></tr>
<tr><td><code id="applyXlsxConditionalFormat_+3A_...">...</code></td>
<td>
<p>additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a convenient wrapper for applying conditional formatting
to 'Excel' 'xlsx' worksheets, with reasonable settings for commonly used
data types.
</p>
<p>Note that this function does not apply cell formatting, such as numeric
formatting as displayed in 'Excel'.
</p>
<p>A description of column types follows:
</p>

<dl>
<dt>&quot;fc&quot;</dt><dd><p>Fold change, typically positive and negative values,
which are formatted to show one decimal place, and use commas
to separate thousands places, e.g. 1,020.1. Colors are applied
with a neutral midpoint, coloring values which are above and
below zero.</p>
</dd>
<dt>&quot;lfc&quot;</dt><dd><p>log fold change, typically positive and negative values,
which are formatted to show one decimal place, and use commas
to separate thousands places, e.g. 12.1. Colors are applied
with a neutral midpoint, coloring values which are above and
below zero. Log fold changes have slightly different color
thresholds than fold changes.</p>
</dd>
<dt>&quot;hit&quot;</dt><dd><p>Hit columns, often just values like <code>c(-1,0,1)</code>,
but which could be fold changes for statistical hits for example.
They are formatted to show one decimal place, and use commas
to separate thousands places, e.g. 1.5. Colors are applied
with a neutral midpoint, coloring values which are above and
below zero, typically with a fairly low threshold.</p>
</dd>
<dt>&quot;int&quot;</dt><dd><p>Integer columns, which are formatted to hide decimal
place values even if present, which can help clean up visible
tabular data. They are formatted to use commas
to separate thousands places, e.g. 1,020. Colors are applied
with a baseline of zero, intended for highlighting two thresholds
of values above zero.</p>
</dd>
<dt>&quot;num&quot;</dt><dd><p>Numeric columns, which are formatted to display 2 decimal
places, and to use commas to separate thousands places,
e.g. 1,020.1. Colors are applied
with a baseline of zero, intended for highlighting two thresholds
of values above zero.</p>
</dd>
<dt>&quot;pvalue&quot;</dt><dd><p>P-value columns, which are formatted to display
scientific notation always, for consistency, with two decimal
places, e.g. 1.02e-02. Colors are applied starting at white for
P-value of 1 (non-significant) and becoming more red as the
P-value approaches 0.01, then 0.0001.</p>
</dd>
</dl>

<p>For each column type, one can describe the column using integer indices,
or colnames, or optionally use the Grep parameters. The Grep parameters
are intended for pattern matching, and may contain a vector of grep patterns
which are used by <code>provigrep()</code> to match to colnames. The Grep
method is particularly useful when applying conditional formatting for
multiple worksheets in the same 'xlsx' file, where the colnames are not
identical in each worksheet.
</p>
<p>Each column type has an associated 3-threshold rule, and three associated
colors. In order to apply different thresholds, one would need to call
this function multiple times, specifying different subsets of columns
corresponding to each set of thresholds. The same process is required
in order to apply different color gradients to different columns. Note
that styles are by default &quot;stacked&quot;, which
maintains font and cell border styles without removing them. However, it
this &quot;stacking&quot; means that applying two rules to the same cell will not
work, since only the first rule will be applied by 'Microsoft Excel'.
Interestingly, if multiple conditional rules are applied to the same
cell, they will be visible in order inside the 'Microsoft Excel'
application.
</p>


<h3>Value</h3>

<p><code>Workbook</code> object as defined by the <code>openxlsx</code> package
is returned invisibly with <code>invisible()</code>. This <code>Workbook</code>
can be used in argument <code>wb</code> to provide a speed boost when
saving multiple sheets to the same file.
</p>


<h3>See Also</h3>

<p>Other jam export functions: 
<code><a href="#topic+applyXlsxCategoricalFormat">applyXlsxCategoricalFormat</a>()</code>,
<code><a href="#topic+readOpenxlsx">readOpenxlsx</a>()</code>,
<code><a href="#topic+set_xlsx_colwidths">set_xlsx_colwidths</a>()</code>,
<code><a href="#topic+set_xlsx_rowheights">set_xlsx_rowheights</a>()</code>,
<code><a href="#topic+writeOpenxlsx">writeOpenxlsx</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># write to tempfile for examples
if (check_pkg_installed("openxlsx")) {
   out_xlsx &lt;- tempfile(pattern="writeOpenxlsx_", fileext=".xlsx")
   df &lt;- data.frame(a=LETTERS[1:5], b=1:5);
   writeOpenxlsx(x=df,
      file=out_xlsx,
      sheetName="jamba_test");

   applyXlsxConditionalFormat(out_xlsx,
      sheet="jamba_test",
      intColumns=2,
      intRule=c(0,3,5),
      intStyle=c("#FFFFFF", "#1E90FF", "#9932CC")
   )
}
</code></pre>

<hr>
<h2 id='asDate'>convert date DDmmmYYYY to Date</h2><span id='topic+asDate'></span>

<h3>Description</h3>

<p>convert date DDmmmYYYY to Date
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asDate(getDateValues, dateFormat = "%d%b%Y", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="asDate_+3A_getdatevalues">getDateValues</code></td>
<td>
<p><code>character</code> date, in format recognized by dateFormat</p>
</td></tr>
<tr><td><code id="asDate_+3A_dateformat">dateFormat</code></td>
<td>
<p><code>character</code> string representing the recognized date
format, by default <code>"DDmmmYYYY"</code>, which recognizes <code>"23aug2007"</code>.</p>
</td></tr>
<tr><td><code id="asDate_+3A_...">...</code></td>
<td>
<p>additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts a text date string to Date object, mainly to
allow date-related math operations, for example <code><a href="base.html#topic+difftime">difftime</a></code>.
</p>


<h3>Value</h3>

<p>Date object
</p>


<h3>See Also</h3>

<p>Other jam date functions: 
<code><a href="#topic+dateToDaysOld">dateToDaysOld</a>()</code>,
<code><a href="#topic+getDate">getDate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>asDate(getDate());

</code></pre>

<hr>
<h2 id='asSize'>convert numeric value or R object to human-readable size</h2><span id='topic+asSize'></span>

<h3>Description</h3>

<p>convert numeric value or R object to human-readable size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asSize(
  x,
  digits = 3,
  abbreviateUnits = TRUE,
  unitType = "bytes",
  unitAbbrev = gsub("^(.).*$", "\\1", unitType),
  kiloSize = 1024,
  sep = " ",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="asSize_+3A_x">x</code></td>
<td>
<p><code>numeric</code> vector, class <code>object_size</code> which is converted
to <code>numeric</code>, any other R object is converted to a single <code>numeric</code>
value using <code>utils::object.size()</code>.</p>
</td></tr>
<tr><td><code id="asSize_+3A_digits">digits</code></td>
<td>
<p><code>integer</code> number of digits used by <code>base::format()</code> when
formatting the number to create a character string</p>
</td></tr>
<tr><td><code id="asSize_+3A_abbreviateunits">abbreviateUnits</code></td>
<td>
<p><code>logical</code>, default TRUE,  whether to print
abbreviated units, for example using k, M, G, T, P instead of
kilo, mega, Giga, Tera, Peta, respectively.</p>
</td></tr>
<tr><td><code id="asSize_+3A_unittype">unitType</code></td>
<td>
<p><code>character</code> string indicating the base unit of measure,
by default &quot;bytes&quot;. Note that trailing &quot;s&quot; is removed when the number
is singular.</p>
</td></tr>
<tr><td><code id="asSize_+3A_unitabbrev">unitAbbrev</code></td>
<td>
<p><code>character</code> string indicating an abbreviated base unit,
by default it uses the first character from <code>unitType.</code></p>
</td></tr>
<tr><td><code id="asSize_+3A_kilosize">kiloSize</code></td>
<td>
<p><code>numeric</code>, default 1024,  number of base units when
converting from to one &quot;kilo&quot; base unit. For computer-based size
such as file size and object size, this value is 1024.
For other purposes, such as scientific or monetary numbers, this
value should usually be 1000.</p>
</td></tr>
<tr><td><code id="asSize_+3A_sep">sep</code></td>
<td>
<p><code>delimiter</code> used between the numeric value and the unit,
default &quot; &quot;.</p>
</td></tr>
<tr><td><code id="asSize_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code>base::format()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns human-readable size based upon <code>numeric</code> input.
Alternatively, when input is any other R object, it calls
<code>utils::object.size()</code> to produce a single <code>numeric</code> value which is then
used to produce human-readable size.
</p>
<p>The default behavior is to report computer size in bytes, where
1024 is considered &quot;kilo&quot;, however argument <code>kiloSize</code> can be
used to produce values where <code>kiloSize=1000</code> which is suitable
for monetary and other scientific values.
</p>


<h3>Value</h3>

<p><code>character</code> vector representing human-friendly size,
based upon the <code>kiloSize</code> argument to determine whether to
report byte (1024) or scientific (1000) units.
</p>


<h3>See Also</h3>

<p>Other jam string functions: 
<code><a href="#topic+breaksByVector">breaksByVector</a>()</code>,
<code><a href="#topic+fillBlanks">fillBlanks</a>()</code>,
<code><a href="#topic+formatInt">formatInt</a>()</code>,
<code><a href="#topic+gsubOrdered">gsubOrdered</a>()</code>,
<code><a href="#topic+gsubs">gsubs</a>()</code>,
<code><a href="#topic+makeNames">makeNames</a>()</code>,
<code><a href="#topic+nameVector">nameVector</a>()</code>,
<code><a href="#topic+nameVectorN">nameVectorN</a>()</code>,
<code><a href="#topic+padInteger">padInteger</a>()</code>,
<code><a href="#topic+padString">padString</a>()</code>,
<code><a href="#topic+pasteByRow">pasteByRow</a>()</code>,
<code><a href="#topic+pasteByRowOrdered">pasteByRowOrdered</a>()</code>,
<code><a href="#topic+sizeAsNum">sizeAsNum</a>()</code>,
<code><a href="#topic+tcount">tcount</a>()</code>,
<code><a href="#topic+ucfirst">ucfirst</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>asSize(c(1, 10,2010,22000,52200))
#&gt; "1 byte"   "10 bytes" "2 kb"     "21 kb"    "51 kb"

# demonstration of straight numeric units
asSize(c(1, 100, 1000, 10000), unitType="", kiloSize=100)

</code></pre>

<hr>
<h2 id='breakDensity'>Calculate more detailed density of numeric values</h2><span id='topic+breakDensity'></span>

<h3>Description</h3>

<p>Calculate more detailed density of numeric values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>breakDensity(
  x,
  breaks = length(x)/3,
  bw = NULL,
  width = NULL,
  densityBreaksFactor = 3,
  weightFactor = 1,
  addZeroEnds = TRUE,
  baseline = 0,
  floorBaseline = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="breakDensity_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="breakDensity_+3A_breaks">breaks</code></td>
<td>
<p>numeric breaks as described for <code>stats::density()</code> except
that single integer value is multiplied by <code>densityBreaksFactor</code>.</p>
</td></tr>
<tr><td><code id="breakDensity_+3A_bw">bw</code></td>
<td>
<p>character name of a bandwidth function, or NULL.</p>
</td></tr>
<tr><td><code id="breakDensity_+3A_width">width</code></td>
<td>
<p>NULL or numeric value indicating the width of breaks to
apply.</p>
</td></tr>
<tr><td><code id="breakDensity_+3A_densitybreaksfactor">densityBreaksFactor</code></td>
<td>
<p>numeric factor to adjust the width of
density breaks, where higher values result in less detail.</p>
</td></tr>
<tr><td><code id="breakDensity_+3A_weightfactor">weightFactor</code></td>
<td>
<p>optional vector of weights <code>length(x)</code> to apply
to the density calculation.</p>
</td></tr>
<tr><td><code id="breakDensity_+3A_addzeroends">addZeroEnds</code></td>
<td>
<p>logical indicating whether the start and end value
should always be zero, which can be helpful for creating a polygon.</p>
</td></tr>
<tr><td><code id="breakDensity_+3A_baseline">baseline</code></td>
<td>
<p>optional numeric value indicating the expected baseline,
which is typically zero, but can be set to a higher value to indicate
a &quot;noise floor&quot;.</p>
</td></tr>
<tr><td><code id="breakDensity_+3A_floorbaseline">floorBaseline</code></td>
<td>
<p>logical indicating whether to apply a noise floor
to the output data.</p>
</td></tr>
<tr><td><code id="breakDensity_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating whether to print verbose output.</p>
</td></tr>
<tr><td><code id="breakDensity_+3A_...">...</code></td>
<td>
<p>additional parameters are sent to <code>stats::density()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a drop-in replacement for <code>stats::density()</code>,
simply to provide a quick alternative that defaults to a higher
level of detail. Detail can be adjusted using <code>densityBreaksFactor</code>,
where higher values will use a wider step size, thus lowering
the detail in the output.
</p>
<p>Note that the density height is scaled by the total number of points,
and can be adjusted with <code>weightFactor</code>. See Examples for how to
scale the y-axis range similar to <code>stats::density()</code>.
</p>


<h3>Value</h3>

<p><code>list</code> output equivalent to <code>stats::density()</code>:
</p>

<ul>
<li> <p><code>x</code>: The <code>n</code> coordinates of the points where the density is
estimated.
</p>
</li>
<li> <p><code>y</code>: The estimated density values, non-negative, but can be zero.
</p>
</li>
<li> <p><code>bw</code>: The bandidth used.
</p>
</li>
<li> <p><code>n</code>: The sample size after elimination of missing values.
</p>
</li>
<li> <p><code>call</code>: the call which produced the result.
</p>
</li>
<li> <p><code>data.name</code>: the deparsed name of the <code>x</code> argument.
</p>
</li>
<li> <p><code>has.na</code>: <code>logical</code> for compatibility, and always <code>FALSE</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other jam practical functions: 
<code><a href="#topic+call_fn_ellipsis">call_fn_ellipsis</a>()</code>,
<code><a href="#topic+checkLightMode">checkLightMode</a>()</code>,
<code><a href="#topic+check_pkg_installed">check_pkg_installed</a>()</code>,
<code><a href="#topic+colNum2excelName">colNum2excelName</a>()</code>,
<code><a href="#topic+color_dither">color_dither</a>()</code>,
<code><a href="#topic+exp2signed">exp2signed</a>()</code>,
<code><a href="#topic+getAxisLabel">getAxisLabel</a>()</code>,
<code><a href="#topic+isFALSEV">isFALSEV</a>()</code>,
<code><a href="#topic+isTRUEV">isTRUEV</a>()</code>,
<code><a href="#topic+jargs">jargs</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+lldf">lldf</a>()</code>,
<code><a href="#topic+log2signed">log2signed</a>()</code>,
<code><a href="#topic+middle">middle</a>()</code>,
<code><a href="#topic+minorLogTicks">minorLogTicks</a>()</code>,
<code><a href="#topic+newestFile">newestFile</a>()</code>,
<code><a href="#topic+printDebug">printDebug</a>()</code>,
<code><a href="#topic+reload_rmarkdown_cache">reload_rmarkdown_cache</a>()</code>,
<code><a href="#topic+renameColumn">renameColumn</a>()</code>,
<code><a href="#topic+rmInfinite">rmInfinite</a>()</code>,
<code><a href="#topic+rmNA">rmNA</a>()</code>,
<code><a href="#topic+rmNAs">rmNAs</a>()</code>,
<code><a href="#topic+rmNULL">rmNULL</a>()</code>,
<code><a href="#topic+setPrompt">setPrompt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(stats::rnorm(15000),
   stats::rnorm(5500)*0.25 + 1,
   stats::rnorm(12500)*0.5 + 2.5)
plot(stats::density(x))

plot(breakDensity(x))

plot(breakDensity(x, densityBreaksFactor=200))

# trim values to show abrupt transitions
x2 &lt;- x[x &gt; 0 &amp; x &lt; 4]
plot(stats::density(x2), lwd=2)
lines(breakDensity(x2, weightFactor=1/length(x2)/10), col="red")
graphics::legend("topright", c("stats::density()", "breakDensity()"),
   col=c("black", "red"), lwd=c(2, 1))

</code></pre>

<hr>
<h2 id='breaksByVector'>break a vector into groups</h2><span id='topic+breaksByVector'></span>

<h3>Description</h3>

<p>breaks a vector into groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>breaksByVector(x, labels = NULL, returnFractions = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="breaksByVector_+3A_x">x</code></td>
<td>
<p><code>character</code> vector of labels</p>
</td></tr>
<tr><td><code id="breaksByVector_+3A_labels">labels</code></td>
<td>
<p><code>character</code> vector of custom labels to represent the items
in x</p>
</td></tr>
<tr><td><code id="breaksByVector_+3A_returnfractions">returnFractions</code></td>
<td>
<p><code>logical</code> whether to return fractional coordinates
for labels that should be positioned between two labels</p>
</td></tr>
<tr><td><code id="breaksByVector_+3A_...">...</code></td>
<td>
<p>additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a vector of values, determines &quot;chunks&quot; of identical
values, from which it defines where breaks occur. It assumes the input
vector is ordered in the way it will be displayed, with some labels
being duplicated consecutively. This function defines the breakpoints
where the labels change, and returns the ideal position to put a single
label to represent a duplicated consecutive set of labels.
</p>
<p>It can return fractional coordinates, for example when a label represents
two consecutive items, the fractional coordinate can be used to place the
label between the two items.
</p>
<p>This function is useful for things like adding labels to
<code>imageDefault()</code> color image map of sample groupings, where
it may be ideal to label only unique elements in a contiguous set.
</p>


<h3>Value</h3>

<p><code>list</code> with the following named elements:
</p>

<ul>
<li> <p><code>"breakPoints"</code>: The mid-point coordinate between each break.
These midpoints would be good for drawing dividing lines for
example.
</p>
</li>
<li> <p><code>"labelPoints"</code>: The ideal point to place a label to represent
the group.
</p>
</li>
<li> <p><code>"newLabels"</code>: A vector of labels the same length as the input
data, except using blank values except where a label should
be drawn. This output is good for text display.
</p>
</li>
<li> <p><code>"useLabels"</code>: The unique set of labels, without blanks,
corresponding to the coordinates supplied by labelPoints.
</p>
</li>
<li> <p><code>"breakLengths"</code>: The integer size of each set of labels.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other jam string functions: 
<code><a href="#topic+asSize">asSize</a>()</code>,
<code><a href="#topic+fillBlanks">fillBlanks</a>()</code>,
<code><a href="#topic+formatInt">formatInt</a>()</code>,
<code><a href="#topic+gsubOrdered">gsubOrdered</a>()</code>,
<code><a href="#topic+gsubs">gsubs</a>()</code>,
<code><a href="#topic+makeNames">makeNames</a>()</code>,
<code><a href="#topic+nameVector">nameVector</a>()</code>,
<code><a href="#topic+nameVectorN">nameVectorN</a>()</code>,
<code><a href="#topic+padInteger">padInteger</a>()</code>,
<code><a href="#topic+padString">padString</a>()</code>,
<code><a href="#topic+pasteByRow">pasteByRow</a>()</code>,
<code><a href="#topic+pasteByRowOrdered">pasteByRowOrdered</a>()</code>,
<code><a href="#topic+sizeAsNum">sizeAsNum</a>()</code>,
<code><a href="#topic+tcount">tcount</a>()</code>,
<code><a href="#topic+ucfirst">ucfirst</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- rep(LETTERS[c(1:5, 1)], c(2,3,5,4,3,4));
bb &lt;- breaksByVector(b);
# Example showing how labels can be minimized inside a data.frame
data.frame(b,
   newLabels=bb$newLabels);

# Example showing how to reposition text labels
# so duplicated labels are displayed in the middle
# of each group
bb2 &lt;- breaksByVector(b, returnFractions=TRUE);
ylabs &lt;- c("minimal labels", "all labels");
withr::with_par(adjustAxisLabelMargins(ylabs, 2), {
   withr::local_par(adjustAxisLabelMargins(bb2$useLabels, 1))
   nullPlot(xlim=range(seq_along(b)), ylim=c(0,3),
      doBoxes=FALSE, doUsrBox=TRUE);
   graphics::axis(2, las=2, at=c(1,2), ylabs);
   graphics::text(y=2, x=seq_along(b), b);
   graphics::text(y=1, x=bb2$labelPoints, bb2$useLabels);

## Print axis labels in the center of each group
graphics::axis(3,
   las=2,
   at=bb2$labelPoints,
   labels=bb2$useLabels);

## indicate each region
for (i in seq_along(bb2$breakPoints)) {
   graphics::axis(1,
      at=c(c(0, bb2$breakPoints)[i]+0.8, bb2$breakPoints[i]+0.2),
      labels=c("", ""));
}
## place the label centered in each region without adding tick marks
graphics::axis(1,
   las=2,
   tick=FALSE,
   at=bb2$labelPoints,
   labels=bb2$useLabels);
## abline to indicate the boundaries, if needed
graphics::abline(v=c(0, bb2$breakPoints) + 0.5,
   lty="dashed",
   col="blue");

})
# The same process is used by imageByColors()

</code></pre>

<hr>
<h2 id='call_fn_ellipsis'>Safely call a function using ellipsis</h2><span id='topic+call_fn_ellipsis'></span>

<h3>Description</h3>

<p>Safely call a function using ellipsis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_fn_ellipsis(FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="call_fn_ellipsis_+3A_fun">FUN</code></td>
<td>
<p><code>function</code> that should be called with arguments in <code>...</code></p>
</td></tr>
<tr><td><code id="call_fn_ellipsis_+3A_...">...</code></td>
<td>
<p>arguments are passed to <code>FUN()</code> in safe manner.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper function intended to help
pass ellipsis arguments <code>...</code> from a parent function
to an external function in a safe way. It will only
include arguments from <code>...</code> that are recognized by
the external function.
</p>
<p>The logic is described as follows:
</p>

<ul>
<li><p> When the external function <code>FUN</code> arguments <code>formals()</code> include
ellipsis <code>...</code>, then the ellipsis <code>...</code> will be passed as-is without
change. In this way, any arguments inside the original ellipsis <code>...</code>
will either match arguments in <code>FUN</code>, or will be ignored in that
function ellipsis <code>...</code>.
</p>
</li>
<li><p> When the external function <code>FUN</code> arguments <code>formals()</code> do not
include ellipsis <code>...</code>, then named arguments in <code>...</code> are passed
to <code>FUN</code> only when the arguments names are recognized by <code>FUN</code>.
</p>
</li></ul>

<p>Note that arguments therefore must be named.
</p>


<h3>Value</h3>

<p>output from <code>FUN()</code> when called with relevant named arguments
from ellipsis <code>...</code>
</p>


<h3>See Also</h3>

<p>Other jam practical functions: 
<code><a href="#topic+breakDensity">breakDensity</a>()</code>,
<code><a href="#topic+checkLightMode">checkLightMode</a>()</code>,
<code><a href="#topic+check_pkg_installed">check_pkg_installed</a>()</code>,
<code><a href="#topic+colNum2excelName">colNum2excelName</a>()</code>,
<code><a href="#topic+color_dither">color_dither</a>()</code>,
<code><a href="#topic+exp2signed">exp2signed</a>()</code>,
<code><a href="#topic+getAxisLabel">getAxisLabel</a>()</code>,
<code><a href="#topic+isFALSEV">isFALSEV</a>()</code>,
<code><a href="#topic+isTRUEV">isTRUEV</a>()</code>,
<code><a href="#topic+jargs">jargs</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+lldf">lldf</a>()</code>,
<code><a href="#topic+log2signed">log2signed</a>()</code>,
<code><a href="#topic+middle">middle</a>()</code>,
<code><a href="#topic+minorLogTicks">minorLogTicks</a>()</code>,
<code><a href="#topic+newestFile">newestFile</a>()</code>,
<code><a href="#topic+printDebug">printDebug</a>()</code>,
<code><a href="#topic+reload_rmarkdown_cache">reload_rmarkdown_cache</a>()</code>,
<code><a href="#topic+renameColumn">renameColumn</a>()</code>,
<code><a href="#topic+rmInfinite">rmInfinite</a>()</code>,
<code><a href="#topic+rmNA">rmNA</a>()</code>,
<code><a href="#topic+rmNAs">rmNAs</a>()</code>,
<code><a href="#topic+rmNULL">rmNULL</a>()</code>,
<code><a href="#topic+setPrompt">setPrompt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new_mean &lt;- function(x, trim=0, na.rm=FALSE) {
   mean(x, trim=trim, na.rm=na.rm)
}
x &lt;- c(1, 3, 5, NA);
new_mean(x, na.rm=TRUE);
# throws an error as expected (below)
tryCatch({
   new_mean(x, na.rm=TRUE, color="red")
}, error=function(e){
   print("Error is expected, shown below:");
   print(e)
})

call_fn_ellipsis(new_mean, x=x, na.rm=TRUE, color="red")

</code></pre>

<hr>
<h2 id='cell_fun_label'>ComplexHeatmap cell function to label heatmap cells</h2><span id='topic+cell_fun_label'></span>

<h3>Description</h3>

<p>ComplexHeatmap cell function to label heatmap cells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell_fun_label(
  m,
  prefix = "",
  suffix = "",
  cex = 1,
  col_hm = NULL,
  outline = FALSE,
  abbrev = FALSE,
  show = NULL,
  rot = 0,
  sep = "\n",
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cell_fun_label_+3A_m">m</code></td>
<td>
<p><code>numeric</code> matrix or <code>list</code> of <code>matrix</code> objects. The
first <code>matrix</code> object must be <code>numeric</code> and compatible
with the color function <code>col_hm</code>.</p>
</td></tr>
<tr><td><code id="cell_fun_label_+3A_prefix">prefix</code>, <code id="cell_fun_label_+3A_suffix">suffix</code></td>
<td>
<p><code>character</code> vectors that define a prefix and
suffix for each value in <code>m</code> for each cell.</p>
</td></tr>
<tr><td><code id="cell_fun_label_+3A_cex">cex</code></td>
<td>
<p><code>numeric</code> adjustment for the fontsize used for each label,
which is multiplied by the default <code>fontsize=10</code> to determine
the fontsize.</p>
</td></tr>
<tr><td><code id="cell_fun_label_+3A_col_hm">col_hm</code></td>
<td>
<p><code>function</code> as returned by <code>circlize::colorRamp2()</code> which
should be the same function used to create the heatmap</p>
</td></tr>
<tr><td><code id="cell_fun_label_+3A_outline">outline</code></td>
<td>
<p><code>logical</code> indicating whether to draw an outline around
each heatmap cell</p>
</td></tr>
<tr><td><code id="cell_fun_label_+3A_abbrev">abbrev</code></td>
<td>
<p><code>logical</code> indicating whether numeric values should
be abbreviated using <code>jamba::asSize(..., kiloSize=1000)</code> which
effectively reduces large numbers to <code>k</code> for thousands, <code>M</code> for
millions (M for Mega), <code>G</code> for billions (G for Giga), etc.</p>
</td></tr>
<tr><td><code id="cell_fun_label_+3A_show">show</code></td>
<td>
<p><code>integer</code> used when <code>m</code> is supplied as a <code>list</code> of matrices,
in which case <code>show</code> is used to define which values should be used
as cell labels. By default, all matrices are used.</p>
</td></tr>
<tr><td><code id="cell_fun_label_+3A_rot">rot</code></td>
<td>
<p><code>numeric</code> value used to rotate cell label text, default 0
is horizontal.</p>
</td></tr>
<tr><td><code id="cell_fun_label_+3A_sep">sep</code></td>
<td>
<p><code>character</code> string, default <code>"\n"</code> newline, used when
there are multiple labels per cell, which also requires
<code>m</code> as a list, and <code>show</code> is <code>NULL</code> or has multiple values.</p>
</td></tr>
<tr><td><code id="cell_fun_label_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating whether to print verbose output,
specifically printing label information for position <code style="white-space: pre;">&#8288;(1, 1)&#8288;</code>.
This output will only be seen when rendering or building the
Heatmap object.</p>
</td></tr>
<tr><td><code id="cell_fun_label_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function serves as a convenient method to add text
labels to each cell in a heatmap produced by
<code>ComplexHeatmap::Heatmap()</code>, via the argument <code>cell_fun</code>.
</p>
<p>Note that this function requires re-using the specific color
function used for the heatmap in the call to
<code>ComplexHeatmap::Heatmap()</code>.
</p>
<p>This function is slightly unique in that it allows multiple
labels, if <code>m</code> is supplied as a <code>list</code> of <code>matrix</code> objects.
In fact, some <code>matrix</code> objects may contain <code>character</code>
values with custom labels.
</p>
<p>Cell labels are colored based upon the heatmap cell color,
which is passed to <code>jamba::setTextContrastColor()</code> to determine
whether to use light or dark text color for optimum contrast.
</p>
<p>TODO: Option to supply a <code>logical</code> matrix to define a subset of
cells to label, for example only labels that meet a filter
criteria. Alternatively, the matrix data supplied in <code>m</code> can
already be filtered.
</p>
<p>TODO: Allow some matrix values that contain <code>character</code> data
to use <code>gridtext</code> for custom markdown formatting. That process
requires a slightly different method.
</p>


<h3>Value</h3>

<p><code>function</code> sufficient to use as input to
<code>ComplexHeatmap::Heatmap()</code> argument <code>cell_fun</code>.
</p>


<h3>See Also</h3>

<p>Other jam heatmap functions: 
<code><a href="#topic+heatmap_column_order">heatmap_column_order</a>()</code>,
<code><a href="#topic+heatmap_row_order">heatmap_row_order</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

m &lt;- matrix(stats::rnorm(16)*2, ncol=4)
colnames(m) &lt;- LETTERS[1:4]
rownames(m) &lt;- letters[1:4]
col_hm &lt;- circlize::colorRamp2(breaks=(-2:2) * 2,
   colors=c("navy", "dodgerblue", "white", "tomato", "red4"))

# the heatmap can be created in one step
hm &lt;- ComplexHeatmap::Heatmap(m,
   col=col_hm,
   heatmap_legend_param=list(
      color_bar="discrete",
      border=TRUE,
      at=-4:4),
   cell_fun=cell_fun_label(m,
      col_hm=col_hm))
ComplexHeatmap::draw(hm)

# the cell label function can be created first
cell_fun &lt;- cell_fun_label(m,
   outline=TRUE,
   cex=1.5,
   col_hm=col_hm)
hm2 &lt;- ComplexHeatmap::Heatmap(m,
   col=col_hm,
   cell_fun=cell_fun)
ComplexHeatmap::draw(hm2)

</code></pre>

<hr>
<h2 id='check_pkg_installed'>Lightweight method to check if an R package is installed</h2><span id='topic+check_pkg_installed'></span>

<h3>Description</h3>

<p>Lightweight method to check if an R package is installed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_pkg_installed(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_pkg_installed_+3A_x">x</code></td>
<td>
<p><code>character</code> string of package or packages to test.</p>
</td></tr>
<tr><td><code id="check_pkg_installed_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are many methods to test for an installed package,
this function represents possibly the most gentle and rapid
approach. It simply calls <code>system.file(package="")</code>,
which checks in the context of the active R session
and uses the relevant <code>.libPaths()</code>.
</p>
<p>This approach does not use <code>require()</code> because that actually
loads the package, which can take time and resources.
</p>
<p>This approach also does not use <code>installed.packages()</code>
which can also take substantial time if many packages
are installed on a system.
</p>


<h3>Value</h3>

<p><code>logical</code> indicating whether each value in <code>x</code>
represents an installed R package.
</p>


<h3>See Also</h3>

<p>Other jam practical functions: 
<code><a href="#topic+breakDensity">breakDensity</a>()</code>,
<code><a href="#topic+call_fn_ellipsis">call_fn_ellipsis</a>()</code>,
<code><a href="#topic+checkLightMode">checkLightMode</a>()</code>,
<code><a href="#topic+colNum2excelName">colNum2excelName</a>()</code>,
<code><a href="#topic+color_dither">color_dither</a>()</code>,
<code><a href="#topic+exp2signed">exp2signed</a>()</code>,
<code><a href="#topic+getAxisLabel">getAxisLabel</a>()</code>,
<code><a href="#topic+isFALSEV">isFALSEV</a>()</code>,
<code><a href="#topic+isTRUEV">isTRUEV</a>()</code>,
<code><a href="#topic+jargs">jargs</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+lldf">lldf</a>()</code>,
<code><a href="#topic+log2signed">log2signed</a>()</code>,
<code><a href="#topic+middle">middle</a>()</code>,
<code><a href="#topic+minorLogTicks">minorLogTicks</a>()</code>,
<code><a href="#topic+newestFile">newestFile</a>()</code>,
<code><a href="#topic+printDebug">printDebug</a>()</code>,
<code><a href="#topic+reload_rmarkdown_cache">reload_rmarkdown_cache</a>()</code>,
<code><a href="#topic+renameColumn">renameColumn</a>()</code>,
<code><a href="#topic+rmInfinite">rmInfinite</a>()</code>,
<code><a href="#topic+rmNA">rmNA</a>()</code>,
<code><a href="#topic+rmNAs">rmNAs</a>()</code>,
<code><a href="#topic+rmNULL">rmNULL</a>()</code>,
<code><a href="#topic+setPrompt">setPrompt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>check_pkg_installed("methods")

check_pkg_installed(c("jamba",
   "multienrichjam",
   "venndir",
   "methods",
   "blah"))

</code></pre>

<hr>
<h2 id='checkLightMode'>check lightMode for light background color</h2><span id='topic+checkLightMode'></span>

<h3>Description</h3>

<p>check lightMode for light background color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkLightMode(lightMode = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkLightMode_+3A_lightmode">lightMode</code></td>
<td>
<p><code>logical</code> or NULL, indicating whether the lightMode
parameter has been defined in the function call.</p>
</td></tr>
<tr><td><code id="checkLightMode_+3A_...">...</code></td>
<td>
<p>Additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Check the lightMode status through function parameter, options, or
environment variable. If the function defines lightMode, it is used as-is.
If lightMode is NULL, then options(&quot;jam.lightMode&quot;) is used if defined.
Otherwise, it tries to detect whether the R session is running inside
Rstudio using the environmental variable &quot;RSTUDIO&quot;, and if so it assumes
lightMode==TRUE.
</p>
<p>To set a default lightMode, add options(&quot;jam.lightMode&quot;=TRUE) to .Rprofile, or
to the relevant R script.
</p>


<h3>Value</h3>

<p>logical or length=1, indicating whether lightMode is defined
</p>


<h3>See Also</h3>

<p>Other jam practical functions: 
<code><a href="#topic+breakDensity">breakDensity</a>()</code>,
<code><a href="#topic+call_fn_ellipsis">call_fn_ellipsis</a>()</code>,
<code><a href="#topic+check_pkg_installed">check_pkg_installed</a>()</code>,
<code><a href="#topic+colNum2excelName">colNum2excelName</a>()</code>,
<code><a href="#topic+color_dither">color_dither</a>()</code>,
<code><a href="#topic+exp2signed">exp2signed</a>()</code>,
<code><a href="#topic+getAxisLabel">getAxisLabel</a>()</code>,
<code><a href="#topic+isFALSEV">isFALSEV</a>()</code>,
<code><a href="#topic+isTRUEV">isTRUEV</a>()</code>,
<code><a href="#topic+jargs">jargs</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+lldf">lldf</a>()</code>,
<code><a href="#topic+log2signed">log2signed</a>()</code>,
<code><a href="#topic+middle">middle</a>()</code>,
<code><a href="#topic+minorLogTicks">minorLogTicks</a>()</code>,
<code><a href="#topic+newestFile">newestFile</a>()</code>,
<code><a href="#topic+printDebug">printDebug</a>()</code>,
<code><a href="#topic+reload_rmarkdown_cache">reload_rmarkdown_cache</a>()</code>,
<code><a href="#topic+renameColumn">renameColumn</a>()</code>,
<code><a href="#topic+rmInfinite">rmInfinite</a>()</code>,
<code><a href="#topic+rmNA">rmNA</a>()</code>,
<code><a href="#topic+rmNAs">rmNAs</a>()</code>,
<code><a href="#topic+rmNULL">rmNULL</a>()</code>,
<code><a href="#topic+setPrompt">setPrompt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>checkLightMode(TRUE);
checkLightMode();

</code></pre>

<hr>
<h2 id='col2alpha'>get R color alpha value</h2><span id='topic+col2alpha'></span>

<h3>Description</h3>

<p>Return the alpha transparency per R color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col2alpha(x, maxValue = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col2alpha_+3A_x">x</code></td>
<td>
<p><code>character</code> R compatible color, either a color name, hex value, or
a mixture of the two. Any value compatible with <code>grDevices::col2rgb()</code>.</p>
</td></tr>
<tr><td><code id="col2alpha_+3A_maxvalue">maxValue</code></td>
<td>
<p><code>numeric</code> maximum value to return, useful when the downstream
alpha range should be 255. By default maxValue=1 is returned.</p>
</td></tr>
<tr><td><code id="col2alpha_+3A_...">...</code></td>
<td>
<p>Additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code> vector of alpha values
</p>


<h3>See Also</h3>

<p>Other jam color functions: 
<code><a href="#topic+alpha2col">alpha2col</a>()</code>,
<code><a href="#topic+applyCLrange">applyCLrange</a>()</code>,
<code><a href="#topic+col2hcl">col2hcl</a>()</code>,
<code><a href="#topic+col2hsl">col2hsl</a>()</code>,
<code><a href="#topic+col2hsv">col2hsv</a>()</code>,
<code><a href="#topic+color2gradient">color2gradient</a>()</code>,
<code><a href="#topic+fixYellow">fixYellow</a>()</code>,
<code><a href="#topic+fixYellowHue">fixYellowHue</a>()</code>,
<code><a href="#topic+getColorRamp">getColorRamp</a>()</code>,
<code><a href="#topic+hcl2col">hcl2col</a>()</code>,
<code><a href="#topic+hsl2col">hsl2col</a>()</code>,
<code><a href="#topic+hsv2col">hsv2col</a>()</code>,
<code><a href="#topic+isColor">isColor</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+makeColorDarker">makeColorDarker</a>()</code>,
<code><a href="#topic+rainbow2">rainbow2</a>()</code>,
<code><a href="#topic+rgb2col">rgb2col</a>()</code>,
<code><a href="#topic+setCLranges">setCLranges</a>()</code>,
<code><a href="#topic+setTextContrastColor">setTextContrastColor</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+unalpha">unalpha</a>()</code>,
<code><a href="#topic+warpRamp">warpRamp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>col2alpha(c("red", "#99004499", "beige", "transparent", "#FFFFFF00"))

</code></pre>

<hr>
<h2 id='col2hcl'>convert R color to HCL color matrix</h2><span id='topic+col2hcl'></span>

<h3>Description</h3>

<p>convert R color to HCL color matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col2hcl(
  x,
  maxColorValue = 255,
  model = getOption("jam.model", c("hcl", "polarLUV", "polarLAB")),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col2hcl_+3A_x">x</code></td>
<td>
<p><code>character</code> R compatible color, either a color name, hex value, or
a mixture of the two. Any value compatible with
<code>grDevices::col2rgb()</code>.</p>
</td></tr>
<tr><td><code id="col2hcl_+3A_maxcolorvalue">maxColorValue</code></td>
<td>
<p><code>numeric</code> maximum value to return, useful
when the downstream alpha range should be 255.
By default maxValue=1 is returned.</p>
</td></tr>
<tr><td><code id="col2hcl_+3A_model">model</code></td>
<td>
<p><code>character</code> color model to use
</p>

<ul>
<li> <p><code>"hcl"</code> to use <code>farver</code> HCL
</p>
</li>
<li> <p><code>"polarLUV"</code> for the standard R conventional HCL,
</p>
</li>
<li> <p><code>"polarLAB"</code> which uses the LAB-based HCL values.
</p>
</li></ul>
</td></tr>
<tr><td><code id="col2hcl_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes an R color and converts to an HCL matrix, using
the colorspace package, and <code><a href="colorspace.html#topic+RGB">RGB</a></code> and
<code><a href="colorspace.html#topic+polarLUV">polarLUV</a></code> functions. It is also used to
maintain alpha transparency, to enable interconversion via other
color manipulation functions as well.
</p>
<p>When <code>model="hcl"</code> this function uses <code>farver::decode_colour()</code>
and bypasses <code>colorspace</code>. In future the <code>colorspace</code> dependency
will likely be removed in favor of using <code>farver</code>. In any event,
<code>model="hcl"</code> is equivalent to using <code>model="polarLUV"</code> and
<code>fixup=TRUE</code>, except that it should be much faster.
</p>


<h3>Value</h3>

<p><code>numeric</code> matrix with H, C, L values.
</p>


<h3>See Also</h3>

<p>Other jam color functions: 
<code><a href="#topic+alpha2col">alpha2col</a>()</code>,
<code><a href="#topic+applyCLrange">applyCLrange</a>()</code>,
<code><a href="#topic+col2alpha">col2alpha</a>()</code>,
<code><a href="#topic+col2hsl">col2hsl</a>()</code>,
<code><a href="#topic+col2hsv">col2hsv</a>()</code>,
<code><a href="#topic+color2gradient">color2gradient</a>()</code>,
<code><a href="#topic+fixYellow">fixYellow</a>()</code>,
<code><a href="#topic+fixYellowHue">fixYellowHue</a>()</code>,
<code><a href="#topic+getColorRamp">getColorRamp</a>()</code>,
<code><a href="#topic+hcl2col">hcl2col</a>()</code>,
<code><a href="#topic+hsl2col">hsl2col</a>()</code>,
<code><a href="#topic+hsv2col">hsv2col</a>()</code>,
<code><a href="#topic+isColor">isColor</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+makeColorDarker">makeColorDarker</a>()</code>,
<code><a href="#topic+rainbow2">rainbow2</a>()</code>,
<code><a href="#topic+rgb2col">rgb2col</a>()</code>,
<code><a href="#topic+setCLranges">setCLranges</a>()</code>,
<code><a href="#topic+setTextContrastColor">setTextContrastColor</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+unalpha">unalpha</a>()</code>,
<code><a href="#topic+warpRamp">warpRamp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>col2hcl("#FF000044")

</code></pre>

<hr>
<h2 id='col2hsl'>convert R color to HSL color matrix</h2><span id='topic+col2hsl'></span>

<h3>Description</h3>

<p>convert R color to HSL color matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col2hsl(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col2hsl_+3A_x">x</code></td>
<td>
<p><code>character</code> vector with R compatible colors.</p>
</td></tr>
<tr><td><code id="col2hsl_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes an R color and converts to an HSL matrix, using
the <code>farver</code> package <code>farver::decode_colour()</code>
the colorspace package, and <code><a href="colorspace.html#topic+RGB">RGB</a></code> and
<code><a href="colorspace.html#topic+polarLUV">polarLUV</a></code> functions. It is also used to
maintain alpha transparency, to enable interconversion via other
color manipulation functions as well.
</p>
<p>When <code>model="hsl"</code> this function uses <code>farver::decode_colour()</code>
and bypasses <code>colorspace</code>. In future the <code>colorspace</code> dependency
will likely be removed in favor of using <code>farver</code>. In any event,
<code>model="hsl"</code> is equivalent to using <code>model="polarLUV"</code> and
<code>fixup=TRUE</code>, except that it should be much faster.
</p>


<h3>Value</h3>

<p><code>numeric</code> matrix of H, S, L color values.
</p>


<h3>See Also</h3>

<p>Other jam color functions: 
<code><a href="#topic+alpha2col">alpha2col</a>()</code>,
<code><a href="#topic+applyCLrange">applyCLrange</a>()</code>,
<code><a href="#topic+col2alpha">col2alpha</a>()</code>,
<code><a href="#topic+col2hcl">col2hcl</a>()</code>,
<code><a href="#topic+col2hsv">col2hsv</a>()</code>,
<code><a href="#topic+color2gradient">color2gradient</a>()</code>,
<code><a href="#topic+fixYellow">fixYellow</a>()</code>,
<code><a href="#topic+fixYellowHue">fixYellowHue</a>()</code>,
<code><a href="#topic+getColorRamp">getColorRamp</a>()</code>,
<code><a href="#topic+hcl2col">hcl2col</a>()</code>,
<code><a href="#topic+hsl2col">hsl2col</a>()</code>,
<code><a href="#topic+hsv2col">hsv2col</a>()</code>,
<code><a href="#topic+isColor">isColor</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+makeColorDarker">makeColorDarker</a>()</code>,
<code><a href="#topic+rainbow2">rainbow2</a>()</code>,
<code><a href="#topic+rgb2col">rgb2col</a>()</code>,
<code><a href="#topic+setCLranges">setCLranges</a>()</code>,
<code><a href="#topic+setTextContrastColor">setTextContrastColor</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+unalpha">unalpha</a>()</code>,
<code><a href="#topic+warpRamp">warpRamp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("#FF000044", "#FF0000", "firebrick");
names(x) &lt;- x;
showColors(x)
xhsl &lt;- col2hsl(x)
xhsl

xhex &lt;- hsl2col(xhsl)
showColors(list(x=x,
   xhex=xhex),
   groupCellnotes=FALSE)

withr::with_par(list("mfrow"=c(4, 4), "mar"=c(0.2, 1, 4, 1)), {

for (H in seq(from=0, to=360, length.out=17)[-17]) {
S &lt;- 75;
Lseq &lt;- seq(from=15, to=95, by=10);
hsl_gradient &lt;- hsl2col(
   H=H,
   S=85,
   L=Lseq);
hcl_gradient &lt;- hcl2col(
   H=H,
   C=85,
   L=Lseq);
names(hsl_gradient) &lt;- Lseq;
names(hcl_gradient) &lt;- Lseq;
showColors(xaxt="n",
   list(
      hsl=hsl_gradient,
      hcl=hcl_gradient),
   main=paste0("Hue: ", round(H),
      "\nSat: ", S,
      "\nLum: (as labeled)"),
   groupCellnotes=FALSE)
}
})

</code></pre>

<hr>
<h2 id='col2hsv'>Convert R color to HSV matrix</h2><span id='topic+col2hsv'></span>

<h3>Description</h3>

<p>Convert R color to HSV matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col2hsv(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col2hsv_+3A_x">x</code></td>
<td>
<p>R color</p>
</td></tr>
<tr><td><code id="col2hsv_+3A_...">...</code></td>
<td>
<p>additional parameters are ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a valid R color and converts to a HSV matrix. The
output can be effectively returned to R color with
<code><a href="#topic+hsv2col">hsv2col</a></code>, usually after manipulating the
HSV color matrix.
</p>


<h3>Value</h3>

<p>matrix of HSV colors
</p>


<h3>See Also</h3>

<p>Other jam color functions: 
<code><a href="#topic+alpha2col">alpha2col</a>()</code>,
<code><a href="#topic+applyCLrange">applyCLrange</a>()</code>,
<code><a href="#topic+col2alpha">col2alpha</a>()</code>,
<code><a href="#topic+col2hcl">col2hcl</a>()</code>,
<code><a href="#topic+col2hsl">col2hsl</a>()</code>,
<code><a href="#topic+color2gradient">color2gradient</a>()</code>,
<code><a href="#topic+fixYellow">fixYellow</a>()</code>,
<code><a href="#topic+fixYellowHue">fixYellowHue</a>()</code>,
<code><a href="#topic+getColorRamp">getColorRamp</a>()</code>,
<code><a href="#topic+hcl2col">hcl2col</a>()</code>,
<code><a href="#topic+hsl2col">hsl2col</a>()</code>,
<code><a href="#topic+hsv2col">hsv2col</a>()</code>,
<code><a href="#topic+isColor">isColor</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+makeColorDarker">makeColorDarker</a>()</code>,
<code><a href="#topic+rainbow2">rainbow2</a>()</code>,
<code><a href="#topic+rgb2col">rgb2col</a>()</code>,
<code><a href="#topic+setCLranges">setCLranges</a>()</code>,
<code><a href="#topic+setTextContrastColor">setTextContrastColor</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+unalpha">unalpha</a>()</code>,
<code><a href="#topic+warpRamp">warpRamp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># start with a color vector
# red and blue with partial transparency
colorV &lt;- c("#FF000055", "#00339999");

# confirm the hsv matrix maintains transparency
col2hsv(colorV);

# convert back to the original color
hsv2col(col2hsv(colorV));

</code></pre>

<hr>
<h2 id='colNum2excelName'>convert column number to 'Excel' column name</h2><span id='topic+colNum2excelName'></span>

<h3>Description</h3>

<p>convert column number to 'Excel' column name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colNum2excelName(x, useLetters = LETTERS, zeroVal = "a", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colNum2excelName_+3A_x">x</code></td>
<td>
<p><code>integer</code> vector</p>
</td></tr>
<tr><td><code id="colNum2excelName_+3A_useletters">useLetters</code></td>
<td>
<p><code>character</code> vector of single-digit characters to use as
digits in the resulting column name. Note that these characters can
be of almost any length, with any content.</p>
</td></tr>
<tr><td><code id="colNum2excelName_+3A_zeroval">zeroVal</code></td>
<td>
<p><code>character</code> single-digit to be used whenever <code>x==0</code>, or as a
prefix for negative values. In theory there should be no negative
input values, but this basic mechanism is used to handle the possibility.</p>
</td></tr>
<tr><td><code id="colNum2excelName_+3A_...">...</code></td>
<td>
<p>Additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose is to convert an <code>integer</code> column number into a valid 'Excel'
column name, using <code>LETTERS</code> starting at A.
This function implements an arbitrary number of digits, which may or
may not be compatible with each version of 'Excel'.  18,278 columns
would be the maximum for three digits, &quot;A&quot; through &quot;ZZZ&quot;.
</p>
<p>This function is useful when referencing 'Excel' columns via another
interface such as via openxlsx. It is also used by <code>makeNames()</code>
when the <code>numberStyle="letters"</code>, in order to provide letter suffix values.
</p>
<p>One can somewhat manipulate the allowed column names via the <code>useLetters</code>
argument, which by default uses the entire 26-letter Western alphabet.
</p>


<h3>Value</h3>

<p><code>character</code> vector with length(x)
</p>


<h3>See Also</h3>

<p>Other jam practical functions: 
<code><a href="#topic+breakDensity">breakDensity</a>()</code>,
<code><a href="#topic+call_fn_ellipsis">call_fn_ellipsis</a>()</code>,
<code><a href="#topic+checkLightMode">checkLightMode</a>()</code>,
<code><a href="#topic+check_pkg_installed">check_pkg_installed</a>()</code>,
<code><a href="#topic+color_dither">color_dither</a>()</code>,
<code><a href="#topic+exp2signed">exp2signed</a>()</code>,
<code><a href="#topic+getAxisLabel">getAxisLabel</a>()</code>,
<code><a href="#topic+isFALSEV">isFALSEV</a>()</code>,
<code><a href="#topic+isTRUEV">isTRUEV</a>()</code>,
<code><a href="#topic+jargs">jargs</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+lldf">lldf</a>()</code>,
<code><a href="#topic+log2signed">log2signed</a>()</code>,
<code><a href="#topic+middle">middle</a>()</code>,
<code><a href="#topic+minorLogTicks">minorLogTicks</a>()</code>,
<code><a href="#topic+newestFile">newestFile</a>()</code>,
<code><a href="#topic+printDebug">printDebug</a>()</code>,
<code><a href="#topic+reload_rmarkdown_cache">reload_rmarkdown_cache</a>()</code>,
<code><a href="#topic+renameColumn">renameColumn</a>()</code>,
<code><a href="#topic+rmInfinite">rmInfinite</a>()</code>,
<code><a href="#topic+rmNA">rmNA</a>()</code>,
<code><a href="#topic+rmNAs">rmNAs</a>()</code>,
<code><a href="#topic+rmNULL">rmNULL</a>()</code>,
<code><a href="#topic+setPrompt">setPrompt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>colNum2excelName(1:30)

</code></pre>

<hr>
<h2 id='color_dither'>Make dithered color pattern light-dark</h2><span id='topic+color_dither'></span>

<h3>Description</h3>

<p>Make dithered color pattern light-dark
</p>


<h3>Usage</h3>

<pre><code class='language-R'>color_dither(
  x,
  L_diff = 4,
  L_max = 90,
  L_min = 30,
  min_contrast = 1.25,
  direction = 1,
  returnType = c("vector", "list", "matrix"),
  debug = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="color_dither_+3A_x">x</code></td>
<td>
<p><code>character</code> vector of R colors</p>
</td></tr>
<tr><td><code id="color_dither_+3A_l_diff">L_diff</code></td>
<td>
<p><code>numeric</code> value added or subtracted from the L in HSL
color space for each color, until contrast is at least <code>min_contrast</code>.</p>
</td></tr>
<tr><td><code id="color_dither_+3A_l_max">L_max</code>, <code id="color_dither_+3A_l_min">L_min</code></td>
<td>
<p><code>numeric</code> values that define the permitted range
of L values in HSL color space, which ranges from 0 to 100.</p>
</td></tr>
<tr><td><code id="color_dither_+3A_min_contrast">min_contrast</code></td>
<td>
<p><code>numeric</code> minimum contrast as defined by
<code>colorspace::contrast_ratio()</code> for the input and potential output
color.</p>
</td></tr>
<tr><td><code id="color_dither_+3A_direction">direction</code></td>
<td>
<p><code>numeric</code> that defines the initial direction,
where values &gt;= 0 start by making colors lighter, and values &lt; 0
make colors darker.</p>
</td></tr>
<tr><td><code id="color_dither_+3A_returntype">returnType</code></td>
<td>
<p><code>character</code> string that defines the output of this
function:
</p>

<ul>
<li> <p><code>vector</code>: two colors for every input color in <code>x</code>
</p>
</li>
<li> <p><code>matrix</code>: two rows, input colors on first row, output colors
on second row
</p>
</li>
<li> <p><code>list</code>: a <code>list</code> with two colors in each element, with input
and output colors together in each vector.
</p>
</li></ul>
</td></tr>
<tr><td><code id="color_dither_+3A_debug">debug</code></td>
<td>
<p><code>logical</code> indicating whether to plot the color iterations
using <code>showColors()</code>.</p>
</td></tr>
<tr><td><code id="color_dither_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function serves a very simple purpose, mainly for
<code>printDebug()</code> to use subtle alternating light/dark colors
for vector output. It takes a color and returns two colors
which are slightly lighter and darker than each other,
to a minimum contrast defined by <code>colorspace::contrast_ratio()</code>.
</p>


<h3>Value</h3>

<p>format defined by argument <code>returnType</code>:
</p>

<ul>
<li> <p><code>vector</code>: two colors for every input color in <code>x</code>
</p>
</li>
<li> <p><code>matrix</code>: two rows, input colors on first row, output colors
on second row
</p>
</li>
<li> <p><code>list</code>: a <code>list</code> with two colors in each element, with input
and output colors together in each vector.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other jam practical functions: 
<code><a href="#topic+breakDensity">breakDensity</a>()</code>,
<code><a href="#topic+call_fn_ellipsis">call_fn_ellipsis</a>()</code>,
<code><a href="#topic+checkLightMode">checkLightMode</a>()</code>,
<code><a href="#topic+check_pkg_installed">check_pkg_installed</a>()</code>,
<code><a href="#topic+colNum2excelName">colNum2excelName</a>()</code>,
<code><a href="#topic+exp2signed">exp2signed</a>()</code>,
<code><a href="#topic+getAxisLabel">getAxisLabel</a>()</code>,
<code><a href="#topic+isFALSEV">isFALSEV</a>()</code>,
<code><a href="#topic+isTRUEV">isTRUEV</a>()</code>,
<code><a href="#topic+jargs">jargs</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+lldf">lldf</a>()</code>,
<code><a href="#topic+log2signed">log2signed</a>()</code>,
<code><a href="#topic+middle">middle</a>()</code>,
<code><a href="#topic+minorLogTicks">minorLogTicks</a>()</code>,
<code><a href="#topic+newestFile">newestFile</a>()</code>,
<code><a href="#topic+printDebug">printDebug</a>()</code>,
<code><a href="#topic+reload_rmarkdown_cache">reload_rmarkdown_cache</a>()</code>,
<code><a href="#topic+renameColumn">renameColumn</a>()</code>,
<code><a href="#topic+rmInfinite">rmInfinite</a>()</code>,
<code><a href="#topic+rmNA">rmNA</a>()</code>,
<code><a href="#topic+rmNAs">rmNAs</a>()</code>,
<code><a href="#topic+rmNULL">rmNULL</a>()</code>,
<code><a href="#topic+setPrompt">setPrompt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "firebrick1";
showColors(color_dither(x))

showColors(color_dither(x, direction=-1))

x &lt;- vigrep("^green[0-9]", grDevices::colors())
showColors(color_dither(x))
showColors(color_dither(x, direction=-1, returnType="list"))

x &lt;- c("green1", "cyan", "blue", "red", "gold", "yellow", "pink")
showColors(color_dither(x))

color_dither(x, debug=TRUE)

</code></pre>

<hr>
<h2 id='color2gradient'>Make a color gradient</h2><span id='topic+color2gradient'></span>

<h3>Description</h3>

<p>Make a color gradient
</p>


<h3>Usage</h3>

<pre><code class='language-R'>color2gradient(
  col,
  n = NULL,
  gradientWtFactor = NULL,
  dex = 1,
  reverseGradient = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="color2gradient_+3A_col">col</code></td>
<td>
<p>some type of recognized R color input as:
</p>

<ul>
<li> <p><code>character</code> vector of one or more individual colors, each
color is expanded into a gradient of length <code>n</code>, where <code>n</code> is
recycled to the number of unique colors. The value <code>n</code> is applied
in the order the colors appear in <code>col</code>.
</p>
</li>
<li> <p><code>list</code> of color vectors where each vector contains one repeated color
</p>
</li>
<li> <p><code>character</code> vector of repeated colors, where <code>n</code> is defined by
the number of each color present.
</p>
</li></ul>
</td></tr>
<tr><td><code id="color2gradient_+3A_n">n</code></td>
<td>
<p><code>integer</code> vector of length one or more, which defines the number
of colors to return for each gradient. When <code>n=0</code> then only duplicated
colors will be expanded into a gradient.</p>
</td></tr>
<tr><td><code id="color2gradient_+3A_gradientwtfactor">gradientWtFactor</code></td>
<td>
<p><code>numeric</code> fraction representing the amount to expand
a color toward its maximum brightness and darkness.
It is recommended to use <code>dex</code> and not this argument.
</p>

<ul>
<li><p> When <code>gradientWtFactor=NULL</code> this value is calculated based upon the
number of colors requested, and the initial luminance in HCL
space of the starting color.
</p>
</li>
<li><p> When <code>gradientWtFactor</code> is defined, values are recycled to
<code>length(col)</code>, and can be independently applied to each color.
</p>
</li></ul>
</td></tr>
<tr><td><code id="color2gradient_+3A_dex">dex</code></td>
<td>
<p><code>numeric</code> value to apply dramatic dark expansion, where:
</p>

<ul>
<li> <p><code>dex &gt; 1</code> will make the gradient more dramatic, values
</p>
</li>
<li> <p><code>dex &lt; 1</code> will make the gradient less dramatic, and are considered
fractions 1/x.
</p>
</li>
<li> <p><code>dex &lt; 0</code> will make the gradient less dramatic, and values are
internally converted to fractions using <code>1/(2 + abs(dex))</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="color2gradient_+3A_reversegradient">reverseGradient</code></td>
<td>
<p><code>logical</code> whether to return light-to-dark gradient
(TRUE) or dark-to-light gradient (FALSE).</p>
</td></tr>
<tr><td><code id="color2gradient_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> whether to print verbose output.</p>
</td></tr>
<tr><td><code id="color2gradient_+3A_...">...</code></td>
<td>
<p>other parameters are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts a single color into a color gradient by expanding
the initial color into lighter and darker colors around the central color.
The amount of gradient expansion is controlled by gradientWtFactor, which
is a weight factor scaled to the maximum available range of bright to
dark colors.
</p>
<p>As an extension, the function can take a vector of colors, and expand each
into its own color gradient, each with its own number of colors.
If a vector with supplied that contains repeated colors, these colors
are expanded in-place into a gradient, bypassing the value for <code>n</code>.
</p>
<p>If a list is supplied, a list is returned of the same length, where
each vector inside the list is a color gradient of length specified
by <code>n</code>. If the input list contains multiple values, only the first
color is used to define the color gradient.
</p>


<h3>Value</h3>

<p><code>character</code> vector of R colors.
</p>


<h3>See Also</h3>

<p>Other jam color functions: 
<code><a href="#topic+alpha2col">alpha2col</a>()</code>,
<code><a href="#topic+applyCLrange">applyCLrange</a>()</code>,
<code><a href="#topic+col2alpha">col2alpha</a>()</code>,
<code><a href="#topic+col2hcl">col2hcl</a>()</code>,
<code><a href="#topic+col2hsl">col2hsl</a>()</code>,
<code><a href="#topic+col2hsv">col2hsv</a>()</code>,
<code><a href="#topic+fixYellow">fixYellow</a>()</code>,
<code><a href="#topic+fixYellowHue">fixYellowHue</a>()</code>,
<code><a href="#topic+getColorRamp">getColorRamp</a>()</code>,
<code><a href="#topic+hcl2col">hcl2col</a>()</code>,
<code><a href="#topic+hsl2col">hsl2col</a>()</code>,
<code><a href="#topic+hsv2col">hsv2col</a>()</code>,
<code><a href="#topic+isColor">isColor</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+makeColorDarker">makeColorDarker</a>()</code>,
<code><a href="#topic+rainbow2">rainbow2</a>()</code>,
<code><a href="#topic+rgb2col">rgb2col</a>()</code>,
<code><a href="#topic+setCLranges">setCLranges</a>()</code>,
<code><a href="#topic+setTextContrastColor">setTextContrastColor</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+unalpha">unalpha</a>()</code>,
<code><a href="#topic+warpRamp">warpRamp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># given a list, it returns a list
x &lt;- color2gradient(list(Reds=c("red"), Blues=c("blue")), n=c(4,7));
showColors(x);

# given a vector, it returns a vector
xv &lt;- color2gradient(c(red="red", blue="blue"), n=c(4,7));
showColors(xv);

# Expand colors in place
# This process is similar to color jittering
colors1 &lt;- c("red","blue")[c(1,1,2,2,1,2,1,1)];
names(colors1) &lt;- colors1;
colors2 &lt;- color2gradient(colors1);
showColors(list(`Input colors`=colors1, `Output colors`=colors2));

# You can do the same using a list intermediate
colors1L &lt;- split(colors1, colors1);
showColors(colors1L);
colors2L &lt;- color2gradient(colors1L);
showColors(colors2L);

# comparison of fixed gradientWtFactor with dynamic gradientWtFactor
showColors(list(
   `dynamic\ngradientWtFactor\ndex=1`=color2gradient(
      c("yellow", "navy", "firebrick", "orange"),
      n=3,
      gradientWtFactor=NULL,
      dex=1),
   `dynamic\ngradientWtFactor\ndex=2`=color2gradient(
      c("yellow", "navy", "firebrick", "orange"),
      n=3,
      gradientWtFactor=NULL,
      dex=2),
   `fixed\ngradientWtFactor=2/3`=color2gradient(
      c("yellow", "navy", "firebrick", "orange"),
      n=3,
      gradientWtFactor=2/3,
      dex=1)
))

</code></pre>

<hr>
<h2 id='coordPresets'>Process coordinate adjustment presets</h2><span id='topic+coordPresets'></span>

<h3>Description</h3>

<p>Process coordinate adjustment presets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coordPresets(
  preset = "default",
  x = 0,
  y = 0,
  adjPreset = "default",
  adjX = 0.5,
  adjY = 0.5,
  adjOffsetX = 0,
  adjOffsetY = 0,
  preset_type = c("plot"),
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coordPresets_+3A_preset">preset</code></td>
<td>
<p><code>character</code> vector of coordinate positions, or the default
&quot;default&quot; to use the <code style="white-space: pre;">&#8288;x,y&#8288;</code> coordinates.
</p>

<ul>
<li><p> Recognized terms: center, bottom, top, left, right, topleft,
topright, bottomleft, bottomright.
</p>
</li></ul>
</td></tr>
<tr><td><code id="coordPresets_+3A_x">x</code>, <code id="coordPresets_+3A_y">y</code></td>
<td>
<p><code>numeric</code> vectors indicating the default coordinates <code style="white-space: pre;">&#8288;x,y&#8288;</code>.</p>
</td></tr>
<tr><td><code id="coordPresets_+3A_adjpreset">adjPreset</code></td>
<td>
<p><code>character</code> vector of text label positions, or
the default &quot;default&quot; to use <code>preset</code>, or when <code>preset="default"</code> the
<code style="white-space: pre;">&#8288;adjX,adjY&#8288;</code> values are used.
</p>

<ul>
<li><p> Recognized terms: center, bottom, top, left, right, topleft,
topright, bottomleft, bottomright.
</p>
</li></ul>
</td></tr>
<tr><td><code id="coordPresets_+3A_adjx">adjX</code>, <code id="coordPresets_+3A_adjy">adjY</code></td>
<td>
<p>numeric vectors indicating default text adjustment
values, as described for <code>adj</code> in <code>graphics::text()</code>.</p>
</td></tr>
<tr><td><code id="coordPresets_+3A_adjoffsetx">adjOffsetX</code>, <code id="coordPresets_+3A_adjoffsety">adjOffsetY</code></td>
<td>
<p><code>numeric</code> vector used to apply an offset
value to the <code style="white-space: pre;">&#8288;adjX,adjY&#8288;</code> values, where positive values would
place a label farther away from center. Note these units are
relative to the text label size, when used with <code>graphics::text()</code>,
larger labels will be adjusted more than smaller labels.</p>
</td></tr>
<tr><td><code id="coordPresets_+3A_preset_type">preset_type</code></td>
<td>
<p><code>character</code> string indicating the reference point
for the preset boundaries:
</p>

<ul>
<li> <p><code>"plot"</code> uses the plot border.
</p>
</li>
<li> <p><code>"margin"</code> uses the margin border. Note that the margin used
is the inner margin around the plot figure, not the outer margin
which may be applied around multi-panel plot figures.
</p>
</li></ul>
</td></tr>
<tr><td><code id="coordPresets_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating whether to print verbose output.</p>
</td></tr>
<tr><td><code id="coordPresets_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to be a convenient way to define
coordinates using preset terms like &quot;topleft&quot;, &quot;bottom&quot;, &quot;center&quot;.
</p>
<p>Similarly, it is intended to help define corresponding text
adjustments, using <code>adj</code> compatible with <code>graphics::text()</code>,
using preset terms like &quot;bottomright&quot;, &quot;center&quot;.
</p>
<p>When <code>preset</code> is <code>"default"</code>, the original <code style="white-space: pre;">&#8288;x,y&#8288;</code> coordinates
are used. Otherwise the <code style="white-space: pre;">&#8288;x,y&#8288;</code> coordinates are defined using the
plot region coordinates, where <code>"left"</code> uses <code>graphics::par("usr")[1]</code>,
and <code>"top"</code> uses <code>graphics::par("usr")[4]</code>.
</p>
<p>When <code>adjPreset</code> is <code>"default"</code> it will use the <code>preset</code> to
define a reciprocal text placement. For example when <code>preset="topright"</code>
the text placement will be equivalent to <code>adjPreset="bottomleft"</code>.
The <code>adjPreset</code> terms <code>"top"</code>, <code>"bottom"</code>, <code>"right"</code>, <code>"left"</code>,
and <code>"center"</code> refer to the text label placement relative to
<code style="white-space: pre;">&#8288;x,y&#8288;</code> coordinate.
</p>
<p>If both <code>preset="default"</code> and <code>adjPreset="default"</code> the original
<code style="white-space: pre;">&#8288;adjX,adjY&#8288;</code> values are returned.
</p>
<p>The function is vectorized, and uses the longest input argument,
so one can supply a vector of <code>preset</code> and it will return coordinates
and adjustments of length equal to the input <code>preset</code> vector.
The <code>preset</code> value takes priority over the supplied <code style="white-space: pre;">&#8288;x,y&#8288;</code> coordinates.
</p>


<h3>Value</h3>

<p><code>data.frame</code> after adjustment, where the number of rows
is determined by the longest input argument, with colnames:
</p>

<ul>
<li><p> x
</p>
</li>
<li><p> y
</p>
</li>
<li><p> adjX
</p>
</li>
<li><p> adjY
</p>
</li>
<li><p> preset
</p>
</li>
<li><p> adjPreset
</p>
</li></ul>



<h3>See Also</h3>

<p>Other jam plot functions: 
<code><a href="#topic+adjustAxisLabelMargins">adjustAxisLabelMargins</a>()</code>,
<code><a href="#topic+decideMfrow">decideMfrow</a>()</code>,
<code><a href="#topic+drawLabels">drawLabels</a>()</code>,
<code><a href="#topic+getPlotAspect">getPlotAspect</a>()</code>,
<code><a href="#topic+groupedAxis">groupedAxis</a>()</code>,
<code><a href="#topic+imageByColors">imageByColors</a>()</code>,
<code><a href="#topic+imageDefault">imageDefault</a>()</code>,
<code><a href="#topic+minorLogTicksAxis">minorLogTicksAxis</a>()</code>,
<code><a href="#topic+nullPlot">nullPlot</a>()</code>,
<code><a href="#topic+plotPolygonDensity">plotPolygonDensity</a>()</code>,
<code><a href="#topic+plotRidges">plotRidges</a>()</code>,
<code><a href="#topic+plotSmoothScatter">plotSmoothScatter</a>()</code>,
<code><a href="#topic+shadowText">shadowText</a>()</code>,
<code><a href="#topic+shadowText_options">shadowText_options</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+sqrtAxis">sqrtAxis</a>()</code>,
<code><a href="#topic+usrBox">usrBox</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># determine coordinates
presetV &lt;- c("top",
   "bottom",
   "left",
   "right",
   "topleft");
cp1 &lt;- coordPresets(preset=presetV);
cp1;

# make sure to prepare the plot region first
jamba::nullPlot(plotAreaTitle="");
graphics::points(cp1$x, cp1$y, pch=20, cex=2, col="red");

# unfortunately graphics::text() does not have vectorized adj
# so it must iterate each row
graphics::title(main="graphics::text() is not vectorized, text is adjacent to edges")
for (i in seq_along(presetV)) {
   graphics::text(cp1$x[i], cp1$y[i],
      labels=presetV[i],
      adj=c(cp1$adjX[i], cp1$adjY[i]));
}

# drawLabels() will be vectorized for unique adj subsets
# and adds a small buffer around text
jamba::nullPlot(plotAreaTitle="");
graphics::title(main="drawLabels() is vectorized, includes small buffer")
drawLabels(txt=presetV,
   preset=presetV)

jamba::nullPlot(plotAreaTitle="");
graphics::title(main="drawLabels() can place labels outside plot edges")
drawLabels(txt=presetV,
   preset=presetV,
   adjPreset=presetV)

# drawLabels() is vectorized for example
jamba::nullPlot(plotAreaTitle="");
graphics::title(main="Use adjPreset to position labels at a center point")
presetV2 &lt;- c("topleft",
   "topright",
   "bottomleft",
   "bottomright");
cp2 &lt;- coordPresets(preset="center",
   adjPreset=presetV2,
   adjOffsetX=0.1,
   adjOffsetY=0.4);
graphics::points(cp2$x,
   cp2$y,
   pch=20,
   cex=2,
   col="red");
drawLabels(x=cp2$x,
   y=cp2$y,
   adjX=cp2$adjX,
   adjY=cp2$adjY,
   txt=presetV2,
   boxCexAdjust=c(1.15,1.6),
   labelCex=1.3,
   lx=rep(1.5, 4),
   ly=rep(1.5, 4))

# demonstrate margin coordinates
withr::with_par(list("oma"=c(1, 1, 1, 1)), {
nullPlot(xlim=c(0, 1), ylim=c(1, 5));
cpxy &lt;- coordPresets(rep(c("top", "bottom", "left", "right"), each=2),
   preset_type=rep(c("plot", "figure"), 4));
drawLabels(preset=c("top", "top"),
   txt=c("top label relative to figure",
      "top label relative to plot"),
   preset_type=c("figure", "plot"))
graphics::points(cpxy$x, cpxy$y, cex=2,
   col="red4", bg="red1", xpd=NA,
   pch=rep(c(21, 23), 4))
})

</code></pre>

<hr>
<h2 id='cPaste'>paste a list into a delimited vector</h2><span id='topic+cPaste'></span><span id='topic+cPasteS'></span><span id='topic+cPasteSU'></span><span id='topic+cPasteUnique'></span><span id='topic+cPasteU'></span>

<h3>Description</h3>

<p>Paste a list of vectors into a character vector, with values
delimited by default with a comma.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cPaste(
  x,
  sep = ",",
  doSort = FALSE,
  makeUnique = FALSE,
  na.rm = FALSE,
  keepFactors = FALSE,
  checkClass = TRUE,
  useBioc = TRUE,
  useLegacy = FALSE,
  honorFactor = TRUE,
  verbose = FALSE,
  ...
)

cPasteS(
  x,
  sep = ",",
  doSort = TRUE,
  makeUnique = FALSE,
  na.rm = FALSE,
  keepFactors = FALSE,
  checkClass = TRUE,
  useBioc = TRUE,
  ...
)

cPasteSU(
  x,
  sep = ",",
  doSort = TRUE,
  makeUnique = TRUE,
  na.rm = FALSE,
  keepFactors = FALSE,
  checkClass = TRUE,
  useBioc = TRUE,
  ...
)

cPasteUnique(
  x,
  sep = ",",
  doSort = FALSE,
  makeUnique = TRUE,
  na.rm = FALSE,
  keepFactors = FALSE,
  checkClass = TRUE,
  useBioc = TRUE,
  ...
)

cPasteU(
  x,
  sep = ",",
  doSort = FALSE,
  makeUnique = TRUE,
  na.rm = FALSE,
  keepFactors = FALSE,
  checkClass = TRUE,
  useBioc = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cPaste_+3A_x">x</code></td>
<td>
<p><code>list</code> of vectors</p>
</td></tr>
<tr><td><code id="cPaste_+3A_sep">sep</code></td>
<td>
<p><code>character</code> delimiter used to paste multiple values together</p>
</td></tr>
<tr><td><code id="cPaste_+3A_dosort">doSort</code></td>
<td>
<p><code>logical</code> indicating whether to sort each vector
using <code><a href="#topic+mixedOrder">mixedOrder()</a></code>.</p>
</td></tr>
<tr><td><code id="cPaste_+3A_makeunique">makeUnique</code></td>
<td>
<p><code>logical</code> indicating whether to make each vector in
the input list unique before pasting its values together.</p>
</td></tr>
<tr><td><code id="cPaste_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code> indicating whether to remove NA values from
each vector in the input list. When <code>na.rm</code> is <code>TRUE</code> and a
list element contains only <code>NA</code> values, the resulting string
will be <code>""</code>.</p>
</td></tr>
<tr><td><code id="cPaste_+3A_keepfactors">keepFactors</code></td>
<td>
<p><code>logical</code> only used when <code>useLegacy=TRUE</code> and
<code>doSort=TRUE</code>; indicating whether to preserve factors,
keeping factor level order. When
<code>keepFactors=TRUE</code>, if any list element is a <code>factor</code>, all elements
are converted to factors. Note that this step combines overall
factor levels, and non-factors will be ordered using
<code>base::order()</code> instead of <code>jamba::mixedOrder()</code> (for now.)</p>
</td></tr>
<tr><td><code id="cPaste_+3A_checkclass">checkClass</code></td>
<td>
<p><code>logical</code>, default TRUE, whether to check the class
of each vector in the input list.
</p>

<ul>
<li><p> When TRUE, it confirms the class of each element in the <code>list</code>
before processing, to prevent conversion which may otherwise
lose information.
</p>
</li>
<li><p> For all cases when a known vector is split into a <code>list</code>,
<code>checkClass=FALSE</code> is preferred since there is only one class
in the resulting <code>list</code> elements. This approach is faster
especially for for large input lists, 10000 or more.
</p>
</li>
<li><p> When <code>checkClass=FALSE</code> it assumes all entries can be
coerced to <code>character</code>, which is fastest, but does not preserve
factor levels due to R coersion methods used by <code>unlist()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="cPaste_+3A_usebioc">useBioc</code></td>
<td>
<p><code>logical</code> indicating whether this function should try
to use <code>S4Vectors::unstrsplit()</code> when the Bioconductor package
<code>S4Vectors</code> is installed, otherwise it will use a less
efficient <code>mapply()</code> operation.</p>
</td></tr>
<tr><td><code id="cPaste_+3A_uselegacy">useLegacy</code></td>
<td>
<p><code>logical</code> indicating whether to enable to previous
legacy process used by <code>cPaste()</code>.</p>
</td></tr>
<tr><td><code id="cPaste_+3A_honorfactor">honorFactor</code></td>
<td>
<p><code>logical</code> passed to <code>mixedSorts()</code>, whether any
<code>factor</code> vector should be sorted in factor level order.
When <code>honorFactor=FALSE</code> then even <code>factor</code> vectors are sorted
as if they were <code>character</code> vectors, ignoring the factor levels.</p>
</td></tr>
<tr><td><code id="cPaste_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating whether to print verbose output.</p>
</td></tr>
<tr><td><code id="cPaste_+3A_...">...</code></td>
<td>
<p>additional arguments are passed to <code>mixedOrder()</code> when
<code>doSort=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>cPaste()</code> concatenates vector values using a delimiter.
</p>
</li>
<li> <p><code>cPasteS()</code> sorts each vector using <code>mixedSort()</code>.
</p>
</li>
<li> <p><code>cPasteU()</code> applies <code>uniques()</code> to retain unique values per vector.
</p>
</li>
<li> <p><code>cPasteSU()</code> applies <code>mixedSort()</code> and <code>uniques()</code>.
</p>
</li></ul>

<p>This function is essentially a wrapper for <code>S4Vectors::unstrsplit()</code>
except that it also optionally applies uniqueness to each vector
in the list, and sorts values in each vector using <code>mixedOrder()</code>.
</p>
<p>The sorting and uniqueness is applied to the <code>unlist</code>ed vector of
values, which is substantially faster than any <code>apply</code> family function
equivalent. The uniqueness is performed by <code>uniques()</code>, which itself
will use <code>S4Vectors::unique()</code> if available.
</p>


<h3>Value</h3>

<p><code>character</code> vector with the same names and in the same order
as the input list <code>x</code>.
</p>


<h3>See Also</h3>

<p>Other jam list functions: 
<code><a href="#topic+heads">heads</a>()</code>,
<code><a href="#topic+jam_rapply">jam_rapply</a>()</code>,
<code><a href="#topic+list2df">list2df</a>()</code>,
<code><a href="#topic+mergeAllXY">mergeAllXY</a>()</code>,
<code><a href="#topic+mixedSorts">mixedSorts</a>()</code>,
<code><a href="#topic+rbindList">rbindList</a>()</code>,
<code><a href="#topic+relist_named">relist_named</a>()</code>,
<code><a href="#topic+rlengths">rlengths</a>()</code>,
<code><a href="#topic+sclass">sclass</a>()</code>,
<code><a href="#topic+sdim">sdim</a>()</code>,
<code><a href="#topic+uniques">uniques</a>()</code>,
<code><a href="#topic+unnestList">unnestList</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L1 &lt;- list(CA=LETTERS[c(1:4,2,7,4,6)], B=letters[c(7:11,9,3)]);

cPaste(L1);
#               CA                 B
# "A,B,C,D,B,G,D,F"   "g,h,i,j,k,i,c"

cPaste(L1, doSort=TRUE);
#               CA                 B
# "A,B,B,C,D,D,F,G"   "c,g,h,i,i,j,k"

## The sort can be done with convenience function cPasteS()
cPasteS(L1);
#               CA                 B
# "A,B,B,C,D,D,F,G"   "c,g,h,i,i,j,k"

## Similarly, makeUnique=TRUE and cPasteU() are the same
cPaste(L1, makeUnique=TRUE);
cPasteU(L1);
#           CA             B
# "A,B,C,D,G,F" "g,h,i,j,k,c"

## Change the delimiter
cPasteSU(L1, sep="; ")
#                CA                  B
# "A; B; C; D; F; G" "c; g; h; i; j; k"

# test mix of factor and non-factor
L2 &lt;- c(
   list(D=factor(letters[1:12],
      levels=letters[12:1])),
   L1);
L2;
cPasteSU(L2, keepFactors=TRUE);

# tricky example with mix of character and factor
# and factor levels are inconsistent
# end result: factor levels are defined in order they appear
L &lt;- list(entryA=c("miR-112", "miR-12", "miR-112"),
   entryB=factor(c("A","B","A","B"),
      levels=c("B","A")),
   entryC=factor(c("C","A","B","B","C"),
      levels=c("A","B","C")),
   entryNULL=NULL)
L;
cPaste(L);
cPasteU(L);

# by default keepFactors=FALSE, which means factors are sorted as characters
cPasteS(L);
cPasteSU(L);
# keepFactors=TRUE will keep unique factor levels in the order they appear
# this is the same behavior as unlist(L[c(2,3)]) on a list of factors
cPasteSU(L, keepFactors=TRUE);
levels(unlist(L[c(2,3)]))

</code></pre>

<hr>
<h2 id='dateToDaysOld'>convert date to age in days</h2><span id='topic+dateToDaysOld'></span>

<h3>Description</h3>

<p>convert date to age in days
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dateToDaysOld(testDate, nowDate = Sys.Date(), units = "days", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dateToDaysOld_+3A_testdate">testDate</code></td>
<td>
<p><code>character</code> date recognized by <code>asDate()</code>,
representing the test date.</p>
</td></tr>
<tr><td><code id="dateToDaysOld_+3A_nowdate">nowDate</code></td>
<td>
<p><code>character</code> date recognized by <code>asDate()</code>,
representing the reference date, by default the current day.</p>
</td></tr>
<tr><td><code id="dateToDaysOld_+3A_units">units</code></td>
<td>
<p><code>character</code> indicating the units, as used by
<code>difftime()</code>.</p>
</td></tr>
<tr><td><code id="dateToDaysOld_+3A_...">...</code></td>
<td>
<p>additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer value with the number of calendar days before the
current date, or the <code>nowDate</code> if supplied.
</p>


<h3>See Also</h3>

<p>Other jam date functions: 
<code><a href="#topic+asDate">asDate</a>()</code>,
<code><a href="#topic+getDate">getDate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dateToDaysOld("23aug2007")

</code></pre>

<hr>
<h2 id='decideMfrow'>Decide plot panel rows, columns for graphics::par(mfrow)</h2><span id='topic+decideMfrow'></span>

<h3>Description</h3>

<p>Decide plot panel rows, columns for graphics::par(mfrow)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decideMfrow(
  n,
  method = c("aspect", "wide", "tall"),
  doTest = FALSE,
  xyratio = 1,
  trimExtra = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decideMfrow_+3A_n">n</code></td>
<td>
<p><code>integer</code> number of plot panels</p>
</td></tr>
<tr><td><code id="decideMfrow_+3A_method">method</code></td>
<td>
<p><code>character</code> string indicating the type of layout to favor.
</p>

<dl>
<dt>&quot;aspect&quot;</dt><dd><p>uses the device size and aspect ratio of the plot to try
to maintain roughly square plot panels.</p>
</dd>
<dt>&quot;wide&quot;</dt><dd><p>tries to keep the columns and rows similar, erring on
the side of more columns than rows.</p>
</dd>
<dt>&quot;tall&quot;</dt><dd><p>tries to keep the columns and rows similar, erring on
the side of more rows than columns.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="decideMfrow_+3A_dotest">doTest</code></td>
<td>
<p><code>logical</code> whether to provide a visual test. Note that
<code>n</code> is required as the number of plot panels requested.</p>
</td></tr>
<tr><td><code id="decideMfrow_+3A_xyratio">xyratio</code></td>
<td>
<p><code>numeric</code> default 1, with the desired target x-to-y ratio.
For example, to have plots slightly wider (x width) than tall
(y height), use <code>xyratio=1.3</code>. The observed device aspect ratio
is divided by <code>xyratio</code> to determine the target aspect ratio
of plot panels.</p>
</td></tr>
<tr><td><code id="decideMfrow_+3A_trimextra">trimExtra</code></td>
<td>
<p><code>logical</code> default TRUE, whether to trim blank rows or
columns in the expected layout when it would be entirely blank.
For example, <code>n=4</code> may produce <code>c(3, 2)</code> output to meet the
desired aspect ratio, however with <code>trimExtra=TRUE</code> it would
be reduced to <code>c(2, 2)</code> to minimize unused whitespace.</p>
</td></tr>
<tr><td><code id="decideMfrow_+3A_...">...</code></td>
<td>
<p>additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the recommended rows and columns of panels
to be used in <code>graphics::par("mfrow")</code> with R base plotting. It attempts
to use the device size and plot aspect ratio to keep panels roughly
square. For example, a short-wide device would have more columns of panels
than rows; a tall-thin device would have more rows than columns.
</p>
<p>The <code>doTest=TRUE</code> argument will create <code>n</code> number of
panels with the recommended layout, as a visual example.
</p>
<p>Note this function calls <code>getPlotAspect()</code>,
therefore if no plot device is currently open,
the call to <code>graphics::par()</code> will open a new graphics device.
</p>


<h3>Value</h3>

<p><code>numeric</code> vector length=2, with the recommended number of plot
rows and columns, respectively. It is intended to be used directly
in this form: <code>graphics::par("mfrow"=decideMfrow(n=5))</code>
</p>


<h3>See Also</h3>

<p>Other jam plot functions: 
<code><a href="#topic+adjustAxisLabelMargins">adjustAxisLabelMargins</a>()</code>,
<code><a href="#topic+coordPresets">coordPresets</a>()</code>,
<code><a href="#topic+drawLabels">drawLabels</a>()</code>,
<code><a href="#topic+getPlotAspect">getPlotAspect</a>()</code>,
<code><a href="#topic+groupedAxis">groupedAxis</a>()</code>,
<code><a href="#topic+imageByColors">imageByColors</a>()</code>,
<code><a href="#topic+imageDefault">imageDefault</a>()</code>,
<code><a href="#topic+minorLogTicksAxis">minorLogTicksAxis</a>()</code>,
<code><a href="#topic+nullPlot">nullPlot</a>()</code>,
<code><a href="#topic+plotPolygonDensity">plotPolygonDensity</a>()</code>,
<code><a href="#topic+plotRidges">plotRidges</a>()</code>,
<code><a href="#topic+plotSmoothScatter">plotSmoothScatter</a>()</code>,
<code><a href="#topic+shadowText">shadowText</a>()</code>,
<code><a href="#topic+shadowText_options">shadowText_options</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+sqrtAxis">sqrtAxis</a>()</code>,
<code><a href="#topic+usrBox">usrBox</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># display a test visualization showing 6 panels
withr::with_par(list("mar"=c(2, 2, 2, 2)), {
decideMfrow(n=6, doTest=TRUE);
})

# use a custom target xyratio of plot panels
withr::with_par(list("mar"=c(2, 2, 2, 2)), {
decideMfrow(n=3, xyratio=3, doTest=TRUE);
})

# a manual demonstration creating 6 panels
n &lt;- 6;
withr::with_par(list(
   "mar"=c(2, 2, 2, 2),
   "mfrow"=decideMfrow(n)), {
for(i in seq_len(n)){
   nullPlot(plotAreaTitle=paste("Plot", i));
}
})

</code></pre>

<hr>
<h2 id='deg2rad'>Convert degrees to radians</h2><span id='topic+deg2rad'></span>

<h3>Description</h3>

<p>Convert degrees to radians
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deg2rad(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deg2rad_+3A_x">x</code></td>
<td>
<p><code>numeric</code> vector, expected to be degree values between zero
and 360.</p>
</td></tr>
<tr><td><code id="deg2rad_+3A_...">...</code></td>
<td>
<p>other parameters are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simply converts degrees which range from 0 to 360,
into radians which range from zero to pi*2.
</p>


<h3>Value</h3>

<p><code>numeric</code> vector after coverting degrees to radians.
</p>


<h3>See Also</h3>

<p>Other jam numeric functions: 
<code><a href="#topic+noiseFloor">noiseFloor</a>()</code>,
<code><a href="#topic+normScale">normScale</a>()</code>,
<code><a href="#topic+rad2deg">rad2deg</a>()</code>,
<code><a href="#topic+rowGroupMeans">rowGroupMeans</a>()</code>,
<code><a href="#topic+rowRmMadOutliers">rowRmMadOutliers</a>()</code>,
<code><a href="#topic+warpAroundZero">warpAroundZero</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>deg2rad(rad2deg(c(pi*2, pi/2)))/pi;

</code></pre>

<hr>
<h2 id='drawLabels'>Draw text labels on a base R plot</h2><span id='topic+drawLabels'></span>

<h3>Description</h3>

<p>Draw text labels on a base R plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawLabels(
  txt = NULL,
  newCoords = NULL,
  x = NULL,
  y = NULL,
  lx = NULL,
  ly = NULL,
  segmentLwd = 1,
  segmentCol = "#00000088",
  drawSegments = TRUE,
  boxBorderColor = "#000000AA",
  boxColor = "#FFEECC",
  boxLwd = 1,
  drawBox = TRUE,
  drawLabels = TRUE,
  font = 1,
  labelCex = 0.8,
  boxCexAdjust = 1.9,
  labelCol = alpha2col(alpha = 0.8, setTextContrastColor(boxColor)),
  doPlot = TRUE,
  xpd = NA,
  preset = "default",
  adjPreset = "default",
  preset_type = "plot",
  adjX = 0.5,
  adjY = 0.5,
  panelWidth = "default",
  trimReturns = TRUE,
  text_fn = getOption("jam.text_fn", graphics::text),
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drawLabels_+3A_txt">txt</code></td>
<td>
<p><code>character</code> vector of labels, length equal to <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="drawLabels_+3A_newcoords">newCoords</code></td>
<td>
<p><code>data.frame</code> optional, typically as a result of
a previous call to <code>drawLabels()</code>. In general, it should contain
colnames equivalent to the function parameters of <code>drawLabels()</code>.</p>
</td></tr>
<tr><td><code id="drawLabels_+3A_x">x</code>, <code id="drawLabels_+3A_y">y</code></td>
<td>
<p><code>numeric</code> vector of x- and y- coordinates.</p>
</td></tr>
<tr><td><code id="drawLabels_+3A_lx">lx</code>, <code id="drawLabels_+3A_ly">ly</code></td>
<td>
<p><code>numeric</code> optional vector of segment endpoint coordinates, used
to draw a line from x,y coordinates to the segment lx,ly coordinate.</p>
</td></tr>
<tr><td><code id="drawLabels_+3A_segmentlwd">segmentLwd</code>, <code id="drawLabels_+3A_segmentcol">segmentCol</code></td>
<td>
<p><code>numeric</code> vector of segment line widths,
and <code>character</code> colors, respectively.
Each vector will be recycled to <code>length(txt)</code> as needed.</p>
</td></tr>
<tr><td><code id="drawLabels_+3A_drawsegments">drawSegments</code></td>
<td>
<p><code>logical</code> whether to draw segments, where applicable.</p>
</td></tr>
<tr><td><code id="drawLabels_+3A_boxbordercolor">boxBorderColor</code></td>
<td>
<p><code>character</code> vector of colors used for the
box border around each label.</p>
</td></tr>
<tr><td><code id="drawLabels_+3A_boxcolor">boxColor</code></td>
<td>
<p><code>character</code> vector of colors used for the box background
behind each label.</p>
</td></tr>
<tr><td><code id="drawLabels_+3A_boxlwd">boxLwd</code></td>
<td>
<p><code>numeric</code> vector of box line widths, sent to
<code>graphics::rect()</code>, this vector will be recycled to <code>length(txt)</code>.</p>
</td></tr>
<tr><td><code id="drawLabels_+3A_drawbox">drawBox</code></td>
<td>
<p><code>logical</code> whether to draw boxes behind each text label.</p>
</td></tr>
<tr><td><code id="drawLabels_+3A_drawlabels">drawLabels</code></td>
<td>
<p><code>logical</code> whether to draw each text label.</p>
</td></tr>
<tr><td><code id="drawLabels_+3A_font">font</code></td>
<td>
<p><code>integer</code> vector of font values as described in
<code>graphics::par()</code>, where 1=normal, 2=bold, 3=italics, 4=bold-italics.</p>
</td></tr>
<tr><td><code id="drawLabels_+3A_labelcex">labelCex</code></td>
<td>
<p><code>numeric</code> vector of cex values used for text labels,
recycled to <code>length(txt)</code> as needed.</p>
</td></tr>
<tr><td><code id="drawLabels_+3A_boxcexadjust">boxCexAdjust</code></td>
<td>
<p><code>numeric</code> vector length=2, used to expand the x-width
and y-height of the box around around text labels.</p>
</td></tr>
<tr><td><code id="drawLabels_+3A_labelcol">labelCol</code></td>
<td>
<p><code>character</code> vector of label colors, by default it calls
<code>jamba::setTextContrastColor()</code> to generate a color to contrast
the background box color.</p>
</td></tr>
<tr><td><code id="drawLabels_+3A_doplot">doPlot</code></td>
<td>
<p><code>logical</code> whether to perform any plot operations. Set
<code>FALSE</code> to calculate coordinates and return a <code>data.frame</code> of
label coordinates, which can then be manipulated before calling
<code>drawLabels()</code> again.</p>
</td></tr>
<tr><td><code id="drawLabels_+3A_xpd">xpd</code></td>
<td>
<p><code>logical</code> value compatible with <code>graphics::par("xpd")</code>, where NA allows labels
anywhere in the device region, TRUE retricts labels within the figure
region, and FALSE restricts labels within the plot region.</p>
</td></tr>
<tr><td><code id="drawLabels_+3A_preset">preset</code></td>
<td>
<p><code>character</code> vector passed to <code>coordPresets()</code>
used to position text labels relative
to the x,y coordinate, where &quot;topleft&quot; will position the label so the
entire label box is top-left of the point, therefore the point will be
at the bottom-right corner of the label box. When <code>preset</code> is anything
by <code>"none"</code> the <code>adjX</code> and <code>adjY</code> values are ignored.</p>
</td></tr>
<tr><td><code id="drawLabels_+3A_preset_type">preset_type</code>, <code id="drawLabels_+3A_adjpreset">adjPreset</code></td>
<td>
<p><code>character</code> passed to <code>coordPresets()</code> to
define orientation of each label relative to the <code>x</code>,<code>y</code> coordinate.</p>
</td></tr>
<tr><td><code id="drawLabels_+3A_adjx">adjX</code>, <code id="drawLabels_+3A_adjy">adjY</code></td>
<td>
<p><code>numeric</code> the text adjustment of labels relative to the x,y
coordinate. The values are recycled to <code>length(txt)</code>.</p>
</td></tr>
<tr><td><code id="drawLabels_+3A_panelwidth">panelWidth</code></td>
<td>
<p><code>character</code> string or vector, recycled to the number
of labels to be displayed. The argument indicates whether to size
each label box relative to the plot panel width, intended when
the label <code>preset</code> and <code>adjPreset</code> are set for the label to be inside
the plot panel, e.g. <code style="white-space: pre;">&#8288;preset="top", adjPreset="top"&#8288;</code>, or
<code style="white-space: pre;">&#8288;preset="topleft", adjPreset="topright"&#8288;</code>. Either both are centered,
or one is &quot;right&quot; and the other is &quot;left&quot;. In these cases, the label
box is expanded to the full plot panel width, thus filling the full
visible x-axis range for the plot panel. Allowed values for <code>panelWidth</code>:
</p>

<ul>
<li> <p><code>"default"</code> size label boxes by text dimensions
</p>
</li>
<li> <p><code>"force"</code> size label to full plot panel width
</p>
</li>
<li> <p><code>"minimum"</code> size label at least the plot panel width, or larger if
necessary to fit the text label
</p>
</li>
<li> <p><code>"maximum"</code> size label to the text label width, but no larger than
the plot panel width
</p>
</li></ul>
</td></tr>
<tr><td><code id="drawLabels_+3A_trimreturns">trimReturns</code></td>
<td>
<p><code>logical</code> whether to trim leading and trailing return
(newline) characters from labels.</p>
</td></tr>
<tr><td><code id="drawLabels_+3A_text_fn">text_fn</code></td>
<td>
<p><code>function</code> used to render text, by default it checks
<code>getOption("jam.text_fn", graphics::text)</code> which then defaults
to <code>graphics::text</code>.
</p>

<ul>
<li><p> This argument is specifically to enable <code>jamba::shadowText()</code>,
for example <code>text_fn=jamba::shadowText</code>.
</p>
</li>
<li><p> Previous to version 0.0.107.900, one could assign
<code>text &lt;- jamba::shadowText</code> however that option was removed
to make jamba more compliant with recommended R code, and
ready for CRAN.
</p>
</li></ul>
</td></tr>
<tr><td><code id="drawLabels_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> whether to print verbose output.</p>
</td></tr>
<tr><td><code id="drawLabels_+3A_...">...</code></td>
<td>
<p>additional arguments are passed to <code>graphics::segments()</code> when
segments are drawn, to <code>graphics::rect()</code> when label boxes are drawn,
and to <code>graphics::text()</code> when text labels are drawn.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a vector of coordinates and text labels,
and draws the labels with colored rectangles around each label
on the plot. Each label can have unique font, cex, and color,
and are drawn using vectorized operations.
</p>
<p>To enable shadow text include argument: <code>text_fn=jamba::shadowText</code>
</p>
<p>TODO: In future allow rotated text labels. Not that useful within
a plot panel, but sometimes useful when draw outside a plot, for
example axis labels.
</p>


<h3>Value</h3>

<p>invisible data.frame containing label coordinates used
to draw labels. This data.frame can be manipulated and provided
as input to <code>drawLabels()</code> for subsequent customized label
positioning.
</p>


<h3>See Also</h3>

<p>Other jam plot functions: 
<code><a href="#topic+adjustAxisLabelMargins">adjustAxisLabelMargins</a>()</code>,
<code><a href="#topic+coordPresets">coordPresets</a>()</code>,
<code><a href="#topic+decideMfrow">decideMfrow</a>()</code>,
<code><a href="#topic+getPlotAspect">getPlotAspect</a>()</code>,
<code><a href="#topic+groupedAxis">groupedAxis</a>()</code>,
<code><a href="#topic+imageByColors">imageByColors</a>()</code>,
<code><a href="#topic+imageDefault">imageDefault</a>()</code>,
<code><a href="#topic+minorLogTicksAxis">minorLogTicksAxis</a>()</code>,
<code><a href="#topic+nullPlot">nullPlot</a>()</code>,
<code><a href="#topic+plotPolygonDensity">plotPolygonDensity</a>()</code>,
<code><a href="#topic+plotRidges">plotRidges</a>()</code>,
<code><a href="#topic+plotSmoothScatter">plotSmoothScatter</a>()</code>,
<code><a href="#topic+shadowText">shadowText</a>()</code>,
<code><a href="#topic+shadowText_options">shadowText_options</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+sqrtAxis">sqrtAxis</a>()</code>,
<code><a href="#topic+usrBox">usrBox</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nullPlot(plotAreaTitle="");
dl_topleft &lt;- drawLabels(x=graphics::par("usr")[1],
   y=graphics::par("usr")[4],
   txt="Top-left\nof plot",
   preset="topleft",
   boxColor="blue4");

drawLabels(x=graphics::par("usr")[2],
   y=graphics::par("usr")[3],
   txt="Bottom-right\nof plot",
   preset="bottomright",
   boxColor="green4");

drawLabels(x=mean(graphics::par("usr")[1:2]),
   y=mean(graphics::par("usr")[3:4]),
   txt="Center\nof plot",
   preset="center",
   boxColor="purple3");

graphics::points(x=c(graphics::par("usr")[1], graphics::par("usr")[2],
      mean(graphics::par("usr")[1:2])),
   y=c(graphics::par("usr")[4], graphics::par("usr")[3],
      mean(graphics::par("usr")[3:4])),
   pch=20,
   col="red",
   xpd=NA);

nullPlot(plotAreaTitle="");
graphics::title(main="place label across the full top plot panel", line=2.5)
dl_top &lt;- drawLabels(
   txt=c("preset='topright', adjPreset='topright', \npanelWidth='force'",
      "preset='topright',\nadjPreset='bottomleft'",
      "preset='bottomleft', adjPreset='topright',\npanelWidth='force'"),
   preset=c("topright", "topright", "bottomleft"),
   adjPreset=c("topleft", "bottomleft", "topright"),
   panelWidth=c("force", "none", "force"),
   boxColor=c("red4",
      "blue4",
      "purple3"));
graphics::box(lwd=2);

withr::with_par(list("mfrow"=c(1, 3), "xpd"=TRUE), {

isub &lt;- c(force="Always full panel width",
   minimum="At least full panel width or larger",
   maximum="No larger than panel width");
for (i in c("force", "minimum", "maximum")) {
nullPlot(plotAreaTitle="", doMargins=FALSE);
graphics::title(main=paste0("panelWidth='", i, "'\n",
   isub[i]));
drawLabels(labelCex=1.2,
   txt=c("Super-wide title across the top\npanelWidth='force'",
   "bottom label"),
   preset=c("top", "bottom"),
   panelWidth=i,
   boxColor="red4")
}
})

</code></pre>

<hr>
<h2 id='exp2signed'>exponentiate log2 values with directionality</h2><span id='topic+exp2signed'></span>

<h3>Description</h3>

<p>exponentiate log2 values with directionality
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exp2signed(x, offset = 1, base = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exp2signed_+3A_x">x</code></td>
<td>
<p><code>numeric</code> vector</p>
</td></tr>
<tr><td><code id="exp2signed_+3A_offset">offset</code></td>
<td>
<p><code>numeric</code> subtracted from exponentiated values
prior to multiplying by the <code>sign(x)</code>.</p>
</td></tr>
<tr><td><code id="exp2signed_+3A_base">base</code></td>
<td>
<p><code>numeric</code> value indicating the logarithmic base used.
For example <code>base=2</code> indicates values were transformed using
<code>log2()</code>.</p>
</td></tr>
<tr><td><code id="exp2signed_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the reciprocal to <code>log2signed()</code>.
</p>
<p>It #' exponentiates the absolute values of <code>x</code>,
then subtracts the <code>offset</code>, then multiplies results
by the <code>sign(x)</code>.
</p>
<p>The <code>offset</code> is typically used to maintain
directionality of values during log transformation by
requiring all absolute values to be <code>1</code> or larger, thus
by default <code>offset=1</code>.
</p>


<h3>Value</h3>

<p>numeric vector of exponentiated values.
</p>


<h3>See Also</h3>

<p>Other jam practical functions: 
<code><a href="#topic+breakDensity">breakDensity</a>()</code>,
<code><a href="#topic+call_fn_ellipsis">call_fn_ellipsis</a>()</code>,
<code><a href="#topic+checkLightMode">checkLightMode</a>()</code>,
<code><a href="#topic+check_pkg_installed">check_pkg_installed</a>()</code>,
<code><a href="#topic+colNum2excelName">colNum2excelName</a>()</code>,
<code><a href="#topic+color_dither">color_dither</a>()</code>,
<code><a href="#topic+getAxisLabel">getAxisLabel</a>()</code>,
<code><a href="#topic+isFALSEV">isFALSEV</a>()</code>,
<code><a href="#topic+isTRUEV">isTRUEV</a>()</code>,
<code><a href="#topic+jargs">jargs</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+lldf">lldf</a>()</code>,
<code><a href="#topic+log2signed">log2signed</a>()</code>,
<code><a href="#topic+middle">middle</a>()</code>,
<code><a href="#topic+minorLogTicks">minorLogTicks</a>()</code>,
<code><a href="#topic+newestFile">newestFile</a>()</code>,
<code><a href="#topic+printDebug">printDebug</a>()</code>,
<code><a href="#topic+reload_rmarkdown_cache">reload_rmarkdown_cache</a>()</code>,
<code><a href="#topic+renameColumn">renameColumn</a>()</code>,
<code><a href="#topic+rmInfinite">rmInfinite</a>()</code>,
<code><a href="#topic+rmNA">rmNA</a>()</code>,
<code><a href="#topic+rmNAs">rmNAs</a>()</code>,
<code><a href="#topic+rmNULL">rmNULL</a>()</code>,
<code><a href="#topic+setPrompt">setPrompt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(-100:100)/10;
z &lt;- log2signed(x);
#plot(x=x, y=z, xlab="x", ylab="log2signed(x)")
plot(x=x, y=exp2signed(z), xlab="x", ylab="exp2signed(log2signed(x))")
plot(x=z, y=exp2signed(z), xlab="log2signed(x)", ylab="exp2signed(log2signed(x))")

</code></pre>

<hr>
<h2 id='fillBlanks'>Fill blank entries in a vector</h2><span id='topic+fillBlanks'></span>

<h3>Description</h3>

<p>Fill blank entries in a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fillBlanks(x, blankGrep = c("[ \t]*"), first = "", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fillBlanks_+3A_x">x</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="fillBlanks_+3A_blankgrep">blankGrep</code></td>
<td>
<p>vector of grep patterns, or <code>NA</code>, indicating
the type of entry to be considered blank.
Each <code>blankGrep</code> pattern is searched using <code>jamba::proigrep()</code>, which
by default uses case-insensitive regular expression pattern
matching.</p>
</td></tr>
<tr><td><code id="fillBlanks_+3A_first">first</code></td>
<td>
<p>options character string intended when the first
entry of <code>x</code> is blank. By default <code>""</code> is used.</p>
</td></tr>
<tr><td><code id="fillBlanks_+3A_...">...</code></td>
<td>
<p>additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a character vector and fills any blank (missing)
entries with the last non-blank entry in the vector. It is intended
for situations like imported 'Excel' data, where there may be one
header value representing a series of cells.
</p>
<p>The method used does not loop through the data, and should scale
fairly well with good efficiency even for extremely large vectors.
</p>


<h3>Value</h3>

<p><code>character</code> vector where blank entries are filled with the
most recent non-blank value.
</p>


<h3>See Also</h3>

<p>Other jam string functions: 
<code><a href="#topic+asSize">asSize</a>()</code>,
<code><a href="#topic+breaksByVector">breaksByVector</a>()</code>,
<code><a href="#topic+formatInt">formatInt</a>()</code>,
<code><a href="#topic+gsubOrdered">gsubOrdered</a>()</code>,
<code><a href="#topic+gsubs">gsubs</a>()</code>,
<code><a href="#topic+makeNames">makeNames</a>()</code>,
<code><a href="#topic+nameVector">nameVector</a>()</code>,
<code><a href="#topic+nameVectorN">nameVectorN</a>()</code>,
<code><a href="#topic+padInteger">padInteger</a>()</code>,
<code><a href="#topic+padString">padString</a>()</code>,
<code><a href="#topic+pasteByRow">pasteByRow</a>()</code>,
<code><a href="#topic+pasteByRowOrdered">pasteByRowOrdered</a>()</code>,
<code><a href="#topic+sizeAsNum">sizeAsNum</a>()</code>,
<code><a href="#topic+tcount">tcount</a>()</code>,
<code><a href="#topic+ucfirst">ucfirst</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("A", "", "", "", "B", "C", "", "", NA,
   "D", "", "", "E", "F", "G", "", "");
data.frame(x, fillBlanks(x));

</code></pre>

<hr>
<h2 id='fixYellow'>Fix yellow color</h2><span id='topic+fixYellow'></span>

<h3>Description</h3>

<p>Fix yellow color to be less green than default &quot;yellow&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixYellow(col, Hrange = c(70, 100), Hshift = -20, fixup = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fixYellow_+3A_col">col</code></td>
<td>
<p>R color, either in hex color format or using values from
<code>grDevices::colors()</code>.</p>
</td></tr>
<tr><td><code id="fixYellow_+3A_hrange">Hrange</code></td>
<td>
<p>numeric vector whose range defines the region of hues
to be adjusted. By default hues between 80 and 90 are adjusted. If
NULL, <code>HCL</code> is return unchanged.</p>
</td></tr>
<tr><td><code id="fixYellow_+3A_hshift">Hshift</code></td>
<td>
<p>numeric value length one, used to adjust the hue of colors
within the range <code>Hrange</code>. If NULL, <code>HCL</code> is return unchanged.</p>
</td></tr>
<tr><td><code id="fixYellow_+3A_fixup">fixup</code></td>
<td>
<p><code>logical</code>, default TRUE, whether to apply fixup to
the resulting color, passed to <code>hcl2col()</code></p>
</td></tr>
<tr><td><code id="fixYellow_+3A_...">...</code></td>
<td>
<p>additional arguments are passed to <code>col2hcl()</code>, and
<code>hcl2col()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function &quot;fixes&quot; the color yellow, which by default appears green
especially when darkened. The effect of this function is to make yellows
appear more red, which appears more visibly yellow even when the color
is darkened.
</p>
<p>This function is intended to be tolerant to missing values. For example if
any of the values <code>col</code>, <code>Hrange</code>, or <code>Hshift</code> are length 0, the original
<code>col</code> is returned unchanged.
</p>


<h3>Value</h3>

<p>returns a vector of R colors the same length as input <code>col</code>.
In the event <code>col</code>, <code>Hrange</code>, or <code>Hshift</code> have length 0, or if any
step in the conversion produces length 0, then the
original <code>col</code> is returned.
</p>


<h3>See Also</h3>

<p>Other jam color functions: 
<code><a href="#topic+alpha2col">alpha2col</a>()</code>,
<code><a href="#topic+applyCLrange">applyCLrange</a>()</code>,
<code><a href="#topic+col2alpha">col2alpha</a>()</code>,
<code><a href="#topic+col2hcl">col2hcl</a>()</code>,
<code><a href="#topic+col2hsl">col2hsl</a>()</code>,
<code><a href="#topic+col2hsv">col2hsv</a>()</code>,
<code><a href="#topic+color2gradient">color2gradient</a>()</code>,
<code><a href="#topic+fixYellowHue">fixYellowHue</a>()</code>,
<code><a href="#topic+getColorRamp">getColorRamp</a>()</code>,
<code><a href="#topic+hcl2col">hcl2col</a>()</code>,
<code><a href="#topic+hsl2col">hsl2col</a>()</code>,
<code><a href="#topic+hsv2col">hsv2col</a>()</code>,
<code><a href="#topic+isColor">isColor</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+makeColorDarker">makeColorDarker</a>()</code>,
<code><a href="#topic+rainbow2">rainbow2</a>()</code>,
<code><a href="#topic+rgb2col">rgb2col</a>()</code>,
<code><a href="#topic+setCLranges">setCLranges</a>()</code>,
<code><a href="#topic+setTextContrastColor">setTextContrastColor</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+unalpha">unalpha</a>()</code>,
<code><a href="#topic+warpRamp">warpRamp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>yellows &lt;- vigrep("yellow", grDevices::colors());
fixedYellows &lt;- fixYellow(yellows);
showColors(list(yellows=yellows,
   fixedYellows=fixedYellows));

</code></pre>

<hr>
<h2 id='fixYellowHue'>Fix yellow color hue</h2><span id='topic+fixYellowHue'></span>

<h3>Description</h3>

<p>Fix yellow color hue to be less green than default &quot;yellow&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixYellowHue(HCL, Hrange = c(80, 90), Hshift = -15, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fixYellowHue_+3A_hcl">HCL</code></td>
<td>
<p>numeric matrix with HCL color values, as returned by <code>col2hcl()</code>,
but requiring only one rowname <code>"H"</code> representing the color hue on
a scale of 0 to 360. If input data does not contain numeric values
with rowname &quot;H&quot;, <code>HCL</code> is return unchanged.</p>
</td></tr>
<tr><td><code id="fixYellowHue_+3A_hrange">Hrange</code></td>
<td>
<p>numeric vector whose range defines the region of hues
to be adjusted. By default hues between 80 and 90 are adjusted. If
NULL, <code>HCL</code> is return unchanged.</p>
</td></tr>
<tr><td><code id="fixYellowHue_+3A_hshift">Hshift</code></td>
<td>
<p>numeric value length one, used to adjust the hue of colors
within the range <code>Hrange</code>. If NULL, <code>HCL</code> is return unchanged.</p>
</td></tr>
<tr><td><code id="fixYellowHue_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function &quot;fixes&quot; the color yellow, which by default appears green
especially when darkened. The effect of this function is to make yellows
appear more red, which appears more visibly yellow even when the color
is darkened.
</p>
<p>This function is intended to be tolerant to missing values. For example if
any of the values <code>HCL</code>, <code>Hrange</code>, or <code>Hshift</code> are length 0, the original
<code>HCL</code> is returned unchanged.
</p>


<h3>Value</h3>

<p>returns the input <code>HCL</code> data where rowname <code>"H"</code> has hue values
adjusted accordingly. In the event <code>HCL</code>, <code>Hrange</code>, or <code>Hshift</code> have
length 0, the original <code>HCL</code> is returned. If input data does not
meet the expected format, the input <code>HCL</code> is returned unchanged.
</p>


<h3>See Also</h3>

<p>Other jam color functions: 
<code><a href="#topic+alpha2col">alpha2col</a>()</code>,
<code><a href="#topic+applyCLrange">applyCLrange</a>()</code>,
<code><a href="#topic+col2alpha">col2alpha</a>()</code>,
<code><a href="#topic+col2hcl">col2hcl</a>()</code>,
<code><a href="#topic+col2hsl">col2hsl</a>()</code>,
<code><a href="#topic+col2hsv">col2hsv</a>()</code>,
<code><a href="#topic+color2gradient">color2gradient</a>()</code>,
<code><a href="#topic+fixYellow">fixYellow</a>()</code>,
<code><a href="#topic+getColorRamp">getColorRamp</a>()</code>,
<code><a href="#topic+hcl2col">hcl2col</a>()</code>,
<code><a href="#topic+hsl2col">hsl2col</a>()</code>,
<code><a href="#topic+hsv2col">hsv2col</a>()</code>,
<code><a href="#topic+isColor">isColor</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+makeColorDarker">makeColorDarker</a>()</code>,
<code><a href="#topic+rainbow2">rainbow2</a>()</code>,
<code><a href="#topic+rgb2col">rgb2col</a>()</code>,
<code><a href="#topic+setCLranges">setCLranges</a>()</code>,
<code><a href="#topic+setTextContrastColor">setTextContrastColor</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+unalpha">unalpha</a>()</code>,
<code><a href="#topic+warpRamp">warpRamp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>yellows &lt;- vigrep("yellow", grDevices::colors());
yellowsHCL &lt;- col2hcl(yellows);
fixedYellowsHCL &lt;- fixYellowHue(yellowsHCL);
fixedYellows &lt;- hcl2col(fixedYellowsHCL);
showColors(list(yellows=yellows,
   fixedYellows=fixedYellows));

</code></pre>

<hr>
<h2 id='formatInt'>Format an integer as a string</h2><span id='topic+formatInt'></span>

<h3>Description</h3>

<p>Format an integer as a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatInt(
  x,
  big.mark = ",",
  trim = TRUE,
  forceInteger = TRUE,
  scientific = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formatInt_+3A_x">x</code></td>
<td>
<p><code>numeric</code> vector or matrix</p>
</td></tr>
<tr><td><code id="formatInt_+3A_big.mark">big.mark</code>, <code id="formatInt_+3A_trim">trim</code>, <code id="formatInt_+3A_scientific">scientific</code></td>
<td>
<p>passed to <code>base::format()</code> but
configured with defaults intended for integer values:
</p>

<ul>
<li> <p><code>big.mark=","</code> adds comma between thousands.
</p>
</li>
<li> <p><code>trim=TRUE</code> to trim excess whitespace.
</p>
</li>
<li> <p><code>scientific=FALSE</code> to prevent exponential notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="formatInt_+3A_forceinteger">forceInteger</code></td>
<td>
<p><code>logical</code>, default TRUE, whether to round <code>numeric</code>
to <code>integer</code> prior to calling <code>base::format()</code>.</p>
</td></tr>
<tr><td><code id="formatInt_+3A_...">...</code></td>
<td>
<p>Additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a quick wrapper function around <code>base::format()</code>
to display integer values as text strings. It will also return a
matrix if the input is a matrix.
</p>


<h3>Value</h3>

<p><code>character</code> vector if <code>x</code> is a vector, or if <code>x</code> is a matrix
a matrix will be returned.
</p>


<h3>See Also</h3>

<p>Other jam string functions: 
<code><a href="#topic+asSize">asSize</a>()</code>,
<code><a href="#topic+breaksByVector">breaksByVector</a>()</code>,
<code><a href="#topic+fillBlanks">fillBlanks</a>()</code>,
<code><a href="#topic+gsubOrdered">gsubOrdered</a>()</code>,
<code><a href="#topic+gsubs">gsubs</a>()</code>,
<code><a href="#topic+makeNames">makeNames</a>()</code>,
<code><a href="#topic+nameVector">nameVector</a>()</code>,
<code><a href="#topic+nameVectorN">nameVectorN</a>()</code>,
<code><a href="#topic+padInteger">padInteger</a>()</code>,
<code><a href="#topic+padString">padString</a>()</code>,
<code><a href="#topic+pasteByRow">pasteByRow</a>()</code>,
<code><a href="#topic+pasteByRowOrdered">pasteByRowOrdered</a>()</code>,
<code><a href="#topic+sizeAsNum">sizeAsNum</a>()</code>,
<code><a href="#topic+tcount">tcount</a>()</code>,
<code><a href="#topic+ucfirst">ucfirst</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1234, 1234.56, 1234567.89);
## By default, commas are used for big.mark, and decimal values are hidden
formatInt(x);

## By default, commas are used for big.mark
formatInt(x, forceInteger=FALSE);

</code></pre>

<hr>
<h2 id='getAxisLabel'>Get axis label for minorLogTicks</h2><span id='topic+getAxisLabel'></span>

<h3>Description</h3>

<p>Get axis label for minorLogTicks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAxisLabel(
  i,
  asValues,
  logAxisType = c("normal", "flip", "pvalue"),
  logBase,
  base_limit = 2,
  offset = 0,
  symmetricZero = (offset &gt; 0),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getAxisLabel_+3A_i">i</code></td>
<td>
<p><code>numeric</code> axis value</p>
</td></tr>
<tr><td><code id="getAxisLabel_+3A_asvalues">asValues</code></td>
<td>
<p><code>logical</code> indicating whether the value should be
evaluated.</p>
</td></tr>
<tr><td><code id="getAxisLabel_+3A_logaxistype">logAxisType</code></td>
<td>
<p><code>character</code> string with the type of axis values:
</p>

<ul>
<li> <p><code>"normal"</code>: axis values as-is.
</p>
</li>
<li> <p><code>"flip"</code>: inverted axis values, for example where negative values
should be displayed as negative log-transformed values.
</p>
</li>
<li> <p><code>"pvalue"</code>: for values transformed as <code>-log10(pvalue)</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="getAxisLabel_+3A_logbase">logBase</code></td>
<td>
<p><code>numeric</code> logarithmic base</p>
</td></tr>
<tr><td><code id="getAxisLabel_+3A_base_limit">base_limit</code></td>
<td>
<p><code>numeric</code> value indicating the minimum value that
should be written as an exponential.</p>
</td></tr>
<tr><td><code id="getAxisLabel_+3A_offset">offset</code></td>
<td>
<p><code>numeric</code> value of offset used for log transformation.</p>
</td></tr>
<tr><td><code id="getAxisLabel_+3A_symmetriczero">symmetricZero</code></td>
<td>
<p><code>logical</code> indicating whether negative values
should be displayed as negative log-transformed values.</p>
</td></tr>
<tr><td><code id="getAxisLabel_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to be called internally by
<code>jamba::minorLogTicks()</code>.
</p>


<h3>Value</h3>

<p><code>character</code> or <code>expression</code> axis label as appropriate.
</p>


<h3>See Also</h3>

<p>Other jam practical functions: 
<code><a href="#topic+breakDensity">breakDensity</a>()</code>,
<code><a href="#topic+call_fn_ellipsis">call_fn_ellipsis</a>()</code>,
<code><a href="#topic+checkLightMode">checkLightMode</a>()</code>,
<code><a href="#topic+check_pkg_installed">check_pkg_installed</a>()</code>,
<code><a href="#topic+colNum2excelName">colNum2excelName</a>()</code>,
<code><a href="#topic+color_dither">color_dither</a>()</code>,
<code><a href="#topic+exp2signed">exp2signed</a>()</code>,
<code><a href="#topic+isFALSEV">isFALSEV</a>()</code>,
<code><a href="#topic+isTRUEV">isTRUEV</a>()</code>,
<code><a href="#topic+jargs">jargs</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+lldf">lldf</a>()</code>,
<code><a href="#topic+log2signed">log2signed</a>()</code>,
<code><a href="#topic+middle">middle</a>()</code>,
<code><a href="#topic+minorLogTicks">minorLogTicks</a>()</code>,
<code><a href="#topic+newestFile">newestFile</a>()</code>,
<code><a href="#topic+printDebug">printDebug</a>()</code>,
<code><a href="#topic+reload_rmarkdown_cache">reload_rmarkdown_cache</a>()</code>,
<code><a href="#topic+renameColumn">renameColumn</a>()</code>,
<code><a href="#topic+rmInfinite">rmInfinite</a>()</code>,
<code><a href="#topic+rmNA">rmNA</a>()</code>,
<code><a href="#topic+rmNAs">rmNAs</a>()</code>,
<code><a href="#topic+rmNULL">rmNULL</a>()</code>,
<code><a href="#topic+setPrompt">setPrompt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- log10(c(1, 2, 5, 10, 20, 50, 100, 200, 500))
getAxisLabel(x, asValues=TRUE, logBase=10)

x1exp &lt;- c(1, 2, 3, 4, 5)
plot(1:6, main="exponential values")
for (i in seq_along(x1exp)) {
   text(x=i, y=i + 0.2,
      getAxisLabel(x1exp[i], asValues=FALSE, logBase=10))
}

x1exp &lt;- c(-3:3)
plot(-3:3, main="log2 fold change values")
for (i in seq_along(x1exp)) {
   text(x=i, y=i + 0.3 - 4,
      getAxisLabel(x1exp[i],
         logAxisType="flip",
         asValues=TRUE, logBase=2))
}

x1exp &lt;- c(1, 2, 3, 4, 5)
plot(1:6, main="P-value style")
for (i in seq_along(x1exp)) {
   text(x=i, y=i + 0.2,
      getAxisLabel(x1exp[i],
      logAxisType="pvalue", asValues=FALSE, logBase=10))
}

</code></pre>

<hr>
<h2 id='getColorRamp'>get color ramp by name, color, or function</h2><span id='topic+getColorRamp'></span>

<h3>Description</h3>

<p>get color ramp by name, color, or function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getColorRamp(
  col,
  n = 15,
  trimRamp = c(0, 0),
  gradientN = 15,
  defaultBaseColor = "grey99",
  reverseRamp = FALSE,
  alpha = TRUE,
  gradientWtFactor = NULL,
  dex = 1,
  lens = 0,
  divergent = NULL,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getColorRamp_+3A_col">col</code></td>
<td>
<p>one of the following:
</p>

<ul>
<li> <p><code>character</code> vector of two or more R colors. A color gradient
will be defined using these colors in order with <code>colorRampPalette()</code>.
</p>
</li>
<li> <p><code>character</code> vector length=1 with one R color.
A color gradient is defined from <code>defaultBaseColor</code> to <code>col</code>
using <code>color2gradient()</code>. To adjust the range of light to dark
luminance, use the <code>dex</code> argument, where higher values increase
the range, and lower values decrease the range.
</p>
</li>
<li> <p><code>character</code> vector length=1, with one recognized color ramp name:
any color palette from RColorBrewer, for example
<code>rownames(RColorBrewer::brewer.pal.info())</code>;
any color palette function name from <code>viridisLite</code>.
</p>
</li>
<li> <p><code>character</code> vector length=1, with one color function name,
for example <code>col="rainbow_hcl"</code>. Input is equivalent to supplying
one color <code>function</code>, see below.
</p>
</li>
<li> <p><code>function</code> whose first argument expects <code>integer</code> number of colors
to return, for example <code>col=viridisLite::viridis</code> defines the function
itself as input.
</p>
</li>
<li> <p><code>function</code> derived from <code>circlize::colorRamp2()</code>,  recognized
by having attribute names <code>"breaks"</code> and <code>"colors"</code>. Note that
only the colors are used for the individual color values, not the
break points.
</p>
</li></ul>
</td></tr>
<tr><td><code id="getColorRamp_+3A_n">n</code></td>
<td>
<p><code>integer</code> number of output colors to return, or NULL if
the output should be a color function in the form <code style="white-space: pre;">&#8288;function(n)&#8288;</code>
which returns <code>n</code> colors.</p>
</td></tr>
<tr><td><code id="getColorRamp_+3A_trimramp">trimRamp</code></td>
<td>
<p><code>integer</code> vector, expanded to length=2 as needed,
which defines the number of colors to trim from the beginning
and end of the color vector, respectively. When <code>reverseRamp=TRUE</code>,
the colors are reversed before the trimming is applied.
If the two <code>trimRamp</code> values are not identical, symmetric divergent
color scales will no longer be symmetric.</p>
</td></tr>
<tr><td><code id="getColorRamp_+3A_gradientn">gradientN</code></td>
<td>
<p><code>integer</code> number of colors to expand gradient colors
prior to trimming colors.</p>
</td></tr>
<tr><td><code id="getColorRamp_+3A_defaultbasecolor">defaultBaseColor</code></td>
<td>
<p><code>character</code> vector indicating a color from which to
begin a color gradient, only used when col is a single color.</p>
</td></tr>
<tr><td><code id="getColorRamp_+3A_reverseramp">reverseRamp</code></td>
<td>
<p><code>logical</code> indicating whether to reverse the resulting
color ramp. This value is ignored when a single value is supplied for
col, and where &quot;_r&quot; or &quot;_rev&quot; is detected as a substring at the end
of the character value.</p>
</td></tr>
<tr><td><code id="getColorRamp_+3A_alpha">alpha</code></td>
<td>
<p><code>logical</code> indicating whether to honor alpha transparency
whenever <code>colorRampPalette</code> is called. If colors contain
no alpha transparency, this setting has no effect, otherwise the
alpha value is applied by <code>grDevices::colorRampPalette()</code> using
a linear gradient between each color.</p>
</td></tr>
<tr><td><code id="getColorRamp_+3A_gradientwtfactor">gradientWtFactor</code></td>
<td>
<p><code>numeric</code> value used to expand single color
input to a gradient, using <code>color2gradient()</code>, prior to making
a full gradient to the <code>defaultBaseColor</code>.
Note that <code>dex</code> is the preferred method for adjusting the range
of light to dark for the given color <code>col</code>.</p>
</td></tr>
<tr><td><code id="getColorRamp_+3A_dex">dex</code></td>
<td>
<p><code>numeric</code> darkness expansion factor, used only with input
<code>col</code> is a single color, which is then split into a color gradient
using <code>defaultBaseColor</code> by calling <code>color2gradient()</code>.
The <code>dex</code> factor adjusts the range of dark to light colors,
where higher values for <code>dex</code> increase the range,
making the changes more dramatic.</p>
</td></tr>
<tr><td><code id="getColorRamp_+3A_lens">lens</code>, <code id="getColorRamp_+3A_divergent">divergent</code></td>
<td>
<p>arguments sent to <code>warpRamp()</code> to
apply a warp effect to the color ramp, to compress or expand
the color gradient: <code>lens</code> scales the warp effect, with
positive values compressing colors toward baseline and
negative values expanding colors near baseline; <code>divergent</code>
is a logical indicating whether the middle color is considered
the baseline.</p>
</td></tr>
<tr><td><code id="getColorRamp_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> whether to print verbose output</p>
</td></tr>
<tr><td><code id="getColorRamp_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts a color ramp name, a single color,
a vector of colors, or a function names, and returns a simple
vector of colors of the appropriate length, suitable as input
to a number of plotting functions.
</p>
<p>When <code>n</code> is <code>NULL</code>, this function returns a color function,
wrapped by <code>grDevices::colorRampPalette()</code>. The colors used
are defined by <code>gradientN</code>, so the <code>grDevices::colorRampPalette()</code>
function actually uses a starting palette of <code>gradientN</code> number
of colors.
</p>
<p>When <code>n</code> is an integer greater than <code>0</code>, this function returns
a vector of colors with length <code>n</code>.
</p>
<p>When <code>col</code> is a single color value, a color gradient is created
by appending <code>defaultColorBase</code> to the output of
<code>color2gradient(..., n=3, gradientWtFactor=gradientWtFactor)</code>.
These 4 colors are used as the internal palette before
applying <code>grDevices::colorRampPalette()</code> as appropriate.
In this case, <code>gradientWtFactor</code> is used to adjust the
strength of the color gradient. The intended use is:
<code>getColorRamp("red", n=5)</code>. To remove the leading white
color, use <code>getColorRamp("red", n=5, trimRamp=c(1,0))</code>.
</p>
<p>When <code>col</code> contains multiple color values, they are used
to define a color ramp directly.
</p>
<p>When <code>col</code> is not a color value, it is compared to known color
palettes from <code>RColorBrewer::RColorBrewer</code> and <code>viridisLite</code>,
and will use the corresponding color function or color palette.
</p>
<p>When <code>col</code> refers to a color palette, the suffix <code>"_r"</code> may
be used to reverse the colors. For example,
<code>getColorRamp(col="RdBu_r", n=9)</code> will recognize the
<code>RColorBrewer</code> color palette <code>"RdBu"</code>, and will reverse the colors
to return blue to red, more suitable for heatmaps where
high values associated with heat are colored red,
and low values associated with cold are colored blue.
</p>
<p>The argument <code>reverseRamp=TRUE</code> may be used to reverse the
returned colors.
</p>
<p>Color functions from <code>viridisLite</code> are recognized:
<code>"viridis"</code>, <code>"cividis"</code>, <code>"inferno"</code>, <code>"magma"</code>, <code>"plasma"</code>.
</p>
<p>The argument <code>trimRamp</code> is used to trim colors from the beginning
and end of a color ramp, respectively. This mechanism is useful
to remove the first or last color when those colors may be too
extreme. Note that internally, colors are expanded to length
<code>gradientN</code>, then trimmed, then the corresponding <code>n</code> colors
are returned.
</p>
<p>The <code>trimRamp</code> argument is also useful when returning a color
function, which occurs when <code>n=NULL</code>. In this case, colors are
expanded to length <code>gradientN</code>, then are trimmed using the
values from <code>trimRamp</code>, then the returned function can be used
to create a color ramp of arbitrary length.
</p>
<p>Note that when <code>reverseRamp=TRUE</code>, colors are reversed
before <code>trimRamp</code> is applied.
</p>
<p>By default, alpha transparency will be maintained if supplied in the
input color vector. Most color ramps have no transparency, in which
case transparency can be added after the fact using <code>alpha2col()</code>.
</p>


<h3>Value</h3>

<p><code>character</code> vector of R colors, or when N is NULL,
<code>function</code> sufficient to create R colors.
</p>


<h3>See Also</h3>

<p>Other jam color functions: 
<code><a href="#topic+alpha2col">alpha2col</a>()</code>,
<code><a href="#topic+applyCLrange">applyCLrange</a>()</code>,
<code><a href="#topic+col2alpha">col2alpha</a>()</code>,
<code><a href="#topic+col2hcl">col2hcl</a>()</code>,
<code><a href="#topic+col2hsl">col2hsl</a>()</code>,
<code><a href="#topic+col2hsv">col2hsv</a>()</code>,
<code><a href="#topic+color2gradient">color2gradient</a>()</code>,
<code><a href="#topic+fixYellow">fixYellow</a>()</code>,
<code><a href="#topic+fixYellowHue">fixYellowHue</a>()</code>,
<code><a href="#topic+hcl2col">hcl2col</a>()</code>,
<code><a href="#topic+hsl2col">hsl2col</a>()</code>,
<code><a href="#topic+hsv2col">hsv2col</a>()</code>,
<code><a href="#topic+isColor">isColor</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+makeColorDarker">makeColorDarker</a>()</code>,
<code><a href="#topic+rainbow2">rainbow2</a>()</code>,
<code><a href="#topic+rgb2col">rgb2col</a>()</code>,
<code><a href="#topic+setCLranges">setCLranges</a>()</code>,
<code><a href="#topic+setTextContrastColor">setTextContrastColor</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+unalpha">unalpha</a>()</code>,
<code><a href="#topic+warpRamp">warpRamp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get a gradient using red4
red4 &lt;- getColorRamp("red4");
showColors(getColorRamp(red4));

# make a custom gradient
BuOr &lt;- getColorRamp(c("dodgerblue","grey10","orange"));
showColors(BuOr);
colorList &lt;- list(red4=red4, BuOr=BuOr);

# From RColorBrewer use a brewer name
RdBu &lt;- getColorRamp("RdBu");
RdBu_r &lt;- getColorRamp("RdBu_r");
colorList &lt;- c(colorList, list(RdBu=RdBu, RdBu_r=RdBu_r));
showColors(RdBu);

if (requireNamespace("viridisLite", quietly=TRUE)) {
   viridisV &lt;- getColorRamp("viridis");
   colorList &lt;- c(colorList, list(viridis=viridisV));
}

# for fun, put a few color ramps onto one plot
showColors(colorList, cexCellnote=0.7);

showColors(list(`white background\ncolor='red'`=getColorRamp("red"),
   `black background\ncolor='red'`=getColorRamp("red", defaultBaseColor="black"),
   `white background\ncolor='gold'`=getColorRamp("gold"),
   `black background\ncolor='gold'`=getColorRamp("gold", defaultBaseColor="black")))

</code></pre>

<hr>
<h2 id='getDate'>get simple date string</h2><span id='topic+getDate'></span>

<h3>Description</h3>

<p>get simple date string in the format DDmonYYYY such as 17jul2018.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDate(t = Sys.time(), trim = TRUE, dateFormat = "%d%b%Y", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDate_+3A_t">t</code></td>
<td>
<p>current time in an appropriate class such as <code>"POSIXct"</code>
or <code>"POSIXt"</code>. The default is output of <code>Sys.time()</code>.</p>
</td></tr>
<tr><td><code id="getDate_+3A_trim">trim</code></td>
<td>
<p><code>logical</code> whether to trim the output of <code>format()</code>
in the event that multiple values are sent for argument <code>t</code>.</p>
</td></tr>
<tr><td><code id="getDate_+3A_dateformat">dateFormat</code></td>
<td>
<p><code>character</code> string representing the recognized date
format, by default <code>"DDmmmYYYY"</code>, which recognizes <code>"23aug2007"</code>.</p>
</td></tr>
<tr><td><code id="getDate_+3A_...">...</code></td>
<td>
<p>additional parameters sent to <code>format()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gets the current date in a simplified text string. Use
<code>asDate()</code> to convert back to Date object.
</p>


<h3>Value</h3>

<p><code>character</code> vector with simplified date string
</p>


<h3>See Also</h3>

<p>Other jam date functions: 
<code><a href="#topic+asDate">asDate</a>()</code>,
<code><a href="#topic+dateToDaysOld">dateToDaysOld</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getDate();

</code></pre>

<hr>
<h2 id='getPlotAspect'>Get aspect ratio for coordinates, plot, or device</h2><span id='topic+getPlotAspect'></span>

<h3>Description</h3>

<p>Get aspect ratio for coordinates, plot, or device
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPlotAspect(
  type = c("coords", "plot", "device"),
  parUsr = graphics::par("usr"),
  parPin = graphics::par("pin"),
  parDin = graphics::par("din"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPlotAspect_+3A_type">type</code></td>
<td>
<p><code>character</code> type of aspect ratio to calculate.
</p>

<dl>
<dt>&quot;coords&quot;</dt><dd><p>calculates plot coordinate aspect ratio, which
is helpful for creating proper circular shapes, for example,
where the x-axis and y-axis ranges are very different. Note
that this calculation does also correct for margin sizes.</p>
</dd>
<dt>&quot;plot&quot;</dt><dd><p>calculates plot aspect ratio, based upon the
actual size of the plot, independent of the numeric coordinate
range of the plot. This aspect ratio reflects the relative
visual height and width of the plot area, ignoring margins.</p>
</dd>
<dt>&quot;device&quot;</dt><dd><p>calculates plot aspect ratio, based upon the
complete graphical device, i.e. the full space including all
panels, margins, and plot areas.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="getPlotAspect_+3A_parusr">parUsr</code>, <code id="getPlotAspect_+3A_parpin">parPin</code>, <code id="getPlotAspect_+3A_pardin">parDin</code></td>
<td>
<p><code>numeric</code> values equivalent to their
respective <code>graphics::par()</code> output, from <code>graphics::par("usr")</code>,
<code>graphics::par("pin")</code>, and <code>graphics::par("din")</code>. Values can be
supplied directly, which among other things, prevents opening a
graphical device if one is not already opened. Any call to
<code>graphics::par()</code> will otherwise cause a graphic device to be opened,
which may not be desired on a headless R server.</p>
</td></tr>
<tr><td><code id="getPlotAspect_+3A_...">...</code></td>
<td>
<p>additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code> plot aspect ratio for a plot device, of the requested
type, see the <code>type</code> argument.
</p>


<h3>See Also</h3>

<p>Other jam plot functions: 
<code><a href="#topic+adjustAxisLabelMargins">adjustAxisLabelMargins</a>()</code>,
<code><a href="#topic+coordPresets">coordPresets</a>()</code>,
<code><a href="#topic+decideMfrow">decideMfrow</a>()</code>,
<code><a href="#topic+drawLabels">drawLabels</a>()</code>,
<code><a href="#topic+groupedAxis">groupedAxis</a>()</code>,
<code><a href="#topic+imageByColors">imageByColors</a>()</code>,
<code><a href="#topic+imageDefault">imageDefault</a>()</code>,
<code><a href="#topic+minorLogTicksAxis">minorLogTicksAxis</a>()</code>,
<code><a href="#topic+nullPlot">nullPlot</a>()</code>,
<code><a href="#topic+plotPolygonDensity">plotPolygonDensity</a>()</code>,
<code><a href="#topic+plotRidges">plotRidges</a>()</code>,
<code><a href="#topic+plotSmoothScatter">plotSmoothScatter</a>()</code>,
<code><a href="#topic+shadowText">shadowText</a>()</code>,
<code><a href="#topic+shadowText_options">shadowText_options</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+sqrtAxis">sqrtAxis</a>()</code>,
<code><a href="#topic+usrBox">usrBox</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>withr::with_par(list("mfrow"=c(2, 4), "mar"=c(1, 1, 1, 1)), {
for (i in 1:8) {
   nullPlot(plotAreaTitle=paste("Plot", i), xlim=c(1,100), ylim=c(1,10),
      doMargins=FALSE);
   graphics::axis(1, las=2);
   graphics::axis(2, las=2);
}
# device aspect inside the 2x4 layout
getPlotAspect("plot");
})
# device aspect outside the 2x4 layout
getPlotAspect("plot");

</code></pre>

<hr>
<h2 id='grepls'>Search for objects in the environment</h2><span id='topic+grepls'></span>

<h3>Description</h3>

<p>Search for objects in the environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grepls(
  x,
  where = "all",
  ignore.case = TRUE,
  searchNames = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grepls_+3A_x">x</code></td>
<td>
<p><code>character</code> string used as a grep pattern</p>
</td></tr>
<tr><td><code id="grepls_+3A_where">where</code></td>
<td>
<p><code>character</code> string compatible with <code>base::ls()</code> or if
installed, <code>AnnotationDbi::ls()</code>. A special value <code>"all"</code> will
search all environments on the search path <code>base::search()</code>
in order.</p>
</td></tr>
<tr><td><code id="grepls_+3A_ignore.case">ignore.case</code></td>
<td>
<p><code>logical</code> indicating whether the pattern match
is case-insensitive.</p>
</td></tr>
<tr><td><code id="grepls_+3A_searchnames">searchNames</code></td>
<td>
<p><code>logical</code> indicating whether names should also
be searched, which is only relevant for <code>AnnDb</code> objects,
for example <code>org.Mm.egSYMBOL2EG</code> from the <code>org.Mm.eg.db</code>
Bioconductor package.</p>
</td></tr>
<tr><td><code id="grepls_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating whether to print verbose output.</p>
</td></tr>
<tr><td><code id="grepls_+3A_...">...</code></td>
<td>
<p>additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function searches the active R environment for an object name
using <code>vigrep()</code> (value, case-insensitive grep).
It is helpful when trying to find an object using a
substring, for example <code>grepls("statshits")</code>.
</p>


<h3>Value</h3>

<p><code>character</code> vector of matching object names, or if
<code>where="all"</code> it returns a named list
whose names indicate the search environment name, and whose
entries are matching object names within each environment.
</p>


<h3>See Also</h3>

<p>Other jam grep functions: 
<code><a href="#topic+igrep">igrep</a>()</code>,
<code><a href="#topic+igrepHas">igrepHas</a>()</code>,
<code><a href="#topic+igrepl">igrepl</a>()</code>,
<code><a href="#topic+provigrep">provigrep</a>()</code>,
<code><a href="#topic+unigrep">unigrep</a>()</code>,
<code><a href="#topic+unvigrep">unvigrep</a>()</code>,
<code><a href="#topic+vgrep">vgrep</a>()</code>,
<code><a href="#topic+vigrep">vigrep</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find all objects named "grep", which should find
# base grep() and jamba::vigrep() among other results.
grepls("grep");

# Find objects in the local environment
allStatsHits &lt;- c(1:12);
someStatsHits &lt;- c(1:3);
grepls("statshits");
# shortcut way to search only the .GlobalEnv, the active local environment
grepls("statshits", 1);

# return objects with "raw" in the name
grepls("raw");

# Require "Raw" to be case-sensitive
grepls("Raw", ignore.case=FALSE)

</code></pre>

<hr>
<h2 id='groupedAxis'>Draw grouped axis labels</h2><span id='topic+groupedAxis'></span>

<h3>Description</h3>

<p>Draw grouped axis labels given a character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupedAxis(
  side = 1,
  x,
  group_style = c("partial_grouped", "grouped", "centered"),
  las = 2,
  returnFractions = TRUE,
  nudge = 0.2,
  do_abline = FALSE,
  abline_lty = "solid",
  abline_col = "grey40",
  do_plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="groupedAxis_+3A_side">side</code></td>
<td>
<p><code>integer</code> indicating the axis side, passed to <code>graphics::axis()</code>.
1=bottom, 2=left, 3=top, 4=right.</p>
</td></tr>
<tr><td><code id="groupedAxis_+3A_x">x</code></td>
<td>
<p><code>character</code> vector of axis labels</p>
</td></tr>
<tr><td><code id="groupedAxis_+3A_group_style">group_style</code></td>
<td>
<p><code>character</code> string indicating the style of label:
</p>

<ul>
<li> <p><code>"partial_grouped"</code> - uses square bracket to bound 2+ repeated entries,
and single line tick mark for non-repeated entries.
</p>
</li>
<li> <p><code>"grouped"</code> - uses square bracket to bound each set of repeated entries
including non-repeated entries.
</p>
</li>
<li> <p><code>"centered"</code> - only labels the center of each group of repeated entries
with no bracket bounding the entries.
</p>
</li></ul>
</td></tr>
<tr><td><code id="groupedAxis_+3A_las">las</code></td>
<td>
<p><code>integer</code> indicating whether labels should be perpendicular,
see <code>graphics::par("las")</code>.</p>
</td></tr>
<tr><td><code id="groupedAxis_+3A_returnfractions">returnFractions</code></td>
<td>
<p><code>logical</code> passed to <code>breaksByVector()</code> to calculate
label positions. Set <code>returnFractions=FALSE</code> and all labels will only
appear at integer locations on the axis.</p>
</td></tr>
<tr><td><code id="groupedAxis_+3A_nudge">nudge</code></td>
<td>
<p><code>numeric</code> adjustment for labels away from the plot border.</p>
</td></tr>
<tr><td><code id="groupedAxis_+3A_do_abline">do_abline</code></td>
<td>
<p><code>logical</code> indicating whether to draw <code>graphics::abline()</code> lines
inside the plot to indicate the exact breakpoints between each group
of labels.</p>
</td></tr>
<tr><td><code id="groupedAxis_+3A_abline_lty">abline_lty</code></td>
<td>
<p>line type compatible with <code>graphics::par("lty")</code>, used when
<code>do_abline=TRUE</code>.</p>
</td></tr>
<tr><td><code id="groupedAxis_+3A_abline_col">abline_col</code></td>
<td>
<p><code>character</code> color used when <code>do_abline=TRUE</code>.</p>
</td></tr>
<tr><td><code id="groupedAxis_+3A_do_plot">do_plot</code></td>
<td>
<p><code>logical</code> whether to plot the resulting axis,
as an option to suppress the output and do something else
with the <code>data.frame</code> of coordinates returned by this function.</p>
</td></tr>
<tr><td><code id="groupedAxis_+3A_...">...</code></td>
<td>
<p>additional arguments are passed to <code>breaksByVector()</code>, and/or to
<code>graphics::axis()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extends <code>breaksByVector()</code> specifically for
axis labels. It is intended where character labels are spaced
at integer steps, and some labels are expected to be repeated.
</p>


<h3>Value</h3>

<p><code>data.frame</code> invisibly, which contains the relevant axis
coordinates, labels, and whether the coordinate should
appear with a tick mark.
</p>


<h3>See Also</h3>

<p>Other jam plot functions: 
<code><a href="#topic+adjustAxisLabelMargins">adjustAxisLabelMargins</a>()</code>,
<code><a href="#topic+coordPresets">coordPresets</a>()</code>,
<code><a href="#topic+decideMfrow">decideMfrow</a>()</code>,
<code><a href="#topic+drawLabels">drawLabels</a>()</code>,
<code><a href="#topic+getPlotAspect">getPlotAspect</a>()</code>,
<code><a href="#topic+imageByColors">imageByColors</a>()</code>,
<code><a href="#topic+imageDefault">imageDefault</a>()</code>,
<code><a href="#topic+minorLogTicksAxis">minorLogTicksAxis</a>()</code>,
<code><a href="#topic+nullPlot">nullPlot</a>()</code>,
<code><a href="#topic+plotPolygonDensity">plotPolygonDensity</a>()</code>,
<code><a href="#topic+plotRidges">plotRidges</a>()</code>,
<code><a href="#topic+plotSmoothScatter">plotSmoothScatter</a>()</code>,
<code><a href="#topic+shadowText">shadowText</a>()</code>,
<code><a href="#topic+shadowText_options">shadowText_options</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+sqrtAxis">sqrtAxis</a>()</code>,
<code><a href="#topic+usrBox">usrBox</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>withr::with_par(list("mar"=c(4,4,6,6)), {
b &lt;- rep(LETTERS[1:5], c(2,3,5,4,3));
b2 &lt;- c(b[1:2], makeNames(b[3:5]), b[6:16]);
nullPlot(doBoxes=FALSE,
   doUsrBox=TRUE,
   xlim=c(0,18),
   ylim=c(0,18));

groupedAxis(1, b);
groupedAxis(2, b, group_style="grouped");
groupedAxis(2, b, group_style="centered");
groupedAxis(3, b2, do_abline=TRUE);
groupedAxis(4, b2, group_style="grouped");
graphics::mtext(side=1, "group_style='partial_grouped'", line=2, las=0);
graphics::mtext(side=2, "group_style='grouped'", line=2, las=0);
graphics::mtext(side=3, "group_style='partial_grouped'", line=2, las=0);
graphics::mtext(side=4, "group_style='grouped'", line=2, las=0);
})

</code></pre>

<hr>
<h2 id='gsubOrdered'>Global substitution into ordered factor</h2><span id='topic+gsubOrdered'></span>

<h3>Description</h3>

<p>Global substitution into ordered factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsubOrdered(
  pattern,
  replacement,
  x,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE,
  sortFunc = mixedSort,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gsubOrdered_+3A_pattern">pattern</code>, <code id="gsubOrdered_+3A_replacement">replacement</code>, <code id="gsubOrdered_+3A_x">x</code>, <code id="gsubOrdered_+3A_ignore.case">ignore.case</code>, <code id="gsubOrdered_+3A_perl">perl</code>, <code id="gsubOrdered_+3A_fixed">fixed</code>, <code id="gsubOrdered_+3A_usebytes">useBytes</code></td>
<td>
<p>arguments sent to <code>base::gsub()</code></p>
</td></tr>
<tr><td><code id="gsubOrdered_+3A_sortfunc">sortFunc</code></td>
<td>
<p>function used to sort factor levels, which
is not performed if the input <code>x</code> is a <code>factor</code>.</p>
</td></tr>
<tr><td><code id="gsubOrdered_+3A_...">...</code></td>
<td>
<p>additional arguments are passed to <code>sortFunc</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an extension of <code>base::gsub()</code> that
returns an ordered factor output. When input is also a
factor, the output factor levels are retained in the
same order, after applying the string substitution.
</p>
<p>This function is very useful when making changes via <code>base::gsub()</code>
to a factor with ordered levels, because it retains the
the order of levels after modification.
</p>
<p>Tips:
</p>

<ul>
<li><p> To convert a character vector to a factor, whose levels are
sorted, use <code>sortFunc=sort</code>.
</p>
</li>
<li><p> To convert a character vector to a factor, whose levels are
the order they appear in the input <code>x</code>, use <code>sortFunc=c</code>.
</p>
</li>
<li><p> To convert a character vector to a factor, whose levels are
sorted alphanumerically, use <code>sortFunc=mixedSort</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>factor whose levels are based upon the order of
input levels when the input <code>x</code> is a factor; or if the
input <code>x</code> is not a factor, it is converted to a factor
using the provided sort function <code>sortFunc</code>.
</p>


<h3>See Also</h3>

<p>Other jam string functions: 
<code><a href="#topic+asSize">asSize</a>()</code>,
<code><a href="#topic+breaksByVector">breaksByVector</a>()</code>,
<code><a href="#topic+fillBlanks">fillBlanks</a>()</code>,
<code><a href="#topic+formatInt">formatInt</a>()</code>,
<code><a href="#topic+gsubs">gsubs</a>()</code>,
<code><a href="#topic+makeNames">makeNames</a>()</code>,
<code><a href="#topic+nameVector">nameVector</a>()</code>,
<code><a href="#topic+nameVectorN">nameVectorN</a>()</code>,
<code><a href="#topic+padInteger">padInteger</a>()</code>,
<code><a href="#topic+padString">padString</a>()</code>,
<code><a href="#topic+pasteByRow">pasteByRow</a>()</code>,
<code><a href="#topic+pasteByRowOrdered">pasteByRowOrdered</a>()</code>,
<code><a href="#topic+sizeAsNum">sizeAsNum</a>()</code>,
<code><a href="#topic+tcount">tcount</a>()</code>,
<code><a href="#topic+ucfirst">ucfirst</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(paste0(
   rep(c("first", "second", "third"), 2),
   rep(c("Section", "Choice"), each=3)),
   "Choice");
f &lt;- factor(x, levels=x);
f;

# default gsub() will return a character vector
gsub("(first|second|third)", "", f)
# converting to factor resets the factor level order
factor(gsub("(first|second|third)", "", f))

## gsubOrdered() maintains the factor level order
gsubOrdered("(first|third)", "", f)
gsubOrdered("(first)", "", f)

# to convert character vector to factor, levels in order they appear
gsubOrdered("", "", x, sortFunc=c)

# to convert character vector to factor, levels alphanumeric sorted
gsubOrdered("", "", x, sortFunc=mixedSort)

</code></pre>

<hr>
<h2 id='gsubs'>Pattern replacement with multiple patterns</h2><span id='topic+gsubs'></span>

<h3>Description</h3>

<p>Pattern replacement with multiple patterns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsubs(
  pattern,
  replacement,
  x,
  ignore.case = TRUE,
  replaceMultiple = rep(TRUE, length(pattern)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gsubs_+3A_pattern">pattern</code></td>
<td>
<p><code>character</code> vector of patterns</p>
</td></tr>
<tr><td><code id="gsubs_+3A_replacement">replacement</code></td>
<td>
<p><code>character</code> vector of replacements</p>
</td></tr>
<tr><td><code id="gsubs_+3A_x">x</code></td>
<td>
<p><code>character</code> vector with input data to be curated</p>
</td></tr>
<tr><td><code id="gsubs_+3A_ignore.case">ignore.case</code></td>
<td>
<p><code>logical</code> indicating whether to perform
pattern matching in case-insensitive manner, where
<code>ignore.case=TRUE</code> will ignore the uppercase/lowercase
distinction.</p>
</td></tr>
<tr><td><code id="gsubs_+3A_replacemultiple">replaceMultiple</code></td>
<td>
<p><code>logical</code> vector indicating whether to perform
global substitution, where <code>replaceMultiple=FALSE</code> will
only replace the first occurrence of the pattern, using
<code>base::sub()</code>. Note that this vector can refer to individual
entries in <code>pattern</code>.</p>
</td></tr>
<tr><td><code id="gsubs_+3A_...">...</code></td>
<td>
<p>additional arguments are passed to <code>base::gsub()</code>
or <code>base::sub()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a simple wrapper around <code>base::gsub()</code>
when considering a series of pattern-replacement
combinations. It applies each pattern match and replacement
in order and is therefore not vectorized.
</p>
<p>When <code>x</code> input is a <code>list</code> each vector in the <code>list</code> is processed,
somewhat differently than processing one vector.
</p>

<ol>
<li><p> When the <code>list</code> contains another <code>list</code>, or when <code>length(x) &lt; 100</code>,
each value in <code>x</code> is iterated calling <code>gsubs()</code>.
This process is the slowest option, however not noticeble until
<code>x</code> has length over 10,000.
</p>
</li>
<li><p> When the <code>list</code> does not contain another <code>list</code> and all values are
non-factor, or all values are <code>factor</code>, they are unlisted,
processed as a vector, then relisted. This process is nearly the
same speed as processing one single vector, except the time it
takes to confirm the list element classes.
</p>
</li>
<li><p> When values contain a mix of non-factor and <code>factor</code> values, they
are separately unlisted, processed by <code>gsubs()</code>, then relisted
and combined afterward. Again, this process is only slightly slower
than option 2 above, given that it calls <code>gsubs()</code> twice, with two
vectors.
</p>
</li>
<li><p> Note that <code>factor</code> values at input are
replaced with <code>character</code> values at output, consistent with <code>gsub()</code>.
</p>
</li></ol>



<h3>Value</h3>

<p><code>character</code> vector when input <code>x</code> is an atomic vector,
or <code>list</code> when input <code>x</code> is a <code>list</code>.
</p>


<h3>See Also</h3>

<p>Other jam string functions: 
<code><a href="#topic+asSize">asSize</a>()</code>,
<code><a href="#topic+breaksByVector">breaksByVector</a>()</code>,
<code><a href="#topic+fillBlanks">fillBlanks</a>()</code>,
<code><a href="#topic+formatInt">formatInt</a>()</code>,
<code><a href="#topic+gsubOrdered">gsubOrdered</a>()</code>,
<code><a href="#topic+makeNames">makeNames</a>()</code>,
<code><a href="#topic+nameVector">nameVector</a>()</code>,
<code><a href="#topic+nameVectorN">nameVectorN</a>()</code>,
<code><a href="#topic+padInteger">padInteger</a>()</code>,
<code><a href="#topic+padString">padString</a>()</code>,
<code><a href="#topic+pasteByRow">pasteByRow</a>()</code>,
<code><a href="#topic+pasteByRowOrdered">pasteByRowOrdered</a>()</code>,
<code><a href="#topic+sizeAsNum">sizeAsNum</a>()</code>,
<code><a href="#topic+tcount">tcount</a>()</code>,
<code><a href="#topic+ucfirst">ucfirst</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gsubs(c("one", "two"), c("three", "four"), "one two five six")
gsubs(c("one", "two"), c("three"), "one two five six")

</code></pre>

<hr>
<h2 id='handleArgsText'>Handle function arguments as text</h2><span id='topic+handleArgsText'></span>

<h3>Description</h3>

<p>Handles a list or list of lists, converting to human-readable text format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handleArgsText(
  argTextA,
  name = "",
  col1 = "mediumpurple2",
  col2 = "mediumaquamarine",
  colT = "dodgerblue3",
  colF = "red1",
  colNULL = "grey60",
  lightMode = NULL,
  Crange = getOption("jam.Crange"),
  Lrange = getOption("jam.Lrange"),
  adjustRgb = getOption("jam.adjustRgb"),
  indent = "",
  useCollapseList = ",\n      ",
  useCollapseBase = ", ",
  level = 1,
  debug = 0,
  useColor = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="handleArgsText_+3A_argtexta">argTextA</code></td>
<td>
<p>object passed by <code>jargs()</code> when iteratively parsing
function argument values.</p>
</td></tr>
<tr><td><code id="handleArgsText_+3A_name">name</code></td>
<td>
<p><code>character</code> name of the argument.</p>
</td></tr>
<tr><td><code id="handleArgsText_+3A_col1">col1</code>, <code id="handleArgsText_+3A_col2">col2</code>, <code id="handleArgsText_+3A_colt">colT</code>, <code id="handleArgsText_+3A_colf">colF</code>, <code id="handleArgsText_+3A_colnull">colNULL</code></td>
<td>
<p><code>character</code> colors used as defaults
for first and second arguments, TRUE, FALSE, NULL, respectively.</p>
</td></tr>
<tr><td><code id="handleArgsText_+3A_lightmode">lightMode</code></td>
<td>
<p><code>logical</code> or <code>NULL</code>, indicating whether the text background
color is light, thus imposing a maximum brightness for colors displayed.
It use lightMode if defined by the function caller, otherwise it will
use <code>getOption("jam.lightMode")</code> if defined, lastly it will attempt to
detect whether running inside Rstudio by checking the environment variable
&quot;RSTUDIO&quot;, and if so it will assume lightMode==TRUE.</p>
</td></tr>
<tr><td><code id="handleArgsText_+3A_crange">Crange</code></td>
<td>
<p><code>numeric</code> range of chroma values, ranging
between 0 and 100. When NULL, default values will be
assigned to Crange by <code>setCLranges()</code>.</p>
</td></tr>
<tr><td><code id="handleArgsText_+3A_lrange">Lrange</code></td>
<td>
<p><code>numeric</code> range of luminance values, ranging
between 0 and 100. When NULL, default values will be
assigned to Lrange by <code>setCLranges()</code>.</p>
</td></tr>
<tr><td><code id="handleArgsText_+3A_adjustrgb">adjustRgb</code></td>
<td>
<p><code>numeric</code> value adjustment used during the conversion of
RGB colors to ANSI colors, which is inherently lossy. If not defined,
it uses the default returned by <code>setCLranges()</code> which itself uses
<code>getOption("jam.adjustRgb")</code> with default=0. In order to boost
color contrast, an alternate value of -0.1 is suggested.</p>
</td></tr>
<tr><td><code id="handleArgsText_+3A_indent">indent</code></td>
<td>
<p><code>character</code> string used as a prefix in output to help
apply text indent.</p>
</td></tr>
<tr><td><code id="handleArgsText_+3A_usecollapselist">useCollapseList</code></td>
<td>
<p><code>character</code> string inserted between multiple values
to split list entries across multiple lines.</p>
</td></tr>
<tr><td><code id="handleArgsText_+3A_usecollapsebase">useCollapseBase</code></td>
<td>
<p><code>character</code> string used to separate multiple
values in a vector which is not split across multiple lines.</p>
</td></tr>
<tr><td><code id="handleArgsText_+3A_level">level</code></td>
<td>
<p><code>integer</code> indicating the level of depth in iterative parsing.</p>
</td></tr>
<tr><td><code id="handleArgsText_+3A_debug">debug</code></td>
<td>
<p><code>integer</code> value, greater than 0 will cause debug-type verbose
output, useful because parameters are hard!</p>
</td></tr>
<tr><td><code id="handleArgsText_+3A_usecolor">useColor</code></td>
<td>
<p><code>logical</code> whether to display results in color, if the crayon
package is available, and terminal console is capable.</p>
</td></tr>
<tr><td><code id="handleArgsText_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> whether to print verbose output.</p>
</td></tr>
<tr><td><code id="handleArgsText_+3A_...">...</code></td>
<td>
<p>Additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a rare non-exported function intended to be called by
<code>jargs()</code>, but separated in order to help isolate the logical
steps required.
</p>


<h3>Value</h3>

<p><code>character</code> vector including ANSI coloring when available.
</p>


<h3>See Also</h3>

<p>Other jam internal functions: 
<code><a href="#topic+jamCalcDensity">jamCalcDensity</a>()</code>,
<code><a href="#topic+make_html_styles">make_html_styles</a>()</code>,
<code><a href="#topic+make_styles">make_styles</a>()</code>,
<code><a href="#topic+smoothScatterJam">smoothScatterJam</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cat(paste0(handleArgsText(formals(graphics::hist.default)), "\n"), sep="")

</code></pre>

<hr>
<h2 id='hcl2col'>convert HCL to R color</h2><span id='topic+hcl2col'></span>

<h3>Description</h3>

<p>Convert an HCL color matrix to vector of R hex colors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hcl2col(
  x = NULL,
  H = NULL,
  C = NULL,
  L = NULL,
  ceiling = 255,
  maxColorValue = 255,
  alpha = NULL,
  fixup = TRUE,
  model = getOption("jam.model", c("hcl", "polarLUV", "polarLAB")),
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hcl2col_+3A_x">x</code></td>
<td>
<p>matrix of colors, with rownames <code>"H"</code>, <code>"C"</code>, <code>"L"</code>, or if not
supplied it looks for vectors <code>H</code>, <code>C</code>, and <code>L</code> accordingly. It can
alternatively be supplied as an object of class <code>polarLUV</code>.</p>
</td></tr>
<tr><td><code id="hcl2col_+3A_h">H</code>, <code id="hcl2col_+3A_c">C</code>, <code id="hcl2col_+3A_l">L</code></td>
<td>
<p>numeric vectors supplied as an alternative to <code>x</code>, with
ranges 0 to 360, 0 to 100, and 0 to 100, respectively.</p>
</td></tr>
<tr><td><code id="hcl2col_+3A_ceiling">ceiling</code></td>
<td>
<p>numeric value indicating the maximum values allowed for
<code>R</code>, <code>G</code>, and <code>B</code> after conversion by <code>colorspace::as(x, "RGB")</code>.
This ceiling is applied after the <code>maxColorValue</code> is used to scale
numeric values, and is intended to correct for the occurrence of
values above 255, which would be outside the typical color gamut
allowed for RGB colors used in R. In general, this value should not
be modified.</p>
</td></tr>
<tr><td><code id="hcl2col_+3A_maxcolorvalue">maxColorValue</code></td>
<td>
<p>numeric value indicating the maximum RGB values,
typically scaling values to a range of 0 to 255, from the default
returned range of 0 to 1. In general, this value should not be
modified.</p>
</td></tr>
<tr><td><code id="hcl2col_+3A_alpha">alpha</code></td>
<td>
<p>optional vector of alpha values. If not supplied, and if
<code>x</code> is supplied as a matrix with rowname <code>"alpha"</code>, then values will
be used from <code>x["alpha",]</code>.</p>
</td></tr>
<tr><td><code id="hcl2col_+3A_fixup">fixup</code></td>
<td>
<p>boolean indicating whether to use
<code>colorspace::hex(...,fixup=TRUE)</code> for conversion to R hex colors,
<strong>which is not recommended</strong> since this conversion applies some
unknown non-linear transformation for colors outside the color gamut.
It is here is an option for comparison, and if specifically needed.</p>
</td></tr>
<tr><td><code id="hcl2col_+3A_model">model</code></td>
<td>
<p><code>character</code> string indicating the color model to use:
</p>

<ul>
<li><p> hcl (default) uses <code>farver</code>
</p>
</li>
<li><p> polarLUV uses <code>colorspace</code> polarLUV
</p>
</li>
<li><p> polarLAB uses 'colorspace polarLAB
</p>
</li></ul>
</td></tr>
<tr><td><code id="hcl2col_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> whether to print verbose output.</p>
</td></tr>
<tr><td><code id="hcl2col_+3A_...">...</code></td>
<td>
<p>other arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes an HCL matrix,and converts to an R color using
the colorspace package <code>colorspace::polarLUV()</code> and <code>colorspace::hex()</code>.
</p>
<p>When <code>model="hcl"</code> this function uses <code>farver::encode_colour()</code>
and bypasses <code>colorspace</code>. In future the <code>colorspace</code> dependency
will likely be removed in favor of using <code>farver</code>. In any event,
<code>model="hcl"</code> is equivalent to using <code>model="polarLUV"</code> and
<code>fixup=TRUE</code>, except that it should be much faster.
</p>


<h3>Value</h3>

<p>vector of R colors, or where the input was NA, then NA
values are returned in the same order.
</p>


<h3>See Also</h3>

<p>Other jam color functions: 
<code><a href="#topic+alpha2col">alpha2col</a>()</code>,
<code><a href="#topic+applyCLrange">applyCLrange</a>()</code>,
<code><a href="#topic+col2alpha">col2alpha</a>()</code>,
<code><a href="#topic+col2hcl">col2hcl</a>()</code>,
<code><a href="#topic+col2hsl">col2hsl</a>()</code>,
<code><a href="#topic+col2hsv">col2hsv</a>()</code>,
<code><a href="#topic+color2gradient">color2gradient</a>()</code>,
<code><a href="#topic+fixYellow">fixYellow</a>()</code>,
<code><a href="#topic+fixYellowHue">fixYellowHue</a>()</code>,
<code><a href="#topic+getColorRamp">getColorRamp</a>()</code>,
<code><a href="#topic+hsl2col">hsl2col</a>()</code>,
<code><a href="#topic+hsv2col">hsv2col</a>()</code>,
<code><a href="#topic+isColor">isColor</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+makeColorDarker">makeColorDarker</a>()</code>,
<code><a href="#topic+rainbow2">rainbow2</a>()</code>,
<code><a href="#topic+rgb2col">rgb2col</a>()</code>,
<code><a href="#topic+setCLranges">setCLranges</a>()</code>,
<code><a href="#topic+setTextContrastColor">setTextContrastColor</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+unalpha">unalpha</a>()</code>,
<code><a href="#topic+warpRamp">warpRamp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Prepare a basic HCL matrix
hclM &lt;- col2hcl(c(red="red",
   blue="blue",
   yellow="yellow",
   orange="#FFAA0066"));
hclM;

# Now convert back to R hex colors
colorV &lt;- hcl2col(hclM);
colorV;

showColors(colorV);

</code></pre>

<hr>
<h2 id='heads'>Apply head() across each element in a list of vectors</h2><span id='topic+heads'></span>

<h3>Description</h3>

<p>Apply head() across each element in a list of vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heads(x, n = 6, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heads_+3A_x">x</code></td>
<td>
<p><code>list</code> of atomic vectors, assumed to be the same
atomic type.</p>
</td></tr>
<tr><td><code id="heads_+3A_n">n</code></td>
<td>
<p><code>integer</code> maximum number of items to include from
each element in the list <code>x</code>. When <code>n</code> contains multiple
values, they are recycled to <code>length(x)</code> and applied to each
list element in order.</p>
</td></tr>
<tr><td><code id="heads_+3A_...">...</code></td>
<td>
<p>additional arguments are passed to <code>utils::head()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function currently only operates on a list
of vectors. This function is notably faster than
<code>lapply(x, head, n)</code> because it operates on the entire
vector in one step.
</p>
<p>Also the input <code>n</code> can be a vector so that each element in
the list has a specific number of items returned.
</p>


<h3>Value</h3>

<p><code>list</code> with at most <code>n</code> elements per vector.
</p>


<h3>See Also</h3>

<p>Other jam list functions: 
<code><a href="#topic+cPaste">cPaste</a>()</code>,
<code><a href="#topic+jam_rapply">jam_rapply</a>()</code>,
<code><a href="#topic+list2df">list2df</a>()</code>,
<code><a href="#topic+mergeAllXY">mergeAllXY</a>()</code>,
<code><a href="#topic+mixedSorts">mixedSorts</a>()</code>,
<code><a href="#topic+rbindList">rbindList</a>()</code>,
<code><a href="#topic+relist_named">relist_named</a>()</code>,
<code><a href="#topic+rlengths">rlengths</a>()</code>,
<code><a href="#topic+sclass">sclass</a>()</code>,
<code><a href="#topic+sdim">sdim</a>()</code>,
<code><a href="#topic+uniques">uniques</a>()</code>,
<code><a href="#topic+unnestList">unnestList</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l &lt;- list(a=1:10, b=2:5, c=NULL, d=1:100);
heads(l, 1);

heads(l, 2);

heads(l, n=c(2, 1, 3, 5))

</code></pre>

<hr>
<h2 id='heatmap_column_order'>Return Heatmap column order from ComplexHeatmap heatmap object</h2><span id='topic+heatmap_column_order'></span>

<h3>Description</h3>

<p>Return Heatmap column order from ComplexHeatmap heatmap object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatmap_column_order(hm, which_heatmap = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heatmap_column_order_+3A_hm">hm</code></td>
<td>
<p><code>Heatmap</code> or <code>HeatmapList</code> object as defined by the
Bioconductor package via <code>ComplexHeatmap::Heatmap()</code>.</p>
</td></tr>
<tr><td><code id="heatmap_column_order_+3A_which_heatmap">which_heatmap</code></td>
<td>
<p>used to specify a specific heatmap with <code>hm</code> is
provided as a <code>HeatmapList</code>. When <code>NULL</code> (default) the first heatmap
in <code>hm@ht_list</code> is used. When one value is supplied, only that heatmap
is used. When multiple values are supplied, a <code>list</code> is returned.
Input can be either:
</p>

<ul>
<li> <p><code>numeric</code> - indicating the heatmap number in <code>hm@ht_list</code>
</p>
</li>
<li> <p><code>character</code> - indicating the heatmap name seen in <code>names(hm@ht_list)</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a helpful utility to return the fully
qualified list of colnames in a <code>ComplexHeatmap::Heatmap</code>
object.
</p>
<p>The core intention is for the output to be usable with the
original data matrix used in the heatmap. Therefore, the
vector values are <code>colnames()</code> when present, or <code>integer</code>
column index values when there are no <code>colnames()</code>. If heatmap
<code>column_labels</code> are defined, they are returned as <code>names()</code>.
</p>
<p>Note that <code>names()</code> are assigned inside <code>try()</code> to allow the
case where <code>column_labels</code>, or <code>column_title</code> labels cannot be
coerced to <code>character</code> values, for example using <code>gridtext</code>
for markdown formatting.
</p>


<h3>Value</h3>

<p>output depends upon the heatmap:
</p>

<ul>
<li><p> When heatmap columns are grouped using <code>column_split</code>, and
when the data matrix contains colnames,
returns a <code>character</code> vector of colnames in the order they
appear in the heatmap. When there are no colnames, <code>integer</code>
column index values are returned. If the heatmap has column labels,
they are returned as vector names.
</p>
</li>
<li><p> When columns are grouped using <code>column_split</code>, it returns a
<code>list</code> of vectors as described above. The <code>list</code>
is named using the <code>column_title</code> labels only when there is
an equal number of column labels.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other jam heatmap functions: 
<code><a href="#topic+cell_fun_label">cell_fun_label</a>()</code>,
<code><a href="#topic+heatmap_row_order">heatmap_row_order</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check_pkg_installed("ComplexHeatmap")) {
   set.seed(123);

   mat &lt;- matrix(stats::rnorm(18 * 24),
      ncol=24);
   rownames(mat) &lt;- paste0("row", seq_len(18))
   colnames(mat) &lt;- paste0("column", seq_len(24))

   # obtaining row order first causes a warning message
   hm1 &lt;- ComplexHeatmap::Heatmap(mat);

   # best practice is to draw() and store output in an object
   # to ensure the row orders are absolutely fixed
   hm1_drawn &lt;- ComplexHeatmap::draw(hm1);
   print(heatmap_row_order(hm1_drawn))
   print(heatmap_column_order(hm1_drawn))

   # row and column split
   hm1_split &lt;- ComplexHeatmap::Heatmap(mat,
      column_split=3, row_split=3, border=TRUE);
   hm1_split_drawn &lt;- ComplexHeatmap::draw(hm1_split);
   print(heatmap_row_order(hm1_split_drawn))
   print(heatmap_column_order(hm1_split_drawn))

   # display two heatmaps side-by-side
   mat2 &lt;- mat + stats::rnorm(18*24);
   hm2 &lt;- ComplexHeatmap::Heatmap(mat2, border=TRUE, row_split=4);

   hm1hm2_drawn &lt;- ComplexHeatmap::draw(hm1_split + hm2,
      ht_gap=grid::unit(1, "cm"));
   print(heatmap_row_order(hm1hm2_drawn))
   print(heatmap_row_order(hm1hm2_drawn, which_heatmap=2))
   # by default the order uses the first heatmap
   print(heatmap_column_order(hm1hm2_drawn))
   # the second heatmap can be returned
   print(heatmap_column_order(hm1hm2_drawn, which_heatmap=2))
   # or a list of heatmap orders can be returned
   print(heatmap_column_order(hm1hm2_drawn, which_heatmap=1:2))

   # stacked vertical heatmaps
   hm1hm2_drawn_tall &lt;- ComplexHeatmap::draw(
      ComplexHeatmap::`%v%`(hm1_split, hm2),
      ht_gap=grid::unit(1, "cm"));
   print(heatmap_row_order(hm1hm2_drawn))
   print(heatmap_row_order(hm1hm2_drawn, which_heatmap=2))
   print(heatmap_row_order(hm1hm2_drawn, which_heatmap=1:2))
   print(heatmap_row_order(hm1hm2_drawn,
      which_heatmap=names(hm1hm2_drawn@ht_list)))

   # annotation heatmap
   ha &lt;- ComplexHeatmap::rowAnnotation(left=rownames(mat))
   ha_drawn &lt;- ComplexHeatmap::draw(ha + hm1)
   print(sdim(ha_drawn@ht_list))
   print(heatmap_row_order(ha_drawn))
   print(heatmap_column_order(ha_drawn))

   # stacked vertical heatmaps with top annotation
   ta &lt;- ComplexHeatmap::HeatmapAnnotation(top=colnames(mat))
   hm1_ha &lt;- ComplexHeatmap::Heatmap(mat,
      left_annotation=ha,
      column_split=3, row_split=3, border=TRUE);
   hm1hm2_drawn_tall &lt;- ComplexHeatmap::draw(
      ComplexHeatmap::`%v%`(ta,
         ComplexHeatmap::`%v%`(hm1_ha, hm2)),
      ht_gap=grid::unit(1, "cm"));
   print(sdim(hm1hm2_drawn_tall@ht_list))
   print(heatmap_row_order(hm1hm2_drawn_tall))
   print(heatmap_row_order(hm1hm2_drawn_tall, 2))
}

</code></pre>

<hr>
<h2 id='heatmap_row_order'>Return Heatmap row order from ComplexHeatmap heatmap object</h2><span id='topic+heatmap_row_order'></span>

<h3>Description</h3>

<p>Return Heatmap row order from ComplexHeatmap heatmap object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatmap_row_order(hm, which_heatmap = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heatmap_row_order_+3A_hm">hm</code></td>
<td>
<p><code>Heatmap</code> or <code>HeatmapList</code> object as defined by the
Bioconductor package via <code>ComplexHeatmap::Heatmap()</code>.</p>
</td></tr>
<tr><td><code id="heatmap_row_order_+3A_which_heatmap">which_heatmap</code></td>
<td>
<p><code>integer</code>, default NULL, used when the input
is a <code>HeatmapList</code> with multiple heatmaps.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a helpful utility to return the fully
qualified list of rownames in a <code>ComplexHeatmap::Heatmap</code>
object.
</p>
<p>The core intention is for the output to be usable with the
original data matrix used in the heatmap. Therefore, the
vector values are <code>rownames()</code> when present, or <code>integer</code>
row index values when there are no <code>rownames()</code>. If heatmap
<code>row_labels</code> are defined, they are returned as <code>names()</code>.
</p>
<p>Note that <code>names()</code> are assigned inside <code>try()</code> to allow the
case where <code>row_labels</code>, or <code>row_title</code> labels cannot be
coerced to <code>character</code> values, for example using <code>gridtext</code>
for markdown formatting.
</p>
<p>Final note: It is best practice to draw the heatmap first
with <code>ComplexHeatmap::draw()</code> then store the output in a new
object. This step creates the definitive clustering and
therefore the row order is absolutely final, not subject
to potential randomness during clustering.
</p>


<h3>Value</h3>

<p>output depends upon the heatmap:
</p>

<ul>
<li><p> When heatmap rows are grouped using <code>row_split</code>, and
when the data matrix contains rownames,
returns a <code>character</code> vector of rownames in the order they
appear in the heatmap. When there are no rownames, <code>integer</code>
row index values are returned. If the heatmap has row labels,
they are returned as vector names.
</p>
</li>
<li><p> When rows are grouped using <code>row_split</code>, it returns a
<code>list</code> of vectors as described above. The <code>list</code>
is named using the <code>row_title</code> labels only when there is
an equal number of row labels.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other jam heatmap functions: 
<code><a href="#topic+cell_fun_label">cell_fun_label</a>()</code>,
<code><a href="#topic+heatmap_column_order">heatmap_column_order</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See heatmap_column_order() for examples

</code></pre>

<hr>
<h2 id='hsl2col'>convert HCL to R color</h2><span id='topic+hsl2col'></span>

<h3>Description</h3>

<p>Convert an HCL color matrix to vector of R hex colors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hsl2col(
  x = NULL,
  H = NULL,
  S = NULL,
  L = NULL,
  alpha = NULL,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hsl2col_+3A_x">x</code></td>
<td>
<p><code>numeric</code> matrix of colors, with rownames <code>"H"</code>, <code>"S"</code>, <code>"L"</code>,
or if not supplied it looks for vectors <code>H</code>, <code>S</code>, and <code>L</code> accordingly.</p>
</td></tr>
<tr><td><code id="hsl2col_+3A_h">H</code>, <code id="hsl2col_+3A_s">S</code>, <code id="hsl2col_+3A_l">L</code></td>
<td>
<p><code>numeric</code> vectors supplied as an alternative to <code>x</code>, with
ranges 0 to 360, 0 to 100, and 0 to 100, respectively.</p>
</td></tr>
<tr><td><code id="hsl2col_+3A_alpha">alpha</code></td>
<td>
<p><code>numeric</code> vector of alpha values, default NULL.
If not supplied, and if <code>x</code> is supplied as a matrix with
rowname <code>"alpha"</code>, then values will be used from <code>x["alpha",]</code>.</p>
</td></tr>
<tr><td><code id="hsl2col_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating whether to print verbose output.</p>
</td></tr>
<tr><td><code id="hsl2col_+3A_...">...</code></td>
<td>
<p>other arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes an HCL matrix,and converts to an R color using
the colorspace package <code>colorspace::polarLUV()</code> and <code>colorspace::hex()</code>.
</p>
<p>When <code>model="hcl"</code> this function uses <code>farver::encode_colour()</code>
and bypasses <code>colorspace</code>. In future the <code>colorspace</code> dependency
will likely be removed in favor of using <code>farver</code>. In any event,
<code>model="hcl"</code> is equivalent to using <code>model="polarLUV"</code> and
<code>fixup=TRUE</code>, except that it should be much faster.
</p>


<h3>Value</h3>

<p>vector of R colors, or where the input was NA, then NA
values are returned in the same order.
</p>


<h3>See Also</h3>

<p>Other jam color functions: 
<code><a href="#topic+alpha2col">alpha2col</a>()</code>,
<code><a href="#topic+applyCLrange">applyCLrange</a>()</code>,
<code><a href="#topic+col2alpha">col2alpha</a>()</code>,
<code><a href="#topic+col2hcl">col2hcl</a>()</code>,
<code><a href="#topic+col2hsl">col2hsl</a>()</code>,
<code><a href="#topic+col2hsv">col2hsv</a>()</code>,
<code><a href="#topic+color2gradient">color2gradient</a>()</code>,
<code><a href="#topic+fixYellow">fixYellow</a>()</code>,
<code><a href="#topic+fixYellowHue">fixYellowHue</a>()</code>,
<code><a href="#topic+getColorRamp">getColorRamp</a>()</code>,
<code><a href="#topic+hcl2col">hcl2col</a>()</code>,
<code><a href="#topic+hsv2col">hsv2col</a>()</code>,
<code><a href="#topic+isColor">isColor</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+makeColorDarker">makeColorDarker</a>()</code>,
<code><a href="#topic+rainbow2">rainbow2</a>()</code>,
<code><a href="#topic+rgb2col">rgb2col</a>()</code>,
<code><a href="#topic+setCLranges">setCLranges</a>()</code>,
<code><a href="#topic+setTextContrastColor">setTextContrastColor</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+unalpha">unalpha</a>()</code>,
<code><a href="#topic+warpRamp">warpRamp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See col2hcl() for more extensive examples

# Prepare a basic HSL matrix
x_colors &lt;- c(red="red",
   blue="blue",
   yellow="yellow",
   orange="#FFAA0066");
hslM &lt;- col2hsl(x_colors);
hslM;

# Now convert back to R hex colors
colorV &lt;- hsl2col(hslM);
colorV;

showColors(list(x_colors=x_colors,
   colorV=nameVector(colorV)));

</code></pre>

<hr>
<h2 id='hsv2col'>Convert HSV matrix to R color</h2><span id='topic+hsv2col'></span>

<h3>Description</h3>

<p>Converts a HSV color matrix to R hex color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hsv2col(hsvValue, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hsv2col_+3A_hsvvalue">hsvValue</code></td>
<td>
<p><code>numeric</code> HSV matrix, with rownames c(&quot;h&quot;,&quot;s&quot;,&quot;v&quot;)
in any order, and optionally &quot;alpha&quot; rowname for alpha transparency.</p>
</td></tr>
<tr><td><code id="hsv2col_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function augments the <code>grDevices::hsv()</code> function in that it handles
output from <code>grDevices::rgb2hsv()</code> or <code>col2hsv()</code>, sufficient to
run a series of conversion functions, e.g. <code>hsv2col(col2hsv("red"))</code>.
This function also maintains alpha transparency, which is not maintained
by the <code>grDevices::hsv()</code> function.
</p>


<h3>Value</h3>

<p><code>character</code> vector of R colors.
</p>


<h3>See Also</h3>

<p>Other jam color functions: 
<code><a href="#topic+alpha2col">alpha2col</a>()</code>,
<code><a href="#topic+applyCLrange">applyCLrange</a>()</code>,
<code><a href="#topic+col2alpha">col2alpha</a>()</code>,
<code><a href="#topic+col2hcl">col2hcl</a>()</code>,
<code><a href="#topic+col2hsl">col2hsl</a>()</code>,
<code><a href="#topic+col2hsv">col2hsv</a>()</code>,
<code><a href="#topic+color2gradient">color2gradient</a>()</code>,
<code><a href="#topic+fixYellow">fixYellow</a>()</code>,
<code><a href="#topic+fixYellowHue">fixYellowHue</a>()</code>,
<code><a href="#topic+getColorRamp">getColorRamp</a>()</code>,
<code><a href="#topic+hcl2col">hcl2col</a>()</code>,
<code><a href="#topic+hsl2col">hsl2col</a>()</code>,
<code><a href="#topic+isColor">isColor</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+makeColorDarker">makeColorDarker</a>()</code>,
<code><a href="#topic+rainbow2">rainbow2</a>()</code>,
<code><a href="#topic+rgb2col">rgb2col</a>()</code>,
<code><a href="#topic+setCLranges">setCLranges</a>()</code>,
<code><a href="#topic+setTextContrastColor">setTextContrastColor</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+unalpha">unalpha</a>()</code>,
<code><a href="#topic+warpRamp">warpRamp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># start with a color vector
# red and blue with partial transparency
colorV &lt;- c("#FF000055", "#00339999");

# confirm the hsv matrix maintains transparency
col2hsv(colorV);

# convert back to the original color
hsv2col(col2hsv(colorV));

</code></pre>

<hr>
<h2 id='igrep'>case-insensitive grep</h2><span id='topic+igrep'></span>

<h3>Description</h3>

<p>case-insensitive grep
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igrep(..., ignore.case = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="igrep_+3A_...">...</code>, <code id="igrep_+3A_ignore.case">ignore.case</code></td>
<td>
<p>parameters sent to <code>base::grep()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a simple wrapper around <code>base::grep()</code> which
runs in case-insensitive mode. It is mainly used to save keystrokes,
but is consistently named alongside <code><a href="#topic+vgrep">vgrep</a></code> and
<code><a href="#topic+vigrep">vigrep</a></code>.
</p>


<h3>Value</h3>

<p>vector of matching indices
</p>


<h3>See Also</h3>

<p>Other jam grep functions: 
<code><a href="#topic+grepls">grepls</a>()</code>,
<code><a href="#topic+igrepHas">igrepHas</a>()</code>,
<code><a href="#topic+igrepl">igrepl</a>()</code>,
<code><a href="#topic+provigrep">provigrep</a>()</code>,
<code><a href="#topic+unigrep">unigrep</a>()</code>,
<code><a href="#topic+unvigrep">unvigrep</a>()</code>,
<code><a href="#topic+vgrep">vgrep</a>()</code>,
<code><a href="#topic+vigrep">vigrep</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>V &lt;- paste0(LETTERS[1:5], LETTERS[4:8]);
igrep("D", V);
igrep("d", V);
vigrep("d", V);

</code></pre>

<hr>
<h2 id='igrepHas'>vector contains any case-insensitive grep match</h2><span id='topic+igrepHas'></span>

<h3>Description</h3>

<p>vector contains any case-insensitive grep match
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igrepHas(
  pattern,
  x = NULL,
  ignore.case = TRUE,
  minCount = 1,
  naToBlank = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="igrepHas_+3A_pattern">pattern</code></td>
<td>
<p>the grep pattern to use with <code>base::grep()</code></p>
</td></tr>
<tr><td><code id="igrepHas_+3A_x">x</code></td>
<td>
<p>vector to use in the grep</p>
</td></tr>
<tr><td><code id="igrepHas_+3A_ignore.case">ignore.case</code></td>
<td>
<p>logical default TRUE, meaning the grep will be performed
in case-insensitive mode.</p>
</td></tr>
<tr><td><code id="igrepHas_+3A_mincount">minCount</code></td>
<td>
<p>integer minimum number of matches required to return TRUE.</p>
</td></tr>
<tr><td><code id="igrepHas_+3A_natoblank">naToBlank</code></td>
<td>
<p>logical whether to convert NA to blank, instead of
allowing grep to handle NA values as-is.</p>
</td></tr>
<tr><td><code id="igrepHas_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks the input vector for any elements matching the
grep pattern. The grep is performed case-insensitive (igrep). This function
is particularly useful when checking function arguments or object class,
where the class(a) might return multiple values, or where the name of
the class might be slightly different than expected, e.g. data.frame,
data_frame, DataFrame.
</p>


<h3>Value</h3>

<p>logical indicating whether the grep match criteria were met,
TRUE indicates the grep pattern was present in minCount or more
number of entries.
</p>


<h3>See Also</h3>

<p><code>base::grep()</code>
</p>
<p>Other jam grep functions: 
<code><a href="#topic+grepls">grepls</a>()</code>,
<code><a href="#topic+igrep">igrep</a>()</code>,
<code><a href="#topic+igrepl">igrepl</a>()</code>,
<code><a href="#topic+provigrep">provigrep</a>()</code>,
<code><a href="#topic+unigrep">unigrep</a>()</code>,
<code><a href="#topic+unvigrep">unvigrep</a>()</code>,
<code><a href="#topic+vgrep">vgrep</a>()</code>,
<code><a href="#topic+vigrep">vigrep</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- c("data.frame","data_frame","tibble","tbl");
igrepHas("Data.*Frame", a);
igrepHas("matrix", a);

</code></pre>

<hr>
<h2 id='igrepl'>case-insensitive logical grepl</h2><span id='topic+igrepl'></span>

<h3>Description</h3>

<p>case-insensitive logical grepl
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igrepl(..., ignore.case = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="igrepl_+3A_...">...</code>, <code id="igrepl_+3A_ignore.case">ignore.case</code></td>
<td>
<p>parameters sent to <code>base::grep()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a simple wrapper around <code>base::grepl()</code> which
runs in case-insensitive mode simply by adding default <code>ignore.case=TRUE</code>.
It is mainly used for convenience.
</p>


<h3>Value</h3>

<p><code>logical</code> vector indicating pattern match
</p>


<h3>See Also</h3>

<p>Other jam grep functions: 
<code><a href="#topic+grepls">grepls</a>()</code>,
<code><a href="#topic+igrep">igrep</a>()</code>,
<code><a href="#topic+igrepHas">igrepHas</a>()</code>,
<code><a href="#topic+provigrep">provigrep</a>()</code>,
<code><a href="#topic+unigrep">unigrep</a>()</code>,
<code><a href="#topic+unvigrep">unvigrep</a>()</code>,
<code><a href="#topic+vgrep">vgrep</a>()</code>,
<code><a href="#topic+vigrep">vigrep</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>V &lt;- paste0(LETTERS[1:5], LETTERS[4:8]);
ig1 &lt;- grepl("D", V);
ig2 &lt;- igrepl("D", V);
ig3 &lt;- grepl("d", V);
ig4 &lt;- igrepl("d", V);
data.frame(V,
   grepl_D=ig1,
   grepl_d=ig3,
   igrepl_D=ig2,
   igrepl_d=ig4);

</code></pre>

<hr>
<h2 id='imageByColors'>Display color raster image using a matrix of colors</h2><span id='topic+imageByColors'></span>

<h3>Description</h3>

<p>Display color raster image using a matrix of colors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imageByColors(
  x,
  useRaster = FALSE,
  fixRasterRatio = TRUE,
  maxRatioFix = 100,
  xaxt = "s",
  yaxt = "s",
  doPlot = TRUE,
  cellnote = NULL,
  cexCellnote = 1,
  srtCellnote = 0,
  fontCellnote = 1,
  groupCellnotes = TRUE,
  groupBy = c("column", "row"),
  groupByColors = TRUE,
  adjBy = c("column", "row"),
  adjustMargins = FALSE,
  interpolate = getOption("interpolate", TRUE),
  verbose = FALSE,
  xpd = NULL,
  bty = graphics::par("bty"),
  flip = c("none", "y", "x", "xy"),
  keepTextAlpha = FALSE,
  doTest = FALSE,
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imageByColors_+3A_x">x</code></td>
<td>
<p><code>matrix</code> or <code>data.frame</code> containing colors</p>
</td></tr>
<tr><td><code id="imageByColors_+3A_useraster">useRaster</code></td>
<td>
<p><code>logical</code> sent to <code><a href="#topic+imageDefault">imageDefault</a></code> to enable
raster rendering, as opposed to polygon rendering. This parameter is
highly recommended when the matrix is large (&gt;50 columns or rows).</p>
</td></tr>
<tr><td><code id="imageByColors_+3A_fixrasterratio">fixRasterRatio</code></td>
<td>
<p><code>logical</code> sent to <code><a href="#topic+imageDefault">imageDefault</a></code>.</p>
</td></tr>
<tr><td><code id="imageByColors_+3A_maxratiofix">maxRatioFix</code></td>
<td>
<p><code>numeric</code> sent to <code><a href="#topic+imageDefault">imageDefault</a></code>.</p>
</td></tr>
<tr><td><code id="imageByColors_+3A_xaxt">xaxt</code>, <code id="imageByColors_+3A_yaxt">yaxt</code></td>
<td>
<p><code>character</code> values compatible with <code><a href="graphics.html#topic+par">par</a></code> to
determine whether x- and y-axes are plotted. Set both to &quot;n&quot; to
suppress display of axes.</p>
</td></tr>
<tr><td><code id="imageByColors_+3A_doplot">doPlot</code></td>
<td>
<p><code>logical</code> whether to create a plot, or simply return data which
would have been used to create the plot.</p>
</td></tr>
<tr><td><code id="imageByColors_+3A_cellnote">cellnote</code></td>
<td>
<p><code>matrix</code> or <code>data.frame</code> of labels to be displayed on the
image. If groupCellnotes==TRUE labels will be placed in the center
of consecutive cells with the same label and identical color.
Currently, cell text is colored using <code><a href="#topic+setTextContrastColor">setTextContrastColor</a></code>
which uses either white or black depending upon the brightness of
the background color.</p>
</td></tr>
<tr><td><code id="imageByColors_+3A_cexcellnote">cexCellnote</code>, <code id="imageByColors_+3A_srtcellnote">srtCellnote</code>, <code id="imageByColors_+3A_fontcellnote">fontCellnote</code></td>
<td>
<p><code>numeric</code> vectors, with values
applied to cellnote text to be compatible with <code>graphics::par("cex")</code>,
<code>graphics::par("srt")</code>,
and <code>graphics::par("font")</code>, respectively.
If supplied a matrix or data.frame with
it is used as-is or expanded to equivalent dimensions of <code>x</code>.
If the vector is named by colnames(x) then it is applied
by column in order, otherwise it is applied by row, with values recycled
to the number of columns or rows, respectively. Note <code>cexCellnote</code>
can also be a list, with the list elements being applied to individual
cells in order. If the list is named by colnames(x), each list element
is applied to values in each column, in order. In future this parameter
may also accept a matrix of cex values as input. Final note: values are
applied to each cell, but when cell labels are combined with
groupCellnotes==TRUE, the value for the first matching cell is used.
Remember that values are placed by coordinate, bottom-to-top on the
y-axis, and left-to-right on the x-axis.</p>
</td></tr>
<tr><td><code id="imageByColors_+3A_groupcellnotes">groupCellnotes</code></td>
<td>
<p><code>logical</code> whether to group labels where consecutive
cells contain the same label and identical cell colors, thus only
displaying one label in the center of these groups.</p>
</td></tr>
<tr><td><code id="imageByColors_+3A_groupby">groupBy</code></td>
<td>
<p><code>character</code> value indicating the direction to group
cellnotes, when <code>groupCellnotes=TRUE</code>: <code>"row"</code> will group cellnote
values by row; <code>"column"</code> will group cellnote values by column.
By default, it will first group cellnotes by <code>"row"</code> then
by <code>"column"</code>.</p>
</td></tr>
<tr><td><code id="imageByColors_+3A_groupbycolors">groupByColors</code></td>
<td>
<p><code>logical</code> indicating whether the cellnote grouping
should also include the cell color. When <code>groupByColors=FALSE</code>,
cellnote values will be grouped together regardless whether the
underlying colors change, which may be preferred when applying
text label to topographical data.</p>
</td></tr>
<tr><td><code id="imageByColors_+3A_adjby">adjBy</code></td>
<td>
<p><code>character</code> value indicating how to apply adjustments for
cexCellnote, srtCellnote, and fontCellnote, as described above.</p>
</td></tr>
<tr><td><code id="imageByColors_+3A_adjustmargins">adjustMargins</code></td>
<td>
<p><code>logical</code> indicating whether to adjust the axis
label margins to ensure enough room to draw the text rownames
and colnames.</p>
</td></tr>
<tr><td><code id="imageByColors_+3A_interpolate">interpolate</code></td>
<td>
<p><code>logical</code> whether to implement image interpolation,
by default TRUE when useRaster=TRUE.</p>
</td></tr>
<tr><td><code id="imageByColors_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> whether to print verbose output.</p>
</td></tr>
<tr><td><code id="imageByColors_+3A_xpd">xpd</code></td>
<td>
<p>NULL or <code>logical</code> used for <code>graphics::par("xpd")</code>
whether to crop displayed output to the plot area.
</p>

<ul>
<li><p> If xpd=NULL then <code>graphics::par("xpd")</code>
will not be modified, otherwise <code>graphics::par("xpd"=xpd)</code>
will be defined while adding any cell notes,
then reverted to its previous value afterward.
This parameter is mainly useful when cellnote labels may overhang the
plot space, and would be cropped and not visible if
<code>graphics::par("xpd"=TRUE)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="imageByColors_+3A_bty">bty</code></td>
<td>
<p><code>character</code> used to control box type, default
<code>graphics::par("bty")</code></p>
</td></tr>
<tr><td><code id="imageByColors_+3A_flip">flip</code></td>
<td>
<p><code>character</code> string, default &quot;none&quot;, with optional axis flip:
</p>

<ul>
<li><p> none: perform no axis flip
</p>
</li>
<li><p> x: flip x-axis orientation
</p>
</li>
<li><p> y: flip y-axis orientation
</p>
</li>
<li><p> xy: flip both x- and y-axis orientation
</p>
</li></ul>
</td></tr>
<tr><td><code id="imageByColors_+3A_keeptextalpha">keepTextAlpha</code></td>
<td>
<p><code>logical</code> defaulit FALSE,
passed to <code>setTextContrastColor()</code>, whether the text label color
should inherit the alpha transparency from the background color.
If TRUE then fully transparent background colors will not have
a visible label.</p>
</td></tr>
<tr><td><code id="imageByColors_+3A_dotest">doTest</code></td>
<td>
<p><code>logical</code> whether to run a test showing basic features.</p>
</td></tr>
<tr><td><code id="imageByColors_+3A_add">add</code></td>
<td>
<p><code>logical</code>, default FALSE, whether to add to an existing
device, otherwise it creates a new plot.</p>
</td></tr>
<tr><td><code id="imageByColors_+3A_...">...</code></td>
<td>
<p>Additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is similar to <code><a href="graphics.html#topic+image">image</a></code> except that
it takes a matrix which already has colors defined for each cell.
This function calls <code><a href="#topic+imageDefault">imageDefault</a></code> which enables updated
use of the <code>useRaster</code> functionality.
</p>
<p>Additionally, if <code>cellnote</code> is supplied, which contains a matrix
of labels for the image cells, those labels will also be displayed.
By default, labels are grouped, so that only one label is displayed
whenever two or more labels appear in consecutive cells. This behavior
can be disabled with groupCellnotes=FALSE.
</p>
<p>The <code>groupCellnotes</code> behavior uses <code>breaksByVector()</code> to
determine where to place consecutive labels, and it applies this logic
starting with rows, then columns. Note that labels are only grouped when
both the cell color and the cell label are identical for consecutive
cells.
</p>
<p>In general, if a large rectangular set of cells contains the same label,
and cell colors, the resulting label will be positioned in the
center. However, when the square is not symmetric, the label will be
grouped only where consecutive columns contain the same groups of
consecutive rows for a given label.
</p>
<p>It is helpful to rotate labels partially to prevent overlaps, e.g.
srtCellnote=10 or srtCellnote=80.
</p>
<p>To do:
</p>

<ul>
<li><p>Detect the size of the area being labeled and determine whether
to rotate the label sideways.
</p>
</li>
<li><p>Detect the size of the label, compared to its bounding box,
and resize the label to fit the available space.
</p>
</li>
<li><p>Optionally draw border around contiguous colored and labeled
polygons. Whether to draw border based only upon color, or color
and label, or just label... it may get confusing.
</p>
</li>
<li><p>Label proper contiguous polygons based upon color and label,
especially when color and label are present on multiple rows and
columns, but not always the same columns per row.
</p>
</li></ul>



<h3>Value</h3>

<p><code>list</code> invisibly, with elements sufficient to create an
image plot. This function is called for the byproduct of creating
an image visualization.
</p>


<h3>See Also</h3>

<p>Other jam plot functions: 
<code><a href="#topic+adjustAxisLabelMargins">adjustAxisLabelMargins</a>()</code>,
<code><a href="#topic+coordPresets">coordPresets</a>()</code>,
<code><a href="#topic+decideMfrow">decideMfrow</a>()</code>,
<code><a href="#topic+drawLabels">drawLabels</a>()</code>,
<code><a href="#topic+getPlotAspect">getPlotAspect</a>()</code>,
<code><a href="#topic+groupedAxis">groupedAxis</a>()</code>,
<code><a href="#topic+imageDefault">imageDefault</a>()</code>,
<code><a href="#topic+minorLogTicksAxis">minorLogTicksAxis</a>()</code>,
<code><a href="#topic+nullPlot">nullPlot</a>()</code>,
<code><a href="#topic+plotPolygonDensity">plotPolygonDensity</a>()</code>,
<code><a href="#topic+plotRidges">plotRidges</a>()</code>,
<code><a href="#topic+plotSmoothScatter">plotSmoothScatter</a>()</code>,
<code><a href="#topic+shadowText">shadowText</a>()</code>,
<code><a href="#topic+shadowText_options">shadowText_options</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+sqrtAxis">sqrtAxis</a>()</code>,
<code><a href="#topic+usrBox">usrBox</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a1 &lt;- c("red4","blue")[c(1,1,2)];
b1 &lt;- c("yellow","orange")[c(1,2,2)];
c1 &lt;- c("purple","orange")[c(1,2,2)];
d1 &lt;- c("purple","green4")[c(1,2,2)];
df1 &lt;- data.frame(a=a1, b=b1, c=c1, d=d1);

# default using polygons
imageByColors(df1, cellnote=df1);

# using useRaster, edges are slightly blurred with small tables
imageByColors(df1, cellnote=df1, useRaster=TRUE);

# some text features, rotation, font size, etc
imageByColors(df1, cellnote=df1, useRaster=TRUE, adjBy="column",
   cexCellnote=list(c(1.5,1.5,1), c(1,1.5), c(1.6,1.2), c(1.6,1.5)),
   srtCellnote=list(c(90,0,0), c(0,45), c(0,0,0), c(0,90,0)));
</code></pre>

<hr>
<h2 id='imageDefault'>Display a color raster image</h2><span id='topic+imageDefault'></span>

<h3>Description</h3>

<p>Display a color raster image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imageDefault(
  x = seq_len(nrow(z) + 1) - 0.5,
  y = seq_len(ncol(z) + 1) - 0.5,
  z,
  zlim = range(z[is.finite(z)]),
  xlim = range(x),
  ylim = range(y),
  col = grDevices::hcl.colors(12, "YlOrRd", rev = TRUE),
  add = FALSE,
  xaxs = "i",
  yaxs = "i",
  xaxt = "n",
  yaxt = "n",
  xlab,
  ylab,
  breaks,
  flip = c("none", "x", "y", "xy"),
  oldstyle = TRUE,
  useRaster = NULL,
  fixRasterRatio = TRUE,
  maxRatioFix = 10,
  minRasterMultiple = NULL,
  rasterTarget = 200,
  interpolate = getOption("interpolate", TRUE),
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imageDefault_+3A_x">x</code></td>
<td>
<p><code>numeric</code> location of grid lines at which the intervals
in z are measured.</p>
</td></tr>
<tr><td><code id="imageDefault_+3A_y">y</code></td>
<td>
<p><code>numeric</code> location of grid lines at which the intervals
in z are measured.</p>
</td></tr>
<tr><td><code id="imageDefault_+3A_z">z</code></td>
<td>
<p><code>numeric</code> or logical matrix containing the values to be plotted,
where NA values are allowed.</p>
</td></tr>
<tr><td><code id="imageDefault_+3A_zlim">zlim</code></td>
<td>
<p><code>numeric</code> range allowed for values in z.</p>
</td></tr>
<tr><td><code id="imageDefault_+3A_xlim">xlim</code></td>
<td>
<p><code>numeric</code> range to plot on the x-axis, by default the x range.</p>
</td></tr>
<tr><td><code id="imageDefault_+3A_ylim">ylim</code></td>
<td>
<p><code>numeric</code> range to plot on the y-axis, by default the y range.</p>
</td></tr>
<tr><td><code id="imageDefault_+3A_col">col</code></td>
<td>
<p><code>character</code> vector of colors to be mapped to values in z.</p>
</td></tr>
<tr><td><code id="imageDefault_+3A_add">add</code></td>
<td>
<p><code>logical</code> whether to add to an existing active R plot, or create
a new plot window.</p>
</td></tr>
<tr><td><code id="imageDefault_+3A_xaxs">xaxs</code></td>
<td>
<p><code>character</code> value compatible with graphics::par(xaxs), mainly useful
for suppressing the x-axis, in order to produce a custom x-axis
range, most useful to restrict the axis range expansion done by R
by default.</p>
</td></tr>
<tr><td><code id="imageDefault_+3A_yaxs">yaxs</code></td>
<td>
<p><code>character</code> value compatible with graphics::par(yaxs), mainly useful
for suppressing the y-axis, in order to produce a custom y-axis
range, most useful to restrict the axis range expansion done by R
by default.</p>
</td></tr>
<tr><td><code id="imageDefault_+3A_xaxt">xaxt</code></td>
<td>
<p><code>character</code> value compatible with graphics::par(xaxt), mainly useful
for suppressing the x-axis, in order to produce a custom x-axis
by other mechanisms, e.g. log-scaled x-axis tick marks.</p>
</td></tr>
<tr><td><code id="imageDefault_+3A_yaxt">yaxt</code></td>
<td>
<p><code>character</code> value compatible with graphics::par(yaxt), mainly useful
for suppressing the y-axis, in order to produce a custom y-axis
by other mechanisms, e.g. log-scaled y-axis tick marks.</p>
</td></tr>
<tr><td><code id="imageDefault_+3A_xlab">xlab</code></td>
<td>
<p><code>character</code> label for the x-axis</p>
</td></tr>
<tr><td><code id="imageDefault_+3A_ylab">ylab</code></td>
<td>
<p><code>character</code> label for the y-axis</p>
</td></tr>
<tr><td><code id="imageDefault_+3A_breaks">breaks</code></td>
<td>
<p><code>numeric</code> vector of breakpoints for colors.</p>
</td></tr>
<tr><td><code id="imageDefault_+3A_flip">flip</code></td>
<td>
<p><code>character</code> string, default &quot;none&quot;, with optional axis flip:
</p>

<ul>
<li><p> none: perform no axis flip
</p>
</li>
<li><p> x: flip x-axis orientation
</p>
</li>
<li><p> y: flip y-axis orientation
</p>
</li>
<li><p> xy: flip both x- and y-axis orientation
</p>
</li></ul>
</td></tr>
<tr><td><code id="imageDefault_+3A_oldstyle">oldstyle</code></td>
<td>
<p><code>logical</code> whether to delineate axis coordinates with an
integer spacing for each column and row. Note: the only allowed parameter
is TRUE, since useRaster=TRUE requires it. Therefore, this function
for consistency will only output this format.</p>
</td></tr>
<tr><td><code id="imageDefault_+3A_useraster">useRaster</code></td>
<td>
<p><code>logical</code> whether to force raster image scaling, which
is especially useful for large data matrices. In this case a bitmap
raster image is created instead of polygons, then the bitmap is scaled
to fit the plot space. Otherwise, individual polygons can be obscured
on monitor screens, or may result in an extremely large file size when
writing to vector image format such as 'PDF' or 'SVG'.</p>
</td></tr>
<tr><td><code id="imageDefault_+3A_fixrasterratio">fixRasterRatio</code></td>
<td>
<p><code>logical</code> whether to implement a simple workaround
to the requirement for square pixels, in the event the x- and y-axis
dimensions are not roughly equal.</p>
</td></tr>
<tr><td><code id="imageDefault_+3A_maxratiofix">maxRatioFix</code></td>
<td>
<p><code>integer</code> maximum number of times any axis may be
replicated to create a matrix of roughly equal x- and y-axis dimensions.</p>
</td></tr>
<tr><td><code id="imageDefault_+3A_minrastermultiple">minRasterMultiple</code></td>
<td>
<p><code>integer</code> minimum number of times the x- and y-axis
will be duplicated, which is mostly useful when creating useRaster=TRUE
for small matrix sizes, otherwise the result will be quite blurry. For
example, minRasterMultiple=10 will duplicate each axis 10 times. Values
are aplied to rows then columns. These values are automatically defined
if minRasterMultiple is NULL and rasterTarget is not NULL.</p>
</td></tr>
<tr><td><code id="imageDefault_+3A_rastertarget">rasterTarget</code></td>
<td>
<p><code>integer</code> number of cells below which cells are duplicated
in order to maintain detail. The default 200 defines
minRasterMultiple=c(1,1) if there are 200 rows and 200 columns, or
minRasterMultiple=c(1,100) if there are 200 rows but 2 columns.</p>
</td></tr>
<tr><td><code id="imageDefault_+3A_interpolate">interpolate</code></td>
<td>
<p><code>logical</code> whether to implement image interpolation,
by default TRUE when useRaster=TRUE.</p>
</td></tr>
<tr><td><code id="imageDefault_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> whether to enable verbose output, useful for
debugging.</p>
</td></tr>
<tr><td><code id="imageDefault_+3A_...">...</code></td>
<td>
<p>Additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function augments the <code><a href="graphics.html#topic+image">image</a></code> function, in
that it handles the useRaster parameter for non-symmetric data matrices,
in order to minimize the distortion from image-smoothing when pixels are
not square.
</p>
<p>The function also by default creates the image map using coordinates where
each integer represents the center point of one column or row of data,
known in the default <code><a href="graphics.html#topic+image">image</a></code> function as <code>oldstyle=TRUE</code>.
For consistency, <code>imageDefault</code> will only accept <code>oldstyle=TRUE</code>.
</p>


<h3>Value</h3>

<p><code>list</code> composed of elements suitable to call
<code>graphics::image.default()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+image">image</a></code>
</p>
<p>Other jam plot functions: 
<code><a href="#topic+adjustAxisLabelMargins">adjustAxisLabelMargins</a>()</code>,
<code><a href="#topic+coordPresets">coordPresets</a>()</code>,
<code><a href="#topic+decideMfrow">decideMfrow</a>()</code>,
<code><a href="#topic+drawLabels">drawLabels</a>()</code>,
<code><a href="#topic+getPlotAspect">getPlotAspect</a>()</code>,
<code><a href="#topic+groupedAxis">groupedAxis</a>()</code>,
<code><a href="#topic+imageByColors">imageByColors</a>()</code>,
<code><a href="#topic+minorLogTicksAxis">minorLogTicksAxis</a>()</code>,
<code><a href="#topic+nullPlot">nullPlot</a>()</code>,
<code><a href="#topic+plotPolygonDensity">plotPolygonDensity</a>()</code>,
<code><a href="#topic+plotRidges">plotRidges</a>()</code>,
<code><a href="#topic+plotSmoothScatter">plotSmoothScatter</a>()</code>,
<code><a href="#topic+shadowText">shadowText</a>()</code>,
<code><a href="#topic+shadowText_options">shadowText_options</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+sqrtAxis">sqrtAxis</a>()</code>,
<code><a href="#topic+usrBox">usrBox</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ps &lt;- plotSmoothScatter(doTest=TRUE)

</code></pre>

<hr>
<h2 id='isColor'>detect valid R color</h2><span id='topic+isColor'></span>

<h3>Description</h3>

<p>detect valid R color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isColor(x, makeNamesFunc = c, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isColor_+3A_x">x</code></td>
<td>
<p>character vector of potential R colors</p>
</td></tr>
<tr><td><code id="isColor_+3A_makenamesfunc">makeNamesFunc</code></td>
<td>
<p>function used to make names for the resulting vector</p>
</td></tr>
<tr><td><code id="isColor_+3A_...">...</code></td>
<td>
<p>additional parameters are ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function determines whether each element in a vector is a valid R
color, based upon the R color names, valid hex color format, and the
word &quot;transparent&quot; which is valid as an R color.
</p>


<h3>Value</h3>

<p><code>logical</code> vector with length(x).
</p>


<h3>See Also</h3>

<p>Other jam color functions: 
<code><a href="#topic+alpha2col">alpha2col</a>()</code>,
<code><a href="#topic+applyCLrange">applyCLrange</a>()</code>,
<code><a href="#topic+col2alpha">col2alpha</a>()</code>,
<code><a href="#topic+col2hcl">col2hcl</a>()</code>,
<code><a href="#topic+col2hsl">col2hsl</a>()</code>,
<code><a href="#topic+col2hsv">col2hsv</a>()</code>,
<code><a href="#topic+color2gradient">color2gradient</a>()</code>,
<code><a href="#topic+fixYellow">fixYellow</a>()</code>,
<code><a href="#topic+fixYellowHue">fixYellowHue</a>()</code>,
<code><a href="#topic+getColorRamp">getColorRamp</a>()</code>,
<code><a href="#topic+hcl2col">hcl2col</a>()</code>,
<code><a href="#topic+hsl2col">hsl2col</a>()</code>,
<code><a href="#topic+hsv2col">hsv2col</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+makeColorDarker">makeColorDarker</a>()</code>,
<code><a href="#topic+rainbow2">rainbow2</a>()</code>,
<code><a href="#topic+rgb2col">rgb2col</a>()</code>,
<code><a href="#topic+setCLranges">setCLranges</a>()</code>,
<code><a href="#topic+setTextContrastColor">setTextContrastColor</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+unalpha">unalpha</a>()</code>,
<code><a href="#topic+warpRamp">warpRamp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isColor(c("red", "blue", "beige", "#99000099", "#aa00ff", "#AAE", "bleh"))

</code></pre>

<hr>
<h2 id='isFALSEV'>Vectorized isFALSE</h2><span id='topic+isFALSEV'></span>

<h3>Description</h3>

<p>Vectorized isFALSE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isFALSEV(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isFALSEV_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="isFALSEV_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function applies three criteria to an input vector, to
determine if each entry in the vector is FALSE:
</p>

<ol>
<li><p> It must be class <code>logical</code>.
</p>
</li>
<li><p> It must not be <code>NA</code>.
</p>
</li>
<li><p> It must evaluate as <code>FALSE</code>.
</p>
</li></ol>



<h3>Value</h3>

<p><code>logical</code> vector with length matching <code>x</code>.
</p>


<h3>See Also</h3>

<p>Other jam practical functions: 
<code><a href="#topic+breakDensity">breakDensity</a>()</code>,
<code><a href="#topic+call_fn_ellipsis">call_fn_ellipsis</a>()</code>,
<code><a href="#topic+checkLightMode">checkLightMode</a>()</code>,
<code><a href="#topic+check_pkg_installed">check_pkg_installed</a>()</code>,
<code><a href="#topic+colNum2excelName">colNum2excelName</a>()</code>,
<code><a href="#topic+color_dither">color_dither</a>()</code>,
<code><a href="#topic+exp2signed">exp2signed</a>()</code>,
<code><a href="#topic+getAxisLabel">getAxisLabel</a>()</code>,
<code><a href="#topic+isTRUEV">isTRUEV</a>()</code>,
<code><a href="#topic+jargs">jargs</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+lldf">lldf</a>()</code>,
<code><a href="#topic+log2signed">log2signed</a>()</code>,
<code><a href="#topic+middle">middle</a>()</code>,
<code><a href="#topic+minorLogTicks">minorLogTicks</a>()</code>,
<code><a href="#topic+newestFile">newestFile</a>()</code>,
<code><a href="#topic+printDebug">printDebug</a>()</code>,
<code><a href="#topic+reload_rmarkdown_cache">reload_rmarkdown_cache</a>()</code>,
<code><a href="#topic+renameColumn">renameColumn</a>()</code>,
<code><a href="#topic+rmInfinite">rmInfinite</a>()</code>,
<code><a href="#topic+rmNA">rmNA</a>()</code>,
<code><a href="#topic+rmNAs">rmNAs</a>()</code>,
<code><a href="#topic+rmNULL">rmNULL</a>()</code>,
<code><a href="#topic+setPrompt">setPrompt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isFALSEV(c(TRUE, FALSE, NA, TRUE))

</code></pre>

<hr>
<h2 id='isTRUEV'>Vectorized isTRUE</h2><span id='topic+isTRUEV'></span>

<h3>Description</h3>

<p>Vectorized isTRUE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isTRUEV(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isTRUEV_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="isTRUEV_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function applies three criteria to an input vector, to
determine if each entry in the vector is TRUE:
</p>

<ol>
<li><p> It must be class <code>logical</code>.
</p>
</li>
<li><p> It must not be <code>NA</code>.
</p>
</li>
<li><p> It must evaluate as <code>TRUE</code>.
</p>
</li></ol>



<h3>Value</h3>

<p><code>logical</code> vector with length matching <code>x</code>.
</p>


<h3>See Also</h3>

<p>Other jam practical functions: 
<code><a href="#topic+breakDensity">breakDensity</a>()</code>,
<code><a href="#topic+call_fn_ellipsis">call_fn_ellipsis</a>()</code>,
<code><a href="#topic+checkLightMode">checkLightMode</a>()</code>,
<code><a href="#topic+check_pkg_installed">check_pkg_installed</a>()</code>,
<code><a href="#topic+colNum2excelName">colNum2excelName</a>()</code>,
<code><a href="#topic+color_dither">color_dither</a>()</code>,
<code><a href="#topic+exp2signed">exp2signed</a>()</code>,
<code><a href="#topic+getAxisLabel">getAxisLabel</a>()</code>,
<code><a href="#topic+isFALSEV">isFALSEV</a>()</code>,
<code><a href="#topic+jargs">jargs</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+lldf">lldf</a>()</code>,
<code><a href="#topic+log2signed">log2signed</a>()</code>,
<code><a href="#topic+middle">middle</a>()</code>,
<code><a href="#topic+minorLogTicks">minorLogTicks</a>()</code>,
<code><a href="#topic+newestFile">newestFile</a>()</code>,
<code><a href="#topic+printDebug">printDebug</a>()</code>,
<code><a href="#topic+reload_rmarkdown_cache">reload_rmarkdown_cache</a>()</code>,
<code><a href="#topic+renameColumn">renameColumn</a>()</code>,
<code><a href="#topic+rmInfinite">rmInfinite</a>()</code>,
<code><a href="#topic+rmNA">rmNA</a>()</code>,
<code><a href="#topic+rmNAs">rmNAs</a>()</code>,
<code><a href="#topic+rmNULL">rmNULL</a>()</code>,
<code><a href="#topic+setPrompt">setPrompt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isTRUEV(c(TRUE, FALSE, NA, TRUE))

</code></pre>

<hr>
<h2 id='jam_rapply'>Jam-specific recursive apply</h2><span id='topic+jam_rapply'></span>

<h3>Description</h3>

<p>Jam-specific recursive apply
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jam_rapply(x, FUN, how = c("unlist", "list"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jam_rapply_+3A_x">x</code></td>
<td>
<p><code>list</code></p>
</td></tr>
<tr><td><code id="jam_rapply_+3A_fun">FUN</code></td>
<td>
<p><code>function</code> to be called on non-list elements in <code>x</code>.</p>
</td></tr>
<tr><td><code id="jam_rapply_+3A_how">how</code></td>
<td>
<p><code>character</code> string indicating whether to return the
<code>list</code> or whether to call <code>unlist()</code> on the result.</p>
</td></tr>
<tr><td><code id="jam_rapply_+3A_...">...</code></td>
<td>
<p>additional arguments are passed to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a very lightweight customization to <code>base::rapply()</code>,
specifically that it does not remove <code>NULL</code> entries.
</p>


<h3>Value</h3>

<p><code>vector</code> or <code>list</code> based upon argument <code>how</code>.
</p>


<h3>See Also</h3>

<p>Other jam list functions: 
<code><a href="#topic+cPaste">cPaste</a>()</code>,
<code><a href="#topic+heads">heads</a>()</code>,
<code><a href="#topic+list2df">list2df</a>()</code>,
<code><a href="#topic+mergeAllXY">mergeAllXY</a>()</code>,
<code><a href="#topic+mixedSorts">mixedSorts</a>()</code>,
<code><a href="#topic+rbindList">rbindList</a>()</code>,
<code><a href="#topic+relist_named">relist_named</a>()</code>,
<code><a href="#topic+rlengths">rlengths</a>()</code>,
<code><a href="#topic+sclass">sclass</a>()</code>,
<code><a href="#topic+sdim">sdim</a>()</code>,
<code><a href="#topic+uniques">uniques</a>()</code>,
<code><a href="#topic+unnestList">unnestList</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L &lt;- list(entryA=c("miR-112", "miR-12", "miR-112"),
   entryB=factor(c("A","B","A","B"),
      levels=c("B","A")),
   entryC=factor(c("C","A","B","B","C"),
      levels=c("A","B","C")),
   entryNULL=NULL)
rapply(L, length)
jam_rapply(L, length)

L0 &lt;- list(A=1:3, B=list(C=1:3, D=4:5, E=NULL));
rapply(L0, length)
jam_rapply(L0, length)

</code></pre>

<hr>
<h2 id='jamCalcDensity'>Calculate scatter plot point density</h2><span id='topic+jamCalcDensity'></span>

<h3>Description</h3>

<p>Calculate scatter plot point density
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jamCalcDensity(x, nbin, bandwidth = NULL, range.x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jamCalcDensity_+3A_x">x</code></td>
<td>
<p><code>numeric</code> matrix with two columns representing x,y coordinates.</p>
</td></tr>
<tr><td><code id="jamCalcDensity_+3A_nbin">nbin</code></td>
<td>
<p><code>integer</code> number of bins to subdivide the scatterplot,
expanded to length 2 to accommodate x and y axis bins.</p>
</td></tr>
<tr><td><code id="jamCalcDensity_+3A_bandwidth">bandwidth</code></td>
<td>
<p><code>numeric</code> or <code>NULL</code> representing the bandwidth used
for point density determination.</p>
</td></tr>
<tr><td><code id="jamCalcDensity_+3A_range.x">range.x</code></td>
<td>
<p><code>numeric</code> vector length 2 representing the range of
values to consider for point density.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called internally by <code>plotSmoothScatter()</code>,
and is an equivalent replacement for
<code>grDevices</code> non-exported function .smoothScatterCalcDensity(),
understandably a requirement by CRAN. A package should not rely
on another package hidden function.
</p>


<h3>Value</h3>

<p><code>list</code> with elements used internally by <code>plotSmoothScatter()</code>,
with: x1, x2, fhat, bandwidth.
</p>


<h3>See Also</h3>

<p>Other jam internal functions: 
<code><a href="#topic+handleArgsText">handleArgsText</a>()</code>,
<code><a href="#topic+make_html_styles">make_html_styles</a>()</code>,
<code><a href="#topic+make_styles">make_styles</a>()</code>,
<code><a href="#topic+smoothScatterJam">smoothScatterJam</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sdim(jamCalcDensity(cbind(x=rnorm(1000) + 4, y=rnorm(1000) + 4), nbin=30))

</code></pre>

<hr>
<h2 id='jargs'>Show R function arguments jam-style</h2><span id='topic+jargs'></span>

<h3>Description</h3>

<p>Show R function arguments jam-style
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jargs(
  x,
  grepString = NULL,
  sortVars = FALSE,
  useMessage = TRUE,
  asList = TRUE,
  useColor = TRUE,
  lightMode = NULL,
  Crange = getOption("jam.Crange"),
  Lrange = getOption("jam.Lrange"),
  adjustRgb = getOption("jam.adjustRgb"),
  useCollapseBase = ", ",
  verbose = FALSE,
  debug = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jargs_+3A_x">x</code></td>
<td>
<p><code>function</code> or character name of a function.</p>
</td></tr>
<tr><td><code id="jargs_+3A_grepstring">grepString</code></td>
<td>
<p><code>NULL</code>, <code>logical</code>, or <code>character</code> grep regular expression
pattern used to filter function arguments by name. Very useful to
search a function for arguments with a substring <code>"row"</code>.
</p>

<ul>
<li><p> If <code>logical</code>, it is assumed to be sortVars, and indicates whether
to sort the parameter names.
</p>
</li>
<li><p> if <code>character</code> it will subset the function arguments by name matching
this regular expression pattern.
</p>
</li></ul>
</td></tr>
<tr><td><code id="jargs_+3A_sortvars">sortVars</code></td>
<td>
<p><code>logical</code> whether to sort the function parameter names.
</p>

<ul>
<li> <p><code>sortVars=FALSE</code> returns arguments in the order they appear in the
function definition.
</p>
</li>
<li> <p><code>sortVars=TRUE</code> returns arguments sorted alphabetically.
</p>
</li></ul>
</td></tr>
<tr><td><code id="jargs_+3A_usemessage">useMessage</code></td>
<td>
<p><code>logical</code> default TRUE, whether to print output
using <code>message()</code>, otherwise text is returned invisibly to be
displayed separately.</p>
</td></tr>
<tr><td><code id="jargs_+3A_aslist">asList</code></td>
<td>
<p><code>logical</code> default TRUE, display one entry per line or
display results as a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="jargs_+3A_usecolor">useColor</code></td>
<td>
<p><code>logical</code> whether to display results in color, if the crayon
package is available, and terminal console is capable.</p>
</td></tr>
<tr><td><code id="jargs_+3A_lightmode">lightMode</code></td>
<td>
<p><code>logical</code> or <code>NULL</code>, indicating whether the text background
color is light, thus imposing a maximum brightness for colors displayed.
It use lightMode if defined by the function caller, otherwise it will
use <code>getOption("jam.lightMode")</code> if defined, lastly it will attempt to
detect whether running inside Rstudio by checking the environment variable
&quot;RSTUDIO&quot;, and if so it will assume lightMode==TRUE.</p>
</td></tr>
<tr><td><code id="jargs_+3A_crange">Crange</code></td>
<td>
<p><code>numeric</code> range of chroma values, ranging
between 0 and 100. When NULL, default values will be
assigned to Crange by <code>setCLranges()</code>.</p>
</td></tr>
<tr><td><code id="jargs_+3A_lrange">Lrange</code></td>
<td>
<p><code>numeric</code> range of luminance values, ranging
between 0 and 100. When NULL, default values will be
assigned to Lrange by <code>setCLranges()</code>.</p>
</td></tr>
<tr><td><code id="jargs_+3A_adjustrgb">adjustRgb</code></td>
<td>
<p><code>numeric</code> value adjustment used during the conversion of
RGB colors to ANSI colors, which is inherently lossy. If not defined,
it uses the default returned by <code>setCLranges()</code> which itself uses
<code>getOption("jam.adjustRgb")</code> with default=0. In order to boost
color contrast, an alternate value of -0.1 is suggested.</p>
</td></tr>
<tr><td><code id="jargs_+3A_usecollapsebase">useCollapseBase</code></td>
<td>
<p><code>character</code> string used to combine multiple parameter
values.</p>
</td></tr>
<tr><td><code id="jargs_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> whether to print verbose output.</p>
</td></tr>
<tr><td><code id="jargs_+3A_debug">debug</code></td>
<td>
<p><code>integer</code> value, greater than 0 will cause debug-type verbose
output, useful because parameters are hard!</p>
</td></tr>
<tr><td><code id="jargs_+3A_...">...</code></td>
<td>
<p>Additional arguments are installed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function displays R function arguments, organized with one argument
per line, and colorized using the <code>crayon</code> package if
installed.
</p>
<p>Output is nicely spaced to help visual alignment of argument names
and argument values.
</p>
<p>Output can be filtered by <code>character</code> pattern. For example the
function <code>ComplexHeatmap::Heatmap()</code> is amazing, and offers numerous
arguments. To find arguments relevant to dendrograms, use <code>"dend"</code>:
</p>
<p><code>jargs(ComplexHeatmap::Heatmap, "dend")</code>
</p>
<p>NOTE: This function has edge case issues displaying complex function
argument values such as nested lists and custom functions.
In that case the argument name is printed as usual, and the argument value
is displayed as a partial snippet of the default argument value.
</p>
<p>Generic functions very often contain no useful parameters,
making it difficult to discover required
parameters without reading the function documentation from the proper
dispatched function and calling package. In that case,
try using <code>jargs(functionname.default)</code> for example compare:
</p>
<p><code>jargs(barplot)</code>
</p>
<p>to:
</p>
<p><code>jargs(barplot.default)</code>
</p>


<h3>Value</h3>

<p><code>NULL</code> this function called for the byproduct of printing
its output.
</p>


<h3>See Also</h3>

<p>Other jam practical functions: 
<code><a href="#topic+breakDensity">breakDensity</a>()</code>,
<code><a href="#topic+call_fn_ellipsis">call_fn_ellipsis</a>()</code>,
<code><a href="#topic+checkLightMode">checkLightMode</a>()</code>,
<code><a href="#topic+check_pkg_installed">check_pkg_installed</a>()</code>,
<code><a href="#topic+colNum2excelName">colNum2excelName</a>()</code>,
<code><a href="#topic+color_dither">color_dither</a>()</code>,
<code><a href="#topic+exp2signed">exp2signed</a>()</code>,
<code><a href="#topic+getAxisLabel">getAxisLabel</a>()</code>,
<code><a href="#topic+isFALSEV">isFALSEV</a>()</code>,
<code><a href="#topic+isTRUEV">isTRUEV</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+lldf">lldf</a>()</code>,
<code><a href="#topic+log2signed">log2signed</a>()</code>,
<code><a href="#topic+middle">middle</a>()</code>,
<code><a href="#topic+minorLogTicks">minorLogTicks</a>()</code>,
<code><a href="#topic+newestFile">newestFile</a>()</code>,
<code><a href="#topic+printDebug">printDebug</a>()</code>,
<code><a href="#topic+reload_rmarkdown_cache">reload_rmarkdown_cache</a>()</code>,
<code><a href="#topic+renameColumn">renameColumn</a>()</code>,
<code><a href="#topic+rmInfinite">rmInfinite</a>()</code>,
<code><a href="#topic+rmNA">rmNA</a>()</code>,
<code><a href="#topic+rmNAs">rmNAs</a>()</code>,
<code><a href="#topic+rmNULL">rmNULL</a>()</code>,
<code><a href="#topic+setPrompt">setPrompt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>args(jargs)
jargs(jargs)

# retrieve parameters involving notes from imageByColors
jargs(imageByColors, "note")

</code></pre>

<hr>
<h2 id='kable_coloring'>Extend kableExtra colorization of 'Rmarkdown' tables</h2><span id='topic+kable_coloring'></span>

<h3>Description</h3>

<p>Extend kableExtra colorization of 'Rmarkdown' tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kable_coloring(
  df,
  colorSub = NULL,
  background_as_tile = TRUE,
  color_cells = TRUE,
  row_color_by = NULL,
  sep = "_",
  border_left = "1px solid #DDDDDD",
  border_right = FALSE,
  extra_css = "white-space: nowrap;",
  format = "html",
  format.args = list(trim = TRUE, big.mark = ","),
  row.names = NA,
  align = NULL,
  return_type = c("kable", "data.frame"),
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kable_coloring_+3A_df">df</code></td>
<td>
<p><code>data.frame</code> input. Note that <code>kable</code> input is not supported.</p>
</td></tr>
<tr><td><code id="kable_coloring_+3A_colorsub">colorSub</code></td>
<td>
<p>one of the following inputs:
</p>

<ul>
<li> <p><code>character</code> vector of R colors, whose names match entries
in the <code>data.frame</code> which are given these assigned colors
</p>
</li>
<li> <p><code>function</code> that takes column values as input, and returns
a <code>character</code> vector with one color per value, using <code>NA</code>
or <code>NULL</code> to indicate <code>"transparent"</code>
</p>
</li>
<li> <p><code>list</code> whose names match <code>colnames(df)</code>, where each entry
contains either <code>character</code> or <code>function</code> option as described
above. A <code>character</code> vector should be named by values expected
in each column. A <code>function</code> should take column values as input,
and return a <code>character</code> vector with same length of R colors.
</p>
</li></ul>
</td></tr>
<tr><td><code id="kable_coloring_+3A_background_as_tile">background_as_tile</code></td>
<td>
<p><code>logical</code> default <code>TRUE</code>, whether the
cell background color will appear as a rounded tile (<code>TRUE</code>)
or a rectangle (<code>FALSE</code>).
Either way, the color does not fill the entire whitespace
of the table cell, but only around the text itself.</p>
</td></tr>
<tr><td><code id="kable_coloring_+3A_color_cells">color_cells</code></td>
<td>
<p><code>logical</code> indicating whether to color individual cells,
default <code>TRUE</code>. This may be <code>FALSE</code> when also applying <code>row_color_by</code>,
so the entire row will be colorized.</p>
</td></tr>
<tr><td><code id="kable_coloring_+3A_row_color_by">row_color_by</code></td>
<td>
<p><code>character</code> vector with one or more <code>colnames</code>,
indicating how to colorize entire rows of a table.
When one column is defined, colors in <code>colorSub</code> are used as normal.
When multiple columns are defined, values from each column are
concatenated using <code>sep</code> delimiter. Then resulting values are
compared with <code>colorSub</code>.</p>
</td></tr>
<tr><td><code id="kable_coloring_+3A_sep">sep</code></td>
<td>
<p><code>character</code> delimiter used to combine values in multiple
columns when <code>row_color_by</code> is supplied and contains multiple
<code>colnames</code>. The delimited character strings are compared to
<code>colorSub</code> to assign colors.</p>
</td></tr>
<tr><td><code id="kable_coloring_+3A_border_left">border_left</code>, <code id="kable_coloring_+3A_border_right">border_right</code>, <code id="kable_coloring_+3A_extra_css">extra_css</code></td>
<td>
<p><code>character</code> values optionally
passed to <code>kableExtra::column_spec()</code> as a convenient way to apply
borders for each column (<code>border_left</code>, <code>border_right</code>) or enable
or disable word-wrapping by column. Some helpful examples:
</p>

<ul>
<li> <p><code>border_left=FALSE</code>: disables left border
</p>
</li>
<li> <p><code>border_left="1px solid #DDDDDD"</code>: light gray 1 pixel left border
</p>
</li>
<li> <p><code>border_right=FALSE</code>: disables right border
</p>
</li>
<li> <p><code>border_right="1px solid #DDDDDD"</code>: light gray 1 pixel right border
</p>
</li>
<li> <p><code>extra_css=NULL</code>: disables word-wrap
</p>
</li>
<li> <p><code>extra_css="whitespace: nowrap;"</code>: enables text word-wrap
</p>
</li>
<li><p> when all options above contain only <code>FALSE</code> or <code>NULL</code>, then
<code>kableExtra::column_spec()</code> is not applied.
</p>
</li></ul>
</td></tr>
<tr><td><code id="kable_coloring_+3A_format">format</code></td>
<td>
<p><code>character</code> passed to <code>knitr::kable()</code>, default <code>"html"</code>
which is the intended format for most scenarios.
It can be set to <code>NULL</code> to enable auto-detection of the format.</p>
</td></tr>
<tr><td><code id="kable_coloring_+3A_format.args">format.args</code></td>
<td>
<p><code>list</code> of arguments passed to <code>base::format()</code>
intended mainly for <code>numeric</code> columns.</p>
</td></tr>
<tr><td><code id="kable_coloring_+3A_row.names">row.names</code></td>
<td>
<p><code>logical</code> indicating whether to include <code>rownames(df)</code>.
When <code>row.names=NA</code> the default is to display rownames if they
are not <code>NULL</code> and not equal to <code>1:nrow(df)</code>.</p>
</td></tr>
<tr><td><code id="kable_coloring_+3A_align">align</code></td>
<td>
<p><code>character</code> passed to <code>kableExtra::kable()</code> to define
alignment of each column.</p>
</td></tr>
<tr><td><code id="kable_coloring_+3A_return_type">return_type</code></td>
<td>
<p><code>character</code> string indicating the type of data
to return.
</p>

<ul>
<li> <p><code>return_type="kable"</code>: (default) returns object with class
<code style="white-space: pre;">&#8288;"kableExtra", "knitr_kable"&#8288;</code> suitable for downstream processing.
</p>
</li>
<li> <p><code>return_type="data.frame"</code>: returns a <code>data.frame</code> whose cells
contain HTML markup with corresponding colors defined.
</p>
</li></ul>
</td></tr>
<tr><td><code id="kable_coloring_+3A_verbose">verbose</code></td>
<td>
<p>boolean indicating whether to print verbose output.</p>
</td></tr>
<tr><td><code id="kable_coloring_+3A_...">...</code></td>
<td>
<p>additional arguments are passed to <code>kableExtra::kable()</code>
which allows the usual customizations on the initial call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extends the <code>kableExtra</code> package, and is only
available for use if the <code>kableExtra</code> package is installed. It is
intended to allow specific color assignment of elements in a
data.frame, but otherwise uses the <code>kableExtra</code> functions to
apply those colors.
</p>
<p>The use case is to provide colorized HTML output for 'Rmarkdown',
it has not been tested with other <code>format</code> output.
</p>
<p>The argument <code>colorSub</code> accepts:
</p>

<ul>
<li> <p><code>character</code> vector input where
names should match column values
</p>
</li>
<li> <p><code>function</code> that accepts column values and returns a <code>character</code>
vector of colors of equal length
</p>
</li>
<li> <p><code>list</code> input where names should match <code>colnames(df)</code>, and where
each list element should contain either a <code>character</code> vector, or
<code>function</code> as described above.
</p>
</li></ul>



<h3>Value</h3>

<p>object with class <code>c("kableExtra", "knitr_kable")</code> by default
when <code>return_type="kable"</code>, suitable to render inside an 'Rmarkdown'
or HTML context. Or returns <code>data.frame</code> when <code>return_type="data.frame"</code>.
</p>


<h3>See Also</h3>

<p>Other jam color functions: 
<code><a href="#topic+alpha2col">alpha2col</a>()</code>,
<code><a href="#topic+applyCLrange">applyCLrange</a>()</code>,
<code><a href="#topic+col2alpha">col2alpha</a>()</code>,
<code><a href="#topic+col2hcl">col2hcl</a>()</code>,
<code><a href="#topic+col2hsl">col2hsl</a>()</code>,
<code><a href="#topic+col2hsv">col2hsv</a>()</code>,
<code><a href="#topic+color2gradient">color2gradient</a>()</code>,
<code><a href="#topic+fixYellow">fixYellow</a>()</code>,
<code><a href="#topic+fixYellowHue">fixYellowHue</a>()</code>,
<code><a href="#topic+getColorRamp">getColorRamp</a>()</code>,
<code><a href="#topic+hcl2col">hcl2col</a>()</code>,
<code><a href="#topic+hsl2col">hsl2col</a>()</code>,
<code><a href="#topic+hsv2col">hsv2col</a>()</code>,
<code><a href="#topic+isColor">isColor</a>()</code>,
<code><a href="#topic+makeColorDarker">makeColorDarker</a>()</code>,
<code><a href="#topic+rainbow2">rainbow2</a>()</code>,
<code><a href="#topic+rgb2col">rgb2col</a>()</code>,
<code><a href="#topic+setCLranges">setCLranges</a>()</code>,
<code><a href="#topic+setTextContrastColor">setTextContrastColor</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+unalpha">unalpha</a>()</code>,
<code><a href="#topic+warpRamp">warpRamp</a>()</code>
</p>
<p>Other jam practical functions: 
<code><a href="#topic+breakDensity">breakDensity</a>()</code>,
<code><a href="#topic+call_fn_ellipsis">call_fn_ellipsis</a>()</code>,
<code><a href="#topic+checkLightMode">checkLightMode</a>()</code>,
<code><a href="#topic+check_pkg_installed">check_pkg_installed</a>()</code>,
<code><a href="#topic+colNum2excelName">colNum2excelName</a>()</code>,
<code><a href="#topic+color_dither">color_dither</a>()</code>,
<code><a href="#topic+exp2signed">exp2signed</a>()</code>,
<code><a href="#topic+getAxisLabel">getAxisLabel</a>()</code>,
<code><a href="#topic+isFALSEV">isFALSEV</a>()</code>,
<code><a href="#topic+isTRUEV">isTRUEV</a>()</code>,
<code><a href="#topic+jargs">jargs</a>()</code>,
<code><a href="#topic+lldf">lldf</a>()</code>,
<code><a href="#topic+log2signed">log2signed</a>()</code>,
<code><a href="#topic+middle">middle</a>()</code>,
<code><a href="#topic+minorLogTicks">minorLogTicks</a>()</code>,
<code><a href="#topic+newestFile">newestFile</a>()</code>,
<code><a href="#topic+printDebug">printDebug</a>()</code>,
<code><a href="#topic+reload_rmarkdown_cache">reload_rmarkdown_cache</a>()</code>,
<code><a href="#topic+renameColumn">renameColumn</a>()</code>,
<code><a href="#topic+rmInfinite">rmInfinite</a>()</code>,
<code><a href="#topic+rmNA">rmNA</a>()</code>,
<code><a href="#topic+rmNAs">rmNAs</a>()</code>,
<code><a href="#topic+rmNULL">rmNULL</a>()</code>,
<code><a href="#topic+setPrompt">setPrompt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
expt_df &lt;- data.frame(
   Sample_ID="",
   Treatment=rep(c("Vehicle", "Dex"), each=6),
   Genotype=rep(c("Wildtype", "Knockout"), each=3),
   Rep=paste0("rep", c(1:3)))
expt_df$Sample_ID &lt;- pasteByRow(expt_df[, 2:4])

# define colors
colorSub &lt;- c(Vehicle="palegoldenrod",
   Dex="navy",
   Wildtype="gold",
   Knockout="firebrick",
   nameVector(
      color2gradient("grey48", n=3, dex=10),
      rep("rep", 3),
      suffix=""),
   nameVector(
      color2gradient(n=3,
         c("goldenrod1", "indianred3", "royalblue3", "darkorchid4")),
      expt_df$Sample_ID))
kbl &lt;- kable_coloring(
   expt_df,
   caption="Experiment design table showing categorical color assignment.",
   colorSub)
# Note that the HTML table is rendered in 'Rmarkdown', not pkgdown
kbl

# return_type="data.frame" is a data.frame with HTML contents
kdf3 &lt;- kable_coloring(
   return_type="data.frame",
   df=expt_df,
   colorSub=colorSub)
kdf3;

</code></pre>

<hr>
<h2 id='list2df'>Convert list of vectors to data.frame with item, value, name</h2><span id='topic+list2df'></span>

<h3>Description</h3>

<p>Convert list of vectors to data.frame with item, value, name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list2df(x, makeUnique = TRUE, useVectorNames = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list2df_+3A_x">x</code></td>
<td>
<p>list of vectors</p>
</td></tr>
<tr><td><code id="list2df_+3A_makeunique">makeUnique</code></td>
<td>
<p>logical indicating whether the data.frame should
contain unique rows.</p>
</td></tr>
<tr><td><code id="list2df_+3A_usevectornames">useVectorNames</code></td>
<td>
<p>logical indicating whether vector names should
be included in the data.frame, if they exist.</p>
</td></tr>
<tr><td><code id="list2df_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts a list of vectors to a tall data.frame
with colnames <code>item</code> to indicate the list name, <code>value</code> to indicate
the vector value, and <code>name</code> to indicate the vector name if
<code>useVectorNames=TRUE</code> and if names exist.
</p>


<h3>Value</h3>

<p><code>data.frame</code> with two columns, or three columns when
<code>useVectorNames=TRUE</code> and the input <code>x</code> contains names.
</p>


<h3>See Also</h3>

<p>Other jam list functions: 
<code><a href="#topic+cPaste">cPaste</a>()</code>,
<code><a href="#topic+heads">heads</a>()</code>,
<code><a href="#topic+jam_rapply">jam_rapply</a>()</code>,
<code><a href="#topic+mergeAllXY">mergeAllXY</a>()</code>,
<code><a href="#topic+mixedSorts">mixedSorts</a>()</code>,
<code><a href="#topic+rbindList">rbindList</a>()</code>,
<code><a href="#topic+relist_named">relist_named</a>()</code>,
<code><a href="#topic+rlengths">rlengths</a>()</code>,
<code><a href="#topic+sclass">sclass</a>()</code>,
<code><a href="#topic+sdim">sdim</a>()</code>,
<code><a href="#topic+uniques">uniques</a>()</code>,
<code><a href="#topic+unnestList">unnestList</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>list2df(list(lower=head(letters, 5), UPPER=head(LETTERS, 10)))

list2df(list(lower=nameVector(head(letters, 5)),
   UPPER=nameVector(head(LETTERS, 10))))

list2df(list(lower=nameVector(head(letters, 5)),
   UPPER=nameVector(head(LETTERS, 10))),
   useVectorNames=FALSE)

</code></pre>

<hr>
<h2 id='lldf'>Long listing of R session objects</h2><span id='topic+lldf'></span>

<h3>Description</h3>

<p>Long listing of R session objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lldf(
  n = Inf,
  envir = -1L,
  items = NULL,
  use_utils_objectsize = TRUE,
  all.names = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lldf_+3A_n">n</code></td>
<td>
<p><code>integer</code> or <code>Inf</code> indicating how many objects to
include in the output <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="lldf_+3A_envir">envir</code></td>
<td>
<p><code>environment</code> where the list of objects is obtained,
default <code>-1L</code> searches the environment of the caller, usually
the user workspace.
Other recognized options:
</p>

<ul>
<li> <p><code>character</code> string suitable for <code>as.environment()</code> which
recognizes the search path returned by <code>search()</code>
</p>
</li>
<li> <p><code>integer</code> or <code>numeric</code> equivalent to environment relative position
as used in <code>ls()</code> argument <code>pos</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="lldf_+3A_items">items</code></td>
<td>
<p><code>character</code> of items to include, default NULL.</p>
</td></tr>
<tr><td><code id="lldf_+3A_use_utils_objectsize">use_utils_objectsize</code></td>
<td>
<p><code>logical</code>, default TRUE, whether to prefer
<code>utils::object.size()</code>, otherwise it will attempt to use
<code>pryr::object_size()</code> if the package is installed.</p>
</td></tr>
<tr><td><code id="lldf_+3A_all.names">all.names</code></td>
<td>
<p><code>logical</code> passed to <code>base::ls()</code> indicating whether
to include all names, where <code>all.names=TRUE</code> will include
hidden objects whose name begin with <code>"."</code> such as <code>".First"</code>.</p>
</td></tr>
<tr><td><code id="lldf_+3A_...">...</code></td>
<td>
<p>additional arguments are passed to <code>ls()</code>, notably
<code>pattern</code> can be passed to subset objects by regular expression.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function expands <code>base::ls()</code> by also determining the
object size, and sorting to display the top <code>n</code> objects by
size, largest first.
</p>
<p>This package will call <code>pryr::object_size</code> if available,
otherwise falls back to <code>utils::object.size()</code>.
</p>


<h3>Value</h3>

<p><code>data.frame</code> with summary of objects and object sizes,
sorted by decreasing object size.
</p>


<h3>See Also</h3>

<p>Other jam practical functions: 
<code><a href="#topic+breakDensity">breakDensity</a>()</code>,
<code><a href="#topic+call_fn_ellipsis">call_fn_ellipsis</a>()</code>,
<code><a href="#topic+checkLightMode">checkLightMode</a>()</code>,
<code><a href="#topic+check_pkg_installed">check_pkg_installed</a>()</code>,
<code><a href="#topic+colNum2excelName">colNum2excelName</a>()</code>,
<code><a href="#topic+color_dither">color_dither</a>()</code>,
<code><a href="#topic+exp2signed">exp2signed</a>()</code>,
<code><a href="#topic+getAxisLabel">getAxisLabel</a>()</code>,
<code><a href="#topic+isFALSEV">isFALSEV</a>()</code>,
<code><a href="#topic+isTRUEV">isTRUEV</a>()</code>,
<code><a href="#topic+jargs">jargs</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+log2signed">log2signed</a>()</code>,
<code><a href="#topic+middle">middle</a>()</code>,
<code><a href="#topic+minorLogTicks">minorLogTicks</a>()</code>,
<code><a href="#topic+newestFile">newestFile</a>()</code>,
<code><a href="#topic+printDebug">printDebug</a>()</code>,
<code><a href="#topic+reload_rmarkdown_cache">reload_rmarkdown_cache</a>()</code>,
<code><a href="#topic+renameColumn">renameColumn</a>()</code>,
<code><a href="#topic+rmInfinite">rmInfinite</a>()</code>,
<code><a href="#topic+rmNA">rmNA</a>()</code>,
<code><a href="#topic+rmNAs">rmNAs</a>()</code>,
<code><a href="#topic+rmNULL">rmNULL</a>()</code>,
<code><a href="#topic+setPrompt">setPrompt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lldf(10);

# custom environment
newenv &lt;- new.env();
newenv$A &lt;- 1:10;
newenv$df &lt;- data.frame(A=1:10, B=11:20);
lldf(envir=newenv);
rm(newenv);

</code></pre>

<hr>
<h2 id='log2signed'>log2 transformation with directionality</h2><span id='topic+log2signed'></span>

<h3>Description</h3>

<p>log2 transformation with directionality
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log2signed(x, offset = 1, base = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log2signed_+3A_x">x</code></td>
<td>
<p><code>numeric</code> vector</p>
</td></tr>
<tr><td><code id="log2signed_+3A_offset">offset</code></td>
<td>
<p><code>numeric</code> value added to the absolute values
of <code>x</code> prior to applying the log transformation.</p>
</td></tr>
<tr><td><code id="log2signed_+3A_base">base</code></td>
<td>
<p><code>numeric</code> value indicating the logarithmic base,
by default <code>2</code> in order to apply <code>base::log2()</code>.</p>
</td></tr>
<tr><td><code id="log2signed_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function applies a log2 transformation but maintains
the sign of the input data, allowing for log2 transformation
of negative values.
</p>
<p>The method applies an offset to the absolute value <code>abs(x)</code>,
in order to handle values between zero and 1, then applies
log2 transformation, then multiplies by the original sign
from <code>sign(x)</code>.
</p>
<p>The argument <code>offset</code> is used to adjust values, for example
<code>offset=1</code> will apply log2 transformation <code>log2(1 + x)</code>,
except using the absolute value of <code>x</code>. This method allows
for positive and negative input data to contain values
between 0 and 1, and between -1 and 0.
</p>
<p>This function could be described as applying
a log2 transformation of the &quot;magnitude&quot; of values in <code>x</code>,
while maintaining the positive or negative directionality.
</p>
<p>If any <code>abs(x)</code> are less than <code>offset</code> this function will
raise an error.
</p>


<h3>Value</h3>

<p>numeric vector of log-transformed magnitudes.
</p>


<h3>See Also</h3>

<p>Other jam practical functions: 
<code><a href="#topic+breakDensity">breakDensity</a>()</code>,
<code><a href="#topic+call_fn_ellipsis">call_fn_ellipsis</a>()</code>,
<code><a href="#topic+checkLightMode">checkLightMode</a>()</code>,
<code><a href="#topic+check_pkg_installed">check_pkg_installed</a>()</code>,
<code><a href="#topic+colNum2excelName">colNum2excelName</a>()</code>,
<code><a href="#topic+color_dither">color_dither</a>()</code>,
<code><a href="#topic+exp2signed">exp2signed</a>()</code>,
<code><a href="#topic+getAxisLabel">getAxisLabel</a>()</code>,
<code><a href="#topic+isFALSEV">isFALSEV</a>()</code>,
<code><a href="#topic+isTRUEV">isTRUEV</a>()</code>,
<code><a href="#topic+jargs">jargs</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+lldf">lldf</a>()</code>,
<code><a href="#topic+middle">middle</a>()</code>,
<code><a href="#topic+minorLogTicks">minorLogTicks</a>()</code>,
<code><a href="#topic+newestFile">newestFile</a>()</code>,
<code><a href="#topic+printDebug">printDebug</a>()</code>,
<code><a href="#topic+reload_rmarkdown_cache">reload_rmarkdown_cache</a>()</code>,
<code><a href="#topic+renameColumn">renameColumn</a>()</code>,
<code><a href="#topic+rmInfinite">rmInfinite</a>()</code>,
<code><a href="#topic+rmNA">rmNA</a>()</code>,
<code><a href="#topic+rmNAs">rmNAs</a>()</code>,
<code><a href="#topic+rmNULL">rmNULL</a>()</code>,
<code><a href="#topic+setPrompt">setPrompt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(-100:100)/10;
log2signed(x);
plot(x=x, y=log2signed(x), xlab="x", ylab="log2signed(x)")

</code></pre>

<hr>
<h2 id='make_html_styles'>vectorized make_styles for html span output</h2><span id='topic+make_html_styles'></span>

<h3>Description</h3>

<p>vectorized make_styles for html span output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_html_styles(
  style = NULL,
  text,
  bg = FALSE,
  bg_style = NULL,
  grey = FALSE,
  Cgrey = getOption("jam.Cgrey"),
  lightMode = NULL,
  Crange = getOption("jam.Crange"),
  Lrange = getOption("jam.Lrange"),
  adjustRgb = getOption("jam.adjustRgb"),
  adjustPower = 1.5,
  fixYellow = TRUE,
  alphaPower = 2,
  setOptions = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_html_styles_+3A_style">style</code></td>
<td>
<p><code>character</code> vector of one or more styles. When <code>NULL</code> or <code>NA</code>,
no style is applied, except when <code>bg_style</code> is supplied
and is neither <code>NA</code> nor <code>NULL</code>, in which case entries with
a <code>bg_style</code> and no <code>style</code> will use <code>setTextContrastColor()</code>
to define a contrasting <code>style</code>.</p>
</td></tr>
<tr><td><code id="make_html_styles_+3A_text">text</code></td>
<td>
<p><code>character</code> vector (or coerced to <code>character</code>) of one or
more values,.</p>
</td></tr>
<tr><td><code id="make_html_styles_+3A_bg">bg</code></td>
<td>
<p><code>logical</code> indicating whether the <code>style</code> should be
applied to the background instead of foreground. This argument
is ignored when <code>bg_style</code> is supplied.</p>
</td></tr>
<tr><td><code id="make_html_styles_+3A_bg_style">bg_style</code></td>
<td>
<p><code>NULL</code> or a <code>character</code> vector of one or more background
styles. When this argument is not NULL, it applies both the foreground
<code>style</code> and background <code>bg_style</code> together, and therefore ignores
<code>Crange</code> and <code>Lrange</code> settings.</p>
</td></tr>
<tr><td><code id="make_html_styles_+3A_grey">grey</code></td>
<td>
<p><code>logical</code>, default FALSE, whether to use greyscale.</p>
</td></tr>
<tr><td><code id="make_html_styles_+3A_cgrey">Cgrey</code></td>
<td>
<p><code>numeric</code> chroma (C) value, which defines grey colors at or
below this chroma. Any colors at or below the grey cutoff will have
use ANSI greyscale coloring. To disable, set <code>Cgrey=-1</code>.</p>
</td></tr>
<tr><td><code id="make_html_styles_+3A_lightmode">lightMode</code></td>
<td>
<p><code>logical</code> indicating whether the background color
is light (TRUE is bright), or dark (FALSE is dark.) By default
it calls <code>checkLightMode()</code> which queries <code>getOption("lightMode")</code>.</p>
</td></tr>
<tr><td><code id="make_html_styles_+3A_crange">Crange</code></td>
<td>
<p><code>numeric</code> range of chroma values, ranging
between 0 and 100. When NULL, default values will be
assigned to Crange. When supplied, range(Crange) is used.</p>
</td></tr>
<tr><td><code id="make_html_styles_+3A_lrange">Lrange</code></td>
<td>
<p><code>numeric</code> range of luminance values, ranging
between 0 and 100. When NULL, default values will be
assigned to Lrange. When supplied, range(Lrange) is used.</p>
</td></tr>
<tr><td><code id="make_html_styles_+3A_adjustrgb">adjustRgb</code></td>
<td>
<p><code>numeric</code> value adjustment used during the conversion of
RGB colors to ANSI colors, which is inherently lossy. If not defined,
it uses the default returned by <code>setCLranges()</code> which itself uses
<code>getOption("jam.adjustRgb")</code> with default=0. In order to boost
color contrast, an alternate value of -0.1 is suggested.</p>
</td></tr>
<tr><td><code id="make_html_styles_+3A_adjustpower">adjustPower</code></td>
<td>
<p><code>numeric</code> adjustment power factor</p>
</td></tr>
<tr><td><code id="make_html_styles_+3A_fixyellow">fixYellow</code></td>
<td>
<p><code>logical</code> indicating whether to &quot;fix&quot; the darkening of
yellow, which otherwise turns to green. Instead, since JAM can,
JAM will make the yellow slightly more golden before darkening. This
change only affects color hues between 80 and 90. This argument is
passed to <code>applyCLrange()</code>.</p>
</td></tr>
<tr><td><code id="make_html_styles_+3A_alphapower">alphaPower</code></td>
<td>
<p><code>numeric</code> value, used to adjust the RGB values for alpha
values less than 255, by raising the ratio to 1/alphaPower, which takes
the ratio of square roots.  alphaPower=100 for minimal adjustment.</p>
</td></tr>
<tr><td><code id="make_html_styles_+3A_setoptions">setOptions</code></td>
<td>
<p><code>character</code> or <code>logical</code> whether to update
<code>Crange</code> and <code>Lrange</code> options during the subsequent call to
<code>setCLranges()</code>. By default,
</p>

<ul>
<li> <p><code>"ifnull"</code> will update only options which were previously <code>NULL</code>;
</p>
</li>
<li> <p><code>"FALSE"</code> prevents modifying the global options;
</p>
</li>
<li> <p><code>"TRUE"</code> will update these options with the current values.
</p>
</li></ul>
</td></tr>
<tr><td><code id="make_html_styles_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating whether to print verbose output</p>
</td></tr>
<tr><td><code id="make_html_styles_+3A_...">...</code></td>
<td>
<p>additional parameters are ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note this function is experimental.
</p>


<h3>Value</h3>

<p><code>character</code> vector with the same length as <code>text</code> input vector,
where entries are surrounded by the relevant HTML consistent with
the <code>style</code> defined at input. In short, a character vector as input,
colorized HTML character vector as output.
</p>


<h3>See Also</h3>

<p>Other jam internal functions: 
<code><a href="#topic+handleArgsText">handleArgsText</a>()</code>,
<code><a href="#topic+jamCalcDensity">jamCalcDensity</a>()</code>,
<code><a href="#topic+make_styles">make_styles</a>()</code>,
<code><a href="#topic+smoothScatterJam">smoothScatterJam</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_html_styles(style=c("red", "orange"), text=c("one ", "two"))

</code></pre>

<hr>
<h2 id='make_styles'>vectorized make_styles for crayon output</h2><span id='topic+make_styles'></span>

<h3>Description</h3>

<p>vectorized make_styles for crayon output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_styles(
  style = NULL,
  text,
  bg = FALSE,
  bg_style = NULL,
  grey = FALSE,
  colors = NULL,
  Cgrey = getOption("jam.Cgrey", 5),
  lightMode = NULL,
  Crange = getOption("jam.Crange"),
  Lrange = getOption("jam.Lrange"),
  adjustRgb = getOption("jam.adjustRgb"),
  adjustPower = 1.5,
  fixYellow = TRUE,
  colorTransparent = "grey45",
  alphaPower = 2,
  setOptions = c("ifnull", "FALSE", "TRUE"),
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_styles_+3A_style">style</code></td>
<td>
<p><code>character</code> vector of one or more styles. When <code>NULL</code> or <code>NA</code>,
no style is applied, except when <code>bg_style</code> is supplied
and is neither <code>NA</code> nor <code>NULL</code>, in which case entries with
a <code>bg_style</code> and no <code>style</code> will use <code>setTextContrastColor()</code>
to define a contrasting <code>style</code>.</p>
</td></tr>
<tr><td><code id="make_styles_+3A_text">text</code></td>
<td>
<p><code>character</code> vector (or coerced to <code>character</code>) of one or
more values,.</p>
</td></tr>
<tr><td><code id="make_styles_+3A_bg">bg</code></td>
<td>
<p><code>logical</code> indicating whether the <code>style</code> should be
applied to the background instead of foreground. This argument
is ignored when <code>bg_style</code> is supplied.</p>
</td></tr>
<tr><td><code id="make_styles_+3A_bg_style">bg_style</code></td>
<td>
<p><code>NULL</code> or a <code>character</code> vector of one or more background
styles. When this argument is not NULL, it applies both the foreground
<code>style</code> and background <code>bg_style</code> together, and therefore ignores
<code>Crange</code> and <code>Lrange</code> settings.</p>
</td></tr>
<tr><td><code id="make_styles_+3A_grey">grey</code></td>
<td>
<p><code>logical</code>, default FALSE, whether to use greyscale.</p>
</td></tr>
<tr><td><code id="make_styles_+3A_colors">colors</code></td>
<td>
<p><code>integer</code>, default NULL, number of colors for console output,
when NULL it calls <code>crayon::num_colors()</code> to detect console
capabilities.</p>
</td></tr>
<tr><td><code id="make_styles_+3A_cgrey">Cgrey</code></td>
<td>
<p><code>numeric</code> chroma (C) value, which defines grey colors at or
below this chroma. Any colors at or below the grey cutoff will have
use ANSI greyscale coloring. To disable, set <code>Cgrey=-1</code>.</p>
</td></tr>
<tr><td><code id="make_styles_+3A_lightmode">lightMode</code></td>
<td>
<p><code>logical</code> indicating whether the background color
is light (TRUE is bright), or dark (FALSE is dark.) By default
it calls <code>checkLightMode()</code> which queries <code>getOption("lightMode")</code>.</p>
</td></tr>
<tr><td><code id="make_styles_+3A_crange">Crange</code></td>
<td>
<p><code>numeric</code> range of chroma values, ranging
between 0 and 100. When NULL, default values will be
assigned to Crange. When supplied, range(Crange) is used.</p>
</td></tr>
<tr><td><code id="make_styles_+3A_lrange">Lrange</code></td>
<td>
<p><code>numeric</code> range of luminance values, ranging
between 0 and 100. When NULL, default values will be
assigned to Lrange. When supplied, range(Lrange) is used.</p>
</td></tr>
<tr><td><code id="make_styles_+3A_adjustrgb">adjustRgb</code></td>
<td>
<p><code>numeric</code> value adjustment used during the conversion of
RGB colors to ANSI colors, which is inherently lossy. If not defined,
it uses the default returned by <code>setCLranges()</code> which itself uses
<code>getOption("jam.adjustRgb")</code> with default=0. In order to boost
color contrast, an alternate value of -0.1 is suggested.</p>
</td></tr>
<tr><td><code id="make_styles_+3A_adjustpower">adjustPower</code></td>
<td>
<p><code>numeric</code> adjustment power factor</p>
</td></tr>
<tr><td><code id="make_styles_+3A_fixyellow">fixYellow</code></td>
<td>
<p><code>logical</code> indicating whether to &quot;fix&quot; the darkening of
yellow, which otherwise turns to green. Instead, since JAM can,
JAM will make the yellow slightly more golden before darkening. This
change only affects color hues between 80 and 90. This argument is
passed to <code>applyCLrange()</code>.</p>
</td></tr>
<tr><td><code id="make_styles_+3A_colortransparent">colorTransparent</code></td>
<td>
<p><code>character</code> color used to substitute for
&quot;transparent&quot; which a valid R color, but not a valid color for
the crayon package.</p>
</td></tr>
<tr><td><code id="make_styles_+3A_alphapower">alphaPower</code></td>
<td>
<p><code>numeric</code> value, used to adjust the RGB values for alpha
values less than 255, by raising the ratio to 1/alphaPower, which takes
the ratio of square roots.  alphaPower=100 for minimal adjustment.</p>
</td></tr>
<tr><td><code id="make_styles_+3A_setoptions">setOptions</code></td>
<td>
<p><code>character</code> or <code>logical</code> whether to update
<code>Crange</code> and <code>Lrange</code> options during the subsequent call to
<code>setCLranges()</code>. By default,
</p>

<ul>
<li> <p><code>"ifnull"</code> will update only options which were previously <code>NULL</code>;
</p>
</li>
<li> <p><code>"FALSE"</code> prevents modifying the global options;
</p>
</li>
<li> <p><code>"TRUE"</code> will update these options with the current values.
</p>
</li></ul>
</td></tr>
<tr><td><code id="make_styles_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating whether to print verbose output</p>
</td></tr>
<tr><td><code id="make_styles_+3A_...">...</code></td>
<td>
<p>additional parameters are ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is essentially a vectorized version of
<code>crayon::make_style()</code> in order to style a vector of
character strings with a vector of foreground and background styles.
</p>


<h3>Value</h3>

<p><code>character</code> vector with the same length as <code>text</code> input vector,
where entries are surrounded by the relevant encoding consistent with
the <code>style</code> defined at input. In short, a character vector as input,
a colorized character vector as output.
</p>


<h3>See Also</h3>

<p>Other jam internal functions: 
<code><a href="#topic+handleArgsText">handleArgsText</a>()</code>,
<code><a href="#topic+jamCalcDensity">jamCalcDensity</a>()</code>,
<code><a href="#topic+make_html_styles">make_html_styles</a>()</code>,
<code><a href="#topic+smoothScatterJam">smoothScatterJam</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cat(make_styles(style=c("red", "yellow"), text=c("one ", "two")), "\n")

</code></pre>

<hr>
<h2 id='makeColorDarker'>make R colors darker (or lighter)</h2><span id='topic+makeColorDarker'></span>

<h3>Description</h3>

<p>Makes R colors darker or lighter based upon darkFactor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeColorDarker(
  hexColor,
  darkFactor = 2,
  sFactor = 1,
  fixAlpha = NULL,
  verbose = FALSE,
  keepNA = FALSE,
  useMethod = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeColorDarker_+3A_hexcolor">hexColor</code></td>
<td>
<p><code>character</code> vector of colors to adjust</p>
</td></tr>
<tr><td><code id="makeColorDarker_+3A_darkfactor">darkFactor</code></td>
<td>
<p><code>numeric</code> value to adjust darkness, values above 1
make the color darker, values below 1 (or below 0) make the color
brighter.</p>
</td></tr>
<tr><td><code id="makeColorDarker_+3A_sfactor">sFactor</code></td>
<td>
<p><code>numeric</code> value to adjust saturation, values above 1
become more saturated.</p>
</td></tr>
<tr><td><code id="makeColorDarker_+3A_fixalpha">fixAlpha</code></td>
<td>
<p><code>numeric</code>, default NULL, to assign a fixed alpha
transparency value, where 0 is transparent and 1 is opaque.</p>
</td></tr>
<tr><td><code id="makeColorDarker_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating whether to print verbose output.</p>
</td></tr>
<tr><td><code id="makeColorDarker_+3A_keepna">keepNA</code></td>
<td>
<p><code>logical</code>, default FALSE, whether to keep NA values
as NA values in the output, otherwise NA values are considered grey
input.</p>
</td></tr>
<tr><td><code id="makeColorDarker_+3A_usemethod">useMethod</code></td>
<td>
<p><code>integer</code> with two alternate methods, <code>1</code> is default.</p>
</td></tr>
<tr><td><code id="makeColorDarker_+3A_...">...</code></td>
<td>
<p>Additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was originally intended to create border colors, or to
create slightly darker colors used for labels. It is also useful for
for making colors lighter, in adjusting color saturation up or down,
or applying alpha transparency during the same step.
</p>
<p>Note when colors are brightened beyond value=1, the saturation is
gradually reduced in order to produce a visibly lighter color. The
saturation minimu is set to 0.2, to maintain at least some amount of
color.
</p>


<h3>Value</h3>

<p><code>character</code> vector of R colors.
</p>


<h3>See Also</h3>

<p>Other jam color functions: 
<code><a href="#topic+alpha2col">alpha2col</a>()</code>,
<code><a href="#topic+applyCLrange">applyCLrange</a>()</code>,
<code><a href="#topic+col2alpha">col2alpha</a>()</code>,
<code><a href="#topic+col2hcl">col2hcl</a>()</code>,
<code><a href="#topic+col2hsl">col2hsl</a>()</code>,
<code><a href="#topic+col2hsv">col2hsv</a>()</code>,
<code><a href="#topic+color2gradient">color2gradient</a>()</code>,
<code><a href="#topic+fixYellow">fixYellow</a>()</code>,
<code><a href="#topic+fixYellowHue">fixYellowHue</a>()</code>,
<code><a href="#topic+getColorRamp">getColorRamp</a>()</code>,
<code><a href="#topic+hcl2col">hcl2col</a>()</code>,
<code><a href="#topic+hsl2col">hsl2col</a>()</code>,
<code><a href="#topic+hsv2col">hsv2col</a>()</code>,
<code><a href="#topic+isColor">isColor</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+rainbow2">rainbow2</a>()</code>,
<code><a href="#topic+rgb2col">rgb2col</a>()</code>,
<code><a href="#topic+setCLranges">setCLranges</a>()</code>,
<code><a href="#topic+setTextContrastColor">setTextContrastColor</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+unalpha">unalpha</a>()</code>,
<code><a href="#topic+warpRamp">warpRamp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>colorV &lt;- c("red","orange","purple","blue");
colorVdark2 &lt;- makeColorDarker(colorV, darkFactor=2);
colorVlite2 &lt;- makeColorDarker(colorV, darkFactor=-2);
showColors(cexCellnote=0.7,
   list(
   `darkFactor=2`=colorVdark2,
   `original colors`=colorV,
   `darkFactor=-2`=colorVlite2
   ));

# these adjustments work really well inside a network diagram
# when coloring nodes, and providing an outline of comparable
# color.
plot(x=c(1,2,1,2), y=c(1,2,2,1), pch=21,
   xaxt="n", yaxt="n", xlab="", ylab="",
   xlim=c(0.5,2.5), ylim=c(0.5,2.5),
   bg=colorV, col=colorVdark2, cex=4, lwd=2);
graphics::points(x=c(1,2,1,2), y=c(1,2,2,1), pch=20, cex=4,
   col=colorVlite2);

# Making a color lighter can make it easier to add labels
# The setTextContrastColor() function also helps.
graphics::text(x=c(1,2,1,2), y=c(1,2,2,1), 1:4,
   col=setTextContrastColor(colorVlite2));

</code></pre>

<hr>
<h2 id='makeNames'>make unique vector names</h2><span id='topic+makeNames'></span>

<h3>Description</h3>

<p>make unique vector names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeNames(
  x,
  unique = TRUE,
  suffix = "_v",
  renameOnes = FALSE,
  doPadInteger = FALSE,
  startN = 1,
  numberStyle = c("number", "letters", "LETTERS"),
  useNchar = NULL,
  renameFirst = TRUE,
  keepNA = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeNames_+3A_x">x</code></td>
<td>
<p>character vector to be used when defining names. All other
vector types will be coerced to character prior to use.</p>
</td></tr>
<tr><td><code id="makeNames_+3A_unique">unique</code></td>
<td>
<p>argument which is ignored, included only for
compatibility with <code>base::make.names</code>. All results from
<code>makeNames()</code> are unique.</p>
</td></tr>
<tr><td><code id="makeNames_+3A_suffix">suffix</code></td>
<td>
<p>character separator between the original entry and the
version, if necessary.</p>
</td></tr>
<tr><td><code id="makeNames_+3A_renameones">renameOnes</code></td>
<td>
<p>logical whether to rename single, unduplicated, entries.</p>
</td></tr>
<tr><td><code id="makeNames_+3A_dopadinteger">doPadInteger</code></td>
<td>
<p>logical whether to pad integer values to a consistent
number of digits, based upon all suffix values needed. This output
allows for more consistent sorting of names. To define a fixed number
of digits, use the useNchar parameter.</p>
</td></tr>
<tr><td><code id="makeNames_+3A_startn">startN</code></td>
<td>
<p>integer number used when numberStyle is &quot;number&quot;, this integer
is used for the first entry to be renamed. You can use this value to
make zero-based suffix values, for example.</p>
</td></tr>
<tr><td><code id="makeNames_+3A_numberstyle">numberStyle</code></td>
<td>
<p>character style for version numbering
</p>

<dl>
<dt>&quot;number&quot;</dt><dd><p>Use integer numbers to represent each duplicated
entry.</p>
</dd>
<dt>&quot;letters&quot;</dt><dd><p>Use lowercase letters to represent each duplicated
entry. The 27th entry uses the pattern &quot;aa&quot; to represent two
26-base digits. When doPadInteger=TRUE, a zero is still used
to pad the resulting version numbers, again to allow easy sorting
of text values, but also because there is no letter equivalent
for the number zero.
It is usually best to change the suffix to &quot;_&quot; or &quot;&quot; when using
&quot;letters&quot;.</p>
</dd>
<dt>&quot;LETTERS&quot;</dt><dd><p>Use uppercase letters to represent each duplicated
entry, with the same rules as applied to &quot;letters&quot;.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="makeNames_+3A_usenchar">useNchar</code></td>
<td>
<p>integer or NULL, number of digits to use when padding
integer values with leading zero, only relevant when usePadInteger=TRUE.</p>
</td></tr>
<tr><td><code id="makeNames_+3A_renamefirst">renameFirst</code></td>
<td>
<p>logical whether to rename the first entry in a set of
duplicated entries. If FALSE then the first entry in a set will not
be versioned, even when renameOnes=TRUE.</p>
</td></tr>
<tr><td><code id="makeNames_+3A_keepna">keepNA</code></td>
<td>
<p>logical whether to retain NA values using the string &quot;NA&quot;.
If keepNA is FALSE, then NA values will remain NA, thus causing some
names to become <code style="white-space: pre;">&#8288;&lt;NA&gt;&#8288;</code>, which can cause problems with some downstream
functions which assume all names are either NULL or non-NA.</p>
</td></tr>
<tr><td><code id="makeNames_+3A_...">...</code></td>
<td>
<p>Additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extends the basic goal from <code><a href="base.html#topic+make.names">make.names</a></code>
which is intended to make syntactically valid names from a character vector.
This makeNames function makes names unique, and offers configurable methods
to handle duplicate names. By default, any duplicated entries receive a
suffix _v# where # is s running count of entries observed, starting at 1.
The <code><a href="base.html#topic+make.names">make.names</a></code> function, by contrast, renames the
second observed entry starting at .1, leaving the original entry
unchanged. Optionally, makeNames can rename all entries with a numeric
suffix, for consistency.
</p>
<p>For example:
<code>A, A, A, B, B, C</code>
becomes:
<code>A_v1, A_v2, A_v3, B_v1, B_v2, C</code>
</p>
<p>Also, makeNames always allows &quot;_&quot;.
</p>
<p>This makeNames function is similar to <code><a href="base.html#topic+make.unique">make.unique</a></code>
which also converts a vector into a unique vector by adding suffix values,
however the <code><a href="base.html#topic+make.unique">make.unique</a></code> function intends to allow
repeated operations which recognize duplicated entries and continually
increment the suffix number. This makeNames function currently does not
handle repeat operations. The recommended approach to workaround having
pre-existing versioned names would be to remove suffix values prior to
running this function. One small distinction from
<code><a href="base.html#topic+make.unique">make.unique</a></code> is that makeNames does version the first
entry in a set.
</p>


<h3>Value</h3>

<p>character vector of unique names
</p>


<h3>See Also</h3>

<p>Other jam string functions: 
<code><a href="#topic+asSize">asSize</a>()</code>,
<code><a href="#topic+breaksByVector">breaksByVector</a>()</code>,
<code><a href="#topic+fillBlanks">fillBlanks</a>()</code>,
<code><a href="#topic+formatInt">formatInt</a>()</code>,
<code><a href="#topic+gsubOrdered">gsubOrdered</a>()</code>,
<code><a href="#topic+gsubs">gsubs</a>()</code>,
<code><a href="#topic+nameVector">nameVector</a>()</code>,
<code><a href="#topic+nameVectorN">nameVectorN</a>()</code>,
<code><a href="#topic+padInteger">padInteger</a>()</code>,
<code><a href="#topic+padString">padString</a>()</code>,
<code><a href="#topic+pasteByRow">pasteByRow</a>()</code>,
<code><a href="#topic+pasteByRowOrdered">pasteByRowOrdered</a>()</code>,
<code><a href="#topic+sizeAsNum">sizeAsNum</a>()</code>,
<code><a href="#topic+tcount">tcount</a>()</code>,
<code><a href="#topic+ucfirst">ucfirst</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>V &lt;- rep(LETTERS[1:3], c(2,3,1));
makeNames(V);
makeNames(V, renameOnes=TRUE);
makeNames(V, renameFirst=FALSE);
exons &lt;- makeNames(rep("exon", 3), suffix="");
makeNames(rep(exons, c(2,3,1)), numberStyle="letters", suffix="");

</code></pre>

<hr>
<h2 id='mergeAllXY'>Merge list of data.frames retaining all rows</h2><span id='topic+mergeAllXY'></span>

<h3>Description</h3>

<p>Merge list of data.frames retaining all rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeAllXY(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mergeAllXY_+3A_...">...</code></td>
<td>
<p>arguments are handled as described:
</p>

<ul>
<li><p> named arguments are passed through to <code>base::merge.data.frame()</code>,
with the exception of <code>all.x</code> and <code>all.y</code> which are both defined
<code>all.x=TRUE</code> and <code>all.y=TRUE</code>.
and all other arguments are assumed
to be <code>data.frame</code> or equivalent, and are merged in order they
appear as arguments. The order of these <code>data.frame</code> objects
should not affect the output content, but will affect the row
and column order of the resulting <code>data.frame</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper around <code>base::merge.data.frame()</code>
except that it allows more than two data.frame objects,
and applies default arguments <code>all.x=TRUE</code> and <code>all.y=TRUE</code>
for each merge operation to ensure that all rows are kept.
</p>


<h3>Value</h3>

<p><code>data.frame</code> after iterative calls to <code>base::merge.data.frame()</code>.
</p>


<h3>See Also</h3>

<p>Other jam list functions: 
<code><a href="#topic+cPaste">cPaste</a>()</code>,
<code><a href="#topic+heads">heads</a>()</code>,
<code><a href="#topic+jam_rapply">jam_rapply</a>()</code>,
<code><a href="#topic+list2df">list2df</a>()</code>,
<code><a href="#topic+mixedSorts">mixedSorts</a>()</code>,
<code><a href="#topic+rbindList">rbindList</a>()</code>,
<code><a href="#topic+relist_named">relist_named</a>()</code>,
<code><a href="#topic+rlengths">rlengths</a>()</code>,
<code><a href="#topic+sclass">sclass</a>()</code>,
<code><a href="#topic+sdim">sdim</a>()</code>,
<code><a href="#topic+uniques">uniques</a>()</code>,
<code><a href="#topic+unnestList">unnestList</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- data.frame(City=c("New York", "Los Angeles", "San Francisco"),
   State=c("New York", "California", "California"))
df2 &lt;- data.frame(Team=c("Yankees", "Mets", "Giants", "Dodgers"),
   City=c("New York", "New York", "San Francisco", "Los Angeles"))
df3 &lt;- data.frame(State=c("New York", "California"),
   `State Population`=c(39.24e9, 8.468e9),
   check.names=FALSE)
mergeAllXY(df1, df3, df2)

df4 &lt;- data.frame(check.names=FALSE,
   CellLine=rep(c("ul3", "dH1A", "dH1B"), each=2),
   Treatment=c("Vehicle", "Dex"))
df4$CellLine &lt;- factor(df4$CellLine,
   levels=c("ul3", "dH1A", "dH1B"))
df4$Treatment &lt;- factor(df4$Treatment,
   levels=c("Vehicle", "Dex"))
df5 &lt;- data.frame(
   Treatment=rep(c("Vehicle", "Dex"), each=3),
   Time=c("0h", "12h", "24h"))
df6 &lt;- data.frame(check.names=FALSE,
   CellLine=c("ul3", "dH1A", "dH1B"),
   Type=c("Control", "KO", "KO"))
mergeAllXY(df4, df5, df6)

# note the factor order is maintained
mergeAllXY(df4, df5, df6)$CellLine
mergeAllXY(df4, df5)$Treatment

# merge "all" can append rows to a data.frame
df4b &lt;- data.frame(check.names=FALSE,
   CellLine=rep("dH1C", 2),
   Treatment=c("Vehicle", "Dex"))
mergeAllXY(df4, df4b)

# factor order is maintained, new levels are appended
mergeAllXY(df4, df4b)$CellLine

# merge proceeds except shows missing data
mergeAllXY(df4, df4b, df5, df6)

# note that appending rows is tricky, the following is incorrect
df6b &lt;- data.frame(check.names=FALSE,
   CellLine="dH1C",
   Type="KO")
mergeAllXY(df4, df4b, df5, df6, df6b)

# but it can be resolved by merging df6 and df6b
mergeAllXY(df4, df4b, df5, mergeAllXY(df6, df6b))

# it may be easier to recognize by sorting with mixedSortDF()
mixedSortDF(honorFactor=TRUE,
   mergeAllXY(df4, df4b, df5, mergeAllXY(df6, df6b)))

# again, factor order is maintained
mergeAllXY(df4, df4b, df5, sort=FALSE, mergeAllXY(df6, df6b))$CellLine

# the result can be sorted properly
mixedSortDF(honorFactor=TRUE,
   mergeAllXY(df4, df4b, df5, mergeAllXY(df6, df6b)))

</code></pre>

<hr>
<h2 id='middle'>Return the middle portion of data similar to head and tail</h2><span id='topic+middle'></span>

<h3>Description</h3>

<p>Return the middle portion of data similar to head and tail
</p>


<h3>Usage</h3>

<pre><code class='language-R'>middle(x, n = 10, evenly = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="middle_+3A_x">x</code></td>
<td>
<p>input data that can be subset</p>
</td></tr>
<tr><td><code id="middle_+3A_n">n</code></td>
<td>
<p><code>numeric</code> number of entries to return</p>
</td></tr>
<tr><td><code id="middle_+3A_evenly">evenly</code></td>
<td>
<p><code>logical</code> indicating whether to return evenly spaced
entries along the full length of <code>x</code>. When <code>evenly=FALSE</code> only
the middle <code>n</code> entries are returned.</p>
</td></tr>
<tr><td><code id="middle_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is very simple, and is intended to mimic <code>head()</code>
and <code>tail()</code> to inspect data without looking at every value
</p>


<h3>Value</h3>

<p>an object of class equivalent to <code>x</code>.
</p>


<h3>See Also</h3>

<p>Other jam practical functions: 
<code><a href="#topic+breakDensity">breakDensity</a>()</code>,
<code><a href="#topic+call_fn_ellipsis">call_fn_ellipsis</a>()</code>,
<code><a href="#topic+checkLightMode">checkLightMode</a>()</code>,
<code><a href="#topic+check_pkg_installed">check_pkg_installed</a>()</code>,
<code><a href="#topic+colNum2excelName">colNum2excelName</a>()</code>,
<code><a href="#topic+color_dither">color_dither</a>()</code>,
<code><a href="#topic+exp2signed">exp2signed</a>()</code>,
<code><a href="#topic+getAxisLabel">getAxisLabel</a>()</code>,
<code><a href="#topic+isFALSEV">isFALSEV</a>()</code>,
<code><a href="#topic+isTRUEV">isTRUEV</a>()</code>,
<code><a href="#topic+jargs">jargs</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+lldf">lldf</a>()</code>,
<code><a href="#topic+log2signed">log2signed</a>()</code>,
<code><a href="#topic+minorLogTicks">minorLogTicks</a>()</code>,
<code><a href="#topic+newestFile">newestFile</a>()</code>,
<code><a href="#topic+printDebug">printDebug</a>()</code>,
<code><a href="#topic+reload_rmarkdown_cache">reload_rmarkdown_cache</a>()</code>,
<code><a href="#topic+renameColumn">renameColumn</a>()</code>,
<code><a href="#topic+rmInfinite">rmInfinite</a>()</code>,
<code><a href="#topic+rmNA">rmNA</a>()</code>,
<code><a href="#topic+rmNAs">rmNAs</a>()</code>,
<code><a href="#topic+rmNULL">rmNULL</a>()</code>,
<code><a href="#topic+setPrompt">setPrompt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:101;
middle(x);
middle(x, evenly=TRUE)

xdf &lt;- data.frame(n=1:101,
   excel_colname=jamba::colNum2excelName(1:101));
middle(xdf)
middle(xdf, evenly=TRUE)

</code></pre>

<hr>
<h2 id='minorLogTicks'>Calculate major and minor tick marks for log-scale axis</h2><span id='topic+minorLogTicks'></span>

<h3>Description</h3>

<p>Calculate major and minor tick marks for log-scale axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minorLogTicks(
  side = NULL,
  lims = NULL,
  logBase = 2,
  displayBase = 10,
  logStep = 1,
  minorWhich = c(2, 5),
  asValues = TRUE,
  offset = 0,
  symmetricZero = (offset &gt; 0),
  col = "black",
  col.ticks = col,
  combine = FALSE,
  logAxisType = c("normal", "flip", "pvalue"),
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="minorLogTicks_+3A_side">side</code></td>
<td>
<p><code>integer</code> value indicating which axis to produce tick
marks, 1=bottom, 2=left, 3=top, 4=right.</p>
</td></tr>
<tr><td><code id="minorLogTicks_+3A_lims">lims</code></td>
<td>
<p><code>numeric</code> vector length=2, indicating specific numeric
range to use for tick marks.</p>
</td></tr>
<tr><td><code id="minorLogTicks_+3A_logbase">logBase</code></td>
<td>
<p><code>numeric</code> value indicating the logarithmic base, assumed
to be applied to the numeric <code>lims</code> limits, or the axis range,
previously.</p>
</td></tr>
<tr><td><code id="minorLogTicks_+3A_displaybase">displayBase</code></td>
<td>
<p><code>numeric</code> value indicating the base used to position
axis labels, typically <code>displayBase=10</code> is used to draw labels
at typical positions.</p>
</td></tr>
<tr><td><code id="minorLogTicks_+3A_logstep">logStep</code></td>
<td>
<p><code>integer</code> value indicating the number of log steps
between major axis label positions. Typically <code>logStep=1</code> will
draw a label every log position based upon <code>displayBase</code>, for
example <code>displayBase=10</code> and <code>logStep=1</code> will use <code>c(1,10,100,1000)</code>;
and <code>displayBase=10</code> and <code>logStep=2</code> would use <code>c(1,100,10000)</code>.</p>
</td></tr>
<tr><td><code id="minorLogTicks_+3A_minorwhich">minorWhich</code></td>
<td>
<p><code>integer</code> vector of values to label, where those
integer values are between 1 and <code>displayBase</code>, for example
<code>displayBase=10</code> may label only <code>c(2,5)</code>, which implies minor
tick labels at <code>c(2, 5, 20, 50, 200, 500)</code>. Any minor labels
which would otherwise equal a major tick position are removed.
By default, when <code>displayBase=2</code>, <code>minorWhich=c(1.5)</code> which has the
effect of drawing one minor label between each two-fold
major tick label.</p>
</td></tr>
<tr><td><code id="minorLogTicks_+3A_asvalues">asValues</code></td>
<td>
<p><code>logical</code> indicating whether to create exponentiated
numeric labels. When <code>asValues=FALSE</code>, it creates <code>expression</code> objects
which include the exponential value. Use <code>asValues=FALSE</code> and
<code>logAxisType="pvalue"</code> to draw P-value labels.</p>
</td></tr>
<tr><td><code id="minorLogTicks_+3A_offset">offset</code></td>
<td>
<p><code>numeric</code> value added during log transformation, typically
of the form <code>log(1 + x)</code> where <code>offset=1</code>. The offset is used to
determine the accurate numeric label such that values of <code>0</code> are
properly labeled by the original numeric value.</p>
</td></tr>
<tr><td><code id="minorLogTicks_+3A_symmetriczero">symmetricZero</code></td>
<td>
<p><code>logical</code> indicating whether numeric values
are symmetric around zero. For example, log fold changes should
use <code>symmetricZero=TRUE</code> which ensures a log2 value of <code>-2</code> is
labeled <code>-4</code> to indicate a negative four fold change. If
<code>symmetricZero=FALSE</code> a log2 value of <code>-2</code> would be labeled
<code>0.0625</code>.</p>
</td></tr>
<tr><td><code id="minorLogTicks_+3A_col">col</code>, <code id="minorLogTicks_+3A_col.ticks">col.ticks</code></td>
<td>
<p><code>character</code> color used for the axis label, and
axis tick marks, respectively, default &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="minorLogTicks_+3A_combine">combine</code></td>
<td>
<p><code>logical</code>, default FALSE, whether to combine major and
minor ticks into one continuous set of major tick marks.</p>
</td></tr>
<tr><td><code id="minorLogTicks_+3A_logaxistype">logAxisType</code></td>
<td>
<p><code>character</code> string indicating the type of log axis:
</p>

<ul>
<li><p> normal: typical axis style and orientation
</p>
</li>
<li><p> flipped: used for reverse orientation
</p>
</li>
<li><p> pvalue: used for <code>-log10(pvalue)</code> orientation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="minorLogTicks_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating whether to print verbose output.</p>
</td></tr>
<tr><td><code id="minorLogTicks_+3A_...">...</code></td>
<td>
<p>additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called by <code>minorLogTicksAxis()</code>, and
it may be better to use that function, or <code>logFoldAxis()</code>
or <code>pvalueAxis()</code> which has better preset options.
</p>
<p>This function calculates log units for the axis of an
existing base R plot.
It calculates appropriate tick and label positions for:
</p>

<ul>
<li><p> major steps, which are typically in log steps; and
</p>
</li>
<li><p> minor steps, which are typically a subset of steps at one
lower log order.
</p>
</li></ul>

<p>For example, log 10 steps would be: <code>c(1, 10, 100, 1000)</code>,
and minor steps would be <code>c(2, 5, 20, 50, 200, 500, 2000, 5000)</code>.
</p>


<h4>Motivation</h4>

<p>This function is motivated to fill a few difficult cases:
</p>

<ol>
<li><p> Label axis ticks properly
when used together with <code>offset</code>. For example <code>log2(1 + x)</code>
uses <code>offset=1</code>. Other offsets can be used as relevant.
</p>
</li>
<li><p> Create axis labels which indicate negative fold change
values, for example <code>-2</code> in log2 fold change units would
be labeled with fold change <code>-4</code>, and not <code>0.0625</code>.
</p>
</li>
<li><p> Use symmetric tick marks around x=0 when applied to log fold changes.
</p>
</li>
<li><p> Display actual P-values when plotting <code>log10(Pvalue)</code>, which
is common for volcano plots.
</p>
</li></ol>




<h3>Value</h3>

<p><code>list</code> of axis tick positions, and corresponding labels,
for major and minor ticks. Note that labels may be <code>numeric</code>,
<code>character</code>, or <code>expression</code>. Specifically when <code>expression</code>
the <code>graphics::axis()</code> must be called once per label.
</p>

<ul>
<li><p> majorTicks: <code>numeric</code> position of each major tick mark
</p>
</li>
<li><p> minorTicks: <code>numeric</code> position of each minor tick mark
</p>
</li>
<li><p> allTicks: <code>numeric</code> position of each major tick mark
</p>
</li>
<li><p> majorLabels: label to show for each tick mark
</p>
</li>
<li><p> minorLabels: label to show for each tick mark
</p>
</li>
<li><p> minorSet: the <code>numeric</code> steps requested for minor ticks
</p>
</li>
<li><p> minorWhich: the <code>numeric</code> steps requested for minor labels
</p>
</li>
<li><p> allLabelsDF: <code>data.frame</code> with all tick marks and labels, with
colname <code>"use"</code> indicating whether the label is displayed beside
each tick mark.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other jam practical functions: 
<code><a href="#topic+breakDensity">breakDensity</a>()</code>,
<code><a href="#topic+call_fn_ellipsis">call_fn_ellipsis</a>()</code>,
<code><a href="#topic+checkLightMode">checkLightMode</a>()</code>,
<code><a href="#topic+check_pkg_installed">check_pkg_installed</a>()</code>,
<code><a href="#topic+colNum2excelName">colNum2excelName</a>()</code>,
<code><a href="#topic+color_dither">color_dither</a>()</code>,
<code><a href="#topic+exp2signed">exp2signed</a>()</code>,
<code><a href="#topic+getAxisLabel">getAxisLabel</a>()</code>,
<code><a href="#topic+isFALSEV">isFALSEV</a>()</code>,
<code><a href="#topic+isTRUEV">isTRUEV</a>()</code>,
<code><a href="#topic+jargs">jargs</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+lldf">lldf</a>()</code>,
<code><a href="#topic+log2signed">log2signed</a>()</code>,
<code><a href="#topic+middle">middle</a>()</code>,
<code><a href="#topic+newestFile">newestFile</a>()</code>,
<code><a href="#topic+printDebug">printDebug</a>()</code>,
<code><a href="#topic+reload_rmarkdown_cache">reload_rmarkdown_cache</a>()</code>,
<code><a href="#topic+renameColumn">renameColumn</a>()</code>,
<code><a href="#topic+rmInfinite">rmInfinite</a>()</code>,
<code><a href="#topic+rmNA">rmNA</a>()</code>,
<code><a href="#topic+rmNAs">rmNAs</a>()</code>,
<code><a href="#topic+rmNULL">rmNULL</a>()</code>,
<code><a href="#topic+setPrompt">setPrompt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This example shows how to draw axis labels manually,
## but the function minorLogTicksAxis() is easier to use.
xlim &lt;- c(0,4);
nullPlot(xlim=xlim, doMargins=FALSE);
mlt &lt;- minorLogTicks(1,
   logBase=10,
   offset=1,
   minTick=0);
maj &lt;- subset(mlt$allLabelsDF, type %in% "major");
graphics::axis(1, las=2,
   at=maj$tick, label=maj$text);
min &lt;- subset(mlt$allLabelsDF, type %in% "minor");
graphics::axis(1, las=2, cex.axis=0.7,
   at=min$tick, label=min$text,
   col="blue");
graphics::text(x=log10(1+c(0,5,50,1000)), y=rep(1.7, 4),
   label=c(0,5,50,1000), srt=90);

nullPlot(xlim=c(-4,10), doMargins=FALSE);
abline(v=0, lty=2)
graphics::axis(3, las=2);
minorLogTicksAxis(1, logBase=2, displayBase=10, symmetricZero=TRUE);

nullPlot(xlim=c(-4,10), doMargins=FALSE);
graphics::axis(3, las=2);
minorLogTicksAxis(1, logBase=2, displayBase=10, offset=1);
x2 &lt;- stats::rnorm(1000) * 40;
d2 &lt;- stats::density(log2(1+abs(x2)) * ifelse(x2&lt;0, -1, 1));
lines(x=d2$x, y=normScale(d2$y)+1, col="green4");

nullPlot(xlim=c(0,10), doMargins=FALSE);
graphics::axis(3, las=2);
minorLogTicksAxis(1, logBase=2, displayBase=10, offset=1);
x1 &lt;- c(0, 5, 15, 200);
graphics::text(y=rep(1.0, 4), x=log2(1+x1), label=x1, srt=90, adj=c(0,0.5));
graphics::points(y=rep(0.95, 4), x=log2(1+x1), pch=20, cex=2, col="blue");

</code></pre>

<hr>
<h2 id='minorLogTicksAxis'>Display major and minor tick marks for log-scale axis</h2><span id='topic+minorLogTicksAxis'></span><span id='topic+logFoldAxis'></span><span id='topic+pvalueAxis'></span>

<h3>Description</h3>

<p>Display major and minor tick marks for log-scale axis,
with optional offset for proper labeling of <code>log2(1+x)</code>
with numeric offset.
</p>
<p>Log fold axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minorLogTicksAxis(
  side = NULL,
  lims = NULL,
  logBase = 2,
  displayBase = 10,
  offset = 0,
  symmetricZero = (offset &gt; 0),
  majorCex = 1,
  minorCex = 0.65,
  doMajor = TRUE,
  doMinor = TRUE,
  doLabels = TRUE,
  doMinorLabels = TRUE,
  asValues = TRUE,
  logAxisType = c("normal", "flip", "pvalue"),
  padj = NULL,
  doFormat = TRUE,
  big.mark = ",",
  scipen = 10,
  minorWhich = c(2, 5),
  logStep = 1,
  cex = 1,
  las = 2,
  col = "black",
  col.ticks = col,
  minorLogTicksData = NULL,
  verbose = FALSE,
  ...
)

logFoldAxis(
  side = NULL,
  lims = NULL,
  logBase = 2,
  displayBase = 2,
  offset = 0,
  symmetricZero = TRUE,
  asValues = TRUE,
  minorWhich = NULL,
  doMinor = TRUE,
  doMinorLabels = NULL,
  scipen = 1,
  ...
)

pvalueAxis(
  side = 2,
  lims = NULL,
  displayBase = 10,
  logBase = 10,
  logAxisType = "pvalue",
  asValues = FALSE,
  doMinor = FALSE,
  doMinorLabels = FALSE,
  scipen = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="minorLogTicksAxis_+3A_side">side</code></td>
<td>
<p><code>integer</code> indicating the axis side, 1=bottom, 2=left,
3=top, 4=right.</p>
</td></tr>
<tr><td><code id="minorLogTicksAxis_+3A_lims">lims</code></td>
<td>
<p>NULL or <code>numeric</code> range for which the axis tick marks
will be determined.
If NULL then the corresponding <code>graphics::par("usr")</code>
will be used.</p>
</td></tr>
<tr><td><code id="minorLogTicksAxis_+3A_logbase">logBase</code></td>
<td>
<p><code>numeric</code> value indicating the log base units, which
will be used similar to how <code>base</code> is used in <code>log(x, base)</code>.</p>
</td></tr>
<tr><td><code id="minorLogTicksAxis_+3A_displaybase">displayBase</code></td>
<td>
<p><code>numeric</code> value indicating the log base units to
use when determining the numeric label position. For example,
data may be log2 scaled, and yet it is visually intuitive to
show log transformed axis units in base 10 units. See examples.</p>
</td></tr>
<tr><td><code id="minorLogTicksAxis_+3A_offset">offset</code></td>
<td>
<p><code>numeric</code> offset used in transforming the
numeric data displayed on this axis. For example, a common
technique is to transform data using <code>log2(1+x)</code> which adds
<code>1</code> to values prior to the log2 transformation. In this case,
<code>offset=1</code>, which ensures the axis labels exactly
match the initial numeric value prior to the log2 transform.</p>
</td></tr>
<tr><td><code id="minorLogTicksAxis_+3A_symmetriczero">symmetricZero</code></td>
<td>
<p><code>logical</code> indicating whether numeric values
are symmetric around zero. For example, log fold changes should
use <code>symmetricZero=TRUE</code> which ensures a log2 value of <code>-2</code> is
labeled <code>-4</code> to indicate a negative four fold change. If
<code>symmetricZero=FALSE</code> a log2 value of <code>-2</code> would be labeled
<code>0.0625</code>.</p>
</td></tr>
<tr><td><code id="minorLogTicksAxis_+3A_majorcex">majorCex</code>, <code id="minorLogTicksAxis_+3A_minorcex">minorCex</code></td>
<td>
<p><code>numeric</code> base text size factors, relative
to cex=1 for default text size. These factors are applied in
addition to existing <code>graphics::par("cex")</code> values, preserving any
global text size defined there.</p>
</td></tr>
<tr><td><code id="minorLogTicksAxis_+3A_domajor">doMajor</code>, <code id="minorLogTicksAxis_+3A_dominor">doMinor</code>, <code id="minorLogTicksAxis_+3A_dolabels">doLabels</code>, <code id="minorLogTicksAxis_+3A_dominorlabels">doMinorLabels</code></td>
<td>
<p><code>logical</code>, default TRUE,
whether to display each type of tick and label.
</p>

<ul>
<li> <p><code>doMajor</code> display major ticks, at <code>displayBase</code> positions
</p>
</li>
<li> <p><code>doMinor</code> display minor ticks at intermediate positions
</p>
</li>
<li> <p><code>doLabels</code> display any labels
</p>
</li>
<li> <p><code>doMinorLabels</code> display minor labels
</p>
</li></ul>
</td></tr>
<tr><td><code id="minorLogTicksAxis_+3A_asvalues">asValues</code></td>
<td>
<p><code>logical</code>, default TRUE, whether to print the
exponentiated value, otherwise FALSE will print the log value.</p>
</td></tr>
<tr><td><code id="minorLogTicksAxis_+3A_logaxistype">logAxisType</code></td>
<td>
<p><code>character</code> string with the type of axis values:
</p>

<ul>
<li> <p><code>"normal"</code>: axis values as-is.
</p>
</li>
<li> <p><code>"flip"</code>: inverted axis values, for example where negative values
should be displayed as negative log-transformed values.
</p>
</li>
<li> <p><code>"pvalue"</code>: for values transformed as <code>-log10(pvalue)</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="minorLogTicksAxis_+3A_padj">padj</code></td>
<td>
<p><code>numeric</code> vector length 2, which is used to position
axis labels for the minor and major labels, respectively. For
example, <code>padj=c(0,1)</code> will position minor labels just to the
left of the tick marks, and major labels just to the right
of tick marks. This example is helpful when minor labels bunch
up on the right side of each section.</p>
</td></tr>
<tr><td><code id="minorLogTicksAxis_+3A_doformat">doFormat</code></td>
<td>
<p><code>logical</code> indicating whether to apply <code>base::format()</code> to
format numeric labels.</p>
</td></tr>
<tr><td><code id="minorLogTicksAxis_+3A_big.mark">big.mark</code>, <code id="minorLogTicksAxis_+3A_scipen">scipen</code></td>
<td>
<p>arguments passed to <code>base::format()</code> when
<code>doFormat=TRUE</code>.</p>
</td></tr>
<tr><td><code id="minorLogTicksAxis_+3A_minorwhich">minorWhich</code></td>
<td>
<p><code>integer</code> vector indicating which of the minor tick
marks should be labeled. Labels are generally numbered from <code>2</code>
to <code>displayBase-1</code>. So by default, log 10 units would add
minor tick marks and labels to the <code>c(2,5)</code> position. For log2
units only, the second label is defined at 1.5, which shows
minor labels at <code>c(3, 6, 12)</code>, which are <code>1.5 * c(2, 4, 8)</code>.</p>
</td></tr>
<tr><td><code id="minorLogTicksAxis_+3A_logstep">logStep</code></td>
<td>
<p><code>integer</code> the number of log units per &quot;step&quot;, typically <code>1</code>.</p>
</td></tr>
<tr><td><code id="minorLogTicksAxis_+3A_cex">cex</code>, <code id="minorLogTicksAxis_+3A_col">col</code>, <code id="minorLogTicksAxis_+3A_col.ticks">col.ticks</code>, <code id="minorLogTicksAxis_+3A_las">las</code></td>
<td>
<p>parameters used for axis label size,
axis label colors,
axis tick mark colors, and label text orientation, respectively.</p>
</td></tr>
<tr><td><code id="minorLogTicksAxis_+3A_minorlogticksdata">minorLogTicksData</code></td>
<td>
<p><code>list</code> object created by running
<code>jamba::minorLogTicks()</code>, which allows inspecting and modifying
the content for custom control.</p>
</td></tr>
<tr><td><code id="minorLogTicksAxis_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating whether to print verbose output.</p>
</td></tr>
<tr><td><code id="minorLogTicksAxis_+3A_...">...</code></td>
<td>
<p>Additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function displays log units on the axis of an
existing base R plot. It calls <code>jamba::minorLogTicks()</code> which
calculates appropriate tick and label positions.
</p>
<p>Note: This function assumes the axis values have already been
log-transformed. Make sure to adjust the <code>offset</code> to reflect
the method of log-transformation, for example:
</p>

<ul>
<li> <p><code>log2(1+x)</code> would require <code>logBase=2</code> and <code>offset=1</code> in order
to represent values properly at or near zero.
</p>
</li>
<li> <p><code>log(0.5+x)</code> would require <code>logBase=exp(1)</code> and <code>offset=0.5</code>.
</p>
</li>
<li> <p><code>log10(x)</code> would require <code>logBase=10</code> and <code>offset=0</code>.
</p>
</li></ul>

<p>The defaults <code>logBase=2</code> and <code>displayBase=10</code> assume data
has been log2-transformed, and displays tick marks using the
common base of 10. To display tick marks at two-fold intervals,
use <code>displayBase=2</code>.
</p>
<p>This function was motivated in order to label log-transformed
data properly in some special cases, like using <code>log2(1+x)</code>
where the resulting values are shifted &quot;off by one&quot; using
standard log-scaled axis tick marks and labels.
</p>
<p>For log fold changes, set <code>symmetricZero=TRUE</code>, which will
create negative log scaled fold change values as needed for
negative values. For example, this option would label a
<code>logBase=2</code> value of <code>-2</code> as <code>-4</code> and not as <code>0.25</code>.
</p>
<p>Note that by default, whenever <code>offset &gt; 0</code> the argument
<code>symmetricZero=TRUE</code> is also defined, since a negative value in
that scenario has little meaning. This behavior can be turned
off by setting <code>symmetricZero=FALSE</code>.
</p>


<h3>Value</h3>

<p><code>list</code> with vectors:
</p>

<ul>
<li> <p><code>majorLabels</code>: <code>character</code> vector of major axis labels
</p>
</li>
<li> <p><code>majorTicks</code>: <code>numeric</code> vector of major axis tick positions
</p>
</li>
<li> <p><code>minorLabels</code>: <code>character</code> vector of minor axis labels
</p>
</li>
<li> <p><code>minorTicks</code>: <code>numeric</code> vector of minor axis tick positions
</p>
</li>
<li> <p><code>allLabelsDF</code>: <code>data.frame</code> containing all axis tick
positions and corresponding labels.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other jam plot functions: 
<code><a href="#topic+adjustAxisLabelMargins">adjustAxisLabelMargins</a>()</code>,
<code><a href="#topic+coordPresets">coordPresets</a>()</code>,
<code><a href="#topic+decideMfrow">decideMfrow</a>()</code>,
<code><a href="#topic+drawLabels">drawLabels</a>()</code>,
<code><a href="#topic+getPlotAspect">getPlotAspect</a>()</code>,
<code><a href="#topic+groupedAxis">groupedAxis</a>()</code>,
<code><a href="#topic+imageByColors">imageByColors</a>()</code>,
<code><a href="#topic+imageDefault">imageDefault</a>()</code>,
<code><a href="#topic+nullPlot">nullPlot</a>()</code>,
<code><a href="#topic+plotPolygonDensity">plotPolygonDensity</a>()</code>,
<code><a href="#topic+plotRidges">plotRidges</a>()</code>,
<code><a href="#topic+plotSmoothScatter">plotSmoothScatter</a>()</code>,
<code><a href="#topic+shadowText">shadowText</a>()</code>,
<code><a href="#topic+shadowText_options">shadowText_options</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+sqrtAxis">sqrtAxis</a>()</code>,
<code><a href="#topic+usrBox">usrBox</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plotPolygonDensity(0:100, breaks=100);

plotPolygonDensity(0:100, breaks=50, log="x",
   main="plotPolygonDensity() uses minorLogTicksAxis()",
   xlab="x (log-scaled)");

plotPolygonDensity(log2(1+0:100), breaks=50,
   main="manually called minorLogTicksAxis(logBase=2)",
   xaxt="n",
   xlab="x (log-scaled)");
minorLogTicksAxis(1, offset=1, logBase=2);

plotPolygonDensity(log10(1+0:100), breaks=50,
   main="manually called minorLogTicksAxis(logBase=10)",
   xaxt="n",
   xlab="x (log-scaled)");
minorLogTicksAxis(1, offset=1, logBase=10);

# example with log fold axes
k &lt;- c(-5:5)
plot(x=k, y=k, xaxt="n", yaxt="n",
   xlab="log2 base, displaying tick marks with log10 intervals",
   ylab="log2 base, displaying tick marks with log2 intervals")
axis(3, las=2)
axis(4, las=2)
lfax &lt;- logFoldAxis(side=1, logBase=2, displayBase=2)
lfay &lt;- logFoldAxis(side=2, logBase=2, displayBase=10)
# optionally add x-axis ablines
abline(v=lfax$allTicks, lty="dotted", col="grey88")
abline(v=lfax$majorTicks, lty="dashed", col="grey82")
# optionally add y-axis ablines
abline(h=lfay$allTicks, lty="dotted", col="grey88")
abline(h=lfay$majorTicks, lty="dashed", col="grey82")

# example showing volcano plot features
set.seed(123);
n &lt;- 1000;
vdf &lt;- data.frame(lfc=rnorm(n) * 2)
vdf$`-log10 (padj)` &lt;- abs(vdf$lfc) * abs(rnorm(n))
plotSmoothScatter(vdf, xaxt="n", yaxt="n", xlab="Fold change",
   main="Volcano plot\ndisplayBase=2")
logFoldAxis(1)
pvalueAxis(2)

plotSmoothScatter(vdf, xaxt="n", yaxt="n", xlab="Fold change",
   main="Volcano plot\ndisplayBase=10")
logFoldAxis(1, displayBase=10)
pvalueAxis(2)
</code></pre>

<hr>
<h2 id='mixedOrder'>order alphanumeric values keeping numeric values in proper order</h2><span id='topic+mixedOrder'></span>

<h3>Description</h3>

<p>order alphanumeric values keeping numeric values in proper order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixedOrder(
  x,
  ...,
  blanksFirst = TRUE,
  na.last = NAlast,
  keepNegative = FALSE,
  keepInfinite = FALSE,
  keepDecimal = FALSE,
  ignore.case = TRUE,
  useCaseTiebreak = TRUE,
  honorFactor = FALSE,
  returnDebug = FALSE,
  returnType = c("order", "rank"),
  NAlast = TRUE,
  verbose = FALSE,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixedOrder_+3A_x">x</code></td>
<td>
<p>input vector</p>
</td></tr>
<tr><td><code id="mixedOrder_+3A_...">...</code></td>
<td>
<p>additional parameters are sent to <code>mixedOrder()</code>.</p>
</td></tr>
<tr><td><code id="mixedOrder_+3A_blanksfirst">blanksFirst</code></td>
<td>
<p><code>logical</code> whether to order blank entries before entries
containing a value.</p>
</td></tr>
<tr><td><code id="mixedOrder_+3A_na.last">na.last</code></td>
<td>
<p><code>logical</code> whether to move NA entries to the end of the sort.
When <code>na.last=TRUE</code> then <code>NA</code> values will always be last, even following
blanks and infinite values. When <code>na.last=FALSE</code> then <code>NA</code> values
will always be first, even before blanks and negative infinite values.</p>
</td></tr>
<tr><td><code id="mixedOrder_+3A_keepnegative">keepNegative</code></td>
<td>
<p><code>logical</code> whether to keep '-' associated with adjacent
numeric values, in order to sort them as negative values. Note that
<code>keepNegative=TRUE</code> also forces <code>keepDecimal=TRUE</code>, and enables
matching of scientific notation such as <code>-1.23e-10</code> as a numeric
value. When <code>keepNegative=FALSE</code> the dash <code>"-"</code> is treated as
a common delimiter.</p>
</td></tr>
<tr><td><code id="mixedOrder_+3A_keepinfinite">keepInfinite</code></td>
<td>
<p><code>logical</code> whether to allow &quot;Inf&quot; in the input <code>x</code>
to be considered a numeric infinite value. Note that <code>"-Inf"</code> is
only treated as a negative infinite value when <code>keepNegative=TRUE</code>.
Also note that <code>"Inf"</code> is only recognized as infinite when it
appears between non-character delimiters, and not part of a
larger character string like <code>"Information"</code>. Be careful
with <code>keepInfinite=TRUE</code> when sorting gene symbols, there are
gene symbols like <code>"Inf3"</code> which should not be sorted as infinite.
Lastly, infinite values are sorted at the end, notably after
all character values which differs from some mixed sorting
algorithms.</p>
</td></tr>
<tr><td><code id="mixedOrder_+3A_keepdecimal">keepDecimal</code></td>
<td>
<p><code>logical</code> whether to keep the decimal in numbers,
sorting as a true number and not as a version number. By default
<code style="white-space: pre;">&#8288;keepDecimal=FALSE``, which means "v1.200" will be ordered after "v1.30", since it considers &#8288;</code>&quot;1.200&quot;<code style="white-space: pre;">&#8288;effectively as&#8288;</code>1<code>and</code>200<code style="white-space: pre;">&#8288;, and &#8288;</code>&quot;1.30&quot;<code style="white-space: pre;">&#8288;effectively as&#8288;</code>1<code>and</code>30<code style="white-space: pre;">&#8288;. When &#8288;</code>keepDecimal=TRUE<code style="white-space: pre;">&#8288;, the numeric sort orders &#8288;</code>&quot;v1.200&quot;<code>before</code>&quot;v1.30&quot;'.</p>
</td></tr>
<tr><td><code id="mixedOrder_+3A_ignore.case">ignore.case</code></td>
<td>
<p><code>logical</code> whether to ignore uppercase and lowercase
characters when defining the sort order.</p>
</td></tr>
<tr><td><code id="mixedOrder_+3A_usecasetiebreak">useCaseTiebreak</code></td>
<td>
<p><code>logical</code> indicating whether to break ties
when <code>ignore.case=TRUE</code>, using mixed case as a tiebreaker.</p>
</td></tr>
<tr><td><code id="mixedOrder_+3A_honorfactor">honorFactor</code></td>
<td>
<p><code>logical</code> indicating whether to honor the
order of <code>levels</code> if the input <code>x</code> is a <code>factor</code>. The default
<code>honorFactor=FALSE</code> is to maintain consistent legacy behavior.
The purpose of this function is to enable alphanumeric sorting,
which is not the purpose of sorting by factor levels.</p>
</td></tr>
<tr><td><code id="mixedOrder_+3A_returndebug">returnDebug</code></td>
<td>
<p><code>logical</code> indicating whether to include
additional debug info as attributes.</p>
</td></tr>
<tr><td><code id="mixedOrder_+3A_returntype">returnType</code></td>
<td>
<p><code>character</code> string to define the return type:
</p>

<ul>
<li><p> &quot;order&quot;: returns <code>integer</code> order, equivalent to <code>order()</code>
</p>
</li>
<li><p> &quot;rank&quot;: returns <code>integer</code> rank, equivalent to <code>rank()</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="mixedOrder_+3A_nalast">NAlast</code></td>
<td>
<p><code>logical</code> DEPRECATED in favor of <code>na.last</code> for
consistency with other base R functions.</p>
</td></tr>
<tr><td><code id="mixedOrder_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> whether to print verbose output.</p>
</td></tr>
<tr><td><code id="mixedOrder_+3A_debug">debug</code></td>
<td>
<p><code>logical</code> indicating whether to return intermediate data
useful only for debugging purposes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a refactor of <code>gtools</code> mixedorder() which was
the source of inspiration for this function, thanks to Gregory R. Warnes!
This function was designed to improve the efficiency for large vectors,
and to handle special cases slightly differently. It was driven by some
need to sort gene symbols, and miRNA symbols in numeric order, for example:
</p>

<dl>
<dt>test set:</dt><dd><p>miR-12,miR-1,miR-122,miR-1b,miR-1a,miR-2</p>
</dd>
<dt><code>sort</code>:</dt><dd><p>miR-1,miR-12,miR-122,miR-1a,miR-1b,miR-2</p>
</dd>
<dt><code>gtools::mixedsort</code>:</dt><dd><p>miR-122,miR-12,miR-2,miR-1,miR-1a,miR-1b</p>
</dd>
<dt><code>mixedSort</code>:</dt><dd><p>miR-1,miR-1a,miR-1b,miR-2,miR-12,miR-122</p>
</dd>
</dl>

<p>This function does not by default consider negative numbers as negative,
instead it treats '-' as a delimiter, unless keepNegative=TRUE.
</p>
<p>When <code>keepNegative=TRUE</code> this function also recognizes scientific
notation, for example <code>"1.23e-2"</code> will be treated as numeric <code>0.0123</code>.
Note that <code>keepNegative=TRUE</code> also forces <code>keepDecimal=TRUE</code>.
</p>
<p>When <code>keepDecimal=TRUE</code> this function maintains numeric values that
include one <code>"."</code>.
</p>
<p>This function is the core of a family of mixedSort functions:
</p>

<dl>
<dt><code>mixedSort()</code></dt><dd><p>Applies <code>mixedOrder()</code> to an input vector.</p>
</dd>
<dt><code>mixedSorts()</code></dt><dd><p>Applies <code>mixedOrder()</code> to a list of vectors,
returning the list where each vector is independently sorted.</p>
</dd>
<dt><code>mixedSortDF()</code></dt><dd><p>Applies <code>mixedOrder()</code> to each column of a
<code>data.frame</code> or comparable object, optionally specifying the order
of columns used during the sort.</p>
</dd>
</dl>

<p>Extra thanks to Gregory R. Warnes for the <code>gtools</code> mixedorder()
that proved to be so useful it ultimately inspired this function.
</p>


<h3>Value</h3>

<p><code>integer</code> vector of orders derived from x,
or when <code>returnType="rank"</code> an integer vector of ranks allowing ties.
The rank is therefore valid for use in chains, such as multiple
columns of a <code>data.frame</code>.
</p>


<h3>See Also</h3>

<p><code>gtools::mixedorder()</code>, <code>gtools::mixedsort()</code>
</p>
<p>Other jam sort functions: 
<code><a href="#topic+mixedSort">mixedSort</a>()</code>,
<code><a href="#topic+mixedSortDF">mixedSortDF</a>()</code>,
<code><a href="#topic+mixedSorts">mixedSorts</a>()</code>,
<code><a href="#topic+mmixedOrder">mmixedOrder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("miR-12","miR-1","miR-122","miR-1b", "miR-1a","miR-2");
mixedOrder(x);
x[mixedOrder(x)];
mixedSort(x);
order(x);
x[order(x)];
sort(x);

## Complex example including NA, blanks, and infinite "Inf"
x &lt;- c("Inf",
   "+Inf12",
   NA,
   "-Inf14",
   "-",
   "---",
   "Jnf12",
   "Hnf12",
   "--",
   "Information");
## By default, strings are sorted as-is, "Hnf" before "Inf" before "Jnf"
## blanks are first, NA values are last
x[mixedOrder(x)];

## blanks are last, but before NA values which are also last
x[mixedOrder(x, blanksFirst=FALSE)];

## Recognize infinite, but not the negative sign
## Now infinite values are at the end, ordered by the number that follows.
x[mixedOrder(x, blanksFirst=FALSE, keepInfinite=TRUE)]

## Now also recognize negative infinite values,
## which puts "-Inf14" at the very beginning.
x[mixedOrder(x, blanksFirst=FALSE, keepInfinite=TRUE, keepNegative=TRUE)]

# test factor level order
factor1 &lt;- factor(c("Cnot9", "Cnot8", "Cnot10"))
sort(factor1)
mixedSort(factor1)
factor1[mixedOrder(factor1)]
factor1[mixedOrder(factor1, honorFactor=TRUE)]

</code></pre>

<hr>
<h2 id='mixedSort'>sort alphanumeric values keeping numeric values in proper order</h2><span id='topic+mixedSort'></span>

<h3>Description</h3>

<p>sort alphanumeric values keeping numeric values in proper order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixedSort(
  x,
  blanksFirst = TRUE,
  na.last = NAlast,
  keepNegative = FALSE,
  keepInfinite = FALSE,
  keepDecimal = FALSE,
  ignore.case = TRUE,
  useCaseTiebreak = TRUE,
  honorFactor = FALSE,
  sortByName = FALSE,
  verbose = FALSE,
  NAlast = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixedSort_+3A_x">x</code></td>
<td>
<p><code>vector</code></p>
</td></tr>
<tr><td><code id="mixedSort_+3A_blanksfirst">blanksFirst</code></td>
<td>
<p><code>logical</code> whether to order blank entries before entries
containing a value.</p>
</td></tr>
<tr><td><code id="mixedSort_+3A_na.last">na.last</code></td>
<td>
<p><code>logical</code> indicating whether to move NA entries at
the end of the sort.</p>
</td></tr>
<tr><td><code id="mixedSort_+3A_keepnegative">keepNegative</code></td>
<td>
<p><code>logical</code> whether to keep '-' associated with adjacent
numeric values, in order to sort them as negative values.</p>
</td></tr>
<tr><td><code id="mixedSort_+3A_keepinfinite">keepInfinite</code></td>
<td>
<p><code>logical</code> whether to allow &quot;Inf&quot; to be considered
a numeric infinite value.</p>
</td></tr>
<tr><td><code id="mixedSort_+3A_keepdecimal">keepDecimal</code></td>
<td>
<p><code>logical</code> whether to keep the decimal in numbers,
sorting as a true number and not as a version number. By default
keepDecimal=FALSE, which means &quot;v1.200&quot; should be ordered before
&quot;v1.30&quot;. When keepDecimal=TRUE, the numeric sort considers only
&quot;1.2&quot; and &quot;1.3&quot; and sorts in that order.</p>
</td></tr>
<tr><td><code id="mixedSort_+3A_ignore.case">ignore.case</code></td>
<td>
<p><code>logical</code> whether to ignore uppercase and lowercase
characters when defining the sort order. Note that when <code>x</code> is
<code>factor</code> the factor levels are converted using
<code>unique(toupper(levels(x)))</code>, therefore the values in <code>x</code> will be
sorted by factor level.</p>
</td></tr>
<tr><td><code id="mixedSort_+3A_usecasetiebreak">useCaseTiebreak</code></td>
<td>
<p><code>logical</code> indicating whether to break ties
when <code>ignore.case=TRUE</code>, using mixed case as a tiebreaker.</p>
</td></tr>
<tr><td><code id="mixedSort_+3A_honorfactor">honorFactor</code></td>
<td>
<p><code>logical</code>, default TRUE, indicating whether to honor
factor level order in the output, otherwise when FALSE it sorts
as <code>character</code>.</p>
</td></tr>
<tr><td><code id="mixedSort_+3A_sortbyname">sortByName</code></td>
<td>
<p><code>logical</code> whether to sort the vector x by names(x) instead
of sorting by x itself.</p>
</td></tr>
<tr><td><code id="mixedSort_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> whether to print verbose output.</p>
</td></tr>
<tr><td><code id="mixedSort_+3A_nalast">NAlast</code></td>
<td>
<p><code>logical</code> deprecated in favor of argument <code>na.last</code>
for consistency with <code>base::sort()</code>.</p>
</td></tr>
<tr><td><code id="mixedSort_+3A_...">...</code></td>
<td>
<p>additional parameters are sent to <code><a href="#topic+mixedOrder">mixedOrder</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a refactor of <code>gtools</code> mixedsort(), a clever bit of
R coding from the <code>gtools</code> package. It was extended to make it slightly
faster, and to handle special cases slightly differently.
It was driven by the need to sort gene symbols, miRNA symbols, chromosome
names, all with proper numeric order, for example:
</p>

<dl>
<dt>test set:</dt><dd><p>miR-12,miR-1,miR-122,miR-1b,mir-1a</p>
</dd>
<dt>gtools::mixedsort:</dt><dd><p>miR-122,miR-12,miR-1,miR-1a,mir-1b</p>
</dd>
<dt>mixedSort:</dt><dd><p>miR-1,miR-1a,miR-1b,miR-12,miR-122</p>
</dd>
</dl>

<p>The function does not by default recognize negative numbers as negative,
instead it treats '-' as a delimiter, unless <code>keepNegative=TRUE</code>.
</p>
<p>This function also attempts to maintain '.' as part of a decimal number,
which can be problematic when sorting IP addresses, for example.
</p>
<p>This function is really just a wrapper function for <code>mixedOrder()</code>,
which does the work of defining the appropriate order.
</p>
<p>The sort logic is roughly as follows:
</p>

<ul>
<li><p> Split each term into alternating chunks containing <code>character</code>
or <code>numeric</code> substrings, split across columns in a matrix.
</p>
</li>
<li><p> Apply appropriate <code>ignore.case</code> logic to the character substrings,
effectively applying <code>toupper()</code> on substrings
</p>
</li>
<li><p> Define rank order of character substrings in each matrix column,
maintaining ties to be resolved in subsequent columns.
</p>
</li>
<li><p> Convert <code>character</code> to <code>numeric</code> ranks via <code>factor</code> intermediate,
defined higher than the highest <code>numeric</code> substring value.
</p>
</li>
<li><p> When <code>ignore.case=TRUE</code> and <code>useCaseTiebreak=TRUE</code>, an additional
tiebreaker column is defined using the <code>character</code> substring values
without applying <code>toupper()</code>.
</p>
</li>
<li><p> A final tiebreaker column is the input string itself, with <code>toupper()</code>
applied when <code>ignore.case=TRUE</code>.
</p>
</li>
<li><p> Apply order across all substring columns.
</p>
</li></ul>

<p>Therefore, some expected behaviors:
</p>

<ul>
<li><p> When <code>ignore.case=TRUE</code> and <code>useCaseTiebreak=TRUE</code> (default for both)
the input data is ordered without regard to case, then the tiebreaker
applies case-specific sort criteria to the final product. This logic
is very close to default <code>sort()</code> except for the handling of internal
<code>numeric</code> values inside each string.
</p>
</li></ul>



<h3>Value</h3>

<p><code>vector</code> of values from argument <code>x</code>, ordered by
<code>mixedOrder()</code>. The output class should match <code>class(x)</code>.
</p>


<h3>See Also</h3>

<p>Other jam sort functions: 
<code><a href="#topic+mixedOrder">mixedOrder</a>()</code>,
<code><a href="#topic+mixedSortDF">mixedSortDF</a>()</code>,
<code><a href="#topic+mixedSorts">mixedSorts</a>()</code>,
<code><a href="#topic+mmixedOrder">mmixedOrder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("miR-12","miR-1","miR-122","miR-1b", "miR-1a", "miR-2");
sort(x);
mixedSort(x);

# test honorFactor
mixedSort(factor(c("Cnot9", "Cnot8", "Cnot10")))
mixedSort(factor(c("Cnot9", "Cnot8", "Cnot10")), honorFactor=TRUE)

# test ignore.case
mixedSort(factor(c("Cnot9", "Cnot8", "CNOT9", "Cnot10")))
mixedSort(factor(c("CNOT9", "Cnot8", "Cnot9", "Cnot10")))
mixedSort(factor(c("Cnot9", "Cnot8", "CNOT9", "Cnot10")), ignore.case=FALSE)
mixedSort(factor(c("Cnot9", "Cnot8", "CNOT9", "Cnot10")), ignore.case=TRUE)

mixedSort(factor(c("Cnot9", "Cnot8", "CNOT9", "Cnot10")), useCaseTiebreak=TRUE)
mixedSort(factor(c("CNOT9", "Cnot8", "Cnot9", "Cnot10")), useCaseTiebreak=FALSE)

</code></pre>

<hr>
<h2 id='mixedSortDF'>sort data.frame keeping numeric values in proper order</h2><span id='topic+mixedSortDF'></span>

<h3>Description</h3>

<p>sort data.frame keeping numeric values in proper order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixedSortDF(
  df,
  byCols = seq_len(ncol(df)),
  na.last = TRUE,
  decreasing = NULL,
  useRownames = FALSE,
  verbose = FALSE,
  blanksFirst = TRUE,
  keepNegative = FALSE,
  keepInfinite = FALSE,
  keepDecimal = FALSE,
  ignore.case = TRUE,
  useCaseTiebreak = TRUE,
  sortByName = FALSE,
  honorFactor = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixedSortDF_+3A_df">df</code></td>
<td>
<p><code>data.frame</code> input</p>
</td></tr>
<tr><td><code id="mixedSortDF_+3A_bycols">byCols</code></td>
<td>
<p>one of two types of input:
</p>

<ol>
<li> <p><code>integer</code> vector referring to the order of columns to be
used by <code>mmixedOrder()</code> to order the <code>data.frame</code>. Note that
negative values will reverse the sort order for the corresponding
column number. To sort <code>rownames(df)</code> use zero <code>0</code>, and to reverse
sorting <code>rownames(x)</code> use <code>-0.1</code> where the negative sign will
reverse the sort, and <code>-0.1</code> will be rounded to <code>0</code>.
</p>
</li>
<li> <p><code>character</code> vector of values in <code>colnames(df)</code>,
optionally including prefix <code>"-"</code> to reverse the sort.
Note that the argument <code>decreasing</code> can also be used to specify
columns to have reverse sort, either as a single value or vector
to be applied to each column in <code>byCols</code>. To sort <code>rownames(df)</code>
use <code>"rownames"</code> or <code>"row.names"</code>. To reverse sorting <code>rownames(df)</code>
use <code>"-rownames"</code> or <code>"-row.names"</code>.
</p>
</li></ol>
</td></tr>
<tr><td><code id="mixedSortDF_+3A_na.last">na.last</code></td>
<td>
<p><code>logical</code> whether to move NA entries to the end of the sort.
When <code>na.last=TRUE</code> then <code>NA</code> values will always be last, even following
blanks and infinite values. When <code>na.last=FALSE</code> then <code>NA</code> values
will always be first, even before blanks and negative infinite values.</p>
</td></tr>
<tr><td><code id="mixedSortDF_+3A_decreasing">decreasing</code></td>
<td>
<p>NULL or <code>logical</code> vector indicating which columns
in <code>byCols</code> should be sorted in decreasing order. By default, the
<code>sign(byCols)</code> is used to define the sort order of each column, but it
can be explicitly overridden with this <code>decreasing</code> parameter.</p>
</td></tr>
<tr><td><code id="mixedSortDF_+3A_userownames">useRownames</code></td>
<td>
<p><code>logical</code> whether to use <code>rownames(df)</code> as a last
tiebreaker in the overall rank ordering. This parameter has the primary
effect of assuring a reproducible result, provided the rownames are
consistently defined, or if rownames are actually row numbers.
When <code>useRownames=FALSE</code> then rows that would otherwise be ties
will be returned in the same order they were provided in <code>df</code>.</p>
</td></tr>
<tr><td><code id="mixedSortDF_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> whether to print verbose output. When
<code>verbose=2</code> there is slightly more verbose output.</p>
</td></tr>
<tr><td><code id="mixedSortDF_+3A_blanksfirst">blanksFirst</code>, <code id="mixedSortDF_+3A_keepnegative">keepNegative</code>, <code id="mixedSortDF_+3A_keepinfinite">keepInfinite</code>, <code id="mixedSortDF_+3A_keepdecimal">keepDecimal</code>, <code id="mixedSortDF_+3A_ignore.case">ignore.case</code>, <code id="mixedSortDF_+3A_usecasetiebreak">useCaseTiebreak</code>, <code id="mixedSortDF_+3A_sortbyname">sortByName</code></td>
<td>
<p>arguments passed to <code>mmixedOrder()</code>, except <code>sortByName</code> which is not
passed along.</p>
</td></tr>
<tr><td><code id="mixedSortDF_+3A_honorfactor">honorFactor</code></td>
<td>
<p><code>logical</code>, default TRUE, indicating whether to honor
factor level order in the output, otherwise when FALSE it sorts
as <code>character</code>.</p>
</td></tr>
<tr><td><code id="mixedSortDF_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>mmixedOrder()</code> for custom
sort options as described in <code>mixedSort()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper around <code>mmixedOrder()</code> so it operates
on <code>data.frame</code> columns in the proper order, using logic similar that used
by <code>base::order()</code> when operating on a <code>data.frame</code>. The sort order logic
is fully described in <code>mixedSort()</code> and <code>mixedOrder()</code>.
</p>
<p>Note that <code>byCols</code> can either be given as <code>integer</code> column index values,
or <code>character</code> vector of <code>colnames(x)</code>. In either case, using negative
prefix <code>-</code> will reverse the sort order of the corresponding column.
</p>
<p>For example <code>byCols=c(2, -1)</code> will sort column 2 increasing, then
column 1 decreasing.
</p>
<p>Similarly, one can supply <code>colnames(df)</code>, such as
<code>byCols=c("colname2", "-colname1")</code>. Values are matched as-is to
<code>colnames(df)</code> first, then any values not matched are compared again
after removing prefix <code>-</code> from the start of each <code>character</code> string.
Therefore, if <code>colnames(df)</code> contains <code>"-colname1"</code> it will be matched
as-is, but <code>"--colname1"</code> will only be matched after removing the first <code>-</code>,
after which the sort order will be reversed for that column.
</p>
<p>For direct control over the sort order of each column defined in <code>byCols</code>,
you can supply <code>logical</code> vector to argument <code>decreasing</code>, and this vector
is recycled to <code>length(byCols)</code>.
</p>
<p>Finally, for slight efficiency, only unique columns defined in <code>byCols</code>
are used to determine the row order, so even if a column is defined twice
in <code>byCols</code>, only the first instance is passed to <code>mmixedOrder()</code> to
determine row order.
</p>


<h3>Value</h3>

<p><code>data.frame</code> whose rows are ordered using <code>mmixedOrder()</code>.
</p>


<h3>See Also</h3>

<p>Other jam sort functions: 
<code><a href="#topic+mixedOrder">mixedOrder</a>()</code>,
<code><a href="#topic+mixedSort">mixedSort</a>()</code>,
<code><a href="#topic+mixedSorts">mixedSorts</a>()</code>,
<code><a href="#topic+mmixedOrder">mmixedOrder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># start with a vector of miRNA names
x &lt;- c("miR-12","miR-1","miR-122","miR-1b", "miR-1a","miR-2");
# add some arbitrary group information
g &lt;- rep(c("Air", "Treatment", "Control"), 2);
# create a data.frame
df &lt;- data.frame(group=g,
   miRNA=x,
   stringsAsFactors=FALSE);

# input data
df;

# output when using order()
df[do.call(order, df), , drop=FALSE];

# output with mixedSortDF()
mixedSortDF(df);

# mixedSort respects factor order
# reorder factor levels to demonstrate.
# "Control" should come first
gf &lt;- factor(g, levels=c("Control", "Air", "Treatment"));
df2 &lt;- data.frame(groupfactor=gf,
   miRNA=x,
   stringsAsFactors=FALSE);

# now the sort properly keeps the group factor levels in order,
# which also sorting the miRNA names in their proper order.
mixedSortDF(df2);


x &lt;- data.frame(l1=letters[1:10],
   l2=rep(letters[1:2+10], 5),
   L1=LETTERS[1:10],
   L2=rep(LETTERS[1:2+20], each=5));
set.seed(123);
rownames(x) &lt;- sample(seq_len(10));
x;

# sort by including rownames
mixedSortDF(x, byCols=c("rownames"));
mixedSortDF(x, byCols=c("L2", "-rownames"));

# demonstrate sorting a matrix with no rownames
m &lt;- matrix(c(2, 1, 3, 4), ncol=2);
mixedSortDF(m, byCols=-2)

# add rownames
rownames(m) &lt;- c("c", "a");
mixedSortDF(m, byCols=0)
mixedSortDF(m, byCols="-rownames")
mixedSortDF(m, byCols="rownames")

mixedSortDF(data.frame(factor1=factor(c("Cnot9", "Cnot8", "Cnot10"))), honorFactor=FALSE)

# test date columns
testfiles &lt;- system.file(package="jamba", c("TODO.md", "README.md", "NEWS.md"))
testinfo &lt;- file.info(testfiles)
testinfo
mixedSortDF(testinfo, byCols="mtime")

</code></pre>

<hr>
<h2 id='mixedSorts'>sort alphanumeric values within a list format</h2><span id='topic+mixedSorts'></span>

<h3>Description</h3>

<p>sort alphanumeric values within a list format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixedSorts(
  x,
  blanksFirst = TRUE,
  na.last = NAlast,
  keepNegative = FALSE,
  keepInfinite = TRUE,
  keepDecimal = FALSE,
  ignore.case = TRUE,
  useCaseTiebreak = TRUE,
  sortByName = FALSE,
  na.rm = FALSE,
  verbose = FALSE,
  NAlast = TRUE,
  honorFactor = TRUE,
  xclass = NULL,
  indent = 0,
  debug = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixedSorts_+3A_x">x</code></td>
<td>
<p><code>vector</code></p>
</td></tr>
<tr><td><code id="mixedSorts_+3A_blanksfirst">blanksFirst</code></td>
<td>
<p><code>logical</code> whether to order blank entries before entries
containing a value.</p>
</td></tr>
<tr><td><code id="mixedSorts_+3A_na.last">na.last</code></td>
<td>
<p><code>logical</code> indicating whether to move NA entries at
the end of the sort.</p>
</td></tr>
<tr><td><code id="mixedSorts_+3A_keepnegative">keepNegative</code></td>
<td>
<p><code>logical</code> whether to keep '-' associated with adjacent
numeric values, in order to sort them as negative values.</p>
</td></tr>
<tr><td><code id="mixedSorts_+3A_keepinfinite">keepInfinite</code></td>
<td>
<p><code>logical</code> whether to allow &quot;Inf&quot; to be considered
a numeric infinite value.</p>
</td></tr>
<tr><td><code id="mixedSorts_+3A_keepdecimal">keepDecimal</code></td>
<td>
<p><code>logical</code> whether to keep the decimal in numbers,
sorting as a true number and not as a version number. By default
keepDecimal=FALSE, which means &quot;v1.200&quot; should be ordered before
&quot;v1.30&quot;. When keepDecimal=TRUE, the numeric sort considers only
&quot;1.2&quot; and &quot;1.3&quot; and sorts in that order.</p>
</td></tr>
<tr><td><code id="mixedSorts_+3A_ignore.case">ignore.case</code></td>
<td>
<p><code>logical</code> whether to ignore uppercase and lowercase
characters when defining the sort order. Note that when <code>x</code> is
<code>factor</code> the factor levels are converted using
<code>unique(toupper(levels(x)))</code>, therefore the values in <code>x</code> will be
sorted by factor level.</p>
</td></tr>
<tr><td><code id="mixedSorts_+3A_usecasetiebreak">useCaseTiebreak</code></td>
<td>
<p><code>logical</code> indicating whether to break ties
when <code>ignore.case=TRUE</code>, using mixed case as a tiebreaker.</p>
</td></tr>
<tr><td><code id="mixedSorts_+3A_sortbyname">sortByName</code></td>
<td>
<p><code>logical</code> whether to sort the vector x by names(x) instead
of sorting by x itself.</p>
</td></tr>
<tr><td><code id="mixedSorts_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>, default FALSE, indicating whether to remove
NA values.</p>
</td></tr>
<tr><td><code id="mixedSorts_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> whether to print verbose output.</p>
</td></tr>
<tr><td><code id="mixedSorts_+3A_nalast">NAlast</code></td>
<td>
<p><code>logical</code> deprecated in favor of argument <code>na.last</code>
for consistency with <code>base::sort()</code>.</p>
</td></tr>
<tr><td><code id="mixedSorts_+3A_honorfactor">honorFactor</code></td>
<td>
<p><code>logical</code>, default TRUE, used to enforce factor level
sort order, when FALSE it sorts as <code>character</code>.</p>
</td></tr>
<tr><td><code id="mixedSorts_+3A_xclass">xclass</code></td>
<td>
<p><code>character</code> vector of classes in <code>x</code>, used for slight
optimization to re-use this vector if it has already been
defined for <code>x</code>. When <code>NULL</code> it is created within this function.</p>
</td></tr>
<tr><td><code id="mixedSorts_+3A_indent">indent</code></td>
<td>
<p><code>numeric</code> used only when <code>verbose=TRUE</code> to determine
the number of spaces indented for verbose output, passed to
<code>printDebug()</code>.</p>
</td></tr>
<tr><td><code id="mixedSorts_+3A_debug">debug</code></td>
<td>
<p><code>logical</code>, default FALSE, whether to print detailed
debug output.</p>
</td></tr>
<tr><td><code id="mixedSorts_+3A_...">...</code></td>
<td>
<p>additional parameters are sent to <code><a href="#topic+mixedOrder">mixedOrder</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an extension to <code>mixedSort()</code> to sort each vector
in a list. It applies the sort to the whole unlisted vector then
splits back into list form.
</p>
<p>In the event the input is a nested list of lists, only the first
level of list structure is maintained in the output data. For
more information, see <code>rlengths()</code> which calculates the recursive
nested list sizes. An exception is when the data contained in <code>x</code>
represents multiple classes, see below.
</p>
<p>When data in <code>x</code> represents multiple classes, for example <code>character</code>
and <code>factor</code>, the mechanism is slightly different and not as well-
optimized for large length <code>x</code>. The method uses
<code>rapply(x, how="replace", mixedSort)</code> which recursively, and iteratively,
calls <code>mixedSort()</code> on each vector, and therefore returns data in the
same nested <code>list</code> structure as provided in <code>x</code>.
</p>
<p>When data in <code>x</code> represents only one class, data is <code>unlist()</code> to one
large vector, which is sorted with <code>mixedSort()</code>, then split back into
<code>list</code> structure representing <code>x</code> input.
</p>


<h3>Value</h3>

<p><code>list</code> after applying <code>mixedSort()</code> to its elements.
</p>


<h3>See Also</h3>

<p>Other jam sort functions: 
<code><a href="#topic+mixedOrder">mixedOrder</a>()</code>,
<code><a href="#topic+mixedSort">mixedSort</a>()</code>,
<code><a href="#topic+mixedSortDF">mixedSortDF</a>()</code>,
<code><a href="#topic+mmixedOrder">mmixedOrder</a>()</code>
</p>
<p>Other jam list functions: 
<code><a href="#topic+cPaste">cPaste</a>()</code>,
<code><a href="#topic+heads">heads</a>()</code>,
<code><a href="#topic+jam_rapply">jam_rapply</a>()</code>,
<code><a href="#topic+list2df">list2df</a>()</code>,
<code><a href="#topic+mergeAllXY">mergeAllXY</a>()</code>,
<code><a href="#topic+rbindList">rbindList</a>()</code>,
<code><a href="#topic+relist_named">relist_named</a>()</code>,
<code><a href="#topic+rlengths">rlengths</a>()</code>,
<code><a href="#topic+sclass">sclass</a>()</code>,
<code><a href="#topic+sdim">sdim</a>()</code>,
<code><a href="#topic+uniques">uniques</a>()</code>,
<code><a href="#topic+unnestList">unnestList</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up an example list of mixed alpha-numeric strings
set.seed(12);
x &lt;- paste0(sample(letters, replace=TRUE, 52), rep(1:30, length.out=52));
x;
# split into a list as an example
xL &lt;- split(x, rep(letters[1:5], c(6,7,5,4,4)));
xL;

# now run mixedSorts(xL)
# Notice "e6" is sorted before "e30"
mixedSorts(xL)

# for fun, compare to lapply(xL, sort)
# Notice "e6" is sorted after "e30"
lapply(xL, sort)

# test super-long list
xL10k &lt;- rep(xL, length.out=10000);
names(xL10k) &lt;- as.character(seq_along(xL10k));
print(head(mixedSorts(xL10k), 10))

# Now make some list vectors into factors
xF &lt;- xL;
xF$c &lt;- factor(xL$c)
# for fun, reverse the levels
xF$c &lt;- factor(xF$c,
   levels=rev(levels(xF$c)))
xF
mixedSorts(xF)

# test super-long list
xF10k &lt;- rep(xF, length.out=10000);
names(xF10k) &lt;- as.character(seq_along(xF10k));
print(head(mixedSorts(xF10k), 10))

# Make a nested list
set.seed(1);
l1 &lt;- list(
   A=sample(nameVector(11:13, rev(letters[11:13]))),
   B=list(
      C=sample(nameVector(4:8, rev(LETTERS[4:8]))),
      D=sample(nameVector(LETTERS[2:5], rev(LETTERS[2:5])))
   )
)
l1;
# The output is a nested list with the same structure
mixedSorts(l1);
mixedSorts(l1, sortByName=TRUE);

# Make a nested list with two sub-lists
set.seed(1);
l2 &lt;- list(
   A=list(
      E=sample(nameVector(11:13, rev(letters[11:13])))
   ),
   B=list(
      C=sample(nameVector(4:8, rev(LETTERS[4:8]))),
      D=sample(nameVector(LETTERS[2:5], rev(LETTERS[2:5])))
   )
)
l2;
# The output is a nested list with the same structure
mixedSorts(l2);
mixedSorts(l2, sortByName=TRUE);

# when one entry is missing
L0 &lt;- list(A=3:1,
   B=list(C=c(1:3,NA,0),
   D=LETTERS[c(4,5,2)],
   E=NULL));
L0
mixedSorts(L0)
mixedSorts(L0, na.rm=TRUE)

</code></pre>

<hr>
<h2 id='mmixedOrder'>order alphanumeric values from a list</h2><span id='topic+mmixedOrder'></span>

<h3>Description</h3>

<p>order alphanumeric values from a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmixedOrder(
  ...,
  decreasing = FALSE,
  blanksFirst = TRUE,
  na.last = NAlast,
  keepNegative = FALSE,
  keepInfinite = FALSE,
  keepDecimal = FALSE,
  ignore.case = TRUE,
  useCaseTiebreak = TRUE,
  sortByName = FALSE,
  NAlast = TRUE,
  honorFactor = TRUE,
  verbose = FALSE,
  matrixAsDF = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mmixedOrder_+3A_...">...</code></td>
<td>
<p>arguments treated as a <code>list</code> of vectors to be ordered in
proper order, based upon the mechanism by <code>base::order()</code>, and
as such <code>data.frame</code> is equivalent to a <code>list</code>.</p>
</td></tr>
<tr><td><code id="mmixedOrder_+3A_decreasing">decreasing</code></td>
<td>
<p><code>logical</code>, default FALSE, used to reverse the sort order.</p>
</td></tr>
<tr><td><code id="mmixedOrder_+3A_blanksfirst">blanksFirst</code>, <code id="mmixedOrder_+3A_na.last">na.last</code>, <code id="mmixedOrder_+3A_keepnegative">keepNegative</code>, <code id="mmixedOrder_+3A_keepinfinite">keepInfinite</code>, <code id="mmixedOrder_+3A_keepdecimal">keepDecimal</code>, <code id="mmixedOrder_+3A_ignore.case">ignore.case</code>, <code id="mmixedOrder_+3A_usecasetiebreak">useCaseTiebreak</code>, <code id="mmixedOrder_+3A_sortbyname">sortByName</code></td>
<td>
<p>arguments passed to <code>mixedOrder()</code>, except <code>sortByName</code> which is not
passed along.</p>
</td></tr>
<tr><td><code id="mmixedOrder_+3A_nalast">NAlast</code></td>
<td>
<p><code>logical</code> deprecated in favor of argument <code>na.last</code>
for consistency with <code>base::sort()</code>.</p>
</td></tr>
<tr><td><code id="mmixedOrder_+3A_honorfactor">honorFactor</code></td>
<td>
<p><code>logical</code>, default TRUE, used to enforce factor level
sort order, when FALSE it sorts as <code>character</code>.</p>
</td></tr>
<tr><td><code id="mmixedOrder_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating whether to print verbose output,
passed as <code>verbose - 1</code> to <code>mixedOrder()</code>.</p>
</td></tr>
<tr><td><code id="mmixedOrder_+3A_matrixasdf">matrixAsDF</code></td>
<td>
<p><code>logical</code> if <code>...</code> supplies only one matrix object,
then <code>matrixAsDF=TRUE</code> will cause it to be converted to a <code>data.frame</code>,
then coerce to a <code>list</code> before processing.
By default, in the event only one matrix object is supplied,
this conversion is performed, in order to define a sort order based upon
each column in order, consistent with behavior of <code>data.frame</code> input.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a minor extension to <code>mixedOrder()</code>,
&quot;multiple <code>mixedOrder()</code>&quot;,
which accepts <code>list</code> input, similar to how <code>base::order()</code> operates.
This function is mainly useful when sorting something like a
<code>data.frame</code>, where ties in column 1 should be maintained then
broken by non-equal values in column 2, and so on.
</p>
<p>This function essentially converts any non-numeric column
to a factor, whose levels are sorted using <code>mixedOrder()</code>.
That factor is converted to numeric value, multiplied by <code>-1</code>
when <code>decreasing=TRUE</code>. Finally the list of numeric vectors
is passed to <code>base::order()</code>.
</p>
<p>In fact, <code>mixedSortDF()</code> calls this <code>mmixedOrder()</code> function,
in order to sort a <code>data.frame</code> properly by column.
</p>
<p>See <code>mixedOrder()</code> and <code>mixedSort()</code> for a better
description of how the sort order logic operates.
</p>


<h3>Value</h3>

<p><code>integer</code> vector of row orders
</p>


<h3>See Also</h3>

<p>Other jam sort functions: 
<code><a href="#topic+mixedOrder">mixedOrder</a>()</code>,
<code><a href="#topic+mixedSort">mixedSort</a>()</code>,
<code><a href="#topic+mixedSortDF">mixedSortDF</a>()</code>,
<code><a href="#topic+mixedSorts">mixedSorts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># test factor level order
factor1 &lt;- factor(c("Cnot9", "Cnot8", "Cnot10"))
sort(factor1)
mixedSort(factor1)
factor1[mixedOrder(factor1)]
factor1[mixedOrder(factor1, honorFactor=FALSE)]
factor1[mixedOrder(factor1, honorFactor=TRUE)]

factor1[mmixedOrder(list(factor1))]
factor1[mmixedOrder(list(factor1), honorFactor=FALSE)]
factor1[mmixedOrder(list(factor1), honorFactor=TRUE)]

</code></pre>

<hr>
<h2 id='nameVector'>assign unique names for a vector</h2><span id='topic+nameVector'></span>

<h3>Description</h3>

<p>assign unique names for a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nameVector(x, y = NULL, makeNamesFunc = makeNames, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nameVector_+3A_x">x</code></td>
<td>
<p><code>character</code> vector, or <code>data.frame</code> or equivalent
(matrix, or tibble) with two columns, the second column
is used to name values in the first column.</p>
</td></tr>
<tr><td><code id="nameVector_+3A_y">y</code></td>
<td>
<p><code>character</code> or NULL, with names. If NULL then x is used.
Note that y is recycled to the length of x, prior to being sent
to the makeNamesFunc.
In fringe cases, y can be a matrix, data.frame, or tibble, in which
case <code>pasteByRow()</code> will be used to create a character string
to be used for vector names. Note this case is activated only when x
is not a two column matrix, data.frame, or tibble.</p>
</td></tr>
<tr><td><code id="nameVector_+3A_makenamesfunc">makeNamesFunc</code></td>
<td>
<p><code>function</code> to make names unique, by default
<code>makeNames()</code> which ensures names are unique.</p>
</td></tr>
<tr><td><code id="nameVector_+3A_...">...</code></td>
<td>
<p>passed to <code>makeNamesFunc</code>, or to
<code>pasteByRow()</code> if y is a two column data.frame, matrix, or
tibble. Thus, <code>sep</code> can be defined here as a delimiter between
column values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assigns unique names to a vector, if necessary it runs
<code><a href="#topic+makeNames">makeNames</a></code> to create unique names. It differs from
<code><a href="stats.html#topic+setNames">setNames</a></code> in that it ensures names are unique,
and when no names are supplied, it uses the vector itself to define
names. It is helpful to run this function inside an <code><a href="base.html#topic+lapply">lapply</a></code>
function call, which by default maintains names, but does not assign
names if the input data did not already have them.
</p>
<p>When used with a data.frame, it is particularly convenient to pull out
a named vector of values. For example, log2 fold changes by gene, where
the gene symbols are the name of the vector.
</p>
<p><code>nameVector(genedata[,c("Gene","log2FC")])</code>
</p>


<h3>Value</h3>

<p>vector with names defined
</p>


<h3>See Also</h3>

<p>Other jam string functions: 
<code><a href="#topic+asSize">asSize</a>()</code>,
<code><a href="#topic+breaksByVector">breaksByVector</a>()</code>,
<code><a href="#topic+fillBlanks">fillBlanks</a>()</code>,
<code><a href="#topic+formatInt">formatInt</a>()</code>,
<code><a href="#topic+gsubOrdered">gsubOrdered</a>()</code>,
<code><a href="#topic+gsubs">gsubs</a>()</code>,
<code><a href="#topic+makeNames">makeNames</a>()</code>,
<code><a href="#topic+nameVectorN">nameVectorN</a>()</code>,
<code><a href="#topic+padInteger">padInteger</a>()</code>,
<code><a href="#topic+padString">padString</a>()</code>,
<code><a href="#topic+pasteByRow">pasteByRow</a>()</code>,
<code><a href="#topic+pasteByRowOrdered">pasteByRowOrdered</a>()</code>,
<code><a href="#topic+sizeAsNum">sizeAsNum</a>()</code>,
<code><a href="#topic+tcount">tcount</a>()</code>,
<code><a href="#topic+ucfirst">ucfirst</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># it generally just creates names from the vector values
nameVector(LETTERS[1:5]);

# if values are replicated, the makeNames() function makes them unique
V &lt;- rep(LETTERS[1:5], each=3);
nameVector(V);

# for a two-column data.frame, it creates a named vector using
# the values in the first column, and names in the second column.
df &lt;- data.frame(seq_along(V), V);
df;
nameVector(df);

# Lastly, admittedly a fringe case, it can take a multi-column data.frame
# to generate labels:
nameVector(V, df);

</code></pre>

<hr>
<h2 id='nameVectorN'>define a named vector using vector names</h2><span id='topic+nameVectorN'></span>

<h3>Description</h3>

<p>define a named vector using vector names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nameVectorN(x, makeNamesFunc = makeNames, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nameVectorN_+3A_x">x</code></td>
<td>
<p><code>character</code> vector or any object which has names available
<code>names(x)</code>.</p>
</td></tr>
<tr><td><code id="nameVectorN_+3A_makenamesfunc">makeNamesFunc</code></td>
<td>
<p><code>function</code> used to create unique names, in the event that
the names(x) are not unique.</p>
</td></tr>
<tr><td><code id="nameVectorN_+3A_...">...</code></td>
<td>
<p>Additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a vector from the names of the input vector,
then assigns the same as names. The utility is mainly for
<code><a href="base.html#topic+lapply">lapply</a></code> functions which maintain the name of a vector
in its output. The reason to run <code><a href="base.html#topic+lapply">lapply</a></code> using names
is so the lapply function is operating only on the name and not the
data it references, which can be convenient when the name of the element
is useful to known inside the function body. The reason to name the names,
is so the list object returned by <code><a href="base.html#topic+lapply">lapply</a></code> is also named
with these same consistent names.
</p>
<p>Consider a list of data.frames, each of which represents stats results
from a contrast and fold change. The data.frame may not indicate the name
of the contrast, while the list itself may be named by the contrast.
One would <code>lapply(nameVectorN(listDF), function(iName)iName)</code> which
allows the internal function access to the name of each list element. This
could for example be added to the data.frame.
</p>


<h3>Value</h3>

<p>vector of names, whose names are uniquely assigned using
<code><a href="#topic+makeNames">makeNames</a></code> using the values of the vector.
</p>


<h3>See Also</h3>

<p>Other jam string functions: 
<code><a href="#topic+asSize">asSize</a>()</code>,
<code><a href="#topic+breaksByVector">breaksByVector</a>()</code>,
<code><a href="#topic+fillBlanks">fillBlanks</a>()</code>,
<code><a href="#topic+formatInt">formatInt</a>()</code>,
<code><a href="#topic+gsubOrdered">gsubOrdered</a>()</code>,
<code><a href="#topic+gsubs">gsubs</a>()</code>,
<code><a href="#topic+makeNames">makeNames</a>()</code>,
<code><a href="#topic+nameVector">nameVector</a>()</code>,
<code><a href="#topic+padInteger">padInteger</a>()</code>,
<code><a href="#topic+padString">padString</a>()</code>,
<code><a href="#topic+pasteByRow">pasteByRow</a>()</code>,
<code><a href="#topic+pasteByRowOrdered">pasteByRowOrdered</a>()</code>,
<code><a href="#topic+sizeAsNum">sizeAsNum</a>()</code>,
<code><a href="#topic+tcount">tcount</a>()</code>,
<code><a href="#topic+ucfirst">ucfirst</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a simple integer vector with character names
L &lt;- nameVector(1:5, LETTERS[1:5]);
L;

# we can make a vector of names, retaining the names
nameVectorN(L);

# Now consider a named list, where the name is important
# to keep for downstream work.
K &lt;- list(A=(1:3)^3, B=7:10, C=(1:4)^2);
K;
# Typical lapply-style work does not operate on the name,
# making it difficult to use the name inside the function.
# Here, we just add the name to the colnames, but anything
# could be useful.
lapply(K, function(i){
    data.frame(mean=mean(i), median=stats::median(i));
 });

# So the next step is to run lapply() on the names
lapply(names(K), function(i){
   iDF &lt;- data.frame(mean=mean(K[[i]]), median=stats::median(K[[i]]));
   colnames(iDF) &lt;- paste(c("mean", "median"), i);
   iDF;
})
# The result is good, but the list is no longer named.
# The nameVectorN() function is helpful for maintaining the names.

# So we run lapply() on the named-names, which keeps the names in
# the resulting list, and sends it into the function.
lapply(nameVectorN(K), function(i){
   iDF &lt;- data.frame(mean=mean(K[[i]]), median=stats::median(K[[i]]));
   colnames(iDF) &lt;- paste(c("mean", "median"), i);
   iDF;
});

</code></pre>

<hr>
<h2 id='newestFile'>Return the newest file from a vector of files</h2><span id='topic+newestFile'></span>

<h3>Description</h3>

<p>Return the newest file from a vector of files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newestFile(x, timecol = "mtime", n = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="newestFile_+3A_x">x</code></td>
<td>
<p><code>character</code> vector of files, specifying file path where
required.</p>
</td></tr>
<tr><td><code id="newestFile_+3A_timecol">timecol</code></td>
<td>
<p><code>character</code> value from the output of <code>base::file.info()</code>
indicating the time column used to order files. By default <code>"mtime"</code>
refers to the time the file was last modified.</p>
</td></tr>
<tr><td><code id="newestFile_+3A_n">n</code></td>
<td>
<p><code>integer</code> number of files to return, in order of the most
recent to the least recent. By default <code>n=1</code> returns only the one
newest file.</p>
</td></tr>
<tr><td><code id="newestFile_+3A_...">...</code></td>
<td>
<p>additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the newest file, defined by the most
recently modified time obtained from <code>base::file.info()</code>.
</p>


<h3>Value</h3>

<p><code>character</code> vector <code>length=1</code> of the most recently modified file
from the input vector <code>x</code>. Note that any files not found are removed,
using <code>base::file.exists()</code>, which means invalid symlinks will be ignored.
</p>


<h3>See Also</h3>

<p>Other jam practical functions: 
<code><a href="#topic+breakDensity">breakDensity</a>()</code>,
<code><a href="#topic+call_fn_ellipsis">call_fn_ellipsis</a>()</code>,
<code><a href="#topic+checkLightMode">checkLightMode</a>()</code>,
<code><a href="#topic+check_pkg_installed">check_pkg_installed</a>()</code>,
<code><a href="#topic+colNum2excelName">colNum2excelName</a>()</code>,
<code><a href="#topic+color_dither">color_dither</a>()</code>,
<code><a href="#topic+exp2signed">exp2signed</a>()</code>,
<code><a href="#topic+getAxisLabel">getAxisLabel</a>()</code>,
<code><a href="#topic+isFALSEV">isFALSEV</a>()</code>,
<code><a href="#topic+isTRUEV">isTRUEV</a>()</code>,
<code><a href="#topic+jargs">jargs</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+lldf">lldf</a>()</code>,
<code><a href="#topic+log2signed">log2signed</a>()</code>,
<code><a href="#topic+middle">middle</a>()</code>,
<code><a href="#topic+minorLogTicks">minorLogTicks</a>()</code>,
<code><a href="#topic+printDebug">printDebug</a>()</code>,
<code><a href="#topic+reload_rmarkdown_cache">reload_rmarkdown_cache</a>()</code>,
<code><a href="#topic+renameColumn">renameColumn</a>()</code>,
<code><a href="#topic+rmInfinite">rmInfinite</a>()</code>,
<code><a href="#topic+rmNA">rmNA</a>()</code>,
<code><a href="#topic+rmNAs">rmNAs</a>()</code>,
<code><a href="#topic+rmNULL">rmNULL</a>()</code>,
<code><a href="#topic+setPrompt">setPrompt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>newestFile(list.files());

</code></pre>

<hr>
<h2 id='noiseFloor'>Apply noise floor and ceiling to numeric vector</h2><span id='topic+noiseFloor'></span>

<h3>Description</h3>

<p>Apply noise floor and ceiling to numeric vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noiseFloor(
  x,
  minimum = 0,
  newValue = minimum,
  adjustNA = FALSE,
  ceiling = NULL,
  newCeiling = ceiling,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="noiseFloor_+3A_x">x</code></td>
<td>
<p><code>numeric</code> vector or matrix</p>
</td></tr>
<tr><td><code id="noiseFloor_+3A_minimum">minimum</code></td>
<td>
<p><code>numeric</code> floor value</p>
</td></tr>
<tr><td><code id="noiseFloor_+3A_newvalue">newValue</code></td>
<td>
<p><code>numeric</code>, by default the same as the floor value. Sometimes
it can be useful to define a different value, one example is to define
values as <code>NA</code>, or another distinct number away from the floor.</p>
</td></tr>
<tr><td><code id="noiseFloor_+3A_adjustna">adjustNA</code></td>
<td>
<p><code>logical</code> whether to change <code>NA</code> values to the <code>newValue.</code></p>
</td></tr>
<tr><td><code id="noiseFloor_+3A_ceiling">ceiling</code></td>
<td>
<p><code>numeric</code> value, optionally a ceiling. If defined, then values
above the ceiling value are set to <code>newCeiling.</code></p>
</td></tr>
<tr><td><code id="noiseFloor_+3A_newceiling">newCeiling</code></td>
<td>
<p><code>numeric</code> value when ceiling is defined, values above the
ceiling are set to this <code>numeric</code> value.</p>
</td></tr>
<tr><td><code id="noiseFloor_+3A_...">...</code></td>
<td>
<p>additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A noise floor is useful when detected numeric values are sometimes below
a clear noise threshold, and where some downstream ratio may be calculated
using these values. Applying a noise floor ensures the ratios and not
artificially higher, especially in cases where the values involved are
least reliable. This procedure is expected to produce more conservative
and appropriate ratios in that scenario.
</p>
<p>A ceiling is similar, values above the ceiling are set to the ceiling,
which is practical when values above a certain threshold are conceptually
similar to those at the threshold. One clear example is plotting
<code>-log10(Pvalue)</code> when the range of P-values might approach 1e-1000.
In this case, setting a ceiling of 50 conceptually equates P-values
below 1e-50, while also restricting the axis range of a plot.
</p>
<p>The ability to set values at the floor to a different value, using
<code>newValue</code> different from <code>minimum</code>, is intended to allow separation
of numeric values from the floor for illustrative purposes.
</p>


<h3>Value</h3>

<p><code>numeric</code> vector or <code>matrix</code>, matching the input type <code>x</code>
where numeric values are fixed to the <code>minimum</code> and <code>ceiling</code>
values as defined by <code>newValue</code> and <code>newCeiling</code>, respectively.
</p>


<h3>See Also</h3>

<p>Other jam numeric functions: 
<code><a href="#topic+deg2rad">deg2rad</a>()</code>,
<code><a href="#topic+normScale">normScale</a>()</code>,
<code><a href="#topic+rad2deg">rad2deg</a>()</code>,
<code><a href="#topic+rowGroupMeans">rowGroupMeans</a>()</code>,
<code><a href="#topic+rowRmMadOutliers">rowRmMadOutliers</a>()</code>,
<code><a href="#topic+warpAroundZero">warpAroundZero</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># start with some random data
n &lt;- 2000;
x1 &lt;- stats::rnorm(n);
y1 &lt;- stats::rnorm(n);

# apply noise floor and ceiling
x2 &lt;- noiseFloor(x1, minimum=-2, ceiling=2);
y2 &lt;- noiseFloor(y1, minimum=-2, ceiling=2);

# apply noise floor and ceiling with custom replacement values
xm &lt;- cbind(x=x1, y=y1);
xm3 &lt;- noiseFloor(xm,
   minimum=-2, newValue=-3,
   ceiling=2, newCeiling=3);

withr::with_par(list("mfrow"=c(2,2)), {
plotSmoothScatter(x1, y1);
plotSmoothScatter(x2, y2);
plotSmoothScatter(xm3);
})

</code></pre>

<hr>
<h2 id='normScale'>Scale a numeric vector from 0 to 1</h2><span id='topic+normScale'></span>

<h3>Description</h3>

<p>Scale a numeric vector from 0 to 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normScale(
  x,
  from = 0,
  to = 1,
  low = min(x, na.rm = TRUE),
  high = max(x, na.rm = TRUE),
  naValue = NA,
  singletMethod = c("mean", "min", "max"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normScale_+3A_x">x</code></td>
<td>
<p><code>numeric</code> vector.</p>
</td></tr>
<tr><td><code id="normScale_+3A_from">from</code></td>
<td>
<p>the minimum <code>numeric</code> value to re-scale the input numeric vector.</p>
</td></tr>
<tr><td><code id="normScale_+3A_to">to</code></td>
<td>
<p>the maximum <code>numeric</code> value to re-scale the input numeric vector.</p>
</td></tr>
<tr><td><code id="normScale_+3A_low">low</code></td>
<td>
<p><code>numeric</code> value defining the low end of the input numeric range,
intended when input values might not contain the entire numeric
range to be re-scaled.</p>
</td></tr>
<tr><td><code id="normScale_+3A_high">high</code></td>
<td>
<p><code>numeric</code> value defining the high end of the input numeric range,
intended when input values might not contain the entire numeric
range to be re-scaled.</p>
</td></tr>
<tr><td><code id="normScale_+3A_navalue">naValue</code></td>
<td>
<p>optional <code>numeric</code> value used to replace <code>NA</code>, usually by
replacing <code>NA</code> with zero.</p>
</td></tr>
<tr><td><code id="normScale_+3A_singletmethod">singletMethod</code></td>
<td>
<p><code>character</code> value describing how to handle singlet
input values, for example how to scale the number 5 by itself.
</p>

<ul>
<li><p> &quot;mean&quot; then it uses the average of <code>from</code> and <code>to</code>,
</p>
</li>
<li><p> &quot;min&quot; uses the <code>from</code> value, and
</p>
</li>
<li><p> &quot;max&quot; uses the <code>to</code> value.
</p>
</li></ul>
</td></tr>
<tr><td><code id="normScale_+3A_...">...</code></td>
<td>
<p>additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended as a quick way to scale numeric values
between 0 and 1, however other ranges can be defined as needed.
</p>
<p>NA values are ignored and will remain NA in the output. To handle
NA values, use the <code>rmNA()</code> function, which can optionally replace
NA with a fixed numeric value.
</p>
<p>The parameters <code>low</code> and <code>high</code> are used optionally to provide a
fixed range of values expected for <code>x</code>, which is useful for
consistent scaling of <code>x</code>. Specifically, if <code>x</code> may be a
vector of numeric values ranging from 0 and 100, you would
define <code>low=0</code> and <code>high=100</code> so that <code>x</code> will be consistently
scaled regardless what actual range is represented by <code>x</code>.
</p>
<p>Note that when <code>x</code> contains only one value, and <code>low</code> and <code>high</code>
are not defined, then <code>x</code> will be scaled based upon the
argument <code>singletMethod</code>. For example, if you provide <code>x=2</code>
and want to scale <code>x</code> values to between 0 and 10... <code>x</code> can
either be the <code>mean</code> value <code>5</code>; the <code>min</code>imum value <code>0</code>; or
the <code>max</code>imum value <code>10</code>.
</p>
<p>However, if <code>low</code> or <code>high</code> are defined, then x will be scaled
relative to that range.
</p>


<h3>Value</h3>

<p><code>numeric</code> vector after applying the transformations.
</p>


<h3>See Also</h3>

<p>Other jam numeric functions: 
<code><a href="#topic+deg2rad">deg2rad</a>()</code>,
<code><a href="#topic+noiseFloor">noiseFloor</a>()</code>,
<code><a href="#topic+rad2deg">rad2deg</a>()</code>,
<code><a href="#topic+rowGroupMeans">rowGroupMeans</a>()</code>,
<code><a href="#topic+rowRmMadOutliers">rowRmMadOutliers</a>()</code>,
<code><a href="#topic+warpAroundZero">warpAroundZero</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Notice the first value 1 is re-scaled to 0
normScale(1:11);

# Scale values from 0 to 10
normScale(1:11, from=0, to=10);

# Here the low value is defined as 0
normScale(1:10, low=0);

normScale(c(10,20,40,30), from=50, to=65);

</code></pre>

<hr>
<h2 id='nullPlot'>Create a blank plot with optional labels</h2><span id='topic+nullPlot'></span>

<h3>Description</h3>

<p>Create a blank plot with optional labels for margins
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nullPlot(
  xaxt = "n",
  yaxt = "n",
  xlab = "",
  ylab = "",
  col = "transparent",
  xlim = c(1, 2),
  ylim = c(1, 2),
  las = graphics::par("las"),
  doBoxes = TRUE,
  doUsrBox = doBoxes,
  fill = "#FFFF9966",
  doAxes = FALSE,
  doMargins = TRUE,
  marginUnit = c("lines", "inches"),
  plotAreaTitle = "Plot Area",
  plotSrt = 0,
  plotNumPrefix = "",
  bty = "n",
  showMarginsOnly = FALSE,
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nullPlot_+3A_xaxt">xaxt</code></td>
<td>
<p><code>character</code> value compatible with<code>options("xaxt")</code></p>
</td></tr>
<tr><td><code id="nullPlot_+3A_yaxt">yaxt</code></td>
<td>
<p><code>character</code> value compatible with <code>options("xaxt")</code></p>
</td></tr>
<tr><td><code id="nullPlot_+3A_xlab">xlab</code></td>
<td>
<p><code>character</code> x-axis label</p>
</td></tr>
<tr><td><code id="nullPlot_+3A_ylab">ylab</code></td>
<td>
<p><code>character</code> y-axis label</p>
</td></tr>
<tr><td><code id="nullPlot_+3A_col">col</code></td>
<td>
<p><code>character</code> colors passed to <code>plot()</code></p>
</td></tr>
<tr><td><code id="nullPlot_+3A_xlim">xlim</code></td>
<td>
<p><code>numeric</code> x-axis range</p>
</td></tr>
<tr><td><code id="nullPlot_+3A_ylim">ylim</code></td>
<td>
<p><code>numeric</code> y-axis range</p>
</td></tr>
<tr><td><code id="nullPlot_+3A_las">las</code></td>
<td>
<p><code>integer</code> value indicating whether axis labels should be
parallel (1) or perpendicular (2) to the axis line.</p>
</td></tr>
<tr><td><code id="nullPlot_+3A_doboxes">doBoxes</code></td>
<td>
<p><code>logical</code> whether to draw annotated boxes around the plot
and inner and outer margins.</p>
</td></tr>
<tr><td><code id="nullPlot_+3A_dousrbox">doUsrBox</code></td>
<td>
<p><code>logical</code> whether to draw a colored bow indicating the
exact plot space, using the function <code>usrBox()</code>.</p>
</td></tr>
<tr><td><code id="nullPlot_+3A_fill">fill</code></td>
<td>
<p><code>character</code> R color used to fill the background of the plot
as used by <code>usrBox()</code>.</p>
</td></tr>
<tr><td><code id="nullPlot_+3A_doaxes">doAxes</code></td>
<td>
<p><code>logical</code> whether to draw default x- and y-axes.</p>
</td></tr>
<tr><td><code id="nullPlot_+3A_domargins">doMargins</code></td>
<td>
<p><code>logical</code> whether to label margins, only active when
doBoxes=TRUE.</p>
</td></tr>
<tr><td><code id="nullPlot_+3A_marginunit">marginUnit</code></td>
<td>
<p><code>character</code> indicating the units used for margin labels.</p>
</td></tr>
<tr><td><code id="nullPlot_+3A_plotareatitle">plotAreaTitle</code></td>
<td>
<p><code>character</code> label printed in the center of the plot
area.</p>
</td></tr>
<tr><td><code id="nullPlot_+3A_plotsrt">plotSrt</code></td>
<td>
<p>numeric angle for the plotAreaTitle, which is good for
labeling this plot with vertical text when displaying a plot panel
inside a grid layout, where the plot is taller than it is wide.</p>
</td></tr>
<tr><td><code id="nullPlot_+3A_plotnumprefix">plotNumPrefix</code></td>
<td>
<p><code>character</code> or integer label appended as suffix to
margin labels, which is useful when annotating multiple plots in a
grid layout, where labels are sometimes quite close together. This
label is but a simple attempt to sidestep the real problem of fitting
labels inside each visual component.</p>
</td></tr>
<tr><td><code id="nullPlot_+3A_bty">bty</code></td>
<td>
<p><code>character</code> passed <code>plot()</code>, default <code>"n"</code> suppresses
the default box, which can then be optionally drawn
based upon the <code>doBoxes</code> parameter.</p>
</td></tr>
<tr><td><code id="nullPlot_+3A_showmarginsonly">showMarginsOnly</code></td>
<td>
<p><code>logical</code> whether to create a new plot or to annotate
an existing active plot.</p>
</td></tr>
<tr><td><code id="nullPlot_+3A_add">add</code></td>
<td>
<p><code>logical</code> whether to add to an existing active R plot, or create
a new plot window.</p>
</td></tr>
<tr><td><code id="nullPlot_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates an empty plot space, using the current
<code>graphics::par()</code> settings for margins, text size, etc. By default
it displays a box around the plot window, and labels the margins and
plot area for review. It can be useful as a visual display of various
base graphics settings, or to create an empty plot window with pre-defined
axis ranges. Lastly, one can use this function to create a &quot;blank&quot; plot
which uses a defined background color, which can be a useful precursor to
drawing an image density which may not cover the whole plot space.
</p>


<h3>Value</h3>

<p>no output, this function is called for the byproduct of
creating a blank plot, optionally annotating the margins.
</p>


<h3>See Also</h3>

<p>Other jam plot functions: 
<code><a href="#topic+adjustAxisLabelMargins">adjustAxisLabelMargins</a>()</code>,
<code><a href="#topic+coordPresets">coordPresets</a>()</code>,
<code><a href="#topic+decideMfrow">decideMfrow</a>()</code>,
<code><a href="#topic+drawLabels">drawLabels</a>()</code>,
<code><a href="#topic+getPlotAspect">getPlotAspect</a>()</code>,
<code><a href="#topic+groupedAxis">groupedAxis</a>()</code>,
<code><a href="#topic+imageByColors">imageByColors</a>()</code>,
<code><a href="#topic+imageDefault">imageDefault</a>()</code>,
<code><a href="#topic+minorLogTicksAxis">minorLogTicksAxis</a>()</code>,
<code><a href="#topic+plotPolygonDensity">plotPolygonDensity</a>()</code>,
<code><a href="#topic+plotRidges">plotRidges</a>()</code>,
<code><a href="#topic+plotSmoothScatter">plotSmoothScatter</a>()</code>,
<code><a href="#topic+shadowText">shadowText</a>()</code>,
<code><a href="#topic+shadowText_options">shadowText_options</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+sqrtAxis">sqrtAxis</a>()</code>,
<code><a href="#topic+usrBox">usrBox</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nullPlot()

nullPlot(doBoxes=FALSE)

</code></pre>

<hr>
<h2 id='padInteger'>prefix integers with leading zeros</h2><span id='topic+padInteger'></span>

<h3>Description</h3>

<p>prefix integers with leading zeros
</p>


<h3>Usage</h3>

<pre><code class='language-R'>padInteger(x, padCharacter = "0", useNchar = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="padInteger_+3A_x">x</code></td>
<td>
<p><code>integer</code>, <code>numeric</code>, or <code>character</code> vector. In reality, only
<code>nchar(x)</code> is required to determine padding.</p>
</td></tr>
<tr><td><code id="padInteger_+3A_padcharacter">padCharacter</code></td>
<td>
<p><code>character</code> with nchar(padCharacter)==1, used to pad
each digit as a prefix.</p>
</td></tr>
<tr><td><code id="padInteger_+3A_usenchar">useNchar</code></td>
<td>
<p><code>NULL</code> or <code>integer</code> number of digits used, or if the maximum
<code>nchar(x)</code> is higher, that number of digits is used. Note <code>useNchar</code> is
mostly useful when all numbers are less than 10, but the desired output
is to have a fixed number of digits 2 or higher.</p>
</td></tr>
<tr><td><code id="padInteger_+3A_...">...</code></td>
<td>
<p>additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this function is to pad integer numbers so they contain
a consistent number of digits, which is helpful when sorting values
as character strings.
</p>


<h3>Value</h3>

<p><code>character</code> vector of length(x).
</p>


<h3>See Also</h3>

<p>Other jam string functions: 
<code><a href="#topic+asSize">asSize</a>()</code>,
<code><a href="#topic+breaksByVector">breaksByVector</a>()</code>,
<code><a href="#topic+fillBlanks">fillBlanks</a>()</code>,
<code><a href="#topic+formatInt">formatInt</a>()</code>,
<code><a href="#topic+gsubOrdered">gsubOrdered</a>()</code>,
<code><a href="#topic+gsubs">gsubs</a>()</code>,
<code><a href="#topic+makeNames">makeNames</a>()</code>,
<code><a href="#topic+nameVector">nameVector</a>()</code>,
<code><a href="#topic+nameVectorN">nameVectorN</a>()</code>,
<code><a href="#topic+padString">padString</a>()</code>,
<code><a href="#topic+pasteByRow">pasteByRow</a>()</code>,
<code><a href="#topic+pasteByRowOrdered">pasteByRowOrdered</a>()</code>,
<code><a href="#topic+sizeAsNum">sizeAsNum</a>()</code>,
<code><a href="#topic+tcount">tcount</a>()</code>,
<code><a href="#topic+ucfirst">ucfirst</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>padInteger(c(1, 10, 20, 300, 5000))

</code></pre>

<hr>
<h2 id='padString'>pad a character string to a fixed length</h2><span id='topic+padString'></span>

<h3>Description</h3>

<p>pad a character string to a fixed length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>padString(
  x,
  stringLength = max(nchar(x)),
  padCharacter = " ",
  justify = "left",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="padString_+3A_x">x</code></td>
<td>
<p><code>character</code> vector</p>
</td></tr>
<tr><td><code id="padString_+3A_stringlength">stringLength</code></td>
<td>
<p><code>integer</code> length for the resulting character strings
in <code>x</code>. By default, all strings are padded to the length of the
longest entry, however stringLength can be defined to impose strict
number of characters for all entries.</p>
</td></tr>
<tr><td><code id="padString_+3A_padcharacter">padCharacter</code></td>
<td>
<p><code>character</code> string with nchar=1 used for padding.</p>
</td></tr>
<tr><td><code id="padString_+3A_justify">justify</code></td>
<td>
<p><code>character</code> string with &quot;left&quot;, &quot;right&quot;, &quot;center&quot; to indicate
alignment of the resulting text string.</p>
</td></tr>
<tr><td><code id="padString_+3A_...">...</code></td>
<td>
<p>additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character</code> vector of length(x)
</p>


<h3>See Also</h3>

<p>Other jam string functions: 
<code><a href="#topic+asSize">asSize</a>()</code>,
<code><a href="#topic+breaksByVector">breaksByVector</a>()</code>,
<code><a href="#topic+fillBlanks">fillBlanks</a>()</code>,
<code><a href="#topic+formatInt">formatInt</a>()</code>,
<code><a href="#topic+gsubOrdered">gsubOrdered</a>()</code>,
<code><a href="#topic+gsubs">gsubs</a>()</code>,
<code><a href="#topic+makeNames">makeNames</a>()</code>,
<code><a href="#topic+nameVector">nameVector</a>()</code>,
<code><a href="#topic+nameVectorN">nameVectorN</a>()</code>,
<code><a href="#topic+padInteger">padInteger</a>()</code>,
<code><a href="#topic+pasteByRow">pasteByRow</a>()</code>,
<code><a href="#topic+pasteByRowOrdered">pasteByRowOrdered</a>()</code>,
<code><a href="#topic+sizeAsNum">sizeAsNum</a>()</code>,
<code><a href="#topic+tcount">tcount</a>()</code>,
<code><a href="#topic+ucfirst">ucfirst</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>padString(c("one","two","three"));
padString(c("one","two","three","four"), padCharacter="_", justify="center");

</code></pre>

<hr>
<h2 id='pasteByRow'>Paste data.frame rows into character vector</h2><span id='topic+pasteByRow'></span>

<h3>Description</h3>

<p>Paste data.frame rows into a character vector, optionally removing
empty fields in order to avoid delimiters being duplicated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pasteByRow(
  x,
  sep = "_",
  na.rm = TRUE,
  condenseBlanks = TRUE,
  includeNames = FALSE,
  sepName = ":",
  blankGrep = "^[ ]*$",
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pasteByRow_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> or comparable object such as <code>matrix</code> or <code>tibble</code>.</p>
</td></tr>
<tr><td><code id="pasteByRow_+3A_sep">sep</code></td>
<td>
<p><code>character</code> string separator to use between columns.</p>
</td></tr>
<tr><td><code id="pasteByRow_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code> whether to remove NA values, or include them
as <code>"NA"</code> strings.</p>
</td></tr>
<tr><td><code id="pasteByRow_+3A_condenseblanks">condenseBlanks</code></td>
<td>
<p><code>logical</code> whether to condense blank or empty values
without including an extra delimiter between columns.</p>
</td></tr>
<tr><td><code id="pasteByRow_+3A_includenames">includeNames</code></td>
<td>
<p><code>logical</code> whether to include the colname delimited
prior to the value, using sepName as the delimiter.</p>
</td></tr>
<tr><td><code id="pasteByRow_+3A_sepname">sepName</code></td>
<td>
<p><code>character</code> string relevant when <code>includeNames=TRUE</code>,
this value becomes the delimiter between name:value.</p>
</td></tr>
<tr><td><code id="pasteByRow_+3A_blankgrep">blankGrep</code></td>
<td>
<p><code>character</code> string used as regular expression pattern in
<code>grep()</code> to recognize blank entries;
by default any field containing no text, or only whitespace,
is considered a blank entry.</p>
</td></tr>
<tr><td><code id="pasteByRow_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> whether to print verbose output.</p>
</td></tr>
<tr><td><code id="pasteByRow_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to paste <code>data.frame</code> (or <code>matrix</code>, or <code>tibble</code>)
values for each row of data.
It differs from using <code>apply(x, 2, paste)</code>:
</p>

<ul>
<li><p> it handles factors without converting to integer factor level numbers.
</p>
</li>
<li><p> it also by default removes blank or empty fields, preventing the delimiter
from being included multiple times, per the <code>condenseBlanks</code> argument.
</p>
</li>
<li><p> it is notably faster than apply, by means of running <code>paste()</code> on
each column of data, making the output vectorized, and scaling rather
well for large <code>data.frame</code> objects.
</p>
</li></ul>

<p>The output can also include name:value pairs, which can make the output
data more self-describing in some circumstances. That said, the most basic
usefulness of this function is to create row labels.
</p>


<h3>Value</h3>

<p><code>character</code> vector of length <code>nrow(x)</code>.
</p>


<h3>See Also</h3>

<p>Other jam string functions: 
<code><a href="#topic+asSize">asSize</a>()</code>,
<code><a href="#topic+breaksByVector">breaksByVector</a>()</code>,
<code><a href="#topic+fillBlanks">fillBlanks</a>()</code>,
<code><a href="#topic+formatInt">formatInt</a>()</code>,
<code><a href="#topic+gsubOrdered">gsubOrdered</a>()</code>,
<code><a href="#topic+gsubs">gsubs</a>()</code>,
<code><a href="#topic+makeNames">makeNames</a>()</code>,
<code><a href="#topic+nameVector">nameVector</a>()</code>,
<code><a href="#topic+nameVectorN">nameVectorN</a>()</code>,
<code><a href="#topic+padInteger">padInteger</a>()</code>,
<code><a href="#topic+padString">padString</a>()</code>,
<code><a href="#topic+pasteByRowOrdered">pasteByRowOrdered</a>()</code>,
<code><a href="#topic+sizeAsNum">sizeAsNum</a>()</code>,
<code><a href="#topic+tcount">tcount</a>()</code>,
<code><a href="#topic+ucfirst">ucfirst</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create an example data.frame
a1 &lt;- c("red","blue")[c(1,1,2)];
b1 &lt;- c("yellow","orange")[c(1,2,2)];
d1 &lt;- c("purple","green")[c(1,2,2)];
df2 &lt;- data.frame(a=a1, b=b1, d=d1);
df2;

# the basic output
pasteByRow(df2);

# Now remove an entry to show the empty field is skipped
df2[3,3] &lt;- "";
pasteByRow(df2);

# the output tends to make good rownames
rownames(df2) &lt;- pasteByRow(df2);

# since the data.frame contains colors, we display using
# imageByColors()
withr::with_par(list("mar"=c(5,10,4,2)), {
imageByColors(df2, cellnote=df2);
})

</code></pre>

<hr>
<h2 id='pasteByRowOrdered'>Paste data.frame rows into an ordered factor</h2><span id='topic+pasteByRowOrdered'></span>

<h3>Description</h3>

<p>Paste data.frame rows into an ordered factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pasteByRowOrdered(
  x,
  sep = "_",
  na.rm = TRUE,
  condenseBlanks = TRUE,
  includeNames = FALSE,
  keepOrder = FALSE,
  byCols = seq_len(ncol(x)),
  na.last = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pasteByRowOrdered_+3A_x">x</code></td>
<td>
<p><code>data.frame</code></p>
</td></tr>
<tr><td><code id="pasteByRowOrdered_+3A_sep">sep</code></td>
<td>
<p><code>character</code> separator to use between columns</p>
</td></tr>
<tr><td><code id="pasteByRowOrdered_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code> whether to remove NA values, or include them as &quot;NA&quot;</p>
</td></tr>
<tr><td><code id="pasteByRowOrdered_+3A_condenseblanks">condenseBlanks</code></td>
<td>
<p><code>logical</code> whether to condense blank or empty values
without including an extra delimiter between columns.</p>
</td></tr>
<tr><td><code id="pasteByRowOrdered_+3A_includenames">includeNames</code></td>
<td>
<p><code>logical</code> whether to include the colname delimited
prior to the value, using sepName as the delimiter.</p>
</td></tr>
<tr><td><code id="pasteByRowOrdered_+3A_keeporder">keepOrder</code></td>
<td>
<p><code>logical</code> indicating whether non-factor columns
should order factor levels based upon the existing order of
unique items. This option is intended for <code>data.frame</code> whose
columns are already sorted in proper order, but where columns
are not <code>factor</code> with appropriate factor levels. Note that
even when <code>keepOrder=TRUE</code> all existing <code>factor</code> columns will
honor the order of factor levels already present in those
columns.</p>
</td></tr>
<tr><td><code id="pasteByRowOrdered_+3A_bycols">byCols</code></td>
<td>
<p><code>integer</code> or <code>character</code> passed to <code>mixedSortDF()</code>.
This argument defines the order of columns sorted by <code>mixedSortDF()</code>,
and does not affect the order of columns pasted. Columns are
always pasted in the same order they appear in <code>x</code>. This argument
<code>byCols</code> was previously passed via <code>...</code> but is added here
to make this connection more direct.</p>
</td></tr>
<tr><td><code id="pasteByRowOrdered_+3A_na.last">na.last</code></td>
<td>
<p><code>logical</code> passed to <code>base::factor()</code> to determine whether
<code>NA</code> values are first or last in factor level order.</p>
</td></tr>
<tr><td><code id="pasteByRowOrdered_+3A_...">...</code></td>
<td>
<p>additional arguments are passed to <code>jamba::pasteByRow()</code>,
and to <code>jamba::mixedSortDF()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an extension to <code>jamba::pasteByRow()</code> which
pastes rows from a <code>data.frame</code> into a character vector. This
function defines factor levels by running <code>jamba::mixedSortDF(unique(x))</code>
and calling <code>jamba::pasteByRow()</code> on the result. Therefore the
original order of the input <code>x</code> is maintained while the factor
levels are based upon the appropriate column-based sort.
</p>
<p>Note that the <code>...</code> additional arguments are
passed to <code>jamba::mixedSortDF()</code> to customize the column-based
sort order, used to define factor levels. A good way to test the
order of factors is to run <code>jamba::mixedSortDF(unique(x))</code> with
appropriate arguments, and confirm the rows are ordered as expected.
</p>
<p>Note also that <code>jamba::mixedSortDF()</code> uses <code>jamba::mixedSort()</code>
which itself performs alphanumeric sort in order to keep
values in proper numeric order where possible.
</p>


<h3>Value</h3>

<p><code>factor</code> vector whose levels are defined by existing
factor levels, then by sorted values.
</p>


<h3>See Also</h3>

<p>Other jam string functions: 
<code><a href="#topic+asSize">asSize</a>()</code>,
<code><a href="#topic+breaksByVector">breaksByVector</a>()</code>,
<code><a href="#topic+fillBlanks">fillBlanks</a>()</code>,
<code><a href="#topic+formatInt">formatInt</a>()</code>,
<code><a href="#topic+gsubOrdered">gsubOrdered</a>()</code>,
<code><a href="#topic+gsubs">gsubs</a>()</code>,
<code><a href="#topic+makeNames">makeNames</a>()</code>,
<code><a href="#topic+nameVector">nameVector</a>()</code>,
<code><a href="#topic+nameVectorN">nameVectorN</a>()</code>,
<code><a href="#topic+padInteger">padInteger</a>()</code>,
<code><a href="#topic+padString">padString</a>()</code>,
<code><a href="#topic+pasteByRow">pasteByRow</a>()</code>,
<code><a href="#topic+sizeAsNum">sizeAsNum</a>()</code>,
<code><a href="#topic+tcount">tcount</a>()</code>,
<code><a href="#topic+ucfirst">ucfirst</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- LETTERS;
df &lt;- data.frame(A=f[rep(1:3, each=2)],
   B=c(NA, f[3]),
   C=c(NA, NA, f[2]))
df

# note that output is consistent with mixedSortDF()
jamba::mixedSortDF(df)
jamba::pasteByRowOrdered(df)

jamba::mixedSortDF(df, na.last=FALSE)
jamba::pasteByRowOrdered(df, na.last=FALSE)

jamba::mixedSortDF(df, byCols=c(3, 2, 1))
jamba::pasteByRowOrdered(df, byCols=c(3, 2, 1))

df1 &lt;- data.frame(group=rep(c("Control", "ABC1"), each=6),
   time=rep(c("Hour2", "Hour10"), each=3),
   rep=paste0("Rep", 1:3))
# default will sort each column alphanumerically
pasteByRowOrdered(df1)

# keepOrder=TRUE will honor existing order of character columns
pasteByRowOrdered(df1, keepOrder=TRUE)

</code></pre>

<hr>
<h2 id='plotPolygonDensity'>Plot distribution and histogram overlay</h2><span id='topic+plotPolygonDensity'></span>

<h3>Description</h3>

<p>Plot distribution and histogram overlay
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPolygonDensity(
  x,
  doHistogram = TRUE,
  doPolygon = TRUE,
  col = NULL,
  barCol = "#00337799",
  polyCol = "#00449977",
  polyBorder = makeColorDarker(polyCol),
  histBorder = makeColorDarker(barCol, darkFactor = 1.5),
  colAlphas = c(0.8, 0.6, 0.9),
  darkFactors = c(-1.3, 1, 3),
  lwd = 2,
  las = 2,
  u5.bias = 0,
  pretty.n = 10,
  bw = NULL,
  breaks = 100,
  width = NULL,
  densityBreaksFactor = 3,
  axisFunc = graphics::axis,
  bty = "l",
  cex.axis = 1.5,
  doPar = TRUE,
  heightFactor = 0.95,
  weightFactor = NULL,
  main = "Histogram distribution",
  xaxs = "i",
  yaxs = "i",
  xaxt = "s",
  yaxt = "s",
  xlab = "",
  ylab = "",
  log = NULL,
  xScale = c("default", "log10", "sqrt"),
  usePanels = TRUE,
  useOnePanel = FALSE,
  ablineV = NULL,
  ablineH = NULL,
  ablineVcol = "#44444499",
  ablineHcol = "#44444499",
  ablineVlty = "solid",
  ablineHlty = "solid",
  removeNA = TRUE,
  add = FALSE,
  ylimQuantile = 0.99,
  ylim = NULL,
  xlim = NULL,
  highlightPoints = NULL,
  highlightCol = "gold",
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotPolygonDensity_+3A_x">x</code></td>
<td>
<p><code>numeric</code> vector, or <code>numeric</code> matrix. When a matrix is
provided, each column in the matrix is used as its own data source.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_dohistogram">doHistogram</code></td>
<td>
<p><code>logical</code> indicating whether to plot histogram bars.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_dopolygon">doPolygon</code></td>
<td>
<p><code>logical</code> indicating whether to plot the density polygon.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_col">col</code></td>
<td>
<p><code>character</code> color, or when <code>x</code> is supplied as a matrix,
a vector of colors is applied to across plot panels.
Note that <code>col</code> will override all colors defined for <code>barCol</code>, <code>polyCol</code>,
<code>histBorder</code>, <code>polyBorder</code>.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_barcol">barCol</code>, <code id="plotPolygonDensity_+3A_polycol">polyCol</code>, <code id="plotPolygonDensity_+3A_polyborder">polyBorder</code>, <code id="plotPolygonDensity_+3A_histborder">histBorder</code></td>
<td>
<p><code>character</code> colors used
when <code>col</code> is not supplied.
They define colors for the histogram bars, polygon fill,
polygon border, and histogram bar border, respectively.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_colalphas">colAlphas</code></td>
<td>
<p><code>numeric</code> vector with length 3, indicating the alpha
transparency to use for histogram bar fill, polygon density fill,
and border color, respectively.
Alpha transparency should be scaled between 0 (fully transparent)
and 1 (fully opaque).
These alpha transparency values are applied to each color in <code>col</code>
when <code>col</code> is defined.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_darkfactors">darkFactors</code></td>
<td>
<p><code>numeric</code> used to adjust colors when <code>col</code> is defined.
Values are applied to histogram bar fill, polygon density fill,
and border color, respectively, by calling <code>makeColorDarker()</code>.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_lwd">lwd</code></td>
<td>
<p><code>numeric</code> line width.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_las">las</code></td>
<td>
<p><code>integer</code> used to define axis label orientation.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_u5.bias">u5.bias</code>, <code id="plotPolygonDensity_+3A_pretty.n">pretty.n</code></td>
<td>
<p><code>numeric</code> arguments passed to to <code>base::pretty()</code>
to define pretty axis label positions.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_bw">bw</code></td>
<td>
<p><code>character</code> string of the bandwidth name to use in the
density calculation, passed to <code>jamba::breakDensity()</code>.
By default <code>stats::density()</code> calls a very smooth density kernel,
which obscures finer details, so the default in
<code>jamba::breakDensity()</code> uses a more detailed kernel.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_breaks">breaks</code></td>
<td>
<p><code>numeric</code> breaks sent to <code>hist</code> to define the number of
histogram bars. It can be in the form of a single <code>integer</code> number
of equidistant breaks, or a <code>numeric</code> vector with specific break
positions, but remember to include a starting value lower the the
lowest value in <code>x</code>, and an ending value higher than the highest
value in <code>x</code>. Passed to <code>breakDensity()</code>.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_width">width</code></td>
<td>
<p><code>numeric</code> passed to <code>breakDensity()</code>.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_densitybreaksfactor">densityBreaksFactor</code></td>
<td>
<p><code>numeric</code> scaling factor to control
the level of detail in the density, passed to <code>breakDensity()</code>.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_axisfunc">axisFunc</code></td>
<td>
<p><code>function</code> optionally used in place of <code>graphics::axis()</code> to define
axis labels.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_bty">bty</code></td>
<td>
<p><code>character</code> string used to define the plot box shape,
see <code>graphics::box()</code>.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_cex.axis">cex.axis</code></td>
<td>
<p><code>numeric</code> scalar to adjust axis label font size.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_dopar">doPar</code></td>
<td>
<p><code>logical</code> indicating whether to apply <code>graphics::par()</code>, specifically
when <code>x</code> is supplied as a multi-column matrix. When <code>doPar=FALSE</code>,
no panels nor margin adjustments are made at all.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_heightfactor">heightFactor</code></td>
<td>
<p><code>numeric</code> value indicating the height of the y-axis
plot scale to use when scaling the histogram and polygon density
within each plot panel.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_weightfactor">weightFactor</code></td>
<td>
<p><code>numeric</code> passed to <code>breakDensity()</code>.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_main">main</code></td>
<td>
<p><code>character</code> title to display above the plot, used only when
<code>x</code> is supplied as a single <code>numeric</code> vector. Otherwise each plot
title uses the relevant <code>colnames(x)</code> value.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_xaxs">xaxs</code>, <code id="plotPolygonDensity_+3A_yaxs">yaxs</code>, <code id="plotPolygonDensity_+3A_xaxt">xaxt</code>, <code id="plotPolygonDensity_+3A_yaxt">yaxt</code></td>
<td>
<p><code>character</code> string indicating the type of
x-axis and y-axis to render, see <code>graphics::par()</code>.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_xlab">xlab</code>, <code id="plotPolygonDensity_+3A_ylab">ylab</code></td>
<td>
<p><code>character</code> labels for x-axis and y-axis, respectively.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_log">log</code></td>
<td>
<p><code>character</code> vector, optionally containing <code>"x"</code> and/or <code>"y"</code> to
to indicate which axes are log-transformed. If <code>"x" %in% log</code>
then it sets <code>xScale="log10"</code>, both methods are equivalent in
defining the log-transformation of the x-axis.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_xscale">xScale</code></td>
<td>
<p><code>character</code> string to define the x-axis transformation:
</p>

<ul>
<li> <p><code>"default"</code> applies no transform;
</p>
</li>
<li> <p><code>"log10"</code> applies a log10 transform, specifically <code>log10(x + 1)</code>
</p>
</li>
<li> <p><code>"sqrt"</code> applies a sqrt transform.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_usepanels">usePanels</code></td>
<td>
<p><code>logical</code> indicating whether to separate
the density plots into panels when <code>x</code> contains multiple columns.
When <code>useOnePanel=FALSE</code> the panels will be defined so that all
columns will fit on one page.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_useonepanel">useOnePanel</code></td>
<td>
<p><code>logical</code> indicating whether to define multiple panels
on one page. Therefore <code>useOnePanel=TRUE</code> will create multiple
pages with one panel on each page, which may work well for
output in multi-page 'PDF' files.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_ablinev">ablineV</code>, <code id="plotPolygonDensity_+3A_ablineh">ablineH</code></td>
<td>
<p><code>numeric</code> vector representing abline
vertical and horizontal positions, respectively.
These values are mostly helpful in multi-panel plots,
to draw consistent reference lines on each panel.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_ablinevcol">ablineVcol</code>, <code id="plotPolygonDensity_+3A_ablinehcol">ablineHcol</code></td>
<td>
<p>default&quot;#44444499&quot;, with the abline
color, used when <code>ablineV</code> or <code>ablineH</code> are supplied, respectively.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_ablinevlty">ablineVlty</code>, <code id="plotPolygonDensity_+3A_ablinehlty">ablineHlty</code></td>
<td>
<p><code>numeric</code> or <code>character</code> indicating the
line type to use for <code>ablineV</code> and <code>ablineH</code>, respectively.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_removena">removeNA</code></td>
<td>
<p><code>logical</code> indicating whether to remove NA values
prior to running histogram and density calculations. Presence
of NA values generally causes both functions to fail.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_add">add</code></td>
<td>
<p><code>logical</code> indicating whether to add the plot to an existing
visualization.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_ylimquantile">ylimQuantile</code></td>
<td>
<p><code>numeric</code> value between 0 and 1, indicating the
quantile value of the density <code>y</code> values to use for the ylim. This
threshold is only applied when <code>ylim</code> is NULL.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_ylim">ylim</code>, <code id="plotPolygonDensity_+3A_xlim">xlim</code></td>
<td>
<p><code>numeric</code> y-axis and x-axis ranges, respectively.
When either is <code>NULL</code>, the axis range is determined independently
for each plot panel. Either value can be supplied as a <code>list</code>
to control the numeric range for each individual plot, relevant
only when <code>x</code> is supplied as a multi-column matrix.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_highlightpoints">highlightPoints</code></td>
<td>
<p><code>character</code> vector of optional rownames,
or <code>integer</code> values with row indices, for rows to be highlighted.
When <code>x</code> is supplied as a <code>matrix</code>, <code>highlightPoints</code> can
be supplied as a <code>list</code> of vectors, referring to each column in <code>x</code>.
When rows are highlighted, the plot is drawn with all points,
then the highlighted points are drawn again over the histogram bars,
and polygon density, as relevant.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_highlightcol">highlightCol</code></td>
<td>
<p><code>character</code> vector of colors to
use to fill the histogram when <code>highlightPoints</code> is supplied.
Multiple values are recycled one per column in <code>x</code>,
if <code>x</code> is supplied as a multi-column matrix.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating whether to print verbose output.</p>
</td></tr>
<tr><td><code id="plotPolygonDensity_+3A_...">...</code></td>
<td>
<p>additional arguments are passed to relevant internal
functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper around <code>graphics::hist()</code> and
<code>stats::density()</code>, with enough customization to cover
most of the situations that need customization.
</p>
<p>For example <code>log="x"</code> will automatically log-transform the x-axis,
keeping the histogram bars uniformly sized. Alternatively,
<code>xScale="sqrt"</code> will square root transform the data, and
transform the x-axis while keeping the numeric values constant.
</p>
<p>It also scales the density profile height to be similar to
the histogram bar height, using the 99th quantile of the y-axis
value, which helps prevent outlier peaks from dominating the
y-axis range, thus obscuring interesting smaller features.
</p>
<p>If supplied with a data matrix, this function will create a layout
with <code>ncol(x)</code> panels, and plot the distribution of each column
in its own panel, using categorical colors from <code>rainbow2()</code>.
</p>
<p>For a similar style using ggplot2, see <code>plotRidges()</code>, which displays
only the density profile for each sample, but in a much more scalable
format for larger numbers of columns.
</p>
<p>By default NA values are ignored, and the distributions represent
non-NA values.
</p>
<p>Colors can be controlled using the parameter <code>col</code>, but can
be specifically defined for bars with <code>barCol</code> and the polygon
with <code>polyCol</code>.
</p>


<h3>Value</h3>

<p>invisible <code>list</code> with density and histogram data output,
however this function is called for the by-product of its plot
output.
</p>


<h3>See Also</h3>

<p>Other jam plot functions: 
<code><a href="#topic+adjustAxisLabelMargins">adjustAxisLabelMargins</a>()</code>,
<code><a href="#topic+coordPresets">coordPresets</a>()</code>,
<code><a href="#topic+decideMfrow">decideMfrow</a>()</code>,
<code><a href="#topic+drawLabels">drawLabels</a>()</code>,
<code><a href="#topic+getPlotAspect">getPlotAspect</a>()</code>,
<code><a href="#topic+groupedAxis">groupedAxis</a>()</code>,
<code><a href="#topic+imageByColors">imageByColors</a>()</code>,
<code><a href="#topic+imageDefault">imageDefault</a>()</code>,
<code><a href="#topic+minorLogTicksAxis">minorLogTicksAxis</a>()</code>,
<code><a href="#topic+nullPlot">nullPlot</a>()</code>,
<code><a href="#topic+plotRidges">plotRidges</a>()</code>,
<code><a href="#topic+plotSmoothScatter">plotSmoothScatter</a>()</code>,
<code><a href="#topic+shadowText">shadowText</a>()</code>,
<code><a href="#topic+shadowText_options">shadowText_options</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+sqrtAxis">sqrtAxis</a>()</code>,
<code><a href="#topic+usrBox">usrBox</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># basic density plot
set.seed(123);
x &lt;- stats::rnorm(2000);
plotPolygonDensity(x, main="basic polygon density plot");

# fewer breaks
plotPolygonDensity(x,
   breaks=20,
   main="breaks=20");

# log-scaled x-axis
plotPolygonDensity(10^(3+stats::rnorm(2000)), log="x",
   breaks=50,
   main="log-scaled x-axis");

# highlighted points
set.seed(123);
plotPolygonDensity(x,
   highlightPoints=sample(which(abs(x) &gt; 1), size=200),
   breaks=40,
   main="breaks=40");

# hide axis labels
set.seed(123);
plotPolygonDensity(x,
   highlightPoints=sample(which(abs(x) &gt; 1), size=200),
   breaks=40,
   xaxt="n",
   yaxt="n",
   main="breaks=40");

# multiple columns
set.seed(123);
xm &lt;- do.call(cbind, lapply(1:4, function(i){stats::rnorm(2000)}))
plotPolygonDensity(xm, breaks=20)

</code></pre>

<hr>
<h2 id='plotRidges'>Plot ridges density plots for numeric matrix input</h2><span id='topic+plotRidges'></span>

<h3>Description</h3>

<p>Plot ridges density plots for numeric matrix input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRidges(
  x,
  xScale = c("none", "-log10", "log10"),
  xlab = NULL,
  ylab = NULL,
  title = ggplot2::waiver(),
  subtitle = ggplot2::waiver(),
  caption = ggplot2::waiver(),
  xlim = NULL,
  color_sub = NULL,
  rel_min_height = 0,
  bandwidth = NULL,
  adjust = 1,
  scale = 1,
  share_bandwidth = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotRidges_+3A_x">x</code></td>
<td>
<p><code>matrix</code> with numeric values, or a <code>list</code> of <code>numeric</code>
vectors. In either case the data is converted to long-tall
format before plotting.</p>
</td></tr>
<tr><td><code id="plotRidges_+3A_xscale">xScale</code></td>
<td>
<p><code>character</code> string indicating whether to transform
the x-axis values:
</p>

<ul>
<li> <p><code>"none"</code>: no transformation
</p>
</li>
<li> <p><code>"-log10"</code>: values are transformed with <code>log10(x)</code> and x-axis
labels are adjusted accordingly.
</p>
</li>
<li> <p><code>"log10"</code>: values are transformed with <code>log10(1 + x)</code> except
that negative values are transformed with <code>-log10(1 - x)</code>. The
x-axis labels are plotted to account for the <code>log10(1 + x)</code> offset.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plotRidges_+3A_xlab">xlab</code>, <code id="plotRidges_+3A_ylab">ylab</code></td>
<td>
<p><code>character</code> strings optionally used as x-axis and y-axis
labels.</p>
</td></tr>
<tr><td><code id="plotRidges_+3A_title">title</code>, <code id="plotRidges_+3A_subtitle">subtitle</code>, <code id="plotRidges_+3A_caption">caption</code></td>
<td>
<p><code>character</code> string values optionally passed
to the relevant downstream <code>ggplot2</code> functions.</p>
</td></tr>
<tr><td><code id="plotRidges_+3A_xlim">xlim</code></td>
<td>
<p>passed to <code>ggplot2::xlim()</code> to define the x-axis range.</p>
</td></tr>
<tr><td><code id="plotRidges_+3A_color_sub">color_sub</code></td>
<td>
<p><code>character</code> vector named by <code>colnames(x)</code>, or when
<code>x</code> is a <code>list</code>, <code>names(color_sub)</code> should contain <code>names(x)</code>, used
to define specific colors for each ridge plot.</p>
</td></tr>
<tr><td><code id="plotRidges_+3A_rel_min_height">rel_min_height</code></td>
<td>
<p><code>numeric</code> values passed to
<code>ggridges::geom_density_ridges2()</code></p>
</td></tr>
<tr><td><code id="plotRidges_+3A_bandwidth">bandwidth</code></td>
<td>
<p><code>numeric</code> value used to define the bandwidth density
when <code>share_bandwidth=TRUE</code> which is default. The bandwidth
affects the level of detail presented in each ridgeline, and when
shared across ridgelines <code>share_bandwidth=TRUE</code> then each ridgeline
will use the same consistent level of detail. In this case, it
is passed to <code>ggridges::geom_density_ridges2()</code>.
Note when <code>bandwidth=NULL</code> a default value is derived from the
range of data to be plotted.</p>
</td></tr>
<tr><td><code id="plotRidges_+3A_adjust">adjust</code></td>
<td>
<p><code>numeric</code> used to adjust the default bandwidth only
when <code>bandwidth=NULL</code>. It is intended as a convenient method to
adjust the level of detail.</p>
</td></tr>
<tr><td><code id="plotRidges_+3A_scale">scale</code></td>
<td>
<p><code>numeric</code> passed directly to
<code>ggridges::geom_density_ridges2()</code>.</p>
</td></tr>
<tr><td><code id="plotRidges_+3A_share_bandwidth">share_bandwidth</code></td>
<td>
<p><code>logical</code> indicating whether to supply
<code>ggridges::geom_density_ridges2()</code> a specific <code>bandwidth</code> to use
for all ridgelines. When <code>share_bandwidth=FALSE</code> then each ridgeline
is presented using the default bandwidth in
<code>ggridges::geom_density_ridges2()</code>.</p>
</td></tr>
<tr><td><code id="plotRidges_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a convenient wrapper for <code>ggridges::geom_density_ridges2()</code>,
intended to be analogous to <code>plotPolygonDensity()</code> which differs
by plotting each item in a separate plot panel using base graphics.
This function plots each item as a ridgeline plot in the same
plot window using <code>ggplot2::ggplot()</code>.
</p>


<h3>Value</h3>

<p>object with class <code style="white-space: pre;">&#8288;"gg", "ggplot"&#8288;</code> with density plot
in the form of ridges.
</p>


<h3>See Also</h3>

<p>Other jam plot functions: 
<code><a href="#topic+adjustAxisLabelMargins">adjustAxisLabelMargins</a>()</code>,
<code><a href="#topic+coordPresets">coordPresets</a>()</code>,
<code><a href="#topic+decideMfrow">decideMfrow</a>()</code>,
<code><a href="#topic+drawLabels">drawLabels</a>()</code>,
<code><a href="#topic+getPlotAspect">getPlotAspect</a>()</code>,
<code><a href="#topic+groupedAxis">groupedAxis</a>()</code>,
<code><a href="#topic+imageByColors">imageByColors</a>()</code>,
<code><a href="#topic+imageDefault">imageDefault</a>()</code>,
<code><a href="#topic+minorLogTicksAxis">minorLogTicksAxis</a>()</code>,
<code><a href="#topic+nullPlot">nullPlot</a>()</code>,
<code><a href="#topic+plotPolygonDensity">plotPolygonDensity</a>()</code>,
<code><a href="#topic+plotSmoothScatter">plotSmoothScatter</a>()</code>,
<code><a href="#topic+shadowText">shadowText</a>()</code>,
<code><a href="#topic+shadowText_options">shadowText_options</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+sqrtAxis">sqrtAxis</a>()</code>,
<code><a href="#topic+usrBox">usrBox</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# multiple columns
set.seed(123);
xm &lt;- do.call(cbind, lapply(1:4, function(i){stats::rnorm(2000)}))
plotRidges(xm)

set.seed(123);
x &lt;- stats::rnorm(2000)
plotRidges(x)

</code></pre>

<hr>
<h2 id='plotSmoothScatter'>Smooth scatter plot with enhancements</h2><span id='topic+plotSmoothScatter'></span>

<h3>Description</h3>

<p>Produce scatter plot using point density instead of displaying
individual data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSmoothScatter(
  x,
  y = NULL,
  bwpi = 50,
  binpi = 50,
  bandwidthN = NULL,
  nbin = NULL,
  expand = c(0.04, 0.04),
  transFactor = 0.25,
  transformation = function(x) x^transFactor,
  xlim = NULL,
  ylim = NULL,
  xlab = NULL,
  ylab = NULL,
  nrpoints = 0,
  colramp = c("white", "lightblue", "blue", "orange", "orangered2"),
  col = "black",
  doTest = FALSE,
  fillBackground = TRUE,
  naAction = c("remove", "floor0", "floor1"),
  xaxt = "s",
  yaxt = "s",
  add = FALSE,
  asp = NULL,
  applyRangeCeiling = TRUE,
  useRaster = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotSmoothScatter_+3A_x">x</code></td>
<td>
<p>numeric vector, or data matrix with two or  more columns.</p>
</td></tr>
<tr><td><code id="plotSmoothScatter_+3A_y">y</code></td>
<td>
<p>numeric vector, or if data is supplied via x as a matrix, y
is NULL.</p>
</td></tr>
<tr><td><code id="plotSmoothScatter_+3A_bwpi">bwpi</code></td>
<td>
<p><code>numeric</code> value indicating the bandwidth &quot;per inch&quot;
to scale the bandwidth based upon visual space available.
This argument is used to define <code>bandwidthN</code>, however <code>bwpi</code>
is only used when <code>bandwidthN=NULL</code>.
The bandwidth is used to define the 2-dimensional point density.</p>
</td></tr>
<tr><td><code id="plotSmoothScatter_+3A_binpi">binpi</code></td>
<td>
<p><code>numeric</code> value indicating the number of bins &quot;per inch&quot;,
to scale based upon visual space available.
This argument is used to define <code>nbin</code>, however <code>binpi</code>
is only used when <code>nbin=NULL</code>.</p>
</td></tr>
<tr><td><code id="plotSmoothScatter_+3A_bandwidthn">bandwidthN</code></td>
<td>
<p><code>integer</code> number of bandwidth steps to use across the
visible plot window. Note that this bandwidth differs from default
<code>graphics::smoothScatter()</code> in that it uses the visible
plot window instead of the data range, so if the plot window is not
sufficiently similar to the data range, the resulting smoothed
density will not be visibly distorted. This parameter also permits
display of higher (or lower) level of detail.</p>
</td></tr>
<tr><td><code id="plotSmoothScatter_+3A_nbin">nbin</code></td>
<td>
<p><code>integer</code> number of bins to use when converting the kernel
density result (which uses bandwidthN above) into a usable image.
This setting is effectively the resolution of rendering the
bandwidth density in terms of visible pixels. For example
<code>nbin=256</code> will create 256 visible pixels wide and tall in each
plot panel; and <code>nbin=32</code> will create 32 visible pixels, with
lower detail which may be suitable for multi-panel plots.
To use a variable number of bins, try <code>binpi</code>.</p>
</td></tr>
<tr><td><code id="plotSmoothScatter_+3A_expand">expand</code></td>
<td>
<p><code>numeric</code> value indicating the fraction of the x-axis
and y-axis ranges to add to create an expanded range,
used when <code>add=FALSE</code>. The default <code>expand=c(0.04, 0.04)</code> mimics
the R base plot default which adds 4 percent total, therefore 2 percent
to each side of the visible range.</p>
</td></tr>
<tr><td><code id="plotSmoothScatter_+3A_transfactor">transFactor</code></td>
<td>
<p><code>numeric</code> value used by the default <code>transformation</code>
function, which effectively scales the density of points to
a reasonable visible distribution. This argument is a convenience
method to avoid having to type out the full <code>transformation</code> function.</p>
</td></tr>
<tr><td><code id="plotSmoothScatter_+3A_transformation">transformation</code></td>
<td>
<p><code>function</code> which converts point density to a number,
typically related to square root or cube root transformation. Note
that the default uses <code>transFactor</code> but if a custom function is
supplied, it will not use <code>transFactor</code> unless specified.</p>
</td></tr>
<tr><td><code id="plotSmoothScatter_+3A_xlim">xlim</code></td>
<td>
<p><code>numeric</code> x-axis range, or <code>NULL</code> to use the data range.</p>
</td></tr>
<tr><td><code id="plotSmoothScatter_+3A_ylim">ylim</code></td>
<td>
<p><code>numeric</code> y-axis range, or <code>NULL</code> to use the data range.</p>
</td></tr>
<tr><td><code id="plotSmoothScatter_+3A_xlab">xlab</code>, <code id="plotSmoothScatter_+3A_ylab">ylab</code></td>
<td>
<p><code>character</code> labels for x- and y-axis, respectively.</p>
</td></tr>
<tr><td><code id="plotSmoothScatter_+3A_nrpoints">nrpoints</code></td>
<td>
<p><code>integer</code> number of outlier datapoints to display,
as defined by <code>graphics::smoothScatter()</code>, however the default here
is <code>nrpoints=0</code> to avoid additional clutter in the output,
and because the default arguments <code>bwpi</code>, <code>binpi</code> usually indicate all
individual points.</p>
</td></tr>
<tr><td><code id="plotSmoothScatter_+3A_colramp">colramp</code></td>
<td>
<p>any input recognized by <code>getColorRamp()</code>:
</p>

<ul>
<li> <p><code>character</code> vector with multiple colors
</p>
</li>
<li> <p><code>character</code> string length 1, with valid R color used to create
a linear color gradient
</p>
</li>
<li> <p><code>character</code> name of a known color gradient from <code>RColorBrewer</code>
or <code>viridis</code>
</p>
</li>
<li> <p><code>function</code> that itself produces vector of colors,
in the form <code style="white-space: pre;">&#8288;function(n)&#8288;</code> where <code>n</code> defines the number of colors.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plotSmoothScatter_+3A_col">col</code></td>
<td>
<p><code>character</code> string with R color used when <code>nrpoints</code> is
non-zero, this color defines the color of those points.</p>
</td></tr>
<tr><td><code id="plotSmoothScatter_+3A_dotest">doTest</code></td>
<td>
<p><code>logical</code> indicating whether to create a visual set of test
plots to demonstrate the utility of this function.</p>
</td></tr>
<tr><td><code id="plotSmoothScatter_+3A_fillbackground">fillBackground</code></td>
<td>
<p><code>logical</code> indicating whether to fill the
background of the plot panel with the first color in <code>colramp</code>.
The default <code>fillBackground=TRUE</code> is useful since the plot panel
may be slightly wider than the range of data being displayed, and
when the first color in <code>colramp</code> is not the same as the plot device
background color.
Run a test using:
<code>plotSmoothScatter(doTest=TRUE, fillBackground=FALSE, colramp="viridis")</code>
and compare with:
<code>plotSmoothScatter(doTest=TRUE, colramp="viridis")</code></p>
</td></tr>
<tr><td><code id="plotSmoothScatter_+3A_naaction">naAction</code></td>
<td>
<p><code>character</code> string indicating how to handle NA values,
typically when x is NA and y is not NA, or vice versa. valid values:
</p>

<dl>
<dt>&quot;remove&quot;</dt><dd><p>ignore any points where either x or y are NA</p>
</dd>
<dt>&quot;floor0&quot;</dt><dd><p>change any NA values to zero 0 for either x or y</p>
</dd>
<dt>&quot;floor1&quot;</dt><dd><p>change any NA values to one 1 for either x or y</p>
</dd>
</dl>

<p>The latter two options are useful when the desired plot should indicate
the presence of an NA value in either x or y, while also indicating the
the corresponding non-NA value in the opposing axis. The driving use
was plotting gene fold changes from two experiments, where the two
experiments may not have measured the same genes.</p>
</td></tr>
<tr><td><code id="plotSmoothScatter_+3A_xaxt">xaxt</code></td>
<td>
<p><code>character</code> value compatible with graphics::par(xaxt), used to control
the x-axis range, similar to its use in <code>plot()</code> generic functions.</p>
</td></tr>
<tr><td><code id="plotSmoothScatter_+3A_yaxt">yaxt</code></td>
<td>
<p><code>character</code> value compatible with graphics::par(yaxt), used to control
the y-axis range, similar to its use in <code>plot()</code> generic functions.</p>
</td></tr>
<tr><td><code id="plotSmoothScatter_+3A_add">add</code></td>
<td>
<p><code>logical</code> whether to add to an existing active R plot, or create
a new plot window.</p>
</td></tr>
<tr><td><code id="plotSmoothScatter_+3A_asp">asp</code></td>
<td>
<p><code>numeric</code> with optional aspect ratio, as described in
<code>graphics::plot.window()</code>, where <code>asp=1</code> defines x- and y-axis
coordinate ranges such that distances between points are rendered
accurately. One data unit on the y-axis is equal in length to
<code>asp</code> multiplied by one data unit on the x-axis.
Notes:
</p>

<ul>
<li><p> When <code>add=TRUE</code>, the value <code>asp</code> is ignored, because
the existing plot device is re-used.
</p>
</li>
<li><p> When <code>add=FALSE</code> and <code>asp</code> is defined with <code>numeric</code> value,
a new plot device is opened using <code>plot.window()</code>, and the <code>xlim</code>
and <code>ylim</code> values are passed to that function. As a result the
<code>graphics::par("usr")</code> values are used to define <code>xlim</code> and <code>ylim</code> for the
purpose of determining visible points, relevant to <code>applyRangeCeiling</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plotSmoothScatter_+3A_applyrangeceiling">applyRangeCeiling</code></td>
<td>
<p><code>logical</code> indicating how to handle points outside
the visible plot range. Valid values:
</p>

<dl>
<dt>TRUE</dt><dd><p>Points outside the viewing area are fixed to the
plot boundaries, in order to represent that there are additional
points outside the boundary. This setting is recommended when
the reasonable viewing area is smaller than the actual data,
for example to be consistent across plot panels, but where
you want to indicate that points may be outside the range.</p>
</dd>
<dt>FALSE</dt><dd><p>Points outside the viewing area is not displayed,
with no special visual indication. This setting is useful when
data may contain a large number of points at <code>c(0, 0)</code> and the
density overwhelms the detail in the rest of the plot. In that
case setting <code>xlim=c(1e-10, 10)</code> and <code>applyRangeCeiling=FALSE</code>
would obscure these points.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="plotSmoothScatter_+3A_useraster">useRaster</code></td>
<td>
<p><code>logical</code> indicating whether to produce plots using the
<code>graphics::rasterImage()</code> function which produces a plot
raster image offline then scales this image to visible plot space.
This technique has two benefits:
</p>

<ol>
<li><p> It produces substantially faster plot output.
</p>
</li>
<li><p> Output contains substantially fewer plot objects, which results
in much smaller file sizes when saving in 'PDF' or 'SVG' format.
</p>
</li></ol>
</td></tr>
<tr><td><code id="plotSmoothScatter_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating whether to print verbose output.</p>
</td></tr>
<tr><td><code id="plotSmoothScatter_+3A_...">...</code></td>
<td>
<p>additional arguments are passed to called functions,
including <code>getColorRamp()</code>, <code>nullPlot()</code>, <code>smoothScatterJam()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function intends to make several potentially customizable
features of <code>graphics::smoothScatter()</code> plots much easier
to customize. For example bandwidthN allows defining the number of
bandwidth steps used by the kernel density function, and importantly
bases the number of steps on the visible plot window, and not the range
of data, which can differ substantially. The <code>nbin</code> argument is related,
but is used to define the level of detail used in the image function,
which when plotting numerous smaller panels, can be useful to reduce
unnecessary visual details.
</p>
<p>This function also by default produces a raster image plot
with <code>useRaster=TRUE</code>, which adjusts the x- and y-bandwidth to
produce visually round density even when the x- and y-ranges
are very different.
</p>
<p>Comments:
</p>

<ul>
<li> <p><code>asp=1</code> will define an aspect ratio 1, meaning the x-axis and y-axis
units will be the same physical size in the output device.
When this is true, and <code>fillBackground=TRUE</code> the <code>xlim</code> and <code>ylim</code>
values follow logic for <code>plot.default()</code> and <code>plot.window()</code> such that
each axis will include at least the <code>xlim</code> and <code>ylim</code> ranges, with
additional range included in order to maintain the plot aspect ratio.
</p>
</li>
<li><p> When <code>asp</code>, and any of <code>xlim</code> or <code>ylim</code>, are defined, the data will
be &quot;cropped&quot; to respective <code>xlim</code> and <code>ylim</code> values as relevant,
after which the plot is drawn with the appropriate plot aspect ratio.
When <code>applyRangeCeiling=TRUE</code>, points outside the fixed <code>xlim</code> and <code>ylim</code>
range are fixed to the edge of the range, after which the plot is drawn
with the requested plot aspect ratio. It is recommended not to define
<code>xlim</code> and <code>ylim</code> when also defining <code>asp</code>.
</p>
</li>
<li><p> When <code>add=TRUE</code> the <code>xlim</code> and <code>ylim</code> values are already defined
by the plot device. It is recommended not to define <code>xlim</code> and <code>ylim</code>
when <code>add=TRUE</code>.
</p>
</li></ul>



<h3>Value</h3>

<p><code>list</code> invisibly, sufficient to reproduce most of the
graphical parameters used to create the smooth scatter plot.
</p>


<h3>See Also</h3>

<p>Other jam plot functions: 
<code><a href="#topic+adjustAxisLabelMargins">adjustAxisLabelMargins</a>()</code>,
<code><a href="#topic+coordPresets">coordPresets</a>()</code>,
<code><a href="#topic+decideMfrow">decideMfrow</a>()</code>,
<code><a href="#topic+drawLabels">drawLabels</a>()</code>,
<code><a href="#topic+getPlotAspect">getPlotAspect</a>()</code>,
<code><a href="#topic+groupedAxis">groupedAxis</a>()</code>,
<code><a href="#topic+imageByColors">imageByColors</a>()</code>,
<code><a href="#topic+imageDefault">imageDefault</a>()</code>,
<code><a href="#topic+minorLogTicksAxis">minorLogTicksAxis</a>()</code>,
<code><a href="#topic+nullPlot">nullPlot</a>()</code>,
<code><a href="#topic+plotPolygonDensity">plotPolygonDensity</a>()</code>,
<code><a href="#topic+plotRidges">plotRidges</a>()</code>,
<code><a href="#topic+shadowText">shadowText</a>()</code>,
<code><a href="#topic+shadowText_options">shadowText_options</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+sqrtAxis">sqrtAxis</a>()</code>,
<code><a href="#topic+usrBox">usrBox</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># doTest=TRUE invisibly returns the test data
x &lt;- plotSmoothScatter(doTest=TRUE);

# so it can be plotted again with different settings
colnames(x) &lt;- c("column_1", "column_2")
plotSmoothScatter(x, colramp="RdBu_r");

</code></pre>

<hr>
<h2 id='printDebug'>print colorized output to R console</h2><span id='topic+printDebug'></span><span id='topic+printDebugI'></span><span id='topic+printDebugHtml'></span>

<h3>Description</h3>

<p>print colorized output to R console
</p>
<p>print colorized output to R console, inverted
</p>
<p>print colorized output to HTML
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printDebug(
  ...,
  fgText = NULL,
  fgDefault = getOption("jam.fgDefault", c("darkorange1", "dodgerblue")),
  bgText = NULL,
  fgTime = getOption("jam.fgTime", "cyan2"),
  timeStamp = getOption("jam.timeStamp", TRUE),
  comment = getOption("jam.comment", !htmlOut),
  formatNumbers = getOption("jam.formatNumbers", TRUE),
  trim = getOption("jam.trim", TRUE),
  digits = getOption("jam.digits"),
  nsmall = getOption("jam.nsmall", 0L),
  justify = "left",
  big.mark = getOption("jam.big.mark", ","),
  small.mark = getOption("jam.small.mark", "."),
  zero.print = NULL,
  width = NULL,
  doColor = getOption("jam.doColor"),
  splitComments = FALSE,
  collapse = getOption("jam.collapse", ""),
  sep = getOption("jam.sep", ","),
  doReset = NULL,
  detectColors = TRUE,
  dex = 2,
  darkFactor = c(1, 1.5),
  sFactor = c(1, 1.5),
  lightMode = checkLightMode(),
  Crange = getOption("jam.Crange"),
  Lrange = getOption("jam.Lrange"),
  removeNA = FALSE,
  replaceNULL = NULL,
  adjustRgb = getOption("jam.adjustRgb"),
  byLine = FALSE,
  verbose = FALSE,
  indent = "",
  keepNA = TRUE,
  file = getOption("jam.file", ""),
  append = getOption("jam.append", TRUE),
  invert = getOption("jam.invert", FALSE),
  htmlOut = getOption("jam.htmlOut", FALSE)
)

printDebugI(..., invert = TRUE)

printDebugHtml(..., htmlOut = TRUE, comment = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="printDebug_+3A_...">...</code></td>
<td>
<p><code>character</code>, <code>factor</code>, <code>numeric</code> or compatible atomic vectors
to be printed to the R console. These arguments are recognized as
any un-named argument, or any argument whose name does not match the
named arguments below.</p>
</td></tr>
<tr><td><code id="printDebug_+3A_fgtext">fgText</code></td>
<td>
<p>one of two formats to define the foreground color for
elements in <code>...</code> being printed. Each element is colored in order,
and when multiple vector values are contained in one <code>...</code> element,
the color defined in <code>fgText</code> is extended.
The input types recognized:
</p>

<ul>
<li> <p><code>NULL</code> when no color is defined, one of two outputs:
</p>

<ol>
<li><p> When all values in <code>...</code> represent colors, these colors are
used to colorize the output text. When <code>names()</code> are present
they are used as the text labels in place of the vector value.
</p>
</li>
<li><p> When not all values in <code>...</code> represent colors, the default
color set is used: <code>c("darkorange1", "dodgerblue")</code>.
</p>
</li>
<li><p> To disable option 1 above, define a specific value for <code>fgText</code>,
such as <code>fgText=c("darkorange1", "dodgerblue")</code>.
</p>
</li></ol>

</li>
<li> <p><code>vector</code> of R compatible colors, recycled to the length of <code>...</code>.
When any element of <code>...</code> is a vector with multiple values, the
corresponding color in <code>fgText</code> is shaded slightly lighter and
darker, then recycled to the vector length, so that adjacent values
have slightly different color.
This behavior is controlled by default argument <code>splitComments=TRUE</code>.
</p>
</li>
<li> <p><code>list</code> of vectors of R compatible colors, recycled to the length
of <code>...</code>, then applied to each element in <code>...</code> in order. When only
one color is defined, and multiple values are present in the
corresponding <code>list</code> element, the color is shaded slightly lighter
and darker, then recycled to the vector length, as described above.
This behavior is controlled by default argument <code>splitComments=TRUE</code>.
When multiple colors are defined for the <code>list</code> element, these
values are recycled to the vector length.
</p>
</li>
<li> <p><strong>Note</strong>: When <code>invert=TRUE</code> the values for <code>fgText</code> and <code>bgText</code> are
reversed, and if the resulting <code>fgText</code> is <code>NULL</code> then its color
is defined by <code>setTextContrastColor()</code> in order to define a contrasting
text color.
</p>
</li></ul>
</td></tr>
<tr><td><code id="printDebug_+3A_fgdefault">fgDefault</code></td>
<td>
<p><code>character</code> defaults to
<code>getOption("jam.fgDefault", c("darkorange1", "dodgerblue"))</code>, and
is used when colors are not defined by <code>fgText</code> or by the
input <code>...</code> values.</p>
</td></tr>
<tr><td><code id="printDebug_+3A_bgtext">bgText</code></td>
<td>
<p><code>vector</code> of R colors, or <code>list</code> of vectors, used to define
the background color, using the same approach described for <code>fgText</code>.
Note that <code>NULL</code> or <code>NA</code> defines the absence of any background color,
which is default. When <code>invert=TRUE</code>, which is default for
<code>printDebugI()</code>, the values for <code>fgText</code> and <code>bgText</code> are reversed.</p>
</td></tr>
<tr><td><code id="printDebug_+3A_fgtime">fgTime</code></td>
<td>
<p><code>character</code> R color to colorize the time</p>
</td></tr>
<tr><td><code id="printDebug_+3A_timestamp">timeStamp</code></td>
<td>
<p><code>logical</code> whether to include a time stamp in output</p>
</td></tr>
<tr><td><code id="printDebug_+3A_comment">comment</code></td>
<td>
<p><code>logical</code> whether to prefix output with '## ' as a comment,
or <code>character</code> string used as a prefix.</p>
</td></tr>
<tr><td><code id="printDebug_+3A_formatnumbers">formatNumbers</code></td>
<td>
<p><code>logical</code> whether to format numbers using
<code>format()</code> which controls the number of digits displayed, and is
default. When <code>formatNumbers=FALSE</code> sometimes <code>numeric</code> values
that contain <code>integers</code> may be represented as <code>14.0000000001</code>.</p>
</td></tr>
<tr><td><code id="printDebug_+3A_trim">trim</code>, <code id="printDebug_+3A_digits">digits</code>, <code id="printDebug_+3A_nsmall">nsmall</code>, <code id="printDebug_+3A_justify">justify</code>, <code id="printDebug_+3A_big.mark">big.mark</code>, <code id="printDebug_+3A_small.mark">small.mark</code>, <code id="printDebug_+3A_zero.print">zero.print</code>, <code id="printDebug_+3A_width">width</code></td>
<td>
<p>arguments passed to <code>format()</code>.</p>
</td></tr>
<tr><td><code id="printDebug_+3A_docolor">doColor</code></td>
<td>
<p><code>logical</code> or <code>NULL</code> indicating whether to colorize output.
When <code>doColor</code> is <code>NULL</code>, if the <code>"crayon"</code> package is available,
and if crayon detects color is permitted, color is enabled.</p>
</td></tr>
<tr><td><code id="printDebug_+3A_splitcomments">splitComments</code></td>
<td>
<p><code>logical</code> whether to color each element independently
without light-dark alternating pattern. The intensity of the
adjustment is controlled by <code>dex</code> passed to <code>color2gradient()</code>.</p>
</td></tr>
<tr><td><code id="printDebug_+3A_collapse">collapse</code></td>
<td>
<p><code>character</code> collapse string used to separate list items,
by default &quot;&quot; so text separation is expected in the input data.</p>
</td></tr>
<tr><td><code id="printDebug_+3A_sep">sep</code></td>
<td>
<p><code>character</code> separator used to separate vector elements, when
a list items contains a vector.</p>
</td></tr>
<tr><td><code id="printDebug_+3A_doreset">doReset</code></td>
<td>
<p><code>logical</code> or <code>NULL</code>, indicating whether to apply
<code>crayon::reset()</code> to the delimiter <code>sep</code>. When <code>doReset=TRUE</code> the
style on the delimiter is forced to reset, using <code>crayon::reset()</code>,
or to remove pre-existing style with <code>crayon::strip_style()</code>. When
<code>doReset=NULL</code> and <code>sep</code> contains ANSI escape characters, they are
left as-is; when <code>doReset=NULL</code> and <code>sep</code> does not contain ANSI escape
characters, <code>sep</code> becomes <code>crayon::reset(sep)</code> which forces the style
to be reset between printed values.</p>
</td></tr>
<tr><td><code id="printDebug_+3A_detectcolors">detectColors</code></td>
<td>
<p><code>logical</code> whether to detect and potentially try to
correct console color capabilities.</p>
</td></tr>
<tr><td><code id="printDebug_+3A_dex">dex</code></td>
<td>
<p><code>numeric</code> passed to <code>color2gradient()</code> to split a color
into a lighter,darker alternating pattern. Until version 0.0.83.900,
this process used <code>gradientWtFactor=1</code> and was not adjustable.
Note that when <code>splitComments=TRUE</code> the input values in <code>...</code>
are flattened to a single vector, and colors in <code>fgText</code> are
applied directly without adjustment.</p>
</td></tr>
<tr><td><code id="printDebug_+3A_darkfactor">darkFactor</code>, <code id="printDebug_+3A_sfactor">sFactor</code></td>
<td>
<p><code>numeric</code> arguments deprecated.</p>
</td></tr>
<tr><td><code id="printDebug_+3A_lightmode">lightMode</code></td>
<td>
<p><code>logical</code> or NULL, indicating whether the text
background color is light, where <code>lightMode=TRUE</code> indicates the
background is white or light enough to require darker text,
imposing a maximum brightness for colors displayed.
When <code>NULL</code> it calls <code>checkLightMode()</code>, which uses:
</p>

<ul>
<li> <p><code>getOption("jam.lightMode")</code> if defined
</p>
</li>
<li><p> otherwise attempts to detect whether the session is running inside
RStudio, by checking for environmental variable <code>"RSTUDIO"</code>,
under the assumption that default RStudio uses a light background,
therefore <code>lightMode=TRUE</code>.
</p>
</li>
<li><p> if steps above fail, it uses <code>lightMode=FALSE</code>.
</p>
</li>
<li><p> to force a specific lightMode for all uses, use options:
<code>options(jam.lightMode=TRUE)</code> or <code>options(jam.lightMode=FALSE)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="printDebug_+3A_crange">Crange</code>, <code id="printDebug_+3A_lrange">Lrange</code></td>
<td>
<p><code>numeric</code> range of chroma and luminance values
between 0 and 100. When NULL, default values are assigned
by <code>setCLranges()</code>. The intent is to restrict the range relative
to the console background color, also controlled by <code>lightMode</code>.</p>
</td></tr>
<tr><td><code id="printDebug_+3A_removena">removeNA</code></td>
<td>
<p><code>logical</code> whether to remove NA values and not print to
the console.</p>
</td></tr>
<tr><td><code id="printDebug_+3A_replacenull">replaceNULL</code></td>
<td>
<p><code>character</code> or NULL, optionally replace NULL elements
with non-NULL character value, otherwise NULL elements are ignored.</p>
</td></tr>
<tr><td><code id="printDebug_+3A_adjustrgb">adjustRgb</code></td>
<td>
<p><code>numeric</code> value adjustment used during the conversion of
RGB colors to ANSI colors, which is inherently lossy. If not defined,
it uses the default returned by <code>setCLranges()</code> which itself uses
<code>getOption("jam.adjustRgb")</code> with default=0. In order to boost
color contrast, an alternate value of -0.1 is suggested.</p>
</td></tr>
<tr><td><code id="printDebug_+3A_byline">byLine</code></td>
<td>
<p><code>logical</code> whether to delimit lists by line instead of
using collapse to combine them onto one line.</p>
</td></tr>
<tr><td><code id="printDebug_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> whether to print verbose output</p>
</td></tr>
<tr><td><code id="printDebug_+3A_indent">indent</code></td>
<td>
<p><code>character</code> optional characters used as a prefix to indent
output. When <code>numeric</code> it is rounded to integer, then this many
character spaces <code>" "</code> are concatenated together to define the
indent width. Note that the <code>indent</code> text is not colorized.</p>
</td></tr>
<tr><td><code id="printDebug_+3A_keepna">keepNA</code></td>
<td>
<p><code>logical</code>, default TRUE, whether to keep and print NA values.</p>
</td></tr>
<tr><td><code id="printDebug_+3A_file">file</code></td>
<td>
<p>argument passed to <code>cat()</code> to send output to a file or
compatible output of <code>cat()</code>.</p>
</td></tr>
<tr><td><code id="printDebug_+3A_append">append</code></td>
<td>
<p><code>logical</code> whether to append output, passed to <code>cat()</code>
when <code>file</code> is defined.</p>
</td></tr>
<tr><td><code id="printDebug_+3A_invert">invert</code></td>
<td>
<p><code>logical</code> indicating whether foreground and background
colors should be switched, as is default for <code>printDebugI()</code>.
Note when the resulting <code>fgText</code> is <code>NULL</code>, its color is defined
by <code>setTextContrastColor()</code> to define a contrasting text color
relative to the background color in <code>bgText</code>.</p>
</td></tr>
<tr><td><code id="printDebug_+3A_htmlout">htmlOut</code></td>
<td>
<p><code>logical</code> indicating whether to print HTML span
output, using format
<code style="white-space: pre;">&#8288;&lt;span style="color:fg;background-color:bg"&gt;text&lt;/span&gt;&#8288;</code>.
This argument is not yet implemented, more testing is required
to determine the best mechanism to use for things like 'Rmarkdown'
rendering, and R-shiny app rendering.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function prints colorized output to the R console, with some
rules for colorizing the output to help visually distinguish items.
</p>
<p>The main intent is to use this function to print pretty debug messages,
because color helps identify.
</p>
<p>By default, output has the following configurable properties:
</p>

<ul>
<li><p> each line begins with a comment, controlled by default
<code>comment=getOption("jam.comment", TRUE)</code> which by default uses <code>"##"</code>,
but which can be defined to use a different prefix, or <code>FALSE</code>
for no prefix at all.
</p>
</li>
<li><p> each line includes time and date stamp controlled by
<code>timeStamp=getOption("jam.timeStamp", TRUE)</code> which by default includes the
current time and date.
</p>
</li>
<li><p> each line formats <code>numeric</code> values, controlled by
<code>formatNumbers=getOption("jam.formatNumbers", TRUE)</code>, which determines
whether to apply arguments <code>big.mark</code> and <code>small.mark</code> to make numeric
values more readable.
</p>
</li>
<li><p> each entry in <code>...</code> is printed with its own foreground color <code>fgText</code>,
background color <code>bgText</code>, with a slight lighter/darker dithering effect
to add minor visual distinction for multiple values.
</p>
</li>
<li><p> Values in each <code>vector</code> are concatenated by <code>sep=","</code> by default.
</p>
</li>
<li><p> Each <code>list</code> is concatenated by <code>collapse=""</code> by default.
</p>
</li></ul>

<p>Additional convenience rules:
</p>

<ul>
<li><p> For convenience, when the last <code>...</code> argument is a <code>character</code> vector
of colors, it is assumed to be <code>fgText</code>.
</p>
</li>
<li><p> When the only entry in <code>...</code> is a <code>character</code> vector of R colors,
the names are printed using the color vector for <code>fgText</code>, or if no
names exist the colors are printed using the color vector for <code>fgText</code>.
</p>
</li>
<li><p> For <code>printDebugI()</code> or <code>invert=TRUE</code>, colors typically assigned to
<code>fgText</code> are instead assigned to <code>bgText</code>.
</p>
</li>
<li><p> For very specific color assignments, <code>fgText</code> and/or <code>bgText</code> can be
defined as a <code>list</code> of <code>character</code> vectors of R colors, in which case
the <code>list</code> overall is recycled to the length <code>...</code> to be printed,
and within each vector of <code>...</code> printed the corresponding color vector
is recycled to the length of that vector.
</p>
</li></ul>

<p>For use inside 'Rmarkdown' <code>.Rmd</code> documents, current recommendation is
to define the R output with <code>results='asis'</code> like this:
</p>
<div class="sourceCode"><pre>\`\`\`{r block_name, results='asis'}
# some R code here
\`\`\`
</pre></div>
<p>Then define a global option to turn off the comment prefix in
<code>printDebug()</code>: <code>options("jam.comment"=FALSE)</code>
</p>
<p>For colorized text, it may require <code>"html_output"</code> rendering of the
<code>.Rmd</code> 'Rmarkdown' file, as well as this option to enable HTML formatting
by <code>printDebug()</code>: <code>options("jam.htmlOut"=TRUE)</code>.
</p>
<p>This function prints colorized output to the R console, using the
same logic as <code>printDebug</code> except by default the color is inverted
so the default <code>fgText</code> colors are applied to the background.
</p>
<p>This function prints colorized output in HTML form, using the
same logic as <code>printDebug()</code> except by default the output is HTML.
The intended use is for 'Rmarkdown' with chunk option <code>results='asis'</code>,
which causes the HTML code to be interpreted directly as HTML.
</p>
<p>This function internally calls <code>printDebug()</code> which then calls
<code>make_html_styles()</code>. The text is surrounded by <code style="white-space: pre;">&#8288;&lt;span color='#FFFFFF'&gt;&#8288;</code>
HTML formatting.
</p>


<h3>Value</h3>

<p><code>NULL</code> invisibly, this function is called for the side effect
of printing output using <code>cat()</code>.
</p>
<p><code>NULL</code> invisibly, this function is called for the side effect
of printing output using <code>cat()</code>.
</p>
<p><code>NULL</code> invisibly, this function is called for the side effect
of printing output using <code>cat()</code>.
</p>


<h3>See Also</h3>

<p>Other jam practical functions: 
<code><a href="#topic+breakDensity">breakDensity</a>()</code>,
<code><a href="#topic+call_fn_ellipsis">call_fn_ellipsis</a>()</code>,
<code><a href="#topic+checkLightMode">checkLightMode</a>()</code>,
<code><a href="#topic+check_pkg_installed">check_pkg_installed</a>()</code>,
<code><a href="#topic+colNum2excelName">colNum2excelName</a>()</code>,
<code><a href="#topic+color_dither">color_dither</a>()</code>,
<code><a href="#topic+exp2signed">exp2signed</a>()</code>,
<code><a href="#topic+getAxisLabel">getAxisLabel</a>()</code>,
<code><a href="#topic+isFALSEV">isFALSEV</a>()</code>,
<code><a href="#topic+isTRUEV">isTRUEV</a>()</code>,
<code><a href="#topic+jargs">jargs</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+lldf">lldf</a>()</code>,
<code><a href="#topic+log2signed">log2signed</a>()</code>,
<code><a href="#topic+middle">middle</a>()</code>,
<code><a href="#topic+minorLogTicks">minorLogTicks</a>()</code>,
<code><a href="#topic+newestFile">newestFile</a>()</code>,
<code><a href="#topic+reload_rmarkdown_cache">reload_rmarkdown_cache</a>()</code>,
<code><a href="#topic+renameColumn">renameColumn</a>()</code>,
<code><a href="#topic+rmInfinite">rmInfinite</a>()</code>,
<code><a href="#topic+rmNA">rmNA</a>()</code>,
<code><a href="#topic+rmNAs">rmNAs</a>()</code>,
<code><a href="#topic+rmNULL">rmNULL</a>()</code>,
<code><a href="#topic+setPrompt">setPrompt</a>()</code>
</p>
<p>Other jam practical functions: 
<code><a href="#topic+breakDensity">breakDensity</a>()</code>,
<code><a href="#topic+call_fn_ellipsis">call_fn_ellipsis</a>()</code>,
<code><a href="#topic+checkLightMode">checkLightMode</a>()</code>,
<code><a href="#topic+check_pkg_installed">check_pkg_installed</a>()</code>,
<code><a href="#topic+colNum2excelName">colNum2excelName</a>()</code>,
<code><a href="#topic+color_dither">color_dither</a>()</code>,
<code><a href="#topic+exp2signed">exp2signed</a>()</code>,
<code><a href="#topic+getAxisLabel">getAxisLabel</a>()</code>,
<code><a href="#topic+isFALSEV">isFALSEV</a>()</code>,
<code><a href="#topic+isTRUEV">isTRUEV</a>()</code>,
<code><a href="#topic+jargs">jargs</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+lldf">lldf</a>()</code>,
<code><a href="#topic+log2signed">log2signed</a>()</code>,
<code><a href="#topic+middle">middle</a>()</code>,
<code><a href="#topic+minorLogTicks">minorLogTicks</a>()</code>,
<code><a href="#topic+newestFile">newestFile</a>()</code>,
<code><a href="#topic+reload_rmarkdown_cache">reload_rmarkdown_cache</a>()</code>,
<code><a href="#topic+renameColumn">renameColumn</a>()</code>,
<code><a href="#topic+rmInfinite">rmInfinite</a>()</code>,
<code><a href="#topic+rmNA">rmNA</a>()</code>,
<code><a href="#topic+rmNAs">rmNAs</a>()</code>,
<code><a href="#topic+rmNULL">rmNULL</a>()</code>,
<code><a href="#topic+setPrompt">setPrompt</a>()</code>
</p>
<p>Other jam practical functions: 
<code><a href="#topic+breakDensity">breakDensity</a>()</code>,
<code><a href="#topic+call_fn_ellipsis">call_fn_ellipsis</a>()</code>,
<code><a href="#topic+checkLightMode">checkLightMode</a>()</code>,
<code><a href="#topic+check_pkg_installed">check_pkg_installed</a>()</code>,
<code><a href="#topic+colNum2excelName">colNum2excelName</a>()</code>,
<code><a href="#topic+color_dither">color_dither</a>()</code>,
<code><a href="#topic+exp2signed">exp2signed</a>()</code>,
<code><a href="#topic+getAxisLabel">getAxisLabel</a>()</code>,
<code><a href="#topic+isFALSEV">isFALSEV</a>()</code>,
<code><a href="#topic+isTRUEV">isTRUEV</a>()</code>,
<code><a href="#topic+jargs">jargs</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+lldf">lldf</a>()</code>,
<code><a href="#topic+log2signed">log2signed</a>()</code>,
<code><a href="#topic+middle">middle</a>()</code>,
<code><a href="#topic+minorLogTicks">minorLogTicks</a>()</code>,
<code><a href="#topic+newestFile">newestFile</a>()</code>,
<code><a href="#topic+reload_rmarkdown_cache">reload_rmarkdown_cache</a>()</code>,
<code><a href="#topic+renameColumn">renameColumn</a>()</code>,
<code><a href="#topic+rmInfinite">rmInfinite</a>()</code>,
<code><a href="#topic+rmNA">rmNA</a>()</code>,
<code><a href="#topic+rmNAs">rmNAs</a>()</code>,
<code><a href="#topic+rmNULL">rmNULL</a>()</code>,
<code><a href="#topic+setPrompt">setPrompt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>printDebug("Testing ", "default ", "printDebug().");
printDebug("List of vectors:", c("one", "two", "three"));

# By default, there is no space between separate elements in `...`
printDebug("List of vectors:", c("one", "two", "three"),
   c("four", "five", "six"));
# To add a space " " between elements, use collapse
printDebug("List of vectors:", c("one", "two", "three"),
   c("four", "five", "six"), collapse=" ");

# slightly different style, one entry per line, indented:
printDebug("List of vectors:", c("one", "two", "three"),
   c("four", "five", "six"), collapse="\n   ");

# when a vector entirely contains recognized colors,
# the colors are used in the output
printDebug(c("red", "blue", "yellow"));

# When the vector contains colors, the names are used as the label
color_vector &lt;- jamba::nameVector(c("red", "blue", "green","orange"),
   c("group_A", "group_B", "group_C", "group_D"));
printDebug(color_vector);

# Remember the sister function that inverses the colors
printDebugI(color_vector);

printDebug(1:10, fgText="blue", dex=2);
printDebug(1:10, bgText="blue", dex=2);
printDebug(1:10, fgText="orange", dex=2);

</code></pre>

<hr>
<h2 id='provigrep'>provigrep: progressive case-insensitive value-grep</h2><span id='topic+provigrep'></span><span id='topic+proigrep'></span>

<h3>Description</h3>

<p>case-insensitive value-grep for a vector of patterns
</p>
<p>case-insensitive grep for a vector of patterns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>provigrep(
  patterns,
  x,
  maxValues = NULL,
  sortFunc = c,
  rev = FALSE,
  returnType = c("vector", "list"),
  ignore.case = TRUE,
  value = TRUE,
  ...
)

proigrep(..., value = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="provigrep_+3A_patterns">patterns</code></td>
<td>
<p><code>character</code> vector of regular expression patterns,
ultimately passed to <code>base::grep()</code>.</p>
</td></tr>
<tr><td><code id="provigrep_+3A_x">x</code></td>
<td>
<p><code>character</code> vector that is the subject of <code>base::grep()</code>.</p>
</td></tr>
<tr><td><code id="provigrep_+3A_maxvalues">maxValues</code></td>
<td>
<p><code>integer</code> or NULL, the maximum matching entries to
return per grep pattern. Note that each grep pattern may match multiple
values, and values are only returned at most once each, so restricting
items returned by one grep pattern may allow an item to be matched
by subsequent patterns, see examples. This argument is most commonly
used with <code>maxValues=1</code> which returns only the first matching entry
per pattern.</p>
</td></tr>
<tr><td><code id="provigrep_+3A_sortfunc">sortFunc</code></td>
<td>
<p><code>function</code> or NULL, used to sort entries within each set of
matching entries. Use NULL to avoid sorting entries.</p>
</td></tr>
<tr><td><code id="provigrep_+3A_rev">rev</code></td>
<td>
<p><code>logical</code> whether to reverse the order of matching entries. Use
TRUE if you would like entries matching the patterns to be placed last,
and entries not matching the grep patterns to be placed first. This
technique is effective at placing &quot;noise names&quot; at the end of a long
vector, for example.</p>
</td></tr>
<tr><td><code id="provigrep_+3A_returntype">returnType</code></td>
<td>
<p><code>character</code> indicating whether to return a vector or list.
A list will be in order of the grep patterns, using empty elements to
indicate when no entries matched each pattern. This output is useful
when you would like to know which patterns matched specific entries.</p>
</td></tr>
<tr><td><code id="provigrep_+3A_ignore.case">ignore.case</code></td>
<td>
<p><code>logical</code> parameter sent to <code>base::grep()</code>, TRUE
runs in case-insensitive mode, as by default.</p>
</td></tr>
<tr><td><code id="provigrep_+3A_value">value</code></td>
<td>
<p><code>logical</code> indicating whether to return the matched value,
or when <code>value=FALSE</code> the index position is returned.</p>
</td></tr>
<tr><td><code id="provigrep_+3A_...">...</code></td>
<td>
<p>additional arguments are passed to <code>vigrep()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Purpose is to provide &quot;progressive vigrep()&quot;,which is value-returning,
case-insensitive grep, starting with an ordered vector of grep patterns.
For example, it returns entries in the order they are matched, by the
progressive use of grep patterns.
</p>
<p>It is particularly good when using multiple grep patterns, since
<code>grep()</code> does not accept multiple patterns as input. This function
also only returns the unique matches in the order they were matched,
which alleviates the need to run a series of <code>grep()</code> functions
and collating their results.
</p>
<p>It is mainly to allow for prioritized ordering of matching entries, where
one would like certain matching  entries first, followed by another
set of matching entries, without duplication. For example,
one might grep for a few patterns, but want certain pattern hits to be
listed first.
</p>


<h3>Value</h3>

<p><code>character</code> vector with entries in <code>x</code> reordered to match
the order of <code>patterns</code> provided,  or <code>list</code> when <code>returnType="list"</code>
named by <code>patterns</code> in the order provided. When <code>value=FALSE</code> then
it returns <code>integer</code> index values of <code>x</code>.
</p>


<h3>See Also</h3>

<p>Other jam grep functions: 
<code><a href="#topic+grepls">grepls</a>()</code>,
<code><a href="#topic+igrep">igrep</a>()</code>,
<code><a href="#topic+igrepHas">igrepHas</a>()</code>,
<code><a href="#topic+igrepl">igrepl</a>()</code>,
<code><a href="#topic+unigrep">unigrep</a>()</code>,
<code><a href="#topic+unvigrep">unvigrep</a>()</code>,
<code><a href="#topic+vgrep">vgrep</a>()</code>,
<code><a href="#topic+vigrep">vigrep</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a rather comical example
# set up a test set with labels containing several substrings
set.seed(1);
testTerms &lt;- c("robot","tree","dog","mailbox","pizza","noob");
testWords &lt;- pasteByRow(t(combn(testTerms,3)));

# now pull out entries matching substrings in order
provigrep(c("pizza", "dog", "noob", "."), testWords);
# more detail about the sort order is shown with returnType="list"
provigrep(c("pizza", "dog", "noob", "."), testWords, returnType="list");
# rev=TRUE will reverse the order of the list
provigrep(c("pizza", "dog", "noob", "."), testWords, returnType="list", rev=TRUE);
provigrep(c("pizza", "dog", "noob", "."), testWords, rev=TRUE);

# another example showing ordering of duplicated entries
set.seed(1);
x &lt;- paste0(
   sample(letters[c(1,2,2,3,3,3,4,4,4,4)]),
   sample(1:5));
x;
# sort by letter
provigrep(letters[1:4], x)

# show more detail about how the sort is performed
provigrep(letters[1:4], x, returnType="list")

# rev=TRUE will reverse the order of pattern matching
# which is most useful when "." is the last pattern:
provigrep(c(letters[1:3], "."), x, returnType="list")
provigrep(c(letters[1:3], "."), x, returnType="list", rev=TRUE)

# example demonstrating maxValues
# return in list format
provigrep(c("[ABCD]", "[CDEF]", "[FGHI]"), LETTERS, returnType="list")

# maxValues=1
provigrep(c("[ABCD]", "[CDEF]", "[FGHI]"), LETTERS, returnType="list", maxValues=1)
provigrep(c("[ABCD]", "[CDEF]", "[FGHI]"), LETTERS, returnType="list", maxValues=1, value=FALSE)
proigrep(c("[ABCD]", "[CDEF]", "[FGHI]"), LETTERS, maxValues=1)

</code></pre>

<hr>
<h2 id='rad2deg'>Convert radians to degrees</h2><span id='topic+rad2deg'></span>

<h3>Description</h3>

<p>Convert radians to degrees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rad2deg(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rad2deg_+3A_x">x</code></td>
<td>
<p><code>numeric</code> vector, expected to be radian values between zero
and pi*2.</p>
</td></tr>
<tr><td><code id="rad2deg_+3A_...">...</code></td>
<td>
<p>other parameters are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simply converts radians which range from zero to pi*2,
into degrees which range from 0 to 360.
</p>


<h3>Value</h3>

<p><code>numeric</code> vector after coverting radians to degrees.
</p>


<h3>See Also</h3>

<p>Other jam numeric functions: 
<code><a href="#topic+deg2rad">deg2rad</a>()</code>,
<code><a href="#topic+noiseFloor">noiseFloor</a>()</code>,
<code><a href="#topic+normScale">normScale</a>()</code>,
<code><a href="#topic+rowGroupMeans">rowGroupMeans</a>()</code>,
<code><a href="#topic+rowRmMadOutliers">rowRmMadOutliers</a>()</code>,
<code><a href="#topic+warpAroundZero">warpAroundZero</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rad2deg(c(pi*2, pi/2))

</code></pre>

<hr>
<h2 id='rainbow2'>Simple rainbow palette replacement</h2><span id='topic+rainbow2'></span>

<h3>Description</h3>

<p>Simple rainbow palette replacement using variable saturation and vibrance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rainbow2(n, s = c(0.9, 0.7, 0.88, 0.55), v = c(0.92, 1, 0.85, 0.94), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rainbow2_+3A_n">n</code></td>
<td>
<p><code>integer</code> number of colors requested</p>
</td></tr>
<tr><td><code id="rainbow2_+3A_s">s</code>, <code id="rainbow2_+3A_v">v</code></td>
<td>
<p><code>numeric</code> vector of values to recycle as saturation and
vibrance, respectively. The purpose is to improve visual distinction
between adjacent and nearby colors in the color wheel.</p>
</td></tr>
<tr><td><code id="rainbow2_+3A_...">...</code></td>
<td>
<p>additional arguments are passed to <code>grDevices::rainbow()</code>:
</p>

<ul>
<li> <p><code>start</code>,<code>end</code> to control the starting and ending hue <code style="white-space: pre;">&#8288;[0,1]&#8288;</code>,
</p>
</li>
<li> <p><code>alpha</code> for alpha opacity, default NULL adds no alpha,
</p>
</li>
<li> <p><code>rev</code> to reverse the color order.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character</code> vector of R colors.
</p>


<h3>See Also</h3>

<p>Other jam color functions: 
<code><a href="#topic+alpha2col">alpha2col</a>()</code>,
<code><a href="#topic+applyCLrange">applyCLrange</a>()</code>,
<code><a href="#topic+col2alpha">col2alpha</a>()</code>,
<code><a href="#topic+col2hcl">col2hcl</a>()</code>,
<code><a href="#topic+col2hsl">col2hsl</a>()</code>,
<code><a href="#topic+col2hsv">col2hsv</a>()</code>,
<code><a href="#topic+color2gradient">color2gradient</a>()</code>,
<code><a href="#topic+fixYellow">fixYellow</a>()</code>,
<code><a href="#topic+fixYellowHue">fixYellowHue</a>()</code>,
<code><a href="#topic+getColorRamp">getColorRamp</a>()</code>,
<code><a href="#topic+hcl2col">hcl2col</a>()</code>,
<code><a href="#topic+hsl2col">hsl2col</a>()</code>,
<code><a href="#topic+hsv2col">hsv2col</a>()</code>,
<code><a href="#topic+isColor">isColor</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+makeColorDarker">makeColorDarker</a>()</code>,
<code><a href="#topic+rgb2col">rgb2col</a>()</code>,
<code><a href="#topic+setCLranges">setCLranges</a>()</code>,
<code><a href="#topic+setTextContrastColor">setTextContrastColor</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+unalpha">unalpha</a>()</code>,
<code><a href="#topic+warpRamp">warpRamp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showColors(list(
   `rainbow(24)`=grDevices::rainbow(24),
   `rainbow2(24)`=rainbow2(24),
   `rainbow2(24, rev=TRUE)`=rainbow2(24, rev=TRUE),
   `rainbow2(24, start=0.5, end=0.499)`=rainbow2(24,
      start=0.5, end=0.5-1e-5),
   `rainbow2(24, rev=TRUE,\nstart=0.5, end=0.499)`=rainbow2(24,
      rev=TRUE, start=0.5, end=0.5-1e-5)))

</code></pre>

<hr>
<h2 id='rbindList'>rbind a list of vectors into matrix or data.frame</h2><span id='topic+rbindList'></span>

<h3>Description</h3>

<p>rbind a list of vectors into matrix or data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbindList(
  x,
  emptyValue = "",
  nullValue = NULL,
  keepListNames = TRUE,
  newColnames = NULL,
  newRownames = NULL,
  fixBlanks = TRUE,
  returnDF = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rbindList_+3A_x">x</code></td>
<td>
<p><code>list</code> of atomic <code>vector</code>, <code>matrix</code>, or <code>data.frame</code>
objects.</p>
</td></tr>
<tr><td><code id="rbindList_+3A_emptyvalue">emptyValue</code></td>
<td>
<p><code>character</code> value to use to represent missing values,
whenever a blank cell is introduced into the resulting matrix</p>
</td></tr>
<tr><td><code id="rbindList_+3A_nullvalue">nullValue</code></td>
<td>
<p>optional value used to replace NULL entries in
the input list, useful especially when the data was produced
by <code>strsplit()</code> with <code>""</code>. Use <code>nullValue=""</code> to replace <code>NULL</code>
with <code>""</code> and preserve the original list length. Otherwise when
<code>nullValue=NULL</code> any empty entries will be silently dropped.</p>
</td></tr>
<tr><td><code id="rbindList_+3A_keeplistnames">keepListNames</code></td>
<td>
<p><code>logical</code> whether to use list names as rownames
in the resulting matrix or data.frame.</p>
</td></tr>
<tr><td><code id="rbindList_+3A_newcolnames">newColnames</code></td>
<td>
<p>NULL or <code>character</code> vector of colnames to use for the
resulting matrix or data.frame.</p>
</td></tr>
<tr><td><code id="rbindList_+3A_newrownames">newRownames</code></td>
<td>
<p>NULL or <code>character</code> vector of rownames to use for the
resulting matrix or data.frame. If supplied, this value overrides the
keepListNames=TRUE use of list names as rownames.</p>
</td></tr>
<tr><td><code id="rbindList_+3A_fixblanks">fixBlanks</code></td>
<td>
<p><code>logical</code> whether to use blank values instead of repeating
each vector to the length of the maximum vector length when filling
each row of the matrix or data.frame.</p>
</td></tr>
<tr><td><code id="rbindList_+3A_returndf">returnDF</code></td>
<td>
<p><code>logical</code> whether to return a data.frame, by default FALSE,
a matrix is returned.</p>
</td></tr>
<tr><td><code id="rbindList_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> whether to print verbose output during processing.</p>
</td></tr>
<tr><td><code id="rbindList_+3A_...">...</code></td>
<td>
<p>Additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this function is to emulate <code>do.call(rbind, x)</code> on a list
of vectors, while specifically handling when there are different
numbers of entries per vector. The output <code>matrix</code> number of columns
will be the longest vector (or largest number of columns) in the
input list <code>x</code>.
</p>
<p>Instead of recycling values in each row to fill the target number
of columns, this function fills cells with blank fields,
with default argument <code>fixBlanks=TRUE</code>.
</p>
<p>In extensive timings tests at the time this function was created,
this technique was notably faster than alternatives.
It runs  <code>do.call(rbind, x)</code> then subsequently replaces recycled values
with blank entries, in a manner that is notably faster than
alternative approaches such as pre-processing the input data.
</p>


<h3>Value</h3>

<p><code>matrix</code> unless <code>returnDF=TRUE</code> in which the output is coerced
to a <code>data.frame</code>.
The rownames by default are derived from the list names,
but the colnames are not derived from the vector names.
If input <code>x</code> contains <code>data.frame</code> or <code>matrix</code> objects, the output
will retain those values.
</p>


<h3>See Also</h3>

<p>Other jam list functions: 
<code><a href="#topic+cPaste">cPaste</a>()</code>,
<code><a href="#topic+heads">heads</a>()</code>,
<code><a href="#topic+jam_rapply">jam_rapply</a>()</code>,
<code><a href="#topic+list2df">list2df</a>()</code>,
<code><a href="#topic+mergeAllXY">mergeAllXY</a>()</code>,
<code><a href="#topic+mixedSorts">mixedSorts</a>()</code>,
<code><a href="#topic+relist_named">relist_named</a>()</code>,
<code><a href="#topic+rlengths">rlengths</a>()</code>,
<code><a href="#topic+sclass">sclass</a>()</code>,
<code><a href="#topic+sdim">sdim</a>()</code>,
<code><a href="#topic+uniques">uniques</a>()</code>,
<code><a href="#topic+unnestList">unnestList</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L &lt;- list(a=LETTERS[1:4], b=letters[1:3]);
rbindList(L);
rbindList(L, returnDF=TRUE);

</code></pre>

<hr>
<h2 id='readOpenxlsx'>Import one or more data.frame from 'Excel' 'xlsx' format</h2><span id='topic+readOpenxlsx'></span>

<h3>Description</h3>

<p>Import one or more data.frame from 'Excel' 'xlsx' format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readOpenxlsx(
  xlsx,
  sheet = NULL,
  startRow = 1,
  startCol = 1,
  rows = NULL,
  cols = NULL,
  check.names = FALSE,
  check_header = FALSE,
  check_header_n = 10,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readOpenxlsx_+3A_xlsx">xlsx</code></td>
<td>
<p><code>character</code> path to an 'Excel' file in <code>xlsx</code> format,
compatible with <code>openxlsx::read.xlsx()</code>.</p>
</td></tr>
<tr><td><code id="readOpenxlsx_+3A_sheet">sheet</code></td>
<td>
<p>one of <code>NULL</code>, <code>character</code>, or <code>integer</code> vector,
where: <code>sheet=NULL</code> will import every sheet; <code>character</code> is
a vector of sheet names; and <code>integer</code> is a vector of sheet
index values. The sheet names are determined with
<code>openxlsx::getSheetNames()</code>.</p>
</td></tr>
<tr><td><code id="readOpenxlsx_+3A_startrow">startRow</code></td>
<td>
<p><code>integer</code> indicating the row number to start
importing each <code>sheet</code>.
</p>

<ul>
<li><p> Note <code>startRow</code> can be a vector
with length <code>length(sheet)</code>, to specify the <code>startRow</code> for
each <code>sheet</code>.
</p>
</li>
<li><p> Note <code>startRow</code> is ignored when <code>rows</code> is defined for the same sheet,
to minimize confusion about using both togetheer.
</p>
</li></ul>
</td></tr>
<tr><td><code id="readOpenxlsx_+3A_startcol">startCol</code></td>
<td>
<p><code>integer</code> indicating the first column number to retain
after importing each <code>sheet</code>.
</p>

<ul>
<li><p> Note <code>startCol</code> can be a vector with length <code>length(sheet)</code>,
to specify the <code>startCol</code> for each <code>sheet</code>.
</p>
</li>
<li><p> Note <code>startCol</code> is ignored when <code>cols</code> is defined for the same sheet,
to minimize confusion about using both togetheer.
</p>
</li></ul>
</td></tr>
<tr><td><code id="readOpenxlsx_+3A_rows">rows</code></td>
<td>
<p><code>integer</code> vector indicating specific rows to import
for each <code>sheet</code>.
</p>

<ul>
<li><p> To specify different <code>rows</code> for each <code>sheet</code>,
supply <code>rows</code> as a <code>list</code> of <code>integer</code> vectors.
</p>
</li>
<li><p> Note that when <code>rows</code> is defined for a sheet, it will be used
and <code>startRow</code> will be ignored for that same sheet.
</p>
</li></ul>
</td></tr>
<tr><td><code id="readOpenxlsx_+3A_cols">cols</code></td>
<td>
<p><code>integer</code> vector indicating specific column numbers to import
for each <code>sheet</code>.
</p>

<ul>
<li><p> To specify different <code>cols</code> for each <code>sheet</code>, supply <code>cols</code>
as a <code>list</code> of <code>integer</code> vectors.
</p>
</li>
<li><p> Note that when <code>cols</code> is defined for a sheet, it will be used
and <code>startCol</code> will be ignored for that same sheet.
</p>
</li></ul>
</td></tr>
<tr><td><code id="readOpenxlsx_+3A_check.names">check.names</code></td>
<td>
<p><code>logical</code> indicating whether to call <code>make.names()</code>
on the <code>colnames</code> of each <code>data.frame</code>.
</p>

<ul>
<li><p> Note that <code>openxlsx::read.xlsx()</code> does not honor <code>check.names=FALSE</code>,
so a workaround is applied which loads a single line
without column headers, in order to obtain the same data without
mangling column headers. If this process fails, another workaround
is to use <code>startRow=2</code> (one higher than previous) and <code>colNames=FALSE</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="readOpenxlsx_+3A_check_header">check_header</code></td>
<td>
<p><code>logical</code> indicating whether to test for presence
of header rows, which may be multi-line column headers.
When <code>check_header=TRUE</code>, this
method simply tests for the presence of rows that have <code>ncol</code>
different than the remaining rows of data in the given sheet.
When header rows are detected, the values are assigned to column
<code>dimnames</code> of the <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="readOpenxlsx_+3A_check_header_n">check_header_n</code></td>
<td>
<p><code>integer</code> number of rows to test for header rows,
only used when <code>check_header=TRUE</code>. This step is intended when
the top row(s) contain fewer columns with headers, above actual
column headers, for example the first row <code>c("Sample", "", "", "Lane", "")</code>,
and the second row <code>c("Name", "Type", "Label", "Name", "Type")</code>.
In this case the desired output is
<code style="white-space: pre;">&#8288;"Sample_Name","Sample_Type","Sample_Label","Lane_Name","Lane_Type")&#8288;</code>.
This option default is <code>FALSE</code> due to the number of exceptions
seen in real data.</p>
</td></tr>
<tr><td><code id="readOpenxlsx_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating whether to print verbose output.</p>
</td></tr>
<tr><td><code id="readOpenxlsx_+3A_...">...</code></td>
<td>
<p>additional arguments are passed to <code>openxlsx::read.xlsx()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is equivalent to <code>openxlsx::read.xlsx()</code>
with a few minor additions:
</p>

<ol>
<li><p> It returns a <code>list</code> of <code>data.frame</code> objects, one per <code>sheet</code>.
</p>
</li>
<li><p> It properly reads the <code>colnames</code> with <code>check.names=FALSE</code>.
</p>
</li></ol>

<p>By default this function returns every <code>sheet</code> for a given
<code>xlsx</code> file.
</p>
<p>Some useful details:
</p>

<ul>
<li><p> Empty columns are not skipped during loading, which means a worksheet
whose data starts at column 3 will be returned with two empty columns,
followed by data from that worksheet. Similarly, any empty columns
in the middle of the data in that worksheet will be included in the
output.
</p>
</li>
<li><p> When both <code>startRow</code> and <code>rows</code> are applied, <code>rows</code> takes priority
and will be used instead of <code>startRows</code>. In fact <code>startRows</code> will be
defined <code>startRows &lt;- min(rows)</code> for each relevant worksheet. However,
for each worksheet either argument can be <code>NULL</code>.
</p>
</li></ul>



<h3>Value</h3>

<p><code>list</code> of <code>data.frame</code> objects, one per sheet in <code>xlsx</code>.
</p>


<h3>See Also</h3>

<p>Other jam export functions: 
<code><a href="#topic+applyXlsxCategoricalFormat">applyXlsxCategoricalFormat</a>()</code>,
<code><a href="#topic+applyXlsxConditionalFormat">applyXlsxConditionalFormat</a>()</code>,
<code><a href="#topic+set_xlsx_colwidths">set_xlsx_colwidths</a>()</code>,
<code><a href="#topic+set_xlsx_rowheights">set_xlsx_rowheights</a>()</code>,
<code><a href="#topic+writeOpenxlsx">writeOpenxlsx</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up a test data.frame
set.seed(123);
lfc &lt;- -3:3 + stats::rnorm(7)/3;
colorSub &lt;- nameVector(
   rainbow2(7),
   LETTERS[1:7])
df &lt;- data.frame(name=LETTERS[1:7],
   int=round(4^(1:7)),
   num=(1:7)*4-2 + stats::rnorm(7),
   fold=2^abs(lfc)*sign(lfc),
   lfc=lfc,
   pvalue=10^(-1:-7 + stats::rnorm(7)),
   hit=sample(c(-1,0,0,1,1), replace=TRUE, size=7));
df;
# write to tempfile for examples
if (check_pkg_installed("openxlsx")) {
   out_xlsx &lt;- tempfile(pattern="writeOpenxlsx_", fileext=".xlsx")
   writeOpenxlsx(x=df,
      file=out_xlsx,
      sheetName="jamba_test",
      append=FALSE);
   # now read it back
   df_list &lt;- readOpenxlsx(xlsx=out_xlsx);
   df_list[[1]]
}

</code></pre>

<hr>
<h2 id='relist_named'>relist a vector which allows re-ordered names</h2><span id='topic+relist_named'></span>

<h3>Description</h3>

<p>relist a vector which imposes the model object list structure while
allowing vector elements and names to be re-ordered
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relist_named(x, skeleton, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relist_named_+3A_x">x</code></td>
<td>
<p>vector to be applied to the <code>skeleton</code> list
structure in order.</p>
</td></tr>
<tr><td><code id="relist_named_+3A_skeleton">skeleton</code></td>
<td>
<p><code>list</code> object representing the desired
final list structure, or <code>vector</code> when the input
data <code>x</code> should be returned as-is, without change.
Specifically, when <code>skeleton</code> is a <code>vector</code>, the
<code>names(x)</code> are maintained without change.</p>
</td></tr>
<tr><td><code id="relist_named_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a simple update to <code>utils::relist()</code>
that allows the order of vectors to change, alongside the
correct names for each element.
</p>
<p>More specifically, this function does not replace the
updated names with the corresponding names from
the list <code>skeleton</code>, as is the case in default implementation of
<code>utils::relist()</code>.
</p>
<p>This function is called by <code>mixedSorts()</code> which iteratively calls
<code>mixedOrder()</code> on each vector component of the input <code>list</code>,
and permits nested lists. The result is a single sorted vector
which is split into the <code>list</code> components, then relist-ed to
the original structure. During the process, it is important
to retain vector names in the order defined by <code>mixedOrder()</code>.
</p>


<h3>Value</h3>

<p><code>list</code> object with the same structure as the <code>skeleton</code>.
</p>


<h3>See Also</h3>

<p>Other jam list functions: 
<code><a href="#topic+cPaste">cPaste</a>()</code>,
<code><a href="#topic+heads">heads</a>()</code>,
<code><a href="#topic+jam_rapply">jam_rapply</a>()</code>,
<code><a href="#topic+list2df">list2df</a>()</code>,
<code><a href="#topic+mergeAllXY">mergeAllXY</a>()</code>,
<code><a href="#topic+mixedSorts">mixedSorts</a>()</code>,
<code><a href="#topic+rbindList">rbindList</a>()</code>,
<code><a href="#topic+rlengths">rlengths</a>()</code>,
<code><a href="#topic+sclass">sclass</a>()</code>,
<code><a href="#topic+sdim">sdim</a>()</code>,
<code><a href="#topic+uniques">uniques</a>()</code>,
<code><a href="#topic+unnestList">unnestList</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate nested list
x &lt;- list(A=nameVector(LETTERS[3:1]),
   B=list(
      E=nameVector(LETTERS[10:7]),
      D=nameVector(LETTERS[5:4])),
   C=list(
      G=nameVector(LETTERS[19:16]),
      F=nameVector(LETTERS[15:11]),
      H=list(
         I=nameVector(LETTERS[22:20]))
      ))
x

# unlisted vector of items
xu &lt;- unlist(unname(x))
# unlisted vector of names
xun &lt;- unname(jam_rapply(x, names));
names(xu) &lt;- xun;

# recursive list element lengths
xrn &lt;- jam_rapply(x, length);
# define factor in order of list structure
xn &lt;- factor(
   rep(names(xrn),
      xrn),
   levels=names(xrn));

# re-create the original list
xu_new &lt;- unlist(unname(split(xu, xn)))
xnew &lt;- relist_named(xu_new, x);
xnew

# re-order elements
k &lt;- mixedOrder(xu_new);
xuk &lt;- unlist(unname(split(xu[k], xn[k])))
xk &lt;- relist_named(xuk, x);
xk

# the default relist() function does not support this use case
xdefault &lt;- relist(xuk, x);
xdefault

</code></pre>

<hr>
<h2 id='reload_rmarkdown_cache'>Reload 'Rmarkdown' cache</h2><span id='topic+reload_rmarkdown_cache'></span>

<h3>Description</h3>

<p>Reload 'Rmarkdown' cache in the order files were created, into an
R environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reload_rmarkdown_cache(
  dir = ".",
  maxnum = 1000,
  max_cache_name = NULL,
  envir = new.env(),
  file_sort = c("globals", "objects", "ctime", "mtime"),
  preferred_load_types = c("lazyLoad", "load"),
  dryrun = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reload_rmarkdown_cache_+3A_dir">dir</code></td>
<td>
<p><code>character</code> path to the directory that contains 'Rmarkdown'
cache files. Each file is recognized by the file extension <code>".rdx"</code>.</p>
</td></tr>
<tr><td><code id="reload_rmarkdown_cache_+3A_maxnum">maxnum</code></td>
<td>
<p><code>integer</code> indicating the maximum number of cache files
to re-load, in order.</p>
</td></tr>
<tr><td><code id="reload_rmarkdown_cache_+3A_max_cache_name">max_cache_name</code></td>
<td>
<p><code>character</code> optional string indicating the
name of an 'Rmarkdown' cache chunk where this function will stop
loading cache data. All cache files after this point will
not be loaded. This option is intended to help recreate the
data available to a particular 'Rmarkdown' chunk during
processing.</p>
</td></tr>
<tr><td><code id="reload_rmarkdown_cache_+3A_envir">envir</code></td>
<td>
<p><code>environment</code> in which data is populated, default <code>new.env()</code>
creates a new <code>environment</code> which is returned invisibly.</p>
</td></tr>
<tr><td><code id="reload_rmarkdown_cache_+3A_file_sort">file_sort</code></td>
<td>
<p><code>character</code> string indicating how to sort cache files,
default uses best available, in order: &quot;globals&quot; (global index file),
&quot;objects&quot; (object index file), &quot;ctime&quot; (creation time),
&quot;mtime&quot; (modification time). The global index is preferred, and
other options are intended for rare scenarios when the global
index is not available. The methods using <code>"mtime"</code> or <code>"ctime"</code>
<strong>is less accurate</strong>, yet may be sufficient for simple output.
</p>

<ul>
<li> <p><code>"globals"</code> uses the <code>"__globals"</code> file in the cache directory.
</p>
</li>
<li> <p><code>"objects"</code> uses the <code>"__objects"</code> file in the cache directory.
</p>
</li>
<li> <p><code>ctime</code> sorts by file creation time
</p>
</li>
<li> <p><code>mtime</code> sorts by file modification time
</p>
</li></ul>
</td></tr>
<tr><td><code id="reload_rmarkdown_cache_+3A_preferred_load_types">preferred_load_types</code></td>
<td>
<p><code>character</code> string indicating the preferred
load mechanism, default uses <code>"lazyLoad"</code> if '.rdx'/'.rdb' files
are available, otherwise <code>"load"</code> to load '.RData'/'.rda' files.
The 'lazyLoad' '.rdx'/.'rdb' files are created when 'Rmarkdown'
options include <code style="white-space: pre;">&#8288;cache=TRUE, cache.lazy=TRUE&#8288;</code>. The load option
is used when <code style="white-space: pre;">&#8288;cache=TRUE, cache.lazy=FALSE&#8288;</code> which is preferred
for some analyses involving large data objects.</p>
</td></tr>
<tr><td><code id="reload_rmarkdown_cache_+3A_dryrun">dryrun</code></td>
<td>
<p><code>logical</code> default FALSE, whether to perform a dry-run,
which prints messages and does not load the data.</p>
</td></tr>
<tr><td><code id="reload_rmarkdown_cache_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> default TRUE, whether to print verbose output.
This argument is not passed to other functions.</p>
</td></tr>
<tr><td><code id="reload_rmarkdown_cache_+3A_...">...</code></td>
<td>
<p>additional arguments are passed to <code>lazyLoad()</code> or <code>load()</code>
as relevant to the method used to re-load the cache object data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to help re-load 'Rmarkdown' cache files
created during the processing/rendering of an 'Rmarkdown' file.
</p>
<p>By default, all cached R objects are loaded into the
environment defined by <code>envir</code>, However,
<strong>it is recommended that <code>envir</code> is used to define a new environment</strong>
into which the cached session is loaded.
</p>
<div class="sourceCode"><pre>cache_env &lt;- new.env()
reload_rmarkdown_cache(cachedir, envir=cache_env)
</pre></div>
<p>From then on, the cached data objects can be seen with <code>ls(cache_env)</code>
and retrieved with <code>get("objectname", envir=cache_env)</code>.
</p>
<p>If supplied with <code>maxnum</code> or <code>max_cache_name</code> then the cache
will be loaded only up to this point, and not beyond.
The recommended method to determine the cache is to use <code>dryrun=TRUE</code>
to view all sections, then to choose the <code>integer</code> number, or
<code>character</code> name to define the maximum chunk to load.
</p>


<h3>Value</h3>

<p><code>envir</code> is returned invisibly, with data objects populated
into that <code>environment</code>.
</p>


<h3>See Also</h3>

<p>Other jam practical functions: 
<code><a href="#topic+breakDensity">breakDensity</a>()</code>,
<code><a href="#topic+call_fn_ellipsis">call_fn_ellipsis</a>()</code>,
<code><a href="#topic+checkLightMode">checkLightMode</a>()</code>,
<code><a href="#topic+check_pkg_installed">check_pkg_installed</a>()</code>,
<code><a href="#topic+colNum2excelName">colNum2excelName</a>()</code>,
<code><a href="#topic+color_dither">color_dither</a>()</code>,
<code><a href="#topic+exp2signed">exp2signed</a>()</code>,
<code><a href="#topic+getAxisLabel">getAxisLabel</a>()</code>,
<code><a href="#topic+isFALSEV">isFALSEV</a>()</code>,
<code><a href="#topic+isTRUEV">isTRUEV</a>()</code>,
<code><a href="#topic+jargs">jargs</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+lldf">lldf</a>()</code>,
<code><a href="#topic+log2signed">log2signed</a>()</code>,
<code><a href="#topic+middle">middle</a>()</code>,
<code><a href="#topic+minorLogTicks">minorLogTicks</a>()</code>,
<code><a href="#topic+newestFile">newestFile</a>()</code>,
<code><a href="#topic+printDebug">printDebug</a>()</code>,
<code><a href="#topic+renameColumn">renameColumn</a>()</code>,
<code><a href="#topic+rmInfinite">rmInfinite</a>()</code>,
<code><a href="#topic+rmNA">rmNA</a>()</code>,
<code><a href="#topic+rmNAs">rmNAs</a>()</code>,
<code><a href="#topic+rmNULL">rmNULL</a>()</code>,
<code><a href="#topic+setPrompt">setPrompt</a>()</code>
</p>

<hr>
<h2 id='renameColumn'>Rename columns in a data.frame, matrix, tibble, or GRanges object</h2><span id='topic+renameColumn'></span>

<h3>Description</h3>

<p>Rename columns in a data.frame, matrix, tibble, or GRanges object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renameColumn(x, from, to, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="renameColumn_+3A_x">x</code></td>
<td>
<p><code>data.frame</code>, <code>matrix</code>, <code>tbl</code>, or <code>GRanges</code> equivalent
object. It will work on any object for which <code>colnames()</code>
is defined.</p>
</td></tr>
<tr><td><code id="renameColumn_+3A_from">from</code></td>
<td>
<p><code>character</code> vector of colnames expected to be in <code>x</code>.
Any values that do not match <code>colnames(x)</code> are ignored.</p>
</td></tr>
<tr><td><code id="renameColumn_+3A_to">to</code></td>
<td>
<p><code>character</code> vector with <code>length(to) == length(from)</code>
corresponding to the target name for any colnames that
match <code>from</code>.</p>
</td></tr>
<tr><td><code id="renameColumn_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating whether to print verbose output.</p>
</td></tr>
<tr><td><code id="renameColumn_+3A_...">...</code></td>
<td>
<p>Additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to rename one or more columns in a
<code>data.frame</code>, <code>matrix</code>, tibble, or <code>GRanges</code> related object.
It will gracefully ignore columns which do not match,
in order to make it possible to call the
function again without problem.
</p>
<p>This function will also recognize input objects <code>GRanges</code>,
<code>ucscData</code>, and <code>IRanges</code>, which store annotation in <code>DataFrame</code>
accessible via <code>S4Vectors::values()</code>. Note the <code>IRanges</code> package
is required, for its generic function <code>values()</code>.
</p>
<p>The values supplied in <code>to</code> and <code>from</code> are converted from <code>factor</code>
to <code>character</code> to avoid coersion by R to <code>integer</code>, which was
noted in output prior to jamba version <code style="white-space: pre;">&#8288;0.0.72.900&#8288;</code>.
</p>


<h3>Value</h3>

<p><code>data.frame</code> or object equivalent to the input <code>x</code>,
with columns <code>from</code> renamed to values in <code>to</code>. For genomic
ranges objects such as <code>GRanges</code> and <code>IRanges</code>, the colnames
are updated in <code>S4Vectors::values(x)</code>.
</p>


<h3>See Also</h3>

<p>Other jam practical functions: 
<code><a href="#topic+breakDensity">breakDensity</a>()</code>,
<code><a href="#topic+call_fn_ellipsis">call_fn_ellipsis</a>()</code>,
<code><a href="#topic+checkLightMode">checkLightMode</a>()</code>,
<code><a href="#topic+check_pkg_installed">check_pkg_installed</a>()</code>,
<code><a href="#topic+colNum2excelName">colNum2excelName</a>()</code>,
<code><a href="#topic+color_dither">color_dither</a>()</code>,
<code><a href="#topic+exp2signed">exp2signed</a>()</code>,
<code><a href="#topic+getAxisLabel">getAxisLabel</a>()</code>,
<code><a href="#topic+isFALSEV">isFALSEV</a>()</code>,
<code><a href="#topic+isTRUEV">isTRUEV</a>()</code>,
<code><a href="#topic+jargs">jargs</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+lldf">lldf</a>()</code>,
<code><a href="#topic+log2signed">log2signed</a>()</code>,
<code><a href="#topic+middle">middle</a>()</code>,
<code><a href="#topic+minorLogTicks">minorLogTicks</a>()</code>,
<code><a href="#topic+newestFile">newestFile</a>()</code>,
<code><a href="#topic+printDebug">printDebug</a>()</code>,
<code><a href="#topic+reload_rmarkdown_cache">reload_rmarkdown_cache</a>()</code>,
<code><a href="#topic+rmInfinite">rmInfinite</a>()</code>,
<code><a href="#topic+rmNA">rmNA</a>()</code>,
<code><a href="#topic+rmNAs">rmNAs</a>()</code>,
<code><a href="#topic+rmNULL">rmNULL</a>()</code>,
<code><a href="#topic+setPrompt">setPrompt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(A=1:5, B=6:10, C=11:15);
df;
df2 &lt;- renameColumn(df,
   from=c("A","C"),
   to=c("a_new", "c_new"));
df2;
df3 &lt;- renameColumn(df2,
   from=c("A","C","B"),
   to=c("a_new", "c_new","b_new"));
df3;

</code></pre>

<hr>
<h2 id='rgb2col'>Convert RGB color matrix to R color</h2><span id='topic+rgb2col'></span>

<h3>Description</h3>

<p>Convert RGB color matrix to R color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgb2col(
  red,
  green = NULL,
  blue = NULL,
  alpha = NULL,
  names = NULL,
  maxColorValue = NULL,
  keepNA = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgb2col_+3A_red">red</code></td>
<td>
<p><code>numeric</code> vector of red values; or RGB numeric matrix with
rownames c(&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;) in any order, with optional rowname
&quot;alpha&quot;; or character strings with comma-separated rgb values, in
format &quot;100,20,10&quot;. The latter input is designed to handle web rgb
values.</p>
</td></tr>
<tr><td><code id="rgb2col_+3A_green">green</code></td>
<td>
<p><code>numeric</code> vector, or when red is a matrix or comma-delimited
character string, this parameter is ignored.</p>
</td></tr>
<tr><td><code id="rgb2col_+3A_blue">blue</code></td>
<td>
<p><code>numeric</code> vector, or when red is a matrix or comma-delimited
character string, this parameter is ignored.</p>
</td></tr>
<tr><td><code id="rgb2col_+3A_alpha">alpha</code></td>
<td>
<p><code>numeric</code> vector, or when red is a matrix or comma-delimited
character string, this parameter is ignored. Alpha values are always
expected in range <code style="white-space: pre;">&#8288;[0,1]&#8288;</code>, even when <code>maxColorValue</code> is higher
than <code>1</code>. When <code>alpha</code> is <code>FALSE</code>, the alpha transparency is removed.
When <code>alpha</code> is <code>TRUE</code> the original alpha transparency is retained
without change. If supplying <code>alpha</code> as a numeric vector, use <code>Inf</code>
to represent <code>TRUE</code> for alpha values to be kept without change, and
use <code>-1</code> or any negative number to indicate alpha values to remove
from the output.</p>
</td></tr>
<tr><td><code id="rgb2col_+3A_names">names</code></td>
<td>
<p><code>character</code>, default NULL, with optional names to apply
to output colors.</p>
</td></tr>
<tr><td><code id="rgb2col_+3A_maxcolorvalue">maxColorValue</code></td>
<td>
<p><code>numeric</code> maximum value for colors. If NULL then it
defaults to 1 unless there are values above 1, in which case it defaults
to 255.</p>
</td></tr>
<tr><td><code id="rgb2col_+3A_keepna">keepNA</code></td>
<td>
<p><code>logical</code> whether to keep NA values, returning NA for any
input where red, green, and/or blue are NA. If keepNA==FALSE then it
substitutes 0 for any NA values.</p>
</td></tr>
<tr><td><code id="rgb2col_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating whether to print verbose output</p>
</td></tr>
<tr><td><code id="rgb2col_+3A_...">...</code></td>
<td>
<p>Additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function intends to augment the <code><a href="grDevices.html#topic+rgb">rgb</a></code> function, which
does not handle output from <code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code>. The goal is to handle
multiple color conversions, e.g. <code>rgb2col(grDevices::col2rgb("red"))</code>. This
function also maintains alpha transparency when supplied.
</p>
<p>The output is named either by names(red), rownames(red), or if supplied,
the value of the parameter <code>names</code>.
</p>
<p>Note that <code>alpha</code> is used to define alpha transparency, but has
additional control over the output.
</p>

<ul>
<li><p> When <code>alpha</code> is <code>FALSE</code> then
output colors will not have the alpha transparency, in hex form that
means colors are in format <code>"#RRGGBB"</code> and not <code>"#RRGGBBAA"</code>.
</p>
</li>
<li><p> When <code>alpha</code> is <code>TRUE</code> the previous alpha transparency values are
used without change.
</p>
</li>
<li><p> When <code>alpha</code> is a numeric vector, numeric values are always
expected to be in range <code style="white-space: pre;">&#8288;[0,1]&#8288;</code>, where <code>0</code> is completely transparent,
and <code>1</code> is completely not transparent. Supplied <code>alpha</code> values will
override those present in <code>red</code> when <code>red</code> is a matrix like that
produced from <code>grDevices::col2rgb(..., alpha=TRUE)</code>.
</p>
</li>
<li><p> When <code>alpha</code> is a numeric vector, use <code>-1</code> or any negative number
to indicate the alpha value should be removed.
</p>
</li>
<li><p> When <code>alpha</code> is a numeric vector, use <code>Inf</code> to indicate the alpha
transparency should be retained without change.
</p>
</li></ul>

<p>Therefore, <code>alpha = c(-1, 0, 1, Inf)</code> will apply the following,
in order: remove alpha; set alpha to 0; set alpha to 1; set alpha
to the same as the input color.
</p>


<h3>Value</h3>

<p><code>character</code> vector of R colors.
</p>


<h3>See Also</h3>

<p>Other jam color functions: 
<code><a href="#topic+alpha2col">alpha2col</a>()</code>,
<code><a href="#topic+applyCLrange">applyCLrange</a>()</code>,
<code><a href="#topic+col2alpha">col2alpha</a>()</code>,
<code><a href="#topic+col2hcl">col2hcl</a>()</code>,
<code><a href="#topic+col2hsl">col2hsl</a>()</code>,
<code><a href="#topic+col2hsv">col2hsv</a>()</code>,
<code><a href="#topic+color2gradient">color2gradient</a>()</code>,
<code><a href="#topic+fixYellow">fixYellow</a>()</code>,
<code><a href="#topic+fixYellowHue">fixYellowHue</a>()</code>,
<code><a href="#topic+getColorRamp">getColorRamp</a>()</code>,
<code><a href="#topic+hcl2col">hcl2col</a>()</code>,
<code><a href="#topic+hsl2col">hsl2col</a>()</code>,
<code><a href="#topic+hsv2col">hsv2col</a>()</code>,
<code><a href="#topic+isColor">isColor</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+makeColorDarker">makeColorDarker</a>()</code>,
<code><a href="#topic+rainbow2">rainbow2</a>()</code>,
<code><a href="#topic+setCLranges">setCLranges</a>()</code>,
<code><a href="#topic+setTextContrastColor">setTextContrastColor</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+unalpha">unalpha</a>()</code>,
<code><a href="#topic+warpRamp">warpRamp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># start with a color vector
# red and blue with partial transparency
colorV &lt;- c("#FF000055", "#00339999");

# Show the output of rgb2col
# make sure to include alpha=TRUE to maintain alpha transparency
grDevices::col2rgb(colorV, alpha=TRUE);

# confirm we can convert from RGB back to the same colors
rgb2col(grDevices::col2rgb(colorV, alpha=TRUE));

</code></pre>

<hr>
<h2 id='rlengths'>lengths for recursive lists</h2><span id='topic+rlengths'></span>

<h3>Description</h3>

<p>lengths for recursive lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlengths(x, doSum = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rlengths_+3A_x">x</code></td>
<td>
<p><code>list</code> or vector</p>
</td></tr>
<tr><td><code id="rlengths_+3A_dosum">doSum</code></td>
<td>
<p><code>logical</code> indicating whether to return the overall sum
of lengths. When <code>NULL</code> it will return the aggregate length of
each list element in <code>x</code>. When <code>FALSE</code> it will return the same
list structure of x, with the length of each. When <code>TRUE</code> it will
return the total length of all elements in <code>x</code> as one value.</p>
</td></tr>
<tr><td><code id="rlengths_+3A_...">...</code></td>
<td>
<p>additional parameters are ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a list as input, and returns the length
of each list element after running <code>base::unlist()</code>.
</p>


<h3>Value</h3>

<p><code>integer</code> value, vector, or list:
</p>

<ul>
<li><p> When <code style="white-space: pre;">&#8288;doSum is NULL&#8288;</code> (default) it returns an <code>integer</code> vector
with length <code>length(x)</code> and names <code>names(x)</code>,
whose values are the total number of elements in each item in
<code>x</code> after running <code>base::unlist()</code>.
</p>
</li>
<li><p> When <code>doSum=="TRUE"</code>, it returns the single <code>integer</code> length of
all elements in <code>x</code>.
</p>
</li>
<li><p> When <code>doSum=="FALSE"</code>, it returns the full structure of <code>x</code> with the
<code>integer</code> length of each element.
</p>
</li></ul>

<p>The parameter <code>doSum</code> is intended for internal use, during
recursive calls of <code>rlengths()</code> to itself. When <code style="white-space: pre;">&#8288;doSum is NULL&#8288;</code> or
<code>TRUE</code>, recursive calls to <code>rlengths()</code> set <code>doSum=TRUE</code>.
</p>


<h3>See Also</h3>

<p>Other jam list functions: 
<code><a href="#topic+cPaste">cPaste</a>()</code>,
<code><a href="#topic+heads">heads</a>()</code>,
<code><a href="#topic+jam_rapply">jam_rapply</a>()</code>,
<code><a href="#topic+list2df">list2df</a>()</code>,
<code><a href="#topic+mergeAllXY">mergeAllXY</a>()</code>,
<code><a href="#topic+mixedSorts">mixedSorts</a>()</code>,
<code><a href="#topic+rbindList">rbindList</a>()</code>,
<code><a href="#topic+relist_named">relist_named</a>()</code>,
<code><a href="#topic+sclass">sclass</a>()</code>,
<code><a href="#topic+sdim">sdim</a>()</code>,
<code><a href="#topic+uniques">uniques</a>()</code>,
<code><a href="#topic+unnestList">unnestList</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(
   A=list(
      A1=nameVector(1:3, letters[1:3]),
      A2=list(
         A1a=nameVector(4:7, letters[4:7]),
         A1b=nameVector(11:14, letters[11:14]))),
   B=list(B1=nameVector(1:9, letters[1:9]),
      B2=nameVector(20:25, letters[20:25])));
# default lengths(x) shows length=2 for A and B
lengths(x)
# rlengths(x) shows the total length of A and B
rlengths(x)

</code></pre>

<hr>
<h2 id='rmInfinite'>remove Infinite values</h2><span id='topic+rmInfinite'></span>

<h3>Description</h3>

<p>remove Infinite values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmInfinite(x, infiniteValue = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmInfinite_+3A_x">x</code></td>
<td>
<p>vector input</p>
</td></tr>
<tr><td><code id="rmInfinite_+3A_infinitevalue">infiniteValue</code></td>
<td>
<p>NULL to remove Infinite values, or a replacement value</p>
</td></tr>
<tr><td><code id="rmInfinite_+3A_...">...</code></td>
<td>
<p>additional parameters are ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function removes any positive or negative infinite numerical
values, optionally replacing them with a given value or NA.
</p>


<h3>Value</h3>

<p>numeric vector with infinite values either removed, or
replaced with the supplied value.
</p>


<h3>See Also</h3>

<p>Other jam practical functions: 
<code><a href="#topic+breakDensity">breakDensity</a>()</code>,
<code><a href="#topic+call_fn_ellipsis">call_fn_ellipsis</a>()</code>,
<code><a href="#topic+checkLightMode">checkLightMode</a>()</code>,
<code><a href="#topic+check_pkg_installed">check_pkg_installed</a>()</code>,
<code><a href="#topic+colNum2excelName">colNum2excelName</a>()</code>,
<code><a href="#topic+color_dither">color_dither</a>()</code>,
<code><a href="#topic+exp2signed">exp2signed</a>()</code>,
<code><a href="#topic+getAxisLabel">getAxisLabel</a>()</code>,
<code><a href="#topic+isFALSEV">isFALSEV</a>()</code>,
<code><a href="#topic+isTRUEV">isTRUEV</a>()</code>,
<code><a href="#topic+jargs">jargs</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+lldf">lldf</a>()</code>,
<code><a href="#topic+log2signed">log2signed</a>()</code>,
<code><a href="#topic+middle">middle</a>()</code>,
<code><a href="#topic+minorLogTicks">minorLogTicks</a>()</code>,
<code><a href="#topic+newestFile">newestFile</a>()</code>,
<code><a href="#topic+printDebug">printDebug</a>()</code>,
<code><a href="#topic+reload_rmarkdown_cache">reload_rmarkdown_cache</a>()</code>,
<code><a href="#topic+renameColumn">renameColumn</a>()</code>,
<code><a href="#topic+rmNA">rmNA</a>()</code>,
<code><a href="#topic+rmNAs">rmNAs</a>()</code>,
<code><a href="#topic+rmNULL">rmNULL</a>()</code>,
<code><a href="#topic+setPrompt">setPrompt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rmInfinite(c(1, 5, 4, 10, Inf, 1, -Inf))

rmInfinite(c(1, 5, 4, 10, Inf, 1, -Inf), infiniteValue=1000)

</code></pre>

<hr>
<h2 id='rmNA'>remove NA values</h2><span id='topic+rmNA'></span>

<h3>Description</h3>

<p>remove NA values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmNA(
  x,
  naValue = NULL,
  rmNULL = FALSE,
  nullValue = naValue,
  rmInfinite = TRUE,
  infiniteValue = NULL,
  rmNAnames = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmNA_+3A_x">x</code></td>
<td>
<p>vector input</p>
</td></tr>
<tr><td><code id="rmNA_+3A_navalue">naValue</code></td>
<td>
<p>NULL or single replacement value for NA entries. If NULL,
then NA entries are removed from the result.</p>
</td></tr>
<tr><td><code id="rmNA_+3A_rmnull">rmNULL</code></td>
<td>
<p><code>logical</code> whether to replace NULL entries with <code>nullValue</code></p>
</td></tr>
<tr><td><code id="rmNA_+3A_nullvalue">nullValue</code></td>
<td>
<p>NULL or single replacement value for NULL entries. If NULL,
then NULL entries are removed from the result.</p>
</td></tr>
<tr><td><code id="rmNA_+3A_rminfinite">rmInfinite</code></td>
<td>
<p><code>logical</code> whether to replace Infinite values with
infiniteValue</p>
</td></tr>
<tr><td><code id="rmNA_+3A_infinitevalue">infiniteValue</code></td>
<td>
<p>value to use when rmInfinite==TRUE to replace
entries which are Inf or -Inf.</p>
</td></tr>
<tr><td><code id="rmNA_+3A_rmnanames">rmNAnames</code></td>
<td>
<p><code>logical</code> whether to remove entries which have NA as the
name, regardless whether the entry itself is NA.</p>
</td></tr>
<tr><td><code id="rmNA_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> whether to print verbose output</p>
</td></tr>
<tr><td><code id="rmNA_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function removes NA values, by default shortening a vector as a result,
but optionally replacing NA and Infinite values with fixed values.
</p>


<h3>Value</h3>

<p>vector with NA entries either removed, or replaced with naValue,
and NULL entries either removed or replaced by nullValue.
</p>


<h3>See Also</h3>

<p>Other jam practical functions: 
<code><a href="#topic+breakDensity">breakDensity</a>()</code>,
<code><a href="#topic+call_fn_ellipsis">call_fn_ellipsis</a>()</code>,
<code><a href="#topic+checkLightMode">checkLightMode</a>()</code>,
<code><a href="#topic+check_pkg_installed">check_pkg_installed</a>()</code>,
<code><a href="#topic+colNum2excelName">colNum2excelName</a>()</code>,
<code><a href="#topic+color_dither">color_dither</a>()</code>,
<code><a href="#topic+exp2signed">exp2signed</a>()</code>,
<code><a href="#topic+getAxisLabel">getAxisLabel</a>()</code>,
<code><a href="#topic+isFALSEV">isFALSEV</a>()</code>,
<code><a href="#topic+isTRUEV">isTRUEV</a>()</code>,
<code><a href="#topic+jargs">jargs</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+lldf">lldf</a>()</code>,
<code><a href="#topic+log2signed">log2signed</a>()</code>,
<code><a href="#topic+middle">middle</a>()</code>,
<code><a href="#topic+minorLogTicks">minorLogTicks</a>()</code>,
<code><a href="#topic+newestFile">newestFile</a>()</code>,
<code><a href="#topic+printDebug">printDebug</a>()</code>,
<code><a href="#topic+reload_rmarkdown_cache">reload_rmarkdown_cache</a>()</code>,
<code><a href="#topic+renameColumn">renameColumn</a>()</code>,
<code><a href="#topic+rmInfinite">rmInfinite</a>()</code>,
<code><a href="#topic+rmNAs">rmNAs</a>()</code>,
<code><a href="#topic+rmNULL">rmNULL</a>()</code>,
<code><a href="#topic+setPrompt">setPrompt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># by default it removes NA, shortening the vector
rmNA(c(1, 5, 4, NA, 10, NA))

# convenient to replace NA with a fixed value
rmNA(c(1, 5, 4, NA, 10, NA), naValue=0)

m &lt;- matrix(ncol=3, 1:9)
m[1, 2] &lt;- NA;
rmNA(m, naValue=-1)

# by default NA and Inf is removed
rmNA(c(1, 5, 4, NA, 10, NA, Inf, -Inf))

# NA and Inf can be replaced, note Inf retains the sign
rmNA(c(1, 5, 4, NA, 10, NA, Inf, -Inf), naValue=0, infiniteValue=100)

</code></pre>

<hr>
<h2 id='rmNAs'>remove NA values from list elements</h2><span id='topic+rmNAs'></span>

<h3>Description</h3>

<p>remove NA values from list elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmNAs(
  x,
  naValue = NULL,
  rmNULL = FALSE,
  nullValue = naValue,
  rmInfinite = TRUE,
  infiniteValue = NULL,
  rmNAnames = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmNAs_+3A_x">x</code></td>
<td>
<p><code>list</code> of vectors</p>
</td></tr>
<tr><td><code id="rmNAs_+3A_navalue">naValue</code></td>
<td>
<p>NULL or single replacement value for NA entries. If NULL,
then NA entries are removed from the result.</p>
</td></tr>
<tr><td><code id="rmNAs_+3A_rmnull">rmNULL</code></td>
<td>
<p><code>logical</code> whether to replace NULL entries with <code>nullValue</code></p>
</td></tr>
<tr><td><code id="rmNAs_+3A_nullvalue">nullValue</code></td>
<td>
<p>NULL or single replacement value for NULL entries. If NULL,
then NULL entries are removed from the result.</p>
</td></tr>
<tr><td><code id="rmNAs_+3A_rminfinite">rmInfinite</code></td>
<td>
<p><code>logical</code> whether to replace Infinite values with
infiniteValue</p>
</td></tr>
<tr><td><code id="rmNAs_+3A_infinitevalue">infiniteValue</code></td>
<td>
<p>value to use when rmInfinite==TRUE to replace
entries which are Inf or -Inf.</p>
</td></tr>
<tr><td><code id="rmNAs_+3A_rmnanames">rmNAnames</code></td>
<td>
<p><code>logical</code> whether to remove entries which have NA as the
name, regardless whether the entry itself is NA.</p>
</td></tr>
<tr><td><code id="rmNAs_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> whether to print verbose output</p>
</td></tr>
<tr><td><code id="rmNAs_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function removes <code>NA</code> values from vectors in a <code>list</code>,
applying the same logic used in <code>rmNA()</code> to each vector.
It is somewhat optimized, in that it checks for list elements
that have <code>NA</code> values before applying <code>rmNA()</code>.
However, it calls <code>rmNA()</code> iteratively on each vector that
contains <code>NA</code> in order to preserve the class
(factor, character, numeric, etc.) of each vector.
</p>
<p>It also optionally applies convenience functions <code>rmNULL()</code>
and <code>rmInfinite()</code> as relevant.
</p>


<h3>Value</h3>

<p><code>list</code> where NA entries were removed or replaced with <code>naValue</code>
in each vector. Empty <code>list</code> elements are optionally removed when
<code>rmNULL=TRUE</code>, or replaced with <code>nullValue</code> when defined. When
<code>rmInfinite=TRUE</code> then infinite values are either removed, or
replaced with <code>infiniteValue</code> when defined.
</p>


<h3>See Also</h3>

<p>Other jam practical functions: 
<code><a href="#topic+breakDensity">breakDensity</a>()</code>,
<code><a href="#topic+call_fn_ellipsis">call_fn_ellipsis</a>()</code>,
<code><a href="#topic+checkLightMode">checkLightMode</a>()</code>,
<code><a href="#topic+check_pkg_installed">check_pkg_installed</a>()</code>,
<code><a href="#topic+colNum2excelName">colNum2excelName</a>()</code>,
<code><a href="#topic+color_dither">color_dither</a>()</code>,
<code><a href="#topic+exp2signed">exp2signed</a>()</code>,
<code><a href="#topic+getAxisLabel">getAxisLabel</a>()</code>,
<code><a href="#topic+isFALSEV">isFALSEV</a>()</code>,
<code><a href="#topic+isTRUEV">isTRUEV</a>()</code>,
<code><a href="#topic+jargs">jargs</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+lldf">lldf</a>()</code>,
<code><a href="#topic+log2signed">log2signed</a>()</code>,
<code><a href="#topic+middle">middle</a>()</code>,
<code><a href="#topic+minorLogTicks">minorLogTicks</a>()</code>,
<code><a href="#topic+newestFile">newestFile</a>()</code>,
<code><a href="#topic+printDebug">printDebug</a>()</code>,
<code><a href="#topic+reload_rmarkdown_cache">reload_rmarkdown_cache</a>()</code>,
<code><a href="#topic+renameColumn">renameColumn</a>()</code>,
<code><a href="#topic+rmInfinite">rmInfinite</a>()</code>,
<code><a href="#topic+rmNA">rmNA</a>()</code>,
<code><a href="#topic+rmNULL">rmNULL</a>()</code>,
<code><a href="#topic+setPrompt">setPrompt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testlist &lt;- list(
   A=c(1, 4, 5, NA, 11),
   B=c("B", NA, "C", "Test"))
rmNAs(testlist)

testlist2 &lt;- list(
   A=c(1, 4, 5, NA, 11, Inf),
   B=c(11, NA, 19, -Inf))
rmNAs(testlist2, naValue=-100, infiniteValue=1000)

</code></pre>

<hr>
<h2 id='rmNULL'>remove NULL entries from list</h2><span id='topic+rmNULL'></span>

<h3>Description</h3>

<p>remove NULL entries from list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmNULL(x, nullValue = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmNULL_+3A_x">x</code></td>
<td>
<p><code>list</code> or other object which may contain NULL.</p>
</td></tr>
<tr><td><code id="rmNULL_+3A_nullvalue">nullValue</code></td>
<td>
<p><code>character</code> optional replacement value, default NULL,
which causes the entry to be removed.</p>
</td></tr>
<tr><td><code id="rmNULL_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a simple helper function to remove NULL from a list,
optionally replacing it with another value
</p>


<h3>Value</h3>

<p>list with NULL entries either removed, or replaced with nullValue.
This function is typically called so it removed list elements which are
NULL, resulting in a list that contains non-NULL entries. This function
can also be useful when NULL values should be changed to something else,
perhaps a character value &quot;NULL&quot; to be used as a label.
</p>


<h3>See Also</h3>

<p>Other jam practical functions: 
<code><a href="#topic+breakDensity">breakDensity</a>()</code>,
<code><a href="#topic+call_fn_ellipsis">call_fn_ellipsis</a>()</code>,
<code><a href="#topic+checkLightMode">checkLightMode</a>()</code>,
<code><a href="#topic+check_pkg_installed">check_pkg_installed</a>()</code>,
<code><a href="#topic+colNum2excelName">colNum2excelName</a>()</code>,
<code><a href="#topic+color_dither">color_dither</a>()</code>,
<code><a href="#topic+exp2signed">exp2signed</a>()</code>,
<code><a href="#topic+getAxisLabel">getAxisLabel</a>()</code>,
<code><a href="#topic+isFALSEV">isFALSEV</a>()</code>,
<code><a href="#topic+isTRUEV">isTRUEV</a>()</code>,
<code><a href="#topic+jargs">jargs</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+lldf">lldf</a>()</code>,
<code><a href="#topic+log2signed">log2signed</a>()</code>,
<code><a href="#topic+middle">middle</a>()</code>,
<code><a href="#topic+minorLogTicks">minorLogTicks</a>()</code>,
<code><a href="#topic+newestFile">newestFile</a>()</code>,
<code><a href="#topic+printDebug">printDebug</a>()</code>,
<code><a href="#topic+reload_rmarkdown_cache">reload_rmarkdown_cache</a>()</code>,
<code><a href="#topic+renameColumn">renameColumn</a>()</code>,
<code><a href="#topic+rmInfinite">rmInfinite</a>()</code>,
<code><a href="#topic+rmNA">rmNA</a>()</code>,
<code><a href="#topic+rmNAs">rmNAs</a>()</code>,
<code><a href="#topic+setPrompt">setPrompt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(A=1:6, B=NULL, C=letters[11:16]);
rmNULL(x)
rmNULL(x, nullValue=NA)

</code></pre>

<hr>
<h2 id='rowGroupMeans'>Calculate row group means, or other statistics</h2><span id='topic+rowGroupMeans'></span><span id='topic+rowGroupRmOutliers'></span>

<h3>Description</h3>

<p>Calculate row group means, or other statistics, where: <code>rowGroupMeans()</code>
calculates row summary stats; and <code>rowGroupRmOutliers()</code> is a convenience
function to call <code>rowGroupMeans(..., rmOutliers=TRUE, returnType="input")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowGroupMeans(
  x,
  groups,
  na.rm = TRUE,
  useMedian = TRUE,
  rmOutliers = FALSE,
  crossGroupMad = TRUE,
  madFactor = 5,
  returnType = c("output", "input"),
  rowStatsFunc = NULL,
  groupOrder = c("same", "sort"),
  keepNULLlevels = FALSE,
  includeAttributes = FALSE,
  verbose = FALSE,
  ...
)

rowGroupRmOutliers(
  x,
  groups,
  na.rm = TRUE,
  rmOutliers = TRUE,
  crossGroupMad = TRUE,
  madFactor = 5,
  returnType = c("input"),
  groupOrder = c("same", "sort"),
  keepNULLlevels = FALSE,
  includeAttributes = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rowGroupMeans_+3A_x">x</code></td>
<td>
<p><code>numeric</code> data matrix</p>
</td></tr>
<tr><td><code id="rowGroupMeans_+3A_groups">groups</code></td>
<td>
<p><code>character</code> or <code>factor</code> vector of group labels,
either as a character vector, or a factor. See the parameter
<code>groupOrder</code> for ordering of group labels in the output
data matrix.</p>
</td></tr>
<tr><td><code id="rowGroupMeans_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>, default TRUE, passed to the stats func
to ignore NA values.</p>
</td></tr>
<tr><td><code id="rowGroupMeans_+3A_usemedian">useMedian</code></td>
<td>
<p><code>logical</code>, default TRUE,  indicating whether the default
stat should be &quot;mean&quot; or &quot;median&quot;.</p>
</td></tr>
<tr><td><code id="rowGroupMeans_+3A_rmoutliers">rmOutliers</code></td>
<td>
<p><code>logical</code>, default FALSE, indicating whether to
apply outlier detection and removal.</p>
</td></tr>
<tr><td><code id="rowGroupMeans_+3A_crossgroupmad">crossGroupMad</code></td>
<td>
<p><code>logical</code> indicating whether to calculate
row MAD values using the median across groups for each row.
The median is calculated using non-NA and non-zero row group
MAD values. When <code>crossGroupMad=TRUE</code> it also calculates
the non-NA, non-zero median row MAD across all rows,
which defines the minimum difference from median applied across
all values to be considered an outlier.</p>
</td></tr>
<tr><td><code id="rowGroupMeans_+3A_madfactor">madFactor</code></td>
<td>
<p><code>numeric</code> value indicating the multiple of the
MAD value to define outliers. For example <code>madFactor=5</code>
will take the MAD value for a group multiplied by 5,
5<em>MAD, as a threshold for outliers. So any points more than
5</em>MAD distance from the median per group are outliers.</p>
</td></tr>
<tr><td><code id="rowGroupMeans_+3A_returntype">returnType</code></td>
<td>
<p><code>character</code>, default &quot;output&quot;, the return data type:
</p>

<ul>
<li> <p><code>"output"</code> returns one summary stat value per group, per row;
</p>
</li>
<li> <p><code>"input"</code> is useful when <code>rmOutliers=TRUE</code> in that it returns
a matrix with the same dimensions as the input, except with
outlier points replaced with NA.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rowGroupMeans_+3A_rowstatsfunc">rowStatsFunc</code></td>
<td>
<p><code>function</code>, default NULL, which takes a numeric matrix
as input, and returns a numeric vector equal to the number of
rows of the input data matrix. When supplied, <code>useMedian</code> is ignored.
Examples: <code>base::rowMeans()</code>,
<code>matrixStats::rowMedians()</code>, <code>matrixStats::rowMads</code>.</p>
</td></tr>
<tr><td><code id="rowGroupMeans_+3A_grouporder">groupOrder</code></td>
<td>
<p><code>character</code> string indicating how character group
labels are ordered in the final data matrix, when <code>returnType="output"</code>.
Note that when <code>groups</code> is a factor, the factor levels are kept
in that order. Otherwise, <code>"same"</code> keeps groups in the same
order they appear in the input matrix; <code>"sort"</code> applies
<code>jamba::mixedSort()</code> to the labels.</p>
</td></tr>
<tr><td><code id="rowGroupMeans_+3A_keepnulllevels">keepNULLlevels</code></td>
<td>
<p><code>logical</code>, default FALSE,  whether to keep factor
levels even when there are no corresponding columns in <code>x</code>.
When <code>TRUE</code> and <code>returnType="output"</code> the output matrix will
contain one colname for each factor level, with NA values used
to fill empty factor levels. This mechanism can be helpful to
ensure that output matrices have consistent colnames.</p>
</td></tr>
<tr><td><code id="rowGroupMeans_+3A_includeattributes">includeAttributes</code></td>
<td>
<p><code>logical</code>, default FALSE, whether to include
attributes with <code>"n"</code> number of replicates per group, and <code>"nLabel"</code>
with replicate label in <code style="white-space: pre;">&#8288;n=#&#8288;</code> form.</p>
</td></tr>
<tr><td><code id="rowGroupMeans_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating whether to print verbose output.</p>
</td></tr>
<tr><td><code id="rowGroupMeans_+3A_...">...</code></td>
<td>
<p>additional parameters are passed to <code>rowStatsFunc</code>,
and if <code>rmOutliers=TRUE</code> to <code>jamba::rowRmMadOutliers()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function by default calculates group mean values
per row in a numeric matrix. However, the stat function
can be changed to calculate row medians, row MADs, etc.
</p>
<p>An added purpose of this function is optional outlier
filtering, via calculation of MAD values and applying
a MAD threshold cutoff. The intention is to identify
technical outliers that otherwise adversely affect the
calculated group mean or median values. To inspect the
data after outlier removal, use the parameter <code>returnType="input"</code>
which will return the input data matrix with <code>NA</code>
substituted for outlier points. Outlier detection and
removal is performed by <code>jamba::rowRmMadOutliers()</code>.
</p>


<h3>Value</h3>

<p><code>numeric</code> matrix based upon <code>returnType</code>:
</p>

<ul>
<li><p> When <code>returnType="output"</code> the output is a numeric matrix
with the same number of columns as the number of unique
<code>groups</code> labels. When <code>groups</code> is a factor and
<code>keepNULLlevels=TRUE</code>, the number of columns will be the
number of factor levels, otherwise it will be the number of
factor levels used in <code>groups</code>.
</p>
</li>
<li><p> When <code>returnType="input"</code> the output is a numeric matrix
with the same dimensions as the input data. This output is
intended for use with <code>rmOutliers=TRUE</code> which will replace
outlier points with <code>NA</code> values. Therefore, this matrix can
be used to see the location of outliers.
</p>
</li></ul>

<p>The function also returns attributes when <code>includeAttributes=TRUE</code>,
although the default is FALSE. The attributes describe the
number of samples per group overall:
</p>

<dl>
<dt>attr(out, &quot;n&quot;)</dt><dd><p>The attribute <code>"n"</code> is used to describe
the number of replicates per group.</p>
</dd>
<dt>attr(out, &quot;nLabel&quot;)</dt><dd><p>The attribute <code>"nLabel"</code> is
a simple text label in the form <code>"n=3"</code>.</p>
</dd>
</dl>

<p>Note that when <code>rmOutliers=TRUE</code> the number of replicates per
group will vary depending upon the outliers removed. In that
case, remember that the reported <code>"n"</code> is always the total
possible columns available prior to outlier removal.
</p>


<h3>See Also</h3>

<p>Other jam numeric functions: 
<code><a href="#topic+deg2rad">deg2rad</a>()</code>,
<code><a href="#topic+noiseFloor">noiseFloor</a>()</code>,
<code><a href="#topic+normScale">normScale</a>()</code>,
<code><a href="#topic+rad2deg">rad2deg</a>()</code>,
<code><a href="#topic+rowRmMadOutliers">rowRmMadOutliers</a>()</code>,
<code><a href="#topic+warpAroundZero">warpAroundZero</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(ncol=9, stats::rnorm(90));
colnames(x) &lt;- LETTERS[1:9];
use_groups &lt;- rep(letters[1:3], each=3)
rowGroupMeans(x, groups=use_groups)

# rowGroupRmOutliers returns the input data after outlier removal
rowGroupRmOutliers(x, groups=use_groups, returnType="input")

# rowGroupMeans(..., returnType="input") also returns the input data
rowGroupMeans(x, groups=use_groups, rmOutliers=TRUE, returnType="input")

# rowGroupMeans with outlier removal
rowGroupMeans(x, groups=use_groups, rmOutliers=TRUE)

</code></pre>

<hr>
<h2 id='rowRmMadOutliers'>Remove outlier points per row by MAD factor threshold</h2><span id='topic+rowRmMadOutliers'></span>

<h3>Description</h3>

<p>Remove outlier points per row by MAD factor threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowRmMadOutliers(
  x,
  madFactor = 5,
  na.rm = TRUE,
  minDiff = 0,
  minReps = 3,
  includeAttributes = FALSE,
  rowMadValues = NULL,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rowRmMadOutliers_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
<tr><td><code id="rowRmMadOutliers_+3A_madfactor">madFactor</code></td>
<td>
<p><code>numeric</code> value to multiply by each row MAD
to define the threshold for outlier detection.</p>
</td></tr>
<tr><td><code id="rowRmMadOutliers_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code> indicating whether to ignore NA values
when calculating the MAD value. It should probably always be
<code>TRUE</code>, however setting to <code>FALSE</code> will prevent any
calculations in rows that contain <code>NA</code> values, which could
be useful.</p>
</td></tr>
<tr><td><code id="rowRmMadOutliers_+3A_mindiff">minDiff</code></td>
<td>
<p><code>numeric</code> value indicating the minimum difference
from median to qualify as an outlier. This value protects
against removing outliers which are already extremely
similar. Consider this example:
</p>

<ul>
<li><p> Three numeric values: <code>c(10.0001, 10.0002, 10.001)</code>.
</p>
</li>
<li><p> The third value differs from median by only 0.0008.
</p>
</li>
<li><p> The third value <code>10.001</code> is 5x MAD factor away from median.
</p>
</li>
<li> <p><code>minDiff = 0.01</code> would require the minimum difference from
median to be at least 0.01 to be eligible to be an outlier point.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rowRmMadOutliers_+3A_minreps">minReps</code></td>
<td>
<p><code>numeric</code> minimum number of non-NA values per row
for outliers to be filtered on the row. This argument is typically
only relevant for rows with <code>n=2</code> non-NA values, and when
<code>rowMadValues</code> is supplied and may define a threshold less than
half the difference in the two points on the given row.
Otherwise, n=2 defines each point at exactly 1x MAD from median,
and would therefore never be considered an outlier.</p>
</td></tr>
<tr><td><code id="rowRmMadOutliers_+3A_includeattributes">includeAttributes</code></td>
<td>
<p><code>logical</code> indicating whether to return
attributes that describe the threshold and type of threshold
used per row, in addition to the madFactor and minDiff values
defined.</p>
</td></tr>
<tr><td><code id="rowRmMadOutliers_+3A_rowmadvalues">rowMadValues</code></td>
<td>
<p><code>numeric</code> optional set of row MAD values to use,
which is mostly helpful when combining MAD values across multiple
samples groups on each row of data, where the combined MAD values
may be more reliable than individual group MAD values.</p>
</td></tr>
<tr><td><code id="rowRmMadOutliers_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating whether to print verbose output.</p>
</td></tr>
<tr><td><code id="rowRmMadOutliers_+3A_...">...</code></td>
<td>
<p>additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function applies outlier detection and removal per
row of the input numeric matrix.
</p>

<ul>
<li><p> It first calculates MAD per row.
</p>
</li>
<li><p> The MAD threshold cutoff is a multiple of the MAD value,
defined by <code>madFactor</code>, multiplying the per-row MAD by the
<code>madFactor</code>.
</p>
</li>
<li><p> The absolute difference from median is calculated for each
point.
</p>
</li>
<li><p> Outlier points are defined:
</p>

<ol>
<li><p> Points with MAD above the MAD threshold, and
</p>
</li>
<li><p> Points with difference from median at or above <code>minDiff</code>
</p>
</li></ol>

</li></ul>

<p>The <code>minDiff</code> parameter affects cases such as 3 replicates,
where all replicates are well within a known threshold
indicating low variance, but where two replicates might
be nearly identical. Consider:
</p>

<ul>
<li><p> Three numeric values: <code>c(10.0001, 10.0002, 10.001)</code>.
</p>
</li>
<li><p> The third value differs from median by only 0.0008.
</p>
</li>
<li><p> The third value <code>10.001</code> is 5x MAD factor away from median.
</p>
</li>
<li> <p><code>minDiff = 0.01</code> would require the minimum difference from
median to be at least 0.01 to be eligible to be an outlier point.
</p>
</li></ul>

<p>One option to define <code>minDiff</code> from the data is to use:
<code>minDiff &lt;- stats::median(rowMads(x))</code>
</p>
<p>In this case, the threshold is defined by the median difference
from median across all rows.
This type of threshold will only be reasonable if the variance
across all rows is expected to be fairly similar.
</p>
<p>This function is substantially faster when the
<code>matrixStats</code> package is installed, but will use the
<code>apply(x, 1, mad)</code> format as a last option.
</p>


<h4>Assumptions</h4>


<ol>
<li><p> This function assumes the input data is appropriate for
the use of MAD as a summary statistic.
</p>
</li>
<li><p> Specifically, numeric values per row are expected to be roughly
normally distributed.
</p>
</li>
<li><p> Outlier points are assumed to be present in less than half overall
non-NA data.
</p>
</li>
<li><p> Outlier points are assumed to be technical outliers, and therefore
not the direct result of the experimental measurements being studied.
Technical outliers are often caused by some instrument measurement,
methodological failure, or other upstream protocol failure.
</p>
</li></ol>

<p>The default threshold of 5x MAD factor is a fairly lenient
criteria, above which the data may even be assumed not to conform
to most downstream statistical techniques.
</p>
<p>For measurements considered to be more robust, or required to be more
robust, the threshold 2x MAD is applied. This criteria is usually a
reasonable expectation of housekeeper gene expression across replicates
within each sample group.
</p>



<h3>Value</h3>

<p><code>numeric</code> matrix with the same dimensions
as the input <code>x</code> matrix. Outliers are replaced with <code>NA</code>.
</p>
<p>If <code>includeAttributes=TRUE</code> then attributes will be
included:
</p>

<ul>
<li> <p><code>outlierDF</code> which is a <code>data.frame</code> with colnames
</p>

<ul>
<li><p> rowMedians: <code>numeric</code> median on each row
</p>
</li>
<li><p> rowMadValues: <code>numeric</code> MAD for each row
</p>
</li>
<li><p> rowThresholds: <code>numeric</code> threshold after applying <code>madFactor</code> and
<code>minDiff</code>
</p>
</li>
<li><p> rowReps: <code>integer</code> number of non-NA values in the input data
</p>
</li>
<li><p> rowTypes: <code>factor</code> indicating the type of threshold: <code>"madFactor"</code>
means the row applied the normal <code>MAD * madFactor</code> threshold;
<code>"minDiff"</code> means the row applied the <code>minDiff</code> threshold which
was the larger threshold.
</p>
</li></ul>

</li>
<li> <p><code>minDiff</code> with the <code>numeric</code> value supplied
</p>
</li>
<li> <p><code>madFactor</code> with the <code>numeric</code> MAD factor threshold supplied
</p>
</li>
<li> <p><code>outliersRemoved</code> with the <code>integer</code> total number of new NA values
produced by the outlier removal process.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other jam numeric functions: 
<code><a href="#topic+deg2rad">deg2rad</a>()</code>,
<code><a href="#topic+noiseFloor">noiseFloor</a>()</code>,
<code><a href="#topic+normScale">normScale</a>()</code>,
<code><a href="#topic+rad2deg">rad2deg</a>()</code>,
<code><a href="#topic+rowGroupMeans">rowGroupMeans</a>()</code>,
<code><a href="#topic+warpAroundZero">warpAroundZero</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123);
x &lt;- matrix(ncol=5, stats::rnorm(25))*5 + 10;
## Define some outlier points
x[1:2,3] &lt;- x[1:2,3]*5 + 50;
x[2:3,2] &lt;- x[2:3,2]*5 - 100;
rownames(x) &lt;- head(letters, nrow(x));

rowRmMadOutliers(x, madFactor=5);

x2 &lt;- rowRmMadOutliers(x, madFactor=2,
   includeAttributes=TRUE);
x2

x3 &lt;- rowRmMadOutliers(x2,
   madFactor=2,
   rowMadValues=attr(x2, "outlierDF")$rowMadValues,
   includeAttributes=TRUE);
x3

</code></pre>

<hr>
<h2 id='sclass'>return the classes of a list of objects</h2><span id='topic+sclass'></span>

<h3>Description</h3>

<p>return the classes of a list of objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sclass(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sclass_+3A_x">x</code></td>
<td>
<p>an S3 object inheriting from class <code>list</code>, or an S4 object.</p>
</td></tr>
<tr><td><code id="sclass_+3A_...">...</code></td>
<td>
<p>additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a <code>list</code> and returns the classes for each
object in the list. In the event an object class has multiple values,
the returned object is a list, otherwise is a vector.
If <code>x</code> is an S4 object, then <code>methods::slotNames(x)</code> is used, and
the class is returned for each S4 slot.
</p>
<p>When <code>x</code> is a <code>data.frame</code>, <code>data.table</code>, <code>tibble</code>, or similar
<code>DataFrame</code> table-like object, the class of each column is returned.
</p>
<p>For the special case where <code>x</code> is an S4 object with one slotName
<code>".Data"</code>, the values in <code>x@.Data</code> are coerced to a <code>list</code>. One
example of this case is with <code>limma::MArrayLM-class</code>.
</p>
<p>When <code>x</code> is a matrix, the class of each column is returned for
consistency, even though the class of each column should be identical.
</p>
<p>For more more information about a list-like object, including
the lengths/dimensions of the elements, see <code>sdim()</code> or <code>ssdim()</code>.
</p>


<h3>Value</h3>

<p><code>character</code> vector with the class of each list element, or
column name, depending upon the input <code>class(x)</code>.
</p>


<h3>See Also</h3>

<p>Other jam list functions: 
<code><a href="#topic+cPaste">cPaste</a>()</code>,
<code><a href="#topic+heads">heads</a>()</code>,
<code><a href="#topic+jam_rapply">jam_rapply</a>()</code>,
<code><a href="#topic+list2df">list2df</a>()</code>,
<code><a href="#topic+mergeAllXY">mergeAllXY</a>()</code>,
<code><a href="#topic+mixedSorts">mixedSorts</a>()</code>,
<code><a href="#topic+rbindList">rbindList</a>()</code>,
<code><a href="#topic+relist_named">relist_named</a>()</code>,
<code><a href="#topic+rlengths">rlengths</a>()</code>,
<code><a href="#topic+sdim">sdim</a>()</code>,
<code><a href="#topic+uniques">uniques</a>()</code>,
<code><a href="#topic+unnestList">unnestList</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sclass(list(LETTERS=LETTERS, letters=letters));

sclass(data.frame(B=letters[1:10], C=2:11))

</code></pre>

<hr>
<h2 id='sdim'>print dimensions of list object elements</h2><span id='topic+sdim'></span><span id='topic+sdima'></span><span id='topic+ssdima'></span><span id='topic+ssdim'></span>

<h3>Description</h3>

<p><code>sdim()</code>  prints the name and dimensions of <code>list</code> object elements,
such as a <code>list</code> of <code>data.frame</code>
</p>
<p><code>ssdim()</code> prints the name and dimensions of nested elements of <code>list</code>
objects, for example a <code>list</code> of <code>list</code> objects that each contain
other objects.
</p>
<p><code>sdima()</code> prints the name and dimensions of object <code>attributes(x)</code>.
It is useful for summarizing the <code>attributes()</code> of an object.
</p>
<p><code>ssdima()</code> prints the name and dimensions of nested elements of <code>list</code>
object <code>attributes()</code>, for example a <code>list</code> of <code>list</code> objects that each
contain other objects. It is useful for comparing attributes across <code>list</code>
elements.
</p>
<p>This function prints the dimensions of a list of objects, usually a <code>list</code>
of <code>data.frame</code> objects, but extended to handle more complicated lists,
including even S4 object <code>methods::slotNames()</code>.
</p>
<p>Over time, more object types will be made compatible with this function.
Currently, <code>igraph</code> objects will print the number of nodes and edges, but
requires the igraph package to be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdim(
  x,
  includeClass = TRUE,
  doFormat = FALSE,
  big.mark = ",",
  verbose = FALSE,
  ...
)

sdima(
  x,
  includeClass = TRUE,
  doFormat = FALSE,
  big.mark = ",",
  verbose = FALSE,
  ...
)

ssdima(
  x,
  includeClass = TRUE,
  doFormat = FALSE,
  big.mark = ",",
  verbose = FALSE,
  ...
)

ssdim(
  x,
  includeClass = TRUE,
  doFormat = FALSE,
  big.mark = ",",
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sdim_+3A_x">x</code></td>
<td>
<p>one of several recognized object classes:
</p>

<ul>
<li><p> an S3 object inheriting from class <code>"list"</code>, including a nested list of
lists or simple list
</p>
</li>
<li><p> an S3 atomic object, which returns only the length
</p>
</li>
<li><p> a single multi-dimensional object such as <code>data.frame</code>, <code>matrix</code>,
<code>array</code>, <code>tibble</code>, or similar, which returns only its dimensions.
</p>
</li>
<li><p> an <code>S4</code> object in which case it used <code>methods::slotNames(x)</code>
to traverse the object structure
</p>
</li>
<li><p> an <code>"environment"</code> object, in which case <code>ls(envir=x)</code> is
used to traverse the object structure.
</p>
</li>
<li><p> When the object is <code>S4</code> that inherits <code>"List"</code> from the
<code>S4Vectors</code> package, it will attempt to use the proper subset
functions from <code>S4Vectors</code> via <code>names(x)</code>, but that process only works
properly if the <code>S4Vectors</code> package is previously loaded,
otherwise it reverts to using <code>methods::slotNames(x)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="sdim_+3A_includeclass">includeClass</code></td>
<td>
<p><code>logical</code> indicating whether to print the class of
each element in the input <code>x</code> object. Note that for S4 objects,
each element will be the object returned for each of
<code>methods::slotNames(x)</code>.</p>
</td></tr>
<tr><td><code id="sdim_+3A_doformat">doFormat</code></td>
<td>
<p><code>logical</code> indicating whether to format the dimensions using
<code>format(...,big.mark=",")</code>, which is mainly useful for extremely
large dimensions. This parameter should probably become more broadly
useful and respectful for different locales.</p>
</td></tr>
<tr><td><code id="sdim_+3A_big.mark">big.mark</code></td>
<td>
<p><code>character</code> value used when <code>doFormat=TRUE</code>, used in the
call to <code>format(...,big.mark)</code>.</p>
</td></tr>
<tr><td><code id="sdim_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> whether to print verbose output</p>
</td></tr>
<tr><td><code id="sdim_+3A_...">...</code></td>
<td>
<p>additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> where each row indicates the dimensions of
each element in the input list. When <code>includeClass</code> is <code>TRUE</code> it
will include a column <code>class</code> which indicates the class of each
list element. When the input list contains arrays with more than
two dimensions, the first two dimensions are named <code>"rows"</code> and
<code>"columns"</code> with additional dimensions named <code>"dim3"</code> and so on.
Any list element with fewer than that many dimensions will only have
values populated to the relevant dimensions, for example a character
vector will only populate the length.
</p>
<p><code>data.frame</code> which
describes the dimensions of the objects in
<code>attributes(x)</code>.
</p>
<p><code>list</code> of <code>data.frame</code> each of which
describes the dimensions of the objects in
<code>attributes(x)</code>.
</p>
<p><code>list</code> of <code>data.frame</code>, each row indicates the dimensions of
each element in the input list.
When <code>includeClass</code> is <code>TRUE</code> it
will include a column <code>class</code> which indicates the class of each
list element.
When the input <code>list</code> contains arrays with more than
two dimensions, the first two dimensions are named <code>"rows"</code> and
<code>"columns"</code> with additional dimensions named <code>"dim3"</code> and so on.
Any <code>list</code> element with fewer than that many dimensions will only have
values populated to the relevant dimensions, for example a character
vector will only populate the length.
</p>


<h3>See Also</h3>

<p>Other jam list functions: 
<code><a href="#topic+cPaste">cPaste</a>()</code>,
<code><a href="#topic+heads">heads</a>()</code>,
<code><a href="#topic+jam_rapply">jam_rapply</a>()</code>,
<code><a href="#topic+list2df">list2df</a>()</code>,
<code><a href="#topic+mergeAllXY">mergeAllXY</a>()</code>,
<code><a href="#topic+mixedSorts">mixedSorts</a>()</code>,
<code><a href="#topic+rbindList">rbindList</a>()</code>,
<code><a href="#topic+relist_named">relist_named</a>()</code>,
<code><a href="#topic+rlengths">rlengths</a>()</code>,
<code><a href="#topic+sclass">sclass</a>()</code>,
<code><a href="#topic+uniques">uniques</a>()</code>,
<code><a href="#topic+unnestList">unnestList</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L &lt;- list(LETTERS=LETTERS,
   letters=letters,
   lettersDF=data.frame(LETTERS, letters));
sdim(L)

LL &lt;- list(L=L, A=list(1:10))
sdim(LL)
ssdim(LL)

m &lt;- matrix(1:9,
   ncol=3,
   dimnames=list(
      Rows=letters[1:3],
      Columns=LETTERS[1:3]));
sdima(m);
ssdima(m);

</code></pre>

<hr>
<h2 id='set_xlsx_colwidths'>Set column widths in Xlsx files</h2><span id='topic+set_xlsx_colwidths'></span>

<h3>Description</h3>

<p>Set column widths in Xlsx files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_xlsx_colwidths(
  xlsxFile,
  sheet = 1,
  cols = seq_along(widths),
  widths = 11,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_xlsx_colwidths_+3A_xlsxfile">xlsxFile</code></td>
<td>
<p><code>character</code> filename to a file with &quot;.xlsx&quot; extension,
or <code>Workbook</code> object defined in the <code>openxlsx</code> package. When
<code>xlsxFile</code> is a <code>Workbook</code> the output is not saved to a file.</p>
</td></tr>
<tr><td><code id="set_xlsx_colwidths_+3A_sheet">sheet</code></td>
<td>
<p><code>integer</code> sheet number or <code>character</code> sheet name,
passed to <code>openxlsx::setColWidths()</code> indicating
the worksheet to affect.</p>
</td></tr>
<tr><td><code id="set_xlsx_colwidths_+3A_cols">cols</code></td>
<td>
<p><code style="white-space: pre;">&#8288;integer vector&#8288;</code> indicating the column numbers to affect.</p>
</td></tr>
<tr><td><code id="set_xlsx_colwidths_+3A_widths">widths</code></td>
<td>
<p><code style="white-space: pre;">&#8288;numeric vector&#8288;</code> indicating the width of each column
defined by <code>cols</code>.</p>
</td></tr>
<tr><td><code id="set_xlsx_colwidths_+3A_...">...</code></td>
<td>
<p>additional arguments are passed to <code>openxlsx::setColWidths()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a light wrapper to perform these steps
from the very useful <code>openxlsx</code> R package:
</p>

<ul>
<li> <p><code>openxlsx::loadWorkbook()</code>
</p>
</li>
<li> <p><code>openxlsx::setColWidths()</code>
</p>
</li>
<li> <p><code>openxlsx::saveWorkbook()</code>
</p>
</li></ul>



<h3>Value</h3>

<p><code>Workbook</code> object as defined by the <code>openxlsx</code> package
is returned invisibly with <code>invisible()</code>. This <code>Workbook</code>
can be used in argument <code>wb</code> to provide a speed boost when
saving multiple sheets to the same file.
</p>


<h3>See Also</h3>

<p>Other jam export functions: 
<code><a href="#topic+applyXlsxCategoricalFormat">applyXlsxCategoricalFormat</a>()</code>,
<code><a href="#topic+applyXlsxConditionalFormat">applyXlsxConditionalFormat</a>()</code>,
<code><a href="#topic+readOpenxlsx">readOpenxlsx</a>()</code>,
<code><a href="#topic+set_xlsx_rowheights">set_xlsx_rowheights</a>()</code>,
<code><a href="#topic+writeOpenxlsx">writeOpenxlsx</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># write to tempfile for examples
if (check_pkg_installed("openxlsx")) {
   out_xlsx &lt;- tempfile(pattern="writeOpenxlsx_", fileext=".xlsx")
   df &lt;- data.frame(a=LETTERS[1:5], b=1:5);
   writeOpenxlsx(x=df,
      file=out_xlsx,
      sheetName="jamba_test");

   ## By default, cols starts at column 1 and continues to length(widths)
   set_xlsx_colwidths(out_xlsx,
      sheet="jamba_test",
      widths=rep(20, ncol(df))
   )
}

</code></pre>

<hr>
<h2 id='set_xlsx_rowheights'>Set row heights in Xlsx files</h2><span id='topic+set_xlsx_rowheights'></span>

<h3>Description</h3>

<p>This function is a light wrapper to perform these steps
from the very useful <code>openxlsx</code> R package:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_xlsx_rowheights(
  xlsxFile,
  sheet = 1,
  rows = seq_along(heights) + 1,
  heights = 17,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_xlsx_rowheights_+3A_xlsxfile">xlsxFile</code></td>
<td>
<p><code>character</code> filename to a file with &quot;.xlsx&quot; extension,
or <code>Workbook</code> object defined in the <code>openxlsx</code> package. When
<code>xlsxFile</code> is a <code>Workbook</code> the output is not saved to a file.</p>
</td></tr>
<tr><td><code id="set_xlsx_rowheights_+3A_sheet">sheet</code></td>
<td>
<p><code>integer</code> sheet number or <code>character</code> sheet name,
passed to <code>openxlsx::setRowHeights()</code> indicating
the worksheet to affect.</p>
</td></tr>
<tr><td><code id="set_xlsx_rowheights_+3A_rows">rows</code></td>
<td>
<p><code style="white-space: pre;">&#8288;integer vector&#8288;</code> indicating the row numbers to affect.</p>
</td></tr>
<tr><td><code id="set_xlsx_rowheights_+3A_heights">heights</code></td>
<td>
<p><code style="white-space: pre;">&#8288;numeric vector&#8288;</code> indicating the height of each column
defined by <code>rows</code>.</p>
</td></tr>
<tr><td><code id="set_xlsx_rowheights_+3A_...">...</code></td>
<td>
<p>additional arguments are passed to <code>openxlsx::setRowHeights()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>openxlsx::loadWorkbook()</code>
</p>
</li>
<li> <p><code>openxlsx::setRowHeights()</code>
</p>
</li>
<li> <p><code>openxlsx::saveWorkbook()</code>
</p>
</li></ul>

<p>Note that when only the argument <code>heights</code> is defined,
the argument <code>rows</code> will point to row 2 and lower, thus
skipping the first (header) row. Define <code>rows</code> specifically
in order to affect the header row as well.
</p>


<h3>Value</h3>

<p><code>Workbook</code> object as defined by the <code>openxlsx</code> package
is returned invisibly with <code>invisible()</code>. This <code>Workbook</code>
can be used in argument <code>wb</code> to provide a speed boost when
saving multiple sheets to the same file.
</p>


<h3>See Also</h3>

<p>Other jam export functions: 
<code><a href="#topic+applyXlsxCategoricalFormat">applyXlsxCategoricalFormat</a>()</code>,
<code><a href="#topic+applyXlsxConditionalFormat">applyXlsxConditionalFormat</a>()</code>,
<code><a href="#topic+readOpenxlsx">readOpenxlsx</a>()</code>,
<code><a href="#topic+set_xlsx_colwidths">set_xlsx_colwidths</a>()</code>,
<code><a href="#topic+writeOpenxlsx">writeOpenxlsx</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># write to tempfile for examples
if (check_pkg_installed("openxlsx")) {
   out_xlsx &lt;- tempfile(pattern="writeOpenxlsx_", fileext=".xlsx")
   df &lt;- data.frame(a=LETTERS[1:5], b=1:5);
   writeOpenxlsx(x=df,
      file=out_xlsx,
      sheetName="jamba_test");

   ## by default, rows will start at row 2, skipping the header
   set_xlsx_rowheights(out_xlsx,
      sheet="jamba_test",
      heights=rep(17, nrow(df))
   )

   ## to include the header row
   set_xlsx_rowheights(out_xlsx,
      sheet="jamba_test",
      rows=seq_len(nrow(df)+1),
      heights=rep(17, nrow(df)+1)
   )
}

</code></pre>

<hr>
<h2 id='setCLranges'>Get Chroma and Luminance ranges for the given lightMode</h2><span id='topic+setCLranges'></span>

<h3>Description</h3>

<p>Return Crange, Lrange, Cgrey, adjustRgb values for the given lightMode,
intended to provide ranges suitable for contrasting text displayed
on a light or dark background.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setCLranges(
  lightMode = NULL,
  Crange = getOption("jam.Crange"),
  Lrange = getOption("jam.Lrange"),
  Cgrey = getOption("jam.Cgrey", 5),
  adjustRgb = getOption("jam.adjustRgb", 0),
  setOptions = c("FALSE", "ifnull", "TRUE"),
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setCLranges_+3A_lightmode">lightMode</code></td>
<td>
<p>boolean indicating whether the background color
is light (TRUE is bright), or dark (FALSE is dark.) By default
it calls <code>checkLightMode()</code> which queries <code>getOption("lightMode")</code>.</p>
</td></tr>
<tr><td><code id="setCLranges_+3A_crange">Crange</code></td>
<td>
<p>numeric range of chroma values, ranging
between 0 and 100. By default, <code>getOptions("Crange")</code> is used,
otherwise defaults will be assigned based upon <code>lightMode</code>.</p>
</td></tr>
<tr><td><code id="setCLranges_+3A_lrange">Lrange</code></td>
<td>
<p>numeric range of luminance values, ranging
between 0 and 100. By default, <code>getOptions("Crange")</code> is used,
otherwise defaults will be assigned based upon <code>lightMode</code>.</p>
</td></tr>
<tr><td><code id="setCLranges_+3A_cgrey">Cgrey</code></td>
<td>
<p>numeric chroma (C) value, which defines grey colors at or
below this chroma. Any colors at or below the grey cutoff will have
their C values unchanged. This mechanism prevents converting black
to red, for example. To disable the effect, set <code>Cgrey=-1</code>.</p>
</td></tr>
<tr><td><code id="setCLranges_+3A_adjustrgb">adjustRgb</code></td>
<td>
<p>numeric color adjustment factor, used during the
conversion of RGB colors to the ANSI-compatible colors used
by the <code>crayon</code> pacakge. The ANSI color range does not include
a full RGB palette, and the conversion is somewhat lossy.
By default, <code>getOptions("jam.adjustRgb")</code> is used to store a
globally re-usable value.</p>
</td></tr>
<tr><td><code id="setCLranges_+3A_setoptions">setOptions</code></td>
<td>
<p>character or logical whether to update <code>options()</code>
<code>"jam.Crange"</code> and <code>"jam.Lrange"</code>, with the following behavior:
</p>

<ul>
<li> <p><code>"ifnull"</code> will update only <code>options()</code> which were previously <code>NULL</code>
</p>
</li>
<li> <p><code>FALSE</code> or <code>"FALSE"</code> does not update <code>options()</code>
</p>
</li>
<li> <p><code>TRUE</code> or <code>"TRUE"</code> will update <code>options()</code> with values determined
by this function.
</p>
</li></ul>
</td></tr>
<tr><td><code id="setCLranges_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating whether to print verbose output.</p>
</td></tr>
<tr><td><code id="setCLranges_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended mainly for internal use by <code>jamba</code>
such as <code>printDebug()</code>, and <code>make_styles()</code>, which is also mainly
intended for console text or other printed text output.
The utility of this function is to store the logic of determining
sensible default ranges.
</p>
<p>Companion functions:
</p>

<ul>
<li> <p><code>applyCLranges()</code> is used to apply the ranges to a vector of R colors.
</p>
</li>
<li> <p><code>checkLightMode()</code> is used to detect whether console output is expected
to have a light or dark background.
</p>
</li></ul>



<h3>Value</h3>

<p><code>list</code> with elements:
</p>

<dl>
<dt>Crange</dt><dd><p>Numeric vector of length 2, defining the
HCL chroma (C) range.</p>
</dd>
<dt>Lrange</dt><dd><p>Numeric vector of length 2, defining the
HCL luminance (L) range.</p>
</dd>
<dt>adjustRgb</dt><dd><p>Numeric vector of length 1, defining the
adjustment to apply during RGB-to-ANSI color conversion.</p>
</dd>
<dt>Cgrey</dt><dd><p>Numeric vector of length 1, defining the
HCL chroma (C) value below which colors are considered greyscale,
and are converted to ANSI greyscale colors.
HCL chroma ranges from 0 to 100. Set value <code>Cgrey=-1</code> or
<code>Cgrey=FALSE</code> to disable this logic, causing colors to be
matched using all available ANSI color values.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other jam color functions: 
<code><a href="#topic+alpha2col">alpha2col</a>()</code>,
<code><a href="#topic+applyCLrange">applyCLrange</a>()</code>,
<code><a href="#topic+col2alpha">col2alpha</a>()</code>,
<code><a href="#topic+col2hcl">col2hcl</a>()</code>,
<code><a href="#topic+col2hsl">col2hsl</a>()</code>,
<code><a href="#topic+col2hsv">col2hsv</a>()</code>,
<code><a href="#topic+color2gradient">color2gradient</a>()</code>,
<code><a href="#topic+fixYellow">fixYellow</a>()</code>,
<code><a href="#topic+fixYellowHue">fixYellowHue</a>()</code>,
<code><a href="#topic+getColorRamp">getColorRamp</a>()</code>,
<code><a href="#topic+hcl2col">hcl2col</a>()</code>,
<code><a href="#topic+hsl2col">hsl2col</a>()</code>,
<code><a href="#topic+hsv2col">hsv2col</a>()</code>,
<code><a href="#topic+isColor">isColor</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+makeColorDarker">makeColorDarker</a>()</code>,
<code><a href="#topic+rainbow2">rainbow2</a>()</code>,
<code><a href="#topic+rgb2col">rgb2col</a>()</code>,
<code><a href="#topic+setTextContrastColor">setTextContrastColor</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+unalpha">unalpha</a>()</code>,
<code><a href="#topic+warpRamp">warpRamp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>setCLranges(lightMode=FALSE)

</code></pre>

<hr>
<h2 id='setPrompt'>set R prompt with project name and R version</h2><span id='topic+setPrompt'></span>

<h3>Description</h3>

<p>set R prompt with project name and R version
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPrompt(
  projectName = "unnamed",
  useColor = TRUE,
  projectColor = "yellow",
  bracketColor = "white",
  Rcolors = c("white", "white", "white"),
  PIDcolor = NA,
  promptColor = "white",
  usePid = TRUE,
  resetPrompt = FALSE,
  addEscape = NULL,
  updateOptions = TRUE,
  debug = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setPrompt_+3A_projectname">projectName</code></td>
<td>
<p><code>character</code> string, default &quot;unnamed&quot;, used as
a label to represent the project work.</p>
</td></tr>
<tr><td><code id="setPrompt_+3A_usecolor">useColor</code></td>
<td>
<p><code>logical</code> whether to define a color prompt if the
<code>crayon</code> package is installed.</p>
</td></tr>
<tr><td><code id="setPrompt_+3A_projectcolor">projectColor</code>, <code id="setPrompt_+3A_bracketcolor">bracketColor</code>, <code id="setPrompt_+3A_rcolors">Rcolors</code>, <code id="setPrompt_+3A_pidcolor">PIDcolor</code>, <code id="setPrompt_+3A_promptcolor">promptColor</code></td>
<td>
<p><code>character</code>
colors used when <code>useColor==TRUE</code> and the <code>crayon</code> package
is installed:
</p>

<ul>
<li> <p><code>projectColor</code> colors the project name;
</p>
</li>
<li> <p><code>bracketColor</code> colors the curly brackets around the project;
</p>
</li>
<li> <p><code>Rcolors</code> can be a vector of 3 colors, colorizing &quot;R&quot;,
the &quot;-&quot; divider, and the R version;
</p>
</li>
<li> <p><code>PIDcolor</code> colors the PID when <code>usePid=TRUE</code>; and
</p>
</li>
<li> <p><code>promptColor</code> colors the <code>"&gt;"</code> at the end of the prompt.
</p>
</li></ul>
</td></tr>
<tr><td><code id="setPrompt_+3A_usepid">usePid</code></td>
<td>
<p><code>logical</code> whether to include the process ID in the prompt.
Including the PID is helpful for the rare occasion when a process is
hung and needs to be stopped directly.</p>
</td></tr>
<tr><td><code id="setPrompt_+3A_resetprompt">resetPrompt</code></td>
<td>
<p><code>logical</code> whether to revert all changes to the prompt
back to the default R prompt, that is, no color and no projectName.</p>
</td></tr>
<tr><td><code id="setPrompt_+3A_addescape">addEscape</code></td>
<td>
<p><code>logical</code> or <code>NULL</code> indicating whether to wrap color
encoding ANSI inside additional escape sequences. This change is
helpful for linux-based (readline-based) R consoles, by telling
the console not to count ANSI color control characters as visible
characters when determining word wrapping on the console. Note
that RStudio does not work well with this setting.
If you find that the word-wrap is incorrect in the R console, try
<code>addEscape=TRUE</code>. Apparently most versions of RStudio will already
adjust (and prevent) colorizing the prompt during editing, presumably
to sidestep the problem of calculating the correct character length.
By default when <code>addEscape</code> is <code>NULL</code>, it checks whether environmental
variable <code>RSTUDIO</code> equals <code>"1"</code> (running inside RStudio) then sets
<code>addEscape=FALSE</code>; otherwise it defines <code>addEscape=TRUE</code>.
In most cases for commandline prompts, <code>addEscape=TRUE</code> is helpful
and not problematic.</p>
</td></tr>
<tr><td><code id="setPrompt_+3A_updateoptions">updateOptions</code></td>
<td>
<p><code>logical</code> whether to update the user <code>options()</code>
with <code>options(prompt="...")</code>, default TRUE.</p>
</td></tr>
<tr><td><code id="setPrompt_+3A_debug">debug</code></td>
<td>
<p><code>logical</code> indicating whether to print the ANSI control
character output for the full prompt, for visual review.</p>
</td></tr>
<tr><td><code id="setPrompt_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> whether to print verbose output.</p>
</td></tr>
<tr><td><code id="setPrompt_+3A_...">...</code></td>
<td>
<p>additional parameters are passed to <code>make_styles()</code> which is
only relevant with the argument <code>useColor=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function sets a simple, colorized R prompt with useful
information:
</p>

<ul>
<li> <p><code>projectName</code>
</p>
</li>
<li><p> R version, major and minor included
</p>
</li>
<li><p> Process ID (PID)
</p>
</li></ul>

<p>The prompt is defined in <code>options("prompt")</code>.
</p>


<h4>Where Am I?</h4>

<p>It is useful for the question: &quot;What version of R?&quot;
In rare cases, multiple R versions can be active at once (!), see
the <code>rig</code> package for this exciting capability.
</p>



<h4>What Am I Doing?</h4>

<p>The core question addressed is : &quot;What am I working on?&quot;
The project name is especially useful when working
with multiple active R sessions.
</p>



<h4>How Do I Stop This Thing?</h4>

<p>It may also be useful for the question &quot;How do I stop this thing&quot;,
by returning the Process ID to be used to kill a long-running process
without fear of killing the <strong>wrong</strong> long-running process.
</p>



<h4>Can It Have Color?</h4>

<p>Then of course, meeting the above requirements, at least make it pretty.
</p>



<h4>Word-Wrap Gone Awry</h4>

<p>A color-encoded prompt may sometimes interfere
with word-wrapping on the R console.
A long line may wrap prematurely
before reaching the right edge of the screen.
There are two frequent causes of this issue:
</p>

<ol>
<li> <p><code>options("width")</code> is sometimes defined too narrow for the
screen. When resizing the console, this option should be updated,
and sometimes this update fails. To fix, either resize the window
briefly again, or define <code>options("width")</code> manually.
(Or debug the reason that this option is not being updated.)
</p>
</li>
<li><p> The terminal <code>locale</code> is sometimes mismatched with the terminal,
usually caused by a layer of terminal emulation which is not
compatible with ANSI color codes, or ANSI escape codes.
</p>

<ul>
<li><p> Some examples: 'PuTTY' on 'Windows', GNU 'screen', 'tmux'.
</p>
</li>
<li><p> Check <code>Sys.env("LC_ALL")</code>. The most common results are
<code>"C"</code> for generic C-type output, or a Unicode/UTF-8 locale such as
<code>"en_US.UTF-8"</code> ('enUS' is English-USA in this context).
In general, Unicode/UTF-8 is recommended, with benefit that
it more readily displays other Unicode characters.
However, sometimes the terminal environment (PuTTY or iTerm)
is expecting one locale, but is receiving another. Either
switching the terminal expected locale, or the R console locale,
may resolve the mismatch.
</p>
</li></ul>

</li></ol>

<p>R uses 'readline' for unix-like systems by default, and
issues related to using color prompt are handled at that level.
</p>
<p>The 'readline' library allows escaping ANSI color characters so they
do not contribute to the estimated line width, and these codes are
used in <code>setPrompt()</code>.
</p>
<p>The final workaround is <code>useColor=FALSE</code>, but that would be a sad
outcome.
</p>



<h3>Value</h3>

<p><code>list</code> named <code>"prompt"</code>, suitable to use in <code>options()</code>
with the recommended prompt.
When <code>updateOptions=FALSE</code> use: <code>options(setPrompt("projectName"))</code>
</p>


<h3>See Also</h3>

<p>Other jam practical functions: 
<code><a href="#topic+breakDensity">breakDensity</a>()</code>,
<code><a href="#topic+call_fn_ellipsis">call_fn_ellipsis</a>()</code>,
<code><a href="#topic+checkLightMode">checkLightMode</a>()</code>,
<code><a href="#topic+check_pkg_installed">check_pkg_installed</a>()</code>,
<code><a href="#topic+colNum2excelName">colNum2excelName</a>()</code>,
<code><a href="#topic+color_dither">color_dither</a>()</code>,
<code><a href="#topic+exp2signed">exp2signed</a>()</code>,
<code><a href="#topic+getAxisLabel">getAxisLabel</a>()</code>,
<code><a href="#topic+isFALSEV">isFALSEV</a>()</code>,
<code><a href="#topic+isTRUEV">isTRUEV</a>()</code>,
<code><a href="#topic+jargs">jargs</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+lldf">lldf</a>()</code>,
<code><a href="#topic+log2signed">log2signed</a>()</code>,
<code><a href="#topic+middle">middle</a>()</code>,
<code><a href="#topic+minorLogTicks">minorLogTicks</a>()</code>,
<code><a href="#topic+newestFile">newestFile</a>()</code>,
<code><a href="#topic+printDebug">printDebug</a>()</code>,
<code><a href="#topic+reload_rmarkdown_cache">reload_rmarkdown_cache</a>()</code>,
<code><a href="#topic+renameColumn">renameColumn</a>()</code>,
<code><a href="#topic+rmInfinite">rmInfinite</a>()</code>,
<code><a href="#topic+rmNA">rmNA</a>()</code>,
<code><a href="#topic+rmNAs">rmNAs</a>()</code>,
<code><a href="#topic+rmNULL">rmNULL</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>setPrompt("jamba")

setPrompt("jamba", projectColor="purple");

setPrompt("jamba", usePid=FALSE);

setPrompt(resetPrompt=TRUE);

</code></pre>

<hr>
<h2 id='setTextContrastColor'>Define visible text color</h2><span id='topic+setTextContrastColor'></span>

<h3>Description</h3>

<p>Given a vector or colors, define a contrasting color for text,
typically using either white or black. The <code>useGrey</code> argument
defines the offset from pure white and pure black, to use a
contrasting grey shade.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setTextContrastColor(
  color,
  hclCutoff = 60,
  rgbCutoff = 127,
  colorModel = c("hcl", "rgb"),
  useGrey = 0,
  keepAlpha = FALSE,
  alphaLens = 0,
  bg = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setTextContrastColor_+3A_color">color</code></td>
<td>
<p>character vector with one or more R-compatible colors.</p>
</td></tr>
<tr><td><code id="setTextContrastColor_+3A_hclcutoff">hclCutoff</code></td>
<td>
<p>numeric threshold above which a color is judged to be
bright, therefore requiring a dark text color. This comparison uses the
L value from the <code>col2hcl()</code> function, which scales colors from
1 to 100.</p>
</td></tr>
<tr><td><code id="setTextContrastColor_+3A_rgbcutoff">rgbCutoff</code></td>
<td>
<p>numeric threshold above which a color is judged to be
bright, therefore requiring a dark text color. The mean r,g,b value is
used.</p>
</td></tr>
<tr><td><code id="setTextContrastColor_+3A_colormodel">colorModel</code></td>
<td>
<p>Either 'hcl' or 'rgb' to indicate how the colors
will be judged for overall brightness. The 'hcl' method uses the L
value, which more reliably represents overall visible lightness.</p>
</td></tr>
<tr><td><code id="setTextContrastColor_+3A_usegrey">useGrey</code></td>
<td>
<p>numeric threshold used to define dark and bright text colors,
using the R greyscale gradient from 0 to 100: <code>useGrey=10</code> implies
<code>"grey10"</code> and <code>"grey90"</code> for the contrasting text colors;
<code>useGrey=15</code> is useful if labels may also overlap white or black space,
since the text will never be fully white or black.</p>
</td></tr>
<tr><td><code id="setTextContrastColor_+3A_keepalpha">keepAlpha</code></td>
<td>
<p>logical indicates whether the input color alpha
transparency should be maintained in the text color. By default, text
alpha is not maintained, and instead is set to alpha=1, fully
opaque.</p>
</td></tr>
<tr><td><code id="setTextContrastColor_+3A_alphalens">alphaLens</code></td>
<td>
<p>numeric value used to adjust the effect of alpha
transparency, where positive values emphasize the background color,
and negative values emphasize the foreground (transparent) color.</p>
</td></tr>
<tr><td><code id="setTextContrastColor_+3A_bg">bg</code></td>
<td>
<p>vector of R colors, used as a background when determining the
brightness of a semi-transparent color. The corresponding brightness
value from the <code>bg</code> is applied via weighted mean to the input
<code>color</code> brightness, the result is compared the the relevant cutoff.
By default <code>graphics::par("bg")</code> is used to determine the default
plot background color, only when there is an open graphics device,
otherwise calling <code>graphics::par("bg")</code> would open a graphics
device, which is not desireable. When no graphics device is open,
and when <code>bg=NULL</code>, the default is <code>bg="white"</code>.</p>
</td></tr>
<tr><td><code id="setTextContrastColor_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>color</code> is expected to represent a background color, the
output is intended to be a color with enough contrast to read
text legibly.
</p>
<p>The brightness of the <code>color</code> is detected dependent upon
the <code>colorModel</code>: when <code>"hcl"</code> the luminance <code>L</code> is compared
to <code>hclCutoff</code>; when <code>"rgb"</code> the brightness is the sum of
the RGB channels which is compared to <code>rgbCutoff</code>. In most
cases the <code>"hcl"</code> and <code>L</code> will be more accurate.
</p>
<p>When <code>color</code> contains transparency, an optional argument <code>bg</code>
represents the figure background color, as if the <code>color</code> is
used to draw a color-filled rectangle. In this case, the <code>bg</code>
and <code>color</code> are combined to determine the resulting actual color.
This scenario is mostly useful when plotting text labels on
a dark background, such as black background with colored
text boxes.
</p>


<h3>Value</h3>

<p><code>character</code> vector of R colors.
</p>


<h3>See Also</h3>

<p>Other jam color functions: 
<code><a href="#topic+alpha2col">alpha2col</a>()</code>,
<code><a href="#topic+applyCLrange">applyCLrange</a>()</code>,
<code><a href="#topic+col2alpha">col2alpha</a>()</code>,
<code><a href="#topic+col2hcl">col2hcl</a>()</code>,
<code><a href="#topic+col2hsl">col2hsl</a>()</code>,
<code><a href="#topic+col2hsv">col2hsv</a>()</code>,
<code><a href="#topic+color2gradient">color2gradient</a>()</code>,
<code><a href="#topic+fixYellow">fixYellow</a>()</code>,
<code><a href="#topic+fixYellowHue">fixYellowHue</a>()</code>,
<code><a href="#topic+getColorRamp">getColorRamp</a>()</code>,
<code><a href="#topic+hcl2col">hcl2col</a>()</code>,
<code><a href="#topic+hsl2col">hsl2col</a>()</code>,
<code><a href="#topic+hsv2col">hsv2col</a>()</code>,
<code><a href="#topic+isColor">isColor</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+makeColorDarker">makeColorDarker</a>()</code>,
<code><a href="#topic+rainbow2">rainbow2</a>()</code>,
<code><a href="#topic+rgb2col">rgb2col</a>()</code>,
<code><a href="#topic+setCLranges">setCLranges</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+unalpha">unalpha</a>()</code>,
<code><a href="#topic+warpRamp">warpRamp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>color &lt;- c("red","yellow","lightblue","darkorchid1","blue4");
setTextContrastColor(color);

# showColors() uses setTextContrastColor() for labels
showColors(color)
# printDebugI() uses setTextContrastColor() for foreground text
printDebugI(color)

# demonstrate the effect of alpha transparency
colorL &lt;- lapply(nameVector(c(1, 0.9, 0.8, 0.6, 0.3)), function(i){
   nameVector(alpha2col(color, alpha=i), color);
})
jamba::showColors(colorL,
   groupCellnotes=FALSE,
   srtCellnote=seq(from=15, to=-15, length.out=5));
graphics::title(ylab="alpha", line=1.5);

# change background to dark blue
withr::with_par(list("bg"="navy", "col"="white", "col.axis"="white"), {
jamba::showColors(colorL,
   groupCellnotes=FALSE,
   srtCellnote=seq(from=15, to=-15, length.out=5))
graphics::title(ylab="alpha", line=1.5);
})

# Example using transparency and drawLabels()
bg &lt;- "blue4";
col &lt;- fixYellow("palegoldenrod");
nullPlot(fill=bg, plotAreaTitle="", doMargins=FALSE);
for (alpha in c(0.1, 0.3, 0.5, 0.7, 0.9)) {
   labelCol &lt;- setTextContrastColor(
      alpha2col("yellow", alpha),
      bg=bg);
   drawLabels(x=1 + alpha,
      y=2 - alpha,
      labelCex=1.5,
      txt="Plot Title",
      boxColor=alpha2col(col, alpha),
      boxBorderColor=labelCol,
      labelCol=labelCol);
}

</code></pre>

<hr>
<h2 id='shadowText'>Draw text with shadow border</h2><span id='topic+shadowText'></span>

<h3>Description</h3>

<p>Draw text with shadow border
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shadowText(
  x,
  y = NULL,
  labels = NULL,
  col = "white",
  bg = setTextContrastColor(col),
  r = getOption("jam.shadow.r", 0.15),
  offset = c(0.15, -0.15),
  n = getOption("jam.shadow.n", 8),
  outline = getOption("jam.outline", TRUE),
  alphaOutline = getOption("jam.alphaOutline", 0.4),
  shadow = getOption("jam.shadow", FALSE),
  shadowColor = getOption("jam.shadowColor", "black"),
  alphaShadow = getOption("jam.alphaShadow", 0.2),
  shadowOrder = c("each", "all"),
  cex = graphics::par("cex"),
  font = graphics::par("font"),
  doTest = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shadowText_+3A_x">x</code>, <code id="shadowText_+3A_y">y</code></td>
<td>
<p>numeric coordinates, either as vectors x and y, or x as a
two-color matrix recognized by <code>grDevices::xy.coords()</code>.</p>
</td></tr>
<tr><td><code id="shadowText_+3A_labels">labels</code></td>
<td>
<p>vector of labels to display at the corresponding xy
coordinates.</p>
</td></tr>
<tr><td><code id="shadowText_+3A_col">col</code>, <code id="shadowText_+3A_bg">bg</code>, <code id="shadowText_+3A_shadowcolor">shadowColor</code></td>
<td>
<p>the label color, and background (outline) color,
and shadow color (if <code>shadow=TRUE</code>), for each
element in <code>labels</code>. Colors are applied in order, and recycled to
<code>length(labels)</code> as needed. By default <code>bg</code> will choose
a contrasting color, based upon <code>setTextContrastColor()</code>.
Also by default, the shadow is &quot;black&quot; true to its name, since it is
expected to darken the area around it.</p>
</td></tr>
<tr><td><code id="shadowText_+3A_r">r</code></td>
<td>
<p>the outline radius, expressed as a fraction of the width of the
character &quot;A&quot; as returned by <code>graphics::strwidth()</code>.</p>
</td></tr>
<tr><td><code id="shadowText_+3A_offset">offset</code></td>
<td>
<p>the outline offset position in xy coordinates, expressed
as a fraction of the width of the character &quot;A&quot; as returned by
<code>graphics::strwidth()</code>, and <code>graphics::strheight()</code>,
respectively.
The offset is only applied when <code>shadow=TRUE</code> to enable the shadow
effect.</p>
</td></tr>
<tr><td><code id="shadowText_+3A_n">n</code></td>
<td>
<p><code>numeric</code> steps around the label used to create the outline.
A higher number may be useful for very large font sizes, otherwise 8
is a reasonably good balance between detail and the number of labels
added.</p>
</td></tr>
<tr><td><code id="shadowText_+3A_outline">outline</code></td>
<td>
<p><code>logical</code> whether to enable outline drawing.</p>
</td></tr>
<tr><td><code id="shadowText_+3A_alphaoutline">alphaOutline</code>, <code id="shadowText_+3A_alphashadow">alphaShadow</code></td>
<td>
<p><code>numeric</code> alpha transparency to use
for the outline and shadow colors, respectively.</p>
</td></tr>
<tr><td><code id="shadowText_+3A_shadow">shadow</code></td>
<td>
<p><code>logical</code> whether to enable shadow drawing.</p>
</td></tr>
<tr><td><code id="shadowText_+3A_shadoworder">shadowOrder</code></td>
<td>
<p><code>character</code> value indicating when shadows are drawn
relative to drawing labels: <code>"each"</code> draws each shadow with each label,
so that shadows will overlap previous labels; <code>"all"</code> draws all shadows
first then all labels, so labels will always appear above all
shadows. See examples.</p>
</td></tr>
<tr><td><code id="shadowText_+3A_cex">cex</code></td>
<td>
<p><code>numeric</code> scalar applied to font size, default <code>graphics::par("cex")</code>.</p>
</td></tr>
<tr><td><code id="shadowText_+3A_font">font</code></td>
<td>
<p><code>character</code> applied to font family, default <code>graphics::par("font")</code>.</p>
</td></tr>
<tr><td><code id="shadowText_+3A_dotest">doTest</code></td>
<td>
<p><code>logical</code> whether to create a visual example of output. Note
that it calls <code><a href="#topic+usrBox">usrBox</a></code> to color the plot area, and the
background can be overridden with something like <code>fill="navy"</code>.</p>
</td></tr>
<tr><td><code id="shadowText_+3A_...">...</code></td>
<td>
<p>other parameters are passed to <code><a href="graphics.html#topic+text">text</a></code>.
Note that certain parameters are not vectorized in that function,
such as <code>srt</code> which requires only a fixed value. To rotate each
label independently, multiple calls to <code><a href="graphics.html#topic+text">text</a></code> or
<code><a href="#topic+shadowText">shadowText</a></code> must be made. Other parameters like <code>adj</code>
only accept up to two values, and those two values affect all label
positioning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draws text with the same syntax as <code>graphics::text()</code> except that
this function adds a contrasting color border around the text, which
helps visibility when the background color is either not known, or is
not expected to be a fixed contrasting color.
</p>
<p>The function draws the label n times with the chosed background
color, then the label itself atop the background text. It does not
typically have a noticeable effect on rendering time, but it may
impact downstream uses in vector file formats like 'SVG' and 'PDF', where
text is stored as proper text and font objects. Take care when editing
text that the underlying shadow text is also edited in sync.
</p>
<p>The parameter <code>doTest=TRUE</code> will display a visual example. The
background color can be modified with <code>fill="navy"</code> for example.
</p>


<h3>Value</h3>

<p>invisible <code>list</code> of components used to call <code>graphics::text()</code>,
including: x, y, allColors, allLabels, cex, font.
</p>


<h3>See Also</h3>

<p>Other jam plot functions: 
<code><a href="#topic+adjustAxisLabelMargins">adjustAxisLabelMargins</a>()</code>,
<code><a href="#topic+coordPresets">coordPresets</a>()</code>,
<code><a href="#topic+decideMfrow">decideMfrow</a>()</code>,
<code><a href="#topic+drawLabels">drawLabels</a>()</code>,
<code><a href="#topic+getPlotAspect">getPlotAspect</a>()</code>,
<code><a href="#topic+groupedAxis">groupedAxis</a>()</code>,
<code><a href="#topic+imageByColors">imageByColors</a>()</code>,
<code><a href="#topic+imageDefault">imageDefault</a>()</code>,
<code><a href="#topic+minorLogTicksAxis">minorLogTicksAxis</a>()</code>,
<code><a href="#topic+nullPlot">nullPlot</a>()</code>,
<code><a href="#topic+plotPolygonDensity">plotPolygonDensity</a>()</code>,
<code><a href="#topic+plotRidges">plotRidges</a>()</code>,
<code><a href="#topic+plotSmoothScatter">plotSmoothScatter</a>()</code>,
<code><a href="#topic+shadowText_options">shadowText_options</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+sqrtAxis">sqrtAxis</a>()</code>,
<code><a href="#topic+usrBox">usrBox</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>shadowText(doTest=TRUE);
shadowText(doTest=TRUE, fill="navy");
shadowText(doTest=TRUE, fill="red4");

# example showing labels with overlapping shadows
withr::with_par(list("mfrow"=c(1, 2)), {
nullPlot(doBoxes=FALSE);
graphics::title(main="shadowOrder='each'");
shadowText(x=c(1.5, 1.65), y=c(1.5, 1.55),
   labels=c("one", "two"), cex=c(2, 4), shadowOrder="each")
nullPlot(doBoxes=FALSE);
graphics::title(main="shadowOrder='all'");
shadowText(x=c(1.5, 1.65), y=c(1.5, 1.55),
   labels=c("one", "two"), cex=c(2, 4), shadowOrder="all")
})

</code></pre>

<hr>
<h2 id='shadowText_options'>Get and set options for shadowText</h2><span id='topic+shadowText_options'></span>

<h3>Description</h3>

<p>Get and set options for shadowText
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shadowText_options(
  r = getOption("jam.shadow.r", 0.15),
  n = getOption("jam.shadow.n", 8),
  outline = getOption("jam.outline", TRUE),
  alphaOutline = getOption("jam.alphaOutline", 0.4),
  shadow = getOption("jam.shadow", FALSE),
  shadowColor = getOption("jam.shadowColor", "black"),
  alphaShadow = getOption("jam.alphaShadow", 0.2),
  r_ex = 1,
  alpha_ex = 1,
  preset = c("none", "default", "bold", "bold white", "bold black", "both", "shadow",
    "bold shadow", "bold white shadow", "bold black shadow", "bold both"),
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shadowText_options_+3A_r">r</code></td>
<td>
<p><code>numeric</code> radius used for outline or shadow</p>
</td></tr>
<tr><td><code id="shadowText_options_+3A_n">n</code></td>
<td>
<p><code>numeric</code> number of shadow steps to render around each text label</p>
</td></tr>
<tr><td><code id="shadowText_options_+3A_outline">outline</code></td>
<td>
<p><code>logical</code> indicating whether to render shadowText
as an outline (default), or when <code>outline=FALSE</code> it renders a
drop shadow offset using <code>offset</code> which by default is slightly
down and to the right of the text labels.</p>
</td></tr>
<tr><td><code id="shadowText_options_+3A_alphaoutline">alphaOutline</code></td>
<td>
<p><code>numeric</code> value for alpha transparency used for
label outlines when <code>outline=TRUE</code>, with values expected
between 0 (fully transparent) and 1 (not transparent).</p>
</td></tr>
<tr><td><code id="shadowText_options_+3A_shadow">shadow</code></td>
<td>
<p><code>logical</code> indicating whether to render shadowText as a
shadow, or not (default).</p>
</td></tr>
<tr><td><code id="shadowText_options_+3A_shadowcolor">shadowColor</code></td>
<td>
<p><code>character</code> R color which defines the color used
for the outline or shadow for each text label.</p>
</td></tr>
<tr><td><code id="shadowText_options_+3A_alphashadow">alphaShadow</code></td>
<td>
<p><code>numeric</code> value for alpha transparency used for
label shadows when <code>shadow=TRUE</code>, with values expected
between 0 (fully transparent) and 1 (not transparent).</p>
</td></tr>
<tr><td><code id="shadowText_options_+3A_r_ex">r_ex</code></td>
<td>
<p><code>numeric</code> expansion factor used to adjust the radius <code>r</code>.
The value for <code>r</code> is defined based upon the arguments provided,
then is multiplied by the <code>r_ex</code> expansion factor.
The result is stored in option &quot;jam.shadow.r&quot;.</p>
</td></tr>
<tr><td><code id="shadowText_options_+3A_alpha_ex">alpha_ex</code></td>
<td>
<p><code>numeric</code> expansion factor used to adjust the
alpha transparency of both <code>alphaOutline</code> and <code>alphaShadow</code>.
Values will be maintained no lower than 0 and no higher than 1.
The values for <code>alphaOutline</code> and <code>alphaShadow</code> are defined
based upon the arguments provided, then are multiplied by the
<code>alpha_ex</code> expansion factor.
The result is clipped to range 0,1 using <code>jamba::noiseFloor()</code>.
The resulting values are stored in options
&quot;jam.alphaOutline&quot; and &quot;jam.alphaShadow&quot;, respectively.</p>
</td></tr>
<tr><td><code id="shadowText_options_+3A_preset">preset</code></td>
<td>
<p><code>character</code> string which defines a preset with
associated settings. Any value other than <code>"none"</code> will cause
all other options to use the preset settings.
</p>

<ul>
<li> <p><code>"none"</code>: no preset settings are applied
</p>
</li>
<li> <p><code>"default"</code>: reverts all options to the original default values,
which produces an outline, and not a drop shadow.
The color will use <code>shadowColor</code> which allows using all other settings
from this preset, except with custom color.
</p>
</li>
<li> <p><code>"bold"</code>: makes output produce visibly more distinct outline,
with no drop shadow.
The color will use <code>shadowColor</code> which allows using all other settings
from this preset, except with custom color.
</p>
</li>
<li> <p><code>"bold white"</code>: same as &quot;bold&quot; except default text color is white
</p>
</li>
<li> <p><code>"bold black"</code>: same as &quot;bold&quot; except default text color is black
</p>
</li>
<li> <p><code>"both"</code>: applies &quot;default&quot; and enables drop shadow
</p>
</li>
<li> <p><code>"shadow"</code>: uses suggested default values to produce a drop shadow,
and not an outline.
The color will use <code>shadowColor</code> which allows using all other settings
from this preset, except with custom color.
</p>
</li>
<li> <p><code>"bold shadow"</code>: same as &quot;shadow&quot; except the shadow is more distinct.
The color will use <code>shadowColor</code> which allows using all other settings
from this preset, except with custom color.
</p>
</li>
<li> <p><code>"bold white shadow"</code>: same as &quot;bold shadow&quot; with white shadow
</p>
</li>
<li> <p><code>"bold black shadow"</code>: same as &quot;bold shadow&quot; with black shadow
</p>
</li>
<li> <p><code>"bold both"</code>: same as &quot;bold&quot; except also enables bold shadow
</p>
</li></ul>
</td></tr>
<tr><td><code id="shadowText_options_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating whether to print verbose output</p>
</td></tr>
<tr><td><code id="shadowText_options_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to be a convenient method to get and set
options to be used with <code>jamba::shadowText()</code>.
This function stores the resulting values in <code>options()</code> for
use by <code>shadowText()</code>.
</p>


<h3>Value</h3>

<p><code>list</code> with the following options for <code>shadowText()</code>:
</p>

<ul>
<li><p> jam.shadow.r
</p>
</li>
<li><p> jam.shadow.n
</p>
</li>
<li><p> jam.outline
</p>
</li>
<li><p> jam.alphaOutline
</p>
</li>
<li><p> jam.shadow
</p>
</li>
<li><p> jam.shadowColor
</p>
</li>
<li><p> jam.alphaShadow
</p>
</li></ul>



<h3>See Also</h3>

<p>Other jam plot functions: 
<code><a href="#topic+adjustAxisLabelMargins">adjustAxisLabelMargins</a>()</code>,
<code><a href="#topic+coordPresets">coordPresets</a>()</code>,
<code><a href="#topic+decideMfrow">decideMfrow</a>()</code>,
<code><a href="#topic+drawLabels">drawLabels</a>()</code>,
<code><a href="#topic+getPlotAspect">getPlotAspect</a>()</code>,
<code><a href="#topic+groupedAxis">groupedAxis</a>()</code>,
<code><a href="#topic+imageByColors">imageByColors</a>()</code>,
<code><a href="#topic+imageDefault">imageDefault</a>()</code>,
<code><a href="#topic+minorLogTicksAxis">minorLogTicksAxis</a>()</code>,
<code><a href="#topic+nullPlot">nullPlot</a>()</code>,
<code><a href="#topic+plotPolygonDensity">plotPolygonDensity</a>()</code>,
<code><a href="#topic+plotRidges">plotRidges</a>()</code>,
<code><a href="#topic+plotSmoothScatter">plotSmoothScatter</a>()</code>,
<code><a href="#topic+shadowText">shadowText</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+sqrtAxis">sqrtAxis</a>()</code>,
<code><a href="#topic+usrBox">usrBox</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nullPlot(doBoxes=FALSE, xlim=c(-1, 4), ylim=c(-1, 4), asp=1);
usrBox(fill="grey")
cex &lt;- 1.2
graphics::axis(1);graphics::axis(2, las=2)
shadowText_options(preset="default")
shadowText(x=0, y=3, "default", cex=cex)
shadowText_options(preset="bold")
shadowText(x=0, y=2, "bold", cex=cex)
shadowText_options(preset="bold white")
shadowText(x=0, y=1, col="black", "bold white", cex=cex)
shadowText_options(preset="bold black")
shadowText(x=0, y=0, col="white", "bold black", cex=cex)
shadowText_options(preset="shadow")
shadowText(x=3, y=3, "shadow", cex=cex)
shadowText_options(preset="bold shadow")
shadowText(x=3, y=2, "bold shadow", cex=cex)
shadowText_options(preset="bold white shadow")
shadowText(x=3, y=1, col="black", "bold white shadow", cex=cex)
shadowText_options(preset="bold black shadow")
shadowText(x=3, y=0, col="white", "bold black shadow", cex=cex)
shadowText_options(preset="both")
shadowText(x=1.5, y=3, col="white", "both", cex=cex)
shadowText(x=1.5, y=2.5, col="black", "both", cex=cex)
shadowText_options(preset="bold both")
shadowText(x=1.5, y=2, col="white", "bold both", cex=cex)
shadowText(x=1.5, y=1, col="black", "bold both", cex=cex)
shadowText(x=1.5, y=0.5, col="blue3", "bold both", cex=cex, font=2)
shadowText(x=1.5, y=0, col="indianred1", "bold both", cex=cex, font=2)
shadowText_options(preset="default")

</code></pre>

<hr>
<h2 id='showColors'>Show colors from a vector or list</h2><span id='topic+showColors'></span>

<h3>Description</h3>

<p>Show colors from a vector or list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showColors(
  x,
  labelCells = NULL,
  transpose = FALSE,
  srtCellnote = NULL,
  adjustMargins = TRUE,
  makeUnique = FALSE,
  doPlot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="showColors_+3A_x">x</code></td>
<td>
<p>one of these input types:
</p>

<ul>
<li> <p><code>character</code> vector of colors
</p>
</li>
<li> <p><code>function</code> to produce colors, for example <code>circlize::colorRamp2()</code>
</p>
</li>
<li> <p><code>list</code> with any combination of <code>character</code> or <code>function</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="showColors_+3A_labelcells">labelCells</code></td>
<td>
<p><code>logical</code> whether to label colors atop the color itself.
If NULL (default) it will only display labels with 40 or fewer items
on either axis.</p>
</td></tr>
<tr><td><code id="showColors_+3A_transpose">transpose</code></td>
<td>
<p><code>logical</code> whether to transpose the colors to display
top-to-bottom, instead of left-to-right.</p>
</td></tr>
<tr><td><code id="showColors_+3A_srtcellnote">srtCellnote</code></td>
<td>
<p><code>numeric</code> angle to rotate text when
<code>labelCells=TRUE</code>. When set to NULL, labels are vertical
srtCellnote=90 when <code>transpose=FALSE</code> and horizontal
srtCellnote=0 when <code>transpose=TRUE</code>.</p>
</td></tr>
<tr><td><code id="showColors_+3A_adjustmargins">adjustMargins</code></td>
<td>
<p><code>logical</code> indicating whether to call
<code>adjustAxisLabelMargins()</code> to adjust the x- and y-axis
label margins to accomodate the label size.
</p>

<ul>
<li><p> Note when an axis is hidden by using <code>xaxt="n"</code> or <code>xaxt="n"</code>,
the respective margin will not be adjusted.
</p>
</li>
<li><p> The arguments in <code>...</code> take precedence over <code>graphics::par()</code>,
when deciding whether to adjust margins. However if <code>xaxt="s"</code> and
<code>graphics::par("xaxt"="n")</code> the margin will be adjusted but not
displayed.
In this way the axes can be adjusted without displaying the labels,
so the labels can be rendered later if needed.
</p>
</li></ul>
</td></tr>
<tr><td><code id="showColors_+3A_makeunique">makeUnique</code></td>
<td>
<p><code>logical</code> indicating whether to display only the first
unique color. When <code>x</code> is supplied as a <code>list</code> this operation will
display the first unique color for each <code>list</code> element.
Also, when <code>x</code> is a <code>list</code>, just to be fancy, <code>makeUnique</code>
is recycled to <code>length(x)</code> so certain list elements can display
unique values, while others display all values.</p>
</td></tr>
<tr><td><code id="showColors_+3A_doplot">doPlot</code></td>
<td>
<p><code>logical</code> indicating whether to produce a visual plot.
Note this function returns the color matrix invisibly.</p>
</td></tr>
<tr><td><code id="showColors_+3A_...">...</code></td>
<td>
<p>additional parameters are passed to <code>imageByColors()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simply displays colors for review, using
<code>imageByColors()</code> to display colors and labels across the
plot space.
</p>
<p>When supplied a <code>list</code>, each row in <code>imageByColors()</code> represents
an entry in the <code>list</code>. Nothing fancy.
</p>


<h3>Value</h3>

<p>invisible color <code>matrix</code> used by <code>imageByColors()</code>. When
the input <code>x</code> is empty, or cannot be converted to colors when
<code>x</code> contains a <code>function</code>, the output returns <code>NULL</code>.
</p>


<h3>See Also</h3>

<p>Other jam plot functions: 
<code><a href="#topic+adjustAxisLabelMargins">adjustAxisLabelMargins</a>()</code>,
<code><a href="#topic+coordPresets">coordPresets</a>()</code>,
<code><a href="#topic+decideMfrow">decideMfrow</a>()</code>,
<code><a href="#topic+drawLabels">drawLabels</a>()</code>,
<code><a href="#topic+getPlotAspect">getPlotAspect</a>()</code>,
<code><a href="#topic+groupedAxis">groupedAxis</a>()</code>,
<code><a href="#topic+imageByColors">imageByColors</a>()</code>,
<code><a href="#topic+imageDefault">imageDefault</a>()</code>,
<code><a href="#topic+minorLogTicksAxis">minorLogTicksAxis</a>()</code>,
<code><a href="#topic+nullPlot">nullPlot</a>()</code>,
<code><a href="#topic+plotPolygonDensity">plotPolygonDensity</a>()</code>,
<code><a href="#topic+plotRidges">plotRidges</a>()</code>,
<code><a href="#topic+plotSmoothScatter">plotSmoothScatter</a>()</code>,
<code><a href="#topic+shadowText">shadowText</a>()</code>,
<code><a href="#topic+shadowText_options">shadowText_options</a>()</code>,
<code><a href="#topic+sqrtAxis">sqrtAxis</a>()</code>,
<code><a href="#topic+usrBox">usrBox</a>()</code>
</p>
<p>Other jam color functions: 
<code><a href="#topic+alpha2col">alpha2col</a>()</code>,
<code><a href="#topic+applyCLrange">applyCLrange</a>()</code>,
<code><a href="#topic+col2alpha">col2alpha</a>()</code>,
<code><a href="#topic+col2hcl">col2hcl</a>()</code>,
<code><a href="#topic+col2hsl">col2hsl</a>()</code>,
<code><a href="#topic+col2hsv">col2hsv</a>()</code>,
<code><a href="#topic+color2gradient">color2gradient</a>()</code>,
<code><a href="#topic+fixYellow">fixYellow</a>()</code>,
<code><a href="#topic+fixYellowHue">fixYellowHue</a>()</code>,
<code><a href="#topic+getColorRamp">getColorRamp</a>()</code>,
<code><a href="#topic+hcl2col">hcl2col</a>()</code>,
<code><a href="#topic+hsl2col">hsl2col</a>()</code>,
<code><a href="#topic+hsv2col">hsv2col</a>()</code>,
<code><a href="#topic+isColor">isColor</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+makeColorDarker">makeColorDarker</a>()</code>,
<code><a href="#topic+rainbow2">rainbow2</a>()</code>,
<code><a href="#topic+rgb2col">rgb2col</a>()</code>,
<code><a href="#topic+setCLranges">setCLranges</a>()</code>,
<code><a href="#topic+setTextContrastColor">setTextContrastColor</a>()</code>,
<code><a href="#topic+unalpha">unalpha</a>()</code>,
<code><a href="#topic+warpRamp">warpRamp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- color2gradient(list(Reds=c("red"), Blues=c("blue")), n=c(4,7));
showColors(x);

showColors(getColorRamp("firebrick3"))

if (requireNamespace("RColorBrewer", quietly=TRUE)) {
   RColorBrewer_namelist &lt;- rownames(RColorBrewer::brewer.pal.info);
   y &lt;- lapply(nameVector(RColorBrewer_namelist), function(i){
      n &lt;- RColorBrewer::brewer.pal.info[i, "maxcolors"]
      j &lt;- RColorBrewer::brewer.pal(n, i);
      nameVector(j, seq_along(j));
   });
   showColors(y, cexCellnote=0.6, cex.axis=0.7, main="Brewer Colors");
}
if (requireNamespace("viridisLite", quietly=TRUE)) {
   # given one function name it will display discrete colors
   showColors(viridisLite::viridis)
   # a list of functions will show each function output
   showColors(list(viridis=viridisLite::viridis,
      inferno=viridisLite::inferno))

   # grab the full viridis color map
   z &lt;- rgb2col(viridisLite::viridis.map[,c("R","G","B")]);
   # split the colors into a list
   viridis_names &lt;- c(A="magma",
      B="inferno",
      C="plasma",
      D="viridis",
      E="cividis",
      F="rocket",
      G="mako",
      H="turbo")
   y &lt;- split(z,
      paste0(viridisLite::viridis.map$opt, ": ",
      viridis_names[viridisLite::viridis.map$opt]));
   showColors(y, labelCells=TRUE, xaxt="n", main="viridis.map colors");
}

# demonstrate makeUnique=TRUE
j1 &lt;- getColorRamp("rainbow", n=7);
names(j1) &lt;- seq_along(j1);
j2 &lt;- rep(j1, each=3);
names(j2) &lt;- makeNames(names(j2), suffix="_rep");
j2
showColors(list(
   j1=j1,
   j2=j2,
   j3=j2),
   makeUnique=c(FALSE, FALSE, TRUE))

</code></pre>

<hr>
<h2 id='sizeAsNum'>convert size to numeric value</h2><span id='topic+sizeAsNum'></span>

<h3>Description</h3>

<p>convert size to numeric value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sizeAsNum(x, kiloSize = 1024, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sizeAsNum_+3A_x">x</code></td>
<td>
<p><code>character</code> vector. When <code>x</code> is numeric, it is returned as-is;
otherwise x is coerced to <code>character</code> with <code>as.character()</code> and
will throw an error if it fails.</p>
</td></tr>
<tr><td><code id="sizeAsNum_+3A_kilosize">kiloSize</code></td>
<td>
<p><code>numeric</code> number of base units when converting from one
base unit, to one &quot;kilo&quot; base unit. For file sizes, this value is 1024,
but for other purposes this value may be 1000, like one thousand units
is <code>"1k units"</code>.</p>
</td></tr>
<tr><td><code id="sizeAsNum_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating whether to print verbose output.
The output includes a <code>data.frame</code> summarizing the input,
and the unit matched, and the final value. If <code>verbose==2</code> it
will return this <code>data.frame</code> for review.</p>
</td></tr>
<tr><td><code id="sizeAsNum_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to provide the inverse of <code>asSize()</code>
by converting an abbreviated size into a full numeric value.
</p>
<p>It makes one simplifying assumption, that the first character in
the unit is enough to determine the unit. This assumption also means
the units are currently case-sensitive, for example <code>Mega</code> requires
upper-case <code>"M"</code>, because <code>"milli"</code> which is not supported,
requires <code>"m"</code>.
</p>
<p>Unit abbreviations recognized:
</p>

<ul>
<li> <p><code>k</code> - kilo - size is defined by <code>kiloSize</code>
</p>
</li>
<li> <p><code>M</code> - Mega - size is defined by <code>kiloSize ^ 2</code>
</p>
</li>
<li> <p><code>G</code> - Giga - size is defined by <code>kiloSize ^ 3</code>
</p>
</li>
<li> <p><code>T</code> - Tera - size is defined by <code>kiloSize ^ 4</code>
</p>
</li>
<li> <p><code>P</code> - Peta - size is defined by <code>kiloSize ^ 5</code>
</p>
</li></ul>

<p>Everything else is considered to have no abbreviated units, thus
the numeric value is returned as-is.
</p>
<p>Note that the round trip <code>asSize()</code> followed by <code>sizeAsNum()</code> will
not produce identical values, because the intermediate value is
rounded by <code>digits</code> in <code>asSize()</code>.
</p>


<h3>Value</h3>

<p><code>numeric</code> vector representing the numeric value represented
by an abbreviated size.
</p>


<h3>See Also</h3>

<p>Other jam string functions: 
<code><a href="#topic+asSize">asSize</a>()</code>,
<code><a href="#topic+breaksByVector">breaksByVector</a>()</code>,
<code><a href="#topic+fillBlanks">fillBlanks</a>()</code>,
<code><a href="#topic+formatInt">formatInt</a>()</code>,
<code><a href="#topic+gsubOrdered">gsubOrdered</a>()</code>,
<code><a href="#topic+gsubs">gsubs</a>()</code>,
<code><a href="#topic+makeNames">makeNames</a>()</code>,
<code><a href="#topic+nameVector">nameVector</a>()</code>,
<code><a href="#topic+nameVectorN">nameVectorN</a>()</code>,
<code><a href="#topic+padInteger">padInteger</a>()</code>,
<code><a href="#topic+padString">padString</a>()</code>,
<code><a href="#topic+pasteByRow">pasteByRow</a>()</code>,
<code><a href="#topic+pasteByRowOrdered">pasteByRowOrdered</a>()</code>,
<code><a href="#topic+tcount">tcount</a>()</code>,
<code><a href="#topic+ucfirst">ucfirst</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- asSize(c(1, 10,2010,22000,52200), unitType="")
x
#&gt; "1"   "10" "2k"     "21k"    "51k"
sizeAsNum(x)

sizeAsNum(x, kiloSize=1000)

</code></pre>

<hr>
<h2 id='smoothScatterJam'>Smooth scatter plot, Jam style</h2><span id='topic+smoothScatterJam'></span>

<h3>Description</h3>

<p>Produce smooth scatter plot, a helper function called by
<code>plotSmoothScatter()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothScatterJam(
  x,
  y = NULL,
  nbin = 256,
  bandwidth,
  colramp = grDevices::colorRampPalette(c("white", "lightblue", "blue", "orange",
    "orangered2")),
  nrpoints = 100,
  pch = ".",
  cex = 1,
  col = "black",
  transformation = function(x) x^0.25,
  postPlotHook = graphics::box,
  xlab = NULL,
  ylab = NULL,
  xlim,
  ylim,
  add = FALSE,
  xaxs = graphics::par("xaxs"),
  yaxs = graphics::par("yaxs"),
  xaxt = graphics::par("xaxt"),
  yaxt = graphics::par("yaxt"),
  useRaster = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smoothScatterJam_+3A_x">x</code></td>
<td>
<p><code>numeric</code> vector, or data matrix with two or  more columns.</p>
</td></tr>
<tr><td><code id="smoothScatterJam_+3A_y">y</code></td>
<td>
<p><code>numeric</code> vector, or if data is supplied via x as a matrix, y
is NULL.</p>
</td></tr>
<tr><td><code id="smoothScatterJam_+3A_nbin">nbin</code></td>
<td>
<p><code>integer</code> number of bins to use when converting the kernel
density result (which uses bandwidthN above) into a usable image.
For example, nbin=123 is the default used by
<code>graphics::smoothScatter()</code>, however the
<code>plotSmoothScatter()</code> function default is higher (256).</p>
</td></tr>
<tr><td><code id="smoothScatterJam_+3A_bandwidth">bandwidth</code></td>
<td>
<p><code>numeric</code> vector used to define the y- and x-axis
bandwidths, respectively, passed to <code>KernSmooth::bkde2D()</code>,
which calculates the underlying 2-dimensional kernel density.
The <code>plotSmoothScatter()</code> function was motivated by never wanting
to define this number directly, instead auto-calculation suitable
values.</p>
</td></tr>
<tr><td><code id="smoothScatterJam_+3A_colramp">colramp</code></td>
<td>
<p><code>function</code> that takes one <code>numeric</code> argument and returns
that integer number of colors, by default 256.</p>
</td></tr>
<tr><td><code id="smoothScatterJam_+3A_nrpoints">nrpoints</code></td>
<td>
<p><code>integer</code> number of outlier datapoints to display,
as defined by <code>graphics::smoothScatter()</code>, however the default here
is <code>nrpoints=0</code> to avoid additional clutter in the output,
and because the default argument <code>bandwidthN</code> usually indicates all
individual points.</p>
</td></tr>
<tr><td><code id="smoothScatterJam_+3A_pch">pch</code></td>
<td>
<p><code>integer</code> point shape used when <code>nrpoints&gt;0</code>.</p>
</td></tr>
<tr><td><code id="smoothScatterJam_+3A_cex">cex</code></td>
<td>
<p><code>numeric</code> point size expansion factor used when <code>nrpoints&gt;0</code>.</p>
</td></tr>
<tr><td><code id="smoothScatterJam_+3A_col">col</code></td>
<td>
<p><code>character</code> R color used when <code>nrpoints&gt;0</code>.</p>
</td></tr>
<tr><td><code id="smoothScatterJam_+3A_transformation">transformation</code></td>
<td>
<p><code>function</code> which converts point density to a number,
typically related to square root or cube root transformation.</p>
</td></tr>
<tr><td><code id="smoothScatterJam_+3A_postplothook">postPlotHook</code></td>
<td>
<p><code>function</code> or <code>NULL</code>, NULL default.
When <code>function</code> is supplied, it is called after producing the image.
By default it is simply used to draw a box around the image,
but could be used to layer additional information atop the image plot,
for example contours, labels, etc.</p>
</td></tr>
<tr><td><code id="smoothScatterJam_+3A_xlab">xlab</code></td>
<td>
<p><code>character</code> x-axis label</p>
</td></tr>
<tr><td><code id="smoothScatterJam_+3A_ylab">ylab</code></td>
<td>
<p><code>character</code> y-axis label</p>
</td></tr>
<tr><td><code id="smoothScatterJam_+3A_xlim">xlim</code></td>
<td>
<p><code>numeric</code> x-axis range for the plot</p>
</td></tr>
<tr><td><code id="smoothScatterJam_+3A_ylim">ylim</code></td>
<td>
<p><code>numeric</code> y-axis range for the plot</p>
</td></tr>
<tr><td><code id="smoothScatterJam_+3A_add">add</code></td>
<td>
<p><code>logical</code> whether to add to an existing active R plot, or create
a new plot window.</p>
</td></tr>
<tr><td><code id="smoothScatterJam_+3A_xaxs">xaxs</code></td>
<td>
<p><code>character</code> value compatible with <code>graphics::par("xaxs")</code>, mainly useful
for suppressing the x-axis, in order to produce a custom x-axis
range, most useful to restrict the axis range expansion done by R
by default.</p>
</td></tr>
<tr><td><code id="smoothScatterJam_+3A_yaxs">yaxs</code></td>
<td>
<p><code>character</code> value compatible with <code>graphics::par("yaxs")</code>, mainly useful
for suppressing the y-axis, in order to produce a custom y-axis
range, most useful to restrict the axis range expansion done by R
by default.</p>
</td></tr>
<tr><td><code id="smoothScatterJam_+3A_xaxt">xaxt</code></td>
<td>
<p><code>character</code> value compatible with <code>graphics::par("xaxt")</code>, mainly useful
for suppressing the x-axis, in order to produce a custom x-axis
by other mechanisms, e.g. log-scaled x-axis tick marks.</p>
</td></tr>
<tr><td><code id="smoothScatterJam_+3A_yaxt">yaxt</code></td>
<td>
<p><code>character</code> value compatible with <code>graphics::par("yaxt")</code>, mainly useful
for suppressing the y-axis, in order to produce a custom y-axis
by other mechanisms, e.g. log-scaled y-axis tick marks.</p>
</td></tr>
<tr><td><code id="smoothScatterJam_+3A_useraster">useRaster</code></td>
<td>
<p><code>NULL</code> or <code>logical</code> indicating whether to invoke
<code>graphics::rasterImage()</code> to produce a raster image.
If NULL, it determines whether to produce a raster image within the
<code>imageDefault()</code> function, which checks the options
using <code>getOption("preferRaster", FALSE)</code> to determine among
other things, whether the user prefers raster images, and if the
<code>grDevices::dev.capabilities()</code> supports raster.</p>
</td></tr>
<tr><td><code id="smoothScatterJam_+3A_...">...</code></td>
<td>
<p>additional arguments are passed to <code>imageDefault()</code> and
optionally to <code>plotPlotHook()</code> when supplied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For general purposes, use <code>plotSmoothScatter()</code> as a replacement
for <code>graphics::smoothScatter()</code>, which produces better default
settings for pixel size and density bandwidth.
</p>
<p>This function is only necessary in order to override the
<code>graphics::smoothScatter()</code> function which calls
<code>graphics::image.default()</code>.
Instead, this function calls <code>imageDefault()</code> which is required
in order to utilize custom raster image scaling, particularly important
when the x- and y-axis ranges are not similar, e.g. where the x-axis spans
10 units, but the y-axis spans 10,000 units.
</p>


<h3>Value</h3>

<p><code>list</code> of elements sufficient to call <code>graphics::image()</code>,
also by default this function is called for the byproduct of
creating a figure.
</p>


<h3>See Also</h3>

<p><code>graphics::smoothScatter()</code>
</p>
<p>Other jam internal functions: 
<code><a href="#topic+handleArgsText">handleArgsText</a>()</code>,
<code><a href="#topic+jamCalcDensity">jamCalcDensity</a>()</code>,
<code><a href="#topic+make_html_styles">make_html_styles</a>()</code>,
<code><a href="#topic+make_styles">make_styles</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- rnorm(1000);
y1 &lt;- (x1 + 5)* 4  + rnorm(1000);
smoothScatterJam(x=x1, y=y1, bandwidth=c(0.05, 0.3))

</code></pre>

<hr>
<h2 id='sqrtAxis'>Determine square root axis tick mark positions</h2><span id='topic+sqrtAxis'></span>

<h3>Description</h3>

<p>Determine square root axis tick mark positions, including positive
and negative range values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqrtAxis(
  side = 1,
  x = NULL,
  pretty.n = 10,
  u5.bias = 1,
  big.mark = ",",
  plot = TRUE,
  las = 2,
  cex.axis = 0.6,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sqrtAxis_+3A_side">side</code></td>
<td>
<p><code>integer</code> value indicating the axis position, as used
by <code>graphics::axis()</code>, 1=bottom, 2=left, 3=top, 4=right.
Note that when <code>x</code> is supplied, the numeric range is defined
using values in <code>x</code> and not the axis side.</p>
</td></tr>
<tr><td><code id="sqrtAxis_+3A_x">x</code></td>
<td>
<p>optional <code>numeric</code> vector representing the numeric range
to be labeled. When supplied, the numeric range of <code>x</code> is used
and not the axis side.</p>
</td></tr>
<tr><td><code id="sqrtAxis_+3A_pretty.n">pretty.n</code></td>
<td>
<p><code>numeric</code> value indicating the number of desired
tick marks, passed to <code>pretty()</code>.</p>
</td></tr>
<tr><td><code id="sqrtAxis_+3A_u5.bias">u5.bias</code></td>
<td>
<p><code>numeric</code> value passed to <code>pretty()</code> to influence the
frequency of intermediate tick marks.</p>
</td></tr>
<tr><td><code id="sqrtAxis_+3A_big.mark">big.mark</code></td>
<td>
<p><code>character</code> value passed to <code>format()</code> which helps
visually distinguish numbers larger than 1000.</p>
</td></tr>
<tr><td><code id="sqrtAxis_+3A_plot">plot</code></td>
<td>
<p><code>logical</code> indicating whether to plot the axis tick
marks and labels.</p>
</td></tr>
<tr><td><code id="sqrtAxis_+3A_las">las</code>, <code id="sqrtAxis_+3A_cex.axis">cex.axis</code></td>
<td>
<p><code>numeric</code> values passed to <code>graphics::axis()</code>
when drawing the axis. The custom default <code>las=2</code> plots labels rotated
perpendicular to the axis.</p>
</td></tr>
<tr><td><code id="sqrtAxis_+3A_...">...</code></td>
<td>
<p>additional parameters are passed to <code>pretty()</code>, and to
<code>graphics::axis()</code> when <code>plot=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates positions for tick marks for data
that has been transformed with <code>sqrt()</code>, specifically a directional
transformation like <code>sqrt(abs(x)) * sign(x)</code>.
</p>
<p>If <code>x</code> is supplied, it is used to define the numeric range, otherwise
the observed range is taken based upon <code>side</code>. If neither <code>x</code> nor <code>side</code>
is supplied, or if the numeric range is empty or zero width,
it returns <code>NULL</code>.
</p>
<p>The main goal of this function is to provide reasonably placed
tick marks using integer values.
</p>


<h3>Value</h3>

<p>invisible <code>numeric</code> vector with axis positions, named
by normal space numeric labels. The primary use is to
add numeric axis tick marks and labels.
</p>


<h3>See Also</h3>

<p>Other jam plot functions: 
<code><a href="#topic+adjustAxisLabelMargins">adjustAxisLabelMargins</a>()</code>,
<code><a href="#topic+coordPresets">coordPresets</a>()</code>,
<code><a href="#topic+decideMfrow">decideMfrow</a>()</code>,
<code><a href="#topic+drawLabels">drawLabels</a>()</code>,
<code><a href="#topic+getPlotAspect">getPlotAspect</a>()</code>,
<code><a href="#topic+groupedAxis">groupedAxis</a>()</code>,
<code><a href="#topic+imageByColors">imageByColors</a>()</code>,
<code><a href="#topic+imageDefault">imageDefault</a>()</code>,
<code><a href="#topic+minorLogTicksAxis">minorLogTicksAxis</a>()</code>,
<code><a href="#topic+nullPlot">nullPlot</a>()</code>,
<code><a href="#topic+plotPolygonDensity">plotPolygonDensity</a>()</code>,
<code><a href="#topic+plotRidges">plotRidges</a>()</code>,
<code><a href="#topic+plotSmoothScatter">plotSmoothScatter</a>()</code>,
<code><a href="#topic+shadowText">shadowText</a>()</code>,
<code><a href="#topic+shadowText_options">shadowText_options</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+usrBox">usrBox</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(-3:3*10, -3:3*10, xaxt="n")
x &lt;- sqrtAxis(1)
abline(v=x, col="grey", lty="dotted")
abline(h=pretty(par("usr")[3:4]), col="grey", lty="dotted")

# slightly different label placement with u5.bias=0
plot(-3:3*10, -3:3*10, xaxt="n")
x &lt;- sqrtAxis(1, u5.bias=0)
abline(v=x, col="grey", lty="dotted")
abline(h=pretty(par("usr")[3:4]), col="grey", lty="dotted")

</code></pre>

<hr>
<h2 id='tcount'>frequency of entries, ordered by frequency</h2><span id='topic+tcount'></span>

<h3>Description</h3>

<p>frequency of entries, ordered by frequency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcount(
  x,
  minCount = NULL,
  doSort = TRUE,
  maxCount = NULL,
  nameSortFunc = sort,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tcount_+3A_x">x</code></td>
<td>
<p><code>character</code>, <code>numeric</code>, <code>factor</code> vector input to use when
calculating frequencies.</p>
</td></tr>
<tr><td><code id="tcount_+3A_mincount">minCount</code></td>
<td>
<p>optional <code>integer</code> minimum frequency, any results with
fewer counts observed will be omitted from results.</p>
</td></tr>
<tr><td><code id="tcount_+3A_dosort">doSort</code></td>
<td>
<p><code>logical</code> whether to sort results decreasing by frequency.</p>
</td></tr>
<tr><td><code id="tcount_+3A_maxcount">maxCount</code></td>
<td>
<p>optional <code>integer</code> maximum frequency for returned results.</p>
</td></tr>
<tr><td><code id="tcount_+3A_namesortfunc">nameSortFunc</code></td>
<td>
<p><code>function</code> used to sort results after sorting by
frequency. For example, one might use <code>mixedSort()</code>. If
<code>nameSortFunc=NULL</code> then no name sort will be applied.</p>
</td></tr>
<tr><td><code id="tcount_+3A_...">...</code></td>
<td>
<p>additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function mimics output from <code>table()</code> with two key
differences. It sorts the results by decreasing frequency, and optionally
filters results for a minimum frequency. It is effective when checking
for duplicate values, and ordering them by the number of occurrences.
</p>
<p>This function is useful when working with large vectors of gene
identifiers, where it is not always obvious whether genes are replicated
in a particular technological assay. Transcript microarrays for example,
can contain many replicated genes, but often only a handful of genes are
highly replicated, while the rest are present only once or twice on the
array.
</p>


<h3>Value</h3>

<p><code>integer</code> vector of counts, named by the unique input
values in <code>x</code>.
</p>


<h3>See Also</h3>

<p>Other jam string functions: 
<code><a href="#topic+asSize">asSize</a>()</code>,
<code><a href="#topic+breaksByVector">breaksByVector</a>()</code>,
<code><a href="#topic+fillBlanks">fillBlanks</a>()</code>,
<code><a href="#topic+formatInt">formatInt</a>()</code>,
<code><a href="#topic+gsubOrdered">gsubOrdered</a>()</code>,
<code><a href="#topic+gsubs">gsubs</a>()</code>,
<code><a href="#topic+makeNames">makeNames</a>()</code>,
<code><a href="#topic+nameVector">nameVector</a>()</code>,
<code><a href="#topic+nameVectorN">nameVectorN</a>()</code>,
<code><a href="#topic+padInteger">padInteger</a>()</code>,
<code><a href="#topic+padString">padString</a>()</code>,
<code><a href="#topic+pasteByRow">pasteByRow</a>()</code>,
<code><a href="#topic+pasteByRowOrdered">pasteByRowOrdered</a>()</code>,
<code><a href="#topic+sizeAsNum">sizeAsNum</a>()</code>,
<code><a href="#topic+ucfirst">ucfirst</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testVector &lt;- rep(c("one", "two", "three", "four"), c(1:4));
tcount(testVector);
tcount(testVector, minCount=2);

</code></pre>

<hr>
<h2 id='ucfirst'>Uppercase the first letter in each word</h2><span id='topic+ucfirst'></span>

<h3>Description</h3>

<p>Uppercase the first letter in each word
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ucfirst(x, lowercaseAll = FALSE, firstWordOnly = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ucfirst_+3A_x">x</code></td>
<td>
<p>character vector.</p>
</td></tr>
<tr><td><code id="ucfirst_+3A_lowercaseall">lowercaseAll</code></td>
<td>
<p>logical indicating whether to force all letters
to lowercase before applying uppercase to the first letter.</p>
</td></tr>
<tr><td><code id="ucfirst_+3A_firstwordonly">firstWordOnly</code></td>
<td>
<p>logical indicating whether to apply the
uppercase only to the first word in each string. Note that it
still applies the logic to every entry in the input vector <code>x</code>.</p>
</td></tr>
<tr><td><code id="ucfirst_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a simple mimic of the Perl function <code>ucfirst</code> which
converts the first letter in each word to uppercase. When
<code>lowercaseAll=TRUE</code> it also forces all other letters to lowercase,
otherwise mixedCase words will retain capital letters in the middle
of words.
</p>


<h3>Value</h3>

<p><code>character</code> vector where letters are converted to uppercase.
</p>


<h3>See Also</h3>

<p>Other jam string functions: 
<code><a href="#topic+asSize">asSize</a>()</code>,
<code><a href="#topic+breaksByVector">breaksByVector</a>()</code>,
<code><a href="#topic+fillBlanks">fillBlanks</a>()</code>,
<code><a href="#topic+formatInt">formatInt</a>()</code>,
<code><a href="#topic+gsubOrdered">gsubOrdered</a>()</code>,
<code><a href="#topic+gsubs">gsubs</a>()</code>,
<code><a href="#topic+makeNames">makeNames</a>()</code>,
<code><a href="#topic+nameVector">nameVector</a>()</code>,
<code><a href="#topic+nameVectorN">nameVectorN</a>()</code>,
<code><a href="#topic+padInteger">padInteger</a>()</code>,
<code><a href="#topic+padString">padString</a>()</code>,
<code><a href="#topic+pasteByRow">pasteByRow</a>()</code>,
<code><a href="#topic+pasteByRowOrdered">pasteByRowOrdered</a>()</code>,
<code><a href="#topic+sizeAsNum">sizeAsNum</a>()</code>,
<code><a href="#topic+tcount">tcount</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ucfirst("TESTING_ALL_UPPERCASE_INPUT")
ucfirst("TESTING_ALL_UPPERCASE_INPUT", TRUE)
ucfirst("TESTING_ALL_UPPERCASE_INPUT", TRUE, TRUE)

ucfirst("testing mixedCase upperAndLower case input")
ucfirst("testing mixedCase upperAndLower case input", TRUE)
ucfirst("testing mixedCase upperAndLower case input", TRUE, TRUE)

</code></pre>

<hr>
<h2 id='unalpha'>Remove alpha transparency from colors</h2><span id='topic+unalpha'></span>

<h3>Description</h3>

<p>Remove alpha transparency from colors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unalpha(x, keepNA = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unalpha_+3A_x">x</code></td>
<td>
<p><code>character</code> vector of R colors</p>
</td></tr>
<tr><td><code id="unalpha_+3A_keepna">keepNA</code></td>
<td>
<p><code>logical</code> indicating whether <code>NA</code> values should be kept
and therefore returned as <code>NA</code>.
When <code>keepNA=FALSE</code> (default for backward compatibility) <code>NA</code>
values are converted to <code>"#FFFFFF"</code> as done by <code>grDevices::col2rgb()</code>.</p>
</td></tr>
<tr><td><code id="unalpha_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simply removes the alpha transparency from
R colors, returned in hex format, for example <code>"#FF0000FF"</code>
becomes <code>"#FF0000"</code>, or <code>"blue"</code> becomes <code>"#0000FF"</code>.
</p>
<p>It also silently converts R color names to hex format,
where applicable.
</p>


<h3>Value</h3>

<p>character vector of R colors in hex format.
</p>


<h3>See Also</h3>

<p>Other jam color functions: 
<code><a href="#topic+alpha2col">alpha2col</a>()</code>,
<code><a href="#topic+applyCLrange">applyCLrange</a>()</code>,
<code><a href="#topic+col2alpha">col2alpha</a>()</code>,
<code><a href="#topic+col2hcl">col2hcl</a>()</code>,
<code><a href="#topic+col2hsl">col2hsl</a>()</code>,
<code><a href="#topic+col2hsv">col2hsv</a>()</code>,
<code><a href="#topic+color2gradient">color2gradient</a>()</code>,
<code><a href="#topic+fixYellow">fixYellow</a>()</code>,
<code><a href="#topic+fixYellowHue">fixYellowHue</a>()</code>,
<code><a href="#topic+getColorRamp">getColorRamp</a>()</code>,
<code><a href="#topic+hcl2col">hcl2col</a>()</code>,
<code><a href="#topic+hsl2col">hsl2col</a>()</code>,
<code><a href="#topic+hsv2col">hsv2col</a>()</code>,
<code><a href="#topic+isColor">isColor</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+makeColorDarker">makeColorDarker</a>()</code>,
<code><a href="#topic+rainbow2">rainbow2</a>()</code>,
<code><a href="#topic+rgb2col">rgb2col</a>()</code>,
<code><a href="#topic+setCLranges">setCLranges</a>()</code>,
<code><a href="#topic+setTextContrastColor">setTextContrastColor</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+warpRamp">warpRamp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>unalpha(c("#FFFF00DD", "red", NA, "#0000FF", "transparent"))

unalpha(c("#FFFF00DD", "red", NA, "#0000FF", "transparent"), keepNA=TRUE)

</code></pre>

<hr>
<h2 id='unigrep'>case-insensitive grep, returning unmatched indices</h2><span id='topic+unigrep'></span>

<h3>Description</h3>

<p>case-insensitive grep, returning unmatched indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unigrep(..., ignore.case = TRUE, invert = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unigrep_+3A_...">...</code>, <code id="unigrep_+3A_ignore.case">ignore.case</code>, <code id="unigrep_+3A_invert">invert</code></td>
<td>
<p>parameters sent to <code>base::grep()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a simple wrapper around <code>base::grep()</code> which
runs in case-insensitive mode, and returns unmatched entries.
It is mainly used to save keystrokes,
but is consistently named alongside <code><a href="#topic+vgrep">vgrep</a></code> and
<code><a href="#topic+vigrep">vigrep</a></code>, and quite helpful for writing concise code.
</p>


<h3>Value</h3>

<p>vector of non-matching indices
</p>


<h3>See Also</h3>

<p>Other jam grep functions: 
<code><a href="#topic+grepls">grepls</a>()</code>,
<code><a href="#topic+igrep">igrep</a>()</code>,
<code><a href="#topic+igrepHas">igrepHas</a>()</code>,
<code><a href="#topic+igrepl">igrepl</a>()</code>,
<code><a href="#topic+provigrep">provigrep</a>()</code>,
<code><a href="#topic+unvigrep">unvigrep</a>()</code>,
<code><a href="#topic+vgrep">vgrep</a>()</code>,
<code><a href="#topic+vigrep">vigrep</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>V &lt;- paste0(LETTERS[1:5], LETTERS[4:8]);
unigrep("D", V);
igrep("D", V);

</code></pre>

<hr>
<h2 id='uniques'>apply unique to each element of a list</h2><span id='topic+uniques'></span>

<h3>Description</h3>

<p>Apply unique to each element of a list, usually a list of vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniques(
  x,
  keepNames = TRUE,
  incomparables = FALSE,
  useBioc = TRUE,
  useSimpleBioc = FALSE,
  xclass = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uniques_+3A_x">x</code></td>
<td>
<p>input list of vectors</p>
</td></tr>
<tr><td><code id="uniques_+3A_keepnames">keepNames</code></td>
<td>
<p>boolean indicating whether to keep the list element
names in the returned results.</p>
</td></tr>
<tr><td><code id="uniques_+3A_incomparables">incomparables</code></td>
<td>
<p>see <code><a href="base.html#topic+unique">unique()</a></code> for details, this value is only
sent to <code>S4Vectors::unique()</code> when the Bioconductor package
<code>S4Vectors</code> is installed, and is ignored otherwise for efficiency.</p>
</td></tr>
<tr><td><code id="uniques_+3A_usebioc">useBioc</code></td>
<td>
<p><code>logical</code>, default TRUE,  indicating whether this
function should try to use <code>S4Vectors::unique()</code> when the
Bioconductor package <code>S4Vectors</code> is installed, otherwise it will
use a somewhat less efficient bulk operation.</p>
</td></tr>
<tr><td><code id="uniques_+3A_usesimplebioc">useSimpleBioc</code></td>
<td>
<p><code>logical</code>, default FALSE, whether to use a legacy
mechanism with <code>S4Vectors</code> and is maintained for edge cases where
it might be faster.</p>
</td></tr>
<tr><td><code id="uniques_+3A_xclass">xclass</code></td>
<td>
<p><code>character</code> optional vector of classes, used to invoke
optimized logic when the class is known upfront.</p>
</td></tr>
<tr><td><code id="uniques_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will attempt to use <code>S4Vectors::unique()</code> which is
substantially faster than any <code>apply</code> family function, especially
for very long lists. However, when <code>S4Vectors</code> is not installed,
it applies uniqueness to the <code>unlist</code>ed vector of values, which is
also substantially faster than the <code>apply</code> family functions for
long lists, but which may still be less efficient than the
C implementation provided by <code>S4Vectors</code>.
</p>


<h3>Value</h3>

<p><code>list</code> with unique values in each list element.
</p>


<h3>See Also</h3>

<p>Other jam list functions: 
<code><a href="#topic+cPaste">cPaste</a>()</code>,
<code><a href="#topic+heads">heads</a>()</code>,
<code><a href="#topic+jam_rapply">jam_rapply</a>()</code>,
<code><a href="#topic+list2df">list2df</a>()</code>,
<code><a href="#topic+mergeAllXY">mergeAllXY</a>()</code>,
<code><a href="#topic+mixedSorts">mixedSorts</a>()</code>,
<code><a href="#topic+rbindList">rbindList</a>()</code>,
<code><a href="#topic+relist_named">relist_named</a>()</code>,
<code><a href="#topic+rlengths">rlengths</a>()</code>,
<code><a href="#topic+sclass">sclass</a>()</code>,
<code><a href="#topic+sdim">sdim</a>()</code>,
<code><a href="#topic+unnestList">unnestList</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L1 &lt;- list(CA=nameVector(LETTERS[c(1:4,2,7,4,6)]),
   B=letters[c(7:11,9,3)],
   C2=NULL,
   D=nameVector(LETTERS[4]));
L1;
uniques(L1);

uniques(L1, useBioc=FALSE);

</code></pre>

<hr>
<h2 id='unnestList'>Un-nest a nested list into a simple list</h2><span id='topic+unnestList'></span>

<h3>Description</h3>

<p>Un-nest a nested list into a simple list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unnestList(
  x,
  addNames = FALSE,
  unnamedBase = "x",
  parentName = NULL,
  sep = ".",
  makeNamesFunc = makeNames,
  stopClasses = c("dendrogram", "data.frame", "matrix", "package_version", "tbl",
    "data.table"),
  extraStopClasses = getOption("jam.stopClasses"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unnestList_+3A_x">x</code></td>
<td>
<p><code>list</code> potentially containing nested lists.</p>
</td></tr>
<tr><td><code id="unnestList_+3A_addnames">addNames</code></td>
<td>
<p><code>logical</code> indicating whether to add names to
the list elements when names are not already present. When
<code>addNames=TRUE</code> and no names are present <code>unnamedBase</code> is
used to define names.</p>
</td></tr>
<tr><td><code id="unnestList_+3A_unnamedbase">unnamedBase</code></td>
<td>
<p><code>character</code> value used as a base for naming any
un-named lists, using the format <code>makeNamesFunc(rep(unnamedBase, n))</code>.</p>
</td></tr>
<tr><td><code id="unnestList_+3A_parentname">parentName</code></td>
<td>
<p><code>character</code> with optional prefix, used as parent name,
default is NULL.</p>
</td></tr>
<tr><td><code id="unnestList_+3A_sep">sep</code></td>
<td>
<p><code>character</code> delimiter used between nested list names.</p>
</td></tr>
<tr><td><code id="unnestList_+3A_makenamesfunc">makeNamesFunc</code></td>
<td>
<p><code>function</code> that takes a character vector and returns
non-duplicated character vector of equal length. By default it
uses <code>jamba::makeNames()</code>.</p>
</td></tr>
<tr><td><code id="unnestList_+3A_stopclasses">stopClasses</code></td>
<td>
<p><code>vector</code> of classes that should not be un-nested,
useful in case some classes inherit list properties.</p>
</td></tr>
<tr><td><code id="unnestList_+3A_extrastopclasses">extraStopClasses</code></td>
<td>
<p><code>vector</code> of additional values for <code>stopClasses</code>,
created mostly to show that <code>options("jam.stopClasses")</code> can be
used to define <code>stopClasses</code>, for example when this function
is called but where arguments cannot be conveniently passed
through the calling function.</p>
</td></tr>
<tr><td><code id="unnestList_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function inspects a list, and unlists each entry
resulting in a simple list of non-list entries as a result.
Sometimes when concatenating lists together, one list gets
added as a list-of-lists. This function resolves that problem
by providing one flat list.
</p>


<h3>Value</h3>

<p><code>list</code> that has been flattened so that it contains
no <code>list</code> elements. Note that it may contain some list-like
objects such as <code>data.frame</code>, defined by <code>stopClasses</code>.
</p>


<h3>See Also</h3>

<p>Other jam list functions: 
<code><a href="#topic+cPaste">cPaste</a>()</code>,
<code><a href="#topic+heads">heads</a>()</code>,
<code><a href="#topic+jam_rapply">jam_rapply</a>()</code>,
<code><a href="#topic+list2df">list2df</a>()</code>,
<code><a href="#topic+mergeAllXY">mergeAllXY</a>()</code>,
<code><a href="#topic+mixedSorts">mixedSorts</a>()</code>,
<code><a href="#topic+rbindList">rbindList</a>()</code>,
<code><a href="#topic+relist_named">relist_named</a>()</code>,
<code><a href="#topic+rlengths">rlengths</a>()</code>,
<code><a href="#topic+sclass">sclass</a>()</code>,
<code><a href="#topic+sdim">sdim</a>()</code>,
<code><a href="#topic+uniques">uniques</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L &lt;- list(A=letters[1:10],
   B=list(C=LETTERS[3:9], D=letters[4:11]),
   E=list(F=list(G=LETTERS[3:9], D=letters[4:11])));
L;

# inspect the data using str()
str(L);

unnestList(L);

# optionally change the delimiter
unnestList(L, sep="|");

# example with nested lists of data.frame objects
df1 &lt;- data.frame(a=1:2, b=letters[3:4]);
DFL &lt;- list(A=df1,
   B=list(C=df1, D=df1),
   E=list(F=list(G=df1, D=df1)));
str(DFL);
unnestList(DFL);
str(unnestList(DFL));

# packageVersion() returns class "package_version"
# where is.list(packageVersion("base")) is TRUE,
# but it cannot ever be subsetted as a list with x[[1]],
# and thus it breaks this function
identical(is.list(packageVersion("base")), is.list(packageVersion("base"))[[1]])
unnestList(lapply(nameVector(c("base","graphics")), packageVersion))

</code></pre>

<hr>
<h2 id='unvigrep'>case-insensitive grep, returning unmatched values</h2><span id='topic+unvigrep'></span>

<h3>Description</h3>

<p>case-insensitive grep, returning unmatched values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unvigrep(..., ignore.case = TRUE, value = TRUE, invert = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unvigrep_+3A_...">...</code>, <code id="unvigrep_+3A_ignore.case">ignore.case</code>, <code id="unvigrep_+3A_value">value</code>, <code id="unvigrep_+3A_invert">invert</code></td>
<td>
<p>parameters sent to <code>base::grep()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a simple wrapper around <code>base::grep()</code> which
runs in case-insensitive mode, and returns unmatched values.
It is mainly used to save keystrokes,
but is consistently named alongside <code><a href="#topic+vgrep">vgrep</a></code> and
<code><a href="#topic+vigrep">vigrep</a></code>, and quite helpful for writing concise code.
It is particularly useful for removing unwanted entries from a long
vector, for example removing accession numbers from a long
vector of gene symbols in order to review gene annotations.
</p>


<h3>Value</h3>

<p>vector of non-matching indices
</p>


<h3>See Also</h3>

<p>Other jam grep functions: 
<code><a href="#topic+grepls">grepls</a>()</code>,
<code><a href="#topic+igrep">igrep</a>()</code>,
<code><a href="#topic+igrepHas">igrepHas</a>()</code>,
<code><a href="#topic+igrepl">igrepl</a>()</code>,
<code><a href="#topic+provigrep">provigrep</a>()</code>,
<code><a href="#topic+unigrep">unigrep</a>()</code>,
<code><a href="#topic+vgrep">vgrep</a>()</code>,
<code><a href="#topic+vigrep">vigrep</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>V &lt;- paste0(LETTERS[1:5], LETTERS[4:8]);
unigrep("D", V);
igrep("D", V);

</code></pre>

<hr>
<h2 id='usrBox'>Draw colored box indicating R plot space</h2><span id='topic+usrBox'></span>

<h3>Description</h3>

<p>Draw colored box indicating the active R plot space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>usrBox(
  fill = "#FFFF9966",
  label = NULL,
  parUsr = graphics::par("usr"),
  debug = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="usrBox_+3A_fill">fill</code></td>
<td>
<p><code>character</code> R color used to fill the background of the plot</p>
</td></tr>
<tr><td><code id="usrBox_+3A_label">label</code></td>
<td>
<p><code>character</code> text optionally used to label the center of the
plot space, default <code>NULL</code></p>
</td></tr>
<tr><td><code id="usrBox_+3A_parusr">parUsr</code></td>
<td>
<p><code>numeric</code> vector length 4, indicating the R plot space,
consistent with <code>graphics::par("usr")</code>. It can thus be used to define a
different area, though using the <code><a href="graphics.html#topic+rect">rect</a></code> function
directly seems more appropriate.</p>
</td></tr>
<tr><td><code id="usrBox_+3A_debug">debug</code></td>
<td>
<p><code>logical</code> whether to print the parUsr value being used.</p>
</td></tr>
<tr><td><code id="usrBox_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simply draws a box indicating the active plot space,
and by default it shades the box light yellow with transparency. It
can be useful to indicate the active plot area while allowing pre-drawn
plot elements to be shown, or can be useful precursor to provide a colored
background for the plot.
</p>
<p>The plot space is defined using <code>graphics::par("usr")</code> and therefore requires
an active R device is already opened.
</p>


<h3>Value</h3>

<p>no output, this function is called for the byproduct
of adding a box in the usr plot space of an R graphics device.
</p>


<h3>See Also</h3>

<p>Other jam plot functions: 
<code><a href="#topic+adjustAxisLabelMargins">adjustAxisLabelMargins</a>()</code>,
<code><a href="#topic+coordPresets">coordPresets</a>()</code>,
<code><a href="#topic+decideMfrow">decideMfrow</a>()</code>,
<code><a href="#topic+drawLabels">drawLabels</a>()</code>,
<code><a href="#topic+getPlotAspect">getPlotAspect</a>()</code>,
<code><a href="#topic+groupedAxis">groupedAxis</a>()</code>,
<code><a href="#topic+imageByColors">imageByColors</a>()</code>,
<code><a href="#topic+imageDefault">imageDefault</a>()</code>,
<code><a href="#topic+minorLogTicksAxis">minorLogTicksAxis</a>()</code>,
<code><a href="#topic+nullPlot">nullPlot</a>()</code>,
<code><a href="#topic+plotPolygonDensity">plotPolygonDensity</a>()</code>,
<code><a href="#topic+plotRidges">plotRidges</a>()</code>,
<code><a href="#topic+plotSmoothScatter">plotSmoothScatter</a>()</code>,
<code><a href="#topic+shadowText">shadowText</a>()</code>,
<code><a href="#topic+shadowText_options">shadowText_options</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+sqrtAxis">sqrtAxis</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># usrBox() requires that a plot device is already open
nullPlot(doBoxes=FALSE);
usrBox();

</code></pre>

<hr>
<h2 id='vgrep'>grep, returning values</h2><span id='topic+vgrep'></span>

<h3>Description</h3>

<p>grep, returning values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vgrep(..., value = TRUE, ignore.case = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vgrep_+3A_...">...</code>, <code id="vgrep_+3A_value">value</code>, <code id="vgrep_+3A_ignore.case">ignore.case</code></td>
<td>
<p>parameters sent to <code>base::grep()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a simple wrapper around <code>base::grep()</code> which
returns matching values. It is
particularly helpful when grabbing values from a vector, but where the
case (uppercase or lowercase) is known.
</p>


<h3>Value</h3>

<p>vector of matching values
</p>


<h3>See Also</h3>

<p>Other jam grep functions: 
<code><a href="#topic+grepls">grepls</a>()</code>,
<code><a href="#topic+igrep">igrep</a>()</code>,
<code><a href="#topic+igrepHas">igrepHas</a>()</code>,
<code><a href="#topic+igrepl">igrepl</a>()</code>,
<code><a href="#topic+provigrep">provigrep</a>()</code>,
<code><a href="#topic+unigrep">unigrep</a>()</code>,
<code><a href="#topic+unvigrep">unvigrep</a>()</code>,
<code><a href="#topic+vigrep">vigrep</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>V &lt;- paste0(LETTERS[1:5], LETTERS[4:8]);
vgrep("D", V);
vgrep("d", V);
vigrep("d", V);

</code></pre>

<hr>
<h2 id='vigrep'>case-insensitive grep, returning values</h2><span id='topic+vigrep'></span>

<h3>Description</h3>

<p>case-insensitive grep, returning values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vigrep(..., value = TRUE, ignore.case = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vigrep_+3A_...">...</code>, <code id="vigrep_+3A_value">value</code>, <code id="vigrep_+3A_ignore.case">ignore.case</code></td>
<td>
<p>parameters sent to <code>base::grep()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a simple wrapper around <code>base::grep()</code> which
runs in case-insensitive mode, and returns matching values. It is
particularly helpful when grabbing values from a vector.
</p>


<h3>Value</h3>

<p>vector of matching values
</p>


<h3>See Also</h3>

<p>Other jam grep functions: 
<code><a href="#topic+grepls">grepls</a>()</code>,
<code><a href="#topic+igrep">igrep</a>()</code>,
<code><a href="#topic+igrepHas">igrepHas</a>()</code>,
<code><a href="#topic+igrepl">igrepl</a>()</code>,
<code><a href="#topic+provigrep">provigrep</a>()</code>,
<code><a href="#topic+unigrep">unigrep</a>()</code>,
<code><a href="#topic+unvigrep">unvigrep</a>()</code>,
<code><a href="#topic+vgrep">vgrep</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>V &lt;- paste0(LETTERS[1:5], LETTERS[4:8]);
vigrep("d", V);

</code></pre>

<hr>
<h2 id='warpAroundZero'>Warp a vector of numeric values relative to zero</h2><span id='topic+warpAroundZero'></span>

<h3>Description</h3>

<p>Warp a vector of numeric values relative to zero
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warpAroundZero(x, lens = 5, baseline = 0, xCeiling = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="warpAroundZero_+3A_x">x</code></td>
<td>
<p><code>numeric</code> vector</p>
</td></tr>
<tr><td><code id="warpAroundZero_+3A_lens">lens</code></td>
<td>
<p><code>numeric</code> value which defines the lens factor,
where <code>lens &gt; 0</code> will compress values near zero, and
<code>lens &lt; 0</code> will expand values near zero and compress
values near the maximum value. If <code>lens == 0</code> the
numeric values are not changed.</p>
</td></tr>
<tr><td><code id="warpAroundZero_+3A_baseline">baseline</code></td>
<td>
<p><code>numeric</code> value describing the baseline, for example
when the central value is non-zero. The baseline is subtracted
from <code>x</code>, the warp is applied, then the baseline is added to
the result.</p>
</td></tr>
<tr><td><code id="warpAroundZero_+3A_xceiling">xCeiling</code></td>
<td>
<p><code>numeric</code> maximum value used for the color warp range,
useful for consistency. When <code>xCeiling</code> is not supplied, the
maximum difference from <code>baseline</code> is used. When <code>xCeiling</code> is
defined, and <code>baseline</code> is non-zero, the effective value used
is <code>(xCeiling - baseline)</code>.</p>
</td></tr>
<tr><td><code id="warpAroundZero_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function warps numeric values using a log curve
transformation, such that values are either more compressed
near zero, or more compressed near the maximum values.
For example, a vector of integers from -10 to 10 would be warped
so the intervals near zero were smaller than 1, and intervals
farthest from zero are greater than 1.
</p>
<p>The main driver for this function was the desire to compress
divergent color scales used in heatmaps, in order to enhance
smaller magnitude numeric values. Existing color ramps map the
color gradient in a linear manner relative to the numeric range,
which can cause extreme values to dominate the color scale.
Further, a linear application of colors is not always appropriate.
</p>


<h3>Value</h3>

<p><code>numeric</code> vector after applying the warp function.
</p>


<h3>See Also</h3>

<p>Other jam numeric functions: 
<code><a href="#topic+deg2rad">deg2rad</a>()</code>,
<code><a href="#topic+noiseFloor">noiseFloor</a>()</code>,
<code><a href="#topic+normScale">normScale</a>()</code>,
<code><a href="#topic+rad2deg">rad2deg</a>()</code>,
<code><a href="#topic+rowGroupMeans">rowGroupMeans</a>()</code>,
<code><a href="#topic+rowRmMadOutliers">rowRmMadOutliers</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(-10:10);
xPlus10 &lt;- warpAroundZero(x, lens=10);
xMinus10 &lt;- warpAroundZero(x, lens=-10);

plot(x=x, y=xPlus10, type="b", pch=20, col="dodgerblue",
   main="Comparison of lens=+10 to lens=-10");
graphics::points(x=x, y=xMinus10, type="b", pch=18, col="orangered");
graphics::abline(h=0, v=0, col="grey", lty="dashed", a=0, b=1);
graphics::legend("topleft",
   legend=c("lens=+10", "lens=-10"),
   col=c("dodgerblue","orangered"),
   pch=c(20,18),
   lty="solid",
   bg="white");

# example showing the effect of a baseline=5
xPlus10b5 &lt;- warpAroundZero(x, lens=10, baseline=5);
xMinus10b5 &lt;- warpAroundZero(x, lens=-10, baseline=5);
plot(x=x, y=xPlus10b5, type="b", pch=20, col="dodgerblue",
   main="Comparison of lens=+10 to lens=-10",
   ylim=c(-10,15),
   sub="baseline=+5");
graphics::points(x=x, y=xMinus10b5, type="b", pch=18, col="orangered");
graphics::abline(h=5, v=5, col="grey", lty="dashed", a=0, b=1);
graphics::legend("topleft",
   legend=c("lens=+10", "lens=-10"),
   col=c("dodgerblue","orangered"),
   pch=c(20,18),
   lty="solid",
   bg="white");

</code></pre>

<hr>
<h2 id='warpRamp'>Warp colors in a color ramp</h2><span id='topic+warpRamp'></span>

<h3>Description</h3>

<p>Warp colors in a color ramp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warpRamp(
  ramp,
  lens = 5,
  divergent = TRUE,
  expandFactor = 10,
  plot = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="warpRamp_+3A_ramp">ramp</code></td>
<td>
<p>character vector of R colors</p>
</td></tr>
<tr><td><code id="warpRamp_+3A_lens">lens</code></td>
<td>
<p>numeric lens factor, centered at zero, where positive
values cause colors to change more rapidly near zero, and
negative values cause colors to change less rapidly near zero
and more rapidly near the extreme.</p>
</td></tr>
<tr><td><code id="warpRamp_+3A_divergent">divergent</code></td>
<td>
<p>logical indicating whether the <code>ramp</code> represents
divergent colors, which are assumed to be symmetric above and
below zero. Otherwise, colors are assumed to begin at zero.</p>
</td></tr>
<tr><td><code id="warpRamp_+3A_expandfactor">expandFactor</code></td>
<td>
<p>numeric factor used to expand the color ramp
prior to selecting the nearest warped numeric value as the
result of <code>warpAroundZero()</code>. This value should not
need to be changed unless the lens is extremely high (&gt;100).</p>
</td></tr>
<tr><td><code id="warpRamp_+3A_plot">plot</code></td>
<td>
<p>logical indicating whether to plot the input and
output color ramps using <code>showColors()</code>.</p>
</td></tr>
<tr><td><code id="warpRamp_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating whether to print verbose output.</p>
</td></tr>
<tr><td><code id="warpRamp_+3A_...">...</code></td>
<td>
<p>additional parameters are passed to <code>showColors()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a vector of colors in a color ramp (color gradient)
and warps the gradient using a lens factor. The effect causes the
color gradient to change faster or slower, dependent upon the lens
factor.
</p>
<p>The main intent is for heatmap color ramps, where the color gradient
changes are not consistent with meaningful numeric differences
being shown in the heatmap. In short, this function enhances
colors.
</p>


<h3>Value</h3>

<p><code>character</code> vector of R colors, with the same length as the
input vector <code>ramp</code>.
</p>


<h3>See Also</h3>

<p>Other jam color functions: 
<code><a href="#topic+alpha2col">alpha2col</a>()</code>,
<code><a href="#topic+applyCLrange">applyCLrange</a>()</code>,
<code><a href="#topic+col2alpha">col2alpha</a>()</code>,
<code><a href="#topic+col2hcl">col2hcl</a>()</code>,
<code><a href="#topic+col2hsl">col2hsl</a>()</code>,
<code><a href="#topic+col2hsv">col2hsv</a>()</code>,
<code><a href="#topic+color2gradient">color2gradient</a>()</code>,
<code><a href="#topic+fixYellow">fixYellow</a>()</code>,
<code><a href="#topic+fixYellowHue">fixYellowHue</a>()</code>,
<code><a href="#topic+getColorRamp">getColorRamp</a>()</code>,
<code><a href="#topic+hcl2col">hcl2col</a>()</code>,
<code><a href="#topic+hsl2col">hsl2col</a>()</code>,
<code><a href="#topic+hsv2col">hsv2col</a>()</code>,
<code><a href="#topic+isColor">isColor</a>()</code>,
<code><a href="#topic+kable_coloring">kable_coloring</a>()</code>,
<code><a href="#topic+makeColorDarker">makeColorDarker</a>()</code>,
<code><a href="#topic+rainbow2">rainbow2</a>()</code>,
<code><a href="#topic+rgb2col">rgb2col</a>()</code>,
<code><a href="#topic+setCLranges">setCLranges</a>()</code>,
<code><a href="#topic+setTextContrastColor">setTextContrastColor</a>()</code>,
<code><a href="#topic+showColors">showColors</a>()</code>,
<code><a href="#topic+unalpha">unalpha</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BuRd &lt;- rev(RColorBrewer::brewer.pal(11, "RdBu"));
BuRdPlus5 &lt;- warpRamp(BuRd, lens=2, plot=TRUE);
BuRdMinus5 &lt;- warpRamp(BuRd, lens=-2, plot=TRUE);

Reds &lt;- RColorBrewer::brewer.pal(9, "Reds");
RedsL &lt;- lapply(nameVector(c(-10,-5,-2,0,2,5,10)), function(lens){
   warpRamp(Reds, lens=lens, divergent=FALSE)
});
showColors(RedsL);

</code></pre>

<hr>
<h2 id='writeOpenxlsx'>Export a data.frame to 'Excel' 'xlsx' format</h2><span id='topic+writeOpenxlsx'></span>

<h3>Description</h3>

<p>Export a data.frame to 'Excel' 'xlsx' format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeOpenxlsx(
  x,
  file = NULL,
  wb = NULL,
  sheetName = "Sheet1",
  startRow = 1,
  startCol = 1,
  append = FALSE,
  headerColors = c("lightskyblue1", "lightskyblue2"),
  columnColors = c("aliceblue", "azure2"),
  highlightHeaderColors = c("tan1", "tan2"),
  highlightColors = c("moccasin", "navajowhite"),
  borderColor = "gray75",
  borderPosition = "BottomRight",
  highlightColumns = NULL,
  numColumns = NULL,
  fcColumns = NULL,
  lfcColumns = NULL,
  hitColumns = NULL,
  intColumns = NULL,
  pvalueColumns = NULL,
  numFormat = "#,##0.00",
  fcFormat = "#,##0.0",
  lfcFormat = "#,##0.0",
  hitFormat = "#,##0.0",
  intFormat = "#,##0",
  pvalueFormat = "[&gt;0.01]0.00#;0.00E+00",
  numRule = c(1, 10, 20),
  fcRule = c(-6, 0, 6),
  lfcRule = c(-3, 0, 3),
  hitRule = c(-1.5, 0, 1.5),
  intRule = c(0, 100, 10000),
  pvalueRule = c(0, 0.01, 0.05),
  numStyle = c("#F2F0F7", "#B4B1D4", "#938EC2"),
  fcStyle = c("#4F81BD", "#EEECE1", "#C0504D"),
  lfcStyle = c("#4F81BD", "#EEECE1", "#C0504D"),
  hitStyle = c("#4F81BD", "#EEECE1", "#C0504D"),
  intStyle = c("#EEECE1", "#FDA560", "#F77F30"),
  pvalueStyle = c("#F77F30", "#FDC99B", "#EEECE1"),
  doConditional = TRUE,
  doCategorical = TRUE,
  colorSub = NULL,
  freezePaneColumn = 0,
  freezePaneRow = 2,
  doFilter = TRUE,
  fontName = "Arial",
  fontSize = 12,
  minWidth = getOption("openxlsx.minWidth", 8),
  maxWidth = getOption("openxlsx.maxWidth", 40),
  autoWidth = TRUE,
  colWidths = NULL,
  wrapCells = FALSE,
  wrapHeaders = TRUE,
  headerRowMultiplier = 5,
  keepRownames = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeOpenxlsx_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> to be saved to an 'Excel' 'xlsx' file.</p>
</td></tr>
<tr><td><code id="writeOpenxlsx_+3A_file">file</code></td>
<td>
<p><code>character</code> valid path to save an 'Excel' 'xlsx' file. If the file
exists, and <code>append=TRUE</code> the new data will be added to the existing
file withthe defined <code>sheetName</code>.
</p>

<ul>
<li><p> Note when <code>file=NULL</code> the output is not saved to a file,
instead the <code>Workbook</code> object is returned by this function.
The <code>Workbook</code> object can be passed as argument <code>wb</code> in order
to add multiple sheets to the same Workbook prior to saving
them together. This operation is intended to provide a
substantial improvement in speed.
</p>
</li></ul>
</td></tr>
<tr><td><code id="writeOpenxlsx_+3A_wb">wb</code></td>
<td>
<p><code>Workbook</code> object as defined in R package <code>openxlsx</code>.
When this argument is defined, data is not imported from <code>file</code>,
and instead the workbook data is used from <code>wb</code>. This option is
intended to improve speed of writing several sheets to the same
output file, by preventing the slow read/write steps each time
a new sheet is added.</p>
</td></tr>
<tr><td><code id="writeOpenxlsx_+3A_sheetname">sheetName</code></td>
<td>
<p><code>character</code> value less with a valid
'Excel' 'xlsx' worksheet name. At this time (version 0.0.29.900) the
sheetName is restricted to 31 characters, with no puntuation except
&quot;-&quot; and &quot;_&quot;.</p>
</td></tr>
<tr><td><code id="writeOpenxlsx_+3A_startrow">startRow</code>, <code id="writeOpenxlsx_+3A_startcol">startCol</code></td>
<td>
<p><code>integer</code> indicating the row and column number
to start with the top,left cell written to the worksheet,
default are 1.</p>
</td></tr>
<tr><td><code id="writeOpenxlsx_+3A_append">append</code></td>
<td>
<p><code>logical</code> default FALSE, whether to append to file (TRUE),
or to write over an existing file. The <code>append=TRUE</code> is useful when
adding a worksheet to an existing file.</p>
</td></tr>
<tr><td><code id="writeOpenxlsx_+3A_headercolors">headerColors</code>, <code id="writeOpenxlsx_+3A_columncolors">columnColors</code>, <code id="writeOpenxlsx_+3A_highlightheadercolors">highlightHeaderColors</code>, <code id="writeOpenxlsx_+3A_highlightcolors">highlightColors</code>, <code id="writeOpenxlsx_+3A_bordercolor">borderColor</code>, <code id="writeOpenxlsx_+3A_borderposition">borderPosition</code></td>
<td>
<p>default values for the 'Excel' worksheet background and border
colors. As of version 0.0.29.900, colors must use valid 'Excel'
color names.</p>
</td></tr>
<tr><td><code id="writeOpenxlsx_+3A_highlightcolumns">highlightColumns</code>, <code id="writeOpenxlsx_+3A_numcolumns">numColumns</code>, <code id="writeOpenxlsx_+3A_fccolumns">fcColumns</code>, <code id="writeOpenxlsx_+3A_lfccolumns">lfcColumns</code>, <code id="writeOpenxlsx_+3A_hitcolumns">hitColumns</code>, <code id="writeOpenxlsx_+3A_intcolumns">intColumns</code>, <code id="writeOpenxlsx_+3A_pvaluecolumns">pvalueColumns</code></td>
<td>
<p><code>integer</code> vector referring the column number in the input <code>data.frame</code>
<code>x</code> to define as each column type, as relevant.</p>
</td></tr>
<tr><td><code id="writeOpenxlsx_+3A_numformat">numFormat</code>, <code id="writeOpenxlsx_+3A_fcformat">fcFormat</code>, <code id="writeOpenxlsx_+3A_lfcformat">lfcFormat</code>, <code id="writeOpenxlsx_+3A_hitformat">hitFormat</code>, <code id="writeOpenxlsx_+3A_intformat">intFormat</code>, <code id="writeOpenxlsx_+3A_pvalueformat">pvalueFormat</code></td>
<td>
<p><code>character</code> string with valid 'Excel' cell formatting, for example
<code>"#,##0.00"</code> defines a column to use comma-delimited numbers above
one thousand, and display two decimal places in all numeric cells.
See <code style="white-space: pre;">&#8288;[https://support.microsoft.com]&#8288;</code> topic
<code>"Excel Create and apply a custom number format."</code> or
<code>"Excel Number format codes"</code> for more details. Some examples below:
</p>

<ul>
<li> <p><code>"#,##0"</code> : display only integer values, using comma as delimiter
for every thousands place.
The number <code>2142.12</code> would be represented: <code>"2,142"</code>
</p>
</li>
<li> <p><code>"###0.0"</code> : display numeric values rounded to the <code>0.1</code> place,
using no comma delimiter for values above one thousand.
The number <code>2142.12</code> would be represented: <code>"2142.1"</code>
</p>
</li>
<li> <p><code>"[&gt;0.01]0.00#;0.00E+00"</code> : this rule is a conditional format,
values above <code>0.01</code> are represented as numbers rounded to the
thousandths position <code>0.001</code>; values below <code>0.01</code> are represented
with scientific notation with three digits.
The number <code>0.1256</code> would be represented: <code>"0.126"</code>
The number <code>0.001256</code> would be represented: <code>"1.26E-03"</code>
</p>
</li>
<li> <p><code>"[Red]#,###.00_);[Blue](#,###.00);[Black]0.00_)"</code> : this format applies
to positive values, negative values, and zero, in order delimited
by semicolons. Positive values are colored red.
The string <code>"_)"</code> adds whitespace (defined by <code>"_"</code>)
equale to the width of the character <code>")"</code> to the end
of positive values.
Negative values are surrounded by parentheses <code>"()"</code>
and are colored blue.
Values equal to zero are represented with two trailing digits,
and whitespace (<code>"_"</code>) equal to width <code>")"</code>.
The whitespace at the end of positive values and zero are used
to align all values at the same decimal position.
</p>
</li></ul>
</td></tr>
<tr><td><code id="writeOpenxlsx_+3A_numrule">numRule</code>, <code id="writeOpenxlsx_+3A_fcrule">fcRule</code>, <code id="writeOpenxlsx_+3A_lfcrule">lfcRule</code>, <code id="writeOpenxlsx_+3A_hitrule">hitRule</code>, <code id="writeOpenxlsx_+3A_intrule">intRule</code>, <code id="writeOpenxlsx_+3A_pvaluerule">pvalueRule</code></td>
<td>
<p><code>numeric</code> vector
<code>length=3</code> indicating the breakpoints for 'Excel' to apply conditional
color formatting, using the corresponding style.
Note that all conditional formatting applied by this function uses
the <code>"3-Color Scale"</code>, therefore there should be three values,
and three corresponding colors in the corresponding Style arguments.</p>
</td></tr>
<tr><td><code id="writeOpenxlsx_+3A_numstyle">numStyle</code>, <code id="writeOpenxlsx_+3A_fcstyle">fcStyle</code>, <code id="writeOpenxlsx_+3A_lfcstyle">lfcStyle</code>, <code id="writeOpenxlsx_+3A_intstyle">intStyle</code>, <code id="writeOpenxlsx_+3A_hitstyle">hitStyle</code>, <code id="writeOpenxlsx_+3A_pvaluestyle">pvalueStyle</code></td>
<td>
<p><code>character</code>
vector <code>length=3</code> containing three valid R colors. Note that alpha
transparency will be removed prior to use in 'Excel', as required.
Note that all conditional formatting applied by this function uses
the <code>"3-Color Scale"</code>, therefore there should be three colors,
which match three values in the corresponding Rule arguments.</p>
</td></tr>
<tr><td><code id="writeOpenxlsx_+3A_doconditional">doConditional</code></td>
<td>
<p><code>logical</code> indicating whether to apply conditional
formatting of cells, with this function only the background cell
color (and contrasting text color) is affected.</p>
</td></tr>
<tr><td><code id="writeOpenxlsx_+3A_docategorical">doCategorical</code></td>
<td>
<p><code>logical</code> indicating whether to apply categorical
color formatting, of only the background cell colors and contrasting
text color. This argument requires <code>colorSub</code> be defined.</p>
</td></tr>
<tr><td><code id="writeOpenxlsx_+3A_colorsub">colorSub</code></td>
<td>
<p><code>character</code> vector of R colors, whose names refer to
cell values in the input <code>x</code> data.frame.</p>
</td></tr>
<tr><td><code id="writeOpenxlsx_+3A_freezepanecolumn">freezePaneColumn</code>, <code id="writeOpenxlsx_+3A_freezepanerow">freezePaneRow</code></td>
<td>
<p><code>integer</code> value of the row or
column before which the 'Excel' &quot;freeze panes&quot; is applied.
Note that these values are adjusted relative by <code>startRow</code> and
<code>startCol</code> in the 'Excel' worksheet, so that the values are applied
relative to the <code>data.frame</code> argument <code>x</code>.</p>
</td></tr>
<tr><td><code id="writeOpenxlsx_+3A_dofilter">doFilter</code></td>
<td>
<p><code>logical</code> indicating whether to enable column
filtering by default.</p>
</td></tr>
<tr><td><code id="writeOpenxlsx_+3A_fontname">fontName</code></td>
<td>
<p><code>character</code> default font configuration, containing
a valid 'Excel' font name.</p>
</td></tr>
<tr><td><code id="writeOpenxlsx_+3A_fontsize">fontSize</code></td>
<td>
<p><code>numeric</code> default font size in 'Excel' point units.</p>
</td></tr>
<tr><td><code id="writeOpenxlsx_+3A_minwidth">minWidth</code>, <code id="writeOpenxlsx_+3A_maxwidth">maxWidth</code>, <code id="writeOpenxlsx_+3A_autowidth">autoWidth</code></td>
<td>
<p><code>numeric</code> minimum, maximum size
for each 'Excel' cell, in character units as defined by 'Excel',
used when <code>autoWidth=TRUE</code> to restrict cell widths to this range.
Note that the argument <code>colWidths</code> is generally preferred, if the
numeric widths can be reasonable calculated or anticipated upfront.
When <code>autoWidth=FALSE</code> 'Excel' typically auto-sizes cells to the width
of the largest value in each column, which may not be ideal when
values are extremely large.</p>
</td></tr>
<tr><td><code id="writeOpenxlsx_+3A_colwidths">colWidths</code></td>
<td>
<p><code>numeric</code> width of each column in <code>x</code>, recycled
to the total number of columns required. Note that when
<code>keepRownames=TRUE</code>, the first column will contain <code>rownames(x)</code>,
therefore the length of <code>colWidths</code> in that case will be
<code>ncol(x) + 1</code>.</p>
</td></tr>
<tr><td><code id="writeOpenxlsx_+3A_wrapcells">wrapCells</code></td>
<td>
<p><code>logical</code> default FALSE, indicating whether to
enable word-wrap within cells.</p>
</td></tr>
<tr><td><code id="writeOpenxlsx_+3A_wrapheaders">wrapHeaders</code></td>
<td>
<p><code>logical</code> indicating whether to enable word wrap
for column headers, which is helpful when <code>autoWidth=TRUE</code> since
it fixed the cell width while allowing the column header to be seen.</p>
</td></tr>
<tr><td><code id="writeOpenxlsx_+3A_headerrowmultiplier">headerRowMultiplier</code></td>
<td>
<p><code>numeric</code> value to define the row height of
the first header row in 'Excel'. This value is defined as a multiple
of subsequent rows, and should usually represent the maximum number
of lines after word-wrapping, as relevant. This argument
is helpful when <code>wrapHeaders=TRUE</code> and <code>autoWidth=TRUE</code>.</p>
</td></tr>
<tr><td><code id="writeOpenxlsx_+3A_keeprownames">keepRownames</code></td>
<td>
<p><code>logical</code> indicating whether to include
<code>rownames(x)</code> in its own column in 'Excel'.</p>
</td></tr>
<tr><td><code id="writeOpenxlsx_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating whether to print verbose output.</p>
</td></tr>
<tr><td><code id="writeOpenxlsx_+3A_...">...</code></td>
<td>
<p>additional arguments are passed to <code>applyXlsxConditionalFormat()</code>
and <code>applyXlsxCategoricalFormat()</code> as relevant.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a minor but useful customization of the
<code>openxlsx::saveWorkbook()</code> and associated functions, intended
to provide some pre-configured formatting of known column
types, typically relevant to statistical values, and
in some cases, gene or transcript expression values.
</p>
<p>There are numerous configurable options when saving an 'Excel'
worksheet, most of the defaults in this function are intended
not to require changes, but are listed as formal function
arguments to make each option visibly obvious.
</p>
<p>If <code>colorSub</code> is supplied as a named vector of colors, then
by default text values will be colorized accordingly, which
can be especially helpful when including data with categorical
text values.
</p>
<p>This function pre-configures formatting options for the following
column data types, each of which has conditional
color-formatting, defined numeric ranges, and color scales.
</p>

<dl>
<dt>int</dt><dd><p>integer values, where numeric values are formatted
without visible decimal places, and the <code>big.mark=","</code> standard
is used to help visually distinguish large integers. The color
scale is by default c(0, 100, 10000).</p>
</dd>
<dt>num</dt><dd><p>numeric values, with fixed number of visible decimal
places, which helps visibly align values along each row.</p>
</dd>
<dt>hit</dt><dd><p>numeric type, a subset of &quot;int&quot; intended when data
is flagged with something like a &quot;+1&quot; or &quot;-1&quot; to indicate a
statistical increase or decrease.</p>
</dd>
<dt>pvalue</dt><dd><p>P-value, where numeric values range from 1 down
near zero, and values are formatted consistently with scientific
notation.</p>
</dd>
<dt>fc</dt><dd><p>numeric fold change, whose values are expected to range
from 1 and higher, and -1 and lower. Decimal places are by default
configured to show one decimal place, to simplify the 'Excel' visual
summary.</p>
</dd>
<dt>lfc</dt><dd><p>numeric log fold change, whose values are expected to be
centered at zero. Decimal places are by default
configured to show one decimal place, to simplify the 'Excel' visual
summary.</p>
</dd>
<dt>highlight</dt><dd><p>character and undefined columns to be highlighted
with a brighter background color, and bold text.</p>
</dd>
</dl>

<p>For each column data type, a color scale and default numeric range
is defined, which allows conditional formatting of cells based upon
expected ranges of values.
</p>
<p>A screenshot of the file produced by the example is shown below.
</p>
<p><img src="../help/figures/writeopenxlsx.png" alt="xlsx screenshot" />
</p>



<h3>Value</h3>

<p><code>Workbook</code> object as defined by the <code>openxlsx</code> package
is returned invisibly with <code>invisible()</code>. This <code>Workbook</code>
can be used in argument <code>wb</code> to provide a speed boost when
saving multiple sheets to the same file.
</p>


<h3>See Also</h3>

<p>Other jam export functions: 
<code><a href="#topic+applyXlsxCategoricalFormat">applyXlsxCategoricalFormat</a>()</code>,
<code><a href="#topic+applyXlsxConditionalFormat">applyXlsxConditionalFormat</a>()</code>,
<code><a href="#topic+readOpenxlsx">readOpenxlsx</a>()</code>,
<code><a href="#topic+set_xlsx_colwidths">set_xlsx_colwidths</a>()</code>,
<code><a href="#topic+set_xlsx_rowheights">set_xlsx_rowheights</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up a test data.frame
set.seed(123);
lfc &lt;- -3:3 + stats::rnorm(7)/3;
colorSub &lt;- nameVector(
   rainbow2(7),
   LETTERS[1:7])
df &lt;- data.frame(name=LETTERS[1:7],
   int=round(4^(1:7)),
   num=(1:7)*4-2 + stats::rnorm(7),
   fold=2^abs(lfc)*sign(lfc),
   lfc=lfc,
   pvalue=10^(-1:-7 + stats::rnorm(7)),
   hit=sample(c(-1,0,0,1,1), replace=TRUE, size=7));
df;
# write to tempfile for examples
if (check_pkg_installed("openxlsx")) {
   out_xlsx &lt;- tempfile(pattern="writeOpenxlsx_", fileext=".xlsx")
   writeOpenxlsx(x=df,
      file=out_xlsx,
      sheetName="jamba_test",
      colorSub=colorSub,
      intColumns=2,
      numColumns=3,
      fcColumns=4,
      lfcColumns=5,
      pvalueColumns=6,
      hitColumn=7,
      freezePaneRow=2,
      freezePaneColumn=2,
      append=FALSE);
   # now read it back
   df_list &lt;- readOpenxlsx(xlsx=out_xlsx);
   sdim(df_list)
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
