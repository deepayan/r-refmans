<!DOCTYPE html><html><head><title>Help for package FIT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FIT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#FIT'><p>FIT: a statistical modeling tool for transcriptome dynamics under fluctuating field conditions</p></a></li>
<li><a href='#convert.attribute'><p>Converts attribute data from a dataframe into an object.</p></a></li>
<li><a href='#convert.expression'><p>converts expression data from a dataframe into an object.</p></a></li>
<li><a href='#convert.weather'><p>Converts weather data from a dataframe into an object.</p></a></li>
<li><a href='#convert.weight'><p>Converts regression weight data from a dataframe into an object.</p></a></li>
<li><a href='#fit.models'><p>A raw API for fixing linear regression coefficients.</p></a></li>
<li><a href='#init'><p>A raw API for initializing model parameters.</p></a></li>
<li><a href='#load.attribute'><p>Loads attribute data.</p></a></li>
<li><a href='#load.expression'><p>Loads expression data.</p></a></li>
<li><a href='#load.weather'><p>Loads weather data.</p></a></li>
<li><a href='#load.weight'><p>Loads regression weight data.</p></a></li>
<li><a href='#make.recipe'><p>Creates a recipe for training models.</p></a></li>
<li><a href='#make.trivial.weights'><p>Makes trivial weight data</p></a></li>
<li><a href='#optim'><p>A raw API for optimizing model parameters.</p></a></li>
<li><a href='#predict'><p>Predicts gene expressions using pretrained models.</p></a></li>
<li><a href='#prediction.errors'><p>Computes the prediction errors using the trained models.</p></a></li>
<li><a href='#train'><p>Constructs models following a recipe.</p></a></li>
<li><a href='#weather.entries'><p>Supported weather factors.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Transcriptomic Dynamics Models in Field Conditions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functionality for constructing
    statistical models of transcriptomic dynamics in field conditions.
    It further offers the function to predict expression of a gene given 
    the attributes of samples and meteorological data. Nagano, A. J., Sato, 
    Y., Mihara, M., Antonio, B. A., Motoyama, R., Itoh, H., Naganuma, Y., and 
    Izawa, T. (2012). &lt;<a href="https://doi.org/10.1016%2Fj.cell.2012.10.048">doi:10.1016/j.cell.2012.10.048</a>&gt;. Iwayama, K., Aisaka, Y., 
    Kutsuna, N., and Nagano, A. J. (2017). &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtx049">doi:10.1093/bioinformatics/btx049</a>&gt;.     </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rcpp (&ge; 0.11.2), XML, gglasso (&ge; 1.4), MASS</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.mozilla.org/en-US/MPL/2.0/">MPL (&ge; 2)</a> | file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen (&ge; 0.3.2.1.2)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-01-01 04:26:18 UTC; koji</td>
</tr>
<tr>
<td>Author:</td>
<td>Koji Iwayama [cre],
  Yuri Aisaka [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Koji Iwayama &lt;fieldtranscriptome@gmail.com&gt;</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-01-07 14:50:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='FIT'>FIT: a statistical modeling tool for transcriptome dynamics under fluctuating field conditions</h2><span id='topic+FIT'></span><span id='topic+FIT-package'></span>

<h3>Description</h3>

<p>Provides functionality for constructing statistical models of transcriptomic dynamics in field 
conditions. It further offers the function to predict expression of a gene given the attributes 
of samples and meteorological data. Nagano, A. J., Sato, Y., Mihara, M., Antonio, B. A., 
Motoyama, R., Itoh, H., Naganuma, Y., and Izawa, T. (2012). &lt;doi:10.1016/j.cell.2012.10.048&gt;. 
Iwayama, K., Aisaka, Y., Kutsuna, N., and Nagano, A. J. (2017). 
&lt;doi:10.1093/bioinformatics/btx049&gt;.
</p>


<h3>Overview</h3>

<p>The <span class="pkg">FIT</span> package is an <code>R</code> implementation
of a class of transcriptomic models that
relates gene expressions of plants and weather conditions to which
the plants are exposed.
(The reader is referred to [Nagano et al.] for the detail of
the class of models concerned.)
</p>
<p>By providing
(a) gene expression profiles of plants brought up in a field condition,
and (b) the relevant weather history (temperature etc.) of the said field,
the user of the package is able to
(1) construct optimized models (one for each gene) for their expressions,
and
(2) use them to predict the expressions for another weather history
(possibly in a different field).
</p>
<p>Below, we briefly explain
the construction of the optimized models (&ldquo;training phase&rdquo;)
and the way to use them to make predictions (&ldquo;prediction phase&rdquo;).
</p>


<h4>Model training phase</h4>

<p>The model of [Nagano et al.] belongs to the class of statistical models
called &ldquo;linear models&rdquo;
and are specified by a set of &ldquo;parameters&rdquo; and
&ldquo;(linear regression) coefficients&rdquo;.
The former are used to convert weather conditions to
the &ldquo;input variables&rdquo; for a regression, and the latter are then
multiplied to the input variables to form the expectation values
for the gene expressions.
The reader is referred to the original article [Nagano et al.]
for the formulas for the input variables.
(See also [Iwayama] for a review.)
</p>
<p>The training phase consists of three stages:
</p>

<ol>
<li> <p><code>Init</code>: fixes the initial model parameters
</p>
</li>
<li> <p><code>Optim</code>: optimizes the model parameters
</p>
</li>
<li> <p><code>Fit</code>: fixes the linear regression coefficients
</p>
</li></ol>

<p>The user can configure the training phase
through a custom data structure (&ldquo;recipe&rdquo;),
which can be constructed by using the utility function
<code>FIT::make.recipe()</code>.
</p>
<p>The role of the first stage <code>Init</code> is to fix the initial values
for the model parameters from which the parameter optimization is performed.
At the moment two methods, <code>'manual'</code> and <code>'gridsearch'</code>,
are implemented.
With the <code>'manual'</code> method the user can simply specify the set of
initial values that he thinks is promising.
For the <code>'gridsearch'</code> method the user discretizes
the parameter space to a grid by providing
a finite number of candidate values for each parameter.
<span class="pkg">FIT</span> then performs a search over the grid
for the &ldquo;best&rdquo; combinations of the initial parameters.
</p>
<p>The second stage <code>Optim</code> is the main step of the model training,
and <span class="pkg">FIT</span> tries to gradually improve the model parameters
using the Nelder-Mead method.
</p>
<p>This stage could be run one or more times where each can be run
using the method <code>'none'</code>, <code>'lm'</code> or <code>'lasso'</code>.
The <code>'none'</code> method passes the given parameter as-is
to the next method in the <code>Optim</code> pipeline or to the next stage <code>Fit</code>.
(Basically, the method is there so that the user can skip the entire
<code>Optim</code> stage, but the method could be used for slightly warming-up the CPU as well.)
</p>
<p>The <code>'lm'</code> method uses the a simple (weighted) linear regression to
guide the parameter optimization. That is, <span class="pkg">FIT</span>
first computes the &ldquo;input variables&rdquo; from the current parameters and
associated weather data, and then finds the set of linear coefficients
that best explains the &ldquo;output variables&rdquo; (gene expressions).
Finally, the quadratic residual is used as the measure for the
error and is fed back to the Nelder-Mead method.
</p>
<p>The <code>'lasso'</code> method is similar to the <code>'lm'</code> method
but uses the (weighted) Lasso regression
(&ldquo;linear&rdquo; regression with an L1-regularization for the regression coefficients)
instead of the simple linear regression.
<span class="pkg">FIT</span> uses the <span class="pkg">glmnet</span> package to perform
the Lasso regression and the strength of the L1-regularization
is fixed via a cross validation. (See <code>cv.glmnet()</code> from the <span class="pkg">glmnet</span>
package.
The Lasso regression is said to suppress irrelevant input variables automatically
and tends to create models with better prediction ability.
On the other hand, <code>'lasso'</code> runs considerably slower than <code>'lm'</code>.
</p>
<p>For example, passing a vector <code>c('lm', 'lasso')</code> to the
argument <code>optim</code> (of <code>make.recipe()</code>) creates a recipe
that instructs the <code>Optim</code> stage to
(1) first optimize using the <code>'lm'</code> method,
(2) and then fine tunes the parameters using the <code>'lasso'</code> method.
</p>
<p>After fixing the model parameters in the <code>Optim</code> stage,
the <code>Fit</code> stage can be used to fix the linear coefficients
of the models.
Here, either <code>'fit.lm'</code> or <code>'fit.lasso'</code> can be used
to find the &ldquo;best&rdquo; coefficients, the main difference being that
the coefficients are penalized by an L1-norm for the latter.
Note that it is perfectly okay to use <code>'fit.lasso'</code> for
the parameters optimized using <code>'lm'</code>.
</p>
<p>In order to prepare for the possibly huge variations
of expression data as measured by RNA-seq,
<span class="pkg">FIT</span> provides a way to weight regression penalties from each sample
with different weights as in
<code>sum_{s in samples} (weight_s) (error_s)^2</code>.
</p>
 


<h4>Prediction phase</h4>

<p>For each gene, the trained model of the previous subsection
can be thought of as a black box that maps
the field conditions (weather data),
to which a plant containing the gene is exposed,
to its expected expression.
<span class="pkg">FIT</span> provides a simple function
<code>FIT::predict()</code> that does just this.
</p>
<p><code>FIT::predict()</code> takes as its argument
a list of pretrained models
as well as actual/hypothetical plant sample attributes and weather data,
and returns the predicted values of gene expressions.
</p>
<p>When there is a set of actually measured expressions,
an associated function <code>FIT::prediction.errors()</code>)
can be used to check the validity of the predictions made by
the models.
</p>
 


<h3>Namespece contamination</h3>

<p>The <span class="pkg">FIT</span> package exports fairly ubiquitous names
auch as <code>optim</code>, <code>predict</code> etc.\ as its API.
Users, therefore, are advised to load <span class="pkg">FIT</span>
via <code>requireNamespace('FIT')</code> and use its API function with
a namaspace qualifier (e.g.~<code>FIT::optim()</code>)
rather than loading <em>and</em> attaching it via <code>library('FIT')</code>.
</p>


<h3>Basic usage</h3>

<p>See vignettes for examples of actual scripts that use <span class="pkg">FIT</span>.
</p>


<h3>References</h3>

<p>[Nagano et al.] A.J.~Nagano, et al.
&ldquo;Deciphering and prediction of transcriptome dynamics under fluctuating field conditions,&rdquo;
Cell~151, 6, 1358&ndash;69 (2012)
</p>
<p>[Iwayama] K.~Iwayama, et al. 
&ldquo;FIT: statistical modeling tool for transcriptome dynamics under fluctuating field conditions,&rdquo;
Bioinformatics, btx049 (2017)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# The following snippet shows the structure of a typical
# driver script of the FIT package.
# See vignettes for examples of actual scripts that use FIT.

##############
## training ##
##############
## discretized parameter space (for 'gridsearch')
grid.coords &lt;- list(
  clock.phase = seq(0, 23*60, 1*60),
  # :
  gate.radiation.amplitude = c(-5, 5)
)

## create a training recipe
recipe &lt;- FIT::make.recipe(c('temperature', 'radiation'),
                           init  = 'gridsearch',
                           init.data = grid.coords,
                           optim = c('lm'),
                           fit   = 'fit.lasso',
                           time.step = 10, 
                           opts =
                             list(lm    = list(maxit = 900),
                             lasso = list(maxit = 1000))
                           )

## names of genes to construct models
genes &lt;- c('Os12g0189300', 'Os02g0724000')


## End(Not run)


## Not run: 
## load training data
training.attribute  &lt;- FIT::load.attribute('attribute.2008.txt')
training.weather    &lt;- FIT::load.weather('weather.2008.dat', 'weather')
training.expression &lt;- FIT::load.expression('expression.2008.dat', 'ex', genes)

## models will be a list of trained models (length: ngenes)
models &lt;- FIT::train(training.expression,
                     training.attribute,
                     training.weather,
                     recipe)


## End(Not run)

################
## prediction ##
################

## Not run: 
## load validation data
prediction.attribute  &lt;- FIT::load.attribute('attribute.2009.txt');
prediction.weather    &lt;- FIT::load.weather('weather.2009.dat', 'weather')
prediction.expression &lt;- FIT::load.expression('expression.2009.dat', 'ex', genes)

## predict
prediction.result &lt;- FIT::predict(models[[1]],
                                 prediction.attribute,
                                 prediction.weather)



## End(Not run)

</code></pre>

<hr>
<h2 id='convert.attribute'>Converts attribute data from a dataframe into an object.</h2><span id='topic+convert.attribute'></span>

<h3>Description</h3>

<p>Converts attribute data from a dataframe into an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert.attribute(data, sample = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert.attribute_+3A_data">data</code></td>
<td>
<p>A dataframe of the attributes of microarray/RNA-seq data.</p>
</td></tr>
<tr><td><code id="convert.attribute_+3A_sample">sample</code></td>
<td>
<p>An optional numeric array that designates
the samples, that is rows, of the dataframe to be loaded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object that represents the attributes of
microarray/RNA-seq data.
Internally, the object holds a dataframe whose number of entries
(rows) equals that of the samples.
</p>

<hr>
<h2 id='convert.expression'>converts expression data from a dataframe into an object.</h2><span id='topic+convert.expression'></span>

<h3>Description</h3>

<p>converts expression data from a dataframe into an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert.expression(data, entries = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert.expression_+3A_data">data</code></td>
<td>
<p>A dataframe of expression data to be loaded.</p>
</td></tr>
<tr><td><code id="convert.expression_+3A_entries">entries</code></td>
<td>
<p>An optional string array that designates
the entries of the dataframe to be loaded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object that represents the expression data of microarray/RNA-seq.
Internally, the object holds a matrix of size
<code>nsamples * ngenes</code>.
</p>

<hr>
<h2 id='convert.weather'>Converts weather data from a dataframe into an object.</h2><span id='topic+convert.weather'></span>

<h3>Description</h3>

<p>Converts weather data from a dataframe into an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert.weather(data, entries = IO$weather.entries)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert.weather_+3A_data">data</code></td>
<td>
<p>A dataframe of weather data to be converted.</p>
</td></tr>
<tr><td><code id="convert.weather_+3A_entries">entries</code></td>
<td>
<p>An optional string array that designates
the entries of the dataframe to be loaded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object that reprents the timeseries data of weather factors.
Internally, the object holds a dataframe of size
<code>ntimepoints * nfactors</code>.
</p>

<hr>
<h2 id='convert.weight'>Converts regression weight data from a dataframe into an object.</h2><span id='topic+convert.weight'></span>

<h3>Description</h3>

<p>Converts regression weight data from a dataframe into an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert.weight(data, entries = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert.weight_+3A_data">data</code></td>
<td>
<p>A dataframe that contains weight data to be loaded.</p>
</td></tr>
<tr><td><code id="convert.weight_+3A_entries">entries</code></td>
<td>
<p>An optional string array that designates
the entries of the dataframe to be loaded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object that represents the weights 
Internally, the object holds a matrix of size
<code>nsamples * ngenes</code>.
</p>

<hr>
<h2 id='fit.models'>A raw API for fixing linear regression coefficients.</h2><span id='topic+fit.models'></span>

<h3>Description</h3>

<p>Note: use <code>train()</code> unless the user is willing to
accept breaking API changes in the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.models(expression, weight, attribute, weather, recipe, models)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.models_+3A_expression">expression</code></td>
<td>
<p>An object that represents gene expression data.
The object can be created from a dumped/saved dataframe
of size <code>nsamples * ngenes</code>
using <code>FIT::load.expression()</code>.
(At the moment it is an instance of a hidden class IO$Attribute,
but this may be subject to change.)</p>
</td></tr>
<tr><td><code id="fit.models_+3A_weight">weight</code></td>
<td>
<p>A matrix of size <code>nsamples * ngenes</code>
that during regression penalizes errors from each sample 
using the formula
<code>sum_{s in samples} (weight_s) (error_s)^2</code>.
</p>
<p>Note that, unlike for <code>FIT::train()</code>, this argument
is NOT optional.</p>
</td></tr>
<tr><td><code id="fit.models_+3A_attribute">attribute</code></td>
<td>
<p>An object that represents the attributes of
microarray/RNA-seq data.
The object can be created from a dumped/saved dataframe
of size <code>nsamples * nattributes</code>
using <code>FIT::load.attribute()</code>.
(At the moment it is an instance of a hidden class IO$Attribute,
but this may be subject to change.)</p>
</td></tr>
<tr><td><code id="fit.models_+3A_weather">weather</code></td>
<td>
<p>An object that represents actual or hypothetical weather data
with which the training of models are done.
The object can be created from a dumped/saved dataframe
of size <code>ntimepoints * nfactors</code>
using <code>FIT::load.weather()</code>.
(At the moment it is an instance of a hidden class IO$Weather,
but this may be subject to change.)</p>
</td></tr>
<tr><td><code id="fit.models_+3A_recipe">recipe</code></td>
<td>
<p>An object that represents the training protocol of models.
A recipe can be created using <code>FIT::make.recipe()</code>.</p>
</td></tr>
<tr><td><code id="fit.models_+3A_models">models</code></td>
<td>
<p>A collection of models being trained as is returnd by
<code>FIT::optim()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A collection of models whose parameters and regression coeffients
are optimized.
</p>

<hr>
<h2 id='init'>A raw API for initializing model parameters.</h2><span id='topic+init'></span>

<h3>Description</h3>

<p>Note: use <code>train()</code> unless the user is willing to
accept breaking API changes in the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init(expression, weight, attribute, weather, recipe)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_+3A_expression">expression</code></td>
<td>
<p>An object that represents gene expression data.
The object can be created from a dumped/saved dataframe
of size <code>nsamples * ngenes</code>
using <code>FIT::load.expression()</code>.
(At the moment it is an instance of a hidden class IO$Attribute,
but this may be subject to change.)</p>
</td></tr>
<tr><td><code id="init_+3A_weight">weight</code></td>
<td>
<p>A matrix of size <code>nsamples * ngenes</code>
that during regression penalizes errors from each sample 
using the formula
<code>sum_{s in samples} (weight_s) (error_s)^2</code>.
</p>
<p>Note that, unlike for <code>FIT::train()</code>, this argument
is NOT optional.</p>
</td></tr>
<tr><td><code id="init_+3A_attribute">attribute</code></td>
<td>
<p>An object that represents the attributes of a
microarray/RNA-seq data.
The object can be created from a dumped/saved dataframe
of size <code>nsamples * nattributes</code>
using <code>FIT::load.attribute()</code>.
(At the moment it is an instance of a hidden class IO$Attribute,
but this may be subject to change.)</p>
</td></tr>
<tr><td><code id="init_+3A_weather">weather</code></td>
<td>
<p>An object that represents actual or hypothetical weather data
with which the training of models are done.
The object can be created from a dumped/saved dataframe
of size <code>ntimepoints * nfactors</code>
using <code>FIT::load.weather()</code>.
(At the moment it is an instance of a hidden class IO$Weather,
but this may be subject to change.)</p>
</td></tr>
<tr><td><code id="init_+3A_recipe">recipe</code></td>
<td>
<p>An object that represents the training protocol of models.
A recipe can be created using <code>FIT::make.recipe()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A collection of models whose parameters are
set by using the <code>'init'</code> method in the argument <code>recipe</code>.
</p>

<hr>
<h2 id='load.attribute'>Loads attribute data.</h2><span id='topic+load.attribute'></span>

<h3>Description</h3>

<p>Loads attribute data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.attribute(path, variable = NULL, sample = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.attribute_+3A_path">path</code></td>
<td>
<p>A path of a file that contains attribute data to be loaded.
When the file is a loadable <code>.Rdata</code>,
<code>name</code> of the dataframe object in the <code>.Rdata</code>
(that actually contains the relevant data)
has to be specified as well.</p>
</td></tr>
<tr><td><code id="load.attribute_+3A_variable">variable</code></td>
<td>
<p>An optional string that designates the name of a
dataframe object that has been saved in an <code>.Rdata</code>.
(See the description of <code>path</code>.)</p>
</td></tr>
<tr><td><code id="load.attribute_+3A_sample">sample</code></td>
<td>
<p>An optional numeric array that designates
the samples, that is rows, of the dataframe to be loaded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object that represents the attributes of
microarray/RNA-seq data.
Internally, the object holds a dataframe whose number of entries
(rows) equals that of the samples.
</p>

<hr>
<h2 id='load.expression'>Loads expression data.</h2><span id='topic+load.expression'></span>

<h3>Description</h3>

<p>Loads expression data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.expression(path, variable = NULL, entries = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.expression_+3A_path">path</code></td>
<td>
<p>A path of a file that contains attribute data to be loaded.
When the file is a loadable <code>.Rdata</code>,
<code>name</code> of the dataframe object in the <code>.Rdata</code>
(that actually contains the relevant data)
has to be specified as well.</p>
</td></tr>
<tr><td><code id="load.expression_+3A_variable">variable</code></td>
<td>
<p>An optional string that designates the name of a
dataframe object that has been saved in an <code>.Rdata</code>.
(See the description of <code>path</code>.)</p>
</td></tr>
<tr><td><code id="load.expression_+3A_entries">entries</code></td>
<td>
<p>An optional string array that designates
the entries of the dataframe to be loaded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object that represents the expression data of microarray/RNA-seq.
Internally, the object holds a matrix of size
<code>nsamples * ngenes</code>.
</p>

<hr>
<h2 id='load.weather'>Loads weather data.</h2><span id='topic+load.weather'></span>

<h3>Description</h3>

<p>Loads weather data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.weather(path, variable = NULL, entries = IO$weather.entries)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.weather_+3A_path">path</code></td>
<td>
<p>A path of a file that contains weather data to be loaded.
When the file is a loadable <code>.Rdata</code>,
<code>name</code> of the dataframe object in the <code>.Rdata</code>
(that actually contains the relevant data)
has to be specified as well.</p>
</td></tr>
<tr><td><code id="load.weather_+3A_variable">variable</code></td>
<td>
<p>An optional string that designates the name of a
dataframe object that has been saved in an <code>.Rdata</code>.
(See the description of <code>path</code>.)</p>
</td></tr>
<tr><td><code id="load.weather_+3A_entries">entries</code></td>
<td>
<p>An optional string array that designates
the entries of the dataframe to be loaded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object that reprents the timeseries data of weather factors.
Internally, the object holds a dataframe of size
<code>ntimepoints * nfactors</code>.
</p>

<hr>
<h2 id='load.weight'>Loads regression weight data.</h2><span id='topic+load.weight'></span>

<h3>Description</h3>

<p>Loads regression weight data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.weight(path, variable = NULL, entries = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.weight_+3A_path">path</code></td>
<td>
<p>A path of a file that contains weight data to be loaded.
When the file is a loadable <code>.Rdata</code>,
<code>name</code> of the dataframe object in the <code>.Rdata</code>
(that actually contains the relevant data)
has to be specified as well.</p>
</td></tr>
<tr><td><code id="load.weight_+3A_variable">variable</code></td>
<td>
<p>An optional string that designates the name of a
dataframe object that has been saved in an <code>.Rdata</code>.
(See the description of <code>path</code>.)</p>
</td></tr>
<tr><td><code id="load.weight_+3A_entries">entries</code></td>
<td>
<p>An optional string array that designates
the entries of the dataframe to be loaded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object that represents the weights 
Internally, the object holds a matrix of size
<code>nsamples * ngenes</code>.
</p>

<hr>
<h2 id='make.recipe'>Creates a recipe for training models.</h2><span id='topic+make.recipe'></span>

<h3>Description</h3>

<p>Creates a recipe for training models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.recipe(envs, init, optim, fit, init.data, time.step, gate.open.min = 0,
  opts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.recipe_+3A_envs">envs</code></td>
<td>
<p>An array of weather factors to be taken into account
during the construction of models.
At the moment, the array <code>envs</code> can only contain a single weather factor
from <code>weather.entries</code>, though there is a plan to remove the restriction
in a future version.</p>
</td></tr>
<tr><td><code id="make.recipe_+3A_init">init</code></td>
<td>
<p>A string to specify the method to choose the initial parameters.
(One of <code>'gridsearch'</code> or <code>'manual'</code>.)</p>
</td></tr>
<tr><td><code id="make.recipe_+3A_optim">optim</code></td>
<td>
<p>A string to specify the method to be used for optimizing
the model parameters.
(One of <code>'none'</code>, <code>'lm'</code> or <code>'lasso'</code>)</p>
</td></tr>
<tr><td><code id="make.recipe_+3A_fit">fit</code></td>
<td>
<p>A string to specify the method to be used for fixing
the linear regression coefficients.
(One of <code>'fit.lm'</code> or <code>'fit.lasso'</code>.)</p>
</td></tr>
<tr><td><code id="make.recipe_+3A_init.data">init.data</code></td>
<td>
<p>Auxiliary data needed to perform the Init stage
using the method specified by the <code>init</code> argument.
When <code>init</code> is <code>'gridsearch'</code>, it should be a list representing
a discretized parameter space.
When <code>init</code> is <code>'manual'</code>, it should be a list of parameter
values that is used as the initial values for the parameters in
the Optim stage.</p>
</td></tr>
<tr><td><code id="make.recipe_+3A_time.step">time.step</code></td>
<td>
<p>An integer to specify the basic unit of time (in minute)
for the transcriptomic models.
Must be a multiple of the time step of weather data.</p>
</td></tr>
<tr><td><code id="make.recipe_+3A_gate.open.min">gate.open.min</code></td>
<td>
<p>The minimum opning length in minutes of the gate function for 
environmental inputs.</p>
</td></tr>
<tr><td><code id="make.recipe_+3A_opts">opts</code></td>
<td>
<p>An optional named list that specifies the arguments to be passed
to methods that constitute each stage of the model training.
Each key of the list corresponds to a name of a method.
</p>
<p>See examples for the supported options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object representing the procedure to construct models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
init.params &lt;- .. # choose them wisely
# Defined in Train.R:
# default.opts &lt;- list(
#   none  = list(),
#   lm    = list(maxit=1500, nfolds=-1), # nfolds for lm is simply ignored
#   lasso = list(maxit=1000, nfolds=10)
# )
recipe &lt;- FIT::make.recipe(c('wind', 'temperature'),
                           init = 'manual',
                           init.data = init.params,
                           optim = c('lm', 'none', 'lasso'),
                           fit = 'fit.lasso',
                           time.step = 10,
                           opts =
                             list(lm    = list(maxit = 900),
                                  lasso = list(maxit = 1000)))

## End(Not run)

</code></pre>

<hr>
<h2 id='make.trivial.weights'>Makes trivial weight data</h2><span id='topic+make.trivial.weights'></span>

<h3>Description</h3>

<p>Makes trivial weight data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.trivial.weights(samples.n, genes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.trivial.weights_+3A_samples.n">samples.n</code></td>
<td>
<p>A number of samples.</p>
</td></tr>
<tr><td><code id="make.trivial.weights_+3A_genes">genes</code></td>
<td>
<p>A list of genes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object that represens the trivial weights. 
Internally, the object holds an identity matrix of size 
<code>nsamples * ngenes</code>.
</p>

<hr>
<h2 id='optim'>A raw API for optimizing model parameters.</h2><span id='topic+optim'></span>

<h3>Description</h3>

<p>Note: use <code>train()</code> unless the user is willing to
accept breaking API changes in the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim(expression, weight, attribute, weather, recipe, models, maxit = NULL,
  nfolds = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optim_+3A_expression">expression</code></td>
<td>
<p>An object that represents gene expression data.
The object can be created from a dumped/saved dataframe
of size <code>nsamples * ngenes</code>
using <code>FIT::load.expression()</code>.
(At the moment it is an instance of a hidden class IO$Attribute,
but this may be subject to change.)</p>
</td></tr>
<tr><td><code id="optim_+3A_weight">weight</code></td>
<td>
<p>A matrix of size <code>nsamples * ngenes</code>
that during regression penalizes errors from each sample 
using the formula
<code>sum_{s in samples} (weight_s) (error_s)^2</code>.
</p>
<p>Note that, unlike for <code>FIT::train()</code>, this argument
is NOT optional.</p>
</td></tr>
<tr><td><code id="optim_+3A_attribute">attribute</code></td>
<td>
<p>An object that represents the attributes of
microarray/RNA-seq data.
The object can be created from a dumped/saved dataframe
of size <code>nsamples * nattributes</code>
using <code>FIT::load.attribute()</code>.
(At the moment it is an instance of a hidden class IO$Attribute,
but this may be subject to change.)</p>
</td></tr>
<tr><td><code id="optim_+3A_weather">weather</code></td>
<td>
<p>An object that represents actual or hypothetical weather data
with which the training of models are done.
The object can be created from a dumped/saved dataframe
of size <code>ntimepoints * nfactors</code>
using <code>FIT::load.weather()</code>.
(At the moment it is an instance of a hidden class IO$Weather,
but this may be subject to change.)</p>
</td></tr>
<tr><td><code id="optim_+3A_recipe">recipe</code></td>
<td>
<p>An object that represents the training protocol of models.
A recipe can be created using <code>FIT::make.recipe()</code>.</p>
</td></tr>
<tr><td><code id="optim_+3A_models">models</code></td>
<td>
<p>A collection of models being trained as is returnd by
<code>FIT::init()</code>.
</p>
<p>At this moment, it must be a list (genes) of a list (envs) of models
and must contain at least one model.
(THIS MIGHT CHANGE IN A FUTURE.)</p>
</td></tr>
<tr><td><code id="optim_+3A_maxit">maxit</code></td>
<td>
<p>An optional number that specifies
the maximal number of times that the parameter optimization is performed.
</p>
<p>The user can control this parameter by using the <code>opts</code> argument
for <code>FIT::train()</code>.</p>
</td></tr>
<tr><td><code id="optim_+3A_nfolds">nfolds</code></td>
<td>
<p>An optional number that specifies the order of
cross validation when <code>optim</code> method is <code>'lasso'</code>.
This is simply ignored when <code>optim</code> method is <code>'lm'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A collection of models whose parameters are
optimized by using the <code>'optim'</code> pipeline
in the argument <code>recipe</code>.
</p>

<hr>
<h2 id='predict'>Predicts gene expressions using pretrained models.</h2><span id='topic+predict'></span>

<h3>Description</h3>

<p>Predicts gene expressions using pretrained models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict(models, attribute, weather)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_models">models</code></td>
<td>
<p>A list of trained models for the genes of interest.
</p>
<p>At the moment the collection of trained models returned
by <code>FIT::train()</code> cannot be directly passed to <code>FIT::predict()</code>:
the user has to explicitly convert it to an appropriate format by using
<code>FIT::train.to.predict.adaptor()</code>.
(This restriction might be removed in a future.)</p>
</td></tr>
<tr><td><code id="predict_+3A_attribute">attribute</code></td>
<td>
<p>An object that represents the attributes of
microarray/RNA-seq data.
The object can be created from a dumped/saved dataframe
of size <code>nsamples * nattributes</code>
using <code>FIT::load.attribute()</code>.
(At the moment it is an instance of a hidden class IO$Attribute,
but this may be subject to change.)</p>
</td></tr>
<tr><td><code id="predict_+3A_weather">weather</code></td>
<td>
<p>An object that represents actual or hypothetical weather data
with which predictions of gene expressions are made.
The object can be created from a dumped/saved dataframe
of size <code>ntimepoints * nfactors</code>
using <code>FIT::load.weather()</code>.
(At the moment it is an instance of a hidden class IO$Weather,
but this may be subject to change.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of prediction results as returned by the models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# prepare models
# NOTE: FIT::train() returns a nested list of models
#   so we have to flatten it using FIT::train.to.predict.adaptor()
#   before passing it to FIT::predict().
models &lt;- FIT::train(..)
models.flattened &lt;- FIT::train.to.predict.adaptor(models)

# load data used for prediction
prediction.attribute  &lt;- FIT::load.attribute('attribute.2009.txt')
prediction.weather    &lt;- FIT::load.weather('weather.2009.dat', 'weather')
prediction.expression &lt;- FIT::load.expression('expression.2009.dat', 'ex', genes)

prediction.results &lt;- FIT::predict(models.flattened,
                                   prediction.attribute,
                                   prediction.weather)

## End(Not run)
</code></pre>

<hr>
<h2 id='prediction.errors'>Computes the prediction errors using the trained models.</h2><span id='topic+prediction.errors'></span>

<h3>Description</h3>

<p>Computes the prediction errors using the trained models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prediction.errors(models, expression, attribute, weather)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prediction.errors_+3A_models">models</code></td>
<td>
<p>A list of trained models for the genes of interest.
</p>
<p>At the moment the collection of trained models returned
by <code>FIT::train()</code> cannot be directly passed to <code>FIT::predict()</code>:
the user has to explicitly convert it to an appropriate format by using
<code>FIT::train.to.predict.adaptor()</code>.
(This restriction might be removed in a future.)</p>
</td></tr>
<tr><td><code id="prediction.errors_+3A_expression">expression</code></td>
<td>
<p>An object that represents the actual measured data of
gene expressions.
The object can be created from a dumped/saved dataframe
of size <code>nsamples * ngenes</code>
using <code>FIT::load.expression()</code>.
(At the moment it is an instance of a hidden class IO$Attribute,
but this may be subject to change.)</p>
</td></tr>
<tr><td><code id="prediction.errors_+3A_attribute">attribute</code></td>
<td>
<p>An object that represents the attributes of
microarray/RNA-seq data.
The object can be created from a dumped/saved dataframe
using <code>FIT::load.attribute()</code>.
(At the moment it is an instance of a hidden class IO$Attribute,
but this may be subject to change.)</p>
</td></tr>
<tr><td><code id="prediction.errors_+3A_weather">weather</code></td>
<td>
<p>An object that represents actual or hypothetical weather data
with which predictions of gene expressions are made.
The object can be created from a dumped/saved dataframe
using <code>FIT::load.weather()</code>.
(At the moment it is an instance of a hidden class IO$Weather,
but this may be subject to change.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of deviance (a measure of validity of predictions,
as is defined by each model) between the prediction results
and the measured results (as is provided by the user through
<code>expression</code> argument).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# see the usage of FIT::predict()

## End(Not run)
</code></pre>

<hr>
<h2 id='train'>Constructs models following a recipe.</h2><span id='topic+train'></span>

<h3>Description</h3>

<p>Constructs models following a recipe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>train(expression, attribute, weather, recipe, weight = NULL,
  min.expressed.rate = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="train_+3A_expression">expression</code></td>
<td>
<p>An object that represents gene expression data.
The object can be created from a dumped/saved dataframe
of size <code>nsamples * ngenes</code>
using <code>FIT::load.expression()</code>.
(At the moment it is an instance of a hidden class IO$Expression,
but this may be subject to change.)</p>
</td></tr>
<tr><td><code id="train_+3A_attribute">attribute</code></td>
<td>
<p>An object that represents the attributes of
microarray/RNA-seq data.
The object can be created from a dumped/saved dataframe
of size <code>nsamples * nattributes</code>
using <code>FIT::load.attribute()</code>.
(At the moment it is an instance of a hidden class IO$Attribute,
but this may be subject to change.)</p>
</td></tr>
<tr><td><code id="train_+3A_weather">weather</code></td>
<td>
<p>An object that represents actual or hypothetical weather data
with which the training of models are done.
The object can be created from a dumped/saved dataframe
of size <code>ntimepoints * nfactors</code>
using <code>FIT::load.weather()</code>.
(At the moment it is an instance of a hidden class IO$Weather,
but this may be subject to change.)</p>
</td></tr>
<tr><td><code id="train_+3A_recipe">recipe</code></td>
<td>
<p>An object that represents the training protocol of models.
A recipe can be created using <code>FIT::make.recipe()</code>.</p>
</td></tr>
<tr><td><code id="train_+3A_weight">weight</code></td>
<td>
<p>An optional numerical matrix of size <code>nsamples * ngenes</code>
that during regression penalizes errors from each sample 
using the formula
<code>sum_{s in samples} (weight_s) (error_s)^2</code>.
</p>
<p>This argument is optional for a historical reason,
and when it is omitted, all samples are equally penalized.</p>
</td></tr>
<tr><td><code id="train_+3A_min.expressed.rate">min.expressed.rate</code></td>
<td>
<p>A number used to 
A gene with <code>var(expr) &lt; thres.expr</code> is regarded as unexpressed,
and <span class="pkg">FIT</span> sets its model as: <code>expr = log(offset) + 0*inputs</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A collection of trained models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# create recipe
recipe &lt;- FIT::make.recipe(..)

#load training data
training.attribute  &lt;- FIT::load.attribute('attribute.2008.txt');
training.weather    &lt;- FIT::load.weather('weather.2008.dat', 'weather')
training.expression &lt;- FIT::load.expression('expression.2008.dat', 'ex', genes)
training.weight     &lt;- FIT::load.weight('weight.2008.dat', 'weight', genes)

# train models
models &lt;- FIT::train(training.expression,
                     training.attribute,
                     training.weather,
                     recipe,
                     training.weight)

## End(Not run)
</code></pre>

<hr>
<h2 id='weather.entries'>Supported weather factors.</h2><span id='topic+weather.entries'></span>

<h3>Description</h3>

<p>Supported weather factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weather.entries
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 6.</p>


<h3>Examples</h3>

<pre><code class='language-R'>length(FIT::weather.entries)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
