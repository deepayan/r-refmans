<!DOCTYPE html><html><head><title>Help for package clustDRM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {clustDRM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#clustDRMapp'><p>launch the shiny app for an easier use of the package</p></a></li>
<li><a href='#clustDRMappSimple'><p>launch the simpler version of the shiny app for an easier use of the package</p></a></li>
<li><a href='#fitDRM'><p>fitting dose-response model according to the identified pattern.</p></a></li>
<li><a href='#generalPatternClustering'><p>Clustering dose-response curves based on their pattern</p></a></li>
<li><a href='#inputDataMaker'><p>Creating suitable inputData for clustering of the dose-response curve patterns</p></a></li>
<li><a href='#monotonePatternClustering'><p>clustering dose-response curves based on their pattern when it is</p>
known to be monotone.
function to cluster dose-response curves based on their pattern.</a></li>
<li><a href='#plotDoseResponseData'><p>plot dose-response curves</p></a></li>
<li><a href='#plotSimulDRM'><p>plot results of the simulation study</p></a></li>
<li><a href='#simulEvalDRM'><p>simulation-based evalutation of a dose-response model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-03-06</td>
</tr>
<tr>
<td>Title:</td>
<td>Clustering Dose-Response Curves and Fitting Appropriate Models
to Them</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vahid Nassiri &lt;vahid.nassiri@openanalytics.eu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to identify the pattern of a dose-response
		curve. Then fit a set of appropriate models to it according to the identified pattern, 
		followed by model averaging to estimate the effective dose.</td>
</tr>
<tr>
<td>Imports:</td>
<td>doParallel, parallel, foreach, caret, ORCME, ORIClust,
multcomp, IsoGene, DoseFinding, pheatmap, shiny, readr, DT,
MCPMod, RColorBrewer,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat,</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-03-13 14:22:02 UTC; vnassiri</td>
</tr>
<tr>
<td>Author:</td>
<td>Vahid Nassiri [cre],
  Yimer Wasihun [aut],
  Martin Otava [aut],
  Helena Geys [aut],
  Fetene Tekle [aut],
  Kanaka Tatikola [aut],
  Ziv Shkedy [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-03-15 16:53:44 UTC</td>
</tr>
</table>
<hr>
<h2 id='clustDRMapp'>launch the shiny app for an easier use of the package</h2><span id='topic+clustDRMapp'></span>

<h3>Description</h3>

<p>launch the shiny app for an easier use of the package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustDRMapp()
</code></pre>


<h3>Details</h3>

<p>the shiny app made for an easy use of the functionalities 
of the clustDRM package. It can be launched using command clustDRMapp(). 
It imports the data (in csv format),
performs the clustering on it (for monotone patterns using E2
test, and for general patterns using ORICC2 and MCT). It also
can estimate EDp for different dose-response curves using 
appropriate models. Plotting dose-response curves are also
possible for any of these operations. A simulation tab will help
to decide about the design of the study using a simulation study.
</p>


<h3>Author(s)</h3>

<p>Vahid Nassiri and Yimer Wasihun.
</p>

<hr>
<h2 id='clustDRMappSimple'>launch the simpler version of the shiny app for an easier use of the package</h2><span id='topic+clustDRMappSimple'></span>

<h3>Description</h3>

<p>launch the simpler version of the shiny app for an easier use of the package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustDRMappSimple()
</code></pre>


<h3>Details</h3>

<p>a simpler version of the shiny app made for an easy use of the functionalities 
of the clustDRM package. It can be launched using command clustDRMappSimple(). 
It imports the data (in csv format),
performs the clustering on it (for monotone patterns using E2
test, and for general patterns using ORICC2 and MCT). It also
can estimate EDp for different dose-response curves using 
appropriate models. Plotting dose-response curves are also
possible for any of these operations.
</p>


<h3>Author(s)</h3>

<p>Vahid Nassiri and Yimer Wasihun.
</p>

<hr>
<h2 id='fitDRM'>fitting dose-response model according to the identified pattern.</h2><span id='topic+fitDRM'></span>

<h3>Description</h3>

<p>function to fit several dose-response candidate models according to the identified pattern, and combine their 
results using model selection and/or model averaging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitDRM(inputDataset, dose, response, ID, subsettingID = NULL,
  transform = c("none", "log", "sRoot", "qRoot", "boxcox"),
  addCovars = ~1, patternClusters, EDp = 0.5, addCovarsVar = TRUE,
  alpha = 0.05, na.rm = FALSE, imputationMethod = c("mean",
  "median"), nCores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitDRM_+3A_inputdataset">inputDataset</code></td>
<td>
<p>a data frame containing the input dataset, it should at least include dose, response, and ID</p>
</td></tr>
<tr><td><code id="fitDRM_+3A_dose">dose</code></td>
<td>
<p>either a single string or a scalar, indicating the name of the dose column or its index.</p>
</td></tr>
<tr><td><code id="fitDRM_+3A_response">response</code></td>
<td>
<p>either a single string or a scalar, indicating the name of the response column or its index.</p>
</td></tr>
<tr><td><code id="fitDRM_+3A_id">ID</code></td>
<td>
<p>either a single string or a scalar, indicating the name of the ID column or its index.</p>
</td></tr>
<tr><td><code id="fitDRM_+3A_subsettingid">subsettingID</code></td>
<td>
<p>a vector of ID's of the subjects, in case one wants to fit the models only to a subset of the data. Default is NULL, 
i.e., all the subjects in the inputDataset will be used.</p>
</td></tr>
<tr><td><code id="fitDRM_+3A_transform">transform</code></td>
<td>
<p>single string indicating what kind of transform should be applied on the response data. 
It takes &quot;none&quot; (no transform, dafault), &quot;log&quot; (natural log), &quot;sRoot (square root), and &quot;qRoot&quot; (cubic root), and 
&quot;boxcox&quot; (Box-Cox transformation).</p>
</td></tr>
<tr><td><code id="fitDRM_+3A_addcovars">addCovars</code></td>
<td>
<p>formula specifying extra linear covariate, e.g., ~x1+x2</p>
</td></tr>
<tr><td><code id="fitDRM_+3A_patternclusters">patternClusters</code></td>
<td>
<p>a vector of the same length as the number of rows in inputData (number of subjects) indicating a 
pattern for each subject. Note that the keywords which are recognized are: &quot;increasing&quot;, &quot;decreasing&quot;, &quot;flat&quot;, &quot;complete&quot;, and 
&quot;up down max at x&quot; and &quot;down up min at x&quot;, which x is one of the doses. The &quot;flat&quot; and &quot;complete&quot; patterns would not be considered.</p>
</td></tr>
<tr><td><code id="fitDRM_+3A_edp">EDp</code></td>
<td>
<p>scalar in (0,1), indicatign with EDp should be computed, default is 0.5 (ED50).</p>
</td></tr>
<tr><td><code id="fitDRM_+3A_addcovarsvar">addCovarsVar</code></td>
<td>
<p>logical variable (TRUE as default), idicating whether the variance of the extra covariates 
preesented in  addCovars (unless it is only intercept) should also be computed or not.</p>
</td></tr>
<tr><td><code id="fitDRM_+3A_alpha">alpha</code></td>
<td>
<p>scalar in (0,1), level of significance with default alpha = 0.05.</p>
</td></tr>
<tr><td><code id="fitDRM_+3A_na.rm">na.rm</code></td>
<td>
<p>logical variable indicatign whether missing values should be removed (TRUE) or not (FALSE, default)</p>
</td></tr>
<tr><td><code id="fitDRM_+3A_imputationmethod">imputationMethod</code></td>
<td>
<p>signle string taking calues from &quot;mean&quot; (default), and &quot;median&quot;, which indicates how the missing values should be
treated. &quot;mean&quot; would replace them with the mean of the observed ones, and &quot;median&quot; will use median of them for imputation.</p>
</td></tr>
<tr><td><code id="fitDRM_+3A_ncores">nCores</code></td>
<td>
<p>scalar, indicating the number of cores should be used to perform LRT and MCT tests. Default is 1 which means sequantial 
computation (no prallel computation).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the dose column of the inputDataset should be a numeric variable.
</p>


<h3>Value</h3>

<p>an object fo class fittedDRM which is a list with the following objects:
fittedModels the outcome of DoseFinding::fitMod for all the suitable models
estAICNonmonotone: the computed AIC for the models fitted to the subjects with a non-monotone pattern
estEDpNonmonotone: the computed EDp for the models fitted to the subjects with a non-monotone pattern
estAICMonmonotone: the computed AIC for the models fitted to the subjects with a monotone pattern
estEDpMonmonotone: the computed EDp for the models fitted to the subjects with a monotone pattern
extraCovarsMonotone: if any extra covariates are added to the model their estimates and possibly standard errors 
(if addCovarsVar = TRUE) are gievn for subjects with monotone pattern.
extraCovarsNonmonotone: if any extra covariates are added to the model their estimates and possibly standard errors 
(if addCovarsVar = TRUE) are gievn for subjects with non-monotone pattern.
</p>


<h3>Author(s)</h3>

<p>Vahid Nassiri, and Yimer Wasihun
</p>


<h3>See Also</h3>

<p><a href="https://www.rdocumentation.org/packages/DoseFinding/versions/0.9-16/topics/fitMod">DoseFinding</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## gnerating data
set.seed(11)
doses2Use &lt;-  c(0, 5, 20)
numRep2Use &lt;- c(6, 3, 3)
generatedData &lt;- cbind(rep(1,sum(numRep2Use)),
MCPMod::genDFdata("logistic",c(5, 3, 10, 0.05), doses2Use, 
numRep2Use, 1), 
		matrix(rnorm(1*sum(numRep2Use)), sum(numRep2Use), 1))
colnames(generatedData) &lt;- c("ID", "dose", "response", "x1")
for (iGen in 2:15){
	genData0 &lt;- cbind(rep(iGen,sum(numRep2Use)),
MCPMod::genDFdata("logistic",c(5, 3, 10, 0.05), doses2Use, 
numRep2Use, 1), matrix(rnorm(1*sum(numRep2Use)), 
sum(numRep2Use), 1))
	colnames(genData0) &lt;- c("ID", "dose", "response", "x1")
	generatedData &lt;- rbind(generatedData, genData0)
}
## transforming it for clustering
toInput &lt;- inputDataMaker(2, 3, 1, generatedData)
## general pattern clustering
generalPatternClust &lt;- generalPatternClustering(
inputData = toInput$inputData, colsData = toInput$colsData ,
colID = toInput$colID, doseLevels = toInput$doseLevels, 
numReplications = toInput$numReplicates, na.rm = FALSE, 
imputationMethod = "mean", ORICC = "two", transform = "none",
plotFormat = "eps", LRT = TRUE, MCT = TRUE,
		adjustMethod = "BH", nPermute = 100, useSeed = NULL, 
theLeastNumberOfMethods = 2, alpha = 0.05, nCores = 1)
## fitDRM 
fittedModel &lt;- fitDRM (inputDataset = generatedData, dose = 2, 
response = 3, ID = 1, subsettingID = NULL, 
		transform = c("none"), addCovars = ~x1, 
		patternClusters = 
generalPatternClust$clusteringORICC2Results$clusteringResultsORICC2, 
		EDp = 0.5, addCovarsVar = TRUE, alpha = 0.05, na.rm = FALSE, 
imputationMethod = c("mean"), nCores = 1)

</code></pre>

<hr>
<h2 id='generalPatternClustering'>Clustering dose-response curves based on their pattern</h2><span id='topic+generalPatternClustering'></span>

<h3>Description</h3>

<p>function to cluster dose-response curves based on their pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generalPatternClustering(inputData, colsData, colID, doseLevels,
  numReplications, na.rm = FALSE, imputationMethod = c("mean",
  "median"), ORICC = c("two", "one", "both"), transform = c("none",
  "log", "sRoot", "qRoot", "boxcox"), plotFormat = c("eps", "jpg"),
  LRT = TRUE, MCT = FALSE, adjustMethod = c("BH", "holm", "hochberg",
  "hommel", "bonferroni", "BY", "fdr", "none"), nPermute = 1000,
  useSeed = NULL, theLeastNumberOfMethods = c(1, 2, 3, 4),
  alpha = 0.05, nCores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generalPatternClustering_+3A_inputdata">inputData</code></td>
<td>
<p>data matrix which should incluide ID's of the subjects, as well as the measurements (gene expressions, etc.) 
for all replications of different as columns.</p>
</td></tr>
<tr><td><code id="generalPatternClustering_+3A_colsdata">colsData</code></td>
<td>
<p>vector indicating the idex of columns in the inputData which correspond to the measurement for different replications 
of different doses.</p>
</td></tr>
<tr><td><code id="generalPatternClustering_+3A_colid">colID</code></td>
<td>
<p>scalar indicating the index of column corresponding to data ID.</p>
</td></tr>
<tr><td><code id="generalPatternClustering_+3A_doselevels">doseLevels</code></td>
<td>
<p>vector with dose levels.</p>
</td></tr>
<tr><td><code id="generalPatternClustering_+3A_numreplications">numReplications</code></td>
<td>
<p>vector wit hthe same length as doseLevels with number of replications for each dose.</p>
</td></tr>
<tr><td><code id="generalPatternClustering_+3A_na.rm">na.rm</code></td>
<td>
<p>logical variable indicatign whether missing values should be removed (TRUE) or not (FALSE, default)</p>
</td></tr>
<tr><td><code id="generalPatternClustering_+3A_imputationmethod">imputationMethod</code></td>
<td>
<p>signle string taking calues from &quot;mean&quot; (default), and &quot;median&quot;, which indicates how the missing values should be
treated. &quot;mean&quot; would replace them with the mean of the observed ones, and &quot;median&quot; will use median of them for imputation.</p>
</td></tr>
<tr><td><code id="generalPatternClustering_+3A_oricc">ORICC</code></td>
<td>
<p>signle string taking value &quot;two&quot;, &quot;one&quot;, and &quot;both&quot;, indicating which ORICC procedure should be used. &quot;one&quot; refers to 
one-stage ORICC only, &quot;two&quot; (default) refers to two-stage ORICC only, and &quot;both&quot; will perform both of them.</p>
</td></tr>
<tr><td><code id="generalPatternClustering_+3A_transform">transform</code></td>
<td>
<p>single string indicating what kind of transform should be applied on the response data. 
It takes &quot;none&quot; (no transform, dafault), &quot;log&quot; (natural log), &quot;sRoot (square root), and &quot;qRoot&quot; (cubic root), and 
&quot;boxcox&quot; (Box-Cox transformation).</p>
</td></tr>
<tr><td><code id="generalPatternClustering_+3A_plotformat">plotFormat</code></td>
<td>
<p>plotFormat string gets two values &quot;eps&quot; (default), and &quot;jpg&quot; indicating the format of the ouput plot.</p>
</td></tr>
<tr><td><code id="generalPatternClustering_+3A_lrt">LRT</code></td>
<td>
<p>logical indicating whether a permutation-based likelihood ratio test should be applied (TRUE) on the subjects which 
their trend is identified as non-flast by ORICC1 or not (FALSE).</p>
</td></tr>
<tr><td><code id="generalPatternClustering_+3A_mct">MCT</code></td>
<td>
<p>logical indicating whether a multiple comparison test (with &quot;UmbrellaWilliams&quot; constrast matrix) 
should be applied (TRUE) on the subjects which their trend is identified as non-flast by ORICC1 or not (FALSE).</p>
</td></tr>
<tr><td><code id="generalPatternClustering_+3A_adjustmethod">adjustMethod</code></td>
<td>
<p>The method for multiplicity adjustment for p-values. The possible values for this argument are 
&quot;BH&quot;, &quot;holm&quot;, &quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BY&quot;, &quot;fdr&quot;, &quot;none&quot; with &quot;BH&quot; (Benjamini-Hocheberg) as default.</p>
</td></tr>
<tr><td><code id="generalPatternClustering_+3A_npermute">nPermute</code></td>
<td>
<p>scalar indicating number of permutations in LRT.</p>
</td></tr>
<tr><td><code id="generalPatternClustering_+3A_useseed">useSeed</code></td>
<td>
<p>scalar, indicating the seed should be used to generate LRT permutations. The default is NULL.</p>
</td></tr>
<tr><td><code id="generalPatternClustering_+3A_theleastnumberofmethods">theLeastNumberOfMethods</code></td>
<td>
<p>scalar taking values from 1, 2, 3, and 4, indicating how many methods should 
approve a non-flat trend that it can be selected. Its value depends on how many tests are asked to be done,
for the maximum happens when ORICC = &quot;both&quot; and both LRT and MCT are TRUE. For example, when this argument sets to 2 and ORICC = &quot;two&quot;, 
LRT = TRUE, and MCT = TRUE, it means if two-stage ORICC identifies a non-flat pattern and at least one of the 
LRT and MCT also accepts (at the level of alpha), then that comound is selected as one with a non-flat pattern. 
Note that the comparison with alpha is done for adjusted p-values.</p>
</td></tr>
<tr><td><code id="generalPatternClustering_+3A_alpha">alpha</code></td>
<td>
<p>the significance level to compare the adjusted p-value with it.</p>
</td></tr>
<tr><td><code id="generalPatternClustering_+3A_ncores">nCores</code></td>
<td>
<p>nCores scalar, indicating the number of cores should be used to perform LRT and MCT tests. Default is 1 which means sequantial 
computation (no prallel computation).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function first use ORIIC1 or ORICC2 (or both) to identify the pattern of the dose-response cruve for each subject. Once 
the pattern is identified, for non-flat ones, a permutation-based likelihood ratio test (for exactly the identified pattern, 
if LRT = TRUE), and a multiple comparisons test (to test H0: flat vs. H1: non-flat, if MCT = TRUE) will be performed to further filter 
the flat patterns.
</p>


<h3>Value</h3>

<p>a list of the following objects: 
</p>
<p>selectedSubjects: a data frame indicating the ID's of the selected subjects in the first columns and the 
identified trend in the second column.
</p>
<p>clusteringORICC1Results and/or clusteringORICC2Results: a list with four elements providing the raw data as 
the outcome of the ORICC procedure (rawDataORICC1 and/or rawDataORICC2), the pattern identified by the ORICC 
procedure (clusteringResultsORICC1 and/or clusteringResultsORICC2), results of LRT (resultsLRT) and results of 
MCT (resultsMCT). Both of them provide the adjusted and unadjusted p-values, but for MCT the selected contrast
will be provided as well.
</p>


<h3>Author(s)</h3>

<p>Vahid Nassiri, and Yimer Wasihun.
</p>


<h3>See Also</h3>

<p><a href="https://www.rdocumentation.org/packages/ORIClust/versions/1.0-1/topics/ORICC1">ORIClust</a>
<a href="https://www.rdocumentation.org/packages/ORIClust/versions/1.0-1/topics/ORICC2">ORIClust</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## gnerating data
set.seed(11)
doses2Use &lt;-  c(0, 5, 20)
numRep2Use &lt;- c(3, 3, 3)
generatedData &lt;- cbind(rep(1,sum(numRep2Use)),
MCPMod::genDFdata("logistic",c(5, 3, 10, 0.05), doses2Use, 
numRep2Use, 1), 
		matrix(rnorm(1*sum(numRep2Use)), sum(numRep2Use), 1))
colnames(generatedData) &lt;- c("ID", "dose", "response", "x1")
for (iGen in 2:15){
	genData0 &lt;- cbind(rep(iGen,sum(numRep2Use)),
MCPMod::genDFdata("logistic",c(5, 3, 10, 0.05), doses2Use, 
numRep2Use, 1), 
			matrix(rnorm(1*sum(numRep2Use)), sum(numRep2Use), 1))
	colnames(genData0) &lt;- c("ID", "dose", "response", "x1")
	generatedData &lt;- rbind(generatedData, genData0)
}
## transforming it for clustering
toInput &lt;- inputDataMaker(2, 3, 1, generatedData)
## general pattern clustering
generalPatternClust &lt;- generalPatternClustering(inputData = toInput$inputData, 
colsData = toInput$colsData ,colID = toInput$colID , 
		doseLevels = toInput$doseLevels, numReplications = toInput$numReplicates, 
na.rm = FALSE, imputationMethod = "mean",
		ORICC = "two", transform = "none",plotFormat = "eps", 
LRT = TRUE, MCT = TRUE,
		adjustMethod = "BH",
		nPermute = 100, useSeed = NULL, 
theLeastNumberOfMethods = 2, alpha = 0.05, nCores = 1)
</code></pre>

<hr>
<h2 id='inputDataMaker'>Creating suitable inputData for clustering of the dose-response curve patterns</h2><span id='topic+inputDataMaker'></span>

<h3>Description</h3>

<p>function to create needed information as the input of the functions to cluster 
dose-response cruve patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inputDataMaker(dose, response, ID, inputDataset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inputDataMaker_+3A_dose">dose</code></td>
<td>
<p>either a single string or a scalar, indicating the name of the dose column or its index.</p>
</td></tr>
<tr><td><code id="inputDataMaker_+3A_response">response</code></td>
<td>
<p>either a single string or a scalar, indicating the name of the response column or its index.</p>
</td></tr>
<tr><td><code id="inputDataMaker_+3A_id">ID</code></td>
<td>
<p>either a single string or a scalar, indicating the name of the ID column or its index.</p>
</td></tr>
<tr><td><code id="inputDataMaker_+3A_inputdataset">inputDataset</code></td>
<td>
<p>a data frame containing the input dataset, it should at least include dose, response, and ID</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the output of this function can be feed into the function for clustering dose-response curve patterns.
</p>


<h3>Value</h3>

<p>a list with the following elements:
</p>
<p>inputDataset: includes the ID (first column), and the response for all doses with their replications for each subject as rows.
doseLevels: unique dose levels
numReplicatrions: number of replicatios per each unique dose level.
colsData: the index of columns with responses.
colID: the index of ID column.
</p>


<h3>Author(s)</h3>

<p>Vahid Nassiri, and Yimer Wasihun
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
## gnerating data
set.seed(11)
doses2Use &lt;-  c(0, 5, 20)
numRep2Use &lt;- c(3, 3, 3)
generatedData &lt;- cbind(rep(1,sum(numRep2Use)), 
MCPMod::genDFdata("logistic",c(5, 3, 10, 0.05), 
doses2Use, numRep2Use, 1), 
		matrix(rnorm(1*sum(numRep2Use)), sum(numRep2Use), 1))
colnames(generatedData) &lt;- c("ID", "dose", "response", "x1")
for (iGen in 2:15){
	genData0 &lt;- cbind(rep(iGen,sum(numRep2Use)), 
MCPMod::genDFdata("logistic",c(5, 3, 10, 0.05), 
doses2Use, numRep2Use, 1), 
			matrix(rnorm(1*sum(numRep2Use)), sum(numRep2Use), 1))
	colnames(genData0) &lt;- c("ID", "dose", "response", "x1")
	generatedData &lt;- rbind(generatedData, genData0)
}
## transforming it for clustering
toInput &lt;- inputDataMaker(2, 3, 1, generatedData)

</code></pre>

<hr>
<h2 id='monotonePatternClustering'>clustering dose-response curves based on their pattern when it is 
known to be monotone.
function to cluster dose-response curves based on their pattern.</h2><span id='topic+monotonePatternClustering'></span>

<h3>Description</h3>

<p>clustering dose-response curves based on their pattern when it is 
known to be monotone.
function to cluster dose-response curves based on their pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monotonePatternClustering(inputData, colsData, colID, doseLevels,
  numReplications, transform = c("none", "log", "sRoot", "qRoot",
  "boxcox"), BHorBY = TRUE, SAM = FALSE, testType = c("E2",
  "Williams", "Marcus", "M", "ModifM"), adjustType = c("BH", "BY"),
  FDRvalue = c(0.05, 0.05), nPermute = c(1000, 1000),
  fudgeSAM = c("pooled", "none"), useSeed = c(NULL, NULL),
  theLeastNumberOfTests = 5, na.rm = FALSE,
  imputationMethod = c("mean", "median"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="monotonePatternClustering_+3A_inputdata">inputData</code></td>
<td>
<p>data matrix which should incluide ID's of the subjects, as well as the measurements (gene expressions, etc.) 
for all replications of different as columns.</p>
</td></tr>
<tr><td><code id="monotonePatternClustering_+3A_colsdata">colsData</code></td>
<td>
<p>vector indicating the idex of columns in the inputData which correspond to the measurement for different replications 
of different doses.</p>
</td></tr>
<tr><td><code id="monotonePatternClustering_+3A_colid">colID</code></td>
<td>
<p>scalar indicating the index of column corresponding to data ID.</p>
</td></tr>
<tr><td><code id="monotonePatternClustering_+3A_doselevels">doseLevels</code></td>
<td>
<p>vector with dose levels.</p>
</td></tr>
<tr><td><code id="monotonePatternClustering_+3A_numreplications">numReplications</code></td>
<td>
<p>vector wit hthe same length as doseLevels with number of replications for each dose.</p>
</td></tr>
<tr><td><code id="monotonePatternClustering_+3A_transform">transform</code></td>
<td>
<p>single string indicating what kind of transform should be applied on the response data. 
It takes &quot;none&quot; (no transform, dafault), &quot;log&quot; (natural log), &quot;sRoot (square root), and &quot;qRoot&quot; (cubic root), and 
&quot;boxcox&quot; (Box-Cox transformation).</p>
</td></tr>
<tr><td><code id="monotonePatternClustering_+3A_bhorby">BHorBY</code></td>
<td>
<p>logical inidicating whether monotonicity tests (specified in argument testType) using BH or BY modifications 
should be performed. Default is TRUE.</p>
</td></tr>
<tr><td><code id="monotonePatternClustering_+3A_sam">SAM</code></td>
<td>
<p>logical indicating whether a SAM procedure should be perfmored. Default is FALSE.</p>
</td></tr>
<tr><td><code id="monotonePatternClustering_+3A_testtype">testType</code></td>
<td>
<p>string a subset of c(&quot;E2&quot;, &quot;Williams&quot;, &quot;Marcus&quot;, &quot;M&quot;, &quot;ModifM&quot;), indicating the monotonicity tests 
which should be applied.</p>
</td></tr>
<tr><td><code id="monotonePatternClustering_+3A_adjusttype">adjustType</code></td>
<td>
<p>method of adjustment for multi-plicity in case BHorBY = TRUE. It takes values &quot;BH&quot; abd &quot;BY&quot; with &quot;BH&quot; as the
default.</p>
</td></tr>
<tr><td><code id="monotonePatternClustering_+3A_fdrvalue">FDRvalue</code></td>
<td>
<p>a numerical vector of length 2 indicating the FDR values for BHorBY and SAM, the default is 0.05 for both.</p>
</td></tr>
<tr><td><code id="monotonePatternClustering_+3A_npermute">nPermute</code></td>
<td>
<p>a numerical vector of length 2 indicating number of permutatation for BHorBY and SAM, the default for 
both is 1000.</p>
</td></tr>
<tr><td><code id="monotonePatternClustering_+3A_fudgesam">fudgeSAM</code></td>
<td>
<p>single string takes value from (&quot;pooled&quot;, &quot;none&quot;) specified the fudge factor in SAM test statistic. 
The default is &quot;pooled&quot;.</p>
</td></tr>
<tr><td><code id="monotonePatternClustering_+3A_useseed">useSeed</code></td>
<td>
<p>a vector of lkength two specifying the seed value for BHorBY and SAM, the default is NULL for both.</p>
</td></tr>
<tr><td><code id="monotonePatternClustering_+3A_theleastnumberoftests">theLeastNumberOfTests</code></td>
<td>
<p>A scalar indicating the minimum number of tests which should approve a monotone trend to 
consider a trend montone. The default is 5, i.e., all of the tests should agree on the monotonicity.</p>
</td></tr>
<tr><td><code id="monotonePatternClustering_+3A_na.rm">na.rm</code></td>
<td>
<p>logical variable indicatign whether missing values should be removed (TRUE) or not (FALSE, default)</p>
</td></tr>
<tr><td><code id="monotonePatternClustering_+3A_imputationmethod">imputationMethod</code></td>
<td>
<p>signle string taking calues from &quot;mean&quot; (default), and &quot;median&quot;, which indicates how the missing values should be
treated. &quot;mean&quot; would replace them with the mean of the observed ones, and &quot;median&quot; will use median of them for imputation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following objects:
</p>
<p>selectedSubjects: provides the ID and indentified patterns for the subjects which are selected based on the results of 
various tests and theLeastNumberOfTests.
</p>
<p>subjectsPatterns: a vector of the same length as the number of subjects in the input dataset which indicates the identified
patterns for all subjects (including flat ones).
</p>
<p>resultsBH: a list with the results of selected tests (if BHorBY = TRUE, NULL otherwise).
</p>
<p>resultsSAM: a list with results of SAM procedure (if SAM = TRUE, NULL otherwise).
</p>
<p>selectedSubjectsBH: a data frame of all of the subjects with then number of tests select them based on adjusted BH or BY methods.
</p>
<p>selectedSubjectsSAM: a data frame of all of the subjects with then number of tests select them based on SAM procedure
</p>


<h3>Author(s)</h3>

<p>Vahid Nassiri, and Yimer Wasihun.
</p>


<h3>See Also</h3>

<p><a href="https://www.rdocumentation.org/packages/IsoGene/versions/1.0-24/topics/IsoTestBH">IsoGene</a>
<a href="https://www.rdocumentation.org/packages/IsoGene/versions/1.0-24/topics/IsoTestSAM">IsoGene</a>
<a href="https://www.rdocumentation.org/packages/ORCME/versions/2.0.2/topics/monotoneDirection">ORCME</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## gnerating data, a sample of size 20
set.seed(11)
doses2Use &lt;-  c(0, 5, 20)
numRep2Use &lt;- c(3, 3, 3)
generatedData &lt;- cbind(rep(1,sum(numRep2Use)), 
MCPMod::genDFdata("logistic",c(5, 3, 10, 0.05), 
doses2Use, numRep2Use, 1), 
		matrix(rnorm(1*sum(numRep2Use)), sum(numRep2Use), 1))
colnames(generatedData) &lt;- c("ID", "dose", "response", "x1")
for (iGen in 2:20){
	genData0 &lt;- cbind(rep(iGen,sum(numRep2Use)), 
MCPMod::genDFdata("logistic",c(5, 3, 10, 0.05), 
doses2Use, numRep2Use, 1), 
			matrix(rnorm(1*sum(numRep2Use)), sum(numRep2Use), 1))
	colnames(genData0) &lt;- c("ID", "dose", "response", "x1")
	generatedData &lt;- rbind(generatedData, genData0)
}
## transforming it for clustering
toInput &lt;- inputDataMaker(2, 3, 1, generatedData)
## monotone pattern clustering
monotonePatternClust &lt;- monotonePatternClustering (inputData = 
toInput$inputData, colsData = toInput$colsData ,
		colID = toInput$colID, doseLevels = toInput$doseLevels, 
numReplications = toInput$numReplicates, 
		BHorBY = TRUE, SAM = FALSE, testType = c("E2"),
		adjustType = "BH", FDRvalue = c(0.05, 0.05), 
nPermute= c(100, 100), fudgeSAM = "pooled",
		useSeed = c(NULL, NULL), theLeastNumberOfTests = 1, 
na.rm = FALSE, imputationMethod = "mean")

</code></pre>

<hr>
<h2 id='plotDoseResponseData'>plot dose-response curves</h2><span id='topic+plotDoseResponseData'></span>

<h3>Description</h3>

<p>function to plot dose-response curves with the possibility of adding lines indicating average response per dose levels. Also, 
provided a pattern for the dose-response curve, it can estimate the expected mean values per dose level for the given pattern and
add them to the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDoseResponseData(inputDataset, dose, response, ID, subjectID,
  xlab = "Dose", ylab = "Response", addMean = TRUE,
  drcPattern = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDoseResponseData_+3A_inputdataset">inputDataset</code></td>
<td>
<p>a data frame containing the input dataset, it should at least include dose, response, and ID</p>
</td></tr>
<tr><td><code id="plotDoseResponseData_+3A_dose">dose</code></td>
<td>
<p>either a single string or a scalar, indicating the name of the dose column or its index.</p>
</td></tr>
<tr><td><code id="plotDoseResponseData_+3A_response">response</code></td>
<td>
<p>either a single string or a scalar, indicating the name of the response column or its index.</p>
</td></tr>
<tr><td><code id="plotDoseResponseData_+3A_id">ID</code></td>
<td>
<p>either a single string or a scalar, indicating the name of the ID column or its index.</p>
</td></tr>
<tr><td><code id="plotDoseResponseData_+3A_subjectid">subjectID</code></td>
<td>
<p>single input as the same type as given ID column with the ID of the subject to plot.</p>
</td></tr>
<tr><td><code id="plotDoseResponseData_+3A_xlab">xlab</code></td>
<td>
<p>single string with default &quot;dose&quot;, the label on x axis.</p>
</td></tr>
<tr><td><code id="plotDoseResponseData_+3A_ylab">ylab</code></td>
<td>
<p>single string with default &quot;response&quot;, the label on y axis.</p>
</td></tr>
<tr><td><code id="plotDoseResponseData_+3A_addmean">addMean</code></td>
<td>
<p>logical variable indicating whether mean values (connecting with lines) should be plotted or not.</p>
</td></tr>
<tr><td><code id="plotDoseResponseData_+3A_drcpattern">drcPattern</code></td>
<td>
<p>single string showing the idetified pattern using clustering algorithms. The default is NULL. In such case, no extra 
line will be added to the plot regarding the estimated means via the identified pattern.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>with addMean = TRUE, a line will be added to the plot, connecting the averaged response per dose level. 
But when a pattern is provided for the dose-response curve via drcPattern, then a line will be added to the data with the means 
estimated assuming the identified pattern. If both addMEan = TRUE and drcPattern != NULL, then two lines will be added to the plot. The line in 
purplish-colored with cross signs as points is the averaged response value per dose level, and the bluish-colored line with circled cross signs as points
represents the estimated mean based on the pattern.
</p>


<h3>Value</h3>

<p>make a plot.
</p>


<h3>Author(s)</h3>

<p>Vahid Nassiri and Yimer Wasihun.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## gnerating data, a sample of size 20
set.seed(11)
doses2Use &lt;-  c(0, 5, 20)
numRep2Use &lt;- c(3, 3, 3)
generatedData &lt;- cbind(rep(1,sum(numRep2Use)), 
MCPMod::genDFdata("logistic",c(5, 3, 10, 0.05), doses2Use, 
numRep2Use, 1), 
		matrix(rnorm(1*sum(numRep2Use)), sum(numRep2Use), 1))
colnames(generatedData) &lt;- c("ID", "dose", "response", "x1")
for (iGen in 2:15){
genData0 &lt;- cbind(rep(iGen,sum(numRep2Use)), 
MCPMod::genDFdata("logistic",c(5, 3, 10, 0.05), 
doses2Use, numRep2Use, 1), 
			matrix(rnorm(1*sum(numRep2Use)), sum(numRep2Use), 1))
colnames(genData0) &lt;- c("ID", "dose", "response", "x1")
generatedData &lt;- rbind(generatedData, genData0)
}
## plotting dose response relation
plotDoseResponseData(generatedData, 2, 3, 1, 2)
## transforming it for clustering
plotDoseResponseData(generatedData, 2, 3, 1, 2, 
addMean = FALSE, 
		drcPattern = "increasing")

</code></pre>

<hr>
<h2 id='plotSimulDRM'>plot results of the simulation study</h2><span id='topic+plotSimulDRM'></span>

<h3>Description</h3>

<p>a function to make a heatmap of the simulation results for tyhe given measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSimulDRM(simulDRMobj, quantity2Plot = c("mean", "bias", "mse",
  "variance", "relativeBias", "absBias", "absRelativeBias"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSimulDRM_+3A_simuldrmobj">simulDRMobj</code></td>
<td>
<p>output of simulEvalDRM function</p>
</td></tr>
<tr><td><code id="plotSimulDRM_+3A_quantity2plot">quantity2Plot</code></td>
<td>
<p>single string, the measure which should be plotted. Available choices are: 
c(&quot;mean&quot;, &quot;bias&quot;, &quot;mse&quot;, &quot;variance&quot;, &quot;relativeBias&quot;, 
&quot;absBias&quot;, &quot;absRelativeBias&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a heatmap
</p>


<h3>Author(s)</h3>

<p>Vahid Nassiri and Yimer Wasihun.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## gnerating data, a sample of size 20
set.seed(11)
doses2Use &lt;-  c(0, 5, 20)
numRep2Use &lt;- c(3, 3, 3)
generatedData &lt;- cbind(rep(1,sum(numRep2Use)),
MCPMod::genDFdata("logistic",c(5, 3, 10, 0.05), doses2Use,
 numRep2Use, 1), 
		matrix(rnorm(1*sum(numRep2Use)), sum(numRep2Use), 1))
colnames(generatedData) &lt;- c("ID", "dose", "response", "x1")
for (iGen in 2:20){
genData0 &lt;- cbind(rep(iGen,sum(numRep2Use)), 
MCPMod::genDFdata("logistic",c(5, 3, 10, 0.05), doses2Use, 
numRep2Use, 1), 
			matrix(rnorm(1*sum(numRep2Use)), sum(numRep2Use), 1))
	colnames(genData0) &lt;- c("ID", "dose", "response", "x1")
	generatedData &lt;- rbind(generatedData, genData0)
}
simRes &lt;- simulEvalDRM (pilotData = 
generatedData[generatedData$ID == 2, c(2,3)], 
doseLevels = c(0, 4, 20), 
		numReplications = c(6, 3, 3), numSim = 10, 
standardDeviation = 1, EDp = 0.5,
		funcList = c("linlog", "emax", "sigEmax", "logistic"))
# plot the simulated results
plotSimulDRM(simRes, quantity2Plot = "mse")
</code></pre>

<hr>
<h2 id='simulEvalDRM'>simulation-based evalutation of a dose-response model</h2><span id='topic+simulEvalDRM'></span>

<h3>Description</h3>

<p>a function to simulate data based different dose-response model using parameters estimated from a provided pilot study. 
The function then simulate data from the estimated model for the given dose levels and number of replications per dose.
Some criteria will be compauted which then can be used to compare different settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulEvalDRM(pilotData, doseLevels, numReplications, numSim,
  standardDeviation, EDp = 0.5, funcList = c("linear", "linlog",
  "exponential", "emax", "sigEmax", "logistic", "betaMod", "quadratic"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulEvalDRM_+3A_pilotdata">pilotData</code></td>
<td>
<p>a dataset presenting dose-response data from a pilot study. The first column should give the doses 
and the second one should give the response values.</p>
</td></tr>
<tr><td><code id="simulEvalDRM_+3A_doselevels">doseLevels</code></td>
<td>
<p>the dose levels which should be used in the simulation study.</p>
</td></tr>
<tr><td><code id="simulEvalDRM_+3A_numreplications">numReplications</code></td>
<td>
<p>number of replications for each of thes dose levels for the simulated data.</p>
</td></tr>
<tr><td><code id="simulEvalDRM_+3A_numsim">numSim</code></td>
<td>
<p>number of times that the simulation study should be replicated.</p>
</td></tr>
<tr><td><code id="simulEvalDRM_+3A_standarddeviation">standardDeviation</code></td>
<td>
<p>standard deviation of the generated response.</p>
</td></tr>
<tr><td><code id="simulEvalDRM_+3A_edp">EDp</code></td>
<td>
<p>scalar in (0,1), indicatign with EDp should be computed to compare different models, default is 0.5 (ED50).</p>
</td></tr>
<tr><td><code id="simulEvalDRM_+3A_funclist">funcList</code></td>
<td>
<p>string vector with models for data generation and fitting, should be selected from 
c(&quot;linear&quot;, &quot;linlog&quot;, &quot;exponential&quot;, &quot;emax&quot;, &quot;sigEmax&quot;, &quot;logistic&quot;, &quot;betaMod&quot;,&quot;quadratic&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following elements
</p>
<p>estEDp a list of length of funcList providing the estimated EDp from models fitted to data generated from each model in funcList
realEDp a vector of length funcList, the EDp's computed based on the estimated parameters from different models fitted to pilotData 
bestModel a list of length funcList, a frequency table of best selected model for data generated from each model in funcList
meanEDp a matrix showing mean of estimated EDp's averaged over numSim replications.
biasEDp a matrix showing bias of estimated EDp's averaged over numSim replications.
mseEDp a matrix showing MSE of estimated EDp's averaged over numSim replications.
varEDp a matrix showing variance of estimated EDp's averaged over numSim replications.
relativeBiasEDp a matrix showing relative bias of estimated EDp's averaged over numSim replications.
absBiasEDp a matrix showing absolute bias of estimated EDp's averaged over numSim replications.
absRelativeBiasEDp a matrix showing absolute bias of estimated EDp's averaged over numSim replications.
averagaedAIC a matrix showing AIC's of different models averaged over numSim replications. 
quantity2Plot which if needed will be passed to plot method.
</p>
<p>The output of simulEvalDRM can be passed to the function plotSimulDRM
to plot a heatmap for the desired the quantity of interest. Possible quantities
are (&quot;mean&quot;, &quot;bias&quot;, &quot;mse&quot;, &quot;variance&quot;, &quot;relativeBias&quot;, 
&quot;absBias&quot;, &quot;absRelativeBias&quot;)
</p>


<h3>Author(s)</h3>

<p>Vahid Nassiri and Yimer Wasihun.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## gnerating data, a sample of size 20
set.seed(11)
doses2Use &lt;-  c(0, 5, 20)
numRep2Use &lt;- c(3, 3, 3)
generatedData &lt;- cbind(rep(1,sum(numRep2Use)),
MCPMod::genDFdata("logistic",c(5, 3, 10, 0.05), doses2Use,
 numRep2Use, 1), 
		matrix(rnorm(1*sum(numRep2Use)), sum(numRep2Use), 1))
colnames(generatedData) &lt;- c("ID", "dose", "response", "x1")
for (iGen in 2:20){
genData0 &lt;- cbind(rep(iGen,sum(numRep2Use)), 
MCPMod::genDFdata("logistic",c(5, 3, 10, 0.05), doses2Use, 
numRep2Use, 1), 
			matrix(rnorm(1*sum(numRep2Use)), sum(numRep2Use), 1))
	colnames(genData0) &lt;- c("ID", "dose", "response", "x1")
	generatedData &lt;- rbind(generatedData, genData0)
}
simRes &lt;- simulEvalDRM (pilotData = 
generatedData[generatedData$ID == 2, c(2,3)], 
doseLevels = c(0, 4, 20), 
		numReplications = c(6, 3, 3), numSim = 10, 
standardDeviation = 1, EDp = 0.5,
		funcList = c("linlog", "emax", "sigEmax", "logistic"))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
