<!DOCTYPE html><html lang="en"><head><title>Help for package gRain</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gRain}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compileCPT'><p>Compile conditional probability tables / cliques potentials.</p></a></li>
<li><a href='#components_extract'><p>Extract conditional probabilities and clique potentials from</p>
data.</a></li>
<li><a href='#components_gather'><p>Compile conditional probability tables / cliques potentials.</p></a></li>
<li><a href='#cpt'><p>Create conditional probability tables (CPTs)</p></a></li>
<li><a href='#example_chest'><p>Chest clinic example</p></a></li>
<li><a href='#example_grass'><p>Wet grass example</p></a></li>
<li><a href='#finding'><p>Set, retrieve, and retract finding in Bayesian network.</p></a></li>
<li><a href='#generics'><p>gRain generics</p></a></li>
<li><a href='#grain_compile'><p>Compile Bayesian network.</p></a></li>
<li><a href='#grain_evidence'><p>Set, update and remove evidence.</p></a></li>
<li><a href='#grain_predict'><p>Make predictions from Bayesian network</p></a></li>
<li><a href='#grain_propagate'><p>Propagate in a Bayesian network</p></a></li>
<li><a href='#grain-main'><p>Create Bayesian network</p></a></li>
<li><a href='#grain-simulate'><p>Simulate from Bayesian network</p></a></li>
<li><a href='#internal-grain'><p>Internal functions for the gRain package</p></a></li>
<li><a href='#load-save-hugin'><p>Load and save Hugin net files</p></a></li>
<li><a href='#logical'><p>Conditional probability tables based on logical dependencies</p></a></li>
<li><a href='#mendel'><p>Mendelian segregation</p></a></li>
<li><a href='#old_components_extract'><p>Extract conditional probabilities and clique potentials from</p>
data.</a></li>
<li><a href='#old_grain_evidence'><p>Set, update and remove evidence.</p></a></li>
<li><a href='#old_replace_cpt'><p>Replace CPTs in Bayesian network</p></a></li>
<li><a href='#querygrain'><p>Query a Bayesian network</p></a></li>
<li><a href='#repeat_pattern'><p>Create repeated patterns in Bayesian networks</p></a></li>
<li><a href='#repeatPattern'><p>Create repeated patterns in Bayesian networks</p></a></li>
<li><a href='#replace_cpt'><p>Replace CPTs in Bayesian network</p></a></li>
<li><a href='#simplify_query'><p>Simplify output query to a Bayesian network</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.4.5</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Networks</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Søren Højsgaard &lt;sorenh@math.aau.dk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Probability propagation in Bayesian networks, also known as graphical independence networks. Documentation
    of the package is provided in vignettes included in the package and in
    the paper by Højsgaard (2012, &lt;<a href="https://doi.org/10.18637%2Fjss.v046.i10">doi:10.18637/jss.v046.i10</a>&gt;).
    See 'citation("gRain")' for details. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0), methods, gRbase (&ge; 2.0.2),</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bnlearn, gRim, knitr, markdown, microbenchmark, testthat (&ge;
2.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, stats4, broom, Rcpp (&ge; 0.11.1)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://people.math.aau.dk/~sorenh/software/gR/">https://people.math.aau.dk/~sorenh/software/gR/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.11.1), RcppArmadillo, RcppEigen, gRbase</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>Yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-17 20:38:00 UTC; sorenh</td>
</tr>
<tr>
<td>Author:</td>
<td>Søren Højsgaard [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-17 21:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='compileCPT'>Compile conditional probability tables / cliques potentials.</h2><span id='topic+compileCPT'></span><span id='topic+compilePOT'></span>

<h3>Description</h3>

<p>Compile conditional probability tables / cliques
potentials as a preprocessing step for creating a graphical
independence network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compileCPT(x, ..., forceCheck = TRUE)

compilePOT(x, ..., forceCheck = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compileCPT_+3A_x">x</code></td>
<td>
<p>To <code>compileCPT</code> x is a list of conditional
probability tables; to <code>compilePOT</code>, x is a list of clique
potentials.</p>
</td></tr>
<tr><td><code id="compileCPT_+3A_...">...</code></td>
<td>
<p>Additional arguments; currently not used.</p>
</td></tr>
<tr><td><code id="compileCPT_+3A_forcecheck">forceCheck</code></td>
<td>
<p>Controls if consistency checks of the probability
tables should be made.</p>
</td></tr>
</table>


<h3>Details</h3>

<div class="sourceCode"><pre>* `compileCPT` is relevant for turning a collection of
cptable's into an object from which a network can be built. For
example, when specification of a cpt is made with cptable then
the levels of the node is given but not the levels of the
parents. `compileCPT` checks that the levels of variables in
the cpt's are consistent and also that the specifications
define a dag.

* `compilePOT` is not of direct relevance for the
user for the moment. However, the elements of the input should
be arrays which define a chordal undirected graph and the
arrays should, if multiplied, form a valid probability density.
</pre></div>


<h3>Value</h3>

<p>A list with a class attribute.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence Networks
with the gRain Package for R. Journal of Statistical Software,
46(10), 1-26.  <a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract_cpt">extract_cpt</a></code>, <code><a href="#topic+extract_pot">extract_pot</a></code>, <code><a href="#topic+extract_marg">extract_marg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example("example_chest_cpt")
x &lt;- compile_cpt(chest_cpt)
class(x)
grain(x)

</code></pre>

<hr>
<h2 id='components_extract'>Extract conditional probabilities and clique potentials from
data.</h2><span id='topic+components_extract'></span><span id='topic+extract_cpt'></span><span id='topic+extract_pot'></span><span id='topic+extract_marg'></span><span id='topic+marg2pot'></span><span id='topic+pot2marg'></span>

<h3>Description</h3>

<p>Extract list of conditional probability tables and
list of clique potentials from data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_cpt(data_, graph, smooth = 0)

extract_pot(data_, graph, smooth = 0)

extract_marg(data_, graph, smooth = 0)

marg2pot(marg_rep)

pot2marg(pot_rep)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="components_extract_+3A_data_">data_</code></td>
<td>
<p>A named array or a dataframe.</p>
</td></tr>
<tr><td><code id="components_extract_+3A_graph">graph</code></td>
<td>
<p>An <code>igraph</code> object or a list or formula which can be
turned into a <code>igraph</code> object by calling <code>ug</code> or
<code>dag</code>. For <code>extract_cpt</code>, graph must be/define a DAG while for
<code>extract_pot</code>, graph must be/define undirected triangulated graph.</p>
</td></tr>
<tr><td><code id="components_extract_+3A_smooth">smooth</code></td>
<td>
<p>See 'details' below.</p>
</td></tr>
<tr><td><code id="components_extract_+3A_marg_rep">marg_rep</code></td>
<td>
<p>An object of class <code>marg_rep</code></p>
</td></tr>
<tr><td><code id="components_extract_+3A_pot_rep">pot_rep</code></td>
<td>
<p>An object of class <code>pot_representation</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>smooth</code> is non-zero then <code>smooth</code> is added
to all cell counts before normalization takes place.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>extract_cpt</code>: A list of conditional probability tables.
</p>
</li>
<li> <p><code>extract_pot</code>: A list of clique potentials.
</p>
</li>
<li> <p><code>extract_marg</code>: A list of clique marginals.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence Networks
with the gRain Package for R. Journal of Statistical Software,
46(10), 1-26.  <a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compileCPT">compileCPT</a></code>, <code><a href="#topic+compilePOT">compilePOT</a></code>,
<code><a href="#topic+grain">grain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Extract cpts / clique potentials from data and graph
# specification and create network. There are different ways:

data(lizard, package="gRbase")

# DAG: height &lt;- species -&gt; diam
daG &lt;- dag(~species + height:species + diam:species, result="igraph")

# UG : [height:species][diam:species]
uG  &lt;- ug(~height:species + diam:species, result="igraph")

pt &lt;- extract_pot(lizard, ~height:species + diam:species) 
cp &lt;- extract_cpt(lizard, ~species + height:species + diam:species)

pt
cp

# Both specify the same probability distribution
tabListMult(pt) |&gt; as.data.frame.table()
tabListMult(cp) |&gt; as.data.frame.table()

## Not run: 
# Bayesian networks can be created as
bn.uG   &lt;- grain(pt)
bn.daG  &lt;- grain(cp)

# The steps above are wrapped into a convenience method which
# builds a network from at graph and data.
bn.uG   &lt;- grain(uG, data=lizard)
bn.daG  &lt;- grain(daG, data=lizard)

## End(Not run)

</code></pre>

<hr>
<h2 id='components_gather'>Compile conditional probability tables / cliques potentials.</h2><span id='topic+components_gather'></span><span id='topic+compile_cpt'></span><span id='topic+parse_cpt+2C'></span><span id='topic+parse_cpt.xtabs+2C'></span><span id='topic+parse_cpt.default'></span><span id='topic+compile_pot'></span><span id='topic+parse_cpt'></span>

<h3>Description</h3>

<p>Compile conditional probability tables / cliques
potentials as a preprocessing step for creating a graphical
independence network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compile_cpt(x, ..., forceCheck = TRUE)

compile_pot(x, ..., forceCheck = TRUE)

parse_cpt(xi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="components_gather_+3A_x">x</code></td>
<td>
<p>To <code>compileCPT</code> x is a list of conditional
probability tables; to <code>compilePOT</code>, x is a list of clique
potentials.</p>
</td></tr>
<tr><td><code id="components_gather_+3A_...">...</code></td>
<td>
<p>Additional arguments; currently not used.</p>
</td></tr>
<tr><td><code id="components_gather_+3A_forcecheck">forceCheck</code></td>
<td>
<p>Controls if consistency checks of the probability
tables should be made.</p>
</td></tr>
<tr><td><code id="components_gather_+3A_xi">xi</code></td>
<td>
<p>cpt in some representation</p>
</td></tr>
</table>


<h3>Details</h3>

<div class="sourceCode"><pre>* `compileCPT` is relevant for turning a collection of
cptable's into an object from which a network can be built. For
example, when specification of a cpt is made with cptable then
the levels of the node is given but not the levels of the
parents. `compileCPT` checks that the levels of variables in
the cpt's are consistent and also that the specifications
define a dag.

* `compilePOT` is not of direct relevance for the
user for the moment. However, the elements of the input should
be arrays which define a chordal undirected graph and the
arrays should, if multiplied, form a valid probability density.
</pre></div>


<h3>Value</h3>

<p>A list with a class attribute.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence Networks
with the gRain Package for R. Journal of Statistical Software,
46(10), 1-26.  <a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract_cpt">extract_cpt</a></code>, <code><a href="#topic+extract_pot">extract_pot</a></code>, <code><a href="#topic+extract_marg">extract_marg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example("example_chest_cpt")
x &lt;- compile_cpt(chest_cpt)
class(x)
grain(x)

</code></pre>

<hr>
<h2 id='cpt'>Create conditional probability tables (CPTs)</h2><span id='topic+cpt'></span><span id='topic+cptable'></span>

<h3>Description</h3>

<p>Creates conditional probability tables of the form
p(v|pa(v)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpt(names, levels, values, normalize = "first", smooth = 0)

cptable(vpar, levels = NULL, values = NULL, normalize = TRUE, smooth = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpt_+3A_names">names</code></td>
<td>
<p>Specifications of the names in P(v|pa1,...pak). See
section 'details' for information about the form of the
argument.</p>
</td></tr>
<tr><td><code id="cpt_+3A_levels">levels</code></td>
<td>

<ol>
<li><p> a list with specification of the levels of the
factors in <code>names</code> or 2) a vector with number of levels of
the factors in <code>names</code>. See 'examples' below.
</p>
</li></ol>
</td></tr>
<tr><td><code id="cpt_+3A_values">values</code></td>
<td>
<p>Probabilities; recycled if necessary. Regarding the
order, please see section 'details' and the examples.</p>
</td></tr>
<tr><td><code id="cpt_+3A_normalize">normalize</code></td>
<td>
<p>See 'details' below.</p>
</td></tr>
<tr><td><code id="cpt_+3A_smooth">smooth</code></td>
<td>
<p>Should values be smoothed, see 'Details' below.</p>
</td></tr>
<tr><td><code id="cpt_+3A_vpar">vpar</code></td>
<td>
<p>node an its parents</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cptable</code> is simply a wrapper for <code>cpt</code> and the functions can hence
be used synonymously.
</p>
<p>If <code>smooth</code> is non&ndash;zero, then this value is added to all cells <strong>before</strong>
normalization takes place.
</p>
<p>Regarding the form of the argument <code>names</code>: To specify
<code class="reqn">P(a|b,c)</code> one may write <code>~a|b:c</code>, <code>~a:b:c</code>,
<code>~a|b+c</code>, <code>~a+b+c</code> or <code>c("a","b","c")</code>. Internally,
the last form is used. Notice that the <code>+</code> and <code>:</code>
operator are used as a separators only. The order of the variables IS
important so the operators DO NOT commute.
</p>
<p>The first variable in <code>levels</code> varies fastest.
</p>


<h3>Value</h3>

<p>An array.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence
Networks with the gRain Package for R. Journal of Statistical
Software, 46(10), 1-26.
<a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+andtable">andtable</a></code>, <code><a href="#topic+ortable">ortable</a></code>,
<code><a href="#topic+extract_cpt">extract_cpt</a></code>, <code><a href="#topic+compileCPT">compileCPT</a></code>,
<code><a href="#topic+extract_cpt">extract_cpt</a></code>, <code><a href="#topic+compilePOT">compilePOT</a></code>,
<code><a href="#topic+grain">grain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## See the wet grass example at
## https://en.wikipedia.org/wiki/Bayesian_network

yn &lt;- c("yes", "no")
ssp &lt;- list(R=yn, S=yn, G=yn) # state space

## Different forms
t1 &lt;- cpt(c("S", "R"), levels=ssp,     values=c(.01, .99, .4, .6))
t2 &lt;- cpt(~S:R,        levels=ssp,     values=c(.01, .99, .4, .6))
t3 &lt;- cpt(~S:R,        levels=c(2, 2), values=c(.01, .99, .4, .6))
t4 &lt;- cpt(~S:R,        levels=yn,      values=c(.01, .99, .4, .6))
t1; t2; t3; t4

varNames(t1)
valueLabels(t1)

## Wet grass example
ssp &lt;- list(R=yn, S=yn, G=yn) # state space
p.R    &lt;- cpt(~R,     levels=ssp, values=c(.2, .8))
p.S_R  &lt;- cpt(~S:R,   levels=ssp, values=c(.01, .99, .4, .6))
p.G_SR &lt;- cpt(~G:S:R, levels=ssp, values=c(.99, .01, .8, .2, .9, .1, 0, 1))

wet.cpt &lt;- compileCPT(p.R, p.S_R, p.G_SR)
wet.cpt
wet.cpt$S # etc

# A Bayesian network is created with:
wet.bn &lt;- grain(wet.cpt)

</code></pre>

<hr>
<h2 id='example_chest'>Chest clinic example</h2><span id='topic+example_chest'></span><span id='topic+example_chest_cpt'></span>

<h3>Description</h3>

<p>Conditional probability tables for the chest clinic example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
yn   &lt;- c("yes", "no")
a    &lt;- cpt(~asia, values=c(1,99),levels=yn)
t.a  &lt;- cpt(~tub|asia, values=c(5,95,1,99),levels=yn)
s    &lt;- cpt(~smoke, values=c(5,5), levels=yn)
l.s  &lt;- cpt(~lung|smoke, values=c(1,9,1,99), levels=yn)
b.s  &lt;- cpt(~bronc|smoke, values=c(6,4,3,7), levels=yn)
e.lt &lt;- cpt(~either|lung:tub,values=c(1,0,1,0,1,0,0,1),levels=yn)
x.e  &lt;- cpt(~xray|either, values=c(98,2,5,95), levels=yn)
d.be &lt;- cpt(~dysp|bronc:either, values=c(9,1,7,3,8,2,1,9), levels=yn)

chest_cpt &lt;- list(a, t.a, s, l.s, b.s, e.lt, x.e, d.be)
## bn &lt;- grain(compile_cpt(chest_cpt))
</code></pre>

<hr>
<h2 id='example_grass'>Wet grass example</h2><span id='topic+example_grass'></span><span id='topic+example_grass_cpt'></span>

<h3>Description</h3>

<p>Conditional probability tables for the wet grass example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>yn &lt;- c("yes", "no")
p.R    &lt;- cpt(~R, values=c(.2, .8), levels=yn)
p.S_R  &lt;- cpt(~S:R, values=c(.01, .99, .4, .6), levels=yn)
p.G_SR &lt;- cpt(~G:S:R, values=c(.99, .01, .8, .2, .9, .1, 0, 1), levels=yn)

grass_cpt &lt;- list(p.R, p.S_R, p.G_SR)
## bn &lt;- grain(compile_cpt(grass_cpt))
</code></pre>

<hr>
<h2 id='finding'>Set, retrieve, and retract finding in Bayesian network.</h2><span id='topic+finding'></span><span id='topic+setFinding'></span><span id='topic+retractFinding'></span><span id='topic+getFinding'></span><span id='topic+pFinding'></span>

<h3>Description</h3>

<p>Set, retrieve, and retract finding in Bayesian
network.  NOTICE: The functions described here are kept only
for backward compatibility; please use the corresponding
evidence-functions in the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setFinding(object, nodes = NULL, states = NULL, flist = NULL, propagate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="finding_+3A_object">object</code></td>
<td>
<p>A &quot;grain&quot; object</p>
</td></tr>
<tr><td><code id="finding_+3A_nodes">nodes</code></td>
<td>
<p>A vector of nodes</p>
</td></tr>
<tr><td><code id="finding_+3A_states">states</code></td>
<td>
<p>A vector of states (of the nodes given by 'nodes')</p>
</td></tr>
<tr><td><code id="finding_+3A_flist">flist</code></td>
<td>
<p>An alternative way of specifying findings, see
examples below.</p>
</td></tr>
<tr><td><code id="finding_+3A_propagate">propagate</code></td>
<td>
<p>Should the network be propagated?</p>
</td></tr>
</table>


<h3>Note</h3>

<p>NOTICE: The functions described here are kept only for
backward compatibility; please use the corresponding
evidence-functions in the future:
</p>
<p><code>setEvidence()</code> is an improvement of <code>setFinding()</code> (and as such
<code>setFinding</code> is obsolete). Users are recommended to use
<code>setEvidence()</code> in the future.
</p>
<p><code>setEvidence()</code> allows to specification of &quot;hard evidence&quot; (specific
values for variables) and likelihood evidence (also known as virtual
evidence) for variables.
</p>
<p>The syntax of <code>setEvidence()</code> may change in the future.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence Networks
with the gRain Package for R. Journal of Statistical Software, 46(10), 1-26.
<a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setEvidence">setEvidence</a></code>, <code><a href="#topic+getEvidence">getEvidence</a></code>,
<code><a href="#topic+retractEvidence">retractEvidence</a></code>, <code><a href="#topic+pEvidence">pEvidence</a></code>,
<code><a href="#topic+querygrain">querygrain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## setFindings
yn &lt;- c("yes", "no")
a    &lt;- cpt(~asia, values=c(1, 99),levels=yn)
t.a  &lt;- cpt(~tub+asia, values=c(5, 95, 1, 99),levels=yn)
s    &lt;- cpt(~smoke, values=c(5,5), levels=yn)
l.s  &lt;- cpt(~lung+smoke, values=c(1, 9, 1, 99), levels=yn)
b.s  &lt;- cpt(~bronc+smoke, values=c(6, 4, 3, 7), levels=yn)
e.lt &lt;- cpt(~either+lung+tub,values=c(1, 0, 1, 0, 1, 0, 0, 1),levels=yn)
x.e  &lt;- cpt(~xray+either, values=c(98, 2, 5, 95), levels=yn)
d.be &lt;- cpt(~dysp+bronc+either, values=c(9, 1, 7, 3, 8, 2, 1, 9), levels=yn)
chest.cpt &lt;- compileCPT(a, t.a, s, l.s, b.s, e.lt, x.e, d.be)
chest.bn &lt;- grain(chest.cpt)

## These two forms are equivalent
bn1 &lt;- setFinding(chest.bn, nodes=c("chest", "xray"), states=c("yes", "yes"))
bn2 &lt;- setFinding(chest.bn, flist=list(c("chest", "yes"), c("xray", "yes")))

getFinding(bn1)
getFinding(bn2)

pFinding(bn1)
pFinding(bn2)

bn1 &lt;- retractFinding(bn1, nodes="asia")
bn2 &lt;- retractFinding(bn2, nodes="asia")

getFinding(bn1)
getFinding(bn2)

pFinding(bn1)
pFinding(bn2)


</code></pre>

<hr>
<h2 id='generics'>gRain generics</h2><span id='topic+generics'></span><span id='topic+nodeNames'></span><span id='topic+nodeNames.grain'></span><span id='topic+nodeStates'></span><span id='topic+nodeStates.grain'></span><span id='topic+universe'></span><span id='topic+universe.grain'></span><span id='topic+isCompiled'></span><span id='topic+isPropagated'></span><span id='topic+vpar.cpt_spec'></span><span id='topic+vpar.cpt_grain'></span><span id='topic+rip.grain'></span>

<h3>Description</h3>

<p>Generic functions etc for the gRain package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodeNames(object)

## S3 method for class 'grain'
nodeNames(object)

nodeStates(object, nodes = nodeNames(object))

## S3 method for class 'grain'
nodeStates(object, nodes = nodeNames(object))

universe(object, ...)

## S3 method for class 'grain'
universe(object, ...)

isCompiled(object)

isPropagated(object)

## S3 method for class 'cpt_spec'
vpar(object, ...)

## S3 method for class 'cpt_grain'
vpar(object, ...)

## S3 method for class 'grain'
rip(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generics_+3A_object">object</code></td>
<td>
<p>A relevant object.</p>
</td></tr>
<tr><td><code id="generics_+3A_nodes">nodes</code></td>
<td>
<p>Some nodes of the object.</p>
</td></tr>
<tr><td><code id="generics_+3A_...">...</code></td>
<td>
<p>Additional arguments; currently not used.</p>
</td></tr>
</table>

<hr>
<h2 id='grain_compile'>Compile Bayesian network.</h2><span id='topic+grain_compile'></span><span id='topic+compile.grain'></span><span id='topic+compile.cpt_grain'></span><span id='topic+compile.pot_grain'></span>

<h3>Description</h3>

<p>Compiles a Bayesian network. This means creating a
junction tree and establishing clique potentials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grain'
compile(
  object,
  propagate = FALSE,
  tug = NULL,
  root = NULL,
  control = object$control,
  details = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grain_compile_+3A_object">object</code></td>
<td>
<p>A grain object.</p>
</td></tr>
<tr><td><code id="grain_compile_+3A_propagate">propagate</code></td>
<td>
<p>If TRUE the network is also propagated meaning
that the cliques of the junction tree are calibrated to each
other.</p>
</td></tr>
<tr><td><code id="grain_compile_+3A_tug">tug</code></td>
<td>
<p>A triangulated undirected graph.</p>
</td></tr>
<tr><td><code id="grain_compile_+3A_root">root</code></td>
<td>
<p>A set of variables which must be in the root of the
junction tree</p>
</td></tr>
<tr><td><code id="grain_compile_+3A_control">control</code></td>
<td>
<p>Controlling the compilation process.</p>
</td></tr>
<tr><td><code id="grain_compile_+3A_details">details</code></td>
<td>
<p>For debugging info. Do not use.</p>
</td></tr>
<tr><td><code id="grain_compile_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A compiled Bayesian network; an object of class
<code>grain</code>.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence
Networks with the gRain Package for R. Journal of Statistical
Software, 46(10), 1-26.
<a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grain">grain</a></code>, <code><a href="gRbase.html#topic+propagate">propagate</a></code>,
<code><a href="#topic+propagate.grain">propagate.grain</a></code>,
<code><a href="gRbase.html#topic+triangulate">triangulate</a></code>, <code><a href="gRbase.html#topic+rip">rip</a></code>,
<code><a href="gRbase.html#topic+junctionTree">junctionTree</a></code>
</p>

<hr>
<h2 id='grain_evidence'>Set, update and remove evidence.</h2><span id='topic+grain_evidence'></span><span id='topic+evidence_get'></span><span id='topic+evidence_add'></span><span id='topic+evidence_drop'></span><span id='topic+evidence_prob'></span>

<h3>Description</h3>

<p>Set, update and remove evidence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evidence_add(object, evidence, propagate = TRUE, details = 0)

evidence_get(object, short = TRUE)

evidence_drop(object, nodes = NULL, propagate = TRUE)

evidence_prob(object, evidence = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grain_evidence_+3A_object">object</code></td>
<td>
<p>A &quot;grain&quot; object</p>
</td></tr>
<tr><td><code id="grain_evidence_+3A_evidence">evidence</code></td>
<td>
<p>A list of name=value. See examples below.</p>
</td></tr>
<tr><td><code id="grain_evidence_+3A_propagate">propagate</code></td>
<td>
<p>Should the network be propagated?</p>
</td></tr>
<tr><td><code id="grain_evidence_+3A_details">details</code></td>
<td>
<p>Debugging information</p>
</td></tr>
<tr><td><code id="grain_evidence_+3A_short">short</code></td>
<td>
<p>If TRUE a dataframe with a summary is returned;
otherwise a list with all details.</p>
</td></tr>
<tr><td><code id="grain_evidence_+3A_nodes">nodes</code></td>
<td>
<p>A vector of nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of tables with potentials.
</p>


<h3>Note</h3>

<p><code>setEvidence()</code> is an improvement of <code>setFinding()</code>
(and as such <code>setFinding</code> is obsolete). Users are
recommended to use <code>setEvidence()</code> in the future.
</p>
<p><code>setEvidence()</code> allows to specification of &quot;hard evidence&quot; (specific
values for variables) and likelihood evidence (also known as virtual
evidence) for variables.
</p>
<p>The syntax of <code>setEvidence()</code> may change in the future.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence Networks
with the gRain Package for R. Journal of Statistical Software,
46(10), 1-26.  <a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setFinding">setFinding</a></code>, <code><a href="#topic+getFinding">getFinding</a></code>,
<code><a href="#topic+retractFinding">retractFinding</a></code>, <code><a href="#topic+pFinding">pFinding</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example("grain")
chest_bn &lt;- grain(compileCPT(chest_cpt))

bn2 &lt;- chest_bn |&gt; evidence_add(list(asia="yes", xray="yes"))
bn3 &lt;- chest_bn |&gt; evidence_add(list(asia=c(0.8, 0.1), xray="yes"))

bn2 |&gt; evidence_get()
bn3 |&gt; evidence_get()

bn2 |&gt; evidence_prob()
bn3 |&gt; evidence_prob()

bn2 |&gt; evidence_drop("xray")
bn3 |&gt; evidence_drop("xray")

bn2 |&gt; evidence_drop("xray") |&gt; evidence_get()
bn3 |&gt; evidence_drop("xray") |&gt; evidence_get()


## For backward compatibility these functions are available now but
# may be deprecated later.
bb2 &lt;- setEvidence(chest_bn, c("asia", "xray"), c("yes", "yes"))
bb3 &lt;- setEvidence(chest_bn, c("asia", "xray"), list(c(0.8, 0.2), "yes"))
bb4 &lt;- setFinding(chest_bn, c("asia", "xray"), c("yes", "yes"))

bb2 |&gt; getEvidence()
bb3 |&gt; getEvidence()

bb2 |&gt; retractEvidence("xray")
bb3 |&gt; retractEvidence("xray")

bb2 |&gt; pEvidence()
bb3 |&gt; pEvidence()

bb2 |&gt; retractEvidence("xray") |&gt; getEvidence()
bb3 |&gt; retractEvidence("xray") |&gt; getEvidence()
</code></pre>

<hr>
<h2 id='grain_predict'>Make predictions from Bayesian network</h2><span id='topic+grain_predict'></span><span id='topic+predict.grain'></span>

<h3>Description</h3>

<p>Makes predictions (either as the most likely state or
as the conditional distributions) of variables conditional on
finding (evidence) on other variables in an independence
network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grain'
predict(
  object,
  response,
  predictors = setdiff(names(newdata), response),
  newdata,
  type = "class",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grain_predict_+3A_object">object</code></td>
<td>
<p>A grain object</p>
</td></tr>
<tr><td><code id="grain_predict_+3A_response">response</code></td>
<td>
<p>A vector of response variables to make predictions
on</p>
</td></tr>
<tr><td><code id="grain_predict_+3A_predictors">predictors</code></td>
<td>
<p>A vector of predictor variables to make
predictions from.  Defaults to all variables that are note
responses.</p>
</td></tr>
<tr><td><code id="grain_predict_+3A_newdata">newdata</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="grain_predict_+3A_type">type</code></td>
<td>
<p>If &quot;class&quot;, the most probable class is returned; if
&quot;distribution&quot; the conditional distribution is returned.</p>
</td></tr>
<tr><td><code id="grain_predict_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components </p>
<table role = "presentation">
<tr><td><code>pred</code></td>
<td>
<p>A list with the
predictions</p>
</td></tr> <tr><td><code>pFinding</code></td>
<td>
<p>A vector with the probability of
the finding (evidence) on which the prediction is based</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence Networks
with the gRain Package for R. Journal of Statistical Software,
46(10), 1-26.  <a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grain">grain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example("example_chest_cpt")
data(chestSim500)

chest.bn &lt;- grain(compileCPT(chest_cpt))
nd &lt;- chestSim500[1:4]

predict(chest.bn, response="bronc", newdata=nd)
predict(chest.bn, response="bronc", newdata=nd, type="distribution")

</code></pre>

<hr>
<h2 id='grain_propagate'>Propagate in a Bayesian network</h2><span id='topic+grain_propagate'></span><span id='topic+propagate.grain'></span><span id='topic+propagateLS'></span><span id='topic+propagateLS__'></span>

<h3>Description</h3>

<p>Propagation refers to calibrating the cliques of the
junction tree so that the clique potentials are consistent on
their intersections; refer to the reference below for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grain'
propagate(object, details = object$details, engine = "cpp", ...)

propagateLS(cq_pot_list, rip, initialize = TRUE, details = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grain_propagate_+3A_object">object</code></td>
<td>
<p>A grain object</p>
</td></tr>
<tr><td><code id="grain_propagate_+3A_details">details</code></td>
<td>
<p>For debugging info</p>
</td></tr>
<tr><td><code id="grain_propagate_+3A_engine">engine</code></td>
<td>
<p>Either &quot;R&quot; or &quot;cpp&quot;; &quot;cpp&quot; is the default and the
fastest.</p>
</td></tr>
<tr><td><code id="grain_propagate_+3A_...">...</code></td>
<td>
<p>Currently not used</p>
</td></tr>
<tr><td><code id="grain_propagate_+3A_cq_pot_list">cq_pot_list</code></td>
<td>
<p>List of clique potentials</p>
</td></tr>
<tr><td><code id="grain_propagate_+3A_rip">rip</code></td>
<td>
<p>A rip ordering</p>
</td></tr>
<tr><td><code id="grain_propagate_+3A_initialize">initialize</code></td>
<td>
<p>Always true.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>propagate</code> method invokes <code>propagateLS</code>
which is a pure R implementation of the Lauritzen-Spiegelhalter
algorithm. The c++ based version is several times faster than
the purely R based version.
</p>


<h3>Value</h3>

<p>A compiled and propagated grain object.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence Networks
with the gRain Package for R. Journal of Statistical Software,
46(10), 1-26.  <a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grain">grain</a></code>, <code><a href="gRbase.html#topic+compile">compile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example("grain")

## Uncompiled and unpropageted network:
bn0  &lt;- grain(chest_cpt, compile=FALSE)
bn0
## Compiled but unpropageted network:
bn1  &lt;- compile(bn0, propagate=FALSE)
## Compiled and propagated network
bn2  &lt;- propagate(bn1)
bn2
## Default is that networks are compiled but not propagated at creation time:
bn3  &lt;- grain(chest_cpt) 
bn3 
</code></pre>

<hr>
<h2 id='grain-main'>Create Bayesian network</h2><span id='topic+grain-main'></span><span id='topic+grain'></span><span id='topic+grain.cpt_spec'></span><span id='topic+grain.CPTspec'></span><span id='topic+grain.pot_spec'></span><span id='topic+grain.igraph'></span><span id='topic+grain.dModel'></span>

<h3>Description</h3>

<p>Create Bayesian network  (grain objects (graphical independence network)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grain(x, ...)

## S3 method for class 'cpt_spec'
grain(x, control = list(), smooth = 0, compile = TRUE, details = 0, ...)

## S3 method for class 'CPTspec'
grain(x, control = list(), smooth = 0, compile = TRUE, details = 0, ...)

## S3 method for class 'pot_spec'
grain(x, control = list(), smooth = 0, compile = TRUE, details = 0, ...)

## S3 method for class 'igraph'
grain(
  x,
  control = list(),
  smooth = 0,
  compile = TRUE,
  details = 0,
  data = NULL,
  ...
)

## S3 method for class 'dModel'
grain(
  x,
  control = list(),
  smooth = 0,
  compile = TRUE,
  details = 0,
  data = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grain-main_+3A_x">x</code></td>
<td>
<p>An argument to build an independence network
from. Typically a list of conditional probability tables, a DAG
or an undirected graph. In the two latter cases, data must also
be provided.</p>
</td></tr>
<tr><td><code id="grain-main_+3A_...">...</code></td>
<td>
<p>Additional arguments, currently not used.</p>
</td></tr>
<tr><td><code id="grain-main_+3A_control">control</code></td>
<td>
<p>A list defining controls, see 'details' below.</p>
</td></tr>
<tr><td><code id="grain-main_+3A_smooth">smooth</code></td>
<td>
<p>A (usually small) number to add to the counts of a
table if the grain is built from a graph plus a dataset.</p>
</td></tr>
<tr><td><code id="grain-main_+3A_compile">compile</code></td>
<td>
<p>Should network be compiled.</p>
</td></tr>
<tr><td><code id="grain-main_+3A_details">details</code></td>
<td>
<p>Debugging information.</p>
</td></tr>
<tr><td><code id="grain-main_+3A_data">data</code></td>
<td>
<p>An optional data set (currently must be an array/table)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If 'smooth' is non-zero then entries of 'values' which a
zero are replaced by the value of 'smooth' - BEFORE any
normalization takes place.
</p>


<h3>Value</h3>

<p>An object of class &quot;grain&quot;
</p>


<h3>Note</h3>

<p>A change from earlier versions of this package is that grain
objects are now compiled upon creation.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence
Networks with the gRain Package for R. Journal of Statistical
Software, 46(10), 1-26.
<a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cptable">cptable</a></code>, <code><a href="#topic+compile.grain">compile.grain</a></code>,
<code><a href="#topic+propagate.grain">propagate.grain</a></code>, <code><a href="#topic+setFinding">setFinding</a></code>,
<code><a href="#topic+setEvidence">setEvidence</a></code>, <code><a href="#topic+getFinding">getFinding</a></code>,
<code><a href="#topic+pFinding">pFinding</a></code>, <code><a href="#topic+retractFinding">retractFinding</a></code>,
<code><a href="#topic+extract_cpt">extract_cpt</a></code>, <code><a href="#topic+extract_pot">extract_pot</a></code>,
<code><a href="#topic+compileCPT">compileCPT</a></code>, <code><a href="#topic+compilePOT">compilePOT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Create network from conditional probability tables CPTs:

yn   &lt;- c("yes", "no")
a    &lt;- cpt(~asia,                  values=c(1,99), levels=yn)
t.a  &lt;- cpt(~tub + asia,            values=c(5,95,1,99), levels=yn)
s    &lt;- cpt(~smoke,                 values=c(5,5), levels=yn)
l.s  &lt;- cpt(~lung + smoke,          values=c(1,9,1,99), levels=yn)
b.s  &lt;- cpt(~bronc + smoke,         values=c(6,4,3,7), levels=yn)
e.lt &lt;- cpt(~either + lung + tub,   values=c(1,0,1,0,1,0,0,1), levels=yn)
x.e  &lt;- cpt(~xray + either,         values=c(98,2,5,95), levels=yn)
d.be &lt;- cpt(~dysp + bronc + either, values=c(9,1,7,3,8,2,1,9), levels=yn)
cpt_list  &lt;- list(a, t.a, s, l.s, b.s, e.lt, x.e, d.be)
chest_cpt &lt;- compileCPT(cpt_list)
## Alternative: chest_cpt &lt;- compileCPT(a, t.a, s, l.s, b.s, e.lt, x.e, d.be)

chest_bn  &lt;- grain(chest_cpt)

## Create network from data and graph specification.

data(lizard, package="gRbase")

## From a DAG: height &lt;- species -&gt; diam
daG &lt;- dag(~species + height:species + diam:species)

## From an undirected graph UG : [height:species][diam:species]
uG  &lt;- ug(~height:species + diam:species)

liz_ug   &lt;- grain(uG, data=lizard)
liz_dag  &lt;- grain(daG, data=lizard)
</code></pre>

<hr>
<h2 id='grain-simulate'>Simulate from Bayesian network</h2><span id='topic+grain-simulate'></span><span id='topic+simulate.grain'></span>

<h3>Description</h3>

<p>Simulate data from an independence network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grain'
simulate(object, nsim = 1, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grain-simulate_+3A_object">object</code></td>
<td>
<p>An independence network.</p>
</td></tr>
<tr><td><code id="grain-simulate_+3A_nsim">nsim</code></td>
<td>
<p>Number of cases to simulate.</p>
</td></tr>
<tr><td><code id="grain-simulate_+3A_seed">seed</code></td>
<td>
<p>An optional integer controlling the random number
generation.</p>
</td></tr>
<tr><td><code id="grain-simulate_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence Networks
with the gRain Package for R. Journal of Statistical Software,
46(10), 1-26.  <a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tf &lt;- system.file("huginex", "chest_clinic.net", package = "gRain")

chest &lt;- loadHuginNet(tf, details=1)
simulate(chest,n=10) 

chest2 &lt;- setFinding(chest, c("VisitToAsia", "Dyspnoea"),
                            c("yes", "yes"))
simulate(chest2, n=10)
</code></pre>

<hr>
<h2 id='internal-grain'>Internal functions for the gRain package</h2><span id='topic+internal-grain'></span><span id='topic+getgin'></span><span id='topic+getgrain'></span><span id='topic+plot.grain'></span><span id='topic+printlist'></span><span id='topic+splitVec'></span>

<h3>Description</h3>

<p>These functions should not be called directly by the user
</p>

<hr>
<h2 id='load-save-hugin'>Load and save Hugin net files</h2><span id='topic+load-save-hugin'></span><span id='topic+loadHuginNet'></span><span id='topic+saveHuginNet'></span>

<h3>Description</h3>

<p>These functions can load a net file saved in the
'Hugin format' into R and save a network in R as a file in the
'Hugin format'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadHuginNet(file, description = NULL, details = 0)

saveHuginNet(gin, file, details = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load-save-hugin_+3A_file">file</code></td>
<td>
<p>Name of Hugin net file. Convenient to give the file the
extension '.net'</p>
</td></tr>
<tr><td><code id="load-save-hugin_+3A_description">description</code></td>
<td>
<p>A text describing the network, defaults to
<code>file</code></p>
</td></tr>
<tr><td><code id="load-save-hugin_+3A_details">details</code></td>
<td>
<p>Debugging information.</p>
</td></tr>
<tr><td><code id="load-save-hugin_+3A_gin">gin</code></td>
<td>
<p>An independence network</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>grain</code>.
</p>


<h3>Note</h3>


<ul>
<li><p> In Hugin, it is possible to specify the potential of a node as a
functional relation between other nodes.  In a .net file, such a
specification will appear as 'function' rather than as
'node'. Such a specification is not recognized by <code>loadHuginNet</code>.
</p>
</li>
<li><p> It is recommended to avoid the text <code>node</code> as part of the name of
a node.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence
Networks with the gRain Package for R. Journal of Statistical
Software, 46(10), 1-26.
<a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grain">grain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Load HUGIN net file
tf &lt;- system.file("huginex", "chest_clinic.net", package = "gRain")
chest &lt;- loadHuginNet(tf, details=1)
chest 

## Save a copy
td &lt;- tempdir()
saveHuginNet(chest, paste(td,"/chest.net",sep=''))

## Load the copy
chest2 &lt;- loadHuginNet(paste(td,"/chest.net",sep=''))

tf &lt;- system.file("huginex", "golf.net", package = "gRain")
golf &lt;- loadHuginNet(tf, details=1)

saveHuginNet(golf, paste(td,"/golf.net",sep=''))
golf2 &lt;- loadHuginNet(paste(td,"/golf.net",sep=''))

</code></pre>

<hr>
<h2 id='logical'>Conditional probability tables based on logical dependencies</h2><span id='topic+logical'></span><span id='topic+booltab'></span><span id='topic+andtable'></span><span id='topic+ortable'></span><span id='topic+andtab'></span><span id='topic+ortab'></span>

<h3>Description</h3>

<p>Generate conditional probability tables based on the
logical expressions AND and OR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>booltab(vpa, levels = c(TRUE, FALSE), op = `&amp;`)

andtab(vpa, levels = c(TRUE, FALSE))

ortab(vpa, levels = c(TRUE, FALSE))

andtable(vpa, levels = c(TRUE, FALSE))

ortable(vpa, levels = c(TRUE, FALSE))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logical_+3A_vpa">vpa</code></td>
<td>
<p>Node and two parents; as a formula or a character
vector.</p>
</td></tr>
<tr><td><code id="logical_+3A_levels">levels</code></td>
<td>
<p>The levels (or rather labels) of v, see 'examples'
below.</p>
</td></tr>
<tr><td><code id="logical_+3A_op">op</code></td>
<td>
<p>A logical operator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Regarding the form of the argument <code>vpa</code>: To specify
<code class="reqn">P(a|b,c)</code> one may write <code>~a|b+c</code> or <code>~a+b+c</code> or
<code>~a|b:c</code> or <code>~a:b:c</code> or <code>c("a","b","c")</code>.
Internally, the last form is used. Notice that the <code>+</code> and
<code>:</code> operator are used as separators only. The order of the
variables is important so <code>+</code> and <code>:</code> DO NOT commute.
</p>


<h3>Value</h3>

<p>An array.
</p>


<h3>Note</h3>

<p><code>andtable</code> and <code>ortable</code> are aliases for
<code>andtab</code> and <code>ortab</code> and are kept for backward
compatibility.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence Networks
with the gRain Package for R. Journal of Statistical Software,
46(10), 1-26.  <a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cptable">cptable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Logical OR:

## A variable v is TRUE if either of its parents pa1 and pa2 are TRUE:
ortab( c("v", "pa1", "pa2") ) |&gt; ftable(row.vars="v")
## TRUE and FALSE can be recoded to e.g. yes and no:
ortab( c("v", "pa1", "pa2"), levels=c("yes", "no") ) |&gt; ftable(row.vars="v")

## Logical AND:

## Same story here:
andtab(c("v", "pa1", "pa2") ) |&gt; ftable(row.vars="v")
andtab(c("v", "pa1", "pa2"), levels=c("yes", "no") ) |&gt; ftable(row.vars="v")

## Combined approach

booltab(c("v", "pa1", "pa2"), op=`&amp;`) |&gt; ftable(row.vars="v") ## AND
booltab(c("v", "pa1", "pa2"), op=`|`) |&gt; ftable(row.vars="v") ## OR

booltab(~v + pa1 + pa2, op=`&amp;`) |&gt; ftable(row.vars="v") ## AND
booltab(~v + pa1 + pa2, op=`|`) |&gt; ftable(row.vars="v") ## OR

</code></pre>

<hr>
<h2 id='mendel'>Mendelian segregation</h2><span id='topic+mendel'></span>

<h3>Description</h3>

<p>Generate conditional probability table for Mendelian
segregation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mendel(allele, names = c("child", "father", "mother"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mendel_+3A_allele">allele</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="mendel_+3A_names">names</code></td>
<td>
<p>Names of columns in dataframe.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>No error checking at all on the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Inheritance of the alleles "y" and "g"

men &lt;- mendel(c("y","g"), names=c("ch", "fa", "mo"))
men

</code></pre>

<hr>
<h2 id='old_components_extract'>Extract conditional probabilities and clique potentials from
data.</h2><span id='topic+old_components_extract'></span><span id='topic+extractCPT'></span><span id='topic+extractPOT'></span><span id='topic+extractMARG'></span>

<h3>Description</h3>

<p>Extract list of conditional probability tables and
list of clique potentials from data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractCPT(data_, graph, smooth = 0)

extractPOT(data_, graph, smooth = 0)

extractMARG(data_, graph, smooth = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="old_components_extract_+3A_data_">data_</code></td>
<td>
<p>A named array or a dataframe.</p>
</td></tr>
<tr><td><code id="old_components_extract_+3A_graph">graph</code></td>
<td>
<p>An <code>igraph</code> object or a list or formula which can be
turned into a <code>igraph</code> object by calling <code>ug</code> or
<code>dag</code>. For <code>extract_cpt</code>, graph must be/define a DAG while for
<code>extract_pot</code>, graph must be/define undirected triangulated graph.</p>
</td></tr>
<tr><td><code id="old_components_extract_+3A_smooth">smooth</code></td>
<td>
<p>See 'details' below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>smooth</code> is non-zero then <code>smooth</code> is added
to all cell counts before normalization takes place.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>extract_cpt</code>: A list of conditional probability tables.
</p>
</li>
<li> <p><code>extract_pot</code>: A list of clique potentials.
</p>
</li>
<li> <p><code>extract_marg</code>: A list of clique marginals.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence Networks
with the gRain Package for R. Journal of Statistical Software,
46(10), 1-26.  <a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compileCPT">compileCPT</a></code>, <code><a href="#topic+compilePOT">compilePOT</a></code>,
<code><a href="#topic+grain">grain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Extract cpts / clique potentials from data and graph
# specification and create network. There are different ways:

data(lizard, package="gRbase")

# DAG: height &lt;- species -&gt; diam
daG &lt;- dag(~species + height:species + diam:species, result="igraph")

# UG : [height:species][diam:species]
uG  &lt;- ug(~height:species + diam:species, result="igraph")

pt &lt;- extract_pot(lizard, ~height:species + diam:species) 
cp &lt;- extract_cpt(lizard, ~species + height:species + diam:species)

pt
cp

# Both specify the same probability distribution
tabListMult(pt) |&gt; as.data.frame.table()
tabListMult(cp) |&gt; as.data.frame.table()

## Not run: 
# Bayesian networks can be created as
bn.uG   &lt;- grain(pt)
bn.daG  &lt;- grain(cp)

# The steps above are wrapped into a convenience method which
# builds a network from at graph and data.
bn.uG   &lt;- grain(uG, data=lizard)
bn.daG  &lt;- grain(daG, data=lizard)

## End(Not run)

</code></pre>

<hr>
<h2 id='old_grain_evidence'>Set, update and remove evidence.</h2><span id='topic+old_grain_evidence'></span><span id='topic+setEvidence'></span><span id='topic+retractEvidence'></span><span id='topic+absorbEvidence'></span><span id='topic+getEvidence'></span><span id='topic+pEvidence'></span>

<h3>Description</h3>

<p>Set, update and remove evidence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setEvidence(
  object,
  nodes = NULL,
  states = NULL,
  evidence = NULL,
  propagate = TRUE,
  details = 0
)

retractEvidence(object, nodes = NULL, propagate = TRUE)

absorbEvidence(object, propagate = TRUE)

getEvidence(object, short = TRUE)

pEvidence(object, evidence = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="old_grain_evidence_+3A_object">object</code></td>
<td>
<p>A &quot;grain&quot; object</p>
</td></tr>
<tr><td><code id="old_grain_evidence_+3A_nodes">nodes</code></td>
<td>
<p>A vector of nodes.</p>
</td></tr>
<tr><td><code id="old_grain_evidence_+3A_states">states</code></td>
<td>
<p>A vector of states (of the nodes given by
'nodes'). Now deprecated; use argument 'evidence' instead.</p>
</td></tr>
<tr><td><code id="old_grain_evidence_+3A_evidence">evidence</code></td>
<td>
<p>A list of name=value. See examples below.</p>
</td></tr>
<tr><td><code id="old_grain_evidence_+3A_propagate">propagate</code></td>
<td>
<p>Should the network be propagated?</p>
</td></tr>
<tr><td><code id="old_grain_evidence_+3A_details">details</code></td>
<td>
<p>Debugging information</p>
</td></tr>
<tr><td><code id="old_grain_evidence_+3A_short">short</code></td>
<td>
<p>If TRUE a dataframe with a summary is returned;
otherwise a list with all details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of tables with potentials.
</p>


<h3>Note</h3>

<p><code>setEvidence()</code> is an improvement of <code>setFinding()</code>
(and as such <code>setFinding</code> is obsolete). Users are
recommended to use <code>setEvidence()</code> in the future.
</p>
<p><code>setEvidence()</code> allows to specification of &quot;hard evidence&quot; (specific
values for variables) and likelihood evidence (also known as virtual
evidence) for variables.
</p>
<p>The syntax of <code>setEvidence()</code> may change in the future.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence Networks
with the gRain Package for R. Journal of Statistical Software,
46(10), 1-26.  <a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setFinding">setFinding</a></code>, <code><a href="#topic+getFinding">getFinding</a></code>,
<code><a href="#topic+retractFinding">retractFinding</a></code>, <code><a href="#topic+pFinding">pFinding</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example("grain")
chest_bn &lt;- grain(compileCPT(chest_cpt))

bn2 &lt;- chest_bn |&gt; evidence_add(list(asia="yes", xray="yes"))
bn3 &lt;- chest_bn |&gt; evidence_add(list(asia=c(0.8, 0.1), xray="yes"))

bn2 |&gt; evidence_get()
bn3 |&gt; evidence_get()

bn2 |&gt; evidence_prob()
bn3 |&gt; evidence_prob()

bn2 |&gt; evidence_drop("xray")
bn3 |&gt; evidence_drop("xray")

bn2 |&gt; evidence_drop("xray") |&gt; evidence_get()
bn3 |&gt; evidence_drop("xray") |&gt; evidence_get()


## For backward compatibility these functions are available now but
# may be deprecated later.
bb2 &lt;- setEvidence(chest_bn, c("asia", "xray"), c("yes", "yes"))
bb3 &lt;- setEvidence(chest_bn, c("asia", "xray"), list(c(0.8, 0.2), "yes"))
bb4 &lt;- setFinding(chest_bn, c("asia", "xray"), c("yes", "yes"))

bb2 |&gt; getEvidence()
bb3 |&gt; getEvidence()

bb2 |&gt; retractEvidence("xray")
bb3 |&gt; retractEvidence("xray")

bb2 |&gt; pEvidence()
bb3 |&gt; pEvidence()

bb2 |&gt; retractEvidence("xray") |&gt; getEvidence()
bb3 |&gt; retractEvidence("xray") |&gt; getEvidence()
</code></pre>

<hr>
<h2 id='old_replace_cpt'>Replace CPTs in Bayesian network</h2><span id='topic+old_replace_cpt'></span><span id='topic+replaceCPT'></span>

<h3>Description</h3>

<p>Replace CPTs of Bayesian network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replaceCPT(object, value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="old_replace_cpt_+3A_object">object</code></td>
<td>
<p>A <code>grain</code> object.</p>
</td></tr>
<tr><td><code id="old_replace_cpt_+3A_value">value</code></td>
<td>
<p>A named list, see examples below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When a Bayesian network (BN) is constructed from a list of
conditional probability tables (CPTs) (e.g. using the function
<code>grain()</code>), various actions are taken:
</p>

<ol>
<li><p> It is checked that the list of CPTs define a directed acyclic graph (DAG).
</p>
</li>
<li><p> The DAG is moralized and triangulated.
</p>
</li>
<li><p> A list of clique potentials (one for each clique in the
triangulated graph) is created from the list of CPTs.
</p>
</li>
<li><p> The clique potentials are, by default, calibrated to each other
so that the potentials contain marginal distributions.
</p>
</li></ol>

<p>The function described here bypass the first two steps which can
provide an important gain in speed compared to constructing a new
BN with a new set of CPTs with the same DAG.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence Networks
with the gRain Package for R. Journal of Statistical Software,
46(10), 1-26.  <a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grain">grain</a></code>, <code><a href="gRbase.html#topic+propagate">propagate</a></code>,
<code><a href="gRbase.html#topic+triangulate">triangulate</a></code>, <code><a href="gRbase.html#topic+rip">rip</a></code>,
<code><a href="gRbase.html#topic+junctionTree">junctionTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the wet grass example at
## https://en.wikipedia.org/wiki/Bayesian_network

yn &lt;- c("yes", "no")
p.R    &lt;- cptable(~R, values=c(.2, .8), levels=yn)
p.S_R  &lt;- cptable(~S:R, values=c(.01, .99, .4, .6), levels=yn)
p.G_SR &lt;- cptable(~G:S:R, values=c(.99, .01, .8, .2, .9, .1, 0, 1), levels=yn)

wet.bn &lt;- compileCPT(p.R, p.S_R, p.G_SR)  |&gt; grain()
getgrain(wet.bn, "cpt")[c("R","S")]

# Update some CPTs
wet.bn &lt;- replace_cpt(wet.bn, list(R=c(.3, .7), S=c(.1, .9, .7, .3)))
getgrain(wet.bn, "cpt")[c("R","S")]

</code></pre>

<hr>
<h2 id='querygrain'>Query a Bayesian network</h2><span id='topic+querygrain'></span><span id='topic+querygrain.grain'></span><span id='topic+qgrain'></span><span id='topic+ask'></span><span id='topic+ask.grain'></span>

<h3>Description</h3>

<p>Query an independence network, i.e. obtain the
conditional distribution of a set of variables - possibly (and
typically) given finding (evidence) on other variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>querygrain(
  object,
  nodes = nodeNames(object),
  type = "marginal",
  evidence = NULL,
  exclude = TRUE,
  normalize = TRUE,
  simplify = FALSE,
  result = "array",
  details = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="querygrain_+3A_object">object</code></td>
<td>
<p>A <code>grain</code> object.</p>
</td></tr>
<tr><td><code id="querygrain_+3A_nodes">nodes</code></td>
<td>
<p>A vector of nodes; those nodes for which the
(conditional) distribution is requested.</p>
</td></tr>
<tr><td><code id="querygrain_+3A_type">type</code></td>
<td>
<p>Valid choices are <code>"marginal"</code> which gives the
marginal distribution for each node in <code>nodes</code>;
<code>"joint"</code> which gives the joint distribution for
<code>nodes</code> and <code>"conditional"</code> which gives the
conditional distribution for the first variable in <code>nodes</code>
given the other variables in <code>nodes</code>.</p>
</td></tr>
<tr><td><code id="querygrain_+3A_evidence">evidence</code></td>
<td>
<p>An alternative way of specifying findings
(evidence), see examples below.</p>
</td></tr>
<tr><td><code id="querygrain_+3A_exclude">exclude</code></td>
<td>
<p>If <code>TRUE</code> then nodes on which evidence is given
will be excluded from <code>nodes</code> (see above).</p>
</td></tr>
<tr><td><code id="querygrain_+3A_normalize">normalize</code></td>
<td>
<p>Should the results be normalized to sum to one.</p>
</td></tr>
<tr><td><code id="querygrain_+3A_simplify">simplify</code></td>
<td>
<p>Should the result be simplified (to a dataframe) if
possible.</p>
</td></tr>
<tr><td><code id="querygrain_+3A_result">result</code></td>
<td>
<p>If &quot;data.frame&quot; the result is returned as a data
frame (or possibly as a list of dataframes).</p>
</td></tr>
<tr><td><code id="querygrain_+3A_details">details</code></td>
<td>
<p>Debugging information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of tables with potentials.
</p>


<h3>Note</h3>

<p><code>setEvidence()</code> is an improvement of <code>setFinding()</code>
(and as such <code>setFinding</code> is obsolete). Users are
recommended to use <code>setEvidence()</code> in the future.
</p>
<p><code>setEvidence()</code> allows to specification of &quot;hard evidence&quot; (specific
values for variables) and likelihood evidence (also known as virtual
evidence) for variables.
</p>
<p>The syntax of <code>setEvidence()</code> may change in the future.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence Networks
with the gRain Package for R. Journal of Statistical Software,
46(10), 1-26.  <a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setEvidence">setEvidence</a></code>, <code><a href="#topic+getEvidence">getEvidence</a></code>,
<code><a href="#topic+retractEvidence">retractEvidence</a></code>, <code><a href="#topic+pEvidence">pEvidence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
testfile &lt;- system.file("huginex", "chest_clinic.net", package = "gRain")
chest &lt;- loadHuginNet(testfile, details=0)
qb &lt;- querygrain(chest)
qb

lapply(qb, as.numeric) # Safe
sapply(qb, as.numeric) # Risky

</code></pre>

<hr>
<h2 id='repeat_pattern'>Create repeated patterns in Bayesian networks</h2><span id='topic+repeat_pattern'></span>

<h3>Description</h3>

<p>Repeated patterns is a useful model specification
short cut for Bayesian networks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repeat_pattern(plist, instances, unlist = TRUE, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repeat_pattern_+3A_plist">plist</code></td>
<td>
<p>A list of conditional probability tables. The variable
names must have the form <code>name[i]</code> and the <code>i</code> will
be substituted by the values given in <code>instances</code> below.
See also the <code>data</code> argument.</p>
</td></tr>
<tr><td><code id="repeat_pattern_+3A_instances">instances</code></td>
<td>
<p>A vector of consecutive integers</p>
</td></tr>
<tr><td><code id="repeat_pattern_+3A_unlist">unlist</code></td>
<td>
<p>If <code>FALSE</code> the result is a list in which each
element is a copy of <code>plist</code> in which <code>name[i]</code> are
substituted. If <code>TRUE</code> the result is the result of
applying <code>unlist()</code>.</p>
</td></tr>
<tr><td><code id="repeat_pattern_+3A_data">data</code></td>
<td>
<p>A two column matrix. The first column is the index /
name of a node; the second column is the index / name of the
node's parent.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence
Networks with the gRain Package for R. Journal of Statistical
Software, 46(10), 1-26.
<a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grain">grain</a></code>, <code><a href="#topic+compile_cpt">compile_cpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
yn &lt;- c("yes", "no")
n &lt;- 3

## Example: Markov chain

x_init  &lt;- cpt(~x0, values=c(1, 9), levels=yn)                  ## p(x0)
x_trans &lt;- cpt(~x[i]|x[i-1], values=c(1, 99, 2, 98), levels=yn) ## p(x[i]|x[i-1])
pat     &lt;- list(x_trans)                             
rep.pat &lt;- repeat_pattern(pat, instances=1:n)

mc &lt;- compile_cpt(c(list(x_init), rep.pat))
mc
mc &lt;- mc |&gt; grain()

## Example: Hidden markov model:
# The x[i]'s are unobserved, the y[i]'s can be observed.

x_init  &lt;- cpt(~x0, values=c(1, 9), levels=yn)                   ##  p(x0)
x_trans &lt;- cpt(~x[i]|x[i-1], values=c(1, 99, 2, 98), levels=yn)  ##  p(x[i]|x[i-1])
y_emis  &lt;- cpt(~y[i]|x[i], values=c(10, 90, 20, 80), levels=yn)  ##  p(y[i]|x[i]) 

pat     &lt;- list(x_trans, y_emis) ## Pattern to be repeated
rep.pat &lt;- repeat_pattern(pat, instances=1:n)
hmm &lt;- compile_cpt(c(list(x_init), rep.pat)) 
hmm
hmm &lt;- hmm |&gt; grain()

## Data-driven variable names

dep &lt;- data.frame(i=c(1, 2, 3, 4, 5, 6, 7, 8),
                  p=c(0, 1, 2, 2, 3, 3, 4, 4))

x0 &lt;- cpt(~x0, values=c(0.5, 0.5), levels=yn)
xa &lt;- cpt(~x[i] | x[data[i, "p"]], values=c(1, 9, 2, 8), levels=yn)
xb &lt;- repeat_pattern(list(xa), instances=1:nrow(dep), data=dep)
tree &lt;- compile_cpt(c(list(x0), xb))
tree
tree &lt;- tree |&gt; grain()
tree 

</code></pre>

<hr>
<h2 id='repeatPattern'>Create repeated patterns in Bayesian networks</h2><span id='topic+repeatPattern'></span>

<h3>Description</h3>

<p>Repeated patterns is a useful model specification
short cut for Bayesian networks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repeatPattern(plist, instances, unlist = TRUE, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repeatPattern_+3A_plist">plist</code></td>
<td>
<p>A list of conditional probability tables. The variable
names must have the form <code>name[i]</code> and the <code>i</code> will
be substituted by the values given in <code>instances</code> below.
See also the <code>data</code> argument.</p>
</td></tr>
<tr><td><code id="repeatPattern_+3A_instances">instances</code></td>
<td>
<p>A vector of consecutive integers</p>
</td></tr>
<tr><td><code id="repeatPattern_+3A_unlist">unlist</code></td>
<td>
<p>If <code>FALSE</code> the result is a list in which each
element is a copy of <code>plist</code> in which <code>name[i]</code> are
substituted. If <code>TRUE</code> the result is the result of
applying <code>unlist()</code>.</p>
</td></tr>
<tr><td><code id="repeatPattern_+3A_data">data</code></td>
<td>
<p>A two column matrix. The first column is the index /
name of a node; the second column is the index / name of the
node's parent.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence
Networks with the gRain Package for R. Journal of Statistical
Software, 46(10), 1-26.
<a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grain">grain</a></code>, <code><a href="#topic+compile_cpt">compile_cpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
yn &lt;- c("yes", "no")
n &lt;- 3

## Example: Markov chain

x_init  &lt;- cpt(~x0, values=c(1, 9), levels=yn)                  ## p(x0)
x_trans &lt;- cpt(~x[i]|x[i-1], values=c(1, 99, 2, 98), levels=yn) ## p(x[i]|x[i-1])
pat     &lt;- list(x_trans)                             
rep.pat &lt;- repeat_pattern(pat, instances=1:n)

mc &lt;- compile_cpt(c(list(x_init), rep.pat))
mc
mc &lt;- mc |&gt; grain()

## Example: Hidden markov model:
# The x[i]'s are unobserved, the y[i]'s can be observed.

x_init  &lt;- cpt(~x0, values=c(1, 9), levels=yn)                   ##  p(x0)
x_trans &lt;- cpt(~x[i]|x[i-1], values=c(1, 99, 2, 98), levels=yn)  ##  p(x[i]|x[i-1])
y_emis  &lt;- cpt(~y[i]|x[i], values=c(10, 90, 20, 80), levels=yn)  ##  p(y[i]|x[i]) 

pat     &lt;- list(x_trans, y_emis) ## Pattern to be repeated
rep.pat &lt;- repeat_pattern(pat, instances=1:n)
hmm &lt;- compile_cpt(c(list(x_init), rep.pat)) 
hmm
hmm &lt;- hmm |&gt; grain()

## Data-driven variable names

dep &lt;- data.frame(i=c(1, 2, 3, 4, 5, 6, 7, 8),
                  p=c(0, 1, 2, 2, 3, 3, 4, 4))

x0 &lt;- cpt(~x0, values=c(0.5, 0.5), levels=yn)
xa &lt;- cpt(~x[i] | x[data[i, "p"]], values=c(1, 9, 2, 8), levels=yn)
xb &lt;- repeat_pattern(list(xa), instances=1:nrow(dep), data=dep)
tree &lt;- compile_cpt(c(list(x0), xb))
tree
tree &lt;- tree |&gt; grain()
tree 

</code></pre>

<hr>
<h2 id='replace_cpt'>Replace CPTs in Bayesian network</h2><span id='topic+replace_cpt'></span><span id='topic+replace_cpt.cpt_grain'></span>

<h3>Description</h3>

<p>Replace CPTs of Bayesian network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_cpt(object, value)

## S3 method for class 'cpt_grain'
replace_cpt(object, value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replace_cpt_+3A_object">object</code></td>
<td>
<p>A <code>grain</code> object.</p>
</td></tr>
<tr><td><code id="replace_cpt_+3A_value">value</code></td>
<td>
<p>A named list, see examples below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When a Bayesian network (BN) is constructed from a list of
conditional probability tables (CPTs) (e.g. using the function
<code>grain()</code>), various actions are taken:
</p>

<ol>
<li><p> It is checked that the list of CPTs define a directed acyclic graph (DAG).
</p>
</li>
<li><p> The DAG is moralized and triangulated.
</p>
</li>
<li><p> A list of clique potentials (one for each clique in the
triangulated graph) is created from the list of CPTs.
</p>
</li>
<li><p> The clique potentials are, by default, calibrated to each other
so that the potentials contain marginal distributions.
</p>
</li></ol>

<p>The function described here bypass the first two steps which can
provide an important gain in speed compared to constructing a new
BN with a new set of CPTs with the same DAG.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence Networks
with the gRain Package for R. Journal of Statistical Software,
46(10), 1-26.  <a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grain">grain</a></code>, <code><a href="gRbase.html#topic+propagate">propagate</a></code>,
<code><a href="gRbase.html#topic+triangulate">triangulate</a></code>, <code><a href="gRbase.html#topic+rip">rip</a></code>,
<code><a href="gRbase.html#topic+junctionTree">junctionTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the wet grass example at
## https://en.wikipedia.org/wiki/Bayesian_network

yn &lt;- c("yes", "no")
p.R    &lt;- cptable(~R, values=c(.2, .8), levels=yn)
p.S_R  &lt;- cptable(~S:R, values=c(.01, .99, .4, .6), levels=yn)
p.G_SR &lt;- cptable(~G:S:R, values=c(.99, .01, .8, .2, .9, .1, 0, 1), levels=yn)

wet.bn &lt;- compileCPT(p.R, p.S_R, p.G_SR)  |&gt; grain()
getgrain(wet.bn, "cpt")[c("R","S")]

# Update some CPTs
wet.bn &lt;- replace_cpt(wet.bn, list(R=c(.3, .7), S=c(.1, .9, .7, .3)))
getgrain(wet.bn, "cpt")[c("R","S")]

</code></pre>

<hr>
<h2 id='simplify_query'>Simplify output query to a Bayesian network</h2><span id='topic+simplify_query'></span>

<h3>Description</h3>

<p>Simplify output query to a Bayesian network to a dataframe provided
that each node has the same levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplify_query(b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simplify_query_+3A_b">b</code></td>
<td>
<p>Result from running querygrain.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
