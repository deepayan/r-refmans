<!DOCTYPE html><html><head><title>Help for package gRain</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gRain}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#chest'><p>Chest clinic example</p></a></li>
<li><a href='#components_extract'><p>Extract conditional probabilities and clique potentials from</p>
data.</a></li>
<li><a href='#components_gather'><p>Compile conditional probability tables / cliques potentials.</p></a></li>
<li><a href='#cpt'><p>Create conditional probability tables (CPTs)</p></a></li>
<li><a href='#evidence_object'><p>Evidence objects</p></a></li>
<li><a href='#finding'><p>Set, retrieve, and retract finding in Bayesian network.</p></a></li>
<li><a href='#generics'><p>gRain generics</p></a></li>
<li><a href='#get_superset_list'><p>Get superset for each element in a list</p></a></li>
<li><a href='#grain_compile'><p>Compile a graphical independence network (a Bayesian network)</p></a></li>
<li><a href='#grain_evidence'><p>Set, update and remove evidence.</p></a></li>
<li><a href='#grain_joint_evidence'><p>Set joint evidence in grain objects</p></a></li>
<li><a href='#grain_predict'><p>Make predictions from a probabilistic network</p></a></li>
<li><a href='#grain_propagate'><p>Propagate a graphical independence network (a Bayesian network)</p></a></li>
<li><a href='#grain-main'><p>Graphical Independence Network</p></a></li>
<li><a href='#grain-simulate'><p>Simulate from an independence network</p></a></li>
<li><a href='#grass'><p>Wet grass example</p></a></li>
<li><a href='#internal-grain'><p>Internal functions for the gRain package</p></a></li>
<li><a href='#load-save-hugin'><p>Load and save Hugin net files</p></a></li>
<li><a href='#logical'><p>Conditional probability tables based on logical dependencies</p></a></li>
<li><a href='#mendel'><p>Mendelian segregation</p></a></li>
<li><a href='#querygrain'><p>Query a network</p></a></li>
<li><a href='#repeat_pattern'><p>Create repeated patterns in Bayesian networks</p></a></li>
<li><a href='#replace-cpt'><p>Replace CPTs in Bayesian network</p></a></li>
<li><a href='#simplify_query'><p>Simplify output query to a Bayesian network</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.4.1</td>
</tr>
<tr>
<td>Title:</td>
<td>Graphical Independence Networks</td>
</tr>
<tr>
<td>Author:</td>
<td>Søren Højsgaard &lt;sorenh@math.aau.dk&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Søren Højsgaard &lt;sorenh@math.aau.dk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Probability propagation in graphical independence networks, also
    known as Bayesian networks or probabilistic expert systems. Documentation
    of the package is provided in vignettes included in the package and in
    the paper by Højsgaard (2012, &lt;<a href="https://doi.org/10.18637%2Fjss.v046.i10">doi:10.18637/jss.v046.i10</a>&gt;).
    See 'citation("gRain")' for details. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0), methods, gRbase (&ge; 2.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>microbenchmark, knitr, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, stats4, broom, magrittr, Rcpp (&ge; 0.11.1)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://people.math.aau.dk/~sorenh/software/gR/">https://people.math.aau.dk/~sorenh/software/gR/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.11.1), RcppArmadillo, RcppEigen, gRbase</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>Yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-21 16:31:59 UTC; sorenh</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-21 17:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='chest'>Chest clinic example</h2><span id='topic+chest'></span><span id='topic+chest_cpt'></span>

<h3>Description</h3>

<p>Conditional probability tables for the chest clinic example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chest_cpt)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>cpt_spec</code> of length 8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## 'data' generated with the following code fragment
yn   &lt;- c("yes", "no")
a    &lt;- cptable(~asia, values=c(1,99),levels=yn)
t.a  &lt;- cptable(~tub|asia, values=c(5,95,1,99),levels=yn)
s    &lt;- cptable(~smoke, values=c(5,5), levels=yn)
l.s  &lt;- cptable(~lung|smoke, values=c(1,9,1,99), levels=yn)
b.s  &lt;- cptable(~bronc|smoke, values=c(6,4,3,7), levels=yn)
e.lt &lt;- cptable(~either|lung:tub,values=c(1,0,1,0,1,0,0,1),levels=yn)
x.e  &lt;- cptable(~xray|either, values=c(98,2,5,95), levels=yn)
d.be &lt;- cptable(~dysp|bronc:either, values=c(9,1,7,3,8,2,1,9), levels=yn)

grain(compileCPT(a, t.a, s, l.s, b.s, e.lt, x.e, d.be))

# 'data' generated from
# chest_cpt &lt;- list(a, t.a, s, l.s, b.s, e.lt, x.e, d.be)

data(chest_cpt)

</code></pre>

<hr>
<h2 id='components_extract'>Extract conditional probabilities and clique potentials from
data.</h2><span id='topic+components_extract'></span><span id='topic+extract_cpt'></span><span id='topic+extract_pot'></span><span id='topic+extract_marg'></span><span id='topic+marg2pot'></span><span id='topic+pot2marg'></span><span id='topic+extractCPT'></span><span id='topic+extractPOT'></span><span id='topic+extractMARG'></span>

<h3>Description</h3>

<p>Extract list of conditional probability tables and
list of clique potentials from data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_cpt(data_, graph, smooth = 0)

extract_pot(data_, graph, smooth = 0)

extract_marg(data_, graph, smooth = 0)

marg2pot(marg_rep)

pot2marg(pot_rep)

extractCPT(data_, graph, smooth = 0)

extractPOT(data_, graph, smooth = 0)

extractMARG(data_, graph, smooth = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="components_extract_+3A_data_">data_</code></td>
<td>
<p>A named array or a dataframe.</p>
</td></tr>
<tr><td><code id="components_extract_+3A_graph">graph</code></td>
<td>
<p>An <code>igraph</code> object or a list or formula which can be
turned into a <code>igraph</code> object by calling <code>ug</code> or
<code>dag</code>. For <code>extract_cpt</code>, graph must be/define a DAG while for
<code>extract_pot</code>, graph must be/define undirected triangulated graph.</p>
</td></tr>
<tr><td><code id="components_extract_+3A_smooth">smooth</code></td>
<td>
<p>See 'details' below.</p>
</td></tr>
<tr><td><code id="components_extract_+3A_marg_rep">marg_rep</code></td>
<td>
<p>An object of class <code>marg_rep</code></p>
</td></tr>
<tr><td><code id="components_extract_+3A_pot_rep">pot_rep</code></td>
<td>
<p>An object of class <code>pot_representation</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>smooth</code> is non-zero then <code>smooth</code> is added
to all cell counts before normalization takes place.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>extract_cpt</code>: A list of conditional probability tables.
</p>
</li>
<li> <p><code>extract_pot</code>: A list of clique potentials.
</p>
</li>
<li> <p><code>extract_marg</code>: A list of clique marginals.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence Networks
with the gRain Package for R. Journal of Statistical Software,
46(10), 1-26.  <a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compileCPT">compileCPT</a></code>, <code><a href="#topic+compilePOT">compilePOT</a></code>,
<code><a href="#topic+grain">grain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Extract cpts / clique potentials from data and graph
# specification and create network. There are different ways:

data(lizard, package="gRbase")

# DAG: height &lt;- species -&gt; diam
daG &lt;- dag(~species + height:species + diam:species, result="igraph")

# UG : [height:species][diam:species]
uG  &lt;- ug(~height:species + diam:species, result="igraph")

pt &lt;- extract_pot(lizard, ~height:species + diam:species) 
cp &lt;- extract_cpt(lizard, ~species + height:species + diam:species)

pt
cp

# Both specify the same probability distribution
tabListMult(pt) %&gt;% as.data.frame.table
tabListMult(cp) %&gt;% as.data.frame.table

## Not run: 
# Bayesian networks can be created as
bn.uG   &lt;- grain(pt)
bn.daG  &lt;- grain(cp)

# The steps above are wrapped into a convenience method which
# builds a network from at graph and data.
bn.uG   &lt;- grain(uG, data=lizard)
bn.daG  &lt;- grain(daG, data=lizard)

## End(Not run)
</code></pre>

<hr>
<h2 id='components_gather'>Compile conditional probability tables / cliques potentials.</h2><span id='topic+components_gather'></span><span id='topic+compile_cpt'></span><span id='topic+parse_cpt+2C'></span><span id='topic+parse_cpt.xtabs+2C'></span><span id='topic+parse_cpt.default'></span><span id='topic+compile_pot'></span><span id='topic+compileCPT'></span><span id='topic+compilePOT'></span><span id='topic+parse_cpt'></span>

<h3>Description</h3>

<p>Compile conditional probability tables / cliques
potentials as a preprocessing step for creating a graphical
independence network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compile_cpt(x, ..., forceCheck = TRUE)

compile_pot(x, ..., forceCheck = TRUE)

compileCPT(x, ..., forceCheck = TRUE)

compilePOT(x, ..., forceCheck = TRUE)

parse_cpt(xi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="components_gather_+3A_x">x</code></td>
<td>
<p>To <code>compileCPT</code> x is a list of conditional
probability tables; to <code>compilePOT</code>, x is a list of clique
potentials.</p>
</td></tr>
<tr><td><code id="components_gather_+3A_...">...</code></td>
<td>
<p>Additional arguments; currently not used.</p>
</td></tr>
<tr><td><code id="components_gather_+3A_forcecheck">forceCheck</code></td>
<td>
<p>Controls if consistency checks of the probability
tables should be made.</p>
</td></tr>
<tr><td><code id="components_gather_+3A_xi">xi</code></td>
<td>
<p>cpt in some representation</p>
</td></tr>
</table>


<h3>Details</h3>

<div class="sourceCode"><pre>* `compileCPT` is relevant for turning a collection of
cptable's into an object from which a network can be built. For
example, when specification of a cpt is made with cptable then
the levels of the node is given but not the levels of the
parents. `compileCPT` checks that the levels of variables in
the cpt's are consistent and also that the specifications
define a dag.

* `compilePOT` is not of direct relevance for the
user for the moment. However, the elements of the input should
be arrays which define a chordal undirected graph and the
arrays should, if multiplied, form a valid probability density.
</pre></div>


<h3>Value</h3>

<p>A list with a class attribute.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence Networks
with the gRain Package for R. Journal of Statistical Software,
46(10), 1-26.  <a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract_cpt">extract_cpt</a></code>, <code><a href="#topic+extract_pot">extract_pot</a></code>, <code><a href="#topic+extract_marg">extract_marg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(chest_cpt)
x &lt;- compile_cpt(chest_cpt)
class(x)
grain(x)

</code></pre>

<hr>
<h2 id='cpt'>Create conditional probability tables (CPTs)</h2><span id='topic+cpt'></span><span id='topic+cptable'></span>

<h3>Description</h3>

<p>Creates conditional probability tables of the form
p(v|pa(v)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpt(names, levels, values, normalize = "first", smooth = 0)

cptable(vpar, levels = NULL, values = NULL, normalize = TRUE, smooth = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpt_+3A_names">names</code></td>
<td>
<p>Specifications of the names in P(v|pa1,...pak). See
section 'details' for information about the form of the
argument.</p>
</td></tr>
<tr><td><code id="cpt_+3A_levels">levels</code></td>
<td>

<ol>
<li><p> a list with specification of the levels of the
factors in <code>names</code> or 2) a vector with number of levels of
the factors in <code>names</code>. See 'examples' below.
</p>
</li></ol>
</td></tr>
<tr><td><code id="cpt_+3A_values">values</code></td>
<td>
<p>Probabilities; recycled if necessary. Regarding the
order, please see section 'details' and the examples.</p>
</td></tr>
<tr><td><code id="cpt_+3A_normalize">normalize</code></td>
<td>
<p>See 'details' below.</p>
</td></tr>
<tr><td><code id="cpt_+3A_smooth">smooth</code></td>
<td>
<p>Should values be smoothed, see 'Details' below.</p>
</td></tr>
<tr><td><code id="cpt_+3A_vpar">vpar</code></td>
<td>
<p>node an its parents</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cptable</code> is simply a wrapper for <code>cpt</code> and the functions can hence
be used synonymously.
</p>
<p>If <code>smooth</code> is non&ndash;zero, then this value is added to all cells <strong>before</strong>
normalization takes place.
</p>
<p>Regarding the form of the argument <code>names</code>: To specify
<code class="reqn">P(a|b,c)</code> one may write <code>~a|b:c</code>, <code>~a:b:c</code>,
<code>~a|b+c</code>, <code>~a+b+c</code> or <code>c("a","b","c")</code>. Internally,
the last form is used. Notice that the <code>+</code> and <code>:</code>
operator are used as a separators only. The order of the variables IS
important so the operators DO NOT commute.
</p>
<p>The first variable in <code>levels</code> varies fastest.
</p>


<h3>Value</h3>

<p>An array.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence
Networks with the gRain Package for R. Journal of Statistical
Software, 46(10), 1-26.
<a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+andtable">andtable</a></code>, <code><a href="#topic+ortable">ortable</a></code>,
<code><a href="#topic+extract_cpt">extract_cpt</a></code>, <code><a href="#topic+compileCPT">compileCPT</a></code>,
<code><a href="#topic+extract_cpt">extract_cpt</a></code>, <code><a href="#topic+compilePOT">compilePOT</a></code>,
<code><a href="#topic+grain">grain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## See the wet grass example at
## https://en.wikipedia.org/wiki/Bayesian_network

yn &lt;- c("yes", "no")
ssp &lt;- list(R=yn, S=yn, G=yn) # state space

## Different forms
t1 &lt;- cpt(c("S", "R"), levels=ssp,     values=c(.01, .99, .4, .6))
t2 &lt;- cpt(~S:R,        levels=ssp,     values=c(.01, .99, .4, .6))
t3 &lt;- cpt(~S:R,        levels=c(2, 2), values=c(.01, .99, .4, .6))
t4 &lt;- cpt(~S:R,        levels=yn,      values=c(.01, .99, .4, .6))
t1; t2; t3; t4

varNames(t1)
valueLabels(t1)

## Wet grass example
ssp &lt;- list(R=yn, S=yn, G=yn) # state space
p.R    &lt;- cptable(~R,     levels=ssp, values=c(.2, .8))
p.S_R  &lt;- cptable(~S:R,   levels=ssp, values=c(.01, .99, .4, .6))
p.G_SR &lt;- cptable(~G:S:R, levels=ssp, values=c(.99, .01, .8, .2, .9, .1, 0, 1))

wet.cpt &lt;- compileCPT(p.R, p.S_R, p.G_SR)
wet.cpt
wet.cpt$S # etc

# A Bayesian network is created with:
wet.bn &lt;- grain(wet.cpt)

</code></pre>

<hr>
<h2 id='evidence_object'>Evidence objects</h2><span id='topic+evidence_object'></span><span id='topic+new_evi'></span><span id='topic+subset.grain_evidence'></span><span id='topic+print.grain_evidence'></span><span id='topic+varNames.grain_evidence'></span><span id='topic+is.null_evi'></span><span id='topic+as.data.frame.grain_evidence'></span><span id='topic+setdiff_evi'></span><span id='topic+union_evi'></span>

<h3>Description</h3>

<p>Functions for defining and manipulating evidence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_evi(evi_list = NULL, levels)

is.null_evi(object)

## S3 method for class 'grain_evidence'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)

setdiff_evi(ev1, ev2)

union_evi(ev1, ev2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evidence_object_+3A_evi_list">evi_list</code></td>
<td>
<p>A named list with evidence; see 'examples' below.</p>
</td></tr>
<tr><td><code id="evidence_object_+3A_levels">levels</code></td>
<td>
<p>A named list with the levels of all variables.</p>
</td></tr>
<tr><td><code id="evidence_object_+3A_object">object</code></td>
<td>
<p>Some R object.</p>
</td></tr>
<tr><td><code id="evidence_object_+3A_x">x</code></td>
<td>
<p>An evidence object.</p>
</td></tr>
<tr><td><code id="evidence_object_+3A_row.names">row.names</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="evidence_object_+3A_optional">optional</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="evidence_object_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="evidence_object_+3A_ev1">ev1</code>, <code id="evidence_object_+3A_ev2">ev2</code></td>
<td>
<p>Evidence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Evidence is specified as a list. Internally, evidence is
represented as a grain evidence object which is a list with 4 elements.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Define the universe
yn &lt;- c("yes", "no")
uni &lt;- list(asia = yn, tub = yn, smoke = yn, lung = yn,
            bronc = yn, either = yn, xray = yn, dysp = yn)

e1 &lt;- list(dysp="no", xray="no")
eo1 &lt;- new_evi(e1, levels=uni)
eo1  |&gt; as.data.frame()

e2 &lt;- list(dysp="no", xray=c(0, 1))
eo2 &lt;- new_evi(e2, levels=uni)
eo2 |&gt; as.data.frame()

# Above e1 and e2 specifies the same evidence but information about
# whether the state has been set definite or as a weight is
# maintained.

e3 &lt;- list(dysp="yes", asia="yes")
eo3 &lt;- new_evi(e3, uni)
eo3 |&gt; as.data.frame()

# If evidence 'e1' is already set in the network and new evidence
# 'e3' emerges, then evidence in the network must be updated. But
# there is a conflict in that dysp="yes" in 'e1' and
# dysp="no" in 'e3'. The (arbitrary) convention is that
# existing evidence overrides new evidence so that the only new
# evidence in 'e3' is really asia="yes".

# To subtract existing evidence from new evidence we can do:
setdiff_evi(eo3, eo1) |&gt; as.data.frame()

# Likewise the 'union' is
union_evi(eo3, eo1) |&gt; as.data.frame()

</code></pre>

<hr>
<h2 id='finding'>Set, retrieve, and retract finding in Bayesian network.</h2><span id='topic+finding'></span><span id='topic+setFinding'></span><span id='topic+retractFinding'></span><span id='topic+getFinding'></span><span id='topic+pFinding'></span>

<h3>Description</h3>

<p>Set, retrieve, and retract finding in Bayesian
network.  NOTICE: The functions described here are kept only
for backward compatibility; please use the corresponding
evidence-functions in the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setFinding(object, nodes = NULL, states = NULL, flist = NULL, propagate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="finding_+3A_object">object</code></td>
<td>
<p>A &quot;grain&quot; object</p>
</td></tr>
<tr><td><code id="finding_+3A_nodes">nodes</code></td>
<td>
<p>A vector of nodes</p>
</td></tr>
<tr><td><code id="finding_+3A_states">states</code></td>
<td>
<p>A vector of states (of the nodes given by 'nodes')</p>
</td></tr>
<tr><td><code id="finding_+3A_flist">flist</code></td>
<td>
<p>An alternative way of specifying findings, see
examples below.</p>
</td></tr>
<tr><td><code id="finding_+3A_propagate">propagate</code></td>
<td>
<p>Should the network be propagated?</p>
</td></tr>
</table>


<h3>Note</h3>

<p>NOTICE: The functions described here are kept only for
backward compatibility; please use the corresponding
evidence-functions in the future:
</p>
<p><code>setEvidence()</code> is an improvement of <code>setFinding()</code> (and as such
<code>setFinding</code> is obsolete). Users are recommended to use
<code>setEvidence()</code> in the future.
</p>
<p><code>setEvidence()</code> allows to specification of &quot;hard evidence&quot; (specific
values for variables) and likelihood evidence (also known as virtual
evidence) for variables.
</p>
<p>The syntax of <code>setEvidence()</code> may change in the future.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence Networks
with the gRain Package for R. Journal of Statistical Software, 46(10), 1-26.
<a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setEvidence">setEvidence</a></code>, <code><a href="#topic+getEvidence">getEvidence</a></code>,
<code><a href="#topic+retractEvidence">retractEvidence</a></code>, <code><a href="#topic+pEvidence">pEvidence</a></code>,
<code><a href="#topic+querygrain">querygrain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## setFindings
yn &lt;- c("yes", "no")
a    &lt;- cptable(~asia, values=c(1, 99),levels=yn)
t.a  &lt;- cptable(~tub+asia, values=c(5, 95, 1, 99),levels=yn)
s    &lt;- cptable(~smoke, values=c(5,5), levels=yn)
l.s  &lt;- cptable(~lung+smoke, values=c(1, 9, 1, 99), levels=yn)
b.s  &lt;- cptable(~bronc+smoke, values=c(6, 4, 3, 7), levels=yn)
e.lt &lt;- cptable(~either+lung+tub,values=c(1, 0, 1, 0, 1, 0, 0, 1),levels=yn)
x.e  &lt;- cptable(~xray+either, values=c(98, 2, 5, 95), levels=yn)
d.be &lt;- cptable(~dysp+bronc+either, values=c(9, 1, 7, 3, 8, 2, 1, 9), levels=yn)
chest.cpt &lt;- compileCPT(a, t.a, s, l.s, b.s, e.lt, x.e, d.be)
chest.bn &lt;- grain(chest.cpt)

## These two forms are equivalent
bn1 &lt;- setFinding(chest.bn, nodes=c("chest", "xray"), states=c("yes", "yes"))
bn2 &lt;- setFinding(chest.bn, flist=list(c("chest", "yes"), c("xray", "yes")))

getFinding(bn1)
getFinding(bn2)

pFinding(bn1)
pFinding(bn2)

bn1 &lt;- retractFinding(bn1, nodes="asia")
bn2 &lt;- retractFinding(bn2, nodes="asia")

getFinding(bn1)
getFinding(bn2)

pFinding(bn1)
pFinding(bn2)


</code></pre>

<hr>
<h2 id='generics'>gRain generics</h2><span id='topic+generics'></span><span id='topic+nodeNames'></span><span id='topic+nodeNames.grain'></span><span id='topic+nodeStates'></span><span id='topic+nodeStates.grain'></span><span id='topic+universe'></span><span id='topic+universe.grain'></span><span id='topic+isCompiled'></span><span id='topic+isPropagated'></span><span id='topic+isCompiled+3C-'></span><span id='topic+isPropagated+3C-'></span><span id='topic+vpar.cpt_spec'></span><span id='topic+vpar.cpt_grain'></span><span id='topic+rip.grain'></span><span id='topic+varNames.grainEvidence_'></span>

<h3>Description</h3>

<p>Generic functions etc for the gRain package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodeNames(object)

## S3 method for class 'grain'
nodeNames(object)

nodeStates(object, nodes = nodeNames(object))

## S3 method for class 'grain'
nodeStates(object, nodes = nodeNames(object))

universe(object, ...)

## S3 method for class 'grain'
universe(object, ...)

isCompiled(object)

isPropagated(object)

isCompiled(object) &lt;- value

isPropagated(object) &lt;- value

## S3 method for class 'cpt_spec'
vpar(object, ...)

## S3 method for class 'cpt_grain'
vpar(object, ...)

## S3 method for class 'grain'
rip(object, ...)

## S3 method for class 'grainEvidence_'
varNames(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generics_+3A_nodes">nodes</code></td>
<td>
<p>Some nodes of the object.</p>
</td></tr>
<tr><td><code id="generics_+3A_...">...</code></td>
<td>
<p>Additional arguments; currently not used.</p>
</td></tr>
<tr><td><code id="generics_+3A_value">value</code></td>
<td>
<p>Value to be set for slot in object.</p>
</td></tr>
<tr><td><code id="generics_+3A_x">x</code>, <code id="generics_+3A_object">object</code></td>
<td>
<p>A relevant object.</p>
</td></tr>
</table>

<hr>
<h2 id='get_superset_list'>Get superset for each element in a list</h2><span id='topic+get_superset_list'></span>

<h3>Description</h3>

<p>For each element (vector) x in x_set, find the first element (vector) y
in y_set such that x is contained in y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_superset_list(x_set, y_set, warn = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_superset_list_+3A_x_set">x_set</code></td>
<td>
<p>Vector or list of vectors.</p>
</td></tr>
<tr><td><code id="get_superset_list_+3A_y_set">y_set</code></td>
<td>
<p>Vector or list of vectors.</p>
</td></tr>
<tr><td><code id="get_superset_list_+3A_warn">warn</code></td>
<td>
<p>Should a warning be made if an element is found.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x_set &lt;- list(c("a", "b"), "e", c("b", "a"))
y_set &lt;- list(c("f","u", "e"), c("a", "b", "c", "a"), c("b", "c", "a"))
get_superset_list(x_set, y_set)
get_superset_list(letters[1:4], y_set)
get_superset_list(letters[1:4], letters[1:10])
get_superset_list(x_set, letters[1:10])
x_set &lt;- list(c("a", "b"), "e", c("b", "a"), "o")
y_set &lt;- list(c("f","u", "e"), c("a", "b", "c", "a"), c("b", "c", "a"))
get_superset_list(x_set, y_set, warn=TRUE)
get_superset_list(x_set, y_set, warn=FALSE)

</code></pre>

<hr>
<h2 id='grain_compile'>Compile a graphical independence network (a Bayesian network)</h2><span id='topic+grain_compile'></span><span id='topic+compile.grain'></span><span id='topic+compile.cpt_grain'></span><span id='topic+compile.pot_grain'></span>

<h3>Description</h3>

<p>Compiles a Bayesian network. This means creating a
junction tree and establishing clique potentials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grain'
compile(
  object,
  propagate = FALSE,
  tug = NULL,
  root = NULL,
  control = object$control,
  details = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grain_compile_+3A_object">object</code></td>
<td>
<p>A grain object.</p>
</td></tr>
<tr><td><code id="grain_compile_+3A_propagate">propagate</code></td>
<td>
<p>If TRUE the network is also propagated meaning
that the cliques of the junction tree are calibrated to each
other.</p>
</td></tr>
<tr><td><code id="grain_compile_+3A_tug">tug</code></td>
<td>
<p>A triangulated undirected graph.</p>
</td></tr>
<tr><td><code id="grain_compile_+3A_root">root</code></td>
<td>
<p>A set of variables which must be in the root of the
junction tree</p>
</td></tr>
<tr><td><code id="grain_compile_+3A_control">control</code></td>
<td>
<p>Controlling the compilation process.</p>
</td></tr>
<tr><td><code id="grain_compile_+3A_details">details</code></td>
<td>
<p>For debugging info. Do not use.</p>
</td></tr>
<tr><td><code id="grain_compile_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A compiled Bayesian network; an object of class
<code>grain</code>.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence
Networks with the gRain Package for R. Journal of Statistical
Software, 46(10), 1-26.
<a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grain">grain</a></code>, <code><a href="gRbase.html#topic+propagate">propagate</a></code>,
<code><a href="#topic+propagate.grain">propagate.grain</a></code>,
<code><a href="gRbase.html#topic+triangulate">triangulate</a></code>, <code><a href="gRbase.html#topic+rip">rip</a></code>,
<code><a href="gRbase.html#topic+junctionTree">junctionTree</a></code>
</p>

<hr>
<h2 id='grain_evidence'>Set, update and remove evidence.</h2><span id='topic+grain_evidence'></span><span id='topic+setEvidence'></span><span id='topic+retractEvidence'></span><span id='topic+absorbEvidence'></span><span id='topic+pEvidence'></span><span id='topic+getEvidence'></span><span id='topic+evidence'></span><span id='topic+evidence.grain'></span><span id='topic+evidence+3C-'></span><span id='topic+evidence+3C-.grain'></span>

<h3>Description</h3>

<p>Set, update and remove evidence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setEvidence(
  object,
  nodes = NULL,
  states = NULL,
  evidence = NULL,
  propagate = TRUE,
  details = 0
)

retractEvidence(object, nodes = NULL, propagate = TRUE)

absorbEvidence(object, propagate = TRUE)

pEvidence(object, evidence = NULL)

getEvidence(object, short = TRUE)

evidence(object, short = TRUE)

## S3 method for class 'grain'
evidence(object, short = TRUE)

evidence(object) &lt;- value

## S3 replacement method for class 'grain'
evidence(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grain_evidence_+3A_object">object</code></td>
<td>
<p>A &quot;grain&quot; object</p>
</td></tr>
<tr><td><code id="grain_evidence_+3A_nodes">nodes</code></td>
<td>
<p>A vector of nodes; those nodes for which the
(conditional) distribution is requested.</p>
</td></tr>
<tr><td><code id="grain_evidence_+3A_states">states</code></td>
<td>
<p>A vector of states (of the nodes given by 'nodes')</p>
</td></tr>
<tr><td><code id="grain_evidence_+3A_evidence">evidence</code></td>
<td>
<p>An alternative way of specifying findings
(evidence), see examples below.</p>
</td></tr>
<tr><td><code id="grain_evidence_+3A_propagate">propagate</code></td>
<td>
<p>Should the network be propagated?</p>
</td></tr>
<tr><td><code id="grain_evidence_+3A_details">details</code></td>
<td>
<p>Debugging information</p>
</td></tr>
<tr><td><code id="grain_evidence_+3A_short">short</code></td>
<td>
<p>If TRUE a dataframe with a summary is returned;
otherwise a list with all details.</p>
</td></tr>
<tr><td><code id="grain_evidence_+3A_value">value</code></td>
<td>
<p>The evidence in the form of a named list or an evidence-object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of tables with potentials.
</p>


<h3>Note</h3>

<p><code>setEvidence()</code> is an improvement of <code>setFinding()</code>
(and as such <code>setFinding</code> is obsolete). Users are
recommended to use <code>setEvidence()</code> in the future.
</p>
<p><code>setEvidence()</code> allows to specification of &quot;hard evidence&quot; (specific
values for variables) and likelihood evidence (also known as virtual
evidence) for variables.
</p>
<p>The syntax of <code>setEvidence()</code> may change in the future.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence Networks
with the gRain Package for R. Journal of Statistical Software,
46(10), 1-26.  <a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setFinding">setFinding</a></code>, <code><a href="#topic+getFinding">getFinding</a></code>,
<code><a href="#topic+retractFinding">retractFinding</a></code>, <code><a href="#topic+pFinding">pFinding</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(chest_cpt)
chest.bn &lt;- grain(compileCPT(chest_cpt))
chest.bn &lt;- compile(chest.bn)

## 1) These two forms are identical
setEvidence(chest.bn, c("asia", "xray"), c("yes", "yes"))
setFinding(chest.bn, c("asia", "xray"), c("yes", "yes"))

## 2) Suppose we do not know with certainty whether a patient has
## recently been to Asia. We can then introduce a new variable
## "guess.asia" with "asia" as its only parent. Suppose
## p(guess.asia=yes|asia=yes)=.8 and p(guess.asia=yes|asia=no)=.1
## If the patient is e.g. unusually tanned we may set
## guess.asia=yes and propagate.
##
## This corresponds to modifying the model by the likelihood (0.8,
## 0.1) as

setEvidence(chest.bn, c("asia", "xray"), list(c(0.8, 0.1), "yes"))

## 3) Hence, the same result as in 1) can be obtained with
setEvidence(chest.bn, c("asia", "xray"), list(c(1, 0), "yes"))

## 4) An alternative specification using evidence is
setEvidence(chest.bn, evidence=list(asia=c(1, 0), xray="yes"))

</code></pre>

<hr>
<h2 id='grain_joint_evidence'>Set joint evidence in grain objects</h2><span id='topic+grain_joint_evidence'></span><span id='topic+setJEvidence'></span><span id='topic+print.grain_joint_evidence'></span><span id='topic+retractJEvidence'></span><span id='topic+new_jev'></span>

<h3>Description</h3>

<p>Setting and removing joint evidence in grain objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setJEvidence(object, evidence = NULL, propagate = TRUE, details = 0)

retractJEvidence(object, items = NULL, propagate = TRUE, details = 0)

new_jev(ev, levels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grain_joint_evidence_+3A_object">object</code></td>
<td>
<p>A &quot;grain&quot; object.</p>
</td></tr>
<tr><td><code id="grain_joint_evidence_+3A_evidence">evidence</code></td>
<td>
<p>A list of evidence. Each element is a named array.</p>
</td></tr>
<tr><td><code id="grain_joint_evidence_+3A_propagate">propagate</code></td>
<td>
<p>Should evidence be absorbed once entered; defaults
to TRUE.</p>
</td></tr>
<tr><td><code id="grain_joint_evidence_+3A_details">details</code></td>
<td>
<p>Amount of printing; for debugging.</p>
</td></tr>
<tr><td><code id="grain_joint_evidence_+3A_items">items</code></td>
<td>
<p>Items in the evidence list to be removed. Here,
<code>NULL</code> means remove everything, <code>0</code> means nothing is
removed. Otherwise <code>items</code> is a numeric vector.</p>
</td></tr>
<tr><td><code id="grain_joint_evidence_+3A_ev">ev</code></td>
<td>
<p>A named list.</p>
</td></tr>
<tr><td><code id="grain_joint_evidence_+3A_levels">levels</code></td>
<td>
<p>A named list.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>All the joint evidence functionality should be used with
great care.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chest_cpt)
chest.bn &lt;- grain(compileCPT(chest_cpt))
chest.bn &lt;- compile(chest.bn)

uni &lt;- list(asia = c("yes", "no"), tub = c("yes", "no"),
            smoke = c("yes", "no"), lung = c("yes", "no"),
            bronc = c("yes", "no"), either = c("yes", "no"),
            xray = c("yes", "no"), dysp = c("yes", "no"))

ev &lt;- list(tabNew("asia", levels=uni, values=c(1,0)),
           tabNew("dysp", levels=uni, values=c(1,0)),
           tabNew(c("dysp","bronc"), levels=uni, values=c(.1, .2, .9, .8)) )

chest.bn
chest.bn2 &lt;- setJEvidence(chest.bn, evidence=ev)
chest.bn2
getEvidence(chest.bn2)

# Notice: The evidence is defined on (subsets of) cliques of the junction tree
# and therefore evidence can readily be absorbed:
getgrain(chest.bn, "rip")$cliques  %&gt;% str

# On the other hand, below is evidence which is not defined cliques
# of the junction tree and therefore evidence can not easily be
# absorbed.  Hence this will fail:

## Not run: 
ev.fail &lt;- list(tabNew(c("dysp","smoke"), levels=uni, values=c(.1, .2, .9, .8)) )
setJEvidence(chest.bn, evidence=ev.fail)

## End(Not run)

## Evidence can be removed with

retractJEvidence(chest.bn2)      ## All evidence removed.
retractJEvidence(chest.bn2, 0)   ## No evidence removed.
retractJEvidence(chest.bn2, 1:2) ## Evidence items 1 and 2 are removed.

# Setting additional joint evidence to an object where joint
# evidence already is set will cause an error. Hence this will fail:

## Not run: 
  ev2 &lt;- list(smoke="yes")
  setJEvidence(chest.bn2, evidence=ev2)

## End(Not run)

## Instead we can do
new.ev &lt;- c(getEvidence(chest.bn2), list(smoke="yes"))
chest.bn
setJEvidence(chest.bn, evidence=new.ev)

## Create joint evidence object:
yn &lt;- c("yes", "no")
db &lt;- tabNew(c("dysp", "bronc"), list(dysp=yn, bronc=yn), values=c(.1, .2, .9, .8))
db
ev   &lt;- list(asia=c(1, 0), dysp="yes", db)

jevi &lt;- new_jev(ev, levels=uni)
jevi

chest.bn3 &lt;- setJEvidence(chest.bn, evidence=jevi)
evidence(chest.bn3)

</code></pre>

<hr>
<h2 id='grain_predict'>Make predictions from a probabilistic network</h2><span id='topic+grain_predict'></span><span id='topic+predict.grain'></span>

<h3>Description</h3>

<p>Makes predictions (either as the most likely state or
as the conditional distributions) of variables conditional on
finding (evidence) on other variables in an independence
network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grain'
predict(
  object,
  response,
  predictors = setdiff(names(newdata), response),
  newdata,
  type = "class",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grain_predict_+3A_object">object</code></td>
<td>
<p>A grain object</p>
</td></tr>
<tr><td><code id="grain_predict_+3A_response">response</code></td>
<td>
<p>A vector of response variables to make predictions
on</p>
</td></tr>
<tr><td><code id="grain_predict_+3A_predictors">predictors</code></td>
<td>
<p>A vector of predictor variables to make
predictions from.  Defaults to all variables that are note
responses.</p>
</td></tr>
<tr><td><code id="grain_predict_+3A_newdata">newdata</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="grain_predict_+3A_type">type</code></td>
<td>
<p>If &quot;class&quot;, the most probable class is returned; if
&quot;distribution&quot; the conditional distribution is returned.</p>
</td></tr>
<tr><td><code id="grain_predict_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components </p>
<table>
<tr><td><code>pred</code></td>
<td>
<p>A list with the
predictions</p>
</td></tr> <tr><td><code>pFinding</code></td>
<td>
<p>A vector with the probability of
the finding (evidence) on which the prediction is based</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence Networks
with the gRain Package for R. Journal of Statistical Software,
46(10), 1-26.  <a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grain">grain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chest_cpt)
data(chestSim500)

chest.bn &lt;- grain(compileCPT(chest_cpt))
nd &lt;- chestSim500[1:4]

predict(chest.bn, response="bronc", newdata=nd)
predict(chest.bn, response="bronc", newdata=nd, type="distribution")

</code></pre>

<hr>
<h2 id='grain_propagate'>Propagate a graphical independence network (a Bayesian network)</h2><span id='topic+grain_propagate'></span><span id='topic+propagate.grain'></span><span id='topic+propagateLS'></span><span id='topic+propagateLS__'></span><span id='topic+compute_p_evidence'></span>

<h3>Description</h3>

<p>Propagation refers to calibrating the cliques of the
junction tree so that the clique potentials are consistent on
their intersections; refer to the reference below for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grain'
propagate(object, details = object$details, engine = "cpp", ...)

propagateLS(cq_pot_list, rip, initialize = TRUE, details = 0)

compute_p_evidence(object, details = object$details, engine = "cpp", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grain_propagate_+3A_object">object</code></td>
<td>
<p>A grain object</p>
</td></tr>
<tr><td><code id="grain_propagate_+3A_details">details</code></td>
<td>
<p>For debugging info</p>
</td></tr>
<tr><td><code id="grain_propagate_+3A_engine">engine</code></td>
<td>
<p>Either &quot;R&quot; or &quot;cpp&quot;; &quot;cpp&quot; is the default and the
fastest.</p>
</td></tr>
<tr><td><code id="grain_propagate_+3A_...">...</code></td>
<td>
<p>Currently not used</p>
</td></tr>
<tr><td><code id="grain_propagate_+3A_cq_pot_list">cq_pot_list</code></td>
<td>
<p>List of clique potentials</p>
</td></tr>
<tr><td><code id="grain_propagate_+3A_rip">rip</code></td>
<td>
<p>A rip ordering</p>
</td></tr>
<tr><td><code id="grain_propagate_+3A_initialize">initialize</code></td>
<td>
<p>Always true.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>propagate</code> method invokes <code>propagateLS</code>
which is a pure R implementation of the Lauritzen-Spiegelhalter
algorithm. The c++ based version is several times faster than
the purely R based version.
</p>


<h3>Value</h3>

<p>A compiled and propagated grain object.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence Networks
with the gRain Package for R. Journal of Statistical Software,
46(10), 1-26.  <a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grain">grain</a></code>, <code><a href="gRbase.html#topic+compile">compile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example("grain")

## Uncompiled and unpropageted network:
bn0  &lt;- grain(chest_cpt, compile=FALSE)
bn0
## Compiled but unpropageted network:
bn1  &lt;- compile(bn0, propagate=FALSE)
## Compiled and propagated network
bn2  &lt;- propagate(bn1)
bn2
## Default is that networks are compiled but not propagated at creation time:
bn3  &lt;- grain(chest_cpt) 
bn3 
</code></pre>

<hr>
<h2 id='grain-main'>Graphical Independence Network</h2><span id='topic+grain-main'></span><span id='topic+grain'></span><span id='topic+grain.cpt_spec'></span><span id='topic+grain.CPTspec'></span><span id='topic+grain.pot_spec'></span><span id='topic+grain.igraph'></span><span id='topic+grain.dModel'></span>

<h3>Description</h3>

<p>Creating grain objects (graphical independence network).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grain(x, ...)

## S3 method for class 'cpt_spec'
grain(x, control = list(), smooth = 0, compile = TRUE, details = 0, ...)

## S3 method for class 'CPTspec'
grain(x, control = list(), smooth = 0, compile = TRUE, details = 0, ...)

## S3 method for class 'pot_spec'
grain(x, control = list(), smooth = 0, compile = TRUE, details = 0, ...)

## S3 method for class 'igraph'
grain(
  x,
  control = list(),
  smooth = 0,
  compile = TRUE,
  details = 0,
  data = NULL,
  ...
)

## S3 method for class 'dModel'
grain(
  x,
  control = list(),
  smooth = 0,
  compile = TRUE,
  details = 0,
  data = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grain-main_+3A_x">x</code></td>
<td>
<p>An argument to build an independence network
from. Typically a list of conditional probability tables, a DAG
or an undirected graph. In the two latter cases, data must also
be provided.</p>
</td></tr>
<tr><td><code id="grain-main_+3A_...">...</code></td>
<td>
<p>Additional arguments, currently not used.</p>
</td></tr>
<tr><td><code id="grain-main_+3A_control">control</code></td>
<td>
<p>A list defining controls, see 'details' below.</p>
</td></tr>
<tr><td><code id="grain-main_+3A_smooth">smooth</code></td>
<td>
<p>A (usually small) number to add to the counts of a
table if the grain is built from a graph plus a dataset.</p>
</td></tr>
<tr><td><code id="grain-main_+3A_compile">compile</code></td>
<td>
<p>Should network be compiled.</p>
</td></tr>
<tr><td><code id="grain-main_+3A_details">details</code></td>
<td>
<p>Debugging information.</p>
</td></tr>
<tr><td><code id="grain-main_+3A_data">data</code></td>
<td>
<p>An optional data set (currently must be an array/table)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If 'smooth' is non-zero then entries of 'values' which a
zero are replaced by the value of 'smooth' - BEFORE any
normalization takes place.
</p>


<h3>Value</h3>

<p>An object of class &quot;grain&quot;
</p>


<h3>Note</h3>

<p>A change from earlier versions of this package is that grain
objects are now compiled upon creation.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence
Networks with the gRain Package for R. Journal of Statistical
Software, 46(10), 1-26.
<a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cptable">cptable</a></code>, <code><a href="#topic+compile.grain">compile.grain</a></code>,
<code><a href="#topic+propagate.grain">propagate.grain</a></code>, <code><a href="#topic+setFinding">setFinding</a></code>,
<code><a href="#topic+setEvidence">setEvidence</a></code>, <code><a href="#topic+getFinding">getFinding</a></code>,
<code><a href="#topic+pFinding">pFinding</a></code>, <code><a href="#topic+retractFinding">retractFinding</a></code>,
<code><a href="#topic+extract_cpt">extract_cpt</a></code>, <code><a href="#topic+extract_pot">extract_pot</a></code>,
<code><a href="#topic+compileCPT">compileCPT</a></code>, <code><a href="#topic+compilePOT">compilePOT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Create network from conditional probability tables CPTs:

yn   &lt;- c("yes", "no")
a    &lt;- cpt(~asia,                  values=c(1,99), levels=yn)
t.a  &lt;- cpt(~tub + asia,            values=c(5,95,1,99), levels=yn)
s    &lt;- cpt(~smoke,                 values=c(5,5), levels=yn)
l.s  &lt;- cpt(~lung + smoke,          values=c(1,9,1,99), levels=yn)
b.s  &lt;- cpt(~bronc + smoke,         values=c(6,4,3,7), levels=yn)
e.lt &lt;- cpt(~either + lung + tub,   values=c(1,0,1,0,1,0,0,1), levels=yn)
x.e  &lt;- cpt(~xray + either,         values=c(98,2,5,95), levels=yn)
d.be &lt;- cpt(~dysp + bronc + either, values=c(9,1,7,3,8,2,1,9), levels=yn)
cpt_list  &lt;- list(a, t.a, s, l.s, b.s, e.lt, x.e, d.be)
chest_cpt &lt;- compileCPT(cpt_list)
## Alternative: chest_cpt &lt;- compileCPT(a, t.a, s, l.s, b.s, e.lt, x.e, d.be)

chest_bn  &lt;- grain(chest_cpt)

## Create network from data and graph specification.

data(lizard, package="gRbase")

## From a DAG: height &lt;- species -&gt; diam
daG &lt;- dag(~species + height:species + diam:species, result="igraph")

## From an undirected graph UG : [height:species][diam:species]
uG  &lt;- ug(~height:species + diam:species, result="igraph")

liz.ug   &lt;- grain(uG, data=lizard)
liz.dag  &lt;- grain(daG, data=lizard)
</code></pre>

<hr>
<h2 id='grain-simulate'>Simulate from an independence network</h2><span id='topic+grain-simulate'></span><span id='topic+simulate.grain'></span>

<h3>Description</h3>

<p>Simulate data from an independence network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grain'
simulate(object, nsim = 1, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grain-simulate_+3A_object">object</code></td>
<td>
<p>An independence network.</p>
</td></tr>
<tr><td><code id="grain-simulate_+3A_nsim">nsim</code></td>
<td>
<p>Number of cases to simulate.</p>
</td></tr>
<tr><td><code id="grain-simulate_+3A_seed">seed</code></td>
<td>
<p>An optional integer controlling the random number
generation.</p>
</td></tr>
<tr><td><code id="grain-simulate_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence Networks
with the gRain Package for R. Journal of Statistical Software,
46(10), 1-26.  <a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tf &lt;- system.file("huginex", "chest_clinic.net", package = "gRain")

chest &lt;- loadHuginNet(tf, details=1)
simulate(chest,n=10) 

chest2 &lt;- setFinding(chest, c("VisitToAsia", "Dyspnoea"),
                            c("yes", "yes"))
simulate(chest2, n=10)
</code></pre>

<hr>
<h2 id='grass'>Wet grass example</h2><span id='topic+grass'></span><span id='topic+grass_cpt'></span>

<h3>Description</h3>

<p>Conditional probability tables for the wet grass example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(grass_cpt)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## 'data' generated with the following code fragment
yn &lt;- c("yes", "no")
p.R    &lt;- cptable(~R, values=c(.2, .8), levels=yn)
p.S_R  &lt;- cptable(~S:R, values=c(.01, .99, .4, .6), levels=yn)
p.G_SR &lt;- cptable(~G:S:R, values=c(.99, .01, .8, .2, .9, .1, 0, 1), levels=yn)

grain(compileCPT(p.R, p.S_R, p.G_SR))

# 'data' generated from
grass_cpt &lt;- list(p.R, p.S_R, p.G_SR)

data(grass_cpt)

</code></pre>

<hr>
<h2 id='internal-grain'>Internal functions for the gRain package</h2><span id='topic+internal-grain'></span><span id='topic++25+3E+25'></span><span id='topic+getgin'></span><span id='topic+getgrain'></span><span id='topic+plot.grain'></span><span id='topic+printlist'></span><span id='topic+splitVec'></span>

<h3>Description</h3>

<p>These functions should not be called directly by the user
</p>

<hr>
<h2 id='load-save-hugin'>Load and save Hugin net files</h2><span id='topic+load-save-hugin'></span><span id='topic+loadHuginNet'></span><span id='topic+saveHuginNet'></span>

<h3>Description</h3>

<p>These functions can load a net file saved in the
'Hugin format' into R and save a network in R as a file in the
'Hugin format'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadHuginNet(file, description = NULL, details = 0)

saveHuginNet(gin, file, details = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load-save-hugin_+3A_file">file</code></td>
<td>
<p>Name of Hugin net file. Convenient to give the file the
extension '.net'</p>
</td></tr>
<tr><td><code id="load-save-hugin_+3A_description">description</code></td>
<td>
<p>A text describing the network, defaults to
<code>file</code></p>
</td></tr>
<tr><td><code id="load-save-hugin_+3A_details">details</code></td>
<td>
<p>Debugging information.</p>
</td></tr>
<tr><td><code id="load-save-hugin_+3A_gin">gin</code></td>
<td>
<p>An independence network</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>grain</code>.
</p>


<h3>Note</h3>


<ul>
<li><p> In Hugin, it is possible to specify the potential of a node as a
functional relation between other nodes.  In a .net file, such a
specification will appear as 'function' rather than as
'node'. Such a specification is not recognized by <code>loadHuginNet</code>.
</p>
</li>
<li><p> It is recommended to avoid the text <code>node</code> as part of the name of
a node.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence
Networks with the gRain Package for R. Journal of Statistical
Software, 46(10), 1-26.
<a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grain">grain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Load HUGIN net file
tf &lt;- system.file("huginex", "chest_clinic.net", package = "gRain")
chest &lt;- loadHuginNet(tf, details=1)
chest 

## Save a copy
td &lt;- tempdir()
saveHuginNet(chest, paste(td,"/chest.net",sep=''))

## Load the copy
chest2 &lt;- loadHuginNet(paste(td,"/chest.net",sep=''))

tf &lt;- system.file("huginex", "golf.net", package = "gRain")
golf &lt;- loadHuginNet(tf, details=1)

saveHuginNet(golf, paste(td,"/golf.net",sep=''))
golf2 &lt;- loadHuginNet(paste(td,"/golf.net",sep=''))

</code></pre>

<hr>
<h2 id='logical'>Conditional probability tables based on logical dependencies</h2><span id='topic+logical'></span><span id='topic+booltab'></span><span id='topic+andtable'></span><span id='topic+ortable'></span><span id='topic+andtab'></span><span id='topic+ortab'></span>

<h3>Description</h3>

<p>Generate conditional probability tables based on the
logical expressions AND and OR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>booltab(vpa, levels = c(TRUE, FALSE), op = `&amp;`)

andtab(vpa, levels = c(TRUE, FALSE))

ortab(vpa, levels = c(TRUE, FALSE))

andtable(vpa, levels = c(TRUE, FALSE))

ortable(vpa, levels = c(TRUE, FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logical_+3A_vpa">vpa</code></td>
<td>
<p>Node and two parents; as a formula or a character
vector.</p>
</td></tr>
<tr><td><code id="logical_+3A_levels">levels</code></td>
<td>
<p>The levels (or rather labels) of v, see 'examples'
below.</p>
</td></tr>
<tr><td><code id="logical_+3A_op">op</code></td>
<td>
<p>A logical operator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Regarding the form of the argument <code>vpa</code>: To specify
<code class="reqn">P(a|b,c)</code> one may write <code>~a|b+c</code> or <code>~a+b+c</code> or
<code>~a|b:c</code> or <code>~a:b:c</code> or <code>c("a","b","c")</code>.
Internally, the last form is used. Notice that the <code>+</code> and
<code>:</code> operator are used as separators only. The order of the
variables is important so <code>+</code> and <code>:</code> DO NOT commute.
</p>


<h3>Value</h3>

<p>An array.
</p>


<h3>Note</h3>

<p><code>andtable</code> and <code>ortable</code> are aliases for
<code>andtab</code> and <code>ortab</code> and are kept for backward
compatibility.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence Networks
with the gRain Package for R. Journal of Statistical Software,
46(10), 1-26.  <a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cptable">cptable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Logical OR:

## A variable v is TRUE if either of its parents pa1 and pa2 are TRUE:
ortab( c("v", "pa1", "pa2") ) %&gt;% ftable(row.vars="v")
## TRUE and FALSE can be recoded to e.g. yes and no:
ortab( c("v", "pa1", "pa2"), levels=c("yes", "no") ) %&gt;% ftable(row.vars="v")

## Logical AND:

## Same story here:
andtab(c("v", "pa1", "pa2") ) %&gt;% ftable(row.vars="v")
andtab(c("v", "pa1", "pa2"), levels=c("yes", "no") ) %&gt;% ftable(row.vars="v")

## Combined approach

booltab(c("v", "pa1", "pa2"), op=`&amp;`) %&gt;% ftable(row.vars="v") ## AND
booltab(c("v", "pa1", "pa2"), op=`|`) %&gt;% ftable(row.vars="v") ## OR

booltab(~v + pa1 + pa2, op=`&amp;`) %&gt;% ftable(row.vars="v") ## AND
booltab(~v + pa1 + pa2, op=`|`) %&gt;% ftable(row.vars="v") ## OR

</code></pre>

<hr>
<h2 id='mendel'>Mendelian segregation</h2><span id='topic+mendel'></span>

<h3>Description</h3>

<p>Generate conditional probability table for Mendelian
segregation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mendel(allele, names = c("child", "father", "mother"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mendel_+3A_allele">allele</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="mendel_+3A_names">names</code></td>
<td>
<p>Names of columns in dataframe.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>No error checking at all on the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Inheritance of the alleles "y" and "g"

men &lt;- mendel(c("y","g"), names=c("ch", "fa", "mo"))
men

</code></pre>

<hr>
<h2 id='querygrain'>Query a network</h2><span id='topic+querygrain'></span><span id='topic+querygrain.grain'></span><span id='topic+qgrain'></span>

<h3>Description</h3>

<p>Query an independence network, i.e. obtain the
conditional distribution of a set of variables - possibly (and
typically) given finding (evidence) on other variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>querygrain(
  object,
  nodes = nodeNames(object),
  type = "marginal",
  evidence = NULL,
  exclude = TRUE,
  normalize = TRUE,
  simplify = FALSE,
  result = "array",
  details = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="querygrain_+3A_object">object</code></td>
<td>
<p>A <code>grain</code> object.</p>
</td></tr>
<tr><td><code id="querygrain_+3A_nodes">nodes</code></td>
<td>
<p>A vector of nodes; those nodes for which the
(conditional) distribution is requested.</p>
</td></tr>
<tr><td><code id="querygrain_+3A_type">type</code></td>
<td>
<p>Valid choices are <code>"marginal"</code> which gives the
marginal distribution for each node in <code>nodes</code>;
<code>"joint"</code> which gives the joint distribution for
<code>nodes</code> and <code>"conditional"</code> which gives the
conditional distribution for the first variable in <code>nodes</code>
given the other variables in <code>nodes</code>.</p>
</td></tr>
<tr><td><code id="querygrain_+3A_evidence">evidence</code></td>
<td>
<p>An alternative way of specifying findings
(evidence), see examples below.</p>
</td></tr>
<tr><td><code id="querygrain_+3A_exclude">exclude</code></td>
<td>
<p>If <code>TRUE</code> then nodes on which evidence is given
will be excluded from <code>nodes</code> (see above).</p>
</td></tr>
<tr><td><code id="querygrain_+3A_normalize">normalize</code></td>
<td>
<p>Should the results be normalized to sum to one.</p>
</td></tr>
<tr><td><code id="querygrain_+3A_simplify">simplify</code></td>
<td>
<p>Should the result be simplified (to a dataframe) if
possible.</p>
</td></tr>
<tr><td><code id="querygrain_+3A_result">result</code></td>
<td>
<p>If &quot;data.frame&quot; the result is returned as a data
frame (or possibly as a list of dataframes).</p>
</td></tr>
<tr><td><code id="querygrain_+3A_details">details</code></td>
<td>
<p>Debugging information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of tables with potentials.
</p>


<h3>Note</h3>

<p><code>setEvidence()</code> is an improvement of <code>setFinding()</code>
(and as such <code>setFinding</code> is obsolete). Users are
recommended to use <code>setEvidence()</code> in the future.
</p>
<p><code>setEvidence()</code> allows to specification of &quot;hard evidence&quot; (specific
values for variables) and likelihood evidence (also known as virtual
evidence) for variables.
</p>
<p>The syntax of <code>setEvidence()</code> may change in the future.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence Networks
with the gRain Package for R. Journal of Statistical Software,
46(10), 1-26.  <a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setEvidence">setEvidence</a></code>, <code><a href="#topic+getEvidence">getEvidence</a></code>,
<code><a href="#topic+retractEvidence">retractEvidence</a></code>, <code><a href="#topic+pEvidence">pEvidence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
testfile &lt;- system.file("huginex", "chest_clinic.net", package = "gRain")
chest &lt;- loadHuginNet(testfile, details=0)
qb &lt;- querygrain(chest)
qb

lapply(qb, as.numeric) # Safe
sapply(qb, as.numeric) # Risky

</code></pre>

<hr>
<h2 id='repeat_pattern'>Create repeated patterns in Bayesian networks</h2><span id='topic+repeat_pattern'></span><span id='topic+repeatPattern'></span>

<h3>Description</h3>

<p>Repeated patterns is a useful model specification
short cut for Bayesian networks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repeat_pattern(plist, instances, unlist = TRUE, data = NULL)

repeatPattern(plist, instances, unlist = TRUE, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repeat_pattern_+3A_plist">plist</code></td>
<td>
<p>A list of conditional probability tables. The variable
names must have the form <code>name[i]</code> and the <code>i</code> will
be substituted by the values given in <code>instances</code> below.
See also the <code>data</code> argument.</p>
</td></tr>
<tr><td><code id="repeat_pattern_+3A_instances">instances</code></td>
<td>
<p>A vector of consecutive integers</p>
</td></tr>
<tr><td><code id="repeat_pattern_+3A_unlist">unlist</code></td>
<td>
<p>If <code>FALSE</code> the result is a list in which each
element is a copy of <code>plist</code> in which <code>name[i]</code> are
substituted. If <code>TRUE</code> the result is the result of
applying <code>unlist()</code>.</p>
</td></tr>
<tr><td><code id="repeat_pattern_+3A_data">data</code></td>
<td>
<p>A two column matrix. The first column is the index /
name of a node; the second column is the index / name of the
node's parent.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence
Networks with the gRain Package for R. Journal of Statistical
Software, 46(10), 1-26.
<a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grain">grain</a></code>, <code><a href="#topic+compile_cpt">compile_cpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
yn &lt;- c("yes", "no")
n &lt;- 3

## Example: Markov chain

x_init  &lt;- cpt(~x0, values=c(1, 9), levels=yn)                  ## p(x0)
x_trans &lt;- cpt(~x[i]|x[i-1], values=c(1, 99, 2, 98), levels=yn) ## p(x[i]|x[i-1])
pat     &lt;- list(x_trans)                             
rep.pat &lt;- repeat_pattern(pat, instances=1:n)

mc &lt;- compile_cpt(c(list(x_init), rep.pat))
mc
mc &lt;- mc |&gt; grain()

## Example: Hidden markov model:
# The x[i]'s are unobserved, the y[i]'s can be observed.

x_init  &lt;- cpt(~x0, values=c(1, 9), levels=yn)                   ##  p(x0)
x_trans &lt;- cpt(~x[i]|x[i-1], values=c(1, 99, 2, 98), levels=yn)  ##  p(x[i]|x[i-1])
y_emis  &lt;- cpt(~y[i]|x[i], values=c(10, 90, 20, 80), levels=yn)  ##  p(y[i]|x[i]) 

pat     &lt;- list(x_trans, y_emis) ## Pattern to be repeated
rep.pat &lt;- repeat_pattern(pat, instances=1:n)
hmm &lt;- compile_cpt(c(list(x_init), rep.pat)) 
hmm
hmm &lt;- hmm |&gt; grain()

## Data-driven variable names

dep &lt;- data.frame(i=c(1, 2, 3, 4, 5, 6, 7, 8),
                  p=c(0, 1, 2, 2, 3, 3, 4, 4))

x0 &lt;- cpt(~x0, values=c(0.5, 0.5), levels=yn)
xa &lt;- cpt(~x[i] | x[data[i, "p"]], values=c(1, 9, 2, 8), levels=yn)
xb &lt;- repeat_pattern(list(xa), instances=1:nrow(dep), data=dep)
tree &lt;- compile_cpt(c(list(x0), xb))
tree
tree &lt;- tree |&gt; grain()
tree 

</code></pre>

<hr>
<h2 id='replace-cpt'>Replace CPTs in Bayesian network</h2><span id='topic+replace-cpt'></span><span id='topic+replaceCPT'></span><span id='topic+replaceCPT.cpt_grain'></span>

<h3>Description</h3>

<p>Replace CPTs of Bayesian network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replaceCPT(object, value)

## S3 method for class 'cpt_grain'
replaceCPT(object, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace-cpt_+3A_object">object</code></td>
<td>
<p>A <code>grain</code> object.</p>
</td></tr>
<tr><td><code id="replace-cpt_+3A_value">value</code></td>
<td>
<p>A named list, see examples below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When a Bayesian network (BN) is constructed from a list of
conditional probability tables (CPTs) (e.g. using the function
<code>grain()</code>), various actions are taken:
</p>

<ol>
<li><p> It is checked that the list of CPTs define a directed acyclic graph (DAG).
</p>
</li>
<li><p> The DAG is moralized and triangulated.
</p>
</li>
<li><p> A list of clique potentials (one for each clique in the
triangulated graph) is created from the list of CPTs.
</p>
</li>
<li><p> The clique potentials are, by default, calibrated to each other
so that the potentials contain marginal distributions.
</p>
</li></ol>

<p>The function described here bypass the first two steps which can
provide an important gain in speed compared to constructing a new
BN with a new set of CPTs with the same DAG.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Søren Højsgaard (2012). Graphical Independence Networks
with the gRain Package for R. Journal of Statistical Software,
46(10), 1-26.  <a href="https://www.jstatsoft.org/v46/i10/">https://www.jstatsoft.org/v46/i10/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grain">grain</a></code>, <code><a href="gRbase.html#topic+propagate">propagate</a></code>,
<code><a href="gRbase.html#topic+triangulate">triangulate</a></code>, <code><a href="gRbase.html#topic+rip">rip</a></code>,
<code><a href="gRbase.html#topic+junctionTree">junctionTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the wet grass example at
## https://en.wikipedia.org/wiki/Bayesian_network

yn &lt;- c("yes", "no")
p.R    &lt;- cptable(~R, values=c(.2, .8), levels=yn)
p.S_R  &lt;- cptable(~S:R, values=c(.01, .99, .4, .6), levels=yn)
p.G_SR &lt;- cptable(~G:S:R, values=c(.99, .01, .8, .2, .9, .1, 0, 1), levels=yn)

wet.bn &lt;- compileCPT(p.R, p.S_R, p.G_SR)  |&gt; grain()
getgrain(wet.bn, "cpt")[c("R","S")]

# Update some CPTs
wet.bn &lt;- replaceCPT(wet.bn, list(R=c(.3, .7), S=c(.1, .9, .7, .3)))
getgrain(wet.bn, "cpt")[c("R","S")]

</code></pre>

<hr>
<h2 id='simplify_query'>Simplify output query to a Bayesian network</h2><span id='topic+simplify_query'></span>

<h3>Description</h3>

<p>Simplify output query to a Bayesian network to a dataframe provided
that each node has the same levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplify_query(b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplify_query_+3A_b">b</code></td>
<td>
<p>Result from running querygrain.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
