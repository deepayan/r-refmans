<!DOCTYPE html><html><head><title>Help for package antitrust</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {antitrust}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AIDS-Functions'><p>(Nested) AIDS Calibration and Merger Simulation</p></a></li>
<li><a href='#antitrust_shiny'><p>Deprecated functions in package <span class="pkg">antitrust</span>.</p></a></li>
<li><a href='#antitrust_shiny-deprecated'><p>A Shiny Interface to the Antitrust Package</p></a></li>
<li><a href='#Antitrust-Class'><p>&ldquo;Antitrust&rdquo; Classes</p></a></li>
<li><a href='#Auction-Classes'><p>Class &ldquo;Auction&rdquo;</p></a></li>
<li><a href='#Auction2ndCap-Functions'><p>(Capacity Constrained) 2nd Price Auction Model</p></a></li>
<li><a href='#Auction2ndLogit-Functions'><p>2nd Score Procurement Auction Model with (Nested) Logit Demand</p></a></li>
<li><a href='#AuctionCap-Methods'><p>Auction Cap Methods</p></a></li>
<li><a href='#Bargaining-Classes'><p>&ldquo;Bargaining&rdquo; Classes</p></a></li>
<li><a href='#BargainingLogit-Functions'><p>Nash Bargaining Model with Logit Demand</p></a></li>
<li><a href='#Bertrand-Functions'><p>Bertrand Calibration and Merger Simulation With Logit, CES and AIDS Demand</p></a></li>
<li><a href='#BertrandOther-Classes'><p>&ldquo;Bertrand&rdquo; Classes</p></a></li>
<li><a href='#BertrandRUM-Classes'><p>&ldquo;Bertrand RUM&rdquo; Classes</p></a></li>
<li><a href='#CES-Functions'><p>(Nested) Constant Elasticity of Substitution Demand Calibration and Merger Simulation</p></a></li>
<li><a href='#CMCR-Methods'><p>Methods For Calculating Compensating Marginal Cost Reductions</p></a></li>
<li><a href='#CMCRBertrand-Functions'><p>Compensating Marginal Cost Reductions and Upwards Pricing Pressure (Bertrand)</p></a></li>
<li><a href='#CMCRCournot-Functions'><p>Compensating Marginal Cost Reductions and Upwards Pricing Pressure (Cournot)</p></a></li>
<li><a href='#Cost-Methods'><p>Methods for Calculating marginal and Variable Costs</p></a></li>
<li><a href='#Cournot-classes'><p>&ldquo;Cournot&rdquo; Classes</p></a></li>
<li><a href='#Cournot-Functions'><p>Multi-product Cournot/Stackelberg Calibration and Merger Simulation With Linear or Log-Linear Demand</p></a></li>
<li><a href='#CV-Methods'><p>Methods For Calculating Compensating Variation (CV)</p></a></li>
<li><a href='#defineMarketTools-methods'><p>Methods For Implementing The Hypothetical Monopolist Test</p></a></li>
<li><a href='#Diagnostics-Methods'><p>Methods for Calculating Diagnostics</p></a></li>
<li><a href='#Diversion-Methods'><p>Methods For Calculating Diversion</p></a></li>
<li><a href='#Elast-Methods'><p>Methods For Calculating Own and Cross-Price Elasticities</p></a></li>
<li><a href='#HHI-Functions'><p>Herfindahl-Hirschman Index</p></a></li>
<li><a href='#HHI-Methods'><p>Methods For Calculating the Herfindahl-Hirschman Index</p></a></li>
<li><a href='#Linear-Functions'><p>Linear and Log-Linear Demand Calibration and Merger Simulation</p></a></li>
<li><a href='#Logit-Functions'><p>(Nested) Logit Demand Calibration and Merger Simulation)</p></a></li>
<li><a href='#Margins-Methods'><p>Methods for Calculating Diagnostics</p></a></li>
<li><a href='#Output-Methods'><p>Output Methods</p></a></li>
<li><a href='#Ownership-methods'><p>Methods for Manipulating Ownership Matrices</p></a></li>
<li><a href='#Params-Methods'><p>Methods for Calculating Demand Parameters</p></a></li>
<li><a href='#Plot-Methods'><p>Methods For Calculating Upwards Pricing Pressure Index (Bertrand)</p></a></li>
<li><a href='#PriceDelta-Methods'><p>Methods For Calculating Price Delta</p></a></li>
<li><a href='#Prices-Methods'><p>&ldquo;Calculating Prices&rdquo; Methods</p></a></li>
<li><a href='#PS-methods'><p>Producer Surplus Methods</p></a></li>
<li><a href='#Show-Methods'><p>Show Method</p></a></li>
<li><a href='#Sim-Functions'><p>Merger Simulation With User-Supplied Demand Parameters</p></a></li>
<li><a href='#summary-methods'><p>Summary Methods</p></a></li>
<li><a href='#SupplyChain-Functions'><p>Supply Chain Merger Simulation</p></a></li>
<li><a href='#UPP-Methods'><p>Methods For Calculating Upwards Pricing Pressure Index (Bertrand)</p></a></li>
<li><a href='#Vertical-Classes'><p>&ldquo;Vertical&rdquo; Classes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Antitrust Practitioners</td>
</tr>
<tr>
<td>Version:</td>
<td>0.99.26</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-22</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Charles Taragin &lt;ctaragin+antitrustr@gmail.com&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, BB, numDeriv</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, knitr, bookdown, rmarkdown, competitiontoolbox</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of tools for antitrust practitioners, including the ability to calibrate different consumer demand systems and simulate the effects of mergers under different competitive regimes.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/luciu5/antitrust">https://github.com/luciu5/antitrust</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/publicdomain/zero/1.0/legalcode">CC0</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Collate:</td>
<td>'AntitrustClasses.R' 'BertrandClasses.R'
'BertrandRUMClasses.R' 'AuctionClasses.R' 'BargainingClasses.R'
'VerticalClasses.R' 'CournotClasses.R' 'OwnershipMethods.R'
'SummaryMethods.R' 'ShowMethods.R' 'AuctionCapMethods.R'
'PricesMethods.R' 'CostMethods.R' 'MarginsMethods.R'
'ParamsMethods.R' 'PriceDeltaMethods.R' 'PSMethods.R'
'OutputMethods.R' 'PlotMethods.R' 'HypoMonMethods.R'
'HHIMethods.R' 'UPPMethods.R' 'DiversionMethods.R'
'ElastMethods.R' 'CMCRMethods.R' 'CVMethods.R'
'DiagnosticsMethods.R' 'AIDSFunctions.R' 'Antitrust_Shiny.R'
'AntitrustPackage.R' 'Auction2ndCapFunctions.R'
'Auction2ndLogitFunctions.R' 'BargainingLogitFunctions.R'
'BertrandFunctions.R' 'CESFunctions.R'
'CMCRBertrandFunctions.R' 'CMCRCournotFunctions.R'
'CournotFunctions.R' 'HHIFunctions.R' 'LinearFunctions.R'
'LogitFunctions.R' 'SimFunctions.R' 'VerticalFunctions.R'
'antitrust-deprecated.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-23 20:15:28 UTC; ctara</td>
</tr>
<tr>
<td>Author:</td>
<td>Charles Taragin [aut, cre],
  Michael Sandfort [aut],
  Shlok Goyal [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-24 07:00:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='AIDS-Functions'>(Nested) AIDS Calibration and Merger Simulation</h2><span id='topic+AIDS-Functions'></span><span id='topic+aids'></span><span id='topic+pcaids'></span><span id='topic+pcaids.nests'></span>

<h3>Description</h3>

<p>Calibrates consumer demand using (nested) AIDS and then
simulates the price effect of a merger between two firms
under the assumption that all firms in the market are playing
a differentiated products Bertrand game.
</p>
<p>Below let k denote the number of products produced by all firms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aids(
  shares,
  margins,
  prices,
  diversions,
  ownerPre,
  ownerPost,
  mktElast = NA_real_,
  insideSize = NA_real_,
  mcDelta = rep(0, length(shares)),
  subset = rep(TRUE, length(shares)),
  parmStart = rep(NA_real_, 2),
  priceStart = runif(length(shares)),
  isMax = FALSE,
  control.slopes,
  control.equ,
  labels = paste("Prod", 1:length(shares), sep = ""),
  ...
)

pcaids(
  shares,
  knownElast,
  mktElast = -1,
  prices,
  diversions,
  ownerPre,
  ownerPost,
  knownElastIndex = 1,
  insideSize = NA_real_,
  mcDelta = rep(0, length(shares)),
  subset = rep(TRUE, length(shares)),
  priceStart = runif(length(shares)),
  isMax = FALSE,
  control.slopes,
  control.equ,
  labels = paste("Prod", 1:length(shares), sep = ""),
  ...
)

pcaids.nests(
  shares,
  margins,
  knownElast,
  mktElast = -1,
  prices,
  ownerPre,
  ownerPost,
  nests = rep(1, length(shares)),
  knownElastIndex = 1,
  insideSize = NA_real_,
  mcDelta = rep(0, length(shares)),
  subset = rep(TRUE, length(shares)),
  priceStart = runif(length(shares)),
  isMax = FALSE,
  nestsParmStart,
  control.slopes,
  control.equ,
  labels = paste("Prod", 1:length(shares), sep = ""),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIDS-Functions_+3A_shares">shares</code></td>
<td>
<p>A length k vector of product revenue shares. All shares must
be between 0 and 1.</p>
</td></tr>
<tr><td><code id="AIDS-Functions_+3A_margins">margins</code></td>
<td>
<p>A length k vector of product margins. All margins must
be either be between 0 and 1, or NA.</p>
</td></tr>
<tr><td><code id="AIDS-Functions_+3A_prices">prices</code></td>
<td>
<p>A length k vector product prices. Default is missing, in
which case demand intercepts are not calibrated.</p>
</td></tr>
<tr><td><code id="AIDS-Functions_+3A_diversions">diversions</code></td>
<td>
<p>A k x k matrix of diversion ratios with diagonal
elements equal to -1. Default is missing, in which case diversion
according to revenue share is assumed.</p>
</td></tr>
<tr><td><code id="AIDS-Functions_+3A_ownerpre">ownerPre</code></td>
<td>
<p>EITHER a vector of length k whose values
indicate which firm produced a product before the merger OR a
k x k matrix of pre-merger ownership shares.</p>
</td></tr>
<tr><td><code id="AIDS-Functions_+3A_ownerpost">ownerPost</code></td>
<td>
<p>EITHER a vector of length k whose values
indicate which firm produced a product after the merger OR
a k x k matrix of post-merger ownership shares.</p>
</td></tr>
<tr><td><code id="AIDS-Functions_+3A_mktelast">mktElast</code></td>
<td>
<p>A negative number equal to the industry pre-merger
price elasticity. Default is NA for  <code>aids</code> and -1 for <code>pcaids</code>.</p>
</td></tr>
<tr><td><code id="AIDS-Functions_+3A_insidesize">insideSize</code></td>
<td>
<p>Total expenditure (revenues) on products included in the simulation.</p>
</td></tr>
<tr><td><code id="AIDS-Functions_+3A_mcdelta">mcDelta</code></td>
<td>
<p>A vector of length k where each element equals the
proportional change in a product's marginal costs due to
the merger. Default is 0, which assumes that the merger does not
affect any products' marginal cost.</p>
</td></tr>
<tr><td><code id="AIDS-Functions_+3A_subset">subset</code></td>
<td>
<p>A vector of length k where each element equals TRUE if
the product indexed by that element should be included in the
post-merger simulation and FALSE if it should be excluded.Default is a
length k vector of TRUE.</p>
</td></tr>
<tr><td><code id="AIDS-Functions_+3A_parmstart">parmStart</code></td>
<td>
<p><code>aids</code> only. A vector of length 2 who elements equal to an
initial guess for &quot;known&quot; element of the diagonal of the demand matrix
and the market elasticity.</p>
</td></tr>
<tr><td><code id="AIDS-Functions_+3A_pricestart">priceStart</code></td>
<td>
<p>A vector of length k who elements equal to an
initial guess of the proportional change in price caused by the
merger. The default is to draw k random elements from a [0,1] uniform
distribution.</p>
</td></tr>
<tr><td><code id="AIDS-Functions_+3A_ismax">isMax</code></td>
<td>
<p>If TRUE, checks to see whether computed price equilibrium
locally maximizes firm profits and returns a warning if not. Default is FALSE.</p>
</td></tr>
<tr><td><code id="AIDS-Functions_+3A_control.slopes">control.slopes</code></td>
<td>
<p>A list of  <code><a href="stats.html#topic+optim">optim</a></code>  control parameters passed to
the calibration routine optimizer (typically the <code>calcSlopes</code> method).</p>
</td></tr>
<tr><td><code id="AIDS-Functions_+3A_control.equ">control.equ</code></td>
<td>
<p>A list of  <code><a href="BB.html#topic+BBsolve">BBsolve</a></code> control parameters passed to
the non-linear equation solver (typically the <code>calcPrices</code> method).</p>
</td></tr>
<tr><td><code id="AIDS-Functions_+3A_labels">labels</code></td>
<td>
<p>A k-length vector of labels.</p>
</td></tr>
<tr><td><code id="AIDS-Functions_+3A_...">...</code></td>
<td>
<p>Additional options to feed to the <code><a href="BB.html#topic+BBsolve">BBsolve</a></code>
optimizer used to solve for equilibrium prices.</p>
</td></tr>
<tr><td><code id="AIDS-Functions_+3A_knownelast">knownElast</code></td>
<td>
<p>A negative number equal to the pre-merger own-price
elasticity for any of the k products.</p>
</td></tr>
<tr><td><code id="AIDS-Functions_+3A_knownelastindex">knownElastIndex</code></td>
<td>
<p>An integer equal to the position of the
&lsquo;knownElast&rsquo; product in the &lsquo;shares&rsquo; vector. Default is 1, which
assumes that the own-price elasticity of the first product is
known.</p>
</td></tr>
<tr><td><code id="AIDS-Functions_+3A_nests">nests</code></td>
<td>
<p>A length k vector identifying which nest a product
belongs to. Default is that all products belong to a single nest.</p>
</td></tr>
<tr><td><code id="AIDS-Functions_+3A_nestsparmstart">nestsParmStart</code></td>
<td>
<p>A vector of starting values used to solve for
price coefficient and nest parameters. If missing then the random
draws with the appropriate restrictions are employed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using product market revenue shares and all of the
product product margins from at least two firms, <code>aids</code> is able to
recover the slopes in a proportionally calibrated Almost Ideal Demand System (AIDS)
without income effects. <code>aids</code> then uses these slopes to simulate the
price effects of a merger between
two firms under the assumption that all firms in the market are
playing a differentiated Bertrand pricing game.
</p>
<p>If prices are also supplied, <code>aids</code> is able to recover the
intercepts from the AIDS demand system. Intercepts are helpful because
they can be used to simulate pre- and post-merger price <em>levels</em> as well as price
<em>changes</em>. Whatsmore, the intercepts are necessary in order to
calculate compensating variation.
</p>
<p><code>aids</code> assumes that diversion between the products
in the market occurs according to revenue share. This assumption may be relaxed
by setting &lsquo;diversions&rsquo; equal to a k x k matrix of diversion
ratios. The diagonal of this matrix must equal -1, the off-diagonal
elements must be between 0 and 1, and the rows must sum to 1.
</p>
<p><code>pcaids</code> is almost identical to <code>aids</code>, but instead of
assuming that at least two margins are known, <code>pcaids</code> assumes
that the own-price elasticity of any single
product, and the industry-wide own-price elasticity, are
known. Demand intercepts cannot be recovered using <code>pcaids</code>.
</p>
<p><code>pcaids.nests</code> extends <code>pcaids</code> by allowing products
to be grouped into nests. Although products within the same nest still
have the independence of irrelevant alternatives (IIA) property,
products in different nests do not. Note that the &lsquo;diversions&rsquo;
argument is absent from <code>pcaids.nests</code>.
</p>
<p><code>pcaids.nests</code>  assumes that the share diversion between nests is symmetric
(i.e for 2 nests A and B, the diversion from A to B is the same as B to
A). Therefore, if there are <code class="reqn">w</code> nests, <code class="reqn">2\le w \le k</code>, then the model
must estimate <code class="reqn">w(w-1)/2</code> distinct nesting parameters. To accomplish
this, <code>pcaids.nests</code> uses margin information to produce estimates of
the nesting parameters. It is important to note that the number of
supplied margins must be at least as great as the number of nesting
parameters in order for PCAIDS to work.
</p>
<p>The nesting parameters are constrained to be between 0 and
1. Therefore, one way to test the validity of the nesting structure is
to check whether the nesting parameters are between 0 and 1. The value
of the nesting parameters may be obtained from calling either the &lsquo;summary&rsquo; or
&lsquo;getNestsParms&rsquo; functions.
</p>


<h3>Value</h3>

<p><code>aids</code> returns an instance of class
<code><a href="#topic+AIDS-class">AIDS</a></code>, a child class of <code><a href="#topic+Linear-class">Linear</a></code>.
<code>pcaids</code> returns an instance of class
<code><a href="#topic+PCAIDS-class">PCAIDS</a></code>, while <code>pcaids.nests</code> returns an
instance of <code><a href="#topic+PCAIDSNests-class">PCAIDSNests</a></code>. Both are
children of the <code><a href="#topic+AIDS-class">AIDS</a></code> class.
</p>


<h3>Author(s)</h3>

<p>Charles Taragin <a href="mailto:ctaragin+antitrustr@gmail.com">ctaragin+antitrustr@gmail.com</a>
</p>


<h3>References</h3>

<p>Epstein, Roy and  Rubinfeld, Daniel (2004).
&ldquo;Merger Simulation with Brand-Level Margin Data: Extending PCAIDS
with Nests.&rdquo;
<em>The B.E. Journal of Economic Analysis and Policy</em>, <b>advances.4</b>(1), pp. 2.
</p>
<p>Epstein, Roy and Rubinfeld, Daniel (2004).
&ldquo;Effects of Mergers Involving Differentiated Products.&rdquo;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linear">linear</a></code> for a demand system based on quantities
rather than revenue shares.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate a merger between two single-product firms A and B in a
## three-firm market (A, B, C). This example assumes that the merger is between
## the firms A and B and that A's own-price elasticity is
## known.
## Source: Epstein and Rubinfeld (2004), pg 9, Table 2.


prices    &lt;- c(2.9,3.4,2.2) ## optional for aids, unnecessary for pcaids
shares    &lt;- c(.2,.3,.5)


## The following are used by aids but not pcaids
## only two of the margins are required to calibrate the demand parameters
margins &lt;- c(0.33, 0.36, 0.44)

## The following are used by pcaids, but not aids
knownElast&lt;- -3
mktElast  &lt;- -1


## Define ownership using a vector of firm identities
ownerPre &lt;- c("A","B","C")
ownerPost &lt;- c("A","A","C")

## Alternatively, ownership could be defined using matrices
#ownerPre=diag(1,length(shares))
#ownerPost=ownerPre
#ownerPost[1,2] &lt;- ownerPost[2,1] &lt;- 1


## AIDS: the following assumes both prices and margins are known.
##       Prices are not needed to estimate price changes



result.aids &lt;- aids(shares,margins,prices,ownerPre=ownerPre,ownerPost=ownerPost,labels=ownerPre)



print(result.aids)           # return predicted price change
summary(result.aids)         # summarize merger simulation

elast(result.aids,TRUE)      # returns premerger elasticities
elast(result.aids,FALSE)     # returns postmerger elasticities

diversion(result.aids,TRUE)  # return premerger diversion ratios
diversion(result.aids,FALSE) # return postmerger diversion ratios


cmcr(result.aids)            #calculate compensating marginal cost reduction
upp(result.aids)             #calculate Upwards Pricing Pressure Index


## Implement the Hypothetical Monopolist Test
## for products A and B using a 5\% SSNIP

HypoMonTest(result.aids,prodIndex=1:2)


CV(result.aids)        #calculate compensating variation as a percent of
#total expenditure
#CV can only be calculated if prices are supplied


## Get a detailed description of the 'AIDS' class slots
showClass("AIDS")

## Show all methods attached to the 'AIDS' Class
showMethods(classes="AIDS")

## Show which class have their own 'elast' method
showMethods("elast")

## Show the method definition for 'elast' and Class 'AIDS'
getMethod("elast","AIDS")



## PCAIDS: the following assumes that only one product's elasticity is
##       known as well as the market elasticity.



result.pcaids &lt;- pcaids(shares,knownElast,mktElast,
                        ownerPre=ownerPre,ownerPost=ownerPost,
                        labels=ownerPre)

print(result.pcaids)           # return predicted price change
summary(result.pcaids)         # summarize merger simulation

elast(result.pcaids,TRUE)      # returns premerger elasticities
elast(result.pcaids,FALSE)     # returns postmerger elasticities

diversion(result.pcaids,TRUE)  # return premerger diversion ratios
diversion(result.pcaids,FALSE) # return postmerger diversion ratios


cmcr(result.pcaids)            #calculate compensating marginal cost reduction


## Implement the Hypothetical Monopolist Test
## for products A and B using a 5\% SSNIP

HypoMonTest(result.pcaids,prodIndex=1:2)



## Nested PCAIDS: in addition to the PCAIDS information requirements,
##                users must supply the nesting structure as well as margin infromation.

nests &lt;- c('H','L','L') # product A assigned to nest H, products B and C assigned to nest L


result.pcaids.nests &lt;- pcaids.nests(shares,knownElast,mktElast,margins=margins,
                                    nests=nests,ownerPre=ownerPre,
                                    ownerPost=ownerPost,labels=ownerPre)

</code></pre>

<hr>
<h2 id='antitrust_shiny'>Deprecated functions in package <span class="pkg">antitrust</span>.</h2><span id='topic+antitrust_shiny'></span><span id='topic+antitrust-deprecated'></span>

<h3>Description</h3>

<p>The functions listed below are deprecated and will be defunct in
the near future. When possible, alternative functions with similar
functionality are also mentioned. Help pages for deprecated functions are
available at <code>help("-deprecated")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>antitrust_shiny()
</code></pre>


<h3><code>antitrust_shiny</code></h3>

<p>For <code>antitrust_shiny</code>, use <code><a href="competitiontoolbox.html#topic+ct_shiny">ct_shiny</a></code>.
</p>

<hr>
<h2 id='antitrust_shiny-deprecated'>A Shiny Interface to the Antitrust Package</h2><span id='topic+antitrust_shiny-deprecated'></span>

<h3>Description</h3>

<p>A Shiny Interface to the Antitrust Package
</p>


<h3>Details</h3>

<p><code>antitrust_shiny</code> launches a shiny interface for
the antitrust package. The shiny interface provides users with
the ability to calibrate and simulate horizontal mergers using
many of the supply and demand models included in the antitrust package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+antitrust-deprecated">antitrust-deprecated</a></code>
</p>

<hr>
<h2 id='Antitrust-Class'>&ldquo;Antitrust&rdquo; Classes</h2><span id='topic+Antitrust-Class'></span><span id='topic+Antitrust-class'></span><span id='topic+matrixOrList-class'></span><span id='topic+matrixOrVector-class'></span><span id='topic+characterOrList-class'></span>

<h3>Description</h3>

<p>The &ldquo;Antitrust&rdquo; class is a building block used to create other classes
in this package. As such, it is most likely to be useful for developers
who wish to code their own calibration/simulation routines.
</p>
<p>Let k denote the number of products produced by all firms below.
</p>


<h3>Slots</h3>


<dl>
<dt><code>pricePre</code></dt><dd><p>A length k vector of simulated pre-merger prices.</p>
</dd>
<dt><code>pricePost</code></dt><dd><p>A length k vector of simulated post-merger prices.</p>
</dd>
<dt><code>ownerPre</code></dt><dd><p>A k x k matrix of pre-merger ownership shares.</p>
</dd>
<dt><code>ownerPost</code></dt><dd><p>A k x k matrix of post-merger ownership shares.</p>
</dd>
<dt><code>labels</code></dt><dd><p>A length k vector of labels.</p>
</dd>
<dt><code>control.slopes</code></dt><dd><p>A list of <code><a href="stats.html#topic+optim">optim</a></code> control parameters passed to the calibration routine optimizer (typically the <code>calcSlopes</code> method).</p>
</dd>
<dt><code>control.equ</code></dt><dd><p>A list of <code><a href="BB.html#topic+BBsolve">BBsolve</a></code> control parameters passed to the non-linear equation solver (typically the <code>calcPrices</code> method).</p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("Antitrust", ...)</code>.
</p>


<h3>The &ldquo;matrixOrList&rdquo;, &ldquo;matrixOrVector&rdquo; and &ldquo;characterOrList&rdquo; Classes</h3>

<p>The &ldquo;matrixOrList&rdquo;,&ldquo;matrixOrVector&rdquo; and &ldquo;characterOrList&rdquo; classes are
virtual classes used for validity checking in the &lsquo;ownerPre&rsquo; and
&lsquo;ownerPost&rsquo; slots of &ldquo;Antitrust&rdquo; and the &lsquo;slopes&rsquo; slot in
&ldquo;Bertrand&rdquo;.
</p>


<h3>Author(s)</h3>

<p>Charles Taragin <a href="mailto:ctaragin+antitrustr@gmail.com">ctaragin+antitrustr@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("Antitrust")           # get a detailed description of the class
</code></pre>

<hr>
<h2 id='Auction-Classes'>Class &ldquo;Auction&rdquo;</h2><span id='topic+Auction-Classes'></span><span id='topic+Auction2ndCap-class'></span><span id='topic+Auction2ndLogit-class'></span><span id='topic+Auction2ndLogitNests-class'></span><span id='topic+Auction2ndLogitALM-class'></span>

<h3>Description</h3>

<p>The &ldquo;Auction2ndCap&rdquo; class contains all the information needed to
calibrate a 2nd price auction with capacity constraints
</p>
<p>The &ldquo;Auction2ndLogit&rdquo; class contains all the information needed to
calibrate a Logit
demand system and perform a merger simulation analysis under the assumption that
firms are setting offers in a 2nd-score auction.
</p>
<p>The &ldquo;Auction2ndLogitNests&rdquo; class contains all the information needed to
calibrate a Nested Logit
demand system and perform a merger simulation analysis under the assumption that
firms are setting offers in a 2nd-score auction.
</p>
<p>The &ldquo;Auction2ndLogitALM&rdquo; class contains all the information needed to
calibrate a Logit
demand system with unobserved outside share and perform a merger simulation analysis under the assumption that
firms are setting offers in a 2nd-score auction.
</p>
<p>Below, let k denote the number of firms.
</p>


<h3>Slots</h3>


<dl>
<dt><code>capacities</code></dt><dd><p>A length k vector of firm capacities.</p>
</dd>
<dt><code>margins</code></dt><dd><p>A length k vector of product margins, some of which may
equal NA.</p>
</dd>
<dt><code>prices</code></dt><dd><p>A length k vector of product prices.</p>
</dd>
<dt><code>reserve</code></dt><dd><p>A length 1 vector equal to observed buyer's
reserve price. May equal NA.</p>
</dd>
<dt><code>shareInside</code></dt><dd><p>A length 1 vector equal to the
probability that a buyer does not select the outside option. May equal NA.</p>
</dd>
<dt><code>sellerCostCDF</code></dt><dd><p>A length 1 character vector equal to
the name of the function that calculates the Cumulative
Distribution (CDF) of SellerCosts.</p>
</dd>
<dt><code>sellerCostCDFLowerTail</code></dt><dd><p>A length 1 logical vector equal to
TRUE if the  probabilities are P[X &lt;= x], otherwise, P[X &gt; x].</p>
</dd>
<dt><code>sellerCostPDF</code></dt><dd><p>A function returning the Probability Density
of Seller Costs.</p>
</dd>
<dt><code>sellerCostBounds</code></dt><dd><p>The bounds on the seller's CDF.</p>
</dd>
<dt><code>sellerCostParms</code></dt><dd><p>The parameters of the seller's CDF.</p>
</dd>
<dt><code>buyerValuation</code></dt><dd><p>Buyer's self-supply cost.</p>
</dd>
<dt><code>reservePre</code></dt><dd><p>Buyer's optimal pre-merger reservation price.</p>
</dd>
<dt><code>reservePost</code></dt><dd><p>Buyer's optimal post-merger reservation
price.</p>
</dd>
<dt><code>mcDelta</code></dt><dd><p>A length k vector equal to the proportional
change in a firm's capacity following the merger.</p>
</dd>
<dt><code>parmsStart</code></dt><dd><p>A vector of starting values.</p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>Auction2ndCap: Objects can be created by using the constructor function <code><a href="#topic+auction2nd.cap">auction2nd.cap</a></code>.
</p>
<p>Auction2ndLogit: Objects can be created by using the constructor function <code><a href="#topic+auction2nd.logit">auction2nd.logit</a></code>.
</p>
<p>Auction2ndLogitNests: Objects can be created by using the constructor function <code><a href="#topic+auction2nd.logit.nests">auction2nd.logit.nests</a></code>.
</p>
<p>Auction2ndLogitALM: Objects can be created by using the constructor function <code><a href="#topic+auction2nd.logit.alm">auction2nd.logit.alm</a></code>.
</p>


<h3>Extends</h3>

<p>Auction2ndCap: Class <code><a href="#topic+Antitrust-class">Antitrust</a></code>, directly.
</p>
<p>Auction2ndLogit: Class <code><a href="#topic+Logit-class">Logit</a></code>, directly.
Class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, by class <code><a href="#topic+Logit-class">Logit</a></code>, distance 2.
Class <code><a href="#topic+Antitrust-class">Antitrust</a></code>, by class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, distance 3.
</p>
<p>Auction2ndLogitALM: Class <code><a href="#topic+Auction2ndLogit-class">Auction2ndLogit</a></code>, directly.
Class <code><a href="#topic+Logit-class">Logit</a></code>, distance 2.
Class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, by class <code><a href="#topic+Logit-class">Logit</a></code>, distance 3.
Class <code><a href="#topic+Antitrust-class">Antitrust</a></code>, by class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, distance 4.
</p>


<h3>Author(s)</h3>

<p>Charles Taragin <a href="mailto:ctaragin+antitrustr@gmail.com">ctaragin+antitrustr@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("Auction2ndCap")           # get a detailed description of the class
showClass("Auction2ndLogit")           # get a detailed description of the class
showClass("Auction2ndLogitALM")           # get a detailed description of the class
</code></pre>

<hr>
<h2 id='Auction2ndCap-Functions'>(Capacity Constrained) 2nd Price Auction Model</h2><span id='topic+Auction2ndCap-Functions'></span><span id='topic+Auction2ndCap'></span><span id='topic+auction2nd.cap'></span>

<h3>Description</h3>

<p>Calibrates the parameters of bidder cost distributions and
then simulates the price effect of a merger between two firms
under the assumption that firms are competing in a (Capacity
Constrained) 2nd price auction.
</p>
<p>Let k denote the number of firms bidding in the auction below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auction2nd.cap(
  capacities,
  margins,
  prices,
  reserve = NA,
  shareInside = NA,
  sellerCostCDF = c("punif", "pexp", "pweibull", "pgumbel", "pfrechet"),
  ownerPre,
  ownerPost,
  mcDelta = rep(0, length(capacities)),
  constrain.reserve = TRUE,
  parmsStart,
  control.slopes,
  labels = as.character(ownerPre),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Auction2ndCap-Functions_+3A_capacities">capacities</code></td>
<td>
<p>A length k vector of firm capacities OR capacity shares.</p>
</td></tr>
<tr><td><code id="Auction2ndCap-Functions_+3A_margins">margins</code></td>
<td>
<p>A length k vector of product margins. All margins must
be either be between 0 and 1, or NA.</p>
</td></tr>
<tr><td><code id="Auction2ndCap-Functions_+3A_prices">prices</code></td>
<td>
<p>A length k vector product prices. Prices may be NA.</p>
</td></tr>
<tr><td><code id="Auction2ndCap-Functions_+3A_reserve">reserve</code></td>
<td>
<p>A length 1 vector equal to the buyer's reserve
price. Default is NA.</p>
</td></tr>
<tr><td><code id="Auction2ndCap-Functions_+3A_shareinside">shareInside</code></td>
<td>
<p>A length 1 vector equal to the probability that the
buyer does not select the outside option. Default is NA.</p>
</td></tr>
<tr><td><code id="Auction2ndCap-Functions_+3A_sellercostcdf">sellerCostCDF</code></td>
<td>
<p>A length 1 character vector indicating which
probability distribution will be used  to model bidder cost
draws. Possible options are &quot;punif&quot;, &quot;pexp&quot;, &quot;pweibull&quot;, &quot;pgumbel&quot;,
&quot;pfrechet&quot;. Default is &quot;punif&quot;.</p>
</td></tr>
<tr><td><code id="Auction2ndCap-Functions_+3A_ownerpre">ownerPre</code></td>
<td>
<p>A length k factor whose values
indicate which firms are present in the market pre-merger.</p>
</td></tr>
<tr><td><code id="Auction2ndCap-Functions_+3A_ownerpost">ownerPost</code></td>
<td>
<p>A length k factor whose values
indicate which firms are present in the market post-merger.</p>
</td></tr>
<tr><td><code id="Auction2ndCap-Functions_+3A_mcdelta">mcDelta</code></td>
<td>
<p>A vector of length k where each element equals the
proportional change in a firm's capacity  due to
the merger. Default is 0, which assumes that the merger does not
affect any products' capacity.</p>
</td></tr>
<tr><td><code id="Auction2ndCap-Functions_+3A_constrain.reserve">constrain.reserve</code></td>
<td>
<p>If TRUE, the buyer's post-merger optimal
reserve price is assumed to equal the buyer's pre-merger optimal
reserve price. If FALSE, the buyer re-calculates her optimal reserve
price post-merger.</p>
</td></tr>
<tr><td><code id="Auction2ndCap-Functions_+3A_parmsstart">parmsStart</code></td>
<td>
<p>A vector of starting values for calibrated parameters. See below
for more details.</p>
</td></tr>
<tr><td><code id="Auction2ndCap-Functions_+3A_control.slopes">control.slopes</code></td>
<td>
<p>A list of  <code><a href="stats.html#topic+optim">optim</a></code>  control parameters passed to
the calibration routine optimizer (typically the <code>calcSlopes</code> method).</p>
</td></tr>
<tr><td><code id="Auction2ndCap-Functions_+3A_labels">labels</code></td>
<td>
<p>A k-length vector of labels. Default is &quot;Firm&quot;, where
&lsquo;#&rsquo; is a number between 1 and the length of &lsquo;capacities&rsquo;.</p>
</td></tr>
<tr><td><code id="Auction2ndCap-Functions_+3A_...">...</code></td>
<td>
<p>Additional options to feed to either <code><a href="stats.html#topic+optim">optim</a></code> or <code><a href="stats.html#topic+constrOptim">constrOptim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>auction2nd.cap</code> examines how a merger affects equilbrium bidding
behavior when a single buyer is running a 2nd price procurement
auction with bidders whose marginal cost of supplying a homogenous product is
private information. This version of the model assumes that
bidders are differentiated by their capacities in the sense that firms
with greater capacity are more likely to have lower costs than firms
with smaller capacities.
</p>
<p>Using firm prices, shares, and margins, as well as information
on the auction reserve price as well as the proportion of buyers who
choose not to purchase from any bidder,  <code>auction2nd.cap</code>
calibrates the parameters of the common distribution from which
bidder's costs are drawn (and, if
not supplied, the implied reserve price) and then uses these calibrated
parameters to calibrate the value to the buyer of selecting the
outside option. Once these parameters have been calibrated,
<code>auction2nd.cap</code> computes the buyer's optimal pre-merger reservation
price, and if &lsquo;constrain.reserve&rsquo; is FALSE, computes the buyer's
optimal post-merger reservation price (setting &lsquo;constrain.reserve&rsquo; to
TRUE sets the buyer's post-merger optimal reserve equal to the buyer's
pre-merger optimal reserve). The pre- and post-merger expected price, conditional on a particular bidder winning, are then calculated.
</p>
<p>Currently, the common distribution from which costs may be drawn is
restricted to be either: Uniform (&quot;punif&quot;), Exponential (&quot;pexp&quot;), Weibull
(&quot;pweibull&quot;), Gumbel (&quot;pgumbel&quot;), or Frechet (&quot;pfrechet&quot;). Note that
the Exponential is a single parameter distribution, the Uniform and
Weibull are two parameter distributions, and the Gumbel and Frechet
are 3 parameter distributions. Accordingly, sufficient price, margin,
reserve, and outside share information must be supplied in order to
calibrate the parameters of the specified
distribution. <code>auction2nd.cap</code> returns an error if insufficient
information is supplied.
</p>


<h3>Value</h3>

<p><code>auction2nd.cap</code> returns an instance of class
<code><a href="#topic+Auction2ndCap-class">Auction2ndCap</a></code>.
</p>


<h3>Author(s)</h3>

<p>Charles Taragin <a href="mailto:ctaragin+antitrustr@gmail.com">ctaragin+antitrustr@gmail.com</a>, with code
contributed by Michael Sandfort and Nathan Miller
</p>


<h3>References</h3>

<p>Keith Waehrer and  Perry, Martin (2003).
&ldquo;The Effects of Mergers in Open Auction Markets&rdquo;,
<em>Rand Journal of Economics</em>, <b>34(2)</b>, pp. 287-304.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Suppose there are 3 firms (A,B,C) participating in a procurement auction with
## an unknown reservation price and that firm A acquires firm B.

caps &lt;- c(0.65,0.30,0.05)           # total capacity normalized to 1 in this example
inShare    &lt;- .67                   # probability that buyer does not select
# any bidder
prices     &lt;- c(3.89, 3.79, 3.74)   # average price charged by each firm
margins    &lt;- c(.228, .209, 0.197)  # average margin earned by each firm
ownerPre   &lt;- ownerPost   &lt;-c("A","B","C")
ownerPost[ownerPost=="B"] &lt;- "A"

##assume costs are uniformly distributed with unknown bounds
result.unif = auction2nd.cap(
  capacities=caps,
  margins=margins,prices=prices,reserve=NA,
  shareInside=inShare,
  sellerCostCDF="punif",
  ownerPre=ownerPre,ownerPost=ownerPost,
  labels=ownerPre
)

print(result.unif)
summary(result.unif)

## Get a detailed description of the 'Auction2ndCap' class slots
showClass("Auction2ndCap")

## Show all methods attached to the 'Auction2ndCap' Class
showMethods(classes="Auction2ndCap")

</code></pre>

<hr>
<h2 id='Auction2ndLogit-Functions'>2nd Score Procurement Auction Model with (Nested) Logit Demand</h2><span id='topic+Auction2ndLogit-Functions'></span><span id='topic+auction2nd.logit'></span><span id='topic+auction2nd.logit.nests'></span><span id='topic+auction2nd.logit.alm'></span>

<h3>Description</h3>

<p>Calibrates consumer demand using (Nested) Logit and then
simulates the price effect of a merger between two firms
under the assumption that all firms in the market are playing a
differentiated products 2nd score auction game.
</p>
<p>Let k denote the number of products produced by all firms playing the
auction game below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auction2nd.logit(
  prices,
  shares,
  margins,
  ownerPre,
  ownerPost,
  normIndex = ifelse(isTRUE(all.equal(sum(shares), 1, check.names = FALSE)), 1, NA),
  mcDelta = rep(0, length(prices)),
  subset = rep(TRUE, length(prices)),
  insideSize = NA_real_,
  mcDeltaOutside = 0,
  control.slopes,
  labels = paste("Prod", 1:length(prices), sep = "")
)

auction2nd.logit.nests(
  prices,
  shares,
  margins,
  nests,
  diversions,
  ownerPre,
  ownerPost,
  normIndex = ifelse(isTRUE(all.equal(sum(shares), 1, check.names = FALSE)), 1, NA),
  mcDelta = rep(0, length(prices)),
  subset = rep(TRUE, length(prices)),
  insideSize = NA_real_,
  mcDeltaOutside = 0,
  parmsStart,
  constraint = TRUE,
  control.slopes,
  labels = paste("Prod", 1:length(prices), sep = "")
)

auction2nd.logit.alm(
  prices,
  shares,
  margins,
  ownerPre,
  ownerPost,
  mktElast = NA_real_,
  insideSize = NA_real_,
  mcDelta = rep(0, length(prices)),
  subset = rep(TRUE, length(prices)),
  mcDeltaOutside = 0,
  parmsStart,
  control.slopes,
  labels = paste("Prod", 1:length(prices), sep = "")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Auction2ndLogit-Functions_+3A_prices">prices</code></td>
<td>
<p>A length k vector of product prices.</p>
</td></tr>
<tr><td><code id="Auction2ndLogit-Functions_+3A_shares">shares</code></td>
<td>
<p>A length k vector of product (quantity) shares. Values must be
between 0 and 1.</p>
</td></tr>
<tr><td><code id="Auction2ndLogit-Functions_+3A_margins">margins</code></td>
<td>
<p>A length k vector of product margins (in levels, not percents), some of which may
equal NA.</p>
</td></tr>
<tr><td><code id="Auction2ndLogit-Functions_+3A_ownerpre">ownerPre</code></td>
<td>
<p>EITHER a vector of length k whose values
indicate which firm produced a product pre-merger OR
a k x k matrix of pre-merger ownership shares.</p>
</td></tr>
<tr><td><code id="Auction2ndLogit-Functions_+3A_ownerpost">ownerPost</code></td>
<td>
<p>EITHER a vector of length k whose values
indicate which firm produced a product after the merger OR
a k x k matrix of post-merger ownership shares.</p>
</td></tr>
<tr><td><code id="Auction2ndLogit-Functions_+3A_normindex">normIndex</code></td>
<td>
<p>An integer equalling the index (position) of the
inside product whose mean valuation will be normalized to 1. Default
is 1, unless &lsquo;shares&rsquo; sum to less than 1, in which case the default is
NA and an outside good is assumed to exist.</p>
</td></tr>
<tr><td><code id="Auction2ndLogit-Functions_+3A_mcdelta">mcDelta</code></td>
<td>
<p>A vector of length k where each element equals the
(level) change in a product's marginal costs due to
the merger. Default is 0, which assumes that the merger does not
affect any products' marginal cost.</p>
</td></tr>
<tr><td><code id="Auction2ndLogit-Functions_+3A_subset">subset</code></td>
<td>
<p>A vector of length k where each element equals TRUE if
the product indexed by that element should be included in the
post-merger simulation and FALSE if it should be excluded.Default is a
length k vector of TRUE.</p>
</td></tr>
<tr><td><code id="Auction2ndLogit-Functions_+3A_insidesize">insideSize</code></td>
<td>
<p>An integer equal to total pre-merger units sold.
If shares sum to one, this also equals the size of the market.</p>
</td></tr>
<tr><td><code id="Auction2ndLogit-Functions_+3A_mcdeltaoutside">mcDeltaOutside</code></td>
<td>
<p>A length 1 vector indicating the change in the marginal cost of the
outside good. Default is 0.</p>
</td></tr>
<tr><td><code id="Auction2ndLogit-Functions_+3A_control.slopes">control.slopes</code></td>
<td>
<p>A list of  <code><a href="stats.html#topic+optim">optim</a></code>  control parameters passed
to the calibration routine optimizer (typically the <code>calcSlopes</code> method).</p>
</td></tr>
<tr><td><code id="Auction2ndLogit-Functions_+3A_labels">labels</code></td>
<td>
<p>A k-length vector of labels. Default is &quot;Prod#&quot;, where
&lsquo;#&rsquo; is a number between 1 and the length of &lsquo;prices&rsquo;.</p>
</td></tr>
<tr><td><code id="Auction2ndLogit-Functions_+3A_nests">nests</code></td>
<td>
<p>A length k factor of product nests.</p>
</td></tr>
<tr><td><code id="Auction2ndLogit-Functions_+3A_diversions">diversions</code></td>
<td>
<p>A k x k matrix of diversion ratios with diagonal
elements equal to -1. Default is missing, in which case diversion
according to share is assumed.</p>
</td></tr>
<tr><td><code id="Auction2ndLogit-Functions_+3A_parmsstart">parmsStart</code></td>
<td>
<p>For <code>auction2nd.logit.alm</code>, a length 2 vector of starting values used to solve for
price coefficient and the share of the outside good. The first element should
always be the price coefficient and the second should be
the outside good. For <code>auction2nd.logit.nests</code>, a length n+1 vector of starting values used to solve for
price coefficient and the nesting parameters. The first element should
always be the price coefficient and the remaining elements should be
the nesting parameters.</p>
</td></tr>
<tr><td><code id="Auction2ndLogit-Functions_+3A_constraint">constraint</code></td>
<td>
<p>if TRUE, then the nesting parameters for all
non-singleton nests are assumed equal. If FALSE, then each
non-singleton nest is permitted to have its own value. Default is
TRUE.</p>
</td></tr>
<tr><td><code id="Auction2ndLogit-Functions_+3A_mktelast">mktElast</code></td>
<td>
<p>a negative value indicating market elasticity. Default is NA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using product prices, quantity shares and all of the
product margins from at least one firm, <code>auction2nd.logit</code> is able to
recover the price coefficient and product mean valuations in a
Logit demand model. <code>auction2nd.logit</code> then uses these
calibrated parameters to simulate a merger between two firms, under the assumption that firms are participating in a 2nd score procurement auction.
</p>
<p><code>auction2nd.logit.nests</code> is identical to <code>auction2nd.logit</code> except that it assumes
that products can be grouped into nests. Additional margin information is needed to 
identify th nesting parameters. 
</p>
<p><code>auction2nd.logit.alm</code> is identical to <code>auction2nd.logit</code> except that it assumes
that an outside product exists and uses additional margin
information to estimate the share of the outside good.
</p>


<h3>Value</h3>

<p><code>auction2nd.logit</code> returns an instance of <code><a href="#topic+Auction2ndLogit-class">Auction2ndLogit</a></code>,
a child class of <code><a href="#topic+Logit-class">Logit</a></code>. <code>auction2nd.logit.nests</code> returns an instance of <code><a href="#topic+Auction2ndLogitNests-class">Auction2ndLogitNests</a></code>.
<code>auction2nd.logit</code> returns an instance of <code><a href="#topic+Auction2ndLogitALM-class">Auction2ndLogitALM</a></code>.
</p>


<h3>Author(s)</h3>

<p>Charles Taragin <a href="mailto:ctaragin+antitrustr@gmail.com">ctaragin+antitrustr@gmail.com</a>
</p>


<h3>References</h3>

<p>Miller, Nathan (2014). &ldquo;Modeling the effects of mergers in procurement&rdquo;
<em>International Journal of Industrial Organization</em> , <b>37</b>, pp. 201-208.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logit">logit</a></code>,<code><a href="#topic+logit.nests">logit.nests</a></code> for simulating mergers under a Nash-Bertrand pricing game with Logit demand
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Calibration and simulation results from a merger between firms 2 and 3
## of a 4-firm market
## Source: Miller 2014 backup materials http://www.nathanhmiller.org/research

share = c(0.29,0.40,0.28,0.03)

price = c(35.53,  154, 84.08, 53.16)*1e3
cost  =  c(NA, 101, NA, NA)*1e3

ownerPre &lt;- ownerPost &lt;- diag(length(share))

#Suppose products 2 and 3 merge
ownerPost[2,3] &lt;- ownerPost[3,2] &lt;- 1

margin = price - cost

result.2nd &lt;- auction2nd.logit(price,share,margin,
                           ownerPre=ownerPre,ownerPost=ownerPost,normIndex=2)


print(result.2nd)
summary(result.2nd,revenue=FALSE)

##re-run without any price information except Firm 2

price &lt;- rep(NA_real_, length(price))

result.noprice &lt;- auction2nd.logit(price,share,margin,
                                   ownerPre=ownerPre,ownerPost=ownerPost,normIndex=2)

print(result.noprice)
summary(result.noprice,revenue=FALSE)

##changing the units of prices and margins can yield dramatically different results 

price = c(35.53,  154, 84.08, 53.16)
cost  =  c(NA, 101, NA, NA)
margin &lt;- price - cost

result.units &lt;- auction2nd.logit(price,share,margin,
                                   ownerPre=ownerPre,ownerPost=ownerPost,normIndex=2)

print(result.units)
summary(result.units,revenue=FALSE)

## Get a detailed description of the 'Auction2ndLogit' class slots
showClass("Auction2ndLogit")

## Show all methods attached to the 'Auction2ndLogit' Class
showMethods(classes="Auction2ndLogit")

</code></pre>

<hr>
<h2 id='AuctionCap-Methods'>Auction Cap Methods</h2><span id='topic+AuctionCap-Methods'></span><span id='topic+calcBuyerExpectedCost'></span><span id='topic+calcBuyerValuation'></span><span id='topic+calcExpectedLowestCost'></span><span id='topic+calcExpectedPrice'></span><span id='topic+calcOptimalReserve'></span><span id='topic+calcSellerCostParms'></span><span id='topic+cdfG'></span><span id='topic+calcBuyerExpectedCost+2CAuction2ndCap-method'></span><span id='topic+calcBuyerValuation+2CAuction2ndCap-method'></span><span id='topic+calcExpectedLowestCost+2CAuction2ndCap-method'></span><span id='topic+calcExpectedPrice+2CAuction2ndCap-method'></span><span id='topic+calcOptimalReserve+2CAuction2ndCap-method'></span><span id='topic+calcSellerCostParms+2CAuction2ndCap-method'></span><span id='topic+cdfG+2CAuction2ndCap-method'></span>

<h3>Description</h3>

<p><code>calcBuyerExpectedCost</code> computes the expected amount that the buyer will pay
to the auction winner.
</p>
<p><code>calcBuyerValuation</code> computes the value to the buyer of the outside option.
</p>
<p><code>calcExpectedLowestCost</code> computes the expected lowest cost of the winning bid.
</p>
<p><code>calcExpectedPrice</code> computes the expected price paid by the buyer.
</p>
<p><code>calcOptimalReserve</code> computes the bidder's optimal reserve price.
</p>
<p><code>calcSellerCostParms</code> calibrates the parameters of the Seller Cost
CDF, as well as the reserve price, if not supplied.
</p>
<p><code>cdfG</code> calculates the probability that a cost draw less than or equal to
&lsquo;c&rsquo; is realized for each firm. If &lsquo;c&rsquo; is not supplied,
the buyer reserve and total capacity is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Auction2ndCap'
calcSellerCostParms(object, ...)

## S4 method for signature 'Auction2ndCap'
calcBuyerValuation(object)

## S4 method for signature 'Auction2ndCap'
calcOptimalReserve(object, preMerger = TRUE, lower, upper)

## S4 method for signature 'Auction2ndCap'
calcBuyerExpectedCost(object, preMerger = TRUE)

## S4 method for signature 'Auction2ndCap'
cdfG(object, c, preMerger = TRUE)

## S4 method for signature 'Auction2ndCap'
calcExpectedPrice(object, preMerger = TRUE)

## S4 method for signature 'Auction2ndCap'
calcExpectedLowestCost(object, preMerger = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AuctionCap-Methods_+3A_object">object</code></td>
<td>
<p>An instance of the respective class (see description for the classes)</p>
</td></tr>
<tr><td><code id="AuctionCap-Methods_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>calcSellerCostParms</code></p>
</td></tr>
<tr><td><code id="AuctionCap-Methods_+3A_premerger">preMerger</code></td>
<td>
<p>If TRUE, the pre-merger ownership structure is used. If FALSE, the post-merger ownership structure is used.
Default is TRUE.</p>
</td></tr>
<tr><td><code id="AuctionCap-Methods_+3A_lower">lower</code></td>
<td>
<p>The minimum for the bidder's reserve price.</p>
</td></tr>
<tr><td><code id="AuctionCap-Methods_+3A_upper">upper</code></td>
<td>
<p>The maximum for the bidder's reserve price.</p>
</td></tr>
<tr><td><code id="AuctionCap-Methods_+3A_c">c</code></td>
<td>
<p><code>cdfG</code> calculates the probability that a cost draw less than or equal to
&lsquo;c&rsquo; is realized for each firm. If &lsquo;c&rsquo; is not supplied,
the buyer reserve and total capacity is used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Charles Taragin <a href="mailto:ctaragin+antitrustr@gmail.com">ctaragin+antitrustr@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showMethods(classes="Auction2ndCap") # show all methods defined for the class

</code></pre>

<hr>
<h2 id='Bargaining-Classes'>&ldquo;Bargaining&rdquo; Classes</h2><span id='topic+Bargaining-Classes'></span><span id='topic+Bargaining-class'></span><span id='topic+BargainingLogit-class'></span><span id='topic+Bargaining2ndLogit-class'></span>

<h3>Description</h3>

<p>Each class contains all the information needed to calibrate a specific type of demand system and
perform a merger simulation analysis under the assumption that firms are playing a differentiated products Nash Bargaining  game.
</p>
<p>The &ldquo;Bargaining&rdquo; class is a building block used to create other classes
in this package. As such, it is most likely to be useful for developers
who wish to code their own calibration/simulation routines.
</p>
<p>The &ldquo;BargainingLogit&rdquo; class has the information for a Nash Bargaining game with Logit demand.
</p>
<p>Let k denote the number of products produced by all firms below.
</p>


<h3>Slots</h3>


<dl>
<dt><code>bargpowerPre</code></dt><dd><p>A length k vector of pre-merger bargaining power parameters.</p>
</dd>
<dt><code>bargpowerPre</code></dt><dd><p>A length k vector of post-merger bargaining power parameters.</p>
</dd>
<dt><code>prices</code></dt><dd><p>A length k vector of of observes prices.</p>
</dd>
<dt><code>margins</code></dt><dd><p>A length k vector of of observes margins.</p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("Bargaining", ...)</code>.
</p>

<hr>
<h2 id='BargainingLogit-Functions'>Nash Bargaining Model with Logit Demand</h2><span id='topic+BargainingLogit-Functions'></span><span id='topic+bargaining.logit'></span><span id='topic+bargaining2nd.logit'></span>

<h3>Description</h3>

<p>Calibrates consumer demand using  Logit and then
simulates the price effect of a merger between two firms
under the assumption that firms and customers in the market are playing a
differentiated products Nash Bargaining game.
</p>
<p>Let k denote the number of products produced by all firms playing the
Nash Bargaining game below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bargaining.logit(
  prices,
  shares,
  margins,
  ownerPre,
  ownerPost,
  bargpowerPre = rep(0.5, length(prices)),
  bargpowerPost = bargpowerPre,
  normIndex = ifelse(isTRUE(all.equal(sum(shares), 1, check.names = FALSE)), 1, NA),
  mcDelta = rep(0, length(prices)),
  subset = rep(TRUE, length(prices)),
  priceStart = prices,
  insideSize = NA_real_,
  priceOutside = 0,
  control.slopes,
  control.equ,
  labels = paste("Prod", 1:length(prices), sep = "")
)

bargaining2nd.logit(
  prices,
  shares,
  margins,
  ownerPre,
  ownerPost,
  bargpowerPre = rep(0.5, length(prices)),
  bargpowerPost = bargpowerPre,
  normIndex = ifelse(isTRUE(all.equal(sum(shares), 1, check.names = FALSE)), 1, NA),
  mcDelta = rep(0, length(prices)),
  subset = rep(TRUE, length(prices)),
  insideSize = NA_real_,
  mcDeltaOutside = 0,
  control.slopes,
  labels = paste("Prod", 1:length(prices), sep = "")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BargainingLogit-Functions_+3A_prices">prices</code></td>
<td>
<p>A length k vector of product prices.</p>
</td></tr>
<tr><td><code id="BargainingLogit-Functions_+3A_shares">shares</code></td>
<td>
<p>A length k vector of product (quantity) shares. Values must be
between 0 and 1.</p>
</td></tr>
<tr><td><code id="BargainingLogit-Functions_+3A_margins">margins</code></td>
<td>
<p>A length k vector of product margins (in levels, not percents), some of which may
equal NA.</p>
</td></tr>
<tr><td><code id="BargainingLogit-Functions_+3A_ownerpre">ownerPre</code></td>
<td>
<p>EITHER a vector of length k whose values
indicate which firm produced a product pre-merger OR
a k x k matrix of pre-merger ownership shares.</p>
</td></tr>
<tr><td><code id="BargainingLogit-Functions_+3A_ownerpost">ownerPost</code></td>
<td>
<p>EITHER a vector of length k whose values
indicate which firm produced a product after the merger OR
a k x k matrix of post-merger ownership shares.</p>
</td></tr>
<tr><td><code id="BargainingLogit-Functions_+3A_bargpowerpre">bargpowerPre</code></td>
<td>
<p>A length k vector of pre-merger bargaining power parameters. Values
must be between 0 (sellers have the power) and 1 (buyers the power). NA values are allowed,
though must be calibrated from additional margin and share data. Default is 0.5.</p>
</td></tr>
<tr><td><code id="BargainingLogit-Functions_+3A_bargpowerpost">bargpowerPost</code></td>
<td>
<p>A length k vector of post-merger bargaining power parameters. Values
must be between 0 (sellers have the power) and 1 (buyers the power). NA values are allowed,
though must be calibrated from additional margin and share data. Default is &lsquo;bargpowerPre&rsquo;.</p>
</td></tr>
<tr><td><code id="BargainingLogit-Functions_+3A_normindex">normIndex</code></td>
<td>
<p>An integer equalling the index (position) of the
inside product whose mean valuation will be normalized to 1. Default
is 1, unless &lsquo;shares&rsquo; sum to less than 1, in which case the default is
NA and an outside good is assumed to exist.</p>
</td></tr>
<tr><td><code id="BargainingLogit-Functions_+3A_mcdelta">mcDelta</code></td>
<td>
<p>A vector of length k where each element equals the
(level) change in a product's marginal costs due to
the merger. Default is 0, which assumes that the merger does not
affect any products' marginal cost.</p>
</td></tr>
<tr><td><code id="BargainingLogit-Functions_+3A_subset">subset</code></td>
<td>
<p>A vector of length k where each element equals TRUE if
the product indexed by that element should be included in the
post-merger simulation and FALSE if it should be excluded.Default is a
length k vector of TRUE.</p>
</td></tr>
<tr><td><code id="BargainingLogit-Functions_+3A_pricestart">priceStart</code></td>
<td>
<p>A vector of length k who elements equal to an
initial guess of equilibrium prices. default is &lsquo;prices&rsquo;.</p>
</td></tr>
<tr><td><code id="BargainingLogit-Functions_+3A_insidesize">insideSize</code></td>
<td>
<p>An integer equal to total pre-merger units sold.
If shares sum to one, this also equals the size of the market.</p>
</td></tr>
<tr><td><code id="BargainingLogit-Functions_+3A_priceoutside">priceOutside</code></td>
<td>
<p>A positive real number equal to the price of the outside good.
Default equals 0 for Logit demand.</p>
</td></tr>
<tr><td><code id="BargainingLogit-Functions_+3A_control.slopes">control.slopes</code></td>
<td>
<p>A list of  <code><a href="stats.html#topic+optim">optim</a></code>  control parameters passed
to the calibration routine optimizer (typically the <code>calcSlopes</code> method).</p>
</td></tr>
<tr><td><code id="BargainingLogit-Functions_+3A_control.equ">control.equ</code></td>
<td>
<p>A list of  <code><a href="BB.html#topic+BBsolve">BBsolve</a></code> control parameters passed
to the non-linear equation solver (typically the <code>calcPrices</code> method).</p>
</td></tr>
<tr><td><code id="BargainingLogit-Functions_+3A_labels">labels</code></td>
<td>
<p>A k-length vector of labels. Default is &quot;Prod#&quot;, where
&lsquo;#&rsquo; is a number between 1 and the length of &lsquo;prices&rsquo;.</p>
</td></tr>
<tr><td><code id="BargainingLogit-Functions_+3A_mcdeltaoutside">mcDeltaOutside</code></td>
<td>
<p>A length 1 vector indicating the change in the marginal cost of the
outside good. Default is 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using product prices, quantity shares and all of the
product margins from at least one firm, <code>auction2nd.logit</code> is able to
recover the price coefficient and product mean valuations in a
Logit demand model. <code>auction2nd.logit</code> then uses these
calibrated parameters to simulate a merger between two firms, under the assumption that firms are participating in a A Nash Bargaining Game 
(bargaining.logit) or splitting the full surplus (bargaining2nd.logit).
</p>


<h3>Value</h3>

<p><code>bargaining.logit</code> returns an instance of <code><a href="#topic+BargainingLogit-class">BargainingLogit</a></code>,
a child class of <code><a href="#topic+Logit-class">Logit</a></code>. 
<code>bargaining2nd.logit</code> returns an instance of <code><a href="#topic+Bargaining2ndLogit-class">Bargaining2ndLogit</a></code>,
a child class of <code><a href="#topic+Auction2ndLogit-class">Auction2ndLogit</a></code>.
</p>


<h3>Author(s)</h3>

<p>Charles Taragin <a href="mailto:ctaragin+antitrustr@gmail.com">ctaragin+antitrustr@gmail.com</a>
</p>


<h3>References</h3>

<p>Miller, Nathan (2014). &ldquo;Modeling the effects of mergers in procurement&rdquo;
<em>International Journal of Industrial Organization</em> , <b>37</b>, pp. 201-208.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logit">logit</a></code> for simulating mergers under a Nash-Bertrand pricing game with Logit demand, and ,<code><a href="#topic+auction2nd.logit">auction2nd.logit</a></code>
for simulating mergers under a 2nd score auction with Logit demand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Calibration and simulation results from a merger between firms 2 and 3
## of a 4-firm market
## Source: Miller 2014 backup materials http://www.nathanhmiller.org/research

share = c(0.29,0.40,0.28,0.03)
bargpower &lt;- rep(0.6,4) # buyer has advantage
price = c(35.53,  154, 84.08, 53.16)
cost  =  c(NA, 101, NA, NA)

ownerPre &lt;- ownerPost &lt;- diag(length(share))

#Suppose products 2 and 3 merge
ownerPost[2,3] &lt;- ownerPost[3,2] &lt;- 1

margin = (price - cost)/price

result.barg &lt;- bargaining.logit(price,share,margin,bargpowerPre=bargpower,
                           ownerPre=ownerPre,ownerPost=ownerPost,normIndex=2)


print(result.barg)
summary(result.barg,revenue=FALSE)


## Get a detailed description of the 'BargainingLogit' class slots
showClass("BargainingLogit")

## Show all methods attached to the 'BargainingLogit' Class
showMethods(classes="BargainingLogit")

</code></pre>

<hr>
<h2 id='Bertrand-Functions'>Bertrand Calibration and Merger Simulation With Logit, CES and AIDS Demand</h2><span id='topic+Bertrand-Functions'></span><span id='topic+Bertrand'></span><span id='topic+bertrand'></span><span id='topic+bertrand.alm'></span>

<h3>Description</h3>

<p>Calibrates consumer demand using either a
Logit, CES, or AIDS demand system and then simulates the
prices effect of a merger between two firms
under the assumption that all firms in the market
are playing a Nash-Bertrand price setting game.
</p>
<p>Let k denote the number of products produced by all firms below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bertrand.alm(
  demand = c("logit", "ces", "aids"),
  prices,
  quantities,
  margins,
  ownerPre,
  ownerPost,
  mktElast = NA_real_,
  insideSize = ifelse(demand == "logit", sum(quantities, na.rm = TRUE), sum(prices *
    quantities, na.rm = TRUE)),
  diversions,
  mcDelta = rep(0, length(prices)),
  subset = rep(TRUE, length(prices)),
  priceOutside = ifelse(demand == "logit", 0, 1),
  priceStart = prices,
  isMax = FALSE,
  parmStart,
  control.slopes,
  control.equ,
  labels = paste("Prod", 1:length(prices), sep = ""),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bertrand-Functions_+3A_demand">demand</code></td>
<td>
<p>A character vector indicating which demand system to use.
Currently allows logit (default), ces, or aids.</p>
</td></tr>
<tr><td><code id="Bertrand-Functions_+3A_prices">prices</code></td>
<td>
<p>A length k vector product prices. Default is missing, in
which case demand intercepts are not calibrated.</p>
</td></tr>
<tr><td><code id="Bertrand-Functions_+3A_quantities">quantities</code></td>
<td>
<p>A length k vector of product quantities.</p>
</td></tr>
<tr><td><code id="Bertrand-Functions_+3A_margins">margins</code></td>
<td>
<p>A length k vector of product margins. All margins must
be either be between 0 and 1, or NA.</p>
</td></tr>
<tr><td><code id="Bertrand-Functions_+3A_ownerpre">ownerPre</code></td>
<td>
<p>EITHER a vector of length k whose values
indicate which firm produced a product before the merger OR a
k x k matrix of pre-merger ownership shares.</p>
</td></tr>
<tr><td><code id="Bertrand-Functions_+3A_ownerpost">ownerPost</code></td>
<td>
<p>EITHER a vector of length k whose values
indicate which firm produced a product after the merger OR
a k x k matrix of post-merger ownership shares.</p>
</td></tr>
<tr><td><code id="Bertrand-Functions_+3A_mktelast">mktElast</code></td>
<td>
<p>A negative number equal to the industry pre-merger
price elasticity. Default is NA.</p>
</td></tr>
<tr><td><code id="Bertrand-Functions_+3A_insidesize">insideSize</code></td>
<td>
<p>Size of all units included in the market. For logit,
this defaults to total quantity, while for aids and ces
this defaults to total revenues.</p>
</td></tr>
<tr><td><code id="Bertrand-Functions_+3A_diversions">diversions</code></td>
<td>
<p>A k x k matrix of diversion ratios with diagonal
elements equal to -1. Default is missing, in which case diversion
according to revenue share is assumed.</p>
</td></tr>
<tr><td><code id="Bertrand-Functions_+3A_mcdelta">mcDelta</code></td>
<td>
<p>A vector of length k where each element equals the
proportional change in a product's marginal costs due to
the merger. Default is 0, which assumes that the merger does not
affect any products' marginal cost.</p>
</td></tr>
<tr><td><code id="Bertrand-Functions_+3A_subset">subset</code></td>
<td>
<p>A vector of length k where each element equals TRUE if
the product indexed by that element should be included in the
post-merger simulation and FALSE if it should be excluded. Default is a
length k vector of TRUE.</p>
</td></tr>
<tr><td><code id="Bertrand-Functions_+3A_priceoutside">priceOutside</code></td>
<td>
<p>A postive real number equal to the price of the outside good.
Default either equals 1 for Logit demand or 0 for CES demand.</p>
</td></tr>
<tr><td><code id="Bertrand-Functions_+3A_pricestart">priceStart</code></td>
<td>
<p>A vector of length k who elements equal to an
initial guess of the proportional change in price caused by the
merger.  For aids, the default is to draw k random elements from
a [0,1] uniform distribution. For ces and logit, the default is prices.</p>
</td></tr>
<tr><td><code id="Bertrand-Functions_+3A_ismax">isMax</code></td>
<td>
<p>If TRUE, checks to see whether computed price equilibrium
locally maximizes firm profits and returns a warning if not. Default is FALSE.</p>
</td></tr>
<tr><td><code id="Bertrand-Functions_+3A_parmstart">parmStart</code></td>
<td>
<p><code>aids</code> only. A vector of length 2 who elements equal to an
initial guess for &quot;known&quot; element of the diagonal of the demand matrix and the market elasticity.</p>
</td></tr>
<tr><td><code id="Bertrand-Functions_+3A_control.slopes">control.slopes</code></td>
<td>
<p>A list of  <code><a href="stats.html#topic+optim">optim</a></code>  control parameters passed
to the calibration routine optimizer (typically the <code>calcSlopes</code> method).</p>
</td></tr>
<tr><td><code id="Bertrand-Functions_+3A_control.equ">control.equ</code></td>
<td>
<p>A list of  <code><a href="BB.html#topic+BBsolve">BBsolve</a></code> control parameters passed
to the non-linear equation solver (typically the <code>calcPrices</code> method).</p>
</td></tr>
<tr><td><code id="Bertrand-Functions_+3A_labels">labels</code></td>
<td>
<p>A k-length vector of labels.</p>
</td></tr>
<tr><td><code id="Bertrand-Functions_+3A_...">...</code></td>
<td>
<p>Additional options to feed to the <code><a href="BB.html#topic+BBsolve">BBsolve</a></code>
optimizer used to solve for equilibrium prices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main purpose of this function is to provide a more convenient front-end
for the <code>aids</code>, <code>logit.alm</code> and <code>ces</code> functions.
</p>
<p>Using price, and quantity, information for all products
in each market, as well as margin information for at least
one products in each market, <code>bertrand.alm</code> is able to
recover the slopes and intercepts of either a Logit, CES, or AIDS demand
system. These parameters are then used to simulate the price
effects of a merger between
two firms under the assumption that the firms are playing a
simultaneous price setting game.
</p>
<p>&lsquo;ownerPre&rsquo; and &lsquo;ownerPost&rsquo; values will typically be equal to either 0
(element [i,j] is not commonly owned) or 1 (element [i,j] is commonly
owned), though these matrices may take on any value between 0 and 1 to
account for partial ownership.
</p>


<h3>Value</h3>

<p><code>bertrand.alm</code> returns an instance of class <code><a href="#topic+LogitALM-class">LogitALM</a></code>,
<code><a href="#topic+CESALM-class">CESALM</a></code>, or <code><a href="#topic+AIDS-class">AIDS</a></code>,
depending upon the value of the &ldquo;demand&rdquo; argument.
</p>


<h3>Author(s)</h3>

<p>Charles Taragin <a href="mailto:ctaragin+antitrustr@gmail.com">ctaragin+antitrustr@gmail.com</a>
</p>

<hr>
<h2 id='BertrandOther-Classes'>&ldquo;Bertrand&rdquo; Classes</h2><span id='topic+BertrandOther-Classes'></span><span id='topic+Bertrand-class'></span><span id='topic+Linear-class'></span><span id='topic+LogLin-class'></span><span id='topic+AIDS-class'></span><span id='topic+PCAIDS-class'></span><span id='topic+PCAIDSNests-class'></span>

<h3>Description</h3>

<p>The &ldquo;Bertrand&rdquo; class is a building block used to create other classes
in this package. As such, it is most likely to be useful for developers
who wish to code their own merger calibration/simulation routines.
</p>
<p>Each class below contains all the information needed to calibrate a specific type of demand system and
perform a merger simulation analysis under the assumption that firms are playing a differentiated products Bertrand pricing game.
</p>
<p>The &ldquo;Linear&rdquo; class has the information for a Linear demand system.
</p>
<p>The &ldquo;LogLin&rdquo; class has the information for a Log-Linear demand system.
</p>
<p>The &ldquo;AIDS&rdquo; class has the information for a AIDS demand system.
</p>
<p>The &ldquo;PCAIDS&rdquo; class has the information for a PCAIDS demand system
</p>
<p>The &ldquo;PCAIDSNests&rdquo; class has the information for a nested PCAIDS demand system
</p>
<p>Below, let k denote the number of products produced by all firms.
</p>


<h3>Slots</h3>


<dl>
<dt><code>shares</code></dt><dd><p>A length k vector containing observed output. Depending upon the model, output will be measured in
units sold, quantity shares, or revenue shares.</p>
</dd>
<dt><code>mcDelta</code></dt><dd><p>A length k vector where each element equals the proportional change in a product's marginal costs due to the merger.</p>
</dd>
<dt><code>slopes</code></dt><dd><p>A k x (k+1) matrix of linear demand intercepts and slope coefficients</p>
</dd>
<dt><code>subset</code></dt><dd><p>A vector of length k where each element equals TRUE if the product indexed by that element should be included in the
post-merger simulation and FALSE if it should be excluded.</p>
</dd>
<dt><code>intercepts</code></dt><dd><p>A length k vector of demand intercepts. (Linear only)</p>
</dd>
<dt><code>prices</code></dt><dd><p>A length k vector product prices. (Linear only)</p>
</dd>
<dt><code>quantities</code></dt><dd><p>A length k vector of product quantities. (Linear only)</p>
</dd>
<dt><code>margins</code></dt><dd><p>A length k vector of product margins. All margins must be between 0 and 1. (Linear only)</p>
</dd>
<dt><code>diversion</code></dt><dd><p>A k x k matrix of diversion ratios with diagonal elements equal to -1.</p>
</dd>
<dt><code>priceStart</code></dt><dd><p>A length k vector of prices used as the initial guess in the nonlinear equation solver. (Linear and AIDS only)</p>
</dd>
<dt><code>symmetry</code></dt><dd><p>If TRUE, requires the matrix of demand slope coefficients to be consistent with utility maximization theory.
Default is false. (Linear and LogLin only)</p>
</dd>
<dt><code>insideSize</code></dt><dd><p>A positive number equal to total pre-merger revenues for all products included in the simulation. (AIDS only)</p>
</dd>
<dt><code>mktElast</code></dt><dd><p>A negative number equal to the industry pre-merger price elasticity. (AIDS only)</p>
</dd>
<dt><code>parmStart</code></dt><dd><p>A length 2 vector who elements equal to an initial of a single diagonal element of the matrix of slope coefficients,
as well as the market elasticity. (AIDS only)</p>
</dd>
<dt><code>priceDelta</code></dt><dd><p>A length k vector containing the simulated price effects from the merger. (AIDS only)</p>
</dd>
<dt><code>knownElast</code></dt><dd><p>A negative number equal to the pre-merger own-price elasticity for any of the k products. (PCAIDS only)</p>
</dd>
<dt><code>knownElastIndex</code></dt><dd><p>An integer equal to the position of the &lsquo;knownElast&rsquo; product in the &lsquo;shares&rsquo; vector. (PCAIDS only)</p>
</dd>
<dt><code>nests</code></dt><dd><p>A length k vector identifying which nest a product belongs to. (Nested PCAIDS only)</p>
</dd>
<dt><code>nestsParms</code></dt><dd><p>A length k vector containing nesting parameters. (Nested PCAIDS only)</p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>For Bertrand, objects can be created by calls of the form <code>new("Bertrand", ...)</code>.
</p>
<p>For Linear, objects can be created by using the constructor function <code><a href="#topic+linear">linear</a></code>.
</p>
<p>For LogLin, objects can be created by using the constructor function <code><a href="stats.html#topic+loglin">loglin</a></code>.
</p>
<p>For AIDS, objects can be created by using the constructor function <code><a href="#topic+aids">aids</a></code>.
</p>
<p>For PCAIDS, objects can be created by using the constructor <code><a href="#topic+pcaids">pcaids</a></code>.
</p>
<p>For nested PCAIDS, objects can be created by using the constructor <code><a href="#topic+pcaids.nests">pcaids.nests</a></code>.
</p>


<h3>Extends</h3>

<p>Bertrand: Class <code><a href="#topic+Antitrust-class">Antitrust</a></code>, directly.
</p>
<p>Linear: Class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, directly.
Class <code><a href="#topic+Antitrust-class">Antitrust</a></code>, by class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, distance 2.
</p>
<p>LogLin: Class <code><a href="#topic+Linear-class">Linear</a></code>, directly.
Class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, by class <code><a href="#topic+Linear-class">Linear</a></code>, distance 2.
Class <code><a href="#topic+Antitrust-class">Antitrust</a></code>, by class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, distance 3.
</p>
<p>AIDS: Class <code><a href="#topic+Linear-class">Linear</a></code>, directly. Class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, by class &ldquo;Linear&rdquo;, distance 2.
</p>
<p>PCAIDS: Class <code><a href="#topic+AIDS-class">AIDS</a></code>, directly. Class <code><a href="#topic+Linear-class">Linear</a></code>, by class <code><a href="#topic+AIDS-class">AIDS</a></code>, distance 2.
Class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, by class <code><a href="#topic+Linear-class">Linear</a></code>, distance 3. Class <code><a href="#topic+Antitrust-class">Antitrust</a></code>, by class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, distance 4.
</p>
<p>Nested PCAIDS: Class <code><a href="#topic+PCAIDS-class">PCAIDS</a></code>, directly. Class <code><a href="#topic+AIDS-class">AIDS</a></code>, by class <code><a href="#topic+PCAIDS-class">PCAIDS</a></code>, distance 2.
Class <code><a href="#topic+Linear-class">Linear</a></code>, by class <code><a href="#topic+AIDS-class">AIDS</a></code>, distance 3. Class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, by class <code><a href="#topic+Linear-class">Linear</a></code>, distance 4.
Class <code><a href="#topic+Antitrust-class">Antitrust</a></code>, by class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, distance 5.
</p>


<h3>Author(s)</h3>

<p>Charles Taragin <a href="mailto:ctaragin+antitrustr@gmail.com">ctaragin+antitrustr@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("Bertrand")           # get a detailed description of the class
showClass("Linear")           # get a detailed description of the class
showClass("LogLin")           # get a detailed description of the class
showClass("AIDS")           # get a detailed description of the class
showClass("PCAIDS")           # get a detailed description of the class
showClass("PCAIDSNests")           # get a detailed description of the class
</code></pre>

<hr>
<h2 id='BertrandRUM-Classes'>&ldquo;Bertrand RUM&rdquo; Classes</h2><span id='topic+BertrandRUM-Classes'></span><span id='topic+Logit-class'></span><span id='topic+LogitCap-class'></span><span id='topic+LogitCapALM-class'></span><span id='topic+LogitNests-class'></span><span id='topic+LogitNestsALM-class'></span><span id='topic+LogitALM-class'></span><span id='topic+CES-class'></span><span id='topic+CESALM-class'></span><span id='topic+CESNests-class'></span>

<h3>Description</h3>

<p>Each class contains all the information needed to calibrate a specific type of demand system and
perform a merger simulation analysis under the assumption that firms are playing a differentiated products Bertrand pricing game.
</p>
<p>The &ldquo;Logit&rdquo; class has the information for a Logit demand system.
</p>
<p>The &ldquo;LogitCap&rdquo; class has the information for a Logit demand system and assumes that
firms are playing a differentiated products Bertrand pricing game with capacity constraints.
&ldquo;LogitCapALM&rdquo; extends &ldquo;LogitCap&rdquo; to allow for an unobserved outside share.
</p>
<p>The &ldquo;LogitNests&rdquo; class has the information for a nested Logit
</p>
<p>The &ldquo;LogitNestsALM&rdquo; class has the information for a nested Logit
demand system under the assumption that the share of the outside product is not known.
Once the model parameters have been calibrated, methods exist that perform a merger simulation analysis under the assumption that
firms are playing a differentiated products Bertrand pricing game.
</p>
<p>The &ldquo;LogitALM&rdquo; class has the information for a Logit demand system
assuming that firms are playing a differentiated products Bertrand pricing game with unknown market elasticity.
</p>
<p>The &ldquo;CES&rdquo; class has the information for a CES demand system
</p>
<p>The &ldquo;CESALM&rdquo; class has the information for a CES demand system and
assumes that firms are playing a differentiated products Bertrand pricing game with unknown market elasticity.
</p>
<p>The &ldquo;CESNests&rdquo; class has the information for a nested CES demand system.
</p>
<p>Let k denote the number of products produced by all firms below.
</p>


<h3>Slots</h3>


<dl>
<dt><code>prices</code></dt><dd><p>A length k vector of product prices.</p>
</dd>
<dt><code>margins</code></dt><dd><p>A length k vector of product margins, some of which may equal NA.</p>
</dd>
<dt><code>normIndex</code></dt><dd><p>An integer specifying the product index against which the mean values of all other products are normalized.</p>
</dd>
<dt><code>shareInside</code></dt><dd><p>The share of customers that purchase any of the products included in the &lsquo;prices&rsquo; vector.</p>
</dd>
<dt><code>priceOutside</code></dt><dd><p>The price of the outside good. Default is 0.</p>
</dd>
<dt><code>slopes</code></dt><dd><p>A list containing the coefficient on price (&lsquo;alpha&rsquo;) and the vector of mean valuations (&lsquo;meanval&rsquo;).</p>
</dd>
<dt><code>mktElast</code></dt><dd><p>A length 1 vector of market elasticities.</p>
</dd>
<dt><code>priceStart</code></dt><dd><p>A length-k vector of starting prices for the non-linear solver.</p>
</dd>
<dt><code>insideSize</code></dt><dd><p>A positive number equal to total pre-merger quantities (revenues for CES) for all products included in the simulation.</p>
</dd>
<dt><code>mktSize</code></dt><dd><p>A positive number equal to total quantities (revenues for CES) pre-merger for all products in the simulations
as well as the outside good.</p>
</dd>
<dt><code>capacitiesPre</code></dt><dd><p>A length k vector whose elements equal pre-merger product capacities. (LogitCap and LogitCapALM only)</p>
</dd>
<dt><code>capacitiesPost</code></dt><dd><p>A length k vector whose elements equal post-merger product capacities. (LogitCap and LogitCapALM only)</p>
</dd>
<dt><code>nests</code></dt><dd><p>A length k vector identifying the nest that each product belongs to. (LogitNests and CESNests Only)</p>
</dd>
<dt><code>parmsStart</code></dt><dd><p>A length k vector who elements equal an initial guess of the nesting parameter values. (LogitNests and CESNests Only)</p>
</dd>
<dt><code>constraint</code></dt><dd><p>A length 1 logical vector that equals TRUE if all nesting parameters are constrained to equal the same value
and FALSE otherwise. Default is TRUE. (LogitNests and CESNests Only)</p>
</dd>
<dt><code>parmsStart</code></dt><dd><p>A length 2 vector whose first element equals an initial guess of the price coefficient and whose second
element equals an initial guess of the outside share. The price
coefficient's initial value must be negative and the outside share's initial value must be between 0 and 1. (LogitALM and CESALM only)</p>
</dd>
<dt><code>slopes</code></dt><dd><p>A list containing the coefficient on the numeraire (&lsquo;alpha&rsquo;),  the coefficient on price (&lsquo;gamma&rsquo;), and the vector of mean
valuations (&lsquo;meanval&rsquo;) (CES only)</p>
</dd>
<dt><code>priceOutside</code></dt><dd><p>The price of the outside good. Default is 1. (CES only)</p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>For Logit, objects can be created by using the constructor function <code><a href="#topic+logit">logit</a></code>.
</p>
<p>For LogitALM, objects can be created by using the constructor function <code><a href="#topic+logit.alm">logit.alm</a></code>.
</p>
<p>For LogitCap and LogitCapALM, objects can be created by using the constructor function <code><a href="#topic+logit.cap">logit.cap</a></code> and <code><a href="#topic+logit.cap.alm">logit.cap.alm</a></code>.
</p>
<p>For LogitNests, objects can be created by using the constructor function <code><a href="#topic+logit.nests">logit.nests</a></code>.
</p>
<p>For LogitNestsALM, objects can be created by using the constructor function <code><a href="#topic+logit.nests.alm">logit.nests.alm</a></code>.
</p>
<p>For CES, objects can be created by using the constructor function <code><a href="#topic+ces">ces</a></code>.
</p>
<p>For CESALM, objects can be created by using the constructor function <code><a href="#topic+ces.alm">ces.alm</a></code>.
</p>
<p>For CESNests, objects can be created by using the constructor function <code><a href="#topic+ces.nests">ces.nests</a></code>.
</p>


<h3>Extends</h3>

<p>Logit: Class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, directly.
Class <code><a href="#topic+Antitrust-class">Antitrust</a></code>, by class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, distance 2.
</p>
<p>LogitCap: Class <code><a href="#topic+Logit-class">Logit</a></code>, directly.
Class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, by class <code><a href="#topic+Logit-class">Logit</a></code>, distance 2.
Class <code><a href="#topic+Antitrust-class">Antitrust</a></code>, by class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, distance 3.
</p>
<p>#'LogitCapALM: Class <code><a href="#topic+LogitCap-class">LogitCap</a></code>, directly.
Class <code><a href="#topic+Logit-class">Logit</a></code>, by class <code><a href="#topic+LogitCap-class">LogitCap</a></code>, distance 2.
Class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, by class <code><a href="#topic+Logit-class">Logit</a></code>, distance 3.
Class <code><a href="#topic+Antitrust-class">Antitrust</a></code>, by class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, distance 4.
</p>
<p>LogitNests: Class <code><a href="#topic+Logit-class">Logit</a></code>, directly.
Class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, by class <code><a href="#topic+Logit-class">Logit</a></code>, distance 2.
</p>
<p>LogitNestsALM: Class <code><a href="#topic+LogitNests-class">LogitNests</a></code>, directly.
Class <code><a href="#topic+Logit-class">Logit</a></code>, by class <code><a href="#topic+LogitNests-class">LogitNests</a></code>, distance 2.
Class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, by class <code><a href="#topic+Logit-class">Logit</a></code>, distance 3.
Class <code><a href="#topic+Antitrust-class">Antitrust</a></code>, by class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, distance 4.
</p>
<p>LogitALM: Class <code><a href="#topic+Logit-class">Logit</a></code>, directly.
Class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, by class <code><a href="#topic+Logit-class">Logit</a></code>, distance 2.
Class <code><a href="#topic+Antitrust-class">Antitrust</a></code>, by class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, distance 3.
</p>
<p>CES: Class <code><a href="#topic+Logit-class">Logit</a></code>, directly.
Class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, by class <code><a href="#topic+Logit-class">Logit</a></code>, distance 2.
Class <code><a href="#topic+Antitrust-class">Antitrust</a></code>, by class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, distance 3.
</p>
<p>CESALM: Class <code><a href="#topic+CES-class">CES</a></code>, directly.
Class <code><a href="#topic+Logit-class">Logit</a></code>, by class <code><a href="#topic+CES-class">CES</a></code>, distance 2.
Class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, by class <code><a href="#topic+Logit-class">Logit</a></code>, distance 3.
Class <code><a href="#topic+Antitrust-class">Antitrust</a></code>, by class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, distance 4.
</p>
<p>CESNests: Class <code><a href="#topic+CES-class">CES</a></code>, directly.
Class <code><a href="#topic+Logit-class">Logit</a></code>, by class <code><a href="#topic+CES-class">CES</a></code>, distance 2.
Class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, by class <code><a href="#topic+Logit-class">Logit</a></code>, distance 3.
Class <code><a href="#topic+Antitrust-class">Antitrust</a></code>, by class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, distance 4.
</p>


<h3>Author(s)</h3>

<p>Charles Taragin <a href="mailto:ctaragin+antitrustr@gmail.com">ctaragin+antitrustr@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("Logit")           # get a detailed description of the class
showClass("LogitCap")           # get a detailed description of the class
showClass("LogitNests")           # get a detailed description of the class
showClass("LogitNestsALM")           # get a detailed description of the class
showClass("LogitALM")           # get a detailed description of the class
showClass("CES")           # get a detailed description of the class
showClass("CESALM")           # get a detailed description of the class
showClass("CESNests")           # get a detailed description of the class
</code></pre>

<hr>
<h2 id='CES-Functions'>(Nested) Constant Elasticity of Substitution Demand Calibration and Merger Simulation</h2><span id='topic+CES-Functions'></span><span id='topic+ces'></span><span id='topic+ces.alm'></span><span id='topic+ces.nests'></span>

<h3>Description</h3>

<p>Calibrates consumer demand using (Nested) Constant Elasticity of
Substitution (CES) and then simulates the price effect of a merger between two firms
under the assumption that all firms in the market are playing a
differentiated products Bertrand pricing game.
</p>
<p>Let k denote the number of products produced by all firms playing the
Bertrand pricing game below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ces(
  prices,
  shares,
  margins,
  diversions,
  ownerPre,
  ownerPost,
  normIndex = ifelse(sum(shares) &lt; 1, NA, 1),
  mktElast = NA_real_,
  insideSize = NA_real_,
  mcDelta = rep(0, length(prices)),
  subset = rep(TRUE, length(prices)),
  priceOutside = 1,
  priceStart = prices,
  isMax = FALSE,
  control.slopes,
  control.equ,
  labels = paste("Prod", 1:length(prices), sep = ""),
  ...
)

ces.alm(
  prices,
  shares,
  margins,
  ownerPre,
  ownerPost,
  mktElast = NA_real_,
  insideSize = NA_real_,
  mcDelta = rep(0, length(prices)),
  subset = rep(TRUE, length(prices)),
  priceOutside = 1,
  priceStart = prices,
  isMax = FALSE,
  parmsStart,
  control.slopes,
  control.equ,
  labels = paste("Prod", 1:length(prices), sep = ""),
  ...
)

ces.nests(
  prices,
  shares,
  margins,
  ownerPre,
  ownerPost,
  nests = rep(1, length(shares)),
  normIndex = ifelse(sum(shares) &lt; 1, NA, 1),
  insideSize = NA_real_,
  mcDelta = rep(0, length(prices)),
  subset = rep(TRUE, length(prices)),
  priceOutside = 1,
  priceStart = prices,
  isMax = FALSE,
  constraint = TRUE,
  parmsStart,
  control.slopes,
  control.equ,
  labels = paste("Prod", 1:length(prices), sep = ""),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CES-Functions_+3A_prices">prices</code></td>
<td>
<p>A length k vector of product prices.</p>
</td></tr>
<tr><td><code id="CES-Functions_+3A_shares">shares</code></td>
<td>
<p>A length k vector of product revenue shares.</p>
</td></tr>
<tr><td><code id="CES-Functions_+3A_margins">margins</code></td>
<td>
<p>A length k vector of product margins, some of which may
equal NA.</p>
</td></tr>
<tr><td><code id="CES-Functions_+3A_diversions">diversions</code></td>
<td>
<p>A k x k matrix of diversion ratios with diagonal
elements equal to -1. Default is missing.</p>
</td></tr>
<tr><td><code id="CES-Functions_+3A_ownerpre">ownerPre</code></td>
<td>
<p>EITHER a vector of length k whose values
indicate which firm produced a product pre-merger OR
a k x k matrix of pre-merger ownership shares.</p>
</td></tr>
<tr><td><code id="CES-Functions_+3A_ownerpost">ownerPost</code></td>
<td>
<p>EITHER a vector of length k whose values
indicate which firm produced a product after the merger OR
a k x k matrix of post-merger ownership shares.</p>
</td></tr>
<tr><td><code id="CES-Functions_+3A_normindex">normIndex</code></td>
<td>
<p>An integer specifying the product index against which
the mean values of all other products are normalized. Default is 1.</p>
</td></tr>
<tr><td><code id="CES-Functions_+3A_mktelast">mktElast</code></td>
<td>
<p>a negative value indicating market elasticity. Default is NA.</p>
</td></tr>
<tr><td><code id="CES-Functions_+3A_insidesize">insideSize</code></td>
<td>
<p>total revenues included in the market.</p>
</td></tr>
<tr><td><code id="CES-Functions_+3A_mcdelta">mcDelta</code></td>
<td>
<p>A vector of length k where each element equals the
proportional change in a product's marginal costs due to
the merger. Default is 0, which assumes that the merger does not
affect any products' marginal cost.</p>
</td></tr>
<tr><td><code id="CES-Functions_+3A_subset">subset</code></td>
<td>
<p>A vector of length k where each element equals TRUE if
the product indexed by that element should be included in the
post-merger simulation and FALSE if it should be excluded.Default is a
length k vector of TRUE.</p>
</td></tr>
<tr><td><code id="CES-Functions_+3A_priceoutside">priceOutside</code></td>
<td>
<p>A length 1 vector indicating the price of the
outside good. Default is 1.</p>
</td></tr>
<tr><td><code id="CES-Functions_+3A_pricestart">priceStart</code></td>
<td>
<p>A length k vector of starting values used to solve for
equilibrium price. Default is the &lsquo;prices&rsquo; vector.</p>
</td></tr>
<tr><td><code id="CES-Functions_+3A_ismax">isMax</code></td>
<td>
<p>If TRUE, checks to see whether computed price equilibrium
locally maximizes firm profits and returns a warning if not. Default is FALSE.</p>
</td></tr>
<tr><td><code id="CES-Functions_+3A_control.slopes">control.slopes</code></td>
<td>
<p>A list of  <code><a href="stats.html#topic+optim">optim</a></code>  control parameters passed to the
calibration routine optimizer (typically the <code>calcSlopes</code> method).</p>
</td></tr>
<tr><td><code id="CES-Functions_+3A_control.equ">control.equ</code></td>
<td>
<p>A list of  <code><a href="BB.html#topic+BBsolve">BBsolve</a></code> control parameters passed
to the non-linear equation solver (typically the <code>calcPrices</code> method).</p>
</td></tr>
<tr><td><code id="CES-Functions_+3A_labels">labels</code></td>
<td>
<p>A k-length vector of labels. Default is &quot;Prod#&quot;, where
&lsquo;#&rsquo; is a number between 1 and the length of &lsquo;prices&rsquo;.</p>
</td></tr>
<tr><td><code id="CES-Functions_+3A_...">...</code></td>
<td>
<p>Additional options to feed to the <code><a href="BB.html#topic+BBsolve">BBsolve</a></code>
optimizer used to solve for equilibrium prices.</p>
</td></tr>
<tr><td><code id="CES-Functions_+3A_parmsstart">parmsStart</code></td>
<td>
<p>A vector of starting values used to solve for
price coefficient and nest parameters. The first element should
always be the price coefficient and the remaining elements should be
nesting parameters. Theory requires the nesting parameters to be
greater than the price coefficient. If missing then the random
draws with the appropriate restrictions are employed.</p>
</td></tr>
<tr><td><code id="CES-Functions_+3A_nests">nests</code></td>
<td>
<p>A length k vector identifying the nest that each
product belongs to.</p>
</td></tr>
<tr><td><code id="CES-Functions_+3A_constraint">constraint</code></td>
<td>
<p>if TRUE, then the nesting parameters for all
non-singleton nests are assumed equal. If FALSE, then each
non-singleton nest is permitted to have its own value. Default is
TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using product prices, revenue shares and all of the
product margins from at least one firm, <code>ces</code> is able to
recover the price coefficient and product mean valuations in a
Constant Elasticity of Substitution demand model. <code>ces</code> then uses these
calibrated parameters to simulate the price effects of a merger between two firms under the
assumption that that all firms in the market are playing a
differentiated products Bertrand pricing game.
</p>
<p><code>ces.alm</code> is identical to <code>ces</code> except that it assumes that an outside product exists and uses additional margin information to estimate the share of the outside good.
</p>
<p><code>ces.nests</code> is identical to <code>ces</code> except that it includes the &lsquo;nests&rsquo;
argument which may be used to assign products to different
nests. Nests are useful because they allow for richer substitution
patterns between products. Products within the same nest are assumed
to be closer substitutes than products in different nests. The degree
of substitutability between products located in different nests is
controlled by the value of the nesting parameter sigma.
The nesting parameters for singleton nests (nests containing
only one product) are not identified and normalized to 1.  The vector of
sigmas is calibrated from the prices, revenue shares, and margins supplied
by the user.
</p>
<p>By default, all non-singleton nests are assumed to have a common value for sigma.
This constraint may be relaxed  by setting &lsquo;constraint&rsquo; to
FALSE. In this case, at least one product margin must be supplied from
a product within each nest.
</p>
<p>In both  <code>ces</code> and  <code>ces.nests</code>, if revenue shares sum to 1,
then one product's mean value is not identified and must be normalized
to 1. &lsquo;normIndex&rsquo; may be used to specify the index (position) of the
product whose mean value is to be normalized. If the sum of revenue shares
is less than 1, both of these functions assume that the exists a k+1st
product in the market whose price and mean value are both normalized
to 1.
</p>


<h3>Value</h3>

<p><code>ces</code> returns an instance of class <code><a href="#topic+CES-class">CES</a></code>.
<code>ces.alm</code> returns an instance of class <code><a href="#topic+CESALM-class">CESALM</a></code>.
<code>ces.nests</code> returns an instance of <code><a href="#topic+CESNests-class">CESNests</a></code>, a
child class of <code><a href="#topic+CES-class">CES</a></code>.
</p>


<h3>Author(s)</h3>

<p>Charles Taragin <a href="mailto:ctaragin+antitrustr@gmail.com">ctaragin+antitrustr@gmail.com</a>
</p>


<h3>References</h3>

<p>Anderson, Simon, Palma, Andre, and Francois Thisse (1992).
<em>Discrete Choice Theory of Product Differentiation</em>.
The MIT Press, Cambridge, Mass.
</p>
<p>Epstein, Roy and Rubinfeld, Daniel (2004).
&ldquo;Effects of Mergers Involving Differentiated Products.&rdquo;
</p>
<p>Sheu G (2011).
&ldquo;Price, Quality, and Variety: Measuring the Gains From Trade in Differentiated
Products.&rdquo;
U.S Department of Justice.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logit">logit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Calibration and simulation results from a merger between Budweiser and
## Old Style. Assume that typical consumer spends 1% of income on beer,
## and that total beer expenditure in US is 1e9
## Source: Epstein/Rubenfeld 2004, pg 80

prodNames &lt;- c("BUD","OLD STYLE","MILLER","MILLER-LITE","OTHER-LITE","OTHER-REG")
ownerPre &lt;-c("BUD","OLD STYLE","MILLER","MILLER","OTHER-LITE","OTHER-REG")
ownerPost &lt;-c("BUD","BUD","MILLER","MILLER","OTHER-LITE","OTHER-REG")
nests &lt;- c("R","R","R","L","L","R")

price    &lt;- c(.0441,.0328,.0409,.0396,.0387,.0497)
shares   &lt;- c(.071,.137,.251,.179,.093,.269)
margins  &lt;- c(.3830,.5515,.5421,.5557,.4453,.3769)

names(price) &lt;-
  names(shares) &lt;-
  names(margins) &lt;-
  prodNames

result.ces &lt;-ces(price,shares,margins,ownerPre=ownerPre,ownerPost=ownerPost,
                 labels=prodNames)

print(result.ces)           # return predicted price change
summary(result.ces)         # summarize merger simulation

elast(result.ces,TRUE)      # returns premerger elasticities
elast(result.ces,FALSE)     # returns postmerger elasticities

diversion(result.ces,TRUE)  # return premerger diversion ratios
diversion(result.ces,FALSE) # return postmerger diversion ratios

cmcr(result.ces)            #calculate compensating marginal cost reduction
upp(result.ces)             #calculate Upwards Pricing Pressure Index

CV(result.ces)              #calculate compensating variation as a percent of
#representative consumer income

## Implement the Hypothetical Monopolist Test
## for BUD and OLD STYLE using a 5\% SSNIP

HypoMonTest(result.ces,prodIndex=1:2)


## Get a detailed description of the 'CES' class slots
showClass("CES")

## Show all methods attached to the 'CES' Class
showMethods(classes="CES")

## Show which class have their own 'elast' method
showMethods("elast")

## Show the method definition for 'elast' and Class 'CES'
getMethod("elast","CES")

</code></pre>

<hr>
<h2 id='CMCR-Methods'>Methods For Calculating Compensating Marginal Cost Reductions</h2><span id='topic+CMCR-Methods'></span><span id='topic+cmcr-methods'></span><span id='topic+cmcr+2CANY-method'></span><span id='topic+cmcr+2CBertrand-method'></span><span id='topic+cmcr+2CAuction2ndLogit-method'></span><span id='topic+cmcr+2CCournot-method'></span><span id='topic+cmcr+2CAIDS-method'></span>

<h3>Description</h3>

<p>Calculate the marginal cost reductions necessary to restore
premerger prices in a merger, or the Upwards Pricing Pressure Index
for the products of merging firms playing a differentiated
products Bertrand pricing game.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Bertrand'
cmcr(object, market = FALSE, levels = FALSE, rel = c("cost", "price"))

## S4 method for signature 'Cournot'
cmcr(object, market = TRUE, levels = FALSE, rel = c("cost", "price"))

## S4 method for signature 'AIDS'
cmcr(object, market = FALSE, rel = c("cost", "price"))

## S4 method for signature 'Auction2ndLogit'
cmcr(object, market = FALSE, levels = FALSE, rel = c("cost", "price"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CMCR-Methods_+3A_object">object</code></td>
<td>
<p>An instance of one of the classes listed above.</p>
</td></tr>
<tr><td><code id="CMCR-Methods_+3A_market">market</code></td>
<td>
<p>If TRUE, calculates (post-merger) share-weighted average of metric. Default is FALSE.</p>
</td></tr>
<tr><td><code id="CMCR-Methods_+3A_levels">levels</code></td>
<td>
<p>If TRUE calculates CMCR in levels rather than as a percentage of pre-merger costs. Default is FALSE.</p>
</td></tr>
<tr><td><code id="CMCR-Methods_+3A_rel">rel</code></td>
<td>
<p>A length 1 character vector indicating whether CMCR should be calculated
relative to pre-merger cost (&ldquo;cost&rdquo;) or pre-merger price (&ldquo;price&rdquo;), 
Default is &ldquo;cost&rdquo;. Ignored when levels is TRUE.</p>
</td></tr>
<tr><td><code id="CMCR-Methods_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>cmcr</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cmcr</code> uses the results from the merger simulation and calibration
methods associates with a particular class to compute the compensating
marginal cost reduction (CMCR) for each of the merging parties' products.
</p>


<h3>Value</h3>

<p><code>cmcr</code> returns a vector of length k equal to CMCR for the
merging parties' products and 0 for all other products.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cmcr.bertrand">cmcr.bertrand</a></code> is a function that calculates CMCR
without the need to first calibrate a demand system and simulate a
merger.
</p>

<hr>
<h2 id='CMCRBertrand-Functions'>Compensating Marginal Cost Reductions and Upwards Pricing Pressure (Bertrand)</h2><span id='topic+CMCRBertrand-Functions'></span><span id='topic+cmcr.bertrand'></span><span id='topic+upp.bertrand'></span><span id='topic+upp'></span><span id='topic+cmcr'></span>

<h3>Description</h3>

<p>Calculate the marginal cost reductions necessary to restore
premerger prices (CMCR), or the net Upwards Pricing Pressure (UPP) in a
merger involving firms playing a differentiated products Bertrand pricing game.
</p>
<p>Let k denote the number of products produced by the merging parties below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmcr.bertrand(
  prices,
  margins,
  diversions,
  ownerPre,
  ownerPost = matrix(1, ncol = length(prices), nrow = length(prices)),
  rel = c("cost", "price"),
  labels = names(prices)
)

upp.bertrand(
  prices,
  margins,
  diversions,
  ownerPre,
  ownerPost = matrix(1, ncol = length(prices), nrow = length(prices)),
  mcDelta = rep(0, length(prices)),
  labels = paste("Prod", 1:length(prices), sep = "")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CMCRBertrand-Functions_+3A_prices">prices</code></td>
<td>
<p>A length-k vector of product prices.</p>
</td></tr>
<tr><td><code id="CMCRBertrand-Functions_+3A_margins">margins</code></td>
<td>
<p>A length-k vector of product margins.</p>
</td></tr>
<tr><td><code id="CMCRBertrand-Functions_+3A_diversions">diversions</code></td>
<td>
<p>A k x k matrix of diversion ratios
with diagonal elements equal to -1.</p>
</td></tr>
<tr><td><code id="CMCRBertrand-Functions_+3A_ownerpre">ownerPre</code></td>
<td>
<p>EITHER a vector of length k whose values
indicate which of the merging parties produced a product pre-merger OR
a k x k matrix of pre-merger ownership shares.</p>
</td></tr>
<tr><td><code id="CMCRBertrand-Functions_+3A_ownerpost">ownerPost</code></td>
<td>
<p>A k x k matrix of post-merger
ownership shares. Default is a k x k matrix of 1s.</p>
</td></tr>
<tr><td><code id="CMCRBertrand-Functions_+3A_rel">rel</code></td>
<td>
<p>A length 1 character vector indicating whether CMCR should be calculated
relative to pre-merger cost (&ldquo;cost&rdquo;) or pre-merger price (&ldquo;price&rdquo;), 
Default is &ldquo;cost&rdquo;.</p>
</td></tr>
<tr><td><code id="CMCRBertrand-Functions_+3A_labels">labels</code></td>
<td>
<p>A length-k vector of product labels.</p>
</td></tr>
<tr><td><code id="CMCRBertrand-Functions_+3A_mcdelta">mcDelta</code></td>
<td>
<p>A vector of length k where each element equals the
proportional change in a product's marginal costs due to
the merger. Default is 0, which assumes that the merger does not
affect any products' marginal cost.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All &lsquo;prices&rsquo; elements must be positive, all &lsquo;margins&rsquo;
elements must be between 0 and 1, and all &lsquo;diversions&rsquo; elements must be
between 0 and 1 in absolute value. In
addition, off-diagonal elements (i,j) of &lsquo;diversions&rsquo;
must equal an estimate of the diversion ratio from product i to product j
(i.e. the estimated fraction of i's sales that go to j due to a small
increase in i's price). Also, &lsquo;diversions&rsquo;
elements are positive if i and j are substitutes and negative if i and j are
complements.
</p>
<p>&lsquo;ownerPre&rsquo; will typically be a vector whose values equal 1 if a product is produced
by firm 1 and 0 otherwise, though other values including firm name are
acceptable.  Optionally, &lsquo;ownerPre&rsquo; may be set equal
to a matrix of the merging firms pre-merger ownership
shares. These ownership shares must be between 0 and 1.
</p>
<p>&lsquo;ownerPost&rsquo;  is an optional argument that should only be specified if
one party to the acquisition is assuming partial control of the
other party's assets.   &lsquo;ownerPost&rsquo; elements must be between 0 and
1.
</p>


<h3>Value</h3>

<p><code>cmcr.bertrand</code> returns a length-k vector whose values
equal the percentage change in each products'
marginal costs that the merged firms must achieve in order to offset a
price increase.
</p>
<p><code>upp.bertrand</code> returns a length-k vector whose values equal
the generalized pricing pressure (GePP) for each of the merging's parties' products,
net any efficiency claims. GePP is a generalization of Upwards Pricing Pressure (UPP)
that accomodates multi-product firms.
</p>


<h3>Author(s)</h3>

<p>Charles Taragin <a href="mailto:ctaragin+antitrustr@gmail.com">ctaragin+antitrustr@gmail.com</a>
</p>


<h3>References</h3>

<p>Farrell, Joseph and Shapiro, Carl (2010).
&ldquo;Antitrust Evaluation of Horizontal Mergers: An Economic Alternative to
Market Definition.&rdquo;
<em>The B.E. Journal of Theoretical Economics</em>, <b>10</b>(1), pp. 1-39.
</p>
<p>Jaffe, Sonia and Weyl Eric (2012).
&ldquo;The First-Order Approach to Merger Analysis.&rdquo;
<em>SSRN eLibrary</em>
</p>
<p>Werden, Gregory (1996).
&ldquo;A Robust Test for Consumer Welfare Enhancing Mergers Among Sellers
of Differentiated Products.&rdquo;
<em>The Journal of Industrial Economics</em>, <b>44</b>(4), pp. 409-413.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cmcr.cournot">cmcr.cournot</a></code> for a homogeneous products Cournot
version of CMCR, and <code><a href="#topic+cmcr-methods">cmcr-methods</a></code> for calculating
CMCR and UPP after calibrating demand system parameters and simulating a merger.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Let k_1 = 1 and and k_2 = 2 ##

p1 = 50;      margin1 = .3
p2 = c(45,70); margin2 = c(.4,.6)
isOne=c(1,0,0)
diversions = matrix(c(-1,.5,.01,.6,-1,.1,.02,.2,-1),ncol=3)

cmcr.bertrand(c(p1,p2), c(margin1,margin2), diversions, isOne)
upp.bertrand(c(p1,p2), c(margin1,margin2), diversions, isOne)


## Calculate the necessary percentage cost reductions for various margins and
## diversion ratios in a two-product merger where both products have
## equal prices and diversions (see Werden 1996, pg. 412, Table 1)


margins = seq(.4,.7,.1)
diversions = seq(.05,.25,.05)
prices = rep(1,2) #assuming prices are equal, we can set product prices to 1
isOne = c(1,0)
result = matrix(ncol=length(margins),nrow=length(diversions),dimnames=list(diversions,margins))

for(m in 1:length(margins)){
  for(d in 1:length(diversions)){

    dMatrix = -diag(2)
    dMatrix[2,1] &lt;- dMatrix[1,2] &lt;- diversions[d]

    firmMargins = rep(margins[m],2)

    result[d,m] = cmcr.bertrand(prices, firmMargins, dMatrix, isOne)[1]

  }}

print(round(result,1))

</code></pre>

<hr>
<h2 id='CMCRCournot-Functions'>Compensating Marginal Cost Reductions and Upwards Pricing Pressure (Cournot)</h2><span id='topic+CMCRCournot-Functions'></span><span id='topic+cmcr.cournot'></span><span id='topic+cmcr.cournot2'></span><span id='topic+upp.cournot'></span>

<h3>Description</h3>

<p>Calculate the marginal cost reductions necessary to restore
premerger prices (CMCR), or the net Upwards Pricing Pressure (UPP) in a
merger involving firms playing a 
homogeneous product Cournot pricing game.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmcr.cournot(
  shares,
  mktElast,
  party = FALSE,
  rel = c("cost", "price"),
  labels = names(shares)
)

cmcr.cournot2(
  margins,
  rel = c("cost", "price"),
  party = FALSE,
  labels = names(margins)
)

upp.cournot(
  prices,
  margins,
  ownerPre,
  ownerPost = matrix(1, ncol = length(prices), nrow = length(prices)),
  mcDelta = rep(0, length(prices)),
  labels = names(margins)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CMCRCournot-Functions_+3A_shares">shares</code></td>
<td>
<p>A length-2 vector containing merging party quantity shares.</p>
</td></tr>
<tr><td><code id="CMCRCournot-Functions_+3A_mktelast">mktElast</code></td>
<td>
<p>A length-1 containing the industry elasticity.</p>
</td></tr>
<tr><td><code id="CMCRCournot-Functions_+3A_party">party</code></td>
<td>
<p>If TRUE calculate a length-2 vector of individial party CMCRs. 
If FALSE calculate share-weighted CMCR relative to share-weighted pre-merger
marginal costs. Default is FALSE</p>
</td></tr>
<tr><td><code id="CMCRCournot-Functions_+3A_rel">rel</code></td>
<td>
<p>A length 1 character vector indicating whether CMCR should be calculated
relative to pre-merger cost (&ldquo;cost&rdquo;) or pre-merger price (&ldquo;price&rdquo;), 
Default is &ldquo;cost&rdquo;.</p>
</td></tr>
<tr><td><code id="CMCRCournot-Functions_+3A_labels">labels</code></td>
<td>
<p>A length-2 vector of product labels.</p>
</td></tr>
<tr><td><code id="CMCRCournot-Functions_+3A_margins">margins</code></td>
<td>
<p>A length-2 vector of product margins.</p>
</td></tr>
<tr><td><code id="CMCRCournot-Functions_+3A_prices">prices</code></td>
<td>
<p>A length-2 vector of product prices.</p>
</td></tr>
<tr><td><code id="CMCRCournot-Functions_+3A_ownerpre">ownerPre</code></td>
<td>
<p>EITHER a vector of length 2 whose values
indicate which of the merging parties produced a product pre-merger OR
a 2 x 2 matrix of pre-merger ownership shares.</p>
</td></tr>
<tr><td><code id="CMCRCournot-Functions_+3A_ownerpost">ownerPost</code></td>
<td>
<p>A 2 x 2 matrix of post-merger
ownership shares. Default is a 2 x 2 matrix of 1s.</p>
</td></tr>
<tr><td><code id="CMCRCournot-Functions_+3A_mcdelta">mcDelta</code></td>
<td>
<p>A vector of length 2 where each element equals the
proportional change in a product's marginal costs due to
the merger. Default is 0, which assumes that the merger does not
affect any products' marginal cost.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &lsquo;shares&rsquo; (or &lsquo;margins&rsquo;) vector must have 2 elements, 
and all &lsquo;shares&rsquo; and &lsquo;margins&rsquo;
elements must be between 0 and 1. The &lsquo;mktElast&rsquo; vector must
have 1 non-negative  element.
</p>


<h3>Value</h3>

<p>when &lsquo;party&rsquo; is FALSE (default), <code>cmcr.cournot</code>, <code>cmcr.cournot2</code> return a vector with 1 element whose value equals the percentage change
in the products' average marginal costs that the merged firms
must achieve in order to offset a price increase. When &lsquo;party&rsquo; is TRUE,  <code>cmcr.cournot</code>, <code>cmcr.cournot2</code> return a vector with 2 element whose value equals the percentage change
in <em>each</em> parties' marginal costs necessary to offset a price increase. When &lsquo;rel&rsquo; equals &quot;cost&quot; (default) results are in terms of per-merger marginal costs. Otherwise, results are in terms of pre-merger price.
</p>


<h3>Author(s)</h3>

<p>Charles Taragin
</p>


<h3>References</h3>

<p>Froeb, Luke and Werden, Gregory (1998).
&ldquo;A robust test for consumer welfare enhancing mergers among sellers
of a homogeneous product.&rdquo;
<em>Economics Letters</em>, <b>58</b>(3), pp. 367 - 369.
</p>
<p>Werden, Gregory and Froeb, Luke (2008). &ldquo;Unilateral Competitive Effects of Horizontal Mergers&rdquo;, 
in Paolo Buccirossi (ed), Handbook of Antitrust Economics (MIT Press).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cmcr.bertrand">cmcr.bertrand</a></code> for a differentiated products Bertrand version of this measure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>shares=c(.05,.65)
industryElast = 1.9
margins=shares/industryElast

##  calculate average CMCR as a percentage of pre-merger costs
cmcr.cournot(shares,industryElast, rel="cost")

##  calculate average CMCR as a percentage of pre-merger price
cmcr.cournot(shares,industryElast, rel="price")

##  calculate average CMCR using margins as a percentage of pre-merger costs
cmcr.cournot2(margins, party=TRUE,rel="cost")

##  calculate the average CMCR for various shares and
##  industry elasticities in a two-product merger where both firm
##  products have identical share (see Froeb and
##  Werden, 1998, pg. 369, Table 1)



deltaHHI = c(100, 500, 1000, 2500, 5000) #start with change in HHI
shares = sqrt(deltaHHI/(2*100^2)) #recover shares from change in HHI
industryElast = 1:3

result = matrix(nrow=length(deltaHHI),ncol=length(industryElast),
                dimnames=list(deltaHHI,industryElast))

for(s in 1:length(shares)){
  for(e in 1:length(industryElast)){


    result[s,e] = cmcr.cournot(rep(shares[s],2),industryElast[e])[1]

  }}

print(round(result,1))

</code></pre>

<hr>
<h2 id='Cost-Methods'>Methods for Calculating marginal and Variable Costs</h2><span id='topic+Cost-Methods'></span><span id='topic+calcMC'></span><span id='topic+calcMC+2CANY-method'></span><span id='topic+calcMC+2CBertrand-method'></span><span id='topic+calcMC+2CVertBargBertLogit-method'></span><span id='topic+calcMC+2CAuction2ndLogit-method'></span><span id='topic+calcMC+2CCournot-method'></span><span id='topic+calcMC+2CAuction2ndCap-method'></span><span id='topic+calcdMC'></span><span id='topic+calcdMC+2CANY-method'></span><span id='topic+calcdMC+2CStackelberg-method'></span><span id='topic+calcVC'></span><span id='topic+calcVC+2CANY-method'></span><span id='topic+calcVC+2CCournot-method'></span>

<h3>Description</h3>

<p>For Auction2ndCap, calcMC calculates (constant) marginal cost for each
product. For those classes that do not require prices, returns a
length-k vector of NAs when prices are not supplied.
</p>
<p>For Bertrand, calcMC computes either pre- or post-merger marginal costs. Marginal costs
are assumed to be constant. Post-merger marginal costs are equal to
pre-merger marginal costs multiplied by 1+&lsquo;mcDelta&rsquo;, a length-k
vector of marginal cost changes. &lsquo;mcDelta&rsquo; will typically be between 0 and 1.
</p>
<p>For Auction2ndLogit, calcMC computes constant marginal costs impied by the model.
</p>
<p>For Cournot, calcMC calculates marginal cost for each product.
</p>
<p>calcdMC computes the derivative of either pre- or post-merger marginal costs. The derivative of Marginal costs
is assumed to be constant. Post-merger marginal costs are equal to
pre-merger marginal costs multiplied by 1+&lsquo;mcDelta&rsquo;, a length-k
vector of marginal cost changes. &lsquo;mcDelta&rsquo; will typically be between 0 and 1.
</p>
<p>calcVC computes either pre- or post-merger variable costs. Variable costs
are assumed to be quadratic by default. Post-merger variable costs are equal to
pre-merger variable costs multiplied by 1+&lsquo;mcDelta&rsquo;, a length-k
vector of marginal cost changes. &lsquo;mcDelta&rsquo; will typically be between 0
and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Bertrand'
calcMC(object, preMerger = TRUE)

## S4 method for signature 'VertBargBertLogit'
calcMC(object, preMerger = TRUE)

## S4 method for signature 'Auction2ndCap'
calcMC(object, t, preMerger = TRUE, exAnte = TRUE)

## S4 method for signature 'Cournot'
calcMC(object, preMerger = TRUE)

## S4 method for signature 'Auction2ndLogit'
calcMC(object, preMerger = TRUE, exAnte = FALSE)

## S4 method for signature 'Stackelberg'
calcdMC(object, preMerger = TRUE)

## S4 method for signature 'Cournot'
calcVC(object, preMerger = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cost-Methods_+3A_object">object</code></td>
<td>
<p>An instance of the respective class (see description for the classes)</p>
</td></tr>
<tr><td><code id="Cost-Methods_+3A_premerger">preMerger</code></td>
<td>
<p>If TRUE, the pre-merger ownership structure is used. If FALSE, the post-merger ownership structure is used.
Default is TRUE.</p>
</td></tr>
<tr><td><code id="Cost-Methods_+3A_t">t</code></td>
<td>
<p>The capacity profile of each supplier. Default is &lsquo;preMerger&rsquo; capacities.</p>
</td></tr>
<tr><td><code id="Cost-Methods_+3A_exante">exAnte</code></td>
<td>
<p>If &lsquo;exAnte&rsquo; equals TRUE then the
<em>ex ante</em> expected result for each firm is produced, while FALSE produces the
expected result conditional on each firm winning the auction. Default is FALSE.</p>
</td></tr>
</table>

<hr>
<h2 id='Cournot-classes'>&ldquo;Cournot&rdquo; Classes</h2><span id='topic+Cournot-classes'></span><span id='topic+Cournot-class'></span><span id='topic+Stackelberg-class'></span>

<h3>Description</h3>

<p>The &ldquo;Cournot&rdquo; and &ldquo;Stackelberg&rdquo; classes are building blocks used to create other classes
in this package. As such, they are most likely to be useful for developers
who wish to code their own merger calibration/simulation routines.
</p>
<p>Note below that k is the number of products and n is the number of plants.
</p>


<h3>Slots</h3>


<dl>
<dt><code>intercepts</code></dt><dd><p>A length k vector containing the calibrated demand intercept.</p>
</dd>
<dt><code>mcfunPre</code></dt><dd><p>A length n list whose elements equal a function that calculates a plant's pre-merger marginal cost.</p>
</dd>
<dt><code>mcfunPost</code></dt><dd><p>A length n list whose elements equal a function that calculates a plant's post-merger marginal cost.</p>
</dd>
<dt><code>vcfunPre</code></dt><dd><p>A length n list whose elements equal a function that calculates a plant's pre-merger variable cost.</p>
</dd>
<dt><code>vcfunPost</code></dt><dd><p>A length n list whose elements equal a function that calculates a plant's post-merger variable cost.</p>
</dd>
<dt><code>prices</code></dt><dd><p>A length k vector of product prices.</p>
</dd>
<dt><code>quantities</code></dt><dd><p>An n x k matrix of plant quantities produced for each product.</p>
</dd>
<dt><code>margins</code></dt><dd><p>An n x k matrix of plant product margins.</p>
</dd>
<dt><code>quantityPre</code></dt><dd><p>An n x k matrix of predicted pre-merger quantities.</p>
</dd>
<dt><code>quantityPost</code></dt><dd><p>An n x k matrix of predicted post-merger quantities.</p>
</dd>
<dt><code>quantityStart</code></dt><dd><p>A length n x k vector of starting quantities for the non-linear solver.</p>
</dd>
<dt><code>productsPre</code></dt><dd><p>An n x k logical matrix qhose elements are TRUE if a plant produces a product pre-merger and FALSE otherwise.</p>
</dd>
<dt><code>productsPost</code></dt><dd><p>An n x k logical matrix qhose elements are TRUE if a plant produces a product post-merger and FALSE otherwise.</p>
</dd>
<dt><code>capacitiesPre</code></dt><dd><p>A length-n logical vector whose elements equal to pre-merger plant capacities. Infinite values are allowed.</p>
</dd>
<dt><code>capacitiesPost</code></dt><dd><p>A length-n logical vector whose elements equal to post-merger plant capacities. Infinite values are allowed.</p>
</dd>
<dt><code>demand</code></dt><dd><p>A length k character vector specifying whether product demand is linear (&quot;linear&quot;) or log-linear (&quot;log&quot;).</p>
</dd>
<dt><code>cost</code></dt><dd><p>A length k character vector equal to &quot;linear&quot; if a plant's marginal cost curve is assumed to be linear
or &quot;constant&quot; if a plant's marginal curve is assumed to be constant.
Returns an error if a multi-plant firm with constant marginal costs does not have capacity constraints.</p>
</dd>
<dt><code>mktElast</code></dt><dd><p>A length k vector of market elasticities.</p>
</dd>
<dt><code>dmcfunPre</code></dt><dd><p>A length n list whose elements equal a function that calculates the derivative of a
plant's pre-merger marginal cost with respect to that plant's output. (Stackelberg only)</p>
</dd>
<dt><code>dmcfunPost</code></dt><dd><p>A length n list whose elements equal a function that calculates the derivative of a
plant's post-merger marginal cost with respect to that plant's output. (Stackelberg only)</p>
</dd>
<dt><code>isLeaderPre</code></dt><dd><p>An n x k logical matrix qhose elements are TRUE if a plant produces a product pre-merger and FALSE otherwise. (Stackelberg only)</p>
</dd>
<dt><code>isLeaderPost</code></dt><dd><p>An n x k logical matrix qhose elements are TRUE if a plant produces a product post-merger and FALSE otherwise. #'@slot dmcfunPre A length n list whose elements equal a function that calculates the derivative of a
plant's pre-merger marginal cost with respect to that plant's output. (Stackelberg only)</p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>For Cournot, objects can be created by calls of the form <code>new("Cournot", ...)</code>.
</p>
<p>For Stackelberg, objects can be created by calls of the form <code>new("Stackelberg", ...)</code>.
</p>


<h3>Extends</h3>

<p>Cournot:
Class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, directly.
Class <code><a href="#topic+Antitrust-class">Antitrust</a></code>, by class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, distance 2.
</p>
<p>Stackelberg:
Class <code><a href="#topic+Cournot-class">Cournot</a></code>, directly.
Class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, by class <code><a href="#topic+Cournot-class">Cournot</a></code>, distance 2.
Class <code><a href="#topic+Antitrust-class">Antitrust</a></code>, by class <code><a href="#topic+Bertrand-class">Bertrand</a></code>, distance 3.
</p>


<h3>Author(s)</h3>

<p>Charles Taragin <a href="mailto:ctaragin+antitrustr@gmail.com">ctaragin+antitrustr@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("Cournot")           # get a detailed description of the class
showClass("Stackelberg")           # get a detailed description of the class
</code></pre>

<hr>
<h2 id='Cournot-Functions'>Multi-product Cournot/Stackelberg Calibration and Merger Simulation With Linear or Log-Linear Demand</h2><span id='topic+Cournot-Functions'></span><span id='topic+cournot'></span><span id='topic+Cournot'></span><span id='topic+stackelberg'></span><span id='topic+Stackelberg'></span>

<h3>Description</h3>

<p>Calibrates consumer demand for multiple products using either a
linear or log-linear demand system and then simulates the
prices effect of a merger between two multi-plant firms
under the assumption that all firms in the market are
playing either a Cournot or Stackelberg quantity setting game.
</p>
<p>Let k denote the number of products and n denote the number of plants below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cournot(
  prices,
  quantities,
  margins = matrix(NA_real_, nrow(quantities), ncol(quantities)),
  demand = rep("linear", length(prices)),
  cost = rep("linear", nrow(quantities)),
  mcfunPre = list(),
  mcfunPost = mcfunPre,
  vcfunPre = list(),
  vcfunPost = vcfunPre,
  capacitiesPre = rep(Inf, nrow(quantities)),
  capacitiesPost = capacitiesPre,
  productsPre = !is.na(quantities),
  productsPost = productsPre,
  ownerPre,
  ownerPost,
  mktElast = rep(NA_real_, length(prices)),
  mcDelta = rep(0, nrow(quantities)),
  quantityStart = as.vector(quantities),
  control.slopes,
  control.equ,
  labels,
  ...
)

stackelberg(
  prices,
  quantities,
  margins,
  demand = rep("linear", length(prices)),
  cost = rep("linear", nrow(quantities)),
  isLeaderPre = matrix(FALSE, ncol = ncol(quantities), nrow = nrow(quantities)),
  isLeaderPost = isLeaderPre,
  mcfunPre = list(),
  mcfunPost = mcfunPre,
  vcfunPre = list(),
  vcfunPost = vcfunPre,
  dmcfunPre = list(),
  dmcfunPost = dmcfunPre,
  capacitiesPre = rep(Inf, nrow(quantities)),
  capacitiesPost = capacitiesPre,
  productsPre = !is.na(quantities),
  productsPost = productsPre,
  ownerPre,
  ownerPost,
  mcDelta = rep(0, nrow(quantities)),
  quantityStart = as.vector(quantities),
  control.slopes,
  control.equ,
  labels,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cournot-Functions_+3A_prices">prices</code></td>
<td>
<p>A length k vector product prices.</p>
</td></tr>
<tr><td><code id="Cournot-Functions_+3A_quantities">quantities</code></td>
<td>
<p>An n x k matrix of product quantities.
All quantities must either be positive, or if the product is not produced by a plant, NA.</p>
</td></tr>
<tr><td><code id="Cournot-Functions_+3A_margins">margins</code></td>
<td>
<p>An n x k  matrix of product margins. All margins must
be either be between 0 and 1, or NA.</p>
</td></tr>
<tr><td><code id="Cournot-Functions_+3A_demand">demand</code></td>
<td>
<p>A length k character vector equal to &quot;linear&quot; if a product's
demand curve is assumed to be linear or &quot;log&quot; if a product's demand curve
is assumed to be log-linear.</p>
</td></tr>
<tr><td><code id="Cournot-Functions_+3A_cost">cost</code></td>
<td>
<p>A length n character vector equal to &quot;linear&quot; if a plant's
marginal cost curve is assumed to be linear or &quot;constant&quot; if a plant's marginal curve
is assumed to be constant. Returns an error if a multi-plant firm with constant marginal costs
does not have capacity constraints.</p>
</td></tr>
<tr><td><code id="Cournot-Functions_+3A_mcfunpre">mcfunPre</code></td>
<td>
<p>a length n list of functions that calculate a plant's
pre-merger marginal cost. If empty (the default), assumes  quadratic costs.</p>
</td></tr>
<tr><td><code id="Cournot-Functions_+3A_mcfunpost">mcfunPost</code></td>
<td>
<p>a length n list of functions that calculate a plant's
post-merger marginal cost. If empty (the default), equals &lsquo;mcfunPre&rsquo;</p>
</td></tr>
<tr><td><code id="Cournot-Functions_+3A_vcfunpre">vcfunPre</code></td>
<td>
<p>a length n list of functions that calculate a plant's
pre-merger variable cost. If empty (the default), assumes quadratic variable costs.</p>
</td></tr>
<tr><td><code id="Cournot-Functions_+3A_vcfunpost">vcfunPost</code></td>
<td>
<p>a length n list of functions that calculate a plant's
post-merger variable cost. If empty (the default), equals &lsquo;vcfunPre&rsquo;</p>
</td></tr>
<tr><td><code id="Cournot-Functions_+3A_capacitiespre">capacitiesPre</code></td>
<td>
<p>A length n numeric vector of pre-merger
plant capacities. Default is Inf.</p>
</td></tr>
<tr><td><code id="Cournot-Functions_+3A_capacitiespost">capacitiesPost</code></td>
<td>
<p>A length n numeric vector of post-merger
plant capacities. Default &lsquo;capacitiesPre&rsquo;.</p>
</td></tr>
<tr><td><code id="Cournot-Functions_+3A_productspre">productsPre</code></td>
<td>
<p>An n x k  matrix that equals TRUE if pre-merger,
a plant produces a product. Default is TRUE if 'quantities' is not NA.</p>
</td></tr>
<tr><td><code id="Cournot-Functions_+3A_productspost">productsPost</code></td>
<td>
<p>An n x k  matrix that equals TRUE if post-merger,
a plant produces a product. Default equals &lsquo;productsPre&rsquo;.</p>
</td></tr>
<tr><td><code id="Cournot-Functions_+3A_ownerpre">ownerPre</code></td>
<td>
<p>EITHER a vector of length n whose values
indicate which plants are commonly owned pre-merger OR
an n x n matrix of pre-merger ownership shares.</p>
</td></tr>
<tr><td><code id="Cournot-Functions_+3A_ownerpost">ownerPost</code></td>
<td>
<p>EITHER a vector of length n whose values
indicate which plants will be commonly owned after the merger OR
an n x n matrix of post-merger ownership shares.</p>
</td></tr>
<tr><td><code id="Cournot-Functions_+3A_mktelast">mktElast</code></td>
<td>
<p>A length k vector of product elasticities. Default is a length k vector of NAs</p>
</td></tr>
<tr><td><code id="Cournot-Functions_+3A_mcdelta">mcDelta</code></td>
<td>
<p>A length n vector where each element equals the
proportional change in a firm's marginal costs due to
the merger. Default is 0, which assumes that the merger does not
affect any products' marginal cost.</p>
</td></tr>
<tr><td><code id="Cournot-Functions_+3A_quantitystart">quantityStart</code></td>
<td>
<p>A length k vector of quantities used as the initial guess
in the nonlinear equation solver. Default is &lsquo;quantities&rsquo;.</p>
</td></tr>
<tr><td><code id="Cournot-Functions_+3A_control.slopes">control.slopes</code></td>
<td>
<p>A list of  <code><a href="stats.html#topic+optim">optim</a></code>  control parameters
passed to the calibration routine optimizer
(typically the <code>calcSlopes</code> method).</p>
</td></tr>
<tr><td><code id="Cournot-Functions_+3A_control.equ">control.equ</code></td>
<td>
<p>A list of  <code><a href="BB.html#topic+BBsolve">BBsolve</a></code> control parameters
passed to the non-linear equation solver
(typically the <code>calcQuantities</code> method).</p>
</td></tr>
<tr><td><code id="Cournot-Functions_+3A_labels">labels</code></td>
<td>
<p>A list with 2 elements. The first element is a
vector of firm names, while the second element is a vector of products names.
Default is &lsquo;O1:On&rsquo;, and &lsquo;P1:Pk&rsquo;.</p>
</td></tr>
<tr><td><code id="Cournot-Functions_+3A_...">...</code></td>
<td>
<p>Additional options to feed to the solver. See below.</p>
</td></tr>
<tr><td><code id="Cournot-Functions_+3A_isleaderpre">isLeaderPre</code></td>
<td>
<p>An n x k logical matrix equal to TRUE if a firm is
a &quot;leader&quot; pre-merger for a particular product and FALSE otherwise.
Default is FALSE, which is equivalent to <code>cournot</code>.</p>
</td></tr>
<tr><td><code id="Cournot-Functions_+3A_isleaderpost">isLeaderPost</code></td>
<td>
<p>An n x k logical matrix equal to TRUE if a firm
is a &quot;leader&quot; pre-merger for a particular product and FALSE otherwise.
Default is FALSE, which is equivalent to <code>cournot</code>.</p>
</td></tr>
<tr><td><code id="Cournot-Functions_+3A_dmcfunpre">dmcfunPre</code></td>
<td>
<p>a length n list of functions that calculate the derivative
of a plant's pre-merger marginal cost. If empty (the default),
assumes  quadratic variable costs.</p>
</td></tr>
<tr><td><code id="Cournot-Functions_+3A_dmcfunpost">dmcfunPost</code></td>
<td>
<p>a length n list of functions that calculate the derivative
of a plant's post-merger marginal cost. If empty (the default), equals &lsquo;mcfunPre&rsquo;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using price, and quantity, information for all products
in each market, as well as margin information for at least
one products in each market, <code>cournot</code> is able to
recover the slopes and intercepts of either a Linear or Log-linear demand
system as well as the cost parameters (see below for further details). 
These parameters are then used to simulate the price
effects of a merger between
two firms under the assumption that the firms are playing a
homogeneous products simultaneous quantity setting game.
</p>
<p><code>stackelberg</code>, is similar to <code>cournot</code>, except that for a given product,
firms are either &quot;leaders&quot; or &quot;followers&quot;. leaders gain a first mover advantage
over followers, which allows the leaders to anticipate how changes to their output
will effect the follower's output decisions. Firms can be the leader for
some products but the follower in others.
</p>
<p>&lsquo;mcfunPre&rsquo; and &lsquo;mcfunPost&rsquo; are length n lists whose elements are &lsquo;R&rsquo; functions 
that return a firm's marginal cost. The first argument of each function should be total firm quantities.
By default, each firm is assumed to have quadratic costs with a firm-specific parameter calibrated from a firm's margin.
&lsquo;vcfunPre&rsquo; and &lsquo;vcfunPost&rsquo; are similarly defined. 
&lsquo;dmcfunPre&rsquo; and &lsquo;dmcfunPost&rsquo; are the changes in marginal cost and are only required for <code>stackelberg</code>.
</p>
<p>&lsquo;ownerPre&rsquo; and &lsquo;ownerPost&rsquo; values will typically be equal to either 0
(element [i,j] is not commonly owned) or 1 (element [i,j] is commonly
owned), though these matrices may take on any value between 0 and 1 to
account for partial ownership.
</p>
<p>Under linear demand and linear marginal costs, an analytic solution to the Cournot quantity game
exists. However, this solution can at times produce negative
equilibrium quantities. To accommodate this issue, <code>cournot</code>
uses <code><a href="BB.html#topic+BBsolve">BBsolve</a></code>  to
find equilibrium quantities subject to a non-negativity constraint. <code>...</code> may
be used to change the default options for <code><a href="BB.html#topic+BBsolve">BBsolve</a></code>.
</p>


<h3>Value</h3>

<p><code>cournot</code> returns an instance of class <code><a href="#topic+Cournot-class">Cournot</a></code>.
<code>stackelberg</code> returns an instance of class <code><a href="#topic+Stackelberg-class">Stackelberg</a></code>.
</p>


<h3>Author(s)</h3>

<p>Charles Taragin <a href="mailto:ctaragin+antitrustr@gmail.com">ctaragin+antitrustr@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate a Cournot merger between two single-plant firms
## producing a single product in a
## 5-firm market with linear demand and quadratic costs



n &lt;- 5 #number of firms in market pre-merger
cap &lt;- rnorm(n,mean = .5, sd = .1)
int &lt;- 10
slope &lt;- -.25

B.pre.c = matrix(slope,nrow=n,ncol=n)
diag(B.pre.c) = 2* diag(B.pre.c) - 1/cap
quantity.pre.c = rowSums(solve(B.pre.c) * -int)
price.pre.c = int + slope * sum(quantity.pre.c)
mc.pre.c = quantity.pre.c/cap
vc.pre.c = quantity.pre.c^2/(2*cap)
margin.pre.c = 1 - mc.pre.c/price.pre.c
ps.pre.c = price.pre.c*quantity.pre.c - vc.pre.c

mktQuant.pre.c = sum(quantity.pre.c)

## suppose firm 1 acquires firm 2
## This model has a closed form solution
B.post.c = B.pre.c
B.post.c[1,2] = 2*B.post.c[1,2]
B.post.c[2,1] = 2*B.post.c[2,1]

quantity.post.c = rowSums(solve(B.post.c) * -int)
price.post.c = int + slope * sum(quantity.post.c)
mc.post.c = quantity.post.c/cap
vc.post.c = quantity.post.c^2/(2*cap)
margin.post.c = 1 - mc.post.c/price.post.c
ps.post.c = price.post.c*quantity.post.c - vc.post.c

mktQuant.post.c = sum(quantity.post.c, na.rm=TRUE)

#check if merger is profitable for merging parties
isprofitable.c = ps.post.c - ps.pre.c
isprofitable.c= sum(isprofitable.c[1:2]) &gt; 0


#prep inputs for Cournot
owner.pre &lt;- diag(n)
owner.post &lt;- owner.pre
owner.post[1,2] &lt;- owner.post[2,1] &lt;- 1



result.c &lt;- cournot(prices = price.pre.c,quantities = as.matrix(quantity.pre.c),
                    margins=as.matrix(margin.pre.c),
                    ownerPre=owner.pre,ownerPost=owner.post)

print(result.c)           # return predicted price change
summary(result.c)         # summarize merger simulation

## check if 'cournot' yields the same result as closed-form solution
#print(all.equal(sum(result.c@quantityPre) , mktQuant.pre.c))
#print(all.equal(sum(result.c@quantityPost) , mktQuant.post.c))




## Simulate a Stackelberg merger between two single-plant firms
## producing a single product in a
## 5-firm market with linear demand and quadratic costs.
## Allow both merging parties to be followers pre-merger,
## but assume that they become leaders post-merger.
## Finally, assume that pre-merger, there is a single leader who ## remains a leader post-merger
## Note: This example uses setup from the above Cournot example

isLeader.pre = matrix(rep(FALSE,n), ncol=1)
isLeader.pre[n,] = TRUE
isLeader.post = isLeader.pre
isLeader.post[1:2,] = TRUE

passthru.pre = matrix(-slope^2/(2*slope - 1/cap))
passthru.post = passthru.pre
passthru.pre[isLeader.pre] = 0
passthru.post[isLeader.post] = 0

B.pre.s = matrix(slope,nrow=n,ncol=n)
diag(B.pre.s) = 2* diag(B.pre.s) - 1/cap
diag(B.pre.s)[n] = diag(B.pre.s)[n] + sum(passthru.pre)

quantity.pre.s = rowSums(solve(B.pre.s) * ( -int))
price.pre.s = int + slope * sum(quantity.pre.s)
mc.pre.s = quantity.pre.s/cap
vc.pre.s = quantity.pre.s^2/(2*cap)
margin.pre.s = 1 - mc.pre.s/price.pre.s
ps.pre.s = price.pre.s*quantity.pre.s - vc.pre.s

mktQuant.pre.s = sum(quantity.pre.s)

## suppose firm 1 acquires firm 2
## This model has a closed form solution
B.post.s = matrix(slope,nrow=n,ncol=n)
diag(B.post.s) = 2* diag(B.post.s) - 1/cap
B.post.s[1,2] = 2*B.post.s[1,2]
B.post.s[1,1:2] = B.post.s[1,1:2]  + sum(passthru.post)
B.post.s[2,1] = 2*B.post.s[2,1]
B.post.s[2,1:2] = B.post.s[2,1:2]  + sum(passthru.post)
diag(B.post.s)[n] = diag(B.post.s)[n]  +  sum(passthru.post)

quantity.post.s = rowSums(solve(B.post.s) * as.vector( -int ) )
price.post.s = int + slope * sum(quantity.post.s)
mc.post.s = quantity.post.s/cap
vc.post.s = quantity.post.s^2/(2*cap)
margin.post.s = 1 - mc.post.s/price.post.s
ps.post.s = price.post.s*quantity.post.s - vc.post.s

mktQuant.post.s = sum(quantity.post.s, na.rm=TRUE)

#check if merger is profitable for merging parties
isprofitable.s = ps.post.s - ps.pre.s
isprofitable.s = sum(isprofitable.s[1:2]) &gt; 0


#prep inputs for Stackelberg
owner.pre &lt;- diag(n)
owner.post &lt;- owner.pre
owner.post[1,2] &lt;- owner.post[2,1] &lt;- 1



result.s &lt;- stackelberg(prices = price.pre.s,quantities = as.matrix(quantity.pre.s),
                        margins=as.matrix(margin.pre.s),ownerPre=owner.pre,
                        ownerPost=owner.post,
                        isLeaderPre = isLeader.pre, isLeaderPost = isLeader.post)

print(result.s)           # return predicted price change
summary(result.s)         # summarize merger simulation

## check if 'stackelberg' yields the same result as closed-form solution
#print(all.equal(sum(result.s@quantityPre) , mktQuant.pre.s))
#print(all.equal(sum(result.s@quantityPost) , mktQuant.post.s))

</code></pre>

<hr>
<h2 id='CV-Methods'>Methods For Calculating Compensating Variation (CV)</h2><span id='topic+CV-Methods'></span><span id='topic+CV-methods'></span><span id='topic+CV'></span><span id='topic+CV+2CANY-method'></span><span id='topic+CV+2CAIDS-method'></span><span id='topic+CV+2CCES-method'></span><span id='topic+CV+2CCESNests-method'></span><span id='topic+CV+2CLinear-method'></span><span id='topic+CV+2CLogLin-method'></span><span id='topic+CV+2CLogit-method'></span><span id='topic+CV+2CLogitNests-method'></span><span id='topic+CV+2CAuction2ndLogit-method'></span><span id='topic+CV+2CVertBargBertLogit-method'></span><span id='topic+CV+2CVertBarg2ndLogit-method'></span><span id='topic+CV+2CCournot-method'></span>

<h3>Description</h3>

<p>Calculate the amount of money a consumer would need to
be paid to be just as well off as they were before the merger.
</p>
<p>All the information needed to
compute CV is already available within the Logit, Nested Logit CES and Nested CES classes.
In CES and Nested CES, CV cannot be calculated if the outside share cannot be inferred.
</p>
<p>For AIDS, if the  &lsquo;insideSize&rsquo;  slot to the &ldquo;AIDS&rdquo; class equals NA, CV is calculated as a percentage of
total expenditure (revenues) on products included in the simulation. Otherwise CV is calculated in terms of dollars.
Pre-merger prices for all products in the market must be supplied in order for CV to be calculated.
</p>
<p>For Linear and LogLin, although no additional information is needed to calculate CV for
either the &ldquo;Linear&rdquo; or &ldquo;LogLin&rdquo; classes, The CV method will fail if
the appropriate restrictions on the demand parameters have not been imposed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Cournot'
CV(object)

## S4 method for signature 'Linear'
CV(object)

## S4 method for signature 'Logit'
CV(object)

## S4 method for signature 'LogLin'
CV(object)

## S4 method for signature 'AIDS'
CV(object)

## S4 method for signature 'LogitNests'
CV(object)

## S4 method for signature 'Auction2ndLogit'
CV(object)

## S4 method for signature 'VertBargBertLogit'
CV(object)

## S4 method for signature 'VertBarg2ndLogit'
CV(object)

## S4 method for signature 'CES'
CV(object)

## S4 method for signature 'CESNests'
CV(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CV-Methods_+3A_object">object</code></td>
<td>
<p>An instance of one of the classes listed above.</p>
</td></tr>
</table>

<hr>
<h2 id='defineMarketTools-methods'>Methods For Implementing The Hypothetical Monopolist Test</h2><span id='topic+defineMarketTools-methods'></span><span id='topic+HypoMonTest'></span><span id='topic+HypoMonTest+2CANY-method'></span><span id='topic+HypoMonTest+2CBertrand-method'></span><span id='topic+calcPricesHypoMon'></span><span id='topic+calcPricesHypoMon+2CANY-method'></span><span id='topic+calcPricesHypoMon+2CAIDS-method'></span><span id='topic+calcPricesHypoMon+2CLinear-method'></span><span id='topic+calcPricesHypoMon+2CLogLin-method'></span><span id='topic+calcPricesHypoMon+2CLogit-method'></span><span id='topic+calcPricesHypoMon+2CLogitCap-method'></span><span id='topic+calcPricesHypoMon+2CAuction2ndLogit-method'></span><span id='topic+calcPricesHypoMon+2CCournot-method'></span><span id='topic+calcPriceDeltaHypoMon'></span><span id='topic+calcPriceDeltaHypoMon+2CANY-method'></span><span id='topic+calcPriceDeltaHypoMon+2CAIDS-method'></span><span id='topic+calcPriceDeltaHypoMon+2CBertrand-method'></span><span id='topic+calcPriceDeltaHypoMon+2CCournot-method'></span><span id='topic+diversionHypoMon'></span><span id='topic+diversionHypoMon+2CANY-method'></span><span id='topic+diversionHypoMon+2CAIDS-method'></span><span id='topic+diversionHypoMon+2CBertrand-method'></span><span id='topic+HypoMonTest+2CCournot-method'></span>

<h3>Description</h3>

<p>An Implementation of the Hypothetical Monopolist Test described in the 2010 Horizontal Merger Guidelines.
</p>
<p><code><a href="#topic+HypoMonTest">HypoMonTest</a></code> implements the Hypothetical Monopolist Test for a given &lsquo;ssnip&rsquo;.
</p>
<p><code>calcPricesHypoMon</code> computes prices for a subset of firms under the control of a hypothetical monopolist
under the specified demand function or auction.
</p>
<p><code><a href="#topic+diversionHypoMon">diversionHypoMon</a></code> calculates the matrix of revenue diversions between all products included in the
merger simulation, <em>irrespective of whether or not they are also included in &lsquo;prodIndex&rsquo;</em>.
</p>
<p><code><a href="#topic+calcPriceDeltaHypoMon">calcPriceDeltaHypoMon</a></code> computes the proportional difference in product prices between the
prices of products in &lsquo;prodIndex&rsquo; (i.e. prices set by the
Hypothetical Monopolist) and prices set in the pre-merger equilibrium.
&lsquo;...&rsquo; may be used to pass arguments to the optimizer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Bertrand'
HypoMonTest(object, prodIndex, ssnip = 0.05, ...)

## S4 method for signature 'Cournot'
HypoMonTest(object, plantIndex, prodIndex, ssnip = 0.05, ...)

## S4 method for signature 'Cournot'
calcPricesHypoMon(object, plantIndex, prodIndex)

## S4 method for signature 'Linear'
calcPricesHypoMon(object, prodIndex)

## S4 method for signature 'Logit'
calcPricesHypoMon(object, prodIndex)

## S4 method for signature 'LogLin'
calcPricesHypoMon(object, prodIndex)

## S4 method for signature 'AIDS'
calcPricesHypoMon(object, prodIndex, ...)

## S4 method for signature 'LogitCap'
calcPricesHypoMon(object, prodIndex, ...)

## S4 method for signature 'Auction2ndLogit'
calcPricesHypoMon(object, prodIndex)

## S4 method for signature 'Bertrand'
diversionHypoMon(object, prodIndex, ...)

## S4 method for signature 'AIDS'
diversionHypoMon(object)

## S4 method for signature 'Bertrand'
calcPriceDeltaHypoMon(object, prodIndex, ...)

## S4 method for signature 'Cournot'
calcPriceDeltaHypoMon(object, prodIndex, plantIndex, ...)

## S4 method for signature 'AIDS'
calcPriceDeltaHypoMon(object, prodIndex, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defineMarketTools-methods_+3A_object">object</code></td>
<td>
<p>An instance of one of the classes listed above.</p>
</td></tr>
<tr><td><code id="defineMarketTools-methods_+3A_prodindex">prodIndex</code></td>
<td>
<p>A vector of product indices that are to be placed under the control of the Hypothetical Monopolist.</p>
</td></tr>
<tr><td><code id="defineMarketTools-methods_+3A_ssnip">ssnip</code></td>
<td>
<p>A number between 0 and 1 that equals the threshold for a &ldquo;Small but Significant and
Non-transitory Increase in Price&rdquo; (SSNIP). Default is .05, or 5%.</p>
</td></tr>
<tr><td><code id="defineMarketTools-methods_+3A_...">...</code></td>
<td>
<p>Pass options to the optimizer used to solve for equilibrium prices.</p>
</td></tr>
<tr><td><code id="defineMarketTools-methods_+3A_plantindex">plantIndex</code></td>
<td>
<p>A vector of plant indices that are to be placed under the control of the Hypothetical Monopolist (Cournot).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let k denote the number of products produced by all firms playing the Bertrand pricing game above.
</p>
<p><code>HypoMonTest</code> is an implementation of the Hypothetical Monopolist Test
on the products indexed by &lsquo;prodIndex&rsquo; for a &lsquo;ssnip&rsquo;. The
Hypothetical Monopolist Test determines whether a profit-maximizing
Hypothetical Monopolist who controls the products indexed by
&lsquo;prodIndex&rsquo; would increase the price of at least one of the merging parties' products in &lsquo;prodIndex&rsquo; by a
small, significant, and non-transitory amount (i.e. impose a SSNIP).
</p>
<p><code>calcPriceDeltaHypoMon</code> calculates the price changes relative to (predicted) pre-merger prices that a
Hypothetical Monopolist would impose on the products indexed by &lsquo;prodIndex&rsquo;, holding the prices of products not
controlled by the Hypothetical Monopolist fixed at pre-merger levels. With the exception of &lsquo;AIDS&rsquo;, the
<code>calcPriceDeltaHypoMon</code> for all the classes listed above calls <code>calcPricesHypoMon</code> to compute price
levels. <code>calcPriceDeltaHypoMon</code> is in turn called by <code>HypoMonTest</code>.
</p>
<p><code>diversionHypoMon</code> calculates the matrix of revenue diversions between all products included in the merger simulation,
<em>irrespective</em> of whether or not they are also included in
&lsquo;prodIndex&rsquo;. This matrix is useful for diagnosing whether or not a
product not included in &lsquo;prodIndex&rsquo; may have a higher revenue diversion
either to or from a product included in &lsquo;prodIndex&rsquo;. Note that the &lsquo;AIDS&rsquo;
<code>diversionHypoMon</code> method does not contain the &lsquo;prodIndex&rsquo;
argument, as AIDS revenue diversions are only a function of demand parameters.
</p>


<h3>Value</h3>

<p><code>HypoMonTest</code> returns TRUE if a profit-maximizing Hypothetical Monopolist who controls the products indexed by
&lsquo;prodIndex&rsquo; would increase the price of at least one of the merging
parties' products in &lsquo;prodIndex&rsquo; by a &lsquo;ssnip&rsquo;, and
FALSE otherwise. <code>HypoMonTest</code> returns an error if &lsquo;prodIndex&rsquo;
does not contain at least one of the merging parties products.
</p>
<p><code>calcPriceDeltaHypoMon</code> returns a vector of proportional price changes for
all products placed under the control of the Hypothetical
Monopolist (i.e. all products indexed by &lsquo;prodIndex&rsquo;).
</p>
<p><code>calcPricesHypoMon</code> is identical, but for price levels.
</p>
<p><code>diversionHypoMon</code> returns a k x k matrix of diversions,
where element i,j is the diversion from product i to product j.
</p>


<h3>References</h3>

<p>U.S. Department of Justice and Federal Trade Commission,
<em>Horizontal Merger Guidelines</em>. Washington DC: U.S. Department of Justice, 2010.
<a href="https://www.justice.gov/atr/horizontal-merger-guidelines-08192010">https://www.justice.gov/atr/horizontal-merger-guidelines-08192010</a> (accessed May 5, 2021).
</p>

<hr>
<h2 id='Diagnostics-Methods'>Methods for Calculating Diagnostics</h2><span id='topic+Diagnostics-Methods'></span><span id='topic+calcDiagnostics'></span><span id='topic+calcDiagnostics+2CANY-method'></span><span id='topic+calcDiagnostics+2CBertrand-method'></span><span id='topic+calcDiagnostics+2CCournot-method'></span><span id='topic+calcDiagnostics+2CVertBargBertLogit-method'></span>

<h3>Description</h3>

<p>Computes the percentage difference between predicted and observed pre-merger prices, shares,
margins and market elasticities (if supplied) . &lsquo;labels&rsquo; is used to specify row labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Bertrand'
calcDiagnostics(object, labels = object@labels)

## S4 method for signature 'VertBargBertLogit'
calcDiagnostics(object, labels = object@down@labels)

## S4 method for signature 'Cournot'
calcDiagnostics(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Diagnostics-Methods_+3A_object">object</code></td>
<td>
<p>An instance of one of the classes listed above.</p>
</td></tr>
<tr><td><code id="Diagnostics-Methods_+3A_labels">labels</code></td>
<td>
<p>A length-k vector of product labels. Default is object@labels.</p>
</td></tr>
</table>

<hr>
<h2 id='Diversion-Methods'>Methods For Calculating Diversion</h2><span id='topic+Diversion-Methods'></span><span id='topic+diversion-methods'></span><span id='topic+diversion'></span><span id='topic+diversion+2CANY-method'></span><span id='topic+diversion+2CAIDS-method'></span><span id='topic+diversion+2CBertrand-method'></span><span id='topic+diversion+2CVertBargBertLogit-method'></span>

<h3>Description</h3>

<p>Calculate the diversion matrix between any two products in the market.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Bertrand'
diversion(object, preMerger = TRUE, revenue = FALSE)

## S4 method for signature 'AIDS'
diversion(object, preMerger = TRUE, revenue = TRUE)

## S4 method for signature 'VertBargBertLogit'
diversion(object, preMerger = TRUE, revenue = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Diversion-Methods_+3A_object">object</code></td>
<td>
<p>An instance of one of the classes listed above.</p>
</td></tr>
<tr><td><code id="Diversion-Methods_+3A_premerger">preMerger</code></td>
<td>
<p>If TRUE, calculates pre-merger price elasticities. If
FALSE, calculates post-merger price elasticities. Default is TRUE.</p>
</td></tr>
<tr><td><code id="Diversion-Methods_+3A_revenue">revenue</code></td>
<td>
<p>If TRUE, calculates revenue diversion. If
FALSE, calculates quantity diversion. Default is TRUE for &lsquo;Bertrand&rsquo;
and FALSE for &lsquo;AIDS&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For Bertrand, when &lsquo;revenue&rsquo; is FALSE (the default),
this method uses the results from the merger calibration and
simulation to compute the <em>quantity</em> diversion matrix between any two products
in the market. Element i,j of this matrix is the quantity diversion from
product i to product j, or the
proportion of product i's sales that leave (go to) i for (from) j due
to a increase (decrease) in i's price. Mathematically, quantity diversion is
<code class="reqn">\frac{-\epsilon_{ji}share_j}{\epsilon_{ii}share_i}</code>,
where <code class="reqn">\epsilon_{ij}</code> is the cross-price elasticity from i to j.
</p>
<p>When &lsquo;revenue&rsquo; is TRUE, this method computes the revenue diversion
matrix between any two products in the market. Element i,j of this matrix is the revenue diversion from
product i to product j, or the
proportion of product i's revenues that leave (go to) i for (from) j due
to a increase (decrease) in i's price. Mathematically, revenue diversion is
<code class="reqn">-\frac{\epsilon_{ji}(\epsilon_{jj}-1)r_j}{\epsilon_{jj}(\epsilon_{ii}-1)r_j}</code>
where <code class="reqn">r_i</code> is the revenue share of product i.
</p>
<p>When &lsquo;preMerger&rsquo; is TRUE, diversions are
calculated at pre-merger equilibrium prices, and when &lsquo;preMerger&rsquo; is FALSE, they
are calculated at post-merger equilibrium prices.
</p>
<p>For AIDS, when &lsquo;revenue&rsquo; is TRUE (the default),
this method computes the <em>revenue</em> diversion matrix between any two
products in the market. For AIDS, the revenue diversion from i to j is
<code class="reqn">\frac{\beta_{ji}}{\beta_ij}</code>, where <code class="reqn">\beta_{ij}</code> is the
percentage change in product i's revenue due to a change in j's price.
</p>
<p>When &lsquo;revenue&rsquo; is FALSE, this <code>callNextMethod</code> is invoked. Will
yield a matrix of NAs if the user did not supply prices.
</p>
<p>When &lsquo;preMerger&rsquo; is TRUE, diversions are
calculated at pre-merger equilibrium prices, and when &lsquo;preMerger&rsquo; is FALSE, they
are calculated at post-merger equilibrium prices.
</p>


<h3>Value</h3>

<p>returns a k x k matrix of diversion ratios, where the i,jth
element is the diversion from i to j.
</p>

<hr>
<h2 id='Elast-Methods'>Methods For Calculating Own and Cross-Price Elasticities</h2><span id='topic+Elast-Methods'></span><span id='topic+elast-methods'></span><span id='topic+elast'></span><span id='topic+elast+2CANY-method'></span><span id='topic+elast+2CAIDS-method'></span><span id='topic+elast+2CCES-method'></span><span id='topic+elast+2CCESNests-method'></span><span id='topic+elast+2CLinear-method'></span><span id='topic+elast+2CLogLin-method'></span><span id='topic+elast+2CLogit-method'></span><span id='topic+elast+2CLogitNests-method'></span><span id='topic+elast+2CCournot-method'></span><span id='topic+elast+2CVertBargBertLogit-method'></span>

<h3>Description</h3>

<p>Calculate the own and cross-price elasticity between any two products in the market.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Cournot'
elast(object, preMerger = TRUE, market = FALSE)

## S4 method for signature 'Linear'
elast(object, preMerger = TRUE, market = FALSE)

## S4 method for signature 'Logit'
elast(object, preMerger = TRUE, market = FALSE)

## S4 method for signature 'LogLin'
elast(object, preMerger = TRUE, market = FALSE)

## S4 method for signature 'AIDS'
elast(object, preMerger = TRUE, market = FALSE)

## S4 method for signature 'LogitNests'
elast(object, preMerger = TRUE, market = FALSE)

## S4 method for signature 'CES'
elast(object, preMerger = TRUE, market = FALSE)

## S4 method for signature 'CESNests'
elast(object, preMerger = TRUE, market = FALSE)

## S4 method for signature 'VertBargBertLogit'
elast(object, preMerger = TRUE, market = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Elast-Methods_+3A_object">object</code></td>
<td>
<p>An instance of one of the classes listed above.</p>
</td></tr>
<tr><td><code id="Elast-Methods_+3A_premerger">preMerger</code></td>
<td>
<p>If TRUE, calculates pre-merger price elasticities. If
FALSE, calculates post-merger price elasticities. Default is TRUE.</p>
</td></tr>
<tr><td><code id="Elast-Methods_+3A_market">market</code></td>
<td>
<p>If TRUE, calculates the market (aggregate) elasticity. If
FALSE, calculates matrix of own- and cross-price elasticities. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When &lsquo;market&rsquo; is FALSE, this method computes the matrix
of own and cross-price elasticities. Element i,j of this matrix is
the percentage change in the demand for good i from a small change in
the price of good j. When &lsquo;market&rsquo; is TRUE, this method computes the
market (aggregate) elasticities using share-weighted prices.
</p>
<p>When &lsquo;preMerger&rsquo; is TRUE, elasticities are
calculated at pre-merger equilibrium prices and shares, and when &lsquo;preMerger&rsquo; is FALSE, they
are calculated at post-merger equilibrium prices and shares.
</p>


<h3>Value</h3>

<p>returns a k x k matrix of own- and cross-price elasticities,
where k is the number of products in the market.
</p>

<hr>
<h2 id='HHI-Functions'>Herfindahl-Hirschman Index</h2><span id='topic+HHI-Functions'></span><span id='topic+HHI'></span>

<h3>Description</h3>

<p>Calculate the Herfindahl-Hirschman Index with arbitrary
ownership and control.
</p>
<p>Let k denote the number of products produced by the merging parties below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HHI(shares, owner = diag(length(shares)), control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HHI-Functions_+3A_shares">shares</code></td>
<td>
<p>A length-k vector of product quantity shares.</p>
</td></tr>
<tr><td><code id="HHI-Functions_+3A_owner">owner</code></td>
<td>
<p>EITHER a vector  of length k whose values
indicate which of the merging parties produced a product OR
a k x k matrix of ownership shares. Default is a diagonal matrix,
which assumes that each product is owned by a separate firm.</p>
</td></tr>
<tr><td><code id="HHI-Functions_+3A_control">control</code></td>
<td>
<p>EITHER a vector  of length k whose values
indicate which of the merging parties have the ability to make pricing
or output decisions OR a k x k matrix of
control shares. Default is a k x k matrix equal to 1 if &lsquo;owner&rsquo; &gt; 0
and 0 otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All &lsquo;shares&rsquo; must be between 0 and 1. When &lsquo;owner&rsquo; is a matrix,
the i,jth element of &lsquo;owner&rsquo; should equal the percentage of
product j's profits earned by the owner
of product i. When &lsquo;owner&rsquo; is a vector, <code>HHI</code> generates a k x k
matrix of whose i,jth element equals 1 if products i and j are
commonly owned and 0 otherwise. &lsquo;control&rsquo; works in a fashion similar
to &lsquo;owner&rsquo;.
</p>


<h3>Value</h3>

<p><code>HHI</code> returns a number between 0 and 10,000
</p>


<h3>Author(s)</h3>

<p>Charles Taragin <a href="mailto:ctaragin+antitrustr@gmail.com">ctaragin+antitrustr@gmail.com</a>
</p>


<h3>References</h3>

<p>Salop, Steven and O'Brien, Daniel (2000)
&ldquo;Competitive Effects of Partial Ownership: Financial Interest and Corporate Control&rdquo;
67 Antitrust L.J. 559, pp. 559-614.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HHI-Methods">HHI-Methods</a></code> for computing HHI following merger simulation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Consider a market with 5 products labeled 1-5. 1,2 are produced
## by Firm A, 2,3 are produced by Firm B, 3 is produced by Firm C.
## The pre-merger product market shares are

shares = c(.15,.2,.25,.35,.05)
owner  = c("A","A","B","B","C")
nprod  = length(shares)

HHI(shares,owner)

## Suppose that Firm A acquires a 75\% ownership stake in product 3, and
## Firm B get a 10\% ownership stake in product 1. Assume that neither
## firm cedes control of the product to the other.

owner &lt;- diag(nprod)

owner[1,2] &lt;- owner[2,1] &lt;- owner[3,4] &lt;- owner[4,3] &lt;- 1
control &lt;- owner
owner[1,1] &lt;- owner[2,1] &lt;- .9
owner[3,1] &lt;- owner[4,1] &lt;- .1
owner[1,3] &lt;- owner[2,3] &lt;- .75
owner[3,3] &lt;- owner[4,3] &lt;- .25

HHI(shares,owner,control)

## Suppose now that in addition to the ownership stakes described
## earlier, B receives 30\% of the control of product 1
control[1,1] &lt;- control[2,1] &lt;- .7
control[3,1] &lt;- control[4,1] &lt;- .3

HHI(shares,owner,control)

</code></pre>

<hr>
<h2 id='HHI-Methods'>Methods For Calculating the Herfindahl-Hirschman Index</h2><span id='topic+HHI-Methods'></span><span id='topic+hhi'></span><span id='topic+hhi+2CANY-method'></span><span id='topic+hhi+2CBertrand-method'></span><span id='topic+hhi+2CCournot-method'></span><span id='topic+hhi+2CVertBargBertLogit-method'></span>

<h3>Description</h3>

<p>Computes the  Herfindahl-Hirschman Index (HHI) using simulated market
shares and either pre- or post-merger ownership information.
Outside shares are excluded from the calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Bertrand'
hhi(object, preMerger = TRUE, revenue = FALSE, insideonly = TRUE)

## S4 method for signature 'Cournot'
hhi(object, preMerger = TRUE, revenue = FALSE)

## S4 method for signature 'VertBargBertLogit'
hhi(object, preMerger = TRUE, revenue = FALSE, insideonly = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HHI-Methods_+3A_object">object</code></td>
<td>
<p>An instance of one of the classes listed above.</p>
</td></tr>
<tr><td><code id="HHI-Methods_+3A_premerger">preMerger</code></td>
<td>
<p>If TRUE, returns pre-merger outcome. If
FALSE, returns post-merger outcome.  Default is TRUE.</p>
</td></tr>
<tr><td><code id="HHI-Methods_+3A_revenue">revenue</code></td>
<td>
<p>If TRUE, returns revenues. If FALSE,
returns quantities. Default is TRUE.</p>
</td></tr>
<tr><td><code id="HHI-Methods_+3A_insideonly">insideonly</code></td>
<td>
<p>If TRUE, excludes the share of the outside good from the calculation.
Default is TRUE.</p>
</td></tr>
</table>

<hr>
<h2 id='Linear-Functions'>Linear and Log-Linear Demand Calibration and Merger Simulation</h2><span id='topic+Linear-Functions'></span><span id='topic+linear'></span><span id='topic+loglinear'></span>

<h3>Description</h3>

<p>Calibrates consumer demand using either a
linear or log-linear demand system and then simulates
the prices effect of a merger between two firms
under the assumption that all firms in the market
are playing a differentiated products Bertrand game.
</p>
<p>Let k denote the number of products produced by all firms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear(
  prices,
  quantities,
  margins,
  diversions,
  symmetry = TRUE,
  ownerPre,
  ownerPost,
  mcDelta = rep(0, length(prices)),
  subset = rep(TRUE, length(prices)),
  priceStart = prices,
  control.slopes,
  labels = paste("Prod", 1:length(prices), sep = ""),
  ...
)

loglinear(
  prices,
  quantities,
  margins,
  diversions,
  ownerPre,
  ownerPost,
  mcDelta = rep(0, length(prices)),
  subset = rep(TRUE, length(prices)),
  priceStart = prices,
  control.equ,
  labels = paste("Prod", 1:length(prices), sep = ""),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Linear-Functions_+3A_prices">prices</code></td>
<td>
<p>A length k vector product prices.</p>
</td></tr>
<tr><td><code id="Linear-Functions_+3A_quantities">quantities</code></td>
<td>
<p>A length k vector of product quantities.</p>
</td></tr>
<tr><td><code id="Linear-Functions_+3A_margins">margins</code></td>
<td>
<p>A length k vector of product margins. All margins must
be either be between 0 and 1, or NA.</p>
</td></tr>
<tr><td><code id="Linear-Functions_+3A_diversions">diversions</code></td>
<td>
<p>A k x k matrix of diversion ratios with diagonal
elements equal to -1. Default is missing, in which case diversion
according to quantity share is assumed.</p>
</td></tr>
<tr><td><code id="Linear-Functions_+3A_symmetry">symmetry</code></td>
<td>
<p>If TRUE, requires the matrix of demand slope coefficients
to be symmetric and homogeneous of degree 0 in prices, both of which
suffice to make demand consistent with utility maximization theory.
Default is TRUE.</p>
</td></tr>
<tr><td><code id="Linear-Functions_+3A_ownerpre">ownerPre</code></td>
<td>
<p>EITHER a vector of length k whose values
indicate which firm produced a product pre-merger OR
a k x k matrix of pre-merger ownership shares.</p>
</td></tr>
<tr><td><code id="Linear-Functions_+3A_ownerpost">ownerPost</code></td>
<td>
<p>EITHER a vector of length k whose values
indicate which firm produced a product after the merger OR
a k x k matrix of post-merger ownership shares.</p>
</td></tr>
<tr><td><code id="Linear-Functions_+3A_mcdelta">mcDelta</code></td>
<td>
<p>A length k vector where each element equals the
proportional change in a product's marginal costs due to
the merger. Default is 0, which assumes that the merger does not
affect any products' marginal cost.</p>
</td></tr>
<tr><td><code id="Linear-Functions_+3A_subset">subset</code></td>
<td>
<p>A vector of length k where each element equals TRUE if
the product indexed by that element should be included in the
post-merger simulation and FALSE if it should be excluded.Default is a
length k vector of TRUE.</p>
</td></tr>
<tr><td><code id="Linear-Functions_+3A_pricestart">priceStart</code></td>
<td>
<p>A length k vector of prices used as the initial guess
in the nonlinear equation solver. Default is &lsquo;prices&rsquo;.</p>
</td></tr>
<tr><td><code id="Linear-Functions_+3A_control.slopes">control.slopes</code></td>
<td>
<p>A list of  <code><a href="stats.html#topic+optim">optim</a></code>  control parameters
passed to the calibration routine optimizer (typically the <code>calcSlopes</code> method).</p>
</td></tr>
<tr><td><code id="Linear-Functions_+3A_labels">labels</code></td>
<td>
<p>A k-length vector of labels. Default is &quot;Prod#&quot;, where
&lsquo;#&rsquo; is a number between 1 and the length of &lsquo;prices&rsquo;.</p>
</td></tr>
<tr><td><code id="Linear-Functions_+3A_...">...</code></td>
<td>
<p>Additional options to feed to the solver. See below.</p>
</td></tr>
<tr><td><code id="Linear-Functions_+3A_control.equ">control.equ</code></td>
<td>
<p>A list of  <code><a href="BB.html#topic+BBsolve">BBsolve</a></code> control parameters
passed to the non-linear equation solver (typically the <code>calcPrices</code> method).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using price, quantity, and diversion information for all products
in a market, as well as margin information for (at least) all the
products of any firm, <code>linear</code> is able to
recover the slopes and intercepts in a Linear demand
system and then uses these demand parameters to simulate the price
effects of a merger between
two firms under the assumption that the firms are playing a
differentiated Bertrand pricing game.
</p>
<p><code>loglinear</code> uses the same information as <code>linear</code> to uncover the
slopes and intercepts in a Log-Linear demand system, and then uses these
demand parameters to simulate the price effects of a merger of two firms under the
assumption that the firms are playing a
differentiated Bertrand pricing game.
</p>
<p>&lsquo;diversions&rsquo; must be a square matrix whose off-diagonal elements [i,j] estimate the diversion ratio from product i to product j
(i.e. the estimated fraction of i's sales that go to j due to a small
increase in i's price). Off-diagonal elements are restricted to be
non-negative (products are assumed to be substitutes), diagonal elements
must equal -1, and rows must sum to 0 (negative if you wish to include an outside good) . If &lsquo;diversions&rsquo; is missing, then diversion according to quantity share is assumed.
</p>
<p>&lsquo;ownerPre&rsquo; and &lsquo;ownerPost&rsquo; values will typically be equal to either 0
(element [i,j] is not commonly owned) or 1 (element [i,j] is commonly
owned), though these matrices may take on any value between 0 and 1 to
account for partial ownership.
</p>
<p>Under linear demand, an analytic solution to the Bertrand pricing game
exists. However, this solution can at times produce negative
equilibrium quantities. To accommodate this issue, <code>linear</code>
uses <code><a href="stats.html#topic+constrOptim">constrOptim</a></code>  to
find equilibrium prices with non-negative quantities. <code>...</code> may
be used to change the default options for <a href="stats.html#topic+constrOptim">constrOptim</a>.
</p>
<p><code>loglinear</code> uses the non-linear equation solver
<code><a href="BB.html#topic+BBsolve">BBsolve</a></code> to find equilibrium prices.  <code>...</code> may
be used to change the default options for <code><a href="BB.html#topic+BBsolve">BBsolve</a></code>.
</p>


<h3>Value</h3>

<p><code>linear</code> returns an instance of class <code><a href="#topic+Linear-class">Linear</a></code>.
<code>loglinear</code> returns an instance of <code><a href="#topic+LogLin-class">LogLin</a></code>, a
child class of <code><a href="#topic+Linear-class">Linear</a></code>.
</p>


<h3>Author(s)</h3>

<p>Charles Taragin <a href="mailto:ctaragin+antitrustr@gmail.com">ctaragin+antitrustr@gmail.com</a>
</p>


<h3>References</h3>

<p>von Haefen, Roger (2002).
&ldquo;A Complete Characterization Of The Linear, Log-Linear, And Semi-Log
Incomplete Demand System Models.&rdquo;
<em>Journal of Agricultural and Resource Economics</em>, <b>27</b>(02).
doi: <a href="https://doi.org/10.22004/ag.econ.31118">10.22004/ag.econ.31118</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aids">aids</a></code> for a demand system based on revenue shares rather than quantities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate a merger between two single-product firms in a
## three-firm market with linear demand with diversions
## that are proportional to shares.
## This example assumes that the merger is between
## the first two firms



n &lt;- 3 #number of firms in market
price    &lt;- c(2.9,3.4,2.2)
quantity &lt;- c(650,998,1801)
margin &lt;- c(.435,.417,.370)


#simulate merger between firms 1 and 2
owner.pre &lt;- diag(n)
owner.post &lt;- owner.pre
owner.post[1,2] &lt;- owner.post[2,1] &lt;- 1



result.linear &lt;- linear(price,quantity,margin,ownerPre=owner.pre,ownerPost=owner.post)

print(result.linear)           # return predicted price change
summary(result.linear)         # summarize merger simulation

elast(result.linear,TRUE)      # returns premerger elasticities
elast(result.linear,FALSE)     # returns postmerger elasticities

diversion(result.linear,TRUE)  # returns premerger diversion ratios
diversion(result.linear,FALSE) # returns postmeger diversion ratios

cmcr(result.linear)            # returns the compensating marginal cost reduction

CV(result.linear)              # returns representative agent compensating variation


## Implement the Hypothetical Monopolist Test
## for products 1 and 2 using a 5\% SSNIP

#HypoMonTest(result.linear,prodIndex=1:2)


## Get a detailed description of the 'Linear' class slots
showClass("Linear")

## Show all methods attached to the 'Linear' Class
showMethods(classes="Linear")

## Show which class have their own 'elast' method
showMethods("elast")

## Show the method definition for 'elast' and Class 'Linear'
getMethod("elast","Linear")

</code></pre>

<hr>
<h2 id='Logit-Functions'>(Nested) Logit Demand Calibration and Merger Simulation)</h2><span id='topic+Logit-Functions'></span><span id='topic+logit'></span><span id='topic+logit.nests'></span><span id='topic+logit.nests.alm'></span><span id='topic+logit.cap'></span><span id='topic+logit.alm'></span><span id='topic+logit.cap.alm'></span>

<h3>Description</h3>

<p>Calibrates consumer demand using (Nested) Logit
and then simulates the price effect of a merger between two firms
under the assumption that all firms in the market are playing a
differentiated products Bertrand pricing game.
</p>
<p>Let k denote the number of products produced by all
firms playing the Bertrand pricing game below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(
  prices,
  shares,
  margins,
  diversions,
  ownerPre,
  ownerPost,
  normIndex = ifelse(isTRUE(all.equal(sum(shares), 1, check.names = FALSE)), 1, NA),
  mcDelta = rep(0, length(prices)),
  subset = rep(TRUE, length(prices)),
  insideSize = NA_real_,
  priceOutside = 0,
  priceStart = prices,
  isMax = FALSE,
  control.slopes,
  control.equ,
  labels = paste("Prod", 1:length(prices), sep = ""),
  ...
)

logit.nests(
  prices,
  shares,
  margins,
  diversions,
  ownerPre,
  ownerPost,
  nests = rep(1, length(shares)),
  normIndex = ifelse(sum(shares) &lt; 1, NA, 1),
  mcDelta = rep(0, length(prices)),
  subset = rep(TRUE, length(prices)),
  priceOutside = 0,
  priceStart = prices,
  isMax = FALSE,
  constraint = TRUE,
  parmsStart,
  control.slopes,
  control.equ,
  labels = paste("Prod", 1:length(prices), sep = ""),
  ...
)

logit.nests.alm(
  prices,
  shares,
  margins,
  ownerPre,
  ownerPost,
  nests = rep(1, length(shares)),
  mcDelta = rep(0, length(prices)),
  subset = rep(TRUE, length(prices)),
  priceOutside = 0,
  priceStart = prices,
  isMax = FALSE,
  constraint = TRUE,
  parmsStart,
  control.slopes,
  control.equ,
  labels = paste("Prod", 1:length(prices), sep = ""),
  ...
)

logit.cap(
  prices,
  shares,
  margins,
  ownerPre,
  ownerPost,
  capacitiesPre = rep(Inf, length(prices)),
  capacitiesPost = capacitiesPre,
  insideSize,
  normIndex = ifelse(sum(shares) &lt; 1, NA, 1),
  mcDelta = rep(0, length(prices)),
  subset = rep(TRUE, length(prices)),
  priceOutside = 0,
  priceStart = prices,
  isMax = FALSE,
  control.slopes,
  control.equ,
  labels = paste("Prod", 1:length(prices), sep = ""),
  ...
)

logit.alm(
  prices,
  shares,
  margins,
  ownerPre,
  ownerPost,
  mktElast = NA_real_,
  insideSize = NA_real_,
  mcDelta = rep(0, length(prices)),
  subset = rep(TRUE, length(prices)),
  priceOutside = 0,
  priceStart = prices,
  isMax = FALSE,
  parmsStart,
  control.slopes,
  control.equ,
  labels = paste("Prod", 1:length(prices), sep = ""),
  ...
)

logit.cap.alm(
  prices,
  shares,
  margins,
  ownerPre,
  ownerPost,
  capacitiesPre = rep(Inf, length(prices)),
  capacitiesPost = capacitiesPre,
  mktElast = NA_real_,
  insideSize,
  mcDelta = rep(0, length(prices)),
  subset = rep(TRUE, length(prices)),
  priceOutside = 0,
  priceStart = prices,
  isMax = FALSE,
  parmsStart,
  control.slopes,
  control.equ,
  labels = paste("Prod", 1:length(prices), sep = ""),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Logit-Functions_+3A_prices">prices</code></td>
<td>
<p>A length k vector of product prices.</p>
</td></tr>
<tr><td><code id="Logit-Functions_+3A_shares">shares</code></td>
<td>
<p>A length k vector of product (quantity) shares. Values must be
between 0 and 1.</p>
</td></tr>
<tr><td><code id="Logit-Functions_+3A_margins">margins</code></td>
<td>
<p>A length k vector of product margins, some of which may
equal NA.</p>
</td></tr>
<tr><td><code id="Logit-Functions_+3A_diversions">diversions</code></td>
<td>
<p>A k x k matrix of diversion ratios with diagonal
elements equal to -1. Default is missing.</p>
</td></tr>
<tr><td><code id="Logit-Functions_+3A_ownerpre">ownerPre</code></td>
<td>
<p>EITHER a vector of length k whose values
indicate which firm produced a product pre-merger OR
a k x k matrix of pre-merger ownership shares.</p>
</td></tr>
<tr><td><code id="Logit-Functions_+3A_ownerpost">ownerPost</code></td>
<td>
<p>EITHER a vector of length k whose values
indicate which firm produced a product after the merger OR
a k x k matrix of post-merger ownership shares.</p>
</td></tr>
<tr><td><code id="Logit-Functions_+3A_normindex">normIndex</code></td>
<td>
<p>An integer equalling the index (position) of the
inside product whose mean valuation will be normalized to 1. Default
is 1, unless &lsquo;shares&rsquo; sum to less than 1, in which case the default is
NA and an outside good is assumed to exist.</p>
</td></tr>
<tr><td><code id="Logit-Functions_+3A_mcdelta">mcDelta</code></td>
<td>
<p>A vector of length k where each element equals the
proportional change in a product's marginal costs due to
the merger. Default is 0, which assumes that the merger does not
affect any products' marginal cost.</p>
</td></tr>
<tr><td><code id="Logit-Functions_+3A_subset">subset</code></td>
<td>
<p>A vector of length k where each element equals TRUE if
the product indexed by that element should be included in the
post-merger simulation and FALSE if it should be excluded.Default is a
length k vector of TRUE.</p>
</td></tr>
<tr><td><code id="Logit-Functions_+3A_insidesize">insideSize</code></td>
<td>
<p>An integer equal to total pre-merger units sold.
If shares sum to one, this also equals the size of the market.</p>
</td></tr>
<tr><td><code id="Logit-Functions_+3A_priceoutside">priceOutside</code></td>
<td>
<p>A length 1 vector indicating the price of the
outside good. Default is 0.</p>
</td></tr>
<tr><td><code id="Logit-Functions_+3A_pricestart">priceStart</code></td>
<td>
<p>A length k vector of starting values used to solve for
equilibrium price. Default is the &lsquo;prices&rsquo; vector.</p>
</td></tr>
<tr><td><code id="Logit-Functions_+3A_ismax">isMax</code></td>
<td>
<p>If TRUE, checks to see whether computed price equilibrium
locally maximizes firm profits and returns a warning if not. Default is FALSE.</p>
</td></tr>
<tr><td><code id="Logit-Functions_+3A_control.slopes">control.slopes</code></td>
<td>
<p>A list of  <code><a href="stats.html#topic+optim">optim</a></code>
control parameters passed to the calibration routine
optimizer (typically the <code>calcSlopes</code> method).</p>
</td></tr>
<tr><td><code id="Logit-Functions_+3A_control.equ">control.equ</code></td>
<td>
<p>A list of  <code><a href="BB.html#topic+BBsolve">BBsolve</a></code> control parameters
passed to the non-linear equation solver (typically the <code>calcPrices</code> method).</p>
</td></tr>
<tr><td><code id="Logit-Functions_+3A_labels">labels</code></td>
<td>
<p>A k-length vector of labels. Default is &quot;Prod#&quot;, where
&lsquo;#&rsquo; is a number between 1 and the length of &lsquo;prices&rsquo;.</p>
</td></tr>
<tr><td><code id="Logit-Functions_+3A_...">...</code></td>
<td>
<p>Additional options to feed to the <code><a href="BB.html#topic+BBsolve">BBsolve</a></code>
optimizer used to solve for equilibrium prices.</p>
</td></tr>
<tr><td><code id="Logit-Functions_+3A_nests">nests</code></td>
<td>
<p>A length k vector identifying the nest that each
product belongs to.</p>
</td></tr>
<tr><td><code id="Logit-Functions_+3A_constraint">constraint</code></td>
<td>
<p>if TRUE, then the nesting parameters for all
non-singleton nests are assumed equal. If FALSE, then each
non-singleton nest is permitted to have its own value. Default is
TRUE.</p>
</td></tr>
<tr><td><code id="Logit-Functions_+3A_parmsstart">parmsStart</code></td>
<td>
<p>For <code>logit.cap.alm</code>, a length-2 vector of starting values
used to solve for the price coefficient and outside share (in that order). For
<code>logit.nets</code>, rhe first element should
always be the price coefficient and the remaining elements should be
the nesting parameters. Theory requires the nesting parameters to be
greater than the price coefficient. If missing then the random
draws with the appropriate restrictions are employed.</p>
</td></tr>
<tr><td><code id="Logit-Functions_+3A_capacitiespre">capacitiesPre</code></td>
<td>
<p>A length k vector of pre-merger product capacities. Capacities
must be at least as great as shares * insideSize.</p>
</td></tr>
<tr><td><code id="Logit-Functions_+3A_capacitiespost">capacitiesPost</code></td>
<td>
<p>A length k vector of post-merger product capacities.</p>
</td></tr>
<tr><td><code id="Logit-Functions_+3A_mktelast">mktElast</code></td>
<td>
<p>a negative value indicating market elasticity. Default is NA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using product prices, quantity shares and all of the
product margins from at least one firm, <code>logit</code> is able to
recover the price coefficient and product mean valuations in a
Logit demand model. <code>logit</code> then uses these
calibrated parameters to simulate a merger between two firms.
</p>
<p><code>logit.alm</code> is identical to <code>logit</code> except that it assumes
that an outside product exists and uses additional margin
information to estimate the share of the outside good.
If market elasticity is known, it may be supplied using the
&lsquo;mktElast&rsquo; argument.
</p>
<p><code>logit.nests</code> is identical to <code>logit</code> except that it includes the &lsquo;nests&rsquo;
argument which may be used to assign products to different
nests. Nests are useful because they allow for richer substitution
patterns between products. Products within the same nest are assumed
to be closer substitutes than products in different nests. The degree
of substitutability between products located in different nests is
controlled by the value of the nesting parameter sigma.
The nesting parameters for singleton nests (nests containing
only one product) are not identified and normalized to 1.  The vector of
sigmas is calibrated from the prices, revenue shares, and margins supplied
by the user.
</p>
<p>By default, all non-singleton nests are assumed to have a common value for sigma.
This constraint may be relaxed  by setting &lsquo;constraint&rsquo; to
FALSE. In this case, at least one product margin must be supplied from
a product within each nest.
</p>
<p><code>logit.nests.alm</code> is identical to <code>logit.nests</code> except that it assumes
that an outside product exists  and uses additional margin
information to estimate the share of the outside good.
</p>
<p><code>logit.cap</code> is identical to  <code>logit</code>  except that firms are
playing the Bertrand pricing game under exogenously supplied capacity
constraints. Unlike <code>logit</code>,  <code>logit.cap</code> requires users to
specify capacity constraints via &lsquo;capacities&rsquo; and  the number of
potential customers in a market via &lsquo;mktSize&rsquo;. &lsquo;mktSize&rsquo; is needed to
transform &lsquo;shares&rsquo; into quantities that must be directly compared to &lsquo;capacities&rsquo;.
</p>
<p>In <code>logit</code>, <code>logit.nests</code> and <code>logit.cap</code>,  if quantity shares sum to 1,
then one product's mean value is not identified and must be normalized
to 0. &lsquo;normIndex&rsquo; may be used to specify the index (position) of the
product whose mean value is to be normalized. If the sum of revenue shares
is less than 1, both of these functions assume that the exists a k+1st
product in the market whose price and mean value are both normalized
to 0.
</p>


<h3>Value</h3>

<p><code>logit</code> returns an instance of class
<code><a href="#topic+Logit-class">Logit</a></code>.
<code>logit.alm</code> returns an instance of <code><a href="#topic+LogitALM-class">LogitALM</a></code>, a
child class of <code><a href="#topic+Logit-class">Logit</a>.</code>.
<code>logit.nests</code> returns an instance of <code><a href="#topic+LogitNests-class">LogitNests</a></code>, a
child class of <code><a href="#topic+Logit-class">Logit</a></code>.
<code>logit.cap</code> returns an instance of <code><a href="#topic+LogitCap-class">LogitCap</a></code>, a
child class of <code><a href="#topic+Logit-class">Logit</a>.</code>
</p>


<h3>Author(s)</h3>

<p>Charles Taragin <a href="mailto:ctaragin+antitrustr@gmail.com">ctaragin+antitrustr@gmail.com</a>
</p>


<h3>References</h3>

<p>Anderson, Simon, Palma, Andre, and Francois Thisse (1992).
<em>Discrete Choice Theory of Product Differentiation</em>.
The MIT Press, Cambridge, Mass.
</p>
<p>Epstein, Roy and Rubinfeld, Daniel (2004).
&ldquo;Effects of Mergers Involving Differentiated Products.&rdquo;
</p>
<p>Werden, Gregory and Froeb, Luke (1994).
&ldquo;The Effects of Mergers in
Differentiated Products Industries: Structural Merger Policy and the
Logit Model&rdquo;,
<em>Journal of Law, Economics, and Organization</em>, <b>10</b>, pp. 407-426.
</p>
<p>Froeb, Luke, Tschantz, Steven  and Phillip Crooke (2003).
&ldquo;Bertrand Competition and Capacity Constraints: Mergers Among Parking Lots&rdquo;,
<em>Journal of Econometrics</em>, <b>113</b>, pp. 49-67.
</p>
<p>Froeb, Luke and Werden, Greg (1996).
&ldquo;Computational Economics and Finance: Modeling and Analysis with Mathematica, Volume 2.&rdquo;
In Varian H (ed.), chapter Simulating Mergers among Noncooperative Oligopolists, pp. 177-95.
Springer-Verlag, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ces">ces</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Calibration and simulation results from a merger between Budweiser and
## Old Style.
## Source: Epstein/Rubenfeld 2004, pg 80


prodNames &lt;- c("BUD","OLD STYLE","MILLER","MILLER-LITE","OTHER-LITE","OTHER-REG")
ownerPre &lt;-c("BUD","OLD STYLE","MILLER","MILLER","OTHER-LITE","OTHER-REG")
ownerPost &lt;-c("BUD","BUD","MILLER","MILLER","OTHER-LITE","OTHER-REG")
nests &lt;- c("Reg","Reg","Reg","Light","Light","Reg")

price    &lt;- c(.0441,.0328,.0409,.0396,.0387,.0497)
shares   &lt;- c(.066,.172,.253,.187,.099,.223)
margins &lt;- c(.3830,.5515,.5421,.5557,.4453,.3769)

insideSize &lt;- 1000

names(price) &lt;-
  names(shares) &lt;-
  names(margins) &lt;-
  prodNames

result.logit &lt;- logit(price,shares,margins,
                      ownerPre=ownerPre,ownerPost=ownerPost,
                      insideSize = insideSize,
                      labels=prodNames)



print(result.logit)           # return predicted price change
summary(result.logit)         # summarize merger simulation

elast(result.logit,TRUE)      # returns premerger elasticities
elast(result.logit,FALSE)     # returns postmerger elasticities

diversion(result.logit,TRUE)  # return premerger diversion ratios
diversion(result.logit,FALSE) # return postmerger diversion ratios


cmcr(result.logit)            #calculate compensating marginal cost reduction
upp(result.logit)            #calculate Upwards Pricing Pressure Index

CV(result.logit)              #calculate representative agent compensating variation


## Implement the Hypothetical Monopolist Test
## for BUD and OLD STYLE using a 5\% SSNIP

HypoMonTest(result.logit,prodIndex=1:2)



## Get a detailed description of the 'Logit' class slots
showClass("Logit")

## Show all methods attached to the 'Logit' Class
showMethods(classes="Logit")

## Show which classes have their own 'elast' method
showMethods("elast")

## Show the method definition for 'elast' and Class 'Logit'
getMethod("elast","Logit")



#
# Logit With capacity Constraints
#


cap     &lt;- c(66,200,300,200,99,300) # BUD and OTHER-LITE are capacity constrained
result.cap &lt;- logit.cap(price,shares,margins,capacitiesPre=cap,
                        insideSize=insideSize,ownerPre=ownerPre,
                        ownerPost=ownerPost,labels=prodNames)
print(result.cap)

</code></pre>

<hr>
<h2 id='Margins-Methods'>Methods for Calculating Diagnostics</h2><span id='topic+Margins-Methods'></span><span id='topic+calcMargins'></span><span id='topic+calcMargins+2CANY-method'></span><span id='topic+calcMargins+2CAIDS-method'></span><span id='topic+calcMargins+2CBertrand-method'></span><span id='topic+calcMargins+2CVertBargBertLogit-method'></span><span id='topic+calcMargins+2CLogitCap-method'></span><span id='topic+calcMargins+2CAuction2ndLogit-method'></span><span id='topic+calcMargins+2CAuction2ndLogitNests-method'></span><span id='topic+calcMargins+2CCournot-method'></span><span id='topic+calcMargins+2CBargainingLogit-method'></span><span id='topic+calcMargins+2CBargaining2ndLogit-method'></span><span id='topic+calcMargins+2CAuction2ndCap-method'></span>

<h3>Description</h3>

<p>Computes equilibrium product margins assuming that firms are playing a
Nash-Bertrand, Cournot, 2nd Score Auction, or Bargaining game. For &quot;LogitCap&quot;, assumes firms are
playing a Nash-Bertrand or Cournot game with capacity constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Bertrand'
calcMargins(object, preMerger = TRUE, level = FALSE)

## S4 method for signature 'Bargaining2ndLogit'
calcMargins(object, preMerger = TRUE, exAnte = FALSE, level = TRUE)

## S4 method for signature 'BargainingLogit'
calcMargins(object, preMerger = TRUE, level = FALSE)

## S4 method for signature 'VertBargBertLogit'
calcMargins(object, preMerger = TRUE, level = FALSE)

## S4 method for signature 'Auction2ndCap'
calcMargins(object, preMerger = TRUE, exAnte = TRUE, level = FALSE)

## S4 method for signature 'Cournot'
calcMargins(object, preMerger = TRUE, level = FALSE)

## S4 method for signature 'AIDS'
calcMargins(object, preMerger = TRUE, level = FALSE)

## S4 method for signature 'LogitCap'
calcMargins(object, preMerger = TRUE, level = FALSE)

## S4 method for signature 'Auction2ndLogit'
calcMargins(object, preMerger = TRUE, exAnte = FALSE, level = TRUE)

## S4 method for signature 'Auction2ndLogitNests'
calcMargins(object, preMerger = TRUE, exAnte = FALSE, level = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Margins-Methods_+3A_object">object</code></td>
<td>
<p>An instance of one of the classes listed above.</p>
</td></tr>
<tr><td><code id="Margins-Methods_+3A_premerger">preMerger</code></td>
<td>
<p>If TRUE, returns pre-merger outcome. If
FALSE, returns post-merger outcome.  Default is TRUE.</p>
</td></tr>
<tr><td><code id="Margins-Methods_+3A_level">level</code></td>
<td>
<p>IF TRUE, return margins in dollars. If FALSE, returns 
margins in proportions. Default for most classes is FALSE.</p>
</td></tr>
<tr><td><code id="Margins-Methods_+3A_exante">exAnte</code></td>
<td>
<p>If &lsquo;exAnte&rsquo; equals TRUE then the
<em>ex ante</em> expected result for each firm is produced, while FALSE produces the
expected result conditional on each firm winning the auction. Default is FALSE.</p>
</td></tr>
</table>

<hr>
<h2 id='Output-Methods'>Output Methods</h2><span id='topic+Output-Methods'></span><span id='topic+calcQuantities'></span><span id='topic+calcQuantities+2CANY-method'></span><span id='topic+calcQuantities+2CLogit-method'></span><span id='topic+calcQuantities+2CCES-method'></span><span id='topic+calcQuantities+2CLinear-method'></span><span id='topic+calcQuantities+2CLogLin-method'></span><span id='topic+calcQuantities+2CLogitCap-method'></span><span id='topic+calcQuantities+2CCournot-method'></span><span id='topic+calcQuantities+2CStackelberg-method'></span><span id='topic+calcQuantities+2CAIDS-method'></span><span id='topic+calcShares'></span><span id='topic+calcShares+2CANY-method'></span><span id='topic+calcShares+2CAIDS-method'></span><span id='topic+calcShares+2CCES-method'></span><span id='topic+calcShares+2CCESNests-method'></span><span id='topic+calcShares+2CLinear-method'></span><span id='topic+calcShares+2CLogit-method'></span><span id='topic+calcShares+2CLogitNests-method'></span><span id='topic+calcShares+2CAuction2ndLogit-method'></span><span id='topic+calcShares+2CAuction2ndLogitNests-method'></span><span id='topic+calcShares+2CCournot-method'></span><span id='topic+calcRevenues'></span><span id='topic+calcRevenues+2CANY-method'></span><span id='topic+calcRevenues+2CBertrand-method'></span><span id='topic+calcRevenues+2CCES-method'></span><span id='topic+calcRevenues+2CAIDS-method'></span><span id='topic+calcRevenues+2CCournot-method'></span><span id='topic+calcRevenues+2CVertBargBertLogit-method'></span><span id='topic+calcShares+2CAuction2ndCap-method'></span><span id='topic+calcQuantities+2CVertBargBertLogit-method'></span><span id='topic+calcShares+2CVertBargBertLogit-method'></span><span id='topic+calcShares+2CVertBarg2ndLogit-method'></span>

<h3>Description</h3>

<p>This section contains three types of methods: calcShares, calcQuantities, and calcRevenues.
calcShares computes equilibrium product shares assuming that firms are playing a
Nash-Bertrand or Cournot  game. &lsquo;revenue&rsquo; takes
on a value of TRUE or FALSE, where TRUE calculates revenue shares,
while FALSE calculates quantity shares.
</p>
<p>calcQuantities computes equilibrium product quantities assuming that firms are playing a
Nash-Bertrand, 2nd Score Auction, or Cournot game. Setting &lsquo;market&rsquo; to TRUE returns total market quantity.
</p>
<p>calcRevenues computes equilibrium product revenues assuming that firms are playing a
Nash-Bertrand, 2nd Score Auction, or Cournot game. Setting &lsquo;market&rsquo; to TRUE returns total market revenue.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Cournot'
calcQuantities(object, preMerger = TRUE, market = FALSE, ...)

## S4 method for signature 'Stackelberg'
calcQuantities(object, preMerger = TRUE, market = FALSE, ...)

## S4 method for signature 'Linear'
calcQuantities(object, preMerger = TRUE, market = FALSE)

## S4 method for signature 'Logit'
calcQuantities(object, preMerger = TRUE, market = FALSE)

## S4 method for signature 'LogLin'
calcQuantities(object, preMerger = TRUE, market = FALSE, ...)

## S4 method for signature 'AIDS'
calcQuantities(object, preMerger = TRUE, market = FALSE)

## S4 method for signature 'CES'
calcQuantities(object, preMerger = TRUE, market = FALSE)

## S4 method for signature 'Bertrand'
calcRevenues(object, preMerger = TRUE, market = FALSE)

## S4 method for signature 'Cournot'
calcRevenues(object, preMerger = TRUE, market = FALSE)

## S4 method for signature 'VertBargBertLogit'
calcRevenues(object, preMerger = TRUE, market = FALSE)

## S4 method for signature 'AIDS'
calcQuantities(object, preMerger = TRUE, market = FALSE)

## S4 method for signature 'CES'
calcRevenues(object, preMerger = TRUE, market = FALSE)

## S4 method for signature 'Auction2ndCap'
calcShares(object, preMerger = TRUE, exAnte = TRUE)

## S4 method for signature 'Cournot'
calcShares(object, preMerger = TRUE, revenue = FALSE)

## S4 method for signature 'Linear'
calcShares(object, preMerger = TRUE, revenue = FALSE)

## S4 method for signature 'VertBargBertLogit'
calcQuantities(object, preMerger = TRUE, market = FALSE)

## S4 method for signature 'VertBargBertLogit'
calcShares(object, preMerger = TRUE, revenue = FALSE)

## S4 method for signature 'VertBarg2ndLogit'
calcShares(object, preMerger = TRUE, revenue = FALSE)

## S4 method for signature 'Logit'
calcShares(object, preMerger = TRUE, revenue = FALSE)

## S4 method for signature 'AIDS'
calcShares(object, preMerger = TRUE, revenue = TRUE)

## S4 method for signature 'LogitNests'
calcShares(object, preMerger = TRUE, revenue = FALSE)

## S4 method for signature 'Auction2ndLogit'
calcShares(object, preMerger = TRUE, revenue = FALSE)

## S4 method for signature 'Auction2ndLogitNests'
calcShares(object, preMerger = TRUE, revenue = FALSE)

## S4 method for signature 'CES'
calcShares(object, preMerger = TRUE, revenue = FALSE)

## S4 method for signature 'CESNests'
calcShares(object, preMerger = TRUE, revenue = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Output-Methods_+3A_object">object</code></td>
<td>
<p>An instance of one of the classes listed above.</p>
</td></tr>
<tr><td><code id="Output-Methods_+3A_premerger">preMerger</code></td>
<td>
<p>If TRUE, returns pre-merger outcome. If
FALSE, returns post-merger outcome.  Default is TRUE.</p>
</td></tr>
<tr><td><code id="Output-Methods_+3A_market">market</code></td>
<td>
<p>If TRUE, reports market-level summary.
Otherwise reports product/plant level summary. Default is FALSE.</p>
</td></tr>
<tr><td><code id="Output-Methods_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>calcQuantities</code>.</p>
</td></tr>
<tr><td><code id="Output-Methods_+3A_exante">exAnte</code></td>
<td>
<p>If &lsquo;exAnte&rsquo; equals TRUE then the
<em>ex ante</em> expected result for each firm is produced, while FALSE produces the
expected result conditional on each firm winning the auction. Default is FALSE.</p>
</td></tr>
<tr><td><code id="Output-Methods_+3A_revenue">revenue</code></td>
<td>
<p>If TRUE, returns revenues. If FALSE,
returns quantities. Default is TRUE.</p>
</td></tr>
</table>

<hr>
<h2 id='Ownership-methods'>Methods for Manipulating Ownership Matrices</h2><span id='topic+Ownership-methods'></span><span id='topic+ownerToMatrix'></span><span id='topic+ownerToVec'></span><span id='topic+ownerToMatrix+2CAntitrust-method'></span><span id='topic+ownerToMatrix+2CVertBargBertLogit-method'></span><span id='topic+ownerToVec+2CAntitrust-method'></span>

<h3>Description</h3>

<p><code>ownerToMatrix</code> converts an ownership vector (or factor) to a k x k matrix of
1s and 0s.
</p>
<p><code>ownerToVec</code> converts a k x k  ownership matrix to a length-k
vector whose values identify an owner.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Antitrust'
ownerToMatrix(object, preMerger = TRUE)

## S4 method for signature 'VertBargBertLogit'
ownerToMatrix(object, preMerger = TRUE)

## S4 method for signature 'Antitrust'
ownerToVec(object, preMerger = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ownership-methods_+3A_object">object</code></td>
<td>
<p>An instance of the Antitrust class.</p>
</td></tr>
<tr><td><code id="Ownership-methods_+3A_premerger">preMerger</code></td>
<td>
<p>The &lsquo;preMerger&rsquo; takes
on a value of TRUE or FALSE, where TRUE invokes the method using the
pre-merger values, while FALSE invokes the method using the post-merger ownership structure.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Charles Taragin <a href="mailto:ctaragin+antitrustr@gmail.com">ctaragin+antitrustr@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showMethods(classes="Antitrust") # show all methods defined for the class

</code></pre>

<hr>
<h2 id='Params-Methods'>Methods for Calculating Demand Parameters</h2><span id='topic+Params-Methods'></span><span id='topic+calcSlopes'></span><span id='topic+calcSlopes+2CANY-method'></span><span id='topic+calcSlopes+2CAIDS-method'></span><span id='topic+calcSlopes+2CCES-method'></span><span id='topic+calcSlopes+2CCESNests-method'></span><span id='topic+calcSlopes+2CLinear-method'></span><span id='topic+calcSlopes+2CLogLin-method'></span><span id='topic+calcSlopes+2CLogit-method'></span><span id='topic+calcSlopes+2CLogitALM-method'></span><span id='topic+calcSlopes+2CCESALM-method'></span><span id='topic+calcSlopes+2CLogitCap-method'></span><span id='topic+calcSlopes+2CLogitCapALM-method'></span><span id='topic+calcSlopes+2CLogitNests-method'></span><span id='topic+calcSlopes+2CLogitNestsALM-method'></span><span id='topic+calcSlopes+2CPCAIDS-method'></span><span id='topic+calcSlopes+2CPCAIDSNests-method'></span><span id='topic+calcSlopes+2CAuction2ndLogit-method'></span><span id='topic+calcSlopes+2CAuction2ndLogitNests-method'></span><span id='topic+calcSlopes+2CAuction2ndLogitALM-method'></span><span id='topic+calcSlopes+2CCournot-method'></span><span id='topic+calcSlopes+2CStackelberg-method'></span><span id='topic+calcSlopes+2CVertBargBertLogit-method'></span><span id='topic+calcSlopes+2CBargainingLogit-method'></span><span id='topic+calcSlopes+2CBargaining2ndLogit-method'></span><span id='topic+getParms'></span><span id='topic+getParms+2CANY-method'></span><span id='topic+getParms+2CBertrand-method'></span><span id='topic+getParms+2CVertBargBertLogit-method'></span><span id='topic+getNestsParms'></span><span id='topic+getNestsParms+2CPCAIDSNests-method'></span>

<h3>Description</h3>

<p>The calcSlopes methods calculate demand parameters assuming that firms are playing
a differentitated product Nash-Bertrand pricing game or
(as in the case of the Cournot and Stackelberg classes), a Cournot game.
</p>
<p>getNestsParms returns a matrix containing the calibrated nesting parameters.
</p>
<p>getParms returns a list of model-specific demand parameters.
&lsquo;digits&rsquo; specifies the number of significant digit to return (default 10).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Cournot'
calcSlopes(object)

## S4 method for signature 'Stackelberg'
calcSlopes(object)

## S4 method for signature 'Linear'
calcSlopes(object)

## S4 method for signature 'Logit'
calcSlopes(object)

## S4 method for signature 'LogLin'
calcSlopes(object)

## S4 method for signature 'AIDS'
calcSlopes(object)

## S4 method for signature 'PCAIDS'
calcSlopes(object)

## S4 method for signature 'PCAIDSNests'
calcSlopes(object)

## S4 method for signature 'LogitCap'
calcSlopes(object)

## S4 method for signature 'LogitNests'
calcSlopes(object)

## S4 method for signature 'Auction2ndLogitNests'
calcSlopes(object)

## S4 method for signature 'LogitCapALM'
calcSlopes(object)

## S4 method for signature 'LogitNestsALM'
calcSlopes(object)

## S4 method for signature 'Auction2ndLogit'
calcSlopes(object)

## S4 method for signature 'Auction2ndLogitALM'
calcSlopes(object)

## S4 method for signature 'LogitALM'
calcSlopes(object)

## S4 method for signature 'CES'
calcSlopes(object)

## S4 method for signature 'CESALM'
calcSlopes(object)

## S4 method for signature 'CESNests'
calcSlopes(object)

## S4 method for signature 'BargainingLogit'
calcSlopes(object)

## S4 method for signature 'Bargaining2ndLogit'
calcSlopes(object)

## S4 method for signature 'VertBargBertLogit'
calcSlopes(object)

## S4 method for signature 'Bertrand'
getParms(object, digits = 10)

## S4 method for signature 'VertBargBertLogit'
getParms(object, digits = 10)

## S4 method for signature 'PCAIDSNests'
getNestsParms(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Params-Methods_+3A_object">object</code></td>
<td>
<p>An instance of the respective class (see description for the classes)</p>
</td></tr>
<tr><td><code id="Params-Methods_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits to report. Default is 2.</p>
</td></tr>
</table>

<hr>
<h2 id='Plot-Methods'>Methods For Calculating Upwards Pricing Pressure Index (Bertrand)</h2><span id='topic+Plot-Methods'></span><span id='topic+plot+2CBertrand-method'></span>

<h3>Description</h3>

<p>Use <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> to plot pre- and post-merger demand, marginal cost and equilibria.
&lsquo;scale&rsquo; controls the amount above marginal cost and below equilbrium price that is plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Bertrand'
plot(x, scale = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Plot-Methods_+3A_x">x</code></td>
<td>
<p>Used only in plot method. Should always be set equal to object.</p>
</td></tr>
<tr><td><code id="Plot-Methods_+3A_scale">scale</code></td>
<td>
<p>The proportion below marginal cost and above equilbrium price that should be plotted. Default is .1.</p>
</td></tr>
</table>

<hr>
<h2 id='PriceDelta-Methods'>Methods For Calculating Price Delta</h2><span id='topic+PriceDelta-Methods'></span><span id='topic+calcPriceDelta'></span><span id='topic+calcPriceDelta+2CANY-method'></span><span id='topic+calcPriceDelta+2CAntitrust-method'></span><span id='topic+calcPriceDelta+2CAIDS-method'></span><span id='topic+calcPriceDelta+2CAuction2ndLogit-method'></span><span id='topic+calcPriceDelta+2CCournot-method'></span><span id='topic+calcPriceDelta+2CVertBargBertLogit-method'></span>

<h3>Description</h3>

<p>For Antitrust, the method computes equilibrium price changes
due to a merger assuming that firms are playing a
Nash-Bertrand or Cournot game. This is a wrapper method for computing
the difference between pre- and post-merger equilbrium prices.
</p>
<p>For AIDS, the method computes equilibrium price changes
due to a merger assuming that firms are playing a
Nash-Bertrand or Cournot game and LA-AIDS. This method calls a non-linear
equations solver to find a sequence of price changes that satisfy
the Bertrand FOCs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Antitrust'
calcPriceDelta(
  object,
  levels = FALSE,
  market = FALSE,
  index = c("paasche", "laspeyres"),
  ...
)

## S4 method for signature 'Cournot'
calcPriceDelta(object, levels = FALSE, market = TRUE, ...)

## S4 method for signature 'VertBargBertLogit'
calcPriceDelta(object, levels = FALSE, market = FALSE, ...)

## S4 method for signature 'AIDS'
calcPriceDelta(
  object,
  isMax = FALSE,
  levels = FALSE,
  subset,
  market = FALSE,
  index = c("paasche", "laspeyres"),
  ...
)

## S4 method for signature 'Auction2ndLogit'
calcPriceDelta(
  object,
  levels = TRUE,
  market = FALSE,
  exAnte = ifelse(market, TRUE, FALSE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PriceDelta-Methods_+3A_object">object</code></td>
<td>
<p>An instance of one of the classes listed above.</p>
</td></tr>
<tr><td><code id="PriceDelta-Methods_+3A_levels">levels</code></td>
<td>
<p>If TRUE, report results in levels. If FALSE, report results in percents. Default is FALSE.</p>
</td></tr>
<tr><td><code id="PriceDelta-Methods_+3A_market">market</code></td>
<td>
<p>If TRUE, calculates (post-merger) share-weighted average of metric. Default is FALSE.</p>
</td></tr>
<tr><td><code id="PriceDelta-Methods_+3A_index">index</code></td>
<td>
<p>If &quot;paasche&quot;,calculates market-wide price changes using post-merger predicted shares. If  &quot;laspeyres&quot;, 
calculates price index using pre-merger shares. Default is &quot;paasche&quot;.</p>
</td></tr>
<tr><td><code id="PriceDelta-Methods_+3A_...">...</code></td>
<td>
<p>Additional values that may be used to change the default values of the non-linear
equation solver.</p>
</td></tr>
<tr><td><code id="PriceDelta-Methods_+3A_ismax">isMax</code></td>
<td>
<p>If TRUE, uses numerical derivatives to determine if
equilibrium price vector is a local maximum. Default is FALSE.</p>
</td></tr>
<tr><td><code id="PriceDelta-Methods_+3A_subset">subset</code></td>
<td>
<p>A vector of length k where each element equals TRUE if
the product indexed by that element should be included in the
post-merger simulation and FALSE if it should be excluded.Default is a
length k vector of TRUE.</p>
</td></tr>
<tr><td><code id="PriceDelta-Methods_+3A_exante">exAnte</code></td>
<td>
<p>If &lsquo;exAnte&rsquo; equals TRUE then the
<em>ex ante</em> expected result for each firm is produced, while FALSE produces the
expected result conditional on each firm winning the auction. Default is FALSE, unless &lsquo;market&rsquo; is TRUE.</p>
</td></tr>
</table>

<hr>
<h2 id='Prices-Methods'>&ldquo;Calculating Prices&rdquo; Methods</h2><span id='topic+Prices-Methods'></span><span id='topic+calcPrices+2CANY-method'></span><span id='topic+calcPrices+2CAuction2ndCap-method'></span><span id='topic+calcPrices+2CCournot-method'></span><span id='topic+calcPrices+2CLinear-method'></span><span id='topic+calcPrices+2CLogit-method'></span><span id='topic+calcPrices+2CLogLin-method'></span><span id='topic+calcPrices+2CAIDS-method'></span><span id='topic+calcPrices+2CLogitCap-method'></span><span id='topic+calcPrices+2CAuction2ndLogit-method'></span><span id='topic+calcPrices+2CVertBargBertLogit-method'></span><span id='topic+calcPrices+2CVertBarg2ndLogit-method'></span><span id='topic+calcPrices'></span><span id='topic+calcPrices+2CBargainingLogit-method'></span>

<h3>Description</h3>

<p>For Auction2ndCap, the calcPrices method computes the expected price that the buyer pays,
conditional on the buyer purchasing from a particular firm.
</p>
<p>For Logit, the calcPrices method computes either pre-merger or post-merger equilibrium prices under the assumptions
that consumer demand is Logit and firms play a differentiated product Bertrand Nash pricing game.
</p>
<p>For LogitCap, the calcPrices method computes either pre-merger or post-merger equilibrium shares under the assumptions that
consumer demand is Logit and firms play a differentiated product Bertrand Nash pricing game with capacity constraints.
</p>
<p>For Logit, the calcPrices method computes either pre-merger or post-merger equilibrium prices under the assumptions
that consumer demand is Logit and firms play a differentiated product Bertrand Nash pricing game.
</p>
<p>For LogLin, the calcPrices method computes either pre-merger or post-merger equilibrium prices under the assumptions
that consumer demand is Log-Linear and firms play a differentiated product Bertrand Nash pricing game.
</p>
<p>For AIDS, the calcPrices method computes either pre-merger or post-merger equilibrium prices under the assumptions
that consumer demand is AIDS and firms play a differentiated product Bertrand Nash pricing game.
It returns a length-k vector of NAs if the user did not supply prices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Cournot'
calcPrices(object, preMerger = TRUE)

## S4 method for signature 'Auction2ndCap'
calcPrices(object, preMerger = TRUE, exAnte = TRUE)

## S4 method for signature 'Logit'
calcPrices(object, preMerger = TRUE, isMax = FALSE, subset, ...)

## S4 method for signature 'Auction2ndLogit'
calcPrices(object, preMerger = TRUE, exAnte = FALSE)

## S4 method for signature 'LogitCap'
calcPrices(object, preMerger = TRUE, isMax = FALSE, subset, ...)

## S4 method for signature 'Linear'
calcPrices(object, preMerger = TRUE, subset, ...)

## S4 method for signature 'LogLin'
calcPrices(object, preMerger = TRUE, subset, ...)

## S4 method for signature 'AIDS'
calcPrices(object, preMerger = TRUE, ...)

## S4 method for signature 'BargainingLogit'
calcPrices(object, preMerger = TRUE, isMax = FALSE, subset, ...)

## S4 method for signature 'VertBargBertLogit'
calcPrices(object, preMerger = TRUE, ...)

## S4 method for signature 'VertBarg2ndLogit'
calcPrices(object, preMerger = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Prices-Methods_+3A_object">object</code></td>
<td>
<p>An instance of the respective class (see description for the classes)</p>
</td></tr>
<tr><td><code id="Prices-Methods_+3A_premerger">preMerger</code></td>
<td>
<p>If TRUE, the pre-merger ownership structure is used. If FALSE, the post-merger ownership structure is used.
Default is TRUE.</p>
</td></tr>
<tr><td><code id="Prices-Methods_+3A_exante">exAnte</code></td>
<td>
<p>If &lsquo;exAnte&rsquo; equals TRUE then the
<em>ex ante</em> expected result for each firm is produced, while FALSE produces the
expected result conditional on each firm winning the auction. Default is FALSE.</p>
</td></tr>
<tr><td><code id="Prices-Methods_+3A_ismax">isMax</code></td>
<td>
<p>If TRUE, a check is run to determine if the calculated equilibrium price vector locally maximizes profits.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="Prices-Methods_+3A_subset">subset</code></td>
<td>
<p>A vector of length k where each element equals TRUE if
the product indexed by that element should be included in the
post-merger simulation and FALSE if it should be excluded. Default is a
length k vector of TRUE.</p>
</td></tr>
<tr><td><code id="Prices-Methods_+3A_...">...</code></td>
<td>
<p>For Logit, additional values that may be used to change the
default values of <code><a href="BB.html#topic+BBsolve">BBsolve</a></code>, the non-linear equation solver.
</p>
<p>For others, additional values that may be used to change the default values of <code><a href="stats.html#topic+constrOptim">constrOptim</a></code>, the non-linear
equation solver used to enforce non-negative equilibrium quantities.</p>
</td></tr>
</table>

<hr>
<h2 id='PS-methods'>Producer Surplus Methods</h2><span id='topic+PS-methods'></span><span id='topic+calcProducerSurplus'></span><span id='topic+calcProducerSurplus+2CANY-method'></span><span id='topic+calcProducerSurplus+2CBertrand-method'></span><span id='topic+calcProducerSurplus+2CCournot-method'></span><span id='topic+calcProducerSurplus+2CVertBargBertLogit-method'></span><span id='topic+calcProducerSurplusGrimTrigger'></span><span id='topic+calcProducerSurplus+2CAuction2ndCap-method'></span><span id='topic+calcProducerSurplusGrimTrigger+2CBertrand-method'></span>

<h3>Description</h3>

<p>In the following methods, <code>calcProducerSurplus</code> computes the expected profits of each supplier
with the game depending on the class. The available classes are: Bertrand, Cournot, and Auction2ndCap.
</p>
<p><code>calcProducerSurplusGrimTrigger</code> is a method that
may be used to explore how a merger affects firms' incentives to collude.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Bertrand'
calcProducerSurplus(object, preMerger = TRUE)

## S4 method for signature 'VertBargBertLogit'
calcProducerSurplus(object, preMerger = TRUE)

## S4 method for signature 'Auction2ndCap'
calcProducerSurplus(object, preMerger = TRUE, exAnte = TRUE)

## S4 method for signature 'Cournot'
calcProducerSurplus(object, preMerger = TRUE)

## S4 method for signature 'Bertrand'
calcProducerSurplusGrimTrigger(
  object,
  coalition,
  discount,
  preMerger = TRUE,
  isCollusion = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PS-methods_+3A_object">object</code></td>
<td>
<p>An instance of one of the classes listed above.</p>
</td></tr>
<tr><td><code id="PS-methods_+3A_premerger">preMerger</code></td>
<td>
<p>If TRUE, returns pre-merger outcome. If FALSE, returns post-merger outcome. Default is TRUE.</p>
</td></tr>
<tr><td><code id="PS-methods_+3A_exante">exAnte</code></td>
<td>
<p>If &lsquo;exAnte&rsquo; equals TRUE then the
<em>ex ante</em> expected result for each firm is produced, while FALSE produces the
expected result conditional on each firm winning the auction. Default is TRUE.</p>
</td></tr>
<tr><td><code id="PS-methods_+3A_coalition">coalition</code></td>
<td>
<p>A length c vector of integers indicating the index of the products participating in the coalition.</p>
</td></tr>
<tr><td><code id="PS-methods_+3A_discount">discount</code></td>
<td>
<p>A length k vector of values between 0 and 1 that
represent the product-specific discount rate for all products
produced by firms particiapting in the coalition. NAs are allowed.</p>
</td></tr>
<tr><td><code id="PS-methods_+3A_iscollusion">isCollusion</code></td>
<td>
<p>TRUE recalculates demand and cost parameters under
the assumption that the coalition specified in &lsquo;coalition&rsquo; is
operating pre-merger. FALSE (the default) uses demand
and cost parameters calculated from the &lsquo;ownerPre&rsquo; matrix.</p>
</td></tr>
<tr><td><code id="PS-methods_+3A_...">...</code></td>
<td>
<p>Additional argument to pass to calcPrices (for <code>calcProducerSurplusGrimTrigger</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>calcProducerSurplusGrimTrigger calculates &lsquo;preMerger&rsquo; product
producer surplus (as well as other statistics &ndash; see below), under the
assumption that firms are playing an N-player iterated Prisoner's Dilemma where in each period a
coalition of firms decides whether to <em>cooperate</em> with
one another by setting the joint surplus maximizing price on some
&lsquo;coalition&rsquo; of their products, or <em>defect</em> from the coalition by setting all of their products'
prices to optimally undercut the prices of the coalition's products. Moreover, firms are assumed
to play Grim Trigger strategies where each firm cooperates in the
current period so long as <em>every</em> firm in the coalition cooperated last period and
defects otherwise. product level &lsquo;discount&rsquo; rates are then employed to determine
whether a firm's discounted surplus from remaining in the coalition are greater than
its surplus from optimally undercutting the coalition prices' for one
period plus its discounted surplus when all firms set Nash-Bertrand prices in all subsequent periods.
</p>


<h3>Value</h3>

<p><code>calcProducerSurplusGrimTrigger</code> returns a data frame with rows
equal to the number of products produced by any firm participating in
the coalition and the following 5 columns
</p>

<ul>
<li><p>Discount:The user-supplied discount rate
</p>
</li>
<li><p>Coord:Single period producer surplus from coordinating
</p>
</li>
<li><p>Defect:Single period producer surplus from defecting
</p>
</li>
<li><p>Punish:Single period producer surplus from punishing using Bertrand price
</p>
</li>
<li><p>IC:TRUE if the discounted producer surplus from coordinating across all firm products are
greater than the surplus from defecting across all firm products for one period and receiving
discounted Bertrand surplus for all subsequent periods under Grim Trigger.
</p>
</li></ul>


<hr>
<h2 id='Show-Methods'>Show Method</h2><span id='topic+Show-Methods'></span><span id='topic+show+2CAntitrust-method'></span><span id='topic+show+2CVertBargBertLogit-method'></span>

<h3>Description</h3>

<p>Displays the percentage change in prices due to the merger.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Antitrust'
show(object)

## S4 method for signature 'VertBargBertLogit'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Show-Methods_+3A_object">object</code></td>
<td>
<p>An instance of the Antitrust class.</p>
</td></tr>
</table>

<hr>
<h2 id='Sim-Functions'>Merger Simulation With User-Supplied Demand Parameters</h2><span id='topic+Sim-Functions'></span><span id='topic+sim'></span>

<h3>Description</h3>

<p>Simulates the price effects of a merger between two firms
with user-supplied demand parameters under the
assumption that all firms in the market are playing either a
differentiated products Bertrand pricing game, 2nd price (score) auction, or bargaining game.
</p>
<p>Let k denote the number of products produced by all firms below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim(
  prices,
  supply = c("bertrand", "auction", "bargaining", "bargaining2nd"),
  demand = c("Linear", "AIDS", "LogLin", "Logit", "CES", "LogitNests", "CESNests",
    "LogitCap"),
  demand.param,
  ownerPre,
  ownerPost,
  nests,
  capacities,
  mcDelta = rep(0, length(prices)),
  subset = rep(TRUE, length(prices)),
  insideSize = 1,
  priceOutside,
  priceStart,
  bargpowerPre = rep(0.5, length(prices)),
  bargpowerPost = bargpowerPre,
  labels = paste("Prod", 1:length(prices), sep = ""),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sim-Functions_+3A_prices">prices</code></td>
<td>
<p>A length k vector of product prices.</p>
</td></tr>
<tr><td><code id="Sim-Functions_+3A_supply">supply</code></td>
<td>
<p>A character string indicating how firms compete with one another. Valid
values are &quot;bertrand&quot; (Nash Bertrand),  &quot;auction2nd&quot;
(2nd score auction), &quot;bargaining&quot;, or &quot;bargaining2nd&quot;.</p>
</td></tr>
<tr><td><code id="Sim-Functions_+3A_demand">demand</code></td>
<td>
<p>A character string indicating the type of demand system
to be used in the merger simulation. Supported demand systems are
linear (&lsquo;Linear&rsquo;), log-linear(&lsquo;LogLin&rsquo;), logit (&lsquo;Logit&rsquo;), nested logit
(&lsquo;LogitNests&rsquo;), ces (&lsquo;CES&rsquo;), nested CES (&lsquo;CESNests&rsquo;) and capacity
constrained Logit (&lsquo;LogitCap&rsquo;).</p>
</td></tr>
<tr><td><code id="Sim-Functions_+3A_demand.param">demand.param</code></td>
<td>
<p>See Below.</p>
</td></tr>
<tr><td><code id="Sim-Functions_+3A_ownerpre">ownerPre</code></td>
<td>
<p>EITHER a vector of length k whose values
indicate which firm produced a product pre-merger OR
a k x k matrix of pre-merger ownership shares.</p>
</td></tr>
<tr><td><code id="Sim-Functions_+3A_ownerpost">ownerPost</code></td>
<td>
<p>EITHER a vector of length k whose values
indicate which firm produced a product after the merger OR
a k x k matrix of post-merger ownership shares.</p>
</td></tr>
<tr><td><code id="Sim-Functions_+3A_nests">nests</code></td>
<td>
<p>A length k vector identifying the nest that each
product belongs to. Must be supplied when &lsquo;demand&rsquo; equals &lsquo;CESNests&rsquo; and
&lsquo;LogitNests&rsquo;.</p>
</td></tr>
<tr><td><code id="Sim-Functions_+3A_capacities">capacities</code></td>
<td>
<p>A length k vector of product capacities. Must be
supplied when &lsquo;demand&rsquo; equals &lsquo;LogitCap&rsquo;.</p>
</td></tr>
<tr><td><code id="Sim-Functions_+3A_mcdelta">mcDelta</code></td>
<td>
<p>A vector of length k where each element equals the
proportional change in a product's marginal costs due to
the merger. Default is 0, which assumes that the merger does not
affect any products' marginal cost.</p>
</td></tr>
<tr><td><code id="Sim-Functions_+3A_subset">subset</code></td>
<td>
<p>A vector of length k where each element equals TRUE if
the product indexed by that element should be included in the
post-merger simulation and FALSE if it should be excluded.Default is a
length k vector of TRUE.</p>
</td></tr>
<tr><td><code id="Sim-Functions_+3A_insidesize">insideSize</code></td>
<td>
<p>A length 1 vector equal to total units sold if &lsquo;demand&rsquo; equals &quot;logit&quot;, or total revenues if
&lsquo;demand&rsquo; equals &quot;ces&quot;.</p>
</td></tr>
<tr><td><code id="Sim-Functions_+3A_priceoutside">priceOutside</code></td>
<td>
<p>A length 1 vector indicating the price of the
outside good. This option only applies to the &lsquo;Logit&rsquo; class and its child classes
Default for &lsquo;Logit&rsquo;,&lsquo;LogitNests&rsquo;, and &lsquo;LogitCap&rsquo; is 0,
and for &lsquo;CES&rsquo; and &lsquo;CesNests&rsquo; is 1.</p>
</td></tr>
<tr><td><code id="Sim-Functions_+3A_pricestart">priceStart</code></td>
<td>
<p>A length k vector of starting values used to solve for
equilibrium price. Default is the &lsquo;prices&rsquo; vector for all values of
demand except for &lsquo;AIDS&rsquo;, which is set equal to a vector of 0s.</p>
</td></tr>
<tr><td><code id="Sim-Functions_+3A_bargpowerpre">bargpowerPre</code></td>
<td>
<p>A length k vector of pre-merger bargaining power parameters. Values
must be between 0 (sellers have the power) and 1 (buyers the power). Ignored if &lsquo;supply&rsquo; not equal
to &quot;bargaining&quot; or bargaining2nd.</p>
</td></tr>
<tr><td><code id="Sim-Functions_+3A_bargpowerpost">bargpowerPost</code></td>
<td>
<p>A length k vector of post-merger bargaining power parameters. Values
must be between 0 (sellers have the power) and 1 (buyers the power). Default is &lsquo;bargpowerPre&rsquo;.
Ignored if &lsquo;supply&rsquo; not equal to &quot;bargaining&quot;.</p>
</td></tr>
<tr><td><code id="Sim-Functions_+3A_labels">labels</code></td>
<td>
<p>A k-length vector of labels. Default is &ldquo;Prod#&rdquo;, where
&lsquo;#&rsquo; is a number between 1 and the length of &lsquo;prices&rsquo;.</p>
</td></tr>
<tr><td><code id="Sim-Functions_+3A_...">...</code></td>
<td>
<p>Additional options to feed to the
optimizer used to solve for equilibrium prices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using user-supplied demand parameters,
<code>sim</code> simulates the effects of a merger in a market where
firms are playing a differentiated products pricing game.
</p>
<p>If &lsquo;demand&rsquo; equals &lsquo;Linear&rsquo;, &lsquo;LogLin&rsquo;, or
&lsquo;AIDS&rsquo;, then &lsquo;demand.param&rsquo; must be a
list containing &lsquo;slopes&rsquo;, a k x k matrix of slope coefficients, and
&lsquo;intercepts&rsquo;, a length-k vector of intercepts. Additionally, if
&lsquo;demand&rsquo; equals &lsquo;AIDS&rsquo;, &lsquo;demand.param&rsquo; must contain &lsquo;mktElast&rsquo;, an
estimate of aggregate market elasticity.  For &lsquo;Linear&rsquo;
demand models, <code>sim</code> returns an error if any intercepts are
negative, and for both &lsquo;Linear&rsquo;, &lsquo;LogLin&rsquo;, and &lsquo;AIDS&rsquo; models,  <code>sim</code>
returns an error if not all diagonal elements of the slopes matrix are
negative.
</p>
<p>If &lsquo;demand&rsquo; equals &lsquo;Logit&rsquo; or &lsquo;LogitNests&rsquo;, then
&lsquo;demand.param&rsquo; must equal a list containing
</p>

<ul>
<li><p>alphaThe price coefficient.
</p>
</li>
<li><p>meanvalA length-k vector of mean valuations &lsquo;meanval&rsquo;. If
none of the values of &lsquo;meanval&rsquo; are zero, an outside good is assumed
to exist.
</p>
</li></ul>

<p>If demand equals &lsquo;CES&rsquo; or &lsquo;CESNests&rsquo;, then
&lsquo;demand.param&rsquo; must equal a list containing
</p>

<ul>
<li><p>gamma The price coefficient,
</p>
</li>
<li><p>alphaThe coefficient on the numeraire good. May instead be
calibrated using &lsquo;shareInside&rsquo;,
</p>
</li>
<li><p>meanvalA length-k vector of mean valuations &lsquo;meanval&rsquo;. If
none of the values of &lsquo;meanval&rsquo; are zero, an outside good is assumed
to exist,
</p>
</li>
<li><p>shareInside The budget share of all products in the
market. Default is 1, meaning that all consumer wealth is spent on
products in the market. May instead be specified using &lsquo;alpha&rsquo;.
</p>
</li></ul>



<h3>Value</h3>

<p><code>sim</code> returns an instance of the class specified by the
&lsquo;demand&rsquo; argument.
</p>


<h3>Author(s)</h3>

<p>Charles Taragin <a href="mailto:ctaragin+antitrustr@gmail.com">ctaragin+antitrustr@gmail.com</a>
</p>


<h3>See Also</h3>

<p>The S4 class documentation for: <code><a href="#topic+Linear-class">Linear</a></code>,
<code><a href="#topic+AIDS-class">AIDS</a></code>, <code><a href="#topic+LogLin-class">LogLin</a></code>, <code><a href="#topic+Logit-class">Logit</a></code>,
<code><a href="#topic+LogitNests-class">LogitNests</a></code>, <code><a href="#topic+CES-class">CES</a></code>, <code><a href="#topic+CESNests-class">CESNests</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Calibration and simulation results from a merger between Budweiser and
## Old Style. Note that the in the following model there is no outside
## good; BUD's mean value has been normalized to zero.

## Source: Epstein/Rubenfeld 2004, pg 80


prodNames &lt;- c("BUD","OLD STYLE","MILLER","MILLER-LITE","OTHER-LITE","OTHER-REG")
ownerPre &lt;-c("BUD","OLD STYLE","MILLER","MILLER","OTHER-LITE","OTHER-REG")
ownerPost &lt;-c("BUD","BUD","MILLER","MILLER","OTHER-LITE","OTHER-REG")
nests &lt;- c("Reg","Reg","Reg","Light","Light","Reg")

price    &lt;- c(.0441,.0328,.0409,.0396,.0387,.0497)

demand.param=list(alpha=-48.0457,
                  meanval=c(0,0.4149233,1.1899885,0.8252482,0.1460183,1.4865730)
)

sim.logit &lt;- sim(price,supply="bertrand",demand="Logit",demand.param,
                 ownerPre=ownerPre,ownerPost=ownerPost)



print(sim.logit)           # return predicted price change
summary(sim.logit)         # summarize merger simulation

elast(sim.logit,TRUE)      # returns premerger elasticities
elast(sim.logit,FALSE)     # returns postmerger elasticities

diversion(sim.logit,TRUE)  # return premerger diversion ratios
diversion(sim.logit,FALSE) # return postmerger diversion ratios


cmcr(sim.logit)            #calculate compensating marginal cost reduction
upp(sim.logit)             #calculate Upwards Pricing Pressure Index

CV(sim.logit)              #calculate representative agent compensating variation

</code></pre>

<hr>
<h2 id='summary-methods'>Summary Methods</h2><span id='topic+summary-methods'></span><span id='topic+summary+2CANY-method'></span><span id='topic+summary+2CAIDS-method'></span><span id='topic+summary+2CBertrand-method'></span><span id='topic+summary+2CAuction2ndLogit-method'></span><span id='topic+summary+2CCournot-method'></span><span id='topic+summary+2CAuction2ndCap-method'></span><span id='topic+summary+2CVertBargBertLogit-method'></span>

<h3>Description</h3>

<p>Summary methods for the <code>Bertrand</code>, <code>Auction2ndCap</code>,  <code>Cournot</code>, and <code>Auction2ndLogit</code> classes.
Summarizes the effect of the merger, including price and revenue changes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Bertrand'
summary(
  object,
  revenue = TRUE,
  shares = TRUE,
  levels = FALSE,
  parameters = FALSE,
  market = FALSE,
  insideOnly = TRUE,
  digits = 2,
  ...
)

## S4 method for signature 'VertBargBertLogit'
summary(
  object,
  revenue = TRUE,
  levels = FALSE,
  parameters = FALSE,
  market = FALSE,
  insideOnly = TRUE,
  digits = 2,
  ...
)

## S4 method for signature 'Auction2ndCap'
summary(object, exAnte = FALSE, parameters = FALSE, market = TRUE, digits = 2)

## S4 method for signature 'Cournot'
summary(
  object,
  market = FALSE,
  revenue = FALSE,
  shares = FALSE,
  levels = FALSE,
  parameters = FALSE,
  digits = 2,
  ...
)

## S4 method for signature 'Auction2ndLogit'
summary(object, levels = TRUE, revenue = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary-methods_+3A_object">object</code></td>
<td>
<p>an instance of class  <code>Bertrand</code>, <code>Auction2ndCap</code>, <code>Cournot</code>, or <code>Auction2ndLogit</code></p>
</td></tr>
<tr><td><code id="summary-methods_+3A_revenue">revenue</code></td>
<td>
<p>When TRUE, returns revenues, when FALSE returns quantitities. Default is TRUE.</p>
</td></tr>
<tr><td><code id="summary-methods_+3A_shares">shares</code></td>
<td>
<p>When TRUE, returns shares, when FALSE returns quantities (when possible). Default is TRUE.</p>
</td></tr>
<tr><td><code id="summary-methods_+3A_levels">levels</code></td>
<td>
<p>When TRUE, returns changes in levels rather than percents and quantities rather than shares, when FALSE, returns
changes as a percent and shares rather than quantities. Default is FALSE.</p>
</td></tr>
<tr><td><code id="summary-methods_+3A_parameters">parameters</code></td>
<td>
<p>When TRUE, displays all demand parameters. Default is FALSE.</p>
</td></tr>
<tr><td><code id="summary-methods_+3A_market">market</code></td>
<td>
<p>When TRUE, displays aggregate information about the effect of a tariff.
When FALSE displays product-specific (or in the case of Cournot, plant-specific) effects.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="summary-methods_+3A_insideonly">insideOnly</code></td>
<td>
<p>When TRUE, rescales shares on inside goods to sum to 1. Default is FALSE.</p>
</td></tr>
<tr><td><code id="summary-methods_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits to report. Default is 2.</p>
</td></tr>
<tr><td><code id="summary-methods_+3A_...">...</code></td>
<td>
<p>Allows other objects to be passed to a <code>CV</code> method.</p>
</td></tr>
<tr><td><code id="summary-methods_+3A_exante">exAnte</code></td>
<td>
<p>If &lsquo;exAnte&rsquo; equals TRUE then the
<em>ex ante</em> expected result for each firm is produced, while FALSE produces the
expected result conditional on each firm winning the auction. Default is FALSE.</p>
</td></tr>
</table>

<hr>
<h2 id='SupplyChain-Functions'>Supply Chain Merger Simulation</h2><span id='topic+SupplyChain-Functions'></span><span id='topic+vertical'></span><span id='topic+vertical.barg'></span>

<h3>Description</h3>

<p>Calibrates consumer demand using (Nested) Logit
and then simulates the price effect of a merger between two firms
under the assumption that all firms in the market are playing a
differentiated products Bertrand pricing game.
</p>
<p>Let k denote the number of products produced by all
firms playing the Bertrand pricing game below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertical.barg(
  supplyDown = c("bertrand", "2nd"),
  sharesDown,
  pricesDown,
  marginsDown,
  ownerPreDown,
  ownerPostDown,
  nests = rep(NA, length(pricesDown)),
  diversions = diversions,
  mcDeltaDown = rep(0, length(pricesDown)),
  pricesUp,
  marginsUp,
  ownerPreUp,
  ownerPostUp,
  mcDeltaUp = rep(0, length(pricesUp)),
  normIndex = ifelse(isTRUE(all.equal(sum(sharesDown), 1, check.names = FALSE)), 1, NA),
  subset = rep(TRUE, length(pricesDown)),
  insideSize = NA_real_,
  priceOutside = 0,
  priceStartDown = pricesDown,
  priceStartUp = pricesUp,
  isMax = FALSE,
  constrain = c("global", "pair", "wholesaler", "retailer"),
  control.slopes,
  control.equ,
  labels = paste0("Prod", 1:length(pricesUp)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SupplyChain-Functions_+3A_supplydown">supplyDown</code></td>
<td>
<p>A length 1 character vector that specifies whether the downstream
game that firms are playing is a Nash-Bertrand Pricing game (&quot;bertrand&rdquo;) or a 2nd score 
auction (&quot;2nd&quot;). Default is &quot;bertrand&quot;.</p>
</td></tr>
<tr><td><code id="SupplyChain-Functions_+3A_sharesdown">sharesDown</code></td>
<td>
<p>A length k vector of product (quantity) shares. Values must be
between 0 and 1.</p>
</td></tr>
<tr><td><code id="SupplyChain-Functions_+3A_pricesdown">pricesDown</code></td>
<td>
<p>A length k vector of downstream product prices.</p>
</td></tr>
<tr><td><code id="SupplyChain-Functions_+3A_marginsdown">marginsDown</code></td>
<td>
<p>A length k vector of downstream product margins in levels (e.g. dollars), some of which may
equal NA.</p>
</td></tr>
<tr><td><code id="SupplyChain-Functions_+3A_ownerpredown">ownerPreDown</code></td>
<td>
<p>A vector of length k whose values
indicate which downstream firm produced a product pre-merger.</p>
</td></tr>
<tr><td><code id="SupplyChain-Functions_+3A_ownerpostdown">ownerPostDown</code></td>
<td>
<p>A vector of length k whose values
indicate which downstream firm produced a product post-merger.</p>
</td></tr>
<tr><td><code id="SupplyChain-Functions_+3A_nests">nests</code></td>
<td>
<p>A length k factor of product nests.</p>
</td></tr>
<tr><td><code id="SupplyChain-Functions_+3A_diversions">diversions</code></td>
<td>
<p>A k x k matrix of diversion ratios with diagonal
elements equal to -1. Default is missing, in which case diversion
according to share is assumed.</p>
</td></tr>
<tr><td><code id="SupplyChain-Functions_+3A_mcdeltadown">mcDeltaDown</code></td>
<td>
<p>A vector of length k where each element equals the
proportional change in a downstream firm's product-level marginal costs due to
the merger. Default is 0, which assumes that the merger does not
affect any products' marginal cost.</p>
</td></tr>
<tr><td><code id="SupplyChain-Functions_+3A_pricesup">pricesUp</code></td>
<td>
<p>A length k vector of upstream product prices.</p>
</td></tr>
<tr><td><code id="SupplyChain-Functions_+3A_marginsup">marginsUp</code></td>
<td>
<p>A length k vector of upstream product margins in levels (e.g. dollars), some of which may
equal NA.</p>
</td></tr>
<tr><td><code id="SupplyChain-Functions_+3A_ownerpreup">ownerPreUp</code></td>
<td>
<p>A vector of length k whose values
indicate which upstream firm produced a product pre-merger.</p>
</td></tr>
<tr><td><code id="SupplyChain-Functions_+3A_ownerpostup">ownerPostUp</code></td>
<td>
<p>A vector of length k whose values
indicate which upstream firm produced a product after the merger.</p>
</td></tr>
<tr><td><code id="SupplyChain-Functions_+3A_mcdeltaup">mcDeltaUp</code></td>
<td>
<p>A vector of length k where each element equals the
proportional change in a upstream firm's product-level marginal costs due to
the merger. Default is 0, which assumes that the merger does not
affect any products' marginal cost.</p>
</td></tr>
<tr><td><code id="SupplyChain-Functions_+3A_normindex">normIndex</code></td>
<td>
<p>An integer equalling the index (position) of the
inside product whose mean valuation will be normalized to 1. Default
is 1, unless &lsquo;shares&rsquo; sum to less than 1, in which case the default is
NA and an outside good is assumed to exist.</p>
</td></tr>
<tr><td><code id="SupplyChain-Functions_+3A_subset">subset</code></td>
<td>
<p>A vector of length k where each element equals TRUE if
the product indexed by that element should be included in the
post-merger simulation and FALSE if it should be excluded.Default is a
length k vector of TRUE.</p>
</td></tr>
<tr><td><code id="SupplyChain-Functions_+3A_insidesize">insideSize</code></td>
<td>
<p>An integer equal to total pre-merger units sold.
If shares sum to one, this also equals the size of the market.</p>
</td></tr>
<tr><td><code id="SupplyChain-Functions_+3A_priceoutside">priceOutside</code></td>
<td>
<p>A length 1 vector indicating the price of the
outside good. Default is 0.</p>
</td></tr>
<tr><td><code id="SupplyChain-Functions_+3A_pricestartdown">priceStartDown</code></td>
<td>
<p>A length k vector of starting values used to solve for
downstream equilibrium prices. Default is the &lsquo;pricesDown&rsquo; vector.</p>
</td></tr>
<tr><td><code id="SupplyChain-Functions_+3A_pricestartup">priceStartUp</code></td>
<td>
<p>A length k vector of starting values used to solve for
upstream equilibrium price. Default is the &lsquo;pricesUp&rsquo; vector.</p>
</td></tr>
<tr><td><code id="SupplyChain-Functions_+3A_ismax">isMax</code></td>
<td>
<p>If TRUE, checks to see whether computed price equilibrium
locally maximizes firm profits and returns a warning if not. Default is FALSE.</p>
</td></tr>
<tr><td><code id="SupplyChain-Functions_+3A_constrain">constrain</code></td>
<td>
<p>Specify calibration strategy for estimating bargaining power parameter. 
&quot;global&quot; (default) assumes bargaining parameter is the same across all participants,&quot;pair&quot; assumes 
that all wholesaler/retailer pairs have a distinct parameter,&quot;wholesaler&quot; assumes that each wholesaler's
parameter is identical across negotiations, &quot;retailer&quot; assumes that each 
retailer's parameter is identical across negotiations.</p>
</td></tr>
<tr><td><code id="SupplyChain-Functions_+3A_control.slopes">control.slopes</code></td>
<td>
<p>A list of  <code><a href="stats.html#topic+optim">optim</a></code>
control parameters passed to the calibration routine
optimizer (typically the <code>calcSlopes</code> method).</p>
</td></tr>
<tr><td><code id="SupplyChain-Functions_+3A_control.equ">control.equ</code></td>
<td>
<p>A list of  <code><a href="BB.html#topic+BBsolve">BBsolve</a></code> control parameters
passed to the non-linear equation solver (typically the <code>calcPrices</code> method).</p>
</td></tr>
<tr><td><code id="SupplyChain-Functions_+3A_labels">labels</code></td>
<td>
<p>A k-length vector of labels. Default is &quot;Prod#&quot;, where
&lsquo;#&rsquo; is a number between 1 and the length of &lsquo;prices&rsquo;.</p>
</td></tr>
<tr><td><code id="SupplyChain-Functions_+3A_...">...</code></td>
<td>
<p>Additional options to feed to the <code><a href="BB.html#topic+BBsolve">BBsolve</a></code>
optimizer used to solve for equilibrium prices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using product prices, quantity shares and all of the
product margins from at least one firm, <code>logit</code> is able to
recover the price coefficient and product mean valuations in a
Logit demand model. <code>logit</code> then uses these
calibrated parameters to simulate a merger between two firms.
</p>


<h3>Value</h3>

<p>When 'supplyDown' equals &quot;bertand&quot;, <code>vertical.barg</code> returns an instance of class
<code><a href="#topic+VertBargBertLogit-class">VertBargBertLogit</a></code>. When 'supplyDown' equals &quot;2nd&quot;, <code>vertical.barg</code> returns an instance of class
<code><a href="#topic+VertBarg2ndLogit-class">VertBarg2ndLogit</a></code>
</p>


<h3>Author(s)</h3>

<p>Charles Taragin <a href="mailto:ctaragin+antitrustr@gmail.com">ctaragin+antitrustr@gmail.com</a>
</p>


<h3>References</h3>

<p>Sheu, G. and Taragin, C. (2021), Simulating mergers in a vertical supply chain with bargaining. The RAND Journal of Economics, 52: 596-632.doi: <a href="https://doi.org/10.1111/1756-2171.12385">10.1111/1756-2171.12385</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Vertical supply with 2 upstream firms,
## 2 downstream firms, each offering 
## a single product.

shareDown &lt;- c( 0.1293482, 0.1422541, 0.4631014, 0.2152962)
marginDown &lt;- c( 0.2067533, 0.2572215, 0.3082511, 0.3539681)
priceDown &lt;- c( 63.08158, 50.70465, 95.82960, 83.45267)
ownerPreDown &lt;- paste0("D",rep(c(1,2),each=2))
marginUp &lt;- c(0.5810900, 0.5331135, 0.5810900, 0.5331135)
priceUp &lt;- c( 40.11427, 27.73734, 40.11427, 27.73734)
ownerPreUp &lt;- paste0("U",rep(c(1,2),2))
priceOutSide &lt;- 10


## Simulate an upstream horizontal merger
ownerPostDown &lt;- ownerPreDown
ownerPostUp &lt;- rep("U1",length(ownerPreUp))


simres_up &lt;- vertical.barg(sharesDown =shareDown,
pricesDown = priceDown,
marginsDown = marginDown,
ownerPreDown = ownerPreDown,
ownerPostDown = ownerPreDown,
pricesUp = priceUp,
marginsUp = marginUp,
ownerPreUp = ownerPreUp,
ownerPostUp = ownerPostUp,
priceOutside = priceOutSide)


print(simres_up)
summary(simres_up)

## Simulate a downstream horizontal merger
ownerPostUp &lt;- ownerPreUp
ownerPostDown &lt;- ownerPreDown
ownerPostDown &lt;- rep("D1",length(ownerPreDown))

simres_down &lt;- vertical.barg(sharesDown =shareDown,
pricesDown = priceDown,
marginsDown = marginDown,
ownerPreDown = ownerPreDown,
ownerPostDown = ownerPostDown,
pricesUp = priceUp,
marginsUp = marginUp,
ownerPreUp = ownerPreUp,
ownerPostUp = ownerPreUp,
priceOutside = priceOutSide)


print(simres_down)
summary(simres_down)


## Simulate a vertical merger
ownerPostUp &lt;- ownerPreUp
ownerPostDown &lt;- ownerPreDown
ownerPostDown[ownerPostDown == "D1"] &lt;- "U1"

simres_vert &lt;- vertical.barg(sharesDown =shareDown,
pricesDown = priceDown,
marginsDown = marginDown,
ownerPreDown = ownerPreDown,
ownerPostDown = ownerPostDown,
pricesUp = priceUp,
marginsUp = marginUp,
ownerPreUp = ownerPreUp,
ownerPostUp = ownerPreUp,
priceOutside = priceOutSide)


print(simres_vert)
summary(simres_vert)
</code></pre>

<hr>
<h2 id='UPP-Methods'>Methods For Calculating Upwards Pricing Pressure Index (Bertrand)</h2><span id='topic+UPP-Methods'></span><span id='topic+upp-methods'></span><span id='topic+upp+2CANY-method'></span><span id='topic+upp+2CBertrand-method'></span><span id='topic+upp+2CAIDS-method'></span><span id='topic+upp+2CAuction2ndLogit-method'></span>

<h3>Description</h3>

<p>Calculate the Upwards Pricing Pressure Index
for the products of merging firms playing a differentiated
products Bertrand pricing game.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Bertrand'
upp(object)

## S4 method for signature 'AIDS'
upp(object)

## S4 method for signature 'Auction2ndLogit'
upp(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UPP-Methods_+3A_object">object</code></td>
<td>
<p>An instance of one of the classes listed above.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>upp</code> uses the results from the merger simulation and
calibration to compute the upwards pricing pressure of the merger on
each merging parties' products.
</p>


<h3>Value</h3>

<p><code>upp</code> returns a vector of length k equal to the  net UPP for the
merging parties' products and 0 for all other products.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+upp.bertrand">upp.bertrand</a></code> calculates net UPP
without the need to first calibrate a demand system and simulate a merger.
</p>

<hr>
<h2 id='Vertical-Classes'>&ldquo;Vertical&rdquo; Classes</h2><span id='topic+Vertical-Classes'></span><span id='topic+VertBargBertLogit'></span><span id='topic+VertBarg2ndLogit'></span><span id='topic+VertBargBertLogitNests'></span><span id='topic+VertBarg2ndLogitNests'></span><span id='topic+VertBargBertLogit-class'></span><span id='topic+VertBarg2ndLogit-class'></span><span id='topic+VertBarg2ndLogitNests-class'></span>

<h3>Description</h3>

<p>The &ldquo;Vertical&rdquo; classes are building blocks used to create other classes
in this package. As such, it is most likely to be useful for developers
who wish to code their own calibration/simulation routines.
</p>
<p>The &ldquo;VertBargBertLogit&rdquo; class has the information for a Vertical Supply Chain with Logit demand and a downstream Nash-Bertrand Pricing game.
</p>
<p>The &ldquo;VertBarg2ndLogit&rdquo; class has the information fora Vertical Supply Chain with Logit demand and a downstream 2nd Score Auction.
</p>


<h3>Slots</h3>


<dl>
<dt><code>up</code></dt><dd><p>an instance of &ldquo;Bargaining&rdquo; class.</p>
</dd>
<dt><code>down</code></dt><dd><p>For  &ldquo;VertBargBertLogit&rdquo;, an instance of  &ldquo;Logit&rdquo; class.For  &ldquo;VertBarg2ndLogit&rdquo;, an instance of  &ldquo;Auction2ndLogit&rdquo; class.</p>
</dd>
<dt><code>constrain</code></dt><dd><p>A length 1 character vector equal to &quot;global&quot;, &quot;pair&quot;, &quot;wholesaler&quot;, or &quot;retailer.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Charles Taragin <a href="mailto:ctaragin+antitrustr@gmail.com">ctaragin+antitrustr@gmail.com</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
