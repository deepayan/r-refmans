<!DOCTYPE html><html><head><title>Help for package cfid</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cfid}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cfid-package'><p>The <code>cfid</code> package</p></a></li>
<li><a href='#causal_effect'><p>Causal Effect Identification</p></a></li>
<li><a href='#counterfactual_conjunction'><p>Counterfactual Conjunction</p></a></li>
<li><a href='#dag'><p>Directed Acyclic Graph</p></a></li>
<li><a href='#export_graph'><p>Export Graph</p></a></li>
<li><a href='#functional'><p>Identifying Functional of a Counterfactual Query</p></a></li>
<li><a href='#identifiable'><p>Identify a Counterfactual Query</p></a></li>
<li><a href='#import_graph'><p>Import Graph</p></a></li>
<li><a href='#probability'><p>Symbolic Probability Distributions</p></a></li>
<li><a href='#query'><p>Query Objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Identification of Counterfactual Queries in Causal Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.7</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Santtu Tikka &lt;santtuth@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Facilitates the identification of counterfactual queries in
 structural causal models via the ID* and IDC* algorithms
 by Shpitser, I. and Pearl, J. (2007, 2008) &lt;<a href="https://doi.org/10.48550/arXiv.1206.5294">doi:10.48550/arXiv.1206.5294</a>&gt;, 
 <a href="https://jmlr.org/papers/v9/shpitser08a.html">https://jmlr.org/papers/v9/shpitser08a.html</a>. 
 Provides a simple interface for defining causal diagrams and counterfactual 
 conjunctions. Construction of parallel worlds graphs and counterfactual graphs 
 is carried out automatically based on the counterfactual query and the causal 
 diagram. See Tikka, S. (2023) &lt;<a href="https://doi.org/10.32614%2FRJ-2023-053">doi:10.32614/RJ-2023-053</a>&gt; for a tutorial of 
 the package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/santikka/cfid">https://github.com/santikka/cfid</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, dagitty, igraph, mockery, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-27 15:16:28 UTC; santikka</td>
</tr>
<tr>
<td>Author:</td>
<td>Santtu Tikka <a href="https://orcid.org/0000-0003-4039-4342"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-27 16:00:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='cfid-package'>The <code>cfid</code> package</h2><span id='topic+cfid-package'></span>

<h3>Description</h3>

<p>Identification of Counterfactual Queries in Causal Models
</p>


<h3>Details</h3>

<p>This package provides tools necessary for identifying counterfactual
queries in causal models. Causal graphs, counterfactual variables,
and counterfactual conjunctions are defined via simple interfaces.
</p>


<h3>Counterfactuals</h3>

<p>In simple terms, counterfactual are statements involving multiple
conceptual &quot;worlds&quot; where the observed state of the worlds is different.
As an example, consider two variables, Y = &quot;headache&quot;, and X = &quot;aspirin&quot;.
A counterfactual statement could be &quot;If I have a headache and did not take
aspirin, would I not have a headache, had I taken aspirin instead&quot;.
This statement involves two worlds: the real or &quot;actual&quot; world, where
aspirin was not taken, and a hypothetical world, where it was taken.
In more formal terms, this statement involves a counterfactual variable
<code class="reqn">Y_x</code> that attains two different values in two different worlds, forming
a counterfactual conjunction: <code class="reqn">y_x \wedge y'_{x'}</code>, where <code class="reqn">y</code> and
<code class="reqn">y'</code> are two different values of <code class="reqn">Y</code>, and <code class="reqn">x</code> and <code class="reqn">x'</code> are
two different values of <code class="reqn">X</code>.
</p>


<h3>Identifiability</h3>

<p>Pearl's ladder of causation consists of the associational,
interventional and counterfactual levels, with counterfactual being
the highest level. The goal of identification is to find a transformation
of a higher level query into a lower level one.
For the interventional case, this transformation is known as causal effect
identifiability, where interventional distributions are expressed in terms
of observational quantities. Tools for this type of identification are
readily available,
such as in the <code>causaleffect</code>, <code>dagitty</code>, <code>pcalg</code>, and <code>dosearch</code>
packages. Transformation from the highest counterfactual level, is more
difficult, both conceptually and computationally, since to reach the
observational level, we must first find a transformation of our
counterfactual query into a interventional query, and then transform this
yet again to observational. Also, there transformations may not always
exist, for example in the presence of latent unobserved confounders, meaning
that the queries are non-identifiable. This package deals with the first
transformation, i.e., expressing the counterfactual queries in terms of
interventional queries (and observational, when possible), as well as the
second one, transforming interventional distributions to observational
quantities.
</p>


<h3>Algorithms</h3>

<p>Identification is carried out in terms of <code class="reqn">G</code> and <code class="reqn">P_*</code> and where
<code class="reqn">G</code> is a directed acyclic graph (DAG) depicting the causal model
in question (a causal graph for short), and
<code class="reqn">P_*</code> is the set of all interventional distributions
in causal models inducing <code class="reqn">G</code>. Identification is carried
out by the ID* and IDC* algorithms by Shpitser and Pearl (2008) which aim to
convert the input counterfactual probability into an expression which can
be represented solely in terms of interventional distributions. These
algorithms are sound and complete, meaning that their output is always
correct, and in the case of a non-identifiable counterfactual, one can
always construct a counterexample, witnessing non-identifiability.
</p>


<h3>Graphs</h3>

<p>The causal graph associated with the causal model is given via a simple
text-based interface, similar to <code>dagitty</code> package syntax. Directed edges
are given as <code>X -&gt; Y</code>, and bidirected edges as <code style="white-space: pre;">&#8288;X &lt;-&gt; Y&#8288;</code>, which is a
shorthand notation for latent confounders. For more details on graph
construction, see <code><a href="#topic+dag">dag()</a></code>.
</p>


<h3>Counterfactual variables and conjunctions</h3>

<p>Counterfactual variables are defined by their name, value and the conceptual
world that they belong to. A world is defined by a unique set of actions
(interventions) via the do-operator (Pearl, 2009). We can define the two
counterfactual variables of the headache/aspirin example as follows:
</p>
<div class="sourceCode"><pre>cf(var = "Y", obs = 0, sub = c(X = 0))
cf(var = "Y", obs = 1, sub = c(X = 1))
</pre></div>
<p>Here, <code>var</code> defines the name of the variable, <code>obs</code> gives level the variable
is assigned to (not the actual value), and <code>sub</code> defines the vector of
interventions that define the counterfactual world. For more details,
see <code><a href="#topic+counterfactual_variable">counterfactual_variable()</a></code>. Counterfactual conjunctions on the
other hand, are simply counterfactual statements (variables) that are
observed at the same time. For more details, see
<code><a href="#topic+counterfactual_conjunction">counterfactual_conjunction()</a></code>.
</p>
<p>For complete examples of identifiable counterfactual queries, see
<code><a href="#topic+identifiable">identifiable()</a></code>, which is the main function of the package.
</p>


<h3>References</h3>

<p>Tikka, S. (2023).
Identifying counterfactual queries with the R package <code>cfid</code>.
<em>The R Journal</em>, <strong>15(2)</strong>:330&ndash;343.
</p>
<p>Pearl, J. (1995) Causal diagrams for empirical research. <em>Biometrika</em>,
<strong>82(4)</strong>:669&ndash;688.
</p>
<p>Pearl, J. (2009) <em>Causality: Models, Reasoning, and Inference</em>. Cambridge
University Press, 2nd edition.
</p>
<p>Shpitser, I. and Pearl, J. (2007). What counterfactuals can be tested.
In <em>Proceedings of the 23rd Conference on Uncertainty</em>
<em>in Artificial Intelligence</em>, 352&ndash;359.
</p>
<p>Shpitser, I. and Pearl, J. (2008). Complete identification
methods for the causal hierarchy. <em>Journal of Machine Learning Research</em>,
<strong>9(64)</strong>:1941&ndash;1979.
</p>
<p>Makhlouf, K., Zhioua, S. and Palamidessi, C. (2021).
Survey on causal-based machine learning fairness notions.
<em>arXiv:2010.09553</em>
</p>

<hr>
<h2 id='causal_effect'>Causal Effect Identification</h2><span id='topic+causal_effect'></span>

<h3>Description</h3>

<p>Identify a causal effect of the form <code class="reqn">P(y|do(x),z)</code> from <code class="reqn">P(v)</code> in
<code class="reqn">G</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>causal_effect(g, y, x = character(0), z = character(0), v = integer(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="causal_effect_+3A_g">g</code></td>
<td>
<p>A <code>dag</code> object depicting the causal diagram <code class="reqn">G</code>.</p>
</td></tr>
<tr><td><code id="causal_effect_+3A_y">y</code></td>
<td>
<p>A <code>character</code> vector of response variables <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code id="causal_effect_+3A_x">x</code></td>
<td>
<p>A <code>character</code> vector of intervention variables <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="causal_effect_+3A_z">z</code></td>
<td>
<p>An optional <code>character</code> vector of conditioning variables <code class="reqn">Z</code>.</p>
</td></tr>
<tr><td><code id="causal_effect_+3A_v">v</code></td>
<td>
<p>An optional named <code>integer</code> vector giving the value assignments
for observed variables in the model, i.e. <code class="reqn">V = v</code> or
for a subset of <code class="reqn">V</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>query</code> which is a <code>list</code> with the following
components:
</p>

<ul>
<li> <p><code>id</code><br /> A <code>logical</code> value that is <code>TRUE</code> if the query is identifiable and
<code>FALSE</code> otherwise.
</p>
</li>
<li> <p><code>formula</code><br /> A  <code>functional</code> object expressing the causal effect in terms
of the joint probability distribution <code class="reqn">P(v)</code> for identifiable queries
or <code>NULL</code> if the query is not identifiable.
</p>
</li>
<li> <p><code>data</code><br /> The available data, for <code>causal_effect</code> this is always
<code>"observations"</code>
</p>
</li>
<li> <p><code>causaleffect</code><br /> The original query <code class="reqn">P(y|do(x),z)</code> as a <code>probability</code>
object.
</p>
</li>
<li> <p><code>undefined</code><br /> A <code>logical</code> value, this is always <code>FALSE</code> for
<code>causaleffect</code>
</p>
</li></ul>


<hr>
<h2 id='counterfactual_conjunction'>Counterfactual Conjunction</h2><span id='topic+counterfactual_conjunction'></span><span id='topic+format.counterfactual_conjunction'></span><span id='topic+print.counterfactual_conjunction'></span><span id='topic++2B.counterfactual_conjunction'></span><span id='topic++5B.counterfactual_conjunction'></span><span id='topic++2B.counterfactual_variable'></span><span id='topic+conj'></span><span id='topic+counterfactual_variable'></span><span id='topic+format.counterfactual_variable'></span><span id='topic+print.counterfactual_variable'></span><span id='topic+cf'></span>

<h3>Description</h3>

<p><code>conj</code> defines a conjunction of counterfactual statements (variables).
</p>
<p><code>cf</code> defines a counterfactual variable <code class="reqn">y_x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>counterfactual_conjunction(...)

## S3 method for class 'counterfactual_conjunction'
format(x, var_sep = " /\\ ", ...)

## S3 method for class 'counterfactual_conjunction'
print(x, ...)

## S3 method for class 'counterfactual_conjunction'
e1 + e2

## S3 method for class 'counterfactual_conjunction'
x[i]

## S3 method for class 'counterfactual_variable'
e1 + e2

conj(...)

counterfactual_variable(var, obs = integer(0L), sub = integer(0L))

## S3 method for class 'counterfactual_variable'
format(x, use_primes = TRUE, ...)

## S3 method for class 'counterfactual_variable'
print(x, ...)

cf(var, obs = integer(0L), sub = integer(0L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="counterfactual_conjunction_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code><a href="#topic+format.counterfactual_variable">format.counterfactual_variable()</a></code>.</p>
</td></tr>
<tr><td><code id="counterfactual_conjunction_+3A_x">x</code></td>
<td>
<p>A <code>counterfactual_variable</code> or a <code>counterfactual_conjunction</code>
object.</p>
</td></tr>
<tr><td><code id="counterfactual_conjunction_+3A_var_sep">var_sep</code></td>
<td>
<p>A <code>character</code> string to separate counterfactual variables.</p>
</td></tr>
<tr><td><code id="counterfactual_conjunction_+3A_e1">e1</code></td>
<td>
<p>A <code>counterfactual_variable</code> or a <code>counterfactual_conjunction</code>
object.</p>
</td></tr>
<tr><td><code id="counterfactual_conjunction_+3A_e2">e2</code></td>
<td>
<p>A <code>counterfactual_variable</code> or a <code>counterfactual_conjunction</code>
object.</p>
</td></tr>
<tr><td><code id="counterfactual_conjunction_+3A_i">i</code></td>
<td>
<p>An <code>integer</code> index vector.</p>
</td></tr>
<tr><td><code id="counterfactual_conjunction_+3A_var">var</code></td>
<td>
<p>A character vector of length one naming the variable
(i.e., <code class="reqn">Y</code>).</p>
</td></tr>
<tr><td><code id="counterfactual_conjunction_+3A_obs">obs</code></td>
<td>
<p>An integer vector of length one or zero. If given, denotes
the observed value of <code>var</code> (i.e., <code class="reqn">Y = y</code>)</p>
</td></tr>
<tr><td><code id="counterfactual_conjunction_+3A_sub">sub</code></td>
<td>
<p>A named integer vector where the names correspond to the
variables intervened on (via <code class="reqn">do(X = x)</code>) and values to the
value assignments (their levels, e.g., <code class="reqn">x</code>).</p>
</td></tr>
<tr><td><code id="counterfactual_conjunction_+3A_use_primes">use_primes</code></td>
<td>
<p>A <code>logical</code> value. If <code>TRUE</code> (the default), any value
assignment of a counterfactual variable with <code>obs</code> will be formatted with
as many primes in the superscript as the value of <code>obs</code>, e.g.,
<code>obs = 0</code> outputs <code>"y"</code>, <code>obs = 1</code> outputs <code>"y'"</code>,
<code>obs = 2</code> outputs <code>"y''"</code> and so forth. The alternative when <code>FALSE</code> is
to simply denote the <code>obs</code> value via superscript directly as
<code>"y^{(obs)}"</code>, where obs is evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>conj</code> returns an object of class <code>counterfactual_conjunction</code>.
</p>
<p><code>cf</code> returns an object of class <code>counterfactual_variable</code>.
</p>


<h3>Counterfactual Conjunctions</h3>

<p>A counterfactual conjunction is a conjunction (or a set in some contexts)
of counterfactual statements that are assumed to hold simultaneously.
</p>
<p>For example, the statement &quot;The value of <code class="reqn">Y</code> was observed to
be <code class="reqn">y</code>, and the value of <code class="reqn">Y</code> was observed to be <code class="reqn">y'</code>
under the intervention <code class="reqn">do(X = x)</code>&quot; consists of two variables:
variable <code class="reqn">Y</code> without intervention, and <code class="reqn">Y</code> under the intervention
<code class="reqn">do(X = x)</code> (which is <code class="reqn">Y_x</code>). This conjunction can be succinctly
written as <code class="reqn">y \wedge y'_x</code>.
</p>
<p>Conjunctions can also be constructed
via the alias <code>conj</code> or iteratively from <code>counterfactual_variable</code>
objects (see examples).
</p>


<h3>Counterfactual Variables</h3>

<p>Assume that <code class="reqn">Y</code> is a single variable and <code class="reqn">X</code> is a vector
of variables. Here, The notation <code class="reqn">y_x</code> means that the variable
<code class="reqn">Y</code> (<code>var</code>) attains the value <code class="reqn">y</code> (<code>obs</code>) under the
intervention <code class="reqn">do(X = x)</code> (<code>sub</code>).
</p>
<p>Note that different values of <code>obs</code> for a two variables with the same <code>var</code>
and the same <code>sub</code> do not denote their actual values, but the levels
(i.e., <code>obs = 0</code> is different from <code>obs = 1</code>, but the variables do not
actually attain values 0 and 1). In other words, if <code>var</code> is different for
two counterfactual variables, but they have the same value <code>obs</code>, this
does not mean that these variables have the same value. They will only
actually have the same value if they share both <code>var</code> and <code>obs</code>.
</p>
<p>For more information about the
<code class="reqn">do</code>-operator, see Pearl (2009). The shortcut alias <code>cf</code> can also
be used to construct counterfactual variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The conjunction described under 'details'
v1 &lt;- cf("Y", 0)
v2 &lt;- cf("Y", 1, c("X" = 0))
c1 &lt;- conj(v1, v2)

# Alternative construction
c1 &lt;- v1 + v2

# Adding further variables
v3 &lt;- cf("X", 1)
c2 &lt;- c1 + v3

# A specific value of a variable (a unique combination of `var` and `sub`)
# can only appear once in a given conjunction,
# otherwise the conjunction would be trivially inconsistent
v4 &lt;- cf("Y", 0, c("X" = 0))
v5 &lt;- cf("Y", 1, c("X" = 0))
c3 &lt;- try(conj(v4, v5))

# Y without an assigned value or any interventions
cf("Y")

# Y with a value assignment y, but no interventions
cf("Y", 0)

# Y with a different value y', but no interventions
cf("Y", 1)

# Y with the same value as the previous under the intervention do(X = x)
cf("Y", 1, c("X" = 0))

# Y with yet another value y'', under the intervention
# do(X = x', Z = z), i.e., the intervention on X has a different value
# than the previous (x != x') and Z is also assigned the value z
cf("Y", 2, c("X" = 1, "Z" = 0))
</code></pre>

<hr>
<h2 id='dag'>Directed Acyclic Graph</h2><span id='topic+dag'></span><span id='topic+print.dag'></span>

<h3>Description</h3>

<p>Define a directed acyclic graph (DAG) describing the causal model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag(x, u = character(0L))

## S3 method for class 'dag'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dag_+3A_x">x</code></td>
<td>
<p>A <code>dag</code> object</p>
</td></tr>
<tr><td><code id="dag_+3A_u">u</code></td>
<td>
<p>A <code>character</code> vector of variable names which should be considered
unobserved (besides those defined by bidirected edges). These variables
are subsequently removed via latent projection. Variable names not found
in the graph are ignored.</p>
</td></tr>
<tr><td><code id="dag_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The syntax for <code>x</code> follows the <code>dagitty</code> package closely for compatibility.
However, not all features of <code>dagitty</code> graphs are supported.
The resulting adjacency matrix of the definition is checked for cycles.
</p>
<p>Directed edges are defined as <code>X -&gt; Y</code> meaning that there is an edge from
<code>X</code> to <code>Y</code> in the graph. Edges can be combined in sequence to create paths
for concise descriptions, for example <code>X -&gt; Y &lt;- Z -&gt; W</code>.
</p>
<p>Unobserved latent confounders are defined using bidirected edges as
<code style="white-space: pre;">&#8288;X &lt;-&gt; Y&#8288;</code> which means that there is an additional variable <code>U[X,Y]</code> in
the graph, and the edges <code>X &lt;- U[X,Y] -&gt; Y</code>, respectively.
</p>
<p>Different statements in <code>x</code> can be distinguished from one
another using either semicolons, line breaks, or spaces.
</p>
<p>Subgraphs can be defined by enclosing the definition within
curly braces. For example <code style="white-space: pre;">&#8288;X -&gt; {Y Z}&#8288;</code> defines an edge
from <code>X</code> to both <code>Y</code> and <code>Z</code>. Individual statements within a subgraph can be
separated by a comma or semicolon, but this is optional.
Edges can also be defined within subgraphs, and subgraphs can be nested.
For example, <code>X -&gt; {Z -&gt; Y}</code> is the same definition as
<code style="white-space: pre;">&#8288;X -&gt; Z; X -&gt; Y; Z -&gt; Y&#8288;</code>. Similarly <code style="white-space: pre;">&#8288;X &lt;-&gt; {Z -&gt; {A B}} -&gt; Y&#8288;</code> is the same as
<code style="white-space: pre;">&#8288;X &lt;-&gt; {Z A B} -&gt; Y; Z -&gt; {A B}&#8288;</code>.
</p>
<p>Note that in the context of this package, vertex labels will always be
converted into upper case, meaning that typing <code>Z</code> or <code>z</code> will
always represent the same variable. This is done to enforce the notation
of counterfactual variables, where capital letters denote variables
and small letters denote their value assignments.
</p>


<h3>Value</h3>

<p>An object of class <code>dag</code>, which is a square adjacency matrix
with the following attributes:
</p>

<ul>
<li> <p><code>labels</code><br /> A <code>character</code> vector (or a list) of vertex labels.
</p>
</li>
<li> <p><code>latent</code><br /> A <code>logical</code> vector indicating latent variables.
</p>
</li>
<li> <p><code>order</code><br /> An <code>integer</code> vector giving a topological order for the vertices.
</p>
</li>
<li> <p><code>text</code><br /> A <code>character</code> string giving representing the DAG.
.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>dag("X -&gt; {Y Z} &lt;- W &lt;-&gt; G")

# Subgraphs can appear on both sides of an edge
dag("{X Z} -&gt; {Y W}")

# Semicolons can be used to distinguish individual statements
dag("X -&gt; Z -&gt; Y; X &lt;-&gt; Y")

# Commas can be used to distinguish variables within groups if there
# are no edges within the group
dag("{X, Y, Z} -&gt; W")

# Edges within subgraphs is supported
dag("{X -&gt; Z} -&gt; {Y &lt;-&gt; W}")

# Nested subgraphs are supported
dag("{X -&gt; {Z -&gt; {Y &lt;-&gt; W}}}")

# Line breaks are also supported for statement separation
dag("
  Z -&gt; W
  X -&gt; Y
")

</code></pre>

<hr>
<h2 id='export_graph'>Export Graph</h2><span id='topic+export_graph'></span>

<h3>Description</h3>

<p>Convert a valid graph object into a supported external format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_graph(
  g,
  type = c("dagitty", "causaleffect", "dosearch"),
  use_bidirected = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_graph_+3A_g">g</code></td>
<td>
<p>An object of class <code>dag</code>.</p>
</td></tr>
<tr><td><code id="export_graph_+3A_type">type</code></td>
<td>
<p>A character string matching one of the following:
<code>"dagitty"</code>, <code>"causaleffect"</code> or <code>"dosearch"</code>. For <code>"dagitty"</code> and
<code>"causaleffect"</code>, the packages <code>dagitty</code> and <code>igraph</code> must be available,
respectively.</p>
</td></tr>
<tr><td><code id="export_graph_+3A_use_bidirected">use_bidirected</code></td>
<td>
<p>A logical value indicating if bidirected edges
should be used in the resulting object.
If <code>TRUE</code>, the result will have explicit <code style="white-space: pre;">&#8288;X &lt;-&gt; Y&#8288;</code>
edges. If <code>FALSE</code>, an explicit latent variable <code>X &lt;- U[X,Y] -&gt; Y</code> will
be used instead (only applicable if <code>type</code> is <code>"dosearch"</code>).</p>
</td></tr>
<tr><td><code id="export_graph_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>format</code> for formatting
vertex labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>type</code> is <code>"dagitty"</code>, returns a <code>dagitty</code> object.
If <code>type</code> is <code>"causaleffect"</code>, returns an <code>igraph</code> graph, with its edge
attributes set according to the <code>causaleffect</code> package syntax. If <code>type</code>
is <code>"dosearch"</code>, returns a character vector of length one that describes
<code>g</code> in the <code>dosearch</code> package syntax.
</p>

<hr>
<h2 id='functional'>Identifying Functional of a Counterfactual Query</h2><span id='topic+functional'></span><span id='topic+format.functional'></span><span id='topic+print.functional'></span>

<h3>Description</h3>

<p>Identifying functionals are more complicated probabilistic expressions
that cannot be expressed as simple observational or interventional
probabilities using <code><a href="#topic+probability">probability()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>functional(sumset = NULL, terms = NULL, numerator = NULL, denominator = NULL)

## S3 method for class 'functional'
format(x, ...)

## S3 method for class 'functional'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="functional_+3A_sumset">sumset</code></td>
<td>
<p>A <code>list</code> of objects of class <code>counterfactual_variable</code>
(without interventions and with value assignments).
If the probability depicts marginalization, <code>sumset</code>
defines the set of variables to be marginalized over.</p>
</td></tr>
<tr><td><code id="functional_+3A_terms">terms</code></td>
<td>
<p>A <code>list</code> of <code>functional</code> objects if the object in question
is meant to represent a product of terms.</p>
</td></tr>
<tr><td><code id="functional_+3A_numerator">numerator</code></td>
<td>
<p>A <code>functional</code> or a <code>probability</code> object.
If the functional represents a conditional probability that
cannot be expressed simply in terms of the set of inputs,
this is the numerator of the quotient representation.</p>
</td></tr>
<tr><td><code id="functional_+3A_denominator">denominator</code></td>
<td>
<p>A <code>functional</code> or a <code>probability</code> object.
The denominator of the quotient representation.</p>
</td></tr>
<tr><td><code id="functional_+3A_x">x</code></td>
<td>
<p>A <code>functional</code> object.</p>
</td></tr>
<tr><td><code id="functional_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>format</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When formatted via <code>print</code> or <code>format</code>, the arguments are
prioritized in the following order if conflicting definitions are given:
(<code>sumset</code>, <code>terms</code>), (<code>numerator</code>, <code>denominator</code>).
</p>


<h3>Value</h3>

<p>An object of class <code>functional</code>, which is a <code>list</code> containing
all of the arguments of the constructor.
</p>
<p>A <code>character</code> representation of the <code>functional</code> object
in LaTeX syntax.
</p>

<hr>
<h2 id='identifiable'>Identify a Counterfactual Query</h2><span id='topic+identifiable'></span>

<h3>Description</h3>

<p>Determine the identifiability of a (conditional) counterfactual conjunction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identifiable(
  g,
  gamma,
  delta = NULL,
  data = c("interventions", "observations", "both")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identifiable_+3A_g">g</code></td>
<td>
<p>A <code>dag</code> object describing the causal graph
(to obtain a <code>dag</code> from another format, see <code><a href="#topic+import_graph">import_graph()</a></code>.</p>
</td></tr>
<tr><td><code id="identifiable_+3A_gamma">gamma</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object that can be coerced into a
<code>counterfactual_conjunction</code> object that represents the
counterfactual causal query.</p>
</td></tr>
<tr><td><code id="identifiable_+3A_delta">delta</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object that can be coerced into a
<code>counterfactual_conjunction</code> object that represents the conditioning
conjunction (optional).</p>
</td></tr>
<tr><td><code id="identifiable_+3A_data">data</code></td>
<td>
<p>A <code>character</code> string that accepts one of the following:
<code>"interventions"</code> (the default), <code>"observations"</code>or <code>"both"</code>. This argument
defines the target level of identification. If <code>"interventions"</code> is used,
the identification is attempted down to the intervention level. If
<code>"observations"</code> is used, identification is attempted down to the
observational level. If <code>"both"</code> is used, identification is carried out
for each term to the lowest level where the term is still identifiable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To identify a non-conditional conjunction <code class="reqn">P(\gamma)</code>, the argument
<code>delta</code> should be <code>NULL</code>.
</p>
<p>To identify a conditional conjunction <code class="reqn">P(\gamma|\delta)</code>, both <code>gamma</code>
and <code>delta</code> should be specified.
</p>
<p>First, a parallel worlds graph is constructed based on the query. In a
parallel worlds graph, for each <code class="reqn">do</code>-action that appears in <code class="reqn">\gamma</code>
(and <code class="reqn">\delta</code>) a copy of the original graph is created with the new
observational variables attaining their post-interventional values
but sharing the latent variables. This graph is known as a parallel worlds
graph. From the parallel worlds graph, a counterfactual graph
is derived such that each variable is unique, which might not be the case
in a parallel worlds graph.
</p>
<p>Finally, the ID* (or IDC*) algorithm is applied to determine identifiability
of the query. Similar to the ID and IDC algorithms for causal effects,
these algorithms exploit the so called c-component factorization to split
the query into smaller subproblems, which are then solved recursively.
If argument <code>data</code> is <code>"observations"</code> or <code>"both"</code>, identification of
interventional probabilities in the resulting functional is further
attempted in terms of the joint probability distribution by using the
ID and IDC algorithms (see <a href="#topic+causal_effect">causal_effect</a>).
</p>


<h3>Value</h3>

<p>An object of class <code>query</code> which is a <code>list</code> containing
one or more of the following:
</p>

<ul>
<li> <p><code>id</code><br /> A <code>logical</code> value that is <code>TRUE</code> if the query is identifiable and
<code>FALSE</code> otherwise from the available <code>data</code> in <code>g</code>.
Note that in cases where <code>gamma</code> itself is
inconsistent, the query will be identifiable, but with probability 0.
</p>
</li>
<li> <p><code>formula</code><br /> An object of class <code>functional</code> giving the identifying
functional of the query in LaTeX syntax via <code>format</code> or <code>print</code>,
if identifiable. This expression is given in terms of the
available <code>data</code>. Variables bound by summation are distinguished by a
superscript asterisk. For tautological statements, the resulting
probability is 1, and for inconsistent statements, the resulting
probability is 0. For formatting options, see
<code><a href="#topic+format.functional">format.functional()</a></code> and <code><a href="#topic+format.probability">format.probability()</a></code>.
</p>
</li>
<li> <p><code>undefined</code><br /> A logical value that is <code>TRUE</code> if
a conditional conjunction <code class="reqn">p(\gamma|\delta)</code> is undefined,
for example when <code class="reqn">p(\delta) = 0</code>, and <code>FALSE</code> otherwise.
</p>
</li>
<li> <p><code>gamma</code><br /> The original counterfactual conjunction..
</p>
</li>
<li> <p><code>delta</code><br /> The original conditioning counterfactual conjunction.
</p>
</li>
<li> <p><code>data</code><br /> The original data.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+dag">dag()</a></code>, <code><a href="#topic+counterfactual_variable">counterfactual_variable()</a></code>,
<code><a href="#topic+probability">probability()</a></code>, <code><a href="#topic+functional">functional()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Examples that appears in Shpitser and Pearl (2008)
g1 &lt;- dag("X -&gt; W -&gt; Y &lt;- Z &lt;- D X &lt;-&gt; Y")
g2 &lt;- dag("X -&gt; W -&gt; Y &lt;- Z &lt;- D X &lt;-&gt; Y X -&gt; Y")
v1 &lt;- cf("Y", 0, c(X = 0))
v2 &lt;- cf("X", 1)
v3 &lt;- cf("Z", 0, c(D = 0))
v4 &lt;- cf("D", 0)
c1 &lt;- conj(v1)
c2 &lt;- conj(v2, v3, v4)
c3 &lt;- conj(v1, v2, v3, v4)

# Identifiable conditional conjunction
identifiable(g1, c1, c2)

# Identifiable conjunction
identifiable(g1, c3)

# Non-identifiable conjunction
identifiable(g2, c3)

</code></pre>

<hr>
<h2 id='import_graph'>Import Graph</h2><span id='topic+import_graph'></span>

<h3>Description</h3>

<p>Import and construct a valid DAG from an external format. Accepts
<code>dagitty</code> graphs, <code>igraph</code> graphs in the <code>causaleffect</code> package syntax,
and character strings in the <code>dosearch</code> package syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_graph(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_graph_+3A_x">x</code></td>
<td>
<p>A graph object in a valid external format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>dag</code> object.
</p>

<hr>
<h2 id='probability'>Symbolic Probability Distributions</h2><span id='topic+probability'></span><span id='topic+format.probability'></span><span id='topic+print.probability'></span>

<h3>Description</h3>

<p>Defines an interventional or observational (conditional) probability
<code class="reqn">P(y|do(x),z)</code>. For formatting options, see <code><a href="#topic+format.probability">format.probability()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probability(val = NULL, var = NULL, do = NULL, cond = NULL)

## S3 method for class 'probability'
format(x, use_do = FALSE, ...)

## S3 method for class 'probability'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probability_+3A_val">val</code></td>
<td>
<p>An <code>integer</code> value of either 0 or 1 for almost sure events.</p>
</td></tr>
<tr><td><code id="probability_+3A_var">var</code></td>
<td>
<p>A <code>list</code> of objects of class <code>counterfactual_variable</code>
(without interventions and with value assignments).
<code>var</code> defines the observations <code class="reqn">y</code> in <code class="reqn">P(y|do(x),z)</code>.</p>
</td></tr>
<tr><td><code id="probability_+3A_do">do</code></td>
<td>
<p>A <code>list</code> of <code>counterfactual_variable</code> variable objects
(without interventions and with value assignments). Defines the
intervention set <code class="reqn">x</code> in <code class="reqn">P(y|do(x),z)</code>.</p>
</td></tr>
<tr><td><code id="probability_+3A_cond">cond</code></td>
<td>
<p>A <code>list</code> of <code>counterfactual_variable</code> variable objects
(without interventions and with value assignments).Defines the
conditioning set <code class="reqn">z</code> in <code class="reqn">P(y|do(x),z)</code>.</p>
</td></tr>
<tr><td><code id="probability_+3A_x">x</code></td>
<td>
<p>A <code>probability</code> object.</p>
</td></tr>
<tr><td><code id="probability_+3A_use_do">use_do</code></td>
<td>
<p>A <code>logical</code> value. If <code>TRUE</code>, the explicit do-operation is
used to denote interventional probabilities (e.g., <code class="reqn">P(y|do(x))</code>).
If <code>FALSE</code> (the default), the subscript notation is used instead
(e.g., <code class="reqn">P_x(y)</code>).</p>
</td></tr>
<tr><td><code id="probability_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>format</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>probability</code>, which is a <code>list</code> containing
all of the arguments of the constructor.
</p>
<p>A <code>character</code> representation of the <code>probability</code> object
in LaTeX syntax.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+counterfactual_variable">counterfactual_variable()</a></code>, <code><a href="#topic+functional">functional()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example from Makhlouf, Zhioua and Palamidessi (2021)
g2 &lt;- dag("C -&gt; A -&gt; Y; C -&gt; Y")
v1 &lt;- cf("Y", 0, c(A = 1))
v2 &lt;- cf("A", 0)
c1 &lt;- conj(v1)
c2 &lt;- conj(v2)
f &lt;- identifiable(g2, c1, c2)$formula

# Default, using primes and subscript notation
format(f)

# Without primes, no do-operator
format(f, use_primes = FALSE)

# Primes, with do-operator
format(f, use_do = TRUE)

# Without primes, with do-operator
format(f, use_primes = FALSE, use_do = TRUE)

</code></pre>

<hr>
<h2 id='query'>Query Objects</h2><span id='topic+query'></span><span id='topic+print.query'></span>

<h3>Description</h3>

<p>Objects of class <code>query</code> describe the output of <code>identifiable</code> and
<code>causal_effect</code>. They are <code>list</code> objects with a custom <code>print</code> method and
contain data related to the identifiability results. See
<a href="#topic+identifiable">identifiable</a> and <a href="#topic+causal_effect">causal_effect</a> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'query'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="query_+3A_x">x</code></td>
<td>
<p>A <code>query</code> object</p>
</td></tr>
<tr><td><code id="query_+3A_...">...</code></td>
<td>
<p>Arguments passed to <a href="#topic+format.functional">format.functional</a> and
<a href="#topic+format.counterfactual_conjunction">format.counterfactual_conjunction</a></p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
