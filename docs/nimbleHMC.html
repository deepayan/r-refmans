<!DOCTYPE html><html><head><title>Help for package nimbleHMC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nimbleHMC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addHMC'><p>Add HMC sampler</p></a></li>
<li><a href='#buildHMC'><p>Build HMC</p></a></li>
<li><a href='#configureHMC'><p>Configure HMC</p></a></li>
<li><a href='#nimbleHMC'><p>Builds and executes NIMBLE's HMC sampler</p></a></li>
<li><a href='#sampler_NUTS'><p>No-U-Turn (NUTS) Hamiltonian Monte Carlo (HMC) Sampler</p></a></li>
<li><a href='#sampler_NUTS_classic'><p>Classic No-U-Turn (NUTS_classic) Hamiltonian Monte Carlo (HMC) Sampler</p></a></li>
<li><a href='#stateNL_NUTS'><p>nimbleList definition used internally in NUTS sampler.</p></a></li>
<li><a href='#treebranchNL_NUTS'><p>nimbleList definition used internally in NUTS sampler.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Hamiltonian Monte Carlo and Other Gradient-Based MCMC Sampling
Algorithms for 'nimble'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-27</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Turek &lt;danielturek@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides gradient-based MCMC sampling algorithms for use with the MCMC engine provided by the 'nimble' package.  This includes two versions of Hamiltonian Monte Carlo (HMC) No-U-Turn (NUTS) sampling, and (under development) Langevin samplers.  The 'NUTS_classic' sampler implements the original HMC-NUTS algorithm as described in Hoffman and Gelman (2014) &lt;<a href="https://doi.org/10.48550%2FarXiv.1111.4246">doi:10.48550/arXiv.1111.4246</a>&gt;.  The 'NUTS' sampler is a modern version of HMC-NUTS sampling matching the HMC sampler available in version 2.32.2 of Stan (Stan Development Team, 2023). In addition, convenience functions are provided for generating and modifying MCMC configuration objects which employ HMC sampling.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), nimble (&ge; 1.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE | <a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: BSD_3_clause + file LICENSE | GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Copyright:</td>
<td>See COPYRIGHTS file.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-28 11:35:15 UTC; dturek</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Turek [aut, cre],
  Perry de Valpine [aut],
  Christopher Paciorek [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-28 12:10:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='addHMC'>Add HMC sampler</h2><span id='topic+addHMC'></span>

<h3>Description</h3>

<p>Add a No-U-Turn (NUTS) Hamiltonian Monte Carlo (HMC) sampler to an existing nimble MCMC configuration object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addHMC(
  conf,
  target = character(),
  type = "NUTS",
  control = list(),
  replace = FALSE,
  print = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addHMC_+3A_conf">conf</code></td>
<td>
<p>A nimble MCMC configuration object, as returned by 'configureMCMC'.</p>
</td></tr>
<tr><td><code id="addHMC_+3A_target">target</code></td>
<td>
<p>A character vector of continuous-valued stochastic node names to sample.  If this argument contains any discrete-valued nodes, an error is produced and no HMC sampler is added.  If this argument is omitted, then no HMC sampler is added.</p>
</td></tr>
<tr><td><code id="addHMC_+3A_type">type</code></td>
<td>
<p>A character string specifying the type of HMC sampler to add, either &quot;NUTS&quot; or &quot;NUTS_classic&quot;.  See 'help(NUTS)' or 'help(NUTS_classic)' for details of each sampler.  The default sampler type is &quot;NUTS&quot;.</p>
</td></tr>
<tr><td><code id="addHMC_+3A_control">control</code></td>
<td>
<p>Optional named list of control parameters to be passed as the 'control' argument to the HMC sampler.  See 'help(NUTS)' or 'help(NUTS_classic)' for details of the control list elements accepted by each sampler.</p>
</td></tr>
<tr><td><code id="addHMC_+3A_replace">replace</code></td>
<td>
<p>Logical argument.  If 'TRUE', any existing samplers operating on the specified nodes will be removed, prior to adding the HMC sampler.  Default value is 'FALSE'.</p>
</td></tr>
<tr><td><code id="addHMC_+3A_print">print</code></td>
<td>
<p>Logical argument whether to print the newly added HMC sampler.  Default value is 'TRUE'.</p>
</td></tr>
<tr><td><code id="addHMC_+3A_...">...</code></td>
<td>
<p>Additional named arguments passed through ... will be used as additional control list elements.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function adds an HMC sampler to an MCMC configuration object.  Use this function if you have already created an MCMC configuration and want to add an HMC sampler.  Optionally, using 'replace = TRUE', this function will also remove any existing samplers operating on the target node(s).
</p>
<p>Either the 'NUTS_classic' or the 'NUTS' sampler can be added.  Both implement variants of No-U-Turn HMC sampling, however the 'NUTS' sampler uses more modern adapatation techniques.  See 'help(NUTS)' or 'help(NUTS_classic)' for details.
</p>
<p>Use 'conf$addSampler' instead if you need more fine-grained control.  See 'help(configureMCMC)' in nimble.
</p>


<h3>Value</h3>

<p>Invisibly returns an object of class 'MCMCconf', but this function is primary called for its side effect.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+configureHMC">configureHMC</a></code> <code><a href="#topic+buildHMC">buildHMC</a></code> <code><a href="nimble.html#topic+configureMCMC">configureMCMC</a></code> <code><a href="nimble.html#topic+addSampler">addSampler</a></code> <code><a href="#topic+sampler_NUTS">sampler_NUTS</a></code> <code><a href="#topic+sampler_NUTS_classic">sampler_NUTS_classic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>code &lt;- nimbleCode({
    b0 ~ dnorm(0, 0.001)
    b1 ~ dnorm(0, 0.001)
    sigma ~ dunif(0, 10000)
    for(i in 1:N) {
        mu[i] &lt;- b0 + b1 * x[i]
        y[i] ~ dnorm(mu[i], sd = sigma)
    }
})

N &lt;- 10
constants &lt;- list(N = N, x = 1:N)
data &lt;- list(y = 1:N)
inits &lt;- list(b0 = 1, b1 = 0.1, sigma = 1)

Rmodel &lt;- nimbleModel(code, constants, data, inits, buildDerivs = TRUE)

## create default MCMC configuration object
conf &lt;- configureMCMC(Rmodel)

## remove default samplers operating on b0 and b1
conf$removeSamplers(c("b0", "b1"))

## add an HMC sampler operating on b0 and b1
addHMC(conf, target = c("b0", "b1"))

Rmcmc &lt;- buildMCMC(conf)

# Cmodel &lt;- compileNimble(Rmodel)
# Cmcmc &lt;- compileNimble(Rmcmc, project = Rmodel)
# samples &lt;- runMCMC(Cmcmc)
</code></pre>

<hr>
<h2 id='buildHMC'>Build HMC</h2><span id='topic+buildHMC'></span>

<h3>Description</h3>

<p>Build an MCMC algorithm which applies HMC sampling to continuous-valued dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildHMC(
  model,
  nodes = character(),
  type = "NUTS",
  control = list(),
  print = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildHMC_+3A_model">model</code></td>
<td>
<p>A nimble model, as returned by 'nimbleModel'</p>
</td></tr>
<tr><td><code id="buildHMC_+3A_nodes">nodes</code></td>
<td>
<p>A character vector of stochastic node names to be sampled. If an empty character vector is provided (the default), then all stochastic non-data nodes will be sampled.  An HMC sampler will be applied to all continuous-valued non-data nodes, and nimble's default sampler will be assigned for all discrete-valued nodes.</p>
</td></tr>
<tr><td><code id="buildHMC_+3A_type">type</code></td>
<td>
<p>A character string specifying the type of HMC sampling to apply, either &quot;NUTS&quot; or &quot;NUTS_classic&quot;.  See 'help(NUTS)' or 'help(NUTS_classic)' for details of each sampler.  The default sampler type is &quot;NUTS&quot;.</p>
</td></tr>
<tr><td><code id="buildHMC_+3A_control">control</code></td>
<td>
<p>Optional named list of control parameters to be passed as the 'control' argument to the HMC sampler.  See 'help(NUTS)' or 'help(NUTS_classic)' for details of the control list elements accepted by each sampler.</p>
</td></tr>
<tr><td><code id="buildHMC_+3A_print">print</code></td>
<td>
<p>Logical argument specifying whether to print the montiors and samplers.  Default is TRUE.</p>
</td></tr>
<tr><td><code id="buildHMC_+3A_...">...</code></td>
<td>
<p>Other arguments that will be passed to 'configureHMC'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the most direct way to create an MCMC algorithm using HMC sampling in nimble.  This will create a compilable, executable MCMC algorithm, with HMC sampling assigned to all continuous-valued model dimensions, and nimble's default sampler assigned to all discrete-valued dimensions.  The &lsquo;nodes' argument can be used to control which model nodes are assigned samplers.  Use this if you don&rsquo;t otherwise need to modify the MCMC configuration.
</p>
<p>Either the 'NUTS_classic' or the 'NUTS' samplin can be applied.  Both implement variants of No-U-Turn HMC sampling, however the 'NUTS' sampler uses more modern adapatation techniques. See 'help(NUTS)' or 'help(NUTS_classic)' for details.
</p>


<h3>Value</h3>

<p>An object of class 'MCMC'.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addHMC">addHMC</a></code> <code><a href="#topic+configureHMC">configureHMC</a></code> <code><a href="nimble.html#topic+configureMCMC">configureMCMC</a></code> <code><a href="nimble.html#topic+addSampler">addSampler</a></code> <code><a href="#topic+sampler_NUTS">sampler_NUTS</a></code> <code><a href="#topic+sampler_NUTS_classic">sampler_NUTS_classic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>code &lt;- nimbleCode({
    b0 ~ dnorm(0, 0.001)
    b1 ~ dnorm(0, 0.001)
    sigma ~ dunif(0, 10000)
    for(i in 1:N) {
        mu[i] &lt;- b0 + b1 * x[i]
        y[i] ~ dnorm(mu[i], sd = sigma)
    }
})

N &lt;- 10
constants &lt;- list(N = N, x = 1:N)
data &lt;- list(y = 1:N)
inits &lt;- list(b0 = 1, b1 = 0.1, sigma = 1)
Rmodel &lt;- nimbleModel(code, constants, data, inits, buildDerivs = TRUE)

Rmcmc &lt;- buildHMC(Rmodel)

# Cmodel &lt;- compileNimble(Rmodel)
# Cmcmc &lt;- compileNimble(Rmcmc, project = Rmodel)
# samples &lt;- runMCMC(Cmcmc)
</code></pre>

<hr>
<h2 id='configureHMC'>Configure HMC</h2><span id='topic+configureHMC'></span>

<h3>Description</h3>

<p>Create a nimble MCMC configuration object which applies HMC sampling to continuous-valued dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>configureHMC(
  model,
  nodes = character(),
  type = "NUTS",
  control = list(),
  print = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="configureHMC_+3A_model">model</code></td>
<td>
<p>A nimble model, as returned by 'nimbleModel'</p>
</td></tr>
<tr><td><code id="configureHMC_+3A_nodes">nodes</code></td>
<td>
<p>A character vector of stochastic node names to be sampled. If an empty character vector is provided (the default), then all stochastic non-data nodes will be sampled.  An HMC sampler will be applied to all continuous-valued non-data nodes, and nimble's default sampler will be assigned for all discrete-valued samplin to apply, either &quot;NUTS&quot; or &quot;NUTS_classic&quot;.</p>
</td></tr>
<tr><td><code id="configureHMC_+3A_type">type</code></td>
<td>
<p>A character string specifying the type of HMC sampling to apply, either &quot;NUTS&quot; or &quot;NUTS_classic&quot;.  See 'help(NUTS)' or 'help(NUTS_classic)' for details of each sampler.  The default sampler type is &quot;NUTS&quot;.</p>
</td></tr>
<tr><td><code id="configureHMC_+3A_control">control</code></td>
<td>
<p>Optional named list of control parameters to be passed as the 'control' argument to the HMC sampler.  See 'help(NUTS)' or 'help(NUTS_classic)' for details of the control list elements accepted by each sampler.</p>
</td></tr>
<tr><td><code id="configureHMC_+3A_print">print</code></td>
<td>
<p>Logical argument specifying whether to print the montiors and samplers.  Default is TRUE.</p>
</td></tr>
<tr><td><code id="configureHMC_+3A_...">...</code></td>
<td>
<p>Other arguments that will be passed to 'configureMCMC'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used like &lsquo;configureMCMC' in nimble to create an MCMC configuration object.  It will return an MCMC configuration with an HMC sampler assigned to continuous-valued model dimensions, and nimble&rsquo;s default sampler assigned for discrete-valued dimensions (or, only for the nodes specified in the 'nodes' argument).  The resulting MCMC configuration object can be used as an argument to 'buildMCMC' to generate an executable MCMC algorithm.
</p>
<p>Either the 'NUTS_classic' or the 'NUTS' sampler can be applied.  Both implement variants of No-U-Turn HMC sampling, however the 'NUTS' sampler uses more modern adapatation techniques. See 'help(NUTS)' or 'help(NUTS_classic)' for details.
</p>
<p>Use this function if you want to create an MCMC configuration, and then modify it further before building the MCMC algorithm.  'buildHMC' provides a more direct route to a compilable MCMC algorithm with HMC sampling applied to all continuous-valued dimensions.
</p>


<h3>Value</h3>

<p>An object of class 'MCMCconf'.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addHMC">addHMC</a></code> <code><a href="#topic+buildHMC">buildHMC</a></code> <code><a href="nimble.html#topic+configureMCMC">configureMCMC</a></code> <code><a href="nimble.html#topic+addSampler">addSampler</a></code> <code><a href="#topic+sampler_NUTS">sampler_NUTS</a></code> <code><a href="#topic+sampler_NUTS_classic">sampler_NUTS_classic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>code &lt;- nimbleCode({
    b0 ~ dnorm(0, 0.001)
    b1 ~ dnorm(0, 0.001)
    sigma ~ dunif(0, 10000)
    for(i in 1:N) {
        mu[i] &lt;- b0 + b1 * x[i]
        y[i] ~ dnorm(mu[i], sd = sigma)
    }
})

N &lt;- 10
constants &lt;- list(N = N, x = 1:N)
data &lt;- list(y = 1:N)
inits &lt;- list(b0 = 1, b1 = 0.1, sigma = 1)

Rmodel &lt;- nimbleModel(code, constants, data, inits, buildDerivs = TRUE)

## create MCMC configuration object with only an HMC sampler
conf &lt;- configureHMC(Rmodel)

Rmcmc &lt;- buildMCMC(conf)

# Cmodel &lt;- compileNimble(Rmodel)
# Cmcmc &lt;- compileNimble(Rmcmc, project = Rmodel)
# samples &lt;- runMCMC(Cmcmc)
</code></pre>

<hr>
<h2 id='nimbleHMC'>Builds and executes NIMBLE's HMC sampler</h2><span id='topic+nimbleHMC'></span>

<h3>Description</h3>

<p><code>nimbleHMC</code> is the most direct entry point to using NIMBLE's HMC sampler.  HMC sampling is applied to all unobserved dimensions of a hierarchical model.  Discrete-valued model dimensions cannot be sampled using HMC, and will produce an error.  See <code>help(HMC)</code> for details of the HMC algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimbleHMC(
  code,
  constants = list(),
  data = list(),
  inits,
  dimensions = list(),
  model,
  type = "NUTS",
  monitors,
  thin = 1,
  niter = 10000,
  nburnin = 0,
  nchains = 1,
  check = TRUE,
  setSeed = FALSE,
  progressBar = getNimbleOption("MCMCprogressBar"),
  samples = TRUE,
  samplesAsCodaMCMC = FALSE,
  summary = FALSE,
  WAIC = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nimbleHMC_+3A_code">code</code></td>
<td>
<p>The quoted code expression representing the model, such as the return value from a call to <code>nimbleCode</code>). Not required if <code>model</code> is provided.</p>
</td></tr>
<tr><td><code id="nimbleHMC_+3A_constants">constants</code></td>
<td>
<p>Named list of constants in the model.  Constants cannot be subsequently modified. For compatibility with JAGS and BUGS, one can include data values with constants and <code>nimbleModel</code> will automatically distinguish them based on what appears on the left-hand side of expressions in <code>code</code>.</p>
</td></tr>
<tr><td><code id="nimbleHMC_+3A_data">data</code></td>
<td>
<p>Named list of values for the data nodes.  Values that are NA will not be flagged as data.</p>
</td></tr>
<tr><td><code id="nimbleHMC_+3A_inits">inits</code></td>
<td>
<p>Argument to specify initial values for each MCMC chain.  See details.</p>
</td></tr>
<tr><td><code id="nimbleHMC_+3A_dimensions">dimensions</code></td>
<td>
<p>Named list of dimensions for variables.  Only needed for variables used with empty indices in model code that are not provided in constants or data.</p>
</td></tr>
<tr><td><code id="nimbleHMC_+3A_model">model</code></td>
<td>
<p>A compiled or uncompiled NIMBLE model object.  When provided, this model will be used to configure the MCMC algorithm to be executed, rather than using the <code>code</code>, <code>constants</code>, <code>data</code> and <code>inits</code> arguments to create a new model object.  However, if also provided, the <code>inits</code> argument will still be used to initialize this model prior to running each MCMC chain.</p>
</td></tr>
<tr><td><code id="nimbleHMC_+3A_type">type</code></td>
<td>
<p>A character string specifying the type of HMC sampling to apply, either &quot;NUTS&quot; or &quot;NUTS_classic&quot;.  See 'help(NUTS)' or 'help(NUTS_classic)' for details of each sampler.  The default sampler type is &quot;NUTS&quot;.</p>
</td></tr>
<tr><td><code id="nimbleHMC_+3A_monitors">monitors</code></td>
<td>
<p>A character vector giving the node names or variable names to monitor.  The samples corresponding to these nodes will returned, and/or will have summary statistics calculated. Default value is all top-level stochastic nodes of the model.</p>
</td></tr>
<tr><td><code id="nimbleHMC_+3A_thin">thin</code></td>
<td>
<p>Thinning interval for collecting MCMC samples.  Thinning occurs after the initial nburnin samples are discarded. Default value is 1.</p>
</td></tr>
<tr><td><code id="nimbleHMC_+3A_niter">niter</code></td>
<td>
<p>Number of MCMC iterations to run.  Default value is 10000.</p>
</td></tr>
<tr><td><code id="nimbleHMC_+3A_nburnin">nburnin</code></td>
<td>
<p>Number of initial, pre-thinning, MCMC iterations to discard.  Default value is 0.</p>
</td></tr>
<tr><td><code id="nimbleHMC_+3A_nchains">nchains</code></td>
<td>
<p>Number of MCMC chains to run.  Default value is 1.</p>
</td></tr>
<tr><td><code id="nimbleHMC_+3A_check">check</code></td>
<td>
<p>Logical argument, specifying whether to check the model object for missing or invalid values.  Default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="nimbleHMC_+3A_setseed">setSeed</code></td>
<td>
<p>Logical or numeric argument.  If a single numeric value is provided, R's random number seed will be set to this value at the onset of each MCMC chain.  If a numeric vector of length <code>nchains</code> is provided, then each element of this vector is provided as R's random number seed at the onset of the corresponding MCMC chain.  Otherwise, in the case of a logical value, if <code>TRUE</code>, then R's random number seed for the ith chain is set to be <code>i</code>, at the onset of each MCMC chain.  Note that specifying the argument <code>setSeed = 0</code> does not prevent setting the RNG seed, but rather sets the random number generation seed to <code>0</code> at the beginning of each MCMC chain.  Default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="nimbleHMC_+3A_progressbar">progressBar</code></td>
<td>
<p>Logical argument.  If <code>TRUE</code>, an MCMC progress bar is displayed during execution of each MCMC chain.  Default value is defined by the nimble package option MCMCprogressBar.</p>
</td></tr>
<tr><td><code id="nimbleHMC_+3A_samples">samples</code></td>
<td>
<p>Logical argument.  If <code>TRUE</code>, then posterior samples are returned from each MCMC chain.  These samples are optionally returned as <code>coda</code> <code>mcmc</code> objects, depending on the <code>samplesAsCodaMCMC</code> argument.  Default value is <code>TRUE</code>.  See details.</p>
</td></tr>
<tr><td><code id="nimbleHMC_+3A_samplesascodamcmc">samplesAsCodaMCMC</code></td>
<td>
<p>Logical argument.  If <code>TRUE</code>, then a <code>coda</code> <code>mcmc</code> object is returned instead of an R matrix of samples, or when <code>nchains &gt; 1</code> a <code>coda</code> <code>mcmc.list</code> object is returned containing <code>nchains</code> <code>mcmc</code> objects.  This argument is only used when <code>samples</code> is <code>TRUE</code>.  Default value is <code>FALSE</code>.  See details.</p>
</td></tr>
<tr><td><code id="nimbleHMC_+3A_summary">summary</code></td>
<td>
<p>Logical argument.  When <code>TRUE</code>, summary statistics for the posterior samples of each parameter are also returned, for each MCMC chain.  This may be returned in addition to the posterior samples themselves.  Default value is <code>FALSE</code>.  See details.
z</p>
</td></tr>
<tr><td><code id="nimbleHMC_+3A_waic">WAIC</code></td>
<td>
<p>Logical argument.  When <code>TRUE</code>, the WAIC (Watanabe, 2010) of the model is calculated and returned.  If multiple chains are run, then a single WAIC value is calculated using the posterior samples from all chains.  Default value is <code>FALSE</code>. Note that the version of WAIC used is the default WAIC conditional on random effects/latent states and without any grouping of data nodes. See <code>help(waic)</code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>nimbleHMC provides capability for running multiple MCMC chains, specifying the number of MCMC iterations, thinning, and burn-in, and which model variables should be monitored.  It also provides options to return the posterior samples, to return summary statistics calculated from the posterior samples, and to return a WAIC value.
</p>
<p>The entry point for this function is providing the <code>code</code>, <code>constants</code>, <code>data</code> and <code>inits</code> arguments, to create a new NIMBLE model object, or alternatively providing an exisiting NIMBLE model object as the <code>model</code> argument.
</p>
<p>At least one of <code>samples</code>, <code>summary</code> or <code>WAIC</code> must be <code>TRUE</code>, since otherwise, nothing will be returned.  Any combination of these may be <code>TRUE</code>, including possibly all three, in which case posterior samples, summary statistics, and WAIC values are returned for each MCMC chain.
</p>
<p>When <code>samples = TRUE</code>, the form of the posterior samples is determined by the <code>samplesAsCodaMCMC</code> argument, as either matrices of posterior samples, or <code>coda</code> <code>mcmc</code> and <code>mcmc.list</code> objects.
</p>
<p>Posterior summary statistics are returned individually for each chain, and also as calculated from all chains combined (when <code>nchains &gt; 1</code>).
</p>
<p>The <code>inits</code> argument can be one of three things:
</p>
<p>(1) a function to generate initial values, which will be executed once to initialize the model object, and once to generate initial values at the beginning of each MCMC chain, or
(2) a single named list of initial values which, will be used to initialize the model object and for each MCMC chain, or
(3) a list of length <code>nchains</code>, each element being a named list of initial values.  The first element will be used to initialize the model object, and once element of the list will be used for each MCMC chain.
</p>
<p>The <code>inits</code> argument may also be omitted, in which case the model will not be provided with initial values.  This is not recommended.
</p>
<p>The <code>niter</code> argument specifies the number of pre-thinning MCMC iterations, and the <code>nburnin</code> argument specifies the number of pre-thinning MCMC samples to discard.  After discarding these burn-in samples, thinning of the remaining samples will take place.  The total number of posterior samples returned will be floor((niter-nburnin)/thin).
</p>


<h3>Value</h3>

<p>A list is returned with named elements depending on the arguments, unless only one among samples, summary, and WAIC are requested, in which case only that element is returned.  These elements may include <code>samples</code>, <code>summary</code>, and <code>WAIC</code>.  When <code>nchains = 1</code>, posterior samples are returned as a single matrix, and summary statistics as a single matrix.  When <code>nchains &gt; 1</code>, posterior samples are returned as a list of matrices, one matrix for each chain, and summary statistics are returned as a list containing <code>nchains+1</code> matrices: one matrix corresponding to each chain, and the final element providing a summary of all chains, combined.  If <code>samplesAsCodaMCMC</code> is <code>TRUE</code>, then posterior samples are provided as <code>coda</code> <code>mcmc</code> and <code>mcmc.list</code> objects.  When <code>WAIC</code> is <code>TRUE</code>, a WAIC summary object is returned.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+configureHMC">configureHMC</a></code> <code><a href="#topic+buildHMC">buildHMC</a></code> <code><a href="nimble.html#topic+configureMCMC">configureMCMC</a></code> <code><a href="nimble.html#topic+buildMCMC">buildMCMC</a></code> <code><a href="nimble.html#topic+runMCMC">runMCMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

code &lt;- nimbleCode({
    mu ~ dnorm(0, sd = 1000)
    sigma ~ dunif(0, 1000)
    for(i in 1:10) {
        x[i] ~ dnorm(mu, sd = sigma)
    }
})
data &lt;- list(x = c(2, 5, 3, 4, 1, 0, 1, 3, 5, 3))
inits &lt;- function() list(mu = rnorm(1,0,1), sigma = runif(1,0,10))
mcmc.output &lt;- nimbleHMC(code, data = data, inits = inits,
                         monitors = c("mu", "sigma"), thin = 10,
                         niter = 20000, nburnin = 1000, nchains = 3,
                         summary = TRUE, WAIC = TRUE)


</code></pre>

<hr>
<h2 id='sampler_NUTS'>No-U-Turn (NUTS) Hamiltonian Monte Carlo (HMC) Sampler</h2><span id='topic+sampler_NUTS'></span><span id='topic+NUTS'></span><span id='topic+nuts'></span><span id='topic+HMC'></span><span id='topic+hmc'></span>

<h3>Description</h3>

<p>The NUTS sampler implements No-U-Turn (NUTS) Hamiltonian Monte Carlo (HMC) sampling following the algorithm of version 2.32.2 of Stan. Internally, any posterior dimensions with bounded support are transformed, so sampling takes place on an unconstrained space. In contrast to standard HMC (Neal, 2011), the NUTS algorithm removes the tuning parameters of the leapfrog step size and the number of leapfrog steps, thus providing a sampling algorithm that can be used without hand-tuning or trial runs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampler_NUTS(model, mvSaved, target, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampler_NUTS_+3A_model">model</code></td>
<td>
<p>An uncompiled nimble model object on which the MCMC will operate.</p>
</td></tr>
<tr><td><code id="sampler_NUTS_+3A_mvsaved">mvSaved</code></td>
<td>
<p>A nimble <code>modelValues</code> object to be used to store MCMC samples.</p>
</td></tr>
<tr><td><code id="sampler_NUTS_+3A_target">target</code></td>
<td>
<p>A character vector of node names on which the sampler will operate.</p>
</td></tr>
<tr><td><code id="sampler_NUTS_+3A_control">control</code></td>
<td>
<p>A named list that controls the precise behavior of the sampler. The default values for control list elements are specified in the setup code of the sampler. A description of the possible control list elements appear in the details section.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NUTS sampler accepts the following control list elements:
</p>

<ul>
<li><p> messages. A logical argument, specifying whether to print informative messages (default = TRUE)
</p>
</li>
<li><p> numWarnings. A numeric argument, specifying how many warnings messages to emit (for example, when <code>NaN</code> values are encountered). See additional details below. (default = 0)
</p>
</li>
<li><p> epsilon. A positive numeric argument, specifying the initial step-size value. If not provided, an appropriate initial value is selected.
</p>
</li>
<li><p> gamma. A positive numeric argument, specifying the degree of shrinkage used during the initial period of step-size adaptation. (default = 0.05)
</p>
</li>
<li><p> t0. A non-negative numeric argument, where larger values stabilize (attenuate) the initial period of step-size adaptation. (default = 10)
</p>
</li>
<li><p> kappa. A numeric argument between zero and one, where smaller values give a higher weighting to more recent iterations during the initial period of step-size adaptation. (default = 0.75)
</p>
</li>
<li><p> delta. A numeric argument, specifying the target acceptance probability used during the initial period of step-size adaptation. (default = 0.8)
</p>
</li>
<li><p> deltaMax. A positive numeric argument, specifying the maximum allowable divergence from the Hamiltonian value. Paths which exceed this value are considered divergent, and will not proceed further. (default = 1000)
</p>
</li>
<li><p> M. A vector of positive real numbers, with length equal to the number of dimensions being sampled. Elements of <code>M</code> specify the diagonal elements of the diagonal mass matrix (or the metric) used for the auxiliary momentum variables in sampling. Sampling may be improved if the elements of <code>M</code> approximate the marginal inverse variance (precision) of the (potentially transformed) parameters. (default: a vector of ones).
</p>
</li>
<li><p> warmupMode. A character string, specifying the behavior for choosing the number of warmup iterations. Four values are possible. The value 'default' (the default) sets the number of warmup iterations as the number of burnin iterations (if a positive value for <code>nburnin</code> is used) or half the number of MCMC iterations in each chain (if <code>nburnin = 0</code>). The value 'burnin' sets the number of warmup iterations as the number of burnin iterations regardless of the length of the burnin period. The value 'fraction' sets the number of warmup iterations as <code>fraction*niter</code>, where <code>fraction</code> is the value of the <code>warmup</code> control argument, and <code>niter</code> is the number of MCMC iterations in each chain; in this case, the value of the <code>warmup</code> control argument must be between 0 and 1. The value 'iterations' sets the number of warmup iterations as the value of the <code>warmup</code> control argumnet, regardless of the length of the burnin period or the number of MCMC iterations; in this case the value of <code>warmup</code> must be a non-negative integer. In all cases, the number of (pre-thinning) samples discarded equals <code>nburnin</code>, as is always the case for MCMC in NIMBLE.
</p>
</li>
<li><p> warmup. Numeric value used in determining the number of warmup iterations. This control argument is only used when <code>warmupMode</code> is 'fraction' or 'iterations'. 
</p>
</li>
<li><p> maxTreeDepth. The maximum allowable depth of the binary leapfrog search tree for generating candidate transitions. (default = 10)
</p>
</li>
<li><p> adaptWindow. Number of iterations in the first adaptation window used for adapting the mass matrix (M). Subsequent adaptation windows double in length, so long as enough warmup iterations are available. (default = 25)
</p>
</li>
<li><p> initBuffer. Number of iterations in the initial warmup window, which occurs prior to the first adaptation of the metric M. (default = 75)
</p>
</li>
<li><p> termBuffer. Number of iterations in the final (terminal) warmup window, before which the metric M is not adjusted(default = 50)
</p>
</li>
<li><p> adaptive. A logical argument, specifying whether to do any adaptation whatsoever. When <code>TRUE</code>, specific adaptation routines are controlled by the <code>adaptEpsilon</code> and <code>adaptM</code> control list elements. (default = TRUE)
</p>
</li>
<li><p> adaptEpsilon. A logical argument, specifying whether to perform stepsize adaptation. Only used when <code>adaptive = TRUE</code>. (default = TRUE)
</p>
</li>
<li><p> adaptM. A logical argument, specifying whether to perform adaptation of the mass matrix (metric) M. Only used when <code>adaptive = TRUE</code>. (default = TRUE)
</p>
</li>
<li><p> initializeEpsilon. A logical argument, specifying whether to perform the epsilon (stepsize) initialization routine at the onset of each adaptation window. (default = TRUE)
</p>
</li></ul>

<p><code>NaN</code> values may be encountered in the course of the leapfrog procedure. In particular, when the stepsize (epsilon) is too large, the leapfrog procedure can step too far and arrive at an invalid region of parameter space, thus generating a <code>NaN</code> value in the likelihood evaluation or in the gradient calculation. These situation are handled by the sampler by rejecting the <code>NaN</code> value, and reducing the stepsize.
</p>


<h3>Value</h3>

<p>A object of class 'sampler_NUTS'.
</p>


<h3>Author(s)</h3>

<p>Perry de Valpine and Daniel Turek
</p>


<h3>References</h3>

<p>Hoffman, Matthew D., and Gelman, Andrew (2014). The No-U-Turn Sampler: Adaptively setting path lengths in Hamiltonian Monte Carlo. <em>Journal of Machine Learning Research</em>, 15(1): 1593-1623.
</p>
<p>Stan Development Team. 2023. Stan Modeling Language Users Guide and Reference Manual, 2.32.2. https://mc-stan.org.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>code &lt;- nimbleCode({
    b0 ~ dnorm(0, 0.001)
    b1 ~ dnorm(0, 0.001)
    sigma ~ dunif(0, 10000)
    for(i in 1:N) {
        mu[i] &lt;- b0 + b1 * x[i]
        y[i] ~ dnorm(mu[i], sd = sigma)
    }
})

set.seed(0)
N &lt;- 100
x &lt;- rnorm(N)
y &lt;- 1 + 0.3*x + rnorm(N)
constants &lt;- list(N = N, x = x)
data &lt;- list(y = y)
inits &lt;- list(b0 = 1, b1 = 0.1, sigma = 1)

Rmodel &lt;- nimbleModel(code, constants, data, inits, buildDerivs = TRUE)

conf &lt;- configureMCMC(Rmodel, nodes = NULL)

conf$addSampler(target = c('b0', 'b1', 'sigma'), type = 'NUTS')

Rmcmc &lt;- buildMCMC(conf)

</code></pre>

<hr>
<h2 id='sampler_NUTS_classic'>Classic No-U-Turn (NUTS_classic) Hamiltonian Monte Carlo (HMC) Sampler</h2><span id='topic+sampler_NUTS_classic'></span><span id='topic+NUTS-classic'></span><span id='topic+NUTS_classic'></span><span id='topic+nuts-classic'></span><span id='topic+nuts_classic'></span>

<h3>Description</h3>

<p>The NUTS_classic sampler implements the original No-U-Turn (NUTS classic) sampler as put forth in Hoffman and Gelman (2014) for performing joint updates of multiple continuous-valued posterior dimensions. This is done by introducing auxiliary momentum variables and using first-order derivatives to simulate Hamiltonian dynamics on this augmented paramter space. Internally, any posterior dimensions with bounded support are transformed, so sampling takes place on an unconstrained space. In contrast to standard HMC (Neal, 2011), the NUTS_classic algorithm removes the tuning parameters of the leapfrog step size and the number of leapfrog steps, thus providing a sampling algorithm that can be used without hand tuning or trial runs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampler_NUTS_classic(model, mvSaved, target, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampler_NUTS_classic_+3A_model">model</code></td>
<td>
<p>An uncompiled nimble model object on which the MCMC will operate.</p>
</td></tr>
<tr><td><code id="sampler_NUTS_classic_+3A_mvsaved">mvSaved</code></td>
<td>
<p>A nimble <code>modelValues</code> object to be used to store MCMC samples.</p>
</td></tr>
<tr><td><code id="sampler_NUTS_classic_+3A_target">target</code></td>
<td>
<p>A character vector of node names on which the sampler will operate.</p>
</td></tr>
<tr><td><code id="sampler_NUTS_classic_+3A_control">control</code></td>
<td>
<p>A named list that controls the precise behavior of the sampler. The default values for control list elements are specified in the setup code of the sampler. A description of the possible control list elements appear in the details section.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NUTS_classic sampler accepts the following control list elements:
</p>

<ul>
<li><p> messages. A logical argument, specifying whether to print informative messages. (default = TRUE)
</p>
</li>
<li><p> numWarnings. A numeric argument, specifying how many warnings messages to emit (for example, when <code>NaN</code> values are encountered). See additional details below. (default = 0)
</p>
</li>
<li><p> epsilon. A positive numeric argument, specifying the initial step-size value. If not provided, an appropriate initial value is selected.
</p>
</li>
<li><p> gamma. A positive numeric argument, specifying the degree of shrinkage used during the initial period of step-size adaptation. (default = 0.05)
</p>
</li>
<li><p> t0. A non-negative numeric argument, where larger values stabilize (attenuate) the initial period of step-size adaptation. (default = 10)
</p>
</li>
<li><p> kappa. A numeric argument between zero and one, where smaller values give a higher weighting to more recent iterations during the initial period of step-size adaptation. (default = 0.75)
</p>
</li>
<li><p> delta. A numeric argument, specifying the target acceptance probability used during the initial period of step-size adaptation. (default = 0.65)
</p>
</li>
<li><p> deltaMax. A positive numeric argument, specifying the maximum allowable divergence from the Hamiltonian value. Paths which exceed this value are considered divergent and will not proceed further. (default = 1000)
</p>
</li>
<li><p> M. A vector of positive real numbers, with length equal to the number of dimensions being sampled. Elements of <code>M</code> specify the diagonal elements of the diagonal mass matrix (or the metric) used for the auxiliary momentum variables in sampling. Sampling may be improved if the elements of <code>M</code> approximate the marginal inverse variance (precision) of the (potentially transformed) parameters. (default: a vector of ones).
</p>
</li>
<li><p> warmupMode. A character string, specifying the behavior for choosing the number of warmup iterations. Four values are possible. The value 'default' (the default) sets the number of warmup iterations as the number of burnin iterations (if a positive value for <code>nburnin</code> is used) or half the number of MCMC iterations in each chain (if <code>nburnin = 0</code>). The value 'burnin' sets the number of warmup iterations as the number of burnin iterations regardless of the length of the burnin period. The value 'fraction' sets the number of warmup iterations as <code>fraction*niter</code>, where <code>fraction</code> is the value of the <code>warmup</code> control argument, and <code>niter</code> is the number of MCMC iterations in each chain; in this case, the value of the <code>warmup</code> control argument must be between 0 and 1. The value 'iterations' sets the number of warmup iterations as the value of the <code>warmup</code> control argumnet, regardless of the length of the burnin period or the number of MCMC iterations; in this case the value of <code>warmup</code> must be a non-negative integer. In all cases, the number of (pre-thinning) samples discarded equals <code>nburnin</code>, as is always the case for MCMC in NIMBLE.
</p>
</li>
<li><p> warmup. Numeric value used in determining the number of warmup iterations. This control argument is only used when <code>warmupMode</code> is 'fraction' or 'iterations'. 
</p>
</li>
<li><p> maxTreeDepth. The maximum allowable depth of the binary leapfrog search tree for generating candidate transitions. (default = 10)
</p>
</li>
<li><p> adaptWindow. Number of iterations in the first adaptation window used for adapting the mass matrix (M). Subsequent adaptation windows double in length, so long as enough warmup iterations are available. (default = 25)
</p>
</li>
<li><p> initBuffer. Number of iterations in the initial warmup window, which occurs prior to the first adaptation of the metric M. (default = 75)
</p>
</li>
<li><p> termBuffer. Number of iterations in the final (terminal) warmup window, before which the metric M is not adjusted. (default = 50)
</p>
</li>
<li><p> adaptive. A logical argument, specifying whether to do any adaptation whatsoever. When <code>TRUE</code>, specific adaptation routines are controlled by the <code>adaptEpsilon</code> and <code>adaptM</code> control list elements. (default = TRUE)
</p>
</li>
<li><p> adaptEpsilon. A logical argument, specifying whether to perform stepsize adaptation. Only used when <code>adaptive = TRUE</code>. (default = TRUE)
</p>
</li>
<li><p> adaptM. A logical argument, specifying whether to perform adaptation of the mass matrix (metric) M. Only used when <code>adaptive = TRUE</code>. (default = TRUE)
</p>
</li>
<li><p> initializeEpsilon. A logical argument, specifying whether to perform the epsilon (stepsize) initialization routine at the onset of each adaptation window. (default = TRUE)
</p>
</li></ul>

<p><code>NaN</code> values may be encountered in the course of the leapfrog procedure. In particular, when the stepsize (<code>epsilon</code>) is too large, the leapfrog procedure can step too far and arrive at an invalid region of parameter space, thus generating a <code>NaN</code> value in the likelihood evaluation or in the gradient calculation. These situation are handled by the sampler by rejecting the <code>NaN</code> value, and reducing the stepsize.
</p>


<h3>Value</h3>

<p>A object of class 'sampler_NUTS_classic'.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>References</h3>

<p>Hoffman, Matthew D., and Gelman, Andrew (2014). The No-U-Turn Sampler: Adaptively setting path lengths in Hamiltonian Monte Carlo. <em>Journal of Machine Learning Research</em>, 15(1): 1593-1623.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>code &lt;- nimbleCode({
    b0 ~ dnorm(0, 0.001)
    b1 ~ dnorm(0, 0.001)
    sigma ~ dunif(0, 10000)
    for(i in 1:N) {
        mu[i] &lt;- b0 + b1 * x[i]
        y[i] ~ dnorm(mu[i], sd = sigma)
    }
})

set.seed(0)
N &lt;- 100
x &lt;- rnorm(N)
y &lt;- 1 + 0.3*x + rnorm(N)
constants &lt;- list(N = N, x = x)
data &lt;- list(y = y)
inits &lt;- list(b0 = 1, b1 = 0.1, sigma = 1)

Rmodel &lt;- nimbleModel(code, constants, data, inits, buildDerivs = TRUE)

conf &lt;- configureMCMC(Rmodel, nodes = NULL)

conf$addSampler(target = c('b0', 'b1', 'sigma'), type = 'NUTS_classic')

Rmcmc &lt;- buildMCMC(conf)

</code></pre>

<hr>
<h2 id='stateNL_NUTS'>nimbleList definition used internally in NUTS sampler.</h2><span id='topic+stateNL_NUTS'></span>

<h3>Description</h3>

<p>nimbleList definition used internally in NUTS sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stateNL_NUTS
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 1.
</p>

<hr>
<h2 id='treebranchNL_NUTS'>nimbleList definition used internally in NUTS sampler.</h2><span id='topic+treebranchNL_NUTS'></span>

<h3>Description</h3>

<p>nimbleList definition used internally in NUTS sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treebranchNL_NUTS
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 1.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
