<!DOCTYPE html><html lang="en"><head><title>Help for package passport</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {passport}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_country_code'><p>Convert standardized country names to country codes</p></a></li>
<li><a href='#as_country_name'><p>Convert standardized country codes to country names</p></a></li>
<li><a href='#codes'><p>Country code and name details and documentation</p></a></li>
<li><a href='#country_format'><p>Construct formatter function to format country codes as country names</p></a></li>
<li><a href='#nato'><p>NATO Member Defense Expenditures</p></a></li>
<li><a href='#order_countries'><p>Order a vector of countries</p></a></li>
<li><a href='#parse_country'><p>Parse country names to standardized form</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Travel Smoothly Between Country Name and Code Formats</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Smooths the process of working with country names and codes via 
    powerful parsing, standardization, and conversion utilities arranged in a 
    simple, consistent API. Country name formats include multiple sources 
    including the Unicode Common Locale Data 
    Repository (CLDR, <a href="http://cldr.unicode.org/">http://cldr.unicode.org/</a>) common-sense standardized 
    names in hundreds of languages.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, dplyr, DT, gapminder, ggplot2, jsonlite, knitr, mockr,
rmarkdown, testthat, tidyr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/alistaire47/passport">https://github.com/alistaire47/passport</a>,
<a href="https://alistaire47.github.io/passport/">https://alistaire47.github.io/passport/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/alistaire47/passport/issues">https://github.com/alistaire47/passport/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-11-07 07:09:00 UTC; alistaire</td>
</tr>
<tr>
<td>Author:</td>
<td>Edward Visel <a href="https://orcid.org/0000-0002-2811-6254"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Edward Visel &lt;edward.visel@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-11-07 07:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_country_code'>Convert standardized country names to country codes</h2><span id='topic+as_country_code'></span>

<h3>Description</h3>

<p><code>as_country_code</code> converts a vector of standardized country names or codes to
country codes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_country_code(x, from, to = "iso2c", factor = is.factor(x))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_country_code_+3A_x">x</code></td>
<td>
<p>A character, factor, or numeric vector of country names or codes</p>
</td></tr>
<tr><td><code id="as_country_code_+3A_from">from</code></td>
<td>
<p>Format from which to convert. See Details for more options.</p>
</td></tr>
<tr><td><code id="as_country_code_+3A_to">to</code></td>
<td>
<p>Code format to which to convert. Defaults to <code>"iso2c"</code>; see
<code><a href="#topic+codes">codes</a></code> for more options.</p>
</td></tr>
<tr><td><code id="as_country_code_+3A_factor">factor</code></td>
<td>
<p>If <code>TRUE</code>, returns factor instead of character vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as_country_code</code> takes a character, factor, or numeric vector of country
names or codes to translate into the specified code format. The default for
<code>to</code> is <code>"iso2c"</code>, the ISO 3166-1 Alpha-2 character codes, but many
alternatives are available.
</p>
<p>Several non-unique codes are available as well, including <code>"continent"</code>,
<code>"is_independent"</code>, ISO 4217 currency codes, etc. Backwards conversion will
not work for such cases.
</p>
<p>See <code><a href="#topic+codes">codes</a></code> for all options, or run <code>DT::datatable(codes)</code> for a
searchable widget.
</p>


<h3>Value</h3>

<p>A vector of country codes. Warns if new <code>NA</code> values are added.
</p>


<h3>See Also</h3>

<p>For converting to country names, use <code><a href="#topic+as_country_name">as_country_name()</a></code>, which
offers control of short and variant forms. For parsing non-standardized
country names to codes, use <code><a href="#topic+parse_country">parse_country()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Codifies standardized names
as_country_code(c("US", "Taiwan", "Myanmar", "Kosovo", "South Korea"), from = "en")

# Translates codes; if passed a factor, returns a releveled one
as_country_code(factor(c("SAH", "PCN", "OMA", "JPN")),
                from = "fifa", to = "iso4217_3c")

</code></pre>

<hr>
<h2 id='as_country_name'>Convert standardized country codes to country names</h2><span id='topic+as_country_name'></span>

<h3>Description</h3>

<p><code>as_country_name</code> converts a vector of standardized country codes to
country names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_country_name(
  x,
  to = "en",
  from = "iso2c",
  short = TRUE,
  variant = FALSE,
  factor = is.factor(x)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_country_name_+3A_x">x</code></td>
<td>
<p>A character, factor, or numeric vector of country codes or names</p>
</td></tr>
<tr><td><code id="as_country_name_+3A_to">to</code></td>
<td>
<p>Language code of country names desired. Defaults to <code>"en"</code>;
see <code><a href="#topic+codes">codes</a></code> for more options.</p>
</td></tr>
<tr><td><code id="as_country_name_+3A_from">from</code></td>
<td>
<p>Code format from which to convert. Defaults to <code>"iso2c"</code>;
see <code><a href="#topic+codes">codes</a></code> for more options.</p>
</td></tr>
<tr><td><code id="as_country_name_+3A_short">short</code></td>
<td>
<p>Whether to use short alternative name when available. Can be
length 1 or the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="as_country_name_+3A_variant">variant</code></td>
<td>
<p>Whether to use variant alternative name when available. Can
be length 1 or the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="as_country_name_+3A_factor">factor</code></td>
<td>
<p>If <code>TRUE</code>, returns factor instead of character vector. If not
supplied, defaults to <code>is.factor(x)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as_country_name</code> takes a character, factor, or numeric vector of country
codes (or names in another standardized format) and converts them to
country names in the specified format. If you are trying to standardize an
existing set of names, see <code><a href="#topic+parse_country">parse_country()</a></code>.
</p>
<p>The default <code>"en"</code> is
from <a href="http://cldr.unicode.org/">Unicode Common Locale Data Repository (CLDR)</a>,
which <a href="http://cldr.unicode.org/translation/displaynames/country-names">aspires to use the most customary name</a>
e.g. &quot;Switzerland&quot; instead of official ones, which are frequently awkward for
common usage, e.g. &quot;Swiss Confederation&quot;. CLDR also supplies names in a huge
variety of languages, allowing for easy translation. Short and variant
alternates are available for some countries; if not, the function will fall
back to the standard form. See LICENSE file for terms of use.
</p>
<p>Other name sets are available from
</p>

<ul>
<li> <p><a href="https://unstats.un.org/unsd/methodology/m49/">the UN Statistics Division(UNSD)</a>,
which maintains standardized names in English, Chinese, Russian, French,
Spanish, and Arabic, here named as <code>"en_un"</code> etc.
</p>
</li>
<li> <p><a href="https://www.iso.org/home.html">the ISO</a>, <code>"en_iso"</code> and <code>"fr_iso"</code>, and
</p>
</li>
<li> <p><a href="https://www.cia.gov/library/publications/the-world-factbook/">the CIA World Factbook</a>:
</p>

<ul>
<li> <p><code>"en_cia"</code>, which include many longer official forms and shorter
practical forms,
</p>
</li>
<li> <p><code>"en_cia_local"</code>, which includes transliterations, and
</p>
</li>
<li> <p><code>"en_cia_abbreviation"</code>, which includes commonly-used abbreviations.
</p>
</li></ul>

</li></ul>

<p>See <code><a href="#topic+codes">codes</a></code> for all options, or run <code>DT::datatable(codes)</code> for a
searchable widget.
</p>


<h3>Value</h3>

<p>A character or factor vector of country names. Warns if new <code>NA</code>
values are added.
</p>


<h3>See Also</h3>

<p>For converting standardized names to codes, use <code><a href="#topic+as_country_code">as_country_code()</a></code>.
For standardizing names to codes, use <code><a href="#topic+parse_country">parse_country()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Usable names for tough-to-standardize places
as_country_name(c("US", "TW", "MM", "XK", "KR"))

# If passed a factor, will return a releveled one
as_country_name(factor(c("US", "NF", "CD", "SJ")), short = FALSE, variant = TRUE)

# Speaks a lot of languages, knows a lot of codes
as_country_name(c("SAH", "PCN", "OMA", "JPN"), from = "fifa", to = "cy")    # to Welsh

</code></pre>

<hr>
<h2 id='codes'>Country code and name details and documentation</h2><span id='topic+codes'></span>

<h3>Description</h3>

<p>A codebook data.frame of codes and details for country code and name
conversions available. Contains
<a href="https://en.wikipedia.org/wiki/IETF_language_tag">Internet Engineering Task Force (IETF) language tags</a>
(e.g. <code>"en-nz"</code> for New Zealand English) for
<a href="http://cldr.unicode.org/">Unicode Common Locale Data Repository (CLDR)</a> names,
similar approximations for institutional names (e.g. <code>"en-iso"</code>), and short
names (e.g. <code>"iso2c"</code>) for country codes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codes
</code></pre>


<h3>Format</h3>

<p>A data.frame of 427 rows and 9 variables.
</p>
<p>Variables:
</p>

<dl>
<dt><code>column</code></dt><dd><p>The column name in the internal <code>passport:::countries</code>
data.frame. Valid for use in <code>from</code> and <code>to</code> parameters.</p>
</dd>
<dt><code>code</code></dt><dd><p><code>column</code> with hyphens for underscores, which is a valid IANA
language tag for Unicode CLDR country names. Valid for use in <code>from</code> and
<code>to</code> parameters.</p>
</dd>
<dt><code>name</code></dt><dd><p>Full name or code name for non-CLDR options.</p>
</dd>
<dt><code>notes</code></dt><dd><p>Things to note, including deprecations, oddities, etc.</p>
</dd>
<dt><code>language</code></dt><dd><p>Full language name parsed from <code>code</code>.</p>
</dd>
<dt><code>region</code></dt><dd><p>Full country or region name parsed from <code>code</code>.</p>
</dd>
<dt><code>script</code></dt><dd><p>Full language script name parsed from <code>code</code>.</p>
</dd>
<dt><code>variant</code></dt><dd><p>Full variant parsed from <code>code</code>. Also used for
organization-standardized names.</p>
</dd>
<dt><code>extension</code></dt><dd><p>Further specification of name type.</p>
</dd>
</dl>



<h3>Details</h3>

<p>All functions can accept codes separated with underscores <code style="white-space: pre;">&#8288;_&#8288;</code>, hyphens <code>-</code>,
or periods <code>.</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A searchable widget to find a code or name
if (requireNamespace("DT", quietly = TRUE)) {
    DT::datatable(codes)
}
</code></pre>

<hr>
<h2 id='country_format'>Construct formatter function to format country codes as country names</h2><span id='topic+country_format'></span>

<h3>Description</h3>

<p><code>country_format</code> is a constructor function that returns a function
to format country codes as country names suitable for passing to ggplot2's
scale functions' <code>label</code> parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>country_format(
  from = "iso2c",
  to = "en",
  short = TRUE,
  variant = FALSE,
  factor
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="country_format_+3A_from">from</code></td>
<td>
<p>Code format from which to convert. Defaults to <code>"iso2c"</code>;
see <code><a href="#topic+codes">codes</a></code> for more options.</p>
</td></tr>
<tr><td><code id="country_format_+3A_to">to</code></td>
<td>
<p>Language code of country names desired. Defaults to <code>"en"</code>;
see <code><a href="#topic+codes">codes</a></code> for more options.</p>
</td></tr>
<tr><td><code id="country_format_+3A_short">short</code></td>
<td>
<p>Whether to use short alternative name when available. Can be
length 1 or the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="country_format_+3A_variant">variant</code></td>
<td>
<p>Whether to use variant alternative name when available. Can
be length 1 or the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="country_format_+3A_factor">factor</code></td>
<td>
<p>If <code>TRUE</code>, returns factor instead of character vector. If not
supplied, defaults to <code>is.factor(x)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A frequent reason to convert country codes back to country names is to make
data visualizations more readable. While both a code and name could be
stored in a data frame, the computation and extra storage required can be
avoided by transforming codes to names directly within the visualization via
a formatter function. <code><a href="#topic+as_country_name">as_country_name()</a></code> could be used without
parentheses to format ISO 2-character codes as English names, but
<code>format_country</code> allows greater flexibility, returning a formatter
function with the specified parameters set.
</p>


<h3>Value</h3>

<p>A function that accepts a vector of country codes and returns them
as country names.
</p>


<h3>See Also</h3>

<p>For controlling the order of a discrete scale, pass the results of
<code><a href="#topic+order_countries">order_countries()</a></code> to <code>limits</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(ggplot2, quietly = TRUE)) {
    ggplot(data.frame(country = c("KOR", "MMR", "TWN", "COG"),
                      y = 1:4),
           aes(x = country, y = y)) +
        geom_col() +
        scale_x_discrete(labels = country_format(from = "iso3c"))
}

</code></pre>

<hr>
<h2 id='nato'>NATO Member Defense Expenditures</h2><span id='topic+nato'></span>

<h3>Description</h3>

<p>A sample dataset of NATO/OTAN member defense expenditures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nato
</code></pre>


<h3>Format</h3>

<p>A data.frame of 232 rows and 14 variables.
</p>
<p>Variables:
</p>

<dl>
<dt><code>country_stanag</code></dt><dd><p>Country code in NATO STANAG format</p>
</dd>
<dt><code>year</code></dt><dd><p>Year, from 2012 to 2019. 2018-2019 numbers may be estimates.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;Defense expenditure (USD, current prices)&#8288;</code></dt><dd>
<p>Defense expenditures in US dollars, using current prices and exchange rates.
</p>
</dd>
<dt><code style="white-space: pre;">&#8288;Defense expenditure (USD, 2015 prices)&#8288;</code></dt><dd>
<p>Defense expenditures in US dollars, using 2015 prices and exchange rates.
</p>
</dd>
<dt><code style="white-space: pre;">&#8288;Defense expenditure (% real GDP)&#8288;</code></dt><dd>
<p>Defense expenditure as a percentage of real gross domestic product.
Based on 2015 prices.
</p>
</dd>
<dt><code style="white-space: pre;">&#8288;Defense expenditure annual real change (% GDP)&#8288;</code></dt><dd>
<p>Annual change in defense expenditure as a percentage of real gross
domestic product. Based on 2015 prices.
</p>
</dd>
<dt><code style="white-space: pre;">&#8288;Real GDP (2015 prices)&#8288;</code></dt><dd>
<p>Real gross domestic product in 2015 US dollars and at 2015 exchange
rates.
</p>
</dd>
<dt><code style="white-space: pre;">&#8288;GDP per capita (USD)&#8288;</code></dt><dd>
<p>Gross domestic product per capita in 2015 US dollars and at 2015
exchange rates.
</p>
</dd>
<dt><code style="white-space: pre;">&#8288;Defense expenditure per capita (USD)&#8288;</code></dt><dd>
<p>Defense expenditure per capita in 2015 US dollars.
</p>
</dd>
<dt><code style="white-space: pre;">&#8288;Military personnel&#8288;</code></dt><dd><p>Number of military personnel</p>
</dd>
<dt><code style="white-space: pre;">&#8288;Equipment expenditure (%)&#8288;</code></dt><dd>
<p>Percent of defense expenditure spent on equipment. Includes major
equipment expenditure and R&amp;D devoted to major equipment.
</p>
</dd>
<dt><code style="white-space: pre;">&#8288;Personnel expenditure (%)&#8288;</code></dt><dd>
<p>Percentage of defense expenditure spent on personnel. Includes both
military and civilian expenditure and pensions.
</p>
</dd>
<dt><code style="white-space: pre;">&#8288;Infrastructure expenditure (%)&#8288;</code></dt><dd>
<p>Percentage of defense expenditure spent on infrastructure. Includes
NATO common infrastructure and national military construction.
</p>
</dd>
<dt><code style="white-space: pre;">&#8288;Other expenditure (%)&#8288;</code></dt><dd>
<p>Percentage of defense expenditure spent on other categories besides
equipment, personnel, and infrastructure. Includes operations and
maintenance expenditure, other R&amp;D expenditure, and other expenditure
not otherwise captured.
</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.nato.int/cps/en/natohq/news_167080.htm">https://www.nato.int/cps/en/natohq/news_167080.htm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_country_name(nato$country_stanag, from = 'stanag')
</code></pre>

<hr>
<h2 id='order_countries'>Order a vector of countries</h2><span id='topic+order_countries'></span>

<h3>Description</h3>

<p><code>order_countries</code> reorders a vector of countries, returning a result useful
for passing to ggplot2's scale functions' <code>limits</code> parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_countries(
  x,
  by,
  ...,
  from = "iso2c",
  short = TRUE,
  variant = FALSE,
  factor = is.factor(x)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="order_countries_+3A_x">x</code></td>
<td>
<p>A character, factor, or numeric vector of country codes or names</p>
</td></tr>
<tr><td><code id="order_countries_+3A_by">by</code></td>
<td>
<p>Either a length-one country code from <code><a href="#topic+codes">codes</a></code> or a vector the
same length as <code>x</code> by which to order <code>x</code></p>
</td></tr>
<tr><td><code id="order_countries_+3A_...">...</code></td>
<td>
<p>Parameters passed on to <code><a href="base.html#topic+order">order()</a></code>, including addition vectors by
which to sort, <code>decreasing</code>, and <code>na.last</code>.</p>
</td></tr>
<tr><td><code id="order_countries_+3A_from">from</code></td>
<td>
<p>Code format from which to convert. Defaults to <code>"iso2c"</code>;
see <code><a href="#topic+codes">codes</a></code> for more options.</p>
</td></tr>
<tr><td><code id="order_countries_+3A_short">short</code></td>
<td>
<p>Whether to use short alternative name when available. Can be
length 1 or the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="order_countries_+3A_variant">variant</code></td>
<td>
<p>Whether to use variant alternative name when available. Can
be length 1 or the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="order_countries_+3A_factor">factor</code></td>
<td>
<p>If <code>TRUE</code>, returns factor instead of character vector. If not
supplied, defaults to <code>is.factor(x)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>order_countries</code> orders a vector of countries by
</p>

<ul>
<li><p> itself converted to a country code or name if <code>by</code> is a code from <code><a href="#topic+codes">codes</a></code>
to which to convert
</p>
</li>
<li><p> a sortable vector if <code>by</code> is a vector of the same length as <code>x</code>
</p>
</li>
<li> <p><code>x</code> itself if neither is supplied.
</p>
</li></ul>



<h3>Value</h3>

<p>The original vector of countries, ordered according to the parameters
passed. Note that factors are not releveled, but are reordered. To
relevel, pass the results to <code><a href="base.html#topic+levels+3C-">levels&lt;-()</a></code>
</p>


<h3>See Also</h3>

<p>To change labels of a discrete scale, pass the results of
<code><a href="#topic+country_format">country_format()</a></code> to the <code>labels</code> parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>countries &lt;- c("FR", "CP", "UZ", "BH", "BR")

order_countries(countries)

order_countries(countries, "ja")

order_countries(countries, rnorm(5))

order_countries(countries, grepl("F", countries), 1:5, decreasing = TRUE)

if (require(ggplot2, quietly = TRUE)) {
    df_countries &lt;- data.frame(country = countries,
                               y = exp(1:5))

    ggplot(df_countries, aes(country, y)) +
        geom_col() +
        scale_x_discrete(
            limits = order_countries(df_countries$country,
                                     df_countries$y)[df_countries$y &gt; 5],
            labels = country_format(to = "en-cia-local")
        )
}

</code></pre>

<hr>
<h2 id='parse_country'>Parse country names to standardized form</h2><span id='topic+parse_country'></span>

<h3>Description</h3>

<p><code>parse_country</code> parses irregular country names to the ISO 3166-1 Alpha-2 code
or other standardized code or name format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_country(
  x,
  to = "iso2c",
  how = c("regex", "google"),
  language = c("en", "de"),
  factor = is.factor(x)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_country_+3A_x">x</code></td>
<td>
<p>A character or factor vector of country names to standardize</p>
</td></tr>
<tr><td><code id="parse_country_+3A_to">to</code></td>
<td>
<p>Format to which to convert. Defaults to <code>"iso2c"</code>; see <code><a href="#topic+codes">codes</a></code>
for more options.</p>
</td></tr>
<tr><td><code id="parse_country_+3A_how">how</code></td>
<td>
<p>How to parse; defaults to <code>"regex"</code>. '&quot;google&quot;&ldquo; uses the Google
Maps geocoding API. See &quot;Details&quot; for more information.</p>
</td></tr>
<tr><td><code id="parse_country_+3A_language">language</code></td>
<td>
<p>If <code>how = "regex"</code>, the language from which to parse country
names. Currently accepts <code>"en"</code> (default) and <code>"de"</code>. Ignored if
<code>how = "google"</code>.</p>
</td></tr>
<tr><td><code id="parse_country_+3A_factor">factor</code></td>
<td>
<p>If <code>TRUE</code>, returns factor instead of character vector. If not
supplied, defaults to <code>is.factor(x)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>parse_country</code> tries to parse a character or factor vector of country names
to a standardized form: by default, ISO 3166-1 Alpha-2 codes.
</p>
<p>When <code>how = "regex"</code> (default), <code>parse_country</code> uses regular expressions to
match irregular forms.
</p>
<p>If regular expressions are insufficient, <code>how = "google"</code> will use the
Google Maps geocoding API instead, which permits a much broader range of
input formats and languages. The API allows 2500 calls per day, and should
thus be called judiciously. <code>parse_country</code> will make one call per unique
input. For more calls, see options that allow passing an API key like
<code>ggmap::geocode()</code> with <code>output = "all"</code> or <code>googleway::google_geocode()</code>.
</p>
<p>Note that due to their flexibility, the APIs may fail unpredictably, e.g.
<code>parse_country("foo", how = "google")</code> returns <code>"CH"</code> whereas <code>how = "regex"</code>
fails with a graceful <code>NA</code> and warning.
</p>


<h3>Value</h3>

<p>A character vector or factor of ISO 2-character country codes or
other specified codes or names. Warns of any parsing failure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parse_country(c("United States", "USA", "U.S.", "us", "United States of America"))

## Not run: 
# Unicode support for parsing accented or non-Latin scripts
parse_country(c("\u65e5\u672c", "Japon", "\u0698\u0627\u067e\u0646"), how = "google")
#&gt; [1] "JP" "JP" "JP" "JP"

# Parse distinct place names via geocoding APIs
parse_country(c("1600 Pennsylvania Ave, DC", "Eiffel Tower"), how = "google")
#&gt; [1] "US" "FR"

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
