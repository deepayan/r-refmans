<!DOCTYPE html><html><head><title>Help for package fastRG</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fastRG}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#chung_lu'><p>Create an undirected Chung-Lu object</p></a></li>
<li><a href='#dcsbm'><p>Create an undirected degree corrected stochastic blockmodel object</p></a></li>
<li><a href='#directed_dcsbm'><p>Create a directed degree corrected stochastic blockmodel object</p></a></li>
<li><a href='#directed_erdos_renyi'><p>Create an directed erdos renyi object</p></a></li>
<li><a href='#directed_factor_model'><p>Create a directed factor model graph</p></a></li>
<li><a href='#eigs_sym.undirected_factor_model'><p>Compute the eigendecomposition of the expected adjacency matrix of an undirected factor model</p></a></li>
<li><a href='#erdos_renyi'><p>Create an undirected erdos renyi object</p></a></li>
<li><a href='#expectation'><p>Calculate the expected adjacency matrix</p></a></li>
<li><a href='#expected_edges'><p>Calculate the expected edges in Poisson RDPG graph</p></a></li>
<li><a href='#mmsbm'><p>Create an undirected degree-corrected mixed membership stochastic blockmodel object</p></a></li>
<li><a href='#overlapping_sbm'><p>Create an undirected overlapping degree corrected stochastic blockmodel object</p></a></li>
<li><a href='#planted_partition'><p>Create an undirected planted partition object</p></a></li>
<li><a href='#plot_expectation'><p>Plot (expected) adjacency matrices</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#sample_edgelist'><p>Sample a random edgelist from a random dot product graph</p></a></li>
<li><a href='#sample_edgelist.matrix'><p>Low level interface to sample RPDG edgelists</p></a></li>
<li><a href='#sample_igraph'><p>Sample a random dot product graph as an igraph graph</p></a></li>
<li><a href='#sample_sparse'><p>Sample a random dot product graph as a sparse Matrix</p></a></li>
<li><a href='#sample_tidygraph'><p>Sample a random dot product graph as a tidygraph graph</p></a></li>
<li><a href='#sbm'><p>Create an undirected stochastic blockmodel object</p></a></li>
<li><a href='#svds.directed_factor_model'><p>Compute the singular value decomposition of the expected adjacency matrix of a directed factor model</p></a></li>
<li><a href='#svds.undirected_factor_model'><p>Compute the singular value decomposition of the expected adjacency matrix of an undirected factor model</p></a></li>
<li><a href='#undirected_factor_model'><p>Create an undirected factor model graph</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Sample Generalized Random Dot Product Graphs in Linear Time</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Samples generalized random product graphs, a generalization of
    a broad class of network models. Given matrices X, S, and Y with with
    non-negative entries, samples a matrix with expectation X S Y^T and
    independent Poisson or Bernoulli entries using the fastRG algorithm of
    Rohe et al. (2017) <a href="https://www.jmlr.org/papers/v19/17-128.html">https://www.jmlr.org/papers/v19/17-128.html</a>. The
    algorithm first samples the number of edges and then puts them down
    one-by-one.  As a result it is O(m) where m is the number of edges, a
    dramatic improvement over element-wise algorithms that which require
    O(n^2) operations to sample a random graph, where n is the number of
    nodes.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rohelab.github.io/fastRG/">https://rohelab.github.io/fastRG/</a>,
<a href="https://github.com/RoheLab/fastRG">https://github.com/RoheLab/fastRG</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RoheLab/fastRG/issues">https://github.com/RoheLab/fastRG/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>Matrix</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, ellipsis, ggplot2, glue, igraph, methods, RSpectra,
stats, tibble, tidygraph, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, magrittr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-21 18:19:36 UTC; alex</td>
</tr>
<tr>
<td>Author:</td>
<td>Alex Hayes <a href="https://orcid.org/0000-0002-4985-5160"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph],
  Karl Rohe [aut, cph],
  Jun Tao [aut],
  Xintian Han [aut],
  Norbert Binkiewicz [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alex Hayes &lt;alexpghayes@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-21 21:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='chung_lu'>Create an undirected Chung-Lu object</h2><span id='topic+chung_lu'></span>

<h3>Description</h3>

<p>To specify a Chung-Lu graph, you must specify
the degree-heterogeneity parameters (via <code>n</code> or <code>theta</code>).
We provide reasonable defaults to enable rapid exploration
or you can invest the effort
for more control over the model parameters. We <strong>strongly recommend</strong>
setting the <code>expected_degree</code> or <code>expected_density</code> argument
to avoid large memory allocations associated with
sampling large, dense graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chung_lu(
  n = NULL,
  theta = NULL,
  ...,
  sort_nodes = TRUE,
  poisson_edges = TRUE,
  allow_self_loops = TRUE,
  force_identifiability = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chung_lu_+3A_n">n</code></td>
<td>
<p>(degree heterogeneity) The number of nodes in the graph.
Use when you don't want to specify the degree-heterogeneity
parameters <code>theta</code> by hand. When <code>n</code> is specified, <code>theta</code>
is randomly generated from a <code>LogNormal(2, 1)</code> distribution.
This is subject to change, and may not be reproducible.
<code>n</code> defaults to <code>NULL</code>. You must specify either <code>n</code>
or <code>theta</code>, but not both.</p>
</td></tr>
<tr><td><code id="chung_lu_+3A_theta">theta</code></td>
<td>
<p>(degree heterogeneity) A numeric vector
explicitly specifying the degree heterogeneity
parameters. This implicitly determines the number of nodes
in the resulting graph, i.e. it will have <code>length(theta)</code> nodes.
Must be positive. Setting to a vector of ones recovers
an erdos renyi graph.
Defaults to <code>NULL</code>. You must specify either <code>n</code> or <code>theta</code>,
but not both.</p>
</td></tr>
<tr><td><code id="chung_lu_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+undirected_factor_model">undirected_factor_model</a></code>
</p>

<dl>
<dt><code>expected_degree</code></dt><dd><p>If specified, the desired expected degree
of the graph. Specifying <code>expected_degree</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Do not specify both
<code>expected_degree</code> and <code>expected_density</code> at the same time.</p>
</dd>
<dt><code>expected_density</code></dt><dd><p>If specified, the desired expected density
of the graph. Specifying <code>expected_density</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Do not specify both
<code>expected_degree</code> and <code>expected_density</code> at the same time.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="chung_lu_+3A_sort_nodes">sort_nodes</code></td>
<td>
<p>Logical indicating whether or not to sort the nodes
so that they are grouped by block and by <code>theta</code>. Useful for plotting.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="chung_lu_+3A_poisson_edges">poisson_edges</code></td>
<td>
<p>Logical indicating whether or not
multiple edges are allowed to form between a pair of
nodes. Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds
as usual, and duplicate edges are removed afterwards. Further,
when <code>FALSE</code>, we assume that <code>S</code> specifies a desired between-factor
connection probability, and back-transform this <code>S</code> to the
appropriate Poisson intensity parameter to approximate Bernoulli
factor connection probabilities. See Section 2.3 of Rohe et al. (2017)
for some additional details.</p>
</td></tr>
<tr><td><code id="chung_lu_+3A_allow_self_loops">allow_self_loops</code></td>
<td>
<p>Logical indicating whether or not
nodes should be allowed to form edges with themselves.
Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds allowing
self-loops, and these are then removed after the fact.</p>
</td></tr>
<tr><td><code id="chung_lu_+3A_force_identifiability">force_identifiability</code></td>
<td>
<p>Logical indicating whether or not to
normalize <code>theta</code> such that it sums to one within each block. Defaults
to <code>FALSE</code>, since this behavior can be surprise when <code>theta</code> is set
to a vector of all ones to recover the DC-SBM case.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>undirected_chung_lu</code> S3 object, a subclass of <code><a href="#topic+dcsbm">dcsbm()</a></code>.
</p>


<h3>See Also</h3>

<p>Other undirected graphs: 
<code><a href="#topic+dcsbm">dcsbm</a>()</code>,
<code><a href="#topic+erdos_renyi">erdos_renyi</a>()</code>,
<code><a href="#topic+mmsbm">mmsbm</a>()</code>,
<code><a href="#topic+overlapping_sbm">overlapping_sbm</a>()</code>,
<code><a href="#topic+planted_partition">planted_partition</a>()</code>,
<code><a href="#topic+sbm">sbm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

cl &lt;- chung_lu(n = 1000, expected_density = 0.01)
cl

theta &lt;- round(stats::rlnorm(100, 2))

cl2 &lt;- chung_lu(
  theta = theta,
  expected_degree = 5
)

cl2

edgelist &lt;- sample_edgelist(cl)
edgelist

</code></pre>

<hr>
<h2 id='dcsbm'>Create an undirected degree corrected stochastic blockmodel object</h2><span id='topic+dcsbm'></span>

<h3>Description</h3>

<p>To specify a degree-corrected stochastic blockmodel, you must specify
the degree-heterogeneity parameters (via <code>n</code> or <code>theta</code>),
the mixing matrix (via <code>k</code> or <code>B</code>), and the relative block
probabilities (optional, via <code>pi</code>). We provide defaults for most of these
options to enable rapid exploration, or you can invest the effort
for more control over the model parameters. We <strong>strongly recommend</strong>
setting the <code>expected_degree</code> or <code>expected_density</code> argument
to avoid large memory allocations associated with
sampling large, dense graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcsbm(
  n = NULL,
  theta = NULL,
  k = NULL,
  B = NULL,
  ...,
  pi = rep(1/k, k),
  sort_nodes = TRUE,
  force_identifiability = FALSE,
  poisson_edges = TRUE,
  allow_self_loops = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcsbm_+3A_n">n</code></td>
<td>
<p>(degree heterogeneity) The number of nodes in the blockmodel.
Use when you don't want to specify the degree-heterogeneity
parameters <code>theta</code> by hand. When <code>n</code> is specified, <code>theta</code>
is randomly generated from a <code>LogNormal(2, 1)</code> distribution.
This is subject to change, and may not be reproducible.
<code>n</code> defaults to <code>NULL</code>. You must specify either <code>n</code>
or <code>theta</code>, but not both.</p>
</td></tr>
<tr><td><code id="dcsbm_+3A_theta">theta</code></td>
<td>
<p>(degree heterogeneity) A numeric vector
explicitly specifying the degree heterogeneity
parameters. This implicitly determines the number of nodes
in the resulting graph, i.e. it will have <code>length(theta)</code> nodes.
Must be positive. Setting to a vector of ones recovers
a stochastic blockmodel without degree correction.
Defaults to <code>NULL</code>. You must specify either <code>n</code> or <code>theta</code>,
but not both.</p>
</td></tr>
<tr><td><code id="dcsbm_+3A_k">k</code></td>
<td>
<p>(mixing matrix) The number of blocks in the blockmodel.
Use when you don't want to specify the mixing-matrix by hand.
When <code>k</code> is specified, the elements of <code>B</code> are drawn
randomly from a <code>Uniform(0, 1)</code> distribution.
This is subject to change, and may not be reproducible.
<code>k</code> defaults to <code>NULL</code>. You must specify either <code>k</code>
or <code>B</code>, but not both.</p>
</td></tr>
<tr><td><code id="dcsbm_+3A_b">B</code></td>
<td>
<p>(mixing matrix) A <code>k</code> by <code>k</code> matrix of block connection
probabilities. The probability that a node in block <code>i</code> connects
to a node in community <code>j</code> is <code>Poisson(B[i, j])</code>. Must be
a square matrix. <code>matrix</code> and <code>Matrix</code> objects are both
acceptable. If <code>B</code> is not symmetric, it will be
symmetrized via the update <code>B := B + t(B)</code>. Defaults to <code>NULL</code>.
You must specify either <code>k</code> or <code>B</code>, but not both.</p>
</td></tr>
<tr><td><code id="dcsbm_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+undirected_factor_model">undirected_factor_model</a></code>
</p>

<dl>
<dt><code>expected_degree</code></dt><dd><p>If specified, the desired expected degree
of the graph. Specifying <code>expected_degree</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Do not specify both
<code>expected_degree</code> and <code>expected_density</code> at the same time.</p>
</dd>
<dt><code>expected_density</code></dt><dd><p>If specified, the desired expected density
of the graph. Specifying <code>expected_density</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Do not specify both
<code>expected_degree</code> and <code>expected_density</code> at the same time.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="dcsbm_+3A_pi">pi</code></td>
<td>
<p>(relative block probabilities) Relative block
probabilities. Must be positive, but do not need to sum
to one, as they will be normalized internally.
Must match the dimensions of <code>B</code> or <code>k</code>. Defaults to
<code>rep(1 / k, k)</code>, or a balanced blocks.</p>
</td></tr>
<tr><td><code id="dcsbm_+3A_sort_nodes">sort_nodes</code></td>
<td>
<p>Logical indicating whether or not to sort the nodes
so that they are grouped by block and by <code>theta</code>. Useful for plotting.
Defaults to <code>TRUE</code>. When <code>TRUE</code>, nodes are first sorted by block
membership, and then by degree-correction parameters within each block.
Additionally, <code>pi</code> is sorted in increasing order, and the columns
of the <code>B</code> matrix are permuted to match the new order of <code>pi</code>.</p>
</td></tr>
<tr><td><code id="dcsbm_+3A_force_identifiability">force_identifiability</code></td>
<td>
<p>Logical indicating whether or not to
normalize <code>theta</code> such that it sums to one within each block. Defaults
to <code>FALSE</code>, since this behavior can be surprise when <code>theta</code> is set
to a vector of all ones to recover the DC-SBM case.</p>
</td></tr>
<tr><td><code id="dcsbm_+3A_poisson_edges">poisson_edges</code></td>
<td>
<p>Logical indicating whether or not
multiple edges are allowed to form between a pair of
nodes. Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds
as usual, and duplicate edges are removed afterwards. Further,
when <code>FALSE</code>, we assume that <code>S</code> specifies a desired between-factor
connection probability, and back-transform this <code>S</code> to the
appropriate Poisson intensity parameter to approximate Bernoulli
factor connection probabilities. See Section 2.3 of Rohe et al. (2017)
for some additional details.</p>
</td></tr>
<tr><td><code id="dcsbm_+3A_allow_self_loops">allow_self_loops</code></td>
<td>
<p>Logical indicating whether or not
nodes should be allowed to form edges with themselves.
Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds allowing
self-loops, and these are then removed after the fact.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>undirected_dcsbm</code> S3 object, a subclass of the
<code><a href="#topic+undirected_factor_model">undirected_factor_model()</a></code> with the following additional
fields:
</p>

<ul>
<li> <p><code>theta</code>: A numeric vector of degree-heterogeneity parameters.
</p>
</li>
<li> <p><code>z</code>: The community memberships of each node, as a <code><a href="base.html#topic+factor">factor()</a></code>.
The factor will have <code>k</code> levels, where <code>k</code> is the number of
communities in the stochastic blockmodel. There will not
always necessarily be observed nodes in each community.
</p>
</li>
<li> <p><code>pi</code>: Sampling probabilities for each block.
</p>
</li>
<li> <p><code>sorted</code>: Logical indicating where nodes are arranged by
block (and additionally by degree heterogeneity parameter)
within each block.
</p>
</li></ul>



<h3>Generative Model</h3>

<p>There are two levels of randomness in a degree-corrected
stochastic blockmodel. First, we randomly chose a block
membership for each node in the blockmodel. This is
handled by <code>dcsbm()</code>. Then, given these block memberships,
we randomly sample edges between nodes. This second
operation is handled by <code><a href="#topic+sample_edgelist">sample_edgelist()</a></code>,
<code><a href="#topic+sample_sparse">sample_sparse()</a></code>, <code><a href="#topic+sample_igraph">sample_igraph()</a></code> and
<code><a href="#topic+sample_tidygraph">sample_tidygraph()</a></code>, depending depending on your desired
graph representation.
</p>


<h4>Block memberships</h4>

<p>Let <code class="reqn">z_i</code> represent the block membership of node <code class="reqn">i</code>.
To generate <code class="reqn">z_i</code> we sample from a categorical
distribution (note that this is a special case of a
multinomial) with parameter <code class="reqn">\pi</code>, such that
<code class="reqn">\pi_i</code> represents the probability of ending up in
the ith block. Block memberships for each node are independent.
</p>



<h4>Degree heterogeneity</h4>

<p>In addition to block membership, the DCSBM also allows
nodes to have different propensities for edge formation.
We represent this propensity for node <code class="reqn">i</code> by a positive
number <code class="reqn">\theta_i</code>. Typically the <code class="reqn">\theta_i</code> are
constrained to sum to one for identifiability purposes,
but this doesn't really matter during sampling (i.e.
without the sum constraint scaling <code class="reqn">B</code> and <code class="reqn">\theta</code>
has the same effect on edge probabilities, but whether
<code class="reqn">B</code> or <code class="reqn">\theta</code> is responsible for this change
is uncertain).
</p>



<h4>Edge formulation</h4>

<p>Once we know the block memberships <code class="reqn">z</code> and the degree
heterogeneity parameters <code class="reqn">theta</code>, we need one more
ingredient, which is the baseline intensity of connections
between nodes in block <code>i</code> and block <code>j</code>. Then each edge
<code class="reqn">A_{i,j}</code> is Poisson distributed with parameter
</p>
<p style="text-align: center;"><code class="reqn">
  \lambda[i, j] = \theta_i \cdot B_{z_i, z_j} \cdot \theta_j.
</code>
</p>




<h3>See Also</h3>

<p>Other stochastic block models: 
<code><a href="#topic+directed_dcsbm">directed_dcsbm</a>()</code>,
<code><a href="#topic+mmsbm">mmsbm</a>()</code>,
<code><a href="#topic+overlapping_sbm">overlapping_sbm</a>()</code>,
<code><a href="#topic+planted_partition">planted_partition</a>()</code>,
<code><a href="#topic+sbm">sbm</a>()</code>
</p>
<p>Other undirected graphs: 
<code><a href="#topic+chung_lu">chung_lu</a>()</code>,
<code><a href="#topic+erdos_renyi">erdos_renyi</a>()</code>,
<code><a href="#topic+mmsbm">mmsbm</a>()</code>,
<code><a href="#topic+overlapping_sbm">overlapping_sbm</a>()</code>,
<code><a href="#topic+planted_partition">planted_partition</a>()</code>,
<code><a href="#topic+sbm">sbm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

lazy_dcsbm &lt;- dcsbm(n = 1000, k = 5, expected_density = 0.01)
lazy_dcsbm

# sometimes you gotta let the world burn and
# sample a wildly dense graph

dense_lazy_dcsbm &lt;- dcsbm(n = 500, k = 3, expected_density = 0.8)
dense_lazy_dcsbm

# explicitly setting the degree heterogeneity parameter,
# mixing matrix, and relative community sizes rather
# than using randomly generated defaults

k &lt;- 5
n &lt;- 1000
B &lt;- matrix(stats::runif(k * k), nrow = k, ncol = k)

theta &lt;- round(stats::rlnorm(n, 2))

pi &lt;- c(1, 2, 4, 1, 1)

custom_dcsbm &lt;- dcsbm(
  theta = theta,
  B = B,
  pi = pi,
  expected_degree = 50
)

custom_dcsbm

edgelist &lt;- sample_edgelist(custom_dcsbm)
edgelist

# efficient eigendecompostion that leverages low-rank structure in
# E(A) so that you don't have to form E(A) to find eigenvectors,
# as E(A) is typically dense. computation is
# handled via RSpectra

population_eigs &lt;- eigs_sym(custom_dcsbm)

</code></pre>

<hr>
<h2 id='directed_dcsbm'>Create a directed degree corrected stochastic blockmodel object</h2><span id='topic+directed_dcsbm'></span>

<h3>Description</h3>

<p>To specify a degree-corrected stochastic blockmodel, you must specify
the degree-heterogeneity parameters (via <code>n</code> or <code>theta_out</code> and
<code>theta_in</code>), the mixing matrix
(via <code>k_out</code> and <code>k_in</code>, or <code>B</code>), and the relative block
probabilities (optional, via <code>p_out</code> and <code>pi_in</code>).
We provide defaults for most of these
options to enable rapid exploration, or you can invest the effort
for more control over the model parameters. We <strong>strongly recommend</strong>
setting the <code>expected_out_degree</code>, <code>expected_in_degree</code>,
or <code>expected_density</code> argument
to avoid large memory allocations associated with
sampling large, dense graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>directed_dcsbm(
  n = NULL,
  theta_out = NULL,
  theta_in = NULL,
  k_out = NULL,
  k_in = NULL,
  B = NULL,
  ...,
  pi_out = rep(1/k_out, k_out),
  pi_in = rep(1/k_in, k_in),
  sort_nodes = TRUE,
  force_identifiability = TRUE,
  poisson_edges = TRUE,
  allow_self_loops = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="directed_dcsbm_+3A_n">n</code></td>
<td>
<p>(degree heterogeneity) The number of nodes in the blockmodel.
Use when you don't want to specify the degree-heterogeneity
parameters <code>theta_out</code> and <code>theta_in</code> by hand. When <code>n</code> is specified,
<code>theta_out</code> and <code>theta_in</code> are randomly generated from
a <code>LogNormal(2, 1)</code> distribution.
This is subject to change, and may not be reproducible.
<code>n</code> defaults to <code>NULL</code>. You must specify either <code>n</code>
or <code>theta_out</code> and <code>theta_in</code> together, but not both.</p>
</td></tr>
<tr><td><code id="directed_dcsbm_+3A_theta_out">theta_out</code></td>
<td>
<p>(degree heterogeneity) A numeric vector
explicitly specifying the degree heterogeneity
parameters. This implicitly determines the number of nodes
in the resulting graph, i.e. it will have <code>length(theta_out)</code> nodes.
Must be positive. Setting to a vector of ones recovers
a stochastic blockmodel without degree correction.
Defaults to <code>NULL</code>. You must specify either <code>n</code>
or <code>theta_out</code> and <code>theta_in</code> together, but not both. <code>theta_out</code>
controls outgoing degree propensity, or, equivalently,
row sums of the adjacency matrix.</p>
</td></tr>
<tr><td><code id="directed_dcsbm_+3A_theta_in">theta_in</code></td>
<td>
<p>(degree heterogeneity) A numeric vector
explicitly specifying the degree heterogeneity
parameters. This implicitly determines the number of nodes
in the resulting graph, i.e. it will have <code>length(theta)</code> nodes.
Must be positive. Setting to a vector of ones recovers
a stochastic blockmodel without degree correction.
Defaults to <code>NULL</code>. You must specify either <code>n</code>
or <code>theta_out</code> and <code>theta_in</code> together, but not both. <code>theta_in</code>
controls incoming degree propensity, or, equivalently, column
sums of the adjacency matrix.</p>
</td></tr>
<tr><td><code id="directed_dcsbm_+3A_k_out">k_out</code></td>
<td>
<p>(mixing matrix) The number of outgoing blocks in the blockmodel.
Use when you don't want to specify the mixing-matrix by hand.
When <code>k_out</code> is specified, the elements of <code>B</code> are drawn
randomly from a <code>Uniform(0, 1)</code> distribution.
This is subject to change, and may not be reproducible.
<code>k_out</code> defaults to <code>NULL</code>. You must specify either <code>k_out</code> and
<code>k_in</code> together, or <code>B</code>. You may specify all three at once, in which
case <code>k_out</code> is only used to set <code>pi_out</code> (when <code>pi_out</code> is
left at its default argument value).</p>
</td></tr>
<tr><td><code id="directed_dcsbm_+3A_k_in">k_in</code></td>
<td>
<p>(mixing matrix) The number of incoming blocks in the blockmodel.
Use when you don't want to specify the mixing-matrix by hand.
When <code>k_in</code> is specified, the elements of <code>B</code> are drawn
randomly from a <code>Uniform(0, 1)</code> distribution.
This is subject to change, and may not be reproducible.
<code>k_in</code> defaults to <code>NULL</code>. You may specify all three at once, in which
case <code>k_in</code> is only used to set <code>pi_in</code> (when <code>pi_in</code> is
left at its default argument value).</p>
</td></tr>
<tr><td><code id="directed_dcsbm_+3A_b">B</code></td>
<td>
<p>(mixing matrix) A <code>k_out</code> by <code>k_in</code> matrix of block connection
probabilities. The probability that a node in block <code>i</code> connects
to a node in community <code>j</code> is <code>Poisson(B[i, j])</code>.
<code>matrix</code> and <code>Matrix</code> objects are both acceptable.
Defaults to <code>NULL</code>. You must specify either <code>k_out</code> and
<code>k_in</code> together, or <code>B</code>, but not both.</p>
</td></tr>
<tr><td><code id="directed_dcsbm_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+directed_factor_model">directed_factor_model</a></code>
</p>

<dl>
<dt><code>expected_in_degree</code></dt><dd><p>If specified, the desired expected in degree
of the graph. Specifying <code>expected_in_degree</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Specify only one of
<code>expected_in_degree</code>, <code>expected_out_degree</code>, and <code>expected_density</code>.</p>
</dd>
<dt><code>expected_out_degree</code></dt><dd><p>If specified, the desired expected out degree
of the graph. Specifying <code>expected_out_degree</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Specify only one of
<code>expected_in_degree</code>, <code>expected_out_degree</code>, and <code>expected_density</code>.</p>
</dd>
<dt><code>expected_density</code></dt><dd><p>If specified, the desired expected density
of the graph. Specifying <code>expected_density</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Specify only one of
<code>expected_in_degree</code>, <code>expected_out_degree</code>, and <code>expected_density</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="directed_dcsbm_+3A_pi_out">pi_out</code></td>
<td>
<p>(relative block probabilities) Relative block
probabilities. Must be positive, but do not need to sum
to one, as they will be normalized internally.
Must match the rows of <code>B</code>, or <code>k_out</code>. Defaults to
<code>rep(1 / k_out, k_out)</code>, or a balanced outgoing blocks.</p>
</td></tr>
<tr><td><code id="directed_dcsbm_+3A_pi_in">pi_in</code></td>
<td>
<p>(relative block probabilities) Relative block
probabilities. Must be positive, but do not need to sum
to one, as they will be normalized internally.
Must match the columns of <code>B</code>, or <code>k_in</code>. Defaults to
<code>rep(1 / k_in, k_in)</code>, or a balanced incoming blocks.</p>
</td></tr>
<tr><td><code id="directed_dcsbm_+3A_sort_nodes">sort_nodes</code></td>
<td>
<p>Logical indicating whether or not to sort the nodes
so that they are grouped by block. Useful for plotting.
Defaults to <code>TRUE</code>. When <code>TRUE</code>, rows of the expected adjacency matrix
are first sorted by outgoing block membership, and then by
incoming degree-correction parameters within each incoming block.
A similar sorting procedure occurs independently from the columns,
according to the incoming blocks.
Additionally, <code>pi_out</code> and <code>pi_in</code> are sorted in increasing order,
and the columns of the <code>B</code> matrix are permuted to match the
new orderings.</p>
</td></tr>
<tr><td><code id="directed_dcsbm_+3A_force_identifiability">force_identifiability</code></td>
<td>
<p>Logical indicating whether or not to
normalize <code>theta_out</code> such that it sums to one within each incoming
block and <code>theta_in</code> such that it sums to one within each outgoing
block. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="directed_dcsbm_+3A_poisson_edges">poisson_edges</code></td>
<td>
<p>Logical indicating whether or not
multiple edges are allowed to form between a pair of
nodes. Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds
as usual, and duplicate edges are removed afterwards. Further,
when <code>FALSE</code>, we assume that <code>S</code> specifies a desired between-factor
connection probability, and back-transform this <code>S</code> to the
appropriate Poisson intensity parameter to approximate Bernoulli
factor connection probabilities. See Section 2.3 of Rohe et al. (2017)
for some additional details.</p>
</td></tr>
<tr><td><code id="directed_dcsbm_+3A_allow_self_loops">allow_self_loops</code></td>
<td>
<p>Logical indicating whether or not
nodes should be allowed to form edges with themselves.
Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds allowing
self-loops, and these are then removed after the fact.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>directed_dcsbm</code> S3 object, a subclass of the
<code><a href="#topic+directed_factor_model">directed_factor_model()</a></code> with the following additional
fields:
</p>

<ul>
<li> <p><code>theta_out</code>: A numeric vector of incoming community
degree-heterogeneity parameters.
</p>
</li>
<li> <p><code>theta_in</code>: A numeric vector of outgoing community
degree-heterogeneity parameters.
</p>
</li>
<li> <p><code>z_out</code>: The incoming community memberships of each node,
as a <code><a href="base.html#topic+factor">factor()</a></code>. The factor will have <code>k_out</code> levels,
where <code>k_out</code> is the number of incoming
communities in the stochastic blockmodel. There will not
always necessarily be observed nodes in each community.
</p>
</li>
<li> <p><code>z_in</code>: The outgoing community memberships of each node,
as a <code><a href="base.html#topic+factor">factor()</a></code>. The factor will have <code>k_in</code> levels,
where <code>k_in</code> is the number of outgoing
communities in the stochastic blockmodel. There will not
always necessarily be observed nodes in each community.
</p>
</li>
<li> <p><code>pi_out</code>: Sampling probabilities for each incoming
community.
</p>
</li>
<li> <p><code>pi_in</code>: Sampling probabilities for each outgoing
community.
</p>
</li>
<li> <p><code>sorted</code>: Logical indicating where nodes are arranged by
block (and additionally by degree heterogeneity parameter)
within each block.
</p>
</li></ul>



<h3>Generative Model</h3>

<p>There are two levels of randomness in a directed degree-corrected
stochastic blockmodel. First, we randomly chose a incoming
block membership and an outgoing block membership
for each node in the blockmodel. This is
handled by <code>directed_dcsbm()</code>. Then, given these block memberships,
we randomly sample edges between nodes. This second
operation is handled by <code><a href="#topic+sample_edgelist">sample_edgelist()</a></code>,
<code><a href="#topic+sample_sparse">sample_sparse()</a></code>, <code><a href="#topic+sample_igraph">sample_igraph()</a></code> and
<code><a href="#topic+sample_tidygraph">sample_tidygraph()</a></code>, depending on your desired
graph representation.
</p>


<h4>Block memberships</h4>

<p>Let <code class="reqn">x</code> represent the incoming block membership of a node
and <code class="reqn">y</code> represent the outgoing block membership of a node.
To generate <code class="reqn">x</code> we sample from a categorical
distribution with parameter <code class="reqn">\pi_out</code>.
To generate <code class="reqn">y</code> we sample from a categorical
distribution with parameter <code class="reqn">\pi_in</code>.
Block memberships are independent across nodes. Incoming and outgoing
block memberships of the same node are also independent.
</p>



<h4>Degree heterogeneity</h4>

<p>In addition to block membership, the DCSBM also
nodes to have different propensities for incoming and
outgoing edge formation.
We represent the propensity to form incoming edges for a
given node by a positive number <code class="reqn">\theta_out</code>.
We represent the propensity to form outgoing edges for a
given node by a positive number <code class="reqn">\theta_in</code>.
Typically the <code class="reqn">\theta_out</code> (and <code class="reqn">theta_in</code>) across all nodes are
constrained to sum to one for identifiability purposes,
but this doesn't really matter during sampling.
</p>



<h4>Edge formulation</h4>

<p>Once we know the block memberships <code class="reqn">x</code> and <code class="reqn">y</code>
and the degree  heterogeneity parameters <code class="reqn">\theta_{in}</code> and
<code class="reqn">\theta_{out}</code>, we need one more
ingredient, which is the baseline intensity of connections
between nodes in block <code>i</code> and block <code>j</code>. Then each edge forms
independently according to a Poisson distribution with
parameters
</p>
<p style="text-align: center;"><code class="reqn">
  \lambda = \theta_{in} * B_{x, y} * \theta_{out}.
</code>
</p>




<h3>See Also</h3>

<p>Other stochastic block models: 
<code><a href="#topic+dcsbm">dcsbm</a>()</code>,
<code><a href="#topic+mmsbm">mmsbm</a>()</code>,
<code><a href="#topic+overlapping_sbm">overlapping_sbm</a>()</code>,
<code><a href="#topic+planted_partition">planted_partition</a>()</code>,
<code><a href="#topic+sbm">sbm</a>()</code>
</p>
<p>Other directed graphs: 
<code><a href="#topic+directed_erdos_renyi">directed_erdos_renyi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

B &lt;- matrix(0.2, nrow = 5, ncol = 8)
diag(B) &lt;- 0.9

ddcsbm &lt;- directed_dcsbm(
  n = 1000,
  B = B,
  k_out = 5,
  k_in = 8,
  expected_density = 0.01
)

ddcsbm

population_svd &lt;- svds(ddcsbm)

</code></pre>

<hr>
<h2 id='directed_erdos_renyi'>Create an directed erdos renyi object</h2><span id='topic+directed_erdos_renyi'></span>

<h3>Description</h3>

<p>Create an directed erdos renyi object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>directed_erdos_renyi(
  n,
  ...,
  p = NULL,
  poisson_edges = TRUE,
  allow_self_loops = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="directed_erdos_renyi_+3A_n">n</code></td>
<td>
<p>Number of nodes in graph.</p>
</td></tr>
<tr><td><code id="directed_erdos_renyi_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+directed_factor_model">directed_factor_model</a></code>
</p>

<dl>
<dt><code>expected_in_degree</code></dt><dd><p>If specified, the desired expected in degree
of the graph. Specifying <code>expected_in_degree</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Specify only one of
<code>expected_in_degree</code>, <code>expected_out_degree</code>, and <code>expected_density</code>.</p>
</dd>
<dt><code>expected_out_degree</code></dt><dd><p>If specified, the desired expected out degree
of the graph. Specifying <code>expected_out_degree</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Specify only one of
<code>expected_in_degree</code>, <code>expected_out_degree</code>, and <code>expected_density</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="directed_erdos_renyi_+3A_p">p</code></td>
<td>
<p>Probability of an edge between any two nodes. You must specify
either <code>p</code>, <code>expected_in_degree</code>, or <code>expected_out_degree</code>.</p>
</td></tr>
<tr><td><code id="directed_erdos_renyi_+3A_poisson_edges">poisson_edges</code></td>
<td>
<p>Logical indicating whether or not
multiple edges are allowed to form between a pair of
nodes. Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds
as usual, and duplicate edges are removed afterwards. Further,
when <code>FALSE</code>, we assume that <code>S</code> specifies a desired between-factor
connection probability, and back-transform this <code>S</code> to the
appropriate Poisson intensity parameter to approximate Bernoulli
factor connection probabilities. See Section 2.3 of Rohe et al. (2017)
for some additional details.</p>
</td></tr>
<tr><td><code id="directed_erdos_renyi_+3A_allow_self_loops">allow_self_loops</code></td>
<td>
<p>Logical indicating whether or not
nodes should be allowed to form edges with themselves.
Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds allowing
self-loops, and these are then removed after the fact.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>directed_factor_model</code> S3 class based on a list
with the following elements:
</p>

<ul>
<li> <p><code>X</code>: The incoming latent positions as a <code><a href="Matrix.html#topic+Matrix">Matrix()</a></code> object.
</p>
</li>
<li> <p><code>S</code>: The mixing matrix as a <code><a href="Matrix.html#topic+Matrix">Matrix()</a></code> object.
</p>
</li>
<li> <p><code>Y</code>: The outgoing latent positions as a <code><a href="Matrix.html#topic+Matrix">Matrix()</a></code> object.
</p>
</li>
<li> <p><code>n</code>: The number of nodes with incoming edges in the network.
</p>
</li>
<li> <p><code>k1</code>: The dimension of the latent node position vectors
encoding incoming latent communities (i.e. in <code>X</code>).
</p>
</li>
<li> <p><code>d</code>: The number of nodes with outgoing edges in the network.
Does not need to match <code>n</code> &ndash; rectangular adjacency matrices
are supported.
</p>
</li>
<li> <p><code>k2</code>: The dimension of the latent node position vectors
encoding outgoing latent communities (i.e. in <code>Y</code>).
</p>
</li>
<li> <p><code>poisson_edges</code>: Whether or not the graph is taken to be have
Poisson or Bernoulli edges, as indicated by a logical vector
of length 1.
</p>
</li>
<li> <p><code>allow_self_loops</code>: Whether or not self loops are allowed.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other erdos renyi: 
<code><a href="#topic+erdos_renyi">erdos_renyi</a>()</code>
</p>
<p>Other directed graphs: 
<code><a href="#topic+directed_dcsbm">directed_dcsbm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(87)

er &lt;- directed_erdos_renyi(n = 10, p = 0.1)
er

big_er &lt;- directed_erdos_renyi(n = 10^6, expected_in_degree = 5)
big_er

A &lt;- sample_sparse(er)
A

</code></pre>

<hr>
<h2 id='directed_factor_model'>Create a directed factor model graph</h2><span id='topic+directed_factor_model'></span>

<h3>Description</h3>

<p>A directed factor model graph is a directed
generalized Poisson random dot product graph. The edges
in this graph are assumpted to be independent and Poisson
distributed. The graph is parameterized by its expected
adjacency matrix, with is <code style="white-space: pre;">&#8288;E[A] = X S Y'&#8288;</code>. We do not recommend
that causal users use this function, see instead <code>directed_dcsbm()</code>
and related functions, which will formulate common variants
of the stochastic blockmodels as undirected factor models
<em>with lots of helpful input validation</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>directed_factor_model(
  X,
  S,
  Y,
  ...,
  expected_in_degree = NULL,
  expected_out_degree = NULL,
  expected_density = NULL,
  poisson_edges = TRUE,
  allow_self_loops = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="directed_factor_model_+3A_x">X</code></td>
<td>
<p>A <code><a href="base.html#topic+matrix">matrix()</a></code> or <a href="base.html#topic+matrix">Matrix()</a> representing real-valued
latent node positions encoding community structure of
incoming edges. Entries must be positive.</p>
</td></tr>
<tr><td><code id="directed_factor_model_+3A_s">S</code></td>
<td>
<p>A <code><a href="base.html#topic+matrix">matrix()</a></code> or <a href="base.html#topic+matrix">Matrix()</a> mixing matrix. Entries
must be positive.</p>
</td></tr>
<tr><td><code id="directed_factor_model_+3A_y">Y</code></td>
<td>
<p>A <code><a href="base.html#topic+matrix">matrix()</a></code> or <a href="base.html#topic+matrix">Matrix()</a> representing real-valued
latent node positions encoding community structure of
outgoing edges. Entries must be positive.</p>
</td></tr>
<tr><td><code id="directed_factor_model_+3A_...">...</code></td>
<td>
<p>Ignored. For internal developer use only.</p>
</td></tr>
<tr><td><code id="directed_factor_model_+3A_expected_in_degree">expected_in_degree</code></td>
<td>
<p>If specified, the desired expected in degree
of the graph. Specifying <code>expected_in_degree</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Specify only one of
<code>expected_in_degree</code>, <code>expected_out_degree</code>, and <code>expected_density</code>.</p>
</td></tr>
<tr><td><code id="directed_factor_model_+3A_expected_out_degree">expected_out_degree</code></td>
<td>
<p>If specified, the desired expected out degree
of the graph. Specifying <code>expected_out_degree</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Specify only one of
<code>expected_in_degree</code>, <code>expected_out_degree</code>, and <code>expected_density</code>.</p>
</td></tr>
<tr><td><code id="directed_factor_model_+3A_expected_density">expected_density</code></td>
<td>
<p>If specified, the desired expected density
of the graph. Specifying <code>expected_density</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Specify only one of
<code>expected_in_degree</code>, <code>expected_out_degree</code>, and <code>expected_density</code>.</p>
</td></tr>
<tr><td><code id="directed_factor_model_+3A_poisson_edges">poisson_edges</code></td>
<td>
<p>Logical indicating whether or not
multiple edges are allowed to form between a pair of
nodes. Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds
as usual, and duplicate edges are removed afterwards. Further,
when <code>FALSE</code>, we assume that <code>S</code> specifies a desired between-factor
connection probability, and back-transform this <code>S</code> to the
appropriate Poisson intensity parameter to approximate Bernoulli
factor connection probabilities. See Section 2.3 of Rohe et al. (2017)
for some additional details.</p>
</td></tr>
<tr><td><code id="directed_factor_model_+3A_allow_self_loops">allow_self_loops</code></td>
<td>
<p>Logical indicating whether or not
nodes should be allowed to form edges with themselves.
Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds allowing
self-loops, and these are then removed after the fact.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>directed_factor_model</code> S3 class based on a list
with the following elements:
</p>

<ul>
<li> <p><code>X</code>: The incoming latent positions as a <code><a href="Matrix.html#topic+Matrix">Matrix()</a></code> object.
</p>
</li>
<li> <p><code>S</code>: The mixing matrix as a <code><a href="Matrix.html#topic+Matrix">Matrix()</a></code> object.
</p>
</li>
<li> <p><code>Y</code>: The outgoing latent positions as a <code><a href="Matrix.html#topic+Matrix">Matrix()</a></code> object.
</p>
</li>
<li> <p><code>n</code>: The number of nodes with incoming edges in the network.
</p>
</li>
<li> <p><code>k1</code>: The dimension of the latent node position vectors
encoding incoming latent communities (i.e. in <code>X</code>).
</p>
</li>
<li> <p><code>d</code>: The number of nodes with outgoing edges in the network.
Does not need to match <code>n</code> &ndash; rectangular adjacency matrices
are supported.
</p>
</li>
<li> <p><code>k2</code>: The dimension of the latent node position vectors
encoding outgoing latent communities (i.e. in <code>Y</code>).
</p>
</li>
<li> <p><code>poisson_edges</code>: Whether or not the graph is taken to be have
Poisson or Bernoulli edges, as indicated by a logical vector
of length 1.
</p>
</li>
<li> <p><code>allow_self_loops</code>: Whether or not self loops are allowed.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 10000

k1 &lt;- 5
k2 &lt;- 3

d &lt;- 5000

X &lt;- matrix(rpois(n = n * k1, 1), nrow = n)
S &lt;- matrix(runif(n = k1 * k2, 0, .1), nrow = k1, ncol = k2)
Y &lt;- matrix(rexp(n = k2 * d, 1), nrow = d)

fm &lt;- directed_factor_model(X, S, Y)
fm

fm2 &lt;- directed_factor_model(X, S, Y, expected_in_degree = 50)
fm2

</code></pre>

<hr>
<h2 id='eigs_sym.undirected_factor_model'>Compute the eigendecomposition of the expected adjacency matrix of an undirected factor model</h2><span id='topic+eigs_sym.undirected_factor_model'></span>

<h3>Description</h3>

<p>Compute the eigendecomposition of the expected adjacency matrix of an undirected factor model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'undirected_factor_model'
eigs_sym(A, k = A$k, which = "LM", sigma = NULL, opts = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigs_sym.undirected_factor_model_+3A_a">A</code></td>
<td>
<p>An <code><a href="#topic+undirected_factor_model">undirected_factor_model()</a></code>.</p>
</td></tr>
<tr><td><code id="eigs_sym.undirected_factor_model_+3A_k">k</code></td>
<td>
<p>Desired rank of decomposition.</p>
</td></tr>
<tr><td><code id="eigs_sym.undirected_factor_model_+3A_which">which</code></td>
<td>
<p>Selection criterion. See <strong>Details</strong> below.</p>
</td></tr>
<tr><td><code id="eigs_sym.undirected_factor_model_+3A_sigma">sigma</code></td>
<td>
<p>Shift parameter. See section <strong>Shift-And-Invert Mode</strong>.</p>
</td></tr>
<tr><td><code id="eigs_sym.undirected_factor_model_+3A_opts">opts</code></td>
<td>
<p>Control parameters related to the computing
algorithm. See <strong>Details</strong> below.</p>
</td></tr>
<tr><td><code id="eigs_sym.undirected_factor_model_+3A_...">...</code></td>
<td>
<p>Unused, included only for consistency with generic signature.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>which</code> argument is a character string
that specifies the type of eigenvalues to be computed.
Possible values are:
</p>

<table>
<tr>
 <td style="text-align: left;">
  "LM"  </td><td style="text-align: left;">  The <code class="reqn">k</code> eigenvalues with largest magnitude. Here the
              magnitude means the Euclidean norm of complex numbers.</td>
</tr>
<tr>
 <td style="text-align: left;">
  "SM"  </td><td style="text-align: left;">  The <code class="reqn">k</code> eigenvalues with smallest magnitude.</td>
</tr>
<tr>
 <td style="text-align: left;">
  "LR"  </td><td style="text-align: left;">  The <code class="reqn">k</code> eigenvalues with largest real part.</td>
</tr>
<tr>
 <td style="text-align: left;">
  "SR"  </td><td style="text-align: left;">  The <code class="reqn">k</code> eigenvalues with smallest real part.</td>
</tr>
<tr>
 <td style="text-align: left;">
  "LI"  </td><td style="text-align: left;">  The <code class="reqn">k</code> eigenvalues with largest imaginary part.</td>
</tr>
<tr>
 <td style="text-align: left;">
  "SI"  </td><td style="text-align: left;">  The <code class="reqn">k</code> eigenvalues with smallest imaginary part.</td>
</tr>
<tr>
 <td style="text-align: left;">
  "LA"  </td><td style="text-align: left;">  The <code class="reqn">k</code> largest (algebraic) eigenvalues, considering any
              negative sign.</td>
</tr>
<tr>
 <td style="text-align: left;">
  "SA"  </td><td style="text-align: left;">  The <code class="reqn">k</code> smallest (algebraic) eigenvalues, considering any
              negative sign.</td>
</tr>
<tr>
 <td style="text-align: left;">
  "BE"  </td><td style="text-align: left;">  Compute <code class="reqn">k</code> eigenvalues, half from each end of the
              spectrum. When <code class="reqn">k</code> is odd, compute more from the high
              and then from the low end.
</td>
</tr>

</table>

<p><code>eigs()</code> with matrix types &quot;matrix&quot;, &quot;dgeMatrix&quot;, &quot;dgCMatrix&quot;
and &quot;dgRMatrix&quot; can use &quot;LM&quot;, &quot;SM&quot;, &quot;LR&quot;, &quot;SR&quot;, &quot;LI&quot; and &quot;SI&quot;.
</p>
<p><code>eigs_sym()</code> with all supported matrix types,
and <code>eigs()</code> with symmetric matrix types
(&quot;dsyMatrix&quot;, &quot;dsCMatrix&quot;, and &quot;dsRMatrix&quot;) can use &quot;LM&quot;, &quot;SM&quot;, &quot;LA&quot;, &quot;SA&quot; and &quot;BE&quot;.
</p>
<p>The <code>opts</code> argument is a list that can supply any of the
following parameters:
</p>

<dl>
<dt><code>ncv</code></dt><dd><p>Number of Lanzcos basis vectors to use. More vectors
will result in faster convergence, but with greater
memory use. For general matrix, <code>ncv</code> must satisfy
<code class="reqn">k+2\le ncv \le n</code>, and
for symmetric matrix, the constraint is
<code class="reqn">k &lt; ncv \le n</code>.
Default is <code>min(n, max(2*k+1, 20))</code>.</p>
</dd>
<dt><code>tol</code></dt><dd><p>Precision parameter. Default is 1e-10.</p>
</dd>
<dt><code>maxitr</code></dt><dd><p>Maximum number of iterations. Default is 1000.</p>
</dd>
<dt><code>retvec</code></dt><dd><p>Whether to compute eigenvectors. If FALSE,
only calculate and return eigenvalues.</p>
</dd>
<dt><code>initvec</code></dt><dd><p>Initial vector of length <code class="reqn">n</code> supplied to the
Arnoldi/Lanczos iteration. It may speed up the convergence
if <code>initvec</code> is close to an eigenvector of <code class="reqn">A</code>.</p>
</dd>
</dl>


<hr>
<h2 id='erdos_renyi'>Create an undirected erdos renyi object</h2><span id='topic+erdos_renyi'></span>

<h3>Description</h3>

<p>Create an undirected erdos renyi object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>erdos_renyi(n, ..., p = NULL, poisson_edges = TRUE, allow_self_loops = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="erdos_renyi_+3A_n">n</code></td>
<td>
<p>Number of nodes in graph.</p>
</td></tr>
<tr><td><code id="erdos_renyi_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+undirected_factor_model">undirected_factor_model</a></code>
</p>

<dl>
<dt><code>expected_degree</code></dt><dd><p>If specified, the desired expected degree
of the graph. Specifying <code>expected_degree</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Do not specify both
<code>expected_degree</code> and <code>expected_density</code> at the same time.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="erdos_renyi_+3A_p">p</code></td>
<td>
<p>Probability of an edge between any two nodes. You must specify
either <code>p</code> or <code>expected_degree</code>.</p>
</td></tr>
<tr><td><code id="erdos_renyi_+3A_poisson_edges">poisson_edges</code></td>
<td>
<p>Logical indicating whether or not
multiple edges are allowed to form between a pair of
nodes. Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds
as usual, and duplicate edges are removed afterwards. Further,
when <code>FALSE</code>, we assume that <code>S</code> specifies a desired between-factor
connection probability, and back-transform this <code>S</code> to the
appropriate Poisson intensity parameter to approximate Bernoulli
factor connection probabilities. See Section 2.3 of Rohe et al. (2017)
for some additional details.</p>
</td></tr>
<tr><td><code id="erdos_renyi_+3A_allow_self_loops">allow_self_loops</code></td>
<td>
<p>Logical indicating whether or not
nodes should be allowed to form edges with themselves.
Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds allowing
self-loops, and these are then removed after the fact.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>undirected_factor_model</code> S3 class based on a list
with the following elements:
</p>

<ul>
<li> <p><code>X</code>: The latent positions as a <code><a href="Matrix.html#topic+Matrix">Matrix()</a></code> object.
</p>
</li>
<li> <p><code>S</code>: The mixing matrix as a <code><a href="Matrix.html#topic+Matrix">Matrix()</a></code> object.
</p>
</li>
<li> <p><code>n</code>: The number of nodes in the network.
</p>
</li>
<li> <p><code>k</code>: The rank of expectation matrix. Equivalently,
the dimension of the latent node position vectors.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other erdos renyi: 
<code><a href="#topic+directed_erdos_renyi">directed_erdos_renyi</a>()</code>
</p>
<p>Other undirected graphs: 
<code><a href="#topic+chung_lu">chung_lu</a>()</code>,
<code><a href="#topic+dcsbm">dcsbm</a>()</code>,
<code><a href="#topic+mmsbm">mmsbm</a>()</code>,
<code><a href="#topic+overlapping_sbm">overlapping_sbm</a>()</code>,
<code><a href="#topic+planted_partition">planted_partition</a>()</code>,
<code><a href="#topic+sbm">sbm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(87)

er &lt;- erdos_renyi(n = 10, p = 0.1)
er


er &lt;- erdos_renyi(n = 10, expected_density = 0.1)
er

big_er &lt;- erdos_renyi(n = 10^6, expected_degree = 5)
big_er

A &lt;- sample_sparse(er)
A

</code></pre>

<hr>
<h2 id='expectation'>Calculate the expected adjacency matrix</h2><span id='topic+expectation'></span><span id='topic+expectation.undirected_factor_model'></span><span id='topic+expectation.directed_factor_model'></span>

<h3>Description</h3>

<p>Calculate the expected adjacency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expectation(model, ...)

## S3 method for class 'undirected_factor_model'
expectation(model, ...)

## S3 method for class 'directed_factor_model'
expectation(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expectation_+3A_model">model</code></td>
<td>
<p>A <code><a href="#topic+directed_factor_model">directed_factor_model()</a></code> or an <code><a href="#topic+undirected_factor_model">undirected_factor_model()</a></code>
object.</p>
</td></tr>
<tr><td><code id="expectation_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The expected value of the adjacency matrix, conditional on the
latent factors <code>X</code> and <code>Y</code> (if the model is directed).
</p>

<hr>
<h2 id='expected_edges'>Calculate the expected edges in Poisson RDPG graph</h2><span id='topic+expected_edges'></span><span id='topic+expected_degree'></span><span id='topic+expected_in_degree'></span><span id='topic+expected_out_degree'></span><span id='topic+expected_density'></span><span id='topic+expected_degrees'></span>

<h3>Description</h3>

<p>These calculations are conditional on the latent factors
<code>X</code> and <code>Y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expected_edges(factor_model, ...)

expected_degree(factor_model, ...)

expected_in_degree(factor_model, ...)

expected_out_degree(factor_model, ...)

expected_density(factor_model, ...)

expected_degrees(factor_model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expected_edges_+3A_factor_model">factor_model</code></td>
<td>
<p>A <code><a href="#topic+directed_factor_model">directed_factor_model()</a></code> or
<code><a href="#topic+undirected_factor_model">undirected_factor_model()</a></code>.</p>
</td></tr>
<tr><td><code id="expected_edges_+3A_...">...</code></td>
<td>
<p>Ignored. Do not use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the runtime of the <code>fastRG</code> algorithm is proportional to
the expected number of edges in the graph. Expected edge count will be
an underestimate of expected number of edges for Bernoulli
graphs. See the Rohe et al for details.
</p>


<h3>Value</h3>

<p>Expected edge counts, or graph densities.
</p>


<h3>References</h3>

<p>Rohe, Karl, Jun Tao, Xintian Han, and Norbert Binkiewicz. 2017.
&quot;A Note on Quickly Sampling a Sparse Matrix with Low Rank Expectation.&quot;
Journal of Machine Learning Research; 19(77):1-13, 2018.
<a href="https://www.jmlr.org/papers/v19/17-128.html">https://www.jmlr.org/papers/v19/17-128.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##### an undirected blockmodel example

n &lt;- 1000
pop &lt;- n / 2
a &lt;- .1
b &lt;- .05

B &lt;- matrix(c(a,b,b,a), nrow = 2)

b_model &lt;- fastRG::sbm(n = n, k = 2, B = B, poisson_edges = FALSE)

b_model

A &lt;- sample_sparse(b_model)

# compare
mean(rowSums(triu(A)))

pop * a + pop * b  # analytical average degree

##### more generic examples

n &lt;- 10000
k &lt;- 5

X &lt;- matrix(rpois(n = n * k, 1), nrow = n)
S &lt;- matrix(runif(n = k * k, 0, .1), nrow = k)

ufm &lt;- undirected_factor_model(X, S)

expected_edges(ufm)
expected_degree(ufm)
eigs_sym(ufm)

n &lt;- 10000
d &lt;- 1000

k1 &lt;- 5
k2 &lt;- 3

X &lt;- matrix(rpois(n = n * k1, 1), nrow = n)
Y &lt;- matrix(rpois(n = d * k2, 1), nrow = d)
S &lt;- matrix(runif(n = k1 * k2, 0, .1), nrow = k1)

dfm &lt;- directed_factor_model(X = X, S = S, Y = Y)

expected_edges(dfm)
expected_in_degree(dfm)
expected_out_degree(dfm)

svds(dfm)

</code></pre>

<hr>
<h2 id='mmsbm'>Create an undirected degree-corrected mixed membership stochastic blockmodel object</h2><span id='topic+mmsbm'></span>

<h3>Description</h3>

<p>To specify a degree-corrected mixed membership stochastic blockmodel, you must specify
the degree-heterogeneity parameters (via <code>n</code> or <code>theta</code>),
the mixing matrix (via <code>k</code> or <code>B</code>), and the relative block
propensities (optional, via <code>alpha</code>). We provide defaults for most of these
options to enable rapid exploration, or you can invest the effort
for more control over the model parameters. We <strong>strongly recommend</strong>
setting the <code>expected_degree</code> or <code>expected_density</code> argument
to avoid large memory allocations associated with
sampling large, dense graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmsbm(
  n = NULL,
  theta = NULL,
  k = NULL,
  B = NULL,
  ...,
  alpha = rep(1, k),
  sort_nodes = TRUE,
  force_pure = TRUE,
  poisson_edges = TRUE,
  allow_self_loops = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmsbm_+3A_n">n</code></td>
<td>
<p>(degree heterogeneity) The number of nodes in the blockmodel.
Use when you don't want to specify the degree-heterogeneity
parameters <code>theta</code> by hand. When <code>n</code> is specified, <code>theta</code>
is randomly generated from a <code>LogNormal(2, 1)</code> distribution.
This is subject to change, and may not be reproducible.
<code>n</code> defaults to <code>NULL</code>. You must specify either <code>n</code>
or <code>theta</code>, but not both.</p>
</td></tr>
<tr><td><code id="mmsbm_+3A_theta">theta</code></td>
<td>
<p>(degree heterogeneity) A numeric vector
explicitly specifying the degree heterogeneity
parameters. This implicitly determines the number of nodes
in the resulting graph, i.e. it will have <code>length(theta)</code> nodes.
Must be positive. Setting to a vector of ones recovers
a stochastic blockmodel without degree correction.
Defaults to <code>NULL</code>. You must specify either <code>n</code> or <code>theta</code>,
but not both.</p>
</td></tr>
<tr><td><code id="mmsbm_+3A_k">k</code></td>
<td>
<p>(mixing matrix) The number of blocks in the blockmodel.
Use when you don't want to specify the mixing-matrix by hand.
When <code>k</code> is specified, the elements of <code>B</code> are drawn
randomly from a <code>Uniform(0, 1)</code> distribution.
This is subject to change, and may not be reproducible.
<code>k</code> defaults to <code>NULL</code>. You must specify either <code>k</code>
or <code>B</code>, but not both.</p>
</td></tr>
<tr><td><code id="mmsbm_+3A_b">B</code></td>
<td>
<p>(mixing matrix) A <code>k</code> by <code>k</code> matrix of block connection
probabilities. The probability that a node in block <code>i</code> connects
to a node in community <code>j</code> is <code>Poisson(B[i, j])</code>. Must be
a square matrix. <code>matrix</code> and <code>Matrix</code> objects are both
acceptable. If <code>B</code> is not symmetric, it will be
symmetrized via the update <code>B := B + t(B)</code>. Defaults to <code>NULL</code>.
You must specify either <code>k</code> or <code>B</code>, but not both.</p>
</td></tr>
<tr><td><code id="mmsbm_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+undirected_factor_model">undirected_factor_model</a></code>
</p>

<dl>
<dt><code>expected_degree</code></dt><dd><p>If specified, the desired expected degree
of the graph. Specifying <code>expected_degree</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Do not specify both
<code>expected_degree</code> and <code>expected_density</code> at the same time.</p>
</dd>
<dt><code>expected_density</code></dt><dd><p>If specified, the desired expected density
of the graph. Specifying <code>expected_density</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Do not specify both
<code>expected_degree</code> and <code>expected_density</code> at the same time.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mmsbm_+3A_alpha">alpha</code></td>
<td>
<p>(relative block propensities) Relative block
propensities, which are parameters of a Dirichlet distribution.
All elments of <code>alpha</code> must thus be positive.
Must match the dimensions of <code>B</code> or <code>k</code>. Defaults to
<code>rep(1, k)</code>, or balanced membership across blocks.</p>
</td></tr>
<tr><td><code id="mmsbm_+3A_sort_nodes">sort_nodes</code></td>
<td>
<p>Logical indicating whether or not to sort the nodes
so that they are grouped by block and by <code>theta</code>. Useful for plotting.
Defaults to <code>TRUE</code>. When <code>TRUE</code>, nodes are first sorted by block
membership, and then by degree-correction parameters within each block.
Additionally, <code>pi</code> is sorted in increasing order, and the columns
of the <code>B</code> matrix are permuted to match the new order of <code>pi</code>.</p>
</td></tr>
<tr><td><code id="mmsbm_+3A_force_pure">force_pure</code></td>
<td>
<p>Logical indicating whether or not to force presence of
&quot;pure nodes&quot; (nodes that belong only to a single community) for the sake
of identifiability. To include pure nodes, block membership sampling
first proceeds as per usual. Then, after it is complete, <code>k</code> nodes
are chosen randomly as pure nodes, one for each block. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mmsbm_+3A_poisson_edges">poisson_edges</code></td>
<td>
<p>Logical indicating whether or not
multiple edges are allowed to form between a pair of
nodes. Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds
as usual, and duplicate edges are removed afterwards. Further,
when <code>FALSE</code>, we assume that <code>S</code> specifies a desired between-factor
connection probability, and back-transform this <code>S</code> to the
appropriate Poisson intensity parameter to approximate Bernoulli
factor connection probabilities. See Section 2.3 of Rohe et al. (2017)
for some additional details.</p>
</td></tr>
<tr><td><code id="mmsbm_+3A_allow_self_loops">allow_self_loops</code></td>
<td>
<p>Logical indicating whether or not
nodes should be allowed to form edges with themselves.
Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds allowing
self-loops, and these are then removed after the fact.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>undirected_mmsbm</code> S3 object, a subclass of the
<code><a href="#topic+undirected_factor_model">undirected_factor_model()</a></code> with the following additional
fields:
</p>

<ul>
<li> <p><code>theta</code>: A numeric vector of degree-heterogeneity parameters.
</p>
</li>
<li> <p><code>Z</code>: The community memberships of each node, a <code><a href="base.html#topic+matrix">matrix()</a></code> with
<code>k</code> columns, whose row sums all equal one.
</p>
</li>
<li> <p><code>alpha</code>: Community membership proportion propensities.
</p>
</li>
<li> <p><code>sorted</code>: Logical indicating where nodes are arranged by
block (and additionally by degree heterogeneity parameter)
within each block.
</p>
</li></ul>



<h3>Generative Model</h3>

<p>There are two levels of randomness in a degree-corrected
stochastic blockmodel. First, we randomly choose how much
each node belongs to each block in the blockmodel. Each node
is one unit of block membership to distribute. This is
handled by <code>mmsbm()</code>. Then, given these block memberships,
we randomly sample edges between nodes. This second
operation is handled by <code><a href="#topic+sample_edgelist">sample_edgelist()</a></code>,
<code><a href="#topic+sample_sparse">sample_sparse()</a></code>, <code><a href="#topic+sample_igraph">sample_igraph()</a></code> and
<code><a href="#topic+sample_tidygraph">sample_tidygraph()</a></code>, depending depending on your desired
graph representation.
</p>


<h4>Block memberships</h4>

<p>Let <code class="reqn">Z_i</code> by a vector on the <code>k</code> dimensional simplex
representing the block memberships of node <code class="reqn">i</code>.
To generate <code class="reqn">z_i</code> we sample from a Dirichlet
distribution with parameter vector <code class="reqn">\alpha</code>.
Block memberships for each node are independent.
</p>



<h4>Degree heterogeneity</h4>

<p>In addition to block membership, the MMSBM also allows
nodes to have different propensities for edge formation.
We represent this propensity for node <code class="reqn">i</code> by a positive
number <code class="reqn">\theta_i</code>.
</p>



<h4>Edge formulation</h4>

<p>Once we know the block membership vector <code class="reqn">z_i, z_j</code> and the degree
heterogeneity parameters <code class="reqn">\theta</code>, we need one more
ingredient, which is the baseline intensity of connections
between nodes in block <code>i</code> and block <code>j</code>. This is given by a
<code class="reqn">k \times k</code> matrix <code class="reqn">B</code>. Then each edge
<code class="reqn">A_{i,j}</code> is Poisson distributed with parameter
</p>
<p style="text-align: center;"><code class="reqn">
  \lambda_{i, j} = \theta_i \cdot z_i^T  B z_j \cdot \theta_j.
</code>
</p>




<h3>See Also</h3>

<p>Other stochastic block models: 
<code><a href="#topic+dcsbm">dcsbm</a>()</code>,
<code><a href="#topic+directed_dcsbm">directed_dcsbm</a>()</code>,
<code><a href="#topic+overlapping_sbm">overlapping_sbm</a>()</code>,
<code><a href="#topic+planted_partition">planted_partition</a>()</code>,
<code><a href="#topic+sbm">sbm</a>()</code>
</p>
<p>Other undirected graphs: 
<code><a href="#topic+chung_lu">chung_lu</a>()</code>,
<code><a href="#topic+dcsbm">dcsbm</a>()</code>,
<code><a href="#topic+erdos_renyi">erdos_renyi</a>()</code>,
<code><a href="#topic+overlapping_sbm">overlapping_sbm</a>()</code>,
<code><a href="#topic+planted_partition">planted_partition</a>()</code>,
<code><a href="#topic+sbm">sbm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

lazy_mmsbm &lt;- mmsbm(n = 1000, k = 5, expected_density = 0.01)
lazy_mmsbm

# sometimes you gotta let the world burn and
# sample a wildly dense graph

dense_lazy_mmsbm &lt;- mmsbm(n = 500, k = 3, expected_density = 0.8)
dense_lazy_mmsbm

# explicitly setting the degree heterogeneity parameter,
# mixing matrix, and relative community sizes rather
# than using randomly generated defaults

k &lt;- 5
n &lt;- 1000
B &lt;- matrix(stats::runif(k * k), nrow = k, ncol = k)

theta &lt;- round(stats::rlnorm(n, 2))

alpha &lt;- c(1, 2, 4, 1, 1)

custom_mmsbm &lt;- mmsbm(
  theta = theta,
  B = B,
  alpha = alpha,
  expected_degree = 50
)

custom_mmsbm

edgelist &lt;- sample_edgelist(custom_mmsbm)
edgelist

# efficient eigendecompostion that leverages low-rank structure in
# E(A) so that you don't have to form E(A) to find eigenvectors,
# as E(A) is typically dense. computation is
# handled via RSpectra

population_eigs &lt;- eigs_sym(custom_mmsbm)
svds(custom_mmsbm)$d

</code></pre>

<hr>
<h2 id='overlapping_sbm'>Create an undirected overlapping degree corrected stochastic blockmodel object</h2><span id='topic+overlapping_sbm'></span>

<h3>Description</h3>

<p>To specify a overlapping stochastic blockmodel, you must specify
the number of nodes (via <code>n</code>),
the mixing matrix (via <code>k</code> or <code>B</code>), and the  block
probabilities (optional, via <code>pi</code>). We provide defaults for most of these
options to enable rapid exploration, or you can invest the effort
for more control over the model parameters. We <strong>strongly recommend</strong>
setting the <code>expected_degree</code> or <code>expected_density</code> argument
to avoid large memory allocations associated with
sampling large, dense graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlapping_sbm(
  n,
  k = NULL,
  B = NULL,
  ...,
  pi = rep(1/k, k),
  sort_nodes = TRUE,
  force_pure = TRUE,
  poisson_edges = TRUE,
  allow_self_loops = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlapping_sbm_+3A_n">n</code></td>
<td>
<p>The number of nodes in the overlapping SBM.</p>
</td></tr>
<tr><td><code id="overlapping_sbm_+3A_k">k</code></td>
<td>
<p>(mixing matrix) The number of blocks in the blockmodel.
Use when you don't want to specify the mixing-matrix by hand.
When <code>k</code> is specified, <code>B</code> is set to a diagonal dominant matrix with
value <code>0.8</code> along the diagonal and <code>0.1 / (k - 1)</code> on the
off-diagonal. <code>k</code> defaults to <code>NULL</code>. You must specify either <code>k</code>
or <code>B</code>, but not both.</p>
</td></tr>
<tr><td><code id="overlapping_sbm_+3A_b">B</code></td>
<td>
<p>(mixing matrix) A <code>k</code> by <code>k</code> matrix of block connection
probabilities. The probability that a node in block <code>i</code> connects
to a node in community <code>j</code> is <code>Poisson(B[i, j])</code>. Must be
an <em>invertible</em>, symmetric square matrix.
<code>matrix</code> and <code>Matrix</code> objects are both
acceptable. If <code>B</code> is not symmetric, it will be
symmetrized via the update <code>B := B + t(B)</code>. Defaults to <code>NULL</code>.
You must specify either <code>k</code> or <code>B</code>, but not both.</p>
</td></tr>
<tr><td><code id="overlapping_sbm_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+undirected_factor_model">undirected_factor_model</a></code>
</p>

<dl>
<dt><code>expected_degree</code></dt><dd><p>If specified, the desired expected degree
of the graph. Specifying <code>expected_degree</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Do not specify both
<code>expected_degree</code> and <code>expected_density</code> at the same time.</p>
</dd>
<dt><code>expected_density</code></dt><dd><p>If specified, the desired expected density
of the graph. Specifying <code>expected_density</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Do not specify both
<code>expected_degree</code> and <code>expected_density</code> at the same time.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="overlapping_sbm_+3A_pi">pi</code></td>
<td>
<p>(block probabilities) Probability of membership in each
block. Membership in each block is independent under the
overlapping SBM. Defaults to <code>rep(1 / k, k)</code>.</p>
</td></tr>
<tr><td><code id="overlapping_sbm_+3A_sort_nodes">sort_nodes</code></td>
<td>
<p>Logical indicating whether or not to sort the nodes
so that they are grouped by block. Useful for plotting.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="overlapping_sbm_+3A_force_pure">force_pure</code></td>
<td>
<p>Logical indicating whether or not to force presence of
&quot;pure nodes&quot; (nodes that belong only to a single community) for the sake
of identifiability. To include pure nodes, block membership sampling
first proceeds as per usual. Then, after it is complete, <code>k</code> nodes
are chosen randomly as pure nodes, one for each block. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="overlapping_sbm_+3A_poisson_edges">poisson_edges</code></td>
<td>
<p>Logical indicating whether or not
multiple edges are allowed to form between a pair of
nodes. Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds
as usual, and duplicate edges are removed afterwards. Further,
when <code>FALSE</code>, we assume that <code>S</code> specifies a desired between-factor
connection probability, and back-transform this <code>S</code> to the
appropriate Poisson intensity parameter to approximate Bernoulli
factor connection probabilities. See Section 2.3 of Rohe et al. (2017)
for some additional details.</p>
</td></tr>
<tr><td><code id="overlapping_sbm_+3A_allow_self_loops">allow_self_loops</code></td>
<td>
<p>Logical indicating whether or not
nodes should be allowed to form edges with themselves.
Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds allowing
self-loops, and these are then removed after the fact.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>undirected_overlapping_sbm</code> S3 object, a subclass of the
<code><a href="#topic+undirected_factor_model">undirected_factor_model()</a></code> with the following additional
fields:
</p>

<ul>
<li> <p><code>pi</code>: Sampling probabilities for each block.
</p>
</li>
<li> <p><code>sorted</code>: Logical indicating where nodes are arranged by
block (and additionally by degree heterogeneity parameter)
within each block.
</p>
</li></ul>



<h3>Generative Model</h3>

<p>There are two levels of randomness in a degree-corrected
overlapping stochastic blockmodel. First, for each node, we
independently determine if that node is a member of each block. This is
handled by <code>overlapping_sbm()</code>. Then, given these block memberships,
we randomly sample edges between nodes. This second
operation is handled by <code><a href="#topic+sample_edgelist">sample_edgelist()</a></code>,
<code><a href="#topic+sample_sparse">sample_sparse()</a></code>, <code><a href="#topic+sample_igraph">sample_igraph()</a></code> and
<code><a href="#topic+sample_tidygraph">sample_tidygraph()</a></code>, depending depending on your desired
graph representation.
</p>


<h4>Identifiability</h4>

<p>In order to be identifiable, an overlapping SBM must satisfy two conditions:
</p>

<ol>
<li> <p><code>B</code> must be invertible, and
</p>
</li>
<li><p> the must be at least one &quot;pure node&quot; in each block that belongs to no
other blocks.
</p>
</li></ol>




<h4>Block memberships</h4>

<p>Note that some nodes may not belong to any blocks.
</p>
<p><strong>TODO</strong>
</p>



<h4>Edge formulation</h4>

<p>Once we know the block memberships, we need one more
ingredient, which is the baseline intensity of connections
between nodes in block <code>i</code> and block <code>j</code>. Then each edge
<code class="reqn">A_{i,j}</code> is Poisson distributed with parameter
</p>
<p><strong>TODO</strong>
</p>



<h3>References</h3>

<p>Kaufmann, Emilie, Thomas Bonald, and Marc Lelarge.
&quot;A Spectral Algorithm with Additive Clustering for the Recovery of
Overlapping Communities in Networks,&quot; Vol. 9925.
Lecture Notes in Computer Science.
Cham: Springer International Publishing, 2016.
https://doi.org/10.1007/978-3-319-46379-7.
</p>
<p>Latouche, Pierre, Etienne Birmelé, and Christophe Ambroise.
&quot;Overlapping Stochastic Block Models with Application to the
French Political Blogosphere.&quot; The Annals of Applied Statistics 5,
no. 1 (March 2011): 309–36. https://doi.org/10.1214/10-AOAS382.
</p>
<p>Zhang, Yuan, Elizaveta Levina, and Ji Zhu. &quot;Detecting
Overlapping Communities in Networks Using Spectral Methods.&quot;
ArXiv:1412.3432, December 10, 2014. http://arxiv.org/abs/1412.3432.
</p>


<h3>See Also</h3>

<p>Other stochastic block models: 
<code><a href="#topic+dcsbm">dcsbm</a>()</code>,
<code><a href="#topic+directed_dcsbm">directed_dcsbm</a>()</code>,
<code><a href="#topic+mmsbm">mmsbm</a>()</code>,
<code><a href="#topic+planted_partition">planted_partition</a>()</code>,
<code><a href="#topic+sbm">sbm</a>()</code>
</p>
<p>Other undirected graphs: 
<code><a href="#topic+chung_lu">chung_lu</a>()</code>,
<code><a href="#topic+dcsbm">dcsbm</a>()</code>,
<code><a href="#topic+erdos_renyi">erdos_renyi</a>()</code>,
<code><a href="#topic+mmsbm">mmsbm</a>()</code>,
<code><a href="#topic+planted_partition">planted_partition</a>()</code>,
<code><a href="#topic+sbm">sbm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

lazy_overlapping_sbm &lt;- overlapping_sbm(n = 1000, k = 5, expected_density = 0.01)
lazy_overlapping_sbm

# sometimes you gotta let the world burn and
# sample a wildly dense graph

dense_lazy_overlapping_sbm &lt;- overlapping_sbm(n = 500, k = 3, expected_density = 0.8)
dense_lazy_overlapping_sbm

k &lt;- 5
n &lt;- 1000
B &lt;- matrix(stats::runif(k * k), nrow = k, ncol = k)

pi &lt;- c(1, 2, 4, 1, 1) / 5

custom_overlapping_sbm &lt;- overlapping_sbm(
  n = 200,
  B = B,
  pi = pi,
  expected_degree = 5
)

custom_overlapping_sbm

edgelist &lt;- sample_edgelist(custom_overlapping_sbm)
edgelist

# efficient eigendecompostion that leverages low-rank structure in
# E(A) so that you don't have to form E(A) to find eigenvectors,
# as E(A) is typically dense. computation is
# handled via RSpectra

population_eigs &lt;- eigs_sym(custom_overlapping_sbm)

</code></pre>

<hr>
<h2 id='planted_partition'>Create an undirected planted partition object</h2><span id='topic+planted_partition'></span>

<h3>Description</h3>

<p>To specify a planted partition model, you must specify
the number of nodes (via <code>n</code>), the mixing matrix (optional, either via
<code>within_block/between_block</code> or <code>a/b</code>),
and the relative block probabilites (optional, via <code>pi</code>).
We provide defaults for most of these options to enable
rapid exploration, or you can invest the effort
for more control over the model parameters. We <strong>strongly recommend</strong>
setting the <code>expected_degree</code> or <code>expected_density</code> argument
to avoid large memory allocations associated with
sampling large, dense graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>planted_partition(
  n,
  k,
  ...,
  within_block = NULL,
  between_block = NULL,
  a = NULL,
  b = NULL,
  pi = rep(1/k, k),
  sort_nodes = TRUE,
  poisson_edges = TRUE,
  allow_self_loops = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="planted_partition_+3A_n">n</code></td>
<td>
<p>The number of nodes in the network. Must be
a positive integer. This argument is required.</p>
</td></tr>
<tr><td><code id="planted_partition_+3A_k">k</code></td>
<td>
<p>Number of planted partitions, as a positive integer.
This argument is required.</p>
</td></tr>
<tr><td><code id="planted_partition_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+undirected_factor_model">undirected_factor_model</a></code>
</p>

<dl>
<dt><code>expected_degree</code></dt><dd><p>If specified, the desired expected degree
of the graph. Specifying <code>expected_degree</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Do not specify both
<code>expected_degree</code> and <code>expected_density</code> at the same time.</p>
</dd>
<dt><code>expected_density</code></dt><dd><p>If specified, the desired expected density
of the graph. Specifying <code>expected_density</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Do not specify both
<code>expected_degree</code> and <code>expected_density</code> at the same time.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="planted_partition_+3A_within_block">within_block</code></td>
<td>
<p>Probability of within block edges. Must be
strictly between zero and one. Must specify either
<code>within_block</code> and <code>between_block</code>, or <code>a</code> and <code>b</code> to determine
edge probabilities.</p>
</td></tr>
<tr><td><code id="planted_partition_+3A_between_block">between_block</code></td>
<td>
<p>Probability of between block edges. Must be
strictly between zero and one. Must specify either
<code>within_block</code> and <code>between_block</code>, or <code>a</code> and <code>b</code> to determine
edge probabilities.</p>
</td></tr>
<tr><td><code id="planted_partition_+3A_a">a</code></td>
<td>
<p>Integer such that <code>a/n</code> is the probability of edges
within a block. Useful for sparse graphs. Must specify either
<code>within_block</code> and <code>between_block</code>, or <code>a</code> and <code>b</code> to determine
edge probabilities.</p>
</td></tr>
<tr><td><code id="planted_partition_+3A_b">b</code></td>
<td>
<p>Integer such that <code>b/n</code> is the probability of edges
between blocks. Useful for sparse graphs. Must specify either
<code>within_block</code> and <code>between_block</code>, or <code>a</code> and <code>b</code> to determine
edge probabilities.</p>
</td></tr>
<tr><td><code id="planted_partition_+3A_pi">pi</code></td>
<td>
<p>(relative block probabilities) Relative block
probabilities. Must be positive, but do not need to sum
to one, as they will be normalized internally.
Must match the dimensions of <code>B</code> or <code>k</code>. Defaults to
<code>rep(1 / k, k)</code>, or a balanced blocks.</p>
</td></tr>
<tr><td><code id="planted_partition_+3A_sort_nodes">sort_nodes</code></td>
<td>
<p>Logical indicating whether or not to sort the nodes
so that they are grouped by block and by <code>theta</code>. Useful for plotting.
Defaults to <code>TRUE</code>. When <code>TRUE</code>, nodes are first sorted by block
membership, and then by degree-correction parameters within each block.
Additionally, <code>pi</code> is sorted in increasing order, and the columns
of the <code>B</code> matrix are permuted to match the new order of <code>pi</code>.</p>
</td></tr>
<tr><td><code id="planted_partition_+3A_poisson_edges">poisson_edges</code></td>
<td>
<p>Logical indicating whether or not
multiple edges are allowed to form between a pair of
nodes. Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds
as usual, and duplicate edges are removed afterwards. Further,
when <code>FALSE</code>, we assume that <code>S</code> specifies a desired between-factor
connection probability, and back-transform this <code>S</code> to the
appropriate Poisson intensity parameter to approximate Bernoulli
factor connection probabilities. See Section 2.3 of Rohe et al. (2017)
for some additional details.</p>
</td></tr>
<tr><td><code id="planted_partition_+3A_allow_self_loops">allow_self_loops</code></td>
<td>
<p>Logical indicating whether or not
nodes should be allowed to form edges with themselves.
Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds allowing
self-loops, and these are then removed after the fact.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A planted partition model is stochastic blockmodel in which
the diagonal and the off-diagonal of the mixing matrix <code>B</code>
are both constant. This means that edge probabilities
depend only on whether two nodes belong to the same block,
or to different blocks, but the particular blocks themselves
don't have any impact apart from this.
</p>


<h3>Value</h3>

<p>An <code>undirected_planted_partition</code> S3 object, which is a subclass
of the <code><a href="#topic+sbm">sbm()</a></code> object, with additional fields:
</p>

<ul>
<li> <p><code>within_block</code>: The probability of edge formation within a block.
</p>
</li>
<li> <p><code>between_block</code>: The probability of edge formation between two distinct
blocks.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other stochastic block models: 
<code><a href="#topic+dcsbm">dcsbm</a>()</code>,
<code><a href="#topic+directed_dcsbm">directed_dcsbm</a>()</code>,
<code><a href="#topic+mmsbm">mmsbm</a>()</code>,
<code><a href="#topic+overlapping_sbm">overlapping_sbm</a>()</code>,
<code><a href="#topic+sbm">sbm</a>()</code>
</p>
<p>Other undirected graphs: 
<code><a href="#topic+chung_lu">chung_lu</a>()</code>,
<code><a href="#topic+dcsbm">dcsbm</a>()</code>,
<code><a href="#topic+erdos_renyi">erdos_renyi</a>()</code>,
<code><a href="#topic+mmsbm">mmsbm</a>()</code>,
<code><a href="#topic+overlapping_sbm">overlapping_sbm</a>()</code>,
<code><a href="#topic+sbm">sbm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

lazy_pp &lt;- planted_partition(
  n = 1000,
  k = 5,
  expected_density = 0.01,
  within_block = 0.1,
  between_block = 0.01
)

lazy_pp

</code></pre>

<hr>
<h2 id='plot_expectation'>Plot (expected) adjacency matrices</h2><span id='topic+plot_expectation'></span><span id='topic+plot_dense_matrix'></span><span id='topic+plot_sparse_matrix'></span>

<h3>Description</h3>

<p>Plot (expected) adjacency matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_expectation(model)

plot_dense_matrix(A, ...)

plot_sparse_matrix(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_expectation_+3A_model">model</code></td>
<td>
<p>A <code><a href="#topic+directed_factor_model">directed_factor_model()</a></code> or an <code><a href="#topic+undirected_factor_model">undirected_factor_model()</a></code>
object.</p>
</td></tr>
<tr><td><code id="plot_expectation_+3A_a">A</code></td>
<td>
<p>A <code><a href="base.html#topic+matrix">matrix()</a></code>, <code><a href="Matrix.html#topic+Matrix">Matrix::Matrix()</a></code> or <code><a href="Matrix.html#topic+sparseMatrix">Matrix::sparseMatrix()</a></code> object.</p>
</td></tr>
<tr><td><code id="plot_expectation_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot2-package">ggplot2::ggplot2()</a></code> plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

model &lt;- dcsbm(n = 10, k = 2, expected_density = 0.2)

plot_expectation(model)

A &lt;- sample_sparse(model)

plot_sparse_matrix(A)

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+svds'></span><span id='topic+eigs_sym'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>RSpectra</dt><dd><p><code><a href="RSpectra.html#topic+eigs">eigs_sym</a></code>, <code><a href="RSpectra.html#topic+svds">svds</a></code></p>
</dd>
</dl>

<hr>
<h2 id='sample_edgelist'>Sample a random edgelist from a random dot product graph</h2><span id='topic+sample_edgelist'></span><span id='topic+sample_edgelist.undirected_factor_model'></span><span id='topic+sample_edgelist.directed_factor_model'></span>

<h3>Description</h3>

<p>There are two steps to using the <code>fastRG</code> package. First,
you must parameterize a random dot product graph by
sampling the latent factors. Use functions such as
<code><a href="#topic+dcsbm">dcsbm()</a></code>, <code><a href="#topic+sbm">sbm()</a></code>, etc, to perform this specification.
Then, use <code style="white-space: pre;">&#8288;sample_*()&#8288;</code> functions to generate a random graph
in your preferred format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_edgelist(factor_model, ...)

## S3 method for class 'undirected_factor_model'
sample_edgelist(factor_model, ...)

## S3 method for class 'directed_factor_model'
sample_edgelist(factor_model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_edgelist_+3A_factor_model">factor_model</code></td>
<td>
<p>A <code><a href="#topic+directed_factor_model">directed_factor_model()</a></code> or
<code><a href="#topic+undirected_factor_model">undirected_factor_model()</a></code>.</p>
</td></tr>
<tr><td><code id="sample_edgelist_+3A_...">...</code></td>
<td>
<p>Ignored. Do not use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the <code>fastRG</code> algorithm as
described in Rohe et al (2017). Please see the paper
(which is short and open access!!) for details.
</p>


<h3>Value</h3>

<p>A single realization of a random Poisson (or Bernoulli)
Dot Product Graph, represented as a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with two
integer columns, <code>from</code> and <code>to</code>.
</p>
<p><strong>NOTE</strong>: Indices for isolated nodes will not appear in the edgelist!
This can lead to issues if you construct network objects from the
edgelist directly.
</p>
<p>In the undirected case, <code>from</code> and <code>to</code> do not encode
information about edge direction, but we will always have
<code>from &lt;= to</code> for convenience of edge identification.
</p>
<p>To avoid handling such considerations yourself, we recommend using
<code><a href="#topic+sample_sparse">sample_sparse()</a></code>, <code><a href="#topic+sample_igraph">sample_igraph()</a></code>, and <code><a href="#topic+sample_tidygraph">sample_tidygraph()</a></code>
over <code><a href="#topic+sample_edgelist">sample_edgelist()</a></code>.
</p>


<h3>References</h3>

<p>Rohe, Karl, Jun Tao, Xintian Han, and Norbert Binkiewicz. 2017.
&quot;A Note on Quickly Sampling a Sparse Matrix with Low Rank Expectation.&quot;
Journal of Machine Learning Research; 19(77):1-13, 2018.
<a href="https://www.jmlr.org/papers/v19/17-128.html">https://www.jmlr.org/papers/v19/17-128.html</a>
</p>


<h3>See Also</h3>

<p>Other samplers: 
<code><a href="#topic+sample_edgelist.matrix">sample_edgelist.matrix</a>()</code>,
<code><a href="#topic+sample_igraph">sample_igraph</a>()</code>,
<code><a href="#topic+sample_sparse">sample_sparse</a>()</code>,
<code><a href="#topic+sample_tidygraph">sample_tidygraph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(igraph)
library(tidygraph)

set.seed(27)

##### undirected examples ----------------------------

n &lt;- 100
k &lt;- 5

X &lt;- matrix(rpois(n = n * k, 1), nrow = n)
S &lt;- matrix(runif(n = k * k, 0, .1), nrow = k)

# S will be symmetrized internal here, or left unchanged if
# it is already symmetric

ufm &lt;- undirected_factor_model(
  X, S,
  expected_density = 0.1
)

ufm

### sampling graphs as edgelists ----------------------

edgelist &lt;- sample_edgelist(ufm)
edgelist

### sampling graphs as sparse matrices ----------------

A &lt;- sample_sparse(ufm)

inherits(A, "dsCMatrix")
isSymmetric(A)
dim(A)

B &lt;- sample_sparse(ufm)

inherits(B, "dsCMatrix")
isSymmetric(B)
dim(B)

### sampling graphs as igraph graphs ------------------

sample_igraph(ufm)

### sampling graphs as tidygraph graphs ---------------

sample_tidygraph(ufm)

##### directed examples ----------------------------

n2 &lt;- 100

k1 &lt;- 5
k2 &lt;- 3

d &lt;- 50

X &lt;- matrix(rpois(n = n2 * k1, 1), nrow = n2)
S &lt;- matrix(runif(n = k1 * k2, 0, .1), nrow = k1, ncol = k2)
Y &lt;- matrix(rexp(n = k2 * d, 1), nrow = d)

fm &lt;- directed_factor_model(X, S, Y, expected_in_degree = 2)
fm

### sampling graphs as edgelists ----------------------

edgelist2 &lt;- sample_edgelist(fm)
edgelist2

### sampling graphs as sparse matrices ----------------

A2 &lt;- sample_sparse(fm)

inherits(A2, "dgCMatrix")
isSymmetric(A2)
dim(A2)

B2 &lt;- sample_sparse(fm)

inherits(B2, "dgCMatrix")
isSymmetric(B2)
dim(B2)

### sampling graphs as igraph graphs ------------------

# since the number of rows and the number of columns
# in `fm` differ, we will get a bipartite igraph here

# creating the bipartite igraph is slow relative to other
# sampling -- if this is a blocker for
# you please open an issue and we can investigate speedups

dig &lt;- sample_igraph(fm)
is_bipartite(dig)

### sampling graphs as tidygraph graphs ---------------

sample_tidygraph(fm)

</code></pre>

<hr>
<h2 id='sample_edgelist.matrix'>Low level interface to sample RPDG edgelists</h2><span id='topic+sample_edgelist.matrix'></span><span id='topic+sample_edgelist.Matrix'></span>

<h3>Description</h3>

<p><strong>This is a breaks-off, no safety checks interface.</strong>
We strongly recommend that you do not call
<code>sample_edgelist.matrix()</code> unless you know what you are doing,
and even then, we still do not recommend it, as you will
bypass all typical input validation.
<em><strong>extremely loud coughing</strong></em> All those who bypass input
validation suffer foolishly at their own hand.
<em><strong>extremely loud coughing</strong></em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
sample_edgelist(
  factor_model,
  S,
  Y,
  directed,
  poisson_edges,
  allow_self_loops,
  ...
)

## S3 method for class 'Matrix'
sample_edgelist(
  factor_model,
  S,
  Y,
  directed,
  poisson_edges,
  allow_self_loops,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_edgelist.matrix_+3A_factor_model">factor_model</code></td>
<td>
<p>An <code>n</code> by <code>k1</code> <code><a href="base.html#topic+matrix">matrix()</a></code> or <code><a href="Matrix.html#topic+Matrix">Matrix::Matrix()</a></code>
of latent node positions encoding incoming edge community membership.
The <code>X</code> matrix in Rohe et al (2017). Naming differs only for
consistency with the S3 generic.</p>
</td></tr>
<tr><td><code id="sample_edgelist.matrix_+3A_s">S</code></td>
<td>
<p>A <code>k1</code> by <code>k2</code> mixing <code><a href="base.html#topic+matrix">matrix()</a></code> or <code><a href="Matrix.html#topic+Matrix">Matrix::Matrix()</a></code>. In
the undirect case this is assumed to be symmetric but <strong>we do not
check that this is the case</strong>.</p>
</td></tr>
<tr><td><code id="sample_edgelist.matrix_+3A_y">Y</code></td>
<td>
<p>A <code>d</code> by <code>k2</code> <code><a href="base.html#topic+matrix">matrix()</a></code> or <code><a href="Matrix.html#topic+Matrix">Matrix::Matrix()</a></code> of latent
node positions encoding outgoing edge community membership.</p>
</td></tr>
<tr><td><code id="sample_edgelist.matrix_+3A_directed">directed</code></td>
<td>
<p>Logical indicating whether or not the graph should be
directed. When <code>directed = FALSE</code>, symmetrizes <code>S</code> internally.
<code>Y = X</code> together with a symmetric <code>S</code> implies a symmetric
expectation (although not necessarily an undirected graph).
When <code>directed = FALSE</code>, samples a directed graph with
symmetric expectation, and then adds edges until symmetry
is achieved.</p>
</td></tr>
<tr><td><code id="sample_edgelist.matrix_+3A_poisson_edges">poisson_edges</code></td>
<td>
<p>Whether or not to remove duplicate edges
after sampling. See Section 2.3 of Rohe et al. (2017)
for some additional details. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sample_edgelist.matrix_+3A_allow_self_loops">allow_self_loops</code></td>
<td>
<p>Logical indicating whether or not
nodes should be allowed to form edges with themselves.
Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds allowing
self-loops, and these are then removed after the fact.</p>
</td></tr>
<tr><td><code id="sample_edgelist.matrix_+3A_...">...</code></td>
<td>
<p>Ignored, for generic consistency only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the <code>fastRG</code> algorithm as
described in Rohe et al (2017). Please see the paper
(which is short and open access!!) for details.
</p>


<h3>Value</h3>

<p>A single realization of a random Poisson (or Bernoulli)
Dot Product Graph, represented as a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with two
integer columns, <code>from</code> and <code>to</code>.
</p>
<p><strong>NOTE</strong>: Indices for isolated nodes will not appear in the edgelist!
This can lead to issues if you construct network objects from the
edgelist directly.
</p>
<p>In the undirected case, <code>from</code> and <code>to</code> do not encode
information about edge direction, but we will always have
<code>from &lt;= to</code> for convenience of edge identification.
</p>
<p>To avoid handling such considerations yourself, we recommend using
<code><a href="#topic+sample_sparse">sample_sparse()</a></code>, <code><a href="#topic+sample_igraph">sample_igraph()</a></code>, and <code><a href="#topic+sample_tidygraph">sample_tidygraph()</a></code>
over <code><a href="#topic+sample_edgelist">sample_edgelist()</a></code>.
</p>


<h3>References</h3>

<p>Rohe, Karl, Jun Tao, Xintian Han, and Norbert Binkiewicz. 2017.
&quot;A Note on Quickly Sampling a Sparse Matrix with Low Rank Expectation.&quot;
Journal of Machine Learning Research; 19(77):1-13, 2018.
<a href="https://www.jmlr.org/papers/v19/17-128.html">https://www.jmlr.org/papers/v19/17-128.html</a>
</p>


<h3>See Also</h3>

<p>Other samplers: 
<code><a href="#topic+sample_edgelist">sample_edgelist</a>()</code>,
<code><a href="#topic+sample_igraph">sample_igraph</a>()</code>,
<code><a href="#topic+sample_sparse">sample_sparse</a>()</code>,
<code><a href="#topic+sample_tidygraph">sample_tidygraph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(46)

n &lt;- 10000
d &lt;- 1000

k1 &lt;- 5
k2 &lt;- 3

X &lt;- matrix(rpois(n = n * k1, 1), nrow = n)
S &lt;- matrix(runif(n = k1 * k2, 0, .1), nrow = k1)
Y &lt;- matrix(rpois(n = d * k2, 1), nrow = d)

sample_edgelist(X, S, Y, TRUE, TRUE, TRUE)

</code></pre>

<hr>
<h2 id='sample_igraph'>Sample a random dot product graph as an igraph graph</h2><span id='topic+sample_igraph'></span><span id='topic+sample_igraph.undirected_factor_model'></span><span id='topic+sample_igraph.directed_factor_model'></span>

<h3>Description</h3>

<p>There are two steps to using the <code>fastRG</code> package. First,
you must parameterize a random dot product graph by
sampling the latent factors. Use functions such as
<code><a href="#topic+dcsbm">dcsbm()</a></code>, <code><a href="#topic+sbm">sbm()</a></code>, etc, to perform this specification.
Then, use <code style="white-space: pre;">&#8288;sample_*()&#8288;</code> functions to generate a random graph
in your preferred format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_igraph(factor_model, ...)

## S3 method for class 'undirected_factor_model'
sample_igraph(factor_model, ...)

## S3 method for class 'directed_factor_model'
sample_igraph(factor_model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_igraph_+3A_factor_model">factor_model</code></td>
<td>
<p>A <code><a href="#topic+directed_factor_model">directed_factor_model()</a></code> or
<code><a href="#topic+undirected_factor_model">undirected_factor_model()</a></code>.</p>
</td></tr>
<tr><td><code id="sample_igraph_+3A_...">...</code></td>
<td>
<p>Ignored. Do not use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the <code>fastRG</code> algorithm as
described in Rohe et al (2017). Please see the paper
(which is short and open access!!) for details.
</p>


<h3>Value</h3>

<p>An <code><a href="igraph.html#topic+aaa-igraph-package">igraph::igraph()</a></code> object that is possibly a
multigraph (that is, we take there to be multiple edges
rather than weighted edges).
</p>
<p>When <code>factor_model</code> is <strong>undirected</strong>:
</p>
<div class="sourceCode"><pre>- the graph is undirected and one-mode.
</pre></div>
<p>When <code>factor_model</code> is <strong>directed</strong> and <strong>square</strong>:
</p>
<div class="sourceCode"><pre>- the graph is directed and one-mode.
</pre></div>
<p>When <code>factor_model</code> is <strong>directed</strong> and <strong>rectangular</strong>:
</p>
<div class="sourceCode"><pre>- the graph is undirected and bipartite.
</pre></div>
<p>Note that working with bipartite graphs in <code>igraph</code> is more
complex than working with one-mode graphs.
</p>


<h3>References</h3>

<p>Rohe, Karl, Jun Tao, Xintian Han, and Norbert Binkiewicz. 2017.
&quot;A Note on Quickly Sampling a Sparse Matrix with Low Rank Expectation.&quot;
Journal of Machine Learning Research; 19(77):1-13, 2018.
<a href="https://www.jmlr.org/papers/v19/17-128.html">https://www.jmlr.org/papers/v19/17-128.html</a>
</p>


<h3>See Also</h3>

<p>Other samplers: 
<code><a href="#topic+sample_edgelist.matrix">sample_edgelist.matrix</a>()</code>,
<code><a href="#topic+sample_edgelist">sample_edgelist</a>()</code>,
<code><a href="#topic+sample_sparse">sample_sparse</a>()</code>,
<code><a href="#topic+sample_tidygraph">sample_tidygraph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(igraph)
library(tidygraph)

set.seed(27)

##### undirected examples ----------------------------

n &lt;- 100
k &lt;- 5

X &lt;- matrix(rpois(n = n * k, 1), nrow = n)
S &lt;- matrix(runif(n = k * k, 0, .1), nrow = k)

# S will be symmetrized internal here, or left unchanged if
# it is already symmetric

ufm &lt;- undirected_factor_model(
  X, S,
  expected_density = 0.1
)

ufm

### sampling graphs as edgelists ----------------------

edgelist &lt;- sample_edgelist(ufm)
edgelist

### sampling graphs as sparse matrices ----------------

A &lt;- sample_sparse(ufm)

inherits(A, "dsCMatrix")
isSymmetric(A)
dim(A)

B &lt;- sample_sparse(ufm)

inherits(B, "dsCMatrix")
isSymmetric(B)
dim(B)

### sampling graphs as igraph graphs ------------------

sample_igraph(ufm)

### sampling graphs as tidygraph graphs ---------------

sample_tidygraph(ufm)

##### directed examples ----------------------------

n2 &lt;- 100

k1 &lt;- 5
k2 &lt;- 3

d &lt;- 50

X &lt;- matrix(rpois(n = n2 * k1, 1), nrow = n2)
S &lt;- matrix(runif(n = k1 * k2, 0, .1), nrow = k1, ncol = k2)
Y &lt;- matrix(rexp(n = k2 * d, 1), nrow = d)

fm &lt;- directed_factor_model(X, S, Y, expected_in_degree = 2)
fm

### sampling graphs as edgelists ----------------------

edgelist2 &lt;- sample_edgelist(fm)
edgelist2

### sampling graphs as sparse matrices ----------------

A2 &lt;- sample_sparse(fm)

inherits(A2, "dgCMatrix")
isSymmetric(A2)
dim(A2)

B2 &lt;- sample_sparse(fm)

inherits(B2, "dgCMatrix")
isSymmetric(B2)
dim(B2)

### sampling graphs as igraph graphs ------------------

# since the number of rows and the number of columns
# in `fm` differ, we will get a bipartite igraph here

# creating the bipartite igraph is slow relative to other
# sampling -- if this is a blocker for
# you please open an issue and we can investigate speedups

dig &lt;- sample_igraph(fm)
is_bipartite(dig)

### sampling graphs as tidygraph graphs ---------------

sample_tidygraph(fm)

</code></pre>

<hr>
<h2 id='sample_sparse'>Sample a random dot product graph as a sparse Matrix</h2><span id='topic+sample_sparse'></span><span id='topic+sample_sparse.undirected_factor_model'></span><span id='topic+sample_sparse.directed_factor_model'></span>

<h3>Description</h3>

<p>There are two steps to using the <code>fastRG</code> package. First,
you must parameterize a random dot product graph by
sampling the latent factors. Use functions such as
<code><a href="#topic+dcsbm">dcsbm()</a></code>, <code><a href="#topic+sbm">sbm()</a></code>, etc, to perform this specification.
Then, use <code style="white-space: pre;">&#8288;sample_*()&#8288;</code> functions to generate a random graph
in your preferred format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_sparse(factor_model, ...)

## S3 method for class 'undirected_factor_model'
sample_sparse(factor_model, ...)

## S3 method for class 'directed_factor_model'
sample_sparse(factor_model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_sparse_+3A_factor_model">factor_model</code></td>
<td>
<p>A <code><a href="#topic+directed_factor_model">directed_factor_model()</a></code> or
<code><a href="#topic+undirected_factor_model">undirected_factor_model()</a></code>.</p>
</td></tr>
<tr><td><code id="sample_sparse_+3A_...">...</code></td>
<td>
<p>Ignored. Do not use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the <code>fastRG</code> algorithm as
described in Rohe et al (2017). Please see the paper
(which is short and open access!!) for details.
</p>


<h3>Value</h3>

<p>For undirected factor models, a sparse
<code><a href="Matrix.html#topic+Matrix">Matrix::Matrix()</a></code> of class <code>dsCMatrix</code>. In particular,
this means the <code>Matrix</code> object (1) has
double data type, (2) is symmetric, and (3) is in
column compressed storage format.
</p>
<p>For directed factor models, a sparse
<code><a href="Matrix.html#topic+Matrix">Matrix::Matrix()</a></code> of class <code>dgCMatrix</code>. This means
the <code>Matrix</code> object (1) has double data type,
(2) in <em>not</em> symmetric, and (3) is in column
compressed storage format.
</p>
<p>To reiterate: for undirected graphs, you will get
a symmetric matrix. For directed graphs, you will
get a general sparse matrix.
</p>


<h3>References</h3>

<p>Rohe, Karl, Jun Tao, Xintian Han, and Norbert Binkiewicz. 2017.
&quot;A Note on Quickly Sampling a Sparse Matrix with Low Rank Expectation.&quot;
Journal of Machine Learning Research; 19(77):1-13, 2018.
<a href="https://www.jmlr.org/papers/v19/17-128.html">https://www.jmlr.org/papers/v19/17-128.html</a>
</p>


<h3>See Also</h3>

<p>Other samplers: 
<code><a href="#topic+sample_edgelist.matrix">sample_edgelist.matrix</a>()</code>,
<code><a href="#topic+sample_edgelist">sample_edgelist</a>()</code>,
<code><a href="#topic+sample_igraph">sample_igraph</a>()</code>,
<code><a href="#topic+sample_tidygraph">sample_tidygraph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(igraph)
library(tidygraph)

set.seed(27)

##### undirected examples ----------------------------

n &lt;- 100
k &lt;- 5

X &lt;- matrix(rpois(n = n * k, 1), nrow = n)
S &lt;- matrix(runif(n = k * k, 0, .1), nrow = k)

# S will be symmetrized internal here, or left unchanged if
# it is already symmetric

ufm &lt;- undirected_factor_model(
  X, S,
  expected_density = 0.1
)

ufm

### sampling graphs as edgelists ----------------------

edgelist &lt;- sample_edgelist(ufm)
edgelist

### sampling graphs as sparse matrices ----------------

A &lt;- sample_sparse(ufm)

inherits(A, "dsCMatrix")
isSymmetric(A)
dim(A)

B &lt;- sample_sparse(ufm)

inherits(B, "dsCMatrix")
isSymmetric(B)
dim(B)

### sampling graphs as igraph graphs ------------------

sample_igraph(ufm)

### sampling graphs as tidygraph graphs ---------------

sample_tidygraph(ufm)

##### directed examples ----------------------------

n2 &lt;- 100

k1 &lt;- 5
k2 &lt;- 3

d &lt;- 50

X &lt;- matrix(rpois(n = n2 * k1, 1), nrow = n2)
S &lt;- matrix(runif(n = k1 * k2, 0, .1), nrow = k1, ncol = k2)
Y &lt;- matrix(rexp(n = k2 * d, 1), nrow = d)

fm &lt;- directed_factor_model(X, S, Y, expected_in_degree = 2)
fm

### sampling graphs as edgelists ----------------------

edgelist2 &lt;- sample_edgelist(fm)
edgelist2

### sampling graphs as sparse matrices ----------------

A2 &lt;- sample_sparse(fm)

inherits(A2, "dgCMatrix")
isSymmetric(A2)
dim(A2)

B2 &lt;- sample_sparse(fm)

inherits(B2, "dgCMatrix")
isSymmetric(B2)
dim(B2)

### sampling graphs as igraph graphs ------------------

# since the number of rows and the number of columns
# in `fm` differ, we will get a bipartite igraph here

# creating the bipartite igraph is slow relative to other
# sampling -- if this is a blocker for
# you please open an issue and we can investigate speedups

dig &lt;- sample_igraph(fm)
is_bipartite(dig)

### sampling graphs as tidygraph graphs ---------------

sample_tidygraph(fm)

</code></pre>

<hr>
<h2 id='sample_tidygraph'>Sample a random dot product graph as a tidygraph graph</h2><span id='topic+sample_tidygraph'></span><span id='topic+sample_tidygraph.undirected_factor_model'></span><span id='topic+sample_tidygraph.directed_factor_model'></span>

<h3>Description</h3>

<p>There are two steps to using the <code>fastRG</code> package. First,
you must parameterize a random dot product graph by
sampling the latent factors. Use functions such as
<code><a href="#topic+dcsbm">dcsbm()</a></code>, <code><a href="#topic+sbm">sbm()</a></code>, etc, to perform this specification.
Then, use <code style="white-space: pre;">&#8288;sample_*()&#8288;</code> functions to generate a random graph
in your preferred format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_tidygraph(factor_model, ...)

## S3 method for class 'undirected_factor_model'
sample_tidygraph(factor_model, ...)

## S3 method for class 'directed_factor_model'
sample_tidygraph(factor_model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_tidygraph_+3A_factor_model">factor_model</code></td>
<td>
<p>A <code><a href="#topic+directed_factor_model">directed_factor_model()</a></code> or
<code><a href="#topic+undirected_factor_model">undirected_factor_model()</a></code>.</p>
</td></tr>
<tr><td><code id="sample_tidygraph_+3A_...">...</code></td>
<td>
<p>Ignored. Do not use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the <code>fastRG</code> algorithm as
described in Rohe et al (2017). Please see the paper
(which is short and open access!!) for details.
</p>


<h3>Value</h3>

<p>A <code><a href="tidygraph.html#topic+tbl_graph">tidygraph::tbl_graph()</a></code> object that is possibly a
multigraph (that is, we take there to be multiple edges
rather than weighted edges).
</p>
<p>When <code>factor_model</code> is <strong>undirected</strong>:
</p>
<div class="sourceCode"><pre>- the graph is undirected and one-mode.
</pre></div>
<p>When <code>factor_model</code> is <strong>directed</strong> and <strong>square</strong>:
</p>
<div class="sourceCode"><pre>- the graph is directed and one-mode.
</pre></div>
<p>When <code>factor_model</code> is <strong>directed</strong> and <strong>rectangular</strong>:
</p>
<div class="sourceCode"><pre>- the graph is undirected and bipartite.
</pre></div>
<p>Note that working with bipartite graphs in <code>tidygraph</code> is more
complex than working with one-mode graphs.
</p>


<h3>References</h3>

<p>Rohe, Karl, Jun Tao, Xintian Han, and Norbert Binkiewicz. 2017.
&quot;A Note on Quickly Sampling a Sparse Matrix with Low Rank Expectation.&quot;
Journal of Machine Learning Research; 19(77):1-13, 2018.
<a href="https://www.jmlr.org/papers/v19/17-128.html">https://www.jmlr.org/papers/v19/17-128.html</a>
</p>


<h3>See Also</h3>

<p>Other samplers: 
<code><a href="#topic+sample_edgelist.matrix">sample_edgelist.matrix</a>()</code>,
<code><a href="#topic+sample_edgelist">sample_edgelist</a>()</code>,
<code><a href="#topic+sample_igraph">sample_igraph</a>()</code>,
<code><a href="#topic+sample_sparse">sample_sparse</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(igraph)
library(tidygraph)

set.seed(27)

##### undirected examples ----------------------------

n &lt;- 100
k &lt;- 5

X &lt;- matrix(rpois(n = n * k, 1), nrow = n)
S &lt;- matrix(runif(n = k * k, 0, .1), nrow = k)

# S will be symmetrized internal here, or left unchanged if
# it is already symmetric

ufm &lt;- undirected_factor_model(
  X, S,
  expected_density = 0.1
)

ufm

### sampling graphs as edgelists ----------------------

edgelist &lt;- sample_edgelist(ufm)
edgelist

### sampling graphs as sparse matrices ----------------

A &lt;- sample_sparse(ufm)

inherits(A, "dsCMatrix")
isSymmetric(A)
dim(A)

B &lt;- sample_sparse(ufm)

inherits(B, "dsCMatrix")
isSymmetric(B)
dim(B)

### sampling graphs as igraph graphs ------------------

sample_igraph(ufm)

### sampling graphs as tidygraph graphs ---------------

sample_tidygraph(ufm)

##### directed examples ----------------------------

n2 &lt;- 100

k1 &lt;- 5
k2 &lt;- 3

d &lt;- 50

X &lt;- matrix(rpois(n = n2 * k1, 1), nrow = n2)
S &lt;- matrix(runif(n = k1 * k2, 0, .1), nrow = k1, ncol = k2)
Y &lt;- matrix(rexp(n = k2 * d, 1), nrow = d)

fm &lt;- directed_factor_model(X, S, Y, expected_in_degree = 2)
fm

### sampling graphs as edgelists ----------------------

edgelist2 &lt;- sample_edgelist(fm)
edgelist2

### sampling graphs as sparse matrices ----------------

A2 &lt;- sample_sparse(fm)

inherits(A2, "dgCMatrix")
isSymmetric(A2)
dim(A2)

B2 &lt;- sample_sparse(fm)

inherits(B2, "dgCMatrix")
isSymmetric(B2)
dim(B2)

### sampling graphs as igraph graphs ------------------

# since the number of rows and the number of columns
# in `fm` differ, we will get a bipartite igraph here

# creating the bipartite igraph is slow relative to other
# sampling -- if this is a blocker for
# you please open an issue and we can investigate speedups

dig &lt;- sample_igraph(fm)
is_bipartite(dig)

### sampling graphs as tidygraph graphs ---------------

sample_tidygraph(fm)

</code></pre>

<hr>
<h2 id='sbm'>Create an undirected stochastic blockmodel object</h2><span id='topic+sbm'></span>

<h3>Description</h3>

<p>To specify a stochastic blockmodel, you must specify
the number of nodes (via <code>n</code>), the mixing matrix (via <code>k</code> or <code>B</code>),
and the relative block probabilites (optional, via <code>pi</code>).
We provide defaults for most of these options to enable
rapid exploration, or you can invest the effort
for more control over the model parameters. We <strong>strongly recommend</strong>
setting the <code>expected_degree</code> or <code>expected_density</code> argument
to avoid large memory allocations associated with
sampling large, dense graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbm(
  n,
  k = NULL,
  B = NULL,
  ...,
  pi = rep(1/k, k),
  sort_nodes = TRUE,
  poisson_edges = TRUE,
  allow_self_loops = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sbm_+3A_n">n</code></td>
<td>
<p>The number of nodes in the network. Must be
a positive integer. This argument is required.</p>
</td></tr>
<tr><td><code id="sbm_+3A_k">k</code></td>
<td>
<p>(mixing matrix) The number of blocks in the blockmodel.
Use when you don't want to specify the mixing-matrix by hand.
When <code>k</code> is specified, the elements of <code>B</code> are drawn
randomly from a <code>Uniform(0, 1)</code> distribution.
This is subject to change, and may not be reproducible.
<code>k</code> defaults to <code>NULL</code>. You must specify either <code>k</code>
or <code>B</code>, but not both.</p>
</td></tr>
<tr><td><code id="sbm_+3A_b">B</code></td>
<td>
<p>(mixing matrix) A <code>k</code> by <code>k</code> matrix of block connection
probabilities. The probability that a node in block <code>i</code> connects
to a node in community <code>j</code> is <code>Poisson(B[i, j])</code>. Must be
a square matrix. <code>matrix</code> and <code>Matrix</code> objects are both
acceptable. If <code>B</code> is not symmetric, it will be
symmetrized via the update <code>B := B + t(B)</code>. Defaults to <code>NULL</code>.
You must specify either <code>k</code> or <code>B</code>, but not both.</p>
</td></tr>
<tr><td><code id="sbm_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+undirected_factor_model">undirected_factor_model</a></code>
</p>

<dl>
<dt><code>expected_degree</code></dt><dd><p>If specified, the desired expected degree
of the graph. Specifying <code>expected_degree</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Do not specify both
<code>expected_degree</code> and <code>expected_density</code> at the same time.</p>
</dd>
<dt><code>expected_density</code></dt><dd><p>If specified, the desired expected density
of the graph. Specifying <code>expected_density</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Do not specify both
<code>expected_degree</code> and <code>expected_density</code> at the same time.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="sbm_+3A_pi">pi</code></td>
<td>
<p>(relative block probabilities) Relative block
probabilities. Must be positive, but do not need to sum
to one, as they will be normalized internally.
Must match the dimensions of <code>B</code> or <code>k</code>. Defaults to
<code>rep(1 / k, k)</code>, or a balanced blocks.</p>
</td></tr>
<tr><td><code id="sbm_+3A_sort_nodes">sort_nodes</code></td>
<td>
<p>Logical indicating whether or not to sort the nodes
so that they are grouped by block and by <code>theta</code>. Useful for plotting.
Defaults to <code>TRUE</code>. When <code>TRUE</code>, nodes are first sorted by block
membership, and then by degree-correction parameters within each block.
Additionally, <code>pi</code> is sorted in increasing order, and the columns
of the <code>B</code> matrix are permuted to match the new order of <code>pi</code>.</p>
</td></tr>
<tr><td><code id="sbm_+3A_poisson_edges">poisson_edges</code></td>
<td>
<p>Logical indicating whether or not
multiple edges are allowed to form between a pair of
nodes. Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds
as usual, and duplicate edges are removed afterwards. Further,
when <code>FALSE</code>, we assume that <code>S</code> specifies a desired between-factor
connection probability, and back-transform this <code>S</code> to the
appropriate Poisson intensity parameter to approximate Bernoulli
factor connection probabilities. See Section 2.3 of Rohe et al. (2017)
for some additional details.</p>
</td></tr>
<tr><td><code id="sbm_+3A_allow_self_loops">allow_self_loops</code></td>
<td>
<p>Logical indicating whether or not
nodes should be allowed to form edges with themselves.
Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds allowing
self-loops, and these are then removed after the fact.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A stochastic block is equivalent to a degree-corrected
stochastic blockmodel where the degree heterogeneity parameters
have all been set equal to 1.
</p>


<h3>Value</h3>

<p>An <code>undirected_sbm</code> S3 object, which is a subclass of the
<code><a href="#topic+dcsbm">dcsbm()</a></code> object.
</p>


<h3>See Also</h3>

<p>Other stochastic block models: 
<code><a href="#topic+dcsbm">dcsbm</a>()</code>,
<code><a href="#topic+directed_dcsbm">directed_dcsbm</a>()</code>,
<code><a href="#topic+mmsbm">mmsbm</a>()</code>,
<code><a href="#topic+overlapping_sbm">overlapping_sbm</a>()</code>,
<code><a href="#topic+planted_partition">planted_partition</a>()</code>
</p>
<p>Other undirected graphs: 
<code><a href="#topic+chung_lu">chung_lu</a>()</code>,
<code><a href="#topic+dcsbm">dcsbm</a>()</code>,
<code><a href="#topic+erdos_renyi">erdos_renyi</a>()</code>,
<code><a href="#topic+mmsbm">mmsbm</a>()</code>,
<code><a href="#topic+overlapping_sbm">overlapping_sbm</a>()</code>,
<code><a href="#topic+planted_partition">planted_partition</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

lazy_sbm &lt;- sbm(n = 1000, k = 5, expected_density = 0.01)
lazy_sbm

# by default we get a multigraph (i.e. multiple edges are
# allowed between the same two nodes). using bernoulli edges
# will with an adjacency matrix with only zeroes and ones

bernoulli_sbm &lt;- sbm(
  n = 5000,
  k = 300,
  poisson_edges = FALSE,
  expected_degree = 8
)

bernoulli_sbm

edgelist &lt;- sample_edgelist(bernoulli_sbm)
edgelist

A &lt;- sample_sparse(bernoulli_sbm)

# only zeroes and ones!
sign(A)

</code></pre>

<hr>
<h2 id='svds.directed_factor_model'>Compute the singular value decomposition of the expected adjacency matrix of a directed factor model</h2><span id='topic+svds.directed_factor_model'></span>

<h3>Description</h3>

<p>Compute the singular value decomposition of the expected adjacency matrix of a directed factor model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'directed_factor_model'
svds(A, k = min(A$k1, A$k2), nu = k, nv = k, opts = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svds.directed_factor_model_+3A_a">A</code></td>
<td>
<p>An <code><a href="#topic+undirected_factor_model">undirected_factor_model()</a></code>.</p>
</td></tr>
<tr><td><code id="svds.directed_factor_model_+3A_k">k</code></td>
<td>
<p>Desired rank of decomposition.</p>
</td></tr>
<tr><td><code id="svds.directed_factor_model_+3A_nu">nu</code></td>
<td>
<p>Number of left singular vectors to be computed. This must
be between 0 and <code>k</code>.</p>
</td></tr>
<tr><td><code id="svds.directed_factor_model_+3A_nv">nv</code></td>
<td>
<p>Number of right singular vectors to be computed. This must
be between 0 and <code>k</code>.</p>
</td></tr>
<tr><td><code id="svds.directed_factor_model_+3A_opts">opts</code></td>
<td>
<p>Control parameters related to the computing
algorithm. See <strong>Details</strong> below.</p>
</td></tr>
<tr><td><code id="svds.directed_factor_model_+3A_...">...</code></td>
<td>
<p>Unused, included only for consistency with generic signature.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>opts</code> argument is a list that can supply any of the
following parameters:
</p>

<dl>
<dt><code>ncv</code></dt><dd><p>Number of Lanzcos basis vectors to use. More vectors
will result in faster convergence, but with greater
memory use. <code>ncv</code> must be satisfy
<code class="reqn">k &lt; ncv \le p</code> where
<code>p = min(m, n)</code>.
Default is <code>min(p, max(2*k+1, 20))</code>.</p>
</dd>
<dt><code>tol</code></dt><dd><p>Precision parameter. Default is 1e-10.</p>
</dd>
<dt><code>maxitr</code></dt><dd><p>Maximum number of iterations. Default is 1000.</p>
</dd>
<dt><code>center</code></dt><dd><p>Either a logical value (<code>TRUE</code>/<code>FALSE</code>), or a numeric
vector of length <code class="reqn">n</code>. If a vector <code class="reqn">c</code> is supplied, then
SVD is computed on the matrix <code class="reqn">A - 1c'</code>,
in an implicit way without actually forming this matrix.
<code>center = TRUE</code> has the same effect as
<code>center = colMeans(A)</code>. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>scale</code></dt><dd><p>Either a logical value (<code>TRUE</code>/<code>FALSE</code>), or a numeric
vector of length <code class="reqn">n</code>. If a vector <code class="reqn">s</code> is supplied, then
SVD is computed on the matrix <code class="reqn">(A - 1c')S</code>,
where <code class="reqn">c</code> is the centering vector and <code class="reqn">S = diag(1/s)</code>.
If <code>scale = TRUE</code>, then the vector <code class="reqn">s</code> is computed as
the column norm of <code class="reqn">A - 1c'</code>.
Default is <code>FALSE</code>.</p>
</dd>
</dl>


<hr>
<h2 id='svds.undirected_factor_model'>Compute the singular value decomposition of the expected adjacency matrix of an undirected factor model</h2><span id='topic+svds.undirected_factor_model'></span>

<h3>Description</h3>

<p>Compute the singular value decomposition of the expected adjacency matrix of an undirected factor model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'undirected_factor_model'
svds(A, k = A$k, nu = k, nv = k, opts = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svds.undirected_factor_model_+3A_a">A</code></td>
<td>
<p>An <code><a href="#topic+undirected_factor_model">undirected_factor_model()</a></code>.</p>
</td></tr>
<tr><td><code id="svds.undirected_factor_model_+3A_k">k</code></td>
<td>
<p>Desired rank of decomposition.</p>
</td></tr>
<tr><td><code id="svds.undirected_factor_model_+3A_nu">nu</code></td>
<td>
<p>Number of left singular vectors to be computed. This must
be between 0 and <code>k</code>.</p>
</td></tr>
<tr><td><code id="svds.undirected_factor_model_+3A_nv">nv</code></td>
<td>
<p>Number of right singular vectors to be computed. This must
be between 0 and <code>k</code>.</p>
</td></tr>
<tr><td><code id="svds.undirected_factor_model_+3A_opts">opts</code></td>
<td>
<p>Control parameters related to the computing
algorithm. See <strong>Details</strong> below.</p>
</td></tr>
<tr><td><code id="svds.undirected_factor_model_+3A_...">...</code></td>
<td>
<p>Unused, included only for consistency with generic signature.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>opts</code> argument is a list that can supply any of the
following parameters:
</p>

<dl>
<dt><code>ncv</code></dt><dd><p>Number of Lanzcos basis vectors to use. More vectors
will result in faster convergence, but with greater
memory use. <code>ncv</code> must be satisfy
<code class="reqn">k &lt; ncv \le p</code> where
<code>p = min(m, n)</code>.
Default is <code>min(p, max(2*k+1, 20))</code>.</p>
</dd>
<dt><code>tol</code></dt><dd><p>Precision parameter. Default is 1e-10.</p>
</dd>
<dt><code>maxitr</code></dt><dd><p>Maximum number of iterations. Default is 1000.</p>
</dd>
<dt><code>center</code></dt><dd><p>Either a logical value (<code>TRUE</code>/<code>FALSE</code>), or a numeric
vector of length <code class="reqn">n</code>. If a vector <code class="reqn">c</code> is supplied, then
SVD is computed on the matrix <code class="reqn">A - 1c'</code>,
in an implicit way without actually forming this matrix.
<code>center = TRUE</code> has the same effect as
<code>center = colMeans(A)</code>. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>scale</code></dt><dd><p>Either a logical value (<code>TRUE</code>/<code>FALSE</code>), or a numeric
vector of length <code class="reqn">n</code>. If a vector <code class="reqn">s</code> is supplied, then
SVD is computed on the matrix <code class="reqn">(A - 1c')S</code>,
where <code class="reqn">c</code> is the centering vector and <code class="reqn">S = diag(1/s)</code>.
If <code>scale = TRUE</code>, then the vector <code class="reqn">s</code> is computed as
the column norm of <code class="reqn">A - 1c'</code>.
Default is <code>FALSE</code>.</p>
</dd>
</dl>


<hr>
<h2 id='undirected_factor_model'>Create an undirected factor model graph</h2><span id='topic+undirected_factor_model'></span>

<h3>Description</h3>

<p>An undirected factor model graph is an undirected
generalized Poisson random dot product graph. The edges
in this graph are assumed to be independent and Poisson
distributed. The graph is parameterized by its expected
adjacency matrix, which is <code style="white-space: pre;">&#8288;E[A|X] = X S X'&#8288;</code>. We do not recommend
that casual users use this function, see instead <code><a href="#topic+dcsbm">dcsbm()</a></code>
and related functions, which will formulate common variants
of the stochastic blockmodels as undirected factor models
<em>with lots of helpful input validation</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>undirected_factor_model(
  X,
  S,
  ...,
  expected_degree = NULL,
  expected_density = NULL,
  poisson_edges = TRUE,
  allow_self_loops = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="undirected_factor_model_+3A_x">X</code></td>
<td>
<p>A <code><a href="base.html#topic+matrix">matrix()</a></code> or <a href="base.html#topic+matrix">Matrix()</a> representing real-valued
latent node positions. Entries must be positive.</p>
</td></tr>
<tr><td><code id="undirected_factor_model_+3A_s">S</code></td>
<td>
<p>A <code><a href="base.html#topic+matrix">matrix()</a></code> or <a href="base.html#topic+matrix">Matrix()</a> mixing matrix. <code>S</code> is
symmetrized if it is not already, as this is the undirected
case. Entries must be positive.</p>
</td></tr>
<tr><td><code id="undirected_factor_model_+3A_...">...</code></td>
<td>
<p>Ignored. Must be empty.</p>
</td></tr>
<tr><td><code id="undirected_factor_model_+3A_expected_degree">expected_degree</code></td>
<td>
<p>If specified, the desired expected degree
of the graph. Specifying <code>expected_degree</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Do not specify both
<code>expected_degree</code> and <code>expected_density</code> at the same time.</p>
</td></tr>
<tr><td><code id="undirected_factor_model_+3A_expected_density">expected_density</code></td>
<td>
<p>If specified, the desired expected density
of the graph. Specifying <code>expected_density</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Do not specify both
<code>expected_degree</code> and <code>expected_density</code> at the same time.</p>
</td></tr>
<tr><td><code id="undirected_factor_model_+3A_poisson_edges">poisson_edges</code></td>
<td>
<p>Logical indicating whether or not
multiple edges are allowed to form between a pair of
nodes. Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds
as usual, and duplicate edges are removed afterwards. Further,
when <code>FALSE</code>, we assume that <code>S</code> specifies a desired between-factor
connection probability, and back-transform this <code>S</code> to the
appropriate Poisson intensity parameter to approximate Bernoulli
factor connection probabilities. See Section 2.3 of Rohe et al. (2017)
for some additional details.</p>
</td></tr>
<tr><td><code id="undirected_factor_model_+3A_allow_self_loops">allow_self_loops</code></td>
<td>
<p>Logical indicating whether or not
nodes should be allowed to form edges with themselves.
Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds allowing
self-loops, and these are then removed after the fact.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>undirected_factor_model</code> S3 class based on a list
with the following elements:
</p>

<ul>
<li> <p><code>X</code>: The latent positions as a <code><a href="Matrix.html#topic+Matrix">Matrix()</a></code> object.
</p>
</li>
<li> <p><code>S</code>: The mixing matrix as a <code><a href="Matrix.html#topic+Matrix">Matrix()</a></code> object.
</p>
</li>
<li> <p><code>n</code>: The number of nodes in the network.
</p>
</li>
<li> <p><code>k</code>: The rank of expectation matrix. Equivalently,
the dimension of the latent node position vectors.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 10000
k &lt;- 5

X &lt;- matrix(rpois(n = n * k, 1), nrow = n)
S &lt;- matrix(runif(n = k * k, 0, .1), nrow = k)

ufm &lt;- undirected_factor_model(X, S)
ufm

ufm2 &lt;- undirected_factor_model(X, S, expected_degree = 50)
ufm2

svds(ufm2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
