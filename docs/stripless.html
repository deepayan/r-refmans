<!DOCTYPE html><html><head><title>Help for package stripless</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stripless}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#stripless-package'><p>Trellis Displays Without Strips For Lattice Graphics</p></a></li>
<li><a href='#defaultStrucLegend'><p>Default legend function for <code>strucplot</code> displays.</p></a></li>
<li><a href='#displayStruc'><p>Construct text For <code>strucplot</code> legends.</p></a></li>
<li><a href='#panel.bars'><p>strucplot Panel Functions</p></a></li>
<li><a href='#print.structured'><p>Methods for structured objects.</p></a></li>
<li><a href='#stripless-internal'><p>Unexported Utility and xyLayout Functions</p></a></li>
<li><a href='#strucParseFormula'><p>Parse Trellis Formula for <code>strucplot</code></p></a></li>
<li><a href='#strucplot'><p>Structured Trellis Plots</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Structured Trellis Displays Without Strips for Lattice Graphics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-09-09</td>
</tr>
<tr>
<td>Description:</td>
<td>For making Trellis-type conditioning plots without strip labels.
    This is useful for displaying the structure of results from factorial designs
    and other studies when many conditioning variables would clutter the display
    with layers of redundant strip labels. Settings of the variables are encoded by
    layout and spacing in the trellis array and decoded by a separate legend. The
    functionality is implemented by a single S3 generic strucplot() function that
    is a wrapper for the Lattice package's xyplot() function. This allows access to
    all Lattice graphics capabilities in the usual way.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0), utils,lattice</td>
</tr>
<tr>
<td>Suggests:</td>
<td>datasets,grDevices,knitr,faraway,rmarkdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats,graphics,grid</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-09-11 17:26:42 UTC; bgunter</td>
</tr>
<tr>
<td>Author:</td>
<td>Bert Gunter [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bert Gunter &lt;bgunter@comcast.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-09-12 08:11:45</td>
</tr>
</table>
<hr>
<h2 id='stripless-package'>Trellis Displays Without Strips For Lattice Graphics</h2><span id='topic+stripless'></span><span id='topic+stripless-package'></span>

<h3>Description</h3>

<p>Stripless provides a simple interface to make trellis plots without strip
labels using lattice graphics. Instead of having strip labels identify each
panel's settings of the conditioning variables, their position in a structured
row/column layout encodes this information, and a legend decodes them. This
avoids cluttering the plot area with redundant layers of strip labels when
there are many conditioning variables, as is often the case for factorial
designs, especially the (fractions of) two level factorials widely used in
industry.
</p>


<h3>Details</h3>

<p>The package consists of a generic <code>strucplot</code> function and methods, an
associated <code>print</code> method for objects inheriting from class
<code>"structured"</code>, and some (currently 1) additional trellis
panel functions. This functionality is implemented as a wrapper
to lattice's <code>xyplot</code> function, so all other plot specifications
(panel functions, colors, titles, etc.) are given through the usual
<code><a href="lattice.html#topic+xyplot">xyplot</a></code> arguments.
</p>
<p>See <code><a href="#topic+strucplot">strucplot</a></code> for a full explanation of the structured plotting
paradigm, how <code>strucplot</code> implements it, and examples illustrating how
it works.
</p>


<h3>Note</h3>

<p>The author has made a considerable effort to provide clear, complete
documentation of the package's functionality. He would therefore appreciate
receiving any reports of errors, inconsistencies, or infelicities in the Help
docs, as well as suggestions for improvement in the docs or underlying
package functionality.
</p>

<hr>
<h2 id='defaultStrucLegend'>Default legend function for <code>strucplot</code> displays.</h2><span id='topic+defaultStrucLegend'></span>

<h3>Description</h3>

<p>A structure legend is always printed on the console. It can also be
optionally added to the trellis plot. This function constructs a default
legend for this option.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defaultStrucLegend(struc, legendLoc = c("top", "right", "bottom", "left",
  "newpage"), legendLab = NA, heading = c("Horizontal", "Vertical"),
  miss = "No Conditioning", abbrevLength = c(0, 0), cex.font = 1,
  cex.lab = 1.25, col = "black", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defaultStrucLegend_+3A_struc">struc</code></td>
<td>
<p>The &quot;structure&quot; attribute of a <code>strucplot</code> object</p>
</td></tr>
<tr><td><code id="defaultStrucLegend_+3A_legendloc">legendLoc</code></td>
<td>
<p>One of c(&quot;top&quot;,&quot;right&quot;,&quot;bottom&quot;,&quot;left&quot;,&quot;newpage&quot;) The first 4 specify
on which side of the trellis display to place the legend. The last indicates that the
legend will be plotted at the center of a separate page.</p>
</td></tr>
<tr><td><code id="defaultStrucLegend_+3A_legendlab">legendLab</code></td>
<td>
<p>A character string title for the legend. A value of
<code>NA</code> omits the title. Default = <code>NA</code></p>
</td></tr>
<tr><td><code id="defaultStrucLegend_+3A_heading">heading</code></td>
<td>
<p>A character vector of length 2 giving the headings for the horizontal
and vertical conditioning variables portions of the legend. Default =
<code>c("Horizontal", "Vertical")</code>.</p>
</td></tr>
<tr><td><code id="defaultStrucLegend_+3A_miss">miss</code></td>
<td>
<p>A character string to use when there is no conditioning either horizontally
or vertically. Default = <code>"No Conditioning"</code></p>
</td></tr>
<tr><td><code id="defaultStrucLegend_+3A_abbrevlength">abbrevLength</code></td>
<td>
<p>Default = <code>c(0,0)</code>. Either a length 2 vector or a named list
to control lengths of factor names and levels in the legend. If a length 2 vector, it
gives the <code>minlength</code> argument for the abbreviate function for abbreviating all
the factor names and their levels, in that order. A value of 0 for either means
&quot;don't abbreviate.&quot; For back compatibility, a single numeric y will also be accepted
and changed to <code>c(y,0)</code>. If a named list, the names must be those of of the
conditioning factors to abbreviate, and values length 2 vectors as above to
control abbreviation lengths for the corresponding factor names and levels.</p>
</td></tr>
<tr><td><code id="defaultStrucLegend_+3A_cex.font">cex.font</code></td>
<td>
<p>Multiplier for text font size in a trellis legend. Default = 1.</p>
</td></tr>
<tr><td><code id="defaultStrucLegend_+3A_cex.lab">cex.lab</code></td>
<td>
<p>Multiplier for legend title font size in a trellis legend.
Default = 1.25.</p>
</td></tr>
<tr><td><code id="defaultStrucLegend_+3A_col">col</code></td>
<td>
<p>Text color for text in a trellis legend. Default = <code>"black"</code>.</p>
</td></tr>
<tr><td><code id="defaultStrucLegend_+3A_...">...</code></td>
<td>
<p>Additional arguments to be used in a <code>gp</code> list for controlling text
appearance in a trellis legend. See <code><a href="grid.html#topic+gpar">gpar</a></code> for possibilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A text grob that can be included as part of the <code>strucplot</code> trellis plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.structured">print.structured</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Controlling the console and plot legends
 library(datasets) ## for the barley data
#
 out &lt;- strucplot(variety~yield|year*site,data=barley, horizontal=TRUE,
   panel=panel.dotplot, col = "darkblue",
   scales = list(alternat = 1, y = list(cex=.5)),
   spacings = list(x=0, y=.5))
#
# Default with legend on top; note that no title is the plot legend default
  print(out, legendLoc = "t", abbrev= list(site = c(0,4)))
#
# Include title on plot and reduce default font sizes in red text
  print(out, legendLoc = "T", abbrev = list(site = c(0,6)),
   legendLab = "Structure", cex.lab = 1, cex.font = .75, col = "darkred" )

</code></pre>

<hr>
<h2 id='displayStruc'>Construct text For <code>strucplot</code> legends.</h2><span id='topic+displayStruc'></span>

<h3>Description</h3>

<p>Construct character strings for print and legend functions to display on
the console or lattice plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>displayStruc(struc, heading = c("Horizontal", "Vertical"),
  miss = "No Conditioning", abbrevLength = c(0, 0), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="displayStruc_+3A_struc">struc</code></td>
<td>
<p>The &quot;structure&quot; attribute of a <code>strucplot</code> object</p>
</td></tr>
<tr><td><code id="displayStruc_+3A_heading">heading</code></td>
<td>
<p>A character vector of length 2 giving the headings for the horizontal
and vertical conditioning variables portions of the legend. Default =
<code>c("Horizontal", "Vertical")</code>.</p>
</td></tr>
<tr><td><code id="displayStruc_+3A_miss">miss</code></td>
<td>
<p>A character string to use when there is no conditioning either horizontally
or vertically. Default = <code>"No Conditioning"</code></p>
</td></tr>
<tr><td><code id="displayStruc_+3A_abbrevlength">abbrevLength</code></td>
<td>
<p>Default = <code>c(0,0)</code>. Either a length 2 vector or a named list
to control lengths of factor names and levels in the legend. If a length 2 vector, it
gives the <code>minlength</code> argument for the abbreviate function for abbreviating all
the factor names and their levels, in that order. A value of 0 for either means
&quot;don't abbreviate.&quot; For back compatibility, a single numeric y will also be accepted
and changed to <code>c(y,0)</code>. If a named list, the names must be those of of the
conditioning factors to abbreviate, and values length 2 vectors as above to
control abbreviation lengths for the corresponding factor names and levels.</p>
</td></tr>
<tr><td><code id="displayStruc_+3A_...">...</code></td>
<td>
<p>Additional arguments, presently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an exported auxiliary function that constructs the character strings
for displaying plot structure on the console and possibly also in a legend on the
lattice display. While not intended to be directly called by the user, it is exported
for use by those who wish to supply custom legends for the lattice display.
</p>


<h3>Value</h3>

<p>A character vector of length 2 giving character strings,
including <code>\n</code> line breaks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(datasets)
# quakes data
#
# Create and save plot
 out &lt;- strucplot(lat ~ long|cut(mag,5)*cut(depth,4), data = quakes,
  col="blue", main = "Earthquake locations, by magnitude and depth")

 displayStruc(attr(out,"structure"))
</code></pre>

<hr>
<h2 id='panel.bars'>strucplot Panel Functions</h2><span id='topic+panel.bars'></span>

<h3>Description</h3>

<p>Panel functions for strucplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.bars(..., summaryFUN = function(x) mean(x, na.rm = TRUE),
  col = "darkblue", grid = TRUE, col.grid = "lightgray")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.bars_+3A_...">...</code></td>
<td>
<p>Arguments to barchart. See <code><a href="lattice.html#topic+panel.barchart">panel.barchart</a></code>.</p>
</td></tr>
<tr><td><code id="panel.bars_+3A_summaryfun">summaryFUN</code></td>
<td>
<p>The function that summarizes replicated response values.
Default = fuction(x) mean(x, na.rm = TRUE).</p>
</td></tr>
<tr><td><code id="panel.bars_+3A_col">col</code></td>
<td>
<p>Color of the bars. Default = &quot;darkblue&quot;.</p>
</td></tr>
<tr><td><code id="panel.bars_+3A_grid">grid</code></td>
<td>
<p>Should an appropriate background grid be plotted? Default = TRUE.</p>
</td></tr>
<tr><td><code id="panel.bars_+3A_col.grid">col.grid</code></td>
<td>
<p>The background grid color. Default = &quot;lightgray&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>panel.bars A wrapper for <code><a href="lattice.html#topic+panel.barchart">panel.barchart</a></code> that 
plots bars that summarize the responses at each setting of the 
conditioning variables. By default, bars are vertical, but setting the
optional parameter, <code>horizontal</code> to <code>TRUE</code> plots horizontal bars.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A half fraction of a 2^5 full factorial with pseudo-replicate responses
# at each design point,

# Build the design matrix
x &lt;- c(-1,1)
ff &lt;- expand.grid(x,x,x,x)
ff[[5]] &lt;- do.call(mapply,c(FUN=prod,ff))
ff &lt;- ff[rep(1:16,e=2),] ## replicates each row twice
names(ff) &lt;- LETTERS[1:5]

# Add a column for the response
ff$y &lt;-c(155.5, 154.8, 158.4, 156.2, 154.8, 152.4, 159.7, 155.5, 161.8, 
159.7, 159, 158.4, 159.7, 157.7, 161.8, 158, 155.9, 151.7, 159, 
158, 154.1, 156.9, 158.4, 158.4, 159, 154.8, 158.4, 156.2, 161.1, 
156.9, 162.6, 159)

# Plot using panel.bars
strucplot(~ y|., data = ff, panel = panel.bars)

# It is often useful to plot the bars the other way, too
strucplot(~ y|., data = ff, panel = panel.bars, horizontal = TRUE)

</code></pre>

<hr>
<h2 id='print.structured'>Methods for structured objects.</h2><span id='topic+plot.structured'></span><span id='topic+print.structured'></span><span id='topic+print.summary.structured'></span><span id='topic+summary.structured'></span>

<h3>Description</h3>

<p>Print/plot and summary methods for class <code>"structured"</code> objects.
</p>
<p>plot and print methods are the same for <code>"structured"</code> objects
</p>
<p>Summary method for <code>"structured"</code> objects.
</p>
<p>Print method for <code>"summary.structured"</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'structured'
print(x, legendLoc = c("left", "right", "top", "bottom",
  "newpage"), legend = defaultStrucLegend, lbl = "PLOT STRUCTURE",
  abbrevLength = c(0, 0), ...)

## S3 method for class 'structured'
plot(x, legendLoc = c("left", "right", "top", "bottom",
  "newpage"), legend = defaultStrucLegend, lbl = "PLOT STRUCTURE",
  abbrevLength = c(0, 0), ...)

## S3 method for class 'structured'
summary(object, ...)

## S3 method for class 'summary.structured'
print(x, lbl = "PLOT STRUCTURE", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.structured_+3A_x">x</code>, <code id="print.structured_+3A_object">object</code></td>
<td>
<p>The object to be displayed or summarized.</p>
</td></tr>
<tr><td><code id="print.structured_+3A_legendloc">legendLoc</code></td>
<td>
<p>An optional location of a legend describing the plot layout to be used
as a legend on the trellis plot. Note that a text legend is <em>always</em> printed on
the console. If used, this argument specified the position of a legend in the trellis
display. It must be one of <code>"left"</code>, <code>"right"</code>, <code>"top"</code>,
<code>"bottom"</code>, or <code>"newpage"</code> (case doesn't matter and
matching is done using <code><a href="base.html#topic+match.arg">match.arg</a></code>,
so <code>legendLoc</code> can be abbreviated). Any of the first four of these will become
the name of a component of the <code>legend</code> argument of the
<code><a href="lattice.html#topic+xyplot">xyplot</a></code> call, and so must not conflict with any in a
<code>legend</code> argument that may already be part of the <code><a href="#topic+strucplot">strucplot</a></code> call.
</p>
<p>If <code>legendLoc = "newpage"</code>, the legend will be plotted centered on a new trellis
page.</p>
</td></tr>
<tr><td><code id="print.structured_+3A_legend">legend</code></td>
<td>
<p>A <em>function</em> that constructs a grob to use as a plot legend. It must
accept at least 3 arguments named <code>"struc"</code>, <code>"legendLoc"</code>, and
<code>"abbrevLength"</code>, and also have a ... argument. The first three will be passed
the <code>structure</code> attribute of the object to be plotted and the <code>legendLoc</code>
and <code>abbrevLength</code> arguments of the <code>print</code> call. The ... argument will
be passed the ... argument of the <code>print</code> call, so additional function
arguments should be included there (as name = value pairs, as usual).
</p>
<p>The default is the <code><a href="#topic+defaultStrucLegend">defaultStrucLegend</a></code> function. Its Help file should be
consulted for its full argument list.</p>
</td></tr>
<tr><td><code id="print.structured_+3A_lbl">lbl</code></td>
<td>
<p>Label for console legend. Default = &quot;PLOT STRUCTURE&quot;</p>
</td></tr>
<tr><td><code id="print.structured_+3A_abbrevlength">abbrevLength</code></td>
<td>
<p>Default = <code>c(0,0)</code>. Either a length 2 vector or a named list
to control lengths of factor names and levels in the legend. If a length 2 vector, it
gives the <code>minlength</code> argument for the abbreviate function for abbreviating all
the factor names and their levels, in that order. A value of 0 for either means
&quot;don't abbreviate.&quot; For back compatibility, a single numeric y will also be accepted
and changed to <code>c(y,0)</code>. If a named list, the names must be those of of the
conditioning factors to abbreviate, and values length 2 vectors as above to
control abbreviation lengths for the corresponding factor names and levels.</p>
</td></tr>
<tr><td><code id="print.structured_+3A_...">...</code></td>
<td>
<p>Further arguments to pass down to either the <code>print</code> methods, the
<code>legend</code> function, or <code><a href="lattice.html#topic+print.trellis">print.trellis</a></code>. Care should be taken
to ensure that the names of arguments do not conflict. Note that <code>heading</code> and
<code>miss</code> arguments of <code>defaultStrucLegend</code> are also used by the console
display.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>print</code> and <code>plot</code> methods produce a plot and informative legend
for <code>"structured"</code> objects. The <code>plot</code> method is an alias for the print
method. The <code>summary</code> method gives a simple summary of the object with a
<code>print</code>
</p>


<h3>Note</h3>

<p>Do not use the <code>packet.panel</code> argument of <code>print.trellis</code>, as this will
totally mess up the display.
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+print.trellis">print.trellis</a>, <a href="#topic+defaultStrucLegend">defaultStrucLegend</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(datasets)
# quakes data
#
# Create and save plot
out &lt;- strucplot(lat ~ long|cut(mag,5)*cut(depth,4), data = quakes,
  col="blue", main = "Earthquake locations, by magnitude and depth")

# Summary:
summary(out)

# Default output -- structure legend on console only
   print(out)

# Add legends to the plot on either right or bottom (note partial matching)
   print(out, legendLoc = "right")
   print(out, legendLoc = "b")
#
# Plot the legend by itself on a separate page
   print(out, legendLoc = "newp")
#
# Extra grid "gp" arguments to alter text appearance
   print(out, legendLoc = "b",col="blue",fontface = "italic", abbrev = 5)
#
# ******* Using the "abbrev" argument with the 'barley' data set ****
#
  out &lt;- strucplot(variety~yield|year*site,data=barley, horizontal=TRUE,
  panel=panel.dotplot, col = "darkblue", scales = list(alternat = 1,
  y = list(cex=.5)), spacings = list(x=0, y=.5))

# Default
  print(out)
#
# Abbreviate factor names and levels
  print(out, abbrev = c(3,4))
#
# abbreviate just the levels of 'site' and change the console legend title
  print(out, abbrev = list(site = c(0,4)), lbl = "Structure Key")
#
# Note that the 'abbreviate' argument is shared by console and plot
# legends; as are the optional 'heading' and 'miss' arguments
# by the 'defaultStrucLegend' function.
  print(out,abbrev = list(site = c(0,4)),legendLoc="t",
   heading = c("Left-Right", "Up-Down"))
</code></pre>

<hr>
<h2 id='stripless-internal'>Unexported Utility and xyLayout Functions</h2><span id='topic+check2lvl'></span><span id='topic+chkSpacings'></span><span id='topic+makeSpacings'></span><span id='topic+make_2level_with_center'></span><span id='topic+stripless-internal'></span><span id='topic+xyLayout'></span><span id='topic+xyLayout.data.frame'></span><span id='topic+xyLayout.default'></span><span id='topic+xyLayout.list'></span><span id='topic+xyLayout.matrix'></span>

<h3>Description</h3>

<p>Unexported functions not intended to be directly called by users.
</p>
<p>For <code>xyLayout</code>: Unexported generic and methods used by <code>strucplot</code> to
create, check and/or fix a <code>xyLayout</code> list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check2lvl(d, sep = ".")

make_2level_with_center(lvls, sep = ".")

makeSpacings(spacings, levelLength)

chkSpacings(spacings)

xyLayout(xylay, ...)

## S3 method for class 'list'
xyLayout(xylay = list(),
  n = stop("Number of conditioning factors is missing"))

## S3 method for class 'matrix'
xyLayout(xylay, n)

## S3 method for class 'data.frame'
xyLayout(xylay, n)

## Default S3 method:
xyLayout(..., n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stripless-internal_+3A_d">d</code></td>
<td>
<p>Condition list from strucParseFormula to be checked to see if it
represents a 2 level design with center point.</p>
</td></tr>
<tr><td><code id="stripless-internal_+3A_sep">sep</code></td>
<td>
<p>sep argument for <code>paste()</code>.</p>
</td></tr>
<tr><td><code id="stripless-internal_+3A_lvls">lvls</code></td>
<td>
<p>A list of length 3 character vectors that are the level names of
factors in a design to be checked.</p>
</td></tr>
<tr><td><code id="stripless-internal_+3A_spacings">spacings</code></td>
<td>
<p>A non-decreasing vector of positive values</p>
</td></tr>
<tr><td><code id="stripless-internal_+3A_levellength">levelLength</code></td>
<td>
<p>An integer vector giving the number of levels per factor
at each level of the plotting hierarchy</p>
</td></tr>
<tr><td><code id="stripless-internal_+3A_xylay">xylay</code></td>
<td>
<p>An appropriate list, matrix, or vector for determining the
plot structure. Can also be missing, length 0, etc.</p>
</td></tr>
<tr><td><code id="stripless-internal_+3A_n">n</code></td>
<td>
<p>The number of conditioning factors. The integers in the combined list
that is created will be a permutation of 1, 2, ... ,n .</p>
</td></tr>
<tr><td><code id="stripless-internal_+3A_...">...</code></td>
<td>
<p>x and/or y vector for <code>xylay</code> list. The remaining component will be
constructed as needed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Brief utility function descriptions:</strong>
</p>

<dl>
<dt>check2lvl</dt><dd><p>Checks for a 2 level design with center point</p>
</dd>
<dt>make_2level_with_center</dt><dd><p>Makes a 2 level design with center point to
compare to a fraction of a <code class="reqn">3^n</code> design</p>
</dd>
<dt>chkSpacings</dt><dd><p>Checks and constructs proper spacings list if possible</p>
</dd>
<dt>makeSpacings</dt><dd><p>Constructs a vector of spacings values for the &quot;between&quot;
argument of <code><a href="lattice.html#topic+xyplot">xyplot</a></code></p>
</dd>
</dl>

<p><strong>xyLayout:</strong>
The various methods provide convenience and flexibility for specifying
the <code>xyLayout</code> list argument that controls the format of <code>strucplot</code>
displays. Essentially any sensible way of specifying <code>xyLayout</code> should
work. See the Help page for <code><a href="#topic+strucplot">strucplot</a></code> for details.
</p>


<h3>Value</h3>

<p>For <code>xyLayout</code>: a list of class &quot;xyLayout&quot; suitable for the <code>xyLayout</code> argument of <code>strucplot</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+strucplot">strucplot</a></code>
</p>

<hr>
<h2 id='strucParseFormula'>Parse Trellis Formula for <code>strucplot</code></h2><span id='topic+strucParseFormula'></span>

<h3>Description</h3>

<p>This is a wrapper for <code>latticeParseFormula</code> that allows the option of using
a &quot;.&quot; for the conditioning variables (i.e. after &quot;|&quot;) instead of explicitly
writing them out. When so used, it means &quot;all variables in the data argument
<em>except</em> those already used to the left of the |&quot;. See the Help for
<code><a href="#topic+strucplot">strucplot</a></code> for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strucParseFormula(form, data = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strucParseFormula_+3A_form">form</code></td>
<td>
<p>The <code>strucplot</code> formula to be parsed.</p>
</td></tr>
<tr><td><code id="strucParseFormula_+3A_data">data</code></td>
<td>
<p>An optional data frame containing values for any variables in
the formula. Default = list(), which means that all variables will be looked
up in the formula's environment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this is a convenience option only; the
conditioning can always be explicitly given. Also note that the two options
cannot be combined: either a &quot;.&quot; and <em>only</em> a &quot;.&quot; must be used or
<em>all</em> the conditioning variables must be written out.
</p>


<h3>Value</h3>

<p>Same as <code>latticeParseFormula</code> with an additional &quot;form&quot;
attribute that is the formula used with all conditioning explicitly
given.
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+latticeParseFormula">latticeParseFormula</a></code>
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> exdat &lt;- data.frame(x = 1:5, alongname = sample( letters[1:3],5, rep=TRUE),
   butalongername = sample(LETTERS[1:2],5, rep = TRUE))
   y &lt;- runif(5)

 strucParseFormula (y ~ x| alongname*butalongername, data = exdat)

 # The same
 strucParseFormula (y ~ x|., data = exdat)

 # The 'data' argument is required with '.'
 ## Not run: 
 strucParseFormula (y ~ x|.)
 
## End(Not run)

</code></pre>

<hr>
<h2 id='strucplot'>Structured Trellis Plots</h2><span id='topic+strucplot'></span><span id='topic+strucplot.data.frame'></span><span id='topic+strucplot.default'></span><span id='topic+strucplot.formula'></span><span id='topic+strucplot.list'></span><span id='topic+strucplot.lm'></span><span id='topic+strucplot.matrix'></span>

<h3>Description</h3>

<p>Structured Trellis Plots Without Strip Labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strucplot(obj, ...)

## S3 method for class 'formula'
strucplot(obj, data = list(), groups = NULL,
  xyLayout = list(), spacings = list(x = 0:9, y = 0:9), center = FALSE,
  ...)

## Default S3 method:
strucplot(...)

## S3 method for class 'data.frame'
strucplot(obj, col = "darkblue", groups = NULL, ...)

## S3 method for class 'list'
strucplot(obj, ...)

## S3 method for class 'matrix'
strucplot(obj, ...)

## S3 method for class 'lm'
strucplot(obj, newdata = model.frame(obj)[-1],
  ylab = "Predicted Response", predictArgs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strucplot_+3A_obj">obj</code></td>
<td>
<p>Argument determining method dispatch. For the formula method, a
<code>xyplot</code> type formula of the form <code>~y|f1*f2*...*fn</code> or
<code>y~x|f1*f2*...*fn</code> (where &quot;...&quot; means the actual variable names).
Instead of explicitly specifying the conditioning variables,
i.e. the variables after the |, you can instead use a &quot;.&quot; after |. This is
interpreted to mean &quot;all variables in the data argument <em>except</em>
those to the left of the |&quot;. For example, the second formula above could be
written as <code>y~x|.</code> where f1, f2, ..., fn and possibly x and y are the
variables in data (typically columns of a data frame).
</p>
<p>Note 1: Extended formulas and 3-d formulas (see
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>) are not implemented.
</p>
<p>Note 2: For the lm method, the model object should contain a model
component. See <code><a href="stats.html#topic+predict.lm">predict.lm</a></code> and Help pages for predict
methods for classes inheriting from &quot;lm&quot; for other arguments and for
exactly what is plotted.
</p>
<p>It is preferable that this be the the first argument of the call.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_data">data</code></td>
<td>
<p>For the formula method, a data frame (or more precisely, anything
that is a valid envir argument in eval, e.g., a list or an environment)
containing values for any variables in the formula, as well as groups and
subset if applicable. If not found in data, or if data is unspecified, the
variables are looked for in the environment of the formula.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_groups">groups</code></td>
<td>
<p>The <code>groups</code> parameter of <code><a href="lattice.html#topic+xyplot">xyplot</a></code></p>
</td></tr>
<tr><td><code id="strucplot_+3A_xylayout">xyLayout</code></td>
<td>
<p>In its most general form, a list with named &quot;x&quot; and &quot;y&quot;
components, either or both of which can be missing (or NULL). If there are
<em>n</em> conditioning factors and both x and y are given, then
the combined components (e.g. via <code>unlist</code>) must be a permutation of
the sequence 1, 2,..., n (with no duplicates).
</p>
<p>The integers in x specify the indices of the conditioning factors and their
levels in the x direction hierarchy. Correspondingly for y. For a fuller
explanation of how this controls the plot layout, see the <strong>Overview</strong>
section and the examples.
</p>
<p>For convenience, the xyLayout argument can be specified in several other
ways. The basic idea is that the full list will be <em>filled in</em>
&quot;appropriately&quot; if possible. Specifically, this means:
</p>

<ul>
<li><p> If both components are missing, NULL, or of zero length the list is
constructed by splitting the conditioning factors equally in the horizontal
and vertical directions, with horizontal gettting one more if the number of
conditioning variables is odd;
</p>
</li>
<li><p> If only one component of the list is given, the missing component gets
the remaining factors, if any, in order(note that this means if both
directions are not in order low to high, then both must be explicitly
specified in the xyLayout list);
</p>
</li>
<li><p> If component names are missing or empty(i.e. &quot;&quot;), the first one is
&quot;x&quot; and the second is &quot;y&quot;. Nonmissing component names must be &quot;x&quot; and/or &quot;y&quot;
and must be unique;
</p>
</li>
<li><p> A 1 or 2 column matrix can be used instead of a list with an even
number of conditioning variables. If the column names are &quot;x&quot; or &quot;y&quot;, they
will be used. Otherwise, the x component is first and y second;
</p>
</li>
<li><p> An unnamed vector can be given in place of a list with a single unnamed
component (which would be assumed to be the &quot;x&quot; component)
</p>
</li></ul>

<p>As a result, all the following would produce exactly the same layout for
n = 5 conditioning factors when used as the xyLayout argument:
</p>

<ul>
<li> <p><code>list(x = 1:3, y = 4:5)</code>
</p>
</li>
<li> <p><code>list (x = 1:3)</code>
</p>
</li>
<li> <p><code>list (y = 4:5)</code>
</p>
</li>
<li><p> argument missing or NULL
</p>
</li>
<li> <p><code>1:3</code>
</p>
</li>
<li> <p><code>cbind(y = 4:5)</code>
</p>
</li>
<li> <p><code>matrix(1:3,ncol=1)</code>
</p>
</li></ul>

<p>Note that arbitrary integer vectors can be used, not just
(ordered) sequences; e.g. the following are correct and equivalent when
there are 6 conditioning factors:
</p>

<ul>
<li> <p><code>list(y = c(1,5,3), x = c(2,4,6))</code>
</p>
</li>
<li> <p><code>cbind(y=c(1,5,3), x=c(2,4,6))</code>
</p>
</li>
<li> <p><code>cbind(y = c(1,5,3))</code>
</p>
</li></ul>

<p><em>But be careful</em>: <code>xyLayout = c(2,4,6)</code> is equivalent to
<code>xyLayout = list(x = c(2,4,6), y = c(1,3,5))</code>, which is different than the
previous, since order matters!</p>
</td></tr>
<tr><td><code id="strucplot_+3A_spacings">spacings</code></td>
<td>
<p>A list with x and y components that are nondecreasing
sequences of positive vaues. The ith value in the sequence gives the spacing
in character heights between the sets of panels at each level for the ith
conditioning variable in the component's direction. If either a single
vector or a list with single component is given, it is replicated. See the
<strong>Overview</strong> for further explanation. Default is <code>list(x=0:9,
y=0:9)</code></p>
</td></tr>
<tr><td><code id="strucplot_+3A_center">center</code></td>
<td>
<p>Logical, default FALSE. If the conditioning factors constitute
a 2-level design with a center point and center is TRUE, a compact trellis
plot that omits panels for the missing settings of the factors is drawn. If
FALSE or the design is not of this form, all panels are shown, which may be
informative in any case to better visualize the design sparsity.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_col">col</code></td>
<td>
<p>Fill color for the data frame method.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_newdata">newdata</code></td>
<td>
<p>For the <code>lm</code> method and objects inheriting from the
<code>lm</code> class. The 'newdata' argument for the associated <code>predict</code>
method. Consult <code><a href="stats.html#topic+predict.lm">predict.lm</a></code> for details.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_ylab">ylab</code></td>
<td>
<p>For the <code>lm</code> method. Optional y axis label for predicted values.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_predictargs">predictArgs</code></td>
<td>
<p>For the <code>lm</code> method. A <strong>list</strong> of optional named
arguments for the relevant <code>predict</code> method. These are will be used as part
of the <code>args</code> list when invoking the relevant predict method using
<code><a href="base.html#topic+do.call">do.call</a></code>.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_...">...</code></td>
<td>
<p>Further arguments to panel functions, methods, or
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A structured display is a trellis display without strip
labels. The factors and levels are
encoded by plot layout and spacing and decoded by a separate legend.
See the <strong>Overview</strong> below for a detailed explanation.
</p>


<h3>Value</h3>

<p>The formula method returns an object of type <code>c("structured", "trellis")</code>; or
<code>c("doe","structured","trellis")</code> for 2-level designs with a center point. This is a
trellis object with additional <code>structure</code> and <code>formula</code> attributes. The lm
method returns a class of <code>c("modelFit","structured","trellis")</code>. At present, this
extension is ignored, but future print/plot methods may take advantage of it. The other
methods return the same object as the formula method.
</p>
<p>The <code>structure</code> attribute provides xyLayout information. It is a list
with <code>x</code> and <code>y</code> components, each of which in turn is a list, one
of which may be empty (i.e. of length 0). The components of the x list have
names of the conditioning variables in the horizontal direction of the
layout with values the variable values; analogously for the y list.
</p>
<p>The <code>formula</code> attribute gives the actual formula used in the trellis
call, i.e. with the actual conditioning variable names substituted for &quot;.&quot;.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>formula</code>: Formula Method
</p>
</li>
<li> <p><code>default</code>: Default method prints an error message
</p>
</li>
<li> <p><code>data.frame</code>: Data frame method with no response to show design structure
</p>
</li>
<li> <p><code>list</code>: Converts to a data frame and calls the data.frame method
</p>
</li>
<li> <p><code>matrix</code>: Converts to a data frame and calls the data.frame method
</p>
</li>
<li> <p><code>lm</code>: Plots predicted values for fitted models inheriting
from class &quot;lm&quot;
</p>
</li></ul>


<h3>Overview</h3>

<p>The trellis display paradigm breaks down when there are
more than 2 or 3 conditioning variables, because the plotting area becomes
cluttered with multiple layers of strip labels identifying the panel
settings. This is especially a problem if one wants to show the structure or
results of studies that are (fractions of) factorial designs with the design
factors as conditioning variables. For example, in industrial type
experiments, it is not uncommon to have 5 or more experimental factors.
</p>
<p>It is also often the case that there are multiple responses &ndash; e.g.
several different characteristics of a product or a functional response like
an IR spectrum, MRI scan, or surface plot. It can be desirable to display
such results so that direct visual comparison of the complex responses can be made.
</p>
<p>The <code>strucplot</code> function enables such functionality by omitting the
strip labels and laying out the panels in a regular array, a 'xyLayout' in
which the position of the panels rather than their strip labels identifies
the variable settings.
</p>
<p>Because the lattice package already has these capabilities, <code>strucplot</code>
is implemented as a wrapper to lattice's <code>xyplot</code> function. This
provides a convenient interface, simplifies the code and, most
importantly, allows the user to access all of lattice's (and the underlying
grid graphics') functionality in the usual way. Only two extra arguments &ndash;
'xyLayout' and 'spacings' &ndash; are used to do this, although the default
'spacings' argument normally need not be changed. (There is also a third
'center' argument for 2 level factorial designs, which are commonly used in
industrial experiments, that is explained below.)
</p>


<h3>How does strucplot() work?</h3>

<p>Suppose that the data consist of a numeric vector response y for 4
conditioning factors, f1, f2, f3, and f4, where f1 and f2 each have 2
levels, f3 has 3 levels, and f4 has 4 levels. (Because the conditioning
variables are coerced to factors by <code>factor</code>, if level orderings other
than that given by these coercions are wanted, the user should do them
explicitly before calling <code>strucplot</code>).
</p>
<p>Then the call, <code>strucplot(~y|f1*f2*f3*f4)</code> would produce a trellis plot
without strip labels with 12 (= 3 x 4) rows and 4 (= 2 x 2) columns of
panels, some of which may be empty if the corresponding factor settings are
missing. The default xyLayout argument that produces this is: <code>xyLayout
 = list(x = 1:2, y = 3:4)</code>. It splits the conditioning variables as evenly as
possible into 2 groups with the x component getting the first 2 variables,
f1 and f2, and the y component getting the second 2 variables, f3 and f4.
(if there are an odd number of variables, the x component gets one more variable than
the y). This means the levels of the x variables, f1 and f2, vary from left to right
across each row. For the y variables, if <code>as.table = TRUE</code>, the default, the
levels of the y variables, f3 and f4, vary from top to bottom down each column;
otherwise if <code>as.table = FALSE</code>, from bottom to top up each column. Since there
are 4 combinations of levels for the x variables and 12 for y, this gives a 12 row by
4 column display.
</p>
<p>The panels are displayed in each direction in reverse lexicographic order,
where the 'alphabets' are the factor levels. This means that the first
variable changes the fastest; the second the next fastest, and so on. Using
(i,j) to denote setting in which the first factor is at the ith level and
the second is at the jth, this translates to (for <code>as.table = TRUE</code>):
</p>
 <dl>
<dt>Row ordering</dt><dd><p> (f1,f2): (1,1), (2,1), (1,2), (2,2)</p>
</dd>
<dt>Column ordering from top down</dt><dd><p> (f3, f4): ((1,1), (2,1), (3,1), (1,2),
(2,2), ... , (1,4), (2,4), (3,4)</p>
</dd> </dl>

<p>If one component is missing, if it is x, there will only be 1 column; if it
is y, only 1 row. The nonmissing component must still be correctly specified
to provide the panel ordering.
</p>


<h3>Panel spacing</h3>

<p>Variable spacing between the panels hierarchically groups them to identify
their settings. The default spacing for both x and y directions is 0:9. This
means that panels corresponding to the first, fastest changing, variable are
separated by 0 units (= character heights); groups of panels at each fixed
level of the second next fastest changing variable are separated by 1 unit;
groups of groups of panels at fixed levels of the third are separated by 2
units; and so forth.
</p>
<p>For the example, this means that the row spacing would look like ('X'
indicates a panel): XX  XX . And for columns it would be going down: XXX XXX
XXX XXX . The spacings can be different for x and y, but this is usually
unnecessary.
</p>


<h3>Effective xyLayout specification</h3>

<p>The default layout is often enhanced by changing the order of the factors
and the xyLayout; for example, ordering the factors from those with the
least change among levels to the most, or vice-versa; or setting the &quot;most
important&quot; factors along rows to facilitate visual comparison.
</p>
<p>The order of the variables &ndash; and hence which vary in the x or y direction
&ndash; is given both by the left to right order of the conditioning in the
formula and the xyLayout argument. Thus, in the example, conditioning with
<code>~|f3*f1*f2*f4</code> and setting the layout with <code>xyLayout = list(x=4,
 y=3:1)</code> is equivalent to <code>~|f4*f2*f1*f3</code> and <code>xyLayout =
 list(x=1,y=2:4)</code> and produces a display with 12 rows and 4 columns in which
the row panels now correspond to the 4 f4 levels and the column panels to
the levels of f2, f1, and f3. This redundancy is deliberate: it allows
changing layouts via the xyLayout argument to avoid rewriting a formula with
long names in a different order.
</p>


<h3>2 level designs with a center point &ndash; the 'center' argument</h3>

<p>Finally, the 'center' argument, a logical with default = <code>TRUE</code>,
controls the display when the conditioning factors are arranged as a 2 level
factorial design with a single &quot;pseudo&quot;-center point. &quot;pseudo&quot; here means
that the settings of the factors at the center need not be exactly in the
middle for numeric factors. If the design is not of this form, the 'center'
argument is ignored.
</p>
<p>For such designs, when <code>center = TRUE</code>,  a more compact display will be
drawn in which a center panel corresponding to the center point is shown as
the single panel in its row and column, but all other empty panels
corresponding to settings where some of the conditioning variables are at
their mid levels and some are not, are omitted. Examples are given below.
</p>
<p>If it is desired to show all the empty panels, which can be useful to
informatively represent the actual design sparsity, set  <code>center = FALSE</code>.
</p>


<h3>Note</h3>

<p>Because 'xyLayout' and the number of levels in the conditioning variables
determine the plot structure, a 'layout' argument in the call will be
ignored. Other <code>xyplot</code> arguments that are ignored are 'skip','between',
'drop.unused.levels', 'strip','perm.cond',and 'index.cond'. All other <code>xyplot</code>
should work as expected.
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+lattice">lattice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Compare standard xyplot vs. strucplot of quakes data in datasets package.
 #  Cut depth into 6 groups and magitude into 5.

 require(datasets)
 # Note that as.table = TRUE is used to make depths increase
 # down the page. For strucplot(), this is the default.

 xyplot(lat ~ long|cut(mag,5)*cut(depth,6),  data = quakes, col="blue",
  as.table = TRUE,type = c("g","p"))

 # Compare to:
 strucplot(lat ~ long|cut(mag,5)*cut(depth,6), data = quakes, col="blue",
    type = c("g", "p"))

 # Visualizing designs:

 # A half fraction of a 2^5 (a 2^(5-1)) design

 # Build the design matrix
  ff &lt;- do.call(expand.grid,rep(list(c(-1,1)),4))
  ff[[5]] &lt;- do.call(mapply,c(FUN = prod,ff))
   names(ff) &lt;- LETTERS[1:5]

 # Show the design
 strucplot(ff)

 # Plotting a 2 level design with a center point

 # Add a center point to ff and plot
  ffCenter &lt;- rbind(ff,rep(0,5))
  strucplot(ffCenter)

 # Use center = TRUE for a more compact display and show legend below.
  print(strucplot(ffCenter, center = TRUE),legendLoc = "bottom")

 # The "npk" data. See help("npk") for details.
 # Visualize design with blocks the vertical factor and the rest horizontal
  strucplot(npk[,-5], xyLay = list(x = 2:4, y =1))

  # Plot the yield
  strucplot(~yield |., xyLay = list(x=2:4, y=1),data = npk, col = "darkblue",
    panel = function(...){
      panel.grid(h = -1, v = 0)
      panel.xyplot(...)}
    )

 # It may be more informative to plot bars instead of points.
 # See help(panel.bars) for details.
 #
 # Note also "shortcut" ways to specify the xyLayout
  strucplot(~yield |., xyLay = list(x=2:4),data = npk,
            panel = panel.bars)

 # Include a conditioning variable in the formula to reduce the
 # dimensionality of conditioning. Show legend on right of plot.
  print(strucplot(yield ~ N|., xyLay = 2:3, data = npk,
            panel = panel.bars), legendLoc = "right")

 # Use the horizontal = TRUE argument of panel.bars to plot the bars
 # horizontally. The left and right hand sides of the formula must also
 # be switched for 2-sided formulas (not for 1-sided).
  strucplot( N ~ yield |., xyLay = list(y=1), data = npk,
            panel = panel.bars, horizontal = TRUE)

 # Fit a linear model with all main effects and 2 factor interactions in N,P,K
 # and plot the fits, using the "newdata" argument to plot predictions at
 # non-design points).
  require("stats")
    npk.aov &lt;- aov(yield ~ block + (N+P+K)^2, data = npk)
    full &lt;- do.call(expand.grid,lapply(npk[,-5],levels))
    plot(strucplot(npk.aov,  xyLay = list(x = 2:4),panel = panel.bars,
            newdata = full),legendLoc = "bottom")

   # Compare to a grouped plot:
   ypred &lt;- predict(npk.aov, new = full)
    plot(
      strucplot(ypred ~ N|K*block, groups = full$P, data = full,
        panel= function(x,y, groups, subscripts,cex=1.25,...){
          panel.grid(h=-1, v=0)
          panel.superpose(x,y,cex= cex, type = c("p","l"),...,
                    panel.groups = panel.xyplot,
                    groups=groups, subscripts =subscripts)},
        auto.key = list(points=FALSE,lines=TRUE, columns = 2,
                title = "P",cex.title=1), ylab = "Predicted Response" ),
      legendLoc = "right")

## Cleanup
rm(full, npk.aov, ypred,ff,ffCenter)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
