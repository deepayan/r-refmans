<!DOCTYPE html><html lang="en"><head><title>Help for package hierNet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hierNet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hierNet'><p>A Lasso for interactions</p></a></li>
<li><a href='#hierNet-internal'><p>Internal hierNet functions</p></a></li>
<li><a href='#hierNet.cv'><p>Cross-validation function for hierNet</p></a></li>
<li><a href='#hierNet.logistic'><p>A logistic regression Lasso for interactions</p></a></li>
<li><a href='#hierNet.logistic.path'><p>Fit a path of logistic hierNet models- lasso models with interactions</p></a></li>
<li><a href='#hierNet.path'><p>Fit a path of hierNet models- lasso models with interactions</p></a></li>
<li><a href='#hierNet.varimp'><p>Variable importance for hierNet.</p></a></li>
<li><a href='#predict.hierNet'><p>Prediction function for hierNet and hierNet.logistic.</p></a></li>
<li><a href='#predict.hierNet.logistic'><p>Prediction function for hierNet.logistic.</p></a></li>
<li><a href='#predict.hierNet.path'><p>Prediction function for hierNet.path and hierNet.logistic.path.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>A Lasso for Hierarchical Interactions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.9</td>
</tr>
<tr>
<td>Author:</td>
<td>Jacob Bien and Rob Tibshirani</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits sparse interaction models for continuous and binary responses subject to the strong (or weak) hierarchy restriction that an interaction between two variables only be included if both (or at least one of) the variables is included as a main effect.  For more details, see Bien, J., Taylor, J., Tibshirani, R., (2013) "A Lasso for Hierarchical Interactions." Annals of Statistics. 41(3). 1111-1141.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jacob Bien &lt;jbien@usc.edu&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-03 20:40:07 UTC; jacobbien</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-05 13:10:20 UTC</td>
</tr>
</table>
<hr>
<h2 id='hierNet'>A Lasso for interactions</h2><span id='topic+hierNet'></span>

<h3>Description</h3>

<p>One of the main functions in the hierNet package.
Builds a regression model with hierarchically constrained pairwise interactions.
Required inputs are an x matrix of
features (the columns are the features) and a y vector of
values.
Reasonably fast for moderate sized problems (100-200 variables). We are currently working
on an alternate algorithm for large scale problems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hierNet(x, y, lam, delta=1e-8, strong=FALSE, diagonal=TRUE, aa=NULL, zz=NULL,
        center=TRUE, stand.main=TRUE, stand.int=FALSE, 
        rho=nrow(x), niter=100, sym.eps=1e-3,
        step=1, maxiter=2000, backtrack=0.2, tol=1e-5, trace=0)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hierNet_+3A_x">x</code></td>
<td>
<p>A matrix of predictors, where the rows are the samples and
the columns are the predictors</p>
</td></tr>
<tr><td><code id="hierNet_+3A_y">y</code></td>
<td>
<p>A vector of observations, where length(y)  equals
nrow(x)</p>
</td></tr>
<tr><td><code id="hierNet_+3A_lam">lam</code></td>
<td>
<p>Regularization parameter (&gt;0).  L1 penalty param is <code>lam * (1-delta)</code>.</p>
</td></tr>
<tr><td><code id="hierNet_+3A_delta">delta</code></td>
<td>
<p>Elastic Net parameter. Squared L2 penalty param is <code>lam * delta</code>. Not a tuning parameter: Think of as fixed and small. Default 1e-8.</p>
</td></tr>
<tr><td><code id="hierNet_+3A_strong">strong</code></td>
<td>
<p>Flag specifying strong hierarchy (TRUE) or weak
hierarchy (FALSE). Default FALSE.</p>
</td></tr>
<tr><td><code id="hierNet_+3A_diagonal">diagonal</code></td>
<td>
<p>Flag specifying whether to include &quot;pure&quot; quadratic
terms, th_jjX_j^2, in the model.  Default TRUE.</p>
</td></tr>
<tr><td><code id="hierNet_+3A_aa">aa</code></td>
<td>
<p>An *optional* argument, a list with results from a previous call</p>
</td></tr>
<tr><td><code id="hierNet_+3A_zz">zz</code></td>
<td>
<p>An *optional* argument, a matrix whose columns are products of features, computed by the function compute.interactions.c</p>
</td></tr>
<tr><td><code id="hierNet_+3A_center">center</code></td>
<td>
<p>Should features be centered? Default TRUE; FALSE should rarely be used.  This option is available for special uses only</p>
</td></tr>
<tr><td><code id="hierNet_+3A_stand.main">stand.main</code></td>
<td>
<p>Should main effects be standardized? Default TRUE.</p>
</td></tr>
<tr><td><code id="hierNet_+3A_stand.int">stand.int</code></td>
<td>
<p>Should interactions be standardized? Default FALSE.</p>
</td></tr>
<tr><td><code id="hierNet_+3A_rho">rho</code></td>
<td>
<p>ADMM parameter: tuning parameter (&gt;0) for ADMM. If there are convergence
problems, try decreasing <code>rho</code>. Default n.</p>
</td></tr>
<tr><td><code id="hierNet_+3A_niter">niter</code></td>
<td>
<p>ADMM parameter: number of iterations</p>
</td></tr>
<tr><td><code id="hierNet_+3A_sym.eps">sym.eps</code></td>
<td>
<p>ADMM parameter: threshold for symmetrizing with strong=TRUE</p>
</td></tr>
<tr><td><code id="hierNet_+3A_step">step</code></td>
<td>
<p>Stepsize for generalized gradient descent</p>
</td></tr>
<tr><td><code id="hierNet_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations for generalized gradient descent</p>
</td></tr>
<tr><td><code id="hierNet_+3A_backtrack">backtrack</code></td>
<td>
<p>Backtrack parameter for generalized gradient descent</p>
</td></tr>
<tr><td><code id="hierNet_+3A_tol">tol</code></td>
<td>
<p>Error tolerance parameter for generalized gradient descent</p>
</td></tr>
<tr><td><code id="hierNet_+3A_trace">trace</code></td>
<td>
<p>Output option; trace=1 gives verbose output</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>bp</code></td>
<td>
<p>p-vector of estimated  &quot;positive part&quot;  main effect (p=# features)</p>
</td></tr>
<tr><td><code>bn</code></td>
<td>
<p>p-vector of estimated  &quot;negative part&quot;  main effect; overall main effect estimated coefficients are bp-bn </p>
</td></tr>
<tr><td><code>th</code></td>
<td>
<p> Matrix of estimated interaction coefficients, of dimension p by p. Note: when output from hierNet is printed, th is symmetrized (set to (th+t(th))/2)
for simplicity.</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>Value of objective function at minimum.</p>
</td></tr>
<tr><td><code>lam</code></td>
<td>
<p>Value of lambda used</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of model fit- &quot;gaussian&quot; or &quot;logistic&quot; (binomial)</p>
</td></tr>
<tr><td><code>mx</code></td>
<td>
<p> p-vector of  column means of x</p>
</td></tr>
<tr><td><code>sx</code></td>
<td>
<p> p-vector of  column standard deviations of x</p>
</td></tr>
<tr><td><code>my</code></td>
<td>
<p> mean of y</p>
</td></tr>
<tr><td><code>mzz</code></td>
<td>
<p> column means of feature product matrix</p>
</td></tr>
<tr><td><code>szz</code></td>
<td>
<p> column standard deviations of feature product matrix</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call to hierNet</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jacob Bien and Robert Tibshirani</p>


<h3>References</h3>

<p>Bien, J., Taylor, J., Tibshirani, R., (2013) &quot;A Lasso for Hierarchical Interactions.&quot; Annals of Statistics. 41(3). 1111-1141.</p>


<h3>See Also</h3>

<p><a href="#topic+predict.hierNet">predict.hierNet</a>, <a href="#topic+hierNet.cv">hierNet.cv</a>, <a href="#topic+hierNet.path">hierNet.path</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12)
# fit a single hierNet model
x=matrix(rnorm(100*10),ncol=10)
x=scale(x,TRUE,TRUE)
y=x[,1]+2*x[,2]+ x[,1]*x[,2]+3*rnorm(100)
fit=hierNet(x,y,lam=50)
print(fit)

# try strong (rather than weak) hierarchy
fit=hierNet(x,y,lam=50, strong=TRUE)
print(fit)

# a typical analysis including cross-validation
set.seed(12)
x=matrix(rnorm(100*10),ncol=10)
x=scale(x,TRUE,TRUE)
y=x[,1]+2*x[,2]+ x[,1]*x[,2]+3*rnorm(100)
fit=hierNet.path(x,y)
fitcv=hierNet.cv(fit,x,y)
print(fitcv)

lamhat=fitcv$lamhat.1se
fit2=hierNet(x,y,lam=lamhat)
yhat=predict(fit2,x)
</code></pre>

<hr>
<h2 id='hierNet-internal'>Internal hierNet functions</h2><span id='topic+print.hierNet'></span><span id='topic+print.hierNet.path'></span><span id='topic+print.hierNet.cv'></span><span id='topic+plot.hierNet.cv'></span><span id='topic+critf.logistic'></span><span id='topic+Objective'></span><span id='topic+Objective.logistic'></span><span id='topic+compute.interactions.c'></span>

<h3>Description</h3>

<p>Internal hierNet functions</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hierNet'
print(x,...)
## S3 method for class 'hierNet.path'
print(x,...)
## S3 method for class 'hierNet.cv'
print(x,...)
## S3 method for class 'hierNet.cv'
plot(x,...)
critf.logistic(x, y, lam.l1, lam.l2, b0, bp, bn, th)
Objective(aa, x, y, lam.l1, lam.l2, xnum = NULL, zz = NULL, strong = TRUE, 
    sym.eps = 0.001)
Objective.logistic(aa, x, y, lam.l1, lam.l2, xnum = NULL, zz = NULL, strong = TRUE, 
    sym.eps = 0.001) 
compute.interactions.c(x, diagonal = TRUE)
</code></pre>


<h3>Details</h3>

<p>These  are internal functions,  not to be called by the user.</p>


<h3>Author(s)</h3>

<p>Jacob Bien and Robert Tibshirani</p>

<hr>
<h2 id='hierNet.cv'>Cross-validation function for hierNet</h2><span id='topic+hierNet.cv'></span>

<h3>Description</h3>

<p>Uses cross-validation to estimate the regularization parameter for hierNet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hierNet.cv(fit, x, y, nfolds=10,folds=NULL,trace=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hierNet.cv_+3A_fit">fit</code></td>
<td>
<p>Object returned from call to hierNet.path or hierNet.logistic.path.  All parameter settings
will be taken from this object.</p>
</td></tr>
<tr><td><code id="hierNet.cv_+3A_x">x</code></td>
<td>
<p>A matrix of predictors, where the rows are the samples and
the columns are the predictors</p>
</td></tr>
<tr><td><code id="hierNet.cv_+3A_y">y</code></td>
<td>
<p>A vector of observations, where length(y)  equals
nrow(x)</p>
</td></tr>
<tr><td><code id="hierNet.cv_+3A_nfolds">nfolds</code></td>
<td>
<p>Number of cross-validation folds</p>
</td></tr>
<tr><td><code id="hierNet.cv_+3A_folds">folds</code></td>
<td>
<p>(Optional) user-supplied cross-validation folds.  If provided, nfolds is ignored.</p>
</td></tr>
<tr><td><code id="hierNet.cv_+3A_trace">trace</code></td>
<td>
<p>Verbose output? 0=no, 1=yes</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>lamlist</code></td>
<td>
<p>Vector of lambda values tried</p>
</td></tr>
<tr><td><code>cv.err</code></td>
<td>
<p>Estimate of cross-validation error</p>
</td></tr>
<tr><td><code>cv.se</code></td>
<td>
<p>Estimated  standard error of cross-validation estimate </p>
</td></tr>
<tr><td><code>lamhat</code></td>
<td>
<p>lambda value minimizing cv.err</p>
</td></tr>
<tr><td><code>lamhat.1se</code></td>
<td>
<p>largest lambda value with cv.err less than  or equal to min(cv.err)+ SE </p>
</td></tr>
<tr><td><code>folds</code></td>
<td>
<p>Indices of folds used in cross-validation</p>
</td></tr>
<tr><td><code>yhat</code></td>
<td>
<p>n by nlam matrix of predicted values.  Here, ith prediction
is based on training on all folds that do not include the ith data
point.</p>
</td></tr>
<tr><td><code>nonzero</code></td>
<td>
<p>Vector giving number of non-zero coefficients for each
lambda value</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call to hierNet.cv</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jacob Bien and Robert Tibshirani</p>


<h3>References</h3>

<p>Bien, J., Taylor, J., Tibshirani, R., (2013) &quot;A Lasso for Hierarchical Interactions.&quot; Annals of Statistics. 41(3). 1111-1141.</p>


<h3>See Also</h3>

<p><a href="#topic+hierNet">hierNet</a>,<a href="#topic+hierNet.path">hierNet.path</a>, <a href="#topic+hierNet.logistic">hierNet.logistic</a>,<a href="#topic+hierNet.logistic.path">hierNet.logistic.path</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12)
x=matrix(rnorm(100*10),ncol=10)
x=scale(x,TRUE,TRUE)
y=x[,1]+2*x[,2]+ x[,1]*x[,2]+3*rnorm(100)
fit=hierNet.path(x,y)
fitcv=hierNet.cv(fit,x,y)
print(fitcv)
plot(fitcv)


x=matrix(rnorm(100*10),ncol=10)
x=scale(x,TRUE,TRUE)
y=x[,1]+2*x[,2]+ x[,1]*x[,2]+3*rnorm(100)
y=1*(y&gt;0)
fit=hierNet.logistic.path(x,y)
fitcv=hierNet.cv(fit,x,y)
print(fitcv)
plot(fitcv)
</code></pre>

<hr>
<h2 id='hierNet.logistic'>A logistic regression Lasso for interactions</h2><span id='topic+hierNet.logistic'></span>

<h3>Description</h3>

<p>One of the main functions in the hierNet package.
Builds a logistic regression model with hierarchically constrained pairwise interactions.
Required inputs are an x matrix of
features (the columns are the features) and a y vector of
values.
Reasonably fast for moderate sized problems (100-200 variables). We are currently working
on a alternate algorithm for large scale problems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hierNet.logistic(x, y, lam, delta=1e-8, diagonal=TRUE, strong=FALSE, aa=NULL, zz=NULL,
                 center=TRUE, stand.main=TRUE, stand.int=FALSE,
                 rho=nrow(x), niter=100, sym.eps=1e-3,# ADMM params
                 step=1, maxiter=2000, backtrack=0.2, tol=1e-5, trace=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hierNet.logistic_+3A_x">x</code></td>
<td>
<p>A matrix of predictors, where the rows are the samples and
the columns are the predictors</p>
</td></tr>
<tr><td><code id="hierNet.logistic_+3A_y">y</code></td>
<td>
<p>A vector of observations, with values 0 or 1, where length(y)  equals
nrow(x)</p>
</td></tr>
<tr><td><code id="hierNet.logistic_+3A_lam">lam</code></td>
<td>
<p>Regularization parameter (&gt;0).  L1 penalty param is <code>lam * (1-delta)</code>.</p>
</td></tr>
<tr><td><code id="hierNet.logistic_+3A_delta">delta</code></td>
<td>
<p>Elastic Net parameter. Squared L2 penalty param is <code>lam * delta</code>. Not a tuning parameter: Think of as fixed and small. Default 1e-8.</p>
</td></tr>
<tr><td><code id="hierNet.logistic_+3A_diagonal">diagonal</code></td>
<td>
<p>Flag specifying whether to include &quot;pure&quot; quadratic
terms, th_jjX_j^2, in the model.  Default TRUE.</p>
</td></tr>  
<tr><td><code id="hierNet.logistic_+3A_strong">strong</code></td>
<td>
<p>Flag specifying strong hierarchy (TRUE) or weak hierarchy (FALSE). Default FALSE</p>
</td></tr>
<tr><td><code id="hierNet.logistic_+3A_aa">aa</code></td>
<td>
<p>An *optional* argument, a list with results from a previous call</p>
</td></tr>
<tr><td><code id="hierNet.logistic_+3A_zz">zz</code></td>
<td>
<p>An  *optional* argument, a matrix whose columns are products of features, computed by the function compute.interactions.c</p>
</td></tr>
<tr><td><code id="hierNet.logistic_+3A_center">center</code></td>
<td>
<p>Should features be centered? Default TRUE; FALSE should rarely be used.  This option is available for special uses only</p>
</td></tr>
<tr><td><code id="hierNet.logistic_+3A_stand.main">stand.main</code></td>
<td>
<p>Should main effects be standardized? Default TRUE</p>
</td></tr>
<tr><td><code id="hierNet.logistic_+3A_stand.int">stand.int</code></td>
<td>
<p>Should interactions be standardized? Default FALSE</p>
</td></tr>
<tr><td><code id="hierNet.logistic_+3A_rho">rho</code></td>
<td>
<p>ADMM parameter: tuning parameter (&gt;0) for ADMM. If there are convergence
problems, try decreasing <code>rho</code>. Default n.</p>
</td></tr>
<tr><td><code id="hierNet.logistic_+3A_niter">niter</code></td>
<td>
<p>ADMM parameter: number of iterations</p>
</td></tr>
<tr><td><code id="hierNet.logistic_+3A_sym.eps">sym.eps</code></td>
<td>
<p>ADMM parameter Thresholding for symmetrizing with strong=TRUE</p>
</td></tr>
<tr><td><code id="hierNet.logistic_+3A_step">step</code></td>
<td>
<p>Stepsize for generalized gradient descent</p>
</td></tr>
<tr><td><code id="hierNet.logistic_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations for generalized gradient descent</p>
</td></tr>
<tr><td><code id="hierNet.logistic_+3A_backtrack">backtrack</code></td>
<td>
<p>Backtrack parameter for generalized gradient descent</p>
</td></tr>
<tr><td><code id="hierNet.logistic_+3A_tol">tol</code></td>
<td>
<p>Error tolerance parameter for generalized gradient descent</p>
</td></tr>
<tr><td><code id="hierNet.logistic_+3A_trace">trace</code></td>
<td>
<p>Output option; trace=1 gives verbose output</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>b0</code></td>
<td>
<p>Intercept</p>
</td></tr>
<tr><td><code>bp</code></td>
<td>
<p>p-vector of estimated  &quot;positive part&quot;  main effect (p=#features)</p>
</td></tr>
<tr><td><code>bn</code></td>
<td>
<p>p-vector of estimated  &quot;negative part&quot;  main effect; overall main effect estimated coefficients are bp-bn </p>
</td></tr>
<tr><td><code>th</code></td>
<td>
<p>Matrix of estimated interaction coefficients, of dimension p by p</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>Value of objective function at minimum.</p>
</td></tr>
<tr><td><code>lam</code></td>
<td>
<p>Value of lambda used</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of model fit- &quot;gaussian&quot; or &quot;logistic&quot; (binomial)</p>
</td></tr>
<tr><td><code>mx</code></td>
<td>
<p>p-vector of column means of x</p>
</td></tr>
<tr><td><code>my</code></td>
<td>
<p>Mean of y</p>
</td></tr>
<tr><td><code>sx</code></td>
<td>
<p>p-vector of  column standard deviations of x</p>
</td></tr>
<tr><td><code>mzz</code></td>
<td>
<p> column means of feature product matrix</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call to hierNet</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jacob Bien and Robert Tibshirani</p>


<h3>References</h3>

<p>Bien, J., Taylor, J., Tibshirani, R., (2013) &quot;A Lasso for Hierarchical Interactions.&quot; Annals of Statistics. 41(3). 1111-1141.</p>


<h3>See Also</h3>

<p><a href="#topic+predict.hierNet.logistic">predict.hierNet.logistic</a>,linkhierNet.logistic.path</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12)
x=matrix(rnorm(100*10),ncol=10)
x=scale(x,TRUE,TRUE)
y=x[,1]+2*x[,2]+ x[,1]*x[,2]+3*rnorm(100)
y=1*(y&gt;0)
fit=hierNet.logistic(x,y,lam=5)
print(fit)
</code></pre>

<hr>
<h2 id='hierNet.logistic.path'>Fit a path of logistic hierNet models- lasso models with interactions</h2><span id='topic+hierNet.logistic.path'></span>

<h3>Description</h3>

<p>One of the main functions in the hierNet package.
Fits a logistic path of hierNet models over different values of the regularization parameter.
Calls hierNet.logistic, which builds a regression model with hierarchically constrained pairwise interactions.
Required inputs are an x matrix of
features (the columns are the features) and a y vector of
values.
Reasonably fast for moderate sized problems (100-200 variables). We are currently working
on a alternate algorithm for large scale problems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hierNet.logistic.path(x, y,
           lamlist = NULL, delta=1e-8, minlam = NULL, maxlam = NULL, flmin=.01, nlam = 20,
           diagonal = TRUE, strong = FALSE, aa = NULL, zz = NULL,
           stand.main = TRUE, stand.int = FALSE,
           rho = nrow(x), niter = 100, sym.eps = 0.001, 
           step = 1, maxiter = 2000, backtrack = 0.2, tol = 1e-05, trace = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hierNet.logistic.path_+3A_x">x</code></td>
<td>
<p>A matrix of predictors, where the rows are the samples and
the columns are the predictors</p>
</td></tr>
<tr><td><code id="hierNet.logistic.path_+3A_y">y</code></td>
<td>
<p>A vector of observations equal to 0 or 1, where length(y)  equals
nrow(x)</p>
</td></tr>
<tr><td><code id="hierNet.logistic.path_+3A_lamlist">lamlist</code></td>
<td>
<p>Optional vector of values of lambda (the regularization parameter).  L1 penalty param is <code>lambda * (1-delta)</code>.</p>
</td></tr>
<tr><td><code id="hierNet.logistic.path_+3A_delta">delta</code></td>
<td>
<p>Elastic Net parameter. Squared L2 penalty param is <code>lambda * delta</code>. Not a tuning parameter: Think of as fixed and small. Default 1e-8.</p>
</td></tr>
<tr><td><code id="hierNet.logistic.path_+3A_minlam">minlam</code></td>
<td>
<p>Optional minimum value for  lambda</p>
</td></tr> 
<tr><td><code id="hierNet.logistic.path_+3A_maxlam">maxlam</code></td>
<td>
<p>Optional maximum value for  lambda</p>
</td></tr>
<tr><td><code id="hierNet.logistic.path_+3A_flmin">flmin</code></td>
<td>
<p>Fraction of maxlam; minlam= flmin*maxlam. If computation is slow, try increasing
flmin to focus on the sparser part of the path</p>
</td></tr>
<tr><td><code id="hierNet.logistic.path_+3A_nlam">nlam</code></td>
<td>
<p>Number of values of lambda to be tried</p>
</td></tr>
<tr><td><code id="hierNet.logistic.path_+3A_diagonal">diagonal</code></td>
<td>
<p>Flag specifying whether to include &quot;pure&quot; quadratic
terms, th_jjX_j^2, in the model.  Default TRUE.</p>
</td></tr>
<tr><td><code id="hierNet.logistic.path_+3A_stand.main">stand.main</code></td>
<td>
<p>Should main effects be standardized? Default TRUE</p>
</td></tr>
<tr><td><code id="hierNet.logistic.path_+3A_stand.int">stand.int</code></td>
<td>
<p>Should interactions be standardized? Default FALSE</p>
</td></tr>
<tr><td><code id="hierNet.logistic.path_+3A_strong">strong</code></td>
<td>
<p>Flag specifying strong hierarchy (TRUE) or weak hierarchy (FALSE). Default FALSE</p>
</td></tr>
<tr><td><code id="hierNet.logistic.path_+3A_aa">aa</code></td>
<td>
<p>An *optional* argument, a list with results from a previous call</p>
</td></tr>
<tr><td><code id="hierNet.logistic.path_+3A_zz">zz</code></td>
<td>
<p>An  *optional* argument, a matrix whose columns are products of features, computed by the function compute.interactions.c</p>
</td></tr>
<tr><td><code id="hierNet.logistic.path_+3A_rho">rho</code></td>
<td>
<p>ADMM parameter: tuning parameter (&gt;0) for ADMM. If there are convergence
problems, try decreasing <code>rho</code>. Default n.</p>
</td></tr>
<tr><td><code id="hierNet.logistic.path_+3A_niter">niter</code></td>
<td>
<p>ADMM parameter: number of iterations</p>
</td></tr>
<tr><td><code id="hierNet.logistic.path_+3A_sym.eps">sym.eps</code></td>
<td>
<p>ADMM parameter Thresholding for symmetrizing with strong=TRUE</p>
</td></tr>
<tr><td><code id="hierNet.logistic.path_+3A_step">step</code></td>
<td>
<p>Stepsize for generalized gradient descent</p>
</td></tr>
<tr><td><code id="hierNet.logistic.path_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations for generalized gradient descent</p>
</td></tr>
<tr><td><code id="hierNet.logistic.path_+3A_backtrack">backtrack</code></td>
<td>
<p>Backtrack parameter for generalized gradient descent</p>
</td></tr>
<tr><td><code id="hierNet.logistic.path_+3A_tol">tol</code></td>
<td>
<p>Error tolerance parameter for generalized gradient descent</p>
</td></tr>
<tr><td><code id="hierNet.logistic.path_+3A_trace">trace</code></td>
<td>
<p>Output option; trace=1 gives verbose output</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>bp</code></td>
<td>
<p>p by nlam  matrix of estimated  &quot;positive part&quot;  main
effects (p=#features)</p>
</td></tr>
<tr><td><code>bn</code></td>
<td>
<p>p by nlam  matrix of estimated  &quot;negative part&quot;  main effects</p>
</td></tr>
<tr><td><code>th</code></td>
<td>
<p>p by p by nlam array of estimated interaction coefficients</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>nlam values of objective function, one per lambda value</p>
</td></tr>
<tr><td><code>lamlist</code></td>
<td>
<p>Vector of values of lambda used</p>
</td></tr>
<tr><td><code>mx</code></td>
<td>
<p>p-vector of  column means of x</p>
</td></tr>
<tr><td><code>sx</code></td>
<td>
<p>p-vector of  column standard deviations of x</p>
</td></tr>
<tr><td><code>my</code></td>
<td>
<p>mean of y</p>
</td></tr>
<tr><td><code>mzz</code></td>
<td>
<p>column means of feature product matrix</p>
</td></tr>
<tr><td><code>szz</code></td>
<td>
<p>column standard deviations of feature product matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jacob Bien and Robert Tibshirani</p>


<h3>References</h3>

<p>Bien, J., Taylor, J., Tibshirani, R., (2013) &quot;A Lasso for Hierarchical Interactions.&quot; Annals of Statistics. 41(3). 1111-1141.</p>


<h3>See Also</h3>

<p><a href="#topic+hierNet">hierNet</a>,<a href="#topic+predict.hierNet">predict.hierNet</a>, <a href="#topic+hierNet.cv">hierNet.cv</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12)
x=matrix(rnorm(100*10),ncol=10)
x=scale(x,TRUE,TRUE)
y=x[,1]+2*x[,2]+ x[,1]*x[,2]+3*rnorm(100)
y=1*(y&gt;0)
fit=hierNet.logistic.path(x,y)
print(fit)
</code></pre>

<hr>
<h2 id='hierNet.path'>Fit a path of hierNet models- lasso models with interactions</h2><span id='topic+hierNet.path'></span>

<h3>Description</h3>

<p>One of the main functions in the hierNet package.
Fits a path of hierNet models over different values of the regularization parameter.
Calls hierNet, which builds a regression model with hierarchically constrained pairwise interactions.
Required inputs are an x matrix of
features (the columns are the features) and a y vector of
values.
Reasonably fast for moderate sized problems (100-200 variables). We are currently working
on an alternate algorithm for large scale problems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hierNet.path(x, y,
             lamlist = NULL, delta=1e-8, minlam = NULL, maxlam = NULL, nlam=20, flmin=.01,
             diagonal = TRUE, strong = FALSE, aa = NULL, zz = NULL,
             stand.main = TRUE, stand.int = FALSE,
             rho = nrow(x), niter = 100, sym.eps = 0.001, 
             step = 1, maxiter = 2000, backtrack = 0.2, tol = 1e-05, trace = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hierNet.path_+3A_x">x</code></td>
<td>
<p>A matrix of predictors, where the rows are the samples and
the columns are the predictors</p>
</td></tr>
<tr><td><code id="hierNet.path_+3A_y">y</code></td>
<td>
<p>A vector  of observations, where length(y) equals
nrow(x)</p>
</td></tr>
<tr><td><code id="hierNet.path_+3A_lamlist">lamlist</code></td>
<td>
<p>Optional vector of values of lambda (the regularization parameter). L1 penalty param is <code>lamdbda * (1-delta)</code>.</p>
</td></tr>
<tr><td><code id="hierNet.path_+3A_delta">delta</code></td>
<td>
<p>Elastic Net parameter. Squared L2 penalty param is <code>lambda * delta</code>. Not a tuning parameter: Think of as fixed and small. Default 1e-8.</p>
</td></tr>
<tr><td><code id="hierNet.path_+3A_minlam">minlam</code></td>
<td>
<p>Optional minimum value for lambda</p>
</td></tr> 
<tr><td><code id="hierNet.path_+3A_maxlam">maxlam</code></td>
<td>
<p>Optional maximum value for lambda</p>
</td></tr>
<tr><td><code id="hierNet.path_+3A_nlam">nlam</code></td>
<td>
<p>Number of values of lambda to be tried</p>
</td></tr>
<tr><td><code id="hierNet.path_+3A_flmin">flmin</code></td>
<td>
<p>Fraction of maxlam; minlam= flmin*maxlam. If computation is slow, try increasing
flmin to focus on the sparser part of the path</p>
</td></tr>
<tr><td><code id="hierNet.path_+3A_diagonal">diagonal</code></td>
<td>
<p>Flag specifying whether to include &quot;pure&quot; quadratic
terms, th_jjX_j^2, in the model.  Default TRUE.</p>
</td></tr>
<tr><td><code id="hierNet.path_+3A_strong">strong</code></td>
<td>
<p>Flag specifying strong hierarchy (true) or weak hierarchy (false). Default false</p>
</td></tr>
<tr><td><code id="hierNet.path_+3A_aa">aa</code></td>
<td>
<p>An *optional* argument, a list with results from a previous call</p>
</td></tr>
<tr><td><code id="hierNet.path_+3A_zz">zz</code></td>
<td>
<p>An  *optional* argument, a matrix whose columns are products of features, computed by the function compute.interactions.c</p>
</td></tr>
<tr><td><code id="hierNet.path_+3A_stand.main">stand.main</code></td>
<td>
<p>Should main effects be standardized? Default TRUE</p>
</td></tr>
<tr><td><code id="hierNet.path_+3A_stand.int">stand.int</code></td>
<td>
<p>Should interactions be standardized? Default FALSE</p>
</td></tr>
<tr><td><code id="hierNet.path_+3A_rho">rho</code></td>
<td>
<p>ADMM parameter: tuning parameter (&gt;0) for ADMM. If there are convergence
problems, try decreasing rho. Default n.</p>
</td></tr>
<tr><td><code id="hierNet.path_+3A_niter">niter</code></td>
<td>
<p>ADMM parameter: number of iterations</p>
</td></tr>
<tr><td><code id="hierNet.path_+3A_sym.eps">sym.eps</code></td>
<td>
<p>ADMM parameter Thresholding for symmetrizing with strong=TRUE</p>
</td></tr>
<tr><td><code id="hierNet.path_+3A_step">step</code></td>
<td>
<p>Stepsize for generalized gradient descent</p>
</td></tr>
<tr><td><code id="hierNet.path_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations for generalized gradient descent</p>
</td></tr>
<tr><td><code id="hierNet.path_+3A_backtrack">backtrack</code></td>
<td>
<p>Backtrack parameter for generalized gradient descent</p>
</td></tr>
<tr><td><code id="hierNet.path_+3A_tol">tol</code></td>
<td>
<p>Error tolerance parameter for generalized gradient descent</p>
</td></tr>
<tr><td><code id="hierNet.path_+3A_trace">trace</code></td>
<td>
<p>Output option; trace=1 gives verbose output</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>bp</code></td>
<td>
<p>p by nlam  matrix of estimated  &quot;positive part&quot;  main effects (p=#variables)</p>
</td></tr>
<tr><td><code>bn</code></td>
<td>
<p>p by nlam  matrix of estimated  &quot;negative part&quot;  main effects</p>
</td></tr>
<tr><td><code>th</code></td>
<td>
<p>p by p by nlam array of estimated interaction coefficients</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>nlam values of objective function, one per lambda value</p>
</td></tr>
<tr><td><code>lamlist</code></td>
<td>
<p>Vector of values of lambda used</p>
</td></tr>
<tr><td><code>mx</code></td>
<td>
<p> p-vector of  column means of x</p>
</td></tr>
<tr><td><code>sx</code></td>
<td>
<p> p-vector of  column standard deviations of x</p>
</td></tr>
<tr><td><code>my</code></td>
<td>
<p> mean of y</p>
</td></tr>
<tr><td><code>mzz</code></td>
<td>
<p> column means of feature product matrix</p>
</td></tr>
<tr><td><code>szz</code></td>
<td>
<p> column standard deviations of feature product matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jacob Bien and Robert Tibshirani</p>


<h3>References</h3>

<p>Bien, J., Taylor, J., Tibshirani, R., (2013) &quot;A Lasso for Hierarchical Interactions.&quot; Annals of Statistics. 41(3). 1111-1141.</p>


<h3>See Also</h3>

<p><a href="#topic+hierNet">hierNet</a>,<a href="#topic+predict.hierNet">predict.hierNet</a>, <a href="#topic+hierNet.cv">hierNet.cv</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12)
x=matrix(rnorm(100*10),ncol=10)
x=scale(x,TRUE,TRUE)
y=x[,1]+2*x[,2]+ x[,1]*x[,2]+3*rnorm(100)
fit=hierNet.path(x,y)
print(fit)
</code></pre>

<hr>
<h2 id='hierNet.varimp'>Variable importance for hierNet.</h2><span id='topic+hierNet.varimp'></span>

<h3>Description</h3>

<p>(This is an experimental function.)  Calculates a measure of the importance of each variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hierNet.varimp(fit, x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hierNet.varimp_+3A_fit">fit</code></td>
<td>
<p>The results of a call to the &quot;hierNet&quot;</p>
</td></tr>
<tr><td><code id="hierNet.varimp_+3A_x">x</code></td>
<td>
<p>The training set feature matrix used in call produced &quot;fit&quot;</p>
</td></tr>
<tr><td><code id="hierNet.varimp_+3A_y">y</code></td>
<td>
<p>The training set response vector used in call produced &quot;fit&quot;</p>
</td></tr>
<tr><td><code id="hierNet.varimp_+3A_...">...</code></td>
<td>
<p>additional arguments (not currently used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Table of variable importance.
</p>


<h3>Author(s)</h3>

<p>Jacob Bien and Robert Tibshirani</p>


<h3>References</h3>

<p>Bien, J., Taylor, J., Tibshirani, R., (2013) &quot;A Lasso for Hierarchical Interactions.&quot; Annals of Statistics. 41(3). 1111-1141.</p>


<h3>See Also</h3>

<p><a href="#topic+hierNet">hierNet</a>, <a href="#topic+hierNet.path">hierNet.path</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12)
x=matrix(rnorm(100*10),ncol=10)
x=scale(x,TRUE,TRUE)
y=x[,1]+2*x[,2]+ x[,1]*x[,2]+3*rnorm(100)
newx=matrix(rnorm(100*10),ncol=10)
fit=hierNet(x,y,lam=50)
yhat=predict(fit,newx)

fit=hierNet.path(x,y)
yhat=predict(fit,newx)
</code></pre>

<hr>
<h2 id='predict.hierNet'>Prediction function for hierNet and hierNet.logistic.</h2><span id='topic+predict.hierNet'></span>

<h3>Description</h3>

<p>A function to perform prediction, using an x matrix and the output of
the &quot;hierNet&quot; or &quot;hiernet.logistic&quot; function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hierNet'
predict(object, newx, newzz=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.hierNet_+3A_object">object</code></td>
<td>
<p>The results of a call to the &quot;hierNet&quot; or &quot;hierNet.path&quot; or
function. The
coefficients that are part of this object will be used for
making predictions.</p>
</td></tr>
<tr><td><code id="predict.hierNet_+3A_newx">newx</code></td>
<td>
<p>The new x at which predictions should be made. Can be a
vector 
or a matrix  (one obseration per row).</p>
</td></tr>
<tr><td><code id="predict.hierNet_+3A_newzz">newzz</code></td>
<td>
<p>Optional matrix of products of columns of newx, computed by compute.interactions.c</p>
</td></tr>
<tr><td><code id="predict.hierNet_+3A_...">...</code></td>
<td>
<p>additional arguments (not currently used)</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>yhat</code></td>
<td>
<p>Vector of predictions for each observation. For logistic model, these are the
estimated probabilities.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jacob Bien and Robert Tibshirani</p>


<h3>References</h3>

<p>Bien, J., Taylor, J., Tibshirani, R., (2013) &quot;A Lasso for Hierarchical Interactions.&quot; Annals of Statistics. 41(3). 1111-1141.</p>


<h3>See Also</h3>

<p><a href="#topic+hierNet">hierNet</a>, <a href="#topic+hierNet.path">hierNet.path</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12)
x=matrix(rnorm(100*10),ncol=10)
x=scale(x,TRUE,TRUE)
y=x[,1]+2*x[,2]+ x[,1]*x[,2]+3*rnorm(100)
newx=matrix(rnorm(100*10),ncol=10)
fit=hierNet(x,y,lam=50)
yhat=predict(fit,newx)

fit=hierNet.path(x,y)
yhat=predict(fit,newx)
</code></pre>

<hr>
<h2 id='predict.hierNet.logistic'>Prediction function for hierNet.logistic.</h2><span id='topic+predict.hierNet.logistic'></span>

<h3>Description</h3>

<p>A function to perform prediction, using an x matrix and the output of
the &quot;hierNet.logistic&quot; function or &quot;hierNet.logistic.path&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hierNet.logistic'
predict(object, newx, newzz=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.hierNet.logistic_+3A_object">object</code></td>
<td>
<p>The results of a call to the &quot;hierNet.logistic&quot; or &quot;hierNet.logistic.path&quot; or
function. The
coefficients that are part of this object will be used for
making predictions.</p>
</td></tr>
<tr><td><code id="predict.hierNet.logistic_+3A_newx">newx</code></td>
<td>
<p>The new x at which predictions should be made. Can be a
vector 
or a matrix  (one observation per row).</p>
</td></tr>
<tr><td><code id="predict.hierNet.logistic_+3A_newzz">newzz</code></td>
<td>
<p>Optional matrix of products of columns of newx, computed by compute.interactions.c</p>
</td></tr>
<tr><td><code id="predict.hierNet.logistic_+3A_...">...</code></td>
<td>
<p>additional arguments (not currently used)</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>yhat</code></td>
<td>
<p>Matrix of predictions (probabilities), one row per observation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jacob Bien and Robert Tibshirani</p>


<h3>References</h3>

<p>Bien, J., Taylor, J., Tibshirani, R., (2013) &quot;A Lasso for Hierarchical Interactions.&quot; Annals of Statistics. 41(3). 1111-1141.</p>


<h3>See Also</h3>

<p><a href="#topic+hierNet.logistic">hierNet.logistic</a>, <a href="#topic+hierNet.logistic.path">hierNet.logistic.path</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12)
x=matrix(rnorm(100*10),ncol=10)
x=scale(x,TRUE,TRUE)
y=x[,1]+2*x[,2]+ x[,1]*x[,2]+3*rnorm(100)
y=1*(y&gt;0)
newx=matrix(rnorm(100*10),ncol=10)
fit=hierNet.logistic(x,y,lam=5)
yhat=predict(fit,newx)

fit=hierNet.logistic.path(x,y)
yhat=predict(fit,newx)
</code></pre>

<hr>
<h2 id='predict.hierNet.path'>Prediction function for hierNet.path and hierNet.logistic.path.</h2><span id='topic+predict.hierNet.path'></span>

<h3>Description</h3>

<p>A function to perform prediction, using an x matrix and the output of
the &quot;hierNet.path&quot; or &quot;hiernet.logistic.path&quot; functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hierNet.path'
predict(object, newx, newzz=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.hierNet.path_+3A_object">object</code></td>
<td>
<p>The results of a call to the &quot;hierNet&quot; or &quot;hierNet.path&quot; or
function. The
coefficients that are part of this object will be used for
making predictions.</p>
</td></tr>
<tr><td><code id="predict.hierNet.path_+3A_newx">newx</code></td>
<td>
<p>The new x at which predictions should be made. Can be a
vector 
or a matrix  (one obseration per row).</p>
</td></tr>
<tr><td><code id="predict.hierNet.path_+3A_newzz">newzz</code></td>
<td>
<p>Optional matrix of products of columns of newx, computed by compute.interactions.c</p>
</td></tr>
<tr><td><code id="predict.hierNet.path_+3A_...">...</code></td>
<td>
<p>additional arguments (not currently used)</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>yhat</code></td>
<td>
<p>Matrix of predictions, one row per observation. For logistic model, these are the
estimated probabilities.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jacob Bien and Robert Tibshirani</p>


<h3>References</h3>

<p>Bien, J., Taylor, J., Tibshirani, R., (2013) &quot;A Lasso for Hierarchical Interactions.&quot; Annals of Statistics. 41(3). 1111-1141.</p>


<h3>See Also</h3>

<p><a href="#topic+hierNet">hierNet</a>, <a href="#topic+hierNet.path">hierNet.path</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12)
x=matrix(rnorm(100*10),ncol=10)
x=scale(x,TRUE,TRUE)
y=x[,1]+2*x[,2]+ x[,1]*x[,2]+3*rnorm(100)
newx=matrix(rnorm(100*10),ncol=10)
fit=hierNet(x,y,lam=50)
yhat=predict(fit,newx)

fit=hierNet.path(x,y)
yhat=predict(fit,newx)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
