<!DOCTYPE html><html lang="en"><head><title>Help for package hoardeR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hoardeR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hoardeR-package'>
<p>Collect and Retrieve Annotation Data for Various Genomic Data Using Different Web Services.</p></a></li>
<li><a href='#blastSeq'>
<p>Sending Genomic Sequences to NCBI Blast service</p></a></li>
<li><a href='#coverageDensity'>
<p>Calculation of the coverage density</p></a></li>
<li><a href='#findSpecies'>
<p>Search in the <code>species</code>' Object.</p></a></li>
<li><a href='#getAnnotation'>
<p>Downloading or Importing of Annotation Data</p></a></li>
<li><a href='#getEnsgInfo'>
<p>Retrieve Gene Information From the NCBI Database.</p></a></li>
<li><a href='#getFastaFromBed'>
<p>Get fasta information based on locations in bed-format</p></a></li>
<li><a href='#getGeneLocation'>
<p>Extracting Gene Locations</p></a></li>
<li><a href='#getGeneSeq'>
<p>Extracting a gene sequence from NCBI database.</p></a></li>
<li><a href='#getSequenceFromNCBI'>
<p>Extracts a sequence from the NCBI webpage</p></a></li>
<li><a href='#intersectXMLAnnot'>
<p>Intersect XML object with annotation object</p></a></li>
<li><a href='#plotCoverage'>
<p>Plots a coverage density object</p></a></li>
<li><a href='#plotHit'>
<p>Visualization of a cross-species hit</p></a></li>
<li><a href='#print.fa'><p>Print an fa Object</p></a></li>
<li><a href='#species'><p>Available species at NCBI</p></a></li>
<li><a href='#subDose'>
<p>Rewrite the Dose File from a Beagle Output</p></a></li>
<li><a href='#subGprobs'>
<p>Rewrite the Gprobs File from a Beagle Output</p></a></li>
<li><a href='#subPhased'>
<p>Rewrite the Phased File from a Beagle Output</p></a></li>
<li><a href='#summary.fa'><p>Summarize an fa Object</p></a></li>
<li><a href='#tableSpecies'>
<p>Tables the species in xml file</p></a></li>
<li><a href='#targetScan'>
<p>Retrieving miRNA target information from targetscan.org</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Collect and Retrieve Annotation Data for Various Genomic Data
Using Different Webservices</td>
</tr>
<tr>
<td>Version:</td>
<td>0.10</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-08</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Fischer [aut, cre],
  Anu Sironen [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Fischer &lt;daniel.fischer@luke.fi&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>bamsignals (&ge; 1.10.0), Biostrings (&ge; 2.46.0), data.table (&ge;
1.11.4), GenomicRanges (&ge; 1.30.3), GenomicTools.fileHandler
(&ge; 0.1.4), httr (&ge; 1.3.1), IRanges (&ge; 2.12.0), KernSmooth
(&ge; 2.23-15), knitr (&ge; 1.20), MASS (&ge; 7.3-31), R.utils (&ge;
2.6.0), RCurl (&ge; 1.95), rmarkdown (&ge; 1.10), Rsamtools (&ge;
1.30.0), S4Vectors (&ge; 0.16.0), seqinr (&ge; 1.0-2), stringr (&ge;
1.3.1), XML (&ge; 3.98-1.1)</td>
</tr>
<tr>
<td>Description:</td>
<td>Cross-species identification of novel gene candidates using the NCBI web service is provided. Further, sets of miRNA target genes can be identified by using the targetscan.org API.</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-08 10:04:43 UTC; ejo138</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-08 10:32:59 UTC</td>
</tr>
</table>
<hr>
<h2 id='hoardeR-package'>
Collect and Retrieve Annotation Data for Various Genomic Data Using Different Web Services.
</h2><span id='topic+hoardeR-package'></span>

<h3>Description</h3>

<p>The hoardeR package is designed for collecting, retrieving and transforming data
from various sources. The current main focus is on setting up a connection to
the NCBI Blast service. Also, the gene information for Ensembl Genes can
be retrieved from NCBI.
Methods for visualizing the results are also provided. The latest
developer version of the package can be downloaded from
</p>
<p>https://github.com/fischuu/hoardeR
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
    Package: </td><td style="text-align: left;"> hoardeR</td>
</tr>
<tr>
 <td style="text-align: left;">
    Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
    Version: </td><td style="text-align: left;"> 0.10</td>
</tr>
<tr>
 <td style="text-align: left;">
    Date: </td><td style="text-align: left;"> 2024-04-08</td>
</tr>
<tr>
 <td style="text-align: left;">
    License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;">
    LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Daniel Fischer, Anu Sironen
</p>
<p>Maintainer: Daniel Fischer &lt;daniel.fischer@luke.fi&gt;
</p>

<hr>
<h2 id='blastSeq'>
Sending Genomic Sequences to NCBI Blast service
</h2><span id='topic+blastSeq'></span>

<h3>Description</h3>

<p>This function sends genomic sequences to the NCBI Blast service.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  blastSeq(seq, n_blast=20, delay_req=10, delay_rid=60, email=NULL, 
           xmlFolder=NULL, logFolder=NULL, keepInMemory=FALSE,
           database="refseq_genomes", verbose=TRUE, createLog=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blastSeq_+3A_seq">seq</code></td>
<td>
<p>The fasta sequence that should be blasted (<code>String</code>).</p>
</td></tr>
<tr><td><code id="blastSeq_+3A_n_blast">n_blast</code></td>
<td>
<p>Amount of parallel blast requests, in case <code>seq</code> is a vector.</p>
</td></tr>
<tr><td><code id="blastSeq_+3A_delay_req">delay_req</code></td>
<td>
<p>Seconds between the single Blast requests.</p>
</td></tr>
<tr><td><code id="blastSeq_+3A_delay_rid">delay_rid</code></td>
<td>
<p>Seconds between the single result requests.</p>
</td></tr>
<tr><td><code id="blastSeq_+3A_email">email</code></td>
<td>
<p>User email, required information from NCBI (<code>String</code>).</p>
</td></tr>
<tr><td><code id="blastSeq_+3A_xmlfolder">xmlFolder</code></td>
<td>
<p>Path to the result folder.</p>
</td></tr>
<tr><td><code id="blastSeq_+3A_logfolder">logFolder</code></td>
<td>
<p>Path to the log folder.</p>
</td></tr>
<tr><td><code id="blastSeq_+3A_keepinmemory">keepInMemory</code></td>
<td>
<p>Logical, shall the results be kept in the memory.</p>
</td></tr>
<tr><td><code id="blastSeq_+3A_database">database</code></td>
<td>
<p>The NCBI database to use.</p>
</td></tr>
<tr><td><code id="blastSeq_+3A_verbose">verbose</code></td>
<td>
<p>Shall the program give extensive feedback.</p>
</td></tr>
<tr><td><code id="blastSeq_+3A_createlog">createLog</code></td>
<td>
<p>Create log files, needed for continuing a crashed program.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function sends fasta sequences to the NCBI blast service. The defaults for the delays are required by NCBI and must not be
smaller than the default values. Also, NCBI asks the user to provide an email address.
</p>
<p>The input <code>seq</code> can be a vector of strings. In that case the sequences are one after another processed. The option <code>n_blast</code>
sets then the upper threshold of how many blast requests are send to the NCBI Blast service at a time and kept running there parallel.
It is here in the users obligation not to misuse the service with too many parallel requests. 
</p>
<p>The <code>xmlFolder</code> parameter specifies the folder to where the XML results will be stored.  In case the folder does not exist, R will create it.
</p>
<p>In case the option <code>keepInMemory</code> is set to TRUE the Blast results will be kept in memory, otherwise they will
be just written to the HDD. Especially if many sequences are send to the blast service it is recommended to drop the result from the memory,
meaning to set the option <code>keepinMemory=FALSE</code>. The option <code>keepinMemory=TRUE</code> is currently still under development and should not be
used.
</p>
<p>If log files should be written (<code>createLog=TRUE</code>) a log path should be given in <code>logPath</code>. However, if a xmlPath is given and the
option <code>createLog=TRUE</code> is set, then the log folder will be automatically created in the parental folder of the <code>xmlFolder</code> and is
called <code>logs</code>.
</p>


<h3>Value</h3>

<p>An xml file that contains the the NCBI result.
</p>


<h3>Author(s)</h3>

<p>Daniel Fischer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
blastSeq("ACGTGCATCGACTAGCTACGACTACGACTATC", email="my.name@somewhere.com")

## End(Not run)
</code></pre>

<hr>
<h2 id='coverageDensity'>
Calculation of the coverage density
</h2><span id='topic+coverageDensity'></span>

<h3>Description</h3>

<p>Calculates the coverage density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  coverageDensity(folder, chr=c(1:22,"X","Y","MT"), chr.length=NULL,
                  posneg=FALSE, verbose=TRUE, use.sqrt=FALSE,
                  kernel.package="slideWindowSum",
                  step.size=50000, window.size=100000, bw=100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coverageDensity_+3A_folder">folder</code></td>
<td>
<p>folder with bam files</p>
</td></tr>
<tr><td><code id="coverageDensity_+3A_chr">chr</code></td>
<td>
<p>Chromosome names to be plotted.</p>
</td></tr>
<tr><td><code id="coverageDensity_+3A_chr.length">chr.length</code></td>
<td>
<p>Length of chromosome</p>
</td></tr>
<tr><td><code id="coverageDensity_+3A_posneg">posneg</code></td>
<td>
<p>Logical, plot pos and neg strand</p>
</td></tr>
<tr><td><code id="coverageDensity_+3A_verbose">verbose</code></td>
<td>
<p>Logical, verbose output</p>
</td></tr> 
<tr><td><code id="coverageDensity_+3A_use.sqrt">use.sqrt</code></td>
<td>
<p>Logical, apply sqrt transformation</p>
</td></tr>
<tr><td><code id="coverageDensity_+3A_kernel.package">kernel.package</code></td>
<td>
<p>Class of kernel smoother</p>
</td></tr> 
<tr><td><code id="coverageDensity_+3A_step.size">step.size</code></td>
<td>
<p>Step size in bases</p>
</td></tr>
<tr><td><code id="coverageDensity_+3A_window.size">window.size</code></td>
<td>
<p>Window size in bases</p>
</td></tr>
<tr><td><code id="coverageDensity_+3A_bw">bw</code></td>
<td>
<p>Bandwidth parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the coverage of bam-files
</p>


<h3>Author(s)</h3>

<p>Daniel Fischer
</p>

<hr>
<h2 id='findSpecies'>
Search in the <code>species</code>' Object.
</h2><span id='topic+findSpecies'></span>

<h3>Description</h3>

<p>This function output rows from the <code>species</code> object that contain a certain string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  findSpecies(string)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findSpecies_+3A_string">string</code></td>
<td>
<p>Search string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function output rows from the <code>species</code> object that contain a certain string. It uses the <code>grepl</code> function to 
identify the corresponding rows.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code>.
</p>


<h3>Author(s)</h3>

<p>Daniel Fischer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+species">species</a></code>, <code><a href="base.html#topic+grepl">grepl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>findSpecies("cattle")
</code></pre>

<hr>
<h2 id='getAnnotation'>
Downloading or Importing of Annotation Data
</h2><span id='topic+getAnnotation'></span>

<h3>Description</h3>

<p>This function downloads (if needed) the annotation file from a given species from NCBI and loads it into the namespace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  getAnnotation(species=NULL, assembly=NULL, annotationFolder=NULL, 
                type="gff3", verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getAnnotation_+3A_species">species</code></td>
<td>
<p>The scientific name of the species (<code>String</code>).</p>
</td></tr>
<tr><td><code id="getAnnotation_+3A_assembly">assembly</code></td>
<td>
<p>The NCBI assembly version.</p>
</td></tr>
<tr><td><code id="getAnnotation_+3A_annotationfolder">annotationFolder</code></td>
<td>
<p>The folder where the file will be stored.</p>
</td></tr>
<tr><td><code id="getAnnotation_+3A_type">type</code></td>
<td>
<p>The file extension/format of the annotation file.</p>
</td></tr>
<tr><td><code id="getAnnotation_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if function gives feedback.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> This function downloads for a given <code>species</code> the annotation file, as provided from NCBI. The main parameters basically define the URL, where the file is located. The file is then downloaded into the folder, provided in <code>annotationFolder</code> and then imported to the namespace.
</p>
<p>If a file has been downloaded previously, it will be loaded directly from that folder. In case the user wants to use an annotation that is not provided by NCBI, the corresponding files can also be placed into the same folder, following the naming scheme as suggested from the function and the function will load it from there.
</p>


<h3>Value</h3>

<p>A <code>data.table</code> with the annotation information.
</p>


<h3>Author(s)</h3>

<p>Daniel Fischer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
susScrofa &lt;- getAnnotation(species = "Sus scrofa", 
                           annotationFolder="/home/user/annotation")
                           
homoSapiens &lt;- getAnnotation(species = "Homo sapiens", 
                             annotationFolder="/home/user/annotation")

## End(Not run)
</code></pre>

<hr>
<h2 id='getEnsgInfo'>
Retrieve Gene Information From the NCBI Database.
</h2><span id='topic+getEnsgInfo'></span>

<h3>Description</h3>

<p>This function retrieves for a given Ensembl Number the corresponding information from the NCBI database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  getEnsgInfo(ensg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getEnsgInfo_+3A_ensg">ensg</code></td>
<td>
<p>Ensembl ID (<code>String</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function retrieves for a given Ensembl Number the corresponding information from the NCBI database. The 
object <code>ensg</code> can also be a vector of Ensembl IDs.
</p>


<h3>Value</h3>

<p>A matrix with information.
</p>


<h3>Author(s)</h3>

<p>Daniel Fischer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ensg &lt;- c("ENSG00000174482", "ENSG00000113494")
getEnsgInfo(ensg)

## End(Not run)
</code></pre>

<hr>
<h2 id='getFastaFromBed'>
Get fasta information based on locations in bed-format
</h2><span id='topic+getFastaFromBed'></span>

<h3>Description</h3>

<p>For a given fasta and a bed file this function can extract the nucleotide sequences and stores them as fasta file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  getFastaFromBed(bed, species=NULL, assembly = NULL, fastaFolder=NULL,
                  verbose=TRUE, export=NULL, fileName=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getFastaFromBed_+3A_bed">bed</code></td>
<td>
<p>The location in bed format, see details.</p>
</td></tr>
<tr><td><code id="getFastaFromBed_+3A_species">species</code></td>
<td>
<p>Define the species.</p>
</td></tr>
<tr><td><code id="getFastaFromBed_+3A_assembly">assembly</code></td>
<td>
<p>Assembly identifier.</p>
</td></tr>
<tr><td><code id="getFastaFromBed_+3A_fastafolder">fastaFolder</code></td>
<td>
<p>Location of the fasta files.</p>
</td></tr>
<tr><td><code id="getFastaFromBed_+3A_verbose">verbose</code></td>
<td>
<p>Logical, should informative status updates be given.</p>
</td></tr>
<tr><td><code id="getFastaFromBed_+3A_export">export</code></td>
<td>
<p>Foldername.</p>
</td></tr>
<tr><td><code id="getFastaFromBed_+3A_filename">fileName</code></td>
<td>
<p>Filename to store the FA object.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Function expects as an input a <code>data.frame</code> in bed format. This means, the first column should contain the chromosome, the second
the start-coordinates, the third the end-coordinates. The forth column contains the ID of the loci. 
</p>
<p>If a standard species is used (as defined in the <code>species</code> data frame), the function automatically downloads the required files
from NCBI, takes the loci and extracts then the nucleotide sequences from it. If the corresponding assemly is not available from NCBI
an own fasta file can be provided. For that the fa-file needs to be in the fastaFolder and follow the same naming system as the NCBI 
files are labelled. In that case, the function suggests the correct filename for an unknown assembly.
</p>
<p>The export function, specifies then a folder to where the fasta file should be stored. If no filename is provided, the filename is then
the object name passed to the <code>bed</code> function.
</p>


<h3>Value</h3>

<p>An <code>fa</code> object containing the nucleotide sequences in fasta format.
</p>


<h3>Author(s)</h3>

<p>Daniel Fischer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

myBed &lt;- data.frame(chr=c(1,2),
                    start=c(235265,12356742),
                    end=c(435265,12386742),
                    gene=c("LOC1", "LOC2"))

myFA &lt;- getFastaFromBed(myBed, species="Homo sapiens", fastaFolder="/home/user/fasta/", export=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='getGeneLocation'>
Extracting Gene Locations
</h2><span id='topic+getGeneLocation'></span>

<h3>Description</h3>

<p>This function extracts the gene locations from an imported gtf file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  getGeneLocation(gtf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getGeneLocation_+3A_gtf">gtf</code></td>
<td>
<p>An imported gtf object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts the information from an imported gtf object.
</p>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Author(s)</h3>

<p>Daniel Fischer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
getGeneLocation(gtf)

## End(Not run)
</code></pre>

<hr>
<h2 id='getGeneSeq'>
Extracting a gene sequence from NCBI database.
</h2><span id='topic+getGeneSeq'></span>

<h3>Description</h3>

<p>This function retrieves a gene sequence from the NCBI database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  getGeneSeq(chr, start, end, organism)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getGeneSeq_+3A_chr">chr</code></td>
<td>
<p>Chromosome number, numeric/string</p>
</td></tr>
<tr><td><code id="getGeneSeq_+3A_start">start</code></td>
<td>
<p>Start position, numeric</p>
</td></tr>
<tr><td><code id="getGeneSeq_+3A_end">end</code></td>
<td>
<p>End position, numeric</p>
</td></tr>
<tr><td><code id="getGeneSeq_+3A_organism">organism</code></td>
<td>
<p>Name of the organism, string</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extracting a gene sequence from NCBI database. For a list of available organism, visit
</p>
<p><a href="http://genome.ucsc.edu/cgi-bin/das/dsn">http://genome.ucsc.edu/cgi-bin/das/dsn</a>. All id=&quot;.&quot; field are available.
</p>


<h3>Value</h3>

<p>A string that contains the genomic sequence.
</p>


<h3>Author(s)</h3>

<p>Daniel Fischer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Extracting for Sus Scrofa, build version 3:
getGeneSeq(1,2134,14532,"susScr3")
getGeneSeq(10,1233312,1233350,"hg38")

## End(Not run)
</code></pre>

<hr>
<h2 id='getSequenceFromNCBI'>
Extracts a sequence from the NCBI webpage
</h2><span id='topic+getSequenceFromNCBI'></span>

<h3>Description</h3>

<p>Retrieve a sequence from the NCBI webpage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  getSequenceFromNCBI(id, file=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSequenceFromNCBI_+3A_id">id</code></td>
<td>
<p>The gene identifier</p>
</td></tr>
<tr><td><code id="getSequenceFromNCBI_+3A_file">file</code></td>
<td>
<p>File name to where the sequence shall be stored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts the sequence for a given identifer and then stores, if requested the sequence to the HDD.
</p>


<h3>Author(s)</h3>

<p>Daniel Fischer
</p>

<hr>
<h2 id='intersectXMLAnnot'>
Intersect XML object with annotation object
</h2><span id='topic+intersectXMLAnnot'></span>

<h3>Description</h3>

<p>For a annotation object this function intersects the loci of it with the output of the tableSpecies function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  intersectXMLAnnot(tabSpecies, annot, level="gene", flanking=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intersectXMLAnnot_+3A_tabspecies">tabSpecies</code></td>
<td>
<p>The table with locations from <code>tableSpecies</code>.</p>
</td></tr>
<tr><td><code id="intersectXMLAnnot_+3A_annot">annot</code></td>
<td>
<p>The annotation object.</p>
</td></tr>
<tr><td><code id="intersectXMLAnnot_+3A_level">level</code></td>
<td>
<p>The level of intersection.</p>
</td></tr>
<tr><td><code id="intersectXMLAnnot_+3A_flanking">flanking</code></td>
<td>
<p>Allowed flanking space for intersection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function expects as an input table from <code>tableSpecies</code> with the option <code>locations=TRUE</code>. Further, it needs an annotation object,
as provided by the <code>getAnnotation</code> function. With that it intersects then the loci on the level as specified in <code>level</code>. Currently
only <code>"gene"</code> is supported. 
</p>
<p>The <code>flanking</code> option allows for flanking space up- and down-stream of the genes. This is especially then useful if the novel gene
candidates are in the extension of known genes (e.g. responsible for regulation or if they are novel exons.)
</p>


<h3>Value</h3>

<p>A table with intersection loci.
</p>


<h3>Author(s)</h3>

<p>Daniel Fischer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

pigHits &lt;- tableSpecies(xmls, species="Sus scrofa", locations = TRUE)
ssannot &lt;- getAnnotation(species = "Sus scrofa", annotationFolder="/home/user/annotation")
pigInter &lt;- list()
for(i in 1:nrow(pigHits)){
   pigInter[[i]] &lt;- intersectXMLAnnot(pigHits[i,], ssannot)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='plotCoverage'>
Plots a coverage density object
</h2><span id='topic+plotCoverage'></span>

<h3>Description</h3>

<p>Plots a coverage density object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  plotCoverage(x, use.sqrt=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotCoverage_+3A_x">x</code></td>
<td>
<p>A coverage density object</p>
</td></tr>
<tr><td><code id="plotCoverage_+3A_use.sqrt">use.sqrt</code></td>
<td>
<p>Logical, use sqrt scale?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots the coverage of bam-files
</p>


<h3>Author(s)</h3>

<p>Daniel Fischer
</p>

<hr>
<h2 id='plotHit'>
Visualization of a cross-species hit
</h2><span id='topic+plotHit'></span>

<h3>Description</h3>

<p>For each cross-species hit the function plots the similarity within that area together with an optional annotation and coverage track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  plotHit(hits, flanking=1, window=NULL, annot=TRUE, coverage=FALSE,
          smoothPara=NULL, diagonal=0.25, verbose=TRUE, output=FALSE,
          hitSpecies=NULL, hitSpeciesAssembly=NULL, origSpecies=NULL,
          origSpeciesAssembly=NULL, fastaFolder=NULL, origAnnot=NULL,
          hitAnnot=NULL, nTick=5, which=NULL, figureFolder=NULL,
          figurePrefix=NULL, indexOffset=0, bamFolder=NULL, bamFiles=NULL,
          groupIndex=NULL, groupColor=NULL, countWindow=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotHit_+3A_hits">hits</code></td>
<td>
<p>The hit object to be plotted.</p>
</td></tr>
<tr><td><code id="plotHit_+3A_flanking">flanking</code></td>
<td>
<p>Allowed flanking site in Mb.</p>
</td></tr>
<tr><td><code id="plotHit_+3A_window">window</code></td>
<td>
<p>Moving window size of similarity measure.</p>
</td></tr>
<tr><td><code id="plotHit_+3A_annot">annot</code></td>
<td>
<p>Logical, add annotation track</p>
</td></tr>
<tr><td><code id="plotHit_+3A_coverage">coverage</code></td>
<td>
<p>Logical, add coverage track</p>
</td></tr> 
<tr><td><code id="plotHit_+3A_smoothpara">smoothPara</code></td>
<td>
<p>Smoothing parameter for coverage</p>
</td></tr>
<tr><td><code id="plotHit_+3A_diagonal">diagonal</code></td>
<td>
<p>Threshold for allowed diagonal similarity</p>
</td></tr> 
<tr><td><code id="plotHit_+3A_verbose">verbose</code></td>
<td>
<p>Logical, shall the function give status updates</p>
</td></tr>
<tr><td><code id="plotHit_+3A_output">output</code></td>
<td>
<p>Logical, shall numerical results be given</p>
</td></tr>
<tr><td><code id="plotHit_+3A_hitspecies">hitSpecies</code></td>
<td>
<p>Scientific identifier of the hit species.</p>
</td></tr>
<tr><td><code id="plotHit_+3A_hitspeciesassembly">hitSpeciesAssembly</code></td>
<td>
<p>Version of the hit species assembly</p>
</td></tr> 
<tr><td><code id="plotHit_+3A_origspecies">origSpecies</code></td>
<td>
<p>Scientific name of the original species</p>
</td></tr>
<tr><td><code id="plotHit_+3A_origspeciesassembly">origSpeciesAssembly</code></td>
<td>
<p>Version of the original species</p>
</td></tr> 
<tr><td><code id="plotHit_+3A_fastafolder">fastaFolder</code></td>
<td>
<p>Location of the fasta files</p>
</td></tr>
<tr><td><code id="plotHit_+3A_origannot">origAnnot</code></td>
<td>
<p>Annotation object of the original species</p>
</td></tr>
<tr><td><code id="plotHit_+3A_hitannot">hitAnnot</code></td>
<td>
<p>Annotation object of the hit species</p>
</td></tr> 
<tr><td><code id="plotHit_+3A_ntick">nTick</code></td>
<td>
<p>Number of ticks on the annotation track</p>
</td></tr>
<tr><td><code id="plotHit_+3A_which">which</code></td>
<td>
<p>Which hits should be plotted</p>
</td></tr>
<tr><td><code id="plotHit_+3A_figurefolder">figureFolder</code></td>
<td>
<p>Folder where Figures should be stored</p>
</td></tr>
<tr><td><code id="plotHit_+3A_figureprefix">figurePrefix</code></td>
<td>
<p>Prefix of the figure filenames</p>
</td></tr>
<tr><td><code id="plotHit_+3A_indexoffset">indexOffset</code></td>
<td>
<p>Offset of the running index of the filenames</p>
</td></tr>
<tr><td><code id="plotHit_+3A_bamfolder">bamFolder</code></td>
<td>
<p>Folder with the bam-files</p>
</td></tr>
<tr><td><code id="plotHit_+3A_bamfiles">bamFiles</code></td>
<td>
<p>Filenames of the bam-files</p>
</td></tr>
<tr><td><code id="plotHit_+3A_groupindex">groupIndex</code></td>
<td>
<p>Index of subgroups in the bamfiles</p>
</td></tr>
<tr><td><code id="plotHit_+3A_groupcolor">groupColor</code></td>
<td>
<p>Vector with colors, one for each subgroup</p>
</td></tr>
<tr><td><code id="plotHit_+3A_countwindow">countWindow</code></td>
<td>
<p>Window size to count the reads from bam-files.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the workhorse of hoardeR and visualizes the findings of the blast and intersection runs. It is really flexibel to handle the hits and  
hence there are many different options. The required options are <code>hits</code>, <code>hitSpecies</code>, <code>origSpecies</code> and <code>fastaFolder</code>.
</p>
<p>The hit object is an object as provided by <code>intersectXMLAnnot</code> and contains all intersections of interest (=intersections that are in close
proximity of a gene in the hit species). Naturally the hit and the original species have to be specified as well as the folder, where the required fasta
files are stored, or to where they should  be downloaded. If the species are the default species from Ensembl (as can be seen in the data.frame
<code>species</code>), the annotation and assembly will be automatically downloaded to the specified location on the harddrive. Changes from that
version can be adjusted with the the <code>hitSpeciesAssembly</code> and <code>origSpeciesAssembly</code> options, but the filenames have still to match the convention, as they
are provided by NCBI. 
</p>
<p>If in  addition to the similarity also a coverage track should be added, the option <code>coverage</code> has to be set to <code>TRUE</code>. The option 
<code>smoothPara</code> sets then the level of smoothing of the coverage. By default no smoothing will be applied. 
</p>
<p>In case an annotation track is requested (<code>annot=TRUE</code>), the annotation objects need to be provided to the <code>origAnnot</code> and <code>hitAnnot</code> options.
</p>
<p>The option <code>diagonal</code> defines the minimum level of similarity so that a (diagonal) match will be plotted. The colors are then towards green for
total similarity and towards red for total disagree, based on a nucleotide mismatch matrix.
</p>
<p>If the option <code>verbose=TRUE</code> is set, the function gives a verbose output while running. Further, if <code>output=TRUE</code> then, in addition to the
figure also a data.frame with the numerical results is provided. 
</p>
<p>In case that <code>hits</code> contains more than one hit, the <code>plotHit</code> function plots for each hit a figure. In that case a folder should be
provided to where the figures should be stored, this can be done with the <code>figureFolder</code> and <code>figurePrefix</code> options. In case only
asserted hits of <code>hits</code> shall be plotted, they can be selected with the <code>which</code> option.
</p>
<p>The function can also plot a coverage track over the similarity. For that, the option <code>coverage=TRUE</code> has to be set and a folder that 
contains the necessary bam-files has to be specified in <code>bamFolder</code>. By default all bam files in that folder are used, if only a subset
is requested, the filenames can be specified in <code>bamFiles</code>. In case several bam-files are given, the average coverage at each loci is used.
Further, if the data contains subgroups (e.g. case/control), the vector <code>groupIndex</code> gives the group labels. Naturally its length should be
similar to <code>bamFiles</code> (or similar to the total amount of files in the bam-folder). In case that more than one group is plotted in the
coverage track, their colors can be defined in <code>groupColor</code>. Of course, this vector has to be as long as the number of groups are defined. 
The option <code>countWindow</code> controls the moving window length in which the number of counts is calculated. The default is the same length as the
hit.
</p>


<h3>Value</h3>

<p>Optional, a table with intersection loci.
</p>


<h3>Author(s)</h3>

<p>Daniel Fischer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pigInter.flank &lt;- list()
for(i in 1:nrow(pigHits)){
   pigInter.flank[[i]] &lt;- intersectXMLAnnot(pigHits[i,], ssannot, flanking=100)
}
# Basic usage:
plotHit(hits=pigInter.flank,
        flanking=100,
        hitSpecies = "Sus scrofa",
        origSpecies = "Bos taurus",
        fastaFolder = "/home/user/fasta/",
        figureFolder = "/home/user/figures/") 

# Annotation tracks added:
plotHit(hits=pigInter.flank,
        flanking=100,
        hitSpecies = "Sus scrofa",
        origSpecies = "Bos taurus",
        fastaFolder = "/home/user/fasta/",
        figureFolder = "/home/user/figures/",
        origAnnot=btannot,
        hitAnnot=ssannot)
        
# Annotation and coverage added:
plotHit(hits=pigInter.flank,
        flanking=100,
        hitSpecies = "Sus scrofa",
        origSpecies = "Bos taurus",
        fastaFolder = "/home/daniel/fasta/",
        figureFolder = "/home/user/figures/",
        origAnnot=btannot,
        hitAnnot=ssannot
        coverage=TRUE,
        bamFolder = "/home/users/bams/") 

## End(Not run)
</code></pre>

<hr>
<h2 id='print.fa'>Print an fa Object</h2><span id='topic+print+2Cfa-method'></span><span id='topic+print.fa'></span>

<h3>Description</h3>

<p>Prints an <code>fa</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'fa'
print(x, n=2, seq.out=50, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.fa_+3A_x">x</code></td>
<td>
<p>Object of class <code>fa</code>.</p>
</td></tr>
<tr><td><code id="print.fa_+3A_n">n</code></td>
<td>
<p>Amount of elements to be displayed, numeric.</p>
</td></tr>
<tr><td><code id="print.fa_+3A_seq.out">seq.out</code></td>
<td>
<p>Length of each element to be displayed, numeric..</p>
</td></tr>  
<tr><td><code id="print.fa_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The print function displays an <code>fa</code> object. By default just the first two elements with their first 50 bases are
displayed. To display the full sequence, set <code>seq.out=NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Daniel Fischer</p>

<hr>
<h2 id='species'>Available species at NCBI</h2><span id='topic+species'></span>

<h3>Description</h3>

<p>This is a list of all organisms/species that are provided by NCBI and hence could end up in the Blast run. Further, it defines the default versions of
the assuemblies that will be downloaded if no further version is specified in <code>plotHit</code>, <code>getAnnotation</code> or <code>getFastaFromBed</code>.
</p>


<h3>Format</h3>

<p>A data frame with 348 species.</p>


<h3>Source</h3>

<p>As downloaded on 05.10.2016 from
</p>
<p>ftp://ftp.ncbi.nlm.nih.gov/genomes/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(species)
summary(species) 

</code></pre>

<hr>
<h2 id='subDose'>
Rewrite the Dose File from a Beagle Output
</h2><span id='topic+subDose'></span>

<h3>Description</h3>

<p>This function takes a Dose Beagle output and rewrites the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  subDose(file=NULL, vmmk=NULL, out=NULL, removeInsertions=TRUE, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subDose_+3A_file">file</code></td>
<td>
<p>Location of the original Beagle file (<code>String</code>).</p>
</td></tr>
<tr><td><code id="subDose_+3A_vmmk">vmmk</code></td>
<td>
<p>Location of the Variant Map Master key (<code>String</code>).</p>
</td></tr>
<tr><td><code id="subDose_+3A_out">out</code></td>
<td>
<p>Name and location of the output file (<code>String</code>).</p>
</td></tr>
<tr><td><code id="subDose_+3A_verbose">verbose</code></td>
<td>
<p>The function gives feedback.</p>
</td></tr>
<tr><td><code id="subDose_+3A_removeinsertions">removeInsertions</code></td>
<td>
<p>All Indels will be removed..</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a Beagle Dose file and rewrites the alleles from numerical to character, based
on the information provided in a variant map master key. 
</p>


<h3>Value</h3>

<p>A rewritten beagle phased file.
</p>


<h3>Author(s)</h3>

<p>Daniel Fischer
</p>

<hr>
<h2 id='subGprobs'>
Rewrite the Gprobs File from a Beagle Output
</h2><span id='topic+subGprobs'></span>

<h3>Description</h3>

<p>This function takes a Gprobs Beagle output and rewrites the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  subGprobs(file=NULL, vmmk=NULL, out=NULL, chunkSize=100000, removeInsertions=TRUE,
             verbose = TRUE, writeOut=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subGprobs_+3A_file">file</code></td>
<td>
<p>Location of the original Beagle file (<code>String</code>).</p>
</td></tr>
<tr><td><code id="subGprobs_+3A_vmmk">vmmk</code></td>
<td>
<p>Location of the Variant Map Master key (<code>String</code>).</p>
</td></tr>
<tr><td><code id="subGprobs_+3A_out">out</code></td>
<td>
<p>Name and location of the output file (<code>String</code>).</p>
</td></tr>
<tr><td><code id="subGprobs_+3A_chunksize">chunkSize</code></td>
<td>
<p>For large Beagle files, the chunk size.</p>
</td></tr>
<tr><td><code id="subGprobs_+3A_removeinsertions">removeInsertions</code></td>
<td>
<p>All Indels will be removed.</p>
</td></tr>
<tr><td><code id="subGprobs_+3A_verbose">verbose</code></td>
<td>
<p>The function gives feedback.</p>
</td></tr>
<tr><td><code id="subGprobs_+3A_writeout">writeOut</code></td>
<td>
<p>Logical, write the output back to the HDD.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a Beagle Gprobs file and rewrites the alleles from numerical to character, based
on the information provided in a variant map master key. 
For larger files the function can process
the rewriting in chunks in order to save memory.
</p>


<h3>Value</h3>

<p>A rewritten beagle Gprobs file.
</p>


<h3>Author(s)</h3>

<p>Daniel Fischer
</p>

<hr>
<h2 id='subPhased'>
Rewrite the Phased File from a Beagle Output
</h2><span id='topic+subPhased'></span>

<h3>Description</h3>

<p>This function takes a phased Beagle output and rewrites the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  subPhased(file=NULL, vmmk = NULL, out=NULL, chunkSize=100000, verbose=TRUE,
            removeInsertions=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subPhased_+3A_file">file</code></td>
<td>
<p>Location of the original Beagle file (<code>String</code>).</p>
</td></tr>
<tr><td><code id="subPhased_+3A_vmmk">vmmk</code></td>
<td>
<p>Location of the Variant Map Master key (<code>String</code>).</p>
</td></tr>
<tr><td><code id="subPhased_+3A_out">out</code></td>
<td>
<p>Name and location of the output file (<code>String</code>).</p>
</td></tr>
<tr><td><code id="subPhased_+3A_chunksize">chunkSize</code></td>
<td>
<p>For large Beagle files, the chunk size.</p>
</td></tr>
<tr><td><code id="subPhased_+3A_verbose">verbose</code></td>
<td>
<p>The function gives feedback.</p>
</td></tr>
<tr><td><code id="subPhased_+3A_removeinsertions">removeInsertions</code></td>
<td>
<p>All Indels will be removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a Beagle phased file and rewrites the alleles from numerical to character, based
on the information provided in a variant map master key. For larger files the function can process
the rewriting in chunks in order to save memory.
</p>


<h3>Value</h3>

<p>A rewritten beagle phased file.
</p>


<h3>Author(s)</h3>

<p>Daniel Fischer
</p>

<hr>
<h2 id='summary.fa'>Summarize an fa Object</h2><span id='topic+summary.fa'></span><span id='topic+summary+2Cfa-method'></span>

<h3>Description</h3>

<p>Summarizes and prints an <code>fa</code> object in an informative way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'fa'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.fa_+3A_object">object</code></td>
<td>
<p>Object of class <code>fa</code>.</p>
</td></tr>
<tr><td><code id="summary.fa_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summary for a <code>fa</code> object, providing the amount of sequences, the minimum and maximum length as well as the
average length.
</p>


<h3>Author(s)</h3>

<p>Daniel Fischer</p>

<hr>
<h2 id='tableSpecies'>
Tables the species in xml file
</h2><span id='topic+tableSpecies'></span>

<h3>Description</h3>

<p>Tables the species in xml file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  tableSpecies(xml, species=NULL, type="chr", minOutput=TRUE, exclude="",
               locations=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tableSpecies_+3A_xml">xml</code></td>
<td>
<p>The xml file.</p>
</td></tr>
<tr><td><code id="tableSpecies_+3A_species">species</code></td>
<td>
<p>Restrict species to a certain set.</p>
</td></tr>
<tr><td><code id="tableSpecies_+3A_type">type</code></td>
<td>
<p>Filter option.</p>
</td></tr>
<tr><td><code id="tableSpecies_+3A_minoutput">minOutput</code></td>
<td>
<p>Logical, should the output be minimal.</p>
</td></tr>
<tr><td><code id="tableSpecies_+3A_exclude">exclude</code></td>
<td>
<p>Names of species to exclude.</p>
</td></tr>
<tr><td><code id="tableSpecies_+3A_locations">locations</code></td>
<td>
<p>Logical, shall the hit locations be given as well.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function provides a table of identified species. This table can e.g. be put into the <code>barplot</code> function to visualize the findings.
</p>
<p>Further, if the option <code>locations</code> is set to <code>TRUE</code> the function not only tables the species, but also the individual locations
of the hits. This output is required for the further steps. Hence, this function plays a important role in the identification pipeline.
</p>
<p>Be default the option <code>type="chr"</code> is set so that only hits in species will full genomes will be reported. Further, the species names
are intersected with the <code>species</code> data frame and only those that appear there are reported.
</p>


<h3>Value</h3>

<p>A <code>table</code> with the species from the XML file
</p>


<h3>Author(s)</h3>

<p>Daniel Fischer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tableSpecies(xmls)
pigHits &lt;- tableSpecies(xmls, species="Sus scrofa", locations = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='targetScan'>
Retrieving miRNA target information from targetscan.org
</h2><span id='topic+targetScan'></span>

<h3>Description</h3>

<p>This function requests from the webpage targetscan.org the stored information for mirnas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   targetScan(mirna=NULL, species=NULL, release="7.1", maxOut=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="targetScan_+3A_mirna">mirna</code></td>
<td>
<p>The name of the mirna (<code>String</code>).</p>
</td></tr>
<tr><td><code id="targetScan_+3A_species">species</code></td>
<td>
<p>The species identifier, see details (<code>String</code>).</p>
</td></tr>
<tr><td><code id="targetScan_+3A_release">release</code></td>
<td>
<p>The release version of targetscan.org.</p>
</td></tr>
<tr><td><code id="targetScan_+3A_maxout">maxOut</code></td>
<td>
<p>The amount of target genes, default (<code>NULL</code>) is all.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function sends a miRNA name to the targetscan.org webpage, retrieves the information and gives it back as a data.frame.
Options for <code>species</code> are <code>"Human", "Mouse", "Rat", "Chimpanzee",</code> <code>"Rhesus", "Cow", "Dog", "Opossum", "Chicken", "Frog"</code>.
</p>


<h3>Value</h3>

<p>A data.frame with the following columns
</p>
<table role = "presentation">
<tr><td><code>Ortholog</code></td>
<td>
<p>The ortholog name of the target gene.</p>
</td></tr>
<tr><td><code>geneName</code></td>
<td>
<p>The long description of the target gene.</p>
</td></tr>
<tr><td><code>consSites</code></td>
<td>
<p>The total number of conserved sites.</p>
</td></tr>
<tr><td><code>poorlySites</code></td>
<td>
<p>The total number of poorly conserved sites.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Fischer
</p>


<h3>References</h3>

<p><cite>V. Agarwal, G. Bell, J.Nam, et al. (2015): Predicting effective microRNA target sites in mammalian mRNAs. eLife, 4, pages 1-38, doi: 10.7554/eLife.05005</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
targetScan(mirna="miR-9-5p", species="Cow", maxOut=5)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
