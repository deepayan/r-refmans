<!DOCTYPE html><html lang="en"><head><title>Help for package ageutils</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ageutils}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ageutils-package'><p>ageutils: Collection of Functions for Working with Age Intervals</p></a></li>
<li><a href='#ageutils-defunct'><p>Defunct functions</p></a></li>
<li><a href='#breaks_to_interval'><p>Convert breaks to an interval</p></a></li>
<li><a href='#cut_ages'><p>Cut integer age vectors</p></a></li>
<li><a href='#pop_dat'><p>Aggregated population data</p></a></li>
<li><a href='#reaggregate_counts'><p>Reaggregate age counts</p></a></li>
<li><a href='#reaggregate_rates'><p>Reaggregate age rates</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Collection of Functions for Working with Age Intervals</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.8</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a collection of efficient functions for working with
  individual ages and corresponding intervals. These include functions for
  conversion from an age to an interval, aggregation of ages with associated
  counts in to intervals and the splitting of interval counts based on
  specified age distributions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://timtaylor.github.io/ageutils/">https://timtaylor.github.io/ageutils/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/TimTaylor/ageutils/issues">https://github.com/TimTaylor/ageutils/issues</a></td>
</tr>
<tr>
<td>Config/build/compilation-database:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang, stats, tibble,</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-13 09:20:29 UTC; tim</td>
</tr>
<tr>
<td>Author:</td>
<td>Tim Taylor <a href="https://orcid.org/0000-0002-8587-7113"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph],
  Edwin van Leeuwen <a href="https://orcid.org/0000-0002-2383-5305"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tim Taylor &lt;tim.taylor@hiddenelephants.co.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-13 09:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ageutils-package'>ageutils: Collection of Functions for Working with Age Intervals</h2><span id='topic+ageutils'></span><span id='topic+ageutils-package'></span>

<h3>Description</h3>

<p>Provides a collection of efficient functions for working with individual ages and corresponding intervals. These include functions for conversion from an age to an interval, aggregation of ages with associated counts in to intervals and the splitting of interval counts based on specified age distributions.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Tim Taylor <a href="mailto:tim.taylor@hiddenelephants.co.uk">tim.taylor@hiddenelephants.co.uk</a> (<a href="https://orcid.org/0000-0002-8587-7113">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Edwin van Leeuwen <a href="mailto:edwinvanl@gmail.com">edwinvanl@gmail.com</a> (<a href="https://orcid.org/0000-0002-2383-5305">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://timtaylor.github.io/ageutils/">https://timtaylor.github.io/ageutils/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/TimTaylor/ageutils/issues">https://github.com/TimTaylor/ageutils/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ageutils-defunct'>Defunct functions</h2><span id='topic+ageutils-defunct'></span><span id='topic+reaggregate_interval_rates'></span><span id='topic+reaggregate_interval_counts'></span><span id='topic+split_interval_counts'></span><span id='topic+aggregate_age_counts'></span>

<h3>Description</h3>

<p>Functions removed from ageutils in the 0.0.8 release. They have been replaced
with stubs that will error and report them as defunct.
</p>

<ul>
<li> <p><code>reaggregate_interval_rates()</code> (best replaced by <code>reaggregate_rates()</code>),
</p>
</li>
<li> <p><code>reaggregate_interval_counts()</code> (best replaced by <code>reaggregate_counts()</code>),
</p>
</li>
<li> <p><code>split_interval_counts()</code>, and
</p>
</li>
<li> <p><code>aggregate_age_counts()</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>reaggregate_interval_rates(
  lower_bounds,
  upper_bounds = NULL,
  rates,
  breaks,
  weights = NULL
)

reaggregate_interval_counts(
  lower_bounds,
  upper_bounds,
  counts,
  breaks,
  max_upper = 100L,
  weights = NULL
)

split_interval_counts(
  lower_bounds,
  upper_bounds,
  counts,
  max_upper = 100L,
  weights = NULL
)

aggregate_age_counts(counts, ages = seq_along(counts) - 1L, breaks)
</code></pre>

<hr>
<h2 id='breaks_to_interval'>Convert breaks to an interval</h2><span id='topic+breaks_to_interval'></span>

<h3>Description</h3>

<p><code>breaks_to_interval()</code> takes a specified set of breaks representing the left
hand limits of a closed open interval, i.e [x, y), and returns the
corresponding interval and upper bounds. The resulting intervals span from
the minimum break through to a specified <code>max_upper</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>breaks_to_interval(breaks, max_upper = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="breaks_to_interval_+3A_breaks">breaks</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integerish]&#8288;</code>.
</p>
<p>1 or more non-negative cut points in increasing (strictly) order.
</p>
<p>These correspond to the left hand side of the desired intervals (e.g. the
closed side of [x, y).
</p>
<p>Double values are coerced to integer prior to categorisation.</p>
</td></tr>
<tr><td><code id="breaks_to_interval_+3A_max_upper">max_upper</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>
</p>
<p>Represents the maximum upper bound splitting the data.
</p>
<p>Defaults to <code>Inf</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tbl_df-class">tibble</a> with an ordered factor column (<code>interval</code>),
as well as columns corresponding to the explicit bounds (<code>lower_bound</code> and
<code>upper_bound</code>). Note that even those these bounds are whole numbers they are
returned as <code>numeric</code> to allow the maximum upper bound to be given as <code>Inf</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
breaks_to_interval(breaks = c(0, 1, 5, 15, 25, 45, 65))
breaks_to_interval(
    breaks = c(0, 1, 5, 15, 25, 45, 65),
    max_upper = 100
)

</code></pre>

<hr>
<h2 id='cut_ages'>Cut integer age vectors</h2><span id='topic+cut_ages'></span>

<h3>Description</h3>

<p><code>cut_ages()</code> provides categorisation of ages based on specified breaks
which represent the left-hand interval limits. The resulting intervals span
from the minimum break through to a specified <code>max_upper</code> and will always be
closed on the left and open on the right. Ages below the minimum break, or
above <code>max_upper</code> will be returned as NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_ages(ages, breaks, max_upper = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cut_ages_+3A_ages">ages</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>.
</p>
<p>Vector of age values.
</p>
<p>Double values are coerced to integer prior to categorisation / aggregation.
</p>
<p>Must not be NA.</p>
</td></tr>
<tr><td><code id="cut_ages_+3A_breaks">breaks</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integerish]&#8288;</code>.
</p>
<p>1 or more non-negative cut points in increasing (strictly) order.
</p>
<p>These correspond to the left hand side of the desired intervals (e.g. the
closed side of [x, y).
</p>
<p>Double values are coerced to integer prior to categorisation.</p>
</td></tr>
<tr><td><code id="cut_ages_+3A_max_upper">max_upper</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>
</p>
<p>Represents the maximum upper bound for the resulting intervals.
</p>
<p>Double values are rounded up to the nearest (numeric) integer.
</p>
<p>Defaults to <code>Inf</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with an ordered factor column (<code>interval</code>), as well as columns
corresponding to the explicit bounds (<code>lower_bound</code> and <code>upper_bound</code>).
Internally both bound columns are stored as double but it can be taken as
part of the function API that <code>lower_bound</code> is coercible to integer without
any coercion to <code>NA_integer_</code>. Similarly all values of <code>upper_bound</code> apart
from those corresponding to <code>max_upper</code> can be assumed coercible to integer
(<code>max_upper</code> may or may not depending on the given argument).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cut_ages(ages = 0:9, breaks = c(0, 3, 5, 10))

cut_ages(ages = 0:9, breaks = c(0, 5))

# Note the following is comparable to a call to
# cut(ages, right = FALSE, breaks = c(breaks, Inf))
ages &lt;- seq.int(from = 0, by = 10, length.out = 10)
breaks &lt;- c(0, 1, 10, 30)
cut_ages(ages, breaks)

# values above max_upper treated as NA
cut_ages(ages = 0:10, breaks = c(0,5), max_upper = 7)

</code></pre>

<hr>
<h2 id='pop_dat'>Aggregated population data</h2><span id='topic+pop_dat'></span>

<h3>Description</h3>

<p>A dataset derived from the 2021 UK census containing population for different
age categories across England and Wales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop_dat
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows and 6 variables:
</p>

<dl>
<dt>area_code</dt><dd><p>Unique area identifier</p>
</dd>
<dt>area_name</dt><dd><p>Unique area name</p>
</dd>
<dt>age_category</dt><dd><p>Left-closed and right-open age interval</p>
</dd>
<dt>value</dt><dd><p>count of individ</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://github.com/TimTaylor/census_pop_2021">https://github.com/TimTaylor/census_pop_2021</a>
</p>

<hr>
<h2 id='reaggregate_counts'>Reaggregate age counts</h2><span id='topic+reaggregate_counts'></span><span id='topic+reaggregate_counts.default'></span>

<h3>Description</h3>

<p><code>reaggregate_counts()</code> converts counts over one interval range to another
with optional weighting by a known population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reaggregate_counts(...)

## Default S3 method:
reaggregate_counts(
  bounds,
  counts,
  new_bounds,
  ...,
  population_bounds = NULL,
  population_weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reaggregate_counts_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="reaggregate_counts_+3A_bounds">bounds</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>
</p>
<p>The <em>current</em> boundaries in (strictly) increasing order.
</p>
<p>These correspond to the left hand side of the intervals (e.g. the
closed side of [x, y).
</p>
<p>Double values are coerced to integer prior to categorisation.</p>
</td></tr>
<tr><td><code id="reaggregate_counts_+3A_counts">counts</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>
</p>
<p>Vector of counts corresponding to the intervals defined by <code>bounds</code>.</p>
</td></tr>
<tr><td><code id="reaggregate_counts_+3A_new_bounds">new_bounds</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>
</p>
<p>The <em>desired</em> boundaries in (strictly) increasing order.</p>
</td></tr>
<tr><td><code id="reaggregate_counts_+3A_population_bounds">population_bounds</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>
</p>
<p>Interval boundaries for a known population weighting given by the
<code>population_weights</code> argument.</p>
</td></tr>
<tr><td><code id="reaggregate_counts_+3A_population_weights">population_weights</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>
</p>
<p>Population weightings corresponding to <code>population_bounds</code>.
</p>
<p>Used to weight the output across the desired intervals.
</p>
<p>If <code>NULL</code> (default), counts are divided proportional to the interval sizes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with 4 entries; <code>interval</code>, <code>lower_bound</code>, <code>upper_bound</code> and a
corresponding <code>count</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Reaggregating some data obtained from the 2021 UK census
head(pop_dat)

# Each row of the data is for the same region so we can drop some columns
# `age_category` and `value` columns
dat &lt;- subset(pop_dat, select = c(age_category, value))

# Add the lower bounds to the data
dat &lt;- transform(
    dat,
    lower_bound = as.integer(sub("\\[([0-9]+), .+)", "\\1", age_category))
)

# Now recategorise to the desired age intervals
with(
    dat,
    reaggregate_counts(
        bounds = lower_bound,
        counts = value,
        new_bounds = c(0, 1, 5, 15, 25, 45, 65)
    )
)

</code></pre>

<hr>
<h2 id='reaggregate_rates'>Reaggregate age rates</h2><span id='topic+reaggregate_rates'></span><span id='topic+reaggregate_rates.default'></span>

<h3>Description</h3>

<p><code>reaggregate_rates()</code> converts rates over one interval range to another
with optional weighting by a known population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reaggregate_rates(...)

## Default S3 method:
reaggregate_rates(
  bounds,
  rates,
  new_bounds,
  ...,
  population_bounds = NULL,
  population_weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reaggregate_rates_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="reaggregate_rates_+3A_bounds">bounds</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>
</p>
<p>The <em>current</em> boundaries in (strictly) increasing order.
</p>
<p>These correspond to the left hand side of the intervals (e.g. the
closed side of [x, y).
</p>
<p>Double values are coerced to integer prior to categorisation.</p>
</td></tr>
<tr><td><code id="reaggregate_rates_+3A_rates">rates</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>
</p>
<p>Vector of rates corresponding to the intervals defined by <code>bounds</code>.</p>
</td></tr>
<tr><td><code id="reaggregate_rates_+3A_new_bounds">new_bounds</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>
</p>
<p>The <em>desired</em> boundaries in (strictly) increasing order.</p>
</td></tr>
<tr><td><code id="reaggregate_rates_+3A_population_bounds">population_bounds</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>
</p>
<p>Interval boundaries for a known population weighting given by the
<code>population_weights</code> argument.</p>
</td></tr>
<tr><td><code id="reaggregate_rates_+3A_population_weights">population_weights</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>
</p>
<p>Population weightings corresponding to <code>population_bounds</code>.
</p>
<p>Used to weight the output across the desired intervals.
</p>
<p>If <code>NULL</code> (default) rates are divided proportional to the interval sizes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with 4 entries; <code>interval</code>, <code>lower_bound</code>, <code>upper_bound</code> and a
corresponding <code>rate</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
reaggregate_rates(
    bounds = c(0, 5, 10),
    rates = c(0.1, 0.2 ,0.3),
    new_bounds = c(0, 2, 7, 10),
    population_bounds = c(0, 2, 5, 7, 10),
    population_weights = c(100, 200, 50, 150, 100)
)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
