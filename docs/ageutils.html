<!DOCTYPE html><html><head><title>Help for package ageutils</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ageutils}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ageutils-package'><p>ageutils: Collection of Functions for Working with Age Intervals</p></a></li>
<li><a href='#aggregate_age_counts'><p>Aggregate counts across ages</p></a></li>
<li><a href='#breaks_to_interval'><p>Convert breaks to an interval</p></a></li>
<li><a href='#cut_ages'><p>Cut integer age vectors</p></a></li>
<li><a href='#pop_dat'><p>Aggregated population data</p></a></li>
<li><a href='#reaggregate_interval_counts'><p>Reaggregate age intervals</p></a></li>
<li><a href='#reaggregate_interval_rates'><p>Reaggregate rates across intervals</p></a></li>
<li><a href='#split_interval_counts'><p>Split interval counts</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Collection of Functions for Working with Age Intervals</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a collection of efficient functions for working with
  individual ages and corresponding intervals. These include functions for
  conversion from an age to an interval, aggregation of ages with associated
  counts in to intervals and the splitting of interval counts based on
  specified age distributions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, markdown, tinytest</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://timtaylor.github.io/ageutils/">https://timtaylor.github.io/ageutils/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/TimTaylor/ageutils/issues">https://github.com/TimTaylor/ageutils/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-06 12:55:23 UTC; tim</td>
</tr>
<tr>
<td>Author:</td>
<td>Tim Taylor <a href="https://orcid.org/0000-0002-8587-7113"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph],
  Edwin van Leeuwen <a href="https://orcid.org/0000-0002-2383-5305"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tim Taylor &lt;tim.taylor@hiddenelephants.co.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-06 13:10:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='ageutils-package'>ageutils: Collection of Functions for Working with Age Intervals</h2><span id='topic+ageutils'></span><span id='topic+ageutils-package'></span>

<h3>Description</h3>

<p>Provides a collection of efficient functions for working with individual ages and corresponding intervals. These include functions for conversion from an age to an interval, aggregation of ages with associated counts in to intervals and the splitting of interval counts based on specified age distributions.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Tim Taylor <a href="mailto:tim.taylor@hiddenelephants.co.uk">tim.taylor@hiddenelephants.co.uk</a> (<a href="https://orcid.org/0000-0002-8587-7113">ORCID</a>) [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Edwin van Leeuwen <a href="mailto:edwinvanl@gmail.com">edwinvanl@gmail.com</a> (<a href="https://orcid.org/0000-0002-2383-5305">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://timtaylor.github.io/ageutils/">https://timtaylor.github.io/ageutils/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/TimTaylor/ageutils/issues">https://github.com/TimTaylor/ageutils/issues</a>
</p>
</li></ul>


<hr>
<h2 id='aggregate_age_counts'>Aggregate counts across ages</h2><span id='topic+aggregate_age_counts'></span>

<h3>Description</h3>

<p><code>aggregate_age_counts()</code> provides aggregation of counts across ages (in
years). It is similar to a <code>cut()</code> and <code>tapply()</code> pattern but optimised for
speed over flexibility. It takes a specified set of breaks representing the
left hand limits of a closed open interval, i.e [x, y), and returns the
corresponding interval and upper bounds. The resulting intervals span from
the minimum break through to the maximum age. Missing values are grouped as
NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_age_counts(counts, ages = seq_along(counts) - 1L, breaks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate_age_counts_+3A_counts">counts</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>.
</p>
<p>Vector of counts to be aggregated.</p>
</td></tr>
<tr><td><code id="aggregate_age_counts_+3A_ages">ages</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>.
</p>
<p>Vector of age in years.
</p>
<p>Double values are coerced to integer prior to categorisation / aggregation.
</p>
<p>For <code>aggregate_age_counts()</code>, these must corresponding to the <code>counts</code> entry
and will defaults to 0:(N-1) where <code>N</code> is the number of counts present.
</p>
<p>No (non-missing) age can be less than the minimum break.</p>
</td></tr>
<tr><td><code id="aggregate_age_counts_+3A_breaks">breaks</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>.
</p>
<p>1 or more cut points in increasing (strictly) order.
</p>
<p>These correspond to the left hand side of the desired intervals (e.g. the
closed side of [x, y).
</p>
<p>Double values are coerced to integer prior to categorisation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with 4 entries; <code>interval</code>, <code>lower_bound</code>, <code>upper_bound</code> and an
associated <code>count</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# default ages generated if only counts provided (here ages will be 0:64)
aggregate_age_counts(counts = 1:65, breaks = c(0L, 1L, 5L, 15L, 25L, 45L, 65L))

# NA ages are handled with their own grouping
ages &lt;- 1:65
ages[1:44] &lt;- NA
aggregate_age_counts(
    counts = 1:65,
    ages = ages,
    breaks = c(0L, 1L, 5L, 15L, 25L, 45L, 65L)
)

</code></pre>

<hr>
<h2 id='breaks_to_interval'>Convert breaks to an interval</h2><span id='topic+breaks_to_interval'></span>

<h3>Description</h3>

<p><code>breaks_to_interval()</code> takes a specified set of breaks representing the left
hand limits of a closed open interval, i.e [x, y), and returns the
corresponding interval and upper bounds. The resulting intervals span from
the minimum break through to a specified <code>max_upper</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>breaks_to_interval(breaks, max_upper = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="breaks_to_interval_+3A_breaks">breaks</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integerish]&#8288;</code>.
</p>
<p>1 or more non-negative cut points in increasing (strictly) order.
</p>
<p>These correspond to the left hand side of the desired intervals (e.g. the
closed side of [x, y).
</p>
<p>Double values are coerced to integer prior to categorisation.</p>
</td></tr>
<tr><td><code id="breaks_to_interval_+3A_max_upper">max_upper</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>
</p>
<p>Represents the maximum upper bound splitting the data.
</p>
<p>Defaults to <code>Inf</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with an ordered factor column (<code>interval</code>), as well as columns
corresponding to the explicit bounds (<code>lower_bound</code> and <code>upper_bound</code>). Note
these bounds are returned as <code style="white-space: pre;">&#8288;&lt;numeric&gt;&#8288;</code> to allow the maximum upper bound to
be <code>Inf</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>brks &lt;- c(0L, 1L, 5L, 15L, 25L, 45L, 65L)
breaks_to_interval(breaks = brks)
breaks_to_interval(breaks = brks, max_upper = 100L)

</code></pre>

<hr>
<h2 id='cut_ages'>Cut integer age vectors</h2><span id='topic+cut_ages'></span>

<h3>Description</h3>

<p><code>cut_ages()</code> provides categorisation of ages based on specified breaks
which represent the left-hand interval limits. The resulting intervals span
from the minimum break through to a specified <code>max_upper</code> and will always be
closed on the left and open on the right. Ages below the minimum break, or
above <code>max_upper</code> will be returned as NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_ages(ages, breaks, max_upper = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut_ages_+3A_ages">ages</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>.
</p>
<p>Vector of age values.
</p>
<p>Double values are coerced to integer prior to categorisation / aggregation.
</p>
<p>Must not be NA.</p>
</td></tr>
<tr><td><code id="cut_ages_+3A_breaks">breaks</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integerish]&#8288;</code>.
</p>
<p>1 or more non-negative cut points in increasing (strictly) order.
</p>
<p>These correspond to the left hand side of the desired intervals (e.g. the
closed side of [x, y).
</p>
<p>Double values are coerced to integer prior to categorisation.</p>
</td></tr>
<tr><td><code id="cut_ages_+3A_max_upper">max_upper</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>
</p>
<p>Represents the maximum upper bound for the resulting intervals.
</p>
<p>Double values are rounded to the nearest (numeric) integer.
</p>
<p>Defaults to <code>Inf</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with an ordered factor column (<code>interval</code>), as well as columns
corresponding to the explicit bounds (<code>lower_bound</code> and <code>upper_bound</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cut_ages(ages = 0:9, breaks = c(0L, 3L, 5L, 10L))

cut_ages(ages = 0:9, breaks = c(0L, 5L))

# Note the following is comparable to a call to
# cut(ages, right = FALSE, breaks = c(breaks, Inf))
ages &lt;- seq.int(from = 0, by = 10, length.out = 10)
breaks &lt;- c(0, 1, 10, 30)
cut_ages(ages, breaks)

# values above max_upper treated as NA
cut_ages(ages = 0:10, breaks = c(0,5), max_upper = 7)

</code></pre>

<hr>
<h2 id='pop_dat'>Aggregated population data</h2><span id='topic+pop_dat'></span>

<h3>Description</h3>

<p>A dataset derived from the 2021 UK census containing population for different
age categories across England and Wales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop_dat
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows and 6 variables:
</p>

<dl>
<dt>area_code</dt><dd><p>Unique area identifier</p>
</dd>
<dt>area_name</dt><dd><p>Unique area name</p>
</dd>
<dt>age_category</dt><dd><p>Left-closed and right-open age interval</p>
</dd>
<dt>value</dt><dd><p>count of individ</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://github.com/TimTaylor/census_pop_2021">https://github.com/TimTaylor/census_pop_2021</a>
</p>

<hr>
<h2 id='reaggregate_interval_counts'>Reaggregate age intervals</h2><span id='topic+reaggregate_interval_counts'></span>

<h3>Description</h3>

<p><code>reaggregate_interval_counts()</code> converts counts over one interval range to
another. It first splits counts of a given age interval in to counts for
individual years based on a given weighting. These are then aggregated to the
desired breaks. Functionally this is equivalent to, but more efficient than,
a call to <code>split_interval_counts()</code> followed by <code>aggregate_age_counts()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reaggregate_interval_counts(
  lower_bounds,
  upper_bounds,
  counts,
  breaks,
  max_upper = 100L,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reaggregate_interval_counts_+3A_lower_bounds">lower_bounds</code>, <code id="reaggregate_interval_counts_+3A_upper_bounds">upper_bounds</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integerish]&#8288;</code>.
</p>
<p>A pair of vectors representing the bounds of the intervals.
</p>
<p><code>lower_bounds</code> must be strictly less than <code>upper_bounds</code> and greater than or
equal to zero.
</p>
<p>Missing (NA) bounds are not permitted.
</p>
<p>Double vectors will be coerced to integer.</p>
</td></tr>
<tr><td><code id="reaggregate_interval_counts_+3A_counts">counts</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>.
</p>
<p>Vector of counts to be aggregated.</p>
</td></tr>
<tr><td><code id="reaggregate_interval_counts_+3A_breaks">breaks</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>.
</p>
<p>1 or more cut points in increasing (strictly) order.
</p>
<p>These correspond to the left hand side of the desired intervals (e.g. the
closed side of [x, y).
</p>
<p>Double values are coerced to integer prior to categorisation.</p>
</td></tr>
<tr><td><code id="reaggregate_interval_counts_+3A_max_upper">max_upper</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integerish]&#8288;</code>
</p>
<p>Represents the maximum upper bounds permitted upon splitting the data.
</p>
<p>Any upper bound greater than this will be replaced with this value prior to
splitting.
</p>
<p>Double vectors will be coerced to integer.</p>
</td></tr>
<tr><td><code id="reaggregate_interval_counts_+3A_weights">weights</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>
</p>
<p>Population weightings to apply for individual years.
</p>
<p>If <code>NULL</code> (default) counts will be split evenly based on interval size.
</p>
<p>If specified, must be of length <code>max_upper</code> and represent weights in the
range 0:(max_upper - 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with 4 entries; <code>interval</code>, <code>lower_bound</code>, <code>upper_bound</code> and an
associated <code>count</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
reaggregate_interval_counts(
    lower_bounds = c(0, 5, 10),
    upper_bounds = c(5, 10, 20),
    counts = c(5, 10, 30),
    breaks = c(0L, 1L, 5L, 15L, 25L, 45L, 65L)
)

</code></pre>

<hr>
<h2 id='reaggregate_interval_rates'>Reaggregate rates across intervals</h2><span id='topic+reaggregate_interval_rates'></span>

<h3>Description</h3>

<p><code>reaggregate_interval_rates()</code> enables the reweighting of interval rates in
to different intervals ranges. It first replicates the rates of a given
age interval into the individual years of said interval. These are then
aggregated allowing for a user specified weight vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reaggregate_interval_rates(
  lower_bounds,
  upper_bounds = NULL,
  rates,
  breaks,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reaggregate_interval_rates_+3A_lower_bounds">lower_bounds</code>, <code id="reaggregate_interval_rates_+3A_upper_bounds">upper_bounds</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integerish]&#8288;</code>.
</p>
<p>A pair of vectors representing the bounds of the current intervals.
</p>
<p>If <code>upper_bounds</code> is NULL, it will be automatically set to
<code>c(lower_bounds[-1L], max_upper)</code>.
</p>
<p><code>lower_bounds</code> must be strictly less than <code>upper_bounds</code> and greater than or
equal to zero.
</p>
<p>Missing (NA) bounds are not permitted.
</p>
<p>Double vectors will be coerced to integer.</p>
</td></tr>
<tr><td><code id="reaggregate_interval_rates_+3A_rates">rates</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>.
</p>
<p>Vector of counts to be averaged.</p>
</td></tr>
<tr><td><code id="reaggregate_interval_rates_+3A_breaks">breaks</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>.
</p>
<p>1 or more non-negative cut points in increasing (strictly) order.
</p>
<p>These correspond to the left hand side of the desired intervals (e.g. the
closed side of [x, y).
</p>
<p>Double values are coerced to integer prior to categorisation.</p>
</td></tr>
<tr><td><code id="reaggregate_interval_rates_+3A_weights">weights</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>
</p>
<p>Population weightings to apply for individual years.
</p>
<p>If <code>NULL</code> (default) weights will be allocated proportional to the interval
size.
</p>
<p>If specified, must be of length most 2000 and represent weights in the
range 0:1999.
</p>
<p><code>weights</code> of length less than 2000 will be padded with 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with 4 entries; <code>interval</code>, <code>lower_bound</code>, <code>upper_bound</code> and an
associated <code>count</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reaggregate_interval_rates(
  lower_bounds = c(0, 5, 13),
  upper_bounds= c(5, 15, 100),
  rates = c(1, 0.1, 0.01),
  breaks = c(0, 1, 9, 15),
  weights = round(runif(70, 10, 30))
)

reaggregate_interval_rates(
  lower_bounds = c(0, 5, 13),
  rates = c(1, 0.1, 0.01),
  breaks = c(0, 1, 9, 15),
  weights = round(runif(70, 10, 30))
)


</code></pre>

<hr>
<h2 id='split_interval_counts'>Split interval counts</h2><span id='topic+split_interval_counts'></span>

<h3>Description</h3>

<p><code>split_interval_counts()</code> splits counts of a given age interval in to
counts for individual years based on a given weighting. Age intervals are
specified by their lower (closed) and upper (open) bounds, i.e. intervals
of the form [lower, upper).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_interval_counts(
  lower_bounds,
  upper_bounds,
  counts,
  max_upper = 100L,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_interval_counts_+3A_lower_bounds">lower_bounds</code>, <code id="split_interval_counts_+3A_upper_bounds">upper_bounds</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integerish]&#8288;</code>.
</p>
<p>A pair of vectors representing the bounds of the intervals.
</p>
<p><code>lower_bounds</code> must be strictly less than <code>upper_bounds</code> and greater than or
equal to zero.
</p>
<p>Missing (NA) bounds are not permitted.
</p>
<p>Double vectors will be coerced to integer.</p>
</td></tr>
<tr><td><code id="split_interval_counts_+3A_counts">counts</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>.
</p>
<p>Vector of counts to be aggregated.</p>
</td></tr>
<tr><td><code id="split_interval_counts_+3A_max_upper">max_upper</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integerish]&#8288;</code>
</p>
<p>Represents the maximum upper bounds permitted upon splitting the data.
</p>
<p>Any upper bound greater than this will be replaced with this value prior to
splitting.
</p>
<p>Double vectors will be coerced to integer.</p>
</td></tr>
<tr><td><code id="split_interval_counts_+3A_weights">weights</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>
</p>
<p>Population weightings to apply for individual years.
</p>
<p>If <code>NULL</code> (default) counts will be split evenly based on interval size.
</p>
<p>If specified, must be of length <code>max_upper</code> and represent weights in the
range 0:(max_upper - 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with entries <code>age</code> (in years) and <code>count</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
split_interval_counts(
    lower_bounds = c(0, 5, 10),
    upper_bounds = c(5, 10, 20),
    counts = c(5, 10, 30)
)

split_interval_counts(
    lower_bounds = c(0, 5, 10),
    upper_bounds = c(5, 10, Inf),
    counts = c(5, 10, 30),
    max_upper = 15
)

split_interval_counts(
    lower_bounds = c(0, 5),
    upper_bounds = c(5, 10),
    counts = c(5, 10),
    max_upper =10,
    weights = 1:10
)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
