<!DOCTYPE html><html><head><title>Help for package CalibrateSSB</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CalibrateSSB}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CalibrateSSB-package'><p>Weighting and Estimation for Panel Data with Non-Response</p></a></li>
<li><a href='#AkuData'><p>Generate test data</p></a></li>
<li><a href='#CalibrateSSB'><p>Calibration weighting and estimation</p></a></li>
<li><a href='#CalibrateSSBpanel'><p>Calibration weighting and variance estimation for panel data</p></a></li>
<li><a href='#CalSSBobj'><p>Create or modify a CalSSB object</p></a></li>
<li><a href='#CalSSBobjReGenesees'><p>Create a CalSSB object from a ReGenesees/cal.analytic object</p></a></li>
<li><a href='#CrossStrata'><p>Crossing several factor variables</p></a></li>
<li><a href='#LinCombMatrix'><p>Creation of linear combination matrices</p></a></li>
<li><a href='#MatchVarNames'><p>MatchVarNames</p></a></li>
<li><a href='#OrderedVarNames'><p>OrderedVarNames</p></a></li>
<li><a href='#PanelEstimation'><p>Variance estimation for panel data</p></a></li>
<li><a href='#print.calSSB'><p>Print method for calSSB</p></a></li>
<li><a href='#print.calSSBwide'><p>Print method for calSSBwide</p></a></li>
<li><a href='#testDataBasis'><p>testDataBasis</p></a></li>
<li><a href='#WideFromCalibrate'><p>Rearrange output from CalibrateSSB (calSSB object). Ready for input to PanelEstimation.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Weighting and Estimation for Panel Data with Non-Response</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-08-03</td>
</tr>
<tr>
<td>Author:</td>
<td>Øyvind Langsrud</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Oyvind Langsrud &lt;oyl@ssb.no&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), survey</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ReGenesees, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to calculate weights, estimates of changes and corresponding variance estimates for panel data with non-response. Partially overlapping samples are handled. Initially, weights are calculated by linear calibration. By default, the survey package is used for this purpose. It is also possible to use ReGenesees, which can be installed from <a href="https://github.com/DiegoZardetto/ReGenesees">https://github.com/DiegoZardetto/ReGenesees</a>. Variances of linear combinations (changes and averages) and ratios are calculated from a covariance matrix based on residuals according to the calibration model. The methodology was presented at the conference, The Use of R in Official Statistics, and is described in Langsrud (2016) <a href="http://www.revistadestatistica.ro/wp-content/uploads/2016/06/RRS2_2016_A021.pdf">http://www.revistadestatistica.ro/wp-content/uploads/2016/06/RRS2_2016_A021.pdf</a>.  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/statisticsnorway/CalibrateSSB">https://github.com/statisticsnorway/CalibrateSSB</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/statisticsnorway/CalibrateSSB/issues">https://github.com/statisticsnorway/CalibrateSSB/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-08-03 21:56:23 UTC; oyl</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-08-04 22:04:14 UTC</td>
</tr>
</table>
<hr>
<h2 id='CalibrateSSB-package'>Weighting and Estimation for Panel Data with Non-Response</h2><span id='topic+CalibrateSSB-package'></span>

<h3>Description</h3>

<p>CalibrateSSB is an R-package that handles repeated surveys with partially
overlapping samples. Initially the samples are weighted by linear
calibration using known or estimated population totals. A robust model based
covariance matrix for all relevant estimated totals is calculated from the
residuals according to the calibration model. Alternatively a design based
covariance matrix is calculated in a very similar way. A cluster robust
version is also possible. In the case of estimated populations totals the
covariance matrix is adjusted by utilizing the theory of Särndal and
Lundström (2005). Variances of linear combinations (changes and averages)
and ratios are calculated from this covariance matrix. The linear
combinations and ratios can involve variables within and/or between sample
waves. <br />
</p>


<h3>References</h3>

<p>Langsrud, Ø (2016): &ldquo;A variance estimation R-package for
repeated surveys - useful for estimates of changes in quarterly and annual
averages&rdquo;, <em>Romanian Statistical Review</em> nr. 2 / 2016, pp. 17-28.
CONFERENCE: <em>New Challenges for Statistical Software - The Use of R in
Official Statistics</em>, Bucharest, Romania, 7-8 April. <br />
</p>
<p>Särndal, C.-E. and Lundström, S. (2005): <em>Estimation in Surveys with
Nonresponse</em>, John Wiley and Sons, New York.
</p>

<hr>
<h2 id='AkuData'>Generate test data</h2><span id='topic+AkuData'></span>

<h3>Description</h3>

<p>Generate test data of eight quarters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AkuData(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AkuData_+3A_n">n</code></td>
<td>
<p>Number of observations within each quarter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the following variables: </p>
<table>
<tr><td><code>id</code></td>
<td>
<p>Sample unit
identifier</p>
</td></tr> <tr><td><code>year</code></td>
<td>
<p>Year</p>
</td></tr> <tr><td><code>q</code></td>
<td>
<p>Quarter</p>
</td></tr> <tr><td><code>month</code></td>
<td>
<p>Month</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>Response indicator</p>
</td></tr> <tr><td><code>age</code></td>
<td>
<p>Age group</p>
</td></tr> <tr><td><code>sex</code></td>
<td>
<p>Education
group</p>
</td></tr> <tr><td><code>famid</code></td>
<td>
<p>Family identifier</p>
</td></tr> <tr><td><code>unemployed</code></td>
<td>
<p>Unemployed</p>
</td></tr>
<tr><td><code>workforce</code></td>
<td>
<p>In workforce</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generates data - two years
z = AkuData(3000) # 3000 in each quarter

</code></pre>

<hr>
<h2 id='CalibrateSSB'>Calibration weighting and estimation</h2><span id='topic+CalibrateSSB'></span>

<h3>Description</h3>

<p>Compute weights by calibration and corresponding estimates, totals and
residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalibrateSSB(
  grossSample,
  calmodel = NULL,
  response = "R",
  popTotals = NULL,
  y = NULL,
  by = NULL,
  partition = NULL,
  lRegmodel = NULL,
  popData = NULL,
  samplingWeights = NULL,
  usePackage = "survey",
  bounds = c(-Inf, Inf),
  calfun = "linear",
  onlyTotals = FALSE,
  onlyw = FALSE,
  uselRegWeights = FALSE,
  ids = NULL,
  residOutput = TRUE,
  leverageOutput = FALSE,
  yOutput = TRUE,
  samplingWeightsOutput = FALSE,
  dropResid2 = TRUE,
  wGrossOutput = TRUE,
  wave = NULL,
  id = NULL,
  extra = NULL,
  allowNApopTotals = NULL,
  partitionPrint = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalibrateSSB_+3A_grosssample">grossSample</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_calmodel">calmodel</code></td>
<td>
<p>Formula defining the linear structure of the calibration
model.</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_response">response</code></td>
<td>
<p>Variable name of response indicator (net sample when 1).</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_poptotals">popTotals</code></td>
<td>
<p>Population totals (similar to population totals as output).</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_y">y</code></td>
<td>
<p>Names of variables of interest. Can be a list similar to &quot;by&quot;
below.</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_by">by</code></td>
<td>
<p>Names of the variables that define the &quot;estimation domains&quot;. If
NULL (the default option) or NA estimates refer to the whole population. Use
list for multiple specifications (resulting in list as output).</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_partition">partition</code></td>
<td>
<p>Names of the variables that define the &quot;calibration
domains&quot; for the model. NULL (the default) implies no calibration domains.</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_lregmodel">lRegmodel</code></td>
<td>
<p>Formula defining the linear structure of a logistic
regression model.</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_popdata">popData</code></td>
<td>
<p>Data frame of population data.</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_samplingweights">samplingWeights</code></td>
<td>
<p>Name of the variable with initial weights for the
sampling units.</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_usepackage">usePackage</code></td>
<td>
<p>Specifying the package to be used: &quot;survey&quot; (the default),
&quot;ReGenesees&quot; or &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_bounds">bounds</code></td>
<td>
<p>Bounds for the calibration weights. When ReGenesees: Allowed
range for the ratios between calibrated and initial weights. The default is
c(-Inf,Inf).</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_calfun">calfun</code></td>
<td>
<p>The distance function for the calibration process; the default
is 'linear'.</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_onlytotals">onlyTotals</code></td>
<td>
<p>When TRUE: Only population totals are returned.</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_onlyw">onlyw</code></td>
<td>
<p>When TRUE: Only the calibrated weights are returned.</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_uselregweights">uselRegWeights</code></td>
<td>
<p>When TRUE: Weighted logistic regression is performed
as a first calibration step.</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_ids">ids</code></td>
<td>
<p>Name of sampling unit identifier variable.</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_residoutput">residOutput</code></td>
<td>
<p>Residuals in output when TRUE. FALSE is default.</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_leverageoutput">leverageOutput</code></td>
<td>
<p>Leverages in output when TRUE. FALSE is default.</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_youtput">yOutput</code></td>
<td>
<p>y in output when TRUE. FALSE is default.</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_samplingweightsoutput">samplingWeightsOutput</code></td>
<td>
<p>samplingWeights in output when TRUE. FALSE is
default.</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_dropresid2">dropResid2</code></td>
<td>
<p>When TRUE (default) and when no missing population totals
- only one set of residuals in output.</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_wgrossoutput">wGrossOutput</code></td>
<td>
<p>wGross in output when TRUE (default) and when NA
popTotals.</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_wave">wave</code></td>
<td>
<p>Time or another repeat variable (to be included in output).</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_id">id</code></td>
<td>
<p>Identifier variable (to be included in output).</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_extra">extra</code></td>
<td>
<p>Variables for the extra dataset (to be included in output).</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_allownapoptotals">allowNApopTotals</code></td>
<td>
<p>When TRUE missing population totals are allowed.
Results in error when FALSE and warning when NULL.</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_partitionprint">partitionPrint</code></td>
<td>
<p>When TRUE partition progress is printed. 
Automatic decision when NULL (about 1 min total computing time).</p>
</td></tr>
<tr><td><code id="CalibrateSSB_+3A_...">...</code></td>
<td>
<p>Further arguments sent to underlying functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When popTotals as input is NULL, population totals are computed from popData
(when available) or from grossSample. Some elements of popTotals may be
missing (not allowed when using ReGenesees). When using &quot;ReGenesees&quot;, both
weiging and estimation are done by that package. When using &quot;survey&quot;, only
calibration weiging are done by that package.
The parameters <code>wave</code>, <code>id</code> and <code>extra</code> have no effect on the 
computations, but result in extra elements in output 
(to be used by WideFromCalibrate() later).
</p>


<h3>Value</h3>

<p>Unless onlyTotals or onlyw is TRUE, the output is an object of class calSSB. That is, a list with 
elements: </p>
<table>
<tr><td><code>popTotals</code></td>
<td>
<p>Population totals.</p>
</td></tr> <tr><td><code>w</code></td>
<td>
<p>The calibrated
weights.</p>
</td></tr> <tr><td><code>wGross</code></td>
<td>
<p>Calibrated gross sample weights when NA popTotals.</p>
</td></tr>
<tr><td><code>estTM</code></td>
<td>
<p>Estimates (with standard error).</p>
</td></tr> <tr><td><code>resids</code></td>
<td>
<p>Residuals,
reduced model when NA popTotals.</p>
</td></tr> <tr><td><code>resids2</code></td>
<td>
<p>Residuals, full model.</p>
</td></tr>
<tr><td><code>leverages</code></td>
<td>
<p>Diagonal elements of hat-matrix, reduced model when NA
popTotals.</p>
</td></tr> <tr><td><code>leverages2</code></td>
<td>
<p>Diagonal elements of hat-matrix, full model.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>as input</p>
</td></tr> <tr><td><code>samplingWeights</code></td>
<td>
<p>as input</p>
</td></tr>
<tr><td><code>wave</code></td>
<td>
<p>as input or via CrossStrata</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>as input</p>
</td></tr>
<tr><td><code>extra</code></td>
<td>
<p>as input</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+CalSSBobj">CalSSBobj</a></code>, <code><a href="#topic+WideFromCalibrate">WideFromCalibrate</a></code>,  <code><a href="#topic+PanelEstimation">PanelEstimation</a></code>, <code><a href="#topic+CalibrateSSBpanel">CalibrateSSBpanel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generates data  - two years
z    &lt;- AkuData(3000)  # 3000 in each quarter
zPop &lt;- AkuData(10000)[,1:7]

# Calibration using "survey"
a &lt;- CalibrateSSB(z, calmodel = "~ sex*age",
                 partition = c("year","q"),  # calibrate within quarter
                 popData = zPop, y = c("unemployed","workforce"),
                 by = c("year","q")) # Estimate within quarter
head(a$w) # calibrated weights
a$estTM   # estimates
a$popTotals   # popTotals used as input below


# Calibration, no package, popTotals as input
b &lt;- CalibrateSSB(z, popTotals=a$popTotals, calmodel="~ sex*age",
      partition = c("year","q"), usePackage = "none", y = c("unemployed","workforce"))
max(abs(a$w-b$w)) # Same weights as above

print(a)
print(b)

## Not run: 
require(ReGenesees)
# Calibration and estimation via ReGenesees
CalibrateSSB(z, calmodel = "~ sex*age",
             partition = c("year","q"),  # calibrate within quarter
             popData = zPop, usePackage = "ReGenesees",
             y = c("unemployed","workforce"),
             by = c("year","q")) # Estimate within quarter

## End(Not run)

</code></pre>

<hr>
<h2 id='CalibrateSSBpanel'>Calibration weighting and variance estimation for panel data</h2><span id='topic+CalibrateSSBpanel'></span>

<h3>Description</h3>

<p>Calibration weighting and variance estimation for panel data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalibrateSSBpanel(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalibrateSSBpanel_+3A_...">...</code></td>
<td>
<p>Input to CalibrateSSB() and PanelEstimation()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output from PanelEstimation()
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalibrateSSB">CalibrateSSB</a></code>, <code><a href="#topic+PanelEstimation">PanelEstimation</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z    = AkuData(3000)  # 3000 in each quarter
zPop = AkuData(10000)[,1:7]
lc = rbind(LagDiff(8,4),PeriodDiff(8,4))
rownames(lc) = c("diffQ1","diffQ2","diffQ3","diffQ4","diffYearMean")
CalibrateSSBpanel(grossSample=z,calmodel="~ sex*age", partition=c("year","q"),popData=zPop, 
       y=c("unemployed","workforce"),id="id",wave=c("year","q"),
       numerator="unemployed",linComb=lc)
</code></pre>

<hr>
<h2 id='CalSSBobj'>Create or modify a CalSSB object</h2><span id='topic+CalSSBobj'></span>

<h3>Description</h3>

<p>The elements of the CalSSB object are taken directly from the input parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalSSBobj(
  x = NULL,
  y = NULL,
  w = NULL,
  wGross = NULL,
  resids = NULL,
  resids2 = NULL,
  leverages = NULL,
  leverages2 = NULL,
  samplingWeights = NULL,
  extra = NULL,
  id = NULL,
  wave = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalSSBobj_+3A_x">x</code></td>
<td>
<p>NULL or an  existing calSSB object</p>
</td></tr>
<tr><td><code id="CalSSBobj_+3A_y">y</code></td>
<td>
<p>y</p>
</td></tr>
<tr><td><code id="CalSSBobj_+3A_w">w</code></td>
<td>
<p>w</p>
</td></tr>
<tr><td><code id="CalSSBobj_+3A_wgross">wGross</code></td>
<td>
<p>wGross</p>
</td></tr>
<tr><td><code id="CalSSBobj_+3A_resids">resids</code></td>
<td>
<p>resids</p>
</td></tr>
<tr><td><code id="CalSSBobj_+3A_resids2">resids2</code></td>
<td>
<p>resids2</p>
</td></tr>
<tr><td><code id="CalSSBobj_+3A_leverages">leverages</code></td>
<td>
<p>leverages</p>
</td></tr>
<tr><td><code id="CalSSBobj_+3A_leverages2">leverages2</code></td>
<td>
<p>leverages2</p>
</td></tr>
<tr><td><code id="CalSSBobj_+3A_samplingweights">samplingWeights</code></td>
<td>
<p>samplingWeights</p>
</td></tr>
<tr><td><code id="CalSSBobj_+3A_extra">extra</code></td>
<td>
<p>extra</p>
</td></tr>
<tr><td><code id="CalSSBobj_+3A_id">id</code></td>
<td>
<p>id</p>
</td></tr>
<tr><td><code id="CalSSBobj_+3A_wave">wave</code></td>
<td>
<p>wave</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A CalSSB object. That is, an object of the type retuned by <code><a href="#topic+CalibrateSSB">CalibrateSSB</a></code>.
</p>


<h3>Note</h3>

<p>If x is a ReGenesees/cal.analytic object, this function is a wrapper to <code><a href="#topic+CalSSBobjReGenesees">CalSSBobjReGenesees</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalibrateSSB">CalibrateSSB</a></code>, <code><a href="#topic+CalSSBobjReGenesees">CalSSBobjReGenesees</a></code>, <code><a href="#topic+WideFromCalibrate">WideFromCalibrate</a></code>,  <code><a href="#topic+PanelEstimation">PanelEstimation</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' # Generates data - two years
z &lt;- AkuData(3000)  # 3000 in each quarter
zPop &lt;- AkuData(10000)[, 1:7]

# Create a CalSSB object by CalibrateSSB
b &lt;- CalibrateSSB(z, calmodel = "~ sex*age", partition = c("year", "q"), popData = zPop, 
                  y = c("unemployed", "workforce"))

# Modify the CalSSB object
a &lt;- CalSSBobj(b, w = 10*b$w, wave = CrossStrata(z[, c("year", "q")]), id = z$id)

# Use the CalSSB object as input ...
PanelEstimation(WideFromCalibrate(a), "unemployed", linComb = PeriodDiff(8, 4))

# Create CalSSB object without x as input
CalSSBobj(y = b$y, w = 10*b$w, resids = b$resids, wave = CrossStrata(z[, c("year", "q")]), 
          id = z$id)

</code></pre>

<hr>
<h2 id='CalSSBobjReGenesees'>Create a CalSSB object from a ReGenesees/cal.analytic object</h2><span id='topic+CalSSBobjReGenesees'></span>

<h3>Description</h3>

<p>Create a CalSSB object from a ReGenesees/cal.analytic object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalSSBobjReGenesees(
  x,
  y,
  samplingWeights = NULL,
  extra = NULL,
  id = NULL,
  wave = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalSSBobjReGenesees_+3A_x">x</code></td>
<td>
<p>Output from ReGenesees::e.calibrate() (object of class cal.analytic)</p>
</td></tr>
<tr><td><code id="CalSSBobjReGenesees_+3A_y">y</code></td>
<td>
<p>formula or variable names</p>
</td></tr>
<tr><td><code id="CalSSBobjReGenesees_+3A_samplingweights">samplingWeights</code></td>
<td>
<p>NULL, TRUE (capture from x), formula, variable name or vector of data</p>
</td></tr>
<tr><td><code id="CalSSBobjReGenesees_+3A_extra">extra</code></td>
<td>
<p>NULL, formula, variable names or matrix of data</p>
</td></tr>
<tr><td><code id="CalSSBobjReGenesees_+3A_id">id</code></td>
<td>
<p>NULL, TRUE (ids from x), formula, variable name or vector of data</p>
</td></tr>
<tr><td><code id="CalSSBobjReGenesees_+3A_wave">wave</code></td>
<td>
<p>NULL,  formula, variable name or vector of data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A CalSSB object. That is, an object of the type retuned by <code><a href="#topic+CalibrateSSB">CalibrateSSB</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalibrateSSB">CalibrateSSB</a></code>, <code><a href="#topic+CalSSBobj">CalSSBobj</a></code>, <code><a href="#topic+WideFromCalibrate">WideFromCalibrate</a></code>,  <code><a href="#topic+PanelEstimation">PanelEstimation</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generates data - two years
z &lt;- AkuData(3000)  # 3000 in each quarter
zPop &lt;- AkuData(10000)[, 1:7]
z$samplingWeights &lt;- 1
z$ids &lt;- 1:NROW(z)

# Create a ReGenesees/cal.analytic object
library("ReGenesees")
desReGenesees &lt;- e.svydesign(z[z$R == 1, ], ids = ~ids, weights = ~samplingWeights)
popTemplate &lt;- pop.template(data = desReGenesees, calmodel = ~sex * age, partition = ~year + q)
popTotals &lt;- fill.template(universe = zPop, template = popTemplate)
calReGenesees &lt;- e.calibrate(design = desReGenesees, df.population = popTotals)

# Create CalSSB objects from a ReGenesees/cal.analytic object
CalSSBobjReGenesees(calReGenesees, y = ~unemployed + workforce, id = TRUE, 
                    samplingWeights = TRUE, extra = ~famid)
a &lt;- CalSSBobjReGenesees(calReGenesees, y = c("unemployed", "workforce"), 
                         id = "id", extra = "famid", wave = c("year", "q"))

# Use the CalSSB object as input ...
PanelEstimation(WideFromCalibrate(a), "unemployed", linComb = PeriodDiff(8, 4))


## End(Not run)
</code></pre>

<hr>
<h2 id='CrossStrata'>Crossing several factor variables</h2><span id='topic+CrossStrata'></span>

<h3>Description</h3>

<p>Create new factor variable by crossing levels in several variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CrossStrata(by, sep = "-", returnb = FALSE, asNumeric = FALSE, byExtra = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CrossStrata_+3A_by">by</code></td>
<td>
<p>Dataframe or matrix with several variables</p>
</td></tr>
<tr><td><code id="CrossStrata_+3A_sep">sep</code></td>
<td>
<p>Used to create new level names</p>
</td></tr>
<tr><td><code id="CrossStrata_+3A_returnb">returnb</code></td>
<td>
<p>When TRUE an overview of original variabels according to new
levels are also retuned.</p>
</td></tr>
<tr><td><code id="CrossStrata_+3A_asnumeric">asNumeric</code></td>
<td>
<p>When TRUE the new variable is numeric.</p>
</td></tr>
<tr><td><code id="CrossStrata_+3A_byextra">byExtra</code></td>
<td>
<p>Contains the same variables as by and represents another data
set.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>a</code></td>
<td>
<p>The new variable</p>
</td></tr> <tr><td><code>aExtra</code></td>
<td>
<p>New variable according to
byExtra</p>
</td></tr> <tr><td><code>b</code></td>
<td>
<p>Overview of original variabels according to new levels</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
CrossStrata(cbind(factor(rep(1:3,2)),c('A',rep('B',5)) ))

</code></pre>

<hr>
<h2 id='LinCombMatrix'>Creation of linear combination matrices</h2><span id='topic+LinCombMatrix'></span><span id='topic+PeriodDiff'></span><span id='topic+Period'></span><span id='topic+LagDiff'></span>

<h3>Description</h3>

<p>Create matrices for changes (LagDiff), means (Period) and mean changes
(PeriodDiff).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LinCombMatrix(
  n,
  period = NULL,
  lag = NULL,
  k = 0,
  takeMean = TRUE,
  removerows = TRUE,
  overlap = FALSE
)

LagDiff(n, lag = 1, removerows = TRUE)

Period(
  n,
  period = 1,
  k = 0,
  takeMean = TRUE,
  removerows = TRUE,
  overlap = FALSE
)

PeriodDiff(
  n,
  period = 1,
  lag = period,
  k = 0,
  takeMean = TRUE,
  removerows = TRUE,
  overlap = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LinCombMatrix_+3A_n">n</code></td>
<td>
<p>Number of variables</p>
</td></tr>
<tr><td><code id="LinCombMatrix_+3A_period">period</code></td>
<td>
<p>Number of variables involved in each period</p>
</td></tr>
<tr><td><code id="LinCombMatrix_+3A_lag">lag</code></td>
<td>
<p>Lag used for difference calculation</p>
</td></tr>
<tr><td><code id="LinCombMatrix_+3A_k">k</code></td>
<td>
<p>Shift the start of each period</p>
</td></tr>
<tr><td><code id="LinCombMatrix_+3A_takemean">takeMean</code></td>
<td>
<p>Calculate mean over each period (sum when FALSE)</p>
</td></tr>
<tr><td><code id="LinCombMatrix_+3A_removerows">removerows</code></td>
<td>
<p>Revove incomplete rows</p>
</td></tr>
<tr><td><code id="LinCombMatrix_+3A_overlap">overlap</code></td>
<td>
<p>Overlap between periods (moving averages)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Linear combination matrix
</p>


<h3>Note</h3>

<p>It can be useful to add row names to the resulting matrix before
further use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# We assume two years of four quarters (n=8)

# Quarter to quarter differences
LagDiff(8)

# Changes from same quarter last year
LagDiff(8,4)

# Yearly averages
Period(8,4)

# Moving yearly averages
Period(8,4,overlap=TRUE)

# Difference between yearly averages
PeriodDiff(8,4) # Also try n=16 with overlap=TRUE/FALSE

# Combine two variants and add row names
lc = rbind(LagDiff(8,4),PeriodDiff(8,4))
rownames(lc) = c("diffQ1","diffQ2","diffQ3","diffQ4","diffYearMean")
lc

</code></pre>

<hr>
<h2 id='MatchVarNames'>MatchVarNames</h2><span id='topic+MatchVarNames'></span>

<h3>Description</h3>

<p>MatchVarNames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatchVarNames(x, y, sep = ":", makeWarning = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MatchVarNames_+3A_x">x</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="MatchVarNames_+3A_y">y</code></td>
<td>
<p>y</p>
</td></tr>
<tr><td><code id="MatchVarNames_+3A_sep">sep</code></td>
<td>
<p>sep</p>
</td></tr>
<tr><td><code id="MatchVarNames_+3A_makewarning">makeWarning</code></td>
<td>
<p>Warning when matching by reordering</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector giving the position in y of the first match if there is a match, otherwise NA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- data.frame(A = factor(c("a", "b", "c")), B = factor(1:2), C = 1:6)
x &lt;- colnames(model.matrix(~B * C * A, z))
y &lt;- colnames(model.matrix(~A * B + A:B:C, z))
MatchVarNames(x, y)
</code></pre>

<hr>
<h2 id='OrderedVarNames'>OrderedVarNames</h2><span id='topic+OrderedVarNames'></span>

<h3>Description</h3>

<p>OrderedVarNames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OrderedVarNames(x, sep = ":")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OrderedVarNames_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="OrderedVarNames_+3A_sep">sep</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>output
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- data.frame(A = factor(c("a", "b", "c")), B = factor(1:2), C = 1:6)
x &lt;- colnames(model.matrix(~B * C * A, z))
OrderedVarNames(x)
</code></pre>

<hr>
<h2 id='PanelEstimation'>Variance estimation for panel data</h2><span id='topic+PanelEstimation'></span>

<h3>Description</h3>

<p>Variance estimation of linear combinations of totals and ratios based on
output from wideFromCalibrate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PanelEstimation(
  x,
  numerator,
  denominator = NULL,
  linComb = matrix(0, 0, n),
  linComb0 = NULL,
  estType = "robustModel",
  leveragePower = 1/2,
  group = NULL,
  returnCov = FALSE,
  usewGross = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PanelEstimation_+3A_x">x</code></td>
<td>
<p>Output from wideFromCalibrate.</p>
</td></tr>
<tr><td><code id="PanelEstimation_+3A_numerator">numerator</code></td>
<td>
<p>y variable name or number.</p>
</td></tr>
<tr><td><code id="PanelEstimation_+3A_denominator">denominator</code></td>
<td>
<p>y variable name or number.</p>
</td></tr>
<tr><td><code id="PanelEstimation_+3A_lincomb">linComb</code></td>
<td>
<p>Matrix defining linear combinations of waves.</p>
</td></tr>
<tr><td><code id="PanelEstimation_+3A_lincomb0">linComb0</code></td>
<td>
<p>Linear combination matrix to be used prior to ratio
calculations.</p>
</td></tr>
<tr><td><code id="PanelEstimation_+3A_esttype">estType</code></td>
<td>
<p>Estimation type: &quot;robustModel&quot; (default), &quot;ssbAKU&quot;,
&quot;robustModelww&quot;, &quot;robustModelGroup&quot; or &quot;robustModelGroupww&quot; (see below)</p>
</td></tr>
<tr><td><code id="PanelEstimation_+3A_leveragepower">leveragePower</code></td>
<td>
<p>Power used when adjusting residuals using leverages.</p>
</td></tr>
<tr><td><code id="PanelEstimation_+3A_group">group</code></td>
<td>
<p>Extra variable name or number for cluster robust estimation.</p>
</td></tr>
<tr><td><code id="PanelEstimation_+3A_returncov">returnCov</code></td>
<td>
<p>Return covariance matrices instead of variance vectors.</p>
</td></tr>
<tr><td><code id="PanelEstimation_+3A_usewgross">usewGross</code></td>
<td>
<p>Use wGross (if avaliable) instead of design weights to
adjust covariance matrix in the case of NA popTotals</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When denominator=NULL, only estimates for a single y-variable (numerator)
are calculated. When denominator is specified, estimates for numerator,
denominator and ratio are calculated. The default estimation type parameter,
&quot;robustModel&quot;, is equation (12) in paper. &quot;ssbAKU&quot; is (16), &quot;robustModelww&quot;
is (9) and &quot;robustModelGroup&quot; and &quot;robustModelGroupww&quot; are cluster robust
variants based on <code class="reqn">(w-1)^2</code> and <code class="reqn">w^2</code> .
</p>


<h3>Value</h3>

<table>
<tr><td><code>wTot</code></td>
<td>
<p>Sum of weights</p>
</td></tr> <tr><td><code>estimates</code></td>
<td>
<p>Ordinary estimates</p>
</td></tr>
<tr><td><code>linCombs</code></td>
<td>
<p>Estimates of linear combinations</p>
</td></tr>
<tr><td><code>varEstimates</code></td>
<td>
<p>Variance of estimates</p>
</td></tr> <tr><td><code>varLinCombs</code></td>
<td>
<p>Variance of
estimates of linear combinations</p>
</td></tr></table>
<p> When denominator is specified the above
output refer to ratios. Then, similar output for numerator and denominator
are also included.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalibrateSSB">CalibrateSSB</a></code>, <code><a href="#topic+CalSSBobj">CalSSBobj</a></code>, <code><a href="#topic+WideFromCalibrate">WideFromCalibrate</a></code>, <code><a href="#topic+CalibrateSSBpanel">CalibrateSSBpanel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generates data  - two years
z    = AkuData(3000)  # 3000 in each quarter
zPop = AkuData(10000)[,1:7]

# Calibration and "WideFromCalibrate"
b = CalibrateSSB(z,calmodel="~ sex*age", partition=c("year","q"),
        popData=zPop, y=c("unemployed","workforce"))
bWide = WideFromCalibrate(b,CrossStrata(z[,c("year","q")]),z$id)

# Define linear combination matrix
lc = rbind(LagDiff(8,4),PeriodDiff(8,4))
rownames(lc) = c("diffQ1","diffQ2","diffQ3","diffQ4","diffYearMean")
colnames(lc) = colnames(head(bWide$y[[1]]))
lc

# Unemployed: Totals and linear combinations
d1=PanelEstimation(bWide,"unemployed",linComb=lc)  #

# Table of output
cbind(tot=d1$estimates,se=sqrt(d1$varEstimates))
cbind(tot=d1$linCombs,se=sqrt(d1$varLinCombs))

# Ratio: Totals and linear combinations
d=PanelEstimation(bWide,numerator="unemployed",denominator="workforce",linComb=lc)
cbind(tot=d$estimates,se=sqrt(d$varEstimates))
cbind(tot=d$linCombs,se=sqrt(d$varLinCombs))

## Not run: 
# Calibration when som population totals unknown (edu)
# Leverages in output (will be used to adjust residuals)
# Cluster robust estimation (families/famid)
b2 = CalibrateSSB(z,popData=zPop,calmodel="~ edu*sex + sex*age",
           partition=c("year","q"), y=c("unemployed","workforce"),
           leverageOutput=TRUE)
b2Wide = WideFromCalibrate(b2,CrossStrata(z[,c("year","q")]),z$id,extra=z$famid)
d2 = PanelEstimation(b2Wide,"unemployed",linComb=lc,group=1,estType = "robustModelGroup")
cbind(tot=d2$linCombs,se=sqrt(d2$varLinCombs))

## End(Not run)


# Yearly mean before ratio calculation (linComb0)
# and difference between years (linComb)
g=PanelEstimation(bWide,numerator="unemployed",denominator="workforce",
    linComb= LagDiff(2),linComb0=Period(8,4))
cbind(tot=g$linCombs,se=sqrt(g$varLinCombs))

</code></pre>

<hr>
<h2 id='print.calSSB'>Print method for calSSB</h2><span id='topic+print.calSSB'></span>

<h3>Description</h3>

<p>Print method for calSSB
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calSSB'
print(x, digits = max(getOption("digits") - 3, 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.calSSB_+3A_x">x</code></td>
<td>
<p>calSSB object</p>
</td></tr>
<tr><td><code id="print.calSSB_+3A_digits">digits</code></td>
<td>
<p>positive integer.  Minimum number of significant digits to be used for printing most numbers.</p>
</td></tr>
<tr><td><code id="print.calSSB_+3A_...">...</code></td>
<td>
<p>further arguments sent to the underlying</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the original object.
</p>

<hr>
<h2 id='print.calSSBwide'>Print method for calSSBwide</h2><span id='topic+print.calSSBwide'></span>

<h3>Description</h3>

<p>Print method for calSSBwide
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calSSBwide'
print(x, digits = max(getOption("digits") - 3, 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.calSSBwide_+3A_x">x</code></td>
<td>
<p>calSSBwide object</p>
</td></tr>
<tr><td><code id="print.calSSBwide_+3A_digits">digits</code></td>
<td>
<p>positive integer.  Minimum number of significant digits to be used for printing most numbers.</p>
</td></tr>
<tr><td><code id="print.calSSBwide_+3A_...">...</code></td>
<td>
<p>further arguments sent to the underlying</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the original object.
</p>

<hr>
<h2 id='testDataBasis'>testDataBasis</h2><span id='topic+testDataBasis'></span>

<h3>Description</h3>

<p>Data used by <code><a href="#topic+AkuData">AkuData</a></code>
</p>

<hr>
<h2 id='WideFromCalibrate'>Rearrange output from CalibrateSSB (calSSB object). Ready for input to PanelEstimation.</h2><span id='topic+WideFromCalibrate'></span>

<h3>Description</h3>

<p>One row for each id and one column for each wave.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WideFromCalibrate(a, wave = NULL, id = NULL, subSet = NULL, extra = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WideFromCalibrate_+3A_a">a</code></td>
<td>
<p>A calSSB object. That is, output from CalibrateSSB() or CalSSBobj().</p>
</td></tr>
<tr><td><code id="WideFromCalibrate_+3A_wave">wave</code></td>
<td>
<p>Time or another repeat variable.</p>
</td></tr>
<tr><td><code id="WideFromCalibrate_+3A_id">id</code></td>
<td>
<p>Identifier variable.</p>
</td></tr>
<tr><td><code id="WideFromCalibrate_+3A_subset">subSet</code></td>
<td>
<p>Grouping variable for splitting ouput.</p>
</td></tr>
<tr><td><code id="WideFromCalibrate_+3A_extra">extra</code></td>
<td>
<p>Dataset with extra variables not in <code>a</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When wave, id or extra is NULL, corresponding elements in the input object (<code>a</code>) will be used if available,
</p>


<h3>Value</h3>

<p>Output has the same elements (+ extra) as input (a), but rearranged.
When subSet is input otput is alist according to the subSet levels.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalibrateSSB">CalibrateSSB</a></code>, <code><a href="#topic+CalSSBobj">CalSSBobj</a></code>, <code><a href="#topic+PanelEstimation">PanelEstimation</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# See examples in PanelEstimation and CalSSBobj

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
