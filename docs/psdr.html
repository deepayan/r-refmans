<!DOCTYPE html><html lang="en"><head><title>Help for package psdr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {psdr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AutomatedCompositePlotting'><p>Automated plotting of time series, PSD, and log transformed PSD</p></a></li>
<li><a href='#CountWindows'><p>Create a contingency table to display how many windows (dataframes) fall into particular categories</p></a></li>
<li><a href='#FindHomogeneousWindows'><p>Assess if window (dataframe) share certain features across all observations</p></a></li>
<li><a href='#GenerateExampleData'><p>Produce example data set for demonstrating package functions</p></a></li>
<li><a href='#GetHomogeneousWindows'><p>Get windows (dataframes) that have the same specified column values for all observations</p></a></li>
<li><a href='#GetSubsetOfWindows'><p>Select only windows (dataframes) where a specified column matches a specified value</p></a></li>
<li><a href='#GetSubsetOfWindowsTwoLevels'><p>Select only windows (dataframes) where a two specified columns must match specified values</p></a></li>
<li><a href='#IdentifyMaxOnXY'><p>Given a xy plot. Find the maximum value on the plot</p></a></li>
<li><a href='#MakeCompositePSDForAllWindows'><p>Make PSD for each window (dataframe) in a list and then find the average of all the PSDs</p></a></li>
<li><a href='#MakeCompositeXYPlotForAllWindows'><p>Find averaged xy plots</p></a></li>
<li><a href='#MakeOneSidedAmplitudeSpectrum'><p>Create a one sided amplitude spectrum using time series data</p></a></li>
<li><a href='#MakePowerSpectralDensity'><p>Create a power spectral density (PSD) plot using time series data</p></a></li>
<li><a href='#PSDDominantFrequencyForMultipleWindows'><p>Calculate dominant frequency for multiple PSDs for a single frequency range</p></a></li>
<li><a href='#PSDIdentifyDominantFrequency'><p>Given a time series vector, create a PSD and find the dominant frequency</p></a></li>
<li><a href='#PSDIntegrationPerFreqBin'><p>Given a time series vector, generate a PSD, then calculate integration for specified bins</p></a></li>
<li><a href='#SingleBinPSDIntegrationForMultipleWindows'><p>Calculate integral for multiple PSDs for a single frequency bin</p></a></li>
<li><a href='#SingleBinPSDIntegrationOrDominantFreqComparison'><p>Given sets of windows (dataframes) corresponding to different combos, see if the integration</p>
or dominant frequency of a specific frequency range is significantly different between the combos</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Use Time Series to Generate and Compare Power Spectral Density</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions that allow you to generate and compare power spectral density (PSD) 
	plots given time series data. Fast Fourier Transform (FFT) is used to take a time series 
	data, analyze the oscillations, and then output the frequencies of these oscillations 
	in the time series in the form of a PSD plot.Thus given a time series, the dominant 
	frequencies in the time series can be identified. Additional functions in this package 
	allow the dominant frequencies of multiple groups of time series to be compared with each other. 
	To see example usage with the main functions of this package, please visit
	this site: <a href="https://yhhc2.github.io/psdr/articles/Introduction.html">https://yhhc2.github.io/psdr/articles/Introduction.html</a>. 
	The mathematical operations used to generate the PSDs are described in these sites:
	<a href="https://www.mathworks.com/help/matlab/ref/fft.html">https://www.mathworks.com/help/matlab/ref/fft.html</a>.
	<a href="https://www.mathworks.com/help/signal/ug/power-spectral-density-estimates-using-fft.html">https://www.mathworks.com/help/signal/ug/power-spectral-density-estimates-using-fft.html</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a> | file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>devtools (&ge; 2.4.1), ggplot2 (&ge; 3.3.2), qpdf (&ge; 1.1), stats
(&ge; 4.0.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-06-03 17:25:57 UTC; hankc</td>
</tr>
<tr>
<td>Author:</td>
<td>Yong-Han Hank Cheng
    <a href="https://orcid.org/0000-0001-7686-0697"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yong-Han Hank Cheng &lt;yhhc@uw.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-06-04 07:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AutomatedCompositePlotting'>Automated plotting of time series, PSD, and log transformed PSD</h2><span id='topic+AutomatedCompositePlotting'></span>

<h3>Description</h3>

<p>This function uses a lot of the functions in this package (psdr) to automate the
plotting process for plotting composite curves and having multiple curves
on the same plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AutomatedCompositePlotting(
  list.of.windows,
  name.of.col.containing.time.series,
  x_start = 0,
  x_end,
  x_increment,
  level1.column.name,
  level2.column.name,
  level.combinations,
  level.combinations.labels,
  plot.title,
  plot.xlab,
  plot.ylab,
  combination.index.for.envelope = NULL,
  TimeSeries.PSD.LogPSD = "TimeSeries",
  sampling_frequency = NULL,
  my.colors = c("blue", "red", "black", "green", "gold", "darkorchid1", "brown",
    "deeppink", "gray")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AutomatedCompositePlotting_+3A_list.of.windows">list.of.windows</code></td>
<td>
<p>A list of windows (dataframes). All windows should have the same length, but because interpolation is used, the function still works if window length differs.</p>
</td></tr>
<tr><td><code id="AutomatedCompositePlotting_+3A_name.of.col.containing.time.series">name.of.col.containing.time.series</code></td>
<td>
<p>A string that specifies the name of the column in the windows that correspond to the time series that should be used.</p>
</td></tr>
<tr><td><code id="AutomatedCompositePlotting_+3A_x_start">x_start</code></td>
<td>
<p>Numeric value specifying start of the new x-axis. Default is 0.</p>
</td></tr>
<tr><td><code id="AutomatedCompositePlotting_+3A_x_end">x_end</code></td>
<td>
<p>Numeric value specifying end of the new x-axis. For PSD, maximum value is the sampling_frequency divided by 2.</p>
</td></tr>
<tr><td><code id="AutomatedCompositePlotting_+3A_x_increment">x_increment</code></td>
<td>
<p>Numeric value specifying increment of the new x-axis.</p>
</td></tr>
<tr><td><code id="AutomatedCompositePlotting_+3A_level1.column.name">level1.column.name</code></td>
<td>
<p>A String that specifies the column name to use for the first level. This column should only contain one unique value within each window.</p>
</td></tr>
<tr><td><code id="AutomatedCompositePlotting_+3A_level2.column.name">level2.column.name</code></td>
<td>
<p>A String that specifies the column name to use for the second level. This column should only contain one unique value within each window.</p>
</td></tr>
<tr><td><code id="AutomatedCompositePlotting_+3A_level.combinations">level.combinations</code></td>
<td>
<p>A List containing Lists. Each list that it contains has two vectors. The first vector specifying the values for level1 and the second vector specifying the values for level2. Each list element will correspond to a new line on the plot.</p>
</td></tr>
<tr><td><code id="AutomatedCompositePlotting_+3A_level.combinations.labels">level.combinations.labels</code></td>
<td>
<p>A vector of strings that labels each combination. This is used for making the figure legend.</p>
</td></tr>
<tr><td><code id="AutomatedCompositePlotting_+3A_plot.title">plot.title</code></td>
<td>
<p>String for title of plot.</p>
</td></tr>
<tr><td><code id="AutomatedCompositePlotting_+3A_plot.xlab">plot.xlab</code></td>
<td>
<p>String for x-axis of plot.</p>
</td></tr>
<tr><td><code id="AutomatedCompositePlotting_+3A_plot.ylab">plot.ylab</code></td>
<td>
<p>String for y-axis of plot.</p>
</td></tr>
<tr><td><code id="AutomatedCompositePlotting_+3A_combination.index.for.envelope">combination.index.for.envelope</code></td>
<td>
<p>A numeric value that specifies which combination (index of level.combinations) should have a line with an error envelope. The default is no envelope.</p>
</td></tr>
<tr><td><code id="AutomatedCompositePlotting_+3A_timeseries.psd.logpsd">TimeSeries.PSD.LogPSD</code></td>
<td>
<p>A String with 3 possible values to specify what type of plot to create from the time series: 1. &quot;TimeSeries&quot;, 2. &quot;PSD&quot;, 3. &quot;LogPSD&quot;</p>
</td></tr>
<tr><td><code id="AutomatedCompositePlotting_+3A_sampling_frequency">sampling_frequency</code></td>
<td>
<p>Numeric value used for specifying sampling frequency if PSD or LogPSD is made with this function. Default is NULL because default plot created is a time series plot.</p>
</td></tr>
<tr><td><code id="AutomatedCompositePlotting_+3A_my.colors">my.colors</code></td>
<td>
<p>A vector of strings that specify the color for each line. 9 default values are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a list of windows, you can specify which windows you want to average together
to form a curve on the plot. You can specify multiple combos and therefore multiple
curves can be plotted on the same plot with a legend to specify the combo
used to create each curve. An error envelope can also be created for a single curve
on the plot.
</p>
<p>The function automatically generates a ggplot
for easy plotting. However, the function also outputs dataframes for each combo.
Each dataframe has 3 columns:
</p>

<ol>
<li><p> X value: For timeseries, this will be in the original units that separates
each observation in the time series. For example, if there are 150 observations
and each observation is 0.02 seconds apart, then if 150 observations are
specified as the x_increment, then each observation are still 0.02 seconds.
The time difference between the first and last observation needs to equal the
time difference between the first and last observation in the original time series.
For PSD and LogPSd, the units will be in Hz (frequency). The frequency range
depends on the sampling frequency. Smallest frequency is 0 and largest frequency
is sampling_frequency/2.
</p>
</li>
<li><p> Y value: For time series, this will be in the original units of the time series.
For PSD, the units will be (original units)^2/Hz, for LogPSD, the units will be
log((original units)^2/Hz)).
</p>
</li>
<li><p> Standard deviation of Y value. This can be used to plot error bars
or error envelopes to see the spread of the windows used to make the composite.
</p>
</li></ol>

<p>Three different plots can be created:
</p>

<ol>
<li><p> Time series plot. This simply takes the time series in the windows, averages them for each combo, and then plots the composite curve for each combo.
</p>
</li>
<li><p> PSD plot. This takes the time series in the windows and given the sampling frequency, it calculates the PSD. It averages the PSD for the windows in each combo, and then plots the composite curve for each combo.
</p>
</li>
<li><p> Log transformed PSD plot. Same as PSD plot except at the end, the composite PSD curves are log transformed.
</p>
</li></ol>



<h3>Value</h3>

<p>A List with three objects:
</p>

<ol>
<li><p> A List of dataframes containing values for each line on the plot. The order of the dataframes correspond to the order of the combinations in level.combinations.
</p>
</li>
<li><p> A ggplot object that can be plotted right away.
</p>
</li>
<li><p> If plot selected is a PSD, then a List is outputted from
SingleBinPSDIntegrationOrDominantFreqComparison() to compare
dominant frequencies between combinations.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>
#I want to create a plot that shows two curves:
#1. Composite of time series signals 1, 2, and 3.
#2. Composite of time series signals 3 and 4.

#Create a vector of time that represent times where data are sampled.
Fs = 100; #sampling frequency in Hz
T = 1/Fs; #sampling period
L = 1000; #length of time vector
t = (0:(L-1))*T; #time vector

#First signal
#1. 1 Hz with amplitude of 2
S1 &lt;- 2*sin(2*pi*1*t)
level1.vals &lt;- rep("a", length(S1))
level2.vals &lt;- rep("1", length(S1))
S1.data.frame &lt;- as.data.frame(cbind(t, S1, level1.vals, level2.vals))
colnames(S1.data.frame) &lt;- c("Time", "Signal", "level1.ID", "level2.ID")
S1.data.frame[,"Signal"] &lt;- as.numeric(S1.data.frame[,"Signal"])

#Second signal
#1. 1 Hz with amplitude of -4
#2. 2 Hz with amplitude of -2
S2 &lt;- (-4)*sin(2*pi*1*t) - 2*sin(2*pi*2*t);
level1.vals &lt;- rep("a", length(S2))
level2.vals &lt;- rep("2", length(S2))
S2.data.frame &lt;- as.data.frame(cbind(t, S2, level1.vals, level2.vals))
colnames(S2.data.frame) &lt;- c("Time", "Signal", "level1.ID", "level2.ID")
S2.data.frame[,"Signal"] &lt;- as.numeric(S2.data.frame[,"Signal"])

#Third signal
#1. 1 Hz with amplitude of 2
#2. 2 Hz with amplitude of 2
S3 &lt;- 2*sin(2*pi*1*t) + 2*sin(2*pi*2*t);
level1.vals &lt;- rep("a", length(S3))
level2.vals &lt;- rep("3", length(S3))
S3.data.frame &lt;- as.data.frame(cbind(t, S3, level1.vals, level2.vals))
colnames(S3.data.frame) &lt;- c("Time", "Signal", "level1.ID", "level2.ID")
S3.data.frame[,"Signal"] &lt;- as.numeric(S3.data.frame[,"Signal"])

#Fourth signal
#1. 1 Hz with amplitude of -2
S4 &lt;- -2*sin(2*pi*1*t)
level1.vals &lt;- rep("b", length(S4))
level2.vals &lt;- rep("3", length(S4))
S4.data.frame &lt;- as.data.frame(cbind(t, S4, level1.vals, level2.vals))
colnames(S4.data.frame) &lt;- c("Time", "Signal", "level1.ID", "level2.ID")
S4.data.frame[,"Signal"] &lt;- as.numeric(S4.data.frame[,"Signal"])

windows &lt;- list(S1.data.frame, S2.data.frame, S3.data.frame, S4.data.frame)

#Gets the composite of the first, second, and third signal. Should result in a flat signal.
FirstComboToUse &lt;- list( c("a"), c(1, 2, 3) )

#Gets the composite of the third and fourth signal
SecondComboToUse &lt;- list( c("a", "b"), c(3) )


#Timeseries-----------------------------------------------------------------

timeseries.results &lt;- AutomatedCompositePlotting(list.of.windows = windows,
                           name.of.col.containing.time.series = "Signal",
                           x_start = 0,
                           x_end = 999,
                           x_increment = 1,
                           level1.column.name = "level1.ID",
                           level2.column.name = "level2.ID",
                           level.combinations = list(FirstComboToUse, SecondComboToUse),
                           level.combinations.labels = c("Signal 1 + 2 + 3", "Signal 3 + 4"),
                           plot.title = "Example",
                           plot.xlab = "Time",
                           plot.ylab = "Original units",
                           combination.index.for.envelope = NULL,
                           TimeSeries.PSD.LogPSD = "TimeSeries",
                           sampling_frequency = NULL)

ggplot.obj.timeseries &lt;- timeseries.results[[2]]

#Plot. Will see the 1+2+3 curve as a flat line. The 3+4 curve will only have 2 Hz.
##dev.new()
ggplot.obj.timeseries

#PSD-------------------------------------------------------------------------

#Note that the PSDs are not generated directly from the "Signal 1 + 2 + 3" and
#the "Signal 3 + 4" time series. Instead, PSDs are generated individually
#for signals 1, 2, 3, and 4, and then then are summed together.

PSD.results &lt;- AutomatedCompositePlotting(list.of.windows = windows,
                           name.of.col.containing.time.series = "Signal",
                           x_start = 0,
                           x_end = 50,
                           x_increment = 0.01,
                           level1.column.name = "level1.ID",
                           level2.column.name = "level2.ID",
                           level.combinations = list(FirstComboToUse, SecondComboToUse),
                           level.combinations.labels = c("Signal 1 + 2 + 3", "Signal 3 + 4"),
                           plot.title = "Example",
                           plot.xlab = "Hz",
                           plot.ylab = "(Original units)^2/Hz",
                           combination.index.for.envelope = 2,
                           TimeSeries.PSD.LogPSD = "PSD",
                           sampling_frequency = 100)

ggplot.obj.PSD &lt;- PSD.results[[2]]

#Plot. For both plots, two peaks will be present, 1 Hz and 2 Hz. 1 Hz should be
#stronger in both cases because more signals have this frequency (even if amp is negative).
#Error envelope is specified for the second (red) curve. Envelope should only
#be present for 2 Hz signal.
#dev.new()
ggplot.obj.PSD

#PSD Zoomed in---------------------------------------------------------------

PSD.results &lt;- AutomatedCompositePlotting(list.of.windows = windows,
                           name.of.col.containing.time.series = "Signal",
                           x_start = 0,
                           x_end = 5,
                           x_increment = 0.01,
                           level1.column.name = "level1.ID",
                           level2.column.name = "level2.ID",
                           level.combinations = list(FirstComboToUse, SecondComboToUse),
                           level.combinations.labels = c("Signal 1 + 2 + 3", "Signal 3 + 4"),
                           plot.title = "Example",
                           plot.xlab = "Hz",
                           plot.ylab = "(Original units)^2/Hz",
                           combination.index.for.envelope = 2,
                           TimeSeries.PSD.LogPSD = "PSD",
                           sampling_frequency = 100)

ggplot.obj.PSD &lt;- PSD.results[[2]]

#Plot. For both plots, two peaks will be present, 1 Hz and 2 Hz. 1 Hz should be
#stronger in both cases because more signals have this frequency (even if amp is negative).
#Error envelope is specified for the second (red) curve. Envelope should only
#be present for 1 Hz signal.
#dev.new()
ggplot.obj.PSD

#LogPSD-------------------------------------------------------------------------

LogPSD.results &lt;- AutomatedCompositePlotting(list.of.windows = windows,
                           name.of.col.containing.time.series = "Signal",
                           x_start = 0,
                           x_end = 50,
                           x_increment = 0.01,
                           level1.column.name = "level1.ID",
                           level2.column.name = "level2.ID",
                           level.combinations = list(FirstComboToUse, SecondComboToUse),
                           level.combinations.labels = c("Signal 1 + 2 + 3", "Signal 3 + 4"),
                           plot.title = "Example",
                           plot.xlab = "Hz",
                           plot.ylab = "log((Original units)^2/Hz)",
                           combination.index.for.envelope = NULL,
                           TimeSeries.PSD.LogPSD = "LogPSD",
                           sampling_frequency = 100)

ggplot.obj.LogPSD &lt;- LogPSD.results[[2]]

#Plot. For both plots, two peaks will be present, 1 Hz and 2 Hz. 1 Hz should
#be stronger in both cases because more signals have this frequency (even if amp is negative).
#Error envelope is specified for the second (red) curve. Envelope should only
#be present for 2 Hz signal.
#dev.new()
ggplot.obj.LogPSD

</code></pre>

<hr>
<h2 id='CountWindows'>Create a contingency table to display how many windows (dataframes) fall into particular categories</h2><span id='topic+CountWindows'></span>

<h3>Description</h3>

<p>Given a List of homogeneous windows (dataframes where the two selected columns in each dataframe only
have one unique value), make a contingency table to show how many windows fall into each of the
categories in level1 and level2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CountWindows(
  list.of.windows,
  level1.column.name,
  level2.column.name,
  level1.categories,
  level2.categories
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CountWindows_+3A_list.of.windows">list.of.windows</code></td>
<td>
<p>A list of windows (dataframes) and each window can only have a single unique value for the two specified columns.</p>
</td></tr>
<tr><td><code id="CountWindows_+3A_level1.column.name">level1.column.name</code></td>
<td>
<p>A String that specifies the column name to use for the first level of the contingency table. This column should only contain one unique value within each window.</p>
</td></tr>
<tr><td><code id="CountWindows_+3A_level2.column.name">level2.column.name</code></td>
<td>
<p>A String that specifies the column name to use for the second level of the contingency table. This column should only contain one unique value within each window.</p>
</td></tr>
<tr><td><code id="CountWindows_+3A_level1.categories">level1.categories</code></td>
<td>
<p>A vector that specifies the possible labels in the level1 column. This will be used as the rows of the outputted matrix.</p>
</td></tr>
<tr><td><code id="CountWindows_+3A_level2.categories">level2.categories</code></td>
<td>
<p>A vector that specifies the possible labels in the level2 column. This will be used as the columns of the outputted matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A List of homogeneous windows is inputted. For each window in the list, the columns specified by
level1.column.name and level2.column.name can only have one value (definition of homogeneous
window). The value of the level1.column and level2.column for each window is evaluated
and the number of windows in each category is captured and outputted as a 2D matrix
with level1 as the row labels and level2 as the column labels.
</p>


<h3>Value</h3>

<p>A matrix which is formatted as a contingency table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Example using a dataframe with 5 homogeneous windows.

#Windows are homogeneous if looking at col.two and col.three values.
window.name.column &lt;- c(10, 10, 10, 20, 20, 20, 30, 30, 30, 30, 40, 40, 50, 50, 50, 50)
col.two &lt;- c("a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "b", "b", "a", "a", "a", "a")
col.three &lt;- c(1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 3, 3, 3, 3)

multi.window.data &lt;- data.frame(window.name.column, col.two, col.three)

list.of.homogeneous.windows &lt;- GetHomogeneousWindows(multi.window.data,
"window.name.column", c("col.two", "col.three"))

matrix &lt;- CountWindows(list.of.homogeneous.windows, "col.two", "col.three",
c("a", "b"), c("1", "2", "3"))

matrix


</code></pre>

<hr>
<h2 id='FindHomogeneousWindows'>Assess if window (dataframe) share certain features across all observations</h2><span id='topic+FindHomogeneousWindows'></span>

<h3>Description</h3>

<p>For a given window (dataframe of observations where rows are observations),
evaluate whether all observations in the window share the same values for
specified columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindHomogeneousWindows(inputted.data, names.of.columns.to.look.at)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FindHomogeneousWindows_+3A_inputted.data">inputted.data</code></td>
<td>
<p>A dataframe.</p>
</td></tr>
<tr><td><code id="FindHomogeneousWindows_+3A_names.of.columns.to.look.at">names.of.columns.to.look.at</code></td>
<td>
<p>A vector of strings with each string being the name of a column in the datafarame to look at.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a dataframe, look at the values in each of the specified column and
sees if there is only one level in the specified column. If there is only
one level, then this means rows share the same value for that column.
Do this for all specified columns and return true if each column only
contains one value. If all observations share the same value for the
specified columns, then the window is considered a homogeneous window.
</p>


<h3>Value</h3>

<p>Boolean (true/false) indicating if window is homogeneous.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
col.one &lt;- c(1, 2, 3, 4, 5)
col.two &lt;- c("a", "a", "a", "a", "a")
col.three &lt;- c(1, 1, 1, 1, 1)

single.window.data &lt;- data.frame(col.one, col.two, col.three)

#Example of inhomogeneous window if looking at col.one and col.two because
#col.one does not only have a single unique value.
result &lt;- FindHomogeneousWindows(single.window.data , c("col.one", "col.two"))

result

#Example of homogeneous window if looking at col.two and col.three because
#col.two and col.three both only have a single unique value.
result &lt;- FindHomogeneousWindows(single.window.data , c("col.two", "col.three"))

result


</code></pre>

<hr>
<h2 id='GenerateExampleData'>Produce example data set for demonstrating package functions</h2><span id='topic+GenerateExampleData'></span>

<h3>Description</h3>

<p>Produce example data set for demonstrating package functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenerateExampleData()
</code></pre>


<h3>Value</h3>

<p>A data frame
</p>

<hr>
<h2 id='GetHomogeneousWindows'>Get windows (dataframes) that have the same specified column values for all observations</h2><span id='topic+GetHomogeneousWindows'></span>

<h3>Description</h3>

<p>For a given dataframe where the windows are specified by a column in the dataframe,
evaluate whether all observations in each window share the same values for
specified columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetHomogeneousWindows(
  inputted.data,
  window.ID.col.name,
  observation.vals.to.compare
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetHomogeneousWindows_+3A_inputted.data">inputted.data</code></td>
<td>
<p>A dataframe that needs a column that labels which window each observation belongs to.</p>
</td></tr>
<tr><td><code id="GetHomogeneousWindows_+3A_window.id.col.name">window.ID.col.name</code></td>
<td>
<p>A string that specifies the column name of the column that provides the window name.</p>
</td></tr>
<tr><td><code id="GetHomogeneousWindows_+3A_observation.vals.to.compare">observation.vals.to.compare</code></td>
<td>
<p>A vector of strings with each string being the name of a column in the datafarame to look at.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function takes a single dataframe with each row as observations. This dataframe
needs a column that specifies which window each observation belongs
to. For each window, the observations within the window is evaluated to see
if all observations share the same values for specified columns of the dataframe.
Windows where the specified columns have the same values across all observations
are labeled as &quot;homogeneous&quot; windows and are captured and outputted in a list,
where each element is a window (dataframe). This function uses the
FindHomogeneousWindows() function to determine whether each window is
homogeneous. As the code executes, it outputs number indicating how many
homogeneous windows have been found so far in the inputted.data.
</p>


<h3>Value</h3>

<p>List where each object is a homogeneous window (dataframe) that has observations sharing the same values for the
observation.vals.to.compare column(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Example using a dataframe with 3 windows.

#Windows 20 and 30 are homogeneous if looking at col.two and col.three values.
window.name.column &lt;- c(10, 10, 10, 20, 20, 20, 30, 30, 30, 30)
col.two &lt;- c("a", "a", "a", "a", "a", "a", "a", "a", "a", "a")
col.three &lt;- c(1, 1, 0, 1, 1, 1, 2, 2, 2, 2)

multi.window.data &lt;- data.frame(window.name.column, col.two, col.three)

result &lt;- GetHomogeneousWindows(multi.window.data, "window.name.column", c("col.two", "col.three"))

#As expected, it looks like two windows are homogeneous.
str(result)

#Output the two windows that are homogeneous:

result[[1]]

result[[2]]


</code></pre>

<hr>
<h2 id='GetSubsetOfWindows'>Select only windows (dataframes) where a specified column matches a specified value</h2><span id='topic+GetSubsetOfWindows'></span>

<h3>Description</h3>

<p>Looks at all the windows (dataframes) in a list of homogeneous windows. And
only selects the windows where the column value contains a specified value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetSubsetOfWindows(
  list.of.windows,
  name.of.column.to.look.at.in.window,
  value.to.match.to
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetSubsetOfWindows_+3A_list.of.windows">list.of.windows</code></td>
<td>
<p>A list of windows (dataframes) and each window can only have a single unique value for the name.of.column.to.look.at.in.window column.</p>
</td></tr>
<tr><td><code id="GetSubsetOfWindows_+3A_name.of.column.to.look.at.in.window">name.of.column.to.look.at.in.window</code></td>
<td>
<p>String that specifies which column to look at.</p>
</td></tr>
<tr><td><code id="GetSubsetOfWindows_+3A_value.to.match.to">value.to.match.to</code></td>
<td>
<p>String that specifies what value to look for in name.of.column.to.look.at.in.window.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes a List of windows (dataframes) where each window is a homogeneous window,
which means in each window, there is only one unique value in the specified
column. This function looks through the homogeneous windows in the List, selects
the windows that have a specified column value in the specified column, then
puts these windows into a new List and outputs the new List of windows.
</p>


<h3>Value</h3>

<p>List containing only selected windows (windows that have value.to.match.to value in the name.of.column.to.look.at.in.window column).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Example using a dataframe with 3 windows.

#Windows 20 and 30 are homogeneous if looking at col.two and col.three values.
window.name.column &lt;- c(10, 10, 10, 20, 20, 20, 30, 30, 30, 30)
col.two &lt;- c("a", "a", "a", "a", "a", "a", "a", "a", "a", "a")
col.three &lt;- c(1, 1, 0, 1, 1, 1, 2, 2, 2, 2)

multi.window.data &lt;- data.frame(window.name.column, col.two, col.three)

list.of.homogeneous.windows &lt;- GetHomogeneousWindows(multi.window.data,
"window.name.column", c("col.two", "col.three"))

#Get a subset of windows where col.three has a value of 2
subset.list.of.homogeneous.windows &lt;- GetSubsetOfWindows(list.of.homogeneous.windows,
"col.three", "2")

str(subset.list.of.homogeneous.windows)

subset.list.of.homogeneous.windows[[1]]

</code></pre>

<hr>
<h2 id='GetSubsetOfWindowsTwoLevels'>Select only windows (dataframes) where a two specified columns must match specified values</h2><span id='topic+GetSubsetOfWindowsTwoLevels'></span>

<h3>Description</h3>

<p>Looks at all the windows (dataframes) in a list of homogeneous windows. And
only selects the windows where the column values for two columns matches
the specified values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetSubsetOfWindowsTwoLevels(
  list.of.windows,
  level1.column.name,
  level2.column.name,
  level1.categories,
  level2.categories
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetSubsetOfWindowsTwoLevels_+3A_list.of.windows">list.of.windows</code></td>
<td>
<p>A list of windows (dataframes) and each window can only have a single unique value for the two specified columns.</p>
</td></tr>
<tr><td><code id="GetSubsetOfWindowsTwoLevels_+3A_level1.column.name">level1.column.name</code></td>
<td>
<p>A String that specifies the column name to use for the first level. This column should only contain one unique value within each window.</p>
</td></tr>
<tr><td><code id="GetSubsetOfWindowsTwoLevels_+3A_level2.column.name">level2.column.name</code></td>
<td>
<p>A String that specifies the column name to use for the second level. This column should only contain one unique value within each window.</p>
</td></tr>
<tr><td><code id="GetSubsetOfWindowsTwoLevels_+3A_level1.categories">level1.categories</code></td>
<td>
<p>A vector that specifies the possible labels in the level1 column.</p>
</td></tr>
<tr><td><code id="GetSubsetOfWindowsTwoLevels_+3A_level2.categories">level2.categories</code></td>
<td>
<p>A vector that specifies the possible labels in the level2 column.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes a List of windows (dataframes) where each window is a homogeneous window,
which means in each window, there is only one unique value in the specified
column. This function looks through the homogeneous windows in the List, selects
the windows that have specified column value(s) in the first specified column, then
from the windows selected based on the first column, windows are further selected
to have specified column value(s) in the second specified column. Puts these windows
into a new List and outputs the new List of windows. Uses the
GetSubsetOfWindows() function.
</p>


<h3>Value</h3>

<p>List containing only selected windows
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example using a dataframe with 5 homogeneous windows.

#Windows are homogeneous if looking at col.two and col.three values.
window.name.column &lt;- c(10, 10, 10, 20, 20, 20, 30, 30, 30, 30, 40, 40, 50, 50, 50, 50)
col.two &lt;- c("a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "b", "b", "a", "a", "a", "a")
col.three &lt;- c(1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 3, 3, 3, 3)

multi.window.data &lt;- data.frame(window.name.column, col.two, col.three)

list.of.homogeneous.windows &lt;- GetHomogeneousWindows(multi.window.data,
"window.name.column", c("col.two", "col.three"))

result &lt;- GetSubsetOfWindowsTwoLevels(list.of.homogeneous.windows, "col.two", "col.three",
c("a"), c("1", "2"))

#Should contain windows 10, 20, 30 because col.two is "a" and col.three can be "1" or "2"
result

</code></pre>

<hr>
<h2 id='IdentifyMaxOnXY'>Given a xy plot. Find the maximum value on the plot</h2><span id='topic+IdentifyMaxOnXY'></span>

<h3>Description</h3>

<p>To generate a curve of points, interpolation is used
and the range and increment can be specified. Will output
a message if multiple maxima are detected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IdentifyMaxOnXY(x_vector, y_vector, x_start = 0, x_end, x_increment)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IdentifyMaxOnXY_+3A_x_vector">x_vector</code></td>
<td>
<p>A numerical vector with x coordinates.</p>
</td></tr>
<tr><td><code id="IdentifyMaxOnXY_+3A_y_vector">y_vector</code></td>
<td>
<p>A numerical vector with y coordinates.</p>
</td></tr>
<tr><td><code id="IdentifyMaxOnXY_+3A_x_start">x_start</code></td>
<td>
<p>Numeric value specifying start of x value to look at.</p>
</td></tr>
<tr><td><code id="IdentifyMaxOnXY_+3A_x_end">x_end</code></td>
<td>
<p>Numeric value specifying end of x value to look at.</p>
</td></tr>
<tr><td><code id="IdentifyMaxOnXY_+3A_x_increment">x_increment</code></td>
<td>
<p>Numeric value specifying the increment of the x-values to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with two elements, The first element is the x value
where the max y value is found. The second element is the max y value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#I want to create a plot that shows two curves:
#1. Composite of time series signals 1, 2, and 3.
#2. Composite of time series signals 3 and 4.

#Create a vector of time that represent times where data are sampled.
Fs = 100; #sampling frequency in Hz
T = 1/Fs; #sampling period
L = 1000; #length of time vector
t = (0:(L-1))*T; #time vector

#First signal
#1. 1 Hz with amplitude of 2
S1 &lt;- 2*sin(2*pi*1*t)
level1.vals &lt;- rep("a", length(S1))
level2.vals &lt;- rep("1", length(S1))
S1.data.frame &lt;- as.data.frame(cbind(t, S1, level1.vals, level2.vals))
colnames(S1.data.frame) &lt;- c("Time", "Signal", "level1.ID", "level2.ID")
S1.data.frame[,"Signal"] &lt;- as.numeric(S1.data.frame[,"Signal"])

#Second signal
#1. 1 Hz with amplitude of -4
#2. 2 Hz with amplitude of -2
S2 &lt;- (-4)*sin(2*pi*1*t) - 2*sin(2*pi*2*t);
level1.vals &lt;- rep("a", length(S2))
level2.vals &lt;- rep("2", length(S2))
S2.data.frame &lt;- as.data.frame(cbind(t, S2, level1.vals, level2.vals))
colnames(S2.data.frame) &lt;- c("Time", "Signal", "level1.ID", "level2.ID")
S2.data.frame[,"Signal"] &lt;- as.numeric(S2.data.frame[,"Signal"])

#Third signal
#1. 1 Hz with amplitude of 2
#2. 2 Hz with amplitude of 2
S3 &lt;- 2*sin(2*pi*1*t) + 2*sin(2*pi*2*t);
level1.vals &lt;- rep("a", length(S3))
level2.vals &lt;- rep("3", length(S3))
S3.data.frame &lt;- as.data.frame(cbind(t, S3, level1.vals, level2.vals))
colnames(S3.data.frame) &lt;- c("Time", "Signal", "level1.ID", "level2.ID")
S3.data.frame[,"Signal"] &lt;- as.numeric(S3.data.frame[,"Signal"])

#Fourth signal
#1. 1 Hz with amplitude of -2
S4 &lt;- -2*sin(2*pi*1*t)
level1.vals &lt;- rep("b", length(S4))
level2.vals &lt;- rep("3", length(S4))
S4.data.frame &lt;- as.data.frame(cbind(t, S4, level1.vals, level2.vals))
colnames(S4.data.frame) &lt;- c("Time", "Signal", "level1.ID", "level2.ID")
S4.data.frame[,"Signal"] &lt;- as.numeric(S4.data.frame[,"Signal"])

#Extra representation of S2 dataframe to show an example that has enough samples
#to have significance for Kruskal-Wallis test
windows &lt;- list(S1.data.frame, S2.data.frame, S2.data.frame, S2.data.frame, S2.data.frame,
S2.data.frame, S2.data.frame, S2.data.frame, S2.data.frame, S2.data.frame, S3.data.frame,
S4.data.frame)

#Gets the composite of the first, second, and third signal. Should result in a flat signal.
FirstComboToUse &lt;- list( c("a"), c(1, 2, 3) )

#Gets the composite of the third and fourth signal
SecondComboToUse &lt;- list( c("a", "b"), c(3) )


#PSD-------------------------------------------------------------------------

PSD.results &lt;- AutomatedCompositePlotting(list.of.windows = windows,
                           name.of.col.containing.time.series = "Signal",
                           x_start = 0,
                           x_end = 10,
                           x_increment = 0.01,
                           level1.column.name = "level1.ID",
                           level2.column.name = "level2.ID",
                           level.combinations = list(FirstComboToUse, SecondComboToUse),
                           level.combinations.labels = c("Signal 1 + 2 + 3", "Signal 3 + 4"),
                           plot.title = "Example",
                           plot.xlab = "Hz",
                           plot.ylab = "(Original units)^2/Hz",
                           combination.index.for.envelope = 2,
                           TimeSeries.PSD.LogPSD = "PSD",
                           sampling_frequency = 100)

ggplot.obj.PSD &lt;- PSD.results[[2]]

dataframes.plotted &lt;- PSD.results[[1]]

first.curve &lt;- dataframes.plotted[[1]]

second.curve &lt;- dataframes.plotted[[2]]

first.curve.max &lt;- IdentifyMaxOnXY(first.curve$xvals, first.curve$yvals, 0, 10, 0.01)
first.curve.max.limited &lt;- IdentifyMaxOnXY(first.curve$xvals, first.curve$yvals, 1.25, 2.5, 0.01)

second.curve.max &lt;- IdentifyMaxOnXY(second.curve$xvals, second.curve$yvals, 0, 10, 0.01)


</code></pre>

<hr>
<h2 id='MakeCompositePSDForAllWindows'>Make PSD for each window (dataframe) in a list and then find the average of all the PSDs</h2><span id='topic+MakeCompositePSDForAllWindows'></span>

<h3>Description</h3>

<p>Given multiple windows of time series data, if the sampling frequency for
all time series is the same, then the PSD for each window can be calculated,
and then averaged to create a composite PSD.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeCompositePSDForAllWindows(
  list.of.windows,
  name.of.col.containing.time.series,
  sampling_frequency,
  x_start = 0,
  x_end,
  x_increment
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MakeCompositePSDForAllWindows_+3A_list.of.windows">list.of.windows</code></td>
<td>
<p>A list of windows (dataframes).</p>
</td></tr>
<tr><td><code id="MakeCompositePSDForAllWindows_+3A_name.of.col.containing.time.series">name.of.col.containing.time.series</code></td>
<td>
<p>A string that specifies the name of the column in the windows that correspond to the time series that should be used for making PSD.</p>
</td></tr>
<tr><td><code id="MakeCompositePSDForAllWindows_+3A_sampling_frequency">sampling_frequency</code></td>
<td>
<p>Numeric value specifying sampling frequency in hertz. If data is sampled once every second, then sampling frequency is 1 Hz. If data is sampled once every 2 seconds, then sampling frequency is 0.5 Hz.</p>
</td></tr>
<tr><td><code id="MakeCompositePSDForAllWindows_+3A_x_start">x_start</code></td>
<td>
<p>Numeric value specifying start of the new x-axis for the averaged PSD. Default is 0 Hz.</p>
</td></tr>
<tr><td><code id="MakeCompositePSDForAllWindows_+3A_x_end">x_end</code></td>
<td>
<p>Numeric value specifying end of the new x-axis for the averaged PSD. Maximum value is the sampling_frequency divided by 2.</p>
</td></tr>
<tr><td><code id="MakeCompositePSDForAllWindows_+3A_x_increment">x_increment</code></td>
<td>
<p>Numeric value specifying increment of the new x-axis for the averaged PSD.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using fft(), the PSD of a time series dataset can be calculated.This is done
for multiple windows of time using the MakePowerSpectralDensity() function
for each window. When the code executes, a counter is displayed to indicate
how many windows have been analyzed.
</p>


<h3>Value</h3>

<p>A List with two objects:
</p>

<ol>
<li><p> Vector of frequencies in Hz. The maximum frequency should be half the sampling frequency. Called Nyquist Frequency.
</p>
</li>
<li><p> Vector of averaged PSD values corresponding with each frequency. Units should be in the original units of the data vector squared and divided by frequency.
</p>
</li>
<li><p> Vector of standard deviation of PSD values corresponding with each frequency. This can be used to generate error envelopes or error bars to show the variation between windows.
</p>
</li></ol>

<p>The vector of frequencies can be used as the x-axis values of a single sided spectrum amplitude plot.
The vector of PSD values can be used as the y-axis values of the PSD plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create a vector of time that represent times where data are sampled.
Fs = 100; #sampling frequency in Hz
T = 1/Fs; #sampling period
L = 1000; #length of time vector
t = (0:(L-1))*T; #time vector

#First signal
#1. 10 Hz with amplitude of 4
#2. 25 Hz with amplitude of 4
S1 &lt;- 1*sin(2*pi*10*t) + 2*sin(2*pi*25*t);
S1 &lt;- S1 + rnorm(length(t)) #Add some noise
S1.data.frame &lt;- as.data.frame(cbind(t, S1))
colnames(S1.data.frame) &lt;- c("Time", "Signal")

#Second signal
#1. 5 Hz with amplitude of 2
#2. 8 Hz with amplitude of 2
S2 &lt;- 2*sin(2*pi*5*t) + 2*sin(2*pi*8*t);
S2 &lt;- S2 + rnorm(length(t)) #Add some noise
S2.data.frame &lt;- as.data.frame(cbind(t, S2))
colnames(S2.data.frame) &lt;- c("Time", "Signal")

#Third signal
#1. 5 Hz with amplitude of 2
#2. 8 Hz with amplitude of 2
S3 &lt;- 2*sin(2*pi*5*t) + 2*sin(2*pi*8*t);
S3 &lt;- S3 + rnorm(length(t)) #Add some noise
S3.data.frame &lt;- as.data.frame(cbind(t, S3))
colnames(S3.data.frame) &lt;- c("Time", "Signal")

#Add all signals to a List
list.of.windows &lt;- list(S1.data.frame, S2.data.frame, S3.data.frame)

results &lt;- MakeCompositePSDForAllWindows(list.of.windows, "Signal", Fs, 0, 30, 0.1)

frequencies &lt;- results[[1]]

averaged.PSD &lt;- results[[2]]

stddev.PSD &lt;- results[[3]]

#dev.new()
plot(frequencies, averaged.PSD, type = "l")

#dev.new()
plot(frequencies, averaged.PSD, type = "l")
#Add error bars
arrows(frequencies, averaged.PSD, frequencies, averaged.PSD + stddev.PSD, length=0.05, angle=90)
arrows(frequencies, averaged.PSD, frequencies, averaged.PSD - stddev.PSD, length=0.05, angle=90)


</code></pre>

<hr>
<h2 id='MakeCompositeXYPlotForAllWindows'>Find averaged xy plots</h2><span id='topic+MakeCompositeXYPlotForAllWindows'></span>

<h3>Description</h3>

<p>If there are multiple 2D plots where the range of the x values are the same,
then this function can allow you to average the y-values for all of these plots.
The increment of the x-values can be different because this function uses interpolation
to ensure each window has the same x-axis when the averaging step occurs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeCompositeXYPlotForAllWindows(
  list.of.windows,
  name.of.col.containing.time.series,
  x_start = 0,
  x_end,
  x_increment
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MakeCompositeXYPlotForAllWindows_+3A_list.of.windows">list.of.windows</code></td>
<td>
<p>A list of windows (dataframes). Each window should have the same range of values in the x-axis in order for averaging to work.</p>
</td></tr>
<tr><td><code id="MakeCompositeXYPlotForAllWindows_+3A_name.of.col.containing.time.series">name.of.col.containing.time.series</code></td>
<td>
<p>A string that specifies the name of the column in the windows that correspond to the time series that should be used for making averaging.</p>
</td></tr>
<tr><td><code id="MakeCompositeXYPlotForAllWindows_+3A_x_start">x_start</code></td>
<td>
<p>Numeric value specifying start of the new x-axis for the averaged PSD. Default is 0, so the first observation in the time series corresponds with x = 0.</p>
</td></tr>
<tr><td><code id="MakeCompositeXYPlotForAllWindows_+3A_x_end">x_end</code></td>
<td>
<p>Numeric value specifying end of the new x-axis for the averaged PSD. Maximum value is the sampling_frequency divided by 2.</p>
</td></tr>
<tr><td><code id="MakeCompositeXYPlotForAllWindows_+3A_x_increment">x_increment</code></td>
<td>
<p>Numeric value specifying increment of the new x-axis for the averaged PSD.</p>
</td></tr>
</table>


<h3>Value</h3>


<ol>
<li><p> Vector of x values for plotting. The units will be number of observations. So if the time series has 100 observations and x_increment used is 1, then each tick mark on the x-axis corresponds to one observation unit.
</p>
</li>
<li><p> Vector of averaged y values after looking at all windows.
</p>
</li>
<li><p> Vector of standard deviation of y values for each x value.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>#Create a vector of time that represent times where data are sampled.
Fs = 100; #sampling frequency in Hz
T = 1/Fs; #sampling period
L = 1000; #length of time vector
t = (0:(L-1))*T; #time vector

#First signal
#1. 1 Hz with amplitude of 4
S1 &lt;- 4*sin(2*pi*1*t)
S1.data.frame &lt;- as.data.frame(cbind(t, S1))
colnames(S1.data.frame) &lt;- c("Time", "Signal")

#Second signal
#1. 1 Hz with amplitude of -2
#2. 2 Hz with amplitude of -2
S2 &lt;- (-2)*sin(2*pi*1*t) - 2*sin(2*pi*2*t);
S2.data.frame &lt;- as.data.frame(cbind(t, S2))
colnames(S2.data.frame) &lt;- c("Time", "Signal")

#Third signal
#1. 1 Hz with amplitude of 2
#2. 2 Hz with amplitude of 2
S3 &lt;- 2*sin(2*pi*1*t) + 2*sin(2*pi*2*t);
S3.data.frame &lt;- as.data.frame(cbind(t, S3))
colnames(S3.data.frame) &lt;- c("Time", "Signal")

#Add all signals to a List
list.of.windows &lt;- list(S1.data.frame, S2.data.frame, S3.data.frame)

results &lt;- MakeCompositeXYPlotForAllWindows(list.of.windows, "Signal", 0, 999, 1)

x.values &lt;- results[[1]]

y.values &lt;- results[[2]]

stddev.y.values &lt;- results[[3]]

#plot each xy plot individually
#dev.new()
plot(t, S1, ylim = c(-5, 5), type = "l")
lines(t, S2, col="blue")
lines(t, S3, col="green")


#plot the averaged plot
#The only curve remaining should be the 1Hz with amplitude of 4/3.
#dev.new()
plot(x.values, y.values, type = "l")

#plot averaged plot with error bars
#dev.new()
plot(x.values, y.values, type = "l")
#Add error bars
arrows(x.values, y.values, x.values, y.values + stddev.y.values, length=0.05, angle=90)
arrows(x.values, y.values, x.values, y.values - stddev.y.values, length=0.05, angle=90)


</code></pre>

<hr>
<h2 id='MakeOneSidedAmplitudeSpectrum'>Create a one sided amplitude spectrum using time series data</h2><span id='topic+MakeOneSidedAmplitudeSpectrum'></span>

<h3>Description</h3>

<p>An explanation for some of the math can be found here: https://www.mathworks.com/help/matlab/ref/fft.html
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeOneSidedAmplitudeSpectrum(sampling_frequency, data_vector)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MakeOneSidedAmplitudeSpectrum_+3A_sampling_frequency">sampling_frequency</code></td>
<td>
<p>Numeric value specifying sampling frequency in hertz. If data is sampled once every second, then sampling frequency is 1 Hz. If data is sampled once every 2 seconds, then sampling frequency is 0.5 Hz.</p>
</td></tr>
<tr><td><code id="MakeOneSidedAmplitudeSpectrum_+3A_data_vector">data_vector</code></td>
<td>
<p>Vector of numeric values. Time series vector of data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A List with two objects:
</p>

<ol>
<li><p> Vector of frequencies in Hz. The maximum frequency should be half the sampling frequency. Called Nyquist Frequency.
</p>
</li>
<li><p> Vector amplitudes corresponding with each frequency. Units should be in the original units of the data vector.
</p>
</li></ol>

<p>The vector of frequencies can be used as the x-axis values of a single sided spectrum amplitude plot.
The vector of amplitudes can be used as the y-axis values of a single sided spectrum.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Create a vector of time that represent times where data are sampled.
Fs = 100; #sampling frequency in Hz
T = 1/Fs; #sampling period
L = 1000; #length of time vector
t = (0:(L-1))*T; #time vector

#Form a signal (time series) that contains two frequencies:
#1. 10 Hz with amplitude of 1
#2. 25 Hz with amplitude of 2
S &lt;- 1*sin(2*pi*10*t) + 2*sin(2*pi*25*t);

results &lt;- MakeOneSidedAmplitudeSpectrum(Fs, S)

frequencies &lt;- results[[1]]

amplitudes &lt;- results[[2]]

#dev.new()
plot(frequencies, amplitudes, type = "l")


</code></pre>

<hr>
<h2 id='MakePowerSpectralDensity'>Create a power spectral density (PSD) plot using time series data</h2><span id='topic+MakePowerSpectralDensity'></span>

<h3>Description</h3>

<p>Dividing the results of fft() by the frequency bin width, the PSD of a time
series data set can be calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakePowerSpectralDensity(sampling_frequency, data_vector)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MakePowerSpectralDensity_+3A_sampling_frequency">sampling_frequency</code></td>
<td>
<p>Numeric value specifying sampling frequency in hertz. If data is sampled once every second, then sampling frequency is 1 Hz. If data is sampled once every 2 seconds, then sampling frequency is 0.5 Hz.</p>
</td></tr>
<tr><td><code id="MakePowerSpectralDensity_+3A_data_vector">data_vector</code></td>
<td>
<p>Vector of numeric values. Time series vector of data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If time series is a vector of accelerometer data, then the outputted y-axis will
have units of (acceleration^2)/Hz.
</p>
<p>Explanations of some of the math:
https://www.mathworks.com/help/signal/ug/power-spectral-density-estimates-using-fft.html
</p>
<p>https://blog.endaq.com/why-the-power-spectral-density-psd-is-the-gold-standard-of-vibration-analysis
</p>
<p>https://endaq.com/pages/power-spectral-density
</p>
<p>https://medium.com/analytics-vidhya/breaking-down-confusions-over-fast-fourier-transform-fft-1561a029b1ab
</p>


<h3>Value</h3>

<p>A List with two objects:
</p>

<ol>
<li><p> Vector of frequencies in Hz. The maximum frequency should be half the sampling frequency. Called Nyquist Frequency.
</p>
</li>
<li><p> Vector of PSD values corresponding with each frequency. Units should be in the original units of the data vector squared and divided by frequency.
</p>
</li></ol>

<p>The vector of frequencies can be used as the x-axis values of a single sided spectrum amplitude plot.
The vector of PSD values can be used as the y-axis values of the PSD plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create a vector of time that represent times where data are sampled.
Fs = 100; #sampling frequency in Hz
T = 1/Fs; #sampling period
L = 1000; #length of time vector
t = (0:(L-1))*T; #time vector

#Form a signal (time series) that contains two frequencies:
#1. 10 Hz with amplitude of 1
#2. 25 Hz with amplitude of 2
S &lt;- 1*sin(2*pi*10*t) + 2*sin(2*pi*25*t);

results &lt;- MakePowerSpectralDensity(Fs, S)

frequencies &lt;- results[[1]]

PSD &lt;- results[[2]]

#dev.new()
plot(frequencies, PSD, type = "l")


</code></pre>

<hr>
<h2 id='PSDDominantFrequencyForMultipleWindows'>Calculate dominant frequency for multiple PSDs for a single frequency range</h2><span id='topic+PSDDominantFrequencyForMultipleWindows'></span>

<h3>Description</h3>

<p>Calculate dominant frequency for multiple PSDs for a single frequency range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PSDDominantFrequencyForMultipleWindows(
  list.of.windows,
  name.of.col.containing.time.series,
  sampling_frequency,
  x_start,
  x_end,
  x_increment
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PSDDominantFrequencyForMultipleWindows_+3A_list.of.windows">list.of.windows</code></td>
<td>
<p>A list of windows (dataframes).</p>
</td></tr>
<tr><td><code id="PSDDominantFrequencyForMultipleWindows_+3A_name.of.col.containing.time.series">name.of.col.containing.time.series</code></td>
<td>
<p>A string that specifies the name of the column in the windows that correspond to the time series that should be used for making PSD.</p>
</td></tr>
<tr><td><code id="PSDDominantFrequencyForMultipleWindows_+3A_sampling_frequency">sampling_frequency</code></td>
<td>
<p>Numeric value specifying sampling frequency in hertz. If data is sampled once every second, then sampling frequency is 1 Hz. If data is sampled once every 2 seconds, then sampling frequency is 0.5 Hz.</p>
</td></tr>
<tr><td><code id="PSDDominantFrequencyForMultipleWindows_+3A_x_start">x_start</code></td>
<td>
<p>Numeric value specifying start of x value (frequency) to look at.</p>
</td></tr>
<tr><td><code id="PSDDominantFrequencyForMultipleWindows_+3A_x_end">x_end</code></td>
<td>
<p>Numeric value specifying end of x value to look at.</p>
</td></tr>
<tr><td><code id="PSDDominantFrequencyForMultipleWindows_+3A_x_increment">x_increment</code></td>
<td>
<p>Numeric value specifying the increment of the x-values to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector where each element is the dominant frequency of each window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#Create a vector of time that represent times where data are sampled.
Fs = 100; #sampling frequency in Hz
T = 1/Fs; #sampling period
L = 1000; #length of time vector
t = (0:(L-1))*T; #time vector

#First signal
#1. 1 Hz with amplitude of 2
S1 &lt;- 2*sin(2*pi*1*t)
level1.vals &lt;- rep("a", length(S1))
level2.vals &lt;- rep("1", length(S1))
S1.data.frame &lt;- as.data.frame(cbind(t, S1, level1.vals, level2.vals))
colnames(S1.data.frame) &lt;- c("Time", "Signal", "level1.ID", "level2.ID")
S1.data.frame[,"Signal"] &lt;- as.numeric(S1.data.frame[,"Signal"])

#Second signal
#1. 1 Hz with amplitude of -4
#2. 2 Hz with amplitude of -2
S2 &lt;- (-4)*sin(2*pi*1*t) - 2*sin(2*pi*2*t);
level1.vals &lt;- rep("a", length(S2))
level2.vals &lt;- rep("2", length(S2))
S2.data.frame &lt;- as.data.frame(cbind(t, S2, level1.vals, level2.vals))
colnames(S2.data.frame) &lt;- c("Time", "Signal", "level1.ID", "level2.ID")
S2.data.frame[,"Signal"] &lt;- as.numeric(S2.data.frame[,"Signal"])

#Third signal
#1. 1 Hz with amplitude of 2
#2. 2 Hz with amplitude of 2
S3 &lt;- 2*sin(2*pi*1*t) + 2*sin(2*pi*2*t);
level1.vals &lt;- rep("a", length(S3))
level2.vals &lt;- rep("3", length(S3))
S3.data.frame &lt;- as.data.frame(cbind(t, S3, level1.vals, level2.vals))
colnames(S3.data.frame) &lt;- c("Time", "Signal", "level1.ID", "level2.ID")
S3.data.frame[,"Signal"] &lt;- as.numeric(S3.data.frame[,"Signal"])

#Fourth signal
#1. 1 Hz with amplitude of -2
S4 &lt;- -2*sin(2*pi*1*t)
level1.vals &lt;- rep("b", length(S4))
level2.vals &lt;- rep("3", length(S4))
S4.data.frame &lt;- as.data.frame(cbind(t, S4, level1.vals, level2.vals))
colnames(S4.data.frame) &lt;- c("Time", "Signal", "level1.ID", "level2.ID")
S4.data.frame[,"Signal"] &lt;- as.numeric(S4.data.frame[,"Signal"])

windows &lt;- list(S1.data.frame, S2.data.frame, S3.data.frame, S4.data.frame)


results &lt;- PSDDominantFrequencyForMultipleWindows(windows, "Signal", Fs, 0, 10, 0.01)


</code></pre>

<hr>
<h2 id='PSDIdentifyDominantFrequency'>Given a time series vector, create a PSD and find the dominant frequency</h2><span id='topic+PSDIdentifyDominantFrequency'></span>

<h3>Description</h3>

<p>The range to look for a dominant frequency (frequency corresponding to max
PSD value) should be specified for this function. This function uses the
MakePowerSpectralDensity() function and the IdentifyMaxOnXY() function
together. If multiple equal maxima are found, then IdentifyMaxOnXY()
will display a message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PSDIdentifyDominantFrequency(
  sampling_frequency,
  data_vector,
  x_start = 0,
  x_end,
  x_increment
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PSDIdentifyDominantFrequency_+3A_sampling_frequency">sampling_frequency</code></td>
<td>
<p>Numeric value specifying sampling frequency in hertz. If data is sampled once every second, then sampling frequency is 1 Hz. If data is sampled once every 2 seconds, then sampling frequency is 0.5 Hz.</p>
</td></tr>
<tr><td><code id="PSDIdentifyDominantFrequency_+3A_data_vector">data_vector</code></td>
<td>
<p>Vector of numeric values. Timeseries vector of data.</p>
</td></tr>
<tr><td><code id="PSDIdentifyDominantFrequency_+3A_x_start">x_start</code></td>
<td>
<p>Numeric value specifying start of x value to look at.</p>
</td></tr>
<tr><td><code id="PSDIdentifyDominantFrequency_+3A_x_end">x_end</code></td>
<td>
<p>Numeric value specifying end of x value to look at.</p>
</td></tr>
<tr><td><code id="PSDIdentifyDominantFrequency_+3A_x_increment">x_increment</code></td>
<td>
<p>Numeric value specifying the increment of the x-values to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with two elements, The first element is the x value (frequency)
where the max y value (PSD value) is found. The second element is the max y value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Create a vector of time that represent times where data are sampled.
Fs = 100; #sampling frequency in Hz
T = 1/Fs; #sampling period
L = 1000; #length of time vector
t = (0:(L-1))*T; #time vector

#First signal
#1. 1 Hz with amplitude of 2
S1 &lt;- 2*sin(2*pi*1*t)
level1.vals &lt;- rep("a", length(S1))
level2.vals &lt;- rep("1", length(S1))
S1.data.frame &lt;- as.data.frame(cbind(t, S1, level1.vals, level2.vals))
colnames(S1.data.frame) &lt;- c("Time", "Signal", "level1.ID", "level2.ID")
S1.data.frame[,"Signal"] &lt;- as.numeric(S1.data.frame[,"Signal"])


results &lt;- PSDIdentifyDominantFrequency(Fs, S1.data.frame[,"Signal"], 0, 10, 0.01)

</code></pre>

<hr>
<h2 id='PSDIntegrationPerFreqBin'>Given a time series vector, generate a PSD, then calculate integration for specified bins</h2><span id='topic+PSDIntegrationPerFreqBin'></span>

<h3>Description</h3>

<p>Given a time series vector, generate a PSD, then calculate integration for specified bins
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PSDIntegrationPerFreqBin(sampling_frequency, data_vector, frequency_bins)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PSDIntegrationPerFreqBin_+3A_sampling_frequency">sampling_frequency</code></td>
<td>
<p>Numeric value specifying sampling frequency in hertz. If data is sampled once every second, then sampling frequency is 1 Hz. If data is sampled once every 2 seconds, then sampling frequency is 0.5 Hz.</p>
</td></tr>
<tr><td><code id="PSDIntegrationPerFreqBin_+3A_data_vector">data_vector</code></td>
<td>
<p>Vector of numeric values. Timeseries vector of data.</p>
</td></tr>
<tr><td><code id="PSDIntegrationPerFreqBin_+3A_frequency_bins">frequency_bins</code></td>
<td>
<p>A list of objects where each object is a vector with two elements. The first element is a numeric value specifying the start frequency of a bin. The second element is a numeric value specifying the end frequency of a bin. Each object corresponds to a new frequency bin for calculating integral. For integration, approxfun is used, so increment does not need to be specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list where each object is also a list. The nested list objects have the first element specifying the bin boundaries. The second element specifies the integral.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Create a vector of time that represent times where data are sampled.
Fs = 100; #sampling frequency in Hz
T = 1/Fs; #sampling period
L = 1000; #length of time vector
t = (0:(L-1))*T; #time vector

#Form a signal (time series) that contains two frequencies:
#1. 10 Hz with amplitude of 1
#2. 25 Hz with amplitude of 2
S &lt;- 1*sin(2*pi*10*t) + 2*sin(2*pi*25*t);

results &lt;- MakePowerSpectralDensity(Fs, S)

frequencies &lt;- results[[1]]

PSD &lt;- results[[2]]

#dev.new()
plot(frequencies, PSD, type = "l")

bins &lt;- list(
c(9, 11),
c(24,26),
c(9,26),
c(30,40)
)

integration.results &lt;- PSDIntegrationPerFreqBin(Fs, S, bins)

message.captured &lt;- list()

for(i in 1:length(integration.results)){

   message &lt;- paste("Area in bin ", integration.results[[i]][[1]], " is ",
                   integration.results[[i]][[2]])

   message.captured[[i]] &lt;- message

}

</code></pre>

<hr>
<h2 id='SingleBinPSDIntegrationForMultipleWindows'>Calculate integral for multiple PSDs for a single frequency bin</h2><span id='topic+SingleBinPSDIntegrationForMultipleWindows'></span>

<h3>Description</h3>

<p>Calculate integral for multiple PSDs for a single frequency bin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SingleBinPSDIntegrationForMultipleWindows(
  list.of.windows,
  name.of.col.containing.time.series,
  sampling_frequency,
  single.bin.boundary
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SingleBinPSDIntegrationForMultipleWindows_+3A_list.of.windows">list.of.windows</code></td>
<td>
<p>A list of windows (dataframes).</p>
</td></tr>
<tr><td><code id="SingleBinPSDIntegrationForMultipleWindows_+3A_name.of.col.containing.time.series">name.of.col.containing.time.series</code></td>
<td>
<p>A string that specifies the name of the column in the windows that correspond to the time series that should be used for making PSD.</p>
</td></tr>
<tr><td><code id="SingleBinPSDIntegrationForMultipleWindows_+3A_sampling_frequency">sampling_frequency</code></td>
<td>
<p>Numeric value specifying sampling frequency in hertz. If data is sampled once every second, then sampling frequency is 1 Hz. If data is sampled once every 2 seconds, then sampling frequency is 0.5 Hz.</p>
</td></tr>
<tr><td><code id="SingleBinPSDIntegrationForMultipleWindows_+3A_single.bin.boundary">single.bin.boundary</code></td>
<td>
<p>A numeric vector with two elements. First element is the start frequency for the bin. Second element is the end frequency of the bin.  For integration, approxfun is used, so increment does not need to be specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector where each element is the integration result of each window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#Create a vector of time that represent times where data are sampled.
Fs = 100; #sampling frequency in Hz
T = 1/Fs; #sampling period
L = 1000; #length of time vector
t = (0:(L-1))*T; #time vector

#First signal
#1. 1 Hz with amplitude of 2
S1 &lt;- 2*sin(2*pi*1*t)
level1.vals &lt;- rep("a", length(S1))
level2.vals &lt;- rep("1", length(S1))
S1.data.frame &lt;- as.data.frame(cbind(t, S1, level1.vals, level2.vals))
colnames(S1.data.frame) &lt;- c("Time", "Signal", "level1.ID", "level2.ID")
S1.data.frame[,"Signal"] &lt;- as.numeric(S1.data.frame[,"Signal"])

#Second signal
#1. 1 Hz with amplitude of -4
#2. 2 Hz with amplitude of -2
S2 &lt;- (-4)*sin(2*pi*1*t) - 2*sin(2*pi*2*t);
level1.vals &lt;- rep("a", length(S2))
level2.vals &lt;- rep("2", length(S2))
S2.data.frame &lt;- as.data.frame(cbind(t, S2, level1.vals, level2.vals))
colnames(S2.data.frame) &lt;- c("Time", "Signal", "level1.ID", "level2.ID")
S2.data.frame[,"Signal"] &lt;- as.numeric(S2.data.frame[,"Signal"])

#Third signal
#1. 1 Hz with amplitude of 2
#2. 2 Hz with amplitude of 2
S3 &lt;- 2*sin(2*pi*1*t) + 2*sin(2*pi*2*t);
level1.vals &lt;- rep("a", length(S3))
level2.vals &lt;- rep("3", length(S3))
S3.data.frame &lt;- as.data.frame(cbind(t, S3, level1.vals, level2.vals))
colnames(S3.data.frame) &lt;- c("Time", "Signal", "level1.ID", "level2.ID")
S3.data.frame[,"Signal"] &lt;- as.numeric(S3.data.frame[,"Signal"])

#Fourth signal
#1. 1 Hz with amplitude of -2
S4 &lt;- -2*sin(2*pi*1*t)
level1.vals &lt;- rep("b", length(S4))
level2.vals &lt;- rep("3", length(S4))
S4.data.frame &lt;- as.data.frame(cbind(t, S4, level1.vals, level2.vals))
colnames(S4.data.frame) &lt;- c("Time", "Signal", "level1.ID", "level2.ID")
S4.data.frame[,"Signal"] &lt;- as.numeric(S4.data.frame[,"Signal"])

windows &lt;- list(S1.data.frame, S2.data.frame, S3.data.frame, S4.data.frame)


results &lt;- SingleBinPSDIntegrationForMultipleWindows(windows, "Signal", Fs, c(0,2))


</code></pre>

<hr>
<h2 id='SingleBinPSDIntegrationOrDominantFreqComparison'>Given sets of windows (dataframes) corresponding to different combos, see if the integration
or dominant frequency of a specific frequency range is significantly different between the combos</h2><span id='topic+SingleBinPSDIntegrationOrDominantFreqComparison'></span>

<h3>Description</h3>

<p>Just for a single frequency bin: For Each combination in level.combinations,
generate the integral or dominant frequency for each
window of each combination. At this point, we should have vectors of
integrals or dominant frequency with each vector
corresponding to a different combo. Now we want to see if the integrals or dominant frequencies
in each combo significantly differ from the other combos. Kruskal-Wallis test is used
as a non-parametric ANOVA test to see if the combos have integrals or dominant frequencies that
are significantly different.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SingleBinPSDIntegrationOrDominantFreqComparison(
  list.of.windows,
  name.of.col.containing.time.series,
  level1.column.name,
  level2.column.name,
  level.combinations,
  level.combinations.labels,
  sampling_frequency,
  single.bin.boundary = NULL,
  x_start = NULL,
  x_end = NULL,
  x_increment = NULL,
  integration.or.dominant.freq
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SingleBinPSDIntegrationOrDominantFreqComparison_+3A_list.of.windows">list.of.windows</code></td>
<td>
<p>A list of windows (dataframes).</p>
</td></tr>
<tr><td><code id="SingleBinPSDIntegrationOrDominantFreqComparison_+3A_name.of.col.containing.time.series">name.of.col.containing.time.series</code></td>
<td>
<p>A string that specifies the name of the column in the windows that correspond to the time series that should be used for making PSD.</p>
</td></tr>
<tr><td><code id="SingleBinPSDIntegrationOrDominantFreqComparison_+3A_level1.column.name">level1.column.name</code></td>
<td>
<p>A String that specifies the column name to use for the first level. This column should only contain one unique value within each window.</p>
</td></tr>
<tr><td><code id="SingleBinPSDIntegrationOrDominantFreqComparison_+3A_level2.column.name">level2.column.name</code></td>
<td>
<p>A String that specifies the column name to use for the second level. This column should only contain one unique value within each window.</p>
</td></tr>
<tr><td><code id="SingleBinPSDIntegrationOrDominantFreqComparison_+3A_level.combinations">level.combinations</code></td>
<td>
<p>A List containing Lists. Each list that it contains has two vectors. The first vector specifying the values for level1 and the second vector specifying the values for level2. Each list element will correspond to a new line on the plot.</p>
</td></tr>
<tr><td><code id="SingleBinPSDIntegrationOrDominantFreqComparison_+3A_level.combinations.labels">level.combinations.labels</code></td>
<td>
<p>A vector of strings that labels each combination. This is used for naming the groups in integrals.with.combo.labels</p>
</td></tr>
<tr><td><code id="SingleBinPSDIntegrationOrDominantFreqComparison_+3A_sampling_frequency">sampling_frequency</code></td>
<td>
<p>Numeric value specifying sampling frequency in hertz. If data is sampled once every second, then sampling frequency is 1 Hz. If data is sampled once every 2 seconds, then sampling frequency is 0.5 Hz.</p>
</td></tr>
<tr><td><code id="SingleBinPSDIntegrationOrDominantFreqComparison_+3A_single.bin.boundary">single.bin.boundary</code></td>
<td>
<p>A numeric vector with two elements. First element is the start frequency for the bin. Second element is the end frequency of the bin.</p>
</td></tr>
<tr><td><code id="SingleBinPSDIntegrationOrDominantFreqComparison_+3A_x_start">x_start</code></td>
<td>
<p>Numeric value specifying start of the new x-axis for the averaged PSD. Default is 0 Hz.</p>
</td></tr>
<tr><td><code id="SingleBinPSDIntegrationOrDominantFreqComparison_+3A_x_end">x_end</code></td>
<td>
<p>Numeric value specifying end of the new x-axis for the averaged PSD. Maximum value is the sampling_frequency divided by 2.</p>
</td></tr>
<tr><td><code id="SingleBinPSDIntegrationOrDominantFreqComparison_+3A_x_increment">x_increment</code></td>
<td>
<p>Numeric value specifying increment of the new x-axis for the averaged PSD.</p>
</td></tr>
<tr><td><code id="SingleBinPSDIntegrationOrDominantFreqComparison_+3A_integration.or.dominant.freq">integration.or.dominant.freq</code></td>
<td>
<p>A string with two possible values for choosing whether integral or dominant frequency should be calculated and compared: &quot;integration&quot; or &quot;dominant_freq&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Need to specify whether to compare integral or dominant frequency:
If integral (total power in frequency bin) is the value to compare, then
SingleBinPSDIntegrationForMultipleWindows() is used. If dominant frequency (
frequency corresponding to max PSD value in frequency bin) is the value to
compare, then PSDDominantFrequencyForMultipleWindows() is used.
</p>


<h3>Value</h3>

<p>A list with 3 objects:
</p>

<ol>
<li><p> integrals.with.combo.labels: Dataframe used for statistical testing.
</p>
</li>
<li><p> kruskal.test.res: Results from Kruskal-Willis testing.
</p>
</li>
<li><p> pairwise.wilcox.rest.res: Results from pairwise Wilcoxo testing
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>

#Create a vector of time that represent times where data are sampled.
Fs = 100; #sampling frequency in Hz
T = 1/Fs; #sampling period
L = 1000; #length of time vector
t = (0:(L-1))*T; #time vector

#First signal
#1. 1 Hz with amplitude of 2
S1 &lt;- 2*sin(2*pi*1*t)
level1.vals &lt;- rep("a", length(S1))
level2.vals &lt;- rep("1", length(S1))
S1.data.frame &lt;- as.data.frame(cbind(t, S1, level1.vals, level2.vals))
colnames(S1.data.frame) &lt;- c("Time", "Signal", "level1.ID", "level2.ID")
S1.data.frame[,"Signal"] &lt;- as.numeric(S1.data.frame[,"Signal"])

#Second signal
#1. 1 Hz with amplitude of -4
#2. 2 Hz with amplitude of -2
S2 &lt;- (-4)*sin(2*pi*1*t) - 2*sin(2*pi*2*t);
level1.vals &lt;- rep("a", length(S2))
level2.vals &lt;- rep("2", length(S2))
S2.data.frame &lt;- as.data.frame(cbind(t, S2, level1.vals, level2.vals))
colnames(S2.data.frame) &lt;- c("Time", "Signal", "level1.ID", "level2.ID")
S2.data.frame[,"Signal"] &lt;- as.numeric(S2.data.frame[,"Signal"])

#Third signal
#1. 1 Hz with amplitude of 2
#2. 2 Hz with amplitude of 2
S3 &lt;- 2*sin(2*pi*1*t) + 2*sin(2*pi*2*t);
level1.vals &lt;- rep("a", length(S3))
level2.vals &lt;- rep("3", length(S3))
S3.data.frame &lt;- as.data.frame(cbind(t, S3, level1.vals, level2.vals))
colnames(S3.data.frame) &lt;- c("Time", "Signal", "level1.ID", "level2.ID")
S3.data.frame[,"Signal"] &lt;- as.numeric(S3.data.frame[,"Signal"])

#Fourth signal
#1. 1 Hz with amplitude of -2
S4 &lt;- -2*sin(2*pi*1*t)
level1.vals &lt;- rep("b", length(S4))
level2.vals &lt;- rep("3", length(S4))
S4.data.frame &lt;- as.data.frame(cbind(t, S4, level1.vals, level2.vals))
colnames(S4.data.frame) &lt;- c("Time", "Signal", "level1.ID", "level2.ID")
S4.data.frame[,"Signal"] &lt;- as.numeric(S4.data.frame[,"Signal"])

#Fifth signal
#1. 5 Hz with amplitude of -2
S5 &lt;- -2*sin(2*pi*5*t)
level1.vals &lt;- rep("c", length(S5))
level2.vals &lt;- rep("1", length(S5))
S5.data.frame &lt;- as.data.frame(cbind(t, S5, level1.vals, level2.vals))
colnames(S5.data.frame) &lt;- c("Time", "Signal", "level1.ID", "level2.ID")
S5.data.frame[,"Signal"] &lt;- as.numeric(S5.data.frame[,"Signal"])

#Extra representation of S2 dataframe to show an example that has enough samples
#to have significance for Kruskal-Wallis test
windows &lt;- list(S1.data.frame, S2.data.frame, S2.data.frame, S2.data.frame, S2.data.frame,
S2.data.frame, S2.data.frame, S2.data.frame, S2.data.frame, S2.data.frame, S3.data.frame,
S4.data.frame,
S5.data.frame, S5.data.frame, S5.data.frame, S5.data.frame, S5.data.frame)

#Gets the composite of the first, second, and third signal. Should result in a flat signal.
FirstComboToUse &lt;- list( c("a"), c(1, 2, 3) )

#Gets the composite of the third and fourth signal
SecondComboToUse &lt;- list( c("a", "b"), c(3) )

#Gets the composite of fifth signal
ThirdComboToUse &lt;- list( c("c"), c(1) )


#PSD-------------------------------------------------------------------------

PSD.results &lt;- AutomatedCompositePlotting(list.of.windows = windows,
                           name.of.col.containing.time.series = "Signal",
                           x_start = 0,
                           x_end = 10,
                           x_increment = 0.01,
                           level1.column.name = "level1.ID",
                           level2.column.name = "level2.ID",
                           level.combinations = list(FirstComboToUse,
                                                    SecondComboToUse,
                                                    ThirdComboToUse),
                           level.combinations.labels = c("Signal 1 + 2 + 3",
                                                         "Signal 3 + 4",
                                                         "Signal 5"),
                           plot.title = "Example",
                           plot.xlab = "Hz",
                           plot.ylab = "(Original units)^2/Hz",
                           combination.index.for.envelope = 2,
                           TimeSeries.PSD.LogPSD = "PSD",
                           sampling_frequency = 100)

ggplot.obj.PSD &lt;- PSD.results[[2]]

#Integration-------------------------------------------------------------------------

#Compare integration for the 1.5-2.5 Hz bin. P-value should not indicate
#significant difference
integration.compare.res &lt;- SingleBinPSDIntegrationOrDominantFreqComparison(
list.of.windows = windows,
name.of.col.containing.time.series = "Signal",
level1.column.name = "level1.ID",
level2.column.name = "level2.ID",
level.combinations = list(FirstComboToUse, SecondComboToUse),
level.combinations.labels = c("Signal 1 + 2 + 3", "Signal 3 + 4"),
sampling_frequency = 100,
single.bin.boundary = c(1.5, 2.5),
integration.or.dominant.freq = "integration")

#Kruskal-Wallis test results
integration.compare.res[[2]]

#Compare integration for the 0.5-1.5 Hz bin. P-value should indicate
#significant difference
integration.compare.res2 &lt;- SingleBinPSDIntegrationOrDominantFreqComparison(
list.of.windows = windows,
name.of.col.containing.time.series = "Signal",
level1.column.name = "level1.ID",
level2.column.name = "level2.ID",
level.combinations = list(FirstComboToUse, SecondComboToUse),
level.combinations.labels = c("Signal 1 + 2 + 3", "Signal 3 + 4"),
sampling_frequency = 100,
single.bin.boundary = c(0.5,1.5),
integration.or.dominant.freq = "integration")

#Kruskal-Wallis test results
integration.compare.res2[[2]]



#Dominant Frequency---------------------------------------------------------------------

#Compare dominant frequency P-value should not indicate
#significant difference
integration.compare.res3 &lt;- SingleBinPSDIntegrationOrDominantFreqComparison(
list.of.windows = windows,
name.of.col.containing.time.series = "Signal",
level1.column.name = "level1.ID",
level2.column.name = "level2.ID",
level.combinations = list(FirstComboToUse, SecondComboToUse),
level.combinations.labels = c("Signal 1 + 2 + 3", "Signal 3 + 4"),
sampling_frequency = 100,
x_start = 0,
x_end = 10,
x_increment = 0.01,
integration.or.dominant.freq = "dominant_freq")

#Kruskal-Wallis test results
integration.compare.res3[[2]]


#Compare dominant frequency P-value should indicate
#significant difference
integration.compare.res4 &lt;- SingleBinPSDIntegrationOrDominantFreqComparison(
list.of.windows = windows,
name.of.col.containing.time.series = "Signal",
level1.column.name = "level1.ID",
level2.column.name = "level2.ID",
level.combinations = list(SecondComboToUse, ThirdComboToUse),
level.combinations.labels = c("Signal 3 + 4", "Signal 5"),
sampling_frequency = 100,
x_start = 0,
x_end = 10,
x_increment = 0.01,
integration.or.dominant.freq = "dominant_freq")

#Kruskal-Wallis test results
integration.compare.res4[[2]]
#Values used in comparison of the two groups
integration.compare.res4[[1]]


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
