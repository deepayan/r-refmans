<!DOCTYPE html><html><head><title>Help for package datadriftR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {datadriftR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DDM'><p>DDM (Drift Detection Method)</p></a></li>
<li><a href='#EDDM'><p>EDDM (Early Drift Detection Method)</p></a></li>
<li><a href='#HDDM_A'><p>HDDM_A: Drift Detection Method based on Adaptive Windows</p></a></li>
<li><a href='#HDDM_W'><p>KSWIN (Kolmogorov-Smirnov WINdowing) for Change Detection</p></a></li>
<li><a href='#KSWIN'><p>KSWIN (Kolmogorov-Smirnov WINdowing) for Change Detection</p></a></li>
<li><a href='#PageHinkley'><p>Page-Hinkley Test for Change Detection</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Concept Drift Detection Methods for Stream Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>
    A system designed for detecting concept drift in streaming datasets. It offers a comprehensive suite of statistical methods to detect concept drift, including methods for monitoring changes in data distributions
    over time. The package supports several tests, such as Drift Detection Method (DDM), Early Drift Detection Method (EDDM), Hoeffding Drift Detection Methods (HDDM_A, HDDM_W), Kolmogorov-Smirnov test-based Windowing (KSWIN)
    and Page Hinkley (PH) tests. The methods implemented in this package are based on established research and have been demonstrated to be effective in real-time data analysis. For more details on the methods, 
    please check to the following sources. Gama et al. (2004) &lt;<a href="https://doi.org/10.1007%2F978-3-540-28645-5_29">doi:10.1007/978-3-540-28645-5_29</a>&gt;, Baena-Garcia et al. (2006) <a href="https://www.researchgate.net/publication/245999704_Early_Drift_Detection_Method">https://www.researchgate.net/publication/245999704_Early_Drift_Detection_Method</a>,
    Frías-Blanco et al. (2014) <a href="https://ieeexplore.ieee.org/document/6871418">https://ieeexplore.ieee.org/document/6871418</a>, Raab et al. (2020) &lt;<a href="https://doi.org/10.1016%2Fj.neucom.2019.11.111">doi:10.1016/j.neucom.2019.11.111</a>&gt;, Page (1954) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2F41.1-2.100">doi:10.1093/biomet/41.1-2.100</a>&gt;, Montiel et al. (2018) <a href="https://jmlr.org/papers/volume19/18-251/18-251.pdf">https://jmlr.org/papers/volume19/18-251/18-251.pdf</a>.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ugurdar/datadriftR">https://github.com/ugurdar/datadriftR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ugurdar/datadriftR/issues">https://github.com/ugurdar/datadriftR/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-13 14:10:35 UTC; ugurdar</td>
</tr>
<tr>
<td>Author:</td>
<td>Ugur Dar [aut, cre],
  Mustafa Cavus [ctb, ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ugur Dar &lt;ugurdarr@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-13 18:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='DDM'>DDM (Drift Detection Method)</h2><span id='topic+DDM'></span>

<h3>Description</h3>

<p>Implements the Drift Detection Method (DDM), used for detecting concept drift in data streams
by analyzing the performance of online learners. The method monitors changes in the error rate
of a learner, signaling potential concept drift.
</p>


<h3>Details</h3>

<p>DDM is designed to be simple yet effective for detecting concept drift by monitoring
the error rate of any online classifier. The method is particularly sensitive to
increases in the error rate, which is typically a strong indicator of concept drift.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>min_instances</code></dt><dd><p>Minimum number of instances required before drift detection begins.</p>
</dd>
<dt><code>warning_level</code></dt><dd><p>Multiplier for the standard deviation to set the warning threshold.</p>
</dd>
<dt><code>out_control_level</code></dt><dd><p>Multiplier for the standard deviation to set the out-of-control threshold.</p>
</dd>
<dt><code>sample_count</code></dt><dd><p>Counter for the number of samples processed.</p>
</dd>
<dt><code>miss_prob</code></dt><dd><p>Current estimated probability of misclassification.</p>
</dd>
<dt><code>miss_std</code></dt><dd><p>Current estimated standard deviation of misclassification probability.</p>
</dd>
<dt><code>miss_prob_sd_min</code></dt><dd><p>Minimum recorded value of misclassification probability plus its standard deviation.</p>
</dd>
<dt><code>miss_prob_min</code></dt><dd><p>Minimum recorded misclassification probability.</p>
</dd>
<dt><code>miss_sd_min</code></dt><dd><p>Minimum recorded standard deviation.</p>
</dd>
<dt><code>estimation</code></dt><dd><p>Current estimation of misclassification probability.</p>
</dd>
<dt><code>change_detected</code></dt><dd><p>Boolean indicating if a drift has been detected.</p>
</dd>
<dt><code>warning_detected</code></dt><dd><p>Boolean indicating if a warning level has been reached.</p>
</dd>
<dt><code>delay</code></dt><dd><p>Delay since the last relevant sample.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DDM-new"><code>DDM$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DDM-reset"><code>DDM$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-DDM-add_element"><code>DDM$add_element()</code></a>
</p>
</li>
<li> <p><a href="#method-DDM-detected_change"><code>DDM$detected_change()</code></a>
</p>
</li>
<li> <p><a href="#method-DDM-clone"><code>DDM$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-DDM-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initializes the DDM detector with specific parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>DDM$new(min_num_instances = 30, warning_level = 2, out_control_level = 3)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>min_num_instances</code></dt><dd><p>Minimum number of samples required before starting drift detection.</p>
</dd>
<dt><code>warning_level</code></dt><dd><p>Threshold multiplier for setting a warning level.</p>
</dd>
<dt><code>out_control_level</code></dt><dd><p>Threshold multiplier for setting the out-of-control level.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DDM-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Resets the internal state of the DDM detector.
</p>


<h5>Usage</h5>

<div class="r"><pre>DDM$reset()</pre></div>


<hr>
<a id="method-DDM-add_element"></a>



<h4>Method <code>add_element()</code></h4>

<p>Adds a new prediction error value to the model, updates the calculation of the misclassification
probability and its standard deviation, and checks for warnings or drifts based on updated statistics.
</p>


<h5>Usage</h5>

<div class="r"><pre>DDM$add_element(prediction)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>prediction</code></dt><dd><p>The new data point (prediction error) to be added to the model.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DDM-detected_change"></a>



<h4>Method <code>detected_change()</code></h4>

<p>Returns a boolean indicating whether a drift has been detected based on the monitored statistics.
</p>


<h5>Usage</h5>

<div class="r"><pre>DDM$detected_change()</pre></div>


<hr>
<a id="method-DDM-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DDM$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>João Gama, Pedro Medas, Gladys Castillo, Pedro Pereira Rodrigues: Learning
with Drift Detection. SBIA 2004: 286-295
</p>
<p>Implementation: https://github.com/scikit-multiflow/scikit-multiflow/blob/a7e316d1cc79988a6df40da35312e00f6c4eabb2/src/skmultiflow/drift_detection/ddm.py
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)  # Setting a seed for reproducibility
data_part1 &lt;- sample(c(0, 1), size = 100, replace = TRUE, prob = c(0.7, 0.3))

# Introduce a change in data distribution
data_part2 &lt;- sample(c(0, 1), size = 100, replace = TRUE, prob = c(0.3, 0.7))

# Combine the two parts
data_stream &lt;- c(data_part1, data_part2)
ddm &lt;- DDM$new()
# Iterate through the data stream
for (i in seq_along(data_stream)) {
  ddm$add_element(data_stream[i])
  if (ddm$change_detected) {
    message(paste("Drift detected!", i))
  } else if (ddm$warning_detected) {
    # message(paste("Warning detected at position:", i))
  }
}
</code></pre>

<hr>
<h2 id='EDDM'>EDDM (Early Drift Detection Method)</h2><span id='topic+EDDM'></span>

<h3>Description</h3>

<p>This class implements the Early Drift Detection Method (EDDM), designed to detect
concept drifts in online learning scenarios by monitoring the distances between consecutive errors.
EDDM is particularly useful for detecting gradual drifts earlier than abrupt changes.
</p>


<h3>Details</h3>

<p>EDDM is a statistical process control method that is more sensitive to changes that happen
more slowly and can provide early warnings of deterioration before the error rate increases
significantly.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>eddm_warning</code></dt><dd><p>Warning threshold setting.</p>
</dd>
<dt><code>eddm_outcontrol</code></dt><dd><p>Out-of-control threshold setting.</p>
</dd>
<dt><code>m_num_errors</code></dt><dd><p>Current number of errors encountered.</p>
</dd>
<dt><code>m_min_num_errors</code></dt><dd><p>Minimum number of errors to initialize drift detection.</p>
</dd>
<dt><code>m_n</code></dt><dd><p>Total instances processed.</p>
</dd>
<dt><code>m_d</code></dt><dd><p>Distance to the last error from the current instance.</p>
</dd>
<dt><code>m_lastd</code></dt><dd><p>Distance to the previous error from the last error.</p>
</dd>
<dt><code>m_mean</code></dt><dd><p>Mean of the distances between errors.</p>
</dd>
<dt><code>m_std_temp</code></dt><dd><p>Temporary standard deviation accumulator for the distances.</p>
</dd>
<dt><code>m_m2s_max</code></dt><dd><p>Maximum mean plus two standard deviations observed.</p>
</dd>
<dt><code>delay</code></dt><dd><p>Delay count since the last detected change.</p>
</dd>
<dt><code>estimation</code></dt><dd><p>Current estimated mean distance between errors.</p>
</dd>
<dt><code>warning_detected</code></dt><dd><p>Boolean indicating if a warning has been detected.</p>
</dd>
<dt><code>change_detected</code></dt><dd><p>Boolean indicating if a change has been detected.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-EDDM-new"><code>EDDM$new()</code></a>
</p>
</li>
<li> <p><a href="#method-EDDM-reset"><code>EDDM$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-EDDM-add_element"><code>EDDM$add_element()</code></a>
</p>
</li>
<li> <p><a href="#method-EDDM-clone"><code>EDDM$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-EDDM-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initializes the EDDM detector with specific parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>EDDM$new(min_num_instances = 30, eddm_warning = 0.95, eddm_outcontrol = 0.9)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>min_num_instances</code></dt><dd><p>Minimum number of errors before drift detection starts.</p>
</dd>
<dt><code>eddm_warning</code></dt><dd><p>Threshold for warning level.</p>
</dd>
<dt><code>eddm_outcontrol</code></dt><dd><p>Threshold for out-of-control level.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-EDDM-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Resets the internal state of the EDDM detector.
</p>


<h5>Usage</h5>

<div class="r"><pre>EDDM$reset()</pre></div>


<hr>
<a id="method-EDDM-add_element"></a>



<h4>Method <code>add_element()</code></h4>

<p>Adds a new observation and updates the drift detection status.
</p>


<h5>Usage</h5>

<div class="r"><pre>EDDM$add_element(prediction)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>prediction</code></dt><dd><p>Numeric value representing a new error (usually 0 or 1).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-EDDM-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>EDDM$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Early Drift Detection Method. Manuel Baena-Garcia, Jose Del Campo-Avila,
Raúl Fidalgo, Albert Bifet, Ricard Gavalda, Rafael Morales-Bueno. In Fourth
International Workshop on Knowledge Discovery from Data Streams, 2006.
</p>
<p>Implementation: https://github.com/scikit-multiflow/scikit-multiflow/blob/a7e316d1cc79988a6df40da35312e00f6c4eabb2/src/skmultiflow/drift_detection/eddm.py
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)  # Setting a seed for reproducibility
data_part1 &lt;- sample(c(0, 1), size = 100, replace = TRUE, prob = c(0.7, 0.3))

# Introduce a change in data distribution
data_part2 &lt;- sample(c(0, 1), size = 100, replace = TRUE, prob = c(0.3, 0.7))

# Combine the two parts
data_stream &lt;- c(data_part1, data_part2)
eddm &lt;- EDDM$new()
for (i in 1:length(data_stream)) {
  eddm$add_element(data_stream[i])
  if (eddm$change_detected) {
    message(paste("Drift detected!",i))
  } else if (eddm$warning_detected) {
    message(paste("Warning detected!",i))
  }
}
</code></pre>

<hr>
<h2 id='HDDM_A'>HDDM_A: Drift Detection Method based on Adaptive Windows</h2><span id='topic+HDDM_A'></span>

<h3>Description</h3>

<p>This class implements the HDDM_A drift detection method that uses adaptive windows
to detect changes in the mean of a data stream. It is designed to monitor online streams
of data and can detect increases or decreases in the process mean in a non-parametric and
online manner.
</p>


<h3>Details</h3>

<p>HDDM_A adapts to changes in the data stream by adjusting its internal windows to track
the minimum and maximum values of the process mean. It triggers alerts when a significant
drift from these benchmarks is detected.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>drift_confidence</code></dt><dd><p>Confidence level for detecting a drift.</p>
</dd>
<dt><code>warning_confidence</code></dt><dd><p>Confidence level for warning detection.</p>
</dd>
<dt><code>two_side_option</code></dt><dd><p>Boolean flag for one-sided or two-sided mean monitoring.</p>
</dd>
<dt><code>total_n</code></dt><dd><p>Total number of samples seen.</p>
</dd>
<dt><code>total_c</code></dt><dd><p>Total cumulative sum of the samples.</p>
</dd>
<dt><code>n_max</code></dt><dd><p>Maximum window end for sample count.</p>
</dd>
<dt><code>c_max</code></dt><dd><p>Maximum window end for cumulative sum.</p>
</dd>
<dt><code>n_min</code></dt><dd><p>Minimum window start for sample count.</p>
</dd>
<dt><code>c_min</code></dt><dd><p>Minimum window start for cumulative sum.</p>
</dd>
<dt><code>n_estimation</code></dt><dd><p>Number of samples since the last detected change.</p>
</dd>
<dt><code>c_estimation</code></dt><dd><p>Cumulative sum since the last detected change.</p>
</dd>
<dt><code>change_detected</code></dt><dd><p>Boolean indicating if a change was detected.</p>
</dd>
<dt><code>warning_detected</code></dt><dd><p>Boolean indicating if a warning has been detected.</p>
</dd>
<dt><code>estimation</code></dt><dd><p>Current estimated mean of the stream.</p>
</dd>
<dt><code>delay</code></dt><dd><p>Current delay since the last update.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HDDM_A-new"><code>HDDM_A$new()</code></a>
</p>
</li>
<li> <p><a href="#method-HDDM_A-add_element"><code>HDDM_A$add_element()</code></a>
</p>
</li>
<li> <p><a href="#method-HDDM_A-mean_incr"><code>HDDM_A$mean_incr()</code></a>
</p>
</li>
<li> <p><a href="#method-HDDM_A-mean_decr"><code>HDDM_A$mean_decr()</code></a>
</p>
</li>
<li> <p><a href="#method-HDDM_A-reset"><code>HDDM_A$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-HDDM_A-update_estimations"><code>HDDM_A$update_estimations()</code></a>
</p>
</li>
<li> <p><a href="#method-HDDM_A-clone"><code>HDDM_A$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-HDDM_A-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initializes the HDDM_A detector with specific settings.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDDM_A$new(
  drift_confidence = 0.001,
  warning_confidence = 0.005,
  two_side_option = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>drift_confidence</code></dt><dd><p>Confidence level for drift detection.</p>
</dd>
<dt><code>warning_confidence</code></dt><dd><p>Confidence level for issuing warnings.</p>
</dd>
<dt><code>two_side_option</code></dt><dd><p>Whether to monitor both increases and decreases.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HDDM_A-add_element"></a>



<h4>Method <code>add_element()</code></h4>

<p>Adds an element to the data stream and updates the detection status.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDDM_A$add_element(prediction)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>prediction</code></dt><dd><p>Numeric, the new data value to add.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HDDM_A-mean_incr"></a>



<h4>Method <code>mean_incr()</code></h4>

<p>Calculates if there is an increase in the mean.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDDM_A$mean_incr(c_min, n_min, total_c, total_n, confidence)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>c_min</code></dt><dd><p>Minimum cumulative sum.</p>
</dd>
<dt><code>n_min</code></dt><dd><p>Minimum count of samples.</p>
</dd>
<dt><code>total_c</code></dt><dd><p>Total cumulative sum.</p>
</dd>
<dt><code>total_n</code></dt><dd><p>Total number of samples.</p>
</dd>
<dt><code>confidence</code></dt><dd><p>Confidence threshold for detection.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HDDM_A-mean_decr"></a>



<h4>Method <code>mean_decr()</code></h4>

<p>Calculates if there is a decrease in the mean.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDDM_A$mean_decr(c_max, n_max, total_c, total_n)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>c_max</code></dt><dd><p>Maximum cumulative sum.</p>
</dd>
<dt><code>n_max</code></dt><dd><p>Maximum count of samples.</p>
</dd>
<dt><code>total_c</code></dt><dd><p>Total cumulative sum.</p>
</dd>
<dt><code>total_n</code></dt><dd><p>Total number of samples.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HDDM_A-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Resets all internal counters and accumulators to their initial state.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDDM_A$reset()</pre></div>


<hr>
<a id="method-HDDM_A-update_estimations"></a>



<h4>Method <code>update_estimations()</code></h4>

<p>Updates estimations of the mean after detecting changes.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDDM_A$update_estimations()</pre></div>


<hr>
<a id="method-HDDM_A-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDDM_A$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Frías-Blanco I, del Campo-Ávila J, Ramos-Jimenez G, et al. Online and non-parametric drift
detection methods based on Hoeffding’s bounds. IEEE Transactions on Knowledge and Data
Engineering, 2014, 27(3): 810-823.
</p>
<p>Albert Bifet, Geoff Holmes, Richard Kirkby, Bernhard Pfahringer. MOA: Massive Online Analysis;
Journal of Machine Learning Research 11: 1601-1604, 2010.
</p>
<p>Implementation: https://github.com/scikit-multiflow/scikit-multiflow/blob/a7e316d1cc79988a6df40da35312e00f6c4eabb2/src/skmultiflow/drift_detection/hddm_a.py
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)  # Setting a seed for reproducibility
data_part1 &lt;- sample(c(0, 1), size = 100, replace = TRUE, prob = c(0.7, 0.3))

# Introduce a change in data distribution
data_part2 &lt;- sample(c(0, 1), size = 100, replace = TRUE, prob = c(0.3, 0.7))

# Combine the two parts
data_stream &lt;- c(data_part1, data_part2)

# Initialize the hddm_a object
hddm_a_instance &lt;- HDDM_A$new()

# Iterate through the data stream
for(i in seq_along(data_stream)) {
  hddm_a_instance$add_element(data_stream[i])
  if(hddm_a_instance$warning_detected) {
    message(paste("Warning detected at index:", i))
  }
  if(hddm_a_instance$change_detected) {
    message(paste("Concept drift detected at index:", i))
  }
}
</code></pre>

<hr>
<h2 id='HDDM_W'>KSWIN (Kolmogorov-Smirnov WINdowing) for Change Detection</h2><span id='topic+HDDM_W'></span>

<h3>Description</h3>

<p>Implements the Kolmogorov-Smirnov test for detecting distribution changes within
a window of streaming data. KSWIN is a non-parametric method for change detection that compares
two samples to determine if they come from the same distribution.
</p>


<h3>Details</h3>

<p>KSWIN is effective for detecting changes in the underlying distribution of data streams.
It is particularly useful in scenarios where data properties may evolve over time, allowing for
early detection of changes that might affect subsequent data processing.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>drift_confidence</code></dt><dd><p>Confidence level for detecting a drift (default: 0.001).</p>
</dd>
<dt><code>warning_confidence</code></dt><dd><p>Confidence level for warning detection (default: 0.005).</p>
</dd>
<dt><code>lambda_option</code></dt><dd><p>Decay rate for the EWMA statistic, smaller values give less weight to recent data (default: 0.050).</p>
</dd>
<dt><code>two_side_option</code></dt><dd><p>Boolean flag for one-sided or two-sided error monitoring (default: TRUE).</p>
</dd>
<dt><code>total</code></dt><dd><p>Container for the EWMA estimator and its bounded conditional sum.</p>
</dd>
<dt><code>sample1_decr_monitor</code></dt><dd><p>First sample monitor for detecting decrements.</p>
</dd>
<dt><code>sample1_incr_monitor</code></dt><dd><p>First sample monitor for detecting increments.</p>
</dd>
<dt><code>sample2_decr_monitor</code></dt><dd><p>Second sample monitor for detecting decrements.</p>
</dd>
<dt><code>sample2_incr_monitor</code></dt><dd><p>Second sample monitor for detecting increments.</p>
</dd>
<dt><code>incr_cutpoint</code></dt><dd><p>Cutpoint for deciding increments.</p>
</dd>
<dt><code>decr_cutpoint</code></dt><dd><p>Cutpoint for deciding decrements.</p>
</dd>
<dt><code>width</code></dt><dd><p>Current width of the window.</p>
</dd>
<dt><code>delay</code></dt><dd><p>Delay count since last reset.</p>
</dd>
<dt><code>change_detected</code></dt><dd><p>Boolean indicating if a change was detected.</p>
</dd>
<dt><code>warning_detected</code></dt><dd><p>Boolean indicating if currently in a warning zone.</p>
</dd>
<dt><code>estimation</code></dt><dd><p>The current estimation of the stream's mean.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HDDM_W-new"><code>HDDM_W$new()</code></a>
</p>
</li>
<li> <p><a href="#method-HDDM_W-add_element"><code>HDDM_W$add_element()</code></a>
</p>
</li>
<li> <p><a href="#method-HDDM_W-SampleInfo"><code>HDDM_W$SampleInfo()</code></a>
</p>
</li>
<li> <p><a href="#method-HDDM_W-reset"><code>HDDM_W$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-HDDM_W-detect_mean_increment"><code>HDDM_W$detect_mean_increment()</code></a>
</p>
</li>
<li> <p><a href="#method-HDDM_W-monitor_mean_incr"><code>HDDM_W$monitor_mean_incr()</code></a>
</p>
</li>
<li> <p><a href="#method-HDDM_W-monitor_mean_decr"><code>HDDM_W$monitor_mean_decr()</code></a>
</p>
</li>
<li> <p><a href="#method-HDDM_W-update_incr_statistics"><code>HDDM_W$update_incr_statistics()</code></a>
</p>
</li>
<li> <p><a href="#method-HDDM_W-update_decr_statistics"><code>HDDM_W$update_decr_statistics()</code></a>
</p>
</li>
<li> <p><a href="#method-HDDM_W-clone"><code>HDDM_W$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-HDDM_W-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initializes the HDDM_W detector with specific parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDDM_W$new(
  drift_confidence = 0.001,
  warning_confidence = 0.005,
  lambda_option = 0.05,
  two_side_option = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>drift_confidence</code></dt><dd><p>Confidence level for drift detection.</p>
</dd>
<dt><code>warning_confidence</code></dt><dd><p>Confidence level for issuing warnings.</p>
</dd>
<dt><code>lambda_option</code></dt><dd><p>Decay rate for the EWMA statistic.</p>
</dd>
<dt><code>two_side_option</code></dt><dd><p>Whether to monitor both increases and decreases.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HDDM_W-add_element"></a>



<h4>Method <code>add_element()</code></h4>

<p>Adds a new element to the data stream and updates the detection status.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDDM_W$add_element(prediction)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>prediction</code></dt><dd><p>The new data value to add.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HDDM_W-SampleInfo"></a>



<h4>Method <code>SampleInfo()</code></h4>

<p>Provides current information about the monitoring samples, typically used for debugging or monitoring.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDDM_W$SampleInfo()</pre></div>


<hr>
<a id="method-HDDM_W-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Resets the internal state to initial conditions.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDDM_W$reset()</pre></div>


<hr>
<a id="method-HDDM_W-detect_mean_increment"></a>



<h4>Method <code>detect_mean_increment()</code></h4>

<p>Detects an increment in the mean between two samples based on the provided confidence level.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDDM_W$detect_mean_increment(sample1, sample2, confidence)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sample1</code></dt><dd><p>First sample information, containing EWMA estimator and bounded conditional sum.</p>
</dd>
<dt><code>sample2</code></dt><dd><p>Second sample information, containing EWMA estimator and bounded conditional sum.</p>
</dd>
<dt><code>confidence</code></dt><dd><p>The confidence level used for calculating the bound.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Boolean indicating if an increment in mean was detected.
</p>


<hr>
<a id="method-HDDM_W-monitor_mean_incr"></a>



<h4>Method <code>monitor_mean_incr()</code></h4>

<p>Monitors the data stream for an increase in the mean based on the set confidence level.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDDM_W$monitor_mean_incr(confidence)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>confidence</code></dt><dd><p>The confidence level used to detect changes in the mean.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Boolean indicating if an increase in the mean was detected.
</p>


<hr>
<a id="method-HDDM_W-monitor_mean_decr"></a>



<h4>Method <code>monitor_mean_decr()</code></h4>

<p>Monitors the data stream for a decrease in the mean based on the set confidence level.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDDM_W$monitor_mean_decr(confidence)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>confidence</code></dt><dd><p>The confidence level used to detect changes in the mean.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Boolean indicating if a decrease in the mean was detected.
</p>


<hr>
<a id="method-HDDM_W-update_incr_statistics"></a>



<h4>Method <code>update_incr_statistics()</code></h4>

<p>Updates increment statistics for drift monitoring based on new values and confidence.
This method adjusts the cutpoint for increments and updates the monitoring samples.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDDM_W$update_incr_statistics(value, confidence)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>value</code></dt><dd><p>The new value to update statistics.</p>
</dd>
<dt><code>confidence</code></dt><dd><p>The confidence level for the update.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HDDM_W-update_decr_statistics"></a>



<h4>Method <code>update_decr_statistics()</code></h4>

<p>Updates decrement statistics for drift monitoring based on new values and confidence.
This method adjusts the cutpoint for decrements and updates the monitoring samples.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDDM_W$update_decr_statistics(value, confidence)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>value</code></dt><dd><p>The new value to update statistics.</p>
</dd>
<dt><code>confidence</code></dt><dd><p>The confidence level for the update.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HDDM_W-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDDM_W$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Frías-Blanco I, del Campo-Ávila J, Ramos-Jimenez G, et al. Online and non-parametric drift detection methods based
on Hoeffding’s bounds. IEEE Transactions on Knowledge and Data Engineering, 2014, 27(3): 810-823.
</p>
<p>Albert Bifet, Geoff Holmes, Richard Kirkby, Bernhard Pfahringer. MOA: Massive Online Analysis;
Journal of Machine Learning Research 11: 1601-1604, 2010.
Implementation: https://github.com/scikit-multiflow/scikit-multiflow/blob/a7e316d1cc79988a6df40da35312e00f6c4eabb2/src/skmultiflow/drift_detection/hddm_w.py
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)  # Setting a seed for reproducibility
data_part1 &lt;- sample(c(0, 1), size = 100, replace = TRUE, prob = c(0.7, 0.3))

# Introduce a change in data distribution
data_part2 &lt;- sample(c(0, 1), size = 100, replace = TRUE, prob = c(0.3, 0.7))

# Combine the two parts
data_stream &lt;- c(data_part1, data_part2)

# Initialize the HDDM_W object
hddm_w_instance &lt;- HDDM_W$new()

# Iterate through the data stream
for(i in seq_along(data_stream)) {
  hddm_w_instance$add_element(data_stream[i])
  if(hddm_w_instance$warning_detected) {
    message(paste("Warning detected at index:", i))
  }
  if(hddm_w_instance$change_detected) {
    message(paste("Concept drift detected at index:", i))
  }
}
</code></pre>

<hr>
<h2 id='KSWIN'>KSWIN (Kolmogorov-Smirnov WINdowing) for Change Detection</h2><span id='topic+KSWIN'></span>

<h3>Description</h3>

<p>Implements the Kolmogorov-Smirnov test for detecting distribution changes within
a window of streaming data. KSWIN is a non-parametric method for change detection that compares
two samples to determine if they come from the same distribution.
</p>


<h3>Details</h3>

<p>KSWIN is effective for detecting changes in the underlying distribution of data streams.
It is particularly useful in scenarios where data properties may evolve over time, allowing for
early detection of changes that might affect subsequent data processing.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>alpha</code></dt><dd><p>Significance level for the KS test.</p>
</dd>
<dt><code>window_size</code></dt><dd><p>Total size of the data window used for testing.</p>
</dd>
<dt><code>stat_size</code></dt><dd><p>Number of data points sampled from the window for the KS test.</p>
</dd>
<dt><code>window</code></dt><dd><p>Current data window used for change detection.</p>
</dd>
<dt><code>change_detected</code></dt><dd><p>Boolean flag indicating whether a change has been detected.</p>
</dd>
<dt><code>p_value</code></dt><dd><p>P-value of the most recent KS test.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-KSWIN-new"><code>KSWIN$new()</code></a>
</p>
</li>
<li> <p><a href="#method-KSWIN-reset"><code>KSWIN$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-KSWIN-add_element"><code>KSWIN$add_element()</code></a>
</p>
</li>
<li> <p><a href="#method-KSWIN-detected_change"><code>KSWIN$detected_change()</code></a>
</p>
</li>
<li> <p><a href="#method-KSWIN-clone"><code>KSWIN$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-KSWIN-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initializes the KSWIN detector with specific settings.
</p>


<h5>Usage</h5>

<div class="r"><pre>KSWIN$new(alpha = 0.005, window_size = 100, stat_size = 30, data = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>alpha</code></dt><dd><p>The significance level for the KS test.</p>
</dd>
<dt><code>window_size</code></dt><dd><p>The size of the data window for change detection.</p>
</dd>
<dt><code>stat_size</code></dt><dd><p>The number of samples in the statistical test window.</p>
</dd>
<dt><code>data</code></dt><dd><p>Initial data to populate the window, if provided.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-KSWIN-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Resets the internal state of the detector to its initial conditions.
</p>


<h5>Usage</h5>

<div class="r"><pre>KSWIN$reset()</pre></div>


<hr>
<a id="method-KSWIN-add_element"></a>



<h4>Method <code>add_element()</code></h4>

<p>Adds a new element to the data window and updates the detection status based on the KS test.
</p>


<h5>Usage</h5>

<div class="r"><pre>KSWIN$add_element(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>The new data value to add to the window.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-KSWIN-detected_change"></a>



<h4>Method <code>detected_change()</code></h4>

<p>Checks if a change has been detected based on the most recent KS test.
</p>


<h5>Usage</h5>

<div class="r"><pre>KSWIN$detected_change()</pre></div>



<h5>Returns</h5>

<p>Boolean indicating whether a change was detected.
</p>


<hr>
<a id="method-KSWIN-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>KSWIN$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Christoph Raab, Moritz Heusinger, Frank-Michael Schleif, Reactive
Soft Prototype Computing for Concept Drift Streams, Neurocomputing, 2020.
</p>
<p>Implementation: https://github.com/scikit-multiflow/scikit-multiflow/blob/a7e316d1cc79988a6df40da35312e00f6c4eabb2/src/skmultiflow/drift_detection/kswin.py
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)  # Setting a seed for reproducibility
data_part1 &lt;- sample(c(0, 1), size = 100, replace = TRUE, prob = c(0.7, 0.3))

# Introduce a change in data distribution
data_part2 &lt;- sample(c(0, 1), size = 100, replace = TRUE, prob = c(0.3, 0.7))

# Combine the two parts
data_stream &lt;- c(data_part1, data_part2)
</code></pre>

<hr>
<h2 id='PageHinkley'>Page-Hinkley Test for Change Detection</h2><span id='topic+PageHinkley'></span>

<h3>Description</h3>

<p>Implements the Page-Hinkley test, a sequential analysis technique used to detect
changes in the average value of a continuous signal or process. It is effective
in detecting small but persistent changes over time, making it suitable for real-time
monitoring applications.
</p>


<h3>Details</h3>

<p>The Page-Hinkley test is a type of cumulative sum (CUSUM) test that accumulates differences
between data points and a reference value (running mean). It triggers a change detection
signal when the cumulative sum exceeds a predefined threshold. This test is especially
useful for early detection of subtle shifts in the behavior of the monitored process.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>min_instances</code></dt><dd><p>Minimum number of instances required to start detection.</p>
</dd>
<dt><code>delta</code></dt><dd><p>Minimal change considered significant for detection.</p>
</dd>
<dt><code>threshold</code></dt><dd><p>Decision threshold for signaling a change.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>Forgetting factor for the cumulative sum calculation.</p>
</dd>
<dt><code>x_mean</code></dt><dd><p>Running mean of the observed values.</p>
</dd>
<dt><code>sample_count</code></dt><dd><p>Counter for the number of samples seen.</p>
</dd>
<dt><code>sum</code></dt><dd><p>Cumulative sum used in the change detection.</p>
</dd>
<dt><code>change_detected</code></dt><dd><p>Boolean indicating if a drift has been detected.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PageHinkley-new"><code>PageHinkley$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PageHinkley-reset"><code>PageHinkley$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-PageHinkley-add_element"><code>PageHinkley$add_element()</code></a>
</p>
</li>
<li> <p><a href="#method-PageHinkley-detected_change"><code>PageHinkley$detected_change()</code></a>
</p>
</li>
<li> <p><a href="#method-PageHinkley-clone"><code>PageHinkley$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-PageHinkley-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initializes the Page-Hinkley test with specific parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>PageHinkley$new(
  min_instances = 30,
  delta = 0.005,
  threshold = 50,
  alpha = 1 - 1e-04
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>min_instances</code></dt><dd><p>Minimum number of samples before detection starts.</p>
</dd>
<dt><code>delta</code></dt><dd><p>Change magnitude to trigger detection.</p>
</dd>
<dt><code>threshold</code></dt><dd><p>Cumulative sum threshold for change detection.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>Weight for older data in cumulative sum.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PageHinkley-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Resets all the internal states of the detector to initial values.
</p>


<h5>Usage</h5>

<div class="r"><pre>PageHinkley$reset()</pre></div>


<hr>
<a id="method-PageHinkley-add_element"></a>



<h4>Method <code>add_element()</code></h4>

<p>Adds a new element to the data stream and updates the detection status based on the Page-Hinkley test.
</p>


<h5>Usage</h5>

<div class="r"><pre>PageHinkley$add_element(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>New data value to add and evaluate.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PageHinkley-detected_change"></a>



<h4>Method <code>detected_change()</code></h4>

<p>Checks if a change has been detected based on the last update.
</p>


<h5>Usage</h5>

<div class="r"><pre>PageHinkley$detected_change()</pre></div>



<h5>Returns</h5>

<p>Boolean indicating whether a change was detected.
</p>


<hr>
<a id="method-PageHinkley-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PageHinkley$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>E. S. Page. 1954. Continuous Inspection Schemes.
Biometrika 41, 1/2 (1954), 100–115.
</p>
<p>Montiel, Jacob, et al. &quot;Scikit-Multiflow: A Multi-output Streaming Framework.&quot; Journal of Machine
Learning Research, 2018. This framework provides tools for multi-output and stream data mining
and was an inspiration for some of the implementations in this class.
</p>
<p>Implementation: https://github.com/scikit-multiflow/scikit-multiflow/blob/a7e316d1cc79988a6df40da35312e00f6c4eabb2/src/skmultiflow/drift_detection/page_hinkley.py
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)  # Setting a seed for reproducibility
data_part1 &lt;- sample(c(0, 1), size = 100, replace = TRUE, prob = c(0.7, 0.3))

# Introduce a change in data distribution
data_part2 &lt;- sample(c(0, 5), size = 100, replace = TRUE, prob = c(0.3, 0.7))

# Combine the two parts
data_stream &lt;- c(data_part1, data_part2)
ph &lt;- PageHinkley$new()
for (i in seq_along(data_stream)) {
  ph$add_element(data_stream[i])
  if (ph$detected_change()) {
    cat(sprintf("Change has been detected in data: %s - at index: %d\n", data_stream[i], i))
  }
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
