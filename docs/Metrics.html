<!DOCTYPE html><html><head><title>Help for package Metrics</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Metrics}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#accuracy'><p>Accuracy</p></a></li>
<li><a href='#ae'><p>Absolute Error</p></a></li>
<li><a href='#ape'><p>Absolute Percent Error</p></a></li>
<li><a href='#apk'><p>Average Precision at k</p></a></li>
<li><a href='#auc'><p>Area under the ROC curve (AUC)</p></a></li>
<li><a href='#bias'><p>Bias</p></a></li>
<li><a href='#ce'><p>Classification Error</p></a></li>
<li><a href='#f1'><p>F1 Score</p></a></li>
<li><a href='#fbeta_score'><p>F-beta Score</p></a></li>
<li><a href='#ll'><p>Log Loss</p></a></li>
<li><a href='#logLoss'><p>Mean Log Loss</p></a></li>
<li><a href='#mae'><p>Mean Absolute Error</p></a></li>
<li><a href='#mape'><p>Mean Absolute Percent Error</p></a></li>
<li><a href='#mapk'><p>Mean Average Precision at k</p></a></li>
<li><a href='#mase'><p>Mean Absolute Scaled Error</p></a></li>
<li><a href='#mdae'><p>Median Absolute Error</p></a></li>
<li><a href='#MeanQuadraticWeightedKappa'><p>Mean Quadratic Weighted Kappa</p></a></li>
<li><a href='#mse'><p>Mean Squared Error</p></a></li>
<li><a href='#msle'><p>Mean Squared Log Error</p></a></li>
<li><a href='#params_binary'><p>Inherit Documentation for Binary Classification Metrics</p></a></li>
<li><a href='#params_classification'><p>Inherit Documentation for Classification Metrics</p></a></li>
<li><a href='#params_regression'><p>Inherit Documentation for Regression Metrics</p></a></li>
<li><a href='#percent_bias'><p>Percent Bias</p></a></li>
<li><a href='#precision'><p>Precision</p></a></li>
<li><a href='#rae'><p>Relative Absolute Error</p></a></li>
<li><a href='#recall'><p>Recall</p></a></li>
<li><a href='#rmse'><p>Root Mean Squared Error</p></a></li>
<li><a href='#rmsle'><p>Root Mean Squared Log Error</p></a></li>
<li><a href='#rrse'><p>Root Relative Squared Error</p></a></li>
<li><a href='#rse'><p>Relative Squared Error</p></a></li>
<li><a href='#ScoreQuadraticWeightedKappa'><p>Quadratic Weighted Kappa</p></a></li>
<li><a href='#se'><p>Squared Error</p></a></li>
<li><a href='#sle'><p>Squared Log Error</p></a></li>
<li><a href='#smape'><p>Symmetric Mean Absolute Percentage Error</p></a></li>
<li><a href='#sse'><p>Sum of Squared Errors</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Title:</td>
<td>Evaluation Metrics for Machine Learning</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of evaluation metrics in R that are commonly
             used in supervised machine learning. It implements metrics for
             regression, time series, binary classification, classification,
             and information retrieval problems. It has zero dependencies and
             a consistent, simple interface for all functions.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Frasco &lt;mfrasco6@gmail.com&gt;</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mfrasco/Metrics">https://github.com/mfrasco/Metrics</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mfrasco/Metrics/issues">https://github.com/mfrasco/Metrics/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-07-09 03:33:50 UTC; mfrasco</td>
</tr>
<tr>
<td>Author:</td>
<td>Ben Hamner [aut, cph],
  Michael Frasco [aut, cre],
  Erin LeDell [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-07-09 04:30:18 UTC</td>
</tr>
</table>
<hr>
<h2 id='accuracy'>Accuracy</h2><span id='topic+accuracy'></span>

<h3>Description</h3>

<p><code>accuracy</code> is defined as the proportion of elements in <code>actual</code> that are
equal to the corresponding element in <code>predicted</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accuracy(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accuracy_+3A_actual">actual</code></td>
<td>
<p>The ground truth vector, where elements of the vector can be any variable type.</p>
</td></tr>
<tr><td><code id="accuracy_+3A_predicted">predicted</code></td>
<td>
<p>The predicted vector, where elements of the vector represent a
prediction for the corresponding value in <code>actual</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ce">ce</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c('a', 'a', 'c', 'b', 'c')
predicted &lt;- c('a', 'b', 'c', 'b', 'a')
accuracy(actual, predicted)
</code></pre>

<hr>
<h2 id='ae'>Absolute Error</h2><span id='topic+ae'></span>

<h3>Description</h3>

<p><code>ae</code> computes the elementwise absolute difference between two numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ae(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ae_+3A_actual">actual</code></td>
<td>
<p>The ground truth numeric vector.</p>
</td></tr>
<tr><td><code id="ae_+3A_predicted">predicted</code></td>
<td>
<p>The predicted numeric vector, where each element in the vector
is a prediction for the corresponding element in <code>actual</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mae">mae</a></code> <code><a href="#topic+mdae">mdae</a></code> <code><a href="#topic+mape">mape</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c(1.1, 1.9, 3.0, 4.4, 5.0, 5.6)
predicted &lt;- c(0.9, 1.8, 2.5, 4.5, 5.0, 6.2)
ae(actual, predicted)
</code></pre>

<hr>
<h2 id='ape'>Absolute Percent Error</h2><span id='topic+ape'></span>

<h3>Description</h3>

<p><code>ape</code> computes the elementwise absolute percent difference between two numeric
vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ape(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ape_+3A_actual">actual</code></td>
<td>
<p>The ground truth numeric vector.</p>
</td></tr>
<tr><td><code id="ape_+3A_predicted">predicted</code></td>
<td>
<p>The predicted numeric vector, where each element in the vector
is a prediction for the corresponding element in <code>actual</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ape</code> is calculated as (<code>actual</code> - <code>predicted</code>) / <code>abs(actual)</code>.
This means that the function will return <code>-Inf</code>, <code>Inf</code>, or <code>NaN</code>
if <code>actual</code> is zero.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mape">mape</a></code> <code>smape</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c(1.1, 1.9, 3.0, 4.4, 5.0, 5.6)
predicted &lt;- c(0.9, 1.8, 2.5, 4.5, 5.0, 6.2)
ape(actual, predicted)
</code></pre>

<hr>
<h2 id='apk'>Average Precision at k</h2><span id='topic+apk'></span>

<h3>Description</h3>

<p><code>apk</code> computes the average precision at k, in the context of information
retrieval problems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apk(k, actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apk_+3A_k">k</code></td>
<td>
<p>The number of elements of <code>predicted</code> to consider in the calculation.</p>
</td></tr>
<tr><td><code id="apk_+3A_actual">actual</code></td>
<td>
<p>The ground truth vector of relevant documents. The vector can contain
any numeric or character values, order does not matter, and the
vector does not need to be the same length as <code>predicted</code>.</p>
</td></tr>
<tr><td><code id="apk_+3A_predicted">predicted</code></td>
<td>
<p>The predicted vector of retrieved documents. The vector can
contain any numeric of character values. However, unlike <code>actual</code>,
order does matter, with the most documents deemed most likely to
be relevant at the beginning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>apk</code> loops over the first k values of <code>predicted</code>. For each value, if
the value is contained within <code>actual</code> and has not been predicted before,
we increment the number of sucesses by one and increment our score by the number
of successes divided by k. Then, we return our final score divided by the number
of relevant documents (i.e. the length of <code>actual</code>).
</p>
<p><code>apk</code> will return <code>NaN</code> if <code>length(actual)</code> equals <code>0</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apk">apk</a></code> <code><a href="#topic+f1">f1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c('a', 'b', 'd')
predicted &lt;- c('b', 'c', 'a', 'e', 'f')
apk(3, actual, predicted)
</code></pre>

<hr>
<h2 id='auc'>Area under the ROC curve (AUC)</h2><span id='topic+auc'></span>

<h3>Description</h3>

<p><code>auc</code> computes the area under the receiver-operator characteristic curve (AUC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auc(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auc_+3A_actual">actual</code></td>
<td>
<p>The ground truth binary numeric vector containing 1 for the positive
class and 0 for the negative class.</p>
</td></tr>
<tr><td><code id="auc_+3A_predicted">predicted</code></td>
<td>
<p>A numeric vector of predicted values, where the smallest values correspond
to the observations most believed to be in the negative class
and the largest values indicate the observations most believed
to be in the positive class. Each element represents the
prediction for the corresponding element in <code>actual</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>auc</code> uses the fact that the area under the ROC curve is equal to the probability
that a randomly chosen positive observation has a higher predicted value than a
randomly chosen negative value. In order to compute this probability, we can
calculate the Mann-Whitney U statistic. This method is very fast, since we
do not need to compute the ROC curve first.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c(1, 1, 1, 0, 0, 0)
predicted &lt;- c(0.9, 0.8, 0.4, 0.5, 0.3, 0.2)
auc(actual, predicted)
</code></pre>

<hr>
<h2 id='bias'>Bias</h2><span id='topic+bias'></span>

<h3>Description</h3>

<p><code>bias</code> computes the average amount by which <code>actual</code> is greater than
<code>predicted</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bias(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bias_+3A_actual">actual</code></td>
<td>
<p>The ground truth numeric vector.</p>
</td></tr>
<tr><td><code id="bias_+3A_predicted">predicted</code></td>
<td>
<p>The predicted numeric vector, where each element in the vector
is a prediction for the corresponding element in <code>actual</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a model is unbiased <code>bias(actual, predicted)</code> should be close to zero.
Bias is calculated by taking the average of (<code>actual</code> - <code>predicted</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+percent_bias">percent_bias</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c(1.1, 1.9, 3.0, 4.4, 5.0, 5.6)
predicted &lt;- c(0.9, 1.8, 2.5, 4.5, 5.0, 6.2)
bias(actual, predicted)
</code></pre>

<hr>
<h2 id='ce'>Classification Error</h2><span id='topic+ce'></span>

<h3>Description</h3>

<p><code>ce</code> is defined as the proportion of elements in <code>actual</code> that are not equal
to the corresponding element in <code>predicted</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ce(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ce_+3A_actual">actual</code></td>
<td>
<p>The ground truth vector, where elements of the vector can be any variable type.</p>
</td></tr>
<tr><td><code id="ce_+3A_predicted">predicted</code></td>
<td>
<p>The predicted vector, where elements of the vector represent a
prediction for the corresponding value in <code>actual</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+accuracy">accuracy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c('a', 'a', 'c', 'b', 'c')
predicted &lt;- c('a', 'b', 'c', 'b', 'a')
ce(actual, predicted)
</code></pre>

<hr>
<h2 id='f1'>F1 Score</h2><span id='topic+f1'></span>

<h3>Description</h3>

<p><code>f1</code> computes the F1 Score in the context of information retrieval problems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f1(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f1_+3A_actual">actual</code></td>
<td>
<p>The ground truth vector of relevant documents. The vector can contain
any numeric or character values, order does not matter, and the
vector does not need to be the same length as <code>predicted</code>.</p>
</td></tr>
<tr><td><code id="f1_+3A_predicted">predicted</code></td>
<td>
<p>The predicted vector of retrieved documents. The vector can contain
any numeric or character values, order does not matter, and the
vector does not need to be the same length as <code>actual</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>f1</code> is defined as <code class="reqn">2 * precision * recall / (precision + recall)</code>. In the
context of information retrieval problems, precision is the proportion of retrieved
documents that are relevant to a query and recall is the proportion of relevant
documents that are successfully retrieved by a query. If there are zero relevant
documents that are retrieved, zero relevant documents, or zero predicted documents,
<code>f1</code> is defined as <code>0</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apk">apk</a></code> <code><a href="#topic+mapk">mapk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c('a', 'c', 'd')
predicted &lt;- c('d', 'e')
f1(actual, predicted)
</code></pre>

<hr>
<h2 id='fbeta_score'>F-beta Score</h2><span id='topic+fbeta_score'></span>

<h3>Description</h3>

<p><code>fbeta_score</code> computes a weighted harmonic mean of Precision and Recall.
The <code>beta</code> parameter controls the weighting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbeta_score(actual, predicted, beta = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fbeta_score_+3A_actual">actual</code></td>
<td>
<p>The ground truth binary numeric vector containing 1 for the positive
class and 0 for the negative class.</p>
</td></tr>
<tr><td><code id="fbeta_score_+3A_predicted">predicted</code></td>
<td>
<p>The predicted binary numeric vector containing 1 for the positive
class and 0 for the negative class. Each element represents the
prediction for the corresponding element in <code>actual</code>.</p>
</td></tr>
<tr><td><code id="fbeta_score_+3A_beta">beta</code></td>
<td>
<p>A non-negative real number controlling how close the F-beta score is to 
either Precision or Recall. When <code>beta</code> is at the default of 1, 
the F-beta Score is exactly an equally weighted harmonic mean.
The F-beta score will weight toward Precision when <code>beta</code> is less 
than one.  The F-beta score will weight toward Recall when <code>beta</code> is
greater than one.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+precision">precision</a></code> <code><a href="#topic+recall">recall</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c(1, 1, 1, 0, 0, 0)
predicted &lt;- c(1, 0, 1, 1, 1, 1)
recall(actual, predicted)
</code></pre>

<hr>
<h2 id='ll'>Log Loss</h2><span id='topic+ll'></span>

<h3>Description</h3>

<p><code>ll</code> computes the elementwise log loss between two numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ll(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ll_+3A_actual">actual</code></td>
<td>
<p>The ground truth binary numeric vector containing 1 for the positive
class and 0 for the negative class.</p>
</td></tr>
<tr><td><code id="ll_+3A_predicted">predicted</code></td>
<td>
<p>A numeric vector of predicted values, where the values correspond
to the probabilities that each observation in <code>actual</code>
belongs to the positive class</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+logLoss">logLoss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c(1, 1, 1, 0, 0, 0)
predicted &lt;- c(0.9, 0.8, 0.4, 0.5, 0.3, 0.2)
ll(actual, predicted)
</code></pre>

<hr>
<h2 id='logLoss'>Mean Log Loss</h2><span id='topic+logLoss'></span>

<h3>Description</h3>

<p><code>logLoss</code> computes the average log loss between two numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLoss(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLoss_+3A_actual">actual</code></td>
<td>
<p>The ground truth binary numeric vector containing 1 for the positive
class and 0 for the negative class.</p>
</td></tr>
<tr><td><code id="logLoss_+3A_predicted">predicted</code></td>
<td>
<p>A numeric vector of predicted values, where the values correspond
to the probabilities that each observation in <code>actual</code>
belongs to the positive class</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ll">ll</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c(1, 1, 1, 0, 0, 0)
predicted &lt;- c(0.9, 0.8, 0.4, 0.5, 0.3, 0.2)
logLoss(actual, predicted)
</code></pre>

<hr>
<h2 id='mae'>Mean Absolute Error</h2><span id='topic+mae'></span>

<h3>Description</h3>

<p><code>mae</code> computes the average absolute difference between two numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mae(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mae_+3A_actual">actual</code></td>
<td>
<p>The ground truth numeric vector.</p>
</td></tr>
<tr><td><code id="mae_+3A_predicted">predicted</code></td>
<td>
<p>The predicted numeric vector, where each element in the vector
is a prediction for the corresponding element in <code>actual</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mdae">mdae</a></code> <code><a href="#topic+mape">mape</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c(1.1, 1.9, 3.0, 4.4, 5.0, 5.6)
predicted &lt;- c(0.9, 1.8, 2.5, 4.5, 5.0, 6.2)
mae(actual, predicted)
</code></pre>

<hr>
<h2 id='mape'>Mean Absolute Percent Error</h2><span id='topic+mape'></span>

<h3>Description</h3>

<p><code>mape</code> computes the average absolute percent difference between two numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mape(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mape_+3A_actual">actual</code></td>
<td>
<p>The ground truth numeric vector.</p>
</td></tr>
<tr><td><code id="mape_+3A_predicted">predicted</code></td>
<td>
<p>The predicted numeric vector, where each element in the vector
is a prediction for the corresponding element in <code>actual</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mape</code> is calculated as the average of (<code>actual</code> - <code>predicted</code>) / <code>abs(actual)</code>.
This means that the function will return <code>-Inf</code>, <code>Inf</code>, or <code>NaN</code>
if <code>actual</code> is zero. Due to the instability at or near zero, <code>smape</code> or
<code>mase</code> are often used as alternatives.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mae">mae</a></code> <code><a href="#topic+smape">smape</a></code> <code><a href="#topic+mase">mase</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c(1.1, 1.9, 3.0, 4.4, 5.0, 5.6)
predicted &lt;- c(0.9, 1.8, 2.5, 4.5, 5.0, 6.2)
mape(actual, predicted)
</code></pre>

<hr>
<h2 id='mapk'>Mean Average Precision at k</h2><span id='topic+mapk'></span>

<h3>Description</h3>

<p><code>mapk</code> computes the mean average precision at k for a set of predictions, in
the context of information retrieval problems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapk(k, actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapk_+3A_k">k</code></td>
<td>
<p>The number of elements of <code>predicted</code> to consider in the calculation.</p>
</td></tr>
<tr><td><code id="mapk_+3A_actual">actual</code></td>
<td>
<p>A list of vectors, where each vector represents a ground truth vector
of relevant documents. In each vector, the elements can be numeric
or character values, and the order of the elements does not matter.</p>
</td></tr>
<tr><td><code id="mapk_+3A_predicted">predicted</code></td>
<td>
<p>A list of vectors, where each vector represents the predicted vector
of retrieved documents for the corresponding element of <code>actual</code>.
In each vector, the order of the elements does matter, with the
elements believed most likely to be relevant at the beginning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mapk</code> evaluates <code>apk</code> for each pair of elements from <code>actual</code> and
<code>predicted</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apk">apk</a></code> <code><a href="#topic+f1">f1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- list(c('a', 'b'), c('a'), c('x', 'y', 'b'))
predicted &lt;- list(c('a', 'c', 'd'), c('x', 'b', 'a', 'b'), c('y'))
mapk(2, actual, predicted)

actual &lt;- list(c(1, 5, 7, 9), c(2, 3), c(2, 5, 6))
predicted &lt;- list(c(5, 6, 7, 8, 9), c(1, 2, 3), c(2, 4, 6, 8))
mapk(3, actual, predicted)
</code></pre>

<hr>
<h2 id='mase'>Mean Absolute Scaled Error</h2><span id='topic+mase'></span>

<h3>Description</h3>

<p><code>mase</code> computes the mean absolute scaled error between two numeric
vectors. This function is only intended for time series data, where
<code>actual</code> and <code>numeric</code> are numeric vectors ordered by time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mase(actual, predicted, step_size = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mase_+3A_actual">actual</code></td>
<td>
<p>The ground truth numeric vector ordered in time, with most recent
observation at the end of the vector.</p>
</td></tr>
<tr><td><code id="mase_+3A_predicted">predicted</code></td>
<td>
<p>The predicted numeric vector ordered in time, where each element
of the vector represents a prediction for the corresponding
element of <code>actual</code>.</p>
</td></tr>
<tr><td><code id="mase_+3A_step_size">step_size</code></td>
<td>
<p>A positive integer that specifies how many observations to look back
in time in order to compute the naive forecast. The default is
<code>1</code>, which means that the naive forecast for the current time
period is the actual value of the previous period.
</p>
<p>However, if <code>actual</code> and <code>predictions</code> were quarterly
predictions over many years, letting <code>step_size = 4</code>, would
mean that the naive forecast for the current time period would
be the actual value from the same quarter last year. In this way,
<code>mase</code> can account for seasonality.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+smape">smape</a></code> <code><a href="#topic+mape">mape</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c(1.1, 1.9, 3.0, 4.4, 5.0, 5.6)
predicted &lt;- c(0.9, 1.8, 2.5, 4.5, 5.0, 6.2)
step_size &lt;- 1
mase(actual, predicted, step_size)
</code></pre>

<hr>
<h2 id='mdae'>Median Absolute Error</h2><span id='topic+mdae'></span>

<h3>Description</h3>

<p><code>mdae</code> computes the median absolute difference between two numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdae(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mdae_+3A_actual">actual</code></td>
<td>
<p>The ground truth numeric vector.</p>
</td></tr>
<tr><td><code id="mdae_+3A_predicted">predicted</code></td>
<td>
<p>The predicted numeric vector, where each element in the vector
is a prediction for the corresponding element in <code>actual</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mae">mae</a></code> <code><a href="#topic+mape">mape</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c(1.1, 1.9, 3.0, 4.4, 5.0, 5.6)
predicted &lt;- c(0.9, 1.8, 2.5, 4.5, 5.0, 6.2)
mdae(actual, predicted)
</code></pre>

<hr>
<h2 id='MeanQuadraticWeightedKappa'>Mean Quadratic Weighted Kappa</h2><span id='topic+MeanQuadraticWeightedKappa'></span>

<h3>Description</h3>

<p><code>MeanQuadraticWeightedKappa</code> computes the mean quadratic weighted kappa,
which can optionally be weighted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MeanQuadraticWeightedKappa(kappas, weights = rep(1, length(kappas)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MeanQuadraticWeightedKappa_+3A_kappas">kappas</code></td>
<td>
<p>A numeric vector of possible kappas.</p>
</td></tr>
<tr><td><code id="MeanQuadraticWeightedKappa_+3A_weights">weights</code></td>
<td>
<p>An optional numeric vector of ratings.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ScoreQuadraticWeightedKappa">ScoreQuadraticWeightedKappa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kappas &lt;- c(0.3 ,0.2, 0.2, 0.5, 0.1, 0.2)
weights &lt;- c(1.0, 2.5, 1.0, 1.0, 2.0, 3.0)
MeanQuadraticWeightedKappa(kappas, weights)
</code></pre>

<hr>
<h2 id='mse'>Mean Squared Error</h2><span id='topic+mse'></span>

<h3>Description</h3>

<p><code>mse</code> computes the average squared difference between two numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mse(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mse_+3A_actual">actual</code></td>
<td>
<p>The ground truth numeric vector.</p>
</td></tr>
<tr><td><code id="mse_+3A_predicted">predicted</code></td>
<td>
<p>The predicted numeric vector, where each element in the vector
is a prediction for the corresponding element in <code>actual</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+rmse">rmse</a></code> <code><a href="#topic+mae">mae</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c(1.1, 1.9, 3.0, 4.4, 5.0, 5.6)
predicted &lt;- c(0.9, 1.8, 2.5, 4.5, 5.0, 6.2)
mse(actual, predicted)
</code></pre>

<hr>
<h2 id='msle'>Mean Squared Log Error</h2><span id='topic+msle'></span>

<h3>Description</h3>

<p><code>msle</code> computes the average of squared log error between two numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msle(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msle_+3A_actual">actual</code></td>
<td>
<p>The ground truth non-negative vector</p>
</td></tr>
<tr><td><code id="msle_+3A_predicted">predicted</code></td>
<td>
<p>The predicted non-negative vector, where each element in the vector
is a prediction for the corresponding element in <code>actual</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>msle</code> adds one to both <code>actual</code> and <code>predicted</code> before taking
the natural logarithm to avoid taking the natural log of zero. As a result,
the function can be used if <code>actual</code> or <code>predicted</code> have zero-valued
elements. But this function is not appropriate if either are negative valued.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmsle">rmsle</a></code> <code><a href="#topic+sle">sle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c(1.1, 1.9, 3.0, 4.4, 5.0, 5.6)
predicted &lt;- c(0.9, 1.8, 2.5, 4.5, 5.0, 6.2)
msle(actual, predicted)
</code></pre>

<hr>
<h2 id='params_binary'>Inherit Documentation for Binary Classification Metrics</h2><span id='topic+params_binary'></span>

<h3>Description</h3>

<p>This object provides the documentation for the parameters of functions
that provide binary classification metrics
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="params_binary_+3A_actual">actual</code></td>
<td>
<p>The ground truth binary numeric vector containing 1 for the positive
class and 0 for the negative class.</p>
</td></tr>
<tr><td><code id="params_binary_+3A_predicted">predicted</code></td>
<td>
<p>The predicted binary numeric vector containing 1 for the positive
class and 0 for the negative class. Each element represents the
prediction for the corresponding element in <code>actual</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='params_classification'>Inherit Documentation for Classification Metrics</h2><span id='topic+params_classification'></span>

<h3>Description</h3>

<p>This object provides the documentation for the parameters of functions
that provide classification metrics
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="params_classification_+3A_actual">actual</code></td>
<td>
<p>The ground truth vector, where elements of the vector can be any variable type.</p>
</td></tr>
<tr><td><code id="params_classification_+3A_predicted">predicted</code></td>
<td>
<p>The predicted vector, where elements of the vector represent a
prediction for the corresponding value in <code>actual</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='params_regression'>Inherit Documentation for Regression Metrics</h2><span id='topic+params_regression'></span>

<h3>Description</h3>

<p>This object provides the documentation for the parameters of functions
that provide regression metrics
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="params_regression_+3A_actual">actual</code></td>
<td>
<p>The ground truth numeric vector.</p>
</td></tr>
<tr><td><code id="params_regression_+3A_predicted">predicted</code></td>
<td>
<p>The predicted numeric vector, where each element in the vector
is a prediction for the corresponding element in <code>actual</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='percent_bias'>Percent Bias</h2><span id='topic+percent_bias'></span>

<h3>Description</h3>

<p><code>percent_bias</code> computes the average amount that <code>actual</code> is greater
than <code>predicted</code> as a percentage of the absolute value of <code>actual</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>percent_bias(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="percent_bias_+3A_actual">actual</code></td>
<td>
<p>The ground truth numeric vector.</p>
</td></tr>
<tr><td><code id="percent_bias_+3A_predicted">predicted</code></td>
<td>
<p>The predicted numeric vector, where each element in the vector
is a prediction for the corresponding element in <code>actual</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a model is unbiased <code>percent_bias(actual, predicted)</code> should be close
to zero. Percent Bias is calculated by taking the average of
(<code>actual</code> - <code>predicted</code>) / <code>abs(actual)</code> across all observations.
</p>
<p><code>percent_bias</code> will give <code>-Inf</code>, <code>Inf</code>, or <code>NaN</code>, if any
elements of <code>actual</code> are <code>0</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bias">bias</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c(1.1, 1.9, 3.0, 4.4, 5.0, 5.6)
predicted &lt;- c(0.9, 1.8, 2.5, 4.5, 5.0, 6.2)
percent_bias(actual, predicted)
</code></pre>

<hr>
<h2 id='precision'>Precision</h2><span id='topic+precision'></span>

<h3>Description</h3>

<p><code>precision</code> computes proportion of observations predicted to be in the
positive class (i.e. the element in <code>predicted</code> equals 1)
that actually belong to the positive class (i.e. the element 
in <code>actual</code> equals 1)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precision(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="precision_+3A_actual">actual</code></td>
<td>
<p>The ground truth binary numeric vector containing 1 for the positive
class and 0 for the negative class.</p>
</td></tr>
<tr><td><code id="precision_+3A_predicted">predicted</code></td>
<td>
<p>The predicted binary numeric vector containing 1 for the positive
class and 0 for the negative class. Each element represents the
prediction for the corresponding element in <code>actual</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+recall">recall</a></code> <code><a href="#topic+fbeta_score">fbeta_score</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c(1, 1, 1, 0, 0, 0)
predicted &lt;- c(1, 1, 1, 1, 1, 1)
precision(actual, predicted)
</code></pre>

<hr>
<h2 id='rae'>Relative Absolute Error</h2><span id='topic+rae'></span>

<h3>Description</h3>

<p><code>rae</code> computes the relative absolute error between two numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rae(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rae_+3A_actual">actual</code></td>
<td>
<p>The ground truth numeric vector.</p>
</td></tr>
<tr><td><code id="rae_+3A_predicted">predicted</code></td>
<td>
<p>The predicted numeric vector, where each element in the vector
is a prediction for the corresponding element in <code>actual</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rae</code> divides <code>sum(ae(actual, predicted))</code> by <code>sum(ae(actual, mean(actual)))</code>,
meaning that it provides the absolute error of the predictions relative to a naive model that
predicted the mean for every data point.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rse">rse</a></code> <code><a href="#topic+rrse">rrse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c(1.1, 1.9, 3.0, 4.4, 5.0, 5.6)
predicted &lt;- c(0.9, 1.8, 2.5, 4.5, 5.0, 6.2)
rrse(actual, predicted)
</code></pre>

<hr>
<h2 id='recall'>Recall</h2><span id='topic+recall'></span>

<h3>Description</h3>

<p><code>recall</code> computes proportion of observations in the positive class
(i.e. the element in <code>actual</code> equals 1) that are predicted
to be in the positive class (i.e. the element in <code>predicted</code>
equals 1)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recall(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recall_+3A_actual">actual</code></td>
<td>
<p>The ground truth binary numeric vector containing 1 for the positive
class and 0 for the negative class.</p>
</td></tr>
<tr><td><code id="recall_+3A_predicted">predicted</code></td>
<td>
<p>The predicted binary numeric vector containing 1 for the positive
class and 0 for the negative class. Each element represents the
prediction for the corresponding element in <code>actual</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+precision">precision</a></code> <code><a href="#topic+fbeta_score">fbeta_score</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c(1, 1, 1, 0, 0, 0)
predicted &lt;- c(1, 0, 1, 1, 1, 1)
recall(actual, predicted)
</code></pre>

<hr>
<h2 id='rmse'>Root Mean Squared Error</h2><span id='topic+rmse'></span>

<h3>Description</h3>

<p><code>rmse</code> computes the root mean squared error between two numeric vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmse(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmse_+3A_actual">actual</code></td>
<td>
<p>The ground truth numeric vector.</p>
</td></tr>
<tr><td><code id="rmse_+3A_predicted">predicted</code></td>
<td>
<p>The predicted numeric vector, where each element in the vector
is a prediction for the corresponding element in <code>actual</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mse">mse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c(1.1, 1.9, 3.0, 4.4, 5.0, 5.6)
predicted &lt;- c(0.9, 1.8, 2.5, 4.5, 5.0, 6.2)
rmse(actual, predicted)
</code></pre>

<hr>
<h2 id='rmsle'>Root Mean Squared Log Error</h2><span id='topic+rmsle'></span>

<h3>Description</h3>

<p><code>rmsle</code> computes the root mean squared log error between two numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmsle(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmsle_+3A_actual">actual</code></td>
<td>
<p>The ground truth non-negative vector</p>
</td></tr>
<tr><td><code id="rmsle_+3A_predicted">predicted</code></td>
<td>
<p>The predicted non-negative vector, where each element in the vector
is a prediction for the corresponding element in <code>actual</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rmsle</code> adds one to both <code>actual</code> and <code>predicted</code> before taking
the natural logarithm to avoid taking the natural log of zero. As a result,
the function can be used if <code>actual</code> or <code>predicted</code> have zero-valued
elements. But this function is not appropriate if either are negative valued.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msle">msle</a></code> <code><a href="#topic+sle">sle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c(1.1, 1.9, 3.0, 4.4, 5.0, 5.6)
predicted &lt;- c(0.9, 1.8, 2.5, 4.5, 5.0, 6.2)
rmsle(actual, predicted)
</code></pre>

<hr>
<h2 id='rrse'>Root Relative Squared Error</h2><span id='topic+rrse'></span>

<h3>Description</h3>

<p><code>rrse</code> computes the root relative squared error between two numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrse(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rrse_+3A_actual">actual</code></td>
<td>
<p>The ground truth numeric vector.</p>
</td></tr>
<tr><td><code id="rrse_+3A_predicted">predicted</code></td>
<td>
<p>The predicted numeric vector, where each element in the vector
is a prediction for the corresponding element in <code>actual</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rrse</code> takes the square root of <code>sse(actual, predicted)</code> divided by
<code>sse(actual, mean(actual))</code>, meaning that it provides the squared error of the
predictions relative to a naive model that predicted the mean for every data point.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rse">rse</a></code> <code><a href="#topic+rae">rae</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c(1.1, 1.9, 3.0, 4.4, 5.0, 5.6)
predicted &lt;- c(0.9, 1.8, 2.5, 4.5, 5.0, 6.2)
rrse(actual, predicted)
</code></pre>

<hr>
<h2 id='rse'>Relative Squared Error</h2><span id='topic+rse'></span>

<h3>Description</h3>

<p><code>rse</code> computes the relative squared error between two numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rse(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rse_+3A_actual">actual</code></td>
<td>
<p>The ground truth numeric vector.</p>
</td></tr>
<tr><td><code id="rse_+3A_predicted">predicted</code></td>
<td>
<p>The predicted numeric vector, where each element in the vector
is a prediction for the corresponding element in <code>actual</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rse</code> divides <code>sse(actual, predicted)</code> by <code>sse(actual, mean(actual))</code>,
meaning that it provides the squared error of the predictions relative to a naive model that
predicted the mean for every data point.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rrse">rrse</a></code> <code><a href="#topic+rae">rae</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c(1.1, 1.9, 3.0, 4.4, 5.0, 5.6)
predicted &lt;- c(0.9, 1.8, 2.5, 4.5, 5.0, 6.2)
rse(actual, predicted)
</code></pre>

<hr>
<h2 id='ScoreQuadraticWeightedKappa'>Quadratic Weighted Kappa</h2><span id='topic+ScoreQuadraticWeightedKappa'></span>

<h3>Description</h3>

<p><code>ScoreQuadraticWeightedKappa</code> computes the quadratic weighted kappa between
two vectors of integers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ScoreQuadraticWeightedKappa(rater.a, rater.b, min.rating = min(c(rater.a,
  rater.b)), max.rating = max(c(rater.a, rater.b)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ScoreQuadraticWeightedKappa_+3A_rater.a">rater.a</code></td>
<td>
<p>An integer vector of the first rater's ratings.</p>
</td></tr>
<tr><td><code id="ScoreQuadraticWeightedKappa_+3A_rater.b">rater.b</code></td>
<td>
<p>An integer vector of the second rater's ratings.</p>
</td></tr>
<tr><td><code id="ScoreQuadraticWeightedKappa_+3A_min.rating">min.rating</code></td>
<td>
<p>The minimum possible rating.</p>
</td></tr>
<tr><td><code id="ScoreQuadraticWeightedKappa_+3A_max.rating">max.rating</code></td>
<td>
<p>The maximum possible rating.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+MeanQuadraticWeightedKappa">MeanQuadraticWeightedKappa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rater.a &lt;- c(1, 4, 5, 5, 2, 1)
rater.b &lt;- c(2, 2, 4, 5, 3, 3)
ScoreQuadraticWeightedKappa(rater.a, rater.b, 1, 5)
</code></pre>

<hr>
<h2 id='se'>Squared Error</h2><span id='topic+se'></span>

<h3>Description</h3>

<p><code>se</code> computes the elementwise squared difference between two numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>se(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="se_+3A_actual">actual</code></td>
<td>
<p>The ground truth numeric vector.</p>
</td></tr>
<tr><td><code id="se_+3A_predicted">predicted</code></td>
<td>
<p>The predicted numeric vector, where each element in the vector
is a prediction for the corresponding element in <code>actual</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mse">mse</a></code> <code><a href="#topic+rmse">rmse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c(1.1, 1.9, 3.0, 4.4, 5.0, 5.6)
predicted &lt;- c(0.9, 1.8, 2.5, 4.5, 5.0, 6.2)
se(actual, predicted)
</code></pre>

<hr>
<h2 id='sle'>Squared Log Error</h2><span id='topic+sle'></span>

<h3>Description</h3>

<p><code>sle</code> computes the elementwise squares of the differences in the logs of two numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sle(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sle_+3A_actual">actual</code></td>
<td>
<p>The ground truth non-negative vector</p>
</td></tr>
<tr><td><code id="sle_+3A_predicted">predicted</code></td>
<td>
<p>The predicted non-negative vector, where each element in the vector
is a prediction for the corresponding element in <code>actual</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sle</code> adds one to both <code>actual</code> and <code>predicted</code> before taking
the natural logarithm of each to avoid taking the natural log of zero. As a result,
the function can be used if <code>actual</code> or <code>predicted</code> have zero-valued
elements. But this function is not appropriate if either are negative valued.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msle">msle</a></code> <code><a href="#topic+rmsle">rmsle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c(1.1, 1.9, 3.0, 4.4, 5.0, 5.6)
predicted &lt;- c(0.9, 1.8, 2.5, 4.5, 5.0, 6.2)
sle(actual, predicted)
</code></pre>

<hr>
<h2 id='smape'>Symmetric Mean Absolute Percentage Error</h2><span id='topic+smape'></span>

<h3>Description</h3>

<p><code>smape</code> computes the symmetric mean absolute percentage error between
two numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smape(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smape_+3A_actual">actual</code></td>
<td>
<p>The ground truth numeric vector.</p>
</td></tr>
<tr><td><code id="smape_+3A_predicted">predicted</code></td>
<td>
<p>The predicted numeric vector, where each element in the vector
is a prediction for the corresponding element in <code>actual</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>smape</code> is defined as two times the average of <code>abs(actual - predicted) / (abs(actual) + abs(predicted))</code>.
Therefore, at the elementwise level, it will provide <code>NaN</code> only if <code>actual</code> and <code>predicted</code>
are both zero. It has an upper bound of <code>2</code>, when either <code>actual</code> or
<code>predicted</code> are zero or when <code>actual</code> and <code>predicted</code> are opposite
signs.
</p>
<p><code>smape</code> is symmetric in the sense that <code>smape(x, y) = smape(y, x)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mape">mape</a></code> <code><a href="#topic+mase">mase</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c(1.1, 1.9, 3.0, 4.4, 5.0, 5.6)
predicted &lt;- c(0.9, 1.8, 2.5, 4.5, 5.0, 6.2)
smape(actual, predicted)
</code></pre>

<hr>
<h2 id='sse'>Sum of Squared Errors</h2><span id='topic+sse'></span>

<h3>Description</h3>

<p><code>sse</code> computes the sum of the squared differences between two numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sse(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sse_+3A_actual">actual</code></td>
<td>
<p>The ground truth numeric vector.</p>
</td></tr>
<tr><td><code id="sse_+3A_predicted">predicted</code></td>
<td>
<p>The predicted numeric vector, where each element in the vector
is a prediction for the corresponding element in <code>actual</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mse">mse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actual &lt;- c(1.1, 1.9, 3.0, 4.4, 5.0, 5.6)
predicted &lt;- c(0.9, 1.8, 2.5, 4.5, 5.0, 6.2)
sse(actual, predicted)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
