<!DOCTYPE html><html><head><title>Help for package phateR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {phateR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.data.frame.phate'><p>Convert a PHATE object to a data.frame</p></a></li>
<li><a href='#as.matrix.phate'><p>Convert a PHATE object to a matrix</p></a></li>
<li><a href='#check_pyphate_version'><p>Check that the current PHATE version in Python is up to date.</p></a></li>
<li><a href='#cluster_phate'><p>KMeans on the PHATE potential</p>
Clustering on the PHATE operator as introduced in Moon et al.
This is similar to spectral clustering.</a></li>
<li><a href='#ggplot.phate'><p>Convert a PHATE object to a data.frame for ggplot</p></a></li>
<li><a href='#install.phate'><p>Install PHATE Python Package</p></a></li>
<li><a href='#library.size.normalize'><p>Performs L1 normalization on input data such that the sum of expression</p>
values for each cell sums to 1, then returns normalized matrix to the metric
space using median UMI count per cell effectively scaling all cells as if
they were sampled evenly.</a></li>
<li><a href='#phate'><p>Run PHATE on an input data matrix</p></a></li>
<li><a href='#plot.phate'><p>Plot a PHATE object in base R</p></a></li>
<li><a href='#print.phate'><p>Print a PHATE object</p></a></li>
<li><a href='#summary.phate'><p>Summarize a PHATE object</p></a></li>
<li><a href='#tree.data'><p>Fake branching data for examples</p></a></li>
<li><a href='#tree.data.small'><p>Fake branching data for running examples fast</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>PHATE - Potential of Heat-Diffusion for Affinity-Based
Transition Embedding</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.7</td>
</tr>
<tr>
<td>Description:</td>
<td>PHATE is a tool for visualizing high dimensional single-cell data
  with natural progressions or trajectories. PHATE uses a novel conceptual framework
  for learning and visualizing the manifold inherent to biological systems in which
  smooth transitions mark the progressions of cells from one state to another.
  To see how PHATE can be applied to single-cell RNA-seq datasets from hematopoietic
  stem cells, human embryonic stem cells, and bone marrow samples, check out our publication in Nature Biotechnology
  at &lt;<a href="https://doi.org/10.1038%2Fs41587-019-0336-3">doi:10.1038/s41587-019-0336-3</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3), Matrix (&ge; 1.2-0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, graphics, reticulate (&ge; 1.8), ggplot2,
memoise</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gridGraphics, cowplot</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-11 18:04:00 UTC; runner</td>
</tr>
<tr>
<td>Author:</td>
<td>Krishnan Srinivasan [aut],
  Scott Gigante <a href="https://orcid.org/0000-0002-4544-2764"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Scott Gigante &lt;scott.gigante@yale.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-12 10:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.data.frame.phate'>Convert a PHATE object to a data.frame</h2><span id='topic+as.data.frame.phate'></span>

<h3>Description</h3>

<p>Returns the embedding matrix with column names PHATE1 and PHATE2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phate'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.phate_+3A_x">x</code></td>
<td>
<p>A fitted PHATE object</p>
</td></tr>
<tr><td><code id="as.data.frame.phate_+3A_...">...</code></td>
<td>
<p>Arguments for as.data.frame()</p>
</td></tr>
</table>

<hr>
<h2 id='as.matrix.phate'>Convert a PHATE object to a matrix</h2><span id='topic+as.matrix.phate'></span>

<h3>Description</h3>

<p>Returns the embedding matrix. All components can be accessed
using phate$embedding, phate$diff.op, etc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phate'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.phate_+3A_x">x</code></td>
<td>
<p>A fitted PHATE object</p>
</td></tr>
<tr><td><code id="as.matrix.phate_+3A_...">...</code></td>
<td>
<p>Arguments for as.matrix()</p>
</td></tr>
</table>

<hr>
<h2 id='check_pyphate_version'>Check that the current PHATE version in Python is up to date.</h2><span id='topic+check_pyphate_version'></span>

<h3>Description</h3>

<p>Check that the current PHATE version in Python is up to date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_pyphate_version()
</code></pre>

<hr>
<h2 id='cluster_phate'>KMeans on the PHATE potential
Clustering on the PHATE operator as introduced in Moon et al.
This is similar to spectral clustering.</h2><span id='topic+cluster_phate'></span>

<h3>Description</h3>

<p>KMeans on the PHATE potential
Clustering on the PHATE operator as introduced in Moon et al.
This is similar to spectral clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_phate(phate, k = 8, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_phate_+3A_phate">phate</code></td>
<td>
<p><code>phate()</code> output</p>
</td></tr>
<tr><td><code id="cluster_phate_+3A_k">k</code></td>
<td>
<p>Number of clusters (default: 8)</p>
</td></tr>
<tr><td><code id="cluster_phate_+3A_seed">seed</code></td>
<td>
<p>Random seed for kmeans (default: NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>clusters Integer vector of cluster assignments
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (reticulate::py_module_available("phate")) {

# Load data
# data(tree.data)
# We use a smaller tree to make examples run faster
data(tree.data.small)

# Run PHATE
phate.tree &lt;- phate(tree.data.small$data)

# Clustering
cluster_phate(phate.tree)
}
</code></pre>

<hr>
<h2 id='ggplot.phate'>Convert a PHATE object to a data.frame for ggplot</h2><span id='topic+ggplot.phate'></span>

<h3>Description</h3>

<p>Passes the embedding matrix to ggplot with column names PHATE1 and PHATE2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phate'
ggplot(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot.phate_+3A_data">data</code></td>
<td>
<p>A fitted PHATE object</p>
</td></tr>
<tr><td><code id="ggplot.phate_+3A_...">...</code></td>
<td>
<p>Arguments for ggplot()</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (reticulate::py_module_available("phate") &amp;&amp; require(ggplot2)) {

# data(tree.data)
# We use a smaller tree to make examples run faster
data(tree.data.small)
phate.tree &lt;- phate(tree.data.small$data)
ggplot(phate.tree, aes(x=PHATE1, y=PHATE2, color=tree.data.small$branches)) +
  geom_point()

}
</code></pre>

<hr>
<h2 id='install.phate'>Install PHATE Python Package</h2><span id='topic+install.phate'></span>

<h3>Description</h3>

<p>Install PHATE Python package into a virtualenv or conda env.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install.phate(
  envname = "r-reticulate",
  method = "auto",
  conda = "auto",
  pip = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="install.phate_+3A_envname">envname</code></td>
<td>
<p>Name of environment to install packages into</p>
</td></tr>
<tr><td><code id="install.phate_+3A_method">method</code></td>
<td>
<p>Installation method. By default, &quot;auto&quot; automatically finds
a method that will work in the local environment. Change the default to
force a specific installation method. Note that the &quot;virtualenv&quot; method
is not available on Windows.</p>
</td></tr>
<tr><td><code id="install.phate_+3A_conda">conda</code></td>
<td>
<p>Path to conda executable (or &quot;auto&quot; to find conda using the PATH
and other conventional install locations).</p>
</td></tr>
<tr><td><code id="install.phate_+3A_pip">pip</code></td>
<td>
<p>Install from pip, if possible.</p>
</td></tr>
<tr><td><code id="install.phate_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to conda_install() or
virtualenv_install().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>On Linux and OS X the &quot;virtualenv&quot; method will be used by default
(&quot;conda&quot; will be used if virtualenv isn't available). On Windows,
the &quot;conda&quot; method is always used.
</p>

<hr>
<h2 id='library.size.normalize'>Performs L1 normalization on input data such that the sum of expression
values for each cell sums to 1, then returns normalized matrix to the metric
space using median UMI count per cell effectively scaling all cells as if
they were sampled evenly.</h2><span id='topic+library.size.normalize'></span>

<h3>Description</h3>

<p>Performs L1 normalization on input data such that the sum of expression
values for each cell sums to 1, then returns normalized matrix to the metric
space using median UMI count per cell effectively scaling all cells as if
they were sampled evenly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>library.size.normalize(data, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="library.size.normalize_+3A_data">data</code></td>
<td>
<p>matrix (n_samples, n_dimensions)
2 dimensional input data array with n cells and p dimensions</p>
</td></tr>
<tr><td><code id="library.size.normalize_+3A_verbose">verbose</code></td>
<td>
<p>boolean, default=FALSE. If true, print verbose output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data_norm matrix (n_samples, n_dimensions)
2 dimensional array with normalized gene expression values
</p>

<hr>
<h2 id='phate'>Run PHATE on an input data matrix</h2><span id='topic+phate'></span>

<h3>Description</h3>

<p>PHATE is a data reduction method specifically designed for visualizing
<strong>high</strong> dimensional data in <strong>low</strong> dimensional spaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phate(
  data,
  ndim = 2,
  knn = 5,
  decay = 40,
  n.landmark = 2000,
  gamma = 1,
  t = "auto",
  mds.solver = "sgd",
  knn.dist.method = "euclidean",
  knn.max = NULL,
  init = NULL,
  mds.method = "metric",
  mds.dist.method = "euclidean",
  t.max = 100,
  npca = 100,
  plot.optimal.t = FALSE,
  verbose = 1,
  n.jobs = 1,
  seed = NULL,
  potential.method = NULL,
  k = NULL,
  alpha = NULL,
  use.alpha = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phate_+3A_data">data</code></td>
<td>
<p>matrix (n_samples, n_dimensions)
2 dimensional input data array with
n_samples samples and n_dimensions dimensions.
If <code>knn.dist.method</code> is 'precomputed', <code>data</code> is treated as a
(n_samples, n_samples) distance or affinity matrix</p>
</td></tr>
<tr><td><code id="phate_+3A_ndim">ndim</code></td>
<td>
<p>int, optional, default: 2
number of dimensions in which the data will be embedded</p>
</td></tr>
<tr><td><code id="phate_+3A_knn">knn</code></td>
<td>
<p>int, optional, default: 5
number of nearest neighbors on which to build kernel</p>
</td></tr>
<tr><td><code id="phate_+3A_decay">decay</code></td>
<td>
<p>int, optional, default: 40
sets decay rate of kernel tails.
If NULL, alpha decaying kernel is not used</p>
</td></tr>
<tr><td><code id="phate_+3A_n.landmark">n.landmark</code></td>
<td>
<p>int, optional, default: 2000
number of landmarks to use in fast PHATE</p>
</td></tr>
<tr><td><code id="phate_+3A_gamma">gamma</code></td>
<td>
<p>float, optional, default: 1
Informational distance constant between -1 and 1.
<code>gamma=1</code> gives the PHATE log potential, <code>gamma=0</code> gives
a square root potential.</p>
</td></tr>
<tr><td><code id="phate_+3A_t">t</code></td>
<td>
<p>int, optional, default: 'auto'
power to which the diffusion operator is powered
sets the level of diffusion</p>
</td></tr>
<tr><td><code id="phate_+3A_mds.solver">mds.solver</code></td>
<td>
<p>'sgd', 'smacof', optional, default: 'sgd'
which solver to use for metric MDS. SGD is substantially faster,
but produces slightly less optimal results. Note that SMACOF was used
for all figures in the PHATE paper.</p>
</td></tr>
<tr><td><code id="phate_+3A_knn.dist.method">knn.dist.method</code></td>
<td>
<p>string, optional, default: 'euclidean'.
recommended values: 'euclidean', 'cosine', 'precomputed'
Any metric from <code>scipy.spatial.distance</code> can be used
distance metric for building kNN graph. If 'precomputed',
<code>data</code> should be an n_samples x n_samples distance or
affinity matrix. Distance matrices are assumed to have zeros
down the diagonal, while affinity matrices are assumed to have
non-zero values down the diagonal. This is detected automatically using
<code>data[0,0]</code>. You can override this detection with
<code>knn.dist.method='precomputed_distance'</code> or
<code>knn.dist.method='precomputed_affinity'</code>.</p>
</td></tr>
<tr><td><code id="phate_+3A_knn.max">knn.max</code></td>
<td>
<p>int, optional, default: NULL
Maximum number of neighbors for which alpha decaying kernel
is computed for each point. For very large datasets, setting <code>knn.max</code>
to a small multiple of <code>knn</code> can speed up computation significantly.</p>
</td></tr>
<tr><td><code id="phate_+3A_init">init</code></td>
<td>
<p>phate object, optional
object to use for initialization. Avoids recomputing
intermediate steps if parameters are the same.</p>
</td></tr>
<tr><td><code id="phate_+3A_mds.method">mds.method</code></td>
<td>
<p>string, optional, default: 'metric'
choose from 'classic', 'metric', and 'nonmetric'
which MDS algorithm is used for dimensionality reduction</p>
</td></tr>
<tr><td><code id="phate_+3A_mds.dist.method">mds.dist.method</code></td>
<td>
<p>string, optional, default: 'euclidean'
recommended values: 'euclidean' and 'cosine'</p>
</td></tr>
<tr><td><code id="phate_+3A_t.max">t.max</code></td>
<td>
<p>int, optional, default: 100.
Maximum value of t to test for automatic t selection.</p>
</td></tr>
<tr><td><code id="phate_+3A_npca">npca</code></td>
<td>
<p>int, optional, default: 100
Number of principal components to use for calculating
neighborhoods. For extremely large datasets, using
n_pca &lt; 20 allows neighborhoods to be calculated in
log(n_samples) time.</p>
</td></tr>
<tr><td><code id="phate_+3A_plot.optimal.t">plot.optimal.t</code></td>
<td>
<p>boolean, optional, default: FALSE
If TRUE, produce a plot showing the Von Neumann Entropy
curve for automatic t selection.</p>
</td></tr>
<tr><td><code id="phate_+3A_verbose">verbose</code></td>
<td>
<p><code>int</code> or <code>boolean</code>, optional (default : 1)
If <code>TRUE</code> or <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code>, print verbose updates.</p>
</td></tr>
<tr><td><code id="phate_+3A_n.jobs">n.jobs</code></td>
<td>
<p><code>int</code>, optional (default: 1)
The number of jobs to use for the computation.
If -1 all CPUs are used. If 1 is given, no parallel computing code is
used at all, which is useful for debugging.
For n_jobs below -1, (n.cpus + 1 + n.jobs) are used. Thus for
n_jobs = -2, all CPUs but one are used</p>
</td></tr>
<tr><td><code id="phate_+3A_seed">seed</code></td>
<td>
<p>int or <code>NULL</code>, random state (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="phate_+3A_potential.method">potential.method</code></td>
<td>
<p>Deprecated.
For log potential, use <code>gamma=1</code>. For sqrt potential, use <code>gamma=0</code>.</p>
</td></tr>
<tr><td><code id="phate_+3A_k">k</code></td>
<td>
<p>Deprecated. Use <code>knn</code>.</p>
</td></tr>
<tr><td><code id="phate_+3A_alpha">alpha</code></td>
<td>
<p>Deprecated. Use <code>decay</code>.</p>
</td></tr>
<tr><td><code id="phate_+3A_use.alpha">use.alpha</code></td>
<td>
<p>Deprecated
To disable alpha decay, use <code>alpha=NULL</code></p>
</td></tr>
<tr><td><code id="phate_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>graphtools.Graph</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>&quot;phate&quot; object containing:
</p>

<ul>
<li> <p><strong>embedding</strong>: the PHATE embedding
</p>
</li>
<li> <p><strong>operator</strong>: The PHATE operator (python phate.PHATE object)
</p>
</li>
<li> <p><strong>params</strong>: Parameters passed to phate
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>if (reticulate::py_module_available("phate")) {

# Load data
# data(tree.data)
# We use a smaller tree to make examples run faster
data(tree.data.small)

# Run PHATE
phate.tree &lt;- phate(tree.data.small$data)
summary(phate.tree)
## PHATE embedding
## knn = 5, decay = 40, t = 58
## Data: (3000, 100)
## Embedding: (3000, 2)

library(graphics)
# Plot the result with base graphics
plot(phate.tree, col=tree.data.small$branches)
# Plot the result with ggplot2
if (require(ggplot2)) {
  ggplot(phate.tree) +
    geom_point(aes(x=PHATE1, y=PHATE2, color=tree.data.small$branches))
}

# Run PHATE again with different parameters
# We use the last run as initialization
phate.tree2 &lt;- phate(tree.data.small$data, t=150, init=phate.tree)
# Extract the embedding matrix to use in downstream analysis
embedding &lt;- as.matrix(phate.tree2)

}
</code></pre>

<hr>
<h2 id='plot.phate'>Plot a PHATE object in base R</h2><span id='topic+plot.phate'></span>

<h3>Description</h3>

<p>Plot a PHATE object in base R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phate'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.phate_+3A_x">x</code></td>
<td>
<p>A fitted PHATE object</p>
</td></tr>
<tr><td><code id="plot.phate_+3A_...">...</code></td>
<td>
<p>Arguments for plot()</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (reticulate::py_module_available("phate")) {

library(graphics)
# data(tree.data)
# We use a smaller tree to make examples run faster
data(tree.data.small)
phate.tree &lt;- phate(tree.data.small$data)
plot(phate.tree, col=tree.data.small$branches)

}
</code></pre>

<hr>
<h2 id='print.phate'>Print a PHATE object</h2><span id='topic+print.phate'></span>

<h3>Description</h3>

<p>This avoids spamming the user's console with a list of many large matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phate'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.phate_+3A_x">x</code></td>
<td>
<p>A fitted PHATE object</p>
</td></tr>
<tr><td><code id="print.phate_+3A_...">...</code></td>
<td>
<p>Arguments for print()</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (reticulate::py_module_available("phate")) {

# data(tree.data)
# We use a smaller tree to make examples run faster
data(tree.data.small)
phate.tree &lt;- phate(tree.data.small$data)
print(phate.tree)
## PHATE embedding with elements
## $embedding : (3000, 2)
## $operator : Python PHATE operator
## $params : list with elements (data, knn, decay, t, n.landmark, ndim,
##                               gamma, npca, mds.method,
##                               knn.dist.method, mds.dist.method)

}
</code></pre>

<hr>
<h2 id='summary.phate'>Summarize a PHATE object</h2><span id='topic+summary.phate'></span>

<h3>Description</h3>

<p>Summarize a PHATE object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phate'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.phate_+3A_object">object</code></td>
<td>
<p>A fitted PHATE object</p>
</td></tr>
<tr><td><code id="summary.phate_+3A_...">...</code></td>
<td>
<p>Arguments for summary()</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (reticulate::py_module_available("phate")) {

# data(tree.data)
# We use a smaller tree to make examples run faster
data(tree.data.small)
phate.tree &lt;- phate(tree.data.small$data)
summary(phate.tree)
## PHATE embedding
## knn = 5, decay = 40, t = 58
## Data: (3000, 100)
## Embedding: (3000, 2)

}
</code></pre>

<hr>
<h2 id='tree.data'>Fake branching data for examples</h2><span id='topic+tree.data'></span>

<h3>Description</h3>

<p>A dataset containing high dimensional data that has 10 unique branches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree.data
</code></pre>


<h3>Format</h3>

<p>A list containing <code>data</code>, a matrix with 3000 rows and 100 variables
and <code>branches</code>, a factor containing 3000 elements.
</p>


<h3>Source</h3>

<p>The authors
</p>

<hr>
<h2 id='tree.data.small'>Fake branching data for running examples fast</h2><span id='topic+tree.data.small'></span>

<h3>Description</h3>

<p>A dataset containing high dimensional data that has 10 unique branches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree.data.small
</code></pre>


<h3>Format</h3>

<p>A list containing <code>data</code>, a matrix with 250 rows and 50 variables
and <code>branches</code>, a factor containing 250 elements.
</p>


<h3>Source</h3>

<p>The authors
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
