<!DOCTYPE html><html><head><title>Help for package adlift</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {adlift}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AdaptNeigh'><p>AdaptNeigh</p></a></li>
<li><a href='#AdaptNeighmp'><p>AdaptNeighmp</p></a></li>
<li><a href='#AdaptPred'><p>AdaptPred</p></a></li>
<li><a href='#AdaptPredmp'><p>AdaptPredmp</p></a></li>
<li><a href='#adjustx'><p>adjustx</p></a></li>
<li><a href='#Amatdual'><p>Amatdual</p></a></li>
<li><a href='#artlev'><p>artlev</p></a></li>
<li><a href='#as.column'><p>as.column</p></a></li>
<li><a href='#as.row'><p>as.row</p></a></li>
<li><a href='#basisfns'><p>basisfns</p></a></li>
<li><a href='#condno'><p>condno</p></a></li>
<li><a href='#CubicPred'><p>CubicPred</p></a></li>
<li><a href='#CubicPredmp'><p>CubicPredmp</p></a></li>
<li><a href='#denoise'><p>denoise</p></a></li>
<li><a href='#denoisehetero'><p>denoisehetero</p></a></li>
<li><a href='#denoiseheteromp'><p>denoiseheteromp</p></a></li>
<li><a href='#denoiseheteroprop'><p>denoiseheteroprop</p></a></li>
<li><a href='#dojitter'><p>dojitter</p></a></li>
<li><a href='#findadds'><p>Finds minimum number of inversion steps</p></a></li>
<li><a href='#fwtnp'><p>fwtnp</p></a></li>
<li><a href='#fwtnpmp'><p>fwtnpmp</p></a></li>
<li><a href='#getnbrs'><p>getnbrs</p></a></li>
<li><a href='#heterovar'><p>heterovar</p></a></li>
<li><a href='#intervals'><p>intervals</p></a></li>
<li><a href='#invtnp'><p>invtnp</p></a></li>
<li><a href='#invtnpmp'><p>invtnpmp</p></a></li>
<li><a href='#lengthintervals'><p>lengthintervals</p></a></li>
<li><a href='#LinearPred'><p>LinearPred</p></a></li>
<li><a href='#LinearPredmp'><p>LinearPredmp</p></a></li>
<li><a href='#make.signal2'><p>make.signal2</p></a></li>
<li><a href='#matcond'><p>matcond</p></a></li>
<li><a href='#modjitter'><p>modjitter</p></a></li>
<li><a href='#motorcycledata'>
<p>Motorcycle data.</p></a></li>
<li><a href='#PointsUpdate'><p>PointsUpdate</p></a></li>
<li><a href='#PointsUpdatemp'><p>PointsUpdatemp</p></a></li>
<li><a href='#postmean.cauchy'><p>postmean.cauchy</p></a></li>
<li><a href='#QuadPred'><p>QuadPred</p></a></li>
<li><a href='#QuadPredmp'><p>QuadPredmp</p></a></li>
<li><a href='#Rmatsolve'><p>Rmatsolve</p></a></li>
<li><a href='#transmatdual'><p>transmatdual</p></a></li>
<li><a href='#UndoPointsUpdate'><p>UndoPointsUpdate</p></a></li>
<li><a href='#UndoPointsUpdatemp'><p>UndoPointsUpdatemp</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.4-5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-22</td>
</tr>
<tr>
<td>Title:</td>
<td>An Adaptive Lifting Scheme Algorithm</td>
</tr>
<tr>
<td>Author:</td>
<td>Matt Nunes [aut, cre],
  Marina Knight [aut],
  Guy Nason [ctb, ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matt Nunes &lt;nunesrpackages@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Adaptive wavelet lifting transforms for signal denoising using optimal local neighbourhood regression, from Nunes et al. (2006) &lt;<a href="https://doi.org/10.1007%2Fs11222-006-6560-y">doi:10.1007/s11222-006-6560-y</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>EbayesThresh</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-22 15:45:17 UTC; matt</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-22 17:10:05 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
</table>
<hr>
<h2 id='AdaptNeigh'>AdaptNeigh</h2><span id='topic+AdaptNeigh'></span>

<h3>Description</h3>

<p>This function performs the prediction lifting step over neighbourhoods and interpolation schemes. </p>


<h3>Usage</h3>

<pre><code class='language-R'>AdaptNeigh(pointsin, X, coeff, nbrs, remove, intercept, 
neighbours)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AdaptNeigh_+3A_pointsin">pointsin</code></td>
<td>
<p>The indices of gridpoints still to be removed. </p>
</td></tr>
<tr><td><code id="AdaptNeigh_+3A_x">X</code></td>
<td>
<p>the vector of grid values. </p>
</td></tr>
<tr><td><code id="AdaptNeigh_+3A_coeff">coeff</code></td>
<td>
<p>the vector of detail and scaling coefficients at that step of the transform. </p>
</td></tr>
<tr><td><code id="AdaptNeigh_+3A_nbrs">nbrs</code></td>
<td>
<p>the indices (into <span class="env">X</span>) of the neighbours to be used in the prediction step. Note that the value to this input is not important, since the procedure checks the neighbourhoods structure in the minimisation step anyway, but is for standardisation of arguments to the non-adaptive prediction schemes. </p>
</td></tr>
<tr><td><code id="AdaptNeigh_+3A_remove">remove</code></td>
<td>
<p>the index (into <span class="env">X</span>) of the point to be removed. </p>
</td></tr>
<tr><td><code id="AdaptNeigh_+3A_intercept">intercept</code></td>
<td>
<p>Boolean value for whether or not an intercept is used in the prediction step of the transform. (Note that this is actually a dummy argument, since it is not necessary for the computation of the detail coefficient in <code>AdaptNeigh</code>, though is used for standardising its arguments with other prediction schemes for use in the <code>fwtnp</code> function). </p>
</td></tr>
<tr><td><code id="AdaptNeigh_+3A_neighbours">neighbours</code></td>
<td>
<p>the number of neighbours to be considered in the computation of predicted values and detail coefficients. </p>
</td></tr></table>


<h3>Details</h3>

<p>The procedure performs adaptive regression (through <code>AdaptPred</code>) over the three types of regression and also over the 3*<span class="env">neighbours</span> configurations of neighbours. The combination (type of regression, configuration of neighbours) is chosen which gives the smallest detail coefficient (in absolute value). </p>


<h3>Value</h3>

<p><strong>results.</strong> This is a ten item list giving the regression information chosen from the detail coefficient minimisation (i.e, the information supplied to <code>AdaptNeigh</code> by <code>AdaptPred</code>):   
</p>
<table>
<tr><td><code>Xneigh</code></td>
<td>
<p>matrix of <span class="env">X</span> values corresponding to the neighbours of the removed point. The matrix consists of columns <code class="reqn">1,X[nbrs],X[nbrs]^2,...</code> depending on the order of the prediction used and whether or not an intercept is used. Refer to any reference on linear regression for more details. </p>
</td></tr>
<tr><td><code>mm</code></td>
<td>
<p>the matrix from which the prediction is made. In terms of <span class="env">Xneigh</span>, it is <br /> <code class="reqn">(Xneigh^T Xneigh)^{-1} Xneigh^T</code> . </p>
</td></tr>
<tr><td><code>bhat</code></td>
<td>
<p>The regression coefficients used in prediction. </p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the prediction weights for the neighbours. </p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>the predicted function value obtained from the regression. </p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>vector of (modified) detail and scaling coefficients to be used in the update step of the transform. </p>
</td></tr>
<tr><td><code>int</code></td>
<td>
<p>if TRUE, an intercept was used in the regression. </p>
</td></tr>
<tr><td><code>scheme</code></td>
<td>
<p>a character vector denoting the type of regression used in the prediction (&quot;Linear&quot;, &quot;Quad&quot; or &quot;Cubic&quot;). </p>
</td></tr>
<tr><td><code>details</code></td>
<td>
<p>a vector of the detail coefficients from which <code>AdaptPred</code> selects the minimum value. There are six entries. The first three entries represent the detail coefficients from regression with no intercept in increasing order of prediction. The second three details are values for regression with intercept. </p>
</td></tr>
<tr><td><code>minindex</code></td>
<td>
<p>the index into details (<span class="env">results[[9]]</span>) which produces the minimum value.</p>
</td></tr>
</table>
<p><strong>newinfo.</strong> A six item list containing extra information to be used in the main transform procedure (<code>fwtnp</code>) obtained from the minimisation in <code>AdaptNeigh</code>:
</p>
<table>
<tr><td><code>clo</code></td>
<td>
<p>boolean value telling the configuration of the neighbours which produce the overall minimum detail coefficient. </p>
</td></tr>
<tr><td><code>totalminindex</code></td>
<td>
<p>the index into <span class="env">mindetails</span> (below) indicating the overall minimum detail coefficient produced by the procedure. </p>
</td></tr>
<tr><td><code>nbrs</code></td>
<td>
<p>the indices into <span class="env">X</span> of the neighbours used in the best prediction scheme.</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>the indices into <span class="env">pointsin</span> of the neighbours used in the best prediction. </p>
</td></tr>
<tr><td><code>mindetails</code></td>
<td>
<p>a vector of 3*<span class="env">neighbours</span> entries giving the minimum details produced by each call of <code>AdaptPred</code> in <code>AdaptNeigh</code> (for the different number and configuration of neighbours). </p>
</td></tr>
<tr><td><code>minindices</code></td>
<td>
<p>vector of 3*<span class="env">neighbours</span> entries giving the index (out of 6) of the schemes which produce the best predictions by each call of <code>AdaptPred</code> <br /> in <code>AdaptNeigh</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight</p>


<h3>See Also</h3>

<p><code><a href="#topic+AdaptPred">AdaptPred</a></code>, <code><a href="#topic+fwtnp">fwtnp</a></code>     </p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some doppler data: 500 observations.
#
tx &lt;- runif(500)
ty&lt;-make.signal2("doppler",x=tx)
#
# Compute the neighbours of point 173 (2 neighbours on each side)
#
out&lt;-getnbrs(tx,173,order(tx),2,FALSE)

#
# Perform the adaptive lifting step 
#
an&lt;-AdaptNeigh(order(tx),tx,ty,out$nbrs,173,FALSE,2)
#
an[[1]][[7]]

an[[2]][[3]]

#shows best prediction when removing point 173, with the neighbours used

</code></pre>

<hr>
<h2 id='AdaptNeighmp'>AdaptNeighmp</h2><span id='topic+AdaptNeighmp'></span>

<h3>Description</h3>

<p>This function performs the prediction lifting step over neighbourhoods and interpolation schemes, for multiple point data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AdaptNeighmp(pointsin, X, coefflist, coeff, nbrs, newnbrs, 
remove, intercept, neighbours, mpdet, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AdaptNeighmp_+3A_pointsin">pointsin</code></td>
<td>
<p>The indices of gridpoints still to be removed.</p>
</td></tr>
<tr><td><code id="AdaptNeighmp_+3A_x">X</code></td>
<td>
<p>the vector of grid values.</p>
</td></tr>
<tr><td><code id="AdaptNeighmp_+3A_coeff">coeff</code></td>
<td>
<p>the vector of detail and scaling coefficients at that step of the transform.</p>
</td></tr>
<tr><td><code id="AdaptNeighmp_+3A_coefflist">coefflist</code></td>
<td>
<p>the list of detail and multiple scaling coefficients at that step of the transform.</p>
</td></tr>
<tr><td><code id="AdaptNeighmp_+3A_nbrs">nbrs</code></td>
<td>
<p>the indices (into <span class="env">X</span>) of the neighbours to be used in the prediction step.</p>
</td></tr>
<tr><td><code id="AdaptNeighmp_+3A_newnbrs">newnbrs</code></td>
<td>
<p>as nbrs, but repeated according to the multiple point structure of the grid.</p>
</td></tr>
<tr><td><code id="AdaptNeighmp_+3A_remove">remove</code></td>
<td>
<p>the index (into <span class="env">X</span>) of the point to be removed.</p>
</td></tr>
<tr><td><code id="AdaptNeighmp_+3A_intercept">intercept</code></td>
<td>
<p>Boolean value for whether or not an intercept is used in the prediction step of the transform.</p>
</td></tr>
<tr><td><code id="AdaptNeighmp_+3A_neighbours">neighbours</code></td>
<td>
<p>the number of neighbours in the computation of the predicted value. This is not actually used specifically in <code>AdaptNeighmp</code>, since this is known already from <span class="env">nbrs</span>.</p>
</td></tr>
<tr><td><code id="AdaptNeighmp_+3A_mpdet">mpdet</code></td>
<td>
<p>how the mutiple point detail coefficients are computed.  Possible values are &quot;ave&quot;, in which the multiple detail coefficients produced when performing the multiple predictions are averaged, or &quot;min&quot;, where the overall minimum detail coefficient is taken.  </p>
</td></tr>
<tr><td><code id="AdaptNeighmp_+3A_g">g</code></td>
<td>
<p>the group structure of the multiple point data.  </p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The procedure performs adaptive regression (through <code>AdaptPred</code>) over the three types of regression and also over the 3*<span class="env">neighbours</span> configurations of neighbours. The combination (type of regression, configuration of neighbours) is chosen which gives the smallest detail coefficient (in absolute value). 
</p>


<h3>Value</h3>

<p><strong>results.</strong>  This is a ten item list giving the regression information chosen from the detail coefficient minimisation (i.e, the information supplied to <code>AdaptNeigh</code> by <code>AdaptPred</code>): 
</p>
<table>
<tr><td><code>Xneigh</code></td>
<td>
<p>matrix of <span class="env">X</span> values corresponding to the neighbours of the removed point. The matrix consists of columns <code class="reqn">1,X[nbrs],X[nbrs]^2,...</code> depending on the order of the prediction used and whether or not an intercept is used. Refer to any reference on linear regression for more details. </p>
</td></tr>
<tr><td><code>mm</code></td>
<td>
<p>the matrix from which the prediction is made. In terms of <span class="env">Xneigh</span>, it is <br /> <code class="reqn">({Xneigh}^T Xneigh)^{-1} {Xneigh}^T</code> . </p>
</td></tr>
<tr><td><code>bhat</code></td>
<td>
<p>The regression coefficients used in prediction. </p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the prediction weights for the neighbours. </p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>the predicted function value obtained from the regression. </p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>vector of (modified) detail and scaling coefficients to be used in the update step of the transform. </p>
</td></tr>
<tr><td><code>int</code></td>
<td>
<p>if TRUE, an intercept was used in the regression. </p>
</td></tr>
<tr><td><code>scheme</code></td>
<td>
<p>a character vector denoting the type of regression used in the prediction (&quot;Linear&quot;, &quot;Quad&quot; or &quot;Cubic&quot;). </p>
</td></tr>
<tr><td><code>details</code></td>
<td>
<p>a vector of the detail coefficients from which <code>AdaptPred</code> selects the minimum value. There are six entries. The first three entries represent the detail coefficients from regression with no intercept in increasing order of prediction. The second three details are values for regression with intercept. </p>
</td></tr>
<tr><td><code>minindex</code></td>
<td>
<p>the index into details (<span class="env">results[[9]]</span>) which produces the minimum value.</p>
</td></tr>
</table>
<p><strong>newinfo.</strong> A six item list containing extra information to be used in the main transform procedure (<code>fwtnp</code>) obtained from the minimisation in <code>AdaptNeigh</code>: 
</p>
<table>
<tr><td><code>clo</code></td>
<td>
<p>boolean value telling the configuration of the neighbours which produce the overall minimum detail coefficient. </p>
</td></tr>
<tr><td><code>totalminindex</code></td>
<td>
<p>the index into <span class="env">mindetails</span> (below) indicating the overall minimum detail coefficient produced by the procedure. </p>
</td></tr>
<tr><td><code>nbrs</code></td>
<td>
<p>the indices into <span class="env">X</span> of the neighbours used in the best prediction scheme.</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>the indices into <span class="env">pointsin</span> of the neighbours used in the best prediction. </p>
</td></tr>
<tr><td><code>mindetails</code></td>
<td>
<p>a vector of 3*<span class="env">neighbours</span> entries giving the minimum details produced by each call of <code>AdaptPred</code> in <code>AdaptNeigh</code> (for the different number and configuration of neighbours). </p>
</td></tr>
<tr><td><code>minindices</code></td>
<td>
<p>vector of 3*<span class="env">neighbours</span> entries giving the index (out of 6) of the schemes which produce the best predictions by each call of <br /> <code>AdaptPred</code> in <code>AdaptNeigh</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight </p>


<h3>See Also</h3>

<p><code><a href="#topic+AdaptPredmp">AdaptPredmp</a></code>, <code><a href="#topic+fwtnpmp">fwtnpmp</a></code>     </p>


<h3>Examples</h3>

<pre><code class='language-R'>#read in data with multiple values...

data(motorcycledata)
times&lt;-motorcycledata$time
accel&lt;-motorcycledata$accel
short&lt;-adjustx(times,accel,"mean")
X&lt;-short$sepx
coeff&lt;-short$sepx
g&lt;-short$g

coefflist&lt;-list()
for (i in 1:length(g)){
coefflist[[i]]&lt;-accel[g[[i]]]
}

#work out neighbours of point to be removed (31)

out&lt;-getnbrs(X,31,order(X),2,TRUE)
nbrs&lt;-out$n

nbrs

newnbrs&lt;-NULL
for (i in 1:length(nbrs)){
newnbrs&lt;-c(newnbrs,rep(nbrs[i],times=length(g[[nbrs[i]]])))
}

#work out repeated neighbours using g...
newnbrs

AdaptNeighmp(order(X),X,coefflist,coeff,nbrs,newnbrs,31,TRUE,2,"ave",g)

</code></pre>

<hr>
<h2 id='AdaptPred'>AdaptPred</h2><span id='topic+AdaptPred'></span>

<h3>Description</h3>

<p>This function performs the prediction lifting step over intercept and regression order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AdaptPred(pointsin, X, coeff, nbrs, remove, intercept, 
neighbours)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AdaptPred_+3A_pointsin">pointsin</code></td>
<td>
<p>The indices of gridpoints still to be removed.</p>
</td></tr>
<tr><td><code id="AdaptPred_+3A_x">X</code></td>
<td>
<p>the vector of grid values</p>
</td></tr>
<tr><td><code id="AdaptPred_+3A_coeff">coeff</code></td>
<td>
<p>the vector of detail and scaling coefficients at that step of the transform.</p>
</td></tr>
<tr><td><code id="AdaptPred_+3A_nbrs">nbrs</code></td>
<td>
<p>the indices (into <span class="env">X</span>) of the neighbours to be used in the prediction step. Note that the value to this input is not important, since the procedure checks the neighbourhoods structure in the minimisation step anyway, but is for standardisation of arguments to the non-adaptive prediction schemes. </p>
</td></tr>
<tr><td><code id="AdaptPred_+3A_remove">remove</code></td>
<td>
<p>the index (into <span class="env">X</span>) of the point to be removed.</p>
</td></tr>
<tr><td><code id="AdaptPred_+3A_intercept">intercept</code></td>
<td>
<p>Boolean value for whether or not an intercept is used in the prediction step of the transform. (Note that this is actually a dummy argument, since it is not necessary for the computation of the detail coefficient in <code>AdaptPred</code>(the intercept is part of the adaptiveness), though is used for standardising its arguments with other prediction schemes for use in the <code>fwtnp</code> function).</p>
</td></tr>
<tr><td><code id="AdaptPred_+3A_neighbours">neighbours</code></td>
<td>
<p>the number of neighbours to be considered in the computation of predicted values and detail coefficients.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure performs adaptive regression (through AdaptPred) over the three types of regression and also over intercept.  The combination (type of regression, intercept) is chosen which gives the smallest detail coefficient (in absolute value).   
</p>


<h3>Value</h3>

<p><strong>results.</strong> This is a ten item list giving the regression information chosen from the detail coefficient minimisation:
</p>
<table>
<tr><td><code>Xneigh</code></td>
<td>
<p>matrix of <span class="env">X</span> values corresponding to the neighbours of the removed point. The matrix consists of columns <code class="reqn">1,X[nbrs],X[nbrs]^2,...</code> depending on the order of the prediction used and whether or not an intercept is used. Refer to any reference on linear regression for more details. </p>
</td></tr>
<tr><td><code>mm</code></td>
<td>
<p>the matrix from which the prediction is made. In terms of <span class="env">Xneigh</span>, it is <br /> <code class="reqn">(Xneigh^T Xneigh)^{-1} Xneigh^T</code> . </p>
</td></tr>
<tr><td><code>bhat</code></td>
<td>
<p>The regression coefficients used in prediction. </p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the prediction weights for the neighbours. </p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>the predicted function value obtained from the regression. </p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>vector of (modified) detail and scaling coefficients to be used in the update step of the transform. </p>
</td></tr>
<tr><td><code>int</code></td>
<td>
<p>if TRUE, an intercept was used in the regression. </p>
</td></tr>
<tr><td><code>scheme</code></td>
<td>
<p>a character vector denoting the type of regression used in the prediction (&quot;Linear&quot;, &quot;Quad&quot; or &quot;Cubic&quot;). </p>
</td></tr>
<tr><td><code>details</code></td>
<td>
<p>a vector of the detail coefficients from which <code>AdaptPred</code> selects the minimum value. There are six entries. The first three entries represent the detail coefficients from regression with no intercept in increasing order of prediction. The second three details are values for regression with intercept. </p>
</td></tr>
<tr><td><code>minindex</code></td>
<td>
<p>the index into details (<span class="env">results[[9]]</span>) which produces the minimum value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight</p>


<h3>See Also</h3>

<p><code><a href="#topic+AdaptNeigh">AdaptNeigh</a></code>, <code><a href="#topic+CubicPred">CubicPred</a></code>, <code><a href="#topic+fwtnp">fwtnp</a></code>, <code><a href="#topic+LinearPred">LinearPred</a></code>, <code><a href="#topic+QuadPred">QuadPred</a></code>    </p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# Generate some doppler data: 500 observations.
#
tx &lt;- runif(500)
ty&lt;-make.signal2("doppler",x=tx)
#
# Compute the neighbours of point 173 (2 neighbours on each side)
#
out&lt;-getnbrs(tx,173,order(tx),2,FALSE)

#
# Perform the adaptive lifting step 
#
ap&lt;-AdaptPred(order(tx),tx,ty,out$nbrs,173,FALSE,2)
#
#the detail coefficient:
ap[[3]]

#and let's check the scheme used:
ap[[4]]

ap[[5]]



</code></pre>

<hr>
<h2 id='AdaptPredmp'>AdaptPredmp</h2><span id='topic+AdaptPredmp'></span>

<h3>Description</h3>

<p>This function performs the prediction lifting step over intercept and regression order, for multiple point data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AdaptPredmp(pointsin, X, coefflist, coeff, nbrs, newnbrs, remove, 
intercept, neighbours, mpdet, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AdaptPredmp_+3A_pointsin">pointsin</code></td>
<td>
<p>The indices of gridpoints still to be removed.</p>
</td></tr>
<tr><td><code id="AdaptPredmp_+3A_x">X</code></td>
<td>
<p>the vector of grid values.</p>
</td></tr>
<tr><td><code id="AdaptPredmp_+3A_coeff">coeff</code></td>
<td>
<p>the vector of detail and scaling coefficients at that step of the transform.</p>
</td></tr>
<tr><td><code id="AdaptPredmp_+3A_coefflist">coefflist</code></td>
<td>
<p>the list of detail and multiple scaling coefficients at that step of the transform.</p>
</td></tr>
<tr><td><code id="AdaptPredmp_+3A_nbrs">nbrs</code></td>
<td>
<p>the indices (into <span class="env">X</span>) of the neighbours to be used in the prediction step.</p>
</td></tr>
<tr><td><code id="AdaptPredmp_+3A_newnbrs">newnbrs</code></td>
<td>
<p>as nbrs, but repeated according to the multiple point structure of the grid.</p>
</td></tr>
<tr><td><code id="AdaptPredmp_+3A_remove">remove</code></td>
<td>
<p>the index (into <span class="env">X</span>) of the point to be removed.</p>
</td></tr>
<tr><td><code id="AdaptPredmp_+3A_intercept">intercept</code></td>
<td>
<p>Boolean value for whether or not an intercept is used in the prediction step of the transform.</p>
</td></tr>
<tr><td><code id="AdaptPredmp_+3A_neighbours">neighbours</code></td>
<td>
<p>the number of neighbours in the computation of the predicted value. This is not actually used specifically in <code>AdaptPredmp</code>, since this is known already from <span class="env">nbrs</span>.</p>
</td></tr>
<tr><td><code id="AdaptPredmp_+3A_mpdet">mpdet</code></td>
<td>
<p>how the mutiple point detail coefficients are computed.  Possible values are &quot;ave&quot;, in which the multiple detail coefficients produced when performing the multiple predictions are averaged, or &quot;min&quot;, where the overall minimum detail coefficient is taken.  </p>
</td></tr>
<tr><td><code id="AdaptPredmp_+3A_g">g</code></td>
<td>
<p>the group structure of the multiple point data.  </p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The procedure performs adaptive regression (through AdaptPred) over the three types of regression and also over intercept.  The combination (type of regression, intercept) is chosen which gives the smallest detail coefficient (in absolute value).
</p>


<h3>Value</h3>

<p><strong>results.</strong>This is a ten item list giving the regression information chosen from the detail coefficient minimisation:
</p>
<table>
<tr><td><code>Xneigh</code></td>
<td>
<p>matrix of <span class="env">X</span> values corresponding to the neighbours of the removed point. The matrix consists of columns <code class="reqn">1,X[newnbrs],X[newnbrs]^2,...</code> depending on the order of the prediction used and whether or not an intercept is used. Refer to any reference on linear regression for more details. </p>
</td></tr>
<tr><td><code>mm</code></td>
<td>
<p>the matrix from which the prediction is made. In terms of <span class="env">Xneigh</span>, it is <br /> <code class="reqn">(Xneigh^T Xneigh)^{-1} Xneigh^T</code> . </p>
</td></tr>
<tr><td><code>bhat</code></td>
<td>
<p>The regression coefficients used in prediction. </p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the prediction weights for the neighbours. </p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>the predicted function value obtained from the regression. </p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>vector of (modified) detail and scaling coefficients to be used in the update step of the transform. </p>
</td></tr>
<tr><td><code>int</code></td>
<td>
<p>if TRUE, an intercept was used in the regression. </p>
</td></tr>
<tr><td><code>scheme</code></td>
<td>
<p>a character vector denoting the type of regression used in the prediction (&quot;Linear&quot;, &quot;Quad&quot; or &quot;Cubic&quot;). </p>
</td></tr>
<tr><td><code>details</code></td>
<td>
<p>a vector of the detail coefficients from which <code>AdaptPredmp</code> selects the minimum value. There are six entries. The first three entries represent the detail coefficients from regression with no intercept in increasing order of prediction. The second three details are values for regression with intercept. </p>
</td></tr>
<tr><td><code>minindex</code></td>
<td>
<p>the index into details (<span class="env">results[[9]]</span>) which produces the minimum value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight</p>


<h3>See Also</h3>

<p><code><a href="#topic+AdaptNeighmp">AdaptNeighmp</a></code>, <code><a href="#topic+CubicPredmp">CubicPredmp</a></code>, <code><a href="#topic+fwtnpmp">fwtnpmp</a></code>, <code><a href="#topic+LinearPredmp">LinearPredmp</a></code>, <code><a href="#topic+QuadPredmp">QuadPredmp</a></code>    </p>


<h3>Examples</h3>

<pre><code class='language-R'>#read in data with multiple values...

data(motorcycledata)
times&lt;-motorcycledata$time
accel&lt;-motorcycledata$accel
short&lt;-adjustx(times,accel,"mean")
X&lt;-short$sepx
coeff&lt;-short$sepx
g&lt;-short$g

coefflist&lt;-list()
for (i in 1:length(g)){
coefflist[[i]]&lt;-accel[g[[i]]]
}

#work out neighbours of point to be removed (31)

out&lt;-getnbrs(X,31,order(X),2,TRUE)
nbrs&lt;-out$n

nbrs

newnbrs&lt;-NULL
for (i in 1:length(nbrs)){
newnbrs&lt;-c(newnbrs,rep(nbrs[i],times=length(g[[nbrs[i]]])))
}

#work out repeated neighbours using g...
newnbrs

AdaptPredmp(order(X),X,coefflist,coeff,nbrs,newnbrs,31,TRUE,2,"ave",g)

</code></pre>

<hr>
<h2 id='adjustx'>adjustx</h2><span id='topic+adjustx'></span>

<h3>Description</h3>

<p>This function produces new grid values to cope with data with repeated grid values according to the method chosen to deal with it. </p>


<h3>Usage</h3>

<pre><code class='language-R'>adjustx(x, f, type = "mean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjustx_+3A_x">x</code></td>
<td>
<p>a vector of the original (repeated) gridpoints.</p>
</td></tr>
<tr><td><code id="adjustx_+3A_f">f</code></td>
<td>
<p>the vector of function values associated to the grid vector <span class="env">X</span>.</p>
</td></tr>
<tr><td><code id="adjustx_+3A_type">type</code></td>
<td>
<p>The method used to cope with the multiple points. <span class="env">"mean"</span> averages all function values with the same grid value. The <span class="env">"jitter"</span> option adds a small amount to all but one of each repeated grid value, and associates the function values to these new gridpoints. In this way, the each gridpoint value corresponds uniquely to the function values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function compares <span class="env">x</span> to <code>unique(x)</code> to find the occurences of repeated grid values, and stores the information in groups. In the <span class="env">"jitter"</span> case, this is then used to modify the original gridpoints by adding an epsilon to the repeated values. In the case of <span class="env">type="mean"</span>, the new gridpoints are, in fact <code>unique(x)</code>, and the information is used to average the groups of original function values to construct <span class="env">sepf</span>. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>sepx</code></td>
<td>
<p>the vector of new gridpoints.</p>
</td></tr>
<tr><td><code>sepf</code></td>
<td>
<p>the function values associated to <span class="env">sepx</span>. </p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>a list of indices into <span class="env">x</span> showing where the original repeated grid values occured.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fwtnp">fwtnp</a></code>,     </p>


<h3>Examples</h3>

<pre><code class='language-R'>#read in the motorcycle crash data 
#
data(motorcycledata)

#
dim(motorcycledata)

#check data.
#
times&lt;-motorcycledata$time
accel&lt;-motorcycledata$accel

a&lt;-adjustx(times,accel,"mean")
#
#note the repeated values in the original grid data
#
#display new data vectors
a$sepx
#
a$sepf
# 
#and now the new adjusted data has length 94.
#
</code></pre>

<hr>
<h2 id='Amatdual'>Amatdual</h2><span id='topic+Amatdual'></span><span id='topic+Amatdual2'></span>

<h3>Description</h3>

<p>Combines filter matrices to produce a refinement matrix A for a wavelet transform. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Amatdual(steps, pointsin, removelist, nbrs, weights, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Amatdual_+3A_steps">steps</code></td>
<td>
<p>a value indicating which refinement matrix to construct. It refers to the number of points already removed during the transform.</p>
</td></tr>
<tr><td><code id="Amatdual_+3A_pointsin">pointsin</code></td>
<td>
<p>The indices of gridpoints still to be removed. </p>
</td></tr>
<tr><td><code id="Amatdual_+3A_removelist">removelist</code></td>
<td>
<p>a vector of indices into envX of the lifted coefficients during the transform (in the order of removal). </p>
</td></tr>
<tr><td><code id="Amatdual_+3A_nbrs">nbrs</code></td>
<td>
<p>indices of the neighbours used in the last step of the decomposition.</p>
</td></tr>
<tr><td><code id="Amatdual_+3A_weights">weights</code></td>
<td>
<p>the prediction weights obtained from the regression in the prediction step of the transform.</p>
</td></tr>
<tr><td><code id="Amatdual_+3A_alpha">alpha</code></td>
<td>
<p>the update weights used to update <span class="env">lengths</span> and <span class="env">coeff</span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the prediction and update weights to construct the filter matrices <span class="env">Hdual</span> and <span class="env">Gdual</span>. Combining these two matrices results in the refinement matrix <span class="env">Adual</span>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Adual</code></td>
<td>
<p>the refinement matrix for the particular step of the transform. </p>
</td></tr>
<tr><td><code>Hdual</code></td>
<td>
<p>the high-pass filter matrix for the current step of the transform.</p>
</td></tr>
<tr><td><code>Gdual</code></td>
<td>
<p>the low-pass filter matrix for the current step of the transform.</p>
</td></tr>
<tr><td><code>o</code></td>
<td>
<p>the indices of <span class="env">nbrs</span> into the vector of <span class="env">pointsin</span> and the <span class="env">steps</span> removed points of the transform.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the update weights used to update <span class="env">lengths</span> and <span class="env">coeff</span>.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the prediction weights obtained from the regression in the prediction step of the transform.</p>
</td></tr>
</table>


<h3>Note</h3>

<p> This function has been left in the package for completeness.  However, the transform matrix is (optionally) computed within the forward lifting
transform function <code><a href="#topic+fwtnp">fwtnp</a></code>.
</p>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight </p>


<h3>See Also</h3>

<p><code><a href="#topic+transmatdual">transmatdual</a></code>, <code><a href="#topic+fwtnp">fwtnp</a></code>    </p>


<h3>Examples</h3>

<pre><code class='language-R'>#
x&lt;-runif(256)
y&lt;-make.signal2("doppler",x=x)
a&lt;-fwtnp(x,y,LocalPred=AdaptNeigh,neighbours=2)
#
Adual&lt;-Amatdual(90,a$pointsin,a$removelist,a$neighbrs[[90]],
a$gamlist[[90]],a$alphalist[[90]])
#
Adual
#
#the 90th refinement matrix for the transform above.
#
</code></pre>

<hr>
<h2 id='artlev'>artlev</h2><span id='topic+artlev'></span>

<h3>Description</h3>

<p>This function splits the coefficients into levels according to increasing quantiles of the removed interval lengths.    
</p>


<h3>Usage</h3>

<pre><code class='language-R'>artlev(y, rem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="artlev_+3A_y">y</code></td>
<td>
<p>a vector of the removed interval lengths (in the order of <span class="env">removelist</span>). </p>
</td></tr>
<tr><td><code id="artlev_+3A_rem">rem</code></td>
<td>
<p>vector of indices of the removed points (from the output of the forward transform). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function finds the median of the removed interval lengths, and takes all <span class="env">pointsin</span> indices with removed interval lengths at most this value as the first artificial level. These indices are now not considered in later groups. The cut-off value, q, is now increased to the 75th percentile, and the indices at most this value are grouped into the second level. The procedure is continued with successive percentiles (1+q)/2 until all indices are grouped. At each stage, the level size is checked to ensure it has at least 10 elements, and if not, the level is taken together with the next level (i.e. the present percentile is ignored, and increased to the q value).   
</p>


<h3>Value</h3>

<table>
<tr><td><code>p</code></td>
<td>
<p>a list of the grouped indices of <span class="env">removelist</span> (in decreasing group size) indicating thresholding groups.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight</p>


<h3>See Also</h3>

<p><code><a href="#topic+denoise">denoise</a></code>,     </p>


<h3>Examples</h3>

<pre><code class='language-R'>#create test signal data
#
x&lt;-runif(100)
y&lt;-make.signal2("blocks",x=x)
#
#perform forward transform...
#
out&lt;-fwtnp(x,y,LocalPred=AdaptNeigh,neighbours=2)
#
al&lt;-artlev(out$lengthsremove,out$removelist)
#
#
# the indices of removelist split into levels:
al
#
</code></pre>

<hr>
<h2 id='as.column'>as.column</h2><span id='topic+as.column'></span>

<h3>Description</h3>

<p>This function returns a given vector as a column (with dimension).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.column(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.column_+3A_x">x</code></td>
<td>
<p>any vector or array.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><span class="env">x</span> can either be a vector with no dimension attributes (a list of values), a vector with dimensions, or a matrix/array. If <span class="env">x</span> is a matrix/array, the function gives <span class="env">x</span> if <code>ncol(x)</code> is less than or equal to <code>nrow(x)</code>, or its transpose if <code>ncol(x)</code> is greater than or equal to <code>nrow(x)</code>. For any input, the input is given non-null dimensions. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>y</code></td>
<td>
<p>a vector identical to <span class="env">x</span>, but given as a column.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.row">as.row</a></code>    </p>


<h3>Examples</h3>

<pre><code class='language-R'>vector&lt;-1:8
#
vector          
#
#...vector has no dimension attributes
# 
as.column(vector)        
#
#...gives output dimension of (8,1)
#
A&lt;-matrix(c(6,2,2,10,6,17),3,2)
#
#
as.column(A)

#
#the function has no effect on F
#
F&lt;-t(A)
F
#now has dimension (2,3)...
#
as.column(A)
#
#the output is made to have more rows than columns

</code></pre>

<hr>
<h2 id='as.row'>as.row</h2><span id='topic+as.row'></span>

<h3>Description</h3>

<p>This function returns a given vector as a row (with dimension). </p>


<h3>Usage</h3>

<pre><code class='language-R'>as.row(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.row_+3A_x">x</code></td>
<td>
<p>any vector or array</p>
</td></tr>
</table>


<h3>Details</h3>

<p><span class="env">x</span> can either be a vector with no dimension attributes (a list of values), a vector with dimensions, or a matrix/array. If <span class="env">x</span> is a matrix/array, the function gives <span class="env">x</span> if <code>ncol(x)</code> is greater than or equal to <code>nrow(x)</code>, or its transpose if <code>ncol(x)</code> is less than or equal to <code>nrow(x)</code>. For any input, the input is given non-null dimensions.  
</p>


<h3>Value</h3>

<table>
<tr><td><code>y</code></td>
<td>
<p>a vector identical to <span class="env">x</span>, but given as a row.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.column">as.column</a></code>     </p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-0:5
#
X
#
as.row(X)
#
#puts input into row (matrix)
#
Y&lt;-matrix(0:5,6,1)
#
Y
#
as.row(Y)
#
#input forced into a row.
#
</code></pre>

<hr>
<h2 id='basisfns'>basisfns</h2><span id='topic+basisfns'></span>

<h3>Description</h3>

<p>This function plots all mother and father wavelets associated with a given wavelet transform.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basisfns(x, f, pred, neigh, int, clo, keep, plot.f = FALSE, 
plot.bas = FALSE, separate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basisfns_+3A_x">x</code></td>
<td>
<p>a gridpoint vector.</p>
</td></tr>
<tr><td><code id="basisfns_+3A_f">f</code></td>
<td>
<p>the vector of associated function values.</p>
</td></tr>
<tr><td><code id="basisfns_+3A_pred">pred</code></td>
<td>
<p>The type of regression to be performed. Possible options are <a href="#topic+LinearPred">LinearPred</a>, <a href="#topic+QuadPred">QuadPred</a>, <a href="#topic+CubicPred">CubicPred</a>, <a href="#topic+AdaptPred">AdaptPred</a> and <a href="#topic+AdaptNeigh">AdaptNeigh</a>.</p>
</td></tr>
<tr><td><code id="basisfns_+3A_neigh">neigh</code></td>
<td>
<p>The number of neighbours over which the regression is performed at each step. If <span class="env">closest</span> is false, then this in fact denotes the number of neighbours on each side of the removed point.</p>
</td></tr>
<tr><td><code id="basisfns_+3A_int">int</code></td>
<td>
<p>Indicates whether or not the regression curve includes an intercept.</p>
</td></tr>
<tr><td><code id="basisfns_+3A_clo">clo</code></td>
<td>
<p>Refers to the configuration of the chosen neighbours. If <span class="env">closest</span> is false, the neighbours will be chosen symmetrically around the removed point. Otherwise, the closest neighbours will be chosen.</p>
</td></tr>
<tr><td><code id="basisfns_+3A_keep">keep</code></td>
<td>
<p>The number of scaling coefficients to be kept in the final representation of the initial signal. This must be at least two.</p>
</td></tr>
<tr><td><code id="basisfns_+3A_plot.f">plot.f</code></td>
<td>
<p>a boolean value indicating whether to plot the original function or not. If so, the signal is plotted with vertical coloured lines, showing which prediction method was used on the different parts of the signal. The plot also shows which gridpoints correspond to scaling functions.</p>
</td></tr>
<tr><td><code id="basisfns_+3A_plot.bas">plot.bas</code></td>
<td>
<p> subset of <code>1:length(f)</code>, denoting which basis functions to plot. Each basis function is colour-coded according to which prediction scheme was used in the lifting of the corresponding gridpoint.</p>
</td></tr>
<tr><td><code id="basisfns_+3A_separate">separate</code></td>
<td>
<p>a boolean argument indicating if the basis functions should be plotted on a single graphsheet.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure constructs <span class="env">W</span>, the matrix representation of the forward transform specified in the arguments to the function, and then uses the inverse matrix to calculate the vectors of basis function values: to work out the basis function values, one inverts the transform with a delta vector, with a one in the position corresponding to the basis function required. Since this is equivalent to pre-multiplying the delta vector by the matrix representation for the inverse transform <code class="reqn">(W^{-1})</code>, the basis function values are precisely the columns of <code class="reqn">W^{-1}</code>. The procedure then plots the basis functions (each on a separate graphsheet, if chosen), colour coded according to the prediction scheme used or whether it is a scaling function. </p>


<h3>Value</h3>

<table>
<tr><td><code>out</code></td>
<td>
<p>the output from the forward transform which is specified in the arguments to this function</p>
</td></tr>
</table>
<p>$</p>
<table>
<tr><td><code>pointsin</code></td>
<td>
<p>the vector of indices of points still to be removed.</p>
</td></tr>
<tr><td><code>schhist</code></td>
<td>
<p>a character string vector of the prediction scheme used for the prediction of each gridpoint (in the order of <span class="env">x</span>).</p>
</td></tr>
<tr><td><code>inthist</code></td>
<td>
<p>vector of boolean values indicating whether an intercept was used in the prediction steps during the transform (in the order of <span class="env">x</span>). </p>
</td></tr>
<tr><td><code>basmat</code></td>
<td>
<p>a matrix of wavelet basis function values. The row <span class="env">i</span> represents the function values corresponding to the grid for the basis function associated to the gridpoint <code class="reqn">i</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If <span class="env">plot.bas=T</span>, since the function produces one graph for each gridpoint, R or Splus is likely to exceed the total number of open devices for large datasets.</p>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight</p>


<h3>See Also</h3>

<p><code><a href="#topic+fwtnp">fwtnp</a></code>,<code><a href="#topic+fwtnp">fwtnp</a></code>     </p>


<h3>Examples</h3>

<pre><code class='language-R'>#create test signal data
#
x&lt;-runif(100)
y&lt;-make.signal2("blocks",x=x)
#
#perform procedure...
#
a&lt;-basisfns(x,y,AdaptNeigh,2,TRUE,TRUE,2,FALSE,c(1,14,15),FALSE)
#
#this produces plots of three basis functions all on one graph.
</code></pre>

<hr>
<h2 id='condno'>condno</h2><span id='topic+condno'></span>

<h3>Description</h3>

<p>This function uses a specified norm to compute the condition number of a matrix representation of a wavelet transform.    
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condno(W, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condno_+3A_w">W</code></td>
<td>
<p>a matrix which represents a wavelet transform.</p>
</td></tr>
<tr><td><code id="condno_+3A_type">type</code></td>
<td>
<p>a character string denoting which norm to use when computing the condition number. Possible values are <span class="env">"l1"</span>, or one of the standard norm types, <span class="env">"F"</span> (Frobenius norm), <span class="env">"i"</span> (infinity norm), <span class="env">"m"</span> (max modulus of a matrix) or <span class="env">"1"</span> (1-norm). 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the condition number as <span class="env">condno</span> = <code class="reqn">||W||*||W^{-1}||</code>. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>condno</code></td>
<td>
<p>the condition number of the matrix <span class="env">W</span>. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>The matrix <span class="env">W</span> must be invertible.</p>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create test signal data
#
x&lt;-runif(100)
y&lt;-make.signal2("blocks",x=x)
#
a&lt;-fwtnp(x,y,LocalPred=AdaptNeigh,neigh=2,do.W=TRUE,varonly=FALSE)
#
#computes the transition matrix for the specified options
#
W&lt;-a$W
#
condno(W,"F")
#
condno(W,"l1")
#
condno(W,"1")
# 
</code></pre>

<hr>
<h2 id='CubicPred'>CubicPred</h2><span id='topic+CubicPred'></span>

<h3>Description</h3>

<p>This function performs the prediction lifting step using a cubic regression curve given a configuration of neighbours.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CubicPred(pointsin, X, coeff, nbrs, remove, intercept, 
neighbours)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CubicPred_+3A_pointsin">pointsin</code></td>
<td>
<p>The indices of gridpoints still to be removed.</p>
</td></tr>
<tr><td><code id="CubicPred_+3A_x">X</code></td>
<td>
<p>the vector of grid values.</p>
</td></tr>
<tr><td><code id="CubicPred_+3A_coeff">coeff</code></td>
<td>
<p>the vector of detail and scaling coefficients at that step of the transform.</p>
</td></tr>
<tr><td><code id="CubicPred_+3A_nbrs">nbrs</code></td>
<td>
<p>the indices (into <span class="env">X</span>) of the neighbours to be used in the prediction step.</p>
</td></tr>
<tr><td><code id="CubicPred_+3A_remove">remove</code></td>
<td>
<p>the index (into <span class="env">X</span>) of the point to be removed.</p>
</td></tr>
<tr><td><code id="CubicPred_+3A_intercept">intercept</code></td>
<td>
<p>Boolean value for whether or not an intercept is used in the prediction step of the transform. </p>
</td></tr>
<tr><td><code id="CubicPred_+3A_neighbours">neighbours</code></td>
<td>
<p>the number of neighbours in the computation of the predicted value. This is not actually used specifically in <code>CubicPred</code>, since this is known already from <span class="env">nbrs</span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure performs cubic regression using the given neighbours using an intercept if chosen. The regression coefficients (<span class="env">weights</span>) are used to predict the new function value at the removed point. If there are not enough neighbours to generate a cubic regression curve, the order of prediction is decreased until it is possible (i.e. to <code>QuadPred</code>, then <code>LinearPred</code>).  
</p>


<h3>Value</h3>

<table>
<tr><td><code>Xneigh</code></td>
<td>
<p>matrix of <span class="env">X</span> values corresponding to the neighbours of the removed point. The matrix consists of columns <code class="reqn">X[nbrs],X[nbrs]^2,X[nbrs]^3</code> augmented with a column of ones if an intercept is used. Refer to any reference on linear regression for more details.</p>
</td></tr>
<tr><td><code>mm</code></td>
<td>
<p>the matrix from which the prediction is made. In terms of <span class="env">Xneigh</span>, it is <br /> <code class="reqn">(Xneigh^T Xneigh)^{-1} Xneigh^T</code> .</p>
</td></tr>
<tr><td><code>bhat</code></td>
<td>
<p>The regression coefficients used in prediction.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the prediction weights for the neighbours.</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>the predicted function value obtained from the regression.</p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>vector of (modified) detail and scaling coefficients to be used in the update step of the transform.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight </p>


<h3>See Also</h3>

<p><code><a href="#topic+fwtnp">fwtnp</a></code>, <code><a href="#topic+LinearPred">LinearPred</a></code>, <code><a href="#topic+QuadPred">QuadPred</a></code>     </p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some doppler data: 500 observations.
#
tx &lt;- runif(500)
ty&lt;-make.signal2("doppler",x=tx)
#
# Compute the neighbours of point 173 (2 neighbours on each side)
#
out&lt;-getnbrs(tx,173,order(tx),2,FALSE)

#
# Perform cubic prediction based on the neighbours (without intercept) 
#
cp&lt;-CubicPred(order(tx),tx,ty,out$nbrs,173,FALSE,2)
#
cp$bhat

#
#the coefficients which define the cubic regression curve
#
cp$pred

#
#the predicted value from the regression curve
#
</code></pre>

<hr>
<h2 id='CubicPredmp'>CubicPredmp</h2><span id='topic+CubicPredmp'></span>

<h3>Description</h3>

<p>This function performs the prediction lifting step using a cubic regression curve given a configuration of neighbours, for multiple point data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CubicPredmp(pointsin, X, coefflist, coeff, nbrs, newnbrs, remove, 
intercept, neighbours, mpdet, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CubicPredmp_+3A_pointsin">pointsin</code></td>
<td>
<p>The indices of gridpoints still to be removed.</p>
</td></tr>
<tr><td><code id="CubicPredmp_+3A_x">X</code></td>
<td>
<p>the vector of grid values.</p>
</td></tr>
<tr><td><code id="CubicPredmp_+3A_coeff">coeff</code></td>
<td>
<p>the vector of detail and scaling coefficients at that step of the transform.</p>
</td></tr>
<tr><td><code id="CubicPredmp_+3A_coefflist">coefflist</code></td>
<td>
<p>the list of detail and multiple scaling coefficients at that step of the transform.</p>
</td></tr>
<tr><td><code id="CubicPredmp_+3A_nbrs">nbrs</code></td>
<td>
<p>the indices (into <span class="env">X</span>) of the neighbours to be used in the prediction step.</p>
</td></tr>
<tr><td><code id="CubicPredmp_+3A_newnbrs">newnbrs</code></td>
<td>
<p>as nbrs, but repeated according to the multiple point structure of the grid.</p>
</td></tr>
<tr><td><code id="CubicPredmp_+3A_remove">remove</code></td>
<td>
<p>the index (into <span class="env">X</span>) of the point to be removed.</p>
</td></tr>
<tr><td><code id="CubicPredmp_+3A_intercept">intercept</code></td>
<td>
<p>Boolean value for whether or not an intercept is used in the prediction step of the transform.</p>
</td></tr>
<tr><td><code id="CubicPredmp_+3A_neighbours">neighbours</code></td>
<td>
<p>the number of neighbours in the computation of the predicted value. This is not actually used specifically in <code>CubicPredmp</code>, since this is known already from <span class="env">nbrs</span>.</p>
</td></tr>
<tr><td><code id="CubicPredmp_+3A_mpdet">mpdet</code></td>
<td>
<p>how the mutiple point detail coefficients are computed.  Possible values are &quot;ave&quot;, in which the multiple detail coefficients produced when performing the multiple predictions are averaged, or &quot;min&quot;, where the overall minimum detail coefficient is taken.  Note that this is taken to standardise the input when <span class="env">LocalPredmp</span> is called.</p>
</td></tr>
<tr><td><code id="CubicPredmp_+3A_g">g</code></td>
<td>
<p>the group structure of the multiple point data.  Note that this is taken to standardise the input when <span class="env">LocalPredmp</span> is called.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The procedure performs cubic regression using the given neighbours using an intercept if chosen. The regression coefficients (<span class="env">weights</span>) are used to predict the new function value at the removed point.   
</p>


<h3>Value</h3>

<table>
<tr><td><code>Xneigh</code></td>
<td>
<p>matrix of X values corresponding to the neighbours of the removed point. The matrix consists of the column X[newnbrs] augmented with a column of ones if an intercept is used. Refer to any reference on linear regression for more details.</p>
</td></tr>
<tr><td><code>mm</code></td>
<td>
<p>the matrix from which the prediction is made. In terms of <span class="env">Xneigh</span>, it is <br /> <code class="reqn">(Xneigh^T Xneigh)^{-1} Xneigh^T</code>.</p>
</td></tr>
<tr><td><code>bhat</code></td>
<td>
<p>The regression coefficients used in prediction.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the prediction weights for the neighbours.</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>the predicted function value obtained from the regression.</p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>vector of (modified) detail and scaling coefficients to be used in the update step of the transform.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight</p>


<h3>See Also</h3>

<p><code><a href="#topic+fwtnpmp">fwtnpmp</a></code>, <code><a href="#topic+LinearPredmp">LinearPredmp</a></code>, <code><a href="#topic+QuadPredmp">QuadPredmp</a></code>     </p>


<h3>Examples</h3>

<pre><code class='language-R'>#read in data with multiple values...

data(motorcycledata)
times&lt;-motorcycledata$time
accel&lt;-motorcycledata$accel

short&lt;-adjustx(times,accel,"mean")
X&lt;-short$sepx
coeff&lt;-short$sepx
g&lt;-short$g

coefflist&lt;-list()
for (i in 1:length(g)){
coefflist[[i]]&lt;-accel[g[[i]]]
}

#work out neighbours of point to be removed (31)

out&lt;-getnbrs(X,31,order(X),2,TRUE)
nbrs&lt;-out$n

nbrs

newnbrs&lt;-NULL
for (i in 1:length(nbrs)){
newnbrs&lt;-c(newnbrs,rep(nbrs[i],times=length(g[[nbrs[i]]])))
}

#work out repeated neighbours using g...
newnbrs

CubicPredmp(order(X),X,coefflist,coeff,nbrs,newnbrs,31,TRUE,2,"ave",g)

</code></pre>

<hr>
<h2 id='denoise'>denoise</h2><span id='topic+denoise'></span><span id='topic+denoise2'></span>

<h3>Description</h3>

<p>Denoises the inputted signal using artificial levels noise variance estimation and bayesian thresholding.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denoise(x, f, pred, neigh, int, clo, keep, rule = "median", 
returnall=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="denoise_+3A_x">x</code></td>
<td>
<p>A vector of grid values. Can be of any length, not necessarily equally spaced. </p>
</td></tr>
<tr><td><code id="denoise_+3A_f">f</code></td>
<td>
<p>A vector of function values corresponding to <span class="env">x</span>. Must be of the same length as <span class="env">x</span>.</p>
</td></tr>
<tr><td><code id="denoise_+3A_pred">pred</code></td>
<td>
<p>The type of regression to be performed. Possible options are <code><a href="#topic+LinearPred">LinearPred</a></code>, <code><a href="#topic+QuadPred">QuadPred</a></code>, <code><a href="#topic+CubicPred">CubicPred</a></code>, <code><a href="#topic+AdaptPred">AdaptPred</a></code> and <code><a href="#topic+AdaptNeigh">AdaptNeigh</a></code>.</p>
</td></tr>
<tr><td><code id="denoise_+3A_neigh">neigh</code></td>
<td>
<p>The number of neighbours over which the regression is performed at each step. If clo is false, then this in fact denotes the number of neighbours on each side of the removed point.</p>
</td></tr>
<tr><td><code id="denoise_+3A_int">int</code></td>
<td>
<p>Indicates whether or not the regression curve includes an intercept.</p>
</td></tr>
<tr><td><code id="denoise_+3A_clo">clo</code></td>
<td>
<p>Refers to the configuration of the chosen neighbours. If <span class="env">clo</span> is false, the neighbours will be chosen symmetrically around the removed point. Otherwise, the closest neighbours will be chosen.</p>
</td></tr>
<tr><td><code id="denoise_+3A_keep">keep</code></td>
<td>
<p>The number of scaling coefficients to be kept in the final representation of the initial signal. This must be at least two.</p>
</td></tr>
<tr><td><code id="denoise_+3A_rule">rule</code></td>
<td>
<p>The type of bayesian thresholding used in the procedure. Possible values are <span class="env">"mean"</span>, <span class="env">"median"</span> (posterior mean or median thresholding) or &quot;hard <br /> or &quot;soft&quot; (hard or soft thresholding). </p>
</td></tr>
<tr><td><code id="denoise_+3A_returnall">returnall</code></td>
<td>
<p>Indicates whether the function should return useful variables or just the denoised datapoints.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the transform matrix to normalise the detail coefficients produced from the forward transform according to the correlation structure, so that they can be used in the bayesian thresholding procedure EbayesThresh. The coefficients are divided into artificial levels, and the first (largest)level is used to estimate the noise variance of the coefficients. EbayesThresh is then used to threshold the coefficients. The resulting new coefficients are then unnormalised and the transform inverted to obtain an estimate of the true (unnoisy) signal.    
</p>


<h3>Value</h3>

<p>If <span class="env">returnall=FALSE</span>, the estimate of the function after denoising.  If <span class="env">returnall=TRUE</span>, a list with components:<br />
</p>
<table>
<tr><td><code>fhat</code></td>
<td>
<p>the estimate of the function after denoising.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>the matrix associated to the wavelet transform.</p>
</td></tr>
<tr><td><code>indsd</code></td>
<td>
<p>the individual coefficient variances introduced by the transform.</p>
</td></tr>
<tr><td><code>al</code></td>
<td>
<p>the artificial levels used to estimate the noise variance.</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>the standard deviation of the noise.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight </p>


<h3>See Also</h3>

<p><code><a href="#topic+denoisehetero">denoisehetero</a></code>   </p>


<h3>Examples</h3>

<pre><code class='language-R'>x1&lt;-runif(256)
y1&lt;-make.signal2("doppler",x=x1)
n1&lt;-rnorm(256,0,.1)
z1&lt;-y1+n1
#
est1&lt;-denoise(x1,z1,AdaptNeigh,1,TRUE,TRUE,2)
sum(abs(y1-est1))
#
#the error between the true signal and the denoised version. 


</code></pre>

<hr>
<h2 id='denoisehetero'>denoisehetero</h2><span id='topic+denoisehetero'></span><span id='topic+denoisehetero2'></span>

<h3>Description</h3>

<p>Denoises the inputted signal using artificial levels noise variance estimation and bayesian thresholding, using heteroscedastic (estimated) noise variances.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denoisehetero(x, f, pred, neigh, int, clo, keep, rule = "median",
returnall=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="denoisehetero_+3A_x">x</code></td>
<td>
<p>A vector of grid values. Can be of any length, not necessarily equally spaced. </p>
</td></tr>
<tr><td><code id="denoisehetero_+3A_f">f</code></td>
<td>
<p>A vector of function values corresponding to <span class="env">x</span>. Must be of the same length as <span class="env">x</span>.</p>
</td></tr>
<tr><td><code id="denoisehetero_+3A_pred">pred</code></td>
<td>
<p>The type of regression to be performed. Possible options are <code><a href="#topic+LinearPred">LinearPred</a></code>, <code><a href="#topic+QuadPred">QuadPred</a></code>, <code><a href="#topic+CubicPred">CubicPred</a></code>, <code><a href="#topic+AdaptPred">AdaptPred</a></code> and <code><a href="#topic+AdaptNeigh">AdaptNeigh</a></code>.</p>
</td></tr>
<tr><td><code id="denoisehetero_+3A_neigh">neigh</code></td>
<td>
<p>The number of neighbours over which the regression is performed at each step. If clo is false, then this in fact denotes the number of neighbours on each side of the removed point.</p>
</td></tr>
<tr><td><code id="denoisehetero_+3A_int">int</code></td>
<td>
<p>Indicates whether or not the regression curve includes an intercept.</p>
</td></tr>
<tr><td><code id="denoisehetero_+3A_clo">clo</code></td>
<td>
<p>Refers to the configuration of the chosen neighbours. If <span class="env">clo</span> is false, the neighbours will be chosen symmetrically around the removed point. Otherwise, the closest neighbours will be chosen.</p>
</td></tr>
<tr><td><code id="denoisehetero_+3A_keep">keep</code></td>
<td>
<p>The number of scaling coefficients to be kept in the final representation of the initial signal. This must be at least two.</p>
</td></tr>
<tr><td><code id="denoisehetero_+3A_rule">rule</code></td>
<td>
<p>The type of bayesian thresholding used in the procedure. Possible values are <span class="env">"mean"</span>, <span class="env">"median"</span> (posterior mean or median thresholding) or &quot;hard or <br /> &quot;soft&quot; (hard or soft thresholding). </p>
</td></tr>
<tr><td><code id="denoisehetero_+3A_returnall">returnall</code></td>
<td>
<p>Indicates whether the function returns useful variables or just the denoised datapoints.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the transform matrix to normalise the detail coefficients produced from the forward transform, so that they can be used in the bayesian thresholding procedure EbayesThresh. The coefficients are divided into artificial levels, and the first (largest)level is used to estimate the noise variances of the coefficients, based on the MAD of those coefficients falling in a sliding window around each gridpoint.  EbayesThresh is then used to threshold the coefficients. The resulting new coefficients are then unnormalised and the transform inverted to obtain an estimate of the true (unnoisy) signal.    
</p>


<h3>Value</h3>

<p>If <span class="env">returnall=FALSE</span>, the estimate of the function after denoising.  If <span class="env">returnall=TRUE</span>, a list with components:<br />
</p>
<table>
<tr><td><code>fhat</code></td>
<td>
<p>the estimate of the function after denoising.</p>
</td></tr>
<tr><td><code>fhat1</code></td>
<td>
<p>the estimate of the function after denoising, using the alternate variance estimate of MAD, centered at zero.</p>
</td></tr>
<tr><td><code>fhat2</code></td>
<td>
<p>the estimate of the function after denoising, using the alternate variance estimate of the median of the absolute values of the detail coefficients.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>the matrix associated to the wavelet transform.</p>
</td></tr>
<tr><td><code>indsd</code></td>
<td>
<p>the individual coefficient variances introduced by the transform.</p>
</td></tr>
<tr><td><code>al</code></td>
<td>
<p>the artificial levels used to estimate the noise variance.</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>the standard deviation of the noise.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight</p>


<h3>See Also</h3>

<p><code><a href="#topic+denoise">denoise</a></code>,  <code><a href="#topic+heterovar">heterovar</a></code>     </p>


<h3>Examples</h3>

<pre><code class='language-R'>x1&lt;-runif(256)
y1&lt;-make.signal2("doppler",x=x1)
n1&lt;-rnorm(256,0,.1)
z1&lt;-y1+n1
#
est1&lt;-denoisehetero(x1,z1,AdaptNeigh,1,TRUE,TRUE,2)
traceback()
sum(abs(y1-est1))
#
#the error between the true signal and the denoised version. 


</code></pre>

<hr>
<h2 id='denoiseheteromp'>denoiseheteromp</h2><span id='topic+denoiseheteromp'></span>

<h3>Description</h3>

<p>Denoises the multiple observation inputted signal using artificial levels noise variance estimation and bayesian thresholding, using heteroscedastic (estimated) noise variances.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denoiseheteromp(x, f, pred, neigh, int, clo, keep, 
rule = "median", mpdet="ave",returnall=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="denoiseheteromp_+3A_x">x</code></td>
<td>
<p>A vector of grid values. Can be of any length, not necessarily equally spaced. </p>
</td></tr>
<tr><td><code id="denoiseheteromp_+3A_f">f</code></td>
<td>
<p>A vector of function values corresponding to <span class="env">x</span>. Must be of the same length as <span class="env">x</span>.</p>
</td></tr>
<tr><td><code id="denoiseheteromp_+3A_pred">pred</code></td>
<td>
<p>The type of regression to be performed. Possible options are <code><a href="#topic+LinearPred">LinearPred</a></code>, <code><a href="#topic+QuadPred">QuadPred</a></code>, <code><a href="#topic+CubicPred">CubicPred</a></code>, <code><a href="#topic+AdaptPred">AdaptPred</a></code> and <code><a href="#topic+AdaptNeigh">AdaptNeigh</a></code>.</p>
</td></tr>
<tr><td><code id="denoiseheteromp_+3A_neigh">neigh</code></td>
<td>
<p>The number of neighbours over which the regression is performed at each step. If clo is false, then this in fact denotes the number of neighbours on each side of the removed point.</p>
</td></tr>
<tr><td><code id="denoiseheteromp_+3A_int">int</code></td>
<td>
<p>Indicates whether or not the regression curve includes an intercept.</p>
</td></tr>
<tr><td><code id="denoiseheteromp_+3A_clo">clo</code></td>
<td>
<p>Refers to the configuration of the chosen neighbours. If <span class="env">clo</span> is false, the neighbours will be chosen symmetrically around the removed point. Otherwise, the closest neighbours will be chosen.</p>
</td></tr>
<tr><td><code id="denoiseheteromp_+3A_keep">keep</code></td>
<td>
<p>The number of scaling coefficients to be kept in the final representation of the initial signal. This must be at least two.</p>
</td></tr>
<tr><td><code id="denoiseheteromp_+3A_rule">rule</code></td>
<td>
<p>The type of bayesian thresholding used in the procedure. Possible values are <span class="env">"mean"</span>, <span class="env">"median"</span> (posterior mean or median thresholding) or &quot;hard or <br /> &quot;soft&quot; (hard or soft thresholding). </p>
</td></tr>
<tr><td><code id="denoiseheteromp_+3A_mpdet">mpdet</code></td>
<td>
<p>how the mutiple point detail coefficients are computed.  Possible values are &quot;ave&quot;, in which the multiple detail coefficients produced when performing the multiple predictions are averaged, or &quot;min&quot;, where the overall minimum detail coefficient is taken.</p>
</td></tr>
<tr><td><code id="denoiseheteromp_+3A_returnall">returnall</code></td>
<td>
<p>Indicates whether the function returns useful variables or just the denoised datapoints.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the transform matrix to normalise the detail coefficients produced from the forward transform, so that they can be used in the bayesian thresholding procedure EbayesThresh. The coefficients are divided into artificial levels, and the first (largest)level is used to estimate the noise variances of the coefficients, based on those coefficients falling in a sliding window around each gridpoint.  EbayesThresh is then used to threshold the coefficients. The resulting new coefficients are then unnormalised and the transform inverted to obtain an estimate of the true (unnoisy) signal.    
</p>


<h3>Value</h3>

<p>If <span class="env">returnall=FALSE</span>, the estimate of the function after denoising.  If <span class="env">returnall=TRUE</span>, a list with components:<br />
</p>
<table>
<tr><td><code>fhat</code></td>
<td>
<p>the estimate of the function after denoising.</p>
</td></tr>
<tr><td><code>fhat1</code></td>
<td>
<p>the estimate of the function after denoising, using the alternate variance estimate of MAD, centered at zero.</p>
</td></tr>
<tr><td><code>fhat2</code></td>
<td>
<p>the estimate of the function after denoising, using the alternate variance estimate of the median of the absolute values of the detail coefficients.</p>
</td></tr>
<tr><td><code>indsd</code></td>
<td>
<p>the individual coefficient variances introduced by the transform.</p>
</td></tr>
<tr><td><code>al</code></td>
<td>
<p>the artificial levels used to estimate the noise variance.</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>the standard deviation of the noise.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight </p>


<h3>See Also</h3>

<p><code><a href="#topic+denoisehetero">denoisehetero</a></code>, <code><a href="#topic+heterovar">heterovar</a></code>     </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(motorcycledata)
#
times&lt;-motorcycledata$time
accel&lt;-motorcycledata$accel



est1&lt;-denoiseheteromp(times,accel,AdaptNeighmp,1,TRUE,TRUE,2,
"median","ave")
#
#the estimate of the underlying curve. 


</code></pre>

<hr>
<h2 id='denoiseheteroprop'>denoiseheteroprop</h2><span id='topic+denoiseheteroprop'></span><span id='topic+denoiseheteroprop2'></span>

<h3>Description</h3>

<p>Denoises the inputted signal using artificial levels noise variance estimation and bayesian thresholding, assuming noise variances known up to proportionality constants.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denoiseheteroprop(x, f, pred, neigh, int, clo, keep, 
rule = "median",gamvec,returnall=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="denoiseheteroprop_+3A_x">x</code></td>
<td>
<p>A vector of grid values. Can be of any length, not necessarily equally spaced. </p>
</td></tr>
<tr><td><code id="denoiseheteroprop_+3A_f">f</code></td>
<td>
<p>A vector of function values corresponding to <span class="env">x</span>. Must be of the same length as <span class="env">x</span>.</p>
</td></tr>
<tr><td><code id="denoiseheteroprop_+3A_pred">pred</code></td>
<td>
<p>The type of regression to be performed. Possible options are <code><a href="#topic+LinearPred">LinearPred</a></code>, <code><a href="#topic+QuadPred">QuadPred</a></code>, <code><a href="#topic+CubicPred">CubicPred</a></code>, <code><a href="#topic+AdaptPred">AdaptPred</a></code> and <code><a href="#topic+AdaptNeigh">AdaptNeigh</a></code>.</p>
</td></tr>
<tr><td><code id="denoiseheteroprop_+3A_neigh">neigh</code></td>
<td>
<p>The number of neighbours over which the regression is performed at each step. If clo is false, then this in fact denotes the number of neighbours on each side of the removed point.</p>
</td></tr>
<tr><td><code id="denoiseheteroprop_+3A_int">int</code></td>
<td>
<p>Indicates whether or not the regression curve includes an intercept.</p>
</td></tr>
<tr><td><code id="denoiseheteroprop_+3A_clo">clo</code></td>
<td>
<p>Refers to the configuration of the chosen neighbours. If <span class="env">clo</span> is false, the neighbours will be chosen symmetrically around the removed point. Otherwise, the closest neighbours will be chosen.</p>
</td></tr>
<tr><td><code id="denoiseheteroprop_+3A_keep">keep</code></td>
<td>
<p>The number of scaling coefficients to be kept in the final representation of the initial signal. This must be at least two.</p>
</td></tr>
<tr><td><code id="denoiseheteroprop_+3A_rule">rule</code></td>
<td>
<p>The type of bayesian thresholding used in the procedure. Possible values are <span class="env">"mean"</span>, <span class="env">"median"</span> (posterior mean or median thresholding) or &quot;hard or <br /> &quot;soft&quot; (hard or soft thresholding). </p>
</td></tr>
<tr><td><code id="denoiseheteroprop_+3A_gamvec">gamvec</code></td>
<td>
<p>A vector of proportions of the noise standard deviations (in the order of <span class="env">x</span>).</p>
</td></tr>
<tr><td><code id="denoiseheteroprop_+3A_returnall">returnall</code></td>
<td>
<p>Indicates whether the function returns useful variables or just the denoised datapoints.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the transform matrix to normalise the detail coefficients produced from the forward transform, so that they can be used in the bayesian thresholding procedure EbayesThresh.  The normalising factors are calculated assuming that the noise associated to the ith gridpoint is <code class="reqn">\gamma_{i}\sigma</code>. The coefficients are divided into artificial levels, and the first (largest)level is used to estimate the noise variance of the coefficients.  EbayesThresh is then used to threshold the coefficients. The resulting new coefficients are then unnormalised and the transform inverted to obtain an estimate of the true (unnoisy) signal.    
</p>


<h3>Value</h3>

<p>If <span class="env">returnall=FALSE</span>, the estimate of the function after denoising.  If <span class="env">returnall=TRUE</span>, a list with components:<br />
</p>
<table>
<tr><td><code>fhat</code></td>
<td>
<p>the estimate of the function after denoising.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>the matrix associated to the wavelet transform.</p>
</td></tr>
<tr><td><code>indsd</code></td>
<td>
<p>the individual coefficient variances introduced by the transform.</p>
</td></tr>
<tr><td><code>al</code></td>
<td>
<p>the artificial levels used to estimate the noise variance.</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>the standard deviation of the noise.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight</p>


<h3>See Also</h3>

<p><code><a href="#topic+denoise">denoise</a></code>   </p>


<h3>Examples</h3>

<pre><code class='language-R'>x1&lt;-runif(256)
y1&lt;-make.signal2("doppler",x=x1)
n1&lt;-rnorm(256,0,.1)
z1&lt;-y1+n1
gvec&lt;-c(rep(.4,times=100),rep(.7,times=100),rep(.3,times=56))
#
est1&lt;-denoiseheteroprop(x1,z1,AdaptNeigh,1,TRUE,TRUE,2,"median",gvec)
sum(abs(y1-est1))
#
#the error between the true signal and the denoised version. 


</code></pre>

<hr>
<h2 id='dojitter'>dojitter</h2><span id='topic+dojitter'></span>

<h3>Description</h3>

<p>This function adds a random uniform vector of the same length as the input to modify the input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dojitter(x, amount = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dojitter_+3A_x">x</code></td>
<td>
<p>a vector to be jittered (e.g. a gridpoint vector). </p>
</td></tr>
<tr><td><code id="dojitter_+3A_amount">amount</code></td>
<td>
<p>a value of how much to jitter the vector <span class="env">x</span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function creates <code>length(x)</code> samples from a uniform[<span class="env">-amount</span>,<span class="env">amount</span>], and adds these to the original vector <span class="env">x</span>. If <span class="env">amount=0</span>, the new vector <span class="env">jx</span> is the same as the original vector.
</p>


<h3>Value</h3>

<table>
<tr><td><code>jx</code></td>
<td>
<p>the jittered version of <span class="env">x</span></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight</p>


<h3>See Also</h3>

<p><code><a href="#topic+modjitter">modjitter</a></code>     </p>


<h3>Examples</h3>

<pre><code class='language-R'>#create grid vector
#
xgrid&lt;-seq(0,1,length=51)
#
xgrid
#
#a regularly-spaced grid
#
dojitter(xgrid,.01)
#
#a jittered grid.
# 
</code></pre>

<hr>
<h2 id='findadds'>Finds minimum number of inversion steps</h2><span id='topic+findadds'></span>

<h3>Description</h3>

<p>This function finds the minimum inversion steps to perform 
to fully reconstruct (a subset of) data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findadds(rem, neighbrs, po, index = 1:(length(rem) + length(po)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findadds_+3A_rem">rem</code></td>
<td>
<p>the <code>removelist</code> variable from a lifting 
decomposition.  See <code><a href="#topic+fwtnp">fwtnp</a></code>.</p>
</td></tr>
<tr><td><code id="findadds_+3A_neighbrs">neighbrs</code></td>
<td>
<p>A list of neighbour indices corresponding to lifting 
steps in a decomposition.  See <code><a href="#topic+fwtnp">fwtnp</a></code>.</p>
</td></tr>
<tr><td><code id="findadds_+3A_po">po</code></td>
<td>
<p>The <code>pointsin</code> variable in a lifting decomposition 
(the index into the unlifted datapoints). See <code><a href="#topic+fwtnp">fwtnp</a></code>.</p>
</td></tr>
<tr><td><code id="findadds_+3A_index">index</code></td>
<td>
<p>a vector of indices into the original data, indicating 
which points should be fully reconstructed during inversion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gives a computational shortcut to get datapoint 
information in certain inversion cases.  In some circumstances,when 
inverting, you might only be interested in the inverted coefficients for 
a subset of timepoints.  In this case, it is not necessary to do a full 
inversion to look at the desired coefficients;  the function uses the 
neighbourhood and removal order of the forward transform information and 
notes: 1) when the desired points were lifted (if at all) and 2) when 
the desired points were used as neighbours in prediction (if applicable).  
The number of inversion steps needed for each index individually is then 
taken as the maximum for these two conditions to be met.  Inverting the 
transform with this number will yield the correct inverted coefficient.  
Note that to get the correct coefficients for all <code>index</code>, the number of 
inversion steps is <code>max(adds)</code>.
</p>


<h3>Value</h3>

<p><code>adds</code>: a vector corresponding to <code>index</code>, each element 
of which is 
the number of inversion steps needed for that datapoint to be fully 
reconstructed.</p>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+invtnp">invtnp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create data:
x&lt;-runif(256)

f&lt;-make.signal2("bumps",x=x)

#do forward transform:
fwd&lt;-fwtnp(x,f)

#I want to invert enough so that points 1:3 are reconstructed.

adds&lt;-findadds(fwd$removelist,fwd$neighbrs,fwd$pointsin,1:3)
adds

#now reconstruct...
fhat&lt;-invtnp(fwd,f,nadd=max(adds))

#...and check that the desired points are the same:
f[1:3]
fhat[1:3]

</code></pre>

<hr>
<h2 id='fwtnp'>fwtnp</h2><span id='topic+fwtnp'></span><span id='topic+fwtnp2'></span>

<h3>Description</h3>

<p>Performs the lifting transform on a signal with grid <span class="env">input</span> and corresponding function values <span class="env">f</span>. There is a unique correspondence between the grid values and the function values. Can also cope with length vector input instead of gridpoint vector input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fwtnp(input, f, nkeep = 2, intercept = TRUE, 
initboundhandl = "reflect", neighbours = 1, closest = FALSE, 
LocalPred = LinearPred, do.W=FALSE, varonly=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fwtnp_+3A_input">input</code></td>
<td>
<p>A vector of grid values. Can be of any length, not necessarily equally spaced.</p>
</td></tr>
<tr><td><code id="fwtnp_+3A_f">f</code></td>
<td>
<p>A vector of function values corresponding to <span class="env">input</span>. Must be of the same length as <span class="env">input</span>.</p>
</td></tr>
<tr><td><code id="fwtnp_+3A_nkeep">nkeep</code></td>
<td>
<p>The number of scaling coefficients to be kept in the final representation of the initial signal. This must be at least two. </p>
</td></tr>
<tr><td><code id="fwtnp_+3A_intercept">intercept</code></td>
<td>
<p>Indicates whether or not the regression curve includes an intercept.</p>
</td></tr>
<tr><td><code id="fwtnp_+3A_initboundhandl">initboundhandl</code></td>
<td>
<p>variable specifying how to handle the boundary at the start of the transform.  Possible values are <code>"reflect"</code> - the intervals corresponding to the first and last datapoints are taken to have the respective grid values as midpoints; and <code>"stop"</code> - the first and last intervals have the first and last grid values (respectively) as outer endpoints.</p>
</td></tr>
<tr><td><code id="fwtnp_+3A_neighbours">neighbours</code></td>
<td>
<p>The number of neighbours over which the regression is performed at each step. If closest is false, then this in fact denotes the number of neighbours on each side of the removed point.</p>
</td></tr>
<tr><td><code id="fwtnp_+3A_closest">closest</code></td>
<td>
<p>Refers to the configuration of the chosen neighbours. If <span class="env">closest</span> is false, the neighbours will be chosen symmetrically around the removed point. Otherwise, the closest neighbours will be chosen.</p>
</td></tr>
<tr><td><code id="fwtnp_+3A_localpred">LocalPred</code></td>
<td>
<p>The type of regression to be performed. Possible options are <code>LinearPred</code>, <code>QuadPred</code>, <code>CubicPred</code>, <code>AdaptPred</code> and <code>AdaptNeigh</code>.</p>
</td></tr>
<tr><td><code id="fwtnp_+3A_do.w">do.W</code></td>
<td>
<p>A boolean indicating whether the transform matrix should 
be computed and returned.</p>
</td></tr>
<tr><td><code id="fwtnp_+3A_varonly">varonly</code></td>
<td>
<p>A boolean indicating whether only the coefficient 
variances should be returned (if <code>do.W=TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">n</code> points on a line, <span class="env">input</span>, each with a corresponding envf value this algorithm computes a lifting transform of the (<span class="env">input</span>,<span class="env">f</span>) data. If lengths are inputted (<span class="env">inputtype="lengths"</span>), then the gridpoints are taken to be the left endpoints of the intervals defined by the lengths inputted. 
Step One. Order the grid values so that corresponding intervals can be constructed. 
</p>
<p>Step Two. Compute &quot;integrals&quot; for each point. For each point its integral is the length of the interval associated to the gridpoint. 
</p>
<p>Step Three. Identify the point to remove as that with the smallest integral. Generally, we remove points in order of smallest to largest integral. The integrals of neighbours of removed points change at each step. 
</p>
<p>Step Four(a). The neighbours of the removed point are identified using the specified neighbour configuration. The value of <span class="env">f</span> at the removed point is predicted using the specified regression curve over the neighbours, unless an adaptive procedure is chosen. In this case, the algorithm adjusts itself. The difference between the removed point's <span class="env">f</span> value and the prediction is computed: this is the wavelet coefficient for the removed point. The difference replaces the function value in the vector coeff at the removed point's location. In this way wavelet coefficients gradually overwrite (scaling) function values in <span class="env">coeff</span>. 
</p>
<p>Step Four(b). The integrals and the scaling function values (other <span class="env">coeff</span> values) of neighbours of the removed point are updated. The values of the rest of the scaling coefficients are unaffected. 
</p>
<p>Step Five. Return to step 3 but in the identification of a point to remove the updated integrals are used. 
</p>
<p>The algorithm continues until as many points as desired are removed.  If 
<code>do.W=TRUE</code>, the predict and update lifting steps are used to 
propogate coefficient contributions to the transform matrix <code>W</code>.  
If <code>varonly=TRUE</code>, only the (detail and scaling) coefficient 
variances are returned.  After each lifting step, the 
coefficient variance is computed and the transform matrix 
row corresponding to the lifted coefficient is deleted for the 
next stage (minimal storage efficiency).  The transform matrix is not 
returned (i.e. <code>W=NULL</code>). 
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>data vector of the grid used in the transform.</p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>vector of detail and scaling coefficients in the wavelet decomposition of the signal.</p>
</td></tr>
<tr><td><code>origlengths</code></td>
<td>
<p>vector of initial interval lengths corresponding to the gridpoints.</p>
</td></tr>
<tr><td><code>lengths</code></td>
<td>
<p>vector of (updated) interval lengths at the end of the transform. This is of length <span class="env">nkeep</span>.</p>
</td></tr>
<tr><td><code>lengthsremove</code></td>
<td>
<p>vector of interval lengths corresponding to the points removed during the transform (in <span class="env">removelist</span>).</p>
</td></tr>
<tr><td><code>pointsin</code></td>
<td>
<p>indices into <span class="env">X</span> of the scaling coefficients in the wavelet decomposition. These are the indices of the <span class="env">X</span> values which remain after all points in <span class="env">removelist</span> have been predicted and removed. This has length <span class="env">nkeep</span>.</p>
</td></tr>
<tr><td><code>removelist</code></td>
<td>
<p>a vector of indices into <span class="env">X</span> of the lifted coefficients during the transform (in the order of removal).</p>
</td></tr>
<tr><td><code>neighbrs</code></td>
<td>
<p>a list of indices into <span class="env">X</span>. Each list entry gives the indices of the neighbours of the removed point used at that particular step of the transform.</p>
</td></tr>
<tr><td><code>neighbours</code></td>
<td>
<p>the user-specified number of neighbours used in the prediction step of the transform.</p>
</td></tr>
<tr><td><code>gamlist</code></td>
<td>
<p>a list of all the prediction weights used at each step of the transform.</p>
</td></tr>
<tr><td><code>alphalist</code></td>
<td>
<p>a list of the update coefficients used in the update step of the decomposition.</p>
</td></tr>
<tr><td><code>schemehist</code></td>
<td>
<p>a vector of character strings indicating the type of regression used at each step of the transform.</p>
</td></tr>
<tr><td><code>interhist</code></td>
<td>
<p>a boolean vector indicating whether or not an intercept was used in the regression curve at each step.</p>
</td></tr>
<tr><td><code>clolist</code></td>
<td>
<p>a boolean vector showing whether or not the neighbours were symmetrical <br /> (FALSE) about the removed point during the transform. This is NULL except when <code>LocalPred=AdaptNeigh</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina.Knight</p>


<h3>See Also</h3>

<p><code><a href="#topic+AdaptNeigh">AdaptNeigh</a></code>, <code><a href="#topic+AdaptPred">AdaptPred</a></code>, <code><a href="#topic+CubicPred">CubicPred</a></code>, <code><a href="#topic+fwtnpmp">fwtnpmp</a></code>, <code><a href="#topic+invtnp">invtnp</a></code>, <code><a href="#topic+LinearPred">LinearPred</a></code>, <code><a href="#topic+QuadPred">QuadPred</a></code>     </p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some one-dimensional data: 100 observations.
#
input &lt;- runif(100)
f &lt;- input^2 - 3*input
#
# Compute fwtnp function on this data
#
out &lt;- fwtnp(input,f,LocalPred=AdaptPred,neighbours=2,closest=TRUE)
#
# That's it.
#
</code></pre>

<hr>
<h2 id='fwtnpmp'>fwtnpmp</h2><span id='topic+fwtnpmp'></span>

<h3>Description</h3>

<p>Performs the lifting transform on a signal with grid <span class="env">input</span> and corresponding function values <span class="env">f</span>, where f has multiple points, that is, more than one function value for (some of) the grid values. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fwtnpmp(input, f,  nkeep = 2, intercept = TRUE,
 initboundhandl = "reflect", neighbours = 1,
 closest = FALSE, LocalPred = LinearPredmp, mpdet="ave")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fwtnpmp_+3A_input">input</code></td>
<td>
<p>A vector of grid values. Can be of any length, not necessarily equally spaced.</p>
</td></tr>
<tr><td><code id="fwtnpmp_+3A_f">f</code></td>
<td>
<p>A vector of function values corresponding to <span class="env">input</span>. Must be of the same length as <span class="env">input</span>.</p>
</td></tr>
<tr><td><code id="fwtnpmp_+3A_nkeep">nkeep</code></td>
<td>
<p>The number of scaling coefficients to be kept in the final representation of the initial signal. This must be at least two. </p>
</td></tr>
<tr><td><code id="fwtnpmp_+3A_intercept">intercept</code></td>
<td>
<p>Indicates whether or not the regression curve includes an intercept.</p>
</td></tr>
<tr><td><code id="fwtnpmp_+3A_initboundhandl">initboundhandl</code></td>
<td>
<p>variable specifying how to handle the boundary at the start of the transform.  Possible values are <code>"reflect"</code> - the intervals corresponding to the first and last datapoints are taken to have the respective grid values as midpoints; and <code>"stop"</code> - the first and last intervals have the first and last grid values (respectively) as outer endpoints.</p>
</td></tr>
<tr><td><code id="fwtnpmp_+3A_neighbours">neighbours</code></td>
<td>
<p>The number of neighbours over which the regression is performed at each step. If closest is false, then this in fact denotes the number of neighbours on each side of the removed point.</p>
</td></tr>
<tr><td><code id="fwtnpmp_+3A_closest">closest</code></td>
<td>
<p>Refers to the configuration of the chosen neighbours. If <span class="env">closest</span> is false, the neighbours will be chosen symmetrically around the removed point. Otherwise, the closest neighbours will be chosen.</p>
</td></tr>
<tr><td><code id="fwtnpmp_+3A_localpred">LocalPred</code></td>
<td>
<p>The type of regression to be performed. Possible options are <code>LinearPredmp</code>, <code>QuadPredmp</code>, <code>CubicPredmp</code>, <code>AdaptPredmp</code> and <code>AdaptNeighmp</code>.</p>
</td></tr>
<tr><td><code id="fwtnpmp_+3A_mpdet">mpdet</code></td>
<td>
<p>how the mutiple point detail coefficients are computed.  Possible values are &quot;ave&quot;, in which the multiple detail coefficients produced when performing the multiple predictions are averaged, or &quot;min&quot;, where the overall minimum detail coefficient is taken.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">n</code> points on a line, <span class="env">input</span>, with multiple <span class="env">f</span> values, this algorithm computes a lifting transform of the (<span class="env">input</span>,<span class="env">f</span>) data.
</p>
<p>Step One. Order the grid values so that corresponding intervals can be constructed, using the average function value at multiple points. 
</p>
<p>Step Two. Compute &quot;integrals&quot; for each point. For each point its integral is the length of the interval associated to the gridpoint. 
</p>
<p>Step Three. Identify the point to remove as that with the smallest integral. Generally, we remove points in order of smallest to largest integral. The integrals of neighbours of removed points change at each step. 
</p>
<p>Step Four(a). The neighbours of the removed point are identified using the specified neighbour configuration. The values of <span class="env">f</span> at the removed point are predicted using the specified regression curve over the neighbours, unless an adaptive procedure is chosen. In this case, the algorithm adjusts itself.  If the removed point has multiple point neighbours, the extra points are used in the regression.  The difference between the removed point(s) <span class="env">f</span> value and the prediction is computed: these are the wavelet coefficient for the removed point.  When the removed point is itself a multiple point, this will produce multiple detail coefficients at that point.  <span class="env">mpdet</span> says how the final detail coefficient for that point is recorded (either averaged or the minimum).  The detail replaces the function value in the vector coeff at the removed point's location. In this way wavelet coefficients gradually overwrite (scaling) function values in <span class="env">coeff</span>. 
</p>
<p>Step Four(b). The integrals and the scaling function values (other <span class="env">coeff</span> and <span class="env">coefflist</span> values) of neighbours of the removed point are updated. The values of the rest of the scaling coefficients are unaffected. 
</p>
<p>Step Five. Return to step 3 but in the identification of a point to remove the updated integrals are used. 
</p>
<p>The algorithm continues until as many points as desired are removed.    
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>data vector of the grid used in the transform.</p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>vector of detail and scaling coefficients in the wavelet decomposition of the signal.</p>
</td></tr>
<tr><td><code>coefflist</code></td>
<td>
<p>list of detail and scaling coefficients.  Should be the same as <span class="env">coeff</span>, apart from possible multiple points at the scaling function values.</p>
</td></tr>
<tr><td><code>origlengths</code></td>
<td>
<p>vector of initial interval lengths corresponding to the gridpoints.</p>
</td></tr>
<tr><td><code>lengths</code></td>
<td>
<p>vector of (updated) interval lengths at the end of the transform. This is of length <span class="env">nkeep</span>.</p>
</td></tr>
<tr><td><code>lengthsremove</code></td>
<td>
<p>vector of interval lengths corresponding to the points removed during the transform (in <span class="env">removelist</span>).</p>
</td></tr>
<tr><td><code>pointsin</code></td>
<td>
<p>indices into <span class="env">X</span> of the scaling coefficients in the wavelet decomposition. These are the indices of the <span class="env">X</span> values which remain after all points in <span class="env">removelist</span> have been predicted and removed. This has length <span class="env">nkeep</span>.</p>
</td></tr>
<tr><td><code>removelist</code></td>
<td>
<p>a vector of indices into <span class="env">X</span> of the lifted coefficients during the transform (in the order of removal).</p>
</td></tr>
<tr><td><code>neighbrs</code></td>
<td>
<p>a list of indices into <span class="env">X</span>. Each list entry gives the indices of the neighbours of the removed point used at that particular step of the transform.</p>
</td></tr>
<tr><td><code>neighbours</code></td>
<td>
<p>the user-specified number of neighbours used in the prediction step of the transform.</p>
</td></tr>
<tr><td><code>gamlist</code></td>
<td>
<p>a list of all the prediction weights used at each step of the transform.</p>
</td></tr>
<tr><td><code>alphalist</code></td>
<td>
<p>a list of the update coefficients used in the update step of the decomposition.</p>
</td></tr>
<tr><td><code>schemehist</code></td>
<td>
<p>a vector of character strings indicating the type of regression used at each step of the transform.</p>
</td></tr>
<tr><td><code>interhist</code></td>
<td>
<p>a boolean vector indicating whether or not an intercept was used in the regression curve at each step.</p>
</td></tr>
<tr><td><code>clolist</code></td>
<td>
<p>a boolean vector showing whether or not the neighbours were symmetrical <br /> (FALSE) about the removed point during the transform. This is NULL except when <code>LocalPred=AdaptNeigh</code>.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>a list desscribing the group structure (indices) of the initial function values.</p>
</td></tr>
<tr><td><code>mp</code></td>
<td>
<p>a boolean vector of which of the groups are actually multiple points.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina.Knight</p>


<h3>See Also</h3>

<p><code><a href="#topic+AdaptNeighmp">AdaptNeighmp</a></code>, <code><a href="#topic+AdaptPredmp">AdaptPredmp</a></code>, <code><a href="#topic+CubicPredmp">CubicPredmp</a></code>, <code><a href="#topic+fwtnp">fwtnp</a></code>, <code><a href="#topic+invtnpmp">invtnpmp</a></code>, <code><a href="#topic+LinearPredmp">LinearPredmp</a></code>, <code><a href="#topic+QuadPredmp">QuadPredmp</a></code>     </p>


<h3>Examples</h3>

<pre><code class='language-R'>#read in multiple point data...

data(motorcycledata)
times&lt;-motorcycledata$time
accel&lt;-motorcycledata$accel

out&lt;-fwtnpmp(times,accel,LocalPred=AdaptPredmp,neighbours=2)
out$coeff

#these are the detail coefficients of the transform.

</code></pre>

<hr>
<h2 id='getnbrs'>getnbrs</h2><span id='topic+getnbrs'></span>

<h3>Description</h3>

<p>This function uses the user's neighbourhood configuration input to find the neighbours of the lifted datapoint to be used in the prediction step of the transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getnbrs(X, remove, pointsin, neighbours, closest)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getnbrs_+3A_x">X</code></td>
<td>
<p>The vector of gridpoints.</p>
</td></tr>
<tr><td><code id="getnbrs_+3A_remove">remove</code></td>
<td>
<p>the index (into <span class="env">X</span>) of the point to be removed.</p>
</td></tr>
<tr><td><code id="getnbrs_+3A_pointsin">pointsin</code></td>
<td>
<p>The indices of gridpoints still to be removed.</p>
</td></tr>
<tr><td><code id="getnbrs_+3A_neighbours">neighbours</code></td>
<td>
<p>the number of neighbours to find for use in prediction.</p>
</td></tr>
<tr><td><code id="getnbrs_+3A_closest">closest</code></td>
<td>
<p>Boolean argument: If FALSE, the neighbours selected are the ones on both sides of the removed point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the value of <span class="env">neighbours</span> and <span class="env">closest</span> to choose the neighbours to return. If <span class="env">closest</span> is FALSE, <span class="env">pointsin</span> is used to find <span class="env">neighbours</span> indices on both sides of the index of the removed point (<span class="env">remove</span>). If <span class="env">closest</span> is TRUE, then the function uses the gridpoint vector (<span class="env">X</span>) to calculate distances from the removed point to <span class="env">neighbours</span> neighbours on each side of the removed point (if they exist) and then uses this information to choose the closest <span class="env">neighbours</span> ones, recording where they lie in relation to the removed point, and accordingly their index can be obtained. If the removed point is on the boundary, then by choice, we take only one neighbour.
</p>


<h3>Value</h3>

<table>
<tr><td><code>nbrs</code></td>
<td>
<p>the indices of the neighbours corresponding to the specified configuration.</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>the indices into <span class="env">pointsin</span> of the neighbours</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight </p>


<h3>See Also</h3>

<p><code><a href="#topic+fwtnp">fwtnp</a></code>     </p>


<h3>Examples</h3>

<pre><code class='language-R'>x1&lt;-runif(20)
#
x1
#
y1&lt;-make.signal2("bumps",x=x1)
#
y1
#
order(x1)
#
# shows where the points lie in relation to each other.
#
neigh&lt;-getnbrs(x1,3,order(x1),4,TRUE)
#
neigh$nbrs
#
# these are the indices of the 4 closest neighbours to point 3.
#
</code></pre>

<hr>
<h2 id='heterovar'>heterovar</h2><span id='topic+heterovar'></span>

<h3>Description</h3>

<p>Estimates individual wavelet coefficient variances using a sliding window approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heterovar(y, detail, al)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heterovar_+3A_y">y</code></td>
<td>
<p>a vector of the gridpoints of <span class="env">removelist</span> after executing the forward transform, in the order of the gridpoint vector.</p>
</td></tr>
<tr><td><code id="heterovar_+3A_detail">detail</code></td>
<td>
<p>the vector of detail coefficients after the forward transform has been performed, in the order of the gridpoint vector.</p>
</td></tr>
<tr><td><code id="heterovar_+3A_al">al</code></td>
<td>
<p>The list of indices into <span class="env">removelist</span> divided into artificial levels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function works out the interval endpoints for each gridpoint in <span class="env">removelist</span>, based on an initial window length of one fifth of the range of <span class="env">y</span>, and then adjusts them so that they lie within the range of <span class="env">y</span>. The indices of the <span class="env">removelist</span> points inside these intervals are then compared against the indices of the first artificial level for the data. These new indices are then used to compute the individual coefficient variances, based on the detail values of the new indices. If any of the window indices list entries contains less than four values, then the initial window length is increased by 5% and the process redone, until each window contains at least four coefficients. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>ep1</code></td>
<td>
<p>a two-column matrix with the (true) endpoints of the windows from which to calculate the coefficient variances (according to the specified window length). </p>
</td></tr>
<tr><td><code>ep2</code></td>
<td>
<p>a two-column matrix with the endpoints of the windows from which to calculate the coefficient variances (adjusted to be of the window length and within the range of <span class="env">y</span>). </p>
</td></tr>
<tr><td><code>idlist</code></td>
<td>
<p>a list of indices into <span class="env">y</span> showing the points each interval contains.</p>
</td></tr>
<tr><td><code>newidlist</code></td>
<td>
<p>a list of indices into <span class="env">y</span> showing the points each interval contains, which are also in the first artificial level.</p>
</td></tr>
<tr><td><code>dlist</code></td>
<td>
<p>a list of detail coefficients which correspond to the indices in <span class="env">newidlist</span>.</p>
</td></tr>
<tr><td><code>varvec</code></td>
<td>
<p>a vector of median absolute deviation values (from the median) for the coefficients in <span class="env">dlist</span>.</p>
</td></tr>
<tr><td><code>varvec1</code></td>
<td>
<p>a vector of median absolute deviation values (from the median), centered at zero, for the coefficients in <span class="env">dlist</span>.</p>
</td></tr>
<tr><td><code>varvec2</code></td>
<td>
<p>a vector of median absolute deviation values (from the median), centered at zero, for the coefficients in <span class="env">dlist</span>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight </p>


<h3>See Also</h3>

<p><code><a href="#topic+denoisehetero">denoisehetero</a></code>     </p>


<h3>Examples</h3>

<pre><code class='language-R'>x1&lt;-runif(256)
#
y1&lt;-make.signal2("doppler",x=x1)
#
fwd&lt;-fwtnp(x1,y1,LocalPred=AdaptNeigh,neighbours=2)
#
y&lt;-fwd$lengthsremove
rem&lt;-fwd$removelist
al&lt;-artlev(y,rem)
#
yrem&lt;-x1[sort(rem)]
detail&lt;-fwd$coeff[sort(rem)]
#
h&lt;-heterovar(yrem,detail,al)
#
h$varvec[1:10]
#
#the first ten coefficient variances to be used in the normalisation of the detail 
#coefficients
</code></pre>

<hr>
<h2 id='intervals'>intervals</h2><span id='topic+intervals'></span><span id='topic+intervals2'></span>

<h3>Description</h3>

<p>This function constructs the intervals around the grid values to be used as scaling integrals during the transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intervals(X, initboundhandl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intervals_+3A_x">X</code></td>
<td>
<p>The vector of gridpoints.</p>
</td></tr>
<tr><td><code id="intervals_+3A_initboundhandl">initboundhandl</code></td>
<td>
<p>the interval construction at the boundary. Takes the value <code>"reflect"</code> for intervals symmetric about the endpoints or <code>"stop"</code> if the endpoint intervals are limited to the edges of the dataset, i.e. the intervals end at the first and last gridpoints respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function constructs the intervals by sorting the observed gridpoints. The endpoints of the intervals are found as the midpoints between consecutive (sorted) gridpoints. In this way the intervals are not necessarily centered around the gridpoints. The first and last intervals are then modified according to <span class="env">initboundhandl</span> (see above). These intervals represent the support of the initial scaling functions associated to each gridpoint.
</p>


<h3>Value</h3>

<table>
<tr><td><code>intervals</code></td>
<td>
<p>a vector of length (<code>length(X)+1</code>) with the <span class="env">X</span> values of the endpoints of the intervals (including the edges).</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p><code>order(X)</code> (the sorted observation order).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight </p>


<h3>See Also</h3>

<p><code><a href="#topic+lengthintervals">lengthintervals</a></code>     </p>


<h3>Examples</h3>

<pre><code class='language-R'>x2&lt;-runif(50)
x2
#
intervals(x2,"reflect")
#
#check that the gridpoints are between the interval vector entries...
#
</code></pre>

<hr>
<h2 id='invtnp'>invtnp</h2><span id='topic+invtnp'></span><span id='topic+invtnp2'></span>

<h3>Description</h3>

<p>Performs the inverse lifting transform on a detail and scaling coefficient vector with grid <span class="env">X</span> and corresponding coefficients <span class="env">coeff</span>. There is a unique correspondence between the grid values and the function values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invtnp(X, coeff, lengths, lengthsremove, pointsin, removelist, 
neighbrs, schemehist, interhist, nadd = length(X) - 2, 
intercept = TRUE, neighbours = 1, closest = FALSE, LocalPred = LinearPred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invtnp_+3A_x">X</code></td>
<td>
<p>data vector of the grid used in the transform.</p>
</td></tr>
<tr><td><code id="invtnp_+3A_coeff">coeff</code></td>
<td>
<p>vector of detail and scaling coefficients in the wavelet decomposition of the signal.</p>
</td></tr>
<tr><td><code id="invtnp_+3A_lengths">lengths</code></td>
<td>
<p>vector of interval lengths to be used in the update step of the transform. This is of length <span class="env">pointsin</span>.</p>
</td></tr>
<tr><td><code id="invtnp_+3A_lengthsremove">lengthsremove</code></td>
<td>
<p>vector of interval lengths corresponding to the points removed during the forward transform.</p>
</td></tr>
<tr><td><code id="invtnp_+3A_pointsin">pointsin</code></td>
<td>
<p>indices into <span class="env">X</span> of the scaling coefficients in the wavelet decomposition.</p>
</td></tr>
<tr><td><code id="invtnp_+3A_removelist">removelist</code></td>
<td>
<p>a vector of indices into <span class="env">X</span> of the lifted coefficients during the transform (in the order of removal). </p>
</td></tr>
<tr><td><code id="invtnp_+3A_neighbrs">neighbrs</code></td>
<td>
<p>a list of indices into <span class="env">X</span>. Each list entry gives the indices of the neighbours of the removed point used at that particular step of the forward transform.</p>
</td></tr>
<tr><td><code id="invtnp_+3A_schemehist">schemehist</code></td>
<td>
<p>a vector of character strings indicating the type of regression used at each step of the forward transform. This is NULL apart from when <span class="env">AdaptNeigh</span> is to be used in the transform.</p>
</td></tr>
<tr><td><code id="invtnp_+3A_interhist">interhist</code></td>
<td>
<p>a boolean vector indicating whether or not an intercept was used in the regression curve at each step of the forward transform. This is NULL apart from when <span class="env">AdaptNeigh</span> is to be used in the transform.</p>
</td></tr>
<tr><td><code id="invtnp_+3A_nadd">nadd</code></td>
<td>
<p>The number of steps to perform of the inverse transform. This corresponds to (<code>length(X)-nkeep</code>) in the forward transform.</p>
</td></tr>
<tr><td><code id="invtnp_+3A_intercept">intercept</code></td>
<td>
<p>Boolean value for whether or not an intercept is used in the prediction step of the transform.</p>
</td></tr>
<tr><td><code id="invtnp_+3A_neighbours">neighbours</code></td>
<td>
<p>the number of neighbours in the computation of the predicted value.</p>
</td></tr>
<tr><td><code id="invtnp_+3A_closest">closest</code></td>
<td>
<p>a boolean value showing whether or not the neighbours were symmetrical (FALSE) about the removed point during the transform.</p>
</td></tr>
<tr><td><code id="invtnp_+3A_localpred">LocalPred</code></td>
<td>
<p>The type of regression to be performed. Possible options are <code>LinearPred</code>, <code>QuadPred</code>, <code>CubicPred</code>, <code>AdaptPred</code> and <code>AdaptNeigh</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm reconstructs an estimate of a function/signal from information about detail and scaling coefficients in its wavelet decomposition. 
Step One. Extract information about the first point to be added in the transform from the <b>last</b> entries in <span class="env">removelist</span>, <span class="env">lengthsremove</span> and <span class="env">neighbrs</span>. Use this information to discover the correct placement of this point in relation to the indices in <span class="env">pointsin</span>. 
</p>
<p>Step Two. Using the information about the prediction scheme used in the &quot;forward&quot; transform, use the corresponding version of <span class="env">LocalPred</span> to obtain prediction weights and value for the lifted point. 
</p>
<p>Step Three. &quot;Undo&quot; the update step of the transform, and then the prediction step of the transform. The vector of scaling and detail coefficients, as well as the interval lengths are modified accordingly. 
</p>
<p>Step Four. Remove the added point from <span class="env">removelist</span>. Update <span class="env">pointsin</span> and <span class="env">lengths</span> to contain the added point.
</p>
<p>Step Five. Return to step 1 but in the identification of the next point to add, the second to last entries in (the original) <span class="env">removelist</span>, <span class="env">lengthsremove</span> and <span class="env">neighbrs</span> are used to indentify the point and then place it in <span class="env">pointsin</span>. 
</p>
<p>The algorithm continues like this until as many points as desired are added. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>X</code></td>
<td>
<p>data vector of the grid used in the transform.</p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>vector of signal function values after inversion.</p>
</td></tr>
<tr><td><code>lengths</code></td>
<td>
<p>vector of interval lengths at the start of the transform. This should be the same as <code>intervals(X)</code>.</p>
</td></tr>
<tr><td><code>lengthsremove</code></td>
<td>
<p>vector of interval lengths corresponding to the points added during the transform.</p>
</td></tr>
<tr><td><code>pointsin</code></td>
<td>
<p>indices into <span class="env">X</span> of the scaling coefficients in the wavelet decomposition. These are the indices of the <span class="env">X</span> values which remain after all points in <span class="env">removelist</span> have been added.  For a straight forward-inverse transform implementation, this should be <code>order(X)</code>.</p>
</td></tr>
<tr><td><code>removelist</code></td>
<td>
<p>a vector of indices into <span class="env">X</span> of the lifted coefficients during the transform (in the reverse order of how they were added).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight</p>


<h3>See Also</h3>

<p><code><a href="#topic+AdaptNeigh">AdaptNeigh</a></code>, <code><a href="#topic+AdaptPred">AdaptPred</a></code>, <code><a href="#topic+CubicPred">CubicPred</a></code>, <code><a href="#topic+fwtnp">fwtnp</a></code>, <code><a href="#topic+invtnpmp">invtnpmp</a></code>, <code><a href="#topic+LinearPred">LinearPred</a></code>, <code><a href="#topic+QuadPred">QuadPred</a></code>, <code><a href="#topic+UndoPointsUpdate">UndoPointsUpdate</a></code>     </p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some one-dimensional data: 500 observations.
x2&lt;-runif(500)
f2&lt;-make.signal2("bumps",x=x2)
#
# perform the forward transform...
out&lt;-fwtnp(x2,f2,LocalPred=AdaptPred)
#
# and now invert using the information from out...
#
fhat&lt;-invtnp(x2,out$coeff,out$lengths,out$lengthsremove,out$pointsin,out$removelist,
 out$neighbrs,out$schemehist,out$interhist,LocalPred=AdaptPred)
#
# Now compare the original signal with the reconstruction.
sum(abs(f2-fhat$coeff))
# 
</code></pre>

<hr>
<h2 id='invtnpmp'>invtnpmp</h2><span id='topic+invtnpmp'></span>

<h3>Description</h3>

<p>Performs the inverse lifting transform on a detail and scaling coefficient vector with grid <span class="env">X</span> and corresponding coefficients <span class="env">coeff</span>, based on multiple point information. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invtnpmp(X, coefflist, coeff, lengths, lengthsremove, pointsin, removelist,
 neighbrs, newneighbrs, schemehist, interhist, nadd = length(X) - 2,
 intercept = TRUE, neighbours = 1, closest = FALSE, LocalPred = LinearPredmp, mpdet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invtnpmp_+3A_x">X</code></td>
<td>
<p>data vector of the grid used in the transform.</p>
</td></tr>
<tr><td><code id="invtnpmp_+3A_coefflist">coefflist</code></td>
<td>
<p>list of detail and multiple scaling coefficients.</p>
</td></tr>
<tr><td><code id="invtnpmp_+3A_coeff">coeff</code></td>
<td>
<p>vector of detail and scaling coefficients in the wavelet decomposition of the signal.</p>
</td></tr>
<tr><td><code id="invtnpmp_+3A_lengths">lengths</code></td>
<td>
<p>vector of interval lengths to be used in the update step of the transform. This is of length <span class="env">pointsin</span>.</p>
</td></tr>
<tr><td><code id="invtnpmp_+3A_lengthsremove">lengthsremove</code></td>
<td>
<p>vector of interval lengths corresponding to the points removed during the forward transform.</p>
</td></tr>
<tr><td><code id="invtnpmp_+3A_pointsin">pointsin</code></td>
<td>
<p>indices into <span class="env">X</span> of the scaling coefficients in the wavelet decomposition.</p>
</td></tr>
<tr><td><code id="invtnpmp_+3A_removelist">removelist</code></td>
<td>
<p>a vector of indices into <span class="env">X</span> of the lifted coefficients during the transform (in the order of removal). </p>
</td></tr>
<tr><td><code id="invtnpmp_+3A_neighbrs">neighbrs</code></td>
<td>
<p>a list of indices into <span class="env">X</span>. Each list entry gives the indices of the neighbours of the removed point used at that particular step of the forward transform.</p>
</td></tr>
<tr><td><code id="invtnpmp_+3A_newneighbrs">newneighbrs</code></td>
<td>
<p>a list of indices into <span class="env">X</span>. Each list entry gives the indices of the multiple neighbours of the removed point used at that particular step of the forward transform.</p>
</td></tr>
<tr><td><code id="invtnpmp_+3A_schemehist">schemehist</code></td>
<td>
<p>a vector of character strings indicating the type of regression used at each step of the forward transform. This is NULL apart from when <span class="env">AdaptNeigh</span> is to be used in the transform.</p>
</td></tr>
<tr><td><code id="invtnpmp_+3A_interhist">interhist</code></td>
<td>
<p>a boolean vector indicating whether or not an intercept was used in the regression curve at each step of the forward transform. This is NULL apart from when <span class="env">AdaptNeigh</span> is to be used in the transform.</p>
</td></tr>
<tr><td><code id="invtnpmp_+3A_nadd">nadd</code></td>
<td>
<p>The number of steps to perform of the inverse transform. This corresponds to (<code>length(X)-nkeep</code>) in the forward transform.</p>
</td></tr>
<tr><td><code id="invtnpmp_+3A_intercept">intercept</code></td>
<td>
<p>Boolean value for whether or not an intercept is used in the prediction step of the transform.</p>
</td></tr>
<tr><td><code id="invtnpmp_+3A_neighbours">neighbours</code></td>
<td>
<p>the number of neighbours in the computation of the predicted value.</p>
</td></tr>
<tr><td><code id="invtnpmp_+3A_closest">closest</code></td>
<td>
<p>a boolean value showing whether or not the neighbours were symmetrical (FALSE) about the removed point during the transform.</p>
</td></tr>
<tr><td><code id="invtnpmp_+3A_localpred">LocalPred</code></td>
<td>
<p>The type of regression to be performed. Possible options are <code>LinearPredmp</code>, <code>QuadPredmp</code>, <code>CubicPredmp</code>, <code>AdaptPredmp</code> and <code>AdaptNeighmp</code>.</p>
</td></tr>
<tr><td><code id="invtnpmp_+3A_mpdet">mpdet</code></td>
<td>
<p>how the mutiple point detail coefficients are computed.  Possible values are &quot;ave&quot;, in which the multiple detail coefficients produced when performing the multiple predictions are averaged, or &quot;min&quot;, where the overall minimum detail coefficient is taken.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm reconstructs an estimate of a function/signal from information about detail and scaling coefficients in its wavelet decomposition, using the multiple point structure information to estimate the spread of original points.
Step One.  Extract information about the first point to be added in the transform from the <b>last</b> entries in <span class="env">removelist</span>, <span class="env">lengthsremove</span> and <span class="env">neighbrs</span>. Use this information to discover the correct placement of this point in relation to the indices in <span class="env">pointsin</span>. 
</p>
<p>Step Two. Using the information about the prediction scheme used in the &quot;forward&quot; transform, use the corresponding version of <span class="env">LocalPred</span> to obtain prediction weights and value for the lifted point. 
</p>
<p>Step Three. &quot;Undo&quot; the update step of the transform, and then the prediction step of the transform. The vector of scaling and detail coefficients, as well as the interval lengths are modified accordingly. 
</p>
<p>Step Four. Remove the added point from <span class="env">removelist</span>. Update <span class="env">pointsin</span> and <span class="env">lengths</span> to contain the added point.
</p>
<p>Step Five. Return to step 1 but in the identification of the next point to add, the second to last entries in (the original) <span class="env">removelist</span>, <span class="env">lengthsremove</span> and <span class="env">neighbrs</span> are used to indentify the point and then place it in <span class="env">pointsin</span>. 
</p>
<p>The algorithm continues like this until as many points as desired are added. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>X</code></td>
<td>
<p>data vector of the grid used in the transform.</p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>vector of signal function values after inversion.</p>
</td></tr>
<tr><td><code>lengths</code></td>
<td>
<p>vector of interval lengths at the start of the transform. This should be the same as <code>intervals(X)</code>.</p>
</td></tr>
<tr><td><code>lengthsremove</code></td>
<td>
<p>vector of interval lengths corresponding to the points added during the transform.</p>
</td></tr>
<tr><td><code>pointsin</code></td>
<td>
<p>indices into <span class="env">X</span> of the scaling coefficients in the wavelet decomposition. These are the indices of the <span class="env">X</span> values which remain after all points in <span class="env">removelist</span> have been added.  For a straight forward-inverse transform implementation, this should be <code>order(X)</code>.</p>
</td></tr>
<tr><td><code>removelist</code></td>
<td>
<p>a vector of indices into <span class="env">X</span> of the lifted coefficients during the transform (in the reverse order of how they were added).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight </p>


<h3>See Also</h3>

<p><code><a href="#topic+AdaptNeighmp">AdaptNeighmp</a></code>, <code><a href="#topic+AdaptPredmp">AdaptPredmp</a></code>, <code><a href="#topic+CubicPredmp">CubicPredmp</a></code>, <code><a href="#topic+fwtnpmp">fwtnpmp</a></code>, <code><a href="#topic+invtnp">invtnp</a></code>, <code><a href="#topic+LinearPredmp">LinearPredmp</a></code>, <code><a href="#topic+QuadPredmp">QuadPredmp</a></code>, 
<code><a href="#topic+UndoPointsUpdatemp">UndoPointsUpdatemp</a></code>     </p>


<h3>Examples</h3>

<pre><code class='language-R'>#read in multiple point data...

data(motorcycledata)
times&lt;-motorcycledata$time
accel&lt;-motorcycledata$accel
shortf&lt;-adjustx(times,accel)$sepf

out&lt;-fwtnpmp(times,accel,LocalPred=CubicPredmp,neighbours=2)

inv&lt;-invtnpmp(times, out$coefflist, out$coeff, out$lengths, out$lengthsremove, out$pointsin,
out$removelist,out$neighbrs,out$newneighbrs,out$schemehist,out$interhist, neighbours = 2,
LocalPred = CubicPredmp)

sum(abs(shortf-inv$coeff)) 
</code></pre>

<hr>
<h2 id='lengthintervals'>lengthintervals</h2><span id='topic+lengthintervals'></span>

<h3>Description</h3>

<p>This function constructs the vector of interval lengths from a vector of interval endpoints.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lengthintervals(X, I, type = "midpoints", neighbours, closest)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lengthintervals_+3A_x">X</code></td>
<td>
<p>The vector of gridpoints.</p>
</td></tr>
<tr><td><code id="lengthintervals_+3A_i">I</code></td>
<td>
<p>a vector of interval endpoints. This is of length <code>length(X)+1</code>. </p>
</td></tr>
<tr><td><code id="lengthintervals_+3A_type">type</code></td>
<td>
<p>a character string, either <code>"midpoints"</code> or <code>"average"</code>, denoting the way of computing the interval lengths, if <span class="env">closest=TRUE</span>. If <code>"average"</code>, then the average neighbour distance is associated as the interval lengths to the gridpoints; otherwise the lengths are associated from the interval vector, <span class="env">I</span> in the obvious way : right endpoint - left endpoint.</p>
</td></tr>
<tr><td><code id="lengthintervals_+3A_neighbours">neighbours</code></td>
<td>
<p>the number of neighbours to be used in the prediction step of the transform. This is only used if <span class="env">closest=TRUE</span>, since it specifies how many distances to average over when <span class="env">type="average"</span>. </p>
</td></tr>
<tr><td><code id="lengthintervals_+3A_closest">closest</code></td>
<td>
<p>indicates whether the neighbourhood structure to be used in the transform is symmetrical or not. When combined with <span class="env">type="average"</span>, enables the option of average closest neighbour distance as the associated interval lengths to the gridpoints.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the interval lengths by finding the differences between the consecutive entries of the supplied interval vector <span class="env">I</span>. In the case of the choice of average closest neighbour distance interval association, the method uses the function <code>getnbrs</code> to find the initial neighbours of each gridpoint to compute the average distances. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>lengths</code></td>
<td>
<p>a vector of <code>length(X)</code> with the intervals lengths associated to the gridpoints.</p>
</td></tr>
<tr><td><code>initialnbrs</code></td>
<td>
<p>a matrix with columns <code>order(X)</code>, possibly together with the neighbour indices into <span class="env">X</span> of each gridpoint, if <span class="env">type="average"</span>.</p>
</td></tr>
<tr><td><code>initialindex</code></td>
<td>
<p>If <span class="env">closest=TRUE</span> and <span class="env">type="average"</span>, a matrix of dimension <code>length(X)</code> x <code>neighbours</code>, showing the indices into <code>order(X)</code> of the neighbours of each gridpoint. Otherwise is NULL.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight </p>


<h3>See Also</h3>

<p><code><a href="#topic+getnbrs">getnbrs</a></code>, <code><a href="#topic+intervals">intervals</a></code>     </p>


<h3>Examples</h3>

<pre><code class='language-R'>input&lt;-runif(10)
#gridpoint vector
#
I&lt;-intervals(input,"reflect")
#create the interval endpoint vector using the input
#
lengthintervals(input,I,"average",3,TRUE)
#
#computes 'intervals' based on 3 closest neighbour distance averages
#
</code></pre>

<hr>
<h2 id='LinearPred'>LinearPred</h2><span id='topic+LinearPred'></span>

<h3>Description</h3>

<p>This function performs the prediction lifting step using a linear regression curve given a configuration of neighbours.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LinearPred(pointsin, X, coeff, nbrs, remove, intercept, neighbours)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LinearPred_+3A_pointsin">pointsin</code></td>
<td>
<p>The indices of gridpoints still to be removed.</p>
</td></tr>
<tr><td><code id="LinearPred_+3A_x">X</code></td>
<td>
<p>the vector of grid values.</p>
</td></tr>
<tr><td><code id="LinearPred_+3A_coeff">coeff</code></td>
<td>
<p>the vector of detail and scaling coefficients at that step of the transform.</p>
</td></tr>
<tr><td><code id="LinearPred_+3A_nbrs">nbrs</code></td>
<td>
<p>the indices (into <span class="env">X</span>) of the neighbours to be used in the prediction step.</p>
</td></tr>
<tr><td><code id="LinearPred_+3A_remove">remove</code></td>
<td>
<p>the index (into <span class="env">X</span>) of the point to be removed.</p>
</td></tr>
<tr><td><code id="LinearPred_+3A_intercept">intercept</code></td>
<td>
<p>Boolean value for whether or not an intercept is used in the prediction step of the transform.</p>
</td></tr>
<tr><td><code id="LinearPred_+3A_neighbours">neighbours</code></td>
<td>
<p>the number of neighbours in the computation of the predicted value. This is not actually used specifically in <code>LinearPred</code>, since this is known already from <span class="env">nbrs</span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure performs linear regression using the given neighbours using an intercept if chosen. The regression coefficients (<span class="env">weights</span>) are used to predict the new function value at the removed point.   
</p>


<h3>Value</h3>

<table>
<tr><td><code>Xneigh</code></td>
<td>
<p>matrix of X values corresponding to the neighbours of the removed point. The matrix consists of the column X[nbrs] augmented with a column of ones if an intercept is used. Refer to any reference on linear regression for more details.</p>
</td></tr>
<tr><td><code>mm</code></td>
<td>
<p>the matrix from which the prediction is made. In terms of <span class="env">Xneigh</span>, it is <br /> <code class="reqn">(Xneigh^T Xneigh)^{-1} Xneigh^T</code>.</p>
</td></tr>
<tr><td><code>bhat</code></td>
<td>
<p>The regression coefficients used in prediction.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the prediction weights for the neighbours.</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>the predicted function value obtained from the regression.</p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>vector of (modified) detail and scaling coefficients to be used in the update step of the transform.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight</p>


<h3>See Also</h3>

<p><code><a href="#topic+CubicPred">CubicPred</a></code>, <code><a href="#topic+fwtnp">fwtnp</a></code>, <code><a href="#topic+QuadPred">QuadPred</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some doppler data: 500 observations.
#
tx &lt;- runif(500)
ty&lt;-make.signal2("doppler",x=tx)
#
# Compute the neighbours of point 173 (2 neighbours on each side)
#
out&lt;-getnbrs(tx,173,order(tx),2,FALSE)
#
# Perform linear regression based on the neighbours (without intercept) 
#
lp&lt;-LinearPred(order(tx),tx,ty,out$nbrs,173,FALSE,2)
#
#
lp
#
#the regression curve details

</code></pre>

<hr>
<h2 id='LinearPredmp'>LinearPredmp</h2><span id='topic+LinearPredmp'></span>

<h3>Description</h3>

<p>This function performs the prediction lifting step using a linear regression curve given a configuration of neighbours, for multiple point data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LinearPredmp(pointsin, X, coefflist, coeff, nbrs, newnbrs, remove, intercept,
 neighbours, mpdet, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LinearPredmp_+3A_pointsin">pointsin</code></td>
<td>
<p>The indices of gridpoints still to be removed.</p>
</td></tr>
<tr><td><code id="LinearPredmp_+3A_x">X</code></td>
<td>
<p>the vector of grid values.</p>
</td></tr>
<tr><td><code id="LinearPredmp_+3A_coeff">coeff</code></td>
<td>
<p>the vector of detail and scaling coefficients at that step of the transform.</p>
</td></tr>
<tr><td><code id="LinearPredmp_+3A_coefflist">coefflist</code></td>
<td>
<p>the list of detail and multiple scaling coefficients at that step of the transform.</p>
</td></tr>
<tr><td><code id="LinearPredmp_+3A_nbrs">nbrs</code></td>
<td>
<p>the indices (into <span class="env">X</span>) of the neighbours to be used in the prediction step.</p>
</td></tr>
<tr><td><code id="LinearPredmp_+3A_newnbrs">newnbrs</code></td>
<td>
<p>as nbrs, but repeated according to the multiple point structure of the grid.</p>
</td></tr>
<tr><td><code id="LinearPredmp_+3A_remove">remove</code></td>
<td>
<p>the index (into <span class="env">X</span>) of the point to be removed.</p>
</td></tr>
<tr><td><code id="LinearPredmp_+3A_intercept">intercept</code></td>
<td>
<p>Boolean value for whether or not an intercept is used in the prediction step of the transform.</p>
</td></tr>
<tr><td><code id="LinearPredmp_+3A_neighbours">neighbours</code></td>
<td>
<p>the number of neighbours in the computation of the predicted value. This is not actually used specifically in <code>LinearPredmp</code>, since this is known already from <span class="env">nbrs</span>.</p>
</td></tr>
<tr><td><code id="LinearPredmp_+3A_mpdet">mpdet</code></td>
<td>
<p>how the mutiple point detail coefficients are computed.  Possible values are &quot;ave&quot;, in which the multiple detail coefficients produced when performing the multiple predictions are averaged, or &quot;min&quot;, where the overall minimum detail coefficient is taken.  Note that this is taken to standardise the input when <span class="env">LocalPredmp</span> is called.</p>
</td></tr>
<tr><td><code id="LinearPredmp_+3A_g">g</code></td>
<td>
<p>the group structure of the multiple point data.  Note that this is taken to standardise the input when <span class="env">LocalPredmp</span> is called.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The procedure performs linear regression using the given neighbours using an intercept if chosen. The regression coefficients (<span class="env">weights</span>) are used to predict the new function value at the removed point.   
</p>


<h3>Value</h3>

<table>
<tr><td><code>Xneigh</code></td>
<td>
<p>matrix of X values corresponding to the neighbours of the removed point. The matrix consists of the column X[newnbrs] augmented with a column of ones if an intercept is used. Refer to any reference on linear regression for more details.</p>
</td></tr>
<tr><td><code>mm</code></td>
<td>
<p>the matrix from which the prediction is made. In terms of <span class="env">Xneigh</span>, it is <br /> <code class="reqn">(Xneigh^T Xneigh)^{-1} Xneigh^T </code>.</p>
</td></tr>
<tr><td><code>bhat</code></td>
<td>
<p>The regression coefficients used in prediction.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the prediction weights for the neighbours.</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>the predicted function value obtained from the regression.</p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>vector of (modified) detail and scaling coefficients to be used in the update step of the transform.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The <span class="pkg">Matrix</span> is needed for this function.</p>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight </p>


<h3>See Also</h3>

<p><code><a href="#topic+CubicPredmp">CubicPredmp</a></code>, <code><a href="#topic+fwtnpmp">fwtnpmp</a></code>, <code><a href="#topic+QuadPredmp">QuadPredmp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#read in data with multiple values...

data(motorcycledata)
times&lt;-motorcycledata$time
accel&lt;-motorcycledata$accel
short&lt;-adjustx(times,accel,"mean")
X&lt;-short$sepx
coeff&lt;-short$sepx
g&lt;-short$g

coefflist&lt;-list()
for (i in 1:length(g)){
coefflist[[i]]&lt;-accel[g[[i]]]
}

#work out neighbours of point to be removed (31)

out&lt;-getnbrs(X,31,order(X),2,TRUE)
nbrs&lt;-out$n

nbrs

newnbrs&lt;-NULL
for (i in 1:length(nbrs)){
newnbrs&lt;-c(newnbrs,rep(nbrs[i],times=length(g[[nbrs[i]]])))
}

#work out repeated neighbours using g...
newnbrs

LinearPredmp(order(X),X,coefflist,coeff,nbrs,newnbrs,31,TRUE,2,"ave",g)

</code></pre>

<hr>
<h2 id='make.signal2'>make.signal2</h2><span id='topic+make.signal2'></span>

<h3>Description</h3>

<p>This function computes signal function values based on a grid input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.signal2(name, x, snr = Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.signal2_+3A_name">name</code></td>
<td>
<p>a character string of the test signal to create.</p>
</td></tr>
<tr><td><code id="make.signal2_+3A_x">x</code></td>
<td>
<p>a vector of gridpoints.</p>
</td></tr>
<tr><td><code id="make.signal2_+3A_snr">snr</code></td>
<td>
<p>optional argument to scale the function values according 
to a signal-to-noise ratio.</p>
</td></tr>
<tr><td><code id="make.signal2_+3A_...">...</code></td>
<td>
<p>any additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on the <code>make.signal</code> function included in the <b>S-Plus wavelets</b> module, except that the <span class="env">x</span> vector can be irregular. As well as the signals included for the original version (e.g. the Donoho/Johnstone test signals), a piecewise polynomial can be sampled.
</p>


<h3>Value</h3>

<table>
<tr><td><code>z</code></td>
<td>
<p>the signal function values.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The test signals have domain [0,1], so the grid vector <span class="env">x</span> must have values within this interval.</p>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight </p>


<h3>Examples</h3>

<pre><code class='language-R'>#create grid vector
#
xgrid&lt;-rnorm(50)
xgrid
#
pp&lt;-make.signal2("ppoly",x=xgrid)
#
#piecewise polynomial data vector 
#
plot(sort(xgrid),pp[order(xgrid)],type="l")
# 
</code></pre>

<hr>
<h2 id='matcond'>matcond</h2><span id='topic+matcond'></span>

<h3>Description</h3>

<p>Works out two alternative condition numbers for the transform associated to the prediction scheme given in the arguments to the function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matcond(x, f, Pred, neigh, int, clo, keep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matcond_+3A_x">x</code></td>
<td>
<p>A vector of grid values. Can be of any length, not necessarily equally spaced.</p>
</td></tr>
<tr><td><code id="matcond_+3A_f">f</code></td>
<td>
<p>A vector of function values corresponding to <span class="env">x</span>. Must be of the same length as <span class="env">x</span>.</p>
</td></tr>
<tr><td><code id="matcond_+3A_pred">Pred</code></td>
<td>
<p>The type of regression to be performed. Possible options are <code><a href="#topic+LinearPred">LinearPred</a></code>, <code><a href="#topic+QuadPred">QuadPred</a></code>, <code><a href="#topic+CubicPred">CubicPred</a></code>, <code><a href="#topic+AdaptPred">AdaptPred</a></code> and <code><a href="#topic+AdaptNeigh">AdaptNeigh</a></code>.</p>
</td></tr>
<tr><td><code id="matcond_+3A_neigh">neigh</code></td>
<td>
<p>The number of neighbours over which the regression is performed at each step. If <span class="env">clo</span> is false, then this in fact denotes the number of neighbours on each side of the removed point.</p>
</td></tr>
<tr><td><code id="matcond_+3A_int">int</code></td>
<td>
<p>Indicates whether or not the regression curve includes an intercept.</p>
</td></tr>
<tr><td><code id="matcond_+3A_clo">clo</code></td>
<td>
<p>Refers to the configuration of the chosen neighbours. If <span class="env">clo</span> is false, the neighbours will be chosen symmetrically around the removed point. Otherwise, the closest neighbours will be chosen. </p>
</td></tr>
<tr><td><code id="matcond_+3A_keep">keep</code></td>
<td>
<p>The number of scaling coefficients to be kept in the final representation of the initial signal. This must be at least two.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the transform matrices to work out their norms and singular value decompositions.  Condition numbers are calculated by <code class="reqn">||T_j ||*||T_j^{-1} ||</code> and <code>svd$d[1]/svd$d[nrow(T_j)]</code> respectively.
</p>


<h3>Value</h3>

<table>
<tr><td><code>cno</code></td>
<td>
<p>the condition numbers for the augmented transform matrices, calculated using the Frobenius norm (see condno).</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>the condition numbers for the augmented transform matrices, calculated using the ratio between the largest to the smallest singular values in the singular value decomposition of the augmented matrices.</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>the transform matrix information for the transform (output from fwtnp).</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight </p>


<h3>See Also</h3>

<p><code><a href="#topic+condno">condno</a></code>, <code><a href="#topic+fwtnp">fwtnp</a></code>     </p>


<h3>Examples</h3>

<pre><code class='language-R'>x1&lt;-runif(256)
y1&lt;-make.signal2("doppler",x=x1)
#
m&lt;-matcond(x1,y1,AdaptNeigh,2,TRUE,TRUE,2)
#
m$cno
#
m$v
# shows the two different condition number measures for the matrix associated
# to the transform performed.
#
</code></pre>

<hr>
<h2 id='modjitter'>modjitter</h2><span id='topic+modjitter'></span>

<h3>Description</h3>

<p>This function jitters grid values by a proportion of the regular distance between consecutive gridpoints and then alters it to lie in [0,1].    
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modjitter(x, amount)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modjitter_+3A_x">x</code></td>
<td>
<p>a vector to be jittered (e.g. a gridpoint vector). </p>
</td></tr>
<tr><td><code id="modjitter_+3A_amount">amount</code></td>
<td>
<p>a value of how much to jitter the vector (expressed as a proportion of the regular gridpoint distance, d). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses dojitter to jitter the gridpoint vector by (<code>amount*d</code>) . The endpoints are fixed to be zero and one, and the corresponding <span class="env">jx</span> values to <code>x[2]</code> and <code>x[length(x)-1]</code> are randomised again in the intervals <code>[0,x[2]+amount*d]</code> and <code>[x[length(x)-1]-amount*d,1]</code> respectively.  
</p>


<h3>Value</h3>

<table>
<tr><td><code>jx</code></td>
<td>
<p>the jittered version of <span class="env">x</span></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight </p>


<h3>See Also</h3>

<p><code><a href="#topic+dojitter">dojitter</a></code>, <code><a href="#topic+make.signal2">make.signal2</a></code>    </p>


<h3>Examples</h3>

<pre><code class='language-R'>#create grid vector
#
xgrid&lt;-seq(0,1,length=51)
#
xgrid
#
#a regularly-spaced grid on [0,1]
#
modjitter(xgrid,1)
#
#jitters xgrid with a maximum change of .02, keeping endpoints of zero and one 
</code></pre>

<hr>
<h2 id='motorcycledata'>
Motorcycle data.
</h2><span id='topic+motorcycledata'></span>

<h3>Description</h3>

<p>This table gives the results of 133 simulations showing the effects of motorcycle crashes on victims heads: time after a simulated impact with motorcycles and head acceleration of a PTMO (post mortem human test object) were recorded.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(motorcycledata)</code></pre>


<h3>Format</h3>

<p>A 133 by 2 data frame.</p>


<h3>References</h3>

<p>Hardle, W. (1990) <em>Applied Nonparametric Regression</em>. Cambridge University Press.</p>

<hr>
<h2 id='PointsUpdate'>PointsUpdate</h2><span id='topic+PointsUpdate'></span><span id='topic+PointsUpdate2'></span>

<h3>Description</h3>

<p>This function performs the update lifting step using a given configuration of neighbours and boundary handling.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PointsUpdate(X, coeff, nbrs, index, remove, pointsin, weights, lengths)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PointsUpdate_+3A_x">X</code></td>
<td>
<p>the vector of grid values.</p>
</td></tr>
<tr><td><code id="PointsUpdate_+3A_coeff">coeff</code></td>
<td>
<p>the vector of detail and scaling coefficients at that step of the transform.</p>
</td></tr>
<tr><td><code id="PointsUpdate_+3A_nbrs">nbrs</code></td>
<td>
<p>the indices (into <span class="env">X</span>) of the neighbours to be used in the lifting step.</p>
</td></tr>
<tr><td><code id="PointsUpdate_+3A_index">index</code></td>
<td>
<p>the indices into <span class="env">pointsin</span> of <span class="env">nbrs</span>, the neighbours of <span class="env">remove</span>.</p>
</td></tr>
<tr><td><code id="PointsUpdate_+3A_remove">remove</code></td>
<td>
<p>the index (into <span class="env">X</span>) of the point to be removed.</p>
</td></tr>
<tr><td><code id="PointsUpdate_+3A_pointsin">pointsin</code></td>
<td>
<p>The indices of gridpoints still to be removed.</p>
</td></tr>
<tr><td><code id="PointsUpdate_+3A_weights">weights</code></td>
<td>
<p>the prediction weights obtained from the regression in the prediction step of the transform.</p>
</td></tr>
<tr><td><code id="PointsUpdate_+3A_lengths">lengths</code></td>
<td>
<p>the vector of interval lengths at the present step of the transform (to be updated).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure performs a minimum norm update lifting step. Firstly the interval lengths are updated using the coefficients obtained. Secondly, the scaling and detail coefficient vector is modified using the new interval lengths.
</p>


<h3>Value</h3>

<table>
<tr><td><code>coeff</code></td>
<td>
<p>vector of (modified) detail and scaling coefficients to be used in the next step of the transform.</p>
</td></tr>
<tr><td><code>lengths</code></td>
<td>
<p>the vector of interval lengths after the update step of the transform.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>the index into <span class="env">pointsin</span> of <span class="env">remove</span>.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>length(<span class="env">pointsin</span>).</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>The regression coefficients used in prediction.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the update weights used to update <span class="env">lengths</span> and <span class="env">coeff</span>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight</p>


<h3>See Also</h3>

<p><code><a href="#topic+AdaptNeigh">AdaptNeigh</a></code>, <code><a href="#topic+AdaptPred">AdaptPred</a></code>, <code><a href="#topic+CubicPred">CubicPred</a></code>, <code><a href="#topic+fwtnp">fwtnp</a></code>, <code><a href="#topic+LinearPred">LinearPred</a></code>, <code><a href="#topic+QuadPred">QuadPred</a></code>, <code><a href="#topic+UndoPointsUpdate">UndoPointsUpdate</a></code>      </p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some blocks data: 100 observations.
#
x &lt;- runif(100)
y &lt;-make.signal2("blocks",x=x)
#
#find initial interval lengths...
#
I&lt;-intervals(x,"reflect")
lengths&lt;-lengthintervals(x,I,neighbours=2,closest=FALSE)
#
#perform prediction step...
p&lt;-AdaptNeigh(order(x),x,y,32,5,TRUE,2)
#
#
u&lt;-PointsUpdate(x,p$results[[6]],p$newinfo[[2]],p$newinfo[[3]],5,order(x),p$results[[4]],lengths)
#
#and here are the updated coefficients...
u$coeff
# 


</code></pre>

<hr>
<h2 id='PointsUpdatemp'>PointsUpdatemp</h2><span id='topic+PointsUpdatemp'></span>

<h3>Description</h3>

<p>This function performs the update lifting step using a given configuration of neighbours and boundary handling.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PointsUpdatemp(X, coeff, nbrs, newnbrs, index, remove, pointsin, 
weights, lengths)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PointsUpdatemp_+3A_x">X</code></td>
<td>
<p>the vector of grid values.</p>
</td></tr>
<tr><td><code id="PointsUpdatemp_+3A_coeff">coeff</code></td>
<td>
<p>the vector of detail and scaling coefficients at that step of the transform.</p>
</td></tr>
<tr><td><code id="PointsUpdatemp_+3A_nbrs">nbrs</code></td>
<td>
<p>the indices (into <span class="env">X</span>) of the neighbours to be used in the lifting step.</p>
</td></tr>
<tr><td><code id="PointsUpdatemp_+3A_newnbrs">newnbrs</code></td>
<td>
<p>as nbrs, but repeated according to the multiple point structure of the grid.</p>
</td></tr>
<tr><td><code id="PointsUpdatemp_+3A_index">index</code></td>
<td>
<p>the indices into <span class="env">pointsin</span> of <span class="env">nbrs</span>, the neighbours of <span class="env">remove</span>.</p>
</td></tr>
<tr><td><code id="PointsUpdatemp_+3A_remove">remove</code></td>
<td>
<p>the index (into <span class="env">X</span>) of the point to be removed.</p>
</td></tr>
<tr><td><code id="PointsUpdatemp_+3A_pointsin">pointsin</code></td>
<td>
<p>The indices of gridpoints still to be removed.</p>
</td></tr>
<tr><td><code id="PointsUpdatemp_+3A_weights">weights</code></td>
<td>
<p>the prediction weights obtained from the regression in the prediction step of the transform.</p>
</td></tr>
<tr><td><code id="PointsUpdatemp_+3A_lengths">lengths</code></td>
<td>
<p>the vector of interval lengths at the present step of the transform (to be updated).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure performs a minimum norm update lifting step. Firstly the interval lengths are updated using the coefficients obtained. Secondly, the scaling and detail coefficient list is modified using the new interval lengths.
</p>


<h3>Value</h3>

<table>
<tr><td><code>coeff</code></td>
<td>
<p>vector of (modified) detail and scaling coefficients to be used in the next step of the transform.</p>
</td></tr>
<tr><td><code>lengths</code></td>
<td>
<p>the vector of interval lengths after the update step of the transform.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>the index into <span class="env">pointsin</span> of <span class="env">remove</span>.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>length(<span class="env">pointsin</span>).</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>The regression coefficients used in prediction.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the update weights used to update <span class="env">lengths</span> and <span class="env">coeff</span>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight </p>


<h3>See Also</h3>

<p><code><a href="#topic+AdaptNeighmp">AdaptNeighmp</a></code>, <code><a href="#topic+AdaptPredmp">AdaptPredmp</a></code>, <code><a href="#topic+CubicPredmp">CubicPredmp</a></code>, <code><a href="#topic+fwtnpmp">fwtnpmp</a></code>, <code><a href="#topic+LinearPredmp">LinearPredmp</a></code>,
<code><a href="#topic+QuadPredmp">QuadPredmp</a></code>, <code><a href="#topic+UndoPointsUpdatemp">UndoPointsUpdatemp</a></code>      </p>


<h3>Examples</h3>

<pre><code class='language-R'>#read in data with multiple values...

data(motorcycledata)
times&lt;-motorcycledata$time
accel&lt;-motorcycledata$accel

short&lt;-adjustx(times,accel,"mean")
X&lt;-short$sepx
coeff&lt;-short$sepx
g&lt;-short$g

coefflist&lt;-list()
for (i in 1:length(g)){
coefflist[[i]]&lt;-accel[g[[i]]]
}

I&lt;-intervals(X,"reflect")
lengths&lt;-lengthintervals(X,I,neighbours=2,closest=TRUE)

#work out neighbours of point to be removed (31)

out&lt;-getnbrs(X,31,order(X),2,TRUE)
nbrs&lt;-out$n

nbrs

newnbrs&lt;-NULL
for (i in 1:length(nbrs)){
newnbrs&lt;-c(newnbrs,rep(nbrs[i],times=length(g[[nbrs[i]]])))
}

#work out repeated neighbours using g...
newnbrs

p&lt;-AdaptNeighmp(order(X),X,coefflist,coeff,nbrs,newnbrs,31,TRUE,2,"ave",g)

nbrs&lt;-p$newinfo[[3]]
nbrs
newnbrs&lt;-NULL
for (i in 1:length(nbrs)){
newnbrs&lt;-c(newnbrs,rep(nbrs[i],times=length(g[[nbrs[i]]])))
}
newnbrs

coefflist[[31]]&lt;-p$results[[6]][31]

u&lt;-PointsUpdatemp(X,coefflist,p$newinfo[[2]],newnbrs,p$newinfo[[3]],31,
order(X),p$results[[4]],lengths)
#
#and here is the updated coefficient list...
u$coeff
</code></pre>

<hr>
<h2 id='postmean.cauchy'>postmean.cauchy</h2><span id='topic+postmean.cauchy'></span>

<h3>Description</h3>

<p>Posterior mean calculations for Bayesian thresholding.
</p>


<h3>Details</h3>

<p>This function replaces one in the EbayesThresh package, which perform Bayesian thresholding.  For more information, see help by Silverman (see references below).
</p>


<h3>References</h3>

<p>Johnstone, I.M. and Silverman, B.W. (2002) EbayesThresh:  R and S-PLUS software for Empirical Bayes thresholding (Submitted for publication).
</p>
<p>Johnstone, I.M. and Silverman, B.W. (2004) Needles and hay in haystacks: Empirical Bayes estimates of possibly sparse sequences.  <em>Ann. Statist.</em>, <b>32</b>, 1594&ndash;1649.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+denoise">denoise</a></code>,<code><a href="#topic+denoisehetero">denoisehetero</a></code>, <code><a href="#topic+denoiseheteromp">denoiseheteromp</a></code>, <code><a href="#topic+denoiseheteroprop">denoiseheteroprop</a></code>     </p>

<hr>
<h2 id='QuadPred'>QuadPred</h2><span id='topic+QuadPred'></span>

<h3>Description</h3>

<p>This function performs the prediction lifting step using a quadratic regression curve given a configuration of neighbours.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QuadPred(pointsin, X, coeff, nbrs, remove, intercept, neighbours)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QuadPred_+3A_pointsin">pointsin</code></td>
<td>
<p>The indices of gridpoints still to be removed.</p>
</td></tr>
<tr><td><code id="QuadPred_+3A_x">X</code></td>
<td>
<p>the vector of grid values.</p>
</td></tr>
<tr><td><code id="QuadPred_+3A_coeff">coeff</code></td>
<td>
<p>the vector of detail and scaling coefficients at that step of the transform.</p>
</td></tr>
<tr><td><code id="QuadPred_+3A_nbrs">nbrs</code></td>
<td>
<p>the indices (into <span class="env">X</span>) of the neighbours to be used in the prediction step.</p>
</td></tr>
<tr><td><code id="QuadPred_+3A_remove">remove</code></td>
<td>
<p>the index (into <span class="env">X</span>) of the point to be removed.</p>
</td></tr>
<tr><td><code id="QuadPred_+3A_intercept">intercept</code></td>
<td>
<p>Boolean value for whether or not an intercept is used in the prediction step of the transform.</p>
</td></tr>
<tr><td><code id="QuadPred_+3A_neighbours">neighbours</code></td>
<td>
<p>the number of neighbours in the computation of the predicted value. This is not actually used specifically in <code>QuadPred</code>, since this is known already from <span class="env">nbrs</span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure performs quadratic regression using the given neighbours using an intercept if chosen. The regression coefficients (<span class="env">weights</span>) are used to predict the new function value at the removed point. If there are not enough neighbours to generate a quadratic regression curve, the order of prediction is decreased down to <code>LinearPred</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Xneigh</code></td>
<td>
<p>matrix of <span class="env">X</span> values corresponding to the neighbours of the removed point. The matrix consists of columns <code class="reqn">X[nbrs],X[nbrs]^2</code>, augmented with a column of ones if an intercept is used. Refer to any reference on linear regression for more details.</p>
</td></tr>
<tr><td><code>mm</code></td>
<td>
<p>the matrix from which the prediction is made. In terms of <span class="env">Xneigh</span>, it is <br /> <code class="reqn">(Xneigh^T Xneigh)^{-1} Xneigh^T</code> .</p>
</td></tr>
<tr><td><code>bhat</code></td>
<td>
<p>The regression coefficients used in prediction.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the prediction weights for the neighbours.</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>the predicted function value obtained from the regression.</p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>vector of (modified) detail and scaling coefficients to be used in the update step of the transform.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight</p>


<h3>See Also</h3>

<p><code><a href="#topic+CubicPred">CubicPred</a></code>, <code><a href="#topic+fwtnp">fwtnp</a></code>, <code><a href="#topic+LinearPred">LinearPred</a></code>     </p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some doppler data: 500 observations.
#
tx &lt;- runif(500)
ty&lt;-make.signal2("doppler",x=tx)
#
# Compute the neighbours of point 173 (2 neighbours on each side)
#
out&lt;-getnbrs(tx,173,order(tx),2,FALSE)
#
# Perform quadratic prediction based on the neighbours (without intercept) 
#
qp&lt;-QuadPred(order(tx),tx,ty,out$nbrs,173,FALSE,2)
#
#
qp[3:5]
#
#the regression curve details
</code></pre>

<hr>
<h2 id='QuadPredmp'>QuadPredmp</h2><span id='topic+QuadPredmp'></span>

<h3>Description</h3>

<p>This function performs the prediction lifting step using a quadratic regression curve given a configuration of neighbours, for multiple point data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QuadPredmp(pointsin, X, coefflist, coeff, nbrs, newnbrs, remove, intercept,
 neighbours, mpdet, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QuadPredmp_+3A_pointsin">pointsin</code></td>
<td>
<p>The indices of gridpoints still to be removed.</p>
</td></tr>
<tr><td><code id="QuadPredmp_+3A_x">X</code></td>
<td>
<p>the vector of grid values.</p>
</td></tr>
<tr><td><code id="QuadPredmp_+3A_coeff">coeff</code></td>
<td>
<p>the vector of detail and scaling coefficients at that step of the transform.</p>
</td></tr>
<tr><td><code id="QuadPredmp_+3A_coefflist">coefflist</code></td>
<td>
<p>the list of detail and multiple scaling coefficients at that step of the transform.</p>
</td></tr>
<tr><td><code id="QuadPredmp_+3A_nbrs">nbrs</code></td>
<td>
<p>the indices (into <span class="env">X</span>) of the neighbours to be used in the prediction step.</p>
</td></tr>
<tr><td><code id="QuadPredmp_+3A_newnbrs">newnbrs</code></td>
<td>
<p>as nbrs, but repeated according to the multiple point structure of the grid.</p>
</td></tr>
<tr><td><code id="QuadPredmp_+3A_remove">remove</code></td>
<td>
<p>the index (into <span class="env">X</span>) of the point to be removed.</p>
</td></tr>
<tr><td><code id="QuadPredmp_+3A_intercept">intercept</code></td>
<td>
<p>Boolean value for whether or not an intercept is used in the prediction step of the transform.</p>
</td></tr>
<tr><td><code id="QuadPredmp_+3A_neighbours">neighbours</code></td>
<td>
<p>the number of neighbours in the computation of the predicted value. This is not actually used specifically in <code>QuadPredmp</code>, since this is known already from <span class="env">nbrs</span>.</p>
</td></tr>
<tr><td><code id="QuadPredmp_+3A_mpdet">mpdet</code></td>
<td>
<p>how the mutiple point detail coefficients are computed.  Possible values are &quot;ave&quot;, in which the multiple detail coefficients produced when performing the multiple predictions are averaged, or &quot;min&quot;, where the overall minimum detail coefficient is taken.  Note that this is taken to standardise the input when <span class="env">LocalPredmp</span> is called.</p>
</td></tr>
<tr><td><code id="QuadPredmp_+3A_g">g</code></td>
<td>
<p>the group structure of the multiple point data.  Note that this is taken to standardise the input when <span class="env">LocalPredmp</span> is called.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The procedure performs quadratic regression using the given neighbours using an intercept if chosen. The regression coefficients (<span class="env">weights</span>) are used to predict the new function value at the removed point.   
</p>


<h3>Value</h3>

<table>
<tr><td><code>Xneigh</code></td>
<td>
<p>matrix of X values corresponding to the neighbours of the removed point. The matrix consists of the column X[newnbrs] augmented with a column of ones if an intercept is used. Refer to any reference on linear regression for more details.</p>
</td></tr>
<tr><td><code>mm</code></td>
<td>
<p>the matrix from which the prediction is made. In terms of <span class="env">Xneigh</span>, it is <br /> <code class="reqn">(Xneigh^T Xneigh)^{-1} Xneigh^T </code>.</p>
</td></tr>
<tr><td><code>bhat</code></td>
<td>
<p>The regression coefficients used in prediction.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the prediction weights for the neighbours.</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>the predicted function value obtained from the regression.</p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>vector of (modified) detail and scaling coefficients to be used in the update step of the transform.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight </p>


<h3>See Also</h3>

<p><code><a href="#topic+CubicPredmp">CubicPredmp</a></code>, <code><a href="#topic+fwtnpmp">fwtnpmp</a></code>, <code><a href="#topic+LinearPredmp">LinearPredmp</a></code>     </p>


<h3>Examples</h3>

<pre><code class='language-R'>#read in data with multiple values...

data(motorcycledata)
times&lt;-motorcycledata$time
accel&lt;-motorcycledata$accel
short&lt;-adjustx(times,accel,"mean")
X&lt;-short$sepx
coeff&lt;-short$sepx
g&lt;-short$g

coefflist&lt;-list()
for (i in 1:length(g)){
coefflist[[i]]&lt;-accel[g[[i]]]
}

#work out neighbours of point to be removed (31)

out&lt;-getnbrs(X,31,order(X),2,TRUE)
nbrs&lt;-out$n

nbrs

newnbrs&lt;-NULL
for (i in 1:length(nbrs)){
newnbrs&lt;-c(newnbrs,rep(nbrs[i],times=length(g[[nbrs[i]]])))
}

#work out repeated neighbours using g...
newnbrs

QuadPredmp(order(X),X,coefflist,coeff,nbrs,newnbrs,31,TRUE,2,"ave",g)


</code></pre>

<hr>
<h2 id='Rmatsolve'>Rmatsolve</h2><span id='topic+Rmatsolve'></span>

<h3>Description</h3>

<p>This function calculates matrix inverses for symmetric matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rmatsolve(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rmatsolve_+3A_m">m</code></td>
<td>
<p>a (symmetric) matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the eigenvalue decomposition of a matrix <span class="env">m</span> to work out its inverse.  The function is used here since standard matrix inverse algorithms do not cope well with matrices which are near singular (this often happens in the regression stages of the forward transforms.
</p>


<h3>Value</h3>

<table>
<tr><td><code>inv</code></td>
<td>
<p>the matrix inverse of <span class="env">m</span>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
#create a 4x4 matrix
m&lt;-matrix(runif(16),4,4)

temp&lt;-crossprod(m)

#i.e. temp is t(m)%*%m

inv&lt;-Rmatsolve(temp)

</code></pre>

<hr>
<h2 id='transmatdual'>transmatdual</h2><span id='topic+transmatdual'></span><span id='topic+transmatdual2'></span>

<h3>Description</h3>

<p>Works out the transform matrix for a particular prediction scheme and neighbourhood structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transmatdual(x, f, Pred = AdaptNeigh, neigh = 1, int = TRUE, clo = TRUE,
 keep = 2,varonly=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transmatdual_+3A_x">x</code></td>
<td>
<p>A vector of grid values. Can be of any length, not necessarily equally spaced.</p>
</td></tr>
<tr><td><code id="transmatdual_+3A_f">f</code></td>
<td>
<p>A vector of function values corresponding to <span class="env">x</span>. Must be of the same length as <span class="env">x</span>.</p>
</td></tr>
<tr><td><code id="transmatdual_+3A_pred">Pred</code></td>
<td>
<p>The type of regression to be performed. Possible options are <code><a href="#topic+LinearPred">LinearPred</a></code>, <code><a href="#topic+QuadPred">QuadPred</a></code>, <code><a href="#topic+CubicPred">CubicPred</a></code>, <code><a href="#topic+AdaptPred">AdaptPred</a></code> and <code><a href="#topic+AdaptNeigh">AdaptNeigh</a></code>.</p>
</td></tr>
<tr><td><code id="transmatdual_+3A_neigh">neigh</code></td>
<td>
<p>The number of neighbours over which the regression is performed at each step. If <span class="env">clo</span> is false, then this in fact denotes the number of neighbours on each side of the removed point.</p>
</td></tr>
<tr><td><code id="transmatdual_+3A_int">int</code></td>
<td>
<p>Indicates whether or not the regression curve includes an intercept.</p>
</td></tr>
<tr><td><code id="transmatdual_+3A_clo">clo</code></td>
<td>
<p>Refers to the configuration of the chosen neighbours. If <span class="env">clo</span> is false, the neighbours will be chosen symmetrically around the removed point. Otherwise, the closest neighbours will be chosen.</p>
</td></tr>
<tr><td><code id="transmatdual_+3A_keep">keep</code></td>
<td>
<p>The number of scaling coefficients to be kept in the final representation of the initial signal. This must be at least two.</p>
</td></tr>
<tr><td><code id="transmatdual_+3A_varonly">varonly</code></td>
<td>
<p>A boolean variable indicating whether only the 
coefficient variances should be returned, i.e. just the diagonal of 
the transform matrix <code>Wnew</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses <code>Amatdual</code> to form the refinement matrices <code class="reqn">A_j</code>, from which the augmented matrices <code class="reqn">T_j</code> are constructed. This process is iterated, to find the transform matrix (the top level augmented matrix). The rows and columns of this matrix are then reordered to be in the order of <code>out$coeff</code>, i.e. so that the columns correspond to <code class="reqn">f_1 \dots f_n</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>out</code></td>
<td>
<p>the output from the forward transform.</p>
</td></tr>
<tr><td><code>Wnew</code></td>
<td>
<p>the matrix associated to the wavelet transform.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the original gridpoint vector. </p>
</td></tr>
</table>


<h3>Note</h3>

<p> This function has been left in the package for completeness.  However, the transform matrix is (optionally) computed within the forward lifting 
transform function <code><a href="#topic+fwtnp">fwtnp</a></code>.
</p>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight </p>


<h3>See Also</h3>

<p><code><a href="#topic+fwtnp">fwtnp</a></code>, <code><a href="#topic+Amatdual">Amatdual</a></code>     </p>


<h3>Examples</h3>

<pre><code class='language-R'>x1&lt;-runif(10)
y1&lt;-make.signal2("doppler",x=x1)
#
a&lt;-transmatdual(x1,y1,AdaptNeigh,2,TRUE,TRUE,2)
#
a$Wnew
#
#the transform matrix for this adaptive lifting scheme 

</code></pre>

<hr>
<h2 id='UndoPointsUpdate'>UndoPointsUpdate</h2><span id='topic+UndoPointsUpdate'></span><span id='topic+UndoPointsUpdate2'></span>

<h3>Description</h3>

<p>This function undoes the update lifting step in the inverse transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UndoPointsUpdate(X, coeff, nbrs, index, remove, r, N, pointsin, gamweights,
 lengths, lengthrem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UndoPointsUpdate_+3A_x">X</code></td>
<td>
<p>the vector of grid values.</p>
</td></tr>
<tr><td><code id="UndoPointsUpdate_+3A_coeff">coeff</code></td>
<td>
<p>the vector of detail and scaling coefficients at that step of the transform.</p>
</td></tr>
<tr><td><code id="UndoPointsUpdate_+3A_nbrs">nbrs</code></td>
<td>
<p>the indices (into <span class="env">X</span>) of the neighbours to be used in the lifting step.</p>
</td></tr>
<tr><td><code id="UndoPointsUpdate_+3A_index">index</code></td>
<td>
<p>the indices into <span class="env">pointsin</span> of <span class="env">nbrs</span>, the neighbours of <span class="env">remove</span>, the point to be added.</p>
</td></tr>
<tr><td><code id="UndoPointsUpdate_+3A_remove">remove</code></td>
<td>
<p>the index (into <span class="env">X</span>) of the point to be added.</p>
</td></tr>
<tr><td><code id="UndoPointsUpdate_+3A_r">r</code></td>
<td>
<p>the index into <span class="env">pointsin</span> of the added point, <span class="env">remove</span>.</p>
</td></tr>
<tr><td><code id="UndoPointsUpdate_+3A_n">N</code></td>
<td>
<p>length(<span class="env">pointsin</span>).</p>
</td></tr>
<tr><td><code id="UndoPointsUpdate_+3A_pointsin">pointsin</code></td>
<td>
<p>The indices of gridpoints still to be added.</p>
</td></tr>
<tr><td><code id="UndoPointsUpdate_+3A_gamweights">gamweights</code></td>
<td>
<p>the prediction weights obtained from the regression in the prediction step of the transform.</p>
</td></tr>
<tr><td><code id="UndoPointsUpdate_+3A_lengths">lengths</code></td>
<td>
<p>the vector of interval lengths at the present step of the transform.</p>
</td></tr>
<tr><td><code id="UndoPointsUpdate_+3A_lengthrem">lengthrem</code></td>
<td>
<p>the interval length associated to the point to be added.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This procedure uses minimum norm update coefficients to invert the update step of the transform. The prediction weights are used to change the interval lengthsm before the update weights are used to modify <span class="env">coeff</span>.   
</p>


<h3>Value</h3>

<table>
<tr><td><code>coeff</code></td>
<td>
<p>vector of (modified) detail and scaling coefficients to be used later in the transform.</p>
</td></tr>
<tr><td><code>lengths</code></td>
<td>
<p>vector of interval lengths after inverting the update step of the transform.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the weights used to modify <span class="env">lengths</span> and <span class="env">coeff</span>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight </p>


<h3>See Also</h3>

<p><code><a href="#topic+AdaptNeigh">AdaptNeigh</a></code>, <code><a href="#topic+AdaptPred">AdaptPred</a></code>, <code><a href="#topic+CubicPred">CubicPred</a></code>, <code><a href="#topic+invtnp">invtnp</a></code>, <code><a href="#topic+LinearPred">LinearPred</a></code>, <code><a href="#topic+PointsUpdate">PointsUpdate</a></code>,
<code><a href="#topic+QuadPred">QuadPred</a></code>     </p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some blocks data: 100 observations.
#
x &lt;- runif(100)
y &lt;-make.signal2("blocks",x=x)
#
#find initial interval lengths...
#
I&lt;-intervals(x,"reflect")
lengths&lt;-lengthintervals(x,I,neighbours=2,closest=FALSE)
#
#perform prediction step...
p&lt;-AdaptNeigh(order(x),x,y,32,5,TRUE,2)
#
#
u&lt;-PointsUpdate(x,p$results[[6]],p$newinfo[[2]],p$newinfo[[3]],5,order(x),p$results[[4]],
lengths)
#
p2&lt;-setdiff(order(x),5)
a&lt;-which(order(x)==5)
l2&lt;-lengths[setdiff(1:100, a)]
#
#remove the lifted coefficient
#
#now undo the update step...
#
undo&lt;-UndoPointsUpdate(x,u$coeff,p$newinfo[[2]],p$newinfo[[3]],5,a,99,p2,
p$results[[4]],l2,lengths[a])
#

</code></pre>

<hr>
<h2 id='UndoPointsUpdatemp'>UndoPointsUpdatemp</h2><span id='topic+UndoPointsUpdatemp'></span>

<h3>Description</h3>

<p>This function undoes the update lifting step in the multiple observation inverse transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UndoPointsUpdatemp(X, coeff, nbrs, newnbrs, index, remove, r, N, pointsin,
 gamweights, lengths, lengthrem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UndoPointsUpdatemp_+3A_x">X</code></td>
<td>
<p>the vector of grid values.</p>
</td></tr>
<tr><td><code id="UndoPointsUpdatemp_+3A_coeff">coeff</code></td>
<td>
<p>the vector of detail and scaling coefficients at that step of the transform.</p>
</td></tr>
<tr><td><code id="UndoPointsUpdatemp_+3A_nbrs">nbrs</code></td>
<td>
<p>the indices (into <span class="env">X</span>) of the neighbours to be used in the lifting step.</p>
</td></tr>
<tr><td><code id="UndoPointsUpdatemp_+3A_newnbrs">newnbrs</code></td>
<td>
<p>as nbrs, but repeated according to the multiple point structure of the grid.</p>
</td></tr>
<tr><td><code id="UndoPointsUpdatemp_+3A_index">index</code></td>
<td>
<p>the indices into <span class="env">pointsin</span> of <span class="env">nbrs</span>, the neighbours of <span class="env">remove</span>, the point to be added.</p>
</td></tr>
<tr><td><code id="UndoPointsUpdatemp_+3A_remove">remove</code></td>
<td>
<p>the index (into <span class="env">X</span>) of the point to be added.</p>
</td></tr>
<tr><td><code id="UndoPointsUpdatemp_+3A_r">r</code></td>
<td>
<p>the index into <span class="env">pointsin</span> of the added point, <span class="env">remove</span>.</p>
</td></tr>
<tr><td><code id="UndoPointsUpdatemp_+3A_n">N</code></td>
<td>
<p>length(<span class="env">pointsin</span>).</p>
</td></tr>
<tr><td><code id="UndoPointsUpdatemp_+3A_pointsin">pointsin</code></td>
<td>
<p>The indices of gridpoints still to be added.</p>
</td></tr>
<tr><td><code id="UndoPointsUpdatemp_+3A_gamweights">gamweights</code></td>
<td>
<p>the prediction weights obtained from the regression in the prediction step of the transform.</p>
</td></tr>
<tr><td><code id="UndoPointsUpdatemp_+3A_lengths">lengths</code></td>
<td>
<p>the vector of interval lengths at the present step of the transform.</p>
</td></tr>
<tr><td><code id="UndoPointsUpdatemp_+3A_lengthrem">lengthrem</code></td>
<td>
<p>the interval length associated to the point to be added.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This procedure uses minimum norm update coefficients to invert the update step of the transform. The prediction weights are used to change the interval lengthsm before the update weights are used to modify <span class="env">coefflist</span>.   
</p>


<h3>Value</h3>

<table>
<tr><td><code>coeff</code></td>
<td>
<p>vector of (modified) detail and scaling coefficients to be used later in the transform.</p>
</td></tr>
<tr><td><code>lengths</code></td>
<td>
<p>vector of interval lengths after inverting the update step of the transform.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the weights used to modify <span class="env">lengths</span> and <span class="env">coeff</span>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight </p>


<h3>See Also</h3>

<p><code><a href="#topic+AdaptNeighmp">AdaptNeighmp</a></code>, <code><a href="#topic+AdaptPredmp">AdaptPredmp</a></code>, <code><a href="#topic+CubicPredmp">CubicPredmp</a></code>, <code><a href="#topic+invtnpmp">invtnpmp</a></code>, <code><a href="#topic+LinearPredmp">LinearPredmp</a></code>, <code><a href="#topic+PointsUpdatemp">PointsUpdatemp</a></code>, <code><a href="#topic+QuadPredmp">QuadPredmp</a></code>     </p>


<h3>Examples</h3>

<pre><code class='language-R'>#read in data with multiple values...

data(motorcycledata)
times&lt;-motorcycledata$time
accel&lt;-motorcycledata$accel
short&lt;-adjustx(times,accel,"mean")
X&lt;-short$sepx
coeff&lt;-short$sepx
g&lt;-short$g

coefflist&lt;-list()
for (i in 1:length(g)){
coefflist[[i]]&lt;-accel[g[[i]]]
}

I&lt;-intervals(X,"reflect")
lengths&lt;-lengthintervals(X,I,neighbours=2,closest=TRUE)

#work out neighbours of point to be removed (31)

out&lt;-getnbrs(X,31,order(X),2,TRUE)
nbrs&lt;-out$n

nbrs

newnbrs&lt;-NULL
for (i in 1:length(nbrs)){
newnbrs&lt;-c(newnbrs,rep(nbrs[i],times=length(g[[nbrs[i]]])))
}

#work out repeated neighbours using g...
newnbrs

p&lt;-AdaptNeighmp(order(X),X,coefflist,coeff,nbrs,newnbrs,31,TRUE,2,"ave",g)

nbrs&lt;-p$newinfo[[3]]
newnbrs&lt;-NULL
for (i in 1:length(nbrs)){
newnbrs&lt;-c(newnbrs,rep(nbrs[i],times=length(g[[nbrs[i]]])))
}
coefflist[[31]]&lt;-p$results[[6]][31]

u&lt;-PointsUpdatemp(X,coefflist,p$newinfo[[2]],newnbrs,p$newinfo[[3]],31,order(X),p$results[[4]],
lengths)

p2&lt;-setdiff(order(X),31)
a&lt;-which(order(X)==31)
l2&lt;-lengths[setdiff(1:length(X), a)]
#
#remove the lifted coefficient
#
#now undo the update step...
#
undo&lt;-UndoPointsUpdatemp(X,coeff,newnbrs,p$newinfo[[2]],p$newinfo[[3]],31,
a,length(X)-1,p2,p$results[[4]],l2,lengths[a])
#

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
