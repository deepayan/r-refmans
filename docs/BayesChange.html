<!DOCTYPE html><html lang="en"><head><title>Help for package BayesChange</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BayesChange}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BayesChange-package'><p>BayesChange: Bayesian Methods for Change Points Analysis</p></a></li>
<li><a href='#clust_cp'><p>Clustering time dependent obsevations with common change points.</p></a></li>
<li><a href='#clust_cp_epi'><p>Clustering Epidemiological survival functions with common changes in time</p></a></li>
<li><a href='#clust_cp_multi'><p>Clustering multivariate times series with common changes in time</p></a></li>
<li><a href='#clust_cp_uni'><p>Clustering univariate times series with common changes in time</p></a></li>
<li><a href='#ClustCpObj'><p>ClustCpObj class constructor</p></a></li>
<li><a href='#detect_cp'><p>Detect change points on time series.</p></a></li>
<li><a href='#detect_cp_multi'><p>Detect Change Points on multivariate time series</p></a></li>
<li><a href='#detect_cp_uni'><p>Detect Change Points on an univariate time series.</p></a></li>
<li><a href='#DetectCpObj'><p>DetectCpObj class constructor</p></a></li>
<li><a href='#plot.ClustCpObj'><p>Plot estimated partition</p></a></li>
<li><a href='#plot.DetectCpObj'><p>Plot estimated change points</p></a></li>
<li><a href='#posterior_estimate'><p>set generic</p></a></li>
<li><a href='#posterior_estimate.ClustCpObj'><p>Estimate the change points of the data</p></a></li>
<li><a href='#posterior_estimate.DetectCpObj'><p>Estimate the change points of the data</p></a></li>
<li><a href='#print.ClustCpObj'><p>ClustCpObj print method</p></a></li>
<li><a href='#print.DetectCpObj'><p>DetectCpObj print method</p></a></li>
<li><a href='#sim_epi_data'><p>Simulate epidemiological data</p></a></li>
<li><a href='#summary.ClustCpObj'><p>ClustCpObj summary method</p></a></li>
<li><a href='#summary.DetectCpObj'><p>DetectCpObj summary method</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Bayesian Methods for Change Points Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Perform change points detection on univariate and multivariate time series according to the methods presented by Asael Fabian Martínez and Ramsés H. Mena (2014) &lt;<a href="https://doi.org/10.1214%2F14-BA878">doi:10.1214/14-BA878</a>&gt; and Corradin, Danese and Ongaro (2022) &lt;<a href="https://doi.org/10.1016%2Fj.ijar.2021.12.019">doi:10.1016/j.ijar.2021.12.019</a>&gt;. It also clusters different types of time dependent data with common change points, see "Model-based clustering of time-dependent observations with common structural changes" (Corradin,Danese,KhudaBukhsh and Ongaro, 2024) &lt;<a href="https://doi.org/10.48550%2FarXiv.2410.09552">doi:10.48550/arXiv.2410.09552</a>&gt; for details. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppGSL</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, salso, dplyr, tidyr, ggplot2, ggpubr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/lucadanese/BayesChange">https://github.com/lucadanese/BayesChange</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lucadanese/BayesChange/issues">https://github.com/lucadanese/BayesChange/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-11 20:23:47 UTC; LUCA</td>
</tr>
<tr>
<td>Author:</td>
<td>Luca Danese <a href="https://orcid.org/0000-0001-8444-8563"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph],
  Riccardo Corradin [aut],
  Andrea Ongaro [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luca Danese &lt;l.danese1@campus.unimib.it&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-12 11:20:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='BayesChange-package'>BayesChange: Bayesian Methods for Change Points Analysis</h2><span id='topic+BayesChange'></span><span id='topic+BayesChange-package'></span>

<h3>Description</h3>

<p>Perform change points detection on univariate and multivariate time series according to the methods presented by Asael Fabian Martínez and Ramsés H. Mena (2014) <a href="https://doi.org/10.1214/14-BA878">doi:10.1214/14-BA878</a> and Corradin, Danese and Ongaro (2022) <a href="https://doi.org/10.1016/j.ijar.2021.12.019">doi:10.1016/j.ijar.2021.12.019</a>. It also clusters different types of time dependent data with common change points, see &quot;Model-based clustering of time-dependent observations with common structural changes&quot; (Corradin,Danese,KhudaBukhsh and Ongaro, 2024) <a href="https://doi.org/10.48550/arXiv.2410.09552">doi:10.48550/arXiv.2410.09552</a> for details.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Luca Danese <a href="mailto:l.danese1@campus.unimib.it">l.danese1@campus.unimib.it</a> (<a href="https://orcid.org/0000-0001-8444-8563">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Riccardo Corradin
</p>
</li>
<li><p> Andrea Ongaro
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/lucadanese/BayesChange">https://github.com/lucadanese/BayesChange</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/lucadanese/BayesChange/issues">https://github.com/lucadanese/BayesChange/issues</a>
</p>
</li></ul>


<hr>
<h2 id='clust_cp'>Clustering time dependent obsevations with common change points.</h2><span id='topic+clust_cp'></span>

<h3>Description</h3>

<p>The <code>clust_cp</code> function cluster observations with common change points. Data can be time series or survival functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clust_cp(
  data,
  n_iterations,
  n_burnin = 0,
  params = list(),
  print_progress = TRUE,
  user_seed = 1234,
  kernel
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clust_cp_+3A_data">data</code></td>
<td>
<p>a vector or a matrix. If a vector the algorithm for
univariate time series is used. If a matrix, where rows are the observations
and columns are the times, then the algorithm for multivariate time series is used.</p>
</td></tr>
<tr><td><code id="clust_cp_+3A_n_iterations">n_iterations</code></td>
<td>
<p>number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="clust_cp_+3A_n_burnin">n_burnin</code></td>
<td>
<p>number of iterations that must be excluded when computing the posterior estimate.</p>
</td></tr>
<tr><td><code id="clust_cp_+3A_params">params</code></td>
<td>
<p>a list of parameters:
</p>
<p>If the time series is univariate the following must be specified:
</p>

<ul>
<li> <p><code>q</code> probability of a split in the split-merge proposal and acceleration step.
</p>
</li>
<li> <p><code>B</code> number of orders for the normalization constant.
</p>
</li>
<li> <p><code>L</code> number of split-merge steps for the proposal step.
</p>
</li>
<li> <p><code>alpha_SM</code> <code class="reqn">\alpha</code> for the split-merge proposal and acceleration step.
</p>
</li>
<li> <p><code>gamma</code>,<code>a</code>,<code>b</code>,<code>c</code> parameters of the integrated likelihood.
</p>
</li></ul>

<p>If the time series is multivariate the following must be specified:
</p>

<ul>
<li> <p><code>q</code> probability of a split in the split-merge proposal and acceleration step.
</p>
</li>
<li> <p><code>B</code> number of orders for the normalization constant.
</p>
</li>
<li> <p><code>L</code> number of split-merge steps for the proposal step.
</p>
</li>
<li> <p><code>gamma</code>,<code>k_0</code>,<code>nu_0</code>,<code>phi_0</code>,<code>m_0</code> parameters of the integrated likelihood.
</p>
</li></ul>

<p>If data are survival functions:
</p>

<ul>
<li> <p><code>q</code> probability of a split in the split-merge proposal and acceleration step.
</p>
</li>
<li> <p><code>B</code> number of orders for the normalization constant.
</p>
</li>
<li> <p><code>L</code> number of split-merge steps for the proposal step.
</p>
</li>
<li> <p><code>alpha_SM</code> <code class="reqn">\alpha</code> for the split-merge proposal and acceleration step.
</p>
</li>
<li> <p><code>M</code> number of Monte Carlo iterations when computing the likelihood of the survival function.
</p>
</li>
<li> <p><code>gamma</code> recovery rate fixed constant for each population at each time.
</p>
</li>
<li> <p><code>alpha</code> <code class="reqn">\alpha</code> for the acceptance ration in the split-merge procedure.
</p>
</li>
<li> <p><code>dt</code>,<code>a0</code>,<code>b0</code>,<code>c0</code>,<code>d0</code> parameters for the computation of the integrated likelihood of the survival functions.
</p>
</li>
<li> <p><code>MH_var</code> variance for the Metropolis-Hastings estimation of the proportion of infected at time 0.
</p>
</li>
<li> <p><code>S0</code>,<code>R0</code> parameters for the SDE solver.
</p>
</li>
<li> <p><code>p</code> prior average number of change points for each order.
</p>
</li></ul>
</td></tr>
<tr><td><code id="clust_cp_+3A_print_progress">print_progress</code></td>
<td>
<p>If TRUE (default) print the progress bar.</p>
</td></tr>
<tr><td><code id="clust_cp_+3A_user_seed">user_seed</code></td>
<td>
<p>seed for random distribution generation.</p>
</td></tr>
<tr><td><code id="clust_cp_+3A_kernel">kernel</code></td>
<td>
<p>can be &quot;ts&quot; if data are time series or &quot;epi&quot; if data are survival functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ClustCpObj</code> class object containing
</p>

<ul>
<li> <p><code>$data</code> vector or matrix with the data.
</p>
</li>
<li> <p><code>$n_iterations</code> number of iterations.
</p>
</li>
<li> <p><code>$n_burnin</code> number of burn-in iterations.
</p>
</li>
<li> <p><code>$clust</code> a matrix where each row corresponds to the output cluster of the corresponding iteration.
</p>
</li>
<li> <p><code>$orders</code> a multidimensional array where each slice is a matrix and represent an iteration. The row of each matrix correspond the order associated to the corresponding cluster.
</p>
</li>
<li> <p><code>$time</code> computational time.
</p>
</li>
<li> <p><code>$lkl</code> a matrix where each row is the likelihood of each observation computed at the corresponding iteration.
</p>
</li>
<li> <p><code>$norm_vec</code> a vector containing the normalisation constant computed at the beginning of the algorithm.
</p>
</li>
<li> <p><code>$rho</code> a vector with the final estimate of the proportion of infected individuals at time 0.
</p>
</li>
<li> <p><code>$kernel_ts</code> if TRUE data are time series.
</p>
</li>
<li> <p><code>$kernel_epi</code> if TRUE data are survival function.
</p>
</li>
<li> <p><code>$univariate_ts</code> TRUE if data is an univariate time series, FALSE if it is a multivariate time series.
</p>
</li></ul>



<h3>References</h3>

<p>Corradin, R., Danese, L., KhudaBukhsh, W. R., &amp; Ongaro, A. (2024). <em>Model-based clustering of time-dependent observations with common structural changes</em>. arXiv preprint arXiv:2410.09552.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Univariate time series

data_mat &lt;- matrix(NA, nrow = 5, ncol = 100)

data_mat[1,] &lt;- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
data_mat[2,] &lt;- as.numeric(c(rnorm(50,0,0.125), rnorm(50,1,0.225)))
data_mat[3,] &lt;- as.numeric(c(rnorm(50,0,0.175), rnorm(50,1,0.280)))
data_mat[4,] &lt;- as.numeric(c(rnorm(25,0,0.135), rnorm(75,1,0.225)))
data_mat[5,] &lt;- as.numeric(c(rnorm(25,0,0.155), rnorm(75,1,0.280)))

out &lt;- clust_cp(data = data_mat, n_iterations = 5000, n_burnin = 1000,
                params = list(L = 1, B = 1000, gamma = 0.5), kernel = "ts")

print(out)

## Multivariate time series


data_array &lt;- array(data = NA, dim = c(3,100,5))

data_array[1,,1] &lt;- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
data_array[2,,1] &lt;- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
data_array[3,,1] &lt;- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))

data_array[1,,2] &lt;- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
data_array[2,,2] &lt;- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
data_array[3,,2] &lt;- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))

data_array[1,,3] &lt;- as.numeric(c(rnorm(50,0,0.175), rnorm(50,1,0.280)))
data_array[2,,3] &lt;- as.numeric(c(rnorm(50,0,0.175), rnorm(50,1,0.280)))
data_array[3,,3] &lt;- as.numeric(c(rnorm(50,0,0.175), rnorm(50,1,0.280)))

data_array[1,,4] &lt;- as.numeric(c(rnorm(25,0,0.135), rnorm(75,1,0.225)))
data_array[2,,4] &lt;- as.numeric(c(rnorm(25,0,0.135), rnorm(75,1,0.225)))
data_array[3,,4] &lt;- as.numeric(c(rnorm(25,0,0.135), rnorm(75,1,0.225)))

data_array[1,,5] &lt;- as.numeric(c(rnorm(25,0,0.155), rnorm(75,1,0.280)))
data_array[2,,5] &lt;- as.numeric(c(rnorm(25,0,0.155), rnorm(75,1,0.280)))
data_array[3,,5] &lt;- as.numeric(c(rnorm(25,0,0.155), rnorm(75,1,0.280)))

out &lt;- clust_cp(data = data_array, n_iterations = 3000, n_burnin = 1000,
                params = list(B = 1000, L = 1, gamma = 0.5, k_0 = 0.25,
                              nu_0 = 5, phi_0 = diag(0.1,3,3),
                              m_0 = rep(0,3)), kernel = "ts")

print(out)

## Epidemiological data



data_mat &lt;- matrix(NA, nrow = 5, ncol = 50)

betas &lt;- list(c(rep(0.45, 25),rep(0.14,25)),
              c(rep(0.55, 25),rep(0.11,25)),
              c(rep(0.50, 25),rep(0.12,25)),
              c(rep(0.52, 10),rep(0.15,40)),
              c(rep(0.53, 10),rep(0.13,40)))

inf_times &lt;- list()

for(i in 1:5){

  inf_times[[i]] &lt;- sim_epi_data(10000, 10, 50, betas[[i]], 1/8)

  vec &lt;- rep(0,50)
  names(vec) &lt;- as.character(1:50)

  for(j in 1:50){
    if(as.character(j) %in% names(table(floor(inf_times[[i]])))){
      vec[j] = table(floor(inf_times[[i]]))[which(names(table(floor(inf_times[[i]]))) == j)]
    }
  }
  data_mat[i,] &lt;- vec
}

out &lt;- clust_cp(data = data_mat, n_iterations = 100, n_burnin = 10,
                params = list(M = 100, L = 1, B = 1000), kernel = "epi")

print(out)


</code></pre>

<hr>
<h2 id='clust_cp_epi'>Clustering Epidemiological survival functions with common changes in time</h2><span id='topic+clust_cp_epi'></span>

<h3>Description</h3>

<p>Clustering Epidemiological survival functions with common changes in time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clust_cp_epi(
  data,
  n_iterations,
  M,
  B,
  L,
  gamma = 1/8,
  alpha = 1,
  q = 0.1,
  dt = 0.1,
  a0 = 4,
  b0 = 10,
  c0 = 1,
  d0 = 1,
  MH_var = 0.01,
  S0 = 1,
  R0 = 0,
  p = 0.003,
  print_progress = TRUE,
  user_seed = 1234L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clust_cp_epi_+3A_data">data</code></td>
<td>
<p>a matrix where each entry is the number of infected for a population (row) at a specific discrete time (column).</p>
</td></tr>
<tr><td><code id="clust_cp_epi_+3A_n_iterations">n_iterations</code></td>
<td>
<p>Second value</p>
</td></tr>
<tr><td><code id="clust_cp_epi_+3A_m">M</code></td>
<td>
<p>number of Monte Carlo iterations when computing the likelihood of the survival function.</p>
</td></tr>
<tr><td><code id="clust_cp_epi_+3A_b">B</code></td>
<td>
<p>number of orders for the normalisation constant.</p>
</td></tr>
<tr><td><code id="clust_cp_epi_+3A_l">L</code></td>
<td>
<p>number of split-merge steps for the proposal step.</p>
</td></tr>
<tr><td><code id="clust_cp_epi_+3A_gamma">gamma</code></td>
<td>
<p>recovery rate fixed constant for each population at each time.</p>
</td></tr>
<tr><td><code id="clust_cp_epi_+3A_alpha">alpha</code></td>
<td>
<p><code class="reqn">\alpha</code> for the acceptance ration in the split-merge procedure.</p>
</td></tr>
<tr><td><code id="clust_cp_epi_+3A_q">q</code></td>
<td>
<p>probability of performing a split when updating the single order for the proposal procedure.</p>
</td></tr>
<tr><td><code id="clust_cp_epi_+3A_dt">dt</code>, <code id="clust_cp_epi_+3A_a0">a0</code>, <code id="clust_cp_epi_+3A_b0">b0</code>, <code id="clust_cp_epi_+3A_c0">c0</code>, <code id="clust_cp_epi_+3A_d0">d0</code></td>
<td>
<p>parameters for the computation of the integrated likelihood of the survival functions.</p>
</td></tr>
<tr><td><code id="clust_cp_epi_+3A_mh_var">MH_var</code></td>
<td>
<p>variance for the Metropolis-Hastings estimation of the proportion of infected at time 0.</p>
</td></tr>
<tr><td><code id="clust_cp_epi_+3A_s0">S0</code>, <code id="clust_cp_epi_+3A_r0">R0</code></td>
<td>
<p>parameters for the SDE solver.</p>
</td></tr>
<tr><td><code id="clust_cp_epi_+3A_p">p</code></td>
<td>
<p>prior average number of change points for each order.</p>
</td></tr>
<tr><td><code id="clust_cp_epi_+3A_print_progress">print_progress</code></td>
<td>
<p>If TRUE (default) print the progress bar.</p>
</td></tr>
<tr><td><code id="clust_cp_epi_+3A_user_seed">user_seed</code></td>
<td>
<p>seed for random distribution generation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>clust_cp_epi</code> returns a list containing the following components: </p>

<ul>
<li><p><code>$clust</code> a matrix where each row corresponds to the output cluster of the corresponding iteration.
</p>
</li>
<li><p><code>$orders</code> a multidimensional matrix where each slice is a matrix with the orders associated to the output cluster of that iteration.
</p>
</li>
<li><p><code>time</code> computational time in seconds.
</p>
</li>
<li><p><code>$llik</code> a matrix containing the log-likelihood of each population at each iteration.
</p>
</li>
<li><p><code>$rho</code> traceplot for the proportion of infected individuals at time 0.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data_mat &lt;- matrix(NA, nrow = 5, ncol = 50)

betas &lt;- list(c(rep(0.45, 25),rep(0.14,25)),
              c(rep(0.55, 25),rep(0.11,25)),
              c(rep(0.50, 25),rep(0.12,25)),
              c(rep(0.52, 10),rep(0.15,40)),
              c(rep(0.53, 10),rep(0.13,40)))

 inf_times &lt;- list()

 for(i in 1:5){

   inf_times[[i]] &lt;- sim_epi_data(10000, 10, 50, betas[[i]], 1/8)

   vec &lt;- rep(0,50)
   names(vec) &lt;- as.character(1:50)

   for(j in 1:50){
     if(as.character(j) %in% names(table(floor(inf_times[[i]])))){
       vec[j] = table(floor(inf_times[[i]]))[which(names(table(floor(inf_times[[i]]))) == j)]
     }
   }
   data_mat[i,] &lt;- vec
 }

 out &lt;- clust_cp_epi(data = data_mat, n_iterations = 3000, M = 250, B = 1000, L = 1)


</code></pre>

<hr>
<h2 id='clust_cp_multi'>Clustering multivariate times series with common changes in time</h2><span id='topic+clust_cp_multi'></span>

<h3>Description</h3>

<p>Clustering multivariate times series with common changes in time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clust_cp_multi(
  data,
  n_iterations,
  B,
  L,
  gamma,
  k_0,
  nu_0,
  phi_0,
  m_0,
  q = 0.5,
  alpha_SM = 0.1,
  print_progress = TRUE,
  user_seed = 1234L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clust_cp_multi_+3A_data">data</code></td>
<td>
<p>a multidimensional matrix where each element is a matrix whose rows are the observations and columns the dimensions.</p>
</td></tr>
<tr><td><code id="clust_cp_multi_+3A_n_iterations">n_iterations</code></td>
<td>
<p>number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="clust_cp_multi_+3A_b">B</code></td>
<td>
<p>number of orders for the normalisation constant.</p>
</td></tr>
<tr><td><code id="clust_cp_multi_+3A_l">L</code></td>
<td>
<p>number of split-merge steps for the proposal step.</p>
</td></tr>
<tr><td><code id="clust_cp_multi_+3A_gamma">gamma</code>, <code id="clust_cp_multi_+3A_k_0">k_0</code>, <code id="clust_cp_multi_+3A_nu_0">nu_0</code>, <code id="clust_cp_multi_+3A_phi_0">phi_0</code>, <code id="clust_cp_multi_+3A_m_0">m_0</code></td>
<td>
<p>parameters of the integrated likelihood.</p>
</td></tr>
<tr><td><code id="clust_cp_multi_+3A_q">q</code></td>
<td>
<p>probability of a split in the split-merge proposal and acceleration step.</p>
</td></tr>
<tr><td><code id="clust_cp_multi_+3A_alpha_sm">alpha_SM</code></td>
<td>
<p><code class="reqn">\alpha</code> for the split-merge proposal and acceleration step.</p>
</td></tr>
<tr><td><code id="clust_cp_multi_+3A_print_progress">print_progress</code></td>
<td>
<p>If TRUE (default) print the progress bar.</p>
</td></tr>
<tr><td><code id="clust_cp_multi_+3A_user_seed">user_seed</code></td>
<td>
<p>seed for random distribution generation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>clust_cp_multi</code> returns a list containing the following components: </p>

<ul>
<li><p><code>$clust</code> a matrix where each row corresponds to the output cluster of the corresponding iteration.
</p>
</li>
<li><p><code>$orders</code> a multidimensional array where each slice is a matrix and represent an iteration. The row of each matrix correspond the order associated to the corresponding cluster.
</p>
</li>
<li><p><code>time</code> computational time in seconds.
</p>
</li>
<li><p><code>$norm_vec</code> a vector containing the normalisation constant computed at the beginning of the algorithm.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data_array &lt;- array(data = NA, dim = c(3,100,5))

data_array[1,,1] &lt;- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
data_array[2,,1] &lt;- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
data_array[3,,1] &lt;- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))

data_array[1,,2] &lt;- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
data_array[2,,2] &lt;- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
data_array[3,,2] &lt;- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))

data_array[1,,3] &lt;- as.numeric(c(rnorm(50,0,0.175), rnorm(50,1,0.280)))
data_array[2,,3] &lt;- as.numeric(c(rnorm(50,0,0.175), rnorm(50,1,0.280)))
data_array[3,,3] &lt;- as.numeric(c(rnorm(50,0,0.175), rnorm(50,1,0.280)))

data_array[1,,4] &lt;- as.numeric(c(rnorm(25,0,0.135), rnorm(75,1,0.225)))
data_array[2,,4] &lt;- as.numeric(c(rnorm(25,0,0.135), rnorm(75,1,0.225)))
data_array[3,,4] &lt;- as.numeric(c(rnorm(25,0,0.135), rnorm(75,1,0.225)))

data_array[1,,5] &lt;- as.numeric(c(rnorm(25,0,0.155), rnorm(75,1,0.280)))
data_array[2,,5] &lt;- as.numeric(c(rnorm(25,0,0.155), rnorm(75,1,0.280)))
data_array[3,,5] &lt;- as.numeric(c(rnorm(25,0,0.155), rnorm(75,1,0.280)))

out &lt;- clust_cp_multi(data = data_array, n_iterations = 3000, B = 1000, L = 1,
                        gamma = 0.1, k_0 = 0.25, nu_0 = 5, phi_0 = diag(0.1,3,3), m_0 = rep(0,3))

</code></pre>

<hr>
<h2 id='clust_cp_uni'>Clustering univariate times series with common changes in time</h2><span id='topic+clust_cp_uni'></span>

<h3>Description</h3>

<p>Clustering univariate times series with common changes in time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clust_cp_uni(
  data,
  n_iterations,
  B,
  L,
  gamma,
  a = 1,
  b = 1,
  c = 1,
  q = 0.5,
  alpha_SM = 0.1,
  print_progress = TRUE,
  user_seed = 1234L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clust_cp_uni_+3A_data">data</code></td>
<td>
<p>a matrix where each row is an observation and each column corresponds to a discrete time.</p>
</td></tr>
<tr><td><code id="clust_cp_uni_+3A_n_iterations">n_iterations</code></td>
<td>
<p>number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="clust_cp_uni_+3A_b">B</code></td>
<td>
<p>number of orders for the normalisation constant.</p>
</td></tr>
<tr><td><code id="clust_cp_uni_+3A_l">L</code></td>
<td>
<p>number of split-merge steps for the proposal step.</p>
</td></tr>
<tr><td><code id="clust_cp_uni_+3A_gamma">gamma</code>, <code id="clust_cp_uni_+3A_a">a</code>, <code id="clust_cp_uni_+3A_b">b</code>, <code id="clust_cp_uni_+3A_c">c</code></td>
<td>
<p>parameters <code class="reqn">\gamma</code> of the integrated likelihood.</p>
</td></tr>
<tr><td><code id="clust_cp_uni_+3A_q">q</code></td>
<td>
<p>probability of a split in the split-merge proposal and acceleration step.</p>
</td></tr>
<tr><td><code id="clust_cp_uni_+3A_alpha_sm">alpha_SM</code></td>
<td>
<p><code class="reqn">\alpha</code> for the split-merge proposal and acceleration step.</p>
</td></tr>
<tr><td><code id="clust_cp_uni_+3A_print_progress">print_progress</code></td>
<td>
<p>If TRUE (default) print the progress bar.</p>
</td></tr>
<tr><td><code id="clust_cp_uni_+3A_user_seed">user_seed</code></td>
<td>
<p>seed for random distribution generation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>clust_cp_uni</code> returns a list containing the following components: </p>

<ul>
<li><p><code>$clust</code> a matrix where each row corresponds to the output cluster of the corresponding iteration.
</p>
</li>
<li><p><code>$orders</code> a multidimensional array where each slice is a matrix and represent an iteration. The row of each matrix correspond the order associated to the corresponding cluster.
</p>
</li>
<li><p><code>$time</code> computational time in seconds.
</p>
</li>
<li><p><code>$norm_vec</code> a vector containing the normalisation constant computed at the beginning of the algorithm.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data_mat &lt;- matrix(NA, nrow = 5, ncol = 100)

data_mat[1,] &lt;- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
data_mat[2,] &lt;- as.numeric(c(rnorm(50,0,0.125), rnorm(50,1,0.225)))
data_mat[3,] &lt;- as.numeric(c(rnorm(50,0,0.175), rnorm(50,1,0.280)))
data_mat[4,] &lt;- as.numeric(c(rnorm(25,0,0.135), rnorm(75,1,0.225)))
data_mat[5,] &lt;- as.numeric(c(rnorm(25,0,0.155), rnorm(75,1,0.280)))

out &lt;- clust_cp_uni(data = data_mat, n_iterations = 5000, B = 1000, L = 1, gamma = 0.5)

</code></pre>

<hr>
<h2 id='ClustCpObj'>ClustCpObj class constructor</h2><span id='topic+ClustCpObj'></span>

<h3>Description</h3>

<p>A constructor for the <code>ClustCpObj</code> class. The class <code>ClustCpObj</code> contains...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClustCpObj(
  data = NULL,
  n_iterations = NULL,
  n_burnin = NULL,
  clust = NULL,
  orders = NULL,
  time = NULL,
  lkl = NULL,
  norm_vec = NULL,
  rho = NULL,
  kernel_ts = NULL,
  kernel_epi = NULL,
  univariate_ts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ClustCpObj_+3A_data">data</code></td>
<td>
<p>a vector or a matrix containing the values of the time series;</p>
</td></tr>
<tr><td><code id="ClustCpObj_+3A_n_iterations">n_iterations</code></td>
<td>
<p>number of iterations of the MCMC algorithm;</p>
</td></tr>
<tr><td><code id="ClustCpObj_+3A_n_burnin">n_burnin</code></td>
<td>
<p>number of MCMC iterations to exclude in the posterior estimate;</p>
</td></tr>
<tr><td><code id="ClustCpObj_+3A_clust">clust</code></td>
<td>
<p>a matrix with the clustering of each iteration.</p>
</td></tr>
<tr><td><code id="ClustCpObj_+3A_orders">orders</code></td>
<td>
<p>a matrix where each row corresponds to the output order of the corresponding iteration;</p>
</td></tr>
<tr><td><code id="ClustCpObj_+3A_time">time</code></td>
<td>
<p>computational time in seconds;</p>
</td></tr>
<tr><td><code id="ClustCpObj_+3A_lkl">lkl</code></td>
<td>
<p>a vector with the likelihood of the final clustering.</p>
</td></tr>
<tr><td><code id="ClustCpObj_+3A_norm_vec">norm_vec</code></td>
<td>
<p>a vector with the estimated normalization constant.</p>
</td></tr>
<tr><td><code id="ClustCpObj_+3A_rho">rho</code></td>
<td>
<p>a vector with the estimated proportion of infected individuals for each observation.</p>
</td></tr>
<tr><td><code id="ClustCpObj_+3A_kernel_ts">kernel_ts</code></td>
<td>
<p>if TRUE data are time series.</p>
</td></tr>
<tr><td><code id="ClustCpObj_+3A_kernel_epi">kernel_epi</code></td>
<td>
<p>if TRUE data are survival functions.</p>
</td></tr>
<tr><td><code id="ClustCpObj_+3A_univariate_ts">univariate_ts</code></td>
<td>
<p>TRUE/FALSE if time series is univariate or not;</p>
</td></tr>
</table>

<hr>
<h2 id='detect_cp'>Detect change points on time series.</h2><span id='topic+detect_cp'></span>

<h3>Description</h3>

<p>The <code>detect_cp</code> function detect change points on univariate and multivariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_cp(
  data,
  n_iterations,
  n_burnin = 0,
  params = list(),
  print_progress = TRUE,
  user_seed = 1234
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detect_cp_+3A_data">data</code></td>
<td>
<p>a vector or a matrix. If a vector the algorithm for
univariate time series is used. If a matrix, where rows are the observations
and columns are the times, then the algorithm for multivariate time series is used.</p>
</td></tr>
<tr><td><code id="detect_cp_+3A_n_iterations">n_iterations</code></td>
<td>
<p>number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="detect_cp_+3A_n_burnin">n_burnin</code></td>
<td>
<p>number of iterations that must be excluded when computing the posterior estimate.</p>
</td></tr>
<tr><td><code id="detect_cp_+3A_params">params</code></td>
<td>
<p>a list of parameters:
</p>
<p>If the time series is univariate the following must be specified:
</p>

<ul>
<li> <p><code>q</code> probability of performing a split at each iteration.
</p>
</li>
<li> <p><code>phi</code> parameter <code class="reqn">\phi</code> of the integrated likelihood function.
</p>
</li>
<li> <p><code>a</code>, <code>b</code>, <code>c</code> parameters of the Normal-Gamma prior for <code class="reqn">\mu</code> and <code class="reqn">\lambda</code>.
</p>
</li>
<li> <p><code>par_theta_c</code>, <code>par_theta_d</code> parameters of the shifted Gamma prior for <code class="reqn">\theta</code>.
</p>
</li></ul>

<p>If the time series is multivariate the following must be specified:
</p>

<ul>
<li> <p><code>q</code> probability of performing a split at each iteration.
</p>
</li>
<li> <p><code>k_0</code>, <code>nu_0</code>, <code>phi_0</code>, <code>m_0</code> parameters for the Normal-Inverse-Wishart prior for <code class="reqn">(\mu,\lambda)</code>.
</p>
</li>
<li> <p><code>par_theta_c</code>, <code>par_theta_d</code> parameters for the shifted Gamma prior for <code class="reqn">\theta</code>.
</p>
</li>
<li> <p><code>prior_var_gamma</code> parameters for the Gamma prior for <code class="reqn">\gamma</code>.
</p>
</li>
<li> <p><code>print_progress</code> If TRUE (default) print the progress bar.
</p>
</li>
<li> <p><code>user_seed</code> seed for random distribution generation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="detect_cp_+3A_print_progress">print_progress</code></td>
<td>
<p>If TRUE (default) print the progress bar.</p>
</td></tr>
<tr><td><code id="detect_cp_+3A_user_seed">user_seed</code></td>
<td>
<p>seed for random distribution generation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>DetectCpObj</code> class object containing
</p>

<ul>
<li> <p><code>$data</code> vector or matrix with the data.
</p>
</li>
<li> <p><code>$n_iterations</code> number of iterations.
</p>
</li>
<li> <p><code>$n_burnin</code> number of burn-in iterations.
</p>
</li>
<li> <p><code>$orders</code> matrix where each entries is the assignment of the realization to a block. Rows are the iterations and columns the times.
</p>
</li>
<li> <p><code>$time</code> computational time.
</p>
</li>
<li> <p><code>$gammaMCMC</code> traceplot for <code class="reqn">\gamma</code>.
</p>
</li>
<li> <p><code>$gamma_MCMC_01</code> a <code class="reqn">0/1</code> vector, the <code class="reqn">n</code>-th element is equal to <code class="reqn">1</code> if the proposed <code class="reqn">\gamma</code> was accepted, <code class="reqn">0</code> otherwise.
</p>
</li>
<li> <p><code>$sigma_MCMC</code> traceplot for <code class="reqn">\sigma</code>.
</p>
</li>
<li> <p><code>$sigma_MCMC_01</code> a <code class="reqn">0/1</code> vector, the <code class="reqn">n</code>-th element is equal to <code class="reqn">1</code> if the proposed <code class="reqn">\sigma</code> was accepted, <code class="reqn">0</code> otherwise.
</p>
</li>
<li> <p><code>$theta_MCMC</code> traceplot for <code class="reqn">\theta</code>.
</p>
</li>
<li> <p><code>$univariate_ts</code> TRUE if data is an univariate time series, FALSE if it is a multivariate time series.
</p>
</li></ul>



<h3>References</h3>

<p>Martínez, A. F., &amp; Mena, R. H. (2014). On a Nonparametric Change Point Detection Model in Markovian Regimes. <em>Bayesian Analysis</em>, 9(4), 823–858. <a href="https://doi.org/10.1214/14-BA878">doi:10.1214/14-BA878</a>
</p>
<p>Corradin, R., Danese, L., &amp; Ongaro, A. (2022). Bayesian nonparametric change point detection for multivariate time series with missing observations. <em>International Journal of Approximate Reasoning</em>, 143, 26&ndash;43. <a href="https://doi.org/10.1016/j.ijar.2021.12.019">doi:10.1016/j.ijar.2021.12.019</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Univariate time series

data_vec &lt;- as.numeric(c(rnorm(50,0,0.1), rnorm(50,1,0.25)))


out &lt;- detect_cp(data = data_vec, n_iterations = 2500, n_burnin = 500,
                 params = list(q = 0.25, phi = 0.1, a = 1, b = 1, c = 0.1))

print(out)

## Multivariate time series

data_mat &lt;- matrix(NA, nrow = 3, ncol = 100)

data_mat[1,] &lt;- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
data_mat[2,] &lt;- as.numeric(c(rnorm(50,0,0.125), rnorm(50,1,0.225)))
data_mat[3,] &lt;- as.numeric(c(rnorm(50,0,0.175), rnorm(50,1,0.280)))


out &lt;- detect_cp(data = data_mat, n_iterations = 2500, n_burnin = 500,
                 params = list(q = 0.25, k_0 = 0.25, nu_0 = 4, phi_0 = diag(1,3,3), m_0 = rep(0,3),
                               par_theta_c = 2, par_theta_d = 0.2, prior_var_gamma = 0.1))

print(out)

</code></pre>

<hr>
<h2 id='detect_cp_multi'>Detect Change Points on multivariate time series</h2><span id='topic+detect_cp_multi'></span>

<h3>Description</h3>

<p>Detect Change Points on multivariate time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_cp_multi(
  data,
  n_iterations,
  q,
  k_0,
  nu_0,
  phi_0,
  m_0,
  par_theta_c = 1,
  par_theta_d = 1,
  prior_var_gamma = 0.1,
  print_progress = TRUE,
  user_seed = 1234L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detect_cp_multi_+3A_data">data</code></td>
<td>
<p>a matrix where each row is a component of the time series and the columns correpospond to the times.</p>
</td></tr>
<tr><td><code id="detect_cp_multi_+3A_n_iterations">n_iterations</code></td>
<td>
<p>number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="detect_cp_multi_+3A_q">q</code></td>
<td>
<p>probability of performing a split at each iteration.</p>
</td></tr>
<tr><td><code id="detect_cp_multi_+3A_k_0">k_0</code>, <code id="detect_cp_multi_+3A_nu_0">nu_0</code>, <code id="detect_cp_multi_+3A_phi_0">phi_0</code>, <code id="detect_cp_multi_+3A_m_0">m_0</code></td>
<td>
<p>parameters for the Normal-Inverse-Wishart prior for <code class="reqn">(\mu,\lambda)</code>.</p>
</td></tr>
<tr><td><code id="detect_cp_multi_+3A_par_theta_c">par_theta_c</code>, <code id="detect_cp_multi_+3A_par_theta_d">par_theta_d</code></td>
<td>
<p>parameters for the shifted Gamma prior for <code class="reqn">\theta</code>.</p>
</td></tr>
<tr><td><code id="detect_cp_multi_+3A_prior_var_gamma">prior_var_gamma</code></td>
<td>
<p>parameters for the Gamma prior for <code class="reqn">\gamma</code>.</p>
</td></tr>
<tr><td><code id="detect_cp_multi_+3A_print_progress">print_progress</code></td>
<td>
<p>If TRUE (default) print the progress bar.</p>
</td></tr>
<tr><td><code id="detect_cp_multi_+3A_user_seed">user_seed</code></td>
<td>
<p>seed for random distribution generation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>detect_cp_multi</code> returns a list containing the following components: </p>

<ul>
<li><p><code>$orders</code> a matrix where each row corresponds to the output order of the corresponding iteration.
</p>
</li>
<li><p><code>time</code> computational time in seconds.
</p>
</li>
<li><p><code>$gamma_MCMC</code> traceplot for <code class="reqn">\gamma</code>.
</p>
</li>
<li><p><code>$gamma_MCMC_01</code> a <code class="reqn">0/1</code> vector, the <code class="reqn">n</code>-th element is equal to <code class="reqn">1</code> if the proposed <code class="reqn">\gamma</code> was accepted, <code class="reqn">0</code> otherwise.
</p>
</li>
<li><p><code>$sigma_MCMC</code> traceplot for <code class="reqn">\sigma</code>.
</p>
</li>
<li><p><code>$sigma_MCMC_01</code> a <code class="reqn">0/1</code> vector, the <code class="reqn">n</code>-th element is equal to <code class="reqn">1</code> if the proposed <code class="reqn">\sigma</code> was accepted, <code class="reqn">0</code> otherwise.
</p>
</li>
<li><p><code>$theta_MCMC</code> traceplot for <code class="reqn">\theta</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data_mat &lt;- matrix(NA, nrow = 3, ncol = 100)

data_mat[1,] &lt;- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
data_mat[2,] &lt;- as.numeric(c(rnorm(50,0,0.125), rnorm(50,1,0.225)))
data_mat[3,] &lt;- as.numeric(c(rnorm(50,0,0.175), rnorm(50,1,0.280)))

out &lt;- detect_cp_multi(data = data_mat,
                              n_iterations = 2500,
                              q = 0.25,k_0 = 0.25, nu_0 = 4, phi_0 = diag(1,3,3), m_0 = rep(0,3),
                              par_theta_c = 2, par_theta_d = 0.2, prior_var_gamma = 0.1)


</code></pre>

<hr>
<h2 id='detect_cp_uni'>Detect Change Points on an univariate time series.</h2><span id='topic+detect_cp_uni'></span>

<h3>Description</h3>

<p>Detect Change Points on an univariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_cp_uni(
  data,
  n_iterations,
  q,
  phi,
  a,
  b,
  c,
  par_theta_c = 1,
  par_theta_d = 1,
  print_progress = TRUE,
  user_seed = 1234L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detect_cp_uni_+3A_data">data</code></td>
<td>
<p>vector of observations.</p>
</td></tr>
<tr><td><code id="detect_cp_uni_+3A_n_iterations">n_iterations</code></td>
<td>
<p>number of MCMC iteration.</p>
</td></tr>
<tr><td><code id="detect_cp_uni_+3A_q">q</code></td>
<td>
<p>probability of performing a split at each iterations.</p>
</td></tr>
<tr><td><code id="detect_cp_uni_+3A_phi">phi</code></td>
<td>
<p>parameter <code class="reqn">\phi</code> of the integrated likelihood function.</p>
</td></tr>
<tr><td><code id="detect_cp_uni_+3A_a">a</code>, <code id="detect_cp_uni_+3A_b">b</code>, <code id="detect_cp_uni_+3A_c">c</code></td>
<td>
<p>parameters of the Normal-Gamma prior for <code class="reqn">\mu</code> and <code class="reqn">\lambda</code>.</p>
</td></tr>
<tr><td><code id="detect_cp_uni_+3A_par_theta_c">par_theta_c</code>, <code id="detect_cp_uni_+3A_par_theta_d">par_theta_d</code></td>
<td>
<p>parameters of the shifted Gamma prior for <code class="reqn">\theta</code>.</p>
</td></tr>
<tr><td><code id="detect_cp_uni_+3A_print_progress">print_progress</code></td>
<td>
<p>If TRUE (default) print the progress bar.</p>
</td></tr>
<tr><td><code id="detect_cp_uni_+3A_user_seed">user_seed</code></td>
<td>
<p>seed for random distribution generation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>detect_cp_uni</code> returns a list containing the following components: </p>

<ul>
<li><p><code>$orders</code> a matrix where each row corresponds to the output order of the corresponding iteration.
</p>
</li>
<li><p><code>time</code> computational time in seconds.
</p>
</li>
<li><p><code>$sigma_MCMC</code> traceplot for <code class="reqn">\sigma</code>.
</p>
</li>
<li><p><code>$sigma_MCMC_01</code> a <code class="reqn">0/1</code> vector, the <code class="reqn">n</code>-th element is equal to <code class="reqn">1</code> if the proposed <code class="reqn">\sigma</code> was accepted, <code class="reqn">0</code> otherwise.
</p>
</li>
<li><p><code>$theta_MCMC</code> traceplot for <code class="reqn">\theta</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data_vec &lt;- as.numeric(c(rnorm(50,0,0.1), rnorm(50,1,0.25)))

out &lt;- detect_cp_uni(data = data_vec,
                            n_iterations = 2500,
                            q = 0.25,
                            phi = 0.1, a = 1, b = 1, c = 0.1)


</code></pre>

<hr>
<h2 id='DetectCpObj'>DetectCpObj class constructor</h2><span id='topic+DetectCpObj'></span>

<h3>Description</h3>

<p>A constructor for the <code>DetectCpObj</code> class. The class <code>DetectCpObj</code> contains...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DetectCpObj(
  data = NULL,
  n_iterations = NULL,
  n_burnin = NULL,
  orders = NULL,
  time = NULL,
  gamma_MCMC = NULL,
  gamma_MCMC_01 = NULL,
  sigma_MCMC = NULL,
  sigma_MCMC_01 = NULL,
  theta_MCMC = NULL,
  univariate_ts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DetectCpObj_+3A_data">data</code></td>
<td>
<p>a vector or a matrix containing the values of the time series;</p>
</td></tr>
<tr><td><code id="DetectCpObj_+3A_n_iterations">n_iterations</code></td>
<td>
<p>number of iterations of the MCMC algorithm;</p>
</td></tr>
<tr><td><code id="DetectCpObj_+3A_n_burnin">n_burnin</code></td>
<td>
<p>number of MCMC iterations to exclude in the posterior estimate;</p>
</td></tr>
<tr><td><code id="DetectCpObj_+3A_orders">orders</code></td>
<td>
<p>a matrix where each row corresponds to the output order of the corresponding iteration;</p>
</td></tr>
<tr><td><code id="DetectCpObj_+3A_time">time</code></td>
<td>
<p>computational time in seconds;</p>
</td></tr>
<tr><td><code id="DetectCpObj_+3A_gamma_mcmc">gamma_MCMC</code></td>
<td>
<p>traceplot for <code class="reqn">\gamma</code>;</p>
</td></tr>
<tr><td><code id="DetectCpObj_+3A_gamma_mcmc_01">gamma_MCMC_01</code></td>
<td>
<p>a <code class="reqn">0/1</code> vector, the <code class="reqn">n</code>-th element is equal to <code class="reqn">1</code> if the proposed <code class="reqn">\gamma</code> was accepted, <code class="reqn">0</code> otherwise;</p>
</td></tr>
<tr><td><code id="DetectCpObj_+3A_sigma_mcmc">sigma_MCMC</code></td>
<td>
<p>traceplot for <code class="reqn">\sigma</code>;</p>
</td></tr>
<tr><td><code id="DetectCpObj_+3A_sigma_mcmc_01">sigma_MCMC_01</code></td>
<td>
<p>a <code class="reqn">0/1</code> vector, the <code class="reqn">n</code>-th element is equal to <code class="reqn">1</code> if the proposed <code class="reqn">\sigma</code> was accepted, <code class="reqn">0</code> otherwise;</p>
</td></tr>
<tr><td><code id="DetectCpObj_+3A_theta_mcmc">theta_MCMC</code></td>
<td>
<p>traceplot for <code class="reqn">\theta</code>;</p>
</td></tr>
<tr><td><code id="DetectCpObj_+3A_univariate_ts">univariate_ts</code></td>
<td>
<p>TRUE/FALSE if time series is univariate or not;</p>
</td></tr>
</table>

<hr>
<h2 id='plot.ClustCpObj'>Plot estimated partition</h2><span id='topic+plot.ClustCpObj'></span>

<h3>Description</h3>

<p>The <code>plot</code> method plots the estimates partition through the salso algorithm, for a <code>ClustCpObj</code> class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ClustCpObj'
plot(
  x,
  y = NULL,
  loss = "VI",
  maxNClusters = 0,
  nRuns = 16,
  maxZealousAttempts = 10,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ClustCpObj_+3A_x">x</code></td>
<td>
<p>an object of class <code>ClustCpObj</code>.</p>
</td></tr>
<tr><td><code id="plot.ClustCpObj_+3A_y">y</code></td>
<td>
<p>parameter of the generic method.</p>
</td></tr>
<tr><td><code id="plot.ClustCpObj_+3A_loss">loss</code></td>
<td>
<p>The loss function used to estimate the final partition, it can be &quot;VI&quot;, &quot;binder&quot;, &quot;omARI&quot;, &quot;NVI&quot;, &quot;ID&quot;, &quot;NID&quot;.</p>
</td></tr>
<tr><td><code id="plot.ClustCpObj_+3A_maxnclusters">maxNClusters</code></td>
<td>
<p>maximum number of clusters in salso procedure.</p>
</td></tr>
<tr><td><code id="plot.ClustCpObj_+3A_nruns">nRuns</code></td>
<td>
<p>number of runs in salso procedure.</p>
</td></tr>
<tr><td><code id="plot.ClustCpObj_+3A_maxzealousattempts">maxZealousAttempts</code></td>
<td>
<p>maximum number of zealous attempts in salso procedure.</p>
</td></tr>
<tr><td><code id="plot.ClustCpObj_+3A_...">...</code></td>
<td>
<p>parameter of the generic method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a ggplot object representing the time series or the survival functions colored according to the final partition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Time series

data_mat &lt;- matrix(NA, nrow = 5, ncol = 100)

data_mat[1,] &lt;- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
data_mat[2,] &lt;- as.numeric(c(rnorm(50,0,0.125), rnorm(50,1,0.225)))
data_mat[3,] &lt;- as.numeric(c(rnorm(50,0,0.175), rnorm(50,1,0.280)))
data_mat[4,] &lt;- as.numeric(c(rnorm(25,0,0.135), rnorm(75,1,0.225)))
data_mat[5,] &lt;- as.numeric(c(rnorm(25,0,0.155), rnorm(75,1,0.280)))

out &lt;- clust_cp(data = data_mat, n_iterations = 5000, n_burnin = 1000,
                params = list(L = 1, B = 1000, gamma = 0.5), kernel = "ts")

plot(out)


## Survival functions

data_mat &lt;- matrix(NA, nrow = 5, ncol = 50)

betas &lt;- list(c(rep(0.45, 25),rep(0.14,25)),
              c(rep(0.55, 25),rep(0.11,25)),
              c(rep(0.50, 25),rep(0.12,25)),
              c(rep(0.52, 10),rep(0.15,40)),
              c(rep(0.53, 10),rep(0.13,40)))

inf_times &lt;- list()

for(i in 1:5){
  inf_times[[i]] &lt;- sim_epi_data(10000, 10, 50, betas[[i]], 1/8)
  vec &lt;- rep(0,50)
  names(vec) &lt;- as.character(1:50)
  for(j in 1:50){
    if(as.character(j) %in% names(table(floor(inf_times[[i]])))){
      vec[j] = table(floor(inf_times[[i]]))[which(names(table(floor(inf_times[[i]]))) == j)]
    }
  }
  data_mat[i,] &lt;- vec
}

out &lt;- clust_cp(data = data_mat, n_iterations = 100, n_burnin = 10,
                params = list(M = 100, L = 1, B = 100), kernel = "epi")

plot(out)


</code></pre>

<hr>
<h2 id='plot.DetectCpObj'>Plot estimated change points</h2><span id='topic+plot.DetectCpObj'></span>

<h3>Description</h3>

<p>The <code>plot</code> method plots the estimates change points estimated through the salso algorithm, for a <code>DetectCpObj</code> class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DetectCpObj'
plot(
  x,
  y = NULL,
  plot_freq = FALSE,
  loss = "VI",
  maxNClusters = 0,
  nRuns = 16,
  maxZealousAttempts = 10,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.DetectCpObj_+3A_x">x</code></td>
<td>
<p>an object of class <code>DetectCPObj</code>.</p>
</td></tr>
<tr><td><code id="plot.DetectCpObj_+3A_y">y</code>, <code id="plot.DetectCpObj_+3A_...">...</code></td>
<td>
<p>parameters of the generic method.</p>
</td></tr>
<tr><td><code id="plot.DetectCpObj_+3A_plot_freq">plot_freq</code></td>
<td>
<p>if TRUE also the histogram with the empirical frequency of each change point is plotted.</p>
</td></tr>
<tr><td><code id="plot.DetectCpObj_+3A_loss">loss</code></td>
<td>
<p>The loss function used to estimate the final partition, it can be &quot;VI&quot;, &quot;binder&quot;, &quot;omARI&quot;, &quot;NVI&quot;, &quot;ID&quot;, &quot;NID&quot;.</p>
</td></tr>
<tr><td><code id="plot.DetectCpObj_+3A_maxnclusters">maxNClusters</code></td>
<td>
<p>maximum number of clusters in salso procedure.</p>
</td></tr>
<tr><td><code id="plot.DetectCpObj_+3A_nruns">nRuns</code></td>
<td>
<p>number of runs in salso procedure.</p>
</td></tr>
<tr><td><code id="plot.DetectCpObj_+3A_maxzealousattempts">maxZealousAttempts</code></td>
<td>
<p>maximum number of zealous attempts in salso procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a ggplot object representing the detected change points. If <code>plot_freq = TRUE</code> is plotted also an histogram with the frequency of times that a change point has been detected in the MCMC chain.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data_mat &lt;- matrix(NA, nrow = 3, ncol = 100)

data_mat[1,] &lt;- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
data_mat[2,] &lt;- as.numeric(c(rnorm(50,0,0.125), rnorm(50,1,0.225)))
data_mat[3,] &lt;- as.numeric(c(rnorm(50,0,0.175), rnorm(50,1,0.280)))

out &lt;- detect_cp(data = data_mat, n_iterations = 2500, n_burnin = 500,
                 params = list(q = 0.25, k_0 = 0.25, nu_0 = 4, phi_0 = diag(1,3,3),
                               m_0 = rep(0,3), par_theta_c = 2, par_theta_d = 0.2,
                               prior_var_gamma = 0.1))
plot(out)



</code></pre>

<hr>
<h2 id='posterior_estimate'>set generic</h2><span id='topic+posterior_estimate'></span>

<h3>Description</h3>

<p>set generic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_estimate(object, ...)
</code></pre>

<hr>
<h2 id='posterior_estimate.ClustCpObj'>Estimate the change points of the data</h2><span id='topic+posterior_estimate.ClustCpObj'></span>

<h3>Description</h3>

<p>The <code>posterior_estimate</code> method estimates the change points of the data making use of the salso algorithm, for a <code>DetectCPObj</code> class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ClustCpObj'
posterior_estimate(
  object,
  loss = "VI",
  maxNClusters = 0,
  nRuns = 16,
  maxZealousAttempts = 10,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior_estimate.ClustCpObj_+3A_object">object</code></td>
<td>
<p>an object of class <code>ClustCpObj</code>.</p>
</td></tr>
<tr><td><code id="posterior_estimate.ClustCpObj_+3A_loss">loss</code></td>
<td>
<p>The loss function used to estimate the final partition, it can be &quot;VI&quot;, &quot;binder&quot;, &quot;omARI&quot;, &quot;NVI&quot;, &quot;ID&quot;, &quot;NID&quot;.</p>
</td></tr>
<tr><td><code id="posterior_estimate.ClustCpObj_+3A_maxnclusters">maxNClusters</code></td>
<td>
<p>maximum number of clusters in salso procedure.</p>
</td></tr>
<tr><td><code id="posterior_estimate.ClustCpObj_+3A_nruns">nRuns</code></td>
<td>
<p>number of runs in salso procedure.</p>
</td></tr>
<tr><td><code id="posterior_estimate.ClustCpObj_+3A_maxzealousattempts">maxZealousAttempts</code></td>
<td>
<p>maximum number of zealous attempts in salso procedure.</p>
</td></tr>
<tr><td><code id="posterior_estimate.ClustCpObj_+3A_...">...</code></td>
<td>
<p>parameter of the generic method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>put details here
</p>


<h3>Value</h3>

<p>The function returns a vector with the cluster assignment of each observation.
</p>


<h3>References</h3>

<p>#' D. B. Dahl, D. J. Johnson, and P. Müller (2022), Search Algorithms and Loss
Functions for Bayesian Clustering, <em>Journal of Computational and
Graphical Statistics</em>, 31(4), 1189-1201, <a href="https://doi.org/10.1080/10618600.2022.2069779">doi:10.1080/10618600.2022.2069779</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data_mat &lt;- matrix(NA, nrow = 5, ncol = 100)

data_mat[1,] &lt;- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
data_mat[2,] &lt;- as.numeric(c(rnorm(50,0,0.125), rnorm(50,1,0.225)))
data_mat[3,] &lt;- as.numeric(c(rnorm(50,0,0.175), rnorm(50,1,0.280)))
data_mat[4,] &lt;- as.numeric(c(rnorm(25,0,0.135), rnorm(75,1,0.225)))
data_mat[5,] &lt;- as.numeric(c(rnorm(25,0,0.155), rnorm(75,1,0.280)))

out &lt;- clust_cp(data = data_mat, n_iterations = 5000, n_burnin = 1000,
                params = list(L = 1, B = 1000, gamma = 0.5), kernel = "ts")

posterior_estimate(out)

</code></pre>

<hr>
<h2 id='posterior_estimate.DetectCpObj'>Estimate the change points of the data</h2><span id='topic+posterior_estimate.DetectCpObj'></span>

<h3>Description</h3>

<p>The <code>posterior_estimate</code> method estimates the change points of the data making use of the salso algorithm, for a <code>DetectCPObj</code> class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DetectCpObj'
posterior_estimate(
  object,
  loss = "VI",
  maxNClusters = 0,
  nRuns = 16,
  maxZealousAttempts = 10,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior_estimate.DetectCpObj_+3A_object">object</code></td>
<td>
<p>an object of class <code>DetectCPObj</code>.</p>
</td></tr>
<tr><td><code id="posterior_estimate.DetectCpObj_+3A_loss">loss</code></td>
<td>
<p>The loss function used to estimate the final partition, it can be &quot;VI&quot;, &quot;binder&quot;, &quot;omARI&quot;, &quot;NVI&quot;, &quot;ID&quot;, &quot;NID&quot;.</p>
</td></tr>
<tr><td><code id="posterior_estimate.DetectCpObj_+3A_maxnclusters">maxNClusters</code></td>
<td>
<p>maximum number of clusters in salso procedure.</p>
</td></tr>
<tr><td><code id="posterior_estimate.DetectCpObj_+3A_nruns">nRuns</code></td>
<td>
<p>number of runs in salso procedure.</p>
</td></tr>
<tr><td><code id="posterior_estimate.DetectCpObj_+3A_maxzealousattempts">maxZealousAttempts</code></td>
<td>
<p>maximum number of zealous attempts in salso procedure.</p>
</td></tr>
<tr><td><code id="posterior_estimate.DetectCpObj_+3A_...">...</code></td>
<td>
<p>parameter of the generic method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>put details here
</p>


<h3>Value</h3>

<p>The function returns a vector with the cluster assignment of each observation.
</p>


<h3>References</h3>

<p>D. B. Dahl, D. J. Johnson, and P. Müller (2022), Search Algorithms and Loss
Functions for Bayesian Clustering, <em>Journal of Computational and
Graphical Statistics</em>, 31(4), 1189-1201, <a href="https://doi.org/10.1080/10618600.2022.2069779">doi:10.1080/10618600.2022.2069779</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data_vec &lt;- as.numeric(c(rnorm(50,0,0.1), rnorm(50,1,0.25)))


out &lt;- detect_cp(data = data_vec, n_iterations = 2500, n_burnin = 500,
                 params = list(q = 0.25, phi = 0.1, a = 1, b = 1, c = 0.1))

posterior_estimate(out)

</code></pre>

<hr>
<h2 id='print.ClustCpObj'>ClustCpObj print method</h2><span id='topic+print.ClustCpObj'></span>

<h3>Description</h3>

<p>The <code>ClustCpObj</code> method prints which algorithm was run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ClustCpObj'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ClustCpObj_+3A_x">x</code></td>
<td>
<p>an object of class <code>ClustCpObj</code>.</p>
</td></tr>
<tr><td><code id="print.ClustCpObj_+3A_...">...</code></td>
<td>
<p>parameter of the generic method.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data_mat &lt;- matrix(NA, nrow = 5, ncol = 100)

data_mat[1,] &lt;- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
data_mat[2,] &lt;- as.numeric(c(rnorm(50,0,0.125), rnorm(50,1,0.225)))
data_mat[3,] &lt;- as.numeric(c(rnorm(50,0,0.175), rnorm(50,1,0.280)))
data_mat[4,] &lt;- as.numeric(c(rnorm(25,0,0.135), rnorm(75,1,0.225)))
data_mat[5,] &lt;- as.numeric(c(rnorm(25,0,0.155), rnorm(75,1,0.280)))

out &lt;- clust_cp(data = data_mat, n_iterations = 5000, n_burnin = 1000,
                params = list(L = 1, B = 1000, gamma = 0.5), kernel = "ts")

print(out)

</code></pre>

<hr>
<h2 id='print.DetectCpObj'>DetectCpObj print method</h2><span id='topic+print.DetectCpObj'></span>

<h3>Description</h3>

<p>The <code>DetectCpObj</code> method prints which algorithm was run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DetectCpObj'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.DetectCpObj_+3A_x">x</code></td>
<td>
<p>an object of class <code>DetectCpObj</code>.</p>
</td></tr>
<tr><td><code id="print.DetectCpObj_+3A_...">...</code></td>
<td>
<p>parameter of the generic method.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data_mat &lt;- matrix(NA, nrow = 3, ncol = 100)

data_mat[1,] &lt;- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
data_mat[2,] &lt;- as.numeric(c(rnorm(50,0,0.125), rnorm(50,1,0.225)))
data_mat[3,] &lt;- as.numeric(c(rnorm(50,0,0.175), rnorm(50,1,0.280)))

out &lt;- detect_cp(data = data_mat, n_iterations = 2500, n_burnin = 500,
                params = list(q = 0.25, k_0 = 0.25, nu_0 = 4, phi_0 = diag(1,3,3), m_0 = rep(0,3),
                              par_theta_c = 2, par_theta_d = 0.2, prior_var_gamma = 0.1))
print(out)

</code></pre>

<hr>
<h2 id='sim_epi_data'>Simulate epidemiological data</h2><span id='topic+sim_epi_data'></span>

<h3>Description</h3>

<p>Simulate epidemiological data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_epi_data(S0, I0, max_time, beta_vec, gamma_0, user_seed = 1234L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_epi_data_+3A_s0">S0</code></td>
<td>
<p>number of individuals in the population.</p>
</td></tr>
<tr><td><code id="sim_epi_data_+3A_i0">I0</code></td>
<td>
<p>number of infected individuals at time 0.</p>
</td></tr>
<tr><td><code id="sim_epi_data_+3A_max_time">max_time</code></td>
<td>
<p>maximum observed time.</p>
</td></tr>
<tr><td><code id="sim_epi_data_+3A_beta_vec">beta_vec</code></td>
<td>
<p>vector with the infection rate for each discrete time.</p>
</td></tr>
<tr><td><code id="sim_epi_data_+3A_gamma_0">gamma_0</code></td>
<td>
<p>the recovery rate. for the population, must be in <code class="reqn">(0,1)</code>.</p>
</td></tr>
<tr><td><code id="sim_epi_data_+3A_user_seed">user_seed</code></td>
<td>
<p>seed for random distribution generation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>sim_epi_data</code> returns a vector with the simulated infection times.
</p>

<hr>
<h2 id='summary.ClustCpObj'>ClustCpObj summary method</h2><span id='topic+summary.ClustCpObj'></span>

<h3>Description</h3>

<p>The <code>ClustCpObj</code> method returns a summary of the algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ClustCpObj'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.ClustCpObj_+3A_object">object</code></td>
<td>
<p>an object of class <code>ClustCpObj</code>.</p>
</td></tr>
<tr><td><code id="summary.ClustCpObj_+3A_...">...</code></td>
<td>
<p>parameter of the generic method.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data_mat &lt;- matrix(NA, nrow = 5, ncol = 100)

data_mat[1,] &lt;- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
data_mat[2,] &lt;- as.numeric(c(rnorm(50,0,0.125), rnorm(50,1,0.225)))
data_mat[3,] &lt;- as.numeric(c(rnorm(50,0,0.175), rnorm(50,1,0.280)))
data_mat[4,] &lt;- as.numeric(c(rnorm(25,0,0.135), rnorm(75,1,0.225)))
data_mat[5,] &lt;- as.numeric(c(rnorm(25,0,0.155), rnorm(75,1,0.280)))

out &lt;- clust_cp(data = data_mat, n_iterations = 5000, n_burnin = 1000,
                params = list(L = 1, B = 1000, gamma = 0.5), kernel = "ts")

summary(out)

</code></pre>

<hr>
<h2 id='summary.DetectCpObj'>DetectCpObj summary method</h2><span id='topic+summary.DetectCpObj'></span>

<h3>Description</h3>

<p>The <code>DetectCpObj</code> method returns a summary of the algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DetectCpObj'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.DetectCpObj_+3A_object">object</code></td>
<td>
<p>an object of class <code>DetectCpObj</code>;</p>
</td></tr>
<tr><td><code id="summary.DetectCpObj_+3A_...">...</code></td>
<td>
<p>parameter of the generic method.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data_mat &lt;- matrix(NA, nrow = 3, ncol = 100)

data_mat[1,] &lt;- as.numeric(c(rnorm(50,0,0.100), rnorm(50,1,0.250)))
data_mat[2,] &lt;- as.numeric(c(rnorm(50,0,0.125), rnorm(50,1,0.225)))
data_mat[3,] &lt;- as.numeric(c(rnorm(50,0,0.175), rnorm(50,1,0.280)))

out &lt;- detect_cp(data = data_mat, n_iterations = 2500, n_burnin = 500,
                params = list(q = 0.25, k_0 = 0.25, nu_0 = 4, phi_0 = diag(1,3,3), m_0 = rep(0,3),
                              par_theta_c = 2, par_theta_d = 0.2, prior_var_gamma = 0.1))
summary(out)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
