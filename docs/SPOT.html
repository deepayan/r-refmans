<!DOCTYPE html><html><head><title>Help for package SPOT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SPOT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#buildBO'><p>Bayesian Optimization Model Interface</p></a></li>
<li><a href='#buildCVModel'><p>buildCVModel</p></a></li>
<li><a href='#buildEnsembleStack'><p>Ensemble: Stacking</p></a></li>
<li><a href='#buildGaussianProcess'><p>Gaussian Process Model Interface</p></a></li>
<li><a href='#buildKriging'><p>Build Kriging Model</p></a></li>
<li><a href='#buildKrigingDACE'><p>Build DACE model</p></a></li>
<li><a href='#buildLasso'><p>Lasso Model Interface</p></a></li>
<li><a href='#buildLM'><p>Linear Model Interface</p></a></li>
<li><a href='#buildLOESS'><p>Build LOESS Model</p></a></li>
<li><a href='#buildPCA'><p>buildPCA</p></a></li>
<li><a href='#buildRandomForest'><p>Random Forest Interface</p></a></li>
<li><a href='#buildRanger'><p>ranger Interface</p></a></li>
<li><a href='#buildrsdummy'><p>Build random search dummy model</p></a></li>
<li><a href='#buildRSM'><p>Build Response Surface Model</p></a></li>
<li><a href='#buildTreeModel'><p>buildTreeModel</p></a></li>
<li><a href='#calculationBarthMuschelknautz'><p>Cyclone Simulation: Barth/Muschelknautz</p></a></li>
<li><a href='#calculationMothes'><p>Cyclone Simulation: Mothes</p></a></li>
<li><a href='#checkArrival'><p>checkArrival</p></a></li>
<li><a href='#checkFeasibilityNlopGnIngres'><p>Check feasibility for NLOPT_GN_ISRES</p></a></li>
<li><a href='#checkForNAs'><p>Check for NAs in x lower and upper</p></a></li>
<li><a href='#checkFunEvalsDesignSize'><p>Check funEvals Setting against designSize</p></a></li>
<li><a href='#checkInputDimensionsionalityCorrect'><p>Check Dimensions of spotInputs</p></a></li>
<li><a href='#checkInputTypesInControl'><p>Check input types in the spotControl list.</p></a></li>
<li><a href='#checkLowerSmallerThanUpper'><p>#' Check That Lower and Upper are not Equal</p>
#'
#' If any entries in lower and upper are equal, the parameter has no range and cant be optimized.
#' In that case, an error is generated.
#'
#' @param lower is a vector that defines the lower boundary of search space. This determines also the dimensionality of the problem.
#' @param upper is a vector that defines the upper boundary of search space.
#'
#' @keywords internal
</p>
<p>checkLowerNotEqualsUpper &lt;- function(lower,upper)</p>
if(any(lower == upper))
stop(&quot;SPOT Configuration Error: Entries in 'lower' and 'upper' should not be equal&quot;)


Check That Lower is smaller than Upper</a></li>
<li><a href='#checkTypesOfInput'><p>Check Input Types</p></a></li>
<li><a href='#checkVerbosityLevels'><p>Check correct verbosity levels</p></a></li>
<li><a href='#code2nat'><p>Transform coded values to natural values</p></a></li>
<li><a href='#corrcubic'><p>Correlation: Cubic</p></a></li>
<li><a href='#correxp'><p>Correlation: Exp</p></a></li>
<li><a href='#correxpg'><p>Correlation: Expg</p></a></li>
<li><a href='#corrgauss'><p>Correlation: Gauss</p></a></li>
<li><a href='#corrkriging'><p>Correlation:  Kriging</p></a></li>
<li><a href='#corrlin'><p>Correlation: Lin</p></a></li>
<li><a href='#corrnoisygauss'><p>Correlation: Noisy Gauss</p></a></li>
<li><a href='#corrnoisykriging'><p>Correlation: Noisy Kriging</p></a></li>
<li><a href='#corrspherical'><p>Correlation: Spherical</p></a></li>
<li><a href='#corrspline'><p>Correlation: Spline</p></a></li>
<li><a href='#daceEvalFit'><p>Evaluate DACE fit</p></a></li>
<li><a href='#daceFixTheta'><p>Fix model parameters DACE</p></a></li>
<li><a href='#daceGetFit'><p>Get DACE fit</p></a></li>
<li><a href='#daceLikelihood'><p>Wrapper for Maximum Likelihood Estimation</p></a></li>
<li><a href='#daceObjfunc'><p>DACE objective function</p></a></li>
<li><a href='#dacePrepareFit'><p>Prepare DACE fit</p></a></li>
<li><a href='#daceStartParameters'><p>Start parameter setup DACE</p></a></li>
<li><a href='#dataGasSensor'><p>Gas Sensor Data</p></a></li>
<li><a href='#descentSpotRSM'><p>Descent RSM model</p></a></li>
<li><a href='#designLHD'><p>Latin Hypercube Design Generator</p></a></li>
<li><a href='#designLHDNorm'><p>Normalized LHD Design</p></a></li>
<li><a href='#designUniformRandom'><p>Uniform Design Generator</p></a></li>
<li><a href='#diff0'><p>diff0</p></a></li>
<li><a href='#doParallel'><p>Parallel execution of code, dependent on the operating system</p></a></li>
<li><a href='#duplicateAndReplicateHandling'><p>duplicateAndReplicateHandling</p></a></li>
<li><a href='#evaluateModel'><p>Evaluate Model</p></a></li>
<li><a href='#expectedImprovement'><p>Expected Improvement</p></a></li>
<li><a href='#funBard'><p>funBard (No. 14, More No. 8)</p></a></li>
<li><a href='#funBeale'><p>funBeale (No.11, More No. 5)</p></a></li>
<li><a href='#funBox3d'><p>funbox3D (No. 18, More No. 12)</p></a></li>
<li><a href='#funBranin'><p>funBranin (No. 1)</p></a></li>
<li><a href='#funBrownBs'><p>funbrownBs (No. 10, More No. 4)</p></a></li>
<li><a href='#funCosts'><p>funCosts</p></a></li>
<li><a href='#funCyclone'><p>Objective function - Cyclone Simulation: Barth/Muschelknautz</p></a></li>
<li><a href='#funError'><p>funError</p></a></li>
<li><a href='#funFreudRoth'><p>funFreudRoth (No. 8, More No. 2)</p></a></li>
<li><a href='#funGauss'><p>funGauss (No. 15, More No. 9)</p></a></li>
<li><a href='#funGoldsteinPrice'><p>Goldstein-Price Test Function (No. 5)</p></a></li>
<li><a href='#funGulf'><p>funGulf (No.17, More No. 11)</p></a></li>
<li><a href='#funHelical'><p>funHelical (No. 13, More No. 7)</p></a></li>
<li><a href='#funIshigami'><p>Ishigami Test Function (No. 7)</p></a></li>
<li><a href='#funJennSamp'><p>funJennSamp (No. 12, More No 6)</p></a></li>
<li><a href='#funMeyer'><p>funMeyer (No. 16, More No. 10)</p></a></li>
<li><a href='#funMoo'><p>funMoo</p></a></li>
<li><a href='#funNoise'><p>funNoise</p></a></li>
<li><a href='#funOptimLecture'><p>funOptimLecture</p></a></li>
<li><a href='#funPowellBs'><p>funPowellBs (No. 9, More No. 3)</p></a></li>
<li><a href='#funPowellS'><p>funPowellS (No. 19, More No. 13)</p></a></li>
<li><a href='#funRosen'><p>funRosen (No. 2, More No. 1)</p></a></li>
<li><a href='#funRosen2'><p>funRosen2 (No. 2a)</p></a></li>
<li><a href='#funShiftedSphere'><p>funShiftedSphere (No. 4)</p></a></li>
<li><a href='#funSoblev99'><p>Sobol and Levitan Test Function (No. 6)</p></a></li>
<li><a href='#funSphere'><p>funSphere (No. 3)</p></a></li>
<li><a href='#funSring'><p>funSring</p></a></li>
<li><a href='#getCorrelationMatrix'><p>getCorrelationMatrix</p></a></li>
<li><a href='#getCosts'><p>getCosts</p></a></li>
<li><a href='#getMultiStartPoints'><p>Get Multi Start Points</p></a></li>
<li><a href='#getNatDesignFromCoded'><p>Get natural parameter values from coded +-1 representation</p></a></li>
<li><a href='#getPerformanceStats'><p>get performance stats</p></a></li>
<li><a href='#getPositions'><p>get impute positions</p></a></li>
<li><a href='#getPower'><p>getPower</p></a></li>
<li><a href='#getReplicates'><p>get number of replicates</p></a></li>
<li><a href='#getSampleSize'><p>getSampleSize</p></a></li>
<li><a href='#handleNAsKrigingWorst'><p>handleNAsKrigingWorst</p></a></li>
<li><a href='#handleNAsMax'><p>handleNAsMax</p></a></li>
<li><a href='#handleNAsMean'><p>handleNAsMean</p></a></li>
<li><a href='#imputeY'><p>Impute NAs and Inf in y</p></a></li>
<li><a href='#infillEI'><p>Expected Improvement Infill Criterion</p></a></li>
<li><a href='#infillExpectedImprovement'><p>infillExpectedImprovement</p></a></li>
<li><a href='#infillGetFullPrediction'><p>infillGetFullPrediction</p></a></li>
<li><a href='#init_ring'><p>init_ring</p></a></li>
<li><a href='#initialInputCheck'><p>initialInputCheck. Initial Input Check of Spot Configuration</p></a></li>
<li><a href='#krigingLikelihood'><p>Calculate negative log-likelihood</p></a></li>
<li><a href='#linearAdaptedSE'><p>linearAdaptedSE</p></a></li>
<li><a href='#makeMoreFunList'><p>makeMoreFunList</p></a></li>
<li><a href='#makeSpotFunList'><p>makeSpotFunList</p></a></li>
<li><a href='#maxNearestNeighbourDistance'><p>maxNearestNeighbourDistance</p></a></li>
<li><a href='#normalizeMatrix'><p>Normalize design matrix</p></a></li>
<li><a href='#normalizeMatrix2'><p>Normalize design 2</p></a></li>
<li><a href='#obj.plgpEI'><p>Wrapper for Expected improvement (Gramacy)</p></a></li>
<li><a href='#objectiveFunctionEvaluation'><p>objectiveFunctionEvaluation  Objective Function Evaluation</p></a></li>
<li><a href='#OCBA'><p>Low Level OCBA</p></a></li>
<li><a href='#ocbaRanking'><p>ocbaRanking</p></a></li>
<li><a href='#optimDE'><p>Minimization by Differential Evolution</p></a></li>
<li><a href='#optimES'><p>Evolution Strategy</p></a></li>
<li><a href='#optimGenoud'><p>Minimization by GENetic Optimization Using Derivatives</p></a></li>
<li><a href='#optimLagp'><p>Interface to minimization based on Gramacy's lagp package</p></a></li>
<li><a href='#optimLBFGSB'><p>Minimization by L-BFGS-B</p></a></li>
<li><a href='#optimLHD'><p>Minimization by Latin Hypercube Sampling</p></a></li>
<li><a href='#optimNLOPTR'><p>optimNLOPTR. Minimization by NLOPT</p></a></li>
<li><a href='#optimRSfun'><p>Random search surrogate-optimizer</p></a></li>
<li><a href='#perceptron'><p>perceptron</p></a></li>
<li><a href='#plgpEI'><p>Expected improvement (Gramacy)</p></a></li>
<li><a href='#plot.spotRSM'><p>Plot RSM model</p></a></li>
<li><a href='#plot.spotSeverity'><p>Plot method for spotSeverity</p></a></li>
<li><a href='#plot.spotTreeModel'><p>Plot rpart tree model</p></a></li>
<li><a href='#plotBestObj'><p>Plot Best Objective Value</p></a></li>
<li><a href='#plotData'><p>Interpolated plot</p></a></li>
<li><a href='#plotFunction'><p>Surface plot of a function</p></a></li>
<li><a href='#plotModel'><p>Surface plot of a model</p></a></li>
<li><a href='#plotPCA'><p>plotPCA</p></a></li>
<li><a href='#plotPCAvariance'><p>plotPCAvariance</p></a></li>
<li><a href='#plotSingleDimFunction'><p>plotSingleDimFunction</p></a></li>
<li><a href='#predict.cvModel'><p>predict.cvModel</p></a></li>
<li><a href='#predict.dace'><p>DACE predictor</p></a></li>
<li><a href='#predict.ensembleStack'><p>Predict Stacked Ensemble</p></a></li>
<li><a href='#predict.kriging'><p>Predict Kriging Model</p></a></li>
<li><a href='#predict.rsdummy'><p>Predict random search dummy</p></a></li>
<li><a href='#predict.spotBOModel'><p>Prediction method for bayesian optimization model</p></a></li>
<li><a href='#predict.spotGaussianProcessModel'><p>Prediction method for Gaussian Process Model</p></a></li>
<li><a href='#predict.spotLassoModel'><p>Prediction method for lasso model</p></a></li>
<li><a href='#predict.spotLinearModel'><p>Prediction method for linear model</p></a></li>
<li><a href='#predict.spotLOESS'><p>Predict loess model</p></a></li>
<li><a href='#predict.spotRandomForest'><p>Prediction method for random forest</p></a></li>
<li><a href='#predict.spotRanger'><p>Predictor for spotExtraTrees</p></a></li>
<li><a href='#predict.spotRSM'><p>Predict RSM model</p></a></li>
<li><a href='#predict.spotTreeModel'><p>Prediction method for rpart tree models</p></a></li>
<li><a href='#predictKrigingReinterpolation'><p>Predict Kriging Model (Re-interpolating)</p></a></li>
<li><a href='#prepareBestObjectiveVal'><p>Preprocess y Values to Plot Best Objective Value</p></a></li>
<li><a href='#print.dace'><p>Print Function DACE Kriging</p></a></li>
<li><a href='#print.spotBOModel'><p>Print method for BO model</p></a></li>
<li><a href='#print.spotGaussianProcessModel'><p>Print method for Gaussian Process Model</p></a></li>
<li><a href='#print.spotLassoModel'><p>Print method for lasso model</p></a></li>
<li><a href='#print.spotLinearModel'><p>Print method for linear model</p></a></li>
<li><a href='#print.spotLOESS'><p>Print method for loess model</p></a></li>
<li><a href='#print.spotRandomForest'><p>Print method for random forest</p></a></li>
<li><a href='#print.spotRanger'><p>Print method for random forest</p></a></li>
<li><a href='#print.spotRSM'><p>Print method for RSM model</p></a></li>
<li><a href='#print.spotSeverity'><p>Print method for spotSeverity</p></a></li>
<li><a href='#print.spotTreeModel'><p>Print method for rpart tree models</p></a></li>
<li><a href='#regpoly0'><p>Regression: Regpoly0</p></a></li>
<li><a href='#regpoly1'><p>Regression: Regpoly1</p></a></li>
<li><a href='#regpoly2'><p>Regression: Regpoly2</p></a></li>
<li><a href='#repairNonNumeric'><p>Repair Non-numeric Values</p></a></li>
<li><a href='#repeatsOCBA'><p>Optimal Computing Budget Allocation</p></a></li>
<li><a href='#repmat'><p>repmat</p></a></li>
<li><a href='#resBench01'><p>result from the vignette benchmark</p></a></li>
<li><a href='#resSpot'><p>S-Ring Simulation Data Obtained With SPOT</p></a></li>
<li><a href='#resSpot2'><p>S-Ring Simulation Data Obtained With SPOT</p></a></li>
<li><a href='#ring'><p>ring</p></a></li>
<li><a href='#runOptim'><p>runOptim</p></a></li>
<li><a href='#runSpotBench'><p>runSpotBench</p></a></li>
<li><a href='#sann2spot'><p>Interface SANN to SPOT</p></a></li>
<li><a href='#satter'><p>Satterthwaite Function</p></a></li>
<li><a href='#selectAll'><p>selectAll</p></a></li>
<li><a href='#selectN'><p>selectN. Select n Design Points</p></a></li>
<li><a href='#simulate.kriging'><p>Kriging Simulation</p></a></li>
<li><a href='#simulateFunction'><p>simulateFunction</p></a></li>
<li><a href='#simulationDecompose'><p>Kriging Simulation: Decomposition</p></a></li>
<li><a href='#simulationSpectral'><p>simulationSpectral</p></a></li>
<li><a href='#spot'><p>spot</p></a></li>
<li><a href='#SPOT-package'><p>Sequential Parameter Optimization Toolbox</p></a></li>
<li><a href='#spotAlgEs'><p>Evolution Strategy Implementation</p></a></li>
<li><a href='#spotAlgEsDominantReco'><p>spotAlgEsDominantReco</p></a></li>
<li><a href='#spotAlgEsGetSuccessRate'><p>get Success Rate</p></a></li>
<li><a href='#spotAlgEsHps'><p>Termination hps</p></a></li>
<li><a href='#spotAlgEsIndividualInitial'><p>Individual Initialization</p></a></li>
<li><a href='#spotAlgEsInitParentPop'><p>Initialize Parent Population</p></a></li>
<li><a href='#spotAlgEsInterReco'><p>spotAlgEsInterReco</p></a></li>
<li><a href='#spotAlgEsInterRecoBeSw02'><p>spotAlgEsInterRecoBeSw02</p></a></li>
<li><a href='#spotAlgEsMarriage'><p>Marriage</p></a></li>
<li><a href='#spotAlgEsMarriageWithReplace'><p>Marriage with replace</p></a></li>
<li><a href='#spotAlgEsObjMutation'><p>spotAlgEsObjMutation</p></a></li>
<li><a href='#spotAlgEsSelection'><p>spotAlgEsSelection</p></a></li>
<li><a href='#spotAlgEsStratMutation'><p>spotAlgEsStratMutation</p></a></li>
<li><a href='#spotAlgEsTermination'><p>Termination</p></a></li>
<li><a href='#spotCleanup'><p>Clean up</p></a></li>
<li><a href='#spotControl'><p>spotControl</p></a></li>
<li><a href='#spotFillControlList'><p>spotFillControlList</p></a></li>
<li><a href='#spotHelpBslash'><p>Backslash operator.</p></a></li>
<li><a href='#spotLoop'><p>Sequential Parameter Optimization Main Loop</p></a></li>
<li><a href='#spotPlotErrors'><p>spotPlotErrors</p></a></li>
<li><a href='#spotPlotPower'><p>spotPlotPower</p></a></li>
<li><a href='#spotPlotSeverityBasic'><p>spotPlotSeverityBasic</p></a></li>
<li><a href='#spotPlotTest'><p>spotPlotTest</p></a></li>
<li><a href='#spotPower'><p>spotPower</p></a></li>
<li><a href='#spotSeverity'><p>spotSeverity</p></a></li>
<li><a href='#spotSeverityBasic'><p>spotSeverityBasic</p></a></li>
<li><a href='#sring'><p>sring</p></a></li>
<li><a href='#sringRes1'><p>S-Ring Simulation Data</p></a></li>
<li><a href='#sringRes2'><p>S-Ring Simulation Data</p></a></li>
<li><a href='#sringRes3'><p>S-Ring Simulation Data</p></a></li>
<li><a href='#thetaNugget'><p>thetaNugget</p></a></li>
<li><a href='#thetaNuggetGradient'><p>thetaNuggetGradient</p></a></li>
<li><a href='#transformX'><p>Transform input</p></a></li>
<li><a href='#updateSeedFromXnew'><p>update seed</p></a></li>
<li><a href='#vmessage'><p>formatted output dependent on verbosity</p></a></li>
<li><a href='#wrapBatchTools'><p>wrapBatchTools</p></a></li>
<li><a href='#wrapFunction'><p>Function Evaluation Wrapper</p></a></li>
<li><a href='#wrapFunctionParallel'><p>Parallelized Function Evaluation Wrapper</p></a></li>
<li><a href='#wrapSystem_parseMatrixToString'><p>wrapSystem_parseMatrixToString</p></a></li>
<li><a href='#wrapSystemCommand'><p>wrapSystemCommand</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Title:</td>
<td>Sequential Parameter Optimization Toolbox</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>gzip</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of tools for model-based optimization and tuning of
    algorithms (hyperparameter tuning respectively hyperparameter optimization). It includes surrogate models, optimizers, and design of experiment
    approaches. The main interface is spot, which uses sequentially updated
    surrogate models for the purpose of efficient optimization. The main goal is
    to ease the burden of objective function evaluations, when a single evaluation
    requires a significant amount of resources.</td>
</tr>
<tr>
<td>Version:</td>
<td>2.11.14</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-11</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>DEoptim, ggplot2, glmnet, graphics, grDevices, laGP, MASS,
nloptr, plgp, plotly, rpart, randomForest, ranger, rgenoud,
rsm, stats, utils</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>batchtools, car, farff, knitr, microbenchmark, rmarkdown,
OpenML, party, RColorBrewer, readr, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.spotseven.de">https://www.spotseven.de</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-11 13:04:15 UTC; bartz</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Bartz-Beielstein
    <a href="https://orcid.org/0000-0002-5938-5158"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Martin Zaefferer <a href="https://orcid.org/0000-0003-2372-2092"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Frederik Rehbach <a href="https://orcid.org/0000-0003-0922-8629"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Margarita Rebolledo [ctb],
  Joerg Stork [ctb] (0000-0002-7471-3498),
  Christian Lasarczyk [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Bartz-Beielstein &lt;tbb@bartzundbartz.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-25 20:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='buildBO'>Bayesian Optimization Model Interface</h2><span id='topic+buildBO'></span>

<h3>Description</h3>

<p>Bayesian Optimization Model Interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildBO(x, y, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildBO_+3A_x">x</code></td>
<td>
<p>matrix of input parameters. Rows for each point, columns for each parameter.</p>
</td></tr>
<tr><td><code id="buildBO_+3A_y">y</code></td>
<td>
<p>one column matrix of observations to be modeled.</p>
</td></tr>
<tr><td><code id="buildBO_+3A_control">control</code></td>
<td>
<p>list of control parameters:
</p>

<dl>
<dt><code>thetaLower</code></dt><dd><p> lower boundary for theta, default is <code>1e-4</code></p>
</dd>
<dt><code>thetaUpper</code></dt><dd><p> upper boundary for theta, default is <code>1e2</code></p>
</dd>
<dt><code>algTheta</code></dt><dd><p>  algorithm used to find theta, default is <code>L-BFGS-B</code></p>
</dd>
<dt><code>budgetAlgTheta</code></dt><dd><p> budget for the above mentioned algorithm, default is <code>200</code>. The value will be multiplied with the length of the model parameter vector to be optimized.</p>
</dd>
<dt><code>optimizeP</code></dt><dd><p> boolean that specifies whether the exponents (<code>p</code>) should be optimized. Else they will be set to two. Default is <code>FALSE</code></p>
</dd>
<dt><code>useLambda</code></dt><dd><p> whether or not to use the regularization constant lambda (nugget effect). Default is <code>TRUE</code></p>
</dd>
<dt><code>lambdaLower</code></dt><dd><p> lower boundary for log10lambda, default is <code>-6</code></p>
</dd>
<dt><code>lambdaUpper</code></dt><dd><p> upper boundary for log10lambda, default is <code>0</code></p>
</dd>
<dt><code>startTheta</code></dt><dd><p> optional start value for theta optimization, default is <code>NULL</code></p>
</dd>
<dt><code>reinterpolate</code></dt><dd><p> whether (<code>TRUE</code>,default) or not (<code>FALSE</code>) reinterpolation should be performed</p>
</dd>
<dt><code>target</code></dt><dd><p> target values of the prediction, a vector of strings. Each string specifies a value to be predicted, e.g., &quot;y&quot; for mean, &quot;s&quot; for standard deviation, &quot;ei&quot; for expected improvement. See also <code><a href="#topic+predict.kriging">predict.kriging</a></code></p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"spotBOModel"</code>,
with a <code>predict</code> method and a <code>print</code> method.
Basically a list, with the options and found parameters for the model which has to be passed to the predictor function:
</p>

<dl>
<dt><code>x</code></dt><dd><p> sample locations </p>
</dd>
<dt><code>y</code></dt><dd><p> observations at sample locations (see parameters)</p>
</dd>
<dt><code>min</code></dt><dd><p> min y val</p>
</dd>
<dt><code>thetaLower</code></dt><dd><p> lower boundary for theta (see parameters)</p>
</dd>
<dt><code>thetaUpper</code></dt><dd><p> upper boundary for theta (see parameters)</p>
</dd>
<dt><code>algTheta</code></dt><dd><p> algorithm to find theta (see parameters)</p>
</dd>
<dt><code>budgetAlgTheta</code></dt><dd><p> budget for the above mentioned algorithm (see parameters)</p>
</dd>
<dt><code>lambdaLower</code></dt><dd><p> lower boundary for log10lambda, default is <code>-6</code></p>
</dd>
<dt><code>lambdaUpper</code></dt><dd><p> upper boundary for log10lambda, default is <code>0</code></p>
</dd>
<dt><code>dmodeltheta</code></dt><dd><p> vector of activity parameters</p>
</dd>
<dt><code>dmodellambda</code></dt><dd><p> regularization constant (nugget)</p>
</dd>
<dt><code>mu</code></dt><dd><p> mean mu</p>
</dd>
<dt><code>ssq</code></dt><dd><p> sigma square</p>
</dd>
<dt><code>Psi</code></dt><dd><p> matrix large Psi</p>
</dd>
<dt><code>Psinv</code></dt><dd><p> inverse of Psi</p>
</dd>
<dt><code>nevals</code></dt><dd><p> number of Likelihood evaluations during MLE</p>
</dd>
</dl>



<h3>References</h3>

<p>Forrester, Alexander I.J.; Sobester, Andras; Keane, Andy J. (2008). Engineering Design via Surrogate Modelling - A Practical Guide. John Wiley &amp; Sons.
</p>
<p>Gramacy, R. B. Surrogates. CRC press, 2020.
</p>
<p>Jones, D. R., Schonlau, M., and Welch, W. J. Efficient global optimization of expensive black-box functions. Journal of Global Optimization 13, 4 (1998), 455–492.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.spotBOModel">predict.spotBOModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Reproduction of Gramacy's classic EI illustration with data from Jones et al.
## Generates Fig. 7.6 from the Gramacy book "Surrogates".
x &lt;- c(1, 2, 3, 4, 12)
y &lt;- c(0, -1.75, -2, -0.5, 5)
## Build BO Model
m1 &lt;- buildBO(x = matrix(x, ncol = 1), 
 y = matrix(y, ncol=1),
 control = list(target="ei"))
xx &lt;- seq(0, 13, length=1000)
yy &lt;- predict(object = m1, newdata = xx)
m &lt;- which.min(y)
fmin &lt;- y[m]
mue &lt;- matrix(yy$y, ncol = 1)
s2 &lt;- matrix(yy$s, ncol = 1)
ei &lt;- matrix(yy$ei, ncol = 1)
## Plotting the Results (similar to Fig. 7.6 in Gramacy's Surrogate book)
par(mfrow=c(1,2))
plot(x, y, pch=19, xlim=c(0,13), ylim=c(-4,9), main="predictive surface")
lines(xx, mue)
lines(xx, mue + 2*sqrt(s2), col=2, lty=2)
lines(xx, mue - 2*sqrt(s2), col=2, lty=2)
abline(h=fmin, col=3, lty=3)
legend("topleft", c("mean", "95% PI", "fmin"), lty=1:3,   col=1:3, bty="n")
plot(xx, ei, type="l", col="blue", main="EI", xlab="x", ylim=c(0,max(ei)))
      
</code></pre>

<hr>
<h2 id='buildCVModel'>buildCVModel</h2><span id='topic+buildCVModel'></span>

<h3>Description</h3>

<p>Build a set of models trained on different folds of cross-validated data.
Can be used to estimate the uncertainty of a given model type at any point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildCVModel(x, y, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildCVModel_+3A_x">x</code></td>
<td>
<p>design matrix (sample locations)</p>
</td></tr>
<tr><td><code id="buildCVModel_+3A_y">y</code></td>
<td>
<p>vector of observations at <code>x</code></p>
</td></tr>
<tr><td><code id="buildCVModel_+3A_control">control</code></td>
<td>
<p>(list), with the options for the model building procedure:<br />
<code>types</code> a character vector giving the data type of each variable. All but &quot;factor&quot; will be handled as numeric, &quot;factor&quot; (categorical) variables will be subject to the hamming distance.<br />
<code>target</code> target values of the prediction, a vector of strings. Each string specifies a value to be predicted, e.g., &quot;y&quot; for mean, &quot;s&quot; for standard deviation.
This can also be changed after the model has been built, by manipulating the respective <code>object$target</code> value.<br />
<code>uncertaintyEstimator</code> a character vector specifying which uncertaintyEstimator should be used.
&quot;s&quot; or the linearlyAdapted uncertrainty &quot;sLinear&quot;. Default is &quot;sLinear&quot;.<br /> 
modellingFunction the model that shall be fitted to each data fold</p>
</td></tr>
</table>


<h3>Value</h3>

<p>set of models (class cvModel)
</p>

<hr>
<h2 id='buildEnsembleStack'>Ensemble: Stacking</h2><span id='topic+buildEnsembleStack'></span>

<h3>Description</h3>

<p>Generates an ensemble of surrogate models with stacking (stacked generalization).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildEnsembleStack(x, y, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildEnsembleStack_+3A_x">x</code></td>
<td>
<p>design matrix (sample locations), rows for each sample, columns for each variable.</p>
</td></tr>
<tr><td><code id="buildEnsembleStack_+3A_y">y</code></td>
<td>
<p>vector of observations at <code>x</code></p>
</td></tr>
<tr><td><code id="buildEnsembleStack_+3A_control">control</code></td>
<td>
<p>(list), with the options for the model building procedure:<br />
<code>modelL1</code> Function for fitting the L1 model (default: <code>buildLM</code>) which combines the results of the L0 models. <br />
<code>modelL1Control</code> List of control parameters for the L1 model (default: <code>list()</code>).<br />
<code>modelL0</code> A list of functions for fitting the L0 models (default: <code>list(buildLM,buildRandomForest,buildKriging)</code>). <br />
<code>modelL0Control</code> List of control lists for each L0 model (default: <code>list(list(),list(),list())</code>).<br /></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an object of class <code>ensembleStack</code>.
</p>


<h3>Note</h3>

<p>Loosely based on the code by Emanuele Olivetti https://github.com/emanuele/kaggle_pbr/blob/master/blend.py
</p>


<h3>References</h3>

<p>Bartz-Beielstein, Thomas. Stacked Generalization of Surrogate Models-A Practical Approach. Technical Report 5/2016, TH Koeln, Koeln, 2016.
</p>
<p>David H Wolpert. Stacked generalization. Neural Networks, 5(2):241-259, January 1992.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.ensembleStack">predict.ensembleStack</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Create design points
x &lt;- cbind(runif(20)*15-5,runif(20)*15)
## Compute observations at design points
y &lt;- funBranin(x)
## Create model with default settings
fit &lt;- buildEnsembleStack(x,y)
## Predict new point
predict(fit,cbind(1,2))
## True value at location
funBranin(matrix( c(1,2), 1))

</code></pre>

<hr>
<h2 id='buildGaussianProcess'>Gaussian Process Model Interface</h2><span id='topic+buildGaussianProcess'></span>

<h3>Description</h3>

<p>Gaussian Process Model Interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildGaussianProcess(x, y, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildGaussianProcess_+3A_x">x</code></td>
<td>
<p>matrix of input parameters. Rows for each point, columns for each parameter.</p>
</td></tr>
<tr><td><code id="buildGaussianProcess_+3A_y">y</code></td>
<td>
<p>one column matrix of observations to be modeled.</p>
</td></tr>
<tr><td><code id="buildGaussianProcess_+3A_control">control</code></td>
<td>
<p>list of control parameters. <code>n</code> subset size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"spotGaussianProcessModel"</code>, 
with a <code>predict</code> method and a <code>print</code> method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 200
x &lt;- matrix( seq(from=-1, to = 1, length.out = N), ncol = 1)
y &lt;- funSphere(x)  + rnorm(N, 0, 0.1)
fit &lt;- buildGaussianProcess(x,y)
## Print model parameters
print(fit)
## Predict at new location
xNew &lt;- matrix( c(-0.1, 0.1), ncol = 1)
predict(fit, xNew)
## True value at location
t(funSphere(xNew))
</code></pre>

<hr>
<h2 id='buildKriging'>Build Kriging Model</h2><span id='topic+buildKriging'></span>

<h3>Description</h3>

<p>This function builds a Kriging model based on code by Forrester et al..
By default exponents (p) are fixed at a value of two, and a nugget (or regularization constant) is used.
To correct the uncertainty estimates in case of nugget, re-interpolation is also by default turned on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildKriging(x, y, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildKriging_+3A_x">x</code></td>
<td>
<p>design matrix (sample locations)</p>
</td></tr>
<tr><td><code id="buildKriging_+3A_y">y</code></td>
<td>
<p>vector of observations at <code>x</code></p>
</td></tr>
<tr><td><code id="buildKriging_+3A_control">control</code></td>
<td>
<p>(list), with the options for the model building procedure. Note: This can also be changed after the model has been built, by manipulating the respective <code>object$target</code> value.
</p>

<dl>
<dt><code>types</code></dt><dd><p>a character vector giving the data type of each variable.
All but &quot;factor&quot; will be handled as numeric, &quot;factor&quot; (categorical) variables
will be subject to the hamming distance.</p>
</dd>
<dt><code>thetaLower</code></dt><dd><p>lower boundary for theta, default is <code>1e-4</code></p>
</dd>
<dt><code>thetaUpper</code></dt><dd><p>upper boundary for theta, default is <code>1e2</code></p>
</dd>
<dt><code>algTheta</code></dt><dd><p>algorithm used to find theta, default is <code>optimDE</code>.</p>
</dd>
<dt><code>budgetAlgTheta</code></dt><dd><p>budget for the above mentioned algorithm,
default is <code>200</code>. The value will be multiplied with the length of
the model parameter vector to be optimized.</p>
</dd>
<dt><code>optimizeP</code></dt><dd><p>boolean that specifies whether the exponents (<code>p</code>) should be optimized. Else they will be set to two. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>useLambda</code></dt><dd><p>whether or not to use the regularization constant lambda
(nugget effect). Default is <code>TRUE</code>.</p>
</dd>
<dt><code>lambdaLower</code></dt><dd><p>lower boundary for log10lambda, default is <code>-6</code></p>
</dd>
<dt><code>lambdaUpper</code></dt><dd><p>upper boundary for log10lambda, default is <code>0</code></p>
</dd>
<dt><code>startTheta</code></dt><dd><p>optional start value for theta optimization, default is <code>NULL</code></p>
</dd>
<dt><code>reinterpolate</code></dt><dd><p>whether (<code>TRUE</code>,default) or not (<code>FALSE</code>) reinterpolation
should be performed.</p>
</dd>
<dt><code>target</code></dt><dd><p>values of the prediction, a vector of strings.
Each string specifies a value to be predicted, e.g., &quot;y&quot; for mean, &quot;s&quot; for standard deviation, &quot;ei&quot; for expected improvement.
See also <code><a href="#topic+predict.kriging">predict.kriging</a></code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The model uses a Gaussian kernel: <code>k(x,z)=exp(-sum(theta_i * |x_i-z_i|^p_i))</code>. By default, <code>p_i = 2</code>.
Note that if dimension <code>x_i</code> is a factor variable (see parameter <code>types</code>), Hamming distance will be used
instead of <code>|x_i-z_i|</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>kriging</code>. Basically a list, with the options
and found parameters for the model which has to be passed to the predictor function:<br />
<code>x</code> sample locations (scaled to values between 0 and 1)<br />
<code>y</code> observations at sample locations (see parameters)<br />
<code>thetaLower</code> lower boundary for theta (see parameters)<br />
<code>thetaUpper</code> upper boundary for theta (see parameters)<br />
<code>algTheta</code> algorithm to find theta (see parameters)<br />
<code>budgetAlgTheta</code> budget for the above mentioned algorithm (see parameters)<br />
<code>optimizeP</code> boolean that specifies whether the exponents (<code>p</code>) were optimized (see parameters)<br />
<code>normalizeymin</code> minimum in normalized space<br />
<code>normalizeymax</code> maximum in normalized space<br />
<code>normalizexmin</code> minimum in input space<br />
<code>normalizexmax</code> maximum in input space<br />
<code>dmodeltheta</code> vector of activity parameters<br />
<code>Theta</code> log_10 vector of activity parameters (i.e. <code>log10(dmodeltheta)</code>)<br />
<code>dmodellambda</code> regularization constant (nugget) <br />
<code>Lambda</code> log_10 of regularization constant (nugget) (i.e. <code>log10(dmodellambda)</code>)<br />
<code>yonemu</code> <code>Ay-ones*mu</code> <br />
<code>ssq</code> sigma square<br />
<code>mu</code> mean mu<br />
<code>Psi</code> matrix large Psi<br />
<code>Psinv</code> inverse of Psi<br />
<code>nevals</code> number of Likelihood evaluations during MLE
</p>


<h3>References</h3>

<p>Forrester, Alexander I.J.; Sobester, Andras; Keane, Andy J. (2008). Engineering Design via Surrogate Modelling - A Practical Guide. John Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.kriging">predict.kriging</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create design points
set.seed(1)
x &lt;- cbind(runif(20)*15-5,runif(20)*15)
y &lt;- funBranin(x)
## Create model with default settings
fit &lt;- buildKriging(x,y,control = list(algTheta=optimLHD))
## Print model parameters
print(fit)
## Predict at new location
predict(fit,cbind(1,2))
## True value at location
funBranin(matrix(c(1,2), 1))
##
## Next Example: Handling factor variables

## create a test function:
braninFunctionFactor &lt;- function (x) {
y &lt;- (x[2]  - 5.1/(4 * pi^2) * (x[1] ^2) + 5/pi * x[1]  - 6)^2 +
		10 * (1 - 1/(8 * pi)) * cos(x[1] ) + 10
if(x[3]==1)
		y &lt;- y +1
else if(x[3]==2)
		y &lt;- y -1
y
}
## create training data
set.seed(1)
x &lt;- cbind(runif(50)*15-5,runif(50)*15,sample(1:3,50,replace=TRUE))
y &lt;- as.matrix(apply(x,1,braninFunctionFactor))
## fit the model (default: assume all variables are numeric)
fitDefault &lt;- buildKriging(x,y,control = list(algTheta=optimDE))
## fit the model (give information about the factor variable)
fitFactor &lt;- buildKriging(x,y,control =
	list(algTheta=optimDE,types=c("numeric","numeric","factor")))
## create test data
xtest &lt;- cbind(runif(200)*15-5,runif(200)*15,sample(1:3,200,replace=TRUE))
ytest &lt;- as.matrix(apply(xtest,1,braninFunctionFactor))
## Predict test data with both models, and compute error
ypredDef &lt;- predict(fitDefault,xtest)$y
ypredFact &lt;- predict(fitFactor,xtest)$y
mean((ypredDef-ytest)^2)
mean((ypredFact-ytest)^2)

</code></pre>

<hr>
<h2 id='buildKrigingDACE'>Build DACE model</h2><span id='topic+buildKrigingDACE'></span>

<h3>Description</h3>

<p>This Kriging meta model is based on DACE (Design and Analysis of Computer Experiments).
It allows to choose different regression and correlation models. The optimization of model parameters
is by default done with a bounded simplex method from the <code>nloptr</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildKrigingDACE(x, y, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildKrigingDACE_+3A_x">x</code></td>
<td>
<p>design matrix (sample locations), rows for each sample, columns for each variable.</p>
</td></tr>
<tr><td><code id="buildKrigingDACE_+3A_y">y</code></td>
<td>
<p>vector of observations at <code>x</code></p>
</td></tr>
<tr><td><code id="buildKrigingDACE_+3A_control">control</code></td>
<td>
<p>(list), with the options for the model building procedure:<br />
<code>startTheta</code> optional start value for theta optimization, default is <code>NULL</code><br />
<code>algTheta</code>  algorithm used to find theta, default is <code>optimDE</code>.<br />
<code>budgetAlgTheta</code> budget for the above mentioned algorithm, default is <code>200</code>. The value will be multiplied with the length of the model parameter vector to be optimized.<br />
<code>nugget</code> Value for nugget. Default is -1, which means the nugget will be optimized during MLE. Else it can be fixed in a range between 0 and 1.
<code>regr</code> Regression function to be used: <code><a href="#topic+regpoly0">regpoly0</a></code> (default), <code><a href="#topic+regpoly1">regpoly1</a></code>, <code><a href="#topic+regpoly2">regpoly2</a></code>. Can be a custom user function.<br />
<code>corr</code> Correlation function to be used: <code><a href="#topic+corrnoisykriging">corrnoisykriging</a></code> (default), <code><a href="#topic+corrkriging">corrkriging</a></code>, <code><a href="#topic+corrnoisygauss">corrnoisygauss</a></code>, <code><a href="#topic+corrgauss">corrgauss</a></code>, <code><a href="#topic+correxp">correxp</a></code>, <code><a href="#topic+correxpg">correxpg</a></code>, <code><a href="#topic+corrlin">corrlin</a></code>, <code><a href="#topic+corrcubic">corrcubic</a></code>,<code><a href="#topic+corrspherical">corrspherical</a></code>,<code><a href="#topic+corrspline">corrspline</a></code>. Can also be user supplied (if in the right form).
<code>target</code> target values of the prediction, a vector of strings. Each string specifies a value to be predicted, e.g., &quot;y&quot; for mean, &quot;s&quot; for standard deviation, &quot;ei&quot; for expected improvement. See also <code><a href="#topic+predict.kriging">predict.kriging</a></code>.
This can also be changed after the model has been build, by manipulating the respective <code>object$target</code> value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an object of class <code>dace</code> with the following elements:
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>A list, containing model parameters</p>
</td></tr>
<tr><td><code>like</code></td>
<td>
<p>Estimated likelihood value</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>activity parameters theta (vector)</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>exponents p (vector)</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>nugget value (numeric)</p>
</td></tr>
<tr><td><code>nevals</code></td>
<td>
<p> Number of iterations during MLE</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The authors of the original DACE Matlab toolbox
are Hans Bruun Nielsen, Soren Nymand Lophaven and Jacob Sondergaard. <br />
Extension of the Matlab code by Tobias Wagner <a href="mailto:wagner@isf.de">wagner@isf.de</a>. <br /> 
Porting and adaptation to R and further extensions by Martin Zaefferer <a href="mailto:martin.zaefferer@fh-koeln.de">martin.zaefferer@fh-koeln.de</a>.
</p>


<h3>References</h3>

<p>S.~Lophaven, H.~Nielsen, and J.~Sondergaard.
DACE&mdash;A Matlab Kriging Toolbox.
Technical Report IMM-REP-2002-12, Informatics and Mathematical
Modelling, Technical University of Denmark, Copenhagen, Denmark, 2002.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.dace">predict.dace</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create design points
x &lt;- cbind(runif(20)*15-5,runif(20)*15)
## Compute observations at design points 
y &lt;- funSphere(x)
## Create model with default settings
fit &lt;- buildKrigingDACE(x,y)
## Print model parameters
print(fit)
## Create with different regression and correlation functions
fit &lt;- buildKrigingDACE(x,y,control=list(regr=regpoly2,corr=corrspline))
## Print model parameters
print(fit)

</code></pre>

<hr>
<h2 id='buildLasso'>Lasso Model Interface</h2><span id='topic+buildLasso'></span>

<h3>Description</h3>

<p>The purpose of this function is to provide an interface as 
required by <code><a href="#topic+spot">spot</a></code>, 
to enable modeling and model-based optimization with Lasso models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildLasso(x, y, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildLasso_+3A_x">x</code></td>
<td>
<p>matrix of input parameters. Rows for each point, columns for each parameter.</p>
</td></tr>
<tr><td><code id="buildLasso_+3A_y">y</code></td>
<td>
<p>one column matrix of observations to be modeled.</p>
</td></tr>
<tr><td><code id="buildLasso_+3A_control">control</code></td>
<td>
<p>list of control parameters, currently only with 
parameter <code>formula</code>. 
The <code>useStep</code> boolean specifies whether the <code>step</code> function is used.
The <code>formula</code> is passed to the lm function.
Without a formula, a second order model will be built.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"spotLassoModel"</code>, 
with a <code>predict</code> method and a <code>print</code> method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Test-function:
braninFunction &lt;- function (x) {	
	(x[2]  - 5.1/(4 * pi^2) * (x[1] ^2) + 5/pi * x[1]  - 6)^2 + 
10 * (1 - 1/(8 * pi)) * cos(x[1] ) + 10
}
## Create design points
set.seed(1)
x &lt;- cbind(runif(20)*15-5,runif(20)*15)
## Compute observations at design points (for Branin function)
y &lt;- as.matrix(apply(x,1,braninFunction))
## Create model
fit &lt;- buildLasso(x,y,control = list(algTheta=optimLHD))
## Print model parameters
print(fit)
## Predict at new location
predict(fit,cbind(1,2))
## True value at location
braninFunction(c(1,2))
</code></pre>

<hr>
<h2 id='buildLM'>Linear Model Interface</h2><span id='topic+buildLM'></span>

<h3>Description</h3>

<p>This is a simple wrapper for the lm function, which fits linear models.
The purpose of this function is to provide an interface as required by SPOT, 
to enable modeling and model-based optimization with linear models. 
The linear model is build with main effects. 
Optionally, the model is also
subject to the AIC-based stepwise algorithm, 
using the <code>step</code> function from the <code>stats</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildLM(x, y, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildLM_+3A_x">x</code></td>
<td>
<p>matrix of input parameters. Rows for each point, columns for each parameter.</p>
</td></tr>
<tr><td><code id="buildLM_+3A_y">y</code></td>
<td>
<p>one column matrix of observations to be modeled.</p>
</td></tr>
<tr><td><code id="buildLM_+3A_control">control</code></td>
<td>
<p>list of control parameters, currently only with 
parameters <code>useStep</code> and <code>formula</code>. 
The <code>useStep</code> boolean specifies whether the <code>step</code> function is used.
The <code>formula</code> is passed to the lm function.
Without a formula, a second order model will be built.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"spotLinearModel"</code>, 
with a <code>predict</code> method and a <code>print</code> method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create design points
set.seed(1)
x &lt;- cbind(runif(20)*15-5,runif(20)*15)
## Compute observations at design points (for Branin function)
y &lt;- funBranin(x)
## Create model
fit &lt;- buildLM(x,y)
## Print model parameters
print(fit)
## Predict at new location
predict(fit,cbind(1,2))
## True value at location
funBranin(cbind(1,2))
</code></pre>

<hr>
<h2 id='buildLOESS'>Build LOESS Model</h2><span id='topic+buildLOESS'></span>

<h3>Description</h3>

<p>Build an interpolation model using the <code>loess</code> function. Essentially a SPOT-style
interface to that function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildLOESS(x, y, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildLOESS_+3A_x">x</code></td>
<td>
<p>design matrix (sample locations), rows for each sample, columns for each variable.</p>
</td></tr>
<tr><td><code id="buildLOESS_+3A_y">y</code></td>
<td>
<p>vector of observations at <code>x</code></p>
</td></tr>
<tr><td><code id="buildLOESS_+3A_control">control</code></td>
<td>
<p>named list, with the options for the model building procedure loess. These
will be passed to loess as arguments. Please refrain from setting the formula or data arguments
as these will be supplied by the interface, based on <code>x</code> and <code>y</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an object of class <code>spotLOESS</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.spotLOESS">predict.spotLOESS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a test function: branin
braninFunction &lt;- function (x) {	
	(x[2]  - 5.1/(4 * pi^2) * (x[1] ^2) + 5/pi * x[1]  - 6)^2 + 
10 * (1 - 1/(8 * pi)) * cos(x[1] ) + 10
}
## Create design points
set.seed(1)
x &lt;- cbind(runif(40)*15-5,runif(40)*15)
## Compute observations at design points
y &lt;- as.matrix(apply(x,1,braninFunction))
## Create model with default settings
fit &lt;- buildLOESS(x,y)
fit
## Predict new point
predict(fit,cbind(1,2))
## True value at location
braninFunction(c(1,2))
## Change model control
fit &lt;- buildLOESS(x,y,control=list(parametric=c(TRUE,FALSE)))
fit

</code></pre>

<hr>
<h2 id='buildPCA'>buildPCA</h2><span id='topic+buildPCA'></span>

<h3>Description</h3>

<p>buildPCA builds principal components of given dataset.
It is used inside <code><a href="#topic+plotPCA">plotPCA</a></code> function to build necessary 
object to perform principal components analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildPCA(x, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildPCA_+3A_x">x</code></td>
<td>
<p>dataset of parameters to be transformed</p>
</td></tr>
<tr><td><code id="buildPCA_+3A_control">control</code></td>
<td>
<p>control list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list with the following elements: <br />
<code>sdev</code> the standard deviations of the principal components (i.e., the square roots of the eigenvalues of the covariance/correlation matrix, though the calculation is actually done with the singular values of the data matrix).<br />
<code>rotation</code> the matrix of variable loadings (i.e., a matrix whose columns contain the eigenvectors).<br />
<code>x</code> transformed matrix.<br />
<code>center,scale</code> the centering and scaling used, or FALSE.
</p>


<h3>Author(s)</h3>

<p>Alpar Gür <a href="mailto:alpar.guer@smail.th-koeln.de">alpar.guer@smail.th-koeln.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#define objective function

objFun &lt;- function(x) 2*(x[1] - 1)^2 + 5*(x[2] - 3)^2 + (10*x[3] - x[4]/3)   

spotConfig &lt;- 
list(types = c('numeric', 'numeric', 'numeric', 'numeric'), 
funEvals = 15, #budget
noise = TRUE,
seedFun = 1,
replicated = 2,
seedSPOT = 1,
design = designLHD,
model = buildRandomForest, #surrogate model
optimizer = optimLHD, #LHD to optimize model
optimizerControl = list(funEvals=100)) #100 model evals in each step

lower &lt;- c(-20, -20, -20, -20) 
upper &lt;- c(20, 20, 20, 20)

res &lt;- spot(x=NULL, 
   fun=objFun, 
   lower=lower, 
   upper=upper, 
   control=spotConfig) 

resPCA &lt;- buildPCA(res$x) 

</code></pre>

<hr>
<h2 id='buildRandomForest'>Random Forest Interface</h2><span id='topic+buildRandomForest'></span>

<h3>Description</h3>

<p>This is a simple wrapper for the randomForest function from the randomForest package.
The purpose of this function is to provide an interface as required by SPOT, to enable
modeling and model-based optimization with random forest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildRandomForest(x, y, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildRandomForest_+3A_x">x</code></td>
<td>
<p>matrix of input parameters. Rows for each point, columns for each parameter.</p>
</td></tr>
<tr><td><code id="buildRandomForest_+3A_y">y</code></td>
<td>
<p>one column matrix of observations to be modeled.</p>
</td></tr>
<tr><td><code id="buildRandomForest_+3A_control">control</code></td>
<td>
<p>list of control parameters, currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"spotRandomForest"</code>, with a <code>predict</code> method and a <code>print</code> method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Test-function:
braninFunction &lt;- function (x) {	
	(x[2]  - 5.1/(4 * pi^2) * (x[1] ^2) + 5/pi * x[1]  - 6)^2 + 
10 * (1 - 1/(8 * pi)) * cos(x[1] ) + 10
}
## Create design points
set.seed(1)
x &lt;- cbind(runif(20)*15-5,runif(20)*15)
## Compute observations at design points (for Branin function)
y &lt;- as.matrix(apply(x,1,braninFunction))
## Create model
fit &lt;- buildRandomForest(x,y)
## Print model parameters
print(fit)
## Predict at new location
predict(fit,cbind(1,2))
## True value at location
braninFunction(c(1,2))

</code></pre>

<hr>
<h2 id='buildRanger'>ranger Interface</h2><span id='topic+buildRanger'></span>

<h3>Description</h3>

<p>This is a simple wrapper for the <code>ranger</code> 
function from the <code>ranger</code> package.
The purpose of this function is to provide an interface as required by SPOT, to enable
modeling and model-based optimization with <code>ranger</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildRanger(x, y, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildRanger_+3A_x">x</code></td>
<td>
<p>matrix of input parameters. Rows for each point, columns for each parameter.</p>
</td></tr>
<tr><td><code id="buildRanger_+3A_y">y</code></td>
<td>
<p>one column matrix of observations to be modeled.</p>
</td></tr>
<tr><td><code id="buildRanger_+3A_control">control</code></td>
<td>
<p>list of control parameters. These are all configuration parameters 
of the <code>ranger</code> function, and will be passed on to it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>spotRanger</code>, with a <code>predict</code> method and a <code>print</code> method.
#'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Create a simple training data set
testfun &lt;- function (x) x[1]^2
x &lt;- cbind(sort(runif(30)*2-1))
y &lt;- as.matrix(apply(x,1,testfun))
## test data:
xt &lt;- cbind(sort(runif(3000)*2-1))
## Example with default model (standard randomforest)
fit &lt;- buildRanger(x,y)
yt &lt;- predict(fit,data.frame(x=xt))
plot(xt,yt$y,type="l")
points(x,y,col="red",pch=20)
## Example with extra trees, an interpolating model
fit &lt;- buildRanger(x,y,
                   control=list(rangerArguments = 
                                list(replace = FALSE,
                                   sample.fraction=1,
                                   min.node.size = 1,
                                   splitrule = "extratrees")))
yt &lt;- predict(fit,data.frame(x=xt))
plot(xt,yt$y,type="l")
points(x,y,col="red",pch=20)

</code></pre>

<hr>
<h2 id='buildrsdummy'>Build random search dummy model</h2><span id='topic+buildrsdummy'></span>

<h3>Description</h3>

<p>This function is used to emulate uniform random search with SPOT.
It is a placeholder for the surrogate model and
simply returns an empty list, with class &quot;rsdummy&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildrsdummy(x, y, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildrsdummy_+3A_x">x</code></td>
<td>
<p>x (independent variables), not used.</p>
</td></tr>
<tr><td><code id="buildrsdummy_+3A_y">y</code></td>
<td>
<p>y (dependent variable), not used.</p>
</td></tr>
<tr><td><code id="buildrsdummy_+3A_control">control</code></td>
<td>
<p>control, not used.</p>
</td></tr>
</table>

<hr>
<h2 id='buildRSM'>Build Response Surface Model</h2><span id='topic+buildRSM'></span>

<h3>Description</h3>

<p>Using the <code>rsm</code> package, this function builds a linear response surface model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildRSM(x, y, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildRSM_+3A_x">x</code></td>
<td>
<p>design matrix (sample locations), rows for each sample, columns for each variable.</p>
</td></tr>
<tr><td><code id="buildRSM_+3A_y">y</code></td>
<td>
<p>vector of observations at <code>x</code></p>
</td></tr>
<tr><td><code id="buildRSM_+3A_control">control</code></td>
<td>
<p>(list), with the options for the model building procedure:
</p>

<dl>
<dt><code>mainEffectsOnly</code></dt><dd><p>Logical, defaults to FALSE. Set to TRUE if a model with main effects only is desired (no interactions, second order effects).</p>
</dd>
<dt><code>canonical</code></dt><dd><p>Logical, defaults to FALSE. If this is TRUE, use the canonical path to descent from saddle points. Else, simply use steepest descent</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an object of class <code>spotRSM</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.spotRSM">predict.spotRSM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a test function: branin
braninFunction &lt;- function (x) {	
	(x[2]  - 5.1/(4 * pi^2) * (x[1] ^2) + 5/pi * x[1]  - 6)^2 + 
10 * (1 - 1/(8 * pi)) * cos(x[1] ) + 10
}
## Create design points
x &lt;- cbind(runif(20)*15-5,runif(20)*15)
## Compute observations at design points
y &lt;- as.matrix(apply(x,1,braninFunction))
## Create model with default settings
fit &lt;- buildRSM(x,y)
## Predict new point
predict(fit,cbind(1,2))
## True value at location
braninFunction(c(1,2))
## plots
plot(fit)
## path of steepest descent
descentSpotRSM(fit)

</code></pre>

<hr>
<h2 id='buildTreeModel'>buildTreeModel</h2><span id='topic+buildTreeModel'></span>

<h3>Description</h3>

<p>Regression Interface 
This is a simple wrapper for the <code>rpart</code> function from the rpart package.
The purpose of this function is to provide an interface as required by SPOT, to enable
modeling and model-based optimization with regression trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildTreeModel(x, y, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildTreeModel_+3A_x">x</code></td>
<td>
<p>matrix of input parameters. Rows for each point, columns for each parameter.</p>
</td></tr>
<tr><td><code id="buildTreeModel_+3A_y">y</code></td>
<td>
<p>one column matrix of observations to be modeled.</p>
</td></tr>
<tr><td><code id="buildTreeModel_+3A_control">control</code></td>
<td>
<p>list of control parameters, currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>spotTreeModel</code>, with a <code>predict</code> method and a <code>print</code> method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create design points
set.seed(1)
x &lt;- cbind(runif(20)*15-5, runif(20)*15)
## Compute observations at design points (for Branin function)
y &lt;- funBranin(x)
## Create model
fit &lt;- buildTreeModel(x,y)
## Print model parameters
print(fit)
## Predict at new location
predict(fit,cbind(1,2))
## True value at location
funBranin(matrix( c(1,2), 1, ))
## 
set.seed(123)
x &lt;- seq(-1,1,1e-2)
y0 &lt;- c(-10,10)
sfun0  &lt;- stepfun(0, y0, f = 0)
y &lt;- sfun0(x)
fit &lt;- buildTreeModel(x,y)
# plot(fit)
# plot(x,y, type = "l")
yhat &lt;- predict(fit, newdata = 1)
yhat$y == 10
</code></pre>

<hr>
<h2 id='calculationBarthMuschelknautz'>Cyclone Simulation: Barth/Muschelknautz</h2><span id='topic+calculationBarthMuschelknautz'></span>

<h3>Description</h3>

<p>Calculate cyclone collection efficiency according to Barth/Muschelknautz.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculationBarthMuschelknautz(cyclone, fluid, xmean, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculationBarthMuschelknautz_+3A_cyclone">cyclone</code></td>
<td>
<p>list of cyclone's geometrical parameters</p>
</td></tr>
<tr><td><code id="calculationBarthMuschelknautz_+3A_fluid">fluid</code></td>
<td>
<p>list of fluid parameters</p>
</td></tr>
<tr><td><code id="calculationBarthMuschelknautz_+3A_xmean">xmean</code></td>
<td>
<p>vector of middle points for the intervals of the particle size distribution</p>
</td></tr>
<tr><td><code id="calculationBarthMuschelknautz_+3A_delta">delta</code></td>
<td>
<p>vector, amount of dust (percentage value) in each interval</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector, first element is the efficiency, second element is the pressure drop
</p>

<hr>
<h2 id='calculationMothes'>Cyclone Simulation: Mothes</h2><span id='topic+calculationMothes'></span>

<h3>Description</h3>

<p>Calculate cyclone collection efficiency and pressure drop according to Mothes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculationMothes(x, cyclone, fluid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculationMothes_+3A_x">x</code></td>
<td>
<p>a single particle diameter (scalar)</p>
</td></tr>
<tr><td><code id="calculationMothes_+3A_cyclone">cyclone</code></td>
<td>
<p>list of cyclone's geometrical parameters</p>
</td></tr>
<tr><td><code id="calculationMothes_+3A_fluid">fluid</code></td>
<td>
<p>list of fluid parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector with first element being the collection efficiency, second element being the pressure drop
</p>

<hr>
<h2 id='checkArrival'>checkArrival</h2><span id='topic+checkArrival'></span>

<h3>Description</h3>

<p>Calculate arrival events for S-Ring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkArrival(probNewCustomer)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkArrival_+3A_probnewcustomer">probNewCustomer</code></td>
<td>
<p>probability of an arrival of a new customer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>checkArrival(0.5)

</code></pre>

<hr>
<h2 id='checkFeasibilityNlopGnIngres'>Check feasibility for NLOPT_GN_ISRES</h2><span id='topic+checkFeasibilityNlopGnIngres'></span>

<h3>Description</h3>

<p>Returns <code>TRUE</code> if x does satisfy ineq constraint OR
no constraint function is used
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkFeasibilityNlopGnIngres(x, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkFeasibilityNlopGnIngres_+3A_x">x</code></td>
<td>
<p>(1 x n)-matrix to be tested</p>
</td></tr>
<tr><td><code id="checkFeasibilityNlopGnIngres_+3A_control">control</code></td>
<td>
<p>Control list for <code><a href="#topic+spot">spot</a></code> and <code><a href="#topic+spotLoop">spotLoop</a></code>.
</p>
<p>Generated with <code><a href="#topic+spotControl">spotControl</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical (<code>TRUE</code> if feasible)
</p>

<hr>
<h2 id='checkForNAs'>Check for NAs in x lower and upper</h2><span id='topic+checkForNAs'></span>

<h3>Description</h3>

<p>Creates an error message if there are any NAs in x lower or upper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkForNAs(x, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkForNAs_+3A_x">x</code></td>
<td>
<p>is an optional start point (or set of start points), specified as a matrix. One row for each point, and one column for each optimized parameter.</p>
</td></tr>
<tr><td><code id="checkForNAs_+3A_lower">lower</code></td>
<td>
<p>is a vector that defines the lower boundary of search space. This determines also the dimensionality of the problem.</p>
</td></tr>
<tr><td><code id="checkForNAs_+3A_upper">upper</code></td>
<td>
<p>is a vector that defines the upper boundary of search space.</p>
</td></tr>
</table>

<hr>
<h2 id='checkFunEvalsDesignSize'>Check funEvals Setting against designSize</h2><span id='topic+checkFunEvalsDesignSize'></span>

<h3>Description</h3>

<p>Checks if the designSize will result in a larger value than funEvals. If so, return an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkFunEvalsDesignSize(x, lower, control, inSpotLoop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkFunEvalsDesignSize_+3A_x">x</code></td>
<td>
<p>is an optional start point (or set of start points), specified as a matrix. One row for each point, and one column for each optimized parameter.</p>
</td></tr>
<tr><td><code id="checkFunEvalsDesignSize_+3A_lower">lower</code></td>
<td>
<p>is a vector that defines the lower boundary of search space. This determines also the dimensionality of the problem.</p>
</td></tr>
<tr><td><code id="checkFunEvalsDesignSize_+3A_inspotloop">inSpotLoop</code></td>
<td>
<p>Boolean indicating whether the check is called from within spotLoop or not</p>
</td></tr>
<tr><td><code id="checkFunEvalsDesignSize_+3A_fun">fun</code></td>
<td>
<p>is the objective function. It should receive a matrix x and return a matrix y. In case the function uses external code and is noisy, an additional seed parameter may be used, see the <code>control$seedFun</code> argument below for details.</p>
</td></tr>
<tr><td><code id="checkFunEvalsDesignSize_+3A_upper">upper</code></td>
<td>
<p>is a vector that defines the upper boundary of search space.</p>
</td></tr>
</table>

<hr>
<h2 id='checkInputDimensionsionalityCorrect'>Check Dimensions of spotInputs</h2><span id='topic+checkInputDimensionsionalityCorrect'></span>

<h3>Description</h3>

<p>The dimensionality of x, lower and upper should match. If this is not the case, errors are generated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkInputDimensionsionalityCorrect(x, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkInputDimensionsionalityCorrect_+3A_x">x</code></td>
<td>
<p>is an optional start point (or set of start points), specified as a matrix. One row for each point, and one column for each optimized parameter.</p>
</td></tr>
<tr><td><code id="checkInputDimensionsionalityCorrect_+3A_lower">lower</code></td>
<td>
<p>is a vector that defines the lower boundary of search space. This determines also the dimensionality of the problem.</p>
</td></tr>
<tr><td><code id="checkInputDimensionsionalityCorrect_+3A_upper">upper</code></td>
<td>
<p>is a vector that defines the upper boundary of search space.</p>
</td></tr>
</table>

<hr>
<h2 id='checkInputTypesInControl'>Check input types in the spotControl list.</h2><span id='topic+checkInputTypesInControl'></span>

<h3>Description</h3>

<p>specified variables are tested for their type in the control list. If a type mismatch is found, an error is thrown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkInputTypesInControl(control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkInputTypesInControl_+3A_control">control</code></td>
<td>
<p>is a list with control settings for spot. See <code><a href="#topic+spotControl">spotControl</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='checkLowerSmallerThanUpper'>#' Check That Lower and Upper are not Equal
#'
#' If any entries in lower and upper are equal, the parameter has no range and cant be optimized. 
#' In that case, an error is generated.
#'
#' @param lower is a vector that defines the lower boundary of search space. This determines also the dimensionality of the problem.
#' @param upper is a vector that defines the upper boundary of search space.
#' 
#' @keywords internal
checkLowerNotEqualsUpper &lt;- function(lower,upper)
if(any(lower == upper))
stop(&quot;SPOT Configuration Error: Entries in 'lower' and 'upper' should not be equal&quot;)


Check That Lower is smaller than Upper</h2><span id='topic+checkLowerSmallerThanUpper'></span>

<h3>Description</h3>

<p>Check if lower actually contains smaller values than upper. Otherwise a warning is generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkLowerSmallerThanUpper(lower, upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkLowerSmallerThanUpper_+3A_lower">lower</code></td>
<td>
<p>is a vector that defines the lower boundary of search space. This determines also the dimensionality of the problem.</p>
</td></tr>
<tr><td><code id="checkLowerSmallerThanUpper_+3A_upper">upper</code></td>
<td>
<p>is a vector that defines the upper boundary of search space.</p>
</td></tr>
</table>

<hr>
<h2 id='checkTypesOfInput'>Check Input Types</h2><span id='topic+checkTypesOfInput'></span>

<h3>Description</h3>

<p>Creates an error message if any of the input types are not numeric even though they are configured to be numeric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkTypesOfInput(x, lower, upper, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkTypesOfInput_+3A_x">x</code></td>
<td>
<p>is an optional start point (or set of start points), specified as a matrix. One row for each point, and one column for each optimized parameter.</p>
</td></tr>
<tr><td><code id="checkTypesOfInput_+3A_lower">lower</code></td>
<td>
<p>is a vector that defines the lower boundary of search space. This determines also the dimensionality of the problem.</p>
</td></tr>
<tr><td><code id="checkTypesOfInput_+3A_upper">upper</code></td>
<td>
<p>is a vector that defines the upper boundary of search space.</p>
</td></tr>
<tr><td><code id="checkTypesOfInput_+3A_control">control</code></td>
<td>
<p>is a list with control settings for spot. See <code><a href="#topic+spotControl">spotControl</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='checkVerbosityLevels'>Check correct verbosity levels</h2><span id='topic+checkVerbosityLevels'></span>

<h3>Description</h3>

<p>Create an error message if the given verbosity level is not allowed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkVerbosityLevels(control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkVerbosityLevels_+3A_control">control</code></td>
<td>
<p>spot control list. The <code>control$verbosity</code> argument
is checked. There are two verbosity levels:
</p>

<dl>
<dt><code>0</code></dt><dd><p>no output</p>
</dd>
<dt><code>1</code></dt><dd><p>detailed output</p>
</dd>
</dl>
</td></tr>
</table>

<hr>
<h2 id='code2nat'>Transform coded values to natural values</h2><span id='topic+code2nat'></span>

<h3>Description</h3>

<p>Input values from the interval from zero to one, i.e., normalized
values,  are mapped to the interval from a to b.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>code2nat(x, a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="code2nat_+3A_x">x</code></td>
<td>
<p><code>matrix</code> of m n-dimensional input values
from the interval <code>[0;1]</code>, i.e, dim(x) = m x n</p>
</td></tr>
<tr><td><code id="code2nat_+3A_a">a</code></td>
<td>
<p><code>vector</code> of n-dimensional lower bound, i.e., length(a) = n</p>
</td></tr>
<tr><td><code id="code2nat_+3A_b">b</code></td>
<td>
<p><code>vector</code> of n-dimensional upper bound, i.e., length(b) = n</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(runif(10),2)
a &lt;- c(-1,1,2,3,4)
b &lt;- c(1,2,3,4,5)
R &lt;- code2nat(x,a,b)

</code></pre>

<hr>
<h2 id='corrcubic'>Correlation: Cubic</h2><span id='topic+corrcubic'></span>

<h3>Description</h3>

<p>Cubic correlation function.<br />
If <code>length(theta) = 1</code>, then the model is isotropic:<br />
all <code>theta_j = theta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrcubic(theta, d, ret = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corrcubic_+3A_theta">theta</code></td>
<td>
<p>parameters in the correlation function</p>
</td></tr>
<tr><td><code id="corrcubic_+3A_d">d</code></td>
<td>
<p>m*n matrix with differences between given data points</p>
</td></tr>
<tr><td><code id="corrcubic_+3A_ret">ret</code></td>
<td>
<p>A string. If set to <code>"all"</code> or <code>"dr"</code>, the derivative of <code>r</code> (<code>dr</code>) will be returned, else <code>dr</code> is <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list with two elements:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>correlation</p>
</td></tr>
<tr><td><code>dr</code></td>
<td>
<p>m*n matrix with the Jacobian of <code>r</code> at <code>x</code>. It is
assumed that <code>x</code> is given implicitly by <code>d[i,] = x - S[i,]</code>,
where <code>S[i,]</code> is the <code>i</code>'th design site.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The authors of the original DACE Matlab code \ 
are Hans Bruun Nielsen, Soren Nymand Lophaven and Jacob Sondergaard. <br />
Ported to R by Martin Zaefferer <a href="mailto:martin.zaefferer@fh-koeln.de">martin.zaefferer@fh-koeln.de</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKrigingDACE">buildKrigingDACE</a></code>
</p>

<hr>
<h2 id='correxp'>Correlation: Exp</h2><span id='topic+correxp'></span>

<h3>Description</h3>

<p>Exponential correlation function.<br />
If <code>length(theta) = 1</code>, then the model is isotropic:<br />
all <code>theta_j = theta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correxp(theta, d, ret = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correxp_+3A_theta">theta</code></td>
<td>
<p>parameters in the correlation function</p>
</td></tr>
<tr><td><code id="correxp_+3A_d">d</code></td>
<td>
<p>m*n matrix with differences between given data points</p>
</td></tr>
<tr><td><code id="correxp_+3A_ret">ret</code></td>
<td>
<p>A string. If set to <code>"all"</code> or <code>"dr"</code>, the derivative of <code>r</code> (<code>dr</code>) will be returned, else <code>dr</code> is <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list with two elements:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>correlation</p>
</td></tr>
<tr><td><code>dr</code></td>
<td>
<p>m*n matrix with the Jacobian of <code>r</code> at <code>x</code>. It is
assumed that <code>x</code> is given implicitly by <code>d[i,] = x - S[i,]</code>,
where <code>S[i,]</code> is the <code>i</code>'th design site.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The authors of the original DACE Matlab code
are Hans Bruun Nielsen, Soren Nymand Lophaven and Jacob Sondergaard. <br />
Ported to R by Martin Zaefferer <a href="mailto:martin.zaefferer@fh-koeln.de">martin.zaefferer@fh-koeln.de</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKrigingDACE">buildKrigingDACE</a></code>
</p>

<hr>
<h2 id='correxpg'>Correlation: Expg</h2><span id='topic+correxpg'></span>

<h3>Description</h3>

<p>General exponential correlation function.<br />
If <code>n &gt; 1</code>  and <code>length(theta) = 1</code>, then the model is isotropic:<br />
<code>theta_j = theta[1], j=1,...,n;  theta_[n+1] = theta[2]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correxpg(theta, d, ret = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correxpg_+3A_theta">theta</code></td>
<td>
<p>parameters in the correlation function</p>
</td></tr>
<tr><td><code id="correxpg_+3A_d">d</code></td>
<td>
<p>m*n matrix with differences between given data points</p>
</td></tr>
<tr><td><code id="correxpg_+3A_ret">ret</code></td>
<td>
<p>A string. If set to <code>"all"</code> or <code>"dr"</code>, the derivative of <code>r</code> (<code>dr</code>) will be returned, else <code>dr</code> is <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list with two elements:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>correlation</p>
</td></tr>
<tr><td><code>dr</code></td>
<td>
<p>m*n matrix with the Jacobian of <code>r</code> at <code>x</code>. It is
assumed that <code>x</code> is given implicitly by <code>d[i,] = x - S[i,]</code>,
where <code>S[i,]</code> is the <code>i</code>'th design site.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The authors of the original DACE Matlab code 
are Hans Bruun Nielsen, Soren Nymand Lophaven and Jacob Sondergaard. <br />
Ported to R by Martin Zaefferer <a href="mailto:martin.zaefferer@fh-koeln.de">martin.zaefferer@fh-koeln.de</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKrigingDACE">buildKrigingDACE</a></code>
</p>

<hr>
<h2 id='corrgauss'>Correlation: Gauss</h2><span id='topic+corrgauss'></span>

<h3>Description</h3>

<p>Gaussian correlation function, no nugget.<br />
If <code>length(theta) = 1</code>, then the model is isotropic:<br />
all <code>theta_j = theta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrgauss(theta, d, ret = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corrgauss_+3A_theta">theta</code></td>
<td>
<p>parameters in the correlation function</p>
</td></tr>
<tr><td><code id="corrgauss_+3A_d">d</code></td>
<td>
<p>m*n matrix with differences between given data points</p>
</td></tr>
<tr><td><code id="corrgauss_+3A_ret">ret</code></td>
<td>
<p>A string. If set to <code>"all"</code> or <code>"dr"</code>, the derivative of <code>r</code> (<code>dr</code>) will be returned, else <code>dr</code> is <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list with two elements:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>correlation</p>
</td></tr>
<tr><td><code>dr</code></td>
<td>
<p>m*n matrix with the Jacobian of <code>r</code> at <code>x</code>. It is
assumed that <code>x</code> is given implicitly by <code>d[i,] = x - S[i,]</code>,
where <code>S[i,]</code> is the <code>i</code>'th design site.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The authors of the original DACE Matlab code 
are Hans Bruun Nielsen, Soren Nymand Lophaven and Jacob Sondergaard. <br />
Ported to R by Martin Zaefferer <a href="mailto:martin.zaefferer@fh-koeln.de">martin.zaefferer@fh-koeln.de</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKrigingDACE">buildKrigingDACE</a></code>
</p>

<hr>
<h2 id='corrkriging'>Correlation:  Kriging</h2><span id='topic+corrkriging'></span>

<h3>Description</h3>

<p>Kriging correlation function, no nugget
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrkriging(theta, d, ret = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corrkriging_+3A_theta">theta</code></td>
<td>
<p>parameters in the correlation function</p>
</td></tr>
<tr><td><code id="corrkriging_+3A_d">d</code></td>
<td>
<p>m*n matrix with differences between given data points</p>
</td></tr>
<tr><td><code id="corrkriging_+3A_ret">ret</code></td>
<td>
<p>A string. If set to <code>"all"</code> or <code>"dr"</code>, the derivative of <code>r</code> (<code>dr</code>) will be returned, else <code>dr</code> is <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list with two elements:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>correlation</p>
</td></tr>
<tr><td><code>dr</code></td>
<td>
<p>m*n matrix with the Jacobian of <code>r</code> at <code>x</code>. It is
assumed that <code>x</code> is given implicitly by <code>d[i,] = x - S[i,]</code>,
where <code>S[i,]</code> is the <code>i</code>'th design site.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The authors of the original DACE Matlab code
are Hans Bruun Nielsen, Soren Nymand Lophaven and Jacob Sondergaard. <br />
Extension of the Matlab code by Tobias Wagner <a href="mailto:wagner@isf.de">wagner@isf.de</a>. <br /> 
Ported to R by Martin Zaefferer <a href="mailto:martin.zaefferer@fh-koeln.de">martin.zaefferer@fh-koeln.de</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKrigingDACE">buildKrigingDACE</a></code>
</p>

<hr>
<h2 id='corrlin'>Correlation: Lin</h2><span id='topic+corrlin'></span>

<h3>Description</h3>

<p>Linear correlation function.<br />
If <code>length(theta) = 1</code>, then the model is isotropic:<br />
all <code>theta_j = theta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrlin(theta, d, ret = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corrlin_+3A_theta">theta</code></td>
<td>
<p>parameters in the correlation function</p>
</td></tr>
<tr><td><code id="corrlin_+3A_d">d</code></td>
<td>
<p>m*n matrix with differences between given data points</p>
</td></tr>
<tr><td><code id="corrlin_+3A_ret">ret</code></td>
<td>
<p>A string. If set to <code>"all"</code> or <code>"dr"</code>, the derivative of <code>r</code> (<code>dr</code>) will be returned, else <code>dr</code> is <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list with two elements:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>correlation</p>
</td></tr>
<tr><td><code>dr</code></td>
<td>
<p>m*n matrix with the Jacobian of <code>r</code> at <code>x</code>. It is
assumed that <code>x</code> is given implicitly by <code>d[i,] = x - S[i,]</code>,
where <code>S[i,]</code> is the <code>i</code>'th design site.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The authors of the original DACE Matlab code 
are Hans Bruun Nielsen, Soren Nymand Lophaven and Jacob Sondergaard. <br />
Ported to R by Martin Zaefferer <a href="mailto:martin.zaefferer@fh-koeln.de">martin.zaefferer@fh-koeln.de</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKrigingDACE">buildKrigingDACE</a></code>
</p>

<hr>
<h2 id='corrnoisygauss'>Correlation: Noisy Gauss</h2><span id='topic+corrnoisygauss'></span>

<h3>Description</h3>

<p>Noisy Gaussian correlation function using nuggets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrnoisygauss(theta, d, ret = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corrnoisygauss_+3A_theta">theta</code></td>
<td>
<p>parameters in the correlation function</p>
</td></tr>
<tr><td><code id="corrnoisygauss_+3A_d">d</code></td>
<td>
<p>m*n matrix with differences between given data points</p>
</td></tr>
<tr><td><code id="corrnoisygauss_+3A_ret">ret</code></td>
<td>
<p>A string. If set to <code>"all"</code> or <code>"dr"</code>, the derivative of <code>r</code> (<code>dr</code>) will be returned, else <code>dr</code> is <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list with two elements:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>correlation</p>
</td></tr>
<tr><td><code>dr</code></td>
<td>
<p>m*n matrix with the Jacobian of <code>r</code> at <code>x</code>. It is
assumed that <code>x</code> is given implicitly by <code>d[i,] = x - S[i,]</code>,
where <code>S[i,]</code> is the <code>i</code>'th design site.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The authors of the original DACE Matlab code
are Hans Bruun Nielsen, Soren Nymand Lophaven and Jacob Sondergaard. <br />
Extension of the Matlab code by Tobias Wagner <a href="mailto:wagner@isf.de">wagner@isf.de</a>. <br /> 
Ported to R by Martin Zaefferer <a href="mailto:martin.zaefferer@fh-koeln.de">martin.zaefferer@fh-koeln.de</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKrigingDACE">buildKrigingDACE</a></code>
</p>

<hr>
<h2 id='corrnoisykriging'>Correlation: Noisy Kriging</h2><span id='topic+corrnoisykriging'></span>

<h3>Description</h3>

<p>Noisy Kriging correlation function using nuggets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrnoisykriging(theta, d, ret = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corrnoisykriging_+3A_theta">theta</code></td>
<td>
<p>parameters in the correlation function</p>
</td></tr>
<tr><td><code id="corrnoisykriging_+3A_d">d</code></td>
<td>
<p>m*n matrix with differences between given data points</p>
</td></tr>
<tr><td><code id="corrnoisykriging_+3A_ret">ret</code></td>
<td>
<p>A string. If set to <code>"all"</code> or <code>"dr"</code>, the derivative of <code>r</code> (<code>dr</code>) will be returned, else <code>dr</code> is <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list with two elements:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>correlation</p>
</td></tr>
<tr><td><code>dr</code></td>
<td>
<p>m*n matrix with the Jacobian of <code>r</code> at <code>x</code>. It is
assumed that <code>x</code> is given implicitly by <code>d[i,] = x - S[i,]</code>,
where <code>S[i,]</code> is the <code>i</code>'th design site.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The authors of the original DACE Matlab code 
are Hans Bruun Nielsen, Soren Nymand Lophaven and Jacob Sondergaard. <br />
Extension of the Matlab code by Tobias Wagner <a href="mailto:wagner@isf.de">wagner@isf.de</a>. <br /> 
Ported to R by Martin Zaefferer <a href="mailto:martin.zaefferer@fh-koeln.de">martin.zaefferer@fh-koeln.de</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKrigingDACE">buildKrigingDACE</a></code>
</p>

<hr>
<h2 id='corrspherical'>Correlation: Spherical</h2><span id='topic+corrspherical'></span>

<h3>Description</h3>

<p>Spherical correlation function.<br />
If <code>length(theta) = 1</code>, then the model is isotropic:<br />
all <code>theta_j = theta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrspherical(theta, d, ret = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corrspherical_+3A_theta">theta</code></td>
<td>
<p>parameters in the correlation function</p>
</td></tr>
<tr><td><code id="corrspherical_+3A_d">d</code></td>
<td>
<p>m*n matrix with differences between given data points</p>
</td></tr>
<tr><td><code id="corrspherical_+3A_ret">ret</code></td>
<td>
<p>A string. If set to <code>"all"</code> or <code>"dr"</code>, the derivative of <code>r</code> (<code>dr</code>) will be returned, else <code>dr</code> is <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list with two elements:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>correlation</p>
</td></tr>
<tr><td><code>dr</code></td>
<td>
<p>m*n matrix with the Jacobian of <code>r</code> at <code>x</code>. It is
assumed that <code>x</code> is given implicitly by <code>d[i,] = x - S[i,]</code>,
where <code>S[i,]</code> is the <code>i</code>'th design site.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The authors of the original DACE Matlab code 
are Hans Bruun Nielsen, Soren Nymand Lophaven and Jacob Sondergaard. <br />
Ported to R by Martin Zaefferer <a href="mailto:martin.zaefferer@fh-koeln.de">martin.zaefferer@fh-koeln.de</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKrigingDACE">buildKrigingDACE</a></code>
</p>

<hr>
<h2 id='corrspline'>Correlation: Spline</h2><span id='topic+corrspline'></span>

<h3>Description</h3>

<p>Cubic spline correlation function.<br />
If <code>length(theta) = 1</code>, then the model is isotropic:<br />
all <code>theta_j = theta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrspline(theta, d, ret = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corrspline_+3A_theta">theta</code></td>
<td>
<p>parameters in the correlation function</p>
</td></tr>
<tr><td><code id="corrspline_+3A_d">d</code></td>
<td>
<p>m*n matrix with differences between given data points</p>
</td></tr>
<tr><td><code id="corrspline_+3A_ret">ret</code></td>
<td>
<p>A string. If set to <code>"all"</code> or <code>"dr"</code>, the derivative of <code>r</code> (<code>dr</code>) will be returned, else <code>dr</code> is <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list with two elements:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>correlation</p>
</td></tr>
<tr><td><code>dr</code></td>
<td>
<p>m*n matrix with the Jacobian of <code>r</code> at <code>x</code>. It is
assumed that <code>x</code> is given implicitly by <code>d[i,] = x - S[i,]</code>,
where <code>S[i,]</code> is the <code>i</code>'th design site.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The authors of the original DACE Matlab code 
are Hans Bruun Nielsen, Soren Nymand Lophaven and Jacob Sondergaard. <br />
Ported to R by Martin Zaefferer <a href="mailto:martin.zaefferer@fh-koeln.de">martin.zaefferer@fh-koeln.de</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKrigingDACE">buildKrigingDACE</a></code>
</p>

<hr>
<h2 id='daceEvalFit'>Evaluate DACE fit</h2><span id='topic+daceEvalFit'></span>

<h3>Description</h3>

<p>Evaluate the fit of a certain set of model parameters (<code>theta</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daceEvalFit(theta, pars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="daceEvalFit_+3A_theta">theta</code></td>
<td>
<p>model parameters to be evaluated</p>
</td></tr>
<tr><td><code id="daceEvalFit_+3A_pars">pars</code></td>
<td>
<p>model option list, as created with <code><a href="#topic+dacePrepareFit">dacePrepareFit</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>performance vector, first elements are theta, last element is likelihood.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKrigingDACE">buildKrigingDACE</a></code> <code><a href="#topic+daceLikelihood">daceLikelihood</a></code> <code><a href="#topic+daceGetFit">daceGetFit</a></code>
</p>

<hr>
<h2 id='daceFixTheta'>Fix model parameters DACE</h2><span id='topic+daceFixTheta'></span>

<h3>Description</h3>

<p>This function fixes theta (model parameter vector) after optimization. That is, if a value was optimized on a logarithmic scale: <code>theta=10^theta</code>.
The result depends on dimensionality of the problem, the nugget value and the choice of correlation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daceFixTheta(m, bestTheta, nugget, corr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="daceFixTheta_+3A_m">m</code></td>
<td>
<p>dimension (length) of each point</p>
</td></tr>
<tr><td><code id="daceFixTheta_+3A_besttheta">bestTheta</code></td>
<td>
<p>the theta value found during MLE</p>
</td></tr>
<tr><td><code id="daceFixTheta_+3A_nugget">nugget</code></td>
<td>
<p>Value for nugget. Default is -1, which means the nugget was be optimized during MLE. In this case, it is part of bestTheta. Otherwise, <code>nugget</code> is appended to the theta vector. This is only relevant for correlation functions that use a nugget (<code><a href="#topic+corrnoisygauss">corrnoisygauss</a></code>,<code><a href="#topic+corrnoisykriging">corrnoisykriging</a></code> )</p>
</td></tr>
<tr><td><code id="daceFixTheta_+3A_corr">corr</code></td>
<td>
<p>The choice of correlation function (which defines the length and values of theta and bounds): <code><a href="#topic+corrnoisykriging">corrnoisykriging</a></code> (default), <code><a href="#topic+corrkriging">corrkriging</a></code>, <code><a href="#topic+corrnoisygauss">corrnoisygauss</a></code>, <code><a href="#topic+corrgauss">corrgauss</a></code>, <code><a href="#topic+correxp">correxp</a></code>, <code><a href="#topic+correxpg">correxpg</a></code>, <code><a href="#topic+corrlin">corrlin</a></code>, <code><a href="#topic+corrcubic">corrcubic</a></code>,<code><a href="#topic+corrspherical">corrspherical</a></code>,<code><a href="#topic+corrspline">corrspline</a></code>. Can also be user supplied (if in the right form).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list:
<code>thetaConv</code> the fixed theta vector (all model parameters)
<code>theta</code> vector of activity parameters theta
<code>p</code> vector of exponents p(NULL if not used in correlation function)
<code>lambda</code> nugget value lambda (NULL if not used in correlation function)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKrigingDACE">buildKrigingDACE</a></code>
</p>

<hr>
<h2 id='daceGetFit'>Get DACE fit</h2><span id='topic+daceGetFit'></span>

<h3>Description</h3>

<p>Evaluate the fit of a certain set of model parameters (<code>theta</code>), and
get all relevant variables of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daceGetFit(theta, pars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="daceGetFit_+3A_theta">theta</code></td>
<td>
<p>model parameters to be evaluated</p>
</td></tr>
<tr><td><code id="daceGetFit_+3A_pars">pars</code></td>
<td>
<p>model option list, as created with <code><a href="#topic+dacePrepareFit">dacePrepareFit</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of model variables, with the following elements: <br />
<code>regr</code> regression function used <br />
<code>corr</code> correlation function used <br />
<code>theta</code> model parameters<br />
<code>beta</code> generalized least squares estimate<br />
<code>gamma</code> correlation factors<br />
<code>sigma2</code> maximum Likelihood estimate of the process variance<br />
<code>S</code> scaled design points<br />
<code>Ssc</code> scaling factors for design arguments<br />
<code>Y</code> scaled observations<br />
<code>Ysc</code> scaling factors for design ordinates<br />
<code>C</code>  Cholesky factor of correlation matrix<br />
<code>Ft</code> Decorrelated regression matrix<br />
<code>G</code> From QR factorization: Ft = Q*t(G)<br />
</p>


<h3>Author(s)</h3>

<p>The authors of the original DACE Matlab code are Hans Bruun Nielsen, Soren Nymand Lophaven and Jacob Sondergaard. <br />
Extension of the Matlab code by Tobias Wagner <a href="mailto:wagner@isf.de">wagner@isf.de</a>. <br /> 
Porting and adaptation to R and further extensions by Martin Zaefferer <a href="mailto:martin.zaefferer@fh-koeln.de">martin.zaefferer@fh-koeln.de</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKrigingDACE">buildKrigingDACE</a></code> <code><a href="#topic+daceLikelihood">daceLikelihood</a></code> <code><a href="#topic+daceEvalFit">daceEvalFit</a></code>
</p>

<hr>
<h2 id='daceLikelihood'>Wrapper for Maximum Likelihood Estimation</h2><span id='topic+daceLikelihood'></span>

<h3>Description</h3>

<p>Returns the maximum likelihood for the model parameter optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daceLikelihood(theta, pars, nugget)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="daceLikelihood_+3A_theta">theta</code></td>
<td>
<p>model parameter vector to be evaluated</p>
</td></tr>
<tr><td><code id="daceLikelihood_+3A_pars">pars</code></td>
<td>
<p>model option list, as created with <code><a href="#topic+dacePrepareFit">dacePrepareFit</a></code></p>
</td></tr>
<tr><td><code id="daceLikelihood_+3A_nugget">nugget</code></td>
<td>
<p>Value for nugget. Default is -1, which means the nugget was optimized during MLE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the likelihood value as calculated by <code><a href="#topic+daceEvalFit">daceEvalFit</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKrigingDACE">buildKrigingDACE</a></code> <code><a href="#topic+daceEvalFit">daceEvalFit</a></code>
</p>

<hr>
<h2 id='daceObjfunc'>DACE objective function</h2><span id='topic+daceObjfunc'></span>

<h3>Description</h3>

<p>Evaluate the fit of a certain set of model parameters (<code>theta</code>), and
get all relevant variables of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daceObjfunc(theta, pars, what = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="daceObjfunc_+3A_theta">theta</code></td>
<td>
<p>model parameters to be evaluated</p>
</td></tr>
<tr><td><code id="daceObjfunc_+3A_pars">pars</code></td>
<td>
<p>model option list, as created with <code><a href="#topic+dacePrepareFit">dacePrepareFit</a></code></p>
</td></tr>
<tr><td><code id="daceObjfunc_+3A_what">what</code></td>
<td>
<p>a string: &quot;all&quot; both the likelihood (f) and the model list (fit) will be returned, 
&quot;f&quot; and &quot;fit specify to return only those.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two elements (which are NA if <code>what</code> is specified accordingly)<br />
<code>f</code> likelihood <br />
<code>fit</code> also a list list of model variables, with the following elements: 
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p> generalized least squares estimate</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p> correlation factors</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p> maximum Likelihood estimate of the process variance</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p> Cholesky factor of correlation matrix</p>
</td></tr>
<tr><td><code>Ft</code></td>
<td>
<p> Decorrelated regression matrix</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p> From QR factorization: Ft = Q*t(G)<br /></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The authors of the original DACE Matlab code are Hans Bruun Nielsen, Soren Nymand Lophaven and Jacob Sondergaard. <br />
Extension of the Matlab code by Tobias Wagner <a href="mailto:wagner@isf.de">wagner@isf.de</a>. <br /> 
Porting and adaptation to R and further extensions by Martin Zaefferer <a href="mailto:martin.zaefferer@fh-koeln.de">martin.zaefferer@fh-koeln.de</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKrigingDACE">buildKrigingDACE</a></code> <code><a href="#topic+daceLikelihood">daceLikelihood</a></code> <code><a href="#topic+daceEvalFit">daceEvalFit</a></code>
</p>

<hr>
<h2 id='dacePrepareFit'>Prepare DACE fit</h2><span id='topic+dacePrepareFit'></span>

<h3>Description</h3>

<p>Prepares a list with relevant model options and settings based on user choice and problem setup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dacePrepareFit(S, Y, nugget, regr = regpoly0, corr = corrnoisykriging)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dacePrepareFit_+3A_s">S</code></td>
<td>
<p>known design points. That is, a matrix with <code>n</code> rows (for each point) and <code>dim</code> columns (for each dimension).</p>
</td></tr>
<tr><td><code id="dacePrepareFit_+3A_y">Y</code></td>
<td>
<p>vector of observations at known design points of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="dacePrepareFit_+3A_nugget">nugget</code></td>
<td>
<p>Value for nugget. Default is -1, which means the nugget will be optimized during MLE.</p>
</td></tr>
<tr><td><code id="dacePrepareFit_+3A_regr">regr</code></td>
<td>
<p>Regression function to be used: <code><a href="#topic+regpoly0">regpoly0</a></code> (default), <code><a href="#topic+regpoly1">regpoly1</a></code>, <code><a href="#topic+regpoly2">regpoly2</a></code>. Can be a custom user function.</p>
</td></tr>
<tr><td><code id="dacePrepareFit_+3A_corr">corr</code></td>
<td>
<p>Correlation function to be used: <code><a href="#topic+corrnoisykriging">corrnoisykriging</a></code> (default), <code><a href="#topic+corrkriging">corrkriging</a></code>, <code><a href="#topic+corrnoisygauss">corrnoisygauss</a></code>, <code><a href="#topic+corrgauss">corrgauss</a></code>, <code><a href="#topic+correxp">correxp</a></code>, <code><a href="#topic+correxpg">correxpg</a></code>, <code><a href="#topic+corrlin">corrlin</a></code>, <code><a href="#topic+corrcubic">corrcubic</a></code>,<code><a href="#topic+corrspherical">corrspherical</a></code>,<code><a href="#topic+corrspline">corrspline</a></code>. Can also be user supplied (if in the right form).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with several model or problem specific settings and parameters
</p>


<h3>Author(s)</h3>

<p>The authors of the original DACE Matlab code are Hans Bruun Nielsen, Soren Nymand Lophaven and Jacob Sondergaard. <br />
Extension of the Matlab by Tobias Wagner <a href="mailto:wagner@isf.de">wagner@isf.de</a>. <br /> 
Porting and adaptation to R and further extensions by Martin Zaefferer <a href="mailto:martin.zaefferer@fh-koeln.de">martin.zaefferer@fh-koeln.de</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKrigingDACE">buildKrigingDACE</a></code>
</p>

<hr>
<h2 id='daceStartParameters'>Start parameter setup DACE</h2><span id='topic+daceStartParameters'></span>

<h3>Description</h3>

<p>This function returns a starting guess for theta, as well as suitable lower and upper bounds.
The result depends on dimensionality of the problem, number of design points, the nugget value and the choice of correlation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daceStartParameters(n, m, nugget, corr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="daceStartParameters_+3A_n">n</code></td>
<td>
<p>number of known design points</p>
</td></tr>
<tr><td><code id="daceStartParameters_+3A_m">m</code></td>
<td>
<p>dimension (length) of each point</p>
</td></tr>
<tr><td><code id="daceStartParameters_+3A_nugget">nugget</code></td>
<td>
<p>Value for nugget. Default is -1, which means the nugget will be optimized during MLE. In that case, a lower limit of 0.5 and an upper limit of 1 as well as a starting value of 0.999 will added to the three output vectors (theta, lower and upper bounds). This is only relevant for correlation functions that use a nugget (<code><a href="#topic+corrnoisygauss">corrnoisygauss</a></code>,<code><a href="#topic+corrnoisykriging">corrnoisykriging</a></code> )</p>
</td></tr>
<tr><td><code id="daceStartParameters_+3A_corr">corr</code></td>
<td>
<p>The choice of correlation function (which defines the length and values of theta and bounds): <code><a href="#topic+corrnoisykriging">corrnoisykriging</a></code> (default), <code><a href="#topic+corrkriging">corrkriging</a></code>, <code><a href="#topic+corrnoisygauss">corrnoisygauss</a></code>, <code><a href="#topic+corrgauss">corrgauss</a></code>, <code><a href="#topic+correxp">correxp</a></code>, <code><a href="#topic+correxpg">correxpg</a></code>, <code><a href="#topic+corrlin">corrlin</a></code>, <code><a href="#topic+corrcubic">corrcubic</a></code>,<code><a href="#topic+corrspherical">corrspherical</a></code>,<code><a href="#topic+corrspline">corrspline</a></code>. Can also be user supplied (if in the right form).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list with the following elements: <br />
<code>theta</code> Starting point for the internal parameter estimation<br />
<code>lb</code> lower bound<br />
<code>ub</code> upper bound
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKrigingDACE">buildKrigingDACE</a></code>
</p>

<hr>
<h2 id='dataGasSensor'>Gas Sensor Data</h2><span id='topic+dataGasSensor'></span>

<h3>Description</h3>

<p>A data set of a Gas Sensor, similar to the one used by Rebolledo et al. 2016.
It also contains information of 10 different test/training splits, to enable comparable evaluation procedures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataGasSensor
</code></pre>


<h3>Format</h3>

<p>A data frame with 280 rows and 20 columns (1 output, 7 input, 2 disturbance, 10 training/test split) :
</p>

<dl>
<dt>Y</dt><dd><p>Measured Sensor Output</p>
</dd>
<dt>X1</dt><dd><p>Sensor Input 1</p>
</dd>
<dt>X2</dt><dd><p>Sensor Input 2</p>
</dd>
<dt>X3</dt><dd><p>Sensor Input 3</p>
</dd>
<dt>X4</dt><dd><p>Sensor Input 4</p>
</dd>
<dt>X5</dt><dd><p>Sensor Input 5</p>
</dd>
<dt>X6</dt><dd><p>Sensor Input 6</p>
</dd>
<dt>X7</dt><dd><p>Sensor Input 7</p>
</dd>
<dt>Batch</dt><dd><p>Disturbance variable, measurement batch</p>
</dd>
<dt>Sensor</dt><dd><p>Disturbance variable, sensor ID</p>
</dd>
<dt>Set1</dt><dd><p>test/training split, <code>1</code> is training data, <code>2</code> is test data</p>
</dd>
<dt>Set2</dt><dd><p>test/training split</p>
</dd>
<dt>Set3</dt><dd><p>test/training split</p>
</dd>
<dt>Set4</dt><dd><p>test/training split</p>
</dd>
<dt>Set5</dt><dd><p>test/training split</p>
</dd>
<dt>Set6</dt><dd><p>test/training split</p>
</dd>
<dt>Set7</dt><dd><p>test/training split</p>
</dd>
<dt>Set8</dt><dd><p>test/training split</p>
</dd>
<dt>Set9</dt><dd><p>test/training split</p>
</dd>
<dt>Set10</dt><dd><p>test/training split</p>
</dd>
</dl>



<h3>Details</h3>

<p>Two different modeling tasks are of interest for this data set:
<code>Y~X1+X2+X3+X4+X5+X6+X7+Batch+Sensor</code> and
<code>X1~Y+X7+Batch+Sensor</code>.
</p>


<h3>References</h3>

<p>Margarita A. Rebolledo C., Sebastian Krey, Thomas Bartz-Beielstein, Oliver Flasch, Andreas Fischbach and Joerg Stork. <br />
2016.<br />
Modeling and Optimization of a Robust Gas Sensor.<br />
7th International Conference on Bioinspired Optimization Methods and their Applications (BIOMA 2016).<br />
</p>

<hr>
<h2 id='descentSpotRSM'>Descent RSM model</h2><span id='topic+descentSpotRSM'></span>

<h3>Description</h3>

<p>Generate steps along the path of steepest descent for a RSM model.
This is only intended as a manual tool to use together with 
<code><a href="#topic+buildRSM">buildRSM</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>descentSpotRSM(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="descentSpotRSM_+3A_object">object</code></td>
<td>
<p>RSM model (settings and parameters) of class <code>spotRSM</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with
</p>

<dl>
<dt><code>x</code></dt><dd><p>list of points along the path of steepest descent</p>
</dd>
<dt><code>y</code></dt><dd><p>corresponding predicted values</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+buildRSM">buildRSM</a></code>
</p>

<hr>
<h2 id='designLHD'>Latin Hypercube Design Generator</h2><span id='topic+designLHD'></span>

<h3>Description</h3>

<p>Creates a latin Hypercube Design (LHD) with user-specified dimension and number of design points.
LHDs are created repeatedly created at random. For each each LHD, the minimal pair-wise distance between design points is computed.
The design with the maximum of that minimal value is chosen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>designLHD(x = NULL, lower, upper, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="designLHD_+3A_x">x</code></td>
<td>
<p>optional matrix x, rows for points, columns for dimensions. This can contain one or more points which are part of the design, 
but specified by the user. These points are added to the design, 
and are taken into account when calculating the pair-wise distances. 
They do not count for the design size. E.g., if <code>x</code> has two rows, <code>control$replicates</code> is one and <code>control$size</code> is ten, the returned design will have
12 points (12 rows). 
The first two rows will be identical to <code>x</code>. 
Only the remaining ten rows are guaranteed to be a valid LHD.</p>
</td></tr>
<tr><td><code id="designLHD_+3A_lower">lower</code></td>
<td>
<p>vector with lower boundary of the design variables (in case of categorical parameters, please map the respective factor to a set of contiguous integers, e.g., with lower = 1 and upper = number of levels)</p>
</td></tr>
<tr><td><code id="designLHD_+3A_upper">upper</code></td>
<td>
<p>vector with upper boundary of the design variables (in case of categorical parameters, please map the respective factor to a set of contiguous integers, e.g., with lower = 1 and upper = number of levels)</p>
</td></tr>
<tr><td><code id="designLHD_+3A_control">control</code></td>
<td>
<p>list of controls:
</p>

<dl>
<dt><code>size</code></dt><dd><p>number of design points</p>
</dd>
<dt><code>retries</code></dt><dd><p>number of retries during design creation</p>
</dd>
<dt><code>types</code></dt><dd><p>this specifies the data type for each design parameter, as a vector of either &quot;numeric&quot;,&quot;integer&quot;,&quot;factor&quot;. (here, this only affects rounding)</p>
</dd>
<dt><code>inequalityConstraint</code></dt><dd><p>inequality constraint function, smaller zero for infeasible points. Used to replace infeasible points with random points.</p>
</dd>
<dt><code>replicates</code></dt><dd><p>integer for replications of each design point. E.g., if replications is two, every design point will occur twice in the resulting matrix.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix <code>design</code> <br />
- <code>design</code> has <code>length(lower)</code> columns and <code>(size + nrow(x))*control$replicates</code> rows.
All values should be within <code>lower &lt;= design &lt;= upper</code>
</p>


<h3>Author(s)</h3>

<p>Original code by Christian Lasarczyk, adaptations by Martin Zaefferer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1) #set RNG seed to make examples reproducible 
design &lt;- designLHD(,1,2) #simple, 1-D case
design
design &lt;- designLHD(,1,2,control=list(replicates=3)) #with replications
design
design &lt;- designLHD(,c(-1,-2,1,0),c(1,4,9,1),
	control=list(size=5, retries=100, types=c("numeric","integer","factor","factor")))
design
x &lt;- designLHD(,c(1,-10),c(2,10),control=list(size=5,retries=100))
x2 &lt;- designLHD(x,c(1,-10),c(2,10),control=list(size=5,retries=100))
plot(x2)
points(x, pch=19)
</code></pre>

<hr>
<h2 id='designLHDNorm'>Normalized LHD Design</h2><span id='topic+designLHDNorm'></span>

<h3>Description</h3>

<p>Produces a normalized design and calculates the minimal distance 
if required.
A design  is a matrix with <code>dim</code> columns and <code>size</code> rows.
Distance can be calculated with respect to a fixed, nested design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>designLHDNorm(
  dim,
  size,
  calcMinDistance = FALSE,
  nested = NULL,
  inequalityConstraint = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="designLHDNorm_+3A_dim">dim</code></td>
<td>
<p>number, dimension of the problem (will be no. of columns of the result matrix)</p>
</td></tr>
<tr><td><code id="designLHDNorm_+3A_size">size</code></td>
<td>
<p>number of points with that dimension needed. (will be no. of rows of the result matrix).</p>
</td></tr>
<tr><td><code id="designLHDNorm_+3A_calcmindistance">calcMinDistance</code></td>
<td>
<p>Boolean to indicate whether a minimal distance should be calculated.</p>
</td></tr>
<tr><td><code id="designLHDNorm_+3A_nested">nested</code></td>
<td>
<p>nested design to be considered during distance calculation.</p>
</td></tr>
<tr><td><code id="designLHDNorm_+3A_inequalityconstraint">inequalityConstraint</code></td>
<td>
<p>inequality constraint function, smaller zero for infeasible points. Used to replace infeasible points with random points. Has to evaluate points in interval [0;1].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list <code>L</code>  <br />
- <code>L</code> consists of a matrix <code>L$design</code> and (if required) a minimal distance <code>L$minDistance</code>
</p>


<h3>Author(s)</h3>

<p>Original code by Christian Lasarczyk, adaptations by Martin Zaefferer
</p>


<h3>See Also</h3>

<p>This function is used as a basis for <code><a href="#topic+designLHD">designLHD</a></code>.
</p>

<hr>
<h2 id='designUniformRandom'>Uniform Design Generator</h2><span id='topic+designUniformRandom'></span>

<h3>Description</h3>

<p>Create a simple experimental design based on uniform random sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>designUniformRandom(x = NULL, lower, upper, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="designUniformRandom_+3A_x">x</code></td>
<td>
<p>optional data.frame x to be part of the design</p>
</td></tr>
<tr><td><code id="designUniformRandom_+3A_lower">lower</code></td>
<td>
<p>vector with lower boundary of the design variables (in case of categorical parameters, please map the respective factor to a set of contiguous integers, e.g., with lower = 1 and upper = number of levels)</p>
</td></tr>
<tr><td><code id="designUniformRandom_+3A_upper">upper</code></td>
<td>
<p>vector with upper boundary of the design variables (in case of categorical parameters, please map the respective factor to a set of contiguous integers, e.g., with lower = 1 and upper = number of levels)</p>
</td></tr>
<tr><td><code id="designUniformRandom_+3A_control">control</code></td>
<td>
<p>list of controls:<br />
<code>size</code> number of design points<br />
<code>types</code> this specifies the data type for each design parameter, as a vector of either &quot;numeric&quot;,&quot;integer&quot;,&quot;factor&quot;. (here, this only affects rounding)<br />
<code>replicates</code> integer for replications of each design point. E.g., if replications is two, every design point will occur twice in the resulting matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix <code>design</code> <br />
- <code>design</code> has <code>length(lower)</code> columns and <code>(size + nrow(x))*control$replicates</code> rows.
All values should be within <code>lower &lt;= design &lt;= upper</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1) #set RNG seed to make examples reproducible
design &lt;- designUniformRandom(,1,2) #simple, 1-D case
design
design &lt;- designUniformRandom(,1,2,control=list(replicates=3)) #with replications
design
design &lt;- designUniformRandom(,c(-1,-2,1,0),c(1,4,9,1),
		control=list(size=5, types=c("numeric","integer","factor","factor")))
design
x &lt;- designUniformRandom(,c(1,-10),c(2,10),control=list(size=5))
x2 &lt;- designUniformRandom(x,c(1,-10),c(2,10),control=list(size=5))
plot(x2)
points(x, pch=19)
</code></pre>

<hr>
<h2 id='diff0'>diff0</h2><span id='topic+diff0'></span>

<h3>Description</h3>

<p>Calculate differences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff0(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff0_+3A_x">x</code></td>
<td>
<p>input vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input vector length = output vector length
</p>


<h3>Value</h3>

<p>vector of differences
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
diff0(x)
</code></pre>

<hr>
<h2 id='doParallel'>Parallel execution of code, dependent on the operating system</h2><span id='topic+doParallel'></span>

<h3>Description</h3>

<p>mclapply is only supported on linux and macOS. On Windows parlapply should be used.
This function switches between both dependent on the operating system of the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doParallel(X, FUN, nCores = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doParallel_+3A_x">X</code></td>
<td>
<p>vector with arguments to parallelize over</p>
</td></tr>
<tr><td><code id="doParallel_+3A_fun">FUN</code></td>
<td>
<p>function that shall be applied to each element of X</p>
</td></tr>
<tr><td><code id="doParallel_+3A_ncores">nCores</code></td>
<td>
<p><code>integer</code>. Defines the number of cores.</p>
</td></tr>
<tr><td><code id="doParallel_+3A_...">...</code></td>
<td>
<p>optional arguments to FUN</p>
</td></tr>
</table>

<hr>
<h2 id='duplicateAndReplicateHandling'>duplicateAndReplicateHandling</h2><span id='topic+duplicateAndReplicateHandling'></span>

<h3>Description</h3>

<p>Handle Duplicates and Replicates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duplicateAndReplicateHandling(xnew, x, lower, upper, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duplicateAndReplicateHandling_+3A_xnew">xnew</code></td>
<td>
<p>matrix of new candidate solution(s), one row for each solution.</p>
</td></tr>
<tr><td><code id="duplicateAndReplicateHandling_+3A_x">x</code></td>
<td>
<p>matrix of evaluated solutions.</p>
</td></tr>
<tr><td><code id="duplicateAndReplicateHandling_+3A_lower">lower</code></td>
<td>
<p>vector for lower boundary of decision space</p>
</td></tr>
<tr><td><code id="duplicateAndReplicateHandling_+3A_upper">upper</code></td>
<td>
<p>vector for upper boundary of decision space</p>
</td></tr>
<tr><td><code id="duplicateAndReplicateHandling_+3A_control">control</code></td>
<td>
<p>list of controls</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function deals with duplicates, that is, when a candidate solution (<code>xnew</code>)
has already been evaluated (that is, <code>xnew</code> is element of <code>x</code>).
If <code>control$noise</code> is <code>TRUE</code> (objective is noisy), duplicates are allowed.
In that case, this function only makes sure that such duplicates
do not receive additional replications (i.e., the duplicate is evaluated only once).
If the objective is not noisy, duplicates are replaced by randomly created solution
and a warning is given.
</p>


<h3>Value</h3>

<p>matrix <code>xnew</code>, with additional replicates for non-duplicates,
or duplicates replaced by random solutions.
</p>

<hr>
<h2 id='evaluateModel'>Evaluate Model</h2><span id='topic+evaluateModel'></span>

<h3>Description</h3>

<p>This function produces an objective function with y=f(x) from a provided model fit.
Important note: this function expects <code>predict(object,newdata)</code> to return
a list. The <code>object$target</code> parameter is a string that determines which list item
is returned by the created function. If not set (NULL), <code>object$target</code> is set to <code>"y"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluateModel(object, infillCriterion = NULL, verbosity = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluateModel_+3A_object">object</code></td>
<td>
<p>fit created by a modeling function, e.g., <code><a href="#topic+buildRandomForest">buildRandomForest</a></code></p>
</td></tr>
<tr><td><code id="evaluateModel_+3A_infillcriterion">infillCriterion</code></td>
<td>
<p>optional parameter, a function that accepts prediction results and a model object.
The function should use these
to alter the prediction result in a user desired way.
For example turning the prediction results of a kriging model (mean and sd) into the expected
improvement criterion</p>
</td></tr>
<tr><td><code id="evaluateModel_+3A_verbosity">verbosity</code></td>
<td>
<p>verbosity (can be taken from control$verbosity). Default: 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function in the style of <code>y=f(x)</code>, which uses the fitted object
to predict <code>y</code> for sample <code>x</code>.
</p>

<hr>
<h2 id='expectedImprovement'>Expected Improvement</h2><span id='topic+expectedImprovement'></span>

<h3>Description</h3>

<p>Compute the negative logarithm of the Expected Improvement of a 
set of candidate solutions.
Based on mean and standard deviation of a candidate solution,
this estimates the expectation of improvement. Improvement
considers the amount by which the best known value (best observed value)
is exceeded by the candidates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expectedImprovement(mean, sd, min)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expectedImprovement_+3A_mean">mean</code></td>
<td>
<p>vector of predicted means of the candidate solutions.</p>
</td></tr>
<tr><td><code id="expectedImprovement_+3A_sd">sd</code></td>
<td>
<p>vector of estimated uncertainties / standard deviations of the candidate solutions.</p>
</td></tr>
<tr><td><code id="expectedImprovement_+3A_min">min</code></td>
<td>
<p>minimal observed value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with the negative logarithm of the expected improvement values, -log10(EI).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mean &lt;- 1:10 #mean of the candidates
sd &lt;- 10:1 #st. deviation of the candidates
min &lt;- 5 #best known value
EI &lt;- expectedImprovement(mean,sd,min)
EI
</code></pre>

<hr>
<h2 id='funBard'>funBard (No. 14, More No. 8)</h2><span id='topic+funBard'></span>

<h3>Description</h3>

<p>3-dim Bard Test Function
</p>
<p>x0 = (1,1,1)
f = 8.21487...1e-3
f = 17.4286... at (0.8406..., -infty, -infty)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funBard(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funBard_+3A_x">x</code></td>
<td>
<p>matrix of points to evaluate with the function.
Rows for points and columns for dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1-column matrix with resulting function values
</p>


<h3>References</h3>

<p>More, J. J., Garbow, B. S., and  Hillstrom, K. E. (1981).
Testing unconstrained optimization software.
<em>ACM Transactions on Mathematical Software (TOMS)</em>, <em>7</em>(1), 17-41.
<a href="https://doi.org/10.1145/355934.355936">doi:10.1145/355934.355936</a>
</p>
<p>BARD, Y. Comparison of gradient methods for the solution of nonlinear parameter estimation
problems SIAM J. Numer. Anal. 7 (1970), 157-186.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- matrix(c(1,1),1,)
funBard(x1)

</code></pre>

<hr>
<h2 id='funBeale'>funBeale (No.11, More No. 5)</h2><span id='topic+funBeale'></span>

<h3>Description</h3>

<p>2-dim Beale Test Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funBeale(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funBeale_+3A_x">x</code></td>
<td>
<p>matrix of points to evaluate with the function.
Rows for points and columns for dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1-column matrix with resulting function values
</p>


<h3>References</h3>

<p>Beale, E.M.L. On an interactive method of finding a local minimum of a function of more than
one variable. Tech. Rep. No. 25, Statistical Techniques Research Group, Princeton Univ.,
Princeton, N.J., 1958.
</p>
<p>Rosenbrock, H. (1960).
An automatic method for finding the greatest or least value of a function.
<em>The Computer Journal</em>, <em>3</em>(3), 175-184.
<a href="https://doi.org/10.1093/comjnl/3.3.175">doi:10.1093/comjnl/3.3.175</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- matrix(c(1,1),1,)
funBeale(x1)

res &lt;- spot(,funBeale,c(1,-1),c(5,2),control=list(funEvals=15))
plotModel(res$model)

</code></pre>

<hr>
<h2 id='funBox3d'>funbox3D (No. 18, More No. 12)</h2><span id='topic+funBox3d'></span>

<h3>Description</h3>

<p>Box three-dimensional Test Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funBox3d(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funBox3d_+3A_x">x</code></td>
<td>
<p>matrix of points to evaluate with the function.
Rows for points and columns for dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1-column matrix with resulting function values
</p>


<h3>References</h3>

<p>More, J. J., Garbow, B. S., and  Hillstrom, K. E. (1981).
Testing unconstrained optimization software.
<em>ACM Transactions on Mathematical Software (TOMS)</em>, <em>7</em>(1), 17-41.
<a href="https://doi.org/10.1145/355934.355936">doi:10.1145/355934.355936</a>
</p>
<p>Box three - dimensional, (1966).
A comparison of several current optimization methods, and the use of transformations
in constrained problems.
<em>The Computer Journal</em>, <em>3</em>(3), 66-77.
<a href="https://academic.oup.com/comjnl/article/9/1/67/348150">https://academic.oup.com/comjnl/article/9/1/67/348150</a>
</p>
<p>@examples
x &lt;- matrix(c(1,10,1),1,)
funBox3d(x)
</p>
<p>res &lt;- spot(,funBox3d,c(5,15,-5),c(15,5,5),control=list(funEvals=20))
# plotting the graphs
plotModel(res$model,which=1:2)
plotModel(res$model,which=2:3)
plotModel(res$model,which=c(1,3))
</p>

<hr>
<h2 id='funBranin'>funBranin (No. 1)</h2><span id='topic+funBranin'></span>

<h3>Description</h3>

<p>Branin Test Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funBranin(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funBranin_+3A_x">x</code></td>
<td>
<p>matrix of points to evaluate with the function. Rows for points and columns for dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1-column matrix with resulting function values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- matrix(c(-pi, 12.275),1,)
funBranin(x1)

</code></pre>

<hr>
<h2 id='funBrownBs'>funbrownBs (No. 10, More No. 4)</h2><span id='topic+funBrownBs'></span>

<h3>Description</h3>

<p>2-dim Brown badly scaled Test Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funBrownBs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funBrownBs_+3A_x">x</code></td>
<td>
<p>matrix of points to evaluate with the function.
Rows for points and columns for dimension.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>n=2, m=3
x0 = (1,1)
f=0 at (1e6, 2e-6)
</p>


<h3>Value</h3>

<p>1-column matrix with resulting function values
</p>


<h3>References</h3>

<p>More, J. J., Garbow, B. S., and  Hillstrom, K. E. (1981).
Testing unconstrained optimization software.
<a href="https://www.osti.gov/servlets/purl/6650344">https://www.osti.gov/servlets/purl/6650344</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- matrix(c(1,1),1,)
funBrownBs(x1)

res &lt;- spot(,fun=funBrownBs,c(-10,-10),c(10,10),control=list(funEvals=20))
plotModel(res$model, points = rbind(c(res$xbest[1], res$xbest[2]),c(1.098e-5,9.106)))

</code></pre>

<hr>
<h2 id='funCosts'>funCosts</h2><span id='topic+funCosts'></span>

<h3>Description</h3>

<p>optimWrapper for getCosts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funCosts(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funCosts_+3A_x">x</code></td>
<td>
<p>vector: weight multiplier <code>sigma</code> and number of elevators <code>ne</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Evaluate synthetic cost function that is based on the number of waiting customers and 
the number elevators
</p>


<h3>Value</h3>

<p>fitness (costs) as matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sigma = 1
ne = 10 
x &lt;- matrix(c(sigma, ne), 1,)
funCosts(x)

</code></pre>

<hr>
<h2 id='funCyclone'>Objective function - Cyclone Simulation: Barth/Muschelknautz</h2><span id='topic+funCyclone'></span>

<h3>Description</h3>

<p>Calculate cyclone collection efficiency. A simple, physics-based
optimization problem (potentially bi-objective). See the references [1,2].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funCyclone(
  x,
  deterministic = c(TRUE, TRUE, TRUE),
  cyclone = list(Da = 1.26, H = 2.5, Dt = 0.42, Ht = 0.65, He = 0.6, Be = 0.2),
  fluid = list(Mu = 1.85e-05, Ve = (50/36)/0.12, lambdag = 1/200, Rhop = 2000, Rhof =
    1.2, Croh = 0.05),
  noiseLevel = list(Vp = 0.1, Rhop = 0.05),
  model = "Barth-Muschelknautz",
  intervals = c(0, 2, 4, 6, 8, 10, 15, 20, 30) * 1e-06,
  delta = c(0, 0.02, 0.03, 0.05, 0.1, 0.3, 0.3, 0.2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funCyclone_+3A_x">x</code></td>
<td>
<p>vector of length at least one and up to six, specifying non-default geometrical parameters in [m]: Da, H, Dt, Ht, He, Be</p>
</td></tr>
<tr><td><code id="funCyclone_+3A_deterministic">deterministic</code></td>
<td>
<p>binary vector. First element specifies whether volume flow is deterministic or not. Second element specifies whether particle density is deterministic or not. Third element specifies whether particle diameters are deterministic or not. Default: All are deterministic (TRUE).</p>
</td></tr>
<tr><td><code id="funCyclone_+3A_cyclone">cyclone</code></td>
<td>
<p>list of a default cyclone's geometrical parameters: fluid$Da, fluid$H, fluid$Dt, fluid$Ht, fluid$He and fluid$Be</p>
</td></tr>
<tr><td><code id="funCyclone_+3A_fluid">fluid</code></td>
<td>
<p>list of default fluid parameters: fluid$Mu, fluid$Vp, fluid$Rhop, fluid$Rhof and fluid$Croh</p>
</td></tr>
<tr><td><code id="funCyclone_+3A_noiselevel">noiseLevel</code></td>
<td>
<p>list of noise levels for volume flow (noiseLevel$Vp) and particle density (noiseLevel$Rhop), only used if non-deterministic.</p>
</td></tr>
<tr><td><code id="funCyclone_+3A_model">model</code></td>
<td>
<p>type of the model (collection efficiency only): either &quot;Barth-Muschelknautz&quot; or &quot;Mothes&quot;</p>
</td></tr>
<tr><td><code id="funCyclone_+3A_intervals">intervals</code></td>
<td>
<p>vector specifying the particle size interval bounds.</p>
</td></tr>
<tr><td><code id="funCyclone_+3A_delta">delta</code></td>
<td>
<p>vector of densities in each interval (specified by intervals). Should have one element less than the intervals parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a function that calculates the fractional efficiency for the specified diameter, see example.
</p>


<h3>References</h3>

<p>[1] Zaefferer, M.; Breiderhoff, B.; Naujoks, B.; Friese, M.; Stork, J.; Fischbach, A.; Flasch, O.; Bartz-Beielstein, T. Tuning Multi-objective Optimization Algorithms for Cyclone Dust Separators Proceedings of the 2014 Conference on Genetic and Evolutionary Computation, ACM, 2014, 1223-1230 <br /><br />
[2] Breiderhoff, B.; Bartz-Beielstein, T.; Naujoks, B.; Zaefferer, M.; Fischbach, A.; Flasch, O.; Friese, M.; Mersmann, O.; Stork, J.; Simulation and Optimization of Cyclone Dust Separators Proceedings 23. Workshop Computational Intelligence, 2013, 177-196
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Call directly
funCyclone(c(1.26,2.5))
## create vectorized target funcion, vectorized, first objective only
## Also: negated, since SPOT always does minimization.
tfunvecF1 &lt;-function(x){-apply(x,1,funCyclone)[1,]}
tfunvecF1(matrix(c(1.26,2.5,1,2),2,2,byrow=TRUE))
## optimize with spot
res &lt;- spot(fun=tfunvecF1,lower=c(1,2),upper=c(2,3),
   control=list(modelControl=list(target="ei"),
   model=buildKriging,optimizer=optimLBFGSB,plots=TRUE)) 
## best found solution ...
res$xbest
## ... and its objective function value
res$ybest

</code></pre>

<hr>
<h2 id='funError'>funError</h2><span id='topic+funError'></span>

<h3>Description</h3>

<p>Simulate NAs, Infs, NaNs in results from objective function evaluations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funError(x, prob = 0.1, errorList = list(NA, Inf, NaN), outDim = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funError_+3A_x">x</code></td>
<td>
<p>input vector or matrix of candidate solution</p>
</td></tr>
<tr><td><code id="funError_+3A_prob">prob</code></td>
<td>
<p>error probability (0&lt;prob&lt;1). Default: 0.1</p>
</td></tr>
<tr><td><code id="funError_+3A_errorlist">errorList</code></td>
<td>
<p>list with error types. Default: <code>list(NA, Inf, NaN)</code></p>
</td></tr>
<tr><td><code id="funError_+3A_outdim">outDim</code></td>
<td>
<p>dimension of the output matrix (number of columns)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Results from <code><a href="#topic+funSphere">funSphere</a></code> are replaced with <code>NA</code>, <code>NaN</code>, and <code>Inf</code>
values.
</p>


<h3>Value</h3>

<p>vector of objective function values
</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+is.finite">is.finite</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
require(SPOT)
x &lt;- matrix(1:10, 5,2)
y &lt;- funError(x)
any(is.na(y))
## two-dim output
funError(x,outDim=2)
funError(x,outDim=2, prob=0.1)


</code></pre>

<hr>
<h2 id='funFreudRoth'>funFreudRoth (No. 8, More No. 2)</h2><span id='topic+funFreudRoth'></span>

<h3>Description</h3>

<p>2-dim Freudenstein and Roth Test Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funFreudRoth(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funFreudRoth_+3A_x">x</code></td>
<td>
<p>matrix of points to evaluate with the function.
Rows for points and columns for dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1-column matrix with resulting function values
</p>


<h3>References</h3>

<p>More, J. J., Garbow, B. S., and  Hillstrom, K. E. (1981).
Testing unconstrained optimization software.
<em>ACM Transactions on Mathematical Software (TOMS)</em>, <em>7</em>(1), 17-41.
<a href="https://doi.org/10.1145/355934.355936">doi:10.1145/355934.355936</a>
</p>
<p>B. Freudenstein, F., and Roth, B. (Oct. 1963).
Numerical solutions of systems of nonlinear equations.
<em>The ACM Journal</em>, <em>3</em>(3), 550-556.
<a href="https://dl.acm.org/doi/10.1145/321186.321200">https://dl.acm.org/doi/10.1145/321186.321200</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- matrix(c(1,1),1,)
funFreudRoth(x1)

# Running SPOT with 20 function evaluations with default configurations
res &lt;- spot(,funFreudRoth,c(0,0),c(10,10),control=list(funEvals=20))
plotModel(res$model)

</code></pre>

<hr>
<h2 id='funGauss'>funGauss (No. 15, More No. 9)</h2><span id='topic+funGauss'></span>

<h3>Description</h3>

<p>3-dim Gaussian Test Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funGauss(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funGauss_+3A_x">x</code></td>
<td>
<p>matrix of points to evaluate with the function.
Rows for points and columns for dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1-column matrix with resulting function values
</p>


<h3>References</h3>

<p>Unpublished
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- matrix(c(1,1,1),1,)
funGauss(x1)

res1 &lt;- spot(,funGauss,
  c(-0.001,-0.007,-0.003),
  c(0.5,1.0,1.1),
  control=list(funEvals=15))
  plotModel(res1$model, which = 1:2)

</code></pre>

<hr>
<h2 id='funGoldsteinPrice'>Goldstein-Price Test Function (No. 5)</h2><span id='topic+funGoldsteinPrice'></span>

<h3>Description</h3>

<p>An implementation of Booker et al.’s method on
a re-scaled/coded version of the 2-dim Goldstein–Price function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funGoldsteinPrice(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funGoldsteinPrice_+3A_x">x</code></td>
<td>
<p>(<code>m,2</code>)-matrix of points to evaluate with the function.
Rows for points and columns for dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1-column matrix with resulting function values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- matrix(c(-pi, 12.275),1,)
funGoldsteinPrice(x1)

</code></pre>

<hr>
<h2 id='funGulf'>funGulf (No.17, More No. 11)</h2><span id='topic+funGulf'></span>

<h3>Description</h3>

<p>3-dim Gulf research and development Test Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funGulf(x, m = 99)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funGulf_+3A_x">x</code></td>
<td>
<p>matrix (n x 3) of points to evaluate with the function. 
Rows for points and columns for dimension.
Values should be larger than 0.</p>
</td></tr>
<tr><td><code id="funGulf_+3A_m">m</code></td>
<td>
<p>additional parameter: .
The Gulf function supports an additional parameter m in the range from 3 to 100</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1-column matrix with resulting function values
</p>


<h3>References</h3>

<p>More, J. J., Garbow, B. S., and  Hillstrom, K. E. (1981).
Testing unconstrained optimization software.
<em>ACM Transactions on Mathematical Software (TOMS)</em>, <em>7</em>(1), 17-41.
<a href="https://doi.org/10.1145/355934.355936">doi:10.1145/355934.355936</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- matrix(c(50,25,1.5),1,)
funGulf(x1)

funGulf(x1,m=50)

resGulf &lt;- spot(,funGulf,c(0,0,0),c(100,50,5))
resGulf$xbest
resGulf$ybest
plotModel(resGulf$model, which=1:2)
plotModel(resGulf$model, which=2:3)

# x0 is an optional start point (or set of start points), specified as a matrix.
# One row for each point, and one column for each optimized parameter.
x0 = matrix(c(5,2.5,0.15),1,3)
resGulf &lt;- spot(x0,funGulf,c(0,0,0),c(100,50,5))
resGulf$xbest
resGulf$ybest

</code></pre>

<hr>
<h2 id='funHelical'>funHelical (No. 13, More No. 7)</h2><span id='topic+funHelical'></span>

<h3>Description</h3>

<p>3-dim Helical Test Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funHelical(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funHelical_+3A_x">x</code></td>
<td>
<p>matrix (n x 3)-dim of points to evaluate with the function.
Rows for points and columns for dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1-column matrix with resulting function values
</p>


<h3>References</h3>

<p>More', J. J., Garbow, B. S., and  Hillstrom, K. E. (1981).
Testing unconstrained optimization software.
<em>ACM Transactions on Mathematical Software (TOMS)</em>, <em>7</em>(1), 17-41.
<a href="https://doi.org/10.1145/355934.355936">doi:10.1145/355934.355936</a>
</p>
<p>Fletcher, R., and  Powell, M. J. (1963).
A rapidly convergent descent method for minimization.
<em>The Computer Journal</em>, <em>6</em>(2), 163-168.
<a href="https://doi.org/10.1093/comjnl/6.2.163">doi:10.1093/comjnl/6.2.163</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- matrix(c(1,1,1),1,)
funHelical(x1)
res &lt;- spot(,funHelical,c(-40,-40,-40),c(40,40,40),control=list(funEvals=20))
plotModel(res$model,which=c(1,2),type="persp",border="NA")
plotModel(res$model,which=c(2,3),type="persp",border="NA")
plotModel(res$model,which=c(1,3),type="persp",border="NA")
plotModel(res$model, which=c(1,2))
plotModel(res$model, which=c(1,3))
plotModel(res$model, which=c(2,3))

</code></pre>

<hr>
<h2 id='funIshigami'>Ishigami Test Function (No. 7)</h2><span id='topic+funIshigami'></span>

<h3>Description</h3>

<p>An implementation of the 3-dim Ishigami function.
</p>
<p>f(x) = sin(x_1) + a sin^2(x_2) + b x_3^4sin(x_1)
</p>
<p>The Ishigami function of Ishigami &amp; Homma (1990) is used as an example for
uncertainty and sensitivity analysis methods,
because it exhibits strong nonlinearity and nonmonotonicity.
It also has a peculiar dependence on x_3, as described by Sobol' &amp; Levitan (1999).
The independent distributions of the input random variables are usually:
x_i ~ Uniform[-pi, pi ], for all i = 1, 2, 3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funIshigami(x, a = 7, b = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funIshigami_+3A_x">x</code></td>
<td>
<p>(<code>m,3</code>)-matrix of points to evaluate with the function.
Values should be &gt;= -pi and &lt;= pi, i.e., x_i in [-pi,pi].</p>
</td></tr>
<tr><td><code id="funIshigami_+3A_a">a</code></td>
<td>
<p>coefficient (optional), with default value 7</p>
</td></tr>
<tr><td><code id="funIshigami_+3A_b">b</code></td>
<td>
<p>coefficient (optional), with default value 0.1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1-column matrix with resulting function values
</p>


<h3>References</h3>

<p>Ishigami, T., &amp; Homma, T. (1990, December).
An importance quantification technique in uncertainty analysis for computer models.
In Uncertainty Modeling and Analysis, 1990. Proceedings.,
First International Symposium on (pp. 398-403). IEEE.
</p>
<p>Sobol', I. M., &amp; Levitan, Y. L. (1999). On the use of variance reducing
multipliers in Monte Carlo computations of a global sensitivity index.
Computer Physics Communications, 117(1), 52-61.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- matrix(c(-pi, 0, pi),1,)
funIshigami(x1)

</code></pre>

<hr>
<h2 id='funJennSamp'>funJennSamp (No. 12, More No 6)</h2><span id='topic+funJennSamp'></span>

<h3>Description</h3>

<p>2-dim Jennrich and Sampson Function Test Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funJennSamp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funJennSamp_+3A_x">x</code></td>
<td>
<p>matrix of points to evaluate with the function.
Rows for points and columns for dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1-column matrix with resulting function values
</p>


<h3>References</h3>

<p>More, J. J., Garbow, B. S., &amp; Hillstrom, K. E. (1981).
Testing unconstrained optimization software.
<em>ACM Transactions on Mathematical Software (TOMS)</em>, <em>7</em>(1), 17-41.
<a href="https://doi.org/10.1145/355934.355936">doi:10.1145/355934.355936</a>
</p>
<p>Jennrich, R.I., and Sampson (1968).
Application of stepwise regression to nonlinear estimation.
<em>Technometrics</em>, <em>3</em>(3), 63-72.
<a href="https://www.tandfonline.com/doi/abs/10.1080/00401706.1968.10490535">https://www.tandfonline.com/doi/abs/10.1080/00401706.1968.10490535</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- matrix(c(1,1),1,)
funJennSamp(x1)

res &lt;- spot(,funJennSamp,c(0,0),c(0.3,0.3))
plotModel(res$model)

</code></pre>

<hr>
<h2 id='funMeyer'>funMeyer (No. 16, More No. 10)</h2><span id='topic+funMeyer'></span>

<h3>Description</h3>

<p>Meyer 3-dim Test Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funMeyer(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funMeyer_+3A_x">x</code></td>
<td>
<p>matrix (dim 1x3) of points to evaluate with the function.
Rows for points and columns for dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1-column matrix with resulting function values
</p>


<h3>References</h3>

<p>More, J. J., Garbow, B. S., and Hillstrom, K. E. (1981).
Testing unconstrained optimization software.
<em>ACM Transactions on Mathematical Software (TOMS)</em>, <em>7</em>(1), 17-41.
<a href="https://doi.org/10.1145/355934.355936">doi:10.1145/355934.355936</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- matrix(c(1,1,1),1,)
funMeyer(x1)

set.seed(13)
resMeyer &lt;- spot(matrix(c(0.02,4000,250),1,3),
  funMeyer,c(0,1000,200),c(3,8000,500),
  control= list(funEvals=15))
resMeyer$xbest
resMeyer$ybest
print("Model with parameters")
plotModel(resMeyer$model)
plotModel(resMeyer$model,which=2:3)

</code></pre>

<hr>
<h2 id='funMoo'>funMoo</h2><span id='topic+funMoo'></span>

<h3>Description</h3>

<p>Multi-objective Test Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funMoo(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funMoo_+3A_x">x</code></td>
<td>
<p>matrix of points to evaluate with the function. Rows for points and columns for dimension.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>funMultiObjectiveOptimization 
</p>
<p>A multiobjective dummy testfunction
</p>


<h3>Value</h3>

<p>n-column matrix with resulting function values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- matrix(c(-pi, 12.275),1,)
funMoo(x1)
x &lt;- matrix(c(1,1,2), ncol=3 )

</code></pre>

<hr>
<h2 id='funNoise'>funNoise</h2><span id='topic+funNoise'></span>

<h3>Description</h3>

<p>noise function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funNoise(x, fun = funSphere, mean = 0, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funNoise_+3A_x">x</code></td>
<td>
<p>input matrix of candidate solution</p>
</td></tr>
<tr><td><code id="funNoise_+3A_fun">fun</code></td>
<td>
<p>objective function. Default: <code>funSphere</code></p>
</td></tr>
<tr><td><code id="funNoise_+3A_mean">mean</code></td>
<td>
<p>error mean. Default: 1</p>
</td></tr>
<tr><td><code id="funNoise_+3A_sigma">sigma</code></td>
<td>
<p>error sd. Default: 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of noisy objective function values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
require(SPOT)
x &lt;- matrix(1:10, 5,2)
funNoise(x)

</code></pre>

<hr>
<h2 id='funOptimLecture'>funOptimLecture</h2><span id='topic+funOptimLecture'></span>

<h3>Description</h3>

<p>A testfunction used in the optimizaton lecture of the AIT Masters course at TH Koeln
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funOptimLecture(vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funOptimLecture_+3A_vec">vec</code></td>
<td>
<p>input vector or matrix of candidate solution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of objective function values
</p>

<hr>
<h2 id='funPowellBs'>funPowellBs (No. 9, More No. 3)</h2><span id='topic+funPowellBs'></span>

<h3>Description</h3>

<p>2-dim Powell Badly Scaled Test Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funPowellBs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funPowellBs_+3A_x">x</code></td>
<td>
<p>matrix of points to evaluate with the function.
Rows for points and columns for dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1-column matrix with resulting function values
</p>


<h3>References</h3>

<p>More, J. J., Garbow, B. S., and  Hillstrom, K. E. (1981).
Testing unconstrained optimization software.
<em>ACM Transactions on Mathematical Software (TOMS)</em>, <em>7</em>(1), 17-41.
<a href="https://doi.org/10.1145/355934.355936">doi:10.1145/355934.355936</a>
</p>
<p>Powell, M.J.D. (1970).
A hybrid method for nonlinear equations.
In Numerical methods for Nonlinear Algebraic Equations,
P. Rabinowitz (Ed),
<em>Gordon &amp; Breach, New York.</em>, <em>3</em>(3), 87-114.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- matrix(c(-1,1),1,)
funPowellBs(x1)

# Running SPOT with 20 function evaluations with default configurations
res &lt;- spot(,fun=funPowellBs,c(-10,-10),c(10,10),control=list(funEvals=20))
plotModel(res$model, points = rbind(c(res$xbest[1], res$xbest[2]),c(1.098e-5,9.106)))

</code></pre>

<hr>
<h2 id='funPowellS'>funPowellS (No. 19, More No. 13)</h2><span id='topic+funPowellS'></span>

<h3>Description</h3>

<p>Powells 4-dim Test Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funPowellS(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funPowellS_+3A_x">x</code></td>
<td>
<p>matrix (dim 1x4) of points to evaluate with the function.
Rows for points and columns for dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1-column matrix with resulting function values
</p>


<h3>References</h3>

<p>More, J. J., Garbow, B. S., and  Hillstrom, K. E. (1981).
Testing unconstrained optimization software.
Trond Steihaug and Sara Suleiman
Global convergence and the Powell singular function
<em>ACM Transactions on Mathematical Software (TOMS)</em>, <em>7</em>(1), 17-41.
<a href="https://doi.org/10.1145/355934.355936">doi:10.1145/355934.355936</a>
<a href="http://owos.gm.fh-koeln.de:8055/bartz/optimization-ait-master-2020/blob/master/Jupyter.d/Exercise-VIIa.ipynb">http://owos.gm.fh-koeln.de:8055/bartz/optimization-ait-master-2020/blob/master/Jupyter.d/Exercise-VIIa.ipynb</a>
<a href="http://bab10.bartzandbartz.de:8033/bartzbeielstein/bab-optimization-ait-master-2020/-/blob/master/Jupyter.d/01spotNutshell.ipynb">http://bab10.bartzandbartz.de:8033/bartzbeielstein/bab-optimization-ait-master-2020/-/blob/master/Jupyter.d/01spotNutshell.ipynb</a>
<a href="https://www.mat.univie.ac.at/~neum/glopt/bounds.html">https://www.mat.univie.ac.at/~neum/glopt/bounds.html</a>
</p>
<p>Powells Test function, M. J. D. Powell, 1962
An automatic method for finding the local minimum of a function.
<em>The Computer Journal</em>, <em>3</em>(3), 175-184.
<a href="https://www.sfu.ca/~ssurjano/powell.html">https://www.sfu.ca/~ssurjano/powell.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- matrix(c(0,0,0,0),1,)
funPowellS(x1)
x2 &lt;- matrix(c(3,-1,0,1),1,)
funPowellS(x2)
x3 &lt;- matrix(c(0,0,0,-2),1,)
funPowellS(x3)
# optimization run with SPOT and 15 evaluations
res_fun &lt;- spot(,funPowellS,c(-4,-4,-4,-4 ),c(5,5,5,5),control=list(funEvals=15))
res_fun

</code></pre>

<hr>
<h2 id='funRosen'>funRosen (No. 2, More No. 1)</h2><span id='topic+funRosen'></span>

<h3>Description</h3>

<p>Rosenbrock Test Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funRosen(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funRosen_+3A_x">x</code></td>
<td>
<p>matrix of points to evaluate with the function. Rows for points and columns for dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1-column matrix with resulting function values
</p>


<h3>References</h3>

<p>More, J. J., Garbow, B. S., and  Hillstrom, K. E. (1981).
Testing unconstrained optimization software.
<em>ACM Transactions on Mathematical Software (TOMS)</em>, <em>7</em>(1), 17-41.
<a href="https://doi.org/10.1145/355934.355936">doi:10.1145/355934.355936</a>
</p>
<p>Rosenbrock, H. (1960).
An automatic method for finding the greatest or least value of a function.
<em>The Computer Journal</em>, <em>3</em>(3), 175-184.
<a href="https://doi.org/10.1093/comjnl/3.3.175">doi:10.1093/comjnl/3.3.175</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- matrix(c(1,1),1,)
funRosen(x1)

</code></pre>

<hr>
<h2 id='funRosen2'>funRosen2 (No. 2a)</h2><span id='topic+funRosen2'></span>

<h3>Description</h3>

<p>Rosenbrock Test Function (2-dim)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funRosen2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funRosen2_+3A_x">x</code></td>
<td>
<p>matrix of points to evaluate with the function. Rows for points and columns for dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1-column matrix with resulting function values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- matrix(c(-pi, 12.275),1,)
funRosen2(x1)

</code></pre>

<hr>
<h2 id='funShiftedSphere'>funShiftedSphere (No. 4)</h2><span id='topic+funShiftedSphere'></span>

<h3>Description</h3>

<p>Shifted Sphere Test Function with optimum at x_opt = a and f(x_opt) = 0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funShiftedSphere(x, a = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funShiftedSphere_+3A_x">x</code></td>
<td>
<p>matrix of points to evaluate with the function. Rows for points and columns for dimension.</p>
</td></tr>
<tr><td><code id="funShiftedSphere_+3A_a">a</code></td>
<td>
<p>offset added, i.e., f = sum (x-a)^2. Default: <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1-column matrix with resulting function values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funSphere">funSphere</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- matrix(c(-pi, 12.275),1,)
a &lt;- 1
funShiftedSphere(x1, a)

</code></pre>

<hr>
<h2 id='funSoblev99'>Sobol and Levitan Test Function (No. 6)</h2><span id='topic+funSoblev99'></span>

<h3>Description</h3>

<p>An implementation of the Sobol-Levitan function.
</p>
<p>f(x) = exp(sum b_i x_i) - I_d + c_0, where
I_d = prod( (exp(b_i) -1) / b_i)
</p>
<p>The value of the elements in the b-vector (b1, ..., bd) affect the importance
of the corresponding x-variables.
Sobol' &amp; Levitan (1999) use two different b-vectors:
(1.5, 0.9, 0.9, 0.9, 0.9, 0.9), for d = 6, and
(0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.4, 0.4, 0.4, 0.4, 0.4,
0.4, 0.4, 0.4, 0.4, 0.4), for d = 20.
Our implementation uses the default b vector:
b = c(0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6,
0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4) (when d&lt;=20).
</p>
<p>Moon et al. (2012) scale the output to have a variance of 100.
For d = 20, they use three different b-vectors:
(2, 1.95, 1.9, 1.85, 1.8, 1.75, 1.7, 1.65, 0.4228, 0.3077, 0.2169, 0.1471,
0.0951, 0.0577, 0.0323, 0.0161, 0.0068, 0.0021, 0.0004, 0),
(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), and
(2.6795, 2.2289, 1.8351, 1.4938, 1.2004, 0.9507, 0.7406, 0.5659, 0.4228,
0.3077, 0.2169, 0.1471, 0.0951, 0.0577, 0.0323, 0.0161, 0.0068, 0.0021, 0.0004, 0).
</p>
<p>The generally used value of c0 is c0 = 0.
The function is evaluated on xi in [0, 1], for all i = 1, ..., d.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funSoblev99(x, b = c(rep(0.6, 10), rep(0.4, 10)), c0 = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funSoblev99_+3A_x">x</code></td>
<td>
<p>(<code>m,2</code>)-matrix of points to evaluate with the function.
Values should be &gt;= 0 and &lt;= 1, i.e., x_i in [0,1].</p>
</td></tr>
<tr><td><code id="funSoblev99_+3A_b">b</code></td>
<td>
<p>d-dimensional vector (optional), with default value
b = c(0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6,
0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4) (when d&lt;=20)</p>
</td></tr>
<tr><td><code id="funSoblev99_+3A_c0">c0</code></td>
<td>
<p>constant term (optional), with default value 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1-column matrix with resulting function values
</p>


<h3>References</h3>

<p>Moon, H., Dean, A. M., &amp; Santner, T. J. (2012).
Two-stage sensitivity-based group screening in computer experiments.
Technometrics, 54(4), 376-387.
</p>
<p>Sobol', I. M., &amp; Levitan, Y. L. (1999). On the use of variance reducing
multipliers in Monte Carlo computations of a global sensitivity index.
Computer Physics Communications, 117(1), 52-61.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- matrix(c(-pi, 12.275),1,)
funSoblev99(x1)

</code></pre>

<hr>
<h2 id='funSphere'>funSphere (No. 3)</h2><span id='topic+funSphere'></span>

<h3>Description</h3>

<p>Sphere Test Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funSphere(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funSphere_+3A_x">x</code></td>
<td>
<p>matrix of points to evaluate with the function. Rows for points and columns for dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1-column matrix with resulting function values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funShiftedSphere">funShiftedSphere</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- matrix(c(-pi, 12.275),1,)
funSphere(x1)

</code></pre>

<hr>
<h2 id='funSring'>funSring</h2><span id='topic+funSring'></span>

<h3>Description</h3>

<p>wrapper for <code><a href="#topic+sring">sring</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funSring(x, opt = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funSring_+3A_x">x</code></td>
<td>
<p>perceptron weights</p>
</td></tr>
<tr><td><code id="funSring_+3A_opt">opt</code></td>
<td>
<p>list of optional parameters, e.g., 
</p>

<dl>
<dt><code>nElevators</code></dt><dd><p>number of elevators</p>
</dd>
<dt><code>probNewCustomer</code></dt><dd><p>probability pf a customer arrival</p>
</dd>
<dt><code>nIterations</code></dt><dd><p>Number of itertions</p>
</dd>
<dt><code>randomSeed</code></dt><dd><p>random seed</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="funSring_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fitness (matrix with one column)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
numberStates = 200
sigma = 1
x = matrix( rnorm(n = 2*numberStates, 1, sigma), 1,)
funSring(x)

</code></pre>

<hr>
<h2 id='getCorrelationMatrix'>getCorrelationMatrix</h2><span id='topic+getCorrelationMatrix'></span>

<h3>Description</h3>

<p>Compute Correlation Matrix. 
Compute the correlation matrix of samples x, given the model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCorrelationMatrix(object, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCorrelationMatrix_+3A_object">object</code></td>
<td>
<p>fit of the Kriging model (settings and parameters), of class <code>kriging</code>.</p>
</td></tr>
<tr><td><code id="getCorrelationMatrix_+3A_x">x</code></td>
<td>
<p>list of samples / data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the correlation matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.kriging">simulate.kriging</a></code>
</p>
<p><code><a href="#topic+predict.kriging">predict.kriging</a></code>
</p>

<hr>
<h2 id='getCosts'>getCosts</h2><span id='topic+getCosts'></span>

<h3>Description</h3>

<p>Evaluate synthetic cost function that is based on the number of waiting customers and 
the number elevators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCosts(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCosts_+3A_x">x</code></td>
<td>
<p>vector with <code>sigma</code> weight multiplier and <code>ne</code> number of elevators</p>
</td></tr>
<tr><td><code id="getCosts_+3A_...">...</code></td>
<td>
<p>optional parameters passed to <code>funSring</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: To accelerate testing, nIterations was set to 1e3 (instead of 1e6)
</p>


<h3>Value</h3>

<p>fitness (costs)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
sigma = 1
ne = 10
x &lt;- c(sigma, ne)
getCosts(x)

</code></pre>

<hr>
<h2 id='getMultiStartPoints'>Get Multi Start Points</h2><span id='topic+getMultiStartPoints'></span>

<h3>Description</h3>

<p>Determine multi start points for optimization on the surrogate.
Combines the current best with additional random starting points for
optimization on the surrogate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMultiStartPoints(x, y, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMultiStartPoints_+3A_x">x</code></td>
<td>
<p>matrix of design points</p>
</td></tr>
<tr><td><code id="getMultiStartPoints_+3A_y">y</code></td>
<td>
<p>matrix of function values (f(x))</p>
</td></tr>
<tr><td><code id="getMultiStartPoints_+3A_control">control</code></td>
<td>
<p>Control list for <code><a href="#topic+spot">spot</a></code> and <code><a href="#topic+spotLoop">spotLoop</a></code>.
Generated with <code><a href="#topic+spotControl">spotControl</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x0 matrix of restart points
</p>

<hr>
<h2 id='getNatDesignFromCoded'>Get natural parameter values from coded +-1 representation</h2><span id='topic+getNatDesignFromCoded'></span>

<h3>Description</h3>

<p>For given lower and upper bounds, a and b, respectively,
coded input values are mapped to their natural values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNatDesignFromCoded(x, a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNatDesignFromCoded_+3A_x">x</code></td>
<td>
<p>(n,m)-dim <code>matrix</code> of coded values, i.e., lower values
are coded as -1, upper values as +1.</p>
</td></tr>
<tr><td><code id="getNatDesignFromCoded_+3A_a">a</code></td>
<td>
<p>m-dim <code>vector</code> of lower bounds (natural values)</p>
</td></tr>
<tr><td><code id="getNatDesignFromCoded_+3A_b">b</code></td>
<td>
<p>m-dim <code>vector</code> of upper bounds (natural values)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rep(-1,2),1,)
lower &lt;- c(-10,-10)
upper &lt;- c(10,10)
getNatDesignFromCoded(x, a = lower, b=upper)
</code></pre>

<hr>
<h2 id='getPerformanceStats'>get performance stats</h2><span id='topic+getPerformanceStats'></span>

<h3>Description</h3>

<p>determines mean performance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPerformanceStats(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPerformanceStats_+3A_x">x</code></td>
<td>
<p>matrix of n solutions (usually a (nxd)-matrix, where d is the problem dimension)</p>
</td></tr>
<tr><td><code id="getPerformanceStats_+3A_y">y</code></td>
<td>
<p>matrix with objective values (usually a (nx1)-matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>further stats will be added
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1:10, ncol=2, byrow=TRUE)
y1 &lt;- funSphere(x) +1
y2 &lt;- funSphere(x) -1
x &lt;- rbind(x,x)
y &lt;- rbind(y1, y2)
M &lt;- getPerformanceStats(x,y)

</code></pre>

<hr>
<h2 id='getPositions'>get impute positions</h2><span id='topic+getPositions'></span>

<h3>Description</h3>

<p>Determines positions in a vectors
that fulfill criteria defined by a list
of criteria, e.g., <code>is.na</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPositions(y, imputeCriteriaFuns = list(is.na, is.infinite, is.nan))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPositions_+3A_y">y</code></td>
<td>
<p>The vector of numerics from which NA/Inf values should be removed</p>
</td></tr>
<tr><td><code id="getPositions_+3A_imputecriteriafuns">imputeCriteriaFuns</code></td>
<td>
<p><code>list</code> criteria functions specified via
<code>imputeCriteriaFuns</code> in <code><a href="#topic+spotControl">spotControl</a></code>.
Default: <code>list(is.na, is.infinite, is.nan)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p vector of positions that fulfill one of the criteria
</p>


<h3>Examples</h3>

<pre><code class='language-R'>imputeCriteriaFuns &lt;- list(is.na, is.infinite, is.nan)
y &lt;- c(1,2,Inf,4,NA,6)
p &lt;- getPositions(y, imputeCriteriaFuns)
</code></pre>

<hr>
<h2 id='getPower'>getPower</h2><span id='topic+getPower'></span>

<h3>Description</h3>

<p>Implements basic power calculations in R
See also: <a href="https://www.cyclismo.org/tutorial/R/power.html">https://www.cyclismo.org/tutorial/R/power.html</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPower(mu0, mu1, n, sigma, alpha, tdist = FALSE, alternative = "greater")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPower_+3A_mu0">mu0</code></td>
<td>
<p>mean value of the null hypothesis (usually referred to as H0)</p>
</td></tr>
<tr><td><code id="getPower_+3A_mu1">mu1</code></td>
<td>
<p>mean value of the alternative hypothesis (usually referred to as H1)</p>
</td></tr>
<tr><td><code id="getPower_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="getPower_+3A_sigma">sigma</code></td>
<td>
<p>sample s.d.</p>
</td></tr>
<tr><td><code id="getPower_+3A_alpha">alpha</code></td>
<td>
<p>error</p>
</td></tr>
<tr><td><code id="getPower_+3A_tdist">tdist</code></td>
<td>
<p>logical. Use Student t Distribution. Default: FALSE</p>
</td></tr>
<tr><td><code id="getPower_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of &quot;two.sided&quot;, &quot;greater&quot; (default) or &quot;less&quot;.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Power should be approx. 0.9183621:
getPower(mu0=5, mu1=6.5, n=20, sigma=2, alpha=0.05, tdist = FALSE, 
alternative = "two.sided")
## Power should be approx. 0.8887417:
getPower(mu0=5, mu1=6.5, n=20, sigma=2, alpha=0.05, tdist = TRUE, 
alternative = "two.sided")
## Compare with results from power.t.test
powerVal &lt;- power.t.test(n=20, delta=1.5, sd=2, sig.level=0.05, type="one.sample",
alternative="two.sided",strict = TRUE)
powerVal$power

</code></pre>

<hr>
<h2 id='getReplicates'>get number of replicates</h2><span id='topic+getReplicates'></span>

<h3>Description</h3>

<p>determine how often appears x in X
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getReplicates(x, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getReplicates_+3A_x">x</code></td>
<td>
<p>row vector</p>
</td></tr>
<tr><td><code id="getReplicates_+3A_x">X</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>can be used to determine the number of
replicates/repeated evaluations of a solution x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k &lt;- 2
n &lt;- 4
A &lt;- matrix(1:(k*n),n,k, byrow = TRUE)
X &lt;- rbind(A,A,A)
x &lt;- A[1,]
## should be 3:
getReplicates(x,X)

## U has unique entries
U &lt;- X[!duplicated(X), ]
## should be 1:
getReplicates(x,U)

</code></pre>

<hr>
<h2 id='getSampleSize'>getSampleSize</h2><span id='topic+getSampleSize'></span>

<h3>Description</h3>

<p>Implements sample size calculations in R
See also: <a href="https://www.cyclismo.org/tutorial/R/power.html">https://www.cyclismo.org/tutorial/R/power.html</a>
and <a href="https://influentialpoints.com/Training/statistical_power_and_sample_size.htm">https://influentialpoints.com/Training/statistical_power_and_sample_size.htm</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSampleSize(mu0, mu1, alpha, beta, sigma, alternative = "greater")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSampleSize_+3A_mu0">mu0</code></td>
<td>
<p>mean value of the null hypothesis (usually referred to as H0)</p>
</td></tr>
<tr><td><code id="getSampleSize_+3A_mu1">mu1</code></td>
<td>
<p>mean value of the alternative hypothesis (usually referred to as H1)</p>
</td></tr>
<tr><td><code id="getSampleSize_+3A_alpha">alpha</code></td>
<td>
<p>type I error</p>
</td></tr>
<tr><td><code id="getSampleSize_+3A_beta">beta</code></td>
<td>
<p>type II error</p>
</td></tr>
<tr><td><code id="getSampleSize_+3A_sigma">sigma</code></td>
<td>
<p>sample s.d.</p>
</td></tr>
<tr><td><code id="getSampleSize_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of &quot;two.sided&quot;, &quot;greater&quot; (default) or &quot;less&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n number of required samples in each arm of a trial. Note: total number of samples is 2*n.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
getSampleSize(mu0 = 0, mu1 = 200, alpha=0.05, beta=0.2, sigma=450, 
alternative="two.sided")
getSampleSize(mu0 = 8.72, mu1 = 8.72*1.1, alpha=0.05, beta=0.2, sigma=1.3825, 
alternative="greater")
getSampleSize(mu0 = 8.72, mu1 = 8.72*1.1, alpha=0.05, beta=0.2, sigma=1.3825, 
alternative="two.sided")

</code></pre>

<hr>
<h2 id='handleNAsKrigingWorst'>handleNAsKrigingWorst</h2><span id='topic+handleNAsKrigingWorst'></span>

<h3>Description</h3>

<p>Remove NAs from a vector by replacing them with a penalized
Kriging-based expectation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handleNAsKrigingWorst(
  x,
  y,
  penaltyImputation = 3,
  imputeCriteriaFuns = list(is.na, is.infinite, is.nan)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handleNAsKrigingWorst_+3A_x">x</code></td>
<td>
<p>The x values from which y was calculated</p>
</td></tr>
<tr><td><code id="handleNAsKrigingWorst_+3A_y">y</code></td>
<td>
<p>The vector of numerics from which the NAs should be removed</p>
</td></tr>
<tr><td><code id="handleNAsKrigingWorst_+3A_penaltyimputation">penaltyImputation</code></td>
<td>
<p>multiplier for sPredicted (penalty term). Default: <code>3</code>.</p>
</td></tr>
<tr><td><code id="handleNAsKrigingWorst_+3A_imputecriteriafuns">imputeCriteriaFuns</code></td>
<td>
<p><code>list</code> criteria functions specified via
<code>imputeCriteriaFuns</code> in <code><a href="#topic+spotControl">spotControl</a></code>. Default:
<code>list(is.na, is.infinite, is.nan)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>y The imputed vector w/o <code>NA</code> and w/o <code>Inf</code> values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>imputeCriteriaFuns &lt;- list(is.na, is.infinite, is.nan)
x &lt;- matrix(runif(20), ncol = 2)
y &lt;- funSphere(x)
y[3] &lt;- NA
y[5] &lt;- Inf
plot(y, type="b")
print(y)
y1 &lt;- handleNAsKrigingWorst(x=x, y=y, imputeCriteriaFuns=imputeCriteriaFuns)
print(y1)
points(3, y1[3], type="b", col="red")
points(5, y1[5], type="b", col="red")
</code></pre>

<hr>
<h2 id='handleNAsMax'>handleNAsMax</h2><span id='topic+handleNAsMax'></span>

<h3>Description</h3>

<p>Remove NAs from a vector by replacing them by the current max + p*s.d., where p
denotes a penalty term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handleNAsMax(
  x,
  y = NULL,
  imputeCriteriaFuns = list(is.na, is.infinite, is.nan),
  penaltyImputation = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handleNAsMax_+3A_x">x</code></td>
<td>
<p>The x values from which y was calculated, not used here</p>
</td></tr>
<tr><td><code id="handleNAsMax_+3A_y">y</code></td>
<td>
<p>The vector of numerics from which the NAs should be removed</p>
</td></tr>
<tr><td><code id="handleNAsMax_+3A_imputecriteriafuns">imputeCriteriaFuns</code></td>
<td>
<p><code>list</code> criteria functions specified via
<code>imputeCriteriaFuns</code> in <code><a href="#topic+spotControl">spotControl</a></code>. Default:
<code>list(is.na, is.infinite, is.nan)</code>.</p>
</td></tr>
<tr><td><code id="handleNAsMax_+3A_penaltyimputation">penaltyImputation</code></td>
<td>
<p>penalty used for imputed values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>y The cleaned vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vecWithNAs &lt;- c(-1, 0,1,NA,3,Inf,5,NA)
control &lt;- spotControl(dim=length(vecWithNAs))
print(vecWithNAs)
print(handleNAsMax(y=vecWithNAs,
                     imputeCriteriaFuns= control$yImputation$imputeCriteriaFuns))
</code></pre>

<hr>
<h2 id='handleNAsMean'>handleNAsMean</h2><span id='topic+handleNAsMean'></span>

<h3>Description</h3>

<p>Remove NAs from a vector by replacing them by the sample mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handleNAsMean(
  x,
  y = NULL,
  imputeCriteriaFuns = list(is.na, is.infinite, is.nan),
  penaltyImputation = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handleNAsMean_+3A_x">x</code></td>
<td>
<p>The x values from which y was calculated, not used here</p>
</td></tr>
<tr><td><code id="handleNAsMean_+3A_y">y</code></td>
<td>
<p>The vector of numerics from which the NAs should be removed</p>
</td></tr>
<tr><td><code id="handleNAsMean_+3A_imputecriteriafuns">imputeCriteriaFuns</code></td>
<td>
<p><code>list</code> criteria functions specified via
<code>imputeCriteriaFuns</code> in <code><a href="#topic+spotControl">spotControl</a></code>. Default:
<code>list(is.na, is.infinite, is.nan)</code>.</p>
</td></tr>
<tr><td><code id="handleNAsMean_+3A_penaltyimputation">penaltyImputation</code></td>
<td>
<p>penalty used for imputed values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>y The cleaned vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vecWithNAs &lt;- c(-1, 0,1,NA,3,Inf,5,NA)
control &lt;- spotControl(dim=length(vecWithNAs))
print(vecWithNAs)
print(handleNAsMean(y=vecWithNAs,
                     imputeCriteriaFuns= control$yImputation$imputeCriteriaFuns))
</code></pre>

<hr>
<h2 id='imputeY'>Impute NAs and Inf in y</h2><span id='topic+imputeY'></span>

<h3>Description</h3>

<p>Impute NAs and Inf in y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputeY(x, y, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imputeY_+3A_x">x</code></td>
<td>
<p>The x values from which y was calculated</p>
</td></tr>
<tr><td><code id="imputeY_+3A_y">y</code></td>
<td>
<p>The vector of numerics from which NA/Inf values should be removed</p>
</td></tr>
<tr><td><code id="imputeY_+3A_control">control</code></td>
<td>
<p><code><a href="#topic+spot">spot</a></code> control list. See also <code><a href="#topic+spotControl">spotControl</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>y The imputed vector w/o <code>NA</code> and w/o <code>Inf</code> values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(runif(10), ncol=2, nrow=5)
y &lt;- funSphere(x)
y[1] &lt;- NA
control &lt;- spotControl(dimension = 2)
# no imputation function, i.e, w/o imputation
imputeY(x=x, y=y, control=control)
# with imputation
control$yImputation$handleNAsMethod &lt;- handleNAsKrigingWorst
y &lt;- imputeY(x=x, y=y, control=control)
# no imputation required:
imputeY(x=x, y=y, control=control)

</code></pre>

<hr>
<h2 id='infillEI'>Expected Improvement Infill Criterion</h2><span id='topic+infillEI'></span>

<h3>Description</h3>

<p>Compute the negative of the Expected Improvement of a set of candidate solutions.
Based on mean and standard deviation of a candidate solution,
this estimates the expectation of improvement. Improvement
considers the amount by which the best known value (best observed value)
is exceeded by the candidates.
Expected Improvement infill criterion that can be passed to control$modelControl$infillCriterion 
in order to be used during the optimization in SPOT.
Parameters dont have to be specified as this function is ment to be internally by SPOT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infillEI(predictionList, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infillEI_+3A_predictionlist">predictionList</code></td>
<td>
<p>The results of a predict.model call</p>
</td></tr>
<tr><td><code id="infillEI_+3A_model">model</code></td>
<td>
<p>The surrogate model which was used for the prediction</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector, expected improvement results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
spot(,funSphere,c(-2,-3),c(1,2), control = 
    list(infillCriterion = infillEI, modelControl = list(target = c("y","s"))))
    
</code></pre>

<hr>
<h2 id='infillExpectedImprovement'>infillExpectedImprovement</h2><span id='topic+infillExpectedImprovement'></span>

<h3>Description</h3>

<p>Compute the negative logarithm of the Expected Improvement of a set of candidate solutions.
Based on mean and standard deviation of a candidate solution,
this estimates the expectation of improvement. Improvement
considers the amount by which the best known value (best observed value)
is exceeded by the candidates.
Expected Improvement infill criterion that can be passed to control$modelControl$infillCriterion in order to be used during the optimization in SPOT.
Parameters dont have to be specified as this function is ment to be internally by SPOT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infillExpectedImprovement(predictionList, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infillExpectedImprovement_+3A_predictionlist">predictionList</code></td>
<td>
<p>The results of a predict.model call</p>
</td></tr>
<tr><td><code id="infillExpectedImprovement_+3A_model">model</code></td>
<td>
<p>The surrogate model which was used for the prediction</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector, expected improvement results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
spot(,funSphere,c(-2,-3),c(1,2), control = 
    list(infillCriterion = infillExpectedImprovement, modelControl = list(target = c("y","s"))))
     
</code></pre>

<hr>
<h2 id='infillGetFullPrediction'>infillGetFullPrediction</h2><span id='topic+infillGetFullPrediction'></span>

<h3>Description</h3>

<p>Wrapper to get the full model Prediction instead of just one target for plotting purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infillGetFullPrediction(predictionList, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infillGetFullPrediction_+3A_predictionlist">predictionList</code></td>
<td>
<p>The results of a predict.model call</p>
</td></tr>
<tr><td><code id="infillGetFullPrediction_+3A_model">model</code></td>
<td>
<p>The surrogate model which was used for the prediction</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list, full model prediction
</p>

<hr>
<h2 id='init_ring'>init_ring</h2><span id='topic+init_ring'></span>

<h3>Description</h3>

<p>Initialize ring parameters: generate arrival probabilities for S-Ring.
- set beginning states to 0 and initialize random customer states and nElevators
- nStates = (number of floors * 2) - 2. For example for 4 floors, 
its 6 states because the upper and lower state have only 
one direction and all other have 2 (UP and DOWN)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_ring(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_ring_+3A_params">params</code></td>
<td>
<p>list of 
</p>

<dl>
<dt><code>randomSeed</code></dt><dd><p>random seed</p>
</dd>
<dt><code>nStates</code></dt><dd><p>number of S-Ring states</p>
</dd>
<dt><code>nElevators</code></dt><dd><p>number of elevators</p>
</dd>
<dt><code>probNewCustomer</code></dt><dd><p>probability pf a customer arrival</p>
</dd>
<dt><code>counter</code></dt><dd><p>Counter: number of waiting customers</p>
</dd>
<dt><code>sElevator</code></dt><dd><p>Vector representing elevators (s)</p>
</dd>
<dt><code>sCustomer</code></dt><dd><p>Vector representing customers (c)</p>
</dd>
<dt><code>currentState</code></dt><dd><p>Current state that is calculated</p>
</dd>
<dt><code>nextState</code></dt><dd><p>Next state that is calculated</p>
</dd>
<dt><code>nWeights</code></dt><dd><p>Number of weights for the perceptron (= 2 * nStates)</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>list (params) of 
</p>

<dl>
<dt><code>randomSeed</code></dt><dd><p>random seed</p>
</dd>
<dt><code>nStates</code></dt><dd><p>number of S-Ring states</p>
</dd>
<dt><code>nElevators</code></dt><dd><p>number of elevators</p>
</dd>
<dt><code>probNewCustomer</code></dt><dd><p>probability pf a customer arrival</p>
</dd>
<dt><code>counter</code></dt><dd><p>Counter: number of waiting customers</p>
</dd>
<dt><code>sElevator</code></dt><dd><p>Vector representing elevators (s)</p>
</dd>
<dt><code>sCustomer</code></dt><dd><p>Vector representing customers (c)</p>
</dd>
<dt><code>currentState</code></dt><dd><p>Current state that is calculated</p>
</dd>
<dt><code>nextState</code></dt><dd><p>Next state that is calculated</p>
</dd>
<dt><code>nWeights</code></dt><dd><p>Number of weights for the perceptron (= 2 * nStates)</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;-list(sElevator=NULL,
  sCustomer=NULL,
  currentState=NULL,
  nextState=NULL,
  counter=NULL,
  nStates=12,
  nElevators=2,
  probNewCustomer=0.1,
  weightsPerceptron=rep(0.1, 24),
  nWeights=NULL,
  nIterations=100,
  randomSeed=1234)
  
init_ring(params)
 
</code></pre>

<hr>
<h2 id='initialInputCheck'>initialInputCheck. Initial Input Check of Spot Configuration</h2><span id='topic+initialInputCheck'></span>

<h3>Description</h3>

<p>#' This function takes the same inputs as given to the <code>spot</code> call and checks for
possible problems in the users configuration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialInputCheck(
  x = NULL,
  fun,
  lower,
  upper,
  control = list(),
  inSpotLoop = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialInputCheck_+3A_x">x</code></td>
<td>
<p>is an optional start point (or set of start points), specified as a matrix. One row for each point, and one column for each optimized parameter.</p>
</td></tr>
<tr><td><code id="initialInputCheck_+3A_fun">fun</code></td>
<td>
<p>is the objective function. It should receive a matrix x and return a matrix y. In case the function uses external code and is noisy, an additional seed parameter may be used, see the <code>control$seedFun</code> argument below for details.</p>
</td></tr>
<tr><td><code id="initialInputCheck_+3A_lower">lower</code></td>
<td>
<p>is a vector that defines the lower boundary of search space. This determines also the problem dimension.</p>
</td></tr>
<tr><td><code id="initialInputCheck_+3A_upper">upper</code></td>
<td>
<p>is a vector that defines the upper boundary of search space.</p>
</td></tr>
<tr><td><code id="initialInputCheck_+3A_control">control</code></td>
<td>
<p>is a list with control settings for spot. See <code><a href="#topic+spotControl">spotControl</a></code>.</p>
</td></tr>
<tr><td><code id="initialInputCheck_+3A_inspotloop">inSpotLoop</code></td>
<td>
<p>logical. If initial design, then <code>FALSE</code>, otherwise <code>TRUE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='krigingLikelihood'>Calculate negative log-likelihood</h2><span id='topic+krigingLikelihood'></span>

<h3>Description</h3>

<p>Used to determine theta/lambda values for the Kriging model in <code><a href="#topic+buildKriging">buildKriging</a></code>.
Supportive function for Kriging model, not to be used directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krigingLikelihood(
  x,
  AX,
  Ay,
  optimizeP = FALSE,
  useLambda = TRUE,
  penval = 1e+08
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krigingLikelihood_+3A_x">x</code></td>
<td>
<p>vector, containing parameters log10(theta), log10(lambda) and p.</p>
</td></tr>
<tr><td><code id="krigingLikelihood_+3A_ax">AX</code></td>
<td>
<p>3 dimensional array, constructed by buildKriging from the sample locations</p>
</td></tr>
<tr><td><code id="krigingLikelihood_+3A_ay">Ay</code></td>
<td>
<p>vector of observations at sample locations</p>
</td></tr>
<tr><td><code id="krigingLikelihood_+3A_optimizep">optimizeP</code></td>
<td>
<p>boolean, whether to optimize parameter p (exponents) or fix at two.</p>
</td></tr>
<tr><td><code id="krigingLikelihood_+3A_uselambda">useLambda</code></td>
<td>
<p>boolean, whether to use nugget</p>
</td></tr>
<tr><td><code id="krigingLikelihood_+3A_penval">penval</code></td>
<td>
<p>a penalty value which affects the value returned for invalid correlation matrices / configurations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with elements<br />
<code>NegLnLike</code>  concentrated log-likelihood *-1 for minimising <br />
<code>Psi</code> correlation matrix<br />
<code>Psinv</code> inverse of correlation matrix (to save computation time during prediction)<br />
<code>mu</code> <br />
<code>ssq</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKriging">buildKriging</a></code>
</p>

<hr>
<h2 id='linearAdaptedSE'>linearAdaptedSE</h2><span id='topic+linearAdaptedSE'></span>

<h3>Description</h3>

<p>Linearly adapt the uncertainty estimation of a CV model regarding its distance to known neighbours
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearAdaptedSE(sOld, newdata, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearAdaptedSE_+3A_sold">sOld</code></td>
<td>
<p>numeric vector, old uncertainty values</p>
</td></tr>
<tr><td><code id="linearAdaptedSE_+3A_newdata">newdata</code></td>
<td>
<p>matrix, new data points for which the uncertainty is estimated</p>
</td></tr>
<tr><td><code id="linearAdaptedSE_+3A_x">x</code></td>
<td>
<p>matrix, already evaluated data points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector, adapted uncertainty values
</p>

<hr>
<h2 id='makeMoreFunList'>makeMoreFunList</h2><span id='topic+makeMoreFunList'></span>

<h3>Description</h3>

<p>Generate a list of benchmark functions.
Based on the More(1981) paper.
Contains the first 13 function from the paper.
Function numbers are the same as in the paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMoreFunList(vector2Matrix = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeMoreFunList_+3A_vector2matrix">vector2Matrix</code></td>
<td>
<p>logical. Convert vector input to matrix.
Default: TRUE, so it can be used with <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of functions with starting points and optimum points.
</p>


<h3>References</h3>

<p>More, J. J., Garbow, B. S., and  Hillstrom, K. E. (1981).
Testing unconstrained optimization software.
<em>ACM Transactions on Mathematical Software (TOMS)</em>, <em>7</em>(1), 17-41.
<a href="https://doi.org/10.1145/355934.355936">doi:10.1145/355934.355936</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate function list.
# Here we use the default setting \code{vector2Matrix = TRUE},
# so the function list can be passed to \code{\link[stats]{optim}}.

fl &lt;- makeMoreFunList()
optim(par=c(-1.2,1), fn=fl$funList[[1]])
optim(par=fl$startPointList[[1]], fn=fl$funList[[1]])$value
optim(par=fl$startPointList[[1]], fn=fl$funList[[1]],NULL, method = "CG", hessian = FALSE)$value
optim(fl$startPointList[[1]], fl$funList[[1]],NULL, method = "BFGS", hessian = FALSE)$value
optim(fl$startPointList[[1]], fl$funList[[1]],NULL, method = "L-BFGS-B", hessian = FALSE)$value

</code></pre>

<hr>
<h2 id='makeSpotFunList'>makeSpotFunList</h2><span id='topic+makeSpotFunList'></span>

<h3>Description</h3>

<p>Generate a list of spot functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeSpotFunList(vector2Matrix = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeSpotFunList_+3A_vector2matrix">vector2Matrix</code></td>
<td>
<p>logical. Convert vector input to matrix.
Default: TRUE, so it can be used with <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fr &lt;- makeSpotFunList()
optim(c(-1.2,1), fr[[1]])

</code></pre>

<hr>
<h2 id='maxNearestNeighbourDistance'>maxNearestNeighbourDistance</h2><span id='topic+maxNearestNeighbourDistance'></span>

<h3>Description</h3>

<p>Find the maximum distance between 2 nearest neighbours in a data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxNearestNeighbourDistance(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxNearestNeighbourDistance_+3A_x">x</code></td>
<td>
<p>matrix with candidate solutions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>maximum euclidean distance between two nearest neighbours
</p>

<hr>
<h2 id='normalizeMatrix'>Normalize design matrix</h2><span id='topic+normalizeMatrix'></span>

<h3>Description</h3>

<p>Normalize design by using minimum and maximum of the design values
for input space. Each column has entries in the range from <code>ymin</code> to <code>ymax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalizeMatrix(x, ymin, ymax, MARGIN = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalizeMatrix_+3A_x">x</code></td>
<td>
<p>design matrix in input space</p>
</td></tr>
<tr><td><code id="normalizeMatrix_+3A_ymin">ymin</code></td>
<td>
<p>minimum vector of normalized space</p>
</td></tr>
<tr><td><code id="normalizeMatrix_+3A_ymax">ymax</code></td>
<td>
<p>maximum vector of normalized space</p>
</td></tr>
<tr><td><code id="normalizeMatrix_+3A_margin">MARGIN</code></td>
<td>
<p>a vector giving the subscripts which the function will be applied over.
1 indicates rows, 2 indicates columns. Default: <code>2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code> with the following entries:
</p>

<dl>
<dt><code>y</code></dt><dd><p>normalized design matrix in the range [ymin, ymax]</p>
</dd>
<dt><code>xmin</code></dt><dd><p>min in each column</p>
</dd>
<dt><code>xmax</code></dt><dd><p>max in each column</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+buildKriging">buildKriging</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x &lt;- matrix(c(rep(1,3), rep(2,3),rep(3,3), rep(4,3)),3,4)
## columnwise:
normalizeMatrix(x, ymin=0, ymax=1)
## rowwise
normalizeMatrix(x, ymin=0, ymax=1, MARGIN=1)
# rows with identical values are mapped to the mean:
x &lt;- matrix(rep(0,4),2,2)
normalizeMatrix(x, ymin=0, ymax=1)

</code></pre>

<hr>
<h2 id='normalizeMatrix2'>Normalize design 2</h2><span id='topic+normalizeMatrix2'></span>

<h3>Description</h3>

<p>Normalize design with given maximum and minimum in input space.
Supportive function for Kriging model, not to be used directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalizeMatrix2(x, ymin, ymax, xmin, xmax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalizeMatrix2_+3A_x">x</code></td>
<td>
<p>design matrix in input space (n rows for each point, k columns for each parameter)</p>
</td></tr>
<tr><td><code id="normalizeMatrix2_+3A_ymin">ymin</code></td>
<td>
<p>minimum vector of normalized space</p>
</td></tr>
<tr><td><code id="normalizeMatrix2_+3A_ymax">ymax</code></td>
<td>
<p>maximum vector of normalized space</p>
</td></tr>
<tr><td><code id="normalizeMatrix2_+3A_xmin">xmin</code></td>
<td>
<p>minimum vector of input space</p>
</td></tr>
<tr><td><code id="normalizeMatrix2_+3A_xmax">xmax</code></td>
<td>
<p>maximum vector of input space</p>
</td></tr>
</table>


<h3>Value</h3>

<p>normalized design matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKriging">buildKriging</a></code>
</p>

<hr>
<h2 id='obj.plgpEI'>Wrapper for Expected improvement (Gramacy)</h2><span id='topic+obj.plgpEI'></span>

<h3>Description</h3>

<p>Wrapper for Expected improvement (Gramacy)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obj.plgpEI(x, fmin, gpi, pred = predGPsep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obj.plgpEI_+3A_x">x</code></td>
<td>
<p>matrix of points to calculate EI</p>
</td></tr>
<tr><td><code id="obj.plgpEI_+3A_fmin">fmin</code></td>
<td>
<p>best function value (y) so far</p>
</td></tr>
<tr><td><code id="obj.plgpEI_+3A_gpi">gpi</code></td>
<td>
<p>Gaussian process C-side object</p>
</td></tr>
<tr><td><code id="obj.plgpEI_+3A_pred">pred</code></td>
<td>
<p>prediction model. Default: <code>predGPsep</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>negative expected improvement
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plgpEI">plgpEI</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(laGP)
library(plgp)

ninit &lt;- 12
dim &lt;- 2
X &lt;- designLHD(,rep(0,dim), rep(1,dim), control=list(size=ninit))
y &lt;- funGoldsteinPrice(X)
m &lt;- which.min(y)
ymin &lt;- y[m]
start &lt;- matrix(X[m,], nrow =1)

## Build laGP model
gpi &lt;- newGPsep(X, y, d=0.1, g=1e-8, dK=TRUE)
da &lt;- darg(list(mle=TRUE, max=0.5), designLHD(,rep(0,dim), rep(1,dim), control=list(size=1000)))
mleGPsep(gpi, param="d", tmin=da$min, tmax=da$max, ab=da$ab)
res &lt;- optim(start[1,], obj.plgpEI, method="L-BFGS-B", lower=0, upper=1, 
gpi=gpi, pred=predGPsep, fmin=ymin)
xnew &lt;- c(res$par, -res$value)
print(xnew)
deleteGPsep(gpi)

</code></pre>

<hr>
<h2 id='objectiveFunctionEvaluation'>objectiveFunctionEvaluation  Objective Function Evaluation</h2><span id='topic+objectiveFunctionEvaluation'></span>

<h3>Description</h3>

<p>This function handles the evaluation of the objective function
in <code><a href="#topic+spot">spot</a></code>.
This includes handling of the random number generator stream, variable transformations
(<code><a href="#topic+transformX">transformX</a></code>) as well as the actual evaluation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objectiveFunctionEvaluation(x = NULL, xnew, fun, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objectiveFunctionEvaluation_+3A_x">x</code></td>
<td>
<p>matrix of already known solutions,
to determine whether RNG seeds for new solutions need to be incremented.</p>
</td></tr>
<tr><td><code id="objectiveFunctionEvaluation_+3A_xnew">xnew</code></td>
<td>
<p>matrix of new solutions.</p>
</td></tr>
<tr><td><code id="objectiveFunctionEvaluation_+3A_fun">fun</code></td>
<td>
<p>objective function to evaluate the solutions in <code>xnew</code>.</p>
</td></tr>
<tr><td><code id="objectiveFunctionEvaluation_+3A_control">control</code></td>
<td>
<p>control list with the following entries:
</p>

<dl>
<dt><code>seedFun</code></dt><dd><p>initial seed to be used for the random number generator
seed. Set to <code>NA</code> to avoid using a fixed seed.</p>
</dd>
<dt><code>noise:</code></dt><dd><p><code>logical</code> parameter specifying
whether the target function is noisy. </p>
</dd>
<dt><code>verbosity:</code></dt><dd><p>verbosity. Default: 0.</p>
</dd>
<dt><code>transformFun:</code></dt><dd><p>transformation functions applied to <code>xnew</code>. See
<code><a href="#topic+transformX">transformX</a></code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="objectiveFunctionEvaluation_+3A_...">...</code></td>
<td>
<p>parameters passed to <code>fun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the matrix ynew, which are the observations for fun(xnew)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spot">spot</a></code> for more details on the parameters, e.g., <code>fun</code>
</p>
<p><code><a href="#topic+transformX">transformX</a></code>
</p>
<p><code><a href="#topic+spotControl">spotControl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## 1) without noise
x &lt;- NULL
xnew &lt;- matrix(1:10, ncol=2)
fun &lt;- funSphere
control &lt;- spotControl(dim(xnew)[2])
control$verbosity &lt;- 0
objectiveFunctionEvaluation(x=x, xnew=xnew, fun=fun, control=control)
##
fun &lt;- funMoo
objectiveFunctionEvaluation(x=x, xnew=xnew, fun=fun, control=control)
## 2) with noise
fun = function(x){funSphere(x) + rnorm(nrow(x))}
control$noise &lt;- TRUE
objectiveFunctionEvaluation(x=x, xnew=xnew, fun=fun, control=control)
## 3) known solutions
x &lt;- matrix(11:20, ncol=2)
xnew &lt;- matrix(1:10, ncol=2)
fun &lt;- funSphere
objectiveFunctionEvaluation(x=x, xnew=xnew, fun=fun, control=control)
## 4) known solutions with noise and repeats
x &lt;- matrix(1:20, ncol=2, byrow=TRUE)
xnew &lt;- matrix(1:10, ncol=2, byrow=TRUE)
fun = function(x){funSphere(x) + rnorm(nrow(x))}
objectiveFunctionEvaluation(x=x, xnew=xnew, fun=fun, control=control)
## 5) identical solutions with noise and repeats
x &lt;- matrix(1:10, ncol=2, byrow=TRUE)
xnew &lt;- x
fun = function(x){funSphere(x) + rnorm(nrow(x))}
y &lt;- objectiveFunctionEvaluation(x=NULL, xnew=x, fun=fun, control=control)
y1 &lt;- objectiveFunctionEvaluation(x=x, xnew=xnew, fun=fun, control=control)
y2 &lt;- objectiveFunctionEvaluation(x=NULL, xnew=xnew, fun=fun, control=control)
print(cbind(x, y))
print(cbind(xnew, y1))
print(cbind(xnew, y2))
identical(y, y1) # FALSE
identical(y, y2) # TRUE
## 6) known solutions with noise and repeats. function sets seed
x &lt;- matrix(1:20, ncol=2, byrow=TRUE)
xnew &lt;- matrix(1:10, ncol=2, byrow=TRUE)
fun &lt;- function(x,seed){
  set.seed(seed)
  funSphere(x)+rnorm(nrow(x))}
control$seedFun &lt;- 1
y1 &lt;- objectiveFunctionEvaluation(x=x, xnew=xnew, fun=fun, control=control)
y2 &lt;- objectiveFunctionEvaluation(x=x, xnew=xnew, fun=fun, control=control)
identical(y1, y2) # TRUE
control$seedFun &lt;- 2
y3 &lt;- objectiveFunctionEvaluation(x=x, xnew=xnew, fun=fun, control=control)
identical(y1,y3) # FALSE
## 7) spot examples:
res1a &lt;- spot(,function(x,seed){set.seed(seed);funSphere(x)+rnorm(nrow(x))},
c(-2,-3),c(1,2),control=list(funEvals=25,noise=TRUE,seedFun=1))
res1b &lt;- spot(,function(x,seed){set.seed(seed);funSphere(x)+rnorm(nrow(x))},
c(-2,-3),c(1,2),control=list(funEvals=25,noise=TRUE,seedFun=1))
res2 &lt;- spot(,function(x,seed){set.seed(seed);funSphere(x)+rnorm(nrow(x))},
c(-2,-3),c(1,2),control=list(funEvals=25,noise=TRUE,seedFun=2))
sprintf("Should be equal: %f = %f. Should be different:  %f", res1a$ybest,
res1b$ybest, res2$ybest)

</code></pre>

<hr>
<h2 id='OCBA'>Low Level OCBA</h2><span id='topic+OCBA'></span>

<h3>Description</h3>

<p>Compute the Optimal Computing Budget Allocation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OCBA(sMean, sVar, n, addBudget, verbosity = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OCBA_+3A_smean">sMean</code></td>
<td>
<p>vector of sample means of candidate solutions.</p>
</td></tr>
<tr><td><code id="OCBA_+3A_svar">sVar</code></td>
<td>
<p>vector of sample variances of candidate solutions.
Note, that these should be non-zero. If the solutions with lowest or second lowest <code>mean</code> have zero variance,
This function will not distribute any additional evaluations, and return a vector of zeros.
If any other solution has zero observed variance, the respective solution will be ignored, and never
be assigned additional evaluations.</p>
</td></tr>
<tr><td><code id="OCBA_+3A_n">n</code></td>
<td>
<p>number of already performed evaluations for each candidate solutions.</p>
</td></tr>
<tr><td><code id="OCBA_+3A_addbudget">addBudget</code></td>
<td>
<p>the number of additional evaluations (replications) that can be distributed to the candidate solutions.</p>
</td></tr>
<tr><td><code id="OCBA_+3A_verbosity">verbosity</code></td>
<td>
<p>verbosity (default: 0)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector that specifies how often each solution should be evaluated.
</p>


<h3>References</h3>

<p>Chun-hung Chen and Loo Hay Lee. 2010. Stochastic Simulation Optimization: An Optimal Computing Budget Allocation (1st ed.). World Scientific Publishing Co., Inc., River Edge, NJ, USA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repeatsOCBA">repeatsOCBA</a></code> is based on this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple test
OCBA(1:10,1:10,rep(4,10),3)
## Example from the referenced book:
res &lt;- OCBA(c(1.2,2.1,3.4,4.87,6.05),c(3.3,2.0,4.5,5.3,6.9),c(12,6,5,5,4),100)
##expected result:
res == c(48,38,11,2,1)
</code></pre>

<hr>
<h2 id='ocbaRanking'>ocbaRanking</h2><span id='topic+ocbaRanking'></span>

<h3>Description</h3>

<p>Return the ocba ranking (xbest, ybest) for noisy optimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ocbaRanking(x, y, fun, control, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ocbaRanking_+3A_x">x</code></td>
<td>
<p>matrix of x values</p>
</td></tr>
<tr><td><code id="ocbaRanking_+3A_y">y</code></td>
<td>
<p>matrix of y values, one dimensional!</p>
</td></tr>
<tr><td><code id="ocbaRanking_+3A_fun">fun</code></td>
<td>
<p>objective function</p>
</td></tr>
<tr><td><code id="ocbaRanking_+3A_control">control</code></td>
<td>
<p>control list, see <code><a href="#topic+spotControl">spotControl</a></code></p>
</td></tr>
<tr><td><code id="ocbaRanking_+3A_...">...</code></td>
<td>
<p>additional arguments to fun</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on <code><a href="#topic+repeatsOCBA">repeatsOCBA</a></code>
</p>


<h3>Value</h3>

<p>(x,y) matrix of sorted (by y) values. In case of noise are these values aggregated (y-mean) values.
</p>

<hr>
<h2 id='optimDE'>Minimization by Differential Evolution</h2><span id='topic+optimDE'></span>

<h3>Description</h3>

<p>For minimization, this function uses the <code>"DEoptim"</code> method from the
codeDEoptim package. It is basically a wrapper, to enable DEoptim for usage
in SPOT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimDE(x = NULL, fun, lower, upper, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimDE_+3A_x">x</code></td>
<td>
<p>optional start point</p>
</td></tr>
<tr><td><code id="optimDE_+3A_fun">fun</code></td>
<td>
<p>objective function, which receives a matrix x and returns observations y</p>
</td></tr>
<tr><td><code id="optimDE_+3A_lower">lower</code></td>
<td>
<p>boundary of the search space</p>
</td></tr>
<tr><td><code id="optimDE_+3A_upper">upper</code></td>
<td>
<p>boundary of the search space</p>
</td></tr>
<tr><td><code id="optimDE_+3A_control">control</code></td>
<td>
<p>list of control parameters
</p>

<dl>
<dt><code>funEvals</code></dt><dd><p>Budget, number of function evaluations allowed. Default is 200.</p>
</dd>
<dt><code>populationSize</code></dt><dd><p>Population size or number of particles in the population. Default is 10*dimension.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="optimDE_+3A_...">...</code></td>
<td>
<p>passed to <code>fun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list, with elements
</p>

<dl>
<dt><code>x</code></dt><dd><p>archive of the best member at each iteration</p>
</dd>
<dt><code>y</code></dt><dd><p>archive of the best value of fn at each iteration</p>
</dd>
<dt><code>xbest</code></dt><dd><p>best solution</p>
</dd>
<dt><code>ybest</code></dt><dd><p>best observation</p>
</dd>
<dt><code>count</code></dt><dd><p>number of evaluations of <code>fun</code></p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- optimDE(,lower = c(-10,-20),upper=c(20,8),fun = funSphere)
res$ybest
optimDE(x = matrix(rep(1,6), 3, 2),lower = c(-10,-20),upper=c(20,8),fun = funSphere, 
   control = list(funEvals=100, populationSize=20))
#Compare to DEoptim:
require(DEoptim)
set.seed(1234)
DEoptim(function(x){funRosen(matrix(x,1))}, lower=c(-10,-10), upper=c(10,10), 
  DEoptim.control(strategy = 2,bs = FALSE, N = 20, itermax = 28, CR = 0.7, F = 1.2,
  trace = FALSE, p = 0.2, c = 0, reltol = sqrt(.Machine$double.eps), steptol = 200 ))
set.seed(1234)
optimDE(, fun=funRosen, lower=c(-10,-10), upper= c(10,10), 
   control = list( populationSize = 20, funEvals = 580, F = 1.2, CR = 0.7))
</code></pre>

<hr>
<h2 id='optimES'>Evolution Strategy</h2><span id='topic+optimES'></span>

<h3>Description</h3>

<p>This is an implementation of an Evolution Strategy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimES(x = NULL, fun, lower, upper, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimES_+3A_x">x</code></td>
<td>
<p>optional start point, not used</p>
</td></tr>
<tr><td><code id="optimES_+3A_fun">fun</code></td>
<td>
<p>objective function, which receives a matrix x and returns observations y</p>
</td></tr>
<tr><td><code id="optimES_+3A_lower">lower</code></td>
<td>
<p>is a vector that defines the lower boundary of search space (this also defines the dimensionality of the problem)</p>
</td></tr>
<tr><td><code id="optimES_+3A_upper">upper</code></td>
<td>
<p>is a vector that defines the upper boundary of search space (same length as lower)</p>
</td></tr>
<tr><td><code id="optimES_+3A_control">control</code></td>
<td>
<p>list of control parameters. The <code>control</code> list can contain the following settings:
</p>

<dl>
<dt>funEvals</dt><dd><p>number of function evaluations, stopping criterion, default is <code>500</code></p>
</dd>
<dt>mue</dt><dd><p>number of parents, default is <code>10</code></p>
</dd>
<dt>nu</dt><dd><p>selection pressure. That means, number of offspring (lambda) is mue multiplied with nu. Default is <code>10</code></p>
</dd>
<dt>mutation</dt><dd><p>string of mutation type, default is <code>1</code></p>
</dd>
<dt>sigmaInit</dt><dd><p>initial sigma value (step size), default is <code>1.0</code></p>
</dd>
<dt>nSigma</dt><dd><p>number of different sigmas, default is <code>1</code></p>
</dd>
<dt>tau0</dt><dd><p>number, default is <code>0.0</code>. tau0 is the general multiplier.</p>
</dd>
<dt>tau</dt><dd><p>number, learning parameter for self adaption, i.e. the local multiplier for step sizes (for each dimension).default is <code>1.0</code></p>
</dd>
<dt>rho</dt><dd><p>number of parents involved in the procreation of an offspring (mixing number), default is <code>"bi"</code></p>
</dd>
<dt>sel</dt><dd><p>number of selected individuals, default is <code>1</code></p>
</dd>
<dt>stratReco</dt><dd><p>Recombination operator for strategy variables. <code>1</code>: none. <code>2</code>: dominant/discrete (default). <code>3</code>: intermediate. <code>4</code>: variation of intermediate recombination. </p>
</dd>
<dt>objReco</dt><dd><p>Recombination operator for object variables. <code>1</code>: none. <code>2</code>: dominant/discrete (default). <code>3</code>: intermediate. <code>4</code>: variation of intermediate recombination. </p>
</dd>
<dt>maxGen</dt><dd><p>number of generations, stopping criterion, default is <code>Inf</code></p>
</dd>
<dt>seed</dt><dd><p>number, random seed, default is <code>1</code></p>
</dd>
<dt>noise</dt><dd><p>number, value of noise added to fitness values, default is <code>0.0</code></p>
</dd>
<dt>verbosity</dt><dd><p>defines output verbosity of the ES, default is <code>0</code></p>
</dd>
<dt>plotResult</dt><dd><p>boolean, specifies if results are plotted, default is <code>FALSE</code></p>
</dd>
<dt>logPlotResult</dt><dd><p>boolean, defines if plot results should be logarithmic, default is <code>FALSE</code></p>
</dd>
<dt>sigmaRestart</dt><dd><p>number, value of sigma on restart, default is <code>0.1</code></p>
</dd>
<dt>preScanMult</dt><dd><p>initial population size is multiplied by this number for a pre-scan, default is <code>1</code></p>
</dd>
<dt>globalOpt</dt><dd><p>termination criterion on reaching a desired optimum value, default is <code>rep(0,dimension)</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="optimES_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed on to <code>fun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list, with elements
</p>

<dl>
<dt><code>x</code></dt><dd><p>NULL, currently not used</p>
</dd>
<dt><code>y</code></dt><dd><p>NULL, currently not used</p>
</dd>
<dt><code>xbest</code></dt><dd><p>best solution</p>
</dd>
<dt><code>ybest</code></dt><dd><p>best observation</p>
</dd>
<dt><code>count</code></dt><dd><p>number of evaluations of <code>fun</code></p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>cont &lt;- list(funEvals=100)
optimES(fun=funSphere,lower=rep(0,2), upper=rep(1,2), control= cont) 

</code></pre>

<hr>
<h2 id='optimGenoud'>Minimization by GENetic Optimization Using Derivatives</h2><span id='topic+optimGenoud'></span>

<h3>Description</h3>

<p>For minimization, this function uses the <code>"genoud"</code> method from the
codergenoud package. It is basically a wrapper, to enable genoud for usage
in SPOT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimGenoud(x = NULL, fun, lower, upper, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimGenoud_+3A_x">x</code></td>
<td>
<p>optional start point, not used</p>
</td></tr>
<tr><td><code id="optimGenoud_+3A_fun">fun</code></td>
<td>
<p>objective function, which receives a matrix x and returns observations y</p>
</td></tr>
<tr><td><code id="optimGenoud_+3A_lower">lower</code></td>
<td>
<p>boundary of the search space</p>
</td></tr>
<tr><td><code id="optimGenoud_+3A_upper">upper</code></td>
<td>
<p>boundary of the search space</p>
</td></tr>
<tr><td><code id="optimGenoud_+3A_control">control</code></td>
<td>
<p>list of control parameters
</p>

<dl>
<dt><code>funEvals</code></dt><dd><p>Budget, number of function evaluations allowed. Default is 100.</p>
</dd>
<dt><code>populationSize</code></dt><dd><p>Population size, number of individuals in the population. Default is 10*dimension.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="optimGenoud_+3A_...">...</code></td>
<td>
<p>passed to <code>fun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list, with elements
</p>

<dl>
<dt><code>x</code></dt><dd><p>NULL, currently not used</p>
</dd>
<dt><code>y</code></dt><dd><p>NULL, currently not used</p>
</dd>
<dt><code>xbest</code></dt><dd><p>best solution</p>
</dd>
<dt><code>ybest</code></dt><dd><p>best observation</p>
</dd>
<dt><code>count</code></dt><dd><p>number of evaluations of <code>fun</code></p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- optimGenoud(,fun = funSphere,lower = c(-10,-20),upper=c(20,8))
res$ybest
</code></pre>

<hr>
<h2 id='optimLagp'>Interface to minimization based on Gramacy's lagp package</h2><span id='topic+optimLagp'></span>

<h3>Description</h3>

<p>Implements Gramacy's plgp package based optimization using expected improvement.
Example from chapter 7 in the surrogate book.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimLagp(x = NULL, fun, lower, upper, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimLagp_+3A_x">x</code></td>
<td>
<p>optional matrix of points to be included in the evaluation</p>
</td></tr>
<tr><td><code id="optimLagp_+3A_fun">fun</code></td>
<td>
<p>objective function, which receives a matrix x and returns observations y</p>
</td></tr>
<tr><td><code id="optimLagp_+3A_lower">lower</code></td>
<td>
<p>boundary of the search space</p>
</td></tr>
<tr><td><code id="optimLagp_+3A_upper">upper</code></td>
<td>
<p>boundary of the search space</p>
</td></tr>
<tr><td><code id="optimLagp_+3A_control">control</code></td>
<td>
<p>list of control parameters
</p>

<dl>
<dt><code>funEvals</code></dt><dd><p>Budget, number of function evaluations allowed. Default: 100.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of retries for design generation, used by <code><a href="#topic+designLHD">designLHD</a></code>. Default: 100.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="optimLagp_+3A_...">...</code></td>
<td>
<p>passed to <code>fun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list, with elements
</p>

<dl>
<dt><code>x</code></dt><dd><p>archive of evaluated solutions</p>
</dd>
<dt><code>y</code></dt><dd><p>archive of observations</p>
</dd>
<dt><code>xbest</code></dt><dd><p>best solution</p>
</dd>
<dt><code>ybest</code></dt><dd><p>best observation</p>
</dd>
<dt><code>count</code></dt><dd><p>number of evaluations of <code>fun</code></p>
</dd>
<dt><code>message</code></dt><dd><p>success message</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- optimLHD(,fun = funSphere,lower = c(-10,-20),upper=c(20,8))
res$ybest
</code></pre>

<hr>
<h2 id='optimLBFGSB'>Minimization by L-BFGS-B</h2><span id='topic+optimLBFGSB'></span>

<h3>Description</h3>

<p>For minimization, this function uses the <code>"L-BFGS-B"</code> method from the <code>optim</code> function, 
which is part of the codestats package. It is basically a wrapper, to enable L-BFGS-B for usage
in SPOT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimLBFGSB(x = NULL, fun, lower, upper, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimLBFGSB_+3A_x">x</code></td>
<td>
<p>optional matrix of points. Only first point (row) is used as startpoint.</p>
</td></tr>
<tr><td><code id="optimLBFGSB_+3A_fun">fun</code></td>
<td>
<p>objective function, which receives a matrix x and returns observations y</p>
</td></tr>
<tr><td><code id="optimLBFGSB_+3A_lower">lower</code></td>
<td>
<p>boundary of the search space</p>
</td></tr>
<tr><td><code id="optimLBFGSB_+3A_upper">upper</code></td>
<td>
<p>boundary of the search space</p>
</td></tr>
<tr><td><code id="optimLBFGSB_+3A_control">control</code></td>
<td>
<p>list of control parameters
</p>

<dl>
<dt><code>funEvals</code></dt><dd><p>Budget, number of function evaluations allowed. Default is 100.</p>
</dd>
</dl>

<p>All other <code>control</code> parameters accepted by the <code>optim</code> function can be used, too, and are passed to <code>optim</code>.</p>
</td></tr>
<tr><td><code id="optimLBFGSB_+3A_...">...</code></td>
<td>
<p>passed to <code>fun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list, with elements
</p>

<dl>
<dt><code>x</code></dt><dd><p>NA, not used</p>
</dd>
<dt><code>y</code></dt><dd><p>NA, not used</p>
</dd>
<dt><code>xbest</code></dt><dd><p>best solution</p>
</dd>
<dt><code>ybest</code></dt><dd><p>best observation</p>
</dd>
<dt><code>count</code></dt><dd><p>number of evaluations of <code>fun</code> 
(estimated from the more complicated <code>"counts"</code> variable returned by <code>optim</code>)</p>
</dd>
<dt><code>message</code></dt><dd><p>termination message returned by <code>optim</code></p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- optimLBFGSB(,fun = funSphere,lower = c(-10,-20),upper=c(20,8))
res$ybest
</code></pre>

<hr>
<h2 id='optimLHD'>Minimization by Latin Hypercube Sampling</h2><span id='topic+optimLHD'></span>

<h3>Description</h3>

<p>This uses Latin Hypercube Sampling (LHS) to optimize a specified target function.
A Latin Hypercube Design (LHD) is created with <code><a href="#topic+designLHD">designLHD</a></code>, then evaluated
by the objective function. All results are reported, including the best (minimal)
objective value, and corresponding design point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimLHD(x = NULL, fun, lower, upper, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimLHD_+3A_x">x</code></td>
<td>
<p>optional matrix of points to be included in the evaluation</p>
</td></tr>
<tr><td><code id="optimLHD_+3A_fun">fun</code></td>
<td>
<p>objective function, which receives a matrix x and returns observations y</p>
</td></tr>
<tr><td><code id="optimLHD_+3A_lower">lower</code></td>
<td>
<p>boundary of the search space</p>
</td></tr>
<tr><td><code id="optimLHD_+3A_upper">upper</code></td>
<td>
<p>boundary of the search space</p>
</td></tr>
<tr><td><code id="optimLHD_+3A_control">control</code></td>
<td>
<p>list of control parameters
</p>

<dl>
<dt><code>funEvals</code></dt><dd><p>Budget, number of function evaluations allowed. Default: 100.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of retries for design generation, used by <code><a href="#topic+designLHD">designLHD</a></code>. Default: 100.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="optimLHD_+3A_...">...</code></td>
<td>
<p>passed to <code>fun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list, with elements
</p>

<dl>
<dt><code>x</code></dt><dd><p>archive of evaluated solutions</p>
</dd>
<dt><code>y</code></dt><dd><p>archive of observations</p>
</dd>
<dt><code>xbest</code></dt><dd><p>best solution</p>
</dd>
<dt><code>ybest</code></dt><dd><p>best observation</p>
</dd>
<dt><code>count</code></dt><dd><p>number of evaluations of <code>fun</code></p>
</dd>
<dt><code>message</code></dt><dd><p>success message</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- optimLHD(,fun = funSphere,lower = c(-10,-20),upper=c(20,8))
res$ybest
</code></pre>

<hr>
<h2 id='optimNLOPTR'>optimNLOPTR. Minimization by NLOPT</h2><span id='topic+optimNLOPTR'></span>

<h3>Description</h3>

<p>#' This is a wrapper that employs the <code>nloptr</code> function from the package of the same name.
The <code>nloptr</code> function itself is an interface to the <code>nlopt</code> library, which contains a wide selection
of different optimization algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimNLOPTR(x = NULL, fun, lower, upper, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimNLOPTR_+3A_x">x</code></td>
<td>
<p>optional matrix of points to be included in the evaluation (only first row will be used)</p>
</td></tr>
<tr><td><code id="optimNLOPTR_+3A_fun">fun</code></td>
<td>
<p>objective function, which receives a matrix x and returns observations y</p>
</td></tr>
<tr><td><code id="optimNLOPTR_+3A_lower">lower</code></td>
<td>
<p>boundary of the search space</p>
</td></tr>
<tr><td><code id="optimNLOPTR_+3A_upper">upper</code></td>
<td>
<p>boundary of the search space</p>
</td></tr>
<tr><td><code id="optimNLOPTR_+3A_control">control</code></td>
<td>
<p>named list, with the options for <code>nloptr</code>. These
will be passed to <code>nloptr</code> as arguments. In addition, the following
parameter can be used to set the function evaluation budget:
</p>

<dl>
<dt><code>funEvals</code></dt><dd><p>Budget, number of function evaluations allowed. Default: 100.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="optimNLOPTR_+3A_...">...</code></td>
<td>
<p>passed to <code>fun</code>
</p>
<p>Note that the arguments 
<code>x</code>, <code>fun</code>, <code>lower</code> and <code>upper</code> 
will be mapped to the corresponding arguments of <code>nloptr</code>: 
<code>x0</code>, <code>eval_f</code>, <code>lb</code> and <code>ub</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list, with elements
</p>

<dl>
<dt><code>x</code></dt><dd><p>archive of evaluated solutions</p>
</dd>
<dt><code>y</code></dt><dd><p>archive of observations</p>
</dd>
<dt><code>xbest</code></dt><dd><p>best solution</p>
</dd>
<dt><code>ybest</code></dt><dd><p>best observation</p>
</dd>
<dt><code>count</code></dt><dd><p>number of evaluations of <code>fun</code></p>
</dd>
<dt><code>message</code></dt><dd><p>success message</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
##simple example:
res &lt;- optimNLOPTR(,fun = funSphere,lower = c(-10,-20),upper=c(20,8))
res
##with an inequality constraint:
contr &lt;- list()  #control list
##specify constraint
contr$eval_g_ineq &lt;- function(x) 1+x[1]-x[2]
res &lt;- optimNLOPTR(,fun=funSphere,lower=c(-10,-20),upper=c(20,8),control=contr) 
res

</code></pre>

<hr>
<h2 id='optimRSfun'>Random search surrogate-optimizer</h2><span id='topic+optimRSfun'></span>

<h3>Description</h3>

<p>This function is used to emulate uniform random search with SPOT.
It is used as the optimizer that searches for new candidates.
It returns a single uniform random sample within
the given lower and upper bounds of the search space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimRSfun(x, fun, lower, upper, control, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimRSfun_+3A_x">x</code></td>
<td>
<p>start guess, not used.</p>
</td></tr>
<tr><td><code id="optimRSfun_+3A_fun">fun</code></td>
<td>
<p>objective function to be evaluated via random search.</p>
</td></tr>
<tr><td><code id="optimRSfun_+3A_lower">lower</code></td>
<td>
<p>bound on the independent variables (search space).</p>
</td></tr>
<tr><td><code id="optimRSfun_+3A_upper">upper</code></td>
<td>
<p>bound on the independent variables (search space).</p>
</td></tr>
<tr><td><code id="optimRSfun_+3A_control">control</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="optimRSfun_+3A_...">...</code></td>
<td>
<p>additional arguments, not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>

<hr>
<h2 id='perceptron'>perceptron</h2><span id='topic+perceptron'></span>

<h3>Description</h3>

<p>Perceptron to calculate decisions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perceptron(currentState, nStates, sElevator, sCustomer, weightsPerceptron)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perceptron_+3A_currentstate">currentState</code></td>
<td>
<p>current state for decision (num)</p>
</td></tr>
<tr><td><code id="perceptron_+3A_nstates">nStates</code></td>
<td>
<p>numer of states (int)</p>
</td></tr>
<tr><td><code id="perceptron_+3A_selevator">sElevator</code></td>
<td>
<p>elevators vector (logical)</p>
</td></tr>
<tr><td><code id="perceptron_+3A_scustomer">sCustomer</code></td>
<td>
<p>customer vector (logical)</p>
</td></tr>
<tr><td><code id="perceptron_+3A_weightsperceptron">weightsPerceptron</code></td>
<td>
<p>Weight vector (num)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Number of weights in NN controller is 2xnStates, 
for each state (sElevator/sCustomer) there is one input
</p>


<h3>Value</h3>

<p>logical pass or take decision
</p>

<hr>
<h2 id='plgpEI'>Expected improvement (Gramacy)</h2><span id='topic+plgpEI'></span>

<h3>Description</h3>

<p>Expected improvement (Gramacy)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plgpEI(gpi, x, fmin, pred = predGPsep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plgpEI_+3A_gpi">gpi</code></td>
<td>
<p>Gaussian process C-side object</p>
</td></tr>
<tr><td><code id="plgpEI_+3A_x">x</code></td>
<td>
<p>matrix of points to calculate EI</p>
</td></tr>
<tr><td><code id="plgpEI_+3A_fmin">fmin</code></td>
<td>
<p>best function value (y) so far</p>
</td></tr>
<tr><td><code id="plgpEI_+3A_pred">pred</code></td>
<td>
<p>prediction model. Default: <code>predGPsep</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>ei expected improvement
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(laGP)
library(plgp)

ninit &lt;- 12
dim &lt;- 2
X &lt;- designLHD(,rep(0,dim), rep(1,dim), control=list(size=ninit))
y &lt;- funGoldsteinPrice(X)
m &lt;- which.min(y)
ymin &lt;- y[m]
start &lt;- matrix(X[m,], nrow =1)

## 1. Build SPOT BO Model
m1 &lt;- buildBO(x = X, y = y, control = list(target="ei"))
yy &lt;- predict(object = m1, newdata = start)
ei1 &lt;- matrix(yy$ei, ncol = 1)
## Show mue and s
mue &lt;- matrix(yy$y, ncol = 1)
s2 &lt;- matrix(yy$s, ncol = 1)

## 2. Build laGP model
gpi &lt;- newGPsep(X, y, d=0.1, g=1e-8, dK=TRUE)
da &lt;- darg(list(mle=TRUE, max=0.5), designLHD(,rep(0,dim), rep(1,dim), control=list(size=1000)))
mleGPsep(gpi, param="d", tmin=da$min, tmax=da$max, ab=da$ab)
ei2 &lt;- plgpEI(gpi=gpi, x=start, fmin=ymin)
deleteGPsep(gpi)

</code></pre>

<hr>
<h2 id='plot.spotRSM'>Plot RSM model</h2><span id='topic+plot.spotRSM'></span>

<h3>Description</h3>

<p>Plot model produced by <code><a href="#topic+buildRSM">buildRSM</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spotRSM'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.spotRSM_+3A_x">x</code></td>
<td>
<p>RSM model (settings and parameters) of class <code>spotRSM</code>.</p>
</td></tr>
<tr><td><code id="plot.spotRSM_+3A_...">...</code></td>
<td>
<p>parameters passed to plotting function (<code>contour</code>)</p>
</td></tr>
</table>

<hr>
<h2 id='plot.spotSeverity'>Plot method for spotSeverity</h2><span id='topic+plot.spotSeverity'></span>

<h3>Description</h3>

<p>Plot method for spotSeverity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spotSeverity'
plot(
  x,
  add = FALSE,
  rangeLeft = -1,
  rangeRight = 1,
  plotSev = TRUE,
  plotPow = FALSE,
  cl = "black",
  xlab = "x",
  ylab = "y",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.spotSeverity_+3A_x">x</code></td>
<td>
<p>severity object</p>
</td></tr>
<tr><td><code id="plot.spotSeverity_+3A_add">add</code></td>
<td>
<p>default value is FALSE</p>
</td></tr>
<tr><td><code id="plot.spotSeverity_+3A_rangeleft">rangeLeft</code></td>
<td>
<p>range default:<code>-1</code></p>
</td></tr>
<tr><td><code id="plot.spotSeverity_+3A_rangeright">rangeRight</code></td>
<td>
<p>range default:<code>1</code></p>
</td></tr>
<tr><td><code id="plot.spotSeverity_+3A_plotsev">plotSev</code></td>
<td>
<p>logical. plot severity. Default: TRUE</p>
</td></tr>
<tr><td><code id="plot.spotSeverity_+3A_plotpow">plotPow</code></td>
<td>
<p>logical. plot power. Default: FALSE</p>
</td></tr>
<tr><td><code id="plot.spotSeverity_+3A_cl">cl</code></td>
<td>
<p>color, e.g.,  <code>c("black", "red", "green", " blue" , "brown", 
"cyan", "darkred", "gray",  "green", "magenta", "orange")</code></p>
</td></tr>
<tr><td><code id="plot.spotSeverity_+3A_xlab">xlab</code></td>
<td>
<p>x axis label</p>
</td></tr>
<tr><td><code id="plot.spotSeverity_+3A_ylab">ylab</code></td>
<td>
<p>y axis label</p>
</td></tr>
<tr><td><code id="plot.spotSeverity_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>description of return value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example from D G Mayo and A Spanos. 
### Severe Testing as a Basic Concept in a Neyman–Pearson Philosophy of Induction. 
### British Journal for the Philosophy of Science, 57:323–357, 2006. (fig 2):
x0 &lt;- 12.1
mu1 &lt;- seq(11.9,13,0.01)
n &lt;- 100
sigma &lt;- 2
alpha &lt;- 0.025
tdist &lt;- FALSE
plot(mu1, spotSeverity(xbar=x0, mu0=0, mu1=mu1, n=n, sigma=sigma, alpha=alpha, 
tdist=tdist)$severity, type = "l", ylim=c(0,1), col="blue")
abline(h=0)
abline(h=1)
 abline(h=0.95)
abline(v=12.43)
### plot power:
mu0 &lt;- 12
points(mu1, spotPower(alpha, mu0, mu1, n, sigma), type = "l", ylim=c(0,1), 
col="green")
abline(v=12.72)

## Fig 13.11 in Span19a
p &lt;- spotSeverity(xbar=10, mu0=10, mu1= 10.2, n=100, sigma = 1, alpha = 0.05, tdist = FALSE)
plot(p, rangeLeft = 10, rangeRight = 10.5, plotPow = TRUE)

</code></pre>

<hr>
<h2 id='plot.spotTreeModel'>Plot rpart tree model</h2><span id='topic+plot.spotTreeModel'></span>

<h3>Description</h3>

<p>Simple plot of the model produced by <code><a href="#topic+buildTreeModel">buildTreeModel</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spotTreeModel'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.spotTreeModel_+3A_x">x</code></td>
<td>
<p>tree model (settings and parameters) of class <code>spotTreeModel</code>.</p>
</td></tr>
<tr><td><code id="plot.spotTreeModel_+3A_...">...</code></td>
<td>
<p>parameters passed to plot function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A nicer plot can be generated with the <code>plotnice()</code> function
from the <code>SPOTMisc</code> package.
</p>

<hr>
<h2 id='plotBestObj'>Plot Best Objective Value</h2><span id='topic+plotBestObj'></span>

<h3>Description</h3>

<p>Plot Best Objective Value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBestObj(y, end = length(y))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotBestObj_+3A_y">y</code></td>
<td>
<p>result vector</p>
</td></tr>
<tr><td><code id="plotBestObj_+3A_end">end</code></td>
<td>
<p>length. Default: <code>length(y)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot
</p>

<hr>
<h2 id='plotData'>Interpolated plot</h2><span id='topic+plotData'></span>

<h3>Description</h3>

<p>A (filled) contour or perspective plot of a data set with
two independent and one dependent variable. The plot is generated by some 
interpolation or regression model. By default, the <code>loess</code> function is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotData(
  x,
  y,
  which = 1:2,
  constant = x[which.min(y), ],
  model = buildLOESS,
  modelControl = list(),
  xlab = c("x1", "x2"),
  ylab = "y",
  type = "filled.contour",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotData_+3A_x">x</code></td>
<td>
<p>independent variables, or input variables. this should be a matrix of at least two columns 
and several rows. If more than two columns are present, all will be used for fitting the model.
The parameter <code>which</code> will determine which of these will be plotted, and the parameter
<code>constant</code> will determine the values of all parameters that are not varied.</p>
</td></tr>
<tr><td><code id="plotData_+3A_y">y</code></td>
<td>
<p>dependent, or observed output variable to be interpolated/regressed and plotted.</p>
</td></tr>
<tr><td><code id="plotData_+3A_which">which</code></td>
<td>
<p>a vector with two elements, each an integer giving the two independent variables of the plot 
(the integers are indices of the respective data set, i.e., columns of x). All other parameters will be fixed to the best known 
solution, i.e., the one with minimal y-value.</p>
</td></tr>
<tr><td><code id="plotData_+3A_constant">constant</code></td>
<td>
<p>a numeric vector that states for each variable a constant value that it will take on
if it is not varied in the plot. This affects the parameters not selected by the <code>which</code> parameter.
By default, this will be fixed to the best known solution, i.e., the one with minimal y-value, according
to <code>which.min(object$y)</code>. The length of this numeric vector should be the same as the number of columns in <code>object$x</code></p>
</td></tr>
<tr><td><code id="plotData_+3A_model">model</code></td>
<td>
<p>the model building function to be used, by default <code>buildLOESS</code>.</p>
</td></tr>
<tr><td><code id="plotData_+3A_modelcontrol">modelControl</code></td>
<td>
<p>control list of the chosen model building function.</p>
</td></tr>
<tr><td><code id="plotData_+3A_xlab">xlab</code></td>
<td>
<p>a vector of characters, giving the labels for each of the two independent variables</p>
</td></tr>
<tr><td><code id="plotData_+3A_ylab">ylab</code></td>
<td>
<p>character, the value of the dependent variable predicted by the corresponding model</p>
</td></tr>
<tr><td><code id="plotData_+3A_type">type</code></td>
<td>
<p>string describing the type of the plot:  <code>"filled.contour"</code> (default), <code>"contour"</code>, 
<code>"persp"</code> (perspective), or <code>"persp3d"</code> plot.
Note that &quot;persp3d&quot; is based on the plotly package and will work in RStudio, but not in the standard RGui.</p>
</td></tr>
<tr><td><code id="plotData_+3A_...">...</code></td>
<td>
<p>additional parameters passed to the <code>contour</code> or <code>filled.contour</code> function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plotFunction">plotFunction</a></code>, <code><a href="#topic+plotModel">plotModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate random test data
testfun &lt;- function (x) sum(x^2)
set.seed(1)
k &lt;- 30
x &lt;- cbind(runif(k)*15-5,runif(k)*15)
y &lt;- as.matrix(apply(x,1,testfun))
plotData(x,y)
plotData(x,y,type="contour")
plotData(x,y,type="persp")

</code></pre>

<hr>
<h2 id='plotFunction'>Surface plot of a function</h2><span id='topic+plotFunction'></span>

<h3>Description</h3>

<p>A (filled) contour plot or perspective / surface plot of a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotFunction(
  f = function(x) {
     rowSums(x^2)
 },
  lower = c(0, 0),
  upper = c(1, 1),
  type = "filled.contour",
  s = 100,
  xlab = "x1",
  ylab = "x2",
  zlab = "y",
  color.palette = terrain.colors,
  title = " ",
  levels = NULL,
  points1,
  points2,
  pch1 = 20,
  pch2 = 8,
  lwd1 = 1,
  lwd2 = 1,
  cex1 = 1,
  cex2 = 1,
  col1 = "red",
  col2 = "black",
  theta = -40,
  phi = 40,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotFunction_+3A_f">f</code></td>
<td>
<p>function to be plotted. The function should either be able to take two vectors or one matrix specifying sample locations. i.e. <code>z=f(X)</code> or <code>z=f(x2,x1)</code> where Z is a two column matrix containing the sample locations <code>x1</code> and <code>x2</code>.</p>
</td></tr>
<tr><td><code id="plotFunction_+3A_lower">lower</code></td>
<td>
<p>boundary for x1 and x2 (defaults to <code>c(0,0)</code>).</p>
</td></tr>
<tr><td><code id="plotFunction_+3A_upper">upper</code></td>
<td>
<p>boundary (defaults to <code>c(1,1)</code>).</p>
</td></tr>
<tr><td><code id="plotFunction_+3A_type">type</code></td>
<td>
<p>string describing the type of the plot:  <code>"filled.contour"</code> (default), <code>"contour"</code>, 
<code>"persp"</code> (perspective), or <code>"persp3d"</code> plot.
Note that &quot;persp3d&quot; is based on the plotly package and will work in RStudio, but not in the standard RGui.</p>
</td></tr>
<tr><td><code id="plotFunction_+3A_s">s</code></td>
<td>
<p>number of samples along each dimension. e.g. <code>f</code> will be evaluated <code>s^2</code> times.</p>
</td></tr>
<tr><td><code id="plotFunction_+3A_xlab">xlab</code></td>
<td>
<p>lable of first axis</p>
</td></tr>
<tr><td><code id="plotFunction_+3A_ylab">ylab</code></td>
<td>
<p>lable of second axis</p>
</td></tr>
<tr><td><code id="plotFunction_+3A_zlab">zlab</code></td>
<td>
<p>lable of third axis</p>
</td></tr>
<tr><td><code id="plotFunction_+3A_color.palette">color.palette</code></td>
<td>
<p>colors used, default is <code>terrain.color</code></p>
</td></tr>
<tr><td><code id="plotFunction_+3A_title">title</code></td>
<td>
<p>of the plot</p>
</td></tr>
<tr><td><code id="plotFunction_+3A_levels">levels</code></td>
<td>
<p>number of levels for the plotted function value. Will be set automatically with default NULL.. (contour plots  only)</p>
</td></tr>
<tr><td><code id="plotFunction_+3A_points1">points1</code></td>
<td>
<p>can be omitted, but if given the points in this matrix are added to the plot in form of dots. Contour plots and persp3d only. Contour plots expect matrix with two columns for coordinates. 3Dperspective expects matrix with three columns, third column giving the corresponding observed value of the plotted function.</p>
</td></tr>
<tr><td><code id="plotFunction_+3A_points2">points2</code></td>
<td>
<p>can be omitted, but if given the points in this matrix are added to the plot in form of crosses. Contour plots and persp3d only.  Contour plots expect matrix with two columns for coordinates. 3Dperspective expects matrix with three columns, third column giving the corresponding observed value of the plotted function.</p>
</td></tr>
<tr><td><code id="plotFunction_+3A_pch1">pch1</code></td>
<td>
<p>pch (symbol) setting for points1 (default: 20). (contour plots only)</p>
</td></tr>
<tr><td><code id="plotFunction_+3A_pch2">pch2</code></td>
<td>
<p>pch (symbol) setting for points2 (default: 8). (contour plots only)</p>
</td></tr>
<tr><td><code id="plotFunction_+3A_lwd1">lwd1</code></td>
<td>
<p>line width for points1 (default: 1). (contour plots only)</p>
</td></tr>
<tr><td><code id="plotFunction_+3A_lwd2">lwd2</code></td>
<td>
<p>line width for points2 (default: 1). (contour plots only)</p>
</td></tr>
<tr><td><code id="plotFunction_+3A_cex1">cex1</code></td>
<td>
<p>cex for points1 (default: 1). (contour plots only)</p>
</td></tr>
<tr><td><code id="plotFunction_+3A_cex2">cex2</code></td>
<td>
<p>cex for points2 (default: 1). (contour plots only)</p>
</td></tr>
<tr><td><code id="plotFunction_+3A_col1">col1</code></td>
<td>
<p>color for points1 (default: &quot;black&quot;). (contour plots only)</p>
</td></tr>
<tr><td><code id="plotFunction_+3A_col2">col2</code></td>
<td>
<p>color for points2 (default: &quot;black&quot;). (contour plots only)</p>
</td></tr>
<tr><td><code id="plotFunction_+3A_theta">theta</code></td>
<td>
<p>angle defining the viewing direction. theta gives the azimuthal direction and phi the colatitude. (persp plot only)</p>
</td></tr>
<tr><td><code id="plotFunction_+3A_phi">phi</code></td>
<td>
<p>angle defining the viewing direction. theta gives the colatitude. (persp plot only)</p>
</td></tr>
<tr><td><code id="plotFunction_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code>contour</code> or <code>filled.contour</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plotData">plotData</a></code>, <code><a href="#topic+plotModel">plotModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plotFunction(function(x){rowSums(x^2)},c(-5,0),c(10,15))
plotFunction(function(x){rowSums(x^2)},c(-5,0),c(10,15),type="contour")
plotFunction(function(x){rowSums(x^2)},c(-5,0),c(10,15),type="persp")

</code></pre>

<hr>
<h2 id='plotModel'>Surface plot of a model</h2><span id='topic+plotModel'></span>

<h3>Description</h3>

<p>A (filled) contour or perspective plot of a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotModel(
  object,
  which = if (ncol(object$x) &gt; 1 &amp; tolower(type) != "singledim") {
     1:2
 } else {
 
       1
 },
  constant = object$x[which.min(object$y), ],
  xlab = paste("x", which, sep = ""),
  ylab = "y",
  type = "filled.contour",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotModel_+3A_object">object</code></td>
<td>
<p>fit created by a modeling function, e.g., <code><a href="#topic+buildRandomForest">buildRandomForest</a></code>.</p>
</td></tr>
<tr><td><code id="plotModel_+3A_which">which</code></td>
<td>
<p>a vector with two elements, each an integer giving the two independent variables of the plot 
(the integers are indices of the respective data set).</p>
</td></tr>
<tr><td><code id="plotModel_+3A_constant">constant</code></td>
<td>
<p>a numeric vector that states for each variable a constant value that it will take on
if it is not varied in the plot. This affects the parameters not selected by the <code>which</code> parameter.
By default, this will be fixed to the best known solution, i.e., the one with minimal y-value, according
to <code>which.min(object$y)</code>. The length of this numeric vector should be the same as the number of columns in <code>object$x</code></p>
</td></tr>
<tr><td><code id="plotModel_+3A_xlab">xlab</code></td>
<td>
<p>a vector of characters, giving the labels for each of the two independent variables.</p>
</td></tr>
<tr><td><code id="plotModel_+3A_ylab">ylab</code></td>
<td>
<p>character, the value of the dependent variable predicted by the corresponding model.</p>
</td></tr>
<tr><td><code id="plotModel_+3A_type">type</code></td>
<td>
<p>string describing the type of the plot:  <code>"filled.contour"</code> (default), <code>"contour"</code>, 
<code>"persp"</code> (perspective), or <code>"persp3d"</code> plot.
Note that &quot;persp3d&quot; is based on the plotly package and will work in RStudio, but not in the standard RGui.</p>
</td></tr>
<tr><td><code id="plotModel_+3A_...">...</code></td>
<td>
<p>additional parameters passed to the <code>contour</code> or <code>filled.contour</code> function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plotFunction">plotFunction</a></code>, <code><a href="#topic+plotData">plotData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate random test data
testfun &lt;- function (x) sum(x^2)
set.seed(1)
k &lt;- 30
x &lt;- cbind(runif(k)*15-5,runif(k)*15,runif(k)*2-7,runif(k)*5+22)
y &lt;- as.matrix(apply(x,1,testfun))
fit &lt;- buildLM(x,y)
plotModel(fit)
plotModel(fit,type="contour")
plotModel(fit,type="persp")
plotModel(fit,which=c(1,4))
plotModel(fit,which=2:3)

</code></pre>

<hr>
<h2 id='plotPCA'>plotPCA</h2><span id='topic+plotPCA'></span>

<h3>Description</h3>

<p>plotPCA returns a 2D plot of optimization data in it's own space using buildPCA. 
It plots first two PCAs by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPCA(x, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPCA_+3A_x">x</code></td>
<td>
<p>dataset of parameters to be transformed &amp; plotted</p>
</td></tr>
<tr><td><code id="plotPCA_+3A_control">control</code></td>
<td>
<p>control list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a plot image.
</p>


<h3>Author(s)</h3>

<p>Alpar Gür <a href="mailto:alpar.guer@smail.th-koeln.de">alpar.guer@smail.th-koeln.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildPCA">buildPCA</a></code>, <code><a href="stats.html#topic+biplot">biplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define objective function
funGauss &lt;- function (x) {
  gauss &lt;- function(par) {
    y &lt;- c(0.0009, 0.0044, 0.0175, 0.0540, 0.1295, 0.2420, 0.3521, 0.3989,
           0.3521, 0.2420, 0.1295, 0.0540, 0.0175, 0.0044, 0.0009)
    m &lt;- 15
    x1 &lt;- par[1]
    x2 &lt;- par[2]
    x3 &lt;- par[3]
    
    fsum &lt;- 0
    for (i in 1:m) {
      ti &lt;- (8 - i) * 0.5
      f &lt;- x1 * exp(-0.5 * x2 * (ti - x3) ^ 2) - y[i]
      fsum &lt;- fsum + f * f
    }
    return(fsum)
  }
  matrix(apply(x, # matrix
               1, # margin (apply over rows)
               gauss),
         , 1) # number of columns
}

# define starting point
x1 &lt;- matrix(c(1,1,1),1,)
funGauss(x1)

# define boundaries
lower = c(-0.001,-0.007,-0.003)
upper = c(0.5,1.0,1.1)

res &lt;- spot(,funGauss, lower=lower, upper=upper, control=list(funEvals=15))

control = list(scale=TRUE) #pca control list, # scale the variables

plotPCA(res$x, control=control) # plot first two PCAs

</code></pre>

<hr>
<h2 id='plotPCAvariance'>plotPCAvariance</h2><span id='topic+plotPCAvariance'></span>

<h3>Description</h3>

<p>plotPCAvariance illustrates the total variance within the dataset.
It plots the effectiveness of each principal component and can be used to decide how many and which prinicpal components to plot.
In order to create this plot, users don't need to build PCA beforehand since it handles this process automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPCAvariance(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPCAvariance_+3A_x">x</code></td>
<td>
<p>dataset of parameters to be transformed &amp; plotted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a plot image.
</p>


<h3>Author(s)</h3>

<p>Alpar Gür <a href="mailto:alpar.guer@smail.th-koeln.de">alpar.guer@smail.th-koeln.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildPCA">buildPCA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># objective function
funBard &lt;- function (x) {
  bard &lt;- function(par) {
    y &lt;- c(0.14, 0.18, 0.22, 0.25, 0.29, 0.32, 0.35, 0.39, 0.37, 0.58,
           0.73, 0.96, 1.34, 2.10, 4.39)
    m &lt;- 15
    x1 &lt;- par[1]
    x2 &lt;- par[2]
    x3 &lt;- par[3]
    
    fsum &lt;- 0
    for (u in 1:m) {
      v &lt;- 16 - u
      w &lt;- min(u, v)
      f &lt;- y[u] - (x1 + u / (v * x2 + w * x3))
      fsum &lt;- fsum + f * f
    }
    return(fsum)
  }
  matrix(apply(x, # matrix
               1, # margin (apply over rows)
               bard),
         , 1) # number of columns
}

# starting point
x1 &lt;- matrix(c(1,1),1,)
funBard(x1)

#boundaries
lower = c(-0.001,-0.007,-0.003)
upper = c(0.5,1.0,1.1)

res &lt;- spot(,funBard, lower=lower, upper=upper, control=list(funEvals=15))

plotPCAvariance(res$x) # plot variance within the dataset

</code></pre>

<hr>
<h2 id='plotSingleDimFunction'>plotSingleDimFunction</h2><span id='topic+plotSingleDimFunction'></span>

<h3>Description</h3>

<p>Plot a single dimensional Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSingleDimFunction(evalFun, lower, upper, target)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSingleDimFunction_+3A_evalfun">evalFun</code></td>
<td>
<p>function to be plotted. The function should either be able to take two vectors or one matrix specifying sample locations. i.e. <code>z=f(X)</code> or <code>z=f(x2,x1)</code> where Z is a two column matrix containing the sample locations <code>x1</code> and <code>x2</code>.</p>
</td></tr>
<tr><td><code id="plotSingleDimFunction_+3A_lower">lower</code></td>
<td>
<p>boundary for x1 and x2 (defaults to <code>c(0,0)</code>).</p>
</td></tr>
<tr><td><code id="plotSingleDimFunction_+3A_upper">upper</code></td>
<td>
<p>boundary (defaults to <code>c(1,1)</code>).</p>
</td></tr>
<tr><td><code id="plotSingleDimFunction_+3A_target">target</code></td>
<td>
<p>String, which type of uncertainty estimation should be plotted? default: NULL - no estimation plotted. 's' standard estimation. 'sLinear' linearly adapted estimation.</p>
</td></tr>
</table>

<hr>
<h2 id='predict.cvModel'>predict.cvModel</h2><span id='topic+predict.cvModel'></span>

<h3>Description</h3>

<p>Predict with the cross validated model produced by <code><a href="#topic+buildCVModel">buildCVModel</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cvModel'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.cvModel_+3A_object">object</code></td>
<td>
<p>CV model (settings and parameters) of class <code>cvModel</code>.</p>
</td></tr>
<tr><td><code id="predict.cvModel_+3A_newdata">newdata</code></td>
<td>
<p>design matrix to be predicted</p>
</td></tr>
<tr><td><code id="predict.cvModel_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prediction results: list with predicted mean ('y'), estimated uncertainty ('y'), linearly adapted uncertainty ('sLinear')
</p>

<hr>
<h2 id='predict.dace'>DACE predictor</h2><span id='topic+predict.dace'></span>

<h3>Description</h3>

<p>Predicts <code>y(x)</code> for a given DACE model (i.e. as created by <code><a href="#topic+buildKrigingDACE">buildKrigingDACE</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dace'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.dace_+3A_object">object</code></td>
<td>
<p>Kriging model (settings and parameters) of class <code>dace</code>.</p>
</td></tr>
<tr><td><code id="predict.dace_+3A_newdata">newdata</code></td>
<td>
<p>design matrix (<code>x</code>) to be predicted</p>
</td></tr>
<tr><td><code id="predict.dace_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list with the following elements: 
</p>
<table>
<tr><td><code>f</code></td>
<td>
<p> Predicted response <code>y</code> at design points <code>x</code> (always)</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p> Gradient of response <code>y</code> at design points <code>x</code>  (only if: <code>GRAD==TRUE</code> and <code>mx==1</code>)</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p> Estimated MSE (only if: <code>MSE==TRUE</code>)</p>
</td></tr>
<tr><td><code>ds</code></td>
<td>
<p> Gradient of MSE (only if: <code>GRADMSE==TRUE</code> and <code>mx==1</code>)</p>
</td></tr>
</table>
<p>The user can choose whether to predict only mean or if he is also interested in gradient, mean squared error MSE, or the MSE gradient.
<code>object$GRAD</code> specifies whether gradient of response should be computed. Even if GRAD is TRUE, the gradient will only be computed in case of a single design point.
<code>MSE</code> specifies whether estimated MSE of response should be computed.
<code>GRADMSE</code> specifies whether gradient of MSE should be computed.  Even if GRADMSE is TRUE, the gradient will only be computed in case of a single design point.
</p>


<h3>Author(s)</h3>

<p>The authors of the original DACE Matlab toolbox \ 
are Hans Bruun Nielsen, Soren Nymand Lophaven and Jacob Sondergaard. <br />
Additional code for generalization to different models by Tobias Wagner <a href="mailto:wagner@isf.de">wagner@isf.de</a>. <br /> 
Porting and adaptation to R and further extensions by Martin Zaefferer <a href="mailto:martin.zaefferer@fh-koeln.de">martin.zaefferer@fh-koeln.de</a>.
</p>


<h3>References</h3>

<p>S.~Lophaven, H.~Nielsen, and J.~Sondergaard.
DACE&mdash;A Matlab Kriging Toolbox.
Technical Report IMM-REP-2002-12, Informatics and Mathematical
Modelling, Technical University of Denmark, Copenhagen, Denmark, 2002.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKrigingDACE">buildKrigingDACE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create design points
x &lt;- cbind(runif(20)*15-5,runif(20)*15)
## Compute observations at design points
y &lt;- funSphere(x)
## Create model
fit &lt;- buildKrigingDACE(x,y)
## Create new design
xx &lt;- cbind(runif(20)*15-5,runif(20)*15)
## Predict candidates
y1 &lt;- predict(fit,xx)$y
## Plot residuals
plot(y1 - funSphere(xx))

</code></pre>

<hr>
<h2 id='predict.ensembleStack'>Predict Stacked Ensemble</h2><span id='topic+predict.ensembleStack'></span>

<h3>Description</h3>

<p>Predict with ensemble model produced by <code><a href="#topic+buildEnsembleStack">buildEnsembleStack</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ensembleStack'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.ensembleStack_+3A_object">object</code></td>
<td>
<p>Kriging model (settings and parameters) of class <code>kriging</code>.</p>
</td></tr>
<tr><td><code id="predict.ensembleStack_+3A_newdata">newdata</code></td>
<td>
<p>design matrix to be predicted</p>
</td></tr>
<tr><td><code id="predict.ensembleStack_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with predicted value <code>y</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKriging">buildKriging</a></code>
</p>

<hr>
<h2 id='predict.kriging'>Predict Kriging Model</h2><span id='topic+predict.kriging'></span>

<h3>Description</h3>

<p>Predict with Kriging model produced by <code><a href="#topic+buildKriging">buildKriging</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kriging'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.kriging_+3A_object">object</code></td>
<td>
<p>Kriging model (settings and parameters) of class <code>kriging</code>.</p>
</td></tr>
<tr><td><code id="predict.kriging_+3A_newdata">newdata</code></td>
<td>
<p>design matrix to be predicted</p>
</td></tr>
<tr><td><code id="predict.kriging_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with predicted mean <code>y</code>, uncertainty / standard deviation <code>s</code> (optional)
and expected improvement <code>ei</code> (optional).
Whether <code>s</code> and <code>ei</code> are returned is specified by the vector of strings
<code>object$target</code>, which then contains <code>"s"</code> and <code>"ei"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKriging">buildKriging</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Create design points
x &lt;- cbind(runif(20)*15-5,runif(20)*15)
## Compute observations at design points (for Branin function)
y &lt;- funBranin(x)
## Create model
fit &lt;- buildKriging(x,y)
fit$target &lt;- c("y","s","ei")
## first estimate error with regressive predictor
predict(fit,x)

</code></pre>

<hr>
<h2 id='predict.rsdummy'>Predict random search dummy</h2><span id='topic+predict.rsdummy'></span>

<h3>Description</h3>

<p>This function is used to emulate uniform random search with SPOT.
It is a placeholder for the surrogate model and
simply returns <code>NA</code> when called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rsdummy'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.rsdummy_+3A_object">object</code></td>
<td>
<p>dummy object, not used.</p>
</td></tr>
<tr><td><code id="predict.rsdummy_+3A_newdata">newdata</code></td>
<td>
<p>dummy data, not used.</p>
</td></tr>
<tr><td><code id="predict.rsdummy_+3A_...">...</code></td>
<td>
<p>additional arguments, not used.</p>
</td></tr>
</table>

<hr>
<h2 id='predict.spotBOModel'>Prediction method for bayesian optimization model</h2><span id='topic+predict.spotBOModel'></span>

<h3>Description</h3>

<p>Wrapper for <code>predict.spotBOModel</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spotBOModel'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.spotBOModel_+3A_object">object</code></td>
<td>
<p>fit of the model, an object of class <code>"spotBOModel"</code>, produced by <code><a href="#topic+buildBO">buildBO</a></code>.</p>
</td></tr>
<tr><td><code id="predict.spotBOModel_+3A_newdata">newdata</code></td>
<td>
<p>matrix of new data.</p>
</td></tr>
<tr><td><code id="predict.spotBOModel_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with predicted mean <code>y</code>, uncertainty / standard deviation <code>s</code> (optional)
and expected improvement <code>ei</code> (optional).
Whether <code>s</code> and <code>ei</code> are returned is specified by the vector of
strings <code>object$target</code>, which then contains <code>"s"</code> and <code>"ei"</code>.
</p>

<hr>
<h2 id='predict.spotGaussianProcessModel'>Prediction method for Gaussian Process Model</h2><span id='topic+predict.spotGaussianProcessModel'></span>

<h3>Description</h3>

<p>Prediction method for Gaussian Process Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spotGaussianProcessModel'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.spotGaussianProcessModel_+3A_object">object</code></td>
<td>
<p>fit of the model, an object of class <code>"spotGaussianProcessModel"</code>, produced by <code><a href="#topic+buildGaussianProcess">buildGaussianProcess</a></code>.</p>
</td></tr>
<tr><td><code id="predict.spotGaussianProcessModel_+3A_newdata">newdata</code></td>
<td>
<p>matrix of new data.</p>
</td></tr>
<tr><td><code id="predict.spotGaussianProcessModel_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='predict.spotLassoModel'>Prediction method for lasso model</h2><span id='topic+predict.spotLassoModel'></span>

<h3>Description</h3>

<p>Wrapper for <code>predict.glmnet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spotLassoModel'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.spotLassoModel_+3A_object">object</code></td>
<td>
<p>fit of the model, an object of class <code>"spotLassoModel"</code>, 
produced by <code><a href="#topic+buildLasso">buildLasso</a></code>.</p>
</td></tr>
<tr><td><code id="predict.spotLassoModel_+3A_newdata">newdata</code></td>
<td>
<p>matrix of new data.</p>
</td></tr>
<tr><td><code id="predict.spotLassoModel_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='predict.spotLinearModel'>Prediction method for linear model</h2><span id='topic+predict.spotLinearModel'></span>

<h3>Description</h3>

<p>Wrapper for <code>predict.lm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spotLinearModel'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.spotLinearModel_+3A_object">object</code></td>
<td>
<p>fit of the model, an object of class <code>"spotLinearModel"</code>, produced by <code><a href="#topic+buildLM">buildLM</a></code>.</p>
</td></tr>
<tr><td><code id="predict.spotLinearModel_+3A_newdata">newdata</code></td>
<td>
<p>matrix of new data.</p>
</td></tr>
<tr><td><code id="predict.spotLinearModel_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='predict.spotLOESS'>Predict loess model</h2><span id='topic+predict.spotLOESS'></span>

<h3>Description</h3>

<p>Predict with model produced by <code><a href="#topic+buildLOESS">buildLOESS</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spotLOESS'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.spotLOESS_+3A_object">object</code></td>
<td>
<p>loess model (settings and parameters) of class <code>spotLOESS</code>.</p>
</td></tr>
<tr><td><code id="predict.spotLOESS_+3A_newdata">newdata</code></td>
<td>
<p>design matrix to be predicted</p>
</td></tr>
<tr><td><code id="predict.spotLOESS_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with predicted value <code>y</code>, standard error 
<code>s</code> (if object$target contains <code>"s"</code>) and
<code>ei</code> (if object$target contains <code>"ei"</code>) and
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildLOESS">buildLOESS</a></code>
</p>

<hr>
<h2 id='predict.spotRandomForest'>Prediction method for random forest</h2><span id='topic+predict.spotRandomForest'></span>

<h3>Description</h3>

<p>Wrapper for <code>predict.randomForest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spotRandomForest'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.spotRandomForest_+3A_object">object</code></td>
<td>
<p>fit of the model, an object of class <code>"spotRandomForest"</code>, produced by <code><a href="#topic+buildRandomForest">buildRandomForest</a></code>.</p>
</td></tr>
<tr><td><code id="predict.spotRandomForest_+3A_newdata">newdata</code></td>
<td>
<p>matrix of new data.</p>
</td></tr>
<tr><td><code id="predict.spotRandomForest_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='predict.spotRanger'>Predictor for spotExtraTrees</h2><span id='topic+predict.spotRanger'></span>

<h3>Description</h3>

<p>Wrapper for <code>predict.ranger</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spotRanger'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.spotRanger_+3A_object">object</code></td>
<td>
<p>fit of the model, an object of class <code>"spotRandomForest"</code>, produced by <code><a href="#topic+buildRandomForest">buildRandomForest</a></code>.</p>
</td></tr>
<tr><td><code id="predict.spotRanger_+3A_newdata">newdata</code></td>
<td>
<p>matrix of new data.</p>
</td></tr>
<tr><td><code id="predict.spotRanger_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='predict.spotRSM'>Predict RSM model</h2><span id='topic+predict.spotRSM'></span>

<h3>Description</h3>

<p>Predict with model produced by <code><a href="#topic+buildRSM">buildRSM</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spotRSM'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.spotRSM_+3A_object">object</code></td>
<td>
<p>RSM model (settings and parameters) of class <code>spotRSM</code>.</p>
</td></tr>
<tr><td><code id="predict.spotRSM_+3A_newdata">newdata</code></td>
<td>
<p>design matrix to be predicted</p>
</td></tr>
<tr><td><code id="predict.spotRSM_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with predicted value <code>y</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildRSM">buildRSM</a></code>
</p>

<hr>
<h2 id='predict.spotTreeModel'>Prediction method for rpart tree models</h2><span id='topic+predict.spotTreeModel'></span>

<h3>Description</h3>

<p>Wrapper for <code>predict.rpart</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spotTreeModel'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.spotTreeModel_+3A_object">object</code></td>
<td>
<p>fit of the model, an object of class <code>"spotTreeModel"</code>, produced by <code><a href="#topic+buildTreeModel">buildTreeModel</a></code>.</p>
</td></tr>
<tr><td><code id="predict.spotTreeModel_+3A_newdata">newdata</code></td>
<td>
<p>matrix of new data.</p>
</td></tr>
<tr><td><code id="predict.spotTreeModel_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='predictKrigingReinterpolation'>Predict Kriging Model (Re-interpolating)</h2><span id='topic+predictKrigingReinterpolation'></span>

<h3>Description</h3>

<p>Kriging predictor with re-interpolation to avoid stalling the optimization process
which employs this model as a surrogate.
This is supposed to be used with deterministic experiments,
which do need a non-interpolating model that avoids predicting non-zero error at sample locations.
This can be useful when the model is deterministic
(i.e. repeated evaluations of one parameter vector do not yield different values)
but does have a &quot;noisy&quot; structure (e.g. due to computational inaccuracies, systematical error).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictKrigingReinterpolation(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictKrigingReinterpolation_+3A_object">object</code></td>
<td>
<p>Kriging model (settings and parameters) of class <code>kriging</code>.</p>
</td></tr>
<tr><td><code id="predictKrigingReinterpolation_+3A_newdata">newdata</code></td>
<td>
<p>design matrix to be predicted</p>
</td></tr>
<tr><td><code id="predictKrigingReinterpolation_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please note that this re-interpolation implementation will not necessarily yield values of
exactly zero at the sample locations used for model building. Slight deviations can occur.
</p>


<h3>Value</h3>

<p>list with predicted mean <code>y</code>, uncertainty <code>s</code> (optional) and expected improvement <code>ei</code> (optional).
Whether <code>s</code> and <code>ei</code> are returned is specified by the vector of strings <code>object$target</code>,
which then contains &quot;s&quot; and &quot;ei.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKriging">buildKriging</a></code>, <code><a href="#topic+predict.kriging">predict.kriging</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Create design points
x &lt;- cbind(runif(20)*15-5,runif(20)*15)
## Compute observations at design points (for Branin function)
y &lt;- funBranin(x)
## Create model
fit &lt;- buildKriging(x,y,control=list(reinterpolate=FALSE))
fit$target &lt;- c("y","s")
## first estimate error with regressive predictor
sreg &lt;- predict(fit,x)$s
## now estimate error with re-interpolating predictor
sreint &lt;- predictKrigingReinterpolation(fit,x)$s
## equivalent:
fit$reinterpolate &lt;- TRUE
sreint2 &lt;- predict(fit,x)$s
print(sreg)
print(sreint)
print(sreint2)
## sreint should be close to zero, significantly smaller than sreg

</code></pre>

<hr>
<h2 id='prepareBestObjectiveVal'>Preprocess y Values to Plot Best Objective Value</h2><span id='topic+prepareBestObjectiveVal'></span>

<h3>Description</h3>

<p>Preprocess y Values to Plot Best Objective Value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepareBestObjectiveVal(y, end = length(y))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepareBestObjectiveVal_+3A_y">y</code></td>
<td>
<p>result vector</p>
</td></tr>
<tr><td><code id="prepareBestObjectiveVal_+3A_end">end</code></td>
<td>
<p>length. Default: <code>length(y)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>prog
</p>

<hr>
<h2 id='print.dace'>Print Function DACE Kriging</h2><span id='topic+print.dace'></span><span id='topic+print.kriging'></span>

<h3>Description</h3>

<p>Print information about a DACE Kriging fit, as produced by <code><a href="#topic+buildKrigingDACE">buildKrigingDACE</a></code>.
</p>
<p>Print information about a Forrester Kriging fit, as produced by <code><a href="#topic+buildKriging">buildKriging</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dace'
print(x, ...)

## S3 method for class 'kriging'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dace_+3A_x">x</code></td>
<td>
<p>fit returned by <code><a href="#topic+buildKriging">buildKriging</a></code>.</p>
</td></tr>
<tr><td><code id="print.dace_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>

<hr>
<h2 id='print.spotBOModel'>Print method for BO model</h2><span id='topic+print.spotBOModel'></span>

<h3>Description</h3>

<p>Wrapper for <code>print.spotBOModel</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spotBOModel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.spotBOModel_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="print.spotBOModel_+3A_object">object</code></td>
<td>
<p>fit of the model, an object of class <code>"spotBOModel"</code>, produced by <code><a href="#topic+buildBO">buildBO</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='print.spotGaussianProcessModel'>Print method for Gaussian Process Model</h2><span id='topic+print.spotGaussianProcessModel'></span>

<h3>Description</h3>

<p>Print method for Gaussian Process Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spotGaussianProcessModel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.spotGaussianProcessModel_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="print.spotGaussianProcessModel_+3A_object">object</code></td>
<td>
<p>fit of the model, an object of class <code>"spotGaussianProcessModel"</code>, produced by <code><a href="#topic+buildGaussianProcess">buildGaussianProcess</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='print.spotLassoModel'>Print method for lasso model</h2><span id='topic+print.spotLassoModel'></span>

<h3>Description</h3>

<p>Wrapper for <code>print.lasso</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spotLassoModel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.spotLassoModel_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="print.spotLassoModel_+3A_object">object</code></td>
<td>
<p>fit of the model, an object of class <code>"spotLassoModel"</code>, 
produced by <code><a href="#topic+buildLasso">buildLasso</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='print.spotLinearModel'>Print method for linear model</h2><span id='topic+print.spotLinearModel'></span>

<h3>Description</h3>

<p>Wrapper for <code>print.lm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spotLinearModel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.spotLinearModel_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="print.spotLinearModel_+3A_object">object</code></td>
<td>
<p>fit of the model, an object of class <code>"spotLinearModel"</code>, produced by <code><a href="#topic+buildLM">buildLM</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='print.spotLOESS'>Print method for loess model</h2><span id='topic+print.spotLOESS'></span>

<h3>Description</h3>

<p>Wrapper for <code>summary.loess</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spotLOESS'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.spotLOESS_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="print.spotLOESS_+3A_object">object</code></td>
<td>
<p>fit of the model, an object of class <code>"spotLOESS"</code>, produced by <code><a href="#topic+buildLOESS">buildLOESS</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+buildLOESS">buildLOESS</a></code>
</p>

<hr>
<h2 id='print.spotRandomForest'>Print method for random forest</h2><span id='topic+print.spotRandomForest'></span>

<h3>Description</h3>

<p>Wrapper for <code>print.randomForest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spotRandomForest'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.spotRandomForest_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="print.spotRandomForest_+3A_object">object</code></td>
<td>
<p>fit of the model, an object of class <code>"spotRandomForest"</code>, produced by <code><a href="#topic+buildRandomForest">buildRandomForest</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='print.spotRanger'>Print method for random forest</h2><span id='topic+print.spotRanger'></span>

<h3>Description</h3>

<p>Wrapper for <code>print.ranger</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spotRanger'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.spotRanger_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="print.spotRanger_+3A_object">object</code></td>
<td>
<p>fit of the model, an object of class <code>"spotRandomForest"</code>, produced by <code><a href="#topic+buildRandomForest">buildRandomForest</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='print.spotRSM'>Print method for RSM model</h2><span id='topic+print.spotRSM'></span>

<h3>Description</h3>

<p>Wrapper for <code>summary.rsm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spotRSM'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.spotRSM_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="print.spotRSM_+3A_object">object</code></td>
<td>
<p>fit of the model, an object of class <code>"spotRSM"</code>, produced by <code><a href="#topic+buildRSM">buildRSM</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+buildRSM">buildRSM</a></code>
</p>

<hr>
<h2 id='print.spotSeverity'>Print method for spotSeverity</h2><span id='topic+print.spotSeverity'></span>

<h3>Description</h3>

<p>Wrapper for <code>print.spotSeverity</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spotSeverity'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.spotSeverity_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="print.spotSeverity_+3A_object">object</code></td>
<td>
<p>an object of class <code>"spotSeverity"</code>, produced by <code><a href="#topic+spotSeverity">spotSeverity</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='print.spotTreeModel'>Print method for rpart tree models</h2><span id='topic+print.spotTreeModel'></span>

<h3>Description</h3>

<p>Wrapper for <code>print.rpart</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spotTreeModel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.spotTreeModel_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="print.spotTreeModel_+3A_object">object</code></td>
<td>
<p>fit of the model, an object of class <code>"spotRandomForest"</code>, produced by <code><a href="#topic+buildRandomForest">buildRandomForest</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='regpoly0'>Regression: Regpoly0</h2><span id='topic+regpoly0'></span>

<h3>Description</h3>

<p>Zero order polynomial regression function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regpoly0(S, grad = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regpoly0_+3A_s">S</code></td>
<td>
<p>m*n matrix with <code>m</code> design points of dimension <code>n</code></p>
</td></tr>
<tr><td><code id="regpoly0_+3A_grad">grad</code></td>
<td>
<p>define if function returns gradient, default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list with two elements:
</p>
<table>
<tr><td><code>f</code></td>
<td>
<p>vector of ones, with length <code>m</code></p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Jacobian at the first point (first row in S) </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The authors of the original DACE Matlab code
are Hans Bruun Nielsen, Soren Nymand Lophaven and Jacob Sondergaard. <br />
Ported to R by Martin Zaefferer <a href="mailto:martin.zaefferer@fh-koeln.de">martin.zaefferer@fh-koeln.de</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKrigingDACE">buildKrigingDACE</a></code>
</p>

<hr>
<h2 id='regpoly1'>Regression: Regpoly1</h2><span id='topic+regpoly1'></span>

<h3>Description</h3>

<p>First order polynomial regression function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regpoly1(S, grad = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regpoly1_+3A_s">S</code></td>
<td>
<p>m*n matrix with <code>m</code> design points of dimension <code>n</code></p>
</td></tr>
<tr><td><code id="regpoly1_+3A_grad">grad</code></td>
<td>
<p>define if function returns gradient, default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list with two elements:
</p>
<table>
<tr><td><code>f</code></td>
<td>
<p>matrix of two columns: <br /> 
1. vector of ones with length <code>m</code> <br />
2. <code>S</code></p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Jacobian at the first point (first row in S) </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The authors of the original DACE Matlab code
are Hans Bruun Nielsen, Soren Nymand Lophaven and Jacob Sondergaard. <br />
Ported to R by Martin Zaefferer <a href="mailto:martin.zaefferer@fh-koeln.de">martin.zaefferer@fh-koeln.de</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKrigingDACE">buildKrigingDACE</a></code>
</p>

<hr>
<h2 id='regpoly2'>Regression: Regpoly2</h2><span id='topic+regpoly2'></span>

<h3>Description</h3>

<p>Second order polynomial regression function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regpoly2(S, grad = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regpoly2_+3A_s">S</code></td>
<td>
<p>m*n matrix with <code>m</code> design points of dimension <code>n</code></p>
</td></tr>
<tr><td><code id="regpoly2_+3A_grad">grad</code></td>
<td>
<p>define if function returns gradient, default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list with two elements:
</p>
<table>
<tr><td><code>f</code></td>
<td>
<p>matrix: <br /> 
( 1 S S[,1]*S S[,2]S[,2:n] ... S[,n]^2 )</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Jacobian at the first point (first row in S) </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The authors of the original DACE Matlab code  
are Hans Bruun Nielsen, Soren Nymand Lophaven and Jacob Sondergaard. <br />
Ported to R by Martin Zaefferer <a href="mailto:martin.zaefferer@fh-koeln.de">martin.zaefferer@fh-koeln.de</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKrigingDACE">buildKrigingDACE</a></code>
</p>

<hr>
<h2 id='repairNonNumeric'>Repair Non-numeric Values</h2><span id='topic+repairNonNumeric'></span>

<h3>Description</h3>

<p>Round non-numeric columns of a matrix, specified by a vector of data given data types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repairNonNumeric(x, types)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repairNonNumeric_+3A_x">x</code></td>
<td>
<p>matrix to be rounded</p>
</td></tr>
<tr><td><code id="repairNonNumeric_+3A_types">types</code></td>
<td>
<p>data types of the respective columns, numeric columns are specified by <code>"numeric"</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(10*runif(12),4,3)
types &lt;- c("numeric","factor","factor")
repairNonNumeric(x,types)

</code></pre>

<hr>
<h2 id='repeatsOCBA'>Optimal Computing Budget Allocation</h2><span id='topic+repeatsOCBA'></span>

<h3>Description</h3>

<p>Simple interface to the Optimal Computing Budget Allocation algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repeatsOCBA(x, y, budget, verbosity = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repeatsOCBA_+3A_x">x</code></td>
<td>
<p>matrix of samples. Identical rows indicate repeated evaluations. 
Any sample should be evaluated at least twice, to get an estimate of the variance.</p>
</td></tr>
<tr><td><code id="repeatsOCBA_+3A_y">y</code></td>
<td>
<p>observations of the respective samples. For repeated evaluations, y should differ (variance not zero).</p>
</td></tr>
<tr><td><code id="repeatsOCBA_+3A_budget">budget</code></td>
<td>
<p>of additional evaluations to be allocated to the samples.</p>
</td></tr>
<tr><td><code id="repeatsOCBA_+3A_verbosity">verbosity</code></td>
<td>
<p>verbosity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector that specifies how often each solution should be evaluated.
</p>


<h3>References</h3>

<p>Chun-hung Chen and Loo Hay Lee. 2010. Stochastic Simulation Optimization: An Optimal Computing Budget Allocation (1st ed.). World Scientific Publishing Co., Inc., River Edge, NJ, USA.
</p>


<h3>See Also</h3>

<p>repeatsOCBA calls <code><a href="#topic+OCBA">OCBA</a></code>, which also provides some additional details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(1:3,1:3),9,2)
y &lt;- runif(9)
repeatsOCBA(x,y,10)
</code></pre>

<hr>
<h2 id='repmat'>repmat</h2><span id='topic+repmat'></span>

<h3>Description</h3>

<p>Reproduce what MATLAB's repmat function can do, using kronecker function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repmat(a, n, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repmat_+3A_a">a</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="repmat_+3A_n">n</code></td>
<td>
<p>dimension 1 (rows)</p>
</td></tr>
<tr><td><code id="repmat_+3A_m">m</code></td>
<td>
<p>dimension 2 (cols)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns repeated matrix
</p>

<hr>
<h2 id='resBench01'>result from the vignette benchmark</h2><span id='topic+resBench01'></span>

<h3>Description</h3>

<p>A data set 
The corresponding code can be found in the vignette SPOTVignetteNutshell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resBench01
</code></pre>


<h3>Format</h3>

<p>A list of 
</p>

<dl>
<dt>xbest</dt><dd><p>num [1, 1:100] 188 45</p>
</dd>
</dl>


<hr>
<h2 id='resSpot'>S-Ring Simulation Data Obtained With SPOT</h2><span id='topic+resSpot'></span>

<h3>Description</h3>

<p>A data set based on evaluations of the <code>funCosts</code> function.
Second experiment (extension of the first design)
The corresponding code can be found in the vignette SPOTVignetteElevator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resSpot
</code></pre>


<h3>Format</h3>

<p>A list of 7:
</p>

<dl>
<dt>xbest</dt><dd><p>num [1, 1:2] 188 45</p>
</dd>
<dt>ybest</dt><dd><p>num [1, 1] 1e+07</p>
</dd>
<dt>x</dt><dd><p>num [1:87, 1:2] 17.4 143.6 89.9 28.7 51.4 ...</p>
</dd>
<dt>y</dt><dd><p>num [1:87, 1] 1e+07 1e+07 1e+07 1e+07 1e+07 ...</p>
</dd>
<dt>count</dt><dd><p>num  0.1 0.1 0.1 0.1 0.1 1 1 1 1 1 ...</p>
</dd>
<dt>msg</dt><dd><p> chr &quot;budget exhausted&quot;</p>
</dd>
<dt>modelFit</dt><dd><p>List of 32</p>
</dd>
</dl>


<hr>
<h2 id='resSpot2'>S-Ring Simulation Data Obtained With SPOT</h2><span id='topic+resSpot2'></span>

<h3>Description</h3>

<p>A data set based on evaluations of the <code>funCosts</code> function.
Second experiment (extension of the second design)
The corresponding code can be found in the vignette SPOTVignetteElevator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resSpot2
</code></pre>


<h3>Format</h3>

<p>A list of 7:
</p>

<dl>
<dt>xbest</dt><dd><p>num [1, 1:2] 188 45</p>
</dd>
<dt>ybest</dt><dd><p>num [1, 1] 1e+07</p>
</dd>
<dt>x</dt><dd><p>num [1:87, 1:2] 17.4 143.6 89.9 28.7 51.4 ...</p>
</dd>
<dt>y</dt><dd><p>num [1:87, 1] 1e+07 1e+07 1e+07 1e+07 1e+07 ...</p>
</dd>
<dt>count</dt><dd><p>num  0.1 0.1 0.1 0.1 0.1 1 1 1 1 1 ...</p>
</dd>
<dt>msg</dt><dd><p> chr &quot;budget exhausted&quot;</p>
</dd>
<dt>modelFit</dt><dd><p>List of 32</p>
</dd>
</dl>


<hr>
<h2 id='ring'>ring</h2><span id='topic+ring'></span>

<h3>Description</h3>

<p>main function which iterates the ring
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ring(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ring_+3A_params">params</code></td>
<td>
<p>list of 
</p>

<dl>
<dt><code>randomSeed</code></dt><dd><p>random seed</p>
</dd>
<dt><code>nStates</code></dt><dd><p>number of S-Ring states</p>
</dd>
<dt><code>nElevators</code></dt><dd><p>number of elevators</p>
</dd>
<dt><code>probNewCustomer</code></dt><dd><p>probability pf a customer arrival</p>
</dd>
<dt><code>counter</code></dt><dd><p>Counter: number of waiting customers</p>
</dd>
<dt><code>sElevator</code></dt><dd><p>Vector representing elevators (s)</p>
</dd>
<dt><code>sCustomer</code></dt><dd><p>Vector representing customers (c)</p>
</dd>
<dt><code>currentState</code></dt><dd><p>Current state that is calculated</p>
</dd>
<dt><code>nextState</code></dt><dd><p>Next state that is calculated</p>
</dd>
<dt><code>nWeights</code></dt><dd><p>Number of weights for the perceptron (= 2 * nStates)</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>number of waiting customers (estimation)
</p>

<hr>
<h2 id='runOptim'>runOptim</h2><span id='topic+runOptim'></span>

<h3>Description</h3>

<p>Run <code><a href="stats.html#topic+optim">optim</a></code> on a list of spot benchmark functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runOptim(
  fl = makeMoreFunList(),
  method = "Nelder-Mead",
  n = 2,
  k = 1:length(makeMoreFunList()$funList),
  verbosity = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runOptim_+3A_fl">fl</code></td>
<td>
<p>function list. Generated with one of the function list 
generators in <code>spot</code>, e.g., <code><a href="#topic+makeSpotFunList">makeSpotFunList</a></code> or 
<code><a href="#topic+makeMoreFunList">makeMoreFunList</a></code>. Default: <code><a href="#topic+makeMoreFunList">makeMoreFunList</a></code>.</p>
</td></tr>
<tr><td><code id="runOptim_+3A_method">method</code></td>
<td>
<p>The method used by <code><a href="stats.html#topic+optim">optim</a></code>: 
<code>"Nelder-Mead", "BFGS", "CG", "L-BFGS-B", "SANN", or "Brent"</code>.
Default: <code>"Nelder-Mead"</code>.</p>
</td></tr>
<tr><td><code id="runOptim_+3A_n">n</code></td>
<td>
<p>repeats. If <code>n &gt;1 </code>, different start points (randomized) 
will be used. Default: <code>n=2</code>.</p>
</td></tr>
<tr><td><code id="runOptim_+3A_k">k</code></td>
<td>
<p>subset of benchmark functions.
Default: <code>1:length(makeMoreFunList()$funList)</code>,
i.e., all implemented functions.</p>
</td></tr>
<tr><td><code id="runOptim_+3A_verbosity">verbosity</code></td>
<td>
<p>Level 0 shows no output (default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>res. data.frame with results: <code>c("f", "r", "y")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(runOptim(k=1)$y)
summary(runOptim(k=1, method="CG")$y)

</code></pre>

<hr>
<h2 id='runSpotBench'>runSpotBench</h2><span id='topic+runSpotBench'></span>

<h3>Description</h3>

<p>Run <code><a href="#topic+spot">spot</a></code> on a list of spot benchmark functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runSpotBench(
  fl = makeMoreFunList(),
  control = list(),
  n = 2,
  k = 1:length(makeMoreFunList()$funList),
  verbosity = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runSpotBench_+3A_fl">fl</code></td>
<td>
<p>function list. Generated with one of the function list 
generators in <code>spot</code>, e.g., <code><a href="#topic+makeSpotFunList">makeSpotFunList</a></code> or 
<code><a href="#topic+makeMoreFunList">makeMoreFunList</a></code>. Default: <code><a href="#topic+makeMoreFunList">makeMoreFunList</a></code>.</p>
</td></tr>
<tr><td><code id="runSpotBench_+3A_control">control</code></td>
<td>
<p>The control list used by <code>spot</code>.</p>
</td></tr>
<tr><td><code id="runSpotBench_+3A_n">n</code></td>
<td>
<p>repeats. If <code>n &gt;1 </code>, different start points (randomized) 
will be used. Default: <code>n=2</code>.</p>
</td></tr>
<tr><td><code id="runSpotBench_+3A_k">k</code></td>
<td>
<p>subset of benchmark functions.
Default: <code>1:length(makeMoreFunList()$funList)</code>,
i.e., all implemented functions.</p>
</td></tr>
<tr><td><code id="runSpotBench_+3A_verbosity">verbosity</code></td>
<td>
<p>Level 0 shows no output (default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>res. data.frame with results: <code>c("f", "r", "y")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(runSpotBench(k=1)$y)

</code></pre>

<hr>
<h2 id='sann2spot'>Interface SANN to SPOT</h2><span id='topic+sann2spot'></span>

<h3>Description</h3>

<p>Provide an interface for tuning SANN.
The interface function receives a <code>matrix</code> where each row is  proposed parameter setting ('temp', 'tmax'),
and each column specifies the parameters.
It generates a $(n,1)$-matrix as output, where $n$ is the number of ('temp', 'tmax') parameter settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sann2spot(algpar, par = c(10, 10), fn, maxit = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sann2spot_+3A_algpar">algpar</code></td>
<td>
<p><code>matrix</code> algorithm parameters.</p>
</td></tr>
<tr><td><code id="sann2spot_+3A_par">par</code></td>
<td>
<p>Initial values for the parameters to be optimized over.</p>
</td></tr>
<tr><td><code id="sann2spot_+3A_fn">fn</code></td>
<td>
<p>A function to be minimized (or maximized),
with first argument the vector of parameters over which minimization is to take place. It should return a scalar result.</p>
</td></tr>
<tr><td><code id="sann2spot_+3A_maxit">maxit</code></td>
<td>
<p>Total number of function evaluations: there is no other stopping criterion. Defaults to 10000.</p>
</td></tr>
<tr><td><code id="sann2spot_+3A_...">...</code></td>
<td>
<p>further arguments for <code>optim</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> of results (performance values)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sphere &lt;- function(x){sum(x^2)}
algpar &lt;- matrix(c(1:10, 1:10), 10,2)
sann2spot(algpar, fn = sphere)

</code></pre>

<hr>
<h2 id='satter'>Satterthwaite Function</h2><span id='topic+satter'></span>

<h3>Description</h3>

<p>The Satterthwaite function can be used to estimate the magnitude of the variance component (sigma_beta)^2, 
when the random factor has significant main effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>satter(MScoeff, MSi, dfi, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="satter_+3A_mscoeff">MScoeff</code></td>
<td>
<p>coefficients c_1, c_2</p>
</td></tr>
<tr><td><code id="satter_+3A_msi">MSi</code></td>
<td>
<p>mean squared values</p>
</td></tr>
<tr><td><code id="satter_+3A_dfi">dfi</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code id="satter_+3A_alpha">alpha</code></td>
<td>
<p>error probability</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note, the output from the <code>satter()</code> procedure is sigma_beta.
</p>


<h3>Value</h3>

<p>vector with 1. estimate of variance 2. degrees of freedom, 3. lower value of 1-alpha confint
4. upper value of 1-alpha confint
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- satter(MScoeff= c(1/4, -1/4)
             , MSi = c(394.9, 73.3)
             , dfi = c(4,3)
             , alpha = 0.1)
</code></pre>

<hr>
<h2 id='selectAll'>selectAll</h2><span id='topic+selectAll'></span>

<h3>Description</h3>

<p>Select all Design Points. 
Returns the whole set of proposed design points.
It is a dummy function, used as the default for more sophisticated selection procedures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectAll(x, y, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectAll_+3A_x">x</code></td>
<td>
<p>matrix of design points</p>
</td></tr>
<tr><td><code id="selectAll_+3A_y">y</code></td>
<td>
<p>matrix of function values</p>
</td></tr>
<tr><td><code id="selectAll_+3A_control">control</code></td>
<td>
<p>list of controls</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with:
</p>

<dl>
<dt><code>x</code></dt><dd><p>matrix of selected design points.</p>
</dd>
<dt><code>y</code></dt><dd><p> matrix of selected function values.</p>
</dd>
</dl>


<hr>
<h2 id='selectN'>selectN. Select n Design Points</h2><span id='topic+selectN'></span>

<h3>Description</h3>

<p>This function returns a subset of n design points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectN(x, y, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectN_+3A_x">x</code></td>
<td>
<p>matrix of design points</p>
</td></tr>
<tr><td><code id="selectN_+3A_y">y</code></td>
<td>
<p>matrix of function values</p>
</td></tr>
<tr><td><code id="selectN_+3A_control">control</code></td>
<td>
<p>list of controls
</p>

<dl>
<dt><code>N</code></dt><dd><p>number of points to be returned.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with n design points:
</p>

<dl>
<dt><code>x</code></dt><dd><p>matrix of selected design points.</p>
</dd>
<dt><code>y</code></dt><dd><p> matrix of selected function values.</p>
</dd>
</dl>


<hr>
<h2 id='simulate.kriging'>Kriging Simulation</h2><span id='topic+simulate.kriging'></span>

<h3>Description</h3>

<p>(Conditional) Simulation at given locations, with a model fit resulting from <code><a href="#topic+buildKriging">buildKriging</a></code>.
In contrast to prediction or estimation, the goal is to reproduce the covariance 
structure, rather than the data itself. Note, that the conditional simulation 
also reproduces the training data, but
has a two times larger error than the Kriging predictor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kriging'
simulate(
  object,
  nsim = 1,
  seed = NA,
  xsim,
  method = "decompose",
  conditionalSimulation = TRUE,
  Ncos = 10,
  returnAll = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.kriging_+3A_object">object</code></td>
<td>
<p>fit of the Kriging model (settings and parameters), of class <code>kriging</code>.</p>
</td></tr>
<tr><td><code id="simulate.kriging_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations</p>
</td></tr>
<tr><td><code id="simulate.kriging_+3A_seed">seed</code></td>
<td>
<p>random number generator seed. Defaults to NA, in which case no seed is set</p>
</td></tr>
<tr><td><code id="simulate.kriging_+3A_xsim">xsim</code></td>
<td>
<p>list of samples in input space, to be simulated at</p>
</td></tr>
<tr><td><code id="simulate.kriging_+3A_method">method</code></td>
<td>
<p><code>"decompose"</code> (default) or <code>"spectral"</code>, specifying the method used for simulation. 
Note that <code>"decompose"</code> is can be preferable, since it is exact but may be computationally infeasible for high-dimensional xsim.
On the other hand, <code>"spectral"</code> yields a function that can be evaluated at arbitrary sample locations.</p>
</td></tr>
<tr><td><code id="simulate.kriging_+3A_conditionalsimulation">conditionalSimulation</code></td>
<td>
<p>logical, if set to TRUE (default), the simulation is conditioned with the training data of the Kriging model.
Else, the simulation is non-conditional.</p>
</td></tr>
<tr><td><code id="simulate.kriging_+3A_ncos">Ncos</code></td>
<td>
<p>number of cosine functions (used with <code>method="spectral"</code> only)</p>
</td></tr>
<tr><td><code id="simulate.kriging_+3A_returnall">returnAll</code></td>
<td>
<p>if set to TRUE, a list with the simulated values (y) and the corresponding covariance matrix (covar)
of the simulated samples is returned.</p>
</td></tr>
<tr><td><code id="simulate.kriging_+3A_...">...</code></td>
<td>
<p>further arguments, not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returned value depends on the setting of <code>object$simulationReturnAll</code>
</p>


<h3>References</h3>

<p>N. A. Cressie. Statistics for Spatial Data. JOHN WILEY &amp; SONS INC, 1993.
</p>
<p>C. Lantuejoul. Geostatistical Simulation - Models and Algorithms. Springer-Verlag Berlin Heidelberg, 2002.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKriging">buildKriging</a></code>, <code><a href="#topic+predict.kriging">predict.kriging</a></code>
</p>

<hr>
<h2 id='simulateFunction'>simulateFunction</h2><span id='topic+simulateFunction'></span>

<h3>Description</h3>

<p>Simulation-based Function Generator. 
Generate functions via simulation of Kriging models, e.g.,
for assessment of optimization algorithms with
non-conditional or conditional simulation, based on real-world data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateFunction(
  object,
  nsim = 1,
  seed = NA,
  method = "spectral",
  xsim = NA,
  Ncos = 10,
  conditionalSimulation = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateFunction_+3A_object">object</code></td>
<td>
<p>an object generated by <code><a href="#topic+buildKriging">buildKriging</a></code></p>
</td></tr>
<tr><td><code id="simulateFunction_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulations, or test functions, to be created</p>
</td></tr>
<tr><td><code id="simulateFunction_+3A_seed">seed</code></td>
<td>
<p>a random number generator seed. Defaults to NA; which means no seed is set. For sake of reproducibility, set this to some integer value.</p>
</td></tr>
<tr><td><code id="simulateFunction_+3A_method">method</code></td>
<td>
<p><code>"decompose"</code> (default) or <code>"spectral"</code>, specifying the method used for simulation. 
Note that <code>"decompose"</code> is can be preferable, since it is exact but may be computationally infeasible for high-dimensional xsim.
On the other hand, <code>"spectral"</code> yields a function that can be evaluated at arbitrary sample locations.</p>
</td></tr>
<tr><td><code id="simulateFunction_+3A_xsim">xsim</code></td>
<td>
<p>list of samples in input space, for simulation (only used for decomposition-based simulation, not for spectral method)</p>
</td></tr>
<tr><td><code id="simulateFunction_+3A_ncos">Ncos</code></td>
<td>
<p>number of cosine functions (used with <code>method="spectral"</code> only)</p>
</td></tr>
<tr><td><code id="simulateFunction_+3A_conditionalsimulation">conditionalSimulation</code></td>
<td>
<p>whether (TRUE) or not (FALSE) to use conditional simulation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of functions, where each function is the interpolation of one simulation realization. The length of the list depends on the nsim parameter.
</p>


<h3>References</h3>

<p>N. A. Cressie. Statistics for Spatial Data. JOHN WILEY &amp; SONS INC, 1993.
</p>
<p>C. Lantuejoul. Geostatistical Simulation - Models and Algorithms. Springer-Verlag Berlin Heidelberg, 2002.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKriging">buildKriging</a></code>, <code><a href="#topic+simulate.kriging">simulate.kriging</a></code>
</p>

<hr>
<h2 id='simulationDecompose'>Kriging Simulation: Decomposition</h2><span id='topic+simulationDecompose'></span>

<h3>Description</h3>

<p>(Conditional) Simulation via decomposition approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulationDecompose(
  object,
  nsim = 1,
  xsim,
  conditionalSimulation = TRUE,
  returnAll = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulationDecompose_+3A_object">object</code></td>
<td>
<p>fit of the Kriging model (settings and parameters), of class <code>kriging</code>.</p>
</td></tr>
<tr><td><code id="simulationDecompose_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations</p>
</td></tr>
<tr><td><code id="simulationDecompose_+3A_xsim">xsim</code></td>
<td>
<p>list of samples in input space, to be simulated</p>
</td></tr>
<tr><td><code id="simulationDecompose_+3A_conditionalsimulation">conditionalSimulation</code></td>
<td>
<p>logical, if set to TRUE (default), the simulation is conditioned with the training data of the Kriging model.
Else, the simulation is non-conditional.</p>
</td></tr>
<tr><td><code id="simulationDecompose_+3A_returnall">returnAll</code></td>
<td>
<p>if set to TRUE, a list with the simulated values (y) and the corresponding covariance matrix (covar)
of the simulated samples is returned.</p>
</td></tr>
<tr><td><code id="simulationDecompose_+3A_...">...</code></td>
<td>
<p>further arguments, not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returned value depends on the setting of <code>object$simulationReturnAll</code>
</p>


<h3>References</h3>

<p>N. A. Cressie. Statistics for Spatial Data. JOHN WILEY &amp; SONS INC, 1993.
</p>
<p>C. Lantuejoul. Geostatistical Simulation - Models and Algorithms. Springer-Verlag Berlin Heidelberg, 2002.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKriging">buildKriging</a></code>, <code><a href="#topic+simulationSpectral">simulationSpectral</a></code>
</p>

<hr>
<h2 id='simulationSpectral'>simulationSpectral</h2><span id='topic+simulationSpectral'></span>

<h3>Description</h3>

<p>Kriging Simulation: Spectral Method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulationSpectral(object, conditionalSimulation = FALSE, Ncos = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulationSpectral_+3A_object">object</code></td>
<td>
<p>fit of the Kriging model (settings and parameters), of class <code>kriging</code>.</p>
</td></tr>
<tr><td><code id="simulationSpectral_+3A_conditionalsimulation">conditionalSimulation</code></td>
<td>
<p>logical, if set to TRUE (default), the simulation is conditioned with the training data of the Kriging model.
Else, the simulation is non-conditional.</p>
</td></tr>
<tr><td><code id="simulationSpectral_+3A_ncos">Ncos</code></td>
<td>
<p>number of cosine functions used to construct the simulation</p>
</td></tr>
<tr><td><code id="simulationSpectral_+3A_...">...</code></td>
<td>
<p>further arguments, not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>(Conditional) Simulation via spectral method.
</p>


<h3>Value</h3>

<p>Returned value depends on the setting of <code>object$simulationReturnAll</code>
</p>


<h3>References</h3>

<p>N. A. Cressie. Statistics for Spatial Data. JOHN WILEY &amp; SONS INC, 1993.
</p>
<p>C. Lantuejoul. Geostatistical Simulation - Models and Algorithms. Springer-Verlag Berlin Heidelberg, 2002.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildKriging">buildKriging</a></code>, <code><a href="#topic+simulationDecompose">simulationDecompose</a></code>
</p>

<hr>
<h2 id='spot'>spot</h2><span id='topic+spot'></span>

<h3>Description</h3>

<p>Sequential Parameter Optimization.
This is one of the main interfaces for using the SPOT package. Based on a user-given objective function
and configuration, <code>spot</code> finds the parameter setting that yields the lowest objective value (minimization).
To that end, it uses methods from the fields of design of experiment, statistical modeling / machine learning
and optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spot(x = NULL, fun, lower, upper, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spot_+3A_x">x</code></td>
<td>
<p>is an optional start point (or set of start points), specified as a matrix. One row for each point, and one column for each optimized parameter.</p>
</td></tr>
<tr><td><code id="spot_+3A_fun">fun</code></td>
<td>
<p>is the objective function. It should receive a matrix x and return a matrix y.
In case the function uses external code and is noisy, an additional seed parameter may be used, see the <code>control$seedFun</code> argument below for details.
Mostly, fun must have format y = f(x, ...). If a noisy function requires some specific seed handling, e.g., in some other non-R code,
a seed can be passed to fun. For that purpose, the user must specify <code>control$noise = TRUE</code> and fun should be <code>fun(x, seed, ...)</code></p>
</td></tr>
<tr><td><code id="spot_+3A_lower">lower</code></td>
<td>
<p>is a vector that defines the lower boundary of search space. This determines also the dimensionality of the problem.</p>
</td></tr>
<tr><td><code id="spot_+3A_upper">upper</code></td>
<td>
<p>is a vector that defines the upper boundary of search space.</p>
</td></tr>
<tr><td><code id="spot_+3A_control">control</code></td>
<td>
<p>is a list with control settings for spot. See <code><a href="#topic+spotControl">spotControl</a></code>.</p>
</td></tr>
<tr><td><code id="spot_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code>fun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with:
</p>

<dl>
<dt><code>xbest</code></dt><dd><p>Parameters of the best found solution (matrix).</p>
</dd>
<dt><code>ybest</code></dt><dd><p>Objective function value of the best found solution (matrix).</p>
</dd>
<dt><code>x</code></dt><dd><p>Archive of all evaluation parameters (matrix).</p>
</dd>
<dt><code>y</code></dt><dd><p>Archive of the respective objective function values (matrix).</p>
</dd>
<dt><code>count</code></dt><dd><p>Number of performed objective function evaluations.</p>
</dd>
<dt><code>msg</code></dt><dd><p>Message specifying the reason of termination.</p>
</dd>
<dt><code>modelFit</code></dt><dd><p>The fit of the last build model, i.e., an object returned by the last call to the function specified by <code>control$model</code>.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Only a few examples. More examples can be found in the vignette and in
## the paper "In a Nutshell -- The Sequential Parameter Optimization Toolbox",
## see https://arxiv.org/abs/1712.04076

## 1. Most simple example: Kriging + LHS search + predicted mean optimization
## (not expected improvement)
set.seed(1)
res &lt;- spot(x=NULL,funSphere,c(-2,-3),c(1,2),
             control=list(funEvals=15))
res$xbest
res$ybest

## 2. With expected improvement
set.seed(1)
res &lt;- spot(x=NULL,funSphere,c(-2,-3),c(1,2),
            control=list(funEvals=15,
                         modelControl=list(target="ei")))
res$xbest
res$ybest

### 3. Use local optimization instead of LHS search
set.seed(1)
res &lt;- spot(,funSphere,c(-2,-3),c(1,2),
            control=list(funEvals=15,
                         modelControl=list(target="ei"),
                         optimizer=optimLBFGSB))
res$xbest
res$ybest

### 4. Use transformed input values
set.seed(1)
f2 &lt;- function(x){2^x}
lower &lt;- c(-100, -100)
upper &lt;- c(100, 100)
transformFun &lt;- rep("f2", length(lower))
res &lt;- spot(x=NULL,funSphere,lower=lower, upper=upper,
             control=list(funEvals=15,
                          modelControl=list(target="ei"),
                          optimizer=optimLBFGSB,
                          transformFun=transformFun))
res$xbest
res$ybest

</code></pre>

<hr>
<h2 id='SPOT-package'>Sequential Parameter Optimization Toolbox</h2><span id='topic+SPOT-package'></span><span id='topic+SPOT'></span>

<h3>Description</h3>

<p>Sequential Parameter Optimization Toolbox
</p>


<h3>Details</h3>

<p>SPOT uses a combination statistic models and optimization algorithms 
for the purpose of parameter optimization. Design of Experiment methods
are employed to generate an initial set of candidate solutions, which
are evaluated with a user-provided objective function.
The resulting data is used to fit a model, which in turn is subject
to an optimization algorithm, to find the most promising candidate solution(s).
These are again evaluated, after which the model is updated with the new results.
This sequential procedure of modeling, optimization, and evaluation is iterated
until the evaluation budget is exhausted.
</p>


<h3>Maintainer</h3>

<p>Thomas Bartz-Beielstein <a href="mailto:tbb@bartzundbartz.de">tbb@bartzundbartz.de</a>
</p>


<h3>Author(s)</h3>

<p>Thomas Bartz-Beielstein <a href="mailto:tbb@bartzundbartz.de">tbb@bartzundbartz.de</a>, Martin Zaefferer, and F. Rehbach
with contributions from: C. Lasarczyk, M. Rebolledo, Joerg Stork.
</p>


<h3>See Also</h3>

<p>Main interface function is <code><a href="#topic+spot">spot</a></code>.
</p>

<hr>
<h2 id='spotAlgEs'>Evolution Strategy Implementation</h2><span id='topic+spotAlgEs'></span>

<h3>Description</h3>

<p>This function is used by <code><a href="#topic+optimES">optimES</a></code> as a main loop for running
the Evolution Strategy with the given parameter set specified by SPOT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spotAlgEs(
  mue = 10,
  nu = 10,
  dimension = 2,
  mutation = 2,
  sigmaInit = 1,
  nSigma = 1,
  tau0 = 0,
  tau = 1,
  rho = "bi",
  sel = -1,
  stratReco = 1,
  objReco = 2,
  maxGen = Inf,
  maxIter = Inf,
  seed = 1,
  noise = 0,
  fName = funSphere,
  lowerLimit = -1,
  upperLimit = 1,
  verbosity = 0,
  plotResult = FALSE,
  logPlotResult = FALSE,
  sigmaRestart = 0.1,
  preScanMult = 1,
  globalOpt = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spotAlgEs_+3A_mue">mue</code></td>
<td>
<p>number of parents, default is <code>10</code></p>
</td></tr>
<tr><td><code id="spotAlgEs_+3A_nu">nu</code></td>
<td>
<p>selection pressure. That means, number of offspring (lambda) is mue multiplied with nu. Default is <code>10</code></p>
</td></tr>
<tr><td><code id="spotAlgEs_+3A_dimension">dimension</code></td>
<td>
<p>dimension number of the target function, default is <code>2</code></p>
</td></tr>
<tr><td><code id="spotAlgEs_+3A_mutation">mutation</code></td>
<td>
<p>mutation type, either <code>1</code> or <code>2</code>, default is <code>1</code></p>
</td></tr>
<tr><td><code id="spotAlgEs_+3A_sigmainit">sigmaInit</code></td>
<td>
<p>initial sigma value (step size), default is <code>1.0</code></p>
</td></tr>
<tr><td><code id="spotAlgEs_+3A_nsigma">nSigma</code></td>
<td>
<p>number of different sigmas, default is <code>1</code></p>
</td></tr>
<tr><td><code id="spotAlgEs_+3A_tau0">tau0</code></td>
<td>
<p>number, default is <code>0.0</code>. tau0 is the general multiplier.</p>
</td></tr>
<tr><td><code id="spotAlgEs_+3A_tau">tau</code></td>
<td>
<p>number, learning parameter for self adaption, default is <code>1.0</code>. tau is the local multiplier for step sizes (for each dimension).</p>
</td></tr>
<tr><td><code id="spotAlgEs_+3A_rho">rho</code></td>
<td>
<p>number of parents involved in the procreation of an offspring (mixing number), default is <code>"bi"</code></p>
</td></tr>
<tr><td><code id="spotAlgEs_+3A_sel">sel</code></td>
<td>
<p>number of selected individuals, default is <code>-1</code></p>
</td></tr>
<tr><td><code id="spotAlgEs_+3A_stratreco">stratReco</code></td>
<td>
<p>Recombination operator for strategy variables. <code>1</code>: none. <code>2</code>: dominant/discrete (default). <code>3</code>: intermediate. <code>4</code>: variation of intermediate recombination.</p>
</td></tr>
<tr><td><code id="spotAlgEs_+3A_objreco">objReco</code></td>
<td>
<p>Recombination operator for object variables. <code>1</code>: none. <code>2</code>: dominant/discrete (default). <code>3</code>: intermediate. <code>4</code>: variation of intermediate recombination.</p>
</td></tr>
<tr><td><code id="spotAlgEs_+3A_maxgen">maxGen</code></td>
<td>
<p>number of generations, stopping criterion, default is <code>Inf</code></p>
</td></tr>
<tr><td><code id="spotAlgEs_+3A_maxiter">maxIter</code></td>
<td>
<p>number of iterations (function evaluations), stopping criterion, default is <code>100</code></p>
</td></tr>
<tr><td><code id="spotAlgEs_+3A_seed">seed</code></td>
<td>
<p>number, random seed, default is <code>1</code></p>
</td></tr>
<tr><td><code id="spotAlgEs_+3A_noise">noise</code></td>
<td>
<p>number, value of noise added to fitness values, default is <code>0.0</code></p>
</td></tr>
<tr><td><code id="spotAlgEs_+3A_fname">fName</code></td>
<td>
<p>function, fitness function, default is <code><a href="#topic+funSphere">funSphere</a></code></p>
</td></tr>
<tr><td><code id="spotAlgEs_+3A_lowerlimit">lowerLimit</code></td>
<td>
<p>number, lower limit for search space, default is <code>-1.0</code></p>
</td></tr>
<tr><td><code id="spotAlgEs_+3A_upperlimit">upperLimit</code></td>
<td>
<p>number, upper limit for search space, default is <code>1.0</code></p>
</td></tr>
<tr><td><code id="spotAlgEs_+3A_verbosity">verbosity</code></td>
<td>
<p>defines output verbosity of the ES, default is <code>0</code></p>
</td></tr>
<tr><td><code id="spotAlgEs_+3A_plotresult">plotResult</code></td>
<td>
<p>boolean, asks if results are plotted, default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="spotAlgEs_+3A_logplotresult">logPlotResult</code></td>
<td>
<p>boolean, asks if plot results should be logarithmic, default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="spotAlgEs_+3A_sigmarestart">sigmaRestart</code></td>
<td>
<p>number, value of sigma on restart, default is <code>0.1</code></p>
</td></tr>
<tr><td><code id="spotAlgEs_+3A_prescanmult">preScanMult</code></td>
<td>
<p>initial population size is multiplied by this number for a pre-scan, default is <code>1</code></p>
</td></tr>
<tr><td><code id="spotAlgEs_+3A_globalopt">globalOpt</code></td>
<td>
<p>termination criterion on reaching a desired optimum value, should be a vector of length dimension (LOCATION of the optimum). Default to NULL, which means it is ignored.</p>
</td></tr>
<tr><td><code id="spotAlgEs_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed on to <code>fName</code></p>
</td></tr>
</table>

<hr>
<h2 id='spotAlgEsDominantReco'>spotAlgEsDominantReco</h2><span id='topic+spotAlgEsDominantReco'></span>

<h3>Description</h3>

<p>Recombination function for the Evolution Strategy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spotAlgEsDominantReco(parents, rhoVal, dimension, nSigma, objType = "obj")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spotAlgEsDominantReco_+3A_parents">parents</code></td>
<td>
<p>Parent individuals</p>
</td></tr>
<tr><td><code id="spotAlgEsDominantReco_+3A_rhoval">rhoVal</code></td>
<td>
<p>number of parents involved in the procreation of an offspring</p>
</td></tr>
<tr><td><code id="spotAlgEsDominantReco_+3A_dimension">dimension</code></td>
<td>
<p>number of dimensions</p>
</td></tr>
<tr><td><code id="spotAlgEsDominantReco_+3A_nsigma">nSigma</code></td>
<td>
<p>number of standard deviations</p>
</td></tr>
<tr><td><code id="spotAlgEsDominantReco_+3A_objtype">objType</code></td>
<td>
<p>string, default is &quot;obj&quot;</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+spotAlgEs">spotAlgEs</a></code> <code><a href="#topic+spotAlgEsInterRecoBeSw02">spotAlgEsInterRecoBeSw02</a></code>  <code><a href="#topic+spotAlgEsInterReco">spotAlgEsInterReco</a></code>
</p>

<hr>
<h2 id='spotAlgEsGetSuccessRate'>get Success Rate</h2><span id='topic+spotAlgEsGetSuccessRate'></span>

<h3>Description</h3>

<p>This function determines the success rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spotAlgEsGetSuccessRate(gen, pop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spotAlgEsGetSuccessRate_+3A_gen">gen</code></td>
<td>
<p>Generation number</p>
</td></tr>
<tr><td><code id="spotAlgEsGetSuccessRate_+3A_pop">pop</code></td>
<td>
<p>Population to be evaluated (only the generation <code>gen</code> will be evaluated)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number <br />
- the success rate of the given population
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spotAlgEs">spotAlgEs</a></code>
</p>

<hr>
<h2 id='spotAlgEsHps'>Termination hps</h2><span id='topic+spotAlgEsHps'></span>

<h3>Description</h3>

<p>Termination function for the ES. Terminates the ES at a given target value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spotAlgEsHps(xk, xOpt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spotAlgEsHps_+3A_xk">xk</code></td>
<td>
<p>current best value of the optimization run</p>
</td></tr>
<tr><td><code id="spotAlgEsHps_+3A_xopt">xOpt</code></td>
<td>
<p>target value of the optimization run</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>boolean</code> <br />
- TRUE as long as the current value has not yet reached its limit. Once the
given termination criterion is reached the function returns FALSE.
</p>

<hr>
<h2 id='spotAlgEsIndividualInitial'>Individual Initialization</h2><span id='topic+spotAlgEsIndividualInitial'></span>

<h3>Description</h3>

<p>Creates a new Individual for the Evolution Strategy implemented in SPOT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spotAlgEsIndividualInitial(
  s,
  dimension,
  n,
  noise = 0,
  fName,
  gen,
  low = -1,
  high = 1,
  des,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spotAlgEsIndividualInitial_+3A_s">s</code></td>
<td>
<p>sigma, step size</p>
</td></tr>
<tr><td><code id="spotAlgEsIndividualInitial_+3A_dimension">dimension</code></td>
<td>
<p>number of target function dimension</p>
</td></tr>
<tr><td><code id="spotAlgEsIndividualInitial_+3A_n">n</code></td>
<td>
<p>n, number of diff. step sizes</p>
</td></tr>
<tr><td><code id="spotAlgEsIndividualInitial_+3A_noise">noise</code></td>
<td>
<p>noise to be added to fitness value</p>
</td></tr>
<tr><td><code id="spotAlgEsIndividualInitial_+3A_fname">fName</code></td>
<td>
<p>target function</p>
</td></tr>
<tr><td><code id="spotAlgEsIndividualInitial_+3A_gen">gen</code></td>
<td>
<p>generation</p>
</td></tr>
<tr><td><code id="spotAlgEsIndividualInitial_+3A_low">low</code></td>
<td>
<p>lower limit</p>
</td></tr>
<tr><td><code id="spotAlgEsIndividualInitial_+3A_high">high</code></td>
<td>
<p>upper limit</p>
</td></tr>
<tr><td><code id="spotAlgEsIndividualInitial_+3A_des">des</code></td>
<td>
<p>des scaling for placement between low and high</p>
</td></tr>
<tr><td><code id="spotAlgEsIndividualInitial_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed on to <code>fName</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector <br />
- contains x value, sigma value, real fitness value, fitness with noise, and generation number
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spotAlgEs">spotAlgEs</a></code>
</p>

<hr>
<h2 id='spotAlgEsInitParentPop'>Initialize Parent Population</h2><span id='topic+spotAlgEsInitParentPop'></span>

<h3>Description</h3>

<p>Creates initial parent population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spotAlgEsInitParentPop(
  sigmaInit,
  dimension,
  nSigma,
  noise,
  fName,
  gen,
  low,
  high,
  mue,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spotAlgEsInitParentPop_+3A_sigmainit">sigmaInit</code></td>
<td>
<p>initial sigma value (standard deviation)</p>
</td></tr>
<tr><td><code id="spotAlgEsInitParentPop_+3A_dimension">dimension</code></td>
<td>
<p>number of target function dimension</p>
</td></tr>
<tr><td><code id="spotAlgEsInitParentPop_+3A_nsigma">nSigma</code></td>
<td>
<p>number of standard deviations</p>
</td></tr>
<tr><td><code id="spotAlgEsInitParentPop_+3A_noise">noise</code></td>
<td>
<p>noise to be added to fitness value</p>
</td></tr>
<tr><td><code id="spotAlgEsInitParentPop_+3A_fname">fName</code></td>
<td>
<p>target function</p>
</td></tr>
<tr><td><code id="spotAlgEsInitParentPop_+3A_gen">gen</code></td>
<td>
<p>generation</p>
</td></tr>
<tr><td><code id="spotAlgEsInitParentPop_+3A_low">low</code></td>
<td>
<p>lower limit</p>
</td></tr>
<tr><td><code id="spotAlgEsInitParentPop_+3A_high">high</code></td>
<td>
<p>upper limit</p>
</td></tr>
<tr><td><code id="spotAlgEsInitParentPop_+3A_mue">mue</code></td>
<td>
<p>number of parents in the ES</p>
</td></tr>
<tr><td><code id="spotAlgEsInitParentPop_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed on to <code>fName</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix <br />
- holds the parent population created by this function
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spotAlgEs">spotAlgEs</a></code> <code><a href="#topic+spotAlgEsIndividualInitial">spotAlgEsIndividualInitial</a></code>
</p>

<hr>
<h2 id='spotAlgEsInterReco'>spotAlgEsInterReco</h2><span id='topic+spotAlgEsInterReco'></span>

<h3>Description</h3>

<p>Recombination function for the Evolution Strategy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spotAlgEsInterReco(parents, rhoVal, dimension, nSigma, objType = "obj")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spotAlgEsInterReco_+3A_parents">parents</code></td>
<td>
<p>Parent individuals</p>
</td></tr>
<tr><td><code id="spotAlgEsInterReco_+3A_rhoval">rhoVal</code></td>
<td>
<p>number of parents involved in the procreation of an offspring</p>
</td></tr>
<tr><td><code id="spotAlgEsInterReco_+3A_dimension">dimension</code></td>
<td>
<p>number of dimensions</p>
</td></tr>
<tr><td><code id="spotAlgEsInterReco_+3A_nsigma">nSigma</code></td>
<td>
<p>number of standard deviations</p>
</td></tr>
<tr><td><code id="spotAlgEsInterReco_+3A_objtype">objType</code></td>
<td>
<p>string, default is &quot;obj&quot;</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+spotAlgEs">spotAlgEs</a></code> <code><a href="#topic+spotAlgEsInterRecoBeSw02">spotAlgEsInterRecoBeSw02</a></code> <code><a href="#topic+spotAlgEsDominantReco">spotAlgEsDominantReco</a></code>
</p>

<hr>
<h2 id='spotAlgEsInterRecoBeSw02'>spotAlgEsInterRecoBeSw02</h2><span id='topic+spotAlgEsInterRecoBeSw02'></span>

<h3>Description</h3>

<p>Recombination function for the Evolution Strategy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spotAlgEsInterRecoBeSw02(parents, dimension, nSigma, objType = "obj")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spotAlgEsInterRecoBeSw02_+3A_parents">parents</code></td>
<td>
<p>Parent individuals</p>
</td></tr>
<tr><td><code id="spotAlgEsInterRecoBeSw02_+3A_dimension">dimension</code></td>
<td>
<p>number of dimensions</p>
</td></tr>
<tr><td><code id="spotAlgEsInterRecoBeSw02_+3A_nsigma">nSigma</code></td>
<td>
<p>number of standard deviations</p>
</td></tr>
<tr><td><code id="spotAlgEsInterRecoBeSw02_+3A_objtype">objType</code></td>
<td>
<p>string, default is &quot;obj&quot;</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+spotAlgEs">spotAlgEs</a></code> <code><a href="#topic+spotAlgEsInterReco">spotAlgEsInterReco</a></code> <code><a href="#topic+spotAlgEsDominantReco">spotAlgEsDominantReco</a></code>
</p>

<hr>
<h2 id='spotAlgEsMarriage'>Marriage</h2><span id='topic+spotAlgEsMarriage'></span>

<h3>Description</h3>

<p>Recombination function for the Evolution Strategy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spotAlgEsMarriage(pop, rhoVal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spotAlgEsMarriage_+3A_pop">pop</code></td>
<td>
<p>Population</p>
</td></tr>
<tr><td><code id="spotAlgEsMarriage_+3A_rhoval">rhoVal</code></td>
<td>
<p>number of parents involved in the procreation of an offspring</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pop</code> <br />
- <code>pop</code> Population
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spotAlgEs">spotAlgEs</a></code> <code><a href="#topic+spotAlgEsMarriage">spotAlgEsMarriage</a></code>
</p>

<hr>
<h2 id='spotAlgEsMarriageWithReplace'>Marriage with replace</h2><span id='topic+spotAlgEsMarriageWithReplace'></span>

<h3>Description</h3>

<p>Recombination function for the Evolution Strategy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spotAlgEsMarriageWithReplace(pop, rhoVal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spotAlgEsMarriageWithReplace_+3A_pop">pop</code></td>
<td>
<p>Population</p>
</td></tr>
<tr><td><code id="spotAlgEsMarriageWithReplace_+3A_rhoval">rhoVal</code></td>
<td>
<p>number of parents involved in the procreation of an offspring</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pop</code> <br />
- <code>pop</code> Population
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spotAlgEs">spotAlgEs</a></code> <code><a href="#topic+spotAlgEsMarriageWithReplace">spotAlgEsMarriageWithReplace</a></code>
</p>

<hr>
<h2 id='spotAlgEsObjMutation'>spotAlgEsObjMutation</h2><span id='topic+spotAlgEsObjMutation'></span>

<h3>Description</h3>

<p>Mutation function for the ES individual parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spotAlgEsObjMutation(obj, strat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spotAlgEsObjMutation_+3A_obj">obj</code></td>
<td>
<p>Object to be mutated</p>
</td></tr>
<tr><td><code id="spotAlgEsObjMutation_+3A_strat">strat</code></td>
<td>
<p>Strategy parameter sigma to mutate with</p>
</td></tr>
</table>

<hr>
<h2 id='spotAlgEsSelection'>spotAlgEsSelection</h2><span id='topic+spotAlgEsSelection'></span>

<h3>Description</h3>

<p>Selection function for the ES
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spotAlgEsSelection(parentPop, offspringPop, sel, gen, iter, maxIter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spotAlgEsSelection_+3A_parentpop">parentPop</code></td>
<td>
<p>Parent population</p>
</td></tr>
<tr><td><code id="spotAlgEsSelection_+3A_offspringpop">offspringPop</code></td>
<td>
<p>Offspring population</p>
</td></tr>
<tr><td><code id="spotAlgEsSelection_+3A_sel">sel</code></td>
<td>
<p>number of individuals to be selected</p>
</td></tr>
<tr><td><code id="spotAlgEsSelection_+3A_gen">gen</code></td>
<td>
<p>generation number</p>
</td></tr>
<tr><td><code id="spotAlgEsSelection_+3A_iter">iter</code></td>
<td>
<p>current iteration number</p>
</td></tr>
<tr><td><code id="spotAlgEsSelection_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum iteration number</p>
</td></tr>
</table>

<hr>
<h2 id='spotAlgEsStratMutation'>spotAlgEsStratMutation</h2><span id='topic+spotAlgEsStratMutation'></span>

<h3>Description</h3>

<p>Mutation function for the ES strategy parameter sigma.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spotAlgEsStratMutation(strat, tau0, tau, sigmaRestart, sigmaInit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spotAlgEsStratMutation_+3A_strat">strat</code></td>
<td>
<p>Strategy parameter (sigma), can be a vector or a single number</p>
</td></tr>
<tr><td><code id="spotAlgEsStratMutation_+3A_tau0">tau0</code></td>
<td>
<p>the global/general step size multiplier for self adaption</p>
</td></tr>
<tr><td><code id="spotAlgEsStratMutation_+3A_tau">tau</code></td>
<td>
<p>the step size multiplier for self adaption in each dimension</p>
</td></tr>
<tr><td><code id="spotAlgEsStratMutation_+3A_sigmarestart">sigmaRestart</code></td>
<td>
<p>sigma values are reset to initial values when a uniformly distributed random number is smaller than sigmaRestart</p>
</td></tr>
<tr><td><code id="spotAlgEsStratMutation_+3A_sigmainit">sigmaInit</code></td>
<td>
<p>initial sigma value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number <code>s</code> <br />
- <code>s</code> is the new sigma value
</p>

<hr>
<h2 id='spotAlgEsTermination'>Termination</h2><span id='topic+spotAlgEsTermination'></span>

<h3>Description</h3>

<p>Handles the termination functions for the ES.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spotAlgEsTermination(it, maxIt, ge, maxGe, xk, xOpt = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spotAlgEsTermination_+3A_it">it</code></td>
<td>
<p>iteration (function evaluations)</p>
</td></tr>
<tr><td><code id="spotAlgEsTermination_+3A_maxit">maxIt</code></td>
<td>
<p>Maximum number of iterations (function evaluations)</p>
</td></tr>
<tr><td><code id="spotAlgEsTermination_+3A_ge">ge</code></td>
<td>
<p>generation</p>
</td></tr>
<tr><td><code id="spotAlgEsTermination_+3A_maxge">maxGe</code></td>
<td>
<p>Maximum number of generations</p>
</td></tr>
<tr><td><code id="spotAlgEsTermination_+3A_xk">xk</code></td>
<td>
<p>current best value of the optimization run</p>
</td></tr>
<tr><td><code id="spotAlgEsTermination_+3A_xopt">xOpt</code></td>
<td>
<p>target value of the optimization run</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>boolean</code> <br />
- TRUE as long as the current value has not yet reached its limit. Once the
given termination criterion is reached the function returns FALSE.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spotAlgEs">spotAlgEs</a></code> <code><a href="#topic+spotAlgEsHps">spotAlgEsHps</a></code>
</p>

<hr>
<h2 id='spotCleanup'>Clean up</h2><span id='topic+spotCleanup'></span>

<h3>Description</h3>

<p>Remove objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spotCleanup(control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spotCleanup_+3A_control">control</code></td>
<td>
<p><code>list</code> of <code>spot</code> control parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='spotControl'>spotControl</h2><span id='topic+spotControl'></span>

<h3>Description</h3>

<p>Default Control list for spot.
This function returns the default controls for the functions <code><a href="#topic+spot">spot</a></code> and <code><a href="#topic+spotLoop">spotLoop</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spotControl(dimension = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spotControl_+3A_dimension">dimension</code></td>
<td>
<p>problem dimension, that is, the number of optimized parameters. This parameter is mandatory since v2.8.4.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Control is a list of the settings:
</p>

<dl>
<dt><code>design</code></dt><dd><p>A function that creates an initial design of experiment. Functions that accept the same parameters,
and return a matrix like <code><a href="#topic+designLHD">designLHD</a></code> or <code><a href="#topic+designUniformRandom">designUniformRandom</a></code> can be used. Default is <code><a href="#topic+designLHD">designLHD</a></code>.</p>
</dd>
<dt><code>designControl</code></dt><dd><p>A list of controls passed to the <code>control</code> list of the <code>design</code> function. See help
of the respective function for details. Default is an empty <code>list</code>.</p>
</dd>
<dt><code>directOpt</code></dt><dd><p>A function that is used to optimize after the <code>spot</code> run is finished.
Functions that accept the same parameters, and return a matrix like <code><a href="#topic+optimNLOPTR">optimNLOPTR</a></code>
or <code><a href="#topic+optimDE">optimDE</a></code> can be used. Default is <code><a href="#topic+optimNLOPTR">optimNLOPTR</a></code>.</p>
</dd>
<dt><code>directOptControl</code></dt><dd><p>A list of controls, which determine whether a direct optimization
(exploitation of the final search region) is performed. Default is to run no direct optimization, i.e.,
<code>directOptControl = list(funEvals = 0)list</code>.
</p>

<dl>
<dt><code>funEvals</code></dt><dd><p>This is the budget of function evaluations of the direct optimization performed
after the SMBO is performed. Default is <code>list(funEvals = 0)</code>.</p>
</dd>
</dl>

</dd>
<dt><code>duplicate</code></dt><dd><p>In case of a deterministic (non-noisy) objective function, this handles duplicated candidate solutions.
By default (<code>duplicate = "EXPLORE"</code>), duplicates are replaced by new candidate solutions, generated by random
sampling with uniform distribution. If desired, the user can set this to &quot;STOP&quot;, which means that the optimization
stops and results are returned to the user (with a warning). This may be desirable, as duplicates can be a indicator
for convergence, or for a problem with the configuration.
In case of noise, duplicates are allowed.</p>
</dd>
<dt><code>funEvals</code></dt><dd><p>This is the budget of function evaluations (spot uses no more than funEvals evaluations of fun), defaults to 20.</p>
</dd>
<dt><code>handleNAsMethod</code></dt><dd><p>A function that treats NAs if there are any present in the result vector of the objective function.
Default: <code>NULL</code>. By default NAs will not be treated.</p>
</dd>
<dt><code>infillCriterion</code></dt><dd><p>A function defining an infillCriterion to be used while optimizing a model. Default: NULL. For example check infillExpectedImprovement</p>
</dd>
<dt><code>model</code></dt><dd><p>A function that builds a statistical model of the observed data. Functions that accept the same
parameters, and return a matrix like <code><a href="#topic+buildKriging">buildKriging</a></code> or <code><a href="#topic+buildRandomForest">buildRandomForest</a></code>
can be used. Default is <code><a href="#topic+buildKriging">buildKriging</a></code>.</p>
</dd>
<dt><code>modelControl</code></dt><dd><p>A list of controls passed to the <code>control</code> list of the <code>model</code> function.
See help of the respective function for details. Default is an empty <code>list</code>.</p>
</dd>
<dt><code>multiStart</code></dt><dd><p>Number of restarts for optimization on the surrrogate
model. Default: <code>1</code>, i.e., no restarts.</p>
</dd>
<dt><code>noise</code></dt><dd><p>Boolean, whether the objective function has noise or not. Default is non-noisy, that is, <code>FALSE</code>.</p>
</dd>
<dt><code>OCBA</code></dt><dd><p>Boolean, indicating whether Optimal Computing Budget Allocation (OCBA) should be used in case of a noisy
objective function or not. OCBA controls the number of replications for each candidate solution.
Note, that <code>replicates</code> should be larger than one in that case, and that the initial experimental design
(see <code>design</code>) should also have replicates larger one. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>OCBABudget</code></dt><dd><p>The number of objective function evaluations that OCBA can distribute in each iteration.
Default is 3.</p>
</dd>
<dt><code>optimizer</code></dt><dd><p>A function that is used to optimize based on <code>model</code>, finding the most promising
candidate solutions. Functions that accept the same parameters, and return a matrix like <code><a href="#topic+optimLHD">optimLHD</a></code>
or <code><a href="#topic+optimDE">optimDE</a></code> can be used. Default is <code><a href="#topic+optimLHD">optimLHD</a></code>.</p>
</dd>
<dt><code>optimizerControl</code></dt><dd><p>A list of controls passed to the <code>control</code> list of the <code>optimizer</code> function.
See help of the respective function for details. Default is an empty <code>list</code>.</p>
</dd>
<dt><code>parNames</code></dt><dd><p> Vector of parameter names of each variable as a string, defaults <code>c("x1", "x2", "x3",..)</code>.</p>
</dd>
<dt><code>plots</code></dt><dd><p>Whether progress should be tracked by a line plot, default is <code>FALSE</code></p>
</dd>
<dt><code>progress</code></dt><dd><p>Whether progress should be visualized, default is <code>FALSE</code></p>
</dd>
<dt><code>replicates</code></dt><dd><p>The number of times a candidate solution is initially evaluated, that is, in the initial design,
or when created by the optimizer. Default is <code>1</code>.</p>
</dd>
<dt><code>replicateResult</code></dt><dd><p><code>logical</code>. If <code>TRUE</code>, one result is
replicated. The result is specified as  the <code>lower</code> vector and
re-evaluated <code>funEvals</code> times. No model building and
optimization is performed, only evaluations on the
objective function. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>returnFullControlList</code></dt><dd><p><code>logical</code>. Return the full control
list. Can be switched off to save memory/space. Default: <code>TRUE</code>.</p>
</dd>
<dt><code>seedFun</code></dt><dd><p>An initial seed for the objective function in case of noise, by default <code>NA</code>. The default means that no seed is set.
The user should be very careful with this setting. It is intended to generate reproducible experiments for each objective
function evaluation, e.g., when tuning non-deterministic algorithms. If the objective function uses a constant number
of random number generations, this may be undesirable. Note, that this seed is by default set prior to each evaluation. A replicated
evaluation will receive an incremented value of the seed.
Sometimes, the user may want to call external code using random numbers. To allow for that case, the user can specify an objective function (<code>fun</code>),
which has a second parameter <code>seed</code>, in addition to first parameter (matrix <code>x</code>). This seed can then be passed
to the external code, for random number generator initialization. See end of examples section for a demonstration.</p>
</dd>
<dt><code>seedSPOT</code></dt><dd><p>This value is used to initialize the random number generator. It ensures that experiments are reproducible. Default is <code>1</code>.</p>
</dd>
<dt><code>subsetSelect</code></dt><dd><p>A function that selects a subset from a given set of design points. Default is <code><a href="#topic+selectAll">selectAll</a></code>.</p>
</dd>
<dt><code>subsetControl</code></dt><dd><p>A list of controls passed to the <code>control</code> list of the <code>subsetSelect</code> function. See help
of the respective function for details. Default is an empty <code>list</code>.</p>
</dd>
<dt><code>time</code></dt><dd><p>List with the following time information:
</p>

<dl>
<dt><code>maxTime</code></dt><dd><p><code>num</code> Maximum allowed run time (in minutes) for <code>spot</code> or <code>spotLoop</code>.
The default value for <code>maxTime</code> (in minutes) is <code>Inf</code> and can be overwritten by the user.
The internal value <code>startTime</code>, that is used to control <code>maxTime</code>,
will be set by <code><a href="#topic+spotFillControlList">spotFillControlList</a></code>.
Note: <code>maxTime</code>  is only an approximate value. It does not affect the <code>directOpt</code> run.</p>
</dd>
<dt><code>startTime</code></dt><dd><p>Start time. Will be set in <code><a href="#topic+spotFillControlList">spotFillControlList</a></code>.</p>
</dd>
<dt><code>endTime</code></dt><dd><p>End time.</p>
</dd>
</dl>

</dd>
<dt><code>types</code></dt><dd><p> Vector of data type of each variable as a string, defaults <code>"numeric"</code> for all variables.</p>
</dd>
<dt><code>verbosity</code></dt><dd><p>Integer level specifying how much output should be given by SPOT. 0 (default) ignores warnings of internal optimizers /models.
1 will show warnings and output.</p>
</dd>
</dl>



<h3>Value</h3>

<p>a list
</p>

<hr>
<h2 id='spotFillControlList'>spotFillControlList</h2><span id='topic+spotFillControlList'></span>

<h3>Description</h3>

<p>Fill in some values for the control list. Internal use only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spotFillControlList(controlList, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spotFillControlList_+3A_controllist">controlList</code></td>
<td>
<p>list of controls, see <code><a href="#topic+spotControl">spotControl</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>

<hr>
<h2 id='spotHelpBslash'>Backslash operator.</h2><span id='topic+spotHelpBslash'></span>

<h3>Description</h3>

<p>Reproduce what MATLAB's backslash operator can do, using qr() and qr.coef().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spotHelpBslash(X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spotHelpBslash_+3A_x">X</code></td>
<td>
<p>X matrix</p>
</td></tr>
<tr><td><code id="spotHelpBslash_+3A_y">Y</code></td>
<td>
<p>Y vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns coefficients
</p>

<hr>
<h2 id='spotLoop'>Sequential Parameter Optimization Main Loop</h2><span id='topic+spotLoop'></span>

<h3>Description</h3>

<p>SPOT is usually started via the function <code><a href="#topic+spot">spot</a></code>. However, SPOT runs can be continued
(i.e., with a larger budget specified in <code>control$funEvals</code>) by using <code>spotLoop</code>.
This is the main loop of SPOT iterations. It requires the user to give the same inputs as
specified for <code><a href="#topic+spot">spot</a></code>. Note: <code>control$funEvals</code> must be larger than the value
used in the previous run, because it specifies the total number of function evaluations and
not the additional number of evalutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spotLoop(x, y, fun, lower, upper, control, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spotLoop_+3A_x">x</code></td>
<td>
<p><code>(m,n) matrix</code> that contains the known candidate solutions.
The SPOT loop is started with these values. Each row represents one <code>n</code> dimensional
data point. Each of the <code>m</code> columns represents one optimized parameter.</p>
</td></tr>
<tr><td><code id="spotLoop_+3A_y">y</code></td>
<td>
<p><code>(m,p) matrix</code> that represents observations for each point in <code>x</code>,
Each of the <code>m</code> rows represents solutions for one data point.</p>
</td></tr>
<tr><td><code id="spotLoop_+3A_fun">fun</code></td>
<td>
<p><code>function</code> that represents the objective function.
It should receive a matrix <code>x</code> and return a matrix <code>y</code>.
In case the function uses external code and is noisy, an additional seed parameter may be used,
see the <code>control$seedFun</code> argument below for details.</p>
</td></tr>
<tr><td><code id="spotLoop_+3A_lower">lower</code></td>
<td>
<p>is a vector that defines the lower boundary of search space.
This determines also the dimension of the problem.</p>
</td></tr>
<tr><td><code id="spotLoop_+3A_upper">upper</code></td>
<td>
<p>is a vector that defines the upper boundary of search space.</p>
</td></tr>
<tr><td><code id="spotLoop_+3A_control">control</code></td>
<td>
<p>is a list with control settings for spot. See <code><a href="#topic+spotControl">spotControl</a></code>.</p>
</td></tr>
<tr><td><code id="spotLoop_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code>fun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with:
</p>

<dl>
<dt>xbest</dt><dd><p>Parameters of the best found solution (matrix).</p>
</dd>
<dt><code>ybest</code></dt><dd><p>Objective function value of the best found solution (matrix).</p>
</dd>
<dt><code>x</code></dt><dd><p>Archive of all evaluation parameters (matrix).</p>
</dd>
<dt><code>y</code></dt><dd><p>Archive of the respective objective function values (matrix).</p>
</dd>
<dt><code>count</code></dt><dd><p>Number of performed objective function evaluations.</p>
</dd>
<dt><code>msg</code></dt><dd><p>Message specifying the reason of termination.</p>
</dd>
<dt><code>modelFit</code></dt><dd><p>The fit of the last build model, i.e.,
an object returned by the last call to the function specified by <code>control$model</code>.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Most simple example: Kriging + LHS + predicted
## mean optimization (not expected improvement)

control &lt;- list(funEvals=20)
res &lt;- spot(,funSphere,c(-2,-3),c(1,2),control)
## now continue with larger budget.
## 5 additional runs will be performed.
control$funEvals &lt;- 25
res2 &lt;- spotLoop(res$x,res$y,funSphere,c(-2,-3),c(1,2),control)
res2$xbest
res2$ybest

</code></pre>

<hr>
<h2 id='spotPlotErrors'>spotPlotErrors</h2><span id='topic+spotPlotErrors'></span>

<h3>Description</h3>

<p>Visualize the alpha, beta errors and the power of the test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spotPlotErrors(
  alternative = "greater",
  lower = -3,
  upper = 3,
  mu0 = 0,
  mu1 = 1,
  sigma = 1,
  n = NULL,
  xbar = 0,
  alpha = 0.05,
  beta = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spotPlotErrors_+3A_alternative">alternative</code></td>
<td>
<p>One of greater, less, or two.sided. The greater is the default.</p>
</td></tr>
<tr><td><code id="spotPlotErrors_+3A_lower">lower</code></td>
<td>
<p>lower limit of the plot</p>
</td></tr>
<tr><td><code id="spotPlotErrors_+3A_upper">upper</code></td>
<td>
<p>upper limit of the plot</p>
</td></tr>
<tr><td><code id="spotPlotErrors_+3A_mu0">mu0</code></td>
<td>
<p>mean of the null</p>
</td></tr>
<tr><td><code id="spotPlotErrors_+3A_mu1">mu1</code></td>
<td>
<p>mean of the alternative. See also parameter <code>beta</code>.</p>
</td></tr>
<tr><td><code id="spotPlotErrors_+3A_sigma">sigma</code></td>
<td>
<p>standard deviation</p>
</td></tr>
<tr><td><code id="spotPlotErrors_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="spotPlotErrors_+3A_xbar">xbar</code></td>
<td>
<p>observed mean</p>
</td></tr>
<tr><td><code id="spotPlotErrors_+3A_alpha">alpha</code></td>
<td>
<p>error of the first kind</p>
</td></tr>
<tr><td><code id="spotPlotErrors_+3A_beta">beta</code></td>
<td>
<p>error 2nd kind. Default <code>NULL</code>. If specified, then parameter 
<code>mu1</code> will be ignored and <code>mu1</code> will be calculated based on
<code>beta</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>description of return value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spotPlotErrors(lower=490,upper=510,mu0=500,mu1=504,sigma=2.7,n=9,xbar=502.22)
spotPlotErrors(lower=140,upper=155,mu0=150,mu1=148,sigma=10,n=100,xbar=149,alternative="less")
</code></pre>

<hr>
<h2 id='spotPlotPower'>spotPlotPower</h2><span id='topic+spotPlotPower'></span>

<h3>Description</h3>

<p>Plot power
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spotPlotPower(y0, y1, alpha = 0.05, add = FALSE, n = NA, rightLimit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spotPlotPower_+3A_y0">y0</code></td>
<td>
<p>First input vector</p>
</td></tr>
<tr><td><code id="spotPlotPower_+3A_y1">y1</code></td>
<td>
<p>Second input vector</p>
</td></tr>
<tr><td><code id="spotPlotPower_+3A_alpha">alpha</code></td>
<td>
<p>description of alpha, default value is <code>0.05</code></p>
</td></tr>
<tr><td><code id="spotPlotPower_+3A_add">add</code></td>
<td>
<p>Boolean, default value is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="spotPlotPower_+3A_n">n</code></td>
<td>
<p>number of vector elements that should be evaluated, default value is <code>NA</code>, which means the whole vector</p>
</td></tr>
<tr><td><code id="spotPlotPower_+3A_rightlimit">rightLimit</code></td>
<td>
<p>description of rightLimit, default value is <code>1</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>description of return value
</p>

<hr>
<h2 id='spotPlotSeverityBasic'>spotPlotSeverityBasic</h2><span id='topic+spotPlotSeverityBasic'></span>

<h3>Description</h3>

<p>spotPlotSeverityBasic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spotPlotSeverityBasic(y0, y1, add = FALSE, n = NA, alpha, rightLimit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spotPlotSeverityBasic_+3A_y0">y0</code></td>
<td>
<p>first input vector</p>
</td></tr>
<tr><td><code id="spotPlotSeverityBasic_+3A_y1">y1</code></td>
<td>
<p>second input vector</p>
</td></tr>
<tr><td><code id="spotPlotSeverityBasic_+3A_add">add</code></td>
<td>
<p>default value is FALSE</p>
</td></tr>
<tr><td><code id="spotPlotSeverityBasic_+3A_n">n</code></td>
<td>
<p>default value is NA, which means length of y0 will be used for n</p>
</td></tr>
<tr><td><code id="spotPlotSeverityBasic_+3A_alpha">alpha</code></td>
<td>
<p>description</p>
</td></tr>
<tr><td><code id="spotPlotSeverityBasic_+3A_rightlimit">rightLimit</code></td>
<td>
<p>description of rightLimit, default value is <code>1</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>description of return value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example from D G Mayo and A Spanos. 
### Severe Testing as a Basic Concept in a Neyman–Pearson Philosophy of Induction. 
### British Journal for the Philosophy of Science, 57:323–357, 2006. (fig 2):
x0 &lt;- 12.1
mu1 &lt;- seq(11.9,13,0.01)
n &lt;- 100
sigma &lt;- 2
alpha &lt;- 0.025
plot(mu1, spotSeverityBasic(x0, mu1, n, sigma, alpha), type = "l", ylim=c(0,1), col="blue")
abline(h=0)
abline(h=1)
 abline(h=0.95)
abline(v=12.43)
### plot power:
mu0 &lt;- 12
points(mu1, spotPower(alpha, mu0, mu1, n, sigma), type = "l", ylim=c(0,1), col="green")
abline(v=12.72)

</code></pre>

<hr>
<h2 id='spotPlotTest'>spotPlotTest</h2><span id='topic+spotPlotTest'></span>

<h3>Description</h3>

<p>Visualize test result, errors, and severity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spotPlotTest(
  alternative = "greater",
  lower = -3,
  upper = 3,
  mu0 = 0,
  mu1 = 1,
  sigma = 1,
  n = NULL,
  xbar = 0,
  alpha = 0.05,
  beta = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spotPlotTest_+3A_alternative">alternative</code></td>
<td>
<p>One of greater, less, or two.sided. Full plots are currently
implemented for less, which is the default.</p>
</td></tr>
<tr><td><code id="spotPlotTest_+3A_lower">lower</code></td>
<td>
<p>lower limit of the plot</p>
</td></tr>
<tr><td><code id="spotPlotTest_+3A_upper">upper</code></td>
<td>
<p>upper limit of the plot</p>
</td></tr>
<tr><td><code id="spotPlotTest_+3A_mu0">mu0</code></td>
<td>
<p>mean of the null</p>
</td></tr>
<tr><td><code id="spotPlotTest_+3A_mu1">mu1</code></td>
<td>
<p>mean of the alternative. See also parameter <code>beta</code>.</p>
</td></tr>
<tr><td><code id="spotPlotTest_+3A_sigma">sigma</code></td>
<td>
<p>standard deviation</p>
</td></tr>
<tr><td><code id="spotPlotTest_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="spotPlotTest_+3A_xbar">xbar</code></td>
<td>
<p>observed mean</p>
</td></tr>
<tr><td><code id="spotPlotTest_+3A_alpha">alpha</code></td>
<td>
<p>error of the first kind</p>
</td></tr>
<tr><td><code id="spotPlotTest_+3A_beta">beta</code></td>
<td>
<p>error 2nd kind. Default <code>NULL</code>. If specified, then parameter 
<code>mu1</code> will be ignored and <code>mu1</code> will be calculated based on
<code>beta</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>description of return value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spotPlotTest(lower=490, upper=510, mu0=500, mu1=504, sigma=2.7, n=9, xbar=502.22, alpha=0.025)
## The following two plots should be nearly identical:
spotPlotTest(lower=490, upper=510, mu0=500, sigma=2.7, n=9, xbar=502.22, alpha=0.025, beta=0.2)
spotPlotTest(lower=490, upper=510, mu0=500, mu1=502.5215, sigma=2.7, n=9, xbar=502.22, alpha=0.025)
</code></pre>

<hr>
<h2 id='spotPower'>spotPower</h2><span id='topic+spotPower'></span>

<h3>Description</h3>

<p>Calculate power
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spotPower(alpha, mu0, mu1, n, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spotPower_+3A_alpha">alpha</code></td>
<td>
<p>description of alpha</p>
</td></tr>
<tr><td><code id="spotPower_+3A_mu0">mu0</code></td>
<td>
<p>description of mu0</p>
</td></tr>
<tr><td><code id="spotPower_+3A_mu1">mu1</code></td>
<td>
<p>description of mu1</p>
</td></tr>
<tr><td><code id="spotPower_+3A_n">n</code></td>
<td>
<p>vector length</p>
</td></tr>
<tr><td><code id="spotPower_+3A_sigma">sigma</code></td>
<td>
<p>standart deviation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>description of return value
</p>

<hr>
<h2 id='spotSeverity'>spotSeverity</h2><span id='topic+spotSeverity'></span>

<h3>Description</h3>

<p>spotSeverity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spotSeverity(xbar, mu0, mu1, n, sigma, alpha, tdist = FALSE, paired = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spotSeverity_+3A_xbar">xbar</code></td>
<td>
<p>sample mean value</p>
</td></tr>
<tr><td><code id="spotSeverity_+3A_mu0">mu0</code></td>
<td>
<p>mean value of the null hypothesis (usually referred to as H0)</p>
</td></tr>
<tr><td><code id="spotSeverity_+3A_mu1">mu1</code></td>
<td>
<p>mean value of the alternative hypothesis (usually referred to as H1)</p>
</td></tr>
<tr><td><code id="spotSeverity_+3A_n">n</code></td>
<td>
<p>sample size in each arm, e.g., if 20 samples are available, then <code>n=10</code> 
regardless whether the samples are paired/blocked (<code>paired=TRUE</code>) or independent
(<code>paired=FALSE</code>). Degrees of freedom will be modified internally
according to the setting of the <code>paired</code> argument.</p>
</td></tr>
<tr><td><code id="spotSeverity_+3A_sigma">sigma</code></td>
<td>
<p>sample s.d. Will be used to determine s.d. of the differences (if 
<code>paired==TRUE</code>) or s.d. of the pooled s.d (if <code>paired==FALSE</code>).</p>
</td></tr>
<tr><td><code id="spotSeverity_+3A_alpha">alpha</code></td>
<td>
<p>probability of a type I error, given H0 is true</p>
</td></tr>
<tr><td><code id="spotSeverity_+3A_tdist">tdist</code></td>
<td>
<p>logical. Use Student t Distribution. Default: FALSE</p>
</td></tr>
<tr><td><code id="spotSeverity_+3A_paired">paired</code></td>
<td>
<p>logical. Paired (blocked) data. Default: TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"spotSeverity"</code>,
with a <code>summary</code> method and a <code>print</code> method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
s0 &lt;- spotSeverity(xbar=0.4, mu0=0.0, mu1=0.6, n=25, sigma=1, alpha=0.03)
print(s0)
s1 &lt;- spotSeverity(xbar=0.4, mu0=0.6, mu1=0.6, n=25, sigma=1, alpha=0.03)
print(s1)
s2 &lt;- spotSeverity(xbar=0, mu0=0.6, mu1=0.6, n=25, sigma=1, alpha=0.03)
print(s2)

## Example from Mayo, p345
spotSeverity(xbar=90, mu0=0, mu1= 200, n=200, sigma = 450, alpha = 0.025, 
paired = FALSE, tdist = FALSE)

## Example from Vena02a to compare with results from t.test()
## library("BHH2")
## data(shoes.data)
## A &lt;- shoes.data$matA
## B &lt;- shoes.data$matB
 A &lt;- c(13.2, 8.2, 10.9, 14.3, 10.7, 6.6, 9.5, 10.8, 8.8, 13.3)
 B &lt;- c(14, 8.8, 11.2, 14.2, 11.8, 6.4, 9.8, 11.3, 9.3, 13.6)
t.paired &lt;- t.test(x = A, y = B, var.equal = TRUE, paired = TRUE, 
alternative = "greater",  conf.level = 0.95)
xbar &lt;- mean(A-B)
n &lt;- length(A)
sigma &lt;- sd(A-B) 
s.paired &lt;- spotSeverity(xbar=xbar,mu0=0, mu1= 1, n=n, sigma = sigma, 
alpha = 0.025, tdist = TRUE)

</code></pre>

<hr>
<h2 id='spotSeverityBasic'>spotSeverityBasic</h2><span id='topic+spotSeverityBasic'></span>

<h3>Description</h3>

<p>spotSeverityBasic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spotSeverityBasic(x0, mu1, n, sigma, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spotSeverityBasic_+3A_x0">x0</code></td>
<td>
<p>sample mean value</p>
</td></tr>
<tr><td><code id="spotSeverityBasic_+3A_mu1">mu1</code></td>
<td>
<p>description</p>
</td></tr>
<tr><td><code id="spotSeverityBasic_+3A_n">n</code></td>
<td>
<p>description</p>
</td></tr>
<tr><td><code id="spotSeverityBasic_+3A_sigma">sigma</code></td>
<td>
<p>description</p>
</td></tr>
<tr><td><code id="spotSeverityBasic_+3A_alpha">alpha</code></td>
<td>
<p>description</p>
</td></tr>
</table>


<h3>Value</h3>

<p>description of return value
</p>

<hr>
<h2 id='sring'>sring</h2><span id='topic+sring'></span>

<h3>Description</h3>

<p>simple elevator simulator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sring(x, opt = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sring_+3A_x">x</code></td>
<td>
<p>perceptron weights</p>
</td></tr>
<tr><td><code id="sring_+3A_opt">opt</code></td>
<td>
<p>list of optional parameters, e.g., 
</p>

<dl>
<dt><code>nElevators</code></dt><dd><p>number of elevators</p>
</dd>
<dt><code>probNewCustomer</code></dt><dd><p>probability pf a customer arrival</p>
</dd>
<dt><code>nIterations</code></dt><dd><p>Number of itertions</p>
</dd>
<dt><code>randomSeed</code></dt><dd><p>random seed</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="sring_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fitness
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
nStates = 6
nElevators = 2
sigma = 1
x = matrix( rnorm(n = 2*nStates, 1, sigma), 1,)
sring(x, opt = list(nElevators=nElevators,
                   nStates= nStates) )

</code></pre>

<hr>
<h2 id='sringRes1'>S-Ring Simulation Data</h2><span id='topic+sringRes1'></span>

<h3>Description</h3>

<p>A data set based on evaluations of the <code>funCosts</code> function.
The corresponding code can be found in the vignette SPOTVignetteElevator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sringRes1
</code></pre>


<h3>Format</h3>

<p>A data frame with 20 obs. of  3 variables:
</p>

<dl>
<dt>y</dt><dd><p>num  10 10 10 10 10 ...</p>
</dd>
<dt>sigma</dt><dd><p>num  0.1 0.1 0.1 0.1 0.1 1 1 1 1 1 ..</p>
</dd>
<dt>ne</dt><dd><p>num  5 5 5 5 5 5 5 5 5 5 ...</p>
</dd>
</dl>


<hr>
<h2 id='sringRes2'>S-Ring Simulation Data</h2><span id='topic+sringRes2'></span>

<h3>Description</h3>

<p>A data set based on evaluations of the <code>funCosts</code> function.
Second experiment (extension of the first design)
The corresponding code can be found in the vignette SPOTVignetteElevator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sringRes2
</code></pre>


<h3>Format</h3>

<p>A data frame with 22 obs. of  3 variables:
</p>

<dl>
<dt>y</dt><dd><p>num  10 10 10 10 10 ...</p>
</dd>
<dt>sigma</dt><dd><p>num  0.1 0.1 0.1 0.1 0.1 1 1 1 1 1 ..</p>
</dd>
<dt>ne</dt><dd><p>num  5 5 5 5 5 5 5 5 5 5 ...</p>
</dd>
</dl>


<hr>
<h2 id='sringRes3'>S-Ring Simulation Data</h2><span id='topic+sringRes3'></span>

<h3>Description</h3>

<p>A data set based on evaluations of the <code>funCosts</code> function.
Second experiment (extension of the first design)
The corresponding code can be found in the vignette SPOTVignetteElevator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sringRes3
</code></pre>


<h3>Format</h3>

<p>A data frame with 27 obs. of  3 variables:
</p>

<dl>
<dt>y</dt><dd><p>num  1e+07 1e+07 1e+07 1e+07 1e+07 ...</p>
</dd>
<dt>sigma</dt><dd><p>num  0.1 0.1 0.1 0.1 0.1 1 1 1 1 1 ...</p>
</dd>
<dt>ne</dt><dd><p>num  5 5 5 5 5 5 5 5 5 5 ...</p>
</dd>
</dl>


<hr>
<h2 id='thetaNugget'>thetaNugget</h2><span id='topic+thetaNugget'></span>

<h3>Description</h3>

<p>get theta (distance, lengthscale)
and nugget (noise) parameters gradient
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thetaNugget(par, X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thetaNugget_+3A_par">par</code></td>
<td>
<p>parameter vector. First dim(x) entries are theta values, 
last entry is nugget parameter.</p>
</td></tr>
<tr><td><code id="thetaNugget_+3A_x">X</code></td>
<td>
<p>x coordinates</p>
</td></tr>
<tr><td><code id="thetaNugget_+3A_y">Y</code></td>
<td>
<p>y values at x</p>
</td></tr>
</table>


<h3>Value</h3>

<p>negLogLikelihood
</p>

<hr>
<h2 id='thetaNuggetGradient'>thetaNuggetGradient</h2><span id='topic+thetaNuggetGradient'></span>

<h3>Description</h3>

<p>get theta (distance, lengthscale)
and nugget (noise) parameters gradient
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thetaNuggetGradient(par, X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thetaNuggetGradient_+3A_par">par</code></td>
<td>
<p>parameter vector. First dim(x) entries are theta values, last entry is nugget parameter.</p>
</td></tr>
<tr><td><code id="thetaNuggetGradient_+3A_x">X</code></td>
<td>
<p>x coordinates</p>
</td></tr>
<tr><td><code id="thetaNuggetGradient_+3A_y">Y</code></td>
<td>
<p>y values at x</p>
</td></tr>
</table>

<hr>
<h2 id='transformX'>Transform input</h2><span id='topic+transformX'></span>

<h3>Description</h3>

<p>Transform input variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformX(xNat = NA, fn = vector())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformX_+3A_xnat">xNat</code></td>
<td>
<p><code>matrix</code> with natural variables. Default: <code>NA</code>.</p>
</td></tr>
<tr><td><code id="transformX_+3A_fn">fn</code></td>
<td>
<p>vector of transformation functions names (<code>char</code>). Default: Empty
vector (<code>vector()</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> of transformed parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f2 &lt;- function(x){2^x}
fn &lt;- c("identity", "exp", "f2")
xNat &lt;- diag(3)
transformX(xNat, fn)

fn &lt;- append(fn, c("sin", "cos", "tan"))
xNat &lt;- cbind(xNat, xNat)
transformX(xNat, fn)
</code></pre>

<hr>
<h2 id='updateSeedFromXnew'>update seed</h2><span id='topic+updateSeedFromXnew'></span>

<h3>Description</h3>

<p>update seed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateSeedFromXnew(x, xnew, seed, seedFun, verbosity = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateSeedFromXnew_+3A_x">x</code></td>
<td>
<p>matrix of already known solutions,
to determine whether RNG seeds for new solutions need to be incremented.</p>
</td></tr>
<tr><td><code id="updateSeedFromXnew_+3A_xnew">xnew</code></td>
<td>
<p>matrix of new solutions.</p>
</td></tr>
<tr><td><code id="updateSeedFromXnew_+3A_seed">seed</code></td>
<td>
<p>seed</p>
</td></tr>
<tr><td><code id="updateSeedFromXnew_+3A_seedfun">seedFun</code></td>
<td>
<p>initial seed to be used for the random number generator seed.
Set to NA to avoid using a fixed seed.</p>
</td></tr>
<tr><td><code id="updateSeedFromXnew_+3A_verbosity">verbosity</code></td>
<td>
<p>verbosity. Default: 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the updated seed
</p>

<hr>
<h2 id='vmessage'>formatted output dependent on verbosity</h2><span id='topic+vmessage'></span>

<h3>Description</h3>

<p>Combine <code><a href="base.html#topic+sprintf">sprintf</a></code> and <code><a href="base.html#topic+writeLines">writeLines</a></code> to
generate formatted output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vmessage(verbosity, text, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vmessage_+3A_verbosity">verbosity</code></td>
<td>
<p>verbosity level</p>
</td></tr>
<tr><td><code id="vmessage_+3A_text">text</code></td>
<td>
<p>output to be printed</p>
</td></tr>
<tr><td><code id="vmessage_+3A_value">value</code></td>
<td>
<p>value to be printed</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- 123
vmessage(1, "value of x:" , x)

</code></pre>

<hr>
<h2 id='wrapBatchTools'>wrapBatchTools</h2><span id='topic+wrapBatchTools'></span>

<h3>Description</h3>

<p>Wrap a given objective function to be evaluated via the batchtools package and make it accessible
for SPOT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrapBatchTools(
  fun,
  reg = NULL,
  clusterFunction = batchtools::makeClusterFunctionsInteractive(),
  resources = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrapBatchTools_+3A_fun">fun</code></td>
<td>
<p>function to wrap</p>
</td></tr>
<tr><td><code id="wrapBatchTools_+3A_reg">reg</code></td>
<td>
<p>batchtools registry, if none is provided, then one will be created automatically</p>
</td></tr>
<tr><td><code id="wrapBatchTools_+3A_clusterfunction">clusterFunction</code></td>
<td>
<p>batchtools clusterFunction, default: makeClusterFunctionsInteractive()</p>
</td></tr>
<tr><td><code id="wrapBatchTools_+3A_resources">resources</code></td>
<td>
<p>resource list that is passed to batchtools, default NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>callable function for SPOT
</p>

<hr>
<h2 id='wrapFunction'>Function Evaluation Wrapper</h2><span id='topic+wrapFunction'></span>

<h3>Description</h3>

<p>This is a simple wrapper that turns a function of type <code>y=f(x)</code>, where x is a vector and y is a scalar,
into a function that accepts and returns matrices, as required by <code><a href="#topic+spot">spot</a></code>.
Note that the wrapper essentially makes use of the apply function. This is effective, but not necessarily
efficient. The wrapper is intended to make the use of spot easier, but it could be faster
if the user spends some time on a more efficient vectorization of the target function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrapFunction(fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrapFunction_+3A_fun">fun</code></td>
<td>
<p>the function <code>y=f(x)</code> to be wrapped, with x a vector and y a numeric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function in the style of <code>y=f(x)</code>, accepting and returning a matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example function
branin &lt;- function (x) {  
  y &lt;- (x[2]  - 5.1/(4 * pi^2) * (x[1] ^2) + 5/pi * x[1]  - 6)^2 + 
    10 * (1 - 1/(8 * pi)) * cos(x[1] ) + 10
  y  
}
## vectorize / wrap
braninWrapped &lt;-wrapFunction(branin)
## test original
branin(c(1,2))
branin(c(2,2))
branin(c(2,1))
## test wrapped
braninWrapped(matrix(c(1,2,2,2,2,1),3,2,byrow=TRUE))

</code></pre>

<hr>
<h2 id='wrapFunctionParallel'>Parallelized Function Evaluation Wrapper</h2><span id='topic+wrapFunctionParallel'></span>

<h3>Description</h3>

<p>This is a simple wrapper that turns a function of type <code>y=f(x)</code>, where x is a vector and y is a scalar,
into a function that accepts and returns matrices, as required by <code><a href="#topic+spot">spot</a></code>.
While doing so, the wrapper will use the parallel package in order to parallelize the execution of each function
evaluation. This function will create a computation cluster if no cluster is specified and there is no
default cluster setup!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrapFunctionParallel(fun, cl = NULL, nCores = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrapFunctionParallel_+3A_fun">fun</code></td>
<td>
<p>the function that shall be evaluated in parallel</p>
</td></tr>
<tr><td><code id="wrapFunctionParallel_+3A_cl">cl</code></td>
<td>
<p>Optional, an existing computation cluster</p>
</td></tr>
<tr><td><code id="wrapFunctionParallel_+3A_ncores">nCores</code></td>
<td>
<p>Optional, amount of cores to use for creating a new computation cluster. Default is all cores.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector, result of the parallelized evaluation
</p>

<hr>
<h2 id='wrapSystem_parseMatrixToString'>wrapSystem_parseMatrixToString</h2><span id='topic+wrapSystem_parseMatrixToString'></span>

<h3>Description</h3>

<p>Create a String that can be passed via the command line from an R-Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrapSystem_parseMatrixToString(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrapSystem_parseMatrixToString_+3A_m">m</code></td>
<td>
<p>a matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>parsed string
</p>

<hr>
<h2 id='wrapSystemCommand'>wrapSystemCommand</h2><span id='topic+wrapSystemCommand'></span>

<h3>Description</h3>

<p>Optimize parameters for a script that is accessible via Command Line
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrapSystemCommand(systemCall)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrapSystemCommand_+3A_systemcall">systemCall</code></td>
<td>
<p>String that calls the command line script.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>callable function for SPOT
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# exampleScriptLocation &lt;- system.file("consoleCallTrialScript.R",package = "SPOT")
# f &lt;- wrapSystemCommand(paste("$(R_HOME)/bin/Rscript", exampleScriptLocation))
# spot(,f,c(1,1),c(100,100))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
