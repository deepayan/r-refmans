<!DOCTYPE html><html><head><title>Help for package sfheaders</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sfheaders}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sf_bbox'><p>sf bbox</p></a></li>
<li><a href='#sf_boxes'><p>sf boxes</p></a></li>
<li><a href='#sf_cast'><p>sf cast</p></a></li>
<li><a href='#sf_line'><p>Helper for sf LINESTRING</p></a></li>
<li><a href='#sf_linestring'><p>sf LINESTRING</p></a></li>
<li><a href='#sf_mline'><p>Helper for sf MULTILINESTRING</p></a></li>
<li><a href='#sf_mpoly'><p>Helper for sf MULTIPOLYGON</p></a></li>
<li><a href='#sf_mpt'><p>Helper for sf MULTIPOINT</p></a></li>
<li><a href='#sf_multilinestring'><p>sf MULTILINESTRING</p></a></li>
<li><a href='#sf_multipoint'><p>sf MULTIPOINT</p></a></li>
<li><a href='#sf_multipolygon'><p>sf MULTIPOLYGON</p></a></li>
<li><a href='#sf_point'><p>sf POINT</p></a></li>
<li><a href='#sf_poly'><p>Helper for sf POLYGON</p></a></li>
<li><a href='#sf_polygon'><p>sf POLYGON</p></a></li>
<li><a href='#sf_pt'><p>Helper for sf POINT</p></a></li>
<li><a href='#sf_remove_holes'><p>remove holes</p></a></li>
<li><a href='#sf_to_df'><p>sf to df</p></a></li>
<li><a href='#sfc_cast'><p>sfc cast</p></a></li>
<li><a href='#sfc_linestring'><p>sfc LINESTRING</p></a></li>
<li><a href='#sfc_multilinestring'><p>sfc MULTILINESTRING</p></a></li>
<li><a href='#sfc_multipoint'><p>sfc MULTIPOINT</p></a></li>
<li><a href='#sfc_multipolygon'><p>sfc MULTIPOLYGON</p></a></li>
<li><a href='#sfc_point'><p>sfc POINT</p></a></li>
<li><a href='#sfc_polygon'><p>sfc POLYGON</p></a></li>
<li><a href='#sfc_to_df'><p>sfc to df</p></a></li>
<li><a href='#sfg_linestring'><p>sfg linestring</p></a></li>
<li><a href='#sfg_multilinestring'><p>sfg multilinestring</p></a></li>
<li><a href='#sfg_multipoint'><p>sfg multipoint</p></a></li>
<li><a href='#sfg_multipolygon'><p>sfg multipolygon</p></a></li>
<li><a href='#sfg_point'><p>sfg point</p></a></li>
<li><a href='#sfg_polygon'><p>sfg polygon</p></a></li>
<li><a href='#sfg_to_df'><p>sfg to df</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Converts Between R Objects and Simple Feature Objects</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-18</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Converts between R and Simple Feature 'sf' objects, without depending
  on the Simple Feature library. Conversion functions are available at both the R level, 
  and through 'Rcpp'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://dcooley.github.io/sfheaders/">https://dcooley.github.io/sfheaders/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dcooley/sfheaders/issues">https://github.com/dcooley/sfheaders/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>geometries (&ge; 0.2.4), Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-17 21:15:30 UTC; dave</td>
</tr>
<tr>
<td>Author:</td>
<td>David Cooley [aut, cre],
  Michael Sumner [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Cooley &lt;david.cooley.au@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-17 21:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sf_bbox'>sf bbox</h2><span id='topic+sf_bbox'></span>

<h3>Description</h3>

<p>Calculates the bounding box of coordinates. This does not read the &quot;bbox&quot; attribute,
it re-calculates the bounding box from the geometry coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_bbox(obj, x = NULL, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_bbox_+3A_obj">obj</code></td>
<td>
<p>matrix, data.frame, <code>sfg</code>, <code>sfc</code> or <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="sf_bbox_+3A_x">x</code></td>
<td>
<p>x geometry column</p>
</td></tr>
<tr><td><code id="sf_bbox_+3A_y">y</code></td>
<td>
<p>y geometry column</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## data.frame
df &lt;- data.frame(
 id1 = c(1,1,1,1,1,1,1,1,2,2,2,2)
 , id2 = c(1,1,1,1,2,2,2,2,1,1,1,1)
 , x = c(0,0,1,1,1,1,2,2,3,4,4,3)
 , y = c(0,1,1,0,1,2,2,1,3,3,4,4)
)

sf_bbox( obj = df[, c("x","y")] )
sf_bbox( obj = df, x = "x", y = "y" )

## sfg objects
pt &lt;- sfg_point(obj = df[1, ], x = "x", y = "y", z = "id1")
mpt &lt;- sfg_multipoint(obj = df, x = "x", y = "y")
ls &lt;- sfg_linestring(obj = df, x = "x", y = "y")
mls &lt;- sfg_multilinestring(obj = df, x = "x", y = "y")
p &lt;- sfg_polygon(obj = df, x = "x" , y = "y")
mp &lt;- sfg_multipolygon(obj = df, x = "x", y = "y", close = FALSE )

sf_bbox( pt )
sf_bbox( mpt )
sf_bbox( ls )
sf_bbox( mls )
sf_bbox( p )
sf_bbox( mp )

## sfc objects
pt &lt;- sfc_point(obj = df, x = "x", y = "y", z = "id1")
mpt &lt;- sfc_multipoint(obj = df, x = "x", y = "y", multipoint_id = "id1")
ls &lt;- sfc_linestring(obj = df, x = "x", y = "y", linestring_id = "id1")
mls &lt;- sfc_multilinestring(obj = df, x = "x", y = "y", multilinestring_id = "id1")
p &lt;- sfc_polygon(
  obj = df
  , x = "x"
  , y = "y"
  , polygon_id = "id1"
  , linestring_id = "id2"
  , close = FALSE
  )
mp &lt;- sfc_multipolygon(
  obj = df
  , x = "x"
  , y = "y"
  , multipolygon_id = "id1"
  , linestring_id = "id2"
  , close = FALSE
  )

sf_bbox( pt )
sf_bbox( mpt )
sf_bbox( ls )
sf_bbox( mls )
sf_bbox( p )
sf_bbox( mp )

## sf objects
pt &lt;- sf_point(obj = df, x = "x", y = "y", z = "id1")
mpt &lt;- sf_multipoint(obj = df, x = "x", y = "y", multipoint_id = "id1")
ls &lt;- sf_linestring(obj = df, x = "x", y = "y", linestring_id = "id1")
mls &lt;- sf_multilinestring(obj = df, x = "x", y = "y", multilinestring_id = "id1")
p &lt;- sf_polygon(
  obj = df
  , x = "x"
  , y = "y"
  , polygon_id = "id1"
  , linestring_id = "id2"
  , close = FALSE
  )
mp &lt;- sf_multipolygon(
  obj = df
  , x = "x"
  , y = "y"
  , multipolygon_id = "id1"
  , linestring_id = "id2"
  , close = FALSE
  )

sf_bbox( pt )
sf_bbox( mpt )
sf_bbox( ls )
sf_bbox( mls )
sf_bbox( p )
sf_bbox( mp )

## you can use it to update a bounding-box if it gets corrupted
attr( mpt, "bbox" ) &lt;- c(1:5)
mpt ## incorrect values
attr( mpt, "bbox" ) &lt;- sf_bbox( mpt )
mpt ## back to correct values

</code></pre>

<hr>
<h2 id='sf_boxes'>sf boxes</h2><span id='topic+sf_boxes'></span>

<h3>Description</h3>

<p>returns the bounding box of each geometry
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_boxes(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_boxes_+3A_obj">obj</code></td>
<td>
<p>sf, sfc or sfg object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(
 id1 = c(1,1,1,1,1,1,1,1,2,2,2,2)
 , id2 = c(1,1,1,1,2,2,2,2,1,1,1,1)
 , x = c(0,0,1,1,1,1,2,2,3,4,4,3)
 , y = c(0,1,1,0,1,2,2,1,3,3,4,4)
)

sf_line &lt;- sfheaders::sf_linestring(
  obj = df
  , x = "x"
  , y = "y"
  , linestring_id = "id1"
)

sf_boxes( sf_line )

</code></pre>

<hr>
<h2 id='sf_cast'>sf cast</h2><span id='topic+sf_cast'></span>

<h3>Description</h3>

<p>convert the input <code>sf</code> to a different geometry
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_cast(sf, to, close = TRUE, list_columns = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_cast_+3A_sf">sf</code></td>
<td>
<p>object to convert</p>
</td></tr>
<tr><td><code id="sf_cast_+3A_to">to</code></td>
<td>
<p>the geometry to convert to.</p>
</td></tr>
<tr><td><code id="sf_cast_+3A_close">close</code></td>
<td>
<p>logical indicating if polygons should be closed</p>
</td></tr>
<tr><td><code id="sf_cast_+3A_list_columns">list_columns</code></td>
<td>
<p>vector of column names or indexes. List columns are columns
of data where there is a value corresponding to each coordinate in the geometry (sfc).
List columns get cast with the geometries.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(
 id1 = c(1,1,1,1,1,1,1,1,2,2,2,2)
 , id2 = c(1,1,1,1,2,2,2,2,1,1,1,1)
 , x = c(0,0,1,1,1,1,2,2,3,4,4,3)
 , y = c(0,1,1,0,1,2,2,1,3,3,4,4)
)

pt &lt;- sf_point(obj = df, x = "x", y = "y", z = "id1")
mpt &lt;- sf_multipoint(obj = df, x = "x", y = "y", multipoint_id = "id1")
ls &lt;- sf_linestring(obj = df, x = "x", y = "y", linestring_id = "id1")
mls &lt;- sf_multilinestring(obj = df, x = "x", y = "y", multilinestring_id = "id1")
p &lt;- sf_polygon(
  obj = df
  , x = "x"
  , y = "y"
  , polygon_id = "id1"
  , linestring_id = "id2"
  , close = FALSE
  )
mp &lt;- sf_multipolygon(
  obj = df
  , x = "x"
  , y = "y"
  , multipolygon_id = "id1"
  , linestring_id = "id2"
  , close = FALSE
  )

sf_cast( pt, "LINESTRING" )
sf_cast( mpt, "POLYGON" )
sf_cast( ls, "POINT" )
sf_cast( mls, "MULTIPOLYGON" )
sf_cast( p, "POINT" )
sf_cast( mp, "LINESTRING" )


## List Columns

df &lt;- data.frame(
 id1 = c(1,1,1,1,1,1,1,1,2,2,2,2)
 , id2 = c(1,1,1,1,2,2,2,2,1,1,1,1)
 , x = c(0,0,1,1,1,1,2,2,3,4,4,3)
 , y = c(0,1,1,0,1,2,2,1,3,3,4,4)
)

## Add a column where each value is an attribute of each coordinate
df$val &lt;- letters[1:nrow(df)]

## Make a multipolygon, and specify `val` as a list_column
mp &lt;- sf_multipolygon(
  obj = df
  , x = "x"
  , y = "y"
  , multipolygon_id = "id1"
  , linestring_id = "id2"
  , list_column = "val"
  , keep = TRUE
  , close = FALSE
  )

## The 'val' attributes follow the same structure as the geometry column
## So each 'val' corresponds to a single coordinate in the geometry
str( mp )

## specifying `list_columns = "val"` when casting will retain the association
## between the 'val' attribute and each coordinate.
res &lt;- sf_cast( mp, "LINESTRING", list_columns = "val" )

## The 'val' attribute still follows the same structure as the geometry column
str( res )

</code></pre>

<hr>
<h2 id='sf_line'>Helper for sf LINESTRING</h2><span id='topic+sf_line'></span>

<h3>Description</h3>

<p>Constructs sf of LINESTRING objects, a helper for <code><a href="#topic+sf_linestring">sf_linestring()</a></code> with a
simpler syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_line(obj, keep = FALSE, list_columns = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_line_+3A_obj">obj</code></td>
<td>
<p>sorted matrix or data.frame</p>
</td></tr>
<tr><td><code id="sf_line_+3A_keep">keep</code></td>
<td>
<p>logical indicating if the non-geometry and non-id columns should be kept.
if TRUE you must supply the geometry and id columns, and only the first row of
each geometry is kept. See Keeping Properties.</p>
</td></tr>
<tr><td><code id="sf_line_+3A_list_columns">list_columns</code></td>
<td>
<p>vector of column names to turn into a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sf</code> object of LINESTRING geometries
</p>


<h3>Helpers</h3>

<p>These are simpler versions of the main functions <code><a href="#topic+sf_point">sf_point()</a></code>,
<code><a href="#topic+sf_multipoint">sf_multipoint()</a></code>, <code><a href="#topic+sf_linestring">sf_linestring()</a></code>, <code><a href="#topic+sf_multilinestring">sf_multilinestring()</a></code>, <code><a href="#topic+sf_polygon">sf_polygon()</a></code>,
and <code><a href="#topic+sf_multipolygon">sf_multipolygon()</a></code> for input data frame or matrix that contains columns
appropriately of 'x', 'y', 'z', 'm', ' multipolygon_id', polygon_id',
'multilinestring_id', 'linestring_id', 'multipoint_id'.
</p>
<p>This puts the onus of the naming and identification of entities onto the
input data set, rather than when calling the creator function. This has pros
and cons, so is not necessarily always 'simpler'. Please choose the
appropriate constructor for the context you have. For examples a data frame
from the real world with columns 'lon', 'lat', 'line' will be best used with
</p>
<p><code>sf_linestring(df, x = "lon", y = "lat", linestring_id = "line")</code>
</p>
<p>whereas a heavy user of sfheaders might always create a data frame with 'x',
'y', 'linestring_id' precisely because they are expecting to call
<code>sf_line(df)</code> and no further work is required. These are very different
contexts and both equally valid.
</p>
<p>Some columns are mandatory, such as 'x' and 'y' (always), while others depend
on the output type where each column for that type is mandatory. The 'z'
and/or 'm' values are included for 'XYZ', 'XYM', or 'XYZM' geometry types if
and as they are present.
</p>
<p>In summary these helpers:
</p>

<ul>
<li><p> do not require arguments declaring column names.
</p>
</li>
<li><p> use assumed default column names, with no variation or absence allowed for
a given type.
</p>
</li>
<li><p> use <code>z</code>, and/or <code>m</code> if present.
</p>
</li>
<li><p> use <code>close = FALSE</code> and <code>keep = FALSE</code> same as proper constructors.
</p>
</li>
<li><p> unlike <code><a href="#topic+sf_point">sf_point()</a></code> <code><a href="#topic+sf_pt">sf_pt()</a></code> does not accept a flat vector for a single
point.
</p>
</li>
<li><p> require a matrix or data frame with complete column names.
</p>
</li></ul>

<p>None of the helpers allow partial name matching for column names.
</p>


<h3>notes</h3>

<p>sfheaders functions do not perform any validity checks on the geometries.
Nor do they set Coordinate Reference Systems, EPSG, PROJ4 or precision attributes.
</p>
<p>The data.frame and matrices you send into the sfheader functions must be ordered.
</p>


<h3>Keeping Properties</h3>

<p>Setting <code>keep = TRUE</code> will retain any columns not specified as a
coordinate (x, y, z, m) or an id (e.g., linestring_id, polygon_id) of the input <code>obj</code>.
</p>
<p>You can use <code>list_columns</code> to specify which of the properties will be turned into
a list, thus keeping all the values in the column. For columns not specified in <code>list_columns</code>,
only the first row of the column is kept
</p>
<p>The <code>sf_*</code> functions assume the input <code>obj</code> is a long data.frame / matrix,
where any properties are repeated down the table for the same geometry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- cbind(x = 1:2, y = 3:4, linestring_id = 1)
sf_line( x )

x &lt;- data.frame( linestring_id = rep(1:2, each = 2), x = 1:4, y = 4:1 )
(sfx &lt;- sf_line( x ))

## we trivially round-trip with sf_line()
sf_line(sf_to_df(sfx))
</code></pre>

<hr>
<h2 id='sf_linestring'>sf LINESTRING</h2><span id='topic+sf_linestring'></span>

<h3>Description</h3>

<p>constructs sf of LINESTRING objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_linestring(
  obj = NULL,
  x = NULL,
  y = NULL,
  z = NULL,
  m = NULL,
  linestring_id = NULL,
  keep = FALSE,
  list_columns = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_linestring_+3A_obj">obj</code></td>
<td>
<p>sorted matrix or data.frame</p>
</td></tr>
<tr><td><code id="sf_linestring_+3A_x">x</code></td>
<td>
<p>x geometry column</p>
</td></tr>
<tr><td><code id="sf_linestring_+3A_y">y</code></td>
<td>
<p>y geometry column</p>
</td></tr>
<tr><td><code id="sf_linestring_+3A_z">z</code></td>
<td>
<p>z geometry column</p>
</td></tr>
<tr><td><code id="sf_linestring_+3A_m">m</code></td>
<td>
<p>m geometry column</p>
</td></tr>
<tr><td><code id="sf_linestring_+3A_linestring_id">linestring_id</code></td>
<td>
<p>column of ids for linestrings</p>
</td></tr>
<tr><td><code id="sf_linestring_+3A_keep">keep</code></td>
<td>
<p>logical indicating if the non-geometry and non-id columns should be kept.
if TRUE you must supply the geometry and id columns, and only the first row of
each geometry is kept. See Keeping Properties.</p>
</td></tr>
<tr><td><code id="sf_linestring_+3A_list_columns">list_columns</code></td>
<td>
<p>vector of column names to turn into a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sf</code> object of LINESTRING geometries
</p>


<h3>notes</h3>

<p>sfheaders functions do not perform any validity checks on the geometries.
Nor do they set Coordinate Reference Systems, EPSG, PROJ4 or precision attributes.
</p>
<p>The data.frame and matrices you send into the sfheader functions must be ordered.
</p>


<h3>Keeping Properties</h3>

<p>Setting <code>keep = TRUE</code> will retain any columns not specified as a
coordinate (x, y, z, m) or an id (e.g., linestring_id, polygon_id) of the input <code>obj</code>.
</p>
<p>You can use <code>list_columns</code> to specify which of the properties will be turned into
a list, thus keeping all the values in the column. For columns not specified in <code>list_columns</code>,
only the first row of the column is kept
</p>
<p>The <code>sf_*</code> functions assume the input <code>obj</code> is a long data.frame / matrix,
where any properties are repeated down the table for the same geometry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix( c(1:8), ncol = 2 )
sf_linestring( x )

x &lt;- cbind( x, c(1,1,2,2) )
sf_linestring( obj = x, x = 1, y = 2 )
sf_linestring( obj = x, x = 1, y = 2, linestring_id = 3 )

x &lt;- data.frame( line_id = 1:2, x = 1:2, y = 2:1 )
sf_linestring( x )
sf_linestring( x, x = "x", y = "y" )
sf_linestring( x, x = "y", y = "x" )
sf_linestring( x, linestring_id = "line_id", x = "x", y = "y")

## keeping properties
x &lt;- data.frame(
  line_id = c(1,1,2,2)
  , x = 1:4
  , y = 4:1
  , val = letters[1:4]
  , stringsAsFactors = FALSE
  )

## first-row of 'val' is kept
sf_linestring( x, x = "x", y = "y", keep = TRUE )
sf_linestring( x, linestring_id = "line_id", x = "x", y = "y", keep = TRUE )

## 'val' column converted to a list
sf_linestring( x, linestring_id = "id", x = "x", y = "y", keep = TRUE, list_columns = "val" )


</code></pre>

<hr>
<h2 id='sf_mline'>Helper for sf MULTILINESTRING</h2><span id='topic+sf_mline'></span>

<h3>Description</h3>

<p>Constructs sf of MULTILINESTRING objects, a helper for <code><a href="#topic+sf_multilinestring">sf_multilinestring()</a></code>
with a simpler syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_mline(obj, keep = FALSE, list_columns = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_mline_+3A_obj">obj</code></td>
<td>
<p>sorted matrix or data.frame</p>
</td></tr>
<tr><td><code id="sf_mline_+3A_keep">keep</code></td>
<td>
<p>logical indicating if the non-geometry and non-id columns should be kept.
if TRUE you must supply the geometry and id columns, and only the first row of
each geometry is kept. See Keeping Properties.</p>
</td></tr>
<tr><td><code id="sf_mline_+3A_list_columns">list_columns</code></td>
<td>
<p>vector of column names to turn into a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sf</code> object of MULTILINESTRING geometries
</p>


<h3>Helpers</h3>

<p>These are simpler versions of the main functions <code><a href="#topic+sf_point">sf_point()</a></code>,
<code><a href="#topic+sf_multipoint">sf_multipoint()</a></code>, <code><a href="#topic+sf_linestring">sf_linestring()</a></code>, <code><a href="#topic+sf_multilinestring">sf_multilinestring()</a></code>, <code><a href="#topic+sf_polygon">sf_polygon()</a></code>,
and <code><a href="#topic+sf_multipolygon">sf_multipolygon()</a></code> for input data frame or matrix that contains columns
appropriately of 'x', 'y', 'z', 'm', ' multipolygon_id', polygon_id',
'multilinestring_id', 'linestring_id', 'multipoint_id'.
</p>
<p>This puts the onus of the naming and identification of entities onto the
input data set, rather than when calling the creator function. This has pros
and cons, so is not necessarily always 'simpler'. Please choose the
appropriate constructor for the context you have. For examples a data frame
from the real world with columns 'lon', 'lat', 'line' will be best used with
</p>
<p><code>sf_linestring(df, x = "lon", y = "lat", linestring_id = "line")</code>
</p>
<p>whereas a heavy user of sfheaders might always create a data frame with 'x',
'y', 'linestring_id' precisely because they are expecting to call
<code>sf_line(df)</code> and no further work is required. These are very different
contexts and both equally valid.
</p>
<p>Some columns are mandatory, such as 'x' and 'y' (always), while others depend
on the output type where each column for that type is mandatory. The 'z'
and/or 'm' values are included for 'XYZ', 'XYM', or 'XYZM' geometry types if
and as they are present.
</p>
<p>In summary these helpers:
</p>

<ul>
<li><p> do not require arguments declaring column names.
</p>
</li>
<li><p> use assumed default column names, with no variation or absence allowed for
a given type.
</p>
</li>
<li><p> use <code>z</code>, and/or <code>m</code> if present.
</p>
</li>
<li><p> use <code>close = FALSE</code> and <code>keep = FALSE</code> same as proper constructors.
</p>
</li>
<li><p> unlike <code><a href="#topic+sf_point">sf_point()</a></code> <code><a href="#topic+sf_pt">sf_pt()</a></code> does not accept a flat vector for a single
point.
</p>
</li>
<li><p> require a matrix or data frame with complete column names.
</p>
</li></ul>

<p>None of the helpers allow partial name matching for column names.
</p>


<h3>notes</h3>

<p>sfheaders functions do not perform any validity checks on the geometries.
Nor do they set Coordinate Reference Systems, EPSG, PROJ4 or precision attributes.
</p>
<p>The data.frame and matrices you send into the sfheader functions must be ordered.
</p>


<h3>Keeping Properties</h3>

<p>Setting <code>keep = TRUE</code> will retain any columns not specified as a
coordinate (x, y, z, m) or an id (e.g., linestring_id, polygon_id) of the input <code>obj</code>.
</p>
<p>You can use <code>list_columns</code> to specify which of the properties will be turned into
a list, thus keeping all the values in the column. For columns not specified in <code>list_columns</code>,
only the first row of the column is kept
</p>
<p>The <code>sf_*</code> functions assume the input <code>obj</code> is a long data.frame / matrix,
where any properties are repeated down the table for the same geometry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- cbind(x = 0, y = 0, multilinestring_id = c(1, 1, 1), linestring_id = 1)
sf_mline( m )

df &lt;- data.frame(
  multilinestring_id = c(1,1,1,1,1,1,1,1,2,2,2,2,2)
  ,    linestring_id = c(1,1,1,2,2,3,3,3,1,1,1,2,2)
  , x = rnorm(13)
  , y = rnorm(13)
  , z = rnorm(13)
  , m = rnorm(13)
)

sf_mline( obj = df)
sf_mline( obj = df[-6])
## this gives XYZ, not XYM see #64
(sfx &lt;- sf_mline( obj = df[-5]))

## we trivially round-trip with sf_mline()
sf_mline(sf_to_df(sfx))

## to round-trip with all fields use `fill`, then `keep`
sf_mline(sf_to_df(sfx, fill = TRUE), keep = TRUE)

</code></pre>

<hr>
<h2 id='sf_mpoly'>Helper for sf MULTIPOLYGON</h2><span id='topic+sf_mpoly'></span>

<h3>Description</h3>

<p>Constructs sf of MULTIPOLYGON objects, a helper for <code><a href="#topic+sf_multipolygon">sf_multipolygon()</a></code> with
a simpler syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_mpoly(obj, close = TRUE, keep = FALSE, list_columns = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_mpoly_+3A_obj">obj</code></td>
<td>
<p>sorted matrix or data.frame</p>
</td></tr>
<tr><td><code id="sf_mpoly_+3A_close">close</code></td>
<td>
<p>logical indicating whether polygons should be closed. If <code>TRUE</code>,
all polygons will be checked and force closed if possible</p>
</td></tr>
<tr><td><code id="sf_mpoly_+3A_keep">keep</code></td>
<td>
<p>logical indicating if the non-geometry and non-id columns should be kept.
if TRUE you must supply the geometry and id columns, and only the first row of
each geometry is kept. See Keeping Properties.</p>
</td></tr>
<tr><td><code id="sf_mpoly_+3A_list_columns">list_columns</code></td>
<td>
<p>vector of column names to turn into a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sf</code> object of MULTIPOLYGON geometries
</p>


<h3>Helpers</h3>

<p>These are simpler versions of the main functions <code><a href="#topic+sf_point">sf_point()</a></code>,
<code><a href="#topic+sf_multipoint">sf_multipoint()</a></code>, <code><a href="#topic+sf_linestring">sf_linestring()</a></code>, <code><a href="#topic+sf_multilinestring">sf_multilinestring()</a></code>, <code><a href="#topic+sf_polygon">sf_polygon()</a></code>,
and <code><a href="#topic+sf_multipolygon">sf_multipolygon()</a></code> for input data frame or matrix that contains columns
appropriately of 'x', 'y', 'z', 'm', ' multipolygon_id', polygon_id',
'multilinestring_id', 'linestring_id', 'multipoint_id'.
</p>
<p>This puts the onus of the naming and identification of entities onto the
input data set, rather than when calling the creator function. This has pros
and cons, so is not necessarily always 'simpler'. Please choose the
appropriate constructor for the context you have. For examples a data frame
from the real world with columns 'lon', 'lat', 'line' will be best used with
</p>
<p><code>sf_linestring(df, x = "lon", y = "lat", linestring_id = "line")</code>
</p>
<p>whereas a heavy user of sfheaders might always create a data frame with 'x',
'y', 'linestring_id' precisely because they are expecting to call
<code>sf_line(df)</code> and no further work is required. These are very different
contexts and both equally valid.
</p>
<p>Some columns are mandatory, such as 'x' and 'y' (always), while others depend
on the output type where each column for that type is mandatory. The 'z'
and/or 'm' values are included for 'XYZ', 'XYM', or 'XYZM' geometry types if
and as they are present.
</p>
<p>In summary these helpers:
</p>

<ul>
<li><p> do not require arguments declaring column names.
</p>
</li>
<li><p> use assumed default column names, with no variation or absence allowed for
a given type.
</p>
</li>
<li><p> use <code>z</code>, and/or <code>m</code> if present.
</p>
</li>
<li><p> use <code>close = FALSE</code> and <code>keep = FALSE</code> same as proper constructors.
</p>
</li>
<li><p> unlike <code><a href="#topic+sf_point">sf_point()</a></code> <code><a href="#topic+sf_pt">sf_pt()</a></code> does not accept a flat vector for a single
point.
</p>
</li>
<li><p> require a matrix or data frame with complete column names.
</p>
</li></ul>

<p>None of the helpers allow partial name matching for column names.
</p>


<h3>notes</h3>

<p>sfheaders functions do not perform any validity checks on the geometries.
Nor do they set Coordinate Reference Systems, EPSG, PROJ4 or precision attributes.
</p>
<p>The data.frame and matrices you send into the sfheader functions must be ordered.
</p>


<h3>Keeping Properties</h3>

<p>Setting <code>keep = TRUE</code> will retain any columns not specified as a
coordinate (x, y, z, m) or an id (e.g., linestring_id, polygon_id) of the input <code>obj</code>.
</p>
<p>You can use <code>list_columns</code> to specify which of the properties will be turned into
a list, thus keeping all the values in the column. For columns not specified in <code>list_columns</code>,
only the first row of the column is kept
</p>
<p>The <code>sf_*</code> functions assume the input <code>obj</code> is a long data.frame / matrix,
where any properties are repeated down the table for the same geometry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- matrix(c(0,0,0,0,1,0,0,1,1,0,0,1,0,0,0), ncol = 3, byrow = TRUE,
      dimnames = list(NULL, c("x", "y", "z")))
m &lt;- cbind(m, multipolygon_id = 1, polygon_id = 1, linestring_id = 1)
sf_mpoly( m )

df &lt;- as.data.frame(m)

sf_mpoly( df)

## order doesn't matter, only the names are used
sf_mpoly(df[c(6, 5, 3, 4, 1, 2)])

</code></pre>

<hr>
<h2 id='sf_mpt'>Helper for sf MULTIPOINT</h2><span id='topic+sf_mpt'></span>

<h3>Description</h3>

<p>Constructs sf of MULTIPOINT objects, a helper for <code><a href="#topic+sf_multipoint">sf_multipoint()</a></code> with a
simpler syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_mpt(obj, keep = FALSE, list_columns = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_mpt_+3A_obj">obj</code></td>
<td>
<p>sorted vector, matrix or data.frame</p>
</td></tr>
<tr><td><code id="sf_mpt_+3A_keep">keep</code></td>
<td>
<p>logical indicating if the non-geometry and non-id columns should be kept.
if TRUE you must supply the geometry and id columns, and only the first row of
each geometry is kept. See Keeping Properties.</p>
</td></tr>
<tr><td><code id="sf_mpt_+3A_list_columns">list_columns</code></td>
<td>
<p>vector of column names to turn into a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sf</code> object of MULTIPOINT geometries
</p>


<h3>Helpers</h3>

<p>These are simpler versions of the main functions <code><a href="#topic+sf_point">sf_point()</a></code>,
<code><a href="#topic+sf_multipoint">sf_multipoint()</a></code>, <code><a href="#topic+sf_linestring">sf_linestring()</a></code>, <code><a href="#topic+sf_multilinestring">sf_multilinestring()</a></code>, <code><a href="#topic+sf_polygon">sf_polygon()</a></code>,
and <code><a href="#topic+sf_multipolygon">sf_multipolygon()</a></code> for input data frame or matrix that contains columns
appropriately of 'x', 'y', 'z', 'm', ' multipolygon_id', polygon_id',
'multilinestring_id', 'linestring_id', 'multipoint_id'.
</p>
<p>This puts the onus of the naming and identification of entities onto the
input data set, rather than when calling the creator function. This has pros
and cons, so is not necessarily always 'simpler'. Please choose the
appropriate constructor for the context you have. For examples a data frame
from the real world with columns 'lon', 'lat', 'line' will be best used with
</p>
<p><code>sf_linestring(df, x = "lon", y = "lat", linestring_id = "line")</code>
</p>
<p>whereas a heavy user of sfheaders might always create a data frame with 'x',
'y', 'linestring_id' precisely because they are expecting to call
<code>sf_line(df)</code> and no further work is required. These are very different
contexts and both equally valid.
</p>
<p>Some columns are mandatory, such as 'x' and 'y' (always), while others depend
on the output type where each column for that type is mandatory. The 'z'
and/or 'm' values are included for 'XYZ', 'XYM', or 'XYZM' geometry types if
and as they are present.
</p>
<p>In summary these helpers:
</p>

<ul>
<li><p> do not require arguments declaring column names.
</p>
</li>
<li><p> use assumed default column names, with no variation or absence allowed for
a given type.
</p>
</li>
<li><p> use <code>z</code>, and/or <code>m</code> if present.
</p>
</li>
<li><p> use <code>close = FALSE</code> and <code>keep = FALSE</code> same as proper constructors.
</p>
</li>
<li><p> unlike <code><a href="#topic+sf_point">sf_point()</a></code> <code><a href="#topic+sf_pt">sf_pt()</a></code> does not accept a flat vector for a single
point.
</p>
</li>
<li><p> require a matrix or data frame with complete column names.
</p>
</li></ul>

<p>None of the helpers allow partial name matching for column names.
</p>


<h3>notes</h3>

<p>sfheaders functions do not perform any validity checks on the geometries.
Nor do they set Coordinate Reference Systems, EPSG, PROJ4 or precision attributes.
</p>
<p>The data.frame and matrices you send into the sfheader functions must be ordered.
</p>


<h3>Keeping Properties</h3>

<p>Setting <code>keep = TRUE</code> will retain any columns not specified as a
coordinate (x, y, z, m) or an id (e.g., linestring_id, polygon_id) of the input <code>obj</code>.
</p>
<p>You can use <code>list_columns</code> to specify which of the properties will be turned into
a list, thus keeping all the values in the column. For columns not specified in <code>list_columns</code>,
only the first row of the column is kept
</p>
<p>The <code>sf_*</code> functions assume the input <code>obj</code> is a long data.frame / matrix,
where any properties are repeated down the table for the same geometry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- cbind(x = 1:2, y = 3:4, multipoint_id = 1, ncol = 2 )
sf_mpt( x )

x &lt;- data.frame( id = 1:2, x = 1:2, y = 2:1, multipoint_id = 1)
sf_mpt( x )
sf_mpt( x, keep = TRUE)
x &lt;- data.frame(multipoint_id = 1:2, id = 1:2, x = 1:2, y = 2:1 )
(sfx &lt;- sf_mpt(x))

## we trivially round-trip with sf_mpt()
sf_mpt(sf_to_df(sfx))
</code></pre>

<hr>
<h2 id='sf_multilinestring'>sf MULTILINESTRING</h2><span id='topic+sf_multilinestring'></span>

<h3>Description</h3>

<p>constructs an sf of MULTILINESTRING objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_multilinestring(
  obj = NULL,
  x = NULL,
  y = NULL,
  z = NULL,
  m = NULL,
  multilinestring_id = NULL,
  linestring_id = NULL,
  keep = FALSE,
  list_columns = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_multilinestring_+3A_obj">obj</code></td>
<td>
<p>sorted matrix or data.frame</p>
</td></tr>
<tr><td><code id="sf_multilinestring_+3A_x">x</code></td>
<td>
<p>x geometry column</p>
</td></tr>
<tr><td><code id="sf_multilinestring_+3A_y">y</code></td>
<td>
<p>y geometry column</p>
</td></tr>
<tr><td><code id="sf_multilinestring_+3A_z">z</code></td>
<td>
<p>z geometry column</p>
</td></tr>
<tr><td><code id="sf_multilinestring_+3A_m">m</code></td>
<td>
<p>m geometry column</p>
</td></tr>
<tr><td><code id="sf_multilinestring_+3A_multilinestring_id">multilinestring_id</code></td>
<td>
<p>column of ids for multilinestrings</p>
</td></tr>
<tr><td><code id="sf_multilinestring_+3A_linestring_id">linestring_id</code></td>
<td>
<p>column of ids for linestrings (within multilinestrings)</p>
</td></tr>
<tr><td><code id="sf_multilinestring_+3A_keep">keep</code></td>
<td>
<p>logical indicating if the non-geometry and non-id columns should be kept.
if TRUE you must supply the geometry and id columns, and only the first row of
each geometry is kept. See Keeping Properties.</p>
</td></tr>
<tr><td><code id="sf_multilinestring_+3A_list_columns">list_columns</code></td>
<td>
<p>vector of column names to turn into a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sf</code> object of MULTILINESTRING geometries
</p>


<h3>notes</h3>

<p>sfheaders functions do not perform any validity checks on the geometries.
Nor do they set Coordinate Reference Systems, EPSG, PROJ4 or precision attributes.
</p>
<p>The data.frame and matrices you send into the sfheader functions must be ordered.
</p>


<h3>Keeping Properties</h3>

<p>Setting <code>keep = TRUE</code> will retain any columns not specified as a
coordinate (x, y, z, m) or an id (e.g., linestring_id, polygon_id) of the input <code>obj</code>.
</p>
<p>You can use <code>list_columns</code> to specify which of the properties will be turned into
a list, thus keeping all the values in the column. For columns not specified in <code>list_columns</code>,
only the first row of the column is kept
</p>
<p>The <code>sf_*</code> functions assume the input <code>obj</code> is a long data.frame / matrix,
where any properties are repeated down the table for the same geometry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- matrix(c(0,0,0,0,1,1), ncol = 3 )
sf_multilinestring( m )

m &lt;- matrix(c(0,0,0,0,0,1,0,1,1,1,2,2,1,2,3), ncol = 3, byrow = TRUE)
sf_multilinestring( obj = m )
sf_multilinestring( obj = m, multilinestring_id = 1 )
sf_multilinestring( obj = m, linestring_id = 1 )

sf_multilinestring( obj = m, linestring_id = 1, multilinestring_id = 1 )

sf_multilinestring( obj = m, x = 2, y = 3 )
sf_multilinestring( obj = m, x = 1, y = 2, z = 3 )
sf_multilinestring( obj = m, x = 2, y = 3, linestring_id = 1, multilinestring_id = 1 )

df &lt;- data.frame(
  ml_id = c(1,1,1,1,1,1,1,1,2,2,2,2,2)
  , l_id = c(1,1,1,2,2,3,3,3,1,1,1,2,2)
  , x = rnorm(13)
  , y = rnorm(13)
  , z = rnorm(13)
  , m = rnorm(13)
)

sf_multilinestring( obj = df, x = "x", y = "y")
sf_multilinestring( obj = df, x = "x", y = "y", z = "z")
sf_multilinestring( obj = df, x = "x", y = "y", z = "z", m = "m")

sf_multilinestring( obj = df, x = 3, y = 4)
sf_multilinestring( obj = df, x = 3, y = 4, z = 5)
sf_multilinestring( obj = df, x = 3, y = 4, z = 5, m = 6 )

sf_multilinestring( obj = df, multilinestring_id = "ml_id", linestring_id = "l_id" )
sf_multilinestring( obj = df, multilinestring_id = 1, linestring_id = 2 )



</code></pre>

<hr>
<h2 id='sf_multipoint'>sf MULTIPOINT</h2><span id='topic+sf_multipoint'></span>

<h3>Description</h3>

<p>constructs sf of MULTIPOINT objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_multipoint(
  obj,
  x = NULL,
  y = NULL,
  z = NULL,
  m = NULL,
  multipoint_id = NULL,
  keep = FALSE,
  list_columns = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_multipoint_+3A_obj">obj</code></td>
<td>
<p>sorted matrix or data.frame</p>
</td></tr>
<tr><td><code id="sf_multipoint_+3A_x">x</code></td>
<td>
<p>x geometry column</p>
</td></tr>
<tr><td><code id="sf_multipoint_+3A_y">y</code></td>
<td>
<p>y geometry column</p>
</td></tr>
<tr><td><code id="sf_multipoint_+3A_z">z</code></td>
<td>
<p>z geometry column</p>
</td></tr>
<tr><td><code id="sf_multipoint_+3A_m">m</code></td>
<td>
<p>m geometry column</p>
</td></tr>
<tr><td><code id="sf_multipoint_+3A_multipoint_id">multipoint_id</code></td>
<td>
<p>column of ids for multipoints</p>
</td></tr>
<tr><td><code id="sf_multipoint_+3A_keep">keep</code></td>
<td>
<p>logical indicating if the non-geometry and non-id columns should be kept.
if TRUE you must supply the geometry and id columns, and only the first row of
each geometry is kept. See Keeping Properties.</p>
</td></tr>
<tr><td><code id="sf_multipoint_+3A_list_columns">list_columns</code></td>
<td>
<p>vector of column names to turn into a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sf</code> object of MULTIPOINT geometries
</p>


<h3>notes</h3>

<p>sfheaders functions do not perform any validity checks on the geometries.
Nor do they set Coordinate Reference Systems, EPSG, PROJ4 or precision attributes.
</p>
<p>The data.frame and matrices you send into the sfheader functions must be ordered.
</p>


<h3>Keeping Properties</h3>

<p>Setting <code>keep = TRUE</code> will retain any columns not specified as a
coordinate (x, y, z, m) or an id (e.g., linestring_id, polygon_id) of the input <code>obj</code>.
</p>
<p>You can use <code>list_columns</code> to specify which of the properties will be turned into
a list, thus keeping all the values in the column. For columns not specified in <code>list_columns</code>,
only the first row of the column is kept
</p>
<p>The <code>sf_*</code> functions assume the input <code>obj</code> is a long data.frame / matrix,
where any properties are repeated down the table for the same geometry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix( c(1:4), ncol = 2 )
sf_multipoint( x )

x &lt;- data.frame( id = 1:2, x = 1:2, y = 2:1 )
sf_multipoint( x )
sf_multipoint( x, x = "x", y = "y" )
sf_multipoint( x, x = "y", y = "x" )
sf_multipoint( x, multipoint_id = "id", x = "x", y = "y")

</code></pre>

<hr>
<h2 id='sf_multipolygon'>sf MULTIPOLYGON</h2><span id='topic+sf_multipolygon'></span>

<h3>Description</h3>

<p>constructs an sf of MULTIPOLYGON objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_multipolygon(
  obj = NULL,
  x = NULL,
  y = NULL,
  z = NULL,
  m = NULL,
  multipolygon_id = NULL,
  polygon_id = NULL,
  linestring_id = NULL,
  close = TRUE,
  keep = FALSE,
  list_columns = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_multipolygon_+3A_obj">obj</code></td>
<td>
<p>sorted matrix or data.frame</p>
</td></tr>
<tr><td><code id="sf_multipolygon_+3A_x">x</code></td>
<td>
<p>x geometry column</p>
</td></tr>
<tr><td><code id="sf_multipolygon_+3A_y">y</code></td>
<td>
<p>y geometry column</p>
</td></tr>
<tr><td><code id="sf_multipolygon_+3A_z">z</code></td>
<td>
<p>z geometry column</p>
</td></tr>
<tr><td><code id="sf_multipolygon_+3A_m">m</code></td>
<td>
<p>m geometry column</p>
</td></tr>
<tr><td><code id="sf_multipolygon_+3A_multipolygon_id">multipolygon_id</code></td>
<td>
<p>column of ids for multipolygons</p>
</td></tr>
<tr><td><code id="sf_multipolygon_+3A_polygon_id">polygon_id</code></td>
<td>
<p>column of ids for polygons</p>
</td></tr>
<tr><td><code id="sf_multipolygon_+3A_linestring_id">linestring_id</code></td>
<td>
<p>column of ids for lines (within polygons)</p>
</td></tr>
<tr><td><code id="sf_multipolygon_+3A_close">close</code></td>
<td>
<p>logical indicating whether polygons should be closed. If <code>TRUE</code>,
all polygons will be checked and force closed if possible</p>
</td></tr>
<tr><td><code id="sf_multipolygon_+3A_keep">keep</code></td>
<td>
<p>logical indicating if the non-geometry and non-id columns should be kept.
if TRUE you must supply the geometry and id columns, and only the first row of
each geometry is kept. See Keeping Properties.</p>
</td></tr>
<tr><td><code id="sf_multipolygon_+3A_list_columns">list_columns</code></td>
<td>
<p>vector of column names to turn into a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sf</code> object of MULTIPOLYGON geometries
</p>


<h3>notes</h3>

<p>sfheaders functions do not perform any validity checks on the geometries.
Nor do they set Coordinate Reference Systems, EPSG, PROJ4 or precision attributes.
</p>
<p>The data.frame and matrices you send into the sfheader functions must be ordered.
</p>


<h3>Keeping Properties</h3>

<p>Setting <code>keep = TRUE</code> will retain any columns not specified as a
coordinate (x, y, z, m) or an id (e.g., linestring_id, polygon_id) of the input <code>obj</code>.
</p>
<p>You can use <code>list_columns</code> to specify which of the properties will be turned into
a list, thus keeping all the values in the column. For columns not specified in <code>list_columns</code>,
only the first row of the column is kept
</p>
<p>The <code>sf_*</code> functions assume the input <code>obj</code> is a long data.frame / matrix,
where any properties are repeated down the table for the same geometry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- matrix(c(0,0,0,0,1,0,0,1,1,0,0,1,0,0,0), ncol = 3, byrow = TRUE )
sf_multipolygon( m )

df &lt;- data.frame(
  id = c(1,1,1,1,1)
  , x = c(0,0,1,1,0)
  , y = c(0,1,1,0,0)
)

sf_multipolygon( df, x = "x", y = "y" )

df &lt;- data.frame(
  id = c(1,1,1,1,1,2,2,2,2,2)
  , x = c(0,0,1,1,0,1,1,2,2,1)
  , y = c(0,1,1,0,0,1,2,2,1,1)
)

sf_multipolygon( df, multipolygon_id = "id", polygon_id = "id", linestring_id = "id")

df &lt;- data.frame(
  id1 = c(1,1,1,1,1,1,1,1,1,1)
  , id2 = c(1,1,1,1,1,2,2,2,2,2)
  , x = c(0,0,1,1,0,1,1,2,2,1)
  , y = c(0,1,1,0,0,1,2,2,1,1)
)

sf_multipolygon( df, multipolygon_id = "id1", polygon_id = "id2")

df &lt;- data.frame(
  id1 = c(1,1,1,1,1,1,1,1,1,1,2,2,2,2,2)
  , id2 = c(1,1,1,1,1,2,2,2,2,2,1,1,1,1,1)
  , x = c(0,0,1,1,0,1,1,2,2,1,3,3,4,4,3)
  , y = c(0,1,1,0,0,1,2,2,1,1,3,4,4,3,3)
)

sf_multipolygon( df, multipolygon_id = "id1", polygon_id = "id2")

df &lt;- data.frame(
  id1 = c(1,1,1,1,1,2,2,2,2,2)
  , id2 = c(1,1,1,1,1,1,1,1,1,1)
  , x = c(0,0,1,1,0,1,1,2,2,1)
  , y = c(0,1,1,0,0,1,2,2,1,1)
)

sf_multipolygon( df, multipolygon_id = "id1", polygon_id = "id2" )
sf_multipolygon( df, polygon_id = "id1", linestring_id = "id2" )
sf_multipolygon( df, x = "x", y = "y", polygon_id = "id1")
sf_multipolygon( df, x = "x", y = "y", polygon_id = "id1", linestring_id = "id2")
sf_multipolygon( df, x = "x", y = "y", linestring_id = "id1")
sf_multipolygon( df, x = "x", y = "y", linestring_id = "id2")

df &lt;- data.frame(
  id1 = c('a','a','a','a','a','b','b','b','b','b')
  , id2 = c(1,1,1,1,1,1,1,1,1,1)
  , x = c(0,0,1,1,0,1,1,2,2,1)
  , y = c(0,1,1,0,0,1,2,2,1,1)
)

sf_multipolygon( df, x = "x", y = "y", polygon_id = "id1")

</code></pre>

<hr>
<h2 id='sf_point'>sf POINT</h2><span id='topic+sf_point'></span>

<h3>Description</h3>

<p>constructs sf of POINT objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_point(obj, x = NULL, y = NULL, z = NULL, m = NULL, keep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_point_+3A_obj">obj</code></td>
<td>
<p>sorted vector, matrix or data.frame</p>
</td></tr>
<tr><td><code id="sf_point_+3A_x">x</code></td>
<td>
<p>x geometry column</p>
</td></tr>
<tr><td><code id="sf_point_+3A_y">y</code></td>
<td>
<p>y geometry column</p>
</td></tr>
<tr><td><code id="sf_point_+3A_z">z</code></td>
<td>
<p>z geometry column</p>
</td></tr>
<tr><td><code id="sf_point_+3A_m">m</code></td>
<td>
<p>m geometry column</p>
</td></tr>
<tr><td><code id="sf_point_+3A_keep">keep</code></td>
<td>
<p>logical indicating if the non-geometry and non-id columns should be kept.
if TRUE you must supply the geometry and id columns, and only the first row of
each geometry is kept. See Keeping Properties.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sf</code> object of POINT geometries
</p>


<h3>Keeping Properties</h3>

<p>Setting <code>keep = TRUE</code> will retain any columns not specified as a
coordinate (x, y, z, m) or an id (e.g., linestring_id, polygon_id) of the input <code>obj</code>.
</p>
<p>You can use <code>list_columns</code> to specify which of the properties will be turned into
a list, thus keeping all the values in the column. For columns not specified in <code>list_columns</code>,
only the first row of the column is kept
</p>
<p>The <code>sf_*</code> functions assume the input <code>obj</code> is a long data.frame / matrix,
where any properties are repeated down the table for the same geometry.
</p>


<h3>notes</h3>

<p>sfheaders functions do not perform any validity checks on the geometries.
Nor do they set Coordinate Reference Systems, EPSG, PROJ4 or precision attributes.
</p>
<p>The data.frame and matrices you send into the sfheader functions must be ordered.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c(1:3)
sf_point( x )

x &lt;- matrix( c(1:10) , ncol = 2 )
sf_point( x )

x &lt;- setNames( as.data.frame( x ), c("x","y") )
sf_point( x )
sf_point( obj = x, x = "x", y = "y" )
sf_point( obj = x, x = "y", y = "x" )

# keeping properties
x$val &lt;- letters[1:5]
sf_point( x, x = "x", y = "y", keep = TRUE )

</code></pre>

<hr>
<h2 id='sf_poly'>Helper for sf POLYGON</h2><span id='topic+sf_poly'></span>

<h3>Description</h3>

<p>Constructs sf of POLYGON objects, a helper for <code><a href="#topic+sf_polygon">sf_polygon()</a></code> with a simpler
syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_poly(obj, close = TRUE, keep = FALSE, list_columns = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_poly_+3A_obj">obj</code></td>
<td>
<p>sorted matrix or data.frame</p>
</td></tr>
<tr><td><code id="sf_poly_+3A_close">close</code></td>
<td>
<p>logical indicating whether polygons should be closed. If <code>TRUE</code>,
all polygons will be checked and force closed if possible</p>
</td></tr>
<tr><td><code id="sf_poly_+3A_keep">keep</code></td>
<td>
<p>logical indicating if the non-geometry and non-id columns should be kept.
if TRUE you must supply the geometry and id columns, and only the first row of
each geometry is kept. See Keeping Properties.</p>
</td></tr>
<tr><td><code id="sf_poly_+3A_list_columns">list_columns</code></td>
<td>
<p>vector of column names to turn into a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sf</code> object of POLYGON geometries
</p>


<h3>Helpers</h3>

<p>These are simpler versions of the main functions <code><a href="#topic+sf_point">sf_point()</a></code>,
<code><a href="#topic+sf_multipoint">sf_multipoint()</a></code>, <code><a href="#topic+sf_linestring">sf_linestring()</a></code>, <code><a href="#topic+sf_multilinestring">sf_multilinestring()</a></code>, <code><a href="#topic+sf_polygon">sf_polygon()</a></code>,
and <code><a href="#topic+sf_multipolygon">sf_multipolygon()</a></code> for input data frame or matrix that contains columns
appropriately of 'x', 'y', 'z', 'm', ' multipolygon_id', polygon_id',
'multilinestring_id', 'linestring_id', 'multipoint_id'.
</p>
<p>This puts the onus of the naming and identification of entities onto the
input data set, rather than when calling the creator function. This has pros
and cons, so is not necessarily always 'simpler'. Please choose the
appropriate constructor for the context you have. For examples a data frame
from the real world with columns 'lon', 'lat', 'line' will be best used with
</p>
<p><code>sf_linestring(df, x = "lon", y = "lat", linestring_id = "line")</code>
</p>
<p>whereas a heavy user of sfheaders might always create a data frame with 'x',
'y', 'linestring_id' precisely because they are expecting to call
<code>sf_line(df)</code> and no further work is required. These are very different
contexts and both equally valid.
</p>
<p>Some columns are mandatory, such as 'x' and 'y' (always), while others depend
on the output type where each column for that type is mandatory. The 'z'
and/or 'm' values are included for 'XYZ', 'XYM', or 'XYZM' geometry types if
and as they are present.
</p>
<p>In summary these helpers:
</p>

<ul>
<li><p> do not require arguments declaring column names.
</p>
</li>
<li><p> use assumed default column names, with no variation or absence allowed for
a given type.
</p>
</li>
<li><p> use <code>z</code>, and/or <code>m</code> if present.
</p>
</li>
<li><p> use <code>close = FALSE</code> and <code>keep = FALSE</code> same as proper constructors.
</p>
</li>
<li><p> unlike <code><a href="#topic+sf_point">sf_point()</a></code> <code><a href="#topic+sf_pt">sf_pt()</a></code> does not accept a flat vector for a single
point.
</p>
</li>
<li><p> require a matrix or data frame with complete column names.
</p>
</li></ul>

<p>None of the helpers allow partial name matching for column names.
</p>


<h3>notes</h3>

<p>sfheaders functions do not perform any validity checks on the geometries.
Nor do they set Coordinate Reference Systems, EPSG, PROJ4 or precision attributes.
</p>
<p>The data.frame and matrices you send into the sfheader functions must be ordered.
</p>


<h3>Keeping Properties</h3>

<p>Setting <code>keep = TRUE</code> will retain any columns not specified as a
coordinate (x, y, z, m) or an id (e.g., linestring_id, polygon_id) of the input <code>obj</code>.
</p>
<p>You can use <code>list_columns</code> to specify which of the properties will be turned into
a list, thus keeping all the values in the column. For columns not specified in <code>list_columns</code>,
only the first row of the column is kept
</p>
<p>The <code>sf_*</code> functions assume the input <code>obj</code> is a long data.frame / matrix,
where any properties are repeated down the table for the same geometry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- matrix(c(0,0,0,0,1,0,0,1,1,0,0,1,0,0,0), ncol = 3, byrow = TRUE,
      dimnames = list(NULL, c("x", "y", "z")))
m &lt;- cbind(m, polygon_id = 1, linestring_id = 1)
sf_poly( m )

df &lt;- as.data.frame(m)

sf_poly( df)

## order doesn't matter, only the names are used
sf_poly(df[c(5, 3, 4, 1, 2)])

</code></pre>

<hr>
<h2 id='sf_polygon'>sf POLYGON</h2><span id='topic+sf_polygon'></span>

<h3>Description</h3>

<p>constructs an sf of POLYGON objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_polygon(
  obj = NULL,
  x = NULL,
  y = NULL,
  z = NULL,
  m = NULL,
  polygon_id = NULL,
  linestring_id = NULL,
  close = TRUE,
  keep = FALSE,
  list_columns = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_polygon_+3A_obj">obj</code></td>
<td>
<p>sorted matrix or data.frame</p>
</td></tr>
<tr><td><code id="sf_polygon_+3A_x">x</code></td>
<td>
<p>x geometry column</p>
</td></tr>
<tr><td><code id="sf_polygon_+3A_y">y</code></td>
<td>
<p>y geometry column</p>
</td></tr>
<tr><td><code id="sf_polygon_+3A_z">z</code></td>
<td>
<p>z geometry column</p>
</td></tr>
<tr><td><code id="sf_polygon_+3A_m">m</code></td>
<td>
<p>m geometry column</p>
</td></tr>
<tr><td><code id="sf_polygon_+3A_polygon_id">polygon_id</code></td>
<td>
<p>column of ids for polygons</p>
</td></tr>
<tr><td><code id="sf_polygon_+3A_linestring_id">linestring_id</code></td>
<td>
<p>column of ids for lines (within polygons)</p>
</td></tr>
<tr><td><code id="sf_polygon_+3A_close">close</code></td>
<td>
<p>logical indicating whether polygons should be closed. If <code>TRUE</code>,
all polygons will be checked and force closed if possible</p>
</td></tr>
<tr><td><code id="sf_polygon_+3A_keep">keep</code></td>
<td>
<p>logical indicating if the non-geometry and non-id columns should be kept.
if TRUE you must supply the geometry and id columns, and only the first row of
each geometry is kept. See Keeping Properties.</p>
</td></tr>
<tr><td><code id="sf_polygon_+3A_list_columns">list_columns</code></td>
<td>
<p>vector of column names to turn into a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sf</code> object of POLYGON geometries
</p>


<h3>notes</h3>

<p>sfheaders functions do not perform any validity checks on the geometries.
Nor do they set Coordinate Reference Systems, EPSG, PROJ4 or precision attributes.
</p>
<p>The data.frame and matrices you send into the sfheader functions must be ordered.
</p>


<h3>Keeping Properties</h3>

<p>Setting <code>keep = TRUE</code> will retain any columns not specified as a
coordinate (x, y, z, m) or an id (e.g., linestring_id, polygon_id) of the input <code>obj</code>.
</p>
<p>You can use <code>list_columns</code> to specify which of the properties will be turned into
a list, thus keeping all the values in the column. For columns not specified in <code>list_columns</code>,
only the first row of the column is kept
</p>
<p>The <code>sf_*</code> functions assume the input <code>obj</code> is a long data.frame / matrix,
where any properties are repeated down the table for the same geometry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- matrix(c(0,0,0,0,1,1), ncol = 2 )
sf_polygon( m )

m &lt;- matrix(c(0,0,0,0,0,1,0,1,1,1,2,2,1,2,3,1,3,4), ncol = 3, byrow = TRUE)
sf_polygon( obj = m )
sf_polygon( obj = m, polygon_id = 1 )
sf_polygon( obj = m, linestring_id = 1 )

sf_polygon( obj = m, linestring_id = 1, polygon_id = 1 )

sf_polygon( obj = m, x = 2, y = 3 )
sf_polygon( obj = m, x = 1, y = 2, z = 3 )
sf_polygon( obj = m, x = 2, y = 3, linestring_id = 1, polygon_id = 1 )

df &lt;- data.frame(
  ml_id = c(1,1,1,1,1,1,1,1,1,2,2,2,2,2,2)
  , l_id = c(1,1,1,2,2,2,3,3,3,1,1,1,2,2,2)
  , x = rnorm(15)
  , y = rnorm(15)
  , z = rnorm(15)
  , m = rnorm(15)
)

sf_polygon( obj = df, x = "x", y = "y")
sf_polygon( obj = df, x = "x", y = "y", z = "z")
sf_polygon( obj = df, x = "x", y = "y", z = "z", m = "m")

sf_polygon( obj = df, x = 2, y = 3)
sf_polygon( obj = df, x = 2, y = 3, z = 4)
sf_polygon( obj = df, x = 2, y = 3, z = 4, m = 5)

sf_polygon( obj = df, polygon_id = "ml_id", linestring_id = "l_id" )
sf_polygon( obj = df, polygon_id = 1, linestring_id = 2 )

## keeping properties
df &lt;- data.frame(
  ml_id = c(1,1,1,1,1,1,1,1,1,2,2,2,2,2,2)
  , l_id = c(1,1,1,2,2,2,3,3,3,1,1,1,2,2,2)
  , x = rnorm(15)
  , y = rnorm(15)
  , z = rnorm(15)
  , m = rnorm(15)
  , val = letters[1:15]
  , stringsAsFactors = FALSE
)

## using keep = TRUE means the first row of all non-geometries are kept
sf_polygon(
  obj = df
  , polygon_id = "ml_id"
  , linestring_id = "l_id"
  , x = "x"
  , y = "y"
  , keep = TRUE
)

## use 'list_column' to specify columns where you want to keep all the values
sf_polygon(
  obj = df
  , polygon_id = "ml_id"
  , linestring_id = "l_id"
  , x = "x"
  , y = "y"
  , keep = TRUE
  , list_columns = "val"
)

</code></pre>

<hr>
<h2 id='sf_pt'>Helper for sf POINT</h2><span id='topic+sf_pt'></span>

<h3>Description</h3>

<p>Constructs sf of POINT objects, a helper for <code><a href="#topic+sf_point">sf_point()</a></code> with a simpler
syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_pt(obj, keep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_pt_+3A_obj">obj</code></td>
<td>
<p>sorted vector, matrix or data.frame</p>
</td></tr>
<tr><td><code id="sf_pt_+3A_keep">keep</code></td>
<td>
<p>logical indicating if the non-geometry and non-id columns should be kept.
if TRUE you must supply the geometry and id columns, and only the first row of
each geometry is kept. See Keeping Properties.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sf</code> object of POINT geometries
</p>


<h3>Helpers</h3>

<p>These are simpler versions of the main functions <code><a href="#topic+sf_point">sf_point()</a></code>,
<code><a href="#topic+sf_multipoint">sf_multipoint()</a></code>, <code><a href="#topic+sf_linestring">sf_linestring()</a></code>, <code><a href="#topic+sf_multilinestring">sf_multilinestring()</a></code>, <code><a href="#topic+sf_polygon">sf_polygon()</a></code>,
and <code><a href="#topic+sf_multipolygon">sf_multipolygon()</a></code> for input data frame or matrix that contains columns
appropriately of 'x', 'y', 'z', 'm', ' multipolygon_id', polygon_id',
'multilinestring_id', 'linestring_id', 'multipoint_id'.
</p>
<p>This puts the onus of the naming and identification of entities onto the
input data set, rather than when calling the creator function. This has pros
and cons, so is not necessarily always 'simpler'. Please choose the
appropriate constructor for the context you have. For examples a data frame
from the real world with columns 'lon', 'lat', 'line' will be best used with
</p>
<p><code>sf_linestring(df, x = "lon", y = "lat", linestring_id = "line")</code>
</p>
<p>whereas a heavy user of sfheaders might always create a data frame with 'x',
'y', 'linestring_id' precisely because they are expecting to call
<code>sf_line(df)</code> and no further work is required. These are very different
contexts and both equally valid.
</p>
<p>Some columns are mandatory, such as 'x' and 'y' (always), while others depend
on the output type where each column for that type is mandatory. The 'z'
and/or 'm' values are included for 'XYZ', 'XYM', or 'XYZM' geometry types if
and as they are present.
</p>
<p>In summary these helpers:
</p>

<ul>
<li><p> do not require arguments declaring column names.
</p>
</li>
<li><p> use assumed default column names, with no variation or absence allowed for
a given type.
</p>
</li>
<li><p> use <code>z</code>, and/or <code>m</code> if present.
</p>
</li>
<li><p> use <code>close = FALSE</code> and <code>keep = FALSE</code> same as proper constructors.
</p>
</li>
<li><p> unlike <code><a href="#topic+sf_point">sf_point()</a></code> <code><a href="#topic+sf_pt">sf_pt()</a></code> does not accept a flat vector for a single
point.
</p>
</li>
<li><p> require a matrix or data frame with complete column names.
</p>
</li></ul>

<p>None of the helpers allow partial name matching for column names.
</p>


<h3>notes</h3>

<p>sfheaders functions do not perform any validity checks on the geometries.
Nor do they set Coordinate Reference Systems, EPSG, PROJ4 or precision attributes.
</p>
<p>The data.frame and matrices you send into the sfheader functions must be ordered.
</p>


<h3>Keeping Properties</h3>

<p>Setting <code>keep = TRUE</code> will retain any columns not specified as a
coordinate (x, y, z, m) or an id (e.g., linestring_id, polygon_id) of the input <code>obj</code>.
</p>
<p>You can use <code>list_columns</code> to specify which of the properties will be turned into
a list, thus keeping all the values in the column. For columns not specified in <code>list_columns</code>,
only the first row of the column is kept
</p>
<p>The <code>sf_*</code> functions assume the input <code>obj</code> is a long data.frame / matrix,
where any properties are repeated down the table for the same geometry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- cbind(x = 1, y= 3)
sf_pt( x )
sf_pt(cbind(x, z = 2))

x &lt;- matrix( c(1:10) , ncol = 2 , dimnames = list(NULL, c("x", "y")))
sf_pt( x )

x &lt;- setNames( as.data.frame( x ), c("x","y") )
sf_pt( x )

# keeping properties
x$val &lt;- letters[1:5]
(sfx &lt;- sf_pt( x, keep = TRUE ))

## we trivially round-trip with sf_pt()
sf_pt(sf_to_df(sfx, fill = TRUE), keep = TRUE)
</code></pre>

<hr>
<h2 id='sf_remove_holes'>remove holes</h2><span id='topic+sf_remove_holes'></span>

<h3>Description</h3>

<p>Removes holes from polygons and multipolygons. Points and linestrings are unaffected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_remove_holes(obj, close = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_remove_holes_+3A_obj">obj</code></td>
<td>
<p>sfg, sfc or sf object.</p>
</td></tr>
<tr><td><code id="sf_remove_holes_+3A_close">close</code></td>
<td>
<p>logical indicating whether polygons should be closed. If <code>TRUE</code>,
all polygons will be checked and force closed if possible</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  ml_id = c(1,1,1,1,1,1,1,1,1,2,2,2,2,2,2)
  , l_id = c(1,1,1,2,2,2,3,3,3,1,1,1,2,2,2)
  , x = rnorm(15)
  , y = rnorm(15)
  , z = rnorm(15)
  , m = rnorm(15)
)

sfg &lt;- sfg_polygon( obj = df, x = "x", y = "y", linestring_id = "ml_id" )
sfc &lt;- sfc_polygon( obj = df, x = "x", y = "y", polygon_id = "ml_id", linestring_id = "l_id" )
sf &lt;- sf_polygon( obj = df, x = "x", y = "y", polygon_id = "ml_id", linestring_id = "l_id" )

sf_remove_holes( sfg )
sf_remove_holes( sfc )
sf_remove_holes( sf )

</code></pre>

<hr>
<h2 id='sf_to_df'>sf to df</h2><span id='topic+sf_to_df'></span>

<h3>Description</h3>

<p>Converts an sf object to a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_to_df(sf, fill = FALSE, unlist = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_to_df_+3A_sf">sf</code></td>
<td>
<p>sf object</p>
</td></tr>
<tr><td><code id="sf_to_df_+3A_fill">fill</code></td>
<td>
<p>logical indicating if the resulting data.frame should be filled
with the data columns from the sf object. If <code>TRUE</code>, each row of data will
be replicated for every coordinate in every geometry.</p>
</td></tr>
<tr><td><code id="sf_to_df_+3A_unlist">unlist</code></td>
<td>
<p>string vector of columns to unlist. Each list element is equivalent
to a row of the input object, and is expected to be the same
length as the number of coordinates in the geometry.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(
ml_id = c(1,1,1,1,1,1,1,1,1,2,2,2,2,2,2)
, l_id = c(1,1,1,2,2,2,3,3,3,1,1,1,2,2,2)
, x = rnorm(15)
, y = rnorm(15)
, z = rnorm(15)
, m = rnorm(15)
)

sf &lt;- sf_polygon( obj = df, polygon_id = "ml_id", linestring_id = "l_id" )
df &lt;- sf_to_df( sf )

## with associated data
sf$val1 &lt;- c("a","b")
sf$val2 &lt;- c(1L, 2L)

df &lt;- sf_to_df( sf, fill = TRUE )

## Unlisting list columns

df &lt;- data.frame(
l_id = c(1,1,1,2,2,2,3,3,3,3)
, x = rnorm(10)
, y = rnorm(10)
)

sf &lt;- sf_linestring( obj = df, linestring_id = "l_id" , x = "x", y = "y")

## put on a list column
sf$l &lt;- list( c(1,2,3),c(3,2,1),c(10,11,12,13))

sf_to_df( sf, unlist = "l" )


</code></pre>

<hr>
<h2 id='sfc_cast'>sfc cast</h2><span id='topic+sfc_cast'></span>

<h3>Description</h3>

<p>convert the input <code>sfc</code> to a different geometry
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfc_cast(sfc, to, close = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfc_cast_+3A_sfc">sfc</code></td>
<td>
<p>geometry object to convert to a different geometry</p>
</td></tr>
<tr><td><code id="sfc_cast_+3A_to">to</code></td>
<td>
<p>the geometry to convert to.</p>
</td></tr>
<tr><td><code id="sfc_cast_+3A_close">close</code></td>
<td>
<p>logical indicating if polygons should be closed</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
 id1 = c(1,1,1,1,1,1,1,1,2,2,2,2)
 , id2 = c(1,1,1,1,2,2,2,2,1,1,1,1)
 , x = c(0,0,1,1,1,1,2,2,3,4,4,3)
 , y = c(0,1,1,0,1,2,2,1,3,3,4,4)
)

pt &lt;- sfc_point(obj = df, x = "x", y = "y", z = "id1")
mpt &lt;- sfc_multipoint(obj = df, x = "x", y = "y", multipoint_id = "id1")
ls &lt;- sfc_linestring(obj = df, x = "x", y = "y", linestring_id = "id1")
mls &lt;- sfc_multilinestring(obj = df, x = "x", y = "y", multilinestring_id = "id1")
p &lt;- sfc_polygon(
  obj = df
  , x = "x"
  , y = "y"
  , polygon_id = "id1"
  , linestring_id = "id2"
  , close = FALSE
  )
mp &lt;- sfc_multipolygon(
  obj = df
  , x = "x"
  , y = "y"
  , multipolygon_id = "id1"
  , linestring_id = "id2"
  , close = FALSE
)

sfc_cast( pt, "LINESTRING" )
sfc_cast( mpt, "POLYGON" )
sfc_cast( ls, "POINT" )
sfc_cast( mls, "MULTIPOLYGON" )
sfc_cast( p, "POINT" )
sfc_cast( mp, "LINESTRING" )

</code></pre>

<hr>
<h2 id='sfc_linestring'>sfc LINESTRING</h2><span id='topic+sfc_linestring'></span>

<h3>Description</h3>

<p>constructs sfc of LINESTRING objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfc_linestring(
  obj = NULL,
  x = NULL,
  y = NULL,
  z = NULL,
  m = NULL,
  linestring_id = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfc_linestring_+3A_obj">obj</code></td>
<td>
<p>sorted matrix or data.frame</p>
</td></tr>
<tr><td><code id="sfc_linestring_+3A_x">x</code></td>
<td>
<p>x geometry column</p>
</td></tr>
<tr><td><code id="sfc_linestring_+3A_y">y</code></td>
<td>
<p>y geometry column</p>
</td></tr>
<tr><td><code id="sfc_linestring_+3A_z">z</code></td>
<td>
<p>z geometry column</p>
</td></tr>
<tr><td><code id="sfc_linestring_+3A_m">m</code></td>
<td>
<p>m geometry column</p>
</td></tr>
<tr><td><code id="sfc_linestring_+3A_linestring_id">linestring_id</code></td>
<td>
<p>column of ids for linestrings</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sfc</code> object of LINESTRING geometries
</p>


<h3>notes</h3>

<p>sfheaders functions do not perform any validity checks on the geometries.
Nor do they set Coordinate Reference Systems, EPSG, PROJ4 or precision attributes.
</p>
<p>The data.frame and matrices you send into the sfheader functions must be ordered.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix( c(1:4), ncol = 2 )
sfc_linestring( x )

x &lt;- data.frame( id = 1:2, x = 1:2, y = 2:1 )
sfc_linestring( x )
sfc_linestring( x, x = "x", y = "y" )
sfc_linestring( x, x = "y", y = "x" )
sfc_linestring( x, linestring_id = "id", x = "x", y = "y")

df &lt;- data.frame(
  id = c(1,1,1,1,2,2,2)
  , x = 1:7
  , y = 7:1
  , z = 14:8
  , m = 8:14
)

sfc_linestring(df, x = "x", y = "y", linestring_id = "id")
sfc_linestring(df, x = "x", y = "y", z = "z", linestring_id = "id")
sfc_linestring(df, x = "x", y = "y", m = "m", linestring_id = "id")
sfc_linestring(df, x = "x", y = "y", z = "z", m = "m", linestring_id = "id")

</code></pre>

<hr>
<h2 id='sfc_multilinestring'>sfc MULTILINESTRING</h2><span id='topic+sfc_multilinestring'></span>

<h3>Description</h3>

<p>constructs an sfc of MULTILINESTRING objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfc_multilinestring(
  obj = NULL,
  x = NULL,
  y = NULL,
  z = NULL,
  m = NULL,
  multilinestring_id = NULL,
  linestring_id = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfc_multilinestring_+3A_obj">obj</code></td>
<td>
<p>sorted matrix or data.frame</p>
</td></tr>
<tr><td><code id="sfc_multilinestring_+3A_x">x</code></td>
<td>
<p>x geometry column</p>
</td></tr>
<tr><td><code id="sfc_multilinestring_+3A_y">y</code></td>
<td>
<p>y geometry column</p>
</td></tr>
<tr><td><code id="sfc_multilinestring_+3A_z">z</code></td>
<td>
<p>z geometry column</p>
</td></tr>
<tr><td><code id="sfc_multilinestring_+3A_m">m</code></td>
<td>
<p>m geometry column</p>
</td></tr>
<tr><td><code id="sfc_multilinestring_+3A_multilinestring_id">multilinestring_id</code></td>
<td>
<p>column of ids for multilinestrings</p>
</td></tr>
<tr><td><code id="sfc_multilinestring_+3A_linestring_id">linestring_id</code></td>
<td>
<p>column of ids for linestrings (within multilinestrings)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sfc</code> object of MULTILINESTRING geometries
</p>


<h3>notes</h3>

<p>sfheaders functions do not perform any validity checks on the geometries.
Nor do they set Coordinate Reference Systems, EPSG, PROJ4 or precision attributes.
</p>
<p>The data.frame and matrices you send into the sfheader functions must be ordered.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- matrix(c(0,0,0,0,1,1), ncol = 3 )
sfc_multilinestring( m )

m &lt;- matrix(c(0,0,0,0,0,1,0,1,1,1,2,2,1,2,3), ncol = 3, byrow = TRUE)
sfc_multilinestring( obj = m )
sfc_multilinestring( obj = m, multilinestring_id = 1 )
sfc_multilinestring( obj = m, linestring_id = 1 )

sfc_multilinestring( obj = m, linestring_id = 1, multilinestring_id = 1 )

sfc_multilinestring( obj = m, x = 2, y = 3 )
sfc_multilinestring( obj = m, x = 1, y = 2, z = 3 )
sfc_multilinestring( obj = m, x = 2, y = 3, linestring_id = 1, multilinestring_id = 1 )

df &lt;- data.frame(
  ml_id = c(1,1,1,1,1,1,1,1,2,2,2,2,2)
  , l_id = c(1,1,1,2,2,3,3,3,1,1,1,2,2)
  , x = rnorm(13)
  , y = rnorm(13)
  , z = rnorm(13)
  , m = rnorm(13)
)

sfc_multilinestring( obj = df, x = "x", y = "y")
sfc_multilinestring( obj = df, x = "x", y = "y", z = "z")
sfc_multilinestring( obj = df, x = "x", y = "y", z = "z", m = "m")

sfc_multilinestring( obj = df, x = 2, y = 3)
sfc_multilinestring( obj = df, x = 2, y = 3, z = 4)
sfc_multilinestring( obj = df, x = 2, y = 3, z = 4, m = 5)

sfc_multilinestring( obj = df, multilinestring_id = "ml_id", linestring_id = "l_id" )
sfc_multilinestring( obj = df, multilinestring_id = 1, linestring_id = 2 )



</code></pre>

<hr>
<h2 id='sfc_multipoint'>sfc MULTIPOINT</h2><span id='topic+sfc_multipoint'></span>

<h3>Description</h3>

<p>constructs sfc of MULTIPOINT objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfc_multipoint(
  obj,
  x = NULL,
  y = NULL,
  z = NULL,
  m = NULL,
  multipoint_id = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfc_multipoint_+3A_obj">obj</code></td>
<td>
<p>sorted matrix or data.frame</p>
</td></tr>
<tr><td><code id="sfc_multipoint_+3A_x">x</code></td>
<td>
<p>x geometry column</p>
</td></tr>
<tr><td><code id="sfc_multipoint_+3A_y">y</code></td>
<td>
<p>y geometry column</p>
</td></tr>
<tr><td><code id="sfc_multipoint_+3A_z">z</code></td>
<td>
<p>z geometry column</p>
</td></tr>
<tr><td><code id="sfc_multipoint_+3A_m">m</code></td>
<td>
<p>m geometry column</p>
</td></tr>
<tr><td><code id="sfc_multipoint_+3A_multipoint_id">multipoint_id</code></td>
<td>
<p>column of ids for multipoints</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sfc</code> object of MULTIPOINT geometries
</p>


<h3>notes</h3>

<p>sfheaders functions do not perform any validity checks on the geometries.
Nor do they set Coordinate Reference Systems, EPSG, PROJ4 or precision attributes.
</p>
<p>The data.frame and matrices you send into the sfheader functions must be ordered.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix( c(1:4), ncol = 2 )
sfc_multipoint( x )

x &lt;- data.frame( id = 1:2, x = 1:2, y = 2:1 )
sfc_multipoint( x )
sfc_multipoint( x, x = "x", y = "y" )
sfc_multipoint( x, x = "y", y = "x" )
sfc_multipoint( x, multipoint_id = "id", x = "x", y = "y")

</code></pre>

<hr>
<h2 id='sfc_multipolygon'>sfc MULTIPOLYGON</h2><span id='topic+sfc_multipolygon'></span>

<h3>Description</h3>

<p>constructs an sfc of MULTIPOLYGON objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfc_multipolygon(
  obj = NULL,
  x = NULL,
  y = NULL,
  z = NULL,
  m = NULL,
  multipolygon_id = NULL,
  polygon_id = NULL,
  linestring_id = NULL,
  close = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfc_multipolygon_+3A_obj">obj</code></td>
<td>
<p>sorted matrix or data.frame</p>
</td></tr>
<tr><td><code id="sfc_multipolygon_+3A_x">x</code></td>
<td>
<p>x geometry column</p>
</td></tr>
<tr><td><code id="sfc_multipolygon_+3A_y">y</code></td>
<td>
<p>y geometry column</p>
</td></tr>
<tr><td><code id="sfc_multipolygon_+3A_z">z</code></td>
<td>
<p>z geometry column</p>
</td></tr>
<tr><td><code id="sfc_multipolygon_+3A_m">m</code></td>
<td>
<p>m geometry column</p>
</td></tr>
<tr><td><code id="sfc_multipolygon_+3A_multipolygon_id">multipolygon_id</code></td>
<td>
<p>column of ids for multipolygons</p>
</td></tr>
<tr><td><code id="sfc_multipolygon_+3A_polygon_id">polygon_id</code></td>
<td>
<p>column of ids for polygons</p>
</td></tr>
<tr><td><code id="sfc_multipolygon_+3A_linestring_id">linestring_id</code></td>
<td>
<p>column of ids for lines (within polygons)</p>
</td></tr>
<tr><td><code id="sfc_multipolygon_+3A_close">close</code></td>
<td>
<p>logical indicating whether polygons should be closed. If <code>TRUE</code>,
all polygons will be checked and force closed if possible</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sfc</code> object of MULTIPOLYGON geometries
</p>


<h3>notes</h3>

<p>sfheaders functions do not perform any validity checks on the geometries.
Nor do they set Coordinate Reference Systems, EPSG, PROJ4 or precision attributes.
</p>
<p>The data.frame and matrices you send into the sfheader functions must be ordered.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- matrix(c(0,0,0,0,1,0,0,1,1,0,0,1,0,0,0), ncol = 3, byrow = TRUE )
sfc_multipolygon( m )

df &lt;- data.frame(
  id = c(1,1,1,1,1)
  , x = c(0,0,1,1,0)
  , y = c(0,1,1,0,0)
)

sfc_multipolygon( df, x = "x", y = "y" )

df &lt;- data.frame(
  id = c(1,1,1,1,1,2,2,2,2,2)
  , x = c(0,0,1,1,0,1,1,2,2,1)
  , y = c(0,1,1,0,0,1,2,2,1,1)
)

sfc_multipolygon( df, multipolygon_id = "id", polygon_id = "id", linestring_id = "id")

df &lt;- data.frame(
  id1 = c(1,1,1,1,1,1,1,1,1,1)
  , id2 = c(1,1,1,1,1,2,2,2,2,2)
  , x = c(0,0,1,1,0,1,1,2,2,1)
  , y = c(0,1,1,0,0,1,2,2,1,1)
)

sfc_multipolygon( df, multipolygon_id = "id1", polygon_id = "id2")

df &lt;- data.frame(
  id1 = c(1,1,1,1,1,1,1,1,1,1,2,2,2,2,2)
  , id2 = c(1,1,1,1,1,2,2,2,2,2,1,1,1,1,1)
  , x = c(0,0,1,1,0,1,1,2,2,1,3,3,4,4,3)
  , y = c(0,1,1,0,0,1,2,2,1,1,3,4,4,3,3)
)

sfc_multipolygon( df, multipolygon_id = "id1", polygon_id = "id2")

df &lt;- data.frame(
  id1 = c(1,1,1,1,1,2,2,2,2,2)
  , id2 = c(1,1,1,1,1,1,1,1,1,1)
  , x = c(0,0,1,1,0,1,1,2,2,1)
  , y = c(0,1,1,0,0,1,2,2,1,1)
)

sfc_multipolygon( df, multipolygon_id = "id1", polygon_id = "id2" )
sfc_multipolygon( df, polygon_id = "id1", linestring_id = "id2" )
sfc_multipolygon( df, x = "x", y = "y", polygon_id = "id1")
sfc_multipolygon( df, x = "x", y = "y", polygon_id = "id1", linestring_id = "id2")
sfc_multipolygon( df, x = "x", y = "y", linestring_id = "id1")
sfc_multipolygon( df, x = "x", y = "y", linestring_id = "id2")

df &lt;- data.frame(
  id1 = c('a','a','a','a','a','b','b','b','b','b')
  , id2 = c(1,1,1,1,1,1,1,1,1,1)
  , x = c(0,0,1,1,0,1,1,2,2,1)
  , y = c(0,1,1,0,0,1,2,2,1,1)
)

sfc_multipolygon( df, x = "x", y = "y", polygon_id = "id1")

</code></pre>

<hr>
<h2 id='sfc_point'>sfc POINT</h2><span id='topic+sfc_point'></span>

<h3>Description</h3>

<p>constructs sfc of POINT objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfc_point(obj, x = NULL, y = NULL, z = NULL, m = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfc_point_+3A_obj">obj</code></td>
<td>
<p>sorted vector, matrix or data.frame</p>
</td></tr>
<tr><td><code id="sfc_point_+3A_x">x</code></td>
<td>
<p>x geometry column</p>
</td></tr>
<tr><td><code id="sfc_point_+3A_y">y</code></td>
<td>
<p>y geometry column</p>
</td></tr>
<tr><td><code id="sfc_point_+3A_z">z</code></td>
<td>
<p>z geometry column</p>
</td></tr>
<tr><td><code id="sfc_point_+3A_m">m</code></td>
<td>
<p>m geometry column</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sfc</code> object of POINT geometries
</p>


<h3>notes</h3>

<p>sfheaders functions do not perform any validity checks on the geometries.
Nor do they set Coordinate Reference Systems, EPSG, PROJ4 or precision attributes.
</p>
<p>The data.frame and matrices you send into the sfheader functions must be ordered.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c(1:3)
sfc_point( x )

x &lt;- matrix( c(1:10) , ncol = 2 )
sfc_point( x )

x &lt;- setNames( as.data.frame( x ), c("x","y") )
sfc_point( x )
sfc_point( obj = x, x = "x", y = "y" )
sfc_point( obj = x, x = "y", y = "x" )

</code></pre>

<hr>
<h2 id='sfc_polygon'>sfc POLYGON</h2><span id='topic+sfc_polygon'></span>

<h3>Description</h3>

<p>constructs an sfc of POLYGON objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfc_polygon(
  obj = NULL,
  x = NULL,
  y = NULL,
  z = NULL,
  m = NULL,
  polygon_id = NULL,
  linestring_id = NULL,
  close = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfc_polygon_+3A_obj">obj</code></td>
<td>
<p>sorted matrix or data.frame</p>
</td></tr>
<tr><td><code id="sfc_polygon_+3A_x">x</code></td>
<td>
<p>x geometry column</p>
</td></tr>
<tr><td><code id="sfc_polygon_+3A_y">y</code></td>
<td>
<p>y geometry column</p>
</td></tr>
<tr><td><code id="sfc_polygon_+3A_z">z</code></td>
<td>
<p>z geometry column</p>
</td></tr>
<tr><td><code id="sfc_polygon_+3A_m">m</code></td>
<td>
<p>m geometry column</p>
</td></tr>
<tr><td><code id="sfc_polygon_+3A_polygon_id">polygon_id</code></td>
<td>
<p>column of ids for polygons</p>
</td></tr>
<tr><td><code id="sfc_polygon_+3A_linestring_id">linestring_id</code></td>
<td>
<p>column of ids for lines (within polygons)</p>
</td></tr>
<tr><td><code id="sfc_polygon_+3A_close">close</code></td>
<td>
<p>logical indicating whether polygons should be closed. If <code>TRUE</code>,
all polygons will be checked and force closed if possible</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sfc</code> object of POLYGON geometries
</p>


<h3>notes</h3>

<p>sfheaders functions do not perform any validity checks on the geometries.
Nor do they set Coordinate Reference Systems, EPSG, PROJ4 or precision attributes.
</p>
<p>The data.frame and matrices you send into the sfheader functions must be ordered.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- matrix(c(0,0,0,0,1,1), ncol = 2 )
sfc_polygon( m )

m &lt;- matrix(c(0,0,0,0,0,1,0,1,1,1,2,2,1,2,3,1,3,2), ncol = 3, byrow = TRUE)
sfc_polygon( obj = m )
sfc_polygon( obj = m, polygon_id = 1 )
sfc_polygon( obj = m, linestring_id = 1 )

sfc_polygon( obj = m, linestring_id = 1, polygon_id = 1 )

sfc_polygon( obj = m, x = 2, y = 3 )
sfc_polygon( obj = m, x = 1, y = 2, z = 3 )
sfc_polygon( obj = m, x = 2, y = 3, linestring_id = 1, polygon_id = 1 )

df &lt;- data.frame(
  ml_id = c(1,1,1,1,1,1,1,1,1,2,2,2,2,2,2)
  , l_id = c(1,1,1,2,2,2,3,3,3,1,1,1,2,2,2)
  , x = rnorm(15)
  , y = rnorm(15)
  , z = rnorm(15)
  , m = rnorm(15)
)

sfc_polygon( obj = df, x = "x", y = "y")
sfc_polygon( obj = df, x = "x", y = "y", z = "z")
sfc_polygon( obj = df, x = "x", y = "y", z = "z", m = "m")

sfc_polygon( obj = df, x = 2, y = 3)
sfc_polygon( obj = df, x = 2, y = 3, z = 4)
sfc_polygon( obj = df, x = 2, y = 3, z = 4, m = 5)

sfc_polygon( obj = df, polygon_id = "ml_id", linestring_id = "l_id" )
sfc_polygon( obj = df, polygon_id = 1, linestring_id = 2 )



</code></pre>

<hr>
<h2 id='sfc_to_df'>sfc to df</h2><span id='topic+sfc_to_df'></span>

<h3>Description</h3>

<p>Converts an sfc object to a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfc_to_df(sfc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfc_to_df_+3A_sfc">sfc</code></td>
<td>
<p>sfc object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix( c(1:16), ncol = 2 )
sfc &lt;- sfc_linestring( x )
df &lt;- sfc_to_df( sfc )

df &lt;- data.frame(
ml_id = c(1,1,1,1,1,1,1,1,2,2,2,2,2)
, l_id = c(1,1,1,2,2,3,3,3,1,1,1,2,2)
, x = rnorm(13)
, y = rnorm(13)
, z = rnorm(13)
, m = rnorm(13)
)
sfc &lt;- sfc_multilinestring( obj = df, multilinestring_id = "ml_id", linestring_id = "l_id" )

df &lt;- sfc_to_df( sfc )

</code></pre>

<hr>
<h2 id='sfg_linestring'>sfg linestring</h2><span id='topic+sfg_linestring'></span>

<h3>Description</h3>

<p>constructs sfg LINESTRING object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfg_linestring(obj, x = NULL, y = NULL, z = NULL, m = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfg_linestring_+3A_obj">obj</code></td>
<td>
<p>matrix or data.frame</p>
</td></tr>
<tr><td><code id="sfg_linestring_+3A_x">x</code></td>
<td>
<p>x geometry column</p>
</td></tr>
<tr><td><code id="sfg_linestring_+3A_y">y</code></td>
<td>
<p>y geometry column</p>
</td></tr>
<tr><td><code id="sfg_linestring_+3A_z">z</code></td>
<td>
<p>z geometry column</p>
</td></tr>
<tr><td><code id="sfg_linestring_+3A_m">m</code></td>
<td>
<p>m geometry column</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sfg</code> object of LINESTRING geometry
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sfg_linestring( 1:2 )
sfg_linestring( 1:3 )
sfg_linestring( 1:4 )

sfg_linestring( matrix( 1:24, ncol = 2 ) )
sfg_linestring( matrix( 1:24, ncol = 3 ) )
sfg_linestring( matrix( 1:24, ncol = 4 ) )

sfg_linestring( matrix( 1:24, ncol = 4 ), x = 3, y = 2, z = 3)

sfg_linestring( data.frame( x = 1:10, y = 11:20 ) )
sfg_linestring( data.frame( x = 1:10, y = 11:20, z = 21:30 ) )
sfg_linestring( data.frame( x = 1:10, y = 11:20, z = 21:30 ), x = "x", y = "z" )


</code></pre>

<hr>
<h2 id='sfg_multilinestring'>sfg multilinestring</h2><span id='topic+sfg_multilinestring'></span>

<h3>Description</h3>

<p>constructs sfg MULTILINESTRING object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfg_multilinestring(
  obj,
  x = NULL,
  y = NULL,
  z = NULL,
  m = NULL,
  linestring_id = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfg_multilinestring_+3A_obj">obj</code></td>
<td>
<p>matrix or data.frame</p>
</td></tr>
<tr><td><code id="sfg_multilinestring_+3A_x">x</code></td>
<td>
<p>x geometry column</p>
</td></tr>
<tr><td><code id="sfg_multilinestring_+3A_y">y</code></td>
<td>
<p>y geometry column</p>
</td></tr>
<tr><td><code id="sfg_multilinestring_+3A_z">z</code></td>
<td>
<p>z geometry column</p>
</td></tr>
<tr><td><code id="sfg_multilinestring_+3A_m">m</code></td>
<td>
<p>m geometry column</p>
</td></tr>
<tr><td><code id="sfg_multilinestring_+3A_linestring_id">linestring_id</code></td>
<td>
<p>column of ids for lines</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sfg</code> object of MULTILINESTRING geometry
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sfg_multilinestring( matrix( 1:24, ncol = 2 ) )
sfg_multilinestring( matrix( 1:24, ncol = 3 ) )
sfg_multilinestring( matrix( 1:24, ncol = 4 ) )

## different lines
m &lt;- cbind( matrix( 1:24, ncol = 2 ), c(rep(1, 6), rep(2, 6) ) )
sfg_multilinestring( obj = m, x = 1, y = 2, linestring_id = 3 )

## just specifying linestring_id will use all others as the geometries
sfg_multilinestring( obj = m, linestring_id = 3 )

df &lt;- data.frame( x = 1:12, y = 1:12, z = 13:24, id = c(rep(1,6), rep(2,6)))
sfg_multilinestring( df, x = "x", y = "y" )
sfg_multilinestring( df, x = "x", y = "y", linestring_id = "id" )

sfg_multilinestring( df, linestring_id = "id" )


</code></pre>

<hr>
<h2 id='sfg_multipoint'>sfg multipoint</h2><span id='topic+sfg_multipoint'></span>

<h3>Description</h3>

<p>constructs sfg MULTIPOINT object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfg_multipoint(obj, x = NULL, y = NULL, z = NULL, m = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfg_multipoint_+3A_obj">obj</code></td>
<td>
<p>matrix or data.frame</p>
</td></tr>
<tr><td><code id="sfg_multipoint_+3A_x">x</code></td>
<td>
<p>x geometry column</p>
</td></tr>
<tr><td><code id="sfg_multipoint_+3A_y">y</code></td>
<td>
<p>y geometry column</p>
</td></tr>
<tr><td><code id="sfg_multipoint_+3A_z">z</code></td>
<td>
<p>z geometry column</p>
</td></tr>
<tr><td><code id="sfg_multipoint_+3A_m">m</code></td>
<td>
<p>m geometry column</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sfg</code> object of MULTIPOINT geometry
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sfg_multipoint( 1:2 )
sfg_multipoint( 1:3 )
sfg_multipoint( 1:4 )

sfg_multipoint( matrix( 1:3, ncol = 3 ) )
sfg_multipoint( data.frame( x = 1, y = 2, z = 3 )  )

sfg_multipoint( matrix( 1:4, ncol = 2 ) )
sfg_multipoint( matrix( 1:24, ncol = 2, byrow = TRUE ) )
sfg_multipoint( matrix( 1:24, ncol = 3, byrow = TRUE ) )
sfg_multipoint( matrix( 1:24, ncol = 4, byrow = TRUE ) )

sfg_multipoint( data.frame( x = 1:5, y = 1:5 ) )

## using columns

sfg_multipoint( matrix( 1:24, ncol = 4, byrow = TRUE ), x = 1, y = 2 )
sfg_multipoint( matrix( 1:24, ncol = 4, byrow = TRUE ), x = 1, y = 2, z = 3 )
sfg_multipoint( matrix( 1:24, ncol = 4, byrow = TRUE ), x = 3, y = 4 )

df &lt;- data.frame( x = 1:5, y = 1:5, z = 11:15, m = 11:15 )
sfg_multipoint( df, x = "x", y = "y" )
sfg_multipoint( df, x = "x", y = "y", z = "z" )
sfg_multipoint( df, x = "x", y = "y", z = "z", m = "m" )

</code></pre>

<hr>
<h2 id='sfg_multipolygon'>sfg multipolygon</h2><span id='topic+sfg_multipolygon'></span>

<h3>Description</h3>

<p>constructs sfg MULTIPOLYGON object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfg_multipolygon(
  obj,
  x = NULL,
  y = NULL,
  z = NULL,
  m = NULL,
  polygon_id = NULL,
  linestring_id = NULL,
  close = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfg_multipolygon_+3A_obj">obj</code></td>
<td>
<p>matrix or data.frame</p>
</td></tr>
<tr><td><code id="sfg_multipolygon_+3A_x">x</code></td>
<td>
<p>x geometry column</p>
</td></tr>
<tr><td><code id="sfg_multipolygon_+3A_y">y</code></td>
<td>
<p>y geometry column</p>
</td></tr>
<tr><td><code id="sfg_multipolygon_+3A_z">z</code></td>
<td>
<p>z geometry column</p>
</td></tr>
<tr><td><code id="sfg_multipolygon_+3A_m">m</code></td>
<td>
<p>m geometry column</p>
</td></tr>
<tr><td><code id="sfg_multipolygon_+3A_polygon_id">polygon_id</code></td>
<td>
<p>column of ids for polygons (within the multipolygon)</p>
</td></tr>
<tr><td><code id="sfg_multipolygon_+3A_linestring_id">linestring_id</code></td>
<td>
<p>column of ids for lines (within polygons)</p>
</td></tr>
<tr><td><code id="sfg_multipolygon_+3A_close">close</code></td>
<td>
<p>logical indicating whether polygons should be closed. If <code>TRUE</code>,
all polygons will be checked and force closed if possible</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sfg</code> object of MULTIPOLYGON geometry
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(
  polygon_id = c(rep(1, 5), rep(2, 10))
  , line_id = c(rep(1, 10), rep(2, 5))
  , x = c(0,0,1,1,0,2,2,5,5,2,3,3,4,4,3)
  , y = c(0,1,1,0,0,2,5,5,2,2,3,4,4,3,3)
  , z = c(1)
  , m = c(1)
)

m &lt;- as.matrix( df )

sfg_multipolygon( df[, c("x","y") ] )

sfg_multipolygon(
  df, x = "x", y = "y", polygon_id = "polygon_id", linestring_id = "line_id"
  )
sfg_multipolygon(
  df, x = "x", y = "y", z = "z", polygon_id = "polygon_id", linestring_id = "line_id"
  )
sfg_multipolygon(
  df, x = "x", y = "y", z = "z", m = "m", polygon_id = "polygon_id", linestring_id = "line_id"
  )


sfg_multipolygon( m[, c("x","y") ] )

sfg_multipolygon(
  m, x = "x", y = "y", polygon_id = "polygon_id", linestring_id = "line_id"
  )
sfg_multipolygon(
  m, x = "x", y = "y", z = "z", polygon_id = "polygon_id", linestring_id = "line_id"
  )
sfg_multipolygon(
  m, x = "x", y = "y", z = "z", m = "m", polygon_id = "polygon_id", linestring_id = "line_id"
  )

</code></pre>

<hr>
<h2 id='sfg_point'>sfg point</h2><span id='topic+sfg_point'></span>

<h3>Description</h3>

<p>constructs sfg POINT object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfg_point(obj, x = NULL, y = NULL, z = NULL, m = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfg_point_+3A_obj">obj</code></td>
<td>
<p>matrix or data.frame</p>
</td></tr>
<tr><td><code id="sfg_point_+3A_x">x</code></td>
<td>
<p>x geometry column</p>
</td></tr>
<tr><td><code id="sfg_point_+3A_y">y</code></td>
<td>
<p>y geometry column</p>
</td></tr>
<tr><td><code id="sfg_point_+3A_z">z</code></td>
<td>
<p>z geometry column</p>
</td></tr>
<tr><td><code id="sfg_point_+3A_m">m</code></td>
<td>
<p>m geometry column</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sfg</code> object of POINT geometry
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sfg_point( 1:2 )
sfg_point( 1:3 )
sfg_point( 1:4 )

sfg_point( matrix( 1:3, ncol = 3 ) )
sfg_point( data.frame( x = 1, y = 2, z = 3 )  )

sfg_point( data.frame( x = 1, y = 2, z = 3 ), x = "x", y = "y" )
sfg_point( data.frame( x = 1, y = 2, z = 3 ), x = 1, y = 3  )

</code></pre>

<hr>
<h2 id='sfg_polygon'>sfg polygon</h2><span id='topic+sfg_polygon'></span>

<h3>Description</h3>

<p>constructs sfg POLYGON object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfg_polygon(
  obj,
  x = NULL,
  y = NULL,
  z = NULL,
  m = NULL,
  linestring_id = NULL,
  close = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfg_polygon_+3A_obj">obj</code></td>
<td>
<p>matrix or data.frame</p>
</td></tr>
<tr><td><code id="sfg_polygon_+3A_x">x</code></td>
<td>
<p>x geometry column</p>
</td></tr>
<tr><td><code id="sfg_polygon_+3A_y">y</code></td>
<td>
<p>y geometry column</p>
</td></tr>
<tr><td><code id="sfg_polygon_+3A_z">z</code></td>
<td>
<p>z geometry column</p>
</td></tr>
<tr><td><code id="sfg_polygon_+3A_m">m</code></td>
<td>
<p>m geometry column</p>
</td></tr>
<tr><td><code id="sfg_polygon_+3A_linestring_id">linestring_id</code></td>
<td>
<p>column of ids for lines (within polygons)</p>
</td></tr>
<tr><td><code id="sfg_polygon_+3A_close">close</code></td>
<td>
<p>logical indicating whether polygons should be closed. If <code>TRUE</code>,
all polygons will be checked and force closed if possible</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sfg</code> object of POLYGON geometry
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sfg_polygon( matrix( 1:24, ncol = 2 ) )
sfg_polygon( matrix( 1:24, ncol = 3 ) )
sfg_polygon( matrix( 1:24, ncol = 4 ) )

## different lines
m &lt;- cbind( matrix( 1:24, ncol = 2 ), c(rep(1, 6), rep(2, 6) ) )
sfg_polygon( obj = m, x = 1, y = 2, linestring_id = 3 )

## just specifying linestring_id will use all others as the geometries
sfg_polygon( obj = m, linestring_id = 3 )

df &lt;- data.frame( x = 1:12, y = 1:12, z = 13:24, id = c(rep(1,6), rep(2,6)))
sfg_polygon( df, x = "x", y = "y" )
sfg_polygon( df, x = "x", y = "y", linestring_id = "id" )

sfg_polygon( df, linestring_id = "id" )


</code></pre>

<hr>
<h2 id='sfg_to_df'>sfg to df</h2><span id='topic+sfg_to_df'></span>

<h3>Description</h3>

<p>Converts an sfg object to a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfg_to_df(sfg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfg_to_df_+3A_sfg">sfg</code></td>
<td>
<p>sfg object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>sfg &lt;- sfg_point( obj = c(1,2) )
df &lt;- sfg_to_df( sfg )

m &lt;- cbind( matrix( 1:24, ncol = 2 ), c(rep(1, 6), rep(2, 6) ) )
sfg &lt;- sfg_polygon( obj = m, x = 1, y = 2, linestring_id = 3 )
df &lt;- sfg_to_df( sfg )


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
