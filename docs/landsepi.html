<!DOCTYPE html><html lang="en"><head><title>Help for package landsepi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {landsepi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#landsepi-package'><p>Landscape Epidemiology and Evolution</p></a></li>
<li><a href='#AgriLand'><p>Landscape allocation</p></a></li>
<li><a href='#allocateCroptypeCultivars'><p>Allocate cultivars to one croptype</p></a></li>
<li><a href='#allocateCultivarGenes'><p>Allocate genes to a cultivar</p></a></li>
<li><a href='#allocateLandscapeCroptypes'><p>Allocate croptypes to the landscape</p></a></li>
<li><a href='#antideriv_verhulst'><p>Antiderivative of the Verhulst logistic function</p></a></li>
<li><a href='#checkCroptypes'><p>Check croptypes</p></a></li>
<li><a href='#checkCultivars'><p>Check cultivars</p></a></li>
<li><a href='#checkCultivarsGenes'><p>Check cultivars genes</p></a></li>
<li><a href='#checkDispersalHost'><p>Check host dispersal</p></a></li>
<li><a href='#checkDispersalPathogen'><p>Check pathogen dispersal</p></a></li>
<li><a href='#checkGenes'><p>Check genes</p></a></li>
<li><a href='#checkInoculum'><p>Check inoculum</p></a></li>
<li><a href='#checkLandscape'><p>Check the landscape</p></a></li>
<li><a href='#checkOutputs'><p>Check outputs</p></a></li>
<li><a href='#checkPathogen'><p>Check pathogen</p></a></li>
<li><a href='#checkPI0_mat'><p>Check the array PI0_mat when entered manually in <code>loadInoculum()</code>.</p></a></li>
<li><a href='#checkSimulParams'><p>Check simulation parameters</p></a></li>
<li><a href='#checkTime'><p>Check time</p></a></li>
<li><a href='#checkTreatment'><p>Check treatment</p></a></li>
<li><a href='#compute_audpc100S'><p>Compute AUDPC in a single 100% susceptible field</p></a></li>
<li><a href='#createSimulParams'><p>Create a LandsepiParams object.</p></a></li>
<li><a href='#Cultivars_list'><p>Cultivars Type list</p></a></li>
<li><a href='#demo_landsepi'><p>Package demonstration</p></a></li>
<li><a href='#dispP'>
<p>Dispersal matrices for rust fungi of cereal crops.</p></a></li>
<li><a href='#epid_output'><p>Generation of epidemiological and economic model outputs</p></a></li>
<li><a href='#evol_output'><p>Generation of evolutionary model outputs</p></a></li>
<li><a href='#getMatrixCroptypePatho'><p>Get the &quot;croptype/pathogen genotype&quot; compatibility matrix.</p></a></li>
<li><a href='#getMatrixCultivarPatho'><p>Get the &quot;cultivar/pathogen genotype&quot; compatibility matrix.</p></a></li>
<li><a href='#getMatrixGenePatho'><p>Get the &quot;resistance gene/pathogen genotype&quot; compatibility matrix.</p></a></li>
<li><a href='#getMatrixPolyPatho'><p>Get the &quot;polygon/pathogen genotype&quot; compatibility matrix.</p></a></li>
<li><a href='#initialize+2CLandsepiParams-method'><p>LandsepiParams</p></a></li>
<li><a href='#inoculumToMatrix'><p>Inoculum To Matrix</p></a></li>
<li><a href='#invlogit'><p>Inverse logit function</p></a></li>
<li><a href='#is.in.01'><p>is.in.01</p></a></li>
<li><a href='#is.positive'><p>is.positive</p></a></li>
<li><a href='#is.strict.positive'><p>is.strict.positive</p></a></li>
<li><a href='#is.wholenumber'><p>is.wholenumber</p></a></li>
<li><a href='#landscapeTEST'>
<p>Landscapes</p></a></li>
<li><a href='#LandsepiParams'><p>Class LandsepiParams</p></a></li>
<li><a href='#loadCroptypes'><p>Load Croptypes</p></a></li>
<li><a href='#loadCultivar'><p>Load a cultivar</p></a></li>
<li><a href='#loadDispersalHost'><p>Load a host dispersal matrix</p></a></li>
<li><a href='#loadDispersalPathogen'><p>Load pathogen dispersal matrices</p></a></li>
<li><a href='#loadGene'><p>Load a gene</p></a></li>
<li><a href='#loadInoculum'><p>Load Inoculum</p></a></li>
<li><a href='#loadLandscape'><p>Load a landscape</p></a></li>
<li><a href='#loadOutputs'><p>Load outputs</p></a></li>
<li><a href='#loadPathogen'><p>Load pathogen parameters</p></a></li>
<li><a href='#loadSimulParams'><p>Load simulation parameters</p></a></li>
<li><a href='#loadTreatment'><p>Load treatment parameters</p></a></li>
<li><a href='#logit'><p>Logit function</p></a></li>
<li><a href='#model_landsepi'><p>Model for Landscape Epidemiology &amp; Evolution</p></a></li>
<li><a href='#multiN'><p>Allocation of cultivars</p></a></li>
<li><a href='#periodic_cov'><p>Periodic covariance function</p></a></li>
<li><a href='#plot_allocation'><p>Plotting allocation of croptypes in a landscape</p></a></li>
<li><a href='#plot_freqPatho'><p>Plotting pathotype frequencies</p></a></li>
<li><a href='#plotland'><p>Plotting the landscape</p></a></li>
<li><a href='#price_reduction'><p>Price reduction function</p></a></li>
<li><a href='#print'><p>print</p></a></li>
<li><a href='#resetCultivarsGenes'><p>Reset cultivars genes</p></a></li>
<li><a href='#runShinyApp'><p>runShinyApp</p></a></li>
<li><a href='#runSimul'><p>Run a simulation</p></a></li>
<li><a href='#saveDeploymentStrategy'><p>Save landscape and deployment strategy</p></a></li>
<li><a href='#setCroptypes'><p>Set croptypes</p></a></li>
<li><a href='#setCultivars'><p>Set cultivars</p></a></li>
<li><a href='#setDispersalHost'><p>Set host dispersal</p></a></li>
<li><a href='#setDispersalPathogen'><p>Set pathogen dispersal</p></a></li>
<li><a href='#setGenes'><p>Set genes</p></a></li>
<li><a href='#setInoculum'><p>Set inoculum</p></a></li>
<li><a href='#setLansdcape'><p>Set the landscape</p></a></li>
<li><a href='#setOutputs'><p>Set outputs</p></a></li>
<li><a href='#setPathogen'><p>Set the pathogen</p></a></li>
<li><a href='#setSeed'><p>Set the seed</p></a></li>
<li><a href='#setSeedValue'><p>setSeedValue</p></a></li>
<li><a href='#setTime'><p>Set time parameters</p></a></li>
<li><a href='#setTreatment'><p>Set chemical treatments</p></a></li>
<li><a href='#show'><p>show</p></a></li>
<li><a href='#simul_landsepi'><p>Simulation with input parameters as data.frames.</p></a></li>
<li><a href='#summary'><p>summary</p></a></li>
<li><a href='#survivalProbToMatrix'><p>Survival probability To Matrix</p></a></li>
<li><a href='#switch_patho_to_aggr'><p>Switch from index of genotype to indices of agressiveness on different components</p></a></li>
<li><a href='#updateReproSexProb'><p>Update the probability of sexual reproduction</p></a></li>
<li><a href='#updateSurvivalProb'><p>Update pathogen survival probability during the off-season</p></a></li>
<li><a href='#video'><p>Generation of a video</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Title:</td>
<td>Landscape Epidemiology and Evolution</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-23</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jean-François Rey &lt;jean-francois.rey@inrae.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A stochastic, spatially-explicit, demo-genetic model simulating the spread and evolution 
    of a plant pathogen in a heterogeneous landscape to assess resistance deployment strategies. 
    It is based on a spatial geometry for describing the landscape and allocation of different cultivars, 
    a dispersal kernel for the dissemination of the pathogen, and a SEIR 
    ('Susceptible-Exposed-Infectious-Removed’) structure with a discrete time step.
    It provides a useful tool to assess the performance of a wide range of deployment options with 
    respect to their epidemiological, evolutionary and economic outcomes.
    Loup Rimbaud, Julien Papaïx, Jean-François Rey, Luke G Barrett, 
    Peter H Thrall (2018) &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1006067">doi:10.1371/journal.pcbi.1006067</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://csiro-inra.pages.biosp.inrae.fr/landsepi/">https://csiro-inra.pages.biosp.inrae.fr/landsepi/</a>,
<a href="https://gitlab.paca.inrae.fr/CSIRO-INRA/landsepi">https://gitlab.paca.inrae.fr/CSIRO-INRA/landsepi</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.paca.inrae.fr/CSIRO-INRA/landsepi/-/issues">https://gitlab.paca.inrae.fr/CSIRO-INRA/landsepi/-/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE [expanded from: GPL (&ge; 2) | file LICENSE]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++, gsl</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0), sp (&ge; 1.0-17)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, utils, stats (&ge; 3.0.2), grDevices (&ge; 3.0.0),
graphics (&ge; 3.0.0), parallel, Rcpp (&ge; 0.9.0), Matrix (&ge;
1.3-0), mvtnorm, fields, splancs, sf, DBI, RSQLite, foreach,
doParallel, deSolve</td>
</tr>
<tr>
<td>Collate:</td>
<td>'Math-Functions.R' 'RcppExports.R' 'graphics.R' 'AgriLand.R'
'Class-LandsepiParams.R' 'Cultivars_List.R' 'GPKGTools.R'
'tools.R' 'Methods-LandsepiParams.R' 'demo_landsepi.R'
'landsepi-package.R' 'output.R' 'runShiny.R' 'simul_landsepi.R'</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), shiny, shinyjs, DT, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-23 11:47:36 UTC; root</td>
</tr>
<tr>
<td>Author:</td>
<td>Loup Rimbaud <a href="https://orcid.org/0000-0002-8098-9984"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Marta Zaffaroni <a href="https://orcid.org/0000-0002-2951-8626"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Jean-François Rey <a href="https://orcid.org/0000-0003-3281-6701"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Julien Papaix [aut],
  Jean-Loup Gaussen [ctb],
  Manon Couty [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-23 12:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='landsepi-package'>Landscape Epidemiology and Evolution</h2><span id='topic+landsepi-package'></span><span id='topic+landsepi'></span>

<h3>Description</h3>

<p>A stochastic, spatially-explicit, demo-genetic model simulating
the spread and evolution of a plant pathogen in a heterogeneous landscape to assess
resistance deployment strategies.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> landsepi</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.5.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-09-23</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The landsepi package implements a spatially explicit stochastic model able to assess the epidemiological,
evolutionary and economic outcomes of strategies to deploy plant resistance to pathogens.
It also helps investigate the effect of landscape organisation, the considered pathosystem and
the epidemio-evolutionary context on the performance of a given strategy.
</p>
<p>It is based on a spatial geometry for describing the landscape and allocation of different cultivars,
a dispersal kernel for the dissemination of the pathogen,
and a SEIR (‘susceptible-exposed-infectious-removed’, renamed HLIR for 'healthy-latent-infectious-removed'
to avoid confusions with 'susceptible host') structure with a discrete time step. It simulates the spread and
evolution (via mutation, recombination through sexual reproduction, selection and drift)
of a pathogen in a heterogeneous cropping landscape, across cropping seasons split by host harvests which impose
potential bottlenecks to the pathogen.
</p>
<p>The lansdcape is represented by a set of polygons where the pathogen can disperse
(the basic spatial unit is an individual polygon; an agricultural field may be composed of a single
or several polygons). <em>landsepi</em> includes built-in simulated landscapes
(and associated dispersal matrices for rust pathogens, see below), but is it possible
to use your own landscape (in shapefile format) and dispersal matrix.
</p>
<p>A wide array of resistance deployment strategies can be simulated in landsepi: fields of the
landscape are cultivated with different croptypes that can rotate through time; each croptype is
composed of either a pure cultivar or a mixture; and each cultivar may carry one or several resistance
genes. Thus, all combinations of rotations, mosaics, mixtures and pyramiding strategies are
possible. Resistance genes affect several possible pathogen aggressiveness components:
infection rate, durations of the latent period and the infectious period, and propagule
production rate. Resistance may be complete (i.e. complete inhibition of the targeted aggressiveness component) or partial
(i.e. the targeted aggressiveness component is only softened), and expressed from the beginning of the season, or later
(to simulate Adult Plant Resistance (APR), also called Mature Plant Resistance).
Cultivar allocation can be realised via an algorithm (<code>allocateCroptypeCultivars()</code>)
but it is possible to use your own cultivar allocation if it is included in the shapefile
containing the landsape.
Additionally, any cultivar may be treated with contact pesticides, which reduce the pathogen infection rate
with an efficiency gradually decreasing with time and host growth.
</p>
<p>To each resistance gene in the host (whether it may be a major gene or a QTL for quantitative resistance)
is associated a pathogenicity gene in the pathogen.
Through mutation of pathogenicity genes, the pathogen can restore its aggressiveness on resistance hosts and thus
adapt to resistance (leading to sudden breakdown or gradual erosion of resistance genes).
Pathogenicity genes may also be reassorted via sexual reproduction or gene recombination.
Increased aggressiveness on a resistant host (i.e. adaptation to the corresponding resistance genes)
can be penalised by a fitness cost, either on all hosts, or only on susceptible hosts (in the latter case,
pathogen genotypes adapted to a resistance gene have a reduced aggressiveness on hosts that do not carry this gene,
and a 'relative advantage' on host that do carry such gene).
The relation between pathogen aggressiveness on susceptible and resistant hosts
is defined by a trade-off relationship whose shape depends on the strength of the trade-off.
Strong trade-off means that the gain in fitness on resistant hosts is smaller than the cost on susceptible hosts.
</p>
<p>The package includes five examples of landscape structures and a default parameterisation to represent
plant pathogens as typified by rusts of cereal crops (genus <em>Puccinia</em>,
e.g. stripe rust, stem rust and leaf rust of wheat and barley). A parameterisation to
downy mildew of grapevine (<em>Plasmopara viticola</em>) and black sigatoka of banana
(<em>Pseudocercospora fijiensis</em>) are also available.
The main function of the package is <code>runSimul()</code>.
It can be parameterised to simulate various resistance deployment strategies using either the provided
landscapes and parameters for cereal rusts, or landscapes and parameters set by the user.
See <code>demo_landsepi()</code> for a demonstration, and our tutorials (<code>browseVignettes("landsepi")</code>)
for details on how to use landsepi.
</p>

<dl>
<dt><strong>Assumptions</strong> (in bold those that can be relaxed with appropriate parameterization): </dt><dd>

<ol>
<li><p> The spatial unit is a polygon, i.e. a piece of land delimited by boundaries and possibly
cultivated with a crop. Such crop may be host or non-host, and the polygon is considered a homogeneous
mixture of host individuals (i.e. there is no intra-polygon structuration).
An agricultural field may be composed of a single or several polygons.
</p>
</li>
<li><p> A host ‘individual’ is an infection unit (i.e. it can be infected by one and only one
pathogen propagule, there is no co-infection) and may correspond to <strong>a given amount of plant tissue
(where a local infection may develop, e.g. fungal lesion) or a whole plant (e.g. systemic viral infection).
In the first case, plant growth increases the amount of available plant tissue
(hence the number of individuals) during the cropping season.</strong> Plant growth is deterministic (logistic growth)
and <strong>only healthy individuals (state H) contribute to plant growth (castrating pathogen)</strong>.
</p>
</li>
<li><p> Host individuals are in one of these four categories: H (healthy), E (exposed and latent,
i.e. infected but not infectious nor symptomatic), I (infectious and symptomatic), or R
(removed, i.e. epidemiologically inactive).
</p>
</li>
<li> <p><strong>The decreasing availability of healthy host tissues (as epidemics spread) makes pathogen
infection less likely (i.e. density-dependence due to plant architecture).</strong>
</p>
</li>
<li> <p><strong>Hosts are cultivated (i.e. sown/planted and harvested), thus there is no host reproduction,
dispersal and natural death.</strong>
</p>
</li>
<li><p> Environmental and climate conditions are constant, and host individuals of a given genotype
are equally susceptible to disease from the first to the last day of every cropping season.
</p>
</li>
<li><p> Crop yield depends on the average amount of producing host individuals during the cropping
season and does not depend on the time of epidemic peak. <strong>Only healthy individuals (state H)
contribute to crop yield.</strong>
</p>
</li>
<li><p> Cultivars may be treated with chemicals which reduce the pathogen infection rate (contact treatment).
Treatment efficiency decreases with host growth (i.e. new biomass is not protected by treatments)
<strong>and time (i.e. pesticide degradation)</strong>. Cultivars to be treated and dates of chemical applications
are fixed prior to simulations but only polygons where disease severity exceeds a given threshold (possibly 0) are treated.
</p>
</li>
<li><p> Components of a mixture are independent each other (i.e. there is neither plant-plant
interaction nor competition for space, and harvests are segregated). If one component is treated
with a chemical, it does not affect other components.
</p>
</li>
<li><p> The pathogen is haploid.
</p>
</li>
<li> <p><strong>Initially, the pathogen is not adapted to any source of resistance, and is only present on
susceptible hosts (at state I).</strong>
</p>
</li>
<li> <p><strong>Pathogen dispersal is isotropic (i.e. equally probable in every direction).</strong>
</p>
</li>
<li> <p><strong>Boundaries of the landscape are reflective: propagules stay in the system as if it was closed.</strong>
</p>
</li>
<li><p> Pathogen reproduction can be purely clonal, purely sexual, or mixed (alternation of clonal
and sexual reproduction).
</p>
</li>
<li><p> If there is sexual reproduction (or gene recombination), it occurs only between parental
infections located in the same polygon and the same host genotype (i.e. cultivar).
At that scale, the pathogen population is panmictic (i.e. all pairs of parents have the
same probability to occur).
The propagule production rate of a parental pair is the sum of the propagule production rates of
the parents. For a given parental pair, the genotype of each propagule is issued from random loci
segregation of parental qualitative resistance genes. For each quantitative resistance gene, the
value of each propagule trait is issued from a normal distribution around the average of the
parental traits, following the infinitesimal model (Fisher 1919).
</p>
</li>
<li><p> All types of propagules (i.e. clonal and sexual) share the same pathogenicity parameters
(e.g. infection rate, latent period duration, etc.) but each of them has their own dispersal and survival
abilities (see after).
</p>
</li>
<li><p> At the end of each cropping season, pathogens experience a bottleneck representing the
off-season and then propagules are produced (either via clonal or sexual reproduction).
<strong>The probability of survival is the same every year and in every polygon.</strong>
Clonal propagules are released during the following season only, either altogether at the first day of
the season, or progressively (in that case the day of release of each propagule is sampled from
a uniform distribution). Sexual propagules are gradually released during several of the following
seasons (between-season release). The season of release of each propagule is sampled from an
exponential distribution, truncated by a maximum viability limit. Then, the day of release in a
given season is sampled from a uniform distribution (within-season release).
</p>
</li>
<li><p> Pathogenicity genes mutate independently from each other.
</p>
</li>
<li> <p><strong>Pathogen adaptation to a given resistance gene consists in restoring the same aggressiveness
component as the one targeted by the resistance gene.</strong>
</p>
</li>
<li><p> If a fitness cost penalises pathogen adaptation to a given resistance gene, this cost is paid
on all hosts with possibly a relative advantage on hosts carrying the resistance gene.
It consists in a reduction in the same aggressiveness
component as the one targeted by the resistance gene.
</p>
</li>
<li><p> When there is a delay for activation of a given resistance gene (APR), the age of activation
is the same for all hosts carrying this gene and located in the same polygon.
</p>
</li>
<li><p> Variances of the durations of the latent and the infectious periods of the pathogen are
not affected by plant resistance.
</p>
</li></ol>

</dd>
<dt><strong>Epidemiological outputs</strong></dt><dd>
<p>The epidemiological outcome of a deployment strategy is evaluated using: </p>

<ol>
<li><p> the area under the disease progress curve (AUDPC) to measure disease severity
(i.e. the average number of diseased plant tissue -status I and R- per time step and square meter),
</p>
</li>
<li><p> the relative area under the disease progress curve (AUDPCr) to measure the average proportion
of diseased tissue (status I and R) relative to the total number of existing host individuals (H+L+I+R).
</p>
</li>
<li><p> the Green Leaf Area (GLA) to measure the average amount of healthy plant tissue (status H) per time step and square meter,
</p>
</li>
<li><p> the relative Green Leaf Area (GLAr) to measure the average proportion of healthy tissue (status H)
relative to the total number of existing host individuals (H+L+I+R).
</p>
</li>
<li><p> the yearly contribution of pathogen genotypes to LIR dynamics on every host as well as the whole landscape.
</p>
</li></ol>

<p>A set of graphics and a video showing epidemic dynamics can also be generated.
</p>
</dd>
<dt><strong>Evolutionary outputs</strong></dt><dd>
<p>The evolutionary outcome is assessed by measuring: </p>

<ol>
<li><p> the dynamics of pathogen genotype frequencies,
</p>
</li>
<li><p> the evolution of pathogen aggressiveness,
</p>
</li>
<li><p> the durability of resistance genes. Durability can be estimated using the time until the pathogen reaches the three
steps to adapt to plant resistance: (1) first appearance of adapted mutants,
(2) initial migration to resistant hosts and infection, and
(3) broader establishment in the resistant host population (i.e. the point at which extinction becomes unlikely).
</p>
</li></ol>

</dd>
<dt><strong>Economic outputs</strong></dt><dd>
<p>The economic outcome of a simulation can be evaluated using: </p>

<ol>
<li><p> the crop yield: yearly crop production (e.g. grains, fruits, wine) in weight (or volume) units
per hectare (depends on the number of productive hosts and associated theoretical yield),
</p>
</li>
<li><p> the crop products: yearly products generated from sales, in monetary units per hectare
(depends on crop yield and market value),
</p>
</li>
<li><p> the crop operational costs: yearly costs associated with crop planting (depends on initial
host density and planting cost) and pesticide treatments (depends on the number of applications and
the cost of a single application) in monetary units per hectare.
</p>
</li>
<li><p> the margin, i.e. products - operational costs, in monetary units per hectare.
</p>
</li></ol>

</dd>
</dl>

<p><strong>Future versions:</strong>
</p>
<p>Future versions of the package will include in particular:</p>

<ul>
<li><p> Sets of pathogen parameters to simulate other pathosystems (e.g. Cucumber mosaic virus on pepper, potato virus Y on pepper).
</p>
</li>
<li><p> An updated version of the shiny interface.
</p>
</li></ul>

<p><strong>Dependencies:</strong>
</p>
<p>The package for compiling needs:</p>

<ul>
<li><p> g++
</p>
</li>
<li><p> libgsl2
</p>
</li>
<li><p> libgsl-dev</p>
</li></ul>

<p>and the following R packages:</p>

<ul>
<li><p> Rcpp
</p>
</li>
<li><p> sp
</p>
</li>
<li><p> stats
</p>
</li>
<li><p> Matrix
</p>
</li>
<li><p> mvtnorm
</p>
</li>
<li><p> fields
</p>
</li>
<li><p> splancs
</p>
</li>
<li><p> sf
</p>
</li>
<li><p> DBI
</p>
</li>
<li><p> RSQLite
</p>
</li>
<li><p> foreach
</p>
</li>
<li><p> parallel
</p>
</li>
<li><p> doParallel
</p>
</li>
<li><p> deSolve</p>
</li></ul>

<p>In addition, to generate videos the package will need ffmpeg.
</p>


<h3>Author(s)</h3>

<p>Loup Rimbaud <a href="mailto:loup.rimbaud@inrae.fr">loup.rimbaud@inrae.fr</a>
</p>
<p>Marta Zaffaroni <a href="mailto:marta.zaffaroni@inrae.fr">marta.zaffaroni@inrae.fr</a>
</p>
<p>Jean-Francois Rey <a href="mailto:jean-francois.rey@inrae.fr">jean-francois.rey@inrae.fr</a>
</p>
<p>Julien Papaix <a href="mailto:julien.papaix@inrae.fr">julien.papaix@inrae.fr</a>
</p>
<p>Jean-Loup Gaussen <a href="mailto:jean-loup-thomas.gaussen@inrae.fr">jean-loup-thomas.gaussen@inrae.fr</a>
</p>
<p>Manon Couty <a href="mailto:manon.couty@insa-lyon.fr">manon.couty@insa-lyon.fr</a>
</p>
<p>Maintainer: Jean-Francois Rey <a href="mailto:jean-francois.rey@inrae.fr">jean-francois.rey@inrae.fr</a>
</p>


<h3>References</h3>



<h4>When referencing the simulation model, please cite the following article:</h4>

<p>Rimbaud L., Papaïx J., Rey J.-F., Barrett L. G. and Thrall P. H. (2018). Assessing the durability and efficiency of
landscape-based strategies to deploy plant resistance to pathogens. <em>PLoS Computational Biology</em> 14(4):e1006067.
</p>



<h4>When referencing the R package, please cite the following package:</h4>

<p>Rimbaud L., Papaïx J. and Rey J.-F. (2018). landsepi: Landscape Epidemiology and Evolution. <em>R package</em>,
url: https://cran.r-project.org/package=landsepi.
</p>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://csiro-inra.pages.biosp.inrae.fr/landsepi/">https://csiro-inra.pages.biosp.inrae.fr/landsepi/</a>
</p>
</li>
<li> <p><a href="https://gitlab.paca.inrae.fr/CSIRO-INRA/landsepi">https://gitlab.paca.inrae.fr/CSIRO-INRA/landsepi</a>
</p>
</li>
<li><p> Report bugs at <a href="https://gitlab.paca.inrae.fr/CSIRO-INRA/landsepi/-/issues">https://gitlab.paca.inrae.fr/CSIRO-INRA/landsepi/-/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("landsepi")

## Run demonstrations (in 10-year simulations) for different deployment strategies:
demo_landsepi(strat = "MO") ## for a mosaic of cultivars
demo_landsepi(strat = "MI") ## for a mixture of cultivars
demo_landsepi(strat = "RO") ## for a rotation of cultivars
demo_landsepi(strat = "PY") ## for a pyramid of resistance genes

## End(Not run)
</code></pre>

<hr>
<h2 id='AgriLand'>Landscape allocation</h2><span id='topic+AgriLand'></span>

<h3>Description</h3>

<p>Generates a landscape composed of fields where croptypes
are allocated with controlled proportions and spatio-temporal aggregation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AgriLand(
  landscape,
  Nyears,
  rotation_period = 0,
  rotation_sequence = list(c(0, 1, 2)),
  rotation_realloc = FALSE,
  prop = list(c(1/3, 1/3, 1/3)),
  aggreg = list(1),
  algo = "periodic",
  croptype_names = c(),
  graphic = FALSE,
  outputDir = "./"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AgriLand_+3A_landscape">landscape</code></td>
<td>
<p>a spatialpolygon object containing field coordinates.</p>
</td></tr>
<tr><td><code id="AgriLand_+3A_nyears">Nyears</code></td>
<td>
<p>an integer giving the number of simulated cropping seasons.</p>
</td></tr>
<tr><td><code id="AgriLand_+3A_rotation_period">rotation_period</code></td>
<td>
<p>number of years before rotation of the landscape. There is no rotation if rotation_period=0 or rotation_period=Nyears.</p>
</td></tr>
<tr><td><code id="AgriLand_+3A_rotation_sequence">rotation_sequence</code></td>
<td>
<p>a list, each element of the list contains indices of croptypes that are cultivated during a period given by &quot;rotation_period&quot;.
There is no change in cultivated croptypes if the list contains only one element (e.g. only one vector c(0,1,2), indicating cultivation of
croptypes 0, 1 and 2).</p>
</td></tr>
<tr><td><code id="AgriLand_+3A_rotation_realloc">rotation_realloc</code></td>
<td>
<p>a logical indicating if a new random allocation of croptypes is performed when the landscape is rotated
(FALSE=static allocation, TRUE=dynamic allocation). Note that if rotation_realloc=FALSE, all elements of the list &quot;rotation_sequence&quot;
must have the same length, and only the first element of the lists &quot;prop&quot; and &quot;aggreg&quot; will be used.</p>
</td></tr>
<tr><td><code id="AgriLand_+3A_prop">prop</code></td>
<td>
<p>a list of the same size as &quot;rotation_sequence&quot;, each element of the list contains a vector of the proportions (in surface)
associated with the croptypes in &quot;rotation_sequence&quot;. A single vector can be given instead of a list if all elements of
&quot;rotation_sequence&quot; are associated with the same proportions.</p>
</td></tr>
<tr><td><code id="AgriLand_+3A_aggreg">aggreg</code></td>
<td>
<p>a list of the same size as &quot;rotation_sequence&quot;, each element of the list is a single double indicating the degree of
aggregation of the landscape. This double must greater or equal 0; the greater its value, the higher the degree of
spatial aggregation (roughly, aggreg between 0 and 0.1 for fragmented landscapes, between 0.1 and 0.5 for balanced
landscapes, between 0.5 and 3 for aggregated landscapes, and above 3 for highly aggregated landscapes).
A single double can be given instead of a list if all elements of
&quot;rotation_sequence&quot; are associated with the same level of aggregation.</p>
</td></tr>
<tr><td><code id="AgriLand_+3A_algo">algo</code></td>
<td>
<p>the algorithm used for the computation of the variance-covariance matrix of the multivariate
normal distribution: &quot;exp&quot; for exponential function, &quot;periodic&quot; for periodic function,
&quot;random&quot; for random draw (see details of function multiN). If algo=&quot;random&quot;, the parameter aggreg is not used.
Algorithm &quot;exp&quot; is preferable for big landscapes.</p>
</td></tr>
<tr><td><code id="AgriLand_+3A_croptype_names">croptype_names</code></td>
<td>
<p>a vector of croptype names (for legend in graphic).</p>
</td></tr>
<tr><td><code id="AgriLand_+3A_graphic">graphic</code></td>
<td>
<p>a logical indicating if a graphic of the landscape must be generated (TRUE) or not (FALSE).</p>
</td></tr>
<tr><td><code id="AgriLand_+3A_outputdir">outputDir</code></td>
<td>
<p>a directory to save graphic</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An algorithm based on latent Gaussian fields is used to allocate two different croptypes
across the simulated landscapes (e.g. a susceptible and a resistant cultivar, denoted as
SC and RC, respectively). This algorithm allows the control of the proportions of each croptype
in terms of surface coverage, and their level of spatial aggregation.
A random vector of values is drawn from a multivariate normal distribution with expectation 0
and a variance-covariance matrix which depends on the pairwise distances between
the centroids of the fields. Next, the croptypes are allocated to different fields
depending on whether each value drawn from the multivariate normal distribution is above
or below a threshold. The proportion of each cultivar in the landscape is controlled by the value
of this threshold. To allocate more than two croptypes, <code>AgriLand</code> uses sequentially
this algorithm. For instance, the allocation of three croptypes (e.g. SC, RC1 and RC2)
is performed as follows:
</p>

<ol>
<li><p> the allocation algorithm is run once to segregate the fields where the susceptible
cultivar is grown, and
</p>
</li>
<li><p> the two resistant cultivars (RC1 and RC2) are assigned to the remaining candidate
fields by re-running the allocation algorithm.
</p>
</li></ol>



<h3>Value</h3>

<p>a gpkg (shapefile) containing the landscape structure (i.e. coordinates of field boundaries),
the area and composition (i.e. croptypes) in time (i.e. each year) for each field. A png graphic can be generated if graphic=TRUE.
</p>


<h3>References</h3>

<p>Rimbaud L., Papaïx J., Rey J.-F., Barrett L. G. and Thrall P. H. (2018). Assessing the durability and efficiency of landscape-based strategies to deploy plant resistance to pathogens. <em>PLoS Computational Biology</em> 14(4):e1006067.
</p>


<h3>See Also</h3>

<p><a href="#topic+multiN">multiN</a>, <a href="#topic+periodic_cov">periodic_cov</a>, <a href="#topic+allocateLandscapeCroptypes">allocateLandscapeCroptypes</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(landscapeTEST)
landscape &lt;- get("landscapeTEST1")
set.seed(12345)
## Generate a mosaic of three croptypes in balanced proportions
## and high level of spatial aggregation
AgriLand(landscape,
  Nyears = 10,
  rotation_sequence = c(0, 1, 2), prop = rep(1 / 3, 3),
  aggreg = rep(10, 3), algo = "periodic",
  graphic = TRUE, outputDir = getwd()
)

## Generate a dynamic mosaic of two croptypes in unbalanced proportions
## and low level of spatial aggregation,
## the second croptype being replaced every 5 years without changing field allocation
AgriLand(landscape,
  Nyears = 20, rotation_period = 5, rotation_sequence = list(c(0, 1), c(0, 2)),
  prop = c(1 / 3, 2 / 3), aggreg = c(0.07, 0.07), algo = "periodic", graphic = TRUE,
  outputDir = getwd()
)

## Generate a dynamic mosaic of four croptypes in balanced proportions
## and medium level of spatial aggregation,
## with field allocation changing every year
AgriLand(landscape,
  Nyears = 5, rotation_period = 1, rotation_realloc = TRUE,
  rotation_sequence = c(0, 1, 2, 3),
  prop = rep(1 / 4, 4), aggreg = 0.25, algo = "exp", graphic = TRUE, outputDir = getwd()
)

## End(Not run)
</code></pre>

<hr>
<h2 id='allocateCroptypeCultivars'>Allocate cultivars to one croptype</h2><span id='topic+allocateCroptypeCultivars'></span>

<h3>Description</h3>

<p>Updates a given croptype by allocating cultivars composing it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allocateCroptypeCultivars(
  croptypes,
  croptypeName,
  cultivarsInCroptype,
  prop = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allocateCroptypeCultivars_+3A_croptypes">croptypes</code></td>
<td>
<p>a dataframe containing all croptypes, initialised via
<code><a href="#topic+loadCroptypes">loadCroptypes</a></code></p>
</td></tr>
<tr><td><code id="allocateCroptypeCultivars_+3A_croptypename">croptypeName</code></td>
<td>
<p>the name of the croptype to be allocated</p>
</td></tr>
<tr><td><code id="allocateCroptypeCultivars_+3A_cultivarsincroptype">cultivarsInCroptype</code></td>
<td>
<p>name of cultivars composing the croptype</p>
</td></tr>
<tr><td><code id="allocateCroptypeCultivars_+3A_prop">prop</code></td>
<td>
<p>vector of proportions of each cultivar in the croptype. Default to
balanced proportions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a croptype data.frame updated for the concerned croptype.
</p>


<h3>See Also</h3>

<p><a href="#topic+setCroptypes">setCroptypes</a>, <a href="#topic+setCultivars">setCultivars</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simul_params &lt;- createSimulParams()
cultivar1 &lt;- loadCultivar(name = "Susceptible", type = "wheat")
cultivar2 &lt;- loadCultivar(name = "Resistant1", type = "wheat")
cultivar3 &lt;- loadCultivar(name = "Resistant2", type = "wheat")
cultivars &lt;- data.frame(rbind(cultivar1, cultivar2, cultivar3), stringsAsFactors = FALSE)
simul_params &lt;- setCultivars(simul_params, cultivars)
croptypes &lt;- loadCroptypes(simul_params, names = c("Susceptible crop", "Mixture"))
croptypes
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Susceptible crop", "Susceptible")
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Mixture", c("Resistant1", "Resistant2"))
croptypes

## End(Not run)
</code></pre>

<hr>
<h2 id='allocateCultivarGenes'>Allocate genes to a cultivar</h2><span id='topic+allocateCultivarGenes'></span>

<h3>Description</h3>

<p>Updates a LandsepiParams object with, for a given cultivar, the list of genes
it carries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allocateCultivarGenes(
  params,
  cultivarName,
  listGenesNames = c(""),
  force.clean = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allocateCultivarGenes_+3A_params">params</code></td>
<td>
<p>a LandsepiParams object.</p>
</td></tr>
<tr><td><code id="allocateCultivarGenes_+3A_cultivarname">cultivarName</code></td>
<td>
<p>the name of the cultivar to be allocated.</p>
</td></tr>
<tr><td><code id="allocateCultivarGenes_+3A_listgenesnames">listGenesNames</code></td>
<td>
<p>the names of the genes the cultivar carries</p>
</td></tr>
<tr><td><code id="allocateCultivarGenes_+3A_force.clean">force.clean</code></td>
<td>
<p>force to clean previous allocated genes to all cultivars</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a LandsepiParams object
</p>


<h3>See Also</h3>

<p><a href="#topic+setGenes">setGenes</a>, <a href="#topic+setCultivars">setCultivars</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simul_params &lt;- createSimulParams()
gene1 &lt;- loadGene(name = "MG 1", type = "majorGene")
gene2 &lt;- loadGene(name = "MG 2", type = "majorGene")
genes &lt;- data.frame(rbind(gene1, gene2), stringsAsFactors = FALSE)
simul_params &lt;- setGenes(simul_params, genes)
cultivar1 &lt;- loadCultivar(name = "Susceptible", type = "wheat")
cultivar2 &lt;- loadCultivar(name = "Resistant", type = "wheat")
cultivars &lt;- data.frame(rbind(cultivar1, cultivar2), stringsAsFactors = FALSE)
simul_params &lt;- setCultivars(simul_params, cultivars)
simul_params &lt;- allocateCultivarGenes(simul_params, "Resistant", c("MG 1", "MG 2"))
simul_params@CultivarsGenes

## End(Not run)
</code></pre>

<hr>
<h2 id='allocateLandscapeCroptypes'>Allocate croptypes to the landscape</h2><span id='topic+allocateLandscapeCroptypes'></span>

<h3>Description</h3>

<p>Updates the landscape of a LandsepiParams object with croptype allocation in
every polygon of the landscape and every year of simulation. Allocation is based on an algorithm
which controls croptype proportions (in surface) and spatio-temporal aggregation.
Note that time, landscape and croptype parameters must be set before allocating
landscape croptypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allocateLandscapeCroptypes(
  params,
  rotation_period,
  rotation_sequence,
  rotation_realloc = FALSE,
  prop,
  aggreg,
  algo = "periodic",
  graphic = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allocateLandscapeCroptypes_+3A_params">params</code></td>
<td>
<p>a LandsepiParams Object.</p>
</td></tr>
<tr><td><code id="allocateLandscapeCroptypes_+3A_rotation_period">rotation_period</code></td>
<td>
<p>number of years before rotation of the landscape. There is no rotation
if rotation_period=0 or rotation_period=Nyears.</p>
</td></tr>
<tr><td><code id="allocateLandscapeCroptypes_+3A_rotation_sequence">rotation_sequence</code></td>
<td>
<p>a list, each element of the list contains indices of croptypes that
are cultivated during a period given by &quot;rotation_period&quot;. There is no change in cultivated
croptypes if the list contains only one element (e.g. only one vector c(0,1,2), indicating
cultivation of croptypes 0, 1 and 2).</p>
</td></tr>
<tr><td><code id="allocateLandscapeCroptypes_+3A_rotation_realloc">rotation_realloc</code></td>
<td>
<p>a logical indicating if a new random allocation of croptypes is
performed when the landscape is rotated (FALSE=static allocation, TRUE=dynamic allocation).
Note that if rotation_realloc=FALSE, all elements of the list &quot;rotation_sequence&quot; must have
the same length, and only the first element of the lists &quot;prop&quot; and &quot;aggreg&quot; will be used.</p>
</td></tr>
<tr><td><code id="allocateLandscapeCroptypes_+3A_prop">prop</code></td>
<td>
<p>a list of the same size as &quot;rotation_sequence&quot;, each element of the list contains
a vector of the proportions (in surface) associated with the croptypes in &quot;rotation_sequence&quot;.
A single vector can be given instead of a list if all elements of &quot;rotation_sequence&quot; are
associated with the same proportions.</p>
</td></tr>
<tr><td><code id="allocateLandscapeCroptypes_+3A_aggreg">aggreg</code></td>
<td>
<p>a list of the same size as &quot;rotation_sequence&quot;, each element of the list is a
single double indicating the degree of
aggregation of the landscape. This double must greater or equal 0; the greater its value,
the higher the degree of spatial aggregation (roughly, aggreg between 0 and 0.1 for fragmented
landscapes, between 0.1 and 0.5 for balanced landscapes, between 0.5 and 3 for aggregated
landscapes, and above 3 for highly aggregated landscapes). A single double can be given
instead of a list if all elements of &quot;rotation_sequence&quot; are associated with the same level
of aggregation.</p>
</td></tr>
<tr><td><code id="allocateLandscapeCroptypes_+3A_algo">algo</code></td>
<td>
<p>the algorithm used for the computation of the variance-covariance matrix
of the multivariate normal distribution: &quot;exp&quot; for exponential function, &quot;periodic&quot;
for periodic function, &quot;random&quot; for random draw (see details of function multiN).
If algo=&quot;random&quot;, the parameter aggreg is not used.
Algorithm &quot;exp&quot; is preferable for big landscapes.</p>
</td></tr>
<tr><td><code id="allocateLandscapeCroptypes_+3A_graphic">graphic</code></td>
<td>
<p>a logical indicating if graphics must be generated (TRUE) or not (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An algorithm based on latent Gaussian fields is used to allocate two different
croptypes across the simulated landscapes (e.g. a susceptible and a resistant cultivar,
denoted as SC and RC, respectively). This algorithm allows the control of the proportions of
each croptype in terms of surface coverage, and their level of spatial aggregation.
A random vector of values is drawn from a multivariate normal distribution with expectation 0
and a variance-covariance matrix which depends on the pairwise distances between
the centroids of the polygons. Next, the croptypes are allocated to different polygons
depending on whether each value drawn from the multivariate normal distribution is above
or below a threshold. The proportion of each cultivar in the landscape is controlled by
the value of this threshold. To allocate more than two croptypes, <code>AgriLand</code> uses
sequentially this algorithm. For instance, the allocation of three croptypes
(e.g. SC, RC1 and RC2) is performed as follows:
</p>

<ol>
<li><p> the allocation algorithm is run once to segregate the polygons where the susceptible
cultivar is grown, and
</p>
</li>
<li><p> the two resistant cultivars (RC1 and RC2) are assigned to the remaining candidate
polygons by re-running the allocation algorithm.
</p>
</li></ol>



<h3>Value</h3>

<p>a LandsepiParams object with Landscape updated with the layer &quot;croptypeID&quot;.
It contains croptype allocation in every polygon of the landscape for all years of simulation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Initialisation
simul_params &lt;- createSimulParams(outputDir = getwd())
## Time parameters
simul_params &lt;- setTime(simul_params, Nyears = 10, nTSpY = 120)
## Landscape
simul_params &lt;- setLandscape(simul_params, loadLandscape(1))
## Cultivars
cultivar1 &lt;- loadCultivar(name = "Susceptible", type = "wheat")
cultivar2 &lt;- loadCultivar(name = "Resistant1", type = "wheat")
cultivar3 &lt;- loadCultivar(name = "Resistant2", type = "wheat")
cultivars &lt;- data.frame(rbind(cultivar1, cultivar2, cultivar3), stringsAsFactors = FALSE)
simul_params &lt;- setCultivars(simul_params, cultivars)
## Allocate cultivars to croptypes
croptypes &lt;- loadCroptypes(simul_params, names = c("Susceptible crop"
, "Resistant crop 1"
, "Resistant crop 2"))
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Susceptible crop", "Susceptible")
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Resistant crop 1", "Resistant1")
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Resistant crop 2", "Resistant2")
simul_params &lt;- setCroptypes(simul_params, croptypes)
## Allocate croptypes to landscape        
rotation_sequence &lt;- croptypes$croptypeID ## No rotation -&gt; 1 rotation_sequence element
rotation_period &lt;- 0 ## same croptypes every years
prop &lt;- c(1 / 3, 1 / 3, 1 / 3) ## croptypes proportions
aggreg &lt;- 10 ## aggregated landscape
simul_params &lt;- allocateLandscapeCroptypes(simul_params, rotation_period = rotation_period,
rotation_sequence = rotation_sequence,
rotation_realloc = FALSE, prop = prop, aggreg = aggreg)
simul_params@Landscape

## End(Not run)
</code></pre>

<hr>
<h2 id='antideriv_verhulst'>Antiderivative of the Verhulst logistic function</h2><span id='topic+antideriv_verhulst'></span>

<h3>Description</h3>

<p>Give the antiderivative of the logistic function from the Verhulst model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>antideriv_verhulst(x, initial_density, max_density, growth_rate)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="antideriv_verhulst_+3A_x">x</code></td>
<td>
<p>timestep up to which antiderivative must be computed</p>
</td></tr>
<tr><td><code id="antideriv_verhulst_+3A_initial_density">initial_density</code></td>
<td>
<p>initial density</p>
</td></tr>
<tr><td><code id="antideriv_verhulst_+3A_max_density">max_density</code></td>
<td>
<p>maximal density</p>
</td></tr>
<tr><td><code id="antideriv_verhulst_+3A_growth_rate">growth_rate</code></td>
<td>
<p>growth rate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Verhulst model (used to simulate host growth) is defined by
<code class="reqn"> f(x) = max\_{density} / (1 + (max\_{density}/initial\_{density})*exp(-growth\_{rate}*x)) </code>.
See https://en.wikipedia.org/wiki/Logistic_function for details.
</p>


<h3>Value</h3>

<p>An object of the same type as x containing the antiderivative of the input values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>antideriv_verhulst(119, 0.1, 2, 0.1) / 120
</code></pre>

<hr>
<h2 id='checkCroptypes'>Check croptypes</h2><span id='topic+checkCroptypes'></span>

<h3>Description</h3>

<p>checks croptypes validity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkCroptypes(params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkCroptypes_+3A_params">params</code></td>
<td>
<p>a LandsepiParams object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean, TRUE if OK, FALSE otherwise
</p>

<hr>
<h2 id='checkCultivars'>Check cultivars</h2><span id='topic+checkCultivars'></span>

<h3>Description</h3>

<p>check cultivars validity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkCultivars(params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkCultivars_+3A_params">params</code></td>
<td>
<p>a LandsepiParams object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean, TRUE if OK, FALSE otherwise
</p>

<hr>
<h2 id='checkCultivarsGenes'>Check cultivars genes</h2><span id='topic+checkCultivarsGenes'></span>

<h3>Description</h3>

<p>Checks CultivarsGene data.frame validity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkCultivarsGenes(params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkCultivarsGenes_+3A_params">params</code></td>
<td>
<p>a LandsepiParams object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean, TRUE if OK, FALSE otherwise
</p>

<hr>
<h2 id='checkDispersalHost'>Check host dispersal</h2><span id='topic+checkDispersalHost'></span>

<h3>Description</h3>

<p>Checks host dispersal matrix validity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkDispersalHost(params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkDispersalHost_+3A_params">params</code></td>
<td>
<p>a LandsepiParams Object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean TRUE if OK, FALSE otherwise
</p>

<hr>
<h2 id='checkDispersalPathogen'>Check pathogen dispersal</h2><span id='topic+checkDispersalPathogen'></span>

<h3>Description</h3>

<p>Checks pathogen dispersal validity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkDispersalPathogen(params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkDispersalPathogen_+3A_params">params</code></td>
<td>
<p>a LandsepiParams Object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean TRUE if OK, FALSE otherwise
</p>

<hr>
<h2 id='checkGenes'>Check genes</h2><span id='topic+checkGenes'></span>

<h3>Description</h3>

<p>checks Genes data.frame validity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkGenes(params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkGenes_+3A_params">params</code></td>
<td>
<p>a LandsepiParams object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean, TRUE if OK, FALSE otherwise
</p>

<hr>
<h2 id='checkInoculum'>Check inoculum</h2><span id='topic+checkInoculum'></span>

<h3>Description</h3>

<p>Checks inoculum validity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkInoculum(params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkInoculum_+3A_params">params</code></td>
<td>
<p>a LandsepiParams object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean, TRUE if OK, FALSE otherwise
</p>

<hr>
<h2 id='checkLandscape'>Check the landscape</h2><span id='topic+checkLandscape'></span>

<h3>Description</h3>

<p>Checks landscape validity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkLandscape(params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkLandscape_+3A_params">params</code></td>
<td>
<p>a LandsepiParams Object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if Ok, FALSE otherwise
</p>

<hr>
<h2 id='checkOutputs'>Check outputs</h2><span id='topic+checkOutputs'></span>

<h3>Description</h3>

<p>Checks outputs validity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkOutputs(params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkOutputs_+3A_params">params</code></td>
<td>
<p>a LandsepiParams object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean, TRUE if OK, FALSE otherwise
</p>

<hr>
<h2 id='checkPathogen'>Check pathogen</h2><span id='topic+checkPathogen'></span>

<h3>Description</h3>

<p>Checks pathogen validity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkPathogen(params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkPathogen_+3A_params">params</code></td>
<td>
<p>a LandsepiParams Object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean, TRUE if OK, FALSE otherwise
</p>

<hr>
<h2 id='checkPI0_mat'>Check the array PI0_mat when entered manually in <code>loadInoculum()</code>.</h2><span id='topic+checkPI0_mat'></span>

<h3>Description</h3>

<p>Checks validity of the array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkPI0_mat(mat, params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkPI0_mat_+3A_mat">mat</code></td>
<td>
<p>a 3D array of dimensions (1:Nhost,1:Npatho,1:Npoly)</p>
</td></tr>
<tr><td><code id="checkPI0_mat_+3A_params">params</code></td>
<td>
<p>a LandsepiParams object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the same array at mat, possibly corrected if incompatibility has been detected
</p>

<hr>
<h2 id='checkSimulParams'>Check simulation parameters</h2><span id='topic+checkSimulParams'></span>

<h3>Description</h3>

<p>Checks validity of a LandsepiParams object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkSimulParams(params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkSimulParams_+3A_params">params</code></td>
<td>
<p>a LandsepiParams Object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if OK for simulation, FALSE otherwise
</p>

<hr>
<h2 id='checkTime'>Check time</h2><span id='topic+checkTime'></span>

<h3>Description</h3>

<p>Checks time parameters validity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkTime(params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkTime_+3A_params">params</code></td>
<td>
<p>a LandsepiParams Object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean TRUE if times are setted.
</p>

<hr>
<h2 id='checkTreatment'>Check treatment</h2><span id='topic+checkTreatment'></span>

<h3>Description</h3>

<p>Checks treatment validity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkTreatment(params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkTreatment_+3A_params">params</code></td>
<td>
<p>a LandsepiParams Object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean, TRUE if OK, FALSE otherwise
</p>

<hr>
<h2 id='compute_audpc100S'>Compute AUDPC in a single 100% susceptible field</h2><span id='topic+compute_audpc100S'></span>

<h3>Description</h3>

<p>Compute AUDPC in a single field cultivated with a susceptible cultivar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_audpc100S(
  disease = "rust",
  hostType = "wheat",
  nTSpY = 120,
  area = 1e+06,
  seed = 12345
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_audpc100S_+3A_disease">disease</code></td>
<td>
<p>a disease name, among &quot;rust&quot; (default), &quot;mildew&quot; and &quot;sigatoka&quot;</p>
</td></tr>
<tr><td><code id="compute_audpc100S_+3A_hosttype">hostType</code></td>
<td>
<p>cultivar type, among: &quot;wheat&quot; (default), &quot;grapevine&quot;, &quot;banana&quot;, &quot;pepper&quot;.</p>
</td></tr>
<tr><td><code id="compute_audpc100S_+3A_ntspy">nTSpY</code></td>
<td>
<p>number to time steps per cropping season</p>
</td></tr>
<tr><td><code id="compute_audpc100S_+3A_area">area</code></td>
<td>
<p>area of the field (must be in square meters).</p>
</td></tr>
<tr><td><code id="compute_audpc100S_+3A_seed">seed</code></td>
<td>
<p>an integer used as seed value (for random number generator).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>audpc100S is the average AUDPC computed in a non-spatial simulation.
</p>


<h3>Value</h3>

<p>The AUDPC value (numeric)
</p>


<h3>See Also</h3>

<p><a href="#topic+loadOutputs">loadOutputs</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
compute_audpc100S("rust", "wheat", area=1E6)
compute_audpc100S("mildew", "grapevine", area=1E6)
compute_audpc100S("sigatoka", "banana", area=1E6, nTSpY=182)

## End(Not run)
</code></pre>

<hr>
<h2 id='createSimulParams'>Create a LandsepiParams object.</h2><span id='topic+createSimulParams'></span>

<h3>Description</h3>

<p>Creates a default object of class LandsepiParams.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createSimulParams(outputDir = "./")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createSimulParams_+3A_outputdir">outputDir</code></td>
<td>
<p>ouput directory for simulation (default: current directory)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create a default object of class LandsepiParams used to store all
simulation parameters. It also creates a subdirectory in <code>outputDir</code>
using the date; this directory will contain all simulation outputs.
</p>


<h3>Value</h3>

<p>a LandsepiParams object initialised with the following context:
</p>

<ul>
<li><p> random seed
</p>
</li>
<li><p> all pathogen parameters fixed at 0
</p>
</li>
<li><p> no between-polygon dispersal (neither pathogen nor host)
</p>
</li>
<li><p> no pathogen introduction
</p>
</li>
<li><p> no resistance gene
</p>
</li>
<li><p> no chemical treatment
</p>
</li>
<li><p> no output to generate.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
createSimulParams()

## End(Not run)
</code></pre>

<hr>
<h2 id='Cultivars_list'>Cultivars Type list</h2><span id='topic+Cultivars_list'></span>

<h3>Description</h3>

<p>A set of configurated cultivars types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cultivars_list
</code></pre>


<h3>Format</h3>

<p>A list of list indexed by type name
</p>

<ul>
<li><p> cultivarName: cultivar names (cannot accept space),
</p>
</li>
<li><p> initial_density: host densities (per square meter) at the beginning of the cropping season
as if cultivated in pure crop,
</p>
</li>
<li><p> max_density: maximum host densities (per square meter) at the end of the cropping season
as if cultivated in pure crop,
</p>
</li>
<li><p> growth rate: host growth rates,
</p>
</li>
<li><p> reproduction rate: host reproduction rates,
</p>
</li>
<li><p> yield_H: theoretical yield (in weight or volume units / ha / cropping season)
associated with hosts in sanitary status H as if cultivated in pure crop,
</p>
</li>
<li><p> yield_L: theoretical yield (in weight or volume units / ha / cropping season)
associated with hosts in sanitary status L as if cultivated in pure crop,
</p>
</li>
<li><p> yield_I: theoretical yield (in weight or volume units / ha / cropping season)
associated with hosts in sanitary status I as if cultivated in pure crop,
</p>
</li>
<li><p> yield_R: theoretical yield (in weight or volume units / ha / cropping season)
associated with hosts in sanitary status R as if cultivated in pure crop,
</p>
</li>
<li><p> planting_cost = planting costs (in monetary units / ha / cropping season) as if cultivated in pure crop,
</p>
</li>
<li><p> market_value = market values of the production (in monetary units / weight or volume unit).
</p>
</li></ul>


<hr>
<h2 id='demo_landsepi'>Package demonstration</h2><span id='topic+demo_landsepi'></span>

<h3>Description</h3>

<p>run a simulation demonstration with landsepi
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demo_landsepi(
  seed = 5,
  strat = "MO",
  Nyears = 10,
  nTSpY = 120,
  videoMP4 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="demo_landsepi_+3A_seed">seed</code></td>
<td>
<p>an interger used as seed for Random Number Generator.</p>
</td></tr>
<tr><td><code id="demo_landsepi_+3A_strat">strat</code></td>
<td>
<p>a string specifying the deployment strategy: &quot;MO&quot; for mosaic of resistant
cultivars, &quot;MI&quot; for intra-fied mixtures, &quot;RO&quot; for cultivar rotations, and &quot;PY&quot; for
resistance gene pyramiding in a cultivar.</p>
</td></tr>
<tr><td><code id="demo_landsepi_+3A_nyears">Nyears</code></td>
<td>
<p>number of cropping seasons (years) to simulate.</p>
</td></tr>
<tr><td><code id="demo_landsepi_+3A_ntspy">nTSpY</code></td>
<td>
<p>number of time-steps (days) per cropping season.</p>
</td></tr>
<tr><td><code id="demo_landsepi_+3A_videomp4">videoMP4</code></td>
<td>
<p>a logical indicating if a video must be generated (TRUE, default) or not (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In these examples on rust fungi of cereal crops, 2 completely efficient resistance sources
(typical of major resistance genes) are deployed in the landscape according
to one of the following strategies:</p>

<ul>
<li><p> Mosaic: 3 pure crops (S + R1 + R2) with very high spatial aggregation.
</p>
</li>
<li><p> Mixture: 1 pure susceptible crop + 1 mixture of two resistant cultivars, with high aggregation.
</p>
</li>
<li><p> Rotation: 1 susceptible pure crop + 2 resistant crops in alternation every 2 years
, with moderate aggregation.
</p>
</li>
<li><p> Pyramiding: 1 susceptible crop + 1 pyramided cultivar in a fragmented landscape (low aggregation).
</p>
</li></ul>



<h3>Value</h3>

<p>A set of text files, graphics and a video showing epidemic dynamics.
</p>


<h3>See Also</h3>

<p><a href="#topic+runSimul">runSimul</a>, <a href="#topic+runShinyApp">runShinyApp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Run demonstrations (in 10-year simulations) for different deployment strategies:
demo_landsepi(strat = "MO") ## for a mosaic of cultivars
demo_landsepi(strat = "MI") ## for a mixture of cultivars
demo_landsepi(strat = "RO") ## for a rotation of cultivars
demo_landsepi(strat = "PY") ## for a pyramid of resistance genes

## End(Not run)
</code></pre>

<hr>
<h2 id='dispP'>
Dispersal matrices for rust fungi of cereal crops.
</h2><span id='topic+dispP'></span><span id='topic+dispP_1'></span><span id='topic+dispP_2'></span><span id='topic+dispP_3'></span><span id='topic+dispP_4'></span><span id='topic+dispP_5'></span>

<h3>Description</h3>

<p>Five vectorised dispersal matrices of pathogens as typified by rust fungi of cereal crops (genus <em>Puccinia</em>), 
and associated with landscapes 1 to 5 (composed of 155, 154, 152, 153 and 156 fields, respectively).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> dispP_1
 dispP_2
 dispP_3
 dispP_4
 dispP_5
</code></pre>


<h3>Format</h3>

<p>The format is:
num [1:24025] 8.81e-01 9.53e-04 7.08e-10 1.59e-10 3.29e-06 ...
</p>


<h3>Details</h3>

<p>The pathogen dispersal matrix gives the probability for a pathogen in a field i (row) to migrate to field i' (column) through dispersal. It is computed based on a dispersal kernel and the euclidian distance between each point in fields i and i', using the CaliFloPP algorithm (Bouvier et al. 2009).  
The dispersal kernel is an isotropic power-law function of equation:  
<code class="reqn"> f(x)=((b-2)*(b-1)/(2*pi*a^2)) * (1 + x/a)^{-b} </code>  
with a=40 a scale parameter and b=7 related to the weight of the dispersal tail.  
The expected mean dispersal distance is given by 2*a/(b-3)=20 m.
</p>


<h3>References</h3>

<p>Bouvier A, Kiêu K, Adamczyk K, Monod H. Computation of the integrated flow of particles between polygons. Environ. Model Softw. 2009;24(7):843-9. doi: http://dx.doi.org/10.1016/j.envsoft.2008.11.006.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dispP_1
summary(dispP_1)
## maybe str(dispP_1) ; plot(dispP_1) ...
</code></pre>

<hr>
<h2 id='epid_output'>Generation of epidemiological and economic model outputs</h2><span id='topic+epid_output'></span>

<h3>Description</h3>

<p>Generates epidemiological and economic outputs from model simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epid_output(
  types = "all",
  time_param,
  Npatho,
  area,
  rotation,
  croptypes,
  cultivars_param,
  eco_param,
  treatment_param,
  pathogen_param,
  audpc100S = 0.76,
  writeTXT = TRUE,
  graphic = TRUE,
  path = getwd()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="epid_output_+3A_types">types</code></td>
<td>
<p>a character string (or a vector of character strings if several outputs are to be computed)
specifying the type of outputs to generate (see details):</p>

<ul>
<li><p> &quot;audpc&quot;: Area Under Disease Progress Curve
</p>
</li>
<li><p> &quot;audpc_rel&quot;: Relative Area Under Disease Progress Curve
</p>
</li>
<li><p> &quot;gla&quot;: Green Leaf Area
</p>
</li>
<li><p> &quot;gla_rel&quot;: Relative Green Leaf Area
</p>
</li>
<li><p> &quot;eco_yield&quot;: Total crop yield
</p>
</li>
<li><p> &quot;eco_cost&quot;: Operational crop costs
</p>
</li>
<li><p> &quot;eco_product&quot;: Crop products
</p>
</li>
<li><p> &quot;eco_margin&quot;: Margin (products - operational costs)
</p>
</li>
<li><p> &quot;contrib&quot;: contribution of pathogen genotypes to LIR dynamics
</p>
</li>
<li><p> &quot;HLIR_dynamics&quot;, &quot;H_dynamics&quot;, &quot;L_dynamics&quot;, &quot;IR_dynamics&quot;, &quot;HLI_dynamics&quot;, etc.: Epidemic dynamics
related to the specified sanitary status (H, L, I or R and all their combinations).
Graphics only, works only if graphic=TRUE.
</p>
</li>
<li><p> &quot;all&quot;: compute all these outputs (default).
</p>
</li></ul>
</td></tr>
<tr><td><code id="epid_output_+3A_time_param">time_param</code></td>
<td>
<p>list of simulation parameters:</p>

<ul>
<li><p> Nyears = number cropping seasons,
</p>
</li>
<li><p> nTSpY = number of time-steps per cropping season.
</p>
</li></ul>
</td></tr>
<tr><td><code id="epid_output_+3A_npatho">Npatho</code></td>
<td>
<p>number of pathogen genotypes.</p>
</td></tr>
<tr><td><code id="epid_output_+3A_area">area</code></td>
<td>
<p>a vector containing polygon areas (must be in square meters).</p>
</td></tr>
<tr><td><code id="epid_output_+3A_rotation">rotation</code></td>
<td>
<p>a dataframe containing for each field (rows) and year (columns, named &quot;year_1&quot;, &quot;year_2&quot;, etc.),
the index of the cultivated croptype. Importantly, the matrix must contain 1 more column than the real number
of simulated years.</p>
</td></tr>
<tr><td><code id="epid_output_+3A_croptypes">croptypes</code></td>
<td>
<p>a dataframe with three columns named 'croptypeID' for croptype index,
'cultivarID' for cultivar index and 'proportion' for the proportion of the cultivar within the croptype.</p>
</td></tr>
<tr><td><code id="epid_output_+3A_cultivars_param">cultivars_param</code></td>
<td>
<p>list of parameters associated with each host genotype (i.e. cultivars):
</p>

<ul>
<li><p> name = vector of cultivar names,
</p>
</li>
<li><p> initial_density = vector of host densities (per square meter) at the beginning of the cropping season
as if cultivated in pure crop,
</p>
</li>
<li><p> max_density = vector of maximum host densities (per square meter) at the end of the cropping season
as if cultivated in pure crop,
</p>
</li>
<li><p> cultivars_genes_list = a list containing, for each host genotype, the indices of carried resistance genes.
</p>
</li></ul>
</td></tr>
<tr><td><code id="epid_output_+3A_eco_param">eco_param</code></td>
<td>
<p>a list of economic parameters for each host genotype as if cultivated in pure crop:</p>

<ul>
<li><p> yield_perHa = a dataframe of 4 columns for the theoretical yield associated with hosts in sanitary status H, L, I and R,
as if cultivated in pure crops, and one row per host genotype
(yields are expressed in weight or volume units / ha / cropping season),
</p>
</li>
<li><p> planting_cost_perHa = a vector of planting costs (in monetary units / ha / cropping season),
</p>
</li>
<li><p> market_value = a vector of market values of the production (in monetary units / weight or volume unit).
</p>
</li></ul>
</td></tr>
<tr><td><code id="epid_output_+3A_treatment_param">treatment_param</code></td>
<td>
<p>list of parameters related to pesticide treatments: </p>

<ul>
<li><p> treatment_degradation_rate = degradation rate (per time step) of chemical concentration,
</p>
</li>
<li><p> treatment_efficiency = maximal efficiency of chemical treatments (i.e. fractional reduction
of pathogen infection rate at the time of application),
</p>
</li>
<li><p> treatment_timesteps = vector of time-steps corresponding to treatment application dates,
</p>
</li>
<li><p> treatment_cultivars = vector of indices of the cultivars that receive treatments,
</p>
</li>
<li><p> treatment_cost = cost of a single treatment application (monetary units/ha)
</p>
</li>
<li><p> treatment_application_threshold = vector of thresholds (i.e. disease severity, one for each treated cultivar)
above which the treatment is applied in a polygon
</p>
</li></ul>
</td></tr>
<tr><td><code id="epid_output_+3A_pathogen_param">pathogen_param</code></td>
<td>
<p>a list of i. pathogen aggressiveness parameters on a susceptible host
for a pathogen genotype not adapted to resistance and ii. sexual reproduction parameters: </p>

<ul>
<li><p> infection_rate = maximal expected infection rate of a propagule on a healthy host,
</p>
</li>
<li><p> propagule_prod_rate = maximal expected effective propagule production rate of an infectious host per time step,
</p>
</li>
<li><p> latent_period_mean = minimal expected duration of the latent period,
</p>
</li>
<li><p> latent_period_var = variance of the latent period duration,
</p>
</li>
<li><p> infectious_period_mean = maximal expected duration of the infectious period,
</p>
</li>
<li><p> infectious_period_var = variance of the infectious period duration,
</p>
</li>
<li><p> survival_prob = probability for a propagule to survive the off-season,
</p>
</li>
<li><p> repro_sex_prob = probability for an infectious host to reproduce via sex rather than via cloning,
</p>
</li>
<li><p> sigmoid_kappa = kappa parameter of the sigmoid contamination function,
</p>
</li>
<li><p> sigmoid_sigma = sigma parameter of the sigmoid contamination function,
</p>
</li>
<li><p> sigmoid_plateau = plateau parameter of the sigmoid contamination function,
</p>
</li>
<li><p> sex_propagule_viability_limit = maximum number of cropping seasons up to which a sexual propagule is viable
</p>
</li>
<li><p> sex_propagule_release_mean = average number of seasons after which a sexual propagule is released,
</p>
</li>
<li><p> clonal_propagule_gradual_release = whether or not clonal propagules surviving the bottleneck are gradually released along the following cropping season.
</p>
</li></ul>
</td></tr>
<tr><td><code id="epid_output_+3A_audpc100s">audpc100S</code></td>
<td>
<p>the audpc in a fully susceptible landscape (used as reference value for graphics).</p>
</td></tr>
<tr><td><code id="epid_output_+3A_writetxt">writeTXT</code></td>
<td>
<p>a logical indicating if the output is written in a text file (TRUE) or not (FALSE).</p>
</td></tr>
<tr><td><code id="epid_output_+3A_graphic">graphic</code></td>
<td>
<p>a logical indicating if a tiff graphic of the output is generated (only if more than one year is simulated).</p>
</td></tr>
<tr><td><code id="epid_output_+3A_path">path</code></td>
<td>
<p>path of text file (if writeTXT = TRUE) and tiff graphic (if graphic = TRUE) to be generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Outputs are computed every year for every cultivar as well as for the whole landscape. </p>

<dl>
<dt><strong>Epidemiological outputs.</strong></dt><dd>
<p>The epidemiological impact of pathogen spread can be evaluated by different measures: </p>

<ol>
<li><p> Area Under Disease Progress Curve (AUDPC): average number of diseased host individuals (status I + R)
per time step and square meter.
</p>
</li>
<li><p> Relative Area Under Disease Progress Curve (AUDPCr): average proportion of diseased host individuals
(status I + R) relative to the total number of existing hosts (H+L+I+R).
</p>
</li>
<li><p> Green Leaf Area (GLA): average number of healthy host individuals (status H) per time step and per square meter.
</p>
</li>
<li><p> Relative Green Leaf Area (GLAr): average proportion of healthy host individuals (status H) relative to the total number
of existing hosts (H+L+I+R).
</p>
</li>
<li><p> Contribution of pathogen genotypes: for every year and every host (as well as for the whole landscape and the whole
simulation duration), fraction of cumulative LIR infections attributed to each pathogen genotype.
</p>
</li></ol>

</dd>
<dt><strong>Economic outputs.</strong></dt><dd>
<p>The economic outcome of a simulation can be evaluated using: </p>

<ol>
<li><p> Crop yield: yearly crop yield (e.g. grains, fruits, wine) in weight (or volume) units
per hectare (depends on the number of productive hosts and associated theoretical yield).
</p>
</li>
<li><p> Crop products: yearly product generated from sales, in monetary units per hectare
(depends on crop yield and market value). Note that when disease = &quot;mildew&quot; a price reduction
between 0% and 5% is applied to the market value depending on disease severity.
</p>
</li>
<li><p> Operational crop costs: yearly costs associated with crop planting (depends on initial
host density and planting cost) and pesticide treatments (depends on the number of applications and
the cost of a single application) in monetary units per hectare.
</p>
</li>
<li><p> Crop margin, i.e. products - operational costs, in monetary units per hectare.
</p>
</li></ol>

</dd>
</dl>



<h3>Value</h3>

<p>A list containing, for each required type of output, a matrix summarising the output for each year and cultivar
(as well as the whole landscape).
Each matrix can be written in a txt file (if writeTXT=TRUE), and illustrated in a graphic (if graphic=TRUE).
</p>


<h3>References</h3>

<p>Rimbaud L., Papaïx J., Rey J.-F., Barrett L. G. and Thrall P. H. (2018). Assessing the durability and efficiency of
landscape-based strategies to deploy plant resistance to pathogens. <em>PLoS Computational Biology</em> 14(4):e1006067.
</p>


<h3>See Also</h3>

<p><a href="#topic+evol_output">evol_output</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
demo_landsepi()

## End(Not run)
</code></pre>

<hr>
<h2 id='evol_output'>Generation of evolutionary model outputs</h2><span id='topic+evol_output'></span>

<h3>Description</h3>

<p>Generates evolutionary outputs from model simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evol_output(
  types = "all",
  time_param,
  Npoly,
  cultivars_param,
  genes_param,
  thres_breakdown = 50000,
  writeTXT = TRUE,
  graphic = TRUE,
  path = getwd()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evol_output_+3A_types">types</code></td>
<td>
<p>a character string (or a vector of character strings if several outputs are to be computed) specifying the
type of outputs to generate (see details):</p>

<ul>
<li><p> &quot;evol_patho&quot;: Evolution of pathogen genotypes
</p>
</li>
<li><p> &quot;evol_aggr&quot;: Evolution of pathogen aggressiveness (i.e. phenotype)
</p>
</li>
<li><p> &quot;durability&quot;: Durability of resistance genes
</p>
</li>
<li><p> &quot;all&quot;: compute all these outputs (default)
</p>
</li></ul>
</td></tr>
<tr><td><code id="evol_output_+3A_time_param">time_param</code></td>
<td>
<p>list of simulation parameters:</p>

<ul>
<li><p> Nyears = number cropping seasons,
</p>
</li>
<li><p> nTSpY = number of time-steps per cropping season.
</p>
</li></ul>
</td></tr>
<tr><td><code id="evol_output_+3A_npoly">Npoly</code></td>
<td>
<p>number of fields in the landscape.</p>
</td></tr>
<tr><td><code id="evol_output_+3A_cultivars_param">cultivars_param</code></td>
<td>
<p>list of parameters associated with each host genotype (i.e. cultivars)
when cultivated in pure crops:</p>

<ul>
<li><p> name = vector of cultivar names,
</p>
</li>
<li><p> cultivars_genes_list = a list containing, for each host genotype, the indices of carried resistance genes.
</p>
</li></ul>
</td></tr>
<tr><td><code id="evol_output_+3A_genes_param">genes_param</code></td>
<td>
<p>list of parameters associated with each resistance gene and with the evolution of
each corresponding pathogenicity gene:</p>

<ul>
<li><p> name = vector of names of resistance genes,
</p>
</li>
<li><p> Nlevels_aggressiveness = vector containing the number of adaptation levels related to each resistance gene (i.e. 1 + number
of required mutations for a pathogenicity gene to fully adapt to the corresponding resistance gene),
</p>
</li></ul>
</td></tr>
<tr><td><code id="evol_output_+3A_thres_breakdown">thres_breakdown</code></td>
<td>
<p>an integer (or vector of integers) giving the threshold (i.e. number of infections) above which a
pathogen genotype is unlikely to go extinct and resistance is considered broken down, used to characterise the time to
invasion of resistant hosts (several values are computed if several thresholds are given in a vector).</p>
</td></tr>
<tr><td><code id="evol_output_+3A_writetxt">writeTXT</code></td>
<td>
<p>a logical indicating if the output is written in a text file (TRUE) or not (FALSE).</p>
</td></tr>
<tr><td><code id="evol_output_+3A_graphic">graphic</code></td>
<td>
<p>a logical indicating if graphics must be generated (TRUE) or not (FALSE).</p>
</td></tr>
<tr><td><code id="evol_output_+3A_path">path</code></td>
<td>
<p>a character string indicating the path of the repository where simulation output files are located and
where .txt files and graphics will be generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each pathogen genotype (evol_patho) or phenotype (evol_aggr, note that different pathogen genotypes
may lead to the same phenotype on a resistant host), several computations are performed based on pathogen genotype
frequencies: </p>

<ul>
<li><p> appearance: time to first appearance (as propagule);
</p>
</li>
<li><p> R_infection: time to first true infection of a resistant host;
</p>
</li>
<li><p> R_invasion: time to invasion, when the number of infections of resistant hosts reaches a threshold above which
the genotype or phenotype is unlikely to go extinct.</p>
</li></ul>

<p>The value Nyears + 1 time step is used if the genotype or phenotype never appeared/infected/invaded.
Durability is defined as the time to invasion of completely adapted pathogen individuals.
</p>


<h3>Value</h3>

<p>A list containing, for each required type of output, a matrix summarising the output.
Each matrix can be written in a txt file (if writeTXT=TRUE), and illustrated in a graphic (if graphic=TRUE).
</p>


<h3>References</h3>

<p>Rimbaud L., Papaïx J., Rey J.-F., Barrett L. G. and Thrall P. H. (2018). Assessing the durability and efficiency
of landscape-based strategies to deploy plant resistance to pathogens. <em>PLoS Computational Biology</em> 14(4):e1006067.
</p>


<h3>See Also</h3>

<p><a href="#topic+epid_output">epid_output</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
demo_landsepi()

## End(Not run)
</code></pre>

<hr>
<h2 id='getMatrixCroptypePatho'>Get the &quot;croptype/pathogen genotype&quot; compatibility matrix.</h2><span id='topic+getMatrixCroptypePatho'></span>

<h3>Description</h3>

<p>Build the matrix indicating if infection is possible at the beginning of the season
for every combination of croptype (rows) and pathogen genotype (columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMatrixCroptypePatho(params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMatrixCroptypePatho_+3A_params">params</code></td>
<td>
<p>a LandsepiParams object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each croptype, there is either possibility of infection by the pathogen genotype
(value of 1), either complete protection (value of 0)
</p>


<h3>Value</h3>

<p>an interaction matrix composed of 0 and 1 values.
</p>


<h3>See Also</h3>

<p><a href="#topic+getMatrixGenePatho">getMatrixGenePatho</a>, <a href="#topic+getMatrixCultivarPatho">getMatrixCultivarPatho</a>, <a href="#topic+getMatrixPolyPatho">getMatrixPolyPatho</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simul_params &lt;- createSimulParams()
gene1 &lt;- loadGene(name = "MG 1", type = "majorGene")
gene2 &lt;- loadGene(name = "MG 2", type = "majorGene")
genes &lt;- data.frame(rbind(gene1, gene2), stringsAsFactors = FALSE)
simul_params &lt;- setGenes(simul_params, genes)
cultivar1 &lt;- loadCultivar(name = "Susceptible", type = "wheat")
cultivar2 &lt;- loadCultivar(name = "Resistant1", type = "wheat")
cultivar3 &lt;- loadCultivar(name = "Resistant2", type = "wheat")
cultivar4 &lt;- loadCultivar(name = "Pyramid", type = "wheat")
cultivars &lt;- data.frame(rbind(cultivar1, cultivar2, cultivar3, cultivar4)
, stringsAsFactors = FALSE)
simul_params &lt;- setCultivars(simul_params, cultivars)
simul_params &lt;- allocateCultivarGenes(simul_params, "Resistant1", c("MG 1"))
simul_params &lt;- allocateCultivarGenes(simul_params, "Resistant2", c("MG 2"))
simul_params &lt;- allocateCultivarGenes(simul_params, "Pyramid", c("MG 1", "MG 2"))
croptypes &lt;- loadCroptypes(simul_params,
                           names = c("Susceptible crop",
                                     "Resistant crop 1",
                                     "Mixture S+R",
                                     "Mixture R1+R2",
                                     "Pyramid crop"))
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Susceptible crop", "Susceptible")
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Resistant crop 1", "Resistant1")
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Mixture S+R", c("Susceptible", "Resistant1"))
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Mixture R1+R2", c("Resistant1", "Resistant2"))
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Pyramid crop", c("Pyramid"))
simul_params &lt;- setCroptypes(simul_params, croptypes)
getMatrixCroptypePatho(simul_params)

## End(Not run)
</code></pre>

<hr>
<h2 id='getMatrixCultivarPatho'>Get the &quot;cultivar/pathogen genotype&quot; compatibility matrix.</h2><span id='topic+getMatrixCultivarPatho'></span>

<h3>Description</h3>

<p>Build the matrix indicating if infection is possible at the beginning of the season
for every combination of cultivar (rows) and pathogen genotype (columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMatrixCultivarPatho(params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMatrixCultivarPatho_+3A_params">params</code></td>
<td>
<p>a LandsepiParams object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each cultivar, there is either possibility of infection by the
pathogen genotype (value of 1), or complete protection (value of 0).
</p>


<h3>Value</h3>

<p>an interaction matrix composed of 0 and 1 values.
</p>


<h3>See Also</h3>

<p><a href="#topic+getMatrixGenePatho">getMatrixGenePatho</a>, <a href="#topic+getMatrixCroptypePatho">getMatrixCroptypePatho</a>, <a href="#topic+getMatrixPolyPatho">getMatrixPolyPatho</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simul_params &lt;- createSimulParams()
gene1 &lt;- loadGene(name = "MG 1", type = "majorGene")
gene2 &lt;- loadGene(name = "MG 2", type = "majorGene")
genes &lt;- data.frame(rbind(gene1, gene2), stringsAsFactors = FALSE)
simul_params &lt;- setGenes(simul_params, genes)
cultivar1 &lt;- loadCultivar(name = "Susceptible", type = "wheat")
cultivar2 &lt;- loadCultivar(name = "monoResistant1", type = "wheat")
cultivar3 &lt;- loadCultivar(name = "monoResistant2", type = "wheat")
cultivar4 &lt;- loadCultivar(name = "Pyramid", type = "wheat")
cultivars &lt;- data.frame(rbind(cultivar1, cultivar2, cultivar3, cultivar4)
, stringsAsFactors = FALSE)
simul_params &lt;- setCultivars(simul_params, cultivars)
simul_params &lt;- allocateCultivarGenes(simul_params, "monoResistant1", c("MG 1"))
simul_params &lt;- allocateCultivarGenes(simul_params, "monoResistant2", c("MG 2"))
simul_params &lt;- allocateCultivarGenes(simul_params, "Pyramid", c("MG 1", "MG 2"))
getMatrixCultivarPatho(simul_params)

## End(Not run)
</code></pre>

<hr>
<h2 id='getMatrixGenePatho'>Get the &quot;resistance gene/pathogen genotype&quot; compatibility matrix.</h2><span id='topic+getMatrixGenePatho'></span>

<h3>Description</h3>

<p>Build the matrix indicating if infection is possible at the beginning of the season
for every combination of plant resistance gene (rows) and pathogen genotype (columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMatrixGenePatho(params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMatrixGenePatho_+3A_params">params</code></td>
<td>
<p>a LandsepiParams object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For hosts carrying each resistance gene, there is either possibility of infection
by the pathogen genotype (value of 1), either complete protection (value of 0).
Complete protection only occurs if the resistance gene targets the infection rate,
has a complete efficiency, and is expressed from the beginning of the cropping season
(i.e. this is not an APR).
</p>


<h3>Value</h3>

<p>an interaction matrix composed of 0 and 1 values.
</p>


<h3>See Also</h3>

<p><a href="#topic+getMatrixCultivarPatho">getMatrixCultivarPatho</a>, <a href="#topic+getMatrixCroptypePatho">getMatrixCroptypePatho</a>, <a href="#topic+getMatrixPolyPatho">getMatrixPolyPatho</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simul_params &lt;- createSimulParams()
gene1 &lt;- loadGene(name = "MG 1", type = "majorGene")
gene2 &lt;- loadGene(name = "MG 2", type = "majorGene")
genes &lt;- data.frame(rbind(gene1, gene2), stringsAsFactors = FALSE)
simul_params &lt;- setGenes(simul_params, genes)
getMatrixGenePatho(simul_params)

## End(Not run)
</code></pre>

<hr>
<h2 id='getMatrixPolyPatho'>Get the &quot;polygon/pathogen genotype&quot; compatibility matrix.</h2><span id='topic+getMatrixPolyPatho'></span>

<h3>Description</h3>

<p>Build the matrix indicating if infection is possible at the beginning of the season
for every combination of polygon (rows) and pathogen genotype (columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMatrixPolyPatho(params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMatrixPolyPatho_+3A_params">params</code></td>
<td>
<p>a LandsepiParams object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each polygon, there is either possibility of infection by the pathogen genotype
(value of 1), either complete protection (value of 0)
</p>


<h3>Value</h3>

<p>an interaction matrix composed of 0 and 1 values.
</p>


<h3>See Also</h3>

<p><a href="#topic+getMatrixGenePatho">getMatrixGenePatho</a>, <a href="#topic+getMatrixCultivarPatho">getMatrixCultivarPatho</a>, <a href="#topic+getMatrixCroptypePatho">getMatrixCroptypePatho</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simul_params &lt;- createSimulParams()
simul_params &lt;- setTime(simul_params, Nyears = 1, nTSpY = 80)
simul_params &lt;- setLandscape(simul_params, loadLandscape(id = 1))
gene1 &lt;- loadGene(name = "MG 1", type = "majorGene")
gene2 &lt;- loadGene(name = "MG 2", type = "majorGene")
genes &lt;- data.frame(rbind(gene1, gene2), stringsAsFactors = FALSE)
simul_params &lt;- setGenes(simul_params, genes)
cultivar1 &lt;- loadCultivar(name = "Susceptible", type = "wheat")
cultivar2 &lt;- loadCultivar(name = "Resistant1", type = "wheat")
cultivar3 &lt;- loadCultivar(name = "Resistant2", type = "wheat")
cultivar4 &lt;- loadCultivar(name = "Pyramid", type = "wheat")
cultivars &lt;- data.frame(rbind(cultivar1, cultivar2, cultivar3, cultivar4)
, stringsAsFactors = FALSE)
simul_params &lt;- setCultivars(simul_params, cultivars)
simul_params &lt;- allocateCultivarGenes(simul_params, "Resistant1", c("MG 1"))
simul_params &lt;- allocateCultivarGenes(simul_params, "Resistant2", c("MG 2"))
simul_params &lt;- allocateCultivarGenes(simul_params, "Pyramid", c("MG 1", "MG 2"))
croptypes &lt;- loadCroptypes(simul_params,
                           names = c("Susceptible crop",
                                     "Resistant crop 1",
                                     "Mixture S+R",
                                     "Mixture R1+R2",
                                     "Pyramid crop"))
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Susceptible crop", "Susceptible")
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Resistant crop 1", "Resistant1")
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Mixture S+R", c("Susceptible", "Resistant1"))
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Mixture R1+R2", c("Resistant1", "Resistant2"))
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Pyramid crop", c("Pyramid"))
simul_params &lt;- setCroptypes(simul_params, croptypes)
simul_params &lt;- allocateLandscapeCroptypes(simul_params, rotation_period = 0,
prop=rep(1/5,5), aggreg=3 , rotation_sequence = croptypes$croptypeID)
getMatrixPolyPatho(simul_params)

## End(Not run)
</code></pre>

<hr>
<h2 id='initialize+2CLandsepiParams-method'>LandsepiParams</h2><span id='topic+initialize+2CLandsepiParams-method'></span>

<h3>Description</h3>

<p>Creates and initialises a LandsepiParams object with default parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LandsepiParams'
initialize(
  .Object,
  Landscape = st_sf(st_sfc()),
  Croptypes = data.frame(),
  Cultivars = data.frame(matrix(ncol = length(.cultivarsColNames), nrow = 0, dimnames =
    list(NULL, .cultivarsColNames))),
  CultivarsGenes = data.frame(),
  Genes = data.frame(matrix(ncol = length(.geneColNames), nrow = 0, dimnames = list(NULL,
    .geneColNames))),
  Pathogen = list(name = "no pathogen", survival_prob = 0, repro_sex_prob = 0,
    infection_rate = 0, propagule_prod_rate = 0, latent_period_mean = 0,
    latent_period_var = 0, infectious_period_mean = 0, infectious_period_var = 0,
    sigmoid_kappa = 0, sigmoid_sigma = 0, sigmoid_plateau = 1,
    sex_propagule_viability_limit = 0, sex_propagule_release_mean = 0,
    clonal_propagule_gradual_release = 0),
  PI0 = 0,
  DispHost = vector(),
  DispPathoClonal = vector(),
  DispPathoSex = vector(),
  Treatment = list(treatment_degradation_rate = 0.1, treatment_efficiency = 0,
    treatment_timesteps = vector(), treatment_cultivars = vector(), treatment_cost = 0,
    treatment_application_threshold = vector()),
  OutputDir = normalizePath(character(getwd())),
  OutputGPKG = "landsepi_landscape.gpkg",
  Outputs = list(epid_outputs = "", evol_outputs = "", thres_breakdown = NA, audpc100S =
    NA),
  TimeParam = list(Nyears = 0, nTSpY = 0),
  Seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initialize+2B2CLandsepiParams-method_+3A_.object">.Object</code></td>
<td>
<p>a LandsepiParam object.</p>
</td></tr>
<tr><td><code id="initialize+2B2CLandsepiParams-method_+3A_landscape">Landscape</code></td>
<td>
<p>a landscape as sf object.</p>
</td></tr>
<tr><td><code id="initialize+2B2CLandsepiParams-method_+3A_croptypes">Croptypes</code></td>
<td>
<p>a dataframe with three columns named 'croptypeID' for croptype index,
'cultivarID' for cultivar index and 'proportion' for the proportion of the cultivar
within the croptype.</p>
</td></tr>
<tr><td><code id="initialize+2B2CLandsepiParams-method_+3A_cultivars">Cultivars</code></td>
<td>
<p>a dataframe of parameters associated with each host genotype
(i.e. cultivars, lines) when cultivated in pure crops.</p>
</td></tr>
<tr><td><code id="initialize+2B2CLandsepiParams-method_+3A_cultivarsgenes">CultivarsGenes</code></td>
<td>
<p>a list containing, for each host genotype, the indices of
carried resistance genes.</p>
</td></tr>
<tr><td><code id="initialize+2B2CLandsepiParams-method_+3A_genes">Genes</code></td>
<td>
<p>a data.frame of parameters associated with each resistance gene and with
the evolution of each corresponding pathogenicity gene.</p>
</td></tr>
<tr><td><code id="initialize+2B2CLandsepiParams-method_+3A_pathogen">Pathogen</code></td>
<td>
<p>a list of pathogen aggressiveness parameters on a susceptible host
for a pathogen genotype not adapted to resistance.</p>
</td></tr>
<tr><td><code id="initialize+2B2CLandsepiParams-method_+3A_pi0">PI0</code></td>
<td>
<p>vector of length Npoly.Nhost.Npatho filled with the initial probabilities for hosts
to be infectious (i.e. state I), for each pathogen genotype,
at the beginning of the simulation.</p>
</td></tr>
<tr><td><code id="initialize+2B2CLandsepiParams-method_+3A_disphost">DispHost</code></td>
<td>
<p>a vectorized matrix giving the probability of host dispersal
from any polygon of the landscape to any other polygon</p>
</td></tr>
<tr><td><code id="initialize+2B2CLandsepiParams-method_+3A_disppathoclonal">DispPathoClonal</code></td>
<td>
<p>a vectorized matrix giving the probability of pathogen dispersal
from any polygon of the landscape to any other polygon.</p>
</td></tr>
<tr><td><code id="initialize+2B2CLandsepiParams-method_+3A_disppathosex">DispPathoSex</code></td>
<td>
<p>a vectorized matrix giving the probability of pathogen dispersal
from any polygon of the landscape to any other polygon (sexual propagule).</p>
</td></tr>
<tr><td><code id="initialize+2B2CLandsepiParams-method_+3A_treatment">Treatment</code></td>
<td>
<p>a list of chemical treatment parameters (indices of treated cultivars,
times of application, efficiency and degradation rate)</p>
</td></tr>
<tr><td><code id="initialize+2B2CLandsepiParams-method_+3A_outputdir">OutputDir</code></td>
<td>
<p>the directory for simulation outputs</p>
</td></tr>
<tr><td><code id="initialize+2B2CLandsepiParams-method_+3A_outputgpkg">OutputGPKG</code></td>
<td>
<p>the name of the output GPKG file containing parameters of the
deployment strategy</p>
</td></tr>
<tr><td><code id="initialize+2B2CLandsepiParams-method_+3A_outputs">Outputs</code></td>
<td>
<p>a list of outputs parameters.</p>
</td></tr>
<tr><td><code id="initialize+2B2CLandsepiParams-method_+3A_timeparam">TimeParam</code></td>
<td>
<p>a list of time parameters.</p>
</td></tr>
<tr><td><code id="initialize+2B2CLandsepiParams-method_+3A_seed">Seed</code></td>
<td>
<p>an integer used as seed value (for random number generator).</p>
</td></tr>
<tr><td><code id="initialize+2B2CLandsepiParams-method_+3A_...">...</code></td>
<td>
<p>more options</p>
</td></tr>
</table>

<hr>
<h2 id='inoculumToMatrix'>Inoculum To Matrix</h2><span id='topic+inoculumToMatrix'></span>

<h3>Description</h3>

<p>Transform the inoculum pI0 (1D vector of length Nhost<em>Npatho</em>Npoly) into
a 3D array (for visualization purpose)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inoculumToMatrix(params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inoculumToMatrix_+3A_params">params</code></td>
<td>
<p>a LandsepiParams object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After defining the inoculum with <code>setInoculum()</code>, this function returns
the inoculum as a 3D array.
</p>


<h3>Value</h3>

<p>a 3D array of structure (1:Nhost,1:Npatho,1:Npoly)
</p>


<h3>See Also</h3>

<p><a href="#topic+setInoculum">setInoculum</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simul_params &lt;- createSimulParams()
simul_params &lt;- setTime(simul_params, Nyears = 1, nTSpY = 80)
simul_params &lt;- setPathogen(simul_params, loadPathogen(disease = "rust"))
simul_params &lt;- setLandscape(simul_params, loadLandscape(id = 1))
simul_params &lt;- setDispersalPathogen(simul_params, loadDispersalPathogen(id = 1)[[1]])
gene1 &lt;- loadGene(name = "MG 1", type = "majorGene")
gene2 &lt;- loadGene(name = "MG 2", type = "majorGene")
genes &lt;- data.frame(rbind(gene1, gene2), stringsAsFactors = FALSE)
simul_params &lt;- setGenes(simul_params, genes)
cultivar1 &lt;- loadCultivar(name = "Susceptible", type = "wheat")
cultivar2 &lt;- loadCultivar(name = "Resistant", type = "wheat")
cultivars &lt;- data.frame(rbind(cultivar1, cultivar2), stringsAsFactors = FALSE)
simul_params &lt;- setCultivars(simul_params, cultivars)
simul_params &lt;- allocateCultivarGenes(simul_params, "Resistant", c("MG 1", "MG 2"))
croptypes &lt;- loadCroptypes(simul_params, names = c("Susceptible crop", "Resistant crop"))
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Susceptible crop", "Susceptible")
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Resistant crop", c("Resistant"))
simul_params &lt;- setCroptypes(simul_params, croptypes)
simul_params@Croptypes
simul_params &lt;- allocateLandscapeCroptypes(simul_params, rotation_period = 0
, rotation_sequence = croptypes$croptypeID
, prop = c(1/2,1/2), aggreg = 1, graphic = FALSE)
pI0 &lt;- loadInoculum(simul_params, pI0_patho=c(1E-3,1E-4,1E-4,1E-5), pI0_host=c(1,1))
simul_params &lt;- setInoculum(simul_params, pI0)
inoculumToMatrix(simul_params)[,,1:5]

## End(Not run)
</code></pre>

<hr>
<h2 id='invlogit'>Inverse logit function</h2><span id='topic+invlogit'></span>

<h3>Description</h3>

<p>Given a numeric object, return the invlogit of the values. Missing values (NAs) are allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invlogit(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invlogit_+3A_x">x</code></td>
<td>
<p>a numeric object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The invlogit is defined by <code class="reqn"> exp(x) / (1+exp(x)) </code>. Values in x of -Inf or Inf return invlogits
of 0 or 1 respectively.
Any NAs in the input will also be NAs in the output.
</p>


<h3>Value</h3>

<p>An object of the same type as x containing the invlogits of the input values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>invlogit(10)
</code></pre>

<hr>
<h2 id='is.in.01'>is.in.01</h2><span id='topic+is.in.01'></span>

<h3>Description</h3>

<p>Tests if a number or vector is in the interval [0,1]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.in.01(x, exclude0 = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.in.01_+3A_x">x</code></td>
<td>
<p>a number or vector or matrix</p>
</td></tr>
<tr><td><code id="is.in.01_+3A_exclude0">exclude0</code></td>
<td>
<p>TRUE is 0 is excluded, FALSE otherwise (default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical of the same size as x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.in.01(-5)
is.in.01(0)
is.in.01(1)
is.in.01(0, exclude0 = TRUE)
is.in.01(2.5)
is.in.01(matrix(5:13/10, nrow=3))
</code></pre>

<hr>
<h2 id='is.positive'>is.positive</h2><span id='topic+is.positive'></span>

<h3>Description</h3>

<p>Tests if a number or vector is positive (including 0)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.positive(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.positive_+3A_x">x</code></td>
<td>
<p>a number or vector or matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical of the same size as x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.positive(-5)
is.positive(10)
is.positive(2.5)
is.positive(matrix(1:9, nrow=3))
</code></pre>

<hr>
<h2 id='is.strict.positive'>is.strict.positive</h2><span id='topic+is.strict.positive'></span>

<h3>Description</h3>

<p>Tests if a number or vector is strictly positive (i.e. excluding 0)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.strict.positive(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.strict.positive_+3A_x">x</code></td>
<td>
<p>a number or vector or matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical of the same size as x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.strict.positive(-5)
is.strict.positive(10)
is.strict.positive(2.5)
is.strict.positive(matrix(1:9, nrow=3))
</code></pre>

<hr>
<h2 id='is.wholenumber'>is.wholenumber</h2><span id='topic+is.wholenumber'></span>

<h3>Description</h3>

<p>Tests if a number or vector is a whole number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.wholenumber(x, tol = .Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.wholenumber_+3A_x">x</code></td>
<td>
<p>a number or vector or matrix</p>
</td></tr>
<tr><td><code id="is.wholenumber_+3A_tol">tol</code></td>
<td>
<p>double tolerance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical of the same format as x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.wholenumber(-5)
is.wholenumber(10)
is.wholenumber(2.5)
is.wholenumber(matrix(1:9, nrow=3))
</code></pre>

<hr>
<h2 id='landscapeTEST'>
Landscapes
</h2><span id='topic+landscapeTEST'></span><span id='topic+landscapeTEST1'></span><span id='topic+landscapeTEST2'></span><span id='topic+landscapeTEST3'></span><span id='topic+landscapeTEST4'></span><span id='topic+landscapeTEST5'></span>

<h3>Description</h3>

<p>Five simulated landscapes, composed of 155, 154, 152, 153 and 156 fields, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> landscapeTEST1
 landscapeTEST2
 landscapeTEST3
 landscapeTEST4
 landscapeTEST5</code></pre>


<h3>Format</h3>

<p>Landscapes have been generated using a T-tesselation algorithm. 
The format is a formal class 'SpatialPolygons' [package &quot;sp&quot;].
</p>


<h3>Details</h3>

<p>The landscape structure is simulated using a T-tessellation algorithm (Kiêu et al. 2013) in order to control specific features such as number, area and shape of the fields.
</p>


<h3>References</h3>

<p>Kiêu K, Adamczyk-Chauvat K, Monod H, Stoica RS. A completely random T-tessellation model and Gibbsian extensions. Spat. Stat. 2013;6:118-38. doi: http://dx.doi.org/10.1016/j.spasta.2013.09.003.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(sp)
  library(landsepi)
  landscapeTEST1
  plot(landscapeTEST1)
</code></pre>

<hr>
<h2 id='LandsepiParams'>Class LandsepiParams</h2><span id='topic+LandsepiParams'></span><span id='topic+LandsepiParams-class'></span>

<h3>Description</h3>

<p>Landsepi simulation parameters
</p>


<h3>Details</h3>

<p>An object of class LandsepiParams that can be created by calling <code><a href="#topic+createSimulParams">createSimulParams</a></code>
</p>


<h3>Slots</h3>


<dl>
<dt><code>Landscape</code></dt><dd><p>a landscape as sf object. See <code><a href="#topic+loadLandscape">loadLandscape</a></code></p>
</dd>
<dt><code>Croptypes</code></dt><dd><p>a dataframe with three columns named 'croptypeID' for croptype index,
'cultivarID' for cultivar index and 'proportion' for the proportion of the cultivar within the croptype.
See <code><a href="#topic+loadCroptypes">loadCroptypes</a></code>, <code><a href="#topic+setCroptypes">setCroptypes</a></code> and <code><a href="#topic+allocateCroptypeCultivars">allocateCroptypeCultivars</a></code></p>
</dd>
<dt><code>Cultivars</code></dt><dd><p>a dataframe of parameters associated with each host genotype (i.e. cultivars, lines)
when cultivated in pure crops.See <code><a href="#topic+loadCultivar">loadCultivar</a></code> and <code><a href="#topic+setCultivars">setCultivars</a></code></p>
</dd>
<dt><code>CultivarsGenes</code></dt><dd><p>a list containing, for each host genotype, the indices of carried resistance genes.
See <code><a href="#topic+allocateCultivarGenes">allocateCultivarGenes</a></code></p>
</dd>
<dt><code>Genes</code></dt><dd><p>a data.frame of parameters associated with each resistance gene and with the evolution of
each corresponding pathogenicity gene. See <code><a href="#topic+loadGene">loadGene</a></code> and <code><a href="#topic+setGenes">setGenes</a></code></p>
</dd>
<dt><code>Pathogen</code></dt><dd><p>a list of i. pathogen aggressiveness parameters on a susceptible host
for a pathogen genotype not adapted to resistance and ii. sexual reproduction parameters. See <code><a href="#topic+loadPathogen">loadPathogen</a></code> and <code><a href="#topic+setPathogen">setPathogen</a></code></p>
</dd>
<dt><code>ReproSexProb</code></dt><dd><p>a vector of size TimeParam$nTSpY + 1 (end of season) of the probabilities for an infectious host to reproduce via sex rather
than via cloning at each step.</p>
</dd>
<dt><code>PI0</code></dt><dd><p>initial probability for the first host (whose index is 0) to be infectious (i.e. state I)
at the beginning of the simulation. Must be between 0 and 1. See <code><a href="#topic+setInoculum">setInoculum</a></code></p>
</dd>
<dt><code>DispHost</code></dt><dd><p>a vectorized matrix giving the probability of host dispersal
from any field of the landscape to any other field. See <code><a href="#topic+loadDispersalHost">loadDispersalHost</a></code> and <code><a href="#topic+setDispersalHost">setDispersalHost</a></code></p>
</dd>
<dt><code>DispPathoClonal</code></dt><dd><p>a vectorized matrix giving the probability of pathogen dispersal (clonal propagules)
from any field of the landscape to any other field. See <code><a href="#topic+loadDispersalPathogen">loadDispersalPathogen</a></code> and <code><a href="#topic+setDispersalPathogen">setDispersalPathogen</a></code></p>
</dd>
<dt><code>DispPathoSex</code></dt><dd><p>a vectorized matrix giving the probability of pathogen dispersal (sexual propagules)
from any field of the landscape to any other field. See <code><a href="#topic+loadDispersalPathogen">loadDispersalPathogen</a></code> and <code><a href="#topic+setDispersalPathogen">setDispersalPathogen</a></code></p>
</dd>
<dt><code>Treatment</code></dt><dd><p>a list of parameters to simulate the effect of chemical treatments on the pathogen,
see <code><a href="#topic+loadTreatment">loadTreatment</a></code> and <code><a href="#topic+setTreatment">setTreatment</a></code></p>
</dd>
<dt><code>OutputDir</code></dt><dd><p>the directory for simulation outputs</p>
</dd>
<dt><code>OutputGPKG</code></dt><dd><p>the name of the output GPKG file containing parameters of the deployment strategy</p>
</dd>
<dt><code>Outputs</code></dt><dd><p>a list of outputs parameters. See <code><a href="#topic+loadOutputs">loadOutputs</a></code> and <code><a href="#topic+setOutputs">setOutputs</a></code></p>
</dd>
<dt><code>TimeParam</code></dt><dd><p>a list of time parameters. See <code><a href="#topic+setTime">setTime</a></code></p>
</dd>
<dt><code>Seed</code></dt><dd><p>an integer used as seed value (for random number generator). See <code><a href="#topic+setTime">setTime</a></code></p>
</dd>
</dl>

<hr>
<h2 id='loadCroptypes'>Load Croptypes</h2><span id='topic+loadCroptypes'></span>

<h3>Description</h3>

<p>Creates a data.frame containing croptype parameters and filled with 0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadCroptypes(params, croptypeIDs = NULL, names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadCroptypes_+3A_params">params</code></td>
<td>
<p>a LandsepiParams Object.</p>
</td></tr>
<tr><td><code id="loadCroptypes_+3A_croptypeids">croptypeIDs</code></td>
<td>
<p>a vector of indices of croptypes (must start at 0 and match with
croptype IDs in the landscape)</p>
</td></tr>
<tr><td><code id="loadCroptypes_+3A_names">names</code></td>
<td>
<p>a vector containing the names of all croptypes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Croptypes need to be later updated with <code><a href="#topic+allocateCroptypeCultivars">allocateCroptypeCultivars</a></code>.
If neither croptypeIDs nor names are given, it will automatically generate
1 croptype per cultivar.
</p>


<h3>Value</h3>

<p>a data.frame with croptype parameters
</p>


<h3>See Also</h3>

<p><a href="#topic+setCroptypes">setCroptypes</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simul_params &lt;- createSimulParams()
cultivar1 &lt;- loadCultivar(name = "Susceptible", type = "wheat")
cultivar2 &lt;- loadCultivar(name = "Resistant1", type = "wheat")
cultivar3 &lt;- loadCultivar(name = "Resistant2", type = "wheat")
cultivars &lt;- data.frame(rbind(cultivar1, cultivar2, cultivar3), stringsAsFactors = FALSE)
simul_params &lt;- setCultivars(simul_params, cultivars)
croptypes &lt;- loadCroptypes(simul_params, names = c("Susceptible crop", "Mixture"))
croptypes

## End(Not run)
</code></pre>

<hr>
<h2 id='loadCultivar'>Load a cultivar</h2><span id='topic+loadCultivar'></span>

<h3>Description</h3>

<p>create a data.frame containing cultivar parameters depending of his type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadCultivar(name, type = "wheat")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadCultivar_+3A_name">name</code></td>
<td>
<p>a character string (without space) specifying the cultivar name.</p>
</td></tr>
<tr><td><code id="loadCultivar_+3A_type">type</code></td>
<td>
<p>the cultivar type, among: &quot;wheat&quot; (default), &quot;grapevine&quot;, &quot;banana&quot;, &quot;pepper&quot; or &quot;nonCrop&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> &quot;wheat&quot; is adapted to situations where the infection unit is a piece of leaf
(e.g. where a fungal lesion can develop); the number of available infection units
increasing during the season due to plant growth (as typified by cereal crops).
</p>
</li>
<li><p> &quot;grapevine&quot; corresponds to parameters for grapevine (including host growth).
</p>
</li>
<li><p> &quot;banana&quot; corresponds to parameters for banana (including host growth).
</p>
</li>
<li><p> &quot;pepper&quot; corresponds to situations where the infection unit is the whole plant
(e.g. for viral systemic infection); thus the number of infection units is constant.
</p>
</li>
<li><p> &quot;nonCrop&quot; is not planted, does not cost anything and does not yield anything
(e.g. forest, fallow).
</p>
</li></ul>



<h3>Value</h3>

<p>a dataframe of parameters associated with each host genotype
(i.e. cultivars, lines) when cultivated in pure crops.
</p>


<h3>See Also</h3>

<p><a href="#topic+setCultivars">setCultivars</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c1 &lt;- loadCultivar("winterWheat", type = "wheat")
c1
c2 &lt;- loadCultivar("forest", type = "nonCrop")
c2
</code></pre>

<hr>
<h2 id='loadDispersalHost'>Load a host dispersal matrix</h2><span id='topic+loadDispersalHost'></span>

<h3>Description</h3>

<p>It loads a vectorised diagonal matrix to simulate no host dispersal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadDispersalHost(params, type = "no")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadDispersalHost_+3A_params">params</code></td>
<td>
<p>a LandsepiParams Object.</p>
</td></tr>
<tr><td><code id="loadDispersalHost_+3A_type">type</code></td>
<td>
<p>a character string specifying the type of dispersal (&quot;no&quot; for no dispersal)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>as the size of the matrix depends on the number of polygons in the landscape,
the landscape must be defined before calling <code>loadDispersalHost</code>.
</p>


<h3>Value</h3>

<p>a vectorised dispersal matrix.
</p>


<h3>See Also</h3>

<p><a href="#topic+setDispersalHost">setDispersalHost</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simul_params &lt;- createSimulParams()
simul_params &lt;- setLandscape(simul_params, loadLandscape(1))
d &lt;- loadDispersalHost(simul_params)
d

## End(Not run)
</code></pre>

<hr>
<h2 id='loadDispersalPathogen'>Load pathogen dispersal matrices</h2><span id='topic+loadDispersalPathogen'></span>

<h3>Description</h3>

<p>It loads one of the five built-in vectorised dispersal matrices of rust fungi
associated with the five built-in landscapes. Landscape and DispersalPathogen ID must be
the same. And set a vectorized identity matrix for sexual reproduction dispersal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadDispersalPathogen(id = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadDispersalPathogen_+3A_id">id</code></td>
<td>
<p>a matrix ID between 1 to 5 (must match the ID of the landscape loaded with
<code><a href="#topic+loadLandscape">loadLandscape</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>landsepi</em> includes built-in dispersal matrices to represent rust dispersal in the
five built-in landscapes. These have been computed from a power-law dispersal kernel:
<code class="reqn"> g(d) = ((b-2)*(b-1) / (2*pi*a^2)) * (1 +  d/a)^{-b} </code>
with a=40 the scale parameter and b=7 a parameter related to the width of the dispersal kernel.
The expected mean dispersal distance is given by <code class="reqn"> 2*a /(b-3) = 20 m </code>.
</p>


<h3>Value</h3>

<p>a vectorised dispersal matrix representing the dispersal of clonal propagules,
and a vectorised dispersal identity matrix for sexual propagules. All by columns.
</p>


<h3>See Also</h3>

<p><a href="#topic+dispP">dispP</a>, <a href="#topic+setDispersalPathogen">setDispersalPathogen</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- loadDispersalPathogen(1)
d
</code></pre>

<hr>
<h2 id='loadGene'>Load a gene</h2><span id='topic+loadGene'></span>

<h3>Description</h3>

<p>Creates a data.frame containing parameters of a gene depending of his type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadGene(name, type = "majorGene")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadGene_+3A_name">name</code></td>
<td>
<p>name of the gene</p>
</td></tr>
<tr><td><code id="loadGene_+3A_type">type</code></td>
<td>
<p>type of the gene: &quot;majorGene&quot;, &quot;APR&quot;, &quot;QTL&quot; or &quot;immunity&quot; (default = &quot;majorGene&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> &quot;majorGene&quot; means a completely efficient gene that can be broken down via a single
pathogen mutation
</p>
</li>
<li><p> &quot;APR&quot; means a major gene that is active only after a delay of 30 days after planting
</p>
</li>
<li><p> &quot;QTL&quot; means a partial resistance (50% efficiency) that requires several pathogen mutations
to be completely eroded
</p>
</li>
<li><p> &quot;immunity&quot; means a completely efficient resistance that the pathogen has no way to adapt
(i.e. the cultivar is non-host).
</p>
</li></ul>

<p>For different scenarios, the data.frame can be manually updated later.
</p>


<h3>Value</h3>

<p>a data.frame with gene parameters
</p>


<h3>See Also</h3>

<p><a href="#topic+setGenes">setGenes</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene1 &lt;- loadGene(name = "MG 1", type = "majorGene")
gene1
gene2 &lt;- loadGene(name = "Lr34", type = "APR")
gene2
</code></pre>

<hr>
<h2 id='loadInoculum'>Load Inoculum</h2><span id='topic+loadInoculum'></span>

<h3>Description</h3>

<p>Loads an inoculum for the beginning of the simulation (t=0), with
controlled localisation (polygons), infected cultivars and pathogen genotypes.
Note that landscape, gene, cultivar and croptype parameters must be set before
loading the inoculum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadInoculum(
  params,
  pI0_all = NULL,
  pI0_host = NULL,
  pI0_patho = NULL,
  pI0_poly = NULL,
  pI0_mat = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadInoculum_+3A_params">params</code></td>
<td>
<p>a LandsepiParams object.</p>
</td></tr>
<tr><td><code id="loadInoculum_+3A_pi0_all">pI0_all</code></td>
<td>
<p>a numeric indicating the (same) probability to infect a host for all
pathogen genotypes, all cultivars and in all polygons</p>
</td></tr>
<tr><td><code id="loadInoculum_+3A_pi0_host">pI0_host</code></td>
<td>
<p>a vector of length Nhost indicating the probabilities to infect an host,
for each cultivar (for all pathogen genotypes and all polygons).</p>
</td></tr>
<tr><td><code id="loadInoculum_+3A_pi0_patho">pI0_patho</code></td>
<td>
<p>a vector of length Npatho indicating the probabilities to infect an host,
for each pathogen genotype (for all cultivars and all polygons).</p>
</td></tr>
<tr><td><code id="loadInoculum_+3A_pi0_poly">pI0_poly</code></td>
<td>
<p>a vector of length Npoly indicating the probabilities to infect an host,
for each polygon (for all pathogen genotypes and all cultivars).</p>
</td></tr>
<tr><td><code id="loadInoculum_+3A_pi0_mat">pI0_mat</code></td>
<td>
<p>a 3D array of dimensions (1:Nhost,1:Npatho,1:Npoly) indicating the
probability to infect an host, for each cultivar, pathogen genotype and polygon.
Note that <code>pI0_all</code>, <code>pI0_host</code>, <code>pI0_patho</code> and <code>pI0_poly</code>
are not accounted if <code>pI0_mat</code> is filled.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The different options enable different types of inoculum (localisation,
infected cultivars and pathogen genetic diversity,
see different options in Examples).<br />
Unless the array <code>pI0_mat</code> is filled, the probability for a host to be infected
at the beginning of the simulation is computed in every polygon (poly), cultivar (host)
and pathogen genotype (patho) with
<code>pI0[host, patho, poly] = pI0_all * pI0_patho[patho] * pI0_host[host] * pI0_poly[poly]</code>. <br />
Before loading the inoculum, one can use
<code>getMatrixGenePatho()</code>, <code>getMatrixCultivarPatho()</code> and <code>getMatrixCroptypePatho()</code>
to acknowledge which pathogen genotypes are adapted to which genes, cultivars and croptypes.<br />
Once <code>setInoculum()</code> is used, one can call <code>inoculumToMatrix()</code> to get the inoculum
as a 3D array (1:Nhost,1:Npatho,1:Npoly)<br />
</p>


<h3>Value</h3>

<p>a 3D array of dimensions (1:Nhost,1:Npatho,1:Npoly)
</p>


<h3>See Also</h3>

<p><a href="#topic+inoculumToMatrix">inoculumToMatrix</a>, <a href="#topic+getMatrixGenePatho">getMatrixGenePatho</a>, <a href="#topic+getMatrixCultivarPatho">getMatrixCultivarPatho</a>,
<a href="#topic+getMatrixCroptypePatho">getMatrixCroptypePatho</a>, <a href="#topic+setInoculum">setInoculum</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simul_params &lt;- createSimulParams()
simul_params &lt;- setTime(simul_params, Nyears = 1, nTSpY = 80)
basic_patho_param &lt;- loadPathogen(disease = "rust")
simul_params &lt;- setPathogen(simul_params, patho_params = basic_patho_param)
simul_params &lt;- setLandscape(simul_params, loadLandscape(id = 1))
simul_params &lt;- setDispersalPathogen(simul_params, loadDispersalPathogen(id = 1)[[1]])
gene1 &lt;- loadGene(name = "MG 1", type = "majorGene")
gene2 &lt;- loadGene(name = "MG 2", type = "majorGene")
genes &lt;- data.frame(rbind(gene1, gene2), stringsAsFactors = FALSE)
simul_params &lt;- setGenes(simul_params, genes)
cultivar1 &lt;- loadCultivar(name = "Susceptible", type = "wheat")
cultivar2 &lt;- loadCultivar(name = "Resistant", type = "wheat")
cultivars &lt;- data.frame(rbind(cultivar1, cultivar2), stringsAsFactors = FALSE)
simul_params &lt;- setCultivars(simul_params, cultivars)
simul_params &lt;- allocateCultivarGenes(simul_params, "Resistant", c("MG 1", "MG 2"))
croptypes &lt;- loadCroptypes(simul_params, names = c("Susceptible crop", "Resistant crop"))
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Susceptible crop", "Susceptible")
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Resistant crop", c("Resistant"))
simul_params &lt;- setCroptypes(simul_params, croptypes)
simul_params &lt;- allocateLandscapeCroptypes(simul_params, rotation_period = 0
, rotation_sequence = croptypes$croptypeID
, prop = c(1/2,1/2), aggreg = 1, graphic = FALSE)

#### Definition of the inoculum ####

### Scenario 1. Only the avirulent pathogen on the susceptible cultivar ###
# In this situation, the susceptible cultivar must be entered
# at the first line of the table cultivars

## Global inoculum (i.e. in the whole landscape)
# Option 1: simply use the default parameterisation
simul_params &lt;- setInoculum(simul_params, 5E-4)

# Option 2: use loadInoculum()
Npatho &lt;- prod(simul_params@Genes$Nlevels_aggressiveness)
Nhost &lt;- nrow(simul_params@Cultivars)
pI0 &lt;- loadInoculum(simul_params,
                    pI0_all=5E-4,
                    pI0_host=c(1,rep(0, Nhost-1)),
                    pI0_patho=c(1,rep(0, Npatho-1)))
simul_params &lt;- setInoculum(simul_params, pI0)
inoculumToMatrix(simul_params)

## Local inoculum (i.e. in some random polygons only)
Npatho &lt;- prod(simul_params@Genes$Nlevels_aggressiveness)
Nhost &lt;- nrow(simul_params@Cultivars)
Npoly &lt;- nrow(simul_params@Landscape)
Npoly_inoc &lt;- 5  ## number of inoculated polygons
## whether the avr pathogen can infect the polygons
compatible_poly &lt;- getMatrixPolyPatho(simul_params)[,1]
## random polygon picked among compatible ones
id_poly &lt;- sample(grep(1, compatible_poly), Npoly_inoc)
pI0_poly &lt;- as.numeric(1:Npoly %in% id_poly)  
pI0 &lt;- loadInoculum(simul_params,
                    pI0_all=5E-4,
                    pI0_host=c(1,rep(0, Nhost-1)),
                    pI0_patho=c(1,rep(0, Npatho-1)), 
pI0_poly=pI0_poly)
simul_params &lt;- setInoculum(simul_params, pI0)
inoculumToMatrix(simul_params)

### Scenario 2. Diversity of pathogen genotypes in the inoculum ###
# in this example,  Nhost=2 cultivars, Npatho=4

## Global inoculum (i.e. in all polygons of the landscape)
pI0 &lt;- loadInoculum(simul_params, pI0_patho=c(1E-3,1E-4,1E-4,1E-5), pI0_host=c(1,1))
simul_params &lt;- setInoculum(simul_params, pI0)
inoculumToMatrix(simul_params)[,,1:5]

## Local inoculum (i.e. in some polygons only) ##
Npoly &lt;- nrow(simul_params@Landscape)
Npoly_inoc &lt;- 5  ## number of inoculated polygons 
id_poly &lt;- sample(1:Npoly, Npoly_inoc)  ## random polygon 
pI0_poly &lt;- as.numeric(1:Npoly %in% id_poly) 
pI0 &lt;- loadInoculum(simul_params, pI0_patho=c(1E-3,1E-4,1E-4,1E-5),
pI0_host=c(1,1), pI0_poly=pI0_poly)
simul_params &lt;- setInoculum(simul_params, pI0)
inoculumToMatrix(simul_params)

## End(Not run)
</code></pre>

<hr>
<h2 id='loadLandscape'>Load a landscape</h2><span id='topic+loadLandscape'></span>

<h3>Description</h3>

<p>Loads one of the five built-in landscapes simulated using a T-tesselation algorithm
and composed of 155, 154, 152, 153 and 156 polygons, respectively.
Each landscape is identified by a numeric from 1 to 5.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadLandscape(id = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadLandscape_+3A_id">id</code></td>
<td>
<p>a landscape ID between 1 to 5 (default = 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a landscape in sp format
</p>


<h3>See Also</h3>

<p><a href="#topic+landscapeTEST">landscapeTEST</a>, <a href="#topic+setLandscape">setLandscape</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>land &lt;- loadLandscape(1)
length(land)
</code></pre>

<hr>
<h2 id='loadOutputs'>Load outputs</h2><span id='topic+loadOutputs'></span>

<h3>Description</h3>

<p>Creates an output list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadOutputs(epid_outputs = "all", evol_outputs = "all", disease = "rust")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadOutputs_+3A_epid_outputs">epid_outputs</code></td>
<td>
<p>a character string (or a vector of character strings if several outputs
are to be computed) specifying the type of epidemiological and economic outputs to generate
(see details):</p>

<ul>
<li><p> &quot;audpc&quot; : Area Under Disease Progress Curve (average number of diseased host individuals
per time step and square meter)
</p>
</li>
<li><p> &quot;audpc_rel&quot; : Relative Area Under Disease Progress Curve (average proportion of
diseased host individuals relative to the total number of existing hosts)
</p>
</li>
<li><p> &quot;gla&quot; : Green Leaf Area (average number of healthy host individuals per time step and
square meter)
</p>
</li>
<li><p> &quot;gla_rel&quot; : Relative Green Leaf Area (average proportion of healthy host individuals
relative to the total number of existing hosts)
</p>
</li>
<li><p> &quot;eco_yield&quot; : total crop yield (in weight or volume units per ha)
</p>
</li>
<li><p> &quot;eco_cost&quot; : operational crop costs (in monetary units per ha)
</p>
</li>
<li><p> &quot;eco_product&quot; : total crop products (in monetary units per ha)
</p>
</li>
<li><p> &quot;eco_margin&quot; : Margin (products - operational costs, in monetary units per ha)
</p>
</li>
<li><p> &quot;contrib&quot;: contribution of pathogen genotypes to LIR dynamics
</p>
</li>
<li><p> &quot;HLIR_dynamics&quot;, &quot;H_dynamics&quot;, &quot;L_dynamics&quot;, &quot;IR_dynamics&quot;, &quot;HLI_dynamics&quot;, etc.:
Epidemic dynamics related to the specified sanitary status (H, L, I or R and all their
combinations). Graphics only, works only if graphic=TRUE.
</p>
</li>
<li><p> &quot;all&quot; : compute all these outputs (default)
</p>
</li>
<li><p> &quot;&quot; : none of these outputs will be generated.
</p>
</li></ul>
</td></tr>
<tr><td><code id="loadOutputs_+3A_evol_outputs">evol_outputs</code></td>
<td>
<p>a character string (or a vector of character strings if several
outputs are to be computed) specifying the type of evolutionary outputs to generate :</p>

<ul>
<li><p> &quot;evol_patho&quot;: Dynamics of pathogen genotype frequencies
</p>
</li>
<li><p> &quot;evol_aggr&quot;: Evolution of pathogen aggressiveness
</p>
</li>
<li><p> &quot;durability&quot;: Durability of resistance genes
</p>
</li>
<li><p> &quot;all&quot;: compute all these outputs (default)
</p>
</li>
<li><p> &quot;&quot;: none of these outputs will be generated.
</p>
</li></ul>
</td></tr>
<tr><td><code id="loadOutputs_+3A_disease">disease</code></td>
<td>
<p>a disease name, among &quot;rust&quot; (default), &quot;mildew&quot;, &quot;sigatoka&quot; and &quot;no pathogen&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of outputs and parameters for output generation
</p>


<h3>See Also</h3>

<p><a href="#topic+setOutputs">setOutputs</a>, <a href="#topic+compute_audpc100S">compute_audpc100S</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>outputList &lt;- loadOutputs(epid_outputs = "audpc", evol_outputs = "durability")
outputList
</code></pre>

<hr>
<h2 id='loadPathogen'>Load pathogen parameters</h2><span id='topic+loadPathogen'></span>

<h3>Description</h3>

<p>Loads default pathogen parameters for a specific disease
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadPathogen(disease = "rust")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadPathogen_+3A_disease">disease</code></td>
<td>
<p>a disease name, among &quot;rust&quot; (default), &quot;mildew&quot;, &quot;sigatoka&quot; and &quot;no pathogen&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available diseases:
</p>

<ul>
<li><p> &quot;no pathogen&quot;
</p>
</li>
<li><p> &quot;rust&quot; (genus <em>Puccinia</em>, e.g. stripe rust, stem rust and leaf rust of wheat and barley)
</p>
</li>
<li><p> &quot;mildew&quot; (<em>Plasmopara viticola</em>, downy mildew of grapevine)
</p>
</li>
<li><p> &quot;sigatoka&quot; (<em>Pseudocercospora fijiensis</em>, black sigatoka of banana)
Note that when disease = &quot;mildew&quot; a price reduction between 0% and 5% is applied to the
market value according to disease severity.
</p>
</li></ul>



<h3>Value</h3>

<p>a list of pathogen parameters on a susceptible host
for a pathogen genotype not adapted to resistance
</p>


<h3>See Also</h3>

<p><a href="#topic+setPathogen">setPathogen</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>basic_patho_params &lt;- loadPathogen()
basic_patho_params
</code></pre>

<hr>
<h2 id='loadSimulParams'>Load simulation parameters</h2><span id='topic+loadSimulParams'></span>

<h3>Description</h3>

<p>Loads a GPKG file from the output of a landsepi simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadSimulParams(inputGPKG = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadSimulParams_+3A_inputgpkg">inputGPKG</code></td>
<td>
<p>name of the GPKG file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+saveDeploymentStrategy">saveDeploymentStrategy</a></code>.
</p>


<h3>Value</h3>

<p>a LandsepiParams object.
</p>

<hr>
<h2 id='loadTreatment'>Load treatment parameters</h2><span id='topic+loadTreatment'></span>

<h3>Description</h3>

<p>Loads a list of treatment parameters for a specific disease (initialised at 0
, i.e. absence of treatments)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadTreatment(disease = "no pathogen")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadTreatment_+3A_disease">disease</code></td>
<td>
<p>a disease name, among &quot;mildew&quot;, &quot;sigatoka&quot; and &quot;no pathogen&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Chemical treatment is applied in a polygon only if disease severity (i.e. I/N) in
this polygon exceeds the threshold given by <code>treatment_application_threshold</code>.
Treatment efficiency is maximum (i.e. equal to the parameter treatment_efficiency)
at the time of treatment application (noted <code class="reqn">t*</code>); then it decreases with time
(i.e. natural pesticide degradation) and host growth (i.e. new biomass is not protected
by treatments):                                                                                                                                                                                     protected by treatments):Efficiency of the treatment at time t after the application date is given by:
<code class="reqn"> efficiency(t) = treatment\_efficiency / (1 + exp(a-b*C(t))) </code>
with <code class="reqn"> C(t)= C_1 * C_2</code>: </p>

<ul>
<li><p><code class="reqn">C_1 = exp(- treatment\_degradation\_rate * \Delta t) </code> is the reduction of
fungicide concentration due to time (e.g. natural degradation, volatilization, weathering),
with <code class="reqn">\Delta t = t - t*</code> the timelag passed since the time of
treatment application.
</p>
</li>
<li> <p><code class="reqn"> C_2 = min(1, N(t*) / N(t)) </code> is the reduction of fungicide concentration due
to plant growth, since new plant tissue is not covered by fungicide.
<code class="reqn">N(t*)</code> and <code class="reqn">N(t)</code> being the number of
host individuals  a the time of treatment <code class="reqn">t*</code> and at time <code class="reqn">t</code>, respectively.
</p>
</li>
<li> <p><code class="reqn">a \in [3.5 ; 4.5]</code> and <code class="reqn">b \in [8 ; 9]</code> are shape parameters.
</p>
</li></ul>



<h3>Value</h3>

<p>a list of treatment parameters:
</p>

<ul>
<li><p> treatment_degradation_rate = degradation rate (per time step) of chemical concentration,
</p>
</li>
<li><p> treatment_efficiency = maximal efficiency of chemical treatments (i.e. fractional reduction
of pathogen infection rate at the time of application),
</p>
</li>
<li><p> treatment_timesteps = vector of time steps corresponding to treatment application dates,
</p>
</li>
<li><p> treatment_cultivars = vector of indices of the cultivars that receive treatments,
</p>
</li>
<li><p> treatment_cost = cost of a single treatment application (monetary units/ha)
</p>
</li>
<li><p> treatment_application_threshold = vector of thresholds (i.e. disease severity, one
for each treated cultivar) above which the treatment is applied in a polygon.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+setTreatment">setTreatment</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>treat &lt;- loadTreatment("sigatoka")
treat
</code></pre>

<hr>
<h2 id='logit'>Logit function</h2><span id='topic+logit'></span>

<h3>Description</h3>

<p>Given a numeric object, return the logit of the values. Missing values (NAs) are allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logit_+3A_x">x</code></td>
<td>
<p>a numeric object containing values between 0 and 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The logit is defined by <code class="reqn"> log(x/(1-x)) </code>. Values in x of 0 or 1 return logits of -Inf or Inf respectively.
Any NAs in the input will also be NAs in the output.
</p>


<h3>Value</h3>

<p>An object of the same type as x containing the logits of the input values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logit(0.5)
</code></pre>

<hr>
<h2 id='model_landsepi'>Model for Landscape Epidemiology &amp; Evolution</h2><span id='topic+model_landsepi'></span>

<h3>Description</h3>

<p>Stochastic, spatially-explicit, demo-genetic model simulating the spread and evolution of a
plant pathogen in a heterogeneous landscape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_landsepi(
  time_param,
  area_vector,
  rotation_matrix,
  croptypes_cultivars_prop,
  dispersal,
  inits,
  seed,
  cultivars_param,
  basic_patho_param,
  genes_param,
  treatment_param
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_landsepi_+3A_time_param">time_param</code></td>
<td>
<p>list of simulation parameters:</p>

<ul>
<li><p> Nyears = number cropping seasons,
</p>
</li>
<li><p> nTSpY = number of time-steps per cropping season.
</p>
</li></ul>
</td></tr>
<tr><td><code id="model_landsepi_+3A_area_vector">area_vector</code></td>
<td>
<p>a vector containing areas of polygons (i.e. fields), in surface units.</p>
</td></tr>
<tr><td><code id="model_landsepi_+3A_rotation_matrix">rotation_matrix</code></td>
<td>
<p>a matrix containing for each field (rows) and year (columns, named &quot;year_1&quot;, &quot;year_2&quot;, etc.),
the index of the cultivated croptype. Importantly, the matrix must contain 1 more column than the real number
of simulated years.</p>
</td></tr>
<tr><td><code id="model_landsepi_+3A_croptypes_cultivars_prop">croptypes_cultivars_prop</code></td>
<td>
<p>a matrix with three columns named 'croptypeID' for croptype index,
'cultivarID' for cultivar index and 'proportion' for the proportion of the cultivar within the croptype.</p>
</td></tr>
<tr><td><code id="model_landsepi_+3A_dispersal">dispersal</code></td>
<td>
<p>list of dispersal parameters:</p>

<ul>
<li><p> disp_patho_clonal = vectorised dispersal matrix of the pathogen (clonal propagules),
</p>
</li>
<li><p> disp_patho_sex = vectorised dispersal matrix of the pathogen (sexual propagules),
</p>
</li>
<li><p> disp_host = vectorised dispersal matrix of the host.
</p>
</li></ul>
</td></tr>
<tr><td><code id="model_landsepi_+3A_inits">inits</code></td>
<td>
<p>list of initial conditions:</p>

<ul>
<li><p> pI0 = vector of length Npoly<em>Npatho</em>Nhost giving the probability to be infectious (i.e. state I) at
t=0 pr each polygon, pathogen genotype and host.
</p>
</li></ul>
</td></tr>
<tr><td><code id="model_landsepi_+3A_seed">seed</code></td>
<td>
<p>seed (for random number generation).</p>
</td></tr>
<tr><td><code id="model_landsepi_+3A_cultivars_param">cultivars_param</code></td>
<td>
<p>list of parameters associated with each host genotype (i.e. cultivars)
when cultivated in pure crops:</p>

<ul>
<li><p> initial_density = vector of host densities (per surface unit) at the beginning of the cropping season,
</p>
</li>
<li><p> max_density = vector of maximum host densities (per surface unit) at the end of the cropping season,
</p>
</li>
<li><p> growth rate = vector of host growth rates,
</p>
</li>
<li><p> reproduction rate = vector of host reproduction rates,
</p>
</li>
<li><p> relative_yield_H = Yield of H individuals relative to H individuals (100%)
</p>
</li>
<li><p> relative_yield_L = Yield of L individuals relative to H individuals
</p>
</li>
<li><p> relative_yield_I = Yield of I individuals relative to H individuals
</p>
</li>
<li><p> relative_yield_R = Yield of R individuals relative to H individuals
</p>
</li>
<li><p> sigmoid_kappa_host = kappa parameter for the sigmoid invasion function (for host dispersal),
</p>
</li>
<li><p> sigmoid_sigma_host = sigma parameter for the sigmoid invasion function (for host dispersal),
</p>
</li>
<li><p> sigmoid_plateau_host = plateau parameter for the sigmoid invasion function (for host dispersal),
</p>
</li>
<li><p> cultivars_genes_list = a list containing, for each host genotype, the indices of carried resistance genes,
</p>
</li></ul>
</td></tr>
<tr><td><code id="model_landsepi_+3A_basic_patho_param">basic_patho_param</code></td>
<td>
<p>list of i. pathogen aggressiveness parameters on a susceptible host
for a pathogen genotype not adapted to resistance and ii. sexual reproduction parameters: </p>

<ul>
<li><p> infection_rate = maximal expected infection rate of a propagule on a healthy host,
</p>
</li>
<li><p> propagule_prod_rate = maximal expected reproduction_rate of an infectious host per timestep,
</p>
</li>
<li><p> latent_period_mean = minimal expected duration of the latent period,
</p>
</li>
<li><p> latent_period_var = variance of the latent period duration,
</p>
</li>
<li><p> infectious_period_mean = maximal expected duration of the infectious period,
</p>
</li>
<li><p> infectious_period_var = variance of the infectious period duration,
</p>
</li>
<li><p> survival_prob = matrix giving the probability for a propagule to survive the off-season, for each croptype (rows) and each year (columns)
</p>
</li>
<li><p> repro_sex_prob = vector of probabilities for an infectious host to reproduce via sex rather than via cloning for each timestep,
</p>
</li>
<li><p> sigmoid_kappa = kappa parameter of the sigmoid contamination function,
</p>
</li>
<li><p> sigmoid_sigma = sigma parameter of the sigmoid contamination function,
</p>
</li>
<li><p> sigmoid_plateau = plateau parameter of the sigmoid contamination function,
</p>
</li>
<li><p> sex_propagule_viability_limit = maximum number of cropping seasons up to which a sexual propagule is viable
</p>
</li>
<li><p> sex_propagule_release_mean = average number of cropping seasons after which a sexual propagule is released.
</p>
</li>
<li><p> clonal_propagule_gradual_release = whether or not clonal propagules surviving the bottleneck are gradually released along the following cropping season.
</p>
</li></ul>
</td></tr>
<tr><td><code id="model_landsepi_+3A_genes_param">genes_param</code></td>
<td>
<p>list of parameters associated with each resistance gene and with the evolution of
each corresponding pathogenicity gene:</p>

<ul>
<li><p> target_trait = vector of aggressiveness components (IR, LAT, IP, or PR) targeted by resistance genes,
</p>
</li>
<li><p> efficiency = vector of resistance gene efficiencies (percentage of reduction of the targeted
aggressiveness component: IR, 1/LAT, IP and PR),
</p>
</li>
<li><p> age_of_activ_mean = vector of expected delays to resistance activation (for APRs),
</p>
</li>
<li><p> age_of_activ_var = vector of variances of the delay to resistance activation (for APRs),
</p>
</li>
<li><p> mutation_prob = vector of mutation probabilities for pathogenicity genes (each of them corresponding to a resistance gene),
</p>
</li>
<li><p> Nlevels_aggressiveness = vector of number of adaptation levels related to each resistance gene (i.e. 1 + number
of required mutations for a pathogenicity gene to fully adapt to the corresponding resistance gene),
</p>
</li>
<li><p> adaptation_cost = vector of adaptation penalties paid by pathogen genotypes fully adapted
to the considered resistance genes on all hosts,
</p>
</li>
<li><p> relative_advantage = vector of fitness advantages of a pathogen genotype fully adapted to the resistance genes
on hosts carrying these genes, relative to those that do not carry these genes,
</p>
</li>
<li><p> tradeoff_strength = vector of strengths of the trade-off relationships between the level of aggressiveness
on hosts that do and do not carry the resistance genes.
</p>
</li></ul>
</td></tr>
<tr><td><code id="model_landsepi_+3A_treatment_param">treatment_param</code></td>
<td>
<p>list of parameters related to pesticide treatments: </p>

<ul>
<li><p> treatment_degradation_rate = degradation rate (per time step) of chemical concentration,
</p>
</li>
<li><p> treatment_efficiency = maximal efficiency of chemical treatments (i.e. fractional reduction
of pathogen infection rate at the time of application),
</p>
</li>
<li><p> treatment_timesteps = vector of time-steps corresponding to treatment application dates,
</p>
</li>
<li><p> treatment_cultivars = vector of indices of the cultivars that receive treatments,
</p>
</li>
<li><p> treatment_cost = cost of a single treatment application (monetary units/ha),
</p>
</li>
<li><p> treatment_application_threshold = vector of thresholds (i.e. disease severity, one for each treated cultivar) above which the treatment is applied
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>?landsepi</code> for details on the model and assumptions.
Briefly, the model is stochastic, spatially explicit (the basic spatial unit is an individual field), based on a SEIR
(‘susceptible-exposed-infectious-removed’, renamed HLIR for 'healthy-latent-infectious-removed' to avoid confusions
with 'susceptible host') structure with a discrete time step. It simulates the spread and
evolution (via mutation, recombination through sexual reproduction, selection and drift)
of a pathogen in a heterogeneous cropping landscape, across cropping seasons split by host harvests which impose
potential bottlenecks to the pathogen. A wide array of resistance deployment strategies
(possibly including chemical treatments) can be simulated.
</p>


<h3>Value</h3>

<p>A set of binary files is generated for every year of simulation and every compartment:
</p>

<ul>
<li><p> H: healthy hosts,
</p>
</li>
<li><p> Hjuv: juvenile healthy hosts (for host reproduction),
</p>
</li>
<li><p> L: latently infected hosts,
</p>
</li>
<li><p> I: infectious hosts,
</p>
</li>
<li><p> R: removed hosts,
</p>
</li>
<li><p> P: propagules.</p>
</li></ul>

<p>Each file indicates for every time-step the number of individuals in each field, and when
appropriate for each host and pathogen genotypes). Additionally, a binary file called TFI is
generated and gives the Treatment Frequency Indicator (expressed as the number of treatment applications
per polygon).
</p>


<h3>References</h3>

<p>Rimbaud L., Papaïx J., Rey J.-F., Barrett L. G. and Thrall P. H. (2018).
Assessing the durability andefficiency of landscape-based strategies to deploy plant
resistance to pathogens. <em>PLoS Computational Biology</em> 14(4):e1006067.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#### Spatially-implicit simulation with 2 patches (S + R) during 3 years ####

## Simulation parameters
time_param &lt;- list(Nyears=3, nTSpY=120)
Npoly=2
Npatho=2
area &lt;- c(100000, 100000)
basic_patho_param &lt;- loadPathogen(disease = "rust")
basic_patho_param$repro_sex_prob &lt;- rep(0, time_param$nTSpY+1)
     cultivars &lt;- as.list(rbind(loadCultivar(name="Susceptible", type="growingHost")
, loadCultivar(name="Resistant", type="growingHost")))
names(cultivars)[names(cultivars)=="cultivarName"] &lt;- "name"
yield0 &lt;- cultivars$yield_H + as.numeric(cultivars$yield_H==0)
cultivars &lt;- c(cultivars, list(relative_yield_H = as.numeric(cultivars$yield_H / yield0)
, relative_yield_L = as.numeric(cultivars$yield_L / yield0)
, relative_yield_I = as.numeric(cultivars$yield_I / yield0)
, relative_yield_R = as.numeric(cultivars$yield_R / yield0)
, sigmoid_kappa_host=0.002, sigmoid_sigma_host=1.001, sigmoid_plateau_host=1
, cultivars_genes_list=list(numeric(0),0)))
rotation &lt;- data.frame(year_1=c(0,1), year_2=c(0,1), year_3=c(0,1), year_4=c(0,1))
croptypes_cultivars_prop &lt;- data.frame(croptypeID=c(0,1), cultivarID=c(0,1), proportion=c(1,1))
genes &lt;- as.list(loadGene(name="MG", type="majorGene"))
treatment=list(treatment_degradation_rate=0.1,
treatment_efficiency=0, 
treatment_timesteps=logical(0),
treatment_cultivars=logical(0),
treatment_cost=0,
treatment_application_threshold = logical(0))
  
## run simulation
model_landsepi(seed=1,
time_param = time_param,
basic_patho_param = basic_patho_param,
inits = list(pI0=c(0.1, rep(0, 7))),
area_vector = area,
dispersal = list(disp_patho_clonal=c(0.99,0.01,0.01,0.99),
disp_patho_sex=c(1,0,0,1),
disp_host=c(1,0,0,1)),
rotation_matrix = as.matrix(rotation),
croptypes_cultivars_prop = as.matrix(croptypes_cultivars_prop),
cultivars_param = cultivars, 
genes_param = genes,
treatment_param = treatment)

## Compute outputs
eco_param &lt;- list(yield_perHa = cbind(H = as.numeric(cultivars$relative_yield_H),
L = as.numeric(cultivars$relative_yield_L),
I = as.numeric(cultivars$relative_yield_I),
R = as.numeric(cultivars$relative_yield_R)),
planting_cost_perHa = as.numeric(cultivars$planting_cost),
market_value = as.numeric(cultivars$market_value))

evol_res &lt;- evol_output(, time_param, Npoly, cultivars, genes)
epid_res &lt;-  epid_output(, time_param, Npatho, area, rotation
, croptypes_cultivars_prop, cultivars, eco_param, treatment, basic_patho_param)



#### 1-year simulation of a rust epidemic in pure susceptible crop in a single 1-km2 patch ####
## Simulation and pathogen parameters
time_param &lt;- list(Nyears=1, nTSpY=120)
area &lt;- c(1E6)
basic_patho_param = loadPathogen(disease = "rust")
basic_patho_param$repro_sex_prob &lt;- rep(0, time_param$nTSpY+1)
## croptypes, cultivars and genes
rotation &lt;- data.frame(year_1=c(0), year_2=c(0))
croptypes_cultivars_prop &lt;- data.frame(croptypeID=c(0), cultivarID=c(0), proportion=c(1))
       cultivars &lt;- as.list(rbind(loadCultivar(name="Susceptible", type="growingHost")))
names(cultivars)[names(cultivars)=="cultivarName"] &lt;- "name"
yield0 &lt;- cultivars$yield_H + as.numeric(cultivars$yield_H==0)
cultivars &lt;- c(cultivars, list(relative_yield_H = as.numeric(cultivars$yield_H / yield0)
, relative_yield_L = as.numeric(cultivars$yield_L / yield0)
    , relative_yield_I = as.numeric(cultivars$yield_I / yield0)
, relative_yield_R = as.numeric(cultivars$yield_R / yield0)
, sigmoid_kappa_host=0.002, sigmoid_sigma_host=1.001, sigmoid_plateau_host=1
, cultivars_genes_list=list(numeric(0))))
genes &lt;-   list(geneName = character(0) , adaptation_cost = numeric(0)
, relative_advantage = numeric(0)
, mutation_prob = numeric(0)
, efficiency = numeric(0) , tradeoff_strength = numeric(0)
, Nlevels_aggressiveness = numeric(0)
, age_of_activ_mean = numeric(0) , age_of_activ_var = numeric(0)
, target_trait = character(0)
, recombination_sd = numeric(0))
treatment=list(treatment_degradation_rate=0.1
                              , treatment_efficiency=0
, treatment_timesteps=logical(0)
, treatment_cultivars=logical(0)
, treatment_cost=0
, treatment_application_threshold = logical(0))

## run simulation
model_landsepi(seed=1, time_param = time_param
, basic_patho_param = basic_patho_param
, inits = list(pI0=5E-4), area_vector = area
, dispersal = list(disp_patho_clonal=c(1), disp_patho_sex=c(1), disp_host=c(1))
, rotation_matrix = as.matrix(rotation)
, treatment_param = treatment
                                , croptypes_cultivars_prop = as.matrix(croptypes_cultivars_prop)
, cultivars_param = cultivars,  genes_param = genes)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='multiN'>Allocation of cultivars</h2><span id='topic+multiN'></span>

<h3>Description</h3>

<p>Algorithm based on latent Gaussian fields to allocate two different types of crops across
a landscape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiN(d, area, prop, range = 0, algo = "random")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multiN_+3A_d">d</code></td>
<td>
<p>a symmetric matrix of the pairwise distances between the centroids of the fields of the landscape.</p>
</td></tr>
<tr><td><code id="multiN_+3A_area">area</code></td>
<td>
<p>vector containing field areas.</p>
</td></tr>
<tr><td><code id="multiN_+3A_prop">prop</code></td>
<td>
<p>proportion of landscape surface covered by the second type of crop.</p>
</td></tr>
<tr><td><code id="multiN_+3A_range">range</code></td>
<td>
<p>range of spatial autocorrelation between fields (must be greater or equal 0). The greater
the value of range, the higher the degree of spatial aggregation (roughly, range between 0 and 0.1 for
fragmented landscapes, between 0.1 and 0.5 for balanced
landscapes, between 0.5 and 3 for aggregated landscapes, and above 3 for highly aggregated landscapes).</p>
</td></tr>
<tr><td><code id="multiN_+3A_algo">algo</code></td>
<td>
<p>the algorithm used for the computation of the variance-covariance matrix of the multivariate
normal distribution: &quot;exp&quot; for exponential function, &quot;periodic&quot; for periodic function,
&quot;random&quot; for random draw (see details). If algo=&quot;random&quot;, the parameter range is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm allows the control of the proportions of each type of crop in terms of surface
coverage, and their level of spatial aggregation. A random vector of values is drawn from a multivariate
normal distribution with expectation 0 and a variance-covariance matrix which depends on the pairwise
distances between the centroids of the fields. Two different functions allow the computation of the
variance-covariance matrix to allocate crops with more or less spatial aggregation (depending on the
value of the range parameter). The exponential function codes for an exponential decay of the spatial
autocorrelation as distance between fields increases. The periodic function codes for a periodic fluctuation
of the spatial autocorrelation as distance between fields increases. Alternatively, a normal distribution
can be used for a random allocation of the types of crops.
Next, the two types of crops are allocated to different fields depending on whether
the value drawn from the multivariate normal distribution is above or below a threshold. The proportion
of each type of crop in the landscape is controlled by the value of this threshold (parameter prop).
</p>


<h3>Value</h3>

<p>A dataframe containing the index of each field (column 1) and the index (0 or 1) of the type
of crop grown on these fields (column 2).
</p>


<h3>See Also</h3>

<p><a href="#topic+AgriLand">AgriLand</a>, <a href="#topic+allocateLandscapeCroptypes">allocateLandscapeCroptypes</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
d &lt;- matrix(rpois(100, 100), nrow = 10)
d &lt;- d + t(d) ## ensures that d is symmetric
area &lt;- data.frame(id = 1:10, area = 10)
multiN(d, area, prop = 0.5, range = 0.5, algo = "periodic")

## End(Not run)
</code></pre>

<hr>
<h2 id='periodic_cov'>Periodic covariance function</h2><span id='topic+periodic_cov'></span>

<h3>Description</h3>

<p>Periodic function used to compute the variance-covariance matrix of the fields of the landscape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>periodic_cov(d, range, phi = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="periodic_cov_+3A_d">d</code></td>
<td>
<p>a numeric object containing pairwise distances between the centroids of the fields</p>
</td></tr>
<tr><td><code id="periodic_cov_+3A_range">range</code></td>
<td>
<p>range (half-period of oscillations)</p>
</td></tr>
<tr><td><code id="periodic_cov_+3A_phi">phi</code></td>
<td>
<p>amplitude of the oscillations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The periodic covariance is defined by <code class="reqn"> exp(-2 * sin(d*pi/(2*range))^2 / phi^2) </code>. It is used to generate
highly fragmented or highly aggregated landscapes.
</p>


<h3>Value</h3>

<p>An object of the same type as d.
</p>


<h3>See Also</h3>

<p><a href="#topic+multiN">multiN</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>periodic_cov(10, range = 5)
</code></pre>

<hr>
<h2 id='plot_allocation'>Plotting allocation of croptypes in a landscape</h2><span id='topic+plot_allocation'></span>

<h3>Description</h3>

<p>Plots croptype allocation in the landscape at a given year of the simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_allocation(
  landscape,
  year,
  croptype_names = c(),
  title = "",
  subtitle = "",
  filename = "landscape.png"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_allocation_+3A_landscape">landscape</code></td>
<td>
<p>a SpatialPolygonsDataFrame</p>
</td></tr>
<tr><td><code id="plot_allocation_+3A_year">year</code></td>
<td>
<p>year to be plotted</p>
</td></tr>
<tr><td><code id="plot_allocation_+3A_croptype_names">croptype_names</code></td>
<td>
<p>croptype names (for legend)</p>
</td></tr>
<tr><td><code id="plot_allocation_+3A_title">title</code></td>
<td>
<p>title of the graphic</p>
</td></tr>
<tr><td><code id="plot_allocation_+3A_subtitle">subtitle</code></td>
<td>
<p>subtitle of the graphic</p>
</td></tr>
<tr><td><code id="plot_allocation_+3A_filename">filename</code></td>
<td>
<p>name of the .png file to be generated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a png file.
</p>


<h3>See Also</h3>

<p><a href="#topic+plotland">plotland</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
landscape &lt;- landscapeTEST1
croptypes &lt;- data.frame(sample.int(3, length(landscape), replace = TRUE))
allocation &lt;- SpatialPolygonsDataFrame(landscape, croptypes, match.ID = TRUE)
plot_allocation(allocation, 1,
  title = "Simulated landscape", subtitle = "Year 1",
  filename = paste(getwd(), "/landscape.png", sep = "")
)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_freqPatho'>Plotting pathotype frequencies</h2><span id='topic+plot_freqPatho'></span>

<h3>Description</h3>

<p>Plots in a .tiff file the dynamics of pathotype frequencies with respect to
pathogen adaptation to a specific resistance gene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_freqPatho(
  name_gene,
  Nlevels_aggressiveness,
  I_aggrProp,
  nTS,
  Nyears,
  nTSpY
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_freqPatho_+3A_name_gene">name_gene</code></td>
<td>
<p>a string specifying the name of the gene under investigation</p>
</td></tr>
<tr><td><code id="plot_freqPatho_+3A_nlevels_aggressiveness">Nlevels_aggressiveness</code></td>
<td>
<p>number of pathotypes with respect to the gene under investigation</p>
</td></tr>
<tr><td><code id="plot_freqPatho_+3A_i_aggrprop">I_aggrProp</code></td>
<td>
<p>a matrix giving the frequency of every pathotype (rows) for every time-step (columns)</p>
</td></tr>
<tr><td><code id="plot_freqPatho_+3A_nts">nTS</code></td>
<td>
<p>number of simulated time-steps</p>
</td></tr>
<tr><td><code id="plot_freqPatho_+3A_nyears">Nyears</code></td>
<td>
<p>number of simulated cropping seasons</p>
</td></tr>
<tr><td><code id="plot_freqPatho_+3A_ntspy">nTSpY</code></td>
<td>
<p>number of time-steps per cropping season</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
freqMatrix &lt;- matrix(0, nrow = 2, ncol = 100)
freqMatrix[2, 26:100] &lt;- (26:100) / 100
freqMatrix[1, ] &lt;- 1 - freqMatrix[2, ]
plot_freqPatho(
  index_gene = 1,
  Nlevels_aggressiveness = 2,
  freqMatrix,
  nTS = 100,
  Nyears = 10,
  nTSpY = 10
)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotland'>Plotting the landscape</h2><span id='topic+plotland'></span>

<h3>Description</h3>

<p>Plots a landscape with colors or hatched lines to represent different types of fields
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotland(
  landscape,
  COL = rep(0, length(landscape)),
  DENS = rep(0, length(landscape)),
  ANGLE = rep(30, length(landscape)),
  COL.LEG = unique(COL),
  DENS.LEG = unique(DENS),
  ANGLE.LEG = unique(ANGLE),
  TITLE = "",
  SUBTITLE = "",
  LEGEND1 = rep("", length(COL.LEG)),
  LEGEND2 = rep("", length(COL.LEG)),
  TITLE.LEG2 = ""
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotland_+3A_landscape">landscape</code></td>
<td>
<p>a spatialpolygon object containing field coordinates</p>
</td></tr>
<tr><td><code id="plotland_+3A_col">COL</code></td>
<td>
<p>vector containing the color of each field</p>
</td></tr>
<tr><td><code id="plotland_+3A_dens">DENS</code></td>
<td>
<p>vector containing the density of hatched lines for each field</p>
</td></tr>
<tr><td><code id="plotland_+3A_angle">ANGLE</code></td>
<td>
<p>vector containing the angle of hatched lines for each field</p>
</td></tr>
<tr><td><code id="plotland_+3A_col.leg">COL.LEG</code></td>
<td>
<p>vector containing the colors in the first legend</p>
</td></tr>
<tr><td><code id="plotland_+3A_dens.leg">DENS.LEG</code></td>
<td>
<p>vector containing the density of hatched lines in the second legend</p>
</td></tr>
<tr><td><code id="plotland_+3A_angle.leg">ANGLE.LEG</code></td>
<td>
<p>vector containing the angle of hatched lines in the second legend</p>
</td></tr>
<tr><td><code id="plotland_+3A_title">TITLE</code></td>
<td>
<p>title of the graphic</p>
</td></tr>
<tr><td><code id="plotland_+3A_subtitle">SUBTITLE</code></td>
<td>
<p>subtitle of the graphic</p>
</td></tr>
<tr><td><code id="plotland_+3A_legend1">LEGEND1</code></td>
<td>
<p>labels in the first legend (colors)</p>
</td></tr>
<tr><td><code id="plotland_+3A_legend2">LEGEND2</code></td>
<td>
<p>labels in the second legend (hatched lines)</p>
</td></tr>
<tr><td><code id="plotland_+3A_title.leg2">TITLE.LEG2</code></td>
<td>
<p>title for the second legend</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Draw a landscape with various colours
landscapeTEST1
plotland(landscapeTEST1,
  COL = 1:length(landscapeTEST1),
  DENS = rep(0, length(landscapeTEST1)), ANGLE = rep(30, length(landscapeTEST1))
)

## End(Not run)
</code></pre>

<hr>
<h2 id='price_reduction'>Price reduction function</h2><span id='topic+price_reduction'></span>

<h3>Description</h3>

<p>Give the price reduction rate associated with the infection on the (grapevine) fruits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>price_reduction(
  I_host,
  N_host,
  Nhost,
  Nyears,
  nTSpY,
  severity_thresh = 0.075,
  price_penalty = 0.3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="price_reduction_+3A_i_host">I_host</code></td>
<td>
<p>number of infected individuals for each cultivar and timestep</p>
</td></tr>
<tr><td><code id="price_reduction_+3A_n_host">N_host</code></td>
<td>
<p>total number of individuals for each cultivar and timestep</p>
</td></tr>
<tr><td><code id="price_reduction_+3A_nhost">Nhost</code></td>
<td>
<p>total number of cultivars considered in the simulation</p>
</td></tr>
<tr><td><code id="price_reduction_+3A_nyears">Nyears</code></td>
<td>
<p>number of simulated cropping seasons</p>
</td></tr>
<tr><td><code id="price_reduction_+3A_ntspy">nTSpY</code></td>
<td>
<p>number of timesteps (e.g. days) per cropping season</p>
</td></tr>
<tr><td><code id="price_reduction_+3A_severity_thresh">severity_thresh</code></td>
<td>
<p>disease severity threshold above which the price reduction is applied</p>
</td></tr>
<tr><td><code id="price_reduction_+3A_price_penalty">price_penalty</code></td>
<td>
<p>percentage of price reduction</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the price reduction rate per cultivar and per year of simulation
</p>


<h3>References</h3>

<p>Savary, S., Delbac, L., Rochas, A., Taisant, G., &amp; Willocquet, L. (2009).
Analysis of nonlinear relationships in dual epidemics, and its application to the management
of grapevine downy and powdery mildews. Phytopathology, 99(8), 930-942.
</p>

<hr>
<h2 id='print'>print</h2><span id='topic+print'></span><span id='topic+print+2CLandsepiParams-method'></span>

<h3>Description</h3>

<p>Prints a LandsepiParams object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LandsepiParams'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>a LandsepiParams object</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>print options</p>
</td></tr>
</table>

<hr>
<h2 id='resetCultivarsGenes'>Reset cultivars genes</h2><span id='topic+resetCultivarsGenes'></span>

<h3>Description</h3>

<p>Resets the lists of genes carried by all cultivars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resetCultivarsGenes(params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resetCultivarsGenes_+3A_params">params</code></td>
<td>
<p>a LandsepiParams object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a LandsepiParams object
</p>

<hr>
<h2 id='runShinyApp'>runShinyApp</h2><span id='topic+runShinyApp'></span>

<h3>Description</h3>

<p>Launches landsepi shiny application into browser
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runShinyApp()
</code></pre>


<h3>Details</h3>

<p>R packages needed to run the shiny app :
install.packages(c(&quot;shiny&quot;,&quot;DT&quot;, &quot;shinyjs&quot;, &quot;gridExtra&quot;, &quot;png&quot;, &quot;grid&quot;, &quot;future&quot;, &quot;promises&quot;, &quot;tools&quot;))
</p>

<hr>
<h2 id='runSimul'>Run a simulation</h2><span id='topic+runSimul'></span>

<h3>Description</h3>

<p>Runs a simulation with landsepi,
a stochastic, spatially-explicit, demo-genetic model simulating the spread and evolution
of a pathogen in a heterogeneous landscape and generating a wide range of epidemiological,
evolutionary and economic outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runSimul(
  params,
  graphic = TRUE,
  writeTXT = TRUE,
  videoMP4 = FALSE,
  keepRawResults = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runSimul_+3A_params">params</code></td>
<td>
<p>a LandsepiParams Object containing all simulation parameters. Must be initialised
with <code><a href="#topic+createSimulParams">createSimulParams</a></code> and updated using <code>set*()</code> methods
(see vignettes for details).</p>
</td></tr>
<tr><td><code id="runSimul_+3A_graphic">graphic</code></td>
<td>
<p>a logical indicating if graphics must be generated (TRUE, default)
or not (FALSE).</p>
</td></tr>
<tr><td><code id="runSimul_+3A_writetxt">writeTXT</code></td>
<td>
<p>a logical indicating if outputs must be written in text files (TRUE, default)
or not (FALSE).</p>
</td></tr>
<tr><td><code id="runSimul_+3A_videomp4">videoMP4</code></td>
<td>
<p>a logical indicating if a video must be generated (TRUE) or not (FALSE, default).
Works only if graphic=TRUE and audpc_rel is computed.</p>
</td></tr>
<tr><td><code id="runSimul_+3A_keeprawresults">keepRawResults</code></td>
<td>
<p>a logical indicating if binary files must be kept after the end of
the simulation (default=FALSE). Careful, many files may be generated if keepRawResults=TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>?landsepi</code> for details on the model, assumptions and outputs, and our
vignettes for tutorials (<code>browseVignettes("landsepi")</code>). The function runs the model
simulation using a LandsepiParams object.
Briefly, the model is stochastic, spatially explicit (the basic spatial unit is an
individual field or polygon), based on a SEIR (‘susceptible-exposed-infectious-removed’,
renamed HLIR for 'healthy-latent-infectious-removed' to avoid confusions with 'susceptible host')
structure with a discrete time step. It simulates the spread and
evolution (via mutation, recombination through sexual reproduction, selection and drift)
of a pathogen in a heterogeneous cropping landscape, across cropping seasons split
by host harvests which impose potential bottlenecks to the pathogen. A wide array of
resistance deployment strategies (possibly including chemical treatments)
can be simulated and evaluated using several possible
outputs to assess the epidemiological, evolutionary and economic performance
of deployment strategies.
</p>


<h3>Value</h3>

<p>A list containing all required outputs.
A set of text files, graphics and a video showing epidemic dynamics can be generated.
If keepRawResults=TRUE, a set of binary files is generated for every year of simulation and
every compartment: </p>

<ul>
<li><p> H: healthy hosts,
</p>
</li>
<li><p> Hjuv: juvenile healthy hosts (for host reproduction),
</p>
</li>
<li><p> L: latently infected hosts,
</p>
</li>
<li><p> I: infectious hosts,
</p>
</li>
<li><p> R: removed hosts,
</p>
</li>
<li><p> P: propagules.</p>
</li></ul>

<p>Each file indicates for every time step the number of individuals in each polygon, and when
appropriate for each host and pathogen genotype. Additionally, a binary file called TFI is
generated and gives the Treatment Frequency Indicator (expressed as the number of treatment
applications per polygon).
</p>


<h3>References</h3>

<p>Rimbaud L., Papaïx J., Rey J.-F., Barrett L. G. and Thrall P. H. (2018).
Assessing the durability and efficiency of landscape-based strategies to deploy plant
resistance to pathogens. <em>PLoS Computational Biology</em> 14(4):e1006067.
</p>


<h3>See Also</h3>

<p><a href="#topic+demo_landsepi">demo_landsepi</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Here is an example of simulation of a mosaic of three cultivars (S + R1 + R2).
## See our tutorials for more examples.

## Initialisation
simul_params &lt;- createSimulParams(outputDir = getwd())
## Seed &amp; Time parameters
simul_params &lt;- setSeed(simul_params, seed = 1)
simul_params &lt;- setTime(simul_params, Nyears = 10, nTSpY = 120)
## Pathogen parameters
simul_params &lt;- setPathogen(simul_params, loadPathogen("rust"))
## Landscape &amp; dispersal
simul_params &lt;- setLandscape(simul_params, loadLandscape(1))
simul_params &lt;- setDispersalPathogen(simul_params, loadDispersalPathogen[[1]])
## Genes
gene1 &lt;- loadGene(name = "MG 1", type = "majorGene")
gene2 &lt;- loadGene(name = "MG 2", type = "majorGene")
genes &lt;- data.frame(rbind(gene1, gene2), stringsAsFactors = FALSE)
simul_params &lt;- setGenes(simul_params, genes)
## Cultivars
cultivar1 &lt;- loadCultivar(name = "Susceptible", type = "wheat")
cultivar2 &lt;- loadCultivar(name = "Resistant1", type = "wheat")
cultivar3 &lt;- loadCultivar(name = "Resistant2", type = "wheat")
cultivars &lt;- data.frame(rbind(cultivar1, cultivar2, cultivar3), stringsAsFactors = FALSE)
simul_params &lt;- setCultivars(simul_params, cultivars)
## Allocate genes to cultivars
simul_params &lt;- allocateCultivarGenes(simul_params, "Resistant1", c("MG 1"))
simul_params &lt;- allocateCultivarGenes(simul_params, "Resistant2", c("MG 2"))
## Allocate cultivars to croptypes
croptypes &lt;- loadCroptypes(simul_params, names = c("Susceptible crop",
"Resistant crop 1", "Resistant crop 2"))
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Susceptible crop", "Susceptible")
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Resistant crop 1", "Resistant1")
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Resistant crop 2", "Resistant2")
simul_params &lt;- setCroptypes(simul_params, croptypes)
## Allocate croptypes to landscape        
rotation_sequence &lt;- croptypes$croptypeID ## No rotation =&gt; 1 rotation_sequence element
rotation_period &lt;- 0 ## same croptypes every years
prop &lt;- c(1 / 3, 1 / 3, 1 / 3) ## croptypes proportions
aggreg &lt;- 10 ## aggregated landscape
simul_params &lt;- allocateLandscapeCroptypes(simul_params,
rotation_period = rotation_period,
rotation_sequence = rotation_sequence,
rotation_realloc = FALSE, prop = prop, aggreg = aggreg)
## Set the inoculum
simul_params &lt;- setInoculum(simul_params, 5e-4)
## list of outputs to be generated
simul_params &lt;- setOutputs(simul_params, loadOutputs())
## Check simulation parameters
checkSimulParams(simul_params)
## Save deployment strategy into GPKG file
simul_params &lt;- saveDeploymentStrategy(simul_params)
## Run simulation
runSimul(simul_params)

### Simulation of rust epidemics in a 1-km^2 patch cultivated
### with a susceptible wheat cultivar
seed=10
Nyears=5
disease="rust"
hostType="wheat"
simul_params &lt;- createSimulParams(outputDir = getwd())

## Seed and time parameters
simul_params &lt;- setSeed(simul_params, seed)
simul_params &lt;- setTime(simul_params, Nyears, nTSpY=120)

## Pathogen parameters
simul_params &lt;- setPathogen(simul_params, loadPathogen(disease))
myLand &lt;- Polygons(list(Polygon(matrix(c(0,0,1,1,0,1,1,0)*1000, nrow=4))), "ID1")
myLand &lt;- SpatialPolygons(list(myLand))
simul_params &lt;- setLandscape(simul_params, myLand)

## Simulation, pathogen, landscape and dispersal parameters
simul_params &lt;- setDispersalPathogen(simul_params, c(1))

## Cultivars
simul_params &lt;- setCultivars(simul_params, loadCultivar(name = "Susceptible",
 type = hostType))

## Croptypes
croptype &lt;- data.frame(croptypeID = 0, croptypeName = c("Fully susceptible crop"),
Susceptible = 1)
simul_params &lt;- setCroptypes(simul_params, croptype)
simul_params &lt;- allocateLandscapeCroptypes(simul_params,
rotation_period = 0, rotation_sequence = list(c(0)),
rotation_realloc = FALSE, prop = 1, aggreg = 1)

## Inoculum
simul_params &lt;- setInoculum(simul_params, 5e-4)

## list of outputs to be generated
outputlist &lt;- loadOutputs(epid_outputs = "all", evol_outputs = "")
simul_params &lt;- setOutputs(simul_params, outputlist)

## Check, save and run simulation
checkSimulParams(simul_params)
runSimul(simul_params, graphic = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='saveDeploymentStrategy'>Save landscape and deployment strategy</h2><span id='topic+saveDeploymentStrategy'></span>

<h3>Description</h3>

<p>Generates a GPKG file containing the landscape and all parameters of
the deployment strategy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveDeploymentStrategy(
  params,
  outputGPKG = "landsepi_landscape.gpkg",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="saveDeploymentStrategy_+3A_params">params</code></td>
<td>
<p>a LandsepiParams Object.</p>
</td></tr>
<tr><td><code id="saveDeploymentStrategy_+3A_outputgpkg">outputGPKG</code></td>
<td>
<p>name of the GPKG output (default: &quot;landsepi_landscape.gpkg&quot;) to be generated.</p>
</td></tr>
<tr><td><code id="saveDeploymentStrategy_+3A_overwrite">overwrite</code></td>
<td>
<p>a boolean specifying if existing files can be overwritten (TRUE) or not
(FALSE, default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates a GPKG file in the simulation path.
The GPKG file contains all input parameters needed to restore the landscape (sf object)
and deployment strategy (croptypes, cultivars and genes).
</p>


<h3>Value</h3>

<p>an updated LandsepiParams object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Initialisation
simul_params &lt;- createSimulParams(outputDir = getwd())
## Time parameters
simul_params &lt;- setTime(simul_params, Nyears = 10, nTSpY = 120)
## Landscape
simul_params &lt;- setLandscape(simul_params, loadLandscape(1))
## Genes
gene1 &lt;- loadGene(name = "MG 1", type = "majorGene")
gene2 &lt;- loadGene(name = "MG 2", type = "majorGene")
genes &lt;- data.frame(rbind(gene1, gene2), stringsAsFactors = FALSE)
simul_params &lt;- setGenes(simul_params, genes)
## Cultivars
cultivar1 &lt;- loadCultivar(name = "Susceptible", type = "wheat")
cultivar2 &lt;- loadCultivar(name = "Resistant1", type = "wheat")
cultivar3 &lt;- loadCultivar(name = "Resistant2", type = "wheat")
cultivars &lt;- data.frame(rbind(cultivar1, cultivar2, cultivar3), stringsAsFactors = FALSE)
simul_params &lt;- setCultivars(simul_params, cultivars)
## Allocate genes to cultivars
simul_params &lt;- allocateCultivarGenes(simul_params, "Resistant1", c("MG 1"))
simul_params &lt;- allocateCultivarGenes(simul_params, "Resistant2", c("MG 2"))
## Allocate cultivars to croptypes
croptypes &lt;- loadCroptypes(simul_params, names = c("Susceptible crop"
, "Resistant crop 1"
, "Resistant crop 2"))
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Susceptible crop", "Susceptible")
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Resistant crop 1", "Resistant1")
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Resistant crop 2", "Resistant2")
simul_params &lt;- setCroptypes(simul_params, croptypes)
## Allocate croptypes to landscape        
rotation_sequence &lt;- croptypes$croptypeID ## No rotation -&gt; 1 rotation_sequence element
rotation_period &lt;- 0 ## same croptypes every years
prop &lt;- c(1 / 3, 1 / 3, 1 / 3) ## croptypes proportions
aggreg &lt;- 10 ## aggregated landscape
simul_params &lt;- allocateLandscapeCroptypes(simul_params, rotation_period = rotation_period,
rotation_sequence = rotation_sequence,
rotation_realloc = FALSE, prop = prop, aggreg = aggreg)
## Save into a GPKG file
simul_params &lt;- saveDeploymentStrategy(simul_params)

## End(Not run)
</code></pre>

<hr>
<h2 id='setCroptypes'>Set croptypes</h2><span id='topic+setCroptypes'></span>

<h3>Description</h3>

<p>Updates a LandsepiParams object with croptypes and their composition with regard
to cultivar proportions.
Note that landscape and cultivar parameters may be required if not all information is
present to set croptypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setCroptypes(params, dfCroptypes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setCroptypes_+3A_params">params</code></td>
<td>
<p>a LandsepiParams Object.</p>
</td></tr>
<tr><td><code id="setCroptypes_+3A_dfcroptypes">dfCroptypes</code></td>
<td>
<p>a data.frame containing cultivar proportions in each croptype (see details).
It can be generated manually, or initialised with <code><a href="#topic+loadCroptypes">loadCroptypes</a></code> and later
updated with <code><a href="#topic+allocateCroptypeCultivars">allocateCroptypeCultivars</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data.frame for cultivar allocations into croptypes must take this format (example):</p>

<table>
<tr>
 <td style="text-align: left;">
   croptypeID </td><td style="text-align: left;"> croptypeName </td><td style="text-align: left;"> cultivarName1 </td><td style="text-align: left;"> cultivarName2 </td><td style="text-align: left;"> ... </td>
</tr>
<tr>
 <td style="text-align: left;">
   0 </td><td style="text-align: left;"> "cropt1" </td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> 0 </td><td style="text-align: left;"> ... </td>
</tr>
<tr>
 <td style="text-align: left;">
   1 </td><td style="text-align: left;"> "cropt2" </td><td style="text-align: left;"> 0.5 </td><td style="text-align: left;"> 0.5 </td><td style="text-align: left;"> ... </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>croptypeIDs must start at 0 and match with values from landscape &quot;croptypeID&quot; layer with
feature year_X.
Cultivars names have to match cultivar names in the cultivars data.frame.
</p>


<h3>Value</h3>

<p>a LandsepiParams object
</p>


<h3>See Also</h3>

<p><a href="#topic+loadCroptypes">loadCroptypes</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simul_params &lt;- createSimulParams()
cultivar1 &lt;- loadCultivar(name = "Susceptible", type = "wheat")
cultivar2 &lt;- loadCultivar(name = "Resistant1", type = "wheat")
cultivar3 &lt;- loadCultivar(name = "Resistant2", type = "wheat")
cultivars &lt;- data.frame(rbind(cultivar1, cultivar2, cultivar3), stringsAsFactors = FALSE)
simul_params &lt;- setCultivars(simul_params, cultivars)
croptypes &lt;- loadCroptypes(simul_params, names = c("Susceptible crop", "Mixture"))
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Susceptible crop", "Susceptible")
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Mixture", c("Resistant1", "Resistant2"))
simul_params &lt;- setCroptypes(simul_params, croptypes)
simul_params@Croptypes

## End(Not run)
</code></pre>

<hr>
<h2 id='setCultivars'>Set cultivars</h2><span id='topic+setCultivars'></span>

<h3>Description</h3>

<p>Updates a LandsepiParams object with cultivars parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setCultivars(params, dfCultivars)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setCultivars_+3A_params">params</code></td>
<td>
<p>a landsepiParams object.</p>
</td></tr>
<tr><td><code id="setCultivars_+3A_dfcultivars">dfCultivars</code></td>
<td>
<p>a data.frame defining the cultivars (see details). It can be generated
manually or, alternatively, via <code><a href="#topic+loadCultivar">loadCultivar</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>dfCultivars is a dataframe of parameters associated with each host genotype
(i.e. cultivars, lines) when cultivated in pure crops. Columns of the dataframe are:</p>

<ul>
<li><p> cultivarName: cultivar names (cannot accept space),
</p>
</li>
<li><p> initial_density: host densities (per square meter) at the beginning of the cropping season
as if cultivated in pure crop,
</p>
</li>
<li><p> max_density: maximum host densities (per square meter) at the end of the cropping season
as if cultivated in pure crop,
</p>
</li>
<li><p> growth rate: host growth rates,
</p>
</li>
<li><p> reproduction rate: host reproduction rates,
</p>
</li>
<li><p> yield_H: theoretical yield (in weight or volume units / ha / cropping season)
associated with hosts in sanitary status H as if cultivated in pure crop,
</p>
</li>
<li><p> yield_L: theoretical yield (in weight or volume units / ha / cropping season)
associated with hosts in sanitary status L as if cultivated in pure crop,
</p>
</li>
<li><p> yield_I: theoretical yield (in weight or volume units / ha / cropping season)
associated with hosts in sanitary status I as if cultivated in pure crop,
</p>
</li>
<li><p> yield_R: theoretical yield (in weight or volume units / ha / cropping season)
associated with hosts in sanitary status R as if cultivated in pure crop,
</p>
</li>
<li><p> planting_cost = planting costs (in monetary units / ha / cropping season) as if
cultivated in pure crop,
</p>
</li>
<li><p> market_value = market values of the production (in monetary units / weight or volume unit).
</p>
</li></ul>

<p>The data.frame must be defined as follow (example):</p>

<table>
<tr>
 <td style="text-align: left;">
   cultivarName </td><td style="text-align: left;"> initial_density </td><td style="text-align: left;"> max_density </td><td style="text-align: left;"> growth_rate </td><td style="text-align: left;"> reproduction_rate </td><td style="text-align: left;"> yield_H </td><td style="text-align: left;"> yield_L </td><td style="text-align: left;"> yield_I </td><td style="text-align: left;"> yield_R </td><td style="text-align: left;"> planting_cost </td><td style="text-align: left;"> market_value </td>
</tr>
<tr>
 <td style="text-align: left;">
   Susceptible </td><td style="text-align: left;"> 0.1 </td><td style="text-align: left;"> 2.0 </td><td style="text-align: left;"> 0.1 </td><td style="text-align: left;"> 0.0 </td><td style="text-align: left;"> 2.5 </td><td style="text-align: left;"> 0.0 </td><td style="text-align: left;"> 0.0 </td><td style="text-align: left;"> 0.0 </td><td style="text-align: left;"> 225 </td><td style="text-align: left;"> 200 </td>
</tr>
<tr>
 <td style="text-align: left;">
   Resistant1 </td><td style="text-align: left;"> 0.1 </td><td style="text-align: left;"> 2.0 </td><td style="text-align: left;"> 0.1 </td><td style="text-align: left;"> 0.0 </td><td style="text-align: left;"> 2.5 </td><td style="text-align: left;"> 0.0 </td><td style="text-align: left;"> 0.0 </td><td style="text-align: left;"> 0.0 </td><td style="text-align: left;"> 225 </td><td style="text-align: left;"> 200 </td>
</tr>
<tr>
 <td style="text-align: left;">
   Resistant2 </td><td style="text-align: left;"> 0.1 </td><td style="text-align: left;"> 2.0 </td><td style="text-align: left;"> 0.1 </td><td style="text-align: left;"> 0.0 </td><td style="text-align: left;"> 2.5 </td><td style="text-align: left;"> 0.0 </td><td style="text-align: left;"> 0.0 </td><td style="text-align: left;"> 0.0 </td><td style="text-align: left;"> 225 </td><td style="text-align: left;"> 200 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>a LandsepiParams object
</p>


<h3>See Also</h3>

<p><a href="#topic+loadCultivar">loadCultivar</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simul_params &lt;- createSimulParams()
cultivar1 &lt;- loadCultivar(name = "Susceptible", type = "wheat")
cultivar2 &lt;- loadCultivar(name = "Resistant", type = "wheat")
cultivars &lt;- data.frame(rbind(cultivar1, cultivar2), stringsAsFactors = FALSE)
simul_params &lt;- setCultivars(simul_params, cultivars)
simul_params@Cultivars

## End(Not run)
</code></pre>

<hr>
<h2 id='setDispersalHost'>Set host dispersal</h2><span id='topic+setDispersalHost'></span>

<h3>Description</h3>

<p>Updates a LandsepiParams object with a host dispersal matrix.
Note that landscape parameters must be set before updating setting dispersal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setDispersalHost(params, mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setDispersalHost_+3A_params">params</code></td>
<td>
<p>a LandsepiParams Object.</p>
</td></tr>
<tr><td><code id="setDispersalHost_+3A_mat">mat</code></td>
<td>
<p>a square matrix giving the probability of host dispersal
from any polygon of the landscape to any other polygon.
It can be generated manually, or, alternatively, via <code><a href="#topic+loadDispersalHost">loadDispersalHost</a></code>.
The size of the matrix must match the number of polygons in the landscape.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the dispersal matrix gives the probability for a host individual in a polygon i (row)
to migrate to polygon j (column) through dispersal.
If the host is a cultivated plant: seeds are harvested and do not disperse.
Thus the dispersal matrix is the identity matrix.
</p>


<h3>Value</h3>

<p>a LandsepiParam object.
</p>


<h3>See Also</h3>

<p><a href="#topic+loadDispersalHost">loadDispersalHost</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simul_params &lt;- createSimulParams()
simul_params &lt;- setLandscape(simul_params, loadLandscape(1))
d &lt;- loadDispersalHost(simul_params)
simul_params &lt;- setDispersalHost(simul_params, d)
simul_params@DispHost

## End(Not run)
</code></pre>

<hr>
<h2 id='setDispersalPathogen'>Set pathogen dispersal</h2><span id='topic+setDispersalPathogen'></span>

<h3>Description</h3>

<p>Updates a LandsepiParams object with a pathogen dispersal matrix.
Note that landscape parameters must be set before updating setting dispersal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setDispersalPathogen(params, mat_clonal, mat_sex = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setDispersalPathogen_+3A_params">params</code></td>
<td>
<p>a LandsepiParams Object.</p>
</td></tr>
<tr><td><code id="setDispersalPathogen_+3A_mat_clonal">mat_clonal</code></td>
<td>
<p>a square matrix giving the probability of pathogen dispersal
(clonal propagules) from any polygon of the landscape to any other polygon.
It can be generated manually, or, alternatively, via <code><a href="#topic+loadDispersalPathogen">loadDispersalPathogen</a></code>.
The size of the matrix must match the number of polygons in the landscape, and lines of
the matrix may sum to 1 (reflecting boundaries) or be &lt;1 (absorbing boundaries).</p>
</td></tr>
<tr><td><code id="setDispersalPathogen_+3A_mat_sex">mat_sex</code></td>
<td>
<p>a square matrix giving the probability of pathogen dispersal (sexual propagules)
from any polygon of the landscape to any other polygon (default identity matrix) .
It can be generated manually, or, alternatively, via <code><a href="#topic+loadDispersalPathogen">loadDispersalPathogen</a></code>.
The size of the matrix must match the number of polygons in the landscape, and lines of
the matrix may sum to 1 (reflecting boundaries) or be &lt;1 (absorbing boundaries).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See tutorial (vignettes) on how to
use your own landscape and compute your own pathogen dispersal kernel.
The dispersal matrix a square matrix whose size is the number of polygons in the landscape
and whose elements are, for each line i and each column i' the probability that propagules
migrate from polygon i to polygon i'.
Lines of the matrix can be normalised to sum to 1 (reflective boundaries);
otherwise propagules dispersing outside the landscape are lost (absorbing boundaries).
</p>


<h3>Value</h3>

<p>a LandsepiParam object.
</p>


<h3>See Also</h3>

<p><a href="#topic+loadDispersalPathogen">loadDispersalPathogen</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simul_params &lt;- createSimulParams()
simul_params &lt;- setLandscape(simul_params, loadLandscape(1))
d &lt;- loadDispersalPathogen(1)
simul_params &lt;- setDispersalPathogen(simul_params, d[[1]], d[[2]])
simul_params@DispPathoClonal

## End(Not run)
</code></pre>

<hr>
<h2 id='setGenes'>Set genes</h2><span id='topic+setGenes'></span>

<h3>Description</h3>

<p>Updates a LandsepiParams object with parameters associated with resistance genes
and pathogen adaptation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setGenes(params, dfGenes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setGenes_+3A_params">params</code></td>
<td>
<p>a LandsepiParams object</p>
</td></tr>
<tr><td><code id="setGenes_+3A_dfgenes">dfGenes</code></td>
<td>
<p>a data.frame containing gene parameters. It can be defined manually, or,
alternatively, with <code><a href="#topic+loadGene">loadGene</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>dfGenes is a data.frame of parameters associated with each resistance gene and
with the evolution of each corresponding pathogenicity gene. Columns of the dataframe are:
</p>

<ul>
<li><p> geneName: names of resistance genes,
</p>
</li>
<li><p> target_trait: aggressiveness components (&quot;IR&quot;, &quot;LAT&quot;, &quot;IP&quot;, or &quot;PR&quot;) targeted by
resistance genes,
</p>
</li>
<li><p> efficiency: resistance gene efficiencies, i.e. the percentage of reduction of the targeted
aggressiveness component (IR, 1/LAT, IP and PR),
</p>
</li>
<li><p> age_of_activ_mean: expected delays to resistance activation (for APRs),
</p>
</li>
<li><p> age_of_activ_var: variances of the delay to resistance activation (for APRs),
</p>
</li>
<li><p> mutation_prob: mutation probabilities for pathogenicity genes (each of them
corresponding to a resistance gene),
</p>
</li>
<li><p> Nlevels_aggressiveness: number of adaptation levels related to each resistance gene
(i.e. 1 + number of required mutations for a pathogenicity gene to fully adapt to the
corresponding resistance gene),
</p>
</li>
<li><p> adaptation_cost: fitness penalties paid by pathogen genotypes
fully adapted to the considered resistance genes on all hosts,
</p>
</li>
<li><p> relative_advantage: fitness advantages of pathogen genotypes fully adapted to the
resistance genes on hosts carrying these genes, relative to those that do not carry these genes,
</p>
</li>
<li><p> tradeoff_strength: strengths of the trade-off relationships between the
level of aggressiveness on hosts that do and do not carry the resistance genes.
</p>
</li>
<li><p> recombination_sd: standard deviation of the normal distribution used for recombination
of quantitative traits during sexual reproduction (infinitesimal model)
</p>
</li></ul>

<p>The data.frame must be defined as follow (example):</p>

<table>
<tr>
 <td style="text-align: left;">
   geneName </td><td style="text-align: left;"> efficiency </td><td style="text-align: left;"> age_of_activ_mean </td><td style="text-align: left;"> age_of_activ_var </td><td style="text-align: left;"> mutation_prob </td><td style="text-align: left;"> Nlevels_agressiveness </td><td style="text-align: left;"> adaptation_cost </td><td style="text-align: left;"> relative advantage </td><td style="text-align: left;"> tradeoff_strength </td><td style="text-align: left;"> target_trait </td><td style="text-align: left;"> recombination_sd </td>
</tr>
<tr>
 <td style="text-align: left;">
   MG1 </td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> 0 </td><td style="text-align: left;"> 0 </td><td style="text-align: left;"> 1e-07 </td><td style="text-align: left;"> 2 </td><td style="text-align: left;"> 0.5 </td><td style="text-align: left;"> 0.5 </td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> IR </td><td style="text-align: left;"> 0.27 </td>
</tr>
<tr>
 <td style="text-align: left;">
   QTL1 </td><td style="text-align: left;"> 0.5 </td><td style="text-align: left;"> 0 </td><td style="text-align: left;"> 0 </td><td style="text-align: left;"> 0.0001 </td><td style="text-align: left;"> 10 </td><td style="text-align: left;"> 0.74 </td><td style="text-align: left;"> 0.74 </td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> LAT </td><td style="text-align: left;"> 0.27 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>a LandsepiParams object.
</p>


<h3>See Also</h3>

<p><a href="#topic+loadGene">loadGene</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simul_params &lt;- createSimulParams()
gene1 &lt;- loadGene(name = "MG 1", type = "majorGene")
gene2 &lt;- loadGene(name = "MG 2", type = "majorGene")
genes &lt;- data.frame(rbind(gene1, gene2), stringsAsFactors = FALSE)
simul_params &lt;- setGenes(simul_params, genes)
simul_params@Genes

## End(Not run)
</code></pre>

<hr>
<h2 id='setInoculum'>Set inoculum</h2><span id='topic+setInoculum'></span>

<h3>Description</h3>

<p>Updates a LandsepiParams object with the initial probability for an individual host
to be infectious (i.e. state I) at the beginning of the simulation (i.e. t=0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setInoculum(params, val = 5e-04)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setInoculum_+3A_params">params</code></td>
<td>
<p>a LandsepiParams object.</p>
</td></tr>
<tr><td><code id="setInoculum_+3A_val">val</code></td>
<td>
<p>a numeric value (default = 5e-4) indicating the probability for the first cultivar
to be infected by the first pathogen genotype in all polygons of the landscape
(must be between 0 and 1).
The parameter can also be entered as a 3D array of dimensions (1:Nhost,1:Npatho,1:Npoly)
indicating the initial probability to be infectious, for each cultivar, pathogen genotype and
polygon (independently from the possible presence of cultivars carrying resistance genes).
It can be generated manually or, alternatively, via <code><a href="#topic+loadInoculum">loadInoculum</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before setting the inoculum, one can use <code>getMatrixGenePatho()</code>,
<code>getMatrixCultivarPatho()</code>,
<code>getMatrixCroptypePatho()</code> and <code>getMatrixPolyPatho()</code> to acknowledge which
pathogen genotypes are compatible to which genes, cultivars, croptypes and polygons.<br />
Once <code>setInoculum()</code> is used, one can call <code>inoculumToMatrix()</code> to get
the inoculum as a 3D array (1:Nhost,1:Npatho,1:Npoly)<br />
</p>


<h3>Value</h3>

<p>a LandsepiParams object
</p>


<h3>See Also</h3>

<p><a href="#topic+inoculumToMatrix">inoculumToMatrix</a>, <a href="#topic+loadInoculum">loadInoculum</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simul_params &lt;- createSimulParams()
simul_params &lt;- setInoculum(simul_params, 1E-3)
simul_params@PI0

## End(Not run)
</code></pre>

<hr>
<h2 id='setLansdcape'>Set the landscape</h2><span id='topic+setLansdcape'></span><span id='topic+setLandscape'></span>

<h3>Description</h3>

<p>Updates a LandsepiParams object with a sp or sf object as landscape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setLandscape(params, land)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setLansdcape_+3A_params">params</code></td>
<td>
<p>a LandsepiParams Object.</p>
</td></tr>
<tr><td><code id="setLansdcape_+3A_land">land</code></td>
<td>
<p>a landscape as sp or sf object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The landscape should be a sp or sf object. Built-in landscape are available using
<code><a href="#topic+loadLandscape">loadLandscape</a></code>.
See our tutorial (vignettes) for details on how to use your own landscape.
If the landscape contains only polygons, croptypes can be allocated later using
<code><a href="#topic+allocateLandscapeCroptypes">allocateLandscapeCroptypes</a></code>.
Otherwise the landscape has to contain a data.frame specifying for every year, the index
of the croptype cultivated in each polygon.
Each features has a field identified by &quot;year_XX&quot; (XX &lt;- seq(1:Nyears+1)) and containing
the croptype ID.</p>

<table>
<tr>
 <td style="text-align: left;">
   Features/fields </td><td style="text-align: left;"> year_1 </td><td style="text-align: left;"> year_2 </td><td style="text-align: left;"> ... year_Nyears+1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   polygons1 </td><td style="text-align: left;"> 13 </td><td style="text-align: left;"> 10 </td><td style="text-align: left;"> 13 </td>
</tr>
<tr>
 <td style="text-align: left;">
   polygonsX </td><td style="text-align: left;"> 2 </td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> 2 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>a LandsepiParams object.
</p>


<h3>See Also</h3>

<p><a href="#topic+loadLandscape">loadLandscape</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simul_params &lt;- createSimulParams()
simul_params &lt;- setLandscape(simul_params, loadLandscape(1))
simul_params@Landscape

## End(Not run)
</code></pre>

<hr>
<h2 id='setOutputs'>Set outputs</h2><span id='topic+setOutputs'></span>

<h3>Description</h3>

<p>Updates a LandsepiParams object with a list of output parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setOutputs(params, output_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setOutputs_+3A_params">params</code></td>
<td>
<p>a LandsepiParams object.</p>
</td></tr>
<tr><td><code id="setOutputs_+3A_output_list">output_list</code></td>
<td>
<p>a list of outputs to be generated and parameters for output generation.
It can be generated manually or, alternatively, via <code><a href="#topic+loadOutputs">loadOutputs</a></code>. This list
is composed of:</p>

<ul>
<li><p> epid_outputs = epidemiological outputs to compute (see details)
</p>
</li>
<li><p> evol_outputs = evolutionary outputs to compute (see details)
</p>
</li>
<li><p> thres_breakdown = an integer (or vector of integers) giving the threshold
(i.e. number of infections) above which a pathogen genotype is unlikely to go extinct,
used to characterise the time to invasion of resistant hosts (several values are computed
if several thresholds are given in a vector).
</p>
</li>
<li><p> audpc100S = the audpc in a fully susceptible landscape (used as reference value
for graphics).
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;epid_outputs&quot; is a character string (or a vector of character strings if several
outputs are to be computed) specifying the type of epidemiological and economic outputs
to generate:
</p>

<ul>
<li><p> &quot;audpc&quot; : Area Under Disease Progress Curve (average number of diseased host individuals
per time step and square meter)
</p>
</li>
<li><p> &quot;audpc_rel&quot; : Relative Area Under Disease Progress Curve (average proportion of
diseased host individuals relative to the total number of existing hosts)
</p>
</li>
<li><p> &quot;gla&quot; : Green Leaf Area (average number of healthy host individuals per square meter)
</p>
</li>
<li><p> &quot;gla_rel&quot; : Relative Green Leaf Area (average proportion of healthy host individuals
relative to the total number of existing hosts)
</p>
</li>
<li><p> &quot;eco_yield&quot; : total crop yield (in weight or volume units per ha)
</p>
</li>
<li><p> &quot;eco_cost&quot; : operational crop costs (in monetary units per ha)
</p>
</li>
<li><p> &quot;eco_product&quot; : total crop products (in monetary units per ha)
</p>
</li>
<li><p> &quot;eco_margin&quot; : Margin (products - costs, in monetary units per ha)
</p>
</li>
<li><p> &quot;contrib&quot;: contribution of pathogen genotypes to LIR dynamics
</p>
</li>
<li><p> &quot;HLIR_dynamics&quot;, &quot;H_dynamics&quot;, &quot;L_dynamics&quot;, &quot;IR_dynamics&quot;, &quot;HLI_dynamics&quot;, etc.:
Epidemic dynamics related to the specified sanitary status (H, L, I or R and all their
combinations). Graphics only, works only if graphic=TRUE.
</p>
</li>
<li><p> &quot;all&quot; : compute all these outputs (default)
</p>
</li>
<li><p> &quot;&quot; : none of these outputs will be generated.
</p>
</li></ul>

<p>&quot;evol_outputs&quot; is a character string (or a vector of character strings if several outputs
are to be computed) specifying the type of evolutionary outputs to generate :</p>

<ul>
<li><p> &quot;evol_patho&quot;: Dynamics of pathogen genotype frequencies
</p>
</li>
<li><p> &quot;evol_aggr&quot;: Evolution of pathogen aggressiveness
</p>
</li>
<li><p> &quot;durability&quot;: Durability of resistance genes
</p>
</li>
<li><p> &quot;all&quot;: compute all these outputs (default)
</p>
</li>
<li><p> &quot;&quot;: none of these outputs will be generated.
</p>
</li></ul>



<h3>Value</h3>

<p>a LandsepiParams object.
</p>


<h3>See Also</h3>

<p><a href="#topic+loadOutputs">loadOutputs</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simul_params &lt;- createSimulParams()
simul_params &lt;- setOutputs(simul_params, loadOutputs())
simul_params@Outputs

## End(Not run)
</code></pre>

<hr>
<h2 id='setPathogen'>Set the pathogen</h2><span id='topic+setPathogen'></span>

<h3>Description</h3>

<p>Updates a LandsepiParams object with pathogen parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPathogen(params, patho_params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setPathogen_+3A_params">params</code></td>
<td>
<p>a LandsepiParams Object.</p>
</td></tr>
<tr><td><code id="setPathogen_+3A_patho_params">patho_params</code></td>
<td>
<p>a list of pathogen aggressiveness parameters on a susceptible host
for a pathogen genotype not adapted to resistance: </p>

<ul>
<li><p> infection_rate = maximal expected infection rate of a propagule on a healthy host,
</p>
</li>
<li><p> propagule_prod_rate = maximal expected effective propagule production rate of an
infectious host per time step,
</p>
</li>
<li><p> latent_period_mean = minimal expected duration of the latent period,
</p>
</li>
<li><p> latent_period_var = variance of the latent period duration,
</p>
</li>
<li><p> infectious_period_mean = maximal expected duration of the infectious period,
</p>
</li>
<li><p> infectious_period_var = variance of the infectious period duration,
</p>
</li>
<li><p> survival_prob = probability for a propagule to survive the off-season,
</p>
</li>
<li><p> repro_sex_prob = probability for an infectious host to reproduce via sex rather
than via cloning,
</p>
</li>
<li><p> sigmoid_kappa = kappa parameter of the sigmoid contamination function,
</p>
</li>
<li><p> sigmoid_sigma = sigma parameter of the sigmoid contamination function,
</p>
</li>
<li><p> sigmoid_plateau = plateau parameter of the sigmoid contamination function,
</p>
</li>
<li><p> sex_propagule_viability_limit = maximum number of cropping seasons up to which
a sexual propagule is viable
</p>
</li>
<li><p> sex_propagule_release_mean = average number of seasons after which a sexual
propagule is released.
</p>
</li>
<li><p> clonal_propagule_gradual_release = whether or not clonal propagules surviving
the bottleneck are gradually released along the following cropping season.
</p>
</li></ul>

<p>It can be generated manually, or, alternatively, via <code><a href="#topic+loadPathogen">loadPathogen</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>a set of parameters representative of rust fungi, downy mildew or black sigatoka
can be loaded via <code><a href="#topic+loadPathogen">loadPathogen</a></code>.
</p>


<h3>Value</h3>

<p>a LandsepiParams object
</p>


<h3>See Also</h3>

<p><a href="#topic+loadPathogen">loadPathogen</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simul_params &lt;- createSimulParams()
simul_params &lt;- setPathogen(simul_params, loadPathogen())
simul_params@Pathogen

## End(Not run)
</code></pre>

<hr>
<h2 id='setSeed'>Set the seed</h2><span id='topic+setSeed'></span>

<h3>Description</h3>

<p>Updates a LandsepiParams object with a seed value for random number generator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setSeed(params, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setSeed_+3A_params">params</code></td>
<td>
<p>a LandsepiParams Object.</p>
</td></tr>
<tr><td><code id="setSeed_+3A_seed">seed</code></td>
<td>
<p>an integer used as seed value (for random number generator).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a LandsepiParams object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simul_params &lt;- createSimulParams()
simul_params &lt;- setSeed(simul_params, 100)
simul_params@Seed

## End(Not run)
</code></pre>

<hr>
<h2 id='setSeedValue'>setSeedValue</h2><span id='topic+setSeedValue'></span>

<h3>Description</h3>

<p>Set RNG seed to seed value if not NULL, otherwise set it to timestamps value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setSeedValue(seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setSeedValue_+3A_seed">seed</code></td>
<td>
<p>an interger as seed value or NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sets seed for &quot;Mersenne-Twister&quot; algorithm using Inversion generation
</p>


<h3>Value</h3>

<p>the new seed value for RNG
</p>


<h3>Examples</h3>

<pre><code class='language-R'>setSeedValue(seed = 10)
</code></pre>

<hr>
<h2 id='setTime'>Set time parameters</h2><span id='topic+setTime'></span>

<h3>Description</h3>

<p>Updates a LandsepiParams object with time parameters : Nyears and nTSpY
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setTime(params, Nyears, nTSpY)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setTime_+3A_params">params</code></td>
<td>
<p>a LandsepiParams Object.</p>
</td></tr>
<tr><td><code id="setTime_+3A_nyears">Nyears</code></td>
<td>
<p>an integer giving the number of cropping seasons (e.g. years) to simulate.</p>
</td></tr>
<tr><td><code id="setTime_+3A_ntspy">nTSpY</code></td>
<td>
<p>an integer giving the number of time steps per cropping season (e.g. days).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a LandsepiParams object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simul_params &lt;- createSimulParams()
simul_params &lt;- setTime(simul_params, Nyears=10, nTSpY=120)
simul_params@TimeParam

## End(Not run)
</code></pre>

<hr>
<h2 id='setTreatment'>Set chemical treatments</h2><span id='topic+setTreatment'></span>

<h3>Description</h3>

<p>Updates a LandsepiParams object with treatment parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setTreatment(params, treatment_params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setTreatment_+3A_params">params</code></td>
<td>
<p>a LandsepiParams Object.</p>
</td></tr>
<tr><td><code id="setTreatment_+3A_treatment_params">treatment_params</code></td>
<td>
<p>list of parameters related to pesticide treatments: </p>

<ul>
<li><p> treatment_degradation_rate = degradation rate (per time step) of chemical concentration,
</p>
</li>
<li><p> treatment_efficiency = maximal efficiency of chemical treatments
(i.e. fractional reduction of pathogen infection rate at the time of application),
</p>
</li>
<li><p> treatment_timesteps = vector of time steps corresponding to treatment application dates,
</p>
</li>
<li><p> treatment_cultivars = vector of indices of the cultivars that receive treatments,
</p>
</li>
<li><p> treatment_cost = cost of a single treatment application (monetary units/ha)
</p>
</li>
<li><p> treatment_application_threshold = vector of thresholds
(i.e. disease severity, one for each treated cultivar) above which the treatment
is applied in a polygon.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Chemical treatment is applied in a polygon only if disease severity (i.e. I/N) in
this polygon exceeds the threshold given by <code>treatment_application_threshold</code>.
Treatment efficiency is maximum (i.e. equal to the parameter treatment_efficiency)
at the time of treatment application (noted <code class="reqn">t*</code>); then it decreases with time
(i.e. natural pesticide degradation) and host growth (i.e. new biomass is not protected
by treatments):                                                                                                                                                                                     protected by treatments):Efficiency of the treatment at time t after the application date is given by:
<code class="reqn"> efficiency(t) = treatment\_efficiency / (1 + exp(a-b*C(t))) </code>
with <code class="reqn"> C(t)= C_1 * C_2</code>: </p>

<ul>
<li><p><code class="reqn">C_1 = exp(- treatment\_degradation\_rate * \Delta t) </code> is the reduction of
fungicide concentration due to time (e.g. natural degradation, volatilization, weathering),
with <code class="reqn">\Delta t = t - t*</code> the timelag passed since the time of
treatment application.
</p>
</li>
<li> <p><code class="reqn"> C_2 = min(1, N(t*) / N(t)) </code> is the reduction of fungicide concentration due
to plant growth, since new plant tissue is not covered by fungicide.
<code class="reqn">N(t*)</code> and <code class="reqn">N(t)</code> being the number of
host individuals  a the time of treatment <code class="reqn">t*</code> and at time <code class="reqn">t</code>, respectively.
</p>
</li>
<li> <p><code class="reqn">a \in [3.5 ; 4.5]</code> and <code class="reqn">b \in [8 ; 9]</code> are shape parameters.
</p>
</li></ul>

<p>An empty list of treatments (i.e. absence of application) can be loaded using
<code><a href="#topic+loadPathogen">loadPathogen</a></code>.
</p>


<h3>Value</h3>

<p>a LandsepiParams object
</p>


<h3>See Also</h3>

<p><a href="#topic+loadTreatment">loadTreatment</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
t &lt;- loadTreatment()
simul_params &lt;- setTreatment(simul_params, t)
simul_params@Treatment

## End(Not run)
</code></pre>

<hr>
<h2 id='show'>show</h2><span id='topic+show'></span><span id='topic+show+2CLandsepiParams-method'></span>

<h3>Description</h3>

<p>Shows a LandsepiParams object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LandsepiParams'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show_+3A_object">object</code></td>
<td>
<p>a LandsepiParams object</p>
</td></tr>
</table>

<hr>
<h2 id='simul_landsepi'>Simulation with input parameters as data.frames.</h2><span id='topic+simul_landsepi'></span>

<h3>Description</h3>

<p>Stochastic, spatially-explicit, demo-genetic model simulating the spread and evolution
of a pathogen in a heterogeneous landscape and generating a wide range of epidemiological, evolutionary
and economic outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simul_landsepi(
  seed = 12345,
  time_param = list(Nyears = 5, nTSpY = 120),
  croptype_names = c("Susceptible crop"),
  croptypes_cultivars_prop = data.frame(croptypeID = 0, cultivarID = 0, proportion = 1),
  cultivars = data.frame(cultivarName = "Susceptible", initial_density = 0.1, max_density
    = 2, growth_rate = 0.1, reproduction_rate = 0, yield_H = 2.5, yield_L = 0, yield_I =
    0, yield_R = 0, planting_cost = 225, market_value = 200),
  cultivars_genes_list = list(numeric(0)),
  genes = data.frame(geneName = character(0), mutation_prob = numeric(0), efficiency =
    numeric(0), tradeoff_strength = numeric(0), Nlevels_aggressiveness = numeric(0),
    adaptation_cost = numeric(0), relative_advantage = numeric(0), age_of_activ_mean =
    numeric(0), age_of_activ_var = numeric(0), target_trait = character(0),
    recombination_sd = numeric(0)),
  landscape = NULL,
  area = 1e+06,
  rotation = data.frame(year_1 = c(0), year_2 = c(0), year_3 = c(0), year_4 = c(0),
    year_5 = c(0), year_6 = c(0)),
  basic_patho_param = list(name = "rust", survival_prob = 1e-04, repro_sex_prob = 0,
    infection_rate = 0.4, propagule_prod_rate = 3.125, latent_period_mean = 10,
    latent_period_var = 9, infectious_period_mean = 24, infectious_period_var = 105,
    sigmoid_kappa = 5.333, sigmoid_sigma = 3, sigmoid_plateau = 1,
    sex_propagule_viability_limit = 1, sex_propagule_release_mean = 1,
    clonal_propagule_gradual_release = 0),
  disp_patho_clonal = c(1),
  disp_patho_sex = c(1),
  disp_host = c(1),
  treatment = list(treatment_degradation_rate = 0.1, treatment_efficiency = 0,
    treatment_timesteps = logical(0), treatment_cultivars = logical(0), treatment_cost =
    0, treatment_application_threshold = logical(0)),
  pI0 = c(5e-04),
  epid_outputs = "all",
  evol_outputs = "all",
  thres_breakdown = 50000,
  audpc100S = 0.76,
  writeTXT = TRUE,
  graphic = TRUE,
  videoMP4 = FALSE,
  keepRawResults = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simul_landsepi_+3A_seed">seed</code></td>
<td>
<p>an integer used as seed value (for random number generator).</p>
</td></tr>
<tr><td><code id="simul_landsepi_+3A_time_param">time_param</code></td>
<td>
<p>a list of simulation parameters:</p>

<ul>
<li><p> Nyears = number cropping seasons,
</p>
</li>
<li><p> nTSpY = number of time-steps per cropping season.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simul_landsepi_+3A_croptype_names">croptype_names</code></td>
<td>
<p>a vector of croptypes names.</p>
</td></tr>
<tr><td><code id="simul_landsepi_+3A_croptypes_cultivars_prop">croptypes_cultivars_prop</code></td>
<td>
<p>a dataframe with three columns named 'croptypeID' for croptype index,
'cultivarID' for cultivar index and 'proportion' for the proportion of the cultivar within the croptype.</p>
</td></tr>
<tr><td><code id="simul_landsepi_+3A_cultivars">cultivars</code></td>
<td>
<p>a dataframe of parameters associated with each host genotype (i.e. cultivars)
when cultivated in pure crops. Columns of the dataframe are:</p>

<ul>
<li><p> cultivarName: cultivar names,
</p>
</li>
<li><p> initial_density: host densities (per square meter) at the beginning of the cropping season
as if cultivated in pure crop,
</p>
</li>
<li><p> max_density: maximum host densities (per square meter) at the end of the cropping season
as if cultivated in pure crop,
</p>
</li>
<li><p> growth_rate: host growth rates,
</p>
</li>
<li><p> reproduction rate: host reproduction rates,
</p>
</li>
<li><p> yield_H: theoretical yield (in weight or volume units / ha / cropping season) associated with
hosts in sanitary status H as if cultivated in pure crop,
</p>
</li>
<li><p> yield_L: theoretical yield (in weight or volume units / ha / cropping season) associated with
hosts in sanitary status L as if cultivated in pure crop,
</p>
</li>
<li><p> yield_I: theoretical yield (in weight or volume units / ha / cropping season) associated with
hosts in sanitary status I as if cultivated in pure crop,
</p>
</li>
<li><p> yield_R: theoretical yield (in weight or volume units / ha / cropping season) associated with
hosts in sanitary status R as if cultivated in pure crop,
</p>
</li>
<li><p> planting_cost = planting costs (in monetary units / ha / cropping season) as if cultivated in pure crop,
</p>
</li>
<li><p> market_value = market values of the production (in monetary units / weight or volume unit).
</p>
</li></ul>
</td></tr>
<tr><td><code id="simul_landsepi_+3A_cultivars_genes_list">cultivars_genes_list</code></td>
<td>
<p>a list containing, for each host genotype, the indices of carried resistance genes.</p>
</td></tr>
<tr><td><code id="simul_landsepi_+3A_genes">genes</code></td>
<td>
<p>a data.frame of parameters associated with each resistance gene and with the evolution of
each corresponding pathogenicity gene. Columns of the dataframe are:</p>

<ul>
<li><p> geneName: names of resistance genes,
</p>
</li>
<li><p> target_trait: aggressiveness components (IR, LAT, IP, or PR) targeted by resistance genes,
</p>
</li>
<li><p> efficiency: resistance gene efficiencies (percentage of reduction of targeted aggressiveness components:
IR, 1/LAT, IP and PR),
</p>
</li>
<li><p> age_of_activ_mean: expected delays to resistance activation (for APRs),
</p>
</li>
<li><p> age_of_activ_var: variances of the delay to resistance activation (for APRs),
</p>
</li>
<li><p> mutation_prob: mutation probabilities for pathogenicity genes (each of them corresponding to a resistance gene),
</p>
</li>
<li><p> Nlevels_aggressiveness: number of adaptation levels related to each resistance gene (i.e. 1 + number
of required mutations for a pathogenicity gene to fully adapt to the corresponding resistance gene),
</p>
</li>
<li><p> adaptation_cost: fitness penalties paid by pathogen genotypes fully adapted
to the considered resistance genes on all hosts,
</p>
</li>
<li><p> relative_advantage: fitness advantages of pathogen genotype fully adapted to the considered resistance
genes on hosts carrying these genes, relative to those that do not carry these genes,
</p>
</li>
<li><p> tradeoff_strength: strengths of the trade-off relationships between the level of aggressiveness
on hosts that do and do not carry the resistance genes.
</p>
</li>
<li><p> recombination_sd: standard deviation of the normal distribution used for recombination of quantitative traits during sexual reproduction (infinitesimal model)
</p>
</li></ul>
</td></tr>
<tr><td><code id="simul_landsepi_+3A_landscape">landscape</code></td>
<td>
<p>a sp object containing the landscape (required only if videoMP4=TRUE).</p>
</td></tr>
<tr><td><code id="simul_landsepi_+3A_area">area</code></td>
<td>
<p>a vector containing polygon areas (must be in square meters).</p>
</td></tr>
<tr><td><code id="simul_landsepi_+3A_rotation">rotation</code></td>
<td>
<p>a dataframe containing for each field (rows) and year (columns, named &quot;year_1&quot;, &quot;year_2&quot;, etc.),
the index of the cultivated croptype. Importantly, the matrix must contain 1 more column than the real number
of simulated years.</p>
</td></tr>
<tr><td><code id="simul_landsepi_+3A_basic_patho_param">basic_patho_param</code></td>
<td>
<p>a list of i. pathogen aggressiveness parameters on a susceptible host
for a pathogen genotype not adapted to resistance and ii. sexual reproduction parameters: </p>

<ul>
<li><p> infection_rate = maximal expected infection rate of a propagule on a healthy host,
</p>
</li>
<li><p> propagule_prod_rate = maximal expected effective propagule production rate of an infectious host per time step,
</p>
</li>
<li><p> latent_period_mean = minimal expected duration of the latent period,
</p>
</li>
<li><p> latent_period_var = variance of the latent period duration,
</p>
</li>
<li><p> infectious_period_mean = maximal expected duration of the infectious period,
</p>
</li>
<li><p> infectious_period_var = variance of the infectious period duration,
</p>
</li>
<li><p> survival_prob = probability for a propagule to survive the off-season (can be entered as a matrix
to give a different probability for every year (rows) and every croptype (columns)),
</p>
</li>
<li><p> repro_sex_prob = probability for an infectious host to reproduce via sex rather than via cloning
(can be entered as a vector of size <code>time_param$nSTpY+1</code> to give a different probability for every time step),
</p>
</li>
<li><p> sigmoid_kappa = kappa parameter of the sigmoid contamination function,
</p>
</li>
<li><p> sigmoid_sigma = sigma parameter of the sigmoid contamination function,
</p>
</li>
<li><p> sigmoid_plateau = plateau parameter of the sigmoid contamination function,
</p>
</li>
<li><p> sex_propagule_viability_limit = maximum number of cropping seasons up to which a sexual propagule is viable
</p>
</li>
<li><p> sex_propagule_release_mean = average number of seasons after which a sexual propagule is released,
</p>
</li>
<li><p> clonal_propagule_gradual_release = Whether or not clonal propagules surviving the bottleneck are gradually released along the following cropping season.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simul_landsepi_+3A_disp_patho_clonal">disp_patho_clonal</code></td>
<td>
<p>a vectorized matrix giving the probability of pathogen dispersal
from any field of the landscape to any other field.</p>
</td></tr>
<tr><td><code id="simul_landsepi_+3A_disp_patho_sex">disp_patho_sex</code></td>
<td>
<p>a vectorized matrix giving the probability of pathogen dispersal for sexual propagules
from any field of the landscape to any other field.</p>
</td></tr>
<tr><td><code id="simul_landsepi_+3A_disp_host">disp_host</code></td>
<td>
<p>a vectorized matrix giving the probability of host dispersal
from any field of the landscape to any other field</p>
</td></tr>
<tr><td><code id="simul_landsepi_+3A_treatment">treatment</code></td>
<td>
<p>list of parameters related to pesticide treatments: </p>

<ul>
<li><p> treatment_degradation_rate = degradation rate (per time step) of chemical concentration,
</p>
</li>
<li><p> treatment_efficiency = maximal efficiency of chemical treatments (i.e. fractional reduction
of pathogen infection rate at the time of application),
</p>
</li>
<li><p> treatment_timesteps = vector of time-steps corresponding to treatment application dates,
</p>
</li>
<li><p> treatment_cultivars = vector of indices of the cultivars that receive treatments,
</p>
</li>
<li><p> treatment_cost = cost of a single treatment application (monetary units/ha)
</p>
</li>
<li><p> treatment_application_threshold = vector of thresholds (i.e. disease severity, one for each treated cultivar)
above which the treatment is applied in a polygon
</p>
</li></ul>
</td></tr>
<tr><td><code id="simul_landsepi_+3A_pi0">pI0</code></td>
<td>
<p>probability for the first cultivar to be infected (and infectious, i.e. state I) by the
first pathogen genotype in all polygons of the landscape at t=0 (i.e. the beginning of the simulation).
It can also be entered as a vector of length Nhost<em>Npatho</em>Npoly giving the probability
for each cultivar, pathogen genotype and polygon (independently from the possible presence of
cultivars carrying resistance genes).</p>
</td></tr>
<tr><td><code id="simul_landsepi_+3A_epid_outputs">epid_outputs</code></td>
<td>
<p>a character string (or a vector of character strings if several outputs are to be computed)
specifying the type of epidemiological and economic outputs to generate (see details):
</p>

<ul>
<li><p> &quot;audpc&quot; : Area Under Disease Progress Curve (average number of diseased host individuals
per time step and square meter)
</p>
</li>
<li><p> &quot;audpc_rel&quot; : Relative Area Under Disease Progress Curve (average proportion of diseased host
individuals relative to the total number of existing hosts)
</p>
</li>
<li><p> &quot;gla&quot; : Green Leaf Area (average number of healthy host individuals per time step and square meter)
</p>
</li>
<li><p> &quot;gla_rel&quot; : Relative Green Leaf Area (average proportion of healthy host individuals relative to the
total number of existing hosts)
</p>
</li>
<li><p> &quot;eco_yield&quot; : total crop yield (in weight or volume units per ha)
</p>
</li>
<li><p> &quot;eco_cost&quot; : operational crop costs (in monetary units per ha)
</p>
</li>
<li><p> &quot;eco_product&quot; : total crop products (in monetary units per ha)
</p>
</li>
<li><p> &quot;eco_margin&quot; : Margin (products - operational costs, in monetary units per ha)
</p>
</li>
<li><p> &quot;contrib&quot;: contribution of pathogen genotypes to LIR dynamics
</p>
</li>
<li><p> &quot;HLIR_dynamics&quot;, &quot;H_dynamics&quot;, &quot;L_dynamics&quot;, &quot;IR_dynamics&quot;, &quot;HLI_dynamics&quot;, etc.: Epidemic dynamics
related to the specified sanitary status (H, L, I or R and all their combinations). Graphics only,
works only if graphic=TRUE.
</p>
</li>
<li><p> &quot;all&quot; : compute all these outputs (default)
</p>
</li>
<li><p> &quot;&quot; : none of these outputs will be generated.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simul_landsepi_+3A_evol_outputs">evol_outputs</code></td>
<td>
<p>a character string (or a vector of character strings if several outputs are to be computed)
specifying the type of evolutionary outputs to generate :</p>

<ul>
<li><p> &quot;evol_patho&quot;: Dynamics of pathogen genotype frequencies
</p>
</li>
<li><p> &quot;evol_aggr&quot;: Evolution of pathogen aggressiveness
</p>
</li>
<li><p> &quot;durability&quot;: Durability of resistance genes
</p>
</li>
<li><p> &quot;all&quot;: compute all these outputs (default)
</p>
</li>
<li><p> &quot;&quot;: none of these outputs will be generated.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simul_landsepi_+3A_thres_breakdown">thres_breakdown</code></td>
<td>
<p>an integer (or vector of integers) giving the threshold (i.e. number of infections)
above which a pathogen genotype is unlikely to go extinct, used to characterise the time to invasion
of resistant hosts (several values are computed if several thresholds are given in a vector).</p>
</td></tr>
<tr><td><code id="simul_landsepi_+3A_audpc100s">audpc100S</code></td>
<td>
<p>the audpc in a fully susceptible landscape (used as reference value for graphics).</p>
</td></tr>
<tr><td><code id="simul_landsepi_+3A_writetxt">writeTXT</code></td>
<td>
<p>a logical indicating if outputs must be written in text files (TRUE, default) or not (FALSE).</p>
</td></tr>
<tr><td><code id="simul_landsepi_+3A_graphic">graphic</code></td>
<td>
<p>a logical indicating if graphics must be generated (TRUE, default) or not (FALSE).</p>
</td></tr>
<tr><td><code id="simul_landsepi_+3A_videomp4">videoMP4</code></td>
<td>
<p>a logical indicating if a video must be generated (TRUE) or not (FALSE, default).
Works only if graphic=TRUE and epid_outputs=&quot;audpc_rel&quot; (or epid_outputs=&quot;all&quot;).</p>
</td></tr>
<tr><td><code id="simul_landsepi_+3A_keeprawresults">keepRawResults</code></td>
<td>
<p>a logical indicating if binary files must be kept after the end of the simulation (default=FALSE).
Careful, many files may be generated if keepRawResults=TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>?landsepi</code> for details on the model and assumptions.
Briefly, the model is stochastic, spatially explicit (the basic spatial unit is an individual field), based on a SEIR
(‘susceptible-exposed-infectious-removed’, renamed HLIR for 'healthy-latent-infectious-removed' to avoid confusions
with 'susceptible host') structure with a discrete time step. It simulates the spread and
evolution (via mutation, recombination through sexual reproduction, selection and drift)
of a pathogen in a heterogeneous cropping landscape, across cropping seasons split by host harvests which impose
potential bottlenecks to the pathogen. A wide array of resistance deployment strategies
(possibly including chemical treatments) can be simulated and evaluated using several possible
outputs to assess the epidemiological, evolutionary and economic performance
of deployment strategies (See <code>?epid_output</code> and <code>?evol_output</code> for details).
</p>


<h3>Value</h3>

<p>A list containing all outputs that have been required via &quot;epid_outputs&quot; and &quot;evol_outputs&quot;.
A set of text files, graphics and a video showing epidemic dynamics can be generated.
If keepRawResults=TRUE, a set of binary files is generated for every year of simulation and
every compartment: </p>

<ul>
<li><p> H: healthy hosts,
</p>
</li>
<li><p> Hjuv: juvenile healthy hosts (for host reproduction),
</p>
</li>
<li><p> L: latently infected hosts,
</p>
</li>
<li><p> I: infectious hosts,
</p>
</li>
<li><p> R: removed hosts,
</p>
</li>
<li><p> P: propagules.</p>
</li></ul>

<p>Each file indicates for every time-step the number of individuals in each field, and when appropriate for
each host and pathogen genotype. Additionally, a binary file called TFI is
generated and gives the Treatment Frequency Indicator (expressed as the number of treatment applications
per polygon).
</p>


<h3>References</h3>

<p>Rimbaud L., Papaïx J., Rey J.-F., Barrett L. G. and Thrall P. H. (2018).
Assessing the durability andefficiency of landscape-based strategies to deploy
plant resistance to pathogens. <em>PLoS Computational Biology</em> 14(4):e1006067.
</p>


<h3>See Also</h3>

<p><a href="#topic+model_landsepi">model_landsepi</a>, <a href="#topic+epid_output">epid_output</a>, <a href="#topic+evol_output">evol_output</a>, <a href="#topic+video">video</a>, <a href="#topic+runSimul">runSimul</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#### Spatially-implicit simulation with a single 1-km^2 patch 100% cultivated 
# with a susceptible cultivar

simul_landsepi()

#### Spatially-implicit simulation with 2 patches (S + R) during 3 years ####

## Simulation parameters
time_param &lt;- list(Nyears = 3, nTSpY = 120)
area &lt;- c(100000, 100000)
rotation &lt;- data.frame(year_1 = c(0, 1), year_2 = c(0, 1), year_3 = c(0, 1), year_4 = c(0, 1))
croptype_names &lt;- c("Susceptible crop", "Resistant crop")
croptypes_cultivars_prop &lt;- data.frame(
croptypeID = c(0, 1),
cultivarID = c(0, 1),
proportion = c(1, 1)
)
cultivars &lt;- rbind(
loadCultivar(name = "Susceptible", type = "growingHost"),
loadCultivar(name = "Resistant", type = "growingHost")
)
genes &lt;- loadGene(name = "MG", type = "majorGene")
cultivars_genes_list &lt;- list(numeric(0), 0)

## Run simulation
simul_landsepi(
seed = 12345, time_param, croptype_names, croptypes_cultivars_prop, cultivars,
cultivars_genes_list, genes, landscape = NULL, area, rotation,
basic_patho_param = loadPathogen(disease = "rust"),
disp_patho_clonal = c(0.99, 0.01, 0.01, 0.99),
disp_patho_sex = c(0.99, 0.01, 0.01, 0.99),
disp_host = c(1, 0, 0, 1),
pI0 = c(5e-4)
)


#### Spatially-explicit simulation with built-in landscape during 10 years ####
# Generate a mosaic of four croptypes in balanced proportions
# and medium level of spatial aggregation

## Simulation and Landscape parameters
Nyears &lt;- 10
nTSpY &lt;- 120
landscape &lt;- loadLandscape(1)
Npoly &lt;- length(landscape)
library(sf)
area &lt;- st_area(st_as_sf(landscape))
rotation &lt;- AgriLand(landscape, Nyears,
rotation_period = 1, rotation_realloc = FALSE,
rotation_sequence = c(0, 1, 2, 3),
prop = rep(1 / 4, 4), aggreg = 0.5, graphic = TRUE, outputDir = getwd()
)
rotation &lt;- data.frame(rotation)[, 1:(Nyears + 1)]
croptype_names &lt;- c("Susceptible crop"
, "Resistant crop 1"
, "Resistant crop 2"
, "Resistant crop 3")
croptypes_cultivars_prop &lt;- data.frame(croptypeID = c(0, 1, 2, 3), cultivarID = c(0, 1, 2, 3),
proportion = c(1, 1, 1, 1))
cultivars &lt;- data.frame(rbind(
loadCultivar(name = "Susceptible", type = "growingHost"),
loadCultivar(name = "Resistant1", type = "growingHost"),
loadCultivar(name = "Resistant2", type = "growingHost"),
loadCultivar(name = "Resistant3", type = "growingHost")
), stringsAsFactors = FALSE)
Nhost &lt;- nrow(cultivars)
genes &lt;- data.frame(rbind(
loadGene(name = "MG 1", type = "majorGene"),
loadGene(name = "MG 2", type = "majorGene"),
loadGene(name = "MG 3", type = "majorGene")
), stringsAsFactors = FALSE)
cultivars_genes_list &lt;- list(numeric(0), 0, 1, 2)
Npatho &lt;- prod(genes$Nlevels_aggressiveness)

## Run simulation
simul_landsepi(
seed = 12345, time_param = list(Nyears = Nyears, nTSpY = nTSpY),
croptype_names, croptypes_cultivars_prop, cultivars,
cultivars_genes_list, genes, landscape, area, rotation,
basic_patho_param = loadPathogen(disease = "rust"),
disp_patho_clonal = loadDispersalPathogen(1)[[1]],
disp_patho_sex = as.numeric(diag(Npoly)),
disp_host = as.numeric(diag(Npoly)),
pI0 = c(5E-4)
)

## End(Not run)

</code></pre>

<hr>
<h2 id='summary'>summary</h2><span id='topic+summary'></span><span id='topic+summary+2CLandsepiParams-method'></span>

<h3>Description</h3>

<p>Prints the summary of a LandsepiParams object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LandsepiParams'
summary(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>a LandsepiParams object.</p>
</td></tr>
</table>

<hr>
<h2 id='survivalProbToMatrix'>Survival probability To Matrix</h2><span id='topic+survivalProbToMatrix'></span>

<h3>Description</h3>

<p>Transform the off-season survival probability of the pathogen
(1D vector of length Nyears*Ncroptypes) into a matrix (for visualization purpose)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survivalProbToMatrix(params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survivalProbToMatrix_+3A_params">params</code></td>
<td>
<p>a LandsepiParams object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After updating the off-season survival probability with <code>updateSurvivalProb()</code>,
this function returns the probability as a matrix for every year (rows) and croptypes (columns)
as well as, if croptypes have been previously allocated to a landscape, a matrix for every
polygon (rows) and year (columns).
</p>


<h3>Value</h3>

<p>a list containing a matrix of dimensions (Nyears, Ncroptypes) as well as a matrix of
dimensions (Npoly, Nyears)
</p>


<h3>See Also</h3>

<p><a href="#topic+updateSurvivalProb">updateSurvivalProb</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simul_params &lt;- createSimulParams()
simul_params &lt;- setTime(simul_params, Nyears=10, nTSpY=120)
simul_params &lt;- setPathogen(simul_params, loadPathogen("rust"))

cultivar1 &lt;- loadCultivar(name = "Susceptible", type = "wheat")
cultivar2 &lt;- loadCultivar(name = "Resistant", type = "wheat")
cultivars &lt;- data.frame(rbind(cultivar1, cultivar2), stringsAsFactors = FALSE)
simul_params &lt;- setCultivars(simul_params, cultivars)

croptypes &lt;- loadCroptypes(simul_params
, names = c("Susceptible crop", "Resistant crop", "Mixture"))
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Susceptible crop", "Susceptible")
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Resistant crop", "Resistant")
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Mixture", c("Susceptible", "Resistant"))
simul_params &lt;- setCroptypes(simul_params, croptypes)

Ncroptypes &lt;- nrow(simul_params@Croptypes)
Nyears &lt;- simul_params@TimeParam$Nyears

landscape &lt;- loadLandscape(1)
simul_params &lt;- setLandscape(simul_params, landscape)
simul_params &lt;- allocateLandscapeCroptypes(simul_params,
rotation_period = 0, rotation_sequence = croptypes$croptypeID,
rotation_realloc = FALSE,
prop = rep(1/Ncroptypes, Ncroptypes),
aggreg = 0.05, graphic = FALSE)

## One probability per year and per croptype:
simul_params &lt;- updateSurvivalProb(simul_params
, mat=matrix(runif(Nyears*Ncroptypes), ncol=Ncroptypes))
simul_params@Pathogen
survivalProbToMatrix(simul_params)

## End(Not run)
</code></pre>

<hr>
<h2 id='switch_patho_to_aggr'>Switch from index of genotype to indices of agressiveness on different components</h2><span id='topic+switch_patho_to_aggr'></span>

<h3>Description</h3>

<p>Finds the level of aggressiveness on different components (targeted by different resistance genes)
from the index of a given pathogen genotype
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switch_patho_to_aggr(index_patho, Ngenes, Nlevels_aggressiveness)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="switch_patho_to_aggr_+3A_index_patho">index_patho</code></td>
<td>
<p>index of pathogen genotype</p>
</td></tr>
<tr><td><code id="switch_patho_to_aggr_+3A_ngenes">Ngenes</code></td>
<td>
<p>number of resistance genes</p>
</td></tr>
<tr><td><code id="switch_patho_to_aggr_+3A_nlevels_aggressiveness">Nlevels_aggressiveness</code></td>
<td>
<p>vector of the number of adaptation levels related to each resistance gene</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the indices of aggressiveness on the different components targeted by the resistance genes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>switch_patho_to_aggr(5, 3, c(2, 2, 3))
</code></pre>

<hr>
<h2 id='updateReproSexProb'>Update the probability of sexual reproduction</h2><span id='topic+updateReproSexProb'></span>

<h3>Description</h3>

<p>set the probabilities for an infectious host to reproduce via sex rather
than via cloning at every time step.
Note that time parameters must be set before updating sexual reproduction probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateReproSexProb(params, vec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="updateReproSexProb_+3A_params">params</code></td>
<td>
<p>a LandsepiParams object</p>
</td></tr>
<tr><td><code id="updateReproSexProb_+3A_vec">vec</code></td>
<td>
<p>a vector of size TimeParam$nTSpY +1 (season end) with the probabilities
for an infectious host to reproduce via sex rather than via cloning at each time step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a LandsepiParams object updated
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simul_params &lt;- createSimulParams()
simul_params &lt;- setTime(simul_params, Nyears=10, nTSpY=120)
simul_params &lt;- setPathogen(simul_params, loadPathogen("rust"))
repro_sex_probs &lt;- c(rep(0.0, 120), 1.0)  
simul_params &lt;- updateReproSexProb(simul_params, repro_sex_probs)
simul_params@Pathogen

## End(Not run)
</code></pre>

<hr>
<h2 id='updateSurvivalProb'>Update pathogen survival probability during the off-season</h2><span id='topic+updateSurvivalProb'></span>

<h3>Description</h3>

<p>update survival probability of the pathogen with a probability value for every
simulated year (number of years = Nyears) and every croptype (number of croptypes = Ncroptypes).
Note that time parameters, pathogen and croptypes must be set before updating
survival probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateSurvivalProb(params, mat_year = NULL, mat_croptype = NULL, mat = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="updateSurvivalProb_+3A_params">params</code></td>
<td>
<p>a LandsepiParams object</p>
</td></tr>
<tr><td><code id="updateSurvivalProb_+3A_mat_year">mat_year</code></td>
<td>
<p>a vector of size Nyear, giving survival probabilities for every year
(replicated for every croptype).</p>
</td></tr>
<tr><td><code id="updateSurvivalProb_+3A_mat_croptype">mat_croptype</code></td>
<td>
<p>a vector of size Ncroptypes, giving survival probabilities for
every croptype (replicated for every year).</p>
</td></tr>
<tr><td><code id="updateSurvivalProb_+3A_mat">mat</code></td>
<td>
<p>a matrix of dimension (Nyears, Ncroptypes) giving survival probabilities
for every year (rows)
and every croptype (columns).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unless the matrix <code>mat</code> is filled, the matrix containing the survival
probability during the offseason
is computed for every year and croptype with
<code>mat[year, croptype] = mat_year[year] * mat_croptype[croptype]</code>. <br />
</p>


<h3>Value</h3>

<p>a LandsepiParams object updated.
</p>


<h3>See Also</h3>

<p><a href="#topic+survivalProbToMatrix">survivalProbToMatrix</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simul_params &lt;- createSimulParams()
simul_params &lt;- setTime(simul_params, Nyears=10, nTSpY=120)
simul_params &lt;- setPathogen(simul_params, loadPathogen("rust"))

cultivar1 &lt;- loadCultivar(name = "Susceptible", type = "wheat")
cultivar2 &lt;- loadCultivar(name = "Resistant", type = "wheat")
cultivars &lt;- data.frame(rbind(cultivar1, cultivar2), stringsAsFactors = FALSE)
simul_params &lt;- setCultivars(simul_params, cultivars)

croptypes &lt;- loadCroptypes(simul_params
, names = c("Susceptible crop", "Resistant crop", "Mixture"))
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Susceptible crop", "Susceptible")
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Resistant crop", "Resistant")
croptypes &lt;- allocateCroptypeCultivars(croptypes, "Mixture", c("Susceptible", "Resistant"))
simul_params &lt;- setCroptypes(simul_params, croptypes)
Ncroptypes &lt;- nrow(simul_params@Croptypes)
Nyears &lt;- simul_params@TimeParam$Nyears

## Same probability in every croptype:
simul_params &lt;- updateSurvivalProb(simul_params, mat_year=1:Nyears/100)
simul_params@Pathogen
## Same probability every year:
simul_params &lt;- updateSurvivalProb(simul_params, mat_croptype=1:Ncroptypes/10)
simul_params@Pathogen
## specific probability for different croptypes and years:
simul_params &lt;- updateSurvivalProb(simul_params
, mat_year=1:Nyears/100, mat_croptype=1:Ncroptypes/10)
simul_params@Pathogen
## One probability per year and per croptype:
simul_params &lt;- updateSurvivalProb(simul_params
, mat=matrix(runif(Nyears*Ncroptypes), ncol=Ncroptypes))
simul_params@Pathogen
survivalProbToMatrix(simul_params)

## End(Not run)
</code></pre>

<hr>
<h2 id='video'>Generation of a video</h2><span id='topic+video'></span>

<h3>Description</h3>

<p>Generates a video showing the epidemic dynamics on a map representing the cropping landscape.
(requires ffmpeg library).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>video(
  audpc,
  time_param,
  Npatho,
  landscape,
  area,
  rotation,
  croptypes,
  croptype_names = c(),
  cultivars_param,
  keyDates = NULL,
  nMapPY = 10,
  path = getwd()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="video_+3A_audpc">audpc</code></td>
<td>
<p>A dataframe containing audpc outputs (generated through epid_output). 1 line per year and
1 column per cultivar, with an additional column for the average audpc in the landscape.</p>
</td></tr>
<tr><td><code id="video_+3A_time_param">time_param</code></td>
<td>
<p>list of simulation parameters:</p>

<ul>
<li><p> Nyears = number cropping seasons,
</p>
</li>
<li><p> nTSpY = number of time-steps per cropping season.
</p>
</li></ul>
</td></tr>
<tr><td><code id="video_+3A_npatho">Npatho</code></td>
<td>
<p>number of pathogen genotypes.</p>
</td></tr>
<tr><td><code id="video_+3A_landscape">landscape</code></td>
<td>
<p>a sp object containing the landscape.</p>
</td></tr>
<tr><td><code id="video_+3A_area">area</code></td>
<td>
<p>a vector containing polygon areas (must be in square meters).</p>
</td></tr>
<tr><td><code id="video_+3A_rotation">rotation</code></td>
<td>
<p>a dataframe containing for each field (rows) and year (columns, named &quot;year_1&quot;, &quot;year_2&quot;, etc.),
the index of the cultivated croptype. Importantly, the matrix must contain 1 more column than the real number
of simulated years.</p>
</td></tr>
<tr><td><code id="video_+3A_croptypes">croptypes</code></td>
<td>
<p>a dataframe with three columns named 'croptypeID' for croptype index,
'cultivarID' for cultivar index and 'proportion' for the proportion of the cultivar within the croptype.</p>
</td></tr>
<tr><td><code id="video_+3A_croptype_names">croptype_names</code></td>
<td>
<p>a vector of croptype names (for legend).</p>
</td></tr>
<tr><td><code id="video_+3A_cultivars_param">cultivars_param</code></td>
<td>
<p>a list of parameters associated with each host genotype (i.e. cultivars)
when cultivated in pure crops:</p>

<ul>
<li><p> name = vector of cultivar names,
</p>
</li>
<li><p> max_density = vector of maximum host densities (per square meter) at the end of the cropping season
as if cultivated in pure crops,
</p>
</li>
<li><p> cultivars_genes_list = a list containing, for each host genotype, the indices of carried resistance genes.
</p>
</li></ul>
</td></tr>
<tr><td><code id="video_+3A_keydates">keyDates</code></td>
<td>
<p>a vector of times (in time steps) where to draw vertical lines in the AUDPC graphic. Usually
used to delimit durabilities of the resistance genes. No line is drawn if keyDates=NULL (default).</p>
</td></tr>
<tr><td><code id="video_+3A_nmappy">nMapPY</code></td>
<td>
<p>an integer specifying the number of epidemic maps per year to generate.</p>
</td></tr>
<tr><td><code id="video_+3A_path">path</code></td>
<td>
<p>path where binary files are located and where the video will be generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The left panel shows the year-after-year dynamics of AUDPC,
for each cultivar as well as the global average. The right panel illustrates the landscape,
where fields are hatched depending on the cultivated croptype, and coloured depending on the prevalence of the disease.
Note that up to 9 different croptypes can be represented properly in the right panel.
</p>


<h3>Value</h3>

<p>A video file of format webM
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
demo_landsepi()

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
