<!DOCTYPE html><html><head><title>Help for package httr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {httr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_headers'><p>Add additional headers to a request.</p></a></li>
<li><a href='#authenticate'><p>Use http authentication.</p></a></li>
<li><a href='#BROWSE'><p>Open specified url in browser.</p></a></li>
<li><a href='#cache_info'><p>Compute caching information for a response.</p></a></li>
<li><a href='#config'><p>Set curl options.</p></a></li>
<li><a href='#content'><p>Extract content from a request.</p></a></li>
<li><a href='#content_type'><p>Set content-type and accept headers.</p></a></li>
<li><a href='#cookies'><p>Access cookies in a response.</p></a></li>
<li><a href='#DELETE'><p>Send a DELETE request.</p></a></li>
<li><a href='#GET'><p>GET a url.</p></a></li>
<li><a href='#get_callback'><p>Install or uninstall a callback function</p></a></li>
<li><a href='#guess_media'><p>Guess the media type of a path from its extension.</p></a></li>
<li><a href='#handle'><p>Create a handle tied to a particular host.</p></a></li>
<li><a href='#handle_pool'><p>Maintain a pool of handles.</p></a></li>
<li><a href='#has_content'><p>Does the request have content associated with it?</p></a></li>
<li><a href='#HEAD'><p>Get url HEADers.</p></a></li>
<li><a href='#headers'><p>Extract the headers from a response</p></a></li>
<li><a href='#hmac_sha1'><p>HMAC SHA1</p></a></li>
<li><a href='#http_condition'><p>Generate a classed http condition.</p></a></li>
<li><a href='#http_error'><p>Check for an http error.</p></a></li>
<li><a href='#http_status'><p>Give information on the status of a request.</p></a></li>
<li><a href='#http_type'><p>Extract the content type of a response</p></a></li>
<li><a href='#httr_dr'><p>Diagnose common configuration problems</p></a></li>
<li><a href='#httr_options'><p>List available options.</p></a></li>
<li><a href='#httr-package'><p><span class="pkg">httr</span> makes http easy.</p></a></li>
<li><a href='#init_oauth1.0'><p>Retrieve OAuth 1.0 access token.</p></a></li>
<li><a href='#init_oauth2.0'><p>Retrieve OAuth 2.0 access token.</p></a></li>
<li><a href='#insensitive'><p>Create a vector with case insensitive name matching.</p></a></li>
<li><a href='#jwt_signature'><p>Generate a JWT signature given credentials.</p></a></li>
<li><a href='#modify_url'><p>Modify a url.</p></a></li>
<li><a href='#oauth_app'><p>Create an OAuth application.</p></a></li>
<li><a href='#oauth_callback'><p>The oauth callback url.</p></a></li>
<li><a href='#oauth_endpoint'><p>Describe an OAuth endpoint.</p></a></li>
<li><a href='#oauth_endpoints'><p>Popular oauth endpoints.</p></a></li>
<li><a href='#oauth_exchanger'><p>Walk the user through the OAuth2 dance without a local webserver.</p></a></li>
<li><a href='#oauth_listener'><p>Create a webserver to listen for OAuth callback.</p></a></li>
<li><a href='#oauth_service_token'><p>Generate OAuth token for service accounts.</p></a></li>
<li><a href='#oauth_signature'><p>Generate oauth signature.</p></a></li>
<li><a href='#oauth1.0_token'><p>Generate an oauth1.0 token.</p></a></li>
<li><a href='#oauth2.0_token'><p>Generate an oauth2.0 token.</p></a></li>
<li><a href='#parse_http_date'><p>Parse and print http dates.</p></a></li>
<li><a href='#parse_media'><p>Parse a media type.</p></a></li>
<li><a href='#parse_url'><p>Parse and build urls according to RFC3986.</p></a></li>
<li><a href='#PATCH'><p>Send PATCH request to a server.</p></a></li>
<li><a href='#POST'><p>POST file to a server.</p></a></li>
<li><a href='#progress'><p>Add a progress bar.</p></a></li>
<li><a href='#PUT'><p>Send PUT request to server.</p></a></li>
<li><a href='#response'><p>The response object.</p></a></li>
<li><a href='#RETRY'><p>Retry a request until it succeeds.</p></a></li>
<li><a href='#revoke_all'><p>Revoke all OAuth tokens in the cache.</p></a></li>
<li><a href='#set_config'><p>Set (and reset) global httr configuration.</p></a></li>
<li><a href='#set_cookies'><p>Set cookies.</p></a></li>
<li><a href='#sha1_hash'><p>SHA1 hash</p></a></li>
<li><a href='#sign_oauth'><p>Sign an OAuth request</p></a></li>
<li><a href='#status_code'><p>Extract status code from response.</p></a></li>
<li><a href='#stop_for_status'><p>Take action on http error.</p></a></li>
<li><a href='#timeout'><p>Set maximum request time.</p></a></li>
<li><a href='#Token-class'><p>OAuth token objects.</p></a></li>
<li><a href='#upload_file'><p>Upload a file with <code>POST()</code> or <code>PUT()</code>.</p></a></li>
<li><a href='#use_proxy'><p>Use a proxy to connect to the internet.</p></a></li>
<li><a href='#user_agent'><p>Set user agent.</p></a></li>
<li><a href='#VERB'><p>VERB a url.</p></a></li>
<li><a href='#verbose'><p>Give verbose output.</p></a></li>
<li><a href='#with_config'><p>Execute code with configuration set.</p></a></li>
<li><a href='#write_disk'><p>Control where the response body is written.</p></a></li>
<li><a href='#write_function'><p>S3 object to define response writer.</p></a></li>
<li><a href='#write_stream'><p>Process output in a streaming manner.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tools for Working with URLs and HTTP</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.7</td>
</tr>
<tr>
<td>Description:</td>
<td>Useful tools for working with HTTP organised by HTTP verbs
    (GET(), POST(), etc). Configuration functions make it easy to control
    additional request components (authenticate(), add_headers() and so
    on).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://httr.r-lib.org/">https://httr.r-lib.org/</a>, <a href="https://github.com/r-lib/httr">https://github.com/r-lib/httr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-lib/httr/issues">https://github.com/r-lib/httr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>curl (&ge; 5.0.2), jsonlite, mime, openssl (&ge; 0.8), R6</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, httpuv, jpeg, knitr, png, readr, rmarkdown, testthat
(&ge; 0.8.0), xml2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-15 02:56:56 UTC; hadleywickham</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham [aut, cre],
  Posit, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hadley Wickham &lt;hadley@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-15 09:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_headers'>Add additional headers to a request.</h2><span id='topic+add_headers'></span>

<h3>Description</h3>

<p>Wikipedia provides a useful list of common http headers:
<a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields">https://en.wikipedia.org/wiki/List_of_HTTP_header_fields</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_headers(..., .headers = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_headers_+3A_...">...</code></td>
<td>
<p>named header values.  To stop an existing header from being
set, pass an empty string: <code>""</code>.</p>
</td></tr>
<tr><td><code id="add_headers_+3A_.headers">.headers</code></td>
<td>
<p>a named character vector</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+accept">accept()</a></code> and <code><a href="#topic+content_type">content_type()</a></code> for
convenience functions for setting accept and content-type headers.
</p>
<p>Other config: 
<code><a href="#topic+authenticate">authenticate</a>()</code>,
<code><a href="#topic+config">config</a>()</code>,
<code><a href="#topic+set_cookies">set_cookies</a>()</code>,
<code><a href="#topic+timeout">timeout</a>()</code>,
<code><a href="#topic+use_proxy">use_proxy</a>()</code>,
<code><a href="#topic+user_agent">user_agent</a>()</code>,
<code><a href="#topic+verbose">verbose</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>add_headers(a = 1, b = 2)
add_headers(.headers = c(a = "1", b = "2"))

## Not run: 
GET("http://httpbin.org/headers")

# Add arbitrary headers
GET(
  "http://httpbin.org/headers",
  add_headers(version = version$version.string)
)

# Override default headers with empty strings
GET("http://httpbin.org/headers", add_headers(Accept = ""))

## End(Not run)
</code></pre>

<hr>
<h2 id='authenticate'>Use http authentication.</h2><span id='topic+authenticate'></span>

<h3>Description</h3>

<p>It's not obvious how to turn authentication off after using it, so
I recommend using custom handles with authentication.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>authenticate(user, password, type = "basic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="authenticate_+3A_user">user</code></td>
<td>
<p>user name</p>
</td></tr>
<tr><td><code id="authenticate_+3A_password">password</code></td>
<td>
<p>password</p>
</td></tr>
<tr><td><code id="authenticate_+3A_type">type</code></td>
<td>
<p>type of HTTP authentication.  Should be one of the following
types supported by Curl: basic, digest, digest_ie, gssnegotiate,
ntlm, any.  It defaults to &quot;basic&quot;, the most common type.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other config: 
<code><a href="#topic+add_headers">add_headers</a>()</code>,
<code><a href="#topic+config">config</a>()</code>,
<code><a href="#topic+set_cookies">set_cookies</a>()</code>,
<code><a href="#topic+timeout">timeout</a>()</code>,
<code><a href="#topic+use_proxy">use_proxy</a>()</code>,
<code><a href="#topic+user_agent">user_agent</a>()</code>,
<code><a href="#topic+verbose">verbose</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
GET("http://httpbin.org/basic-auth/user/passwd")
GET(
  "http://httpbin.org/basic-auth/user/passwd",
  authenticate("user", "passwd")
)

## End(Not run)
</code></pre>

<hr>
<h2 id='BROWSE'>Open specified url in browser.</h2><span id='topic+BROWSE'></span>

<h3>Description</h3>

<p>(This isn't really a http verb, but it seems to follow the same format).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BROWSE(url = NULL, config = list(), ..., handle = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BROWSE_+3A_url">url</code></td>
<td>
<p>the url of the page to retrieve</p>
</td></tr>
<tr><td><code id="BROWSE_+3A_config">config</code></td>
<td>
<p>All configuration options are ignored because the request
is handled by the browser, not <span class="pkg">RCurl</span>.</p>
</td></tr>
<tr><td><code id="BROWSE_+3A_...">...</code></td>
<td>
<p>Further named parameters, such as <code>query</code>, <code>path</code>, etc,
passed on to <code><a href="#topic+modify_url">modify_url()</a></code>. Unnamed parameters will be combined
with <code><a href="#topic+config">config()</a></code>.</p>
</td></tr>
<tr><td><code id="BROWSE_+3A_handle">handle</code></td>
<td>
<p>The handle to use with this request. If not
supplied, will be retrieved and reused from the <code><a href="#topic+handle_pool">handle_pool()</a></code>
based on the scheme, hostname and port of the url. By default <span class="pkg">httr</span>
requests to the same scheme/host/port combo. This substantially reduces
connection time, and ensures that cookies are maintained over multiple
requests to the same host. See <code><a href="#topic+handle_pool">handle_pool()</a></code> for more
details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only works in interactive sessions.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+response">response()</a></code> object.
</p>


<h3>See Also</h3>

<p>Other http methods: 
<code><a href="#topic+DELETE">DELETE</a>()</code>,
<code><a href="#topic+GET">GET</a>()</code>,
<code><a href="#topic+HEAD">HEAD</a>()</code>,
<code><a href="#topic+PATCH">PATCH</a>()</code>,
<code><a href="#topic+POST">POST</a>()</code>,
<code><a href="#topic+PUT">PUT</a>()</code>,
<code><a href="#topic+VERB">VERB</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BROWSE("http://google.com")
BROWSE("http://had.co.nz")
</code></pre>

<hr>
<h2 id='cache_info'>Compute caching information for a response.</h2><span id='topic+cache_info'></span><span id='topic+rerequest'></span>

<h3>Description</h3>

<p><code>cache_info()</code> gives details of cacheability of a response,
<code>rerequest()</code> re-performs the original request doing as little work
as possible (if not expired, returns response as is, or performs
revalidation if Etag or Last-Modified headers are present).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cache_info(r)

rerequest(r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cache_info_+3A_r">r</code></td>
<td>
<p>A response</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Never cached, always causes redownload
r1 &lt;- GET("https://www.google.com")
cache_info(r1)
r1$date
rerequest(r1)$date

# Expires in a year
r2 &lt;- GET("https://www.google.com/images/srpr/logo11w.png")
cache_info(r2)
r2$date
rerequest(r2)$date

## Not run: 
# Has last-modified and etag, so does revalidation
r3 &lt;- GET("http://httpbin.org/cache")
cache_info(r3)
r3$date
rerequest(r3)$date

# Expires after 5 seconds
r4 &lt;- GET("http://httpbin.org/cache/5")
cache_info(r4)
r4$date
rerequest(r4)$date
Sys.sleep(5)
cache_info(r4)
rerequest(r4)$date

## End(Not run)
</code></pre>

<hr>
<h2 id='config'>Set curl options.</h2><span id='topic+config'></span>

<h3>Description</h3>

<p>Generally you should only need to use this function to set CURL options
directly if there isn't already a helpful wrapper function, like
<code><a href="#topic+set_cookies">set_cookies()</a></code>, <code><a href="#topic+add_headers">add_headers()</a></code> or
<code><a href="#topic+authenticate">authenticate()</a></code>. To use this function effectively requires
some knowledge of CURL, and CURL options. Use <code><a href="#topic+httr_options">httr_options()</a></code> to
see a complete list of available options. To see the libcurl documentation
for a given option, use <code><a href="#topic+curl_docs">curl_docs()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>config(..., token = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="config_+3A_...">...</code></td>
<td>
<p>named Curl options.</p>
</td></tr>
<tr><td><code id="config_+3A_token">token</code></td>
<td>
<p>An OAuth token (1.0 or 2.0)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike Curl (and RCurl), all configuration options are per request, not
per handle.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_config">set_config()</a></code> to set global config defaults, and
<code><a href="#topic+with_config">with_config()</a></code> to temporarily run code with set options.
</p>
<p>All known available options are listed in <code><a href="#topic+httr_options">httr_options()</a></code>
</p>
<p>Other config: 
<code><a href="#topic+add_headers">add_headers</a>()</code>,
<code><a href="#topic+authenticate">authenticate</a>()</code>,
<code><a href="#topic+set_cookies">set_cookies</a>()</code>,
<code><a href="#topic+timeout">timeout</a>()</code>,
<code><a href="#topic+use_proxy">use_proxy</a>()</code>,
<code><a href="#topic+user_agent">user_agent</a>()</code>,
<code><a href="#topic+verbose">verbose</a>()</code>
</p>
<p>Other ways to set configuration: 
<code><a href="#topic+set_config">set_config</a>()</code>,
<code><a href="#topic+with_config">with_config</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># There are a number of ways to modify the configuration of a request
# * you can add directly to a request
HEAD("https://www.google.com", verbose())

# * you can wrap with with_config()
with_config(verbose(), HEAD("https://www.google.com"))

# * you can set global with set_config()
old &lt;- set_config(verbose())
HEAD("https://www.google.com")
# and re-establish the previous settings with
set_config(old, override = TRUE)
HEAD("https://www.google.com")
# or
reset_config()
HEAD("https://www.google.com")

# If available, you should use a friendly httr wrapper over RCurl
# options. But you can pass Curl options (as listed in httr_options())
# in config
HEAD("https://www.google.com/", config(verbose = TRUE))
</code></pre>

<hr>
<h2 id='content'>Extract content from a request.</h2><span id='topic+content'></span><span id='topic+text_content'></span><span id='topic+parsed_content'></span>

<h3>Description</h3>

<p>There are currently three ways to retrieve the contents of a request:
as a raw object (<code>as = "raw"</code>), as a character vector,
(<code>as = "text"</code>), and as parsed into an R object where possible,
(<code>as = "parsed"</code>). If <code>as</code> is not specified, <code>content</code>
does its best to guess which output is most appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>content(x, as = NULL, type = NULL, encoding = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="content_+3A_x">x</code></td>
<td>
<p>request object</p>
</td></tr>
<tr><td><code id="content_+3A_as">as</code></td>
<td>
<p>desired type of output: <code>raw</code>, <code>text</code> or
<code>parsed</code>. <code>content</code> attempts to automatically figure out
which one is most appropriate, based on the content-type.</p>
</td></tr>
<tr><td><code id="content_+3A_type">type</code></td>
<td>
<p>MIME type (aka internet media type) used to override
the content type returned by the server. See
<a href="https://en.wikipedia.org/wiki/Internet_media_type">https://en.wikipedia.org/wiki/Internet_media_type</a> for a list of
common types.</p>
</td></tr>
<tr><td><code id="content_+3A_encoding">encoding</code></td>
<td>
<p>For text, overrides the charset or the Latin1 (ISO-8859-1)
default, if you know that the server is returning the incorrect encoding
as the charset in the content-type. Use for text and parsed outputs.</p>
</td></tr>
<tr><td><code id="content_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to the parsing functions, if
<code>as = "parsed"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>content</code> currently knows about the following mime types:
</p>

<ul>
<li> <p><code>text/html</code>: <code><a href="xml2.html#topic+read_xml">xml2::read_html()</a></code>
</p>
</li>
<li> <p><code>text/xml</code>: <code><a href="xml2.html#topic+read_xml">xml2::read_xml()</a></code>
</p>
</li>
<li> <p><code>text/csv</code>: <code><a href="readr.html#topic+read_delim">readr::read_csv()</a></code>
</p>
</li>
<li> <p><code>text/tab-separated-values</code>: <code><a href="readr.html#topic+read_delim">readr::read_tsv()</a></code>
</p>
</li>
<li> <p><code>application/json</code>: <code><a href="jsonlite.html#topic+fromJSON">jsonlite::fromJSON()</a></code>
</p>
</li>
<li> <p><code>application/x-www-form-urlencoded</code>: <code>parse_query</code>
</p>
</li>
<li> <p><code>image/jpeg</code>: <code><a href="jpeg.html#topic+readJPEG">jpeg::readJPEG()</a></code>
</p>
</li>
<li> <p><code>image/png</code>: <code><a href="png.html#topic+readPNG">png::readPNG()</a></code>
</p>
</li></ul>

<p><code>as = "parsed"</code> is provided as a convenience only: if the type you
are trying to parse is not available, use <code>as = "text"</code> and parse
yourself.
</p>


<h3>Value</h3>

<p>For &quot;raw&quot;, a raw vector.
</p>
<p>For &quot;text&quot;, a character vector of length 1. The character vector is always
re-encoded to UTF-8. If this encoding fails (usually because the page
declares an incorrect encoding), <code>content()</code> will return <code>NA</code>.
</p>
<p>For &quot;auto&quot;, a parsed R object.
</p>


<h3>WARNING</h3>

<p>When using <code>content()</code> in a package, DO NOT use on <code>as = "parsed"</code>.
Instead, check the mime-type is what you expect, and then parse yourself.
This is safer, as you will fail informatively if the API changes, and
you will protect yourself against changes to httr.
</p>


<h3>See Also</h3>

<p>Other response methods: 
<code><a href="#topic+http_error">http_error</a>()</code>,
<code><a href="#topic+http_status">http_status</a>()</code>,
<code><a href="#topic+response">response</a>()</code>,
<code><a href="#topic+stop_for_status">stop_for_status</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
r &lt;- POST("http://httpbin.org/post", body = list(a = 1, b = 2))
content(r) # automatically parses JSON
cat(content(r, "text"), "\n") # text content
content(r, "raw") # raw bytes from server

rlogo &lt;- content(GET("https://httpbin.org/image/png"))
plot(0:1, 0:1, type = "n")
rasterImage(rlogo, 0, 0, 1, 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='content_type'>Set content-type and accept headers.</h2><span id='topic+content_type'></span><span id='topic+content_type_json'></span><span id='topic+content_type_xml'></span><span id='topic+accept'></span><span id='topic+accept_json'></span><span id='topic+accept_xml'></span>

<h3>Description</h3>

<p>These are convenient wrappers aroud <code><a href="#topic+add_headers">add_headers()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>content_type(type)

content_type_json()

content_type_xml()

accept(type)

accept_json()

accept_xml()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="content_type_+3A_type">type</code></td>
<td>
<p>A mime type or a file extension. If a file extension (i.e. starts
with <code>.</code>) will guess the mime type using <code><a href="mime.html#topic+guess_type">mime::guess_type()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>accept_json</code>/<code>accept_xml</code> and
<code>content_type_json</code>/<code>content_type_xml</code> are useful shortcuts to
ask for json or xml responses or tell the server you are sending json/xml.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
GET("http://httpbin.org/headers")

GET("http://httpbin.org/headers", accept_json())
GET("http://httpbin.org/headers", accept("text/csv"))
GET("http://httpbin.org/headers", accept(".doc"))

GET("http://httpbin.org/headers", content_type_xml())
GET("http://httpbin.org/headers", content_type("text/csv"))
GET("http://httpbin.org/headers", content_type(".xml"))

## End(Not run)
</code></pre>

<hr>
<h2 id='cookies'>Access cookies in a response.</h2><span id='topic+cookies'></span>

<h3>Description</h3>

<p>Access cookies in a response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cookies(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cookies_+3A_x">x</code></td>
<td>
<p>A response.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+set_cookies">set_cookies()</a></code> to send cookies in request.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
r &lt;- GET("http://httpbin.org/cookies/set", query = list(a = 1, b = 2))
cookies(r)

## End(Not run)
</code></pre>

<hr>
<h2 id='DELETE'>Send a DELETE request.</h2><span id='topic+DELETE'></span>

<h3>Description</h3>

<p>Send a DELETE request.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DELETE(
  url = NULL,
  config = list(),
  ...,
  body = NULL,
  encode = c("multipart", "form", "json", "raw"),
  handle = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DELETE_+3A_url">url</code></td>
<td>
<p>the url of the page to retrieve</p>
</td></tr>
<tr><td><code id="DELETE_+3A_config">config</code></td>
<td>
<p>Additional configuration settings such as http
authentication (<code><a href="#topic+authenticate">authenticate()</a></code>), additional headers
(<code><a href="#topic+add_headers">add_headers()</a></code>), cookies (<code><a href="#topic+set_cookies">set_cookies()</a></code>) etc.
See <code><a href="#topic+config">config()</a></code> for full details and list of helpers.</p>
</td></tr>
<tr><td><code id="DELETE_+3A_...">...</code></td>
<td>
<p>Further named parameters, such as <code>query</code>, <code>path</code>, etc,
passed on to <code><a href="#topic+modify_url">modify_url()</a></code>. Unnamed parameters will be combined
with <code><a href="#topic+config">config()</a></code>.</p>
</td></tr>
<tr><td><code id="DELETE_+3A_body">body</code></td>
<td>
<p>One of the following:
</p>

<ul>
<li> <p><code>FALSE</code>: No body. This is typically not used with <code>POST</code>,
<code>PUT</code>, or <code>PATCH</code>, but can be useful if you need to send a
bodyless request (like <code>GET</code>) with <code>VERB()</code>.
</p>
</li>
<li> <p><code>NULL</code>: An empty body
</p>
</li>
<li> <p><code>""</code>: A length 0 body
</p>
</li>
<li> <p><code>upload_file("path/")</code>: The contents of a file.  The mime
type will be guessed from the extension, or can be supplied explicitly
as the second argument to <code>upload_file()</code>
</p>
</li>
<li><p> A character or raw vector: sent as is in body. Use
<code><a href="#topic+content_type">content_type()</a></code> to tell the server what sort of data
you are sending.
</p>
</li>
<li><p> A named list: See details for encode.
</p>
</li></ul>
</td></tr>
<tr><td><code id="DELETE_+3A_encode">encode</code></td>
<td>
<p>If the body is a named list, how should it be encoded? Can be
one of form (application/x-www-form-urlencoded), multipart,
(multipart/form-data), or json (application/json).
</p>
<p>For &quot;multipart&quot;, list elements can be strings or objects created by
<code><a href="#topic+upload_file">upload_file()</a></code>. For &quot;form&quot;, elements are coerced to strings
and escaped, use <code>I()</code> to prevent double-escaping. For &quot;json&quot;,
parameters are automatically &quot;unboxed&quot; (i.e. length 1 vectors are
converted to scalars). To preserve a length 1 vector as a vector,
wrap in <code>I()</code>. For &quot;raw&quot;, either a character or raw vector. You'll
need to make sure to set the <code><a href="#topic+content_type">content_type()</a></code> yourself.</p>
</td></tr>
<tr><td><code id="DELETE_+3A_handle">handle</code></td>
<td>
<p>The handle to use with this request. If not
supplied, will be retrieved and reused from the <code><a href="#topic+handle_pool">handle_pool()</a></code>
based on the scheme, hostname and port of the url. By default <span class="pkg">httr</span>
requests to the same scheme/host/port combo. This substantially reduces
connection time, and ensures that cookies are maintained over multiple
requests to the same host. See <code><a href="#topic+handle_pool">handle_pool()</a></code> for more
details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+response">response()</a></code> object.
</p>


<h3>RFC2616</h3>

<p>The DELETE method requests that the origin server delete the resource
identified by the Request-URI. This method MAY be overridden by human
intervention (or other means) on the origin server. The client cannot be
guaranteed that the operation has been carried out, even if the status code
returned from the origin server indicates that the action has been
completed successfully. However, the server SHOULD NOT indicate success
unless, at the time the response is given, it intends to delete the
resource or move it to an inaccessible location.
</p>
<p>A successful response SHOULD be 200 (OK) if the response includes an entity
describing the status, 202 (Accepted) if the action has not yet been
enacted, or 204 (No Content) if the action has been enacted but the
response does not include an entity.
</p>
<p>If the request passes through a cache and the Request-URI identifies one or
more currently cached entities, those entries SHOULD be treated as stale.
Responses to this method are not cacheable.
</p>


<h3>See Also</h3>

<p>Other http methods: 
<code><a href="#topic+BROWSE">BROWSE</a>()</code>,
<code><a href="#topic+GET">GET</a>()</code>,
<code><a href="#topic+HEAD">HEAD</a>()</code>,
<code><a href="#topic+PATCH">PATCH</a>()</code>,
<code><a href="#topic+POST">POST</a>()</code>,
<code><a href="#topic+PUT">PUT</a>()</code>,
<code><a href="#topic+VERB">VERB</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
DELETE("http://httpbin.org/delete")
POST("http://httpbin.org/delete")

## End(Not run)
</code></pre>

<hr>
<h2 id='GET'>GET a url.</h2><span id='topic+GET'></span>

<h3>Description</h3>

<p>GET a url.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GET(url = NULL, config = list(), ..., handle = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GET_+3A_url">url</code></td>
<td>
<p>the url of the page to retrieve</p>
</td></tr>
<tr><td><code id="GET_+3A_config">config</code></td>
<td>
<p>Additional configuration settings such as http
authentication (<code><a href="#topic+authenticate">authenticate()</a></code>), additional headers
(<code><a href="#topic+add_headers">add_headers()</a></code>), cookies (<code><a href="#topic+set_cookies">set_cookies()</a></code>) etc.
See <code><a href="#topic+config">config()</a></code> for full details and list of helpers.</p>
</td></tr>
<tr><td><code id="GET_+3A_...">...</code></td>
<td>
<p>Further named parameters, such as <code>query</code>, <code>path</code>, etc,
passed on to <code><a href="#topic+modify_url">modify_url()</a></code>. Unnamed parameters will be combined
with <code><a href="#topic+config">config()</a></code>.</p>
</td></tr>
<tr><td><code id="GET_+3A_handle">handle</code></td>
<td>
<p>The handle to use with this request. If not
supplied, will be retrieved and reused from the <code><a href="#topic+handle_pool">handle_pool()</a></code>
based on the scheme, hostname and port of the url. By default <span class="pkg">httr</span>
requests to the same scheme/host/port combo. This substantially reduces
connection time, and ensures that cookies are maintained over multiple
requests to the same host. See <code><a href="#topic+handle_pool">handle_pool()</a></code> for more
details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+response">response()</a></code> object.
</p>


<h3>RFC2616</h3>

<p>The GET method means retrieve whatever information (in the form of an
entity) is identified by the Request-URI. If the Request-URI refers to a
data-producing process, it is the produced data which shall be returned as
the entity in the response and not the source text of the process, unless
that text happens to be the output of the process.
</p>
<p>The semantics of the GET method change to a &quot;conditional GET&quot; if the
request message includes an If-Modified-Since, If-Unmodified-Since,
If-Match, If-None-Match, or If-Range header field. A conditional GET method
requests that the entity be transferred only under the circumstances
described by the conditional header field(s). The conditional GET method is
intended to reduce unnecessary network usage by allowing cached entities to
be refreshed without requiring multiple requests or transferring data
already held by the client.
</p>
<p>The semantics of the GET method change to a &quot;partial GET&quot; if the request
message includes a Range header field. A partial GET requests that only
part of the entity be transferred, as described in <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35">https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35</a>
The partial GET method is intended to reduce unnecessary network usage by
allowing partially-retrieved entities to be completed without transferring
data already held by the client.
</p>


<h3>See Also</h3>

<p>Other http methods: 
<code><a href="#topic+BROWSE">BROWSE</a>()</code>,
<code><a href="#topic+DELETE">DELETE</a>()</code>,
<code><a href="#topic+HEAD">HEAD</a>()</code>,
<code><a href="#topic+PATCH">PATCH</a>()</code>,
<code><a href="#topic+POST">POST</a>()</code>,
<code><a href="#topic+PUT">PUT</a>()</code>,
<code><a href="#topic+VERB">VERB</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GET("http://google.com/")
## Not run: 
GET("http://google.com/", path = "search")
GET("http://google.com/", path = "search", query = list(q = "ham"))

## End(Not run)

# See what GET is doing with httpbin.org
## Not run: 
url &lt;- "http://httpbin.org/get"
GET(url)
GET(url, add_headers(a = 1, b = 2))
GET(url, set_cookies(a = 1, b = 2))
GET(url, add_headers(a = 1, b = 2), set_cookies(a = 1, b = 2))
GET(url, authenticate("username", "password"))
GET(url, verbose())

## End(Not run)

# You might want to manually specify the handle so you can have multiple
# independent logins to the same website.
## Not run: 
google &lt;- handle("http://google.com")
GET(handle = google, path = "/")
GET(handle = google, path = "search")

## End(Not run)
</code></pre>

<hr>
<h2 id='get_callback'>Install or uninstall a callback function</h2><span id='topic+get_callback'></span><span id='topic+set_callback'></span>

<h3>Description</h3>

<p>Supported callback functions: </p>

<dl>
<dt>&lsquo;request&rsquo;</dt><dd><p>This callback is called before an HTTP request
is performed, with the <code>request</code> object as an argument.
If the callback returns a value other than <code>NULL</code>, the HTTP
request is not performed at all, and the return value of the callback
is returned. This mechanism can be used to replay previously
recorded HTTP responses.
</p>
</dd>
<dt>&lsquo;response&rsquo;</dt><dd><p>This callback is called after an HTTP request
is performed. The callback is called with two arguments: the
<code>request</code> object and the <code>response</code> object of the HTTP
request. If this callback returns a value other than <code>NULL</code>,
then this value is returned by <code>httr</code>.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>get_callback(name)

set_callback(name, new_callback = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_callback_+3A_name">name</code></td>
<td>
<p>Character scalar, name of the callback to query or set.</p>
</td></tr>
<tr><td><code id="get_callback_+3A_new_callback">new_callback</code></td>
<td>
<p>The callback function to install, a function object;
or <code>NULL</code> to remove the currently installed callback (if any).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that it is not possible to install multiple callbacks of the same
type. The installed callback overwrites the previously intalled one.
To uninstall a callback function, set it to <code>NULL</code> with
<code>set_callback()</code>.
</p>
<p>See the <code>httrmock</code> package for a proper example that uses
callbacks.
</p>


<h3>Value</h3>

<p><code>get_callback</code> returns the currently installed
callback, or <code>NULL</code> if none is installed.
</p>
<p><code>set_callback</code> returns the previously installed callback,
or <code>NULL</code> if none was installed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Log all HTTP requests to the screeen
req_logger &lt;- function(req) {
  cat("HTTP request to", sQuote(req$url), "\n")
}

old &lt;- set_callback("request", req_logger)
g1 &lt;- GET("https://httpbin.org")
g2 &lt;- GET("https://httpbin.org/ip")
set_callback("request", old)

## Log all HTTP requests and response status codes as well
req_logger2 &lt;- function(req) {
  cat("HTTP request to", sQuote(req$url), "... ")
}
res_logger &lt;- function(req, res) {
  cat(res$status_code, "\n")
}

old_req &lt;- set_callback("request", req_logger2)
old_res &lt;- set_callback("response", res_logger)
g3 &lt;- GET("https://httpbin.org")
g4 &lt;- GET("https://httpbin.org/ip")
set_callback("request", old_req)
set_callback("response", old_res)

## Return a recorded response, without performing the HTTP request
replay &lt;- function(req) {
  if (req$url == "https://httpbin.org") g3
}
old_req &lt;- set_callback("request", replay)
grec &lt;- GET("https://httpbin.org")
grec$date == g3$date
set_callback("request", old_req)

## End(Not run)

</code></pre>

<hr>
<h2 id='guess_media'>Guess the media type of a path from its extension.</h2><span id='topic+guess_media'></span>

<h3>Description</h3>

<p>DEPRECATED: please use <code>mime::guess_type</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess_media(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guess_media_+3A_x">x</code></td>
<td>
<p>path to file</p>
</td></tr>
</table>

<hr>
<h2 id='handle'>Create a handle tied to a particular host.</h2><span id='topic+handle'></span>

<h3>Description</h3>

<p>This handle preserves settings and cookies across multiple requests. It is
the foundation of all requests performed through the httr package, although
it will mostly be hidden from the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle(url, cookies = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_+3A_url">url</code></td>
<td>
<p>full url to site</p>
</td></tr>
<tr><td><code id="handle_+3A_cookies">cookies</code></td>
<td>
<p>DEPRECATED</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Because of the way argument dispatch works in R, using handle() in the
http methods (See <code><a href="#topic+GET">GET()</a></code>) will cause problems when trying to
pass configuration arguments (See examples below). Directly specifying the
handle when using http methods is not recommended in general, since the
selection of the correct handle is taken care of when the user passes an url
(See <code><a href="#topic+handle_pool">handle_pool()</a></code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>handle("http://google.com")
handle("https://google.com")

h &lt;- handle("http://google.com")
GET(handle = h)
# Should see cookies sent back to server
GET(handle = h, config = verbose())

h &lt;- handle("http://google.com", cookies = FALSE)
GET(handle = h)$cookies
## Not run: 
# Using the preferred way of configuring the http methods
# will not work when using handle():
GET(handle = h, timeout(10))
# Passing named arguments will work properly:
GET(handle = h, config = list(timeout(10), add_headers(Accept = "")))

## End(Not run)

</code></pre>

<hr>
<h2 id='handle_pool'>Maintain a pool of handles.</h2><span id='topic+handle_pool'></span><span id='topic+handle_find'></span><span id='topic+handle_reset'></span>

<h3>Description</h3>

<p>The handle pool is used to automatically reuse Curl handles for the same
scheme/host/port combination. This ensures that the http session is
automatically reused, and cookies are maintained across requests to a site
without user intervention.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_pool

handle_find(url)

handle_reset(url)
</code></pre>


<h3>Format</h3>

<p>An environment.
</p>

<hr>
<h2 id='has_content'>Does the request have content associated with it?</h2><span id='topic+has_content'></span>

<h3>Description</h3>

<p>Does the request have content associated with it?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_content(x)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
has_content(POST("http://httpbin.org/post", body = FALSE))
has_content(HEAD("http://httpbin.org/headers"))

## End(Not run)
</code></pre>

<hr>
<h2 id='HEAD'>Get url HEADers.</h2><span id='topic+HEAD'></span>

<h3>Description</h3>

<p>Get url HEADers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HEAD(url = NULL, config = list(), ..., handle = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HEAD_+3A_url">url</code></td>
<td>
<p>the url of the page to retrieve</p>
</td></tr>
<tr><td><code id="HEAD_+3A_config">config</code></td>
<td>
<p>Additional configuration settings such as http
authentication (<code><a href="#topic+authenticate">authenticate()</a></code>), additional headers
(<code><a href="#topic+add_headers">add_headers()</a></code>), cookies (<code><a href="#topic+set_cookies">set_cookies()</a></code>) etc.
See <code><a href="#topic+config">config()</a></code> for full details and list of helpers.</p>
</td></tr>
<tr><td><code id="HEAD_+3A_...">...</code></td>
<td>
<p>Further named parameters, such as <code>query</code>, <code>path</code>, etc,
passed on to <code><a href="#topic+modify_url">modify_url()</a></code>. Unnamed parameters will be combined
with <code><a href="#topic+config">config()</a></code>.</p>
</td></tr>
<tr><td><code id="HEAD_+3A_handle">handle</code></td>
<td>
<p>The handle to use with this request. If not
supplied, will be retrieved and reused from the <code><a href="#topic+handle_pool">handle_pool()</a></code>
based on the scheme, hostname and port of the url. By default <span class="pkg">httr</span>
requests to the same scheme/host/port combo. This substantially reduces
connection time, and ensures that cookies are maintained over multiple
requests to the same host. See <code><a href="#topic+handle_pool">handle_pool()</a></code> for more
details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+response">response()</a></code> object.
</p>


<h3>RFC2616</h3>

<p>The HEAD method is identical to GET except that the server MUST NOT return
a message-body in the response. The metainformation contained in the HTTP
headers in response to a HEAD request SHOULD be identical to the
information sent in response to a GET request. This method can be used for
obtaining metainformation about the entity implied by the request without
transferring the entity-body itself. This method is often used for testing
hypertext links for validity, accessibility, and recent modification.
</p>
<p>The response to a HEAD request MAY be cacheable in the sense that the
information contained in the response MAY be used to update a previously
cached entity from that resource. If the new field values indicate that the
cached entity differs from the current entity (as would be indicated by a
change in Content-Length, Content-MD5, ETag or Last-Modified), then the
cache MUST treat the cache entry as stale.
</p>


<h3>See Also</h3>

<p>Other http methods: 
<code><a href="#topic+BROWSE">BROWSE</a>()</code>,
<code><a href="#topic+DELETE">DELETE</a>()</code>,
<code><a href="#topic+GET">GET</a>()</code>,
<code><a href="#topic+PATCH">PATCH</a>()</code>,
<code><a href="#topic+POST">POST</a>()</code>,
<code><a href="#topic+PUT">PUT</a>()</code>,
<code><a href="#topic+VERB">VERB</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HEAD("http://google.com")
headers(HEAD("http://google.com"))
</code></pre>

<hr>
<h2 id='headers'>Extract the headers from a response</h2><span id='topic+headers'></span>

<h3>Description</h3>

<p>Extract the headers from a response
</p>


<h3>Usage</h3>

<pre><code class='language-R'>headers(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="headers_+3A_x">x</code></td>
<td>
<p>A request object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+add_headers">add_headers()</a></code> to send additional headers in a
request
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
r &lt;- GET("http://httpbin.org/get")
headers(r)

## End(Not run)
</code></pre>

<hr>
<h2 id='hmac_sha1'>HMAC SHA1</h2><span id='topic+hmac_sha1'></span>

<h3>Description</h3>

<p>As described in <a href="https://datatracker.ietf.org/doc/rfc2104/">https://datatracker.ietf.org/doc/rfc2104/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmac_sha1(key, string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmac_sha1_+3A_key">key</code></td>
<td>
<p>secret key</p>
</td></tr>
<tr><td><code id="hmac_sha1_+3A_string">string</code></td>
<td>
<p>data to securely hash</p>
</td></tr>
</table>

<hr>
<h2 id='http_condition'>Generate a classed http condition.</h2><span id='topic+http_condition'></span>

<h3>Description</h3>

<p>This function generate S3 condition objects which are passed to
<code><a href="base.html#topic+stop">stop()</a></code> or <code><a href="base.html#topic+warning">warning()</a></code> to generate classes warnings
and error. These can be used in conjunction with <code><a href="base.html#topic+tryCatch">tryCatch()</a></code>
to respond differently to different type of failure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>http_condition(x, type, task = NULL, call = sys.call(-1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="http_condition_+3A_x">x</code></td>
<td>
<p>a response, or numeric http code (or other object with
<code>status_code</code> method)</p>
</td></tr>
<tr><td><code id="http_condition_+3A_type">type</code></td>
<td>
<p>type of condition to generate. Must be one of error,
warning or message.</p>
</td></tr>
<tr><td><code id="http_condition_+3A_task">task</code></td>
<td>
<p>The text of the message: either <code>NULL</code> or a
character vector. If non-<code>NULL</code>, the error message will finish with
&quot;Failed to <code>task</code>&quot;.</p>
</td></tr>
<tr><td><code id="http_condition_+3A_call">call</code></td>
<td>
<p>The call stored in the condition object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object that inherits from (e.g.) condition, <code>type</code>,
http_error, http_400 and http_404.
</p>


<h3>See Also</h3>

<p><a href="http://adv-r.had.co.nz/Exceptions-Debugging.html#condition-handling">http://adv-r.had.co.nz/Exceptions-Debugging.html#condition-handling</a>
for more details about R's condition handling model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# You can use tryCatch to take different actions based on the type
# of error. Note that tryCatch will call the first handler that
# matches any classes of the condition, not the best matching, so
# always list handlers from most specific to least specific
f &lt;- function(url) {
  tryCatch(stop_for_status(GET(url)),
    http_404 = function(c) "That url doesn't exist",
    http_403 = function(c) "You need to authenticate!",
    http_400 = function(c) "You made a mistake!",
    http_500 = function(c) "The server screwed up"
  )
}
f("http://httpbin.org/status/404")
f("http://httpbin.org/status/403")
f("http://httpbin.org/status/505")

## End(Not run)
</code></pre>

<hr>
<h2 id='http_error'>Check for an http error.</h2><span id='topic+http_error'></span><span id='topic+url_success'></span><span id='topic+url_ok'></span>

<h3>Description</h3>

<p>Check for an http error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>http_error(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="http_error_+3A_x">x</code></td>
<td>
<p>Object to check. Default methods are provided for strings
(which perform an <code><a href="#topic+HEAD">HEAD()</a></code> request), responses, and
integer status codes.</p>
</td></tr>
<tr><td><code id="http_error_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the request fails (status code 400 or above),
otherwise <code>FALSE</code>.
</p>


<h3>See Also</h3>

<p>Other response methods: 
<code><a href="#topic+content">content</a>()</code>,
<code><a href="#topic+http_status">http_status</a>()</code>,
<code><a href="#topic+response">response</a>()</code>,
<code><a href="#topic+stop_for_status">stop_for_status</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# You can pass a url:
http_error("http://www.google.com")
http_error("http://httpbin.org/status/404")

# Or a request
r &lt;- GET("http://httpbin.org/status/201")
http_error(r)

## End(Not run)

# Or an (integer) status code
http_error(200L)
http_error(404L)
</code></pre>

<hr>
<h2 id='http_status'>Give information on the status of a request.</h2><span id='topic+http_status'></span>

<h3>Description</h3>

<p>Extract the http status code and convert it into a human readable message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>http_status(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="http_status_+3A_x">x</code></td>
<td>
<p>a request object or a number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>http servers send a status code with the response to each request. This code
gives information regarding the outcome of the execution of the request
on the server. Roughly speaking, codes in the 100s and 200s mean the request
was successfully executed; codes in the 300s mean the page was redirected;
codes in the 400s mean there was a mistake in the way the client sent the
request; codes in the 500s mean the server failed to fulfill
an apparently valid request. More details on the codes can be found at
<code style="white-space: pre;">&#8288;http://en.wikipedia.org/wiki/Http_error_codes&#8288;</code>.
</p>


<h3>Value</h3>

<p>If the status code does not match a known status, an error.
Otherwise, a list with components
</p>
<table>
<tr><td><code>category</code></td>
<td>
<p>the broad category of the status</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>the meaning of the status code</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other response methods: 
<code><a href="#topic+content">content</a>()</code>,
<code><a href="#topic+http_error">http_error</a>()</code>,
<code><a href="#topic+response">response</a>()</code>,
<code><a href="#topic+stop_for_status">stop_for_status</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>http_status(100)
http_status(404)

## Not run: 
x &lt;- GET("http://httpbin.org/status/200")
http_status(x)

http_status(GET("http://httpbin.org/status/300"))
http_status(GET("http://httpbin.org/status/301"))
http_status(GET("http://httpbin.org/status/404"))

# errors out on unknown status
http_status(GET("http://httpbin.org/status/320"))

## End(Not run)
</code></pre>

<hr>
<h2 id='http_type'>Extract the content type of a response</h2><span id='topic+http_type'></span>

<h3>Description</h3>

<p>Extract the content type of a response
</p>


<h3>Usage</h3>

<pre><code class='language-R'>http_type(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="http_type_+3A_x">x</code></td>
<td>
<p>A response</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string giving the complete mime type, with all parameters
stripped off.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
r1 &lt;- GET("http://httpbin.org/image/png")
http_type(r1)
headers(r1)[["Content-Type"]]

r2 &lt;- GET("http://httpbin.org/ip")
http_type(r2)
headers(r2)[["Content-Type"]]

## End(Not run)
</code></pre>

<hr>
<h2 id='httr_dr'>Diagnose common configuration problems</h2><span id='topic+httr_dr'></span>

<h3>Description</h3>

<p>Currently one check: that curl uses nss.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>httr_dr()
</code></pre>

<hr>
<h2 id='httr_options'>List available options.</h2><span id='topic+httr_options'></span><span id='topic+curl_docs'></span>

<h3>Description</h3>

<p>This function lists all available options for <code><a href="#topic+config">config()</a></code>.
It provides both the short R name which you use with httr, and the longer
Curl name, which is useful when searching the documentation. <code>curl_doc</code>
opens a link to the libcurl documentation for an option in your browser.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>httr_options(matches)

curl_docs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="httr_options_+3A_matches">matches</code></td>
<td>
<p>If not missing, this restricts the output so that either
the httr or curl option matches this regular expression.</p>
</td></tr>
<tr><td><code id="httr_options_+3A_x">x</code></td>
<td>
<p>An option name (either short or full).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>RCurl and httr use slightly different names to libcurl: the initial
<code>CURLOPT_</code> is removed, all underscores are converted to periods and
the option is given in lower case.  Thus &quot;CURLOPT_SSLENGINE_DEFAULT&quot;
becomes &quot;sslengine.default&quot;.
</p>


<h3>Value</h3>

<p>A data frame with three columns:
</p>
<table>
<tr><td><code>httr</code></td>
<td>
<p>The short name used in httr</p>
</td></tr>
<tr><td><code>libcurl</code></td>
<td>
<p>The full name used by libcurl</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The type of R object that the option accepts</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>httr_options()
httr_options("post")

# Use curl_docs to read the curl documentation for each option.
# You can use either the httr or curl option name.
curl_docs("userpwd")
curl_docs("CURLOPT_USERPWD")
</code></pre>

<hr>
<h2 id='httr-package'><span class="pkg">httr</span> makes http easy.</h2><span id='topic+httr'></span><span id='topic+httr-package'></span>

<h3>Description</h3>

<p><code>httr</code> is organised around the six most common http verbs:
<code><a href="#topic+GET">GET()</a></code>, <code><a href="#topic+PATCH">PATCH()</a></code>,
<code><a href="#topic+POST">POST()</a></code>, <code><a href="#topic+HEAD">HEAD()</a></code>,
<code><a href="#topic+PUT">PUT()</a></code>, and <code><a href="#topic+DELETE">DELETE()</a></code>.
</p>


<h3>Details</h3>

<p>Each request returns a <code><a href="#topic+response">response()</a></code> object which provides
easy access to status code, cookies, headers, timings, and other useful
info.  The content of the request is available as a raw vector
(<code><a href="#topic+content">content()</a></code>), character vector (<code><a href="#topic+text_content">text_content()</a></code>),
or parsed into an R object (<code><a href="#topic+parsed_content">parsed_content()</a></code>), currently for
html, xml, json, png and jpeg).
</p>
<p>Requests can be modified by various config options like
<code><a href="#topic+set_cookies">set_cookies()</a></code>, <code><a href="#topic+add_headers">add_headers()</a></code>,
<code><a href="#topic+authenticate">authenticate()</a></code>, <code><a href="#topic+use_proxy">use_proxy()</a></code>,
<code><a href="#topic+verbose">verbose()</a></code>, and <code><a href="#topic+timeout">timeout()</a></code>
</p>
<p>httr supports OAuth 1.0 and 2.0. Use <code><a href="#topic+oauth1.0_token">oauth1.0_token()</a></code> and
<code><a href="#topic+oauth2.0_token">oauth2.0_token()</a></code> to get user tokens, and
<code><a href="#topic+sign_oauth1.0">sign_oauth1.0()</a></code> and <code><a href="#topic+sign_oauth2.0">sign_oauth2.0()</a></code> to sign
requests. The demos directory has twelve demos of using OAuth: four for 1.0
(linkedin, twitter, vimeo, and yahoo) and eight for 2.0 (azure, facebook,
github, google, linkedin, reddit, yahoo, and yelp).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Hadley Wickham <a href="mailto:hadley@posit.co">hadley@posit.co</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Posit, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://httr.r-lib.org/">https://httr.r-lib.org/</a>
</p>
</li>
<li> <p><a href="https://github.com/r-lib/httr">https://github.com/r-lib/httr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-lib/httr/issues">https://github.com/r-lib/httr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='init_oauth1.0'>Retrieve OAuth 1.0 access token.</h2><span id='topic+init_oauth1.0'></span>

<h3>Description</h3>

<p>See demos for use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_oauth1.0(
  endpoint,
  app,
  permission = NULL,
  is_interactive = interactive(),
  private_key = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_oauth1.0_+3A_endpoint">endpoint</code></td>
<td>
<p>An OAuth endpoint, created by <code><a href="#topic+oauth_endpoint">oauth_endpoint()</a></code></p>
</td></tr>
<tr><td><code id="init_oauth1.0_+3A_app">app</code></td>
<td>
<p>An OAuth consumer application, created by
<code><a href="#topic+oauth_app">oauth_app()</a></code></p>
</td></tr>
<tr><td><code id="init_oauth1.0_+3A_permission">permission</code></td>
<td>
<p>optional, a string of permissions to ask for.</p>
</td></tr>
<tr><td><code id="init_oauth1.0_+3A_is_interactive">is_interactive</code></td>
<td>
<p>DEPRECATED</p>
</td></tr>
<tr><td><code id="init_oauth1.0_+3A_private_key">private_key</code></td>
<td>
<p>Optional, a key provided by <code><a href="openssl.html#topic+read_key">openssl::read_key()</a></code>.
Used for signed OAuth 1.0.</p>
</td></tr>
</table>

<hr>
<h2 id='init_oauth2.0'>Retrieve OAuth 2.0 access token.</h2><span id='topic+init_oauth2.0'></span><span id='topic+oauth2.0_authorize_url'></span><span id='topic+oauth2.0_access_token'></span>

<h3>Description</h3>

<p>See demos for use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_oauth2.0(
  endpoint,
  app,
  scope = NULL,
  user_params = NULL,
  type = NULL,
  use_oob = getOption("httr_oob_default"),
  oob_value = NULL,
  is_interactive = interactive(),
  use_basic_auth = FALSE,
  config_init = list(),
  client_credentials = FALSE,
  query_authorize_extra = list()
)

oauth2.0_authorize_url(
  endpoint,
  app,
  scope,
  redirect_uri = app$redirect_uri,
  state = nonce(),
  query_extra = list()
)

oauth2.0_access_token(
  endpoint,
  app,
  code,
  user_params = NULL,
  type = NULL,
  use_basic_auth = FALSE,
  redirect_uri = app$redirect_uri,
  client_credentials = FALSE,
  config = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_oauth2.0_+3A_endpoint">endpoint</code></td>
<td>
<p>An OAuth endpoint, created by <code><a href="#topic+oauth_endpoint">oauth_endpoint()</a></code></p>
</td></tr>
<tr><td><code id="init_oauth2.0_+3A_app">app</code></td>
<td>
<p>An OAuth consumer application, created by
<code><a href="#topic+oauth_app">oauth_app()</a></code></p>
</td></tr>
<tr><td><code id="init_oauth2.0_+3A_scope">scope</code></td>
<td>
<p>a character vector of scopes to request.</p>
</td></tr>
<tr><td><code id="init_oauth2.0_+3A_user_params">user_params</code></td>
<td>
<p>Named list holding endpoint specific parameters to pass to
the server when posting the request for obtaining or refreshing the
access token.</p>
</td></tr>
<tr><td><code id="init_oauth2.0_+3A_type">type</code></td>
<td>
<p>content type used to override incorrect server response</p>
</td></tr>
<tr><td><code id="init_oauth2.0_+3A_use_oob">use_oob</code></td>
<td>
<p>if FALSE, use a local webserver for the OAuth dance.
Otherwise, provide a URL to the user and prompt for a validation
code. Defaults to the of the <code>"httr_oob_default"</code> default,
or <code>TRUE</code> if <code>httpuv</code> is not installed.</p>
</td></tr>
<tr><td><code id="init_oauth2.0_+3A_oob_value">oob_value</code></td>
<td>
<p>if provided, specifies the value to use for the redirect_uri
parameter when retrieving an authorization URL. Defaults to &quot;urn:ietf:wg:oauth:2.0:oob&quot;.
Requires <code>use_oob = TRUE</code>.</p>
</td></tr>
<tr><td><code id="init_oauth2.0_+3A_is_interactive">is_interactive</code></td>
<td>
<p>DEPRECATED</p>
</td></tr>
<tr><td><code id="init_oauth2.0_+3A_use_basic_auth">use_basic_auth</code></td>
<td>
<p>if <code>TRUE</code> use http basic authentication to
retrieve the token. Some authorization servers require this.
If <code>FALSE</code>, the default, retrieve the token by including the
app key and secret in the request body.</p>
</td></tr>
<tr><td><code id="init_oauth2.0_+3A_config_init">config_init</code></td>
<td>
<p>Additional configuration settings sent to
<code><a href="#topic+POST">POST()</a></code>, e.g. <code><a href="#topic+user_agent">user_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="init_oauth2.0_+3A_client_credentials">client_credentials</code></td>
<td>
<p>Default to <code>FALSE</code>. Set to <code>TRUE</code> to use
<em>Client Credentials Grant</em> instead of <em>Authorization
Code Grant</em>. See <a href="https://www.rfc-editor.org/rfc/rfc6749#section-4.4">https://www.rfc-editor.org/rfc/rfc6749#section-4.4</a>.</p>
</td></tr>
<tr><td><code id="init_oauth2.0_+3A_query_authorize_extra">query_authorize_extra</code></td>
<td>
<p>Default to <code>list()</code>. Set to named list
holding query parameters to append to initial auth page query. Useful for
some APIs.</p>
</td></tr>
<tr><td><code id="init_oauth2.0_+3A_query_extra">query_extra</code></td>
<td>
<p>See <code>query_authorize_extra</code></p>
</td></tr>
</table>

<hr>
<h2 id='insensitive'>Create a vector with case insensitive name matching.</h2><span id='topic+insensitive'></span>

<h3>Description</h3>

<p>Create a vector with case insensitive name matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insensitive(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insensitive_+3A_x">x</code></td>
<td>
<p>vector to modify</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("abc" = 1, "def" = 2)
x["ABC"]
y &lt;- insensitive(x)
y["ABC"]
y[["ABC"]]
</code></pre>

<hr>
<h2 id='jwt_signature'>Generate a JWT signature given credentials.</h2><span id='topic+jwt_signature'></span>

<h3>Description</h3>

<p>As described in
<a href="https://developers.google.com/identity/protocols/oauth2/service-account">https://developers.google.com/identity/protocols/oauth2/service-account</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jwt_signature(
  credentials,
  scope,
  aud,
  sub = NULL,
  iat = as.integer(Sys.time()),
  exp = iat + duration,
  duration = 60L * 60L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jwt_signature_+3A_credentials">credentials</code></td>
<td>
<p>Parsed contents of the credentials file.</p>
</td></tr>
<tr><td><code id="jwt_signature_+3A_scope">scope</code></td>
<td>
<p>A space-delimited list of the permissions that the application
requests.</p>
</td></tr>
<tr><td><code id="jwt_signature_+3A_aud">aud</code></td>
<td>
<p>A descriptor of the intended target of the assertion. This
typically comes from the service auth file.</p>
</td></tr>
<tr><td><code id="jwt_signature_+3A_sub">sub</code></td>
<td>
<p>The email address of the user for which the application is
requesting delegated access.</p>
</td></tr>
<tr><td><code id="jwt_signature_+3A_iat">iat</code></td>
<td>
<p>The time the assertion was issued, measured in seconds since
00:00:00 UTC, January 1, 1970.</p>
</td></tr>
<tr><td><code id="jwt_signature_+3A_exp">exp</code></td>
<td>
<p>The expiration time of the assertion, measured in seconds since
00:00:00 UTC, January 1, 1970. This value has a maximum of 1 hour from
the issued time.</p>
</td></tr>
<tr><td><code id="jwt_signature_+3A_duration">duration</code></td>
<td>
<p>Duration of token, in seconds.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
cred &lt;- jsonlite::fromJSON("~/Desktop/httrtest-45693cbfac92.json")
jwt_signature(cred, "https://www.googleapis.com/auth/userinfo.profile")

## End(Not run)
</code></pre>

<hr>
<h2 id='modify_url'>Modify a url.</h2><span id='topic+modify_url'></span>

<h3>Description</h3>

<p>Modify a url by first parsing it and then replacing components with
the non-NULL arguments of this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify_url(
  url,
  scheme = NULL,
  hostname = NULL,
  port = NULL,
  path = NULL,
  query = NULL,
  params = NULL,
  fragment = NULL,
  username = NULL,
  password = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modify_url_+3A_url">url</code></td>
<td>
<p>the url to modify</p>
</td></tr>
<tr><td><code id="modify_url_+3A_scheme">scheme</code>, <code id="modify_url_+3A_hostname">hostname</code>, <code id="modify_url_+3A_port">port</code>, <code id="modify_url_+3A_path">path</code>, <code id="modify_url_+3A_query">query</code>, <code id="modify_url_+3A_params">params</code>, <code id="modify_url_+3A_fragment">fragment</code>, <code id="modify_url_+3A_username">username</code>, <code id="modify_url_+3A_password">password</code></td>
<td>
<p>components of the url to change</p>
</td></tr>
</table>

<hr>
<h2 id='oauth_app'>Create an OAuth application.</h2><span id='topic+oauth_app'></span>

<h3>Description</h3>

<p>See the demos for instructions on how to create an OAuth app for linkedin,
twitter, vimeo, facebook, github and google. When wrapping an API from a
package, the author may want to include a default app to facilitate early and
casual use and then provide a method for heavy or advanced users to supply
their own app or key and secret.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oauth_app(appname, key, secret = NULL, redirect_uri = oauth_callback())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oauth_app_+3A_appname">appname</code></td>
<td>
<p>name of the application.  This is not used for OAuth, but is
used to make it easier to identify different applications.</p>
</td></tr>
<tr><td><code id="oauth_app_+3A_key">key</code></td>
<td>
<p>consumer key, also sometimes called the client ID</p>
</td></tr>
<tr><td><code id="oauth_app_+3A_secret">secret</code></td>
<td>
<p>consumer secret, also sometimes called the client secret.
Despite its name, this does not necessarily need to be protected like a
password, i.e. the user still has to authenticate themselves and grant the
app permission to access resources on their behalf. For example, see
Google's docs for <a href="https://developers.google.com/identity/protocols/oauth2">OAuth2 for installed applications</a>.</p>
</td></tr>
<tr><td><code id="oauth_app_+3A_redirect_uri">redirect_uri</code></td>
<td>
<p>The URL that user will be redirected to after
authorisation is complete. You should generally leave this as the default
unless you're using a non-standard auth flow (like with shiny).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other OAuth: 
<code><a href="#topic+oauth1.0_token">oauth1.0_token</a>()</code>,
<code><a href="#topic+oauth2.0_token">oauth2.0_token</a>()</code>,
<code><a href="#topic+oauth_endpoint">oauth_endpoint</a>()</code>,
<code><a href="#topic+oauth_service_token">oauth_service_token</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
google_app &lt;- oauth_app(
  "google",
  key = "123456789.apps.googleusercontent.com",
  secret = "abcdefghijklmnopqrstuvwxyz"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='oauth_callback'>The oauth callback url.</h2><span id='topic+oauth_callback'></span>

<h3>Description</h3>

<p>The url that <code><a href="#topic+oauth_listener">oauth_listener()</a></code> expects that the client be
referred to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oauth_callback()
</code></pre>

<hr>
<h2 id='oauth_endpoint'>Describe an OAuth endpoint.</h2><span id='topic+oauth_endpoint'></span>

<h3>Description</h3>

<p>See <code><a href="#topic+oauth_endpoints">oauth_endpoints()</a></code> for a list of popular OAuth endpoints
baked into httr.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oauth_endpoint(request = NULL, authorize, access, ..., base_url = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oauth_endpoint_+3A_request">request</code></td>
<td>
<p>url used to request initial (unauthenticated) token.
If using OAuth2.0, leave as <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="oauth_endpoint_+3A_authorize">authorize</code></td>
<td>
<p>url to send client to for authorisation. Set to <code>NULL</code>
if not needed</p>
</td></tr>
<tr><td><code id="oauth_endpoint_+3A_access">access</code></td>
<td>
<p>url used to exchange unauthenticated for authenticated token.</p>
</td></tr>
<tr><td><code id="oauth_endpoint_+3A_...">...</code></td>
<td>
<p>other additional endpoints.</p>
</td></tr>
<tr><td><code id="oauth_endpoint_+3A_base_url">base_url</code></td>
<td>
<p>option url to use as base for <code>request</code>,
<code>authorize</code> and <code>access</code> urls.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other OAuth: 
<code><a href="#topic+oauth1.0_token">oauth1.0_token</a>()</code>,
<code><a href="#topic+oauth2.0_token">oauth2.0_token</a>()</code>,
<code><a href="#topic+oauth_app">oauth_app</a>()</code>,
<code><a href="#topic+oauth_service_token">oauth_service_token</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>linkedin &lt;- oauth_endpoint("requestToken", "authorize", "accessToken",
  base_url = "https://api.linkedin.com/uas/oauth"
)
github &lt;- oauth_endpoint(NULL, "authorize", "access_token",
  base_url = "https://github.com/login/oauth"
)
facebook &lt;- oauth_endpoint(
  authorize = "https://www.facebook.com/dialog/oauth",
  access = "https://graph.facebook.com/oauth/access_token"
)

oauth_endpoints
</code></pre>

<hr>
<h2 id='oauth_endpoints'>Popular oauth endpoints.</h2><span id='topic+oauth_endpoints'></span>

<h3>Description</h3>

<p>Provides some common OAuth endpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oauth_endpoints(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oauth_endpoints_+3A_name">name</code></td>
<td>
<p>One of the following endpoints: linkedin, twitter,
vimeo, google, facebook, github, azure.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>oauth_endpoints("twitter")
</code></pre>

<hr>
<h2 id='oauth_exchanger'>Walk the user through the OAuth2 dance without a local webserver.</h2><span id='topic+oauth_exchanger'></span>

<h3>Description</h3>

<p>This performs a similar function to <code><a href="#topic+oauth_listener">oauth_listener()</a></code>,
but without running a local webserver.  This manual process can be useful
in situations where the user is remotely accessing the machine outside a
browser (say via ssh) or when it's not possible to successfully receive a
callback (such as when behind a firewall).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oauth_exchanger(request_url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oauth_exchanger_+3A_request_url">request_url</code></td>
<td>
<p>the url to provide to the user</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should generally not be called directly by the user.
</p>

<hr>
<h2 id='oauth_listener'>Create a webserver to listen for OAuth callback.</h2><span id='topic+oauth_listener'></span>

<h3>Description</h3>

<p>This opens a web browser pointing to <code>request_url</code>, and opens a
webserver on port 1410 to listen to the reponse.  The redirect url should
either be set previously (during the OAuth authentication dance) or
supplied as a parameter to the url.  See <code><a href="#topic+oauth1.0_token">oauth1.0_token()</a></code> and
<code><a href="#topic+oauth2.0_token">oauth2.0_token()</a></code> for examples of both techniques.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oauth_listener(request_url, is_interactive = interactive())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oauth_listener_+3A_request_url">request_url</code></td>
<td>
<p>the url to send the browser to</p>
</td></tr>
<tr><td><code id="oauth_listener_+3A_is_interactive">is_interactive</code></td>
<td>
<p>DEPRECATED</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should not normally be called directly by the user.
</p>

<hr>
<h2 id='oauth_service_token'>Generate OAuth token for service accounts.</h2><span id='topic+oauth_service_token'></span>

<h3>Description</h3>

<p>Service accounts provide a way of using OAuth2 without user intervention.
They instead assume that the server has access to a private key used
to sign requests. The OAuth app is not needed for service accounts:
that information is embedded in the account itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oauth_service_token(endpoint, secrets, scope = NULL, sub = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oauth_service_token_+3A_endpoint">endpoint</code></td>
<td>
<p>An OAuth endpoint, created by <code><a href="#topic+oauth_endpoint">oauth_endpoint()</a></code></p>
</td></tr>
<tr><td><code id="oauth_service_token_+3A_secrets">secrets</code></td>
<td>
<p>Secrets loaded from JSON file, downloaded from console.</p>
</td></tr>
<tr><td><code id="oauth_service_token_+3A_scope">scope</code></td>
<td>
<p>a character vector of scopes to request.</p>
</td></tr>
<tr><td><code id="oauth_service_token_+3A_sub">sub</code></td>
<td>
<p>The email address of the user for which the application is
requesting delegated access.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other OAuth: 
<code><a href="#topic+oauth1.0_token">oauth1.0_token</a>()</code>,
<code><a href="#topic+oauth2.0_token">oauth2.0_token</a>()</code>,
<code><a href="#topic+oauth_app">oauth_app</a>()</code>,
<code><a href="#topic+oauth_endpoint">oauth_endpoint</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
endpoint &lt;- oauth_endpoints("google")
secrets &lt;- jsonlite::fromJSON("~/Desktop/httrtest-45693cbfac92.json")
scope &lt;- "https://www.googleapis.com/auth/bigquery.readonly"

token &lt;- oauth_service_token(endpoint, secrets, scope)

## End(Not run)
</code></pre>

<hr>
<h2 id='oauth_signature'>Generate oauth signature.</h2><span id='topic+oauth_signature'></span><span id='topic+oauth_header'></span>

<h3>Description</h3>

<p>For advanced use only. Occassionally needed for sites that use some
components of the OAuth spec, but not all of them (e.g. 2-legged oauth)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oauth_signature(
  url,
  method = "GET",
  app,
  token = NULL,
  token_secret = NULL,
  private_key = NULL,
  other_params = NULL
)

oauth_header(info)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oauth_signature_+3A_url">url</code>, <code id="oauth_signature_+3A_method">method</code></td>
<td>
<p>Url and http method of request.</p>
</td></tr>
<tr><td><code id="oauth_signature_+3A_app">app</code></td>
<td>
<p><code><a href="#topic+oauth_app">oauth_app()</a></code> object representing application.</p>
</td></tr>
<tr><td><code id="oauth_signature_+3A_token">token</code>, <code id="oauth_signature_+3A_token_secret">token_secret</code></td>
<td>
<p>OAuth token and secret.</p>
</td></tr>
<tr><td><code id="oauth_signature_+3A_other_params">other_params</code></td>
<td>
<p>Named argument providing additional parameters
(e.g. <code>oauth_callback</code> or <code>oauth_body_hash</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of oauth parameters.
</p>

<hr>
<h2 id='oauth1.0_token'>Generate an oauth1.0 token.</h2><span id='topic+oauth1.0_token'></span>

<h3>Description</h3>

<p>This is the final object in the OAuth dance - it encapsulates the app,
the endpoint, other parameters and the received credentials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oauth1.0_token(
  endpoint,
  app,
  permission = NULL,
  as_header = TRUE,
  private_key = NULL,
  cache = getOption("httr_oauth_cache")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oauth1.0_token_+3A_endpoint">endpoint</code></td>
<td>
<p>An OAuth endpoint, created by <code><a href="#topic+oauth_endpoint">oauth_endpoint()</a></code></p>
</td></tr>
<tr><td><code id="oauth1.0_token_+3A_app">app</code></td>
<td>
<p>An OAuth consumer application, created by
<code><a href="#topic+oauth_app">oauth_app()</a></code></p>
</td></tr>
<tr><td><code id="oauth1.0_token_+3A_permission">permission</code></td>
<td>
<p>optional, a string of permissions to ask for.</p>
</td></tr>
<tr><td><code id="oauth1.0_token_+3A_as_header">as_header</code></td>
<td>
<p>If <code>TRUE</code>, the default, sends oauth in header.
If <code>FALSE</code>, adds as parameter to url.</p>
</td></tr>
<tr><td><code id="oauth1.0_token_+3A_private_key">private_key</code></td>
<td>
<p>Optional, a key provided by <code><a href="openssl.html#topic+read_key">openssl::read_key()</a></code>.
Used for signed OAuth 1.0.</p>
</td></tr>
<tr><td><code id="oauth1.0_token_+3A_cache">cache</code></td>
<td>
<p>A logical value or a string. <code>TRUE</code> means to cache
using the default cache file <code>.httr-oauth</code>, <code>FALSE</code> means
don't cache, and <code>NA</code> means to guess using some sensible heuristics.
A string means use the specified path as the cache file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+Token">Token()</a></code> for full details about the token object, and the
caching policies used to store credentials across sessions.
</p>


<h3>Value</h3>

<p>A <code>Token1.0</code> reference class (RC) object.
</p>


<h3>See Also</h3>

<p>Other OAuth: 
<code><a href="#topic+oauth2.0_token">oauth2.0_token</a>()</code>,
<code><a href="#topic+oauth_app">oauth_app</a>()</code>,
<code><a href="#topic+oauth_endpoint">oauth_endpoint</a>()</code>,
<code><a href="#topic+oauth_service_token">oauth_service_token</a>()</code>
</p>

<hr>
<h2 id='oauth2.0_token'>Generate an oauth2.0 token.</h2><span id='topic+oauth2.0_token'></span>

<h3>Description</h3>

<p>This is the final object in the OAuth dance - it encapsulates the app,
the endpoint, other parameters and the received credentials. It is a
reference class so that it can be seamlessly updated (e.g. using
<code style="white-space: pre;">&#8288;$refresh()&#8288;</code>) when access expires.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oauth2.0_token(
  endpoint,
  app,
  scope = NULL,
  user_params = NULL,
  type = NULL,
  use_oob = getOption("httr_oob_default"),
  oob_value = NULL,
  as_header = TRUE,
  use_basic_auth = FALSE,
  cache = getOption("httr_oauth_cache"),
  config_init = list(),
  client_credentials = FALSE,
  credentials = NULL,
  query_authorize_extra = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oauth2.0_token_+3A_endpoint">endpoint</code></td>
<td>
<p>An OAuth endpoint, created by <code><a href="#topic+oauth_endpoint">oauth_endpoint()</a></code></p>
</td></tr>
<tr><td><code id="oauth2.0_token_+3A_app">app</code></td>
<td>
<p>An OAuth consumer application, created by
<code><a href="#topic+oauth_app">oauth_app()</a></code></p>
</td></tr>
<tr><td><code id="oauth2.0_token_+3A_scope">scope</code></td>
<td>
<p>a character vector of scopes to request.</p>
</td></tr>
<tr><td><code id="oauth2.0_token_+3A_user_params">user_params</code></td>
<td>
<p>Named list holding endpoint specific parameters to pass to
the server when posting the request for obtaining or refreshing the
access token.</p>
</td></tr>
<tr><td><code id="oauth2.0_token_+3A_type">type</code></td>
<td>
<p>content type used to override incorrect server response</p>
</td></tr>
<tr><td><code id="oauth2.0_token_+3A_use_oob">use_oob</code></td>
<td>
<p>if FALSE, use a local webserver for the OAuth dance.
Otherwise, provide a URL to the user and prompt for a validation
code. Defaults to the of the <code>"httr_oob_default"</code> default,
or <code>TRUE</code> if <code>httpuv</code> is not installed.</p>
</td></tr>
<tr><td><code id="oauth2.0_token_+3A_oob_value">oob_value</code></td>
<td>
<p>if provided, specifies the value to use for the redirect_uri
parameter when retrieving an authorization URL. Defaults to &quot;urn:ietf:wg:oauth:2.0:oob&quot;.
Requires <code>use_oob = TRUE</code>.</p>
</td></tr>
<tr><td><code id="oauth2.0_token_+3A_as_header">as_header</code></td>
<td>
<p>If <code>TRUE</code>, the default, configures the token to add
itself to the bearer header of subsequent requests. If <code>FALSE</code>,
configures the token to add itself as a url parameter of subsequent
requests.</p>
</td></tr>
<tr><td><code id="oauth2.0_token_+3A_use_basic_auth">use_basic_auth</code></td>
<td>
<p>if <code>TRUE</code> use http basic authentication to
retrieve the token. Some authorization servers require this.
If <code>FALSE</code>, the default, retrieve the token by including the
app key and secret in the request body.</p>
</td></tr>
<tr><td><code id="oauth2.0_token_+3A_cache">cache</code></td>
<td>
<p>A logical value or a string. <code>TRUE</code> means to cache
using the default cache file <code>.httr-oauth</code>, <code>FALSE</code> means
don't cache, and <code>NA</code> means to guess using some sensible heuristics.
A string means use the specified path as the cache file.</p>
</td></tr>
<tr><td><code id="oauth2.0_token_+3A_config_init">config_init</code></td>
<td>
<p>Additional configuration settings sent to
<code><a href="#topic+POST">POST()</a></code>, e.g. <code><a href="#topic+user_agent">user_agent()</a></code>.</p>
</td></tr>
<tr><td><code id="oauth2.0_token_+3A_client_credentials">client_credentials</code></td>
<td>
<p>Default to <code>FALSE</code>. Set to <code>TRUE</code> to use
<em>Client Credentials Grant</em> instead of <em>Authorization
Code Grant</em>. See <a href="https://www.rfc-editor.org/rfc/rfc6749#section-4.4">https://www.rfc-editor.org/rfc/rfc6749#section-4.4</a>.</p>
</td></tr>
<tr><td><code id="oauth2.0_token_+3A_credentials">credentials</code></td>
<td>
<p>Advanced use only: allows you to completely customise
token generation.</p>
</td></tr>
<tr><td><code id="oauth2.0_token_+3A_query_authorize_extra">query_authorize_extra</code></td>
<td>
<p>Default to <code>list()</code>. Set to named list
holding query parameters to append to initial auth page query. Useful for
some APIs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+Token">Token()</a></code> for full details about the token object, and the
caching policies used to store credentials across sessions.
</p>


<h3>Value</h3>

<p>A <code>Token2.0</code> reference class (RC) object.
</p>


<h3>See Also</h3>

<p>Other OAuth: 
<code><a href="#topic+oauth1.0_token">oauth1.0_token</a>()</code>,
<code><a href="#topic+oauth_app">oauth_app</a>()</code>,
<code><a href="#topic+oauth_endpoint">oauth_endpoint</a>()</code>,
<code><a href="#topic+oauth_service_token">oauth_service_token</a>()</code>
</p>

<hr>
<h2 id='parse_http_date'>Parse and print http dates.</h2><span id='topic+parse_http_date'></span><span id='topic+http_date'></span>

<h3>Description</h3>

<p>As defined in RFC2616,
<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3">https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3</a>, there are
three valid formats:
</p>

<ul>
<li><p> Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123
</p>
</li>
<li><p> Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036
</p>
</li>
<li><p> Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>parse_http_date(x, failure = structure(NA_real_, class = "Date"))

http_date(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_http_date_+3A_x">x</code></td>
<td>
<p>For <code>parse_http_date</code>, a character vector of strings to parse.
All elements must be of the same type.
</p>
<p>For <code>http_date</code>, a <code>POSIXt</code> vector.</p>
</td></tr>
<tr><td><code id="parse_http_date_+3A_failure">failure</code></td>
<td>
<p>What to return on failure?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A POSIXct object if succesful, otherwise <code>failure</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parse_http_date("Sun, 06 Nov 1994 08:49:37 GMT")
parse_http_date("Sunday, 06-Nov-94 08:49:37 GMT")
parse_http_date("Sun Nov  6 08:49:37 1994")

http_date(Sys.time())
</code></pre>

<hr>
<h2 id='parse_media'>Parse a media type.</h2><span id='topic+parse_media'></span>

<h3>Description</h3>

<p>Parsed according to RFC 2616, as at
<a href="https://www.rfc-editor.org/rfc/rfc2616#section-3.7">https://www.rfc-editor.org/rfc/rfc2616#section-3.7</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_media(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_media_+3A_x">x</code></td>
<td>
<p>String to parse</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simplified minimal EBNF is:
</p>

<ul>
<li><p> media-type     = <code style="white-space: pre;">&#8288;type "/" subtype *( ";" parameter )&#8288;</code>
</p>
</li>
<li><p> type           = <code>token</code>
</p>
</li>
<li><p> subtype        = <code>token</code>
</p>
</li>
<li><p> parameter      = <code style="white-space: pre;">&#8288;attribute "=" value&#8288;</code>
</p>
</li>
<li><p> attribute      = <code>token</code>
</p>
</li>
<li><p> value          = <code>token | quoted-string</code>
</p>
</li>
<li><p> token          = <code style="white-space: pre;">&#8288;1*&lt;any CHAR except CTLs or ()&lt;&gt;@,;:\"/[]?=\{\}&#8288;</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>parse_media("text/plain")
parse_media("text/plain; charset=utf-8")
parse_media("text/plain; charset=\"utf-8\"")
parse_media("text/plain; randomparam=\";=;=\"")
</code></pre>

<hr>
<h2 id='parse_url'>Parse and build urls according to RFC3986.</h2><span id='topic+parse_url'></span><span id='topic+build_url'></span>

<h3>Description</h3>

<p>See <a href="https://www.rfc-editor.org/rfc/rfc3986">https://www.rfc-editor.org/rfc/rfc3986</a> for details of parsing
algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_url(url)

build_url(url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_url_+3A_url">url</code></td>
<td>
<p>For <code>parse_url</code> a character vector (of length 1) to parse
into components; for <code>build_url</code> a list of components to turn back
into a string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing:
</p>

<ul>
<li><p> scheme
</p>
</li>
<li><p> hostname
</p>
</li>
<li><p> port
</p>
</li>
<li><p> path
</p>
</li>
<li><p> params
</p>
</li>
<li><p> fragment
</p>
</li>
<li><p> query, a list
</p>
</li>
<li><p> username
</p>
</li>
<li><p> password
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>parse_url("http://google.com/")
parse_url("http://google.com:80/")
parse_url("http://google.com:80/?a=1&amp;b=2")

url &lt;- parse_url("http://google.com/")
url$scheme &lt;- "https"
url$query &lt;- list(q = "hello")
build_url(url)
</code></pre>

<hr>
<h2 id='PATCH'>Send PATCH request to a server.</h2><span id='topic+PATCH'></span>

<h3>Description</h3>

<p>Send PATCH request to a server.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PATCH(
  url = NULL,
  config = list(),
  ...,
  body = NULL,
  encode = c("multipart", "form", "json", "raw"),
  handle = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PATCH_+3A_url">url</code></td>
<td>
<p>the url of the page to retrieve</p>
</td></tr>
<tr><td><code id="PATCH_+3A_config">config</code></td>
<td>
<p>Additional configuration settings such as http
authentication (<code><a href="#topic+authenticate">authenticate()</a></code>), additional headers
(<code><a href="#topic+add_headers">add_headers()</a></code>), cookies (<code><a href="#topic+set_cookies">set_cookies()</a></code>) etc.
See <code><a href="#topic+config">config()</a></code> for full details and list of helpers.</p>
</td></tr>
<tr><td><code id="PATCH_+3A_...">...</code></td>
<td>
<p>Further named parameters, such as <code>query</code>, <code>path</code>, etc,
passed on to <code><a href="#topic+modify_url">modify_url()</a></code>. Unnamed parameters will be combined
with <code><a href="#topic+config">config()</a></code>.</p>
</td></tr>
<tr><td><code id="PATCH_+3A_body">body</code></td>
<td>
<p>One of the following:
</p>

<ul>
<li> <p><code>FALSE</code>: No body. This is typically not used with <code>POST</code>,
<code>PUT</code>, or <code>PATCH</code>, but can be useful if you need to send a
bodyless request (like <code>GET</code>) with <code>VERB()</code>.
</p>
</li>
<li> <p><code>NULL</code>: An empty body
</p>
</li>
<li> <p><code>""</code>: A length 0 body
</p>
</li>
<li> <p><code>upload_file("path/")</code>: The contents of a file.  The mime
type will be guessed from the extension, or can be supplied explicitly
as the second argument to <code>upload_file()</code>
</p>
</li>
<li><p> A character or raw vector: sent as is in body. Use
<code><a href="#topic+content_type">content_type()</a></code> to tell the server what sort of data
you are sending.
</p>
</li>
<li><p> A named list: See details for encode.
</p>
</li></ul>
</td></tr>
<tr><td><code id="PATCH_+3A_encode">encode</code></td>
<td>
<p>If the body is a named list, how should it be encoded? Can be
one of form (application/x-www-form-urlencoded), multipart,
(multipart/form-data), or json (application/json).
</p>
<p>For &quot;multipart&quot;, list elements can be strings or objects created by
<code><a href="#topic+upload_file">upload_file()</a></code>. For &quot;form&quot;, elements are coerced to strings
and escaped, use <code>I()</code> to prevent double-escaping. For &quot;json&quot;,
parameters are automatically &quot;unboxed&quot; (i.e. length 1 vectors are
converted to scalars). To preserve a length 1 vector as a vector,
wrap in <code>I()</code>. For &quot;raw&quot;, either a character or raw vector. You'll
need to make sure to set the <code><a href="#topic+content_type">content_type()</a></code> yourself.</p>
</td></tr>
<tr><td><code id="PATCH_+3A_handle">handle</code></td>
<td>
<p>The handle to use with this request. If not
supplied, will be retrieved and reused from the <code><a href="#topic+handle_pool">handle_pool()</a></code>
based on the scheme, hostname and port of the url. By default <span class="pkg">httr</span>
requests to the same scheme/host/port combo. This substantially reduces
connection time, and ensures that cookies are maintained over multiple
requests to the same host. See <code><a href="#topic+handle_pool">handle_pool()</a></code> for more
details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+response">response()</a></code> object.
</p>


<h3>See Also</h3>

<p>Other http methods: 
<code><a href="#topic+BROWSE">BROWSE</a>()</code>,
<code><a href="#topic+DELETE">DELETE</a>()</code>,
<code><a href="#topic+GET">GET</a>()</code>,
<code><a href="#topic+HEAD">HEAD</a>()</code>,
<code><a href="#topic+POST">POST</a>()</code>,
<code><a href="#topic+PUT">PUT</a>()</code>,
<code><a href="#topic+VERB">VERB</a>()</code>
</p>

<hr>
<h2 id='POST'>POST file to a server.</h2><span id='topic+POST'></span>

<h3>Description</h3>

<p>POST file to a server.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>POST(
  url = NULL,
  config = list(),
  ...,
  body = NULL,
  encode = c("multipart", "form", "json", "raw"),
  handle = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="POST_+3A_url">url</code></td>
<td>
<p>the url of the page to retrieve</p>
</td></tr>
<tr><td><code id="POST_+3A_config">config</code></td>
<td>
<p>Additional configuration settings such as http
authentication (<code><a href="#topic+authenticate">authenticate()</a></code>), additional headers
(<code><a href="#topic+add_headers">add_headers()</a></code>), cookies (<code><a href="#topic+set_cookies">set_cookies()</a></code>) etc.
See <code><a href="#topic+config">config()</a></code> for full details and list of helpers.</p>
</td></tr>
<tr><td><code id="POST_+3A_...">...</code></td>
<td>
<p>Further named parameters, such as <code>query</code>, <code>path</code>, etc,
passed on to <code><a href="#topic+modify_url">modify_url()</a></code>. Unnamed parameters will be combined
with <code><a href="#topic+config">config()</a></code>.</p>
</td></tr>
<tr><td><code id="POST_+3A_body">body</code></td>
<td>
<p>One of the following:
</p>

<ul>
<li> <p><code>FALSE</code>: No body. This is typically not used with <code>POST</code>,
<code>PUT</code>, or <code>PATCH</code>, but can be useful if you need to send a
bodyless request (like <code>GET</code>) with <code>VERB()</code>.
</p>
</li>
<li> <p><code>NULL</code>: An empty body
</p>
</li>
<li> <p><code>""</code>: A length 0 body
</p>
</li>
<li> <p><code>upload_file("path/")</code>: The contents of a file.  The mime
type will be guessed from the extension, or can be supplied explicitly
as the second argument to <code>upload_file()</code>
</p>
</li>
<li><p> A character or raw vector: sent as is in body. Use
<code><a href="#topic+content_type">content_type()</a></code> to tell the server what sort of data
you are sending.
</p>
</li>
<li><p> A named list: See details for encode.
</p>
</li></ul>
</td></tr>
<tr><td><code id="POST_+3A_encode">encode</code></td>
<td>
<p>If the body is a named list, how should it be encoded? Can be
one of form (application/x-www-form-urlencoded), multipart,
(multipart/form-data), or json (application/json).
</p>
<p>For &quot;multipart&quot;, list elements can be strings or objects created by
<code><a href="#topic+upload_file">upload_file()</a></code>. For &quot;form&quot;, elements are coerced to strings
and escaped, use <code>I()</code> to prevent double-escaping. For &quot;json&quot;,
parameters are automatically &quot;unboxed&quot; (i.e. length 1 vectors are
converted to scalars). To preserve a length 1 vector as a vector,
wrap in <code>I()</code>. For &quot;raw&quot;, either a character or raw vector. You'll
need to make sure to set the <code><a href="#topic+content_type">content_type()</a></code> yourself.</p>
</td></tr>
<tr><td><code id="POST_+3A_handle">handle</code></td>
<td>
<p>The handle to use with this request. If not
supplied, will be retrieved and reused from the <code><a href="#topic+handle_pool">handle_pool()</a></code>
based on the scheme, hostname and port of the url. By default <span class="pkg">httr</span>
requests to the same scheme/host/port combo. This substantially reduces
connection time, and ensures that cookies are maintained over multiple
requests to the same host. See <code><a href="#topic+handle_pool">handle_pool()</a></code> for more
details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+response">response()</a></code> object.
</p>


<h3>See Also</h3>

<p>Other http methods: 
<code><a href="#topic+BROWSE">BROWSE</a>()</code>,
<code><a href="#topic+DELETE">DELETE</a>()</code>,
<code><a href="#topic+GET">GET</a>()</code>,
<code><a href="#topic+HEAD">HEAD</a>()</code>,
<code><a href="#topic+PATCH">PATCH</a>()</code>,
<code><a href="#topic+PUT">PUT</a>()</code>,
<code><a href="#topic+VERB">VERB</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
b2 &lt;- "http://httpbin.org/post"
POST(b2, body = "A simple text string")
POST(b2, body = list(x = "A simple text string"))
POST(b2, body = list(y = upload_file(system.file("CITATION"))))
POST(b2, body = list(x = "A simple text string"), encode = "json")

# body can also be provided as a json string directly to deal
# with specific case, like an empty element in the json string.
# passing as string directly
POST(b2, body = '{"a":1,"b":{}}', encode = "raw")
# or building the json string before
json_body &lt;- jsonlite::toJSON(list(a = 1, b = NULL), auto_unbox = TRUE)
POST(b2, body = json_body, encode = "raw")

# Various types of empty body:
POST(b2, body = NULL, verbose())
POST(b2, body = FALSE, verbose())
POST(b2, body = "", verbose())

## End(Not run)
</code></pre>

<hr>
<h2 id='progress'>Add a progress bar.</h2><span id='topic+progress'></span>

<h3>Description</h3>

<p>Add a progress bar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>progress(type = c("down", "up"), con = stdout())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="progress_+3A_type">type</code></td>
<td>
<p>Type of progress to display: either number of bytes uploaded
or downloaded.</p>
</td></tr>
<tr><td><code id="progress_+3A_con">con</code></td>
<td>
<p>Connection to send output too. Usually <code>stdout()</code> or
<code>stderr</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cap_speed &lt;- config(max_recv_speed_large = 10000)
## Not run: 
# If file size is known, you get a progress bar:
x &lt;- GET("http://httpbin.org/bytes/102400", progress(), cap_speed)
# Otherwise you get the number of bytes downloaded:
x &lt;- GET("http://httpbin.org/stream-bytes/102400", progress(), cap_speed)

## End(Not run)
</code></pre>

<hr>
<h2 id='PUT'>Send PUT request to server.</h2><span id='topic+PUT'></span>

<h3>Description</h3>

<p>Send PUT request to server.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PUT(
  url = NULL,
  config = list(),
  ...,
  body = NULL,
  encode = c("multipart", "form", "json", "raw"),
  handle = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PUT_+3A_url">url</code></td>
<td>
<p>the url of the page to retrieve</p>
</td></tr>
<tr><td><code id="PUT_+3A_config">config</code></td>
<td>
<p>Additional configuration settings such as http
authentication (<code><a href="#topic+authenticate">authenticate()</a></code>), additional headers
(<code><a href="#topic+add_headers">add_headers()</a></code>), cookies (<code><a href="#topic+set_cookies">set_cookies()</a></code>) etc.
See <code><a href="#topic+config">config()</a></code> for full details and list of helpers.</p>
</td></tr>
<tr><td><code id="PUT_+3A_...">...</code></td>
<td>
<p>Further named parameters, such as <code>query</code>, <code>path</code>, etc,
passed on to <code><a href="#topic+modify_url">modify_url()</a></code>. Unnamed parameters will be combined
with <code><a href="#topic+config">config()</a></code>.</p>
</td></tr>
<tr><td><code id="PUT_+3A_body">body</code></td>
<td>
<p>One of the following:
</p>

<ul>
<li> <p><code>FALSE</code>: No body. This is typically not used with <code>POST</code>,
<code>PUT</code>, or <code>PATCH</code>, but can be useful if you need to send a
bodyless request (like <code>GET</code>) with <code>VERB()</code>.
</p>
</li>
<li> <p><code>NULL</code>: An empty body
</p>
</li>
<li> <p><code>""</code>: A length 0 body
</p>
</li>
<li> <p><code>upload_file("path/")</code>: The contents of a file.  The mime
type will be guessed from the extension, or can be supplied explicitly
as the second argument to <code>upload_file()</code>
</p>
</li>
<li><p> A character or raw vector: sent as is in body. Use
<code><a href="#topic+content_type">content_type()</a></code> to tell the server what sort of data
you are sending.
</p>
</li>
<li><p> A named list: See details for encode.
</p>
</li></ul>
</td></tr>
<tr><td><code id="PUT_+3A_encode">encode</code></td>
<td>
<p>If the body is a named list, how should it be encoded? Can be
one of form (application/x-www-form-urlencoded), multipart,
(multipart/form-data), or json (application/json).
</p>
<p>For &quot;multipart&quot;, list elements can be strings or objects created by
<code><a href="#topic+upload_file">upload_file()</a></code>. For &quot;form&quot;, elements are coerced to strings
and escaped, use <code>I()</code> to prevent double-escaping. For &quot;json&quot;,
parameters are automatically &quot;unboxed&quot; (i.e. length 1 vectors are
converted to scalars). To preserve a length 1 vector as a vector,
wrap in <code>I()</code>. For &quot;raw&quot;, either a character or raw vector. You'll
need to make sure to set the <code><a href="#topic+content_type">content_type()</a></code> yourself.</p>
</td></tr>
<tr><td><code id="PUT_+3A_handle">handle</code></td>
<td>
<p>The handle to use with this request. If not
supplied, will be retrieved and reused from the <code><a href="#topic+handle_pool">handle_pool()</a></code>
based on the scheme, hostname and port of the url. By default <span class="pkg">httr</span>
requests to the same scheme/host/port combo. This substantially reduces
connection time, and ensures that cookies are maintained over multiple
requests to the same host. See <code><a href="#topic+handle_pool">handle_pool()</a></code> for more
details.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other http methods: 
<code><a href="#topic+BROWSE">BROWSE</a>()</code>,
<code><a href="#topic+DELETE">DELETE</a>()</code>,
<code><a href="#topic+GET">GET</a>()</code>,
<code><a href="#topic+HEAD">HEAD</a>()</code>,
<code><a href="#topic+PATCH">PATCH</a>()</code>,
<code><a href="#topic+POST">POST</a>()</code>,
<code><a href="#topic+VERB">VERB</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
POST("http://httpbin.org/put")
PUT("http://httpbin.org/put")

b2 &lt;- "http://httpbin.org/put"
PUT(b2, body = "A simple text string")
PUT(b2, body = list(x = "A simple text string"))
PUT(b2, body = list(y = upload_file(system.file("CITATION"))))
PUT(b2, body = list(x = "A simple text string"), encode = "json")

## End(Not run)
</code></pre>

<hr>
<h2 id='response'>The response object.</h2><span id='topic+response'></span>

<h3>Description</h3>

<p>The response object captures all information from a request.  It includes
fields:
</p>

<ul>
<li> <p><code>url</code> the url the request was actually sent to (after redirects)
</p>
</li>
<li> <p><code>handle</code> the handle associated with the url
</p>
</li>
<li> <p><code>status_code</code> the http status code
</p>
</li>
<li> <p><code>header</code> a named list of headers returned by the server
</p>
</li>
<li> <p><code>cookies</code> a named list of cookies returned by the server
</p>
</li>
<li> <p><code>content</code> the body of the response, as raw vector. See <code><a href="#topic+content">content()</a></code> for various ways to access the content.
</p>
</li>
<li> <p><code>time</code> request timing information
</p>
</li>
<li> <p><code>config</code> configuration for the request
</p>
</li></ul>



<h3>Details</h3>

<p>For non-http(s) responses, some parts including the status and
header may not be interpretable the same way as http responses.
</p>


<h3>See Also</h3>

<p>Other response methods: 
<code><a href="#topic+content">content</a>()</code>,
<code><a href="#topic+http_error">http_error</a>()</code>,
<code><a href="#topic+http_status">http_status</a>()</code>,
<code><a href="#topic+stop_for_status">stop_for_status</a>()</code>
</p>

<hr>
<h2 id='RETRY'>Retry a request until it succeeds.</h2><span id='topic+RETRY'></span>

<h3>Description</h3>

<p>Safely retry a request until it succeeds, as defined by the <code>terminate_on</code>
parameter, which by default means a response for which <code><a href="#topic+http_error">http_error()</a></code>
is <code>FALSE</code>. Will also retry on error conditions raised by the underlying curl code,
but if the last retry still raises one, <code>RETRY</code> will raise it again with
<code><a href="base.html#topic+stop">stop()</a></code>.
It is designed to be kind to the server: after each failure
randomly waits up to twice as long. (Technically it uses exponential
backoff with jitter, using the approach outlined in
<a href="https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/">https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/</a>.)
If the server returns status code 429 and specifies a <code>retry-after</code> value, that
value will be used instead, unless it's smaller than <code>pause_min</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RETRY(
  verb,
  url = NULL,
  config = list(),
  ...,
  body = NULL,
  encode = c("multipart", "form", "json", "raw"),
  times = 3,
  pause_base = 1,
  pause_cap = 60,
  pause_min = 1,
  handle = NULL,
  quiet = FALSE,
  terminate_on = NULL,
  terminate_on_success = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RETRY_+3A_verb">verb</code></td>
<td>
<p>Name of verb to use.</p>
</td></tr>
<tr><td><code id="RETRY_+3A_url">url</code></td>
<td>
<p>the url of the page to retrieve</p>
</td></tr>
<tr><td><code id="RETRY_+3A_config">config</code></td>
<td>
<p>Additional configuration settings such as http
authentication (<code><a href="#topic+authenticate">authenticate()</a></code>), additional headers
(<code><a href="#topic+add_headers">add_headers()</a></code>), cookies (<code><a href="#topic+set_cookies">set_cookies()</a></code>) etc.
See <code><a href="#topic+config">config()</a></code> for full details and list of helpers.</p>
</td></tr>
<tr><td><code id="RETRY_+3A_...">...</code></td>
<td>
<p>Further named parameters, such as <code>query</code>, <code>path</code>, etc,
passed on to <code><a href="#topic+modify_url">modify_url()</a></code>. Unnamed parameters will be combined
with <code><a href="#topic+config">config()</a></code>.</p>
</td></tr>
<tr><td><code id="RETRY_+3A_body">body</code></td>
<td>
<p>One of the following:
</p>

<ul>
<li> <p><code>FALSE</code>: No body. This is typically not used with <code>POST</code>,
<code>PUT</code>, or <code>PATCH</code>, but can be useful if you need to send a
bodyless request (like <code>GET</code>) with <code>VERB()</code>.
</p>
</li>
<li> <p><code>NULL</code>: An empty body
</p>
</li>
<li> <p><code>""</code>: A length 0 body
</p>
</li>
<li> <p><code>upload_file("path/")</code>: The contents of a file.  The mime
type will be guessed from the extension, or can be supplied explicitly
as the second argument to <code>upload_file()</code>
</p>
</li>
<li><p> A character or raw vector: sent as is in body. Use
<code><a href="#topic+content_type">content_type()</a></code> to tell the server what sort of data
you are sending.
</p>
</li>
<li><p> A named list: See details for encode.
</p>
</li></ul>
</td></tr>
<tr><td><code id="RETRY_+3A_encode">encode</code></td>
<td>
<p>If the body is a named list, how should it be encoded? Can be
one of form (application/x-www-form-urlencoded), multipart,
(multipart/form-data), or json (application/json).
</p>
<p>For &quot;multipart&quot;, list elements can be strings or objects created by
<code><a href="#topic+upload_file">upload_file()</a></code>. For &quot;form&quot;, elements are coerced to strings
and escaped, use <code>I()</code> to prevent double-escaping. For &quot;json&quot;,
parameters are automatically &quot;unboxed&quot; (i.e. length 1 vectors are
converted to scalars). To preserve a length 1 vector as a vector,
wrap in <code>I()</code>. For &quot;raw&quot;, either a character or raw vector. You'll
need to make sure to set the <code><a href="#topic+content_type">content_type()</a></code> yourself.</p>
</td></tr>
<tr><td><code id="RETRY_+3A_times">times</code></td>
<td>
<p>Maximum number of requests to attempt.</p>
</td></tr>
<tr><td><code id="RETRY_+3A_pause_base">pause_base</code>, <code id="RETRY_+3A_pause_cap">pause_cap</code></td>
<td>
<p>This method uses exponential back-off with full
jitter - this means that each request will randomly wait between
<code>pause_min</code> and <code>pause_base * 2 ^ attempt</code> seconds, up to a maximum of
<code>pause_cap</code> seconds.</p>
</td></tr>
<tr><td><code id="RETRY_+3A_pause_min">pause_min</code></td>
<td>
<p>Minimum time to wait in the backoff; generally
only necessary if you need pauses less than one second (which may
not be kind to the server, use with caution!).</p>
</td></tr>
<tr><td><code id="RETRY_+3A_handle">handle</code></td>
<td>
<p>The handle to use with this request. If not
supplied, will be retrieved and reused from the <code><a href="#topic+handle_pool">handle_pool()</a></code>
based on the scheme, hostname and port of the url. By default <span class="pkg">httr</span>
requests to the same scheme/host/port combo. This substantially reduces
connection time, and ensures that cookies are maintained over multiple
requests to the same host. See <code><a href="#topic+handle_pool">handle_pool()</a></code> for more
details.</p>
</td></tr>
<tr><td><code id="RETRY_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code>, will print a message displaying how long
until the next request.</p>
</td></tr>
<tr><td><code id="RETRY_+3A_terminate_on">terminate_on</code></td>
<td>
<p>Optional vector of numeric HTTP status codes that if found
on the response will terminate the retry process. If <code>NULL</code>, will keep
retrying while <code><a href="#topic+http_error">http_error()</a></code> is <code>TRUE</code> for the response.</p>
</td></tr>
<tr><td><code id="RETRY_+3A_terminate_on_success">terminate_on_success</code></td>
<td>
<p>If <code>TRUE</code>, the default, this will
automatically terminate when the request is successful, regardless of the
value of <code>terminate_on</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The last response. Note that if the request doesn't succeed after
<code>times</code> times this will be a failed request, i.e. you still need
to use <code><a href="#topic+stop_for_status">stop_for_status()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Succeeds straight away
RETRY("GET", "http://httpbin.org/status/200")
# Never succeeds
RETRY("GET", "http://httpbin.org/status/500")
# Invalid hostname generates curl error condition and is retried but eventually
# raises an error condition.
RETRY("GET", "http://invalidhostname/")

## End(Not run)
</code></pre>

<hr>
<h2 id='revoke_all'>Revoke all OAuth tokens in the cache.</h2><span id='topic+revoke_all'></span>

<h3>Description</h3>

<p>Use this function if you think that your token may have been compromised,
e.g. you accidentally uploaded the cache file to github. It's not possible
to automatically revoke all tokens - this function will warn when it can't.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>revoke_all(cache_path = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="revoke_all_+3A_cache_path">cache_path</code></td>
<td>
<p>Path to cache file. Defaults to <code>.httr-oauth</code> in
current directory.</p>
</td></tr>
</table>

<hr>
<h2 id='set_config'>Set (and reset) global httr configuration.</h2><span id='topic+set_config'></span><span id='topic+reset_config'></span>

<h3>Description</h3>

<p>Set (and reset) global httr configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_config(config, override = FALSE)

reset_config()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_config_+3A_config">config</code></td>
<td>
<p>Settings as generated by <code><a href="#topic+add_headers">add_headers()</a></code>,
<code><a href="#topic+set_cookies">set_cookies()</a></code> or <code><a href="#topic+authenticate">authenticate()</a></code>.</p>
</td></tr>
<tr><td><code id="set_config_+3A_override">override</code></td>
<td>
<p>if <code>TRUE</code>, ignore existing settings, if <code>FALSE</code>,
combine new config with old.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibility, the old global config.
</p>


<h3>See Also</h3>

<p>Other ways to set configuration: 
<code><a href="#topic+config">config</a>()</code>,
<code><a href="#topic+with_config">with_config</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GET("http://google.com")
set_config(verbose())
GET("http://google.com")
reset_config()
GET("http://google.com")
</code></pre>

<hr>
<h2 id='set_cookies'>Set cookies.</h2><span id='topic+set_cookies'></span>

<h3>Description</h3>

<p>Set cookies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_cookies(..., .cookies = character(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_cookies_+3A_...">...</code></td>
<td>
<p>a named cookie values</p>
</td></tr>
<tr><td><code id="set_cookies_+3A_.cookies">.cookies</code></td>
<td>
<p>a named character vector</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+cookies">cookies()</a></code> to see cookies in response.
</p>
<p>Other config: 
<code><a href="#topic+add_headers">add_headers</a>()</code>,
<code><a href="#topic+authenticate">authenticate</a>()</code>,
<code><a href="#topic+config">config</a>()</code>,
<code><a href="#topic+timeout">timeout</a>()</code>,
<code><a href="#topic+use_proxy">use_proxy</a>()</code>,
<code><a href="#topic+user_agent">user_agent</a>()</code>,
<code><a href="#topic+verbose">verbose</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set_cookies(a = 1, b = 2)
set_cookies(.cookies = c(a = "1", b = "2"))

## Not run: 
GET("http://httpbin.org/cookies")
GET("http://httpbin.org/cookies", set_cookies(a = 1, b = 2))

## End(Not run)
</code></pre>

<hr>
<h2 id='sha1_hash'>SHA1 hash</h2><span id='topic+sha1_hash'></span>

<h3>Description</h3>

<p>Creates a SHA1 hash of data using either HMAC or RSA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sha1_hash(key, string, method = "HMAC-SHA1")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sha1_hash_+3A_key">key</code></td>
<td>
<p>The key to create the hash with</p>
</td></tr>
<tr><td><code id="sha1_hash_+3A_string">string</code></td>
<td>
<p>data to securely hash</p>
</td></tr>
<tr><td><code id="sha1_hash_+3A_method">method</code></td>
<td>
<p>The method to use, either HMAC-SHA1 or RSA-SHA1</p>
</td></tr>
</table>

<hr>
<h2 id='sign_oauth'>Sign an OAuth request</h2><span id='topic+sign_oauth'></span><span id='topic+sign_oauth1.0'></span><span id='topic+sign_oauth2.0'></span>

<h3>Description</h3>

<p>Deprecated. Instead create a config object directly using
<code>config(token = my_token)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sign_oauth1.0(app, token = NULL, token_secret = NULL, as_header = TRUE, ...)

sign_oauth2.0(access_token, as_header = TRUE)
</code></pre>

<hr>
<h2 id='status_code'>Extract status code from response.</h2><span id='topic+status_code'></span>

<h3>Description</h3>

<p>Extract status code from response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>status_code(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="status_code_+3A_x">x</code></td>
<td>
<p>A response</p>
</td></tr>
</table>

<hr>
<h2 id='stop_for_status'>Take action on http error.</h2><span id='topic+stop_for_status'></span><span id='topic+warn_for_status'></span><span id='topic+message_for_status'></span>

<h3>Description</h3>

<p>Converts http errors to R errors or warnings - these should always
be used whenever you're creating requests inside a function, so
that the user knows why a request has failed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_for_status(x, task = NULL)

warn_for_status(x, task = NULL)

message_for_status(x, task = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_for_status_+3A_x">x</code></td>
<td>
<p>a response, or numeric http code (or other object with
<code>status_code</code> method)</p>
</td></tr>
<tr><td><code id="stop_for_status_+3A_task">task</code></td>
<td>
<p>The text of the message: either <code>NULL</code> or a
character vector. If non-<code>NULL</code>, the error message will finish with
&quot;Failed to <code>task</code>&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If request was successful, the response (invisibly). Otherwise,
raised a classed http error or warning, as generated by
<code><a href="#topic+http_condition">http_condition()</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+http_status">http_status()</a></code> and
<code style="white-space: pre;">&#8288;http://en.wikipedia.org/wiki/Http_status_codes&#8288;</code> for more information
on http status codes.
</p>
<p>Other response methods: 
<code><a href="#topic+content">content</a>()</code>,
<code><a href="#topic+http_error">http_error</a>()</code>,
<code><a href="#topic+http_status">http_status</a>()</code>,
<code><a href="#topic+response">response</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- GET("http://httpbin.org/status/200")
stop_for_status(x) # nothing happens
warn_for_status(x)
message_for_status(x)

x &lt;- GET("http://httpbin.org/status/300")
stop_for_status(x)
warn_for_status(x)
message_for_status(x)

x &lt;- GET("http://httpbin.org/status/404")
stop_for_status(x)
warn_for_status(x)
message_for_status(x)

# You can provide more information with the task argument
warn_for_status(x, "download spreadsheet")
message_for_status(x, "download spreadsheet")

## End(Not run)
</code></pre>

<hr>
<h2 id='timeout'>Set maximum request time.</h2><span id='topic+timeout'></span>

<h3>Description</h3>

<p>Set maximum request time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeout(seconds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeout_+3A_seconds">seconds</code></td>
<td>
<p>number of seconds to wait for a response until giving up.
Can not be less than 1 ms.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This timeout is passed on to <code><a href="curl.html#topic+handle">curl::handle_setopt()</a></code>.
See there and <code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code> for more details.
</p>


<h3>See Also</h3>

<p>Other config: 
<code><a href="#topic+add_headers">add_headers</a>()</code>,
<code><a href="#topic+authenticate">authenticate</a>()</code>,
<code><a href="#topic+config">config</a>()</code>,
<code><a href="#topic+set_cookies">set_cookies</a>()</code>,
<code><a href="#topic+use_proxy">use_proxy</a>()</code>,
<code><a href="#topic+user_agent">user_agent</a>()</code>,
<code><a href="#topic+verbose">verbose</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
GET("http://httpbin.org/delay/3", timeout(1))
GET("http://httpbin.org/delay/1", timeout(2))

## End(Not run)
</code></pre>

<hr>
<h2 id='Token-class'>OAuth token objects.</h2><span id='topic+Token-class'></span><span id='topic+Token'></span><span id='topic+Token1.0'></span><span id='topic+Token2.0'></span><span id='topic+TokenServiceAccount'></span>

<h3>Description</h3>

<p>These objects represent the complete set of data needed for OAuth access:
an app, an endpoint, cached credentials and parameters. They should be
created through their constructor functions <code><a href="#topic+oauth1.0_token">oauth1.0_token()</a></code>
and <code><a href="#topic+oauth2.0_token">oauth2.0_token()</a></code>.
</p>


<h3>Format</h3>

<p>An R6 class object.
</p>


<h3>Methods</h3>


<ul>
<li> <p><code>cache()</code>: caches token to disk
</p>
</li>
<li> <p><code>sign(method, url)</code>: returns list of url and config
</p>
</li>
<li> <p><code>refresh()</code>: refresh access token (if possible)
</p>
</li>
<li> <p><code>validate()</code>: TRUE if the token is still valid, FALSE otherwise
</p>
</li></ul>



<h3>Caching</h3>

<p>OAuth tokens are cached on disk in a file called <code>.httr-oauth</code>
saved in the current working directory.  Caching is enabled if:
</p>

<ul>
<li><p> The session is interactive, and the user agrees to it, OR
</p>
</li>
<li><p> The <code>.httr-oauth</code> file is already present, OR
</p>
</li>
<li> <p><code>getOption("httr_oauth_cache")</code> is <code>TRUE</code>
</p>
</li></ul>

<p>You can suppress caching by setting the <code>httr_oauth_cache</code> option to
<code>FALSE</code>.
</p>
<p>Tokens are cached based on their endpoint and parameters.
</p>
<p>The cache file should not be included in source code control or R packages
(because it contains private information), so httr will automatically add
the appropriate entries to <code>.gitignore</code> and <code>.Rbuildignore</code> if needed.
</p>

<hr>
<h2 id='upload_file'>Upload a file with <code><a href="#topic+POST">POST()</a></code> or <code><a href="#topic+PUT">PUT()</a></code>.</h2><span id='topic+upload_file'></span>

<h3>Description</h3>

<p>Upload a file with <code><a href="#topic+POST">POST()</a></code> or <code><a href="#topic+PUT">PUT()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upload_file(path, type = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upload_file_+3A_path">path</code></td>
<td>
<p>path to file</p>
</td></tr>
<tr><td><code id="upload_file_+3A_type">type</code></td>
<td>
<p>mime type of path. If not supplied, will be guess by
<code><a href="mime.html#topic+guess_type">mime::guess_type()</a></code> when needed.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>citation &lt;- upload_file(system.file("CITATION"))
## Not run: 
POST("http://httpbin.org/post", body = citation)
POST("http://httpbin.org/post", body = list(y = citation))

## End(Not run)
</code></pre>

<hr>
<h2 id='use_proxy'>Use a proxy to connect to the internet.</h2><span id='topic+use_proxy'></span>

<h3>Description</h3>

<p>Use a proxy to connect to the internet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_proxy(url, port = NULL, username = NULL, password = NULL, auth = "basic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_proxy_+3A_url">url</code>, <code id="use_proxy_+3A_port">port</code></td>
<td>
<p>location of proxy</p>
</td></tr>
<tr><td><code id="use_proxy_+3A_username">username</code>, <code id="use_proxy_+3A_password">password</code></td>
<td>
<p>login details for proxy, if needed</p>
</td></tr>
<tr><td><code id="use_proxy_+3A_auth">auth</code></td>
<td>
<p>type of HTTP authentication to use. Should be one of the
following: basic, digest, digest_ie, gssnegotiate, ntlm, any.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other config: 
<code><a href="#topic+add_headers">add_headers</a>()</code>,
<code><a href="#topic+authenticate">authenticate</a>()</code>,
<code><a href="#topic+config">config</a>()</code>,
<code><a href="#topic+set_cookies">set_cookies</a>()</code>,
<code><a href="#topic+timeout">timeout</a>()</code>,
<code><a href="#topic+user_agent">user_agent</a>()</code>,
<code><a href="#topic+verbose">verbose</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See http://www.hidemyass.com/proxy-list for a list of public proxies
# to test with
# GET("http://had.co.nz", use_proxy("64.251.21.73", 8080), verbose())
</code></pre>

<hr>
<h2 id='user_agent'>Set user agent.</h2><span id='topic+user_agent'></span>

<h3>Description</h3>

<p>Override the default RCurl user agent of <code>NULL</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>user_agent(agent)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="user_agent_+3A_agent">agent</code></td>
<td>
<p>string giving user agent</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other config: 
<code><a href="#topic+add_headers">add_headers</a>()</code>,
<code><a href="#topic+authenticate">authenticate</a>()</code>,
<code><a href="#topic+config">config</a>()</code>,
<code><a href="#topic+set_cookies">set_cookies</a>()</code>,
<code><a href="#topic+timeout">timeout</a>()</code>,
<code><a href="#topic+use_proxy">use_proxy</a>()</code>,
<code><a href="#topic+verbose">verbose</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
GET("http://httpbin.org/user-agent")
GET("http://httpbin.org/user-agent", user_agent("httr"))

## End(Not run)
</code></pre>

<hr>
<h2 id='VERB'>VERB a url.</h2><span id='topic+VERB'></span>

<h3>Description</h3>

<p>Use an arbitrary verb.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VERB(
  verb,
  url = NULL,
  config = list(),
  ...,
  body = NULL,
  encode = c("multipart", "form", "json", "raw"),
  handle = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VERB_+3A_verb">verb</code></td>
<td>
<p>Name of verb to use.</p>
</td></tr>
<tr><td><code id="VERB_+3A_url">url</code></td>
<td>
<p>the url of the page to retrieve</p>
</td></tr>
<tr><td><code id="VERB_+3A_config">config</code></td>
<td>
<p>Additional configuration settings such as http
authentication (<code><a href="#topic+authenticate">authenticate()</a></code>), additional headers
(<code><a href="#topic+add_headers">add_headers()</a></code>), cookies (<code><a href="#topic+set_cookies">set_cookies()</a></code>) etc.
See <code><a href="#topic+config">config()</a></code> for full details and list of helpers.</p>
</td></tr>
<tr><td><code id="VERB_+3A_...">...</code></td>
<td>
<p>Further named parameters, such as <code>query</code>, <code>path</code>, etc,
passed on to <code><a href="#topic+modify_url">modify_url()</a></code>. Unnamed parameters will be combined
with <code><a href="#topic+config">config()</a></code>.</p>
</td></tr>
<tr><td><code id="VERB_+3A_body">body</code></td>
<td>
<p>One of the following:
</p>

<ul>
<li> <p><code>FALSE</code>: No body. This is typically not used with <code>POST</code>,
<code>PUT</code>, or <code>PATCH</code>, but can be useful if you need to send a
bodyless request (like <code>GET</code>) with <code>VERB()</code>.
</p>
</li>
<li> <p><code>NULL</code>: An empty body
</p>
</li>
<li> <p><code>""</code>: A length 0 body
</p>
</li>
<li> <p><code>upload_file("path/")</code>: The contents of a file.  The mime
type will be guessed from the extension, or can be supplied explicitly
as the second argument to <code>upload_file()</code>
</p>
</li>
<li><p> A character or raw vector: sent as is in body. Use
<code><a href="#topic+content_type">content_type()</a></code> to tell the server what sort of data
you are sending.
</p>
</li>
<li><p> A named list: See details for encode.
</p>
</li></ul>
</td></tr>
<tr><td><code id="VERB_+3A_encode">encode</code></td>
<td>
<p>If the body is a named list, how should it be encoded? Can be
one of form (application/x-www-form-urlencoded), multipart,
(multipart/form-data), or json (application/json).
</p>
<p>For &quot;multipart&quot;, list elements can be strings or objects created by
<code><a href="#topic+upload_file">upload_file()</a></code>. For &quot;form&quot;, elements are coerced to strings
and escaped, use <code>I()</code> to prevent double-escaping. For &quot;json&quot;,
parameters are automatically &quot;unboxed&quot; (i.e. length 1 vectors are
converted to scalars). To preserve a length 1 vector as a vector,
wrap in <code>I()</code>. For &quot;raw&quot;, either a character or raw vector. You'll
need to make sure to set the <code><a href="#topic+content_type">content_type()</a></code> yourself.</p>
</td></tr>
<tr><td><code id="VERB_+3A_handle">handle</code></td>
<td>
<p>The handle to use with this request. If not
supplied, will be retrieved and reused from the <code><a href="#topic+handle_pool">handle_pool()</a></code>
based on the scheme, hostname and port of the url. By default <span class="pkg">httr</span>
requests to the same scheme/host/port combo. This substantially reduces
connection time, and ensures that cookies are maintained over multiple
requests to the same host. See <code><a href="#topic+handle_pool">handle_pool()</a></code> for more
details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+response">response()</a></code> object.
</p>


<h3>See Also</h3>

<p>Other http methods: 
<code><a href="#topic+BROWSE">BROWSE</a>()</code>,
<code><a href="#topic+DELETE">DELETE</a>()</code>,
<code><a href="#topic+GET">GET</a>()</code>,
<code><a href="#topic+HEAD">HEAD</a>()</code>,
<code><a href="#topic+PATCH">PATCH</a>()</code>,
<code><a href="#topic+POST">POST</a>()</code>,
<code><a href="#topic+PUT">PUT</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- VERB(
  "PROPFIND", "http://svn.r-project.org/R/tags/",
  add_headers(depth = 1), verbose()
)
stop_for_status(r)
content(r)

## Not run: 
VERB("POST", url = "http://httpbin.org/post")
VERB("POST", url = "http://httpbin.org/post", body = "foobar")

## End(Not run)
</code></pre>

<hr>
<h2 id='verbose'>Give verbose output.</h2><span id='topic+verbose'></span>

<h3>Description</h3>

<p>A verbose connection provides much more information about the flow of
information between the client and server.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verbose(data_out = TRUE, data_in = FALSE, info = FALSE, ssl = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verbose_+3A_data_out">data_out</code></td>
<td>
<p>Show data sent to the server.</p>
</td></tr>
<tr><td><code id="verbose_+3A_data_in">data_in</code></td>
<td>
<p>Show data recieved from the server.</p>
</td></tr>
<tr><td><code id="verbose_+3A_info">info</code></td>
<td>
<p>Show informational text from curl. This is mainly useful
for debugging https and auth problems, so is disabled by default.</p>
</td></tr>
<tr><td><code id="verbose_+3A_ssl">ssl</code></td>
<td>
<p>Show even data sent/recieved over SSL connections?</p>
</td></tr>
</table>


<h3>Prefixes</h3>

<p><code>verbose()</code> uses the following prefixes to distinguish between
different components of the http messages:
</p>

<ul>
<li> <p><code>*</code> informative curl messages
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;-&gt;&#8288;</code> headers sent (out)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;&gt;&gt;&#8288;</code> data sent (out)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;*&gt;&#8288;</code> ssl data sent (out)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;&lt;-&#8288;</code> headers received (in)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;&lt;&lt;&#8288;</code> data received (in)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;&lt;*&#8288;</code> ssl data received (in)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+with_verbose">with_verbose()</a></code> makes it easier to use verbose mode
even when the requests are buried inside another function call.
</p>
<p>Other config: 
<code><a href="#topic+add_headers">add_headers</a>()</code>,
<code><a href="#topic+authenticate">authenticate</a>()</code>,
<code><a href="#topic+config">config</a>()</code>,
<code><a href="#topic+set_cookies">set_cookies</a>()</code>,
<code><a href="#topic+timeout">timeout</a>()</code>,
<code><a href="#topic+use_proxy">use_proxy</a>()</code>,
<code><a href="#topic+user_agent">user_agent</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
GET("http://httpbin.org", verbose())
GET("http://httpbin.org", verbose(info = TRUE))

f &lt;- function() {
  GET("http://httpbin.org")
}
with_verbose(f())
with_verbose(f(), info = TRUE)

# verbose() makes it easy to see exactly what POST requests send
POST_verbose &lt;- function(body, ...) {
  POST("https://httpbin.org/post", body = body, verbose(), ...)
  invisible()
}
POST_verbose(list(x = "a", y = "b"))
POST_verbose(list(x = "a", y = "b"), encode = "form")
POST_verbose(FALSE)
POST_verbose(NULL)
POST_verbose("")
POST_verbose("xyz")

## End(Not run)
</code></pre>

<hr>
<h2 id='with_config'>Execute code with configuration set.</h2><span id='topic+with_config'></span><span id='topic+with_verbose'></span>

<h3>Description</h3>

<p>Execute code with configuration set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_config(config = config(), expr, override = FALSE)

with_verbose(expr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_config_+3A_config">config</code></td>
<td>
<p>Settings as generated by <code><a href="#topic+add_headers">add_headers()</a></code>,
<code><a href="#topic+set_cookies">set_cookies()</a></code> or <code><a href="#topic+authenticate">authenticate()</a></code>.</p>
</td></tr>
<tr><td><code id="with_config_+3A_expr">expr</code></td>
<td>
<p>code to execute under specified configuration</p>
</td></tr>
<tr><td><code id="with_config_+3A_override">override</code></td>
<td>
<p>if <code>TRUE</code>, ignore existing settings, if <code>FALSE</code>,
combine new config with old.</p>
</td></tr>
<tr><td><code id="with_config_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+verbose">verbose()</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other ways to set configuration: 
<code><a href="#topic+config">config</a>()</code>,
<code><a href="#topic+set_config">set_config</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with_config(verbose(), {
  GET("http://had.co.nz")
  GET("http://google.com")
})

# Or even easier:
with_verbose(GET("http://google.com"))
</code></pre>

<hr>
<h2 id='write_disk'>Control where the response body is written.</h2><span id='topic+write_disk'></span><span id='topic+write_memory'></span>

<h3>Description</h3>

<p>The default behaviour is to use <code>write_memory()</code>, which caches
the response locally in memory. This is useful when talking to APIs as
it avoids a round-trip to disk. If you want to save a file that's bigger
than memory, use <code>write_disk()</code> to save it to a known path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_disk(path, overwrite = FALSE)

write_memory()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_disk_+3A_path">path</code></td>
<td>
<p>Path to content to.</p>
</td></tr>
<tr><td><code id="write_disk_+3A_overwrite">overwrite</code></td>
<td>
<p>Will only overwrite existing <code>path</code> if TRUE.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- tempfile()
r1 &lt;- GET("https://www.google.com", write_disk(tmp))
readLines(tmp)

# The default
r2 &lt;- GET("https://www.google.com", write_memory())

# Save a very large file
## Not run: 
GET(
  "http://www2.census.gov/acs2011_5yr/pums/csv_pus.zip",
  write_disk("csv_pus.zip"), progress()
)

## End(Not run)
</code></pre>

<hr>
<h2 id='write_function'>S3 object to define response writer.</h2><span id='topic+write_function'></span>

<h3>Description</h3>

<p>This S3 object allows you to control how the response body is saved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_function(subclass, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_function_+3A_subclass">subclass</code>, <code id="write_function_+3A_...">...</code></td>
<td>
<p>Class name and fields. Used in class constructors.</p>
</td></tr>
</table>

<hr>
<h2 id='write_stream'>Process output in a streaming manner.</h2><span id='topic+write_stream'></span>

<h3>Description</h3>

<p>This is the most general way of processing the response from the server -
you receive the raw bytes as they come in, and you can do whatever you want
with them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_stream(f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_stream_+3A_f">f</code></td>
<td>
<p>Callback function. It should have a single argument, a raw
vector containing the bytes recieved from the server. This will usually
be 16k or less. The return value of the function is ignored.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>GET(
  "https://github.com/jeroen/data/raw/gh-pages/diamonds.json",
  write_stream(function(x) {
    print(length(x))
    length(x)
  })
)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
