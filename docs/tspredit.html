<!DOCTYPE html><html><head><title>Help for package tspredit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tspredit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fertilizers'><p>Fertilizers (Regression)</p></a></li>
<li><a href='#ts_aug_awareness'><p>Augmentation by awareness</p></a></li>
<li><a href='#ts_aug_awaresmooth'><p>Augmentation by awareness smooth</p></a></li>
<li><a href='#ts_aug_flip'><p>Augmentation by flip</p></a></li>
<li><a href='#ts_aug_jitter'><p>Augmentation by jitter</p></a></li>
<li><a href='#ts_aug_none'><p>no augmentation</p></a></li>
<li><a href='#ts_aug_shrink'><p>Augmentation by shrink</p></a></li>
<li><a href='#ts_aug_stretch'><p>Augmentation by stretch</p></a></li>
<li><a href='#ts_aug_wormhole'><p>Augmentation by wormhole</p></a></li>
<li><a href='#ts_fil_ema'><p>Time Series Exponential Moving Average</p></a></li>
<li><a href='#ts_fil_hp'><p>Hodrick-Prescott Filter</p></a></li>
<li><a href='#ts_fil_kalman'><p>Kalman Filter</p></a></li>
<li><a href='#ts_fil_lowess'><p>Lowess Smoothing</p></a></li>
<li><a href='#ts_fil_ma'><p>Time Series Moving Average</p></a></li>
<li><a href='#ts_fil_none'><p>no filter</p></a></li>
<li><a href='#ts_fil_qes'><p>Quadratic Exponential Smoothing</p></a></li>
<li><a href='#ts_fil_recursive'><p>Recursive Filter</p></a></li>
<li><a href='#ts_fil_seas_adj'><p>Seasonal Adjustment</p></a></li>
<li><a href='#ts_fil_ses'><p>Simple Exponential Smoothing</p></a></li>
<li><a href='#ts_fil_smooth'><p>Time Series Smooth</p></a></li>
<li><a href='#ts_fil_spline'><p>Smoothing Splines</p></a></li>
<li><a href='#ts_fil_winsor'><p>Winsorization of Time Series</p></a></li>
<li><a href='#ts_maintune'><p>Time Series Tune</p></a></li>
<li><a href='#ts_norm_none'><p>no normalization</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Time Series Prediction Integrated Tuning</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.767</td>
</tr>
<tr>
<td>Description:</td>
<td>Prediction is one of the most important activities while working with time series. There are many alternative ways to model the time series. Finding the right one is challenging to model them. Most data-driven models (either statistical or machine learning) demand tuning. Setting them right is mandatory for good predictions. It is even more complex since time series prediction also demands choosing a data pre-processing that complies with the chosen model. Many time series frameworks have features to build and tune models. The package differs as it provides a framework that seamlessly integrates tuning data pre-processing activities with the building of models. The package provides functions for defining and conducting time series prediction, including data pre(post)processing, decomposition, tuning, modeling, prediction, and accuracy assessment. More information is available at Izau et al. &lt;<a href="https://doi.org/10.5753%2Fsbbd.2022.224330">doi:10.5753/sbbd.2022.224330</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/cefet-rj-dal/daltoolbox">https://github.com/cefet-rj-dal/daltoolbox</a>,
<a href="https://cefet-rj-dal.github.io/daltoolbox/">https://cefet-rj-dal.github.io/daltoolbox/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, stats, forecast, mFilter, DescTools, KFAS, daltoolbox</td>
</tr>
<tr>
<td>Config/reticulate:</td>
<td>list( packages = list( list(package = "scipy"),
list(package = "torch"), list(package = "pandas"), list(package
= "numpy"), list(package = "matplotlib"), list(package =
"scikit-learn") ) )</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-25 21:18:37 UTC; gpca</td>
</tr>
<tr>
<td>Author:</td>
<td>Eduardo Ogasawara <a href="https://orcid.org/0000-0002-0466-0626"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ths, cre],
  Cristiane Gea [aut],
  Diogo Santos [aut],
  Rebecca Salles [aut],
  Vitoria Birindiba [aut],
  Carla Pacheco [aut],
  Eduardo Bezerra [aut],
  Esther Pacitti [aut],
  Fabio Porto [aut],
  Federal Center for Technological Education of Rio de Janeiro (CEFET/RJ)
    [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eduardo Ogasawara &lt;eogasawara@ieee.org&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-26 02:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fertilizers'>Fertilizers (Regression)</h2><span id='topic+fertilizers'></span>

<h3>Description</h3>

<p>List of Brazilian fertilizers consumption of N, P2O5, K2O.
</p>

<ul>
<li><p> brazil_n: nitrogen consumption from 1961 to 2020.
</p>
</li>
<li><p> brazil_p2o5: phosphate consumption from 1961 to 2020.
</p>
</li>
<li><p> brazil_k2o: potash consumption from 1961 to 2020.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(fertilizers)
</code></pre>


<h3>Format</h3>

<p>list of fertilizers' time series.
</p>


<h3>Source</h3>

<p>This dataset was obtained from the MASS library.
</p>


<h3>References</h3>

<p>International Fertilizer Association (IFA): http://www.fertilizer.org.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fertilizers)
head(fertilizers$brazil_n)
</code></pre>

<hr>
<h2 id='ts_aug_awareness'>Augmentation by awareness</h2><span id='topic+ts_aug_awareness'></span>

<h3>Description</h3>

<p>Time series data augmentation is a technique used to increase the size and diversity of a time series dataset by creating new instances of the original data through transformations or modifications. The goal is to improve the performance of machine learning models trained on time series data by reducing overfitting and improving generalization.
Awareness reinforce recent data preferably.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_aug_awareness(factor = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_aug_awareness_+3A_factor">factor</code></td>
<td>
<p>increase factor for data augmentation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ts_aug_awareness</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(daltoolbox)
data(sin_data)

#convert to sliding windows
xw &lt;- ts_data(sin_data$y, 10)

#data augmentation using awareness
augment &lt;- ts_aug_awareness()
augment &lt;- fit(augment, xw)
xa &lt;- transform(augment, xw)
ts_head(xa)
</code></pre>

<hr>
<h2 id='ts_aug_awaresmooth'>Augmentation by awareness smooth</h2><span id='topic+ts_aug_awaresmooth'></span>

<h3>Description</h3>

<p>Time series data augmentation is a technique used to increase the size and diversity of a time series dataset by creating new instances of the original data through transformations or modifications. The goal is to improve the performance of machine learning models trained on time series data by reducing overfitting and improving generalization.
Awareness Smooth reinforce recent data preferably. It also smooths noise data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_aug_awaresmooth(factor = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_aug_awaresmooth_+3A_factor">factor</code></td>
<td>
<p>increase factor for data augmentation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ts_aug_awaresmooth</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(daltoolbox)
data(sin_data)

#convert to sliding windows
xw &lt;- ts_data(sin_data$y, 10)

#data augmentation using awareness
augment &lt;- ts_aug_awaresmooth()
augment &lt;- fit(augment, xw)
xa &lt;- transform(augment, xw)
ts_head(xa)
</code></pre>

<hr>
<h2 id='ts_aug_flip'>Augmentation by flip</h2><span id='topic+ts_aug_flip'></span>

<h3>Description</h3>

<p>Time series data augmentation is a technique used to increase the size and diversity of a time series dataset by creating new instances of the original data through transformations or modifications. The goal is to improve the performance of machine learning models trained on time series data by reducing overfitting and improving generalization.
Flip mirror the sliding observations relative to the mean of the sliding windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_aug_flip()
</code></pre>


<h3>Value</h3>

<p>a <code>ts_aug_flip</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(daltoolbox)
data(sin_data)

#convert to sliding windows
xw &lt;- ts_data(sin_data$y, 10)

#data augmentation using flip
augment &lt;- ts_aug_flip()
augment &lt;- fit(augment, xw)
xa &lt;- transform(augment, xw)
ts_head(xa)
</code></pre>

<hr>
<h2 id='ts_aug_jitter'>Augmentation by jitter</h2><span id='topic+ts_aug_jitter'></span>

<h3>Description</h3>

<p>Time series data augmentation is a technique used to increase the size and diversity of a time series dataset by creating new instances of the original data through transformations or modifications. The goal is to improve the performance of machine learning models trained on time series data by reducing overfitting and improving generalization.
jitter adds random noise to each data point in the time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_aug_jitter()
</code></pre>


<h3>Value</h3>

<p>a <code>ts_aug_jitter</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(daltoolbox)
data(sin_data)

#convert to sliding windows
xw &lt;- ts_data(sin_data$y, 10)

#data augmentation using flip
augment &lt;- ts_aug_jitter()
augment &lt;- fit(augment, xw)
xa &lt;- transform(augment, xw)
ts_head(xa)
</code></pre>

<hr>
<h2 id='ts_aug_none'>no augmentation</h2><span id='topic+ts_aug_none'></span>

<h3>Description</h3>

<p>Does not make data augmentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_aug_none()
</code></pre>


<h3>Value</h3>

<p>a <code>ts_aug_none</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(daltoolbox)
data(sin_data)

#convert to sliding windows
xw &lt;- ts_data(sin_data$y, 10)

#no data augmentation
augment &lt;- ts_aug_none()
augment &lt;- fit(augment, xw)
xa &lt;- transform(augment, xw)
ts_head(xa)
</code></pre>

<hr>
<h2 id='ts_aug_shrink'>Augmentation by shrink</h2><span id='topic+ts_aug_shrink'></span>

<h3>Description</h3>

<p>Time series data augmentation is a technique used to increase the size and diversity of a time series dataset by creating new instances of the original data through transformations or modifications. The goal is to improve the performance of machine learning models trained on time series data by reducing overfitting and improving generalization.
stretch does data augmentation by decreasing the volatility of the time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_aug_shrink(scale_factor = 0.8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_aug_shrink_+3A_scale_factor">scale_factor</code></td>
<td>
<p>for shrink</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ts_aug_shrink</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(daltoolbox)
data(sin_data)

#convert to sliding windows
xw &lt;- ts_data(sin_data$y, 10)

#data augmentation using flip
augment &lt;- ts_aug_shrink()
augment &lt;- fit(augment, xw)
xa &lt;- transform(augment, xw)
ts_head(xa)
</code></pre>

<hr>
<h2 id='ts_aug_stretch'>Augmentation by stretch</h2><span id='topic+ts_aug_stretch'></span>

<h3>Description</h3>

<p>Time series data augmentation is a technique used to increase the size and diversity of a time series dataset by creating new instances of the original data through transformations or modifications. The goal is to improve the performance of machine learning models trained on time series data by reducing overfitting and improving generalization.
stretch does data augmentation by increasing the volatility of the time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_aug_stretch(scale_factor = 1.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_aug_stretch_+3A_scale_factor">scale_factor</code></td>
<td>
<p>for stretch</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ts_aug_stretch</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(daltoolbox)
data(sin_data)

#convert to sliding windows
xw &lt;- ts_data(sin_data$y, 10)

#data augmentation using flip
augment &lt;- ts_aug_stretch()
augment &lt;- fit(augment, xw)
xa &lt;- transform(augment, xw)
ts_head(xa)
</code></pre>

<hr>
<h2 id='ts_aug_wormhole'>Augmentation by wormhole</h2><span id='topic+ts_aug_wormhole'></span>

<h3>Description</h3>

<p>Time series data augmentation is a technique used to increase the size and diversity of a time series dataset by creating new instances of the original data through transformations or modifications. The goal is to improve the performance of machine learning models trained on time series data by reducing overfitting and improving generalization.
Wormhole does data augmentation by removing lagged terms and adding old terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_aug_wormhole()
</code></pre>


<h3>Value</h3>

<p>a <code>ts_aug_wormhole</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(daltoolbox)
data(sin_data)

#convert to sliding windows
xw &lt;- ts_data(sin_data$y, 10)

#data augmentation using flip
augment &lt;- ts_aug_wormhole()
augment &lt;- fit(augment, xw)
xa &lt;- transform(augment, xw)
ts_head(xa)
</code></pre>

<hr>
<h2 id='ts_fil_ema'>Time Series Exponential Moving Average</h2><span id='topic+ts_fil_ema'></span>

<h3>Description</h3>

<p>Used to smooth out fluctuations, while giving more weight to
recent observations. Particularly useful when the data has a trend or
seasonality component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_fil_ema(ema = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_fil_ema_+3A_ema">ema</code></td>
<td>
<p>exponential moving average size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ts_fil_ema</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># time series with noise
library(daltoolbox)
data(sin_data)
sin_data$y[9] &lt;- 2*sin_data$y[9]

# filter
filter &lt;- ts_fil_ema(ema = 3)
filter &lt;- fit(filter, sin_data$y)
y &lt;- transform(filter, sin_data$y)

# plot
plot_ts_pred(y=sin_data$y, yadj=y)
</code></pre>

<hr>
<h2 id='ts_fil_hp'>Hodrick-Prescott Filter</h2><span id='topic+ts_fil_hp'></span>

<h3>Description</h3>

<p>This filter eliminates the cyclical component of the series, performs smoothing on it, making it more sensitive to long-term fluctuations. Each observation is decomposed into a cyclical and a growth component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_fil_hp(lambda = 100, preserve = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_fil_hp_+3A_lambda">lambda</code></td>
<td>
<p>It is the smoothing parameter of the Hodrick-Prescott filter.
Lambda = 100*(frequency)^2
Correspondence between frequency and lambda values
annual =&gt; frequency = 1 // lambda = 100
quarterly =&gt; frequency = 4 // lambda = 1600
monthly =&gt; frequency = 12 // lambda = 14400
weekly =&gt; frequency = 52 // lambda = 270400
daily (7 days a week) =&gt; frequency = 365 // lambda = 13322500
daily (5 days a week) =&gt; frequency = 252 // lambda = 6812100</p>
</td></tr>
<tr><td><code id="ts_fil_hp_+3A_preserve">preserve</code></td>
<td>
<p>value between 0 and 1. Balance the composition of observations and applied filter.
Values close to 1 preserve original values. Values close to 0 adopts HP filter values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ts_fil_hp</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># time series with noise
library(daltoolbox)
data(sin_data)
sin_data$y[9] &lt;- 2*sin_data$y[9]

# filter
filter &lt;- ts_fil_hp(lambda = 100*(26)^2)  #frequency assumed to be 26
filter &lt;- fit(filter, sin_data$y)
y &lt;- transform(filter, sin_data$y)

# plot
plot_ts_pred(y=sin_data$y, yadj=y)
</code></pre>

<hr>
<h2 id='ts_fil_kalman'>Kalman Filter</h2><span id='topic+ts_fil_kalman'></span>

<h3>Description</h3>

<p>The Kalman filter is an estimation algorithm that produces estimates of certain variables based on imprecise measurements to provide a prediction of the future state of the system.
It wraps KFAS package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_fil_kalman(H = 0.1, Q = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_fil_kalman_+3A_h">H</code></td>
<td>
<p>variance or covariance matrix of the measurement noise. This noise pertains to the relationship between the true system state and actual observations. Measurement noise is added to the measurement equation to account for uncertainties or errors associated with real observations. The higher this value, the higher the level of uncertainty in the observations.</p>
</td></tr>
<tr><td><code id="ts_fil_kalman_+3A_q">Q</code></td>
<td>
<p>variance or covariance matrix of the process noise. This noise follows a zero-mean Gaussian distribution. It is added to the equation to account for uncertainties or unmodeled disturbances in the state evolution. The higher this value, the greater the uncertainty in the state transition process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ts_fil_kalman</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># time series with noise
library(daltoolbox)
data(sin_data)
sin_data$y[9] &lt;- 2*sin_data$y[9]

# filter
filter &lt;- ts_fil_kalman()
filter &lt;- fit(filter, sin_data$y)
y &lt;- transform(filter, sin_data$y)

# plot
plot_ts_pred(y=sin_data$y, yadj=y)
</code></pre>

<hr>
<h2 id='ts_fil_lowess'>Lowess Smoothing</h2><span id='topic+ts_fil_lowess'></span>

<h3>Description</h3>

<p>It is a smoothing method that preserves the primary trend of the original observations and is used to remove noise and spikes in a way that allows data reconstruction and smoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_fil_lowess(f = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_fil_lowess_+3A_f">f</code></td>
<td>
<p>smoothing parameter. The larger this value, the smoother the series will be.
This provides the proportion of points on the plot that influence the smoothing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ts_fil_lowess</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># time series with noise
library(daltoolbox)
data(sin_data)
sin_data$y[9] &lt;- 2*sin_data$y[9]

# filter
filter &lt;- ts_fil_lowess(f = 0.2)
filter &lt;- fit(filter, sin_data$y)
y &lt;- transform(filter, sin_data$y)

# plot
plot_ts_pred(y=sin_data$y, yadj=y)
</code></pre>

<hr>
<h2 id='ts_fil_ma'>Time Series Moving Average</h2><span id='topic+ts_fil_ma'></span>

<h3>Description</h3>

<p>Used to smooth out fluctuations and reduce noise in a time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_fil_ma(ma = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_fil_ma_+3A_ma">ma</code></td>
<td>
<p>moving average size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ts_fil_ma</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># time series with noise
library(daltoolbox)
data(sin_data)
sin_data$y[9] &lt;- 2*sin_data$y[9]

# filter
filter &lt;- ts_fil_ma(3)
filter &lt;- fit(filter, sin_data$y)
y &lt;- transform(filter, sin_data$y)

# plot
plot_ts_pred(y=sin_data$y, yadj=y)
</code></pre>

<hr>
<h2 id='ts_fil_none'>no filter</h2><span id='topic+ts_fil_none'></span>

<h3>Description</h3>

<p>Does not make data filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_fil_none()
</code></pre>


<h3>Value</h3>

<p>a <code>ts_fil_none</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># time series with noise
library(daltoolbox)
data(sin_data)
sin_data$y[9] &lt;- 2*sin_data$y[9]

# filter
filter &lt;- ts_fil_none()
filter &lt;- fit(filter, sin_data$y)
y &lt;- transform(filter, sin_data$y)

# plot
plot_ts_pred(y=sin_data$y, yadj=y)
</code></pre>

<hr>
<h2 id='ts_fil_qes'>Quadratic Exponential Smoothing</h2><span id='topic+ts_fil_qes'></span>

<h3>Description</h3>

<p>This code implements quadratic exponential smoothing on a time series.
Quadratic exponential smoothing is a smoothing technique that includes components of
both trend and seasonality in time series forecasting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_fil_qes(gamma = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_fil_qes_+3A_gamma">gamma</code></td>
<td>
<p>If TRUE, enables the gamma seasonality component.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ts_fil_qes</code> obj.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># time series with noise
library(daltoolbox)
data(sin_data)
sin_data$y[9] &lt;- 2*sin_data$y[9]

# filter
filter &lt;- ts_fil_qes()
filter &lt;- fit(filter, sin_data$y)
y &lt;- transform(filter, sin_data$y)

# plot
plot_ts_pred(y=sin_data$y, yadj=y)
</code></pre>

<hr>
<h2 id='ts_fil_recursive'>Recursive Filter</h2><span id='topic+ts_fil_recursive'></span>

<h3>Description</h3>

<p>Applies linear filtering to a univariate time series or to each series within a multivariate time series. It is useful for outlier detection, and the calculation is done recursively. This recursive calculation has the effect of reducing autocorrelation among observations, so that for each detected outlier, the filter is recalculated until there are no more outliers in the residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_fil_recursive(filter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_fil_recursive_+3A_filter">filter</code></td>
<td>
<p>smoothing parameter. The larger the value, the greater the smoothing. The smaller the value, the less smoothing, and the resulting series shape is more similar to the original series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ts_fil_recursive</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># time series with noise
library(daltoolbox)
data(sin_data)
sin_data$y[9] &lt;- 2*sin_data$y[9]

# filter
filter &lt;- ts_fil_recursive(filter =  0.05)
filter &lt;- fit(filter, sin_data$y)
y &lt;- transform(filter, sin_data$y)

# plot
plot_ts_pred(y=sin_data$y, yadj=y)
</code></pre>

<hr>
<h2 id='ts_fil_seas_adj'>Seasonal Adjustment</h2><span id='topic+ts_fil_seas_adj'></span>

<h3>Description</h3>

<p>Removes the seasonal component from the time series without affecting the other components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_fil_seas_adj(frequency = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_fil_seas_adj_+3A_frequency">frequency</code></td>
<td>
<p>Frequency of the time series. It is an optional parameter.
It can be configured when the frequency of the time series is known.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ts_fil_seas_adj</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># time series with noise
library(daltoolbox)
data(sin_data)
sin_data$y[9] &lt;- 2*sin_data$y[9]

# filter
filter &lt;- ts_fil_seas_adj(frequency = 26)
filter &lt;- fit(filter, sin_data$y)
y &lt;- transform(filter, sin_data$y)

# plot
plot_ts_pred(y=sin_data$y, yadj=y)
</code></pre>

<hr>
<h2 id='ts_fil_ses'>Simple Exponential Smoothing</h2><span id='topic+ts_fil_ses'></span>

<h3>Description</h3>

<p>This code implements simple exponential smoothing on a time series.
Simple exponential smoothing is a smoothing technique that can include or exclude
trend and seasonality components in time series forecasting, depending on the specified parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_fil_ses(gamma = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_fil_ses_+3A_gamma">gamma</code></td>
<td>
<p>If TRUE, enables the gamma seasonality component.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ts_fil_ses</code> obj.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># time series with noise
library(daltoolbox)
data(sin_data)
sin_data$y[9] &lt;- 2*sin_data$y[9]

# filter
filter &lt;- ts_fil_ses()
filter &lt;- fit(filter, sin_data$y)
y &lt;- transform(filter, sin_data$y)

# plot
plot_ts_pred(y=sin_data$y, yadj=y)
</code></pre>

<hr>
<h2 id='ts_fil_smooth'>Time Series Smooth</h2><span id='topic+ts_fil_smooth'></span>

<h3>Description</h3>

<p>Used to remove or reduce randomness (noise).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_fil_smooth()
</code></pre>


<h3>Value</h3>

<p>a <code>ts_fil_smooth</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># time series with noise
library(daltoolbox)
data(sin_data)
sin_data$y[9] &lt;- 2*sin_data$y[9]

# filter
filter &lt;- ts_fil_smooth()
filter &lt;- fit(filter, sin_data$y)
y &lt;- transform(filter, sin_data$y)

# plot
plot_ts_pred(y=sin_data$y, yadj=y)
</code></pre>

<hr>
<h2 id='ts_fil_spline'>Smoothing Splines</h2><span id='topic+ts_fil_spline'></span>

<h3>Description</h3>

<p>Fits a cubic smoothing spline to a time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_fil_spline(spar = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_fil_spline_+3A_spar">spar</code></td>
<td>
<p>smoothing parameter. When spar is specified, the coefficient
of the integral of the squared second derivative in the fitting criterion (penalized log-likelihood)
is a monotone function of spar.
#'@return a <code>ts_fil_spline</code> object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># time series with noise
library(daltoolbox)
data(sin_data)
sin_data$y[9] &lt;- 2*sin_data$y[9]

# filter
filter &lt;- ts_fil_spline(spar = 0.5)
filter &lt;- fit(filter, sin_data$y)
y &lt;- transform(filter, sin_data$y)

# plot
plot_ts_pred(y=sin_data$y, yadj=y)
</code></pre>

<hr>
<h2 id='ts_fil_winsor'>Winsorization of Time Series</h2><span id='topic+ts_fil_winsor'></span>

<h3>Description</h3>

<p>This code implements the Winsorization technique on a time series.
Winsorization is a statistical method used to handle extreme values in a time series
by replacing them with values closer to the center of the distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_fil_winsor(li = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_fil_winsor_+3A_li">li</code></td>
<td>
<p>Defines the Winsorization limit (proportion of values to be trimmed)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ts_fil_winsor</code> obj.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># time series with noise
library(daltoolbox)
data(sin_data)
sin_data$y[9] &lt;- 2*sin_data$y[9]

# filter
filter &lt;- ts_fil_winsor()
filter &lt;- fit(filter, sin_data$y)
y &lt;- transform(filter, sin_data$y)

# plot
plot_ts_pred(y=sin_data$y, yadj=y)
</code></pre>

<hr>
<h2 id='ts_maintune'>Time Series Tune</h2><span id='topic+ts_maintune'></span>

<h3>Description</h3>

<p>Time Series Tune
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_maintune(
  input_size,
  base_model,
  folds = 10,
  preprocess = list(daltoolbox::ts_norm_gminmax()),
  augment = list(ts_aug_none())
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_maintune_+3A_input_size">input_size</code></td>
<td>
<p>input size for machine learning model</p>
</td></tr>
<tr><td><code id="ts_maintune_+3A_base_model">base_model</code></td>
<td>
<p>base model for tuning</p>
</td></tr>
<tr><td><code id="ts_maintune_+3A_folds">folds</code></td>
<td>
<p>number of folds for cross-validation</p>
</td></tr>
<tr><td><code id="ts_maintune_+3A_preprocess">preprocess</code></td>
<td>
<p>list of preprocessing methods</p>
</td></tr>
<tr><td><code id="ts_maintune_+3A_augment">augment</code></td>
<td>
<p>data augmentation method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ts_maintune</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(daltoolbox)
data(sin_data)
ts &lt;- ts_data(sin_data$y, 10)

samp &lt;- ts_sample(ts, test_size = 5)
io_train &lt;- ts_projection(samp$train)
io_test &lt;- ts_projection(samp$test)

tune &lt;- ts_maintune(input_size=c(3:5), base_model = ts_elm(), preprocess = list(ts_norm_gminmax()))
ranges &lt;- list(nhid = 1:5, actfun=c('purelin'))

# Generic model tunning
model &lt;- fit(tune, x=io_train$input, y=io_train$output, ranges)

prediction &lt;- predict(model, x=io_test$input[1,], steps_ahead=5)
prediction &lt;- as.vector(prediction)
output &lt;- as.vector(io_test$output)

ev_test &lt;- evaluate(model, output, prediction)
ev_test
</code></pre>

<hr>
<h2 id='ts_norm_none'>no normalization</h2><span id='topic+ts_norm_none'></span>

<h3>Description</h3>

<p>Does not make data normalization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_norm_none()
</code></pre>


<h3>Value</h3>

<p>a <code>ts_norm_none</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(daltoolbox)
data(sin_data)

#convert to sliding windows
xw &lt;- ts_data(sin_data$y, 10)

#no data normalization
normalize &lt;- ts_norm_none()
normalize &lt;- fit(normalize, xw)
xa &lt;- transform(normalize, xw)
ts_head(xa)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
