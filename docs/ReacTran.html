<!DOCTYPE html><html><head><title>Help for package ReacTran</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ReacTran}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#advection.1D'>
<p>One-Dimensional Advection Equation</p></a></li>
<li><a href='#fiadeiro'>
<p>Advective Finite Difference Weights</p></a></li>
<li><a href='#g.sphere'>
<p>Surface Area and Volume of Geometrical Objects</p></a></li>
<li><a href='#p.exp'>
<p>Common Properties with Distance, to be used with setup.prop.1D</p></a></li>
<li><a href='#ReacTran-package'><p>Reactive transport modelling in 1D, 2D and 3D</p></a></li>
<li><a href='#setup.compaction.1D'>
<p>Calculates Advective Velocities of the Pore Water and Solid Phase</p>
in a Water Saturated Sediment assuming Steady State Compaction</a></li>
<li><a href='#setup.grid.1D'>
<p>Creates a One-Dimensional Finite Difference Grid</p></a></li>
<li><a href='#setup.grid.2D'>
<p>Creates a Finite Difference Grid over a Two-Dimensional Rectangular Domain</p></a></li>
<li><a href='#setup.prop.1D'>
<p>Attaches a Property to a One-Dimensional Grid</p></a></li>
<li><a href='#setup.prop.2D'>
<p>Attaches a Property to a Two-Dimensional Grid</p></a></li>
<li><a href='#tran.1D'>
<p>General One-Dimensional Advective-Diffusive Transport</p></a></li>
<li><a href='#tran.2D'>
<p>General Two-Dimensional Advective-Diffusive Transport</p></a></li>
<li><a href='#tran.3D'>
<p>General Three-Dimensional Advective-Diffusive Transport</p></a></li>
<li><a href='#tran.cylindrical'>
<p>Diffusive Transport in cylindrical (r, theta, z) and spherical (r, theta, phi)</p>
coordinates.</a></li>
<li><a href='#tran.polar'>
<p>Diffusive Transport in polar (r, theta) coordinates.</p></a></li>
<li><a href='#tran.volume.1D'>
<p>1-D, 2-D and 3-D Volumetric Advective-Diffusive Transport in an Aquatic System</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.4.3.1</td>
</tr>
<tr>
<td>Title:</td>
<td>Reactive Transport Modelling in 1d, 2d and 3d</td>
</tr>
<tr>
<td>Author:</td>
<td>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;,
  Filip Meysman &lt;filip.meysman@nioz.nl&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), rootSolve, deSolve, shape</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics</td>
</tr>
<tr>
<td>Description:</td>
<td>Routines for developing models that describe reaction and advective-diffusive transport in one, two or three dimensions.
  Includes transport routines in porous media, in estuaries, and in bodies with variable shape.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Repository/R-Forge/Project:</td>
<td>reactran</td>
</tr>
<tr>
<td>Repository/R-Forge/Revision:</td>
<td>100</td>
</tr>
<tr>
<td>Repository/R-Forge/DateTimeStamp:</td>
<td>2017-08-15 06:57:39</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-08-15 22:13:03 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-08-15 07:20:26 UTC; rforge</td>
</tr>
</table>
<hr>
<h2 id='advection.1D'>
One-Dimensional Advection Equation
</h2><span id='topic+advection.1D'></span><span id='topic+advection.volume.1D'></span>

<h3>Description</h3>

<p>Estimates the advection term in a one-dimensional model of a
liquid (volume fraction constant and equal to one) or in a porous medium
(volume fraction variable and lower than one).
</p>
<p>The interfaces between grid cells can have a variable cross-sectional area,
e.g. when modelling spherical or cylindrical geometries (see example).
</p>
<p>TVD (total variation diminishing) slope limiters ensure monotonic and 
positive schemes in the presence of strong gradients. 
</p>
<p><code>advection.1-D</code>: uses finite differences.
</p>
<p>This implies the use of velocity (length per time) and fluxes 
(mass per unit of area per unit of time). 
</p>
<p><code>advection.volume.1D</code>
Estimates the volumetric advection term in a one-dimensional model 
of an aquatic system (river, estuary). This routine is particularly 
suited for modelling channels (like rivers, estuaries) where the 
cross-sectional area changes, and hence the velocity changes. 
</p>
<p>Volumetric transport implies the use of flows (mass per unit of time). 
</p>
<p>When solved dynamically, the euler method should be used, unless the
first-order upstream method is used.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>advection.1D(C, C.up = NULL, C.down = NULL,
  flux.up = NULL, flux.down = NULL, v, VF = 1, A = 1, dx, 
  dt.default = 1, adv.method = c("muscl", "super", "quick", "p3", "up"),
  full.check = FALSE)

advection.volume.1D(C, C.up = C[1], C.down = C[length(C)],
  F.up = NULL, F.down = NULL, flow, V, 
  dt.default = 1, adv.method = c("muscl", "super", "quick", "p3", "up"),
  full.check = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="advection.1D_+3A_c">C</code></td>
<td>
<p>concentration, expressed per unit of phase volume, defined at the
centre of each grid cell. A vector of length N [M/L3].
</p>
</td></tr>
<tr><td><code id="advection.1D_+3A_c.up">C.up</code></td>
<td>
<p>concentration at upstream boundary. One value [M/L3]. If <code>NULL</code>,
and <code>flux.up</code> is also <code>NULL</code>, then a zero-gradient boundary 
is assumed, i.e. <code>C.up = C[1]</code>.
</p>
</td></tr>
<tr><td><code id="advection.1D_+3A_c.down">C.down</code></td>
<td>
<p>concentration at downstream boundary. One value [M/L3]. If <code>NULL</code>,
and <code>flux.down</code> is also <code>NULL</code>, then a zero-gradient boundary 
is assumed, i.e. <code>C.down = C[length(C)]</code>.
</p>
</td></tr>
<tr><td><code id="advection.1D_+3A_flux.up">flux.up</code></td>
<td>
<p>flux across the upstream boundary, positive = INTO model
domain. One value, expressed per unit of total surface [M/L2/T]. 
If <code>NULL</code>, the boundary is prescribed as
a concentration boundary.
</p>
</td></tr>
<tr><td><code id="advection.1D_+3A_flux.down">flux.down</code></td>
<td>
<p>flux across the downstream boundary, positive = OUT
of model domain. One value, expressed per unit of total surface [M/L2/T].
If <code>NULL</code>, the boundary is prescribed as
a concentration boundary.
</p>
</td></tr>
<tr><td><code id="advection.1D_+3A_f.up">F.up</code></td>
<td>
<p>total input across the upstream boundary, positive = INTO model
domain; used with <code>advection.volume.1D</code>. 
One value, expressed in [M/T]. 
If <code>NULL</code>, the boundary is prescribed as
a concentration boundary.
</p>
</td></tr>
<tr><td><code id="advection.1D_+3A_f.down">F.down</code></td>
<td>
<p>total input across the downstream boundary, positive = OUT
of model domain; used with <code>advection.volume.1D</code>. 
One value, expressed in [M/T].
If <code>NULL</code>, the boundary is prescribed as
a concentration boundary.
</p>
</td></tr>
<tr><td><code id="advection.1D_+3A_v">v</code></td>
<td>
<p>advective velocity, defined on the grid cell
interfaces. Can be positive (downstream flow) or negative (upstream flow).
One value, a vector of length N+1 [L/T], or a <code>1D property</code> list; the list
contains at least the element <code>int</code> (see <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>)
[L/T]. Used with <code>advection.1D</code>.
</p>
</td></tr>
<tr><td><code id="advection.1D_+3A_flow">flow</code></td>
<td>
<p>water flow rate, defined on grid cell interfaces. 
One value, a vector of length N+1, or a list as defined by 
<code>setup.prop.1D</code> [L^3/T]. 
Used with <code>advection.volume.1D</code>.
</p>
</td></tr>
<tr><td><code id="advection.1D_+3A_vf">VF</code></td>
<td>
<p>Volume fraction defined at the grid cell interfaces. One value,
a vector of length N+1, or a <code>1D property</code> list; the list
contains at least the elements <code>int</code> and <code>mid</code>
(see <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>) [-].
</p>
</td></tr>
<tr><td><code id="advection.1D_+3A_a">A</code></td>
<td>
<p>Interface area defined at the grid cell interfaces. One value,
a vector of length N+1, or a <code>1D grid property</code> list; the list
contains at least the elements <code>int</code> and <code>mid</code>
(see <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>) [L^2].
</p>
</td></tr>
<tr><td><code id="advection.1D_+3A_dx">dx</code></td>
<td>
<p>distance between adjacent cell interfaces (thickness of grid
cells). One value, a vector of length N, or a <code>1D grid</code> list containing
at least the elements
<code>dx</code> and <code>dx.aux</code> (see <code><a href="#topic+setup.grid.1D">setup.grid.1D</a></code>) [L].
</p>
</td></tr>
<tr><td><code id="advection.1D_+3A_dt.default">dt.default</code></td>
<td>
<p>timestep to be used, if it cannot be estimated (e.g.
when calculating steady-state conditions.
</p>
</td></tr>
<tr><td><code id="advection.1D_+3A_v">V</code></td>
<td>
<p>volume of cells. One value, or a vector of length N [L^3].
</p>
</td></tr>
<tr><td><code id="advection.1D_+3A_adv.method">adv.method</code></td>
<td>
<p>the advection method, slope limiter used to reduce the 
numerical dispersion. One of &quot;quick&quot;,&quot;muscl&quot;,&quot;super&quot;,&quot;p3&quot;,&quot;up&quot; - see details.
</p>
</td></tr>
<tr><td><code id="advection.1D_+3A_full.check">full.check</code></td>
<td>
<p>logical flag enabling a full check of the consistency
of the arguments (default = <code>FALSE</code>; <code>TRUE</code> slows down execution
by 50 percent).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation is based on the GOTM code
</p>
<p>The <b>boundary conditions</b> are either
</p>

<ul>
<li><p> zero-gradient.
</p>
</li>
<li><p> fixed concentration.
</p>
</li>
<li><p> fixed flux.
</p>
</li></ul>

<p>The above order also shows the priority. The default condition is the
zero gradient. The fixed concentration condition overrules the zero gradient.
The fixed flux overrules the other specifications.
</p>
<p>Ensure that the boundary conditions are well defined: for instance, it 
does not make sense to specify an influx in a boundary cell with the advection
velocity pointing outward.
</p>
<p><b>Transport properties:</b>
</p>
<p>The <em>advective velocity</em> (<code>v</code>),
the <em>volume fraction</em> (VF), and the <em>interface surface</em> (<code>A</code>),
can either be specified as one value, a vector, or a 1D property list
as generated by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>.
</p>
<p>When a vector, this vector must be of length N+1, defined at all grid
cell interfaces, including the upper and lower boundary.
</p>
<p>The <b>finite difference grid</b> (<code>dx</code>) is specified either as
one value, a vector or a 1D grid list, as generated by <code><a href="#topic+setup.grid.1D">setup.grid.1D</a></code>. 
</p>
<p>Several slope limiters are implemented to obtain monotonic and positive 
schemes also in the presence of strong gradients, i.e. to reduce the effect
of numerical dispersion. The methods are (Pietrzak, 1989, Hundsdorfer and 
Verwer, 2003):
</p>

<ul>
<li><p> &quot;quick&quot;: third-order scheme (TVD) with ULTIMATE QUICKEST limiter 
(quadratic upstream interpolation for convective kinematics with 
estimated stream terms) (Leonard, 1988)
</p>
</li>
<li><p> &quot;muscl&quot;: third-order scheme (TVD) with MUSCL limiter (monotonic upstream 
centered schemes for conservation laws) (van Leer, 1979).
</p>
</li>
<li><p> &quot;super&quot;: third-order scheme (TVD) with Superbee limiter (method=Superbee)
(Roe, 1985)
</p>
</li>
<li><p> &quot;p3&quot;: third-order upstream-biased polynomial scheme (method=P3)
</p>
</li>
<li><p> &quot;up&quot;: first-order upstream ( method=UPSTREAM) - this is the same
method as implemented in <a href="#topic+tran.1D">tran.1D</a> or <a href="#topic+tran.volume.1D">tran.volume.1D</a>
</p>
</li></ul>

<p>where &quot;TVD&quot; means a total variation diminishing scheme
</p>
<p>Some schemes may produce artificial steepening. Scheme &quot;p3&quot; is not necessarily
monotone (may produce negative concentrations!).
</p>
<p>If during a certain time step the maximum Courant number is larger
than one, a split iteration will be carried out which guarantees that the
split step Courant numbers are just smaller than 1. The maximal number of such
iterations is set to 100.
</p>
<p>These limiters are supposed to work with explicit methods (<a href="deSolve.html#topic+euler">euler</a>). However, 
they will also work with implicit methods, although less effectively.
Integrate <a href="deSolve.html#topic+ode.1D">ode.1D</a> only if the model is stiff (see first example).
</p>


<h3>Value</h3>

<table>
<tr><td><code>dC</code></td>
<td>
<p>the rate of change of the concentration C due to advective 
transport, defined in the centre of each grid cell. 
The rate of change is expressed per unit of (phase) volume [M/L^3/T].
</p>
</td></tr>
<tr><td><code>adv.flux</code></td>
<td>
<p>advective flux across at the interface of each grid cell.
A vector of length N+1 [M/L2/T] - only for <code>advection.1D</code>.
</p>
</td></tr>
<tr><td><code>flux.up</code></td>
<td>
<p>flux across the upstream boundary, positive = INTO model
domain. One value [M/L2/T] - only for <code>advection.1D</code>.
</p>
</td></tr>
<tr><td><code>flux.down</code></td>
<td>
<p>flux across the downstream boundary, positive = OUT of
model domain. One value [M/L2/T] - only for <code>advection.1D</code>.
</p>
</td></tr>
<tr><td><code>adv.F</code></td>
<td>
<p>advective mass flow across at the interface of each grid cell.
A vector of length N+1 [M/T] - only for <code>advection.volume.1D</code>.
</p>
</td></tr>
<tr><td><code>F.up</code></td>
<td>
<p>mass flow across the upstream boundary, positive = INTO model
domain. One value [M/T] - only for <code>advection.volume.1D</code>.
</p>
</td></tr>
<tr><td><code>F.down</code></td>
<td>
<p>flux across the downstream boundary, positive = OUT of
model domain. One value [M/T] - only for <code>advection.volume.1D</code>.
</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>number of split time iterations that were necessary.
</p>
</td></tr>  
</table>


<h3>Note</h3>

 
<p>The advective equation is not checked for mass conservation. Sometimes, this is 
not an issue, for instance when <code>v</code> represents a sinking velocity of 
particles or a swimming velocity of organisms. 
</p>
<p>In others cases however, mass conservation needs to be accounted for. 
</p>
<p>To ensure mass conservation, the advective velocity must obey certain 
continuity constraints: in essence the product of the volume fraction (VF), 
interface surface area (A) and advective velocity (v) should be constant. 
In sediments, one can use <code><a href="#topic+setup.compaction.1D">setup.compaction.1D</a></code> to ensure that 
the advective velocities for the pore water and solid phase meet these 
constraints. 
</p>
<p>In terms of the units of concentrations and fluxes we follow the convention 
in the geosciences. 
The concentration <code>C</code>, <code>C.up</code>, <code>C.down</code> as well at the rate of 
change of the concentration <code>dC</code> are always expressed per unit of 
phase volume (i.e. per unit volume of solid or liquid). 
</p>
<p>Total concentrations (e.g. per unit volume of bulk sediment) can be obtained by 
multiplication with the appropriate volume fraction. In contrast, fluxes are 
always expressed per unit of total interface area (so here the volume fraction 
is accounted for).     
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>Pietrzak J (1998) The use of TVD limiters for forward-in-time
upstream-biased advection schemes in ocean modeling. Monthly
Weather Review 126: 812 .. 830
</p>
<p>Hundsdorfer W and Verwer JG (2003)
Numerical Solution of Time-Dependent Advection-Diffusion-Reaction Equations. 
Springer Series in Computational Mathematics, Springer-Verlag, Berlin, 471 pages
</p>
<p>Burchard H, Bolding K, Villarreal MR (1999) GOTM, a general
ocean turbulence model. Theory, applications and test cases.
Tech Rep EUR 18745 EN. European Commission  
</p>
<p>Leonard BP (1988) Simple high accuracy resolution program for convective modeling
of discontinuities. Int. J. Numer. Meth.Fluids 8: 1291&ndash;1318.
</p>
<p>Roe PL (1985) Some contributions to the modeling of discontinuous flows.
Lect. Notes Appl. Math. 22: 163-193.
</p>
<p>van Leer B. (1979) Towards the ultimate conservative difference scheme V. A second 
order sequel to Godunov's method. J. Comput. Phys. 32: 101-136
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tran.1D">tran.1D</a></code>, for a discretisation of the general transport equations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## =============================================================================
## EXAMPLE 1: Testing the various methods - moving a square pulse  
## use of advection.1D
## The tests as in Pietrzak 
## =============================================================================

#--------------------#
# Model formulation  #
#--------------------#
model &lt;- function (t, y, parms,...) {

  adv &lt;- advection.1D(y, v = v, dx = dx, 
     C.up = y[n], C.down = y[1], ...)  # out on one side -&gt; in at other
  return(list(adv$dC))

}

#--------------------#
# Parameters         #
#--------------------#

n     &lt;- 100
dx    &lt;- 100/n
y     &lt;- c(rep(1, 5), rep(2, 20), rep(1, n-25))
v     &lt;- 2 
times &lt;- 0:300   # 3 times out and in

#--------------------#
# model solution     #
#--------------------#

## a plotting function
plotfun &lt;- function (Out, ...) {
  plot(Out[1, -1], type = "l", col = "red", ylab = "y", xlab = "x", ...)
  lines(Out[nrow(Out), 2:(1+n)])
}

# courant number = 2
pm   &lt;- par(mfrow = c(2, 2))

## third order TVD, quickest limiter
out &lt;- ode.1D(y = y, times = times, func = model, parms = 0, hini = 1,
              method = "euler", nspec = 1, adv.method = "quick")

plotfun(out, main = "quickest, euler") 

## third-order ustream-biased polynomial
out2 &lt;- ode.1D(y = y, times = times, func = model, parms = 0, hini = 1,
              method = "euler", nspec = 1, adv.method = "p3")

plotfun(out2, main = "p3, euler")

## third order TVD, superbee limiter
out3 &lt;- ode.1D(y = y, times = times, func = model, parms = 0, hini = 1,
              method = "euler", nspec = 1, adv.method = "super")

plotfun(out3, main = "superbee, euler")

## third order TVD, muscl limiter
out4 &lt;- ode.1D(y = y, times = times, func = model, parms = 0, hini = 1,
              method = "euler", nspec = 1, adv.method = "muscl")

plotfun(out4, main = "muscl, euler")

## =============================================================================
## upstream, different time-steps , i.e. different courant number
## =============================================================================
out &lt;- ode.1D(y = y, times = times, func = model, parms = 0, 
              method = "euler", nspec = 1, adv.method = "up")

plotfun(out, main = "upstream, courant number = 2")

out2 &lt;- ode.1D(y = y, times = times, func = model, parms = 0, hini = 0.5,  
               method = "euler", nspec = 1, adv.method = "up")
plotfun(out2, main = "upstream, courant number = 1")


## Now muscl scheme, velocity against x-axis
y     &lt;- rev(c(rep(0, 5), rep(1, 20), rep(0, n-25)))
v     &lt;- -2.0
out6 &lt;- ode.1D(y = y, times = times, func = model, parms = 0, hini = 1,
               method = "euler", nspec = 1, adv.method = "muscl")

plotfun(out6, main = "muscl, reversed velocity, , courant number = 1")

image(out6, mfrow = NULL)
par(mfrow = pm)


## =============================================================================
## EXAMPLE 2: moving a square pulse in a widening river  
## use of advection.volume.1D
## =============================================================================

#--------------------#
# Model formulation  #
#--------------------#

river.model &lt;- function (t=0, C, pars = NULL, ...)  {

 tran &lt;- advection.volume.1D(C = C, C.up = 0,
                     flow = flow, V = Volume,...)
 return(list(dCdt = tran$dC, F.down = tran$F.down, F.up = tran$F.up))
}

#--------------------#
# Parameters         #
#--------------------#

# Initialising morphology river:

nbox          &lt;- 100                # number of grid cells
lengthRiver   &lt;- 100000             # [m]
BoxLength     &lt;- lengthRiver / nbox # [m]

Distance      &lt;- seq(BoxLength/2, by = BoxLength, len = nbox)   # [m]

# Cross sectional area: sigmoid function of distance [m2]
CrossArea &lt;- 4000 + 72000 * Distance^5 /(Distance^5+50000^5)

# Volume of boxes                          (m3)
Volume    &lt;- CrossArea*BoxLength

# Transport coefficients
flow      &lt;- 1000*24*3600   # m3/d, main river upstream inflow

#--------------------#
# Model solution     #
#--------------------#

pm   &lt;- par(mfrow=c(2,2))

# a square pulse
yini &lt;-  c(rep(10, 10), rep(0, nbox-10))

## third order TVD, muscl limiter
Conc &lt;- ode.1D(y = yini, fun = river.model,  method = "euler", hini = 1,
              parms = NULL, nspec = 1, times = 0:40, adv.method = "muscl")

image(Conc, main = "muscl", mfrow = NULL)
plot(Conc[30, 2:(1+nbox)], type = "l", lwd = 2, xlab = "x", ylab = "C", 
     main = "muscl after 30 days")

## simple upstream differencing
Conc2&lt;- ode.1D(y = yini, fun = river.model, method = "euler", hini = 1,
              parms = NULL, nspec = 1, times = 0:40, adv.method = "up")

image(Conc2, main = "upstream", mfrow = NULL)
plot(Conc2[30, 2:(1+nbox)], type = "l", lwd = 2, xlab = "x", ylab = "C", 
     main = "upstream after 30 days")

par(mfrow = pm)


# Note: the more sophisticated the scheme, the more mass lost/created
# increase tolerances to improve this.

CC &lt;- Conc[ , 2:(1+nbox)]
MASS &lt;- t(CC)*Volume     
colSums(MASS)

## =============================================================================
## EXAMPLE 3: A steady-state solution 
## use of advection.volume.1D
## =============================================================================

Sink &lt;- function (t, y, parms, ...) {
  C1 &lt;- y[1:N]
  C2 &lt;- y[(N+1):(2*N)]
  C3 &lt;- y[(2*N+1):(3*N)]
  # Rate of change= Flux gradient and first-order consumption                  
  
  # upstream can be implemented in two ways:
 
  dC1  &lt;- advection.1D(C1, v = sink, dx = dx, 
           C.up = 100, adv.method = "up", ...)$dC - decay*C1

# same, using tran.1D  
#  dC1  &lt;- tran.1D(C1, v = sink, dx = dx, 
#        C.up = 100, D = 0)$dC -
#           decay*C1

  dC2  &lt;- advection.1D(C2, v = sink, dx = dx, 
        C.up = 100, adv.method = "p3", ...)$dC -
           decay*C2

  dC3  &lt;- advection.1D(C3, v = sink, dx = dx, 
        C.up = 100, adv.method = "muscl", ...)$dC -
           decay*C3

  list(c(dC1, dC2, dC3))
}

N     &lt;- 10
L     &lt;- 1000
dx    &lt;- L/N                          # thickness of boxes
sink  &lt;- 10
decay &lt;- 0.1
out &lt;- steady.1D(runif(3*N), func = Sink, names = c("C1", "C2", "C3"),
        parms = NULL, nspec = 3, bandwidth = 2)
matplot(out$y, 1:N, type = "l", ylim = c(10, 0), lwd = 2, 
  main = "Steady-state")          
legend("bottomright", col = 1:3, lty = 1:3, 
  c("upstream", "p3", "muscl"))


</code></pre>

<hr>
<h2 id='fiadeiro'>
Advective Finite Difference Weights
</h2><span id='topic+fiadeiro'></span>

<h3>Description</h3>

<p>Weighing coefficients used in the finite difference scheme for advection
calculated according to Fiadeiro and Veronis (1977).
</p>
<p>This particular AFDW (advective finite difference weights) scheme switches
from backward differencing (in advection dominated conditions; large Peclet
numbers) to central differencing (under diffusion dominated conditions;
small Peclet numbers).
</p>
<p>This way it forms a compromise between stability, accuracy and reduced
numerical dispersion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fiadeiro(v, D, dx.aux = NULL, grid = list(dx.aux = dx.aux))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fiadeiro_+3A_v">v</code></td>
<td>
<p>advective velocity; either one value or a vector of length N+1,
with N the number of grid cells [L/T]
</p>
</td></tr>
<tr><td><code id="fiadeiro_+3A_d">D</code></td>
<td>
<p>diffusion coefficient; either one value or a vector of length N+1
[L2/T]
</p>
</td></tr>
<tr><td><code id="fiadeiro_+3A_dx.aux">dx.aux</code></td>
<td>
<p>auxiliary vector containing the distances between the
locations where the concentration is defined (i.e. the grid cell centers
and the two outer interfaces);
either one value or a vector of length N+1 [L]
</p>
</td></tr>
<tr><td><code id="fiadeiro_+3A_grid">grid</code></td>
<td>
<p>discretization grid as calculated by <code><a href="#topic+setup.grid.1D">setup.grid.1D</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Fiadeiro and Veronis (1977) scheme adapts the differencing method to
the local situation (checks for advection or diffusion dominance).
</p>
<p>Finite difference schemes are based on following rationale:
</p>

<ul>
<li><p> When using forward differences (AFDW = 0), the scheme is first
order accurate, creates a low level of (artificial) numerical dispersion,
but is highly unstable (state variables may become negative).
</p>
</li>
<li><p> When using backward differences (AFDW = 1), the scheme is first
order accurate, is universally stable (state variables always remain
positive), but the scheme creates high levels of numerical dispersion.
</p>
</li>
<li><p> When using central differences (AFDW = 0.5), the scheme is second
order accurate, is not universally stable, and has a moderate level of
numerical dispersion, but state variables may become negative.
</p>
</li></ul>

<p>Because of the instability issue, forward schemes should be avoided.
Because of the higher accuracy, the central scheme is preferred over the
backward scheme.
</p>
<p>The central scheme is stable when sufficient physical dispersion is present,
it may become unstable when advection is the only transport process.
</p>
<p>The Fiadeiro and Veronis (1977) scheme takes this into account: it uses
central differencing when possible (when physical dispersion is high enough),
and switches to backward differing when needed (when advection dominates).
The switching is determined by the Peclet number
</p>
<p><code>Pe = abs(v)*dx.aux/D</code>
</p>

<ul>
<li><p> the higher the diffusion <code>D</code> (<code>Pe &gt; 1</code>), the closer the
AFDW coefficients are to 0.5 (central differencing)
</p>
</li>
<li><p> the higher the advection <code>v</code> (<code>Pe &lt; 1</code>), the closer the
AFDW coefficients are to 1 (backward differencing)
</p>
</li></ul>



<h3>Value</h3>

<p>the Advective Finite Difference Weighing (AFDW) coefficients as used in 
the transport routines <code><a href="#topic+tran.1D">tran.1D</a></code> and <code><a href="#topic+tran.volume.1D">tran.volume.1D</a></code>;
either one value or a vector of length N+1 [-]
</p>


<h3>Note</h3>


<ul>
<li><p> If the state variables (concentrations) decline in the direction
of the 1D axis, then the central difference scheme will be stable.
If this is known a prioiri, then central differencing is
preferred over the fiadeiro scheme.
</p>
</li>
<li><p> Each scheme will always create some numerical diffusion. This
principally depends on the resolution of the grid (i.e. larger 
<code>dx.aux</code> values create higher numerical diffusion). In order to reduce numerical dispersion, one should
increase the grid resolution (i.e. decrease <code>dx.aux</code>).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Filip Meysman &lt;filip.meysman@nioz.nl&gt;,
</p>
<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>


<ul>
<li><p> Fiadeiro ME and Veronis G (1977) Weighted-mean schemes for
finite-difference approximation to advection-diffusion equation.
Tellus 29, 512-522.
</p>
</li>
<li><p> Boudreau (1997) Diagnetic models and their implementation.
Chapter 8: Numerical Methods. Springer.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#============================================
# Model formulation (differential equations)
#============================================

# This is a test model to evaluate the different finite difference schemes 
# and evaluate their effect on munerical diffusion. The model describes the
# decay of organic carbon (OC) as it settles through the ocean water column.

model &lt;- function (time, OC, pars, AFDW = 1) {
  dOC &lt;- tran.1D(OC, flux.up = F_OC, D = D.eddy, 
                 v = v.sink, AFDW = AFDW, dx = dx)$dC - k*OC
  return(list(dOC))
}
#============================================
# Parameter set
#============================================

L &lt;- 1000         # water depth model domain [m]
x.att &lt;- 200      # attenuation depth of the sinking velocity [m]
v.sink.0 &lt;- 10    # sinking velocity at the surface [m d-1]
D.eddy &lt;- 10      # eddy diffusion coefficient [m2 d-1]
F_OC &lt;- 10        # particle flux [mol m-2 d-1]
k &lt;- 0.1          # decay coefficient [d-1]

## =============================================================================
## Model solution for a coarse grid (10 grid cells)
## =============================================================================

# Setting up the grid
N &lt;- 10                               # number of grid layers 
dx &lt;- L/N                             # thickness of boxes [m]
dx.aux &lt;- rep(dx, N+1)                # auxilliary grid vector
x.int &lt;- seq(from = 0, to = L, by = dx)    # water depth at box interfaces [m]
x.mid &lt;- seq(from = dx/2, to = L, by = dx) # water depth at box centres [m]

# Exponentially declining sink velocity
v.sink &lt;- v.sink.0 * exp(-x.int/x.att) # sink velocity [m d-1]
Pe &lt;- v.sink * dx/D.eddy               # Peclet number

# Calculate the weighing coefficients
AFDW &lt;- fiadeiro(v = v.sink, D = D.eddy, dx.aux = dx.aux)

par(mfrow = c(2, 1), cex.main = 1.2, cex.lab = 1.2)

# Plot the Peclet number over the grid 

plot(Pe, x.int, log = "x", pch = 19, ylim = c(L,0), xlim = c(0.1, 1000), 
     xlab = "", ylab = "depth [m]", 
     main = "Peclet number", axes = FALSE)
abline(h = 0)
axis(pos = NA, side = 2)
axis(pos = 0, side = 3)

# Plot the AFDW coefficients over the grid 

plot(AFDW, x.int, pch = 19, ylim = c(L, 0), xlim = c(0.5, 1), 
     xlab = "", ylab = "depth [m]", main = "AFDW coefficient", axes = FALSE)
abline(h = 0)
axis(pos = NA, side = 2)
axis(pos = 0, side = 3)

# Three steady-state solutions for a coarse grid based on:
# (1) backward differences (BD)
# (2) central differences (CD)
# (3) Fiadeiro &amp; Veronis scheme (FV)

BD &lt;- steady.1D(y = runif(N), func = model, AFDW = 1.0, nspec = 1)
CD &lt;- steady.1D(y = runif(N), func = model, AFDW = 0.5, nspec = 1)
FV &lt;- steady.1D(y = runif(N), func = model, AFDW = AFDW, nspec = 1)

# Plotting output - use rootSolve's plot method
plot(BD, CD, FV, grid = x.mid, xyswap = TRUE, mfrow = c(1,2), 
     xlab = "", ylab = "depth [m]", main = "conc (Low resolution grid)")

legend("bottomright", col = 1:3, lty = 1:3,
       legend = c("backward diff", "centred diff", "Fiadeiro&amp;Veronis"))


## =============================================================================
## Model solution for a fine grid (1000 grid cells)
## =============================================================================

# Setting up the grid
N &lt;- 1000                            # number of grid layers 
dx &lt;- L/N                            # thickness of boxes[m]
dx.aux &lt;- rep(dx, N+1)              # auxilliary grid vector
x.int &lt;- seq(from = 0, to = L, by = dx)      # water depth at box interfaces [m]
x.mid &lt;- seq(from = dx/2, to = L, by = dx)   # water depth at box centres [m]

# Exponetially declining sink velocity
v.sink &lt;- v.sink.0 * exp(-x.int/x.att) # sink velocity [m d-1]
Pe &lt;- v.sink * dx/D.eddy               # Peclet number

# Calculate the weighing coefficients
AFDW &lt;- fiadeiro(v = v.sink, D = D.eddy, dx.aux = dx.aux)

# Three steady-state solutions for a coarse grid based on:
# (1) backward differences (BD)
# (2) centered differences (CD)
# (3) Fiadeiro &amp; Veronis scheme (FV)

BD &lt;- steady.1D(y = runif(N), func = model, AFDW = 1.0, nspec = 1)
CD &lt;- steady.1D(y = runif(N), func = model, AFDW = 0.5, nspec = 1)
FV &lt;- steady.1D(y = runif(N), func = model, AFDW = AFDW, nspec = 1)

# Plotting output
plot(BD, CD, FV, grid = x.mid, xyswap = TRUE, mfrow = NULL, 
     xlab = "", ylab = "depth [m]", main = "conc (High resolution grid)")

legend("bottomright", col = 1:3, lty = 1:3,
       legend = c("backward diff", "centred diff", "Fiadeiro&amp;Veronis"))

# Results and conclusions:
# - For the fine grid, all three solutions are identical
# - For the coarse grid, the BD and FV solutions show numerical dispersion
#   while the CD provides more accurate results
</code></pre>

<hr>
<h2 id='g.sphere'>
Surface Area and Volume of Geometrical Objects
</h2><span id='topic+g.sphere'></span><span id='topic+g.spheroid'></span><span id='topic+g.cylinder'></span>

<h3>Description</h3>


<ul>
<li> <p><code>g.sphere</code> the surface and volume of a sphere
</p>
</li>
<li> <p><code>g.spheroid</code> the surface and volume of a spheroid
</p>
</li>
<li> <p><code>g.cylinder</code> the surface and volume of a cylinder;
note that the surface area calculation ignores the top and bottom.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>
g.sphere(x)
g.spheroid (x, b = 1)
g.cylinder (x, L = 1)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.sphere_+3A_x">x</code></td>
<td>
<p>the radius 
</p>
</td></tr>
<tr><td><code id="g.sphere_+3A_b">b</code></td>
<td>
<p>the ratio of long/short radius of the spheroid;
if b&lt;1: the spheroid is oblate.
</p>
</td></tr>
<tr><td><code id="g.sphere_+3A_l">L</code></td>
<td>
<p>the length of the cylinder
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>surf</code></td>
<td>
<p>the surface area 
</p>
</td></tr>
<tr><td><code>vol</code></td>
<td>
<p>the volume 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Filip Meysman &lt;filip.meysman@nioz.nl&gt;,
Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 mf &lt;- par(mfrow = c(3, 2))
 x  &lt;- seq(from = 0, to = 1, length = 10)
 plot(x, g.sphere(x)$surf, main = "sphere surface")
 plot(x, g.sphere(x)$vol, main = "sphere volume")
 plot(x, g.spheroid(x, b = 0.5)$surf, main = "spheroid surface")
 plot(x, g.spheroid(x, b = 0.5)$vol, main = "spheroid volume")
 plot(x, g.cylinder(x, L = 1)$surf, main = "cylinder surface")
 plot(x, g.cylinder(x, L = 1)$vol, main = "cylinder volume")
 par("mfrow" = mf)

</code></pre>

<hr>
<h2 id='p.exp'>
Common Properties with Distance, to be used with setup.prop.1D
</h2><span id='topic+p.exp'></span><span id='topic+p.lin'></span><span id='topic+p.sig'></span>

<h3>Description</h3>

<p>Functions that define an y-property as a function of the one-dimensional
x-coordinate. These routines can be used to specify properties and parameters
as a function of distance, e.g. depth in the water column or the sediment.
</p>
<p>They make a transition from an upper (or upstream) zone, with value
<code>y.0</code> to a lower zone with a value <code>y.inf</code>.
</p>
<p>Particularly useful in combination with <a href="#topic+setup.prop.1D">setup.prop.1D</a>
</p>

<ul>
<li> <p><code>p.exp</code>: exponentially decreasing transition 
</p>
<p style="text-align: center;"><code class="reqn">
         y = y_{\inf} + (y_0-y_{\inf}) \exp(-\max(0,x-x_0)/x_a)
      </code>
</p>

</li>
<li> <p><code>p.lin</code>: linearly decreasing transition 
</p>
<p style="text-align: center;"><code class="reqn">
         y = y_0;  y = y_0 - (y_0-y_{inf})*(x-x_L)/x_{att}) ;
         y = y_{inf}
        </code>
</p>

<p>for <code class="reqn">0 \leq x \leq x_L</code>, <code class="reqn">x_L \leq x \leq x_L + x_{att}</code> and
<code class="reqn">(x \geq x_L + x.att )</code> respectively.
</p>
</li>
<li> <p><code>p.sig</code>: sigmoidal decreasing transition
</p>
<p style="text-align: center;"><code class="reqn">
         y = y_{inf} + (y_0-y_{inf})\frac{\exp(-(x-x_L)/
         (0.25 x_{att}))}{(1+\exp(-(x-x_L))/(0.25 x_{att}))})
        </code>
</p>

</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>p.exp(x, y.0 = 1, y.inf = 0.5, x.L = 0, x.att = 1)
p.lin(x, y.0 = 1, y.inf = 0.5, x.L = 0, x.att = 1)
p.sig(x, y.0 = 1, y.inf = 0.5, x.L = 0, x.att = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p.exp_+3A_x">x</code></td>
<td>
<p>the x-values for which the property has to be calculated.
</p>
</td></tr>
<tr><td><code id="p.exp_+3A_y.0">y.0</code></td>
<td>
<p>the y-value at the origin 
</p>
</td></tr>
<tr><td><code id="p.exp_+3A_y.inf">y.inf</code></td>
<td>
<p>the y-value at infinity 
</p>
</td></tr>
<tr><td><code id="p.exp_+3A_x.l">x.L</code></td>
<td>
<p>the x-coordinate where the transition zone starts;
for <code>x &lt;= x.0</code>, the value will be equal
to <code>y.0</code>. For <code>x &gt;&gt; x.L + x.att</code> the value will
tend to <code>y.inf</code>
</p>
</td></tr>
<tr><td><code id="p.exp_+3A_x.att">x.att</code></td>
<td>
<p>attenuation coefficient in exponential decrease,
or the size of the transition zone in the linear and sigmoid decrease
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>p.lin</code>, the width of the transition zone equals <code>x.att</code> and
the depth where the transition zone starts is <code>x.L</code>.
</p>
<p>For <code>p.sig</code>, <code>x.L</code> is located the middle of the smooth transition zone of approaximate width <code>x.att</code>.  
</p>
<p>For <code>p.exp</code>, there is no clearly demarcated transition zone;
there is an abrupt change at <code>x.L</code> after which the property
exponentially changes from <code>y.0</code> towards <code>y.L</code> with attenuation
coefficient <code>x.att</code>; the larger <code>x.att</code> the less steep the change.
</p>


<h3>Value</h3>

<p>the property value, estimated for each x-value.
</p>


<h3>Author(s)</h3>

<p>Filip Meysman &lt;filip.meysman@nioz.nl&gt;,
Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(0, 5, len = 100)
plot(x, p.exp(x, x.L = 2), 
     xlab = "x.coordinate", ylab = "y value", ylim = c(0, 1))
lines(x, p.lin(x, x.L = 2), col = "blue")
lines(x, p.sig(x, x.L = 2), col = "red")
</code></pre>

<hr>
<h2 id='ReacTran-package'>Reactive transport modelling in 1D, 2D and 3D</h2><span id='topic+ReacTran-package'></span><span id='topic+ReacTran'></span>

<h3>Description</h3>

<p>R-package ReacTran contains routines that enable the development of
reactive transport models in aquatic systems (rivers, lakes, oceans), 
porous media (floc aggregates, sediments,...) and
even idealized organisms (spherical cells, cylindrical worms,...).
</p>
<p>The geometry of the model domain is either one-dimensional, two-dimensional
or three-dimensional.
</p>
<p>The package contains:
</p>

<ul>
<li><p> Functions to setup a finite-difference grid (1D or 2D)
</p>
</li>
<li><p> Functions to attach parameters and properties to this grid (1D or 2D)
</p>
</li>
<li><p> Functions to calculate the advective-diffusive transport term over
the grid (1D, 2D, 3D)
</p>
</li>
<li><p> Utility functions
</p>
</li></ul>



<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
    Package: </td><td style="text-align: left;"> ReacTran</td>
</tr>
<tr>
 <td style="text-align: left;">
    Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
    Version: </td><td style="text-align: left;"> 1.4.3</td>
</tr>
<tr>
 <td style="text-align: left;">
    Date: </td><td style="text-align: left;"> 2017-08-14</td>
</tr>
<tr>
 <td style="text-align: left;">
    License: </td><td style="text-align: left;"> GNU Public License 2 or above</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Karline Soetaert (Maintainer)
</p>
<p>Filip Meysman
</p>


<h3>See Also</h3>

<p>Functions <a href="deSolve.html#topic+ode.1D">ode.1D</a>, <a href="deSolve.html#topic+ode.2D">ode.2D</a>, <a href="deSolve.html#topic+ode.3D">ode.3D</a> from package <code>deSolve</code> 
to integrate the reactive-transport model
</p>
<p>Functions steady.1D, steady.2D, steady.3D from 
package <code>rootSolve</code> to find the steady-state solution of the 
reactive-transport model
</p>
<p><code><a href="#topic+tran.1D">tran.1D</a></code>,   <code><a href="#topic+tran.2D">tran.2D</a></code>,  <code><a href="#topic+tran.3D">tran.3D</a></code> for 
a discretisation of the general transport equations
</p>
<p><code><a href="#topic+tran.volume.1D">tran.volume.1D</a></code> for discretisation of the 1-D transport equations using finite volumes
</p>
<p><code><a href="#topic+tran.cylindrical">tran.cylindrical</a></code>, <code><a href="#topic+tran.spherical">tran.spherical</a></code> 
for a discretisation of 3-D transport equations in cylindrical and 
spherical coordinates
</p>
<p><code><a href="#topic+tran.polar">tran.polar</a></code>, 
for a discretisation of 2-D transport equations in polar coordinates  
</p>
<p><code><a href="#topic+setup.grid.1D">setup.grid.1D</a></code>,   <code><a href="#topic+setup.grid.2D">setup.grid.2D</a></code> for the creation of grids in 1-D and in 2-D
</p>
<p><code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,   <code><a href="#topic+setup.prop.2D">setup.prop.2D</a></code> for defining properties on these grids.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## show examples (see respective help pages for details)
## 1-dimensional transport
example(tran.1D)
example(tran.volume.1D)

## 2-dimensional transport
example(tran.2D)
example(tran.polar)

## 3-dimensional transport
example(tran.3D)
example(tran.cylindrical)
example(tran.spherical)

## open the directory with documents
browseURL(paste(system.file(package="ReacTran"), "/doc", sep=""))

## open the directory with fortran codes of the transport functions
browseURL(paste(system.file(package="ReacTran"), "/doc/fortran", sep=""))

## show package vignette with how to use ReacTran and how to solve PDEs
## + source code of the vignettes
vignette("ReacTran")
vignette("PDE")
edit(vignette("ReacTran"))

## a directory with fortran implementations of the transport
browseURL(paste(system.file(package="ReacTran"), "/doc/fortran", sep=""))

## End(Not run)
</code></pre>

<hr>
<h2 id='setup.compaction.1D'>
Calculates Advective Velocities of the Pore Water and Solid Phase
in a Water Saturated Sediment assuming Steady State Compaction
</h2><span id='topic+setup.compaction.1D'></span>

<h3>Description</h3>

<p>This function calculates the advective velocities of the pore water and
the solid phase in a sediment based on the assumption of steady state
compaction.
</p>
<p>The velocities of the pore water (<code>u</code>) and the solid phase (<code>v</code>)
are calculated in the middle (<code>mid</code>) of the grid cells and the
interfaces (<code>int</code>).
</p>
<p>One needs to specify the porosity at the interface (<code>por.0</code>), the
porosity at infinite depth (<code>por.inf</code>), the porosity profile
(<code>por.grid</code>) encoded as a 1D grid property
(see <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>, as well as the advective
velocity of the solid phase at one particular depth (either at the sediment 
water interface (<code>v.0</code>) or at infinite depth (<code>v.inf</code>)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup.compaction.1D(v.0 = NULL, v.inf = NULL, por.0, por.inf,
                    por.grid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup.compaction.1D_+3A_v.0">v.0</code></td>
<td>
<p>advective velocity of the solid phase at the sediment-water
interface (also referred to as the sedimentation velocity); if <code>NULL</code>
then <code>v.inf</code> must not be <code>NULL</code> [L/T]
</p>
</td></tr>
<tr><td><code id="setup.compaction.1D_+3A_v.inf">v.inf</code></td>
<td>
<p>advective velocity of the solid phase at infinite depth
(also referred to as the burial velocity); if <code>NULL</code> then
<code>v.0</code> must not be <code>NULL</code> [L/T]
</p>
</td></tr>
<tr><td><code id="setup.compaction.1D_+3A_por.0">por.0</code></td>
<td>
<p>porosity at the sediment-water interface
</p>
</td></tr>
<tr><td><code id="setup.compaction.1D_+3A_por.inf">por.inf</code></td>
<td>
<p>porosity at infinite depth
</p>
</td></tr>
<tr><td><code id="setup.compaction.1D_+3A_por.grid">por.grid</code></td>
<td>
<p>porosity profile specified as a 1D grid property
(see <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code> for details on the structure of this list)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>u</code></td>
<td>
<p>list with pore water advective velocities at the middle of the
grid cells (<code>mid</code>) and at the grid cell interfaces (<code>int</code>).
</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>list with solid phase advective velocities at the middle of the
grid cells (<code>mid</code>) and at the grid cell interfaces (<code>int</code>).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Filip Meysman &lt;filip.meysman@nioz.nl&gt;,
Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>Meysman, F. J. R., Boudreau, B. P., Middelburg, J. J. (2005) Modeling Reactive Transport in Sediments Subject to Bioturbation and Compaction. Geochimica Et Cosmochimica Acta 69, 3601-3617
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# setup of the 1D grid

L &lt;-10
grid &lt;- setup.grid.1D(x.up = 0, L = L, N = 20)

# attaching an exponential porosity profile to the 1D grid
# this uses the "p.exp" profile function

por.grid &lt;- setup.prop.1D(func = p.exp, grid = grid, 
                          y.0 = 0.9, y.inf = 0.5, x.att = 3)

# calculate the advective velocities

dummy &lt;- setup.compaction.1D(v.0 = 1, por.0 = 0.9, por.inf = 0.5, 
                             por.grid = por.grid)
u.grid &lt;- dummy$u
v.grid &lt;- dummy$v

# plotting the results

par(mfrow = c(2, 1), cex.main = 1.2, cex.lab = 1.2)

plot(por.grid$int, grid$x.int, pch = 19, ylim = c(L,0), xlim = c(0,1),
     xlab = "", ylab = "depth [cm]", main = expression("porosity"),
     axes = FALSE)
abline(h = 0)
axis(pos = 0, side = 2)
axis(pos = 0, side = 3)

plot(u.grid$int, grid$x.int, type = "l", lwd = 2, col = "blue",
     ylim = c(L, 0), xlim = c(0, max(u.grid$int,v.grid$int)),
     xlab = "", ylab = "depth [cm]",
     main = "advective velocity [cm yr-1]", axes = FALSE)
abline(h = 0)
axis(pos = 0, side = 2)
axis(pos = 0, side = 3)

lines(v.grid$int, grid$x.int, lwd = 2, col = "red")

legend(x = "bottomright", legend = c("pore water","solid phase"),
       col = c("blue", "red"), lwd = 2)

</code></pre>

<hr>
<h2 id='setup.grid.1D'>
Creates a One-Dimensional Finite Difference Grid
</h2><span id='topic+setup.grid.1D'></span><span id='topic+plot.grid.1D'></span>

<h3>Description</h3>

<p>Subdivides the one-dimensional model domain into one or more zones that
are each sub-divided into grid cells. The resulting grid structure can be
used in the other <code>ReacTran</code> functions.
</p>
<p>The grid structure is characterized by the position of the middle of
the grid cells (<code>x.mid</code>) and the position of the interfaces between
grid cells (<code>x.int</code>).
</p>
<p>Distances are calculated between the interfaces (<code>dx</code>), i.e. the
thickness of the grid cells. An auxiliary set of distances (<code>dx.aux</code>)
is calculated between the points where the concentrations are specified
(at the center of each grid cell and the two external interfaces).
</p>
<p>A more complex grid consisting of multiple zones can be constructed when
specifying the endpoints of ech zone (<code>x.down</code>), the interval length
(<code>L</code>), and the number of layers in each zone (<code>N</code>) as vectors.
In each zone, one can control the grid resolution near the upstream and
downstream boundary.
</p>
<p>The grid resolution at the upstream interface changes according to the
power law relation <code>dx[i+1] = min(max.dx.1,p.dx.1*dx[i])</code>,
where <code>p.dx.1</code> determines the rate of increase and <code>max.dx.1</code>
puts an upper limit on the grid cell size.
</p>
<p>A similar formula controls the resolution at the downstream interface.
This allows refinement of the grid near the interfaces.
</p>
<p>If only <code>x.up, N</code> and <code>dx.1</code> are specified, then the grid size
is taken constant = <code>dx.1</code> (and <code>L=N*dx.1</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup.grid.1D(x.up = 0, x.down = NULL, L = NULL, N = NULL, dx.1 = NULL,
              p.dx.1 = rep(1, length(L)), max.dx.1 = L, dx.N = NULL,
              p.dx.N = rep(1, length(L)), max.dx.N = L)

## S3 method for class 'grid.1D'
plot(x, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup.grid.1D_+3A_x.up">x.up</code></td>
<td>
<p>position of the upstream interface; one value [L]
</p>
</td></tr>
<tr><td><code id="setup.grid.1D_+3A_x.down">x.down</code></td>
<td>
<p>position of the endpoint of each zone; one value when the
model domain covers only one zone (<code>x.down</code> = position of downstream
interface), or a vector of length M when the model domain is divided into
M zones (<code>x.down[M]</code> = position of downstream interface) [L]
</p>
</td></tr>
<tr><td><code id="setup.grid.1D_+3A_l">L</code></td>
<td>
<p>thickness of zones; one value (model domain = one zone) or a
vector of length M (model domain = M zones) [L]
</p>
</td></tr>
<tr><td><code id="setup.grid.1D_+3A_n">N</code></td>
<td>
<p>number of grid cells within a zone; one value or a vector of
length M [-]
</p>
</td></tr>
<tr><td><code id="setup.grid.1D_+3A_dx.1">dx.1</code></td>
<td>
<p>size of the first grid cell in a zone; one value or a vector
of length M [L]
</p>
</td></tr>
<tr><td><code id="setup.grid.1D_+3A_p.dx.1">p.dx.1</code></td>
<td>
<p>power factor controlling the increase in grid cell size near
the upstream boundary; one value or a vector of length M. The default
value is 1 (constant grid cell size) [-]
</p>
</td></tr>
<tr><td><code id="setup.grid.1D_+3A_max.dx.1">max.dx.1</code></td>
<td>
<p>maximum grid cell size in the upstream half of the zone;
one value or a vector of length M [L]
</p>
</td></tr>
<tr><td><code id="setup.grid.1D_+3A_dx.n">dx.N</code></td>
<td>
<p>size of the last grid cell in a zone; one value or a vector
of length M [L]
</p>
</td></tr>
<tr><td><code id="setup.grid.1D_+3A_p.dx.n">p.dx.N</code></td>
<td>
<p>power factor controlling the increase in grid cell size near the
downstream boundary; one value or a vector of length M. The default value
is 1 (constant grid cell size) [-]
</p>
</td></tr>
<tr><td><code id="setup.grid.1D_+3A_max.dx.n">max.dx.N</code></td>
<td>
<p>maximum grid cell size in the downstream half of the zone;
one value or a vector of length M [L]
</p>
</td></tr>
<tr><td><code id="setup.grid.1D_+3A_x">x</code></td>
<td>
<p>the object of class <code>grid.1D</code> that needs plotting
</p>
</td></tr>
<tr><td><code id="setup.grid.1D_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the function <a href="graphics.html#topic+plot">plot</a>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of type <code>grid.1D</code> containing:
</p>
<table>
<tr><td><code>N</code></td>
<td>
<p>the total number of grid cells [-]
</p>
</td></tr>
<tr><td><code>x.up</code></td>
<td>
<p>position of the upstream interface; one value [L]
</p>
</td></tr>
<tr><td><code>x.down</code></td>
<td>
<p>position of the downstream interface; one value [L]
</p>
</td></tr>
<tr><td><code>x.mid</code></td>
<td>
<p>position of the middle of the grid cells;
vector of length <code>N</code> [L]
</p>
</td></tr>
<tr><td><code>x.int</code></td>
<td>
<p>position of the interfaces of the grid cells;
vector of length <code>N+1</code> [L]
</p>
</td></tr>
<tr><td><code>dx</code></td>
<td>
<p>distance between adjacent cell interfaces (thickness of grid
cells); vector of length <code>N</code> [L]
</p>
</td></tr>
<tr><td><code>dx.aux</code></td>
<td>
<p>auxiliary vector containing the distance between adjacent
cell centers; at the upper and lower boundary calculated as
(<code>x[1]-x.up</code>) and (<code>x.down-x[N]</code>) respectively; vector of
length <code>N+1</code> [L]
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Filip Meysman &lt;filip.meysman@nioz.nl&gt;,
Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tran.1D">tran.1D</a></code>, for a discretisation of the general transport equation in 1-D
</p>
<p><code><a href="#topic+setup.grid.2D">setup.grid.2D</a></code> for the creation of grids in 2-D
</p>
<p><code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>, for defining properties on the 1-D grid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># one zone, constant resolution
(GR &lt;- setup.grid.1D(x.up = 0, L = 10, N = 10))
(GR &lt;- setup.grid.1D(x.up = 0, L = 10, dx.1 = 1))
(GR &lt;- setup.grid.1D(x.up = 0, L = 10, dx.N = 1))
plot(GR)

# one zone, constant resolution, origin not zero
(GR &lt;- setup.grid.1D(x.up = 5, x.down = 10, N = 10))
plot(GR)

# one zone, variable resolution
(GR &lt;- setup.grid.1D(x.up = 0, L = 10, dx.1 = 1, p.dx.1 = 1.2))
(GR &lt;- setup.grid.1D(x.up = 0, L = 10, dx.N = 1, p.dx.N = 1.2))
plot(GR)

# one zone, variable resolution, imposed number of layers
(GR &lt;- setup.grid.1D(x.up = 0, L = 10, N = 6, dx.1 = 1, p.dx.1 = 1.2))
(GR &lt;- setup.grid.1D(x.up = 0, L = 10, N = 6, dx.N = 1, p.dx.N = 1.2))
plot(GR)

# one zone, higher resolution near upstream and downstream interfaces
(GR &lt;- setup.grid.1D(x.up = 0, x.down = 10, dx.1 = 0.1,
                     p.dx.1 = 1.2, dx.N = 0.1, p.dx.N = 1.2))
plot(GR)

# one zone, higher resolution near upstream and downstream interfaces
# imposed number of layers 
(GR &lt;- setup.grid.1D(x.up = 0, x.down = 10, N = 20, 
                     dx.1 = 0.1, p.dx.1 = 1.2, 
                     dx.N = 0.1, p.dx.N = 1.2))
plot(GR)

# two zones, higher resolution near the upstream
# and downstream interface
(GR&lt;-setup.grid.1D(x.up = 0, L = c(5, 5), 
         dx.1 = c(0.2, 0.2), p.dx.1 = c(1.1, 1.1), 
         dx.N = c(0.2, 0.2), p.dx.N = c(1.1, 1.1)))
plot(GR)

# two zones, higher resolution near the upstream
# and downstream interface
# the number of grid cells in each zone is imposed via N
(GR &lt;- setup.grid.1D(x.up = 0, L = c(5, 5), N = c(20, 10),
         dx.1 = c(0.2, 0.2), p.dx.1 = c(1.1, 1.1), 
         dx.N = c(0.2, 0.2), p.dx.N = c(1.1, 1.1)))
plot(GR)
</code></pre>

<hr>
<h2 id='setup.grid.2D'>
Creates a Finite Difference Grid over a Two-Dimensional Rectangular Domain
</h2><span id='topic+setup.grid.2D'></span>

<h3>Description</h3>

<p>Creates a finite difference grid over a rectangular two-dimensional model
domain starting from two separate one-dimensional grids (as created by
<code><a href="#topic+setup.grid.1D">setup.grid.1D</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup.grid.2D(x.grid = NULL, y.grid = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup.grid.2D_+3A_x.grid">x.grid</code></td>
<td>
<p>list containing the one-dimensional grid in the vertical
direction - see <code><a href="#topic+setup.grid.1D">setup.grid.1D</a></code> for the structure of the list
</p>
</td></tr>
<tr><td><code id="setup.grid.2D_+3A_y.grid">y.grid</code></td>
<td>
<p>list containing the one-dimensional grid in the horizontal
direction - see <code><a href="#topic+setup.grid.1D">setup.grid.1D</a></code> for the structure of the list
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of type <code>grid.2D</code> containing:
</p>
<table>
<tr><td><code>x.up</code></td>
<td>
<p>position of the upstream interface in x-direction
(i.e. if x is vertical, the upper boundary); one value
</p>
</td></tr>
<tr><td><code>x.down</code></td>
<td>
<p>position of the downstream interface in x-direction
(i.e. if x is vertical, the lower boundary); one value
</p>
</td></tr>
<tr><td><code>x.mid</code></td>
<td>
<p>position of the middle of the grid cells in x-direction;
vector of length <code>x.N</code>
</p>
</td></tr>
<tr><td><code>x.int</code></td>
<td>
<p>position of the interfaces of the grid cells in x-direction;
vector of length <code>x.N+1</code>
</p>
</td></tr>
<tr><td><code>dx</code></td>
<td>
<p>distance between adjacent cell interfaces in x-direction
(thickness of grid cells); vector of length <code>x.N</code>
</p>
</td></tr>
<tr><td><code>dx.aux</code></td>
<td>
<p>auxiliary vector containing the distance between adjacent
cell centers; at the upstream and downstream boundary calculated as
(<code>x[1]-x.up</code>) and (<code>x.down-x[x.N]</code>) respectively;
vector of length <code>x.N+1</code>
</p>
</td></tr>
<tr><td><code>x.N</code></td>
<td>
<p>total number of grid cells in the x direction; one value
</p>
</td></tr>
<tr><td><code>y.left</code></td>
<td>
<p>position of the upstream interface in y-direction
(i.e. if y us the horizontal, the left boundary); one value
</p>
</td></tr>
<tr><td><code>y.right</code></td>
<td>
<p>position of the downstream interface in y-direction
(i.e. if y us the horizontal, the right boundary); one value
</p>
</td></tr>
<tr><td><code>y.mid</code></td>
<td>
<p>position of the middle of the grid cells in y-direction;
vector of length <code>y.N</code>
</p>
</td></tr>
<tr><td><code>y.int</code></td>
<td>
<p>position of the interfaces of the grid cells in y-direction;
vector of length <code>y.N+1</code>
</p>
</td></tr>
<tr><td><code>dy</code></td>
<td>
<p>distance between adjacent cell interfaces in y-direction
(thickness of grid cells); vector of length <code>y.N</code>
</p>
</td></tr>
<tr><td><code>dy.aux</code></td>
<td>
<p>auxiliary vector containing the distance between adjacent
cell centers; at the upstream and downstream boundary calculated as
(<code>y[1]-y.up</code>) and (<code>y.down-y[y.N]</code>) respectively;
vector of length <code>y.N+1</code>
</p>
</td></tr>
<tr><td><code>y.N</code></td>
<td>
<p>total number of grid cells in the y direction;
one value
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Filip Meysman &lt;filip.meysman@nioz.nl&gt;,
Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tran.2D">tran.2D</a></code>,  for a discretisation of the general transport equation in 2-D
</p>
<p><code><a href="#topic+setup.grid.1D">setup.grid.1D</a></code>, for the creation of grids in 1-D
</p>
<p><code><a href="#topic+setup.prop.2D">setup.prop.2D</a></code> for defining properties on the 2-D grid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># test of the setup.grid.2D functionality
x.grid  &lt;- setup.grid.1D(x.up = 0, L = 10, N = 5)
y.grid  &lt;- setup.grid.1D(x.up = 0, L = 20, N = 10)
(grid2D &lt;- setup.grid.2D(x.grid, y.grid))

</code></pre>

<hr>
<h2 id='setup.prop.1D'>
Attaches a Property to a One-Dimensional Grid
</h2><span id='topic+setup.prop.1D'></span><span id='topic+plot.prop.1D'></span>

<h3>Description</h3>

<p>This routine calculates the value of a given property at the middle of
the grid cells (<code>mid</code>) and at the interfaces of the grid cells
(<code>int</code>).
</p>
<p>Two possibilities are available: either specifying a mathematical function
(<code>func</code>) that describes the spatial dependency of the property,
or obtaining the property from interpolation of a data series
(via the input of the data matrix <code>xy</code>).
</p>
<p>For example, in a sediment model, <code>setup.prop.1D</code> can be used to
specify the porosity, the mixing intensity or some other parameter over
the one-dimensional grid. Similarly, in a vertical water column model, <code>setup.prop.1D</code> can be
used to specify the sinking velocity of particles or other model parameters
changing with water depth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup.prop.1D(func = NULL, value = NULL, xy = NULL,
              interpolate = "spline", grid, ...)

## S3 method for class 'prop.1D'
plot(x, grid, xyswap = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup.prop.1D_+3A_func">func</code></td>
<td>
<p>function that describes the spatial dependency. For example, one can use the functions provided in <code><a href="#topic+p.exp">p.exp</a></code> 
</p>
</td></tr>
<tr><td><code id="setup.prop.1D_+3A_value">value</code></td>
<td>
<p>constant value given to the property (no spatial dependency)
</p>
</td></tr>
<tr><td><code id="setup.prop.1D_+3A_xy">xy</code></td>
<td>
<p>a two-column data matrix where the first column (<code>x</code>) provides
the position, and the second column (<code>y</code>) provides the values that
needs interpolation over the grid
</p>
</td></tr>
<tr><td><code id="setup.prop.1D_+3A_interpolate">interpolate</code></td>
<td>
<p>specifies how the interpolation should be done, one
of &quot;spline&quot; or &quot;linear&quot;; only used when <code>xy</code> is present
</p>
</td></tr>
<tr><td><code id="setup.prop.1D_+3A_grid">grid</code></td>
<td>
<p>list specifying the 1D grid characteristics, see
<code><a href="#topic+setup.grid.1D">setup.grid.1D</a></code> for details on the structure of this list
</p>
</td></tr>
<tr><td><code id="setup.prop.1D_+3A_x">x</code></td>
<td>
<p>the object of class <code>prop.1D</code> that needs plotting
</p>
</td></tr>
<tr><td><code id="setup.prop.1D_+3A_xyswap">xyswap</code></td>
<td>
<p>if <code>TRUE</code>, then x- and y-values are swapped and
the y-axis is oriented from top to bottom. Useful for drawing
vertical depth profiles
</p>
</td></tr>
<tr><td><code id="setup.prop.1D_+3A_...">...</code></td>
<td>
<p>additional arguments that are passed on to <code>func</code> or
to the S3 method
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two options to carry out the data interpolation:
</p>

<ul>
<li><p> &quot;spline&quot; gives a smooth profile, but sometimes generates
strange profiles - always check the result!
</p>
</li>
<li><p> &quot;linear&quot; gives a segmented profile
</p>
</li></ul>



<h3>Value</h3>

<p>A list of type <code>prop.1D</code> containing:
</p>
<table>
<tr><td><code>mid</code></td>
<td>
<p>property value in the middle of the grid cells; vector of
length N (where N is the number of grid cells)
</p>
</td></tr>
<tr><td><code>int</code></td>
<td>
<p>property value at the interface of the grid cells;
vector of length N+1
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;,
Filip Meysman &lt;filip.meysman@nioz.nl&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tran.1D">tran.1D</a></code>, for a discretisation of the general transport equation in 1-D
</p>
<p><code><a href="#topic+setup.grid.1D">setup.grid.1D</a></code>, the creation of grids in 1-D
</p>
<p><code><a href="#topic+setup.prop.2D">setup.prop.2D</a></code> for defining properties on 2-D grids.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Construction of the 1D grid 

grid &lt;- setup.grid.1D(x.up = 0, L = 10, N = 10)

# Porosity profile via function specification

P.prof &lt;- setup.prop.1D(func = p.exp, grid = grid, y.0 = 0.9,
                        y.inf = 0.5, x.att = 3)

# Porosity profile via data series interpolation

P.data &lt;- matrix(ncol = 2, data = c(0,3,6,10,0.9,0.65,0.55,0.5))
P.spline &lt;- setup.prop.1D(xy = P.data, grid = grid)
P.linear &lt;- setup.prop.1D(xy = P.data, grid = grid, interpolate = "linear")

# Plot different profiles 

plot(P.prof, grid = grid, type = "l",
     main = "setup.prop, function evaluation")
points(P.data, cex = 1.5, pch = 16) 
lines(grid$x.int, P.spline$int, lty = "dashed")
lines(grid$x.int, P.linear$int, lty = "dotdash")
</code></pre>

<hr>
<h2 id='setup.prop.2D'>
Attaches a Property to a Two-Dimensional Grid
</h2><span id='topic+setup.prop.2D'></span><span id='topic+contour.prop.2D'></span>

<h3>Description</h3>

<p>Calculates the value of a given property at the middle of grid cells
(<code>mid</code>) and at the interfaces of the grid cells (<code>int</code>).
</p>
<p>Two possibilities are available: either specifying a mathematical function
(<code>func</code>) that describes the spatial dependency of the property, or
asssuming a constant value (<code>value</code>). To allow for anisotropy, the
spatial dependency can be different in the x and y direction.
</p>
<p>For example, in a sediment model, the routine can be used to specify the
porosity, the mixing intensity or other parameters over the grid of the
reactangular sediment domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup.prop.2D(func = NULL, value = NULL, grid, y.func = func, 
              y.value = value, ...)

## S3 method for class 'prop.2D'
contour(x, grid, xyswap = FALSE, filled = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup.prop.2D_+3A_func">func</code></td>
<td>
<p>function that describes the spatial dependency in the 
x-direction; defined as <code>func &lt;- function (x,y, ...); 
    it should return as many elements as in x or y</code>
</p>
</td></tr>
<tr><td><code id="setup.prop.2D_+3A_value">value</code></td>
<td>
<p>constant value given to the property in the x-direction
</p>
</td></tr>
<tr><td><code id="setup.prop.2D_+3A_grid">grid</code></td>
<td>
<p>list specifying the 2D grid characteristics, see
<code><a href="#topic+setup.grid.2D">setup.grid.2D</a></code> for details on the structure of this list
</p>
</td></tr>
<tr><td><code id="setup.prop.2D_+3A_y.func">y.func</code></td>
<td>
<p>function that describes the spatial dependency in the
y-direction; defined as <code>y.func &lt;- function (x, y, ...)</code>;
it should return as many elements as in x or y. 
By default the same as in the x-direction. 
</p>
</td></tr>
<tr><td><code id="setup.prop.2D_+3A_y.value">y.value</code></td>
<td>
<p>constant value given to the property in the y-direction.
By default the same as in the x-direction.
</p>
</td></tr>
<tr><td><code id="setup.prop.2D_+3A_x">x</code></td>
<td>
<p>the object of class <code>prop.2D</code> that needs plotting
</p>
</td></tr>
<tr><td><code id="setup.prop.2D_+3A_filled">filled</code></td>
<td>
<p>if <code>TRUE</code>, uses <code>filled.contour</code>, else <code>contour</code>
</p>
</td></tr>
<tr><td><code id="setup.prop.2D_+3A_xyswap">xyswap</code></td>
<td>
<p>if <code>TRUE</code>, then x- and y-values are swapped and
the y-axis is oriented from top to bottom. Useful for drawing
vertical depth profiles
</p>
</td></tr>
<tr><td><code id="setup.prop.2D_+3A_...">...</code></td>
<td>
<p>additional arguments that are passed on to <code>func</code> or
to the method
</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p>When the property is isotropic, the <code>x.mid</code> and
<code>y.mid</code> values are identical. This is for example the case for
sediment porosity.
</p>
</li>
<li> <p>When the property is anisotropic, the <code>x.mid</code> and
<code>y.mid</code> values can differ. This can be for example the case for
the velocity, where in general, the value will differ between the x and
y direction.
</p>
</li></ul>



<h3>Value</h3>

<p>A list of type <code>prop.2D</code> containing:
</p>
<table>
<tr><td><code>x.mid</code></td>
<td>
<p>property value in the x-direction defined at the middle of the
grid cells; Nx * Ny matrix (where Nx and Ny = number of cells in x, y
direction)
</p>
</td></tr>
<tr><td><code>y.mid</code></td>
<td>
<p>property value in the y-direction at the middle of the grid
cells; Nx * Ny matrix
</p>
</td></tr>
<tr><td><code>x.int</code></td>
<td>
<p>property value in the x-direction defined at the
x-interfaces of the grid cells;
(Nx+1)*Ny matrix
</p>
</td></tr>
<tr><td><code>y.int</code></td>
<td>
<p>property value in the y-direction at the y-interfaces of the
grid cells; Nx*(Ny+1) matrix
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For some properties, it does not make sense to use <code>y.func</code> different 
to <code>func</code>. For instance, for volume fractions, AFDW.
</p>
<p>For other properties, it may be usefull to have <code>y.func</code> or 
<code>y.value</code> different from <code>func</code> or <code>value</code>, for instance
for velocities, surface areas, ...
</p>


<h3>Author(s)</h3>

<p>Filip Meysman &lt;filip.meysman@nioz.nl&gt;,
Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Inverse quadratic function 
inv.quad &lt;- function(x, y, a = NULL, b = NULL)
   return(1/((x-a)^2+(y-b)^2))


# Construction of the 2D grid 
x.grid &lt;- setup.grid.1D (x.up = 0, L = 10, N = 10)
y.grid &lt;- setup.grid.1D (x.up = 0, L = 10, N = 10)
grid2D &lt;- setup.grid.2D (x.grid, y.grid)

# Attaching the inverse quadratic function to the 2D grid 
(twoD &lt;- setup.prop.2D (func = inv.quad, grid = grid2D, a = 5, b = 5))

# show 
contour(log(twoD$x.int))

</code></pre>

<hr>
<h2 id='tran.1D'>
General One-Dimensional Advective-Diffusive Transport
</h2><span id='topic+tran.1D'></span>

<h3>Description</h3>

<p>Estimates the transport term (i.e. the rate of change of a concentration
due to diffusion and advection) in a one-dimensional model of a
liquid (volume fraction constant and equal to one) or in a porous medium
(volume fraction variable and lower than one).
</p>
<p>The interfaces between grid cells can have a variable cross-sectional area,
e.g. when modelling spherical or cylindrical geometries (see example).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tran.1D(C, C.up = C[1], C.down = C[length(C)],
        flux.up = NULL, flux.down = NULL, 
        a.bl.up = NULL, a.bl.down = NULL, 
        D = 0, v = 0, AFDW = 1, VF = 1, A = 1, dx,
        full.check = FALSE, full.output = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tran.1D_+3A_c">C</code></td>
<td>
<p>concentration, expressed per unit of phase volume, defined at the
centre of each grid cell. A vector of length N [M/L3]
</p>
</td></tr>
<tr><td><code id="tran.1D_+3A_c.up">C.up</code></td>
<td>
<p>concentration at upstream boundary. One value [M/L3]
</p>
</td></tr>
<tr><td><code id="tran.1D_+3A_c.down">C.down</code></td>
<td>
<p>concentration at downstream boundary. One value [M/L3]
</p>
</td></tr>
<tr><td><code id="tran.1D_+3A_flux.up">flux.up</code></td>
<td>
<p>flux across the upstream boundary, positive = INTO model
domain. One value, expressed per unit of total surface [M/L2/T]. 
If <code>NULL</code>, the boundary is prescribed as
a concentration or a convective transfer boundary.
</p>
</td></tr>
<tr><td><code id="tran.1D_+3A_flux.down">flux.down</code></td>
<td>
<p>flux across the downstream boundary, positive = OUT
of model domain. One value, expressed per unit of total surface [M/L2/T].
If <code>NULL</code>, the boundary is prescribed as
a concentration or a convective transfer boundary.
</p>
</td></tr>
<tr><td><code id="tran.1D_+3A_a.bl.up">a.bl.up</code></td>
<td>
<p>convective transfer coefficient across the upstream
boundary layer. <code>Flux = a.bl.up*(C.up-C0)</code>. One value [L/T]
</p>
</td></tr>
<tr><td><code id="tran.1D_+3A_a.bl.down">a.bl.down</code></td>
<td>
<p>convective transfer coefficient across the downstream
boundary layer (L). <code>Flux = a.bl.down*(CL-C.down)</code>.
One value [L/T]
</p>
</td></tr>
<tr><td><code id="tran.1D_+3A_d">D</code></td>
<td>
<p>diffusion coefficient, defined on grid cell interfaces.
One value, a vector of length N+1 [L2/T], or a <code>1D property</code> list; the list
contains at least the element <code>int</code> (see <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>)
[L2/T]
</p>
</td></tr>
<tr><td><code id="tran.1D_+3A_v">v</code></td>
<td>
<p>advective velocity, defined on the grid cell
interfaces. Can be positive (downstream flow) or negative (upstream flow).
One value, a vector of length N+1 [L/T], or a <code>1D property</code> list; the list
contains at least the element <code>int</code> (see <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>)
[L/T]
</p>
</td></tr>
<tr><td><code id="tran.1D_+3A_afdw">AFDW</code></td>
<td>
<p>weight used in the finite difference scheme for advection,
defined on grid cell interfaces; backward = 1, centred = 0.5, forward = 0;
default is backward. One value, a vector of length N+1, or a
<code>1D property</code> list; the list contains at least the element <code>int</code>
(see <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>) [-]
</p>
</td></tr>
<tr><td><code id="tran.1D_+3A_vf">VF</code></td>
<td>
<p>Volume fraction defined at the grid cell interfaces. One value,
a vector of length N+1, or a <code>1D property</code> list; the list
contains at least the elements <code>int</code> and <code>mid</code>
(see <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>) [-]
</p>
</td></tr>
<tr><td><code id="tran.1D_+3A_a">A</code></td>
<td>
<p>Interface area defined at the grid cell interfaces. One value,
a vector of length N+1, or a <code>1D grid property</code> list; the list
contains at least the elements <code>int</code> and <code>mid</code>
(see <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>) [L2]
</p>
</td></tr>
<tr><td><code id="tran.1D_+3A_dx">dx</code></td>
<td>
<p>distance between adjacent cell interfaces (thickness of grid
cells). One value, a vector of length N, or a <code>1D grid</code> list containing
at least the elements
<code>dx</code> and <code>dx.aux</code> (see <code><a href="#topic+setup.grid.1D">setup.grid.1D</a></code>) [L]
</p>
</td></tr>
<tr><td><code id="tran.1D_+3A_full.check">full.check</code></td>
<td>
<p>logical flag enabling a full check of the consistency
of the arguments (default = <code>FALSE</code>; <code>TRUE</code> slows down execution
by 50 percent)
</p>
</td></tr>
<tr><td><code id="tran.1D_+3A_full.output">full.output</code></td>
<td>
<p>logical flag enabling a full return of the output
(default = <code>FALSE</code>; <code>TRUE</code> slows down execution by 20 percent)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <b>boundary conditions</b> are either
</p>

<ul>
<li><p> (1) zero-gradient.
</p>
</li>
<li><p> (2) fixed concentration.
</p>
</li>
<li><p> (3) convective boundary layer.
</p>
</li>
<li><p> (4) fixed flux.
</p>
</li></ul>

<p>The above order also shows the priority. The default condition is the
zero gradient. The fixed concentration condition overrules the zero gradient.
The convective boundary layer condition overrules the fixed concentration
and zero gradient. The fixed flux overrules all other specifications.
</p>
<p>Ensure that the boundary conditions are well defined: for instance, it 
does not make sense to specify an influx in a boundary cell with the advection
velocity pointing outward.
</p>
<p><b>Transport properties:</b>
</p>
<p>The <em>diffusion coefficient</em> (<code>D</code>),
the <em>advective velocity</em> (<code>v</code>),
the <em>volume fraction</em> (VF), the <em>interface surface</em> (<code>A</code>),
and the <em>advective finite difference weight</em> (<code>AFDW</code>)
can either be specified as one value, a vector or a 1D property list
as generated by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>.
</p>
<p>When a vector, this vector must be of length N+1, defined at all grid
cell interfaces, including the upper and lower boundary.
</p>
<p>The <b>finite difference grid</b> (<code>dx</code>) is specified either as
one value, a vector or a 1D grid list, as generated by <code><a href="#topic+setup.grid.1D">setup.grid.1D</a></code>. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>dC</code></td>
<td>
<p>the rate of change of the concentration C due to transport,
defined in the centre of each grid cell. The rate of change is expressed
per unit of phase volume [M/L3/T]
</p>
</td></tr>
<tr><td><code>C.up</code></td>
<td>
<p>concentration at the upstream interface. One value [M/L3]
only when (<code>full.output</code> = <code>TRUE</code>)
</p>
</td></tr>
<tr><td><code>C.down</code></td>
<td>
<p>concentration at the downstream interface. One value [M/L3]
only when (<code>full.output</code> = <code>TRUE</code>)
</p>
</td></tr>
<tr><td><code>dif.flux</code></td>
<td>
<p>diffusive flux across at the interface of each grid cell.
A vector of length N+1 [M/L2/T]
only when (<code>full.output</code> = <code>TRUE</code>)
</p>
</td></tr>
<tr><td><code>adv.flux</code></td>
<td>
<p>advective flux across at the interface of each grid cell.
A vector of length N+1 [M/L2/T]
only when (<code>full.output</code> = <code>TRUE</code>)
</p>
</td></tr>
<tr><td><code>flux</code></td>
<td>
<p>total flux across at the interface of each grid cell. A vector
of length N+1 [M/L2/T].
only when (<code>full.output</code> = <code>TRUE</code>)
</p>
</td></tr>
<tr><td><code>flux.up</code></td>
<td>
<p>flux across the upstream boundary, positive = INTO model
domain. One value [M/L2/T]
</p>
</td></tr>
<tr><td><code>flux.down</code></td>
<td>
<p>flux across the downstream boundary, positive = OUT of
model domain. One value [M/L2/T]
</p>
</td></tr>
</table>


<h3>Note</h3>

 
<p>The advective equation is not checked for mass conservation. Sometimes, this is 
not an issue, for instance when <code>v</code> represents a sinking velocity of 
particles or a swimming velocity of organisms. 
In others cases however, mass conservation needs to be accounted for. 
To ensure mass conservation, the advective velocity must obey certain 
continuity constraints: in essence the product of the volume fraction (VF), 
interface surface area (A) and advective velocity (v) should be constant. 
In sediments, one can use <code><a href="#topic+setup.compaction.1D">setup.compaction.1D</a></code> to ensure that 
the advective velocities for the pore water and solid phase meet these 
constraints. 
</p>
<p>In terms of the units of concentrations and fluxes we follow the convention 
in the geosciences. 
The concentration <code>C</code>, <code>C.up</code>, <code>C.down</code> as well at the rate of 
change of the concentration <code>dC</code> are always expressed per unit of 
phase volume (i.e. per unit volume of solid or liquid). 
</p>
<p>Total concentrations (e.g. per unit volume of bulk sediment) can be obtained by 
multiplication with the appropriate volume fraction. In contrast, fluxes are 
always expressed per unit of total interface area (so here the volume fraction 
is accounted for).     
</p>


<h3>Author(s)</h3>

<p>Filip Meysman &lt;filip.meysman@nioz.nl&gt;,
Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>Soetaert and Herman (2009). A practical guide to ecological modelling -
using R as a simulation platform. Springer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tran.volume.1D">tran.volume.1D</a></code> for a discretisation the transport equation using finite volumes.
</p>
<p><code><a href="#topic+tran.2D">tran.2D</a></code>,   <code><a href="#topic+tran.3D">tran.3D</a></code>
</p>
<p><code><a href="#topic+advection.1D">advection.1D</a></code>, for more sophisticated advection schemes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =============================================================================
## EXAMPLE 1: O2 and OC consumption in sediments
## =============================================================================

# this example uses only the volume fractions 
# in the reactive transport term

#====================#
# Model formulation  #
#====================#

# Monod consumption of oxygen (O2)

O2.model &lt;- function (t = 0, O2, pars = NULL) {

  tran &lt;- tran.1D(C = O2, C.up = C.ow.O2, D = D.grid, 
                  v = v.grid, VF = por.grid, dx = grid)$dC
  reac &lt;- - R.O2*(O2/(Ks+O2))
  return(list(dCdt = tran + reac))
}

# First order consumption of organic carbon (OC)

OC.model &lt;- function (t = 0, OC, pars = NULL) {

  tran &lt;- tran.1D(C = OC, flux.up = F.OC, D = Db.grid,
                  v = v.grid, VF = svf.grid, dx = grid)$dC
  reac &lt;- - k*OC
  return(list(dCdt = tran + reac))
}

#======================#
# Parameter definition #
#======================#

# Parameter values

F.OC    &lt;- 25    # input flux organic carbon [micromol cm-2 yr-1]
C.ow.O2 &lt;- 0.25  # concentration O2 in overlying water [micromol cm-3]
por     &lt;- 0.8   # porosity
D       &lt;- 400   # diffusion coefficient O2 [cm2 yr-1]
Db      &lt;- 10    # mixing coefficient sediment [cm2 yr-1]
v       &lt;- 1     # advective velocity [cm yr-1]
k       &lt;- 1     # decay constant organic carbon [yr-1]
R.O2    &lt;- 10    # O2 consumption rate [micromol cm-3 yr-1]
Ks      &lt;- 0.005 # O2 consumption saturation constant 

# Grid definition

L &lt;- 10   # depth of sediment domain [cm]
N &lt;- 100  # number of grid layers
grid &lt;- setup.grid.1D(x.up = 0, L = L, N = N)

# Volume fractions 

por.grid &lt;- setup.prop.1D(value = por, grid = grid)
svf.grid &lt;- setup.prop.1D(value = (1-por), grid = grid)
D.grid   &lt;- setup.prop.1D(value = D, grid = grid)
Db.grid  &lt;- setup.prop.1D(value = Db, grid = grid)
v.grid   &lt;- setup.prop.1D(value = v, grid = grid)

#====================#
# Model solution     #
#====================#

# Initial conditions + simulation O2

yini &lt;- rep(0, length.out = N) 
O2   &lt;- steady.1D(y = yini, func = O2.model, nspec = 1)

# Initial conditions + simulation OC

yini &lt;- rep(0, length.out = N) 
OC   &lt;- steady.1D(y = yini, func = OC.model, nspec = 1)

# Plotting output, using S3 plot method of package rootSolve"

plot(O2, grid = grid$x.mid, xyswap = TRUE, main = "O2 concentration", 
     ylab = "depth [cm]", xlab = "", mfrow = c(1,2), type = "p", pch = 16)

plot(OC, grid = grid$x.mid, xyswap = TRUE, main = "C concentration", 
     ylab = "depth [cm]", xlab = "", mfrow = NULL)

## =============================================================================
## EXAMPLE 2: O2 in a cylindrical and spherical organism
## =============================================================================

# This example uses only the surface areas 
# in the reactive transport term

#====================#
# Model formulation  #
#====================#

# the numerical model - rate of change = transport-consumption
Cylinder.Model &lt;- function(time, O2, pars)
  return (list(
    tran.1D(C = O2, C.down = BW, D = Da, A = A.cyl, dx = dx)$dC - Q
    ))

Sphere.Model &lt;- function(time, O2, pars)
  return (list(
    tran.1D(C = O2, C.down = BW, D = Da, A = A.sphere, dx = dx)$dC - Q
    ))

#======================#
# Parameter definition #
#======================#

# parameter values

BW     &lt;- 2      # mmol/m3,  oxygen conc in surrounding water
Da     &lt;- 0.5    # cm2/d     effective diffusion coeff in organism
R      &lt;- 0.0025 # cm        radius of organism
Q      &lt;- 250000 # nM/cm3/d  oxygen consumption rate/ volume / day
L      &lt;- 0.05   # cm        length of organism (if a cylinder)

# the numerical model

N  &lt;- 40                              # layers in the body
dx &lt;- R/N                             # thickness of each layer
x.mid &lt;- seq(dx/2, by = dx, length.out = N) # distance of center to mid-layer
x.int &lt;- seq(0, by = dx, length.out = N+1)  # distance to layer interface

# Cylindrical surfaces
A.cyl   &lt;- 2*pi*x.int*L  # surface at mid-layer depth

# Spherical surfaces
A.sphere &lt;- 4*pi*x.int^2 # surface of sphere, at each mid-layer

#====================#
# Model solution     #
#====================#

# the analytical solution of cylindrical and spherical model
cylinder &lt;- function(Da, Q, BW, R, r)  BW + Q/(4*Da)*(r^2-R^2)
sphere   &lt;- function(Da, Q, BW, R, r)  BW + Q/(6*Da)*(r^2-R^2)

# solve the model numerically for a cylinder
O2.cyl &lt;- steady.1D (y = runif(N), name = "O2", 
      func = Cylinder.Model, nspec = 1, atol = 1e-10)

# solve the model numerically for a sphere
O2.sphere &lt;- steady.1D (y = runif(N), name = "O2", 
      func = Sphere.Model, nspec = 1, atol = 1e-10)

#====================#
# Plotting output    #
#====================#
# Analytical solution - "observations"
Ana.cyl   &lt;- cbind(x.mid, O2 = cylinder(Da, Q, BW, R, x.mid))
Ana.spher &lt;- cbind(x.mid, O2 = sphere(Da, Q, BW, R, x.mid))

plot(O2.cyl, O2.sphere, grid = x.mid, lwd = 2, lty = 1, col = 1:2, 
     xlab = "distance from centre, cm", 
     ylab = "mmol/m3", main = "tran.1D",
     sub = "diffusion-reaction in a cylinder and sphere",
     obs = list(Ana.cyl, Ana.spher), obspar = list(pch = 16, col =1:2))
     
legend ("topleft", lty = c(1, NA), pch = c(NA, 18),
        c("numerical approximation", "analytical solution"))
legend ("bottomright", pch = 16, lty = 1, col = 1:2,
        c("cylinder", "sphere"))

## =============================================================================
## EXAMPLE 3: O2 consumption in a spherical aggregate
## =============================================================================

# this example uses both the surface areas and the volume fractions
# in the reactive transport term

#====================#
# Model formulation  #
#====================#

Aggregate.Model &lt;- function(time, O2, pars) {

  tran &lt;- tran.1D(C = O2, C.down = C.ow.O2,
                  D = D.grid, A = A.grid,
                  VF = por.grid, dx = grid )$dC

  reac &lt;- - R.O2*(O2/(Ks+O2))*(O2&gt;0)
  return(list(dCdt = tran + reac, consumption = -reac))

}

#======================#
# Parameter definition #
#======================#

# Parameters

C.ow.O2 &lt;- 0.25     # concentration O2 water [micromol cm-3]
por     &lt;- 0.8      # porosity
D       &lt;- 400      # diffusion coefficient O2 [cm2 yr-1]
v       &lt;- 0        # advective velocity [cm yr-1]
R.O2    &lt;- 1000000  # O2 consumption rate [micromol cm-3 yr-1]
Ks      &lt;- 0.005    # O2 saturation constant [micromol cm-3]

# Grid definition
R &lt;- 0.025           # radius of the agggregate [cm]
N &lt;- 100             # number of grid layers
grid &lt;- setup.grid.1D(x.up = 0, L = R, N = N)

# Volume fractions 

por.grid &lt;- setup.prop.1D(value = por, grid = grid)
D.grid   &lt;- setup.prop.1D(value = D, grid = grid)

# Surfaces 

A.mid &lt;- 4*pi*grid$x.mid^2  # surface of sphere at middle of grid cells
A.int &lt;- 4*pi*grid$x.int^2  # surface of sphere at interface
A.grid &lt;- list(int = A.int, mid = A.mid)

#====================#
# Model solution     #
#====================#

# Numerical solution: staedy state 

O2.agg &lt;- steady.1D (runif(N), func = Aggregate.Model, nspec = 1,
                     atol = 1e-10, names = "O2")

#====================#
# Plotting output    #
#====================#

par(mfrow = c(1,1))

plot(grid$x.mid, O2.agg$y, xlab = "distance from centre, cm",
     ylab = "mmol/m3",
     main = "Diffusion-reaction of O2 in a spherical aggregate")
legend ("bottomright", pch = c(1, 18), lty = 1, col = "black",
        c("O2 concentration"))

# Similar, using S3 plot method of package rootSolve"
plot(O2.agg, grid = grid$x.mid, which = c("O2", "consumption"),
     xlab = "distance from centre, cm", ylab = c("mmol/m3","mmol/m3/d")) 

</code></pre>

<hr>
<h2 id='tran.2D'>
General Two-Dimensional Advective-Diffusive Transport
</h2><span id='topic+tran.2D'></span>

<h3>Description</h3>

<p>Estimates the transport term (i.e. the rate of change of a concentration
due to diffusion and advection) in a two-dimensional model domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tran.2D (C, C.x.up = C[1,], C.x.down = C[nrow(C),],
         C.y.up = C[,1], C.y.down = C[ ,ncol(C)],
         flux.x.up = NULL, flux.x.down = NULL, 
         flux.y.up = NULL, flux.y.down = NULL,
         a.bl.x.up = NULL, a.bl.x.down = NULL, 
         a.bl.y.up = NULL, a.bl.y.down = NULL, 
         D.grid = NULL, D.x = NULL, D.y = D.x,
         v.grid = NULL, v.x = 0, v.y = 0,
         AFDW.grid = NULL, AFDW.x = 1, AFDW.y = AFDW.x,
         VF.grid = NULL, VF.x = 1, VF.y = VF.x,
         A.grid = NULL, A.x = 1, A.y = 1,
         grid = NULL, dx = NULL, dy = NULL,
         full.check = FALSE, full.output = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tran.2D_+3A_c">C</code></td>
<td>
<p>concentration, expressed per unit volume, defined at the centre
of each grid cell; Nx*Ny matrix [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_c.x.up">C.x.up</code></td>
<td>
<p>concentration at upstream boundary in x-direction;
vector of length Ny [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_c.x.down">C.x.down</code></td>
<td>
<p>concentration at downstream boundary in x-direction;
vector of length Ny [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_c.y.up">C.y.up</code></td>
<td>
<p>concentration at upstream boundary in y-direction;
vector of length Nx [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_c.y.down">C.y.down</code></td>
<td>
<p>concentration at downstream boundary in y-direction;
vector of length Nx [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_flux.x.up">flux.x.up</code></td>
<td>
<p>flux across the upstream boundary in x-direction,
positive = INTO model domain; vector of length Ny [M/L2/T].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_flux.x.down">flux.x.down</code></td>
<td>
<p>flux across the downstream boundary in x-direction,
positive = OUT of model domain; vector of length Ny [M/L2/T].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_flux.y.up">flux.y.up</code></td>
<td>
<p>flux across the upstream boundary in y-direction,
positive = INTO model domain; vector of length Nx [M/L2/T].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_flux.y.down">flux.y.down</code></td>
<td>
<p>flux across the downstream boundary in y-direction,
positive = OUT of model domain; vector of length Nx [M/L2/T].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_a.bl.x.up">a.bl.x.up</code></td>
<td>
<p>transfer coefficient across the upstream boundary layer.
in x-direction;
</p>
<p><code>Flux=a.bl.x.up*(C.x.up-C[1,])</code>. One value [L/T].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_a.bl.x.down">a.bl.x.down</code></td>
<td>
<p>transfer coefficient across the downstream boundary
layer in x-direction;
</p>
<p><code>Flux=a.bl.x.down*(C[Nx,]-C.x.down)</code>.
One value [L/T].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_a.bl.y.up">a.bl.y.up</code></td>
<td>
<p>transfer coefficient across the upstream boundary layer.
in y-direction;
</p>
<p><code>Flux=a.bl.y.up*(C.y.up-C[,1])</code>. One value [L/T].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_a.bl.y.down">a.bl.y.down</code></td>
<td>
<p>transfer coefficient across the downstream boundary
layer in y-direction;
</p>
<p><code>Flux=a.bl.y.down*(C[,Ny]-C.y.down)</code>.
One value [L/T].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_d.grid">D.grid</code></td>
<td>
<p>diffusion coefficient defined on all grid cell
interfaces. A <code>prop.2D</code> list created by <code><a href="#topic+setup.prop.2D">setup.prop.2D</a></code> [L2/T].
See last example for creating spatially-varying diffusion coefficients.
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_d.x">D.x</code></td>
<td>
<p>diffusion coefficient in x-direction, defined on grid cell
interfaces. One value, a vector of length (Nx+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,
or a (Nx+1)* Ny matrix [L2/T].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_d.y">D.y</code></td>
<td>
<p>diffusion coefficient in y-direction, defined on grid cell
interfaces. One value, a vector of length (Ny+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,
or a Nx*(Ny+1) matrix [L2/T].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_v.grid">v.grid</code></td>
<td>
<p>advective velocity defined on all grid cell
interfaces. Can be positive (downstream flow) or negative (upstream flow).
A <code>prop.2D</code> list created by <code><a href="#topic+setup.prop.2D">setup.prop.2D</a></code> [L/T].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_v.x">v.x</code></td>
<td>
<p>advective velocity in the x-direction, defined on grid cell
interfaces. Can be positive (downstream flow) or negative (upstream flow).
One value, a vector of length (Nx+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,
or a (Nx+1)*Ny matrix [L/T].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_v.y">v.y</code></td>
<td>
<p>advective velocity in the y-direction, defined on grid cell
interfaces. Can be positive (downstream flow) or negative (upstream flow).
One value, a vector of length (Ny+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,
or a Nx*(Ny+1) matrix [L/T].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_afdw.grid">AFDW.grid</code></td>
<td>
<p>weight used in the finite difference scheme for advection
in the x- and y- direction, defined on grid cell interfaces; backward = 1,
centred = 0.5, forward = 0; default is backward.
A <code>prop.2D</code> list created by <code><a href="#topic+setup.prop.2D">setup.prop.2D</a></code> [-].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_afdw.x">AFDW.x</code></td>
<td>
<p>weight used in the finite difference scheme for advection
in the x-direction, defined on grid cell interfaces; backward = 1,
centred = 0.5, forward = 0; default is backward.
One value, a vector of length (Nx+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,
or a (Nx+1)*Ny matrix [-].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_afdw.y">AFDW.y</code></td>
<td>
<p>weight used in the finite difference scheme for advection
in the y-direction, defined on grid cell interfaces; backward = 1,
centred = 0.5, forward = 0; default is backward.
One value, a vector of length (Ny+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,
or a Nx*(Ny+1) matrix [-].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_vf.grid">VF.grid</code></td>
<td>
<p>Volume fraction. A <code>prop.2D</code> list created by
<code><a href="#topic+setup.prop.2D">setup.prop.2D</a></code> [-].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_vf.x">VF.x</code></td>
<td>
<p>Volume fraction at the grid cell interfaces in the x-direction.
One value, a vector of length (Nx+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,
or a (Nx+1)*Ny matrix [-].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_vf.y">VF.y</code></td>
<td>
<p>Volume fraction at the grid cell interfaces in the y-direction.
One value, a vector of length (Ny+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,
or a Nx*(Ny+1) matrix [-].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_a.grid">A.grid</code></td>
<td>
<p>Interface area. A <code>prop.2D</code> list created by
<code><a href="#topic+setup.prop.2D">setup.prop.2D</a></code> [L2].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_a.x">A.x</code></td>
<td>
<p>Interface area defined at the grid cell interfaces in
the x-direction. One value, a vector of length (Nx+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,
or a (Nx+1)*Ny matrix [L2].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_a.y">A.y</code></td>
<td>
<p>Interface area defined at the grid cell interfaces in
the y-direction. One value, a vector of length (Ny+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,
or a Nx*(Ny+1) matrix [L2].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_dx">dx</code></td>
<td>
<p>distance between adjacent cell interfaces in the x-direction
(thickness of grid cells). One value or vector of length Nx [L].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_dy">dy</code></td>
<td>
<p>distance between adjacent cell interfaces in the y-direction
(thickness of grid cells). One value or vector of length Ny [L].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_grid">grid</code></td>
<td>
<p>discretization grid, a list containing at least elements
<code>dx</code>, <code>dx.aux</code>, <code>dy</code>, <code>dy.aux</code>
(see <code><a href="#topic+setup.grid.2D">setup.grid.2D</a></code>) [L].
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_full.check">full.check</code></td>
<td>
<p>logical flag enabling a full check of the consistency
of the arguments (default = <code>FALSE</code>; <code>TRUE</code> slows down
execution by 50 percent).
</p>
</td></tr>
<tr><td><code id="tran.2D_+3A_full.output">full.output</code></td>
<td>
<p>logical flag enabling a full return of the output
(default = <code>FALSE</code>; <code>TRUE</code> slows down execution by 20 percent).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <b>boundary conditions</b> are either
</p>

<ul>
<li><p> (1) zero-gradient
</p>
</li>
<li><p> (2) fixed concentration
</p>
</li>
<li><p> (3) convective boundary layer
</p>
</li>
<li><p> (4) fixed flux
</p>
</li></ul>

<p>This is also the order of priority. The zero gradient is the default,
the fixed flux overrules all other.
</p>


<h3>Value</h3>

<p>a list containing:
</p>
<table>
<tr><td><code>dC</code></td>
<td>
<p>the rate of change of the concentration C due to transport,
defined in the centre of each grid cell, a Nx*Ny matrix. [M/L3/T].
</p>
</td></tr>
<tr><td><code>C.x.up</code></td>
<td>
<p>concentration at the upstream interface in x-direction.
A vector of length Ny [M/L3]. Only when <code>full.output = TRUE</code>.
</p>
</td></tr>
<tr><td><code>C.x.down</code></td>
<td>
<p>concentration at the downstream interface in x-direction.
A vector of length Ny [M/L3]. Only when <code>full.output = TRUE</code>.
</p>
</td></tr>
<tr><td><code>C.y.up</code></td>
<td>
<p>concentration at the the upstream interface in y-direction.
A vector of length Nx [M/L3].  Only when <code>full.output = TRUE</code>.
</p>
</td></tr>
<tr><td><code>C.y.down</code></td>
<td>
<p>concentration at the downstream interface in y-direction.
A vector of length Nx [M/L3]. Only when <code>full.output = TRUE</code>.
</p>
</td></tr>
<tr><td><code>x.flux</code></td>
<td>
<p>flux across the interfaces in x-direction of the grid cells.
A (Nx+1)*Ny matrix  [M/L2/T]. Only when <code>full.output = TRUE</code>.
</p>
</td></tr>
<tr><td><code>y.flux</code></td>
<td>
<p>flux across the interfaces in y-direction of the grid cells.
A Nx*(Ny+1) matrix [M/L2/T].  Only when <code>full.output = TRUE</code>.
</p>
</td></tr>
<tr><td><code>flux.x.up</code></td>
<td>
<p>flux across the upstream boundary in x-direction,
positive = INTO model domain. A vector of length Ny [M/L2/T].
</p>
</td></tr>
<tr><td><code>flux.x.down</code></td>
<td>
<p>flux across the downstream boundary in x-direction,
positive = OUT of model domain. A vector of length Ny [M/L2/T].
</p>
</td></tr>
<tr><td><code>flux.y.up</code></td>
<td>
<p>flux across the upstream boundary in y-direction,
positive = INTO model domain. A vector of length Nx [M/L2/T].
</p>
</td></tr>
<tr><td><code>flux.y.down</code></td>
<td>
<p>flux across the downstream boundary in y-direction,
positive = OUT of model domain. A vector of length Nx [M/L2/T].
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>It is much more efficient to use the <em>grid</em> input rather than 
vectors or single numbers. 
</p>
<p>Thus: to optimise the code, use <a href="#topic+setup.grid.2D">setup.grid.2D</a> to create the 
<code>grid</code>, and use <a href="#topic+setup.prop.2D">setup.prop.2D</a> to create <code>D.grid</code>,
<code>v.grid</code>, <code>AFDW.grid</code>, <code>VF.grid</code>, and <code>A.grid</code>,
even if the values are 1 or remain constant.
</p>
<p>There is no provision (yet) to deal with <em>cross-diffusion</em>. 
Set <code>D.x</code> and <code>D.y</code> different only if cross-diffusion effects
are unimportant. 
</p>


<h3>Author(s)</h3>

<p>Filip Meysman &lt;filip.meysman@nioz.nl&gt;,
Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>Soetaert and Herman, 2009. a practical guide to ecological modelling -
using R as a simulation platform. Springer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tran.polar">tran.polar</a></code> for a discretisation of 2-D transport equations 
in polar coordinates
</p>
<p><code><a href="#topic+tran.1D">tran.1D</a></code>,   <code><a href="#topic+tran.3D">tran.3D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =============================================================================
## Testing the functions
## =============================================================================
# Parameters
F        &lt;- 100             # input flux [micromol cm-2 yr-1]
por      &lt;- 0.8             # constant porosity
D        &lt;- 400             # mixing coefficient [cm2 yr-1]
v        &lt;- 1               # advective velocity [cm yr-1]

# Grid definition
x.N &lt;- 4   # number of cells in x-direction
y.N &lt;- 6   # number of cells in y-direction
x.L &lt;- 8   # domain size x-direction [cm]
y.L &lt;- 24  # domain size y-direction [cm]
dx  &lt;- x.L/x.N             # cell size x-direction [cm]
dy  &lt;- y.L/y.N             # cell size y-direction [cm]
 
# Intial conditions 
C &lt;- matrix(nrow = x.N, ncol = y.N, data = 0, byrow = FALSE)

# Boundary conditions: fixed concentration  
C.x.up   &lt;- rep(1, times = y.N)
C.x.down &lt;- rep(0, times = y.N)
C.y.up   &lt;- rep(1, times = x.N)
C.y.down &lt;- rep(0, times = x.N)

# Only diffusion 
tran.2D(C = C, D.x = D, D.y = D, v.x = 0, v.y = 0,
  VF.x = por, VF.y = por, dx = dx, dy = dy,
  C.x.up = C.x.up, C.x.down = C.x.down,
  C.y.up = C.y.up, C.y.down = C.y.down, full.output = TRUE)

# Strong advection, backward (default), central and forward 
#finite difference schemes 
tran.2D(C = C, D.x = D, v.x = 100*v, 
  VF.x = por, dx = dx, dy = dy,
  C.x.up = C.x.up, C.x.down = C.x.down, 
  C.y.up = C.y.up, C.y.down = C.y.down)
  
tran.2D(AFDW.x = 0.5, C = C, D.x = D, v.x = 100*v, 
  VF.x = por, dx = dx, dy = dy,
  C.x.up = C.x.up, C.x.down = C.x.down, 
  C.y.up = C.y.up, C.y.down = C.y.down)

tran.2D(AFDW.x = 0, C = C, D.x = D, v.x = 100*v, 
  VF.x = por, dx = dx, dy = dy,
  C.x.up = C.x.up, C.x.down = C.x.down, 
  C.y.up = C.y.up, C.y.down = C.y.down)

# Boundary conditions: fixed fluxes 

flux.x.up &lt;- rep(200, times = y.N)
flux.x.down &lt;- rep(-200, times = y.N)
flux.y.up &lt;- rep(200, times = x.N)
flux.y.down &lt;- rep(-200, times = x.N)
tran.2D(C = C, D.x = D, v.x = 0, 
  VF.x = por, dx = dx, dy = dy,
  flux.x.up = flux.x.up, flux.x.down = flux.x.down,
  flux.y.up = flux.y.up, flux.y.down = flux.y.down)

# Boundary conditions: convective boundary layer on all sides

a.bl &lt;- 800   # transfer coefficient
C.x.up &lt;- rep(1, times = (y.N)) # fixed conc at boundary layer
C.y.up &lt;- rep(1, times = (x.N)) # fixed conc at boundary layer
tran.2D(full.output = TRUE, C = C, D.x = D, v.x = 0, 
  VF.x = por, dx = dx, dy = dy, 
  C.x.up   = C.x.up, a.bl.x.up = a.bl, 
  C.x.down = C.x.up, a.bl.x.down = a.bl, 
  C.y.up   = C.y.up, a.bl.y.up = a.bl,
  C.y.down = C.y.up, a.bl.y.down = a.bl)

# Runtime test with and without argument checking

n.iterate &lt;-500

test1 &lt;- function() {
  for (i in 1:n.iterate )
    ST &lt;- tran.2D(full.check = TRUE, C = C, D.x = D, 
      v.x = 0, VF.x = por, dx = dx, dy = dy,
      C.x.up = C.x.up, a.bl.x.up = a.bl, C.x.down = C.x.down)
} 
system.time(test1())

test2 &lt;- function() {
  for (i in 1:n.iterate )
    ST &lt;- tran.2D(full.output = TRUE, C = C, D.x = D, 
      v.x = 0, VF.x = por, dx = dx, dy = dy,
      C.x.up = C.x.up, a.bl.x.up = a.bl, C.x.down = C.x.down)
} 
system.time(test2())

test3 &lt;- function() {
  for (i in 1:n.iterate )
    ST &lt;- tran.2D(full.output = TRUE, full.check = TRUE, C = C,
      D.x = D, v.x = 0, VF.x = por, dx = dx, dy = dy,
      C.x.up = C.x.up, a.bl.x.up = a.bl, C.x.down = C.x.down)
} 
system.time(test3())

## =============================================================================
## A 2-D model with diffusion in x- and y direction and first-order
## consumption - unefficient implementation
## =============================================================================

N     &lt;- 51          # number of grid cells
XX    &lt;- 10           # total size
dy    &lt;- dx &lt;- XX/N  # grid size
Dy    &lt;- Dx &lt;- 0.1   # diffusion coeff, X- and Y-direction
r     &lt;- 0.005       # consumption rate
ini   &lt;- 1           # initial value at x=0

N2  &lt;- ceiling(N/2)
X   &lt;- seq (dx, by = dx, len = (N2-1))
X   &lt;- c(-rev(X), 0, X)

# The model equations

Diff2D &lt;- function (t, y, parms)  {

 CONC  &lt;- matrix(nrow = N, ncol = N, y)
 dCONC &lt;- tran.2D(CONC, D.x = Dx, D.y = Dy, dx = dx, dy = dy)$dC + r * CONC

 return (list(dCONC))

}

# initial condition: 0 everywhere, except in central point
y &lt;- matrix(nrow = N, ncol = N, data = 0)
y[N2, N2] &lt;- ini  # initial concentration in the central point...

# solve for 10 time units
times &lt;- 0:10
out &lt;- ode.2D (y = y, func = Diff2D, t = times, parms = NULL,
                dim = c(N,N), lrw = 160000)

pm &lt;- par (mfrow = c(2, 2))

# Compare solution with analytical solution...
for (i in seq(2, 11, by = 3))  {
  tt   &lt;- times[i]
  mat  &lt;-  matrix(nrow = N, ncol = N, 
                  data = subset(out, time == tt))
  plot(X, mat[N2,], type = "l", main = paste("time=", times[i]),
       ylab = "Conc", col = "red")
  ana &lt;- ini*dx^2/(4*pi*Dx*tt)*exp(r*tt-X^2/(4*Dx*tt))
  points(X, ana, pch = "+")
}

legend ("bottom", col = c("red","black"), lty = c(1, NA), 
  pch = c(NA, "+"), c("tran.2D", "exact"))
par("mfrow" = pm )



## =============================================================================
## A 2-D model with diffusion in x- and y direction and first-order
## consumption - more efficient implementation, specifying ALL 2-D grids
## =============================================================================

N     &lt;- 51          # number of grid cells
Dy    &lt;- Dx &lt;- 0.1   # diffusion coeff, X- and Y-direction
r     &lt;- 0.005       # consumption rate
ini   &lt;- 1           # initial value at x=0

x.grid    &lt;- setup.grid.1D(x.up = -5, x.down = 5, N = N)
y.grid    &lt;- setup.grid.1D(x.up = -5, x.down = 5, N = N)
grid2D    &lt;- setup.grid.2D(x.grid, y.grid)

D.grid    &lt;- setup.prop.2D(value = Dx, y.value = Dy, grid = grid2D)
v.grid    &lt;- setup.prop.2D(value = 0, grid = grid2D)
A.grid    &lt;- setup.prop.2D(value = 1, grid = grid2D)
AFDW.grid &lt;- setup.prop.2D(value = 1, grid = grid2D)
VF.grid   &lt;- setup.prop.2D(value = 1, grid = grid2D)

# The model equations - using the grids

Diff2Db &lt;- function (t, y, parms)  {

   CONC  &lt;- matrix(nrow = N, ncol = N, data = y)

   dCONC &lt;- tran.2D(CONC, grid = grid2D, D.grid = D.grid, 
      A.grid = A.grid, VF.grid = VF.grid, AFDW.grid = AFDW.grid, 
      v.grid = v.grid)$dC + r * CONC
  
  return (list(dCONC))
}

# initial condition: 0 everywhere, except in central point
y &lt;- matrix(nrow = N, ncol = N, data = 0)
y[N2,N2] &lt;- ini  # initial concentration in the central point...

# solve for 8 time units
times &lt;- 0:8
outb &lt;- ode.2D (y = y, func = Diff2Db, t = times, parms = NULL,
                dim = c(N, N), lrw = 160000)

image(outb, ask = FALSE, mfrow = c(3, 3), main = paste("time", times))

## =============================================================================
## Same 2-D model, but now with spatially-variable diffusion coefficients
## =============================================================================

N     &lt;- 51          # number of grid cells
r     &lt;- 0.005       # consumption rate
ini   &lt;- 1           # initial value at x=0
N2    &lt;- ceiling(N/2)

D.grid &lt;- list()

# Diffusion on x-interfaces
D.grid$x.int &lt;- matrix(nrow = N+1, ncol = N, data = runif(N*(N+1)))

# Diffusion on y-interfaces
D.grid$y.int &lt;- matrix(nrow = N, ncol = N+1, data = runif(N*(N+1)))

dx &lt;- 10/N
dy &lt;- 10/N

# The model equations

Diff2Dc &lt;- function (t, y, parms)  {

   CONC  &lt;- matrix(nrow = N, ncol = N, data = y)

   dCONC &lt;- tran.2D(CONC, dx = dx, dy = dy, D.grid = D.grid)$dC + r * CONC

  return (list(dCONC))
}

# initial condition: 0 everywhere, except in central point
y &lt;- matrix(nrow = N, ncol = N, data = 0)
y[N2, N2] &lt;- ini  # initial concentration in the central point...

# solve for 8 time units
times &lt;- 0:8
outc &lt;- ode.2D (y = y, func = Diff2Dc, t = times, parms = NULL,
                dim = c(N, N), lrw = 160000)

outtimes &lt;- c(1, 3, 5, 7)
image(outc, ask = FALSE, mfrow = c(2, 2), main = paste("time", outtimes),
      legend = TRUE, add.contour = TRUE, subset = time %in% outtimes)

</code></pre>

<hr>
<h2 id='tran.3D'>
General Three-Dimensional Advective-Diffusive Transport
</h2><span id='topic+tran.3D'></span>

<h3>Description</h3>

<p>Estimates the transport term (i.e. the rate of change of a concentration
due to diffusion and advection) in a three-dimensional rectangular
model domain.
</p>
<p>Do not use with too many boxes!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tran.3D (C, C.x.up = C[1,,], C.x.down = C[dim(C)[1],,],
         C.y.up = C[ ,1, ],  C.y.down=C[ ,dim(C)[2], ],
         C.z.up = C[ , ,1],  C.z.down=C[ , ,dim(C)[3]],
         flux.x.up = NULL, flux.x.down = NULL,
         flux.y.up = NULL, flux.y.down = NULL,
         flux.z.up = NULL, flux.z.down = NULL,
         a.bl.x.up = NULL, a.bl.x.down = NULL, 
         a.bl.y.up = NULL, a.bl.y.down = NULL, 
         a.bl.z.up = NULL, a.bl.z.down = NULL, 
         D.grid = NULL, D.x = NULL, D.y = D.x, D.z = D.x,
         v.grid = NULL, v.x = 0, v.y = 0, v.z = 0,
         AFDW.grid = NULL, AFDW.x = 1, AFDW.y = AFDW.x, AFDW.z = AFDW.x,
         VF.grid = NULL, VF.x = 1, VF.y = VF.x, VF.z = VF.x,
         A.grid = NULL, A.x = 1, A.y = 1, A.z = 1,
         grid = NULL, dx = NULL, dy = NULL, dz = NULL,
         full.check = FALSE, full.output = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tran.3D_+3A_c">C</code></td>
<td>
<p>concentration, expressed per unit volume, defined at the centre
of each grid cell; Nx*Ny*Nz array [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_c.x.up">C.x.up</code></td>
<td>
<p>concentration at upstream boundary in x-direction;
matrix of dimensions Ny*Nz [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_c.x.down">C.x.down</code></td>
<td>
<p>concentration at downstream boundary in x-direction;
matrix of dimensions Ny*Nz [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_c.y.up">C.y.up</code></td>
<td>
<p>concentration at upstream boundary in y-direction;
matrix of dimensions Nx*Nz [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_c.y.down">C.y.down</code></td>
<td>
<p>concentration at downstream boundary in y-direction;
matrix of dimensions Nx*Nz [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_c.z.up">C.z.up</code></td>
<td>
<p>concentration at upstream boundary in z-direction;
matrix of dimensions Nx*Ny [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_c.z.down">C.z.down</code></td>
<td>
<p>concentration at downstream boundary in z-direction;
matrix of dimensions Nx*Ny [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_flux.x.up">flux.x.up</code></td>
<td>
<p>flux across the upstream boundary in x-direction,
positive = INTO model domain; matrix of dimensions Ny*Nz [M/L2/T].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_flux.x.down">flux.x.down</code></td>
<td>
<p>flux across the downstream boundary in x-direction,
positive = OUT of model domain; matrix of dimensions Ny*Nz [M/L2/T].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_flux.y.up">flux.y.up</code></td>
<td>
<p>flux across the upstream boundary in y-direction,
positive = INTO model domain; matrix of dimensions Nx*Nz [M/L2/T].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_flux.y.down">flux.y.down</code></td>
<td>
<p>flux across the downstream boundary in y-direction,
positive = OUT of model domain; matrix of dimensions Nx*Nz [M/L2/T].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_flux.z.up">flux.z.up</code></td>
<td>
<p>flux across the upstream boundary in z-direction,
positive = INTO model domain; matrix of dimensions Nx*Ny [M/L2/T].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_flux.z.down">flux.z.down</code></td>
<td>
<p>flux across the downstream boundary in z-direction,
positive = OUT of model domain; matrix of dimensions Nx*Ny [M/L2/T].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_a.bl.x.up">a.bl.x.up</code></td>
<td>
<p>transfer coefficient across the upstream boundary layer.
in x-direction
</p>
<p><code>Flux=a.bl.x.up*(C.x.up-C[1,,])</code>. One value [L/T].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_a.bl.x.down">a.bl.x.down</code></td>
<td>
<p>transfer coefficient across the downstream boundary
layer in x-direction;
</p>
<p><code>Flux=a.bl.x.down*(C[Nx,,]-C.x.down)</code>.
One value [L/T].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_a.bl.y.up">a.bl.y.up</code></td>
<td>
<p>transfer coefficient across the upstream boundary layer.
in y-direction
</p>
<p><code>Flux=a.bl.y.up*(C.y.up-C[,1,])</code>. One value [L/T].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_a.bl.y.down">a.bl.y.down</code></td>
<td>
<p>transfer coefficient across the downstream boundary
layer in y-direction;
</p>
<p><code>Flux=a.bl.y.down*(C[,Ny,]-C.y.down)</code>.
One value [L/T].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_a.bl.z.up">a.bl.z.up</code></td>
<td>
<p>transfer coefficient across the upstream boundary layer.
in y-direction
</p>
<p><code>Flux=a.bl.y.up*(C.y.up-C[,,1])</code>. One value [L/T].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_a.bl.z.down">a.bl.z.down</code></td>
<td>
<p>transfer coefficient across the downstream boundary
layer in z-direction;
</p>
<p><code>Flux=a.bl.z.down*(C[,,Nz]-C.z.down)</code>.
One value [L/T].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_d.grid">D.grid</code></td>
<td>
<p>diffusion coefficient defined on all grid cell
interfaces.
Should contain elements x.int, y.int, z.int, arrays with the values on the
interfaces in x, y and z-direction, and with dimensions
(Nx+1)*Ny*Nz, Nx*(Ny+1)*Nz and Nx*Ny*(Nz+1) respectively. [L2/T].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_d.x">D.x</code></td>
<td>
<p>diffusion coefficient in x-direction, defined on grid cell
interfaces. One value, a vector of length (Nx+1),
or a (Nx+1)* Ny *Nz array [L2/T].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_d.y">D.y</code></td>
<td>
<p>diffusion coefficient in y-direction, defined on grid cell
interfaces. One value, a vector of length (Ny+1),
or a Nx*(Ny+1)*Nz array [L2/T].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_d.z">D.z</code></td>
<td>
<p>diffusion coefficient in z-direction, defined on grid cell
interfaces. One value, a vector of length (Nz+1),
or a Nx*Ny*(Nz+1) array [L2/T].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_v.grid">v.grid</code></td>
<td>
<p>advective velocity defined on all grid cell
interfaces. Can be positive (downstream flow) or negative (upstream flow).
Should contain elements x.int, y.int, z.int, arrays with the values on the
interfaces in x, y and z-direction, and with dimensions
(Nx+1)*Ny*Nz, Nx*(Ny+1)*Nz and Nx*Ny*(Nz+1) respectively.  [L/T].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_v.x">v.x</code></td>
<td>
<p>advective velocity in the x-direction, defined on grid cell
interfaces. Can be positive (downstream flow) or negative (upstream flow).
One value, a vector of length (Nx+1),
or a (Nx+1)*Ny*Nz array [L/T].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_v.y">v.y</code></td>
<td>
<p>advective velocity in the y-direction, defined on grid cell
interfaces. Can be positive (downstream flow) or negative (upstream flow).
One value, a vector of length (Ny+1),
or a Nx*(Ny+1)*Nz array [L/T].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_v.z">v.z</code></td>
<td>
<p>advective velocity in the z-direction, defined on grid cell
interfaces. Can be positive (downstream flow) or negative (upstream flow).
One value, a vector of length (Nz+1),
or a Nx*Ny*(Nz+1) array [L/T].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_afdw.grid">AFDW.grid</code></td>
<td>
<p>weight used in the finite difference scheme for advection
in the x-direction, defined on grid cell interfaces; backward = 1,
centred = 0.5, forward = 0; default is backward.
Should contain elements x.int, y.int, z.int, arrays with the values on the
interfaces in x, y and z-direction, and with dimensions
(Nx+1)*Ny*Nz, Nx*(Ny+1)*Nz and Nx*Ny*(Nz+1) respectively. [-].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_afdw.x">AFDW.x</code></td>
<td>
<p>weight used in the finite difference scheme for advection
in the x-direction, defined on grid cell interfaces; backward = 1,
centred = 0.5, forward = 0; default is backward.
One value, a vector of length (Nx+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,
or a (Nx+1)*Ny*Nz array [-].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_afdw.y">AFDW.y</code></td>
<td>
<p>weight used in the finite difference scheme for advection
in the y-direction, defined on grid cell interfaces; backward = 1,
centred = 0.5, forward = 0; default is backward.
One value, a vector of length (Ny+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,
or a Nx*(Ny+1)*Nz array [-].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_afdw.z">AFDW.z</code></td>
<td>
<p>weight used in the finite difference scheme for advection
in the z-direction, defined on grid cell interfaces; backward = 1,
centred = 0.5, forward = 0; default is backward.
One value, a vector of length (Nz+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,
or a Nx*Ny*(Nz+1) array [-].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_vf.grid">VF.grid</code></td>
<td>
<p>Volume fraction. A list.
Should contain elements x.int, y.int, z.int, arrays with the values on the
interfaces in x, y and z-direction, and with dimensions
(Nx+1)*Ny*Nz, Nx*(Ny+1)*Nz and Nx*Ny*(Nz+1) respectively. [-].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_vf.x">VF.x</code></td>
<td>
<p>Volume fraction at the grid cell interfaces in the x-direction.
One value, a vector of length (Nx+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,
or a (Nx+1)*Ny*Nz array [-].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_vf.y">VF.y</code></td>
<td>
<p>Volume fraction at the grid cell interfaces in the y-direction.
One value, a vector of length (Ny+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,
or a Nx*(Ny+1)*Nz array [-].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_vf.z">VF.z</code></td>
<td>
<p>Volume fraction at the grid cell interfaces in the z-direction.
One value, a vector of length (Nz+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,
or a Nx*Ny*(Nz+1) array [-].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_a.grid">A.grid</code></td>
<td>
<p>Interface area, a list.
Should contain elements x.int, y.int, z.int, arrays with the values on the
interfaces in x, y and z-direction, and with dimensions
(Nx+1)*Ny*Nz, Nx*(Ny+1)*Nz and Nx*Ny*(Nz+1) respectively. [L2].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_a.x">A.x</code></td>
<td>
<p>Interface area defined at the grid cell interfaces in
the x-direction. One value, a vector of length (Nx+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,
or a (Nx+1)*Ny*Nz array [L2].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_a.y">A.y</code></td>
<td>
<p>Interface area defined at the grid cell interfaces in
the y-direction. One value, a vector of length (Ny+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,
or a Nx*(Ny+1)*Nz array [L2].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_a.z">A.z</code></td>
<td>
<p>Interface area defined at the grid cell interfaces in
the z-direction. One value, a vector of length (Nz+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,
or a Nx*Ny*(Nz+1) array [L2].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_dx">dx</code></td>
<td>
<p>distance between adjacent cell interfaces in the x-direction
(thickness of grid cells). One value or vector of length Nx [L].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_dy">dy</code></td>
<td>
<p>distance between adjacent cell interfaces in the y-direction
(thickness of grid cells). One value or vector of length Ny [L].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_dz">dz</code></td>
<td>
<p>distance between adjacent cell interfaces in the z-direction
(thickness of grid cells). One value or vector of length Nz [L].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_grid">grid</code></td>
<td>
<p>discretization grid, a list containing at least elements
<code>dx</code>, <code>dx.aux</code>, <code>dy</code>, <code>dy.aux</code>, <code>dz</code>, <code>dz.aux</code>
(see <code><a href="#topic+setup.grid.2D">setup.grid.2D</a></code>) [L].
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_full.check">full.check</code></td>
<td>
<p>logical flag enabling a full check of the consistency
of the arguments (default = <code>FALSE</code>; <code>TRUE</code> slows down
execution by 50 percent).
</p>
</td></tr>
<tr><td><code id="tran.3D_+3A_full.output">full.output</code></td>
<td>
<p>logical flag enabling a full return of the output
(default = <code>FALSE</code>; <code>TRUE</code> slows down execution by 20 percent).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Do not use this with too large grid.
</p>
<p>The <b>boundary conditions</b> are either
</p>

<ul>
<li><p> (1) zero-gradient
</p>
</li>
<li><p> (2) fixed concentration
</p>
</li>
<li><p> (3) convective boundary layer
</p>
</li>
<li><p> (4) fixed flux
</p>
</li></ul>

<p>This is also the order of priority. The zero gradient is the default,
the fixed flux overrules all other.
</p>


<h3>Value</h3>

<p>a list containing:
</p>
<table>
<tr><td><code>dC</code></td>
<td>
<p>the rate of change of the concentration C due to transport,
defined in the centre of each grid cell, an array with dimension
Nx*Ny*Nz [M/L3/T].
</p>
</td></tr>
<tr><td><code>C.x.up</code></td>
<td>
<p>concentration at the upstream interface in x-direction.
A matrix of dimension Ny*Nz [M/L3]. Only when <code>full.output = TRUE</code>.
</p>
</td></tr>
<tr><td><code>C.x.down</code></td>
<td>
<p>concentration at the downstream interface in x-direction.
A matrix of dimension Ny*Nz [M/L3]. Only when <code>full.output = TRUE</code>.
</p>
</td></tr>
<tr><td><code>C.y.up</code></td>
<td>
<p>concentration at the upstream interface in y-direction.
A matrix of dimension Nx*Nz [M/L3].  Only when <code>full.output = TRUE</code>.
</p>
</td></tr>
<tr><td><code>C.y.down</code></td>
<td>
<p>concentration at the downstream interface in y-direction.
A matrix of dimension Nx*Nz [M/L3]. Only when <code>full.output = TRUE</code>.
</p>
</td></tr>
<tr><td><code>C.z.up</code></td>
<td>
<p>concentration at the upstream interface in z-direction.
A matrix of dimension Nx*Ny [M/L3].  Only when <code>full.output = TRUE</code>.
</p>
</td></tr>
<tr><td><code>C.z.down</code></td>
<td>
<p>concentration at the downstream interface in z-direction.
A matrix of dimension Nx*Ny [M/L3]. Only when <code>full.output = TRUE</code>.
</p>
</td></tr>
<tr><td><code>x.flux</code></td>
<td>
<p>flux across the interfaces in x-direction of the grid cells.
A (Nx+1)*Ny*Nz array [M/L2/T]. Only when <code>full.output = TRUE</code>.
</p>
</td></tr>
<tr><td><code>y.flux</code></td>
<td>
<p>flux across the interfaces in y-direction of the grid cells.
A Nx*(Ny+1)*Nz array [M/L2/T].  Only when <code>full.output = TRUE</code>.
</p>
</td></tr>
<tr><td><code>z.flux</code></td>
<td>
<p>flux across the interfaces in z-direction of the grid cells.
A Nx*Ny*(Nz+1) array [M/L2/T].  Only when <code>full.output = TRUE</code>.
</p>
</td></tr>
<tr><td><code>flux.x.up</code></td>
<td>
<p>flux across the upstream boundary in x-direction,
positive = INTO model domain. A matrix of dimension Ny*Nz [M/L2/T].
</p>
</td></tr>
<tr><td><code>flux.x.down</code></td>
<td>
<p>flux across the downstream boundary in x-direction,
positive = OUT of model domain. A matrix of dimension Ny*Nz [M/L2/T].
</p>
</td></tr>
<tr><td><code>flux.y.up</code></td>
<td>
<p>flux across the upstream boundary in y-direction,
positive = INTO model domain. A matrix of dimension Nx*Nz [M/L2/T].
</p>
</td></tr>
<tr><td><code>flux.y.down</code></td>
<td>
<p>flux across the downstream boundary in y-direction,
positive = OUT of model domain. A matrix of dimension Nx*Nz [M/L2/T].
</p>
</td></tr>
<tr><td><code>flux.z.up</code></td>
<td>
<p>flux across the upstream boundary in z-direction,
positive = INTO model domain. A matrix of dimension Nx*Ny [M/L2/T].
</p>
</td></tr>
<tr><td><code>flux.z.down</code></td>
<td>
<p>flux across the downstream boundary in z-direction,
positive = OUT of model domain. A matrix of dimension Nx*Ny [M/L2/T].
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Filip Meysman &lt;filip.meysman@nioz.nl&gt;,
Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>Soetaert and Herman, a practical guide to ecological modelling - using R as
a simulation platform, 2009. Springer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tran.cylindrical">tran.cylindrical</a></code>, <code><a href="#topic+tran.spherical">tran.spherical</a></code> 
for a discretisation of 3-D transport equations in cylindrical and 
spherical coordinates
</p>
<p><code><a href="#topic+tran.1D">tran.1D</a></code>,   <code><a href="#topic+tran.2D">tran.2D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =============================================================================
## Diffusion in 3-D; imposed boundary conditions
## =============================================================================
diffusion3D &lt;- function(t, Y, par) {

  yy    &lt;- array(dim = c(n, n, n), data = Y)  # vector to 3-D array
  dY    &lt;- -r * yy                            # consumption
  BND   &lt;- matrix(nrow = n, ncol = n, 1)      # boundary concentration

  dY &lt;- dY + tran.3D(C = yy,
      C.x.up = BND, C.y.up = BND, C.z.up = BND,
      C.x.down = BND, C.y.down = BND, C.z.down = BND,
      D.x = Dx, D.y = Dy, D.z = Dz,
      dx = dx, dy = dy, dz = dz, full.check = TRUE)$dC
  return(list(dY))
}

# parameters
dy   &lt;- dx &lt;- dz &lt;- 1   # grid size
Dy   &lt;- Dx &lt;- Dz &lt;- 1   # diffusion coeff, X- and Y-direction
r    &lt;- 0.025     # consumption rate

n  &lt;- 10
y  &lt;- array(dim = c(n, n, n), data = 10.)

print(system.time(
  ST3 &lt;- steady.3D(y, func = diffusion3D, parms = NULL, 
                 pos = TRUE, dimens = c(n, n, n),
                 lrw = 2000000, verbose = TRUE)
))

pm &lt;- par(mfrow = c(1,1))
y &lt;- array(dim = c(n, n, n), data = ST3$y)
filled.contour(y[ , ,n/2], color.palette = terrain.colors)

# a selection in the x-direction
image(ST3, mfrow = c(2, 2), add.contour = TRUE, legend = TRUE,
      dimselect = list(x = c(1, 4, 8, 10)))

par(mfrow = pm)
</code></pre>

<hr>
<h2 id='tran.cylindrical'>
Diffusive Transport in cylindrical (r, theta, z) and spherical (r, theta, phi)
coordinates.
</h2><span id='topic+tran.cylindrical'></span><span id='topic+tran.spherical'></span>

<h3>Description</h3>

<p>Estimates the transport term (i.e. the rate of change of a concentration
due to diffusion) in a cylindrical (r, theta, z) or spherical (r, theta, phi) 
coordinate system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tran.cylindrical (C, C.r.up = NULL, C.r.down = NULL, 
                  C.theta.up = NULL, C.theta.down = NULL, 
                  C.z.up = NULL, C.z.down = NULL, 
                  flux.r.up = NULL, flux.r.down = NULL, 
                  flux.theta.up = NULL, flux.theta.down = NULL,          
                  flux.z.up = NULL, flux.z.down = NULL, 
                  cyclicBnd = NULL,
                  D.r = NULL, D.theta = D.r, D.z = D.r, 
                  r = NULL, theta = NULL, z = NULL)

tran.spherical (C, C.r.up = NULL, C.r.down = NULL, 
                C.theta.up = NULL, C.theta.down = NULL, 
                C.phi.up = NULL, C.phi.down = NULL, 
                flux.r.up = NULL, flux.r.down = NULL, 
                flux.theta.up = NULL, flux.theta.down = NULL,          
                flux.phi.up = NULL, flux.phi.down = NULL, 
                cyclicBnd = NULL,
                D.r = NULL, D.theta = D.r, D.phi = D.r, 
                r = NULL, theta = NULL, phi = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tran.cylindrical_+3A_c">C</code></td>
<td>
<p>concentration, expressed per unit volume, defined at the centre
of each grid cell; Nr*Nteta*Nz (cylindrica) or Nr*Ntheta*Nphi (spherical
coordinates) array [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.cylindrical_+3A_c.r.up">C.r.up</code></td>
<td>
<p>concentration at upstream boundary in r(x)-direction; 
one value [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.cylindrical_+3A_c.r.down">C.r.down</code></td>
<td>
<p>concentration at downstream boundary in r(x)-direction;
one value [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.cylindrical_+3A_c.theta.up">C.theta.up</code></td>
<td>
<p>concentration at upstream boundary in theta-direction;
one value [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.cylindrical_+3A_c.theta.down">C.theta.down</code></td>
<td>
<p>concentration at downstream boundary in theta-direction;
one value [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.cylindrical_+3A_c.z.up">C.z.up</code></td>
<td>
<p>concentration at upstream boundary in z-direction (cylindrical
coordinates); one value [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.cylindrical_+3A_c.z.down">C.z.down</code></td>
<td>
<p>concentration at downstream boundary in z-direction(cylindrical
coordinates); one value [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.cylindrical_+3A_c.phi.up">C.phi.up</code></td>
<td>
<p>concentration at upstream boundary in phi-direction (spherical
coordinates); one value [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.cylindrical_+3A_c.phi.down">C.phi.down</code></td>
<td>
<p>concentration at downstream boundary in phi-direction(spherical
coordinates); one value [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.cylindrical_+3A_flux.r.up">flux.r.up</code></td>
<td>
<p>flux across the upstream boundary in r-direction,
positive = INTO model domain; one value [M/L2/T].
</p>
</td></tr>
<tr><td><code id="tran.cylindrical_+3A_flux.r.down">flux.r.down</code></td>
<td>
<p>flux across the downstream boundary in r-direction,
positive = OUT of model domain; one value [M/L2/T].
</p>
</td></tr>
<tr><td><code id="tran.cylindrical_+3A_flux.theta.up">flux.theta.up</code></td>
<td>
<p>flux across the upstream boundary in theta-direction,
positive = INTO model domain; one value [M/L2/T].
</p>
</td></tr>
<tr><td><code id="tran.cylindrical_+3A_flux.theta.down">flux.theta.down</code></td>
<td>
<p>flux across the downstream boundary in theta-direction,
positive = OUT of model domain; one value [M/L2/T].
</p>
</td></tr>
<tr><td><code id="tran.cylindrical_+3A_flux.z.up">flux.z.up</code></td>
<td>
<p>flux across the upstream boundary in z-direction(cylindrical
coordinates); positive = INTO model domain; one value [M/L2/T].
</p>
</td></tr>
<tr><td><code id="tran.cylindrical_+3A_flux.z.down">flux.z.down</code></td>
<td>
<p>flux across the downstream boundary in z-direction,
(cylindrical coordinates); positive = OUT of model domain; one value [M/L2/T].
</p>
</td></tr>
<tr><td><code id="tran.cylindrical_+3A_flux.phi.up">flux.phi.up</code></td>
<td>
<p>flux across the upstream boundary in phi-direction(spherical
coordinates); positive = INTO model domain; one value [M/L2/T].
</p>
</td></tr>
<tr><td><code id="tran.cylindrical_+3A_flux.phi.down">flux.phi.down</code></td>
<td>
<p>flux across the downstream boundary in phi-direction,
(spherical coordinates); positive = OUT of model domain; one value [M/L2/T].
</p>
</td></tr>
<tr><td><code id="tran.cylindrical_+3A_cyclicbnd">cyclicBnd</code></td>
<td>
<p>If not <code>NULL</code>, the direction in which a cyclic 
boundary is defined, i.e. <code>cyclicBnd = 1</code> for the <code>r</code> direction, 
<code>cyclicBnd = 2</code> for the <code>theta</code> direction and 
<code>cyclicBnd = c(1,2)</code> for both the <code>r</code> and <code>theta</code> direction.
</p>
</td></tr>
<tr><td><code id="tran.cylindrical_+3A_d.r">D.r</code></td>
<td>
<p>diffusion coefficient in r-direction, defined on grid cell
interfaces. One value or a vector of length (Nr+1), [L2/T].
</p>
</td></tr>
<tr><td><code id="tran.cylindrical_+3A_d.theta">D.theta</code></td>
<td>
<p>diffusion coefficient in theta-direction, defined on grid cell
interfaces. One value or or a vector of length (Ntheta+1), [L2/T].
</p>
</td></tr>
<tr><td><code id="tran.cylindrical_+3A_d.z">D.z</code></td>
<td>
<p>diffusion coefficient in z-direction, defined on grid cell
interfaces for cylindrical coordinates. One value or a vector of length 
(Nz+1) [L2/T].
</p>
</td></tr>
<tr><td><code id="tran.cylindrical_+3A_d.phi">D.phi</code></td>
<td>
<p>diffusion coefficient in phi-direction, defined on grid cell
interfaces for cylindrical coordinates. One value or a vector of length 
(Nphi+1) [L2/T].
</p>
</td></tr>
<tr><td><code id="tran.cylindrical_+3A_r">r</code></td>
<td>
<p>position of adjacent cell interfaces in the r-direction. 
A vector of length Nr+1 [L].
</p>
</td></tr>
<tr><td><code id="tran.cylindrical_+3A_theta">theta</code></td>
<td>
<p>position of adjacent cell interfaces in the theta-direction.
A vector of length Ntheta+1 [L].  Theta should be within [0,2 pi]
</p>
</td></tr>
<tr><td><code id="tran.cylindrical_+3A_z">z</code></td>
<td>
<p>position of adjacent cell interfaces in the z-direction (cylindrical
coordinates). A vector of length Nz+1 [L].
</p>
</td></tr>
<tr><td><code id="tran.cylindrical_+3A_phi">phi</code></td>
<td>
<p>position of adjacent cell interfaces in the phi-direction (spherical
coordinates). A vector of length Nphi+1 [L]. Phi should be within [0,2 pi]
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tran.cylindrical</code> performs (diffusive) transport in cylindrical coordinates
</p>
<p><code>tran.spherical</code> performs (diffusive) transport in spherical coordinates
</p>
<p>The <b>boundary conditions</b> are either
</p>

<ul>
<li><p> (1) zero gradient
</p>
</li>
<li><p> (2) fixed concentration
</p>
</li>
<li><p> (3) fixed flux
</p>
</li>
<li><p> (4) cyclic boundary
</p>
</li></ul>

<p>This is also the order of priority. The cyclic boundary overrules the other.
If fixed concentration, fixed flux, and cyclicBnd are <code>NULL</code> then
the boundary is zero-gradient
</p>
<p>A cyclic boundary condition has concentration and flux at upstream and 
downstream boundary the same. It is useful mainly for the <code>theta</code> and 
<code>phi</code> direction.
</p>
<p>** Do  not expect too much of this equation: do not try to use it with 
many boxes ** 
</p>


<h3>Value</h3>

<p>a list containing:
</p>
<table>
<tr><td><code>dC</code></td>
<td>
<p>the rate of change of the concentration C due to transport,
defined in the centre of each grid cell, a Nr*Nteta*Nz (cylindrical) or 
Nr*Ntheta*Nphi (spherical coordinates) array. [M/L3/T].
</p>
</td></tr>
<tr><td><code>flux.r.up</code></td>
<td>
<p>flux across the upstream boundary in r-direction,
positive = INTO model domain. A matrix of dimension Nteta*Nz (cylindrical) 
or Ntheta*Nphi (spherical) [M/L2/T].
</p>
</td></tr>
<tr><td><code>flux.r.down</code></td>
<td>
<p>flux across the downstream boundary in r-direction,
positive = OUT of model domain. A matrix of dimension Nteta*Nz (cylindrical)
or Ntheta*Nphi (spherical) [M/L2/T].
</p>
</td></tr>
<tr><td><code>flux.theta.up</code></td>
<td>
<p>flux across the upstream boundary in theta-direction,
positive = INTO model domain. A matrix of dimension Nr*Nz (cylindrical) or 
or Nr*Nphi (spherical) [M/L2/T].
</p>
</td></tr>
<tr><td><code>flux.theta.down</code></td>
<td>
<p>flux across the downstream boundary in theta-direction,
positive = OUT of model domain. A matrix of dimension Nr*Nz (cylindrical) or 
Nr*Nphi (spherical) [M/L2/T].
</p>
</td></tr>
<tr><td><code>flux.z.up</code></td>
<td>
<p>flux across the upstream boundary in z-direction,
for cylindrical coordinates; 
positive = OUT of model domain. A matrix of dimension Nr*Nteta [M/L2/T].
</p>
</td></tr>
<tr><td><code>flux.z.down</code></td>
<td>
<p>flux across the downstream boundary in z-direction 
for cylindrical coordinates; 
positive = OUT of model domain. A matrix of dimension Nr*Nteta [M/L2/T].
</p>
</td></tr>
<tr><td><code>flux.phi.up</code></td>
<td>
<p>flux across the upstream boundary in phi-direction,
for spherical coordinates;
positive = OUT of model domain. A matrix of dimension Nr*Nteta [M/L2/T].
</p>
</td></tr>
<tr><td><code>flux.phi.down</code></td>
<td>
<p>flux across the downstream boundary in phi-direction,
for spherical coordinates;
positive = OUT of model domain. A matrix of dimension Nr*Nteta [M/L2/T].
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tran.polar">tran.polar</a></code> 
for a discretisation of 2-D transport equations in polar coordinates
</p>
<p><code><a href="#topic+tran.1D">tran.1D</a></code>,   <code><a href="#topic+tran.2D">tran.2D</a></code>,  <code><a href="#topic+tran.3D">tran.3D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =============================================================================
## Testing the functions
## =============================================================================
# Grid definition
r.N     &lt;- 4   # number of cells in r-direction
theta.N &lt;- 6   # number of cells in theta-direction
z.N     &lt;- 3   # number of cells in z-direction

D       &lt;- 100 # diffusion coefficient
 
r      &lt;- seq(0,   8, len = r.N+1)       # cell size r-direction [cm]
theta  &lt;- seq(0,2*pi, len = theta.N+1)   # theta-direction - theta: from 0, 2pi
phi    &lt;- seq(0,2*pi, len = z.N+1)       # phi-direction (0,2pi)
z      &lt;- seq(0,5, len = z.N+1)          # cell size z-direction [cm]
 
# Intial conditions 
C &lt;- array(dim = c(r.N, theta.N, z.N), data = 0)

# Concentration boundary conditions
tran.cylindrical (C = C, D.r = D, D.theta = D, 
  C.r.up = 1, C.r.down = 1,
  C.theta.up = 1, C.theta.down = 1, 
  C.z.up = 1, C.z.down = 1,
  r = r, theta = theta, z = z )

tran.spherical (C = C, D.r = D, D.theta = D, 
  C.r.up = 1, C.r.down = 1, C.theta.up = 1, C.theta.down = 1, 
  C.phi.up = 1, C.phi.down = 1,
  r = r, theta = theta, phi = phi)

# Flux boundary conditions
tran.cylindrical(C = C, D.r = D, r = r, theta = theta, z = z,
  flux.r.up = 10, flux.r.down = 10,
  flux.theta.up = 10, flux.theta.down = 10,
  flux.z.up = 10, flux.z.down = 10)

tran.spherical(C = C, D.r = D, r = r, theta = theta, phi = phi,
  flux.r.up = 10, flux.r.down = 10,
  flux.theta.up = 10, flux.theta.down = 10,
  flux.phi.up = 10, flux.phi.down = 10)

# cyclic boundary conditions
tran.cylindrical(C = C, D.r = D, r = r, theta = theta, z = z,
  cyclicBnd = 1:3)
tran.spherical(C = C, D.r = D, r = r, theta = theta, phi = phi,
  cyclicBnd = 1:3)

# zero-gradient boundary conditions
tran.cylindrical(C = C, D.r = D, r = r, theta = theta, z = z)
tran.spherical(C = C, D.r = D, r = r, theta = theta, phi = phi)

## =============================================================================
## A model with diffusion and first-order consumption
## =============================================================================

N     &lt;- 10          # number of grid cells
rr    &lt;- 0.005       # consumption rate
D     &lt;- 400

r       &lt;- seq (2, 4, len = N+1)
theta   &lt;- seq (0, 2*pi, len = N+1)
z       &lt;- seq (0, 3, len = N+1)
phi     &lt;- seq (0, 2*pi, len = N+1)

# The model equations
Diffcylin &lt;- function (t, y, parms)  {
  CONC  &lt;- array(dim = c(N, N, N), data = y)
  tran  &lt;- tran.cylindrical(CONC, 
        D.r = D, D.theta = D, D.z = D,
        r = r, theta = theta, z = z,
        C.r.up = 0,  C.r.down = 1,
        cyclicBnd = 2)
  dCONC &lt;- tran$dC  - rr * CONC
  return (list(dCONC))
}

Diffspher &lt;- function (t, y, parms)  {
  CONC  &lt;- array(dim = c(N, N, N), data = y)
  tran  &lt;- tran.spherical (CONC, 
        D.r = D, D.theta = D, D.phi = D,
        r = r, theta = theta, phi = phi,
        C.r.up = 0,  C.r.down = 1,
        cyclicBnd = 2:3)
  dCONC &lt;- tran$dC  - rr * CONC
  return (list(dCONC))
}

# initial condition: 0 everywhere, except in central point
y   &lt;- array(dim = c(N, N, N), data = 0)
N2  &lt;- ceiling(N/2)

y[N2, N2, N2] &lt;- 100  # initial concentration in the central point...

# solve to steady-state; cyclicBnd = 2, 
outcyl &lt;- steady.3D (y = y, func = Diffcylin, parms = NULL,
                  dim = c(N, N, N), lrw = 1e6, cyclicBnd = 2)

STDcyl &lt;- array(dim = c(N, N, N), data = outcyl$y)
image(STDcyl[,,1])

# For spherical coordinates, cyclic Bnd = 2, 3
outspher &lt;- steady.3D (y = y, func = Diffspher, parms = NULL, pos=TRUE,
                  dim = c(N, N, N), lrw = 1e6, cyclicBnd = 2:3)

#STDspher &lt;- array(dim = c(N, N, N), data = outspher$y)
#image(STDspher[,,1])

## Not run: 
  image(outspher)

## End(Not run)          
</code></pre>

<hr>
<h2 id='tran.polar'>
Diffusive Transport in polar (r, theta) coordinates.
</h2><span id='topic+tran.polar'></span><span id='topic+polar2cart'></span>

<h3>Description</h3>

<p>Estimates the transport term (i.e. the rate of change of a concentration
due to diffusion) in a polar (r, theta)  coordinate system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tran.polar (C, C.r.up = NULL, C.r.down = NULL, 
            C.theta.up = NULL, C.theta.down = NULL, 
            flux.r.up = NULL, flux.r.down = NULL, 
            flux.theta.up = NULL, flux.theta.down = NULL, 
            cyclicBnd = NULL, D.r = 1, D.theta = D.r, 
            r = NULL, theta = NULL, full.output = FALSE)

polar2cart (out, r, theta, x = NULL, y = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tran.polar_+3A_c">C</code></td>
<td>
<p>concentration, expressed per unit volume, defined at the centre
of each grid cell; Nr*Nteta matrix [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.polar_+3A_c.r.up">C.r.up</code></td>
<td>
<p>concentration at upstream boundary in r(x)-direction;
vector of length Nteta [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.polar_+3A_c.r.down">C.r.down</code></td>
<td>
<p>concentration at downstream boundary in r(x)-direction;
vector of length Nteta [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.polar_+3A_c.theta.up">C.theta.up</code></td>
<td>
<p>concentration at upstream boundary in theta-direction;
vector of length Nr [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.polar_+3A_c.theta.down">C.theta.down</code></td>
<td>
<p>concentration at downstream boundary in theta-direction;
vector of length Nr [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.polar_+3A_flux.r.up">flux.r.up</code></td>
<td>
<p>flux across the upstream boundary in r-direction,
positive = INTO model domain; vector of length Ntheta [M/L2/T].
</p>
</td></tr>
<tr><td><code id="tran.polar_+3A_flux.r.down">flux.r.down</code></td>
<td>
<p>flux across the downstream boundary in r-direction,
positive = OUT of model domain; vector of length Ntheta [M/L2/T].
</p>
</td></tr>
<tr><td><code id="tran.polar_+3A_flux.theta.up">flux.theta.up</code></td>
<td>
<p>flux across the upstream boundary in theta-direction,
positive = INTO model domain; vector of length Nr [M/L2/T].
</p>
</td></tr>
<tr><td><code id="tran.polar_+3A_flux.theta.down">flux.theta.down</code></td>
<td>
<p>flux across the downstream boundary in theta-direction,
positive = OUT of model domain; vector of length Nr [M/L2/T].
</p>
</td></tr>
<tr><td><code id="tran.polar_+3A_cyclicbnd">cyclicBnd</code></td>
<td>
<p>If not <code>NULL</code>, the direction in which a cyclic 
boundary is defined, i.e. <code>cyclicBnd = 1</code> for the <code>r</code> direction, 
<code>cyclicBnd = 2</code> for the <code>theta</code> direction and 
<code>cyclicBnd = c(1,2)</code> for both the <code>r</code> and <code>theta</code> direction.
</p>
</td></tr>
<tr><td><code id="tran.polar_+3A_d.r">D.r</code></td>
<td>
<p>diffusion coefficient in r-direction, defined on grid cell
interfaces. One value, a vector of length (Nr+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,
or a (Nr+1)* Nteta matrix [L2/T].
</p>
</td></tr>
<tr><td><code id="tran.polar_+3A_d.theta">D.theta</code></td>
<td>
<p>diffusion coefficient in theta-direction, defined on grid cell
interfaces. One value, a vector of length (Ntheta+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,
or a Nr*(Ntheta+1) matrix [L2/T].
</p>
</td></tr>
<tr><td><code id="tran.polar_+3A_r">r</code></td>
<td>
<p>position of adjacent cell interfaces in the r-direction. 
A vector of length Nr+1 [L].
</p>
</td></tr>
<tr><td><code id="tran.polar_+3A_theta">theta</code></td>
<td>
<p>position of adjacent cell interfaces in the theta-direction.
A vector of length Ntheta+1 [L].  Theta should be within [0,2 pi]
</p>
</td></tr>
<tr><td><code id="tran.polar_+3A_full.output">full.output</code></td>
<td>
<p>logical flag enabling a full return of the output
(default = <code>FALSE</code>; <code>TRUE</code> slows down execution by 20 percent).
</p>
</td></tr>
<tr><td><code id="tran.polar_+3A_out">out</code></td>
<td>
<p>output as returned by <code>tran.polar</code>, and which is to be
mapped from polar to cartesian coordinates
</p>
</td></tr>
<tr><td><code id="tran.polar_+3A_x">x</code></td>
<td>
<p>The cartesian x-coordinates to whicht the polar coordinates are
to be mapped
</p>
</td></tr>
<tr><td><code id="tran.polar_+3A_y">y</code></td>
<td>
<p>The cartesian y-coordinates to whicht the polar coordinates are
to be mapped
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tran.polar</code> performs (simplified) transport in polar coordinates
</p>
<p>The <b>boundary conditions</b> are either
</p>

<ul>
<li><p> (1) zero gradient
</p>
</li>
<li><p> (2) fixed concentration
</p>
</li>
<li><p> (3) fixed flux
</p>
</li>
<li><p> (4) cyclic boundary
</p>
</li></ul>

<p>This is also the order of priority. The cyclic boundary overrules the other.
If fixed concentration, fixed flux, and cyclicBnd are <code>NULL</code> then
the boundary is zero-gradient
</p>
<p>A cyclic boundary condition has concentration and flux at upstream and 
downstream boundary the same.
</p>
<p><code>polar2cart</code> maps the polar coordinates to cartesian coordinates
</p>
<p>If <code>x</code> and <code>y</code> is not provided, then it will create an (x,y)
grid based on <code>r</code> : <code>seq(-maxr, maxr, length.out=Nr)</code>, where
<code>maxr</code> is the maximum value of <code>r</code>, and <code>Nr</code> is the number
of elements in <code>r</code>.
</p>


<h3>Value</h3>

<p>a list containing:
</p>
<table>
<tr><td><code>dC</code></td>
<td>
<p>the rate of change of the concentration C due to transport,
defined in the centre of each grid cell, a Nr*Nteta matrix. [M/L3/T].
</p>
</td></tr>
<tr><td><code>C.r.up</code></td>
<td>
<p>concentration at the upstream interface in r-direction.
A vector of length Nteta [M/L3]. Only when <code>full.output = TRUE</code>.
</p>
</td></tr>
<tr><td><code>C.r.down</code></td>
<td>
<p>concentration at the downstream interface in r-direction.
A vector of length Nteta [M/L3]. Only when <code>full.output = TRUE</code>.
</p>
</td></tr>
<tr><td><code>C.theta.up</code></td>
<td>
<p>concentration at the the upstream interface in theta-direction.
A vector of length Nr [M/L3].  Only when <code>full.output = TRUE</code>.
</p>
</td></tr>
<tr><td><code>C.theta.down</code></td>
<td>
<p>concentration at the downstream interface in theta-direction.
A vector of length Nr [M/L3]. Only when <code>full.output = TRUE</code>.
</p>
</td></tr>
<tr><td><code>r.flux</code></td>
<td>
<p>flux across the interfaces in x-direction of the grid cells.
A (Nr+1)*Nteta matrix  [M/L2/T]. Only when <code>full.output = TRUE</code>.
</p>
</td></tr>
<tr><td><code>theta.flux</code></td>
<td>
<p>flux across the interfaces in y-direction of the grid cells.
A Nr*(Nteta+1) matrix [M/L2/T].  Only when <code>full.output = TRUE</code>.
</p>
</td></tr>
<tr><td><code>flux.r.up</code></td>
<td>
<p>flux across the upstream boundary in r-direction,
positive = INTO model domain. A vector of length Nteta [M/L2/T].
</p>
</td></tr>
<tr><td><code>flux.r.down</code></td>
<td>
<p>flux across the downstream boundary in r-direction,
positive = OUT of model domain. A vector of length Nteta [M/L2/T].
</p>
</td></tr>
<tr><td><code>flux.theta.up</code></td>
<td>
<p>flux across the upstream boundary in theta-direction,
positive = INTO model domain. A vector of length Nr [M/L2/T].
</p>
</td></tr>
<tr><td><code>flux.theta.down</code></td>
<td>
<p>flux across the downstream boundary in theta-direction,
positive = OUT of model domain. A vector of length Nr [M/L2/T].
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Soetaert and Herman, 2009. a practical guide to ecological modelling -
using R as a simulation platform. Springer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tran.cylindrical">tran.cylindrical</a></code>, <code><a href="#topic+tran.spherical">tran.spherical</a></code> 
for a discretisation of 3-D transport equations in cylindrical and 
spherical coordinates
</p>
<p><code><a href="#topic+tran.1D">tran.1D</a></code>,   <code><a href="#topic+tran.2D">tran.2D</a></code>,  <code><a href="#topic+tran.3D">tran.3D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =============================================================================
## Testing the functions
## =============================================================================
# Parameters
F        &lt;- 100             # input flux [micromol cm-2 yr-1]
D        &lt;- 400             # mixing coefficient [cm2 yr-1]

# Grid definition
r.N   &lt;- 4     # number of cells in r-direction
theta.N &lt;- 6   # number of cells in theta-direction
r.L &lt;- 8       # domain size r-direction [cm]
r      &lt;- seq(0, r.L,len = r.N+1)      # cell size r-direction [cm]
theta  &lt;- seq(0, 2*pi,len = theta.N+1) # theta-direction - theta: from 0, 2pi
 
# Intial conditions 
C &lt;- matrix(nrow = r.N, ncol = theta.N, data = 0)

# Boundary conditions: fixed concentration  
C.r.up       &lt;- rep(1, times = theta.N)
C.r.down     &lt;- rep(0, times = theta.N)
C.theta.up   &lt;- rep(1, times = r.N)
C.theta.down &lt;- rep(0, times = r.N)

# Concentration boundary conditions
tran.polar(C = C, D.r = D, D.theta = D, 
  r = r, theta = theta,
  C.r.up = C.r.up, C.r.down = C.r.down, 
  C.theta.up = C.theta.up, C.theta.down = C.theta.down)

# Flux boundary conditions
flux.r.up &lt;- rep(200, times = theta.N)
flux.r.down &lt;- rep(-200, times = theta.N)
flux.theta.up &lt;- rep(200, times = r.N)
flux.theta.down &lt;- rep(-200, times = r.N)

tran.polar(C = C, D.r = D, r = r, theta = theta,
  flux.r.up = flux.r.up, flux.r.down = flux.r.down,
  flux.theta.up = flux.theta.up, flux.theta.down = flux.theta.down,
  full.output = TRUE)


## =============================================================================
## A model with diffusion and first-order consumption
## =============================================================================
N     &lt;- 50          # number of grid cells
XX    &lt;- 4           # total size
rr    &lt;- 0.005       # consumption rate
ini   &lt;- 1           # initial value at x=0
D     &lt;- 400

r     &lt;- seq (2, 4, len = N+1)
theta   &lt;- seq(0, 2*pi, len = N+1)
theta.m &lt;- 0.5*(theta[-1]+theta[-(N+1)])

# The model equations

Diffpolar &lt;- function (t, y, parms)  {
  CONC  &lt;- matrix(nrow = N, ncol = N, data = y)
  tran  &lt;- tran.polar(CONC, D.r = D, D.theta = D, r = r, theta = theta,
        C.r.up = 0, C.r.down = 1*sin(5*theta.m), 
        cyclicBnd = 2, full.output=TRUE )
  dCONC &lt;- tran$dC  - rr * CONC
  return (list(dCONC))
}

# solve to steady-state; cyclicBnd = 2, because of C.theta.up, C.theta.down
out &lt;- steady.2D (y = rep(0, N*N), func = Diffpolar, parms = NULL,
                  dim = c(N, N), lrw = 1e6, cyclicBnd = 2)

image(out)

cart &lt;- polar2cart(out, r = r, theta = theta, 
                        x = seq(-4, 4, len = 100), 
                        y = seq(-4, 4, len = 100))
image(cart)
          
</code></pre>

<hr>
<h2 id='tran.volume.1D'>
1-D, 2-D and 3-D Volumetric Advective-Diffusive Transport in an Aquatic System
</h2><span id='topic+tran.volume.1D'></span><span id='topic+tran.volume.2D'></span><span id='topic+tran.volume.3D'></span>

<h3>Description</h3>

<p>Estimates the volumetric transport term (i.e. the rate of change of the
concentration due to diffusion and advection) in a 1-D, 2-D or 3-D model of
an aquatic system (river, estuary).
</p>
<p>Volumetric transport implies the use of flows (mass per unit of time) rather
than fluxes (mass per unit of area per unit of time) as is done in
<code><a href="#topic+tran.1D">tran.1D</a></code>, <code><a href="#topic+tran.2D">tran.2D</a></code> or <code><a href="#topic+tran.3D">tran.3D</a></code>.
</p>
<p>The <code>tran.volume.xD</code> routines are particularly suited for modelling
channels (like rivers, estuaries) where the cross-sectional area changes,
but where this area change needs not to be explicitly modelled as such.
</p>
<p>Another difference with <code>tran.1D</code> is that the <code>tran.volume.1D</code> 
routine also allows lateral water or lateral mass input (as from side rivers 
or diffusive lateral ground water inflow).
</p>
<p>The <code>tran.volume.2D</code> routine can check for water balance and assume an
in- or efflux in case the net flows in and out of a box are not = 0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tran.volume.1D(C, C.up = C[1], C.down = C[length(C)],
               C.lat = C, F.up = NULL, F.down = NULL, F.lat = NULL,
               Disp,	flow = 0, flow.lat = NULL, AFDW = 1,
               V = NULL, full.check = FALSE, full.output = FALSE)

tran.volume.2D(C, C.x.up = C[1, ], C.x.down = C[nrow(C), ], 
               C.y.up = C[, 1], C.y.down = C[, ncol(C)], 
               C.z = C, masscons = TRUE, 
               F.x.up = NULL, F.x.down = NULL, 
               F.y.up = NULL, F.y.down = NULL, 
               Disp.grid = NULL, Disp.x = NULL, Disp.y = Disp.x, 
               flow.grid = NULL, flow.x = NULL, flow.y = NULL, 
               AFDW.grid = NULL, AFDW.x = 1, AFDW.y = AFDW.x,         
               V = NULL, full.check = FALSE, full.output = FALSE) 

tran.volume.3D(C,  C.x.up = C[1, , ], C.x.down = C[dim(C)[1], , ],                
               C.y.up = C[, 1, ], C.y.down = C[, dim(C)[2], ], 
               C.z.up = C[, , 1], C.z.down = C[, , dim(C)[3]], 
               F.x.up = NULL, F.x.down = NULL,  
               F.y.up = NULL, F.y.down = NULL, 
               F.z.up = NULL, F.z.down = NULL,         
               Disp.grid = NULL, 
               Disp.x = NULL, Disp.y = Disp.x, Disp.z = Disp.x,      
               flow.grid = NULL, flow.x = 0, flow.y = 0, flow.z = 0, 
               AFDW.grid = NULL, AFDW.x = 1, AFDW.y = AFDW.x, 
               AFDW.z = AFDW.x,                 
               V = NULL, full.check = FALSE, full.output = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tran.volume.1D_+3A_c">C</code></td>
<td>
<p>tracer concentration, defined at the centre of the grid cells.
A vector of length N [M/L3] (tran.volume.1D), 
a matrix of dimension Nr*Nc (tran.volume.2D) or 
an Nx*Ny*Nz array (tran.volume.3D) [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_c.up">C.up</code></td>
<td>
<p>tracer concentration at the upstream interface. 
One value [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_c.down">C.down</code></td>
<td>
<p>tracer concentration at downstream interface. One value [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_c.lat">C.lat</code></td>
<td>
<p>tracer concentration in the lateral input, defined at
grid cell centres. One value, a vector of length N, or a
list as defined by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code> [M/L3].
The default is  <code>C.lat = C</code>, (a zero-gradient condition).
Setting <code>C.lat=0</code>, together with a positive <code>F.lat</code> will
lead to dilution of the tracer concentration in the
grid cells.
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_c.x.up">C.x.up</code></td>
<td>
<p>concentration at upstream boundary in x-direction;
vector of length Ny (2D) or matrix of dimensions Ny*Nz (3D) [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_c.x.down">C.x.down</code></td>
<td>
<p>concentration at downstream boundary in x-direction;
vector of length Ny (2D) or matrix of dimensions Ny*Nz (3D) [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_c.y.up">C.y.up</code></td>
<td>
<p>concentration at upstream boundary in y-direction;
vector of length Nx (2D) or matrix of dimensions Nx*Nz (3D) [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_c.y.down">C.y.down</code></td>
<td>
<p>concentration at downstream boundary in y-direction;
vector of length Nx (2D) or matrix of dimensions Nx*Nz (3D) [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_c.z.up">C.z.up</code></td>
<td>
<p>concentration at upstream boundary in z-direction;
matrix of dimensions Nx*Ny [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_c.z.down">C.z.down</code></td>
<td>
<p>concentration at downstream boundary in z-direction;
matrix of dimensions Nx*Ny [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_c.z">C.z</code></td>
<td>
<p>concentration at boundary in z-direction for 2-D models where
<code>masscons</code> = TRUE. Matrix of dimensions Nx*Ny [M/L3].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_masscons">masscons</code></td>
<td>
<p>When <code>TRUE</code>, will check flow balance in 2D model. 
The flow in the third direction will then be estimated.
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_f.up">F.up</code></td>
<td>
<p>total tracer input at the upstream interface. One value [M/T].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_f.down">F.down</code></td>
<td>
<p>total tracer input at downstream interface. One value [M/T].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_f.lat">F.lat</code></td>
<td>
<p>total lateral tracer input, defined at grid cell centres.
One value, a vector of length N, or a 1D list property as defined by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,[M/T].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_f.x.up">F.x.up</code></td>
<td>
<p>total tracer input at the upstream interface in x-direction.
positive = INTO model domain. A vector of length Ny (2D) or a matrix of dimensions Ny*Nz (3D)  [M/T].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_f.x.down">F.x.down</code></td>
<td>
<p>total tracer input at downstream interface in x-direction. positive = INTO model domain. A vector of length Ny (2D) or a matrix of dimensions Ny*Nz (3D)  [M/T].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_f.y.up">F.y.up</code></td>
<td>
<p>total tracer input at the upstream interface in y-direction.
positive = INTO model domain. A vector of length Nx (2D) or a matrix of dimensions Nx*Nz (3D)  [M/T].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_f.y.down">F.y.down</code></td>
<td>
<p>total tracer input at downstream interface in y-direction. positive = INTO model domain. A vector of length Nx (2D) or a matrix of dimensions Nx*Nz (3D)  [M/T].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_f.z.up">F.z.up</code></td>
<td>
<p>total tracer input at the upstream interface in z-direction.
positive = INTO model domain. A matrix of dimensions Nx*Ny    [M/T].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_f.z.down">F.z.down</code></td>
<td>
<p>total tracer input at downstream interface in z-direction. positive = INTO model domain. A matrix of dimensions Nx*Ny [M/T].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_disp.grid">Disp.grid</code></td>
<td>
<p>BULK dispersion coefficients defined on all grid cell
interfaces. For <code>tran.volume.2D</code>, should contain two matrices, x.int (dimension (Nx+1)*Ny)  and y.int (dimension Nx * (Ny+1)). 
For tran.volume.3D should contain three arrays x.int (dim = (Nx+1)*Ny*Nz), y.int (dim = Nx*(Ny+1)*Nz), and z.int (dim = Nx*Ny*(Nz+1))
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_disp">Disp</code></td>
<td>
<p>BULK dispersion coefficient, defined on grid cell interfaces.
One value, a vector of length N+1, or a 1D list property as defined by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code> [L3/T].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_disp.x">Disp.x</code></td>
<td>
<p>BULK dispersion coefficient in x-direction, defined on grid cell interfaces. One value, a vector of length (Nx+1), a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>, a (Nx+1)* Ny matrix (2D) or a  Nx*(Ny+1)*Nz array (3D)   [L3/T].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_disp.y">Disp.y</code></td>
<td>
<p>BULK dispersion coefficient in y-direction, defined on grid cell
interfaces. One value, a vector of length (Ny+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,
or a Nx*(Ny+1) matrix (2D) or a Nx*(Ny+1)*Nz array  (3D)[L3/T].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_disp.z">Disp.z</code></td>
<td>
<p>BULK dispersion coefficient in z-direction, defined on grid cell
interfaces. One value, a vector of length (Nz+1), or a Nx*Ny*(Nz+1) array   [L3/T].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_flow">flow</code></td>
<td>
<p>water flow rate, defined on grid cell interfaces. One value, a vector of length N+1, or a list as defined by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code> [L3/T]. 
If <code>flow.lat</code> is not <code>NULL</code> the <code>flow</code> should be one value containing the flow rate at the upstream boundary. 
If <code>flow.lat</code> is <code>NULL</code> then <code>flow</code> can be either one value, a vector or a list.
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_flow.lat">flow.lat</code></td>
<td>
<p>lateral water flow rate [L3/T] into each volume box, defined at grid cell centres. One value, a vector of
length N, or a list as defined by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>. If <code>flow.lat</code> has a value, then
<code>flow</code> should be the flow rate at the upstream interface (one value).
For each grid cell, the <code>flow</code> at the downstream side of a grid cell is 
then estimated by water balance (adding <code>flow.lat</code> in the cell to 
flow rate at the upstream side of the grid cell). If <code>flow.lat</code> is <code>NULL</code>, then it is determined by water balance 
from <code>flow</code>.
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_flow.grid">flow.grid</code></td>
<td>
<p>flow rates defined on all grid cell
interfaces. Can be positive (downstream flow) or negative (upstream flow).
Should contain elements x.int, y.int, z.int (3-D), arrays with the values on the
interfaces in x, y and z-direction  [L3/T].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_flow.x">flow.x</code></td>
<td>
<p>flow rates in the x-direction, defined on grid cell
interfaces. Can be positive (downstream flow) or negative (upstream flow).
One value, a vector of length (Nx+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code> (2D),
a (Nx+1)*Ny matrix (2D) or a (Nx+1)*Ny*Nz array (3D) [L3/T].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_flow.y">flow.y</code></td>
<td>
<p>flow rates in the y-direction, defined on grid cell
interfaces. Can be positive (downstream flow) or negative (upstream flow).
One value, a vector of length (Ny+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code> (2D),
a Nx*(Ny+1) matrix (2D) or a Nx*(Ny+1)*Nz array [L3/T].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_flow.z">flow.z</code></td>
<td>
<p>flow rates in the z-direction, defined on grid cell
interfaces. Can be positive (downstream flow) or negative (upstream flow).
One value, a vector of length (Nz+1),
or a Nx*Ny*(Nz+1) array [L3/T].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_afdw">AFDW</code></td>
<td>
<p>weight used in the finite difference scheme for advection,
defined on grid cell interfaces; backward = 1, centred = 0.5, forward = 0;
default is backward. One value, a vector of length N+1, or a
list as defined by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code> [-]. 
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_afdw.grid">AFDW.grid</code></td>
<td>
<p>weight used in the finite difference scheme for advection
in the x-direction, defined on grid cell interfaces; backward = 1,
centred = 0.5, forward = 0; default is backward.
For <code>tran.volume.3D</code> should contain elements x.int, y.int, z.int (3D),  for <code>tran.volume.2D</code> should contain elements x.int and y.int. [-].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_afdw.x">AFDW.x</code></td>
<td>
<p>weight used in the finite difference scheme for advection
in the x-direction, defined on grid cell interfaces; backward = 1,
centred = 0.5, forward = 0; default is backward.
One value, a vector of length (Nx+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,
a (Nx+1)*Ny matrix (2D) or a (Nx+1)*Ny*Nz array (3D) [-].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_afdw.y">AFDW.y</code></td>
<td>
<p>weight used in the finite difference scheme for advection
in the y-direction, defined on grid cell interfaces; backward = 1,
centred = 0.5, forward = 0; default is backward.
One value, a vector of length (Ny+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,
a Nx*(Ny+1) matrix (2D) or a Nx*(Ny+1)*Nz array [-].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_afdw.z">AFDW.z</code></td>
<td>
<p>weight used in the finite difference scheme for advection
in the z-direction, defined on grid cell interfaces; backward = 1,
centred = 0.5, forward = 0; default is backward.
One value, a vector of length (Nz+1),
a <code>prop.1D</code> list created by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>,
or a Nx*Ny*(Nz+1) array [-].
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_v">V</code></td>
<td>
<p>grid cell volume, defined at grid cell centres [L3]. One value, a
vector of length N, or a list as defined by <code><a href="#topic+setup.prop.1D">setup.prop.1D</a></code>.
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_full.check">full.check</code></td>
<td>
<p>logical flag enabling a full check of the consistency
of the arguments (default = <code>FALSE</code>; <code>TRUE</code> slows down execution
by 50 percent).
</p>
</td></tr>
<tr><td><code id="tran.volume.1D_+3A_full.output">full.output</code></td>
<td>
<p>logical flag enabling a full return of the output
(default = <code>FALSE</code>; <code>TRUE</code> slows down execution by 20 percent).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <b>boundary conditions</b> are of type
</p>

<ul>
<li><p> 1. zero-gradient (default)
</p>
</li>
<li><p> 2. fixed concentration
</p>
</li>
<li><p> 3. fixed input
</p>
</li></ul>

<p>The <em>bulk dispersion coefficient</em> (<code>Disp</code>) and the <em>flow rate</em>
(<code>flow</code>) can be either one value or a vector of length N+1, defined at
all grid cell interfaces, including upstream and downstream boundary.
</p>
<p>The spatial discretisation is given by the volume of each box (<code>V</code>),
which can be one value or a vector of length N+1, defined at the centre of
each grid cell.
</p>
<p>The water flow is mass conservative. Over each volume box, the routine
calculates internally the downstream outflow of water in terms of the
upstream inflow and the lateral inflow.
</p>


<h3>Value</h3>

<table>
<tr><td><code>dC</code></td>
<td>
<p>the rate of change of the concentration C due to transport,
defined in the centre of each grid cell [M/L3/T].
</p>
</td></tr>
<tr><td><code>F.up</code></td>
<td>
<p>mass flow across the upstream boundary, positive = INTO
model domain. One value [M/T].
</p>
</td></tr>
<tr><td><code>F.down</code></td>
<td>
<p>mass flow across the downstream boundary, positive = OUT
of model domain. One value [M/T].
</p>
</td></tr>
<tr><td><code>F.lat</code></td>
<td>
<p>lateral mass input per volume box, positive = INTO model
domain. A vector of length N [M/T].
</p>
</td></tr>
<tr><td><code>flow</code></td>
<td>
<p>water flow across the interface of each grid cell. A vector
of length N+1 [L3/T]. Only provided when (<code>full.output</code> = <code>TRUE</code>
</p>
</td></tr>
<tr><td><code>flow.up</code></td>
<td>
<p>water flow across the upstream (external) boundary, positive = INTO
model domain. One value [L3/T]. Only provided when (<code>full.output</code> = <code>TRUE</code>)
</p>
</td></tr>
<tr><td><code>flow.down</code></td>
<td>
<p>water flow across the downstream (external) boundary, positive = OUT
of model domain. One value [L3/T]. Only provided when
(<code>full.output</code> = <code>TRUE</code>)
</p>
</td></tr>
<tr><td><code>flow.lat</code></td>
<td>
<p>lateral water input on each volume box, positive = INTO model
domain. A vector of length N [L3/T]. Only provided when
(<code>full.output</code> = <code>TRUE</code>)
</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>mass flow across at the interface of each grid cell. A vector
of length N+1 [M/T]. Only provided when (<code>full.output</code> = <code>TRUE</code>)
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Filip Meysman &lt;filip.meysman@nioz.nl&gt;,
Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>Soetaert and Herman (2009) A practical guide to ecological modelling -
using R as a simulation platform. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tran.1D">tran.1D</a></code>
</p>
<p><code><a href="#topic+advection.volume.1D">advection.volume.1D</a></code>, for more sophisticated advection schemes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## =============================================================================
##  EXAMPLE : organic carbon (OC) decay in a widening estuary
## =============================================================================

# Two scenarios are simulated: the baseline includes only input 
# of organic matter upstream. The second scenario simulates the 
# input of an important side river half way the estuary.  

#====================#
# Model formulation  #
#====================#

river.model &lt;- function (t = 0, OC, pars = NULL) {

  tran &lt;- tran.volume.1D(C = OC, F.up = F.OC, F.lat = F.lat,
          Disp = Disp, flow = flow.up, flow.lat = flow.lat, 
          V = Volume, full.output = TRUE) 

  reac &lt;- - k*OC
  return(list(dCdt = tran$dC + reac, Flow = tran$flow))
}

#======================#
# Parameter definition #
#======================#

# Initialising morphology estuary: 

nbox          &lt;- 500     # number of grid cells
lengthEstuary &lt;- 100000  # length of estuary [m]
BoxLength     &lt;- lengthEstuary/nbox # [m]
Distance      &lt;- seq(BoxLength/2, by = BoxLength, len =nbox) # [m]
Int.Distance  &lt;- seq(0, by = BoxLength, len = (nbox+1))      # [m]

# Cross sectional area: sigmoid function of estuarine distance [m2]
CrossArea &lt;- 4000 + 72000 * Distance^5 /(Distance^5+50000^5)

# Volume of boxes                          (m3)
Volume  &lt;- CrossArea*BoxLength

# Transport coefficients
Disp    &lt;- 1000   # m3/s, bulk dispersion coefficient
flow.up  &lt;- 180    # m3/s, main river upstream inflow
flow.lat.0  &lt;- 180    # m3/s, side river inflow

F.OC    &lt;- 180               # input organic carbon [mol s-1]
F.lat.0 &lt;- 180              # lateral input organic carbon [mol s-1]

k       &lt;- 10/(365*24*3600)  # decay constant organic carbon [s-1]


#====================#
# Model solution     #
#====================#
#scenario 1: without lateral input
F.lat    &lt;- rep(0, length.out = nbox)
flow.lat &lt;- rep(0, length.out = nbox)

Conc1 &lt;- steady.1D(runif(nbox), fun = river.model, nspec = 1, name = "OC")   

#scenario 2: with lateral input
F.lat &lt;- F.lat.0 * dnorm(x =Distance/lengthEstuary,
                         mean = Distance[nbox/2]/lengthEstuary, 
                         sd = 1/20, log = FALSE)/nbox 
flow.lat &lt;- flow.lat.0 * dnorm(x = Distance/lengthEstuary,
                               mean = Distance[nbox/2]/lengthEstuary, 
                               sd = 1/20, log = FALSE)/nbox 

Conc2 &lt;- steady.1D(runif(nbox), fun = river.model, nspec = 1, name = "OC")   

#====================#
# Plotting output    #
#====================#
# use S3 plot method
plot(Conc1, Conc2, grid = Distance/1000, which = "OC", 
     mfrow = c(2, 1), lwd = 2, xlab = "distance [km]", 
     main = "Organic carbon decay in the estuary",
     ylab = "OC Concentration [mM]")
       
plot(Conc1, Conc2, grid = Int.Distance/1000, which = "Flow", 
     mfrow = NULL, lwd = 2, xlab = "distance [km]", 
     main = "Longitudinal change in the water flow rate",
     ylab = "Flow rate [m3 s-1]")  

legend ("topright", lty = 1:2, col = 1:2, lwd = 2,
        c("baseline", "+ side river input"))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
