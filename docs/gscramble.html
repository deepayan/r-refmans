<!DOCTYPE html><html><head><title>Help for package gscramble</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gscramble}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_chrom_lengths'><p>check that the chromosome lengths are acceptable given recombination rates</p></a></li>
<li><a href='#check_gsp_for_validity_and_saturation'><p>Check that GSP does not reuse genetic material and yet uses all of it</p></a></li>
<li><a href='#check_pedigree_for_inbreeding'><p>Check the a GSP (in prepped list format) for inbreeding loops</p></a></li>
<li><a href='#check_rec_rates_formatting'><p>check to make sure that the recombination rates tibble is formatted properly</p></a></li>
<li><a href='#check_reppop'><p>check that the RepPop is formatted correctly</p></a></li>
<li><a href='#computeQs_from_segments'><p>return the admixture fractions of sampled individuals</p></a></li>
<li><a href='#create_GSP'><p>Create a GSP from user inputs about what type of hybrids from which populations to create hybrids</p></a></li>
<li><a href='#drop_segs_down_gsp'><p>High level function for dropping segments down a GSP</p></a></li>
<li><a href='#example_chrom_lengths'><p>Lengths of the three chromosomes used in the example data set</p></a></li>
<li><a href='#example_segments'><p>Example of a segments tibble</p></a></li>
<li><a href='#Geno'><p>Genotype matrix of 78 individuals and 100 SNP markers</p></a></li>
<li><a href='#gscramble2newhybrids'><p>Convert 'gscramble' output to newhybrids format</p></a></li>
<li><a href='#gscramble2plink'><p>Write 'gscramble' I_meta, M_meta, and Geno to a plink file</p></a></li>
<li><a href='#GSP'><p>Example Genomic Simulation Pedigree, GSP, with 13 members</p></a></li>
<li><a href='#GSP_opts'><p>A list of tibbles specifying the pedigrees available from <code>createGSP()</code></p></a></li>
<li><a href='#gsp2dot'><p>Write a dot file to represent a genome simulation pedigree</p></a></li>
<li><a href='#gsp3'><p>Tibble holding specification for a 5 member genomic permutation pedigree.</p></a></li>
<li><a href='#gsp4'><p>Tibble holding specification for a 7 member genomic permutation pedigree.</p></a></li>
<li><a href='#I_meta'><p>Metadata for 78 individuals</p></a></li>
<li><a href='#M_meta'><p>Metadata for 100 molecular markers</p></a></li>
<li><a href='#make_subscript_matrix'><p>makes a two-column matrix for subscripting alleles out of a genotype matrix</p></a></li>
<li><a href='#mat_scramble'><p>Scramble a matrix of genotype data</p></a></li>
<li><a href='#perm_gs_by_pops'><p>Take the output of rearrange_genos and permute everyone by population</p></a></li>
<li><a href='#plink_map2rec_rates'><p>Convert a PLINK map file to 'gscramble' RecRates bins in a tibble</p></a></li>
<li><a href='#plink2gscramble'><p>read plink-formatted .map and .ped files into 'gscramble' format</p></a></li>
<li><a href='#plot_simulated_chromomsome_segments'><p>Plot the simulated chromosomes of an individual</p></a></li>
<li><a href='#prep_gsp_for_hap_dropping'><p>Take a gsp in tibble form and make a list suitable for gene dropping</p></a></li>
<li><a href='#rearrange_genos'><p>rearrange genotypes into separate columns for each haplotype.</p></a></li>
<li><a href='#recomb_point'><p>Randomly sample the positions of recombinations on a chromosome</p></a></li>
<li><a href='#RecRates'><p>Recombination rate data for many roughly 1 Mb bins</p></a></li>
<li><a href='#renumber_GSP'><p>Renumber GSP members by adding a constant to each</p></a></li>
<li><a href='#RepPop1'><p>A simple example of a reppop table</p></a></li>
<li><a href='#RepPop4'><p>Another simple example of a reppop table</p></a></li>
<li><a href='#seg_haps_through_gsp'><p>Segregate haplotypes through a genome simulation pedigree list</p></a></li>
<li><a href='#seg2tib'><p>Takes a gamete in segment format and returns a tibble with Pop and indiv_index</p></a></li>
<li><a href='#segments2markers'><p>Map alleles from scrambled founders to the sampled segments from a GSP.</p></a></li>
<li><a href='#segregate'><p>Segregate segments down genomic simulation pedigrees</p></a></li>
<li><a href='#sim_level_founder_haplos'><p>computes the simulation-level founder haplotype index for each founder haplo</p></a></li>
<li><a href='#tidy_up_sampled_haplos'><p>takes the waka_waka table and returns a simple tibble with results for each sampled &quot;hybridized&quot; gamete from each chromosome</p>
#'
Not yet documented</a></li>
<li><a href='#xover'><p>internal function to do crossovers and create recombinations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulating Admixed Genotypes Without Replacement</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A genomic simulation approach for creating biologically
    informed individual genotypes from empirical data that 1) samples alleles
    from populations without replacement, 2) segregates alleles based on species-specific
    recombination rates. 'gscramble' is a flexible simulation approach that allows users
    to create pedigrees of varying complexity in order to simulate admixed genotypes.
    Furthermore, it allows users to track haplotype blocks from the source populations
    through the pedigrees.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/publicdomain/zero/1.0/legalcode">CC0</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, ggplot2, glue, magrittr, purrr, readr, rlang, stats,
stringr, tibble, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cowplot, knitr, rmarkdown, tidyverse</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/eriqande/gscramble">https://github.com/eriqande/gscramble</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/eriqande/gscramble/issues">https://github.com/eriqande/gscramble/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-27 23:41:47 UTC; eriq</td>
</tr>
<tr>
<td>Author:</td>
<td>Eric C. Anderson <a href="https://orcid.org/0000-0003-1326-0840"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Rachael M. Giglio <a href="https://orcid.org/0000-0003-4183-3546"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Matt G. DeSaix <a href="https://orcid.org/0000-0002-5721-0311"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Timothy J. Smyser <a href="https://orcid.org/0000-0003-4542-3077"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eric C. Anderson &lt;eric.anderson@noaa.gov&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-28 19:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_chrom_lengths'>check that the chromosome lengths are acceptable given recombination rates</h2><span id='topic+check_chrom_lengths'></span>

<h3>Description</h3>

<p>For 'gscramble' to work properly, all variant positions on a chromosome (found in the meta data file)
must be equal to or less than the total chromosome length found in the recombination map. In other words,
the variant positions must be within the the total length of each chromosome. The check_chrom_lengths()
function checks that variant positions on each chromosome do not exceed the total chromosome length from the
recombination map. Input files for the function include 1) the meta data file which contains 3 columns (the chromosome ID
as a character, the position of the variant as a numeric, and the name of the variant as a character) and
2) the recombination map which contains 5 columns (the chromosome ID as a character, the total length of the chromosome
as a numeric, the starting position of the recombination bin as a numeric, the last position of the recombination bin as
a numeric, and the recombination probability for the given bin as a numeric).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_chrom_lengths(meta, rec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_chrom_lengths_+3A_meta">meta</code></td>
<td>
<p>a tibble with meta data for the genotype data. It must consist of the columns (chrom, pos, variant_id).</p>
</td></tr>
<tr><td><code id="check_chrom_lengths_+3A_rec">rec</code></td>
<td>
<p>a tibble with recombination map information for your study species.It must contain 5 columns (chrom, chrom_len, start_pos, end_pos, rec_prob).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function will return a message for each chromosome stating whether the chromosome lengths are accurate
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The example uses the built in datasets M_meta and RecRates
# to use the check_chrom_lengths() function

check_chrom_lengths(M_meta,RecRates)

</code></pre>

<hr>
<h2 id='check_gsp_for_validity_and_saturation'>Check that GSP does not reuse genetic material and yet uses all of it</h2><span id='topic+check_gsp_for_validity_and_saturation'></span>

<h3>Description</h3>

<p>These conditions can be checked for a GSP with no inbreeding loops
simply by ensuring that the amount of genetic material coming into
each individual is the same as the amount going out (either as
segregated gametes or as samples).  If the amount of material coming
out of any individual in the GSP is greater than the amount coming
in, then an error is thrown.  If the amount coming out is less than
the amount coming in, then a warning about the GSP is thrown.
Messages printed via <code>message()</code> and <code>warning()</code> indicate which
individuals in the GSP are problematic.  All problematic individuals
are listed before an error is thrown with <code>stop()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_gsp_for_validity_and_saturation(GP)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_gsp_for_validity_and_saturation_+3A_gp">GP</code></td>
<td>
<p>A gsp in list format as produced by the function
<code>prep_gsp_for_hap_dropping()</code>.  See the documentation for the return
object of <code>prep_gsp_for_hap_dropping()</code> for a description.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function does not return anything.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get the 13 member pedigree in tibble form as the package
# and turn it into a list
GP &lt;- prep_gsp_for_hap_dropping(GSP)

# check it. (This passes)
check_gsp_for_validity_and_saturation(GP)

## The following will show a failure, so we wrap it in tryCatch
## so CRAN check does not flag it as a problem.
# Read in a gsp with errors and then make sure all the
# error in it are caught
bad &lt;- readr::read_csv(system.file("extdata/13-member-ped-with-errors.csv", package = "gscramble"))

# check_gsp_for_validity_and_saturation() is called internally from
# within prep_gsp_for_hap_dropping(), after creating a list-from GSP.
# This will show the error produced by check_gsp_for_validity_and_saturation().
badL &lt;- tryCatch(
  prep_gsp_for_hap_dropping(bad),
  error = function(x) 0,
  warning = function(x) 0
)


</code></pre>

<hr>
<h2 id='check_pedigree_for_inbreeding'>Check the a GSP (in prepped list format) for inbreeding loops</h2><span id='topic+check_pedigree_for_inbreeding'></span>

<h3>Description</h3>

<p>After a GSP has been passed through <code>prep_gsp_for_hap_dropping()</code> it
is in a list format with the individuals ordered in such a way that
it should be easy to check for any inbreeding loops in it (which
are not allowed!).  This version uses a simple recursive
approach to compute the ancestry vector for each individual, and it
detects inbreeding by the occurrence of the same ID in the ancestry
vector more than once.  This might be slow on large pedigrees, but for
most that people would use, this should be fine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_pedigree_for_inbreeding(GP)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_pedigree_for_inbreeding_+3A_gp">GP</code></td>
<td>
<p>A gsp in list format as produced by the function
<code>prep_gsp_for_hap_dropping()</code>.  See the documentation for the return
object of <code>prep_gsp_for_hap_dropping()</code> for a description.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the ancestry vector produced by this is not ordered the
way the ancestry vectors are in my package CKMRpop&mdash;for simplicity
I just get a list of ancestors in whatever order they happen to be
reached.
</p>


<h3>Value</h3>

<p>This function does not return anything.  It throws an error via <code>stop()</code> if
inbreeeding loops are found in the pedigree.  Before throwing that error it lists
the individuals with repeated occurrences in their ancestry vectors via the
<code>message()</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get the 13 member pedigree in the data object GSP and
# turn it into a list
GP &lt;- prep_gsp_for_hap_dropping(GSP)

# check it for inbreeding. (There is none)
check_pedigree_for_inbreeding(GP)

## This one will fail, so we wrap it in tryCatch so CRAN
## check doesn't find it a problem.
# To see what happens if there are inbreeding loops, make some
GP_inbred &lt;-  GP
# make 12 be inbred trough individual 6
GP_inbred$`12`$par1$par = "13"
# make 8 inbred (because both of its founder parents are the same!)
GP_inbred$`8`$par2$par = "4"

# now try that:
tryCatch(
  check_pedigree_for_inbreeding(GP_inbred),
  error = function(x) 0,
  warning = function(x) 0
)
</code></pre>

<hr>
<h2 id='check_rec_rates_formatting'>check to make sure that the recombination rates tibble is formatted properly</h2><span id='topic+check_rec_rates_formatting'></span>

<h3>Description</h3>

<p>This is used internally when the rr object is about to be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_rec_rates_formatting(rr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_rec_rates_formatting_+3A_rr">rr</code></td>
<td>
<p>The tibble of recombination-rate bins like RecRates</p>
</td></tr>
</table>

<hr>
<h2 id='check_reppop'>check that the RepPop is formatted correctly</h2><span id='topic+check_reppop'></span>

<h3>Description</h3>

<p>The input 'RepPop' is used in the segregate() function to create admixed individuals based on defined pedigrees (GSP).
In order for segregate() to work, the RepPop defined by the user must be formatted correctly. The function check_repop()
checks the RepPop for errors that would result in errors while using segregate(). Specifically, it checks that you have
three columns with the names ('index','pop', and 'group'), that the class of each column is correct, and that your indices
(column 'index') starts with 1 and all other indices are in consecutive order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_reppop(reppop, request_idx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_reppop_+3A_reppop">reppop</code></td>
<td>
<p>a tibble with the information used to define how individuals among groups combine to form
hybrids. It must consist of the columns (index, pop, group).</p>
</td></tr>
<tr><td><code id="check_reppop_+3A_request_idx">request_idx</code></td>
<td>
<p>The index of the request</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function will return an error message if reppop is not formatted properly. If no issues exist,
a message will be returned stating that the reppop is formatted properly.
</p>

<hr>
<h2 id='computeQs_from_segments'>return the admixture fractions of sampled individuals</h2><span id='topic+computeQs_from_segments'></span>

<h3>Description</h3>

<p>This operates on the output of segregate to add up the lengths
of all the segments segregated to different individuals to
thus compute the admixture fractions of each sampled
individual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeQs_from_segments(S, check_total_length = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeQs_from_segments_+3A_s">S</code></td>
<td>
<p>the tibble output from <code><a href="#topic+segregate">segregate</a></code></p>
</td></tr>
<tr><td><code id="computeQs_from_segments_+3A_check_total_length">check_total_length</code></td>
<td>
<p>TRUE means it checks the total
genome length in each individual to make sure it checks out.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a tibble with the following columns:
</p>

<ul>
<li> <p><code>gpp</code>: the genomic simulation pedigree within which the individual sample was
simulated.
</p>
</li>
<li> <p><code>index</code>: the index which gives which instance of the GSP the sample is from
</p>
</li>
<li> <p><code>ped_sample_id</code>: the id number of that the sampled individual had in the
genomic simulation pedigree.
</p>
</li>
<li> <p><code>samp_index</code>: the index of the sample taken.  Some individuals in some
genomic simulation pedigrees can produce more than one sample. This number
tells you which sample it is.
</p>
</li>
<li> <p><code>pop_origin</code>: the &quot;pedigree&quot; population of origin of the segments that contributed
to the <code>group_length</code>.  These are
the simple &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, etc. designations given in the genomic simulation
pedigree.
</p>
</li>
<li> <p><code>group_origin</code>: Which group of samples the segments contributing to
the <code>group_length</code> originated from.  These are the groups of samples
that were mapped onto the simple pedigree <code>pop_origin</code>s by the reppop
request.
</p>
</li>
<li> <p><code>group_length</code>: the total length of segments from this group in this individual
in this reppop index from this gpp (in bases).
</p>
</li>
<li> <p><code>tot_length</code>: the total number of bases from all origins carried by this
individual.
</p>
</li>
<li> <p><code>admixture_fraction</code>: the fraction of all bases in the simulated individual
that originate from the group in <code>group_origin</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#### Get output from segregate to use as input ####
# We construct an example here where we will request segregation
# down a GSP with two F1s and F1B backcrosses between two hypothetical
# populations, A and B.
gsp_f1f1b &lt;- create_GSP("A", "B", F1 = TRUE, F1B = TRUE)

# We will imagine that in our marker data there are three groups
# labelled "grp1", "grp2", and "grp3", and we want to create the F1Bs with backcrossing
# only to grp3.
reppop &lt;- tibble::tibble(
  index = as.integer(c(1, 1, 2, 2)),
  pop = c("A", "B", "A", "B"),
  group = c("grp3", "grp1", "grp3", "grp2")
)

# combine those into a request
request &lt;- tibble::tibble(
  gpp = list(gsp_f1f1b),
  reppop = list(reppop)
)

# now run it through segregate()
set.seed(5)  # just for reproducibility in example...
simSegs &lt;- segregate(request, RecRates)

#### Now we can run those through computeQs_from_segments() ####
Qs &lt;- computeQs_from_segments(simSegs)

Qs
</code></pre>

<hr>
<h2 id='create_GSP'>Create a GSP from user inputs about what type of hybrids from which populations to create hybrids</h2><span id='topic+create_GSP'></span>

<h3>Description</h3>

<p>This function allows the user to choose two populations and create a GSP input for 'gscramble'.
The input requires two different population IDs of class character as well as at least one TRUE statement for one of
the hybrid parameters (F1, F2, F1B, F1B2). The GSP will indicate hybrid individuals that will be sampled based on
which F1, F2, F1B, and F1B2 parameters are TRUE. F1= TRUE means F1 hybrids will be sampled. F2=TRUE means F2 hybrids
will be sampled. F1B2=TRUE means F1 backcross hybrids will be sampled. F1B2=TRUE means F1 backcross 2 hybrids will be sampled.
Default setting for these parameters is FALSE. The function then outputs a GSP in tibble format that can be used for other
functions in 'gscramble' including <code>check_pedigree_for_inbreeding()</code> and <code>prep_gsp_for_hap_dropping()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_GSP(
  pop1,
  pop2,
  F1 = FALSE,
  F2 = FALSE,
  F1B = FALSE,
  F1B2 = FALSE,
  AllowSinglePop = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_GSP_+3A_pop1">pop1</code></td>
<td>
<p>character name for population 1</p>
</td></tr>
<tr><td><code id="create_GSP_+3A_pop2">pop2</code></td>
<td>
<p>character name for population 2</p>
</td></tr>
<tr><td><code id="create_GSP_+3A_f1">F1</code></td>
<td>
<p>logical indicating whether you would like to have sampled F1 hybrids in the output.</p>
</td></tr>
<tr><td><code id="create_GSP_+3A_f2">F2</code></td>
<td>
<p>logical indicating whether you would like to have sampled F2 hybrids in the output.</p>
</td></tr>
<tr><td><code id="create_GSP_+3A_f1b">F1B</code></td>
<td>
<p>logical indicating whether you would like to have sampled F1 backcross hybrids in the output.</p>
</td></tr>
<tr><td><code id="create_GSP_+3A_f1b2">F1B2</code></td>
<td>
<p>logical indicating whether you would like to have sampled F1 backcross 2 hybrids in the output.</p>
</td></tr>
<tr><td><code id="create_GSP_+3A_allowsinglepop">AllowSinglePop</code></td>
<td>
<p>Set to true if you want all the founders from just a single population.  This
has some use cases...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a GSP in tibble format with the user argument for pop1 and pop2 autopopulated
in the hpop1 and hpop2 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a GSP that generates hybrids and samples F1s and F1B's from pops A and B
gsp &lt;- create_GSP("A", "B", F1 = TRUE, F1B = TRUE)

#create a GSP that generates hybrids and samples F1s, F2s, F1Bs, F1B2s from pops A and B
gsp &lt;- create_GSP("Pop_X", "Pop_Z", F1 = TRUE, F2 = TRUE, F1B = TRUE, F1B2 = TRUE)

</code></pre>

<hr>
<h2 id='drop_segs_down_gsp'>High level function for dropping segments down a GSP</h2><span id='topic+drop_segs_down_gsp'></span>

<h3>Description</h3>

<p>This one asks for the number of reps to do, and it also
automatically does it over chromosomes and returns the results
in a nice tidy tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_segs_down_gsp(GSP, RR, Reps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_segs_down_gsp_+3A_gsp">GSP</code></td>
<td>
<p>the pedigree to use for the simulation, in the format of
the package data <code><a href="#topic+GSP">GSP</a></code>.</p>
</td></tr>
<tr><td><code id="drop_segs_down_gsp_+3A_rr">RR</code></td>
<td>
<p>the recombination rates in the format of the package data
<code><a href="#topic+RecRates">RecRates</a></code></p>
</td></tr>
<tr><td><code id="drop_segs_down_gsp_+3A_reps">Reps</code></td>
<td>
<p>the number of times to do the simulation.  Different replicates
are denoted by the index column in the output tibble.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output from this function is a tibble.  Each row represents one segment of genetic
material amongst the sampled individuals from the genomic permutation pedigrees. The columns give
information about the provenance and destination of that segment as follows.
Each segment exists in one of the samples (<code>samp_index</code>) from a sampled individual
with a <code>ped_sample_id</code>
in a given <code>samp_index</code> within the individual.  Further, it is on one of two gametes
(<code>gamete_index</code>) that segregated into the individual, and it came from a certain founding
population (<code>pop_origin</code>).
And, of course, the segment occupies the space from <code>start</code> to <code>end</code> on a chromosome <code>chrom</code>.
Finally, the index of the founder haplotype on the given gpp that this segement descended from is
given in <code>rs_founder_haplotype</code> which is short for &quot;rep-specific founder haplotype&quot;. This final
piece of information is crucial for segregating variation from the individuals in the <code>Geno</code> file
onto these segments. The <code>gamete_segments</code> column is a list column with duplicated entries for
each chromosome in an individual.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simSegs &lt;- drop_segs_down_gsp(GSP, RecRates, 4)


</code></pre>

<hr>
<h2 id='example_chrom_lengths'>Lengths of the three chromosomes used in the example data set</h2><span id='topic+example_chrom_lengths'></span>

<h3>Description</h3>

<p>These are for the example of how to use <code>plink_map2rec_rates()</code>.
</p>


<h3>Format</h3>

<p>A tibble with two columns: <code>chrom</code> and <code>bp</code>.
</p>


<h3>Source</h3>

<p>These lengths were taken from the maximal values in
Tortereau, Flavie, et al. &quot;A high density
recombination map of the pig reveals a correlation between sex-specific
recombination and GC content.&quot; BMC genomics 13.1 (2012): 1-12. It is available
for download from <a href="https://static-content.springer.com/esm/art%3A10.1186%2F1471-2164-13-586/MediaObjects/12864_2012_4363_MOESM1_ESM.txt">https://static-content.springer.com/esm/art%3A10.1186%2F1471-2164-13-586/MediaObjects/12864_2012_4363_MOESM1_ESM.txt</a>.
After downloading the data were processed to remove inconsistencies with the
marker data set used for M_meta and Geno.
</p>

<hr>
<h2 id='example_segments'>Example of a segments tibble</h2><span id='topic+example_segments'></span>

<h3>Description</h3>

<p>This is the Segments object from the 'gscramble' tutorial.
It is included as a data object to use in the example for
the function <code>plot_simulated_chromosome_segments()</code>.
</p>


<h3>Format</h3>

<p>A tibble like that produced by the <code>segregate()</code> function.
</p>


<h3>Source</h3>

<p>Made from package functions
</p>

<hr>
<h2 id='Geno'>Genotype matrix of 78 individuals and 100 SNP markers</h2><span id='topic+Geno'></span>

<h3>Description</h3>

<p>This dataset represents 3 distinct populations of feral swine in the United States.
To make this dataset computationally efficient, only 3 chromosomes (12, 17, 18) from the pig genome were used.
Further, loci were reduced to the 100 most informative loci for distinguishing the 3 populations.
Each row of the genotype matrix includes the genotypes for a single individual.
The genotype matrix is in a standard &quot;two-column&quot; format for a diploid species
where two adjacent columns make up a locus and each column of a locus contains an allele.
Genotype data is stored in the character class.
Missing data is represented by NAs.
Individual IDs and population assignment information can be found in <code><a href="#topic+I_meta">I_meta</a></code>
Locus and chromosome information for genotypes can be found in <code><a href="#topic+M_meta">M_meta</a></code>
</p>


<h3>Format</h3>

<p>A character matrix. Each row represents an individual and columns contain the genotypes for individuals
in a &quot;two-column&quot; format where two adjacent columns make up a locus with an allele in each column.
</p>


<h3>Source</h3>

<p>USDA-APHIS-WS-National Wildlife Research Center Feral Swine Genetic Archive
</p>

<hr>
<h2 id='gscramble2newhybrids'>Convert 'gscramble' output to newhybrids format</h2><span id='topic+gscramble2newhybrids'></span>

<h3>Description</h3>

<p>This function turns character-based alleles into integers
and writes the necessary headers, etc.  It preferentially uses
the &quot;id&quot; column if it exists in <code>M$ret_ids</code>. Otherwise it uses
the <code>indiv</code> column for the sample names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gscramble2newhybrids(
  M,
  M_meta,
  z = NULL,
  s = NULL,
  retain = NULL,
  outfile = tempfile()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gscramble2newhybrids_+3A_m">M</code></td>
<td>
<p>the output from <code>segments2markers()</code> from 'gscramble'. This could
have an added <code>id</code> column on it, which will then be used for the
sample names.</p>
</td></tr>
<tr><td><code id="gscramble2newhybrids_+3A_m_meta">M_meta</code></td>
<td>
<p>the Marker meta data file.</p>
</td></tr>
<tr><td><code id="gscramble2newhybrids_+3A_z">z</code></td>
<td>
<p>A vector of length two. The values
are regular expressions that the sample names that you want to have
-z 0 or -z 1 should match.  For example <code>c("SH", "CCT")</code> means any
sample matching &quot;SH&quot; would get z0 and any sample matchine &quot;CCT&quot; would
get z1.</p>
</td></tr>
<tr><td><code id="gscramble2newhybrids_+3A_s">s</code></td>
<td>
<p>a single regular expressions that matches individuals that
should be given the -s option. For example &quot;SH|CCT&quot;</p>
</td></tr>
<tr><td><code id="gscramble2newhybrids_+3A_retain">retain</code></td>
<td>
<p>a vector of loci to retain.</p>
</td></tr>
<tr><td><code id="gscramble2newhybrids_+3A_outfile">outfile</code></td>
<td>
<p>path to the file to write the newhybrids data set to. For CRAN
compliance, this is, by default, a temp file. But you can change it to be
anything valid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It allows you to set the -s and -z through some regular expression mapping.
</p>
<p>This function relies a lot on some tidyverse functions
for pivoting, etc.  As such, it is not intended for data sets with
tens of thousands of markers.  You oughtn't be using NewHybrids with
so many markers, anyway!
</p>


<h3>Value</h3>

<p>A list with three components:
</p>

<ul>
<li> <p><code>outfile</code>: outfile name of saved data.
</p>
</li>
<li> <p><code>genos</code>: Genotypes
</p>
</li>
<li> <p><code>allele_names</code>: Allele names.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># get output from segments2markers():
example("segments2markers")
# copy that result to a new variable
M &lt;- s2m_result

# then run it
gscramble2newhybrids(M, M_meta)
</code></pre>

<hr>
<h2 id='gscramble2plink'>Write 'gscramble' I_meta, M_meta, and Geno to a plink file</h2><span id='topic+gscramble2plink'></span>

<h3>Description</h3>

<p>Writes genetic and individual information in 'gscramble's
I_meta, M_meta, and Geno like objects into a uncompressed plink
<code>.ped</code> and <code>.map</code> files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gscramble2plink(I_meta, M_meta, Geno, prefix = tempfile())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gscramble2plink_+3A_i_meta">I_meta</code></td>
<td>
<p>a tibble of individual meta data
with at least the columns of <code>group</code> and <code>indiv</code>.</p>
</td></tr>
<tr><td><code id="gscramble2plink_+3A_m_meta">M_meta</code></td>
<td>
<p>a tibble of marker meta data with at least the columns
of <code>chrom</code>, <code>pos</code>, and <code>variant_id</code>.</p>
</td></tr>
<tr><td><code id="gscramble2plink_+3A_geno">Geno</code></td>
<td>
<p>a character matrix of genotypes.  Num-indivs rows and
num-markers * 2 columns, with missing denoted denoted by NA.</p>
</td></tr>
<tr><td><code id="gscramble2plink_+3A_prefix">prefix</code></td>
<td>
<p>the file path and prefix into which to write out the files</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns TRUE if successful.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gscramble2plink(I_meta, M_meta, Geno)
</code></pre>

<hr>
<h2 id='GSP'>Example Genomic Simulation Pedigree, GSP, with 13 members</h2><span id='topic+GSP'></span>

<h3>Description</h3>

<p>A GSP is a pedigree with no inbreeding which specifies
This is a relatively complex GSP.  The tibble <code>GSP</code> specifies its
structure using the following columns:
</p>

<ul>
<li> <p><code>ind</code>: the numeric identifier for the individual specific to the row
(we will call that the &quot;focal individual&quot;).
</p>
</li>
<li> <p><code>par1</code>: numeric identifier of the first parent of the focal individual.
Must be NA for pedigree founders.
</p>
</li>
<li> <p><code>par2</code>: numeric identifier of the second parent of the focal individual.
Must be NA for pedigree founders.
</p>
</li>
<li> <p><code>ipar1</code>: the number of gametes that will be incoming from the first parent
to the focal individual. Must be NA for pedigree founders. Note that this
must be equal to <code>ipar2</code>.
</p>
</li>
<li> <p><code>ipar2</code>: the number of gametes that will be incoming from the second parent
to the focal individual. Must be NA for pedigree founders. Note that this
must be equal to <code>ipar1</code>.
</p>
</li>
<li> <p><code>hap1</code>: character name for the first haplotype of a founder (if the focal
individual is a founder).  Must be NA for pedigree non-founders.
</p>
</li>
<li> <p><code>hap2</code>: character name for the second haplotype of a founder (if the focal
individual is a founder).  Must be NA for pedigree non-founders.
</p>
</li>
<li> <p><code>hpop1</code>: character ID of the population from which haplotype 1 comes from.
Must be NA for pedigree non-founders.
</p>
</li>
<li> <p><code>hpop2</code>: character ID of the population from which haplotype 2 comes from.
Must be NA for pedigree non-founders.
</p>
</li>
<li> <p><code>sample</code>: character ID for the sample from the focal individual. NA if no samples
are taken from the focal individual, and must be NA for any pedigree founders.
</p>
</li>
<li> <p><code>osample</code>: numeric value giving the number or samples that are taken from this
individual.  <code>osample</code> must be less than or equal to <code>ipar1</code> and <code>ipar2</code>. If
<code>osample</code> is less than <code>ipar1</code> and <code>ipar2</code>, then some gametes must get passed
on to descendants of the focal individual.
</p>
</li></ul>



<h3>Format</h3>

<p>A tibble
</p>


<h3>Details</h3>

<p>The CSV version of this is in <code>extdata/13-member-ped.csv</code>.
</p>


<h3>Source</h3>

<p>Created by the developers.
</p>

<hr>
<h2 id='GSP_opts'>A list of tibbles specifying the pedigrees available from <code>createGSP()</code></h2><span id='topic+GSP_opts'></span>

<h3>Description</h3>

<p>This is a list that is used by the function <code>createGSP()</code>.  There are 15
different genomic simulation pedigrees, specified as tibbles, in this
list.
</p>


<h3>Format</h3>

<p>A list of 15 tibbles
</p>


<h3>Source</h3>

<p>Written by package authors Rachael and Tim
</p>

<hr>
<h2 id='gsp2dot'>Write a dot file to represent a genome simulation pedigree</h2><span id='topic+gsp2dot'></span>

<h3>Description</h3>

<p>This takes the tibble representation of a GSP and writes it to
a dot file to be rendered into a graph using the dot command
from the GraphViz package.  You can easily get GraphViz using Miniconda
or check out the GraphViz downloads page.  If you have the dot
executable in your PATH, then dot will be run on the dot file
and an SVG and a PNG image of the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsp2dot(
  g,
  path = file.path(tempfile(), "file_prefix"),
  edge_label_font_size = 18,
  indiv_node_label_font_size = 18,
  sample_node_label_font_size = 18,
  haplo_origin_colors = c("lightblue", "orange", "blue", "green", "cadetblue",
    "dodgerblue3", "darkolivegreen1", "forestgreen", "lightpink", "red2", "sandybrown",
    "orangered", "plum3", "purple4", "palegoldenrod", "peru"),
  sam_node_color = "violet",
  sample_edge_label_color = "purple",
  parent_edge_label_color = "red"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsp2dot_+3A_g">g</code></td>
<td>
<p>a GSP tibble.</p>
</td></tr>
<tr><td><code id="gsp2dot_+3A_path">path</code></td>
<td>
<p>the path to the file prefix to use (to this will be appended
.dot, and .png or .svg, if dot is on your system). By default these
paths are in a temporary directory, because packages are not allowed to
write to user home directories by default.  Supply a path with prefix,
like <code>my_path/myfile</code> to get the output file <code>mypath.myfile.dot</code></p>
</td></tr>
<tr><td><code id="gsp2dot_+3A_edge_label_font_size">edge_label_font_size</code></td>
<td>
<p>The font size of the number annotations along the edges.</p>
</td></tr>
<tr><td><code id="gsp2dot_+3A_indiv_node_label_font_size">indiv_node_label_font_size</code></td>
<td>
<p>the font size of the labels for the individual nodes</p>
</td></tr>
<tr><td><code id="gsp2dot_+3A_sample_node_label_font_size">sample_node_label_font_size</code></td>
<td>
<p>the font size of the labels for the individual nodes</p>
</td></tr>
<tr><td><code id="gsp2dot_+3A_haplo_origin_colors">haplo_origin_colors</code></td>
<td>
<p>The colors for different origins of haplotypes.
By default there are only sixteen.  If you have more populations that founders
may come from, you should provide a vector with more than 16 colors.</p>
</td></tr>
<tr><td><code id="gsp2dot_+3A_sam_node_color">sam_node_color</code></td>
<td>
<p>The color given to the sample nodes in the GSP.</p>
</td></tr>
<tr><td><code id="gsp2dot_+3A_sample_edge_label_color">sample_edge_label_color</code></td>
<td>
<p>Color for the numeric annotations along the
edges leading to samples.</p>
</td></tr>
<tr><td><code id="gsp2dot_+3A_parent_edge_label_color">parent_edge_label_color</code></td>
<td>
<p>Color for the numeric annotations along the
edges leading from parents to offspring.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It can be tricky knowing whether or not R or Rstudio will read
your Unix rc files and populate your paths appropriately.  If you want to
test whether <code>dot</code> in on your PATH as it is when running under R, try:
<code>Sys.which("dot")</code> at your R console.  If that returns an empty string,
(<code>""</code>), then you need to do something else to make sure R can find <code>dot</code>
on your system.
</p>


<h3>Value</h3>

<p>A vector of file paths.  The first is the path of the dot
file that was produced.  The second and third are only present if
dot was found in the PATH.  They are the paths of the png and svg
files that were produced.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gsp_file &lt;- system.file("extdata/13-member-ped.csv", package = "gscramble")
g &lt;- readr::read_csv(gsp_file)

paths &lt;- gsp2dot(g)
paths

</code></pre>

<hr>
<h2 id='gsp3'>Tibble holding specification for a 5 member genomic permutation pedigree.</h2><span id='topic+gsp3'></span>

<h3>Description</h3>

<p>This has 3 founders
</p>


<h3>Format</h3>

<p>A tibble
</p>


<h3>Details</h3>

<p>For details on the columns, see the documentation for <code><a href="#topic+GSP">GSP</a></code>.
</p>


<h3>Source</h3>

<p>Created by the developers.
</p>

<hr>
<h2 id='gsp4'>Tibble holding specification for a 7 member genomic permutation pedigree.</h2><span id='topic+gsp4'></span>

<h3>Description</h3>

<p>This has 4 founders, each one from a different population, and it provides
four samples that are the product of F1 matings (an A x B F1 crossing with
a C x D F1.)
</p>


<h3>Format</h3>

<p>A tibble
</p>


<h3>Details</h3>

<p>For details on the columns, see the documentation for <code><a href="#topic+GSP">GSP</a></code>.
</p>


<h3>Source</h3>

<p>Created by the developers.
</p>

<hr>
<h2 id='I_meta'>Metadata for 78 individuals</h2><span id='topic+I_meta'></span>

<h3>Description</h3>

<p>The tibble 'I_meta' contains the Individuals IDs and group specifications for 78 individuals. Each row of 'I_meta'
contains the metadata for an individual. 'I_meta' has two columns, a 'group' column with the group or population assignment
for a given individual and an 'indiv' column with the individual sample IDs. The information in each column are stored as characters.
The order of the individual IDs corresponds to the genotypes found in <code><a href="#topic+Geno">Geno</a></code>.
</p>


<h3>Format</h3>

<p>A tibble with two columns: group and indiv.
</p>


<h3>Source</h3>

<p>USDA-APHIS-WS-National Wildlife Research Center Feral Swine Genetic Archive
</p>

<hr>
<h2 id='M_meta'>Metadata for 100 molecular markers</h2><span id='topic+M_meta'></span>

<h3>Description</h3>

<p>This data set contains the metadata for the 100 most divergent SNP loci for three feral swine populations
sampled in the United States. To make the dataset more computationally efficient, only 3 chromosomes were
used (12,17, and 18). The metadata for the SNP loci is in a tibble with three columns:
chrom (character), pos (numeric), variant_id (character).
The column 'chrom' contains the chromosome ID where the SNP is located, the column 'pos' gives the base pair
location on the chromosome, and the column 'variant_id' gives the name of the SNP.
Each row of the metadata tibble contains the metadata for a given SNP locus.
The individual genotypes for each of these SNP loci can be found in <code><a href="#topic+Geno">Geno</a></code>.
</p>


<h3>Format</h3>

<p>A tibble with three columns: chrom, pos, and variant_id.
</p>


<h3>Source</h3>

<p>Chromosome, position, and variant IDs are from the Sus scrofa 10.2 genome <a href="https://www.ncbi.nlm.nih.gov/assembly/GCF_000003025.5/">https://www.ncbi.nlm.nih.gov/assembly/GCF_000003025.5/</a>.
</p>

<hr>
<h2 id='make_subscript_matrix'>makes a two-column matrix for subscripting alleles out of a genotype matrix</h2><span id='topic+make_subscript_matrix'></span>

<h3>Description</h3>

<p>This is intended to be applied to a grouped tibble that
has all the columns that are arguments to the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_subscript_matrix(n, chrom, start, end, abs_column, m_list, num_markers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_subscript_matrix_+3A_n">n</code></td>
<td>
<p>the number of rows in the group of the tibble</p>
</td></tr>
<tr><td><code id="make_subscript_matrix_+3A_chrom">chrom</code></td>
<td>
<p>chromosome names</p>
</td></tr>
<tr><td><code id="make_subscript_matrix_+3A_start">start</code></td>
<td>
<p>starting position of the segment</p>
</td></tr>
<tr><td><code id="make_subscript_matrix_+3A_end">end</code></td>
<td>
<p>ending position of th segment</p>
</td></tr>
<tr><td><code id="make_subscript_matrix_+3A_abs_column">abs_column</code></td>
<td>
<p>the absolute column index of the founder</p>
</td></tr>
<tr><td><code id="make_subscript_matrix_+3A_m_list">m_list</code></td>
<td>
<p>a list column of markers</p>
</td></tr>
<tr><td><code id="make_subscript_matrix_+3A_num_markers">num_markers</code></td>
<td>
<p>the number of markers</p>
</td></tr>
</table>

<hr>
<h2 id='mat_scramble'>Scramble a matrix of genotype data</h2><span id='topic+mat_scramble'></span>

<h3>Description</h3>

<p>This function assumes that M is a matrix with L rows (number of markers) and
2 * N (N = number of individuals) columns.
There are two ways that the data might be permuted.  In the first,
obtained with <code>preserve_haplotypes = FALSE</code>,
the position of missing data within the matrix is held constant, but all
non-missing sites within a row (i.e. all gene copies at a locus) get
scrambled amongst the samples.  In the second way, just the columns are
permuted.  This preserves haplotypes in the data, if there are any.
The second approach should only be used if haplotypes are inferred in
the individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat_scramble(
  M,
  preserve_haplotypes = FALSE,
  row_groups = NULL,
  preserve_individuals = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat_scramble_+3A_m">M</code></td>
<td>
<p>a matrix with L rows (number of markers) and 2 * N columns
where N is the number of individuals. Missing data must be coded
as NA</p>
</td></tr>
<tr><td><code id="mat_scramble_+3A_preserve_haplotypes">preserve_haplotypes</code></td>
<td>
<p>logical indicating whether the haplotypes
set to be TRUE</p>
</td></tr>
<tr><td><code id="mat_scramble_+3A_row_groups">row_groups</code></td>
<td>
<p>if not NULL must be a list of indexes of adjacent rows
that are all in the same groups.  For example: <code>list(1:10, 11:15, 16:30)</code>.
They should be in order and complete.
In practice, these should correspond to the indexes of markers on different
chromosomes.</p>
</td></tr>
<tr><td><code id="mat_scramble_+3A_preserve_individuals">preserve_individuals</code></td>
<td>
<p>logical indicating whether the genes within
each individual should stay togeter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is now an additional way of permuting:  if
<code>preserve_individuals = TRUE</code>, then entire individuals are permuted.
If <code>preserve_haplotypes = FALSE</code>, then the gene copies at each locus
are randomly ordered within each individual before permuating them.
If <code>preserve_haplotypes = TRUE</code> then that initial permutation is not
done.  This should only be done if the individuals are phased and that
phasing is represented in how the genotypes are stored in the matrix.
</p>


<h3>Value</h3>

<p>This function returns a matrix of the same dimensions and storage.mode
as the input, <code>M</code>; however the elements have been permuted according to the
options specified by the users.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make a matrix with alleles named as I.M.g, where I is individual
# number, M is marker number, and g is either "a" or "b" depending
# on which gene copy in the diploid it is.  4 indivs and 7 markers...
Mat &lt;- matrix(
 paste(
   rep(1:4, each = 7 * 2),
   rep(1:7, 4 * 2),
   rep(c("a", "b"), each = 7),
   sep = "."
 ),
 nrow = 7
)

# without preserving haplotypes
S1 &lt;- mat_scramble(Mat)

# preserving haplotypes with markers 1-7 all on one chromosome
S2 &lt;- mat_scramble(Mat, preserve_haplotypes = TRUE)

# preserving haplotypes with markers 1-3 on one chromosome and 4-7 on another
S3 &lt;- mat_scramble(Mat, row_groups = list(1:3, 4:7))

# preserving individuals, but not haplotypes, with two chromosomes
S4 &lt;- mat_scramble(Mat, row_groups = list(1:3, 4:7), preserve_individuals = TRUE)

# preserving individuals by chromosome, but not haplotypes, with two chromosomes
S5 &lt;- mat_scramble(Mat, row_groups = list(1:3, 4:7), preserve_individuals = "BY_CHROM")

# preserving individuals by chromosome, and preserving haplotypes, with two chromosomes
S6 &lt;- mat_scramble(Mat, row_groups = list(1:3, 4:7),
                 preserve_individuals = "BY_CHROM", preserve_haplotypes = TRUE)
</code></pre>

<hr>
<h2 id='perm_gs_by_pops'>Take the output of rearrange_genos and permute everyone by population</h2><span id='topic+perm_gs_by_pops'></span>

<h3>Description</h3>

<p>This is done prior to assigning random genomic fragments of individuals in the
sample to the founders of the GSP, to be dropped to the samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perm_gs_by_pops(GS, preserve_haplotypes = FALSE, preserve_individuals = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perm_gs_by_pops_+3A_gs">GS</code></td>
<td>
<p>the tibble that is the output from rearrange_genos</p>
</td></tr>
<tr><td><code id="perm_gs_by_pops_+3A_preserve_haplotypes">preserve_haplotypes</code></td>
<td>
<p>If TRUE then the Geno data is assumed phased
(first allele at an individual on one haplotype and second allele on the
other) and those haplotypes are preserved in this permutation of
genomic material amongst the founders.</p>
</td></tr>
<tr><td><code id="perm_gs_by_pops_+3A_preserve_individuals">preserve_individuals</code></td>
<td>
<p>If TRUE then whole individuals are permuted
around the data set and the two gene copies at each locus are randomly
permuted within each individual.  If <code>preserve_individuals = "BY_CHROM"</code>,
then the the two copies of each chromosome in an individual are permuted
together.  Thus a permuted individual may have two copies of one chromosome
from one individual, and two copies of another chromosome from a different
individual.  (If <code>preserve_haplotypes = TRUE</code> then
the gene copies are not permuted within individuals. You should only ever
use <code>preserve_haplotypes = TRUE</code> if you have phased data.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of the same format as the output of <code>rearrange_genos</code>.
Plus one additional component. Each component of the return list is itself
an unnamed list with one component (makes it easier to use <code>bind_rows</code> to
create a tibble of list columns from these).  The components, once unlisted are:
</p>

<ul>
<li> <p><code>G</code>: a matrix&mdash;the original genotype data matrix
</p>
</li>
<li> <p><code>I</code>: the I_meta tibble
</p>
</li>
<li> <p><code>M</code>: the M_meta tibble
</p>
</li>
<li> <p><code>G_permed</code>: the genotype matrix after permutation.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># first get the output of rearrange_genos
RG &lt;- rearrange_genos(Geno, I_meta, M_meta)

# then permute by the populations
PG &lt;- perm_gs_by_pops(RG)
</code></pre>

<hr>
<h2 id='plink_map2rec_rates'>Convert a PLINK map file to 'gscramble' RecRates bins in a tibble</h2><span id='topic+plink_map2rec_rates'></span>

<h3>Description</h3>

<p>This is a convenience function to convert PLINK map format to
the format used in the 'gscramble' <code>RecRates</code> object.  By default,
this function will use the positions of the markers and assume
recombination rates of 1 cM per megabase.  If the marker positions
are also available in Morgans in the PLINK map file, the these can be
used by setting <code>use_morgans</code> to TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plink_map2rec_rates(
  map,
  use_morgans = FALSE,
  cM_per_Mb = 1,
  chrom_lengths = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plink_map2rec_rates_+3A_map">map</code></td>
<td>
<p>path to the plink <code>.map</code> file holding information about
the markers.  This file can be gzipped.</p>
</td></tr>
<tr><td><code id="plink_map2rec_rates_+3A_use_morgans">use_morgans</code></td>
<td>
<p>logical. IF true, the third column in the PLINK map
file (assumed to have the position of the markers in Morgans) will be used
to calculate the <code>rec_probs</code> in the bins of the RecRates object.</p>
</td></tr>
<tr><td><code id="plink_map2rec_rates_+3A_cm_per_mb">cM_per_Mb</code></td>
<td>
<p>numeric. If <code>use_morgans</code> is <code>FALSE</code>, physical positions
will be converted to recombination fractions as <code>cM_per_Mb</code> centiMorgans
per megabase.  Default is 1. This is also used to determine the recombination
probability on the last segment of the chromosome (beyond the last marker)
if <code>chrom_lengths</code> is used.</p>
</td></tr>
<tr><td><code id="plink_map2rec_rates_+3A_chrom_lengths">chrom_lengths</code></td>
<td>
<p>if you know the full length of each chromosome, you can
add those in a tibble with columns <code>chrom</code> and <code>bp</code> where <code>chrom</code>
<em>must be a character vector</em> (Don't leave them in as numerics) and <code>bp</code>
must be a numeric vector of the number of base pairs of length of each
chromosome.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For simplicity, this function will assume that the length of the chromosome
is just one base pair beyond the last marker.  That is typically not correct
but will have no effect, since there are no markers to be typed out beyond
that point.  However, if you know the lengths of the chromosomes and want to
add those in there, then pass them into the <code>chrom_lengths</code> option.
</p>


<h3>Value</h3>

<p>A tibble that provides the recombination rates for the segments of the genome.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mapfile &lt;- system.file(
    "extdata/example-plink-with-morgans.map.gz",
    package = "gscramble"
 )

# get a rec-rates tibble from the positions of the markers,
# assuming 1 cM per megabase.
rec_rates_from_positions &lt;- plink_map2rec_rates(mapfile)

# get a rec-rates tibble from the positions of the markers,
# assuming 1.5 cM per megabase.
rec_rates_from_positions_1.5 &lt;- plink_map2rec_rates(
    mapfile,
    cM_per_Mb = 1.5
)

# get a rec-rates tibble from the cumulative Morgans position
# in the plink map file
rec_rates_from_positions_Morg &lt;- plink_map2rec_rates(
    mapfile,
    use_morgans = TRUE
)

# get a rec-rates tibble from the cumulative Morgans position
# in the plink map file, and extend it out to the full length
# of the chromosome (assuming for that last part of the chromosome
# a map of 1.2 cM per megabase.)
rec_rates_from_positions_Morg_fl &lt;- plink_map2rec_rates(
    mapfile,
    use_morgans = TRUE,
    cM_per_Mb = 1.2,
    chrom_lengths = example_chrom_lengths
)
</code></pre>

<hr>
<h2 id='plink2gscramble'>read plink-formatted .map and .ped files into 'gscramble' format</h2><span id='topic+plink2gscramble'></span>

<h3>Description</h3>

<p>This will read .ped and .map files (which can be gzipped, but
cannot be the binary .bed or .bim plink format).  The population
specifier of each individual is assumed to be the first column
(the FID column) in the .ped file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plink2gscramble(ped = NULL, map = NULL, prefix = NULL, gz_ext = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plink2gscramble_+3A_ped">ped</code></td>
<td>
<p>path to the plink <code>.ped</code> file holding information about the
individuals and their genotypes.  This file can also be gzipped.
The function assumes that the second column of this file is unique across
all family IDs. If this is not the case, the function throws a warning.
It is assumed that missing genotypes are denoted by 0's in this file.</p>
</td></tr>
<tr><td><code id="plink2gscramble_+3A_map">map</code></td>
<td>
<p>path to the plink <code>.map</code> file holding information about
the markers.  This file can be gzipped</p>
</td></tr>
<tr><td><code id="plink2gscramble_+3A_prefix">prefix</code></td>
<td>
<p>If map and ped are not given as explicit paths to the
file, you can give the prefix, and it will search for the two files
with the .ped and .map extensions on the end of the prefix.</p>
</td></tr>
<tr><td><code id="plink2gscramble_+3A_gz_ext">gz_ext</code></td>
<td>
<p>Logical.  If TRUE, and specifying files by prefix, this
will add a .gz extension to the map and ped files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three components:
</p>

<ul>
<li> <p><code>I_meta</code>: meta data about the individuals in the file.  This will
include the columns of <code>group</code> (value of the first column of the
ped file) and <code>indiv</code> (the ID of the individual stored in
second column of the ped file). And wil also include the other four
columns of the plink ped specification, named as follows: <code>pa</code>
<code>ma</code>, <code>sex_code</code>, <code>pheno</code>.
</p>
</li>
<li> <p><code>M_meta</code>: meta data about the markers.  A tibble with the columns
<code>chrom</code>, <code>pos</code>, and <code>variant_id</code> and <code>link_pos</code>.  The <code>link_pos</code> column
holds the information about marker position in Morgans or cM that was
included in the <code>map</code> file.
</p>
</li>
<li> <p><code>Geno</code>: a character matrix of genotypes with number-of-indviduals rows
and number-of-markers * 2 columns. Missing genotypes in this matrix
are coded as <code>NA</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>ped_plink &lt;- system.file("extdata/example-plink.ped.gz", package = "gscramble")
map_plink &lt;- system.file("extdata/example-plink.map.gz", package = "gscramble")

result &lt;- plink2gscramble(ped_plink, map_plink)
</code></pre>

<hr>
<h2 id='plot_simulated_chromomsome_segments'>Plot the simulated chromosomes of an individual</h2><span id='topic+plot_simulated_chromomsome_segments'></span>

<h3>Description</h3>

<p>This function uses the information in the tibble about segments
dropped down a genome simulation pedigree to plot the
chromomomes of an individual colored by
the population of origin of each segment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_simulated_chromomsome_segments(
  Segs,
  RR = NULL,
  fill_by_group_origin = FALSE,
  rel_heights = c(chrom_ht = 4, chrom_gap = 0.8, spark_gap = 0.2 * !is.null(RR),
    spark_box = 2.6 * !is.null(RR), unit_gap = 4),
  bottom_gap = 0.3,
  spark_thick = 0.2,
  spark_splat = 0.25
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_simulated_chromomsome_segments_+3A_segs">Segs</code></td>
<td>
<p>a tibble of segments</p>
</td></tr>
<tr><td><code id="plot_simulated_chromomsome_segments_+3A_rr">RR</code></td>
<td>
<p>a tibble of recombination rates in bins in the format
of <a href="#topic+RecRates">RecRates</a>. If this is
included, the recombination rates in cM/Mb are plotted atop the chromosomes
as a little sparkline. If it is not included, then the there are
no little sparklines above the chromosomes.</p>
</td></tr>
<tr><td><code id="plot_simulated_chromomsome_segments_+3A_fill_by_group_origin">fill_by_group_origin</code></td>
<td>
<p>If FALSE (the default) the fill color of segments
is mapped to the pop_origin, which is where the founder haplotypes came from according
to the <code>hpop1</code> and <code>hpop2</code> columns in the GSP specification. If you set this
to TRUE, then we map the &quot;group&quot; column of the reppop to fill.</p>
</td></tr>
<tr><td><code id="plot_simulated_chromomsome_segments_+3A_rel_heights">rel_heights</code></td>
<td>
<p>a vector the the relative heights of the different
elements of each chromosomal unit of the plot.  This is a named vector
with the following elements, listed in order of the bottom of each
unit to the top:
</p>

<ul>
<li> <p><code>chrom_ht</code>: the height of the bars for each of the two chromosomes of the
pair in a chromosome unit.
</p>
</li>
<li> <p><code>chrom_gap</code>: The gap between the two homologous chromosomes of the individual.
</p>
</li>
<li> <p><code>spark_gap</code>: the gap between the top chromosome and the sparkline box
for recombination rates.
</p>
</li>
<li> <p><code>spark_box</code>: height of the box within which the sparkline goes.  Note that
the sparkline itself will be scaled so that the highest rate anywhere within
the genome will correspond to the top of the spark box.
</p>
</li>
<li> <p><code>unit_gap</code>: The relative height of the gap between one chromosome unit and
the next.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_simulated_chromomsome_segments_+3A_bottom_gap">bottom_gap</code></td>
<td>
<p>the y value of the bottom chromosome unit.  Basically the
absolute distance between the y=0 line and the start of the plotted material.
Should typically be between 0 and 1.</p>
</td></tr>
<tr><td><code id="plot_simulated_chromomsome_segments_+3A_spark_thick">spark_thick</code></td>
<td>
<p>thickness of the line that draws the recombination rate
sparkline.</p>
</td></tr>
<tr><td><code id="plot_simulated_chromomsome_segments_+3A_spark_splat">spark_splat</code></td>
<td>
<p>fraction by which the unit gap should be reduced when
there are sparklines being drawn.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a ggplot object.  Each facet of the plot shows
the chromosomes of a different sampled individual from a particular replicate
simulation from a particular genome simulation pedigree.  The facets are titled
like: <code style="white-space: pre;">&#8288;GSP 1, Idx 2, ID 8[3]&#8288;</code>, which means that the chromosomes shown in the panel
are from the third sampled set of chromosomes from the individual with ID 8 from the
simulation from genome simulation pedigree 1 with index 2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- example_segments
rr &lt;- RecRates
g &lt;- plot_simulated_chromomsome_segments(s)
g_with_sparklines &lt;- plot_simulated_chromomsome_segments(s, rr)
</code></pre>

<hr>
<h2 id='prep_gsp_for_hap_dropping'>Take a gsp in tibble form and make a list suitable for gene dropping</h2><span id='topic+prep_gsp_for_hap_dropping'></span>

<h3>Description</h3>

<p>Just a simple function that makes a list-based data structure
that makes it easy to gene-drop chromosome segments down the
gsp.  The basic idea is to get everyone into a data structure
in which they are ordered such that by the time you get to segregating
segments <em>from</em> anyone, you already have the segments segregated <em>into</em> them.
This works by each individual having a list of gametes (post-recombination)
coming out of them, and a list of &quot;uniters&quot; which are the gametes coming
into them.  We just point the uniters to gametes in the previous generation
and then make sure that we shuffle the order of the gametes when they come
out of someone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_gsp_for_hap_dropping(gsp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_gsp_for_hap_dropping_+3A_gsp">gsp</code></td>
<td>
<p>A tibble that holds the genome simulation pedigree (GSP).
This is a tibble in which each row specifies an individual in the
GSP.  The columns of the tibble are:
</p>

<ul>
<li> <p><code>ind</code>: a numeric identifier for that row's indvidual.
</p>
</li>
<li> <p><code>par</code>: the numeric ID of the first parent of the individual (NA if the
individual is a founder of the pedigree).
</p>
</li>
<li> <p><code>par2</code>: the numeric ID of the second parent of the individual (NA if
the individual is a founder)
</p>
</li>
<li> <p><code>ipar1</code>: the number of gametes that <code>par1</code> must segregate &quot;through&quot; <code>ind</code> in
order to exhaust all the genetic material in the GSP.  These values are given
by the red numerals alongside the edge connecting parents to offspring in the
GSP images defined by <code>gsp2dot()</code>.  See the vignette <code>gscramble-tutorial</code>, for
an example. (NA if <code>ind</code> is a founder).
</p>
</li>
<li> <p><code>ipar2</code>: the number of gametes that <code>par2</code> must segregate through <code>ind</code>.
(NA if <code>ind</code> is a founder).
</p>
</li>
<li> <p><code>hap1</code>: a unique character label given to the first haplotype in <code>ind</code> if <code>ind</code> is a
founder.  If <code>ind</code> is not a founder, this must be NA.
</p>
</li>
<li> <p><code>hap2</code>: unique character label given to the second haplotype in <code>ind</code>. NA if <code>ind</code>
is not a founder.
</p>
</li>
<li> <p><code>hpop1</code>: character label giving the population of origin of the first haplotype
(i.e., <code>hap1</code>) in <code>ind</code>, if <code>ind</code> is a founder.  NA otherwise.
</p>
</li>
<li> <p><code>hpop2</code>: character label giving the population of origin of the second
haplotype (i.e., <code>hap2</code>) in <code>ind</code>.  NA if <code>ind</code> is not a founder.
</p>
</li>
<li> <p><code>sample</code>: unique character label for the outcoming diploid sample from the
pedigree member <code>ind</code>. NA if <code>ind</code> is not sampled.
</p>
</li>
<li> <p><code>osample</code>: the number of diploid samples that come out of <code>ind</code>.  NA if
<code>ind</code> is not sampled.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a named list, which is a linked-list type of
structure that contains the same information that is in <code>gsp</code>, but
it makes it easier to access when traversing the pedigree.
</p>
<p>The length of the list is
<code>nrow(gsp)</code>. The names are the character versions of the <code>ind</code> column.
Each component of the list refers to an individual row from <code>gsp</code>.  All
of these list elements are themselves lists. (i.e., the information
about a single individual is stored in a list.) Every such individual
list has at least the two elements:
</p>

<ul>
<li> <p><code>isSample</code>: TRUE if samples are taken from the individual. FALSE otherwise.
</p>
</li>
<li> <p><code>isFounder</code>: TRUE if the individual is a founder.  FALSE otherwise.
</p>
</li>
<li> <p><code>nGamete</code>: The total number of gametes that will be segregated <em>out</em>
of this individual along edges to the <em>offspring</em> of the individual in the pedigree.
This is the sum of all the red numbers alongside edges below the individual in the
GSP.
</p>
</li></ul>

<p>If an individual's <code>isSample</code> is TRUE, then its list also contains the following elements:
</p>

<ul>
<li> <p><code>nSamples</code>: the number of diploid genomes sampled out of this individual.
This is the purple number along the edge to the sample node below the individual
in the GSP &quot;picture&quot;.
</p>
</li></ul>

<p>If an individual's, <code>isFounder</code> is TRUE then its list also contains
the following elements:
</p>

<ul>
<li> <p><code>hpop1</code>: the population from which haplotype 1 in this (founder) individual originated.
</p>
</li>
<li> <p><code>hpop2</code>: the population from which haplotype 2 in this (founder) individual originated.
</p>
</li>
<li> <p><code>fh_idx1</code>: this stands for &quot;founding haplotype index 1.  It is a unique integer
that identifies haplotype one in this founder individual.  This integer is unique over
all haplotypes in all the founder individuals.
</p>
</li>
<li> <p><code>fh_idx2</code>' the unique integer identifier for haplotype two in this founder
individual.
</p>
</li></ul>

<p>If an individual's <code>isFounder</code> is FALSE, then its list also contains
the following elements:
</p>

<ul>
<li> <p><code>par1</code> and <code>par2</code>. Each of these is a list with the elements:
</p>

<ul>
<li> <p><code>par</code>: the character identifier of the first (if in <code>par1</code>) of the
second (if in <code>par2</code>) parent of the individual.
</p>
</li>
<li> <p><code>gam_idx</code>: This tells us which of the gametes in the parent (1 or 2)
depending on if this is in <code>par1</code> or <code>par2</code>, gets segregated to the
individual.  NEED TO EXPLAIN MORE.  SINCE THINGS GET PERMUTED, ETC.
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># get the 13 member complex pedigree in tibble form as the
# package data object GSP and prep it:
GSP_list &lt;- prep_gsp_for_hap_dropping(GSP)
</code></pre>

<hr>
<h2 id='rearrange_genos'>rearrange genotypes into separate columns for each haplotype.</h2><span id='topic+rearrange_genos'></span>

<h3>Description</h3>

<p>This function first reorders individuals in the columns of
the matrix so that every population is together.  Then it
rearranges genotypes into separate columns for each haplotype
(or &quot;halflotype&quot; if they are unphased.)  This prepares the matrix
for different kinds of a permutation (within or between populations,
for example).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rearrange_genos(G, Im, Mm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rearrange_genos_+3A_g">G</code></td>
<td>
<p>the genotype matrix (N rows and 2L columns)</p>
</td></tr>
<tr><td><code id="rearrange_genos_+3A_im">Im</code></td>
<td>
<p>the meta data for the N samples.</p>
</td></tr>
<tr><td><code id="rearrange_genos_+3A_mm">Mm</code></td>
<td>
<p>the meta data for the L markers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It returns a list.  One component is the matrix, another is the
updated individual meta data, and the third is the marker meta
data.
</p>


<h3>Value</h3>

<p>Returns a list. Each component of the return list is itself
an unnamed list with one component (makes it easier to use <code>bind_rows</code> to
create a tibble of list columns from these).  The components, once unlisted are:
</p>

<ul>
<li> <p><code>G</code>: a matrix&mdash;the rearranged genotype data matrix
</p>
</li>
<li> <p><code>I</code>: the I_meta tibble
</p>
</li>
<li> <p><code>M</code>: the M_meta tibble
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>RG &lt;- rearrange_genos(Geno, I_meta, M_meta)
</code></pre>

<hr>
<h2 id='recomb_point'>Randomly sample the positions of recombinations on a chromosome</h2><span id='topic+recomb_point'></span>

<h3>Description</h3>

<p>This function uses the observed recombination fractions such as those
in the data object <a href="#topic+RecRates">RecRates</a>.  These are observed recombination fractions
in a series of adjacent small bins that are defined by a start position
<code>start_pos</code> and ending position <code>end_pos</code>.  This function operates on the
recombination rates for only a single chromosome at a time, so it will
typically be wrapped up inside a <code>purrr::map()</code> function to operate over
multiple chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recomb_point(M, at_least_one = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recomb_point_+3A_m">M</code></td>
<td>
<p>a tibble that has the columns start_pos, end_pos, and rec_prob (where rec_prob is the
probability of a recombination occurring during meiosis within the interval defined by start_pos and end_pos.</p>
</td></tr>
<tr><td><code id="recomb_point_+3A_at_least_one">at_least_one</code></td>
<td>
<p>if this is TRUE then at least one recombination occurs
on every chromosome (see Details).  If FALSE then the total number of recombinations is
simulated as a Poisson r.v. with mean equal to the sum of the
recombination fractions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two main modes by which this function operates. If
<code>at_least_one == TRUE</code>, then the chromosome will always have at least
one recombination.  In this case, the position of that first recombination
is chosen according to the recombination rates.  Subsequently, the remaining
number of recombinations is chosen by the random variable Y, which is
the greater of zero and X - 1, where X is a
Poisson r.v. with mean given by the sum of the
recombination fractions.  These additional recombinations are placed
randomly according to the <code>rec_probs</code> but without interference.
</p>
<p>If <code>at_least_one == FALSE</code> then the total number of recombinations is
simulated as a Poisson r.v. with mean equal to the sum of the
recombination fractions. Again, their placement assumes no interference.
</p>
<p>Locations within each bin are chosen uniformly.  These locations are represented
as real numbers (rather than as integers) and those are used for describing segments,
as well.  This simplifies matters such as condensing information about multiple recombinations
that occurred at the same base pair.  In practice, this will have negligible effects, since
it is so unlikely that a recombination will ever occur in the same place.
</p>
<p>If no recombination occurs, this just returns a zero-length numeric vector.
</p>


<h3>Value</h3>

<p>Returns a numeric vector of recombination breakpoints along the chromome.
The values are sorted in ascending order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># for an example, create a tibble of bins, roughly 1 Mb each,
# on a chromosome of length roughly 150 Mb, and we assign each
# a rec_prob around 0.01
ends &lt;- seq(1e6, 150e6, by = 1e6)
ends &lt;- ends + floor(runif(length(ends), min = -1e4, max = 1e4))
set.seed(5)
M &lt;- tibble::tibble(
    start_pos = c(0, ends[-length(ends)] + 1),
    end_pos = ends,
    rec_prob = abs(rnorm(length(ends), 0.01, 0.004))
)
recomb_point(M)
</code></pre>

<hr>
<h2 id='RecRates'>Recombination rate data for many roughly 1 Mb bins</h2><span id='topic+RecRates'></span>

<h3>Description</h3>

<p>Chromosome, start position and end position and probability of recombination
within the bin for chromosomes in pigs.
</p>


<h3>Format</h3>

<p>A tibble with four columns: chrom, chrom_len, start_pos, end_pos, and rec_prob.
</p>


<h3>Source</h3>

<p>These rates were estimated in: Tortereau, Flavie, et al. &quot;A high density
recombination map of the pig reveals a correlation between sex-specific
recombination and GC content.&quot; BMC genomics 13.1 (2012): 1-12. It is available
for download from <a href="https://static-content.springer.com/esm/art%3A10.1186%2F1471-2164-13-586/MediaObjects/12864_2012_4363_MOESM1_ESM.txt">https://static-content.springer.com/esm/art%3A10.1186%2F1471-2164-13-586/MediaObjects/12864_2012_4363_MOESM1_ESM.txt</a>.
After downloading the data were processed to remove inconsistencies with the
marker data set used for M_meta and Geno.
</p>

<hr>
<h2 id='renumber_GSP'>Renumber GSP members by adding a constant to each</h2><span id='topic+renumber_GSP'></span>

<h3>Description</h3>

<p>This function assumes that all individuals are named as
numerics and that their haplotypes in hap1 and hap2
are named Xa and Xb,respectively, and their
samples are named sX, where X is an integer,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renumber_GSP(G, add)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renumber_GSP_+3A_g">G</code></td>
<td>
<p>a GSP tibble</p>
</td></tr>
<tr><td><code id="renumber_GSP_+3A_add">add</code></td>
<td>
<p>amount to add to each label</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a GSP just like the input, but with the identity numbers
of the individuals in it incremented by <code>add</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get an example GSP
G &lt;- create_GSP(pop1 = "p1", pop2 = "p2", F1B2 = TRUE)


</code></pre>

<hr>
<h2 id='RepPop1'>A simple example of a reppop table</h2><span id='topic+RepPop1'></span>

<h3>Description</h3>

<p>A <code>reppop</code> table in 'gscramble' is used to define how the founder populations
in a GSP (typically named something like &quot;A&quot;, &quot;B&quot;, etc.) are mapped to the
groups/populations of individuals, as specified in the individual meta data
(an example of which is found in <code>I_meta</code>).
</p>


<h3>Format</h3>

<p>A tibble with three columns: <code>index</code>, which must be of type integer,
<code>pop</code>, and <code>group</code> of type character.
</p>


<h3>Details</h3>

<p>This particular version shows a situation where individuals from group Pop1 will be
sampled as founders from A and from group Pop2 will be sampled as founders from
B into the GSP.  Since this <code>RepPop1</code> example has two values of index: 1 and 2,
it specifies that individuals from the populations will be sampled without replacment,
two times into the founders on the pedigree.
</p>


<h3>Source</h3>

<p>The developers created this.
</p>

<hr>
<h2 id='RepPop4'>Another simple example of a reppop table</h2><span id='topic+RepPop4'></span>

<h3>Description</h3>

<p>A <code>reppop</code> table in 'gscramble' is used to define how the founder populations
in a GSP (typically named something like &quot;A&quot;, &quot;B&quot;, etc.) are mapped to the
groups/populations of individuals, as specified in the individual meta data
(an example of which is found in <code>I_meta</code>).
</p>


<h3>Format</h3>

<p>A tibble with three columns: <code>index</code>, which must be of type integer,
<code>pop</code>, and <code>group</code> of type character.
</p>


<h3>Details</h3>

<p>This particular version shows a situation where individuals from four different
groups (Pop1, Pop2, Pop3, and Pop4) get mapped to four different founder groups
(A, B, C, D) in the GSP.
Since this <code>RepPop4</code> example has three values of index: 1, 2, and 3,
it specifies that there will be three rounds of sampling of individuals
from the populations to be the founders on the pedigree.  That will be done
entirely without replacement (individuals are not replaced after each round!)
</p>


<h3>Source</h3>

<p>The developers created this.
</p>

<hr>
<h2 id='seg_haps_through_gsp'>Segregate haplotypes through a genome simulation pedigree list</h2><span id='topic+seg_haps_through_gsp'></span>

<h3>Description</h3>

<p>The main input into this is the list prepared by prep_gsp_for_hap_dropping.
This returns a list of the same form, but with a few extra variables in there,
the most important of which for future use will be the Samples, which are
lists that hold the founder segments that made it into the sampled individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seg_haps_through_gsp(
  G,
  M,
  chrom_len,
  pop_idx_sep = "--%--",
  recomb_model = "always one"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seg_haps_through_gsp_+3A_g">G</code></td>
<td>
<p>a genome simulation pedigree as a list, ready to go</p>
</td></tr>
<tr><td><code id="seg_haps_through_gsp_+3A_m">M</code></td>
<td>
<p>map information.  Should be a tibble with start_pos end_pos
and rec_prob</p>
</td></tr>
<tr><td><code id="seg_haps_through_gsp_+3A_chrom_len">chrom_len</code></td>
<td>
<p>The length of the chromosome in base pairs</p>
</td></tr>
<tr><td><code id="seg_haps_through_gsp_+3A_pop_idx_sep">pop_idx_sep</code></td>
<td>
<p>The string to use to separate the index of the pop
and the index of the founder for naming where chromosomal segments
come from.  It is not recommended that this be changed.</p>
</td></tr>
<tr><td><code id="seg_haps_through_gsp_+3A_recomb_model">recomb_model</code></td>
<td>
<p>Not used for now, but we will want to add that
here, eventually, to specify the kind of recombination model we are using,
and then modify recomb_point to accommodate the different choices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a low-level function that the user will not typically use.
</p>

<hr>
<h2 id='seg2tib'>Takes a gamete in segment format and returns a tibble with Pop and indiv_index</h2><span id='topic+seg2tib'></span>

<h3>Description</h3>

<p>A small helper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seg2tib(s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seg2tib_+3A_s">s</code></td>
<td>
<p>a gamete in segment format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a tibble with columns <code>tmp_seg_names</code>, <code>start</code>, and <code>end</code>,
that show the origin (in <code>tmp_seg_names</code>) of segments that start at <code>start</code>
and end at <code>end</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first make a segment that has pieces from a few different founders
 V &lt;- c(Amy = 0, Bob = 10000, Joe = 30000, Frieda = 40000)
 seg2tib(V)
</code></pre>

<hr>
<h2 id='segments2markers'>Map alleles from scrambled founders to the sampled segments from a GSP.</h2><span id='topic+segments2markers'></span>

<h3>Description</h3>

<p>Map alleles from scrambled founders to the sampled segments from a GSP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segments2markers(
  Segs,
  Im,
  Mm,
  G,
  preserve_haplotypes = FALSE,
  preserve_individuals = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segments2markers_+3A_segs">Segs</code></td>
<td>
<p>the simulated segments. A tibble like that returned from
<code><a href="#topic+segregate">segregate()</a></code>.</p>
</td></tr>
<tr><td><code id="segments2markers_+3A_im">Im</code></td>
<td>
<p>the individual meta data, like that in <code><a href="#topic+I_meta">I_meta</a></code>. A tibble with
columns <code>group</code> and <code>indiv</code>.</p>
</td></tr>
<tr><td><code id="segments2markers_+3A_mm">Mm</code></td>
<td>
<p>the marker meta data formatted like that in <code><a href="#topic+M_meta">M_meta</a></code>. A tibble
with columns <code>chrom</code>, <code>pos</code>, and <code>variant_id</code>.</p>
</td></tr>
<tr><td><code id="segments2markers_+3A_g">G</code></td>
<td>
<p>the marker genotype data as a matrix like <code><a href="#topic+Geno">Geno</a></code>.  This is
a character matrix.  Each row is an individual, and each pair of columns are the
alleles at a locus.  Thus it is N x 2L where N is the number of individuals
and L is the number of markers.</p>
</td></tr>
<tr><td><code id="segments2markers_+3A_preserve_haplotypes">preserve_haplotypes</code></td>
<td>
<p>If TRUE then the Geno data is assumed phased
(first allele at an individual on one haplotype and second allele on the
other) and those haplotypes are preserved in this permutation of
genomic material amongst the founders.</p>
</td></tr>
<tr><td><code id="segments2markers_+3A_preserve_individuals">preserve_individuals</code></td>
<td>
<p>If TRUE then whole individuals are permuted
around the data set and the two gene copies at each locus are randomly
permuted within each individual.  If <code>preserve_individuals = "BY_CHROM"</code>,
then the the two copies of each chromosome in an individual are permuted
together.  Thus a permuted individual may have two copies of one chromosome
from one individual, and two copies of another chromosome from a different
individual.  (If <code>preserve_haplotypes = TRUE</code> then
the gene copies are not permuted within individuals. You should only ever
use <code>preserve_haplotypes = TRUE</code> if you have phased data.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three components:
</p>

<ul>
<li> <p><code>ret_geno</code>: A character matrix where each row is an individual and each pair of
columns are the alleles at a locus, thus it is N x 2L where N is the number of
individuals and L is the number of markers.
</p>
</li>
<li> <p><code>ret_ids</code>: A tibble providing the individual meta data with columns <code>groups</code> and <code>indiv</code>.
</p>
</li>
<li> <p><code>hyb_Qs</code>: A tibble of the admixture Q values.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#### First, get input segments for the function ####
# We construct an example here where we will request segregation
# down a GSP with two F1s and F1B backcrosses between two hypothetical
# populations, A and B.
set.seed(5)
gsp_f1f1b &lt;- create_GSP("A", "B", F1 = TRUE, F1B = TRUE)

# We will imagine that in our marker data there are three groups
# labelled "Pop1", "Pop2", and "Pop3", and we want to create the F1Bs with backcrossing
# only to Pop3.
reppop &lt;- tibble::tibble(
    index = as.integer(c(1, 1, 2, 2)),
    pop = c("A", "B", "A", "B"),
    group = c("Pop3", "Pop1", "Pop3", "Pop2")
)

# combine those into a request
request &lt;- tibble::tibble(
   gpp = list(gsp_f1f1b),
   reppop = list(reppop)
)

# now segegate segments.  Explicitly pass the markers
# in M_meta so that the order of the markers is set efficiently.
segs &lt;- segregate(request, RecRates, M_meta)

#### Now, use segs in an example with segments2markers() ####
# this uses several package data objects that are there for examples
# and illustration.
s2m_result &lt;- segments2markers(segs, I_meta, M_meta, Geno)
</code></pre>

<hr>
<h2 id='segregate'>Segregate segments down genomic simulation pedigrees</h2><span id='topic+segregate'></span>

<h3>Description</h3>

<p>Given a collection of genomic simulation pedigrees and requests
for how many simulations should be done (in the <code>request</code> input),
as well as recombination rates, this simulates the segregation
of segments down through the pedigrees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segregate(request, RR, MM = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segregate_+3A_request">request</code></td>
<td>
<p>a tibble with list columns &quot;gpp&quot; and &quot;reppop&quot;.
Each element of the gpp column is a tibble giving a genomic simulation
pedigree as documented as the input for <code>prep_gsp_for_hap_dropping()</code>.
Each element of the &quot;reppop&quot; column is a tibble with columns
<code>index</code>, <code>pop</code>, <code>group</code>, to indicate which of the founding
populations (&quot;A&quot;, &quot;B&quot;, etc.) correspond to the different groups
(from the <code>group</code> column in, for example, the meta data for individuals
in your genotype data set, like the data object <code>I_meta</code>).
Because it is quite likely that you might wish to iterate
the segregation procedure multiple
times in a single simulation, you can specify that by doing multiple
&quot;reps&quot; (replicates) of the procedure.  <strong>BIG NOTE</strong>: The values in the index column that you
choose must start at 1 and should be dense within.  In other words, if
the max value in the index column is N, then every integer from 1 to N
must be in there.</p>
</td></tr>
<tr><td><code id="segregate_+3A_rr">RR</code></td>
<td>
<p>the recombination rates in the format of the package data</p>
</td></tr>
<tr><td><code id="segregate_+3A_mm">MM</code></td>
<td>
<p>the marker meta data tibble (like M_meta).  If this is NULL (the default) that
is fine.  If not, then it uses the order of the markers in MM to define
the levels of a chrom_f column so that we can sort the rows of the output
correctly, with respect to markers in the Genotype data frame.  This will
let us more efficiently subscript the markers out of the matrix. If MM is
not present, then the function will create <code>chrom_f</code> by using the
order of the chromosomes from RR. If MM is not NULL, then the function
will also check to make sure that the markers are within the extent of the
recombination rate bins, giving an error otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output from this function is a tibble.  Each row represents one segment of genetic
material amongst the sampled individuals from the genomic permutation pedigrees. The columns give
information about the provenance and destination of that segment as follows.
Each segment exists in one of the samples (<code>samp_index</code>) from a sampled individual
with a <code>ped_sample_id</code> on a given <code>gpp</code> (the index giving the row of the request input tibble)
in a given <code>index</code> within the individual.  Further, it is on one of two gametes
(<code>gamete_index</code>) that segregated into the individual, and it came from a certain founding
population (<code>pop_origin</code>) that corresponds to the named groups in the genotype file (<code>group_origin</code>).
And, of course, the segment occupies the space from <code>start</code> to <code>end</code> on a chromosome <code>chrom</code>.
Finally, the index of the founder haplotype on the given gpp that this segement descended from is
given in <code>rs_founder_haplotype</code> which is short for &quot;rep-specific founder haplotype&quot;. This final
piece of information is crucial for segregating variation from the individuals in the <code>Geno</code> file
onto these segments. Finally, the column <code>sim_level_founder_haplo</code> assigns a unique index for each founder
haplotype. This is necessary because any simulation can involve multiple gpps and/or indexes of gpps,
and the founders in each of those must all be unique within a simulation. so that those haplotypes
can all, eventually, be accessed easily out of the genotype matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We construct an example here where we will request segregation
# down a GSP with two F1s and F1B backcrosses between two hypothetical
# populations, A and B.
gsp_f1f1b &lt;- create_GSP("A", "B", F1 = TRUE, F1B = TRUE)

# We will imagine that in our marker data there are three groups
# labelled "grp1", "grp2", and "grp3", and we want to create the F1Bs with backcrossing
# only to grp3.
reppop &lt;- tibble::tibble(
    index = as.integer(c(1, 1, 2, 2)),
    pop = c("A", "B", "A", "B"),
    group = c("grp3", "grp1", "grp3", "grp2")
)

# combine those into a request
request &lt;- tibble::tibble(
   gpp = list(gsp_f1f1b),
   reppop = list(reppop)
)


result1 &lt;- segregate(request, RecRates)

# here we pass it some markers, too
result2 &lt;- segregate(request, RecRates, M_meta)

result1

result2
</code></pre>

<hr>
<h2 id='sim_level_founder_haplos'>computes the simulation-level founder haplotype index for each founder haplo</h2><span id='topic+sim_level_founder_haplos'></span>

<h3>Description</h3>

<p>This takes the output of <code>segregate()</code> and deals with the multiple gpp's and reps
to come up with a unique index for each found haplotype, so that those haplotypes
can all, eventually, be accessed easily out of the genotype matrix.
Along the way, this function does some light checking to make sure that the
<code>rs_founder_haplo</code> values are dense within <code>gpp</code> and <code>index</code> as they should be.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_level_founder_haplos(S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_level_founder_haplos_+3A_s">S</code></td>
<td>
<p>tibble of segments like that produced by <code><a href="#topic+segregate">segregate</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a result that is basically the output of <code>segregate()</code> with
an additional column added to it:  <code>sim_level_founder_haplo</code>.  This is the index
of the haplotype within each <code>group_origin</code> that should be used. For details of the
other columns in the output tibble, see the documentation for <code><a href="#topic+segregate">segregate</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Get output from segregate to use as input ####
# We construct an example here where we will request segregation
# down a GSP with two F1s and F1B backcrosses between two hypothetical
# populations, A and B.
gsp_f1f1b &lt;- create_GSP("A", "B", F1 = TRUE, F1B = TRUE)

# We will imagine that in our marker data there are three groups
# labelled "grp1", "grp2", and "grp3", and we want to create the F1Bs with backcrossing
# only to grp3.
reppop &lt;- tibble::tibble(
  index = as.integer(c(1, 1, 2, 2)),
  pop = c("A", "B", "A", "B"),
  group = c("grp3", "grp1", "grp3", "grp2")
)

# combine those into a request
request &lt;- tibble::tibble(
  gpp = list(gsp_f1f1b),
  reppop = list(reppop)
)

# now run it through segregate()
set.seed(5)  # just for reproducibility in example...
simSegs &lt;- segregate(request, RecRates)

#### Now we can run those through sim_level_founder_haplos() ####
fh &lt;- sim_level_founder_haplos(simSegs)
fh
</code></pre>

<hr>
<h2 id='tidy_up_sampled_haplos'>takes the waka_waka table and returns a simple tibble with results for each sampled &quot;hybridized&quot; gamete from each chromosome
#'
Not yet documented</h2><span id='topic+tidy_up_sampled_haplos'></span>

<h3>Description</h3>

<p>takes the waka_waka table and returns a simple tibble with results for each sampled &quot;hybridized&quot; gamete from each chromosome
#'
Not yet documented
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_up_sampled_haplos(W)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_up_sampled_haplos_+3A_w">W</code></td>
<td>
<p>a tibble.  see how it is used in code below.</p>
</td></tr>
</table>

<hr>
<h2 id='xover'>internal function to do crossovers and create recombinations</h2><span id='topic+xover'></span>

<h3>Description</h3>

<p>This function doesn't choose the recombination points.  That is done with
the function <code>recomb_point()</code>,
and the results are passed into this function. The two inputs <code>V1</code> and
<code>V2</code> represent the two gametes coming into an individual on the pedigree.
Recombination occurs within that individual, and the two resulting gametes
from that recombination are the output.  Typically this is not the way
things happen, of course.  Generally, only one of the two resulting gametes
from the recombination will be segregated to a surviving offspring. But,
since we are interested in segregating genetic material without duplicating
or destroying any of it, we keep track of both gametes that result
from the meiosis/recombination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xover(V1, V2, R)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xover_+3A_v1">V1</code></td>
<td>
<p>integer vector of recombination points already existing on the
first incoming gamete.  Its names are the names of the
founder haplotype that the left end originates from (i.e. it is from the named
haplotype up until it changes at each point).  For example
c(A = 0, B = 12890, B = 30000) would work for a 30 Kb chromosome in which there
is a single recombination just to the right of the point 12890.
(In that example, positions 1 through 12890 are from founder haplotype A, while positions
12891 to 30000 are from founder haplotype B.) Note that these
vectors have to have a first
value of 0 and a final value of the chromosome length.</p>
</td></tr>
<tr><td><code id="xover_+3A_v2">V2</code></td>
<td>
<p>integer vector of breakpoints of the second incoming gamete.  Format
is just like it is for V1.</p>
</td></tr>
<tr><td><code id="xover_+3A_r">R</code></td>
<td>
<p>a vector of new breakpoints to insert into the existing ones on each gamete.
This is usually returned from the function <code>recomb_point()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This sends back two updated gametes, V1 and V2, but with the new points
of recombination stuck in there.  Note, for two incoming gametes there are two
outgoing gametes, but we aren't &quot;re-using&quot; any genomic sequence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' # make the two gametes/chromosomes coming into the function.
#' # Each one has length 30000 and a single existing recombination
V1 &lt;- c(A = 0, B = 10000, B = 30000)
V2 &lt;- c(C = 0, D = 20000, D = 30000)

# now, set a new recombination point at position 15000
xover(V1, V2, R = 15000)

# set three recombination points at 5,000, 15,000, and 25,000:
xover(V1, V2, R = c(5000, 15000, 25000))

# no recombinations (R is a zero length numeric vector)
xover(V1, V2, R = numeric(0))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
