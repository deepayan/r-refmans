<!DOCTYPE html><html><head><title>Help for package TreeDist</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TreeDist}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#TreeDist-package'><p>TreeDist: Distances between Phylogenetic Trees</p></a></li>
<li><a href='#.MASTSizeEdges'><p>Calculate MAST size from edge matrices.</p></a></li>
<li><a href='#.PairMean'><p>Mean of two numbers</p></a></li>
<li><a href='#.TreeDistance'><p>Calculate distance between trees, or lists of trees</p></a></li>
<li><a href='#AllSplitPairings'><p>Variation of information for all split pairings</p></a></li>
<li><a href='#CalculateTreeDistance'><p>Wrapper for tree distance calculations</p></a></li>
<li><a href='#cluster-statistics'><p>Cluster size statistics</p></a></li>
<li><a href='#CompareAll'><p>Distances between each pair of trees</p></a></li>
<li><a href='#Entropy'><p>Entropy in bits</p></a></li>
<li><a href='#GeneralizedRF'><p>Generalized Robinson–Foulds distance</p></a></li>
<li><a href='#JaccardRobinsonFoulds'><p>Jaccard–Robinson–Foulds metric</p></a></li>
<li><a href='#KendallColijn'><p>Kendall–Colijn distance</p></a></li>
<li><a href='#KMeansPP'><p>k-means++ clustering</p></a></li>
<li><a href='#LAPJV'><p>Solve linear assignment problem using LAPJV</p></a></li>
<li><a href='#MappingQuality'><p>Faithfulness of mapped distances</p></a></li>
<li><a href='#MapTrees'><p>Graphical user interface for mapping distances and analysing</p>
tree space</a></li>
<li><a href='#MASTSize'><p>Maximum Agreement Subtree size</p></a></li>
<li><a href='#MatchingSplitDistance'><p>Matching Split Distance</p></a></li>
<li><a href='#median.multiPhylo'><p>Median of a set of trees</p></a></li>
<li><a href='#MeilaVariationOfInformation'><p>Use variation of clustering information to compare pairs of splits</p></a></li>
<li><a href='#MSTSegments'><p>Add minimum spanning tree to plot, colouring by stress</p></a></li>
<li><a href='#NNIDist'><p>Approximate Nearest Neighbour Interchange distance</p></a></li>
<li><a href='#NormalizeInfo'><p>Normalize information against total present in both starting trees</p></a></li>
<li><a href='#NyeSimilarity'><p>Nye <em>et al</em>. (2006) tree comparison</p></a></li>
<li><a href='#PathDist'><p>Path distance</p></a></li>
<li><a href='#Plot3'><p>Pseudo-3D plotting</p></a></li>
<li><a href='#ReportMatching'><p>List clades as text</p></a></li>
<li><a href='#Robinson-Foulds'><p>Robinson–Foulds distances, with adjustments for phylogenetic information</p>
content</a></li>
<li><a href='#SpectralEigens'><p>Eigenvalues for spectral clustering</p></a></li>
<li><a href='#SplitEntropy'><p>Entropy of two splits</p></a></li>
<li><a href='#SplitsCompatible'><p>Are splits compatible?</p></a></li>
<li><a href='#SplitSharedInformation'><p>Shared information content of two splits</p></a></li>
<li><a href='#SPRDist'><p>Approximate Subtree Prune and Regraft distance</p></a></li>
<li><a href='#StartParallel'><p>Calculate distances in parallel</p></a></li>
<li><a href='#TreeDistance'><p>Information-based generalized Robinson–Foulds distances</p></a></li>
<li><a href='#TreeDistPlot'><p>Plot a simple tree</p></a></li>
<li><a href='#TreeInfo'><p>Information content of splits within a tree</p></a></li>
<li><a href='#VisualizeMatching'><p>Visualise a matching</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Calculate and Map Distances Between Phylogenetic Trees</td>
</tr>
<tr>
<td>Version:</td>
<td>2.7.0</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Implements measures of tree similarity, including 
  information-based generalized Robinson-Foulds distances
  (Phylogenetic Information Distance, Clustering Information Distance,
  Matching Split Information Distance; Smith 2020)
  &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtaa614">doi:10.1093/bioinformatics/btaa614</a>&gt;; 
  Jaccard-Robinson-Foulds distances (Bocker et al. 2013)
  &lt;<a href="https://doi.org/10.1007%2F978-3-642-40453-5_13">doi:10.1007/978-3-642-40453-5_13</a>&gt;, 
  including the Nye et al. (2006) metric &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbti720">doi:10.1093/bioinformatics/bti720</a>&gt;;
  the Matching Split Distance (Bogdanowicz &amp; Giaro 2012)
  &lt;<a href="https://doi.org/10.1109%2FTCBB.2011.48">doi:10.1109/TCBB.2011.48</a>&gt;;
  Maximum Agreement Subtree distances;
  the Kendall-Colijn (2016) distance &lt;<a href="https://doi.org/10.1093%2Fmolbev%2Fmsw124">doi:10.1093/molbev/msw124</a>&gt;, and the
  Nearest Neighbour Interchange (NNI) distance, approximated per Li et al. 
  (1996) &lt;<a href="https://doi.org/10.1007%2F3-540-61332-3_168">doi:10.1007/3-540-61332-3_168</a>&gt;.
  Includes tools for visualizing mappings of tree space (Smith 2022)
  &lt;<a href="https://doi.org/10.1093%2Fsysbio%2Fsyab100">doi:10.1093/sysbio/syab100</a>&gt;,
  for calculating the median of sets of trees,
  and for computing the information content of trees and splits.</td>
</tr>
<tr>
<td>Copyright:</td>
<td>Jonker-Volgenant Linear Assignment Problem implementation by
Roy Jonker modified by Yong Yang and Yi Cao.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ms609.github.io/TreeDist/">https://ms609.github.io/TreeDist/</a>,
<a href="https://github.com/ms609/TreeDist/">https://github.com/ms609/TreeDist/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ms609/TreeDist/issues/">https://github.com/ms609/TreeDist/issues/</a></td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://ms609.github.io/packages/">https://ms609.github.io/packages/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), stats,</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape (&ge; 5.0), cli (&ge; 3.0), colorspace, memoise, phangorn (&ge;
2.2.1), Rdpack (&ge; 0.7), shiny, shinyjs, TreeTools (&ge; 1.7.2),</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bookdown, cluster, ggplot2, hypervolume, kdensity, knitr,
MASS, parallel, plotly, PlotTools, protoclust, Quartet, readxl,
rmarkdown, Rcpp (&ge; 1.0.8), rgl, Rogue, spelling, testthat (&ge;
3.0), Ternary (&ge; 1.1.2), TreeDistData (&gt; 0.1.0), TreeSearch
(&ge; 1.4.0), Umatrix, uwot, vdiffr (&ge; 1.0.0),</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, TreeTools,</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/check:</td>
<td>rcmdcheck</td>
</tr>
<tr>
<td>Config/Needs/coverage:</td>
<td>covr</td>
</tr>
<tr>
<td>Config/Needs/memcheck:</td>
<td>devtools</td>
</tr>
<tr>
<td>Config/Needs/metadata:</td>
<td>codemetar</td>
</tr>
<tr>
<td>Config/Needs/revdeps:</td>
<td>revdepcheck</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>pkgdown</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>false</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>X-schema.org-keywords:</td>
<td>phylogenetics, tree-distance</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-25 16:11:53 UTC; pjjg18</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin R. Smith <a href="https://orcid.org/0000-0001-5660-1727"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph, prg],
  Roy Jonker [prg, cph],
  Yong Yang [ctb, cph],
  Yi Cao [ctb, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin R. Smith &lt;martin.smith@durham.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-25 22:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='TreeDist-package'>TreeDist: Distances between Phylogenetic Trees</h2><span id='topic+TreeDist'></span><span id='topic+TreeDist-package'></span>

<h3>Description</h3>

<p>'TreeDist' is an R package that implements a suite of metrics that quantify the
topological distance between pairs of unweighted phylogenetic trees.
It also includes a simple &quot;Shiny&quot; application to allow the visualization of
distance-based tree spaces, and functions to calculate the information content
of trees and splits.
</p>


<h3>Details</h3>

<p>&quot;TreeDist&quot; primarily employs metrics in the category of
&quot;generalized Robinson–Foulds distances&quot;: they are based on comparing splits
(bipartitions) between trees, and thus reflect the relationship data within
trees, with no reference to branch lengths.
Detailed documentation and usage instructions are
<a href="https://ms609.github.io/TreeDist/">available online</a> or in the vignettes.
</p>


<h4>Generalized RF distances</h4>

<p>The <a href="https://ms609.github.io/TreeDist/articles/Robinson-Foulds.html">Robinson–Foulds distance</a>
simply tallies the number of non-trivial splits (sometimes inaccurately
termed clades, nodes or edges) that occur in both trees &ndash; any splits that are
not perfectly identical contributes one point to the distance score of zero,
however similar or different they are.
By overlooking potential similarities between almost-identical splits,
this conservative approach has undesirable properties.
</p>
<p><a href="https://ms609.github.io/TreeDist/articles/Generalized-RF.html">&quot;Generalized&quot; RF metrics</a>
generate <em>matchings</em> that pair each split in one tree with a similar split
in the other.
Each pair of splits is assigned a similarity score; the sum of these scores in
the optimal matching then quantifies the similarity between two trees.
</p>
<p>Different ways of calculating the the similarity between a pair of splits
lead to different tree distance metrics, implemented in the functions below:
</p>

<ul>
<li> <p><a href="https://ms609.github.io/TreeDist/reference/TreeDistance.html"><code>MutualClusteringInfo()</code></a>, <a href="https://ms609.github.io/TreeDist/reference/TreeDistance.html"><code>SharedPhylogeneticInfo()</code></a>
</p>

<ul>
<li><p> Smith (2020) scores matchings based on the amount of information
that one partition contains about the other.  The Mutual Phylogenetic
Information assigns zero similarity to split pairs that cannot
both exist on a single tree; The Mutual
Clustering Information metric is more forgiving, and exhibits more
desirable behaviour; it is the recommended metric for tree comparison.
(Its complement, <a href="https://ms609.github.io/TreeDist/reference/TreeDistance.html"><code>ClusteringInfoDistance()</code></a>, returns a tree
distance.)
</p>
</li></ul>

</li>
<li> <p><a href="https://ms609.github.io/TreeDist/reference/NyeSimilarity.html"><code>NyeSimilarity()</code></a>
</p>

<ul>
<li><p> Nye <em>et al.</em> (2006) score matchings according to the size of the largest
split that is consistent with both of them, normalized against
the Jaccard index.  This approach is extended by Böcker <em>et al</em>. (2013)
with the Jaccard–Robinson–Foulds metric (function
<a href="https://ms609.github.io/TreeDist/reference/JaccardRobinsonFoulds.html"><code>JaccardRobinsonFoulds()</code></a>).
</p>
</li></ul>

</li>
<li> <p><a href="https://ms609.github.io/TreeDist/reference/MatchingSplitDistance.html"><code>MatchingSplitDistance()</code></a>
</p>

<ul>
<li><p> Bogdanowicz and Giaro (2012) and  Lin <em>et al.</em> (2012) independently proposed
counting the number of &quot;mismatched&quot; leaves in a pair of splits.
<a href="https://ms609.github.io/TreeDist/reference/TreeDistance.html"><code>MatchingSplitInfoDistance()</code></a>
provides an information-based equivalent (Smith 2020).
</p>
</li></ul>

</li></ul>

<p>The package also implements the variation of the path distance
proposed by Kendal and Colijn (2016) (function
<a href="https://ms609.github.io/TreeDist/reference/KendallColijn.html"><code>KendallColijn()</code></a>),
approximations of the Nearest-Neighbour Interchange (NNI) distance (function
<a href="https://ms609.github.io/TreeDist/reference/NNIDist.html"><code>NNIDist()</code></a>;
following Li <em>et al.</em> (1996)), and calculates the size (function
<a href="https://ms609.github.io/TreeDist/reference/MASTSize.html"><code>MASTSize()</code></a>) and
information content (function
<a href="https://ms609.github.io/TreeDist/reference/MASTSize.html"><code>MASTInfo()</code></a>) of the
Maximum Agreement Subtree.
</p>
<p>For an implementation of the Tree Bisection and Reconnection (TBR) distance, see
the package '<a href="https://ms609.github.io/TBRDist/index.html">TBRDist</a>'.
</p>



<h3>Tree space analysis</h3>

<p>Map tree spaces and readily visualize mapped landscapes, avoiding
common analytical pitfalls (Smith, forthcoming),
using the inbuilt graphical user interface:
</p>
<div class="sourceCode r"><pre>TreeDist::MapTrees()
</pre></div>
<p>Serious analysts should consult the
<a href="https://ms609.github.io/TreeDist/articles/treespace.html">vignette</a>
for a command-line interface.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Martin R. Smith <a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a> (<a href="https://orcid.org/0000-0001-5660-1727">ORCID</a>) [copyright holder, programmer]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Roy Jonker <a href="mailto:roy_jonker@magiclogic.com">roy_jonker@magiclogic.com</a> [programmer, copyright holder]
</p>
</li>
<li><p> Yong Yang <a href="mailto:yongyanglink@gmail.com">yongyanglink@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Yi Cao [contributor, copyright holder]
</p>
</li></ul>



<h3>References</h3>


<ul>
<li> <p>Böcker S, Canzar S, Klau GW (2013).
&ldquo;The generalized Robinson-Foulds metric.&rdquo;
In Darling A, Stoye J (eds.), <em>Algorithms in Bioinformatics. WABI 2013. Lecture Notes in Computer Science, vol 8126</em>, 156&ndash;169.
Springer, Berlin, Heidelberg.
<a href="https://doi.org/10.1007/978-3-642-40453-5_13">doi:10.1007/978-3-642-40453-5_13</a>.
</p>
</li>
<li> <p>Bogdanowicz D, Giaro K (2012).
&ldquo;Matching split distance for unrooted binary phylogenetic trees.&rdquo;
<em>IEEE/ACM Transactions on Computational Biology and Bioinformatics</em>, <b>9</b>(1), 150&ndash;160.
<a href="https://doi.org/10.1109/TCBB.2011.48">doi:10.1109/TCBB.2011.48</a>.
</p>
</li>
<li> <p>Kendall M, Colijn C (2016).
&ldquo;Mapping phylogenetic trees to reveal distinct patterns of evolution.&rdquo;
<em>Molecular Biology and Evolution</em>, <b>33</b>(10), 2735&ndash;2743.
<a href="https://doi.org/10.1093/molbev/msw124">doi:10.1093/molbev/msw124</a>.
</p>
</li>
<li> <p>Li M, Tromp J, Zhang L (1996).
&ldquo;Some notes on the nearest neighbour interchange distance.&rdquo;
In Goos G, Hartmanis J, Leeuwen J, Cai J, Wong CK (eds.), <em>Computing and Combinatorics</em>, volume 1090, 343&ndash;351.
Springer, Berlin, Heidelberg.
ISBN 978-3-540-61332-9 978-3-540-68461-9, <a href="https://doi.org/10.1007/3-540-61332-3_168">doi:10.1007/3-540-61332-3_168</a>.
</p>
</li>
<li> <p>Lin Y, Rajan V, Moret BME (2012).
&ldquo;A metric for phylogenetic trees based on matching.&rdquo;
<em>IEEE/ACM Transactions on Computational Biology and Bioinformatics</em>, <b>4</b>(9), 1014&ndash;1022.
<a href="https://doi.org/10.1109/TCBB.2011.157">doi:10.1109/TCBB.2011.157</a>.
</p>
</li>
<li> <p>Nye TMW, Liò P, Gilks WR (2006).
&ldquo;A novel algorithm and web-based tool for comparing two alternative phylogenetic trees.&rdquo;
<em>Bioinformatics</em>, <b>22</b>(1), 117&ndash;119.
<a href="https://doi.org/10.1093/bioinformatics/bti720">doi:10.1093/bioinformatics/bti720</a>.
</p>
</li>
<li> <p>Smith MR (2020).
&ldquo;Information theoretic Generalized Robinson-Foulds metrics for comparing phylogenetic trees.&rdquo;
<em>Bioinformatics</em>, <b>36</b>(20), 5007&ndash;5013.
<a href="https://doi.org/10.1093/bioinformatics/btaa614">doi:10.1093/bioinformatics/btaa614</a>.
</p>
</li>
<li> <p>Smith MR (2022).
&ldquo;Robust analysis of phylogenetic tree space.&rdquo;
<em>Systematic Biology</em>, <b>71</b>(5), 1255&ndash;1270.
<a href="https://doi.org/10.1093/sysbio/syab100">doi:10.1093/sysbio/syab100</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Further documentation is available in the
<a href="https://ms609.github.io/TreeDist/articles/">package vignettes</a>, visible from
R using <code>vignette(package = "TreeDist")</code>.
</p>
<p>Other R packages implementing tree distance functions include:
</p>

<ul>
<li> <p><a href="http://ape-package.ird.fr/">ape</a>:
</p>

<ul>
<li> <p><code>cophenetic.phylo()</code>: Cophenetic distance
</p>
</li>
<li> <p><code>dist.topo()</code>: Path (topological) distance, Robinson–Foulds distance.
</p>
</li></ul>

</li>
<li> <p><a href="https://cran.r-project.org/package=phangorn">phangorn</a>
</p>

<ul>
<li> <p><code>treedist()</code>: Path, Robinson–Foulds and approximate SPR distances.
</p>
</li></ul>

</li>
<li> <p><a href="https://ms609.github.io/Quartet/">Quartet</a>: Triplet and Quartet distances,
using the tqDist algorithm.
</p>
</li>
<li> <p><a href="https://ms609.github.io/TBRDist/">TBRDist</a>: TBR and SPR distances on
unrooted trees, using the 'uspr; C library.
</p>
</li>
<li> <p><a href="https://cran.r-project.org/package=distory">distory</a> (unmaintained):
Geodesic distance
</p>
</li></ul>


<hr>
<h2 id='.MASTSizeEdges'>Calculate MAST size from edge matrices.</h2><span id='topic+.MASTSizeEdges'></span>

<h3>Description</h3>

<p>Internal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.MASTSizeEdges(edge1, edge2, nTip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".MASTSizeEdges_+3A_edge1">edge1</code></td>
<td>
<p>Edge matrix of tree 1. <strong>Must be in postorder!</strong></p>
</td></tr>
<tr><td><code id=".MASTSizeEdges_+3A_edge2">edge2</code></td>
<td>
<p>Edge matrix of tree 2.</p>
</td></tr>
<tr><td><code id=".MASTSizeEdges_+3A_ntip">nTip</code></td>
<td>
<p>Integer specifying the number of leaves in each split.</p>
</td></tr>
</table>

<hr>
<h2 id='.PairMean'>Mean of two numbers</h2><span id='topic+.PairMean'></span>

<h3>Description</h3>

<p>Used for normalization and range calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.PairMean(x, y)
</code></pre>

<hr>
<h2 id='.TreeDistance'>Calculate distance between trees, or lists of trees</h2><span id='topic+.TreeDistance'></span>

<h3>Description</h3>

<p>Calculate distance between trees, or lists of trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.TreeDistance(Func, tree1, tree2, checks = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".TreeDistance_+3A_checks">checks</code></td>
<td>
<p>Logical specifying whether to perform basic sanity checks to
avoid crashes in C++.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalculateTreeDistance">CalculateTreeDistance</a></code>
</p>

<hr>
<h2 id='AllSplitPairings'>Variation of information for all split pairings</h2><span id='topic+AllSplitPairings'></span>

<h3>Description</h3>

<p>Calculate the variation of clustering information
(Meila 2007) for each possible pairing of
non-trivial splits on <em>n</em> leaves (Smith 2020),
tabulating the number of pairings with each similarity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AllSplitPairings(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AllSplitPairings_+3A_n">n</code></td>
<td>
<p>Integer specifying the number of leaves in a tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>AllSplitPairings()</code> returns a named vector. The name of each
element corresponds to a certain variation of information, in bits; the
value of each element specifies the number of pairings of non-trivial
splits that give rise to that variation of information.
Split <code>AB|CD</code>  is treated as distinct from <code>CD|AB</code>.  If pairing
<code>AB|CD</code>=<code>CD|AB</code> is considered equivalent to <code>CD|AB</code>=<code>CD|AB</code> (etc), then
values should be divided by four.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Meila M (2007).
&ldquo;Comparing clusterings&mdash;an information based distance.&rdquo;
<em>Journal of Multivariate Analysis</em>, <b>98</b>(5), 873&ndash;895.
<a href="https://doi.org/10.1016/j.jmva.2006.11.013">doi:10.1016/j.jmva.2006.11.013</a>.<br /><br /> Smith MR (2020).
&ldquo;Information theoretic Generalized Robinson-Foulds metrics for comparing phylogenetic trees.&rdquo;
<em>Bioinformatics</em>, <b>36</b>(20), 5007&ndash;5013.
<a href="https://doi.org/10.1093/bioinformatics/btaa614">doi:10.1093/bioinformatics/btaa614</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>AllSplitPairings(6)
# Treat equivalent splits as identical by dividing by four:
AllSplitPairings(6) / 4L
</code></pre>

<hr>
<h2 id='CalculateTreeDistance'>Wrapper for tree distance calculations</h2><span id='topic+CalculateTreeDistance'></span>

<h3>Description</h3>

<p>Calls tree distance functions from trees or lists of trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateTreeDistance(Func, tree1, tree2 = NULL, reportMatching = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculateTreeDistance_+3A_func">Func</code></td>
<td>
<p>Tree distance function.</p>
</td></tr>
<tr><td><code id="CalculateTreeDistance_+3A_tree1">tree1</code>, <code id="CalculateTreeDistance_+3A_tree2">tree2</code></td>
<td>
<p>Trees of class <code>phylo</code>, with leaves labelled identically,
or lists of such trees to undergo pairwise comparison.  Where implemented,
<code>tree2 = NULL</code> will compute distances between each pair of trees in the list
<code>tree1</code> using a fast algorithm based on Day (1985).</p>
</td></tr>
<tr><td><code id="CalculateTreeDistance_+3A_reportmatching">reportMatching</code></td>
<td>
<p>Logical specifying whether to return the clade
matchings as an attribute of the score.</p>
</td></tr>
<tr><td><code id="CalculateTreeDistance_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>Func</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>

<hr>
<h2 id='cluster-statistics'>Cluster size statistics</h2><span id='topic+cluster-statistics'></span><span id='topic+SumOfRanges'></span><span id='topic+SumOfVariances'></span><span id='topic+SumOfVars'></span><span id='topic+MeanCentroidDistance'></span><span id='topic+MeanCentDist'></span><span id='topic+MeanCentroidDist'></span><span id='topic+DistanceFromMedian'></span><span id='topic+DistFromMed'></span><span id='topic+MeanNN'></span><span id='topic+MeanMSTEdge'></span>

<h3>Description</h3>

<p>Cluster size statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SumOfRanges(x, cluster = 1)

SumOfVariances(x, cluster = 1)

SumOfVars(x, cluster = 1)

MeanCentroidDistance(x, cluster = 1)

MeanCentDist(x, cluster = 1)

MeanCentroidDist(x, cluster = 1)

DistanceFromMedian(x, cluster = 1)

DistFromMed(x, cluster = 1)

MeanNN(x, cluster = 1)

MeanMSTEdge(x, cluster = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster-statistics_+3A_x">x</code></td>
<td>
<p>Matrix in which each row lists the coordinates of a point
in a Euclidian space; or, where supported, <code>dist</code> object specifying
distances between each pair of points.</p>
</td></tr>
<tr><td><code id="cluster-statistics_+3A_cluster">cluster</code></td>
<td>
<p>Optional integer vector specifying the cluster or group to
which each row in <code>x</code> belongs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SumOfRanges()</code> returns a numeric specifying the sum of ranges
within each cluster across all dimensions.
</p>
<p><code>SumOfVariances()</code> returns a numeric specifying the sum of variances
within each cluster across all dimensions.
</p>
<p><code>MeanCentroidDistance()</code> returns a numeric specifying the mean
distance from the centroid to points in each cluster.
</p>
<p><code>DistanceFromMedian()</code> returns a numeric specifying the mean distance
of each point (except the median) from the median point of its cluster.
</p>
<p><code>MeanNN()</code> returns a numeric specifying the mean distance from each
point within a cluster to its nearest neighbour.
</p>
<p><code>MeanMSTEdge()</code> returns a numeric specifying the mean length of an
edge in the minimum spanning tree of points within each cluster.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree space functions: 
<code><a href="#topic+MSTSegments">MSTSegments</a>()</code>,
<code><a href="#topic+MapTrees">MapTrees</a>()</code>,
<code><a href="#topic+MappingQuality">MappingQuality</a>()</code>,
<code><a href="#topic+SpectralEigens">SpectralEigens</a>()</code>,
<code><a href="#topic+median.multiPhylo">median.multiPhylo</a>()</code>
</p>
<p>Other cluster functions: 
<code><a href="#topic+KMeansPP">KMeansPP</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>points &lt;- rbind(matrix(1:16, 4), rep(1, 4), matrix(1:32, 8, 4) / 10)
cluster &lt;- rep(1:3, c(4, 1, 8))

plot(
  points[, 1:2], # Plot first two dimensions of four-dimensional space
  col = cluster, pch = cluster, # Style by cluster membership
  asp = 1, # Fix aspect ratio to avoid distortion
  ann = FALSE, frame = FALSE # Simple axes
)

SumOfRanges(points, cluster)
SumOfVariances(points, cluster)
MeanCentroidDistance(points, cluster)
DistanceFromMedian(points, cluster)
MeanNN(points, cluster)
MeanMSTEdge(points, cluster)
</code></pre>

<hr>
<h2 id='CompareAll'>Distances between each pair of trees</h2><span id='topic+CompareAll'></span>

<h3>Description</h3>

<p>Calculate the distance between each tree in a list, and each other tree
in the same list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompareAll(x, Func, FUN.VALUE = Func(x[[1]], x[[1]], ...), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CompareAll_+3A_x">x</code></td>
<td>
<p>List of trees, in the format expected by <code>Func()</code>.</p>
</td></tr>
<tr><td><code id="CompareAll_+3A_func">Func</code></td>
<td>
<p>distance function returning distance between two trees,
e.g. <code><a href="phangorn.html#topic+treedist">path.dist()</a></code>.</p>
</td></tr>
<tr><td><code id="CompareAll_+3A_fun.value">FUN.VALUE</code></td>
<td>
<p>Format of output of <code>Func()</code>, to be passed to <code><a href="base.html#topic+vapply">vapply()</a></code>.
If unspecified, calculated by running <code>Func(x[[1]], x[[1]])</code>.</p>
</td></tr>
<tr><td><code id="CompareAll_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to <code>Func()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>CompareAll()</code> is not limited to tree comparisons:
<code>Func</code> can be any symmetric function.
</p>


<h3>Value</h3>

<p><code>CompareAll()</code> returns a distance matrix of class <code>dist</code> detailing
the distance between each pair of trees.
Identical trees are assumed to have zero distance.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a list of trees to compare
library("TreeTools", quietly = TRUE)
trees &lt;- list(bal1 = BalancedTree(1:8), 
              pec1 = PectinateTree(1:8),
              pec2 = PectinateTree(c(4:1, 5:8)))
  
# Compare each tree with each other tree
CompareAll(trees, NNIDist)
  
# Providing FUN.VALUE yields a modest speed gain:
dist &lt;- CompareAll(trees, NNIDist, FUN.VALUE = integer(7))
  
# View distances as a matrix
as.matrix(dist$lower)
</code></pre>

<hr>
<h2 id='Entropy'>Entropy in bits</h2><span id='topic+Entropy'></span>

<h3>Description</h3>

<p>Calculate the entropy of a vector of probabilities, in bits.
Probabilities should sum to one.
Probabilities equalling zero will be ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Entropy(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Entropy_+3A_...">...</code></td>
<td>
<p>Numerics or numeric vector specifying probabilities of outcomes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Entropy()</code> returns the entropy of the specified probabilities,
in bits.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Entropy(1/2, 0, 1/2) # = 1
Entropy(rep(1/4, 4)) # = 2
</code></pre>

<hr>
<h2 id='GeneralizedRF'>Generalized Robinson–Foulds distance</h2><span id='topic+GeneralizedRF'></span>

<h3>Description</h3>

<p>An internal function to calculate Generalized Robinson–Foulds
distances from splits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeneralizedRF(
  splits1,
  splits2,
  nTip,
  PairScorer,
  maximize,
  reportMatching,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeneralizedRF_+3A_splits1">splits1</code>, <code id="GeneralizedRF_+3A_splits2">splits2</code></td>
<td>
<p>Logical matrices where each row corresponds to a leaf,
either listed in the same order or bearing identical names (in any sequence),
and each column corresponds to a split, such that each leaf is identified as
a member of the ingroup (<code>TRUE</code>) or outgroup (<code>FALSE</code>) of the respective
split.</p>
</td></tr>
<tr><td><code id="GeneralizedRF_+3A_ntip">nTip</code></td>
<td>
<p>Integer specifying the number of leaves in each split.</p>
</td></tr>
<tr><td><code id="GeneralizedRF_+3A_pairscorer">PairScorer</code></td>
<td>
<p>function taking four arguments, <code>splits1</code>, <code>splits2</code>,
<code>nSplits1</code>, <code>nSplits2</code>, which should return the score of each pair of splits
in a two-dimensional matrix.  Additional parameters may be specified via
....</p>
</td></tr>
<tr><td><code id="GeneralizedRF_+3A_reportmatching">reportMatching</code></td>
<td>
<p>Logical specifying whether to return the clade
matchings as an attribute of the score.</p>
</td></tr>
<tr><td><code id="GeneralizedRF_+3A_...">...</code></td>
<td>
<p>Additional parameters to <code>PairScorer</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that no checks will be made to confirm that <code>splits1</code> and <code>splits2</code>
contain the same leaves in the same order.
This is the responsibility of the calling function.
</p>


<h3>Value</h3>

<p>A numeric value specifying the score of the tree pairs under the
specified pair scorer. If <code>reportMatching = TRUE</code>, attribute also list:
</p>

<ul>
<li> <p><code>matching</code>: which split in <code>splits2</code> is optimally matched to each split in
<code>split1</code> (<code>NA</code> if not matched);
</p>
</li>
<li> <p><code>pairScores</code>: Calculated scores for each possible matching of each split.
</p>
</li>
<li> <p><code>matchedSplits</code>: Textual representation of each match
</p>
</li></ul>



<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>

<hr>
<h2 id='JaccardRobinsonFoulds'>Jaccard–Robinson–Foulds metric</h2><span id='topic+JaccardRobinsonFoulds'></span><span id='topic+JaccardSplitSimilarity'></span>

<h3>Description</h3>

<p>Calculate the
<a href="https://ms609.github.io/TreeDist/articles/Generalized-RF.html#jaccard-robinson-foulds-metric">Jaccard–Robinson–Foulds metric</a>
(Böcker et al. 2013), a
<a href="https://ms609.github.io/TreeDist/articles/Robinson-Foulds.html#generalized-robinson-foulds-distances">Generalized Robinson–Foulds metric</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JaccardRobinsonFoulds(
  tree1,
  tree2 = NULL,
  k = 1L,
  allowConflict = TRUE,
  similarity = FALSE,
  normalize = FALSE,
  reportMatching = FALSE
)

JaccardSplitSimilarity(
  splits1,
  splits2,
  nTip = attr(splits1, "nTip"),
  k = 1L,
  allowConflict = TRUE,
  reportMatching = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JaccardRobinsonFoulds_+3A_tree1">tree1</code>, <code id="JaccardRobinsonFoulds_+3A_tree2">tree2</code></td>
<td>
<p>Trees of class <code>phylo</code>, with leaves labelled identically,
or lists of such trees to undergo pairwise comparison.  Where implemented,
<code>tree2 = NULL</code> will compute distances between each pair of trees in the list
<code>tree1</code> using a fast algorithm based on Day (1985).</p>
</td></tr>
<tr><td><code id="JaccardRobinsonFoulds_+3A_k">k</code></td>
<td>
<p>An arbitrary exponent to which to raise the Jaccard index.
Integer values greater than one are anticipated by Böcker <em>et al</em>.
The Nye <em>et al</em>. metric uses <code>k = 1</code>.
As k increases towards infinity, the metric converges to the Robinson–Foulds
metric.</p>
</td></tr>
<tr><td><code id="JaccardRobinsonFoulds_+3A_allowconflict">allowConflict</code></td>
<td>
<p>Logical specifying whether to allow conflicting splits
to be paired. If <code>FALSE</code>, such pairings will be allocated a similarity
score of zero.</p>
</td></tr>
<tr><td><code id="JaccardRobinsonFoulds_+3A_similarity">similarity</code></td>
<td>
<p>Logical specifying whether to report the result as a tree
similarity, rather than a difference.</p>
</td></tr>
<tr><td><code id="JaccardRobinsonFoulds_+3A_normalize">normalize</code></td>
<td>
<p>If a numeric value is provided, this will be used as a
maximum value against which to rescale results.
If <code>TRUE</code>, results will be rescaled against a maximum value calculated from
the specified tree sizes and topology, as specified in the &quot;Normalization&quot;
section below.
If <code>FALSE</code>, results will not be rescaled.</p>
</td></tr>
<tr><td><code id="JaccardRobinsonFoulds_+3A_reportmatching">reportMatching</code></td>
<td>
<p>Logical specifying whether to return the clade
matchings as an attribute of the score.</p>
</td></tr>
<tr><td><code id="JaccardRobinsonFoulds_+3A_splits1">splits1</code>, <code id="JaccardRobinsonFoulds_+3A_splits2">splits2</code></td>
<td>
<p>Logical matrices where each row corresponds to a leaf,
either listed in the same order or bearing identical names (in any sequence),
and each column corresponds to a split, such that each leaf is identified as
a member of the ingroup (<code>TRUE</code>) or outgroup (<code>FALSE</code>) of the respective
split.</p>
</td></tr>
<tr><td><code id="JaccardRobinsonFoulds_+3A_ntip">nTip</code></td>
<td>
<p>(Optional) Integer specifying the number of leaves in each split.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In short, the Jaccard–Robinson–Foulds
metric is a generalized Robinson-Foulds
metric: it finds the optimal matching that pairs each split in one tree with
a similar split in the second.
Matchings are scored according to the size of the largest split that is
consistent with both of them, normalized against the Jaccard index, and
raised to an arbitrary exponent.
A more detailed explanation is provided in the
<a href="https://ms609.github.io/TreeDist/articles/Generalized-RF.html#jaccard-robinson-foulds-metric">vignettes</a>.
</p>
<p>By default, conflicting splits may be paired.
</p>
<p>Note that the settings <code style="white-space: pre;">&#8288;k = 1, allowConflict = TRUE, similarity = TRUE&#8288;</code>
give the similarity metric of Nye et al. (2006);
a slightly faster implementation of this metric is available as
<code><a href="#topic+NyeSimilarity">NyeSimilarity()</a></code>.
</p>
<p>The examples section below details how to visualize matchings with
non-default parameter values.
</p>
<p>Trees need not contain identical leaves; scores are based on the leaves that
trees hold in common.  Check for unexpected differences in tip labelling
with <code>setdiff(TipLabels(tree1), TipLabels(tree2))</code>.
</p>


<h3>Value</h3>

<p><code>JaccardRobinsonFoulds()</code> returns an array of numerics providing the
distances between each  pair of trees in <code>tree1</code> and <code>tree2</code>,
or <code>splits1</code> and <code>splits2</code>.
</p>


<h3>Normalization</h3>

<p>If <code>normalize = TRUE</code>, then results will be rescaled from zero to one by
dividing by the maximum possible value for trees of the given topologies,
which is equal to the sum of the number of splits in each tree.
You may wish to normalize instead against the maximum number of splits
present in a pair of trees with <em>n</em> leaves, by specifying
<code>normalize = n - 3</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Böcker S, Canzar S, Klau GW (2013).
&ldquo;The generalized Robinson-Foulds metric.&rdquo;
In Darling A, Stoye J (eds.), <em>Algorithms in Bioinformatics. WABI 2013. Lecture Notes in Computer Science, vol 8126</em>, 156&ndash;169.
Springer, Berlin, Heidelberg.
<a href="https://doi.org/10.1007/978-3-642-40453-5_13">doi:10.1007/978-3-642-40453-5_13</a>.<br /><br /> Nye TMW, Liò P, Gilks WR (2006).
&ldquo;A novel algorithm and web-based tool for comparing two alternative phylogenetic trees.&rdquo;
<em>Bioinformatics</em>, <b>22</b>(1), 117&ndash;119.
<a href="https://doi.org/10.1093/bioinformatics/bti720">doi:10.1093/bioinformatics/bti720</a>.
</p>


<h3>See Also</h3>

<p>Other tree distances: 
<code><a href="#topic+KendallColijn">KendallColijn</a>()</code>,
<code><a href="#topic+MASTSize">MASTSize</a>()</code>,
<code><a href="#topic+MatchingSplitDistance">MatchingSplitDistance</a>()</code>,
<code><a href="#topic+NNIDist">NNIDist</a>()</code>,
<code><a href="#topic+NyeSimilarity">NyeSimilarity</a>()</code>,
<code><a href="#topic+PathDist">PathDist</a>()</code>,
<code><a href="#topic+Robinson-Foulds">Robinson-Foulds</a></code>,
<code><a href="#topic+SPRDist">SPRDist</a>()</code>,
<code><a href="#topic+TreeDistance">TreeDistance</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2)
tree1 &lt;- ape::rtree(10)
tree2 &lt;- ape::rtree(10)
JaccardRobinsonFoulds(tree1, tree2, k = 2, allowConflict = FALSE)
JaccardRobinsonFoulds(tree1, tree2, k = 2, allowConflict = TRUE)

JRF2 &lt;- function(tree1, tree2, ...) 
  JaccardRobinsonFoulds(tree1, tree2, k = 2, allowConflict = FALSE, ...)
  
VisualizeMatching(JRF2, tree1, tree2, matchZeros = FALSE)
</code></pre>

<hr>
<h2 id='KendallColijn'>Kendall–Colijn distance</h2><span id='topic+KendallColijn'></span><span id='topic+KCVector'></span><span id='topic+PathVector'></span><span id='topic+SplitVector'></span><span id='topic+KCDiameter'></span>

<h3>Description</h3>

<p>Calculate the Kendall–Colijn tree distance, a measure related to the
path difference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KendallColijn(tree1, tree2 = NULL, Vector = KCVector)

KCVector(tree)

PathVector(tree)

SplitVector(tree)

KCDiameter(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KendallColijn_+3A_tree1">tree1</code>, <code id="KendallColijn_+3A_tree2">tree2</code></td>
<td>
<p>Trees of class <code>phylo</code>, with leaves labelled identically,
or lists of such trees to undergo pairwise comparison.  Where implemented,
<code>tree2 = NULL</code> will compute distances between each pair of trees in the list
<code>tree1</code> using a fast algorithm based on Day (1985).</p>
</td></tr>
<tr><td><code id="KendallColijn_+3A_vector">Vector</code></td>
<td>
<p>Function converting a tree to a numeric vector.
</p>
<p><code>KCVector</code>, the default, returns the number of edges between the common
ancestor of each pair of leaves and the root of the tree
(per Kendall and Colijn 2016).
</p>
<p><code>PathVector</code> returns the number of edges between each pair of leaves
(per Steel and Penny 1993).
</p>
<p><code>SplitVector</code> returns the size of the smallest split that contains each
pair of leaves (per Smith 2022).</p>
</td></tr>
<tr><td><code id="KendallColijn_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+read.tree">phylo</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Kendall–Colijn distance works by measuring, for each pair of
leaves, the distance from the most recent common ancestor of those leaves
and the root node.
For a given tree, this produces a vector of values recording the
distance-from-the-root of each most recent common ancestor of each pair of
leaves.
</p>
<p>Two trees are compared by taking the Euclidean distance between the
respective vectors.  This is calculated by taking the square root of the sum
of the squares of the differences between the vectors.
</p>
<p>An analogous distance can be created from any vector representation of a
tree.
The split size vector metric (Smith 2022) is an attempt
to mimic the Kendall Colijn metric in situations where the position of
the root should not be afforded special significance; and the path distance
(Steel and Penny 1993) is a familiar alternative whose underlying
vector measures the distance of the last common ancestor of each pair
of leaves from the leaves themselves, i.e. the length of the path from one
leaf to another.
</p>
<p>None of these vector-based methods performs as well as other tree distances
in measuring similarities in the relationships implied by a pair of trees
(Smith 2020); in particular, the Kendall Colijn
metric is strongly influenced by tree balance, and may not be appropriate
for a suite of common applications (Smith 2022).
</p>


<h3>Value</h3>

<p><code>KendallColijn()</code> returns an array of numerics providing the
distances between each  pair of trees in <code>tree1</code> and <code>tree2</code>,
or <code>splits1</code> and <code>splits2</code>.
</p>
<p><code>KCDiameter()</code> returns the value of the Kendall &amp; Colijn's (2016)
metric distance between two pectinate trees with <em>n</em> leaves ordered in
the opposite direction, which I suggest (without any attempt at a proof) may
be a useful proxy for the diameter (i.e. maximum value) of the K–C
metric.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>KCVector()</code>: Creates a vector that characterises a rooted tree,
as described in Kendall and Colijn (2016).
</p>
</li>
<li> <p><code>PathVector()</code>: Creates a vector reporting the number of edges
between each pair of leaves, per the path metric of
Steel and Penny (1993).
</p>
</li>
<li> <p><code>SplitVector()</code>: Creates a vector reporting the smallest split
containing each pair of leaves, per the metric proposed in
Smith (2022).
</p>
</li></ul>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Kendall M, Colijn C (2016).
&ldquo;Mapping phylogenetic trees to reveal distinct patterns of evolution.&rdquo;
<em>Molecular Biology and Evolution</em>, <b>33</b>(10), 2735&ndash;2743.
<a href="https://doi.org/10.1093/molbev/msw124">doi:10.1093/molbev/msw124</a>.<br /><br /> Smith MR (2020).
&ldquo;Information theoretic Generalized Robinson-Foulds metrics for comparing phylogenetic trees.&rdquo;
<em>Bioinformatics</em>, <b>36</b>(20), 5007&ndash;5013.
<a href="https://doi.org/10.1093/bioinformatics/btaa614">doi:10.1093/bioinformatics/btaa614</a>.<br /><br /> Smith MR (2022).
&ldquo;Robust analysis of phylogenetic tree space.&rdquo;
<em>Systematic Biology</em>, <b>71</b>(5), 1255&ndash;1270.
<a href="https://doi.org/10.1093/sysbio/syab100">doi:10.1093/sysbio/syab100</a>.<br /><br /> Steel MA, Penny D (1993).
&ldquo;Distributions of tree comparison metrics&mdash;some new results.&rdquo;
<em>Systematic Biology</em>, <b>42</b>(2), 126&ndash;141.
<a href="https://doi.org/10.1093/sysbio/42.2.126">doi:10.1093/sysbio/42.2.126</a>.
</p>


<h3>See Also</h3>

<p><a href="https://CRAN.R-project.org/package=treespace/vignettes/introduction.html"><code>treespace::treeDist</code></a>
is a more sophisticated, if more cumbersome, implementation that supports
lambda &gt; 0, i.e. use of edge lengths in tree comparison.
</p>
<p>Other tree distances: 
<code><a href="#topic+JaccardRobinsonFoulds">JaccardRobinsonFoulds</a>()</code>,
<code><a href="#topic+MASTSize">MASTSize</a>()</code>,
<code><a href="#topic+MatchingSplitDistance">MatchingSplitDistance</a>()</code>,
<code><a href="#topic+NNIDist">NNIDist</a>()</code>,
<code><a href="#topic+NyeSimilarity">NyeSimilarity</a>()</code>,
<code><a href="#topic+PathDist">PathDist</a>()</code>,
<code><a href="#topic+Robinson-Foulds">Robinson-Foulds</a></code>,
<code><a href="#topic+SPRDist">SPRDist</a>()</code>,
<code><a href="#topic+TreeDistance">TreeDistance</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>KendallColijn(TreeTools::BalancedTree(8), TreeTools::PectinateTree(8))

set.seed(0)
KendallColijn(TreeTools::BalancedTree(8), lapply(rep(8, 3), ape::rtree))
KendallColijn(lapply(rep(8, 4), ape::rtree))

KendallColijn(lapply(rep(8, 4), ape::rtree), Vector = SplitVector)

# Notice that changing tree shape close to the root results in much
# larger differences
tree1 &lt;- ape::read.tree(text = "(a, (b, (c, (d, (e, (f, (g, h)))))));")
tree2 &lt;- ape::read.tree(text = "(a, ((b, c), (d, (e, (f, (g, h))))));")
tree3 &lt;- ape::read.tree(text = "(a, (b, (c, (d, (e, ((f, g), h))))));")
trees &lt;- c(tree1, tree2, tree3)
KendallColijn(trees)
KendallColijn(trees, Vector = SplitVector)
KCDiameter(trees)
KCDiameter(4)
</code></pre>

<hr>
<h2 id='KMeansPP'>k-means++ clustering</h2><span id='topic+KMeansPP'></span>

<h3>Description</h3>

<p>k-means++ clustering (Arthur and Vassilvitskii 2007) improves the speed and
accuracy of standard <code><a href="stats.html#topic+kmeans">kmeans</a></code> clustering
(Hartigan and Wong 1979) by preferring initial cluster centres
that are far from others.
A scalable version of the algorithm has been proposed for larger data sets
(Bahmani et al. 2012), but is not implemented here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KMeansPP(x, k = 2, nstart = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KMeansPP_+3A_x">x</code></td>
<td>
<p>Numeric matrix of data, or an object that can be coerced to such a
matrix (such as a numeric vector or a data frame with all numeric columns).</p>
</td></tr>
<tr><td><code id="KMeansPP_+3A_k">k</code></td>
<td>
<p>Integer specifying the number of clusters, <em>k</em>.</p>
</td></tr>
<tr><td><code id="KMeansPP_+3A_nstart">nstart</code></td>
<td>
<p>Positive integer specifying how many random sets should be
chosen</p>
</td></tr>
<tr><td><code id="KMeansPP_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="stats.html#topic+kmeans">kmeans</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Arthur D, Vassilvitskii S (2007).
&ldquo;K-Means++: The Advantages of Careful Seeding.&rdquo;
In <em>Proceedings of the Eighteenth Annual ACM-SIAM Symposium on Discrete Algorithms</em>,  SODA '07, 1027&ndash;1035.<br /><br /> Bahmani B, Moseley B, Vattani A, Kumar R, Vassilvitskii S (2012).
&ldquo;Scalable K-Means++.&rdquo;
<em>arXiv</em>.
<a href="https://doi.org/10.48550/arXiv.1203.6402">doi:10.48550/arXiv.1203.6402</a>, 1203.6402.<br /><br /> Hartigan JA, Wong MA (1979).
&ldquo;Algorithm AS 136: a <em>K</em>-means clustering algorithm.&rdquo;
<em>Journal of the Royal Statistical Society. Series C (Applied Statistics)</em>, <b>28</b>(1), 100&ndash;108.
<a href="https://doi.org/10.2307/2346830">doi:10.2307/2346830</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+kmeans">kmeans</a></code>
</p>
<p>Other cluster functions: 
<code><a href="#topic+cluster-statistics">cluster-statistics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate random points
set.seed(1)
x &lt;- cbind(c(rnorm(10, -5), rnorm(5, 1), rnorm(10, 6)),
           c(rnorm(5, 0), rnorm(15, 4), rnorm(5, 0)))

# Conventional k-means may perform poorly
klusters &lt;- kmeans(x, cent = 5)
plot(x, col = klusters$cluster, pch = rep(15:19, each = 5))

# Here, k-means++ recovers a better clustering
plusters &lt;- KMeansPP(x, k = 5)
plot(x, col = plusters$cluster, pch = rep(15:19, each = 5))
</code></pre>

<hr>
<h2 id='LAPJV'>Solve linear assignment problem using LAPJV</h2><span id='topic+LAPJV'></span>

<h3>Description</h3>

<p>Use the algorithm of Jonker and Volgenant (1987) to solve the
<a href="http://www.assignmentproblems.com/doc/LSAPIntroduction.pdf">Linear Sum Assignment Problem</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LAPJV(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LAPJV_+3A_x">x</code></td>
<td>
<p>Matrix of costs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Linear Assignment Problem seeks to match each row of a matrix with a
column, such that the cost of the matching is minimized.
</p>
<p>The Jonker &amp; Volgenant approach is a faster alternative to the Hungarian
algorithm (Munkres 1957), which is implemented in
<code>clue::solve_LSAP()</code>.
</p>
<p>Note: the JV algorithm expects integers. In order to apply the function
to a non-integer <em>n</em>, as in the tree distance calculations in this package,
each <em>n</em> is multiplied by the largest available integer before applying
the JV algorithm.  If two values of <em>n</em> exhibit a trivial difference &ndash;
e.g. due to floating point errors &ndash; then this can lead to interminable
run times.  (If numbers of the magnitude of billions differ only in their
last significant digit, then the JV algorithm may undergo billions of
iterations.)  To avoid this, integers over 2^22 that differ by a value of
8 or less are treated as equal.
</p>


<h3>Value</h3>

<p><code>LAPJV()</code> returns a list with two entries: <code>score</code>, the score of the
optimal matching;
and <code>matching</code>, the columns matched to each row of the matrix in turn.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/yongyanghz/LAPJV-algorithm-c/blob/master/LAPJV/lap.cpp">C++ code</a>
by Roy Jonker, MagicLogic Optimization Inc. <a href="mailto:roy_jonker@magiclogic.com">roy_jonker@magiclogic.com</a>,
with contributions from Yong Yang <a href="mailto:yongyanglink@gmail.com">yongyanglink@gmail.com</a>, after
<a href="https://uk.mathworks.com/matlabcentral/profile/authors/69713-yi-cao">Yi Cao</a>
</p>


<h3>References</h3>

<p>Jonker R, Volgenant A (1987).
&ldquo;A shortest augmenting path algorithm for dense and sparse linear assignment problems.&rdquo;
<em>Computing</em>, <b>38</b>, 325&ndash;340.
<a href="https://doi.org/10.1007/BF02278710">doi:10.1007/BF02278710</a>.<br /><br /> Munkres J (1957).
&ldquo;Algorithms for the assignment and transportation problems.&rdquo;
<em>Journal of the Society for Industrial and Applied Mathematics</em>, <b>5</b>(1), 32&ndash;38.
<a href="https://doi.org/10.1137/0105003">doi:10.1137/0105003</a>.
</p>


<h3>See Also</h3>

<p>Implementations of the Hungarian algorithm exist in <span class="pkg">adagio</span>,
<span class="pkg">RcppHungarian</span>, and <span class="pkg">clue</span> and <span class="pkg">lpSolve</span>; for larger matrices,
these are substantially slower. (See discussion at <a href="https://stackoverflow.com/questions/72806265/">Stack Overflow</a>.)
</p>
<p>The JV algorithm is implemented for square matrices in the Bioconductor
package <a href="https://www.bioconductor.org/packages/release/bioc/html/GraphAlignment.html"><code>GraphAlignment::LinearAssignment()</code></a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>problem &lt;- matrix(c(7, 9, 8, 9, 9,
                    2, 8, 5, 7, 9,
                    1, 6, 6, 9, 9,
                    3, 6, 2, 2, 9), 4, 5, byrow = TRUE)

LAPJV(problem)
</code></pre>

<hr>
<h2 id='MappingQuality'>Faithfulness of mapped distances</h2><span id='topic+MappingQuality'></span><span id='topic+ProjectionQuality'></span>

<h3>Description</h3>

<p><code>MappingQuality()</code> calculates the trustworthiness and continuity
of mapped distances (Venna and Kaski 2001; Kaski et al. 2003).
Trustworthiness measures, on a scale from 0&ndash;1,
the degree to which points that are nearby in a mapping are truly close
neighbours; continuity, the extent to which points that are truly nearby
retain their close spatial proximity in a mapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MappingQuality(original, mapped, neighbours = 10L)

ProjectionQuality(original, mapped, neighbours = 10L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MappingQuality_+3A_original">original</code>, <code id="MappingQuality_+3A_mapped">mapped</code></td>
<td>
<p>Square matrix or <code>dist</code> object containing
original / mapped pairwise distances.</p>
</td></tr>
<tr><td><code id="MappingQuality_+3A_neighbours">neighbours</code></td>
<td>
<p>Integer specifying number of nearest neighbours to use in
calculation.  This should typically be small relative to the number of
points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>MappingQuality()</code> returns a named vector of length four,
containing the entries: <code>Trustworthiness</code>, <code>Continuity</code>, <code>TxC</code>
(the product of these values), and <code>sqrtTxC</code> (its square root).
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Kaski S, Nikkila J, Oja M, Venna J, Toronen P, Castren E (2003).
&ldquo;Trustworthiness and metrics in visualizing similarity of gene expression.&rdquo;
<em>BMC Bioinformatics</em>, <b>4</b>, 48.
<a href="https://doi.org/10.1186/1471-2105-4-48">doi:10.1186/1471-2105-4-48</a>.<br /><br /> Venna J, Kaski S (2001).
&ldquo;Neighborhood preservation in nonlinear projection methods: an experimental study.&rdquo;
In Dorffner G, Bischof H, Hornik K (eds.), <em>Artificial Neural Networks &mdash; ICANN 2001</em>,  Lecture Notes in Computer Science, 485&ndash;491.
<a href="https://doi.org/10.1007/3-540-44668-0_68">doi:10.1007/3-540-44668-0_68</a>.
</p>


<h3>See Also</h3>

<p>Other tree space functions: 
<code><a href="#topic+MSTSegments">MSTSegments</a>()</code>,
<code><a href="#topic+MapTrees">MapTrees</a>()</code>,
<code><a href="#topic+SpectralEigens">SpectralEigens</a>()</code>,
<code><a href="#topic+cluster-statistics">cluster-statistics</a></code>,
<code><a href="#topic+median.multiPhylo">median.multiPhylo</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("TreeTools", quietly = TRUE)
trees &lt;- as.phylo(0:10, nTip = 8)
distances &lt;- ClusteringInfoDistance(trees)
mapping &lt;- cmdscale(distances)
MappingQuality(distances, dist(mapping), 4)
</code></pre>

<hr>
<h2 id='MapTrees'>Graphical user interface for mapping distances and analysing
tree space</h2><span id='topic+MapTrees'></span><span id='topic+Project'></span>

<h3>Description</h3>

<p><code>MapTrees()</code> launches a &quot;Shiny&quot; application for the visualization and
evaluation of tree spaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MapTrees()

Project()
</code></pre>


<h3>Input tab</h3>

<p>The input tab allows for the upload of sets of phylogenetic trees from file.
Trees at the start or end of a file can be excluded, and the number of trees
can be brought down to a manageable number by uniformly subsampling every
_n_th tree.  Samples of c. 100 trees can be analysed in seconds;
analysis of larger samples will take longer, particularly with slower
methods (e.g. quartet distances; Kruskal-1 MDS; large minimum spanning trees).
</p>
<p>Different batches can be plotted with different colours / symbols.
</p>
<p>If each tree is associated with a property &ndash; for example, the data or method
used to generate it, or its stratigraphic congruence &ndash; a list of properties
for each tree, with one entry per line/row, can be uploaded along with
the trees.  Points in tree space can then be styled according to the
corresponding property.
</p>
<p>If trees are subsampled (using the &quot;Sample every&quot; slider), then the values
in the tree properties file can also be subsampled accordingly.
Unfortunately there is not yet support for multiple point property files;
one file will be applied to all trees, in the sequence that they were added
to memory.
</p>


<h3>Analysis tab</h3>

<p>Select from a suite of distance methods: clustering information and
phylogenetic information are quick and satisfactory; quartet is slow but
gives slightly better mappings; path is very fast but may not reflect
evolutionary signal very well; and Robinson&ndash;Foulds should probably never
be used for analysis; it is included for comparison purposes.
</p>
<p>Principle components mappings should suffice for most purposes;
Sammon and Kruskal mappings are slower and seldom differ by much,
in character or quality, but may emphasize outliers more.
</p>
<p>Partitioning around medoids or minimax-linkage hierarchical clustering
will typically find a close-to-optimal clustering where one exists;
select additional methods for a more exhaustive search.
To avoid redundant calculation, clusterings are only updated when
&quot;recalculate clustering&quot; is clicked, or the &quot;maximum cluster number&quot; slider
is modified; clustering solutions using more than this many clusters are
not considered
Clusterings with silhouette coefficients &lt; 0.25 are unlikely to represent
genuine structure and are not reported or depicted.
</p>


<h3>Display tab</h3>

<p>Up to 15 dimensions can be depicted; the quality of a mapping &ndash; that is,
the faithfulness of mapped distances to true tree-to-tree distances &ndash;
is quantified by the product of the Trustworthiness and Continuity metrics,
which should exceed 0.9 (at least).
</p>
<p>An interactive 3D plot can be explored by dragging the mouse and scrolling,
but do be careful to check that three dimensions are enough to depict your
data accurately.
</p>
<p>The minimum spanning tree is the shortest possible line selecting the chosen
subsample of trees; if it takes a convoluted zig-zagging route, then the
mapping is doing a poor job of reflecting true tree to tree distances.
</p>
<p>Convex hulls are the smallest polygons enclosing all points in each cluster;
they are handy for spotting clusters, but their area does not correspond
to a genuine quantity, so should not be interpreted.
</p>
<p>Tree numbers correspond to the sequence of trees in their original input
file, before subsampling.
</p>
<p>Each tree is denoted by a point, whose symbol can be styled according to
cluster membership or according to the file that contains the tree,
with each click of &quot;Add to existing&quot; on the input tab constituting a
new batch with a new symbol.
</p>
<p>Points can be coloured according to a category &ndash; the cluster or batch to
which they belong, or custom data provided in the Point Property File
on the input tab &ndash; or continuously, either by the sequence in which they
were added to memory, or according to custom data.
</p>


<h3>Exporting tree spaces</h3>

<p>A mapping can be saved to PDF or as a PNG bitmap at the size selected.
</p>


<h3>References</h3>

<p>A list of references employed when constructing the tree space is populated
according to the methods used; it would be appropriate to cite and briefly
discuss these studies in any publication using figures generated using
this application.  The application itself can be cited using
Smith (2020, 2022)
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Smith MR (2020).
&ldquo;Information theoretic Generalized Robinson-Foulds metrics for comparing phylogenetic trees.&rdquo;
<em>Bioinformatics</em>, <b>36</b>(20), 5007&ndash;5013.
<a href="https://doi.org/10.1093/bioinformatics/btaa614">doi:10.1093/bioinformatics/btaa614</a>.<br /><br /> Smith MR (2022).
&ldquo;Robust analysis of phylogenetic tree space.&rdquo;
<em>Systematic Biology</em>, <b>71</b>(5), 1255&ndash;1270.
<a href="https://doi.org/10.1093/sysbio/syab100">doi:10.1093/sysbio/syab100</a>.
</p>


<h3>See Also</h3>

<p>Full detail of tree space analysis in R is provided in the accompanying
<a href="https://ms609.github.io/TreeDist/articles/treespace.html">vignette</a>.
</p>
<p>Other tree space functions: 
<code><a href="#topic+MSTSegments">MSTSegments</a>()</code>,
<code><a href="#topic+MappingQuality">MappingQuality</a>()</code>,
<code><a href="#topic+SpectralEigens">SpectralEigens</a>()</code>,
<code><a href="#topic+cluster-statistics">cluster-statistics</a></code>,
<code><a href="#topic+median.multiPhylo">median.multiPhylo</a>()</code>
</p>

<hr>
<h2 id='MASTSize'>Maximum Agreement Subtree size</h2><span id='topic+MASTSize'></span><span id='topic+MASTInfo'></span>

<h3>Description</h3>

<p>Calculate the size or phylogenetic information content
(Steel and Penny 2006)
of the maximum agreement subtree between two phylogenetic trees, i.e.
the largest tree that can be obtained from both <code>tree1</code> and <code>tree2</code> by
deleting, but not rearranging, leaves, using the algorithm of
Valiente (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MASTSize(tree1, tree2 = tree1, rooted = TRUE)

MASTInfo(tree1, tree2 = tree1, rooted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MASTSize_+3A_tree1">tree1</code>, <code id="MASTSize_+3A_tree2">tree2</code></td>
<td>
<p>Trees of class <code>phylo</code>, or lists of such trees to undergo
pairwise comparison.</p>
</td></tr>
<tr><td><code id="MASTSize_+3A_rooted">rooted</code></td>
<td>
<p>Logical specifying whether to treat the trees as rooted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implemented for trees with up to 4096 tips.  Contact the maintainer if you
need to process larger trees.
</p>


<h3>Value</h3>

<p><code>MASTSize()</code> returns an integer specifying the number of leaves in
the maximum agreement subtree.
</p>
<p><code>MASTInfo()</code> returns a vector or matrix listing the phylogenetic
information content, in bits, of the maximum agreement subtree.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Steel MA, Penny D (2006).
&ldquo;Maximum parsimony and the phylogenetic information in multistate characters.&rdquo;
In Albert VA (ed.), <em>Parsimony, Phylogeny, and Genomics</em>, 163&ndash;178.
Oxford University Press, Oxford.<br /><br /> Valiente G (2009).
<em>Combinatorial Pattern Matching Algorithms in Computational Biology using Perl and R</em>,  CRC Mathematical and Computing Biology Series.
CRC Press, Boca Raton.
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+mast">phangorn::mast()</a></code>, a slower implementation that also lists the
leaves contained within the subtree.
</p>
<p>Other tree distances: 
<code><a href="#topic+JaccardRobinsonFoulds">JaccardRobinsonFoulds</a>()</code>,
<code><a href="#topic+KendallColijn">KendallColijn</a>()</code>,
<code><a href="#topic+MatchingSplitDistance">MatchingSplitDistance</a>()</code>,
<code><a href="#topic+NNIDist">NNIDist</a>()</code>,
<code><a href="#topic+NyeSimilarity">NyeSimilarity</a>()</code>,
<code><a href="#topic+PathDist">PathDist</a>()</code>,
<code><a href="#topic+Robinson-Foulds">Robinson-Foulds</a></code>,
<code><a href="#topic+SPRDist">SPRDist</a>()</code>,
<code><a href="#topic+TreeDistance">TreeDistance</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # for as.phylo, BalancedTree, PectinateTree:
library("TreeTools", quietly = TRUE)

MASTSize(PectinateTree(8), BalancedTree(8))
MASTInfo(PectinateTree(8), BalancedTree(8))

MASTSize(BalancedTree(7), as.phylo(0:3, 7))
MASTSize(as.phylo(0:3, 7), PectinateTree(7))

MASTInfo(BalancedTree(7), as.phylo(0:3, 7))
MASTInfo(as.phylo(0:3, 7), PectinateTree(7))

MASTSize(list(Bal = BalancedTree(7), Pec = PectinateTree(7)),
         as.phylo(0:3, 7))
MASTInfo(list(Bal = BalancedTree(7), Pec = PectinateTree(7)),
         as.phylo(0:3, 7))

CompareAll(as.phylo(0:4, 8), MASTSize)
CompareAll(as.phylo(0:4, 8), MASTInfo)
</code></pre>

<hr>
<h2 id='MatchingSplitDistance'>Matching Split Distance</h2><span id='topic+MatchingSplitDistance'></span><span id='topic+MatchingSplitDistanceSplits'></span>

<h3>Description</h3>

<p>Calculate the
<a href="https://ms609.github.io/TreeDist/articles/Generalized-RF.html#matching-split-distance">Matching Split Distance</a>
(Bogdanowicz and Giaro 2012; Lin et al. 2012) for unrooted binary trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatchingSplitDistance(
  tree1,
  tree2 = NULL,
  normalize = FALSE,
  reportMatching = FALSE
)

MatchingSplitDistanceSplits(
  splits1,
  splits2,
  nTip = attr(splits1, "nTip"),
  normalize = TRUE,
  reportMatching = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MatchingSplitDistance_+3A_tree1">tree1</code>, <code id="MatchingSplitDistance_+3A_tree2">tree2</code></td>
<td>
<p>Trees of class <code>phylo</code>, with leaves labelled identically,
or lists of such trees to undergo pairwise comparison.  Where implemented,
<code>tree2 = NULL</code> will compute distances between each pair of trees in the list
<code>tree1</code> using a fast algorithm based on Day (1985).</p>
</td></tr>
<tr><td><code id="MatchingSplitDistance_+3A_normalize">normalize</code></td>
<td>
<p>If a numeric value is provided, this will be used as a
maximum value against which to rescale results.
If <code>TRUE</code>, results will be rescaled against a maximum value calculated from
the specified tree sizes and topology, as specified in the &quot;Normalization&quot;
section below.
If <code>FALSE</code>, results will not be rescaled.</p>
</td></tr>
<tr><td><code id="MatchingSplitDistance_+3A_reportmatching">reportMatching</code></td>
<td>
<p>Logical specifying whether to return the clade
matchings as an attribute of the score.</p>
</td></tr>
<tr><td><code id="MatchingSplitDistance_+3A_splits1">splits1</code>, <code id="MatchingSplitDistance_+3A_splits2">splits2</code></td>
<td>
<p>Logical matrices where each row corresponds to a leaf,
either listed in the same order or bearing identical names (in any sequence),
and each column corresponds to a split, such that each leaf is identified as
a member of the ingroup (<code>TRUE</code>) or outgroup (<code>FALSE</code>) of the respective
split.</p>
</td></tr>
<tr><td><code id="MatchingSplitDistance_+3A_ntip">nTip</code></td>
<td>
<p>(Optional) Integer specifying the number of leaves in each split.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Trees need not contain identical leaves; scores are based on the leaves that
trees hold in common.  Check for unexpected differences in tip labelling
with <code>setdiff(TipLabels(tree1), TipLabels(tree2))</code>.
</p>


<h3>Value</h3>

<p><code>MatchingSplitDistance()</code> returns an array of numerics providing the
distances between each  pair of trees in <code>tree1</code> and <code>tree2</code>,
or <code>splits1</code> and <code>splits2</code>.
</p>


<h3>Normalization</h3>

<p>A normalization value or function must be provided in order to return a
normalized value.  If you are aware of a generalised formula, please
let me know by
<a href="https://github.com/ms609/TreeDist/issues/new">creating a GitHub issue</a>
so that it can be implemented.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Bogdanowicz D, Giaro K (2012).
&ldquo;Matching split distance for unrooted binary phylogenetic trees.&rdquo;
<em>IEEE/ACM Transactions on Computational Biology and Bioinformatics</em>, <b>9</b>(1), 150&ndash;160.
<a href="https://doi.org/10.1109/TCBB.2011.48">doi:10.1109/TCBB.2011.48</a>.<br /><br /> Lin Y, Rajan V, Moret BME (2012).
&ldquo;A metric for phylogenetic trees based on matching.&rdquo;
<em>IEEE/ACM Transactions on Computational Biology and Bioinformatics</em>, <b>4</b>(9), 1014&ndash;1022.
<a href="https://doi.org/10.1109/TCBB.2011.157">doi:10.1109/TCBB.2011.157</a>.
</p>


<h3>See Also</h3>

<p>Other tree distances: 
<code><a href="#topic+JaccardRobinsonFoulds">JaccardRobinsonFoulds</a>()</code>,
<code><a href="#topic+KendallColijn">KendallColijn</a>()</code>,
<code><a href="#topic+MASTSize">MASTSize</a>()</code>,
<code><a href="#topic+NNIDist">NNIDist</a>()</code>,
<code><a href="#topic+NyeSimilarity">NyeSimilarity</a>()</code>,
<code><a href="#topic+PathDist">PathDist</a>()</code>,
<code><a href="#topic+Robinson-Foulds">Robinson-Foulds</a></code>,
<code><a href="#topic+SPRDist">SPRDist</a>()</code>,
<code><a href="#topic+TreeDistance">TreeDistance</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MatchingSplitDistance(lapply(rep(8, 5), ape::rtree), normalize = 16)

MatchingSplitDistance(TreeTools::BalancedTree(6),
                      TreeTools::PectinateTree(6),
                      reportMatching = TRUE)

VisualizeMatching(MatchingSplitDistance, TreeTools::BalancedTree(6),
                  TreeTools::PectinateTree(6))
</code></pre>

<hr>
<h2 id='median.multiPhylo'>Median of a set of trees</h2><span id='topic+median.multiPhylo'></span>

<h3>Description</h3>

<p>Calculate the single binary tree that represents the geometric median &ndash;
an &quot;average&quot; &ndash; of a forest of tree topologies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiPhylo'
median(
  x,
  na.rm = FALSE,
  Distance = ClusteringInfoDistance,
  index = FALSE,
  breakTies = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="median.multiPhylo_+3A_x">x</code></td>
<td>
<p>Object of class <code>multiPhylo</code> containing phylogenetic trees.</p>
</td></tr>
<tr><td><code id="median.multiPhylo_+3A_na.rm">na.rm</code>, <code id="median.multiPhylo_+3A_...">...</code></td>
<td>
<p>Unused; included for consistency with default function..</p>
</td></tr>
<tr><td><code id="median.multiPhylo_+3A_distance">Distance</code></td>
<td>
<p>Function to calculate distances between each pair
of trees in <code>x</code>.</p>
</td></tr>
<tr><td><code id="median.multiPhylo_+3A_index">index</code></td>
<td>
<p>Logical: if <code>TRUE</code>, return the index of the median tree(s);
if <code>FALSE</code>, return the tree itself.</p>
</td></tr>
<tr><td><code id="median.multiPhylo_+3A_breakties">breakTies</code></td>
<td>
<p>Logical: if <code>TRUE</code>, return a single tree with the minimum
score; if <code>FALSE</code>, return all tied trees.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The geometric median is the tree that exhibits the shortest average distance
from each other tree topology in the set.
It represents an &quot;average&quot; of a set of trees, though note that an unsampled
tree may be closer to the geometric &quot;centre of gravity&quot; of the input set &ndash;
such a tree would not be considered.
</p>
<p>The result will depend on the metric chosen to calculate distances between
tree topologies. In the absence of a natural metric of tree topologies,
the default choice is <code><a href="#topic+ClusteringInfoDistance">ClusteringInfoDistance()</a></code> &ndash; which discards
branch length information.
If specifying a different function, be sure that it returns a difference,
rather than a similarity.
</p>


<h3>Value</h3>

<p><code>median()</code> returns an object of class <code>phylo</code>
corresponding to the geometric median of a set of trees:
that is, the tree whose average distance from all other trees in the set
is lowest.
If multiple trees tie in their average distance, the first will be returned,
unless <code>breakTies = FALSE</code>, in which case an object of class <code>multiPhylo</code>
containing all such trees will be returned.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Consensus methods:
<code><a href="ape.html#topic+consensus">ape::consensus()</a></code>,
<code><a href="TreeTools.html#topic+ConsensusWithout">TreeTools::ConsensusWithout()</a></code>
</p>
<p>Other tree space functions: 
<code><a href="#topic+MSTSegments">MSTSegments</a>()</code>,
<code><a href="#topic+MapTrees">MapTrees</a>()</code>,
<code><a href="#topic+MappingQuality">MappingQuality</a>()</code>,
<code><a href="#topic+SpectralEigens">SpectralEigens</a>()</code>,
<code><a href="#topic+cluster-statistics">cluster-statistics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("TreeTools", quietly = TRUE)
tenTrees &lt;- as.phylo(1:10, nTip = 8)

# Default settings:
median(tenTrees)

# Robinson-Foulds distances include ties:
median(tenTrees, Distance = RobinsonFoulds, breakTies = FALSE)

# Be sure to use a distance function, rather than a similarity:
NyeDistance &lt;- function(...) NyeSimilarity(..., similarity = FALSE)
median(tenTrees, Distance = NyeDistance)

# To analyse a list of trees that is not of class multiPhylo:
treeList &lt;- lapply(1:10, as.phylo, nTip = 8)
class(treeList)
median(structure(treeList, class = "multiPhylo"))
</code></pre>

<hr>
<h2 id='MeilaVariationOfInformation'>Use variation of clustering information to compare pairs of splits</h2><span id='topic+MeilaVariationOfInformation'></span><span id='topic+MeilaMutualInformation'></span>

<h3>Description</h3>

<p>Compare a pair of splits viewed as clusterings of taxa, using the variation
of clustering information proposed by (Meila 2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MeilaVariationOfInformation(split1, split2)

MeilaMutualInformation(split1, split2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MeilaVariationOfInformation_+3A_split1">split1</code>, <code id="MeilaVariationOfInformation_+3A_split2">split2</code></td>
<td>
<p>Logical vectors listing leaves in a consistent order,
identifying each leaf as a member of the ingroup (<code>TRUE</code>) or outgroup
(<code>FALSE</code>) of the split in question.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is equivalent to the mutual clustering information
(Vinh et al. 2010).
For the total information content, multiply the VoI by the number of leaves.
</p>


<h3>Value</h3>

<p><code>MeilaVariationOfInformation()</code> returns the variation of (clustering)
information, measured in bits.
</p>
<p><code>MeilaMutualInformation()</code> returns the mutual information,
measured in bits.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Meila M (2007).
&ldquo;Comparing clusterings&mdash;an information based distance.&rdquo;
<em>Journal of Multivariate Analysis</em>, <b>98</b>(5), 873&ndash;895.
<a href="https://doi.org/10.1016/j.jmva.2006.11.013">doi:10.1016/j.jmva.2006.11.013</a>.<br /><br /> Vinh NX, Epps J, Bailey J (2010).
&ldquo;Information theoretic measures for clusterings comparison: variants, properties, normalization and correction for chance.&rdquo;
<em>Journal of Machine Learning Research</em>, <b>11</b>, 2837&ndash;2854.
<a href="https://doi.org/10.1145/1553374.1553511">doi:10.1145/1553374.1553511</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Maximum variation = information content of each split separately
A &lt;- TRUE
B &lt;- FALSE
MeilaVariationOfInformation(c(A, A, A, B, B, B), c(A, A, A, A, A, A))
Entropy(c(3, 3) / 6) + Entropy(c(0, 6) / 6)

# Minimum variation = 0
MeilaVariationOfInformation(c(A, A, A, B, B, B), c(A, A, A, B, B, B))

# Not always possible for two evenly-sized splits to reach maximum
# variation of information
Entropy(c(3, 3) / 6) * 2  # = 2
MeilaVariationOfInformation(c(A, A, A,B ,B, B), c(A, B, A, B, A, B)) # &lt; 2

# Phylogenetically uninformative groupings contain spliting information
Entropy(c(1, 5) / 6)
MeilaVariationOfInformation(c(B, A, A, A, A, A), c(A, A, A, A, A, B))
</code></pre>

<hr>
<h2 id='MSTSegments'>Add minimum spanning tree to plot, colouring by stress</h2><span id='topic+MSTSegments'></span><span id='topic+StrainCol'></span>

<h3>Description</h3>

<p>To identify strain in a multidimensional scaling of distances, it can be
useful to plot a minimum spanning tree
(Gower 1966; Smith 2022).  Colouring each edge of the
tree according to its strain can identify areas where the mapping is
stretched or compressed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSTSegments(mapping, mstEnds, ...)

StrainCol(
  distances,
  mapping,
  mstEnds = MSTEdges(distances),
  palette = rev(hcl.colors(256L, "RdYlBu"))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MSTSegments_+3A_mapping">mapping</code></td>
<td>
<p>Two-column matrix giving <em>x</em> and <em>y</em> coordinates of plotted
points.</p>
</td></tr>
<tr><td><code id="MSTSegments_+3A_mstends">mstEnds</code></td>
<td>
<p>Two-column matrix identifying rows of <code>mapping</code> at end of
each edge of the MST, as output by <code><a href="TreeTools.html#topic+MSTEdges">TreeTools::MSTEdges()</a></code>.</p>
</td></tr>
<tr><td><code id="MSTSegments_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="graphics.html#topic+segments">segments()</a></code>.</p>
</td></tr>
<tr><td><code id="MSTSegments_+3A_distances">distances</code></td>
<td>
<p>Matrix or <code>dist</code> object giving original distances between
each pair of points.</p>
</td></tr>
<tr><td><code id="MSTSegments_+3A_palette">palette</code></td>
<td>
<p>Vector of colours with which to colour edges.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>StrainCol()</code> returns a vector in which each entry is selected from
<code>palette</code>, with an attribute <code>logStrain</code> denoting the logarithm of the
mapped over original distance, shifted such that the median value is zero.
Palette colours are assigned centred on the median value, with entries
early in <code>palette</code> assigned to edges in which the ratio of mapped
distance to original distance is small.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Gower JC (1966).
&ldquo;Some distance properties of latent root and vector methods used in multivariate analysis.&rdquo;
<em>Biometrika</em>, <b>53</b>(3/4), 325&ndash;338.
<a href="https://doi.org/10.2307/2333639">doi:10.2307/2333639</a>.<br /><br /> Smith MR (2022).
&ldquo;Robust analysis of phylogenetic tree space.&rdquo;
<em>Systematic Biology</em>, <b>71</b>(5), 1255&ndash;1270.
<a href="https://doi.org/10.1093/sysbio/syab100">doi:10.1093/sysbio/syab100</a>.
</p>


<h3>See Also</h3>

<p>Other tree space functions: 
<code><a href="#topic+MapTrees">MapTrees</a>()</code>,
<code><a href="#topic+MappingQuality">MappingQuality</a>()</code>,
<code><a href="#topic+SpectralEigens">SpectralEigens</a>()</code>,
<code><a href="#topic+cluster-statistics">cluster-statistics</a></code>,
<code><a href="#topic+median.multiPhylo">median.multiPhylo</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
library("TreeTools", quietly = TRUE)
distances &lt;- ClusteringInfoDist(as.phylo(5:16, 8))
mapping &lt;- cmdscale(distances, k = 2)
mstEnds &lt;- MSTEdges(distances)

# Set up blank plot
plot(mapping, asp = 1, frame.plot = FALSE, ann = FALSE, axes = FALSE,
     type = "n")
# Add MST
MSTSegments(mapping, mstEnds, 
            col = StrainCol(distances, mapping, mstEnds))
# Add points at end so they overprint the MST
points(mapping)
PlotTools::SpectrumLegend(
 "bottomleft",
 legend = c("Extended", "Median", "Contracted"),
 bty = "n",     # No box
 y.intersp = 2, # Expand in Y direction
 palette = hcl.colors(256L, "RdYlBu", rev = TRUE)
)
</code></pre>

<hr>
<h2 id='NNIDist'>Approximate Nearest Neighbour Interchange distance</h2><span id='topic+NNIDist'></span><span id='topic+NNIDiameter'></span>

<h3>Description</h3>

<p>Use the approach of Li et al. (1996) to approximate the
Nearest Neighbour Interchange distance (Robinson 1971)
between phylogenetic trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNIDist(tree1, tree2 = tree1)

NNIDiameter(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNIDist_+3A_tree1">tree1</code>, <code id="NNIDist_+3A_tree2">tree2</code></td>
<td>
<p>Single trees of class <code>phylo</code> to undergo comparison.</p>
</td></tr>
<tr><td><code id="NNIDist_+3A_tree">tree</code></td>
<td>
<p>Object of supported class representing a tree or list of trees,
or an integer specifying the number of leaves in a tree/trees.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In brief, this approximation algorithm works by identifying edges in one
tree that do not match edges in the second.  Each of these edges must
undergo at least one NNI operation in order to reconcile the trees.
Edges that match in both trees need never undergo an NNI operation, and
divide each tree into smaller regions.  By &quot;cutting&quot; matched edges into two,
a tree can be divided into a number of regions that solely comprise unmatched
edges.
</p>
<p>These regions can be viewed as separate trees that need to be reconciled.
One way to reconcile these trees is to conduct a series of NNI operations
that reduce a tree to a pectinate (caterpillar) tree, then to conduct an
analogue of the mergesort algorithm.  This takes at most <em>n</em> log <em>n</em> + O(<em>n</em>)
NNI operations, and provides a loose upper bound on the NNI score.
The maximum number of moves for an <em>n</em>-leaf tree
(<a href="https://oeis.org/A182136">OEIS A182136</a>) can be calculated exactly for
small trees (Fack et al. 2002); this provides a tighter upper
bound, but is unavailable for <em>n</em> &gt; 12.
<code>NNIDiameter()</code> reports the limits on this bound.
</p>

<table>
<tr>
 <td style="text-align: right;">
Leaves:   </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 4 </td><td style="text-align: center;"> 5 </td><td style="text-align: center;"> 6 </td><td style="text-align: center;"> 7 </td><td style="text-align: center;"> 8 </td><td style="text-align: center;"> 9
</td><td style="text-align: center;"> 10 </td><td style="text-align: center;"> 11 </td><td style="text-align: center;"> 12 </td><td style="text-align: center;"> 13 </td>
</tr>
<tr>
 <td style="text-align: right;">
Diameter: </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 5 </td><td style="text-align: center;"> 7 </td><td style="text-align: center;"> 10 </td><td style="text-align: center;"> 12
</td><td style="text-align: center;"> 15 </td><td style="text-align: center;"> 18 </td><td style="text-align: center;"> 21 </td><td style="text-align: center;"> ? </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Value</h3>

<p><code>NNIDist()</code> returns, for each pair of trees, a named vector
containing three integers:
</p>

<ul>
<li> <p><code>lower</code> is a lower bound on the NNI distance, and corresponds
to the RF distance between the trees.
</p>
</li>
<li> <p><code>tight_upper</code> is an upper bound on the distance, based on calculated
maximum diameters for trees with &lt; 13 leaves.  <em>NA</em> is returned if trees are
too different to employ this approach.
</p>
</li>
<li> <p><code>loose_upper</code> is a looser upper bound on the distance, using <em>n</em> log <em>n</em> +
O(<em>n</em>).
</p>
</li></ul>

<p><code>NNIDiameter()</code> returns a matrix specifying (bounds on) the diameter
of the NNI distance metric on the specified tree(s).
Columns correspond to:
</p>

<ul>
<li> <p><code>liMin</code>:  </p>
<p style="text-align: center;"><code class="reqn">n - 3</code>
</p>
<p>, a lower bound on the diameter
(Li <em>et al.</em> 1996);
</p>
</li>
<li> <p><code>fackMin</code>: Lower bound on diameter following Fack <em>et al</em>. (2002), i.e.
</p>
<p style="text-align: center;"><code class="reqn">\log2{N!} / 4</code>
</p>
<p>;
</p>
</li>
<li> <p><code>min</code>: The larger of <code>liMin</code> and <code>fackMin</code>;
</p>
</li>
<li> <p><code>exact</code>: The exact value of the diameter, where <em>n</em> &lt; 13;
</p>
</li>
<li> <p><code>liMax</code>: Upper bound on diameter following Li <em>et al.</em> (1996), i.e.
</p>
<p style="text-align: center;"><code class="reqn">n \log2{n} + \textrm{O}(n)</code>
</p>
<p>;
</p>
</li>
<li> <p><code>fackMax</code>: Upper bound on diameter following Fack <em>et al</em>. (2002), i.e.
(</p>
<p style="text-align: center;"><code class="reqn">N - 2</code>
</p>
<p>) ceiling(</p>
<p style="text-align: center;"><code class="reqn">\log2{n}</code>
</p>
<p>)
</p>

<ul>
<li> <p><em>N</em>;
</p>
</li></ul>

</li>
<li> <p><code>max</code>: The smaller of <code>liMax</code> and <code>fackMax</code>;
</p>
</li></ul>

<p>where <em>n</em> is the number of leaves, and <em>N</em> the number of internal nodes,
i.e. </p>
<p style="text-align: center;"><code class="reqn">n - 2</code>
</p>
<p>.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Fack V, Lievens S, Van der Jeugt J (2002).
&ldquo;On the diameter of the rotation graph of binary coupling trees.&rdquo;
<em>Discrete Mathematics</em>, <b>245</b>(1-3), 1&ndash;18.
<a href="https://doi.org/10.1016/S0012-365X%2801%2900418-6">doi:10.1016/S0012-365X(01)00418-6</a>.<br /><br /> Li M, Tromp J, Zhang L (1996).
&ldquo;Some notes on the nearest neighbour interchange distance.&rdquo;
In Goos G, Hartmanis J, Leeuwen J, Cai J, Wong CK (eds.), <em>Computing and Combinatorics</em>, volume 1090, 343&ndash;351.
Springer, Berlin, Heidelberg.
ISBN 978-3-540-61332-9 978-3-540-68461-9, <a href="https://doi.org/10.1007/3-540-61332-3_168">doi:10.1007/3-540-61332-3_168</a>.<br /><br /> Robinson DF (1971).
&ldquo;Comparison of labeled trees with valency three.&rdquo;
<em>Journal of Combinatorial Theory, Series B</em>, <b>11</b>(2), 105&ndash;119.
<a href="https://doi.org/10.1016/0095-8956%2871%2990020-7">doi:10.1016/0095-8956(71)90020-7</a>.
</p>


<h3>See Also</h3>

<p>Other tree distances: 
<code><a href="#topic+JaccardRobinsonFoulds">JaccardRobinsonFoulds</a>()</code>,
<code><a href="#topic+KendallColijn">KendallColijn</a>()</code>,
<code><a href="#topic+MASTSize">MASTSize</a>()</code>,
<code><a href="#topic+MatchingSplitDistance">MatchingSplitDistance</a>()</code>,
<code><a href="#topic+NyeSimilarity">NyeSimilarity</a>()</code>,
<code><a href="#topic+PathDist">PathDist</a>()</code>,
<code><a href="#topic+Robinson-Foulds">Robinson-Foulds</a></code>,
<code><a href="#topic+SPRDist">SPRDist</a>()</code>,
<code><a href="#topic+TreeDistance">TreeDistance</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("TreeTools", quietly = TRUE)

NNIDist(BalancedTree(7), PectinateTree(7))

NNIDist(BalancedTree(7), as.phylo(0:2, 7))
NNIDist(as.phylo(0:2, 7), PectinateTree(7))

NNIDist(list(bal = BalancedTree(7), pec = PectinateTree(7)),
        as.phylo(0:2, 7))

CompareAll(as.phylo(30:33, 8), NNIDist)
</code></pre>

<hr>
<h2 id='NormalizeInfo'>Normalize information against total present in both starting trees</h2><span id='topic+NormalizeInfo'></span>

<h3>Description</h3>

<p>Normalize information against total present in both starting trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NormalizeInfo(
  unnormalized,
  tree1,
  tree2,
  InfoInTree,
  infoInBoth = NULL,
  how = TRUE,
  Combine = "+",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NormalizeInfo_+3A_unnormalized">unnormalized</code></td>
<td>
<p>Numeric value to be normalized.</p>
</td></tr>
<tr><td><code id="NormalizeInfo_+3A_tree1">tree1</code>, <code id="NormalizeInfo_+3A_tree2">tree2</code></td>
<td>
<p>Trees from which <code>unnormalized</code> was calculated</p>
</td></tr>
<tr><td><code id="NormalizeInfo_+3A_infointree">InfoInTree</code></td>
<td>
<p>Function to calculate the information content of each tree</p>
</td></tr>
<tr><td><code id="NormalizeInfo_+3A_infoinboth">infoInBoth</code></td>
<td>
<p>Numeric specifying information content of both trees
independently (optional)</p>
</td></tr>
<tr><td><code id="NormalizeInfo_+3A_how">how</code></td>
<td>
<p>Method for normalization</p>
</td></tr>
<tr><td><code id="NormalizeInfo_+3A_...">...</code></td>
<td>
<p>Additional parameters to <code>InfoInTree()</code> or <code>how</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>

<hr>
<h2 id='NyeSimilarity'>Nye <em>et al</em>. (2006) tree comparison</h2><span id='topic+NyeSimilarity'></span><span id='topic+NyeSplitSimilarity'></span>

<h3>Description</h3>

<p><code>NyeSimilarity()</code> and <code>NyeSplitSimilarity()</code> implement the
<a href="https://ms609.github.io/TreeDist/articles/Robinson-Foulds.html#generalized-robinson-foulds-distances">Generalized Robinson–Foulds</a>
tree comparison metric of Nye et al. (2006).
In short, this finds the optimal matching that pairs each branch from
one tree with a branch in the second, where matchings are scored according to
the size of the largest split that is consistent with both of them,
normalized against the Jaccard index.
A more detailed account is available in the
<a href="https://ms609.github.io/TreeDist/articles/Generalized-RF.html#nye-et-al--tree-similarity-metric">vignettes</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NyeSimilarity(
  tree1,
  tree2 = NULL,
  similarity = TRUE,
  normalize = FALSE,
  normalizeMax = !is.logical(normalize),
  reportMatching = FALSE,
  diag = TRUE
)

NyeSplitSimilarity(
  splits1,
  splits2,
  nTip = attr(splits1, "nTip"),
  reportMatching = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NyeSimilarity_+3A_tree1">tree1</code>, <code id="NyeSimilarity_+3A_tree2">tree2</code></td>
<td>
<p>Trees of class <code>phylo</code>, with leaves labelled identically,
or lists of such trees to undergo pairwise comparison.  Where implemented,
<code>tree2 = NULL</code> will compute distances between each pair of trees in the list
<code>tree1</code> using a fast algorithm based on Day (1985).</p>
</td></tr>
<tr><td><code id="NyeSimilarity_+3A_similarity">similarity</code></td>
<td>
<p>Logical specifying whether to report the result as a tree
similarity, rather than a difference.</p>
</td></tr>
<tr><td><code id="NyeSimilarity_+3A_normalize">normalize</code></td>
<td>
<p>If a numeric value is provided, this will be used as a
maximum value against which to rescale results.
If <code>TRUE</code>, results will be rescaled against a maximum value calculated from
the specified tree sizes and topology, as specified in the &quot;Normalization&quot;
section below.
If <code>FALSE</code>, results will not be rescaled.</p>
</td></tr>
<tr><td><code id="NyeSimilarity_+3A_normalizemax">normalizeMax</code></td>
<td>
<p>When calculating similarity, normalize against the
maximum number of splits that could have been present (<code>TRUE</code>),
or the number of splits that were actually observed (<code>FALSE</code>)?
Defaults to the number of splits in the better-resolved tree; set
<code>normalize = pmin.int</code> to use the number of splits in the less resolved
tree.</p>
</td></tr>
<tr><td><code id="NyeSimilarity_+3A_reportmatching">reportMatching</code></td>
<td>
<p>Logical specifying whether to return the clade
matchings as an attribute of the score.</p>
</td></tr>
<tr><td><code id="NyeSimilarity_+3A_diag">diag</code></td>
<td>
<p>Logical specifying whether to return similarities along the
diagonal, i.e. of each tree with itself.  Applies only if <code>tree2</code> is
a list identical to <code>tree1</code>, or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="NyeSimilarity_+3A_splits1">splits1</code>, <code id="NyeSimilarity_+3A_splits2">splits2</code></td>
<td>
<p>Logical matrices where each row corresponds to a leaf,
either listed in the same order or bearing identical names (in any sequence),
and each column corresponds to a split, such that each leaf is identified as
a member of the ingroup (<code>TRUE</code>) or outgroup (<code>FALSE</code>) of the respective
split.</p>
</td></tr>
<tr><td><code id="NyeSimilarity_+3A_ntip">nTip</code></td>
<td>
<p>(Optional) Integer specifying the number of leaves in each split.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The measure is defined as a similarity score.  If <code>similarity = FALSE</code>, the
similarity score will be converted into a distance by doubling it and
subtracting it from the number of splits present in both trees.
This ensures consistency with <code>JaccardRobinsonFoulds</code>.
</p>
<p>Note that <code>NyeSimilarity(tree1, tree2)</code> is equivalent to, but
slightly faster than, <code><a href="#topic+JaccardRobinsonFoulds">JaccardRobinsonFoulds</a>
(tree1, tree2, k = 1, allowConflict = TRUE)</code>.
</p>


<h3>Value</h3>

<p><code>NyeSimilarity()</code> returns an array of numerics providing the
distances between each  pair of trees in <code>tree1</code> and <code>tree2</code>,
or <code>splits1</code> and <code>splits2</code>.
</p>


<h3>Normalization</h3>

<p>If <code>normalize = TRUE</code> and <code>similarity = TRUE</code>, then results will be rescaled
from zero to one by dividing by the mean number of splits in the two trees
being compared.
</p>
<p>You may wish to normalize instead against the number of splits present
in the smaller tree, which represents the maximum value possible for a pair
of trees with the specified topologies (<code>normalize = pmin.int</code>); the
number of splits in the most resolved tree (<code>normalize = pmax.int</code>);
or the maximum value possible for any pair of trees with  <em>n</em> leaves,
<em>n</em> - 3 (<code>normalize = TreeTools::NTip(tree1) - 3L</code>).
</p>
<p>If <code>normalize = TRUE</code> and <code>similarity = FALSE</code>, then results will be rescaled
from zero to one by dividing by the total number of splits in the pair
of trees being considered.
</p>
<p>Trees need not contain identical leaves; scores are based on the leaves that
trees hold in common.  Check for unexpected differences in tip labelling
with <code>setdiff(TipLabels(tree1), TipLabels(tree2))</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Nye TMW, Liò P, Gilks WR (2006).
&ldquo;A novel algorithm and web-based tool for comparing two alternative phylogenetic trees.&rdquo;
<em>Bioinformatics</em>, <b>22</b>(1), 117&ndash;119.
<a href="https://doi.org/10.1093/bioinformatics/bti720">doi:10.1093/bioinformatics/bti720</a>.
</p>


<h3>See Also</h3>

<p>Other tree distances: 
<code><a href="#topic+JaccardRobinsonFoulds">JaccardRobinsonFoulds</a>()</code>,
<code><a href="#topic+KendallColijn">KendallColijn</a>()</code>,
<code><a href="#topic+MASTSize">MASTSize</a>()</code>,
<code><a href="#topic+MatchingSplitDistance">MatchingSplitDistance</a>()</code>,
<code><a href="#topic+NNIDist">NNIDist</a>()</code>,
<code><a href="#topic+PathDist">PathDist</a>()</code>,
<code><a href="#topic+Robinson-Foulds">Robinson-Foulds</a></code>,
<code><a href="#topic+SPRDist">SPRDist</a>()</code>,
<code><a href="#topic+TreeDistance">TreeDistance</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("TreeTools")
NyeSimilarity(BalancedTree(8), PectinateTree(8))
VisualizeMatching(NyeSimilarity, BalancedTree(8), PectinateTree(8))
NyeSimilarity(as.phylo(0:5, nTip = 8), PectinateTree(8))
NyeSimilarity(as.phylo(0:5, nTip = 8), similarity = FALSE)
</code></pre>

<hr>
<h2 id='PathDist'>Path distance</h2><span id='topic+PathDist'></span>

<h3>Description</h3>

<p>Calculate the path distance between rooted or unrooted trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PathDist(tree1, tree2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PathDist_+3A_tree1">tree1</code>, <code id="PathDist_+3A_tree2">tree2</code></td>
<td>
<p>Trees of class <code>phylo</code>, with leaves labelled identically,
or lists of such trees to undergo pairwise comparison.  Where implemented,
<code>tree2 = NULL</code> will compute distances between each pair of trees in the list
<code>tree1</code> using a fast algorithm based on Day (1985).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for the function
<code><a href="phangorn.html#topic+treedist">path.dist()</a></code> in the phangorn package.
It pre-processes trees to ensure that their internal representation does
not cause the <code>path.dist()</code> function to crash R.
</p>
<p>The path distance is calculated by tabulating the cladistic difference (=
topological distance) between each pair of tips in each tree.
A precursor to the path distance (Farris 1969)
took the mean squared
difference between the elements of each tree's tabulation (Farris, 1973);
the method used here is that proposed by
Steel and Penny (1993), which takes the square root of this
sum.
Other precursor measures are described in
Williams and Clifford (1971) and
Phipps (1971).
</p>
<p>If a root node is present, trees are treated as rooted.
To avoid counting the root edge twice, use <code>UnrootTree(tree)</code> before
calculating the path distance.
</p>
<p>Use of the path distance is discouraged as it emphasizes
shallow relationships at the expense of deeper (and arguably more
fundamental) relationships (Farris 1973).
</p>


<h3>Value</h3>

<p><code>PathDist()</code> returns a vector or distance matrix of distances
between trees.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Farris JS (1969).
&ldquo;A successive approximations approach to character weighting.&rdquo;
<em>Systematic Biology</em>, <b>18</b>(4), 374&ndash;385.
<a href="https://doi.org/10.2307/2412182">doi:10.2307/2412182</a>.<br /><br /> Farris JS (1973).
&ldquo;On comparing the shapes of taxonomic trees.&rdquo;
<em>Systematic Zoology</em>, <b>22</b>(1), 50&ndash;54.
<a href="https://doi.org/10.2307/2412378">doi:10.2307/2412378</a>.<br /><br /> Phipps JB (1971).
&ldquo;Dendrogram topology.&rdquo;
<em>Systematic Zoology</em>, <b>20</b>(3), 306.
<a href="https://doi.org/10.2307/2412343">doi:10.2307/2412343</a>.<br /><br /> Steel MA, Penny D (1993).
&ldquo;Distributions of tree comparison metrics&mdash;some new results.&rdquo;
<em>Systematic Biology</em>, <b>42</b>(2), 126&ndash;141.
<a href="https://doi.org/10.1093/sysbio/42.2.126">doi:10.1093/sysbio/42.2.126</a>.<br /><br /> Williams WT, Clifford HT (1971).
&ldquo;On the comparison of two classifications of the same set of elements.&rdquo;
<em>Taxon</em>, <b>20</b>(4), 519&ndash;522.
<a href="https://doi.org/10.2307/1218253">doi:10.2307/1218253</a>.
</p>


<h3>See Also</h3>

<p>Other tree distances: 
<code><a href="#topic+JaccardRobinsonFoulds">JaccardRobinsonFoulds</a>()</code>,
<code><a href="#topic+KendallColijn">KendallColijn</a>()</code>,
<code><a href="#topic+MASTSize">MASTSize</a>()</code>,
<code><a href="#topic+MatchingSplitDistance">MatchingSplitDistance</a>()</code>,
<code><a href="#topic+NNIDist">NNIDist</a>()</code>,
<code><a href="#topic+NyeSimilarity">NyeSimilarity</a>()</code>,
<code><a href="#topic+Robinson-Foulds">Robinson-Foulds</a></code>,
<code><a href="#topic+SPRDist">SPRDist</a>()</code>,
<code><a href="#topic+TreeDistance">TreeDistance</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("TreeTools")

# Treating the two edges to the root node as distinct
PathDist(BalancedTree(7), PectinateTree(7))

# Counting those two edges once
PathDist(UnrootTree(BalancedTree(7)), UnrootTree(PectinateTree(7)))

PathDist(BalancedTree(7), as.phylo(0:2, 7))
PathDist(as.phylo(0:2, 7), PectinateTree(7))

PathDist(list(bal = BalancedTree(7), pec = PectinateTree(7)),
        as.phylo(0:2, 7))

CompareAll(as.phylo(30:33, 8), PathDist)
 
</code></pre>

<hr>
<h2 id='Plot3'>Pseudo-3D plotting</h2><span id='topic+Plot3'></span>

<h3>Description</h3>

<p><code>Plot3()</code> displays three-dimensional data in two dimensions, reflecting the
third dimension with point scaling, overlap and fogging.
Points with a lower <code>z</code> value are smaller than, fainter than, and overlapped
by points with a higher value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot3(
  x,
  y = NULL,
  z = NULL,
  pch = par("pch"),
  col = par("col"),
  bg = NA,
  cex = 1,
  axes = TRUE,
  frame.plot = axes,
  plot.bg = NA,
  fog = 1/2,
  shrink = 1/2,
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Plot3_+3A_x">x</code>, <code id="Plot3_+3A_y">y</code>, <code id="Plot3_+3A_z">z</code></td>
<td>
<p>Coordinates of points to plot.</p>
</td></tr>
<tr><td><code id="Plot3_+3A_bg">bg</code>, <code id="Plot3_+3A_cex">cex</code>, <code id="Plot3_+3A_col">col</code>, <code id="Plot3_+3A_pch">pch</code>, <code id="Plot3_+3A_add">add</code>, <code id="Plot3_+3A_axes">axes</code>, <code id="Plot3_+3A_frame.plot">frame.plot</code>, <code id="Plot3_+3A_...">...</code></td>
<td>
<p>Parameters passed to
<code><a href="graphics.html#topic+plot.default">plot.default()</a></code>.</p>
</td></tr>
<tr><td><code id="Plot3_+3A_plot.bg">plot.bg</code></td>
<td>
<p>Colour with which to fill plot area, used as fog colour.</p>
</td></tr>
<tr><td><code id="Plot3_+3A_fog">fog</code></td>
<td>
<p>Numeric from zero (no fading) to one (furthest points are
invisible) specifying amount to fade distant points.</p>
</td></tr>
<tr><td><code id="Plot3_+3A_shrink">shrink</code></td>
<td>
<p>Numeric specifying degree to which size of plotted point
should reflect <code>z</code> position. <code>0</code> denotes no scaling; if <code>1</code>, furthest
point will have zero size.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Plot3(1:10, 1:10, 1:10, cex = 7, pch = 16, axes = FALSE, asp = 1)
# Extreme values of fog and shrink will cause smallest z values to
# become invisible.
Plot3(1:10, 1:10, 1:10, cex = 7, pch = 16, axes = FALSE, asp = 1,
      fog = 1, shrink = 1)
</code></pre>

<hr>
<h2 id='ReportMatching'>List clades as text</h2><span id='topic+ReportMatching'></span>

<h3>Description</h3>

<p>List clades as text
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReportMatching(splits1, splits2, realMatch = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReportMatching_+3A_splits1">splits1</code>, <code id="ReportMatching_+3A_splits2">splits2</code></td>
<td>
<p>Logical matrices with columns specifying membership
of each corresponding matched clade.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ReportMatching</code> returns a character vector describing each pairing
in a matching.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VisualizeMatching">VisualizeMatching</a></code>
</p>

<hr>
<h2 id='Robinson-Foulds'>Robinson–Foulds distances, with adjustments for phylogenetic information
content</h2><span id='topic+Robinson-Foulds'></span><span id='topic+InfoRobinsonFoulds'></span><span id='topic+RobinsonFouldsInfo'></span><span id='topic+InfoRobinsonFouldsSplits'></span><span id='topic+RobinsonFoulds'></span><span id='topic+RobinsonFouldsMatching'></span><span id='topic+RobinsonFouldsSplits'></span>

<h3>Description</h3>

<p>Calculate the Robinson–Foulds distance
(Robinson and Foulds 1981), or
the equivalent similarity measure, with options to
(i) annotate matched splits;
(ii) weight splits according to their phylogenetic information content
(Smith 2020).
Whilst slower to calculate, information theoretic modifications of the
Robinson–Foulds distance (see <code><a href="#topic+TreeDistance">TreeDistance()</a></code>)
are better suited to most use cases
(Smith 2020, 2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InfoRobinsonFoulds(
  tree1,
  tree2 = NULL,
  similarity = FALSE,
  normalize = FALSE,
  reportMatching = FALSE
)

InfoRobinsonFouldsSplits(
  splits1,
  splits2,
  nTip = attr(splits1, "nTip"),
  reportMatching = FALSE
)

RobinsonFoulds(
  tree1,
  tree2 = NULL,
  similarity = FALSE,
  normalize = FALSE,
  reportMatching = FALSE
)

RobinsonFouldsMatching(
  tree1,
  tree2,
  similarity = FALSE,
  normalize = FALSE,
  ...
)

RobinsonFouldsSplits(
  splits1,
  splits2,
  nTip = attr(splits1, "nTip"),
  reportMatching = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Robinson-Foulds_+3A_tree1">tree1</code>, <code id="Robinson-Foulds_+3A_tree2">tree2</code></td>
<td>
<p>Trees of class <code>phylo</code>, with leaves labelled identically,
or lists of such trees to undergo pairwise comparison.  Where implemented,
<code>tree2 = NULL</code> will compute distances between each pair of trees in the list
<code>tree1</code> using a fast algorithm based on Day (1985).</p>
</td></tr>
<tr><td><code id="Robinson-Foulds_+3A_similarity">similarity</code></td>
<td>
<p>Logical specifying whether to report the result as a tree
similarity, rather than a difference.</p>
</td></tr>
<tr><td><code id="Robinson-Foulds_+3A_normalize">normalize</code></td>
<td>
<p>If a numeric value is provided, this will be used as a
maximum value against which to rescale results.
If <code>TRUE</code>, results will be rescaled against a maximum value calculated from
the specified tree sizes and topology, as specified in the &quot;Normalization&quot;
section below.
If <code>FALSE</code>, results will not be rescaled.</p>
</td></tr>
<tr><td><code id="Robinson-Foulds_+3A_reportmatching">reportMatching</code></td>
<td>
<p>Logical specifying whether to return the clade
matchings as an attribute of the score.</p>
</td></tr>
<tr><td><code id="Robinson-Foulds_+3A_splits1">splits1</code>, <code id="Robinson-Foulds_+3A_splits2">splits2</code></td>
<td>
<p>Logical matrices where each row corresponds to a leaf,
either listed in the same order or bearing identical names (in any sequence),
and each column corresponds to a split, such that each leaf is identified as
a member of the ingroup (<code>TRUE</code>) or outgroup (<code>FALSE</code>) of the respective
split.</p>
</td></tr>
<tr><td><code id="Robinson-Foulds_+3A_ntip">nTip</code></td>
<td>
<p>(Optional) Integer specifying the number of leaves in each split.</p>
</td></tr>
<tr><td><code id="Robinson-Foulds_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that if <code>reportMatching = TRUE</code>, the <code>pairScores</code> attribute returns
a logical matrix specifying whether each pair of splits is identical.
</p>
<p><code>InfoRobinsonFoulds()</code> calculates the tree similarity or distance by summing
the phylogenetic information content of all splits that are (or are not)
identical in both trees.  Consequently, splits that are more likely
to be identical by chance alone make a smaller contribution to overall
tree distance, because their similarity is less remarkable.
</p>
<p>Rapid comparison between multiple pairs of trees employs the
Day (1985) linear-time algorithm.
</p>


<h3>Value</h3>

<p><code>RobinsonFoulds()</code> and <code>InfoRobinsonFoulds()</code> return an array of numerics providing the
distances between each  pair of trees in <code>tree1</code> and <code>tree2</code>,
or <code>splits1</code> and <code>splits2</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>RobinsonFouldsMatching()</code>: Matched splits, intended for use with
<code><a href="#topic+VisualizeMatching">VisualizeMatching()</a></code>.
</p>
</li></ul>


<h3>Normalization</h3>


<ul>
<li> <p><code>RobinsonFoulds()</code> is normalized against the total number of splits that
are present.
</p>
</li>
<li> <p><code>InfoRobinsonFoulds()</code> is normalized against the sum of the phylogenetic
information of all splits in both trees, treated independently.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Day WHE (1985).
&ldquo;Optimal algorithms for comparing trees with labeled leaves.&rdquo;
<em>Journal of Classification</em>, <b>2</b>(1), 7&ndash;28.
<a href="https://doi.org/10.1007/BF01908061">doi:10.1007/BF01908061</a>.<br /><br /> Robinson DF, Foulds LR (1981).
&ldquo;Comparison of phylogenetic trees.&rdquo;
<em>Mathematical Biosciences</em>, <b>53</b>(1-2), 131&ndash;147.
<a href="https://doi.org/10.1016/0025-5564%2881%2990043-2">doi:10.1016/0025-5564(81)90043-2</a>.<br /><br /> Smith MR (2020).
&ldquo;Information theoretic Generalized Robinson-Foulds metrics for comparing phylogenetic trees.&rdquo;
<em>Bioinformatics</em>, <b>36</b>(20), 5007&ndash;5013.
<a href="https://doi.org/10.1093/bioinformatics/btaa614">doi:10.1093/bioinformatics/btaa614</a>.<br /><br /> Smith MR (2022).
&ldquo;Robust analysis of phylogenetic tree space.&rdquo;
<em>Systematic Biology</em>, <b>71</b>(5), 1255&ndash;1270.
<a href="https://doi.org/10.1093/sysbio/syab100">doi:10.1093/sysbio/syab100</a>.
</p>


<h3>See Also</h3>

<p>Display paired splits: <code><a href="#topic+VisualizeMatching">VisualizeMatching()</a></code>
</p>
<p>Other tree distances: 
<code><a href="#topic+JaccardRobinsonFoulds">JaccardRobinsonFoulds</a>()</code>,
<code><a href="#topic+KendallColijn">KendallColijn</a>()</code>,
<code><a href="#topic+MASTSize">MASTSize</a>()</code>,
<code><a href="#topic+MatchingSplitDistance">MatchingSplitDistance</a>()</code>,
<code><a href="#topic+NNIDist">NNIDist</a>()</code>,
<code><a href="#topic+NyeSimilarity">NyeSimilarity</a>()</code>,
<code><a href="#topic+PathDist">PathDist</a>()</code>,
<code><a href="#topic+SPRDist">SPRDist</a>()</code>,
<code><a href="#topic+TreeDistance">TreeDistance</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # For BalancedTree, PectinateTree, as.phylo:
library("TreeTools", quietly = TRUE)
balanced7 &lt;- BalancedTree(7)
pectinate7 &lt;- PectinateTree(7)
RobinsonFoulds(balanced7, pectinate7)
RobinsonFoulds(balanced7, pectinate7, normalize = TRUE)
VisualizeMatching(RobinsonFouldsMatching, balanced7, pectinate7)

InfoRobinsonFoulds(balanced7, pectinate7)
VisualizeMatching(InfoRobinsonFoulds, balanced7, pectinate7)
</code></pre>

<hr>
<h2 id='SpectralEigens'>Eigenvalues for spectral clustering</h2><span id='topic+SpectralEigens'></span><span id='topic+SpectralClustering'></span>

<h3>Description</h3>

<p>Spectral clustering emphasizes nearest neighbours when forming clusters;
it avoids some of the issues that arise from clustering around means /
medoids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpectralEigens(D, nn = 10L, nEig = 2L)

SpectralClustering(D, nn = 10L, nEig = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpectralEigens_+3A_d">D</code></td>
<td>
<p>Square matrix or <code>dist</code> object containing Euclidean distances
between data points.</p>
</td></tr>
<tr><td><code id="SpectralEigens_+3A_nn">nn</code></td>
<td>
<p>Integer specifying number of nearest neighbours to consider</p>
</td></tr>
<tr><td><code id="SpectralEigens_+3A_neig">nEig</code></td>
<td>
<p>Integer specifying number of eigenvectors to retain.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SpectralEigens()</code> returns spectral eigenvalues that can then be
clustered using a method of choice.
</p>


<h3>Author(s)</h3>

<p>Adapted by MRS from script by <a href="https://rpubs.com/nurakawa/spectral-clustering">Nura Kawa</a>
</p>


<h3>See Also</h3>

<p>Other tree space functions: 
<code><a href="#topic+MSTSegments">MSTSegments</a>()</code>,
<code><a href="#topic+MapTrees">MapTrees</a>()</code>,
<code><a href="#topic+MappingQuality">MappingQuality</a>()</code>,
<code><a href="#topic+cluster-statistics">cluster-statistics</a></code>,
<code><a href="#topic+median.multiPhylo">median.multiPhylo</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("TreeTools", quietly = TRUE)
trees &lt;- as.phylo(0:18, nTip = 8)
distances &lt;- ClusteringInfoDistance(trees)
eigens &lt;- SpectralEigens(distances)
# Perform clustering:
clusts &lt;- KMeansPP(dist(eigens), k = 3)
plot(eigens, pch = 15, col = clusts$cluster)
plot(cmdscale(distances), pch = 15, col = clusts$cluster)
</code></pre>

<hr>
<h2 id='SplitEntropy'>Entropy of two splits</h2><span id='topic+SplitEntropy'></span>

<h3>Description</h3>

<p>Calculate the entropy, joint entropy, entropy distance and information
content of two splits, treating each split as a division of <em>n</em> leaves into
two groups.
Further details are available in a
<a href="https://ms609.github.io/TreeDist/articles/information.html">vignette</a>,
MacKay (2003) and
Meila (2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SplitEntropy(split1, split2 = split1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SplitEntropy_+3A_split1">split1</code>, <code id="SplitEntropy_+3A_split2">split2</code></td>
<td>
<p>Logical vectors listing leaves in a consistent order,
identifying each leaf as a member of the ingroup (<code>TRUE</code>) or outgroup
(<code>FALSE</code>) of the split in question.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector listing, in bits:
</p>

<ul>
<li> <p><code>H1</code> The entropy of split 1;
</p>
</li>
<li> <p><code>H2</code> The entropy of split 2;
</p>
</li>
<li> <p><code>H12</code> The joint entropy of both splits;
</p>
</li>
<li> <p><code>I</code> The mutual information of the splits;
</p>
</li>
<li> <p><code>Hd</code> The entropy distance (variation of information) of the splits.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>MacKay DJC (2003).
<em>Information Theory, Inference, and Learning Algorithms</em>.
Cambridge University Press, Cambridge.
<a href="https://www.inference.org.uk/itprnn/book.pdf">https://www.inference.org.uk/itprnn/book.pdf</a>.<br /><br /> Meila M (2007).
&ldquo;Comparing clusterings&mdash;an information based distance.&rdquo;
<em>Journal of Multivariate Analysis</em>, <b>98</b>(5), 873&ndash;895.
<a href="https://doi.org/10.1016/j.jmva.2006.11.013">doi:10.1016/j.jmva.2006.11.013</a>.
</p>


<h3>See Also</h3>

<p>Other information functions: 
<code><a href="#topic+SplitSharedInformation">SplitSharedInformation</a>()</code>,
<code><a href="#topic+TreeInfo">TreeInfo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- TRUE
B &lt;- FALSE
SplitEntropy(c(A, A, A, B, B, B), c(A, A, B, B, B, B))
</code></pre>

<hr>
<h2 id='SplitsCompatible'>Are splits compatible?</h2><span id='topic+SplitsCompatible'></span>

<h3>Description</h3>

<p>Determine whether splits are compatible (concave); i.e. they can both occur
on a single tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SplitsCompatible(split1, split2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SplitsCompatible_+3A_split1">split1</code>, <code id="SplitsCompatible_+3A_split2">split2</code></td>
<td>
<p>Logical vectors listing leaves in a consistent order,
identifying each leaf as a member of the ingroup (<code>TRUE</code>) or outgroup
(<code>FALSE</code>) of the split in question.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SplitsCompatible()</code> returns a logical specifying whether the splits
provided are compatible with one another.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- TRUE
B &lt;- FALSE
SplitsCompatible(c(A, A, A, B, B, B),
                 c(A, A, B, B, B, B))
SplitsCompatible(c(A, A, A, B, B, B),
                 c(A, A, B, B, B, A))
</code></pre>

<hr>
<h2 id='SplitSharedInformation'>Shared information content of two splits</h2><span id='topic+SplitSharedInformation'></span><span id='topic+SplitDifferentInformation'></span><span id='topic+TreesConsistentWithTwoSplits'></span><span id='topic+LnTreesConsistentWithTwoSplits'></span><span id='topic+Log2TreesConsistentWithTwoSplits'></span>

<h3>Description</h3>

<p>Calculate the phylogenetic information shared, or not shared, between two
splits.
See the <a href="https://ms609.github.io/TreeDist/articles/information.html">accompanying vignette</a>
for definitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SplitSharedInformation(n, A1, A2 = A1)

SplitDifferentInformation(n, A1, A2 = A1)

TreesConsistentWithTwoSplits(n, A1, A2 = A1)

LnTreesConsistentWithTwoSplits(n, A1, A2 = A1)

Log2TreesConsistentWithTwoSplits(n, A1, A2 = A1)

Log2TreesConsistentWithTwoSplits(n, A1, A2 = A1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SplitSharedInformation_+3A_n">n</code></td>
<td>
<p>Integer specifying the number of leaves</p>
</td></tr>
<tr><td><code id="SplitSharedInformation_+3A_a1">A1</code>, <code id="SplitSharedInformation_+3A_a2">A2</code></td>
<td>
<p>Integers specifying the number of taxa in <em>A1</em> and <em>A2</em>,
once the splits have been arranged such that <em>A1</em> fully overlaps with <em>A2</em>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Split <em>S1</em> divides <em>n</em> leaves into two splits, <em>A1</em> and <em>B1</em>.
Split <em>S2</em> divides the same leaves into the splits <em>A2</em> and <em>B2</em>.
</p>
<p>Splits must be named such that <em>A1</em> fully overlaps with <em>A2</em>:
that is to say, all taxa in <em>A1</em> are also in <em>A2</em>, or <em>vice versa</em>.
Thus, all taxa in the smaller of <em>A1</em> and <em>A2</em> also occur in the larger.
</p>


<h3>Value</h3>

<p><code>TreesConsistentWithTwoSplits()</code> returns the number of unrooted bifurcating
trees consistent with two splits.
</p>
<p><code>SplitSharedInformation()</code> returns the phylogenetic information that two splits
have in common (Meila 2007), in bits.
</p>
<p><code>SplitDifferentInformation()</code> returns the amount of phylogenetic information
distinct to one of the two splits, in bits.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>SplitDifferentInformation()</code>: Different information between two splits.
</p>
</li>
<li> <p><code>TreesConsistentWithTwoSplits()</code>: Number of trees consistent with two
splits.
</p>
</li>
<li> <p><code>LnTreesConsistentWithTwoSplits()</code>: Natural logarithm of
<code>TreesConsistentWithTwoSplits()</code>.
</p>
</li>
<li> <p><code>Log2TreesConsistentWithTwoSplits()</code>: Base two logarithm of
<code>TreesConsistentWithTwoSplits()</code>.
</p>
</li>
<li> <p><code>Log2TreesConsistentWithTwoSplits()</code>: Base 2 logarithm of
<code>TreesConsistentWithTwoSplits()</code>.
</p>
</li></ul>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Meila M (2007).
&ldquo;Comparing clusterings&mdash;an information based distance.&rdquo;
<em>Journal of Multivariate Analysis</em>, <b>98</b>(5), 873&ndash;895.
<a href="https://doi.org/10.1016/j.jmva.2006.11.013">doi:10.1016/j.jmva.2006.11.013</a>.
</p>


<h3>See Also</h3>

<p>Other information functions: 
<code><a href="#topic+SplitEntropy">SplitEntropy</a>()</code>,
<code><a href="#topic+TreeInfo">TreeInfo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Eight leaves, labelled A to H.
  # Split 1: ABCD|EFGH
  # Split 2: ABC|DEFGH
  # Let A1 = ABCD (four taxa), and A2 = ABC (three taxa).
  # A1 and A2 overlap (both contain ABC).
  
  TreesConsistentWithTwoSplits(n = 8, A1 = 4, A2 = 3)
  SplitSharedInformation(n = 8, A1 = 4, A2 = 3)
  SplitDifferentInformation(n = 8, A1 = 4, A2 = 3)

  # If splits are identical, then their shared information is the same
  # as the information of either split:
  SplitSharedInformation(n = 8, A1 = 3, A2 = 3)
  TreeTools::SplitInformation(3, 5)
</code></pre>

<hr>
<h2 id='SPRDist'>Approximate Subtree Prune and Regraft distance</h2><span id='topic+SPRDist'></span>

<h3>Description</h3>

<p>Approximate the Subtree Prune and Regraft (SPR) distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPRDist(tree1, tree2 = NULL, symmetric = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SPRDist_+3A_tree1">tree1</code>, <code id="SPRDist_+3A_tree2">tree2</code></td>
<td>
<p>Trees of class <code>phylo</code>, with leaves labelled identically,
or lists of such trees to undergo pairwise comparison.  Where implemented,
<code>tree2 = NULL</code> will compute distances between each pair of trees in the list
<code>tree1</code> using a fast algorithm based on Day (1985).</p>
</td></tr>
<tr><td><code id="SPRDist_+3A_symmetric">symmetric</code></td>
<td>
<p>Logical specifying whether to produce a better heuristic
by calculating the minimum of <code>SPRDist(t1, t2)</code> and <code>SPRDist(t2, t1)</code>,
which are not guaranteed to be equal due to the heuristic nature of the
approximation (see
<a href="https://github.com/KlausVigo/phangorn/issues/97">phangorn#97</a>). Set to
<code>FALSE</code> for the faster approximation, as implemented in &quot;phangorn&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>SPRDist()</code> is a wrapper for the function
<code><a href="phangorn.html#topic+treedist">SPR.dist()</a></code> in the phangorn package.
It pre-processes trees to ensure that their internal representation does
not cause the <code>SPR.dist()</code> function to crash R, and allows an improved
(but slower) symmetric heuristic.
</p>
<p>A memory leak is present in phangorn v2.5.5.  To avoid a drain on system
resources, install the latest version of phangorn with
<code>devtools::install_github("KlausVigo/phangorn")</code>.
</p>


<h3>Value</h3>

<p><code>SPRDist()</code> returns a vector or distance matrix of distances
between trees.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree distances: 
<code><a href="#topic+JaccardRobinsonFoulds">JaccardRobinsonFoulds</a>()</code>,
<code><a href="#topic+KendallColijn">KendallColijn</a>()</code>,
<code><a href="#topic+MASTSize">MASTSize</a>()</code>,
<code><a href="#topic+MatchingSplitDistance">MatchingSplitDistance</a>()</code>,
<code><a href="#topic+NNIDist">NNIDist</a>()</code>,
<code><a href="#topic+NyeSimilarity">NyeSimilarity</a>()</code>,
<code><a href="#topic+PathDist">PathDist</a>()</code>,
<code><a href="#topic+Robinson-Foulds">Robinson-Foulds</a></code>,
<code><a href="#topic+TreeDistance">TreeDistance</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("TreeTools", quietly = TRUE)

SPRDist(BalancedTree(7), PectinateTree(7))

SPRDist(BalancedTree(7), as.phylo(0:2, 7))
SPRDist(as.phylo(0:2, 7), PectinateTree(7))

SPRDist(list(bal = BalancedTree(7), pec = PectinateTree(7)),
        as.phylo(0:2, 7))

CompareAll(as.phylo(30:33, 8), SPRDist)
</code></pre>

<hr>
<h2 id='StartParallel'>Calculate distances in parallel</h2><span id='topic+StartParallel'></span><span id='topic+SetParallel'></span><span id='topic+GetParallel'></span><span id='topic+StopParallel'></span>

<h3>Description</h3>

<p>Accelerate distance calculation by employing multiple <abbr><span class="acronym">CPU</span></abbr> workers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StartParallel(...)

SetParallel(cl)

GetParallel(cl)

StopParallel(quietly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StartParallel_+3A_...">...</code></td>
<td>
<p>Parameters to pass to <code><a href="parallel.html#topic+makeCluster">makeCluster()</a></code>.</p>
</td></tr>
<tr><td><code id="StartParallel_+3A_cl">cl</code></td>
<td>
<p>An existing cluster.</p>
</td></tr>
<tr><td><code id="StartParallel_+3A_quietly">quietly</code></td>
<td>
<p>Logical; if <code>TRUE</code>, do not warn when no cluster was running.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;TreeDist&quot; parallelizes the calculation of tree to tree distances via
the <code><a href="parallel.html#topic+parCapply">parCapply()</a></code> function, using a user-defined cluster specified in
<code>options("TreeDist-cluster")</code>.
</p>
<p><code>StartParallel()</code> calls <code>parallel::makeCluster()</code> and tells &quot;TreeDist&quot; to
use the created cluster.
</p>
<p><code>SetParallel()</code> tells &quot;TreeDist&quot; to use a pre-existing or user-specified
cluster.
</p>
<p><code>StopParallel()</code> stops the current TreeDist cluster.
</p>


<h3>Value</h3>

<p><code>StartParallel()</code> and <code>SetParallel()</code> return the previous value of
<code>options("TreeDist-cluster")</code>.
</p>
<p><code>GetParallel()</code> returns the currently specified cluster.
</p>
<p><code>StopParallel()</code> returns <code>TRUE</code> if a cluster was destroyed,
<code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) { # Only run in terminal
  library("TreeTools", quietly = TRUE)
  nCores &lt;- ceiling(detectCores() / 2)
  StartParallel(nCores) # Takes a few seconds to set up processes
  GetParallel()
  ClusteringInfoDistance(as.phylo(0:6, 100))
  StopParallel() # Returns system resources
}
</code></pre>

<hr>
<h2 id='TreeDistance'>Information-based generalized Robinson–Foulds distances</h2><span id='topic+TreeDistance'></span><span id='topic+SharedPhylogeneticInfo'></span><span id='topic+DifferentPhylogeneticInfo'></span><span id='topic+PhylogeneticInfoDistance'></span><span id='topic+ClusteringInfoDistance'></span><span id='topic+ClusteringInfoDist'></span><span id='topic+ExpectedVariation'></span><span id='topic+MutualClusteringInfo'></span><span id='topic+MutualClusteringInformation'></span><span id='topic+SharedPhylogeneticInfoSplits'></span><span id='topic+MutualClusteringInfoSplits'></span><span id='topic+MatchingSplitInfo'></span><span id='topic+MatchingSplitInfoDistance'></span><span id='topic+MatchingSplitInfoSplits'></span>

<h3>Description</h3>

<p>Calculate tree similarity and distance measures based on the amount of
phylogenetic or clustering information that two trees hold in common, as
proposed in Smith (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TreeDistance(tree1, tree2 = NULL)

SharedPhylogeneticInfo(
  tree1,
  tree2 = NULL,
  normalize = FALSE,
  reportMatching = FALSE,
  diag = TRUE
)

DifferentPhylogeneticInfo(
  tree1,
  tree2 = NULL,
  normalize = FALSE,
  reportMatching = FALSE
)

PhylogeneticInfoDistance(
  tree1,
  tree2 = NULL,
  normalize = FALSE,
  reportMatching = FALSE
)

ClusteringInfoDistance(
  tree1,
  tree2 = NULL,
  normalize = FALSE,
  reportMatching = FALSE
)

ExpectedVariation(tree1, tree2, samples = 10000)

MutualClusteringInfo(
  tree1,
  tree2 = NULL,
  normalize = FALSE,
  reportMatching = FALSE,
  diag = TRUE
)

SharedPhylogeneticInfoSplits(
  splits1,
  splits2,
  nTip = attr(splits1, "nTip"),
  reportMatching = FALSE
)

MutualClusteringInfoSplits(
  splits1,
  splits2,
  nTip = attr(splits1, "nTip"),
  reportMatching = FALSE
)

MatchingSplitInfo(
  tree1,
  tree2 = NULL,
  normalize = FALSE,
  reportMatching = FALSE,
  diag = TRUE
)

MatchingSplitInfoDistance(
  tree1,
  tree2 = NULL,
  normalize = FALSE,
  reportMatching = FALSE
)

MatchingSplitInfoSplits(
  splits1,
  splits2,
  nTip = attr(splits1, "nTip"),
  reportMatching = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TreeDistance_+3A_tree1">tree1</code>, <code id="TreeDistance_+3A_tree2">tree2</code></td>
<td>
<p>Trees of class <code>phylo</code>, with leaves labelled identically,
or lists of such trees to undergo pairwise comparison.  Where implemented,
<code>tree2 = NULL</code> will compute distances between each pair of trees in the list
<code>tree1</code> using a fast algorithm based on Day (1985).</p>
</td></tr>
<tr><td><code id="TreeDistance_+3A_normalize">normalize</code></td>
<td>
<p>If a numeric value is provided, this will be used as a
maximum value against which to rescale results.
If <code>TRUE</code>, results will be rescaled against a maximum value calculated from
the specified tree sizes and topology, as specified in the &quot;Normalization&quot;
section below.
If <code>FALSE</code>, results will not be rescaled.</p>
</td></tr>
<tr><td><code id="TreeDistance_+3A_reportmatching">reportMatching</code></td>
<td>
<p>Logical specifying whether to return the clade
matchings as an attribute of the score.</p>
</td></tr>
<tr><td><code id="TreeDistance_+3A_diag">diag</code></td>
<td>
<p>Logical specifying whether to return similarities along the
diagonal, i.e. of each tree with itself.  Applies only if <code>tree2</code> is
a list identical to <code>tree1</code>, or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="TreeDistance_+3A_samples">samples</code></td>
<td>
<p>Integer specifying how many samplings to obtain;
accuracy of estimate increases with <code>sqrt(samples)</code>.</p>
</td></tr>
<tr><td><code id="TreeDistance_+3A_splits1">splits1</code>, <code id="TreeDistance_+3A_splits2">splits2</code></td>
<td>
<p>Logical matrices where each row corresponds to a leaf,
either listed in the same order or bearing identical names (in any sequence),
and each column corresponds to a split, such that each leaf is identified as
a member of the ingroup (<code>TRUE</code>) or outgroup (<code>FALSE</code>) of the respective
split.</p>
</td></tr>
<tr><td><code id="TreeDistance_+3A_ntip">nTip</code></td>
<td>
<p>(Optional) Integer specifying the number of leaves in each split.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://ms609.github.io/TreeDist/articles/Robinson-Foulds.html#generalized-robinson-foulds-distances">Generalized Robinson–Foulds distances</a>
calculate tree similarity by finding an
optimal matching that the similarity between a split on one tree
and its pair on a second, considering all possible ways to pair splits
between trees (including leaving a split unpaired).
</p>
<p>The methods implemented here use the concepts of
<a href="https://ms609.github.io/TreeDist/articles/information.html">entropy and information</a>
(MacKay 2003) to assign a similarity score between each
pair of splits.
</p>
<p>The returned tree similarity measures state the amount of information,
in bits, that the splits in two trees hold in common
when they are optimally matched, following
Smith (2020).
The complementary tree distance measures state how much information is
different in the splits of two trees, under an optimal matching.
Where trees contain different tips, tips present in one tree but not the
other are removed before each comparison (as by definition, the trees neither
hold information in common nor differ regarding these tips).
</p>


<h3>Value</h3>

<p>If <code>reportMatching = FALSE</code>, the functions return a numeric
vector specifying the requested similarities or differences.
</p>
<p>If <code>reportMatching = TRUE</code>, the functions additionally return an integer
vector listing the index of the split in <code>tree2</code> that is matched with
each split in <code>tree1</code> in the optimal matching.
Unmatched splits are denoted <code>NA</code>.
Use <code><a href="#topic+VisualizeMatching">VisualizeMatching()</a></code> to plot the optimal matching.
</p>


<h3>Concepts of information</h3>

<p>The phylogenetic (Shannon) information content and entropy of a split are
defined in
<a href="https://ms609.github.io/TreeDist/articles/information.html">a separate vignette</a>.
</p>
<p>Using the mutual (clustering) information
(Meila 2007; Vinh et al. 2010) of two splits to quantify their
similarity gives rise to the Mutual Clustering Information measure
(<code>MutualClusteringInfo()</code>, <code>MutualClusteringInfoSplits()</code>);
the entropy distance gives the Clustering Information Distance
(<code>ClusteringInfoDistance()</code>).
This approach is optimal in many regards, and is implemented with
normalization in the convenience function <code>TreeDistance()</code>.
</p>
<p>Using the amount of phylogenetic information common to two splits to measure
their similarity gives rise to the Shared Phylogenetic Information similarity
measure (<code>SharedPhylogeneticInfo()</code>, <code>SharedPhylogeneticInfoSplits()</code>).
The amount of information distinct to
each of a pair of splits provides the complementary Different Phylogenetic
Information distance metric (<code>DifferentPhylogeneticInfo()</code>).
</p>
<p>The Matching Split Information measure (<code>MatchingSplitInfo()</code>,
<code>MatchingSplitInfoSplits()</code>) defines the similarity between a pair of
splits as the phylogenetic information content of the most informative
split that is consistent with both input splits; <code>MatchingSplitInfoDistance()</code>
is the corresponding measure of tree difference.
(<a href="https://ms609.github.io/TreeDist/articles/Generalized-RF.html">More information here</a>.)
</p>


<h3>Conversion to distances</h3>

<p>To convert similarity measures to distances, it is necessary to
subtract the similarity score from a maximum value.  In order to generate
distance <em>metrics</em>, these functions subtract the similarity twice from the
total information content (SPI, MSI) or entropy (MCI) of all the splits in
both trees (Smith 2020).
</p>


<h3>Normalization</h3>

<p>If <code>normalize = TRUE</code>, then results will be rescaled such that distance
ranges from zero to (in principle) one.
The maximum <strong>distance</strong> is the sum of the information content or entropy of
each split in each tree; the maximum <strong>similarity</strong> is half this value.
(See Vinh <em>et al.</em> (2010, table 3) and
Smith (2020) for
alternative normalization possibilities.)
</p>
<p>Note that a distance value of one (= similarity of zero) will seldom be
achieved, as even the most different trees exhibit some similarity.
It may thus be helpful to rescale the normalized value such that the
<em>expected</em> distance between a random pair of trees equals one.  This can
be calculated with <code>ExpectedVariation()</code>; or see package
'<a href="https://ms609.github.io/TreeDistData/reference/randomTreeDistances.html">TreeDistData</a>'
for a compilation of expected values under different metrics for trees with
up to 200 leaves.
</p>
<p>Alternatively, to scale against the information content or entropy of all
splits in the most or least informative tree, use <code style="white-space: pre;">&#8288;normalize = &#8288;</code><code><a href="base.html#topic+pmax">pmax</a></code> or
<code><a href="base.html#topic+pmin">pmin</a></code> respectively.
To calculate the relative similarity against a reference tree that is known
to be &quot;correct&quot;, use <code>normalize = SplitwiseInfo(trueTree)</code> (SPI, MSI) or
<code>ClusteringEntropy(trueTree)</code> (MCI).
</p>


<h3>Distances between large trees</h3>

<p>To balance memory demands and runtime with flexibility, these functions are
implemented for trees with up to 2048 leaves.
To analyse trees with up to 8192 leaves, you will need to a modified version
of <span class="pkg">TreeTools</span>.
First uninstall <span class="pkg">TreeDist</span> and <span class="pkg">TreeTools</span> using <code>remove.packages()</code>.
Then use <code>devtools::install_github("ms609/TreeTools", ref = "more-leaves")</code>
to install the modified <span class="pkg">TreeTools</span> package.
Finally, install <span class="pkg">TreeDist</span> using
<code>devtools::install_github("ms609/TreeDist")</code>.
(<span class="pkg">TreeDist</span> will need building from source <em>after</em> the modified
<span class="pkg">TreeTools</span> package has been installed, as its code links to values
set in the TreeTools source code.)
</p>
<p>Trees with over 8192 leaves require further modification of the source code,
which the maintainer will attempt on demand; please <a href="https://github.com/ms609/TreeTools/issues/141">comment on GitHub</a> if you would find this useful.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>MacKay DJC (2003).
<em>Information Theory, Inference, and Learning Algorithms</em>.
Cambridge University Press, Cambridge.
<a href="https://www.inference.org.uk/itprnn/book.pdf">https://www.inference.org.uk/itprnn/book.pdf</a>.<br /><br /> Meila M (2007).
&ldquo;Comparing clusterings&mdash;an information based distance.&rdquo;
<em>Journal of Multivariate Analysis</em>, <b>98</b>(5), 873&ndash;895.
<a href="https://doi.org/10.1016/j.jmva.2006.11.013">doi:10.1016/j.jmva.2006.11.013</a>.<br /><br /> Smith MR (2020).
&ldquo;Information theoretic Generalized Robinson-Foulds metrics for comparing phylogenetic trees.&rdquo;
<em>Bioinformatics</em>, <b>36</b>(20), 5007&ndash;5013.
<a href="https://doi.org/10.1093/bioinformatics/btaa614">doi:10.1093/bioinformatics/btaa614</a>.<br /><br /> Vinh NX, Epps J, Bailey J (2010).
&ldquo;Information theoretic measures for clusterings comparison: variants, properties, normalization and correction for chance.&rdquo;
<em>Journal of Machine Learning Research</em>, <b>11</b>, 2837&ndash;2854.
<a href="https://doi.org/10.1145/1553374.1553511">doi:10.1145/1553374.1553511</a>.
</p>


<h3>See Also</h3>

<p>Other tree distances: 
<code><a href="#topic+JaccardRobinsonFoulds">JaccardRobinsonFoulds</a>()</code>,
<code><a href="#topic+KendallColijn">KendallColijn</a>()</code>,
<code><a href="#topic+MASTSize">MASTSize</a>()</code>,
<code><a href="#topic+MatchingSplitDistance">MatchingSplitDistance</a>()</code>,
<code><a href="#topic+NNIDist">NNIDist</a>()</code>,
<code><a href="#topic+NyeSimilarity">NyeSimilarity</a>()</code>,
<code><a href="#topic+PathDist">PathDist</a>()</code>,
<code><a href="#topic+Robinson-Foulds">Robinson-Foulds</a></code>,
<code><a href="#topic+SPRDist">SPRDist</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree1 &lt;- ape::read.tree(text="((((a, b), c), d), (e, (f, (g, h))));")
tree2 &lt;- ape::read.tree(text="(((a, b), (c, d)), ((e, f), (g, h)));")
tree3 &lt;- ape::read.tree(text="((((h, b), c), d), (e, (f, (g, a))));")

# Best possible score is obtained by matching a tree with itself
DifferentPhylogeneticInfo(tree1, tree1) # 0, by definition
SharedPhylogeneticInfo(tree1, tree1)
SplitwiseInfo(tree1) # Maximum shared phylogenetic information

# Best possible score is a function of tree shape; the splits within
# balanced trees are more independent and thus contain less information
SplitwiseInfo(tree2)

# How similar are two trees?
SharedPhylogeneticInfo(tree1, tree2) # Amount of phylogenetic information in common
attr(SharedPhylogeneticInfo(tree1, tree2, reportMatching = TRUE), "matching")
VisualizeMatching(SharedPhylogeneticInfo, tree1, tree2) # Which clades are matched?

DifferentPhylogeneticInfo(tree1, tree2) # Distance measure
DifferentPhylogeneticInfo(tree2, tree1) # The metric is symmetric

# Are they more similar than two trees of this shape would be by chance?
ExpectedVariation(tree1, tree2, sample=12)["DifferentPhylogeneticInfo", "Estimate"]

# Every split in tree1 conflicts with every split in tree3
# Pairs of conflicting splits contain clustering, but not phylogenetic, 
# information
SharedPhylogeneticInfo(tree1, tree3) # = 0
MutualClusteringInfo(tree1, tree3) # &gt; 0

# Converting trees to Splits objects can speed up multiple comparisons
splits1 &lt;- TreeTools::as.Splits(tree1)
splits2 &lt;- TreeTools::as.Splits(tree2)

SharedPhylogeneticInfoSplits(splits1, splits2)
MatchingSplitInfoSplits(splits1, splits2)
MutualClusteringInfoSplits(splits1, splits2)
</code></pre>

<hr>
<h2 id='TreeDistPlot'>Plot a simple tree</h2><span id='topic+TreeDistPlot'></span>

<h3>Description</h3>

<p>Convenience plotting function used in vignettes and documentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TreeDistPlot(
  tr,
  title = NULL,
  bold = NULL,
  leaveRoom = FALSE,
  prune = integer(0),
  graft = integer(0),
  edge.color = "black",
  edge.width = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TreeDistPlot_+3A_tr">tr</code></td>
<td>
<p>A tree of class <code>phylo</code>, with leaves labelled as integers.</p>
</td></tr>
<tr><td><code id="TreeDistPlot_+3A_title">title</code></td>
<td>
<p><code>main</code> title for the plot.</p>
</td></tr>
<tr><td><code id="TreeDistPlot_+3A_bold">bold</code></td>
<td>
<p>Integer specifying which leaves to print in bold.</p>
</td></tr>
<tr><td><code id="TreeDistPlot_+3A_leaveroom">leaveRoom</code></td>
<td>
<p>Logical specifying whether to leave space to print
tree distances beneath the plotted tree.</p>
</td></tr>
<tr><td><code id="TreeDistPlot_+3A_prune">prune</code>, <code id="TreeDistPlot_+3A_graft">graft</code></td>
<td>
<p>Integer vectors specifying which edges to highlight as
pruned and grafted.</p>
</td></tr>
<tr><td><code id="TreeDistPlot_+3A_edge.color">edge.color</code></td>
<td>
<p>Additional parameter to <code>plot.phylo</code>; will be overridden
by <code>prune</code> and <code>graft</code> as requested.</p>
</td></tr>
<tr><td><code id="TreeDistPlot_+3A_edge.width">edge.width</code>, <code id="TreeDistPlot_+3A_...">...</code></td>
<td>
<p>Additional parameters to <code>plot.phylo</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>

<hr>
<h2 id='TreeInfo'>Information content of splits within a tree</h2><span id='topic+TreeInfo'></span><span id='topic+SplitwiseInfo'></span><span id='topic+ClusteringEntropy'></span><span id='topic+ClusteringInfo'></span><span id='topic+ClusteringEntropy.phylo'></span><span id='topic+ClusteringEntropy.list'></span><span id='topic+ClusteringEntropy.multiPhylo'></span><span id='topic+ClusteringEntropy.Splits'></span><span id='topic+ClusteringInfo.phylo'></span><span id='topic+ClusteringInfo.list'></span><span id='topic+ClusteringInfo.multiPhylo'></span><span id='topic+ClusteringInfo.Splits'></span><span id='topic+ConsensusInfo'></span>

<h3>Description</h3>

<p>Sum the entropy (<code>ClusteringEntropy()</code>), clustering information content
(<code>ClusteringInfo()</code>), or phylogenetic information content (<code>SplitwiseInfo()</code>)
across each split within a phylogenetic tree,
or the consensus of a set of phylogenetic trees (<code>ConsensusInfo()</code>).
This value will be greater than the total information
content of the tree where a tree contains multiple splits, as
these splits are not independent and thus contain mutual information that is
counted more than once
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SplitwiseInfo(x, p = NULL, sum = TRUE)

ClusteringEntropy(x, p = NULL, sum = TRUE)

ClusteringInfo(x, p = NULL, sum = TRUE)

## S3 method for class 'phylo'
ClusteringEntropy(x, p = NULL, sum = TRUE)

## S3 method for class 'list'
ClusteringEntropy(x, p = NULL, sum = TRUE)

## S3 method for class 'multiPhylo'
ClusteringEntropy(x, p = NULL, sum = TRUE)

## S3 method for class 'Splits'
ClusteringEntropy(x, p = NULL, sum = TRUE)

## S3 method for class 'phylo'
ClusteringInfo(x, p = NULL, sum = TRUE)

## S3 method for class 'list'
ClusteringInfo(x, p = NULL, sum = TRUE)

## S3 method for class 'multiPhylo'
ClusteringInfo(x, p = NULL, sum = TRUE)

## S3 method for class 'Splits'
ClusteringInfo(x, p = NULL, sum = TRUE)

ConsensusInfo(trees, info = "phylogenetic", p = 0.5, check.tips = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TreeInfo_+3A_x">x</code></td>
<td>
<p>A tree of class <code>phylo</code>, a list of trees, or a <code>multiPhylo</code> object.</p>
</td></tr>
<tr><td><code id="TreeInfo_+3A_p">p</code></td>
<td>
<p>Scalar from 0.5 to 1 specifying minimum proportion of trees that
must contain a split for it to appear within the consensus.</p>
</td></tr>
<tr><td><code id="TreeInfo_+3A_sum">sum</code></td>
<td>
<p>Logical: if <code>TRUE</code>, sum the information content of each split to
provide the total splitwise information content of the tree.</p>
</td></tr>
<tr><td><code id="TreeInfo_+3A_trees">trees</code></td>
<td>
<p>List of <code>phylo</code> objects, optionally with class <code>multiPhylo</code>.</p>
</td></tr>
<tr><td><code id="TreeInfo_+3A_info">info</code></td>
<td>
<p>Abbreviation of &quot;phylogenetic&quot; or &quot;clustering&quot;, specifying
the concept of information to employ.</p>
</td></tr>
<tr><td><code id="TreeInfo_+3A_check.tips">check.tips</code></td>
<td>
<p>Logical specifying whether to renumber leaves such that
leaf numbering is consistent in all trees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SplitwiseInfo()</code>, <code>ClusteringInfo()</code> and <code>ClusteringEntropy()</code>
return the splitwise information content of the tree &ndash; or of each split
in turn, if <code>sum = FALSE</code> &ndash; in bits.
</p>
<p><code>ConsensusInfo()</code> returns the splitwise information content of the
majority rule consensus of <code>trees</code>.
</p>


<h3>Clustering information</h3>

<p>Clustering entropy addresses the question &quot;how much information is contained
in the splits within a tree&quot;. Its approach is complementary to the
phylogenetic information content, used in <code><a href="#topic+SplitwiseInfo">SplitwiseInfo()</a></code>.
In essence, it asks, given a split that subdivides the leaves of a tree into
two partitions, how easy it is to predict which partition a randomly drawn
leaf belongs to (Meila2007; Vinh et al. 2010).
</p>
<p>Formally, the entropy of a split <em>S</em> that divides <em>n</em> leaves into two
partitions of sizes <em>a</em> and <em>b</em> is given by
<em>H(S)</em> = - <em>a/n</em> log <em>a/n</em> - <em>b/n</em> log <em>b/n</em>.
</p>
<p>Base 2 logarithms are conventionally used, such that entropy is measured in
bits.
Entropy denotes the number of bits that are necessary to encode the outcome
of a random variable: here, the random variable is &quot;what partition does a
randomly selected leaf belong to&quot;.
</p>
<p>An even split has an entropy of 1 bit: there is no better way of encoding
an outcome than using one bit to specify which of the two partitions the
randomly selected leaf belongs to.
</p>
<p>An uneven split has a lower entropy: membership of the larger partition is
common, and thus less surprising; it can be signified using fewer bits in an
optimal compression system.
</p>
<p>If this sounds confusing, let's consider creating a code to transmit the
cluster label of two randomly selected leaves.  One straightforward
option would be to use
</p>

<ul>
<li> <p><code>00</code> = &quot;Both leaves belong to partition A&quot;
</p>
</li>
<li> <p><code>11</code> = &quot;Both leaves belong to partition B&quot;
</p>
</li>
<li> <p><code>01</code> = 'First leaf in A, second in B'
</p>
</li>
<li> <p><code>10</code> = 'First leaf in B, second in A'
</p>
</li></ul>

<p>This code uses two bits to transmit the partition labels of two leaves.
If partitions A and B are equiprobable, this is the optimal code; our
entropy &ndash; the average information content required per leaf &ndash; is 1 bit.
</p>
<p>Alternatively, we could use the (suboptimal) code
</p>

<ul>
<li> <p><code>0</code> = &quot;Both leaves belong to partition A&quot;
</p>
</li>
<li> <p><code>111</code> = &quot;Both leaves belong to partition B&quot;
</p>
</li>
<li> <p><code>101</code> = 'First leaf in A, second in B'
</p>
</li>
<li> <p><code>110</code> = 'First leaf in B, second in A'
</p>
</li></ul>

<p>If A is much larger than B, then most pairs of leaves will require just
a single bit (code <code>0</code>). The additional bits when 1+ leaf belongs to B
may be required sufficiently rarely that the average message
requires fewer than two bits for two leaves, so the entropy is less than
1 bit.  (The optimal coding strategy will depend on the exact sizes
of A and B.)
</p>
<p>As entropy measures the bits required to transmit the cluster label of each
leaf (Vinh2010: p. 2840), the information content of
a split is its entropy multiplied by the number of leaves.
</p>


<h3>Phylogenetic information</h3>

<p>Phylogenetic information expresses the information content of a split
in terms of the probability that a uniformly selected tree will contain it
(Thorley et al. 1998).
</p>


<h3>Consensus information</h3>

<p>The information content of splits in a consensus tree is calculated by
interpreting support values (i.e. the proportion of trees containing
each split in the consensus) as probabilities that the true tree contains
that split, following Smith (2022).
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Smith MR (2022).
&ldquo;Using information theory to detect rogue taxa and improve consensus trees.&rdquo;
<em>Systematic Biology</em>, syab099.
<a href="https://doi.org/10.1093/sysbio/syab099">doi:10.1093/sysbio/syab099</a>.<br /><br /> Thorley JL, Wilkinson M, Charleston M (1998).
&ldquo;The information content of consensus trees.&rdquo;
In Rizzi A, Vichi M, Bock H (eds.), <em>Advances in Data Science and Classification</em>, 91&ndash;98.
Springer, Berlin.
<a href="https://doi.org/10.1007/978-3-642-72253-0_12">doi:10.1007/978-3-642-72253-0_12</a>.<br /><br /> Vinh NX, Epps J, Bailey J (2010).
&ldquo;Information theoretic measures for clusterings comparison: variants, properties, normalization and correction for chance.&rdquo;
<em>Journal of Machine Learning Research</em>, <b>11</b>, 2837&ndash;2854.
<a href="https://doi.org/10.1145/1553374.1553511">doi:10.1145/1553374.1553511</a>.
</p>


<h3>See Also</h3>

<p>An introduction to the phylogenetic information content of a split is given
in <a href="https://ms609.github.io/TreeTools/reference/SplitInformation.html"><code>SplitInformation()</code></a>
and in a <a href="https://ms609.github.io/TreeDist/articles/information.html">package vignette</a>.
</p>
<p>Other information functions: 
<code><a href="#topic+SplitEntropy">SplitEntropy</a>()</code>,
<code><a href="#topic+SplitSharedInformation">SplitSharedInformation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("TreeTools", quietly = TRUE)

SplitwiseInfo(PectinateTree(8))
tree &lt;- read.tree(text = "(a, b, (c, (d, e, (f, g)0.8))0.9);")
SplitwiseInfo(tree)
SplitwiseInfo(tree, TRUE)

# Clustering entropy of an even split = 1 bit
ClusteringEntropy(TreeTools::as.Splits(c(rep(TRUE, 4), rep(FALSE, 4))))

# Clustering entropy of an uneven split &lt; 1 bit
ClusteringEntropy(TreeTools::as.Splits(c(rep(TRUE, 2), rep(FALSE, 6))))

tree1 &lt;- TreeTools::BalancedTree(8)
tree2 &lt;- TreeTools::PectinateTree(8)

ClusteringInfo(tree1)
ClusteringEntropy(tree1)
ClusteringInfo(list(one = tree1, two = tree2))

ClusteringInfo(tree1) + ClusteringInfo(tree2)
ClusteringEntropy(tree1) + ClusteringEntropy(tree2)
ClusteringInfoDistance(tree1, tree2)
MutualClusteringInfo(tree1, tree2)

# Clustering entropy with uncertain splits
tree &lt;- ape::read.tree(text = "(a, b, (c, (d, e, (f, g)0.8))0.9);")
ClusteringInfo(tree)
ClusteringInfo(tree, TRUE)

# Support-weighted information content of a consensus tree
set.seed(0)
trees &lt;- list(RandomTree(8), RootTree(BalancedTree(8), 1), PectinateTree(8))
cons &lt;- consensus(trees, p = 0.5)
p &lt;- SplitFrequency(cons, trees) / length(trees)
plot(cons)
LabelSplits(cons, signif(SplitwiseInfo(cons, p, sum = FALSE), 4))
ConsensusInfo(trees)
LabelSplits(cons, signif(ClusteringInfo(cons, p, sum = FALSE), 4))
ConsensusInfo(trees, "clustering")
</code></pre>

<hr>
<h2 id='VisualizeMatching'>Visualise a matching</h2><span id='topic+VisualizeMatching'></span>

<h3>Description</h3>

<p>Depict the splits that are matched between two trees using a specified
<a href="https://ms609.github.io/TreeDist/articles/Generalized-RF.html">Generalized Robinson–Foulds</a>
similarity measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VisualizeMatching(
  Func,
  tree1,
  tree2,
  setPar = TRUE,
  precision = 3L,
  Plot = plot.phylo,
  matchZeros = TRUE,
  plainEdges = FALSE,
  edge.width = 1,
  edge.color = "black",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VisualizeMatching_+3A_func">Func</code></td>
<td>
<p>Function used to construct tree similarity.</p>
</td></tr>
<tr><td><code id="VisualizeMatching_+3A_tree1">tree1</code>, <code id="VisualizeMatching_+3A_tree2">tree2</code></td>
<td>
<p>Trees of class <code>phylo</code>, with identical leaf labels.</p>
</td></tr>
<tr><td><code id="VisualizeMatching_+3A_setpar">setPar</code></td>
<td>
<p>Logical specifying whether graphical parameters should be
set to display trees side by side.</p>
</td></tr>
<tr><td><code id="VisualizeMatching_+3A_precision">precision</code></td>
<td>
<p>Integer specifying number of significant figures to display
when reporting matching scores.</p>
</td></tr>
<tr><td><code id="VisualizeMatching_+3A_plot">Plot</code></td>
<td>
<p>Function to use to plot trees.</p>
</td></tr>
<tr><td><code id="VisualizeMatching_+3A_matchzeros">matchZeros</code></td>
<td>
<p>Logical specifying whether to pair splits with zero
similarity (<code>TRUE</code>), or leave them unpaired (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="VisualizeMatching_+3A_plainedges">plainEdges</code></td>
<td>
<p>Logical specifying whether to plot edges with a uniform
width and colour (<code>TRUE</code>), or whether to draw edge widths according to the
similarity of the associated splits (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="VisualizeMatching_+3A_edge.width">edge.width</code>, <code id="VisualizeMatching_+3A_edge.color">edge.color</code>, <code id="VisualizeMatching_+3A_...">...</code></td>
<td>
<p>Additional parameters to send to <code>Plot()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that when visualizing a Robinson–Foulds distance (using
<code>Func = RobinsonFouldsMatching</code>), matched splits are assigned a <em>similarity</em>
score of 1, which is deducted from the total number of splits to calculate
the Robinson–Foulds <em>distance</em>.  Unmatched splits thus contribute one to
total tree distance.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree1 &lt;- TreeTools::BalancedTree(6)
tree2 &lt;- TreeTools::PectinateTree(6)

VisualizeMatching(RobinsonFouldsMatching, tree1, tree2)
VisualizeMatching(SharedPhylogeneticInfo, tree1, tree2, matchZeros = FALSE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
