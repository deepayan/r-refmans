<!DOCTYPE html><html lang="en-US"><head><title>Help for package lotri</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lotri}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.lotriPointers'><p>This function is used to get the pointers to the C objects that are used in the lotri package.</p></a></li>
<li><a href='#as.lotri'><p>As lower triangular matrix</p></a></li>
<li><a href='#lotri'><p>Easily Specify block-diagonal matrices with lower triangular info</p></a></li>
<li><a href='#lotriAsExpression'><p>Change a matrix or lotri matrix to a lotri expression</p></a></li>
<li><a href='#lotriDataFrameToLotriExpression'><p>Convert a lotri data frame to a lotri expression</p></a></li>
<li><a href='#lotriEst'><p>Extract or remove lotri estimate data frame from lotri object</p></a></li>
<li><a href='#lotriIsBlockMat'><p>Determine if the matrix is a block matrix</p></a></li>
<li><a href='#lotriMat'><p>Create a matrix from a list of matrices</p></a></li>
<li><a href='#lotriMatInv'><p>Converts a matrix into a list of block matrices</p></a></li>
<li><a href='#lotriNearPD'><p>C++ implementation of Matrix's nearPD</p></a></li>
<li><a href='#lotriSep'><p>Separate a lotri matrix into above and below lotri matrices</p></a></li>
<li><a href='#rcm'><p>Use the RCM algorithm to permute to banded matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>A Simple Way to Specify Symmetric, Block Diagonal Matrices</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew L. Fidler &lt;matthew.fidler@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a simple mechanism to specify a symmetric block
    diagonal matrices (often used for covariance matrices).  This is based
    on the domain specific language implemented in 'nlmixr2' but expanded
    to create matrices in R generally instead of specifying parts of
    matrices to estimate. It has expanded to include some matrix manipulation
    functions that are generally useful for 'rxode2' and 'nlmixr2'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://nlmixr2.github.io/lotri/">https://nlmixr2.github.io/lotri/</a>, <a href="https://github.com/nlmixr2/lotri">https://github.com/nlmixr2/lotri</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nlmixr2/lotri/issues">https://github.com/nlmixr2/lotri/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, crayon, methods, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, knitr, Matrix, microbenchmark, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11, cpp11armadillo</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-17 23:09:59 UTC; matt</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew L. Fidler <a href="https://orcid.org/0000-0001-8538-6691"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Bill Denney <a href="https://orcid.org/0000-0002-5759-428X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-18 04:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='.lotriPointers'>This function is used to get the pointers to the C objects that are used in the lotri package.</h2><span id='topic+.lotriPointers'></span>

<h3>Description</h3>

<p>This function is used to get the pointers to the C objects that are used in the lotri package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.lotriPointers()
</code></pre>


<h3>Value</h3>

<p>A list of function pointers
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
.lotriPointers()
</code></pre>

<hr>
<h2 id='as.lotri'>As lower triangular matrix</h2><span id='topic+as.lotri'></span><span id='topic+as.lotri.matrix'></span><span id='topic+as.lotri.data.frame'></span><span id='topic+as.lotri.default'></span>

<h3>Description</h3>

<p>As lower triangular matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.lotri(x, ..., default = "")

## S3 method for class 'matrix'
as.lotri(x, ..., default = "")

## S3 method for class 'data.frame'
as.lotri(x, ..., default = "")

## Default S3 method:
as.lotri(x, ..., default = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.lotri_+3A_x">x</code></td>
<td>
<p>Matrix or other data frame</p>
</td></tr>
<tr><td><code id="as.lotri_+3A_...">...</code></td>
<td>
<p>Other factors</p>
</td></tr>
<tr><td><code id="as.lotri_+3A_default">default</code></td>
<td>
<p>Is the default factor when no conditioning is
implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Lower triangular matrix
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='lotri'>Easily Specify block-diagonal matrices with lower triangular info</h2><span id='topic+lotri'></span>

<h3>Description</h3>

<p>Easily Specify block-diagonal matrices with lower triangular info
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lotri(x, ..., cov = FALSE, rcm = FALSE, envir = parent.frame(), default = "id")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lotri_+3A_x">x</code></td>
<td>
<p>list, matrix or expression, see details</p>
</td></tr>
<tr><td><code id="lotri_+3A_...">...</code></td>
<td>
<p>Other arguments treated as a list that will be
concatenated then reapplied to this function.</p>
</td></tr>
<tr><td><code id="lotri_+3A_cov">cov</code></td>
<td>
<p>either a boolean or a function accepting a matrix input.
</p>
<p>When a boolean, 'cov' describes if this matrix definition is
actually a rxode2/nlmixr2-style covariance matrix.
If so, 'lotri()' will enforce certain regularity conditions:
</p>
<p>- When diagonal elements are zero, the off-diagonal elements are
zero. This means the covariance element is fixed to zero and
not truly part of the covariance matrix in general.
</p>
<p>- For the rest of the matrix, 'lotri' will check that it is
non-positive definite (which is required for covariance matrix in
general)
</p>
<p>It is sometimes difficult to adjust covariance matrices to be
non-positive definite.  For this reason 'cov' may also be a
function accepting a matrix input and returning a non-positive
definite matrix from this matrix input.  When this is a function,
it is equivalent to 'cov=TRUE' with the additional ability to
correct the matrix to be non-positive definite if needed.</p>
</td></tr>
<tr><td><code id="lotri_+3A_rcm">rcm</code></td>
<td>
<p>logical; if 'TRUE', the matrix will be reordered to
change the matrix to a banded matrix, which is easier to express
in 'lotri' than a full matrix.  The RCM stands for the reverse
Cuthill McKee (RCM) algorithm which is used for this matrix permutation.
(see 'rcm()')</p>
</td></tr>
<tr><td><code id="lotri_+3A_envir">envir</code></td>
<td>
<p>the <code><a href="base.html#topic+environment">environment</a></code> in which <code>expr</code> is to
be evaluated.  May also be <code>NULL</code>, a list, a data frame,
a pairlist or an integer as specified to <code><a href="base.html#topic+sys.call">sys.call</a></code>.</p>
</td></tr>
<tr><td><code id="lotri_+3A_default">default</code></td>
<td>
<p>Is the default factor when no conditioning is
implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This can take an R matrix, a list including matrices or
expressions, or expressions
</p>
<p>Expressions can take the form
</p>
<p>name ~ estimate
</p>
<p>Or the lower triangular matrix when &quot;adding&quot; the names
</p>
<p>name1 + name2 ~ c(est1,
est2, est3)
</p>
<p>The matrices are concatenated into a block diagonal matrix, like
<code><a href="Matrix.html#topic+bdiag">bdiag</a></code>, but allows expressions to specify
matrices easier.
</p>


<h3>Value</h3>

<p>named symmetric matrix useful in 'rxode2()' simulations (and
perhaps elsewhere)
</p>


<h3>Author(s)</h3>

<p>Matthew L Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## A few ways to specify the same matrix
lotri({et2 + et3 + et4 ~ c(40,
                           0.1, 20,
                           0.1, 0.1, 30)})

## You  do not need to enclose in {}
lotri(et2 + et3 + et4 ~ c(40,
                          0.1, 20,
                          0.1, 0.1, 30),
          et5 ~ 6)
## But if you do enclose in {}, you can use
## multi-line matrix specifications:

lotri({et2 + et3 + et4 ~ c(40,
                           0.1, 20,
                           0.1, 0.1, 30)
          et5 ~ 6
          })

## You can also add lists or actual R matrices as in this example:
lotri(list(et2 + et3 + et4 ~ c(40,
                               0.1, 20,
                               0.1, 0.1, 30),
              matrix(1,dimnames=list("et5","et5"))))

## Overall this is a flexible way to specify symmetric block
## diagonal matrices.

## For rxode2, you may also condition based on different levels of
## nesting with lotri;  Here is an example:

mat &lt;- lotri(lotri(iov.Ka ~ 0.5,
                    iov.Cl ~ 0.6),
              lotri(occ.Ka ~ 0.5,
                    occ.Cl ~ 0.6) | occ(lower=4,nu=3))

mat

## you may access features of the matrix simply by `$` that is

mat$lower # Shows the lower bound for each condition

mat$lower$occ # shows the lower bound for the occasion variable

## Note that `lower` fills in defaults for parameters.  This is true
## for `upper` true;  In fact when accessing this the defaults
## are put into the list

mat$upper

## However all other values return NULL if they are not present like

mat$lotri

## And values that are specified once are only returned on one list:

mat$nu

mat$nu$occ
mat$nu$id

## You can also change the default condition with `as.lotri`

mat &lt;- as.lotri(mat, default="id")

mat

</code></pre>

<hr>
<h2 id='lotriAsExpression'>Change a matrix or lotri matrix to a lotri expression</h2><span id='topic+lotriAsExpression'></span>

<h3>Description</h3>

<p>Change a matrix or lotri matrix to a lotri expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lotriAsExpression(
  x,
  useIni = FALSE,
  plusNames = getOption("lotri.plusNames", FALSE),
  nameEst = getOption("lotri.nameEst", 5L)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lotriAsExpression_+3A_x">x</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="lotriAsExpression_+3A_useini">useIni</code></td>
<td>
<p>use the ini block</p>
</td></tr>
<tr><td><code id="lotriAsExpression_+3A_plusnames">plusNames</code></td>
<td>
<p>logical, when 'TRUE' use the 'a + b ~ c(1, 0.1,
1)' naming convention.  Otherwise use the lotri single line
convention 'a ~ 1; b ~ c(0.1, 1)'</p>
</td></tr>
<tr><td><code id="lotriAsExpression_+3A_nameest">nameEst</code></td>
<td>
<p>logical or integerish.  When logical 'TRUE' will add
names to all matrix estimates and 'TRUE' when using the lotri
single line convention i.e. 'a~c(a=1); b~c(a=0.1, b=1)'.  When an
integer, the dimension of the matrix being displayed needs to
have a dimension above this number before names are displayed.</p>
</td></tr>
</table>

<hr>
<h2 id='lotriDataFrameToLotriExpression'>Convert a lotri data frame to a lotri expression</h2><span id='topic+lotriDataFrameToLotriExpression'></span>

<h3>Description</h3>

<p>Convert a lotri data frame to a lotri expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lotriDataFrameToLotriExpression(data, useIni = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lotriDataFrameToLotriExpression_+3A_data">data</code></td>
<td>
<p>lotri data frame</p>
</td></tr>
<tr><td><code id="lotriDataFrameToLotriExpression_+3A_useini">useIni</code></td>
<td>
<p>Use 'ini' instead of 'lotri' in the expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>expression of the lotri syntax equivalent to the data.frame provided
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 x &lt;- lotri({
  tka &lt;- 0.45; label("Log Ka")
  tcl &lt;- 1; label("Log Cl")
  tv &lt;- 3.45; label("Log V")
  eta.ka ~ 0.6
  eta.cl ~ 0.3
  eta.v ~ 0.1
  add.err &lt;- 0.7
})

df &lt;- as.data.frame(x)

lotriDataFrameToLotriExpression(df)

# You may also call as.expression directly from the lotri object

as.expression(x)

</code></pre>

<hr>
<h2 id='lotriEst'>Extract or remove lotri estimate data frame from lotri object</h2><span id='topic+lotriEst'></span>

<h3>Description</h3>

<p>Extract or remove lotri estimate data frame from lotri object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lotriEst(x, drop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lotriEst_+3A_x">x</code></td>
<td>
<p>lotri object</p>
</td></tr>
<tr><td><code id="lotriEst_+3A_drop">drop</code></td>
<td>
<p>boolean indicating if the lotri estimate should be dropped</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with estimates or NULL if there is not a data.frame attached
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fix1 &lt;- lotri({
   a &lt;- c(0, 1); backTransform("exp"); label("a label")
   b &lt;- c(0, 1, 2)
   c &lt;- fix(1)
   d &lt;- fix(0, 1, 2)
   e &lt;- c(0, 1, 2, fixed)
   f+g ~ c(1,
           0.5, 1)
 })

# Extract the attached lotri estimate data frame
lotriEst(fix1)

# Remove the attached lotri estimate data frame
lotriEst(fix1, drop=TRUE)

</code></pre>

<hr>
<h2 id='lotriIsBlockMat'>Determine if the matrix is a block matrix</h2><span id='topic+lotriIsBlockMat'></span>

<h3>Description</h3>

<p>Determine if the matrix is a block matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lotriIsBlockMat(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lotriIsBlockMat_+3A_mat">mat</code></td>
<td>
<p>matrix to determine if it is a block matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical value, TRUE if it is a block matrix and FALSE
otherwise
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- lotri({
  a ~ c(a = 0.4)
  b ~ c(a = 0, b = 0.3)
  c ~ c(a = 0, b = 0, c = 0)
  d ~ c(a = -0.1, b = 0, c = 0, d = 0.2)
  e ~ c(a = 0, b = 0, c = 0, d = 0, e = 0.5)
  f ~ c(a = 0, b = 0, c = 0, d = 0, e = 0, f = 1.3)
  g ~ c(a = 0, b = 0, c = 0, d = 0, e = 0, f = -0.6, g = 0.8)
  h ~ c(a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0)
  i ~ c(a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0,
        i = 0.2)
  j ~ c(a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0,
        i = 0, j = 0.9)
  k ~ c(a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0,
        i = 0, j = 0, k = 0.9)
  l ~ c(a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0,
        i = 0, j = -0.2, k = 0, l = 0.3)
  m ~ c(a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0,
        i = 0, j = 0, k = 0, l = 0, m = 2.1)
  n ~ c(a = 0.2, b = 0, c = 0, d = 0.2, e = 0, f = 0, g = 0,
        h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0.4)
  o ~ c(a = 0, b = 0, c = 0, d = 0, e = 0, f = -1.1, g = 0.9,
        h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 4.7)
  p ~ c(a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0,
        i = 0, j = 0.5, k = 0, l = 0.2, m = 0, n = 0, o = 0,
       p = 1.9)
})

lotriIsBlockMat(m)

lotriIsBlockMat(rcm(m))

</code></pre>

<hr>
<h2 id='lotriMat'>Create a matrix from a list of matrices</h2><span id='topic+lotriMat'></span>

<h3>Description</h3>

<p>This creates a named banded symmetric matrix from a list of named
symmetric matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lotriMat(matList, format = NULL, start = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lotriMat_+3A_matlist">matList</code></td>
<td>
<p>list of symmetric named matrices</p>
</td></tr>
<tr><td><code id="lotriMat_+3A_format">format</code></td>
<td>
<p>The format of dimension names when a sub-matrix is
repeated. The format will be called with the dimension number,
so &quot;ETA[%d]&quot; would represent &quot;ETA[1]&quot;, &quot;ETA[2]&quot;, etc</p>
</td></tr>
<tr><td><code id="lotriMat_+3A_start">start</code></td>
<td>
<p>The number the counter of each repeated dimension
should start.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named symmetric block diagonal matrix based on
concatenating the list of matrices together
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
testList &lt;- list(lotri({et2 + et3 + et4 ~ c(40,
                           0.1, 20,
                           0.1, 0.1, 30)}),
                 lotri(et5 ~ 6))

testList

lotriMat(testList)


# Another option is to repeat a matrix a number of times.  This
# can be done with list(matrix, # times to repeat).

# In the example below, the first matrix is repeated 3 times
testList &lt;- list(list(lotri({et2 + et3 + et4 ~ c(40,
                           0.1, 20,
                           0.1, 0.1, 30)}), 3),
                 lotri(et5 ~ 6))

lotriMat(testList)

# Notice that the dimension names `et2`, `et3` and `et4` are
# repeated.

# Another option is to name the dimensions.  For example it could
# be `ETA[1]`, `ETA[2]`, etc by using the 'format' option:

lotriMat(testList, "ETA[%d]")

# Or could start with ETA[2]:

lotriMat(testList, "ETA[%d]", 2)

</code></pre>

<hr>
<h2 id='lotriMatInv'>Converts a matrix into a list of block matrices</h2><span id='topic+lotriMatInv'></span>

<h3>Description</h3>

<p>Converts a matrix into a list of block matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lotriMatInv(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lotriMatInv_+3A_mat">mat</code></td>
<td>
<p>Matrix to convert to a list of block matrices</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the inverse of 'lotriMat()'
</p>


<h3>Value</h3>

<p>A list of block matrixes
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a block matrix using `lotri()`
mat &lt;- lotri({
   a+b ~ c(1,
           0.5, 1)
   c ~ 1
   d +e ~ c(1,
            0.5, 1)
})

print(mat)

# now convert t a list of matrices

mat2 &lt;- lotriMatInv(mat)
print(mat2)

# Of course you can convert it back to a full matrix:

mat3 &lt;- lotriMat(mat2)

print(mat3)
</code></pre>

<hr>
<h2 id='lotriNearPD'>C++ implementation of Matrix's nearPD</h2><span id='topic+lotriNearPD'></span>

<h3>Description</h3>

<p>With 'ensureSymmetry' it makes sure it is symmetric by applying 0.5*(t(x) + x) before using lotriNearPD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lotriNearPD(
  x,
  keepDiag = FALSE,
  do2eigen = TRUE,
  doDykstra = TRUE,
  only.values = FALSE,
  ensureSymmetry = !isSymmetric(x),
  eig.tol = 1e-06,
  conv.tol = 1e-07,
  posd.tol = 1e-08,
  maxit = 100L,
  trace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lotriNearPD_+3A_x">x</code></td>
<td>
<p>numeric <code class="reqn">n \times n</code> approximately positive
definite matrix, typically an approximation to a correlation or
covariance matrix.  If <code>x</code> is not symmetric (and
<code>ensureSymmetry</code> is not false), <code><a href="Matrix.html#topic+symmpart">symmpart</a>(x)</code> is used.</p>
</td></tr>
<tr><td><code id="lotriNearPD_+3A_keepdiag">keepDiag</code></td>
<td>
<p>logical, generalizing <code>corr</code>: if <code>TRUE</code>, the
resulting matrix should have the same diagonal
(<code><a href="base.html#topic+diag">diag</a>(x)</code>) as the input matrix.</p>
</td></tr>
<tr><td><code id="lotriNearPD_+3A_do2eigen">do2eigen</code></td>
<td>
<p>logical indicating if a 'posdefify()' (like in the
package 'sfsmisc') eigen step should be applied to the result of
the Higham algorithm</p>
</td></tr>
<tr><td><code id="lotriNearPD_+3A_dodykstra">doDykstra</code></td>
<td>
<p>logical indicating if Dykstra's correction should be
used; true by default.  If false, the algorithm is basically the
direct fixpoint iteration
<code class="reqn">Y_k = P_U(P_S(Y_{k-1}))</code>.</p>
</td></tr>
<tr><td><code id="lotriNearPD_+3A_only.values">only.values</code></td>
<td>
<p>logical; if <code>TRUE</code>, the result is just the
vector of eigenvalues of the approximating matrix.</p>
</td></tr>
<tr><td><code id="lotriNearPD_+3A_ensuresymmetry">ensureSymmetry</code></td>
<td>
<p>logical; by default, <code><a href="Matrix.html#topic+symmpart">symmpart</a>(x)</code>
is used whenever <code>isSymmetric(x)</code> is not true.  The user
can explicitly set this to <code>TRUE</code> or <code>FALSE</code>, saving the
symmetry test. <em>Beware</em> however that setting it <code>FALSE</code>
for an <b>a</b>symmetric input <code>x</code>, is typically nonsense!</p>
</td></tr>
<tr><td><code id="lotriNearPD_+3A_eig.tol">eig.tol</code></td>
<td>
<p>defines relative positiveness of eigenvalues compared
to largest one, <code class="reqn">\lambda_1</code>. Eigenvalues <code class="reqn">\lambda_k</code> are
treated as if zero when <code class="reqn">\lambda_k / \lambda_1 \le eig.tol</code>.</p>
</td></tr>
<tr><td><code id="lotriNearPD_+3A_conv.tol">conv.tol</code></td>
<td>
<p>convergence tolerance for Higham algorithm.</p>
</td></tr>
<tr><td><code id="lotriNearPD_+3A_posd.tol">posd.tol</code></td>
<td>
<p>tolerance for enforcing positive definiteness (in the
final <code>posdefify</code> step when <code>do2eigen</code> is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="lotriNearPD_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="lotriNearPD_+3A_trace">trace</code></td>
<td>
<p>logical or integer specifying if convergence monitoring
should be traced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implements the algorithm of Higham (2002), and then (if
<code>do2eigen</code> is true) forces positive definiteness using code from
'sfsmisc::posdefify()'.  The algorithm of Knol and ten
Berge (1989) (not implemented here) is more general in that it
allows constraints to (1) fix some rows (and columns) of the matrix and
(2) force the smallest eigenvalue to have a certain value.
</p>
<p>Note that setting <code>corr = TRUE</code> just sets <code>diag(.) &lt;- 1</code>
within the algorithm.
</p>
<p>Higham (2002) uses Dykstra's correction, but the version by Jens
Oehlschlägel did not use it (accidentally),
and still gave reasonable results; this simplification, now only
used if <code>doDykstra = FALSE</code>,
was active in <code>nearPD()</code> up to Matrix version 0.999375-40.
</p>


<h3>Value</h3>

<p>unlike the matrix package, this simply returns the nearest
positive definite matrix
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel donated a first
version to Matrix.  Subsequent changes by the Matrix package
authors, later modifications to C++ by Matthew Fidler
</p>


<h3>References</h3>

<p>Cheng, Sheung Hun and Higham, Nick (1998)
A Modified Cholesky Algorithm Based on a Symmetric Indefinite Factorization;
<em>SIAM J. Matrix Anal.\ Appl.</em>, <b>19</b>, 1097&ndash;1110.
</p>
<p>Knol DL, ten Berge JMF (1989)
Least-squares approximation of an improper correlation matrix by a
proper one.
<em>Psychometrika</em> <b>54</b>, 53&ndash;61.
</p>
<p>Higham, Nick (2002)
Computing the nearest correlation matrix - a problem from finance;
<em>IMA Journal of Numerical Analysis</em> <b>22</b>, 329&ndash;343.
</p>


<h3>See Also</h3>

<p>A first version of this (with non-optional <code>corr=TRUE</code>)
has been available as 'sfsmisc::nearcor()' and
more simple versions with a similar purpose
'sfsmisc::posdefify()'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)
m &lt;- matrix(round(rnorm(25),2), 5, 5)
m &lt;- m + t(m)
diag(m) &lt;- pmax(0, diag(m)) + 1
(m &lt;- round(cov2cor(m), 2))

near.m &lt;- lotriNearPD(m)
round(near.m, 2)
norm(m - near.m) # 1.102 / 1.08

round(lotriNearPD(m, only.values=TRUE), 9)

## A longer example, extended from Jens' original,
## showing the effects of some of the options:

pr &lt;- matrix(c(1,     0.477, 0.644, 0.478, 0.651, 0.826,
               0.477, 1,     0.516, 0.233, 0.682, 0.75,
               0.644, 0.516, 1,     0.599, 0.581, 0.742,
               0.478, 0.233, 0.599, 1,     0.741, 0.8,
               0.651, 0.682, 0.581, 0.741, 1,     0.798,
               0.826, 0.75,  0.742, 0.8,   0.798, 1),
               nrow = 6, ncol = 6)

nc  &lt;- lotriNearPD(pr)

</code></pre>

<hr>
<h2 id='lotriSep'>Separate a lotri matrix into above and below lotri matrices</h2><span id='topic+lotriSep'></span>

<h3>Description</h3>

<p>This is used for creating nesting simulations in 'rxode2()' and may
not be useful for external function calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lotriSep(x, above, below, aboveStart = 1L, belowStart = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lotriSep_+3A_x">x</code></td>
<td>
<p>lotri matrix</p>
</td></tr>
<tr><td><code id="lotriSep_+3A_above">above</code></td>
<td>
<p>Named integer vector listing variability above the id
level.  Each element lists the number of population differences
in the whole data-set (as integer)</p>
</td></tr>
<tr><td><code id="lotriSep_+3A_below">below</code></td>
<td>
<p>Named integer vector listing variability below the id
level.  Each element lists the number of items below the
individual level.  For example with 3 occasions per individual
you could use 'c(occ=3L)'</p>
</td></tr>
<tr><td><code id="lotriSep_+3A_abovestart">aboveStart</code></td>
<td>
<p>Add the attribute of where THETA[#] will be added</p>
</td></tr>
<tr><td><code id="lotriSep_+3A_belowstart">belowStart</code></td>
<td>
<p>Add the attribute of where ETA[#] will be added</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of two lotri matrices
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
omega &lt;- lotri(lotri(eta.Cl ~ 0.1,
                        eta.Ka ~ 0.1) | id(nu=100),
                  lotri(eye.Cl ~ 0.05,
                        eye.Ka ~ 0.05) | eye(nu=50),
                  lotri(iov.Cl ~ 0.01,
                        iov.Ka ~ 0.01) | occ(nu=200),
                  lotri(inv.Cl ~ 0.02,
                        inv.Ka ~ 0.02) | inv(nu=10))

lotriSep(omega, above=c(inv=10L), below=c(eye=2L, occ=4L))
</code></pre>

<hr>
<h2 id='rcm'>Use the RCM algorithm to permute to banded matrix</h2><span id='topic+rcm'></span>

<h3>Description</h3>

<p>The RCM stands for the reverse Cuthill McKee (RCM) algorithm
which is used to permute the matrix to a banded matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcm(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rcm_+3A_x">x</code></td>
<td>
<p>A symmetric matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A permuted matrix that should be banded
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- lotri({
 a + b + c + d + e + f + g + h + i + j + k + l + m + n + o +
 p ~ c(0.4, 0, 0.3, 0, 0, 0, -0.1, 0, 0, 0.2, 0, 0, 0,
       0, 0.5, 0, 0, 0, 0, 0, 1.3, 0, 0, 0, 0, 0, -0.6, 0.8,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.2,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0.9, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0.9, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.2, 0, 0.3,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2.1, 0.2, 0, 0, 0.2,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0.4, 0, 0, 0, 0, 0, -1.1,
       0.9, 0, 0, 0, 0, 0, 0, 0, 4.7, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0.5, 0, 0.2, 0, 0, 0, 1.9)
})

rcm(m)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
