<!DOCTYPE html><html><head><title>Help for package gps</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gps}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DemoBS'>
<p>Demonstrate the construction of ordinary B-splines</p></a></li>
<li><a href='#DemoKnots'>
<p>Demonstrate ordinary cubic B-splines on three types of knots</p></a></li>
<li><a href='#DemoNull'>
<p>Demonstrate the null space of P-splines</p></a></li>
<li><a href='#DemoPBS'>
<p>Demonstrate the construction of periodic B-splines</p></a></li>
<li><a href='#DemoSpl'>
<p>Demonstrate a polynomial spline and its B-spline representation</p></a></li>
<li><a href='#gps2GS'>
<p>Penalized B-splines estimation with automatic grid search of their smoothing parameter</p></a></li>
<li><a href='#GramBS'>
<p>Gram matrix of B-splines</p></a></li>
<li><a href='#MakeGrid'>
<p>Make a grid of <code class="reqn">x</code>-values between domain knots</p></a></li>
<li><a href='#penalty'>
<p>Wiggliness penalties for penalized B-splines</p></a></li>
<li><a href='#penutils'>
<p>Utility functions for working with wiggliness penalties</p></a></li>
<li><a href='#periodic'>
<p>Design matrix and general difference matrices for periodic B-splines</p></a></li>
<li><a href='#PlaceKnots'>
<p>Automatically place knots according to data</p></a></li>
<li><a href='#rspl'>
<p>Simulate random cubic splines</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-02</td>
</tr>
<tr>
<td>Title:</td>
<td>General P-Splines</td>
</tr>
<tr>
<td>Author:</td>
<td>Zheyuan Li <a href="https://orcid.org/0000-0002-7434-5947"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zheyuan Li &lt;zheyuan.li@bath.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, splines, Matrix, methods, graphics, grDevices</td>
</tr>
<tr>
<td>Description:</td>
<td>General P-splines are non-uniform B-splines penalized by a general difference penalty, proposed by Li and Cao (2022) &lt;<a href="https://doi.org/10.48550/arXiv.2201.06808">doi:10.48550/arXiv.2201.06808</a>&gt;. Constructible on arbitrary knots, they extend the standard P-splines of Eilers and Marx (1996) &lt;<a href="https://doi.org/10.1214%2Fss%2F1038425655">doi:10.1214/ss/1038425655</a>&gt;. They are also related to the O-splines of O'Sullivan (1986) &lt;<a href="https://doi.org/10.1214%2Fss%2F1177013525">doi:10.1214/ss/1177013525</a>&gt; via a sandwich formula that links a general difference penalty to a derivative penalty. The package includes routines for setting up and handling difference and derivative penalties. It also fits P-splines and O-splines to (x, y) data (optionally weighted) for a grid of smoothing parameter values in the automatic search intervals of Li and Cao (2023) &lt;<a href="https://doi.org/10.1007%2Fs11222-022-10178-z">doi:10.1007/s11222-022-10178-z</a>&gt;. It aims to facilitate other packages to implement P-splines or O-splines as a smoothing tool in their model estimation framework.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ZheyuanLi/gps">https://github.com/ZheyuanLi/gps</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-02 03:25:41 UTC; lzy</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-02 06:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='DemoBS'>
Demonstrate the construction of ordinary B-splines
</h2><span id='topic+DemoBS'></span>

<h3>Description</h3>

<p>Demonstrate the construction of 4 ordinary cubic B-splines on 8 knots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DemoBS(uniform = TRUE, clamped = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DemoBS_+3A_uniform">uniform</code></td>
<td>
<p>if TRUE, place uniform knots; if FALSE, place non-uniform knots.</p>
</td></tr>
<tr><td><code id="DemoBS_+3A_clamped">clamped</code></td>
<td>
<p>if TRUE, place clamped boundary knots when <code>uniform = FALSE</code>. For aesthetic reason, only boundary knots on the left end are clamped. This parameter is ignored when <code>uniform = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function has no returned values.
</p>


<h3>Author(s)</h3>

<p>Zheyuan Li <a href="mailto:zheyuan.li@bath.edu">zheyuan.li@bath.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(gps)

## uniform B-splines
DemoBS(uniform = TRUE)

## non-uniform B-splines
DemoBS(uniform = FALSE, clamped = FALSE)

## non-uniform &amp; clamped B-splines
DemoBS(uniform = FALSE, clamped = TRUE)
</code></pre>

<hr>
<h2 id='DemoKnots'>
Demonstrate ordinary cubic B-splines on three types of knots
</h2><span id='topic+DemoKnots'></span>

<h3>Description</h3>

<p>Demonstrate ordinary cubic B-splines on three types of knots: (a) uniform knots; (b) non-uniform knots; (c) non-uniform knots with clamped boundary knots. The same interior knots are positioned in cases (b) and (c).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DemoKnots(aligned = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DemoKnots_+3A_aligned">aligned</code></td>
<td>
<p>if TRUE, interior knots in cases (b) and (c) are aligned for a better display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function has no returned values.
</p>


<h3>Author(s)</h3>

<p>Zheyuan Li <a href="mailto:zheyuan.li@bath.edu">zheyuan.li@bath.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(gps)

DemoKnots(aligned = TRUE)
</code></pre>

<hr>
<h2 id='DemoNull'>
Demonstrate the null space of P-splines
</h2><span id='topic+DemoNull'></span>

<h3>Description</h3>

<p>Cubic P-splines set up with non-uniform B-splines and a 2nd order standard or general difference penalty are fitted to observations simulated from <code class="reqn">y = x</code>. Should the resulting standard or general P-splines have the correct null space, the limiting fit at <code class="reqn">\lambda = +\infty</code> will be a straight line regardless of knot locations. In this demo, non-uniform knots from different distributions (primarily Beta distributions with varying shape parameters) are attempted. Results show that standard P-splines have an incorrect and unpredictable limiting behavior that is sensitive to knot locations, whereas general P-splines have a correct and consistent limiting behavior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DemoNull(n, k, gps = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DemoNull_+3A_n">n</code></td>
<td>
<p>number of simulated observations from <code class="reqn">y = x</code>.</p>
</td></tr>
<tr><td><code id="DemoNull_+3A_k">k</code></td>
<td>
<p>number of interior knots to place.</p>
</td></tr>
<tr><td><code id="DemoNull_+3A_gps">gps</code></td>
<td>
<p>if TRUE, fit general P-splines; if FALSE, fit standard P-splines.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function has no returned values.
</p>


<h3>Author(s)</h3>

<p>Zheyuan Li <a href="mailto:zheyuan.li@bath.edu">zheyuan.li@bath.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(gps)

## standard P-splines
DemoNull(n = 100, k = 10, gps = FALSE)

## general P-splines
DemoNull(n = 100, k = 10, gps = TRUE)
</code></pre>

<hr>
<h2 id='DemoPBS'>
Demonstrate the construction of periodic B-splines
</h2><span id='topic+DemoPBS'></span>

<h3>Description</h3>

<p>Demonstrate the construction of 6 periodic cubic B-splines on 7 domain knots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DemoPBS(uniform = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DemoPBS_+3A_uniform">uniform</code></td>
<td>
<p>if TRUE, place uniform knots; if FALSE, place non-uniform knots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function has no returned values.
</p>


<h3>Author(s)</h3>

<p>Zheyuan Li <a href="mailto:zheyuan.li@bath.edu">zheyuan.li@bath.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(gps)

## uniform periodic cubic B-splines
DemoPBS(uniform = TRUE)

## non-uniform periodic cubic B-splines
DemoPBS(uniform = FALSE)
</code></pre>

<hr>
<h2 id='DemoSpl'>
Demonstrate a polynomial spline and its B-spline representation
</h2><span id='topic+DemoSpl'></span>

<h3>Description</h3>

<p>Demonstrate a cubic spline and its B-spline representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DemoSpl(uniform = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DemoSpl_+3A_uniform">uniform</code></td>
<td>
<p>if TRUE, place uniform knots; if FALSE, place non-uniform knots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list giving the domain knots, B-spline coefficients and piecewise polynomial coefficients of the illustrated cubic spline.
</p>


<h3>Author(s)</h3>

<p>Zheyuan Li <a href="mailto:zheyuan.li@bath.edu">zheyuan.li@bath.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(gps)

## a cubic spline with uniform knots
DemoSpl(uniform = TRUE)

## a cubic spline with non-uniform knots
DemoSpl(uniform = FALSE)
</code></pre>

<hr>
<h2 id='gps2GS'>
Penalized B-splines estimation with automatic grid search of their smoothing parameter
</h2><span id='topic+gps2GS'></span><span id='topic+DemoRhoLim'></span>

<h3>Description</h3>

<p>Fit penalized B-splines (including standard or general P-splines and O-splines) to <code>(x, y, w)</code> for a grid of smoothing parameter values in the automatic search intervals of Li and Cao (2023). The GCV score and effective degree of freedom of each fit are also returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gps2GS(x, y, w = NULL, xt, d = 4, m = 2, gps = TRUE, periodic = FALSE,
       ng = 20, scalePen = TRUE)
       
DemoRhoLim(fit, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gps2GS_+3A_x">x</code>, <code id="gps2GS_+3A_y">y</code>, <code id="gps2GS_+3A_w">w</code></td>
<td>
<p>a vector of <code class="reqn">x</code>-values, <code class="reqn">y</code>-values and weights.</p>
</td></tr>
<tr><td><code id="gps2GS_+3A_xt">xt</code></td>
<td>
<p>full knot sequence for ordinary B-splines (<code>length(xt) &gt;= 2 * d</code>).</p>
</td></tr>
<tr><td><code id="gps2GS_+3A_d">d</code></td>
<td>
<p>B-spline order (<code class="reqn">d \ge 2</code>).</p>
</td></tr>
<tr><td><code id="gps2GS_+3A_m">m</code></td>
<td>
<p>penalty order (<code class="reqn">1 \le m \le d - 1</code>).</p>
</td></tr>
<tr><td><code id="gps2GS_+3A_gps">gps</code></td>
<td>
<p>if TRUE, use a difference penalty; if FALSE, use a derivative penalty.</p>
</td></tr>
<tr><td><code id="gps2GS_+3A_periodic">periodic</code></td>
<td>
<p>if TRUE, periodic boundary conditions are applied to B-splines and their penalty, so that periodic P-splines are estimated.</p>
</td></tr>
<tr><td><code id="gps2GS_+3A_ng">ng</code></td>
<td>
<p>number of grid points in the grid search of <code class="reqn">\rho</code>; can be set to 0 to set up the grid search only, without actual P-splines estimation.</p>
</td></tr>
<tr><td><code id="gps2GS_+3A_scalepen">scalePen</code></td>
<td>
<p>if TRUE, scale the penalty matrix <code class="reqn">\bm{S}</code> (as <span class="pkg">mgcv</span> does).</p>
</td></tr>
<tr><td><code id="gps2GS_+3A_fit">fit</code></td>
<td>
<p>fitted P-splines returned by <code>gps2GS</code>.</p>
</td></tr>
<tr><td><code id="gps2GS_+3A_plot">plot</code></td>
<td>
<p>if TRUE, produce summary plots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We smooth <code class="reqn">y_i</code> using <code class="reqn">f(x_i) = \bm{B_i\beta}</code>, where <code class="reqn">\bm{B_i}</code> is <code class="reqn">i</code>-th row of the B-spline design matrix <code class="reqn">\bm{B}</code> and <code class="reqn">\bm{\beta}</code> is a vector of B-spline coefficients. These coefficients are estimated by minimizing: </p>
<p style="text-align: center;"><code class="reqn">\|\bm{y} - \bm{B\beta}\|^2 + \exp(\rho)\cdot\|\bm{D\beta}\|^2,</code>
</p>
<p> where the <code class="reqn">L_2</code> penalty <code class="reqn">\|\bm{D\beta}\|^2</code> is some wiggliness measure for <code class="reqn">f(x)</code> and <code class="reqn">\rho \in (-\infty, +\infty)</code> is a smoothing parameter.
</p>


<h3>Value</h3>

<p><code>gps2GS</code> returns a large list with the following components:
</p>

<ul>
<li> <p><code>eqn</code>
</p>
</li>
<li> <p><code>eigen</code>
</p>
</li>
<li> <p><code>rho.lim</code>
</p>
</li>
<li> <p><code>E</code>
</p>
</li>
<li> <p><code>pwls</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Zheyuan Li <a href="mailto:zheyuan.li@bath.edu">zheyuan.li@bath.edu</a>
</p>


<h3>References</h3>

<p>Zheyuan Li and Jiguo Cao (2023). Automatic search intervals for the smoothing parameter in penalized splines, <em>Statistics and Computing</em>, <a href="https://doi.org/10.1007/s11222-022-10178-z">doi:10.1007/s11222-022-10178-z</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(gps)

x &lt;- rnorm(100)
xt &lt;- PlaceKnots(x, d = 4, k = 10)

## set ng = 0 to set up grid search only
## here the y-values does not matter; we simply use the x-values
setup &lt;- gps2GS(x, x, xt = xt, d = 4, m = 2, ng = 0)

## compute exact eigenvalues
DemoResult &lt;- DemoRhoLim(setup)

## simulate 100 (x, y) data from g(x) = sin(2 * pi * x) on [0, 1]
## x-values are not equidistant but at quantiles of Beta(2, 2)
## note that g(x) is a periodic function
x &lt;- qbeta(seq.int(0, 1, length.out = 100), 2, 2)
gx &lt;- sin(2 * pi * x)
y &lt;- rnorm(length(x), gx, sd = 0.1)

## place quantile knots with clamped boundary knots
xt &lt;- PlaceKnots(x, d = 4, k = 10)

## fit a general P-spline with different boundary constraints
ordinary &lt;- gps2GS(x, y, xt = xt, d = 4, m = 2)
periodic &lt;- gps2GS(x, y, xt = xt, d = 4, m = 2, periodic = TRUE)

## identify the optimal fit minimizing GCV score
opt.ordinary &lt;- which.min(ordinary$pwls$gcv)
opt.periodic &lt;- which.min(periodic$pwls$gcv)

## inspect grid search result
## column 1: ordinary cubic spline
## column 2: periodic cubic spline
op &lt;- par(mfcol = c(2, 2), mar = c(2, 2, 1.5, 0.5))
## ordinary spline
with(ordinary$pwls, plot(rho, edf, ann = FALSE))
title("edf v.s. log(lambda)")
with(ordinary$pwls, plot(rho, gcv, ann = FALSE))
with(ordinary$pwls, points(rho[opt.ordinary], gcv[opt.ordinary], pch = 19))
title("GCV v.s. log(lambda)")
## periodic spline
with(periodic$pwls, plot(rho, edf, ann = FALSE))
title("edf v.s. log(lambda)")
with(periodic$pwls, plot(rho, gcv, ann = FALSE))
with(periodic$pwls, points(rho[opt.periodic], gcv[opt.periodic], pch = 19))
title("GCV v.s. log(lambda)")
par(op)

## inspect fitted splines
yhat.ordinary &lt;- with(ordinary, eqn$B %*% pwls$beta)
yhat.periodic &lt;- with(periodic, eqn$B %*% pwls$beta)
op &lt;- par(mfrow = c(1, 2), mar = c(2, 2, 1.5, 0.5))
## ordinary spline
matplot(x, yhat.ordinary, type = "l", lty = 1, ann = FALSE)
title("ordinary")
## periodic spline
matplot(x, yhat.periodic, type = "l", lty = 1, ann = FALSE)
title("periodic")
par(op)

## pick and plot the optimal fit minimizing GCV score
best.ordinary &lt;- yhat.ordinary[, opt.ordinary]
best.periodic &lt;- yhat.periodic[, opt.periodic]
op &lt;- par(mfrow = c(1, 2), mar = c(2, 2, 1.5, 0.5))
## ordinary spline
plot(x, y, ann = FALSE)
lines(x, gx, lwd = 2, col = 2)
lines(x, best.ordinary, lwd = 2)
title("ordinary")
## periodic spline
plot(x, y, ann = FALSE)
lines(x, gx, lwd = 2, col = 2)
lines(x, best.periodic, lwd = 2)
title("periodic")
par(op)
</code></pre>

<hr>
<h2 id='GramBS'>
Gram matrix of B-splines
</h2><span id='topic+GramBS'></span>

<h3>Description</h3>

<p>Compute the Gram matrix <code class="reqn">\bm{G}</code>, i.e., the matrix of inner products between B-splines <code class="reqn">b_1(x), b_2(x), \ldots</code>. Precisely, its element is <code class="reqn">G_{uv} = \int b_u(x)b_v(x)\textrm{d}x</code>. Such matrix is useful for estimating functional linear models.
</p>
<p>The Gram matrix of differentiated B-splines gives the derivative penalty matrix <code class="reqn">\bm{S}</code> for O-splines. Precisely, its element is <code class="reqn">S_{uv} = \int b_u^{(m)}(x)b_v^{(m)}(x)\textrm{d}x</code>. Such matrix is straightforward to compute using the results of <code><a href="#topic+SparseD">SparseD</a></code>; see Examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GramBS(xt, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GramBS_+3A_xt">xt</code></td>
<td>
<p>full knot sequence for ordinary B-splines (<code>length(xt) &gt;= 2 * d</code>).</p>
</td></tr>
<tr><td><code id="GramBS_+3A_d">d</code></td>
<td>
<p>B-spline order (<code class="reqn">d \ge 2</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse matrix of &quot;dsCMatrix&quot; class.
</p>


<h3>Author(s)</h3>

<p>Zheyuan Li <a href="mailto:zheyuan.li@bath.edu">zheyuan.li@bath.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(gps)
require(Matrix)

## 11 domain knots at equal quantiles of Beta(3, 3) distribution
xd &lt;- qbeta(seq.int(0, 1, by = 0.1), 3, 3)
## full knots (with clamped boundary knots) for constructing cubic B-splines
xt &lt;- c(0, 0, 0, xd, 1, 1, 1)
## compute Gram matrix of B-splines
G &lt;- GramBS(xt, d = 4)
round(G, digits = 3)

## Gram matrix of differentiated B-splines, i.e., a derivative penalty matrix
## compute derivative penalty matrices of all orders (m = NULL in SparseD)
D &lt;- SparseD(xt, d = 4, gps = FALSE)
S &lt;- lapply(D, crossprod)
lapply(S, round, digits = 1)
</code></pre>

<hr>
<h2 id='MakeGrid'>
Make a grid of <code class="reqn">x</code>-values between domain knots
</h2><span id='topic+MakeGrid'></span>

<h3>Description</h3>

<p>Place equidistant grid points on each knot span to produce a grid of <code class="reqn">x</code>-values between domain knots, suitable for evaluating B-splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeGrid(xd, n, rm.dup = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MakeGrid_+3A_xd">xd</code></td>
<td>
<p>domain knot sequence.</p>
</td></tr>
<tr><td><code id="MakeGrid_+3A_n">n</code></td>
<td>
<p>number of equidistant grid points on each knot span.</p>
</td></tr>
<tr><td><code id="MakeGrid_+3A_rm.dup">rm.dup</code></td>
<td>
<p>if FALSE, interior knots will appear twice on the grid; if TRUE, they will appear only once.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Denote the domain knot sequence by <code class="reqn">s_0, s_1, s_2, \ldots, s_k, s_{k + 1}</code>, where <code class="reqn">(s_j)_1^k</code> are interior knots and <code class="reqn">s_0 = a</code>, <code class="reqn">s_{k + 1} = b</code> are domain endpoints. A knot span is the interval between two successive knots, i.e., <code class="reqn">[s_j, s_{j + 1}]</code>.
</p>
<p>To make a suitable grid on <code class="reqn">[a, b]</code> for evaluating B-splines, we can place <code class="reqn">n</code> equidistant grid points on each knot span, ending up with <code class="reqn">n(k + 1)</code> grid points in total. Interior knots will show up twice in this grid. To keep only one instance, set <code>rm.dup = TRUE</code>.
</p>


<h3>Value</h3>

<p>A vector of grid points.
</p>


<h3>Author(s)</h3>

<p>Zheyuan Li <a href="mailto:zheyuan.li@bath.edu">zheyuan.li@bath.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(gps)

## 4 domain knots: two interior knots 0.5 and 1.5 in domain [0, 3]
xd &lt;- c(0, 0.5, 1.5, 3)

## interior knots will appear twice
MakeGrid(xd, 5, rm.dup = FALSE)

## interior knots only appear once
MakeGrid(xd, 5, rm.dup = TRUE)
</code></pre>

<hr>
<h2 id='penalty'>
Wiggliness penalties for penalized B-splines
</h2><span id='topic+penalty'></span><span id='topic+penalties'></span><span id='topic+SparseD'></span><span id='topic+PriorCoef'></span><span id='topic+MPinv'></span>

<h3>Description</h3>

<p>For penalized B-splines (including standard or general P-splines and O-splines), (1) construct matrix <code class="reqn">\bm{D}</code> in the wiggliness penalty <code class="reqn">\|\bm{D\beta}\|^2</code>; (2) sample B-spline coefficients from their prior distribution <code class="reqn">\textrm{N}(\bm{0},\ (\bm{D'D})^-)</code>; (3) compute the Moore-Penrose generalized inverse matrix <code class="reqn">(\bm{D'D})^-</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SparseD(xt, d, m = NULL, gps = TRUE)

PriorCoef(n, D)

MPinv(D, only.diag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penalty_+3A_xt">xt</code></td>
<td>
<p>full knot sequence for ordinary B-splines (<code>length(xt) &gt;= 2 * d</code>).</p>
</td></tr>
<tr><td><code id="penalty_+3A_d">d</code></td>
<td>
<p>B-spline order (<code class="reqn">d \ge 2</code>).</p>
</td></tr>
<tr><td><code id="penalty_+3A_m">m</code></td>
<td>
<p>penalty order (<code class="reqn">1 \le m \le d - 1</code>). Can be a vector of multiple values for <code>SparseD</code>.</p>
</td></tr>
<tr><td><code id="penalty_+3A_gps">gps</code></td>
<td>
<p>if TRUE, return <code class="reqn">\bm{D}_{\textrm{gps}}</code>; if FALSE, return <code class="reqn">\bm{D}_{\textrm{os}}</code>.</p>
</td></tr>
<tr><td><code id="penalty_+3A_n">n</code></td>
<td>
<p>number of samples to draw from the prior distribution.</p>
</td></tr>
<tr><td><code id="penalty_+3A_d">D</code></td>
<td>
<p>matrix <code class="reqn">\bm{D}_{\textrm{gps}}</code> or <code class="reqn">\bm{D}_{\textrm{os}}</code>.</p>
</td></tr>
<tr><td><code id="penalty_+3A_only.diag">only.diag</code></td>
<td>
<p>if TURE, only diagonal elements are computed.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>General Difference Penalty for General P-Splines</h4>

<p>A general P-spline is characterized by an order-<code class="reqn">m</code> general difference matrix <code class="reqn">\bm{D}_{\textrm{gps}}</code>, which can be computed by <code>SparseD(..., gps = TRUE)</code>. For interpretation, the differenced coefficients <code class="reqn">\bm{D}_{\textrm{gps}}\bm{\beta}</code> are in fact <code class="reqn">f^{(m)}(x)</code>'s B-spline coefficients, so the penalty is their squared <code class="reqn">L_2</code> norm.
</p>



<h4>Derivative Penalty for O-Splines</h4>

<p>An O-spline is characterized by <code class="reqn">\bm{D}_{\textrm{os}}</code> such that <code class="reqn">\|\bm{D}_{\textrm{os}}\bm{\beta}\|^2 = \int_a^b f^{(m)}(x)^2\textrm{d}x</code>. Since <code class="reqn">f^{(m)}(x)</code> has B-spline coefficients <code class="reqn">\bm{D}_{\textrm{gps}}\bm{\beta}</code>, the integral can be shown to be <code class="reqn">\bm{\beta'}\bm{D}_{\textrm{gps}}'\bm{\bar{S}}\bm{D}_{\textrm{gps}}\bm{\beta}</code>, where <code class="reqn">\bm{\bar{S}}</code> is the Gram matrix of those B-splines representing <code class="reqn">f^{(m)}(x)</code>. Following the Cholesky factorization <code class="reqn">\bm{\bar{S}} = \bm{U'U}</code>, the quadratic form becomes <code class="reqn">\|\bm{U}\bm{D}_{\textrm{gps}}\bm{\beta}\|^2</code>, so that <code class="reqn">\bm{D}_{\textrm{os}} = \bm{U}\bm{D}_{\textrm{gps}}</code>. This matrix can be computed by <code>SparseD(..., gps = FALSE)</code>, with <code class="reqn">\bm{\bar{S}}</code> and <code class="reqn">\bm{D}_{\textrm{gps}}</code> also returned in a &quot;sandwich&quot; attribute.
</p>



<h4>Penalty Matrix</h4>

<p>We can express the <code class="reqn">L_2</code> penalty <code class="reqn">\|\bm{D\beta}\|^2</code> as quadratic form <code class="reqn">\bm{\beta'S\beta}</code>, where <code class="reqn">\bm{S} = \bm{D'D}</code> is called a penalty matrix. It is trivial to compute <code class="reqn">\bm{S}</code> (using function <code>crossprod</code>) once <code class="reqn">\bm{D}</code> is available, so we don't feel the need to provide a function for this. Note that the link between <code class="reqn">\bm{D}_{\textrm{os}}</code> and <code class="reqn">\bm{D}_{\textrm{gps}}</code> implies a sandwich formula <code class="reqn">\bm{S}_{\textrm{os}} = \bm{D}_{\textrm{gps}}'\bm{\bar{S}}\bm{D}_{\textrm{gps}}</code>, wherease <code class="reqn">\bm{S}_{\textrm{gps}} = \bm{D}_{\textrm{gps}}'\bm{D}_{\textrm{gps}}</code>.
</p>



<h4>The Bayesian View</h4>

<p>In the Bayesian view, the penalty <code class="reqn">\bm{\beta'S\beta}</code> is a Gaussian prior for B-spline coefficients <code class="reqn">\bm{\beta}</code>. But it is an improper one because <code class="reqn">\bm{S}</code> has a null space where an unpenalized order-<code class="reqn">m</code> polynomial lies. Let's decompose <code class="reqn">\bm{\beta} = \bm{\xi} + \bm{\theta}</code>, where <code class="reqn">\bm{\xi}</code> (the projection of <code class="reqn">\bm{\beta}</code> on this null space) is the coefficients of this order-<code class="reqn">m</code> polynomial, and <code class="reqn">\bm{\theta}</code> (orthogonal to <code class="reqn">\bm{\xi}</code>) is the component that can be shrunk to zero by the penalty. As a result, <code class="reqn">\bm{\xi} \propto \bm{1}</code> is not proper, but <code class="reqn">\bm{\theta} \sim \textrm{N}(\bm{0},\ \bm{S}^-)</code> is. Function <code>PriorCoef</code> samples this distribution, and the resulting B-spline coefficients can be used to create random spline curves. The algorithm behind <code>PriorCoef</code> bypasses the Moore-Penrose generalized inverse and is very efficient. We don't recommend forming this inverse matrix because it, being completely dense, is expensive to compute and store. But if we need it anyway, it can be computed using function <code>MPinv</code>.
</p>



<h3>Value</h3>

<p><code>SparseD</code> returns a list of sparse matrices (of &quot;dgCMatrix&quot; class), giving <code class="reqn">\bm{D}_{\textrm{gps}}</code> or <code class="reqn">\bm{D}_{\textrm{os}}</code> of order <code>m[1]</code>, <code>m[2]</code>, ..., <code>m[length(m)]</code>. In the latter case, <code class="reqn">\bm{\bar{S}}</code> (sparse matrices of &quot;dsCMatrix&quot; or &quot;ddiMatrix&quot; class) and <code class="reqn">\bm{D}_{\textrm{gps}}</code> for computing <code class="reqn">\bm{D}_{\textrm{os}}</code> are also returned in a &quot;sandwich&quot; attribute.
</p>
<p><code>PriorCoef</code> returns a list of two components:
</p>

<ul>
<li> <p><code>coef</code> gives a vector of B-spline coefficients when <code>n = 1</code>, or a matrix of <code>n</code> columns when <code>n &gt; 1</code>, where each column is an independent sample;
</p>
</li>
<li> <p><code>sigma</code> is a vector, giving the marginal standard deviation for each B-spline coefficient.
</p>
</li></ul>

<p><code>MPinv</code> returns the dense Moore-Penrose generalized inverse matrix <code class="reqn">\bm{(D'D})^-</code> if <code>only.diag = FALSE</code>, and the diagonal entries of this matrix if <code>only.diag = TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Zheyuan Li <a href="mailto:zheyuan.li@bath.edu">zheyuan.li@bath.edu</a>
</p>


<h3>References</h3>

<p>Zheyuan Li and Jiguo Cao (2022). General P-splines for non-uniform splines, <a href="https://doi.org/10.48550/arXiv.2201.06808">doi:10.48550/arXiv.2201.06808</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(Matrix)
require(gps)

## 11 domain knots at equal quantiles of Beta(3, 3) distribution
xd &lt;- qbeta(seq.int(0, 1, by = 0.1), 3, 3)
## full knots (with clamped boundary knots) for constructing cubic B-splines
xt &lt;- c(0, 0, 0, xd, 1, 1, 1)

## compute D matrices of order 1 to 3 for O-splines
D.os &lt;- SparseD(xt, d = 4, gps = FALSE)
D1.os &lt;- D.os[[1]]; D2.os &lt;- D.os[[2]]; D3.os &lt;- D.os[[3]]

## get D matrices of order 1 to 3 for general P-splines
## we can of course compute them with D.gps &lt;- SparseD(xt, d = 4, gps = TRUE)
## but they are readily stored in the "sandwich" attribute of 'D.os'
D.gps &lt;- attr(D.os, "sandwich")$D
D1.gps &lt;- D.gps[[1]]; D2.gps &lt;- D.gps[[2]]; D3.gps &lt;- D.gps[[3]]

## we can compute the penalty matrix S = D'D
S.gps &lt;- lapply(D.gps, crossprod)
S1.gps &lt;- S.gps[[1]]; S2.gps &lt;- S.gps[[2]]; S3.gps &lt;- S.gps[[3]]
S.os &lt;- lapply(D.os, crossprod)
S1.os &lt;- S.os[[1]]; S2.os &lt;- S.os[[2]]; S3.os &lt;- S.os[[3]]

## if we want to verify the sandwich formula for O-splines
## extract 'Sbar' matrices stored in the "sandwich" attribute
## and compute the relative error between S and t(D) %*% Sbar %*% D
Sbar &lt;- attr(D.os, "sandwich")$Sbar
Sbar1 &lt;- Sbar[[1]]; Sbar2 &lt;- Sbar[[2]]; Sbar3 &lt;- Sbar[[3]]
range(S1.os - t(D1.gps) %*% Sbar1 %*% D1.gps) / max(abs(S1.os))
range(S2.os - t(D2.gps) %*% Sbar2 %*% D2.gps) / max(abs(S2.os))
range(S3.os - t(D3.gps) %*% Sbar3 %*% D3.gps) / max(abs(S3.os))

## sample B-spline coefficients from their prior distribution
b.gps &lt;- PriorCoef(n = 5, D2.gps)$coef
b.os &lt;- PriorCoef(n = 5, D2.os)$coef
op &lt;- par(mfrow = c(1, 2), mar = c(2, 2, 1.5, 0.5), oma = c(0, 0, 1, 0))
## prior B-spline coefficients with a general difference penalty
matplot(b.gps, type = "l", lty = 1, ann = FALSE)
title("general difference penalty")
## prior B-spline coefficients with a derivative penalty
matplot(b.os, type = "l", lty = 1, ann = FALSE)
title("derivative penalty")
title("random B-spline coefficients from their prior", outer = TRUE)
par(op)

## plot the corresponding cubic splines with these B-spline coefficients
x &lt;- MakeGrid(xd, n = 11)
B &lt;- splines::splineDesign(xt, x, ord = 4, sparse = TRUE)
y.gps &lt;- B %*% b.gps
y.os &lt;- B %*% b.os
op &lt;- par(mfrow = c(1, 2), mar = c(2, 2, 1.5, 0.5), oma = c(0, 0, 1, 0))
matplot(x, y.gps, type = "l", lty = 1, ann = FALSE)
title("general difference penalty")
matplot(x, y.os, type = "l", lty = 1, ann = FALSE)
title("derivative penalty")
title("random cubic splines with prior B-spline coefficients", outer = TRUE)
par(op)
</code></pre>

<hr>
<h2 id='penutils'>
Utility functions for working with wiggliness penalties
</h2><span id='topic+penutils'></span><span id='topic+penalty.utils'></span><span id='topic+penalty.utilities'></span><span id='topic+DiffCoef'></span><span id='topic+btSb'></span>

<h3>Description</h3>

<p>Evaluate <code class="reqn">\|\bm{D\beta}\|^2</code> without using <code class="reqn">\bm{D}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiffCoef(b, xt, d, m)

btSb(b, xt, d, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penutils_+3A_b">b</code></td>
<td>
<p>a vector of B-spline coefficients (<code>length(b) == length(xt) - d</code>).</p>
</td></tr>
<tr><td><code id="penutils_+3A_xt">xt</code></td>
<td>
<p>full knot sequence for ordinary B-splines (<code>length(xt) &gt;= 2 * d</code>).</p>
</td></tr>
<tr><td><code id="penutils_+3A_d">d</code></td>
<td>
<p>B-spline order (<code class="reqn">d \ge 2</code>).</p>
</td></tr>
<tr><td><code id="penutils_+3A_m">m</code></td>
<td>
<p>penalty order (<code class="reqn">1 \le m \le d - 1</code>).</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Implicit Evaluation of the Penalty</h4>

<p>Sometimes we want to evaluate the penalty <code class="reqn">\|\bm{D\beta}\|^2</code> for some <code class="reqn">\bm{\beta}</code>. The obvious way is to do the matrix-vector multiplication <code class="reqn">\bm{D\beta}</code> then compute its <code class="reqn">L_2</code> norm, however, implicit evaluation without using <code class="reqn">\bm{D}</code> is possible. For general P-splines, we can calculate <code class="reqn">\bm{D}_{\textrm{gps}}\bm{\beta}</code> by taking order-<code class="reqn">m</code> general differences between elements of <code class="reqn">\bm{\beta}</code>, and function <code>DiffCoef</code> does this. For O-splines, the evaluation can be more refined. Denote domain knots by <code class="reqn">s_0,\ s_1,\ s_2,\ \ldots,\ s_k,\ s_{k + 1}</code>, where <code class="reqn">(s_j)_1^k</code> are interior knots and <code class="reqn">s_0 = a</code>, <code class="reqn">s_{k + 1} = b</code> are domain endpoints. The derivative penalty adds up local wiggliness measure on each interval: <code class="reqn">\int_a^b f^{(m)}(x)^2\mathrm{d}x = \sum_{j = 0}^k\int_{s_j}^{s_{j + 1}} f^{(m)}(x)^2\mathrm{d}x</code>. Function <code>btSb</code> calculates each integral in the summation and returns those additive components in a vector.
</p>



<h3>Value</h3>

<p><code>DiffCoef</code> (for general P-splines only) returns <code class="reqn">\bm{D}_{\textrm{gps}}\bm{\beta}</code> as a vector.
</p>
<p><code>btSb</code> (for O-splines only) returns a vector with element <code class="reqn">\int_{s_j}^{s_{j + 1}} f^{(m)}(x)^2\mathrm{d}x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(Matrix)
require(gps)

## 11 domain knots at equal quantiles of Beta(3, 3) distribution
xd &lt;- qbeta(seq.int(0, 1, by = 0.1), 3, 3)
## full knots (with clamped boundary knots) for constructing cubic B-splines
xt &lt;- c(0, 0, 0, xd, 1, 1, 1)

## compute 2nd order D matrix for O-splines
D.os &lt;- SparseD(xt, d = 4, m = 2, gps = FALSE)
D2.os &lt;- D.os$order.2

## get 2nd order D matrix for general P-splines
## we can of course compute it with D.gps &lt;- SparseD(xt, d = 4, m = 2, gps = TRUE)
## but it is readily stored in the "sandwich" attribute of 'D.os'
D.gps &lt;- attr(D.os, "sandwich")$D
D2.gps &lt;- D.gps$order.2

## random B-spline coefficients
b &lt;- rnorm(ncol(D2.gps))

## two ways to evaluate a difference penalty
diff.b1 &lt;- DiffCoef(b, xt, d = 4, m = 2)  ## implicit
diff.b2 &lt;- as.numeric(D2.gps %*% b)       ## explicit
range(diff.b1 - diff.b2) / max(abs(diff.b1))

## several ways to evaluate a derivative penalty
sum(btSb(b, xt, d = 4, m = 2))  ## recommended
sum(as.numeric(D2.os %*% b) ^ 2)
S2.os &lt;- crossprod(D2.os); sum(b * as.numeric(S2.os %*% b))
</code></pre>

<hr>
<h2 id='periodic'>
Design matrix and general difference matrices for periodic B-splines
</h2><span id='topic+periodic'></span><span id='topic+pbsDesign'></span><span id='topic+SparsePD'></span>

<h3>Description</h3>

<p>For order-<code class="reqn">d</code> periodic B-splines, <code>pbsDesign</code> evaluates B-splines or their derivatives at given <code class="reqn">x</code>-values, and <code>SparsePD</code> computes general difference matrices of order 1 to <code class="reqn">d - 1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbsDesign(x, xd, d, nDeriv = 0, sparse = FALSE, wrap = TRUE)

SparsePD(xd, d, wrap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="periodic_+3A_x">x</code></td>
<td>
<p><code class="reqn">x</code>-values where periodic B-splines are to be evaluated.</p>
</td></tr>
<tr><td><code id="periodic_+3A_xd">xd</code></td>
<td>
<p>domain knot sequence for periodic B-splines (<code>length(xd) &gt;= d + 1</code>).</p>
</td></tr>
<tr><td><code id="periodic_+3A_d">d</code></td>
<td>
<p>B-spline order (<code class="reqn">d \ge 2</code>).</p>
</td></tr>
<tr><td><code id="periodic_+3A_nderiv">nDeriv</code></td>
<td>
<p>derivative order.</p>
</td></tr>
<tr><td><code id="periodic_+3A_sparse">sparse</code></td>
<td>
<p>if TRUE, create a sparse design matrix of &quot;dgCMatrix&quot; class.</p>
</td></tr>
<tr><td><code id="periodic_+3A_wrap">wrap</code></td>
<td>
<p>if TRUE, the knots wrapping strategy is used; if FALSE, the linear constraint strategy is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions perform type-2 construction, by transforming design matrix and general difference matrices for ordinary B-splines to satisfy periodic boundary constraints (see Details). By contrast, <code>pbsDesign</code> and <code>SparsePD</code> in <span class="pkg">gps</span> perform type-1 construction by basis wrapping.
</p>
<p>A spline <code class="reqn">f(x)</code> on domain <code class="reqn">[a, b]</code> can be constructed to satisfy periodic boundary constraints, that is, <code class="reqn">f^{(q)}(a) = f^{(q)}(b)</code>, <code class="reqn">q</code> = 0, 1, ..., degree - 1. These are actually linear equality constraints
</p>
<p>Unlike ordinary B-splines, period B-splines do not require explicit auxiliary boundary knots for their construction. The magic is that auxiliary boundary knots will be automatically positioned by periodic extension of interior knots.
</p>
<p>Denote the domain knot sequence by <code class="reqn">s_0, s_1, s_2, \ldots, s_k, s_{k + 1}</code>, where <code class="reqn">(s_j)_1^k</code> are interior knots and <code class="reqn">s_0 = a</code>, <code class="reqn">s_{k + 1} = b</code> are domain endpoints. For order-<code class="reqn">d</code> B-splines, we replicate the first <code class="reqn">d - 1</code> interior knots (after adding <code class="reqn">b - a</code>) to the right of <code class="reqn">[a, b]</code> for an augmented set of <code class="reqn">K = k + d + 1</code> knots, which spawns <code class="reqn">p = K - d = k + 1</code> ordinary B-splines. It turns out that periodic B-splines can be obtained by wrapping segments of those ordinary B-splines that stretch beyond <code class="reqn">[a, b]</code> to the start of the domain (a demo is offered by <code><a href="#topic+DemoPBS">DemoPBS</a></code>).
</p>
<p>Note that we must have at least <code class="reqn">d - 1</code> interior knots to do such periodic extension. This means that <code class="reqn">d + 1</code> domain knots are required at a minimum for construction of periodic B-splines.
</p>


<h3>Value</h3>

<p><code>pbsDesign</code> returns a design matrix with <code>length(x)</code> rows and <code>length(xd) - 1</code> columns. <code>SparsePD</code> returns a list of sparse matrices (of &quot;dgCMatrix&quot; class), giving general difference matrices of order 1 to <code class="reqn">d - 1</code>.
</p>


<h3>Author(s)</h3>

<p>Zheyuan Li <a href="mailto:zheyuan.li@bath.edu">zheyuan.li@bath.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(gps)

## 5 domain knots: three interior knots 0.5, 1.5 and 1.8 in domain [0, 3]
xd &lt;- c(0, 0.5, 1.5, 1.8, 3)

## make a grid
x &lt;- MakeGrid(xd, n = 10)

## construct periodic cubic B-splines
PB1 &lt;- pbsDesign(x, xd, d = 4, wrap = TRUE)
PB2 &lt;- pbsDesign(x, xd, d = 4, wrap = FALSE)

## construct general difference matrices of order 1 to 3
SparsePD(xd, d = 4, wrap = TRUE)
SparsePD(xd, d = 4, wrap = FALSE)
</code></pre>

<hr>
<h2 id='PlaceKnots'>
Automatically place knots according to data
</h2><span id='topic+PlaceKnots'></span>

<h3>Description</h3>

<p>Place knots for ordinary B-splines or periodic B-splines using automatic strategies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlaceKnots(x, d, k, domain = NULL, uniform = FALSE, periodic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlaceKnots_+3A_x">x</code></td>
<td>
<p>observed <code class="reqn">x</code>-values.</p>
</td></tr>
<tr><td><code id="PlaceKnots_+3A_d">d</code></td>
<td>
<p>B-spline order.</p>
</td></tr>
<tr><td><code id="PlaceKnots_+3A_k">k</code></td>
<td>
<p>number of interior knots.</p>
</td></tr>
<tr><td><code id="PlaceKnots_+3A_domain">domain</code></td>
<td>
<p>a vector of two values giving domain interval <code class="reqn">[a, b]</code>. Will use <code>min(x)</code> and <code>max(x)</code> if not specified.</p>
</td></tr>
<tr><td><code id="PlaceKnots_+3A_uniform">uniform</code></td>
<td>
<p>if TRUE, place equidistant knots; if FALSE, place quantile knots with clamped boundary knots.</p>
</td></tr>
<tr><td><code id="PlaceKnots_+3A_periodic">periodic</code></td>
<td>
<p>if TRUE, return the domain knot sequence that is sufficient for constructing periodic B-splines (see <code><a href="#topic+pbsDesign">pbsDesign</a></code>); if FALSE, return the full knot sequence that is required for constructing ordinary B-splines.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of <code class="reqn">K = k + 2d</code> knots for ordinary B-splines, or <code class="reqn">k + 2</code> knots for periodic B-splines.
</p>


<h3>Author(s)</h3>

<p>Zheyuan Li <a href="mailto:zheyuan.li@bath.edu">zheyuan.li@bath.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(gps)

x &lt;- rnorm(50)

## uniform knots for uniform cubic B-splines
xt1 &lt;- PlaceKnots(x, d = 4, k = 5, uniform = TRUE)
B1 &lt;- splines::splineDesign(xt1, x, ord = 4)

## clamped quantile knots for clamped non-uniform cubic B-splines
xt2 &lt;- PlaceKnots(x, d = 4, k = 5, uniform = FALSE)
B2 &lt;- splines::splineDesign(xt2, x, ord = 4)

## uniform knots for uniform periodic cubic B-splines
xd1 &lt;- PlaceKnots(x, d = 4, k = 5, uniform = TRUE, periodic = TRUE)
PB1 &lt;- pbsDesign(x, xd1, d = 4)

## quantile knots for non-uniform periodic cubic B-splines
xd2 &lt;- PlaceKnots(x, d = 4, k = 5, uniform = FALSE, periodic = TRUE)
PB2 &lt;- pbsDesign(x, xd2, d = 4)
</code></pre>

<hr>
<h2 id='rspl'>
Simulate random cubic splines
</h2><span id='topic+rspl'></span><span id='topic+random.splines'></span>

<h3>Description</h3>

<p>Simulate random cubic splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rspl(x, domain = NULL, n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rspl_+3A_x">x</code></td>
<td>
<p><code class="reqn">x</code>-values where simulated cubic splines are evaluated.</p>
</td></tr>
<tr><td><code id="rspl_+3A_domain">domain</code></td>
<td>
<p>a vector of two values giving domain interval <code class="reqn">[a, b]</code>. Will use <code>min(x)</code> and <code>max(x)</code> if not specified.</p>
</td></tr>
<tr><td><code id="rspl_+3A_n">n</code></td>
<td>
<p>number of replicates to simulate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of four components:
</p>

<ul>
<li> <p><code>y</code> is a vector of random cubic spline values evaluated at <code>x</code> when <code>n = 1</code>, or a matrix of <code>n</code> columns when <code>n &gt; 1</code>, where each column is an independent replicate of random cubic splines;
</p>
</li>
<li> <p><code>b</code> is a vector of random B-spline coefficients when <code>n = 1</code>, or a matrix of <code>n</code> columns when <code>n &gt; 1</code>, where each column is an independent replicate of random B-spline coefficients;
</p>
</li>
<li> <p><code>xt</code> is the full knot sequence for B-splines;
</p>
</li>
<li> <p><code>domain</code> gives the domain of the simulated spline(s).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Zheyuan Li <a href="mailto:zheyuan.li@bath.edu">zheyuan.li@bath.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(gps)

x &lt;- seq.int(0, 1, 0.01)

## a random cubic spline
y &lt;- rspl(x, n = 1)$y
op &lt;- par(mar = c(2, 2, 1.5, 0.5))
plot(x, y, type = "l", ann = FALSE)
title("a random cubic spline")
par(op)

## 5 random cubic splines
Y &lt;- rspl(x, n = 5)$y
op &lt;- par(mar = c(2, 2, 1.5, 0.5))
matplot(x, Y, type = "l", lty = 1, ylab = "y")
title("5 random cubic splines")
par(op)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
