<!DOCTYPE html><html><head><title>Help for package RCTS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RCTS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adapt_pic_with_sigma2maxmodel'><p>Adapts the object that contains PIC for all candidate C's and all subsamples with sigma2_max_model.</p></a></li>
<li><a href='#adapt_X_estimating_less_variables'><p>When running the algorithm with a different number of observable variables then the number that is available, reformat X. (Mainly used for testing)</p></a></li>
<li><a href='#add_configuration'><p>Adds the current configuration (number of groups and factors) to df_results.</p></a></li>
<li><a href='#add_metrics'><p>Adds several metrics to df_results.</p></a></li>
<li><a href='#add_pic'><p>Fills in df_pic: adds a row with the calculated PIC for the current configuration.</p></a></li>
<li><a href='#add_pic_parallel'><p>Calculates the PIC for the current configuration.</p></a></li>
<li><a href='#beta_true_heterogroups'><p>Helpfunction in create_true_beta() for the option beta_true_heterogeneous_groups. (This is the default option.)</p></a></li>
<li><a href='#calculate_best_config'><p>Function that returns for each candidate C the best number of groups and factors, based on the PIC.</p></a></li>
<li><a href='#calculate_error_term'><p>Calculates the error term Y - X*beta_est - LF - LgFg.</p></a></li>
<li><a href='#calculate_errors_virtual_groups'><p>Helpfunction for update_g(). Calculates the errors for one of the possible groups time series can be placed in.</p></a></li>
<li><a href='#calculate_FL_group_estimated'><p>Returns the estimated groupfactorstructure.</p></a></li>
<li><a href='#calculate_FL_group_true'><p>Calculate the true groupfactorstructure.</p></a></li>
<li><a href='#calculate_lambda'><p>calculates factor loadings of common factors</p></a></li>
<li><a href='#calculate_lambda_group'><p>calculates factor loadings of groupfactors</p></a></li>
<li><a href='#calculate_lgfg'><p>Calculates the group factor structure: the matrix product of the group factors and their loadings.</p></a></li>
<li><a href='#calculate_obj_for_g'><p>Calculates objective function for individual i and group k in order to estimate group membership.</p></a></li>
<li><a href='#calculate_PIC'><p>Function to determine PIC (panel information criterium)</p></a></li>
<li><a href='#calculate_PIC_term1'><p>Function to calculate the first term of PIC (panel information criterium)</p></a></li>
<li><a href='#calculate_sigma2'><p>Calculates sum of squared errors, divided by NT</p></a></li>
<li><a href='#calculate_sigma2maxmodel'><p>Calculates sigma2maxmodel</p></a></li>
<li><a href='#calculate_TN_factor'><p>Helpfunction. Calculates part of the 4th term of the PIC.</p></a></li>
<li><a href='#calculate_VCsquared'><p>Calculates VCÂ², to determine the stability of the found number of groups and factors over the subsamples.</p></a></li>
<li><a href='#calculate_virtual_factor_and_lambda_group'><p>Helpfunction used in update_g()</p></a></li>
<li><a href='#calculate_W'><p>Calculates W = Y - X*beta_est. It is used in the initialization step of the algorithm, to initialise the factorstructures.</p></a></li>
<li><a href='#calculate_XB_estimated'><p>Calculates (the estimated value of) the matrix X*beta_est.</p></a></li>
<li><a href='#calculate_XB_true'><p>Calculates the product of X*beta_true .</p></a></li>
<li><a href='#calculate_Z_common'><p>Calculates Z = Y - X*beta_est - LgFg. It is used in the estimate of the common factorstructure.</p></a></li>
<li><a href='#calculate_Z_group'><p>Calculates Z = Y - X*beta_est - LF. It is used to estimate the groupfactorstructure.</p></a></li>
<li><a href='#check_stopping_rules'><p>Checks the rules for stopping the algorithm, based on its convergence speed.</p></a></li>
<li><a href='#clustering_with_robust_distances'><p>Function that puts individuals in a separate &quot;class zero&quot;, when their distance to all possible groups is bigger then a certain threshold.</p></a></li>
<li><a href='#create_covMat_crosssectional_dependence'><p>Function used in generating simulated data with non normal errors.</p></a></li>
<li><a href='#create_data_dgp2'><p>Creates an instance of DGP 2, as defined in Boudt and Heyndels (2022).</p></a></li>
<li><a href='#create_true_beta'><p>Creates beta_true, which contains the true values of beta (= the coefficients of X)</p></a></li>
<li><a href='#define_C_candidates'><p>Defines the candidate values for C.</p></a></li>
<li><a href='#define_configurations'><p>Constructs dataframe where the rows contains all configurations that are included and for which the estimators will be estimated.</p></a></li>
<li><a href='#define_kg_candidates'><p>Defines the set of combinations of group specific factors.</p></a></li>
<li><a href='#define_number_subsets'><p>Returns a vector with the indices of the subsets. Must start with zero.</p></a></li>
<li><a href='#define_object_for_initial_clustering_macropca'><p>Defines the object that will be used to define a initial clustering.</p></a></li>
<li><a href='#define_rho_parameters'><p>Determines parameters of rho-function.</p></a></li>
<li><a href='#determine_beta'><p>Helpfunction in estimate_beta() for estimating beta_est.</p></a></li>
<li><a href='#determine_robust_lambda'><p>Help-function for return_robust_lambdaobject().</p></a></li>
<li><a href='#df_results_example'><p>An example for df_results. This dataframe contains the estimators for each configuration.</p></a></li>
<li><a href='#do_we_estimate_common_factors'><p>Helpfunction to shorten code: are common factors being estimated.</p></a></li>
<li><a href='#do_we_estimate_group_factors'><p>Helpfunction to shorten code: are group factors being estimated.</p></a></li>
<li><a href='#estimate_algorithm'><p>This function is a wrapper around the initialization and the estimation part of the algorithm, for one configuration. It is only used for the serialized algorithm.</p></a></li>
<li><a href='#estimate_beta'><p>Estimates beta.</p></a></li>
<li><a href='#estimate_factor'><p>Estimates common factor(s) F.</p></a></li>
<li><a href='#estimate_factor_group'><p>Estimates group factors Fg.</p></a></li>
<li><a href='#evade_crashes_macropca'><p>Solves a very specific issue with MacroPCA.</p></a></li>
<li><a href='#evade_floating_point_errors'><p>Function to evade floating point errors.</p></a></li>
<li><a href='#factor_group_true_dgp3'><p>factor_group_true_dgp3 contains the values of the true group factors on which Y_dgp3 is based</p></a></li>
<li><a href='#fill_rc'><p>Fills in the optimized number of common factors for each C.</p></a></li>
<li><a href='#fill_rcj'><p>Fills in the optimized number of groups and group specific factors for each C.</p></a></li>
<li><a href='#final_estimations_filter_kg'><p>Filters dataframe on the requested group specific factors configuration.</p></a></li>
<li><a href='#g_true_dgp3'><p>g_true_dgp3 contains the true group memberships of the elements of Y_dgp3</p></a></li>
<li><a href='#generate_grouped_factorstructure'><p>Generates the true groupfactorstructure, to use in simulations.</p></a></li>
<li><a href='#generate_Y'><p>Generate panel data Y for simulations.</p></a></li>
<li><a href='#get_best_configuration'><p>Finds the first stable interval after the first unstable point. It then defines the value for C for the begin, middle and end of this interval.</p></a></li>
<li><a href='#get_convergence_speed'><p>Defines the convergence speed.</p></a></li>
<li><a href='#get_final_estimation'><p>Function that returns the final clustering, based on the estimated number of groups and common and group specific factors.</p></a></li>
<li><a href='#grid_add_variables'><p>Function which is used to have a dataframe (called &quot;grid&quot;) with data (individualindex, timeindex, XT and LF) available.</p></a></li>
<li><a href='#handle_macropca_errors'><p>Helpfunction in robustpca().</p></a></li>
<li><a href='#handleNA'><p>Function with as input a dataframe. (this will be &quot;Y&quot; or &quot;to_divide&quot;) It filters out rows with NA.</p></a></li>
<li><a href='#handleNA_LG'><p>Removes NA's in LG (in function calculate_virtual_factor_and_lambda_group() )</p></a></li>
<li><a href='#initialise_beta'><p>Initialisation of estimation of beta (the coefficients with the observable variables)</p></a></li>
<li><a href='#initialise_clustering'><p>Function that clusters time series in a dataframe with kmeans.</p></a></li>
<li><a href='#initialise_commonfactorstructure_macropca'><p>Initialises the estimation of the common factors and their loadings.</p></a></li>
<li><a href='#initialise_df_pic'><p>Initialises a dataframe which will contain the PIC for each configuration and for each value of C.</p></a></li>
<li><a href='#initialise_df_results'><p>Initialises a dataframe that will contain an overview of metrics for each estimated configuration (for example adjusted randindex).</p></a></li>
<li><a href='#initialise_rc'><p>Initialises rc.</p></a></li>
<li><a href='#initialise_rcj'><p>Initialises rcj.</p></a></li>
<li><a href='#initialise_X'><p>Creates X (the observable variables) to use in simulations.</p></a></li>
<li><a href='#iterate'><p>Wrapper around estimate_beta(), update_g(), and estimating the factorstructures.</p></a></li>
<li><a href='#kg_candidates_expand'><p>Function that returns the set of combinations of groupfactors for which the algorithm needs to run.</p></a></li>
<li><a href='#lambda_group_true_dgp3'><p>lambda_group_true_dgp3 contains the values of the loadings to the group factors on which Y_dgp3 is based</p></a></li>
<li><a href='#LMROB'><p>Wrapper around lmrob.</p></a></li>
<li><a href='#make_df_pic_parallel'><p>Makes a dataframe with the PIC for each configuration and each candidate C.</p></a></li>
<li><a href='#make_df_results_parallel'><p>Makes a dataframe with information on each configuration.</p></a></li>
<li><a href='#make_subsamples'><p>Selects a subsample of the time series, and of the length of the time series.</p>
Based on this it returns a list with a subsample of Y, the corresponding subsample of X and of the true group membership and factorstructures if applicable.</a></li>
<li><a href='#matrixnorm'><p>Function to calculate the norm of a matrix.</p></a></li>
<li><a href='#OF_vectorized_helpfunction3'><p>Helpfunction in OF_vectorized3()</p></a></li>
<li><a href='#OF_vectorized3'><p>Calculates objective function for the classical algorithm: used in iterate() and in local_search.</p></a></li>
<li><a href='#parallel_algorithm'><p>Wrapper of the loop over the subsets which in turn use the parallelised algorithm.</p></a></li>
<li><a href='#plot_VCsquared'><p>Plots expression(VC^2) along with the corresponding number of groups (orange), common factors (darkblue) and group factors of the first group (lightblue).</p></a></li>
<li><a href='#prepare_for_robpca'><p>Helpfunction: prepares object to perform robust PCA on.</p></a></li>
<li><a href='#RCTS'><p>RCTS</p></a></li>
<li><a href='#reassign_if_empty_groups'><p>Randomly reassign individual(s) if there are empty groups. This can happen if the total number of time series is low compared to the number of desired groups.</p></a></li>
<li><a href='#restructure_X_to_order_slowN_fastT'><p>Restructures X (which is an 3D-array of dimensions (N,T,p) to a 2D-matrix of dimension (NxT,p).</p></a></li>
<li><a href='#return_robust_lambdaobject'><p>Calculates robust loadings</p></a></li>
<li><a href='#robustpca'><p>Function that uses robust PCA and estimates robust factors and loadings.</p></a></li>
<li><a href='#run_config'><p>Wrapper around the non-parallel algorithm, to estimate beta, group membership and the factorstructures.</p></a></li>
<li><a href='#scaling_X'><p>Scaling of X.</p></a></li>
<li><a href='#solveFG'><p>Helpfunction in update_g(), to calculate solve(FG x t(FG)) x FG</p></a></li>
<li><a href='#tabulate_potential_C'><p>Shows the configurations for potential C's of the first stable interval (beginpoint, middlepoint and endpoint)</p></a></li>
<li><a href='#update_g'><p>Function that estimates group membership.</p></a></li>
<li><a href='#X_dgp3'><p>The dataset X_dgp3 contains the values of the 3 observable variables on which Y_dgp3 is based.</p></a></li>
<li><a href='#Y_dgp3'><p>Y_dgp3 contains a simulated dataset for DGP 3.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Clustering Time Series While Resisting Outliers</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Robust Clustering of Time Series (RCTS) has the functionality to cluster time series using both the classical and the robust interactive fixed effects framework. 
  The classical framework is developed in Ando &amp; Bai (2017) &lt;<a href="https://doi.org/10.1080%2F01621459.2016.1195743">doi:10.1080/01621459.2016.1195743</a>&gt;. The implementation within this package excludes the SCAD-penalty on the estimations of beta. 
  This robust framework is developed in Boudt &amp; Heyndels (2022) &lt;<a href="https://doi.org/10.1016%2Fj.ecosta.2022.01.002">doi:10.1016/j.ecosta.2022.01.002</a>&gt; and is made robust against different kinds of outliers.
  The algorithm iteratively updates beta (the coefficients of the observable variables), group membership, and the latent factors (which can be common and/or group-specific) along
  with their loadings. The number of groups and factors can be estimated if they are unknown.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, magrittr, dplyr, purrr, stringr, tidyr, tibble,
ggplot2, ncvreg, robustbase, cellWise, rlang, Rdpack</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tsqn, doParallel, doSNOW, foreach, mclust, Matrix</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-18 14:05:51 UTC; hewoud</td>
</tr>
<tr>
<td>Author:</td>
<td>Ewoud Heyndels <a href="https://orcid.org/0000-0003-4540-8571"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ewoud Heyndels &lt;ewoud.heyndels@vub.be&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-18 14:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adapt_pic_with_sigma2maxmodel'>Adapts the object that contains PIC for all candidate C's and all subsamples with sigma2_max_model.</h2><span id='topic+adapt_pic_with_sigma2maxmodel'></span>

<h3>Description</h3>

<p>The PIC is calculated with a sigma2 specific to the configuration (= number of groups and factors).
Because the method to estimate the number of groups and factors requires sigma2 to be equal over all configurations
(see proofs of different papers of Ando/Bai) we replace sigma2
by the sigma2 of the configuration with maximum number of groups and factors (this is the last one that was executed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adapt_pic_with_sigma2maxmodel(df, df_results, sigma2_max_model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adapt_pic_with_sigma2maxmodel_+3A_df">df</code></td>
<td>
<p>contains PIC for all candidate C's and all subsamples</p>
</td></tr>
<tr><td><code id="adapt_pic_with_sigma2maxmodel_+3A_df_results">df_results</code></td>
<td>
<p>dataframe with results for each estimated configuration</p>
</td></tr>
<tr><td><code id="adapt_pic_with_sigma2maxmodel_+3A_sigma2_max_model">sigma2_max_model</code></td>
<td>
<p>sigma2 of model with maximum number of groups and factors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame of same size as df
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
df_pic &lt;- data.frame(matrix(rnorm(4 * 50), nrow = 4)) #4 configuration / 50 candidate values for C
df_results &lt;- data.frame(sigma2 = rnorm(4))
pic_sigma2 &lt;- 3.945505
adapt_pic_with_sigma2maxmodel(df_pic, df_results, pic_sigma2)
</code></pre>

<hr>
<h2 id='adapt_X_estimating_less_variables'>When running the algorithm with a different number of observable variables then the number that is available, reformat X. (Mainly used for testing)</h2><span id='topic+adapt_X_estimating_less_variables'></span>

<h3>Description</h3>

<p>When running the algorithm with a different number of observable variables then the number that is available, reformat X. (Mainly used for testing)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adapt_X_estimating_less_variables(X, vars_est)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adapt_X_estimating_less_variables_+3A_x">X</code></td>
<td>
<p>dataframe with the observed variables</p>
</td></tr>
<tr><td><code id="adapt_X_estimating_less_variables_+3A_vars_est">vars_est</code></td>
<td>
<p>number of available observed variables for which a coefficient will be estimated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 3D-array. If vars_est is set to 0, it returns NA.
</p>

<hr>
<h2 id='add_configuration'>Adds the current configuration (number of groups and factors) to df_results.</h2><span id='topic+add_configuration'></span>

<h3>Description</h3>

<p>Adds the current configuration (number of groups and factors) to df_results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_configuration(df_results, S, k, kg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_configuration_+3A_df_results">df_results</code></td>
<td>
<p>dataframe with results for each estimated configuration</p>
</td></tr>
<tr><td><code id="add_configuration_+3A_s">S</code></td>
<td>
<p>estimated number of groups in current configuration</p>
</td></tr>
<tr><td><code id="add_configuration_+3A_k">k</code></td>
<td>
<p>estimated number of common factors in current configuration</p>
</td></tr>
<tr><td><code id="add_configuration_+3A_kg">kg</code></td>
<td>
<p>vector with the estimated number of group specific factors in current configuration (augmented with NA's to reach a length of 20)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>add_configuration(initialise_df_results(TRUE), 3, 0, c(3, 3, 3, rep(NA, 17)))
</code></pre>

<hr>
<h2 id='add_metrics'>Adds several metrics to df_results.</h2><span id='topic+add_metrics'></span>

<h3>Description</h3>

<p>Adds several metrics to df_results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_metrics(
  df_results,
  index_configuration,
  pic_sigma2,
  beta_est,
  g,
  comfactor,
  lambda,
  factor_group,
  lambda_group,
  iteration,
  g_true = NA,
  add_rand = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_metrics_+3A_df_results">df_results</code></td>
<td>
<p>dataframe with results for each estimated configuration</p>
</td></tr>
<tr><td><code id="add_metrics_+3A_index_configuration">index_configuration</code></td>
<td>
<p>index of the configuration of groups and factors</p>
</td></tr>
<tr><td><code id="add_metrics_+3A_pic_sigma2">pic_sigma2</code></td>
<td>
<p>sum of squared errors divided by NT</p>
</td></tr>
<tr><td><code id="add_metrics_+3A_beta_est">beta_est</code></td>
<td>
<p>estimated values of beta</p>
</td></tr>
<tr><td><code id="add_metrics_+3A_g">g</code></td>
<td>
<p>Vector with estimated group membership for all individuals</p>
</td></tr>
<tr><td><code id="add_metrics_+3A_comfactor">comfactor</code></td>
<td>
<p>estimated common factors</p>
</td></tr>
<tr><td><code id="add_metrics_+3A_lambda">lambda</code></td>
<td>
<p>loadings of the estimated common factors</p>
</td></tr>
<tr><td><code id="add_metrics_+3A_factor_group">factor_group</code></td>
<td>
<p>estimated group specific factors</p>
</td></tr>
<tr><td><code id="add_metrics_+3A_lambda_group">lambda_group</code></td>
<td>
<p>loadings of the estimated group specific factors</p>
</td></tr>
<tr><td><code id="add_metrics_+3A_iteration">iteration</code></td>
<td>
<p>number of iteration</p>
</td></tr>
<tr><td><code id="add_metrics_+3A_g_true">g_true</code></td>
<td>
<p>vector of length NN with true group memberships</p>
</td></tr>
<tr><td><code id="add_metrics_+3A_add_rand">add_rand</code></td>
<td>
<p>adds the adjusted randindex to the df (requires the mclust package); used for simulations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with final estimations of each configuration
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df_results &lt;- add_configuration(initialise_df_results(TRUE),
  3, 0, c(3, 3, 3, rep(NA, 17))) #data.frame with one configuration
add_metrics(df_results, 1, 3.94, NA, round(runif(30, 1, 3)), NA, NA, NA, NA, 9)
</code></pre>

<hr>
<h2 id='add_pic'>Fills in df_pic: adds a row with the calculated PIC for the current configuration.</h2><span id='topic+add_pic'></span>

<h3>Description</h3>

<p>Fills in df_pic: adds a row with the calculated PIC for the current configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_pic(
  df,
  index_configuration,
  robust,
  Y,
  beta_est,
  g,
  S,
  k,
  kg,
  est_errors,
  C_candidates,
  method_estimate_beta = "individual",
  choice_pic = "pic2017"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_pic_+3A_df">df</code></td>
<td>
<p>input data frame</p>
</td></tr>
<tr><td><code id="add_pic_+3A_index_configuration">index_configuration</code></td>
<td>
<p>index of the configuration of groups and factors</p>
</td></tr>
<tr><td><code id="add_pic_+3A_robust">robust</code></td>
<td>
<p>robust or classical estimation</p>
</td></tr>
<tr><td><code id="add_pic_+3A_y">Y</code></td>
<td>
<p>Y: NxT dataframe with the panel data of interest</p>
</td></tr>
<tr><td><code id="add_pic_+3A_beta_est">beta_est</code></td>
<td>
<p>estimated values of beta</p>
</td></tr>
<tr><td><code id="add_pic_+3A_g">g</code></td>
<td>
<p>Vector with estimated group membership for all individuals</p>
</td></tr>
<tr><td><code id="add_pic_+3A_s">S</code></td>
<td>
<p>number of estimated groups</p>
</td></tr>
<tr><td><code id="add_pic_+3A_k">k</code></td>
<td>
<p>estimated number of common factors</p>
</td></tr>
<tr><td><code id="add_pic_+3A_kg">kg</code></td>
<td>
<p>vector with the estimated number of group specific factors for each group</p>
</td></tr>
<tr><td><code id="add_pic_+3A_est_errors">est_errors</code></td>
<td>
<p>NxT matrix with the error terms</p>
</td></tr>
<tr><td><code id="add_pic_+3A_c_candidates">C_candidates</code></td>
<td>
<p>candidates for C (parameter in PIC)</p>
</td></tr>
<tr><td><code id="add_pic_+3A_method_estimate_beta">method_estimate_beta</code></td>
<td>
<p>defines how beta is estimated. Default case is an estimated beta for each individual. Default value is &quot;individual.&quot; Possible values are &quot;homogeneous&quot;, &quot;group&quot; or &quot;individual&quot;.</p>
</td></tr>
<tr><td><code id="add_pic_+3A_choice_pic">choice_pic</code></td>
<td>
<p>parameter that defines which PIC is used to select the best configuration of groups and factors.
Options are &quot;pic2017&quot; (uses the PIC of Ando and Bai (2017)),
&quot;pic2016&quot; (Ando and Bai (2016)) weighs the fourth term with an extra factor relative to the size of the groups, and &quot;pic2022&quot;.
They differ in the penalty they perform on the number of group specific factors (and implicitly on the number of groups). They also differ in the sense that they have
different NT-regions (where N is the number of time series and T is the length of the time series) where the estimated number of groups, and thus group specific factors will be wrong.
Pic2022 is designed to shrink the problematic NT-region to very large N / very small T).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
original_data &lt;- create_data_dgp2(30, 10)
Y &lt;- original_data[[1]]
g &lt;- original_data[[3]]
beta_est &lt;- matrix(rnorm(4 * nrow(Y)), nrow = 4)
df_pic &lt;- initialise_df_pic(1:5)
e &lt;- matrix(rnorm(nrow(Y) * ncol(Y)), nrow(Y))
add_pic(df_pic, 1, TRUE, Y, beta_est, g, 3, 0, c(3, 3, 3), e, 1:5)
</code></pre>

<hr>
<h2 id='add_pic_parallel'>Calculates the PIC for the current configuration.</h2><span id='topic+add_pic_parallel'></span>

<h3>Description</h3>

<p>Calculates the PIC for the current configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_pic_parallel(
  Y,
  beta_est,
  g,
  S,
  k,
  kg,
  robust,
  est_errors,
  C_candidates,
  choice_pic,
  method_estimate_beta = "individual"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_pic_parallel_+3A_y">Y</code></td>
<td>
<p>Y: NxT dataframe with the panel data of interest</p>
</td></tr>
<tr><td><code id="add_pic_parallel_+3A_beta_est">beta_est</code></td>
<td>
<p>estimated values of beta</p>
</td></tr>
<tr><td><code id="add_pic_parallel_+3A_g">g</code></td>
<td>
<p>Vector with estimated group membership for all individuals</p>
</td></tr>
<tr><td><code id="add_pic_parallel_+3A_s">S</code></td>
<td>
<p>number of estimated groups</p>
</td></tr>
<tr><td><code id="add_pic_parallel_+3A_k">k</code></td>
<td>
<p>estimated number of common factors</p>
</td></tr>
<tr><td><code id="add_pic_parallel_+3A_kg">kg</code></td>
<td>
<p>vector with the estimated number of group specific factors for each group</p>
</td></tr>
<tr><td><code id="add_pic_parallel_+3A_robust">robust</code></td>
<td>
<p>robust or classical estimation</p>
</td></tr>
<tr><td><code id="add_pic_parallel_+3A_est_errors">est_errors</code></td>
<td>
<p>NxT matrix with the error terms</p>
</td></tr>
<tr><td><code id="add_pic_parallel_+3A_c_candidates">C_candidates</code></td>
<td>
<p>candidates for C (parameter in PIC)</p>
</td></tr>
<tr><td><code id="add_pic_parallel_+3A_choice_pic">choice_pic</code></td>
<td>
<p>parameter that defines which PIC is used to select the best configuration of groups and factors.
Options are &quot;pic2017&quot; (uses the PIC of Ando and Bai (2017)),
&quot;pic2016&quot; (Ando and Bai (2016)) weighs the fourth term with an extra factor relative to the size of the groups, and &quot;pic2022&quot;.
They differ in the penalty they perform on the number of group specific factors (and implicitly on the number of groups). They also differ in the sense that they have
different NT-regions (where N is the number of time series and T is the length of the time series) where the estimated number of groups, and thus group specific factors will be wrong.
Pic2022 is designed to shrink the problematic NT-region to very large N / very small T).</p>
</td></tr>
<tr><td><code id="add_pic_parallel_+3A_method_estimate_beta">method_estimate_beta</code></td>
<td>
<p>defines how beta is estimated. Default case is an estimated beta for each individual. Default value is &quot;individual.&quot; Possible values are &quot;homogeneous&quot;, &quot;group&quot; or &quot;individual&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with a value for each candidate C
</p>

<hr>
<h2 id='beta_true_heterogroups'>Helpfunction in create_true_beta() for the option beta_true_heterogeneous_groups. (This is the default option.)</h2><span id='topic+beta_true_heterogroups'></span>

<h3>Description</h3>

<p>Helpfunction in create_true_beta() for the option beta_true_heterogeneous_groups. (This is the default option.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta_true_heterogroups(
  vars,
  S_true,
  extra_beta_factor = 1,
  limit_true_groups = 12
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta_true_heterogroups_+3A_vars">vars</code></td>
<td>
<p>number of observable variables</p>
</td></tr>
<tr><td><code id="beta_true_heterogroups_+3A_s_true">S_true</code></td>
<td>
<p>true number of groups: should be at least 1 and maximum limit_true_groups</p>
</td></tr>
<tr><td><code id="beta_true_heterogroups_+3A_extra_beta_factor">extra_beta_factor</code></td>
<td>
<p>option to multiply the coefficients in true beta; default = 1</p>
</td></tr>
<tr><td><code id="beta_true_heterogroups_+3A_limit_true_groups">limit_true_groups</code></td>
<td>
<p>Maximum number of true groups in a simulation-DGP for which the code in this package is implemented. Currently equals 12. For application on realworld data this parameter is not relevant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix where the number of rows equals S_true, and the number of columns equals max(1, vars)
</p>

<hr>
<h2 id='calculate_best_config'>Function that returns for each candidate C the best number of groups and factors, based on the PIC.</h2><span id='topic+calculate_best_config'></span>

<h3>Description</h3>

<p>Function that returns for each candidate C the best number of groups and factors, based on the PIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_best_config(df_results, df_pic, C_candidates, limit_est_groups = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_best_config_+3A_df_results">df_results</code></td>
<td>
<p>dataframe with results for each estimated configuration</p>
</td></tr>
<tr><td><code id="calculate_best_config_+3A_df_pic">df_pic</code></td>
<td>
<p>dataframe with the PIC for each configuration and for each candidate C</p>
</td></tr>
<tr><td><code id="calculate_best_config_+3A_c_candidates">C_candidates</code></td>
<td>
<p>candidates for C (parameter in PIC)</p>
</td></tr>
<tr><td><code id="calculate_best_config_+3A_limit_est_groups">limit_est_groups</code></td>
<td>
<p>maximum allowed number of groups that can be estimated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with a row for each candidate value for C.
The first column contains the optimized number of groups (for each candidate C).
The second columns does the same for the number of common factors.
Column 3 until 22 do the same for the number of group specific factors. This is set to NA if the configuration has less than 20 groups estimated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df_results &lt;- add_configuration(initialise_df_results(TRUE),
  3, 0, c(3, 3, 3, rep(NA, 17))) #data.frame with one configuration
calculate_best_config(df_results, data.frame(t(1:5)), 1:5)
</code></pre>

<hr>
<h2 id='calculate_error_term'>Calculates the error term Y - X*beta_est - LF - LgFg.</h2><span id='topic+calculate_error_term'></span>

<h3>Description</h3>

<p>Calculates the error term Y - X*beta_est - LF - LgFg.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_error_term(
  Y,
  X,
  beta_est,
  g,
  factor_group,
  lambda_group,
  comfactor,
  lambda,
  S,
  k,
  kg,
  method_estimate_beta = "individual",
  no_common_factorstructure = FALSE,
  no_group_factorstructure = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_error_term_+3A_y">Y</code></td>
<td>
<p>Y: NxT dataframe with the panel data of interest</p>
</td></tr>
<tr><td><code id="calculate_error_term_+3A_x">X</code></td>
<td>
<p>X: NxTxp array containing the observable variables</p>
</td></tr>
<tr><td><code id="calculate_error_term_+3A_beta_est">beta_est</code></td>
<td>
<p>estimated values of beta</p>
</td></tr>
<tr><td><code id="calculate_error_term_+3A_g">g</code></td>
<td>
<p>Vector with estimated group membership for all individuals</p>
</td></tr>
<tr><td><code id="calculate_error_term_+3A_factor_group">factor_group</code></td>
<td>
<p>estimated group specific factors</p>
</td></tr>
<tr><td><code id="calculate_error_term_+3A_lambda_group">lambda_group</code></td>
<td>
<p>loadings of the estimated group specific factors</p>
</td></tr>
<tr><td><code id="calculate_error_term_+3A_comfactor">comfactor</code></td>
<td>
<p>estimated common factors</p>
</td></tr>
<tr><td><code id="calculate_error_term_+3A_lambda">lambda</code></td>
<td>
<p>loadings of the estimated common factors</p>
</td></tr>
<tr><td><code id="calculate_error_term_+3A_s">S</code></td>
<td>
<p>number of estimated groups</p>
</td></tr>
<tr><td><code id="calculate_error_term_+3A_k">k</code></td>
<td>
<p>number of common factors to be estimated</p>
</td></tr>
<tr><td><code id="calculate_error_term_+3A_kg">kg</code></td>
<td>
<p>number of group specific factors to be estimated</p>
</td></tr>
<tr><td><code id="calculate_error_term_+3A_method_estimate_beta">method_estimate_beta</code></td>
<td>
<p>defines how beta is estimated. Default case is an estimated beta for each individual. Default value is &quot;individual.&quot; Possible values are &quot;homogeneous&quot;, &quot;group&quot; or &quot;individual&quot;.</p>
</td></tr>
<tr><td><code id="calculate_error_term_+3A_no_common_factorstructure">no_common_factorstructure</code></td>
<td>
<p>if there is a common factorstructure being estimated</p>
</td></tr>
<tr><td><code id="calculate_error_term_+3A_no_group_factorstructure">no_group_factorstructure</code></td>
<td>
<p>if there is a group factorstructure being estimated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NxT matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- X_dgp3
Y &lt;- Y_dgp3
# Set estimations for group factors and its loadings, and group membership
#  to the true value for this example.
lambda_group &lt;- lambda_group_true_dgp3
factor_group &lt;- factor_group_true_dgp3
g &lt;- g_true_dgp3
set.seed(1)
beta_est &lt;- matrix(rnorm(nrow(Y) * 4), ncol = nrow(Y)) #random values for beta
comfactor &lt;- matrix(0, ncol = ncol(Y))
lambda  &lt;- matrix(0, ncol = nrow(Y))
calculate_error_term(Y, X, beta_est, g, factor_group, lambda_group, comfactor, lambda,
  3, 0, c(3, 3, 3))
</code></pre>

<hr>
<h2 id='calculate_errors_virtual_groups'>Helpfunction for update_g(). Calculates the errors for one of the possible groups time series can be placed in.</h2><span id='topic+calculate_errors_virtual_groups'></span>

<h3>Description</h3>

<p>During the updating of group membership, the errorterm is used as the objective function to estimate the group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_errors_virtual_groups(
  group,
  LF,
  virtual_grouped_factor_structure,
  NN,
  TT,
  k,
  kg,
  vars_est,
  method_estimate_beta,
  Y,
  X,
  beta_est,
  g
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_errors_virtual_groups_+3A_group">group</code></td>
<td>
<p>group</p>
</td></tr>
<tr><td><code id="calculate_errors_virtual_groups_+3A_lf">LF</code></td>
<td>
<p>NxT-matrix of the common factorstructure</p>
</td></tr>
<tr><td><code id="calculate_errors_virtual_groups_+3A_virtual_grouped_factor_structure">virtual_grouped_factor_structure</code></td>
<td>
<p>list with length the number of groups; every element of the list contains NxT-matrix</p>
</td></tr>
<tr><td><code id="calculate_errors_virtual_groups_+3A_nn">NN</code></td>
<td>
<p>number of time series</p>
</td></tr>
<tr><td><code id="calculate_errors_virtual_groups_+3A_tt">TT</code></td>
<td>
<p>length of time series</p>
</td></tr>
<tr><td><code id="calculate_errors_virtual_groups_+3A_k">k</code></td>
<td>
<p>number of common factors to be estimated</p>
</td></tr>
<tr><td><code id="calculate_errors_virtual_groups_+3A_kg">kg</code></td>
<td>
<p>number of group specific factors to be estimated</p>
</td></tr>
<tr><td><code id="calculate_errors_virtual_groups_+3A_vars_est">vars_est</code></td>
<td>
<p>number of variables that will be included in the algorithm and have their coefficient estimated. This is usually equal to the number of observable variables.</p>
</td></tr>
<tr><td><code id="calculate_errors_virtual_groups_+3A_method_estimate_beta">method_estimate_beta</code></td>
<td>
<p>defines how beta is estimated. Default case is an estimated beta for each individual. Default value is &quot;individual.&quot; Possible values are &quot;homogeneous&quot;, &quot;group&quot; or &quot;individual&quot;.</p>
</td></tr>
<tr><td><code id="calculate_errors_virtual_groups_+3A_y">Y</code></td>
<td>
<p>Y: NxT dataframe with the panel data of interest</p>
</td></tr>
<tr><td><code id="calculate_errors_virtual_groups_+3A_x">X</code></td>
<td>
<p>dataframe with the observed variables</p>
</td></tr>
<tr><td><code id="calculate_errors_virtual_groups_+3A_beta_est">beta_est</code></td>
<td>
<p>estimated values of beta</p>
</td></tr>
<tr><td><code id="calculate_errors_virtual_groups_+3A_g">g</code></td>
<td>
<p>Vector with estimated group membership for all individuals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NxT matrix with the errorterms (=Y minus the estimated factorstructure(s) and minus X*beta)
</p>

<hr>
<h2 id='calculate_FL_group_estimated'>Returns the estimated groupfactorstructure.</h2><span id='topic+calculate_FL_group_estimated'></span>

<h3>Description</h3>

<p>Returns the estimated groupfactorstructure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_FL_group_estimated(
  lg,
  fg,
  g,
  NN,
  TT,
  S,
  k,
  kg,
  num_factors_may_vary = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_FL_group_estimated_+3A_lg">lg</code></td>
<td>
<p>loadings of estimated group factors</p>
</td></tr>
<tr><td><code id="calculate_FL_group_estimated_+3A_fg">fg</code></td>
<td>
<p>estimated group factors</p>
</td></tr>
<tr><td><code id="calculate_FL_group_estimated_+3A_g">g</code></td>
<td>
<p>Vector with estimated group membership for all individuals</p>
</td></tr>
<tr><td><code id="calculate_FL_group_estimated_+3A_nn">NN</code></td>
<td>
<p>number of time series</p>
</td></tr>
<tr><td><code id="calculate_FL_group_estimated_+3A_tt">TT</code></td>
<td>
<p>length of time series</p>
</td></tr>
<tr><td><code id="calculate_FL_group_estimated_+3A_s">S</code></td>
<td>
<p>number of estimated groups</p>
</td></tr>
<tr><td><code id="calculate_FL_group_estimated_+3A_k">k</code></td>
<td>
<p>number of common factors to be estimated</p>
</td></tr>
<tr><td><code id="calculate_FL_group_estimated_+3A_kg">kg</code></td>
<td>
<p>number of group specific factors to be estimated</p>
</td></tr>
<tr><td><code id="calculate_FL_group_estimated_+3A_num_factors_may_vary">num_factors_may_vary</code></td>
<td>
<p>whether or not the number of groupfactors is constant over all groups or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with NjxT matrices
</p>

<hr>
<h2 id='calculate_FL_group_true'>Calculate the true groupfactorstructure.</h2><span id='topic+calculate_FL_group_true'></span>

<h3>Description</h3>

<p>Calculate the true groupfactorstructure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_FL_group_true(
  lgt,
  fgt,
  g_true,
  NN,
  TT,
  S_true,
  k_true,
  kg_true,
  num_factors_may_vary = TRUE,
  dgp1_AB_local = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_FL_group_true_+3A_lgt">lgt</code></td>
<td>
<p>true group factor loadings</p>
</td></tr>
<tr><td><code id="calculate_FL_group_true_+3A_fgt">fgt</code></td>
<td>
<p>true group factors</p>
</td></tr>
<tr><td><code id="calculate_FL_group_true_+3A_g_true">g_true</code></td>
<td>
<p>vector of length NN with true group memberships</p>
</td></tr>
<tr><td><code id="calculate_FL_group_true_+3A_nn">NN</code></td>
<td>
<p>number of time series</p>
</td></tr>
<tr><td><code id="calculate_FL_group_true_+3A_tt">TT</code></td>
<td>
<p>length of time series</p>
</td></tr>
<tr><td><code id="calculate_FL_group_true_+3A_s_true">S_true</code></td>
<td>
<p>true number of groups</p>
</td></tr>
<tr><td><code id="calculate_FL_group_true_+3A_k_true">k_true</code></td>
<td>
<p>true number of common factors</p>
</td></tr>
<tr><td><code id="calculate_FL_group_true_+3A_kg_true">kg_true</code></td>
<td>
<p>true number of group factors for each group</p>
</td></tr>
<tr><td><code id="calculate_FL_group_true_+3A_num_factors_may_vary">num_factors_may_vary</code></td>
<td>
<p>whether or not the number of groupfactors is constant over all groups or not</p>
</td></tr>
<tr><td><code id="calculate_FL_group_true_+3A_dgp1_ab_local">dgp1_AB_local</code></td>
<td>
<p>gives information about which DGP we use; TRUE of FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with NjxT matrices
</p>

<hr>
<h2 id='calculate_lambda'>calculates factor loadings of common factors</h2><span id='topic+calculate_lambda'></span>

<h3>Description</h3>

<p>calculates factor loadings of common factors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_lambda(
  Y,
  X,
  beta_est,
  comfactor,
  factor_group,
  g,
  lgfg_list,
  k,
  kg,
  robust,
  method_estimate_beta,
  method_estimate_factors,
  verbose = FALSE,
  initialise = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_lambda_+3A_y">Y</code></td>
<td>
<p>Y: NxT dataframe with the panel data of interest</p>
</td></tr>
<tr><td><code id="calculate_lambda_+3A_x">X</code></td>
<td>
<p>X: NxTxp array containing the observable variables</p>
</td></tr>
<tr><td><code id="calculate_lambda_+3A_beta_est">beta_est</code></td>
<td>
<p>estimated values of beta</p>
</td></tr>
<tr><td><code id="calculate_lambda_+3A_comfactor">comfactor</code></td>
<td>
<p>common factors</p>
</td></tr>
<tr><td><code id="calculate_lambda_+3A_factor_group">factor_group</code></td>
<td>
<p>estimated group specific factors</p>
</td></tr>
<tr><td><code id="calculate_lambda_+3A_g">g</code></td>
<td>
<p>Vector with group membership for all individuals</p>
</td></tr>
<tr><td><code id="calculate_lambda_+3A_lgfg_list">lgfg_list</code></td>
<td>
<p>This is a list (length number of groups) containing FgLg for every group.</p>
</td></tr>
<tr><td><code id="calculate_lambda_+3A_k">k</code></td>
<td>
<p>number of common factors to be estimated</p>
</td></tr>
<tr><td><code id="calculate_lambda_+3A_kg">kg</code></td>
<td>
<p>number of group specific factors to be estimated</p>
</td></tr>
<tr><td><code id="calculate_lambda_+3A_robust">robust</code></td>
<td>
<p>TRUE or FALSE: defines using the classical or robust algorithm to estimate beta</p>
</td></tr>
<tr><td><code id="calculate_lambda_+3A_method_estimate_beta">method_estimate_beta</code></td>
<td>
<p>defines how beta is estimated. Default case is an estimated beta for each individual. Default value is &quot;individual.&quot; Possible values are &quot;homogeneous&quot;, &quot;group&quot; or &quot;individual&quot;.</p>
</td></tr>
<tr><td><code id="calculate_lambda_+3A_method_estimate_factors">method_estimate_factors</code></td>
<td>
<p>defines method of robust estimaton of the factors: &quot;macro&quot;, &quot;pertmm&quot; or &quot;cz&quot;</p>
</td></tr>
<tr><td><code id="calculate_lambda_+3A_verbose">verbose</code></td>
<td>
<p>when TRUE, it prints messages</p>
</td></tr>
<tr><td><code id="calculate_lambda_+3A_initialise">initialise</code></td>
<td>
<p>indicator of being in the initialisation phase</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix where each row contains a common factor. If the number of estimated common factors equals zero, it returns a matrix with 1 row, containing zero's.
</p>

<hr>
<h2 id='calculate_lambda_group'>calculates factor loadings of groupfactors</h2><span id='topic+calculate_lambda_group'></span>

<h3>Description</h3>

<p>returns object which includes group and id of the individuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_lambda_group(
  Y,
  X,
  beta_est,
  factor_group,
  g,
  lambda,
  comfactor,
  S,
  k,
  kg,
  robust,
  method_estimate_beta = "individual",
  method_estimate_factors = "macro",
  verbose = FALSE,
  initialise = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_lambda_group_+3A_y">Y</code></td>
<td>
<p>Y: NxT dataframe with the panel data of interest</p>
</td></tr>
<tr><td><code id="calculate_lambda_group_+3A_x">X</code></td>
<td>
<p>X: NxTxp array containing the observable variables</p>
</td></tr>
<tr><td><code id="calculate_lambda_group_+3A_beta_est">beta_est</code></td>
<td>
<p>estimated values of beta</p>
</td></tr>
<tr><td><code id="calculate_lambda_group_+3A_factor_group">factor_group</code></td>
<td>
<p>estimated group specific factors</p>
</td></tr>
<tr><td><code id="calculate_lambda_group_+3A_g">g</code></td>
<td>
<p>Vector with estimated group membership for all individuals</p>
</td></tr>
<tr><td><code id="calculate_lambda_group_+3A_lambda">lambda</code></td>
<td>
<p>loadings of the estimated common factors</p>
</td></tr>
<tr><td><code id="calculate_lambda_group_+3A_comfactor">comfactor</code></td>
<td>
<p>estimated common factors</p>
</td></tr>
<tr><td><code id="calculate_lambda_group_+3A_s">S</code></td>
<td>
<p>number of estimated groups</p>
</td></tr>
<tr><td><code id="calculate_lambda_group_+3A_k">k</code></td>
<td>
<p>number of common factors to be estimated</p>
</td></tr>
<tr><td><code id="calculate_lambda_group_+3A_kg">kg</code></td>
<td>
<p>number of group specific factors to be estimated</p>
</td></tr>
<tr><td><code id="calculate_lambda_group_+3A_robust">robust</code></td>
<td>
<p>TRUE or FALSE: defines using the classical or robust algorithm to estimate beta</p>
</td></tr>
<tr><td><code id="calculate_lambda_group_+3A_method_estimate_beta">method_estimate_beta</code></td>
<td>
<p>defines how beta is estimated. Default case is an estimated beta for each individual. Default value is &quot;individual.&quot; Possible values are &quot;homogeneous&quot;, &quot;group&quot; or &quot;individual&quot;.</p>
</td></tr>
<tr><td><code id="calculate_lambda_group_+3A_method_estimate_factors">method_estimate_factors</code></td>
<td>
<p>defines method of robust estimaton of the factors: &quot;macro&quot;, &quot;pertmm&quot; or &quot;cz&quot;</p>
</td></tr>
<tr><td><code id="calculate_lambda_group_+3A_verbose">verbose</code></td>
<td>
<p>when TRUE, it prints messages</p>
</td></tr>
<tr><td><code id="calculate_lambda_group_+3A_initialise">initialise</code></td>
<td>
<p>indicator of being in the initialisation phase</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame with a row for each time series. The first number of columns contain the individual loadings to the group specific factors.
Furthermore &quot;group&quot; (group membership) and id (the order in which the time series appear in Y) are added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' #example with data generated with DGP 2
data &lt;- create_data_dgp2(30, 10)
Y &lt;- data[[1]]
X &lt;- data[[2]]
g &lt;- data[[3]] #true group membership
set.seed(1)
beta_est &lt;- matrix(rnorm(4 * nrow(Y)), nrow = 4)
factor_group &lt;- data[[5]] #true values of group specific factors
comfactor &lt;- matrix(0, nrow = 1, ncol = ncol(Y))
lambda &lt;- matrix(0, nrow = 1, ncol = nrow(Y))
calculate_lambda_group(Y, X, beta_est, factor_group, g, lambda, comfactor,
3, 0, c(3, 3, 3), TRUE)
</code></pre>

<hr>
<h2 id='calculate_lgfg'>Calculates the group factor structure: the matrix product of the group factors and their loadings.</h2><span id='topic+calculate_lgfg'></span>

<h3>Description</h3>

<p>Returns list (with as length the number of groups) with lgfg (product of grouploadings and groupfactors).
Each element of the list with the assumption that all individuals are in the same group k.
This function is used to speed up code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_lgfg(
  lambda_group,
  factor_group,
  S,
  k,
  kg,
  num_factors_may_vary,
  NN,
  TT
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_lgfg_+3A_lambda_group">lambda_group</code></td>
<td>
<p>loadings of the estimated group specific factors</p>
</td></tr>
<tr><td><code id="calculate_lgfg_+3A_factor_group">factor_group</code></td>
<td>
<p>estimated group specific factors</p>
</td></tr>
<tr><td><code id="calculate_lgfg_+3A_s">S</code></td>
<td>
<p>number of groups</p>
</td></tr>
<tr><td><code id="calculate_lgfg_+3A_k">k</code></td>
<td>
<p>number of common factors</p>
</td></tr>
<tr><td><code id="calculate_lgfg_+3A_kg">kg</code></td>
<td>
<p>vector with the number of group specific factors for each group</p>
</td></tr>
<tr><td><code id="calculate_lgfg_+3A_num_factors_may_vary">num_factors_may_vary</code></td>
<td>
<p>whether or not the number of groupfactors is constant over all groups or not</p>
</td></tr>
<tr><td><code id="calculate_lgfg_+3A_nn">NN</code></td>
<td>
<p>number of time series</p>
</td></tr>
<tr><td><code id="calculate_lgfg_+3A_tt">TT</code></td>
<td>
<p>length of time series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with S elements: each element contains a matrix with NN rows and TT columns with the estimated group factor structure of this particular group
</p>

<hr>
<h2 id='calculate_obj_for_g'>Calculates objective function for individual i and group k in order to estimate group membership.</h2><span id='topic+calculate_obj_for_g'></span>

<h3>Description</h3>

<p>Helpfunction in update_g().
Depends on an not yet established group k ( cannot use lgfg_list)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_obj_for_g(i, k, errors_virtual, rho_parameters, robust, TT)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_obj_for_g_+3A_i">i</code></td>
<td>
<p>individual</p>
</td></tr>
<tr><td><code id="calculate_obj_for_g_+3A_k">k</code></td>
<td>
<p>group</p>
</td></tr>
<tr><td><code id="calculate_obj_for_g_+3A_errors_virtual">errors_virtual</code></td>
<td>
<p>list with errors for each possible group</p>
</td></tr>
<tr><td><code id="calculate_obj_for_g_+3A_rho_parameters">rho_parameters</code></td>
<td>
<p>median and madn of the calculated error term</p>
</td></tr>
<tr><td><code id="calculate_obj_for_g_+3A_robust">robust</code></td>
<td>
<p>robust or classical estimation</p>
</td></tr>
<tr><td><code id="calculate_obj_for_g_+3A_tt">TT</code></td>
<td>
<p>length of time series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value
</p>

<hr>
<h2 id='calculate_PIC'>Function to determine PIC (panel information criterium)</h2><span id='topic+calculate_PIC'></span>

<h3>Description</h3>

<p>This depends on kappa1 -&gt; kappaN, through p (=number of nonzero elements of beta_est).
The parameter 'sigma2' is the non-robust sigma2. As it is only used in term 2 to 4, it does not actually matter what its value is (needs to be &gt; 0).
It could be set to 1 as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_PIC(
  C,
  robust,
  S,
  k,
  kg,
  e2,
  sigma2,
  NN,
  TT,
  method_estimate_beta,
  beta_est,
  g,
  vars_est,
  choice_pic = "pic2017"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_PIC_+3A_c">C</code></td>
<td>
<p>determines relative contribution of the penalty terms compared to the estimation error term</p>
</td></tr>
<tr><td><code id="calculate_PIC_+3A_robust">robust</code></td>
<td>
<p>TRUE or FALSE: defines using the classical or robust algorithm to estimate beta</p>
</td></tr>
<tr><td><code id="calculate_PIC_+3A_s">S</code></td>
<td>
<p>number of estimated groups</p>
</td></tr>
<tr><td><code id="calculate_PIC_+3A_k">k</code></td>
<td>
<p>number of common factors to be estimated</p>
</td></tr>
<tr><td><code id="calculate_PIC_+3A_kg">kg</code></td>
<td>
<p>number of group specific factors to be estimated</p>
</td></tr>
<tr><td><code id="calculate_PIC_+3A_e2">e2</code></td>
<td>
<p>NxT matrix with error terms</p>
</td></tr>
<tr><td><code id="calculate_PIC_+3A_sigma2">sigma2</code></td>
<td>
<p>scalar: sum of squared error terms, scaled by NT</p>
</td></tr>
<tr><td><code id="calculate_PIC_+3A_nn">NN</code></td>
<td>
<p>number of time series</p>
</td></tr>
<tr><td><code id="calculate_PIC_+3A_tt">TT</code></td>
<td>
<p>length of time series</p>
</td></tr>
<tr><td><code id="calculate_PIC_+3A_method_estimate_beta">method_estimate_beta</code></td>
<td>
<p>defines how beta is estimated. Default case is an estimated beta for each individual. Default value is &quot;individual.&quot; Possible values are &quot;homogeneous&quot;, &quot;group&quot; or &quot;individual&quot;.</p>
</td></tr>
<tr><td><code id="calculate_PIC_+3A_beta_est">beta_est</code></td>
<td>
<p>estimated values of beta</p>
</td></tr>
<tr><td><code id="calculate_PIC_+3A_g">g</code></td>
<td>
<p>Vector with estimated group membership for all individuals</p>
</td></tr>
<tr><td><code id="calculate_PIC_+3A_vars_est">vars_est</code></td>
<td>
<p>number of variables that will be included in the algorithm and have their coefficient estimated. This is usually equal to the number of observable variables.</p>
</td></tr>
<tr><td><code id="calculate_PIC_+3A_choice_pic">choice_pic</code></td>
<td>
<p>indicates which PIC to use to estimate the number of groups and factors:
options are &quot;pic2017&quot; (uses the PIC of Ando and Bai (2017); works better for large N),
&quot;pic2016&quot; (Ando and Bai (2016); works better for large T) weighs the fourth term with an extra factor relative to the size of the groups,
and &quot;pic2022&quot; which shrinks the NT-space where the number of groups and factors would be over- or underestimated compared to pic2016 and pic2017.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
NN &lt;- 30
TT &lt;- 10
e &lt;- matrix(rnorm(NN * TT), nrow = NN)
beta_est &lt;- matrix(rnorm(NN * 4), ncol = NN) #random values for beta
g &lt;- round(runif(NN, 1, 3))
calculate_PIC(0.51, TRUE, 3, 0, c(3, 3, 3), e, e^2/(NN*TT), NN, TT, "individual", beta_est, g, 3)
</code></pre>

<hr>
<h2 id='calculate_PIC_term1'>Function to calculate the first term of PIC (panel information criterium)</h2><span id='topic+calculate_PIC_term1'></span>

<h3>Description</h3>

<p>This is used in calculate_PIC()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_PIC_term1(e, robust)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_PIC_term1_+3A_e">e</code></td>
<td>
<p>NxT matrix with the error terms</p>
</td></tr>
<tr><td><code id="calculate_PIC_term1_+3A_robust">robust</code></td>
<td>
<p>robust or classical estimation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>

<hr>
<h2 id='calculate_sigma2'>Calculates sum of squared errors, divided by NT</h2><span id='topic+calculate_sigma2'></span>

<h3>Description</h3>

<p>Calculates sum of squared errors, divided by NT
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_sigma2(e, NN = nrow(e), TT = ncol(e))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_sigma2_+3A_e">e</code></td>
<td>
<p>matrix with error terms</p>
</td></tr>
<tr><td><code id="calculate_sigma2_+3A_nn">NN</code></td>
<td>
<p>N</p>
</td></tr>
<tr><td><code id="calculate_sigma2_+3A_tt">TT</code></td>
<td>
<p>T</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- Y_dgp3
set.seed(1)
e &lt;- matrix(rnorm(nrow(Y) * ncol(Y)), nrow = nrow(Y))
calculate_sigma2(e)
</code></pre>

<hr>
<h2 id='calculate_sigma2maxmodel'>Calculates sigma2maxmodel</h2><span id='topic+calculate_sigma2maxmodel'></span>

<h3>Description</h3>

<p>Sigma2 is the sum of the squared errors, divided by NT. We need the sigma2 of the maxmodel to use (in term 2,3,4 of the PIC) instead of the configuration-dependent sigma2. (See paper AndoBai 2016).
sigma2_max_model could actually be set to 1 as well, as it can be absorbed in parameter C of the PIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_sigma2maxmodel(e, kg_max, S, S_cand, kg, k, k_cand)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_sigma2maxmodel_+3A_e">e</code></td>
<td>
<p>NxT-matrix containing the estimated error term</p>
</td></tr>
<tr><td><code id="calculate_sigma2maxmodel_+3A_kg_max">kg_max</code></td>
<td>
<p>scalar: maximum allowed number of estimated factors for any group</p>
</td></tr>
<tr><td><code id="calculate_sigma2maxmodel_+3A_s">S</code></td>
<td>
<p>estimated number of groups</p>
</td></tr>
<tr><td><code id="calculate_sigma2maxmodel_+3A_s_cand">S_cand</code></td>
<td>
<p>vector with candidate values for the number of groups</p>
</td></tr>
<tr><td><code id="calculate_sigma2maxmodel_+3A_kg">kg</code></td>
<td>
<p>vector with the estimated number of group specific factors for each group</p>
</td></tr>
<tr><td><code id="calculate_sigma2maxmodel_+3A_k">k</code></td>
<td>
<p>estimated number of common factors</p>
</td></tr>
<tr><td><code id="calculate_sigma2maxmodel_+3A_k_cand">k_cand</code></td>
<td>
<p>vector with candidate value for the number of common factors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>

<hr>
<h2 id='calculate_TN_factor'>Helpfunction. Calculates part of the 4th term of the PIC.</h2><span id='topic+calculate_TN_factor'></span>

<h3>Description</h3>

<p>Helpfunction. Calculates part of the 4th term of the PIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_TN_factor(TT, Nj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_TN_factor_+3A_tt">TT</code></td>
<td>
<p>length of time series</p>
</td></tr>
<tr><td><code id="calculate_TN_factor_+3A_nj">Nj</code></td>
<td>
<p>number of time series in group j</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>

<hr>
<h2 id='calculate_VCsquared'>Calculates VCÂ², to determine the stability of the found number of groups and factors over the subsamples.</h2><span id='topic+calculate_VCsquared'></span>

<h3>Description</h3>

<p>VCÂ² depends on C (this is the scale parameter in PIC). When VCÂ² is equal to zero, the found number of groups and factors
are the same over the subsamples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_VCsquared(
  rcj,
  rc,
  C_candidates,
  indices_subset,
  Smax,
  limit_est_groups = 20
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_VCsquared_+3A_rcj">rcj</code></td>
<td>
<p>dataframe containg the numer of groupfactors for all candidate C's and all subsamples</p>
</td></tr>
<tr><td><code id="calculate_VCsquared_+3A_rc">rc</code></td>
<td>
<p>dataframe containg the numer of common factors for all candidate C's and all subsamples</p>
</td></tr>
<tr><td><code id="calculate_VCsquared_+3A_c_candidates">C_candidates</code></td>
<td>
<p>candidates for C (parameter in PIC)</p>
</td></tr>
<tr><td><code id="calculate_VCsquared_+3A_indices_subset">indices_subset</code></td>
<td>
<p>all indices of the subsets</p>
</td></tr>
<tr><td><code id="calculate_VCsquared_+3A_smax">Smax</code></td>
<td>
<p>maximum allowed number of estimated groups</p>
</td></tr>
<tr><td><code id="calculate_VCsquared_+3A_limit_est_groups">limit_est_groups</code></td>
<td>
<p>maximum allowed number of groups that can be estimated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with the VC2-value for each candidate C
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rcj &lt;- data.frame(X1 = rep("3_3_3", 5), X2 = rep("3_2_1", 5))
rc &lt;- data.frame(X1 = rep(1, 5), X2 = rep(0, 5))
calculate_VCsquared(rcj, rc, 1:5, 0:1, 3)
</code></pre>

<hr>
<h2 id='calculate_virtual_factor_and_lambda_group'>Helpfunction used in update_g()</h2><span id='topic+calculate_virtual_factor_and_lambda_group'></span>

<h3>Description</h3>

<p>This function calculates FgLg (the groupfactorstructure) for all possible groups where individual i can be placed. For each group were
the groupfactors (Fg) estimated earlier. Now the grouploadings are needed for each group as well. In the classical case these are calculated by Fg*Y/T. In the robust case
these are robust.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_virtual_factor_and_lambda_group(
  group,
  solve_FG_FG_times_FG,
  robust,
  NN_local,
  method_estimate_factors_local,
  g,
  vars_est,
  number_of_group_factors_local,
  number_of_common_factors_local,
  method_estimate_beta,
  factor_group,
  lambda,
  comfactor,
  Y,
  X,
  beta_est,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_virtual_factor_and_lambda_group_+3A_group">group</code></td>
<td>
<p>number of groups</p>
</td></tr>
<tr><td><code id="calculate_virtual_factor_and_lambda_group_+3A_solve_fg_fg_times_fg">solve_FG_FG_times_FG</code></td>
<td>
<p>This is the same as groupfactor / T. It is only used in the Classical approach</p>
</td></tr>
<tr><td><code id="calculate_virtual_factor_and_lambda_group_+3A_robust">robust</code></td>
<td>
<p>robust or classical estimation of group membership</p>
</td></tr>
<tr><td><code id="calculate_virtual_factor_and_lambda_group_+3A_nn_local">NN_local</code></td>
<td>
<p>number of time series</p>
</td></tr>
<tr><td><code id="calculate_virtual_factor_and_lambda_group_+3A_method_estimate_factors_local">method_estimate_factors_local</code></td>
<td>
<p>specifies the robust algorithm to estimate factors: default is &quot;macro&quot;</p>
</td></tr>
<tr><td><code id="calculate_virtual_factor_and_lambda_group_+3A_g">g</code></td>
<td>
<p>vector with estimated group membership for all individuals</p>
</td></tr>
<tr><td><code id="calculate_virtual_factor_and_lambda_group_+3A_vars_est">vars_est</code></td>
<td>
<p>number of variables that are included in the algorithm and have their coefficient estimated. This is usually equal to vars.</p>
</td></tr>
<tr><td><code id="calculate_virtual_factor_and_lambda_group_+3A_number_of_group_factors_local">number_of_group_factors_local</code></td>
<td>
<p>number of group factors to be estimated</p>
</td></tr>
<tr><td><code id="calculate_virtual_factor_and_lambda_group_+3A_number_of_common_factors_local">number_of_common_factors_local</code></td>
<td>
<p>number of common factors to be estimated</p>
</td></tr>
<tr><td><code id="calculate_virtual_factor_and_lambda_group_+3A_method_estimate_beta">method_estimate_beta</code></td>
<td>
<p>defines how beta is estimated. Default case is an estimated beta for each individual. Default value is &quot;individual.&quot; Possible values are &quot;homogeneous&quot;, &quot;group&quot; or &quot;individual&quot;.</p>
</td></tr>
<tr><td><code id="calculate_virtual_factor_and_lambda_group_+3A_factor_group">factor_group</code></td>
<td>
<p>estimated group specific factors</p>
</td></tr>
<tr><td><code id="calculate_virtual_factor_and_lambda_group_+3A_lambda">lambda</code></td>
<td>
<p>loadings of the estimated common factors</p>
</td></tr>
<tr><td><code id="calculate_virtual_factor_and_lambda_group_+3A_comfactor">comfactor</code></td>
<td>
<p>estimated common factors</p>
</td></tr>
<tr><td><code id="calculate_virtual_factor_and_lambda_group_+3A_y">Y</code></td>
<td>
<p>Y: NxT dataframe with the panel data of interest</p>
</td></tr>
<tr><td><code id="calculate_virtual_factor_and_lambda_group_+3A_x">X</code></td>
<td>
<p>X: NxTxp array containing the observable variables</p>
</td></tr>
<tr><td><code id="calculate_virtual_factor_and_lambda_group_+3A_beta_est">beta_est</code></td>
<td>
<p>estimated values of beta</p>
</td></tr>
<tr><td><code id="calculate_virtual_factor_and_lambda_group_+3A_verbose">verbose</code></td>
<td>
<p>when TRUE, it prints messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NxT matrix containing the product of virtual groupfactors and virtual loadings
</p>

<hr>
<h2 id='calculate_W'>Calculates W = Y - X*beta_est. It is used in the initialization step of the algorithm, to initialise the factorstructures.</h2><span id='topic+calculate_W'></span>

<h3>Description</h3>

<p>Calculates W = Y - X*beta_est. It is used in the initialization step of the algorithm, to initialise the factorstructures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_W(Y, X, beta_est, g, vars_est, method_estimate_beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_W_+3A_y">Y</code></td>
<td>
<p>Y: NxT dataframe with the panel data of interest</p>
</td></tr>
<tr><td><code id="calculate_W_+3A_x">X</code></td>
<td>
<p>X: NxTxp array containing the observable variables</p>
</td></tr>
<tr><td><code id="calculate_W_+3A_beta_est">beta_est</code></td>
<td>
<p>estimated values of beta</p>
</td></tr>
<tr><td><code id="calculate_W_+3A_g">g</code></td>
<td>
<p>Vector with group membership for all individuals</p>
</td></tr>
<tr><td><code id="calculate_W_+3A_vars_est">vars_est</code></td>
<td>
<p>number of variables that will be included in the algorithm and have their coefficient estimated. This is usually equal to the number of observable variables.</p>
</td></tr>
<tr><td><code id="calculate_W_+3A_method_estimate_beta">method_estimate_beta</code></td>
<td>
<p>defines how beta is estimated. Default case is an estimated beta for each individual. Default value is &quot;individual.&quot; Possible values are &quot;homogeneous&quot;, &quot;group&quot; or &quot;individual&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NxT matrix
</p>

<hr>
<h2 id='calculate_XB_estimated'>Calculates (the estimated value of) the matrix X*beta_est.</h2><span id='topic+calculate_XB_estimated'></span>

<h3>Description</h3>

<p>Calculates (the estimated value of) the matrix X*beta_est.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_XB_estimated(X, beta_est, g, vars_est, method_estimate_beta, TT)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_XB_estimated_+3A_x">X</code></td>
<td>
<p>X: NxTxp array containing the observable variables</p>
</td></tr>
<tr><td><code id="calculate_XB_estimated_+3A_beta_est">beta_est</code></td>
<td>
<p>estimated values of beta</p>
</td></tr>
<tr><td><code id="calculate_XB_estimated_+3A_g">g</code></td>
<td>
<p>Vector with estimated group membership for all individuals</p>
</td></tr>
<tr><td><code id="calculate_XB_estimated_+3A_vars_est">vars_est</code></td>
<td>
<p>number of variables that will be included in the algorithm and have their coefficient estimated. This is usually equal to the number of observable variables.</p>
</td></tr>
<tr><td><code id="calculate_XB_estimated_+3A_method_estimate_beta">method_estimate_beta</code></td>
<td>
<p>defines how beta is estimated. Default case is an estimated beta for each individual. Default value is &quot;individual.&quot; Possible values are &quot;homogeneous&quot;, &quot;group&quot; or &quot;individual&quot;.</p>
</td></tr>
<tr><td><code id="calculate_XB_estimated_+3A_tt">TT</code></td>
<td>
<p>length of time series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a NxT matrix. If vars_est is set to 0, it returns NA.
</p>

<hr>
<h2 id='calculate_XB_true'>Calculates the product of X*beta_true .</h2><span id='topic+calculate_XB_true'></span>

<h3>Description</h3>

<p>Calculates the product of X*beta_true .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_XB_true(X, beta_true, g, g_true, method_estimate_beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_XB_true_+3A_x">X</code></td>
<td>
<p>X: NxTxp array containing the observable variables</p>
</td></tr>
<tr><td><code id="calculate_XB_true_+3A_beta_true">beta_true</code></td>
<td>
<p>true coefficients of the observable variables</p>
</td></tr>
<tr><td><code id="calculate_XB_true_+3A_g">g</code></td>
<td>
<p>Vector with estimated group membership for all individuals</p>
</td></tr>
<tr><td><code id="calculate_XB_true_+3A_g_true">g_true</code></td>
<td>
<p>true group membership</p>
</td></tr>
<tr><td><code id="calculate_XB_true_+3A_method_estimate_beta">method_estimate_beta</code></td>
<td>
<p>defines how beta is estimated. Default case is an estimated beta for each individual. Default value is &quot;individual.&quot; Possible values are &quot;homogeneous&quot;, &quot;group&quot; or &quot;individual&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a NxT matrix (if method_estimate_beta == &quot;individual&quot;), and otherwise NA.
</p>

<hr>
<h2 id='calculate_Z_common'>Calculates Z = Y - X*beta_est - LgFg. It is used in the estimate of the common factorstructure.</h2><span id='topic+calculate_Z_common'></span>

<h3>Description</h3>

<p>Calculates Z = Y - X*beta_est - LgFg. It is used in the estimate of the common factorstructure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_Z_common(
  Y,
  X,
  beta_est,
  g,
  lgfg_list,
  vars_est,
  kg,
  method_estimate_beta,
  method_estimate_factors,
  initialise = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_Z_common_+3A_y">Y</code></td>
<td>
<p>Y: NxT dataframe with the panel data of interest</p>
</td></tr>
<tr><td><code id="calculate_Z_common_+3A_x">X</code></td>
<td>
<p>X: NxTxp array containing the observable variables</p>
</td></tr>
<tr><td><code id="calculate_Z_common_+3A_beta_est">beta_est</code></td>
<td>
<p>estimated values of beta</p>
</td></tr>
<tr><td><code id="calculate_Z_common_+3A_g">g</code></td>
<td>
<p>Vector with group membership for all individuals</p>
</td></tr>
<tr><td><code id="calculate_Z_common_+3A_lgfg_list">lgfg_list</code></td>
<td>
<p>This is a list (length number of groups) containing FgLg for every group.</p>
</td></tr>
<tr><td><code id="calculate_Z_common_+3A_vars_est">vars_est</code></td>
<td>
<p>number of variables that will be included in the algorithm and have their coefficient estimated. This is usually equal to the number of observable variables.</p>
</td></tr>
<tr><td><code id="calculate_Z_common_+3A_kg">kg</code></td>
<td>
<p>number of group specific factors to be estimated</p>
</td></tr>
<tr><td><code id="calculate_Z_common_+3A_method_estimate_beta">method_estimate_beta</code></td>
<td>
<p>defines how beta is estimated. Default case is an estimated beta for each individual. Default value is &quot;individual.&quot; Possible values are &quot;homogeneous&quot;, &quot;group&quot; or &quot;individual&quot;.</p>
</td></tr>
<tr><td><code id="calculate_Z_common_+3A_method_estimate_factors">method_estimate_factors</code></td>
<td>
<p>defines method of robust estimaton of the factors: &quot;macro&quot;, &quot;pertmm&quot; or &quot;cz&quot;</p>
</td></tr>
<tr><td><code id="calculate_Z_common_+3A_initialise">initialise</code></td>
<td>
<p>indicator of being in the initialisation phase</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NxT matrix
</p>

<hr>
<h2 id='calculate_Z_group'>Calculates Z = Y - X*beta_est - LF. It is used to estimate the groupfactorstructure.</h2><span id='topic+calculate_Z_group'></span>

<h3>Description</h3>

<p>Calculates Z = Y - X*beta_est - LF. It is used to estimate the groupfactorstructure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_Z_group(
  Y,
  X,
  beta_est,
  g,
  lambda,
  comfactor,
  group,
  k,
  method_estimate_beta,
  initialise,
  vars_est
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_Z_group_+3A_y">Y</code></td>
<td>
<p>Y: NxT dataframe with the panel data of interest</p>
</td></tr>
<tr><td><code id="calculate_Z_group_+3A_x">X</code></td>
<td>
<p>X: NxTxp array containing the observable variables</p>
</td></tr>
<tr><td><code id="calculate_Z_group_+3A_beta_est">beta_est</code></td>
<td>
<p>estimated values of beta</p>
</td></tr>
<tr><td><code id="calculate_Z_group_+3A_g">g</code></td>
<td>
<p>Vector with group membership for all individuals</p>
</td></tr>
<tr><td><code id="calculate_Z_group_+3A_lambda">lambda</code></td>
<td>
<p>loadings of the estimated common factors</p>
</td></tr>
<tr><td><code id="calculate_Z_group_+3A_comfactor">comfactor</code></td>
<td>
<p>estimated common factors</p>
</td></tr>
<tr><td><code id="calculate_Z_group_+3A_group">group</code></td>
<td>
<p>indexnumber of the group</p>
</td></tr>
<tr><td><code id="calculate_Z_group_+3A_k">k</code></td>
<td>
<p>number of common factors to be estimated</p>
</td></tr>
<tr><td><code id="calculate_Z_group_+3A_method_estimate_beta">method_estimate_beta</code></td>
<td>
<p>defines how beta is estimated. Default case is an estimated beta for each individual. Default value is &quot;individual.&quot; Possible values are &quot;homogeneous&quot;, &quot;group&quot; or &quot;individual&quot;.</p>
</td></tr>
<tr><td><code id="calculate_Z_group_+3A_initialise">initialise</code></td>
<td>
<p>indicator of being in the initialisation phase</p>
</td></tr>
<tr><td><code id="calculate_Z_group_+3A_vars_est">vars_est</code></td>
<td>
<p>number of variables that will be included in the algorithm and have their coefficient estimated. This is usually equal to the number of observable variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NxT matrix
</p>

<hr>
<h2 id='check_stopping_rules'>Checks the rules for stopping the algorithm, based on its convergence speed.</h2><span id='topic+check_stopping_rules'></span>

<h3>Description</h3>

<p>Checks the rules for stopping the algorithm, based on its convergence speed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_stopping_rules(
  iteration,
  speed,
  all_OF_values,
  speedlimit = 0.01,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_stopping_rules_+3A_iteration">iteration</code></td>
<td>
<p>number of iteration</p>
</td></tr>
<tr><td><code id="check_stopping_rules_+3A_speed">speed</code></td>
<td>
<p>convergence speed</p>
</td></tr>
<tr><td><code id="check_stopping_rules_+3A_all_of_values">all_OF_values</code></td>
<td>
<p>vector containing the values of the objective function from previous iterations</p>
</td></tr>
<tr><td><code id="check_stopping_rules_+3A_speedlimit">speedlimit</code></td>
<td>
<p>if the convergence speed falls under this limit the algorithm stops</p>
</td></tr>
<tr><td><code id="check_stopping_rules_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, more information is printed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>check_stopping_rules(4, 1.7, 5:1)
</code></pre>

<hr>
<h2 id='clustering_with_robust_distances'>Function that puts individuals in a separate &quot;class zero&quot;, when their distance to all possible groups is bigger then a certain threshold.</h2><span id='topic+clustering_with_robust_distances'></span>

<h3>Description</h3>

<p>It starts with defining a robust location and scatter (based on Ma &amp; Genton (2000): Highly robust estimation of the autocovariance function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustering_with_robust_distances(g, number_of_groups, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustering_with_robust_distances_+3A_g">g</code></td>
<td>
<p>Vector with group membership for all individuals</p>
</td></tr>
<tr><td><code id="clustering_with_robust_distances_+3A_number_of_groups">number_of_groups</code></td>
<td>
<p>number of groups</p>
</td></tr>
<tr><td><code id="clustering_with_robust_distances_+3A_y">Y</code></td>
<td>
<p>Y: the panel data of interest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with the new clustering, now including class zero adjustments
</p>

<hr>
<h2 id='create_covMat_crosssectional_dependence'>Function used in generating simulated data with non normal errors.</h2><span id='topic+create_covMat_crosssectional_dependence'></span>

<h3>Description</h3>

<p>Used to include cross-sectional dependence or serial dependence into the simulated panel data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_covMat_crosssectional_dependence(parameter, NN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_covMat_crosssectional_dependence_+3A_parameter">parameter</code></td>
<td>
<p>amount of cross-sectional dependence</p>
</td></tr>
<tr><td><code id="create_covMat_crosssectional_dependence_+3A_nn">NN</code></td>
<td>
<p>number of time series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NxN covariance matrix
</p>

<hr>
<h2 id='create_data_dgp2'>Creates an instance of DGP 2, as defined in Boudt and Heyndels (2022).</h2><span id='topic+create_data_dgp2'></span>

<h3>Description</h3>

<p>The default has 3 groups with each 3 group specific factors. Further it contains 0 common factors and 3 observed variables.
The output is a list where the first element is the simulated panel dataset (a dataframe with N (amount of time series) rows and T (length of time series) columns).
The second element contains the NxTxp array with the p observed variables. The third element contains the true group membership.
The fourth element contains the true beta's (this has p+1 rows and one column for each group).
The fifth element contains a list with the true group specific factors.
The sixth element contains a dataframe with N rows where each row contains the group specific factor loadings that corresponds to the group specific factors.
Further it contains the true group membership and an index (this corresponds to the rownumber in Y and X).
The seventh and eighth elements contain the true common factor(s) and its loadings respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_data_dgp2(N, TT, S_true = 3, vars = 3, k_true = 0, kg_true = c(3, 3, 3))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_data_dgp2_+3A_n">N</code></td>
<td>
<p>number of time series</p>
</td></tr>
<tr><td><code id="create_data_dgp2_+3A_tt">TT</code></td>
<td>
<p>length of time series</p>
</td></tr>
<tr><td><code id="create_data_dgp2_+3A_s_true">S_true</code></td>
<td>
<p>true number of groups</p>
</td></tr>
<tr><td><code id="create_data_dgp2_+3A_vars">vars</code></td>
<td>
<p>number of available observed variables</p>
</td></tr>
<tr><td><code id="create_data_dgp2_+3A_k_true">k_true</code></td>
<td>
<p>true number of common_factors</p>
</td></tr>
<tr><td><code id="create_data_dgp2_+3A_kg_true">kg_true</code></td>
<td>
<p>vector with the true number of group factors for each group</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>create_data_dgp2(30, 10)
</code></pre>

<hr>
<h2 id='create_true_beta'>Creates beta_true, which contains the true values of beta (= the coefficients of X)</h2><span id='topic+create_true_beta'></span>

<h3>Description</h3>

<p>Creates beta_true, which contains the true values of beta (= the coefficients of X)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_true_beta(
  vars,
  NN,
  S_true,
  method_true_beta = "heterogeneous_groups",
  limit_true_groups = 12,
  extra_beta_factor = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_true_beta_+3A_vars">vars</code></td>
<td>
<p>number of observable variables</p>
</td></tr>
<tr><td><code id="create_true_beta_+3A_nn">NN</code></td>
<td>
<p>number of time series</p>
</td></tr>
<tr><td><code id="create_true_beta_+3A_s_true">S_true</code></td>
<td>
<p>number of groups</p>
</td></tr>
<tr><td><code id="create_true_beta_+3A_method_true_beta">method_true_beta</code></td>
<td>
<p>how the true values of beta are defined: &quot;homogeneous&quot; (equal for all individuals),
&quot;heterogeneous_groups&quot; (equal within groups, and different between groups) or heterogeneous_individuals (different for all individuals)</p>
</td></tr>
<tr><td><code id="create_true_beta_+3A_limit_true_groups">limit_true_groups</code></td>
<td>
<p>Maximum number of true groups in a simulation-DGP for which the code in this package is implemented. Currently equals 12. For application on realworld data this parameter is not relevant.</p>
</td></tr>
<tr><td><code id="create_true_beta_+3A_extra_beta_factor">extra_beta_factor</code></td>
<td>
<p>multiplies coefficients in beta_est; default = 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with number of rows equal to number of observable variables + 1 (the first row contains the intercept) and number of culumns
equal to the true number of groups.
</p>

<hr>
<h2 id='define_C_candidates'>Defines the candidate values for C.</h2><span id='topic+define_C_candidates'></span>

<h3>Description</h3>

<p>Defines the candidate values for C.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_C_candidates()
</code></pre>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>define_C_candidates()
</code></pre>

<hr>
<h2 id='define_configurations'>Constructs dataframe where the rows contains all configurations that are included and for which the estimators will be estimated.</h2><span id='topic+define_configurations'></span>

<h3>Description</h3>

<p>Constructs dataframe where the rows contains all configurations that are included and for which the estimators will be estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_configurations(S_cand, k_cand, kg_cand)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_configurations_+3A_s_cand">S_cand</code></td>
<td>
<p>candidates for S (number of groups)</p>
</td></tr>
<tr><td><code id="define_configurations_+3A_k_cand">k_cand</code></td>
<td>
<p>candidates for k (number of common factors)</p>
</td></tr>
<tr><td><code id="define_configurations_+3A_kg_cand">kg_cand</code></td>
<td>
<p>candidates for kg (number of group specific factors)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>define_configurations(2:4, 0, 2:3)
</code></pre>

<hr>
<h2 id='define_kg_candidates'>Defines the set of combinations of group specific factors.</h2><span id='topic+define_kg_candidates'></span>

<h3>Description</h3>

<p>Defines the set of combinations of group specific factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_kg_candidates(S, kg_min, kg_max, nfv = TRUE, limit_est_groups = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_kg_candidates_+3A_s">S</code></td>
<td>
<p>number of estimated groups</p>
</td></tr>
<tr><td><code id="define_kg_candidates_+3A_kg_min">kg_min</code></td>
<td>
<p>minimum value for number of group specific factors</p>
</td></tr>
<tr><td><code id="define_kg_candidates_+3A_kg_max">kg_max</code></td>
<td>
<p>minimum value for number of group specific factors</p>
</td></tr>
<tr><td><code id="define_kg_candidates_+3A_nfv">nfv</code></td>
<td>
<p>logical; whether the number of group specific factors is allowed to change among the groups</p>
</td></tr>
<tr><td><code id="define_kg_candidates_+3A_limit_est_groups">limit_est_groups</code></td>
<td>
<p>maximum allowed number of groups that can be estimated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame where each row contains the number of group specific factors for all the estimated groups.
The number of columns is set to 20 (the current maximum amount of group that can be estimated)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>define_kg_candidates(3, 2, 4)
</code></pre>

<hr>
<h2 id='define_number_subsets'>Returns a vector with the indices of the subsets. Must start with zero.</h2><span id='topic+define_number_subsets'></span>

<h3>Description</h3>

<p>Returns a vector with the indices of the subsets. Must start with zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_number_subsets(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_number_subsets_+3A_n">n</code></td>
<td>
<p>number of subsets</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>define_number_subsets(3)
</code></pre>

<hr>
<h2 id='define_object_for_initial_clustering_macropca'>Defines the object that will be used to define a initial clustering.</h2><span id='topic+define_object_for_initial_clustering_macropca'></span>

<h3>Description</h3>

<p>This is a short version of define_object_for_initial_clustering() which only contains implementations for robust macropca case and classical case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_object_for_initial_clustering_macropca(
  Y,
  k,
  kg,
  comfactor,
  robust,
  method_estimate_beta = "individual",
  method_estimate_factors = "macro",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_object_for_initial_clustering_macropca_+3A_y">Y</code></td>
<td>
<p>Y: NxT dataframe with the panel data of interest</p>
</td></tr>
<tr><td><code id="define_object_for_initial_clustering_macropca_+3A_k">k</code></td>
<td>
<p>number of common factors to be estimated</p>
</td></tr>
<tr><td><code id="define_object_for_initial_clustering_macropca_+3A_kg">kg</code></td>
<td>
<p>number of group specific factors to be estimated</p>
</td></tr>
<tr><td><code id="define_object_for_initial_clustering_macropca_+3A_comfactor">comfactor</code></td>
<td>
<p>estimated common factors</p>
</td></tr>
<tr><td><code id="define_object_for_initial_clustering_macropca_+3A_robust">robust</code></td>
<td>
<p>TRUE or FALSE: defines using the classical or robust algorithm to estimate beta</p>
</td></tr>
<tr><td><code id="define_object_for_initial_clustering_macropca_+3A_method_estimate_beta">method_estimate_beta</code></td>
<td>
<p>defines how beta is estimated. Default case is an estimated beta for each individual. Default value is &quot;individual.&quot; Possible values are &quot;homogeneous&quot;, &quot;group&quot; or &quot;individual&quot;.</p>
</td></tr>
<tr><td><code id="define_object_for_initial_clustering_macropca_+3A_method_estimate_factors">method_estimate_factors</code></td>
<td>
<p>specifies the robust algorithm to estimate factors: default is &quot;macro&quot;. The value is not used when robust is set to FALSE.</p>
</td></tr>
<tr><td><code id="define_object_for_initial_clustering_macropca_+3A_verbose">verbose</code></td>
<td>
<p>when TRUE, it prints messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with N rows and 10 columns
</p>

<hr>
<h2 id='define_rho_parameters'>Determines parameters of rho-function.</h2><span id='topic+define_rho_parameters'></span>

<h3>Description</h3>

<p>Robust updating of group membership is based on a rho function (instead of the non-robust quadratic function) on the norm of the errors.
This requires parameters of location and scale.
They are defined here (currently as median and madn).
This function is applied on the estimated errors: Y - XB - FL - FgLg.
This function is used in update_g().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_rho_parameters(object = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_rho_parameters_+3A_object">object</code></td>
<td>
<p>input</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>

<hr>
<h2 id='determine_beta'>Helpfunction in estimate_beta() for estimating beta_est.</h2><span id='topic+determine_beta'></span>

<h3>Description</h3>

<p>Helpfunction in estimate_beta() for estimating beta_est.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>determine_beta(
  string,
  X_special,
  Y_special,
  robust,
  NN,
  TT,
  S,
  method_estimate_beta,
  initialisation = FALSE,
  indices = NA,
  vars_est,
  sigma2,
  nosetting_local = FALSE,
  kappa_candidates = c(2^(-0:-20), 0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="determine_beta_+3A_string">string</code></td>
<td>
<p>can have values: &quot;homogeneous&quot; (when one beta_est is estimated for all individuals together) or &quot;heterogeneous&quot; (when beta_est is estimated either groupwise or elementwise)</p>
</td></tr>
<tr><td><code id="determine_beta_+3A_x_special">X_special</code></td>
<td>
<p>preprocessed X (2-dimensional matrix with 'var_est' observable variables)</p>
</td></tr>
<tr><td><code id="determine_beta_+3A_y_special">Y_special</code></td>
<td>
<p>preprocessed Y</p>
</td></tr>
<tr><td><code id="determine_beta_+3A_robust">robust</code></td>
<td>
<p>robust or classical estimation</p>
</td></tr>
<tr><td><code id="determine_beta_+3A_nn">NN</code></td>
<td>
<p>number of time series</p>
</td></tr>
<tr><td><code id="determine_beta_+3A_tt">TT</code></td>
<td>
<p>length of time series</p>
</td></tr>
<tr><td><code id="determine_beta_+3A_s">S</code></td>
<td>
<p>estimated number of groups</p>
</td></tr>
<tr><td><code id="determine_beta_+3A_method_estimate_beta">method_estimate_beta</code></td>
<td>
<p>defines how beta is estimated. Default case is an estimated beta for each individual. Default value is &quot;individual.&quot; Possible values are &quot;homogeneous&quot;, &quot;group&quot; or &quot;individual&quot;.</p>
</td></tr>
<tr><td><code id="determine_beta_+3A_initialisation">initialisation</code></td>
<td>
<p>indicator of being in the initialisation phase</p>
</td></tr>
<tr><td><code id="determine_beta_+3A_indices">indices</code></td>
<td>
<p>individuals for which beta_est is being estimated</p>
</td></tr>
<tr><td><code id="determine_beta_+3A_vars_est">vars_est</code></td>
<td>
<p>number of available observed variables for which a coefficient will be estimated. As default it is equal to the number of available observed variables.</p>
</td></tr>
<tr><td><code id="determine_beta_+3A_sigma2">sigma2</code></td>
<td>
<p>sum of squared error terms, scaled by NT</p>
</td></tr>
<tr><td><code id="determine_beta_+3A_nosetting_local">nosetting_local</code></td>
<td>
<p>option to remove the recommended setting in lmrob(). It is much faster. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="determine_beta_+3A_kappa_candidates">kappa_candidates</code></td>
<td>
<p>Defines the size of the SCAD-penalty used in the classical algorithm. This vector should contain more than 1 element.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a numeric vector (for the default setting: string == &quot;heterogeneous&quot;) or a matrix with the estimated beta (if string == &quot;homogeneous&quot;).
</p>

<hr>
<h2 id='determine_robust_lambda'>Help-function for return_robust_lambdaobject().</h2><span id='topic+determine_robust_lambda'></span>

<h3>Description</h3>

<p>Uses the &quot;almost classical lambda&quot; (=matrix where the mean of each row is equal to the classical lambda) to create a robust lambda by using M estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>determine_robust_lambda(
  almost_classical_lambda,
  fastoption = TRUE,
  fastoption2 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="determine_robust_lambda_+3A_almost_classical_lambda">almost_classical_lambda</code></td>
<td>
<p>matrix where the mean of each row is equal to the classical lambda</p>
</td></tr>
<tr><td><code id="determine_robust_lambda_+3A_fastoption">fastoption</code></td>
<td>
<p>Uses nlm() instead of optim(). This is faster.</p>
</td></tr>
<tr><td><code id="determine_robust_lambda_+3A_fastoption2">fastoption2</code></td>
<td>
<p>experimental parameter: can speed nlm() up (10%), but loses accuracy. May benefit from finetuning.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>M-estimator of location of the parameter, by minimizing sum of rho()
</p>

<hr>
<h2 id='df_results_example'>An example for df_results. This dataframe contains the estimators for each configuration.</h2><span id='topic+df_results_example'></span>

<h3>Description</h3>

<p>An example for df_results. This dataframe contains the estimators for each configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_results_example
</code></pre>


<h3>Format</h3>

<p>Dataframe with 4 rows (one for each configuration) and 11 columns:
</p>

<dl>
<dt>S</dt><dd><p>number of groups</p>
</dd>
<dt>k_common</dt><dd><p>number of common factors</p>
</dd>
<dt>k1</dt><dd><p>number of group specific factors in group 1</p>
</dd>
<dt>k2</dt><dd><p>number of group specific factors in group 2</p>
</dd>
<dt>k3</dt><dd><p>number of group specific factors in group 3</p>
</dd>
<dt>g</dt><dd><p>estimated group membership</p>
</dd>
<dt>beta_est</dt><dd><p>estimated beta</p>
</dd>
<dt>factor_group</dt><dd><p>estimated group specific factors</p>
</dd>
<dt>lambda_group</dt><dd><p>estimated loadings to the group specific factors</p>
</dd>
<dt>comfactor</dt><dd><p>estimated common factors</p>
</dd>
<dt>lambda_group</dt><dd><p>estimated loadings to the common factors</p>
</dd>
</dl>


<hr>
<h2 id='do_we_estimate_common_factors'>Helpfunction to shorten code: are common factors being estimated.</h2><span id='topic+do_we_estimate_common_factors'></span>

<h3>Description</h3>

<p>Helpfunction to shorten code: are common factors being estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_we_estimate_common_factors(k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_we_estimate_common_factors_+3A_k">k</code></td>
<td>
<p>number of common factors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric: 0 or 1
</p>

<hr>
<h2 id='do_we_estimate_group_factors'>Helpfunction to shorten code: are group factors being estimated.</h2><span id='topic+do_we_estimate_group_factors'></span>

<h3>Description</h3>

<p>Helpfunction to shorten code: are group factors being estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_we_estimate_group_factors(kg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_we_estimate_group_factors_+3A_kg">kg</code></td>
<td>
<p>number of group factors to be estimated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric: 0 or 1
</p>

<hr>
<h2 id='estimate_algorithm'>This function is a wrapper around the initialization and the estimation part of the algorithm, for one configuration. It is only used for the serialized algorithm.</h2><span id='topic+estimate_algorithm'></span>

<h3>Description</h3>

<p>This function is a wrapper around the initialization and the estimation part of the algorithm, for one configuration. It is only used for the serialized algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_algorithm(Y, X, S, k, kg, maxit = 30, robust = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_algorithm_+3A_y">Y</code></td>
<td>
<p>Y: NxT dataframe with the panel data of interest</p>
</td></tr>
<tr><td><code id="estimate_algorithm_+3A_x">X</code></td>
<td>
<p>X: NxTxp array containing the observable variables</p>
</td></tr>
<tr><td><code id="estimate_algorithm_+3A_s">S</code></td>
<td>
<p>number of estimated groups</p>
</td></tr>
<tr><td><code id="estimate_algorithm_+3A_k">k</code></td>
<td>
<p>number of common factors to be estimated</p>
</td></tr>
<tr><td><code id="estimate_algorithm_+3A_kg">kg</code></td>
<td>
<p>number of group specific factors to be estimated</p>
</td></tr>
<tr><td><code id="estimate_algorithm_+3A_maxit">maxit</code></td>
<td>
<p>maximum limit for the number of iterations</p>
</td></tr>
<tr><td><code id="estimate_algorithm_+3A_robust">robust</code></td>
<td>
<p>TRUE or FALSE: defines using the classical or robust algorithm to estimate beta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with
</p>

<ol>
<li><p> estimated beta
</p>
</li>
<li><p> vector with group membership
</p>
</li>
<li><p> matrix with the common factor(s) (contains zero's if there are none estimated)
</p>
</li>
<li><p> loadings to the common factor(s)
</p>
</li>
<li><p> list with the group specific factors for each of the groups
</p>
</li>
<li><p> data.frame with loadings to the group specific factors augmented with group membership and id (to have the order of the time series)
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
original_data &lt;- create_data_dgp2(60, 30)
Y &lt;- original_data[[1]]
X &lt;- original_data[[2]]
estimate_algorithm(Y, X, 3, 0, c(3,3,3), maxit = 2, robust = TRUE)

</code></pre>

<hr>
<h2 id='estimate_beta'>Estimates beta.</h2><span id='topic+estimate_beta'></span>

<h3>Description</h3>

<p>Update step of algorithm to obtain new estimation for beta. Note that we call it beta_est because beta() exists in base R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_beta(
  Y,
  X,
  beta_est,
  g,
  lambda_group,
  factor_group,
  lambda,
  comfactor,
  method_estimate_beta = "individual",
  S,
  k,
  kg,
  vars_est,
  robust,
  num_factors_may_vary = TRUE,
  optimize_kappa = FALSE,
  nosetting = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_beta_+3A_y">Y</code></td>
<td>
<p>Y: NxT dataframe with the panel data of interest</p>
</td></tr>
<tr><td><code id="estimate_beta_+3A_x">X</code></td>
<td>
<p>X: NxTxp array containing the observable variables</p>
</td></tr>
<tr><td><code id="estimate_beta_+3A_beta_est">beta_est</code></td>
<td>
<p>estimated values of beta</p>
</td></tr>
<tr><td><code id="estimate_beta_+3A_g">g</code></td>
<td>
<p>Vector with estimated group membership for all individuals</p>
</td></tr>
<tr><td><code id="estimate_beta_+3A_lambda_group">lambda_group</code></td>
<td>
<p>loadings of the estimated group specific factors</p>
</td></tr>
<tr><td><code id="estimate_beta_+3A_factor_group">factor_group</code></td>
<td>
<p>estimated group specific factors</p>
</td></tr>
<tr><td><code id="estimate_beta_+3A_lambda">lambda</code></td>
<td>
<p>loadings of the estimated common factors</p>
</td></tr>
<tr><td><code id="estimate_beta_+3A_comfactor">comfactor</code></td>
<td>
<p>estimated common factors</p>
</td></tr>
<tr><td><code id="estimate_beta_+3A_method_estimate_beta">method_estimate_beta</code></td>
<td>
<p>defines how beta is estimated. Default case is an estimated beta for each individual. Default value is &quot;individual.&quot; Possible values are &quot;homogeneous&quot;, &quot;group&quot; or &quot;individual&quot;.</p>
</td></tr>
<tr><td><code id="estimate_beta_+3A_s">S</code></td>
<td>
<p>number of estimated groups</p>
</td></tr>
<tr><td><code id="estimate_beta_+3A_k">k</code></td>
<td>
<p>number of common factors to be estimated</p>
</td></tr>
<tr><td><code id="estimate_beta_+3A_kg">kg</code></td>
<td>
<p>number of group specific factors to be estimated</p>
</td></tr>
<tr><td><code id="estimate_beta_+3A_vars_est">vars_est</code></td>
<td>
<p>number of variables that will be included in the algorithm and have their coefficient estimated. This is usually equal to the number of observable variables.</p>
</td></tr>
<tr><td><code id="estimate_beta_+3A_robust">robust</code></td>
<td>
<p>TRUE or FALSE: defines using the classical or robust algorithm to estimate beta</p>
</td></tr>
<tr><td><code id="estimate_beta_+3A_num_factors_may_vary">num_factors_may_vary</code></td>
<td>
<p>whether or not the number of groupfactors is constant over all groups or not</p>
</td></tr>
<tr><td><code id="estimate_beta_+3A_optimize_kappa">optimize_kappa</code></td>
<td>
<p>indicates if kappa has to be optimized or not (only relevant for the classical algorithm)</p>
</td></tr>
<tr><td><code id="estimate_beta_+3A_nosetting">nosetting</code></td>
<td>
<p>option to remove the recommended setting in lmrob(). It is much faster. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list: 1st element contains matrix (N columns: 1 for each time series of the panel data) with estimated beta_est's. If vars_est is set to 0, the list contains NA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
X &lt;- X_dgp3
Y &lt;- Y_dgp3
# Set estimations for group factors and its loadings, and group membership to the true value
lambda_group &lt;- lambda_group_true_dgp3
factor_group &lt;- factor_group_true_dgp3
g &lt;- g_true_dgp3
# There are no common factors to be estimated  -&gt; but needs placeholder
lambda &lt;- matrix(0, nrow = 1, ncol = 300)
comfactor &lt;- matrix(0, nrow = 1, ncol = 30)
#
# Choose how coefficients of the observable variables are estimated
method_estimate_beta &lt;- "individual"
method_estimate_factors &lt;- "macro"
beta_est &lt;- estimate_beta(
  Y, X, NA, g, lambda_group, factor_group,
  lambda, comfactor,
  S = 3, k = 0, kg = c(3, 3, 3),
  vars_est = 3,
  robust = TRUE
)[[1]]

</code></pre>

<hr>
<h2 id='estimate_factor'>Estimates common factor(s) F.</h2><span id='topic+estimate_factor'></span>

<h3>Description</h3>

<p>The estimator for F, see Anderson (1984), is equal to the first k eigenvectors (multiplied by sqrt(T) due to the restriction F'F/T = I)
associated with first r largest eigenvalues of the matrix WW' (which is of size TxT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_factor(
  Y,
  X,
  beta_est,
  g,
  lgfg_list,
  k,
  kg,
  robust,
  method_estimate_beta,
  method_estimate_factors,
  initialise = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_factor_+3A_y">Y</code></td>
<td>
<p>Y: NxT dataframe with the panel data of interest</p>
</td></tr>
<tr><td><code id="estimate_factor_+3A_x">X</code></td>
<td>
<p>X: NxTxp array containing the observable variables</p>
</td></tr>
<tr><td><code id="estimate_factor_+3A_beta_est">beta_est</code></td>
<td>
<p>estimated values of beta</p>
</td></tr>
<tr><td><code id="estimate_factor_+3A_g">g</code></td>
<td>
<p>Vector with group membership for all individuals</p>
</td></tr>
<tr><td><code id="estimate_factor_+3A_lgfg_list">lgfg_list</code></td>
<td>
<p>This is a list (length number of groups) containing FgLg for every group.</p>
</td></tr>
<tr><td><code id="estimate_factor_+3A_k">k</code></td>
<td>
<p>number of common factors to be estimated</p>
</td></tr>
<tr><td><code id="estimate_factor_+3A_kg">kg</code></td>
<td>
<p>number of group specific factors to be estimated</p>
</td></tr>
<tr><td><code id="estimate_factor_+3A_robust">robust</code></td>
<td>
<p>TRUE or FALSE: defines using the classical or robust algorithm to estimate beta</p>
</td></tr>
<tr><td><code id="estimate_factor_+3A_method_estimate_beta">method_estimate_beta</code></td>
<td>
<p>defines how beta is estimated. Default case is an estimated beta for each individual. Default value is &quot;individual.&quot; Possible values are &quot;homogeneous&quot;, &quot;group&quot; or &quot;individual&quot;.</p>
</td></tr>
<tr><td><code id="estimate_factor_+3A_method_estimate_factors">method_estimate_factors</code></td>
<td>
<p>defines method of robust estimaton of the factors: &quot;macro&quot;, &quot;pertmm&quot; or &quot;cz&quot;</p>
</td></tr>
<tr><td><code id="estimate_factor_+3A_initialise">initialise</code></td>
<td>
<p>indicator of being in the initialisation phase</p>
</td></tr>
<tr><td><code id="estimate_factor_+3A_verbose">verbose</code></td>
<td>
<p>when TRUE, it prints messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list. The first element contains the k x T matrix with the k estimated common factors. The second element contains either the
robust MacroPCA-based loadings or NA.
</p>

<hr>
<h2 id='estimate_factor_group'>Estimates group factors Fg.</h2><span id='topic+estimate_factor_group'></span>

<h3>Description</h3>

<p>Estimates group factors Fg.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_factor_group(
  Y,
  X,
  beta_est,
  g,
  lambda,
  comfactor,
  factor_group,
  S,
  k,
  kg,
  robust,
  method_estimate_beta = "individual",
  method_estimate_factors = "macro",
  initialise = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_factor_group_+3A_y">Y</code></td>
<td>
<p>Y: NxT dataframe with the panel data of interest</p>
</td></tr>
<tr><td><code id="estimate_factor_group_+3A_x">X</code></td>
<td>
<p>X: NxTxp array containing the observable variables</p>
</td></tr>
<tr><td><code id="estimate_factor_group_+3A_beta_est">beta_est</code></td>
<td>
<p>estimated values of beta</p>
</td></tr>
<tr><td><code id="estimate_factor_group_+3A_g">g</code></td>
<td>
<p>Vector with group membership for all individuals</p>
</td></tr>
<tr><td><code id="estimate_factor_group_+3A_lambda">lambda</code></td>
<td>
<p>loadings of the estimated common factors</p>
</td></tr>
<tr><td><code id="estimate_factor_group_+3A_comfactor">comfactor</code></td>
<td>
<p>estimated common factors</p>
</td></tr>
<tr><td><code id="estimate_factor_group_+3A_factor_group">factor_group</code></td>
<td>
<p>estimated group specific factors</p>
</td></tr>
<tr><td><code id="estimate_factor_group_+3A_s">S</code></td>
<td>
<p>number of estimated groups</p>
</td></tr>
<tr><td><code id="estimate_factor_group_+3A_k">k</code></td>
<td>
<p>number of common factors to be estimated</p>
</td></tr>
<tr><td><code id="estimate_factor_group_+3A_kg">kg</code></td>
<td>
<p>number of group specific factors to be estimated</p>
</td></tr>
<tr><td><code id="estimate_factor_group_+3A_robust">robust</code></td>
<td>
<p>TRUE or FALSE: defines using the classical or robust algorithm to estimate beta</p>
</td></tr>
<tr><td><code id="estimate_factor_group_+3A_method_estimate_beta">method_estimate_beta</code></td>
<td>
<p>defines how beta is estimated. Default case is an estimated beta for each individual. Default value is &quot;individual.&quot; Possible values are &quot;homogeneous&quot;, &quot;group&quot; or &quot;individual&quot;.</p>
</td></tr>
<tr><td><code id="estimate_factor_group_+3A_method_estimate_factors">method_estimate_factors</code></td>
<td>
<p>defines method of robust estimaton of the factors: &quot;macro&quot;, &quot;pertmm&quot; or &quot;cz&quot;</p>
</td></tr>
<tr><td><code id="estimate_factor_group_+3A_initialise">initialise</code></td>
<td>
<p>indicator of being in the initialisation phase</p>
</td></tr>
<tr><td><code id="estimate_factor_group_+3A_verbose">verbose</code></td>
<td>
<p>when TRUE, it prints messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with an element for each estimated group. Each element of the list is a matrix with the group specific factors as rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#example with data generated with DGP 2
data &lt;- create_data_dgp2(30, 10)
Y &lt;- data[[1]]
X &lt;- data[[2]]
g &lt;- data[[3]] #true group membership
set.seed(1)
beta_est &lt;- matrix(rnorm(4 * nrow(Y)), nrow = 4)
factor_group &lt;- data[[5]] #true values of group specific factors
comfactor &lt;- matrix(0, nrow = 1, ncol = ncol(Y))
lambda &lt;- matrix(0, nrow = 1, ncol = nrow(Y))
estimate_factor_group(Y, X, beta_est, g, lambda, comfactor, factor_group,
3, 0, c(3, 3, 3), TRUE)
</code></pre>

<hr>
<h2 id='evade_crashes_macropca'>Solves a very specific issue with MacroPCA.</h2><span id='topic+evade_crashes_macropca'></span>

<h3>Description</h3>

<p>MacroPCA crashes Rstudio with certain dimensions of the input. Solve this by doubling every row.
No information is added by this, so there is no influence on the end result,
but crashes of Rstudio are evaded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evade_crashes_macropca(object, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evade_crashes_macropca_+3A_object">object</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="evade_crashes_macropca_+3A_verbose">verbose</code></td>
<td>
<p>prints messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>

<hr>
<h2 id='evade_floating_point_errors'>Function to evade floating point errors.</h2><span id='topic+evade_floating_point_errors'></span>

<h3>Description</h3>

<p>Sets values that should be zero but are &gt;0 (e.g. 1e-13) on zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evade_floating_point_errors(x, LIMIT = 1e-13)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evade_floating_point_errors_+3A_x">x</code></td>
<td>
<p>numeric input</p>
</td></tr>
<tr><td><code id="evade_floating_point_errors_+3A_limit">LIMIT</code></td>
<td>
<p>limit under which value is set to 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>

<hr>
<h2 id='factor_group_true_dgp3'>factor_group_true_dgp3 contains the values of the true group factors on which Y_dgp3 is based</h2><span id='topic+factor_group_true_dgp3'></span>

<h3>Description</h3>

<p>factor_group_true_dgp3 contains the values of the true group factors on which Y_dgp3 is based
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factor_group_true_dgp3
</code></pre>


<h3>Format</h3>

<p>list with length 3: each element has dimension 3 x 30
</p>

<hr>
<h2 id='fill_rc'>Fills in the optimized number of common factors for each C.</h2><span id='topic+fill_rc'></span>

<h3>Description</h3>

<p>Fills in the optimized number of common factors for each C.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_rc(df, all_best_values, subset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_rc_+3A_df">df</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="fill_rc_+3A_all_best_values">all_best_values</code></td>
<td>
<p>data frame with the optimal number of groups, common factors and group specific factors</p>
</td></tr>
<tr><td><code id="fill_rc_+3A_subset">subset</code></td>
<td>
<p>index of the subsample</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df_results &lt;- add_configuration(initialise_df_results(TRUE),
  3, 0, c(3, 3, 3, rep(NA, 17))) #data.frame with one configuration
all_best_values &lt;- calculate_best_config(df_results, data.frame(t(1:5)), 1:5)
rc &lt;- fill_rc(initialise_rc(0:2, 1:5), all_best_values, 1)
</code></pre>

<hr>
<h2 id='fill_rcj'>Fills in the optimized number of groups and group specific factors for each C.</h2><span id='topic+fill_rcj'></span>

<h3>Description</h3>

<p>Fills in the optimized number of groups and group specific factors for each C.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_rcj(df, all_best_values, subset, S_cand, kg_cand)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_rcj_+3A_df">df</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="fill_rcj_+3A_all_best_values">all_best_values</code></td>
<td>
<p>data frame with the optimal number of groups, common factors and group specific factors</p>
</td></tr>
<tr><td><code id="fill_rcj_+3A_subset">subset</code></td>
<td>
<p>index of the subsample</p>
</td></tr>
<tr><td><code id="fill_rcj_+3A_s_cand">S_cand</code></td>
<td>
<p>vector with candidate values for the number of estimated groups</p>
</td></tr>
<tr><td><code id="fill_rcj_+3A_kg_cand">kg_cand</code></td>
<td>
<p>vector with candidate values for the number of estimated group specific factors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df_results &lt;- add_configuration(initialise_df_results(TRUE),
  3, 0, c(3, 3, 3, rep(NA, 17))) #data.frame with one configuration
all_best_values &lt;- calculate_best_config(df_results, data.frame(t(1:5)), 1:5)
rcj &lt;- fill_rcj(initialise_rcj(0:2, 1:5) , all_best_values, 1, 2:4, 2:4)
</code></pre>

<hr>
<h2 id='final_estimations_filter_kg'>Filters dataframe on the requested group specific factors configuration.</h2><span id='topic+final_estimations_filter_kg'></span>

<h3>Description</h3>

<p>Filters dataframe on the requested group specific factors configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>final_estimations_filter_kg(df, kg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="final_estimations_filter_kg_+3A_df">df</code></td>
<td>
<p>input dataframe</p>
</td></tr>
<tr><td><code id="final_estimations_filter_kg_+3A_kg">kg</code></td>
<td>
<p>vector with number of group specific factors for each group, on which should be filtered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>

<hr>
<h2 id='g_true_dgp3'>g_true_dgp3 contains the true group memberships of the elements of Y_dgp3</h2><span id='topic+g_true_dgp3'></span>

<h3>Description</h3>

<p>g_true_dgp3 contains the true group memberships of the elements of Y_dgp3
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_true_dgp3
</code></pre>


<h3>Format</h3>

<p>vector with 300 elements
</p>


<h3>Examples</h3>

<pre><code class='language-R'>table(g_true_dgp3)
</code></pre>

<hr>
<h2 id='generate_grouped_factorstructure'>Generates the true groupfactorstructure, to use in simulations.</h2><span id='topic+generate_grouped_factorstructure'></span>

<h3>Description</h3>

<p>Loadings and factors are generated by:
factors ~ N(j * fgr_factor_mean, fgr_factor_sd) -&gt; default case will be N(j, 1)
loadings ~ N(lgr_factor_mean, j * lgr_factor_sd) -&gt; default case will be N(0, j)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_grouped_factorstructure(
  S,
  kg_true,
  TT,
  g_true,
  lgr_factor_mean = 0,
  lgr_factor_sd = 1,
  fgr_factor_mean = 1,
  fgr_factor_sd = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_grouped_factorstructure_+3A_s">S</code></td>
<td>
<p>true number of groups</p>
</td></tr>
<tr><td><code id="generate_grouped_factorstructure_+3A_kg_true">kg_true</code></td>
<td>
<p>vector with as length the number of groups, where each element is the true number of groupfactors of that group.</p>
</td></tr>
<tr><td><code id="generate_grouped_factorstructure_+3A_tt">TT</code></td>
<td>
<p>length of time series</p>
</td></tr>
<tr><td><code id="generate_grouped_factorstructure_+3A_g_true">g_true</code></td>
<td>
<p>vector of length NN with true group memberships</p>
</td></tr>
<tr><td><code id="generate_grouped_factorstructure_+3A_lgr_factor_mean">lgr_factor_mean</code></td>
<td>
<p>mean of the normal distribution from which the loadings are generated</p>
</td></tr>
<tr><td><code id="generate_grouped_factorstructure_+3A_lgr_factor_sd">lgr_factor_sd</code></td>
<td>
<p>sd of the normal distribution from which the loadings are generated (multiplied by a coefficient for each different group)</p>
</td></tr>
<tr><td><code id="generate_grouped_factorstructure_+3A_fgr_factor_mean">fgr_factor_mean</code></td>
<td>
<p>mean of the normal distribution from which the group specific factors are generated (multiplied by a coefficient for each different group)</p>
</td></tr>
<tr><td><code id="generate_grouped_factorstructure_+3A_fgr_factor_sd">fgr_factor_sd</code></td>
<td>
<p>sd of the normal distribution from which the group specific factors are generated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list: first element contains the true group specific factors and the second element contains the corresponding loadings
</p>

<hr>
<h2 id='generate_Y'>Generate panel data Y for simulations.</h2><span id='topic+generate_Y'></span>

<h3>Description</h3>

<p>Generate panel data Y for simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_Y(
  NN,
  TT,
  k_true,
  kg_true,
  g_true,
  beta_true,
  lambda_group_true,
  factor_group_true,
  lambda_true,
  comfactor_true,
  eps,
  X
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_Y_+3A_nn">NN</code></td>
<td>
<p>number of time series</p>
</td></tr>
<tr><td><code id="generate_Y_+3A_tt">TT</code></td>
<td>
<p>length of time series</p>
</td></tr>
<tr><td><code id="generate_Y_+3A_k_true">k_true</code></td>
<td>
<p>true number of common factors</p>
</td></tr>
<tr><td><code id="generate_Y_+3A_kg_true">kg_true</code></td>
<td>
<p>Vector of length the number of groups. Each element contains the true number of group factors for that group.</p>
</td></tr>
<tr><td><code id="generate_Y_+3A_g_true">g_true</code></td>
<td>
<p>vector of length NN with true group memberships</p>
</td></tr>
<tr><td><code id="generate_Y_+3A_beta_true">beta_true</code></td>
<td>
<p>true coefficients of the observable variables</p>
</td></tr>
<tr><td><code id="generate_Y_+3A_lambda_group_true">lambda_group_true</code></td>
<td>
<p>loadings of the true group specific factors</p>
</td></tr>
<tr><td><code id="generate_Y_+3A_factor_group_true">factor_group_true</code></td>
<td>
<p>true group specific factors</p>
</td></tr>
<tr><td><code id="generate_Y_+3A_lambda_true">lambda_true</code></td>
<td>
<p>loadings of the true common factors</p>
</td></tr>
<tr><td><code id="generate_Y_+3A_comfactor_true">comfactor_true</code></td>
<td>
<p>true common factors</p>
</td></tr>
<tr><td><code id="generate_Y_+3A_eps">eps</code></td>
<td>
<p>NN x TT-matrix containing the error term</p>
</td></tr>
<tr><td><code id="generate_Y_+3A_x">X</code></td>
<td>
<p>dataframe with the observed variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NN x TT matrix
</p>

<hr>
<h2 id='get_best_configuration'>Finds the first stable interval after the first unstable point. It then defines the value for C for the begin, middle and end of this interval.</h2><span id='topic+get_best_configuration'></span>

<h3>Description</h3>

<p>Finds the first stable interval after the first unstable point. It then defines the value for C for the begin, middle and end of this interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_best_configuration(
  list_vc,
  list_rc,
  list_rcj,
  C_candidates,
  S_cand,
  return_short = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_best_configuration_+3A_list_vc">list_vc</code></td>
<td>
<p>list with resulting expression(VC^2) for each run</p>
</td></tr>
<tr><td><code id="get_best_configuration_+3A_list_rc">list_rc</code></td>
<td>
<p>list with resulting rc for each run</p>
</td></tr>
<tr><td><code id="get_best_configuration_+3A_list_rcj">list_rcj</code></td>
<td>
<p>list with resulting rcj for each run</p>
</td></tr>
<tr><td><code id="get_best_configuration_+3A_c_candidates">C_candidates</code></td>
<td>
<p>candidates for C</p>
</td></tr>
<tr><td><code id="get_best_configuration_+3A_s_cand">S_cand</code></td>
<td>
<p>candidates for S (number of groups)</p>
</td></tr>
<tr><td><code id="get_best_configuration_+3A_return_short">return_short</code></td>
<td>
<p>if TRUE, the function returns the dataframe filtered for several specified potential candidates for C</p>
</td></tr>
<tr><td><code id="get_best_configuration_+3A_verbose">verbose</code></td>
<td>
<p>when TRUE, it prints messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with the optimized configuration for each candidate C (if return_short is FALSE) and
for each of the selected C's in the chosen stable interval (if return_short is TRUE).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
all_best_values &lt;- calculate_best_config(add_configuration(initialise_df_results(TRUE),
  3, 0, c(3, 3, 3, rep(NA, 17))),
  data.frame(t(1:5)), 1:5)
rc &lt;- fill_rc(initialise_rc(0:1, 1:5), all_best_values, 0)
rc &lt;- fill_rc(rc, all_best_values, 1)
rcj &lt;- fill_rcj(initialise_rcj(0:1, 1:5) , all_best_values, 0, 2:4, 2:4)
rcj &lt;- fill_rcj(rcj, all_best_values, 1, 2:4, 2:4)
get_best_configuration(sort(runif(5)), rc, rcj, 1:5, 2:4, return_short = FALSE)
</code></pre>

<hr>
<h2 id='get_convergence_speed'>Defines the convergence speed.</h2><span id='topic+get_convergence_speed'></span>

<h3>Description</h3>

<p>Defines the convergence speed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_convergence_speed(iteration, of)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_convergence_speed_+3A_iteration">iteration</code></td>
<td>
<p>number of iteration</p>
</td></tr>
<tr><td><code id="get_convergence_speed_+3A_of">of</code></td>
<td>
<p>objective function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric if iteration &gt; 3, otherwise NA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_convergence_speed(5, 10:1)
</code></pre>

<hr>
<h2 id='get_final_estimation'>Function that returns the final clustering, based on the estimated number of groups and common and group specific factors.</h2><span id='topic+get_final_estimation'></span>

<h3>Description</h3>

<p>Function that returns the final clustering, based on the estimated number of groups and common and group specific factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_final_estimation(df, opt_groups, k, kg, type, limit_est_groups = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_final_estimation_+3A_df">df</code></td>
<td>
<p>input dataframe (this will be df_results_full)</p>
</td></tr>
<tr><td><code id="get_final_estimation_+3A_opt_groups">opt_groups</code></td>
<td>
<p>the optimal number of groups</p>
</td></tr>
<tr><td><code id="get_final_estimation_+3A_k">k</code></td>
<td>
<p>the optimal number of common factors</p>
</td></tr>
<tr><td><code id="get_final_estimation_+3A_kg">kg</code></td>
<td>
<p>vector with the optimal number of group specific factors</p>
</td></tr>
<tr><td><code id="get_final_estimation_+3A_type">type</code></td>
<td>
<p>defines which estimation to return: options are &quot;clustering&quot;, &quot;beta&quot;, &quot;fg&quot; (group specific factors), &quot;lg&quot; (loadings corresponding to fg), &quot;f&quot; (common factors), &quot;l&quot; (loadings corresponding to f),</p>
</td></tr>
<tr><td><code id="get_final_estimation_+3A_limit_est_groups">limit_est_groups</code></td>
<td>
<p>maximum allowed number of groups that can be estimated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the estimations of the chosen configuration.
If type is &quot;clustering&quot; it returns a numeric vector with the estimated group membership for all time series.
If type is &quot;beta&quot;, &quot;lg&quot; the function returns a data.frame.
If type is &quot;f&quot; or &quot;l&quot; the function also returns a data.frame. If no common factors were estimated in the optimized configuration, then NA is returned.
If type is &quot;fg&quot; the function returns a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_final_estimation(df_results_example, 3, 0, c(3, 3, 3), "clustering")
get_final_estimation(df_results_example, 3, 0, c(3, 3, 3), "beta")
get_final_estimation(df_results_example, 3, 0, c(3, 3, 3), "fg")
get_final_estimation(df_results_example, 3, 0, c(3, 3, 3), "lg")
</code></pre>

<hr>
<h2 id='grid_add_variables'>Function which is used to have a dataframe (called &quot;grid&quot;) with data (individualindex, timeindex, XT and LF) available.</h2><span id='topic+grid_add_variables'></span>

<h3>Description</h3>

<p>It is used in iterate().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_add_variables(
  grid,
  Y,
  X,
  beta_est,
  g,
  lambda,
  comfactor,
  method_estimate_beta,
  vars_est,
  S,
  limit_est_groups_heterogroups = 15
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid_add_variables_+3A_grid">grid</code></td>
<td>
<p>dataframe containing values for X*beta_est and LF (product of common factor and its loadings)</p>
</td></tr>
<tr><td><code id="grid_add_variables_+3A_y">Y</code></td>
<td>
<p>Y: NxT dataframe with the panel data of interest</p>
</td></tr>
<tr><td><code id="grid_add_variables_+3A_x">X</code></td>
<td>
<p>X: NxTxp array containing the observable variables</p>
</td></tr>
<tr><td><code id="grid_add_variables_+3A_beta_est">beta_est</code></td>
<td>
<p>estimated values of beta</p>
</td></tr>
<tr><td><code id="grid_add_variables_+3A_g">g</code></td>
<td>
<p>Vector with estimated group membership for all individuals</p>
</td></tr>
<tr><td><code id="grid_add_variables_+3A_lambda">lambda</code></td>
<td>
<p>loadings of the estimated common factors</p>
</td></tr>
<tr><td><code id="grid_add_variables_+3A_comfactor">comfactor</code></td>
<td>
<p>estimated common factors</p>
</td></tr>
<tr><td><code id="grid_add_variables_+3A_method_estimate_beta">method_estimate_beta</code></td>
<td>
<p>defines how beta is estimated. Default case is an estimated beta for each individual. Default value is &quot;individual.&quot; Possible values are &quot;homogeneous&quot;, &quot;group&quot; or &quot;individual&quot;.</p>
</td></tr>
<tr><td><code id="grid_add_variables_+3A_vars_est">vars_est</code></td>
<td>
<p>number of variables that will be included in the algorithm and have their coefficient estimated. This is usually equal to the number of observable variables.</p>
</td></tr>
<tr><td><code id="grid_add_variables_+3A_s">S</code></td>
<td>
<p>number of estimated groups</p>
</td></tr>
<tr><td><code id="grid_add_variables_+3A_limit_est_groups_heterogroups">limit_est_groups_heterogroups</code></td>
<td>
<p>maximum amount of groups that can be estimated when method_estimate_beta is set to &quot;group&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>

<hr>
<h2 id='handle_macropca_errors'>Helpfunction in robustpca().</h2><span id='topic+handle_macropca_errors'></span>

<h3>Description</h3>

<p>It handles possible thrown errors in MacroPCA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_macropca_errors(
  object,
  temp,
  KMAX,
  number_eigenvectors,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_macropca_errors_+3A_object">object</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="handle_macropca_errors_+3A_temp">temp</code></td>
<td>
<p>this is the result of the trycatch block of using macropca on object</p>
</td></tr>
<tr><td><code id="handle_macropca_errors_+3A_kmax">KMAX</code></td>
<td>
<p>parameter kmax in MacroPCA</p>
</td></tr>
<tr><td><code id="handle_macropca_errors_+3A_number_eigenvectors">number_eigenvectors</code></td>
<td>
<p>number of principal components that are needed</p>
</td></tr>
<tr><td><code id="handle_macropca_errors_+3A_verbose">verbose</code></td>
<td>
<p>when TRUE, it prints messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of which the columns contain the chosen amount of eigenvectors of object
</p>

<hr>
<h2 id='handleNA'>Function with as input a dataframe. (this will be &quot;Y&quot; or &quot;to_divide&quot;) It filters out rows with NA.</h2><span id='topic+handleNA'></span>

<h3>Description</h3>

<p>Function with as input a dataframe. (this will be &quot;Y&quot; or &quot;to_divide&quot;) It filters out rows with NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handleNA(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handleNA_+3A_df">df</code></td>
<td>
<p>input</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with a dataframe where the rows with NA are filtered out, and a dataframe with only those rows
</p>

<hr>
<h2 id='handleNA_LG'>Removes NA's in LG (in function calculate_virtual_factor_and_lambda_group() )</h2><span id='topic+handleNA_LG'></span>

<h3>Description</h3>

<p>Removes NA's in LG (in function calculate_virtual_factor_and_lambda_group() )
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handleNA_LG(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handleNA_LG_+3A_df">df</code></td>
<td>
<p>input</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>

<hr>
<h2 id='initialise_beta'>Initialisation of estimation of beta (the coefficients with the observable variables)</h2><span id='topic+initialise_beta'></span>

<h3>Description</h3>

<p>Note: this needs to be called before the definition of grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialise_beta(
  Y,
  X,
  S,
  robust,
  method_estimate_beta = "individual",
  nosetting_lmrob = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialise_beta_+3A_y">Y</code></td>
<td>
<p>Y: NxT dataframe with the panel data of interest</p>
</td></tr>
<tr><td><code id="initialise_beta_+3A_x">X</code></td>
<td>
<p>dataframe with the observed variables</p>
</td></tr>
<tr><td><code id="initialise_beta_+3A_s">S</code></td>
<td>
<p>estimated number of groups</p>
</td></tr>
<tr><td><code id="initialise_beta_+3A_robust">robust</code></td>
<td>
<p>robust or classical estimation</p>
</td></tr>
<tr><td><code id="initialise_beta_+3A_method_estimate_beta">method_estimate_beta</code></td>
<td>
<p>defines how beta is estimated. Default case is an estimated beta for each individual. Default value is &quot;individual.&quot; Possible values are &quot;homogeneous&quot;, &quot;group&quot; or &quot;individual&quot;.</p>
</td></tr>
<tr><td><code id="initialise_beta_+3A_nosetting_lmrob">nosetting_lmrob</code></td>
<td>
<p>option to remove the recommended setting in lmrob(). It is much faster. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with number of rows equal to the number of estimated variables plus one. If method_estimate_beta is set to the default (&quot;individual&quot;),
the number of columns is equal to the number of time series in Y. If method_estimate_beta is set to &quot;group&quot; or to &quot;homogeneous&quot; the number of columns
is equal to the number of groups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
X &lt;- X_dgp3
Y &lt;- Y_dgp3
# Set estimations for group factors and its loadings, and group membership
#  to the true value for this example.
lambda_group &lt;- lambda_group_true_dgp3
factor_group &lt;- factor_group_true_dgp3
beta_init &lt;- initialise_beta(Y, X,
  S = 3, TRUE
)

</code></pre>

<hr>
<h2 id='initialise_clustering'>Function that clusters time series in a dataframe with kmeans.</h2><span id='topic+initialise_clustering'></span>

<h3>Description</h3>

<p>If a time series contains NA's a random cluster will be assigned to that time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialise_clustering(
  Y,
  S,
  k,
  kg,
  comfactor,
  robust,
  max_percent_outliers_tkmeans = 0,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialise_clustering_+3A_y">Y</code></td>
<td>
<p>Y: NxT dataframe with the panel data of interest</p>
</td></tr>
<tr><td><code id="initialise_clustering_+3A_s">S</code></td>
<td>
<p>the desired number of groups</p>
</td></tr>
<tr><td><code id="initialise_clustering_+3A_k">k</code></td>
<td>
<p>number of common factors to be estimated</p>
</td></tr>
<tr><td><code id="initialise_clustering_+3A_kg">kg</code></td>
<td>
<p>number of group specific factors to be estimated</p>
</td></tr>
<tr><td><code id="initialise_clustering_+3A_comfactor">comfactor</code></td>
<td>
<p>estimated common factors</p>
</td></tr>
<tr><td><code id="initialise_clustering_+3A_robust">robust</code></td>
<td>
<p>TRUE or FALSE: defines using the classical or robust algorithm to estimate beta</p>
</td></tr>
<tr><td><code id="initialise_clustering_+3A_max_percent_outliers_tkmeans">max_percent_outliers_tkmeans</code></td>
<td>
<p>the proportion of observations to be trimmed</p>
</td></tr>
<tr><td><code id="initialise_clustering_+3A_verbose">verbose</code></td>
<td>
<p>when TRUE, it prints messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- Y_dgp3
comfactor &lt;- matrix(0, nrow = ncol(Y))
initialise_clustering(Y, 3, 0, c(3, 3, 3), comfactor, TRUE)
</code></pre>

<hr>
<h2 id='initialise_commonfactorstructure_macropca'>Initialises the estimation of the common factors and their loadings.</h2><span id='topic+initialise_commonfactorstructure_macropca'></span>

<h3>Description</h3>

<p>This is a short version of initialise_commonfactorstructure() which only contains implementations for the robust macropca case and the classical case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialise_commonfactorstructure_macropca(
  Y,
  X,
  beta_est,
  g,
  factor_group,
  k,
  kg,
  robust,
  method_estimate_beta = "individual",
  method_estimate_factors = "macro",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialise_commonfactorstructure_macropca_+3A_y">Y</code></td>
<td>
<p>Y: NxT dataframe with the panel data of interest</p>
</td></tr>
<tr><td><code id="initialise_commonfactorstructure_macropca_+3A_x">X</code></td>
<td>
<p>dataframe with the observed variables</p>
</td></tr>
<tr><td><code id="initialise_commonfactorstructure_macropca_+3A_beta_est">beta_est</code></td>
<td>
<p>estimated values of beta</p>
</td></tr>
<tr><td><code id="initialise_commonfactorstructure_macropca_+3A_g">g</code></td>
<td>
<p>Vector with estimated group membership for all individuals</p>
</td></tr>
<tr><td><code id="initialise_commonfactorstructure_macropca_+3A_factor_group">factor_group</code></td>
<td>
<p>estimated group specific factors</p>
</td></tr>
<tr><td><code id="initialise_commonfactorstructure_macropca_+3A_k">k</code></td>
<td>
<p>number of estimated common factors</p>
</td></tr>
<tr><td><code id="initialise_commonfactorstructure_macropca_+3A_kg">kg</code></td>
<td>
<p>vector with the number of estimated group specific factors</p>
</td></tr>
<tr><td><code id="initialise_commonfactorstructure_macropca_+3A_robust">robust</code></td>
<td>
<p>TRUE or FALSE: defines using the classical or robust algorithm to estimate beta</p>
</td></tr>
<tr><td><code id="initialise_commonfactorstructure_macropca_+3A_method_estimate_beta">method_estimate_beta</code></td>
<td>
<p>defines how beta is estimated. Default case is an estimated beta for each individual. Default value is &quot;individual.&quot; Possible values are &quot;homogeneous&quot;, &quot;group&quot; or &quot;individual&quot;.</p>
</td></tr>
<tr><td><code id="initialise_commonfactorstructure_macropca_+3A_method_estimate_factors">method_estimate_factors</code></td>
<td>
<p>specifies the robust algorithm to estimate factors: default is &quot;macro&quot;. The value is not used when robust is set to FALSE.</p>
</td></tr>
<tr><td><code id="initialise_commonfactorstructure_macropca_+3A_verbose">verbose</code></td>
<td>
<p>when TRUE, it prints messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list: 1st element contains the common factor(s) and the second element contains the factor loadings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
original_data &lt;- create_data_dgp2(30, 20)
Y &lt;- original_data[[1]]
X &lt;- original_data[[2]]
g &lt;- original_data[[3]]
beta_est &lt;- matrix(rnorm(4 * ncol(Y)), nrow = 4)
initialise_commonfactorstructure_macropca(Y, X, beta_est, g, NA, 0, c(3, 3, 3), TRUE)
</code></pre>

<hr>
<h2 id='initialise_df_pic'>Initialises a dataframe which will contain the PIC for each configuration and for each value of C.</h2><span id='topic+initialise_df_pic'></span>

<h3>Description</h3>

<p>Initialises a dataframe which will contain the PIC for each configuration and for each value of C.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialise_df_pic(C_candidates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialise_df_pic_+3A_c_candidates">C_candidates</code></td>
<td>
<p>candidates for C (parameter in PIC)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an empty data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>initialise_df_pic(1:10)
</code></pre>

<hr>
<h2 id='initialise_df_results'>Initialises a dataframe that will contain an overview of metrics for each estimated configuration (for example adjusted randindex).</h2><span id='topic+initialise_df_results'></span>

<h3>Description</h3>

<p>Initialises a dataframe that will contain an overview of metrics for each estimated configuration (for example adjusted randindex).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialise_df_results(robust, limit_est_groups = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialise_df_results_+3A_robust">robust</code></td>
<td>
<p>robust or classical estimation</p>
</td></tr>
<tr><td><code id="initialise_df_results_+3A_limit_est_groups">limit_est_groups</code></td>
<td>
<p>maximum allowed number of groups that can be estimated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an empty data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>initialise_df_results(TRUE)
</code></pre>

<hr>
<h2 id='initialise_rc'>Initialises rc.</h2><span id='topic+initialise_rc'></span>

<h3>Description</h3>

<p>This function initialises a data frame which will eventually be filled with the optimized number of common factors for each C and for each subset of the original dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialise_rc(indices_subset, C_candidates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialise_rc_+3A_indices_subset">indices_subset</code></td>
<td>
<p>all indices of the subsets</p>
</td></tr>
<tr><td><code id="initialise_rc_+3A_c_candidates">C_candidates</code></td>
<td>
<p>candidates for C (parameter in PIC)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>initialise_rc(0:2, 1:5)
</code></pre>

<hr>
<h2 id='initialise_rcj'>Initialises rcj.</h2><span id='topic+initialise_rcj'></span>

<h3>Description</h3>

<p>This function initialises a data frame which will eventually be filled with the optimized number of groups and group specific factors for each C and for each subset of the original dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialise_rcj(indices_subset, C_candidates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialise_rcj_+3A_indices_subset">indices_subset</code></td>
<td>
<p>all indices of the subsets</p>
</td></tr>
<tr><td><code id="initialise_rcj_+3A_c_candidates">C_candidates</code></td>
<td>
<p>candidates for C (parameter in PIC)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>initialise_rcj(0:2, 1:5)
</code></pre>

<hr>
<h2 id='initialise_X'>Creates X (the observable variables) to use in simulations.</h2><span id='topic+initialise_X'></span>

<h3>Description</h3>

<p>X is an array with dimensions N, T and number of observable variables.
The variables are randomly generated with mean 0 and sd 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialise_X(NN, TT, vars, scale_robust = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialise_X_+3A_nn">NN</code></td>
<td>
<p>number of time series</p>
</td></tr>
<tr><td><code id="initialise_X_+3A_tt">TT</code></td>
<td>
<p>length of time series</p>
</td></tr>
<tr><td><code id="initialise_X_+3A_vars">vars</code></td>
<td>
<p>number of available observable variables</p>
</td></tr>
<tr><td><code id="initialise_X_+3A_scale_robust">scale_robust</code></td>
<td>
<p>logical, defines if X will be scaled with robust metrics instead of with non-robust metrics</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array with dimensions N x T x number of observable variables
</p>

<hr>
<h2 id='iterate'>Wrapper around estimate_beta(), update_g(), and estimating the factorstructures.</h2><span id='topic+iterate'></span>

<h3>Description</h3>

<p>Wrapper around estimate_beta(), update_g(), and estimating the factorstructures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iterate(
  Y,
  X,
  beta_est,
  g,
  lambda_group,
  factor_group,
  lambda,
  comfactor,
  S,
  k,
  kg,
  robust,
  method_estimate_beta = "individual",
  method_estimate_factors = "macro",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iterate_+3A_y">Y</code></td>
<td>
<p>Y: NxT dataframe with the panel data of interest</p>
</td></tr>
<tr><td><code id="iterate_+3A_x">X</code></td>
<td>
<p>X: NxTxp array containing the observable variables</p>
</td></tr>
<tr><td><code id="iterate_+3A_beta_est">beta_est</code></td>
<td>
<p>estimated values of beta</p>
</td></tr>
<tr><td><code id="iterate_+3A_g">g</code></td>
<td>
<p>Vector with estimated group membership for all individuals</p>
</td></tr>
<tr><td><code id="iterate_+3A_lambda_group">lambda_group</code></td>
<td>
<p>loadings of the estimated group specific factors</p>
</td></tr>
<tr><td><code id="iterate_+3A_factor_group">factor_group</code></td>
<td>
<p>estimated group specific factors</p>
</td></tr>
<tr><td><code id="iterate_+3A_lambda">lambda</code></td>
<td>
<p>loadings of the estimated common factors</p>
</td></tr>
<tr><td><code id="iterate_+3A_comfactor">comfactor</code></td>
<td>
<p>estimated common factors</p>
</td></tr>
<tr><td><code id="iterate_+3A_s">S</code></td>
<td>
<p>number of groups to estimate</p>
</td></tr>
<tr><td><code id="iterate_+3A_k">k</code></td>
<td>
<p>number of common factors to estimate</p>
</td></tr>
<tr><td><code id="iterate_+3A_kg">kg</code></td>
<td>
<p>vector with length S. Each element contains the number of group specific factors to estimate.</p>
</td></tr>
<tr><td><code id="iterate_+3A_robust">robust</code></td>
<td>
<p>TRUE or FALSE: defines using the classical or robust algorithm to estimate beta</p>
</td></tr>
<tr><td><code id="iterate_+3A_method_estimate_beta">method_estimate_beta</code></td>
<td>
<p>defines how beta is estimated. Default case is an estimated beta for each individual. Default value is &quot;individual.&quot; Possible values are &quot;homogeneous&quot;, &quot;group&quot; or &quot;individual&quot;.</p>
</td></tr>
<tr><td><code id="iterate_+3A_method_estimate_factors">method_estimate_factors</code></td>
<td>
<p>specifies the robust algorithm to estimate factors: default is &quot;macro&quot;. The value is not used when robust is set to FALSE.</p>
</td></tr>
<tr><td><code id="iterate_+3A_verbose">verbose</code></td>
<td>
<p>when TRUE, it prints messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with
</p>

<ol>
<li><p> estimated beta
</p>
</li>
<li><p> vector with group membership
</p>
</li>
<li><p> matrix with the common factor(s) (contains zero's if there are none estimated)
</p>
</li>
<li><p> loadings to the common factor(s)
</p>
</li>
<li><p> list with the group specific factors for each of the groups
</p>
</li>
<li><p> data.frame with loadings to the group specific factors augmented with group membership and id (to have the order of the time series)
</p>
</li>
<li><p> the value of the objective function
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
original_data &lt;- create_data_dgp2(30, 10)
Y &lt;- original_data[[1]]
X &lt;- original_data[[2]]
g &lt;- original_data[[3]]
beta_est &lt;- matrix(rnorm(4 * ncol(Y)), nrow = 4)
factor_group &lt;- original_data[[5]]
lambda_group &lt;- original_data[[6]]
comfactor &lt;- matrix(0, nrow = 1, ncol = ncol(Y))
lambda &lt;- matrix(0, nrow = 1, ncol = nrow(Y))
iterate(Y, X, beta_est, g, lambda_group, factor_group, lambda, comfactor, 3, 0, c(3, 3, 3), TRUE,
  verbose = FALSE)
</code></pre>

<hr>
<h2 id='kg_candidates_expand'>Function that returns the set of combinations of groupfactors for which the algorithm needs to run.</h2><span id='topic+kg_candidates_expand'></span>

<h3>Description</h3>

<p>Function that returns the set of combinations of groupfactors for which the algorithm needs to run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kg_candidates_expand(S, kg_min, kg_max, limit_est_groups = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kg_candidates_expand_+3A_s">S</code></td>
<td>
<p>number of groups</p>
</td></tr>
<tr><td><code id="kg_candidates_expand_+3A_kg_min">kg_min</code></td>
<td>
<p>minimum value for number of group specific factors</p>
</td></tr>
<tr><td><code id="kg_candidates_expand_+3A_kg_max">kg_max</code></td>
<td>
<p>minimum value for number of group specific factors</p>
</td></tr>
<tr><td><code id="kg_candidates_expand_+3A_limit_est_groups">limit_est_groups</code></td>
<td>
<p>maximum allowed number of groups that can be estimated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame where each row contains a possible combination of group specific factors for each of the groups
</p>

<hr>
<h2 id='lambda_group_true_dgp3'>lambda_group_true_dgp3 contains the values of the loadings to the group factors on which Y_dgp3 is based</h2><span id='topic+lambda_group_true_dgp3'></span>

<h3>Description</h3>

<p>lambda_group_true_dgp3 contains the values of the loadings to the group factors on which Y_dgp3 is based
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda_group_true_dgp3
</code></pre>


<h3>Format</h3>

<p>dataframe with 300 rows. The first 3 columns are the loadings to the factors. The 4th column contains group membership. The fifth column contains an id of the individuals.
</p>

<hr>
<h2 id='LMROB'>Wrapper around lmrob.</h2><span id='topic+LMROB'></span>

<h3>Description</h3>

<p>Desgined to make sure the following error does not happen anymore:
Error in if (init$scale == 0)  : missing value where TRUE/FALSE needed.
KS2014 is the recommended setting (use &quot;nosetting = FALSE&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LMROB(parameter_y, parameter_x, nointercept = FALSE, nosetting = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LMROB_+3A_parameter_y">parameter_y</code></td>
<td>
<p>dependent variable in regression</p>
</td></tr>
<tr><td><code id="LMROB_+3A_parameter_x">parameter_x</code></td>
<td>
<p>independent variables in regression</p>
</td></tr>
<tr><td><code id="LMROB_+3A_nointercept">nointercept</code></td>
<td>
<p>if TRUE it performs regression without an intercept</p>
</td></tr>
<tr><td><code id="LMROB_+3A_nosetting">nosetting</code></td>
<td>
<p>option to remove the recommended setting in lmrob(). It is much faster. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class lmrob. If something went wrong it returns an object of class error.
</p>

<hr>
<h2 id='make_df_pic_parallel'>Makes a dataframe with the PIC for each configuration and each candidate C.</h2><span id='topic+make_df_pic_parallel'></span>

<h3>Description</h3>

<p>Makes a dataframe with the PIC for each configuration and each candidate C.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_df_pic_parallel(x, C_candidates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_df_pic_parallel_+3A_x">x</code></td>
<td>
<p>output of the parallel version of the algorithm</p>
</td></tr>
<tr><td><code id="make_df_pic_parallel_+3A_c_candidates">C_candidates</code></td>
<td>
<p>candidates for C</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>

<hr>
<h2 id='make_df_results_parallel'>Makes a dataframe with information on each configuration.</h2><span id='topic+make_df_results_parallel'></span>

<h3>Description</h3>

<p>Makes a dataframe with information on each configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_df_results_parallel(x, limit_est_groups = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_df_results_parallel_+3A_x">x</code></td>
<td>
<p>output of the parallel version of the algorithm</p>
</td></tr>
<tr><td><code id="make_df_results_parallel_+3A_limit_est_groups">limit_est_groups</code></td>
<td>
<p>maximum allowed number of groups that can be estimated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>

<hr>
<h2 id='make_subsamples'>Selects a subsample of the time series, and of the length of the time series.
Based on this it returns a list with a subsample of Y, the corresponding subsample of X and of the true group membership and factorstructures if applicable.</h2><span id='topic+make_subsamples'></span>

<h3>Description</h3>

<p>Selects a subsample of the time series, and of the length of the time series.
Based on this it returns a list with a subsample of Y, the corresponding subsample of X and of the true group membership and factorstructures if applicable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_subsamples(original_data, subset, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_subsamples_+3A_original_data">original_data</code></td>
<td>
<p>list containing the true data: Y, X, g_true, beta_true, factor_group_true, lambda_group_true, comfactor_true, lambda_true</p>
</td></tr>
<tr><td><code id="make_subsamples_+3A_subset">subset</code></td>
<td>
<p>index of the subsample: this defines how many times stepsize_N is subtracted from the original N time series. Similar for stepsize_T.</p>
</td></tr>
<tr><td><code id="make_subsamples_+3A_verbose">verbose</code></td>
<td>
<p>when TRUE, it prints messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Y, X, g_true, comfactor_true, lambda_true, factor_group_true, lambda_group_true, sampleN, sampleT
The output is a list where the first element is a subset of the panel dataset.
The second element contains a subsetted 3D-array with the p observed variables.
The third element contains the subsetted true group membership.
The fourth and fifth elements contain the subsetted true common factor(s) and its loadings respectively.
The sixth element contains a list with the subsetted true group specific factors.
The seventh element contains a dataframe where each row contains the group specific factor loadings that corresponds to the group specific factors.
The eighth and ninth element contain the indices of N and T respectively, which were used to create the subsets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
original_data &lt;- create_data_dgp2(30, 10)
make_subsamples(original_data, 1)
</code></pre>

<hr>
<h2 id='matrixnorm'>Function to calculate the norm of a matrix.</h2><span id='topic+matrixnorm'></span>

<h3>Description</h3>

<p>Function to calculate the norm of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixnorm(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrixnorm_+3A_mat">mat</code></td>
<td>
<p>input matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>

<hr>
<h2 id='OF_vectorized_helpfunction3'>Helpfunction in OF_vectorized3()</h2><span id='topic+OF_vectorized_helpfunction3'></span>

<h3>Description</h3>

<p>Helpfunction in OF_vectorized3()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OF_vectorized_helpfunction3(
  i,
  t,
  XBETA,
  LF,
  group_memberships,
  lgfg_list,
  Y,
  kg
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OF_vectorized_helpfunction3_+3A_i">i</code></td>
<td>
<p>index of individual</p>
</td></tr>
<tr><td><code id="OF_vectorized_helpfunction3_+3A_t">t</code></td>
<td>
<p>index of time</p>
</td></tr>
<tr><td><code id="OF_vectorized_helpfunction3_+3A_xbeta">XBETA</code></td>
<td>
<p>matrixproduct of X and beta_est</p>
</td></tr>
<tr><td><code id="OF_vectorized_helpfunction3_+3A_lf">LF</code></td>
<td>
<p>matrixproduct of common factors and its loadings</p>
</td></tr>
<tr><td><code id="OF_vectorized_helpfunction3_+3A_group_memberships">group_memberships</code></td>
<td>
<p>Vector with group membership for all individuals</p>
</td></tr>
<tr><td><code id="OF_vectorized_helpfunction3_+3A_lgfg_list">lgfg_list</code></td>
<td>
<p>product of groupfactors and their loadings; list with length the number of groups</p>
</td></tr>
<tr><td><code id="OF_vectorized_helpfunction3_+3A_y">Y</code></td>
<td>
<p>Y: NxT dataframe with the panel data of interest</p>
</td></tr>
<tr><td><code id="OF_vectorized_helpfunction3_+3A_kg">kg</code></td>
<td>
<p>vector containing the number of group factors to be estimated for all groups</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric: contains the contribution to the objective function of one timepoint for one time series
</p>

<hr>
<h2 id='OF_vectorized3'>Calculates objective function for the classical algorithm: used in iterate() and in local_search.</h2><span id='topic+OF_vectorized3'></span>

<h3>Description</h3>

<p>Calculates objective function for the classical algorithm: used in iterate() and in local_search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OF_vectorized3(
  NN,
  TT,
  g,
  grid,
  Y,
  beta_est,
  lc,
  fc,
  lg,
  fg,
  S,
  k,
  kg,
  method_estimate_beta,
  num_factors_may_vary = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OF_vectorized3_+3A_nn">NN</code></td>
<td>
<p>number of time series</p>
</td></tr>
<tr><td><code id="OF_vectorized3_+3A_tt">TT</code></td>
<td>
<p>length of time series</p>
</td></tr>
<tr><td><code id="OF_vectorized3_+3A_g">g</code></td>
<td>
<p>Vector with group membership for all individuals</p>
</td></tr>
<tr><td><code id="OF_vectorized3_+3A_grid">grid</code></td>
<td>
<p>dataframe containing the matrix multiplications XB, FgLg and FL</p>
</td></tr>
<tr><td><code id="OF_vectorized3_+3A_y">Y</code></td>
<td>
<p>Y: NxT dataframe with the panel data of interest</p>
</td></tr>
<tr><td><code id="OF_vectorized3_+3A_beta_est">beta_est</code></td>
<td>
<p>estimated values of beta</p>
</td></tr>
<tr><td><code id="OF_vectorized3_+3A_lc">lc</code></td>
<td>
<p>loadings of estimated common factors</p>
</td></tr>
<tr><td><code id="OF_vectorized3_+3A_fc">fc</code></td>
<td>
<p>estimated common factors</p>
</td></tr>
<tr><td><code id="OF_vectorized3_+3A_lg">lg</code></td>
<td>
<p>estimated grouploadings</p>
</td></tr>
<tr><td><code id="OF_vectorized3_+3A_fg">fg</code></td>
<td>
<p>estimated groupfactors</p>
</td></tr>
<tr><td><code id="OF_vectorized3_+3A_s">S</code></td>
<td>
<p>number of estimated groups</p>
</td></tr>
<tr><td><code id="OF_vectorized3_+3A_k">k</code></td>
<td>
<p>number of common factors to be estimated</p>
</td></tr>
<tr><td><code id="OF_vectorized3_+3A_kg">kg</code></td>
<td>
<p>number of group specific factors to be estimated</p>
</td></tr>
<tr><td><code id="OF_vectorized3_+3A_method_estimate_beta">method_estimate_beta</code></td>
<td>
<p>defines how beta is estimated. Default case is an estimated beta for each individual. Default value is &quot;individual.&quot; Possible values are &quot;homogeneous&quot;, &quot;group&quot; or &quot;individual&quot;.</p>
</td></tr>
<tr><td><code id="OF_vectorized3_+3A_num_factors_may_vary">num_factors_may_vary</code></td>
<td>
<p>whether or not the number of groupfactors is constant over all groups or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value of the objective function
</p>

<hr>
<h2 id='parallel_algorithm'>Wrapper of the loop over the subsets which in turn use the parallelised algorithm.</h2><span id='topic+parallel_algorithm'></span>

<h3>Description</h3>

<p>Wrapper of the loop over the subsets which in turn use the parallelised algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parallel_algorithm(
  original_data,
  indices_subset,
  S_cand,
  k_cand,
  kg_cand,
  C_candidates,
  robust = TRUE,
  USE_DO = FALSE,
  choice_pic = "pic2022",
  maxit = 30
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parallel_algorithm_+3A_original_data">original_data</code></td>
<td>
<p>list containing the original data (1: Y, 2: X)</p>
</td></tr>
<tr><td><code id="parallel_algorithm_+3A_indices_subset">indices_subset</code></td>
<td>
<p>vector with indices of the subsets; starts with zero</p>
</td></tr>
<tr><td><code id="parallel_algorithm_+3A_s_cand">S_cand</code></td>
<td>
<p>candidates for S (number of groups)</p>
</td></tr>
<tr><td><code id="parallel_algorithm_+3A_k_cand">k_cand</code></td>
<td>
<p>candidates for k (number of common factors)</p>
</td></tr>
<tr><td><code id="parallel_algorithm_+3A_kg_cand">kg_cand</code></td>
<td>
<p>candidates for kg (number of group specific factors)</p>
</td></tr>
<tr><td><code id="parallel_algorithm_+3A_c_candidates">C_candidates</code></td>
<td>
<p>candidates for C</p>
</td></tr>
<tr><td><code id="parallel_algorithm_+3A_robust">robust</code></td>
<td>
<p>robust or classical estimation</p>
</td></tr>
<tr><td><code id="parallel_algorithm_+3A_use_do">USE_DO</code></td>
<td>
<p>(for testing purposes) if TRUE, then a serialized version is performed (&quot;do&quot; instead of &quot;dopar&quot;)</p>
</td></tr>
<tr><td><code id="parallel_algorithm_+3A_choice_pic">choice_pic</code></td>
<td>
<p>indicates which PIC to use to estimate the number of groups and factors.
Options are &quot;pic2017&quot; (PIC of Ando and Bai (2017); works better for large N),
&quot;pic2016&quot; (Ando and Bai (2016); works better for large T) weighs the fourth term with an extra factor relative to the size of the groups,
and &quot;pic2022&quot; which shrinks the NT-space where the number of groups and factors would be over- or underestimated compared to pic2016 and pic2017. This is the default.
This parameter can also be a vector with multiple pic's.</p>
</td></tr>
<tr><td><code id="parallel_algorithm_+3A_maxit">maxit</code></td>
<td>
<p>maximum limit for the number of iterations for each configuration; defaults to 30</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with three elements.
</p>

<ol>
<li><p> Data.frame with the optimal number of common factors for each candidate C in the rows.
Each column contains the results of one subset of the input data (the first row corresponds to the full dataset).
</p>
</li>
<li><p> Data.frame with the optimal number of groups and group specific factors for each candidate C in the rows. The structure is the same as in the above.
Each entry is of the form &quot;1_2_3_NA&quot;. This is to be interpreted as 3 groups (three non NA values) where group 1 contains 1 group specific factor,
group 2 contains 2 and group 3 contains 3.
</p>
</li>
<li><p> Data.frame with information about each configuration in the rows.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>
#Using a small dataset as an example; this will generate several warnings due to its small size.
#Note that this example is run sequentially instead of parallel,
#  and consequently will print some intermediate information in the console.
#This example uses the classical algorithm instead of the robust algorithm
#  to limit its running time.
set.seed(1)
original_data &lt;- create_data_dgp2(30, 10)
#define the number of subsets used to estimate the optimal number of groups and factors
indices_subset &lt;- define_number_subsets(2)
#define the candidate values for C (this is a parameter in the information criterium
#  used to estimate the optimal number of groups and factors)
C_candidates &lt;- define_C_candidates()

S_cand &lt;- 3:3 # vector with candidate number of groups
k_cand &lt;- 0:0 # vector with candidate number of common factors
kg_cand &lt;- 1:2 # vector with candidate number of group specific factors

#excluding parallel part from this example
#cl &lt;- makeCluster(detectCores() - 1)
#registerDoSNOW(cl)
output &lt;- parallel_algorithm(original_data, indices_subset, S_cand, k_cand, kg_cand,
  C_candidates, robust = FALSE, USE_DO = TRUE, maxit = 3)
#stopCluster(cl)

</code></pre>

<hr>
<h2 id='plot_VCsquared'>Plots expression(VC^2) along with the corresponding number of groups (orange), common factors (darkblue) and group factors of the first group (lightblue).</h2><span id='topic+plot_VCsquared'></span>

<h3>Description</h3>

<p>Plots expression(VC^2) along with the corresponding number of groups (orange), common factors (darkblue) and group factors of the first group (lightblue).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_VCsquared(
  VC_squared,
  rc,
  rcj,
  C_candidates,
  S_cand,
  xlim_min = 0.001,
  xlim_max = 100,
  add_true_lines = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_VCsquared_+3A_vc_squared">VC_squared</code></td>
<td>
<p>measure of variability in the optimal configuration between the subsets</p>
</td></tr>
<tr><td><code id="plot_VCsquared_+3A_rc">rc</code></td>
<td>
<p>dataframe containg the numer of common factors for all candidate C's and all subsamples</p>
</td></tr>
<tr><td><code id="plot_VCsquared_+3A_rcj">rcj</code></td>
<td>
<p>dataframe containg the numer of groupfactors for all candidate C's and all subsamples</p>
</td></tr>
<tr><td><code id="plot_VCsquared_+3A_c_candidates">C_candidates</code></td>
<td>
<p>candidates for C (parameter in PIC)</p>
</td></tr>
<tr><td><code id="plot_VCsquared_+3A_s_cand">S_cand</code></td>
<td>
<p>candidate numbers for the number of groups</p>
</td></tr>
<tr><td><code id="plot_VCsquared_+3A_xlim_min">xlim_min</code></td>
<td>
<p>starting point of the plot</p>
</td></tr>
<tr><td><code id="plot_VCsquared_+3A_xlim_max">xlim_max</code></td>
<td>
<p>end point of the plot</p>
</td></tr>
<tr><td><code id="plot_VCsquared_+3A_add_true_lines">add_true_lines</code></td>
<td>
<p>if set to TRUE, for each C the true number of groups, common factors, and group specific factors of group 1 will be added to the plot</p>
</td></tr>
<tr><td><code id="plot_VCsquared_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, more details are printed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
#requires filled in dataframes rc and rcj
all_best_values &lt;- calculate_best_config(add_configuration(initialise_df_results(TRUE),
  3, 0, c(3, 3, 3, rep(NA, 17))),
  data.frame(t(1:20)), 1:20)
rc &lt;- fill_rc(initialise_rc(0:1, 1:20), all_best_values, 0)
rc &lt;- fill_rc(rc, all_best_values, 1)
rcj &lt;- fill_rcj(initialise_rcj(0:1, 1:20) , all_best_values, 0, 2:4, 2:4)
rcj &lt;- fill_rcj(rcj, all_best_values, 1, 2:4, 2:4)
plot_VCsquared(c(runif(9), 0, 0, runif(9)), rc, rcj, 1:20, 2:4)

</code></pre>

<hr>
<h2 id='prepare_for_robpca'>Helpfunction: prepares object to perform robust PCA on.</h2><span id='topic+prepare_for_robpca'></span>

<h3>Description</h3>

<p>It contains options to use the classical or robust covmatrix or no covariance matrix at all.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_for_robpca(object, NN, TT, option = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_for_robpca_+3A_object">object</code></td>
<td>
<p>this is the object of which we may take the covariance matrix and then to perform robust PCA on</p>
</td></tr>
<tr><td><code id="prepare_for_robpca_+3A_nn">NN</code></td>
<td>
<p>N</p>
</td></tr>
<tr><td><code id="prepare_for_robpca_+3A_tt">TT</code></td>
<td>
<p>T</p>
</td></tr>
<tr><td><code id="prepare_for_robpca_+3A_option">option</code></td>
<td>
<p>1 (robust covmatrix), 2 (classical covmatrix), 3 (no covmatrix)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>

<hr>
<h2 id='RCTS'>RCTS</h2><span id='topic+RCTS'></span>

<h3>Description</h3>

<p>This package is about clustering time series in a robust manner.
The method of Ando &amp; Bai (Clustering Huge Number of Financial Time Series: A Panel Data Approach With High-Dimensional Predictors and Factor Structures)
is extended to make it robust against contamination, a common issue with real world data. In this package the core functions for the robust approach are included.
It also contains a simulated dataset (dataset_Y_dgp3).
</p>

<hr>
<h2 id='reassign_if_empty_groups'>Randomly reassign individual(s) if there are empty groups. This can happen if the total number of time series is low compared to the number of desired groups.</h2><span id='topic+reassign_if_empty_groups'></span>

<h3>Description</h3>

<p>Randomly reassign individual(s) if there are empty groups. This can happen if the total number of time series is low compared to the number of desired groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reassign_if_empty_groups(g, S_true, NN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reassign_if_empty_groups_+3A_g">g</code></td>
<td>
<p>Vector with group membership for all individuals</p>
</td></tr>
<tr><td><code id="reassign_if_empty_groups_+3A_s_true">S_true</code></td>
<td>
<p>true number of groups</p>
</td></tr>
<tr><td><code id="reassign_if_empty_groups_+3A_nn">NN</code></td>
<td>
<p>number of time series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with the estimated group membership for all time series
</p>

<hr>
<h2 id='restructure_X_to_order_slowN_fastT'>Restructures X (which is an 3D-array of dimensions (N,T,p) to a 2D-matrix of dimension (NxT,p).</h2><span id='topic+restructure_X_to_order_slowN_fastT'></span>

<h3>Description</h3>

<p>Restructures X (which is an 3D-array of dimensions (N,T,p) to a 2D-matrix of dimension (NxT,p).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restructure_X_to_order_slowN_fastT(X, vars_est)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restructure_X_to_order_slowN_fastT_+3A_x">X</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="restructure_X_to_order_slowN_fastT_+3A_vars_est">vars_est</code></td>
<td>
<p>number of variables that will be included in the algorithm and have their coefficient estimated. This is usually equal to the number of observable variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a 2D-array, unless the input X is NA, in which case the output will be NA as well.
</p>

<hr>
<h2 id='return_robust_lambdaobject'>Calculates robust loadings</h2><span id='topic+return_robust_lambdaobject'></span>

<h3>Description</h3>

<p>Uses the almost classical lambda (this is an object of which the mean equals to the classical lambda) to create a robust lambda by using M estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>return_robust_lambdaobject(
  Y_like_object,
  group,
  type,
  g,
  NN,
  k,
  kg,
  comfactor_rrn,
  factor_group_rrn,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="return_robust_lambdaobject_+3A_y_like_object">Y_like_object</code></td>
<td>
<p>this is Y_ster or W or W_j</p>
</td></tr>
<tr><td><code id="return_robust_lambdaobject_+3A_group">group</code></td>
<td>
<p>index of group</p>
</td></tr>
<tr><td><code id="return_robust_lambdaobject_+3A_type">type</code></td>
<td>
<p>scalar which shows in which setting this function is used</p>
</td></tr>
<tr><td><code id="return_robust_lambdaobject_+3A_g">g</code></td>
<td>
<p>vector with group memberships</p>
</td></tr>
<tr><td><code id="return_robust_lambdaobject_+3A_nn">NN</code></td>
<td>
<p>number of time series</p>
</td></tr>
<tr><td><code id="return_robust_lambdaobject_+3A_k">k</code></td>
<td>
<p>number of common factors</p>
</td></tr>
<tr><td><code id="return_robust_lambdaobject_+3A_kg">kg</code></td>
<td>
<p>number of group factors</p>
</td></tr>
<tr><td><code id="return_robust_lambdaobject_+3A_comfactor_rrn">comfactor_rrn</code></td>
<td>
<p>estimated common factors</p>
</td></tr>
<tr><td><code id="return_robust_lambdaobject_+3A_factor_group_rrn">factor_group_rrn</code></td>
<td>
<p>estimatied group specific factors</p>
</td></tr>
<tr><td><code id="return_robust_lambdaobject_+3A_verbose">verbose</code></td>
<td>
<p>when TRUE, it prints messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nxk dataframe
</p>

<hr>
<h2 id='robustpca'>Function that uses robust PCA and estimates robust factors and loadings.</h2><span id='topic+robustpca'></span>

<h3>Description</h3>

<p>Contains call to MacroPCA()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robustpca(object, number_eigenvectors, KMAX = 20, verbose_robustpca = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robustpca_+3A_object">object</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="robustpca_+3A_number_eigenvectors">number_eigenvectors</code></td>
<td>
<p>number of eigenvectors to extract</p>
</td></tr>
<tr><td><code id="robustpca_+3A_kmax">KMAX</code></td>
<td>
<p>The maximal number of principal components to compute. This is a parameter in cellWise::MacroPCA()</p>
</td></tr>
<tr><td><code id="robustpca_+3A_verbose_robustpca">verbose_robustpca</code></td>
<td>
<p>when TRUE, it prints messages: used for testing (requires Matrix-package when set to TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Notes:
</p>
<p>Different values for kmax give different factors, but the product lambda<em>factor stays constant. Note that
this number needs to be big enough, otherwise eigen() will be used. Variation in k does give different results for lambda</em>factor
</p>
<p>MacroPCA() crashes with specific values of dim(object). For example when dim(object) = c(193,27).
This is solved with evade_crashes_macropca(), for those problematic dimensions that are already encountered during tests.
</p>


<h3>Value</h3>

<p>list with as the first element the robust factors and as the second element the robust factor loadings
</p>

<hr>
<h2 id='run_config'>Wrapper around the non-parallel algorithm, to estimate beta, group membership and the factorstructures.</h2><span id='topic+run_config'></span>

<h3>Description</h3>

<p>The function estimates beta, group membership and the common and group specific factorstructures for one configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_config(robust, config, C_candidates, Y, X, choice_pic, maxit = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_config_+3A_robust">robust</code></td>
<td>
<p>TRUE or FALSE: defines using the classical or robust algorithm to estimate beta</p>
</td></tr>
<tr><td><code id="run_config_+3A_config">config</code></td>
<td>
<p>contains one configuration of groups and factors</p>
</td></tr>
<tr><td><code id="run_config_+3A_c_candidates">C_candidates</code></td>
<td>
<p>candidates for C (parameter in PIC)</p>
</td></tr>
<tr><td><code id="run_config_+3A_y">Y</code></td>
<td>
<p>Y: NxT dataframe with the panel data of interest</p>
</td></tr>
<tr><td><code id="run_config_+3A_x">X</code></td>
<td>
<p>X: NxTxp array containing the observable variables</p>
</td></tr>
<tr><td><code id="run_config_+3A_choice_pic">choice_pic</code></td>
<td>
<p>indicates which PIC to use to estimate the number of groups and factors:
options are &quot;pic2017&quot; (uses the PIC of Ando and Bai (2017); works better for large N),
&quot;pic2016&quot; (Ando and Bai (2016); works better for large T) weighs the fourth term with an extra factor relative to the size of the groups,
and &quot;pic2022&quot; which shrinks the NT-space where the number of groups and factors would be over- or underestimated compared to pic2016 and pic2017.</p>
</td></tr>
<tr><td><code id="run_config_+3A_maxit">maxit</code></td>
<td>
<p>maximum limit for the number of iterations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the estimators and metrics for this configuration
</p>

<hr>
<h2 id='scaling_X'>Scaling of X.</h2><span id='topic+scaling_X'></span>

<h3>Description</h3>

<p>Scaling of X.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaling_X(X, firsttime, robust, vars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaling_X_+3A_x">X</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="scaling_X_+3A_firsttime">firsttime</code></td>
<td>
<p>Scaling before generating Y and before adding outliers: this is always with mean and sd. If this is FALSE, it indicates that
we are using the function for a second time, after adding the outliers. In the robust case it uses median and MAD, otherwise again mean and sd.</p>
</td></tr>
<tr><td><code id="scaling_X_+3A_robust">robust</code></td>
<td>
<p>logical, scaling with robust metrics instead of with non-robust measures</p>
</td></tr>
<tr><td><code id="scaling_X_+3A_vars">vars</code></td>
<td>
<p>number of observable variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3D-array with the same dimensions as X
</p>

<hr>
<h2 id='solveFG'>Helpfunction in update_g(), to calculate solve(FG x t(FG)) x FG</h2><span id='topic+solveFG'></span>

<h3>Description</h3>

<p>Helpfunction in update_g(), to calculate solve(FG x t(FG)) x FG
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solveFG(TT, S, kg, factor_group, testing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solveFG_+3A_tt">TT</code></td>
<td>
<p>length of time series</p>
</td></tr>
<tr><td><code id="solveFG_+3A_s">S</code></td>
<td>
<p>number of groups</p>
</td></tr>
<tr><td><code id="solveFG_+3A_kg">kg</code></td>
<td>
<p>vector with the estimated number of group specific factors for each group</p>
</td></tr>
<tr><td><code id="solveFG_+3A_factor_group">factor_group</code></td>
<td>
<p>estimated group specific factors</p>
</td></tr>
<tr><td><code id="solveFG_+3A_testing">testing</code></td>
<td>
<p>variable that determines if we are in 'testing phase'; defaults to FALSE (requires Matrix-package if set to TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list: the number of elements in this list is equal to S (the number of groups).
Each of the elements in this list has a number rows equal to the number of group specific factors, and TT columns.
</p>

<hr>
<h2 id='tabulate_potential_C'>Shows the configurations for potential C's of the first stable interval (beginpoint, middlepoint and endpoint)</h2><span id='topic+tabulate_potential_C'></span>

<h3>Description</h3>

<p>Shows the configurations for potential C's of the first stable interval (beginpoint, middlepoint and endpoint)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabulate_potential_C(
  df,
  runs,
  beginpoint,
  middlepoint_log,
  middlepoint,
  endpoint,
  S_cand
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabulate_potential_C_+3A_df">df</code></td>
<td>
<p>input dataframe</p>
</td></tr>
<tr><td><code id="tabulate_potential_C_+3A_runs">runs</code></td>
<td>
<p>number of panel data sets for which the algorithm has run. If larger than one, the median VC2 is used to determine C.</p>
</td></tr>
<tr><td><code id="tabulate_potential_C_+3A_beginpoint">beginpoint</code></td>
<td>
<p>first C of the chosen stable interval</p>
</td></tr>
<tr><td><code id="tabulate_potential_C_+3A_middlepoint_log">middlepoint_log</code></td>
<td>
<p>middle C (on a logscale) of the chosen stable interval</p>
</td></tr>
<tr><td><code id="tabulate_potential_C_+3A_middlepoint">middlepoint</code></td>
<td>
<p>middle C of the chosen stable interval</p>
</td></tr>
<tr><td><code id="tabulate_potential_C_+3A_endpoint">endpoint</code></td>
<td>
<p>last C of the chosen stable interval</p>
</td></tr>
<tr><td><code id="tabulate_potential_C_+3A_s_cand">S_cand</code></td>
<td>
<p>candidate number for the number of groups</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>

<hr>
<h2 id='update_g'>Function that estimates group membership.</h2><span id='topic+update_g'></span>

<h3>Description</h3>

<p>Function that estimates group membership.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_g(
  Y,
  X,
  beta_est,
  g,
  factor_group,
  lambda,
  comfactor,
  S,
  k,
  kg,
  vars_est,
  robust,
  method_estimate_factors,
  method_estimate_beta,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_g_+3A_y">Y</code></td>
<td>
<p>Y: NxT dataframe with the panel data of interest</p>
</td></tr>
<tr><td><code id="update_g_+3A_x">X</code></td>
<td>
<p>X: NxTxp array containing the observable variables</p>
</td></tr>
<tr><td><code id="update_g_+3A_beta_est">beta_est</code></td>
<td>
<p>estimated values of beta</p>
</td></tr>
<tr><td><code id="update_g_+3A_g">g</code></td>
<td>
<p>Vector with estimated group membership for all individuals</p>
</td></tr>
<tr><td><code id="update_g_+3A_factor_group">factor_group</code></td>
<td>
<p>estimated group specific factors</p>
</td></tr>
<tr><td><code id="update_g_+3A_lambda">lambda</code></td>
<td>
<p>loadings of the estimated common factors</p>
</td></tr>
<tr><td><code id="update_g_+3A_comfactor">comfactor</code></td>
<td>
<p>estimated common factors</p>
</td></tr>
<tr><td><code id="update_g_+3A_s">S</code></td>
<td>
<p>number of estimated groups</p>
</td></tr>
<tr><td><code id="update_g_+3A_k">k</code></td>
<td>
<p>number of common factors to be estimated</p>
</td></tr>
<tr><td><code id="update_g_+3A_kg">kg</code></td>
<td>
<p>number of group specific factors to be estimated</p>
</td></tr>
<tr><td><code id="update_g_+3A_vars_est">vars_est</code></td>
<td>
<p>number of variables that will be included in the algorithm and have their coefficient estimated. This is usually equal to the number of observable variables.</p>
</td></tr>
<tr><td><code id="update_g_+3A_robust">robust</code></td>
<td>
<p>robust or classical estimation of group membership</p>
</td></tr>
<tr><td><code id="update_g_+3A_method_estimate_factors">method_estimate_factors</code></td>
<td>
<p>defines method of robust estimaton of the factors: &quot;macro&quot;, &quot;pertmm&quot; or &quot;cz&quot;</p>
</td></tr>
<tr><td><code id="update_g_+3A_method_estimate_beta">method_estimate_beta</code></td>
<td>
<p>defines how beta is estimated. Default case is an estimated beta for each individual. Default value is &quot;individual.&quot; Possible values are &quot;homogeneous&quot;, &quot;group&quot; or &quot;individual&quot;.</p>
</td></tr>
<tr><td><code id="update_g_+3A_verbose">verbose</code></td>
<td>
<p>when TRUE, it prints messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list. The first element contains a vector with the estimated group membership for all time series. The second element contains the values
which were used to determine the group membership. The third element is only relevant if method_estimate_factors is set to &quot;cz&quot; (non-default) and
contains the group membership before moving some of the time series to class zero.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
X &lt;- X_dgp3
Y &lt;- Y_dgp3
# Set estimations for group factors and its loadings, and group membership to the true value
lambda_group &lt;- lambda_group_true_dgp3
factor_group &lt;- factor_group_true_dgp3
g_true &lt;- g_true_dgp3 # true values of group membership
g &lt;- g_true # estimated values of group membership; set in this example to be equal to true values
# There are no common factors to be estimated  -&gt;  use placeholder with values set to zero
lambda &lt;- matrix(0, nrow = 1, ncol = 300)
comfactor &lt;- matrix(0, nrow = 1, ncol = 30)
# Choose how coefficients of the observable are estimated
beta_est &lt;- estimate_beta(
  Y, X, NA, g, lambda_group, factor_group,
  lambda, comfactor,
  S = 3, k = 0, kg = c(3, 3, 3),
  vars_est = 3, robust = TRUE
)[[1]]
g_new &lt;- update_g(
  Y, X, beta_est, g,
  factor_group, lambda, comfactor,
  S = 3,
  k = 0,
  kg = c(3, 3, 3),
  vars_est = 3,
  robust = TRUE,
  "macro", "individual"
)[[1]]

</code></pre>

<hr>
<h2 id='X_dgp3'>The dataset X_dgp3 contains the values of the 3 observable variables on which Y_dgp3 is based.</h2><span id='topic+X_dgp3'></span>

<h3>Description</h3>

<p>The dataset X_dgp3 contains the values of the 3 observable variables on which Y_dgp3 is based.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>X_dgp3
</code></pre>


<h3>Format</h3>

<p>array with 300 x 30 x 3 elements
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(X_dgp3[,,1])
hist(X_dgp3[,,1])
</code></pre>

<hr>
<h2 id='Y_dgp3'>Y_dgp3 contains a simulated dataset for DGP 3.</h2><span id='topic+Y_dgp3'></span>

<h3>Description</h3>

<p>Y = XB + LgFg. It has 3 groups and each group has 3 groupfactors.
At last there were 3 observable variables generated into it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Y_dgp3
</code></pre>


<h3>Format</h3>

<p>300 x 30 matrix. Each row is one time series.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(Y_dgp3[,1:2], col = g_true_dgp3, xlab = "First column of Y",  ylab = "Second column of Y",
main = "Plot of the first two columns of the dataset Y. \nColors are the true groups.")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
