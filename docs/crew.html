<!DOCTYPE html><html lang="en-US"><head><title>Help for package crew</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {crew}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#crew-package'><p>crew: a distributed worker launcher framework</p></a></li>
<li><a href='#crew_assert'><p>Crew assertion</p></a></li>
<li><a href='#crew_async'><p>Local asynchronous client object.</p></a></li>
<li><a href='#crew_class_async'><p><code>R6</code> async class.</p></a></li>
<li><a href='#crew_class_client'><p><code>R6</code> client class.</p></a></li>
<li><a href='#crew_class_controller'><p>Controller class</p></a></li>
<li><a href='#crew_class_controller_group'><p>Controller group class</p></a></li>
<li><a href='#crew_class_launcher'><p>Launcher abstract class</p></a></li>
<li><a href='#crew_class_launcher_local'><p>Local process launcher class</p></a></li>
<li><a href='#crew_class_monitor_local'><p>Local monitor class</p></a></li>
<li><a href='#crew_class_queue'><p><code>R6</code> queue class</p></a></li>
<li><a href='#crew_class_relay'><p><code>R6</code> relay class.</p></a></li>
<li><a href='#crew_class_throttle'><p><code>R6</code> throttle class.</p></a></li>
<li><a href='#crew_class_tls'><p><code>R6</code> TLS class.</p></a></li>
<li><a href='#crew_clean'><p>Terminate dispatchers and/or workers</p></a></li>
<li><a href='#crew_client'><p>Create a client object.</p></a></li>
<li><a href='#crew_controller'><p>Create a controller object from a client and launcher.</p></a></li>
<li><a href='#crew_controller_group'><p>Create a controller group.</p></a></li>
<li><a href='#crew_controller_local'><p>Create a controller with a local process launcher.</p></a></li>
<li><a href='#crew_deprecate'><p>Deprecate a <code>crew</code> feature.</p></a></li>
<li><a href='#crew_eval'><p>Evaluate an R command and return results as a monad.</p></a></li>
<li><a href='#crew_eval_async'><p>Run an asynchronous task in the crew launcher.</p></a></li>
<li><a href='#crew_launcher'><p>Create an abstract launcher.</p></a></li>
<li><a href='#crew_launcher_local'><p>Create a launcher with local process workers.</p></a></li>
<li><a href='#crew_monitor_local'><p>Create a local monitor object.</p></a></li>
<li><a href='#crew_options_local'><p>Local <code>crew</code> launcher options.</p></a></li>
<li><a href='#crew_options_metrics'><p>Options for logging resource usage metrics.</p></a></li>
<li><a href='#crew_queue'><p>Create a <code>crew</code> queue object.</p></a></li>
<li><a href='#crew_random_name'><p>Random name</p></a></li>
<li><a href='#crew_relay'><p>Create a <code>crew</code> relay object.</p></a></li>
<li><a href='#crew_retry'><p>Retry code.</p></a></li>
<li><a href='#crew_terminate_process'><p>Manually terminate a local process.</p></a></li>
<li><a href='#crew_terminate_signal'><p>Get the termination signal.</p></a></li>
<li><a href='#crew_throttle'><p>Create a stateful throttling object.</p></a></li>
<li><a href='#crew_tls'><p>Configure TLS.</p></a></li>
<li><a href='#crew_worker'><p>Crew worker.</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>A Distributed Worker Launcher Framework</td>
</tr>
<tr>
<td>Description:</td>
<td>In computationally demanding analysis projects,
  statisticians and data scientists asynchronously
  deploy long-running tasks to distributed systems,
  ranging from traditional clusters to cloud services.
  The 'NNG'-powered 'mirai' R package by Gao (2023)
  &lt;<a href="https://doi.org/10.5281%2Fzenodo.7912722">doi:10.5281/zenodo.7912722</a>&gt; is a sleek
  and sophisticated scheduler that
  efficiently processes these intense workloads.
  The 'crew' package extends 'mirai' with a unifying
  interface for third-party worker launchers.
  Inspiration also comes from packages.
  'future' by Bengtsson (2021) &lt;<a href="https://doi.org/10.32614%2FRJ-2021-048">doi:10.32614/RJ-2021-048</a>&gt;,
  'rrq' by FitzJohn and Ashton (2023) <a href="https://github.com/mrc-ide/rrq">https://github.com/mrc-ide/rrq</a>,
  'clustermq' by Schubert (2019) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtz284">doi:10.1093/bioinformatics/btz284</a>&gt;),
  and 'batchtools' by Lang, Bischel, and Surmann (2017)
  &lt;<a href="https://doi.org/10.21105%2Fjoss.00135">doi:10.21105/joss.00135</a>&gt;.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://wlandau.github.io/crew/">https://wlandau.github.io/crew/</a>, <a href="https://github.com/wlandau/crew">https://github.com/wlandau/crew</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/wlandau/crew/issues">https://github.com/wlandau/crew/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.1.0), data.table, getip, later, mirai (&ge; 2.0.1),
nanonext (&ge; 1.4.0), processx, promises, ps, R6, rlang, stats,
tibble, tidyselect, tools, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>autometric (&ge; 0.1.0), knitr (&ge; 1.30), markdown (&ge; 1.1),
rmarkdown (&ge; 2.4), testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-03 13:14:12 UTC; C240390</td>
</tr>
<tr>
<td>Author:</td>
<td>William Michael Landau
    <a href="https://orcid.org/0000-0003-1878-3253"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Daniel Woodie [ctb],
  Eli Lilly and Company [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>William Michael Landau &lt;will.landau.oss@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-03 15:40:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='crew-package'>crew: a distributed worker launcher framework</h2><span id='topic+crew-package'></span>

<h3>Description</h3>

<p>In computationally demanding analysis projects,
statisticians and data scientists asynchronously deploy
long-running tasks to distributed systems, ranging from
traditional clusters to cloud services.
The <a href="https://nng.nanomsg.org">NNG</a>-powered
<a href="https://github.com/shikokuchuo/mirai"><code>mirai</code></a>
R package is a sleek and sophisticated scheduler
that efficiently processes these intense workloads.
The <code>crew</code> package extends
<a href="https://github.com/shikokuchuo/mirai"><code>mirai</code></a>
with a unifying interface
for third-party worker launchers.
Inspiration also comes from packages
<a href="https://future.futureverse.org/"><code>future</code></a>,
<a href="https://mrc-ide.github.io/rrq/"><code>rrq</code></a>,
<a href="https://mschubert.github.io/clustermq/"><code>clustermq</code></a>,
and <a href="https://mllg.github.io/batchtools/"><code>batchtools</code></a>.
</p>

<hr>
<h2 id='crew_assert'>Crew assertion</h2><span id='topic+crew_assert'></span>

<h3>Description</h3>

<p>Assert that a condition is true.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crew_assert(value = NULL, ..., message = NULL, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crew_assert_+3A_value">value</code></td>
<td>
<p>An object or condition.</p>
</td></tr>
<tr><td><code id="crew_assert_+3A_...">...</code></td>
<td>
<p>Conditions that use the <code>"."</code> symbol to refer to the object.</p>
</td></tr>
<tr><td><code id="crew_assert_+3A_message">message</code></td>
<td>
<p>Optional message to print on error.</p>
</td></tr>
<tr><td><code id="crew_assert_+3A_envir">envir</code></td>
<td>
<p>Environment to evaluate the condition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> (invisibly). Throws an error if the condition is not true.
</p>


<h3>See Also</h3>

<p>Other utility: 
<code><a href="#topic+crew_clean">crew_clean</a>()</code>,
<code><a href="#topic+crew_deprecate">crew_deprecate</a>()</code>,
<code><a href="#topic+crew_eval">crew_eval</a>()</code>,
<code><a href="#topic+crew_random_name">crew_random_name</a>()</code>,
<code><a href="#topic+crew_retry">crew_retry</a>()</code>,
<code><a href="#topic+crew_terminate_process">crew_terminate_process</a>()</code>,
<code><a href="#topic+crew_terminate_signal">crew_terminate_signal</a>()</code>,
<code><a href="#topic+crew_worker">crew_worker</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>crew_assert(1 &lt; 2)
crew_assert("object", !anyNA(.), nzchar(.))
tryCatch(
  crew_assert(2 &lt; 1),
  crew_error = function(condition) message("false")
)
</code></pre>

<hr>
<h2 id='crew_async'>Local asynchronous client object.</h2><span id='topic+crew_async'></span>

<h3>Description</h3>

<p>Create an <code>R6</code> object to manage local asynchronous quick
tasks with error detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crew_async(workers = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crew_async_+3A_workers">workers</code></td>
<td>
<p>Number of local <code>mirai</code> daemons to run asynchronous tasks.
If <code>NULL</code>, then tasks will be evaluated synchronously.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+crew_async">crew_async()</a></code> objects are created inside launchers to allow
launcher plugins to run local tasks asynchronously, such as
calls to cloud APIs to launch serious remote workers.
</p>


<h3>Value</h3>

<p>An <code>R6</code> async client object.
</p>


<h3>See Also</h3>

<p>Other async: 
<code><a href="#topic+crew_class_async">crew_class_async</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("CREW_EXAMPLES"), "true")) {
x &lt;- crew_async()
x$start()
out &lt;- x$eval(1 + 1)
mirai::call_mirai_(out)
out$data # 2
x$terminate()
}
</code></pre>

<hr>
<h2 id='crew_class_async'><code>R6</code> async class.</h2><span id='topic+crew_class_async'></span>

<h3>Description</h3>

<p><code>R6</code> class for async configuration.
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+crew_async">crew_async()</a></code>.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>workers</code></dt><dd><p>See <code><a href="#topic+crew_async">crew_async()</a></code>.</p>
</dd>
<dt><code>instance</code></dt><dd><p>Name of the current instance.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-crew_class_async-new"><code>crew_class_async$new()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_async-validate"><code>crew_class_async$validate()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_async-start"><code>crew_class_async$start()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_async-terminate"><code>crew_class_async$terminate()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_async-started"><code>crew_class_async$started()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_async-asynchronous"><code>crew_class_async$asynchronous()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_async-eval"><code>crew_class_async$eval()</code></a>
</p>
</li></ul>


<hr>
<a id="method-crew_class_async-new"></a>



<h4>Method <code>new()</code></h4>

<p>TLS configuration constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_async$new(workers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>workers</code></dt><dd><p>Argument passed from <code><a href="#topic+crew_async">crew_async()</a></code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An <code>R6</code> object with TLS configuration.
</p>


<hr>
<a id="method-crew_class_async-validate"></a>



<h4>Method <code>validate()</code></h4>

<p>Validate the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_async$validate()</pre></div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_async-start"></a>



<h4>Method <code>start()</code></h4>

<p>Start the local workers and error handling socket.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_async$start()</pre></div>



<h5>Details</h5>

<p>Does not create workers or an error handling socket
if <code>workers</code> is <code>NULL</code> or the object is already started.
</p>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_async-terminate"></a>



<h4>Method <code>terminate()</code></h4>

<p>Start the local workers and error handling socket.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_async$terminate()</pre></div>



<h5>Details</h5>

<p>Waits for existing tasks to complete first.
</p>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_async-started"></a>



<h4>Method <code>started()</code></h4>

<p>Show whether the object is started.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_async$started()</pre></div>



<h5>Returns</h5>

<p>Logical of length 1, whether the object is started.
</p>


<hr>
<a id="method-crew_class_async-asynchronous"></a>



<h4>Method <code>asynchronous()</code></h4>

<p>Show whether the object is asynchronous (has real workers).
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_async$asynchronous()</pre></div>



<h5>Returns</h5>

<p>Logical of length 1, whether the object is asynchronous.
</p>


<hr>
<a id="method-crew_class_async-eval"></a>



<h4>Method <code>eval()</code></h4>

<p>Run a local asynchronous task using a local
compute profile.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_async$eval(
  command,
  substitute = TRUE,
  data = list(),
  packages = character(0L),
  library = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>command</code></dt><dd><p>R code to run.</p>
</dd>
<dt><code>substitute</code></dt><dd><p>Logical of length 1, whether to substitute <code>command</code>.
If <code>FALSE</code>, then <code>command</code> must be an expression object
or language object.</p>
</dd>
<dt><code>data</code></dt><dd><p>Named list of data objects required to run <code>command</code>.</p>
</dd>
<dt><code>packages</code></dt><dd><p>Character vector of packages to load.</p>
</dd>
<dt><code>library</code></dt><dd><p>Character vector of library paths to load the packages
from.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Used for launcher plugins with asynchronous launches and
terminations. If <code>processes</code> is <code>NULL</code>, the task will run locally.
Otherwise, the task will run on a local process in the local
<code>mirai</code> compute profile.
</p>



<h5>Returns</h5>

<p>If the <code>processes</code> field is <code>NULL</code>, a list with an object named
<code>data</code> containing the result of evaluating <code>expr</code> synchronously.
Otherwise, the task is evaluated asynchronously, and the result
is a <code>mirai</code> task object. Either way, the <code>data</code> element
of the return value will contain the result of the task.
</p>




<h3>See Also</h3>

<p>Other async: 
<code><a href="#topic+crew_async">crew_async</a>()</code>
</p>

<hr>
<h2 id='crew_class_client'><code>R6</code> client class.</h2><span id='topic+crew_class_client'></span>

<h3>Description</h3>

<p><code>R6</code> class for <code>mirai</code> clients.
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+crew_client">crew_client()</a></code>.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>host</code></dt><dd><p>See <code><a href="#topic+crew_client">crew_client()</a></code>.</p>
</dd>
<dt><code>port</code></dt><dd><p>See <code><a href="#topic+crew_client">crew_client()</a></code>.</p>
</dd>
<dt><code>tls</code></dt><dd><p>See <code><a href="#topic+crew_client">crew_client()</a></code>.</p>
</dd>
<dt><code>seconds_interval</code></dt><dd><p>See <code><a href="#topic+crew_client">crew_client()</a></code>.</p>
</dd>
<dt><code>seconds_timeout</code></dt><dd><p>See <code><a href="#topic+crew_client">crew_client()</a></code>.</p>
</dd>
<dt><code>relay</code></dt><dd><p>Relay object for event-driven programming on a downstream
condition variable.</p>
</dd>
<dt><code>started</code></dt><dd><p>Whether the client is started.</p>
</dd>
<dt><code>url</code></dt><dd><p>Client websocket URL.</p>
</dd>
<dt><code>profile</code></dt><dd><p>Compute profile of the client.</p>
</dd>
<dt><code>client</code></dt><dd><p>Process ID of the local process running the client.</p>
</dd>
<dt><code>dispatcher</code></dt><dd><p>Process ID of the <code>mirai</code> dispatcher</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-crew_class_client-new"><code>crew_class_client$new()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_client-validate"><code>crew_class_client$validate()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_client-start"><code>crew_class_client$start()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_client-terminate"><code>crew_class_client$terminate()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_client-condition"><code>crew_class_client$condition()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_client-resolved"><code>crew_class_client$resolved()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_client-status"><code>crew_class_client$status()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_client-pids"><code>crew_class_client$pids()</code></a>
</p>
</li></ul>


<hr>
<a id="method-crew_class_client-new"></a>



<h4>Method <code>new()</code></h4>

<p><code>mirai</code> client constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_client$new(
  host = NULL,
  port = NULL,
  tls = NULL,
  seconds_interval = NULL,
  seconds_timeout = NULL,
  relay = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>host</code></dt><dd><p>Argument passed from <code><a href="#topic+crew_client">crew_client()</a></code>.</p>
</dd>
<dt><code>port</code></dt><dd><p>Argument passed from <code><a href="#topic+crew_client">crew_client()</a></code>.</p>
</dd>
<dt><code>tls</code></dt><dd><p>Argument passed from <code><a href="#topic+crew_client">crew_client()</a></code>.</p>
</dd>
<dt><code>seconds_interval</code></dt><dd><p>Argument passed from <code><a href="#topic+crew_client">crew_client()</a></code>.</p>
</dd>
<dt><code>seconds_timeout</code></dt><dd><p>Argument passed from <code><a href="#topic+crew_client">crew_client()</a></code>.</p>
</dd>
<dt><code>relay</code></dt><dd><p>Argument passed from <code><a href="#topic+crew_client">crew_client()</a></code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An <code>R6</code> object with the client.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (identical(Sys.getenv("CREW_EXAMPLES"), "true")) {
client &lt;- crew_client()
client$start()
client$log()
client$terminate()
}
</pre>
</div>


<hr>
<a id="method-crew_class_client-validate"></a>



<h4>Method <code>validate()</code></h4>

<p>Validate the client.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_client$validate()</pre></div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_client-start"></a>



<h4>Method <code>start()</code></h4>

<p>Start listening for workers on the available sockets.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_client$start()</pre></div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_client-terminate"></a>



<h4>Method <code>terminate()</code></h4>

<p>Stop the mirai client and disconnect from the
worker websockets.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_client$terminate()</pre></div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_client-condition"></a>



<h4>Method <code>condition()</code></h4>

<p>Get the <code>nanonext</code> condition variable which tasks signal
on resolution.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_client$condition()</pre></div>



<h5>Returns</h5>

<p>The <code>nanonext</code> condition variable which tasks signal
on resolution. The return value is <code>NULL</code> if the client
is not running.
</p>


<hr>
<a id="method-crew_class_client-resolved"></a>



<h4>Method <code>resolved()</code></h4>

<p>Get the true value of the <code>nanonext</code> condition variable.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_client$resolved()</pre></div>



<h5>Returns</h5>

<p>The value of the <code>nanonext</code> condition variable.
</p>


<hr>
<a id="method-crew_class_client-status"></a>



<h4>Method <code>status()</code></h4>

<p>Internal function:
return the <code>mirai</code> status of the compute profile.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_client$status()</pre></div>



<h5>Details</h5>

<p>Should only be called by the launcher, never by the user.
The returned <code>events</code> field changes on every call and must be
interpreted by the launcher before it vanishes.
</p>



<h5>Returns</h5>

<p>A list with status information.
</p>


<hr>
<a id="method-crew_class_client-pids"></a>



<h4>Method <code>pids()</code></h4>

<p>Get the process IDs of the local process and the
<code>mirai</code> dispatcher (if started).
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_client$pids()</pre></div>



<h5>Returns</h5>

<p>An integer vector of process IDs of the local process and the
<code>mirai</code> dispatcher (if started).
</p>




<h3>See Also</h3>

<p>Other client: 
<code><a href="#topic+crew_client">crew_client</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("CREW_EXAMPLES"), "true")) {
client &lt;- crew_client()
client$start()
client$log()
client$terminate()
}

## ------------------------------------------------
## Method `crew_class_client$new`
## ------------------------------------------------

if (identical(Sys.getenv("CREW_EXAMPLES"), "true")) {
client &lt;- crew_client()
client$start()
client$log()
client$terminate()
}
</code></pre>

<hr>
<h2 id='crew_class_controller'>Controller class</h2><span id='topic+crew_class_controller'></span>

<h3>Description</h3>

<p><code>R6</code> class for controllers.
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+crew_controller">crew_controller()</a></code>.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>client</code></dt><dd><p>Router object.</p>
</dd>
<dt><code>launcher</code></dt><dd><p>Launcher object.</p>
</dd>
<dt><code>tasks</code></dt><dd><p>A list of <code>mirai::mirai()</code> task objects.</p>
</dd>
<dt><code>pushed</code></dt><dd><p>Number of tasks pushed since the controller was started.</p>
</dd>
<dt><code>popped</code></dt><dd><p>Number of tasks popped
since the controller was started.</p>
</dd>
<dt><code>crashes_max</code></dt><dd><p>See <code><a href="#topic+crew_controller">crew_controller()</a></code>.</p>
</dd>
<dt><code>backup</code></dt><dd><p>See <code><a href="#topic+crew_controller">crew_controller()</a></code>.</p>
</dd>
<dt><code>error</code></dt><dd><p>Tibble of task results (with one result per row)
from the last call to <code style="white-space: pre;">&#8288;map(error = "stop)&#8288;</code>.</p>
</dd>
<dt><code>backlog</code></dt><dd><p>Character vector of explicitly backlogged tasks.</p>
</dd>
<dt><code>autoscaling</code></dt><dd><p><code>TRUE</code> or <code>FALSE</code>, whether async <code>later</code>-based
auto-scaling is currently running</p>
</dd>
<dt><code>queue</code></dt><dd><p>Queue of resolved unpopped/uncollected tasks.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-crew_class_controller-new"><code>crew_class_controller$new()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-validate"><code>crew_class_controller$validate()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-empty"><code>crew_class_controller$empty()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-nonempty"><code>crew_class_controller$nonempty()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-resolved"><code>crew_class_controller$resolved()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-unresolved"><code>crew_class_controller$unresolved()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-unpopped"><code>crew_class_controller$unpopped()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-saturated"><code>crew_class_controller$saturated()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-start"><code>crew_class_controller$start()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-started"><code>crew_class_controller$started()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-launch"><code>crew_class_controller$launch()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-scale"><code>crew_class_controller$scale()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-autoscale"><code>crew_class_controller$autoscale()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-descale"><code>crew_class_controller$descale()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-crashes"><code>crew_class_controller$crashes()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-push"><code>crew_class_controller$push()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-walk"><code>crew_class_controller$walk()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-map"><code>crew_class_controller$map()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-pop"><code>crew_class_controller$pop()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-collect"><code>crew_class_controller$collect()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-promise"><code>crew_class_controller$promise()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-wait"><code>crew_class_controller$wait()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-push_backlog"><code>crew_class_controller$push_backlog()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-pop_backlog"><code>crew_class_controller$pop_backlog()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-summary"><code>crew_class_controller$summary()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-cancel"><code>crew_class_controller$cancel()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-pids"><code>crew_class_controller$pids()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller-terminate"><code>crew_class_controller$terminate()</code></a>
</p>
</li></ul>


<hr>
<a id="method-crew_class_controller-new"></a>



<h4>Method <code>new()</code></h4>

<p><code>mirai</code> controller constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$new(
  client = NULL,
  launcher = NULL,
  crashes_max = NULL,
  backup = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>client</code></dt><dd><p>Router object. See <code><a href="#topic+crew_controller">crew_controller()</a></code>.</p>
</dd>
<dt><code>launcher</code></dt><dd><p>Launcher object. See <code><a href="#topic+crew_controller">crew_controller()</a></code>.</p>
</dd>
<dt><code>crashes_max</code></dt><dd><p>See <code><a href="#topic+crew_controller">crew_controller()</a></code>.</p>
</dd>
<dt><code>backup</code></dt><dd><p>See <code><a href="#topic+crew_controller">crew_controller()</a></code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An <code>R6</code> controller object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (identical(Sys.getenv("CREW_EXAMPLES"), "true")) {
client &lt;- crew_client()
launcher &lt;- crew_launcher_local()
controller &lt;- crew_controller(client = client, launcher = launcher)
controller$start()
controller$push(name = "task", command = sqrt(4))
controller$wait()
controller$pop()
controller$terminate()
}
</pre>
</div>


<hr>
<a id="method-crew_class_controller-validate"></a>



<h4>Method <code>validate()</code></h4>

<p>Validate the controller.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$validate()</pre></div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_controller-empty"></a>



<h4>Method <code>empty()</code></h4>

<p>Check if the controller is empty.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$empty(controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>A controller is empty if it has no running tasks
or completed tasks waiting to be retrieved with <code>push()</code>.
</p>



<h5>Returns</h5>

<p><code>TRUE</code> if the controller is empty, <code>FALSE</code> otherwise.
</p>


<hr>
<a id="method-crew_class_controller-nonempty"></a>



<h4>Method <code>nonempty()</code></h4>

<p>Check if the controller is nonempty.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$nonempty(controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>A controller is empty if it has no running tasks
or completed tasks waiting to be retrieved with <code>push()</code>.
</p>



<h5>Returns</h5>

<p><code>TRUE</code> if the controller is empty, <code>FALSE</code> otherwise.
</p>


<hr>
<a id="method-crew_class_controller-resolved"></a>



<h4>Method <code>resolved()</code></h4>

<p>Number of resolved <code>mirai()</code> tasks.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$resolved(controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code>resolved()</code> is cumulative: it counts all the resolved
tasks over the entire lifetime of the controller session.
</p>



<h5>Returns</h5>

<p>Non-negative integer of length 1,
number of resolved <code>mirai()</code> tasks.
The return value is 0 if the condition variable does not exist
(i.e. if the client is not running).
</p>


<hr>
<a id="method-crew_class_controller-unresolved"></a>



<h4>Method <code>unresolved()</code></h4>

<p>Number of unresolved <code>mirai()</code> tasks.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$unresolved(controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Non-negative integer of length 1,
number of unresolved <code>mirai()</code> tasks.
</p>


<hr>
<a id="method-crew_class_controller-unpopped"></a>



<h4>Method <code>unpopped()</code></h4>

<p>Number of resolved <code>mirai()</code> tasks available via <code>pop()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$unpopped(controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Non-negative integer of length 1,
number of resolved <code>mirai()</code> tasks available via <code>pop()</code>.
</p>


<hr>
<a id="method-crew_class_controller-saturated"></a>



<h4>Method <code>saturated()</code></h4>

<p>Check if the controller is saturated.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$saturated(
  collect = NULL,
  throttle = NULL,
  controller = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>collect</code></dt><dd><p>Deprecated in version 0.5.0.9003 (2023-10-02). Not used.</p>
</dd>
<dt><code>throttle</code></dt><dd><p>Deprecated in version 0.5.0.9003 (2023-10-02). Not used.</p>
</dd>
<dt><code>controller</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>A controller is saturated if the number of unresolved tasks
is greater than or equal to the maximum number of workers.
In other words, in a saturated controller, every available worker
has a task.
You can still push tasks to a saturated controller, but
tools that use <code>crew</code> such as <code>targets</code> may choose not to.
</p>



<h5>Returns</h5>

<p><code>TRUE</code> if the controller is saturated, <code>FALSE</code> otherwise.
</p>


<hr>
<a id="method-crew_class_controller-start"></a>



<h4>Method <code>start()</code></h4>

<p>Start the controller if it is not already started.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$start(controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Register the mirai client and register worker websockets
with the launcher.
</p>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_controller-started"></a>



<h4>Method <code>started()</code></h4>

<p>Check whether the controller is started.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$started(controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Actually checks whether the client is started.
</p>



<h5>Returns</h5>

<p><code>TRUE</code> if the controller is started, <code>FALSE</code> otherwise.
</p>


<hr>
<a id="method-crew_class_controller-launch"></a>



<h4>Method <code>launch()</code></h4>

<p>Launch one or more workers.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$launch(n = 1L, controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of workers to launch.</p>
</dd>
<dt><code>controllers</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_controller-scale"></a>



<h4>Method <code>scale()</code></h4>

<p>Auto-scale workers out to meet the demand of tasks.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$scale(throttle = TRUE, controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>throttle</code></dt><dd><p><code>TRUE</code> to skip auto-scaling if it already happened
within the last <code>seconds_interval</code> seconds. <code>FALSE</code> to auto-scale
every time <code>scale()</code> is called. Throttling avoids
overburdening the <code>mirai</code> dispatcher and other resources.</p>
</dd>
<dt><code>controllers</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The <code>scale()</code> method re-launches all inactive backlogged
workers, then any additional inactive workers needed to
accommodate the demand of unresolved tasks. A worker is
&quot;backlogged&quot; if it was assigned more tasks than it has completed
so far.
</p>
<p>Methods <code>push()</code>, <code>pop()</code>, and <code>wait()</code> already invoke
<code>scale()</code> if the <code>scale</code> argument is <code>TRUE</code>.
For finer control of the number of workers launched,
call <code>launch()</code> on the controller with the exact desired
number of workers.
</p>



<h5>Returns</h5>

<p>Invisibly returns <code>TRUE</code> if there was any relevant
auto-scaling activity (new worker launches or worker
connection/disconnection events) (<code>FALSE</code> otherwise).
</p>


<hr>
<a id="method-crew_class_controller-autoscale"></a>



<h4>Method <code>autoscale()</code></h4>

<p>Run worker auto-scaling in a private <code>later</code> loop
every <code>controller$client$seconds_interval</code> seconds.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$autoscale(controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Call <code>controller$descale()</code> to terminate the
auto-scaling loop.
</p>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_controller-descale"></a>



<h4>Method <code>descale()</code></h4>

<p>Terminate the auto-scaling loop started by
<code>controller$autoscale()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$descale(controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_controller-crashes"></a>



<h4>Method <code>crashes()</code></h4>

<p>Report the number of consecutive crashes of a task.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$crashes(name, controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Character string, name of the task to check.</p>
</dd>
<dt><code>controllers</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>See the <code>crashes_max</code> argument of <code><a href="#topic+crew_controller">crew_controller()</a></code>.
</p>



<h5>Returns</h5>

<p>Non-negative integer, number of consecutive times the task
crashed.
</p>


<hr>
<a id="method-crew_class_controller-push"></a>



<h4>Method <code>push()</code></h4>

<p>Push a task to the head of the task list.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$push(
  command,
  data = list(),
  globals = list(),
  substitute = TRUE,
  seed = NULL,
  algorithm = NULL,
  packages = character(0),
  library = NULL,
  seconds_timeout = NULL,
  scale = TRUE,
  throttle = TRUE,
  name = NULL,
  save_command = NULL,
  controller = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>command</code></dt><dd><p>Language object with R code to run.</p>
</dd>
<dt><code>data</code></dt><dd><p>Named list of local data objects in the
evaluation environment.</p>
</dd>
<dt><code>globals</code></dt><dd><p>Named list of objects to temporarily assign to the
global environment for the task.
This list should
include any functions you previously defined in the global
environment which are required to run tasks.
See the <code>reset_globals</code> argument
of <code><a href="#topic+crew_controller_local">crew_controller_local()</a></code>.</p>
</dd>
<dt><code>substitute</code></dt><dd><p>Logical of length 1, whether to call
<code>base::substitute()</code> on the supplied value of the
<code>command</code> argument. If <code>TRUE</code> (default) then <code>command</code> is quoted
literally as you write it, e.g.
<code>push(command = your_function_call())</code>. If <code>FALSE</code>, then <code>crew</code>
assumes <code>command</code> is a language object and you are passing its
value, e.g. <code>push(command = quote(your_function_call()))</code>.
<code>substitute = TRUE</code> is appropriate for interactive use,
whereas <code>substitute = FALSE</code> is meant for automated R programs
that invoke <code>crew</code> controllers.</p>
</dd>
<dt><code>seed</code></dt><dd><p>Integer of length 1 with the pseudo-random number generator
seed to set for the evaluation of the task. Passed to the
<code>seed</code> argument of <code>set.seed()</code> if not <code>NULL</code>.
If <code>algorithm</code> and <code>seed</code> are both <code>NULL</code>,
then the random number generator defaults to the
widely spaced worker-specific
L'Ecuyer streams as supported by <code>mirai::nextstream()</code>.
See <code>vignette("parallel", package = "parallel")</code> for details.</p>
</dd>
<dt><code>algorithm</code></dt><dd><p>Integer of length 1 with the pseudo-random number
generator algorithm to set for the evaluation of the task.
Passed to the <code>kind</code> argument of <code>RNGkind()</code> if not <code>NULL</code>.
If <code>algorithm</code> and <code>seed</code> are both <code>NULL</code>,
then the random number generator defaults to the
recommended widely spaced worker-specific
L'Ecuyer streams as supported by <code>mirai::nextstream()</code>.
See <code>vignette("parallel", package = "parallel")</code> for details.</p>
</dd>
<dt><code>packages</code></dt><dd><p>Character vector of packages to load for the task.</p>
</dd>
<dt><code>library</code></dt><dd><p>Library path to load the packages. See the <code>lib.loc</code>
argument of <code>require()</code>.</p>
</dd>
<dt><code>seconds_timeout</code></dt><dd><p>Optional task timeout passed to the <code>.timeout</code>
argument of <code>mirai::mirai()</code> (after converting to milliseconds).</p>
</dd>
<dt><code>scale</code></dt><dd><p>Logical, whether to automatically call <code>scale()</code>
to auto-scale workers to meet the demand of the task load. Also
see the <code>throttle</code> argument.</p>
</dd>
<dt><code>throttle</code></dt><dd><p><code>TRUE</code> to skip auto-scaling if it already happened
within the last <code>seconds_interval</code> seconds. <code>FALSE</code> to auto-scale
every time <code>scale()</code> is called. Throttling avoids
overburdening the <code>mirai</code> dispatcher and other resources.</p>
</dd>
<dt><code>name</code></dt><dd><p>Character string, name of the task. If <code>NULL</code>, then
a random name is generated automatically.
The name of the task must not conflict with the name of another
task pushed to the controller. Any previous task with the same name
must first be popped before a new task with that name can be pushed.</p>
</dd>
<dt><code>save_command</code></dt><dd><p>Deprecated on 2025-01-22 (<code>crew</code> version
0.10.2.9004) and no longer used.</p>
</dd>
<dt><code>controller</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Invisibly return the <code>mirai</code> object of the pushed task.
This allows you to interact with the task directly, e.g.
to create a promise object with <code>promises::as.promise()</code>.
</p>


<hr>
<a id="method-crew_class_controller-walk"></a>



<h4>Method <code>walk()</code></h4>

<p>Apply a single command to multiple inputs,
and return control to the user without
waiting for any task to complete.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$walk(
  command,
  iterate,
  data = list(),
  globals = list(),
  substitute = TRUE,
  seed = NULL,
  algorithm = NULL,
  packages = character(0),
  library = NULL,
  seconds_timeout = NULL,
  names = NULL,
  save_command = NULL,
  scale = TRUE,
  throttle = TRUE,
  controller = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>command</code></dt><dd><p>Language object with R code to run.</p>
</dd>
<dt><code>iterate</code></dt><dd><p>Named list of vectors or lists to iterate over.
For example, to run function calls
<code>f(x = 1, y = "a")</code> and <code>f(x = 2, y = "b")</code>,
set <code>command</code> to <code>f(x, y)</code>, and set <code>iterate</code> to
<code>list(x = c(1, 2), y = c("a", "b"))</code>. The individual
function calls are evaluated as
<code>f(x = iterate$x[[1]], y = iterate$y[[1]])</code> and
<code>f(x = iterate$x[[2]], y = iterate$y[[2]])</code>.
All the elements of <code>iterate</code> must have the same length.
If there are any name conflicts between <code>iterate</code> and <code>data</code>,
<code>iterate</code> takes precedence.</p>
</dd>
<dt><code>data</code></dt><dd><p>Named list of constant local data objects in the
evaluation environment. Objects in this list are treated as single
values and are held constant for each iteration of the map.</p>
</dd>
<dt><code>globals</code></dt><dd><p>Named list of constant objects to temporarily
assign to the global environment for each task. This list should
include any functions you previously defined in the global
environment which are required to run tasks.
See the <code>reset_globals</code> argument of <code><a href="#topic+crew_controller_local">crew_controller_local()</a></code>.
Objects in this list are treated as single
values and are held constant for each iteration of the map.</p>
</dd>
<dt><code>substitute</code></dt><dd><p>Logical of length 1, whether to call
<code>base::substitute()</code> on the supplied value of the
<code>command</code> argument. If <code>TRUE</code> (default) then <code>command</code> is quoted
literally as you write it, e.g.
<code>push(command = your_function_call())</code>. If <code>FALSE</code>, then <code>crew</code>
assumes <code>command</code> is a language object and you are passing its
value, e.g. <code>push(command = quote(your_function_call()))</code>.
<code>substitute = TRUE</code> is appropriate for interactive use,
whereas <code>substitute = FALSE</code> is meant for automated R programs
that invoke <code>crew</code> controllers.</p>
</dd>
<dt><code>seed</code></dt><dd><p>Integer of length 1 with the pseudo-random number generator
seed to set for the evaluation of the task. Passed to the
<code>seed</code> argument of <code>set.seed()</code> if not <code>NULL</code>.
If <code>algorithm</code> and <code>seed</code> are both <code>NULL</code>,
then the random number generator defaults to the
recommended widely spaced worker-specific
L'Ecuyer streams as supported by <code>mirai::nextstream()</code>.
See <code>vignette("parallel", package = "parallel")</code> for details.</p>
</dd>
<dt><code>algorithm</code></dt><dd><p>Integer of length 1 with the pseudo-random number
generator algorithm to set for the evaluation of the task.
Passed to the <code>kind</code> argument of <code>RNGkind()</code> if not <code>NULL</code>.
If <code>algorithm</code> and <code>seed</code> are both <code>NULL</code>,
then the random number generator defaults to the
recommended widely spaced worker-specific
L'Ecuyer streams as supported by <code>mirai::nextstream()</code>.
See <code>vignette("parallel", package = "parallel")</code> for details.</p>
</dd>
<dt><code>packages</code></dt><dd><p>Character vector of packages to load for the task.</p>
</dd>
<dt><code>library</code></dt><dd><p>Library path to load the packages. See the <code>lib.loc</code>
argument of <code>require()</code>.</p>
</dd>
<dt><code>seconds_timeout</code></dt><dd><p>Optional task timeout passed to the <code>.timeout</code>
argument of <code>mirai::mirai()</code> (after converting to milliseconds).</p>
</dd>
<dt><code>names</code></dt><dd><p>Optional character of length 1, name of the element of
<code>iterate</code> with names for the tasks. If <code>names</code> is supplied,
then <code>iterate[[names]]</code> must be a character vector.</p>
</dd>
<dt><code>save_command</code></dt><dd><p>Deprecated on 2025-01-22 (<code>crew</code> version
0.10.2.9004). The command is always saved now.</p>
</dd>
<dt><code>scale</code></dt><dd><p>Logical, whether to automatically scale workers to meet
demand. See also the <code>throttle</code> argument.</p>
</dd>
<dt><code>throttle</code></dt><dd><p><code>TRUE</code> to skip auto-scaling if it already happened
within the last <code>seconds_interval</code> seconds. <code>FALSE</code> to auto-scale
every time <code>scale()</code> is called. Throttling avoids
overburdening the <code>mirai</code> dispatcher and other resources.</p>
</dd>
<dt><code>controller</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>In contrast to <code>walk()</code>, <code>map()</code> blocks the local R session
and waits for all tasks to complete.
</p>



<h5>Returns</h5>

<p>Invisibly returns a list of <code>mirai</code> task objects for the
newly created tasks. The order of tasks in the list matches the
order of data in the <code>iterate</code> argument.
</p>


<hr>
<a id="method-crew_class_controller-map"></a>



<h4>Method <code>map()</code></h4>

<p>Apply a single command to multiple inputs,
wait for all tasks to complete,
and return the results of all tasks.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$map(
  command,
  iterate,
  data = list(),
  globals = list(),
  substitute = TRUE,
  seed = NULL,
  algorithm = NULL,
  packages = character(0),
  library = NULL,
  seconds_interval = NULL,
  seconds_timeout = NULL,
  names = NULL,
  save_command = NULL,
  error = "stop",
  warnings = TRUE,
  verbose = interactive(),
  scale = TRUE,
  throttle = TRUE,
  controller = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>command</code></dt><dd><p>Language object with R code to run.</p>
</dd>
<dt><code>iterate</code></dt><dd><p>Named list of vectors or lists to iterate over.
For example, to run function calls
<code>f(x = 1, y = "a")</code> and <code>f(x = 2, y = "b")</code>,
set <code>command</code> to <code>f(x, y)</code>, and set <code>iterate</code> to
<code>list(x = c(1, 2), y = c("a", "b"))</code>. The individual
function calls are evaluated as
<code>f(x = iterate$x[[1]], y = iterate$y[[1]])</code> and
<code>f(x = iterate$x[[2]], y = iterate$y[[2]])</code>.
All the elements of <code>iterate</code> must have the same length.
If there are any name conflicts between <code>iterate</code> and <code>data</code>,
<code>iterate</code> takes precedence.</p>
</dd>
<dt><code>data</code></dt><dd><p>Named list of constant local data objects in the
evaluation environment. Objects in this list are treated as single
values and are held constant for each iteration of the map.</p>
</dd>
<dt><code>globals</code></dt><dd><p>Named list of constant objects to temporarily
assign to the global environment for each task. This list should
include any functions you previously defined in the global
environment which are required to run tasks.
See the <code>reset_globals</code> argument of <code><a href="#topic+crew_controller_local">crew_controller_local()</a></code>.
Objects in this list are treated as single
values and are held constant for each iteration of the map.</p>
</dd>
<dt><code>substitute</code></dt><dd><p>Logical of length 1, whether to call
<code>base::substitute()</code> on the supplied value of the
<code>command</code> argument. If <code>TRUE</code> (default) then <code>command</code> is quoted
literally as you write it, e.g.
<code>push(command = your_function_call())</code>. If <code>FALSE</code>, then <code>crew</code>
assumes <code>command</code> is a language object and you are passing its
value, e.g. <code>push(command = quote(your_function_call()))</code>.
<code>substitute = TRUE</code> is appropriate for interactive use,
whereas <code>substitute = FALSE</code> is meant for automated R programs
that invoke <code>crew</code> controllers.</p>
</dd>
<dt><code>seed</code></dt><dd><p>Integer of length 1 with the pseudo-random number generator
seed to set for the evaluation of the task. Passed to the
<code>seed</code> argument of <code>set.seed()</code> if not <code>NULL</code>.
If <code>algorithm</code> and <code>seed</code> are both <code>NULL</code>,
then the random number generator defaults to the
recommended widely spaced worker-specific
L'Ecuyer streams as supported by <code>mirai::nextstream()</code>.
See <code>vignette("parallel", package = "parallel")</code> for details.</p>
</dd>
<dt><code>algorithm</code></dt><dd><p>Integer of length 1 with the pseudo-random number
generator algorithm to set for the evaluation of the task.
Passed to the <code>kind</code> argument of <code>RNGkind()</code> if not <code>NULL</code>.
If <code>algorithm</code> and <code>seed</code> are both <code>NULL</code>,
then the random number generator defaults to the
recommended widely spaced worker-specific
L'Ecuyer streams as supported by <code>mirai::nextstream()</code>.
See <code>vignette("parallel", package = "parallel")</code> for details.</p>
</dd>
<dt><code>packages</code></dt><dd><p>Character vector of packages to load for the task.</p>
</dd>
<dt><code>library</code></dt><dd><p>Library path to load the packages. See the <code>lib.loc</code>
argument of <code>require()</code>.</p>
</dd>
<dt><code>seconds_interval</code></dt><dd><p>Deprecated on 2025-01-17 (<code>crew</code> version
0.10.2.9003). Instead, the <code>seconds_interval</code> argument passed
to <code><a href="#topic+crew_controller_group">crew_controller_group()</a></code> is used as <code>seconds_max</code>
in a <code><a href="#topic+crew_throttle">crew_throttle()</a></code> object which orchestrates exponential
backoff.</p>
</dd>
<dt><code>seconds_timeout</code></dt><dd><p>Optional task timeout passed to the <code>.timeout</code>
argument of <code>mirai::mirai()</code> (after converting to milliseconds).</p>
</dd>
<dt><code>names</code></dt><dd><p>Optional character string, name of the element of
<code>iterate</code> with names for the tasks. If <code>names</code> is supplied,
then <code>iterate[[names]]</code> must be a character vector.</p>
</dd>
<dt><code>save_command</code></dt><dd><p>Deprecated on 2025-01-22 (<code>crew</code> version
0.10.2.9004). The command is always saved now.</p>
</dd>
<dt><code>error</code></dt><dd><p>Character of length 1, choice of action if
a task was not successful. Possible values:
</p>

<ul>
<li> <p><code>"stop"</code>: throw an error in the main R session instead of returning
a value. In case of an error, the results from the last errored
<code>map()</code> are in the <code>error</code> field
of the controller, e.g. <code>controller_object$error</code>. To reduce
memory consumption, set <code>controller_object$error &lt;- NULL</code> after
you are finished troubleshooting.
</p>
</li>
<li> <p><code>"warn"</code>: throw a warning. This allows the return value with
all the error messages and tracebacks to be generated.
</p>
</li>
<li> <p><code>"silent"</code>: do nothing special.
NOTE: the only kinds of errors considered here are errors at the R
level. A crashed tasks will return a status of <code>"crash"</code> in the output
and not trigger an error in <code>map()</code> unless <code>crashes_max</code> is reached.
</p>
</li></ul>
</dd>
<dt><code>warnings</code></dt><dd><p>Logical of length 1, whether to throw a warning in the
interactive session if at least one task encounters an error.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Logical of length 1, whether to print progress messages.</p>
</dd>
<dt><code>scale</code></dt><dd><p>Logical, whether to automatically scale workers to meet
demand. See also the <code>throttle</code> argument.</p>
</dd>
<dt><code>throttle</code></dt><dd><p><code>TRUE</code> to skip auto-scaling if it already happened
within the last <code>seconds_interval</code> seconds. <code>FALSE</code> to auto-scale
every time <code>scale()</code> is called. Throttling avoids
overburdening the <code>mirai</code> dispatcher and other resources.</p>
</dd>
<dt><code>controller</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code>map()</code> cannot be used unless all prior tasks are
completed and popped. You may need to wait and then pop them
manually. Alternatively, you can start over: either call
<code>terminate()</code> on the current controller object to reset it, or
create a new controller object entirely.
</p>



<h5>Returns</h5>

<p>A <code>tibble</code> of results and metadata: one row per task
and columns corresponding to the output of <code>pop()</code>.
</p>


<hr>
<a id="method-crew_class_controller-pop"></a>



<h4>Method <code>pop()</code></h4>

<p>Pop a completed task from the results data frame.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$pop(
  scale = TRUE,
  collect = NULL,
  throttle = TRUE,
  error = NULL,
  controllers = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>scale</code></dt><dd><p>Logical of length 1,
whether to automatically call <code>scale()</code>
to auto-scale workers to meet the demand of the task load.
Scaling up on <code>pop()</code> may be important
for transient or nearly transient workers that tend to drop off
quickly after doing little work.
See also the <code>throttle</code> argument.</p>
</dd>
<dt><code>collect</code></dt><dd><p>Deprecated in version 0.5.0.9003 (2023-10-02).</p>
</dd>
<dt><code>throttle</code></dt><dd><p><code>TRUE</code> to skip auto-scaling if it already happened
within the last <code>seconds_interval</code> seconds. <code>FALSE</code> to auto-scale
every time <code>scale()</code> is called. Throttling avoids
overburdening the <code>mirai</code> dispatcher and other resources.</p>
</dd>
<dt><code>error</code></dt><dd><p><code>NULL</code> or character of length 1, choice of action if
the popped task threw an error. Possible values:
</p>

<ul>
<li> <p><code>"stop"</code>: throw an error in the main R session instead of returning
a value.
</p>
</li>
<li> <p><code>"warn"</code>: throw a warning.
</p>
</li>
<li> <p><code>NULL</code> or <code>"silent"</code>: do not react to errors.
NOTE: the only kinds of errors considered here are errors at the R
level. A crashed tasks will return a status of <code>"crash"</code> in the output
and not trigger an error in <code>pop()</code> unless <code>crashes_max</code> is reached.
</p>
</li></ul>
</dd>
<dt><code>controllers</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>If not task is currently completed, <code>pop()</code>
will attempt to auto-scale workers as needed.
</p>



<h5>Returns</h5>

<p>If there is no task to collect, return <code>NULL</code>. Otherwise,
return a one-row <code>tibble</code> with the following columns.
</p>

<ul>
<li> <p><code>name</code>: the task name.
</p>
</li>
<li> <p><code>command</code>: a character string with the R command.
</p>
</li>
<li> <p><code>result</code>: a list containing the return value of the R command.
<code>NA</code> if the task failed.
</p>
</li>
<li> <p><code>status</code>: a character string. <code>"success"</code> if the task succeeded,
<code>"cancel"</code> if the task was canceled with
the <code>cancel()</code> controller method,
<code>"crash"</code> if the worker running the task exited before
it could complete the task, or <code>"error"</code>
for any other kind of error.
</p>
</li>
<li> <p><code>error</code>: the first 2048 characters of the error message if
the task status is not <code>"success"</code>, <code>NA</code> otherwise.
Messages for crashes and cancellations are captured here
alongside ordinary R-level errors.
</p>
</li>
<li> <p><code>code</code>: an integer code denoting the specific exit status:
<code>0</code> for successful tasks, <code>-1</code> for tasks with an error in the R
command of the task, and another positive integer with an NNG
status code if there is an error at the NNG/<code>nanonext</code> level.
<code>nanonext::nng_error()</code> can interpret these codes.
</p>
</li>
<li> <p><code>trace</code>: the first 2048 characters of the text of the traceback
if the task threw an error, <code>NA</code> otherwise.
</p>
</li>
<li> <p><code>warnings</code>: the first 2048 characters. of the text of
warning messages that the task may have generated, <code>NA</code> otherwise.
</p>
</li>
<li> <p><code>seconds</code>: number of seconds that the task ran.
</p>
</li>
<li> <p><code>seed</code>: the single integer originally supplied to <code>push()</code>,
<code>NA</code> otherwise. The pseudo-random number generator state
just prior to the task can be restored using
<code>set.seed(seed = seed, kind = algorithm)</code>, where <code>seed</code> and
<code>algorithm</code> are part of this output.
</p>
</li>
<li> <p><code>algorithm</code>: name of the pseudo-random number generator algorithm
originally supplied to <code>push()</code>,
<code>NA</code> otherwise. The pseudo-random number generator state
just prior to the task can be restored using
<code>set.seed(seed = seed, kind = algorithm)</code>, where <code>seed</code> and
<code>algorithm</code> are part of this output.
</p>
</li>
<li> <p><code>controller</code>: name of the <code>crew</code> controller where the task ran.
</p>
</li>
<li> <p><code>worker</code>: name of the <code>crew</code> worker that ran the task.
</p>
</li></ul>



<hr>
<a id="method-crew_class_controller-collect"></a>



<h4>Method <code>collect()</code></h4>

<p>Pop all available task results and return them in a tidy
<code>tibble</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$collect(
  scale = TRUE,
  throttle = TRUE,
  error = NULL,
  controllers = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>scale</code></dt><dd><p>Logical of length 1,
whether to automatically call <code>scale()</code>
to auto-scale workers to meet the demand of the task load.</p>
</dd>
<dt><code>throttle</code></dt><dd><p><code>TRUE</code> to skip auto-scaling if it already happened
within the last <code>seconds_interval</code> seconds. <code>FALSE</code> to auto-scale
every time <code>scale()</code> is called. Throttling avoids
overburdening the <code>mirai</code> dispatcher and other resources.</p>
</dd>
<dt><code>error</code></dt><dd><p><code>NULL</code> or character of length 1, choice of action if
the popped task threw an error. Possible values:
* <code>"stop"</code>: throw an error in the main R session instead of
returning a value.
* <code>"warn"</code>: throw a warning.
* <code>NULL</code> or <code>"silent"</code>: do not react to errors.
NOTE: the only kinds of errors considered here are errors at the R
level. A crashed tasks will return a status of <code>"crash"</code> in the output
and not trigger an error in <code>collect()</code>
unless <code>crashes_max</code> is reached.</p>
</dd>
<dt><code>controllers</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>tibble</code> of results and metadata of all resolved tasks,
with one row per task. Returns <code>NULL</code> if there are no tasks
to collect. See <code>pop()</code> for details on the columns of the
returned <code>tibble</code>.
</p>


<hr>
<a id="method-crew_class_controller-promise"></a>



<h4>Method <code>promise()</code></h4>

<p>Create a <code>promises::promise()</code> object to asynchronously
pop or collect one or more tasks.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$promise(
  mode = "one",
  seconds_interval = 1,
  scale = NULL,
  throttle = NULL,
  controllers = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mode</code></dt><dd><p>Character of length 1, what kind of promise to create.
<code>mode</code> must be <code>"one"</code> or <code>"all"</code>. Details:
</p>

<ul>
<li><p> If <code>mode</code> is <code>"one"</code>, then the promise is fulfilled (or rejected)
when at least one task is resolved and available to <code>pop()</code>.
When that happens, <code>pop()</code> runs asynchronously, pops a result off
the task list, and returns a value.
If the task succeeded, then the promise
is fulfilled and its value is the result of <code>pop()</code> (a one-row
<code>tibble</code> with the result and metadata). If the task threw an error,
the error message of the task is forwarded to any error callbacks
registered with the promise.
</p>
</li>
<li><p> If <code>mode</code> is <code>"all"</code>, then the promise is fulfilled (or rejected)
when there are no unresolved tasks left in the controller.
(Be careful: this condition is trivially met in the moment
if the controller is empty and you have not submitted any tasks,
so it is best to create this kind of promise only after you
submit tasks.)
When there are no unresolved tasks left,
<code>collect()</code> runs asynchronously, pops all available results
off the task list, and returns a value.
If the task succeeded, then the promise
is fulfilled and its value is the result of <code>collect()</code>
(a <code>tibble</code> with one row per task result). If any of the tasks
threw an error, then the first error message detected is forwarded
to any error callbacks registered with the promise.
</p>
</li></ul>
</dd>
<dt><code>seconds_interval</code></dt><dd><p>Positive numeric of length 1, delay in the
<code>later::later()</code> polling interval to asynchronously check if
the promise can be resolved.</p>
</dd>
<dt><code>scale</code></dt><dd><p>Deprecated on 2024-04-10 (version 0.9.1.9003)
and no longer used. Now, <code>promise()</code> always turns on auto-scaling
in a private <code>later</code> loop (if not already activated).</p>
</dd>
<dt><code>throttle</code></dt><dd><p>Deprecated on 2024-04-10 (version 0.9.1.9003)
and no longer used. Now, <code>promise()</code> always turns on auto-scaling
in a private <code>later</code> loop (if not already activated).</p>
</dd>
<dt><code>controllers</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Please be aware that <code>pop()</code> or <code>collect()</code> will happen
asynchronously at a some unpredictable time after the promise object
is created, even if your local R process appears to be doing
something completely different. This behavior is highly desirable
in a Shiny reactive context, but please be careful as it may be
surprising in other situations.
</p>



<h5>Returns</h5>

<p>A <code>promises::promise()</code> object whose eventual value will
be a <code>tibble</code> with results from one or more popped tasks.
If <code>mode = "one"</code>, only one task is popped and returned (one row).
If <code>mode = "all"</code>, then all the tasks are returned in a <code>tibble</code>
with one row per task (or <code>NULL</code> is returned if there are no
tasks to pop).
</p>


<hr>
<a id="method-crew_class_controller-wait"></a>



<h4>Method <code>wait()</code></h4>

<p>Wait for tasks.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$wait(
  mode = "all",
  seconds_interval = NULL,
  seconds_timeout = Inf,
  scale = TRUE,
  throttle = TRUE,
  controllers = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mode</code></dt><dd><p>Character of length 1: <code>"all"</code> to wait for all tasks to
complete, <code>"one"</code> to wait for a single task to complete.</p>
</dd>
<dt><code>seconds_interval</code></dt><dd><p>Deprecated on 2025-01-17 (<code>crew</code> version
0.10.2.9003). Instead, the <code>seconds_interval</code> argument passed
to <code><a href="#topic+crew_controller_group">crew_controller_group()</a></code> is used as <code>seconds_max</code>
in a <code><a href="#topic+crew_throttle">crew_throttle()</a></code> object which orchestrates exponential
backoff.</p>
</dd>
<dt><code>seconds_timeout</code></dt><dd><p>Timeout length in seconds waiting for tasks.</p>
</dd>
<dt><code>scale</code></dt><dd><p>Logical, whether to automatically call <code>scale()</code>
to auto-scale workers to meet the demand of the task load.
See also the <code>throttle</code> argument.</p>
</dd>
<dt><code>throttle</code></dt><dd><p><code>TRUE</code> to skip auto-scaling if it already happened
within the last <code>seconds_interval</code> seconds. <code>FALSE</code> to auto-scale
every time <code>scale()</code> is called. Throttling avoids
overburdening the <code>mirai</code> dispatcher and other resources.</p>
</dd>
<dt><code>controllers</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The <code>wait()</code> method blocks the calling R session and
repeatedly auto-scales workers for tasks that need them.
The function runs until it either times out or the condition
in <code>mode</code> is met.
</p>



<h5>Returns</h5>

<p>A logical of length 1, invisibly. <code>TRUE</code> if the condition
in <code>mode</code> was met, <code>FALSE</code> otherwise.
</p>


<hr>
<a id="method-crew_class_controller-push_backlog"></a>



<h4>Method <code>push_backlog()</code></h4>

<p>Push the name of a task to the backlog.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$push_backlog(name, controller = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Character of length 1 with the task name to push to
the backlog.</p>
</dd>
<dt><code>controller</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code>pop_backlog()</code> pops the tasks that can be pushed
without saturating the controller.
</p>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_controller-pop_backlog"></a>



<h4>Method <code>pop_backlog()</code></h4>

<p>Pop the task names from the head of the backlog which
can be pushed without saturating the controller.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$pop_backlog(controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Character vector of task names which can be pushed to the
controller without saturating it. If the controller is saturated,
<code>character(0L)</code> is returned.
</p>


<hr>
<a id="method-crew_class_controller-summary"></a>



<h4>Method <code>summary()</code></h4>

<p>Summarize the workers and tasks of the controller.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$summary(controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A data frame of summary statistics on the tasks
that ran on a worker and then were returned by <code>pop()</code> or
<code>collect()</code>.
It has one row and the following columns:
</p>

<ul>
<li> <p><code>controller</code>: name of the controller.
</p>
</li>
<li> <p><code>tasks</code>: number of tasks.
</p>
</li>
<li> <p><code>seconds</code>: total number of runtime in seconds.
</p>
</li>
<li> <p><code>success</code>: total number of successful tasks.
</p>
</li>
<li> <p><code>error</code>: total number of tasks with errors, either in the R code
of the task or an NNG-level error that is not a cancellation
or crash.
</p>
</li>
<li> <p><code>crash</code>: total number of crashed tasks (where the worker exited
unexpectedly while it was running the task).
</p>
</li>
<li> <p><code>cancel</code>: total number of tasks interrupted with the <code>cancel()</code>
controller method.
</p>
</li>
<li> <p><code>warnings</code>: total number of tasks with one or more warnings.
</p>
</li></ul>



<hr>
<a id="method-crew_class_controller-cancel"></a>



<h4>Method <code>cancel()</code></h4>

<p>Cancel one or more tasks.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$cancel(names = character(0L), all = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>names</code></dt><dd><p>Character vector of names of tasks to cancel.
Those names must have been manually supplied by <code>push()</code>.</p>
</dd>
<dt><code>all</code></dt><dd><p><code>TRUE</code> to cancel all tasks, <code>FALSE</code> otherwise.
<code>all = TRUE</code> supersedes the <code>names</code> argument.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-crew_class_controller-pids"></a>



<h4>Method <code>pids()</code></h4>

<p>Get the process IDs of the local process and the
<code>mirai</code> dispatcher (if started).
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$pids(controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An integer vector of process IDs of the local process and the
<code>mirai</code> dispatcher (if started).
</p>


<hr>
<a id="method-crew_class_controller-terminate"></a>



<h4>Method <code>terminate()</code></h4>

<p>Terminate the workers and the <code>mirai</code> client.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller$terminate(controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>




<h3>See Also</h3>

<p>Other controller: 
<code><a href="#topic+crew_controller">crew_controller</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("CREW_EXAMPLES"), "true")) {
client &lt;- crew_client()
launcher &lt;- crew_launcher_local()
controller &lt;- crew_controller(client = client, launcher = launcher)
controller$start()
controller$push(name = "task", command = sqrt(4))
controller$wait()
controller$pop()
controller$terminate()
}

## ------------------------------------------------
## Method `crew_class_controller$new`
## ------------------------------------------------

if (identical(Sys.getenv("CREW_EXAMPLES"), "true")) {
client &lt;- crew_client()
launcher &lt;- crew_launcher_local()
controller &lt;- crew_controller(client = client, launcher = launcher)
controller$start()
controller$push(name = "task", command = sqrt(4))
controller$wait()
controller$pop()
controller$terminate()
}
</code></pre>

<hr>
<h2 id='crew_class_controller_group'>Controller group class</h2><span id='topic+crew_class_controller_group'></span>

<h3>Description</h3>

<p><code>R6</code> class for controller groups.
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+crew_controller_group">crew_controller_group()</a></code>.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>controllers</code></dt><dd><p>List of <code>R6</code> controller objects.</p>
</dd>
<dt><code>relay</code></dt><dd><p>Relay object for event-driven programming on a downstream
condition variable.</p>
</dd>
<dt><code>throttle</code></dt><dd><p><code><a href="#topic+crew_throttle">crew_throttle()</a></code> object to orchestrate exponential
backoff in the relay and auto-scaling.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-crew_class_controller_group-new"><code>crew_class_controller_group$new()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller_group-validate"><code>crew_class_controller_group$validate()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller_group-empty"><code>crew_class_controller_group$empty()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller_group-nonempty"><code>crew_class_controller_group$nonempty()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller_group-resolved"><code>crew_class_controller_group$resolved()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller_group-unresolved"><code>crew_class_controller_group$unresolved()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller_group-unpopped"><code>crew_class_controller_group$unpopped()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller_group-saturated"><code>crew_class_controller_group$saturated()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller_group-start"><code>crew_class_controller_group$start()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller_group-started"><code>crew_class_controller_group$started()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller_group-launch"><code>crew_class_controller_group$launch()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller_group-scale"><code>crew_class_controller_group$scale()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller_group-autoscale"><code>crew_class_controller_group$autoscale()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller_group-descale"><code>crew_class_controller_group$descale()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller_group-crashes"><code>crew_class_controller_group$crashes()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller_group-push"><code>crew_class_controller_group$push()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller_group-walk"><code>crew_class_controller_group$walk()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller_group-map"><code>crew_class_controller_group$map()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller_group-pop"><code>crew_class_controller_group$pop()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller_group-collect"><code>crew_class_controller_group$collect()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller_group-promise"><code>crew_class_controller_group$promise()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller_group-wait"><code>crew_class_controller_group$wait()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller_group-push_backlog"><code>crew_class_controller_group$push_backlog()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller_group-pop_backlog"><code>crew_class_controller_group$pop_backlog()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller_group-summary"><code>crew_class_controller_group$summary()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller_group-pids"><code>crew_class_controller_group$pids()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_controller_group-terminate"><code>crew_class_controller_group$terminate()</code></a>
</p>
</li></ul>


<hr>
<a id="method-crew_class_controller_group-new"></a>



<h4>Method <code>new()</code></h4>

<p>Multi-controller constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$new(
  controllers = NULL,
  relay = NULL,
  throttle = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>List of <code>R6</code> controller objects.</p>
</dd>
<dt><code>relay</code></dt><dd><p>Relay object for event-driven programming on a downstream
condition variable.</p>
</dd>
<dt><code>throttle</code></dt><dd><p><code><a href="#topic+crew_throttle">crew_throttle()</a></code> object to orchestrate exponential
backoff in the relay and auto-scaling.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An <code>R6</code> object with the controller group object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (identical(Sys.getenv("CREW_EXAMPLES"), "true")) {
persistent &lt;- crew_controller_local(name = "persistent")
transient &lt;- crew_controller_local(
  name = "transient",
  tasks_max = 1L
)
group &lt;- crew_controller_group(persistent, transient)
group$start()
group$push(name = "task", command = sqrt(4), controller = "transient")
group$wait()
group$pop()
group$terminate()
}
</pre>
</div>


<hr>
<a id="method-crew_class_controller_group-validate"></a>



<h4>Method <code>validate()</code></h4>

<p>Validate the client.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$validate()</pre></div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_controller_group-empty"></a>



<h4>Method <code>empty()</code></h4>

<p>See if the controllers are empty.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$empty(controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>Character vector of controller names.
Set to <code>NULL</code> to select all controllers.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>A controller is empty if it has no running tasks
or completed tasks waiting to be retrieved with <code>push()</code>.
</p>



<h5>Returns</h5>

<p><code>TRUE</code> if all the selected controllers are empty,
<code>FALSE</code> otherwise.
</p>


<hr>
<a id="method-crew_class_controller_group-nonempty"></a>



<h4>Method <code>nonempty()</code></h4>

<p>Check if the controller group is nonempty.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$nonempty(controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>Character vector of controller names.
Set to <code>NULL</code> to select all controllers.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>A controller is empty if it has no running tasks
or completed tasks waiting to be retrieved with <code>push()</code>.
</p>



<h5>Returns</h5>

<p><code>TRUE</code> if the controller is empty, <code>FALSE</code> otherwise.
</p>


<hr>
<a id="method-crew_class_controller_group-resolved"></a>



<h4>Method <code>resolved()</code></h4>

<p>Number of resolved <code>mirai()</code> tasks.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$resolved(controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>Character vector of controller names.
Set to <code>NULL</code> to select all controllers.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code>resolved()</code> is cumulative: it counts all the resolved
tasks over the entire lifetime of the controller session.
</p>



<h5>Returns</h5>

<p>Non-negative integer of length 1,
number of resolved <code>mirai()</code> tasks.
The return value is 0 if the condition variable does not exist
(i.e. if the client is not running).
</p>


<hr>
<a id="method-crew_class_controller_group-unresolved"></a>



<h4>Method <code>unresolved()</code></h4>

<p>Number of unresolved <code>mirai()</code> tasks.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$unresolved(controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>Character vector of controller names.
Set to <code>NULL</code> to select all controllers.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Non-negative integer of length 1,
number of unresolved <code>mirai()</code> tasks.
</p>


<hr>
<a id="method-crew_class_controller_group-unpopped"></a>



<h4>Method <code>unpopped()</code></h4>

<p>Number of resolved <code>mirai()</code> tasks available via <code>pop()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$unpopped(controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>Character vector of controller names.
Set to <code>NULL</code> to select all controllers.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Non-negative integer of length 1,
number of resolved <code>mirai()</code> tasks available via <code>pop()</code>.
</p>


<hr>
<a id="method-crew_class_controller_group-saturated"></a>



<h4>Method <code>saturated()</code></h4>

<p>Check if a controller is saturated.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$saturated(
  collect = NULL,
  throttle = NULL,
  controller = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>collect</code></dt><dd><p>Deprecated in version 0.5.0.9003 (2023-10-02). Not used.</p>
</dd>
<dt><code>throttle</code></dt><dd><p>Deprecated in version 0.5.0.9003 (2023-10-02). Not used.</p>
</dd>
<dt><code>controller</code></dt><dd><p>Character vector of length 1 with the controller name.
Set to <code>NULL</code> to select the default controller that <code>push()</code>
would choose.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>A controller is saturated if the number of unresolved tasks
is greater than or equal to the maximum number of workers.
In other words, in a saturated controller, every available worker
has a task.
You can still push tasks to a saturated controller, but
tools that use <code>crew</code> such as <code>targets</code> may choose not to.
</p>



<h5>Returns</h5>

<p><code>TRUE</code> if all the selected controllers are saturated,
<code>FALSE</code> otherwise.
</p>


<hr>
<a id="method-crew_class_controller_group-start"></a>



<h4>Method <code>start()</code></h4>

<p>Start one or more controllers.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$start(controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>Character vector of controller names.
Set to <code>NULL</code> to select all controllers.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_controller_group-started"></a>



<h4>Method <code>started()</code></h4>

<p>Check whether all the given controllers are started.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$started(controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>Character vector of controller names.
Set to <code>NULL</code> to select all controllers.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Actually checks whether all the given clients are started.
</p>



<h5>Returns</h5>

<p><code>TRUE</code> if the controllers are started, <code>FALSE</code> if any are not.
</p>


<hr>
<a id="method-crew_class_controller_group-launch"></a>



<h4>Method <code>launch()</code></h4>

<p>Launch one or more workers on one or more controllers.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$launch(n = 1L, controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of workers to launch in each controller selected.</p>
</dd>
<dt><code>controllers</code></dt><dd><p>Character vector of controller names.
Set to <code>NULL</code> to select all controllers.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_controller_group-scale"></a>



<h4>Method <code>scale()</code></h4>

<p>Automatically scale up the number of workers if needed
in one or more controller objects.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$scale(throttle = TRUE, controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>throttle</code></dt><dd><p><code>TRUE</code> to skip auto-scaling if it already happened
within the last <code>seconds_interval</code> seconds. <code>FALSE</code> to auto-scale
every time <code>scale()</code> is called. Throttling avoids
overburdening the <code>mirai</code> dispatcher and other resources.</p>
</dd>
<dt><code>controllers</code></dt><dd><p>Character vector of controller names.
Set to <code>NULL</code> to select all controllers.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>See the <code>scale()</code> method in individual controller classes.
</p>



<h5>Returns</h5>

<p>Invisibly returns <code>TRUE</code> if there was any relevant
auto-scaling activity (new worker launches or worker
connection/disconnection events) (<code>FALSE</code> otherwise).
</p>


<hr>
<a id="method-crew_class_controller_group-autoscale"></a>



<h4>Method <code>autoscale()</code></h4>

<p>Run worker auto-scaling in a private <code>later</code> loop
every <code>controller$client$seconds_interval</code> seconds.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$autoscale(controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>Character vector of controller names.
Set to <code>NULL</code> to select all controllers.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_controller_group-descale"></a>



<h4>Method <code>descale()</code></h4>

<p>Terminate the auto-scaling loop started by
<code>controller$autoscale()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$descale(controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>Character vector of controller names.
Set to <code>NULL</code> to select all controllers.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_controller_group-crashes"></a>



<h4>Method <code>crashes()</code></h4>

<p>Report the number of consecutive crashes of a task,
summed over all selected controllers in the group.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$crashes(name, controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Character string, name of the task to check.</p>
</dd>
<dt><code>controllers</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>See the <code>crashes_max</code> argument of <code><a href="#topic+crew_controller">crew_controller()</a></code>.
</p>



<h5>Returns</h5>

<p>Number of consecutive crashes of the named task,
summed over all the controllers in the group.
</p>


<hr>
<a id="method-crew_class_controller_group-push"></a>



<h4>Method <code>push()</code></h4>

<p>Push a task to the head of the task list.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$push(
  command,
  data = list(),
  globals = list(),
  substitute = TRUE,
  seed = NULL,
  algorithm = NULL,
  packages = character(0),
  library = NULL,
  seconds_timeout = NULL,
  scale = TRUE,
  throttle = TRUE,
  name = NULL,
  save_command = NULL,
  controller = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>command</code></dt><dd><p>Language object with R code to run.</p>
</dd>
<dt><code>data</code></dt><dd><p>Named list of local data objects in the
evaluation environment.</p>
</dd>
<dt><code>globals</code></dt><dd><p>Named list of objects to temporarily assign to the
global environment for the task. See the <code>reset_globals</code>
argument of <code><a href="#topic+crew_controller_local">crew_controller_local()</a></code>.</p>
</dd>
<dt><code>substitute</code></dt><dd><p>Logical of length 1, whether to call
<code>base::substitute()</code> on the supplied value of the
<code>command</code> argument. If <code>TRUE</code> (default) then <code>command</code> is quoted
literally as you write it, e.g.
<code>push(command = your_function_call())</code>. If <code>FALSE</code>, then <code>crew</code>
assumes <code>command</code> is a language object and you are passing its
value, e.g. <code>push(command = quote(your_function_call()))</code>.
<code>substitute = TRUE</code> is appropriate for interactive use,
whereas <code>substitute = FALSE</code> is meant for automated R programs
that invoke <code>crew</code> controllers.</p>
</dd>
<dt><code>seed</code></dt><dd><p>Integer of length 1 with the pseudo-random number generator
seed to set for the evaluation of the task. Passed to the
<code>seed</code> argument of <code>set.seed()</code> if not <code>NULL</code>.
If <code>algorithm</code> and <code>seed</code> are both <code>NULL</code>,
then the random number generator defaults to the
widely spaced worker-specific
L'Ecuyer streams as supported by <code>mirai::nextstream()</code>.
See <code>vignette("parallel", package = "parallel")</code> for details.</p>
</dd>
<dt><code>algorithm</code></dt><dd><p>Integer of length 1 with the pseudo-random number
generator algorithm to set for the evaluation of the task.
Passed to the <code>kind</code> argument of <code>RNGkind()</code> if not <code>NULL</code>.
If <code>algorithm</code> and <code>seed</code> are both <code>NULL</code>,
then the random number generator defaults to the
recommended widely spaced worker-specific
L'Ecuyer streams as supported by <code>mirai::nextstream()</code>.
See <code>vignette("parallel", package = "parallel")</code> for details.</p>
</dd>
<dt><code>packages</code></dt><dd><p>Character vector of packages to load for the task.</p>
</dd>
<dt><code>library</code></dt><dd><p>Library path to load the packages. See the <code>lib.loc</code>
argument of <code>require()</code>.</p>
</dd>
<dt><code>seconds_timeout</code></dt><dd><p>Optional task timeout passed to the <code>.timeout</code>
argument of <code>mirai::mirai()</code> (after converting to milliseconds).</p>
</dd>
<dt><code>scale</code></dt><dd><p>Logical, whether to automatically scale workers to meet
demand. See the <code>scale</code> argument of the <code>push()</code> method of
ordinary single controllers.</p>
</dd>
<dt><code>throttle</code></dt><dd><p><code>TRUE</code> to skip auto-scaling if it already happened
within the last <code>seconds_interval</code> seconds. <code>FALSE</code> to auto-scale
every time <code>scale()</code> is called. Throttling avoids
overburdening the <code>mirai</code> dispatcher and other resources.</p>
</dd>
<dt><code>name</code></dt><dd><p>Character string, name of the task. If <code>NULL</code>,
a random name is automatically generated.
The task name must not conflict with an existing task
in the controller where it is submitted.
To reuse the name, wait for the existing task
to finish, then either <code>pop()</code> or <code>collect()</code> it
to remove it from its controller.</p>
</dd>
<dt><code>save_command</code></dt><dd><p>Deprecated on 2025-01-22
(<code>crew</code> version 0.10.2.9004).</p>
</dd>
<dt><code>controller</code></dt><dd><p>Character of length 1,
name of the controller to submit the task.
If <code>NULL</code>, the controller defaults to the
first controller in the list.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Invisibly return the <code>mirai</code> object of the pushed task.
This allows you to interact with the task directly, e.g.
to create a promise object with <code>promises::as.promise()</code>.
</p>


<hr>
<a id="method-crew_class_controller_group-walk"></a>



<h4>Method <code>walk()</code></h4>

<p>Apply a single command to multiple inputs,
and return control to the user without
waiting for any task to complete.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$walk(
  command,
  iterate,
  data = list(),
  globals = list(),
  substitute = TRUE,
  seed = NULL,
  algorithm = NULL,
  packages = character(0),
  library = NULL,
  seconds_timeout = NULL,
  names = NULL,
  save_command = NULL,
  scale = TRUE,
  throttle = TRUE,
  controller = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>command</code></dt><dd><p>Language object with R code to run.</p>
</dd>
<dt><code>iterate</code></dt><dd><p>Named list of vectors or lists to iterate over.
For example, to run function calls
<code>f(x = 1, y = "a")</code> and <code>f(x = 2, y = "b")</code>,
set <code>command</code> to <code>f(x, y)</code>, and set <code>iterate</code> to
<code>list(x = c(1, 2), y = c("a", "b"))</code>. The individual
function calls are evaluated as
<code>f(x = iterate$x[[1]], y = iterate$y[[1]])</code> and
<code>f(x = iterate$x[[2]], y = iterate$y[[2]])</code>.
All the elements of <code>iterate</code> must have the same length.
If there are any name conflicts between <code>iterate</code> and <code>data</code>,
<code>iterate</code> takes precedence.</p>
</dd>
<dt><code>data</code></dt><dd><p>Named list of constant local data objects in the
evaluation environment. Objects in this list are treated as single
values and are held constant for each iteration of the map.</p>
</dd>
<dt><code>globals</code></dt><dd><p>Named list of constant objects to temporarily
assign to the global environment for each task. This list should
include any functions you previously defined in the global
environment which are required to run tasks.
See the <code>reset_globals</code> argument of <code><a href="#topic+crew_controller_local">crew_controller_local()</a></code>.
Objects in this list are treated as single
values and are held constant for each iteration of the map.</p>
</dd>
<dt><code>substitute</code></dt><dd><p>Logical of length 1, whether to call
<code>base::substitute()</code> on the supplied value of the
<code>command</code> argument. If <code>TRUE</code> (default) then <code>command</code> is quoted
literally as you write it, e.g.
<code>push(command = your_function_call())</code>. If <code>FALSE</code>, then <code>crew</code>
assumes <code>command</code> is a language object and you are passing its
value, e.g. <code>push(command = quote(your_function_call()))</code>.
<code>substitute = TRUE</code> is appropriate for interactive use,
whereas <code>substitute = FALSE</code> is meant for automated R programs
that invoke <code>crew</code> controllers.</p>
</dd>
<dt><code>seed</code></dt><dd><p>Integer of length 1 with the pseudo-random number generator
seed to set for the evaluation of the task. Passed to the
<code>seed</code> argument of <code>set.seed()</code> if not <code>NULL</code>.
If <code>algorithm</code> and <code>seed</code> are both <code>NULL</code>,
then the random number generator defaults to the
recommended widely spaced worker-specific
L'Ecuyer streams as supported by <code>mirai::nextstream()</code>.
See <code>vignette("parallel", package = "parallel")</code> for details.</p>
</dd>
<dt><code>algorithm</code></dt><dd><p>Integer of length 1 with the pseudo-random number
generator algorithm to set for the evaluation of the task.
Passed to the <code>kind</code> argument of <code>RNGkind()</code> if not <code>NULL</code>.
If <code>algorithm</code> and <code>seed</code> are both <code>NULL</code>,
then the random number generator defaults to the
recommended widely spaced worker-specific
L'Ecuyer streams as supported by <code>mirai::nextstream()</code>.
See <code>vignette("parallel", package = "parallel")</code> for details.</p>
</dd>
<dt><code>packages</code></dt><dd><p>Character vector of packages to load for the task.</p>
</dd>
<dt><code>library</code></dt><dd><p>Library path to load the packages. See the <code>lib.loc</code>
argument of <code>require()</code>.</p>
</dd>
<dt><code>seconds_timeout</code></dt><dd><p>Optional task timeout passed to the <code>.timeout</code>
argument of <code>mirai::mirai()</code> (after converting to milliseconds).</p>
</dd>
<dt><code>names</code></dt><dd><p>Optional character of length 1, name of the element of
<code>iterate</code> with names for the tasks. If <code>names</code> is supplied,
then <code>iterate[[names]]</code> must be a character vector.</p>
</dd>
<dt><code>save_command</code></dt><dd><p>Deprecated on 2025-01-22
(<code>crew</code> version 0.10.2.9004).</p>
</dd>
<dt><code>scale</code></dt><dd><p>Logical, whether to automatically scale workers to meet
demand. See also the <code>throttle</code> argument.</p>
</dd>
<dt><code>throttle</code></dt><dd><p><code>TRUE</code> to skip auto-scaling if it already happened
within the last <code>seconds_interval</code> seconds. <code>FALSE</code> to auto-scale
every time <code>scale()</code> is called. Throttling avoids
overburdening the <code>mirai</code> dispatcher and other resources.</p>
</dd>
<dt><code>controller</code></dt><dd><p>Character of length 1,
name of the controller to submit the tasks.
If <code>NULL</code>, the controller defaults to the
first controller in the list.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>In contrast to <code>walk()</code>, <code>map()</code> blocks the local R session
and waits for all tasks to complete.
</p>



<h5>Returns</h5>

<p>Invisibly returns a list of <code>mirai</code> task objects for the
newly created tasks. The order of tasks in the list matches the
order of data in the <code>iterate</code> argument.
</p>


<hr>
<a id="method-crew_class_controller_group-map"></a>



<h4>Method <code>map()</code></h4>

<p>Apply a single command to multiple inputs.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$map(
  command,
  iterate,
  data = list(),
  globals = list(),
  substitute = TRUE,
  seed = NULL,
  algorithm = NULL,
  packages = character(0),
  library = NULL,
  seconds_interval = NULL,
  seconds_timeout = NULL,
  names = NULL,
  save_command = NULL,
  error = "stop",
  warnings = TRUE,
  verbose = interactive(),
  scale = TRUE,
  throttle = TRUE,
  controller = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>command</code></dt><dd><p>Language object with R code to run.</p>
</dd>
<dt><code>iterate</code></dt><dd><p>Named list of vectors or lists to iterate over.
For example, to run function calls
<code>f(x = 1, y = "a")</code> and <code>f(x = 2, y = "b")</code>,
set <code>command</code> to <code>f(x, y)</code>, and set <code>iterate</code> to
<code>list(x = c(1, 2), y = c("a", "b"))</code>. The individual
function calls are evaluated as
<code>f(x = iterate$x[[1]], y = iterate$y[[1]])</code> and
<code>f(x = iterate$x[[2]], y = iterate$y[[2]])</code>.
All the elements of <code>iterate</code> must have the same length.
If there are any name conflicts between <code>iterate</code> and <code>data</code>,
<code>iterate</code> takes precedence.</p>
</dd>
<dt><code>data</code></dt><dd><p>Named list of constant local data objects in the
evaluation environment. Objects in this list are treated as single
values and are held constant for each iteration of the map.</p>
</dd>
<dt><code>globals</code></dt><dd><p>Named list of constant objects to temporarily
assign to the global environment for each task. This list should
include any functions you previously defined in the global
environment which are required to run tasks.
See the <code>reset_globals</code> argument of <code><a href="#topic+crew_controller_local">crew_controller_local()</a></code>.
Objects in this list are treated as single
values and are held constant for each iteration of the map.</p>
</dd>
<dt><code>substitute</code></dt><dd><p>Logical of length 1, whether to call
<code>base::substitute()</code> on the supplied value of the
<code>command</code> argument. If <code>TRUE</code> (default) then <code>command</code> is quoted
literally as you write it, e.g.
<code>push(command = your_function_call())</code>. If <code>FALSE</code>, then <code>crew</code>
assumes <code>command</code> is a language object and you are passing its
value, e.g. <code>push(command = quote(your_function_call()))</code>.
<code>substitute = TRUE</code> is appropriate for interactive use,
whereas <code>substitute = FALSE</code> is meant for automated R programs
that invoke <code>crew</code> controllers.</p>
</dd>
<dt><code>seed</code></dt><dd><p>Integer of length 1 with the pseudo-random number generator
seed to set for the evaluation of the task. Passed to the
<code>seed</code> argument of <code>set.seed()</code> if not <code>NULL</code>.
If <code>algorithm</code> and <code>seed</code> are both <code>NULL</code>,
then the random number generator defaults to the
recommended widely spaced worker-specific
L'Ecuyer streams as supported by <code>mirai::nextstream()</code>.
See <code>vignette("parallel", package = "parallel")</code> for details.</p>
</dd>
<dt><code>algorithm</code></dt><dd><p>Integer of length 1 with the pseudo-random number
generator algorithm to set for the evaluation of the task.
Passed to the <code>kind</code> argument of <code>RNGkind()</code> if not <code>NULL</code>.
If <code>algorithm</code> and <code>seed</code> are both <code>NULL</code>,
then the random number generator defaults to the
recommended widely spaced worker-specific
L'Ecuyer streams as supported by <code>mirai::nextstream()</code>.
See <code>vignette("parallel", package = "parallel")</code> for details.</p>
</dd>
<dt><code>packages</code></dt><dd><p>Character vector of packages to load for the task.</p>
</dd>
<dt><code>library</code></dt><dd><p>Library path to load the packages. See the <code>lib.loc</code>
argument of <code>require()</code>.</p>
</dd>
<dt><code>seconds_interval</code></dt><dd><p>Deprecated on 2025-01-17 (<code>crew</code> version
0.10.2.9003). Instead, the <code>seconds_interval</code> argument passed
to <code><a href="#topic+crew_controller_group">crew_controller_group()</a></code> is used as <code>seconds_max</code>
in a <code><a href="#topic+crew_throttle">crew_throttle()</a></code> object which orchestrates exponential
backoff.</p>
</dd>
<dt><code>seconds_timeout</code></dt><dd><p>Optional task timeout passed to the <code>.timeout</code>
argument of <code>mirai::mirai()</code> (after converting to milliseconds).</p>
</dd>
<dt><code>names</code></dt><dd><p>Optional character of length 1, name of the element of
<code>iterate</code> with names for the tasks. If <code>names</code> is supplied,
then <code>iterate[[names]]</code> must be a character vector.</p>
</dd>
<dt><code>save_command</code></dt><dd><p>Deprecated on 2025-01-22
(<code>crew</code> version 0.10.2.9004).</p>
</dd>
<dt><code>error</code></dt><dd><p>Character vector of length 1, choice of action if
a task has an error. Possible values:
</p>

<ul>
<li> <p><code>"stop"</code>: throw an error in the main R session instead of returning
a value. In case of an error, the results from the last errored
<code>map()</code> are in the <code>error</code> field
of the controller, e.g. <code>controller_object$error</code>. To reduce
memory consumption, set <code>controller_object$error &lt;- NULL</code> after
you are finished troubleshooting.
</p>
</li>
<li> <p><code>"warn"</code>: throw a warning. This allows the return value with
all the error messages and tracebacks to be generated.
</p>
</li>
<li> <p><code>"silent"</code>: do nothing special.
</p>
</li></ul>
</dd>
<dt><code>warnings</code></dt><dd><p>Logical of length 1, whether to throw a warning in the
interactive session if at least one task encounters an error.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Logical of length 1, whether to print progress messages.</p>
</dd>
<dt><code>scale</code></dt><dd><p>Logical, whether to automatically scale workers to meet
demand. See also the <code>throttle</code> argument.</p>
</dd>
<dt><code>throttle</code></dt><dd><p><code>TRUE</code> to skip auto-scaling if it already happened
within the last <code>seconds_interval</code> seconds. <code>FALSE</code> to auto-scale
every time <code>scale()</code> is called. Throttling avoids
overburdening the <code>mirai</code> dispatcher and other resources.</p>
</dd>
<dt><code>controller</code></dt><dd><p>Character of length 1,
name of the controller to submit the tasks.
If <code>NULL</code>, the controller defaults to the
first controller in the list.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The idea comes from functional programming: for example,
the <code>map()</code> function from the <code>purrr</code> package.
</p>



<h5>Returns</h5>

<p>A <code>tibble</code> of results and metadata: one row per task and
columns corresponding to the output of <code>pop()</code>.
</p>


<hr>
<a id="method-crew_class_controller_group-pop"></a>



<h4>Method <code>pop()</code></h4>

<p>Pop a completed task from the results data frame.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$pop(
  scale = TRUE,
  collect = NULL,
  throttle = TRUE,
  error = NULL,
  controllers = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>scale</code></dt><dd><p>Logical, whether to automatically scale workers to meet
demand. See the <code>scale</code> argument of the <code>pop()</code> method of
ordinary single controllers.</p>
</dd>
<dt><code>collect</code></dt><dd><p>Deprecated in version 0.5.0.9003 (2023-10-02). Not used.</p>
</dd>
<dt><code>throttle</code></dt><dd><p><code>TRUE</code> to skip auto-scaling if it already happened
within the last <code>seconds_interval</code> seconds. <code>FALSE</code> to auto-scale
every time <code>scale()</code> is called. Throttling avoids
overburdening the <code>mirai</code> dispatcher and other resources.</p>
</dd>
<dt><code>error</code></dt><dd><p><code>NULL</code> or character of length 1, choice of action if
the popped task threw an error. Possible values:
</p>

<ul>
<li> <p><code>"stop"</code>: throw an error in the main R session instead of returning
a value.
</p>
</li>
<li> <p><code>"warn"</code>: throw a warning.
</p>
</li>
<li> <p><code>NULL</code> or <code>"silent"</code>: do not react to errors.
</p>
</li></ul>
</dd>
<dt><code>controllers</code></dt><dd><p>Character vector of controller names.
Set to <code>NULL</code> to select all controllers.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>If there is no task to collect, return <code>NULL</code>. Otherwise,
return a one-row <code>tibble</code> with the same columns as <code>pop()</code>
for ordinary controllers.
</p>


<hr>
<a id="method-crew_class_controller_group-collect"></a>



<h4>Method <code>collect()</code></h4>

<p>Pop all available task results and return them in a tidy
<code>tibble</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$collect(
  scale = TRUE,
  throttle = TRUE,
  error = NULL,
  controllers = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>scale</code></dt><dd><p>Logical of length 1,
whether to automatically call <code>scale()</code>
to auto-scale workers to meet the demand of the task load.</p>
</dd>
<dt><code>throttle</code></dt><dd><p><code>TRUE</code> to skip auto-scaling if it already happened
within the last <code>seconds_interval</code> seconds. <code>FALSE</code> to auto-scale
every time <code>scale()</code> is called. Throttling avoids
overburdening the <code>mirai</code> dispatcher and other resources.</p>
</dd>
<dt><code>error</code></dt><dd><p><code>NULL</code> or character of length 1, choice of action if
the popped task threw an error. Possible values:
</p>

<ul>
<li> <p><code>"stop"</code>: throw an error in the main R session instead of returning
a value.
</p>
</li>
<li> <p><code>"warn"</code>: throw a warning.
</p>
</li>
<li> <p><code>NULL</code> or <code>"silent"</code>: do not react to errors.
</p>
</li></ul>
</dd>
<dt><code>controllers</code></dt><dd><p>Character vector of controller names.
Set to <code>NULL</code> to select all controllers.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>tibble</code> of results and metadata of all resolved tasks,
with one row per task. Returns <code>NULL</code> if there are no available
results.
</p>


<hr>
<a id="method-crew_class_controller_group-promise"></a>



<h4>Method <code>promise()</code></h4>

<p>Create a <code>promises::promise()</code> object to asynchronously
pop or collect one or more tasks.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$promise(
  mode = "one",
  seconds_interval = 0.1,
  scale = NULL,
  throttle = NULL,
  controllers = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mode</code></dt><dd><p>Character of length 1, what kind of promise to create.
<code>mode</code> must be <code>"one"</code> or <code>"all"</code>. Details:
</p>

<ul>
<li><p> If <code>mode</code> is <code>"one"</code>, then the promise is fulfilled (or rejected)
when at least one task is resolved and available to <code>pop()</code>.
When that happens, <code>pop()</code> runs asynchronously, pops a result off
the task list, and returns a value.
If the task succeeded, then the promise
is fulfilled and its value is the result of <code>pop()</code> (a one-row
<code>tibble</code> with the result and metadata). If the task threw an error,
the error message of the task is forwarded to any error callbacks
registered with the promise.
</p>
</li>
<li><p> If <code>mode</code> is <code>"all"</code>, then the promise is fulfilled (or rejected)
when there are no unresolved tasks left in the controller.
(Be careful: this condition is trivially met in the moment
if the controller is empty and you have not submitted any tasks,
so it is best to create this kind of promise only after you
submit tasks.)
When there are no unresolved tasks left,
<code>collect()</code> runs asynchronously, pops all available results
off the task list, and returns a value.
If the task succeeded, then the promise
is fulfilled and its value is the result of <code>collect()</code>
(a <code>tibble</code> with one row per task result). If any of the tasks
threw an error, then the first error message detected is forwarded
to any error callbacks registered with the promise.
</p>
</li></ul>
</dd>
<dt><code>seconds_interval</code></dt><dd><p>Positive numeric of length 1, delay in the
<code>later::later()</code> polling interval to asynchronously check if
the promise can be resolved.</p>
</dd>
<dt><code>scale</code></dt><dd><p>Deprecated on 2024-04-10 (version 0.9.1.9003)
and no longer used. Now, <code>promise()</code> always turns on auto-scaling
in a private <code>later</code> loop (if not already activated).</p>
</dd>
<dt><code>throttle</code></dt><dd><p>Deprecated on 2024-04-10 (version 0.9.1.9003)
and no longer used. Now, <code>promise()</code> always turns on auto-scaling
in a private <code>later</code> loop (if not already activated).</p>
</dd>
<dt><code>controllers</code></dt><dd><p>Not used. Included to ensure the signature is
compatible with the analogous method of controller groups.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Please be aware that <code>pop()</code> or <code>collect()</code> will happen
asynchronously at a some unpredictable time after the promise object
is created, even if your local R process appears to be doing
something completely different. This behavior is highly desirable
in a Shiny reactive context, but please be careful as it may be
surprising in other situations.
</p>



<h5>Returns</h5>

<p>A <code>promises::promise()</code> object whose eventual value will
be a <code>tibble</code> with results from one or more popped tasks.
If <code>mode = "one"</code>, only one task is popped and returned (one row).
If <code>mode = "all"</code>, then all the tasks are returned in a <code>tibble</code>
with one row per task (or <code>NULL</code> is returned if there are no
tasks to pop).
</p>


<hr>
<a id="method-crew_class_controller_group-wait"></a>



<h4>Method <code>wait()</code></h4>

<p>Wait for tasks.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$wait(
  mode = "all",
  seconds_interval = NULL,
  seconds_timeout = Inf,
  scale = TRUE,
  throttle = TRUE,
  controllers = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mode</code></dt><dd><p>Character of length 1: <code>"all"</code> to wait for
all tasks in all controllers to complete, <code>"one"</code> to wait for
a single task in a single controller to complete. In this scheme,
the timeout limit is applied to each controller sequentially,
and a timeout is treated the same as a completed controller.</p>
</dd>
<dt><code>seconds_interval</code></dt><dd><p>Deprecated on 2025-01-17 (<code>crew</code> version
0.10.2.9003). Instead, the <code>seconds_interval</code> argument passed
to <code><a href="#topic+crew_controller_group">crew_controller_group()</a></code> is used as <code>seconds_max</code>
in a <code><a href="#topic+crew_throttle">crew_throttle()</a></code> object which orchestrates exponential
backoff.</p>
</dd>
<dt><code>seconds_timeout</code></dt><dd><p>Timeout length in seconds waiting for
results to become available.</p>
</dd>
<dt><code>scale</code></dt><dd><p>Logical of length 1, whether to call <code>scale_later()</code>
on each selected controller to schedule auto-scaling.
See the <code>scale</code> argument of the <code>wait()</code> method of
ordinary single controllers.</p>
</dd>
<dt><code>throttle</code></dt><dd><p><code>TRUE</code> to skip auto-scaling if it already happened
within the last <code>seconds_interval</code> seconds. <code>FALSE</code> to auto-scale
every time <code>scale()</code> is called. Throttling avoids
overburdening the <code>mirai</code> dispatcher and other resources.</p>
</dd>
<dt><code>controllers</code></dt><dd><p>Character vector of controller names.
Set to <code>NULL</code> to select all controllers.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The <code>wait()</code> method blocks the calling R session and
repeatedly auto-scales workers for tasks that need them.
The function runs until it either times out or the condition
in <code>mode</code> is met.
</p>



<h5>Returns</h5>

<p>A logical of length 1, invisibly. <code>TRUE</code> if the condition
in <code>mode</code> was met, <code>FALSE</code> otherwise.
</p>


<hr>
<a id="method-crew_class_controller_group-push_backlog"></a>



<h4>Method <code>push_backlog()</code></h4>

<p>Push the name of a task to the backlog.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$push_backlog(name, controller = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Character of length 1 with the task name to push to
the backlog.</p>
</dd>
<dt><code>controller</code></dt><dd><p>Character vector of length 1 with the controller name.
Set to <code>NULL</code> to select the default controller that <code>push_backlog()</code>
would choose.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code>pop_backlog()</code> pops the tasks that can be pushed
without saturating the controller.
</p>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_controller_group-pop_backlog"></a>



<h4>Method <code>pop_backlog()</code></h4>

<p>Pop the task names from the head of the backlog which
can be pushed without saturating the controller.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$pop_backlog(controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>Character vector of controller names.
Set to <code>NULL</code> to select all controllers.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Character vector of task names which can be pushed to the
controller without saturating it. If the controller is saturated,
<code>character(0L)</code> is returned.
</p>


<hr>
<a id="method-crew_class_controller_group-summary"></a>



<h4>Method <code>summary()</code></h4>

<p>Summarize the workers of one or more controllers.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$summary(controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>Character vector of controller names.
Set to <code>NULL</code> to select all controllers.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A data frame of aggregated worker summary statistics
of all the selected controllers. It has one row per worker,
and the rows are grouped by controller.
See the documentation of the <code>summary()</code> method of the controller
class for specific information about the columns in the output.
</p>


<hr>
<a id="method-crew_class_controller_group-pids"></a>



<h4>Method <code>pids()</code></h4>

<p>Get the process IDs of the local process and the
<code>mirai</code> dispatchers (if started).
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$pids(controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>Character vector of controller names.
Set to <code>NULL</code> to select all controllers.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An integer vector of process IDs of the local process and the
<code>mirai</code> dispatcher (if started).
</p>


<hr>
<a id="method-crew_class_controller_group-terminate"></a>



<h4>Method <code>terminate()</code></h4>

<p>Terminate the workers and disconnect the client
for one or more controllers.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_controller_group$terminate(controllers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>controllers</code></dt><dd><p>Character vector of controller names.
Set to <code>NULL</code> to select all controllers.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>




<h3>See Also</h3>

<p>Other controller_group: 
<code><a href="#topic+crew_controller_group">crew_controller_group</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("CREW_EXAMPLES"), "true")) {
persistent &lt;- crew_controller_local(name = "persistent")
transient &lt;- crew_controller_local(
  name = "transient",
  tasks_max = 1L
)
group &lt;- crew_controller_group(persistent, transient)
group$start()
group$push(name = "task", command = sqrt(4), controller = "transient")
group$wait()
group$pop()
group$terminate()
}

## ------------------------------------------------
## Method `crew_class_controller_group$new`
## ------------------------------------------------

if (identical(Sys.getenv("CREW_EXAMPLES"), "true")) {
persistent &lt;- crew_controller_local(name = "persistent")
transient &lt;- crew_controller_local(
  name = "transient",
  tasks_max = 1L
)
group &lt;- crew_controller_group(persistent, transient)
group$start()
group$push(name = "task", command = sqrt(4), controller = "transient")
group$wait()
group$pop()
group$terminate()
}
</code></pre>

<hr>
<h2 id='crew_class_launcher'>Launcher abstract class</h2><span id='topic+crew_class_launcher'></span>

<h3>Description</h3>

<p><code>R6</code> abstract class to build other subclasses
which launch and manage workers.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>name</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>workers</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>seconds_interval</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>seconds_timeout</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>seconds_launch</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>seconds_idle</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>seconds_wall</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>tasks_max</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>tasks_timers</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>reset_globals</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>reset_packages</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>reset_options</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>garbage_collection</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>tls</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>processes</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.
asynchronously.</p>
</dd>
<dt><code>r_arguments</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>options_metrics</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>url</code></dt><dd><p>Websocket URL for worker connections.</p>
</dd>
<dt><code>profile</code></dt><dd><p><code>mirai</code> compute profile of the launcher.</p>
</dd>
<dt><code>instances</code></dt><dd><p>Data frame of worker instance information.</p>
</dd>
<dt><code>id</code></dt><dd><p>Integer worker ID from the last call to <code>settings()</code>.</p>
</dd>
<dt><code>async</code></dt><dd><p>A <code><a href="#topic+crew_async">crew_async()</a></code> object to run low-level launcher tasks
asynchronously.</p>
</dd>
<dt><code>throttle</code></dt><dd><p>A <code><a href="#topic+crew_throttle">crew_throttle()</a></code> object to throttle scaling.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-crew_class_launcher-new"><code>crew_class_launcher$new()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_launcher-validate"><code>crew_class_launcher$validate()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_launcher-poll"><code>crew_class_launcher$poll()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_launcher-settings"><code>crew_class_launcher$settings()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_launcher-call"><code>crew_class_launcher$call()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_launcher-start"><code>crew_class_launcher$start()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_launcher-terminate"><code>crew_class_launcher$terminate()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_launcher-resolve"><code>crew_class_launcher$resolve()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_launcher-update"><code>crew_class_launcher$update()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_launcher-launch"><code>crew_class_launcher$launch()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_launcher-scale"><code>crew_class_launcher$scale()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_launcher-launch_worker"><code>crew_class_launcher$launch_worker()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_launcher-terminate_worker"><code>crew_class_launcher$terminate_worker()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_launcher-terminate_workers"><code>crew_class_launcher$terminate_workers()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_launcher-crashes"><code>crew_class_launcher$crashes()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_launcher-set_name"><code>crew_class_launcher$set_name()</code></a>
</p>
</li></ul>


<hr>
<a id="method-crew_class_launcher-new"></a>



<h4>Method <code>new()</code></h4>

<p>Launcher constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_launcher$new(
  name = NULL,
  workers = NULL,
  seconds_interval = NULL,
  seconds_timeout = NULL,
  seconds_launch = NULL,
  seconds_idle = NULL,
  seconds_wall = NULL,
  seconds_exit = NULL,
  tasks_max = NULL,
  tasks_timers = NULL,
  reset_globals = NULL,
  reset_packages = NULL,
  reset_options = NULL,
  garbage_collection = NULL,
  crashes_error = NULL,
  launch_max = NULL,
  tls = NULL,
  processes = NULL,
  r_arguments = NULL,
  options_metrics = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>workers</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>seconds_interval</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>seconds_timeout</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>seconds_launch</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>seconds_idle</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>seconds_wall</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>seconds_exit</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>tasks_max</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>tasks_timers</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>reset_globals</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>reset_packages</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>reset_options</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>garbage_collection</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>crashes_error</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>launch_max</code></dt><dd><p>Deprecated.</p>
</dd>
<dt><code>tls</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>processes</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>r_arguments</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>options_metrics</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An <code>R6</code> object with the launcher.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (identical(Sys.getenv("CREW_EXAMPLES"), "true")) {
client &lt;- crew_client()
client$start()
launcher &lt;- crew_launcher_local()
launcher$start(url = client$url, profile = client$profile)
launcher$launch()
task &lt;- mirai::mirai("result", .compute = client$profile)
mirai::call_mirai_(task)
task$data
client$terminate()
}
</pre>
</div>


<hr>
<a id="method-crew_class_launcher-validate"></a>



<h4>Method <code>validate()</code></h4>

<p>Validate the launcher.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_launcher$validate()</pre></div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_launcher-poll"></a>



<h4>Method <code>poll()</code></h4>

<p>Poll the throttle.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_launcher$poll()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> to run whatever work comes next, <code>FALSE</code> to skip
until the appropriate time.
</p>


<hr>
<a id="method-crew_class_launcher-settings"></a>



<h4>Method <code>settings()</code></h4>

<p>List of arguments for <code>mirai::daemon()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_launcher$settings()</pre></div>



<h5>Returns</h5>

<p>List of arguments for <code>mirai::daemon()</code>.
</p>


<hr>
<a id="method-crew_class_launcher-call"></a>



<h4>Method <code>call()</code></h4>

<p>Create a call to <code><a href="#topic+crew_worker">crew_worker()</a></code> to
help create custom launchers.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_launcher$call(
  worker,
  socket = NULL,
  launcher = NULL,
  instance = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>worker</code></dt><dd><p>Character string, name of the worker.</p>
</dd>
<dt><code>socket</code></dt><dd><p>Deprecated on 2025-01-28 (<code>crew</code> version 1.0.0).</p>
</dd>
<dt><code>launcher</code></dt><dd><p>Deprecated on 2025-01-28 (<code>crew</code> version 1.0.0).</p>
</dd>
<dt><code>instance</code></dt><dd><p>Deprecated on 2025-01-28 (<code>crew</code> version 1.0.0).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Character string with a call to <code><a href="#topic+crew_worker">crew_worker()</a></code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>launcher &lt;- crew_launcher_local()
launcher$start(url = "tcp://127.0.0.1:57000", profile = "profile")
launcher$call(worker = "worker_name")
launcher$terminate()
</pre>
</div>


<hr>
<a id="method-crew_class_launcher-start"></a>



<h4>Method <code>start()</code></h4>

<p>Start the launcher.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_launcher$start(url = NULL, profile = NULL, sockets = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>url</code></dt><dd><p>Character string, websocket URL for worker connections.</p>
</dd>
<dt><code>profile</code></dt><dd><p>Character string, <code>mirai</code> compute profile.</p>
</dd>
<dt><code>sockets</code></dt><dd><p>Deprecated on 2025-01-28 (<code>crew</code> version 1.0.0).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_launcher-terminate"></a>



<h4>Method <code>terminate()</code></h4>

<p>Terminate the whole launcher, including all workers.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_launcher$terminate()</pre></div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_launcher-resolve"></a>



<h4>Method <code>resolve()</code></h4>

<p>Resolve asynchronous worker submissions.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_launcher$resolve()</pre></div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly). Throw an error if there were any
asynchronous worker submission errors.'
</p>


<hr>
<a id="method-crew_class_launcher-update"></a>



<h4>Method <code>update()</code></h4>

<p>Update worker metadata, resolve asynchronous
worker submissions, and terminate lost workers.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_launcher$update(status)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>status</code></dt><dd><p>A <code>mirai</code> status list.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_launcher-launch"></a>



<h4>Method <code>launch()</code></h4>

<p>Launch a worker.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_launcher$launch()</pre></div>



<h5>Returns</h5>

<p>Handle of the launched worker.
</p>


<hr>
<a id="method-crew_class_launcher-scale"></a>



<h4>Method <code>scale()</code></h4>

<p>Auto-scale workers out to meet the demand of tasks.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_launcher$scale(status, throttle = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>status</code></dt><dd><p>A <code>mirai</code> status list with worker and task information.</p>
</dd>
<dt><code>throttle</code></dt><dd><p>Deprecated, only used in the controller
as of 2025-01-16 (<code>crew</code> version 0.10.2.9003).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Invisibly returns <code>TRUE</code> if there was any relevant
auto-scaling activity (new worker launches or worker
connection/disconnection events) (<code>FALSE</code> otherwise).
</p>


<hr>
<a id="method-crew_class_launcher-launch_worker"></a>



<h4>Method <code>launch_worker()</code></h4>

<p>Abstract worker launch method.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_launcher$launch_worker(call, name, launcher, worker)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>call</code></dt><dd><p>Character of length 1 with a namespaced call to
<code><a href="#topic+crew_worker">crew_worker()</a></code> which will run in the worker and accept tasks.</p>
</dd>
<dt><code>name</code></dt><dd><p>Character of length 1 with an informative worker name.</p>
</dd>
<dt><code>launcher</code></dt><dd><p>Character of length 1, name of the launcher.</p>
</dd>
<dt><code>worker</code></dt><dd><p>Positive integer of length 1, index of the worker.
This worker index remains the same even when the current instance
of the worker exits and a new instance launches.
It is always between 1 and the maximum number of concurrent workers.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Launcher plugins will overwrite this method.
</p>



<h5>Returns</h5>

<p>A handle to mock the worker launch.
</p>


<hr>
<a id="method-crew_class_launcher-terminate_worker"></a>



<h4>Method <code>terminate_worker()</code></h4>

<p>Abstract worker termination method.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_launcher$terminate_worker(handle)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>handle</code></dt><dd><p>A handle object previously
returned by <code>launch_worker()</code> which allows the termination
of the worker.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Launcher plugins will overwrite this method.
</p>



<h5>Returns</h5>

<p>A handle to mock worker termination.
</p>


<hr>
<a id="method-crew_class_launcher-terminate_workers"></a>



<h4>Method <code>terminate_workers()</code></h4>

<p>Terminate all workers.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_launcher$terminate_workers()</pre></div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_launcher-crashes"></a>



<h4>Method <code>crashes()</code></h4>

<p>Deprecated on 2025-01-28 (<code>crew</code> version 1.0.0).
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_launcher$crashes(index = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt><dd><p>Unused argument.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The integer 1, for compatibility.
</p>


<hr>
<a id="method-crew_class_launcher-set_name"></a>



<h4>Method <code>set_name()</code></h4>

<p>Deprecated on 2025-01-28 (<code>crew</code> version 1.0.0).
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_launcher$set_name(name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Name to set for the launcher.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>




<h3>See Also</h3>

<p>Other launcher: 
<code><a href="#topic+crew_launcher">crew_launcher</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("CREW_EXAMPLES"), "true")) {
client &lt;- crew_client()
client$start()
launcher &lt;- crew_launcher_local()
launcher$start(url = client$url, profile = client$profile)
launcher$launch()
task &lt;- mirai::mirai("result", .compute = client$profile)
mirai::call_mirai_(task)
task$data
client$terminate()
}

## ------------------------------------------------
## Method `crew_class_launcher$new`
## ------------------------------------------------

if (identical(Sys.getenv("CREW_EXAMPLES"), "true")) {
client &lt;- crew_client()
client$start()
launcher &lt;- crew_launcher_local()
launcher$start(url = client$url, profile = client$profile)
launcher$launch()
task &lt;- mirai::mirai("result", .compute = client$profile)
mirai::call_mirai_(task)
task$data
client$terminate()
}

## ------------------------------------------------
## Method `crew_class_launcher$call`
## ------------------------------------------------

launcher &lt;- crew_launcher_local()
launcher$start(url = "tcp://127.0.0.1:57000", profile = "profile")
launcher$call(worker = "worker_name")
launcher$terminate()
</code></pre>

<hr>
<h2 id='crew_class_launcher_local'>Local process launcher class</h2><span id='topic+crew_class_launcher_local'></span>

<h3>Description</h3>

<p><code>R6</code> class to launch and manage local process workers.
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+crew_launcher_local">crew_launcher_local()</a></code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+crew_class_launcher">crew::crew_class_launcher</a></code> -&gt; <code>crew_class_launcher_local</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>options_local</code></dt><dd><p>See <code><a href="#topic+crew_launcher_local">crew_launcher_local()</a></code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-crew_class_launcher_local-new"><code>crew_class_launcher_local$new()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_launcher_local-validate"><code>crew_class_launcher_local$validate()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_launcher_local-launch_worker"><code>crew_class_launcher_local$launch_worker()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_launcher_local-terminate_worker"><code>crew_class_launcher_local$terminate_worker()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="crew" data-topic="crew_class_launcher" data-id="call"><a href='../../crew/html/crew_class_launcher.html#method-crew_class_launcher-call'><code>crew::crew_class_launcher$call()</code></a></span></li>
<li><span class="pkg-link" data-pkg="crew" data-topic="crew_class_launcher" data-id="crashes"><a href='../../crew/html/crew_class_launcher.html#method-crew_class_launcher-crashes'><code>crew::crew_class_launcher$crashes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="crew" data-topic="crew_class_launcher" data-id="launch"><a href='../../crew/html/crew_class_launcher.html#method-crew_class_launcher-launch'><code>crew::crew_class_launcher$launch()</code></a></span></li>
<li><span class="pkg-link" data-pkg="crew" data-topic="crew_class_launcher" data-id="poll"><a href='../../crew/html/crew_class_launcher.html#method-crew_class_launcher-poll'><code>crew::crew_class_launcher$poll()</code></a></span></li>
<li><span class="pkg-link" data-pkg="crew" data-topic="crew_class_launcher" data-id="resolve"><a href='../../crew/html/crew_class_launcher.html#method-crew_class_launcher-resolve'><code>crew::crew_class_launcher$resolve()</code></a></span></li>
<li><span class="pkg-link" data-pkg="crew" data-topic="crew_class_launcher" data-id="scale"><a href='../../crew/html/crew_class_launcher.html#method-crew_class_launcher-scale'><code>crew::crew_class_launcher$scale()</code></a></span></li>
<li><span class="pkg-link" data-pkg="crew" data-topic="crew_class_launcher" data-id="set_name"><a href='../../crew/html/crew_class_launcher.html#method-crew_class_launcher-set_name'><code>crew::crew_class_launcher$set_name()</code></a></span></li>
<li><span class="pkg-link" data-pkg="crew" data-topic="crew_class_launcher" data-id="settings"><a href='../../crew/html/crew_class_launcher.html#method-crew_class_launcher-settings'><code>crew::crew_class_launcher$settings()</code></a></span></li>
<li><span class="pkg-link" data-pkg="crew" data-topic="crew_class_launcher" data-id="start"><a href='../../crew/html/crew_class_launcher.html#method-crew_class_launcher-start'><code>crew::crew_class_launcher$start()</code></a></span></li>
<li><span class="pkg-link" data-pkg="crew" data-topic="crew_class_launcher" data-id="terminate"><a href='../../crew/html/crew_class_launcher.html#method-crew_class_launcher-terminate'><code>crew::crew_class_launcher$terminate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="crew" data-topic="crew_class_launcher" data-id="terminate_workers"><a href='../../crew/html/crew_class_launcher.html#method-crew_class_launcher-terminate_workers'><code>crew::crew_class_launcher$terminate_workers()</code></a></span></li>
<li><span class="pkg-link" data-pkg="crew" data-topic="crew_class_launcher" data-id="update"><a href='../../crew/html/crew_class_launcher.html#method-crew_class_launcher-update'><code>crew::crew_class_launcher$update()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-crew_class_launcher_local-new"></a>



<h4>Method <code>new()</code></h4>

<p>Local launcher constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_launcher_local$new(
  name = NULL,
  workers = NULL,
  seconds_interval = NULL,
  seconds_timeout = NULL,
  seconds_launch = NULL,
  seconds_idle = NULL,
  seconds_wall = NULL,
  seconds_exit = NULL,
  tasks_max = NULL,
  tasks_timers = NULL,
  reset_globals = NULL,
  reset_packages = NULL,
  reset_options = NULL,
  garbage_collection = NULL,
  crashes_error = NULL,
  tls = NULL,
  processes = NULL,
  r_arguments = NULL,
  options_metrics = NULL,
  options_local = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>workers</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>seconds_interval</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>seconds_timeout</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>seconds_launch</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>seconds_idle</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>seconds_wall</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>seconds_exit</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>tasks_max</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>tasks_timers</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>reset_globals</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>reset_packages</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>reset_options</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>garbage_collection</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>crashes_error</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>tls</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>processes</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>r_arguments</code></dt><dd><p>See <code><a href="#topic+crew_launcher">crew_launcher()</a></code>.</p>
</dd>
<dt><code>options_metrics</code></dt><dd><p>See <code><a href="#topic+crew_launcher_local">crew_launcher_local()</a></code>.</p>
</dd>
<dt><code>options_local</code></dt><dd><p>See <code><a href="#topic+crew_launcher_local">crew_launcher_local()</a></code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An <code>R6</code> object with the local launcher.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (identical(Sys.getenv("CREW_EXAMPLES"), "true")) {
client &lt;- crew_client()
client$start()
launcher &lt;- crew_launcher_local(name = client$name)
launcher$start(url = client$url, profile = client$profile)
launcher$launch()
task &lt;- mirai::mirai("result", .compute = client$profile)
mirai::call_mirai_(task)
task$data
client$terminate()
}
</pre>
</div>


<hr>
<a id="method-crew_class_launcher_local-validate"></a>



<h4>Method <code>validate()</code></h4>

<p>Validate the local launcher.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_launcher_local$validate()</pre></div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_launcher_local-launch_worker"></a>



<h4>Method <code>launch_worker()</code></h4>

<p>Launch a local process worker which will
dial into a socket.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_launcher_local$launch_worker(call, name, launcher, worker)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>call</code></dt><dd><p>Character of length 1 with a namespaced call to
<code><a href="#topic+crew_worker">crew_worker()</a></code> which will run in the worker and accept tasks.</p>
</dd>
<dt><code>name</code></dt><dd><p>Character of length 1 with a long informative worker name
which contains the <code>launcher</code> and <code>worker</code> arguments
described below.</p>
</dd>
<dt><code>launcher</code></dt><dd><p>Character of length 1, name of the launcher.</p>
</dd>
<dt><code>worker</code></dt><dd><p>Character string, name of the worker within the launcher.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The <code>call</code> argument is R code that will run to
initiate the worker. Together, the <code>launcher</code>, <code>worker</code>,
and <code>instance</code> arguments are useful for
constructing informative job names.
</p>



<h5>Returns</h5>

<p>A handle object to allow the termination of the worker
later on.
</p>


<hr>
<a id="method-crew_class_launcher_local-terminate_worker"></a>



<h4>Method <code>terminate_worker()</code></h4>

<p>Terminate a local process worker.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_launcher_local$terminate_worker(handle)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>handle</code></dt><dd><p>A process handle object previously
returned by <code>launch_worker()</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list with the process ID of the worker.
</p>




<h3>See Also</h3>

<p>Other plugin_local: 
<code><a href="#topic+crew_controller_local">crew_controller_local</a>()</code>,
<code><a href="#topic+crew_launcher_local">crew_launcher_local</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("CREW_EXAMPLES"), "true")) {
client &lt;- crew_client()
client$start()
launcher &lt;- crew_launcher_local(name = client$name)
launcher$start(url = client$url, profile = client$profile)
launcher$launch()
task &lt;- mirai::mirai("result", .compute = client$profile)
mirai::call_mirai_(task)
task$data
client$terminate()
}

## ------------------------------------------------
## Method `crew_class_launcher_local$new`
## ------------------------------------------------

if (identical(Sys.getenv("CREW_EXAMPLES"), "true")) {
client &lt;- crew_client()
client$start()
launcher &lt;- crew_launcher_local(name = client$name)
launcher$start(url = client$url, profile = client$profile)
launcher$launch()
task &lt;- mirai::mirai("result", .compute = client$profile)
mirai::call_mirai_(task)
task$data
client$terminate()
}
</code></pre>

<hr>
<h2 id='crew_class_monitor_local'>Local monitor class</h2><span id='topic+crew_class_monitor_local'></span>

<h3>Description</h3>

<p>Local monitor <code>R6</code> class
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+crew_monitor_local">crew_monitor_local()</a></code>.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-crew_class_monitor_local-dispatchers"><code>crew_class_monitor_local$dispatchers()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_monitor_local-daemons"><code>crew_class_monitor_local$daemons()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_monitor_local-workers"><code>crew_class_monitor_local$workers()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_monitor_local-terminate"><code>crew_class_monitor_local$terminate()</code></a>
</p>
</li></ul>


<hr>
<a id="method-crew_class_monitor_local-dispatchers"></a>



<h4>Method <code>dispatchers()</code></h4>

<p>List the process IDs of the running <code>mirai</code> dispatcher
processes.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_monitor_local$dispatchers(user = ps::ps_username())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>user</code></dt><dd><p>Character of length 1, user ID to filter on. <code>NULL</code>
to list processes of all users (not recommended).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Integer vector of process IDs of the running <code>mirai</code> dispatcher
processes.
</p>


<hr>
<a id="method-crew_class_monitor_local-daemons"></a>



<h4>Method <code>daemons()</code></h4>

<p>List the process IDs of the locally running <code>mirai</code> daemon
processes which are not <code>crew</code> workers. The <code><a href="#topic+crew_async">crew_async()</a></code>
object can launch such processes: for example, when a positive
integer is supplied to the <code>processes</code> argument of e.g.
<code>crew.aws.batch::crew_controller_aws_batch()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_monitor_local$daemons(user = ps::ps_username())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>user</code></dt><dd><p>Character of length 1, user ID to filter on. <code>NULL</code>
to list processes of all users (not recommended).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Integer vector of process IDs of the locally running
<code>mirai</code> daemon processes which are not <code>crew</code> workers.
</p>


<hr>
<a id="method-crew_class_monitor_local-workers"></a>



<h4>Method <code>workers()</code></h4>

<p>List the process IDs of locally running <code>crew</code> workers
launched by the local controller (<code><a href="#topic+crew_controller_local">crew_controller_local()</a></code>).
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_monitor_local$workers(user = ps::ps_username())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>user</code></dt><dd><p>Character of length 1, user ID to filter on. <code>NULL</code>
to list processes of all users (not recommended).</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Only the workers running on your local computer are listed.
Workers that are not listed include jobs on job schedulers like
SLURM or jobs on cloud services like AWS Batch. To monitor
those worker processes, please consult the monitor objects in
the relevant third-party launcher plugins such as <code>crew.cluster</code>
and <code>crew.aws.batch</code>.
</p>



<h5>Returns</h5>

<p>Integer vector of process IDs of locally running <code>crew</code> workers
launched by the local controller (<code><a href="#topic+crew_controller_local">crew_controller_local()</a></code>).
</p>


<hr>
<a id="method-crew_class_monitor_local-terminate"></a>



<h4>Method <code>terminate()</code></h4>

<p>Terminate the given process IDs.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_monitor_local$terminate(pids)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pids</code></dt><dd><p>Integer vector of process IDs of local processes to
terminate.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Termination happens with the operating system signal
given by <code><a href="#topic+crew_terminate_signal">crew_terminate_signal()</a></code>.
</p>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>




<h3>See Also</h3>

<p>Other monitor: 
<code><a href="#topic+crew_monitor_local">crew_monitor_local</a>()</code>
</p>

<hr>
<h2 id='crew_class_queue'><code>R6</code> queue class</h2><span id='topic+crew_class_queue'></span>

<h3>Description</h3>

<p><code>R6</code> class for a queue of resolved task names.
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+crew_queue">crew_queue()</a></code>.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>names</code></dt><dd><p>Names of resolved tasks.</p>
</dd>
<dt><code>head</code></dt><dd><p>Non-negative integer pointing to the location of the
next name to pop.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-crew_class_queue-validate"><code>crew_class_queue$validate()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_queue-reset"><code>crew_class_queue$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_queue-set"><code>crew_class_queue$set()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_queue-pop"><code>crew_class_queue$pop()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_queue-collect"><code>crew_class_queue$collect()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_queue-empty"><code>crew_class_queue$empty()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_queue-nonempty"><code>crew_class_queue$nonempty()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_queue-popped"><code>crew_class_queue$popped()</code></a>
</p>
</li></ul>


<hr>
<a id="method-crew_class_queue-validate"></a>



<h4>Method <code>validate()</code></h4>

<p>Validate the queue.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_queue$validate()</pre></div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly). Called for its side effects.
</p>


<hr>
<a id="method-crew_class_queue-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Reset the queue.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_queue$reset()</pre></div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly). Called for its side effects.
</p>


<hr>
<a id="method-crew_class_queue-set"></a>



<h4>Method <code>set()</code></h4>

<p>Set the names in the queue.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_queue$set(names = character(0L))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>names</code></dt><dd><p>Character vector of names to set.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly). Called for its side effects.
</p>


<hr>
<a id="method-crew_class_queue-pop"></a>



<h4>Method <code>pop()</code></h4>

<p>Pop a name off the queue.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_queue$pop()</pre></div>



<h5>Returns</h5>

<p>Character string, a name popped off the queue.
<code>NULL</code> if there are no more names available to pop.
</p>


<hr>
<a id="method-crew_class_queue-collect"></a>



<h4>Method <code>collect()</code></h4>

<p>Remove and return all available names off the queue.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_queue$collect()</pre></div>



<h5>Returns</h5>

<p>Character vector, names collected from the queue.
<code>NULL</code> if there are no more names available to collect.
</p>


<hr>
<a id="method-crew_class_queue-empty"></a>



<h4>Method <code>empty()</code></h4>

<p>Report if the queue is empty.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_queue$empty()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> if the queue is empty, <code>FALSE</code> otherwise.
</p>


<hr>
<a id="method-crew_class_queue-nonempty"></a>



<h4>Method <code>nonempty()</code></h4>

<p>Report if the queue is nonempty.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_queue$nonempty()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> if the queue is nonempty, <code>FALSE</code> otherwise.
</p>


<hr>
<a id="method-crew_class_queue-popped"></a>



<h4>Method <code>popped()</code></h4>

<p>List the names already popped.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_queue$popped()</pre></div>



<h5>Details</h5>

<p><code>set()</code>, <code>reset()</code>, and <code>collect()</code> remove these names.
</p>



<h5>Returns</h5>

<p>Character vector of names already popped.
</p>




<h3>See Also</h3>

<p>Other queue: 
<code><a href="#topic+crew_queue">crew_queue</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>crew_queue()
</code></pre>

<hr>
<h2 id='crew_class_relay'><code>R6</code> relay class.</h2><span id='topic+crew_class_relay'></span>

<h3>Description</h3>

<p><code>R6</code> class for relay configuration.
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+crew_relay">crew_relay()</a></code>.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>condition</code></dt><dd><p>Main condition variable.</p>
</dd>
<dt><code>from</code></dt><dd><p>Condition variable to relay from.</p>
</dd>
<dt><code>to</code></dt><dd><p>Condition variable to relay to.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-crew_class_relay-validate"><code>crew_class_relay$validate()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_relay-start"><code>crew_class_relay$start()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_relay-terminate"><code>crew_class_relay$terminate()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_relay-set_from"><code>crew_class_relay$set_from()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_relay-set_to"><code>crew_class_relay$set_to()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_relay-wait"><code>crew_class_relay$wait()</code></a>
</p>
</li></ul>


<hr>
<a id="method-crew_class_relay-validate"></a>



<h4>Method <code>validate()</code></h4>

<p>Validate the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_relay$validate()</pre></div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_relay-start"></a>



<h4>Method <code>start()</code></h4>

<p>Start the relay object.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_relay$start()</pre></div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_relay-terminate"></a>



<h4>Method <code>terminate()</code></h4>

<p>Terminate the relay object.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_relay$terminate()</pre></div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_relay-set_from"></a>



<h4>Method <code>set_from()</code></h4>

<p>Set the condition variable to relay from.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_relay$set_from(from)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>from</code></dt><dd><p>Condition variable to relay from.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_relay-set_to"></a>



<h4>Method <code>set_to()</code></h4>

<p>Set the condition variable to relay to.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_relay$set_to(to)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>to</code></dt><dd><p>Condition variable to relay to.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_relay-wait"></a>



<h4>Method <code>wait()</code></h4>

<p>Wait until an unobserved task resolves or the timeout
is reached. Use the throttle to determine the waiting time.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_relay$wait(throttle)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>throttle</code></dt><dd><p>A <code><a href="#topic+crew_throttle">crew_throttle()</a></code> object to orchestrate the
wait time intervals.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>




<h3>See Also</h3>

<p>Other relay: 
<code><a href="#topic+crew_relay">crew_relay</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>crew_relay()
</code></pre>

<hr>
<h2 id='crew_class_throttle'><code>R6</code> throttle class.</h2><span id='topic+crew_class_throttle'></span>

<h3>Description</h3>

<p><code>R6</code> class for throttle configuration.
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+crew_throttle">crew_throttle()</a></code>.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>seconds_max</code></dt><dd><p>See <code><a href="#topic+crew_throttle">crew_throttle()</a></code>.</p>
</dd>
<dt><code>seconds_min</code></dt><dd><p>See <code><a href="#topic+crew_throttle">crew_throttle()</a></code>.</p>
</dd>
<dt><code>seconds_start</code></dt><dd><p>See <code><a href="#topic+crew_throttle">crew_throttle()</a></code>.</p>
</dd>
<dt><code>base</code></dt><dd><p>See <code><a href="#topic+crew_throttle">crew_throttle()</a></code>.</p>
</dd>
<dt><code>seconds_interval</code></dt><dd><p>Current wait time interval.</p>
</dd>
<dt><code>polled</code></dt><dd><p>Positive numeric of length 1,
millisecond timestamp of the last time <code>poll()</code> returned <code>TRUE</code>.
<code>NULL</code> if <code>poll()</code> was never called on the current object.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-crew_class_throttle-new"><code>crew_class_throttle$new()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_throttle-validate"><code>crew_class_throttle$validate()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_throttle-poll"><code>crew_class_throttle$poll()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_throttle-accelerate"><code>crew_class_throttle$accelerate()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_throttle-decelerate"><code>crew_class_throttle$decelerate()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_throttle-reset"><code>crew_class_throttle$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_throttle-update"><code>crew_class_throttle$update()</code></a>
</p>
</li></ul>


<hr>
<a id="method-crew_class_throttle-new"></a>



<h4>Method <code>new()</code></h4>

<p>Throttle constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_throttle$new(
  seconds_max = NULL,
  seconds_min = NULL,
  seconds_start = NULL,
  base = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>seconds_max</code></dt><dd><p>See <code><a href="#topic+crew_throttle">crew_throttle()</a></code>.</p>
</dd>
<dt><code>seconds_min</code></dt><dd><p>See <code><a href="#topic+crew_throttle">crew_throttle()</a></code>.</p>
</dd>
<dt><code>seconds_start</code></dt><dd><p>See <code><a href="#topic+crew_throttle">crew_throttle()</a></code>.</p>
</dd>
<dt><code>base</code></dt><dd><p>See <code><a href="#topic+crew_throttle">crew_throttle()</a></code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An <code>R6</code> object with throttle configuration.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>throttle &lt;- crew_throttle(seconds_max = 1)
throttle$poll()
throttle$poll()
</pre>
</div>


<hr>
<a id="method-crew_class_throttle-validate"></a>



<h4>Method <code>validate()</code></h4>

<p>Validate the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_throttle$validate()</pre></div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_throttle-poll"></a>



<h4>Method <code>poll()</code></h4>

<p>Poll the throttler.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_throttle$poll()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> if <code>poll()</code> did not return <code>TRUE</code> in the last
<code>max</code> seconds, <code>FALSE</code> otherwise.
</p>


<hr>
<a id="method-crew_class_throttle-accelerate"></a>



<h4>Method <code>accelerate()</code></h4>

<p>Divide <code>seconds_interval</code> by <code>base</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_throttle$accelerate()</pre></div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly). Called for its side effects.
</p>


<hr>
<a id="method-crew_class_throttle-decelerate"></a>



<h4>Method <code>decelerate()</code></h4>

<p>Multiply <code>seconds_interval</code> by <code>base</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_throttle$decelerate()</pre></div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly). Called for its side effects.
</p>


<hr>
<a id="method-crew_class_throttle-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Reset the throttle object so the next <code>poll()</code> returns
<code>TRUE</code>, and reset the wait time interval to its initial value.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_throttle$reset()</pre></div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_throttle-update"></a>



<h4>Method <code>update()</code></h4>

<p>Reset the throttle when there is activity and
decelerate it gradually when there is no activity.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_throttle$update(activity)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>activity</code></dt><dd><p><code>TRUE</code> if there is activity, <code>FALSE</code> otherwise.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>




<h3>See Also</h3>

<p>Other throttle: 
<code><a href="#topic+crew_throttle">crew_throttle</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>throttle &lt;- crew_throttle(seconds_max = 1)
throttle$poll()
throttle$poll()

## ------------------------------------------------
## Method `crew_class_throttle$new`
## ------------------------------------------------

throttle &lt;- crew_throttle(seconds_max = 1)
throttle$poll()
throttle$poll()
</code></pre>

<hr>
<h2 id='crew_class_tls'><code>R6</code> TLS class.</h2><span id='topic+crew_class_tls'></span>

<h3>Description</h3>

<p><code>R6</code> class for TLS configuration.
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+crew_tls">crew_tls()</a></code>.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>mode</code></dt><dd><p>See <code><a href="#topic+crew_tls">crew_tls()</a></code>.</p>
</dd>
<dt><code>key</code></dt><dd><p>See <code><a href="#topic+crew_tls">crew_tls()</a></code>.</p>
</dd>
<dt><code>password</code></dt><dd><p>See <code><a href="#topic+crew_tls">crew_tls()</a></code>.</p>
</dd>
<dt><code>certificates</code></dt><dd><p>See <code><a href="#topic+crew_tls">crew_tls()</a></code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-crew_class_tls-new"><code>crew_class_tls$new()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_tls-validate"><code>crew_class_tls$validate()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_tls-client"><code>crew_class_tls$client()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_tls-worker"><code>crew_class_tls$worker()</code></a>
</p>
</li>
<li> <p><a href="#method-crew_class_tls-url"><code>crew_class_tls$url()</code></a>
</p>
</li></ul>


<hr>
<a id="method-crew_class_tls-new"></a>



<h4>Method <code>new()</code></h4>

<p>TLS configuration constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_tls$new(
  mode = NULL,
  key = NULL,
  password = NULL,
  certificates = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mode</code></dt><dd><p>Argument passed from <code><a href="#topic+crew_tls">crew_tls()</a></code>.</p>
</dd>
<dt><code>key</code></dt><dd><p>Argument passed from <code><a href="#topic+crew_tls">crew_tls()</a></code>.</p>
</dd>
<dt><code>password</code></dt><dd><p>Argument passed from <code><a href="#topic+crew_tls">crew_tls()</a></code>.</p>
</dd>
<dt><code>certificates</code></dt><dd><p>Argument passed from <code><a href="#topic+crew_tls">crew_tls()</a></code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An <code>R6</code> object with TLS configuration.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>crew_tls(mode = "automatic")
</pre>
</div>


<hr>
<a id="method-crew_class_tls-validate"></a>



<h4>Method <code>validate()</code></h4>

<p>Validate the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_tls$validate(test = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>test</code></dt><dd><p>Logical of length 1, whether to test the TLS configuration
with <code>nanonext::tls_config()</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>NULL</code> (invisibly).
</p>


<hr>
<a id="method-crew_class_tls-client"></a>



<h4>Method <code>client()</code></h4>

<p>TLS credentials for the <code>crew</code> client.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_tls$client()</pre></div>



<h5>Returns</h5>

<p><code>NULL</code> or character vector, depending on the mode.
</p>


<hr>
<a id="method-crew_class_tls-worker"></a>



<h4>Method <code>worker()</code></h4>

<p>TLS credentials for <code>crew</code> workers.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_tls$worker(profile)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>profile</code></dt><dd><p>Character of length 1 with the <code>mirai</code> compute profile.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>NULL</code> or character vector, depending on the mode.
</p>


<hr>
<a id="method-crew_class_tls-url"></a>



<h4>Method <code>url()</code></h4>

<p>Form the URL for <code>crew</code> worker connections.
</p>


<h5>Usage</h5>

<div class="r"><pre>crew_class_tls$url(host, port)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>host</code></dt><dd><p>Character string with the host name or IP address.</p>
</dd>
<dt><code>port</code></dt><dd><p>Non-negative integer with the port number
(0 to let NNG select a random ephemeral port).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Character string with the URL.
</p>




<h3>See Also</h3>

<p>Other tls: 
<code><a href="#topic+crew_tls">crew_tls</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>crew_tls(mode = "automatic")

## ------------------------------------------------
## Method `crew_class_tls$new`
## ------------------------------------------------

crew_tls(mode = "automatic")
</code></pre>

<hr>
<h2 id='crew_clean'>Terminate dispatchers and/or workers</h2><span id='topic+crew_clean'></span>

<h3>Description</h3>

<p>Terminate <code>mirai</code> dispatchers and/or <code>crew</code> workers
which may be lingering from previous workloads.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crew_clean(
  dispatchers = TRUE,
  workers = TRUE,
  user = ps::ps_username(),
  seconds_interval = 1,
  seconds_timeout = 60,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crew_clean_+3A_dispatchers">dispatchers</code></td>
<td>
<p>Logical of length 1,
whether to terminate dispatchers.</p>
</td></tr>
<tr><td><code id="crew_clean_+3A_workers">workers</code></td>
<td>
<p>Logical of length 1,
whether to terminate workers.</p>
</td></tr>
<tr><td><code id="crew_clean_+3A_user">user</code></td>
<td>
<p>Character of length 1. Terminate dispatchers and/or
workers associated with this user name.</p>
</td></tr>
<tr><td><code id="crew_clean_+3A_seconds_interval">seconds_interval</code></td>
<td>
<p>Seconds to between polling intervals
waiting for a process to exit.</p>
</td></tr>
<tr><td><code id="crew_clean_+3A_seconds_timeout">seconds_timeout</code></td>
<td>
<p>Seconds to wait for a process to exit.</p>
</td></tr>
<tr><td><code id="crew_clean_+3A_verbose">verbose</code></td>
<td>
<p>Logical of length 1, whether to print an informative
message every time a process is terminated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Behind the scenes, <code>mirai</code> uses an external R process
called a &quot;dispatcher&quot; to send tasks to <code>crew</code> workers.
This dispatcher usually shuts down when you terminate the controller
or quit your R session, but sometimes it lingers. Likewise,
sometimes <code>crew</code> workers do not shut down on their own.
The <code>crew_clean()</code> function searches the process table on your
local machine and manually terminates any <code>mirai</code> dispatchers
and <code>crew</code> workers associated with your user name (or the
user name you select in the <code>user</code> argument.
Unfortunately, it cannot reach remote workers such as those
launched by a <code>crew.cluster</code> controller.
</p>


<h3>Value</h3>

<p><code>NULL</code> (invisibly). If <code>verbose</code> is <code>TRUE</code>, it does
print out a message for every terminated process.
</p>


<h3>See Also</h3>

<p>Other utility: 
<code><a href="#topic+crew_assert">crew_assert</a>()</code>,
<code><a href="#topic+crew_deprecate">crew_deprecate</a>()</code>,
<code><a href="#topic+crew_eval">crew_eval</a>()</code>,
<code><a href="#topic+crew_random_name">crew_random_name</a>()</code>,
<code><a href="#topic+crew_retry">crew_retry</a>()</code>,
<code><a href="#topic+crew_terminate_process">crew_terminate_process</a>()</code>,
<code><a href="#topic+crew_terminate_signal">crew_terminate_signal</a>()</code>,
<code><a href="#topic+crew_worker">crew_worker</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("CREW_EXAMPLES"), "true")) {
crew_clean()
}
</code></pre>

<hr>
<h2 id='crew_client'>Create a client object.</h2><span id='topic+crew_client'></span>

<h3>Description</h3>

<p>Create an <code>R6</code> wrapper object to manage the <code>mirai</code> client.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crew_client(
  name = NULL,
  workers = NULL,
  host = NULL,
  port = NULL,
  tls = crew::crew_tls(),
  tls_enable = NULL,
  tls_config = NULL,
  seconds_interval = 1,
  seconds_timeout = 60,
  retry_tasks = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crew_client_+3A_name">name</code></td>
<td>
<p>Deprecated on 2025-01-14 (<code>crew</code> version 0.10.2.9002).</p>
</td></tr>
<tr><td><code id="crew_client_+3A_workers">workers</code></td>
<td>
<p>Deprecated on 2025-01-13 (<code>crew</code> version 0.10.2.9002).</p>
</td></tr>
<tr><td><code id="crew_client_+3A_host">host</code></td>
<td>
<p>IP address of the <code>mirai</code> client to send and receive tasks.
If <code>NULL</code>, the host defaults to the local IP address.</p>
</td></tr>
<tr><td><code id="crew_client_+3A_port">port</code></td>
<td>
<p>TCP port to listen for the workers. If <code>NULL</code>,
then an available ephemeral port is automatically chosen.
Controllers running simultaneously on the same computer
(as in a controller group) must not share the same TCP port.</p>
</td></tr>
<tr><td><code id="crew_client_+3A_tls">tls</code></td>
<td>
<p>A TLS configuration object from <code><a href="#topic+crew_tls">crew_tls()</a></code>.</p>
</td></tr>
<tr><td><code id="crew_client_+3A_tls_enable">tls_enable</code></td>
<td>
<p>Deprecated on 2023-09-15 in version 0.4.1.
Use argument <code>tls</code> instead.</p>
</td></tr>
<tr><td><code id="crew_client_+3A_tls_config">tls_config</code></td>
<td>
<p>Deprecated on 2023-09-15 in version 0.4.1.
Use argument <code>tls</code> instead.</p>
</td></tr>
<tr><td><code id="crew_client_+3A_seconds_interval">seconds_interval</code></td>
<td>
<p>Number of seconds between
polling intervals waiting for certain internal
synchronous operations to complete,
such as checking <code>mirai::status()</code></p>
</td></tr>
<tr><td><code id="crew_client_+3A_seconds_timeout">seconds_timeout</code></td>
<td>
<p>Number of seconds until timing
out while waiting for certain synchronous operations to complete,
such as checking <code>mirai::status()</code>.</p>
</td></tr>
<tr><td><code id="crew_client_+3A_retry_tasks">retry_tasks</code></td>
<td>
<p>Deprecated on 2025-01-13 (<code>crew</code> version 0.10.2.9002).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other client: 
<code><a href="#topic+crew_class_client">crew_class_client</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("CREW_EXAMPLES"), "true")) {
client &lt;- crew_client()
client$start()
client$summary()
client$terminate()
}
</code></pre>

<hr>
<h2 id='crew_controller'>Create a controller object from a client and launcher.</h2><span id='topic+crew_controller'></span>

<h3>Description</h3>

<p>This function is for developers of <code>crew</code> launcher plugins.
Users should use a specific controller helper such as
<code><a href="#topic+crew_controller_local">crew_controller_local()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crew_controller(
  client,
  launcher,
  crashes_max = 5L,
  backup = NULL,
  auto_scale = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crew_controller_+3A_client">client</code></td>
<td>
<p>An <code>R6</code> client object created by <code><a href="#topic+crew_client">crew_client()</a></code>.</p>
</td></tr>
<tr><td><code id="crew_controller_+3A_launcher">launcher</code></td>
<td>
<p>An <code>R6</code> launcher object created by one of the
<code style="white-space: pre;">&#8288;crew_launcher_*()&#8288;</code> functions such as <code><a href="#topic+crew_launcher_local">crew_launcher_local()</a></code>.</p>
</td></tr>
<tr><td><code id="crew_controller_+3A_crashes_max">crashes_max</code></td>
<td>
<p>In rare cases, a worker may exit unexpectedly
before it completes its current task. If this happens, <code>pop()</code>
returns a status of <code>"crash"</code> instead of <code>"error"</code> for the task.
The controller does not automatically retry the task, but
you can retry it manually by calling <code>push()</code> again and using the same
task name as before. (However, <code>targets</code> pipelines running <code>crew</code>
do automatically retry tasks whose workers crashed.)
</p>
<p><code>crashes_max</code> is a non-negative integer, and it sets the maximum number of
allowable consecutive crashes for a given task.
If a task's worker crashes more than <code>crashes_max</code> times in a row,
then <code>pop()</code> throws an error when it tries to return the results
of the task.</p>
</td></tr>
<tr><td><code id="crew_controller_+3A_backup">backup</code></td>
<td>
<p>An optional <code>crew</code> controller object, or <code>NULL</code> to omit.
If supplied, the <code>backup</code> controller runs any pushed tasks that have
already reached <code>crashes_max</code> consecutive crashes.
Using <code>backup</code>, you can create
a chain of controllers with different levels of resources
(such as worker memory and CPUs) so that a task that fails on
one controller can retry using incrementally more powerful workers.
All controllers in a backup chain should be part of the same
controller group (see <code><a href="#topic+crew_controller_group">crew_controller_group()</a></code>) so you can call the
group-level <code>pop()</code> and <code>collect()</code> methods to make sure you get results
regardless of which controller actually ended up running the task.
</p>
<p>Limitations of <code>backup</code>:
* <code>crashes_max</code> needs to be positive in order for <code>backup</code> to be used.
Otherwise, every task would always skip the current controller and
go to <code>backup</code>.
* <code>backup</code> cannot be a controller group. It must be an ordinary
controller.</p>
</td></tr>
<tr><td><code id="crew_controller_+3A_auto_scale">auto_scale</code></td>
<td>
<p>Deprecated. Use the <code>scale</code> argument of <code>push()</code>,
<code>pop()</code>, and <code>wait()</code> instead.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other controller: 
<code><a href="#topic+crew_class_controller">crew_class_controller</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("CREW_EXAMPLES"), "true")) {
client &lt;- crew_client()
launcher &lt;- crew_launcher_local()
controller &lt;- crew_controller(client = client, launcher = launcher)
controller$start()
controller$push(name = "task", command = sqrt(4))
controller$wait()
controller$pop()
controller$terminate()
}
</code></pre>

<hr>
<h2 id='crew_controller_group'>Create a controller group.</h2><span id='topic+crew_controller_group'></span>

<h3>Description</h3>

<p>Create an <code>R6</code> object to submit tasks and launch workers
through multiple <code>crew</code> controllers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crew_controller_group(..., seconds_interval = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crew_controller_group_+3A_...">...</code></td>
<td>
<p><code>R6</code> controller objects or lists of <code>R6</code> controller objects.
Nested lists are allowed, but each element must be a control object
or another list.</p>
</td></tr>
<tr><td><code id="crew_controller_group_+3A_seconds_interval">seconds_interval</code></td>
<td>
<p>Number of seconds between
polling intervals waiting for certain internal
synchronous operations to complete,
such as checking <code>mirai::status()</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other controller_group: 
<code><a href="#topic+crew_class_controller_group">crew_class_controller_group</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("CREW_EXAMPLES"), "true")) {
persistent &lt;- crew_controller_local(name = "persistent")
transient &lt;- crew_controller_local(
  name = "transient",
  tasks_max = 1L
)
group &lt;- crew_controller_group(persistent, transient)
group$start()
group$push(name = "task", command = sqrt(4), controller = "transient")
group$wait()
group$pop()
group$terminate()
}
</code></pre>

<hr>
<h2 id='crew_controller_local'>Create a controller with a local process launcher.</h2><span id='topic+crew_controller_local'></span>

<h3>Description</h3>

<p>Create an <code>R6</code> object to submit tasks and
launch workers on local processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crew_controller_local(
  name = NULL,
  workers = 1L,
  host = "127.0.0.1",
  port = NULL,
  tls = crew::crew_tls(),
  tls_enable = NULL,
  tls_config = NULL,
  seconds_interval = 1,
  seconds_timeout = 60,
  seconds_launch = 30,
  seconds_idle = 300,
  seconds_wall = Inf,
  seconds_exit = NULL,
  retry_tasks = NULL,
  tasks_max = Inf,
  tasks_timers = 0L,
  reset_globals = TRUE,
  reset_packages = FALSE,
  reset_options = FALSE,
  garbage_collection = FALSE,
  crashes_error = NULL,
  launch_max = NULL,
  r_arguments = c("--no-save", "--no-restore"),
  crashes_max = 5L,
  backup = NULL,
  options_metrics = crew::crew_options_metrics(),
  options_local = crew::crew_options_local(),
  local_log_directory = NULL,
  local_log_join = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crew_controller_local_+3A_name">name</code></td>
<td>
<p>Deprecated on 2025-01-14 (<code>crew</code> version 0.10.2.9002).</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_workers">workers</code></td>
<td>
<p>Deprecated on 2025-01-13 (<code>crew</code> version 0.10.2.9002).</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_host">host</code></td>
<td>
<p>IP address of the <code>mirai</code> client to send and receive tasks.
If <code>NULL</code>, the host defaults to the local IP address.</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_port">port</code></td>
<td>
<p>TCP port to listen for the workers. If <code>NULL</code>,
then an available ephemeral port is automatically chosen.
Controllers running simultaneously on the same computer
(as in a controller group) must not share the same TCP port.</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_tls">tls</code></td>
<td>
<p>A TLS configuration object from <code><a href="#topic+crew_tls">crew_tls()</a></code>.</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_tls_enable">tls_enable</code></td>
<td>
<p>Deprecated on 2023-09-15 in version 0.4.1.
Use argument <code>tls</code> instead.</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_tls_config">tls_config</code></td>
<td>
<p>Deprecated on 2023-09-15 in version 0.4.1.
Use argument <code>tls</code> instead.</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_seconds_interval">seconds_interval</code></td>
<td>
<p>Number of seconds between
polling intervals waiting for certain internal
synchronous operations to complete,
such as checking <code>mirai::status()</code></p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_seconds_timeout">seconds_timeout</code></td>
<td>
<p>Number of seconds until timing
out while waiting for certain synchronous operations to complete,
such as checking <code>mirai::status()</code>.</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_seconds_launch">seconds_launch</code></td>
<td>
<p>Seconds of startup time to allow.
A worker is unconditionally assumed to be alive
from the moment of its launch until <code>seconds_launch</code> seconds later.
After <code>seconds_launch</code> seconds, the worker is only
considered alive if it is actively connected to its assign websocket.</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_seconds_idle">seconds_idle</code></td>
<td>
<p>Maximum number of seconds that a worker can idle
since the completion of the last task. If exceeded, the worker exits.
But the timer does not launch until <code>tasks_timers</code> tasks
have completed.
See the <code>idletime</code> argument of <code>mirai::daemon()</code>. <code>crew</code> does not
excel with perfectly transient workers because it does not micromanage
the assignment of tasks to workers, so please allow enough idle
time for a new worker to be delegated a new task.</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_seconds_wall">seconds_wall</code></td>
<td>
<p>Soft wall time in seconds.
The timer does not launch until <code>tasks_timers</code> tasks
have completed.
See the <code>walltime</code> argument of <code>mirai::daemon()</code>.</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_seconds_exit">seconds_exit</code></td>
<td>
<p>Deprecated on 2023-09-21 in version 0.5.0.9002.
No longer necessary.</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_retry_tasks">retry_tasks</code></td>
<td>
<p>Deprecated on 2025-01-13 (<code>crew</code> version 0.10.2.9002).</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_tasks_max">tasks_max</code></td>
<td>
<p>Maximum number of tasks that a worker will do before
exiting. See the <code>maxtasks</code> argument of <code>mirai::daemon()</code>.
<code>crew</code> does not
excel with perfectly transient workers because it does not micromanage
the assignment of tasks to workers, it is recommended to set
<code>tasks_max</code> to a value greater than 1.</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_tasks_timers">tasks_timers</code></td>
<td>
<p>Number of tasks to do before activating
the timers for <code>seconds_idle</code> and <code>seconds_wall</code>.
See the <code>timerstart</code> argument of <code>mirai::daemon()</code>.</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_reset_globals">reset_globals</code></td>
<td>
<p><code>TRUE</code> to reset global environment
variables between tasks, <code>FALSE</code> to leave them alone.</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_reset_packages">reset_packages</code></td>
<td>
<p><code>TRUE</code> to unload any packages loaded during
a task (runs between each task), <code>FALSE</code> to leave packages alone.</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_reset_options">reset_options</code></td>
<td>
<p><code>TRUE</code> to reset global options to their original
state between each task, <code>FALSE</code> otherwise. It is recommended to
only set <code>reset_options = TRUE</code> if <code>reset_packages</code> is also <code>TRUE</code>
because packages sometimes rely on options they set at loading time.</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p><code>TRUE</code> to run garbage collection between
tasks, <code>FALSE</code> to skip.</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_crashes_error">crashes_error</code></td>
<td>
<p>Deprecated on 2025-01-13 (<code>crew</code> version 0.10.2.9002).</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_launch_max">launch_max</code></td>
<td>
<p>Deprecated on 2024-11-04 (<code>crew</code> version 0.10.2.9002).
Use <code>crashes_error</code> instead.</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_r_arguments">r_arguments</code></td>
<td>
<p>Optional character vector of command line arguments
to pass to <code>Rscript</code> (non-Windows) or <code>Rscript.exe</code> (Windows)
when starting a worker. Example:
<code>r_arguments = c("--vanilla", "--max-connections=32")</code>.</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_crashes_max">crashes_max</code></td>
<td>
<p>In rare cases, a worker may exit unexpectedly
before it completes its current task. If this happens, <code>pop()</code>
returns a status of <code>"crash"</code> instead of <code>"error"</code> for the task.
The controller does not automatically retry the task, but
you can retry it manually by calling <code>push()</code> again and using the same
task name as before. (However, <code>targets</code> pipelines running <code>crew</code>
do automatically retry tasks whose workers crashed.)
</p>
<p><code>crashes_max</code> is a non-negative integer, and it sets the maximum number of
allowable consecutive crashes for a given task.
If a task's worker crashes more than <code>crashes_max</code> times in a row,
then <code>pop()</code> throws an error when it tries to return the results
of the task.</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_backup">backup</code></td>
<td>
<p>An optional <code>crew</code> controller object, or <code>NULL</code> to omit.
If supplied, the <code>backup</code> controller runs any pushed tasks that have
already reached <code>crashes_max</code> consecutive crashes.
Using <code>backup</code>, you can create
a chain of controllers with different levels of resources
(such as worker memory and CPUs) so that a task that fails on
one controller can retry using incrementally more powerful workers.
All controllers in a backup chain should be part of the same
controller group (see <code><a href="#topic+crew_controller_group">crew_controller_group()</a></code>) so you can call the
group-level <code>pop()</code> and <code>collect()</code> methods to make sure you get results
regardless of which controller actually ended up running the task.
</p>
<p>Limitations of <code>backup</code>:
* <code>crashes_max</code> needs to be positive in order for <code>backup</code> to be used.
Otherwise, every task would always skip the current controller and
go to <code>backup</code>.
* <code>backup</code> cannot be a controller group. It must be an ordinary
controller.</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_options_metrics">options_metrics</code></td>
<td>
<p>Either <code>NULL</code> to opt out of resource metric logging
for workers, or an object from <code><a href="#topic+crew_options_metrics">crew_options_metrics()</a></code> to enable
and configure resource metric logging for workers.
For resource logging to run,
the <code>autometric</code> R package version 0.1.0 or higher
must be installed.</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_options_local">options_local</code></td>
<td>
<p>An object generated by <code><a href="#topic+crew_options_local">crew_options_local()</a></code>
with options specific to the local controller.</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_local_log_directory">local_log_directory</code></td>
<td>
<p>Deprecated on 2024-10-08. Use
<code>options_local</code> instead.</p>
</td></tr>
<tr><td><code id="crew_controller_local_+3A_local_log_join">local_log_join</code></td>
<td>
<p>Deprecated on 2024-10-08. Use
<code>options_local</code> instead.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other plugin_local: 
<code><a href="#topic+crew_class_launcher_local">crew_class_launcher_local</a></code>,
<code><a href="#topic+crew_launcher_local">crew_launcher_local</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("CREW_EXAMPLES"), "true")) {
controller &lt;- crew_controller_local()
controller$start()
controller$push(name = "task", command = sqrt(4))
controller$wait()
controller$pop()
controller$terminate()
}
</code></pre>

<hr>
<h2 id='crew_deprecate'>Deprecate a <code>crew</code> feature.</h2><span id='topic+crew_deprecate'></span>

<h3>Description</h3>

<p>Show an informative warning when a <code>crew</code> feature is
deprecated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crew_deprecate(
  name,
  date,
  version,
  alternative,
  condition = "warning",
  value = "x",
  skip_cran = FALSE,
  frequency = "always"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crew_deprecate_+3A_name">name</code></td>
<td>
<p>Name of the feature (function or argument) to deprecate.</p>
</td></tr>
<tr><td><code id="crew_deprecate_+3A_date">date</code></td>
<td>
<p>Date of deprecation.</p>
</td></tr>
<tr><td><code id="crew_deprecate_+3A_version">version</code></td>
<td>
<p>Package version when deprecation was instated.</p>
</td></tr>
<tr><td><code id="crew_deprecate_+3A_alternative">alternative</code></td>
<td>
<p>Message about an alternative.</p>
</td></tr>
<tr><td><code id="crew_deprecate_+3A_condition">condition</code></td>
<td>
<p>Either &quot;warning&quot; or &quot;message&quot; to indicate the type
of condition thrown on deprecation.</p>
</td></tr>
<tr><td><code id="crew_deprecate_+3A_value">value</code></td>
<td>
<p>Value of the object. Deprecation is skipped
if <code>value</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="crew_deprecate_+3A_skip_cran">skip_cran</code></td>
<td>
<p>Logical of length 1, whether to skip the deprecation
warning or message on CRAN.</p>
</td></tr>
<tr><td><code id="crew_deprecate_+3A_frequency">frequency</code></td>
<td>
<p>Character of length 1, passed to the <code>.frequency</code>
argument of <code>rlang::warn()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> (invisibly). Throws a warning if a feature is deprecated.
</p>


<h3>See Also</h3>

<p>Other utility: 
<code><a href="#topic+crew_assert">crew_assert</a>()</code>,
<code><a href="#topic+crew_clean">crew_clean</a>()</code>,
<code><a href="#topic+crew_eval">crew_eval</a>()</code>,
<code><a href="#topic+crew_random_name">crew_random_name</a>()</code>,
<code><a href="#topic+crew_retry">crew_retry</a>()</code>,
<code><a href="#topic+crew_terminate_process">crew_terminate_process</a>()</code>,
<code><a href="#topic+crew_terminate_signal">crew_terminate_signal</a>()</code>,
<code><a href="#topic+crew_worker">crew_worker</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>suppressWarnings(
  crew_deprecate(
    name = "auto_scale",
    date = "2023-05-18",
    version = "0.2.0",
    alternative = "use the scale argument of push(), pop(), and wait()."
  )
)
</code></pre>

<hr>
<h2 id='crew_eval'>Evaluate an R command and return results as a monad.</h2><span id='topic+crew_eval'></span>

<h3>Description</h3>

<p>Not a user-side function. Do not call directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crew_eval(
  command,
  name,
  data = list(),
  globals = list(),
  seed = NULL,
  algorithm = NULL,
  packages = character(0),
  library = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crew_eval_+3A_command">command</code></td>
<td>
<p>Language object with R code to run.</p>
</td></tr>
<tr><td><code id="crew_eval_+3A_name">name</code></td>
<td>
<p>Character of length 1, name of the task.</p>
</td></tr>
<tr><td><code id="crew_eval_+3A_data">data</code></td>
<td>
<p>Named list of local data objects in the evaluation environment.</p>
</td></tr>
<tr><td><code id="crew_eval_+3A_globals">globals</code></td>
<td>
<p>Named list of objects to temporarily assign to the
global environment for the task.</p>
</td></tr>
<tr><td><code id="crew_eval_+3A_seed">seed</code></td>
<td>
<p>Integer of length 1 with the pseudo-random number generator
seed to set for the evaluation of the task. Passed to the
<code>seed</code> argument of <code>set.seed()</code> if not <code>NULL</code>.
If <code>algorithm</code> and <code>seed</code> are both <code>NULL</code>,
then the random number generator defaults to the
recommended widely spaced worker-specific
L'Ecuyer streams as supported by <code>mirai::nextstream()</code>.
See <code>vignette("parallel", package = "parallel")</code> for details.</p>
</td></tr>
<tr><td><code id="crew_eval_+3A_algorithm">algorithm</code></td>
<td>
<p>Integer of length 1 with the pseudo-random number
generator algorithm to set for the evaluation of the task.
Passed to the <code>kind</code> argument of <code>RNGkind()</code> if not <code>NULL</code>.
If <code>algorithm</code> and <code>seed</code> are both <code>NULL</code>,
then the random number generator defaults to the
recommended widely spaced worker-specific
L'Ecuyer streams as supported by <code>mirai::nextstream()</code>.
See <code>vignette("parallel", package = "parallel")</code> for details.</p>
</td></tr>
<tr><td><code id="crew_eval_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load for the task.</p>
</td></tr>
<tr><td><code id="crew_eval_+3A_library">library</code></td>
<td>
<p>Library path to load the packages. See the <code>lib.loc</code>
argument of <code>require()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>crew_eval()</code> function evaluates an R expression
in an encapsulated environment and returns a monad with the results,
including warnings and error messages if applicable.
The random number generator seed, <code>globals</code>, and global options
are restored to their original values on exit.
</p>


<h3>Value</h3>

<p>A monad object with results and metadata.
</p>


<h3>See Also</h3>

<p>Other utility: 
<code><a href="#topic+crew_assert">crew_assert</a>()</code>,
<code><a href="#topic+crew_clean">crew_clean</a>()</code>,
<code><a href="#topic+crew_deprecate">crew_deprecate</a>()</code>,
<code><a href="#topic+crew_random_name">crew_random_name</a>()</code>,
<code><a href="#topic+crew_retry">crew_retry</a>()</code>,
<code><a href="#topic+crew_terminate_process">crew_terminate_process</a>()</code>,
<code><a href="#topic+crew_terminate_signal">crew_terminate_signal</a>()</code>,
<code><a href="#topic+crew_worker">crew_worker</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>crew_eval(quote(1 + 1), name = "task_name")
</code></pre>

<hr>
<h2 id='crew_eval_async'>Run an asynchronous task in the crew launcher.</h2><span id='topic+crew_eval_async'></span>

<h3>Description</h3>

<p>Called internally, not for users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crew_eval_async(
  command,
  data = list(),
  packages = character(0L),
  library = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crew_eval_async_+3A_command">command</code></td>
<td>
<p>Language object with R code to run.</p>
</td></tr>
<tr><td><code id="crew_eval_async_+3A_data">data</code></td>
<td>
<p>Named list of objects that <code>command</code> depends on.</p>
</td></tr>
<tr><td><code id="crew_eval_async_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load.</p>
</td></tr>
<tr><td><code id="crew_eval_async_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to load the packages from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of running <code>command</code>.
</p>

<hr>
<h2 id='crew_launcher'>Create an abstract launcher.</h2><span id='topic+crew_launcher'></span>

<h3>Description</h3>

<p>This function is useful for inheriting argument documentation
in functions that create custom third-party launchers. See
<code style="white-space: pre;">&#8288;@inheritParams crew::crew_launcher&#8288;</code> in the source code file of
<code><a href="#topic+crew_launcher_local">crew_launcher_local()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crew_launcher(
  name = NULL,
  workers = 1L,
  seconds_interval = 1,
  seconds_timeout = 60,
  seconds_launch = 30,
  seconds_idle = 300,
  seconds_wall = Inf,
  seconds_exit = NULL,
  tasks_max = Inf,
  tasks_timers = 0L,
  reset_globals = TRUE,
  reset_packages = FALSE,
  reset_options = FALSE,
  garbage_collection = FALSE,
  crashes_error = NULL,
  launch_max = NULL,
  tls = crew::crew_tls(),
  processes = NULL,
  r_arguments = c("--no-save", "--no-restore"),
  options_metrics = crew::crew_options_metrics()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crew_launcher_+3A_name">name</code></td>
<td>
<p>Character string, name of the launcher. If the name is
<code>NULL</code>, then a name is automatically generated when the launcher starts.</p>
</td></tr>
<tr><td><code id="crew_launcher_+3A_workers">workers</code></td>
<td>
<p>Maximum number of workers to run concurrently
when auto-scaling, excluding task retries and manual calls to <code>launch()</code>.
Special workers allocated for task retries
do not count towards this limit, so the number of workers running at a
given time may exceed this maximum.
A smaller number of workers may run if the number of executing tasks
is smaller than the supplied value of the <code>workers</code> argument.</p>
</td></tr>
<tr><td><code id="crew_launcher_+3A_seconds_interval">seconds_interval</code></td>
<td>
<p>Number of seconds between
polling intervals waiting for certain internal
synchronous operations to complete. In certain cases, exponential
backoff is used with this argument passed to <code>seconds_max</code>
in a <code><a href="#topic+crew_throttle">crew_throttle()</a></code> object.</p>
</td></tr>
<tr><td><code id="crew_launcher_+3A_seconds_timeout">seconds_timeout</code></td>
<td>
<p>Number of seconds until timing
out while waiting for certain synchronous operations to complete,
such as checking <code>mirai::status()</code>.</p>
</td></tr>
<tr><td><code id="crew_launcher_+3A_seconds_launch">seconds_launch</code></td>
<td>
<p>Seconds of startup time to allow.
A worker is unconditionally assumed to be alive
from the moment of its launch until <code>seconds_launch</code> seconds later.
After <code>seconds_launch</code> seconds, the worker is only
considered alive if it is actively connected to its assign websocket.</p>
</td></tr>
<tr><td><code id="crew_launcher_+3A_seconds_idle">seconds_idle</code></td>
<td>
<p>Maximum number of seconds that a worker can idle
since the completion of the last task. If exceeded, the worker exits.
But the timer does not launch until <code>tasks_timers</code> tasks
have completed.
See the <code>idletime</code> argument of <code>mirai::daemon()</code>. <code>crew</code> does not
excel with perfectly transient workers because it does not micromanage
the assignment of tasks to workers, so please allow enough idle
time for a new worker to be delegated a new task.</p>
</td></tr>
<tr><td><code id="crew_launcher_+3A_seconds_wall">seconds_wall</code></td>
<td>
<p>Soft wall time in seconds.
The timer does not launch until <code>tasks_timers</code> tasks
have completed.
See the <code>walltime</code> argument of <code>mirai::daemon()</code>.</p>
</td></tr>
<tr><td><code id="crew_launcher_+3A_seconds_exit">seconds_exit</code></td>
<td>
<p>Deprecated on 2023-09-21 in version 0.5.0.9002.
No longer necessary.</p>
</td></tr>
<tr><td><code id="crew_launcher_+3A_tasks_max">tasks_max</code></td>
<td>
<p>Maximum number of tasks that a worker will do before
exiting. See the <code>maxtasks</code> argument of <code>mirai::daemon()</code>.
<code>crew</code> does not
excel with perfectly transient workers because it does not micromanage
the assignment of tasks to workers, it is recommended to set
<code>tasks_max</code> to a value greater than 1.</p>
</td></tr>
<tr><td><code id="crew_launcher_+3A_tasks_timers">tasks_timers</code></td>
<td>
<p>Number of tasks to do before activating
the timers for <code>seconds_idle</code> and <code>seconds_wall</code>.
See the <code>timerstart</code> argument of <code>mirai::daemon()</code>.</p>
</td></tr>
<tr><td><code id="crew_launcher_+3A_reset_globals">reset_globals</code></td>
<td>
<p><code>TRUE</code> to reset global environment
variables between tasks, <code>FALSE</code> to leave them alone.</p>
</td></tr>
<tr><td><code id="crew_launcher_+3A_reset_packages">reset_packages</code></td>
<td>
<p><code>TRUE</code> to unload any packages loaded during
a task (runs between each task), <code>FALSE</code> to leave packages alone.</p>
</td></tr>
<tr><td><code id="crew_launcher_+3A_reset_options">reset_options</code></td>
<td>
<p><code>TRUE</code> to reset global options to their original
state between each task, <code>FALSE</code> otherwise. It is recommended to
only set <code>reset_options = TRUE</code> if <code>reset_packages</code> is also <code>TRUE</code>
because packages sometimes rely on options they set at loading time.</p>
</td></tr>
<tr><td><code id="crew_launcher_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p><code>TRUE</code> to run garbage collection between
tasks, <code>FALSE</code> to skip.</p>
</td></tr>
<tr><td><code id="crew_launcher_+3A_crashes_error">crashes_error</code></td>
<td>
<p>Deprecated on 2025-01-13 (<code>crew</code> version 0.10.2.9002).</p>
</td></tr>
<tr><td><code id="crew_launcher_+3A_launch_max">launch_max</code></td>
<td>
<p>Deprecated on 2024-11-04 (<code>crew</code> version 0.10.2.9002).
Use <code>crashes_error</code> instead.</p>
</td></tr>
<tr><td><code id="crew_launcher_+3A_tls">tls</code></td>
<td>
<p>A TLS configuration object from <code><a href="#topic+crew_tls">crew_tls()</a></code>.</p>
</td></tr>
<tr><td><code id="crew_launcher_+3A_processes">processes</code></td>
<td>
<p><code>NULL</code> or positive integer of length 1,
number of local processes to
launch to allow worker launches to happen asynchronously. If <code>NULL</code>,
then no local processes are launched. If 1 or greater, then the launcher
starts the processes on <code>start()</code> and ends them on <code>terminate()</code>.
Plugins that may use these processes should run asynchronous calls
using <code>launcher$async$eval()</code> and expect a <code>mirai</code> task object
as the return value.</p>
</td></tr>
<tr><td><code id="crew_launcher_+3A_r_arguments">r_arguments</code></td>
<td>
<p>Optional character vector of command line arguments
to pass to <code>Rscript</code> (non-Windows) or <code>Rscript.exe</code> (Windows)
when starting a worker. Example:
<code>r_arguments = c("--vanilla", "--max-connections=32")</code>.</p>
</td></tr>
<tr><td><code id="crew_launcher_+3A_options_metrics">options_metrics</code></td>
<td>
<p>Either <code>NULL</code> to opt out of resource metric logging
for workers, or an object from <code><a href="#topic+crew_options_metrics">crew_options_metrics()</a></code> to enable
and configure resource metric logging for workers.
For resource logging to run,
the <code>autometric</code> R package version 0.1.0 or higher
must be installed.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other launcher: 
<code><a href="#topic+crew_class_launcher">crew_class_launcher</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("CREW_EXAMPLES"), "true")) {
client &lt;- crew_client()
client$start()
launcher &lt;- crew_launcher_local()
launcher$start(url = client$url, profile = client$profile)
launcher$launch()
task &lt;- mirai::mirai("result", .compute = client$profile)
mirai::call_mirai_(task)
task$data
client$terminate()
}
</code></pre>

<hr>
<h2 id='crew_launcher_local'>Create a launcher with local process workers.</h2><span id='topic+crew_launcher_local'></span>

<h3>Description</h3>

<p>Create an <code>R6</code> object to launch and maintain
local process workers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crew_launcher_local(
  name = NULL,
  workers = 1L,
  seconds_interval = 1,
  seconds_timeout = 60,
  seconds_launch = 30,
  seconds_idle = Inf,
  seconds_wall = Inf,
  seconds_exit = NULL,
  tasks_max = Inf,
  tasks_timers = 0L,
  reset_globals = TRUE,
  reset_packages = FALSE,
  reset_options = FALSE,
  garbage_collection = FALSE,
  crashes_error = 5L,
  launch_max = NULL,
  tls = crew::crew_tls(),
  r_arguments = c("--no-save", "--no-restore"),
  options_metrics = crew::crew_options_metrics(),
  options_local = crew::crew_options_local(),
  local_log_directory = NULL,
  local_log_join = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crew_launcher_local_+3A_name">name</code></td>
<td>
<p>Character string, name of the launcher. If the name is
<code>NULL</code>, then a name is automatically generated when the launcher starts.</p>
</td></tr>
<tr><td><code id="crew_launcher_local_+3A_workers">workers</code></td>
<td>
<p>Maximum number of workers to run concurrently
when auto-scaling, excluding task retries and manual calls to <code>launch()</code>.
Special workers allocated for task retries
do not count towards this limit, so the number of workers running at a
given time may exceed this maximum.
A smaller number of workers may run if the number of executing tasks
is smaller than the supplied value of the <code>workers</code> argument.</p>
</td></tr>
<tr><td><code id="crew_launcher_local_+3A_seconds_interval">seconds_interval</code></td>
<td>
<p>Number of seconds between
polling intervals waiting for certain internal
synchronous operations to complete. In certain cases, exponential
backoff is used with this argument passed to <code>seconds_max</code>
in a <code><a href="#topic+crew_throttle">crew_throttle()</a></code> object.</p>
</td></tr>
<tr><td><code id="crew_launcher_local_+3A_seconds_timeout">seconds_timeout</code></td>
<td>
<p>Number of seconds until timing
out while waiting for certain synchronous operations to complete,
such as checking <code>mirai::status()</code>.</p>
</td></tr>
<tr><td><code id="crew_launcher_local_+3A_seconds_launch">seconds_launch</code></td>
<td>
<p>Seconds of startup time to allow.
A worker is unconditionally assumed to be alive
from the moment of its launch until <code>seconds_launch</code> seconds later.
After <code>seconds_launch</code> seconds, the worker is only
considered alive if it is actively connected to its assign websocket.</p>
</td></tr>
<tr><td><code id="crew_launcher_local_+3A_seconds_idle">seconds_idle</code></td>
<td>
<p>Maximum number of seconds that a worker can idle
since the completion of the last task. If exceeded, the worker exits.
But the timer does not launch until <code>tasks_timers</code> tasks
have completed.
See the <code>idletime</code> argument of <code>mirai::daemon()</code>. <code>crew</code> does not
excel with perfectly transient workers because it does not micromanage
the assignment of tasks to workers, so please allow enough idle
time for a new worker to be delegated a new task.</p>
</td></tr>
<tr><td><code id="crew_launcher_local_+3A_seconds_wall">seconds_wall</code></td>
<td>
<p>Soft wall time in seconds.
The timer does not launch until <code>tasks_timers</code> tasks
have completed.
See the <code>walltime</code> argument of <code>mirai::daemon()</code>.</p>
</td></tr>
<tr><td><code id="crew_launcher_local_+3A_seconds_exit">seconds_exit</code></td>
<td>
<p>Deprecated on 2023-09-21 in version 0.5.0.9002.
No longer necessary.</p>
</td></tr>
<tr><td><code id="crew_launcher_local_+3A_tasks_max">tasks_max</code></td>
<td>
<p>Maximum number of tasks that a worker will do before
exiting. See the <code>maxtasks</code> argument of <code>mirai::daemon()</code>.
<code>crew</code> does not
excel with perfectly transient workers because it does not micromanage
the assignment of tasks to workers, it is recommended to set
<code>tasks_max</code> to a value greater than 1.</p>
</td></tr>
<tr><td><code id="crew_launcher_local_+3A_tasks_timers">tasks_timers</code></td>
<td>
<p>Number of tasks to do before activating
the timers for <code>seconds_idle</code> and <code>seconds_wall</code>.
See the <code>timerstart</code> argument of <code>mirai::daemon()</code>.</p>
</td></tr>
<tr><td><code id="crew_launcher_local_+3A_reset_globals">reset_globals</code></td>
<td>
<p><code>TRUE</code> to reset global environment
variables between tasks, <code>FALSE</code> to leave them alone.</p>
</td></tr>
<tr><td><code id="crew_launcher_local_+3A_reset_packages">reset_packages</code></td>
<td>
<p><code>TRUE</code> to unload any packages loaded during
a task (runs between each task), <code>FALSE</code> to leave packages alone.</p>
</td></tr>
<tr><td><code id="crew_launcher_local_+3A_reset_options">reset_options</code></td>
<td>
<p><code>TRUE</code> to reset global options to their original
state between each task, <code>FALSE</code> otherwise. It is recommended to
only set <code>reset_options = TRUE</code> if <code>reset_packages</code> is also <code>TRUE</code>
because packages sometimes rely on options they set at loading time.</p>
</td></tr>
<tr><td><code id="crew_launcher_local_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p><code>TRUE</code> to run garbage collection between
tasks, <code>FALSE</code> to skip.</p>
</td></tr>
<tr><td><code id="crew_launcher_local_+3A_crashes_error">crashes_error</code></td>
<td>
<p>Deprecated on 2025-01-13 (<code>crew</code> version 0.10.2.9002).</p>
</td></tr>
<tr><td><code id="crew_launcher_local_+3A_launch_max">launch_max</code></td>
<td>
<p>Deprecated on 2024-11-04 (<code>crew</code> version 0.10.2.9002).
Use <code>crashes_error</code> instead.</p>
</td></tr>
<tr><td><code id="crew_launcher_local_+3A_tls">tls</code></td>
<td>
<p>A TLS configuration object from <code><a href="#topic+crew_tls">crew_tls()</a></code>.</p>
</td></tr>
<tr><td><code id="crew_launcher_local_+3A_r_arguments">r_arguments</code></td>
<td>
<p>Optional character vector of command line arguments
to pass to <code>Rscript</code> (non-Windows) or <code>Rscript.exe</code> (Windows)
when starting a worker. Example:
<code>r_arguments = c("--vanilla", "--max-connections=32")</code>.</p>
</td></tr>
<tr><td><code id="crew_launcher_local_+3A_options_metrics">options_metrics</code></td>
<td>
<p>Either <code>NULL</code> to opt out of resource metric logging
for workers, or an object from <code><a href="#topic+crew_options_metrics">crew_options_metrics()</a></code> to enable
and configure resource metric logging for workers.
For resource logging to run,
the <code>autometric</code> R package version 0.1.0 or higher
must be installed.</p>
</td></tr>
<tr><td><code id="crew_launcher_local_+3A_options_local">options_local</code></td>
<td>
<p>An object generated by <code><a href="#topic+crew_options_local">crew_options_local()</a></code>
with options specific to the local controller.</p>
</td></tr>
<tr><td><code id="crew_launcher_local_+3A_local_log_directory">local_log_directory</code></td>
<td>
<p>Deprecated on 2024-10-08. Use
<code>options_local</code> instead.</p>
</td></tr>
<tr><td><code id="crew_launcher_local_+3A_local_log_join">local_log_join</code></td>
<td>
<p>Deprecated on 2024-10-08. Use
<code>options_local</code> instead.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other plugin_local: 
<code><a href="#topic+crew_class_launcher_local">crew_class_launcher_local</a></code>,
<code><a href="#topic+crew_controller_local">crew_controller_local</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("CREW_EXAMPLES"), "true")) {
client &lt;- crew_client()
client$start()
launcher &lt;- crew_launcher_local(name = client$name)
launcher$start(url = client$url, profile = client$profile)
launcher$launch()
task &lt;- mirai::mirai("result", .compute = client$profile)
mirai::call_mirai_(task)
task$data
client$terminate()
}
</code></pre>

<hr>
<h2 id='crew_monitor_local'>Create a local monitor object.</h2><span id='topic+crew_monitor_local'></span>

<h3>Description</h3>

<p>Create an <code>R6</code> object to monitor local processes created by
<code>crew</code> and <code>mirai</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crew_monitor_local()
</code></pre>


<h3>See Also</h3>

<p>Other monitor: 
<code><a href="#topic+crew_class_monitor_local">crew_class_monitor_local</a></code>
</p>

<hr>
<h2 id='crew_options_local'>Local <code>crew</code> launcher options.</h2><span id='topic+crew_options_local'></span>

<h3>Description</h3>

<p>Options for the local <code>crew</code> launcher.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crew_options_local(log_directory = NULL, log_join = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crew_options_local_+3A_log_directory">log_directory</code></td>
<td>
<p>Either <code>NULL</code> or a character of length 1
with the file path to a directory to write worker-specific log files
with standard output and standard error messages.
Each log file represents a single <em>instance</em> of a running worker,
so there will be more log files
if a given worker starts and terminates a lot. Set to <code>NULL</code> to suppress
log files (default).</p>
</td></tr>
<tr><td><code id="crew_options_local_+3A_log_join">log_join</code></td>
<td>
<p>Logical of length 1. If <code>TRUE</code>, <code>crew</code> will write
standard output and standard error to the same log file for
each worker instance. If <code>FALSE</code>, then they these two streams
will go to different log files with informative suffixes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A classed list of options for the local launcher.
</p>


<h3>See Also</h3>

<p>Other options: 
<code><a href="#topic+crew_options_metrics">crew_options_metrics</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  crew_options_local()
</code></pre>

<hr>
<h2 id='crew_options_metrics'>Options for logging resource usage metrics.</h2><span id='topic+crew_options_metrics'></span>

<h3>Description</h3>

<p><code><a href="#topic+crew_options_metrics">crew_options_metrics()</a></code> configures the
<code>crew</code> to record resource usage metrics (such as CPU and memory usage)
for each running worker.
To be activate resource usage logging,
the <code>autometric</code> R package version 0.1.0 or higher
must be installed.
</p>
<p>Logging happens in the background (through a detached POSIX)
so as not to disrupt
the R session. On Unix-like systems, <code><a href="#topic+crew_options_metrics">crew_options_metrics()</a></code>
can specify <code style="white-space: pre;">&#8288;/dev/stdout&#8288;</code> or <code style="white-space: pre;">&#8288;/dev/stderr&#8288;</code> as the log files, which will
redirect output to existing logs you are already using.
<code><a href="autometric.html#topic+log_read">autometric::log_read()</a></code> and <code><a href="autometric.html#topic+log_plot">autometric::log_plot()</a></code> can read and
visualize resource usage data from multiple log files, even
if those files are mixed with other messages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crew_options_metrics(path = NULL, seconds_interval = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crew_options_metrics_+3A_path">path</code></td>
<td>
<p>Where to write resource metric log entries for workers.
<code>path = NULL</code> disables logging. <code>path</code> equal to <code>"/dev/stdout"</code>
(or <code>"/dev/stderr"</code>) sends log messages to the standard output
(or standard error) streams, which is recommended on Unix-like systems
because then output will go to the existing log files already
configured for the
controller, e.g. through <code><a href="#topic+crew_options_local">crew_options_local()</a></code> in the case of
<code><a href="#topic+crew_controller_local">crew_controller_local()</a></code>. If <code>path</code> is not <code>NULL</code>, <code>"/dev/stdout"</code>, or
<code>"/dev/stderr"</code>, it should be a directory path,
in which case each worker instance will write to a new file in that
directory.
</p>
<p>After running enough tasks in <code>crew</code>, you can call
<code>autometric::log_read(path)</code> to read all the data from all the log
files in the files or directories at <code>path</code>,
even if the logs files are mixed with other kinds of messages.
Pass that data into <code><a href="autometric.html#topic+log_plot">autometric::log_plot()</a></code> to visualize it.</p>
</td></tr>
<tr><td><code id="crew_options_metrics_+3A_seconds_interval">seconds_interval</code></td>
<td>
<p>Positive number, seconds between resource metric
log entries written to <code>path</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A classed list of options for logging resource usage metrics.
</p>


<h3>See Also</h3>

<p>Other options: 
<code><a href="#topic+crew_options_local">crew_options_local</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  crew_options_metrics()
</code></pre>

<hr>
<h2 id='crew_queue'>Create a <code>crew</code> queue object.</h2><span id='topic+crew_queue'></span>

<h3>Description</h3>

<p>Create an <code>R6</code> <code>crew</code> queue object for resolved task names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crew_queue()
</code></pre>


<h3>Details</h3>

<p>A <code>crew</code> queue object efficiently tracks the names of resolved
tasks so the controller can pop them efficiently.
</p>


<h3>See Also</h3>

<p>Other queue: 
<code><a href="#topic+crew_class_queue">crew_class_queue</a></code>
</p>

<hr>
<h2 id='crew_random_name'>Random name</h2><span id='topic+crew_random_name'></span>

<h3>Description</h3>

<p>Generate a random string that can be used as a name
for a worker or task.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crew_random_name(n = 12L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crew_random_name_+3A_n">n</code></td>
<td>
<p>Number of bytes of information in the random string
hashed to generate the name. Larger <code>n</code> is
more likely to generate unique names, but it may be slower to compute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The randomness is not reproducible and cannot be set with
e.g. <code>set.seed()</code> in R.
</p>


<h3>Value</h3>

<p>A random character string.
</p>


<h3>See Also</h3>

<p>Other utility: 
<code><a href="#topic+crew_assert">crew_assert</a>()</code>,
<code><a href="#topic+crew_clean">crew_clean</a>()</code>,
<code><a href="#topic+crew_deprecate">crew_deprecate</a>()</code>,
<code><a href="#topic+crew_eval">crew_eval</a>()</code>,
<code><a href="#topic+crew_retry">crew_retry</a>()</code>,
<code><a href="#topic+crew_terminate_process">crew_terminate_process</a>()</code>,
<code><a href="#topic+crew_terminate_signal">crew_terminate_signal</a>()</code>,
<code><a href="#topic+crew_worker">crew_worker</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>crew_random_name()
</code></pre>

<hr>
<h2 id='crew_relay'>Create a <code>crew</code> relay object.</h2><span id='topic+crew_relay'></span>

<h3>Description</h3>

<p>Create an <code>R6</code> <code>crew</code> relay object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crew_relay()
</code></pre>


<h3>Details</h3>

<p>A <code>crew</code> relay object keeps the signaling relationships
among condition variables.
</p>


<h3>Value</h3>

<p>An <code>R6</code> <code>crew</code> relay object.
</p>


<h3>See Also</h3>

<p>Other relay: 
<code><a href="#topic+crew_class_relay">crew_class_relay</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>crew_relay()
</code></pre>

<hr>
<h2 id='crew_retry'>Retry code.</h2><span id='topic+crew_retry'></span>

<h3>Description</h3>

<p>Repeatedly retry a function while it keeps returning <code>FALSE</code>
and exit the loop when it returns <code>TRUE</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crew_retry(
  fun,
  args = list(),
  seconds_interval = 1,
  seconds_timeout = 60,
  max_tries = Inf,
  error = TRUE,
  message = character(0),
  envir = parent.frame(),
  assertions = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crew_retry_+3A_fun">fun</code></td>
<td>
<p>Function that returns <code>FALSE</code> to keep waiting
or <code>TRUE</code> to stop waiting.</p>
</td></tr>
<tr><td><code id="crew_retry_+3A_args">args</code></td>
<td>
<p>A named list of arguments to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="crew_retry_+3A_seconds_interval">seconds_interval</code></td>
<td>
<p>Nonnegative numeric of length 1,
number of seconds to wait between calls to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="crew_retry_+3A_seconds_timeout">seconds_timeout</code></td>
<td>
<p>Nonnegative numeric of length 1,
number of seconds to loop before timing out.</p>
</td></tr>
<tr><td><code id="crew_retry_+3A_max_tries">max_tries</code></td>
<td>
<p>Maximum number of calls to <code>fun</code> to try
before giving up.</p>
</td></tr>
<tr><td><code id="crew_retry_+3A_error">error</code></td>
<td>
<p>Whether to throw an error on a timeout or max tries.</p>
</td></tr>
<tr><td><code id="crew_retry_+3A_message">message</code></td>
<td>
<p>Character of length 1, optional error message
if the wait times out.</p>
</td></tr>
<tr><td><code id="crew_retry_+3A_envir">envir</code></td>
<td>
<p>Environment to evaluate <code>fun</code>.</p>
</td></tr>
<tr><td><code id="crew_retry_+3A_assertions">assertions</code></td>
<td>
<p><code>TRUE</code> to run assertions to check if arguments are
valid, <code>FALSE</code> otherwise. <code>TRUE</code> is recommended for users.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> (invisibly).
</p>


<h3>See Also</h3>

<p>Other utility: 
<code><a href="#topic+crew_assert">crew_assert</a>()</code>,
<code><a href="#topic+crew_clean">crew_clean</a>()</code>,
<code><a href="#topic+crew_deprecate">crew_deprecate</a>()</code>,
<code><a href="#topic+crew_eval">crew_eval</a>()</code>,
<code><a href="#topic+crew_random_name">crew_random_name</a>()</code>,
<code><a href="#topic+crew_terminate_process">crew_terminate_process</a>()</code>,
<code><a href="#topic+crew_terminate_signal">crew_terminate_signal</a>()</code>,
<code><a href="#topic+crew_worker">crew_worker</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>crew_retry(fun = function() TRUE)
</code></pre>

<hr>
<h2 id='crew_terminate_process'>Manually terminate a local process.</h2><span id='topic+crew_terminate_process'></span>

<h3>Description</h3>

<p>Manually terminate a local process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crew_terminate_process(pid)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crew_terminate_process_+3A_pid">pid</code></td>
<td>
<p>Integer of length 1, process ID to terminate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> (invisibly).
</p>


<h3>See Also</h3>

<p>Other utility: 
<code><a href="#topic+crew_assert">crew_assert</a>()</code>,
<code><a href="#topic+crew_clean">crew_clean</a>()</code>,
<code><a href="#topic+crew_deprecate">crew_deprecate</a>()</code>,
<code><a href="#topic+crew_eval">crew_eval</a>()</code>,
<code><a href="#topic+crew_random_name">crew_random_name</a>()</code>,
<code><a href="#topic+crew_retry">crew_retry</a>()</code>,
<code><a href="#topic+crew_terminate_signal">crew_terminate_signal</a>()</code>,
<code><a href="#topic+crew_worker">crew_worker</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("CREW_EXAMPLES"), "true")) {
process &lt;- processx::process$new("sleep", "60")
process$is_alive()
crew_terminate_process(pid = process$get_pid())
process$is_alive()
}
</code></pre>

<hr>
<h2 id='crew_terminate_signal'>Get the termination signal.</h2><span id='topic+crew_terminate_signal'></span>

<h3>Description</h3>

<p>Get a supported operating system signal for terminating
a local process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crew_terminate_signal()
</code></pre>


<h3>Value</h3>

<p>An integer of length 1: <code>tools::SIGTERM</code> if your platform
supports <code>SIGTERM</code>. If not, then <code>crew_crew_terminate_signal()()</code> checks
<code>SIGQUIT</code>, then <code>SIGINT</code>, then <code>SIGKILL</code>, and then returns the first
signal it finds that your operating system can use.
</p>


<h3>See Also</h3>

<p>Other utility: 
<code><a href="#topic+crew_assert">crew_assert</a>()</code>,
<code><a href="#topic+crew_clean">crew_clean</a>()</code>,
<code><a href="#topic+crew_deprecate">crew_deprecate</a>()</code>,
<code><a href="#topic+crew_eval">crew_eval</a>()</code>,
<code><a href="#topic+crew_random_name">crew_random_name</a>()</code>,
<code><a href="#topic+crew_retry">crew_retry</a>()</code>,
<code><a href="#topic+crew_terminate_process">crew_terminate_process</a>()</code>,
<code><a href="#topic+crew_worker">crew_worker</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>crew_terminate_signal()
</code></pre>

<hr>
<h2 id='crew_throttle'>Create a stateful throttling object.</h2><span id='topic+crew_throttle'></span>

<h3>Description</h3>

<p>Create an <code>R6</code> object for throttling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crew_throttle(
  seconds_max = 1,
  seconds_min = 0.001,
  seconds_start = seconds_min,
  base = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crew_throttle_+3A_seconds_max">seconds_max</code></td>
<td>
<p>Positive numeric scalar, maximum throttling interval</p>
</td></tr>
<tr><td><code id="crew_throttle_+3A_seconds_min">seconds_min</code></td>
<td>
<p>Positive numeric scalar, minimum throttling interval.</p>
</td></tr>
<tr><td><code id="crew_throttle_+3A_seconds_start">seconds_start</code></td>
<td>
<p>Positive numeric scalar,
the initial wait time interval in seconds.
The default is <code>min</code> because there is almost always
auto-scaling to be done when the controller is created.
<code>reset()</code> always sets the current wait interval back to <code>seconds_start</code>.</p>
</td></tr>
<tr><td><code id="crew_throttle_+3A_base">base</code></td>
<td>
<p>Numeric scalar greater than 1, base of the exponential
backoff algorithm. <code>increment()</code> multiplies the waiting interval by
<code>base</code> and <code>decrement()</code> divides the waiting interval by <code>base</code>.
The default <code>base</code> is 2, which specifies a binary exponential
backoff algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Throttling is a technique that limits how often a function is
called in a given period of time. <code><a href="#topic+crew_throttle">crew_throttle()</a></code> objects support
the <code>throttle</code> argument of controller methods, which ensures auto-scaling
does not induce superfluous overhead.
The throttle uses deterministic exponential backoff algorithm
(<a href="https://en.wikipedia.org/wiki/Exponential_backoff">https://en.wikipedia.org/wiki/Exponential_backoff</a>) which
increases wait times when there is nothing to do and decreases
wait times when there is something to do. The controller decreases
or increases the wait time with methods <code>accelerate()</code> and <code>decelerate()</code>
in the throttle object, respectively,
by dividing or multiplying by <code>base</code> (but keeping the wait time
between <code>seconds_min</code> and <code>seconds_max</code>).
In practice, <code>crew</code> calls <code>reset()</code> instead of <code>update()</code>
in order to respond quicker to surges of activity (see the
<code>update()</code> method).
</p>


<h3>Value</h3>

<p>An <code>R6</code> object with throttle configuration settings and methods.
</p>


<h3>See Also</h3>

<p>Other throttle: 
<code><a href="#topic+crew_class_throttle">crew_class_throttle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>throttle &lt;- crew_throttle(seconds_max = 1)
throttle$poll()
throttle$poll()
</code></pre>

<hr>
<h2 id='crew_tls'>Configure TLS.</h2><span id='topic+crew_tls'></span>

<h3>Description</h3>

<p>Create an <code>R6</code> object with transport layer security (TLS)
configuration for <code>crew</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crew_tls(
  mode = "none",
  key = NULL,
  password = NULL,
  certificates = NULL,
  validate = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crew_tls_+3A_mode">mode</code></td>
<td>
<p>Character of length 1. Must be one of the following:
</p>

<ul>
<li> <p><code>"none"</code>: disable TLS configuration.
</p>
</li>
<li> <p><code>"automatic"</code>: let <code>mirai</code> create a one-time key pair with a
self-signed certificate.
</p>
</li>
<li> <p><code>"custom"</code>: manually supply a private key pair, an optional
password for the private key, a certificate,
an optional revocation list.
</p>
</li></ul>
</td></tr>
<tr><td><code id="crew_tls_+3A_key">key</code></td>
<td>
<p>If <code>mode</code> is <code>"none"</code> or <code>"automatic"</code>, then <code>key</code> is <code>NULL</code>.
If <code>mode</code> is <code>"custom"</code>, then <code>key</code> is a character of length 1
with the file path to the private key file.</p>
</td></tr>
<tr><td><code id="crew_tls_+3A_password">password</code></td>
<td>
<p>If <code>mode</code> is <code>"none"</code> or <code>"automatic"</code>,
then <code>password</code> is <code>NULL</code>.
If <code>mode</code> is <code>"custom"</code> and the private key is not encrypted, then
<code>password</code> is still <code>NULL</code>.
If <code>mode</code> is <code>"custom"</code> and the private key is encrypted,
then <code>password</code> is a character of length 1 the the password of the private
key. In this case, DO NOT SAVE THE PASSWORD IN YOUR R CODE FILES.
See the <code>keyring</code> R package for solutions.</p>
</td></tr>
<tr><td><code id="crew_tls_+3A_certificates">certificates</code></td>
<td>
<p>If <code>mode</code> is <code>"none"</code> or <code>"automatic"</code>,
then <code>certificates</code> is <code>NULL</code>.
If <code>mode</code> is <code>"custom"</code>, then <code>certificates</code> is a character vector
of file paths to certificate files (signed public keys).
If the certificate is self-signed or if it is
directly signed by a certificate authority (CA),
then only the certificate of the CA is needed. But if you have a whole
certificate chain which begins at your own certificate and ends with the
CA, then you can supply the whole certificate chain as a character vector
which begins at your own certificate and ends with
the certificate of the CA.</p>
</td></tr>
<tr><td><code id="crew_tls_+3A_validate">validate</code></td>
<td>
<p>Logical of length 1, whether to validate the configuration
object on creation. If <code>FALSE</code>, then <code>validate()</code> can be called later on.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+crew_tls">crew_tls()</a></code> objects are input to the <code>tls</code> argument of
<code><a href="#topic+crew_client">crew_client()</a></code>, <code><a href="#topic+crew_controller_local">crew_controller_local()</a></code>, etc.
See <a href="https://wlandau.github.io/crew/articles/risks.html">https://wlandau.github.io/crew/articles/risks.html</a> for details.
</p>


<h3>Value</h3>

<p>An <code>R6</code> object with TLS configuration settings and methods.
</p>


<h3>See Also</h3>

<p>Other tls: 
<code><a href="#topic+crew_class_tls">crew_class_tls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>crew_tls(mode = "automatic")
</code></pre>

<hr>
<h2 id='crew_worker'>Crew worker.</h2><span id='topic+crew_worker'></span>

<h3>Description</h3>

<p>Launches a <code>crew</code> worker which runs a <code>mirai</code> daemon.
Not a user-side function. Users should not call <code><a href="#topic+crew_worker">crew_worker()</a></code>
directly. See launcher plugins like <code><a href="#topic+crew_launcher_local">crew_launcher_local()</a></code>
for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crew_worker(
  settings,
  launcher,
  worker,
  options_metrics = crew::crew_options_metrics()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crew_worker_+3A_settings">settings</code></td>
<td>
<p>Named list of arguments to <code>mirai::daemon()</code>.</p>
</td></tr>
<tr><td><code id="crew_worker_+3A_launcher">launcher</code></td>
<td>
<p>Character string, name of the launcher</p>
</td></tr>
<tr><td><code id="crew_worker_+3A_worker">worker</code></td>
<td>
<p>Character of length 1 to uniquely identify the current worker.</p>
</td></tr>
<tr><td><code id="crew_worker_+3A_options_metrics">options_metrics</code></td>
<td>
<p>Either <code>NULL</code> to opt out of resource metric logging
for workers, or an object from <code><a href="#topic+crew_options_metrics">crew_options_metrics()</a></code> to enable
and configure resource metric logging for workers.
For resource logging to run,
the <code>autometric</code> R package version 0.1.0 or higher
must be installed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> (invisibly)
</p>


<h3>See Also</h3>

<p>Other utility: 
<code><a href="#topic+crew_assert">crew_assert</a>()</code>,
<code><a href="#topic+crew_clean">crew_clean</a>()</code>,
<code><a href="#topic+crew_deprecate">crew_deprecate</a>()</code>,
<code><a href="#topic+crew_eval">crew_eval</a>()</code>,
<code><a href="#topic+crew_random_name">crew_random_name</a>()</code>,
<code><a href="#topic+crew_retry">crew_retry</a>()</code>,
<code><a href="#topic+crew_terminate_process">crew_terminate_process</a>()</code>,
<code><a href="#topic+crew_terminate_signal">crew_terminate_signal</a>()</code>
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+all_of'></span><span id='topic+any_of'></span><span id='topic+contains'></span><span id='topic+ends_with'></span><span id='topic+everything'></span><span id='topic+last_col'></span><span id='topic+matches'></span><span id='topic+num_range'></span><span id='topic+one_of'></span><span id='topic+starts_with'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>tidyselect</dt><dd><p><code><a href="tidyselect.html#topic+all_of">all_of</a></code>, <code><a href="tidyselect.html#topic+all_of">any_of</a></code>, <code><a href="tidyselect.html#topic+starts_with">contains</a></code>, <code><a href="tidyselect.html#topic+starts_with">ends_with</a></code>, <code><a href="tidyselect.html#topic+everything">everything</a></code>, <code><a href="tidyselect.html#topic+everything">last_col</a></code>, <code><a href="tidyselect.html#topic+starts_with">matches</a></code>, <code><a href="tidyselect.html#topic+starts_with">num_range</a></code>, <code><a href="tidyselect.html#topic+one_of">one_of</a></code>, <code><a href="tidyselect.html#topic+starts_with">starts_with</a></code></p>
</dd>
</dl>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
