<!DOCTYPE html><html lang="en-US"><head><title>Help for package babelmixr2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {babelmixr2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.popedCluster'><p>Internal function to use with PopED to run PopED in parallel on Windows</p></a></li>
<li><a href='#.popedF'><p>Get the function value from the rxode2 solve</p></a></li>
<li><a href='#.popedFree'><p>Free Poped memory (if any is allocated)</p></a></li>
<li><a href='#.popedRxRunSetup'><p>Setup poped if needed</p></a></li>
<li><a href='#.popedSetup'><p>Setup the PopED environment</p></a></li>
<li><a href='#.popedSolveIdME'><p>Solve poped problem for appropriate times with single/multiple endpoint models</p></a></li>
<li><a href='#.popedW'><p>Get the weight from the rxode2 solve</p></a></li>
<li><a href='#.setupPopEDdatabase'><p>Setup the poped database</p></a></li>
<li><a href='#as.nlmixr2'><p>Convert an object to a nlmixr2 fit object</p></a></li>
<li><a href='#babel.poped.database'><p>Expand a babelmixr2 PopED database</p></a></li>
<li><a href='#babelBpopIdx'><p>Get the bpop_idx by variable name for a poped database created by <code>babelmixr2</code></p></a></li>
<li><a href='#bblDatToMonolix'><p>Convert nlmixr2-compatible data to other formats (if possible)</p></a></li>
<li><a href='#getStandardColNames'><p>Determine standardized rxode2 column names from data</p></a></li>
<li><a href='#modelUnitConversion'><p>Unit conversion for pharmacokinetic models</p></a></li>
<li><a href='#monolixControl'><p>Monolix Controller for nlmixr2</p></a></li>
<li><a href='#nlmixr2Est.pknca'><p>Estimate starting parameters using PKNCA</p></a></li>
<li><a href='#nmGetDistributionMonolixLines'><p>This is a S3 method for getting the distribution lines for a base rxode2 saem problem</p></a></li>
<li><a href='#nmGetDistributionNonmemLines'><p>This is a S3 method for getting the distribution lines for a base rxode2 saem problem</p></a></li>
<li><a href='#nonmemControl'><p>NONMEM estimation control</p></a></li>
<li><a href='#pkncaControl'><p>PKNCA estimation control</p></a></li>
<li><a href='#popedControl'><p>Control for a PopED design task</p></a></li>
<li><a href='#popedGetMultipleEndpointModelingTimes'><p>Get Multiple Endpoint Modeling Times</p></a></li>
<li><a href='#popedMultipleEndpointParam'><p>Populates Multiple Endpoint Parameters for internal solving</p></a></li>
<li><a href='#popedMultipleEndpointResetTimeIndex'><p>Reset the Global Time Indexer for Multiple Endpoint Modeling</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rxToMonolix'><p>Convert RxODE syntax to monolix syntax</p></a></li>
<li><a href='#rxToNonmem'><p>Convert RxODE syntax to NONMEM syntax</p></a></li>
<li><a href='#simplifyUnit'><p>Simplify units by removing repeated units from the numerator and denominator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Use 'nlmixr2' to Interact with Open Source and Commercial
Software</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Run other estimation and simulation software via the 'nlmixr2' (Fidler et al (2019)
  &lt;<a href="https://doi.org/10.1002%2Fpsp4.12445">doi:10.1002/psp4.12445</a>&gt;) interface including 'PKNCA', 'NONMEM' and 'Monolix'. While not required, you can
  get/install the 'lixoftConnectors' package in the 'Monolix' installation, as
  described at the following url
  <a href="https://monolixsuite.slp-software.com/r-functions/2024R1/installation-and-initialization">https://monolixsuite.slp-software.com/r-functions/2024R1/installation-and-initialization</a>. When
  'lixoftConnectors' is available, 'Monolix' can be run directly instead of setting up
  command line usage.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://nlmixr2.github.io/babelmixr2/">https://nlmixr2.github.io/babelmixr2/</a>,
<a href="https://github.com/nlmixr2/babelmixr2/">https://github.com/nlmixr2/babelmixr2/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, nlmixr2data, withr, lixoftConnectors, PKNCA (&ge;
0.10.0), rmarkdown, spelling, PopED, units, vdiffr, dplyr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), nlmixr2 (&ge; 3.0.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, cli, digest, lotri, nlmixr2est (&ge; 3.0.1),
nonmem2rx (&ge; 0.1.5), monolix2rx (&ge; 0.0.3), methods, qs, rex,
rxode2 (&ge; 3.0.2)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, rxode2, RcppArmadillo, RcppEigen</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-19 14:38:34 UTC; matt</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew Fidler <a href="https://orcid.org/0000-0001-8538-6691"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Bill Denney <a href="https://orcid.org/0000-0002-5759-428X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Theodoros Papathanasiou [ctb],
  Nook Fulloption [ctb] (goldfish art)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew Fidler &lt;matthew.fidler@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-20 10:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='.popedCluster'>Internal function to use with PopED to run PopED in parallel on Windows</h2><span id='topic+.popedCluster'></span>

<h3>Description</h3>

<p>Internal function to use with PopED to run PopED in parallel on Windows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.popedCluster(babelmixr2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".popedCluster_+3A_babelmixr2">babelmixr2</code></td>
<td>
<p>environment in poped environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.popedF'>Get the function value from the rxode2 solve</h2><span id='topic+.popedF'></span>

<h3>Description</h3>

<p>This shouldn't be called directly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.popedF(popedDb)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".popedF_+3A_popeddb">popedDb</code></td>
<td>
<p>poped DB with babelmixr2 issue</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rxode2 weights for the poped error function
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.popedFree'>Free Poped memory (if any is allocated)</h2><span id='topic+.popedFree'></span>

<h3>Description</h3>

<p>This should not be called directly but is used in babelmixr2's
poped interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.popedFree()
</code></pre>


<h3>Value</h3>

<p>nothing, called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.popedRxRunSetup'>Setup poped if needed</h2><span id='topic+.popedRxRunSetup'></span>

<h3>Description</h3>

<p>Should not be called by user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.popedRxRunSetup(popedDb)
</code></pre>


<h3>Value</h3>

<p>nothing, called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.popedSetup'>Setup the PopED environment</h2><span id='topic+.popedSetup'></span>

<h3>Description</h3>

<p>This should not typically be called directly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.popedSetup(e, eglobal, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".popedSetup_+3A_e">e</code></td>
<td>
<p>environment with setup information for popEd</p>
</td></tr>
<tr><td><code id=".popedSetup_+3A_eglobal">eglobal</code></td>
<td>
<p>global environment for poped info</p>
</td></tr>
<tr><td><code id=".popedSetup_+3A_full">full</code></td>
<td>
<p>setup the full model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.popedSolveIdME'>Solve poped problem for appropriate times with single/multiple endpoint models</h2><span id='topic+.popedSolveIdME'></span><span id='topic+.popedSolveIdME2'></span>

<h3>Description</h3>

<p>This really should not be called directly (if not setup correctly
can crash R)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.popedSolveIdME(theta, umt, mt, ms, nend, id, totn)

.popedSolveIdME2(theta, umt, mt, ms, nend, id, totn)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".popedSolveIdME_+3A_theta">theta</code></td>
<td>
<p>parameters (includes covariates and modeling times)</p>
</td></tr>
<tr><td><code id=".popedSolveIdME_+3A_umt">umt</code></td>
<td>
<p>unique times sampled</p>
</td></tr>
<tr><td><code id=".popedSolveIdME_+3A_mt">mt</code></td>
<td>
<p>original unsorted time (to match the f/w against)</p>
</td></tr>
<tr><td><code id=".popedSolveIdME_+3A_ms">ms</code></td>
<td>
<p>model switch parameter integer starting with 1 (related to dvid in rxode2)</p>
</td></tr>
<tr><td><code id=".popedSolveIdME_+3A_nend">nend</code></td>
<td>
<p>specifies the number of endpoints in this model</p>
</td></tr>
<tr><td><code id=".popedSolveIdME_+3A_id">id</code></td>
<td>
<p>this is the design identifier</p>
</td></tr>
<tr><td><code id=".popedSolveIdME_+3A_totn">totn</code></td>
<td>
<p>This is the total number of design points tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with $f and $w corresponding to the function
value and standard deviation at the sampling point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.popedW'>Get the weight from the rxode2 solve</h2><span id='topic+.popedW'></span>

<h3>Description</h3>

<p>This shouldn't be called directly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.popedW(popedDb)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".popedW_+3A_popeddb">popedDb</code></td>
<td>
<p>poped DB with babelmixr2 issue</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rxode2 weights for the poped error function
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.setupPopEDdatabase'>Setup the poped database</h2><span id='topic+.setupPopEDdatabase'></span>

<h3>Description</h3>

<p>Setup the poped database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.setupPopEDdatabase(ui, data, control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".setupPopEDdatabase_+3A_ui">ui</code></td>
<td>
<p>rxode2 ui function</p>
</td></tr>
<tr><td><code id=".setupPopEDdatabase_+3A_data">data</code></td>
<td>
<p>babelmixr2 design data</p>
</td></tr>
<tr><td><code id=".setupPopEDdatabase_+3A_control">control</code></td>
<td>
<p>PopED control</p>
</td></tr>
</table>


<h3>Value</h3>

<p>PopED database
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='as.nlmixr2'>Convert an object to a nlmixr2 fit object</h2><span id='topic+as.nlmixr2'></span><span id='topic+as.nlmixr'></span>

<h3>Description</h3>

<p>Convert an object to a nlmixr2 fit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.nlmixr2(
  x,
  ...,
  table = nlmixr2est::tableControl(),
  rxControl = rxode2::rxControl(),
  ci = 0.95
)

as.nlmixr(
  x,
  ...,
  table = nlmixr2est::tableControl(),
  rxControl = rxode2::rxControl(),
  ci = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.nlmixr2_+3A_x">x</code></td>
<td>
<p>Object to convert</p>
</td></tr>
<tr><td><code id="as.nlmixr2_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
<tr><td><code id="as.nlmixr2_+3A_table">table</code></td>
<td>
<p>is the <code>nlmixr2est::tableControl()</code> options</p>
</td></tr>
<tr><td><code id="as.nlmixr2_+3A_rxcontrol">rxControl</code></td>
<td>
<p>is the <code>rxode2::rxControl()</code> options, which is
generally needed for how <code>addl</code> doses are handled in the
translation</p>
</td></tr>
<tr><td><code id="as.nlmixr2_+3A_ci">ci</code></td>
<td>
<p>is the confidence interval of the residual differences
calculated (by default 0.95)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nlmixr2 fit object
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# First read in the model (but without residuals)
mod &lt;- nonmem2rx(system.file("mods/cpt/runODE032.ctl", package="nonmem2rx"),
                 determineError=FALSE, lst=".res", save=FALSE)

# define the model with residuals (and change the name of the
# parameters) In this step you need to be careful to not change the
# estimates and make sure the residual estimates are correct (could
# have to change var to sd).

 mod2 &lt;-function() {
   ini({
     lcl &lt;- 1.37034036528946
     lvc &lt;- 4.19814911033061
     lq &lt;- 1.38003493562413
     lvp &lt;- 3.87657341967489
     RSV &lt;- c(0, 0.196446108190896, 1)
     eta.cl ~ 0.101251418415006
     eta.v ~ 0.0993872449483344
     eta.q ~ 0.101302674763154
     eta.v2 ~ 0.0730497519364148
   })
   model({
     cmt(CENTRAL)
     cmt(PERI)
     cl &lt;- exp(lcl + eta.cl)
     v &lt;- exp(lvc + eta.v)
     q &lt;- exp(lq + eta.q)
     v2 &lt;- exp(lvp + eta.v2)
     v1 &lt;- v
     scale1 &lt;- v
     k21 &lt;- q/v2
     k12 &lt;- q/v
     d/dt(CENTRAL) &lt;- k21 * PERI - k12 * CENTRAL - cl * CENTRAL/v1
     d/dt(PERI) &lt;- -k21 * PERI + k12 * CENTRAL
     f &lt;- CENTRAL/scale1
     f ~ prop(RSV)
   })
 }

# now we create another nonmem2rx object that validates the model above:

new &lt;- as.nonmem2rx(mod2, mod)

# once that is done, you can translate to a full nlmixr2 fit (if you wish)

fit &lt;- as.nlmixr2(new)

print(fit)


</code></pre>

<hr>
<h2 id='babel.poped.database'>Expand a babelmixr2 PopED database</h2><span id='topic+babel.poped.database'></span>

<h3>Description</h3>

<p>Expand a babelmixr2 PopED database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>babel.poped.database(popedInput, ..., optTime = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="babel.poped.database_+3A_popedinput">popedInput</code></td>
<td>
<p>The babelmixr2 generated PopED database</p>
</td></tr>
<tr><td><code id="babel.poped.database_+3A_...">...</code></td>
<td>
<p>other parameters sent to <code>PopED::create.poped.database()</code></p>
</td></tr>
<tr><td><code id="babel.poped.database_+3A_opttime">optTime</code></td>
<td>
<p>boolean to indicate if the global time indexer
inside of babelmixr2 is reset if the times are different. By
default this is <code>TRUE</code>.  If <code>FALSE</code> you can get slightly better
run times and possibly slightly different results.  When
<code>optTime</code> is <code>FALSE</code> the global indexer is reset every time the
PopED rxode2 is setup for a problem or when a poped dataset is
created.  You can manually reset with
<code>popedMultipleEndpointResetTimeIndex()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>babelmixr2 PopED database (with $babelmixr2 in database)
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='babelBpopIdx'>Get the bpop_idx by variable name for a poped database created by <code>babelmixr2</code></h2><span id='topic+babelBpopIdx'></span>

<h3>Description</h3>

<p>This may work for other poped databases if the population parameters are named.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>babelBpopIdx(popedInput, var)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="babelBpopIdx_+3A_popedinput">popedInput</code></td>
<td>
<p>The babelmixr2 created database</p>
</td></tr>
<tr><td><code id="babelBpopIdx_+3A_var">var</code></td>
<td>
<p>variable to query</p>
</td></tr>
</table>


<h3>Value</h3>

<p>index of the variable
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("PopED", quietly=TRUE)) {

f &lt;- function() {
  ini({
    tV &lt;- 72.8
    tKa &lt;- 0.25
    tCl &lt;- 3.75
    tF &lt;- fix(0.9)
    pedCL &lt;- 0.8

    eta.v ~ 0.09
    eta.ka ~ 0.09
    eta.cl ~0.25^2

    prop.sd &lt;- fix(sqrt(0.04))
    add.sd &lt;- fix(sqrt(5e-6))

  })
  model({
    V&lt;-tV*exp(eta.v)
    KA&lt;-tKa*exp(eta.ka) * (pedCL**isPediatric) # add covariate for pediatrics
    CL&lt;-tCl*exp(eta.cl)
    Favail &lt;- tF

    N &lt;-  floor(t/TAU)+1
    y &lt;- (DOSE*Favail/V)*(KA/(KA - CL/V)) *
      (exp(-CL/V * (t - (N - 1) * TAU)) *
         (1 - exp(-N * CL/V * TAU))/(1 - exp(-CL/V * TAU)) -
         exp(-KA * (t - (N - 1) * TAU)) * (1 - exp(-N * KA * TAU))/(1 - exp(-KA * TAU)))

    y ~ prop(prop.sd) + add(add.sd)
  })
}

e &lt;- et(c( 1,8,10,240,245))

babel.db &lt;- nlmixr2(f, e, "poped",
                    popedControl(m = 2,
                                 groupsize=20,
                                 bUseGrouped_xt=TRUE,
                                 a=list(c(DOSE=20,TAU=24,isPediatric = 0),
                                        c(DOSE=40, TAU=24,isPediatric = 0))))

babelBpopIdx(babel.db, "pedCL")

}
</code></pre>

<hr>
<h2 id='bblDatToMonolix'>Convert nlmixr2-compatible data to other formats (if possible)</h2><span id='topic+bblDatToMonolix'></span><span id='topic+bblDatToNonmem'></span><span id='topic+bblDatToRxode'></span><span id='topic+bblDatToMrgsolve'></span><span id='topic+bblDatToPknca'></span>

<h3>Description</h3>

<p>Convert nlmixr2-compatible data to other formats (if possible)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bblDatToMonolix(
  model,
  data,
  table = nlmixr2est::tableControl(),
  rxControl = rxode2::rxControl(),
  env = NULL
)

bblDatToNonmem(
  model,
  data,
  table = nlmixr2est::tableControl(),
  rxControl = rxode2::rxControl(),
  env = NULL
)

bblDatToRxode(
  model,
  data,
  table = nlmixr2est::tableControl(),
  rxControl = rxode2::rxControl(),
  env = NULL
)

bblDatToMrgsolve(
  model,
  data,
  table = nlmixr2est::tableControl(),
  rxControl = rxode2::rxControl(),
  env = NULL
)

bblDatToPknca(
  model,
  data,
  table = nlmixr2est::tableControl(),
  rxControl = rxode2::rxControl(),
  env = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bblDatToMonolix_+3A_model">model</code></td>
<td>
<p>rxode2 model for conversion</p>
</td></tr>
<tr><td><code id="bblDatToMonolix_+3A_data">data</code></td>
<td>
<p>Input dataset.</p>
</td></tr>
<tr><td><code id="bblDatToMonolix_+3A_table">table</code></td>
<td>
<p>is the table control; this is mostly to figure out if
there are additional columns to keep.</p>
</td></tr>
<tr><td><code id="bblDatToMonolix_+3A_rxcontrol">rxControl</code></td>
<td>
<p>is the rxode2 control options; This is to figure
out how to handle the addl dosing information.</p>
</td></tr>
<tr><td><code id="bblDatToMonolix_+3A_env">env</code></td>
<td>
<p>When <code>NULL</code> (default) nothing is done.  When an
environment, the function <code>nlmixr2est::.foceiPreProcessData(data, env, model, rxControl)</code> is called on the provided environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>With the function <code>bblDatToMonolix()</code> return a list with:
</p>

<ul>
<li><p> Monolix compatible dataset ($monolix)
</p>
</li>
<li><p> Monolix ADM information ($adm)
</p>
</li></ul>

<p>With the function <code>nlmixrDataToNonmem()</code> return a dataset that is
compatible with NONMEM.
</p>
<p>With the function <code>nlmixrDataToMrgsolve()</code> return a dataset that is
compatible with <code>mrgsolve</code>.  Unlike NONMEM, it supports replacement
events with <code>evid=8</code> (note with <code>rxode2</code> replacement <code>evid</code> is <code>5</code>).
</p>
<p>With the function <code>nlmixrDataToRxode()</code> this will normalize the
dataset to use newer <code>evid</code> definitions that are closer to NONMEM
instead of any classic definitions that are used at a lower level
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pk.turnover.emax3 &lt;- function() {
  ini({
    tktr &lt;- log(1)
    tka &lt;- log(1)
    tcl &lt;- log(0.1)
    tv &lt;- log(10)
    ##
    eta.ktr ~ 1
    eta.ka ~ 1
    eta.cl ~ 2
    eta.v ~ 1
    prop.err &lt;- 0.1
    pkadd.err &lt;- 0.1
    ##
    temax &lt;- logit(0.8)
    tec50 &lt;- log(0.5)
    tkout &lt;- log(0.05)
    te0 &lt;- log(100)
    ##
    eta.emax ~ .5
    eta.ec50  ~ .5
    eta.kout ~ .5
    eta.e0 ~ .5
    ##
    pdadd.err &lt;- 10
  })
  model({
    ktr &lt;- exp(tktr + eta.ktr)
    ka &lt;- exp(tka + eta.ka)
    cl &lt;- exp(tcl + eta.cl)
    v &lt;- exp(tv + eta.v)
    emax = expit(temax+eta.emax)
    ec50 =  exp(tec50 + eta.ec50)
    kout = exp(tkout + eta.kout)
    e0 = exp(te0 + eta.e0)
    ##
    DCP = center/v
    PD=1-emax*DCP/(ec50+DCP)
    ##
    effect(0) = e0
    kin = e0*kout
    ##
    d/dt(depot) = -ktr * depot
    d/dt(gut) =  ktr * depot -ka * gut
    d/dt(center) =  ka * gut - cl / v * center
    d/dt(effect) = kin*PD -kout*effect
    ##
    cp = center / v
    cp ~ prop(prop.err) + add(pkadd.err)
    effect ~ add(pdadd.err) | pca
  })
}

bblDatToMonolix(pk.turnover.emax3, nlmixr2data::warfarin)

bblDatToNonmem(pk.turnover.emax3, nlmixr2data::warfarin)

bblDatToMrgsolve(pk.turnover.emax3, nlmixr2data::warfarin)

bblDatToRxode(pk.turnover.emax3, nlmixr2data::warfarin)

</code></pre>

<hr>
<h2 id='getStandardColNames'>Determine standardized rxode2 column names from data</h2><span id='topic+getStandardColNames'></span>

<h3>Description</h3>

<p>Determine standardized rxode2 column names from data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getStandardColNames(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getStandardColNames_+3A_data">data</code></td>
<td>
<p>A data.frame as the source for column names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named character vector where the names are the standardized names
and the values are either the name of the column from the data or <code>NA</code>
if the column is not present in the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getStandardColNames(data.frame(ID=1, DV=2, Time=3, CmT=4))
</code></pre>

<hr>
<h2 id='modelUnitConversion'>Unit conversion for pharmacokinetic models</h2><span id='topic+modelUnitConversion'></span>

<h3>Description</h3>

<p>Unit conversion for pharmacokinetic models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelUnitConversion(
  dvu = NA_character_,
  amtu = NA_character_,
  timeu = NA_character_,
  volumeu = NA_character_
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelUnitConversion_+3A_dvu">dvu</code>, <code id="modelUnitConversion_+3A_amtu">amtu</code>, <code id="modelUnitConversion_+3A_timeu">timeu</code></td>
<td>
<p>The units for the DV, AMT, and TIME columns in the data</p>
</td></tr>
<tr><td><code id="modelUnitConversion_+3A_volumeu">volumeu</code></td>
<td>
<p>The units for the volume parameters in the model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with names for the units associated with each parameter
(&quot;amtu&quot;, &quot;clearanceu&quot;, &quot;volumeu&quot;, &quot;timeu&quot;, &quot;dvu&quot;) and the numeric value to
multiply the modeled estimate (for example, <code>cp</code>) so that the model is
consistent with the data units.
</p>


<h3>See Also</h3>

<p>Other Unit conversion: 
<code><a href="#topic+simplifyUnit">simplifyUnit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>modelUnitConversion(dvu = "ng/mL", amtu = "mg", timeu = "hr", volumeu = "L")
</code></pre>

<hr>
<h2 id='monolixControl'>Monolix Controller for nlmixr2</h2><span id='topic+monolixControl'></span>

<h3>Description</h3>

<p>Monolix Controller for nlmixr2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monolixControl(
  nbSSDoses = 7,
  useLinearization = FALSE,
  stiff = FALSE,
  addProp = c("combined2", "combined1"),
  exploratoryAutoStop = FALSE,
  smoothingAutoStop = FALSE,
  burnInIterations = 5,
  smoothingIterations = 200,
  exploratoryIterations = 250,
  simulatedAnnealingIterations = 250,
  exploratoryInterval = 200,
  exploratoryAlpha = 0,
  omegaTau = 0.95,
  errorModelTau = 0.95,
  variability = c("none", "firstStage", "decreasing"),
  runCommand = getOption("babelmixr2.monolix", ""),
  rxControl = NULL,
  sumProd = FALSE,
  optExpression = TRUE,
  calcTables = TRUE,
  compress = TRUE,
  ci = 0.95,
  sigdigTable = NULL,
  absolutePath = FALSE,
  modelName = NULL,
  muRefCovAlg = TRUE,
  run = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="monolixControl_+3A_nbssdoses">nbSSDoses</code></td>
<td>
<p>Number of steady state doses (default 7)</p>
</td></tr>
<tr><td><code id="monolixControl_+3A_uselinearization">useLinearization</code></td>
<td>
<p>Use linearization for log likelihood and
fim.</p>
</td></tr>
<tr><td><code id="monolixControl_+3A_stiff">stiff</code></td>
<td>
<p>boolean for using the stiff ODE solver</p>
</td></tr>
<tr><td><code id="monolixControl_+3A_addprop">addProp</code></td>
<td>
<p>specifies the type of additive plus proportional
errors, the one where standard deviations add (combined1) or the
type where the variances add (combined2).
</p>
<p>The combined1 error type can be described by the following equation:
</p>
<p style="text-align: center;"><code class="reqn">y = f + (a + b\times f^c) \times \varepsilon</code>
</p>

<p>The combined2 error model can be described by the following equation:
</p>
<p style="text-align: center;"><code class="reqn">y = f + \sqrt{a^2 + b^2\times f^{2\times c}} \times \varepsilon</code>
</p>

<p>Where:
</p>
<p>- y represents the observed value
</p>
<p>- f represents the predicted value
</p>
<p>- a  is the additive standard deviation
</p>
<p>- b is the proportional/power standard deviation
</p>
<p>- c is the power exponent (in the proportional case c=1)</p>
</td></tr>
<tr><td><code id="monolixControl_+3A_exploratoryautostop">exploratoryAutoStop</code></td>
<td>
<p>logical to turn on or off exploratory
phase auto-stop of SAEM (default 250)</p>
</td></tr>
<tr><td><code id="monolixControl_+3A_smoothingautostop">smoothingAutoStop</code></td>
<td>
<p>Boolean indicating if the smoothing should
automatically stop (default <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="monolixControl_+3A_burniniterations">burnInIterations</code></td>
<td>
<p>Number of burn in iterations</p>
</td></tr>
<tr><td><code id="monolixControl_+3A_smoothingiterations">smoothingIterations</code></td>
<td>
<p>Number of smoothing iterations</p>
</td></tr>
<tr><td><code id="monolixControl_+3A_exploratoryiterations">exploratoryIterations</code></td>
<td>
<p>Number of iterations for exploratory
phase (default 250)</p>
</td></tr>
<tr><td><code id="monolixControl_+3A_simulatedannealingiterations">simulatedAnnealingIterations</code></td>
<td>
<p>Number of simulating annealing
iterations</p>
</td></tr>
<tr><td><code id="monolixControl_+3A_exploratoryinterval">exploratoryInterval</code></td>
<td>
<p>Minimum number of iterations in the
exploratory phase (default 200)</p>
</td></tr>
<tr><td><code id="monolixControl_+3A_exploratoryalpha">exploratoryAlpha</code></td>
<td>
<p>Convergence memory in the exploratory phase
(only used when <code>exploratoryAutoStop</code> is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="monolixControl_+3A_omegatau">omegaTau</code></td>
<td>
<p>Proportional rate on variance for simulated
annealing</p>
</td></tr>
<tr><td><code id="monolixControl_+3A_errormodeltau">errorModelTau</code></td>
<td>
<p>Proportional rate on error model for simulated
annealing</p>
</td></tr>
<tr><td><code id="monolixControl_+3A_variability">variability</code></td>
<td>
<p>This describes the methodology for parameters
without variability.  It could be: - Fixed throughout (none) -
Variability in the first stage (firstStage) - Decreasing until it
reaches the fixed value (decreasing)</p>
</td></tr>
<tr><td><code id="monolixControl_+3A_runcommand">runCommand</code></td>
<td>
<p>is a shell command or function to run monolix; You can specify
the default by
<code>options("babelmixr2.monolix"="runMonolix")</code>. If it is empty
and 'lixoftConnectors' is available, use lixoftConnectors to run
monolix. See details for function usage.</p>
</td></tr>
<tr><td><code id="monolixControl_+3A_rxcontrol">rxControl</code></td>
<td>
<p>'rxode2' ODE solving options during fitting, created with 'rxControl()'</p>
</td></tr>
<tr><td><code id="monolixControl_+3A_sumprod">sumProd</code></td>
<td>
<p>Is a boolean indicating if the model should change
multiplication to high precision multiplication and sums to
high precision sums using the PreciseSums package.  By default
this is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="monolixControl_+3A_optexpression">optExpression</code></td>
<td>
<p>Optimize the rxode2 expression to speed up
calculation. By default this is turned on.</p>
</td></tr>
<tr><td><code id="monolixControl_+3A_calctables">calcTables</code></td>
<td>
<p>This boolean is to determine if the foceiFit
will calculate tables. By default this is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="monolixControl_+3A_compress">compress</code></td>
<td>
<p>Should the object have compressed items</p>
</td></tr>
<tr><td><code id="monolixControl_+3A_ci">ci</code></td>
<td>
<p>Confidence level for some tables.  By default this is
0.95 or 95% confidence.</p>
</td></tr>
<tr><td><code id="monolixControl_+3A_sigdigtable">sigdigTable</code></td>
<td>
<p>Significant digits in the final output table.
If not specified, then it matches the significant digits in the
'sigdig' optimization algorithm.  If 'sigdig' is NULL, use 3.</p>
</td></tr>
<tr><td><code id="monolixControl_+3A_absolutepath">absolutePath</code></td>
<td>
<p>Boolean indicating if the absolute path should
be used for the monolix runs</p>
</td></tr>
<tr><td><code id="monolixControl_+3A_modelname">modelName</code></td>
<td>
<p>Model name used to generate the NONMEM output.  If
<code>NULL</code> try to infer from the model name (could be <code>x</code> if not
clear).  Otherwise use this character for outputs.</p>
</td></tr>
<tr><td><code id="monolixControl_+3A_murefcovalg">muRefCovAlg</code></td>
<td>
<p>This controls if algebraic expressions that can
be mu-referenced are treated as mu-referenced covariates by:
</p>
<p>1. Creating a internal data-variable 'nlmixrMuDerCov#' for each
algebraic mu-referenced expression
</p>
<p>2. Change the algebraic expression to 'nlmixrMuDerCov# * mu_cov_theta'
</p>
<p>3. Use the internal mu-referenced covariate for saem
</p>
<p>4. After optimization is completed, replace 'model()' with old
'model()' expression
</p>
<p>5. Remove 'nlmixrMuDerCov#' from nlmix2 output
</p>
<p>In general, these covariates should be more accurate since it
changes the system to a linear compartment model.  Therefore, by default this is 'TRUE'.</p>
</td></tr>
<tr><td><code id="monolixControl_+3A_run">run</code></td>
<td>
<p>Should monolix be run and the results be imported to nlmixr2?  (Default is TRUE)</p>
</td></tr>
<tr><td><code id="monolixControl_+3A_...">...</code></td>
<td>
<p>Ignored parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>runCommand</code> is given as a string, it will be called with the
<code>system()</code> command like:
</p>
<p><code>runCommand mlxtran</code>.
</p>
<p>For example, if <code>runCommand="'/path/to/monolix/mlxbsub2021' -p "</code> then the command line
used would look like the following:
</p>
<p><code>'/path/to/monolix/mlxbsub2021' monolix.mlxtran</code>
</p>
<p>If <code>runCommand</code> is given as a function, it will be called as
<code>FUN(mlxtran, directory, ui)</code> to run Monolix.  This allows you to run Monolix
in any way that you may need, as long as you can write it in R.  babelmixr2
will wait for the function to return before proceeding.
</p>
<p>If <code>runCommand</code> is <code>NA</code>, <code>nlmixr()</code> will stop after writing
the model files and without starting Monolix.
</p>
<p>Note that you can get the translated monolix components from a
parsed/compiled rxode2 ui object with <code>ui$monolixModel</code> and <code>ui$mlxtran</code>
</p>


<h3>Value</h3>

<p>A monolix control object
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='nlmixr2Est.pknca'>Estimate starting parameters using PKNCA</h2><span id='topic+nlmixr2Est.pknca'></span>

<h3>Description</h3>

<p>Estimate starting parameters using PKNCA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pknca'
nlmixr2Est(env, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nlmixr2Est.pknca_+3A_env">env</code></td>
<td>
<p>Environment for the nlmixr2 estimation routines.
</p>
<p>This needs to have:
</p>
<p>- rxode2 ui object in '$ui'
</p>
<p>- data to fit in the estimation routine in '$data'
</p>
<p>- control for the estimation routine's control options in '$ui'</p>
</td></tr>
<tr><td><code id="nlmixr2Est.pknca_+3A_...">...</code></td>
<td>
<p>Other arguments provided to 'nlmixr2Est()' provided for
flexibility but not currently used inside nlmixr</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parameters are estimated as follows:
</p>

<ul>
<li> <p><code>ka</code> 4 half-lives to Tmax but not higher than 3:  <code>log(2)/(tmax/4)</code>
</p>
</li>
<li> <p><code>vc</code> Inverse of dose-normalized Cmax
</p>
</li>
<li> <p><code>cl</code> Estimated as the median clearance
</p>
</li>
<li> <p><code>vp,vp2</code>2- and 4-fold the <code>vc</code>, respectively by default,
controlled by the <code>vpMult</code> and <code>vp2Mult</code> arguments to
<code>pkncaControl</code>
</p>
</li>
<li> <p><code>q,q2</code> 0.5- and 0.25-fold the <code>cl</code>, respectively by default,
controlled by the <code>qMult</code> and <code>q2Mult</code> arguments to
<code>pkncaControl</code>
</p>
</li></ul>

<p>The bounds for the parameter estimates are set to 10% of the first percentile
and 10 times the 99th percentile.  (For ka, the lower bound is set to the
lower of 10% of the first percentile or 0.03 and the upper bound is not
modified from 10 times the 99th percentile.)
</p>
<p>Parameter estimation methods may be changed in a future version.
</p>


<h3>Value</h3>

<p>A model with updated starting parameters.  In the model a new element
named &quot;nca&quot; will be available which includes the PKNCA results used for the
calculation.
</p>

<hr>
<h2 id='nmGetDistributionMonolixLines'>This is a S3 method for getting the distribution lines for a base rxode2 saem problem</h2><span id='topic+nmGetDistributionMonolixLines'></span><span id='topic+nmGetDistributionMonolixLines.rxUi'></span><span id='topic+nmGetDistributionMonolixLines.norm'></span>

<h3>Description</h3>

<p>This is a S3 method for getting the distribution lines for a base rxode2 saem problem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nmGetDistributionMonolixLines(line)

## S3 method for class 'rxUi'
nmGetDistributionMonolixLines(line)

## S3 method for class 'norm'
nmGetDistributionMonolixLines(line)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nmGetDistributionMonolixLines_+3A_line">line</code></td>
<td>
<p>Parsed rxode2 model environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Lines for the estimation of monolix
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='nmGetDistributionNonmemLines'>This is a S3 method for getting the distribution lines for a base rxode2 saem problem</h2><span id='topic+nmGetDistributionNonmemLines'></span><span id='topic+nmGetDistributionNonmemLines.rxUi'></span><span id='topic+nmGetDistributionNonmemLines.norm'></span>

<h3>Description</h3>

<p>This is a S3 method for getting the distribution lines for a base rxode2 saem problem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nmGetDistributionNonmemLines(line)

## S3 method for class 'rxUi'
nmGetDistributionNonmemLines(line)

## S3 method for class 'norm'
nmGetDistributionNonmemLines(line)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nmGetDistributionNonmemLines_+3A_line">line</code></td>
<td>
<p>Parsed rxode2 model environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Lines for the estimation of nonmem
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='nonmemControl'>NONMEM estimation control</h2><span id='topic+nonmemControl'></span>

<h3>Description</h3>

<p>NONMEM estimation control
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonmemControl(
  est = c("focei", "imp", "its", "posthoc"),
  advanOde = c("advan13", "advan8", "advan6"),
  cov = c("r,s", "r", "s", ""),
  maxeval = 1e+05,
  tol = 6,
  atol = 12,
  sstol = 6,
  ssatol = 12,
  sigl = 12,
  sigdig = 3,
  print = 1,
  extension = getOption("babelmixr2.nmModelExtension", ".nmctl"),
  outputExtension = getOption("babelmixr2.nmOutputExtension", ".lst"),
  runCommand = getOption("babelmixr2.nonmem", ""),
  iniSigDig = 5,
  protectZeros = FALSE,
  muRef = TRUE,
  addProp = c("combined2", "combined1"),
  rxControl = NULL,
  sumProd = FALSE,
  optExpression = TRUE,
  calcTables = TRUE,
  compress = TRUE,
  ci = 0.95,
  sigdigTable = NULL,
  readRounding = FALSE,
  readBadOpt = FALSE,
  niter = 100L,
  isample = 1000L,
  iaccept = 0.4,
  iscaleMin = 0.1,
  iscaleMax = 10,
  df = 4,
  seed = 14456,
  mapiter = 1,
  mapinter = 0,
  noabort = TRUE,
  modelName = NULL,
  muRefCovAlg = TRUE,
  run = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nonmemControl_+3A_est">est</code></td>
<td>
<p>NONMEM estimation method</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_advanode">advanOde</code></td>
<td>
<p>The ODE solving method for NONMEM</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_cov">cov</code></td>
<td>
<p>The NONMEM covariance method</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_maxeval">maxeval</code></td>
<td>
<p>NONMEM's maxeval (for non posthoc methods)</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_tol">tol</code></td>
<td>
<p>NONMEM tolerance for ODE solving advan</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_atol">atol</code></td>
<td>
<p>NONMEM absolute tolerance for ODE solving</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_sstol">sstol</code></td>
<td>
<p>NONMEM tolerance for steady state ODE solving</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_ssatol">ssatol</code></td>
<td>
<p>NONMEM absolute tolerance for steady state ODE
solving</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_sigl">sigl</code></td>
<td>
<p>NONMEM sigl estimation option</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_sigdig">sigdig</code></td>
<td>
<p>the significant digits for NONMEM</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_print">print</code></td>
<td>
<p>The print number for NONMEM</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_extension">extension</code></td>
<td>
<p>NONMEM file extensions</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_outputextension">outputExtension</code></td>
<td>
<p>Extension to use for the NONMEM output
listing</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_runcommand">runCommand</code></td>
<td>
<p>Command to run NONMEM (typically the path to
&quot;nmfe75&quot;) or a function.  See the details for more information.</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_inisigdig">iniSigDig</code></td>
<td>
<p>How many significant digits are printed in $THETA
and $OMEGA when the estimate is zero.  Also controls the zero
protection numbers</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_protectzeros">protectZeros</code></td>
<td>
<p>Add methods to protect divide by zero</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_muref">muRef</code></td>
<td>
<p>Automatically mu-reference the control stream</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_addprop">addProp</code>, <code id="nonmemControl_+3A_sumprod">sumProd</code>, <code id="nonmemControl_+3A_optexpression">optExpression</code>, <code id="nonmemControl_+3A_calctables">calcTables</code>, <code id="nonmemControl_+3A_compress">compress</code>, <code id="nonmemControl_+3A_ci">ci</code>, <code id="nonmemControl_+3A_sigdigtable">sigdigTable</code></td>
<td>
<p>Passed to <code>nlmixr2est::foceiControl</code></p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_rxcontrol">rxControl</code></td>
<td>
<p>Options to pass to <code>rxode2::rxControl</code> for
simulations</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_readrounding">readRounding</code></td>
<td>
<p>Try to read NONMEM output when NONMEM
terminated due to rounding errors</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_readbadopt">readBadOpt</code></td>
<td>
<p>Try to read NONMEM output when NONMEM terminated
due to an apparent failed optimization</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_niter">niter</code></td>
<td>
<p>number of iterations in NONMEM estimation methods</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_isample">isample</code></td>
<td>
<p>Isample argument for NONMEM ITS estimation method</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_iaccept">iaccept</code></td>
<td>
<p>Iaccept for NONMEM ITS estimation methods</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_iscalemin">iscaleMin</code></td>
<td>
<p>parameter for IMP NONMEM method (ISCALE_MIN)</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_iscalemax">iscaleMax</code></td>
<td>
<p>parameter for IMP NONMEM method (ISCALE_MAX)</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_df">df</code></td>
<td>
<p>degrees of freedom for IMP method</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_seed">seed</code></td>
<td>
<p>is the seed for NONMEM methods</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_mapiter">mapiter</code></td>
<td>
<p>the number of map iterations for IMP method</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_mapinter">mapinter</code></td>
<td>
<p>is the MAPINTER parameter for the IMP method</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_noabort">noabort</code></td>
<td>
<p>Add the <code>NOABORT</code> option for <code style="white-space: pre;">&#8288;$EST&#8288;</code></p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_modelname">modelName</code></td>
<td>
<p>Model name used to generate the NONMEM output.  If
<code>NULL</code> try to infer from the model name (could be <code>x</code> if not
clear).  Otherwise use this character for outputs.</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_murefcovalg">muRefCovAlg</code></td>
<td>
<p>This controls if algebraic expressions that can
be mu-referenced are treated as mu-referenced covariates by:
</p>
<p>1. Creating a internal data-variable 'nlmixrMuDerCov#' for each
algebraic mu-referenced expression
</p>
<p>2. Change the algebraic expression to 'nlmixrMuDerCov# * mu_cov_theta'
</p>
<p>3. Use the internal mu-referenced covariate for saem
</p>
<p>4. After optimization is completed, replace 'model()' with old
'model()' expression
</p>
<p>5. Remove 'nlmixrMuDerCov#' from nlmix2 output
</p>
<p>In general, these covariates should be more accurate since it
changes the system to a linear compartment model.  Therefore, by default this is 'TRUE'.</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_run">run</code></td>
<td>
<p>Should NONMEM be run (and the files imported to
nlmixr2); default is TRUE, but FALSE will simply create the
NONMEM control stream and data file.</p>
</td></tr>
<tr><td><code id="nonmemControl_+3A_...">...</code></td>
<td>
<p>optional <code>genRxControl</code> argument controlling
automatic <code>rxControl</code> generation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>runCommand</code> is given as a string, it will be called with the
<code>system()</code> command like:
</p>
<p><code>runCommand controlFile outputFile</code>.
</p>
<p>For example, if <code>runCommand="'/path/to/nmfe75'"</code> then the command line
used would look like the following:
</p>
<p><code>'/path/to/nmfe75' one.cmt.nmctl one.cmt.lst</code>
</p>
<p>If <code>runCommand</code> is given as a function, it will be called as
<code>FUN(ctl, directory, ui)</code> to run NONMEM.  This allows you to run NONMEM
in any way that you may need, as long as you can write it in R.  babelmixr2
will wait for the function to return before proceeding.
</p>
<p>If <code>runCommand</code> is <code>NA</code>, <code>nlmixr()</code> will stop after writing
the model files and without starting NONMEM.
</p>


<h3>Value</h3>

<p>babelmixr2 control option for generating NONMEM control stream and
reading it back into <code>babelmixr2</code>/<code>nlmixr2</code>
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nonmemControl()

</code></pre>

<hr>
<h2 id='pkncaControl'>PKNCA estimation control</h2><span id='topic+pkncaControl'></span>

<h3>Description</h3>

<p>PKNCA estimation control
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkncaControl(
  concu = NA_character_,
  doseu = NA_character_,
  timeu = NA_character_,
  volumeu = NA_character_,
  vpMult = 2,
  qMult = 1/2,
  vp2Mult = 4,
  q2Mult = 1/4,
  dvParam = "cp",
  groups = character(),
  sparse = FALSE,
  ncaData = NULL,
  ncaResults = NULL,
  rxControl = rxode2::rxControl()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pkncaControl_+3A_concu">concu</code>, <code id="pkncaControl_+3A_doseu">doseu</code>, <code id="pkncaControl_+3A_timeu">timeu</code></td>
<td>
<p>concentration, dose, and time units from the source
data (passed to <code>PKNCA::pknca_units_table()</code>).</p>
</td></tr>
<tr><td><code id="pkncaControl_+3A_volumeu">volumeu</code></td>
<td>
<p>compartment volume for the model (if <code>NULL</code>, simplified
units from source data will be used)</p>
</td></tr>
<tr><td><code id="pkncaControl_+3A_vpmult">vpMult</code>, <code id="pkncaControl_+3A_qmult">qMult</code>, <code id="pkncaControl_+3A_vp2mult">vp2Mult</code>, <code id="pkncaControl_+3A_q2mult">q2Mult</code></td>
<td>
<p>Multipliers for vc and cl to provide
initial estimates for vp, q, vp2, and q2</p>
</td></tr>
<tr><td><code id="pkncaControl_+3A_dvparam">dvParam</code></td>
<td>
<p>The parameter name in the model that should be modified for
concentration unit conversions.  It must be assigned on a line by itself,
separate from the residual error model line.</p>
</td></tr>
<tr><td><code id="pkncaControl_+3A_groups">groups</code></td>
<td>
<p>Grouping columns for NCA summaries by group (required if
<code>sparse = TRUE</code>)</p>
</td></tr>
<tr><td><code id="pkncaControl_+3A_sparse">sparse</code></td>
<td>
<p>Are the concentration-time data sparse PK (commonly used in
small nonclinical species or with terminal or difficult sampling) or dense
PK (commonly used in clinical studies or larger nonclinical species)?</p>
</td></tr>
<tr><td><code id="pkncaControl_+3A_ncadata">ncaData</code></td>
<td>
<p>Data to use for calculating NCA parameters.  Typical use is
when a subset of the original data are informative for NCA.</p>
</td></tr>
<tr><td><code id="pkncaControl_+3A_ncaresults">ncaResults</code></td>
<td>
<p>Already computed NCA results (a PKNCAresults object) to
bypass automatic calculations.  At least the following parameters must be
calculated in the NCA: tmax, cmax.dn, cl.last</p>
</td></tr>
<tr><td><code id="pkncaControl_+3A_rxcontrol">rxControl</code></td>
<td>
<p>Control options sent to <code>rxode2::rxControl()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of parameters
</p>

<hr>
<h2 id='popedControl'>Control for a PopED design task</h2><span id='topic+popedControl'></span>

<h3>Description</h3>

<p>Control for a PopED design task
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popedControl(
  stickyRecalcN = 4,
  maxOdeRecalc = 5,
  odeRecalcFactor = 10^(0.5),
  maxn = NULL,
  rxControl = NULL,
  sigdig = 4,
  important = NULL,
  unimportant = NULL,
  iFIMCalculationType = c("reduced", "full", "weighted", "loc", "reducedPFIM", "fullABC",
    "largeMat", "reducedFIMABC"),
  iApproximationMethod = c("fo", "foce", "focei", "foi"),
  iFOCENumInd = 1000,
  prior_fim = matrix(0, 0, 1),
  d_switch = c("d", "ed"),
  ofv_calc_type = c("lnD", "d", "a", "Ds", "inverse"),
  strEDPenaltyFile = "",
  ofv_fun = NULL,
  iEDCalculationType = c("mc", "laplace", "bfgs-laplace"),
  ED_samp_size = 45,
  bLHS = c("hypercube", "random"),
  bUseRandomSearch = TRUE,
  bUseStochasticGradient = TRUE,
  bUseLineSearch = TRUE,
  bUseExchangeAlgorithm = FALSE,
  bUseBFGSMinimizer = FALSE,
  bUseGrouped_xt = FALSE,
  EACriteria = c("modified", "fedorov"),
  strRunFile = "",
  poped_version = NULL,
  modtit = "PopED babelmixr2 model",
  output_file = "PopED_output_summary",
  output_function_file = "PopED_output_",
  strIterationFileName = "PopED_current.R",
  user_data = NULL,
  ourzero = 1e-05,
  dSeed = NULL,
  line_opta = NULL,
  line_optx = NULL,
  bShowGraphs = FALSE,
  use_logfile = FALSE,
  m1_switch = c("central", "complex", "analytic", "ad"),
  m2_switch = c("central", "complex", "analytic", "ad"),
  hle_switch = c("central", "complex", "ad"),
  gradff_switch = c("central", "complex", "analytic", "ad"),
  gradfg_switch = c("central", "complex", "analytic", "ad"),
  grad_all_switch = c("central", "complex"),
  rsit_output = 5,
  sgit_output = 1,
  hm1 = 1e-05,
  hlf = 1e-05,
  hlg = 1e-05,
  hm2 = 1e-05,
  hgd = 1e-05,
  hle = 1e-05,
  AbsTol = 1e-06,
  RelTol = 1e-06,
  iDiffSolverMethod = NULL,
  bUseMemorySolver = FALSE,
  rsit = 300,
  sgit = 150,
  intrsit = 250,
  intsgit = 50,
  maxrsnullit = 50,
  convergence_eps = 1e-08,
  rslxt = 10,
  rsla = 10,
  cfaxt = 0.001,
  cfaa = 0.001,
  bGreedyGroupOpt = FALSE,
  EAStepSize = 0.01,
  EANumPoints = FALSE,
  EAConvergenceCriteria = 1e-20,
  bEANoReplicates = FALSE,
  BFGSProjectedGradientTol = 1e-04,
  BFGSTolerancef = 0.001,
  BFGSToleranceg = 0.9,
  BFGSTolerancex = 0.1,
  ED_diff_it = 30,
  ED_diff_percent = 10,
  line_search_it = 50,
  Doptim_iter = 1,
  iCompileOption = c("none", "full", "mcc", "mpi"),
  compileOnly = FALSE,
  iUseParallelMethod = c("mpi", "matlab"),
  MCC_Dep = NULL,
  strExecuteName = "calc_fim.exe",
  iNumProcesses = 2,
  iNumChunkDesignEvals = -2,
  Mat_Out_Pre = "parallel_output",
  strExtraRunOptions = "",
  dPollResultTime = 0.1,
  strFunctionInputName = "function_input",
  bParallelRS = FALSE,
  bParallelSG = FALSE,
  bParallelMFEA = FALSE,
  bParallelLS = FALSE,
  groupsize = NULL,
  time = "time",
  timeLow = "low",
  timeHi = "high",
  id = "id",
  m = NULL,
  x = NULL,
  ni = NULL,
  maxni = NULL,
  minni = NULL,
  maxtotni = NULL,
  mintotni = NULL,
  maxgroupsize = NULL,
  mingroupsize = NULL,
  maxtotgroupsize = NULL,
  mintotgroupsize = NULL,
  xt_space = NULL,
  a = NULL,
  maxa = NULL,
  mina = NULL,
  a_space = NULL,
  x_space = NULL,
  use_grouped_xt = FALSE,
  grouped_xt = NULL,
  use_grouped_a = FALSE,
  grouped_a = NULL,
  use_grouped_x = FALSE,
  grouped_x = NULL,
  our_zero = NULL,
  auto_pointer = "",
  user_distribution_pointer = "",
  minxt = NULL,
  maxxt = NULL,
  discrete_xt = NULL,
  discrete_a = NULL,
  fixRes = FALSE,
  script = NULL,
  overwrite = TRUE,
  literalFix = TRUE,
  opt_xt = FALSE,
  opt_a = FALSE,
  opt_x = FALSE,
  opt_samps = FALSE,
  optTime = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="popedControl_+3A_stickyrecalcn">stickyRecalcN</code></td>
<td>
<p>The number of bad ODE solves before reducing
the atol/rtol for the rest of the problem.</p>
</td></tr>
<tr><td><code id="popedControl_+3A_maxoderecalc">maxOdeRecalc</code></td>
<td>
<p>Maximum number of times to reduce the ODE
tolerances and try to resolve the system if there was a bad
ODE solve.</p>
</td></tr>
<tr><td><code id="popedControl_+3A_oderecalcfactor">odeRecalcFactor</code></td>
<td>
<p>The ODE recalculation factor when ODE
solving goes bad, this is the factor the rtol/atol is reduced</p>
</td></tr>
<tr><td><code id="popedControl_+3A_maxn">maxn</code></td>
<td>
<p>Maximum number of design points for optimization; By
default this is declared by the maximum number of design points
in the babelmixr2 dataset (when <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="popedControl_+3A_rxcontrol">rxControl</code></td>
<td>
<p>'rxode2' ODE solving options during fitting, created with 'rxControl()'</p>
</td></tr>
<tr><td><code id="popedControl_+3A_sigdig">sigdig</code></td>
<td>
<p>Optimization significant digits. This controls:
</p>

<ul>
<li><p> The tolerance of the inner and outer optimization is <code>10^-sigdig</code>
</p>
</li>
<li><p> The tolerance of the ODE solvers is
<code>0.5*10^(-sigdig-2)</code>; For the sensitivity equations and
steady-state solutions the default is <code>0.5*10^(-sigdig-1.5)</code>
(sensitivity changes only applicable for liblsoda)
</p>
</li>
<li><p> The tolerance of the boundary check is <code>5 * 10 ^ (-sigdig + 1)</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="popedControl_+3A_important">important</code></td>
<td>
<p>character vector of important parameters or NULL
for default.  This is used with Ds-optimality</p>
</td></tr>
<tr><td><code id="popedControl_+3A_unimportant">unimportant</code></td>
<td>
<p>character vector of unimportant parameters or
NULL for default.  This is used with Ds-optimality</p>
</td></tr>
<tr><td><code id="popedControl_+3A_ifimcalculationtype">iFIMCalculationType</code></td>
<td>
<p>can be either an integer or a named
value of the Fisher Information Matrix type:
</p>

<ul>
<li><p> 0/&quot;full&quot; = Full FIM
</p>
</li>
<li><p> 1/&quot;reduced&quot; = Reduced FIM
</p>
</li>
<li><p> 2/&quot;weighted&quot; = weighted models
</p>
</li>
<li><p> 3/&quot;loc&quot; = Loc models
</p>
</li>
<li><p> 4/&quot;reducedPFIM&quot; = reduced FIM with derivative of SD of sigma as in PFIM
</p>
</li>
<li><p> 5/&quot;fullABC&quot; = FULL FIM parameterized with A,B,C matrices &amp; derivative of variance
</p>
</li>
<li><p> 6/&quot;largeMat&quot; = Calculate one model switch at a time, good for large matrices
</p>
</li>
<li><p> 7/&quot;reducedFIMABC&quot; = =Reduced FIM parameterized with A,B,C matrices &amp; derivative of variance
</p>
</li></ul>
</td></tr>
<tr><td><code id="popedControl_+3A_iapproximationmethod">iApproximationMethod</code></td>
<td>
<p>Approximation method for model, 0=FO, 1=FOCE, 2=FOCEI, 3=FOI</p>
</td></tr>
<tr><td><code id="popedControl_+3A_ifocenumind">iFOCENumInd</code></td>
<td>
<p>integer; number of individuals in focei solve</p>
</td></tr>
<tr><td><code id="popedControl_+3A_prior_fim">prior_fim</code></td>
<td>
<p>matrix; prior FIM</p>
</td></tr>
<tr><td><code id="popedControl_+3A_d_switch">d_switch</code></td>
<td>
<p>integer or character option:
</p>

<ul>
<li><p> 0/&quot;ed&quot; = ED design
</p>
</li>
<li><p> 1/&quot;d&quot; = D design
</p>
</li></ul>
</td></tr>
<tr><td><code id="popedControl_+3A_ofv_calc_type">ofv_calc_type</code></td>
<td>
<p>objective calculation type:
</p>

<ul>
<li><p> 1/&quot;d&quot; = D-optimality&quot;. Determinant of the FIM: det(FIM)
</p>
</li>
<li><p> 2/&quot;a&quot; =  &quot;A-optimality&quot;. Inverse of the sum of the expected parameter variances: 1/trace_matrix(inv(FIM))
</p>
</li>
<li><p> 4/&quot;lnD&quot; = &quot;lnD-optimality&quot;. Natural logarithm of the determinant of the FIM: log(det(FIM))
</p>
</li>
<li><p> 6/&quot;Ds&quot; = &quot;Ds-optimality&quot;. Ratio of the Determinant of the FIM and the Determinant of the uninteresting rows and columns of the FIM: det(FIM)/det(FIM_u)
</p>
</li>
<li><p> 7/&quot;inverse&quot; = Inverse of the sum of the expected parameter RSE: 1/sum(get_rse(FIM,poped.db,use_percent=FALSE))
</p>
</li></ul>
</td></tr>
<tr><td><code id="popedControl_+3A_stredpenaltyfile">strEDPenaltyFile</code></td>
<td>
<p>Penalty function name or path and filename, empty string means no penalty.
User defined criterion can be defined this way.</p>
</td></tr>
<tr><td><code id="popedControl_+3A_ofv_fun">ofv_fun</code></td>
<td>
<p>User defined function used to compute the objective function. The function must have a poped database object as its first
argument and have &quot;...&quot; in its argument list.  Can be referenced as a function or as a file name where the function defined in the file has the same name as the file.
e.g. &quot;cost.txt&quot; has a function named &quot;cost&quot; in it.</p>
</td></tr>
<tr><td><code id="popedControl_+3A_iedcalculationtype">iEDCalculationType</code></td>
<td>
<p>ED Integral Calculation type:
</p>

<ul>
<li><p> 0/&quot;mc&quot; = Monte-Carlo-Integration
</p>
</li>
<li><p> 1/&quot;laplace&quot; = Laplace Approximation
</p>
</li>
<li><p> 2/&quot;bfgs-laplace&quot; = BFGS Laplace Approximation
</p>
</li></ul>
</td></tr>
<tr><td><code id="popedControl_+3A_ed_samp_size">ED_samp_size</code></td>
<td>
<p>Sample size for E-family sampling</p>
</td></tr>
<tr><td><code id="popedControl_+3A_blhs">bLHS</code></td>
<td>
<p>How to sample from distributions in E-family calculations. 0=Random Sampling, 1=LatinHyperCube &ndash;</p>
</td></tr>
<tr><td><code id="popedControl_+3A_buserandomsearch">bUseRandomSearch</code></td>
<td>

<ul>
<li> <p><b>******START OF Optimization algorithm  SPECIFICATION OPTIONS**********</b></p>
</li></ul>

<p>Use random search (1=TRUE, 0=FALSE)</p>
</td></tr>
<tr><td><code id="popedControl_+3A_busestochasticgradient">bUseStochasticGradient</code></td>
<td>
<p>Use Stochastic Gradient search (1=TRUE, 0=FALSE)</p>
</td></tr>
<tr><td><code id="popedControl_+3A_buselinesearch">bUseLineSearch</code></td>
<td>
<p>Use Line search (1=TRUE, 0=FALSE)</p>
</td></tr>
<tr><td><code id="popedControl_+3A_buseexchangealgorithm">bUseExchangeAlgorithm</code></td>
<td>
<p>Use Exchange algorithm (1=TRUE, 0=FALSE)</p>
</td></tr>
<tr><td><code id="popedControl_+3A_busebfgsminimizer">bUseBFGSMinimizer</code></td>
<td>
<p>Use BFGS Minimizer (1=TRUE, 0=FALSE)</p>
</td></tr>
<tr><td><code id="popedControl_+3A_busegrouped_xt">bUseGrouped_xt</code></td>
<td>
<p>Use grouped time points (1=TRUE, 0=FALSE).</p>
</td></tr>
<tr><td><code id="popedControl_+3A_eacriteria">EACriteria</code></td>
<td>
<p>Exchange Algorithm Criteria:
</p>

<ul>
<li><p> 1/&quot;modified&quot; = Modified
</p>
</li>
<li><p> 2/&quot;fedorov&quot;  = Fedorov
</p>
</li></ul>
</td></tr>
<tr><td><code id="popedControl_+3A_strrunfile">strRunFile</code></td>
<td>
<p>Filename and path, or function name, for a run file that is used instead of the regular PopED call.</p>
</td></tr>
<tr><td><code id="popedControl_+3A_poped_version">poped_version</code></td>
<td>

<ul>
<li> <p><b>******START OF Labeling and file names  SPECIFICATION OPTIONS**********</b></p>
</li></ul>

<p>The current PopED version</p>
</td></tr>
<tr><td><code id="popedControl_+3A_modtit">modtit</code></td>
<td>
<p>The model title</p>
</td></tr>
<tr><td><code id="popedControl_+3A_output_file">output_file</code></td>
<td>
<p>Filename and path of the output file during search</p>
</td></tr>
<tr><td><code id="popedControl_+3A_output_function_file">output_function_file</code></td>
<td>
<p>Filename suffix of the result function file</p>
</td></tr>
<tr><td><code id="popedControl_+3A_striterationfilename">strIterationFileName</code></td>
<td>
<p>Filename and path for storage of current optimal design</p>
</td></tr>
<tr><td><code id="popedControl_+3A_user_data">user_data</code></td>
<td>

<ul>
<li> <p><b>******START OF Miscellaneous SPECIFICATION OPTIONS**********</b></p>
</li></ul>

<p>User defined data structure that, for example could be used to send in data to the model</p>
</td></tr>
<tr><td><code id="popedControl_+3A_ourzero">ourzero</code></td>
<td>
<p>Value to interpret as zero in design</p>
</td></tr>
<tr><td><code id="popedControl_+3A_dseed">dSeed</code></td>
<td>
<p>The seed number used for optimization and sampling &ndash; integer or -1 which creates a random seed <code>as.integer(Sys.time())</code> or NULL.</p>
</td></tr>
<tr><td><code id="popedControl_+3A_line_opta">line_opta</code></td>
<td>
<p>Vector for line search on continuous design variables (1=TRUE,0=FALSE)</p>
</td></tr>
<tr><td><code id="popedControl_+3A_line_optx">line_optx</code></td>
<td>
<p>Vector for line search on discrete design variables (1=TRUE,0=FALSE)</p>
</td></tr>
<tr><td><code id="popedControl_+3A_bshowgraphs">bShowGraphs</code></td>
<td>
<p>Use graph output during search</p>
</td></tr>
<tr><td><code id="popedControl_+3A_use_logfile">use_logfile</code></td>
<td>
<p>If a log file should be used (0=FALSE, 1=TRUE)</p>
</td></tr>
<tr><td><code id="popedControl_+3A_m1_switch">m1_switch</code></td>
<td>
<p>Method used to calculate M1:
</p>

<ul>
<li><p> 1/&quot;central&quot; = Central difference
</p>
</li>
<li><p> 0/&quot;complex&quot; = Complex difference
</p>
</li>
<li><p> 20/&quot;analytic&quot; = Analytic derivative
</p>
</li>
<li><p> 30/&quot;ad&quot; = Automatic differentiation
</p>
</li></ul>
</td></tr>
<tr><td><code id="popedControl_+3A_m2_switch">m2_switch</code></td>
<td>
<p>Method used to calculate M2:
</p>

<ul>
<li><p> 1/&quot;central&quot; = Central difference
</p>
</li>
<li><p> 0/&quot;complex&quot; = Complex difference
</p>
</li>
<li><p> 20/&quot;analytic&quot; = Analytic derivative
</p>
</li>
<li><p> 30/&quot;ad&quot; = Automatic differentiation
</p>
</li></ul>
</td></tr>
<tr><td><code id="popedControl_+3A_hle_switch">hle_switch</code></td>
<td>
<p>Method used to calculate linearization of residual error:
</p>

<ul>
<li><p> 1/&quot;central&quot; = Central difference
</p>
</li>
<li><p> 0/&quot;complex&quot; = Complex difference
</p>
</li>
<li><p> 30/&quot;ad&quot; = Automatic differentiation
</p>
</li></ul>
</td></tr>
<tr><td><code id="popedControl_+3A_gradff_switch">gradff_switch</code></td>
<td>
<p>Method used to calculate the gradient of the model:
</p>

<ul>
<li><p> 1/&quot;central&quot; = Central difference
</p>
</li>
<li><p> 0/&quot;complex&quot; = Complex difference
</p>
</li>
<li><p> 20/&quot;analytic&quot; = Analytic derivative
</p>
</li>
<li><p> 30/&quot;ad&quot; = Automatic differentiation
</p>
</li></ul>
</td></tr>
<tr><td><code id="popedControl_+3A_gradfg_switch">gradfg_switch</code></td>
<td>
<p>Method used to calculate the gradient of the
parameter vector g:
</p>

<ul>
<li><p> 1/&quot;central&quot; = Central difference
</p>
</li>
<li><p> 0/&quot;complex&quot; = Complex difference
</p>
</li>
<li><p> 20/&quot;analytic&quot; = Analytic derivative
</p>
</li>
<li><p> 30/&quot;ad&quot; = Automatic differentiation
</p>
</li></ul>
</td></tr>
<tr><td><code id="popedControl_+3A_grad_all_switch">grad_all_switch</code></td>
<td>
<p>Method used to calculate all the gradients:
</p>

<ul>
<li><p> 1/&quot;central&quot; = Central difference
</p>
</li>
<li><p> 0/&quot;complex&quot; = Complex difference
</p>
</li></ul>
</td></tr>
<tr><td><code id="popedControl_+3A_rsit_output">rsit_output</code></td>
<td>
<p>Number of iterations in random search between screen output</p>
</td></tr>
<tr><td><code id="popedControl_+3A_sgit_output">sgit_output</code></td>
<td>
<p>Number of iterations in stochastic gradient search between screen output</p>
</td></tr>
<tr><td><code id="popedControl_+3A_hm1">hm1</code></td>
<td>
<p>Step length of derivative of linearized model w.r.t. typical values</p>
</td></tr>
<tr><td><code id="popedControl_+3A_hlf">hlf</code></td>
<td>
<p>Step length of derivative of model w.r.t. g</p>
</td></tr>
<tr><td><code id="popedControl_+3A_hlg">hlg</code></td>
<td>
<p>Step length of derivative of g w.r.t. b</p>
</td></tr>
<tr><td><code id="popedControl_+3A_hm2">hm2</code></td>
<td>
<p>Step length of derivative of variance w.r.t. typical values</p>
</td></tr>
<tr><td><code id="popedControl_+3A_hgd">hgd</code></td>
<td>
<p>Step length of derivative of OFV w.r.t. time</p>
</td></tr>
<tr><td><code id="popedControl_+3A_hle">hle</code></td>
<td>
<p>Step length of derivative of model w.r.t. sigma</p>
</td></tr>
<tr><td><code id="popedControl_+3A_abstol">AbsTol</code></td>
<td>
<p>The absolute tolerance for the diff equation solver</p>
</td></tr>
<tr><td><code id="popedControl_+3A_reltol">RelTol</code></td>
<td>
<p>The relative tolerance for the diff equation solver</p>
</td></tr>
<tr><td><code id="popedControl_+3A_idiffsolvermethod">iDiffSolverMethod</code></td>
<td>
<p>The diff equation solver method, NULL as default.</p>
</td></tr>
<tr><td><code id="popedControl_+3A_busememorysolver">bUseMemorySolver</code></td>
<td>
<p>If the differential equation results should be stored in memory (1) or not (0)</p>
</td></tr>
<tr><td><code id="popedControl_+3A_rsit">rsit</code></td>
<td>
<p>Number of Random search iterations</p>
</td></tr>
<tr><td><code id="popedControl_+3A_sgit">sgit</code></td>
<td>
<p>Number of stochastic gradient iterations</p>
</td></tr>
<tr><td><code id="popedControl_+3A_intrsit">intrsit</code></td>
<td>
<p>Number of Random search iterations with discrete optimization.</p>
</td></tr>
<tr><td><code id="popedControl_+3A_intsgit">intsgit</code></td>
<td>
<p>Number of Stochastic Gradient search iterations with discrete optimization</p>
</td></tr>
<tr><td><code id="popedControl_+3A_maxrsnullit">maxrsnullit</code></td>
<td>
<p>Iterations until adaptive narrowing in random search</p>
</td></tr>
<tr><td><code id="popedControl_+3A_convergence_eps">convergence_eps</code></td>
<td>
<p>Stochastic Gradient convergence value,
(difference in OFV for D-optimal, difference in gradient for ED-optimal)</p>
</td></tr>
<tr><td><code id="popedControl_+3A_rslxt">rslxt</code></td>
<td>
<p>Random search locality factor for sample times</p>
</td></tr>
<tr><td><code id="popedControl_+3A_rsla">rsla</code></td>
<td>
<p>Random search locality factor for covariates</p>
</td></tr>
<tr><td><code id="popedControl_+3A_cfaxt">cfaxt</code></td>
<td>
<p>Stochastic Gradient search first step factor for sample times</p>
</td></tr>
<tr><td><code id="popedControl_+3A_cfaa">cfaa</code></td>
<td>
<p>Stochastic Gradient search first step factor for covariates</p>
</td></tr>
<tr><td><code id="popedControl_+3A_bgreedygroupopt">bGreedyGroupOpt</code></td>
<td>
<p>Use greedy algorithm for group assignment optimization</p>
</td></tr>
<tr><td><code id="popedControl_+3A_eastepsize">EAStepSize</code></td>
<td>
<p>Exchange Algorithm StepSize</p>
</td></tr>
<tr><td><code id="popedControl_+3A_eanumpoints">EANumPoints</code></td>
<td>
<p>Exchange Algorithm NumPoints</p>
</td></tr>
<tr><td><code id="popedControl_+3A_eaconvergencecriteria">EAConvergenceCriteria</code></td>
<td>
<p>Exchange Algorithm Convergence Limit/Criteria</p>
</td></tr>
<tr><td><code id="popedControl_+3A_beanoreplicates">bEANoReplicates</code></td>
<td>
<p>Avoid replicate samples when using Exchange Algorithm</p>
</td></tr>
<tr><td><code id="popedControl_+3A_bfgsprojectedgradienttol">BFGSProjectedGradientTol</code></td>
<td>
<p>BFGS Minimizer Convergence Criteria Normalized Projected Gradient Tolerance</p>
</td></tr>
<tr><td><code id="popedControl_+3A_bfgstolerancef">BFGSTolerancef</code></td>
<td>
<p>BFGS Minimizer Line Search Tolerance f</p>
</td></tr>
<tr><td><code id="popedControl_+3A_bfgstoleranceg">BFGSToleranceg</code></td>
<td>
<p>BFGS Minimizer Line Search Tolerance g</p>
</td></tr>
<tr><td><code id="popedControl_+3A_bfgstolerancex">BFGSTolerancex</code></td>
<td>
<p>BFGS Minimizer Line Search Tolerance x</p>
</td></tr>
<tr><td><code id="popedControl_+3A_ed_diff_it">ED_diff_it</code></td>
<td>
<p>Number of iterations in ED-optimal design to calculate convergence criteria</p>
</td></tr>
<tr><td><code id="popedControl_+3A_ed_diff_percent">ED_diff_percent</code></td>
<td>
<p>ED-optimal design convergence criteria in percent</p>
</td></tr>
<tr><td><code id="popedControl_+3A_line_search_it">line_search_it</code></td>
<td>
<p>Number of grid points in the line search</p>
</td></tr>
<tr><td><code id="popedControl_+3A_doptim_iter">Doptim_iter</code></td>
<td>
<p>Number of iterations of full Random search and full Stochastic Gradient if line search is not used</p>
</td></tr>
<tr><td><code id="popedControl_+3A_icompileoption">iCompileOption</code></td>
<td>
<p>Compile options for PopED
</p>

<ul>
<li><p> &quot;none&quot;/-1 = No compilation
</p>
</li>
<li><p> &quot;full/0 or 3 = Full compilation
</p>
</li>
<li><p> &quot;mcc&quot;/1 or 4 = Only using MCC (shared lib)
</p>
</li>
<li><p> &quot;mpi&quot;/2 or 5 = Only MPI,
</p>
</li></ul>

<p>When using numbers, option 0,1,2 runs PopED and option 3,4,5 stops
after compilation.
</p>
<p>When using characters, the option <code>compileOnly</code> determines if the
model is only compiled (and PopED is not run).</p>
</td></tr>
<tr><td><code id="popedControl_+3A_compileonly">compileOnly</code></td>
<td>
<p>logical; only compile the model, do not run
PopED (in conjunction with <code>iCompileOption</code>)</p>
</td></tr>
<tr><td><code id="popedControl_+3A_iuseparallelmethod">iUseParallelMethod</code></td>
<td>
<p>Parallel method to use
</p>

<ul>
<li><p> 0/&quot;matlab&quot;= Matlab PCT
</p>
</li>
<li><p> 1/&quot;mpi&quot; = MPI
</p>
</li></ul>
</td></tr>
<tr><td><code id="popedControl_+3A_mcc_dep">MCC_Dep</code></td>
<td>
<p>Additional dependencies used in MCC compilation (mat-files), if several space separated</p>
</td></tr>
<tr><td><code id="popedControl_+3A_strexecutename">strExecuteName</code></td>
<td>
<p>Compilation output executable name</p>
</td></tr>
<tr><td><code id="popedControl_+3A_inumprocesses">iNumProcesses</code></td>
<td>
<p>Number of processes to use when running in parallel (e.g. 3 = 2 workers, 1 job manager)</p>
</td></tr>
<tr><td><code id="popedControl_+3A_inumchunkdesignevals">iNumChunkDesignEvals</code></td>
<td>
<p>Number of design evaluations that should be evaluated in each process before getting new work from job manager</p>
</td></tr>
<tr><td><code id="popedControl_+3A_mat_out_pre">Mat_Out_Pre</code></td>
<td>
<p>The prefix of the output mat file to communicate with the executable</p>
</td></tr>
<tr><td><code id="popedControl_+3A_strextrarunoptions">strExtraRunOptions</code></td>
<td>
<p>Extra options send to e$g. the MPI executable or a batch script, see execute_parallel$m for more information and options</p>
</td></tr>
<tr><td><code id="popedControl_+3A_dpollresulttime">dPollResultTime</code></td>
<td>
<p>Polling time to check if the parallel execution is finished</p>
</td></tr>
<tr><td><code id="popedControl_+3A_strfunctioninputname">strFunctionInputName</code></td>
<td>
<p>The file containing the popedInput structure that should be used to evaluate the designs</p>
</td></tr>
<tr><td><code id="popedControl_+3A_bparallelrs">bParallelRS</code></td>
<td>
<p>If the random search is going to be executed in parallel</p>
</td></tr>
<tr><td><code id="popedControl_+3A_bparallelsg">bParallelSG</code></td>
<td>
<p>If the stochastic gradient search is going to be executed in parallel</p>
</td></tr>
<tr><td><code id="popedControl_+3A_bparallelmfea">bParallelMFEA</code></td>
<td>
<p>If the modified exchange algorithm is going to be executed in parallel</p>
</td></tr>
<tr><td><code id="popedControl_+3A_bparallells">bParallelLS</code></td>
<td>
<p>If the line search is going to be executed in parallel</p>
</td></tr>
<tr><td><code id="popedControl_+3A_groupsize">groupsize</code></td>
<td>
<p>Vector defining the size of the different groups (num individuals in each group).
If only one number then the number will be the same in every group.</p>
</td></tr>
<tr><td><code id="popedControl_+3A_time">time</code></td>
<td>
<p>string that represents the time in the dataset (ie xt)</p>
</td></tr>
<tr><td><code id="popedControl_+3A_timelow">timeLow</code></td>
<td>
<p>string that represents the lower design time (ie
minxt)</p>
</td></tr>
<tr><td><code id="popedControl_+3A_timehi">timeHi</code></td>
<td>
<p>string that represents the upper design time (ie
maxmt)</p>
</td></tr>
<tr><td><code id="popedControl_+3A_id">id</code></td>
<td>
<p>The id variable</p>
</td></tr>
<tr><td><code id="popedControl_+3A_m">m</code></td>
<td>
<p>Number of groups in the study.  Each individual in a group will have the same design.</p>
</td></tr>
<tr><td><code id="popedControl_+3A_x">x</code></td>
<td>
<p>A matrix defining the initial discrete values for the model 
Each row is a group/individual.</p>
</td></tr>
<tr><td><code id="popedControl_+3A_ni">ni</code></td>
<td>
<p>Vector defining the number of samples for each group.</p>
</td></tr>
<tr><td><code id="popedControl_+3A_maxni">maxni</code></td>
<td>

<ul>
<li> <p><b>******START OF DESIGN SPACE OPTIONS**********</b></p>
</li></ul>

<p>Max number of samples per group/individual</p>
</td></tr>
<tr><td><code id="popedControl_+3A_minni">minni</code></td>
<td>
<p>Min number of samples per group/individual</p>
</td></tr>
<tr><td><code id="popedControl_+3A_maxtotni">maxtotni</code></td>
<td>
<p>Number defining the maximum number of samples allowed in the experiment.</p>
</td></tr>
<tr><td><code id="popedControl_+3A_mintotni">mintotni</code></td>
<td>
<p>Number defining the minimum number of samples allowed in the experiment.</p>
</td></tr>
<tr><td><code id="popedControl_+3A_maxgroupsize">maxgroupsize</code></td>
<td>
<p>Vector defining the max size of the different groups (max number of individuals in each group)</p>
</td></tr>
<tr><td><code id="popedControl_+3A_mingroupsize">mingroupsize</code></td>
<td>
<p>Vector defining the min size of the different groups (min num individuals in each group) &ndash;</p>
</td></tr>
<tr><td><code id="popedControl_+3A_maxtotgroupsize">maxtotgroupsize</code></td>
<td>
<p>The total maximal groupsize over all groups</p>
</td></tr>
<tr><td><code id="popedControl_+3A_mintotgroupsize">mintotgroupsize</code></td>
<td>
<p>The total minimal groupsize over all groups</p>
</td></tr>
<tr><td><code id="popedControl_+3A_xt_space">xt_space</code></td>
<td>
<p>Cell array <code><a href="PopED.html#topic+cell">cell</a></code> defining the discrete variables allowed for each xt value.
Can also be a vector of values <code>c(1:10)</code> (same values allowed for all xt), or a list of lists 
<code>list(1:10, 2:23, 4:6)</code> (one for each value in xt in row major order or just for one row in xt, 
and all other rows will be duplicated).</p>
</td></tr>
<tr><td><code id="popedControl_+3A_a">a</code></td>
<td>
<p>Matrix defining the initial continuous covariate values. 
n_rows=number of groups, n_cols=number of covariates.
If the number of rows is one and the number of groups &gt; 1 then all groups are assigned the 
same values.</p>
</td></tr>
<tr><td><code id="popedControl_+3A_maxa">maxa</code></td>
<td>
<p>Vector defining the max value for each covariate. If a single value is supplied then
all a values are given the same max value</p>
</td></tr>
<tr><td><code id="popedControl_+3A_mina">mina</code></td>
<td>
<p>Vector defining the min value for each covariate. If a single value is supplied then
all a values are given the same max value</p>
</td></tr>
<tr><td><code id="popedControl_+3A_a_space">a_space</code></td>
<td>
<p>Cell array <code><a href="PopED.html#topic+cell">cell</a></code> defining the discrete variables allowed for each a value.
Can also be a list of values <code>list(1:10)</code> (same values allowed for all a), or a list of lists 
<code>list(1:10, 2:23, 4:6)</code> (one for each value in a).</p>
</td></tr>
<tr><td><code id="popedControl_+3A_x_space">x_space</code></td>
<td>
<p>Cell array <code><a href="PopED.html#topic+cell">cell</a></code> defining the discrete variables for each x value.</p>
</td></tr>
<tr><td><code id="popedControl_+3A_use_grouped_xt">use_grouped_xt</code></td>
<td>
<p>Group sampling times between groups so that each group has the same values (<code>TRUE</code> or <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="popedControl_+3A_grouped_xt">grouped_xt</code></td>
<td>
<p>Matrix defining the grouping of sample points. Matching integers mean that the points are matched.
Allows for finer control than <code>use_grouped_xt</code></p>
</td></tr>
<tr><td><code id="popedControl_+3A_use_grouped_a">use_grouped_a</code></td>
<td>
<p>Group continuous design variables between groups so that each group has the same values (<code>TRUE</code> or <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="popedControl_+3A_grouped_a">grouped_a</code></td>
<td>
<p>Matrix defining the grouping of continuous design variables. Matching integers mean that the values are matched.
Allows for finer control than <code>use_grouped_a</code>.</p>
</td></tr>
<tr><td><code id="popedControl_+3A_use_grouped_x">use_grouped_x</code></td>
<td>
<p>Group discrete design variables between groups so that each group has the same values (<code>TRUE</code> or <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="popedControl_+3A_grouped_x">grouped_x</code></td>
<td>
<p>Matrix defining the grouping of discrete design variables. Matching integers mean that the values are matched.
Allows for finer control than <code>use_grouped_x</code>.</p>
</td></tr>
<tr><td><code id="popedControl_+3A_our_zero">our_zero</code></td>
<td>
<p>Value to interpret as zero in design.</p>
</td></tr>
<tr><td><code id="popedControl_+3A_auto_pointer">auto_pointer</code></td>
<td>
<p>Filename and path, or function name, for the
Autocorrelation function, empty string means no autocorrelation</p>
</td></tr>
<tr><td><code id="popedControl_+3A_user_distribution_pointer">user_distribution_pointer</code></td>
<td>
<p>Filename and path, or function
name, for user defined distributions for E-family designs</p>
</td></tr>
<tr><td><code id="popedControl_+3A_minxt">minxt</code></td>
<td>
<p>Matrix or single value defining the minimum value for each xt sample.  If a single value is 
supplied then all xt values are given the same minimum value</p>
</td></tr>
<tr><td><code id="popedControl_+3A_maxxt">maxxt</code></td>
<td>
<p>Matrix or single value defining the maximum value for each xt sample.  If a single value is 
supplied then all xt values are given the same maximum value.</p>
</td></tr>
<tr><td><code id="popedControl_+3A_discrete_xt">discrete_xt</code></td>
<td>
<p>Cell array <code><a href="PopED.html#topic+cell">cell</a></code> defining the discrete variables allowed for each xt value.
Can also be a list of values <code>list(1:10)</code> (same values allowed for all xt), or a list of lists 
<code>list(1:10, 2:23, 4:6)</code> (one for each value in xt). See examples in <code><a href="PopED.html#topic+create_design_space">create_design_space</a></code>.</p>
</td></tr>
<tr><td><code id="popedControl_+3A_discrete_a">discrete_a</code></td>
<td>
<p>Cell array <code><a href="PopED.html#topic+cell">cell</a></code> defining the discrete variables allowed for each a value.
Can also be a list of values <code>list(1:10)</code> (same values allowed for all a), or a list of lists 
<code>list(1:10, 2:23, 4:6)</code> (one for each value in a). See examples in <code><a href="PopED.html#topic+create_design_space">create_design_space</a></code>.</p>
</td></tr>
<tr><td><code id="popedControl_+3A_fixres">fixRes</code></td>
<td>
<p>boolean; Fix the residuals to what is specified by
the model</p>
</td></tr>
<tr><td><code id="popedControl_+3A_script">script</code></td>
<td>
<p>write a PopED/rxode2 script that can be modified for
more fine control.  The default is NULL.
</p>
<p>When <code>script</code> is TRUE, the script is returned as a lines that
would be written to a file and with the class
<code>babelmixr2popedScript</code>. This allows it to be printed as the
script on screen.
</p>
<p>When <code>script</code> is a file name (with an R extension), the script is
written to that file.</p>
</td></tr>
<tr><td><code id="popedControl_+3A_overwrite">overwrite</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If <code>TRUE</code>, an existing file in place is allowed if it
it is both readable and writable.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="popedControl_+3A_literalfix">literalFix</code></td>
<td>
<p>boolean, substitute fixed population values as
literals and re-adjust ui and parameter estimates after
optimization; Default is 'TRUE'.</p>
</td></tr>
<tr><td><code id="popedControl_+3A_opt_xt">opt_xt</code></td>
<td>
<p>boolean to indicate if this is meant for optimizing times</p>
</td></tr>
<tr><td><code id="popedControl_+3A_opt_a">opt_a</code></td>
<td>
<p>boolean to indicate if this is meant for optimizing covariates</p>
</td></tr>
<tr><td><code id="popedControl_+3A_opt_x">opt_x</code></td>
<td>
<p>boolean to indicate if the discrete design variables
be optimized</p>
</td></tr>
<tr><td><code id="popedControl_+3A_opt_samps">opt_samps</code></td>
<td>
<p>boolean to indicate if the sample optimizer is
used (not implemented yet in <code>PopED</code>)</p>
</td></tr>
<tr><td><code id="popedControl_+3A_opttime">optTime</code></td>
<td>
<p>boolean to indicate if the global time indexer
inside of babelmixr2 is reset if the times are different. By
default this is <code>TRUE</code>.  If <code>FALSE</code> you can get slightly better
run times and possibly slightly different results.  When
<code>optTime</code> is <code>FALSE</code> the global indexer is reset every time the
PopED rxode2 is setup for a problem or when a poped dataset is
created.  You can manually reset with
<code>popedMultipleEndpointResetTimeIndex()</code></p>
</td></tr>
<tr><td><code id="popedControl_+3A_...">...</code></td>
<td>
<p>other parameters for PopED control</p>
</td></tr>
</table>


<h3>Value</h3>

<p>popedControl object
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='popedGetMultipleEndpointModelingTimes'>Get Multiple Endpoint Modeling Times</h2><span id='topic+popedGetMultipleEndpointModelingTimes'></span><span id='topic+popedMultipleEndpointIndexDataFrame'></span>

<h3>Description</h3>

<p>This function takes a vector of times and a corresponding vector
of IDs, groups the times by their IDs, initializes an internal
C++ global TimeIndexer, that is used to efficiently lookup the
final output from the rxode2 solve and then returns the sorted
unique times.
</p>
<p>The <code>popedMultipleEndpointIndexDataFrame()</code> function can be used
to visualize the internal data structure inside R, but it does
not show all the indexes in the case of time ties for a given
ID.  Rather it shows one of the indexs and the total number of
indexes in the data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popedGetMultipleEndpointModelingTimes(times, modelSwitch, sorted = FALSE)

popedMultipleEndpointIndexDataFrame(print = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="popedGetMultipleEndpointModelingTimes_+3A_times">times</code></td>
<td>
<p>A numeric vector of times.</p>
</td></tr>
<tr><td><code id="popedGetMultipleEndpointModelingTimes_+3A_modelswitch">modelSwitch</code></td>
<td>
<p>An integer vector of model switch indicator
corresponding to the times</p>
</td></tr>
<tr><td><code id="popedGetMultipleEndpointModelingTimes_+3A_sorted">sorted</code></td>
<td>
<p>A boolean indicating if the returned times should be sorted</p>
</td></tr>
<tr><td><code id="popedGetMultipleEndpointModelingTimes_+3A_print">print</code></td>
<td>
<p>boolean for <code>popedMultipleEndpointIndexDataFrame()</code>
when <code>TRUE</code> show each id/index per time even though it may not
reflect in the returned data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of unique times.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



times &lt;- c(1.1, 1.2, 1.3, 2.1, 2.2, 3.1)
modelSwitch &lt;- c(1, 1, 1, 2, 2, 3)
sortedTimes &lt;- popedGetMultipleEndpointModelingTimes(times, modelSwitch, TRUE)
print(sortedTimes)

# now show the output of the data frame representing the model
# switch to endpoint index

popedMultipleEndpointIndexDataFrame()

# now show a more complex example with overlaps etc.

times &lt;- c(1.1, 1.2, 1.3, 0.5, 2.2, 1.1, 0.75,0.75)
modelSwitch &lt;- c(1, 1, 1, 2, 2, 2, 3, 3)
sortedTimes &lt;- popedGetMultipleEndpointModelingTimes(times, modelSwitch, TRUE)
print(sortedTimes)

popedMultipleEndpointIndexDataFrame(TRUE) # Print to show individual matching


</code></pre>

<hr>
<h2 id='popedMultipleEndpointParam'>Populates Multiple Endpoint Parameters for internal solving</h2><span id='topic+popedMultipleEndpointParam'></span>

<h3>Description</h3>

<p>This function populates a numeric vector with parameters and
unique times and also populates the internal C++ global index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popedMultipleEndpointParam(p, times, modelSwitch, maxMT, optTime = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="popedMultipleEndpointParam_+3A_p">p</code></td>
<td>
<p>A numeric vector of parameters</p>
</td></tr>
<tr><td><code id="popedMultipleEndpointParam_+3A_times">times</code></td>
<td>
<p>A numeric vector of times</p>
</td></tr>
<tr><td><code id="popedMultipleEndpointParam_+3A_modelswitch">modelSwitch</code></td>
<td>
<p>An integer vector indicating model switches from PopED</p>
</td></tr>
<tr><td><code id="popedMultipleEndpointParam_+3A_maxmt">maxMT</code></td>
<td>
<p>An integer specifying the maximum number of time
points in the mtimes model</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> This function first uses the input times and model switches to
a global time indexer.
</p>
</li>
<li><p> It then creates a new numeric vector
that combines the input parameters and unique times.  If the
number of times is less than <code>maxMT</code>, the remaining elements are
filled with the maximum time.
</p>
</li></ul>



<h3>Value</h3>

<p>A numeric vector containing the parameters followed by
unique times, if the maximum number of times is greater than the
input this will append the maximum observed times in the
input. This assumes the first parameter is the id and is dropped
fro the output.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


p &lt;- c(1.0, 2.0, 3.0)
times &lt;- c(0.5, 1.5, 2.5)
modelSwitch &lt;- c(1, 2, 3)
maxMT &lt;- 5
popedMultipleEndpointParam(p, times, modelSwitch, maxMT)


</code></pre>

<hr>
<h2 id='popedMultipleEndpointResetTimeIndex'>Reset the Global Time Indexer for Multiple Endpoint Modeling</h2><span id='topic+popedMultipleEndpointResetTimeIndex'></span>

<h3>Description</h3>

<p>This clears the memory and resets the global time indexer used for
multiple endpoint modeling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popedMultipleEndpointResetTimeIndex()
</code></pre>


<h3>Value</h3>

<p>NULL, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


popedMultipleEndpointResetTimeIndex()


</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+rxModelVars'></span><span id='topic+rxUiGet'></span><span id='topic+nlmixr2Est'></span><span id='topic+.minfo'></span><span id='topic+nmObjGetFoceiControl'></span><span id='topic+getValidNlmixrCtl'></span><span id='topic+nmObjHandleControlObject'></span><span id='topic+nmObjGetControl'></span><span id='topic+nonmem2rx'></span><span id='topic+nmcov'></span><span id='topic+nmext'></span><span id='topic+nminfo'></span><span id='topic+nmtab'></span><span id='topic+nmxml'></span><span id='topic+as.nonmem2rx'></span><span id='topic+monolix2rx'></span><span id='topic+mlxtran'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>monolix2rx</dt><dd><p><code><a href="monolix2rx.html#topic+mlxtran">mlxtran</a></code>, <code><a href="monolix2rx.html#topic+monolix2rx">monolix2rx</a></code></p>
</dd>
<dt>nlmixr2est</dt><dd><p><code><a href="nlmixr2est.html#topic+getValidNlmixrControl">getValidNlmixrCtl</a></code>, <code><a href="nlmixr2est.html#topic+nlmixr2Est">nlmixr2Est</a></code>, <code><a href="nlmixr2est.html#topic+nmObjGetControl">nmObjGetControl</a></code>, <code><a href="nlmixr2est.html#topic+nmObjGetFoceiControl">nmObjGetFoceiControl</a></code>, <code><a href="nlmixr2est.html#topic+nmObjHandleControlObject">nmObjHandleControlObject</a></code></p>
</dd>
<dt>nonmem2rx</dt><dd><p><code><a href="nonmem2rx.html#topic+as.nonmem2rx">as.nonmem2rx</a></code>, <code><a href="nonmem2rx.html#topic+nmcov">nmcov</a></code>, <code><a href="nonmem2rx.html#topic+nmext">nmext</a></code>, <code><a href="nonmem2rx.html#topic+nminfo">nminfo</a></code>, <code><a href="nonmem2rx.html#topic+nmtab">nmtab</a></code>, <code><a href="nonmem2rx.html#topic+nmxml">nmxml</a></code>, <code><a href="nonmem2rx.html#topic+nonmem2rx">nonmem2rx</a></code></p>
</dd>
<dt>rxode2</dt><dd><p><code><a href="rxode2.html#topic+dot-minfo">.minfo</a></code>, <code><a href="rxode2.html#topic+rxModelVars">rxModelVars</a></code>, <code><a href="rxode2.html#topic+rxUiGet">rxUiGet</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rxToMonolix'>Convert RxODE syntax to monolix syntax</h2><span id='topic+rxToMonolix'></span>

<h3>Description</h3>

<p>Convert RxODE syntax to monolix syntax
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxToMonolix(x, ui)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxToMonolix_+3A_x">x</code></td>
<td>
<p>Expression</p>
</td></tr>
<tr><td><code id="rxToMonolix_+3A_ui">ui</code></td>
<td>
<p>rxode2 ui</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Monolix syntax
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='rxToNonmem'>Convert RxODE syntax to NONMEM syntax</h2><span id='topic+rxToNonmem'></span>

<h3>Description</h3>

<p>Convert RxODE syntax to NONMEM syntax
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxToNonmem(x, ui)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxToNonmem_+3A_x">x</code></td>
<td>
<p>Expression</p>
</td></tr>
<tr><td><code id="rxToNonmem_+3A_ui">ui</code></td>
<td>
<p>rxode2 ui</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NONMEM syntax
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='simplifyUnit'>Simplify units by removing repeated units from the numerator and denominator</h2><span id='topic+simplifyUnit'></span>

<h3>Description</h3>

<p>Simplify units by removing repeated units from the numerator and denominator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplifyUnit(numerator = "", denominator = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simplifyUnit_+3A_numerator">numerator</code></td>
<td>
<p>The numerator of the units (or the whole unit specification)</p>
</td></tr>
<tr><td><code id="simplifyUnit_+3A_denominator">denominator</code></td>
<td>
<p>The denominator of the units (or NULL if <code>numerator</code>
is the whole unit specification)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>NA</code> or <code>""</code> for <code>numerator</code> and <code>denominator</code>
are considered unitless.
</p>


<h3>Value</h3>

<p>The units specified with units that are in both the numerator and
denominator cancelled.
</p>


<h3>See Also</h3>

<p>Other Unit conversion: 
<code><a href="#topic+modelUnitConversion">modelUnitConversion</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simplifyUnit("kg", "kg/mL")
# units that don't match exactly are not cancelled
simplifyUnit("kg", "g/mL")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
