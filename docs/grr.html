<!DOCTYPE html><html lang="en"><head><title>Help for package grr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {grr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#grr'><p>Alternative Implementations of Base R Functions</p></a></li>
<li><a href='#convertBase'><p>Convert string representations of numbers in any base to any other base.</p></a></li>
<li><a href='#extract'><p>Extract/return parts of objects</p></a></li>
<li><a href='#matches'><p>Value Matching</p></a></li>
<li><a href='#order2'><p>Ordering vectors</p></a></li>
<li><a href='#sample2'><p>A wrapper for <code>sample.int</code> and <code>extract</code> that makes it easy to quickly sample rows from any object,</p>
including Matrix and sparse matrix objects.</a></li>
<li><a href='#sort2'><p>Sorting vectors</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Alternative Implementations of Base R Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.5</td>
</tr>
<tr>
<td>Author:</td>
<td>Craig Varrichio &lt;canthony427@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Craig Varrichio &lt;canthony427@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Alternative implementations of some base R functions, including sort, order, and match.  Functions are simplified but can be faster or have other advantages.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-08-26 16:28:14 UTC; Craig_Varrichio</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-08-26 20:35:38</td>
</tr>
</table>
<hr>
<h2 id='grr'>Alternative Implementations of Base R Functions</h2><span id='topic+grr'></span><span id='topic+grr-package'></span>

<h3>Description</h3>

<p>Alternative implementations of some base R functions, including sort, order, and match.  Functions are
simplified but can be faster or have other advantages.  See the documentation of individual functions
for details and benchmarks.
</p>


<h3>Details</h3>

<p>Note that these functions cannot be considered drop-in replacements for the functions in base <code>R</code>.  
They do not implement all the same parameters and do not work for all data types.  Utilize these 
with caution in specialized applications that require them.
</p>

<hr>
<h2 id='convertBase'>Convert string representations of numbers in any base to any other base.</h2><span id='topic+convertBase'></span>

<h3>Description</h3>

<p>Convert string representations of numbers in any base to any other base.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertBase(x, base1 = 10, base2 = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convertBase_+3A_x">x</code></td>
<td>
<p>a vector of integers or strings to be converted</p>
</td></tr>
<tr><td><code id="convertBase_+3A_base1">base1</code></td>
<td>
<p>the base of x</p>
</td></tr>
<tr><td><code id="convertBase_+3A_base2">base2</code></td>
<td>
<p>the base of the output</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+as.octmode">as.octmode</a></code>
</p>
<p><code><a href="base.html#topic+as.hexmode">as.hexmode</a></code>
</p>
<p><code><a href="base.html#topic+strtoi">strtoi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
identical(convertBase(1234,base2=8),as.character(as.octmode(1234)))

convertBase(17771,base1=8,base2=30)
convertBase(17771,base1=8,base2=10)
convertBase(8185,base1=10,base2=30)

</code></pre>

<hr>
<h2 id='extract'>Extract/return parts of objects</h2><span id='topic+extract'></span>

<h3>Description</h3>

<p>Alternative to built-in <code><a href="base.html#topic+Extract">Extract</a></code> or <code>[</code>.  Allows for 
extraction operations that are ambivalent to the data type of the object. For 
example, <code>extract(x,i)</code> will work on lists, vectors, data frames, 
matrices, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract(x, i = NULL, j = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_+3A_x">x</code></td>
<td>
<p>object from which to extract elements</p>
</td></tr>
<tr><td><code id="extract_+3A_i">i</code>, <code id="extract_+3A_j">j</code></td>
<td>
<p>indices specifying elements to extract.  Can be <code>numeric</code>,
<code>character</code>, or <code>logical</code> vectors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extraction is 2-100x faster on data frames than with the built in operation - 
but does not preserve row names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Typically about twice as fast on normal subselections
orders&lt;-data.frame(orderNum=1:1e5,
 sku=sample(1e3, 1e5, TRUE),
 customer=sample(1e4,1e5,TRUE))
a&lt;-sample(1e5,1e4)
system.time(b&lt;-orders[a,])
system.time(c&lt;-extract(orders,a))
rownames(b)&lt;-NULL
rownames(c)&lt;-NULL
identical(b,c)

#Speedup increases to 50-100x with oversampling 
a&lt;-sample(1e5,1e6,TRUE)
system.time(b&lt;-orders[a,])
system.time(c&lt;-extract(orders,a))
rownames(b)&lt;-NULL
rownames(c)&lt;-NULL
identical(b,c)

#Can create function calls that work for multiple data types
alist&lt;-as.list(1:50)
avector&lt;-1:50
extract(alist,1:5)
extract(avector,1:5)
extract(orders,1:5)#'

## Not run: 
orders&lt;-data.frame(orderNum=as.character(sample(1e5, 1e6, TRUE)),
 sku=sample(1e3, 1e6, TRUE),
 customer=sample(1e4,1e6,TRUE))
system.time(a&lt;-sample(1e6,1e7,TRUE))
system.time(b&lt;-orders[a,])
system.time(c&lt;-extract(orders,a))

## End(Not run)
</code></pre>

<hr>
<h2 id='matches'>Value Matching</h2><span id='topic+matches'></span>

<h3>Description</h3>

<p>Returns a lookup table or list of the positions of ALL matches of its first
argument in its second and vice versa. Similar to <code><a href="base.html#topic+match">match</a></code>, though
that function only returns the first match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matches(x, y, all.x = TRUE, all.y = TRUE, list = FALSE, indexes = TRUE,
  nomatch = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matches_+3A_x">x</code></td>
<td>
<p>vector.  The values to be matched.  Long vectors are not currently
supported.</p>
</td></tr>
<tr><td><code id="matches_+3A_y">y</code></td>
<td>
<p>vector.  The values to be matched.  Long vectors are not currently
supported.</p>
</td></tr>
<tr><td><code id="matches_+3A_all.x">all.x</code></td>
<td>
<p>logical; if <code>TRUE</code>, then each value in <code>x</code> will be
included even if it has no matching values in <code>y</code></p>
</td></tr>
<tr><td><code id="matches_+3A_all.y">all.y</code></td>
<td>
<p>logical; if <code>TRUE</code>, then each value in <code>y</code> will be
included even if it has no matching values in <code>x</code></p>
</td></tr>
<tr><td><code id="matches_+3A_list">list</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the result will be returned as a list
of vectors, each vector being the matching values in y. If <code>FALSE</code>,
result is returned as a data frame with repeated values for each match.</p>
</td></tr>
<tr><td><code id="matches_+3A_indexes">indexes</code></td>
<td>
<p>logical.  Whether to return the indices of the matches or the
actual values.</p>
</td></tr>
<tr><td><code id="matches_+3A_nomatch">nomatch</code></td>
<td>
<p>the value to be returned in the case when no match is found.
If not provided and <code>indexes=TRUE</code>, items with no match will be
represented as <code>NA</code>.  If set to <code>NULL</code>, items with no match will
be set to an index value of <code>length+1</code>.  If indexes=FALSE, they will
default to <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This behavior can be imitated by using joins to create lookup tables, but
<code>matches</code> is simpler and faster: usually faster than the best joins in
other packages and thousands of times faster than the built in
<code><a href="base.html#topic+merge">merge</a></code>.
</p>
<p><code>all.x/all.y</code> correspond to the four types of database joins in the
following way:
</p>
 <dl>
<dt>left</dt><dd><p><code>all.x=TRUE</code>, <code>all.y=FALSE</code></p>
</dd> 
<dt>right</dt><dd><p><code>all.x=FALSE</code>, <code>all.y=TRUE</code></p>
</dd> 
<dt>inner</dt><dd><p><code>all.x=FALSE</code>, <code>all.y=FALSE</code></p>
</dd> 
<dt>full</dt><dd><p><code>all.x=TRUE</code>, <code>all.y=TRUE</code></p>
</dd> </dl>

<p>Note that <code>NA</code> values will match other <code>NA</code> values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>one&lt;-as.integer(1:10000)
two&lt;-as.integer(sample(1:10000,1e3,TRUE))
system.time(a&lt;-lapply(one, function (x) which(two %in% x)))
system.time(b&lt;-matches(one,two,all.y=FALSE,list=TRUE))

#Only retain items from one with a match in two
b&lt;-matches(one,two,all.x=FALSE,all.y=FALSE,list=TRUE)
length(b)==length(unique(two))

one&lt;-round(runif(1e3),3)
two&lt;-round(runif(1e3),3)
system.time(a&lt;-lapply(one, function (x) which(two %in% x)))
system.time(b&lt;-matches(one,two,all.y=FALSE,list=TRUE))
 
one&lt;-as.character(1:1e5)
two&lt;-as.character(sample(1:1e5,1e5,TRUE))
system.time(b&lt;-matches(one,two,list=FALSE))
system.time(c&lt;-merge(data.frame(key=one),data.frame(key=two),all=TRUE))

## Not run: 
one&lt;-as.integer(1:1000000)
two&lt;-as.integer(sample(1:1000000,1e5,TRUE))
system.time(b&lt;-matches(one,two,indexes=FALSE))
if(requireNamespace("dplyr",quietly=TRUE))
 system.time(c&lt;-dplyr::full_join(data.frame(key=one),data.frame(key=two)))
if(require(data.table,quietly=TRUE))
 system.time(d&lt;-merge(data.table(data.frame(key=one))
             ,data.table(data.frame(key=two))
             ,by='key',all=TRUE,allow.cartesian=TRUE))

one&lt;-as.character(1:1000000)
two&lt;-as.character(sample(1:1000000,1e5,TRUE))
system.time(a&lt;-merge(one,two)) #Times out
system.time(b&lt;-matches(one,two,indexes=FALSE))
if(requireNamespace("dplyr",quietly=TRUE))
 system.time(c&lt;-dplyr::full_join(data.frame(key=one),data.frame(key=two)))#'
if(require(data.table,quietly=TRUE))
{
 system.time(d&lt;-merge(data.table(data.frame(key=one))
             ,data.table(data.frame(key=two))
             ,by='key',all=TRUE,allow.cartesian=TRUE))
 identical(b[,1],as.character(d$key))
}

## End(Not run)
</code></pre>

<hr>
<h2 id='order2'>Ordering vectors</h2><span id='topic+order2'></span>

<h3>Description</h3>

<p>Simplified implementation of <code><a href="base.html#topic+order">order</a></code>.  For large vectors, typically is about 3x faster for 
numbers and 20x faster for characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order2(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="order2_+3A_x">x</code></td>
<td>
<p>a vector of class numeric, integer, character, factor, or logical.  Long vectors are not supported.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>chars&lt;-as.character(sample(1e3,1e4,TRUE))
system.time(a&lt;-order(chars))
system.time(b&lt;-order2(chars))
identical(chars[a],chars[b])

ints&lt;-as.integer(sample(1e3,1e4,TRUE))
system.time(a&lt;-order(ints))
system.time(b&lt;-order2(ints))
identical(ints[a],ints[b])

nums&lt;-runif(1e4)
system.time(a&lt;-order(nums))
system.time(b&lt;-order2(nums))
identical(nums[a],nums[b])

logs&lt;-as.logical(sample(0:1,1e6,TRUE))
system.time(a&lt;-order(logs))
system.time(b&lt;-order2(logs))
identical(logs[a],logs[b])

facts&lt;-as.factor(as.character(sample(1e3,1e4,TRUE)))
system.time(a&lt;-order(facts))
system.time(b&lt;-order2(facts))
identical(facts[a],facts[b])

#How are special values like NA and Inf handled?
#For numerics, values sort intuitively, with the important note that NA and
#NaN will come after all real numbers but before Inf.
(function (x) x[order2(x)])(c(1,2,NA,NaN,Inf,-Inf))
#For characters, values sort correctly with NA at the end.
(function (x) x[order2(x)])(c('C','B',NA,'A'))
#For factors, values sort correctly with NA at the end.
(function (x) x[order2(x)])(as.factor(c('C','B',NA,'A')))


#Ordering a data frame using order2
df&lt;-data.frame(one=as.character(1:4e5),
   two=sample(1:1e5,4e5,TRUE),
   three=sample(letters,4e5,TRUE),stringsAsFactors=FALSE)
system.time(a&lt;-df[order(df$one),])  
system.time(b&lt;-df[order2(df$one),])
system.time(a&lt;-df[order(df$two),])  
system.time(b&lt;-df[order2(df$two),])

## Not run: 
chars&lt;-as.character(sample(1e5,1e6,TRUE))
system.time(a&lt;-order(chars))
system.time(b&lt;-order2(chars)) 

ints&lt;-as.integer(sample(1e5,1e6,TRUE))
system.time(result&lt;-order(ints))
system.time(result&lt;-order2(ints))

nums&lt;-runif(1e6)
system.time(result&lt;-order(nums))
system.time(result&lt;-order2(nums)) 

logs&lt;-as.logical(sample(0:1,1e7,TRUE))
system.time(result&lt;-order(logs))
system.time(result&lt;-order2(logs))

facts&lt;-as.factor(as.character(sample(1e5,1e6,TRUE)))
system.time(a&lt;-order(facts))
system.time(b&lt;-order2(facts))
identical(facts[a],facts[b])



## End(Not run)
</code></pre>

<hr>
<h2 id='sample2'>A wrapper for <code><a href="base.html#topic+sample.int">sample.int</a></code> and <code><a href="#topic+extract">extract</a></code> that makes it easy to quickly sample rows from any object,
including Matrix and sparse matrix objects.</h2><span id='topic+sample2'></span>

<h3>Description</h3>

<p>Row names are not preserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample2(x, size, replace = FALSE, prob = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample2_+3A_x">x</code></td>
<td>
<p>object from which to extract elements</p>
</td></tr>
<tr><td><code id="sample2_+3A_size">size</code></td>
<td>
<p>a positive number, the number of items to choose.</p>
</td></tr>
<tr><td><code id="sample2_+3A_replace">replace</code></td>
<td>
<p>Should sampling be with replacement?</p>
</td></tr>
<tr><td><code id="sample2_+3A_prob">prob</code></td>
<td>
<p>A vector of probability weights for obtaining the elements of the vector being sampled.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#Sampling from a list
l1&lt;-as.list(1:1e6)
b&lt;-sample2(l1,1e5)

#Sampling from a data frame
orders&lt;-data.frame(orderNum=sample(1e5, 1e6, TRUE),
   sku=sample(1e3, 1e6, TRUE),
   customer=sample(1e4,1e6,TRUE),stringsAsFactors=FALSE)
   
a&lt;-sample2(orders,250000) 

#With oversampling sample2 can be much faster than the alternatives,
#with the caveat that it does not preserve row names.
system.time(a&lt;-sample2(orders,2000000,TRUE))
system.time(b&lt;-orders[sample.int(nrow(orders),2000000,TRUE),])
## Not run: 

system.time(c&lt;-dplyr::sample_n(orders,2000000,replace=TRUE))

#Can quickly sample for sparse matrices while preserving sparsity
sm&lt;-rsparsematrix(20000000,10000,density=.0001)
sm2&lt;-sample2(sm,1000000)

## End(Not run)
</code></pre>

<hr>
<h2 id='sort2'>Sorting vectors</h2><span id='topic+sort2'></span>

<h3>Description</h3>

<p>Simplified implementation of <code><a href="base.html#topic+sort">sort</a></code>. For large vectors,
typically is about 2x faster for numbers and 20x faster for characters and
factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort2(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sort2_+3A_x">x</code></td>
<td>
<p>a vector of class numeric, integer, character, factor, or logical. 
Long vectors are not supported.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>chars&lt;-as.character(sample(1e3,1e4,TRUE))
system.time(a&lt;-sort(chars))
system.time(b&lt;-sort2(chars))
identical(a,b)  
 
ints&lt;-as.integer(sample(1e3,1e4,TRUE))
system.time(a&lt;-sort(ints))
system.time(b&lt;-sort2(ints))
identical(a,b)
 
nums&lt;-runif(1e4)
system.time(a&lt;-sort(nums))
system.time(b&lt;-sort2(nums))
identical(a,b)

logs&lt;-as.logical(sample(0:1,1e6,TRUE))
system.time(result&lt;-sort(logs))
system.time(result&lt;-sort2(logs))

facts&lt;-as.factor(as.character(sample(1e3,1e4,TRUE)))
system.time(a&lt;-sort(facts))
system.time(b&lt;-sort2(facts))
identical(a,b)

#How are special values like NA and Inf handled?
#For numerics, values sort intuitively, with the important note that NA and
#NaN will come after all real numbers but before Inf.
sort2(c(1,2,NA,NaN,Inf,-Inf))
#For characters, values sort correctly with NA at the end.
sort2(c('C','B',NA,'A'))
#For factors, values sort correctly with NA at the end
sort2(as.factor(c('C','B',NA,'A')))

## Not run: 
chars&lt;-as.character(sample(1e5,1e6,TRUE))
system.time(a&lt;-sort(chars))
system.time(b&lt;-sort2(chars))

ints&lt;-as.integer(sample(1e5,1e6,TRUE))
system.time(result&lt;-sort(ints))
system.time(result&lt;-sort2(ints))

nums&lt;-runif(1e6)
system.time(result&lt;-sort(nums))
system.time(result&lt;-sort2(nums))

logs&lt;-as.logical(sample(0:1,1e7,TRUE))
system.time(result&lt;-sort(logs))
system.time(result&lt;-sort2(logs))

facts&lt;-as.factor(as.character(sample(1e5,1e6,TRUE)))
system.time(a&lt;-sort(facts))
system.time(b&lt;-sort2(facts))

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
