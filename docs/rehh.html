<!DOCTYPE html><html><head><title>Help for package rehh</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rehh}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#allelefurcation-class'><p>An S4 class containing furcation trees for one allele</p>
of a focal marker</a></li>
<li><a href='#as.newick'><p>Convert a furcation tree into Newick format</p></a></li>
<li><a href='#calc_candidate_regions'><p>Determine candidate regions of selection</p></a></li>
<li><a href='#calc_ehh'><p>EHH and iHH computation for a given focal marker</p></a></li>
<li><a href='#calc_ehhs'><p>EHHS and iES computation for a given focal marker</p></a></li>
<li><a href='#calc_furcation'><p>calculate furcation trees around a focal marker</p></a></li>
<li><a href='#calc_haplen'><p>Calculate length of longest shared haplotypes around a focal marker</p></a></li>
<li><a href='#calc_pairwise_haplen'><p>Calculate pairwise shared haplotype length between all chromosomes</p></a></li>
<li><a href='#calc_region_stats'><p>Calculate score statistics for given regions</p></a></li>
<li><a href='#calc_sfs_tests'><p>Calculate site frequency spectrum test statistics</p></a></li>
<li><a href='#data2haplohh'><p>Convert data from input file to an object of class haplohh</p></a></li>
<li><a href='#distribplot'><p>Plot distribution of standardized iHS, Rsb or XP-EHH values</p></a></li>
<li><a href='#extract_regions'><p>Extract regions from a scan</p></a></li>
<li><a href='#freqbinplot'><p>Plot of unstandardized iHS within frequency bins</p></a></li>
<li><a href='#ftree-class'><p>An S4 class to represent a furcation tree on one side of one allele of a focal marker</p></a></li>
<li><a href='#furcation-class'><p>An S4 class representing the complete furcation pattern around a focal marker.</p></a></li>
<li><a href='#haplen-class'><p>class for haplotype length</p></a></li>
<li><a href='#haplohh_cgu_bta12'><p>Example of an <code>haplohh</code> object</p></a></li>
<li><a href='#haplohh-class'><p>Class &quot;haplohh&quot;</p></a></li>
<li><a href='#haplohh2sweepfinder'><p>Translate object of <code>haplohh-class</code> into SweepFinder format</p></a></li>
<li><a href='#ies2xpehh'><p>Compute XP-EHH</p></a></li>
<li><a href='#ihh2ihs'><p>Compute iHS</p></a></li>
<li><a href='#ines2rsb'><p>Compute Rsb</p></a></li>
<li><a href='#make.example.files'><p>Copy example input files into current working directory</p></a></li>
<li><a href='#manhattanplot'><p>Manhattan plot of iHS, XP-EHH or Rsb over a genome.</p></a></li>
<li><a href='#plot.ehh'><p>Plot EHH around a focal marker</p></a></li>
<li><a href='#plot.ehhs'><p>Plot EHHS around a focal marker</p></a></li>
<li><a href='#plot.furcation'><p>Plots furcation trees around a focal marker</p></a></li>
<li><a href='#plot.haplen'><p>Plot the length of extended haplotypes around a focal marker</p></a></li>
<li><a href='#plot.haplohh'><p>Plot the variants of a haplohh object</p></a></li>
<li><a href='#rehh-package'><p>rehh: Searching for Footprints of Selection using 'Extended Haplotype</p>
Homozygosity' Based Tests</a></li>
<li><a href='#remove.example.files'><p>Remove example files from current working directory.</p></a></li>
<li><a href='#scan_hh'><p>Compute iHH, iES and inES over a whole chromosome</p></a></li>
<li><a href='#scan_hh_full'><p>Compute iHH, iES and inES over a whole chromosome without cut-offs</p></a></li>
<li><a href='#subset.haplohh'><p>Subsets object of <code>haplohh-class</code></p></a></li>
<li><a href='#update_haplohh'><p>Update object of class haplohh</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>3.2.2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Title:</td>
<td>Searching for Footprints of Selection using 'Extended Haplotype
Homozygosity' Based Tests</td>
</tr>
<tr>
<td>Description:</td>
<td>Population genetic data such as 'Single Nucleotide
        Polymorphisms' (SNPs) is often used to identify genomic regions
        that have been under recent natural or artificial selection
        and might provide clues about the molecular mechanisms of adaptation. 
        One approach, the concept of an 'Extended Haplotype Homozygosity' (EHH), 
        introduced by (Sabeti 2002) &lt;<a href="https://doi.org/10.1038%2Fnature01140">doi:10.1038/nature01140</a>&gt;, has given rise to 
        several statistics designed for whole genome scans. 
        The package provides functions to compute three of these,
        namely: 'iHS' (Voight 2006) &lt;<a href="https://doi.org/10.1371%2Fjournal.pbio.0040072">doi:10.1371/journal.pbio.0040072</a>&gt; for
        detecting positive or 'Darwinian' selection within a single population as well as
        'Rsb' (Tang 2007) &lt;<a href="https://doi.org/10.1371%2Fjournal.pbio.0050171">doi:10.1371/journal.pbio.0050171</a>&gt; and 
        'XP-EHH' (Sabeti 2007) &lt;<a href="https://doi.org/10.1038%2Fnature06250">doi:10.1038/nature06250</a>&gt;, targeted
        at differential selection between two populations. 
        Various plotting functions are included to facilitate
        visualization and interpretation of these statistics.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, rehh.data</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ape, bookdown, data.table, gap, knitr, qqman, rmarkdown,
R.utils, testthat, vcfR</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-15 13:21:20 UTC; alex</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://CRAN.R-project.org/package=rehh">https://CRAN.R-project.org/package=rehh</a>,
<a href="https://gitlab.com/oneoverx/rehh">https://gitlab.com/oneoverx/rehh</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.com/oneoverx/rehh/-/issues">https://gitlab.com/oneoverx/rehh/-/issues</a></td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Klassmann [aut, cre],
  Mathieu Gautier [aut],
  Renaud Vitalis [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Klassmann &lt;rehh@oneoverx.eu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-15 13:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='allelefurcation-class'>An S4 class containing furcation trees for one allele
of a focal marker</h2><span id='topic+allelefurcation-class'></span><span id='topic+allelefurcation'></span>

<h3>Description</h3>

<p>An S4 class containing the furcation trees
for both sides of a focal marker for one allele.
</p>


<h3>Slots</h3>


<dl>
<dt><code>allele</code></dt><dd><p>the allele of the focal marker.</p>
</dd>
<dt><code>description</code></dt><dd><p>&quot;ancestral&quot;, &quot;derived&quot;, &quot;major&quot;, &quot;minor&quot;, etc.</p>
</dd>
<dt><code>count</code></dt><dd><p>the number of chromosomes with that allele.</p>
</dd>
<dt><code>left</code></dt><dd><p>furcation tree to the left of the marker.</p>
</dd>
<dt><code>right</code></dt><dd><p>furcation tree to the right of the marker.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+ftree">ftree</a></code>, <code><a href="#topic+furcation">furcation</a></code>
</p>

<hr>
<h2 id='as.newick'>Convert a furcation tree into Newick format</h2><span id='topic+as.newick'></span>

<h3>Description</h3>

<p>Convert a furcation tree into Newick format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.newick(furcation, allele = 0, side, hap.names = seq_len(furcation@nhap))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.newick_+3A_furcation">furcation</code></td>
<td>
<p>an object of <code><a href="#topic+furcation-class">furcation-class</a></code>.</p>
</td></tr>
<tr><td><code id="as.newick_+3A_allele">allele</code></td>
<td>
<p>the allele to be considered (default 0).</p>
</td></tr>
<tr><td><code id="as.newick_+3A_side">side</code></td>
<td>
<p>side (either <code>"left"</code> or <code>"right"</code>).</p>
</td></tr>
<tr><td><code id="as.newick_+3A_hap.names">hap.names</code></td>
<td>
<p>names/labels of chromosomes in haplotype data file.
Per default haplotypes are numbered by their order in the input file.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ftree-class">ftree-class</a></code>, <code><a href="#topic+calc_furcation">calc_furcation</a></code>,
<code><a href="#topic+plot.furcation">plot.furcation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#example haplohh object (280 haplotypes, 1424 SNPs)
#see ?haplohh_cgu_bta12 for details
data(haplohh_cgu_bta12)
#calculate furcation for the marker "F1205400"
#which displays a strong signal of selection
f &lt;- calc_furcation(haplohh_cgu_bta12, mrk = "F1205400")
#get left tree of ancestral allele (coded as '0')
as.newick(f, 0, "left")
</code></pre>

<hr>
<h2 id='calc_candidate_regions'>Determine candidate regions of selection</h2><span id='topic+calc_candidate_regions'></span>

<h3>Description</h3>

<p>Determine candidate regions of selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_candidate_regions(
  scan,
  threshold = NA,
  pval = FALSE,
  ignore_sign = FALSE,
  window_size = 1e+06,
  overlap = 0,
  right = TRUE,
  min_n_mrk = 1,
  min_n_extr_mrk = 1,
  min_perc_extr_mrk = 0,
  join_neighbors = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_candidate_regions_+3A_scan">scan</code></td>
<td>
<p>a data frame containing scores (output of <code><a href="#topic+ihh2ihs">ihh2ihs</a></code>, <code><a href="#topic+ines2rsb">ines2rsb</a></code> or <code><a href="#topic+ies2xpehh">ies2xpehh</a></code>).</p>
</td></tr>
<tr><td><code id="calc_candidate_regions_+3A_threshold">threshold</code></td>
<td>
<p>boundary score above which markers are defined as &quot;extreme&quot;.</p>
</td></tr>
<tr><td><code id="calc_candidate_regions_+3A_pval">pval</code></td>
<td>
<p>logical. If <code>TRUE</code> use the (negative log-) p-value instead of the score.</p>
</td></tr>
<tr><td><code id="calc_candidate_regions_+3A_ignore_sign">ignore_sign</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), take absolute values of score.</p>
</td></tr>
<tr><td><code id="calc_candidate_regions_+3A_window_size">window_size</code></td>
<td>
<p>size of sliding windows. If set to 1, no windows
are constructed and only the individual extremal markers are reported.</p>
</td></tr>
<tr><td><code id="calc_candidate_regions_+3A_overlap">overlap</code></td>
<td>
<p>size of window overlap (default 0, i.e. no overlap).</p>
</td></tr>
<tr><td><code id="calc_candidate_regions_+3A_right">right</code></td>
<td>
<p>logical, indicating if the windows should be closed on the right (and open on the left) or vice versa.</p>
</td></tr>
<tr><td><code id="calc_candidate_regions_+3A_min_n_mrk">min_n_mrk</code></td>
<td>
<p>minimum number of markers per window.</p>
</td></tr>
<tr><td><code id="calc_candidate_regions_+3A_min_n_extr_mrk">min_n_extr_mrk</code></td>
<td>
<p>minimum number of markers with extreme
value in a window.</p>
</td></tr>
<tr><td><code id="calc_candidate_regions_+3A_min_perc_extr_mrk">min_perc_extr_mrk</code></td>
<td>
<p>minimum percentage of extremal markers among all markers.</p>
</td></tr>
<tr><td><code id="calc_candidate_regions_+3A_join_neighbors">join_neighbors</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), merge neighboring windows with
extreme values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is no generally agreed method how to determine genomic
regions which might have been under recent selection. Since selection tends
to yield clusters of markers with outlier values, a common approach is
to search for regions with an elevated number or fraction
of outlier or extremal markers.
This function allows to set three conditions a window must fulfill
in order to classify as candidate region:
</p>

<ul>
<li> <p><code>min_n_mrk</code> a minimum number of (any) markers.
</p>
</li>
<li> <p><code>min_n_extr_mrk</code> a minimum number of markers with outlier / extreme value.
</p>
</li>
<li> <p><code>min_perc_extr_mrk</code> a minimum percentage of extremal markers among all markers.
</p>
</li></ul>

<p>&quot;Extreme&quot; markers are defined by having a score above the specified <code>threshold</code>.
</p>


<h3>Value</h3>

<p>A data frame with chromosomal regions, i.e. windows that fulfill
the necessary conditions to qualify as candidate regions under selection.
For each region the overall number of markers, their mean and maximum,
the number of markers with extremal values, their percentage of all markers
and their average are reported.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_region_stats">calc_region_stats</a></code>
</p>

<hr>
<h2 id='calc_ehh'>EHH and iHH computation for a given focal marker</h2><span id='topic+calc_ehh'></span><span id='topic+ehh-class'></span><span id='topic+ehh'></span>

<h3>Description</h3>

<p>Compute Extended Haplotype Homozygosity (EHH) and integrated EHH (iHH) for a given focal marker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_ehh(
  haplohh,
  mrk,
  limhaplo = 2,
  limhomohaplo = 2,
  limehh = 0.05,
  include_zero_values = FALSE,
  include_nhaplo = FALSE,
  phased = TRUE,
  polarized = TRUE,
  scalegap = NA,
  maxgap = NA,
  discard_integration_at_border = TRUE,
  lower_y_bound = limehh,
  interpolate = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_ehh_+3A_haplohh">haplohh</code></td>
<td>
<p>an object of class <code>haplohh</code> (see <code><a href="#topic+data2haplohh">data2haplohh</a></code>).</p>
</td></tr>
<tr><td><code id="calc_ehh_+3A_mrk">mrk</code></td>
<td>
<p>integer representing the number of the focal marker within the haplohh object
or string representing its ID/name.</p>
</td></tr>
<tr><td><code id="calc_ehh_+3A_limhaplo">limhaplo</code></td>
<td>
<p>if there are less than <code>limhaplo</code> chromosomes that can be used for
the calculation of EHH, the calculation is stopped. The option is intended for the case of missing data,
which leads to the successive exclusion of haplotypes: the further away from the focal marker
the less haplotypes contribute to EHH.</p>
</td></tr>
<tr><td><code id="calc_ehh_+3A_limhomohaplo">limhomohaplo</code></td>
<td>
<p>if there are less than <code>limhomohaplo</code> homozygous chromosomes, the
calculation is stopped. This option is intended for unphased data and should be invoked only
if relatively low frequency variants are not filtered subsequently (see main vignette and Klassmann et al. 2020).</p>
</td></tr>
<tr><td><code id="calc_ehh_+3A_limehh">limehh</code></td>
<td>
<p>limit at which EHH stops to be evaluated</p>
</td></tr>
<tr><td><code id="calc_ehh_+3A_include_zero_values">include_zero_values</code></td>
<td>
<p>logical. If <code>FALSE</code>, return values only for those positions where the calculation is
actually performed, i.e. until stopped by reaching either <code>limehh</code> or <code>limhaplo</code>. If <code>TRUE</code>, report EHH values for
all markers, the additional ones being zero.</p>
</td></tr>
<tr><td><code id="calc_ehh_+3A_include_nhaplo">include_nhaplo</code></td>
<td>
<p>logical. If <code>TRUE</code>, report the number of evaluated haplotypes at each marker
(only informative, if missing data leads to a decrease of evaluated haplotypes).</p>
</td></tr>
<tr><td><code id="calc_ehh_+3A_phased">phased</code></td>
<td>
<p>logical. If <code>TRUE</code> (default) chromosomes are expected to be phased. If <code>FALSE</code>, the haplotype data is assumed to
consist of pairwise ordered chromosomes belonging to diploid individuals.
EHH is then estimated over individuals which are homozygous at the focal marker.</p>
</td></tr>
<tr><td><code id="calc_ehh_+3A_polarized">polarized</code></td>
<td>
<p>logical. <code>TRUE</code> by default. If <code>FALSE</code>, use major and minor allele instead of ancestral and derived. If there
are more than two alleles then the minor allele refers to the second-most frequent allele.</p>
</td></tr>
<tr><td><code id="calc_ehh_+3A_scalegap">scalegap</code></td>
<td>
<p>scale or cap gaps larger than the specified size to the specified size (default=<code>NA</code>, i.e. no scaling).</p>
</td></tr>
<tr><td><code id="calc_ehh_+3A_maxgap">maxgap</code></td>
<td>
<p>maximum allowed gap in bp between two markers. If exceeded, further calculation of EHH is stopped at the gap
(default=<code>NA</code>, i.e no limitation).</p>
</td></tr>
<tr><td><code id="calc_ehh_+3A_discard_integration_at_border">discard_integration_at_border</code></td>
<td>
<p>logical. If <code>TRUE</code> (default) and computation reaches first or last marker or a gap larger than <code>maxgap</code>,
iHH is set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="calc_ehh_+3A_lower_y_bound">lower_y_bound</code></td>
<td>
<p>lower y boundary of the area to be integrated over (default: <code>limehh</code>). Can be set
to zero for compatibility with the program hapbin.</p>
</td></tr>
<tr><td><code id="calc_ehh_+3A_interpolate">interpolate</code></td>
<td>
<p>logical. Affects only IHH values. If <code>TRUE</code> (default), integration
is performed over a continuous EHH curve (values are interpolated linearly between consecutive markers),
otherwise the EHH curve decreases stepwise at markers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Values for allele-specific Extended Haplotype Homozygosity (EHH) are computed
upstream and downstream of the focal marker for each of its alleles.
These values are integrated with respect to their genomic positions to yield
an 'integrated EHH' (iHH) value for each allele.
</p>


<h3>Value</h3>

<p>The returned value is a list containing the following elements:
</p>

<dl>
<dt>mrk.name</dt><dd><p>The name/identifier of the focal marker.</p>
</dd>
<dt>freq</dt><dd><p>A vector with the frequencies of the alleles of the focal marker.</p>
</dd>
<dt>ehh</dt><dd><p>A data frame with EHH values for each allele of the focal marker.</p>
</dd>
<dt>ihh</dt><dd><p>A vector with iHH (integrated EHH) values for each allele of the focal marker.</p>
</dd>
</dl>



<h3>References</h3>

<p>Gautier, M. and Naves, M. (2011). Footprints of selection in the ancestral admixture of a New World Creole cattle breed. <em>Molecular Ecology</em>, <strong>20</strong>, 3128-3143.
</p>
<p>Klassmann, A. and Gautier, M. (2020). Detecting selection using Extended Haplotype
Homozygosity-based statistics on unphased or unpolarized data (preprint). 
https://doi.org/10.22541/au.160405572.29972398/v1
</p>
<p>Sabeti, P.C. et al. (2002). Detecting recent positive selection in the human genome from haplotype structure. <em>Nature</em>, <strong>419</strong>, 832-837.
</p>
<p>Sabeti, P.C. et al. (2007). Genome-wide detection and characterization of positive selection in human populations. <em>Nature</em>, <strong>449</strong>, 913-918.
</p>
<p>Tang, K. and Thornton, K.R. and Stoneking, M. (2007). A New Approach for Using Genome Scans to Detect Recent Positive Selection in the Human Genome. <em>Plos Biology</em>, <strong>7</strong>, e171.
</p>
<p>Voight, B.F. and Kudaravalli, S. and Wen, X. and Pritchard, J.K. (2006). A map of recent positive selection in the human genome. <em>Plos Biology</em>, <strong>4</strong>, e72.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data2haplohh">data2haplohh</a></code>, <code><a href="#topic+plot.ehh">plot.ehh</a></code>, <code><a href="#topic+calc_ehhs">calc_ehhs</a></code>, <code><a href="#topic+scan_hh">scan_hh</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#example haplohh object (280 haplotypes, 1424 SNPs)
#see ?haplohh_cgu_bta12 for details
data(haplohh_cgu_bta12)
#computing EHH statistics for the marker "F1205400"
#which displays a strong signal of selection
ehh &lt;- calc_ehh(haplohh_cgu_bta12, mrk = "F1205400")
</code></pre>

<hr>
<h2 id='calc_ehhs'>EHHS and iES computation for a given focal marker</h2><span id='topic+calc_ehhs'></span><span id='topic+ehhs-class'></span><span id='topic+ehhs'></span>

<h3>Description</h3>

<p>Compute site-specific Extended Haplotype Homozygosity (EHHS) and integrated EHHS (iES) for a given focal marker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_ehhs(
  haplohh,
  mrk,
  limhaplo = 2,
  limhomohaplo = 2,
  limehhs = 0.05,
  include_zero_values = FALSE,
  include_nhaplo = FALSE,
  phased = TRUE,
  scalegap = NA,
  maxgap = NA,
  discard_integration_at_border = TRUE,
  lower_y_bound = limehhs,
  interpolate = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_ehhs_+3A_haplohh">haplohh</code></td>
<td>
<p>an object of class <code>haplohh</code> (see <code><a href="#topic+data2haplohh">data2haplohh</a></code>).</p>
</td></tr>
<tr><td><code id="calc_ehhs_+3A_mrk">mrk</code></td>
<td>
<p>integer representing the number of the focal marker within the haplohh object
or string representing its ID/name.</p>
</td></tr>
<tr><td><code id="calc_ehhs_+3A_limhaplo">limhaplo</code></td>
<td>
<p>if there are less than <code>limhaplo</code> chromosomes that can be used for
the calculation of EHH, the calculation is stopped. The option is intended for the case of missing data,
which leads to the successive exclusion of haplotypes: the further away from the focal marker
the less haplotypes contribute to EHH.</p>
</td></tr>
<tr><td><code id="calc_ehhs_+3A_limhomohaplo">limhomohaplo</code></td>
<td>
<p>if there are less than <code>limhomohaplo</code> homozygous chromosomes, the
calculation is stopped. This option is intended for unphased data and should be invoked only
if relatively low frequency variants are not filtered subsequently (see main vignette and Klassmann et al. 2020).</p>
</td></tr>
<tr><td><code id="calc_ehhs_+3A_limehhs">limehhs</code></td>
<td>
<p>limit at which EHHS stops to be evaluated.</p>
</td></tr>
<tr><td><code id="calc_ehhs_+3A_include_zero_values">include_zero_values</code></td>
<td>
<p>logical. If <code>FALSE</code>, return values only for those positions where the calculation is
actually performed, i.e. until stopped by reaching either <code>limehh</code> or <code>limhaplo</code>. If <code>TRUE</code>, report EHH values for
all markers, the additional ones being zero.</p>
</td></tr>
<tr><td><code id="calc_ehhs_+3A_include_nhaplo">include_nhaplo</code></td>
<td>
<p>logical. If <code>TRUE</code>, report the number of evaluated haplotypes at each marker
(only informative, if missing data leads to a decrease of evaluated haplotypes).</p>
</td></tr>
<tr><td><code id="calc_ehhs_+3A_phased">phased</code></td>
<td>
<p>logical. If <code>TRUE</code> (default) chromosomes are expected to be phased. If <code>FALSE</code>, the haplotype data is assumed to
consist of pairwise ordered chromosomes belonging to diploid individuals.
EHHS is then estimated over individuals which are homozygous at the focal marker.</p>
</td></tr>
<tr><td><code id="calc_ehhs_+3A_scalegap">scalegap</code></td>
<td>
<p>scale or cap gaps larger than the specified size to the specified size (default=<code>NA</code>, i.e. no scaling).</p>
</td></tr>
<tr><td><code id="calc_ehhs_+3A_maxgap">maxgap</code></td>
<td>
<p>maximum allowed gap in bp between two markers. If exceeded, further calculation of EHHS is stopped at the gap
(default=<code>NA</code>, i.e no limitation).</p>
</td></tr>
<tr><td><code id="calc_ehhs_+3A_discard_integration_at_border">discard_integration_at_border</code></td>
<td>
<p>logical. If <code>TRUE</code> (default) and computation reaches first or last marker or a gap larger than <code>maxgap</code>,
iHH is set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="calc_ehhs_+3A_lower_y_bound">lower_y_bound</code></td>
<td>
<p>lower y boundary of the area to be integrated over (default: <code>limehhs</code>). Can be set
to zero for compatibility with the program hapbin.</p>
</td></tr>
<tr><td><code id="calc_ehhs_+3A_interpolate">interpolate</code></td>
<td>
<p>logical. Affects only IES and INES values. If <code>TRUE</code> (default), integration
is performed over a continuous EHHS curve (values are interpolated linearly between consecutive markers),
otherwise the EHHS curve decreases stepwise at markers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Values for site-specific Extended Haplotype Homozygosity (EHHS) are computed at each position upstream and downstream
of the focal marker. These values are integrated with respect to their
genomic position to yield an 'integrated EHHS' (iES) value.
</p>


<h3>Value</h3>

<p>The returned value is a list containing the following elements:
</p>

<dl>
<dt>mrk.name</dt><dd><p>The name/identifier of the focal marker.</p>
</dd>
<dt>ehhs</dt><dd><p>A table containing EHHS values as used by Sabeti et al. (2007),
resp. the same values normalized to 1 at the focal marker (nEHHS) as used by Tang et al. (2007).</p>
</dd>
<dt>IES</dt><dd><p>Integrated EHHS.</p>
</dd>
<dt>INES</dt><dd><p>Integrated  normalized EHHS.</p>
</dd>
</dl>



<h3>References</h3>

<p>Gautier, M. and Naves, M. (2011). Footprints of selection in the ancestral admixture of a New World Creole cattle breed. <em>Molecular Ecology</em>, <strong>20</strong>, 3128-3143.
</p>
<p>Klassmann, A. and Gautier, M. (2020). Detecting selection using Extended Haplotype
Homozygosity-based statistics on unphased or unpolarized data (preprint). 
https://doi.org/10.22541/au.160405572.29972398/v1
</p>
<p>Sabeti, P.C. et al. (2002). Detecting recent positive selection in the human genome from haplotype structure. <em>Nature</em>, <strong>419</strong>, 832-837.
</p>
<p>Sabeti, P.C. et al. (2007). Genome-wide detection and characterization of positive selection in human populations. <em>Nature</em>, <strong>449</strong>, 913-918.
</p>
<p>Tang, K. and Thornton, K.R. and Stoneking, M. (2007). A New Approach for Using Genome Scans to Detect Recent Positive Selection in the Human Genome. <em>Plos Biology</em>, <strong>7</strong>, e171.
</p>
<p>Voight, B.F. and Kudaravalli, S. and Wen, X. and Pritchard, J.K. (2006). A map of recent positive selection in the human genome. <em>Plos Biology</em>, <strong>4</strong>, e72.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data2haplohh">data2haplohh</a></code>, <code><a href="#topic+plot.ehhs">plot.ehhs</a></code>, <code><a href="#topic+calc_ehh">calc_ehh</a></code>, <code><a href="#topic+scan_hh">scan_hh</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#example haplohh object (280 haplotypes, 1424 SNPs)
#see ?haplohh_cgu_bta12 for details
data(haplohh_cgu_bta12)
#computing EHHS statistics for the marker "F1205400"
#which displays a strong signal of selection
ehhs &lt;- calc_ehhs(haplohh_cgu_bta12, mrk = "F1205400")
</code></pre>

<hr>
<h2 id='calc_furcation'>calculate furcation trees around a focal marker</h2><span id='topic+calc_furcation'></span>

<h3>Description</h3>

<p>Calculate furcation trees around a focal marker. A furcation tree captures
in greater detail than EHH values the decrease of extended haplotype homozygosity at
increasing distances from the selected focal marker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_furcation(
  haplohh,
  mrk,
  allele = NA,
  limhaplo = 2,
  phased = TRUE,
  polarized = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_furcation_+3A_haplohh">haplohh</code></td>
<td>
<p>an object of class haplohh (see <code><a href="#topic+data2haplohh">data2haplohh</a></code>).</p>
</td></tr>
<tr><td><code id="calc_furcation_+3A_mrk">mrk</code></td>
<td>
<p>integer representing the number of the focal marker within the haplohh object
or string representing its ID/name.</p>
</td></tr>
<tr><td><code id="calc_furcation_+3A_allele">allele</code></td>
<td>
<p>a vector of alleles as coded internally, i.e. in case of polarized alleles,
0 represents the ancestral, 1 or higher the derived alleles.
If <code>NULL</code>, all alleles of the focal marker are considered.</p>
</td></tr>
<tr><td><code id="calc_furcation_+3A_limhaplo">limhaplo</code></td>
<td>
<p>if there are less than <code>limhaplo</code> chromosomes that can be used for
the calculation, it is stopped. This is useful in case of missing data,
which lead to a successive exclusion of haplotypes: the further away from the focal marker
the less haplotypes are evaluated.</p>
</td></tr>
<tr><td><code id="calc_furcation_+3A_phased">phased</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), chromosomes are expected to be phased.
If <code>FALSE</code>, consecutive chromosomes are assumed to
belong to diploid individuals and furcation trees are limited to within individuals which
are homozygous at the focal marker.</p>
</td></tr>
<tr><td><code id="calc_furcation_+3A_polarized">polarized</code></td>
<td>
<p>logical. Affects only the order of furcations. If <code>TRUE</code> (default), the ancestral allele
becomes the first furcation and derived alleles are sorted by their internal coding. Otherwise all alleles
are sorted by their internal coding.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A haplotype furcation tree visualizes the breakdown
of LD at increasing distances from the focal marker.
The root of each tree is an allele of the focal marker, which in turn is identified
by a vertical dashed line.
Moving either to the &quot;left&quot; or to the &quot;right&quot; of the focal marker, each further marker is an opportunity for a node;
the tree either divides or does not, based on whether alleles at that marker
distinguish between hitherto identical extended haplotypes.
The thickness of the lines corresponds to the number of chromosomes sharing an extended haplotype.
</p>


<h3>Value</h3>

<p>An object of class furcation, containing the furcation structure of the specified alleles at the focal marker.
</p>


<h3>References</h3>

<p>Sabeti, P.C. and Reich, D.E. and Higgins, J.M. and Levine, H.Z.P and Richter, D.J. and Schaffner, S.F. and Gabriel, S.B. and Platko, J.V. and Patterson, N.J. and McDonald, G.J. and Ackerman, H.C. and Campbell, S.J. and Altshuler, D. and Cooper, R. and Kwiatkowski, D. and Ward, R. and Lander, E.S. (2002). Detecting recent positive selection in the human genome from haplotype structure. Nature, 419, 832-837.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.furcation">plot.furcation</a></code>, <code><a href="#topic+calc_haplen">calc_haplen</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#example haplohh object (280 haplotypes, 1424 SNPs)
#see ?haplohh_cgu_bta12 for details
data(haplohh_cgu_bta12)
#plotting a furcation diagram for both ancestral and derived allele
#from the marker "F1205400"
#which display a strong signal of selection
f &lt;- calc_furcation(haplohh_cgu_bta12, mrk = "F1205400")
plot(f)
</code></pre>

<hr>
<h2 id='calc_haplen'>Calculate length of longest shared haplotypes around a focal marker</h2><span id='topic+calc_haplen'></span>

<h3>Description</h3>

<p>Calculate for each chromosome the maximum length of its extended haplotype homozygosity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_haplen(furcation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_haplen_+3A_furcation">furcation</code></td>
<td>
<p>an object of class <code>furcation</code> calculated by <code><a href="#topic+calc_furcation">calc_furcation</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extended haplotype homozygosity is defined as the region
around a focal marker in which a particular chromosome shares
a haplotype with (its sequence is identical to) another chromosome.
The function calculates for each chromosome the boundaries of its longest
shared haplotype. These correspond to the last furcations of a chromsome 
in a furcation diagram. Note that the calculation is performed independently
upstream and downstream of the focal marker and hence upper and lower 
boundaries do not necessarily arise from the same chromosomal pair.
</p>


<h3>Value</h3>

<p>The functions returns a list containing four elements:
</p>

<dl>
<dt>mrk.name</dt><dd><p>name/identifier of the focal marker.</p>
</dd>
<dt>position</dt><dd><p>position of the focal marker.</p>
</dd>
<dt>xlim</dt><dd><p>positions of left- and rightmost markers covered by extended haplotypes.</p>
</dd>
<dt>haplen</dt><dd><p>a data frame with the coordinates of extended haplotypes around the focal marker.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>#example haplohh object (280 haplotypes, 1424 SNPs)
#see ?haplohh_cgu_bta12 for details
data(haplohh_cgu_bta12)
#plotting haplotype lengths for both ancestral and derived allele
#of the marker "F1205400"
#which displays a strong signal of selection
f &lt;- calc_furcation(haplohh_cgu_bta12, mrk = "F1205400")
h &lt;- calc_haplen(f)
plot(h)
</code></pre>

<hr>
<h2 id='calc_pairwise_haplen'>Calculate pairwise shared haplotype length between all chromosomes</h2><span id='topic+calc_pairwise_haplen'></span>

<h3>Description</h3>

<p>Calculate pairwise shared haplotype length between all chromosomes at a focal marker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_pairwise_haplen(
  haplohh,
  mrk,
  phased = TRUE,
  maxgap = NA,
  max_extend = NA,
  side = "both"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_pairwise_haplen_+3A_haplohh">haplohh</code></td>
<td>
<p>an object of class <code>haplohh</code> (see <code><a href="#topic+data2haplohh">data2haplohh</a></code>).</p>
</td></tr>
<tr><td><code id="calc_pairwise_haplen_+3A_mrk">mrk</code></td>
<td>
<p>integer representing the number of the focal marker within the haplohh object
or string representing its ID/name.</p>
</td></tr>
<tr><td><code id="calc_pairwise_haplen_+3A_phased">phased</code></td>
<td>
<p>logical. If <code>TRUE</code> (default) chromosomes are expected to be phased. If <code>FALSE</code>, the haplotype data is assumed to
consist of pairwise ordered chromosomes belonging to diploid individuals and only the two chromosomes of
each individual are compared.</p>
</td></tr>
<tr><td><code id="calc_pairwise_haplen_+3A_maxgap">maxgap</code></td>
<td>
<p>maximum allowed gap in bp between two markers. If exceeded, further calculation is stopped at the gap
(default=<code>NA</code>, i.e. no limitation).</p>
</td></tr>
<tr><td><code id="calc_pairwise_haplen_+3A_max_extend">max_extend</code></td>
<td>
<p>maximum distance in bp to extend shared haplotypes away from the focal marker.
(default <code>NA</code>, i.e. no limitation).</p>
</td></tr>
<tr><td><code id="calc_pairwise_haplen_+3A_side">side</code></td>
<td>
<p>side to consider, either &quot;left&quot; (positions lower than focal position), &quot;right&quot; (positions higher than focal position)
or &quot;both&quot; (default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the length of shared haplotypes (stretches of identical sequence) around
the focal marker.
</p>
<p>Note that the function <code><a href="#topic+calc_haplen">calc_haplen</a></code> calculates for each chromosome
the boundaries of its longest shared haplotype; separately upstream and downstream of
the focal marker.
</p>


<h3>Value</h3>

<p>The returned value is a matrix with pairwise shared haplotype lengths.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data2haplohh">data2haplohh</a></code>, <code><a href="#topic+scan_hh_full">scan_hh_full</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#example haplohh object (280 haplotypes, 1424 SNPs)
#see ?haplohh_cgu_bta12 for details
data(haplohh_cgu_bta12)
#computing shared haplotype lengths around the marker "F1205400"
#which displays a strong signal of selection
m &lt;- calc_pairwise_haplen(haplohh_cgu_bta12, mrk = "F1205400")
</code></pre>

<hr>
<h2 id='calc_region_stats'>Calculate score statistics for given regions</h2><span id='topic+calc_region_stats'></span>

<h3>Description</h3>

<p>Calculate score statistics (extremal values) for given regions. This function
is intended for the comparison of different scores for the same chromosomal regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_region_stats(
  scan,
  regions,
  threshold = NA,
  pval = FALSE,
  ignore_sign = FALSE,
  right = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_region_stats_+3A_scan">scan</code></td>
<td>
<p>a data frame containing scores (output of <code><a href="#topic+ihh2ihs">ihh2ihs</a></code>, <code><a href="#topic+ines2rsb">ines2rsb</a></code> or <code><a href="#topic+ies2xpehh">ies2xpehh</a></code>).</p>
</td></tr>
<tr><td><code id="calc_region_stats_+3A_regions">regions</code></td>
<td>
<p>a data frame with column names <code>CHR</code>, <code>START</code> and <code>END</code>,
specifying chromosomal regions (e.g. as obtained by function <code><a href="#topic+calc_candidate_regions">calc_candidate_regions</a></code>).</p>
</td></tr>
<tr><td><code id="calc_region_stats_+3A_threshold">threshold</code></td>
<td>
<p>boundary score above which markers are defined as &quot;extreme&quot;.</p>
</td></tr>
<tr><td><code id="calc_region_stats_+3A_pval">pval</code></td>
<td>
<p>logical. If <code>TRUE</code> use the (negative log-) p-value instead of the score.</p>
</td></tr>
<tr><td><code id="calc_region_stats_+3A_ignore_sign">ignore_sign</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), take absolute values of score.</p>
</td></tr>
<tr><td><code id="calc_region_stats_+3A_right">right</code></td>
<td>
<p>logical, indicating if the regions should be closed on the right (and open on the left) or vice versa.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with chromosomal regions.
For each region the overall number of markers, their mean and maximum,
the number of markers with extremal values, their percentage of all markers
and their average are reported.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_candidate_regions">calc_candidate_regions</a></code>
</p>

<hr>
<h2 id='calc_sfs_tests'>Calculate site frequency spectrum test statistics</h2><span id='topic+calc_sfs_tests'></span>

<h3>Description</h3>

<p>Calculate site frequency spectrum (SFS) tests Tajima's D, Fay &amp; Wu's H and Zeng's E.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_sfs_tests(
  haplohh,
  polarized = TRUE,
  window_size = NA,
  overlap = 0,
  right = TRUE,
  min_n_mrk = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_sfs_tests_+3A_haplohh">haplohh</code></td>
<td>
<p>an object of class <code>haplohh</code> (see <code><a href="#topic+data2haplohh">data2haplohh</a></code>)</p>
</td></tr>
<tr><td><code id="calc_sfs_tests_+3A_polarized">polarized</code></td>
<td>
<p>logical. <code>TRUE</code> by default. If <code>FALSE</code>, use major and minor allele instead of ancestral and derived. If there
are more than two alleles then the minor allele refers to the second-most frequent allele.
Note that Tajima's D remains unchanged, Fay &amp; Wu's H is always zero for folded spectra and Zeng's E becomes equal to Tajima's D.</p>
</td></tr>
<tr><td><code id="calc_sfs_tests_+3A_window_size">window_size</code></td>
<td>
<p>size of sliding windows. If <code>NA</code> (default), there will be only
one window covering the whole length of the chromosome.</p>
</td></tr>
<tr><td><code id="calc_sfs_tests_+3A_overlap">overlap</code></td>
<td>
<p>size of window overlap (default 0, i.e. no overlap).</p>
</td></tr>
<tr><td><code id="calc_sfs_tests_+3A_right">right</code></td>
<td>
<p>logical, indicating if the windows should be closed on the right and open on the left (default) or vice versa.</p>
</td></tr>
<tr><td><code id="calc_sfs_tests_+3A_min_n_mrk">min_n_mrk</code></td>
<td>
<p>minimum number of (polymorphic) markers per window.</p>
</td></tr>
<tr><td><code id="calc_sfs_tests_+3A_verbose">verbose</code></td>
<td>
<p>logical. <code>TRUE</code> by default; reports if multi-allelic sites are removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Neutrality tests based on the site frequency spectrum (SFS) are
largely unrelated to EHH-based methods. The tests provided here are implemented
elsewhere, too (e.g. in package <a href="https://cran.r-project.org/package=PopGenome">PopGenome</a>).
</p>
<p>Each test compares two estimations of the <em>scaled mutation rate</em> theta,
which all have the same expected value under neutrality. Deviations from zero indicate
violations of the neutral null model, typically population size changes, population subdivision or selection.
Tajima's D and Fay &amp; Wu's H become negative in presence of an almost completed sweep, Zeng's E becomes
positive for some time after it. Significance can typically be assigned only by
simulations.
</p>
<p>The standard definition of the tests cannot cope with missing values and typically markers
with missing genotypes must be discarded. Ferretti (2012) provides an extension
that can handle missing values (without discarding any non-missing values). In this package, 
only the first moments (the theta-estimators themselves) are adapted accordingly, 
but not the second moments (their variances), because the latter is computationally demanding
and the resulting bias relatively small. It is recommended, though, to discard markers or haplotypes 
with more than 20% missing values.
</p>
<p>Multi-allelic markers are always removed since the tests rely on the &quot;infinite sites model&quot; which
implies that all polymorphic markers are bi-allelic. 
Monomorphic markers can be present, but are irrelevant for the tests.
</p>


<h3>Value</h3>

<p>A data frame with window coordinates, the number of contained (polymorphic) markers, Watterson's, Tajima's and Zeng's
estimators of theta and the test statistics of Tajima's D, Fay &amp; Wu's H and Zeng's E.
</p>


<h3>References</h3>

<p>Watterson, G.A. (1975). On the number of segregating sites in genetical models without recombination.
<em>Theoretical Population Biology</em> <strong>7</strong>(2) 256-276.
</p>
<p>Tajima, F. (1983). Evolutionary relationship of DNA sequences in finite populations.
<em>Genetics</em> <strong>105</strong>(2) 437-60.
</p>
<p>Tajima, F. (1989). Statistical method for testing the neutral mutation hypothesis by DNA polymorphism.
<em>Genetics</em> <strong>123</strong>(3) 585-95.
</p>
<p>Fay, J. and Wu, C. (2000). Hitchhiking under positive Darwinian selection. <em>Genetics</em>
<strong>155</strong>(3) 1405-13.
</p>
<p>Zeng, E. et al. (2006). Statistical tests for detecting positive selection by utilizing high-frequency variants.
<em>Genetics</em> <strong>174</strong>(3) 1431-9.
</p>
<p>Ferretti, L. and Raineri, E. and Ramos-Onsins, S. (2012). Neutrality tests for sequences with missing data.
<em>Genetics</em> <strong>191</strong>(4) 1397-401.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make.example.files()
# neutral evolution
hh &lt;- data2haplohh("example_neutral.vcf", verbose = FALSE)
calc_sfs_tests(hh)
# strong selective sweep
hh &lt;- data2haplohh("example_sweep.vcf", verbose = FALSE)
calc_sfs_tests(hh)
remove.example.files()
</code></pre>

<hr>
<h2 id='data2haplohh'>Convert data from input file to an object of class haplohh</h2><span id='topic+data2haplohh'></span>

<h3>Description</h3>

<p>Convert input data files to an object of <code><a href="#topic+haplohh-class">haplohh-class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data2haplohh(
  hap_file,
  map_file = NA,
  min_perc_geno.hap = NA,
  min_perc_geno.mrk = 100,
  min_maf = NA,
  chr.name = NA,
  popsel = NA,
  recode.allele = FALSE,
  allele_coding = "12",
  haplotype.in.columns = FALSE,
  remove_multiple_markers = FALSE,
  polarize_vcf = TRUE,
  capitalize_AA = TRUE,
  vcf_reader = "data.table",
  position_scaling_factor = NA,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data2haplohh_+3A_hap_file">hap_file</code></td>
<td>
<p>file containing haplotype data (see details below).</p>
</td></tr>
<tr><td><code id="data2haplohh_+3A_map_file">map_file</code></td>
<td>
<p>file containing map information (see details below).</p>
</td></tr>
<tr><td><code id="data2haplohh_+3A_min_perc_geno.hap">min_perc_geno.hap</code></td>
<td>
<p>threshold on percentage of missing data for haplotypes
(haplotypes with less than <code>min_perc_geno.hap</code> percent of markers genotyped are discarded). Default is <code>NA</code>,
hence no constraint.</p>
</td></tr>
<tr><td><code id="data2haplohh_+3A_min_perc_geno.mrk">min_perc_geno.mrk</code></td>
<td>
<p>threshold on percentage of missing data for markers (markers genotyped on less than
<code>min_perc_geno.mrk</code> percent of haplotypes are discarded). By default, <code>min_perc_geno.mrk=100</code>,
hence only fully genotyped markers are retained.
This value cannot be set to <code>NA</code> or zero.</p>
</td></tr>
<tr><td><code id="data2haplohh_+3A_min_maf">min_maf</code></td>
<td>
<p>threshold on the Minor Allele Frequency. Markers having a MAF lower than or equal to minmaf are discarded.
In case of multi-allelic markers the second-most frequent allele is referred to as minor allele.
Setting this value to zero eliminates monomorphic sites. Default is <code>NA</code>,
hence no constraint.</p>
</td></tr>
<tr><td><code id="data2haplohh_+3A_chr.name">chr.name</code></td>
<td>
<p>name of the chromosome considered (relevant if data for several chromosomes is
contained in the haplotype or map file).</p>
</td></tr>
<tr><td><code id="data2haplohh_+3A_popsel">popsel</code></td>
<td>
<p>code of the population considered (relevant for fastPHASE output which
can contain haplotypes from various populations).</p>
</td></tr>
<tr><td><code id="data2haplohh_+3A_recode.allele">recode.allele</code></td>
<td>
<p>*Deprecated*. logical. <code>FALSE</code> by default. <code>TRUE</code> forces parameter <code>allele_coding</code> to <code>"map"</code>,
<code>FALSE</code> leaves it unchanged.</p>
</td></tr>
<tr><td><code id="data2haplohh_+3A_allele_coding">allele_coding</code></td>
<td>
<p>the allele coding provided by the user. Either <code>"12"</code> (default), <code>"01"</code>, <code>"map"</code> or <code>"none"</code>.
The option is irrelevant for vcf files and ms output.</p>
</td></tr>
<tr><td><code id="data2haplohh_+3A_haplotype.in.columns">haplotype.in.columns</code></td>
<td>
<p>logical. If <code>TRUE</code>, phased input haplotypes are assumed to be in columns (as produced
by the SHAPEIT2 program (O'Connell et al., 2014).</p>
</td></tr>
<tr><td><code id="data2haplohh_+3A_remove_multiple_markers">remove_multiple_markers</code></td>
<td>
<p>logical. If <code>FALSE</code> (default), conversion
stops, if multiple markers with the same chromosomal position are encountered.
If <code>TRUE</code>, duplicated markers are removed (all but the first marker with identical positions).</p>
</td></tr>
<tr><td><code id="data2haplohh_+3A_polarize_vcf">polarize_vcf</code></td>
<td>
<p>logical. Only of relevance for vcf files. If <code>TRUE</code> (default), tries to polarize
variants with help of the AA entry in the INFO field. Unpolarized alleles are discarded.
If <code>FALSE</code>, allele coding of vcf file is used unchanged as internal coding.</p>
</td></tr>
<tr><td><code id="data2haplohh_+3A_capitalize_aa">capitalize_AA</code></td>
<td>
<p>logical. Only of relevance for vcf files with ancestral allele information.
Low confidence ancestral alleles are usually coded by lower-case letters. If <code>TRUE</code> (default), these are
changed to upper case before the alleles of the sample are matched for polarization.</p>
</td></tr>
<tr><td><code id="data2haplohh_+3A_vcf_reader">vcf_reader</code></td>
<td>
<p>library used to read vcf. By default, low-level parsing is
performed using the generic package <code>data.table</code>. In order to read compressed files,
the package <code>R.utils</code> must be installed, too.
If the specialized package <code>vcfR</code> is available, set this parameter to <code>"vcfR"</code>.</p>
</td></tr>
<tr><td><code id="data2haplohh_+3A_position_scaling_factor">position_scaling_factor</code></td>
<td>
<p>intended primarily for output of ms where
positions lie in the interval [0,1]. These can be rescaled to sizes
of typical markers in real data.</p>
</td></tr>
<tr><td><code id="data2haplohh_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), report verbose progress.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Five haplotype input formats are supported:
</p>

<ul>
<li><p> a &quot;standard format&quot; with haplotypes in rows and markers in columns (with no header, but a haplotype ID/name in
the first column).
</p>
</li>
<li><p> a &quot;transposed format&quot; similar to the one produced by the phasing program SHAPEIT2
(O'Connell et al., 2014) in which haplotypes are in columns and markers in rows
(with neither header nor marker IDs nor haplotype IDs).
</p>
</li>
<li><p> output files from the fastPHASE program (Sheet and Stephens, 2006).
If haplotypes from several different population were phased simultaneously (-u fastPHASE option
was used), it is necessary to specify the population of interest by parameter <code>popsel</code>
(if this parameter is not or wrongly set, the error message will provide a list of
the population numbers contained in the file).
</p>
</li>
<li><p> files in variant call format (vcf). No mapfile is needed is this case. If
the file contains several chromosomes, it is necessary to choose one by parameter
<code>chr.name</code>.
</p>
</li>
<li><p> output of the simulation program 'ms'. No mapfile is needed in this case. If the file
contains several 'runs', a specific number has to be specified by the
parameter <code>chr.name</code>.
</p>
</li></ul>

<p>The &quot;transposed format&quot; has to be explicitly set while the other formats
are recognized automatically.
</p>
<p>The map file contains marker information in three, or, if it is used for
polarization (see below), five columns:
</p>

<ul>
<li><p> marker name/id
</p>
</li>
<li><p> chromosome
</p>
</li>
<li><p> position (physical or genetic)
</p>
</li>
<li><p> ancestral allele encoding
</p>
</li>
<li><p> derived allele encoding
</p>
</li></ul>

<p>The markers must be in the same order as in the haplotype file. If
several chromosomes are represented in the map file, it is necessary to choose that
which corresponds to the haplotype file by parameter <code>chr.name</code>.
</p>
<p>Haplotypes can be given either with alleles already coded as numbers (in two possible ways)
or with the actual alleles (e.g. nucleotides) which can be translated into numbers
either using the fourth and fifth column of the map file or by their alpha-numeric order.
Correspondingly, the parameter <code>allele_coding</code> has to be set to either <code>"12"</code>,
<code>"01"</code>, <code>"map"</code> or <code>"none"</code>:
</p>

<ul>
<li> <p><code>"12"</code>: 0 represents missing values, 1 the ancestral allele
and 2 (or higher integers) derived allele(s).
</p>
</li>
<li> <p><code>"01"</code>: <code>NA</code> or '.' (a point) represent missing values, 0 the
ancestral and 1 (or higher integers) derived allele(s).
</p>
</li>
<li> <p><code>"map"</code>: for each marker, the fourth column of the map file
defines the ancestral allele and the fifth column derived alleles.
In case of multiple derived alleles, they must be separated by commas without space.
Alleles in the haplotype file which do not appear in neither of the two columns
of the map file are regarded as missing values (<code>NA</code>).
</p>
</li>
<li> <p><code>"none"</code>: <code>NA</code> or '.' (a point) represent missing values, otherwise for each
marker the allele that comes first in alpha-numeric
order is coded by 0, the next by 1, etc. Evidently, this coding does not convey
any information about allele status as ancestral or derived, hence the alleles
cannot be regarded as polarized.
</p>
</li></ul>

<p>The information of allelic ancestry is exploited only in the frequency-bin-wise
standardization of iHS (see <code><a href="#topic+ihh2ihs">ihh2ihs</a></code>). However, although ancestry status does
not figure in the formulas of the cross populations statistics
Rsb and XP-EHH, their values do depend on the assigned status.
</p>
<p>The arguments <code>min_perc_geno.hap</code>,
<code>min_perc_geno.mrk</code> and <code>min_maf</code> are evaluated in this order.
</p>


<h3>Value</h3>

<p>The returned value is an object of <code><a href="#topic+haplohh-class">haplohh-class</a></code>.
</p>


<h3>References</h3>

<p>Scheet P, Stephens M (2006) A fast and flexible statistical model for large-scale population genotype
data: applications to inferring missing genotypes and haplotypic phase. <em>Am J Hum Genet</em>, <strong>78</strong>, 629-644.
</p>
<p>O'Connell J, Gurdasani D, Delaneau O, et al (2014) A general approach for haplotype phasing
across the full spectrum of relatedness. <em>PLoS Genet</em>, <strong>10</strong>, e1004234.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#copy example files into the current working directory.
make.example.files()
#create object using a haplotype file in "standard format"
hap &lt;- data2haplohh(hap_file = "bta12_cgu.hap",
                   map_file = "map.inp",
                   chr.name = 12,
                   allele_coding = "map")
#create object using fastPHASE output
hap &lt;- data2haplohh(hap_file = "bta12_hapguess_switch.out",
                   map_file = "map.inp",
                   chr.name = 12,
                   popsel = 7,
                   allele_coding = "map")
#clean up demo files
remove.example.files()
</code></pre>

<hr>
<h2 id='distribplot'>Plot distribution of standardized iHS, Rsb or XP-EHH values</h2><span id='topic+distribplot'></span>

<h3>Description</h3>

<p>Plot the observed distribution of standardized iHS, Rsb or XP-EHH values together with
the standard Gaussian distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distribplot(
  data,
  lty = 1,
  lwd = 1.5,
  col = c("blue", "red"),
  qqplot = FALSE,
  resolution = 0.01,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distribplot_+3A_data">data</code></td>
<td>
<p>a vector of iHS, Rsb or XPEHH values.</p>
</td></tr>
<tr><td><code id="distribplot_+3A_lty">lty</code></td>
<td>
<p>line type.</p>
</td></tr>
<tr><td><code id="distribplot_+3A_lwd">lwd</code></td>
<td>
<p>line width.</p>
</td></tr>
<tr><td><code id="distribplot_+3A_col">col</code></td>
<td>
<p>a vector describing the colors of the observed and Gaussian distribution, respectively.</p>
</td></tr>
<tr><td><code id="distribplot_+3A_qqplot">qqplot</code></td>
<td>
<p>logical. If <code>TRUE</code> a qq-plot is drawn instead of the distribution density curve.</p>
</td></tr>
<tr><td><code id="distribplot_+3A_resolution">resolution</code></td>
<td>
<p>affects only qqplot. Rasterize data points to a quadratic grid with the specified resolution and remove
duplicate points. Defaults to 0.01.</p>
</td></tr>
<tr><td><code id="distribplot_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ihh2ihs">ihh2ihs</a></code>, <code><a href="#topic+ines2rsb">ines2rsb</a></code>, <code><a href="#topic+ies2xpehh">ies2xpehh</a></code>, <code><a href="#topic+manhattanplot">manhattanplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rehh.data)
#results from a genome scan (44,057 SNPs) see ?wgscan.cgu for details
data(wgscan.cgu)
#extract vector with iHS values from data frame
IHS &lt;- ihh2ihs(wgscan.cgu)$ihs[["IHS"]]
distribplot(IHS, main = "iHS (CGU population)")
distribplot(IHS, main = "iHS (CGU population)", qqplot = TRUE)
</code></pre>

<hr>
<h2 id='extract_regions'>Extract regions from a scan</h2><span id='topic+extract_regions'></span>

<h3>Description</h3>

<p>Extract regions from a scan data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_regions(scan, regions, right = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_regions_+3A_scan">scan</code></td>
<td>
<p>A data frame with chromosomal positions like obtained
by <code><a href="#topic+scan_hh">scan_hh</a></code>, <code><a href="#topic+ihh2ihs">ihh2ihs</a></code>, <code><a href="#topic+ines2rsb">ines2rsb</a></code> or <code><a href="#topic+ies2xpehh">ies2xpehh</a></code>.</p>
</td></tr>
<tr><td><code id="extract_regions_+3A_regions">regions</code></td>
<td>
<p>A data frame with genomic regions like the output of <code><a href="#topic+calc_candidate_regions">calc_candidate_regions</a></code>.</p>
</td></tr>
<tr><td><code id="extract_regions_+3A_right">right</code></td>
<td>
<p>logical, indicating if the intervals should be closed on the right (and open on the left) or vice versa.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subset of data frame <code>scan</code>, retaining only positions belonging to
the regions specified in data frame <code>regions</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rehh.data)
data(wgscan.cgu)
regions &lt;- data.frame(CHR = 12, START = 2.88e+7, END = 2.92e+7)
extract_regions(wgscan.cgu, regions)
</code></pre>

<hr>
<h2 id='freqbinplot'>Plot of unstandardized iHS within frequency bins</h2><span id='topic+freqbinplot'></span>

<h3>Description</h3>

<p>Plot of unstandardized iHS within frequency bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freqbinplot(
  x,
  spectrum = FALSE,
  main = NA,
  xlab = "Derived allele frequency",
  ylab = NA,
  xlim = c(0, 1),
  ylim = NULL,
  pch = 20,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freqbinplot_+3A_x">x</code></td>
<td>
<p>data (output of function <code>ihh2ihs</code>)</p>
</td></tr>
<tr><td><code id="freqbinplot_+3A_spectrum">spectrum</code></td>
<td>
<p>logical. If <code>TRUE</code>, plot frequency spectrum instead of iHS.</p>
</td></tr>
<tr><td><code id="freqbinplot_+3A_main">main</code></td>
<td>
<p>an overall title for the plot.</p>
</td></tr>
<tr><td><code id="freqbinplot_+3A_xlab">xlab</code></td>
<td>
<p>a title for the x axis.</p>
</td></tr>
<tr><td><code id="freqbinplot_+3A_ylab">ylab</code></td>
<td>
<p>a title for the y axis.</p>
</td></tr>
<tr><td><code id="freqbinplot_+3A_xlim">xlim</code></td>
<td>
<p>the x coordinate range of the plot.</p>
</td></tr>
<tr><td><code id="freqbinplot_+3A_ylim">ylim</code></td>
<td>
<p>the y coordinate range of the plot.</p>
</td></tr>
<tr><td><code id="freqbinplot_+3A_pch">pch</code></td>
<td>
<p>plotting 'character' see <code>points</code>.</p>
</td></tr>
<tr><td><code id="freqbinplot_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to plot resp. points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot shows the mean and the quantiles calculated by
function <code><a href="#topic+ihh2ihs">ihh2ihs</a></code> for the unstandardized iHS in each frequency bin.
Note that the standardization of iHS is performed bin-wise in order
to reduce the frequency-dependence of
iHS values (expected under neutrality).
An implicit assumption of this procedure is that each bin is dominated
by neutral markers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ihh2ihs">ihh2ihs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rehh.data)
data(wgscan.cgu)
#results from a genome scan (44,057 SNPs)
#see ?wgscan.eut and ?wgscan.cgu for details
wgscan.cgu.ihs &lt;- ihh2ihs(wgscan.cgu)
freqbinplot(wgscan.cgu.ihs)
</code></pre>

<hr>
<h2 id='ftree-class'>An S4 class to represent a furcation tree on one side of one allele of a focal marker</h2><span id='topic+ftree-class'></span><span id='topic+ftree'></span>

<h3>Description</h3>

<p>An S4 class to represent a furcation tree on one side of one allele of a focal marker
</p>


<h3>Details</h3>

<p>A furcation structure consists of two trees (&quot;left&quot; and &quot;right&quot;) for each allele of
a focal marker. If there are only bi-allelic markers
and no missing values, the trees are bifurcating.
</p>
<p>Missing values are treated similarly to an extra allele
in so far as they cause a furcation. However, the resulting daughter node is marked
accordingly and the chromosomes excluded from further calculations.
If all chromosomes of a parent node have missing values, the &quot;furcation&quot; is
degenerated and yields a single daughter node.
</p>
<p>Note that a tree with n leaves can have at most 2n-1 nodes.
</p>
<p>In a furcation tree, the leaves do not necessarily represent
single chromosomes, either due to multiple missing data or
because the first/last marker was reached before all
extended haplotypes were distinct.
</p>


<h3>Slots</h3>


<dl>
<dt><code>node_parent</code></dt><dd><p>a vector, representing the tree structure. 
Each node (number) is assigned its parent node (number).</p>
</dd>
<dt><code>node_pos</code></dt><dd><p>a vector, assigning to each node (number) its position in the chromosome, i.e.
at which marker position the furcation occurred.</p>
</dd>
<dt><code>node_with_missing_data</code></dt><dd><p>a vector of type <code>logical</code>. 
Pseudo-furcations arise due to missing data at a marker.
The daughter node (number) is marked accordingly.</p>
</dd>
<dt><code>label_parent</code></dt><dd><p>a vector, that attaches an &quot;extra leave&quot;, representing
the haplotype number (defined by the order in the haplotype data file) to leaves
of the tree.
This is necessary because in general not all leaves of the original tree represent
a single haplotype/chromosome.</p>
</dd>
</dl>

<hr>
<h2 id='furcation-class'>An S4 class representing the complete furcation pattern around a focal marker.</h2><span id='topic+furcation-class'></span><span id='topic+furcation'></span>

<h3>Description</h3>

<p>An S4 class representing the complete furcation pattern around a focal marker.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code></dt><dd><p>a list containing for each allele an object of <code>allelefurcation-class</code>.</p>
</dd>
<dt><code>mrk.name</code></dt><dd><p>the name/identifier of the focal marker.</p>
</dd>
<dt><code>position</code></dt><dd><p>the chromosomal position of the focal marker.</p>
</dd>
<dt><code>xlim</code></dt><dd><p>the range of marker positions.</p>
</dd>
<dt><code>nhap</code></dt><dd><p>the number of haplotypes in the sample.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+calc_furcation">calc_furcation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># copy example files into working directory
make.example.files()
# read first example file
hh &lt;- data2haplohh(hap_file = "example1.hap", map_file = "example1.map", allele_coding = "01")
# remove example files
remove.example.files()
# calculate furcation structure around marker "rs6"
f &lt;- calc_furcation(hh, mrk = "rs6")
# extract left side tree of ancestral allele (which is coded by '0')
f[['0']]@left
# the tree consists of seven nodes, '1' being the root node
# nodes 2 and 3 have the root node as parent, etc.
# the first chromosome is attached as a label node to node 7, etc.
# For comparison, a plot of the complete furcation structure:
plot(f)
</code></pre>

<hr>
<h2 id='haplen-class'>class for haplotype length</h2><span id='topic+haplen-class'></span><span id='topic+haplen'></span>

<h3>Description</h3>

<p>class for haplotype length
</p>

<hr>
<h2 id='haplohh_cgu_bta12'>Example of an <code>haplohh</code> object</h2><span id='topic+haplohh_cgu_bta12'></span>

<h3>Description</h3>

<p>The object contains haplotype data for 140 cattle individuals (280 haplotypes) belonging to the
Creole breed from Guadeloupe (CGU) and 1424 markers (mapping to chromosome BTA12).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(haplohh_cgu_bta12)
</code></pre>


<h3>Format</h3>

<p>An object of <code><a href="#topic+haplohh-class">haplohh-class</a></code>.
</p>


<h3>References</h3>

<p>Gautier, M. and Naves, M. (2011). Footprints of selection in the ancestral admixture of a New World Creole cattle breed. <em>Molecular Ecology</em>, <strong>20</strong>, 3128-3143.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data2haplohh">data2haplohh</a></code>
</p>

<hr>
<h2 id='haplohh-class'>Class &quot;haplohh&quot;</h2><span id='topic+haplohh-class'></span><span id='topic+chr.name'></span><span id='topic+positions'></span><span id='topic+haplo'></span><span id='topic+nmrk'></span><span id='topic+nhap'></span><span id='topic+mrk.names'></span><span id='topic+hap.names'></span><span id='topic+chr.name+2Chaplohh-method'></span><span id='topic+chr.name+2C'></span><span id='topic+positions+2Chaplohh-method'></span><span id='topic+positions+2C'></span><span id='topic+haplo+2Chaplohh-method'></span><span id='topic+haplo+2C'></span><span id='topic+nmrk+2Chaplohh-method'></span><span id='topic+nmrk+2C'></span><span id='topic+mrk.names+2Chaplohh-method'></span><span id='topic+mrk.names+2C'></span><span id='topic+nhap+2Chaplohh-method'></span><span id='topic+nhap+2C'></span><span id='topic+hap.names+2Chaplohh-method'></span><span id='topic+hap.names+2C'></span>

<h3>Description</h3>

<p>An object of this class contains the information needed for computation of EHH based statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'haplohh'
chr.name(x)

## S4 method for signature 'haplohh'
positions(x)

## S4 method for signature 'haplohh'
haplo(x)

## S4 method for signature 'haplohh'
nmrk(x)

## S4 method for signature 'haplohh'
mrk.names(x)

## S4 method for signature 'haplohh'
nhap(x)

## S4 method for signature 'haplohh'
hap.names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="haplohh-class_+3A_x">x</code></td>
<td>
<p>an object of this class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This class is the basis for all calculations done by this package.
Note that the matrix in slot <code>haplo</code> has to be of type <code>integer</code>, not <code>numeric</code>.
Objects built by versions of rehh up to 2.0.4 coded this matrix as <code>numeric</code> and used
a different coding scheme. They can be converted e.g. by
<code>haplohh &lt;- update_haplohh(old_haplohh)</code> in order be used
with the present version.
</p>


<h3>Slots</h3>


<dl>
<dt><code>chr.name</code></dt><dd><p>name of the chromosome/scaffold to which the markers belong.</p>
</dd>
<dt><code>positions</code></dt><dd><p>vector of type <code>numeric</code> containing the marker positions within the chromosome.</p>
</dd>
<dt><code>haplo</code></dt><dd><p>matrix of type <code>integer</code> containing haplotypes in rows and markers in columns.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+data2haplohh">data2haplohh</a></code>, <code><a href="#topic+update_haplohh">update_haplohh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("haplohh")
</code></pre>

<hr>
<h2 id='haplohh2sweepfinder'>Translate object of <code><a href="#topic+haplohh-class">haplohh-class</a></code> into SweepFinder format</h2><span id='topic+haplohh2sweepfinder'></span>

<h3>Description</h3>

<p>Extract allele frequencies of an object of class <code><a href="#topic+haplohh-class">haplohh-class</a></code>
and returns a table in SweepFinder input format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haplohh2sweepfinder(haplohh, polarized = TRUE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="haplohh2sweepfinder_+3A_haplohh">haplohh</code></td>
<td>
<p>object of class <code><a href="#topic+haplohh-class">haplohh-class</a></code>.</p>
</td></tr>
<tr><td><code id="haplohh2sweepfinder_+3A_polarized">polarized</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), flag &quot;folded&quot; is set to 0, otherwise to 1.</p>
</td></tr>
<tr><td><code id="haplohh2sweepfinder_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), prints filter statements.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>SweepFinder and SweeD are two stand-alone programs which
implement the same method to detect selective sweeps using the
allele frequency at each site. This function calculates these frequencies
from a <code><a href="#topic+haplohh-class">haplohh-class</a></code> and returns a table which
can be saved into a file (with tabs as separators, without row names and quotes) that can
be used as input for the two programs.
</p>
<p>Sites with less than two haplotypes genotyped or with more than two alleles are removed.
If <code>polarized</code>, sites monomorphic for the ancestral allele are removed, too.
</p>


<h3>Value</h3>

<p>A dataframe with four columns:
</p>

<ul>
<li> <p><strong>position</strong> marker position
</p>
</li>
<li> <p><strong>x</strong> (absolute) frequency of the alternative (derived) variant
</p>
</li>
<li> <p><strong>n</strong> number of non-missing genotypes
</p>
</li>
<li> <p><strong>folded</strong> a flag marking polarization
</p>
</li></ul>



<h3>References</h3>

<p>DeGiorgio, M., and, Huber, CD and Hubisz, MJ and, Hellmann, I. and Nielsen, R. (2016)
SweepFinder2: increased robustness and flexibility. <em>Bioinformatics</em> <strong>32</strong>:1895-1897
</p>
<p>Pavlidis, P., D. Zivkovic, A. Stamatakis, and N. Alachiotis, (2013)
SweeD: likelihood-based detection of selective sweeps in thousands of genomes.
<em>Molecular Biology and Evolution</em> <strong>30</strong>: 2224-34.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplohh-class">haplohh-class</a></code>, <code><a href="#topic+data2haplohh">data2haplohh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#example
# sweepfinder example from vignette
make.example.files()
hh &lt;- data2haplohh("example_sweep_with_recombination.vcf")
haplohh2sweepfinder(hh)
remove.example.files()
</code></pre>

<hr>
<h2 id='ies2xpehh'>Compute XP-EHH</h2><span id='topic+ies2xpehh'></span>

<h3>Description</h3>

<p>Compute XP-EHH (standardized ratio of iES of two populations).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ies2xpehh(
  scan_pop1,
  scan_pop2,
  popname1 = NA,
  popname2 = NA,
  min_nhaplo = NA,
  standardize = TRUE,
  include_freq = FALSE,
  p.side = NA,
  p.adjust.method = "none",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ies2xpehh_+3A_scan_pop1">scan_pop1</code></td>
<td>
<p>a data frame with markers in rows and columns with chromosome name, position of the
marker, frequency of the ancestral allele and iES as obtained by <code><a href="#topic+scan_hh">scan_hh</a></code> on the first population.</p>
</td></tr>
<tr><td><code id="ies2xpehh_+3A_scan_pop2">scan_pop2</code></td>
<td>
<p>a data frame with markers in rows and columns with chromosome name, position of the
marker, frequency of the ancestral allele and iES as obtained by <code><a href="#topic+scan_hh">scan_hh</a></code> on the second population.</p>
</td></tr>
<tr><td><code id="ies2xpehh_+3A_popname1">popname1</code></td>
<td>
<p>short ID/name of the first population; to be added to an output column name.</p>
</td></tr>
<tr><td><code id="ies2xpehh_+3A_popname2">popname2</code></td>
<td>
<p>short ID/name of the second population; to be added to an output column name.</p>
</td></tr>
<tr><td><code id="ies2xpehh_+3A_min_nhaplo">min_nhaplo</code></td>
<td>
<p>discard positions where in at least one of the populations fewer than <code>min_nhaplo</code> haplotypes
have been evaluated (default <code>NA</code>).</p>
</td></tr>
<tr><td><code id="ies2xpehh_+3A_standardize">standardize</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), then standardize XP-EHH, else report unstandardized XP-EHH.</p>
</td></tr>
<tr><td><code id="ies2xpehh_+3A_include_freq">include_freq</code></td>
<td>
<p>logical. If <code>TRUE</code> include columns with allele frequencies into result.</p>
</td></tr>
<tr><td><code id="ies2xpehh_+3A_p.side">p.side</code></td>
<td>
<p>side to which refers the p-value. Default <code>NA</code>, meaning two-sided. Can be set
to <code>"left"</code> or <code>"right"</code>.</p>
</td></tr>
<tr><td><code id="ies2xpehh_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method passed to function <code><a href="stats.html#topic+p.adjust">p.adjust</a></code> to correct the p-value for
multiple testing. Default <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="ies2xpehh_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), report number of markers of the two source data frames and result data frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Log ratio of iES (population 1 over population 2) computed as described in Sabeti et al. (2007).
Note that the two data frames are merged on the basis of chromosome and position. Marker names
are kept, if they are identical and unique in both data frames.
</p>
<p>Since the standardized XP-EHH values follow, if markers evolve predominantly neutrally, approximately
a standard Gaussian distribution, it is practical to assign to the values a p-value relative
to the null-hypothesis of neutral evolution. The parameter <code>p.side</code> determines
if the p-value is assigned to both sides of the distribution or to one side of interest.
</p>


<h3>Value</h3>

<p>The returned value is a data frame with markers in rows and columns for chromosome name, marker position,
XP-EHH and, if standardized, p-value in a negative log10 scale. Optionally, allele frequencies are included.
</p>


<h3>References</h3>

<p>Gautier, M. and Naves, M. (2011). Footprints of selection in the ancestral admixture of a New World Creole cattle breed. <em>Molecular Ecology</em>, <strong>20</strong>, 3128-3143.
</p>
<p>Sabeti, P.C. et al. (2007). Genome-wide detection and characterization of positive selection in human populations. <em>Nature</em>, <strong>449</strong>, 913-918.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scan_hh">scan_hh</a></code>, <code><a href="#topic+distribplot">distribplot</a></code>, <code><a href="#topic+manhattanplot">manhattanplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rehh.data)
data(wgscan.cgu) ; data(wgscan.eut)
## results from a genome scan (44,057 SNPs)
##see ?wgscan.eut and ?wgscan.cgu for details
wgscan.xpehh &lt;- ies2xpehh(wgscan.cgu, wgscan.eut, "CGU", "EUT")
</code></pre>

<hr>
<h2 id='ihh2ihs'>Compute iHS</h2><span id='topic+ihh2ihs'></span>

<h3>Description</h3>

<p>Compute iHS (standardized ratio of iHH values of two alleles).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ihh2ihs(
  scan,
  freqbin = 0.025,
  min_maf = 0.05,
  min_nhaplo = NA,
  standardize = TRUE,
  include_freq = FALSE,
  right = FALSE,
  alpha = 0.05,
  p.side = NA,
  p.adjust.method = "none",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ihh2ihs_+3A_scan">scan</code></td>
<td>
<p>a data frame with chromosome name,
marker position, frequency of ancestral (resp. major) allele, frequency of derived (resp. minor)
allele, and iHH for both alleles, as obtained from function <code><a href="#topic+scan_hh">scan_hh</a></code>.</p>
</td></tr>
<tr><td><code id="ihh2ihs_+3A_freqbin">freqbin</code></td>
<td>
<p>size of the bins to standardize log(iHH_A/iHH_D). Markers are binned with
respect to the derived allele frequency at the focal marker. The bins are built from
<code>min_maf</code> to <code>1-min_maf</code> in steps of size <code>freqbin</code>. If set to 0, standardization
is performed considering each observed frequency as a discrete frequency
class (useful in case of a large number of markers and few different haplotypes).
If set to an integer of 1 or greater, a corresponding number of equally sized bins are created.</p>
</td></tr>
<tr><td><code id="ihh2ihs_+3A_min_maf">min_maf</code></td>
<td>
<p>focal markers with a MAF (Minor Allele Frequency) lower than or equal to <code>min_maf</code>
are discarded from the analysis (default 0.05).</p>
</td></tr>
<tr><td><code id="ihh2ihs_+3A_min_nhaplo">min_nhaplo</code></td>
<td>
<p>focal markers with least one of the two compared alleles carried by fewer
than <code>min_nhaplo</code> haplotypes, are discarded (default <code>NA</code>).</p>
</td></tr>
<tr><td><code id="ihh2ihs_+3A_standardize">standardize</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), then standardize iHS, else report unstandardized iHS.</p>
</td></tr>
<tr><td><code id="ihh2ihs_+3A_include_freq">include_freq</code></td>
<td>
<p>logical. If <code>TRUE</code> include columns with allele frequencies into result.</p>
</td></tr>
<tr><td><code id="ihh2ihs_+3A_right">right</code></td>
<td>
<p>logical. If <code>TRUE</code> the bin intervals are closed on the right (and open on the left).</p>
</td></tr>
<tr><td><code id="ihh2ihs_+3A_alpha">alpha</code></td>
<td>
<p>calculate quantiles <code>alpha/2</code> and <code>(1-alpha/2)</code> for unstandardized binned iHS.</p>
</td></tr>
<tr><td><code id="ihh2ihs_+3A_p.side">p.side</code></td>
<td>
<p>side to which refers the p-value. Default <code>NA</code>, meaning two-sided. Can be set
to <code>"left"</code> or <code>"right"</code>.</p>
</td></tr>
<tr><td><code id="ihh2ihs_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method passed to function <code><a href="stats.html#topic+p.adjust">p.adjust</a></code> to correct the p-value for
multiple testing. Default <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="ihh2ihs_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), report number of markers of the source data frame and result data frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes log ratio of iHH of two focal alleles as described in Voight et al. (2006). The standardization
is performed within each bins separately because of the frequency-dependence
of expected iHS values under neutrality. An implicit assumption of this
approach is that each bin is dominated by neutral markers.
</p>
<p>Since the standardized iHS values follow, if markers evolve predominantly neutrally, approximately
a standard Gaussian distribution, it is practical to assign to the values a p-value relative
to the null-hypothesis of neutral evolution. The parameter <code>p.side</code> determines
if the p-value is assigned to both sides of the distribution or to one side of interest.
</p>


<h3>Value</h3>

<p>The returned value is a list containing two elements
</p>

<dl>
<dt>ihs</dt><dd><p>a data frame with markers in rows and the columns for chromosome name, marker position,
iHS and, if standardized, p-value in a negative log10 scale. Optionally, allele frequencies are included.</p>
</dd>
<dt>frequency.class</dt><dd><p>a data frame with bins in rows and columns for
the number of markers, mean uniHS, standard deviation uniHS, lower quantile uniHS, upper quantile uniHS.</p>
</dd>
</dl>



<h3>References</h3>

<p>Gautier, M. and Naves, M. (2011). Footprints of selection in the ancestral admixture of a New World Creole cattle breed. <em>Molecular Ecology</em>, <strong>20</strong>, 3128-3143.
</p>
<p>Voight, B.F. and Kudaravalli, S. and Wen, X. and Pritchard, J.K. (2006). A map of recent positive selection in the human genome. <em>Plos Biology</em>, <strong>4</strong>, e72.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scan_hh">scan_hh</a></code>, <code><a href="#topic+distribplot">distribplot</a></code>, <code><a href="#topic+freqbinplot">freqbinplot</a></code>, <code><a href="#topic+manhattanplot">manhattanplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rehh.data)
data(wgscan.cgu)
#results from a genome scan (44,057 SNPs)
#see ?wgscan.eut and ?wgscan.cgu for details
wgscan.cgu.ihs &lt;- ihh2ihs(wgscan.cgu)
</code></pre>

<hr>
<h2 id='ines2rsb'>Compute Rsb</h2><span id='topic+ines2rsb'></span>

<h3>Description</h3>

<p>Compute Rsb (standardized ratio of inES of two populations).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ines2rsb(
  scan_pop1,
  scan_pop2,
  popname1 = NA,
  popname2 = NA,
  min_nhaplo = NA,
  standardize = TRUE,
  include_freq = FALSE,
  p.side = NA,
  p.adjust.method = "none",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ines2rsb_+3A_scan_pop1">scan_pop1</code></td>
<td>
<p>a data frame with markers in rows and columns with chromosome name, position of the
marker, frequency of the ancestral allele and inES as obtained by <code><a href="#topic+scan_hh">scan_hh</a></code> on the first population.</p>
</td></tr>
<tr><td><code id="ines2rsb_+3A_scan_pop2">scan_pop2</code></td>
<td>
<p>a data frame with markers in rows and columns with chromosome name, position of the
marker, frequency of the ancestral allele and inES as obtained by <code><a href="#topic+scan_hh">scan_hh</a></code> on the second population.</p>
</td></tr>
<tr><td><code id="ines2rsb_+3A_popname1">popname1</code></td>
<td>
<p>short ID/name of the first population; to be added to an output column name.</p>
</td></tr>
<tr><td><code id="ines2rsb_+3A_popname2">popname2</code></td>
<td>
<p>short ID/name of the second population; to be added to an output column name.</p>
</td></tr>
<tr><td><code id="ines2rsb_+3A_min_nhaplo">min_nhaplo</code></td>
<td>
<p>discard positions where in at least one of the populations fewer than <code>min_nhaplo</code> haplotypes
have been evaluated (default <code>NA</code>).</p>
</td></tr>
<tr><td><code id="ines2rsb_+3A_standardize">standardize</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), then standardize Rsb, else report unstandardized Rsb.</p>
</td></tr>
<tr><td><code id="ines2rsb_+3A_include_freq">include_freq</code></td>
<td>
<p>logical. If <code>TRUE</code> include columns with allele frequencies into result.</p>
</td></tr>
<tr><td><code id="ines2rsb_+3A_p.side">p.side</code></td>
<td>
<p>side to which refers the p-value. Default <code>NA</code>, meaning two-sided. Can be set
to <code>"left"</code> or <code>"right"</code>.</p>
</td></tr>
<tr><td><code id="ines2rsb_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method passed to function <code><a href="stats.html#topic+p.adjust">p.adjust</a></code> to correct the p-value for
multiple testing. Default <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="ines2rsb_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), report number of markers of the two source data frames and result data frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Log ratio of inES (population 1 over population 2) computed as described in Tang et al. (2007).
Note that the two data frames are merged on the basis of chromosome and position. Marker names
are kept, if they are identical and unique in both data frames.
</p>
<p>Since the standardized Rsb values follow, if markers evolve predominantly neutrally, approximately
a standard Gaussian distribution, it is practical to assign to the values a p-value relative
to the null-hypothesis of neutral evolution. The parameter <code>p.side</code> determines
if the p-value is assigned to both sides of the distribution or to one side of interest.
</p>


<h3>Value</h3>

<p>The returned value is a data frame with markers in rows and columns for chromosome name, marker position,
Rsb and, if standardized, p-value in a negative log10 scale. Optionally, allele frequencies are included.
</p>


<h3>References</h3>

<p>Gautier, M. and Naves, M. (2011). Footprints of selection in the ancestral admixture of a New World Creole cattle breed. <em>Molecular Ecology</em>, <strong>20</strong>, 3128-3143.
</p>
<p>Tang, K. and Thornton, K.R. and Stoneking, M. (2007). A New Approach for Using Genome Scans to Detect Recent Positive Selection in the Human Genome. <em>Plos Biology</em>, <strong>7</strong>, e171.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scan_hh">scan_hh</a></code>, <code><a href="#topic+distribplot">distribplot</a></code>, <code><a href="#topic+manhattanplot">manhattanplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rehh.data)
data(wgscan.cgu) ; data(wgscan.eut)
## results from a genome scan (44,057 SNPs)
##see ?wgscan.eut and ?wgscan.cgu for details
wgscan.rsb &lt;- ines2rsb(wgscan.cgu, wgscan.eut, "CGU", "EUT")
</code></pre>

<hr>
<h2 id='make.example.files'>Copy example input files into current working directory</h2><span id='topic+make.example.files'></span>

<h3>Description</h3>

<p>This function copies the following example files to the current working directory:
</p>

<ul>
<li> <p><code>example1.hap</code> &quot;example 1&quot; haplotype file in &quot;standard format&quot;
</p>
</li>
<li> <p><code>example1.map</code> &quot;example 1&quot; marker information file
</p>
</li>
<li> <p><code>example1.vcf</code> &quot;example 1&quot; as vcf file
</p>
</li>
<li> <p><code>example2.hap</code> &quot;example 2&quot; haplotype file in &quot;standard format&quot;
</p>
</li>
<li> <p><code>example2.map</code> &quot;example 2&quot; marker information file
</p>
</li>
<li> <p><code>example2.vcf</code> &quot;example 2&quot; as vcf file
</p>
</li>
<li> <p><code>example_neutral.vcf</code> &quot;example neutral evolution&quot; as vcf file
</p>
</li>
<li> <p><code>example_sweep.vcf</code> &quot;example for a selective sweep (without recombination)&quot;
</p>
</li>
<li> <p><code>example_sweep_with_recombination.vcf</code> &quot;example for a selective sweep with recombination
</p>
</li>
<li> <p><code>ms.out output</code> from a small simulation by the program 'ms'
</p>
</li>
<li> <p><code>bta12_cgu.hap</code> an haplotype file in &quot;standard format&quot;
</p>
</li>
<li> <p><code>bta12_cgu.thap</code> an haplotype file in &quot;transposed format&quot;
</p>
</li>
<li> <p><code>bta12_hapguess_switch.out</code> an haplotype file in fastphase output format
</p>
</li>
<li> <p><code>map.inp</code> a marker information file for all bta_cgu markers
</p>
</li></ul>

<p>Example 1 was used in (Gautier 2017) to explain the various EHH derived statistics calculated by this package.
Example 2 is an extension containing multi-allelic markers and missing values.
</p>
<p>Examples for neutral data and sweeps are discussed in a supplement of Klassmann (2020).
</p>
<p>The bta12 files contain data for 280 haplotypes, originating from 140 individuals belonging to the
Creole cattle breed from Guadeloupe, at 1.424 markers mapping to bovine chromosome 12 (BTA12) (Gautier 2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.example.files()
</code></pre>


<h3>References</h3>

<p>Gautier, M. and Naves, M. (2011). Footprints of selection in the ancestral admixture of a New World Creole cattle breed. <em>Molecular Ecology</em>, <strong>20</strong>, 3128-3143.
</p>
<p>Gautier, M., Klassmann,  A. and Vitalis, R. (2017). rehh 2.0: a reimplementation of the R package rehh to detect positive selection from haplotype structure. <em>Molecular Ecology Resources</em>, <strong>17</strong>, 78-90.
</p>
<p>Klassmann, A. and Gautier, M. (2020). Detecting selection using Extended Haplotype
Homozygosity-based statistics on unphased or unpolarized data (preprint). 
https://doi.org/10.22541/au.160405572.29972398/v1
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data2haplohh">data2haplohh</a></code>, <code><a href="#topic+remove.example.files">remove.example.files</a></code>
</p>

<hr>
<h2 id='manhattanplot'>Manhattan plot of iHS, XP-EHH or Rsb over a genome.</h2><span id='topic+manhattanplot'></span>

<h3>Description</h3>

<p>Manhattanplot of iHS, XP-EHH or Rsb over a genome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manhattanplot(
  data,
  pval = FALSE,
  threshold = c(-2, 2),
  chr.name = NA,
  cr = NULL,
  cr.col = "gray",
  cr.opacity = 0.5,
  cr.lab.cex = 0.6,
  cr.lab.offset = 0,
  cr.lab.pos = "top",
  mrk = NULL,
  mrk.cex = 1,
  mrk.col = "gray",
  mrk.pch = 1,
  mrk.lab.cex = 0.4,
  mrk.lab.pos = 4,
  ignore_sign = FALSE,
  cex = 0.5,
  las = 1,
  pch = 20,
  inset = 5e+06,
  resolution = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manhattanplot_+3A_data">data</code></td>
<td>
<p>output of either <code><a href="#topic+ihh2ihs">ihh2ihs</a></code>, <code><a href="#topic+ies2xpehh">ies2xpehh</a></code> or <code><a href="#topic+ines2rsb">ines2rsb</a></code>.</p>
</td></tr>
<tr><td><code id="manhattanplot_+3A_pval">pval</code></td>
<td>
<p>logical. If <code>TRUE</code>, the p-value is plotted, otherwise the score itself.</p>
</td></tr>
<tr><td><code id="manhattanplot_+3A_threshold">threshold</code></td>
<td>
<p>a horizontal line is added at the corresponding value(s),
for instance to represent a significance threshold.
A single value (upper or lower threshold) or two values (upper and lower) can be specified.</p>
</td></tr>
<tr><td><code id="manhattanplot_+3A_chr.name">chr.name</code></td>
<td>
<p>if <code>NA</code> (default), all chromosomes are plotted, otherwise only those specified.</p>
</td></tr>
<tr><td><code id="manhattanplot_+3A_cr">cr</code></td>
<td>
<p>highlight &quot;candidate regions&quot; specified by a data.frame with columns <code>CHR</code>, <code>START</code>
and <code>END</code> as obtained by the function <code><a href="#topic+calc_candidate_regions">calc_candidate_regions</a></code>.</p>
</td></tr>
<tr><td><code id="manhattanplot_+3A_cr.col">cr.col</code></td>
<td>
<p>the color for highlighting</p>
</td></tr>
<tr><td><code id="manhattanplot_+3A_cr.opacity">cr.opacity</code></td>
<td>
<p>a value between 0 (invisible) and 1 (opaque).</p>
</td></tr>
<tr><td><code id="manhattanplot_+3A_cr.lab.cex">cr.lab.cex</code></td>
<td>
<p>text size of candidate region labels.</p>
</td></tr>
<tr><td><code id="manhattanplot_+3A_cr.lab.offset">cr.lab.offset</code></td>
<td>
<p>offset of candidate region labels.</p>
</td></tr>
<tr><td><code id="manhattanplot_+3A_cr.lab.pos">cr.lab.pos</code></td>
<td>
<p>if <code>"top"</code> (default) or <code>"bottom"</code>, candidate regions are labeled by numbers; to turn off, use <code>"none"</code></p>
</td></tr>
<tr><td><code id="manhattanplot_+3A_mrk">mrk</code></td>
<td>
<p>highlight marker specified by a data.frame containing the
colums <code>CHR</code> and <code>POSITION</code>. The row names of that data frame are taken as labels.
Alternatively a vector with marker IDs can be specified. In the latter case the ID is used as label.</p>
</td></tr>
<tr><td><code id="manhattanplot_+3A_mrk.cex">mrk.cex</code></td>
<td>
<p>size of marker label.</p>
</td></tr>
<tr><td><code id="manhattanplot_+3A_mrk.col">mrk.col</code></td>
<td>
<p>color of the highlighted points.</p>
</td></tr>
<tr><td><code id="manhattanplot_+3A_mrk.pch">mrk.pch</code></td>
<td>
<p>type of the highlighted points.</p>
</td></tr>
<tr><td><code id="manhattanplot_+3A_mrk.lab.cex">mrk.lab.cex</code></td>
<td>
<p>text size of marker label. If zero, no labels are printed.</p>
</td></tr>
<tr><td><code id="manhattanplot_+3A_mrk.lab.pos">mrk.lab.pos</code></td>
<td>
<p>a position specifier for the text.
Values of 1, 2, 3 and 4, respectively indicate positions below, to the left of, above and to the right of the highlighted marker.</p>
</td></tr>
<tr><td><code id="manhattanplot_+3A_ignore_sign">ignore_sign</code></td>
<td>
<p>logical. If <code>TRUE</code>, absolute values are plotted.</p>
</td></tr>
<tr><td><code id="manhattanplot_+3A_cex">cex</code></td>
<td>
<p>size of the points representing markers in the plot(s) (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="manhattanplot_+3A_las">las</code></td>
<td>
<p>orientation of axis labels (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="manhattanplot_+3A_pch">pch</code></td>
<td>
<p>type of the points representing markers in the plot(s) (see <code><a href="graphics.html#topic+points">points</a></code>).</p>
</td></tr>
<tr><td><code id="manhattanplot_+3A_inset">inset</code></td>
<td>
<p>inset (in bases) between chromosomes to avoid overlap of data points. Default: 5,000,000 bases.</p>
</td></tr>
<tr><td><code id="manhattanplot_+3A_resolution">resolution</code></td>
<td>
<p>Rasterize data points to the specified resolution and remove
duplicate points. Defaults to NULL, i.e. no rasterization. A typical value might be <code>c(1E5, 0.01)</code>,
meaning that resolution on the x-axis (chromosomal position) is 100000 and on the y-axis (score or p-value) is 0.01.</p>
</td></tr>
<tr><td><code id="manhattanplot_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The color of chromosomes is taken from the &quot;Graphics Palette&quot;, see <code><a href="grDevices.html#topic+palette">palette</a></code>.
</p>
<p>If a single chromosome is plotted, a genomic region can be specified by
argument <code>xlim</code>.
</p>
<p>Other statistics can be plotted as well, although a warning is issued. They must be given by a data.frame
with columns CHR and POSITION and the statistic in the third column.
</p>


<h3>Value</h3>

<p>The function returns a plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ihh2ihs">ihh2ihs</a></code>, <code><a href="#topic+ies2xpehh">ies2xpehh</a></code>, <code><a href="#topic+ines2rsb">ines2rsb</a></code>, <code><a href="#topic+calc_candidate_regions">calc_candidate_regions</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rehh.data)
data(wgscan.cgu)
## results from a genome scan (44,057 SNPs)
## see ?wgscan.eut and ?wgscan.cgu for details
wgscan.ihs &lt;- ihh2ihs(wgscan.cgu)
manhattanplot(wgscan.ihs)
</code></pre>

<hr>
<h2 id='plot.ehh'>Plot EHH around a focal marker</h2><span id='topic+plot.ehh'></span>

<h3>Description</h3>

<p>Plot curve of EHH values around a focal marker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ehh'
plot(
  x,
  ylim = c(0, 1),
  type = "l",
  main = paste0("EHH around '", x$mrk.name, "'"),
  xlab = "Position",
  ylab = "Extended Haplotype Homozygosity",
  col = c("blue", "red", "violet", "orange"),
  mrk.col = "gray",
  bty = "n",
  legend = NA,
  legend.xy.coords = "automatic",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ehh_+3A_x">x</code></td>
<td>
<p>data (output of <code><a href="#topic+calc_ehh">calc_ehh</a></code>).</p>
</td></tr>
<tr><td><code id="plot.ehh_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot</p>
</td></tr>
<tr><td><code id="plot.ehh_+3A_type">type</code></td>
<td>
<p>plot type (see code<a href="graphics.html#topic+plot.default">plot.default</a> and <code><a href="graphics.html#topic+matplot">matplot</a></code>). 
Type <code>"s"</code> or <code>"S"</code> yield both (the same) piecewise constant curve.</p>
</td></tr>
<tr><td><code id="plot.ehh_+3A_main">main</code></td>
<td>
<p>title for the plot (default <code>NA</code>, i.e. none).</p>
</td></tr>
<tr><td><code id="plot.ehh_+3A_xlab">xlab</code></td>
<td>
<p>title for the x-axis.</p>
</td></tr>
<tr><td><code id="plot.ehh_+3A_ylab">ylab</code></td>
<td>
<p>title for the y-axis.</p>
</td></tr>
<tr><td><code id="plot.ehh_+3A_col">col</code></td>
<td>
<p>color for the ancestral and derived alleles (respectively) curves.</p>
</td></tr>
<tr><td><code id="plot.ehh_+3A_mrk.col">mrk.col</code></td>
<td>
<p>color of the vertical line at the focal marker position.</p>
</td></tr>
<tr><td><code id="plot.ehh_+3A_bty">bty</code></td>
<td>
<p>box type around plot (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="plot.ehh_+3A_legend">legend</code></td>
<td>
<p>legend text.</p>
</td></tr>
<tr><td><code id="plot.ehh_+3A_legend.xy.coords">legend.xy.coords</code></td>
<td>
<p>if <code>"automatic"</code> (default) places legend either top left or top right;
if <code>"none"</code>, no legend is drawn; otherwise the argument is passed to <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="plot.ehh_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to function <code><a href="graphics.html#topic+matplot">matplot</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+data2haplohh">data2haplohh</a></code>, <code><a href="#topic+calc_ehh">calc_ehh</a></code>, <code><a href="#topic+plot.ehhs">plot.ehhs</a></code>, <code><a href="#topic+scan_hh">scan_hh</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#example haplohh object (280 haplotypes, 1424 SNPs)
#see ?haplohh_cgu_bta12 for details
data(haplohh_cgu_bta12)
#computing EHH statistics for the marker "F1205400"
#which displays a strong signal of selection
ehh &lt;- calc_ehh(haplohh_cgu_bta12, mrk = "F1205400")
plot(ehh)
</code></pre>

<hr>
<h2 id='plot.ehhs'>Plot EHHS around a focal marker</h2><span id='topic+plot.ehhs'></span>

<h3>Description</h3>

<p>Plot curve of EHHS values around a focal marker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ehhs'
plot(
  x,
  nehhs = FALSE,
  ylim = c(0, 1),
  type = "l",
  main = paste0("EHHS around '", x$mrk.name, "'"),
  xlab = "Position",
  ylab = "Extended Haplotype Homozygosity per Site",
  bty = "n",
  mrk.col = "gray",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ehhs_+3A_x">x</code></td>
<td>
<p>data (output of <code><a href="#topic+calc_ehhs">calc_ehhs</a></code>).</p>
</td></tr>
<tr><td><code id="plot.ehhs_+3A_nehhs">nehhs</code></td>
<td>
<p>logical. If <code>TRUE</code>, plot normalized EHHS.</p>
</td></tr>
<tr><td><code id="plot.ehhs_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot</p>
</td></tr>
<tr><td><code id="plot.ehhs_+3A_type">type</code></td>
<td>
<p>plot type (see code<a href="graphics.html#topic+plot.default">plot.default</a>.
Type <code>"s"</code> or <code>"S"</code> yield both (the same) piecewise constant curve.</p>
</td></tr>
<tr><td><code id="plot.ehhs_+3A_main">main</code></td>
<td>
<p>title for the plot (default <code>NA</code>, i.e. none).</p>
</td></tr>
<tr><td><code id="plot.ehhs_+3A_xlab">xlab</code></td>
<td>
<p>title for the x-axis.</p>
</td></tr>
<tr><td><code id="plot.ehhs_+3A_ylab">ylab</code></td>
<td>
<p>title for the y-axis.</p>
</td></tr>
<tr><td><code id="plot.ehhs_+3A_bty">bty</code></td>
<td>
<p>box type around plot (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="plot.ehhs_+3A_mrk.col">mrk.col</code></td>
<td>
<p>color of the vertical line at the focal marker position.</p>
</td></tr>
<tr><td><code id="plot.ehhs_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to function <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+data2haplohh">data2haplohh</a></code>, <code><a href="#topic+plot.ehh">plot.ehh</a></code>, <code><a href="#topic+calc_ehhs">calc_ehhs</a></code>, <code><a href="#topic+scan_hh">scan_hh</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#example haplohh object (280 haplotypes, 1424 SNPs)
#see ?haplohh_cgu_bta12 for details
data(haplohh_cgu_bta12)
#computing EHHS statisitics for the marker "F1205400"
#which displays a strong signal of selection
ehhs &lt;- calc_ehhs(haplohh_cgu_bta12, mrk = "F1205400")
plot(ehhs)
</code></pre>

<hr>
<h2 id='plot.furcation'>Plots furcation trees around a focal marker</h2><span id='topic+plot.furcation'></span>

<h3>Description</h3>

<p>Plots furcation trees around a focal marker
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'furcation'
plot(
  x,
  allele = NA,
  col = c("blue", "red", "violet", "orange"),
  mrk.col = "gray",
  lwd = 0.1,
  hap.names = NULL,
  cex.lab = 1,
  family.lab = "",
  offset.lab = 0.5,
  legend = NA,
  legend.xy.coords = "automatic",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.furcation_+3A_x">x</code></td>
<td>
<p>an object of class furcation (see <code><a href="#topic+calc_furcation">calc_furcation</a></code>).</p>
</td></tr>
<tr><td><code id="plot.furcation_+3A_allele">allele</code></td>
<td>
<p>If <code>NA</code> (default), furcation trees for all alleles of the focal marker are plotted,
otherwise for the specified alleles. Alleles must be specified by their
internal coding, i.e. '0' for ancestral resp. major allele, etc.</p>
</td></tr>
<tr><td><code id="plot.furcation_+3A_col">col</code></td>
<td>
<p>color for each allele (as coded internally).</p>
</td></tr>
<tr><td><code id="plot.furcation_+3A_mrk.col">mrk.col</code></td>
<td>
<p>color of the vertical line at the focal marker position.</p>
</td></tr>
<tr><td><code id="plot.furcation_+3A_lwd">lwd</code></td>
<td>
<p>controls the relative width of the diagram lines on the plot (default 0.1).</p>
</td></tr>
<tr><td><code id="plot.furcation_+3A_hap.names">hap.names</code></td>
<td>
<p>a vector containing names of chromosomes.</p>
</td></tr>
<tr><td><code id="plot.furcation_+3A_cex.lab">cex.lab</code></td>
<td>
<p>relative size of labels. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.furcation_+3A_family.lab">family.lab</code></td>
<td>
<p>font family for labels. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.furcation_+3A_offset.lab">offset.lab</code></td>
<td>
<p>offset of labels. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.furcation_+3A_legend">legend</code></td>
<td>
<p>legend text.</p>
</td></tr>
<tr><td><code id="plot.furcation_+3A_legend.xy.coords">legend.xy.coords</code></td>
<td>
<p>if <code>"automatic"</code> (default) places legend either top left or top right;
if <code>"none"</code>, no legend is drawn; otherwise argument is passed to <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="plot.furcation_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plot.haplen">plot.haplen</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#example haplohh object (280 haplotypes, 1424 SNPs)
#see ?haplohh_cgu_bta12 for details
data(haplohh_cgu_bta12)
#plotting furcation diagram for both ancestral and derived allele
#from the marker "F1205400"
#which display a strong signal of selection
f &lt;- calc_furcation(haplohh_cgu_bta12, mrk = "F1205400")
plot(f)
plot(f, xlim = c(2e+07,3.5e+07))
plot(f, xlim = c(2.7e+07,3.1e+07))
plot(f, xlim = c(2.7e+07,3.1e+07), hap.names = hap.names(haplohh_cgu_bta12), cex.lab=0.3)
</code></pre>

<hr>
<h2 id='plot.haplen'>Plot the length of extended haplotypes around a focal marker</h2><span id='topic+plot.haplen'></span>

<h3>Description</h3>

<p>Plot the length of extended haplotype around a focal marker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haplen'
plot(
  x,
  allele = NA,
  group_by_allele = TRUE,
  order_by_length = FALSE,
  col = c("blue", "red", "violet", "orange"),
  mrk.col = "gray",
  lwd = 1,
  hap.names = NULL,
  cex.lab = 1,
  family.lab = "",
  offset.lab = 0.5,
  pos.lab = "left",
  legend = NA,
  legend.xy.coords = "automatic",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.haplen_+3A_x">x</code></td>
<td>
<p>an object of class <code>haplen</code> generated by <code><a href="#topic+calc_haplen">calc_haplen</a></code>.</p>
</td></tr>
<tr><td><code id="plot.haplen_+3A_allele">allele</code></td>
<td>
<p>if <code>NA</code> (default), haplotypes of all alleles are plotted,
otherwise for the specified alleles. Alleles must be specified by their
internal coding, i.e. '0' for ancestral resp. major allele, etc.</p>
</td></tr>
<tr><td><code id="plot.haplen_+3A_group_by_allele">group_by_allele</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), group chromosomes
by their allele at the focal marker; alleles are ordered by their internal coding
unless parameter <code>alleles</code> is specified. If <code>FALSE</code>, haplotypes are drawn by
their order in the input file.</p>
</td></tr>
<tr><td><code id="plot.haplen_+3A_order_by_length">order_by_length</code></td>
<td>
<p>if <code>TRUE</code>, chromosomes are ordered by their
shared haplotype length.</p>
</td></tr>
<tr><td><code id="plot.haplen_+3A_col">col</code></td>
<td>
<p>color for each allele (as coded internally).</p>
</td></tr>
<tr><td><code id="plot.haplen_+3A_mrk.col">mrk.col</code></td>
<td>
<p>color of the vertical line at the focal marker position.</p>
</td></tr>
<tr><td><code id="plot.haplen_+3A_lwd">lwd</code></td>
<td>
<p>line width.</p>
</td></tr>
<tr><td><code id="plot.haplen_+3A_hap.names">hap.names</code></td>
<td>
<p>a vector containing the names of chromosomes.</p>
</td></tr>
<tr><td><code id="plot.haplen_+3A_cex.lab">cex.lab</code></td>
<td>
<p>relative letter size of labels. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.haplen_+3A_family.lab">family.lab</code></td>
<td>
<p>font family for labels. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.haplen_+3A_offset.lab">offset.lab</code></td>
<td>
<p>offset of labels. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.haplen_+3A_pos.lab">pos.lab</code></td>
<td>
<p>position of haplotype labels. Either <code>"left"</code> , <code>"right"</code> or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="plot.haplen_+3A_legend">legend</code></td>
<td>
<p>legend text.</p>
</td></tr>
<tr><td><code id="plot.haplen_+3A_legend.xy.coords">legend.xy.coords</code></td>
<td>
<p>if <code>"automatic"</code> (default) places legend either top left or top right;
if <code>"none"</code>, no legend is drawn; otherwise argument is passed to <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="plot.haplen_+3A_...">...</code></td>
<td>
<p>other parameters to be passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+calc_haplen">calc_haplen</a></code>, <code><a href="#topic+plot.furcation">plot.furcation</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#example haplohh object (280 haplotypes, 1424 SNPs)
#see ?haplohh_cgu_bta12 for details
data(haplohh_cgu_bta12)
#plotting length of extended haplotypes for both ancestral and derived allele
#of the marker "F1205400"
#which displays a strong signal of selection
f &lt;- calc_furcation(haplohh_cgu_bta12, mrk = "F1205400")
h &lt;- calc_haplen(f)
plot(h)
plot(h, hap.names = hap.names(haplohh_cgu_bta12), cex.lab = 0.3)
</code></pre>

<hr>
<h2 id='plot.haplohh'>Plot the variants of a haplohh object</h2><span id='topic+plot.haplohh'></span>

<h3>Description</h3>

<p>Plot the variants of a haplohh object. This method is intended
for visualization of very small data sets such as the examples
provided by the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haplohh'
plot(
  x,
  mrk = NA,
  allele = NA,
  group_by_allele = FALSE,
  ignore.distances = FALSE,
  col = c("blue", "red", "violet", "orange"),
  linecol = "gray",
  mrk.col = "gray",
  pch = 19,
  cex = 1,
  lwd = 1,
  hap.names = NULL,
  mrk.names = NULL,
  cex.lab.hap = 0.8,
  cex.lab.mrk = 0.8,
  family.lab = "",
  offset.lab.hap = 0.5,
  offset.lab.mrk = 0.25,
  pos.lab.hap = "left",
  pos.lab.mrk = "top",
  srt.hap = 0,
  srt.mrk = 0,
  highlight.mrk = NULL,
  highlight.mrk.col = c("lightgray", "black", "darkgray"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.haplohh_+3A_x">x</code></td>
<td>
<p>an object of class <code>haplo-hh</code> generated by <code><a href="#topic+data2haplohh">data2haplohh</a></code>.</p>
</td></tr>
<tr><td><code id="plot.haplohh_+3A_mrk">mrk</code></td>
<td>
<p>the focal marker. Used only, if alleles are grouped or (de-)selected.</p>
</td></tr>
<tr><td><code id="plot.haplohh_+3A_allele">allele</code></td>
<td>
<p>if <code>NA</code> (default), haplotypes of all alleles are plotted,
otherwise for the specified alleles. Alleles must be specified by their
internal coding, i.e. '0' for ancestral resp. major allele, etc.
Haplotypes with missing values at the focal marker can only be selected in
combination with genotyped alleles, e.g. as <code>c(1,NA)</code>.</p>
</td></tr>
<tr><td><code id="plot.haplohh_+3A_group_by_allele">group_by_allele</code></td>
<td>
<p>logical. If <code>TRUE</code>, group chromosomes
by their allele at the focal marker; alleles are ordered by their internal coding
unless parameter <code>alleles</code> is specified. If <code>FALSE</code> (default), haplotypes are drawn by
their order in the input file.</p>
</td></tr>
<tr><td><code id="plot.haplohh_+3A_ignore.distances">ignore.distances</code></td>
<td>
<p>logical. If <code>TRUE</code>, markers are drawn equally-spaced.</p>
</td></tr>
<tr><td><code id="plot.haplohh_+3A_col">col</code></td>
<td>
<p>color for each allele (as coded internally).</p>
</td></tr>
<tr><td><code id="plot.haplohh_+3A_linecol">linecol</code></td>
<td>
<p>the color of the background lines. If more than one color is specified and sequences
sorted by the marker allele, the specified colors are used to distinguish the alleles; otherwise
consecutive sequences are set into the specified colors.</p>
</td></tr>
<tr><td><code id="plot.haplohh_+3A_mrk.col">mrk.col</code></td>
<td>
<p>color of the vertical line at the focal marker position.</p>
</td></tr>
<tr><td><code id="plot.haplohh_+3A_pch">pch</code></td>
<td>
<p>symbol used for markers. See <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="plot.haplohh_+3A_cex">cex</code></td>
<td>
<p>relative size of marker symbol. See <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="plot.haplohh_+3A_lwd">lwd</code></td>
<td>
<p>line width.</p>
</td></tr>
<tr><td><code id="plot.haplohh_+3A_hap.names">hap.names</code></td>
<td>
<p>a vector containing the names of chromosomes.</p>
</td></tr>
<tr><td><code id="plot.haplohh_+3A_mrk.names">mrk.names</code></td>
<td>
<p>a vector containing the names of markers.</p>
</td></tr>
<tr><td><code id="plot.haplohh_+3A_cex.lab.hap">cex.lab.hap</code></td>
<td>
<p>relative letter size of haplotype labels. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.haplohh_+3A_cex.lab.mrk">cex.lab.mrk</code></td>
<td>
<p>relative letter size of marker labels. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.haplohh_+3A_family.lab">family.lab</code></td>
<td>
<p>font family for labels. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.haplohh_+3A_offset.lab.hap">offset.lab.hap</code></td>
<td>
<p>offset of haplotype labels. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.haplohh_+3A_offset.lab.mrk">offset.lab.mrk</code></td>
<td>
<p>offset of marker labels. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.haplohh_+3A_pos.lab.hap">pos.lab.hap</code></td>
<td>
<p>position of haplotype labels. Either <code>"left"</code> (default),
<code>"right"</code>, <code>"none"</code> or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="plot.haplohh_+3A_pos.lab.mrk">pos.lab.mrk</code></td>
<td>
<p>position of marker labels. Either <code>"top"</code> (default) or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="plot.haplohh_+3A_srt.hap">srt.hap</code></td>
<td>
<p>rotation of haplotype labels (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="plot.haplohh_+3A_srt.mrk">srt.mrk</code></td>
<td>
<p>rotation of marker labels (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="plot.haplohh_+3A_highlight.mrk">highlight.mrk</code></td>
<td>
<p>vector of markers to be highlighted</p>
</td></tr>
<tr><td><code id="plot.haplohh_+3A_highlight.mrk.col">highlight.mrk.col</code></td>
<td>
<p>color for each allele (as coded internally) at highlighted markers.</p>
</td></tr>
<tr><td><code id="plot.haplohh_+3A_...">...</code></td>
<td>
<p>other parameters to be passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specifying a haplohh-object with more than 4096 haplotypes or
markers produces an error.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_haplen">calc_haplen</a></code>, <code><a href="#topic+plot.furcation">plot.furcation</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#example haplohh object
make.example.files()
hh &lt;- data2haplohh(hap_file = "example1.hap",
                   map_file = "example1.map",
                   allele_coding = "01")
plot(hh)
hh &lt;- data2haplohh(hap_file = "example2.hap",
                   map_file = "example2.map",
                   allele_coding = "01",
                   min_perc_geno.mrk = 50)
plot(hh)
remove.example.files()
</code></pre>

<hr>
<h2 id='rehh-package'>rehh: Searching for Footprints of Selection using 'Extended Haplotype
Homozygosity' Based Tests</h2><span id='topic+rehh'></span><span id='topic+rehh-package'></span>

<h3>Description</h3>

<p>Population genetic data such as 'Single Nucleotide
Polymorphisms' (SNPs) is often used to identify genomic regions
that have been under recent natural or artificial selection
and might provide clues about the molecular mechanisms of adaptation. 
One approach, the concept of an 'Extended Haplotype Homozygosity' (EHH), 
introduced by (Sabeti 2002) &lt;doi:10.1038/nature01140&gt;, has given rise to 
several statistics designed for whole genome scans. 
The package provides functions to compute three of these,
namely: 'iHS' (Voight 2006) &lt;doi:10.1371/journal.pbio.0040072&gt; for
detecting positive or 'Darwinian' selection within a single population as well as
'Rsb' (Tang 2007) &lt;doi:10.1371/journal.pbio.0050171&gt; and 
'XP-EHH' (Sabeti 2007) &lt;doi:10.1038/nature06250&gt;, targeted
at differential selection between two populations. 
Various plotting functions are included to facilitate
visualization and interpretation of these statistics.
</p>


<h3>Details</h3>

<p>See <code>vignette("rehh", package = "rehh")</code> for an overview of the package and
<code>vignette("examples", package = "rehh")</code> for a more detailed discussion of two small example
data sets.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Alexander Klassmann <a href="mailto:rehh@oneoverx.eu">rehh@oneoverx.eu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Mathieu Gautier <a href="mailto:mathieu.gautier@inrae.fr">mathieu.gautier@inrae.fr</a>
</p>
</li>
<li><p> Renaud Vitalis
</p>
</li></ul>



<h3>References</h3>

<p>Gautier, M. and Naves, M. (2011). Footprints of selection in the ancestral admixture of a New World Creole cattle breed. <em>Molecular Ecology</em>, <strong>20</strong>, 3128-3143.
</p>
<p>Gautier M. and Vitalis R. (2012). rehh: An R package to detect footprints of selection in
genome-wide SNP data from haplotype structure. <em>Bioinformatics</em>, <strong>28</strong>(8), 1176-1177.
</p>
<p>Gautier M., Klassmann A., and Vitalis R. (2017). rehh 2.0: a reimplementation of the R package
rehh to detect positive selection from haplotype structure. <em>Molecular Ecology Resources</em>, <strong>17</strong>, 78-90.
</p>
<p>Klassmann, A. and Gautier, M. (2020). Detecting selection using Extended Haplotype
Homozygosity-based statistics on unphased or unpolarized data (preprint). 
https://doi.org/10.22541/au.160405572.29972398/v1
</p>
<p>Sabeti, P.C. et al. (2002). Detecting recent positive selection in the human genome from haplotype structure. <em>Nature</em>, <strong>419</strong>, 832-837.
</p>
<p>Sabeti, P.C. et al. (2007). Genome-wide detection and characterization of positive selection in human populations. <em>Nature</em>, <strong>449</strong>, 913-918.
</p>
<p>Tang, K. and Thornton, K.R. and Stoneking, M. (2007). A New Approach for Using Genome Scans to Detect Recent Positive Selection in the Human Genome. <em>Plos Biology</em>, <strong>7</strong>, e171.
</p>
<p>Voight, B.F. and Kudaravalli, S. and Wen, X. and Pritchard, J.K. (2006). A map of recent positive selection in the human genome. <em>Plos Biology</em>, <strong>4</strong>, e72.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://CRAN.R-project.org/package=rehh">https://CRAN.R-project.org/package=rehh</a>
</p>
</li>
<li> <p><a href="https://gitlab.com/oneoverx/rehh">https://gitlab.com/oneoverx/rehh</a>
</p>
</li>
<li><p> Report bugs at <a href="https://gitlab.com/oneoverx/rehh/-/issues">https://gitlab.com/oneoverx/rehh/-/issues</a>
</p>
</li></ul>


<hr>
<h2 id='remove.example.files'>Remove example files from current working directory.</h2><span id='topic+remove.example.files'></span>

<h3>Description</h3>

<p>Remove example files from current working directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove.example.files()
</code></pre>


<h3>Details</h3>

<p>Removes the files created by <code>make.example.files()</code>. 
No error is thrown, if files do not exist.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.example.files">make.example.files</a></code>
</p>

<hr>
<h2 id='scan_hh'>Compute iHH, iES and inES over a whole chromosome</h2><span id='topic+scan_hh'></span>

<h3>Description</h3>

<p>Compute integrated EHH (iHH), integrated EHHS (iES) and integrated normalized EHHS (inES)
for all markers of a chromosome (or linkage group).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_hh(
  haplohh,
  limhaplo = 2,
  limhomohaplo = 2,
  limehh = 0.05,
  limehhs = 0.05,
  phased = TRUE,
  polarized = TRUE,
  scalegap = NA,
  maxgap = NA,
  discard_integration_at_border = TRUE,
  lower_ehh_y_bound = limehh,
  lower_ehhs_y_bound = limehhs,
  interpolate = TRUE,
  threads = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_hh_+3A_haplohh">haplohh</code></td>
<td>
<p>an object of class <code>haplohh</code> (see <code><a href="#topic+data2haplohh">data2haplohh</a></code>)</p>
</td></tr>
<tr><td><code id="scan_hh_+3A_limhaplo">limhaplo</code></td>
<td>
<p>if there are less than <code>limhaplo</code> chromosomes that can be used for
the calculation of EHH(S), the calculation is stopped. The option is intended for the case of missing data,
which leads to the successive exclusion of haplotypes: the further away from the focal marker
the less haplotypes contribute to EHH(S).</p>
</td></tr>
<tr><td><code id="scan_hh_+3A_limhomohaplo">limhomohaplo</code></td>
<td>
<p>if there are less than <code>limhomohaplo</code> homozygous chromosomes, the
calculation is stopped. This option is intended for unphased data and should be invoked only
if relatively low frequency variants are not filtered subsequently (see main vignette and Klassmann et al. 2020).</p>
</td></tr>
<tr><td><code id="scan_hh_+3A_limehh">limehh</code></td>
<td>
<p>limit at which EHH stops to be evaluated.</p>
</td></tr>
<tr><td><code id="scan_hh_+3A_limehhs">limehhs</code></td>
<td>
<p>limit at which EHHS stops to be evaluated.</p>
</td></tr>
<tr><td><code id="scan_hh_+3A_phased">phased</code></td>
<td>
<p>logical. If <code>TRUE</code> (default) chromosomes are expected to be phased. If <code>FALSE</code>, the haplotype data is assumed to
consist of pairwise ordered chromosomes belonging to diploid individuals.
EHH(S) is then estimated over individuals which are homozygous at the focal marker.</p>
</td></tr>
<tr><td><code id="scan_hh_+3A_polarized">polarized</code></td>
<td>
<p>logical. <code>TRUE</code> by default. If <code>FALSE</code>, use major and minor allele instead of ancestral and derived. If there
are more than two alleles then the minor allele refers to the second-most frequent allele.</p>
</td></tr>
<tr><td><code id="scan_hh_+3A_scalegap">scalegap</code></td>
<td>
<p>scale or cap gaps larger than the specified size to the specified size (default=<code>NA</code>, i.e. no scaling).</p>
</td></tr>
<tr><td><code id="scan_hh_+3A_maxgap">maxgap</code></td>
<td>
<p>maximum allowed gap in bp between two markers. If exceeded, further calculation of EHH(S) is stopped at the gap
(default=<code>NA</code>, i.e no limitation).</p>
</td></tr>
<tr><td><code id="scan_hh_+3A_discard_integration_at_border">discard_integration_at_border</code></td>
<td>
<p>logical. If <code>TRUE</code> (default) and computation reaches first or last marker or a gap larger than <code>maxgap</code>,
iHH, iES and inES are set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="scan_hh_+3A_lower_ehh_y_bound">lower_ehh_y_bound</code></td>
<td>
<p>lower y boundary of the area to be integrated over (default: <code>limehh</code>). Can be set
to zero for compatibility with the program hapbin.</p>
</td></tr>
<tr><td><code id="scan_hh_+3A_lower_ehhs_y_bound">lower_ehhs_y_bound</code></td>
<td>
<p>lower y boundary of the area to be integrated (default: <code>limehhs</code>). Can be set
to zero for compatibility with the program hapbin.</p>
</td></tr>
<tr><td><code id="scan_hh_+3A_interpolate">interpolate</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), integration
is performed over a continuous EHH(S) curve (values are interpolated linearly between consecutive markers),
otherwise the EHH(S) curve decreases stepwise at markers.</p>
</td></tr>
<tr><td><code id="scan_hh_+3A_threads">threads</code></td>
<td>
<p>number of threads to parallelize computation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Integrated EHH (iHH), integrated EHHS (iES) and integrated normalized EHHS (inES)
are computed for all markers of the chromosome (or linkage group). This function is several
times faster as a procedure calling in turn <code>calc_ehh</code> and <code>calc_ehhs</code>
for all markers. To perform a whole genome-scan this function needs
to be called for each chromosome and results concatenated.
</p>
<p>Note that setting <code>limehh</code> or <code>limehhs</code> to zero is likely to reduce power,
since even under neutrality a tiny fraction (&lt;&lt;0.05) of extremely long shared haplotypes is expected
which, if fully accounted for, would obfuscate the signal at selected sites.
</p>


<h3>Value</h3>

<p>The returned value is a dataframe with markers in rows and the following columns
</p>

<ol>
<li><p> chromosome name
</p>
</li>
<li><p> position in the chromosome
</p>
</li>
<li><p> sample frequency of the ancestral / major allele
</p>
</li>
<li><p> sample frequency of the second-most frequent remaining allele
</p>
</li>
<li><p> number of evaluated haplotypes at the focal marker for the ancestral / major allele
</p>
</li>
<li><p> number of evaluated haplotypes at the focal marker for the second-most frequent remaining allele
</p>
</li>
<li><p> iHH of the ancestral / major allele
</p>
</li>
<li><p> iHH of the second-most frequent remaining allele
</p>
</li>
<li><p> iES (used by Sabeti et al 2007)
</p>
</li>
<li><p> inES (used by Tang et al 2007)</p>
</li></ol>

<p>Note that in case of unphased data the evaluation is restricted to
haplotypes of homozygous individuals which reduces the power
to detect selection, particularly for iHS (for appropriate parameter setting
see the main vignette and Klassmann et al (2020)).
</p>


<h3>References</h3>

<p>Gautier, M. and Naves, M. (2011). Footprints of selection in the ancestral admixture of a New World Creole cattle breed. <em>Molecular Ecology</em>, <strong>20</strong>, 3128-3143.
</p>
<p>Klassmann, A. and Gautier, M. (2020). Detecting selection using Extended Haplotype
Homozygosity-based statistics on unphased or unpolarized data (preprint). 
https://doi.org/10.22541/au.160405572.29972398/v1
</p>
<p>Sabeti, P.C. et al. (2002). Detecting recent positive selection in the human genome from haplotype structure. <em>Nature</em>, <strong>419</strong>, 832-837.
</p>
<p>Sabeti, P.C. et al. (2007). Genome-wide detection and characterization of positive selection in human populations. <em>Nature</em>, <strong>449</strong>, 913-918.
</p>
<p>Tang, K. and Thornton, K.R. and Stoneking, M. (2007). A New Approach for Using Genome Scans to Detect Recent Positive Selection in the Human Genome. <em>Plos Biology</em>, <strong>7</strong>, e171.
</p>
<p>Voight, B.F. and Kudaravalli, S. and Wen, X. and Pritchard, J.K. (2006). A map of recent positive selection in the human genome. <em>Plos Biology</em>, <strong>4</strong>, e72.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data2haplohh">data2haplohh</a></code>, <code><a href="#topic+calc_ehh">calc_ehh</a></code>, <code><a href="#topic+calc_ehhs">calc_ehhs</a></code>
<code><a href="#topic+ihh2ihs">ihh2ihs</a></code>,<code><a href="#topic+ines2rsb">ines2rsb</a></code>, <code><a href="#topic+ies2xpehh">ies2xpehh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#example haplohh object (280 haplotypes, 1424 SNPs)
#see ?haplohh_cgu_bta12 for details
data(haplohh_cgu_bta12)
scan &lt;- scan_hh(haplohh_cgu_bta12)
</code></pre>

<hr>
<h2 id='scan_hh_full'>Compute iHH, iES and inES over a whole chromosome without cut-offs</h2><span id='topic+scan_hh_full'></span>

<h3>Description</h3>

<p>Compute integrated EHH (iHH), integrated EHHS (iES) and integrated normalized EHHS (inES) for all markers of a chromosome (or linkage group).
This function computes the statistics by a slightly different algorithm than <code><a href="#topic+scan_hh">scan_hh</a></code>: it sidesteps the calculation of EHH and EHHS values and their subsequent integration and
consequently no cut-offs relying on these values can be specified. Instead,
it computes the (full) lengths of pairwise shared haplotypes and averages them afterwords.
</p>
<p>This function is primarily intended for the study of general properties of these statistics using simulated data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_hh_full(
  haplohh,
  phased = TRUE,
  polarized = TRUE,
  maxgap = NA,
  max_extend = NA,
  discard_integration_at_border = TRUE,
  geometric.mean = FALSE,
  threads = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_hh_full_+3A_haplohh">haplohh</code></td>
<td>
<p>an object of class <code>haplohh</code> (see <code><a href="#topic+data2haplohh">data2haplohh</a></code>)</p>
</td></tr>
<tr><td><code id="scan_hh_full_+3A_phased">phased</code></td>
<td>
<p>logical. If <code>TRUE</code> (default) chromosomes are expected to be phased. If <code>FALSE</code>, the haplotype data is assumed to
consist of pairwise ordered chromosomes belonging to diploid individuals.
EHH(S) is then estimated over individuals which are homozygous at the focal marker.</p>
</td></tr>
<tr><td><code id="scan_hh_full_+3A_polarized">polarized</code></td>
<td>
<p>logical. <code>TRUE</code> by default. If <code>FALSE</code>, use major and minor allele instead of ancestral and derived. If there
are more than two alleles then the minor allele refers to the second-most frequent allele.</p>
</td></tr>
<tr><td><code id="scan_hh_full_+3A_maxgap">maxgap</code></td>
<td>
<p>maximum allowed gap in bp between two markers. If exceeded, further calculation of EHH(S) is stopped at the gap
(default=<code>NA</code>, i.e. no limitation).</p>
</td></tr>
<tr><td><code id="scan_hh_full_+3A_max_extend">max_extend</code></td>
<td>
<p>maximum distance in bp to extend shared haplotypes away from the focal marker.
(default <code>NA</code>, i.e. no limitation).</p>
</td></tr>
<tr><td><code id="scan_hh_full_+3A_discard_integration_at_border">discard_integration_at_border</code></td>
<td>
<p>logical. If <code>TRUE</code> (default) and computation of any of the statistics reaches first or last
marker or a gap larger than <code>maxgap</code>, iHH, iES and inES are set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="scan_hh_full_+3A_geometric.mean">geometric.mean</code></td>
<td>
<p>logical. If <code>FALSE</code> (default), the standard arithmetic mean is used to average
shared haplotype lengths. If <code>TRUE</code>
the geometric mean is used instead (IES values are undefined in this case). Note that usage of the geometric mean has not
yet been studied formally and should be considered experimental!</p>
</td></tr>
<tr><td><code id="scan_hh_full_+3A_threads">threads</code></td>
<td>
<p>number of threads to parallelize computation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Integrated EHH (iHH), integrated EHHS (iES) and integrated normalized EHHS (inES)
are computed for all markers of the chromosome (or linkage group). This function sidesteps
the computation of EHH and EHHS values and their stepwise integration. Instead, the length of all shared haplotypes
is computed and afterwords averaged.  In the absence of missing values the
statistics are identical to those calculated by <code><a href="#topic+scan_hh">scan_hh</a></code> with settings
<code>limehh = 0</code>, <code>limehhs = 0</code>, <code>lower_ehh_y_bound = 0</code> and <code>interpolate = FALSE</code>, yet this function is faster.
</p>
<p>Application of a cut-off is necessary for reducing the spurious signals
of selection caused by single shared haplotypes of extreme length. Hence, e.g. for human experimental data
it might be reasonable to set <code>max_extend</code> to 1 or 2 Mb.
</p>
<p><code><a href="#topic+scan_hh">scan_hh</a></code> computes the statistics iHH_A, ihh_D and iES/inES separately,
while this function calculates them simultaneously. Hence, 
if <code>discard_integration_at_border</code> is set to <code>TRUE</code> and the extension of shared haplotypes
reaches a border (i.e. chromosomal boundaries or a gap larger than <code>maxgap</code>), this function discards
all statistics.
</p>
<p>The handling of missing values is different, too: <code><a href="#topic+scan_hh">scan_hh</a></code> &quot;removes&quot; chromosomes with missing values from further calculations.
EHH and EHHS are then calculated for the remaining chromosomes which can accidentally yield an increase in EHH or EHHS.
This can not happen with <code>scan_hh_full()</code> which treats each missing value of a marker
as if it were a new allele - terminating any shared haplotype, but does changing the
set of considered chromosomes. Thus, missing values
cause a faster decay of EHH(S) with function <code>scan_hh_full()</code>.
</p>


<h3>Value</h3>

<p>The returned value is a dataframe with markers in rows and the following columns
</p>

<ol>
<li><p> chromosome name
</p>
</li>
<li><p> position in the chromosome
</p>
</li>
<li><p> sample frequency of the ancestral / major allele
</p>
</li>
<li><p> sample frequency of the second-most frequent remaining allele
</p>
</li>
<li><p> number of evaluated haplotypes at the focal marker for the ancestral / major allele
</p>
</li>
<li><p> number of evaluated haplotypes at the focal marker for the second-most frequent remaining allele
</p>
</li>
<li><p> iHH of the ancestral / major allele
</p>
</li>
<li><p> iHH of the second-most frequent remaining allele
</p>
</li>
<li><p> iES (used by Sabeti et al 2007)
</p>
</li>
<li><p> inES (used by Tang et al 2007)</p>
</li></ol>

<p>Note that in case of unphased data the evaluation is restricted to
haplotypes of homozygous individuals which reduces the power
to detect selection, particularly for iHS (for appropriate parameter setting
see the main vignette and Klassmann et al (2020)).
</p>


<h3>References</h3>

<p>Gautier, M. and Naves, M. (2011). Footprints of selection in the ancestral admixture of a New World Creole cattle breed. <em>Molecular Ecology</em>, <strong>20</strong>, 3128-3143.
</p>
<p>Klassmann, A. and Gautier, M. (2020). Detecting selection using Extended Haplotype
Homozygosity-based statistics on unphased or unpolarized data (preprint). 
https://doi.org/10.22541/au.160405572.29972398/v1
</p>
<p>Sabeti, P.C. et al. (2002). Detecting recent positive selection in the human genome from haplotype structure. <em>Nature</em>, <strong>419</strong>, 832-837.
</p>
<p>Sabeti, P.C. et al. (2007). Genome-wide detection and characterization of positive selection in human populations. <em>Nature</em>, <strong>449</strong>, 913-918.
</p>
<p>Tang, K. and Thornton, K.R. and Stoneking, M. (2007). A New Approach for Using Genome Scans to Detect Recent Positive Selection in the Human Genome. <em>Plos Biology</em>, <strong>7</strong>, e171.
</p>
<p>Voight, B.F. and Kudaravalli, S. and Wen, X. and Pritchard, J.K. (2006). A map of recent positive selection in the human genome. <em>Plos Biology</em>, <strong>4</strong>, e72.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data2haplohh">data2haplohh</a></code>, <code><a href="#topic+scan_hh">scan_hh</a></code>,
<code><a href="#topic+ihh2ihs">ihh2ihs</a></code>, <code><a href="#topic+ines2rsb">ines2rsb</a></code>, <code><a href="#topic+ies2xpehh">ies2xpehh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#example haplohh object (280 haplotypes, 1424 SNPs)
#see ?haplohh_cgu_bta12 for details
data(haplohh_cgu_bta12)
#using function scan_hh() with no cut-offs
scan &lt;- scan_hh(haplohh_cgu_bta12, discard_integration_at_border = FALSE,
limehh = 0, limehhs = 0, lower_ehh_y_bound = 0, interpolate = FALSE)
#using function scan_hh_full()
scan_full &lt;- scan_hh_full(haplohh_cgu_bta12, discard_integration_at_border = FALSE)
#both yield identical results within numerical precision
all.equal(scan, scan_full)
</code></pre>

<hr>
<h2 id='subset.haplohh'>Subsets object of <code><a href="#topic+haplohh-class">haplohh-class</a></code></h2><span id='topic+subset.haplohh'></span>

<h3>Description</h3>

<p>Subsets the data of an object of class <code><a href="#topic+haplohh-class">haplohh-class</a></code>,
meeting certain conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haplohh'
subset(
  x,
  select.hap = NULL,
  select.mrk = NULL,
  min_perc_geno.hap = NA,
  min_perc_geno.mrk = 100,
  min_maf = NA,
  max_alleles = NA,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.haplohh_+3A_x">x</code></td>
<td>
<p>object of class <code><a href="#topic+haplohh-class">haplohh-class</a></code> to be subset.</p>
</td></tr>
<tr><td><code id="subset.haplohh_+3A_select.hap">select.hap</code></td>
<td>
<p>expression, indicating haplotypes to select.</p>
</td></tr>
<tr><td><code id="subset.haplohh_+3A_select.mrk">select.mrk</code></td>
<td>
<p>expression, indicating markers to select.</p>
</td></tr>
<tr><td><code id="subset.haplohh_+3A_min_perc_geno.hap">min_perc_geno.hap</code></td>
<td>
<p>threshold on percentage of missing data for haplotypes
(haplotypes with less than <code>min_perc_geno.hap</code> percent of markers genotyped are discarded). Default is <code>NA</code>,
hence no constraint.</p>
</td></tr>
<tr><td><code id="subset.haplohh_+3A_min_perc_geno.mrk">min_perc_geno.mrk</code></td>
<td>
<p>threshold on percentage of missing data for markers (markers genotyped on less than
<code>min_perc_geno.mrk</code> percent of haplotypes are discarded). By default, <code>min_perc_geno.mrk=100</code>,
hence only fully genotyped markers are retained.
This value cannot be set to <code>NA</code> or zero.</p>
</td></tr>
<tr><td><code id="subset.haplohh_+3A_min_maf">min_maf</code></td>
<td>
<p>threshold on the Minor Allele Frequency. Markers having a MAF lower than or equal to minmaf are discarded.
In case of multi-allelic markers the second-most frequent allele is referred to as minor allele.
Setting this value to zero eliminates monomorphic sites. Default is <code>NA</code>,
hence no constraint.</p>
</td></tr>
<tr><td><code id="subset.haplohh_+3A_max_alleles">max_alleles</code></td>
<td>
<p>threshold for the maximum number of different alleles at a site. Default is <code>NA</code>,
hence no restriction. In order to retain only bi-allelic markers, set this parameter to 2.</p>
</td></tr>
<tr><td><code id="subset.haplohh_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), report verbose progress.</p>
</td></tr>
<tr><td><code id="subset.haplohh_+3A_...">...</code></td>
<td>
<p>further arguments are ignored.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+haplohh-class">haplohh-class</a></code>, <code><a href="#topic+data2haplohh">data2haplohh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#example haplohh object (280 haplotypes, 1424 SNPs)
#see ?haplohh_cgu_bta12 for details
data(haplohh_cgu_bta12)
#select subset of first 10 hyplotypes and first 5 markers
subset(haplohh_cgu_bta12, select.hap = 1:10, select.mrk = 1:5)
</code></pre>

<hr>
<h2 id='update_haplohh'>Update object of class haplohh</h2><span id='topic+update_haplohh'></span>

<h3>Description</h3>

<p>Update object of class <code><a href="#topic+haplohh-class">haplohh-class</a></code>
constructed by rehh versions up to version 2.0.4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_haplohh(haplohh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_haplohh_+3A_haplohh">haplohh</code></td>
<td>
<p>an object of an old version of <code><a href="#topic+haplohh-class">haplohh-class</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to update <code>haplohh</code> objects
that have been built by rehh versions up to 2.0.4. These objects cannot
be used in functions of the current version. 
The following changes have been made to the class definition:
The internal representation of the haplotype matrix followed the encoding
</p>

<ul>
<li><p> 0 missing value
</p>
</li>
<li><p> 1 ancestral allele
</p>
</li>
<li><p> 2 derived allele</p>
</li></ul>

<p>and has been replaced by a vcf-like encoding:
</p>

<ul>
<li> <p><code>NA</code> missing value
</p>
</li>
<li><p> 0 ancestral allele
</p>
</li>
<li><p> 1 derived allele.</p>
</li></ul>

<p>Furthermore the slots <code>nsnp</code>, <code>snp.name</code> and <code>nhap</code> have been removed
and slot <code>position</code> renamed to <code>positions</code>.
An update of an old <code>haplohh</code> object is done as follows:
</p>
<p><code>new_haplohh = update_haplohh(old_haplohh)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplohh-class">haplohh-class</a></code>, <code><a href="#topic+data2haplohh">data2haplohh</a></code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
