<!DOCTYPE html><html lang="en-US"><head><title>Help for package habCluster</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {habCluster}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#habCluster-package'><p>habCluster: Detecting Spatial Clustering Based on Connection Cost Between Grids</p></a></li>
<li><a href='#cluster'><p>Clustering cells from a raster by Community Detection Algorithm according to the connections between them and return a cluster map</p></a></li>
<li><a href='#raster2Graph'><p>Create a graph from an raster according the connection between cells</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Detecting Spatial Clustering Based on Connection Cost Between
Grids</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-24</td>
</tr>
<tr>
<td>Author:</td>
<td>Qiang Dai</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Qiang Dai &lt;daiqiang@cib.ac.cn&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Based on landscape connectivity, spatial boundaries were
        identified using community detection algorithm at grid level. Methods 
        using raster as input and the value of each cell of the raster is the 
        "smoothness" to indicate how easy the cell connecting with neighbor cells. 
        Details about the 'habCluster' package methods can be found in Zhang et al.
        &lt;bioRxiv:2022.05.06.490926&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), igraph (&ge; 1.3.0), stars (&ge; 0.5-0), sf (&ge;
1.0.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, raster</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.1.0), spelling</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-24 11:23:16 UTC; qiang</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-25 15:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='habCluster-package'>habCluster: Detecting Spatial Clustering Based on Connection Cost Between Grids</h2><span id='topic+habCluster'></span><span id='topic+habCluster-package'></span>

<h3>Description</h3>

<p>Based on landscape connectivity, spatial boundaries were identified using community detection algorithm at grid level. Methods using raster as input and the value of each cell of the raster is the &quot;smoothness&quot; to indicate how easy the cell connecting with neighbor cells. Details about the 'habCluster' package methods can be found in Zhang et al. &lt;bioRxiv:2022.05.06.490926&gt;.
</p>
<p>Spatial explicitly identify the structure of landscape base on cost (weighted) connection at grid scale, using community detection algorithm from graph theory.
</p>


<h3>Details</h3>

<p>Based on landscape connectivity, spatial boundaries were identified using community detection algorithm at grid level. Methods using raster as input and the value of each cell of the raster is the ‘smoothness’ to indicate how easy the cell connecting with neighbor cells. The method can be use to find habitat clusters for wildlife from a map of habitat suitability index, and thus can be used to detect the spatial boundaries among populations or other intraspecific units.
</p>
<p>Key content of the 'habCluster' package include:<br />
</p>
<p><b>Spatial Cluster Detection</b>
</p>
<p><code><a href="#topic+cluster">cluster</a></code> Clustering cells from a raster by Community Detection Algorithm according to the connections between them and return a cluster map.
</p>


<h3>Dependencies</h3>

<p>The 'habCluster' package relies heavily upon <code><a href="raster.html#topic+raster">raster</a></code>, <code><a href="Rcpp.html#topic+Rcpp">Rcpp</a></code>, and <code><a href="igraph.html#topic+igraph">igraph</a></code>.
</p>


<h3>Author(s)</h3>

<p>Qiang Dai<br /> <em>Chengdu Institute of Biology, Chinese Academy of Sciences.</em><br />
</p>
<p>Maintainer: Qiang Dai <a href="mailto:daiqiang@cib.ac.cn">daiqiang@cib.ac.cn</a>
</p>

<hr>
<h2 id='cluster'>Clustering cells from a raster by Community Detection Algorithm according to the connections between them and return a cluster map</h2><span id='topic+cluster'></span>

<h3>Description</h3>

<p>This function use Community Detection Algorithm to find structure of raster and return a polygon representing the boundary of the clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster(
  r = NULL,
  method = igraph::cluster_fast_greedy,
  cellsize = NULL,
  relative.distance = TRUE,
  silent = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster_+3A_r">r</code></td>
<td>
<p>An object of stars or RasterLayer. The value of each cell of the raster is the ‘smoothness’ to indicate how easy the cell connecting with neighbor cells.</p>
</td></tr>
<tr><td><code id="cluster_+3A_method">method</code></td>
<td>
<p>method from package igraph used to finding community structure. (see details below).</p>
</td></tr>
<tr><td><code id="cluster_+3A_cellsize">cellsize</code></td>
<td>
<p>Numeric. Re-sample the input raster to given resolution and use the resampled raster to find community structure. Set this to NULL if using the original resolution of of the input raster,given the parameter r is an object of raster.</p>
</td></tr>
<tr><td><code id="cluster_+3A_relative.distance">relative.distance</code></td>
<td>
<p>Boolean. If FALSE, absolute distance between cells is used to compute the edge weight; otherwise, relative distance between cells is used . Default is TRUE.</p>
</td></tr>
<tr><td><code id="cluster_+3A_silent">silent</code></td>
<td>
<p>Boolean. A logical indicating if some “progress report” should be given. Default is TRUE.</p>
</td></tr>
<tr><td><code id="cluster_+3A_...">...</code></td>
<td>
<p>Optional arguments to method. For example, can set resolution_parameter for cluster_leiden, or resolution for cluster_louvain.(see details below).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Choice of the method used to finding community structure(see Mukerjee, 2021). The default method is cluster_fast_greedy, but could also be methods like cluster_leiden, cluster_walktrap, or cluster_louvain. If cluster_leiden is chosen, then we can use resolution_parameter to control the size of clusters. Higher resolution_parameter lead to more smaller clusters, while lower resolution_parameter lead to fewer larger clusters. The parameter of resolution for cluster_louvain is similar. More details about those methods can be found in the document for package &quot;igraph&quot;.
</p>


<h3>Value</h3>

<p>A polygon of sf object for boundaries of habitat clusters,
and an object of communities defined in package igraph.
</p>


<h3>References</h3>

<p>Mukerjee, S. (2021). A systematic comparison of community detection algorithms for measuring selective exposure in co-exposure networks. Scientific reports 11, 15218. https://doi.org/10.1038/s41598-021-94724-1<br />
Traag, V. A., Waltman, L., &amp; van Eck, N. J. (2019). From Louvain to Leiden: guaranteeing well-connected communities. Scientific reports, 9(1), 5233. doi: 10.1038/s41598-019-41695-z<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
library(stars)

# read in habitat suitability data of wolf in Europe
hsi.file = system.file("extdata","wolf3_int.tif",package="habCluster")
wolf = read_stars(hsi.file)

# rescale raster value to 0 - 1
wolf = wolf / 100

# find habitat cluster using Fast Greedy Algorithm.
# Raster will be resampled to 40 km, to cluser at the scale of 40 km and reduce calculation amount.
clst = cluster(wolf, method = cluster_fast_greedy, cellsize = 40000)

# plot the results
image(wolf,col=terrain.colors(100,rev = TRUE),asp = 1)
boundary = clst$boundary
plot( boundary$geometry, add=TRUE, asp=1, border = "lightseagreen")

# discard patches smaller than 1600 sqkm
boundary$area = as.numeric(st_area(boundary))
boundary = boundary[boundary$area &gt; 40000*40000,]
image(wolf,col=terrain.colors(100,rev = TRUE),asp = 1)
plot( boundary$geometry, add=TRUE, asp=1, border = "lightseagreen")

# can also use RasterLayer object#
library(raster)
wolf = read_stars(hsi.file)
wolf = wolf / 100
clst = cluster(wolf, method = cluster_leiden, cellsize = 40000, resolution_parameter = 0.0002)
</code></pre>

<hr>
<h2 id='raster2Graph'>Create a graph from an raster according the connection between cells</h2><span id='topic+raster2Graph'></span>

<h3>Description</h3>

<p>Create a graph from an raster according the connection between cells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raster2Graph(r, cellsize = NULL, relative.distance = TRUE, silent = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raster2Graph_+3A_r">r</code></td>
<td>
<p>An object of stars or RasterLayer. The value of each cell of the raster is the ‘smoothness’ to indicate how easy the cell connecting with neighbor cells.</p>
</td></tr>
<tr><td><code id="raster2Graph_+3A_cellsize">cellsize</code></td>
<td>
<p>Numeric. Re-sample the input raster to given resolution and use the re-sampled raster to build graph. Set this to NULL if using the original resolution of of the input raster.</p>
</td></tr>
<tr><td><code id="raster2Graph_+3A_relative.distance">relative.distance</code></td>
<td>
<p>Boolean. If fasle, absolute distance between cells is used to compute the edge weight; otherwise, relative distance between cells is used. Default is true</p>
</td></tr>
<tr><td><code id="raster2Graph_+3A_silent">silent</code></td>
<td>
<p>Boolean. A logical indicating if some “progress report” should be given. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with an graph and the re-sampled raster (a object of stars). The graph is igraph object, with cells as node and connections as weight.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read in habitat suitability data of wolf in Europe
library(stars)
hsi.file = system.file("extdata","wolf3_int.tif",package="habCluster")
wolf = read_stars(hsi.file)
# build graph from raster
g = raster2Graph(wolf, 40000)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
