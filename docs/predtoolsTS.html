<!DOCTYPE html><html><head><title>Help for package predtoolsTS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {predtoolsTS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#modl'><p>Building predictive models</p></a></li>
<li><a href='#modl.arima'><p>Automatic ARIMA model</p></a></li>
<li><a href='#modl.dataMining'><p>Train the data</p></a></li>
<li><a href='#modl.trControl'><p>Control the splitting to train the data</p></a></li>
<li><a href='#modl.tsToDataFrame'><p>Ts to data frame transformation</p></a></li>
<li><a href='#plot.pred'><p>Generic function</p></a></li>
<li><a href='#plot.prep'><p>Generic function</p></a></li>
<li><a href='#postp'><p>Post-processing of pre-processed data</p></a></li>
<li><a href='#postp.deseason.differencing'><p>Undo deseason(differencing)</p></a></li>
<li><a href='#postp.detrend.differencing'><p>Undo detrend(differencing)</p></a></li>
<li><a href='#postp.detrend.sfsm'><p>Undo detrend(substracting full-means method)</p></a></li>
<li><a href='#postp.homogenize.boxcox'><p>Undo Box-Cox transformation</p></a></li>
<li><a href='#postp.homogenize.log'><p>Undo logarithmic transformation</p></a></li>
<li><a href='#pred'><p>Predictions</p></a></li>
<li><a href='#pred.arima'><p>Predicts for ARIMA</p></a></li>
<li><a href='#pred.compareModels'><p>Compare different predictions</p></a></li>
<li><a href='#pred.dataMining'><p>Predicts for data mining methods</p></a></li>
<li><a href='#prep'><p>Automatic pre-preprocessing</p></a></li>
<li><a href='#prep.check.acf'><p>Autocorrelation function</p></a></li>
<li><a href='#prep.check.adf'><p>Augmented Dickey-Fuller test</p></a></li>
<li><a href='#prep.deseason.differencing'><p>Deseason with differencing method</p></a></li>
<li><a href='#prep.detrend.differencing'><p>Detrend with differencing method</p></a></li>
<li><a href='#prep.detrend.sfsm'><p>Detrend with &quot;substracting full-season means&quot; method</p></a></li>
<li><a href='#prep.homogenize.boxcox'><p>Box-Cox transformation</p></a></li>
<li><a href='#prep.homogenize.log'><p>Logarithmic transformation</p></a></li>
<li><a href='#print.modl'><p>Generic function</p></a></li>
<li><a href='#print.pred'><p>Generic function</p></a></li>
<li><a href='#print.prep'><p>Generic function</p></a></li>
<li><a href='#summary.modl'><p>Generic function</p></a></li>
<li><a href='#summary.pred'><p>Generic function</p></a></li>
<li><a href='#summary.prep'><p>Generic function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Time Series Prediction Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-04-26</td>
</tr>
<tr>
<td>Author:</td>
<td>Alberto Vico Moreno [aut, cre],
  Antonio Jesus Rivera Rivas [aut, ths],
  Maria Dolores Perez Godoy [aut, ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alberto Vico Moreno &lt;avm00016@red.ujaen.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Makes the time series prediction easier by automatizing this process
  using four main functions: prep(), modl(), pred() and postp(). Features different
  preprocessing methods to homogenize variance and to remove trend and seasonality.
  Also has the potential to bring together different predictive models to make comparatives.
  Features ARIMA and Data Mining Regression models (using caret).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/avm00016/predtoolsTS">https://github.com/avm00016/predtoolsTS</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>caret, forecast, graphics, methods, Metrics, stats, TSPred,
tseries, utils</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-04-29 13:45:20 UTC; Alberto Vico Moreno</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-04-29 13:54:50 UTC</td>
</tr>
</table>
<hr>
<h2 id='modl'>Building predictive models</h2><span id='topic+modl'></span>

<h3>Description</h3>

<p>This function give us the tools to build predictive models for time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modl(tserie, method = "arima", algorithm = NULL, formula = NULL,
  initialWindow = NULL, horizon = NULL, fixedWindow = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modl_+3A_tserie">tserie</code></td>
<td>
<p>A ts or prep object.</p>
</td></tr>
<tr><td><code id="modl_+3A_method">method</code></td>
<td>
<p>A string. Current methods available are &quot;arima&quot; and &quot;dataMining&quot;. Method &quot;arima&quot; is set as default.</p>
</td></tr>
<tr><td><code id="modl_+3A_algorithm">algorithm</code></td>
<td>
<p>A string. In case <code>method</code> is &quot;dataMining&quot;, pick the algorithm you want to use. There is a complete list of available algorithms here (only regression type allowed): <a href="http://topepo.github.io/caret/train-models-by-tag.html">http://topepo.github.io/caret/train-models-by-tag.html</a>.</p>
</td></tr>
<tr><td><code id="modl_+3A_formula">formula</code></td>
<td>
<p>An integer vector. Contains the indexes from the time series wich will indicate how to extract the features. The last value will be the class index. Default value: c(1:16)</p>
</td></tr>
<tr><td><code id="modl_+3A_initialwindow">initialWindow</code></td>
<td>
<p>An integer. The initial number of consecutive values in each training set sample. Default value: 30.</p>
</td></tr>
<tr><td><code id="modl_+3A_horizon">horizon</code></td>
<td>
<p>An integer. The number of consecutive values in test set sample. Default value: 15.</p>
</td></tr>
<tr><td><code id="modl_+3A_fixedwindow">fixedWindow</code></td>
<td>
<p>A logical: if FALSE, the training set always start at the first sample and the training set size will vary over data splits. Default value: TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns an object <code>modl</code> which stores all the information related to
the final chosen model (errors, parameters, model).
</p>
<p>Currently this function covers two different methods: the widely know ARIMA
and the &quot;not so used for prediction&quot; data mining. For the data mining we make
use of the <code>caret</code> package.
</p>
<p>The <code>caret</code> package offers plenty of data mining algorithms.
For the data splitting here we use a rolling forecasting origin technique, wich
works better on time series.
</p>


<h3>Value</h3>

<p>A list is returned of class <code>modl</code> containing:
</p>
<table>
<tr><td><code>tserie</code></td>
<td>
<p>Original time serie.</p>
</td></tr>
<tr><td><code>tserieDF</code></td>
<td>
<p>Time serie converted to data frame.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Method used to build the model.</p>
</td></tr>
<tr><td><code>algorithm</code></td>
<td>
<p>If method is data mining, indicates wich algorithm was used.</p>
</td></tr>
<tr><td><code>horizon</code></td>
<td>
<p>Horizon for the splitting.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>Model result from <code>caret</code>. It is a list, result of the <code>caret::train</code> function.</p>
</td></tr>
<tr><td><code>errors</code></td>
<td>
<p>Contains three different metrics to evaluate the model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alberto Vico Moreno
</p>


<h3>References</h3>

<p><a href="http://topepo.github.io/caret/index.html">http://topepo.github.io/caret/index.html</a>
</p>


<h3>See Also</h3>


<p><code><a href="#topic+prep">prep</a></code>
<code><a href="#topic+modl.arima">modl.arima</a></code>,
<code><a href="#topic+modl.tsToDataFrame">modl.tsToDataFrame</a></code>,
<code><a href="#topic+modl.trControl">modl.trControl</a></code>,
<code><a href="#topic+modl.dataMining">modl.dataMining</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- prep(AirPassengers)
modl(p,method='arima')
modl(p,method='dataMining',algorithm='rpart')
</code></pre>

<hr>
<h2 id='modl.arima'>Automatic ARIMA model</h2><span id='topic+modl.arima'></span>

<h3>Description</h3>

<p>Assuming &quot;tserie&quot; is stationary, returns the best arima model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modl.arima(tserie)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modl.arima_+3A_tserie">tserie</code></td>
<td>
<p>A ts object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ARIMA model.
</p>


<h3>Author(s)</h3>

<p>Alberto Vico Moreno
</p>


<h3>Examples</h3>

<pre><code class='language-R'>modl.arima(AirPassengers)
</code></pre>

<hr>
<h2 id='modl.dataMining'>Train the data</h2><span id='topic+modl.dataMining'></span>

<h3>Description</h3>

<p>Train the time serie(as data frame) to build the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modl.dataMining(form, tserieDF, algorithm, timeControl, metric = "RMSE",
  maximize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modl.dataMining_+3A_form">form</code></td>
<td>
<p>A formula of the form y ~ x1 + x2 + ...</p>
</td></tr>
<tr><td><code id="modl.dataMining_+3A_tseriedf">tserieDF</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="modl.dataMining_+3A_algorithm">algorithm</code></td>
<td>
<p>A string. Algorithm to perform the training. Full list at <a href="http://topepo.github.io/caret/train-models-by-tag.html">http://topepo.github.io/caret/train-models-by-tag.html</a>. Only regression types allowed.</p>
</td></tr>
<tr><td><code id="modl.dataMining_+3A_timecontrol">timeControl</code></td>
<td>
<p>trainControl object.</p>
</td></tr>
<tr><td><code id="modl.dataMining_+3A_metric">metric</code></td>
<td>
<p>A string. Specifies what summary metric will be used to select the optimal model. Possible values in <code>caret</code> are &quot;RMSE&quot; and &quot;Rsquared&quot;. &quot;RMSE&quot; set as default. If you used a custom summaryFunction(see ?trainControl) your metrics will prevail over default.</p>
</td></tr>
<tr><td><code id="modl.dataMining_+3A_maximize">maximize</code></td>
<td>
<p>A logical. Should the metric be maximized or minimized? Default is FALSE, since that is what makes sense for time series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>train object
</p>


<h3>Author(s)</h3>

<p>Alberto Vico Moreno
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
modl.dataMining(form=Class ~ .,
 tserieDF=modl.tsToDataFrame(AirPassengers,formula=c(1:20)),
 algorithm='rpart',
 timeControl=modl.trControl(initialWindow=30,horizon=15,fixedWindow=TRUE))

</code></pre>

<hr>
<h2 id='modl.trControl'>Control the splitting to train the data</h2><span id='topic+modl.trControl'></span>

<h3>Description</h3>

<p>Creates the needed <code>caret::trainControl</code> object to control the training
splitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modl.trControl(initialWindow, horizon, fixedWindow, givenSummary = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modl.trControl_+3A_initialwindow">initialWindow</code></td>
<td>
<p>An integer. The initial number of consecutive values in each training set sample. Default value: 30.</p>
</td></tr>
<tr><td><code id="modl.trControl_+3A_horizon">horizon</code></td>
<td>
<p>An integer. The number of consecutive values in test set sample. Default value: 15.</p>
</td></tr>
<tr><td><code id="modl.trControl_+3A_fixedwindow">fixedWindow</code></td>
<td>
<p>A logical: if FALSE, the training set always start at the first sample and the training set size will vary over data splits. Default value: TRUE.</p>
</td></tr>
<tr><td><code id="modl.trControl_+3A_givensummary">givenSummary</code></td>
<td>
<p>A logical. Indicates if it should be used the customized summaryFunction(?trainControl for more info) modl.sumFunction or not. Default is FALSE; this will use default <code>caret</code> metrics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We always split using method &quot;timeslice&quot;, wich is the better for time series.
More information on how this works on <a href="http://topepo.github.io/caret/data-splitting.html#data-splitting-for-time-series">http://topepo.github.io/caret/data-splitting.html#data-splitting-for-time-series</a>.
</p>


<h3>Value</h3>

<p>trainControl object
</p>


<h3>Author(s)</h3>

<p>Alberto Vico Moreno
</p>


<h3>Examples</h3>

<pre><code class='language-R'>modl.trControl(initialWindow=30,horizon=15,fixedWindow=TRUE,givenSummary=TRUE)
</code></pre>

<hr>
<h2 id='modl.tsToDataFrame'>Ts to data frame transformation</h2><span id='topic+modl.tsToDataFrame'></span>

<h3>Description</h3>

<p>Transform a ts object into a data frame using the given formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modl.tsToDataFrame(tserie, formula = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modl.tsToDataFrame_+3A_tserie">tserie</code></td>
<td>
<p>A ts object.</p>
</td></tr>
<tr><td><code id="modl.tsToDataFrame_+3A_formula">formula</code></td>
<td>
<p>An integer vector. Contains the indexes from the <code>tserie</code> wich will indicate how to extract the features. The last value will be the class index. Default value: c(1:16). Has to be length 6 minimum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the time serie as data frame
</p>


<h3>Author(s)</h3>

<p>Alberto Vico Moreno
</p>


<h3>Examples</h3>

<pre><code class='language-R'>modl.tsToDataFrame(AirPassengers,formula=c(1,3,4,5,6,7))
modl.tsToDataFrame(AirPassengers,formula=c(1:20))
</code></pre>

<hr>
<h2 id='plot.pred'>Generic function</h2><span id='topic+plot.pred'></span>

<h3>Description</h3>

<p>Plots object prep
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pred'
plot(x, ylab = "Values", main = "Predictions", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pred_+3A_x">x</code></td>
<td>
<p><code>pred</code> object</p>
</td></tr>
<tr><td><code id="plot.pred_+3A_ylab">ylab</code></td>
<td>
<p>ylab</p>
</td></tr>
<tr><td><code id="plot.pred_+3A_main">main</code></td>
<td>
<p>main</p>
</td></tr>
<tr><td><code id="plot.pred_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plot(pred(modl(prep(AirPassengers))))
</code></pre>

<hr>
<h2 id='plot.prep'>Generic function</h2><span id='topic+plot.prep'></span>

<h3>Description</h3>

<p>Plots object prep
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prep'
plot(x, ylab = "Preprocessed time serie", xlab = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.prep_+3A_x">x</code></td>
<td>
<p><code>prep</code> object</p>
</td></tr>
<tr><td><code id="plot.prep_+3A_ylab">ylab</code></td>
<td>
<p>ylab</p>
</td></tr>
<tr><td><code id="plot.prep_+3A_xlab">xlab</code></td>
<td>
<p>xlab</p>
</td></tr>
<tr><td><code id="plot.prep_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plot(prep(AirPassengers),ylab="Stationary AisPassengers")
</code></pre>

<hr>
<h2 id='postp'>Post-processing of pre-processed data</h2><span id='topic+postp'></span>

<h3>Description</h3>

<p>Using the <code>prep</code> data we undo the changes on a <code>pred</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postp(prd, pre)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postp_+3A_prd">prd</code></td>
<td>
<p>A <code>pred</code> object.</p>
</td></tr>
<tr><td><code id="postp_+3A_pre">pre</code></td>
<td>
<p>A <code>prep</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>pred</code> object with reverted transformations.
</p>


<h3>Author(s)</h3>

<p>Alberto Vico Moreno
</p>


<h3>See Also</h3>


<p><code><a href="#topic+pred">pred</a></code>
<code><a href="#topic+prep">prep</a></code>,
<code><a href="#topic+postp.homogenize.log">postp.homogenize.log</a></code>,
<code><a href="#topic+postp.homogenize.boxcox">postp.homogenize.boxcox</a></code>,
<code><a href="#topic+postp.detrend.differencing">postp.detrend.differencing</a></code>,
<code><a href="#topic+postp.detrend.sfsm">postp.detrend.sfsm</a></code>,
<code><a href="#topic+postp.deseason.differencing">postp.deseason.differencing</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>preprocess &lt;- prep(AirPassengers)
prediction &lt;- pred(modl(preprocess),n.ahead=30)
postp.prediction &lt;- postp(prediction,preprocess)
</code></pre>

<hr>
<h2 id='postp.deseason.differencing'>Undo deseason(differencing)</h2><span id='topic+postp.deseason.differencing'></span>

<h3>Description</h3>

<p>Uses inverse seasonal differences to reverse the changes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postp.deseason.differencing(tserie, nsd, firstseasons, frequency)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postp.deseason.differencing_+3A_tserie">tserie</code></td>
<td>
<p>A <code>ts</code> object.</p>
</td></tr>
<tr><td><code id="postp.deseason.differencing_+3A_nsd">nsd</code></td>
<td>
<p>Number of seasonal differences.</p>
</td></tr>
<tr><td><code id="postp.deseason.differencing_+3A_firstseasons">firstseasons</code></td>
<td>
<p>Values lost on the original differences</p>
</td></tr>
<tr><td><code id="postp.deseason.differencing_+3A_frequency">frequency</code></td>
<td>
<p>Frequency of the original time serie</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ts</code> object.
</p>


<h3>Author(s)</h3>

<p>Alberto Vico Moreno
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- prep.deseason.differencing(AirPassengers)
postp.deseason.differencing(p$tserie,p$nsd,p$firstseasons,frequency(AirPassengers))
</code></pre>

<hr>
<h2 id='postp.detrend.differencing'>Undo detrend(differencing)</h2><span id='topic+postp.detrend.differencing'></span>

<h3>Description</h3>

<p>Uses inverse differences to revert the changes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postp.detrend.differencing(tserie, nd, firstvalues)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postp.detrend.differencing_+3A_tserie">tserie</code></td>
<td>
<p>A <code>ts</code> object.</p>
</td></tr>
<tr><td><code id="postp.detrend.differencing_+3A_nd">nd</code></td>
<td>
<p>Number of differences.</p>
</td></tr>
<tr><td><code id="postp.detrend.differencing_+3A_firstvalues">firstvalues</code></td>
<td>
<p>Values lost on the original differences</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ts</code> object.
</p>


<h3>Author(s)</h3>

<p>Alberto Vico Moreno
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- prep.detrend.differencing(AirPassengers)
postp.detrend.differencing(p$tserie,p$nd,p$firstvalues)
</code></pre>

<hr>
<h2 id='postp.detrend.sfsm'>Undo detrend(substracting full-means method)</h2><span id='topic+postp.detrend.sfsm'></span>

<h3>Description</h3>

<p>Undo detrend(substracting full-means method)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postp.detrend.sfsm(tserie, means, start, frequency)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postp.detrend.sfsm_+3A_tserie">tserie</code></td>
<td>
<p>A <code>ts</code> object.</p>
</td></tr>
<tr><td><code id="postp.detrend.sfsm_+3A_means">means</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="postp.detrend.sfsm_+3A_start">start</code></td>
<td>
<p>Start of original time serie</p>
</td></tr>
<tr><td><code id="postp.detrend.sfsm_+3A_frequency">frequency</code></td>
<td>
<p>Frequency of the original time serie</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ts</code> object.
</p>


<h3>Author(s)</h3>

<p>Alberto Vico Moreno
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- prep.detrend.sfsm(AirPassengers)
postp.detrend.sfsm(p$tserie,p$means,start(AirPassengers),frequency(AirPassengers))
</code></pre>

<hr>
<h2 id='postp.homogenize.boxcox'>Undo Box-Cox transformation</h2><span id='topic+postp.homogenize.boxcox'></span>

<h3>Description</h3>

<p>Undo Box-Cox transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postp.homogenize.boxcox(tserie, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postp.homogenize.boxcox_+3A_tserie">tserie</code></td>
<td>
<p>A <code>ts</code> object.</p>
</td></tr>
<tr><td><code id="postp.homogenize.boxcox_+3A_lambda">lambda</code></td>
<td>
<p>A numeric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ts</code> object.
</p>


<h3>Author(s)</h3>

<p>Alberto Vico Moreno
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- prep.homogenize.boxcox(AirPassengers)
postp.homogenize.boxcox(p$tserie,p$lambda)
</code></pre>

<hr>
<h2 id='postp.homogenize.log'>Undo logarithmic transformation</h2><span id='topic+postp.homogenize.log'></span>

<h3>Description</h3>

<p>Uses exponent to reverse the logarithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postp.homogenize.log(tserie)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postp.homogenize.log_+3A_tserie">tserie</code></td>
<td>
<p>A <code>ts</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ts</code> object.
</p>


<h3>Author(s)</h3>

<p>Alberto Vico Moreno
</p>


<h3>Examples</h3>

<pre><code class='language-R'>postp.homogenize.log(prep.homogenize.log(AirPassengers))
</code></pre>

<hr>
<h2 id='pred'>Predictions</h2><span id='topic+pred'></span>

<h3>Description</h3>

<p>Performs predictions over a trained model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred(model = NULL, n.ahead = 20, tserie = NULL, predictions = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred_+3A_model">model</code></td>
<td>
<p>A <code>modl</code> object. Contains the trained model we want to predict with.</p>
</td></tr>
<tr><td><code id="pred_+3A_n.ahead">n.ahead</code></td>
<td>
<p>Number of values to predict ahead of the end of the original time serie. Default value is 20. Must ve lower than 100.</p>
</td></tr>
<tr><td><code id="pred_+3A_tserie">tserie</code></td>
<td>
<p>A <code>ts</code> object.</p>
</td></tr>
<tr><td><code id="pred_+3A_predictions">predictions</code></td>
<td>
<p>A <code>ts</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Predicts future values over a &quot;modl&quot; object which can be ARIMA or data mining, and returns
the predictions. Data mining predictions start right after the last value
contained in the training data, so they overlap with the end of the original.
</p>
<p>The object contains only two time series: the original one
and the predictions. You can just set these series aswell.
</p>


<h3>Value</h3>

<p>A list is returned of class <code>pred</code> containing:
</p>
<table>
<tr><td><code>tserie</code></td>
<td>
<p>Original time serie.</p>
</td></tr>
<tr><td><code>predictions</code></td>
<td>
<p>Time serie with the predictions.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alberto Vico Moreno
</p>


<h3>See Also</h3>


<p><code><a href="#topic+modl">modl</a></code>
<code><a href="#topic+pred.arima">pred.arima</a></code>,
<code><a href="#topic+pred.dataMining">pred.dataMining</a></code>,
<code><a href="#topic+pred.compareModels">pred.compareModels</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>prediction &lt;- pred(model=modl(prep(AirPassengers)),n.ahead=25)
pred(tserie=prediction$tserie, predictions=prediction$predictions)
</code></pre>

<hr>
<h2 id='pred.arima'>Predicts for ARIMA</h2><span id='topic+pred.arima'></span>

<h3>Description</h3>

<p>Performs predictions over an ARIMA model using the <code>stats::predict</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.arima(model, n.ahead)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.arima_+3A_model">model</code></td>
<td>
<p>An ARIMA model.</p>
</td></tr>
<tr><td><code id="pred.arima_+3A_n.ahead">n.ahead</code></td>
<td>
<p>Number of values to predict.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ts</code> object containing the predictions.
</p>


<h3>Author(s)</h3>

<p>Alberto Vico Moreno
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pred.arima(forecast::auto.arima(prep(AirPassengers)$tserie),n.ahead=30)
</code></pre>

<hr>
<h2 id='pred.compareModels'>Compare different predictions</h2><span id='topic+pred.compareModels'></span>

<h3>Description</h3>

<p>Plots the original time serie along with 2-5 predictive models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.compareModels(originalTS, p_1, p_2, p_3 = NULL, p_4 = NULL,
  p_5 = NULL, legendNames = NULL, colors = NULL, legend = TRUE,
  legendPosition = NULL, yAxis = "Values", title = "Predictions")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.compareModels_+3A_originalts">originalTS</code></td>
<td>
<p>A <code>ts</code> object</p>
</td></tr>
<tr><td><code id="pred.compareModels_+3A_p_1">p_1</code></td>
<td>
<p>A <code>ts</code> object</p>
</td></tr>
<tr><td><code id="pred.compareModels_+3A_p_2">p_2</code></td>
<td>
<p>A <code>ts</code> object</p>
</td></tr>
<tr><td><code id="pred.compareModels_+3A_p_3">p_3</code></td>
<td>
<p>A <code>ts</code> object. Default is NULL.</p>
</td></tr>
<tr><td><code id="pred.compareModels_+3A_p_4">p_4</code></td>
<td>
<p>A <code>ts</code> object. Default is NULL.</p>
</td></tr>
<tr><td><code id="pred.compareModels_+3A_p_5">p_5</code></td>
<td>
<p>A <code>ts</code> object. Default is NULL.</p>
</td></tr>
<tr><td><code id="pred.compareModels_+3A_legendnames">legendNames</code></td>
<td>
<p>String vector with the names for the legend. Has to be same length as number of time series we are plotting(including the original one). Default is NULL.</p>
</td></tr>
<tr><td><code id="pred.compareModels_+3A_colors">colors</code></td>
<td>
<p>Vector with the colors. Has to be same length as number of time series we are plotting(including the original one). Default is NULL.</p>
</td></tr>
<tr><td><code id="pred.compareModels_+3A_legend">legend</code></td>
<td>
<p>A logical. Do we want a legend? Default is TRUE.</p>
</td></tr>
<tr><td><code id="pred.compareModels_+3A_legendposition">legendPosition</code></td>
<td>
<p>A string with the position of the legend (bottomright, topright, ...). Default is NULL.</p>
</td></tr>
<tr><td><code id="pred.compareModels_+3A_yaxis">yAxis</code></td>
<td>
<p>A string. Name for the y axis. &quot;Values&quot; as default.</p>
</td></tr>
<tr><td><code id="pred.compareModels_+3A_title">title</code></td>
<td>
<p>A string. Title for the plot. Default is &quot;Predictions&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function aims to ease the comparation between different predictive models
by plotting them into the same graphic.
</p>


<h3>Author(s)</h3>

<p>Alberto Vico Moreno
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(AirPassengers)
#pre-processing
p &lt;- prep(AirPassengers)
#modelling
arima.modl &lt;- modl(p)
cart.modl &lt;- modl(p,method='dataMining',algorithm='rpart')
#predicting
arima.pred &lt;- pred(arima.modl,n.ahead=30)
cart.pred &lt;- pred(cart.modl,n.ahead=45)
#post-processing
arima.pred &lt;- postp(arima.pred,p)
cart.pred &lt;- postp(cart.pred,p)
#visual comparison
pred.compareModels(AirPassengers,arima.pred$predictions,cart.pred$predictions
,legendNames=c('AirPassengers','ARIMA','CART'),yAxis='Passengers',legendPosition = 'topleft')

</code></pre>

<hr>
<h2 id='pred.dataMining'>Predicts for data mining methods</h2><span id='topic+pred.dataMining'></span>

<h3>Description</h3>

<p>Performs predictions over a data mining model using the <code>caret::predict.train</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.dataMining(model, n.ahead)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.dataMining_+3A_model">model</code></td>
<td>
<p>A <code>modl</code> object.</p>
</td></tr>
<tr><td><code id="pred.dataMining_+3A_n.ahead">n.ahead</code></td>
<td>
<p>Number of values to predict.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ts</code> object containing the predictions.
</p>


<h3>Author(s)</h3>

<p>Alberto Vico Moreno
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- modl(prep(AirPassengers),method='dataMining',algorithm='rpart')
pred.dataMining(m,n.ahead=15)
</code></pre>

<hr>
<h2 id='prep'>Automatic pre-preprocessing</h2><span id='topic+prep'></span>

<h3>Description</h3>

<p>This function performs pre-processing on a time series object(ts) to treat
heterocedasticity, trend and seasonality in order to make the serie stationary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep(tserie, homogenize.method = "log", detrend.method = "differencing",
  nd = NULL, deseason.method = "differencing", nsd = NULL,
  detrend.first = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_+3A_tserie">tserie</code></td>
<td>
<p>A ts object.</p>
</td></tr>
<tr><td><code id="prep_+3A_homogenize.method">homogenize.method</code></td>
<td>
<p>A string. Current methods available are &quot;log&quot; and &quot;boxcox&quot;. Method &quot;log&quot; is set as default. If you don't want to perform this transformation, set method as &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="prep_+3A_detrend.method">detrend.method</code></td>
<td>
<p>A string. Current methods available are &quot;differencing&quot; and &quot;sfsm&quot;. Method &quot;differencing&quot; is set as default. If you don't want to perform this transformation, set method as &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="prep_+3A_nd">nd</code></td>
<td>
<p>A number. Number of differences you want to apply to the &quot;differencing&quot; detrending method. As default its value is NULL, which means nd will be calculated internally.</p>
</td></tr>
<tr><td><code id="prep_+3A_deseason.method">deseason.method</code></td>
<td>
<p>A string. Current methods available are &quot;differencing&quot;. Method &quot;differencing&quot; is set as default. If you don't want to perform this transformation, set method as &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="prep_+3A_nsd">nsd</code></td>
<td>
<p>A number. Number of seasonal differences you want to apply to the &quot;differencing&quot; deseasoning method. As default its value is NULL, which means nsd will be calculated internally.</p>
</td></tr>
<tr><td><code id="prep_+3A_detrend.first">detrend.first</code></td>
<td>
<p>A boolean. TRUE if detrending method is applied first, then deseasoning. FALSE if deseasoning method is applied first. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns an object <code>prep</code> which stores all data needed to undo the changes later on.
</p>
<p>This function provides an automatic way of pre-processing based on unit root tests, but
this is not the perfect way to do it. You should always check manually if
the given time serie is actually stationary, and modify the parameters according
to your thoughts.
</p>


<h3>Value</h3>

<p>A list is returned of class <code>prep</code> containing:
</p>
<table>
<tr><td><code>tserie</code></td>
<td>
<p>Processed ts object.</p>
</td></tr>
<tr><td><code>homogenize.method</code></td>
<td>
<p>Method used for homogenizing.</p>
</td></tr>
<tr><td><code>detrend.method</code></td>
<td>
<p>Method used for detrending.</p>
</td></tr>
<tr><td><code>nd</code></td>
<td>
<p>Number of differences used on detrending through differencing.</p>
</td></tr>
<tr><td><code>firstvalues</code></td>
<td>
<p>First <code>nd</code> values of the original series.</p>
</td></tr>
<tr><td><code>deseason.method</code></td>
<td>
<p>Method used for deseasoning.</p>
</td></tr>
<tr><td><code>nsd</code></td>
<td>
<p>Number of seasonal differences used on deseasoning through differencing.</p>
</td></tr>
<tr><td><code>firstseasons</code></td>
<td>
<p>First <code>nsd</code> seasons of the original series.</p>
</td></tr>
<tr><td><code>detrend.first</code></td>
<td>
<p>Processed ts object</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>Vector of means used in &quot;sfsm&quot; detrending method.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Coefficient used in &quot;boxcox&quot; transformation.</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>Start of the original time serie.</p>
</td></tr>
<tr><td><code>length</code></td>
<td>
<p>Length of the original time serie.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alberto Vico Moreno
</p>


<h3>References</h3>

<p><a href="https://www.otexts.org/fpp/8/1">https://www.otexts.org/fpp/8/1</a>
</p>


<h3>See Also</h3>


<p><code><a href="#topic+prep.homogenize.log">prep.homogenize.log</a></code>,
<code><a href="#topic+prep.homogenize.boxcox">prep.homogenize.boxcox</a></code>,
<code><a href="#topic+prep.detrend.differencing">prep.detrend.differencing</a></code>,
<code><a href="#topic+prep.detrend.sfsm">prep.detrend.sfsm</a></code>,
<code><a href="#topic+prep.deseason.differencing">prep.deseason.differencing</a></code>,
<code><a href="#topic+prep.check.acf">prep.check.acf</a></code>,
<code><a href="#topic+prep.check.adf">prep.check.adf</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>prep(AirPassengers)
prep(AirPassengers,homogenize.method='boxcox',detrend.method='none')
</code></pre>

<hr>
<h2 id='prep.check.acf'>Autocorrelation function</h2><span id='topic+prep.check.acf'></span>

<h3>Description</h3>

<p>Plots the autocorrelation function to check stationarity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep.check.acf(tserie)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep.check.acf_+3A_tserie">tserie</code></td>
<td>
<p>a <code>ts</code> or a <code>prep</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a stationary time series, the ACF will drop to zero
relatively quickly, while the ACF of non-stationary data decreases slowly.
Also, for non-stationary data, the value is often large and positive.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prep.check.acf(AirPassengers)
prep.check.acf(prep(AirPassengers))
</code></pre>

<hr>
<h2 id='prep.check.adf'>Augmented Dickey-Fuller test</h2><span id='topic+prep.check.adf'></span>

<h3>Description</h3>

<p>Performs ADF test just as another tool to check stationarity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep.check.adf(tserie)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep.check.adf_+3A_tserie">tserie</code></td>
<td>
<p>a <code>ts</code> or a <code>prep</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Shows the results of an ADF test. A p-value&lt;0.05 suggests the data is stationary.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prep.check.adf(AirPassengers)
prep.check.adf(prep(AirPassengers))
</code></pre>

<hr>
<h2 id='prep.deseason.differencing'>Deseason with differencing method</h2><span id='topic+prep.deseason.differencing'></span>

<h3>Description</h3>

<p>Performs differencing with lag=frequency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep.deseason.differencing(tserie, nsd = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep.deseason.differencing_+3A_tserie">tserie</code></td>
<td>
<p>a <code>ts</code> object</p>
</td></tr>
<tr><td><code id="prep.deseason.differencing_+3A_nsd">nsd</code></td>
<td>
<p>number of seasonal differences to apply. As default its value is NULL; in this case, the function will perform an automatic estimation of <code>nsd</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no number of differences is specified, the function will make an estimation
of the number of differences needed based on unit root test provided by <code>forecast::nsdiffs</code>
</p>


<h3>Value</h3>

<p>A list is returned containing:
</p>
<table>
<tr><td><code>tserie</code></td>
<td>
<p>Transformed ts object.</p>
</td></tr>
<tr><td><code>nsd</code></td>
<td>
<p>Number of seasonal differencies applied.</p>
</td></tr>
<tr><td><code>firstseasons</code></td>
<td>
<p>Lost values after differencing.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>prep.deseason.differencing(AirPassengers)
prep.deseason.differencing(AirPassengers,nsd=2)
</code></pre>

<hr>
<h2 id='prep.detrend.differencing'>Detrend with differencing method</h2><span id='topic+prep.detrend.differencing'></span>

<h3>Description</h3>

<p>Performs differencing with lag=1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep.detrend.differencing(tserie, nd = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep.detrend.differencing_+3A_tserie">tserie</code></td>
<td>
<p>a <code>ts</code> object</p>
</td></tr>
<tr><td><code id="prep.detrend.differencing_+3A_nd">nd</code></td>
<td>
<p>number of differences to apply. As default its value is NULL; in this case, the function will perform an automatic estimation of <code>nd</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no number of differences is specified, the function will make an estimation
of the number of differences needed based on unit root test provided by <code>forecast::ndiffs</code>
</p>


<h3>Value</h3>

<p>A list is returned containing:
</p>
<table>
<tr><td><code>tserie</code></td>
<td>
<p>Transformed ts object.</p>
</td></tr>
<tr><td><code>nd</code></td>
<td>
<p>Number of differencies applied.</p>
</td></tr>
<tr><td><code>firstvalues</code></td>
<td>
<p>Lost values after differencing.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>prep.detrend.differencing(AirPassengers)
prep.detrend.differencing(AirPassengers,nd=2)
</code></pre>

<hr>
<h2 id='prep.detrend.sfsm'>Detrend with &quot;substracting full-season means&quot; method</h2><span id='topic+prep.detrend.sfsm'></span>

<h3>Description</h3>

<p>Performs &quot;substracting full-season means&quot; method to go for a totally automatic
approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep.detrend.sfsm(tserie)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep.detrend.sfsm_+3A_tserie">tserie</code></td>
<td>
<p>a <code>ts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under this detrending scheme, a series is first split into segments. The length
of the segments is equal to the length of seasonality(12 for monthly).
The mean of the historical observations within each of these segments is substacted
from every historical observation in the segment.
To get the detrended serie we do:
<code>ds = xi - m</code>
Being <code>xi</code> the actual values on the time series and <code>m</code> the mean of the segment of <code>xi</code>
</p>


<h3>Value</h3>

<p>A list is returned containing:
</p>
<table>
<tr><td><code>tserie</code></td>
<td>
<p>Transformed ts object.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>Vector containing the historical means.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>prep.detrend.sfsm(AirPassengers)
</code></pre>

<hr>
<h2 id='prep.homogenize.boxcox'>Box-Cox transformation</h2><span id='topic+prep.homogenize.boxcox'></span>

<h3>Description</h3>

<p>Performs a Box-Cox transformation to a time serie.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep.homogenize.boxcox(tserie)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep.homogenize.boxcox_+3A_tserie">tserie</code></td>
<td>
<p>a <code>ts</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list is returned containing:
</p>
<table>
<tr><td><code>boxcox</code></td>
<td>
<p>Transformed ts object.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Lambda value.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Box-Cox transformation: <a href="https://en.wikipedia.org/wiki/Power_transform#Box.E2.80.93Cox_transformation">https://en.wikipedia.org/wiki/Power_transform#Box.E2.80.93Cox_transformation</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prep.homogenize.log(AirPassengers)
</code></pre>

<hr>
<h2 id='prep.homogenize.log'>Logarithmic transformation</h2><span id='topic+prep.homogenize.log'></span>

<h3>Description</h3>

<p>Performs a logarithmic transformation to a time serie.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep.homogenize.log(tserie)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep.homogenize.log_+3A_tserie">tserie</code></td>
<td>
<p>a <code>ts</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ts</code> object with transformed time serie
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prep.homogenize.log(AirPassengers)
</code></pre>

<hr>
<h2 id='print.modl'>Generic function</h2><span id='topic+print.modl'></span>

<h3>Description</h3>

<p>Prints object modl
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modl'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.modl_+3A_x">x</code></td>
<td>
<p><code>prep</code> object</p>
</td></tr>
<tr><td><code id="print.modl_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>print(modl(prep(AirPassengers)))
</code></pre>

<hr>
<h2 id='print.pred'>Generic function</h2><span id='topic+print.pred'></span>

<h3>Description</h3>

<p>Prints object pred
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pred'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pred_+3A_x">x</code></td>
<td>
<p><code>prep</code> object</p>
</td></tr>
<tr><td><code id="print.pred_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>print(pred(modl(prep(AirPassengers))))
</code></pre>

<hr>
<h2 id='print.prep'>Generic function</h2><span id='topic+print.prep'></span>

<h3>Description</h3>

<p>Prints object prep
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prep'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.prep_+3A_x">x</code></td>
<td>
<p><code>prep</code> object</p>
</td></tr>
<tr><td><code id="print.prep_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>print(prep(AirPassengers))
</code></pre>

<hr>
<h2 id='summary.modl'>Generic function</h2><span id='topic+summary.modl'></span>

<h3>Description</h3>

<p>Summary of object modl
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modl'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.modl_+3A_object">object</code></td>
<td>
<p><code>prep</code> object</p>
</td></tr>
<tr><td><code id="summary.modl_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>summary(modl(prep(AirPassengers)))
</code></pre>

<hr>
<h2 id='summary.pred'>Generic function</h2><span id='topic+summary.pred'></span>

<h3>Description</h3>

<p>Summary of object pred
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pred'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.pred_+3A_object">object</code></td>
<td>
<p><code>prep</code> object</p>
</td></tr>
<tr><td><code id="summary.pred_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>summary(pred(modl(prep(AirPassengers))))
</code></pre>

<hr>
<h2 id='summary.prep'>Generic function</h2><span id='topic+summary.prep'></span>

<h3>Description</h3>

<p>Summary of object prep
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prep'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.prep_+3A_object">object</code></td>
<td>
<p><code>prep</code> object</p>
</td></tr>
<tr><td><code id="summary.prep_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>summary(prep(AirPassengers))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
