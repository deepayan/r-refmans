<!DOCTYPE html><html><head><title>Help for package fdadensity</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fdadensity}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BacteriaPI'><p>pH distribution of 813 bacterial organisms</p></a></li>
<li><a href='#CreateModeOfVarPlotLQ2D'><p>Transformation Mode of Variation Plot</p></a></li>
<li><a href='#dens2lqd'><p>Function for converting densities to log quantile density functions</p></a></li>
<li><a href='#dens2qd'><p>Function for converting Densities to Quantile Densities</p></a></li>
<li><a href='#dens2quantile'><p>Function for converting Densities to Quantile Functions</p></a></li>
<li><a href='#DeregulariseByAlpha'><p>Function to deregularise densities to have (smaller) minimum value</p></a></li>
<li><a href='#FPCAdens'><p>FPCA for densities by log quantile density transformation</p></a></li>
<li><a href='#GetFVE'><p>Compute Metric-based Fraction of Variance Explained</p></a></li>
<li><a href='#getWFmean'><p>Wasserstein Frechet Mean Computation</p></a></li>
<li><a href='#lqd2dens'><p>Function for converting log quantile densities to densities</p></a></li>
<li><a href='#lqd2quantile'><p>Function for converting log quantile densities to quantile functions</p></a></li>
<li><a href='#MakeDENsample'><p>Convenience function for converting log quantile densities to densities</p></a></li>
<li><a href='#MakeLQDsample'><p>Convenience function for converting densities to log-quantile densities</p></a></li>
<li><a href='#normaliseDensities'><p>Normalise Densities</p></a></li>
<li><a href='#qd2dens'><p>Function for converting Quantile Densities to Densities</p></a></li>
<li><a href='#RegulariseByAlpha'><p>Function to regularise densities to have (larger) minimum value</p></a></li>
<li><a href='#Top50BabyNames'><p>Baby name popularity densities for 50 male and 50 female names in the USA</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>URL:</td>
<td><a href="https://github.com/functionaldata/tDENS">https://github.com/functionaldata/tDENS</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/functionaldata/tDENS/issues">https://github.com/functionaldata/tDENS/issues</a></td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Functional Data Analysis for Density Functions by Transformation
to a Hilbert Space</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-12-03</td>
</tr>
<tr>
<td>Author:</td>
<td>A. Petersen, P. Z. Hadjipantelis and H.G. Mueller</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Petersen &lt;petersen@pstat.ucsb.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of the methodology described in
    Petersen and Mueller (2016) &lt;<a href="https://doi.org/10.1214%2F15-AOS1363">doi:10.1214/15-AOS1363</a>&gt; for the functional
    data analysis of samples of density functions.  Densities are first
    transformed to their corresponding log quantile densities, followed by
    ordinary Functional Principal Components Analysis (FPCA).  Transformation
    modes of variation yield improved interpretation of the variability in the
    data as compared to FPCA on the densities themselves.  The standard
    fraction of variance explained (FVE) criterion commonly used for functional
    data is adapted to the transformation setting, also allowing for an
    alternative quantification of variability for density data through the
    Wasserstein metric of optimal transport.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>false</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.5), fdapace (&ge; 0.3.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-12-04 18:09:17 UTC; alexanderpetersen</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-12-05 06:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='BacteriaPI'>pH distribution of 813 bacterial organisms</h2><span id='topic+BacteriaPI'></span>

<h3>Description</h3>

<p>The approximate kernel density estimates of the 813 bacterial 
organisms' isoelectric point (pI) protein distributions.
</p>


<h3>Format</h3>

<p>A matrix with 813 rows and 768 columns:
</p>

<dl>
<dt>rowname</dt><dd><p>General organism identifier</p>
</dd>
<dt>colspace</dt><dd><p>pH in [0,14]</p>
</dd>
</dl>


<h3>References</h3>

<p>The authors would like to thank Dr. Chris Knight for providing the original data
</p>

<hr>
<h2 id='CreateModeOfVarPlotLQ2D'>Transformation Mode of Variation Plot</h2><span id='topic+CreateModeOfVarPlotLQ2D'></span>

<h3>Description</h3>

<p>Create the k-th transformation mode of variation plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateModeOfVarPlotLQ2D(
  fpcaObj,
  domain = "D",
  k = 1,
  dSup = NULL,
  Qvec = -2:2,
  alpha = 0,
  useAlpha = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateModeOfVarPlotLQ2D_+3A_fpcaobj">fpcaObj</code></td>
<td>
<p>An FPCA class object returned by FPCA() on the log quantile density functions.</p>
</td></tr>
<tr><td><code id="CreateModeOfVarPlotLQ2D_+3A_domain">domain</code></td>
<td>
<p>should the mode be plotted in LQD ('Q') or density space ('D', the default).</p>
</td></tr>
<tr><td><code id="CreateModeOfVarPlotLQ2D_+3A_k">k</code></td>
<td>
<p>The k-th mode of variation to plot (default k = 1)</p>
</td></tr>
<tr><td><code id="CreateModeOfVarPlotLQ2D_+3A_dsup">dSup</code></td>
<td>
<p>The common support of the original densities. Only relevant for <code>domain = 'D'</code></p>
</td></tr>
<tr><td><code id="CreateModeOfVarPlotLQ2D_+3A_qvec">Qvec</code></td>
<td>
<p>Vector of values <code class="reqn">Q</code> to be plotted.  If 0 is not included, it will be added (default is -2:2).  Only relevant for <code>domain = 'D'</code></p>
</td></tr>
<tr><td><code id="CreateModeOfVarPlotLQ2D_+3A_alpha">alpha</code></td>
<td>
<p>(De)regularisation parameter (default is 0).  See details.</p>
</td></tr>
<tr><td><code id="CreateModeOfVarPlotLQ2D_+3A_usealpha">useAlpha</code></td>
<td>
<p>logical - should deregularisation be performed?  Default:FALSE</p>
</td></tr>
<tr><td><code id="CreateModeOfVarPlotLQ2D_+3A_...">...</code></td>
<td>
<p>Additional arguments for the 'plot' function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>domain = 'D'</code> (the default), the a transformation mode of variation is plotted.  The red-line is 
<code class="reqn">\psi^{-1}(\nu)</code>, where <code class="reqn">\nu</code> is the mean in LQD space and
<code class="reqn">\psi</code> is the LQD transformation.  Other lines correspond to perturbations by 
adding multiples of the LQD eigenfunctions <code class="reqn">\rho_k</code> (with eigenvalues <code class="reqn">\tau_k</code>)
: <code class="reqn">\psi^{-1}(\nu  + Q \sqrt{\tau_k} \rho_k)</code> 
for the values <code class="reqn">Q</code> in <code>Qvec</code>.  If <code>alpha</code> is positive, will attempt to deregularise (see <code>DeregulariseByAlpha</code>). This
will throw an error if alpha is too large.
</p>
<p>If <code>domain = 'Q'</code>, ordinary modes of variation are plotted in LQD space (see documentation for <code>CreateModeOfVarPlot</code> in <code>fdapace</code>).
</p>


<h3>References</h3>

<p><cite>Functional Data Analysis for Density Functions by Transformation to a Hilbert space, Alexander Petersen and Hans-Georg Mueller, 2016</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DeregulariseByAlpha">DeregulariseByAlpha</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Densities for Top 50 Male Baby Names
data(Top50BabyNames)
x = Top50BabyNames$x

# Perform Transformation FPCA for male baby name densities
X = FPCAdens(dmatrix = t(Top50BabyNames$dens$male), dSup = Top50BabyNames$x, useAlpha = TRUE, 
                  optns = list(dataType = 'Dense', error = FALSE, methodSelectK = 2))

# Plot Modes

Qvec = quantile(X$xiEst[,1], probs = c(0.1, 0.25, 0.75, 0.9))/sqrt(X$lambda[1])
CreateModeOfVarPlotLQ2D(X, k = 1, dSup = x, Qvec = Qvec, main = 'First Mode, Density Space')
CreateModeOfVarPlotLQ2D(X, domain = 'Q', k = 1, dSup = x, Qvec = Qvec, 
                            main = 'First Mode, LQD space')

Qvec = quantile(X$xiEst[,2], probs = c(0.1, 0.25, 0.75, 0.9))/sqrt(X$lambda[2])
CreateModeOfVarPlotLQ2D(X, k = 2, dSup = x, Qvec = Qvec, main = 'Second Mode, Density Space')
CreateModeOfVarPlotLQ2D(X, domain = 'Q', k = 2, dSup = x, Qvec = Qvec, 
                            main = 'Second Mode, LQD space')

</code></pre>

<hr>
<h2 id='dens2lqd'>Function for converting densities to log quantile density functions</h2><span id='topic+dens2lqd'></span>

<h3>Description</h3>

<p>Function for converting densities to log quantile density functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dens2lqd(dens, dSup, N = length(dSup), lqdSup = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dens2lqd_+3A_dens">dens</code></td>
<td>
<p>density values on dSup - must be strictly positive and integrate to 1</p>
</td></tr>
<tr><td><code id="dens2lqd_+3A_dsup">dSup</code></td>
<td>
<p>support (grid) for Density domain</p>
</td></tr>
<tr><td><code id="dens2lqd_+3A_n">N</code></td>
<td>
<p>desired number of points on a [0,1] grid for lqd function; default length(dSup)</p>
</td></tr>
<tr><td><code id="dens2lqd_+3A_lqdsup">lqdSup</code></td>
<td>
<p>support for lqd domain - must begin at 0 and end at 1; default [0,1] with N-equidistant support points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>lqd log quantile density on lqdSup
</p>


<h3>References</h3>

<p><cite>Functional Data Analysis for Density Functions by Transformation to a Hilbert space, Alexander Petersen and Hans-Georg Mueller, 2016</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normaliseDensities">normaliseDensities</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(0,2,length.out =512)
y &lt;- rep(0.5,length.out =512)
y.lqd &lt;- dens2lqd( dens=y, dSup = x) # should equate # log(2)

</code></pre>

<hr>
<h2 id='dens2qd'>Function for converting Densities to Quantile Densities</h2><span id='topic+dens2qd'></span>

<h3>Description</h3>

<p>Function for converting Densities to Quantile Densities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dens2qd(
  dens,
  dSup = seq(0, 1, length.out = length(dens)),
  qdSup = seq(0, 1, length.out = length(dens)),
  useSplines = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dens2qd_+3A_dens">dens</code></td>
<td>
<p>density on dSup</p>
</td></tr>
<tr><td><code id="dens2qd_+3A_dsup">dSup</code></td>
<td>
<p>support for Density domain - max and min values mark the boundary of the support.</p>
</td></tr>
<tr><td><code id="dens2qd_+3A_qdsup">qdSup</code></td>
<td>
<p>support for quantile density domain - must begin at 0 and end at 1</p>
</td></tr>
<tr><td><code id="dens2qd_+3A_usesplines">useSplines</code></td>
<td>
<p>fit spline to the qd when doing the numerical integration (default: TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>qd quantile density values on qdSup
</p>


<h3>References</h3>

<p><cite>Functional Data Analysis for Density Functions by Transformation to a Hilbert space, Alexander Petersen and Hans-Georg Mueller, 2016</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normaliseDensities">normaliseDensities</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(0,2,length.out =512)
y &lt;- rep(0.5,length.out =512)
y.qd &lt;- dens2qd(dens=y, dSup = x) # should equate # 2

</code></pre>

<hr>
<h2 id='dens2quantile'>Function for converting Densities to Quantile Functions</h2><span id='topic+dens2quantile'></span>

<h3>Description</h3>

<p>Function for converting Densities to Quantile Functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dens2quantile(
  dens,
  dSup = seq(0, 1, length.out = length(dens)),
  qSup = seq(0, 1, length.out = length(dens)),
  useSplines = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dens2quantile_+3A_dens">dens</code></td>
<td>
<p>density on dSup</p>
</td></tr>
<tr><td><code id="dens2quantile_+3A_dsup">dSup</code></td>
<td>
<p>support for Density domain - max and min values mark the boundary of the support.</p>
</td></tr>
<tr><td><code id="dens2quantile_+3A_qsup">qSup</code></td>
<td>
<p>support for quantile domain - must begin at 0 and end at 1</p>
</td></tr>
<tr><td><code id="dens2quantile_+3A_usesplines">useSplines</code></td>
<td>
<p>fit spline to the qd when doing the numerical integration (default: TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Q quantile function on qSup
</p>


<h3>References</h3>

<p><cite>Functional Data Analysis for Density Functions by Transformation to a Hilbert space, Alexander Petersen and Hans-Georg Mueller, 2016</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normaliseDensities">normaliseDensities</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(0,2,length.out =512)
y &lt;- rep(0.5,length.out =512)
y.quantile &lt;- dens2quantile(dens=y, dSup = x) # should equate # 2*seq(0, 1, length.out = 512)

</code></pre>

<hr>
<h2 id='DeregulariseByAlpha'>Function to deregularise densities to have (smaller) minimum value</h2><span id='topic+DeregulariseByAlpha'></span>

<h3>Description</h3>

<p>If possible, deregularises the input density <code>y</code> to have minimum density value is <code>alpha</code>. See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DeregulariseByAlpha(x, y, alpha = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DeregulariseByAlpha_+3A_x">x</code></td>
<td>
<p>support of the density</p>
</td></tr>
<tr><td><code id="DeregulariseByAlpha_+3A_y">y</code></td>
<td>
<p>values of the density</p>
</td></tr>
<tr><td><code id="DeregulariseByAlpha_+3A_alpha">alpha</code></td>
<td>
<p>scalar to deregularise with (default = 0) - this will be the minimum value of the deregularised density, unless <code>min(y) &lt; alpha</code>, in which case 
no deregularisation will be performed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>min(y) &lt;= alpha</code>, or <code>y</code> is the uniform distribution, no deregularisation is performed and <code>y</code> is returned.  If <code>min(y)*diff(range(x)) &gt; 1</code>, 
the deregularisation is not possible and an error is thrown.  Otherwise, the deregularised density in an inverse manner to <code>RegulariseByAlpha</code>.
</p>


<h3>Value</h3>

<p>dens density values on x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RegulariseByAlpha">RegulariseByAlpha</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 x = seq(0,1,length.out=122)
 y = seq(0.1,1.9,length.out=122)
 z = DeregulariseByAlpha(x=x, y=y, alpha = 0)
 
</code></pre>

<hr>
<h2 id='FPCAdens'>FPCA for densities by log quantile density transformation</h2><span id='topic+FPCAdens'></span>

<h3>Description</h3>

<p>Perform FPCA on LQD-transformed densities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FPCAdens(
  dmatrix,
  dSup,
  lqdSup = seq(0, 1, length.out = length(dSup)),
  useAlpha = FALSE,
  alpha = 0.01,
  optns = list(dataType = "Dense", error = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FPCAdens_+3A_dmatrix">dmatrix</code></td>
<td>
<p>Matrix holding the density values on dSup - all rows must be strictly positive and integrate to 1</p>
</td></tr>
<tr><td><code id="FPCAdens_+3A_dsup">dSup</code></td>
<td>
<p>Support (grid) for Density domain</p>
</td></tr>
<tr><td><code id="FPCAdens_+3A_lqdsup">lqdSup</code></td>
<td>
<p>Support grid for lqd domain (default = seq(0, 1, length.out = length(dSup)))</p>
</td></tr>
<tr><td><code id="FPCAdens_+3A_usealpha">useAlpha</code></td>
<td>
<p>should regularisation be performed (default=FALSE)</p>
</td></tr>
<tr><td><code id="FPCAdens_+3A_alpha">alpha</code></td>
<td>
<p>Scalar to regularise the supports with (default=0.01)</p>
</td></tr>
<tr><td><code id="FPCAdens_+3A_optns">optns</code></td>
<td>
<p>A list of options for FPCA.  See documentation for <code>FPCA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Densities are transformed to log-quantile densities, followed by standard FPCA.  If <code>useAlpha = TRUE</code>, densities are regularized before transformation
</p>


<h3>References</h3>

<p><cite>Functional Data Analysis for Density Functions by Transformation to a Hilbert space, Alexander Petersen and Hans-Georg Mueller, 2016</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RegulariseByAlpha">RegulariseByAlpha</a>,<a href="#topic+lqd2dens">lqd2dens</a>,<a href="#topic+MakeLQDsample">MakeLQDsample</a>,<a href="fdapace.html#topic+FPCA">FPCA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Densities for Top 50 Female Baby Names
data(Top50BabyNames)

# Perform Transformation FPCA for male baby name densities
X = FPCAdens(dmatrix = t(Top50BabyNames$dens$female), dSup = Top50BabyNames$x, useAlpha = TRUE, 
                  optns = list(dataType = 'Dense', error = FALSE, methodSelectK = 2))
x = Top50BabyNames$x

# Plot Modes

Qvec = quantile(X$xiEst[,1], probs = c(0.1, 0.25, 0.75, 0.9))/sqrt(X$lambda[1])
CreateModeOfVarPlotLQ2D(X, k = 1, dSup = x, Qvec = Qvec, main = 'First Mode, Density space')
CreateModeOfVarPlotLQ2D(X, domain = 'Q', k = 1, dSup = x, Qvec = Qvec, 
                            main = 'First Mode, LQD space')

Qvec = quantile(X$xiEst[,2], probs = c(0.1, 0.25, 0.75, 0.9))/sqrt(X$lambda[2])
CreateModeOfVarPlotLQ2D(X, k = 2, dSup = x, Qvec = Qvec, main = 'Second Mode, Density Space')
CreateModeOfVarPlotLQ2D(X, domain = 'Q', k = 2, dSup = x, Qvec = Qvec, 
                            main = 'Second Mode, LQD space')

</code></pre>

<hr>
<h2 id='GetFVE'>Compute Metric-based Fraction of Variance Explained</h2><span id='topic+GetFVE'></span>

<h3>Description</h3>

<p>When FPCA is performed on the log quantile density functions, the fraction of variance explained by the first K components is computed based on 
the density reconstruction and chosen metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetFVE(fpcaObj, dmatrix, dSup, metric = "L2", useAlpha = FALSE, alpha = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetFVE_+3A_fpcaobj">fpcaObj</code></td>
<td>
<p>PACE output (FPCA on LQDs)</p>
</td></tr>
<tr><td><code id="GetFVE_+3A_dmatrix">dmatrix</code></td>
<td>
<p>matrix of original densities measures on grid dSup, rows correspond to individual densities</p>
</td></tr>
<tr><td><code id="GetFVE_+3A_dsup">dSup</code></td>
<td>
<p>support for Density domain - max and min mark the boundary of the support.</p>
</td></tr>
<tr><td><code id="GetFVE_+3A_metric">metric</code></td>
<td>
<p>metric for measuring variance - 'L2' for Euclidean or 'W' for Wasserstein</p>
</td></tr>
<tr><td><code id="GetFVE_+3A_usealpha">useAlpha</code></td>
<td>
<p>should regularisation be performed to densities in dmatrix? This should be set to TRUE if densities were regularised prior to FPCA (default = FALSE)</p>
</td></tr>
<tr><td><code id="GetFVE_+3A_alpha">alpha</code></td>
<td>
<p>scalar to regularise before computing FVE.  If useAlpha = TRUE, this should match the value used to regularise prior to FPCA (default = 0.01)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fraction of variance explained (FVE) by the first K principal components corresponding to the LQD functions is computed by taking the K-dimensional
LQD representations, transforming back to densities, and comparing the reconstruction to the original densities using the chosen metric.  If densities were regularised
prior to transformation and FPCA, the same regularisation parameters should be used here.
</p>


<h3>Value</h3>

<p>FVEvector
</p>


<h3>References</h3>

<p><cite>Functional Data Analysis for Density Functions by Transformation to a Hilbert space, Alexander Petersen and Hans-Georg Mueller, 2016</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RegulariseByAlpha">RegulariseByAlpha</a>,<a href="#topic+lqd2quantile">lqd2quantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Top50BabyNames)

# Perform Transformation FPCA for male baby name densities
dSup = Top50BabyNames$x
X = FPCAdens(dmatrix = t(Top50BabyNames$dens$male), dSup = dSup, useAlpha = TRUE, 
                   optns = list(dataType = 'Dense', error = FALSE, methodSelectK = 8))

# Compute FVE - must compare to regularized densities 

fveL2 = GetFVE(fpcaObj = X, dmatrix = t(Top50BabyNames$dens$male), dSup = dSup, useAlpha = TRUE)
fveW = GetFVE(fpcaObj = X, dmatrix = t(Top50BabyNames$dens$male), dSup = dSup, 
                   metric = 'W', useAlpha = TRUE)

</code></pre>

<hr>
<h2 id='getWFmean'>Wasserstein Frechet Mean Computation</h2><span id='topic+getWFmean'></span>

<h3>Description</h3>

<p>Function for computing the Wasserstein Frechet mean through quantile density averaging
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWFmean(
  dmatrix,
  dSup,
  N = length(dSup),
  qdSup = seq(0, 1, length.out = N),
  useAlpha = FALSE,
  alpha = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getWFmean_+3A_dmatrix">dmatrix</code></td>
<td>
<p>matrix of density values on dSup - must be strictly positive and each row must integrate to 1</p>
</td></tr>
<tr><td><code id="getWFmean_+3A_dsup">dSup</code></td>
<td>
<p>support (grid) for Density domain</p>
</td></tr>
<tr><td><code id="getWFmean_+3A_n">N</code></td>
<td>
<p>desired number of points on a [0,1] grid for quantile density functions; default length(dSup)</p>
</td></tr>
<tr><td><code id="getWFmean_+3A_qdsup">qdSup</code></td>
<td>
<p>support for LQ domain - must begin at 0 and end at 1; default [0,1] with N-equidistant support points</p>
</td></tr>
<tr><td><code id="getWFmean_+3A_usealpha">useAlpha</code></td>
<td>
<p>should regularisation be performed (default=FALSE)</p>
</td></tr>
<tr><td><code id="getWFmean_+3A_alpha">alpha</code></td>
<td>
<p>Scalar to regularise the supports with (default=0.01)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>wfmean the Wasserstein-Frechet mean density
</p>


<h3>References</h3>

<p><cite>Functional Data Analysis for Density Functions by Transformation to a Hilbert space, Alexander Petersen and Hans-Georg Mueller, 2016</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(0,1,length.out = 101)
# linear densities on (0, 1)
y &lt;- t(sapply(seq(0.5, 1.5, length.out = 10), function(b) b + 2*(1 - b)*x)) 
wfmean = getWFmean(y, x)

# Plot WF mean with Euclidean Mean
matplot(x, t(y), ylab = 'Density', type = 'l', lty = 1, col = 'black')
lines(x, wfmean, lwd = 2, col = 'red')
lines(x, colMeans(y), lwd = 2, col = 'blue')
legend('topright', col = c('black', 'red', 'blue'), lwd = c(1, 2, 2), 
           legend = c('Densities', 'WF Mean', 'Euclidean Mean'))

</code></pre>

<hr>
<h2 id='lqd2dens'>Function for converting log quantile densities to densities</h2><span id='topic+lqd2dens'></span>

<h3>Description</h3>

<p>Function for converting log quantile densities to densities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lqd2dens(
  lqd,
  lqdSup = seq(0, 1, length.out = length(lqd)),
  dSup,
  useSplines = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lqd2dens_+3A_lqd">lqd</code></td>
<td>
<p>log quantile density on lqdSup</p>
</td></tr>
<tr><td><code id="lqd2dens_+3A_lqdsup">lqdSup</code></td>
<td>
<p>support forlqd domain - must begin at 0 and end at 1</p>
</td></tr>
<tr><td><code id="lqd2dens_+3A_dsup">dSup</code></td>
<td>
<p>support for Density domain - max and min values mark the boundary of the support.</p>
</td></tr>
<tr><td><code id="lqd2dens_+3A_usesplines">useSplines</code></td>
<td>
<p>fit spline to the lqd when doing the numerical integration (default: TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dens density values on dSup
</p>


<h3>References</h3>

<p><cite>Functional Data Analysis for Density Functions by Transformation to a Hilbert space, Alexander Petersen and Hans-Georg Mueller, 2016</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(0,2,length.out =512)
y.lqd &lt;- rep(log(2), times = 512)
y &lt;- lqd2dens(dSup=x, lqd = y.lqd) # should equate # 1/2
</code></pre>

<hr>
<h2 id='lqd2quantile'>Function for converting log quantile densities to quantile functions</h2><span id='topic+lqd2quantile'></span>

<h3>Description</h3>

<p>Function for converting log quantile densities to quantile functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lqd2quantile(
  lqd,
  lqdSup = seq(0, 1, length.out = length(lqd)),
  lb = 0,
  useSplines = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lqd2quantile_+3A_lqd">lqd</code></td>
<td>
<p>log quantile density on lqdSup</p>
</td></tr>
<tr><td><code id="lqd2quantile_+3A_lqdsup">lqdSup</code></td>
<td>
<p>support for lqd domain - must begin at 0 and end at 1</p>
</td></tr>
<tr><td><code id="lqd2quantile_+3A_lb">lb</code></td>
<td>
<p>lower bound of support for Density domain - default is 0.</p>
</td></tr>
<tr><td><code id="lqd2quantile_+3A_usesplines">useSplines</code></td>
<td>
<p>fit spline to the lqd when doing the numerical integration (default: TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>quantile values on lqdSup
</p>


<h3>References</h3>

<p><cite>Functional Data Analysis for Density Functions by Transformation to a Hilbert space, Alexander Petersen and Hans-Georg Mueller, 2016</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(1,3,length.out =512)
y.lqd &lt;- rep(log(2), times = 512)
y &lt;- lqd2quantile(lqd = y.lqd, lb = 1) # should equate # seq(1, 3, length.out = 512)
</code></pre>

<hr>
<h2 id='MakeDENsample'>Convenience function for converting log quantile densities to densities</h2><span id='topic+MakeDENsample'></span>

<h3>Description</h3>

<p>See 'lqd2dens' and 'DeregulariseByAlpha' for more details.
This function transforms the log quantile densities in 'qmatrix' to density functions, optionally followed by deregularisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeDENsample(
  qmatrix,
  lqdSup = seq(0, 1, length.out = ncol(qmatrix)),
  dSup = seq(0, 1, length.out = ncol(qmatrix)),
  useAlpha = FALSE,
  alpha = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MakeDENsample_+3A_qmatrix">qmatrix</code></td>
<td>
<p>Matrix holding the log quantile density values on [0,1]</p>
</td></tr>
<tr><td><code id="MakeDENsample_+3A_lqdsup">lqdSup</code></td>
<td>
<p>Support grid for input log quantile densities (default = seq(0, 1, length.out = ncol(qmatrix)))</p>
</td></tr>
<tr><td><code id="MakeDENsample_+3A_dsup">dSup</code></td>
<td>
<p>Support grid for output densities (default = seq(0, 1, length.out = ncol(qmatrix)))</p>
</td></tr>
<tr><td><code id="MakeDENsample_+3A_usealpha">useAlpha</code></td>
<td>
<p>Logical indicator to deregularise the densities (default = FALSE)</p>
</td></tr>
<tr><td><code id="MakeDENsample_+3A_alpha">alpha</code></td>
<td>
<p>Scalar to deregularise the density - where possible, this will be the minimum value for the deregularised densities (default=0)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the 'DEN' transformed data, and 'dSup' that matches the input argument.
</p>


<h3>References</h3>

<p><cite>Functional Data Analysis for Density Functions by Transformation to a Hilbert space, Alexander Petersen and Hans-Georg Mueller, 2016</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DeregulariseByAlpha">DeregulariseByAlpha</a>,<a href="#topic+lqd2dens">lqd2dens</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 

x &lt;- seq(0,1,length.out = 101)
# linear densities on (0, 1)
y &lt;- t(sapply(seq(0.5, 1.5, length.out = 10), function(b) b + 2*(1 - b)*x)) 

# Get LQDs

y.lqd = MakeLQDsample(dmatrix = y, dSup = x)
matplot(y.lqd$lqdSup, t(y.lqd$LQD), ylab = 'LQD', type = 'l', lty = 1, col = 'black')

# Get Densities Back

y.dens = MakeDENsample(y.lqd$LQD, lqdSup = x, dSup = x) # should equate to y above
# These should look the same
matplot(y.dens$dSup, t(y.dens$DEN), ylab = 'Density', type = 'l', lty = 1, col = 'blue')
matplot(x, t(y), ylab = 'Original Density', type = 'l', lty = 1, col = 'red')

</code></pre>

<hr>
<h2 id='MakeLQDsample'>Convenience function for converting densities to log-quantile densities</h2><span id='topic+MakeLQDsample'></span>

<h3>Description</h3>

<p>See 'dens2lqd' and 'RegulariseByAlpha' for more details.
This function first (transforms the densities in 'dmatrix' to log quantile density functions, optionally followed by regularisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeLQDsample(
  dmatrix,
  dSup,
  lqdSup = seq(0, 1, length.out = length(dSup)),
  useAlpha = FALSE,
  alpha = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MakeLQDsample_+3A_dmatrix">dmatrix</code></td>
<td>
<p>Matrix holding the density values on dSup - all rows must be strictly positive and integrate to 1</p>
</td></tr>
<tr><td><code id="MakeLQDsample_+3A_dsup">dSup</code></td>
<td>
<p>Support (grid) for Density domain</p>
</td></tr>
<tr><td><code id="MakeLQDsample_+3A_lqdsup">lqdSup</code></td>
<td>
<p>Support grid for lqd domain (default = seq(0, 1, length.out = length(dSup)))</p>
</td></tr>
<tr><td><code id="MakeLQDsample_+3A_usealpha">useAlpha</code></td>
<td>
<p>should regularisation be performed (default=FALSE)</p>
</td></tr>
<tr><td><code id="MakeLQDsample_+3A_alpha">alpha</code></td>
<td>
<p>Scalar to regularise the supports with (default=0.01)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with 'LQD', a matrix of log quantile density functions, and 'lqdSup' that matches the input argument
</p>


<h3>References</h3>

<p><cite>Functional Data Analysis for Density Functions by Transformation to a Hilbert space, Alexander Petersen and Hans-Georg Mueller, 2016</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RegulariseByAlpha">RegulariseByAlpha</a>,<a href="#topic+dens2lqd">dens2lqd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 

x &lt;- seq(0,1,length.out = 101)
# some log quantile densities on (0, 1)
y &lt;- t(sapply(seq(0.5, 1.5, length.out = 10), function(b) -log(b^2 + 4*(1-b)*x)/2)) 

# Get densities

y.dens = MakeDENsample(qmatrix = y, lqdSup = x, dSup = x)$DEN
matplot(x, t(y.dens), ylab = 'Density', type = 'l', lty = 1, col = 'black')

# Get LQDs Back

y.lqd = MakeLQDsample(y.dens, lqdSup = x, dSup = x)
# These should match
matplot(y.lqd$lqdSup, t(y.lqd$LQD), ylab = 'LQD', type = 'l', lty = 1, col = 'blue')
matplot(x, t(y), ylab = 'LQD', type = 'l', lty = 1, col = 'red')

</code></pre>

<hr>
<h2 id='normaliseDensities'>Normalise Densities</h2><span id='topic+normaliseDensities'></span>

<h3>Description</h3>

<p>Preprocessing function to ensure densities integrate to 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normaliseDensities(dmatrix, dSup = 1:ncol(dmatrix))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normaliseDensities_+3A_dmatrix">dmatrix</code></td>
<td>
<p>Matrix with rows representing distinct densities on dSup - all entries must be nonnegative</p>
</td></tr>
<tr><td><code id="normaliseDensities_+3A_dsup">dSup</code></td>
<td>
<p>Support (grid) for Density domain</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses trapezoidal integration to normalise the densities to have integral 1
</p>


<h3>Value</h3>

<p>matrix 'dmatrix' consisting of rows of input of the same name that have been normalised to have integral 1
</p>


<h3>References</h3>

<p><cite>Functional Data Analysis for Density Functions by Transformation to a Hilbert space, Alexander Petersen and Hans-Georg Mueller, 2016</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Normalise collection of truncated normal densities

mu &lt;- seq(-2, 2, by = 0.5)
dSup = seq(-3, 3, length.out = 101)
y &lt;- t(sapply(mu, function(m) dnorm(x = dSup, mean = m)))

# Should return warnings about densities not integrating to 1
lqd = MakeLQDsample(dmatrix = y, dSup = dSup)

# Normalise and rerun without warning
dens &lt;- normaliseDensities(dmatrix = y, dSup = dSup)
lqd = MakeLQDsample(dmatrix = dens, dSup = dSup)


</code></pre>

<hr>
<h2 id='qd2dens'>Function for converting Quantile Densities to Densities</h2><span id='topic+qd2dens'></span>

<h3>Description</h3>

<p>Function for converting Quantile Densities to Densities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qd2dens(
  qd,
  qdSup = seq(0, 1, length.out = length(qd)),
  dSup,
  useSplines = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qd2dens_+3A_qd">qd</code></td>
<td>
<p>quantile density on qdSup</p>
</td></tr>
<tr><td><code id="qd2dens_+3A_qdsup">qdSup</code></td>
<td>
<p>support for quantile domain - must begin at 0 and end at 1 (default = seq(0, 1, length.out = length(qd)))</p>
</td></tr>
<tr><td><code id="qd2dens_+3A_dsup">dSup</code></td>
<td>
<p>support for Density domain - max and min values mark the boundary of the support.</p>
</td></tr>
<tr><td><code id="qd2dens_+3A_usesplines">useSplines</code></td>
<td>
<p>fit spline to the qd when doing the numerical integration (default: TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dens density values on dSup
</p>


<h3>References</h3>

<p><cite>Functional Data Analysis for Density Functions by Transformation to a Hilbert space, Alexander Petersen and Hans-Georg Mueller, 2016</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(0,1,length.out =512)
y &lt;- rep(2,length.out =512)
y.dens &lt;- qd2dens(qd=y, qdSup = x, dSup = seq(0, 2, length.out = 512)) # should equate # 1/2

</code></pre>

<hr>
<h2 id='RegulariseByAlpha'>Function to regularise densities to have (larger) minimum value</h2><span id='topic+RegulariseByAlpha'></span>

<h3>Description</h3>

<p>If possible, regularises the input density <code>y</code> to have minimum density value is <code>alpha</code>. See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RegulariseByAlpha(x, y, alpha = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RegulariseByAlpha_+3A_x">x</code></td>
<td>
<p>support of the density</p>
</td></tr>
<tr><td><code id="RegulariseByAlpha_+3A_y">y</code></td>
<td>
<p>values of the density</p>
</td></tr>
<tr><td><code id="RegulariseByAlpha_+3A_alpha">alpha</code></td>
<td>
<p>scalar to regularise with (default = 0.01) - this will be the minimum value of the regularised density, unless <code>min(y) &gt; alpha</code>, in which case 
no regularisation will be performed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>min(y) &gt;= alpha</code> or <code>y</code> is the uniform distribution, no regularisation is performed and <code>y</code> is returned.  If <code>alpha*diff(range(x)) &gt; 1</code>, 
the regularisation is not possible and an error is thrown.  Otherwise, the regularised density is computed by adding an appropriate constant <code>gam</code> <code>y</code>, 
followed by renormalisation to have integral 1.
</p>


<h3>Value</h3>

<p>dens density values on x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DeregulariseByAlpha">DeregulariseByAlpha</a>,<a href="#topic+normaliseDensities">normaliseDensities</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 x = seq(0,1,length.out=122)
 y = seq(0,2,length.out=122)
 z = RegulariseByAlpha(x=x, y=y, alpha = 0.1)
 
</code></pre>

<hr>
<h2 id='Top50BabyNames'>Baby name popularity densities for 50 male and 50 female names in the USA</h2><span id='topic+Top50BabyNames'></span>

<h3>Description</h3>

<p>Baby name popularity densities, obtained by smoothing year-to-year popularity indices from 1950 to 2016, after normalization to have integral equal to 1.  
The top 50 names, in absolute popularity, are included for each gender.
</p>


<h3>Format</h3>

<p>A list with two variables
</p>

<dl>
<dt>x</dt><dd><p>grid of years between 1950 and 2016, of length 67.</p>
</dd>
<dt>dens</dt><dd><p>list of length two, corresponding to male (<code>dens$male</code>) and female(<code>dens$female</code>) names.  Each is a 67-by-50 matrix of density estimates, where each 
column corresponds to a unique baby name given by the corresponding column name.</p>
</dd>
</dl>


<h3>References</h3>

<p>Data from the <code>R</code> package <code>babynames</code>, originally from the US Social Security Administration
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
