<!DOCTYPE html><html><head><title>Help for package inline</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {inline}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cfunction'><p> Inline C, C++, Fortran function calls from R</p></a></li>
<li><a href='#cxxfunction'><p>inline C++ function</p></a></li>
<li><a href='#getDynLib-methods'><p>Retrieve the dynamic library (or DLL) associated with a package of</p>
a function generated by cfunction</a></li>
<li><a href='#inline-package'><p>Functions to Inline C, C++, Fortran Function Calls from R</p></a></li>
<li><a href='#internals'><p> Internals</p></a></li>
<li><a href='#package.skeleton-methods'><p>Generate the skeleton of a package</p></a></li>
<li><a href='#plugins'>
<p>Plugin system for cxxfunction</p></a></li>
<li><a href='#utilities'><p> Printing, reading and writing compiled function objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.3.19</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-05-25</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions to Inline C, C++, Fortran Function Calls from R</td>
</tr>
<tr>
<td>Author:</td>
<td>Oleg Sklyar, Duncan Murdoch, Mike Smith, Dirk Eddelbuettel, 
 Romain Francois, Karline Soetaert, Johannes Ranke</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dirk Eddelbuettel &lt;edd@debian.org&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Rcpp (&ge; 0.11.0), tinytest</td>
</tr>
<tr>
<td>Description:</td>
<td>Functionality to dynamically define R functions and S4 methods
 with 'inlined' C, C++ or Fortran code supporting the .C and .Call calling
 conventions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a> | <a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL]</td>
</tr>
<tr>
<td>Copyright:</td>
<td>Oleg Sklyar, 2005-2010 and other authors per their commits</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/eddelbuettel/inline">https://github.com/eddelbuettel/inline</a>,
<a href="https://dirk.eddelbuettel.com/code/inline.html">https://dirk.eddelbuettel.com/code/inline.html</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/eddelbuettel/inline/issues">https://github.com/eddelbuettel/inline/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-25 12:45:08 UTC; edd</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-31 08:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cfunction'> Inline C, C++, Fortran function calls from R </h2><span id='topic+cfunction'></span><span id='topic+setCMethod'></span>

<h3>Description</h3>

<p>Functionality to dynamically define R functions and S4 methods with in-lined C,
C++ or Fortran code supporting .C and .Call calling conventions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cfunction(sig=character(), body=character(), includes=character(),
            otherdefs=character(),
            language=c("C++", "C", "Fortran", "F95", "ObjectiveC", "ObjectiveC++"),
            verbose=FALSE,
            convention=c(".Call", ".C", ".Fortran"),
            Rcpp=FALSE,
            cppargs=character(), cxxargs=character(), libargs=character(),
            dim=NULL, implicit=NULL, module=NULL, name=NULL)

  ## S4 methods for signatures
  #  f='character', sig='list', body='list'
  #  f='character', sig='character', body='character'

  setCMethod(f, sig, body, ...)

  ## Further arguments:
  #  setCMethod(f, sig, body, includes="", otherdefs="", cpp=TRUE,
  #  verbose=FALSE, where=topenv(.GlobalEnv), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cfunction_+3A_f">f</code></td>
<td>
<p>A single character value if <code>sig</code> and <code>body</code> are character vectors
or a character vector of the same length and the length of <code>sig</code> or
<code>body</code> with the name(s) of methods to create.</p>
</td></tr>
<tr><td><code id="cfunction_+3A_sig">sig</code></td>
<td>
<p>A match of formal argument names for the function with the
character-string names of corresponding classes. Alternatively,
a named list of such character vectors. The names of the list elements will
be used as function names (see example). If <code>sig</code> is not a list,
the function name used in the code can be specified by the <code>name</code>
argument.  </p>
</td></tr>
<tr><td><code id="cfunction_+3A_body">body</code></td>
<td>
<p> A character vector with C, C++ or Fortran code omitting function
declaration (only the body, i.e. in case of C starting after the function
opening curly bracket and ending before the closing curly bracket,
brackets excluded). In case of <code>setCMethod</code> with signature
<code>list</code> &ndash; a list of such character vectors. </p>
</td></tr>
<tr><td><code id="cfunction_+3A_includes">includes</code></td>
<td>
<p> A character vector of additional includes and preprocessor
statements etc that will be put between the R includes and the user function(s).</p>
</td></tr>
<tr><td><code id="cfunction_+3A_otherdefs">otherdefs</code></td>
<td>
<p> A characted vector with the code for any further definitions of
functions, classes, types, forward declarations, namespace usage clauses etc
which is inserted between the includes and the declarations of the functions
defined in <code>sig</code>.</p>
</td></tr>
<tr><td><code id="cfunction_+3A_language">language</code></td>
<td>
<p> A character value that specifies the source language of the
inline code. The possible values for <code>language</code> include all those
supported by <code>R CMD SHLIB</code> on any platform, which are currently C,
C++, Fortran, F95, ObjectiveC and ObjectiveC++; they may not all be supported
on your platform. One can specify the language either in full as above, or
using any of the following case insensitive shortened forms: <code>c, cpp,
    c++, f, f95, objc, objcpp, objc++</code>. Defaults to <code>C++</code>.</p>
</td></tr>
<tr><td><code id="cfunction_+3A_verbose">verbose</code></td>
<td>
<p> If <code>TRUE</code> prints the compilation output, the source
code of the resulting program and the definitions of all declared
methods. If <code>FALSE</code>, the function is silent, but it prints compiler
warning and error messages and the source code if compilation fails. </p>
</td></tr>
<tr><td><code id="cfunction_+3A_convention">convention</code></td>
<td>
<p> Which calling convention to use?  See the Details section.</p>
</td></tr>
<tr><td><code id="cfunction_+3A_rcpp">Rcpp</code></td>
<td>
<p>If <code>TRUE</code> adds inclusion of <code>Rcpp.h</code> to
<code>includes</code>, also queries the <code>Rcpp</code> package about
the location of header and library files and sets environment
variables <code>PKG_CXXFLAGS</code> and <code>PKG_LIBS</code> accordingly so that
the R / C++ interface provided by the <code>Rcpp</code> package can be
used. Default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cfunction_+3A_cppargs">cppargs</code></td>
<td>
<p>Optional character vector of tokens to be passed to
the compiler via the <code>PKG_CPPFLAGS</code> environment
variable. Elements should be fully formed as for example
<code>c("-I/usr/local/lib/foo", "-DDEBUG")</code> and are passed along verbatim.</p>
</td></tr>
<tr><td><code id="cfunction_+3A_cxxargs">cxxargs</code></td>
<td>
<p>Optional character vector of tokens to be passed to
the compiler via the <code>PKG_CXXFLAGS</code> environment
variable. Elements should be fully formed as for example
<code>c("-I/usr/local/lib/foo", "-DDEBUG")</code> and are passed along verbatim.</p>
</td></tr>
<tr><td><code id="cfunction_+3A_libargs">libargs</code></td>
<td>
<p>Optional character vector of tokens to be passed to the
compiler via the <code>PKG_LIBS</code> environment variable. Elements should
be fully formed as for example <code>c("-L/usr/local/lib/foo -lfoo",
  "--lpthread")</code> and are passed along verbatim.</p>
</td></tr>
<tr><td><code id="cfunction_+3A_dim">dim</code></td>
<td>
<p>Optional character vector defining the dimensionality of the
function arguments. Of same length as <code>sig</code>. Fortran or F95 only.</p>
</td></tr>
<tr><td><code id="cfunction_+3A_implicit">implicit</code></td>
<td>
<p>A character vector defining the implicit declaration in
Fortran or F95; the default is to use the implicit typing rules for Fortran,
which is <code>integer</code> for names starting with the letters <code>I</code> through
<code>N</code>, and <code>real</code> for names beginning with any other letter.
As <code>R</code> passes double precision, this is not the best choice.
Safest is to choose <code>implicit = "none"</code> which will require all names
in the subroutine to be explicitly declared.</p>
</td></tr>
<tr><td><code id="cfunction_+3A_module">module</code></td>
<td>
<p>Name(s) of any modules to be used in the <code>Fortran</code> or
<code>F95</code> subroutine.</p>
</td></tr>
<tr><td><code id="cfunction_+3A_name">name</code></td>
<td>
<p>Function name to be used in the code. Only used if <code>sig</code> is
not a list. This is useful if the DLL created is to be used in conjunction
with the <code>ode</code> function of the <code>deSolve</code> package.
</p>
</td></tr>
<tr><td><code id="cfunction_+3A_...">...</code></td>
<td>
<p> Reserved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To declare multiple functions in the same library one can use <code>setCMethod</code>
supplying lists of signatures and implementations. In this case, provide as
many method names in <code>f</code> as you define methods. Avoid clashes when selecting
names of the methods to declare, i.e. if you provide the same name several times
you must ensure that signatures are different but can share the same generic!
</p>
<p>The source code in the <code>body</code> should not include the header or
&quot;front-matter&quot; of the function or the close, e.g. in C or C++ it
must start after the C-function opening curly bracket and end before
the C-function closing curly bracket, brackets should not be
included. The header will be automatically generated from the R-<code>signature</code>
argument. Arguments will will carry the same name as used in the signature,
so avoid variable names that are not legal in the target language
(e.g. names with dots).
</p>
<p>C/C++: If <code>convention == ".Call"</code> (the default), the <code><a href="base.html#topic+.Call">.Call</a></code> mechanism
is used and its result is returned directly as the result of the call of the
generated function.  As the last line of the generated C/C++ code a
<code>return R_NilValue;</code> is added in this case and a warning is generated
in case the user has forgotten to provide a return value. To suppress the
warning and still return NULL, add <code>return R_NilValue;</code> explicitly.
</p>
<p>Special care is needed with types, memory allocation and protection
&ndash; exactly the same as if the code was not inline: see the
Writing R Extension manual for information on <code><a href="base.html#topic+.Call">.Call</a></code>.
</p>
<p>If <code>convention == ".C"</code> or <code>convention == ".Fortran"</code>, the
<code><a href="base.html#topic+.C">.C</a></code> or <code><a href="base.html#topic+.Fortran">.Fortran</a></code> mechanism respectively is
used, and the return value is a list containing all arguments.
</p>
<p>Attached R includes include <code>R.h</code> for <code>".C"</code>, and
additionally <code>Rdefines.h</code> and <code>R_ext\Error.h</code> for
<code>".Call"</code>.
</p>


<h3>Value</h3>

<p>If <code>sig</code> is a single character vector, <code>cfunction</code> returns a single
<code><a href="base.html#topic+function">function</a></code>; if it is a list, it returns a list of functions.
</p>
<p><code>setCMethod</code> declares new methods with given names and signatures and
returns invisible <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Oleg Sklyar, Duncan Murdoch, Mike Smith, Dirk Eddelbuettel
</p>


<h3>See Also</h3>

 <p><code>
    <a href="base.html#topic+Foreign">Foreign</a> Function Interface
</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- as.numeric(1:10)
n &lt;- as.integer(10)

## Not run: 
## A simple Fortran example - n and x: assumed-size vector
code &lt;- "
      integer i
      do 1 i=1, n(1)
    1 x(i) = x(i)**3
"
cubefn &lt;- cfunction(signature(n="integer", x="numeric"), code, convention=".Fortran")
print(cubefn)

cubefn(n, x)$x

## Same Fortran example - now n is one number
code2 &lt;- "
      integer i
      do 1 i=1, n
    1 x(i) = x(i)**3
"
cubefn2 &lt;- cfunction(signature(n="integer", x="numeric"), implicit = "none",
  dim = c("", "(*)"), code2, convention=".Fortran")

cubefn2(n, x)$x

## Same in F95, now x is fixed-size vector (length = n)
code3 &lt;- "x = x*x*x"
cubefn3 &lt;- cfunction(sig = signature(n="integer", x="numeric"), implicit = "none",
  dim = c("", "(n)"), code3, language="F95")
cubefn3(20, 1:20)
print(cubefn3)

## Same example in C
code4 &lt;- "
      int i;
      for (i = 0; i &lt; *n; i++)
        x[i] = x[i]*x[i]*x[i];
"
cubefn4 &lt;- cfunction(signature(n="integer", x="numeric"), code4, language = "C", convention = ".C")
cubefn4(20, 1:20)

## Give the function in the source code a name
cubefn5 &lt;- cfunction(signature(n="integer", x="numeric"), code4, language = "C", convention = ".C",
  name = "cubefn")
code(cubefn5)

## End(Not run)

 ## use of a module in F95
modct &lt;- "module modcts
double precision, parameter :: pi = 3.14159265358979
double precision, parameter :: e = 2.71828182845905
end"

getconstants &lt;- "x(1) = pi
x(2) = e"

cgetcts &lt;- cfunction(getconstants, module = "modcts", implicit = "none",
  includes = modct, sig = c(x = "double"), dim = c("(2)"), language = "F95")

cgetcts(x = 1:2)
print(cgetcts)

## Use of .C convention with C code
## Defining two functions, one of which calls the other
sigSq &lt;- signature(n="integer", x="numeric")
codeSq &lt;- "
  for (int i=0; i &lt; *n; i++) {
    x[i] = x[i]*x[i];
  }"
sigQd &lt;- signature(n="integer", x="numeric")
codeQd &lt;- "
  squarefn(n, x);
  squarefn(n, x);
"

fns &lt;- cfunction( list(squarefn=sigSq, quadfn=sigQd),
                  list(codeSq, codeQd),
                  convention=".C")

squarefn &lt;- fns[["squarefn"]]
quadfn &lt;- fns[["quadfn"]]

squarefn(n, x)$x
quadfn(n, x)$x

## Alternative declaration using 'setCMethod'
setCMethod(c("squarefn", "quadfn"), list(sigSq, sigQd),
           list(codeSq, codeQd), convention=".C")

squarefn(n, x)$x
quadfn(n, x)$x

## Use of .Call convention with C code
## Multyplying each image in a stack with a 2D Gaussian at a given position
code &lt;- "
  SEXP res;
  int nprotect = 0, nx, ny, nz, x, y;
  PROTECT(res = Rf_duplicate(a)); nprotect++;
  nx = INTEGER(GET_DIM(a))[0];
  ny = INTEGER(GET_DIM(a))[1];
  nz = INTEGER(GET_DIM(a))[2];
  double sigma2 = REAL(s)[0] * REAL(s)[0], d2 ;
  double cx = REAL(centre)[0], cy = REAL(centre)[1], *data, *rdata;
  for (int im = 0; im &lt; nz; im++) {
    data = &amp;(REAL(a)[im*nx*ny]); rdata = &amp;(REAL(res)[im*nx*ny]);
    for (x = 0; x &lt; nx; x++)
      for (y = 0; y &lt; ny; y++) {
        d2 = (x-cx)*(x-cx) + (y-cy)*(y-cy);
        rdata[x + y*nx] = data[x + y*nx] * exp(-d2/sigma2);
      }
  }
  UNPROTECT(nprotect);
  return res;
"
funx &lt;- cfunction(signature(a="array", s="numeric", centre="numeric"), code)

x &lt;- array(runif(50*50), c(50,50,1))
res &lt;- funx(a=x, s=10, centre=c(25,15))
if (interactive()) image(res[,,1])

## Same but done by registering an S4 method
setCMethod("funy", signature(a="array", s="numeric", centre="numeric"), code, verbose=TRUE)

res &lt;- funy(x, 10, c(35,35))
if (interactive()) { x11(); image(res[,,1]) }

</code></pre>

<hr>
<h2 id='cxxfunction'>inline C++ function</h2><span id='topic+cxxfunction'></span><span id='topic+rcpp'></span>

<h3>Description</h3>

<p>Functionality to dynamically define an R function with inlined C++ code
using the <code><a href="base.html#topic+.Call">.Call</a></code> calling convention.
</p>
<p>The <code>rcpp()</code> wrapper sets the plugin to the &ldquo;Rcpp&rdquo; value
suitable for using <span class="pkg">Rcpp</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cxxfunction(sig = character(), body = character(), 
            plugin = "default", includes = "", 
            settings = getPlugin(plugin), ..., verbose = FALSE)
rcpp(..., plugin="Rcpp")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cxxfunction_+3A_sig">sig</code></td>
<td>
<p>Signature of the function. A named character vector</p>
</td></tr>
<tr><td><code id="cxxfunction_+3A_body">body</code></td>
<td>
<p>A character vector with C++ code to include in the body of the compiled C++ function</p>
</td></tr>
<tr><td><code id="cxxfunction_+3A_plugin">plugin</code></td>
<td>
<p>Name of the plugin to use. See <code><a href="#topic+getPlugin">getPlugin</a></code> for details about plugins. </p>
</td></tr>
<tr><td><code id="cxxfunction_+3A_includes">includes</code></td>
<td>
<p>User includes, inserted after the includes provided by the plugin. </p>
</td></tr>
<tr><td><code id="cxxfunction_+3A_settings">settings</code></td>
<td>
<p>Result of the call to the plugin</p>
</td></tr>
<tr><td><code id="cxxfunction_+3A_...">...</code></td>
<td>
<p>Further arguments to the plugin</p>
</td></tr>
<tr><td><code id="cxxfunction_+3A_verbose">verbose</code></td>
<td>
<p>verbose output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function</p>


<h3>See Also</h3>

<p><code><a href="#topic+cfunction">cfunction</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# default plugin
fx &lt;- cxxfunction(signature(x = "integer", y = "numeric"), 
	          "return ScalarReal(INTEGER(x)[0] * REAL(y)[0]);")
fx(2L, 5)

# Rcpp plugin
if (requireNamespace("Rcpp", quietly=TRUE)) {

    fx &lt;- cxxfunction(signature(x = "integer", y = "numeric"), 
                      "return wrap( as&lt;int&gt;(x) * as&lt;double&gt;(y));",
                      plugin = "Rcpp" )
    fx(2L, 5)

    ## equivalent shorter form using rcpp()
    fx &lt;- rcpp(signature(x = "integer", y = "numeric"),
               "return wrap(as&lt;int&gt;(x) * as&lt;double&gt;(y));")
}

# RcppArmadillo plugin
if (requireNamespace(RcppArmadillo)) {
	
    fx &lt;- cxxfunction(signature(x = "integer", y = "numeric"),
                      "int dim = as&lt;int&gt;(x);
		       arma::mat z = as&lt;double&gt;(y) * arma::eye&lt;arma::mat&gt;(dim, dim);
		       return wrap(arma::accu(z));",
                      plugin = "RcppArmadillo")
    fx(2L, 5)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='getDynLib-methods'>Retrieve the dynamic library (or DLL) associated with a package of 
a function generated by cfunction</h2><span id='topic+getDynLib'></span><span id='topic+getDynLib-methods'></span><span id='topic+getDynLib+2CCFunc-method'></span><span id='topic+getDynLib+2Ccharacter-method'></span><span id='topic+getDynLib+2CCFuncList-method'></span>

<h3>Description</h3>

<p>The <code>getDynLib</code> function retrieves the dynamic library (or DLL) 
associated with a package or with a function generated by 
<code><a href="#topic+cfunction">cfunction</a></code>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "CFunc")</code></dt><dd><p>Retrieves the dynamic 
library associated with the function generated by <code><a href="#topic+cfunction">cfunction</a></code>. 
The library is dynamically loaded if necessary. </p>
</dd>
<dt><code>signature(x = "CFuncList")</code></dt><dd><p>Retrieves the dynamic 
library associated with a set of functions generated by <code><a href="#topic+cfunction">cfunction</a></code>. 
The library is dynamically loaded if necessary. </p>
</dd>
<dt><code>signature(x = "character")</code></dt><dd>
<p>Retrieves the dynamic library of the given name. This typically refers 
to package names, but can be any name of the list returned by 
<code><a href="base.html#topic+getLoadedDLLs">getLoadedDLLs</a></code>
</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="base.html#topic+getLoadedDLLs">getLoadedDLLs</a></code>, <code><a href="base.html#topic+dyn.load">dyn.load</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
getDynLib( "base" )

f &lt;- cfunction( signature() , "return R_NilValue ;" )
getDynLib( f )


## End(Not run)</code></pre>

<hr>
<h2 id='inline-package'>Functions to Inline C, C++, Fortran Function Calls from R</h2><span id='topic+inline-package'></span><span id='topic+inline'></span>

<h3>Description</h3>

<p>Functionality to dynamically define R functions and S4 methods
 with 'inlined' C, C++ or Fortran code supporting the .C and .Call calling
 conventions.</p>


<h3>Maintainer</h3>

<p>Dirk Eddelbuettel &lt;edd@debian.org&gt;</p>


<h3>Author(s)</h3>

<p>Oleg Sklyar, Duncan Murdoch, Mike Smith, Dirk Eddelbuettel, 
 Romain Francois, Karline Soetaert, Johannes Ranke</p>


<h3>See Also</h3>

<p><code><a href="#topic+cfunction">cfunction</a></code>, <code><a href="#topic+cxxfunction">cxxfunction</a></code></p>

<hr>
<h2 id='internals'> Internals </h2><span id='topic+internals'></span><span id='topic+setCMethod+2Ccharacter+2Clist+2Clist-method'></span><span id='topic+setCMethod+2Ccharacter+2Ccharacter+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Aliases required for 'R CMD check' but those no-one will ever search for.
Here to prevent the mess of the index. The corresponding items have help
aliases without method signature!
</p>

<hr>
<h2 id='package.skeleton-methods'>Generate the skeleton of a package</h2><span id='topic+package.skeleton-methods'></span><span id='topic+package.skeleton+2CANY+2CANY-method'></span><span id='topic+package.skeleton+2Ccharacter+2CCFunc-method'></span><span id='topic+package.skeleton+2Ccharacter+2CCFuncList-method'></span>

<h3>Description</h3>

<p>Generate the skeleton of a package
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(name = "ANY", list = "ANY")</code></dt><dd>
<p>Standard method. See <code><a href="utils.html#topic+package.skeleton">package.skeleton</a></code>
</p>
</dd>
<dt><code>signature(name = "character", list = "CFunc")</code></dt><dd>
<p>Method for a single generated by <code><a href="#topic+cfunction">cfunction</a></code>
or <code><a href="#topic+cxxfunction">cxxfunction</a></code>
</p>
</dd>
<dt><code>signature(name = "character", list = "CFuncList")</code></dt><dd>
<p>Method for a set functions generated by <code><a href="#topic+cfunction">cfunction</a></code>
or <code><a href="#topic+cxxfunction">cxxfunction</a></code>
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

fx &lt;- cxxfunction(signature(x = "integer", y = "numeric"),
	          "return ScalarReal( INTEGER(x)[0] * REAL(y)[0]);")
package.skeleton("foo", fx)

functions &lt;- cxxfunction(list(ff = signature(), 
                              gg = signature(x = "integer", y = "numeric")), 
                         c("return R_NilValue ;",
                           "return ScalarReal(INTEGER(x)[0] * REAL(y)[0]);"))
package.skeleton("foobar", functions)


## End(Not run)
</code></pre>

<hr>
<h2 id='plugins'>
Plugin system for cxxfunction
</h2><span id='topic+getPlugin'></span><span id='topic+registerPlugin'></span>

<h3>Description</h3>

<p><code><a href="#topic+cxxfunction">cxxfunction</a></code> uses a plugin system to assembly the 
code that it compiles. These functions allow to register and get 
plugins by their name. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPlugin(name, ...)
registerPlugin(name, plugin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plugins_+3A_name">name</code></td>
<td>
<p>name of the plugin. </p>
</td></tr>
<tr><td><code id="plugins_+3A_...">...</code></td>
<td>
<p>Further argments to pass to the plugin. </p>
</td></tr>
<tr><td><code id="plugins_+3A_plugin">plugin</code></td>
<td>
<p>plugin function. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>plugins are functions that return a list with : 
</p>

<dl>
<dt>includes</dt><dd><p>mandatory. it is included at the top of the compiled file by <code><a href="#topic+cxxfunction">cxxfunction</a></code> </p>
</dd>
<dt>body</dt><dd><p>optional. a function that takes one argument (the body of the c++ function) and returned
a modified version of the body. The &quot;Rcpp&quot; plugin uses this to surround the code with the 
<code>BEGIN_RCPP</code> and <code>END_RCPP</code> macros
</p>
</dd>	
<dt>LinkingTo</dt><dd><p>optional. character vector containing the list of packages
that the code needs to link to. This adds the include path of the given 
packages. The &quot;Rcpp&quot; and &quot;RcppArmadillo&quot; plugins use this.
</p>
</dd>
<dt>env</dt><dd><p>optional. named list of environment variables. For example, the &quot;Rcpp&quot; 
plugin uses this to add Rcpp user library to the <code>PKG_LIBS</code> environment
variable.
</p>
</dd>
</dl>

<p>plugins can be manually registered using the <code>registerPlugin</code>
function. Alternatively, a package may supply an inline plugin 
implicitely by defining a function called <code>inlineCxxPlugin</code>, which 
does not necessarily need to be exported from the namespace of the package.
</p>
<p>Known packages implementing this scheme include <code>Rcpp</code> and 
<code>RcppArmadillo</code>. 
</p>


<h3>Value</h3>

<p><code>getPlugin</code> retrieves the plugin and invokes it with the
... arguments
</p>
<p><code>registerPlugin</code> does not return anything.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cxxfunction">cxxfunction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
getPlugin( "Rcpp" )

## End(Not run)
</code></pre>

<hr>
<h2 id='utilities'> Printing, reading and writing compiled function objects </h2><span id='topic+utilities'></span><span id='topic+moveDLL'></span><span id='topic+moveDLL-methods'></span><span id='topic+moveDLL+2CCFunc-method'></span><span id='topic+writeCFunc'></span><span id='topic+readCFunc'></span><span id='topic+print+2CCFunc-method'></span><span id='topic+print+2CCFuncList-method'></span><span id='topic+code'></span><span id='topic+code-methods'></span><span id='topic+code+2Ccharacter-method'></span><span id='topic+code+2CCFunc-method'></span><span id='topic+code+2CCFuncList-method'></span>

<h3>Description</h3>

<p><code>moveDLL</code> moves the DLL used by a compiled function to a user defined
location.
</p>
<p><code>writeCFunc</code> saves a <code>CFunc</code> object after the DLL has been moved to
the desired location using <code>moveDLL</code>.
</p>
<p><code>readCFunc</code> reads a <code>CFunc</code> object that has been saved using
<code>writeCFunc</code>.
</p>
<p>The <code>print</code> and <code>code</code> methods respectively print the entire
object or only the code parts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moveDLL(x, ...)
## S4 method for signature 'CFunc'
moveDLL(x, name, directory, unload = FALSE, overwrite = FALSE, verbose = FALSE)

writeCFunc(x, file)
readCFunc(file)

## S4 method for signature 'CFunc'
print(x)
## S4 method for signature 'CFuncList'
print(x)

## S4 method for signature 'CFunc'
code(x, linenumbers = TRUE)
## S4 method for signature 'CFuncList'
code(x, linenumbers = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utilities_+3A_x">x</code></td>
<td>
<p>A <code>CFunc</code> or <code>CFuncList</code> object as created by <code><a href="#topic+cfunction">cfunction</a></code></p>
</td></tr>
<tr><td><code id="utilities_+3A_name">name</code></td>
<td>
<p>The base of the file name that the DLL should be moved to. The file name
extension will depend on the operating system used</p>
</td></tr>
<tr><td><code id="utilities_+3A_directory">directory</code></td>
<td>
<p>The directory that the DLL should be written to</p>
</td></tr>
<tr><td><code id="utilities_+3A_unload">unload</code></td>
<td>
<p>In case the new path constructed from <code>name</code> and
<code>directory</code> points to a loaded DLL, should we unload it?</p>
</td></tr>
<tr><td><code id="utilities_+3A_overwrite">overwrite</code></td>
<td>
<p>In case there is a file at the new path constructed from
<code>name</code> and <code>directory</code> should we overwrite that file?</p>
</td></tr>
<tr><td><code id="utilities_+3A_verbose">verbose</code></td>
<td>
<p>Should we print a message stating where the DLL was copied
if the operation was successful?</p>
</td></tr>
<tr><td><code id="utilities_+3A_file">file</code></td>
<td>
<p>The file path for writing and reading the object generated by
<code><a href="#topic+cfunction">cfunction</a></code>. Consider using a file name extension like
<code>.rda</code> or <code>.RData</code> to indicate that this is a serialized
R object.
</p>
</td></tr>
<tr><td><code id="utilities_+3A_linenumbers">linenumbers</code></td>
<td>
<p>If <code>TRUE</code> all code lines will be numbered.</p>
</td></tr>
<tr><td><code id="utilities_+3A_...">...</code></td>
<td>
<p>May be used in future methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you move the DLL to a user defined location with <code>moveDLL</code>, this will
keep an on-disk copy of the DLL which will prevent it from being lost at
session termination - unless written to the session <code><a href="base.html#topic+tempdir">tempdir</a></code>.
Saving and reloading the <code>CFunc</code> object with standard tools like
<code><a href="base.html#topic+save">save</a></code> or <code><a href="base.html#topic+saveRDS">saveRDS</a></code> will still loose the pointer to
the DLL. However, when the DLL has been moved using <code>moveDLL</code>,
<code>CFunc</code> objects can be saved by <code>writeCFunc</code> and restored by
<code>readCFunc</code>.
</p>


<h3>Value</h3>

<p>Function <code>readDynLib</code> returns a <code>CFunc</code> object.
</p>
<p>Function <code>writeDynLib</code> returns the name of the <code>.CFunc</code> file that
was created.
</p>


<h3>Note</h3>


<ul>
<li><p> The code of a <code>CFunc</code> or <code>CFuncList</code> object <code>x</code> can be extracted
(rather than printed), using:
</p>
<p><code>x@code</code>.
</p>
</li>
<li><p> To write the code to a file (here called <code>"fn"</code>), without the
new-line character <code>"\n"</code>:
</p>
<p><code>write (strsplit(x, "\n")[[1]], file = "fn")</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Karline Soetaert and Johannes Ranke
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getDynLib">getDynLib</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- as.numeric(1:10)
n &lt;- as.integer(10)

code &lt;- "
      integer i
      do 1 i=1, n(1)
    1 x(i) = x(i)**3
"
cubefn &lt;- cfunction(signature(n="integer", x="numeric"), code,
  convention=".Fortran")
code(cubefn)

cubefn(n, x)$x

## Not run: 
# The following code is exempted from the automated tests of example code, as
# it writes to the users home directory.
# The following writes the DLL, e.g. cubefn.so on Linux/Unix or cubefn.dll
# on Windows
moveDLL(cubefn, name = "cubefn", directory = "~")
path &lt;- file.path("~", "cubefn.rda")
writeCFunc(cubefn, path)
rm(cubefn)

# Now you can start a fresh R session and load the function
library(inline)
path &lt;- file.path("~", "cubefn.rda")
cfn &lt;- readCFunc(path)
cfn(3, 1:3)$x

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
