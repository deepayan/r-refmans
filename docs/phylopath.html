<!DOCTYPE html><html><head><title>Help for package phylopath</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {phylopath}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#average'><p>Extract and average the best supported models from a phylogenetic path</p>
analysis.</a></li>
<li><a href='#average_DAGs'><p>Perform model averaging on a list of DAGs.</p></a></li>
<li><a href='#best'><p>Extract and estimate the best supported model from a phylogenetic path</p>
analysis.</a></li>
<li><a href='#choice'><p>Extract and estimate an arbitrary model from a phylogenetic path analysis.</p></a></li>
<li><a href='#cichlids'><p>Cichlid traits and the evolution of cooperative breeding.</p></a></li>
<li><a href='#cichlids_tree'><p>Cichlid phylogeny.</p></a></li>
<li><a href='#coef_plot'><p>Plot path coefficients and their confidence intervals or standard errors.</p></a></li>
<li><a href='#DAG'><p>Directed acyclic graphs (DAGs)</p></a></li>
<li><a href='#define_model_set'><p>Define a model set.</p></a></li>
<li><a href='#est_DAG'><p>Add standardized path coefficients to a DAG.</p></a></li>
<li><a href='#phylo_path'><p>Compare causal models in a phylogenetic context.</p></a></li>
<li><a href='#plot_model_set'><p>Plot several causal hypothesis at once.</p></a></li>
<li><a href='#plot.DAG'><p>Plot a directed acyclic graph.</p></a></li>
<li><a href='#plot.fitted_DAG'><p>Plot a directed acyclic graph with path coefficients.</p></a></li>
<li><a href='#red_list'><p>Data on brain size, life history and vulnerability to extinction</p></a></li>
<li><a href='#red_list_tree'><p>Mammalian phylogeny</p></a></li>
<li><a href='#rhino'><p>Rhinogrades traits.</p></a></li>
<li><a href='#rhino_tree'><p>Rhinogrades phylogeny.</p></a></li>
<li><a href='#show_warnings'><p>Print out warnings from a phylopath analysis.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Perform Phylogenetic Path Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wouter van der Bijl &lt;wouter@zoology.ubc.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A comprehensive and easy to use R implementation of confirmatory
    phylogenetic path analysis as described by Von Hardenberg and Gonzalez-Voyer
    (2012) &lt;<a href="https://doi.org/10.1111%2Fj.1558-5646.2012.01790.x">doi:10.1111/j.1558-5646.2012.01790.x</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://Ax3man.github.io/phylopath/">https://Ax3man.github.io/phylopath/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Ax3man/phylopath/issues">https://github.com/Ax3man/phylopath/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape (&ge; 4.1), future.apply, ggm (&ge; 2.3), ggplot2 (&ge; 3.0.0),
ggraph (&ge; 1.0.0), igraph (&ge; 1.0.1), phylolm (&ge; 2.5), purrr
(&ge; 0.2.3), tibble</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-11 22:10:44 UTC; wouter</td>
</tr>
<tr>
<td>Author:</td>
<td>Wouter van der Bijl [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-11 23:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='average'>Extract and average the best supported models from a phylogenetic path
analysis.</h2><span id='topic+average'></span>

<h3>Description</h3>

<p>Extract and average the best supported models from a phylogenetic path
analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average(phylopath, cut_off = 2, avg_method = "conditional", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="average_+3A_phylopath">phylopath</code></td>
<td>
<p>An object of class <code>phylopath</code>.</p>
</td></tr>
<tr><td><code id="average_+3A_cut_off">cut_off</code></td>
<td>
<p>The CICc cut-off used to select the best models. Use
<code>Inf</code> to average over all models. Use the <code><a href="#topic+best">best()</a></code> function to
only use the top model, or <code><a href="#topic+choice">choice()</a></code> to select any single model.</p>
</td></tr>
<tr><td><code id="average_+3A_avg_method">avg_method</code></td>
<td>
<p>Either <code>"full"</code> or <code>"conditional"</code>. The methods
differ in how they deal with averaging a path coefficient where the path is
absent in some of the models. The full method sets the coefficient (and the
variance) for the missing paths to zero, meaning paths that are missing in
some models will shrink towards zero. The conditional method only averages
over models where the path appears, making it more sensitive to small
effects. Following von Hardenberg &amp; Gonzalez-Voyer 2013, conditional
averaging is set as the default.</p>
</td></tr>
<tr><td><code id="average_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <a href="phylolm.html#topic+phylolm">phylolm::phylolm</a> and <a href="phylolm.html#topic+phyloglm">phylolm::phyloglm</a>. Provide <code>boot = K</code>
parameter to enable bootstrapping, where <code>K</code> is the number of bootstrap replicates. If you
specified other options in the original <a href="#topic+phylo_path">phylo_path</a> call you don't need to specify them again.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>fitted_DAG</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  candidates &lt;- define_model_set(
    A = NL ~ RS,
    B = RS ~ NL + BM,
    .common = c(LS ~ BM, DD ~ NL, NL ~ BM)
  )
  p &lt;- phylo_path(candidates, rhino, rhino_tree)
  summary(p)

  # Models A and B have similar support, so we may decide to take
  # their average.

  avg_model &lt;- average(p)
  # Print the average model to see coefficients, se and ci:
  avg_model

  ## Not run: 
  # Plot to show the weighted graph:
  plot(avg_model)

  # One can see that an averaged model is not necessarily a DAG itself.
  # This model actually has a path in two directions.

  # Note that coefficients that only occur in one of the models become much
  # smaller when we use full averaging:

  coef_plot(avg_model)
  coef_plot(average(p, method = 'full'))
  
## End(Not run)

</code></pre>

<hr>
<h2 id='average_DAGs'>Perform model averaging on a list of DAGs.</h2><span id='topic+average_DAGs'></span>

<h3>Description</h3>

<p>Perform model averaging on a list of DAGs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average_DAGs(
  fitted_DAGs,
  weights = rep(1, length(coef)),
  avg_method = "conditional",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="average_DAGs_+3A_fitted_dags">fitted_DAGs</code></td>
<td>
<p>A list of <code>fitted_DAG</code> objects containing
coefficients and standard errors, usually obtained by using <code><a href="#topic+est_DAG">est_DAG()</a></code>
on several DAGs.</p>
</td></tr>
<tr><td><code id="average_DAGs_+3A_weights">weights</code></td>
<td>
<p>A vector of associated model weights.</p>
</td></tr>
<tr><td><code id="average_DAGs_+3A_avg_method">avg_method</code></td>
<td>
<p>Either <code>"full"</code> or <code>"conditional"</code>. The methods
differ in how they deal with averaging a path coefficient where the path is
absent in some of the models. The full method sets the coefficient (and the
variance) for the missing paths to zero, meaning paths that are missing in
some models will shrink towards zero. The conditional method only averages
over models where the path appears, making it more sensitive to small
effects. Following von Hardenberg &amp; Gonzalez-Voyer 2013, conditional
averaging is set as the default.</p>
</td></tr>
<tr><td><code id="average_DAGs_+3A_...">...</code></td>
<td>
<p>Use of the ellipses is deprecated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>fitted_DAG</code>, including standard errors and
confidence intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Normally, I would advocate the use of the phylo_path and average
  # functions, but this code shows how to average any set of models. Note
  # that not many checks are implemented, so you may want to be careful and
  # make sure the DAGs make sense and contain the same variables!
  candidates &lt;- define_model_set(
    A = NL ~ BM,
    B = NL ~ LS,
    .common = c(LS ~ BM, DD ~ NL)
  )
  fit_cand &lt;- lapply(candidates, est_DAG, rhino, rhino_tree,
                     model = 'lambda', method = 'logistic_MPLE')
  ave_cand &lt;- average_DAGs(fit_cand)
  coef_plot(ave_cand)
</code></pre>

<hr>
<h2 id='best'>Extract and estimate the best supported model from a phylogenetic path
analysis.</h2><span id='topic+best'></span>

<h3>Description</h3>

<p>Extract and estimate the best supported model from a phylogenetic path
analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best(phylopath, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="best_+3A_phylopath">phylopath</code></td>
<td>
<p>An object of class <code>phylopath</code>.</p>
</td></tr>
<tr><td><code id="best_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <a href="phylolm.html#topic+phylolm">phylolm::phylolm</a> and <a href="phylolm.html#topic+phyloglm">phylolm::phyloglm</a>. Provide <code>boot = K</code>
parameter to enable bootstrapping, where <code>K</code> is the number of bootstrap replicates. If you
specified other options in the original <a href="#topic+phylo_path">phylo_path</a> call you don't need to specify them again.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>fitted_DAG</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  candidates &lt;- define_model_set(
    A = NL ~ BM,
    B = NL ~ LS,
    .common = c(LS ~ BM, DD ~ NL)
  )
  p &lt;- phylo_path(candidates, rhino, rhino_tree)
  best_model &lt;- best(p)
  # Print the best model to see coefficients, se and ci:
  best_model
  # Plot to show the weighted graph:
  plot(best_model)

</code></pre>

<hr>
<h2 id='choice'>Extract and estimate an arbitrary model from a phylogenetic path analysis.</h2><span id='topic+choice'></span>

<h3>Description</h3>

<p>Extract and estimate an arbitrary model from a phylogenetic path analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choice(phylopath, choice, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="choice_+3A_phylopath">phylopath</code></td>
<td>
<p>An object of class <code>phylopath</code>.</p>
</td></tr>
<tr><td><code id="choice_+3A_choice">choice</code></td>
<td>
<p>A character string of the name of the model to be chosen, or
the index in <code>model_set</code>.</p>
</td></tr>
<tr><td><code id="choice_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <a href="phylolm.html#topic+phylolm">phylolm::phylolm</a> and <a href="phylolm.html#topic+phyloglm">phylolm::phyloglm</a>. Provide <code>boot = K</code>
parameter to enable bootstrapping, where <code>K</code> is the number of bootstrap replicates. If you
specified other options in the original <a href="#topic+phylo_path">phylo_path</a> call you don't need to specify them again.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>fitted_DAG</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  candidates &lt;- define_model_set(
    A = NL ~ BM,
    B = NL ~ LS,
    .common = c(LS ~ BM, DD ~ NL)
  )
  p &lt;- phylo_path(candidates, rhino, rhino_tree)
  my_model &lt;- choice(p, "B")
  # Print the best model to see coefficients, se and ci:
  my_model
  # Plot to show the weighted graph:
  plot(my_model)

</code></pre>

<hr>
<h2 id='cichlids'>Cichlid traits and the evolution of cooperative breeding.</h2><span id='topic+cichlids'></span>

<h3>Description</h3>

<p>A data set with binary traits, used in an analysis on the evolution of
cooperative breeding by Dey et al 2017. Variable names are shortened for
easy of use and consist of cooperative breeding (C), mating system (M),
parental care (P), social grouping (G) and diet (D). All traits are coded as
two level factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cichlids
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 69 rows and 5 columns.
</p>


<h3>Source</h3>

<p>Dey, C.J., O'Connor, C.M., Wilkinson, H., Shultz, S., Balshine, S. &amp;
Fitzpatrick, J.L. 2017. Direct benefits and evolutionary transitions to
complex societies. Nat Ecol Evol 1: 137.
</p>

<hr>
<h2 id='cichlids_tree'>Cichlid phylogeny.</h2><span id='topic+cichlids_tree'></span>

<h3>Description</h3>

<p>The phylogenetic tree of cichlid species that accompanies the <code>cichlids</code>
dataset. The phylogeny is based on five nuclear genes and three
mitochondrial genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cichlids_tree
</code></pre>


<h3>Format</h3>

<p>An object of class <code>phylo</code> of length 4.
</p>


<h3>Source</h3>

<p>Dey, C.J., O'Connor, C.M., Wilkinson, H., Shultz, S., Balshine, S. &amp;
Fitzpatrick, J.L. 2017. Direct benefits and evolutionary transitions to
complex societies. Nat Ecol Evol 1: 137.
</p>

<hr>
<h2 id='coef_plot'>Plot path coefficients and their confidence intervals or standard errors.</h2><span id='topic+coef_plot'></span>

<h3>Description</h3>

<p>Plot path coefficients and their confidence intervals or standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coef_plot(
  fitted_DAG,
  error_bar = "ci",
  order_by = "default",
  from = NULL,
  to = NULL,
  reverse_order = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef_plot_+3A_fitted_dag">fitted_DAG</code></td>
<td>
<p>A fitted DAG, usually obtained by <code><a href="#topic+best">best()</a></code>, <code><a href="#topic+average">average()</a></code> or <code><a href="#topic+est_DAG">est_DAG()</a></code>.</p>
</td></tr>
<tr><td><code id="coef_plot_+3A_error_bar">error_bar</code></td>
<td>
<p>Whether to use confidence intervals (<code>"ci"</code>) or standard errors (<code>"se"</code>) as
error bars. Will force standard errors with a message if confidence intervals are not
available.</p>
</td></tr>
<tr><td><code id="coef_plot_+3A_order_by">order_by</code></td>
<td>
<p>By <code>"default"</code>, the paths are ordered as in the the model that is supplied.
Usually this is in the order that was established by <code style="white-space: pre;">&#8288;[phylo_path()]&#8288;</code> for all combined graphs.
This can be change to <code>"causal"</code> to do a reordering based on the model at hand, or to
<code>"strength"</code> to order them by the standardized regression coefficient.</p>
</td></tr>
<tr><td><code id="coef_plot_+3A_from">from</code></td>
<td>
<p>Only show path coefficients from these nodes. Supply as a character vector.</p>
</td></tr>
<tr><td><code id="coef_plot_+3A_to">to</code></td>
<td>
<p>Only show path coefficients to these nodes. Supply as a character vector.</p>
</td></tr>
<tr><td><code id="coef_plot_+3A_reverse_order">reverse_order</code></td>
<td>
<p>If <code>TRUE</code>, the paths are plotted in reverse order.
Particularly useful in combination with <code><a href="ggplot2.html#topic+coord_flip">ggplot2::coord_flip()</a></code> to create
horizontal versions of the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  d &lt;- DAG(LS ~ BM, NL ~ BM, DD ~ NL + LS)
  plot(d)
  d_fitted &lt;- est_DAG(d, rhino, rhino_tree, 'lambda')
  plot(d_fitted)
  coef_plot(d_fitted, error_bar = "se")
  # to create a horizontal version, use this:
  coef_plot(d_fitted, error_bar = "se", reverse_order = TRUE) + ggplot2::coord_flip()
</code></pre>

<hr>
<h2 id='DAG'>Directed acyclic graphs (DAGs)</h2><span id='topic+DAG'></span>

<h3>Description</h3>

<p>This function is a simple wrapper around the function from the <code>ggm</code>
package with the same name. The only differences are that the <code>order</code>
argument defaults to <code>TRUE</code> and that it adds a <code>DAG</code> class for
easy plotting. Typically, one would use <code><a href="#topic+define_model_set">define_model_set()</a></code> to
create models for use with the <code>phylopath</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DAG(..., order = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DAG_+3A_...">...</code></td>
<td>
<p>a sequence of model formulae</p>
</td></tr>
<tr><td><code id="DAG_+3A_order">order</code></td>
<td>
<p>logical, defaulting to <code>TRUE</code>. If <code>TRUE</code> the nodes of the DAG
are permuted according to the topological order. If <code>FALSE</code> the nodes are
in the order they first appear in the model formulae (from left to right).
For use in the <code>phylopath</code> package, this should always be kept to <code>TRUE</code>,
but the argument is available to avoid potential problems with masking the
function from other packages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Supply a formulas for the model as arguments. Formulas should be of the
form <code style="white-space: pre;">&#8288;child ~ parent`` and describe each path in your model. Multiple children of a single parent can be combined into a single formula: &#8288;</code>child ~ parent1 + parent2<code style="white-space: pre;">&#8288;. Finally, an isolate (unconnected variable) can be included as being connected to itself: &#8288;</code>isolate ~ isolate'.
</p>


<h3>Value</h3>

<p>An object of classes <code>matrix</code> and <code>DAG</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Use formula notation to create DAGs:
  plot(DAG(A~B, B~C))
  # Use + to easily add multiple parents to a node:
  plot(DAG(A~B+C))
  # Add a node as it's own parent to create an isolate:
  plot(DAG(A~B+C, D~D))
</code></pre>

<hr>
<h2 id='define_model_set'>Define a model set.</h2><span id='topic+define_model_set'></span>

<h3>Description</h3>

<p>This is a convenience function to quickly and clearly define a set of causal
models. Supply a list of formulas for each model, using either <code>c()</code>. Formulas
should be of the form <code>child ~ parent</code> and describe each path in your model.
Multiple children of a single parent can be combined into a single formula:
<code>child ~ parent1 + parent2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_model_set(..., .common = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_model_set_+3A_...">...</code></td>
<td>
<p>Named arguments, which each are a lists of formulas defining the
paths of a causal model.</p>
</td></tr>
<tr><td><code id="define_model_set_+3A_.common">.common</code></td>
<td>
<p>A list of formulas that contain causal paths that are common
to each model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses <code><a href="ggm.html#topic+DAG">ggm::DAG()</a></code>.
</p>


<h3>Value</h3>

<p>A list of models, each of class <code>matrix</code> and <code>DAG</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(m &lt;- define_model_set(
  A = c(a~b, b~c),
  B = c(b~a, c~b),
  .common = c(d~a)))
plot_model_set(m)
</code></pre>

<hr>
<h2 id='est_DAG'>Add standardized path coefficients to a DAG.</h2><span id='topic+est_DAG'></span>

<h3>Description</h3>

<p>Add standardized path coefficients to a DAG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_DAG(DAG, data, tree, model, method, boot = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est_DAG_+3A_dag">DAG</code></td>
<td>
<p>A directed acyclic graph, typically created with <code>DAG</code>.</p>
</td></tr>
<tr><td><code id="est_DAG_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> with data. If you have binary variables, make
sure they are either character values or factors!</p>
</td></tr>
<tr><td><code id="est_DAG_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree of class <code>phylo</code>.</p>
</td></tr>
<tr><td><code id="est_DAG_+3A_model">model</code></td>
<td>
<p>The evolutionary model used for the regressions on continuous
variables. See <a href="phylolm.html#topic+phylolm">phylolm::phylolm</a> for options and details. Defaults to
Pagel's lambda model</p>
</td></tr>
<tr><td><code id="est_DAG_+3A_method">method</code></td>
<td>
<p>The estimation method for the binary models. See
<a href="phylolm.html#topic+phyloglm">phylolm::phyloglm</a> for options and details. Defaults to logistic MPLE.</p>
</td></tr>
<tr><td><code id="est_DAG_+3A_boot">boot</code></td>
<td>
<p>The number of bootstrap replicates used to estimate confidence intervals.</p>
</td></tr>
<tr><td><code id="est_DAG_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>phylolm</code>:
</p>
<p><code>lower.bound</code>: optional lower bound for the optimization of the phylogenetic model parameter.
</p>
<p><code>upper.bound</code>: optional upper bound for the optimization of the phylogenetic model parameter.
</p>
<p><code>starting.value</code>: optional starting value for the optimization of the phylogenetic model parameter.
</p>
<p><code>measurement_error</code>: a logical value indicating whether there is measurement error sigma2_error (see Details).
</p>
<p>Arguments passed on to <code>phyloglm</code>:
</p>
<p><code>btol</code>: bound on the linear predictor to bound the searching space.
</p>
<p><code>log.alpha.bound</code>: bound for the log of the parameter alpha.
</p>
<p><code>start.beta</code>: starting values for beta coefficients.
</p>
<p><code>start.alpha</code>: starting values for alpha (phylogenetic correlation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>fitted_DAG</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  d &lt;- DAG(LS ~ BM, NL ~ BM, DD ~ NL + LS)
  plot(d)
  d_fitted &lt;- est_DAG(d, rhino, rhino_tree, 'lambda')
  plot(d_fitted)
</code></pre>

<hr>
<h2 id='phylo_path'>Compare causal models in a phylogenetic context.</h2><span id='topic+phylo_path'></span>

<h3>Description</h3>

<p>Continuous variables are modeled using <a href="phylolm.html#topic+phylolm">phylolm::phylolm</a>, while binary
traits are modeled using <a href="phylolm.html#topic+phyloglm">phylolm::phyloglm</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylo_path(
  model_set,
  data,
  tree,
  model = "lambda",
  method = "logistic_MPLE",
  order = NULL,
  parallel = NULL,
  na.rm = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylo_path_+3A_model_set">model_set</code></td>
<td>
<p>A list of directed acyclic graphs. These are matrices,
typically created with <code>define_model_set</code>.</p>
</td></tr>
<tr><td><code id="phylo_path_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> with data. If you have binary variables, make
sure they are either character values or factors!</p>
</td></tr>
<tr><td><code id="phylo_path_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree of class <code>phylo</code>.</p>
</td></tr>
<tr><td><code id="phylo_path_+3A_model">model</code></td>
<td>
<p>The evolutionary model used for the regressions on continuous
variables. See <a href="phylolm.html#topic+phylolm">phylolm::phylolm</a> for options and details. Defaults to
Pagel's lambda model</p>
</td></tr>
<tr><td><code id="phylo_path_+3A_method">method</code></td>
<td>
<p>The estimation method for the binary models. See
<a href="phylolm.html#topic+phyloglm">phylolm::phyloglm</a> for options and details. Defaults to logistic MPLE.</p>
</td></tr>
<tr><td><code id="phylo_path_+3A_order">order</code></td>
<td>
<p>Causal order of the included variable, given as a character
vector. This is used to determine which variable should be the dependent
in the dsep regression equations. If left unspecified, the order will be
automatically determined. If the combination of all included models is
itself a DAG, then the ordering of that full model is used. Otherwise,
the most common ordering between each pair of variables is used to create
a general ordering.</p>
</td></tr>
<tr><td><code id="phylo_path_+3A_parallel">parallel</code></td>
<td>
<p><em>Superseded</em> From v1.2 <code>phylopath</code> uses the <code>future</code> package
for all parallel processing, see details.</p>
</td></tr>
<tr><td><code id="phylo_path_+3A_na.rm">na.rm</code></td>
<td>
<p>Should rows that contain missing values be dropped from the data
as necessary (with a message)?</p>
</td></tr>
<tr><td><code id="phylo_path_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>phylolm</code>:
</p>
<p><code>lower.bound</code>: optional lower bound for the optimization of the phylogenetic model parameter.
</p>
<p><code>upper.bound</code>: optional upper bound for the optimization of the phylogenetic model parameter.
</p>
<p><code>starting.value</code>: optional starting value for the optimization of the phylogenetic model parameter.
</p>
<p><code>measurement_error</code>: a logical value indicating whether there is measurement error sigma2_error (see Details).
</p>
<p>Arguments passed on to <code>phyloglm</code>:
</p>
<p><code>btol</code>: bound on the linear predictor to bound the searching space.
</p>
<p><code>log.alpha.bound</code>: bound for the log of the parameter alpha.
</p>
<p><code>start.beta</code>: starting values for beta coefficients.
</p>
<p><code>start.alpha</code>: starting values for alpha (phylogenetic correlation).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Parallel processing</em>: From v1.2, <code>phylopath</code> uses the <code>future</code> framework
for parallel processing. This is compatible with the parallel computation
within the underlying <code>phylolm</code>, making it easy to enable parallel
processing of multiple models, and of bootstrap replicates. To enable,
simply set a parallel <code>plan()</code> using the <code>future</code> package. Typically, you'll
want to run <code>future::plan("multisession", workers = n)</code>, where <code>n</code> is the
number of cores. Now parallel processing is enabled. Return to sequential
processing using <code>future::plan("sequential")</code>
</p>


<h3>Value</h3>

<p>A phylopath object, with the following components:
</p>

<dl>
<dt>d_sep</dt><dd><p>for each model a table with separation statements and statistics.</p>
</dd>
<dt>model_set</dt><dd><p>the DAGs</p>
</dd>
<dt>data</dt><dd><p>the supplied data</p>
</dd>
<dt>tree</dt><dd><p>the supplied tree</p>
</dd>
<dt>model</dt><dd><p>the employed model of evolution in <code>phylolm</code></p>
</dd>
<dt>method</dt><dd><p>the employed method in <code>phyloglm</code></p>
</dd>
<dt>dots</dt><dd><p>any additional arguments given, these are passed on to downstream functions</p>
</dd>
<dt>warnings</dt><dd><p>any warnings generated by the models</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>  #see vignette('intro_to_phylopath') for more details
  candidates &lt;- define_model_set(
    A = NL ~ BM,
    B = NL ~ LS,
    .common = c(LS ~ BM, DD ~ NL)
  )
  p &lt;- phylo_path(candidates, rhino, rhino_tree)

  # Printing p gives some general information:
  p
  # And the summary gives statistics to compare the models:
  summary(p)

</code></pre>

<hr>
<h2 id='plot_model_set'>Plot several causal hypothesis at once.</h2><span id='topic+plot_model_set'></span>

<h3>Description</h3>

<p>Plot several causal hypothesis at once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_model_set(
  model_set,
  labels = NULL,
  algorithm = "kk",
  manual_layout = NULL,
  text_size = 5,
  box_x = 12,
  box_y = 10,
  edge_width = 1,
  curvature = 0.05,
  rotation = 0,
  flip_x = FALSE,
  flip_y = FALSE,
  nrow = NULL,
  arrow = grid::arrow(type = "closed", 15, grid::unit(10, "points"))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_model_set_+3A_model_set">model_set</code></td>
<td>
<p>A list of <code>DAG</code> objects, usually created with <code><a href="#topic+define_model_set">define_model_set()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_model_set_+3A_labels">labels</code></td>
<td>
<p>An optional set of labels to use for the nodes. This should be a named vector, of
the form <code>c(var1 = "label1", var2 = "label2")</code>.
If left at 'NULL&ldquo;, the variable names of the DAGs are used.</p>
</td></tr>
<tr><td><code id="plot_model_set_+3A_algorithm">algorithm</code></td>
<td>
<p>A layout algorithm from <code>igraph</code>, see
<code><a href="ggraph.html#topic+ggraph">ggraph::create_layout()</a></code>. By default, uses the Kamada-Kawai
layout algorithm. Another good option is <code>"sugiyama"</code>, which is
designed to minimize edge crossing in DAGs. However, it can often plot
nodes too close together.</p>
</td></tr>
<tr><td><code id="plot_model_set_+3A_manual_layout">manual_layout</code></td>
<td>
<p>Alternatively, precisely define the layout yourself, by providing a
<code>data.frame</code> that at least has a column <code>name</code> with all variable names, and columns <code>x</code> and <code>y</code>
with positions to be plotted. Setting this parameter overrides <code>algorithm</code> but other changes,
such as <code>rotation</code> and <code>flip</code>s will still be applied.</p>
</td></tr>
<tr><td><code id="plot_model_set_+3A_text_size">text_size</code></td>
<td>
<p>Size of the node label text.</p>
</td></tr>
<tr><td><code id="plot_model_set_+3A_box_x">box_x</code></td>
<td>
<p>To avoid the arrows colliding with the nodes, specify the
rectangular dimensions of an invisible box around each node. If you have
long labels, you need to increase this.</p>
</td></tr>
<tr><td><code id="plot_model_set_+3A_box_y">box_y</code></td>
<td>
<p>To avoid the arrows colliding with the nodes, specify the
rectangular dimensions of an invisible box around each node. If you have
multi-line labels, you need to increase this.</p>
</td></tr>
<tr><td><code id="plot_model_set_+3A_edge_width">edge_width</code></td>
<td>
<p>Width of the edges.</p>
</td></tr>
<tr><td><code id="plot_model_set_+3A_curvature">curvature</code></td>
<td>
<p>Curvature of the edges. A slight curvature can look pretty.</p>
</td></tr>
<tr><td><code id="plot_model_set_+3A_rotation">rotation</code></td>
<td>
<p>Supply the degrees you want to rotate the layout by. This is useful in order to
put rotate your upstream nodes towards the top if needed.</p>
</td></tr>
<tr><td><code id="plot_model_set_+3A_flip_x">flip_x</code></td>
<td>
<p>Whether to flip the node positions horizontally.</p>
</td></tr>
<tr><td><code id="plot_model_set_+3A_flip_y">flip_y</code></td>
<td>
<p>Whether to flip the node positions vertically.</p>
</td></tr>
<tr><td><code id="plot_model_set_+3A_nrow">nrow</code></td>
<td>
<p>Number of rows to display the models on.</p>
</td></tr>
<tr><td><code id="plot_model_set_+3A_arrow">arrow</code></td>
<td>
<p>A <code>grid::arrow</code> object, specifying the shape and size of the arrowheads.
</p>
<p>The order of facets is taken from the ordering of the list, with the facet
labels coming from the names of the list. If the list is unnamed, sequential
lettering is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- list(one = DAG(a ~ b + c + d), two = DAG(a ~ b, b ~ c, d ~ d))
plot_model_set(m)
plot_model_set(m, algorithm = "sugiyama")
</code></pre>

<hr>
<h2 id='plot.DAG'>Plot a directed acyclic graph.</h2><span id='topic+plot.DAG'></span>

<h3>Description</h3>

<p>Plot a directed acyclic graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DAG'
plot(
  x,
  labels = NULL,
  algorithm = "sugiyama",
  manual_layout = NULL,
  text_size = 6,
  box_x = 12,
  box_y = 8,
  edge_width = 1.5,
  curvature = 0.02,
  rotation = 0,
  flip_x = FALSE,
  flip_y = FALSE,
  arrow = grid::arrow(type = "closed", 18, grid::unit(15, "points")),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.DAG_+3A_x">x</code></td>
<td>
<p>A 'DAG&ldquo; object, usually created with the <code><a href="#topic+define_model_set">define_model_set()</a></code> or <code><a href="#topic+DAG">DAG()</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_labels">labels</code></td>
<td>
<p>An optional set of labels to use for the nodes. This should be a named vector, of
the form <code>c(var1 = "label1", var2 = "label2")</code>.
If left at 'NULL&ldquo;, the variable names of the DAGs are used.</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_algorithm">algorithm</code></td>
<td>
<p>A layout algorithm from <a href="igraph.html#topic+igraph">igraph</a>, see
<code><a href="ggraph.html#topic+ggraph">ggraph::create_layout()</a></code>. By default,
uses the Sugiyama layout algorithm, which is designed to minimize edge crossing in DAGs.</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_manual_layout">manual_layout</code></td>
<td>
<p>Alternatively, precisely define the layout yourself, by providing a
<code>data.frame</code> that at least has a column <code>name</code> with all variable names, and columns <code>x</code> and <code>y</code>
with positions to be plotted. Setting this parameter overrides <code>algorithm</code> but other changes,
such as <code>rotation</code> and <code>flip</code>s will still be applied.</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_text_size">text_size</code></td>
<td>
<p>Size of the node label text.</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_box_x">box_x</code></td>
<td>
<p>To avoid the arrows colliding with the nodes, specify the
rectangular dimensions of an invisible box around each node. If you have
long labels, you need to increase this.</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_box_y">box_y</code></td>
<td>
<p>To avoid the arrows colliding with the nodes, specify the
rectangular dimensions of an invisible box around each node. If you have
multi-line labels, you need to increase this.</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_edge_width">edge_width</code></td>
<td>
<p>Width of the edges.</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_curvature">curvature</code></td>
<td>
<p>Curvature of the edges. A slight curvature can look pretty.</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_rotation">rotation</code></td>
<td>
<p>Supply the degrees you want to rotate the layout by. This is useful in order to
put rotate your upstream nodes towards the top if needed.</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_flip_x">flip_x</code></td>
<td>
<p>Whether to flip the node positions horizontally.</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_flip_y">flip_y</code></td>
<td>
<p>Whether to flip the node positions vertically.</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_arrow">arrow</code></td>
<td>
<p>A <code>grid::arrow</code> object, specifying the shape and size of the arrowheads.
</p>
<p>The order of facets is taken from the ordering of the list, with the facet
labels coming from the names of the list. If the list is unnamed, sequential
lettering is used.</p>
</td></tr>
<tr><td><code id="plot.DAG_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  d &lt;- DAG(a ~ b + c + d)
  plot(d)

  # Plot with manually defined positions:
  ml &lt;- data.frame(
    name = c('a', 'b', 'c', 'd'),
    x = c(1, 1, 2, 2),
    y = c(1, 2, 1, 2)
  )
  plot(d, manual_layout = ml)

</code></pre>

<hr>
<h2 id='plot.fitted_DAG'>Plot a directed acyclic graph with path coefficients.</h2><span id='topic+plot.fitted_DAG'></span>

<h3>Description</h3>

<p>Plot a directed acyclic graph with path coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitted_DAG'
plot(
  x,
  type = "width",
  labels = NULL,
  algorithm = "sugiyama",
  manual_layout = NULL,
  text_size = 6,
  box_x = 12,
  box_y = 8,
  edge_width = 1.25,
  curvature = 0.02,
  rotation = 0,
  flip_x = FALSE,
  flip_y = FALSE,
  arrow = grid::arrow(type = "closed", 18, grid::unit(15, "points")),
  colors = c("firebrick", "navy"),
  show.legend = TRUE,
  width_const = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fitted_DAG_+3A_x">x</code></td>
<td>
<p>An object of class <code>fitted_DAG</code>.</p>
</td></tr>
<tr><td><code id="plot.fitted_DAG_+3A_type">type</code></td>
<td>
<p>How to express the weight of the path. Either <code>"width"</code>, or <code>"color"</code>.</p>
</td></tr>
<tr><td><code id="plot.fitted_DAG_+3A_labels">labels</code></td>
<td>
<p>An optional set of labels to use for the nodes. This should be a named vector, of
the form <code>c(var1 = "label1", var2 = "label2")</code>.
If left at 'NULL&ldquo;, the variable names of the DAGs are used.</p>
</td></tr>
<tr><td><code id="plot.fitted_DAG_+3A_algorithm">algorithm</code></td>
<td>
<p>A layout algorithm from <code>igraph</code>, see
<code><a href="ggraph.html#topic+ggraph">ggraph::create_layout()</a></code>. By default,
uses the Sugiyama layout algorithm, which is designed to minimize edge crossing in DAGs.</p>
</td></tr>
<tr><td><code id="plot.fitted_DAG_+3A_manual_layout">manual_layout</code></td>
<td>
<p>Alternatively, precisely define the layout yourself, by providing a
<code>data.frame</code> that at least has a column <code>name</code> with all variable names, and columns <code>x</code> and <code>y</code>
with positions to be plotted. Setting this parameter overrides <code>algorithm</code> but other changes,
such as <code>rotation</code> and <code>flip</code>s will still be applied.</p>
</td></tr>
<tr><td><code id="plot.fitted_DAG_+3A_text_size">text_size</code></td>
<td>
<p>Size of the node label text.</p>
</td></tr>
<tr><td><code id="plot.fitted_DAG_+3A_box_x">box_x</code></td>
<td>
<p>To avoid the arrows colliding with the nodes, specify the
rectangular dimensions of an invisible box around each node. If you have
long labels, you need to increase this.</p>
</td></tr>
<tr><td><code id="plot.fitted_DAG_+3A_box_y">box_y</code></td>
<td>
<p>To avoid the arrows colliding with the nodes, specify the
rectangular dimensions of an invisible box around each node. If you have
multi-line labels, you need to increase this.</p>
</td></tr>
<tr><td><code id="plot.fitted_DAG_+3A_edge_width">edge_width</code></td>
<td>
<p>Width of the edges.</p>
</td></tr>
<tr><td><code id="plot.fitted_DAG_+3A_curvature">curvature</code></td>
<td>
<p>Curvature of the edges. A slight curvature can look pretty.</p>
</td></tr>
<tr><td><code id="plot.fitted_DAG_+3A_rotation">rotation</code></td>
<td>
<p>Supply the degrees you want to rotate the layout by. This is useful in order to
put rotate your upstream nodes towards the top if needed.</p>
</td></tr>
<tr><td><code id="plot.fitted_DAG_+3A_flip_x">flip_x</code></td>
<td>
<p>Whether to flip the node positions horizontally.</p>
</td></tr>
<tr><td><code id="plot.fitted_DAG_+3A_flip_y">flip_y</code></td>
<td>
<p>Whether to flip the node positions vertically.</p>
</td></tr>
<tr><td><code id="plot.fitted_DAG_+3A_arrow">arrow</code></td>
<td>
<p>A <code>grid::arrow</code> object, specifying the shape and size of the arrowheads.
</p>
<p>The order of facets is taken from the ordering of the list, with the facet
labels coming from the names of the list. If the list is unnamed, sequential
lettering is used.</p>
</td></tr>
<tr><td><code id="plot.fitted_DAG_+3A_colors">colors</code></td>
<td>
<p>The end points of the continuous color scale. Keep in mind that red and green are
obvious colors to use, but are better to be avoided because of color blind users.</p>
</td></tr>
<tr><td><code id="plot.fitted_DAG_+3A_show.legend">show.legend</code></td>
<td>
<p>Whether a legend for the color scale should be shown.</p>
</td></tr>
<tr><td><code id="plot.fitted_DAG_+3A_width_const">width_const</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
<tr><td><code id="plot.fitted_DAG_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  d &lt;- DAG(LS ~ BM, NL ~ BM, DD ~ NL + LS)
  d_fitted &lt;- est_DAG(d, rhino, rhino_tree, 'lambda')
  plot(d_fitted)
</code></pre>

<hr>
<h2 id='red_list'>Data on brain size, life history and vulnerability to extinction</h2><span id='topic+red_list'></span>

<h3>Description</h3>

<p>A dataset with continuous variables affecting the conservation <code>Status</code> of
mammalian species (the IUCN red list of threatened species).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>red_list
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 474 rows and 7 columns.
</p>


<h3>Details</h3>

<p>It includes the following variables: brain size (<code>Br</code>), body size (<code>B</code>),
gestation period (<code>G</code>), litter size (<code>L</code>), weening age (<code>W</code>), population
density (<code>P</code>) and vulnerability to extinction (<code>Status</code>).
</p>


<h3>Source</h3>

<p>Gonzalez-Voyer A, Gonzalez-Suarez M, Vila C, Revilla E (2016) Larger
brain size indirectly increases vulnerability to extinction in mammals.
Evolution 70:1364-1375. doi: 10.1111/evo.12943
</p>

<hr>
<h2 id='red_list_tree'>Mammalian phylogeny</h2><span id='topic+red_list_tree'></span>

<h3>Description</h3>

<p>This is the accompanying phylogeny for the red_list data set. It is based
on the updated mammalian supertree by Bininda-Emonds et al. 2007 &amp; Fritz
et al. 2009.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>red_list_tree
</code></pre>


<h3>Format</h3>

<p>An object of class <code>phylo</code> of length 4.
</p>


<h3>Source</h3>

<p>Gonzalez-Voyer, A. Gonzalez-Suarez M. Vila C. and Revilla E. 2016.
Larger brain size indirectly increases vulnerability to extinction in
mammals. Evolution 70:1364-1375. doi: 10.1111/evo.12943.
</p>
<p>Bininda-Emonds, O. R. P., M. Cardillo, K. E. Jones, R. D. E. MacPhee, R. M. D.
Beck, R. Grenyer, S. A. Price, R. A. Vos, J. L. Gittleman, and A. Purvis.
2007. The delayed rise of present-day mammals. Nature 446:507-512.
</p>
<p>Fritz, S. A., O. R. P. Bininda-Emonds, and A. Purvis. 2009. Geographical
variation in predictors of mammalian extinction risk: big is bad, but
only in the tropics. Ecol. Lett. 12:538-549.
</p>

<hr>
<h2 id='rhino'>Rhinogrades traits.</h2><span id='topic+rhino'></span>

<h3>Description</h3>

<p>A simulated dataset, as used by Gonzalez-Voyer and Von Hardenberg as an
example, containing variables on body mass (BM), litter size (LS), nose
length (NL), dispersal distance (DD) and range size (RS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhino
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 100 rows and 6 columns.
</p>


<h3>Source</h3>

<p>Gonzalez-Voyer A &amp; von Hardenberg A. 2014. An Introduction to
Phylogenetic Path Analysis. Chapter 8. In: Garamszegi LZ (ed.), Modern
Phylogenetic Comparative Methods and Their Application in Evolutionary
Biology. pp. 201-229. Springer-Verlag Berlin Heidelberg.
doi:10.1111/j.1558-5646.2012.01790.x
</p>

<hr>
<h2 id='rhino_tree'>Rhinogrades phylogeny.</h2><span id='topic+rhino_tree'></span>

<h3>Description</h3>

<p>A phylogenetic tree for the 100 species of the <code>rhino</code> dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhino_tree
</code></pre>


<h3>Format</h3>

<p>An object of class <code>phylo</code> of length 4.
</p>


<h3>Source</h3>

<p>Gonzalez-Voyer A &amp; von Hardenberg A. 2014. An Introduction to
Phylogenetic Path Analysis. Chapter 8. In: Garamszegi LZ (ed.), Modern
Phylogenetic Comparative Methods and Their Application in Evolutionary
Biology. pp. 201-229. Springer-Verlag Berlin Heidelberg.
doi:10.1111/j.1558-5646.2012.01790.x
</p>

<hr>
<h2 id='show_warnings'>Print out warnings from a phylopath analysis.</h2><span id='topic+show_warnings'></span>

<h3>Description</h3>

<p>Use this function after running <code>phylo_path()</code> to conveniently print any generated warnings
to the screen. You can either provide no arguments, which will only work if you run it directly
after the analysis, or you have to provide the <code>phylopath</code> object manually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_warnings(phylopath = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_warnings_+3A_phylopath">phylopath</code></td>
<td>
<p>A <code>phylopath</code> object of which the warnings should be printed.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
