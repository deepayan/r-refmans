<!DOCTYPE html><html lang="en"><head><title>Help for package BVAR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BVAR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BVAR-package'><p>BVAR: Hierarchical Bayesian vector autoregression</p></a></li>
<li><a href='#bv_dummy'><p>Dummy prior settings</p></a></li>
<li><a href='#bv_fcast'><p>Forecast settings</p></a></li>
<li><a href='#bv_irf'><p>Impulse response settings and identification</p></a></li>
<li><a href='#bv_metropolis'><p>Metropolis-Hastings settings</p></a></li>
<li><a href='#bv_minnesota'><p>Minnesota prior settings</p></a></li>
<li><a href='#bv_priors'><p>Prior settings</p></a></li>
<li><a href='#bvar'><p>Hierarchical Bayesian vector autoregression</p></a></li>
<li><a href='#coda'><p>Methods for <span class="pkg">coda</span> Markov chain Monte Carlo objects</p></a></li>
<li><a href='#coef.bvar'><p>Coefficient and VCOV methods for Bayesian VARs</p></a></li>
<li><a href='#companion'><p>Retrieve companion matrix from a Bayesian VAR</p></a></li>
<li><a href='#density.bvar'><p>Density methods for Bayesian VARs</p></a></li>
<li><a href='#fitted.bvar'><p>Fitted and residual methods for Bayesian VARs</p></a></li>
<li><a href='#fred_qd'><p>FRED-MD and FRED-QD: Databases for Macroeconomic Research</p></a></li>
<li><a href='#fred_transform'><p>FRED transformation and subset helper</p></a></li>
<li><a href='#hist_decomp.bvar'><p>Historical decomposition</p></a></li>
<li><a href='#irf.bvar'><p>Impulse response and forecast error methods for Bayesian VARs</p></a></li>
<li><a href='#logLik.bvar'><p>Log-Likelihood method for Bayesian VARs</p></a></li>
<li><a href='#par_bvar'><p>Parallel hierarchical Bayesian vector autoregression</p></a></li>
<li><a href='#plot.bvar'><p>Plotting method for Bayesian VARs</p></a></li>
<li><a href='#plot.bvar_fcast'><p>Plotting method for Bayesian VAR predictions</p></a></li>
<li><a href='#plot.bvar_irf'><p>Plotting method for Bayesian VAR impulse responses</p></a></li>
<li><a href='#predict.bvar'><p>Predict method for Bayesian VARs</p></a></li>
<li><a href='#rmse.bvar'><p>Model fit in- and out-of-sample</p></a></li>
<li><a href='#summary.bvar'><p>Summary method for Bayesian VARs</p></a></li>
<li><a href='#WAIC.bvar'><p>Widely applicable information criterion (WAIC) for Bayesian VARs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Hierarchical Bayesian Vector Autoregression</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-13</td>
</tr>
<tr>
<td>Author:</td>
<td>Nikolas Kuschnig <a href="https://orcid.org/0000-0002-6642-2543"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Lukas Vashold <a href="https://orcid.org/0000-0002-3562-3414"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Nirai Tomass [ctb],
  Michael McCracken [dtc],
  Serena Ng [dtc]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nikolas Kuschnig &lt;nikolas.kuschnig@wu.ac.at&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimation of hierarchical Bayesian vector autoregressive models
    following Kuschnig &amp; Vashold (2021) &lt;<a href="https://doi.org/10.18637%2Fjss.v100.i14">doi:10.18637/jss.v100.i14</a>&gt;.
    Implements hierarchical prior selection for conjugate priors in the fashion
    of Giannone, Lenza &amp; Primiceri (2015) &lt;<a href="https://doi.org/10.1162%2FREST_a_00483">doi:10.1162/REST_a_00483</a>&gt;.
    Functions to compute and identify impulse responses, calculate forecasts,
    forecast error variance decompositions and scenarios are available.
    Several methods to print, plot and summarise results facilitate analysis.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/nk027/bvar">https://github.com/nk027/bvar</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nk027/bvar/issues">https://github.com/nk027/bvar/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>mvtnorm, stats, graphics, utils, grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>coda, vars, tinytest</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-16 09:57:30 UTC; nikolas</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-16 10:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='BVAR-package'>BVAR: Hierarchical Bayesian vector autoregression</h2><span id='topic+BVAR'></span><span id='topic+BVAR-package'></span>

<h3>Description</h3>

<p>Estimation of hierarchical Bayesian vector autoregressive models following
Kuschnig &amp; Vashold (2021).
Implements hierarchical prior selection for conjugate priors in the fashion
of Giannone, Lenza &amp; Primiceri (2015) &lt;doi:10.1162/REST_a_00483&gt;. Functions
to compute and identify impulse responses, calculate forecasts,
forecast error variance decompositions and scenarios are available.
Several methods to print, plot and summarise results facilitate analysis.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Nikolas Kuschnig <a href="mailto:nikolas.kuschnig@wu.ac.at">nikolas.kuschnig@wu.ac.at</a> (<a href="https://orcid.org/0000-0002-6642-2543">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Lukas Vashold (<a href="https://orcid.org/0000-0002-3562-3414">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Nirai Tomass [contributor]
</p>
</li>
<li><p> Michael McCracken [data contributor]
</p>
</li>
<li><p> Serena Ng [data contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Giannone, D. and Lenza, M. and Primiceri, G. E. (2015) Prior Selection for
Vector Autoregressions. <em>The Review of Economics and Statistics</em>,
<b>97:2</b>, 436-451, <a href="https://doi.org/10.1162/REST_a_00483">doi:10.1162/REST_a_00483</a>.
</p>
<p>Kuschnig, N. and Vashold, L. (2021) BVAR: Bayesian Vector Autoregressions
with Hierarchical Prior Selection in R.
<em>Journal of Statistical Software</em>, <b>14</b>, 1-27,
<a href="https://doi.org/10.18637/jss.v100.i14">doi:10.18637/jss.v100.i14</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/nk027/bvar">https://github.com/nk027/bvar</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/nk027/bvar/issues">https://github.com/nk027/bvar/issues</a>
</p>
</li></ul>


<hr>
<h2 id='bv_dummy'>Dummy prior settings</h2><span id='topic+bv_dummy'></span><span id='topic+bv_soc'></span><span id='topic+bv_sur'></span>

<h3>Description</h3>

<p>Allows the creation of dummy observation priors for <code><a href="#topic+bv_priors">bv_priors</a></code>.
See the Details section for information on common dummy priors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bv_dummy(mode = 1, sd = 1, min = 0.0001, max = 5, fun)

bv_soc(mode = 1, sd = 1, min = 0.0001, max = 50)

bv_sur(mode = 1, sd = 1, min = 0.0001, max = 50)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bv_dummy_+3A_mode">mode</code>, <code id="bv_dummy_+3A_sd">sd</code></td>
<td>
<p>Numeric scalar. Mode / standard deviation of the
parameter. Note that the <em>mode</em> of <em>psi</em> is set automatically by
default, and would need to be provided as vector.</p>
</td></tr>
<tr><td><code id="bv_dummy_+3A_min">min</code>, <code id="bv_dummy_+3A_max">max</code></td>
<td>
<p>Numeric scalar. Minimum / maximum allowed value. Note that
for <em>psi</em> these are set automatically or need to provided as vectors.</p>
</td></tr>
<tr><td><code id="bv_dummy_+3A_fun">fun</code></td>
<td>
<p>Function taking <em>Y</em>, <em>lags</em> and the prior's parameter
<em>par</em> to generate and return a named list with elements <em>X</em> and
<em>Y</em> (numeric matrices).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dummy priors are often used to &quot;reduce the importance of the deterministic
component implied by VARs estimated conditioning on the initial
observations&quot; (Giannone, Lenza and Primiceri, 2015, p. 440).
One such prior is the sum-of-coefficients (SOC) prior, which imposes the
notion that a no-change forecast is optimal at the beginning of a time
series. Its key parameter <code class="reqn">\mu</code> controls the tightness - i.e. for
low values the model is pulled towards a form with as many unit roots as
variables and no cointegration.
Another such prior is the single-unit-root (SUR) prior, that allows for
cointegration relationships in the data. It pushes variables either towards
their unconditional mean or towards the presence of at least one unit root.
These priors are implemented via Theil mixed estimation, i.e. by adding
dummy-observations on top of the data matrix. They are available via the
functions <code><a href="#topic+bv_soc">bv_soc</a></code> and <code><a href="#topic+bv_sur">bv_sur</a></code>.
</p>


<h3>Value</h3>

<p>Returns a named list of class <code>bv_dummy</code> for
<code><a href="#topic+bv_priors">bv_priors</a></code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>bv_soc()</code>: Sum-of-coefficients dummy prior
</p>
</li>
<li> <p><code>bv_sur()</code>: Single-unit-root dummy prior
</p>
</li></ul>


<h3>References</h3>

<p>Giannone, D. and Lenza, M. and Primiceri, G. E. (2015) Prior Selection for
Vector Autoregressions. <em>The Review of Economics and Statistics</em>,
<b>97:2</b>, 436-451, <a href="https://doi.org/10.1162/REST_a_00483">doi:10.1162/REST_a_00483</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bv_priors">bv_priors</a></code>; <code><a href="#topic+bv_minnesota">bv_minnesota</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a sum-of-coefficients prior
add_soc &lt;- function(Y, lags, par) {
  soc &lt;- if(lags == 1) {diag(Y[1, ]) / par} else {
    diag(colMeans(Y[1:lags, ])) / par
  }
  Y_soc &lt;- soc
  X_soc &lt;- cbind(rep(0, ncol(Y)), matrix(rep(soc, lags), nrow = ncol(Y)))

  return(list("Y" = Y_soc, "X" = X_soc))
}
soc &lt;- bv_dummy(mode = 1, sd = 1, min = 0.0001, max = 50, fun = add_soc)

# Create a single-unit-root prior
add_sur &lt;- function(Y, lags, par) {
  sur &lt;- if(lags == 1) {Y[1, ] / par} else {
    colMeans(Y[1:lags, ]) / par
  }
  Y_sur &lt;- sur
  X_sur &lt;- c(1 / par, rep(sur, lags))

  return(list("Y" = Y_sur, "X" = X_sur))
}

sur &lt;- bv_dummy(mode = 1, sd = 1, min = 0.0001, max = 50, fun = add_sur)

# Add the new custom dummy priors
bv_priors(hyper = "auto", soc = soc, sur = sur)
</code></pre>

<hr>
<h2 id='bv_fcast'>Forecast settings</h2><span id='topic+bv_fcast'></span>

<h3>Description</h3>

<p>Provide forecast settings to <code><a href="#topic+predict.bvar">predict.bvar</a></code>. Allows adjusting
the horizon of forecasts, and for setting up conditional forecasts. See the
Details section for further information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bv_fcast(horizon = 12, cond_path = NULL, cond_vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bv_fcast_+3A_horizon">horizon</code></td>
<td>
<p>Integer scalar. Horizon for which to compute forecasts.</p>
</td></tr>
<tr><td><code id="bv_fcast_+3A_cond_path">cond_path</code></td>
<td>
<p>Optional numeric vector or matrix used for conditional
forecasts. Supply variable path(s) on which forecasts are conditioned on.
Unrestricted future realisations should be filled with <code>NA</code>. Note that
not all variables can be restricted at the same time.</p>
</td></tr>
<tr><td><code id="bv_fcast_+3A_cond_vars">cond_vars</code></td>
<td>
<p>Optional character or numeric vector. Used to subset
<em>cond_path</em> to specific variable(s) via name or position. Not
needed when <em>cond_path</em> is constructed for all variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conditional forecasts are calculated using the algorithm by Waggoner and Zha
(1999). They are set up by imposing a path on selected variables.
</p>


<h3>Value</h3>

<p>Returns a named list of class <code>bv_fcast</code> with options for
<code><a href="#topic+bvar">bvar</a></code> or <code><a href="#topic+predict.bvar">predict.bvar</a></code>.
</p>


<h3>References</h3>

<p>Waggoner, D. F., &amp; Zha, T. (1999). Conditional Forecasts in Dynamic
Multivariate Models. <em>Review of Economics and Statistics</em>,
<b>81:4</b>, 639-651, <a href="https://doi.org/10.1162/003465399558508">doi:10.1162/003465399558508</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.bvar">predict.bvar</a></code>; <code><a href="#topic+plot.bvar_fcast">plot.bvar_fcast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set forecast-horizon to 20 time periods for unconditional forecasts
bv_fcast(horizon = 20)

# Define a path for the second variable (in the initial six periods).
bv_fcast(cond_path = c(1, 1, 1, 1, 1, 1), cond_var = 2)

# Constrain the paths of the first and third variables.
paths &lt;- matrix(NA, nrow = 10, ncol = 2)
paths[1:5, 1] &lt;- 1
paths[1:10, 2] &lt;- 2
bv_fcast(cond_path = paths, cond_var = c(1, 3))
</code></pre>

<hr>
<h2 id='bv_irf'>Impulse response settings and identification</h2><span id='topic+bv_irf'></span>

<h3>Description</h3>

<p>Provides settings for the computation of impulse responses to
<code><a href="#topic+bvar">bvar</a></code>, <code><a href="#topic+irf.bvar">irf.bvar</a></code> or <code><a href="#topic+fevd.bvar">fevd.bvar</a></code>. Allows
setting the horizon for which impulse responses should be computed, whether
or not forecast error variance decompositions (FEVDs) should be included
as well as if and what kind of identification should be used. See the Details
section for further information on identification. Identification can be
achieved via Cholesky decomposition, sign restrictions (Rubio-Ramirez,
Waggoner and Zha, 2010), and zero and sign restrictions (Arias,
Rubio-Ramirez and Waggoner, 2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bv_irf(
  horizon = 12,
  fevd = FALSE,
  identification = TRUE,
  sign_restr = NULL,
  sign_lim = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bv_irf_+3A_horizon">horizon</code></td>
<td>
<p>Integer scalar. The horizon for which impulse responses
(and FEVDs) should be computed. Note that the first period corresponds to
impacts i.e. contemporaneous effects.</p>
</td></tr>
<tr><td><code id="bv_irf_+3A_fevd">fevd</code></td>
<td>
<p>Logical scalar. Whether or not forecast error variance
decompositions should be calculated.</p>
</td></tr>
<tr><td><code id="bv_irf_+3A_identification">identification</code></td>
<td>
<p>Logical scalar. Whether or not the shocks used for
calculating impulses should be identified. Defaults to <code>TRUE</code>, i.e.
identification via Cholesky decomposition of the VCOV-matrix unless
<em>sign_restr</em> is provided.</p>
</td></tr>
<tr><td><code id="bv_irf_+3A_sign_restr">sign_restr</code></td>
<td>
<p>Elements inform about expected impacts
of certain shocks. Can be either <code class="reqn">1</code>, <code class="reqn">-1</code> or <code class="reqn">0</code> depending
on whether a positive, a negative or no contemporaneous effect of a
certain shock is expected. Elements set to <code class="reqn">NA</code> indicate that there are
no particular expectations for the contemporaneous effects. The default
value is <code>NULL</code>. Note that in order to be fully identified at least
<code class="reqn">M * (M - 1) / 2</code> restrictions have to be set and a maximum of
<code class="reqn">M - j</code> zero restrictions can be imposed on the <code class="reqn">j</code>'th column.</p>
</td></tr>
<tr><td><code id="bv_irf_+3A_sign_lim">sign_lim</code></td>
<td>
<p>Integer scalar. Maximum number of tries to find suitable
matrices to for fitting sign or zero and sign restrictions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Identification can be performed via Cholesky decomposition, sign
restrictions, or zero and sign restrictions. The algorithm
for generating suitable sign restrictions follows Rubio-Ramirez, Waggoner
and Zha (2010), while the one for zero and sign restrictions follows
Arias, Rubio-Ramirez and Waggoner (2018).
Note the possiblity of finding no suitable zero/sign restrictions.
</p>


<h3>Value</h3>

<p>Returns a named list of class <code>bv_irf</code> with options for
<code><a href="#topic+bvar">bvar</a></code>, <code><a href="#topic+irf.bvar">irf.bvar</a></code> or <code><a href="#topic+fevd.bvar">fevd.bvar</a></code>.
</p>


<h3>References</h3>

<p>Rubio-Ramirez, J. F. and Waggoner, D. F. and Zha, T. (2010) Structural
Vector Autoregressions: Theory of Identification and Algorithms for
Inference. <em>The Review of Economic Studies</em>, <b>77</b>, 665-696,
<a href="https://doi.org/10.1111/j.1467-937X.2009.00578.x">doi:10.1111/j.1467-937X.2009.00578.x</a>.
Arias, J.E. and Rubio-Ramirez, J. F. and Waggoner, D. F. (2018)
Inference Based on Structural Vector Autoregressions Identifiied with
Sign and Zero Restrictions: Theory and Applications.
<em>Econometrica</em>, <b>86</b>, 2, 685-720,
<a href="https://doi.org/10.3982/ECTA14468">doi:10.3982/ECTA14468</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irf.bvar">irf.bvar</a></code>; <code><a href="#topic+plot.bvar_irf">plot.bvar_irf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set impulse responses to a horizon of 20 time periods and enable FEVD
# (Identification is performed via Cholesky decomposition)
bv_irf(horizon = 20, fevd = TRUE)

# Set up structural impulse responses using sign restrictions
signs &lt;- matrix(c(1, NA, NA, -1, 1, -1, -1, 1, 1), nrow = 3)
bv_irf(sign_restr = signs)

# Set up structural impulse responses using zero and sign restrictions
zero_signs &lt;- matrix(c(1, 0, NA, -1, 1, 0, -1, 1, 1), nrow = 3)
bv_irf(sign_restr = zero_signs)

# Prepare to estimate unidentified impulse responses
bv_irf(identification = FALSE)
</code></pre>

<hr>
<h2 id='bv_metropolis'>Metropolis-Hastings settings</h2><span id='topic+bv_metropolis'></span><span id='topic+bv_mh'></span>

<h3>Description</h3>

<p>Function to provide settings for the Metropolis-Hastings step in
<code><a href="#topic+bvar">bvar</a></code>. Options include scaling the inverse Hessian that is
used to draw parameter proposals and automatic scaling to achieve certain
acceptance rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bv_metropolis(
  scale_hess = 0.01,
  adjust_acc = FALSE,
  adjust_burn = 0.75,
  acc_lower = 0.25,
  acc_upper = 0.45,
  acc_change = 0.01
)

bv_mh(
  scale_hess = 0.01,
  adjust_acc = FALSE,
  adjust_burn = 0.75,
  acc_lower = 0.25,
  acc_upper = 0.45,
  acc_change = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bv_metropolis_+3A_scale_hess">scale_hess</code></td>
<td>
<p>Numeric scalar or vector. Scaling parameter, determining
the range of hyperparameter draws. Should be calibrated so a reasonable
acceptance rate is reached. If provided as vector the length must equal
the number of hyperparameters (one per variable for <code>psi</code>).</p>
</td></tr>
<tr><td><code id="bv_metropolis_+3A_adjust_acc">adjust_acc</code></td>
<td>
<p>Logical scalar. Whether or not to further scale the
variability of parameter draws during the burn-in phase.</p>
</td></tr>
<tr><td><code id="bv_metropolis_+3A_adjust_burn">adjust_burn</code></td>
<td>
<p>Numeric scalar. How much of the burn-in phase should be
used to scale parameter variability. See Details.</p>
</td></tr>
<tr><td><code id="bv_metropolis_+3A_acc_lower">acc_lower</code>, <code id="bv_metropolis_+3A_acc_upper">acc_upper</code></td>
<td>
<p>Numeric scalar. Lower (upper) bound of the target
acceptance rate. Required if <em>adjust_acc</em> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bv_metropolis_+3A_acc_change">acc_change</code></td>
<td>
<p>Numeric scalar. Percent change applied to the Hessian
matrix for tuning acceptance rate. Required if <em>adjust_acc</em> is set to
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that adjustment of the acceptance rate by scaling the parameter
draw variability can only be done during the burn-in phase, as otherwise the
resulting draws do not feature the desirable properties of a Markov chain.
After the parameter draws have been scaled, some additional draws should be
burnt.
</p>


<h3>Value</h3>

<p>Returns a named list of class <code>bv_metropolis</code> with options for
<code><a href="#topic+bvar">bvar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Increase the scaling parameter
bv_mh(scale_hess = 1)

# Turn on automatic scaling of the acceptance rate to [20%, 40%]
bv_mh(adjust_acc = TRUE, acc_lower = 0.2, acc_upper = 0.4)

# Increase the rate of automatic scaling
bv_mh(adjust_acc = TRUE, acc_lower = 0.2, acc_upper = 0.4, acc_change = 0.1)

# Use only 50% of the burn-in phase to adjust scaling
bv_mh(adjust_acc = TRUE, adjust_burn = 0.5)
</code></pre>

<hr>
<h2 id='bv_minnesota'>Minnesota prior settings</h2><span id='topic+bv_minnesota'></span><span id='topic+bv_mn'></span><span id='topic+bv_lambda'></span><span id='topic+bv_alpha'></span><span id='topic+bv_psi'></span>

<h3>Description</h3>

<p>Provide settings for the Minnesota prior to <code><a href="#topic+bv_priors">bv_priors</a></code>. See the
Details section for further information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bv_minnesota(
  lambda = bv_lambda(),
  alpha = bv_alpha(),
  psi = bv_psi(),
  var = 10000000,
  b = 1
)

bv_mn(
  lambda = bv_lambda(),
  alpha = bv_alpha(),
  psi = bv_psi(),
  var = 10000000,
  b = 1
)

bv_lambda(mode = 0.2, sd = 0.4, min = 0.0001, max = 5)

bv_alpha(mode = 2, sd = 0.25, min = 1, max = 3)

bv_psi(scale = 0.004, shape = 0.004, mode = "auto", min = "auto", max = "auto")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bv_minnesota_+3A_lambda">lambda</code></td>
<td>
<p>List constructed via <code><a href="#topic+bv_lambda">bv_lambda</a></code>.
Arguments are <em>mode</em>, <em>sd</em>, <em>min</em> and <em>max</em>.
May also be provided as a numeric vector of length 4.</p>
</td></tr>
<tr><td><code id="bv_minnesota_+3A_alpha">alpha</code></td>
<td>
<p>List constructed via <code><a href="#topic+bv_alpha">bv_alpha</a></code>.
Arguments are <em>mode</em>, <em>sd</em>, <em>min</em> and <em>max</em>. High values
for <em>mode</em> may affect invertibility of the augmented data matrix.
May also be provided as a numeric vector of length 4.</p>
</td></tr>
<tr><td><code id="bv_minnesota_+3A_psi">psi</code></td>
<td>
<p>List with elements <em>scale</em>, <em>shape</em> of the prior
as well as <em>mode</em> and optionally <em>min</em> and <em>max</em>. The length
of these needs to match the number of variables (i.e. columns) in the data.
By default <em>mode</em> is set automatically to the square-root of the
innovations variance after fitting an <code class="reqn">AR(p)</code> model to the data.
If <code><a href="stats.html#topic+arima">arima</a></code> fails due to a non-stationary time series the
order of integration is incremented by 1. By default <em>min</em> / <em>max</em>
are set to <em>mode</em> divided / multiplied by 100.</p>
</td></tr>
<tr><td><code id="bv_minnesota_+3A_var">var</code></td>
<td>
<p>Numeric scalar with the prior variance on the model's constant.</p>
</td></tr>
<tr><td><code id="bv_minnesota_+3A_b">b</code></td>
<td>
<p>Numeric scalar, vector or matrix with the prior mean. A scalar is
applied to all variables, with a default value of 1. Consider setting it to
0 for growth rates. A vector needs to match the number of variables (i.e.
columns) in the data, with a prior mean per variable. If provided, a matrix
needs to have a column per variable (<code class="reqn">M</code>), and <code class="reqn">M * p + 1</code> rows,
where <code class="reqn">p</code> is the number of lags applied.</p>
</td></tr>
<tr><td><code id="bv_minnesota_+3A_mode">mode</code>, <code id="bv_minnesota_+3A_sd">sd</code></td>
<td>
<p>Numeric scalar. Mode / standard deviation of the
parameter. Note that the <em>mode</em> of <em>psi</em> is set automatically by
default, and would need to be provided as vector.</p>
</td></tr>
<tr><td><code id="bv_minnesota_+3A_min">min</code>, <code id="bv_minnesota_+3A_max">max</code></td>
<td>
<p>Numeric scalar. Minimum / maximum allowed value. Note that
for <em>psi</em> these are set automatically or need to provided as vectors.</p>
</td></tr>
<tr><td><code id="bv_minnesota_+3A_scale">scale</code>, <code id="bv_minnesota_+3A_shape">shape</code></td>
<td>
<p>Numeric scalar. Scale and shape parameters of a Gamma
distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Essentially this prior imposes the hypothesis, that individual variables
all follow random walk processes. This parsimonious specification typically
performs well in forecasts of macroeconomic time series and is often used as
a benchmark for evaluating accuracy (Kilian and Lütkepohl, 2017).
The key parameter is <code class="reqn">\lambda</code> (<em>lambda</em>), which controls
the tightness of the prior. The parameter <code class="reqn">\alpha</code> (<em>alpha</em>)
governs variance decay with increasing lag order, while <code class="reqn">\psi</code>
(<em>psi</em>) controls the prior's standard deviation on lags of variables
other than the dependent.
The Minnesota prior is often refined with additional priors, trying to
minimise the importance of conditioning on initial observations. See
<code><a href="#topic+bv_dummy">bv_dummy</a></code> for more information on such priors.
</p>


<h3>Value</h3>

<p>Returns a list of class <code>bv_minnesota</code> with options for
<code><a href="#topic+bvar">bvar</a></code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>bv_lambda()</code>: Tightness of the Minnesota prior
</p>
</li>
<li> <p><code>bv_alpha()</code>: Variance decay with increasing lag order
</p>
</li>
<li> <p><code>bv_psi()</code>: Prior standard deviation on other lags
</p>
</li></ul>


<h3>References</h3>

<p>Kilian, L. and Lütkepohl, H. (2017). <em>Structural Vector
Autoregressive Analysis</em>. Cambridge University Press,
<a href="https://doi.org/10.1017/9781108164818">doi:10.1017/9781108164818</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bv_priors">bv_priors</a></code>; <code><a href="#topic+bv_dummy">bv_dummy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Adjust alpha and the Minnesota prior variance.
bv_mn(alpha = bv_alpha(mode = 0.5, sd = 1, min = 1e-12, max = 10), var = 1e6)
# Optionally use a vector as shorthand
bv_mn(alpha = c(0.5, 1, 1e-12, 10), var = 1e6)

# Only adjust lambda's standard deviation
bv_mn(lambda = bv_lambda(sd = 2))

# Provide prior modes for psi (for a VAR with three variables)
bv_mn(psi = bv_psi(mode = c(0.7, 0.3, 0.9)))
</code></pre>

<hr>
<h2 id='bv_priors'>Prior settings</h2><span id='topic+bv_priors'></span>

<h3>Description</h3>

<p>Function to provide priors and their parameters to <code><a href="#topic+bvar">bvar</a></code>. Used
for adjusting the parameters treated as hyperparameters, the Minnesota prior
and adding various dummy priors through the ellipsis parameter.
Note that treating <code class="reqn">\psi</code> (<em>psi</em>) as a hyperparameter in a
model with many variables may lead to very low acceptance rates and thus
hinder convergence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bv_priors(hyper = "auto", mn = bv_mn(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bv_priors_+3A_hyper">hyper</code></td>
<td>
<p>Character vector. Used to specify the parameters to be treated
as hyperparameters. May also be set to <code>"auto"</code> or <code>"full"</code> for
an automatic / full subset. Other allowed values are the Minnesota prior's
parameters <code>"lambda"</code>, <code>"alpha"</code> and <code>"psi"</code> as well as the
names of additional dummy priors included via <em>...</em>.</p>
</td></tr>
<tr><td><code id="bv_priors_+3A_mn">mn</code></td>
<td>
<p>List of class <code>"bv_minnesota"</code>. Options for the Minnesota
prior, set via <code><a href="#topic+bv_mn">bv_mn</a></code>.</p>
</td></tr>
<tr><td><code id="bv_priors_+3A_...">...</code></td>
<td>
<p>Optional lists of class <code>bv_dummy</code> with options for
dummy priors. <b>Must be assigned a name in the function call</b>. Created
with <code><a href="#topic+bv_dummy">bv_dummy</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named list of class <code>bv_priors</code> with options for
<code><a href="#topic+bvar">bvar</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bv_mn">bv_mn</a></code>; <code><a href="#topic+bv_dummy">bv_dummy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Extend the hyperparameters to the full Minnesota prior
bv_priors(hyper = c("lambda", "alpha", "psi"))
# Alternatively
# bv_priors("full")

# Add a dummy prior via `bv_dummy()`

# Re-create the single-unit-root prior
add_sur &lt;- function(Y, lags, par) {
  sur &lt;- if(lags == 1) {Y[1, ] / par} else {
    colMeans(Y[1:lags, ]) / par
  }
  Y_sur &lt;- sur
  X_sur &lt;- c(1 / par, rep(sur, lags))

  return(list("Y" = Y_sur, "X" = X_sur))
}
sur &lt;- bv_dummy(mode = 1, sd = 1, min = 0.0001, max = 50, fun = add_sur)

# Add the new prior
bv_priors(hyper = "auto", sur = sur)
</code></pre>

<hr>
<h2 id='bvar'>Hierarchical Bayesian vector autoregression</h2><span id='topic+bvar'></span>

<h3>Description</h3>

<p>Used to estimate hierarchical Bayesian Vector Autoregression (VAR) models in
the fashion of Giannone, Lenza and Primiceri (2015).
Priors are adjusted and added via <code><a href="#topic+bv_priors">bv_priors</a></code>.
The Metropolis-Hastings step can be modified with <code><a href="#topic+bv_mh">bv_mh</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bvar(
  data,
  lags,
  n_draw = 10000L,
  n_burn = 5000L,
  n_thin = 1L,
  priors = bv_priors(),
  mh = bv_mh(),
  fcast = NULL,
  irf = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bvar_+3A_data">data</code></td>
<td>
<p>Numeric matrix or dataframe. Note that observations are expected
to be ordered from earliest to latest, and variables in the columns.</p>
</td></tr>
<tr><td><code id="bvar_+3A_lags">lags</code></td>
<td>
<p>Integer scalar. Lag order of the model.</p>
</td></tr>
<tr><td><code id="bvar_+3A_n_draw">n_draw</code>, <code id="bvar_+3A_n_burn">n_burn</code></td>
<td>
<p>Integer scalar. The number of iterations to (a) cycle
through and (b) burn at the start.</p>
</td></tr>
<tr><td><code id="bvar_+3A_n_thin">n_thin</code></td>
<td>
<p>Integer scalar. Every <em>n_thin</em>'th iteration is stored.
For a given memory requirement thinning reduces autocorrelation, while
increasing effective sample size.</p>
</td></tr>
<tr><td><code id="bvar_+3A_priors">priors</code></td>
<td>
<p>Object from <code><a href="#topic+bv_priors">bv_priors</a></code> with prior settings.
Used to adjust the Minnesota prior, add custom dummy priors, and choose
hyperparameters for hierarchical estimation.</p>
</td></tr>
<tr><td><code id="bvar_+3A_mh">mh</code></td>
<td>
<p>Object from <code><a href="#topic+bv_mh">bv_mh</a></code> with settings for the
Metropolis-Hastings step. Used to tune automatic adjustment of the
acceptance rate within the burn-in period, or manually adjust the proposal
variance.</p>
</td></tr>
<tr><td><code id="bvar_+3A_fcast">fcast</code></td>
<td>
<p>Object from <code><a href="#topic+bv_fcast">bv_fcast</a></code> with forecast settings.
Options include the horizon and settings for conditional forecasts i.e.
scenario analysis.
May also be calculated ex-post using <code><a href="#topic+predict.bvar">predict.bvar</a></code>.</p>
</td></tr>
<tr><td><code id="bvar_+3A_irf">irf</code></td>
<td>
<p>Object from <code><a href="#topic+bv_irf">bv_irf</a></code> with settings for the calculation
of impulse responses and forecast error variance decompositions. Options
include the horizon and different identification schemes.
May also be calculated ex-post using <code><a href="#topic+irf.bvar">irf.bvar</a></code>.</p>
</td></tr>
<tr><td><code id="bvar_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar. Whether to print intermediate results and
progress.</p>
</td></tr>
<tr><td><code id="bvar_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model can be expressed as:
</p>
<p style="text-align: center;"><code class="reqn">y_t = a_0 + A_1 y_{t-1} + ... + A_p y_{t-p} + \epsilon_t</code>
</p>

<p>See Kuschnig and Vashold (2021) and Giannone, Lenza and Primiceri (2015)
for further information.
Methods for a <code>bvar</code> object and its derivatives can be used to:
</p>

<ul>
<li><p> predict and analyse scenarios;
</p>
</li>
<li><p> evaluate shocks and the variance of forecast errors;
</p>
</li>
<li><p> visualise forecasts and impulse responses, parameters and residuals;
</p>
</li>
<li><p> retrieve coefficents and the variance-covariance matrix;
</p>
</li>
<li><p> calculate fitted and residual values;
</p>
</li></ul>

<p>Note that these methods generally work by calculating quantiles from the
posterior draws. The full posterior may be retrieved directly from the
objects. The function <code><a href="utils.html#topic+str">str</a></code> can be very helpful for this.
</p>


<h3>Value</h3>

<p>Returns a list of class <code>bvar</code> with the following elements:
</p>

<ul>
<li> <p><code>beta</code> - Numeric array with draws from the posterior of the VAR
coefficients. Also see <code><a href="#topic+coef.bvar">coef.bvar</a></code>.
</p>
</li>
<li> <p><code>sigma</code> - Numeric array with draws from the posterior of the
variance-covariance matrix. Also see <code><a href="#topic+vcov.bvar">vcov.bvar</a></code>.
</p>
</li>
<li> <p><code>hyper</code> - Numeric matrix with draws from the posterior of the
hierarchically treated hyperparameters.
</p>
</li>
<li> <p><code>ml</code> - Numeric vector with the marginal likelihood (with respect
to the hyperparameters), that determines acceptance probability.
</p>
</li>
<li> <p><code>optim</code> - List with outputs of <code><a href="stats.html#topic+optim">optim</a></code>,
which is used to find starting values for the hyperparameters.
</p>
</li>
<li> <p><code>prior</code> - Prior settings from <code><a href="#topic+bv_priors">bv_priors</a></code>.
</p>
</li>
<li> <p><code>call</code> - Call to the function. See <code><a href="base.html#topic+match.call">match.call</a></code>.
</p>
</li>
<li> <p><code>meta</code> - List with meta information. Includes the number of
variables, accepted draws, number of iterations, and data.
</p>
</li>
<li> <p><code>variables</code> - Character vector with the column names of
<em>data</em>. If missing, variables are named iteratively.
</p>
</li>
<li> <p><code>explanatories</code> - Character vector with names of explanatory
variables. Formatting is akin to: <code>"FEDFUNDS-lag1"</code>.
</p>
</li>
<li> <p><code>fcast</code> - Forecasts from <code><a href="#topic+predict.bvar">predict.bvar</a></code>.
</p>
</li>
<li> <p><code>irf</code> - Impulse responses from <code><a href="#topic+irf.bvar">irf.bvar</a></code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nikolas Kuschnig, Lukas Vashold
</p>


<h3>References</h3>

<p>Giannone, D. and Lenza, M. and Primiceri, G. E. (2015) Prior Selection for
Vector Autoregressions. <em>The Review of Economics and Statistics</em>,
<b>97:2</b>, 436-451, <a href="https://doi.org/10.1162/REST_a_00483">doi:10.1162/REST_a_00483</a>.
</p>
<p>Kuschnig, N. and Vashold, L. (2021) BVAR: Bayesian Vector Autoregressions
with Hierarchical Prior Selection in R.
<em>Journal of Statistical Software</em>, <b>14</b>, 1-27,
<a href="https://doi.org/10.18637/jss.v100.i14">doi:10.18637/jss.v100.i14</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bv_priors">bv_priors</a></code>; <code><a href="#topic+bv_mh">bv_mh</a></code>;
<code><a href="#topic+bv_fcast">bv_fcast</a></code>; <code><a href="#topic+bv_irf">bv_irf</a></code>;
<code><a href="#topic+predict.bvar">predict.bvar</a></code>; <code><a href="#topic+irf.bvar">irf.bvar</a></code>; <code><a href="#topic+plot.bvar">plot.bvar</a></code>;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Access a subset of the fred_qd dataset
data &lt;- fred_qd[, c("CPIAUCSL", "UNRATE", "FEDFUNDS")]
# Transform it to be stationary
data &lt;- fred_transform(data, codes = c(5, 5, 1), lag = 4)

# Estimate a BVAR using one lag, default settings and very few draws
x &lt;- bvar(data, lags = 1, n_draw = 1000L, n_burn = 200L, verbose = FALSE)

# Calculate and store forecasts and impulse responses
predict(x) &lt;- predict(x, horizon = 8)
irf(x) &lt;- irf(x, horizon = 8, fevd = FALSE)

## Not run: 
# Check convergence of the hyperparameters with a trace and density plot
plot(x)
# Plot forecasts and impulse responses
plot(predict(x))
plot(irf(x))
# Check coefficient values and variance-covariance matrix
summary(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='coda'>Methods for <span class="pkg">coda</span> Markov chain Monte Carlo objects</h2><span id='topic+coda'></span><span id='topic+as.mcmc.bvar'></span><span id='topic+as.mcmc.bvar_chains'></span>

<h3>Description</h3>

<p>Methods to convert parameter and/or coefficient draws from <code><a href="#topic+bvar">bvar</a></code>
to <span class="pkg">coda</span>'s <code><a href="coda.html#topic+mcmc">mcmc</a></code> (or <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>)
format for further processing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.mcmc.bvar(
  x,
  vars = NULL,
  vars_response = NULL,
  vars_impulse = NULL,
  chains = list(),
  ...
)

as.mcmc.bvar_chains(
  x,
  vars = NULL,
  vars_response = NULL,
  vars_impulse = NULL,
  chains = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coda_+3A_x">x</code></td>
<td>
<p>A <code>bvar</code> object, obtained from <code><a href="#topic+bvar">bvar</a></code>.</p>
</td></tr>
<tr><td><code id="coda_+3A_vars">vars</code></td>
<td>
<p>Character vector used to select variables. Elements are matched
to hyperparameters or coefficients. Coefficients may be matched based on
the dependent variable (by providing the name or position) or the
explanatory variables (by providing the name and the desired lag). See the
example section for a demonstration. Defaults to <code>NULL</code>, i.e. all
hyperparameters.</p>
</td></tr>
<tr><td><code id="coda_+3A_vars_response">vars_response</code>, <code id="coda_+3A_vars_impulse">vars_impulse</code></td>
<td>
<p>Optional character or integer vectors used
to select coefficents. Dependent variables are specified with
<em>vars_response</em>, explanatory ones with <em>vars_impulse</em>. See the
example section for a demonstration.</p>
</td></tr>
<tr><td><code id="coda_+3A_chains">chains</code></td>
<td>
<p>List with additional <code>bvar</code> objects. If provided,
an object of class <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> is returned.</p>
</td></tr>
<tr><td><code id="coda_+3A_...">...</code></td>
<td>
<p>Other parameters for <code><a href="coda.html#topic+as.mcmc">as.mcmc</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <span class="pkg">coda</span> <code><a href="coda.html#topic+mcmc">mcmc</a></code> (or
<code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>) object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bvar">bvar</a></code>; <code><a href="coda.html#topic+mcmc">mcmc</a></code>;
<code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library("coda")

# Access a subset of the fred_qd dataset
data &lt;- fred_qd[, c("CPIAUCSL", "UNRATE", "FEDFUNDS")]
# Transform it to be stationary
data &lt;- fred_transform(data, codes = c(5, 5, 1), lag = 4)

# Estimate two BVARs using one lag, default settings and very few draws
x &lt;- bvar(data, lags = 1, n_draw = 750L, n_burn = 250L, verbose = FALSE)
y &lt;- bvar(data, lags = 1, n_draw = 750L, n_burn = 250L, verbose = FALSE)

# Convert the hyperparameter lambda
as.mcmc(x, vars = c("lambda"))

# Convert coefficients for the first dependent, use chains in method
as.mcmc(structure(list(x, y), class = "bvar_chains"), vars = "CPIAUCSL")

# Convert the coefs of variable three's first lag, use in the generic
as.mcmc(x, vars = "FEDFUNDS-lag1", chains = y)

# Convert hyperparameters and constant coefficient values for variable 1
as.mcmc(x, vars = c("lambda", "CPI", "constant"))

# Specify coefficent values to convert in alternative way
as.mcmc(x, vars_impulse = c("FED", "CPI"), vars_response = "UNRATE")

</code></pre>

<hr>
<h2 id='coef.bvar'>Coefficient and VCOV methods for Bayesian VARs</h2><span id='topic+coef.bvar'></span><span id='topic+vcov.bvar'></span>

<h3>Description</h3>

<p>Retrieves coefficient / variance-covariance values from Bayesian VAR models
generated with <code><a href="#topic+bvar">bvar</a></code>. Note that coefficients are available for
every stored draw and one may retrieve (a) credible intervals via the
<em>conf_bands</em> argument, or (2) means via the <em>type</em> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvar'
coef(
  object,
  type = c("quantile", "mean"),
  conf_bands = 0.5,
  companion = FALSE,
  ...
)

## S3 method for class 'bvar'
vcov(object, type = c("quantile", "mean"), conf_bands = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.bvar_+3A_object">object</code></td>
<td>
<p>A <code>bvar</code> object, obtained from <code><a href="#topic+bvar">bvar</a></code>.</p>
</td></tr>
<tr><td><code id="coef.bvar_+3A_type">type</code></td>
<td>
<p>Character scalar. Whether to return quantile or mean values.
Note that <em>conf_bands</em> is ignored for mean values.</p>
</td></tr>
<tr><td><code id="coef.bvar_+3A_conf_bands">conf_bands</code></td>
<td>
<p>Numeric vector of confidence bands to apply.
E.g. for bands at 5%, 10%, 90% and 95% set this to <code>c(0.05, 0.1)</code>.
Note that the median, i.e. 0.5 is always included.</p>
</td></tr>
<tr><td><code id="coef.bvar_+3A_companion">companion</code></td>
<td>
<p>Logical scalar. Whether to retrieve the companion matrix of
coefficients. See <code><a href="#topic+companion.bvar">companion.bvar</a></code>.</p>
</td></tr>
<tr><td><code id="coef.bvar_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric array of class <code>bvar_coefs</code> or
<code>bvar_vcovs</code> at the specified values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bvar">bvar</a></code>; <code><a href="#topic+companion.bvar">companion.bvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Access a subset of the fred_qd dataset
data &lt;- fred_qd[, c("CPIAUCSL", "UNRATE", "FEDFUNDS")]
# Transform it to be stationary
data &lt;- fred_transform(data, codes = c(5, 5, 1), lag = 4)

# Estimate a BVAR using one lag, default settings and very few draws
x &lt;- bvar(data, lags = 1, n_draw = 1000L, n_burn = 200L, verbose = FALSE)

# Get coefficent values at the 10%, 50% and 90% quantiles
coef(x, conf_bands = 0.10)

# Only get the median of the variance-covariance matrix
vcov(x, conf_bands = 0.5)

</code></pre>

<hr>
<h2 id='companion'>Retrieve companion matrix from a Bayesian VAR</h2><span id='topic+companion'></span><span id='topic+companion.default'></span><span id='topic+companion.bvar'></span>

<h3>Description</h3>

<p>Calculates the companion matrix for Bayesian VARs generated via
<code><a href="#topic+bvar">bvar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>companion(object, ...)

## Default S3 method:
companion(object, ...)

## S3 method for class 'bvar'
companion(object, type = c("quantile", "mean"), conf_bands = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="companion_+3A_object">object</code></td>
<td>
<p>A <code>bvar</code> object, obtained from <code><a href="#topic+bvar">bvar</a></code>.</p>
</td></tr>
<tr><td><code id="companion_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="companion_+3A_type">type</code></td>
<td>
<p>Character scalar. Whether to return quantile or mean values.
Note that <em>conf_bands</em> is ignored for mean values.</p>
</td></tr>
<tr><td><code id="companion_+3A_conf_bands">conf_bands</code></td>
<td>
<p>Numeric vector of confidence bands to apply.
E.g. for bands at 5%, 10%, 90% and 95% set this to <code>c(0.05, 0.1)</code>.
Note that the median, i.e. 0.5 is always included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric array/matrix of class <code>bvar_comp</code> with the
VAR's coefficents in companion form at the specified values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bvar">bvar</a></code>; <code><a href="#topic+coef.bvar">coef.bvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Access a subset of the fred_qd dataset
data &lt;- fred_qd[, c("CPIAUCSL", "UNRATE", "FEDFUNDS")]
# Transform it to be stationary
data &lt;- fred_transform(data, codes = c(5, 5, 1), lag = 4)

# Estimate a BVAR using one lag, default settings and very few draws
x &lt;- bvar(data, lags = 1, n_draw = 1000L, n_burn = 200L, verbose = FALSE)

# Get companion matrices for confidence bands at 10%, 50% and 90%
companion(x, conf_bands = 0.10)

</code></pre>

<hr>
<h2 id='density.bvar'>Density methods for Bayesian VARs</h2><span id='topic+density.bvar'></span><span id='topic+plot.bvar_density'></span><span id='topic+independent_index'></span>

<h3>Description</h3>

<p>Calculates densities of hyperparameters or coefficient draws from Bayesian
VAR models generated via <code><a href="#topic+bvar">bvar</a></code>. Wraps standard
<code><a href="stats.html#topic+density">density</a></code> outputs into a <code>list</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvar'
density(x, vars = NULL, vars_response = NULL, vars_impulse = NULL, ...)

## S3 method for class 'bvar_density'
plot(x, mar = c(2, 2, 2, 0.5), mfrow = c(length(x), 1), ...)

independent_index(var, n_vars, lag)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="density.bvar_+3A_x">x</code></td>
<td>
<p>A <code>bvar</code> object, obtained from <code><a href="#topic+bvar">bvar</a></code>.</p>
</td></tr>
<tr><td><code id="density.bvar_+3A_vars">vars</code></td>
<td>
<p>Character vector used to select variables. Elements are matched
to hyperparameters or coefficients. Coefficients may be matched based on
the dependent variable (by providing the name or position) or the
explanatory variables (by providing the name and the desired lag). See the
example section for a demonstration. Defaults to <code>NULL</code>, i.e. all
hyperparameters.</p>
</td></tr>
<tr><td><code id="density.bvar_+3A_vars_response">vars_response</code>, <code id="density.bvar_+3A_vars_impulse">vars_impulse</code></td>
<td>
<p>Optional character or integer vectors used
to select coefficents. Dependent variables are specified with
<em>vars_response</em>, explanatory ones with <em>vars_impulse</em>. See the
example section for a demonstration.</p>
</td></tr>
<tr><td><code id="density.bvar_+3A_...">...</code></td>
<td>
<p>Fed to <code><a href="stats.html#topic+density">density</a></code> or
<code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="density.bvar_+3A_mar">mar</code></td>
<td>
<p>Numeric vector. Margins for <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="density.bvar_+3A_mfrow">mfrow</code></td>
<td>
<p>Numeric vector. Rows for <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="density.bvar_+3A_var">var</code>, <code id="density.bvar_+3A_n_vars">n_vars</code>, <code id="density.bvar_+3A_lag">lag</code></td>
<td>
<p>Integer scalars. Retrieve the position of lag
<em>lag</em> of variable <em>var</em> given <em>n_vars</em> total variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with outputs of <code><a href="stats.html#topic+density">density</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bvar">bvar</a></code>; <code><a href="stats.html#topic+density">density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Access a subset of the fred_qd dataset
data &lt;- fred_qd[, c("CPIAUCSL", "UNRATE", "FEDFUNDS")]
# Transform it to be stationary
data &lt;- fred_transform(data, codes = c(5, 5, 1), lag = 4)

# Estimate a BVAR using one lag, default settings and very few draws
x &lt;- bvar(data, lags = 1, n_draw = 1000L, n_burn = 200L, verbose = FALSE)

# Get densities of the hyperparameters
density(x)

# Plot them
plot(density(x))

# Only get the densities associated with dependent variable 1
density(x, vars_response = "CPI")

# Check out the constant's densities
plot(density(x, vars_impulse = 1))

# Get the densities of variable three's first lag
density(x, vars = "FEDFUNDS-lag1")

# Get densities of lambda and the coefficients of dependent variable 2
density(x, vars = c("lambda", "UNRATE"))

</code></pre>

<hr>
<h2 id='fitted.bvar'>Fitted and residual methods for Bayesian VARs</h2><span id='topic+fitted.bvar'></span><span id='topic+residuals.bvar'></span><span id='topic+plot.bvar_resid'></span>

<h3>Description</h3>

<p>Calculates fitted or residual values for Bayesian VAR models generated with
<code><a href="#topic+bvar">bvar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvar'
fitted(object, type = c("quantile", "mean"), conf_bands = 0.5, ...)

## S3 method for class 'bvar'
residuals(object, type = c("quantile", "mean"), conf_bands = 0.5, ...)

## S3 method for class 'bvar_resid'
plot(x, vars = NULL, mar = c(2, 2, 2, 0.5), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.bvar_+3A_object">object</code></td>
<td>
<p>A <code>bvar</code> object, obtained from <code><a href="#topic+bvar">bvar</a></code>.</p>
</td></tr>
<tr><td><code id="fitted.bvar_+3A_type">type</code></td>
<td>
<p>Character scalar. Whether to return quantile or mean values.
Note that <em>conf_bands</em> is ignored for mean values.</p>
</td></tr>
<tr><td><code id="fitted.bvar_+3A_conf_bands">conf_bands</code></td>
<td>
<p>Numeric vector of confidence bands to apply.
E.g. for bands at 5%, 10%, 90% and 95% set this to <code>c(0.05, 0.1)</code>.
Note that the median, i.e. 0.5 is always included.</p>
</td></tr>
<tr><td><code id="fitted.bvar_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="fitted.bvar_+3A_x">x</code></td>
<td>
<p>Object of class <code>bvar_fitted</code> / <code>bvar_resid</code>.</p>
</td></tr>
<tr><td><code id="fitted.bvar_+3A_vars">vars</code></td>
<td>
<p>Character vector used to select variables. Elements are matched
to hyperparameters or coefficients. Coefficients may be matched based on
the dependent variable (by providing the name or position) or the
explanatory variables (by providing the name and the desired lag). See the
example section for a demonstration. Defaults to <code>NULL</code>, i.e. all
hyperparameters.</p>
</td></tr>
<tr><td><code id="fitted.bvar_+3A_mar">mar</code></td>
<td>
<p>Numeric vector. Margins for <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric array of class <code>bvar_fitted</code> or
<code>bvar_resid</code> at the specified values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bvar">bvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Access a subset of the fred_qd dataset
data &lt;- fred_qd[, c("CPIAUCSL", "UNRATE", "FEDFUNDS")]
# Transform it to be stationary
data &lt;- fred_transform(data, codes = c(5, 5, 1), lag = 4)

# Estimate a BVAR using one lag, default settings and very few draws
x &lt;- bvar(data, lags = 1, n_draw = 1000L, n_burn = 200L, verbose = FALSE)

# Get fitted values and adjust confidence bands to 10%, 50% and 90%
fitted(x, conf_bands = 0.10)

# Get the residuals of variable 1
resid(x, vars = 1)

## Not run: 
# Get residuals and plot them
plot(residuals(x))

## End(Not run)
</code></pre>

<hr>
<h2 id='fred_qd'>FRED-MD and FRED-QD: Databases for Macroeconomic Research</h2><span id='topic+fred_qd'></span><span id='topic+fred_md'></span>

<h3>Description</h3>

<p>FRED-MD and FRED-QD are large macroeconomic databases, containing monthly
and quarterly time series that are frequently used in the literature. They
are intended to facilitate the reproduction of empirical work and simplify
data related tasks.
Included datasets are provided as is - transformation codes are available
in <code>system.file("fred_trans.rds", package = "BVAR")</code>. These can be
applied automatically with <code><a href="#topic+fred_transform">fred_transform</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fred_qd

fred_md
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> object with dates as rownames.
</p>
<p>An object of class <code>data.frame</code> with 777 rows and 118 columns.
</p>


<h3>Details</h3>

<p>The versions of FRED-MD and FRED-QD that are provided here are licensed
under a modified ODC-BY 1.0 license that can be found in the provided
<em>LICENSE</em> file. The provided versions are subset to variables that are
either in public domain or for which we were given permission to use.
For further details see McCracken and Ng (2016) or
<a href="https://research.stlouisfed.org/econ/mccracken/fred-databases/">https://research.stlouisfed.org/econ/mccracken/fred-databases/</a>.
We would like to thank Michael McCracken and Serena Ng, Adrienne Brennecke
and the Federal Reserve Bank of St. Louis for creating, updating and making
available the datasets and many of the contained time series. We also thank
all other owners of included time series that permitted their use.
</p>


<h3>Source</h3>

<p><a href="https://research.stlouisfed.org/econ/mccracken/fred-databases/">https://research.stlouisfed.org/econ/mccracken/fred-databases/</a>
</p>


<h3>References</h3>

<p>McCracken, M. W. and Ng, S. (2016) FRED-MD: A Monthly Database for
Macroeconomic Research. <em>Journal of Business &amp; Economic Statistics</em>,
<b>34:4</b>, 574-589, <a href="https://doi.org/10.1080/07350015.2015.1086655">doi:10.1080/07350015.2015.1086655</a>.
McCracken, M. W., &amp; Ng, S. (2020). FRED-QD: A Quarterly Database for
Macroeconomic Research <b>w26872</b>. National Bureau of Economic Research.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fred_transform">fred_transform</a></code>
</p>

<hr>
<h2 id='fred_transform'>FRED transformation and subset helper</h2><span id='topic+fred_transform'></span><span id='topic+fred_code'></span>

<h3>Description</h3>

<p>Apply transformations given by FRED-MD or FRED-QD and generate rectangular
subsets. See <code><a href="#topic+fred_qd">fred_qd</a></code> for information on data and the Details
section for information on the transformations. Call without arguments to
retrieve available codes / all FRED suggestions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fred_transform(
  data,
  type = c("fred_qd", "fred_md"),
  codes,
  na.rm = TRUE,
  lag = 1L,
  scale = 100
)

fred_code(vars, type = c("fred_qd", "fred_md"), table = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fred_transform_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> with FRED-QD or FRED-MD time series. The
column names are used to find the correct transformation.</p>
</td></tr>
<tr><td><code id="fred_transform_+3A_type">type</code></td>
<td>
<p>Character scalar. Whether <em>data</em> stems from the FRED-QD or
the FRED-MD database.</p>
</td></tr>
<tr><td><code id="fred_transform_+3A_codes">codes</code></td>
<td>
<p>Integer vector. Transformation code(s) to apply to <em>data</em>.
Overrides automatic lookup of transformation codes.</p>
</td></tr>
<tr><td><code id="fred_transform_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical scalar. Whether to subset to rows without any
<code>NA</code> values. A warning is thrown if rows are non-sequential.</p>
</td></tr>
<tr><td><code id="fred_transform_+3A_lag">lag</code></td>
<td>
<p>Integer scalar. Number of lags to apply when taking differences.
See <code><a href="base.html#topic+diff">diff</a></code>.</p>
</td></tr>
<tr><td><code id="fred_transform_+3A_scale">scale</code></td>
<td>
<p>Numeric scalar. Scaling to apply to log differences.</p>
</td></tr>
<tr><td><code id="fred_transform_+3A_vars">vars</code></td>
<td>
<p>Character vector. Names of the variables to look for.</p>
</td></tr>
<tr><td><code id="fred_transform_+3A_table">table</code></td>
<td>
<p>Logical scalar. Whether to return a table of matching
transformation codes instead of just the codes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>FRED-QD and FRED-MD include a transformation code for every variable. All
codes are provided in <code>system.file("fred_trans.csv", package = "BVAR")</code>.
The transformation codes are as follows:
</p>

<ol>
<li> <p><code>1</code> - no transformation;
</p>
</li>
<li> <p><code>2</code> - first differences - <code class="reqn">\Delta x_t</code>;
</p>
</li>
<li> <p><code>3</code> - second differences - <code class="reqn">\Delta^2 x_t</code>;
</p>
</li>
<li> <p><code>4</code> - log transformation - <code class="reqn">\log x_t</code>;
</p>
</li>
<li> <p><code>5</code> - log differences -
<code class="reqn">\Delta \log x_t</code>;
</p>
</li>
<li> <p><code>6</code> - log second differences -
<code class="reqn">\Delta^2 \log x_t</code>;
</p>
</li>
<li> <p><code>7</code> - percent change differences -
<code class="reqn">\Delta x_t / x_{t-1} - 1</code>;
</p>
</li></ol>

<p>Note that the transformation codes of FRED-MD and FRED-QD may differ for
the same series.
</p>


<h3>Value</h3>

<p><code><a href="#topic+fred_transform">fred_transform</a></code> returns a <code>data.frame</code> object with
applied transformations. <code><a href="#topic+fred_code">fred_code</a></code> returns transformation
codes, or a <code>data.frame</code> of matching transformation codes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fred_qd">fred_qd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Transform a subset of FRED-QD
fred_transform(fred_qd[, c("GDPC1", "INDPRO", "FEDFUNDS")])

# Get info on transformation codes for unemployment variables
fred_code("UNRATE", table = TRUE)

# Get the transformation code for GDPC1
fred_code("GDPC1", type = "fred_qd")

# Transform all of FRED-MD
## Not run: 
fred_transform(fred_md, type = "fred_md")

## End(Not run)
</code></pre>

<hr>
<h2 id='hist_decomp.bvar'>Historical decomposition</h2><span id='topic+hist_decomp.bvar'></span><span id='topic+hist_decomp'></span><span id='topic+hist_decomp.default'></span>

<h3>Description</h3>

<p>Function to compute a historical variance decomposition of a VAR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvar'
hist_decomp(x, type = c("mean", "quantile"), ...)

hist_decomp(x, ...)

## Default S3 method:
hist_decomp(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hist_decomp.bvar_+3A_x">x</code></td>
<td>
<p>A <code>bvar</code> object, obtained from <code><a href="#topic+bvar">bvar</a></code>.</p>
</td></tr>
<tr><td><code id="hist_decomp.bvar_+3A_type">type</code></td>
<td>
<p>Character scalar. Whether to use median or mean values.</p>
</td></tr>
<tr><td><code id="hist_decomp.bvar_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numerical array (time, variable, shock) with the results
of the historical decomposition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Access a subset of the fred_qd dataset
data &lt;- fred_qd[, c("CPIAUCSL", "UNRATE", "FEDFUNDS")]
# Transform it to be stationary
data &lt;- fred_transform(data, codes = c(5, 5, 1), lag = 4)

# Estimate a BVAR using one lag, default settings and very few draws
x &lt;- bvar(data, lags = 1, n_draw = 600L, n_burn = 100L, verbose = FALSE)

# Compute historical decomposition
hist_decomp(x, type = "mean")

</code></pre>

<hr>
<h2 id='irf.bvar'>Impulse response and forecast error methods for Bayesian VARs</h2><span id='topic+irf.bvar'></span><span id='topic+fevd.bvar'></span><span id='topic+irf'></span><span id='topic+irf.default'></span><span id='topic+irf+3C-'></span><span id='topic+fevd'></span><span id='topic+fevd.default'></span><span id='topic+fevd+3C-'></span><span id='topic+summary.bvar_irf'></span>

<h3>Description</h3>

<p>Retrieves / calculates impulse response functions (IRFs) and/or forecast
error variance decompositions (FEVDs) for Bayesian VARs generated via
<code><a href="#topic+bvar">bvar</a></code>. If the object is already present and no settings are
supplied it is simply retrieved, otherwise it will be calculated ex-post.
Note that FEVDs require the presence / calculation of IRFs.
To store the results you may want to assign the output using the setter
function (<code>irf(x) &lt;- irf(x)</code>). May also be used to update
confidence bands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvar'
irf(x, ..., conf_bands, n_thin = 1L, verbose = FALSE)

## S3 method for class 'bvar'
fevd(x, ..., conf_bands, n_thin = 1L)

irf(x, ...)

## Default S3 method:
irf(x, ...)

irf(x) &lt;- value

fevd(x, ...)

## Default S3 method:
fevd(x, ...)

fevd(x) &lt;- value

## S3 method for class 'bvar_irf'
summary(object, vars_impulse = NULL, vars_response = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="irf.bvar_+3A_x">x</code>, <code id="irf.bvar_+3A_object">object</code></td>
<td>
<p>A <code>bvar</code> object, obtained from <code><a href="#topic+bvar">bvar</a></code>.
Summary and print methods take in a <code>bvar_irf</code> / <code>bvar_fevd</code>
object.</p>
</td></tr>
<tr><td><code id="irf.bvar_+3A_...">...</code></td>
<td>
<p>A <code>bv_irf</code> object or arguments to be fed into
<code><a href="#topic+bv_irf">bv_irf</a></code>. Contains settings for the IRFs / FEVDs.</p>
</td></tr>
<tr><td><code id="irf.bvar_+3A_conf_bands">conf_bands</code></td>
<td>
<p>Numeric vector of confidence bands to apply.
E.g. for bands at 5%, 10%, 90% and 95% set this to <code>c(0.05, 0.1)</code>.
Note that the median, i.e. 0.5 is always included.</p>
</td></tr>
<tr><td><code id="irf.bvar_+3A_n_thin">n_thin</code></td>
<td>
<p>Integer scalar. Every <em>n_thin</em>'th draw in <em>x</em> is used
to calculate, others are dropped.</p>
</td></tr>
<tr><td><code id="irf.bvar_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar. Whether to print intermediate results and
progress.</p>
</td></tr>
<tr><td><code id="irf.bvar_+3A_value">value</code></td>
<td>
<p>A <code>bvar_irf</code> object to assign.</p>
</td></tr>
<tr><td><code id="irf.bvar_+3A_vars_impulse">vars_impulse</code>, <code id="irf.bvar_+3A_vars_response">vars_response</code></td>
<td>
<p>Optional numeric or character vector.
Used to subset the summary method's outputs to certain variables by position
or name (must be available). Defaults to <code>NULL</code>, i.e. all variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of class <code>bvar_irf</code> including IRFs and optionally
FEVDs at desired confidence bands. The <code>fevd</code> method only returns a
the nested <code>bvar_fevd</code> object.
The summary method returns a numeric array of impulse responses at the
specified confidence bands.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.bvar_irf">plot.bvar_irf</a></code>; <code><a href="#topic+bv_irf">bv_irf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Access a subset of the fred_qd dataset
data &lt;- fred_qd[, c("CPIAUCSL", "UNRATE", "FEDFUNDS")]
# Transform it to be stationary
data &lt;- fred_transform(data, codes = c(5, 5, 1), lag = 4)

# Estimate a BVAR using one lag, default settings and very few draws
x &lt;- bvar(data, lags = 1, n_draw = 600L, n_burn = 100L, verbose = FALSE)

# Compute + store IRF with a longer horizon, no identification and thinning
irf(x) &lt;- irf(x, bv_irf(horizon = 24L, identification = FALSE), n_thin = 5L)

# Update the confidence bands of the IRFs
irf(x, conf_bands = c(0.01, 0.05, 0.1))

# Recalculate with sign restrictions provided via the ellipsis
irf(x, sign_restr = matrix(c(1, NA, NA, -1, 1, -1, -1, 1, 1), nrow = 3))

# Recalculate with zero and sign restrictions provided via the ellipsis
irf(x, sign_restr = matrix(c(1, 0, 1, NA, 1, 1, -1, -1, 1), nrow = 3))

# Calculate the forecast error variance decomposition
fevd(x)

# Get a summary of the saved impulse response function
summary(x)

# Limit the summary to responses of variable #2
summary(x, vars_response = 2L)

</code></pre>

<hr>
<h2 id='logLik.bvar'>Log-Likelihood method for Bayesian VARs</h2><span id='topic+logLik.bvar'></span>

<h3>Description</h3>

<p>Calculates the log-likelihood of Bayesian VAR models generated with
<code><a href="#topic+bvar">bvar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvar'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.bvar_+3A_object">object</code></td>
<td>
<p>A <code>bvar</code> object, obtained from <code><a href="#topic+bvar">bvar</a></code>.</p>
</td></tr>
<tr><td><code id="logLik.bvar_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>logLik</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bvar">bvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Access a subset of the fred_qd dataset
data &lt;- fred_qd[, c("CPIAUCSL", "UNRATE", "FEDFUNDS")]
# Transform it to be stationary
data &lt;- fred_transform(data, codes = c(5, 5, 1), lag = 4)

# Estimate a BVAR using one lag, default settings and very few draws
x &lt;- bvar(data, lags = 1, n_draw = 1000L, n_burn = 200L, verbose = FALSE)

# Calculate the log-likelihood
logLik(x)

</code></pre>

<hr>
<h2 id='par_bvar'>Parallel hierarchical Bayesian vector autoregression</h2><span id='topic+par_bvar'></span>

<h3>Description</h3>

<p>Wrapper for <code><a href="#topic+bvar">bvar</a></code> to simplify parallel computation via
<code><a href="parallel.html#topic+parLapply">parLapply</a></code>. Make sure to properly start and stop the
provided cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par_bvar(
  cl,
  n_runs = length(cl),
  data,
  lags,
  n_draw = 10000L,
  n_burn = 5000L,
  n_thin = 1L,
  priors = bv_priors(),
  mh = bv_mh(),
  fcast = NULL,
  irf = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="par_bvar_+3A_cl">cl</code></td>
<td>
<p>A <code>cluster</code> object obtained from
<code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>.</p>
</td></tr>
<tr><td><code id="par_bvar_+3A_n_runs">n_runs</code></td>
<td>
<p>The number of parallel runs to calculate. Defaults to the
length of <em>cl</em>, i.e. the number of registered nodes.</p>
</td></tr>
<tr><td><code id="par_bvar_+3A_data">data</code></td>
<td>
<p>Numeric matrix or dataframe. Note that observations are expected
to be ordered from earliest to latest, and variables in the columns.</p>
</td></tr>
<tr><td><code id="par_bvar_+3A_lags">lags</code></td>
<td>
<p>Integer scalar. Lag order of the model.</p>
</td></tr>
<tr><td><code id="par_bvar_+3A_n_draw">n_draw</code>, <code id="par_bvar_+3A_n_burn">n_burn</code></td>
<td>
<p>Integer scalar. The number of iterations to (a) cycle
through and (b) burn at the start.</p>
</td></tr>
<tr><td><code id="par_bvar_+3A_n_thin">n_thin</code></td>
<td>
<p>Integer scalar. Every <em>n_thin</em>'th iteration is stored.
For a given memory requirement thinning reduces autocorrelation, while
increasing effective sample size.</p>
</td></tr>
<tr><td><code id="par_bvar_+3A_priors">priors</code></td>
<td>
<p>Object from <code><a href="#topic+bv_priors">bv_priors</a></code> with prior settings.
Used to adjust the Minnesota prior, add custom dummy priors, and choose
hyperparameters for hierarchical estimation.</p>
</td></tr>
<tr><td><code id="par_bvar_+3A_mh">mh</code></td>
<td>
<p>Object from <code><a href="#topic+bv_mh">bv_mh</a></code> with settings for the
Metropolis-Hastings step. Used to tune automatic adjustment of the
acceptance rate within the burn-in period, or manually adjust the proposal
variance.</p>
</td></tr>
<tr><td><code id="par_bvar_+3A_fcast">fcast</code></td>
<td>
<p>Object from <code><a href="#topic+bv_fcast">bv_fcast</a></code> with forecast settings.
Options include the horizon and settings for conditional forecasts i.e.
scenario analysis.
May also be calculated ex-post using <code><a href="#topic+predict.bvar">predict.bvar</a></code>.</p>
</td></tr>
<tr><td><code id="par_bvar_+3A_irf">irf</code></td>
<td>
<p>Object from <code><a href="#topic+bv_irf">bv_irf</a></code> with settings for the calculation
of impulse responses and forecast error variance decompositions. Options
include the horizon and different identification schemes.
May also be calculated ex-post using <code><a href="#topic+irf.bvar">irf.bvar</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of class <code>bvar_chain</code> with <code>bvar</code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bvar">bvar</a></code>; <code><a href="parallel.html#topic+parLapply">parLapply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library("parallel")

cl &lt;- makeCluster(2L)

# Access a subset of the fred_qd dataset
data &lt;- fred_qd[, c("CPIAUCSL", "UNRATE", "FEDFUNDS")]
# Transform it to be stationary
data &lt;- fred_transform(data, codes = c(5, 5, 1), lag = 4)

# A singular run using one lag, default settings and very few draws
x &lt;- bvar(data, lags = 1, n_draw = 1000L, n_burn = 200L, verbose = FALSE)

# Two parallel runs
y &lt;- par_bvar(cl, n_runs = 2,
  data = data, lags = 1, n_draw = 1000L, n_burn = 200L)

stopCluster(cl)

# Plot lambda for all of the runs
## Not run: 
plot(x, type = "full", vars = "lambda", chains = y)

# Convert the hyperparameter lambda to a coda mcmc.list object
coda::as.mcmc(y, vars = "lambda")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.bvar'>Plotting method for Bayesian VARs</h2><span id='topic+plot.bvar'></span>

<h3>Description</h3>

<p>Method to plot trace and densities of coefficient, hyperparameter and
marginal likelihood draws obtained from <code><a href="#topic+bvar">bvar</a></code>. Several types of
plot are available via the argument <em>type</em>, including traces, densities,
plots of forecasts and impulse responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvar'
plot(
  x,
  type = c("full", "trace", "density", "irf", "fcast"),
  vars = NULL,
  vars_response = NULL,
  vars_impulse = NULL,
  chains = list(),
  mar = c(2, 2, 2, 0.5),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.bvar_+3A_x">x</code></td>
<td>
<p>A <code>bvar</code> object, obtained from <code><a href="#topic+bvar">bvar</a></code>.</p>
</td></tr>
<tr><td><code id="plot.bvar_+3A_type">type</code></td>
<td>
<p>A string with the type of plot desired. The default option
<code>"full"</code> plots both densities and traces.</p>
</td></tr>
<tr><td><code id="plot.bvar_+3A_vars">vars</code></td>
<td>
<p>Character vector used to select variables. Elements are matched
to hyperparameters or coefficients. Coefficients may be matched based on
the dependent variable (by providing the name or position) or the
explanatory variables (by providing the name and the desired lag). See the
example section for a demonstration. Defaults to <code>NULL</code>, i.e. all
hyperparameters.</p>
</td></tr>
<tr><td><code id="plot.bvar_+3A_vars_response">vars_response</code>, <code id="plot.bvar_+3A_vars_impulse">vars_impulse</code></td>
<td>
<p>Optional character or integer vectors used
to select coefficents. Dependent variables are specified with
<em>vars_response</em>, explanatory ones with <em>vars_impulse</em>. See the
example section for a demonstration.</p>
</td></tr>
<tr><td><code id="plot.bvar_+3A_chains">chains</code></td>
<td>
<p>List of <code>bvar</code> objects. Contents are then added to trace
and density plots to help assessing covergence.</p>
</td></tr>
<tr><td><code id="plot.bvar_+3A_mar">mar</code></td>
<td>
<p>Numeric vector. Margins for <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.bvar_+3A_...">...</code></td>
<td>
<p>Other graphical parameters for <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <em>x</em> invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bvar">bvar</a></code>; <code><a href="#topic+plot.bvar_fcast">plot.bvar_fcast</a></code>;
<code><a href="#topic+plot.bvar_irf">plot.bvar_irf</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Access a subset of the fred_qd dataset
data &lt;- fred_qd[, c("CPIAUCSL", "UNRATE", "FEDFUNDS")]
# Transform it to be stationary
data &lt;- fred_transform(data, codes = c(5, 5, 1), lag = 4)

# Estimate a BVAR using one lag, default settings and very few draws
x &lt;- bvar(data, lags = 1, n_draw = 1000L, n_burn = 200L, verbose = FALSE)

# Plot full traces and densities
plot(x)

# Only plot the marginal likelihood's trace
plot(x, "trace", "ml")

# Access IRF and forecast plotting functions
plot(x, type = "irf", vars_response = 2)
plot(x, type = "fcast", vars = 2)

</code></pre>

<hr>
<h2 id='plot.bvar_fcast'>Plotting method for Bayesian VAR predictions</h2><span id='topic+plot.bvar_fcast'></span>

<h3>Description</h3>

<p>Plotting method for forecasts obtained from <code><a href="#topic+predict.bvar">predict.bvar</a></code>.
Forecasts of all or a subset of the available variables can be plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvar_fcast'
plot(
  x,
  vars = NULL,
  col = "#737373",
  t_back = 1,
  area = FALSE,
  fill = "#808080",
  variables = NULL,
  orientation = c("vertical", "horizontal"),
  mar = c(2, 2, 2, 0.5),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.bvar_fcast_+3A_x">x</code></td>
<td>
<p>A <code>bvar_fcast</code> object, obtained from <code><a href="#topic+predict.bvar">predict.bvar</a></code>.</p>
</td></tr>
<tr><td><code id="plot.bvar_fcast_+3A_vars">vars</code></td>
<td>
<p>Optional numeric or character vector. Used to subset the plot to
certain variables by position or name (must be available). Defaults to
<code>NULL</code>, i.e. all variables.</p>
</td></tr>
<tr><td><code id="plot.bvar_fcast_+3A_col">col</code></td>
<td>
<p>Character vector. Colour(s) of the lines delineating credible
intervals. Single values will be recycled if necessary. Recycled HEX color
codes are varied in transparency if not provided (e.g. &quot;#737373FF&quot;). Lines
can be bypassed by setting this to <code>"transparent"</code>.</p>
</td></tr>
<tr><td><code id="plot.bvar_fcast_+3A_t_back">t_back</code></td>
<td>
<p>Integer scalar. Number of observed datapoints to plot ahead of
the forecast.</p>
</td></tr>
<tr><td><code id="plot.bvar_fcast_+3A_area">area</code></td>
<td>
<p>Logical scalar. Whether to fill the credible intervals using
<code><a href="graphics.html#topic+polygon">polygon</a></code>.</p>
</td></tr>
<tr><td><code id="plot.bvar_fcast_+3A_fill">fill</code></td>
<td>
<p>Character vector. Colour(s) to fill the credible intervals with.
See <em>col</em> for more information.</p>
</td></tr>
<tr><td><code id="plot.bvar_fcast_+3A_variables">variables</code></td>
<td>
<p>Optional character vector. Names of all variables in the
object. Used to subset and title. Taken from <code>x$variables</code> if available.</p>
</td></tr>
<tr><td><code id="plot.bvar_fcast_+3A_orientation">orientation</code></td>
<td>
<p>String indicating the orientation of the plots. Defaults
to <code>"v"</code> (i.e. vertical); may be set to <code>"h"</code> (i.e. horizontal).</p>
</td></tr>
<tr><td><code id="plot.bvar_fcast_+3A_mar">mar</code></td>
<td>
<p>Numeric vector. Margins for <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.bvar_fcast_+3A_...">...</code></td>
<td>
<p>Other graphical parameters for <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <em>x</em> invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bvar">bvar</a></code>; <code><a href="#topic+predict.bvar">predict.bvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Access a subset of the fred_qd dataset
data &lt;- fred_qd[, c("CPIAUCSL", "UNRATE", "FEDFUNDS")]
# Transform it to be stationary
data &lt;- fred_transform(data, codes = c(5, 5, 1), lag = 4)

# Estimate a BVAR using one lag, default settings and very few draws
x &lt;- bvar(data, lags = 1, n_draw = 1000L, n_burn = 200L, verbose = FALSE)

# Store predictions ex-post
predict(x) &lt;- predict(x)

# Plot forecasts for all available variables
plot(predict(x))

# Subset to variables in positions 1 and 3 via their name
plot(predict(x), vars = c("CPI", "FED"))

# Subset via position, increase the plotted forecast horizon and past data
plot(predict(x, horizon = 20), vars = c(1, 3), t_back = 10)

# Adjust confidence bands and the plot's orientation
plot(predict(x, conf_bands = 0.25), orientation = "h")

# Draw areas inbetween the confidence bands and skip drawing lines
plot(predict(x), col = "transparent", area = TRUE)

# Plot a conditional forecast (with a constrained second variable).
plot(predict(x, cond_path = c(1, 1, 1, 1, 1, 1), cond_var = 2))

</code></pre>

<hr>
<h2 id='plot.bvar_irf'>Plotting method for Bayesian VAR impulse responses</h2><span id='topic+plot.bvar_irf'></span>

<h3>Description</h3>

<p>Plotting method for impulse responses obtained from <code><a href="#topic+irf.bvar">irf.bvar</a></code>.
Impulse responses of all or a subset of the available variables can be
plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvar_irf'
plot(
  x,
  vars_response = NULL,
  vars_impulse = NULL,
  col = "#737373",
  area = FALSE,
  fill = "#808080",
  variables = NULL,
  mar = c(2, 2, 2, 0.5),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.bvar_irf_+3A_x">x</code></td>
<td>
<p>A <code>bvar_irf</code> object, obtained from <code><a href="#topic+irf.bvar">irf.bvar</a></code>.</p>
</td></tr>
<tr><td><code id="plot.bvar_irf_+3A_vars_impulse">vars_impulse</code>, <code id="plot.bvar_irf_+3A_vars_response">vars_response</code></td>
<td>
<p>Optional numeric or character vector. Used
to subset the plot's impulses / responses to certain variables by position
or name (must be available). Defaults to <code>NULL</code>, i.e. all variables.</p>
</td></tr>
<tr><td><code id="plot.bvar_irf_+3A_col">col</code></td>
<td>
<p>Character vector. Colour(s) of the lines delineating credible
intervals. Single values will be recycled if necessary. Recycled HEX color
codes are varied in transparency if not provided (e.g. &quot;#737373FF&quot;). Lines
can be bypassed by setting this to <code>"transparent"</code>.</p>
</td></tr>
<tr><td><code id="plot.bvar_irf_+3A_area">area</code></td>
<td>
<p>Logical scalar. Whether to fill the credible intervals using
<code><a href="graphics.html#topic+polygon">polygon</a></code>.</p>
</td></tr>
<tr><td><code id="plot.bvar_irf_+3A_fill">fill</code></td>
<td>
<p>Character vector. Colour(s) to fill the credible intervals with.
See <em>col</em> for more information.</p>
</td></tr>
<tr><td><code id="plot.bvar_irf_+3A_variables">variables</code></td>
<td>
<p>Optional character vector. Names of all variables in the
object. Used to subset and title. Taken from <code>x$variables</code> if available.</p>
</td></tr>
<tr><td><code id="plot.bvar_irf_+3A_mar">mar</code></td>
<td>
<p>Numeric vector. Margins for <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.bvar_irf_+3A_...">...</code></td>
<td>
<p>Other graphical parameters for <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <em>x</em> invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bvar">bvar</a></code>; <code><a href="#topic+irf.bvar">irf.bvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Access a subset of the fred_qd dataset
data &lt;- fred_qd[, c("CPIAUCSL", "UNRATE", "FEDFUNDS")]
# Transform it to be stationary
data &lt;- fred_transform(data, codes = c(5, 5, 1), lag = 4)

# Estimate a BVAR using one lag, default settings and very few draws
x &lt;- bvar(data, lags = 1, n_draw = 1000L, n_burn = 200L, verbose = FALSE)

# Store IRFs ex-post
irf(x) &lt;- irf(x)

# Plot impulse responses for all available variables
plot(irf(x))

# Subset to impulse variables in positions 2 and 3 via their name
plot(irf(x), vars_impulse = c(2, 3))

# Subset via position and increase the plotted IRF horizon
plot(irf(x, horizon = 20), vars_impulse = c("UNRATE", "FED"))

# Adjust confidence bands and subset to one response variables
plot(irf(x, conf_bands = 0.25), vars_response = "CPI")

# Draw areas inbetween the confidence bands and skip drawing lines
plot(irf(x), col = "transparent", area = TRUE)

# Subset to a specific impulse and response
plot(irf(x), vars_response = "CPI", vars_impulse = "FED")

</code></pre>

<hr>
<h2 id='predict.bvar'>Predict method for Bayesian VARs</h2><span id='topic+predict.bvar'></span><span id='topic+predict+3C-'></span><span id='topic+summary.bvar_fcast'></span>

<h3>Description</h3>

<p>Retrieves / calculates forecasts for Bayesian VARs generated via
<code><a href="#topic+bvar">bvar</a></code>. If a forecast is already present and no settings are
supplied it is simply retrieved, otherwise it will be calculated.
To store the results you may want to assign the output using the setter
function (<code>predict(x) &lt;- predict(x)</code>). May also be used to update
confidence bands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvar'
predict(object, ..., conf_bands, n_thin = 1L, newdata)

predict(object) &lt;- value

## S3 method for class 'bvar_fcast'
summary(object, vars = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.bvar_+3A_object">object</code></td>
<td>
<p>A <code>bvar</code> object, obtained from <code><a href="#topic+bvar">bvar</a></code>.
Summary and print methods take in a <code>bvar_fcast</code> object.</p>
</td></tr>
<tr><td><code id="predict.bvar_+3A_...">...</code></td>
<td>
<p>A <code>bv_fcast</code> object or parameters to be fed into
<code><a href="#topic+bv_fcast">bv_fcast</a></code>. Contains settings for the forecast.</p>
</td></tr>
<tr><td><code id="predict.bvar_+3A_conf_bands">conf_bands</code></td>
<td>
<p>Numeric vector of confidence bands to apply.
E.g. for bands at 5%, 10%, 90% and 95% set this to <code>c(0.05, 0.1)</code>.
Note that the median, i.e. 0.5 is always included.</p>
</td></tr>
<tr><td><code id="predict.bvar_+3A_n_thin">n_thin</code></td>
<td>
<p>Integer scalar. Every <em>n_thin</em>'th draw in <em>object</em>
is used to predict, others are dropped.</p>
</td></tr>
<tr><td><code id="predict.bvar_+3A_newdata">newdata</code></td>
<td>
<p>Optional numeric matrix or dataframe. Used to base the
prediction on.</p>
</td></tr>
<tr><td><code id="predict.bvar_+3A_value">value</code></td>
<td>
<p>A <code>bvar_fcast</code> object to assign.</p>
</td></tr>
<tr><td><code id="predict.bvar_+3A_vars">vars</code></td>
<td>
<p>Optional numeric or character vector. Used to subset the summary
to certain variables by position or name (must be available). Defaults to
<code>NULL</code>, i.e. all variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of class <code>bvar_fcast</code> including forecasts
at desired confidence bands.
The summary method returns a numeric array of forecast paths at the
specified confidence bands.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.bvar_fcast">plot.bvar_fcast</a></code>; <code><a href="#topic+bv_fcast">bv_fcast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Access a subset of the fred_qd dataset
data &lt;- fred_qd[, c("CPIAUCSL", "UNRATE", "FEDFUNDS")]
# Transform it to be stationary
data &lt;- fred_transform(data, codes = c(5, 5, 1), lag = 4)

# Estimate a BVAR using one lag, default settings and very few draws
x &lt;- bvar(data, lags = 1, n_draw = 1000L, n_burn = 200L, verbose = FALSE)

# Calculate a forecast with an increased horizon
y &lt;- predict(x, horizon = 20)

# Add some confidence bands and store the forecast
predict(x) &lt;- predict(x, conf_bands = c(0.05, 0.16))

# Recalculate with different settings and increased thinning
predict(x, bv_fcast(24L), n_thin = 10L)

# Simulate some new data to predict on
predict(x, newdata = matrix(rnorm(300), ncol = 3))

# Calculate a conditional forecast (with a constrained second variable).
predict(x, cond_path = c(1, 1, 1, 1, 1, 1), cond_var = 2)

# Get a summary of the stored forecast
summary(x)

# Only get the summary for variable #2
summary(x, vars = 2L)

</code></pre>

<hr>
<h2 id='rmse.bvar'>Model fit in- and out-of-sample</h2><span id='topic+rmse.bvar'></span><span id='topic+lps.bvar'></span><span id='topic+rmse'></span><span id='topic+rmse.default'></span><span id='topic+lps'></span><span id='topic+lps.default'></span>

<h3>Description</h3>

<p>Functions to compute the root mean squared error and log predictive scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvar'
rmse(x, holdout, ...)

## S3 method for class 'bvar'
lps(x, holdout, n_thin = 1L, ...)

rmse(x, ...)

## Default S3 method:
rmse(x, ...)

lps(x, ...)

## Default S3 method:
lps(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmse.bvar_+3A_x">x</code></td>
<td>
<p>A <code>bvar</code> object, obtained from <code><a href="#topic+bvar">bvar</a></code>.</p>
</td></tr>
<tr><td><code id="rmse.bvar_+3A_holdout">holdout</code></td>
<td>
<p>Optional numeric matrix or dataframe. Used for the
out-of-sample fit.</p>
</td></tr>
<tr><td><code id="rmse.bvar_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="rmse.bvar_+3A_n_thin">n_thin</code></td>
<td>
<p>Integer scalar. Every <em>n_thin</em>'th draw in <em>x</em> is used
to calculate, others are dropped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with measures of model fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Access a subset of the fred_qd dataset
data &lt;- fred_qd[, c("CPIAUCSL", "UNRATE", "FEDFUNDS")]
# Transform it to be stationary
data &lt;- fred_transform(data, codes = c(5, 5, 1), lag = 4)

# Estimate a BVAR using one lag, default settings and very few draws
x &lt;- bvar(data[seq(1, nrow(data) - 5), ], lags = 1,
  n_draw = 600L, n_burn = 100L, verbose = FALSE)

# Compute RMSE
rmse(x)
lps(x, holdout = data[seq(nrow(data) - 4, nrow(data)), ])

</code></pre>

<hr>
<h2 id='summary.bvar'>Summary method for Bayesian VARs</h2><span id='topic+summary.bvar'></span>

<h3>Description</h3>

<p>Retrieves several outputs of interest, including the median coefficient
matrix, the median variance-covariance matrix, and the log-likelihood.
Separate summary methods exist for impulse responses and forecasts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvar'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.bvar_+3A_object">object</code></td>
<td>
<p>A <code>bvar</code> object, obtained from <code><a href="#topic+bvar">bvar</a></code>.</p>
</td></tr>
<tr><td><code id="summary.bvar_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of class <code>bvar_summary</code> with elements that can
can be accessed individually:
</p>

<ul>
<li> <p><code>bvar</code> - the <code>bvar</code> object provided.
</p>
</li>
<li> <p><code>coef</code> - coefficient values from <code><a href="#topic+coef.bvar">coef.bvar</a></code>.
</p>
</li>
<li> <p><code>vcov</code> - VCOV values from <code><a href="#topic+vcov.bvar">vcov.bvar</a></code>.
</p>
</li>
<li> <p><code>logLik</code> - the log-likelihood from <code><a href="stats.html#topic+logLik">logLik</a></code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+bvar">bvar</a></code>;
<code><a href="#topic+predict.bvar">predict.bvar</a></code>; <code><a href="#topic+irf.bvar">irf.bvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Access a subset of the fred_qd dataset
data &lt;- fred_qd[, c("CPIAUCSL", "UNRATE", "FEDFUNDS")]
# Transform it to be stationary
data &lt;- fred_transform(data, codes = c(5, 5, 1), lag = 4)

# Estimate a BVAR using one lag, default settings and very few draws
x &lt;- bvar(data, lags = 1, n_draw = 1000L, n_burn = 200L, verbose = FALSE)

summary(x)

</code></pre>

<hr>
<h2 id='WAIC.bvar'>Widely applicable information criterion (WAIC) for Bayesian VARs</h2><span id='topic+WAIC.bvar'></span><span id='topic+WAIC'></span><span id='topic+WAIC.default'></span>

<h3>Description</h3>

<p>Calculates the widely applicable (or Watanabe-Akaike) information criterion
(Watanabe, 2010) for VAR models generated with <code><a href="#topic+bvar">bvar</a></code>. The
result equals </p>
<p style="text-align: center;"><code class="reqn">-2 (\text{lppd} - \text{pWAIC}</code>
</p>
<p>, where 'lppd' is the
log pointwise predictive density, and 'pWAIC' is the effective number of
parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvar'
WAIC(x, n_thin = 1L, ...)

WAIC(x, ...)

## Default S3 method:
WAIC(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WAIC.bvar_+3A_x">x</code></td>
<td>
<p>A <code>bvar</code> object, obtained from <code><a href="#topic+bvar">bvar</a></code>.</p>
</td></tr>
<tr><td><code id="WAIC.bvar_+3A_n_thin">n_thin</code></td>
<td>
<p>Integer scalar. Every <em>n_thin</em>'th draw in <em>x</em> is used
to calculate, others are dropped.</p>
</td></tr>
<tr><td><code id="WAIC.bvar_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numerical value.
</p>


<h3>References</h3>

<p>Watanabe, S. (2010) Asymptotic Equivalence of Bayes Cross Validation and
Widely Applicable Information Criterion in Singular Learning Theory.
<em>Journal of Machine Learning Research</em>, <b>11</b>, 3571-3594.
</p>
<p>Kuschnig, N. and Vashold, L. (2021) BVAR: Bayesian Vector Autoregressions
with Hierarchical Prior Selection in R.
<em>Journal of Statistical Software</em>, <b>14</b>, 1-27,
<a href="https://doi.org/10.18637/jss.v100.i14">doi:10.18637/jss.v100.i14</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bvar">bvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Access a subset of the fred_qd dataset
data &lt;- fred_qd[, c("CPIAUCSL", "UNRATE", "FEDFUNDS")]
# Transform it to be stationary
data &lt;- fred_transform(data, codes = c(5, 5, 1), lag = 4)

# Estimate a BVAR using one lag, default settings and very few draws
x &lt;- bvar(data, lags = 1, n_draw = 600L, n_burn = 100L, verbose = FALSE)

# Calculate the log-likelihood
WAIC(x)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
