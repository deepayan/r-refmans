<!DOCTYPE html><html><head><title>Help for package zoo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {zoo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aggregate.zoo'><p>Compute Summary Statistics of zoo Objects</p></a></li>
<li><a href='#as.zoo'><p>Coercion from and to zoo</p></a></li>
<li><a href='#coredata'><p>Extracting/Replacing the Core Data of Objects</p></a></li>
<li><a href='#frequency&lt;-'><p>Replacing the Index of Objects</p></a></li>
<li><a href='#ggplot2.zoo'><p>Convenience Functions for Plotting zoo Objects with ggplot2</p></a></li>
<li><a href='#index'><p>Extracting/Replacing the Index of Objects</p></a></li>
<li><a href='#is.regular'><p>Check Regularity of a Series</p></a></li>
<li><a href='#lag.zoo'><p>Lags and Differences of zoo Objects</p></a></li>
<li><a href='#make.par.list'><p>Make a List from a Parameter Specification</p></a></li>
<li><a href='#MATCH'><p>Value Matching</p></a></li>
<li><a href='#merge.zoo'><p>Merge Two or More zoo Objects</p></a></li>
<li><a href='#na.aggregate'><p>Replace NA by Aggregation</p></a></li>
<li><a href='#na.approx'><p>Replace NA by Interpolation</p></a></li>
<li><a href='#na.fill'><p>Fill NA or specified positions.</p></a></li>
<li><a href='#na.locf'><p>Last Observation Carried Forward</p></a></li>
<li><a href='#na.StructTS'><p>Fill NA or specified positions.</p></a></li>
<li><a href='#na.trim'><p>Trim Leading/Trailing Missing Observations</p></a></li>
<li><a href='#ORDER'><p>Ordering Permutation</p></a></li>
<li><a href='#plot.zoo'><p>Plotting zoo Objects</p></a></li>
<li><a href='#read.zoo'><p>Reading and Writing zoo Series</p></a></li>
<li><a href='#rollapply'><p>Apply Rolling Functions</p></a></li>
<li><a href='#rollmean'><p>Rolling Means/Maximums/Medians/Sums</p></a></li>
<li><a href='#window.zoo'><p>Extract/Replacing the Time Windows of Objects</p></a></li>
<li><a href='#xblocks'>
<p>Plot contiguous blocks along x axis.</p></a></li>
<li><a href='#xyplot.zoo'><p>Plot zoo Series with Lattice</p></a></li>
<li><a href='#yearmon'><p>An Index Class for Monthly Data</p></a></li>
<li><a href='#yearqtr'><p>An Index Class for Quarterly Data</p></a></li>
<li><a href='#zoo'><p>Z's Ordered Observations</p></a></li>
<li><a href='#zooreg'><p>Regular zoo Series</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.8-12</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-11</td>
</tr>
<tr>
<td>Title:</td>
<td>S3 Infrastructure for Regular and Irregular Time Series (Z's
Ordered Observations)</td>
</tr>
<tr>
<td>Description:</td>
<td>An S3 class with methods for totally ordered indexed
             observations. It is particularly aimed at irregular time series
             of numeric vectors/matrices and factors. zoo's key design goals
             are independence of a particular index/date/time class and
             consistency with ts and base R by providing methods to extend
             standard generics.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0), stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>AER, coda, chron, ggplot2 (&ge; 3.0.0), mondate, scales,
stinepack, strucchange, timeDate, timeSeries, tis, tseries, xts</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, graphics, grDevices, lattice (&ge; 0.20-27)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://zoo.R-Forge.R-project.org/">https://zoo.R-Forge.R-project.org/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-11 21:24:32 UTC; zeileis</td>
</tr>
<tr>
<td>Author:</td>
<td>Achim Zeileis <a href="https://orcid.org/0000-0003-0918-3766"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Gabor Grothendieck [aut],
  Jeffrey A. Ryan [aut],
  Joshua M. Ulrich [ctb],
  Felix Andrews [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Achim Zeileis &lt;Achim.Zeileis@R-project.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-13 12:13:20 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.4.0; x86_64-pc-linux-gnu; 2024-01-02 07:34:07 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='aggregate.zoo'>Compute Summary Statistics of zoo Objects</h2><span id='topic+aggregate.zoo'></span><span id='topic+split.zoo'></span>

<h3>Description</h3>

<p>Splits a <code>"zoo"</code> object into subsets along a coarser index grid,
computes summary statistics for each, and returns the 
reduced <code>"zoo"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zoo'
aggregate(x, by, FUN = sum, ...,
  regular = NULL, frequency = NULL, coredata = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate.zoo_+3A_x">x</code></td>
<td>
<p>an object of class <code>"zoo"</code>.</p>
</td></tr>
<tr><td><code id="aggregate.zoo_+3A_by">by</code></td>
<td>
<p>index vector of the same length as <code>index(x)</code> which defines
aggregation groups and the new index to be associated with each group.
If <code>by</code> is a function, then it is applied to <code>index(x)</code> to
obtain the aggregation groups.</p>
</td></tr>
<tr><td><code id="aggregate.zoo_+3A_fun">FUN</code></td>
<td>
<p>a function to compute the summary statistics which can be applied
to all subsets. Always needs to return a result of fixed length (typically
scalar).</p>
</td></tr>
<tr><td><code id="aggregate.zoo_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="aggregate.zoo_+3A_regular">regular</code></td>
<td>
<p>logical. Should the aggregated series be coerced to class <code>"zooreg"</code>
(if the series is regular)? The default is <code>FALSE</code> for <code>"zoo"</code> series and
<code>TRUE</code> for <code>"zooreg"</code> series.</p>
</td></tr>
<tr><td><code id="aggregate.zoo_+3A_frequency">frequency</code></td>
<td>
<p>numeric indicating the frequency of the aggregated series
(if a <code>"zooreg"</code> series should be returned. The default is to
determine the frequency from the data if <code>regular</code> is <code>TRUE</code>.
If <code>frequency</code> is specified, it sets <code>regular</code> to <code>TRUE</code>.
See examples for illustration.</p>
</td></tr>
<tr><td><code id="aggregate.zoo_+3A_coredata">coredata</code></td>
<td>
<p>logical. Should only the <code>coredata(x)</code>
be passed to every <code>by</code> group? If set to <code>FALSE</code> the
full zoo series is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"zoo"</code> or <code>"zooreg"</code>.
</p>


<h3>Note</h3>

<p>The <code>xts</code> package functions <code>endpoints</code>, <code>period.apply</code> 
<code>to.period</code>, <code>to.weekly</code>, <code>to.monthly</code>, etc., 
can also directly input and output certain <code>zoo</code> objects and 
so can be used for aggregation tasks in some cases as well.</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+zoo">zoo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## averaging over values in a month:
# x.date is jan 1,3,5,7; feb 9,11,13; mar 15,17,19
x.date &lt;- as.Date(paste(2004, rep(1:4, 4:1), seq(1,20,2), sep = "-")); x.date
x &lt;- zoo(rnorm(12), x.date); x
# coarser dates - jan 1 (4 times), feb 1 (3 times), mar 1 (3 times)
x.date2 &lt;- as.Date(paste(2004, rep(1:4, 4:1), 1, sep = "-")); x.date2
x2 &lt;- aggregate(x, x.date2, mean); x2
# same - uses as.yearmon
x2a &lt;- aggregate(x, as.Date(as.yearmon(time(x))), mean); x2a
# same - uses by function
x2b &lt;- aggregate(x, function(tt) as.Date(as.yearmon(tt)), mean); x2b
# same - uses cut
x2c &lt;- aggregate(x, as.Date(cut(time(x), "month")), mean); x2c
# almost same but times of x2d have yearmon class rather than Date class
x2d &lt;- aggregate(x, as.yearmon, mean); x2d

# compare time series
plot(x)
lines(x2, col = 2)

## aggregate a daily time series to a quarterly series
# create zoo series
tt &lt;- as.Date("2000-1-1") + 0:300
z.day &lt;- zoo(0:300, tt)

# function which returns corresponding first "Date" of quarter
first.of.quarter &lt;- function(tt) as.Date(as.yearqtr(tt))

# average z over quarters
# 1. via "yearqtr" index (regular)
# 2. via "Date" index (not regular)
z.qtr1 &lt;- aggregate(z.day, as.yearqtr, mean)
z.qtr2 &lt;- aggregate(z.day, first.of.quarter, mean)

# The last one used the first day of the quarter but suppose
# we want the first day of the quarter that exists in the series
# (and the series does not necessarily start on the first day
# of the quarter).
z.day[!duplicated(as.yearqtr(time(z.day)))]

# This is the same except it uses the last day of the quarter.
# It requires R 2.6.0 which introduced the fromLast= argument.
## Not run: 
z.day[!duplicated(as.yearqtr(time(z.day)), fromLast = TRUE)]

## End(Not run)

# The aggregated series above are of class "zoo" (because z.day
# was "zoo"). To create a regular series of class "zooreg",
# the frequency can be automatically chosen
zr.qtr1 &lt;- aggregate(z.day, as.yearqtr, mean, regular = TRUE)
# or specified explicitely
zr.qtr2 &lt;- aggregate(z.day, as.yearqtr, mean, frequency = 4)


## aggregate on month and extend to monthly time series
if(require(chron)) {
y &lt;- zoo(matrix(11:15, nrow = 5, ncol = 2), chron(c(15, 20, 80, 100, 110)))
colnames(y) &lt;- c("A", "B")

# aggregate by month using first of month as times for coarser series
# using first day of month as repesentative time
y2 &lt;- aggregate(y, as.Date(as.yearmon(time(y))), head, 1)

# fill in missing months by merging with an empty series containing
# a complete set of 1st of the months
yrt2 &lt;- range(time(y2))
y0 &lt;- zoo(,seq(from = yrt2[1], to = yrt2[2], by = "month"))
merge(y2, y0)
}

# given daily series keep only first point in each month at
# day 21 or more
z &lt;- zoo(101:200, as.Date("2000-01-01") + seq(0, length = 100, by = 2))
zz &lt;- z[as.numeric(format(time(z), "%d")) &gt;= 21]
zz[!duplicated(as.yearmon(time(zz)))]

# same except times are of "yearmon" class
aggregate(zz, as.yearmon, head, 1)

# aggregate POSIXct seconds data every 10 minutes
Sys.setenv(TZ = "GMT")
tt &lt;- seq(10, 2000, 10)
x &lt;- zoo(tt, structure(tt, class = c("POSIXt", "POSIXct")))
aggregate(x, time(x) - as.numeric(time(x)) %% 600, mean)

# aggregate weekly series to a series with frequency of 52 per year
suppressWarnings(RNGversion("3.5.0"))
set.seed(1)
z &lt;- zooreg(1:100 + rnorm(100), start = as.Date("2001-01-01"), deltat = 7)

# new.freq() converts dates to a grid of freq points per year
# yd is sequence of dates of firsts of years
# yy is years of the same sequence
# last line interpolates so dates, d, are transformed to year + frac of year
# so first week of 2001 is 2001.0, second week is 2001 + 1/52, third week
# is 2001 + 2/52, etc.
new.freq &lt;- function(d, freq = 52) {
       y &lt;- as.Date(cut(range(d), "years")) + c(0, 367)
       yd &lt;- seq(y[1], y[2], "year")
       yy &lt;- as.numeric(format(yd, "%Y"))
       floor(freq * approx(yd, yy, xout = d)$y) / freq
}

# take last point in each period
aggregate(z, new.freq, tail, 1)

# or, take mean of all points in each
aggregate(z, new.freq, mean)

# example of taking means in the presence of NAs
z.na &lt;- zooreg(c(1:364, NA), start = as.Date("2001-01-01"))
aggregate(z.na, as.yearqtr, mean, na.rm = TRUE)

# Find the sd of all days that lie in any Jan, all days that lie in
# any Feb, ..., all days that lie in any Dec (i.e. output is vector with
# 12 components)
aggregate(z, format(time(z), "%m"), sd)

</code></pre>

<hr>
<h2 id='as.zoo'>Coercion from and to zoo</h2><span id='topic+as.zoo'></span><span id='topic+as.zoo.default'></span><span id='topic+as.zoo.data.frame'></span><span id='topic+as.zoo.fts'></span><span id='topic+as.zoo.its'></span><span id='topic+as.zoo.irts'></span><span id='topic+as.zoo.matrix'></span><span id='topic+as.zoo.mcmc'></span><span id='topic+as.zoo.tis'></span><span id='topic+as.zoo.xts'></span><span id='topic+as.zoo.zoo'></span><span id='topic+as.matrix.zoo'></span><span id='topic+as.vector.zoo'></span><span id='topic+as.data.frame.zoo'></span><span id='topic+as.list.zoo'></span><span id='topic+as.list.ts'></span><span id='topic+as.zoo.ts'></span><span id='topic+as.ts.zoo'></span>

<h3>Description</h3>

<p>Methods for coercing <code>"zoo"</code> objects to other classes and
a generic function <code>as.zoo</code> for coercing objects to class <code>"zoo"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.zoo(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.zoo_+3A_x">x</code></td>
<td>
<p>an object,</p>
</td></tr>
<tr><td><code id="as.zoo_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="zoo.html#topic+zoo">zoo</a></code> when the return
object is created.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as.zoo</code> currently has a default method and methods for <code><a href="stats.html#topic+ts">ts</a></code>,
<code>fts</code> (currently archived on CRAN), <code><a href="tseries.html#topic+irts">irts</a></code>,
<code><a href="coda.html#topic+mcmc">mcmc</a></code>, <code><a href="tis.html#topic+tis">tis</a></code>, <code><a href="xts.html#topic+xts">xts</a></code> 
objects (and <code><a href="zoo.html#topic+zoo">zoo</a></code> objects themselves).
</p>
<p>Methods for coercing objects of class <code>"zoo"</code> to other classes
currently include: <code><a href="stats.html#topic+as.ts">as.ts</a></code>, <code><a href="base.html#topic+as.matrix">as.matrix</a></code>, <code><a href="base.html#topic+as.vector">as.vector</a></code>,
<code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>, <code><a href="base.html#topic+as.list">as.list</a></code> (the latter also being available
for <code>"ts"</code> objects). Furthermore, <code><a href="zoo.html#topic+fortify.zoo">fortify.zoo</a></code> can transform <code>"zoo"</code>
series to <code>"data.frame"</code> including the time index and optionally melting a wide series
into a long data frame.
</p>
<p>In the conversion between <code>zoo</code> and <code>ts</code>, the <code><a href="zoo.html#topic+zooreg">zooreg</a></code> class is
always used.
</p>


<h3>Value</h3>

<p><code>as.zoo</code> returns a <code><a href="zoo.html#topic+zoo">zoo</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+zoo">zoo</a></code>, <code><a href="zoo.html#topic+fortify.zoo">fortify.zoo</a></code>,
<code><a href="zoo.html#topic+zooreg">zooreg</a></code>, <code><a href="stats.html#topic+ts">ts</a></code>, <code><a href="tseries.html#topic+irts">irts</a></code>, 
<code><a href="tis.html#topic+tis">tis</a></code>, <code><a href="coda.html#topic+mcmc">mcmc</a></code>,
<code><a href="xts.html#topic+xts">xts</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>suppressWarnings(RNGversion("3.5.0"))
set.seed(1)

## coercion to zoo:
## default method
as.zoo(rnorm(5))
## method for "ts" objects
as.zoo(ts(rnorm(5), start = 1981, freq = 12))

## coercion from zoo:
x.date &lt;- as.POSIXct(paste("2003-", rep(1:4, 4:1), "-", sample(1:28, 10, replace = TRUE), sep = ""))
x &lt;- zoo(matrix(rnorm(24), ncol = 2), x.date)
as.matrix(x)
as.vector(x)
as.data.frame(x)
as.list(x)
</code></pre>

<hr>
<h2 id='coredata'>Extracting/Replacing the Core Data of Objects</h2><span id='topic+coredata'></span><span id='topic+coredata.default'></span><span id='topic+coredata.zoo'></span><span id='topic+coredata.ts'></span><span id='topic+coredata.its'></span><span id='topic+coredata.irts'></span><span id='topic+coredata+3C-'></span><span id='topic+coredata+3C-.zoo'></span><span id='topic+coredata+3C-.ts'></span><span id='topic+coredata+3C-.irts'></span><span id='topic+coredata+3C-.its'></span>

<h3>Description</h3>

<p>Generic functions for extracting the core data contained in
a (more complex) object and replacing it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coredata(x, ...)
coredata(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coredata_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="coredata_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="coredata_+3A_value">value</code></td>
<td>
<p>a suitable value object for use with <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In <code>zoo</code>, there are currently <code>coredata</code> methods for time series
objects of class <code>"zoo"</code>, <code>"ts"</code>, <code>"its"</code>, <code>"irts"</code>, all of
which strip off the index/time attributes and return only the observations.
The are also corresponding replacement methods for these classes.
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+zoo">zoo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>suppressWarnings(RNGversion("3.5.0"))
set.seed(1)

x.date &lt;- as.Date(paste(2003, rep(1:4, 4:1), seq(1,20,2), sep = "-"))
x &lt;- zoo(matrix(rnorm(20), ncol = 2), x.date)

## the full time series
x
## and only matrix of observations
coredata(x)

## change the observations
coredata(x) &lt;- matrix(1:20, ncol = 2)
x
</code></pre>

<hr>
<h2 id='frequency+26lt+3B-'>Replacing the Index of Objects</h2><span id='topic+frequency+3C-'></span><span id='topic+frequency+3C-.zoo'></span><span id='topic+frequency+3C-.zooreg'></span>

<h3>Description</h3>

<p>Generic function for replacing the frequency of an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frequency(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frequency+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="frequency+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>a frequency.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>frequency&lt;-</code> is a generic function for replacing (or assigning)
the frequency of an object. Currently, there is a <code>"zooreg"</code> and
a <code>"zoo"</code> method. In both cases, the <code>value</code> is assigned
to the <code>"frequency"</code> of the object if it complies with the
<code>index(x)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+zooreg">zooreg</a></code>, <code><a href="quanteda.html#topic+index">index</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- zooreg(1:5)
z
as.ts(z)
frequency(z) &lt;- 3
z
as.ts(z)
</code></pre>

<hr>
<h2 id='ggplot2.zoo'>Convenience Functions for Plotting zoo Objects with ggplot2</h2><span id='topic+autoplot.zoo'></span><span id='topic+fortify.zoo'></span><span id='topic+ggplot2.zoo'></span><span id='topic+facet_free'></span><span id='topic+yearmon_trans'></span><span id='topic+yearqtr_trans'></span><span id='topic+scale_x_yearmon'></span><span id='topic+scale_y_yearmon'></span><span id='topic+scale_x_yearqtr'></span><span id='topic+scale_y_yearqtr'></span><span id='topic+scale_type.yearmon'></span><span id='topic+scale_type.yearqtr'></span>

<h3>Description</h3>

<p><code>fortify.zoo</code> takes a zoo object and converts it into a data frame
(intended for ggplot2). <code>autoplot.zoo</code> takes a zoo object and returns a
ggplot2 object. It essentially uses the mapping <code>aes(x = Time, y = Value, group = Series)</code>
and adds <code>colour = Series</code> in the case of a multivariate series with <code>facets = NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'zoo'
autoplot(object, geom = "line", facets, ...)
  ## S3 method for class 'zoo'
fortify(model, data, 
	names = c("Index", "Series", "Value"),
	melt = FALSE, sep = NULL, ...)
  facet_free(facets = Series ~ ., margins = FALSE, scales = "free_y", ...)

  yearmon_trans(format = "%b %Y", n = 5)
  scale_x_yearmon(..., format = "%b %Y", n = 5)
  scale_y_yearmon(..., format = "%b %Y", n = 5)

  yearqtr_trans(format = "%Y-%q", n = 5)
  scale_x_yearqtr(..., format = "%Y-%q", n = 5)
  scale_y_yearqtr(..., format = "%Y-%q", n = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot2.zoo_+3A_object">object</code></td>
<td>
<p>an object of class <code>"zoo"</code>.</p>
</td></tr>
<tr><td><code id="ggplot2.zoo_+3A_geom">geom</code></td>
<td>
<p>character (e.g., <code>"line"</code>) or function (e.g., <code><a href="ggplot2.html#topic+geom_line">geom_line</a></code>)
specifying which <code>geom</code> to use.</p>
</td></tr>
<tr><td><code id="ggplot2.zoo_+3A_facets">facets</code></td>
<td>
<p>specification of <code>facets</code> for <code><a href="ggplot2.html#topic+facet_grid">facet_grid</a></code>. The
default in the <code>autoplot</code> method is to use <code>facets = NULL</code> for univariate
series and <code>facets = Series ~ .</code> for multivariate series.</p>
</td></tr>
<tr><td><code id="ggplot2.zoo_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="ggplot2.html#topic+aes">aes</a></code>
for <code>autoplot</code> (e.g., <code>linetype = Series</code> and/or <code>shape = Series</code>).
For <code>fortify</code> the arguments are not used. For the <code>scale_*_*</code>
functions the arguments are passed on to <code>scale_*_continuous</code>.</p>
</td></tr>
<tr><td><code id="ggplot2.zoo_+3A_model">model</code></td>
<td>
<p>an object of class <code>"zoo"</code> to be converted to
a <code>"data.frame"</code>.</p>
</td></tr>
<tr><td><code id="ggplot2.zoo_+3A_data">data</code></td>
<td>
<p>not used (required by generic <code><a href="ggplot2.html#topic+fortify">fortify</a></code>
method).</p>
</td></tr>
<tr><td><code id="ggplot2.zoo_+3A_names">names</code></td>
<td>
<p>(list of) character vector(s). New names given to index/time column,
series indicator (if melted), and value column (if melted). If only
a subset of characters should be changed, either NAs can be used
or a named vector.</p>
</td></tr>
<tr><td><code id="ggplot2.zoo_+3A_sep">sep</code></td>
<td>
<p>If specified then the Series column is split into multiple 
columns using sep as the split character.</p>
</td></tr>
<tr><td><code id="ggplot2.zoo_+3A_melt">melt</code></td>
<td>
<p>Should the resulting data frame be in long format (<code>melt = TRUE</code>)
or wide format (<code>melt = FALSE</code>).</p>
</td></tr>
<tr><td><code id="ggplot2.zoo_+3A_margins">margins</code></td>
<td>
<p>As in <code><a href="ggplot2.html#topic+facet_grid">facet_grid</a></code>.</p>
</td></tr>
<tr><td><code id="ggplot2.zoo_+3A_scales">scales</code></td>
<td>
<p>As in <code><a href="ggplot2.html#topic+facet_grid">facet_grid</a></code> except it defaults to <code>"free_y"</code>.</p>
</td></tr>
<tr><td><code id="ggplot2.zoo_+3A_format">format</code></td>
<td>
<p>A format acceptable to <a href="zoo.html#topic+format.yearmon">format.yearmon</a> or <a href="zoo.html#topic+format.yearqtr">format.yearqtr</a>.</p>
</td></tr>
<tr><td><code id="ggplot2.zoo_+3A_n">n</code></td>
<td>
<p>Approximate number of axis ticks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convenience interface for visualizing zoo objects with ggplot2.
<code>autoplot.zoo</code> uses <code>fortify.zoo</code> (with <code>melt = TRUE</code>)
to convert the zoo object into a data frame and then uses a suitable
<code>aes()</code> mapping to visiualize the series.
</p>


<h3>Value</h3>

<p><code>fortify.zoo</code> returns a <code>data.frame</code> either in long format
(<code>melt = TRUE</code>) or in wide format (<code>melt = FALSE</code>). The
long format has three columns: the time <code>Index</code>, a
factor indicating the <code>Series</code>, and the corresponding <code>Value</code>.
The wide format simply has the time <code>Index</code> plus all columns
of <code>coredata(model)</code>.
</p>
<p><code>autoplot.zoo</code> returns a <code>ggplot</code> object.
</p>


<h3>Author(s)</h3>

<p>Trevor L. Davis <a href="mailto:trevor.l.davis@gmail.com">trevor.l.davis@gmail.com</a>, Achim Zeileis
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+autoplot">autoplot</a></code>, <code><a href="ggplot2.html#topic+fortify">fortify</a></code>, <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("ggplot2") &amp;&amp; require("scales")) {
suppressWarnings(RNGversion("3.5.0"))
set.seed(1)

## example data
x.Date &lt;- as.Date(paste(2003, 02, c(1, 3, 7, 9, 14), sep = "-"))
x &lt;- zoo(rnorm(5), x.Date)
xlow &lt;- x - runif(5)
xhigh &lt;- x + runif(5)
z &lt;- cbind(x, xlow, xhigh)

## univariate plotting
autoplot(x)
## by hand
ggplot(aes(x = Index, y = Value), data = fortify(x, melt = TRUE)) +
  geom_line() + xlab("Index") + ylab("x")
## adding series one at a time
last_plot() + geom_line(aes(x = Index, y = xlow), colour = "red", data = fortify(xlow))
## add ribbon for high/low band
ggplot(aes(x = Index, y = x, ymin = xlow, ymax = xhigh), data = fortify(x)) +
  geom_ribbon(fill = "darkgray") + geom_line()

## multivariate plotting in multiple or single panels
autoplot(z)                      ## multiple without color/linetype
autoplot(z, facets = Series ~ .) ## multiple with series-dependent color/linetype
autoplot(z, facets = NULL)       ## single with series-dependent color/linetype
## by hand with color/linetype and with/without facets
ggz &lt;- ggplot(aes(x = Index, y = Value, group = Series, colour = Series, linetype = Series),
  data = fortify(z, melt = TRUE)) + geom_line() + xlab("Index") + ylab("")
ggz
ggz + facet_grid(Series ~ .)
## variations
autoplot(z, geom = "point")
autoplot(z, facets = NULL) + geom_point()
autoplot(z, facets = NULL) + scale_colour_grey() + theme_bw()

## for "ts" series via coercion
autoplot(as.zoo(EuStockMarkets))
autoplot(as.zoo(EuStockMarkets), facets = NULL)

autoplot(z) + 
	aes(colour = NULL, linetype = NULL) +
	facet_grid(Series ~ ., scales = "free_y")

autoplot(z) + aes(colour = NULL, linetype = NULL) + facet_free() # same

z.yq &lt;- zooreg(rnorm(50), as.yearqtr("2000-1"), freq = 4)
autoplot(z.yq)

## mimic matplot
data &lt;- cbind(A = c(6, 1, NA, NA), B = c(16, 4, 1, NA), C = c(25, 7, 2, 1))
autoplot(zoo(data), facet = NULL) + geom_point()
## with different line types
autoplot(zoo(data), facet = NULL) + geom_point() + aes(linetype = Series)

## illustrate just fortify() method
z &lt;- zoo(data)
fortify(z)
fortify(z, melt = TRUE)
fortify(z, melt = TRUE, names = c("Time", NA, "Data"))
fortify(z, melt = TRUE, names = c(Index = "Time"))

## with/without splitting
z &lt;- zoo(cbind(a.A = 1:2, a.B = 2:3, b.A = 3:4, c.B = 4:5))
fortify(z)
fortify(z, melt = TRUE, sep = ".", names = list(Series = c("Lower", "Upper")))

## scale_x_yearmon with custom discrete breaks
df &lt;-  data.frame(dates = as.yearmon("2018-08") + 0:6/12, values = c(2:6, 0, 1))
ggdf &lt;- ggplot(df, aes(x = dates, y = values)) +
  geom_bar(position = "dodge", stat = "identity") + theme_light() +
  xlab("Month") + ylab("Values")
ggdf ## with default scale_x_yearmon
ggdf + scale_x_yearmon(breaks = df$dates) ## with custom discrete breaks
}
</code></pre>

<hr>
<h2 id='index'>Extracting/Replacing the Index of Objects</h2><span id='topic+index'></span><span id='topic+index.default'></span><span id='topic+index.zoo'></span><span id='topic+index.ts'></span><span id='topic+time.zoo'></span><span id='topic+index+3C-'></span><span id='topic+index+3C-.zoo'></span><span id='topic+time+3C-'></span><span id='topic+time+3C-.zoo'></span><span id='topic+start.zoo'></span><span id='topic+end.zoo'></span>

<h3>Description</h3>

<p>Generic functions for extracting the index of an object
and replacing it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index(x, ...)
index(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="index_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="index_+3A_value">value</code></td>
<td>
<p>an ordered vector of the same length
as the <code>"index"</code> attribute of <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>index</code> is a generic function for extracting the index
of objects, currently it has a default method and a method
for <code><a href="zoo.html#topic+zoo">zoo</a></code> objects which is the same as the
<code><a href="stats.html#topic+time">time</a></code> method for <code><a href="zoo.html#topic+zoo">zoo</a></code> objects.
Another pair of generic functions provides replacing
the <code>index</code> or <code>time</code> attribute. 
Methods are available for <code>"zoo"</code> objects only, see examples below.
</p>
<p>The start and end of the index/time can be queried by using
the methods of <code>start</code> and <code>end</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+time">time</a></code>, <code><a href="zoo.html#topic+zoo">zoo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>suppressWarnings(RNGversion("3.5.0"))
set.seed(1)

x.date &lt;- as.Date(paste(2003, 2, c(1, 3, 7, 9, 14), sep = "-"))
x &lt;- zoo(rnorm(5), x.date)

## query index/time of a zoo object
index(x)
time(x)

## change class of index from Date to POSIXct
## relative to current time zone
x
index(x) &lt;- as.POSIXct(format(time(x)),tz="")
x

## replace index/time of a zoo object
index(x) &lt;- 1:5
x
time(x) &lt;- 6:10
x

## query start and end of a zoo object
start(x)
end(x)

## query index of a usual matrix
xm &lt;- matrix(rnorm(10), ncol = 2)
index(xm)
</code></pre>

<hr>
<h2 id='is.regular'>Check Regularity of a Series</h2><span id='topic+is.regular'></span><span id='topic+is.regular.zoo'></span><span id='topic+is.regular.ts'></span><span id='topic+is.regular.zooreg'></span><span id='topic+is.regular.default'></span>

<h3>Description</h3>

<p><code>is.regular</code> is a regular function for checking whether a series of ordered observations
has an underlying regularity or is even strictly regular.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.regular(x, strict = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.regular_+3A_x">x</code></td>
<td>
<p>an object (representing a series of ordered observations).</p>
</td></tr>
<tr><td><code id="is.regular_+3A_strict">strict</code></td>
<td>
<p>logical. Should strict regularity be checked? See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A time series can either be irregular (unequally spaced), strictly regular (equally spaced)
or have an underlying regularity, i.e., be created from a regular series by
omitting some observations. Here, the latter property is called <em>regular</em>.
Consequently, regularity follows from strict regularity but not vice versa.
</p>
<p><code>is.regular</code> is a generic function for checking regularity (default) or
strict regularity. Currently, it has methods for <code>"ts"</code> objects (which are
always strictly regular), <code>"zooreg"</code> objects (which are at least regular),
<code>"zoo"</code> objects (which can be either irregular, regular or even strictly regular)
and a default method. The latter coerces <code>x</code> to <code>"zoo"</code> before checking
its regularity. 
</p>


<h3>Value</h3>

<p>A logical is returned indicating whether <code>x</code> is (strictly) regular.
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+zooreg">zooreg</a></code>, <code><a href="zoo.html#topic+zoo">zoo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## checking of a strictly regular zoo series
z &lt;- zoo(1:10, seq(2000, 2002.25, by = 0.25), frequency = 4)
z
class(z)
frequency(z) ## extraction of frequency attribute
is.regular(z)
is.regular(z, strict = TRUE)
## by omitting observations, the series is not strictly regular
is.regular(z[-3])
is.regular(z[-3], strict = TRUE)

## checking of a plain zoo series without frequency attribute
## which is in fact regular
z &lt;- zoo(1:10, seq(2000, 2002.25, by = 0.25))
z
class(z)
frequency(z) ## data driven computation of frequency
is.regular(z)
is.regular(z, strict = TRUE)
## by omitting observations, the series is not strictly regular
is.regular(z[-3])
is.regular(z[-3], strict = TRUE)

suppressWarnings(RNGversion("3.5.0"))
set.seed(1)

## checking of an irregular zoo series
z &lt;- zoo(1:10, rnorm(10))
z
class(z)
frequency(z) ## attempt of data-driven frequency computation
is.regular(z)
is.regular(z, strict = TRUE)
</code></pre>

<hr>
<h2 id='lag.zoo'>Lags and Differences of zoo Objects</h2><span id='topic+lag.zoo'></span><span id='topic+diff.zoo'></span>

<h3>Description</h3>

<p>Methods for computing lags and differences of <code>"zoo"</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zoo'
lag(x, k = 1, na.pad = FALSE, ...)
## S3 method for class 'zoo'
diff(x, lag = 1, differences = 1, arithmetic = TRUE, na.pad = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lag.zoo_+3A_x">x</code></td>
<td>
<p>a <code>"zoo"</code> object.</p>
</td></tr>
<tr><td><code id="lag.zoo_+3A_k">k</code>, <code id="lag.zoo_+3A_lag">lag</code></td>
<td>
<p>For <code>lag</code> the number of lags (in units of observations).
Note the sign of <code>k</code> behaves as in <code><a href="stats.html#topic+lag">lag</a></code>.
For <code>diff</code> it is the number of backward lags used (or if negative the
number of forward lags.</p>
</td></tr>
<tr><td><code id="lag.zoo_+3A_differences">differences</code></td>
<td>
<p>an integer indicating the order of the difference.</p>
</td></tr>
<tr><td><code id="lag.zoo_+3A_arithmetic">arithmetic</code></td>
<td>
<p>logical. Should arithmetic (or geometric) differences be computed?</p>
</td></tr>
<tr><td><code id="lag.zoo_+3A_na.pad">na.pad</code></td>
<td>
<p>logical. If <code>TRUE</code> it adds any times that would not otherwise have been in
the result with a value of <code>NA</code>.  If <code>FALSE</code> those times are dropped.</p>
</td></tr>
<tr><td><code id="lag.zoo_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These methods for <code>"zoo"</code> objects behave analogously to the default
methods. The only additional arguments are <code>arithmetic</code> in <code>diff</code>
<code>na.pad</code> in <code>lag.zoo</code> which can also be specified in <code>diff.zoo</code>
as part of the dots.
Also, <code>"k"</code> can be a vector of lags in which case the names of
<code>"k"</code>, if any, are used in naming the result.
</p>


<h3>Value</h3>

<p>The lagged or differenced <code>"zoo"</code> object.
</p>


<h3>Note</h3>

<p>Note the sign of <code>k</code>: a series lagged by a positive <code>k</code>
is shifted <em>earlier</em> in time.
</p>
<p><code>lag.zoo</code> and <code>lag.zooreg</code> can give different results.
For a lag of 1 <code>lag.zoo</code> moves points to the adjacent time point
whereas <code>lag.zooreg</code> moves the time by <code>deltat</code>.  This
implies that a point in a <code>zoo</code> series cannot be lagged to a time 
point that is not already in the series whereas this is possible for
a <code>zooreg</code> series.  
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+zoo">zoo</a></code>, <code><a href="stats.html#topic+lag">lag</a></code>, <code><a href="base.html#topic+diff">diff</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- zoo(11:21)

lag(x, k = 1)
lag(x, k = -1)
# this pairs each value of x with the next or future value
merge(x, lag1 = lag(x, k=1))
diff(x^3)
diff(x^3, -1)
diff(x^3, na.pad = TRUE)

</code></pre>

<hr>
<h2 id='make.par.list'>Make a List from a Parameter Specification</h2><span id='topic+make.par.list'></span>

<h3>Description</h3>

<p>Process parameters so that a list of parameter
specifications is returned (used by <code>plot.zoo</code> and
<code>xyplot.zoo</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.par.list(nams, x, n, m, def, recycle = sum(unnamed) &gt; 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.par.list_+3A_nams">nams</code></td>
<td>
<p>character vector with names of variables.</p>
</td></tr>
<tr><td><code id="make.par.list_+3A_x">x</code></td>
<td>
<p>list or vector of parameter specifications, see details.</p>
</td></tr>
<tr><td><code id="make.par.list_+3A_n">n</code></td>
<td>
<p>numeric, number of rows.</p>
</td></tr>
<tr><td><code id="make.par.list_+3A_m">m</code></td>
<td>
<p>numeric, number of columns. (Only determines whether <code>m</code>
is 1 or greater than 1.</p>
</td></tr>
<tr><td><code id="make.par.list_+3A_def">def</code></td>
<td>
<p>default parameter value.</p>
</td></tr>
<tr><td><code id="make.par.list_+3A_recycle">recycle</code></td>
<td>
<p>logical. If <code>TRUE</code> recycle columns to provide
unspecified ones. If <code>FALSE</code> use <code>def</code> to provide unspecified
ones. This only applies to entire columns. Within columns recycling is
always done regardless of how <code>recycle</code> is set. Defaults to
<code>TRUE</code> if there is at least one unnamed variable and defaults to
<code>FALSE</code> if there are only named variables in <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is currently intended for internal use.  It is currently 
used by 
<code>plot.zoo</code> and <code>xyplot.zoo</code> but might also be used in the future
to create additional new plotting routines.
It creates a new list which uses the named variables from <code>x</code>
and then assigns the unnamed in order.  For the remaining variables
assign them the default value if <code>!recycle</code> or recycle the
unnamed variables if <code>recycle</code>.
</p>


<h3>Value</h3>

<p>A list of parameters, see details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make.par.list(letters[1:5], 1:5, 3, 5)
suppressWarnings( make.par.list(letters[1:5], 1:4, 3, 5, 99) )
make.par.list(letters[1:5], c(d=3), 3, 5, 99)
make.par.list(letters[1:5], list(d=1:2, 99), 3, 5)
make.par.list(letters[1:5], list(d=1:2, 99, 100), 3, 5)
</code></pre>

<hr>
<h2 id='MATCH'>Value Matching</h2><span id='topic+MATCH'></span><span id='topic+MATCH.default'></span><span id='topic+MATCH.times'></span><span id='topic+MATCH.timeDate'></span><span id='topic+MATCH.Date'></span><span id='topic+MATCH.POSIXct'></span><span id='topic+MATCH.POSIXlt'></span>

<h3>Description</h3>

<p><code>MATCH</code> is a generic function for value matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MATCH(x, table, nomatch = NA, ...)
## S3 method for class 'times'
MATCH(x, table, nomatch = NA, units = "sec", eps = 1e-10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MATCH_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="MATCH_+3A_table">table</code></td>
<td>
<p>the values to be matched against.</p>
</td></tr>
<tr><td><code id="MATCH_+3A_nomatch">nomatch</code></td>
<td>
<p>the value to be returned in the case when no match is
found.  Note that it is coerced to <code>integer</code>.</p>
</td></tr>
<tr><td><code id="MATCH_+3A_units">units</code></td>
<td>
<p>See <code><a href="chron.html#topic+trunc.times">trunc.times</a></code>.</p>
</td></tr>
<tr><td><code id="MATCH_+3A_eps">eps</code></td>
<td>
<p>See <code><a href="chron.html#topic+trunc.times">trunc.times</a></code>.</p>
</td></tr>
<tr><td><code id="MATCH_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MATCH</code> is a new generic function which aims at providing
the functionality of the non-generic base function <code><a href="base.html#topic+match">match</a></code>
for arbitrary objects. Currently, there is a default method which
simply calls <code><a href="base.html#topic+match">match</a></code> and various methods for time/date
objects.
</p>
<p>The <code>MATCH</code> method for <code>Date</code> objects coerces the <code>table</code>
to <code>Date</code> as well (if necessary) and then uses
<code>match(unclass(x), unclass(table), ...</code>. Similarly, the <code>MATCH</code>
methods for <code>POSIXct</code>, <code>POSIXlt</code>, and <code>timeDate</code> coerce
both <code>x</code> and <code>table</code> to <code>POSIXct</code> and then match the unclassed
objects.
</p>
<p><code>MATCH.times</code> is used for <code>chron</code> objects. <code>x</code> will
match any time in <code>table</code> less than <code>units</code> away.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+match">match</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>MATCH(1:5, 2:3)
</code></pre>

<hr>
<h2 id='merge.zoo'>Merge Two or More zoo Objects</h2><span id='topic+merge.zoo'></span><span id='topic+rbind.zoo'></span><span id='topic+c.zoo'></span><span id='topic+cbind.zoo'></span>

<h3>Description</h3>

<p>Merge two zoo objects by common indexes (times), or do other
versions of database <em>join</em> operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zoo'
merge(..., all = TRUE, fill = NA, suffixes = NULL,
  check.names = FALSE, retclass = c("zoo", "list", "data.frame"),
  drop = TRUE, sep = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge.zoo_+3A_...">...</code></td>
<td>
<p>two or more objects, usually of class <code>"zoo"</code>.</p>
</td></tr>
<tr><td><code id="merge.zoo_+3A_all">all</code></td>
<td>
<p>logical vector having the same length as the number of <code>"zoo"</code>
objects to be merged (otherwise expanded).</p>
</td></tr>
<tr><td><code id="merge.zoo_+3A_fill">fill</code></td>
<td>
<p>an element for filling gaps in merged <code>"zoo"</code>
objects (if any).</p>
</td></tr>
<tr><td><code id="merge.zoo_+3A_suffixes">suffixes</code></td>
<td>
<p>character vector of the same length as the number of
<code>"zoo"</code> objects specifying the suffixes to be used for making
the merged column names unique.</p>
</td></tr>
<tr><td><code id="merge.zoo_+3A_check.names">check.names</code></td>
<td>
<p>See <code>link{read.table}</code>.</p>
</td></tr>
<tr><td><code id="merge.zoo_+3A_retclass">retclass</code></td>
<td>
<p>character that specifies the class of the returned result.
It can be <code>"zoo"</code> (the default), <code>"list"</code> or <code>NULL</code>. For 
details see below.</p>
</td></tr>
<tr><td><code id="merge.zoo_+3A_drop">drop</code></td>
<td>
<p>logical. If a <code>"zoo"</code> object without observations is
merged with a one-dimensional <code>"zoo"</code> object (vector or 1-column
matrix), should the result be a vector (<code>drop = TRUE</code>) or a
1-column matrix (<code>drop = FALSE</code>)? The former is the default
in the <code>Merge</code> method, the latter in the <code>cbind</code> method.</p>
</td></tr>
<tr><td><code id="merge.zoo_+3A_sep">sep</code></td>
<td>
<p>character. Separator character that should be used when
pasting <code>suffixes</code> to column names for making them unique.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>merge</code> method for <code>"zoo"</code> objects combines the columns
of several objects along the union of the dates 
for <code>all = TRUE</code>, the default,
or the intersection of their dates for <code>all = FALSE</code>
filling up the created gaps (if any) with the <code>fill</code> pattern.
</p>
<p>The first argument must be a <code>zoo</code> object.   If any of the remaining
arguments are plain vectors or matrices with the same length or number
of rows as the first argument then such arguments are coerced to <code>"zoo"</code>
using <code>as.zoo</code>.  If they are plain but have length 1 then they are
merged after all non-scalars such that their column is filled with the
value of the scalar.
</p>
<p><code>all</code> can be a vector of the same length as the number of <code>"zoo"</code>
objects to merged (if not, it is expanded): All indexes
(times) of the objects corresponding to <code>TRUE</code> are included, for those
corresponding to <code>FALSE</code> only the indexes present in all objects are
included.  This allows intersection, union and left and right joins 
to be expressed.
</p>
<p>If <code>retclass</code> is <code>"zoo"</code> (the default) a single merged <code>"zoo"</code>
object is returned. If it is set to <code>"list"</code> a list of <code>"zoo"</code>
objects is returned. If <code>retclass = NULL</code> then instead of returning a value it updates each
argument (if it is a variable rather than an expression) in
place so as to extend or reduce it to use the common index vector.
</p>
<p>The indexes of different
<code>"zoo"</code> objects can be of different classes and are coerced to
one class in the resulting object (with a warning).
</p>
<p>The default <code>cbind</code> method is essentially the default <code>merge</code>
method, but does not support the <code>retclass</code> argument.
The <code>rbind</code>
method combines the dates of the <code>"zoo"</code> objects (duplicate dates are
not allowed) and combines the rows of the objects. Furthermore, the
<code>c</code> method is identical to the <code>rbind</code> method.
</p>


<h3>Value</h3>

<p>An object of class <code>"zoo"</code> if <code>retclass="zoo"</code>, an object of
class <code>"list"</code> if <code>retclass="list"</code> or modified arguments as
explained above if <code>retclass=NULL</code>.   If the result is an object
of class <code>"zoo"</code> then its frequency is the common frequency of its
zoo arguments, if they have a common frequency.
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+zoo">zoo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## simple merging
x.date &lt;- as.Date(paste(2003, 02, c(1, 3, 7, 9, 14), sep = "-"))
x &lt;- zoo(rnorm(5), x.date)

y1 &lt;- zoo(matrix(1:10, ncol = 2), 1:5)
y2 &lt;- zoo(matrix(rnorm(10), ncol = 2), 3:7)

## using arguments `fill' and `suffixes'
merge(y1, y2, all = FALSE)
merge(y1, y2, all = FALSE, suffixes = c("a", "b"))
merge(y1, y2, all = TRUE)
merge(y1, y2, all = TRUE, fill = 0)

## if different index classes are merged, as in
## the next merge example then ## a warning is issued and 
### the indexes are coerced.
## It is up to the user to ensure that the result makes sense.
merge(x, y1, y2, all = TRUE)

## extend an irregular series to a regular one:
# create a constant series
z &lt;- zoo(1, seq(4)[-2])
# create a 0 dimensional zoo series
z0 &lt;- zoo(, 1:4)
# do the extension
merge(z, z0)
# same but with zero fill
merge(z, z0, fill = 0)

merge(z, coredata(z),  1)


## merge multiple series represented in a long form data frame 
## into a multivariate zoo series and plot, one series for each site.
## Additional examples can be found here:
## https://stat.ethz.ch/pipermail/r-help/2009-February/187094.html
## https://stat.ethz.ch/pipermail/r-help/2009-February/187096.html
##
m &lt;- 5 # no of years
n &lt;- 6 # no of sites
sites &lt;- LETTERS[1:n]
suppressWarnings(RNGversion("3.5.0"))
set.seed(1)
DF &lt;- data.frame(site = sites, year = 2000 + 1:m, data = rnorm(m*n))
tozoo &lt;- function(x) zoo(x$data, x$year) 
Data &lt;- do.call(merge, lapply(split(DF, DF$site), tozoo))
plot(Data, screen = 1, col = 1:n, pch = 1:n, type = "o", xlab = "")
legend("bottomleft", legend = sites, lty = 1, pch = 1:n, col = 1:n)

## for each index value in x merge it with the closest index value in y
## but retaining x's times.
x&lt;-zoo(1:3,as.Date(c("1992-12-13", "1997-05-12", "1997-07-13")))
y&lt;-zoo(1:5,as.Date(c("1992-12-15", "1992-12-16", "1997-05-10","1997-05-19", "1997-07-13")))
f &lt;- function(u) which.min(abs(as.numeric(index(y)) - as.numeric(u)))
ix &lt;- sapply(index(x), f)
cbind(x, y = coredata(y)[ix])

## this merges each element of x with the closest time point in y at or
## after x's time point (whereas in previous example it could be before
## or after)
window(na.locf(merge(x, y), fromLast = TRUE), index(x))


## c() can combine several zoo series, e.g., zoo series with Date index
z &lt;- zoo(1:5, as.Date("2000-01-01") + 0:4)
z2 &lt;- zoo(6:7, time(z)[length(z)] + 1:2)

## c() combines these in a single series
c(z, z2)

## the order does not matter
c(z2, z)

## note, however, that combining a zoo series with an unclassed vector
## of observations would try to coerce the indexes first
## which might either give an unexpected result or an error in R &gt;= 4.1.0
## c(z, 6:7)

</code></pre>

<hr>
<h2 id='na.aggregate'>Replace NA by Aggregation</h2><span id='topic+na.aggregate'></span><span id='topic+na.aggregate.default'></span>

<h3>Description</h3>

<p>Generic function for replacing each <code>NA</code> with aggregated
values. This allows imputing by the overall mean, by monthly means,
etc. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na.aggregate(object, ...)
## Default S3 method:
na.aggregate(object, by = 1, ..., FUN = mean,
             na.rm = FALSE, maxgap = Inf)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na.aggregate_+3A_object">object</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="na.aggregate_+3A_by">by</code></td>
<td>
<p>a grouping variable corresponding to <code>object</code>, or a
function to be applied to <code>time(object)</code> to generate the
groups.</p>
</td></tr>
<tr><td><code id="na.aggregate_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>by</code> if <code>by</code> is a
function.</p>
</td></tr>
<tr><td><code id="na.aggregate_+3A_fun">FUN</code></td>
<td>
<p>function to apply to the non-missing values in each group
defined by <code>by</code>.</p>
</td></tr> 
<tr><td><code id="na.aggregate_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should any remaining <code>NA</code>s be removed?</p>
</td></tr>
<tr><td><code id="na.aggregate_+3A_maxgap">maxgap</code></td>
<td>
<p>maximum number of consecutive <code>NA</code>s to
fill. Any longer gaps will be left unchanged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object in which each <code>NA</code> in the input object is replaced
by the mean (or other function) of its group, defined by
<code>by</code>. This is done for each series in a multi-column object. Common
choices for the aggregation group are a year, a month, all calendar
months, etc.  
</p>
<p>If a group has no non-missing values, the default aggregation function
<code>mean</code> will return <code>NaN</code>. Specify <code>na.rm = TRUE</code> to
omit such remaining missing values.
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+zoo">zoo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- zoo(c(1, NA, 3:9),
         c(as.Date("2010-01-01") + 0:2,
           as.Date("2010-02-01") + 0:2,
           as.Date("2011-01-01") + 0:2))
## overall mean
na.aggregate(z)
## group by months
na.aggregate(z, as.yearmon)
## group by calendar months
na.aggregate(z, months)
## group by years
na.aggregate(z, format, "%Y")
</code></pre>

<hr>
<h2 id='na.approx'>Replace NA by Interpolation</h2><span id='topic+na.approx'></span><span id='topic+na.approx.zoo'></span><span id='topic+na.approx.zooreg'></span><span id='topic+na.approx.ts'></span><span id='topic+na.approx.default'></span><span id='topic+na.spline'></span><span id='topic+na.spline.zoo'></span><span id='topic+na.spline.zooreg'></span><span id='topic+na.spline.ts'></span><span id='topic+na.spline.default'></span>

<h3>Description</h3>

<p>Generic functions for replacing each <code>NA</code> with interpolated
values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na.approx(object, ...) 
## S3 method for class 'zoo'
na.approx(object, x = index(object), xout, ..., na.rm = TRUE, maxgap = Inf, along)
## S3 method for class 'zooreg'
na.approx(object, ...) 
## S3 method for class 'ts'
na.approx(object, ...)
## Default S3 method:
na.approx(object, x = index(object), xout, ..., na.rm = TRUE, maxgap = Inf, along) 

na.spline(object, ...) 
## S3 method for class 'zoo'
na.spline(object, x = index(object), xout, ..., na.rm = TRUE, maxgap = Inf, along)
## S3 method for class 'zooreg'
na.spline(object, ...) 
## S3 method for class 'ts'
na.spline(object, ...)
## Default S3 method:
na.spline(object, x = index(object), xout, ..., na.rm = TRUE, maxgap = Inf, along) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na.approx_+3A_object">object</code></td>
<td>
<p>object in which <code>NA</code>s are to be replaced</p>
</td></tr>
<tr><td><code id="na.approx_+3A_x">x</code>, <code id="na.approx_+3A_xout">xout</code></td>
<td>
<p>Variables to be used for interpolation as in <code><a href="stats.html#topic+approx">approx</a></code>.</p>
</td></tr>
<tr><td><code id="na.approx_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If the result of the (spline) interpolation
still results in leading and/or trailing <code>NA</code>s, should these be removed
(using <code><a href="zoo.html#topic+na.trim">na.trim</a></code>)?</p>
</td></tr>
<tr><td><code id="na.approx_+3A_maxgap">maxgap</code></td>
<td>
<p>maximum number of consecutive <code>NA</code>s to
fill. Any longer gaps will be left unchanged. Note that all methods listed
above can accept <code>maxgap</code> as it is ultimately passed to the 
<code>default</code> method. In <code>na.spline</code> the <code>maxgap</code> argument cannot
be combined with <code>xout</code>, though.</p>
</td></tr>
<tr><td><code id="na.approx_+3A_along">along</code></td>
<td>
<p>deprecated.</p>
</td></tr>
<tr><td><code id="na.approx_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods. The <code>n</code> argument of <code><a href="stats.html#topic+approx">approx</a></code> is currently not supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing values (<code>NA</code>s) are replaced by linear interpolation via
<code><a href="stats.html#topic+approx">approx</a></code> or cubic spline interpolation via <code><a href="stats.html#topic+spline">spline</a></code>,
respectively.  
</p>
<p>It can also be used for series disaggregation by specifying <code>xout</code>.
</p>
<p>By default the index associated with <code>object</code> is used
for interpolation. Note, that if this calls <code>index.default</code>
this gives an equidistant spacing <code>1:NROW(object)</code>. If <code>object</code>
is a matrix or data.frame, the interpolation is done separately for
each column.
</p>
<p>If <code>obj</code> is a plain vector then <code>na.approx(obj, x, y, xout, ...)</code>
returns <code>approx(x = x[!na], y = coredata(obj)[!na], xout = xout, ...)</code>
(where <code>na</code> indicates observations with <code>NA</code>) such that <code>xout</code>
defaults to <code>x</code>. Note that if there are less than two non-<code>NA</code>s then
<code>approx()</code> cannot be applied and thus no <code>NA</code>s can be replaced.
</p>
<p>If <code>obj</code> is a <code>zoo</code>, <code>zooreg</code> or <code>ts</code> object its
<code>coredata</code> value is processed as described and its time index is <code>xout</code> if
specified and <code>index(obj)</code> otherwise. If <code>obj</code> is two dimensional
then the above is applied to each column separately. For examples, see below.
</p>
<p>If <code>obj</code> has more than one column, the above strategy is applied to
each column.
</p>


<h3>Value</h3>

<p>An object of similar structure as <code>object</code> with <code>NA</code>s replaced by
interpolation. For <code>na.approx</code> only the internal <code>NA</code>s are replaced and
leading or trailing <code>NA</code>s are omitted if <code>na.rm = TRUE</code> or not
replaced if <code>na.rm = FALSE</code>. 
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+zoo">zoo</a></code>, <code><a href="stats.html#topic+approx">approx</a></code>, <code><a href="stats.html#topic+na.contiguous">na.contiguous</a></code>,
<code><a href="zoo.html#topic+na.locf">na.locf</a></code>, <code><a href="stats.html#topic+na.omit">na.omit</a></code>, <code><a href="zoo.html#topic+na.trim">na.trim</a></code>, <code><a href="stats.html#topic+spline">spline</a></code>,
<code><a href="stinepack.html#topic+stinterp">stinterp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
z &lt;- zoo(c(2, NA, 1, 4, 5, 2), c(1, 3, 4, 6, 7, 8))

## use underlying time scale for interpolation
na.approx(z) 
## use equidistant spacing
na.approx(z, 1:6)

# with and without na.rm = FALSE
zz &lt;- c(NA, 9, 3, NA, 3, 2)
na.approx(zz, na.rm = FALSE)
na.approx(zz)

d0 &lt;- as.Date("2000-01-01")
z &lt;- zoo(c(11, NA, 13, NA, 15, NA), d0 + 1:6)

# NA fill, drop or keep leading/trailing NAs
na.approx(z)
na.approx(z, na.rm = FALSE)

# extrapolate to point outside of range of time points
# (a) drop NA, (b) keep NA, (c) extrapolate using rule = 2 from approx()
na.approx(z, xout = d0 + 7)
na.approx(z, xout = d0 + 7, na.rm = FALSE)
na.approx(z, xout = d0 + 7, rule = 2)

# use splines - extrapolation handled differently
z &lt;- zoo(c(11, NA, 13, NA, 15, NA), d0 + 1:6)
na.spline(z)
na.spline(z, na.rm = FALSE)
na.spline(z, xout = d0 + 1:6)
na.spline(z, xout = d0 + 2:5)
na.spline(z, xout = d0 + 7)
na.spline(z, xout = d0 + 7, na.rm = FALSE)

## using na.approx for disaggregation
zy &lt;- zoo(1:3,  2000:2001)

# yearly to monthly series
zmo &lt;- na.approx(zy, xout = as.yearmon(2000+0:13/12))
zmo

# monthly to daily series
sq &lt;- seq(as.Date(start(zmo)), as.Date(end(zmo), frac = 1), by = "day")
zd &lt;- na.approx(zmo, x = as.Date, xout = sq)
head(zd)

# weekly to daily series
zww &lt;- zoo(1:3, as.Date("2001-01-01") + seq(0, length = 3, by = 7))
zww
zdd &lt;- na.approx(zww, xout = seq(start(zww), end(zww), by = "day"))
zdd

# The lines do not show up because of the NAs
plot(cbind(z, z), type = "b", screen = 1)
# use na.approx to force lines to appear
plot(cbind(z, na.approx(z)), type = "b", screen = 1)

# Workaround where less than 2 NAs can appear in a column
za &lt;- zoo(cbind(1:5, NA, c(1:3, NA, 5), NA)); za

ix &lt;- colSums(!is.na(za)) &gt; 0
za[, ix] &lt;- na.approx(za[, ix]); za

# using na.approx to create regularly spaced series
# z has points at 10, 20 and 40 minutes while output also has a point at 30
if(require("chron")) {
  tt &lt;- as.chron("2000-01-01 10:00:00") + c(1, 2, 4) * as.numeric(times("00:10:00"))
  z &lt;- zoo(1:3, tt)
  tseq &lt;- seq(start(z), end(z), by = times("00:10:00"))
  na.approx(z, xout = tseq)
}
</code></pre>

<hr>
<h2 id='na.fill'>Fill NA or specified positions.</h2><span id='topic+na.fill'></span><span id='topic+na.fill0'></span><span id='topic+na.fill.ts'></span><span id='topic+na.fill.zoo'></span><span id='topic+na.fill.default'></span>

<h3>Description</h3>

<p>Generic function for filling <code>NA</code> values or specified positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na.fill(object, fill, ...)
## S3 method for class 'ts'
na.fill(object, fill, ix, ...)
## S3 method for class 'zoo'
na.fill(object, fill, ix, ...)
## Default S3 method:
na.fill(object, fill, ix, ...)

na.fill0(object, fill, ix = !is.na(object))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na.fill_+3A_object">object</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="na.fill_+3A_fill">fill</code></td>
<td>
<p>a three component list or a vector that is coerced to a 
list. Shorter objects are recycled.  The three components 
represent the fill value to the left of the data, within the
interior of the data and to the right of the data,
respectively.  The value of any component may be the keyword
<code>"extend"</code> to indicate repetition of the
leftmost or rightmost non-NA value or linear interpolation in the interior.
<code>NULL</code> means that items are dropped rather than filled.</p>
</td></tr>
<tr><td><code id="na.fill_+3A_ix">ix</code></td>
<td>
<p>logical. Should be the same length as the number of time points.
Indicates which time points not to fill. This defaults to the non-NA values.</p>
</td></tr>
<tr><td><code id="na.fill_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>na.fill</code> is a generic function for filling <code>NA</code> or indicated values.
It currently has methods for the time series classes <code>"zoo"</code> and <code>"ts"</code>
and a default method based on the <code>"zoo"</code> method.
</p>
<p>Furthermore, <code>na.fill0</code> works with plain vectors and <code>"Date"</code> objects.
It also works with <code>"zoo"</code> objects provided that no <code>fill</code> component is <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+na.approx">na.approx</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
z &lt;- zoo(c(NA, 2, NA, 1, 4, 5, 2, NA))
na.fill(z, "extend")
na.fill(z, c("extend", NA))
na.fill(z, -(1:3))
na.fill(z, list(NA, NULL, NA))

</code></pre>

<hr>
<h2 id='na.locf'>Last Observation Carried Forward</h2><span id='topic+na.locf'></span><span id='topic+na.locf0'></span><span id='topic+na.locf.data.frame'></span><span id='topic+na.locf.list'></span><span id='topic+na.locf.default'></span>

<h3>Description</h3>

<p>Generic function for replacing each <code>NA</code> with the most recent
non-<code>NA</code> prior to it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na.locf(object, na.rm = TRUE, ...)
## Default S3 method:
na.locf(object, na.rm = TRUE, fromLast, rev,
        maxgap = Inf, rule = 2, ...)

na.locf0(object, fromLast = FALSE, maxgap = Inf, coredata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na.locf_+3A_object">object</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="na.locf_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should leading <code>NA</code>s be removed?</p>
</td></tr>
<tr><td><code id="na.locf_+3A_fromlast">fromLast</code></td>
<td>
<p>logical. Causes observations to be carried backward rather
than forward.  Default is <code>FALSE</code>. With a value of <code>TRUE</code>
this corresponds to NOCB (next observation carried backward).
It is not supported if <code>x</code> or <code>xout</code> is specified.</p>
</td></tr>
<tr><td><code id="na.locf_+3A_rev">rev</code></td>
<td>
<p>Use <code>fromLast</code> instead.  This argument will
be eliminated in the future in favor of <code>fromLast</code>.</p>
</td></tr>
<tr><td><code id="na.locf_+3A_maxgap">maxgap</code></td>
<td>
<p>Runs of more than <code>maxgap</code> <code>NA</code>s are retained,
other <code>NA</code>s are removed and the last occurrence in the resulting series
prior to each time point in <code>xout</code> is used as that time point's output value.
(If <code>xout</code> is not specified this reduces to retaining runs of more than
<code>maxgap</code> <code>NA</code>s while filling other <code>NA</code>s with the last
occurrence of a non-<code>NA</code>.)</p>
</td></tr>
<tr><td><code id="na.locf_+3A_rule">rule</code></td>
<td>
<p>See <code><a href="stats.html#topic+approx">approx</a></code>.</p>
</td></tr>
<tr><td><code id="na.locf_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="na.locf_+3A_coredata">coredata</code></td>
<td>
<p>logical. Should LOCF be applied to the core data
of a (time series) object and then assigned to the original object
again? By default, this strategy is applied to time series classes
(e.g., <code>ts</code>, <code>zoo</code>, <code>xts</code>, etc.) where it preserves
the time index.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object in which each <code>NA</code> in the input object is replaced
by the most recent non-<code>NA</code> prior to it.  If there are no earlier non-<code>NA</code>s then 
the <code>NA</code> is omitted (if <code>na.rm = TRUE</code>) or it is not replaced (if <code>na.rm = FALSE</code>).  
</p>
<p>The arguments <code>x</code> and <code>xout</code> can be used in which case they have
the same meaning as in <code><a href="stats.html#topic+approx">approx</a></code>.
</p>
<p>Note that if a multi-column zoo object has a column entirely composed of
<code>NA</code> then with <code>na.rm = TRUE</code>, the default,
the above implies that the resulting object will have
zero rows. Use <code>na.rm = FALSE</code> to preserve the <code>NA</code> values instead.
</p>
<p>The function <code>na.locf0</code> is the workhorse function underlying the default
<code>na.locf</code> method. It has more limited capabilities but is faster for the
special cases it covers. Implicitly, it uses <code>na.rm=FALSE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+zoo">zoo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>az &lt;- zoo(1:6)

bz &lt;- zoo(c(2,NA,1,4,5,2))
na.locf(bz)
na.locf(bz, fromLast = TRUE)

cz &lt;- zoo(c(NA,9,3,2,3,2))
na.locf(cz)

# generate and fill in missing dates
z &lt;- zoo(c(0.007306621, 0.007659046, 0.007681013,
	0.007817548, 0.007847579, 0.007867313),
	as.Date(c("1993-01-01", "1993-01-09", "1993-01-16",
	"1993-01-23", "1993-01-30", "1993-02-06")))
g &lt;- seq(start(z), end(z), "day")
na.locf(z, xout = g)

# similar but use a 2 second grid

z &lt;- zoo(1:9, as.POSIXct(c("2010-01-04 09:30:02", "2010-01-04 09:30:06",
 "2010-01-04 09:30:07", "2010-01-04 09:30:08", "2010-01-04 09:30:09", 
 "2010-01-04 09:30:10", "2010-01-04 09:30:11", "2010-01-04 09:30:13",
 "2010-01-04 09:30:14")))

g &lt;- seq(start(z), end(z), by = "2 sec")
na.locf(z, xout = g)

## get 5th of every month or most recent date prior to 5th if 5th missing.
## Result has index of the date actually used.

z &lt;- zoo(c(1311.56, 1309.04, 1295.5, 1296.6, 1286.57, 1288.12, 
1289.12, 1289.12, 1285.33, 1307.65, 1309.93, 1311.46, 1311.28, 
1308.11, 1301.74, 1305.41, 1309.72, 1310.61, 1305.19, 1313.21, 
1307.85, 1312.25, 1325.76), as.Date(c(13242, 13244, 
13245, 13248, 13249, 13250, 13251, 13252, 13255, 13256, 13257, 
13258, 13259, 13262, 13263, 13264, 13265, 13266, 13269, 13270, 
13271, 13272, 13274)))

# z.na is same as z but with missing days added (with NAs)
# It is formed by merging z with a zero with series having all the dates.

rng &lt;- range(time(z))
z.na &lt;- merge(z, zoo(, seq(rng[1], rng[2], by = "day")))

# use na.locf to bring values forward picking off 5th of month
na.locf(z.na)[as.POSIXlt(time(z.na))$mday == 5]

## this is the same as the last one except instead of always using the
## 5th of month in the result we show the date actually used

# idx has NAs wherever z.na does but has 1, 2, 3, ... instead of
# z.na's data values (so idx can be used for indexing)

idx &lt;- coredata(na.locf(seq_along(z.na) + (0 * z.na)))

# pick off those elements of z.na that correspond to 5th

z.na[idx[as.POSIXlt(time(z.na))$mday == 5]]

## only fill single-day gaps

merge(z.na, filled1 = na.locf(z.na, maxgap = 1))

## fill NAs in first column by inflating the most recent non-NA
## by the growth in second column.  Note that elements of x-x
## are NA if the corresponding element of x is NA and zero else

m &lt;- zoo(cbind(c(1, 2, NA, NA, 5, NA, NA), seq(7)^2), as.Date(1:7))

r &lt;- na.locf(m[,1]) * m[,2] / na.locf(m[,2] + (m[,1]-m[,1]))
cbind(V1 = r, V2 = m[,2])

## repeat a quarterly value every month
## preserving NAs
zq &lt;- zoo(c(1, NA, 3, 4), as.yearqtr(2000) + 0:3/4)
tt &lt;- as.yearmon(start(zq)) + seq(0, len = 3 * length(zq))/12
na.locf(zq, xout = tt, maxgap = 0)

## na.locf() can also be mimicked with ave()
x &lt;- c(NA, 10, NA, NA, 20, NA)
f &lt;- function(x) x[1]
ave(x, cumsum(!is.na(x)), FUN = f)

## by replacing f() with other functions various generalizations can be
## obtained, e.g.,
f &lt;- function(x) if (length(x) &gt; 3) x else x[1]  # like maxgap
f &lt;- function(x) replace(x, 1:min(length(x)), 3) # replace up to 2 NAs
f &lt;- function(x) if (!is.na(x[1]) &amp;&amp; x[1] &gt; 0) x[1] else x  # only positve numbers
</code></pre>

<hr>
<h2 id='na.StructTS'>Fill NA or specified positions.</h2><span id='topic+na.StructTS'></span><span id='topic+na.StructTS.zoo'></span><span id='topic+na.StructTS.ts'></span>

<h3>Description</h3>

<p>Generic function for filling <code>NA</code> values using seasonal Kalman filter.</p>


<h3>Usage</h3>

<pre><code class='language-R'>na.StructTS(object, ...)
## S3 method for class 'ts'
na.StructTS(object, ..., na.rm = FALSE, maxgap = Inf)
## S3 method for class 'zoo'
na.StructTS(object, ..., na.rm = FALSE, maxgap = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na.StructTS_+3A_object">object</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="na.StructTS_+3A_...">...</code></td>
<td>
<p>other arguments passed to methods.</p>
</td></tr>
<tr><td><code id="na.StructTS_+3A_na.rm">na.rm</code></td>
<td>
<p>logical.  Whether to remove end portions or fill them with NA.</p>
</td></tr>
<tr><td><code id="na.StructTS_+3A_maxgap">maxgap</code></td>
<td>
<p>Runs of more than <code>maxgap</code> <code>NA</code>s are retained,
other <code>NA</code>s are removed and the last occurrence in the resulting series
prior to each time point in <code>xout</code> is used as that time point's
output value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Interpolate with seasonal Kalman filter, using <code><a href="stats.html#topic+StructTS">StructTS</a></code>,
followed by <code><a href="stats.html#topic+tsSmooth">tsSmooth</a></code>.  The input object should
be a regular time series and have a frequency. It is assumed the cycle length is 1.</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+StructTS">StructTS</a></code>, <code><a href="stats.html#topic+tsSmooth">tsSmooth</a></code>, <code><a href="zoo.html#topic+na.approx">na.approx</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
z &lt;- zooreg(rep(10 * seq(8), each = 4) + rep(c(3, 1, 2, 4), times = 8), 
	start = as.yearqtr(2000), freq = 4)
z[25] &lt;- NA

zout &lt;- na.StructTS(z)

plot(cbind(z, zout), screen = 1, col = 1:2, type = c("l", "p"), pch = 20)


</code></pre>

<hr>
<h2 id='na.trim'>Trim Leading/Trailing Missing Observations</h2><span id='topic+na.trim'></span><span id='topic+na.trim.default'></span><span id='topic+na.trim.ts'></span>

<h3>Description</h3>

<p>Generic function for removing leading and trailing <code>NA</code>s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na.trim(object, ...)
## Default S3 method:
na.trim(object, sides = c("both", "left", "right"), 
	is.na = c("any", "all"), maxgap = Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na.trim_+3A_object">object</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="na.trim_+3A_sides">sides</code></td>
<td>
<p>character specifying whether <code>NA</code>s are to be removed from
both sides, just from the left side or just from the right side.</p>
</td></tr>
<tr><td><code id="na.trim_+3A_is.na">is.na</code></td>
<td>
<p>If &quot;any&quot; then a row will be regarded as <code>NA</code> if it has
any <code>NA</code>s.  If &quot;all&quot; then a row will be regarded as <code>NA</code>
only if all elements in the row are <code>NA</code>.  For one dimensional
zoo objects this argument has no effect.</p>
</td></tr>
<tr><td><code id="na.trim_+3A_maxgap">maxgap</code></td>
<td>
<p>maximum number of consecutive <code>NA</code>s to
trim. Any longer gaps will be left unchanged.</p>
</td></tr>
<tr><td><code id="na.trim_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object in which leading and/or trailing
<code>NA</code>s have been removed.
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+na.approx">na.approx</a></code>, <code><a href="stats.html#topic+na.contiguous">na.contiguous</a></code>, <code><a href="zoo.html#topic+na.locf">na.locf</a></code>, <code><a href="stats.html#topic+na.omit">na.omit</a></code>, <code><a href="zoo.html#topic+na.spline">na.spline</a></code>, <code><a href="stinepack.html#topic+stinterp">stinterp</a></code>, <code><a href="zoo.html#topic+zoo">zoo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># examples of na.trim
x &lt;- zoo(c(1, 4, 6), c(2, 4, 6))
xx &lt;- zoo(matrix(c(1, 4, 6, NA, 5, 7), 3), c(2, 4, 6))
na.trim(x)
na.trim(xx)

# using na.trim for alignment
# cal defines the legal dates
# all dates within the date range of x should be present
cal &lt;- zoo(,c(1, 2, 3, 6, 7))
x &lt;- zoo(c(12, 16), c(2, 6))
na.trim(merge(x, cal))

</code></pre>

<hr>
<h2 id='ORDER'>Ordering Permutation</h2><span id='topic+ORDER'></span><span id='topic+ORDER.default'></span>

<h3>Description</h3>

<p><code>ORDER</code> is a generic function for computing ordering
permutations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ORDER(x, ...)
## Default S3 method:
ORDER(x, ..., na.last = TRUE, decreasing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ORDER_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="ORDER_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to methods.</p>
</td></tr>
<tr><td><code id="ORDER_+3A_na.last">na.last</code></td>
<td>
<p>for controlling the treatment of <code>NA</code>s.
If <code>TRUE</code>, missing values in the data are put last; if
<code>FALSE</code>, they are put first; if <code>NA</code>, they are removed.
</p>
</td></tr>
<tr><td><code id="ORDER_+3A_decreasing">decreasing</code></td>
<td>
<p>logical. Should the sort order be increasing or
decreasing?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ORDER</code> is a new generic function which aims at providing
the functionality of the non-generic base function <code><a href="base.html#topic+order">order</a></code>
for arbitrary objects. Currently, there is only a default method which
simply calls <code><a href="base.html#topic+order">order</a></code>. For objects (more precisely if
<code><a href="base.html#topic+is.object">is.object</a></code> is <code>TRUE</code>) <code>order</code>
leverages the generic <code>xtfrm</code>. Thus, to assure ordering
works, one can supply either a method to <code>xtfrm</code> or to <code>ORDER</code>
(or both).
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+order">order</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ORDER(rnorm(5))
</code></pre>

<hr>
<h2 id='plot.zoo'>Plotting zoo Objects</h2><span id='topic+plot.zoo'></span><span id='topic+barplot.zoo'></span><span id='topic+boxplot.zoo'></span><span id='topic+lines.zoo'></span><span id='topic+points.zoo'></span>

<h3>Description</h3>

<p>Plotting method for objects of class <code>"zoo"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zoo'
plot(x, y = NULL, screens, plot.type,
  panel = lines, xlab = "Index", ylab = NULL, main = NULL,
  xlim = NULL, ylim = NULL, xy.labels = FALSE, xy.lines = NULL,
  yax.flip = FALSE, oma = c(6, 0, 5, 0),
  mar = c(0, 5.1, 0, if(yax.flip) 5.1 else 2.1), 
  col = 1, lty = 1, lwd = 1, pch = 1, type = "l", log = "",
  nc, widths = 1, heights = 1, ...)
## S3 method for class 'zoo'
lines(x, y = NULL, type = "l", ...)
## S3 method for class 'zoo'
points(x, y = NULL, type = "p", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.zoo_+3A_x">x</code></td>
<td>
<p>an object of class <code>"zoo"</code>.</p>
</td></tr>
<tr><td><code id="plot.zoo_+3A_y">y</code></td>
<td>
<p>an object of class <code>"zoo"</code>. If <code>y</code> is <code>NULL</code>
(the default) a time series plot of <code>x</code> is produced, otherwise
if both <code>x</code> and <code>y</code> are univariate <code>"zoo"</code> series, a
scatter plot of <code>y</code> versus <code>x</code> is produced.</p>
</td></tr>
<tr><td><code id="plot.zoo_+3A_screens">screens</code></td>
<td>
<p>factor (or coerced to factor) whose levels specify which
graph each series is to be plotted in.  <code>screens=c(1,2,1)</code>
would plot series 1, 2 and 3 in graphs 1, 2 and 1.  If not specified
then 1 is used if <code>plot.type="single"</code> and <code>seq_len(ncol(x))</code>
otherwise.</p>
</td></tr>
<tr><td><code id="plot.zoo_+3A_plot.type">plot.type</code></td>
<td>
<p>for multivariate zoo objects, &quot;multiple&quot; plots the
series on multiple plots and &quot;single&quot; superimposes them on a single
plot.  Default is &quot;single&quot; if <code>screens</code> has only one level and
<code>"multiple"</code> otherwise. If neither <code>screens</code> nor
<code>plot.type</code> is specified then <code>"single"</code>
is used if there is one series and <code>"mulitple"</code> otherwise.  This
option is provided for back compatibility.  Usually <code>screens</code> is
used instead.</p>
</td></tr>
<tr><td><code id="plot.zoo_+3A_panel">panel</code></td>
<td>
<p>a <code>function(x, y, col, lty, ...)</code>  which gives the
action to be carried out in each panel of the display for
<code>plot.type = "multiple"</code>.</p>
</td></tr>
<tr><td><code id="plot.zoo_+3A_ylim">ylim</code></td>
<td>
<p>if <code>plot.type = "multiple"</code> then it can be a list of
y axis limits.  If not a list each graph has the same limits.
If any list element is not a pair then its range is used instead. If 
<code>plot.type = "single"</code> then it is as in <code>plot</code>.</p>
</td></tr>
<tr><td><code id="plot.zoo_+3A_xy.labels">xy.labels</code></td>
<td>
<p>logical, indicating if <code><a href="graphics.html#topic+text">text</a></code> labels should be
used in the scatter plot, or character, supplying a vector of labels to be used.</p>
</td></tr>
<tr><td><code id="plot.zoo_+3A_xy.lines">xy.lines</code></td>
<td>
<p>logical, indicating if <code><a href="graphics.html#topic+lines">lines</a></code> should be drawn in
the scatter plot. Defaults to the value of <code>xy.labels</code> if that is
logical, otherwise to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.zoo_+3A_yax.flip">yax.flip</code></td>
<td>
<p>logical, indicating if the y-axis (ticks and numbering)
should flip from side 2 (left) to 4 (right) from series to series
when <code>type = "multiple"</code>.</p>
</td></tr>
<tr><td><code id="plot.zoo_+3A_xlab">xlab</code>, <code id="plot.zoo_+3A_ylab">ylab</code>, <code id="plot.zoo_+3A_main">main</code>, <code id="plot.zoo_+3A_xlim">xlim</code>, <code id="plot.zoo_+3A_oma">oma</code>, <code id="plot.zoo_+3A_mar">mar</code></td>
<td>
<p>graphical arguments, see <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.zoo_+3A_col">col</code>, <code id="plot.zoo_+3A_lty">lty</code>, <code id="plot.zoo_+3A_lwd">lwd</code>, <code id="plot.zoo_+3A_pch">pch</code>, <code id="plot.zoo_+3A_type">type</code></td>
<td>
<p>graphical arguments that can be vectors or 
(named) lists. See the details for more information.</p>
</td></tr>
<tr><td><code id="plot.zoo_+3A_log">log</code></td>
<td>
<p>specification of log scales as <code>"x"</code>, <code>"y"</code> or <code>"xy"</code>.</p>
</td></tr>
<tr><td><code id="plot.zoo_+3A_nc">nc</code></td>
<td>
<p>the number of columns to use when <code>plot.type = "multiple"</code>.
Defaults to <code>1</code> for up to <code>4</code> series, otherwise to <code>2</code>.</p>
</td></tr>
<tr><td><code id="plot.zoo_+3A_widths">widths</code>, <code id="plot.zoo_+3A_heights">heights</code></td>
<td>
<p>widths and heights for individual graphs, see
<code><a href="graphics.html#topic+layout">layout</a></code>.</p>
</td></tr>
<tr><td><code id="plot.zoo_+3A_...">...</code></td>
<td>
<p>additional graphical arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The methods for <code>plot</code> and <code>lines</code> are very similar
to the corresponding <code>ts</code> methods. However, the handling of
several graphical parameters is more flexible for multivariate series.
These parameters can be vectors of the same length as the number of
series plotted or are recycled if shorter. They can also be (partially)
named list, e.g., <code>list(A = c(1,2), c(3,4))</code> in which <code>c(3, 4)</code>
is the default value and <code>c(1, 2)</code> the value only  for series <code>A</code>.
The <code>screens</code> argument can be specified in a similar way.
If <code>plot.type</code> and <code>screens</code> conflict then multiple plots
will be assumed. Also see the examples.
</p>
<p>In the case of a custom panel the panel can reference
<code>parent.frame$panel.number</code> in order to determine which
frame the panel is being called from.  See examples.
</p>
<p><code>par(mfrow=...)</code> and <code>Axis</code> can be used in conjunction with 
single panel plots in the same way as with other classic graphics.
</p>
<p>For multi-panel graphics, <code>plot.zoo</code> takes over the layout so
<code>par(mfrow=...)</code> cannot be used.  <code>Axis</code> can be used within
the panels themselves but not outside the panel.  See examples.
Also, <code>par(new = TRUE)</code> is not supported for multi-panel graphics.
</p>
<p>In addition to classical time series line plots, there is also a
simple <code><a href="graphics.html#topic+barplot">barplot</a></code> method for <code>"zoo"</code> series. Additionally,
there is a <code><a href="graphics.html#topic+boxplot">boxplot</a></code> method that visualizes the <code>coredata</code>
of the <code>"zoo"</code> series with a box plot.
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+zoo">zoo</a></code>, <code><a href="stats.html#topic+plot.ts">plot.ts</a></code>, <code><a href="graphics.html#topic+barplot">barplot</a></code>,
<code><a href="graphics.html#topic+boxplot">boxplot</a></code>, <code><a href="zoo.html#topic+xyplot.zoo">xyplot.zoo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## example dates
x.Date &lt;- as.Date(paste(2003, 02, c(1, 3, 7, 9, 14), sep = "-"))

## univariate plotting
x &lt;- zoo(rnorm(5), x.Date)
x2 &lt;- zoo(rnorm(5, sd = 0.2), x.Date)
plot(x)
lines(x2, col = 2)

## multivariate plotting
z &lt;- cbind(x, x2, zoo(rnorm(5, sd = 0.5), x.Date))
plot(z, type = "b", pch = 1:3, col = 1:3, ylab = list(expression(mu), "b", "c"))
colnames(z) &lt;- LETTERS[1:3]
plot(z, screens = 1, col = list(B = 2))
plot(z, type = "b", pch = 1:3, col = 1:3)
plot(z, type = "b", pch = list(A = 1:5, B = 3), col = list(C = 4, 2))
plot(z, type = "b", screen = c(1,2,1), col = 1:3)
# right axis is for broken lines
plot(x)
opar &lt;- par(usr = c(par("usr")[1:2], range(x2)))
lines(x2, lty = 2)
# axis(4)
axis(side = 4)
par(opar)


## Custom x axis labelling using a custom panel.
# 1. test data
z &lt;- zoo(c(21, 34, 33, 41, 39, 38, 37, 28, 33, 40), 
     as.Date(c("1992-01-10", "1992-01-17", "1992-01-24", "1992-01-31", 
       "1992-02-07", "1992-02-14", "1992-02-21", "1992-02-28", "1992-03-06", 
       "1992-03-13")))
zz &lt;- merge(a = z, b = z+10)
# 2. axis tick for every point. Also every 3rd point labelled.
my.panel &lt;- function(x, y, ..., pf = parent.frame()) {
   fmt &lt;- "%b-%d" # format for axis labels
   lines(x, y, ...)
   # if bottom panel
   if (with(pf, length(panel.number) == 0 || 
        panel.number %% nr == 0 || panel.number == nser)) { 
      # create ticks at x values and then label every third tick
      axis(side = 1, at = x, labels = FALSE)
      ix &lt;- seq(1, length(x), 3)
      labs &lt;- format(x, fmt)
      axis(side = 1, at = x[ix], labels = labs[ix], tcl = -0.7, cex.axis = 0.7)
   }
}
# 3. plot
plot(zz, panel = my.panel, xaxt = "n")

# with a single panel plot a fancy x-axis is just the same
# procedure as for the ordinary plot command
plot(zz, screen = 1, col = 1:2, xaxt = "n")
# axis(1, at = time(zz), labels = FALSE)
tt &lt;- time(zz)
axis(side = 1, at = tt, labels = FALSE)
ix &lt;- seq(1, length(tt), 3)
fmt &lt;- "%b-%d" # format for axis labels
labs &lt;- format(tt, fmt)
# axis(1, at = time(zz)[ix], labels = labs[ix], tcl = -0.7, cex.axis = 0.7)
axis(side = 1, at = tt[ix], labels = labs[ix], tcl = -0.7, cex.axis = 0.7)
legend("bottomright", colnames(zz), lty = 1, col = 1:2)

## plot a mulitple ts series with nice x-axis using panel function
tab &lt;- ts(cbind(A = 1:24, B = 24:1), start = c(2006, 1), freq = 12)
pnl.xaxis &lt;- function(...) {
     lines(...)
     panel.number &lt;- parent.frame()$panel.number
     nser &lt;- parent.frame()$nser
     # if bottom panel
     if (!length(panel.number) || panel.number == nser) { 
           tt &lt;- list(...)[[1]]
           ym &lt;- as.yearmon(tt)
	   mon &lt;- as.numeric(format(ym, "%m"))
	   yy &lt;- format(ym, "%y")
	   mm &lt;- substring(month.abb[mon], 1, 1)
       if (any(mon == 1))
	    # axis(1, tt[mon == 1], yy[mon == 1], cex.axis = 0.7)
	    axis(side = 1, at = tt[mon == 1], labels = yy[mon == 1], cex.axis = 0.7)
	   # axis(1, tt[mon &gt; 1], mm[mon &gt; 1], cex.axis = 0.5, tcl = -0.3)
	   axis(side = 1, at = tt[mon &gt; 1], labels = mm[mon &gt; 1], cex.axis = 0.5, tcl = -0.3)
     }
}
plot(as.zoo(tab), panel = pnl.xaxis, xaxt = "n", main = "Fancy X Axis")

## Another example with a custom axis
# test data
z &lt;- zoo(matrix(1:25, 5), c(10,11,20,21))
colnames(z) &lt;- letters[1:5]

plot(zoo(coredata(z)), xaxt = "n", panel = function(x, y, ..., Time = time(z)) {
    lines(x, y, ...)
    # if bottom panel
    pf &lt;- parent.frame()
    if (with(pf, panel.number %% nr == 0 || panel.number == nser)) {
        axis(side = 1, at = x, labels = Time)
    }
})


## plot with left and right axes
## modified from http://www.mayin.org/ajayshah/KB/R/html/g6.html
suppressWarnings(RNGversion("3.5.0"))
set.seed(1)
z &lt;- zoo(cbind(A = cumsum(rnorm(100)), B = cumsum(rnorm(100, mean = 0.2))))
opar &lt;- par(mai = c(.8, .8, .2, .8))
plot(z[,1], type = "l", 
  xlab = "x-axis label", ylab = colnames(z)[1])
par(new = TRUE)
plot(z[,2], type = "l", ann = FALSE, yaxt = "n", col = "blue")
# axis(4)
axis(side = 4)
legend(x = "topleft", bty = "n", lty = c(1,1), col = c("black", "blue"),
  legend = paste(colnames(z), c("(left scale)", "(right scale)")))
usr &lt;- par("usr")
# if you don't care about srt= in text then mtext is shorter:
#   mtext(colnames(z)[2], 4, 2, col = "blue")
text(usr[2] + .1 * diff(usr[1:2]), mean(usr[3:4]), colnames(z)[2],
  srt = -90, xpd = TRUE, col = "blue")
par(opar)


## another plot with left and right axes
## modified from https://stat.ethz.ch/pipermail/r-help/2014-May/375293.html
d1 &lt;- c(38.2, 18.1, 83.2, 42.7, 22.8, 48.1, 81.8, 129.6, 52.0, 110.3)
d2 &lt;- c(2.2, 0.8, 0.7, 1.6, 0.9, 0.9, 1.1, 2.8, 5.1, 2.1)
z1 &lt;- zooreg(d1, start = as.POSIXct("2013-01-01 00:00:01"), frequency = 0.0000006)
z2 &lt;- zooreg(d2, start = as.POSIXct("2013-01-01 00:00:20"), frequency = 0.0000006)
zt &lt;- zooreg(rnorm(1050), start = as.POSIXct("2013-01-01 00:00:01"), frequency = 0.00007)
z &lt;- merge(zt, z1, z2, all = TRUE)
z &lt;- na.spline(z[,2:3], na.rm = FALSE)
## function to round up to a number divisible by n (2011 by Owen Jones)
roundup &lt;- function(x, n) ceiling(ceiling(x)/n) * n
## plot how to match secondary y-axis ticks to primary ones
plot(z$z1, ylim = c(0, signif(max(na.omit(z$z1)), 2)), xlab = "")
## use multiplication for even tick numbers and fake sekondary y-axis
max.yl &lt;- roundup(max(na.omit(z$z2)), par("yaxp")[3])
multipl.yl &lt;- max(na.omit(z$z2)) / max.yl
multipl.z2 &lt;- signif(max(na.omit(z$z1) * 1.05), 2)/max.yl
lines(z$z2 * multipl.z2, lty = 2)
at4 &lt;- axTicks(4)
axis(4, at = at4, seq(0, max.yl, length.out = par("yaxp")[3] + 1))


# automatically placed point labels
## Not run: 
library("maptools")
pointLabel(time(z), coredata(z[,2]), labels = format(time(z)), cex = 0.5)

## End(Not run)

## plot one zoo series against the other.
plot(x, x2)
plot(x, x2, xy.labels = TRUE)
plot(x, x2, xy.labels = 1:5, xy.lines = FALSE)

## shade a portion of a plot and make axis fancier

v &lt;- zooreg(rnorm(50), start = as.yearmon(2004), freq = 12)

plot(v, type = "n")
u &lt;- par("usr")
rect(as.yearmon("2007-8"), u[3], as.yearmon("2009-11"), u[4], 
   border = 0, col = "grey")
lines(v)
axis(1, floor(time(v)), labels = FALSE, tcl = -1)

## shade certain times to show recessions, etc.
v &lt;- zooreg(rnorm(50), start = as.yearmon(2004), freq = 12)
plot(v, type = "n")
u &lt;- par("usr")
rect(as.yearmon("2007-8"), u[3], as.yearmon("2009-11"), u[4], 
   border = 0, col = "grey")
lines(v)
axis(1, floor(time(v)), labels = FALSE, tcl = -1)

## fill area under plot

pnl.xyarea &lt;- function(x, y, fill.base = 0, col = 1, ...) {
       lines(x, y, ...)
       panel.number &lt;- parent.frame()$panel.number
	   col &lt;- rep(col, length = panel.number)[panel.number]
       polygon(c(x[1], x, tail(x, 1), x[1]), 
		c(fill.base, as.numeric(y), fill.base, fill.base), col = col)
}
plot(zoo(EuStockMarkets), col = rainbow(4), panel = pnl.xyarea)


## barplot
x &lt;- zoo(cbind(rpois(5, 2), rpois(5, 3)), x.Date)
barplot(x, beside = TRUE)

## boxplot
boxplot(x)

## 3d plot
## The persp function in R (not part of zoo) works with zoo objects.
## The following example is by Enrico Schumann.
## https://stat.ethz.ch/pipermail/r-sig-finance/2009q1/003710.html
nC &lt;- 10    # columns
nO &lt;- 100 # observations
dataM &lt;- array(runif(nC * nO), dim=c(nO, nC))
zz &lt;- zoo(dataM, 1:nO)
persp(1:nO, 1:nC, zz)

# interactive plotting
## Not run: 
library("TeachingDemos")
tke.test1 &lt;- list(Parameters = list(
	lwd = list("spinbox", init = 1, from = 0, to = 5, increment = 1, width = 5),
	lty = list("spinbox", init = 1, from = 0, to = 6, increment = 1, width = 5)
))
z &lt;- zoo(rnorm(25))
tkexamp(plot(z), tke.test1, plotloc = "top")

## End(Not run)

# setting ylim on a multi-panel plot - 2nd panel y axis range is 1-50
data("anscombe", package = "datasets")
ans6 &lt;- zoo(anscombe[, 1:6])
screens &lt;- c(1, 1, 2, 2, 3, 3)
ylim &lt;- unname(tapply(as.list(ans6), screens, range))
ylim[[2]] &lt;- 1:50 # or ylim[[2]] &lt;- c(1, 50)
plot(ans6, screens = screens, ylim = ylim) 

</code></pre>

<hr>
<h2 id='read.zoo'>Reading and Writing zoo Series</h2><span id='topic+read.zoo'></span><span id='topic+read.table.zoo'></span><span id='topic+read.csv.zoo'></span><span id='topic+read.csv2.zoo'></span><span id='topic+read.delim.zoo'></span><span id='topic+read.delim2.zoo'></span><span id='topic+write.zoo'></span>

<h3>Description</h3>

<p><code>read.zoo</code> and <code>write.zoo</code> are convenience functions for reading
and writing <code>"zoo"</code> series from/to text files. They are convenience
interfaces to <code>read.table</code> and <code>write.table</code>, respectively.
To employ <code>read.csv</code>, <code>read.csv2</code>, <code>read.delim</code>,
<code>read.delim2</code> instead of <code>read.table</code> additional functions
<code>read.csv.zoo</code> etc. are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.zoo(file, format = "", tz = "", FUN = NULL,
  regular = FALSE, index.column = 1, drop = TRUE, FUN2 = NULL,
  split = NULL, aggregate = FALSE, ..., text, read = read.table)
  
write.zoo(x, file = "", index.name = "Index", row.names = FALSE, col.names = NULL, ...)

read.csv.zoo(..., read = read.csv)
read.csv2.zoo(..., read = read.csv2)
read.delim.zoo(..., read = read.delim)
read.delim2.zoo(..., read = read.delim2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.zoo_+3A_file">file</code></td>
<td>
<p>character string or strings giving the name of the file(s) 
which the data
are to be read from/written to. See <code><a href="utils.html#topic+read.table">read.table</a></code> and
<code><a href="utils.html#topic+write.table">write.table</a></code> for more information. Alternatively,
in <code>read.zoo</code>, <code>file</code> can be a <code>connection</code> or a
<code>data.frame</code> (e.g.,
resulting from a previous <code>read.table</code> call) that
is subsequently processed to a <code>"zoo"</code> series.</p>
</td></tr>
<tr><td><code id="read.zoo_+3A_format">format</code></td>
<td>
<p>date format argument passed to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="read.zoo_+3A_tz">tz</code></td>
<td>
<p>time zone argument passed to <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>.</p>
</td></tr>
<tr><td><code id="read.zoo_+3A_fun">FUN</code></td>
<td>
<p>a function for computing the index from the first column
of the data. See details.</p>
</td></tr>
<tr><td><code id="read.zoo_+3A_regular">regular</code></td>
<td>
<p>logical. Should the series be coerced to class <code>"zooreg"</code>
(if the series is regular)?</p>
</td></tr>
<tr><td><code id="read.zoo_+3A_index.column">index.column</code></td>
<td>
<p>numeric vector or list. The column names or numbers of the data frame 
in which the index/time is stored.  If the <code>read.table</code> argument <code>colClasses</code> 
is used and <code>"NULL"</code> is among its components then 
<code>index.column</code> refers to the column numbers after the columns 
corresponding to <code>"NULL"</code> in <code>colClasses</code> have been removed.  
If specified as a list then one argument will be passed to argument <code>FUN</code> per component so that, 
for example, <code>index.column = list(1, 2)</code> will cause 
<code>FUN(x[,1], x[,2], ...)</code> to be called whereas 
<code>index.column = list(1:2)</code> will cause 
<code>FUN(x[,1:2], ...)</code> to be called where <code>x</code> is a data frame of 
characters data.  Here <code>...</code> refers to <code>format</code>
and/or <code>tz</code>, if they specified as arguments.  <code>index.column = 0</code> can
be used to specify that the row names be used as the index.  In the case that
no row names were input sequential numbering is used.
If <code>index.column</code> is specified as an ordinary vector then if it has the
same length as the number of arguments of <code>FUN</code> (or <code>FUN2</code> in the
event that <code>FUN2</code> is specified and <code>FUN</code> is not) 
then <code>index.column</code> is converted to a
list.  Also it is always converted to a list if it has length 1.</p>
</td></tr>
<tr><td><code id="read.zoo_+3A_drop">drop</code></td>
<td>
<p>logical. If the data frame contains just a single data column, should
the second dimension be dropped?</p>
</td></tr>
<tr><td><code id="read.zoo_+3A_x">x</code></td>
<td>
<p>a <code>"zoo"</code> object.</p>
</td></tr>
<tr><td><code id="read.zoo_+3A_index.name">index.name</code></td>
<td>
<p>character with name of the index column in the written
data file.</p>
</td></tr>  
<tr><td><code id="read.zoo_+3A_row.names">row.names</code></td>
<td>
<p>logical. Should row names be written? Default is <code>FALSE</code>
because the row names are just character representations of the index.</p>
</td></tr>
<tr><td><code id="read.zoo_+3A_col.names">col.names</code></td>
<td>
<p>logical. Should column names be written? Default is to
write column names only if <code>x</code> has column names.</p>
</td></tr>
<tr><td><code id="read.zoo_+3A_fun2">FUN2</code></td>
<td>
<p>function. It is applied to the time index after 
<code>FUN</code> and before <code>aggregate</code>. If <code>FUN</code> is not specified
but <code>FUN2</code> is specified then only <code>FUN2</code> is applied.</p>
</td></tr>
<tr><td><code id="read.zoo_+3A_split">split</code></td>
<td>
<p>NULL or column number or name or vector of numbers or 
names. If not NULL then the data is assumed to be in long format and is 
split according to the indicated columns.  See the <span class="rlang"><b>R</b></span> 
<code><a href="stats.html#topic+reshape">reshape</a></code> command for description of long data.
If <code>split = Inf</code> then the first of each run among the times are made into
a separate series, the second of each run and so on.  If <code>split= -Inf</code> then
the last of each run is made into a separate series, the second last
and so on.</p>
</td></tr>
<tr><td><code id="read.zoo_+3A_aggregate">aggregate</code></td>
<td>
<p>logical or function. If set to <code>TRUE</code>, then <code><a href="zoo.html#topic+aggregate.zoo">aggregate.zoo</a></code>
is applied to the zoo object created to compute the <code><a href="base.html#topic+mean">mean</a></code> of all values with
the same time index. Alternatively, <code>aggregate</code> can be set to any other
function that should be used for aggregation.
If <code>FALSE</code> (the default), no aggregation is performed and a warning
is given if there are any duplicated time indexes.  Note that most
<code>zoo</code> functions do not accept objects with duplicate time indexes. 
See <code><a href="zoo.html#topic+aggregate.zoo">aggregate.zoo</a></code>.</p>
</td></tr>
<tr><td><code id="read.zoo_+3A_...">...</code></td>
<td>
<p>further arguments passed to other functions. In the <code>read.*.zoo</code>
the arguments are passed to the function specified in <code>read</code>
(unless <code>file</code> is a <code>data.frame</code> already). In <code>write.zoo</code> the
arguments are passed to <code><a href="utils.html#topic+write.table">write.table</a></code>.</p>
</td></tr>
<tr><td><code id="read.zoo_+3A_text">text</code></td>
<td>
<p>character. If <code>file</code> is not supplied and this is, then
data are read from the value of <code>text</code> via a text connection.
See below for an example.</p>
</td></tr>
<tr><td><code id="read.zoo_+3A_read">read</code></td>
<td>
<p>function. The function for reading <code>file</code> (unless it is
a <code>data.frame</code> already).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>read.zoo</code> is a convenience function which should make it easier
to read data from a text file and turn it into a <code>"zoo"</code> series 
immediately. <code>read.zoo</code> reads the data file via <code>read.table(file, ...)</code>.
The column <code>index.column</code> (by default the first) of the resulting data is
interpreted to be the index/time, the remaining columns the corresponding data.
(If the file only has only column then that is assumed to be the data column and
<code>1, 2, ...</code> are used for the index.)  To assign the appropriate class
to the index, <code>FUN</code> can be specified and is applied to the first column.
</p>
<p>To process the index, <code>read.zoo</code> calls <code>FUN</code> with the index as the
first argument. If <code>FUN</code> is not specified, the following default is employed:
</p>
<p>(a) If <code>file</code> is a data frame with a single
index column that appears to be a time index already, then <code>FUN = identity</code> is used.
The conditions for a readily produced time index are: It is not <code>character</code> or 
<code>factor</code> (and the arguments <code>tz</code> and <code>format</code> must not be specified).
</p>
<p>(b) If the conditions from (a) do not hold then the following strategy is used.
If there are multiple index columns they are pasted together with a space between each.
Using the (pasted) index column: (1) If <code>tz</code> is specified then the
index column is converted to <code>POSIXct</code>.  (2) If <code>format</code> is specified
then the index column is converted to <code>Date</code>. (3) Otherwise, a heuristic
attempts to decide between <code>"numeric"</code>, <code>"POSIXct"</code>, and <code>"Date"</code> by
trying them in that order (which may not always succeed though). By default,
only the standard date/time format is used. Hence, supplying <code>format</code> and/or <code>tz</code>
is necessary if some date/time format is used that is not the default. And even
if the default format is appropriate for the index, explicitly supplying
<code>FUN</code> or at least <code>format</code> and/or <code>tz</code> typically leads to more
reliable results than the heuristic.
</p>
<p>If <code>regular</code> is set to <code>TRUE</code> and the resulting series has an 
underlying regularity, it is coerced to a <code>"zooreg"</code> series.
</p>
<p>To employ other functions than <code>read.table</code> to read the initial data,
further convenience interfaces <code>read.csv.zoo</code> etc. are provided.
</p>
<p><code>write.zoo</code> is a convenience function for writing <code>"zoo"</code> series
to text files. It first coerces its argument to a <code>"data.frame"</code>, adds
a column with the index and then calls <code><a href="utils.html#topic+write.table">write.table</a></code>.
</p>
<p>See also <code>vignette("zoo-read", package = "zoo")</code> for detailed examples.
</p>


<h3>Value</h3>

<p><code>read.zoo</code> returns an object of class <code>"zoo"</code> (or <code>"zooreg"</code>).
</p>


<h3>Note</h3>

<p><code>read.zoo</code> works by first reading the data in using <code>read.table</code>
and then processing it.  This implies that 
if the index field is entirely numeric the default is to pass it to <code>FUN</code>
or the built-in date conversion routine
a number, rather than a character string. 
Thus, a date field such as <code>09122007</code> intended
to represent December 12, 2007 would be seen as <code>9122007</code>
and interpreted as the 91st day 
thereby generating an error.  
</p>
<p>This comment also applies to trailing decimals so that if 
<code>2000.10</code> were intended to represent the 10th month of 2000 in fact
it would receive
<code>2000.1</code> and regard it as the first month of 2000
unless similar precautions were taken.
</p>
<p>In the above cases the index field should be specified to be
<code>"character"</code> so that leading or trailing zeros
are not dropped.  This can be done by specifying a <code>"character"</code>
index column in the 
<code>"colClasses"</code> argument, which is passed to <code>read.table</code>, 
as shown in the examples below.
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+zoo">zoo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## this manual page provides a few typical examples, many more cases
## are covered in vignette("zoo-read", package = "zoo")

## read text lines with a single date column
Lines &lt;- "2013-12-24  2
2013-12-25 3
2013-12-26 8"
read.zoo(text = Lines, FUN = as.Date)       # explicit coercion
read.zoo(text = Lines, format = "%Y-%m-%d") # same
read.zoo(text = Lines)                      # same, via heuristic

## read text lines with date/time in separate columns
Lines &lt;- "2013-11-24 12:41:21 2
2013-12-25 12:41:22.25 3
2013-12-26 12:41:22.75 8"
read.zoo(text = Lines, index = 1:2,
  FUN = paste, FUN2 = as.POSIXct)            # explicit coercion
read.zoo(text = Lines, index = 1:2, tz = "") # same
read.zoo(text = Lines, index = 1:2)          # same, via heuristic

## read text lines with month/year in separate columns
Lines &lt;- "Jan 1998 4.36
Feb 1998 4.34"
read.zoo(text = Lines, index = 1:2, FUN = paste, FUN2 = as.yearmon)

## read directly from a data.frame (artificial and built-in BOD)
dat &lt;- data.frame(date = paste("2000-01-", 10:15, sep = ""),
  a = sin(1:6), b = cos(1:6))
read.zoo(dat)
data("BOD", package = "datasets")
read.zoo(BOD)

## Not run: 
## descriptions of typical examples

## turn *numeric* first column into yearmon index
## where number is year + fraction of year represented by month
z &lt;- read.zoo("foo.csv", sep = ",", FUN = as.yearmon)

## first column is of form yyyy.mm
## (Here we use format in place of as.character so that final zero 
## is not dropped in dates like 2001.10 which as.character would do.)
f &lt;- function(x) as.yearmon(format(x, nsmall = 2), "%Y.%m")
z &lt;- read.zoo("foo.csv", header = TRUE, FUN = f)

## turn *character* first column into "Date" index
## Assume lines look like: 12/22/2007 1 2
z &lt;- read.zoo("foo.tab", format = "%m/%d/%Y")

# Suppose lines look like: 09112007 1 2 and there is no header
z &lt;- read.zoo("foo.txt", format = "%d%m%Y")

## csv file with first column of form YYYY-mm-dd HH:MM:SS
## Read in times as "chron" class. Requires chron 2.3-22 or later.
z &lt;- read.zoo("foo.csv", header = TRUE, sep = ",", FUN = as.chron)

## same but with custom format.  Note as.chron uses POSIXt-style 
## Read in times as "chron" class. Requires chron 2.3-24 or later.
z &lt;- read.zoo("foo.csv", header = TRUE, sep = ",", FUN = as.chron, 
	format = "

## same file format but read it in times as "POSIXct" class.
z &lt;- read.zoo("foo.csv", header = TRUE, sep = ",", tz = "")

## csv file with first column mm-dd-yyyy. Read times as "Date" class.
z &lt;- read.zoo("foo.csv", header = TRUE, sep = ",", format = "%m-%d-%Y")

## whitespace separated file with first column of form YYYY-mm-ddTHH:MM:SS
## and no headers.  T appears literally.  Requires chron 2.3-22 or later.
z &lt;- read.zoo("foo.csv", FUN = as.chron)

# read in all csv files in the current directory and merge them
read.zoo(Sys.glob("*.csv"), header = TRUE, sep = ",")

# We use "NULL" in colClasses for those columns we don't need but in 
# col.names we still have to include dummy names for them.  Of what 
# is left the index is the first three columns (1:3) which we convert 
# to chron class times in FUN and then truncate to 5 seconds in FUN2.  
# Finally we use aggregate = mean to average over the 5 second intervals.
library("chron")

Lines &lt;- "CVX 20070201 9 30 51 73.25 81400 0
CVX 20070201 9 30 51 73.25 100 0
CVX 20070201 9 30 51 73.25 100 0
CVX 20070201 9 30 51 73.25 300 0
CVX 20070201 9 30 51 73.25 81400 0
CVX 20070201 9 40 51 73.25 100 0
CVX 20070201 9 40 52 73.25 100 0
CVX 20070201 9 40 53 73.25 300 0"

z &lt;- read.zoo(text = Lines, 
  colClasses = c("NULL", "NULL", "numeric", "numeric", "numeric",
    "numeric", "numeric", "NULL"),
  col.names = c("Symbol", "Date", "Hour", "Minute", "Second", "Price", "Volume", "junk"),
  index = 1:3,  # do not count columns that are "NULL" in colClasses
  FUN = function(h, m, s) times(paste(h, m, s, sep = ":")),
  FUN2 = function(tt) trunc(tt, "00:00:05"),
  aggregate = mean)

## End(Not run)

</code></pre>

<hr>
<h2 id='rollapply'>Apply Rolling Functions</h2><span id='topic+rollapply'></span><span id='topic+rollapplyr'></span><span id='topic+rollapply.default'></span><span id='topic+rollapply.ts'></span><span id='topic+rollapply.zoo'></span>

<h3>Description</h3>

<p>A generic function for applying a function to rolling margins of an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rollapply(data, ...)
## S3 method for class 'ts'
rollapply(data, ...)
## S3 method for class 'zoo'
rollapply(data, width, FUN, ..., by = 1, by.column = TRUE, 
    fill = if (na.pad) NA, na.pad = FALSE, partial = FALSE, 
    align = c("center", "left", "right"), coredata = TRUE)
## Default S3 method:
rollapply(data, ...)
rollapplyr(..., align = "right")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rollapply_+3A_data">data</code></td>
<td>
<p>the data to be used (representing a series of observations).</p>
</td></tr>
<tr><td><code id="rollapply_+3A_width">width</code></td>
<td>
<p>numeric vector or list. In the simplest case this is an integer
specifying the window width (in numbers of observations) which is aligned
to the original sample according to the <code>align</code> argument. Alternatively,
<code>width</code> can be a list regarded as offsets compared to the current
time, see below for details.</p>
</td></tr>
<tr><td><code id="rollapply_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied.</p>
</td></tr>
<tr><td><code id="rollapply_+3A_...">...</code></td>
<td>
<p>optional arguments to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="rollapply_+3A_by">by</code></td>
<td>
<p>calculate FUN at every <code>by</code>-th time point rather than 
every point.  <code>by</code> is only used if <code>width</code> is length 1 and either
a plain scalar or a list.</p>
</td></tr>
<tr><td><code id="rollapply_+3A_by.column">by.column</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>FUN</code> is applied to each column separately.</p>
</td></tr>
<tr><td><code id="rollapply_+3A_fill">fill</code></td>
<td>
<p>a three-component vector or list (recycled otherwise) providing
filling values at the left/within/to the right of the data range.
See the <code>fill</code> argument of <code><a href="data.table.html#topic+na.fill">na.fill</a></code> for details.</p>
</td></tr>
<tr><td><code id="rollapply_+3A_na.pad">na.pad</code></td>
<td>
<p>deprecated. Use <code>fill = NA</code> instead of <code>na.pad = TRUE</code>.</p>
</td></tr>
<tr><td><code id="rollapply_+3A_partial">partial</code></td>
<td>
<p>logical or numeric. If <code>FALSE</code> (default) then <code>FUN</code> is only 
applied when all indexes of the rolling window are within the observed time range.
If <code>TRUE</code>, then the subset of indexes that are in range are passed to <code>FUN</code>.
A numeric argument to <code>partial</code> can be used to determin the minimal
window size for partial computations. See below for more details.</p>
</td></tr>
<tr><td><code id="rollapply_+3A_align">align</code></td>
<td>
<p>specifyies whether the index of the result
should be left- or right-aligned or centered (default) compared
to the rolling window of observations. This argument is only used if
<code>width</code> represents widths.</p>
</td></tr>
<tr><td><code id="rollapply_+3A_coredata">coredata</code></td>
<td>
<p>logical. Should only the <code>coredata(data)</code>
be passed to every <code>width</code> window? If set to <code>FALSE</code> the
full zoo series is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>width</code> is a plain numeric vector its elements are regarded as widths
to be interpreted in conjunction with <code>align</code> whereas if <code>width</code> is a list
its components are regarded as offsets. In the above cases if the length of
<code>width</code> is 1 then <code>width</code> is recycled for every <code>by</code>-th point.
If <code>width</code> is a list its components represent integer offsets such that 
the i-th component of the list refers to time points at positions
<code>i + width[[i]]</code>.  If any of these points are below 1 or above the 
length of <code>index(data)</code> then <code>FUN</code> is not evaluated for that
point unless <code>partial = TRUE</code> and in that case only the valid
points are passed.
</p>
<p>The rolling function can also be applied to partial windows by setting <code>partial = TRUE</code>
For example, if <code>width = 3, align = "right"</code> then for the first point
just that point is passed to <code>FUN</code> since the two points to its
left are out of range.  For the same example, if <code>partial = FALSE</code> then <code>FUN</code> is not
invoked at all for the first two points.  If <code>partial</code> is a numeric then it
specifies the minimum number of offsets that must be within range.  Negative
<code>partial</code> is interpreted as <code>FALSE</code>.
</p>
<p>If <code>width</code> is a scalar then <code>partial = TRUE</code> and <code>fill = NA</code> are
mutually exclusive but if offsets are specified for the <code>width</code> and 0 is not
among the offsets then the output will be shorter than the input even
if <code>partial = TRUE</code> is specified.  In that case it may still be useful
to specify <code>fill</code> in addition to <code>partial</code>.
</p>
<p>If <code>FUN</code> is <code>mean</code>, <code>max</code> or <code>median</code> and <code>by.column</code> is 
<code>TRUE</code> and width is a plain scalar and there are no other arguments
then special purpose code is used to enhance performance.
Also in the case of <code>mean</code> such special purpose code is only invoked if the
<code>data</code> argument has no <code>NA</code> values.
See <code><a href="data.table.html#topic+rollmean">rollmean</a></code>, <code><a href="zoo.html#topic+rollmax">rollmax</a></code> and <code><a href="zoo.html#topic+rollmedian">rollmedian</a></code>
for more details.
</p>
<p>Currently, there are methods for <code>"zoo"</code> and <code>"ts"</code> series
and <code>"default"</code> method for ordinary vectors and matrices.
</p>
<p><code>rollapplyr</code> is a wrapper around <code>rollapply</code> that uses a default
of <code>align = "right"</code>.
</p>
<p>If <code>data</code> is of length 0, <code>data</code> is returned unmodified.
</p>


<h3>Value</h3>

<p>A object of the same class as <code>data</code> with the results of the rolling function.
</p>


<h3>See Also</h3>

<p><code><a href="data.table.html#topic+rollmean">rollmean</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>suppressWarnings(RNGversion("3.5.0"))
set.seed(1)

## rolling mean
z &lt;- zoo(11:15, as.Date(31:35))
rollapply(z, 2, mean)

## non-overlapping means
z2 &lt;- zoo(rnorm(6))
rollapply(z2, 3, mean, by = 3)      # means of nonoverlapping groups of 3
aggregate(z2, c(3,3,3,6,6,6), mean) # same

## optimized vs. customized versions
rollapply(z2, 3, mean)   # uses rollmean which is optimized for mean
rollmean(z2, 3)          # same
rollapply(z2, 3, (mean)) # does not use rollmean


## rolling regression:
## set up multivariate zoo series with
## number of UK driver deaths and lags 1 and 12
seat &lt;- as.zoo(log(UKDriverDeaths))
time(seat) &lt;- as.yearmon(time(seat))
seat &lt;- merge(y = seat, y1 = lag(seat, k = -1),
  y12 = lag(seat, k = -12), all = FALSE)

## run a rolling regression with a 3-year time window
## (similar to a SARIMA(1,0,0)(1,0,0)_12 fitted by OLS)
rr &lt;- rollapply(seat, width = 36,
  FUN = function(z) coef(lm(y ~ y1 + y12, data = as.data.frame(z))),
  by.column = FALSE, align = "right")

## plot the changes in coefficients
## showing the shifts after the oil crisis in Oct 1973
## and after the seatbelt legislation change in Jan 1983
plot(rr)


## rolling mean by time window (e.g., 3 days) rather than
## by number of observations (e.g., when these are unequally spaced):
#
## - test data
tt &lt;- as.Date("2000-01-01") + c(1, 2, 5, 6, 7, 8, 10)
z &lt;- zoo(seq_along(tt), tt)
## - fill it out to a daily series, zm, using NAs
## using a zero width zoo series g on a grid
g &lt;- zoo(, seq(start(z), end(z), "day"))
zm &lt;- merge(z, g)
## - 3-day rolling mean
rollapply(zm, 3, mean, na.rm = TRUE, fill = NA)
##
## - without expansion to regular grid: find interval widths
## that encompass the previous 3 days for each Date
w &lt;- seq_along(tt) - findInterval(tt - 3, tt)
## a solution to computing the widths 'w' that is easier to read but slower
## w &lt;- sapply(tt, function(x) sum(tt &gt;= x - 2 &amp; tt &lt;= x))
##
## - rolling sum from 3-day windows
## without vs. with expansion to regular grid
rollapplyr(z, w, sum)
rollapplyr(zm, 3, sum, partial = TRUE, na.rm = TRUE)


## rolling weekly sums (with some missing dates)
z &lt;- zoo(1:11, as.Date("2016-03-09") + c(0:7, 9:10, 12))
weeksum &lt;- function(z) sum(z[time(z) &gt; max(time(z)) - 7])
zs &lt;- rollapplyr(z, 7, weeksum, fill = NA, coredata = FALSE)
merge(value = z, weeksum = zs)


## replicate cumsum with either 'partial' or vector width 'k'
cumsum(1:10)
rollapplyr(1:10, 10, sum, partial = TRUE)
rollapplyr(1:10, 1:10, sum)


## different values of rule argument
z &lt;- zoo(c(NA, NA, 2, 3, 4, 5, NA))
rollapply(z, 3, sum, na.rm = TRUE)
rollapply(z, 3, sum, na.rm = TRUE, fill = NULL)
rollapply(z, 3, sum, na.rm = TRUE, fill = NA)
rollapply(z, 3, sum, na.rm = TRUE, partial = TRUE)

# this will exclude time points 1 and 2
# It corresponds to align = "right", width = 3
rollapply(zoo(1:8), list(seq(-2, 0)), sum)

# but this will include points 1 and 2
rollapply(zoo(1:8), list(seq(-2, 0)), sum, partial = 1)
rollapply(zoo(1:8), list(seq(-2, 0)), sum, partial = 0)

# so will this
rollapply(zoo(1:8), list(seq(-2, 0)), sum, fill = NA)

# by = 3, align = "right"
L &lt;- rep(list(NULL), 8)
L[seq(3, 8, 3)] &lt;- list(seq(-2, 0))
str(L)
rollapply(zoo(1:8), L, sum)

rollapply(zoo(1:8), list(0:2), sum, fill = 1:3)
rollapply(zoo(1:8), list(0:2), sum, fill = 3)

L2 &lt;- rep(list(-(2:0)), 10)
L2[5] &lt;- list(NULL)
str(L2)
rollapply(zoo(1:10), L2, sum, fill = "extend")
rollapply(zoo(1:10), L2, sum, fill = list("extend", NULL))

rollapply(zoo(1:10), L2, sum, fill = list("extend", NA))

rollapply(zoo(1:10), L2, sum, fill = NA)
rollapply(zoo(1:10), L2, sum, fill = 1:3)
rollapply(zoo(1:10), L2, sum, partial = TRUE)
rollapply(zoo(1:10), L2, sum, partial = TRUE, fill = 99)

rollapply(zoo(1:10), list(-1), sum, partial = 0)
rollapply(zoo(1:10), list(-1), sum, partial = TRUE)

rollapply(zoo(cbind(a = 1:6, b = 11:16)), 3, rowSums, by.column = FALSE)

# these two are the same
rollapply(zoo(cbind(a = 1:6, b = 11:16)), 3, sum)
rollapply(zoo(cbind(a = 1:6, b = 11:16)), 3, colSums, by.column = FALSE)

# these two are the same
rollapply(zoo(1:6), 2, sum, by = 2, align = "right")
aggregate(zoo(1:6), c(2, 2, 4, 4, 6, 6), sum)

# these two are the same
rollapply(zoo(1:3), list(-1), c)
lag(zoo(1:3), -1)

# these two are the same
rollapply(zoo(1:3), list(1), c)
lag(zoo(1:3))

# these two are the same
rollapply(zoo(1:5), list(c(-1, 0, 1)), sum)
rollapply(zoo(1:5), 3, sum)

# these two are the same
rollapply(zoo(1:5), list(0:2), sum)
rollapply(zoo(1:5), 3, sum, align = "left")

# these two are the same
rollapply(zoo(1:5), list(-(2:0)), sum)
rollapply(zoo(1:5), 3, sum, align = "right")

# these two are the same
rollapply(zoo(1:6), list(NULL, NULL, -(2:0)), sum)
rollapply(zoo(1:6), 3, sum, by = 3, align = "right")

# these two are the same
rollapply(zoo(1:5), list(c(-1, 1)), sum)
rollapply(zoo(1:5), 3, function(x) sum(x[-2]))

# these two are the same
rollapply(1:5, 3, rev)
embed(1:5, 3)

# these four are the same
x &lt;- 1:6
rollapply(c(0, 0, x), 3, sum, align = "right") - x
rollapply(x, 3, sum, partial = TRUE, align = "right") - x
rollapply(x, 3, function(x) sum(x[-3]), partial = TRUE, align = "right")
rollapply(x, list(-(2:1)), sum, partial = 0)

# same as Matlab's buffer(x, n, p) for valid non-negative p
# See http://www.mathworks.com/help/toolbox/signal/buffer.html
x &lt;- 1:30; n &lt;- 7; p &lt;- 3
t(rollapply(c(rep(0, p), x, rep(0, n-p)), n, by = n-p, c))

# these three are the same
y &lt;- 10 * seq(8); k &lt;- 4; d &lt;- 2
# 1
# from http://ucfagls.wordpress.com/2011/06/14/embedding-a-time-series-with-time-delay-in-r-part-ii/
Embed &lt;- function(x, m, d = 1, indices = FALSE, as.embed = TRUE) {
    n &lt;- length(x) - (m-1)*d
    X &lt;- seq_along(x)
    if(n &lt;= 0)
        stop("Insufficient observations for the requested embedding")
    out &lt;- matrix(rep(X[seq_len(n)], m), ncol = m)
    out[,-1] &lt;- out[,-1, drop = FALSE] +
        rep(seq_len(m - 1) * d, each = nrow(out))
    if(as.embed)
        out &lt;- out[, rev(seq_len(ncol(out)))]
    if(!indices)
        out &lt;- matrix(x[out], ncol = m)
    out
}
Embed(y, k, d)
# 2
rollapply(y, list(-d * seq(0, k-1)), c)
# 3
rollapply(y, d*k-1, function(x) x[d * seq(k-1, 0) + 1])


## mimic convolve() using rollapplyr()
A &lt;- 1:4
B &lt;- 5:8
## convolve(..., type = "open")
cross &lt;- function(x) x 
rollapplyr(c(A, 0*B[-1]), length(B), cross, partial = TRUE)
convolve(A, B, type = "open")

# convolve(..., type = "filter")
rollapplyr(A, length(B), cross)
convolve(A, B, type = "filter")


# weighted sum including partials near ends, keeping
## alignment with wts correct
points &lt;- zoo(cbind(lon = c(11.8300715, 11.8296697,
    11.8268708, 11.8267236, 11.8249612, 11.8251062),
  lat = c(48.1099048, 48.10884, 48.1067431, 48.1066077,
    48.1037673, 48.103318),
  dist = c(46.8463805878941, 33.4921440879536, 10.6101735030534,
    18.6085009578724, 6.97253109610173, 9.8912817449265)))
mysmooth &lt;- function(z, wts = c(0.3, 0.4, 0.3)) { 
  notna &lt;- !is.na(z)
  sum(z[notna] * wts[notna]) / sum(wts[notna])
}
points2 &lt;- points
points2[, 1:2] &lt;- rollapply(rbind(NA, coredata(points)[, 1:2], NA), 3, mysmooth)
points2
</code></pre>

<hr>
<h2 id='rollmean'>Rolling Means/Maximums/Medians/Sums</h2><span id='topic+rollmean'></span><span id='topic+rollmax'></span><span id='topic+rollmedian'></span><span id='topic+rollsum'></span><span id='topic+rollmeanr'></span><span id='topic+rollmaxr'></span><span id='topic+rollmedianr'></span><span id='topic+rollsumr'></span><span id='topic+rollmean.zoo'></span><span id='topic+rollmax.zoo'></span><span id='topic+rollmedian.zoo'></span><span id='topic+rollsum.zoo'></span><span id='topic+rollmean.ts'></span><span id='topic+rollmax.ts'></span><span id='topic+rollmedian.ts'></span><span id='topic+rollsum.ts'></span><span id='topic+rollmean.default'></span><span id='topic+rollmax.default'></span><span id='topic+rollmedian.default'></span><span id='topic+rollsum.default'></span>

<h3>Description</h3>

<p>Generic functions for computing rolling means, maximums, medians, and sums of ordered observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rollmean(x, k, fill = if (na.pad) NA, na.pad = FALSE, 
  align = c("center", "left", "right"), ...)

rollmax(x, k, fill = if (na.pad) NA, na.pad = FALSE, 
  align = c("center", "left", "right"), ...)

rollmedian(x, k, fill = if (na.pad) NA, na.pad = FALSE, 
  align = c("center", "left", "right"), ...)

rollsum(x, k, fill = if (na.pad) NA, na.pad = FALSE, 
  align = c("center", "left", "right"), ...)

rollmeanr(..., align = "right")
rollmaxr(..., align = "right")
rollmedianr(..., align = "right")
rollsumr(..., align = "right")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rollmean_+3A_x">x</code></td>
<td>
<p>an object (representing a series of observations).</p>
</td></tr>
<tr><td><code id="rollmean_+3A_k">k</code></td>
<td>
<p>integer width of the rolling window. Must be odd for <code>rollmedian</code>.</p>
</td></tr>  
<tr><td><code id="rollmean_+3A_fill">fill</code></td>
<td>
<p>a three-component vector or list (recycled otherwise) providing
filling values at the left/within/to the right of the data range.
See the <code>fill</code> argument of <code><a href="data.table.html#topic+na.fill">na.fill</a></code> for details.</p>
</td></tr>
<tr><td><code id="rollmean_+3A_na.pad">na.pad</code></td>
<td>
<p>deprecated. Use <code>fill = NA</code> instead of <code>na.pad = TRUE</code>.</p>
</td></tr>
<tr><td><code id="rollmean_+3A_align">align</code></td>
<td>
<p>character specifying whether the index of the result
should be left- or right-aligned or centered (default) compared
to the rolling window of observations.</p>
</td></tr>
<tr><td><code id="rollmean_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions compute rolling means, maximums, medians, and sums respectively
and are thus similar to <code><a href="data.table.html#topic+rollapply">rollapply</a></code> but are
optimized for speed.
</p>
<p>Currently, there are methods for <code>"zoo"</code> and <code>"ts"</code> series and
default methods. The default method of <code>rollmedian</code>
is an interface to <code><a href="stats.html#topic+runmed">runmed</a></code>.
The default methods of <code>rollmean</code> and <code>rollsum</code> do not handle inputs that contain
<code>NA</code>s. In such cases, use <code><a href="data.table.html#topic+rollapply">rollapply</a></code> instead.
</p>
<p>If <code>x</code> is of length 0, <code>x</code> is returned unmodified.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>x</code> with the rolling mean/max/median/sum.
</p>


<h3>See Also</h3>

<p><code><a href="data.table.html#topic+rollapply">rollapply</a></code>, <code><a href="zoo.html#topic+zoo">zoo</a></code>, <code><a href="data.table.html#topic+na.fill">na.fill</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>suppressWarnings(RNGversion("3.5.0"))
set.seed(1)

x.Date &lt;- as.Date(paste(2004, rep(1:4, 4:1), sample(1:28, 10), sep = "-"))
x &lt;- zoo(rnorm(12), x.Date)

## rolling operations for univariate series
rollmean(x, 3)
rollmax(x, 3)
rollmedian(x, 3)
rollsum(x, 3)

## rolling operations for multivariate series
xm &lt;- zoo(matrix(1:12, 4, 3), x.Date[1:4])
rollmean(xm, 3)
rollmax(xm, 3)
rollmedian(xm, 3)
rollsum(xm, 3)

## rollapply vs. dedicated rollmean
rollapply(xm, 3, mean) # uses rollmean
rollapply(xm, 3, function(x) mean(x)) # does not use rollmean
</code></pre>

<hr>
<h2 id='window.zoo'>Extract/Replacing the Time Windows of Objects</h2><span id='topic+window.zoo'></span><span id='topic+window+3C-.zoo'></span>

<h3>Description</h3>

<p>Methods for extracting time windows
of <code>"zoo"</code> objects and replacing it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zoo'
window(x, index. = index(x), start = NULL, end = NULL, ...)
## S3 replacement method for class 'zoo'
window(x, index. = index(x), start = NULL, end = NULL, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="window.zoo_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="window.zoo_+3A_index.">index.</code></td>
<td>
<p>the index/time window which should be extracted.</p>
</td></tr>
<tr><td><code id="window.zoo_+3A_start">start</code></td>
<td>
<p>an index/time value. Only the indexes in <code>index</code>
which are greater or equal to <code>start</code> are used.  If the index
class supports comparisons to character variables, as does <code>"Date"</code>
class, <code>"yearmon"</code> class, <code>"yearqtr"</code> class and 
the <code>chron</code> package classes <code>"dates"</code> and <code>"times"</code>
then <code>start</code> may alternately be a character variable.</p>
</td></tr>
<tr><td><code id="window.zoo_+3A_end">end</code></td>
<td>
<p>an index/time value. Only the indexes in <code>index</code>
which are lower or equal to <code>end</code> are used.  Similar comments
about character variables mentioned under <code>start</code> apply
here too.</p>
</td></tr>
<tr><td><code id="window.zoo_+3A_value">value</code></td>
<td>
<p>a suitable value object for use with <code>window(x)</code>.</p>
</td></tr>
<tr><td><code id="window.zoo_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either the time window of the object is extracted (and hence return a <code>"zoo"</code>
object) or it is replaced.
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+zoo">zoo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>suppressWarnings(RNGversion("3.5.0"))
set.seed(1)

## zoo example
x.date &lt;- as.Date(paste(2003, rep(1:4, 4:1), seq(1,19,2), sep = "-"))
x &lt;- zoo(matrix(rnorm(20), ncol = 2), x.date)
x

window(x, start = as.Date("2003-02-01"), end = as.Date("2003-03-01"))
window(x, index = x.date[1:6], start = as.Date("2003-02-01"))
window(x, index = x.date[c(4, 8, 10)])
window(x, index = x.date[c(4, 8, 10)]) &lt;- matrix(1:6, ncol = 2)
x

## for classes that support comparisons with "character" variables
## start and end may be "character".
window(x, start = "2003-02-01")

## zooreg example (with plain numeric index)
z &lt;- zooreg(rnorm(10), start = 2000, freq = 4)
window(z, start = 2001.75)
window(z, start = c(2001, 4))

## replace data at times of d0 which are in dn
d1 &lt;- d0 &lt;- zoo(1:10) + 100
dn &lt;- - head(d0, 4)
window(d1, time(dn)) &lt;- coredata(dn)

## if the underlying time index is a float, note that the index may
## print in the same way but actually be different (e.g., differing
## by 0.1 second in this example)
zp &lt;- zoo(1:4, as.POSIXct("2000-01-01 00:00:00") + c(-3600, 0, 0.1, 3600))
## and then the &gt;= start and &lt;= end may not select all intended
## observations and adding/subtracting some "fuzz" may be needed
window(zp, end = "2000-01-01 00:00:00")
window(zp, end = as.POSIXct("2000-01-01 00:00:00") + 0.5)
</code></pre>

<hr>
<h2 id='xblocks'>
Plot contiguous blocks along x axis.
</h2><span id='topic+xblocks'></span><span id='topic+xblocks.default'></span><span id='topic+xblocks.zoo'></span><span id='topic+xblocks.ts'></span>

<h3>Description</h3>

<p>Plot contiguous blocks along x axis. A typical use would be to
highlight events or periods of missing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xblocks(x, ...)

## Default S3 method:
xblocks(x, y, ..., col = NULL, border = NA, 
        ybottom = par("usr")[3], ytop = ybottom + height,
        height = diff(par("usr")[3:4]),
        last.step = median(diff(tail(x))))

## S3 method for class 'zoo'
xblocks(x, y = x, ...)

## S3 method for class 'ts'
xblocks(x, y = x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xblocks_+3A_x">x</code>, <code id="xblocks_+3A_y">y</code></td>
<td>

<p>In the default method, <code>x</code> gives the ordinates along the x axis and
must be in increasing order. <code>y</code> gives the color values to plot as
contiguous blocks. If <code>y</code> is numeric, data coverage is plotted,
by converting it into a logical (<code>!is.na(y)</code>). Finally, if
<code>y</code> is a function, it is applied to <code>x</code> (<code>time(x)</code> in
the time series methods). 
</p>
<p>If <code>y</code> has character (or factor) values, these are interpreted
as colors &ndash; and should therefore be color names or hex
codes. Missing values in <code>y</code> are not plotted. The default color
is taken from <code>palette()[1]</code>. If <code>col</code> is given, this
over-rides the block colors given as <code>y</code>.
</p>
<p>The <code>ts</code> and <code>zoo</code> methods plot the <code>coredata(y)</code>
values against the time index <code>index(x)</code>. 
</p>
</td></tr>
<tr><td><code id="xblocks_+3A_...">...</code></td>
<td>

<p>In the default method, further arguments are graphical parameters
passed on to <code><a href="grid.html#topic+gpar">gpar</a></code>.
</p>
</td></tr>
<tr><td><code id="xblocks_+3A_col">col</code></td>
<td>

<p>if <code>col</code> is specified, it determines the colors of the blocks
defined by <code>y</code>. If multiple colors are specified they will be
repeated to cover the total number of blocks.
</p>
</td></tr>
<tr><td><code id="xblocks_+3A_border">border</code></td>
<td>

<p>border color.
</p>
</td></tr>
<tr><td><code id="xblocks_+3A_ybottom">ybottom</code>, <code id="xblocks_+3A_ytop">ytop</code>, <code id="xblocks_+3A_height">height</code></td>
<td>

<p>y axis position of the blocks. The default it to fill the whole plot
region, but by setting these values one can draw blocks along the
top of bottom of the plot. Note that <code>height</code> is not used
directly, it only sets the default value of <code>ytop</code>.
</p>
</td></tr>
<tr><td><code id="xblocks_+3A_last.step">last.step</code></td>
<td>

<p>width (in native units) of the final block. Defaults to the median of
the last 5 time steps (assuming steps are regular).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Blocks are drawn forward in &quot;time&quot; from the specified x locations,
up until the following value. Contiguous blocks are calculated using
<code><a href="base.html#topic+rle">rle</a></code>.
</p>


<h3>Author(s)</h3>

<p>Felix Andrews <a href="mailto:felix@nfrac.org">felix@nfrac.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+rect">rect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example time series:
suppressWarnings(RNGversion("3.5.0"))
set.seed(0)
flow &lt;- ts(filter(rlnorm(200, mean = 1), 0.8, method = "r"))

## highlight values above and below thresholds.
## this draws on top using semi-transparent colors.
rgb &lt;- hcl(c(0, 0, 260), c = c(100, 0, 100), l = c(50, 90, 50), alpha = 0.3)
plot(flow)
xblocks(flow &gt; 30, col = rgb[1]) ## high values red
xblocks(flow &lt; 15, col = rgb[3]) ## low value blue
xblocks(flow &gt;= 15 &amp; flow &lt;= 30, col = rgb[2]) ## the rest gray

## same thing:
plot(flow)
xblocks(time(flow), cut(flow, c(0,15,30,Inf), labels = rev(rgb)))

## another approach is to plot blocks underneath without transparency.
plot(flow)
## note that 'ifelse' keeps its result as class 'ts'
xblocks(ifelse(flow &lt; mean(flow), hcl(0, 0, 90), hcl(0, 80, 70)))
## need to redraw data series on top:
lines(flow)
box()

## for single series only: plot.default has a panel.first argument
plot(time(flow), flow, type = "l",
  panel.first = xblocks(flow &gt; 20, col = "lightgray"))
## (see also the 'panel' argument for use with multiple series, below)

## insert some missing values
flow[c(1:10, 50:80, 100)] &lt;- NA

## the default plot shows data coverage
## (most useful when displaying multiple series, see below)
plot(flow)
xblocks(flow)

## can also show gaps:
plot(flow, type = "s")
xblocks(time(flow), is.na(flow), col = "gray")

## Example of alternating colors, here showing calendar months
flowdates &lt;- as.Date("2000-01-01") + as.numeric(time(flow))
flowz &lt;- zoo(coredata(flow), flowdates)
plot(flowz)
xblocks(flowz, months, ## i.e. months(time(flowz)),
  col = gray.colors(2, start = 0.7), border = "slategray")
lines(flowz)

## Example of multiple series.
## set up example data
z &lt;- ts(cbind(A = 0:5, B = c(6:7, NA, NA, 10:11), C = c(NA, 13:17)))

## show data coverage only (highlighting gaps)
plot(z, panel = function(x, ...)
  xblocks(x, col = "darkgray"))

## draw gaps in darkgray
plot(z, type = "s", panel = function(x, ...) {
  xblocks(time(x), is.na(x), col = "darkgray")
  lines(x, ...); points(x)
})

## Example of overlaying blocks from a different series.
## Are US presidential approval ratings linked to sunspot activity?
## Set block height to plot blocks along the bottom.
plot(presidents)
xblocks(sunspot.year &gt; 50, height = 2)
</code></pre>

<hr>
<h2 id='xyplot.zoo'>Plot zoo Series with Lattice</h2><span id='topic+xyplot.zoo'></span><span id='topic+xyplot.its'></span><span id='topic+xyplot.tis'></span><span id='topic+llines.zoo'></span><span id='topic+llines.its'></span><span id='topic+llines.tis'></span><span id='topic+lpoints.zoo'></span><span id='topic+lpoints.its'></span><span id='topic+lpoints.tis'></span><span id='topic+ltext.zoo'></span><span id='topic+ltext.its'></span><span id='topic+ltext.tis'></span><span id='topic+panel.lines.zoo'></span><span id='topic+panel.lines.ts'></span><span id='topic+panel.lines.its'></span><span id='topic+panel.lines.tis'></span><span id='topic+panel.points.zoo'></span><span id='topic+panel.points.ts'></span><span id='topic+panel.points.its'></span><span id='topic+panel.points.tis'></span><span id='topic+panel.text.zoo'></span><span id='topic+panel.text.ts'></span><span id='topic+panel.text.its'></span><span id='topic+panel.text.tis'></span><span id='topic+panel.plot.default'></span><span id='topic+panel.plot.custom'></span><span id='topic+panel.segments.zoo'></span><span id='topic+panel.segments.ts'></span><span id='topic+panel.segments.its'></span><span id='topic+panel.segments.tis'></span><span id='topic+panel.rect.zoo'></span><span id='topic+panel.rect.ts'></span><span id='topic+panel.rect.its'></span><span id='topic+panel.rect.tis'></span><span id='topic+panel.polygon.zoo'></span><span id='topic+panel.polygon.ts'></span><span id='topic+panel.polygon.its'></span><span id='topic+panel.polygon.tis'></span>

<h3>Description</h3>

<p><code>xyplot</code> methods for time series objects (of class <code>"zoo"</code>,
<code>"its"</code>, or <code>"tis"</code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zoo'
xyplot(x, data, ...)

## S3 method for class 'zoo'
llines(x, y = NULL, ...)
## S3 method for class 'zoo'
lpoints(x, y = NULL, ...)
## S3 method for class 'zoo'
ltext(x, y = NULL, ...)

panel.segments.zoo(x0, x1, ...)
panel.rect.zoo(x0, x1, ...)
panel.polygon.zoo(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xyplot.zoo_+3A_x">x</code>, <code id="xyplot.zoo_+3A_x0">x0</code>, <code id="xyplot.zoo_+3A_x1">x1</code></td>
<td>
<p>time series object of class <code>"zoo"</code>, <code>"its"</code> or 
<code>"tis"</code>.  For <code>panel.plot.default</code> it should be a numeric
vector.</p>
</td></tr>
<tr><td><code id="xyplot.zoo_+3A_y">y</code></td>
<td>
<p>numeric vector or matrix.</p>
</td></tr>
<tr><td><code id="xyplot.zoo_+3A_data">data</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="xyplot.zoo_+3A_...">...</code></td>
<td>

<p>arguments are passed to <code><a href="lattice.html#topic+xyplot.ts">xyplot.ts</a></code>, and may be
passed through to <code><a href="lattice.html#topic+xyplot">xyplot</a></code> and
<code><a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code>.
</p>
<p>Some of the commonly used arguments are:
</p>

<dl>
<dt><code>screens</code></dt><dd><p>factor (or coerced to factor) whose levels specify which
graph each series is to be plotted in.  <code>screens = c(1, 2, 1)</code>
would plot series 1, 2 and 3 in graphs 1, 2 and 1. This also defines
the strip text in multi-panel plots.</p>
</dd>
<dt><code>scales</code></dt><dd><p> the default is set so that all
series have the <code>"same"</code> X axis but <code>"free"</code> Y axis. 
See <code><a href="lattice.html#topic+xyplot">xyplot</a></code> in the <span class="pkg">lattice</span> package for more
information on <code>scales</code>. </p>
</dd>
<dt><code>layout</code></dt><dd><p>numeric vector of length 2 specifying number of columns
and rows in the plot, see <code><a href="lattice.html#topic+xyplot">xyplot</a></code> for more details.
The default is to fill columns with up to 6 rows.</p>
</dd>
<dt><code>xlab</code></dt><dd><p>character string used as the X axis label.</p>
</dd>
<dt><code>ylab</code></dt><dd><p>character string used as the Y axis label. If there
are multiple panels it may be a character vector the same length
as the number of panels, but <em>NOTE</em> in this case the vector
should be reversed OR the argument <code>as.table</code> set to
<code>FALSE</code>.</p>
</dd>
<dt><code>lty, lwd, pch, type, col</code></dt><dd>
<p>graphical arguments passed to <code><a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code>.
These arguments can also be vectors or (named) lists, see details
for more information.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Details</h3>

<p><code>xyplot.zoo</code> plots a <code>"zoo"</code>, <code>"its"</code> or <code>"tis"</code>
object using <code><a href="lattice.html#topic+xyplot.ts">xyplot.ts</a></code> from
<span class="pkg">lattice</span>. Series of other classes are coerced to <code>"zoo"</code>
first. 
</p>
<p>The handling of several graphical parameters is more
flexible for multivariate series. These parameters can be
vectors of the same length as the number of series plotted or
are recycled if shorter. They can also be (partially) named list, e.g.,
<code>list(A = c(1,2), c(3,4))</code> in which <code>c(3, 4)</code> is the
default value and <code>c(1, 2)</code> the value only  for series <code>A</code>.
The <code>screens</code> argument can be specified in a similar way.
</p>
<p>Note that since <span class="pkg">zoo</span> 1.6-3 <code>plot.panel.default</code> and
<code>plot.panel.custom</code> are no longer necessary, as normal panel
functions (<code><a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code> by default) will work.
</p>
<p>Similarly, there are now methods for the generic <span class="pkg">lattice</span> drawing
functions <code><a href="lattice.html#topic+llines">llines</a></code>,
<code><a href="lattice.html#topic+llines">lpoints</a></code>, and
<code><a href="lattice.html#topic+llines">ltext</a></code>. These can also be called as 
<code>panel.lines</code>, <code>panel.points</code>, and <code>panel.text</code>,
respectively. The old interfaces (<code>panel.lines.zoo</code>,
<code>panel.points.zoo</code>, and <code>panel.text.zoo</code>), will be
removed in future versions. <code>panel.polygon.zoo</code> may also be
removed. 
</p>


<h3>Value</h3>

<p>Invisibly returns a <code>"trellis"</code> class object. Printing this
object using <code>print</code> will display it.
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+xyplot.ts">xyplot.ts</a></code>, <code><a href="zoo.html#topic+zoo">zoo</a></code>,
<code><a href="stats.html#topic+plot.ts">plot.ts</a></code>, <code><a href="graphics.html#topic+barplot">barplot</a></code>, <code><a href="zoo.html#topic+plot.zoo">plot.zoo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("lattice") &amp; require("grid")) {

suppressWarnings(RNGversion("3.5.0"))
set.seed(1)
z &lt;- zoo(cbind(a = 1:5, b = 11:15, c = 21:25) + rnorm(5))

# plot z using same Y axis on all plots
xyplot(z, scales = list(y = list(relation = "same", alternating = FALSE)))
 
# plot a double-line-width running mean on the panel of b.
# Also add a grid.
# We show two ways to do it. 

# change strip background to levels of grey
# If you like the defaults, this can be omitted.
strip.background &lt;- trellis.par.get("strip.background")
trellis.par.set(strip.background = list(col = grey(7:1/8)))


# Number 1.  Using trellis.focus.
print( xyplot(z) )
trellis.focus("panel", 1, 2, highlight = FALSE)
# (or just trellis.focus() for interactive use)
z.mean &lt;- rollmean(z, 3)
panel.lines(z.mean[,2], lwd = 2)
panel.grid(h = 10, v = 10, col = "grey", lty = 3)
trellis.unfocus()

# Number 2. Using a custom panel routine.
xyplot(z, panel = function(x, y, ...) {
    if (packet.number() == 2) {
        panel.grid(h = 10, v = 10, col = "grey", lty = 3)
        panel.lines(rollmean(zoo(y, x), 3), lwd = 2)
    }
    panel.xyplot(x, y, ...)
})

# plot a light grey rectangle "behind" panel b
trellis.focus("panel", 1, 2)
grid.rect(x = 2, w = 1, default.units = "native", 
  gp = gpar(fill = "light grey"))
# do.call("panel.xyplot", trellis.panelArgs())
do.call("panel.lines", trellis.panelArgs()[1:2])
trellis.unfocus()
# a better method is to use a custom panel function.
# see also panel.xblocks() and layer() in the latticeExtra package.

# same but make first panel twice as large as others
lopt &lt;- list(layout.heights = list(panel = list(x = c(2,1,1))))
xyplot(z, lattice.options = lopt)
# add a grid
update(trellis.last.object(), type = c("l", "g"))

# Plot all in one panel.
xyplot(z, screens = 1)
# Same with default styles and auto.key:
xyplot(z, superpose = TRUE)

# Plot first two columns in first panel and third column in second panel.
# Plot first series using points, second series using lines and third
#  series via overprinting both lines and points
# Use colors 1, 2 and 3 for the three series (1=black, 2=red, 3=green)
# Make 2nd (lower) panel 3x the height of the 1st (upper) panel
# Also make the strip background orange.
p &lt;- xyplot(z, screens = c(1,1,2), type = c("p", "l", "o"), col = 1:3,
  par.settings = list(strip.background = list(col = "orange")))
print(p, panel.height = list(y = c(1, 3), units = "null"))

# Example of using a custom axis
# Months are labelled with smaller ticks for weeks and even smaller
# ticks for days.
Days &lt;- seq(from = as.Date("2006-1-1"), to = as.Date("2006-8-8"), by = "day")
z1 &lt;- zoo(seq(length(Days))^2, Days)
Months &lt;- Days[format(Days, "%d") == "01"]
Weeks &lt;- Days[format(Days, "%w") == "0"]
print( xyplot(z1, scales = list(x = list(at = Months))) )
trellis.focus("panel", 1, 1, clip.off = TRUE)
panel.axis("bottom", check.overlap = TRUE, outside = TRUE, labels = FALSE, 
  tck = .7, at = as.numeric(Weeks))
panel.axis("bottom", check.overlap = TRUE, outside = TRUE, labels = FALSE, 
  tck = .4, at = as.numeric(Days))
trellis.unfocus()

trellis.par.set(strip.background = strip.background)

# separate the panels and suppress the ticks on very top
xyplot(z, between = list(y = 1), scales = list(tck = c(1,0)))

# left strips but no top strips
xyplot(z, screens = colnames(z), strip = FALSE, strip.left = TRUE)

# plot list of zoo objects using different x scales
z.l &lt;- list(
	zoo(cbind(a = rnorm(10), b = rnorm(10)), as.Date("2006-01-01") + 0:9),
	zoo(cbind(c = rnorm(10), d = rnorm(10)), as.Date("2006-12-01") + 0:9)
)
zm &lt;- do.call(merge, z.l)
xlim &lt;- lapply(zm, function(x) range(time(na.omit(x))))
xyplot(zm, xlim = xlim, scale = list(relation = "free"))
# to avoid merging see xyplot.list() in the latticeExtra package.

}

## Not run: 
## playwith (&gt;= 0.9)
library("playwith")

z3 &lt;- zoo(cbind(a = rnorm(100), b = rnorm(100) + 1), as.Date(1:100))
playwith(xyplot(z3), time.mode = TRUE)
# hold down Shift key and drag to zoom in to a time period.
# then use the horizontal scroll bar.

# set custom labels; right click on points to view or add labels
labs &lt;- paste(round(z3,1), index(z3), sep = "@")
trellis.par.set(user.text = list(cex = 0.7))
playwith(xyplot(z3, type = "o"), labels = labs)

# this returns indexes into times of clicked points 
ids &lt;- playGetIDs()
z3[ids,]

## another example of using playwith with zoo
# set up data
dat &lt;- zoo(matrix(rnorm(100*100),ncol=100), Sys.Date()+1:100)
colnames(dat) &lt;- paste("Series", 1:100)

# This will give you a spin button to choose the column to plot,
# and a button to print out the current series number.
playwith(xyplot(dat[,c(1,i)]),  parameters = list(i = 1:100,
   do_something = function(playState) print(playState$env$i))


## End(Not run)

</code></pre>

<hr>
<h2 id='yearmon'>An Index Class for Monthly Data</h2><span id='topic+yearmon'></span><span id='topic+as.yearmon'></span><span id='topic+as.yearmon.default'></span><span id='topic+as.yearmon.numeric'></span><span id='topic+as.yearmon.integer'></span><span id='topic+as.yearmon.date'></span><span id='topic+as.yearmon.dates'></span><span id='topic+as.yearmon.Date'></span><span id='topic+as.yearmon.timeDate'></span><span id='topic+as.yearmon.jul'></span><span id='topic+as.yearmon.POSIXt'></span><span id='topic+as.yearmon.character'></span><span id='topic+as.yearmon.date'></span><span id='topic+as.yearmon.factor'></span><span id='topic+as.Date'></span><span id='topic+as.Date.numeric'></span><span id='topic+as.Date.ts'></span><span id='topic+as.Date.yearmon'></span><span id='topic+as.POSIXct.yearmon'></span><span id='topic+as.POSIXlt.yearmon'></span><span id='topic+as.list.yearmon'></span><span id='topic+as.numeric.yearmon'></span><span id='topic+as.character.yearmon'></span><span id='topic+as.data.frame.yearmon'></span><span id='topic+c.yearmon'></span><span id='topic+cycle.yearmon'></span><span id='topic+format.yearmon'></span><span id='topic+is.numeric.yearmon'></span><span id='topic+mean.yearmon'></span><span id='topic+print.yearmon'></span><span id='topic+range.yearmon'></span><span id='topic+summary.yearmon'></span><span id='topic+unique.yearmon'></span><span id='topic++5B.yearmon'></span><span id='topic++5B+5B.yearmon'></span><span id='topic+MATCH.yearmon'></span><span id='topic+Ops.yearmon'></span><span id='topic+Summary.yearmon'></span><span id='topic+Sys.yearmon'></span><span id='topic+-.yearmon'></span><span id='topic+xtfrm.yearmon'></span>

<h3>Description</h3>

<p><code>"yearmon"</code> is a class for representing monthly data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yearmon(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yearmon_+3A_x">x</code></td>
<td>
<p>numeric (interpreted as being &ldquo;in years&rdquo;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>"yearmon"</code> class is used to represent monthly data. Internally it holds
the data as year plus 0 for January, 1/12 for February, 2/12 for March
and so on in order that its internal representation is the same as 
<code>ts</code> class with <code>frequency = 12</code>. If <code>x</code> is not in this
format it is rounded via <code>floor(12*x + .0001)/12</code>.
</p>
<p>There are coercion methods available for various classes including:
default coercion to <code>"yearmon"</code> (which coerces to <code>"numeric"</code> first)
and coercions to and from <code>"yearmon"</code> to <code>"Date"</code> (see below), 
<code>"POSIXct"</code>,
<code>"POSIXlt"</code>, <code>"numeric"</code>, <code>"character"</code> and <code>"jul"</code>.  
The last one is from the <code>"tis"</code> package available on CRAN.
In the case of <code>as.yearmon.POSIXt</code> the conversion is with respect to
GMT.  (Use <code>as.yearmon(format(...))</code> for other time zones.)
In the case of
<code>as.yearmon.character</code> the <code>format</code> argument uses the same
percent code as 
<code>"Date"</code>.   These are described in <code><a href="base.html#topic+strptime">strptime</a></code>.  Unlike
<code>"Date"</code> one can specify a year and month with no day.  
Default formats of <code>"%Y-%m"</code>, <code>"%Y-%m-%d"</code> and <code>"%b %Y"</code>.
</p>
<p>There is an <code>is.numeric</code> method which returns <code>FALSE</code>.
</p>
<p><code>as.Date.yearmon</code> and <code>as.yearmon.yearqtr</code> 
each has an optional
second argument of <code>"frac"</code> which is a number between 0 and 1 inclusive
that indicates the fraction of the way through the period that the result
represents.  The default is 0 which means the beginning of the period.
</p>
<p>There is also a <code>date</code> method for <code>as.yearmon</code> usable with objects
created with package <code>date</code>.
</p>
<p><code>Sys.yearmon()</code> returns the current year/month and methods for
<code>min</code>, <code>max</code> and <code>range</code> are defined (by defining 
a method for <code>Summary</code>).
</p>
<p>A <code>yearmon</code> <code>mean</code> method is also defined.
</p>


<h3>Value</h3>

<p>Returns its argument converted to class <code>yearmon</code>.
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+yearqtr">yearqtr</a></code>, <code><a href="zoo.html#topic+zoo">zoo</a></code>, <code><a href="zoo.html#topic+zooreg">zooreg</a></code>, <code><a href="stats.html#topic+ts">ts</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Sys.setenv(TZ = "GMT")

x &lt;- as.yearmon(2000 + seq(0, 23)/12)
x

as.yearmon("mar07", "%b%y")
as.yearmon("2007-03-01")
as.yearmon("2007-12")

# returned Date is the fraction of the way through
# the period given by frac (= 0 by default)
as.Date(x)
as.Date(x, frac = 1)
as.POSIXct(x)

# given a Date, x, return the Date of the next Friday
nextfri &lt;- function(x) 7 * ceiling(as.numeric(x - 1)/7) + as.Date(1)

# given a Date, d, return the same Date in the following month
# Note that as.Date.yearmon gives first Date of the month.
d &lt;- as.Date("2005-1-1") + seq(0,90,30)
next.month &lt;- function(d) as.Date(as.yearmon(d) + 1/12) + 
	as.numeric(d - as.Date(as.yearmon(d)))
next.month(d)

# 3rd Friday in last month of the quarter of Date x
## first day of last month of quarter
y &lt;- as.Date(zoo::as.yearmon(zoo::as.yearqtr(x), frac = 1))
## number of days to first Friday
n &lt;- sapply(y, function(z) which(format(z + 0:6, "%w") == "5")) - 1
## add number of days to third Friday
y + n + 14


suppressWarnings(RNGversion("3.5.0"))
set.seed(1)

z &lt;- zoo(rnorm(24), x, frequency = 12)
z
as.ts(z)

## convert data fram to multivariate monthly "ts" series
## 1.read raw data
Lines.raw &lt;- "ID Date Count
123 20 May 1999 1
123 21 May 1999 3
222 1 Feb 2000 2
222 3 Feb 2000 4
"
DF &lt;- read.table(text = Lines.raw, skip = 1,
 col.names = c("ID", "d", "b", "Y", "Count"))
## 2. fix raw date
DF$yearmon &lt;- as.yearmon(paste(DF$b, DF$Y), "%b %Y")
## 3. aggregate counts over months, convert to zoo and merge over IDs
ag &lt;- function(DF) aggregate(zoo(DF$Count), DF$yearmon, sum)
z &lt;- do.call("merge.zoo", lapply(split(DF, DF$ID), ag))
## 4. convert to "zooreg" and then to "ts"
frequency(z) &lt;- 12
as.ts(z)

xx &lt;- zoo(seq_along(x), x)

## aggregating over year 
as.year &lt;- function(x) as.numeric(floor(as.yearmon(x)))
aggregate(xx, as.year, mean)

</code></pre>

<hr>
<h2 id='yearqtr'>An Index Class for Quarterly Data</h2><span id='topic+yearqtr'></span><span id='topic+as.yearqtr'></span><span id='topic+as.yearqtr.default'></span><span id='topic+as.yearqtr.numeric'></span><span id='topic+as.yearqtr.integer'></span><span id='topic+as.yearqtr.date'></span><span id='topic+as.yearqtr.dates'></span><span id='topic+as.yearqtr.Date'></span><span id='topic+as.yearqtr.timeDate'></span><span id='topic+as.yearqtr.jul'></span><span id='topic+as.yearqtr.POSIXt'></span><span id='topic+as.yearqtr.character'></span><span id='topic+as.yearqtr.factor'></span><span id='topic+as.yearqtr.yearqtr'></span><span id='topic+as.Date.yearqtr'></span><span id='topic+as.POSIXct.yearqtr'></span><span id='topic+as.POSIXlt.yearqtr'></span><span id='topic+as.list.yearqtr'></span><span id='topic+as.numeric.yearqtr'></span><span id='topic+as.character.yearqtr'></span><span id='topic+as.data.frame.yearqtr'></span><span id='topic+c.yearqtr'></span><span id='topic+cycle.yearqtr'></span><span id='topic+format.yearqtr'></span><span id='topic+is.numeric.yearqtr'></span><span id='topic+mean.yearqtr'></span><span id='topic+print.yearqtr'></span><span id='topic+range.yearqtr'></span><span id='topic+summary.yearqtr'></span><span id='topic+unique.yearqtr'></span><span id='topic++5B.yearqtr'></span><span id='topic++5B+5B.yearqtr'></span><span id='topic+MATCH.yearqtr'></span><span id='topic+Ops.yearqtr'></span><span id='topic+Summary.yearqtr'></span><span id='topic+Sys.yearqtr'></span><span id='topic+-.yearqtr'></span><span id='topic+xtfrm.yearqtr'></span>

<h3>Description</h3>

<p><code>"yearqtr"</code> is a class for representing quarterly data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yearqtr(x)
as.yearqtr(x, ...)
## S3 method for class 'character'
as.yearqtr(x, format, ...)
## S3 method for class 'yearqtr'
format(x, format = "%Y Q%q", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yearqtr_+3A_x">x</code></td>
<td>
<p>for <code>yearqtr</code> a numeric (interpreted as being 
&ldquo;in years&rdquo;).  For <code>as.yearqtr</code> another date class
object.  For the <code>"yearqtr"</code> method of <code>format</code> an 
object of class <code>"yearqtr"</code> or if called as <code>format.yearqtr</code>
then an object with an <code>as.yearqtr</code> method that can be coerced 
to <code>"yearqtr"</code>.</p>
</td></tr>
<tr><td><code id="yearqtr_+3A_format">format</code></td>
<td>
<p>character string specifying format. For coercing to <code>"yearqtr"</code>
from character: <code>"%Y"</code> and <code>"%q"</code> have to be specified. For formatting an existing
<code>"yearqtr"</code>: <code>"%C"</code>, <code>"%Y"</code>, <code>"%y"</code> and <code>"%q"</code>, if present,
are replaced with the century, year, last two digits of the year, 
and quarter (i.e. a number between 1 and 4), respectively.</p>
</td></tr>
<tr><td><code id="yearqtr_+3A_...">...</code></td>
<td>
<p>arguments passed ot other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>"yearqtr"</code> class is used to represent quarterly data. Internally it holds
the data as year plus 0 for Quarter 1, 1/4 for Quarter 2
and so on in order that its internal representation is the same as 
<code>ts</code> class with <code>frequency = 4</code>. If <code>x</code> is not in this
format it is rounded via <code>floor(4*x + .0001)/4</code>.
</p>
<p><code>as.yearqtr.character</code> uses a default format of <code>"%Y Q%q"</code>, 
<code>"%Y q%q"</code> or <code>"%Y-%q"</code> according to whichever matches.
<code>%q</code> accepts the numbers 1-4 (possibly with leading zeros). Due to
this <code>%q</code> does not match to single digits only and consequently
formats such as <code>as.yearqtr("Q12000", "Q%q%Y")</code> are ambiguous and
do not work (i.e., result in <code>NA</code>).
</p>
<p>There are coercion methods available for various classes including:
default coercion to <code>"yearqtr"</code> (which coerces to <code>"numeric"</code> first)
and coercion from <code>"yearqtr"</code> to <code>"Date"</code> (see below), <code>"POSIXct"</code>,
<code>"POSIXlt"</code>, <code>"numeric"</code>, <code>"character"</code> and <code>"jul"</code>.  
The last one is from the <code>frame</code> package on CRAN.
</p>
<p>There is an <code>is.numeric</code> method which returns <code>FALSE</code>.
</p>
<p>There is also a <code>date</code> method for <code>as.yearqtr</code> usable with objects
created with package <code>date</code>.
</p>
<p><code>Sys.yearqtr()</code> returns the current year/month and methods for
<code>min</code>, <code>max</code> and <code>range</code> are defined (by defining 
a method for <code>Summary</code>).
</p>
<p>A <code>yearqtr</code> <code>mean</code> method is also defined.
</p>
<p>Certain methods support a <code>frac</code> argument.  See <code><a href="zoo.html#topic+yearmon">yearmon</a></code>.
</p>


<h3>Value</h3>

<p><code>yearqtr</code> and <code>as.yearqtr</code> return the first argument converted to 
class <code>yearqtr</code>.
The <code>format</code> method returns a character string representation of
its argument first argument.
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+yearmon">yearmon</a></code>, <code><a href="zoo.html#topic+zoo">zoo</a></code>, <code><a href="zoo.html#topic+zooreg">zooreg</a></code>, <code><a href="stats.html#topic+ts">ts</a></code>,
<code><a href="base.html#topic+strptime">strptime</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>Sys.setenv(TZ = "GMT")

x &lt;- as.yearqtr(2000 + seq(0, 7)/4)
x

format(x, "%Y Quarter %q")
as.yearqtr("2001 Q2")
as.yearqtr("2001 q2") # same
as.yearqtr("2001-2") # same

# returned Date is the fraction of the way through
# the period given by frac (= 0 by default)
dd &lt;- as.Date(x)
format.yearqtr(dd)
as.Date(x, frac = 1)
as.POSIXct(x)

suppressWarnings(RNGversion("3.5.0"))
set.seed(1)

zz &lt;- zoo(rnorm(8), x, frequency = 4)
zz
as.ts(zz)

</code></pre>

<hr>
<h2 id='zoo'>Z's Ordered Observations</h2><span id='topic+zoo'></span><span id='topic+with.zoo'></span><span id='topic+range.zoo'></span><span id='topic+print.zoo'></span><span id='topic+as.zoo.factor'></span><span id='topic+summary.zoo'></span><span id='topic+str.zoo'></span><span id='topic+is.zoo'></span><span id='topic++5B.zoo'></span><span id='topic++5B+3C-.zoo'></span><span id='topic++24.zoo'></span><span id='topic++24+3C-.zoo'></span><span id='topic+subset.zoo'></span><span id='topic+head.zoo'></span><span id='topic+tail.zoo'></span><span id='topic+Ops.zoo'></span><span id='topic+t.zoo'></span><span id='topic+cumsum.zoo'></span><span id='topic+cumprod.zoo'></span><span id='topic+cummin.zoo'></span><span id='topic+cummax.zoo'></span><span id='topic+mean.zoo'></span><span id='topic+median.zoo'></span><span id='topic+na.contiguous'></span><span id='topic+na.contiguous.data.frame'></span><span id='topic+na.contiguous.list'></span><span id='topic+na.contiguous.default'></span><span id='topic+na.contiguous.zoo'></span><span id='topic+scale.zoo'></span><span id='topic+xtfrm.zoo'></span><span id='topic+names.zoo'></span><span id='topic+names+3C-.zoo'></span><span id='topic+quantile.zoo'></span><span id='topic+rev.zoo'></span><span id='topic+transform.zoo'></span><span id='topic+ifelse.zoo'></span><span id='topic+dim+3C-.zoo'></span><span id='topic+index2char'></span><span id='topic+index2char.default'></span><span id='topic+index2char.numeric'></span><span id='topic+index2char.POSIXt'></span><span id='topic+head.ts'></span><span id='topic+tail.ts'></span>

<h3>Description</h3>

<p><code>zoo</code> is the creator for an S3 class of indexed
totally ordered observations which includes irregular
time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zoo(x = NULL, order.by = index(x), frequency = NULL,
  calendar = getOption("zoo.calendar", TRUE))
## S3 method for class 'zoo'
print(x, style = , quote = FALSE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zoo_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix or a factor.</p>
</td></tr>
<tr><td><code id="zoo_+3A_order.by">order.by</code></td>
<td>
<p>an index vector with unique entries by which the
observations in <code>x</code> are ordered. See the details for support
of non-unique indexes.</p>
</td></tr>
<tr><td><code id="zoo_+3A_frequency">frequency</code></td>
<td>
<p>numeric indicating frequency of <code>order.by</code>.
If specified, it is checked whether <code>order.by</code> and <code>frequency</code>
comply. If so, a regular <code>"zoo"</code> series is returned, i.e.,
an object of class <code>c("zooreg", "zoo")</code>. See below and
<code><a href="zoo.html#topic+zooreg">zooreg</a></code> for more details.</p>
</td></tr>
<tr><td><code id="zoo_+3A_calendar">calendar</code></td>
<td>
<p>logical. If <code>frequency</code> is specified and is 4 or 12:
Should <code><a href="zoo.html#topic+yearqtr">yearqtr</a></code> or <code><a href="zoo.html#topic+yearmon">yearmon</a></code> be used for a numeric
index <code>order.by</code>?</p>
</td></tr>
<tr><td><code id="zoo_+3A_style">style</code></td>
<td>
<p>a string specifying the printing style which can be
<code>"horizontal"</code> (the default for vectors), <code>"vertical"</code>
(the default for matrices) or <code>"plain"</code> (which first prints
the data and then the index).</p>
</td></tr>
<tr><td><code id="zoo_+3A_quote">quote</code></td>
<td>
<p>logical. Should characters be quoted?</p>
</td></tr>
<tr><td><code id="zoo_+3A_...">...</code></td>
<td>
<p>further arguments passed to the print methods of
the data and the index.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>zoo</code> provides infrastructure for ordered observations
which are stored internally in a vector or matrix with an
index attribute (of arbitrary class, see below).  The index
must have the same length as <code>NROW(x)</code> except in the 
case of a zero length numeric vector in which case the index
length can be any length. Emphasis has
been given to make all methods independent of the index/time class
(given in <code>order.by</code>). In principle, the data <code>x</code> could also
be arbitrary, but currently there is only support for vectors and matrices
and partial support for factors.
</p>
<p><code>zoo</code> is particularly aimed at irregular time series of numeric
vectors/matrices, but it also supports regular time series (i.e.,
series with a certain <code>frequency</code>).
<code>zoo</code>'s key design goals are independence of a particular
index/date/time class and consistency 
with <code>ts</code> and base <span class="rlang"><b>R</b></span> by providing methods to standard generics. Therefore,
standard functions can be used to work with <code>"zoo"</code> objects and 
memorization of new commands is reduced.
</p>
<p>When creating a <code>"zoo"</code> object with the function <code>zoo</code>,
the vector of indexes <code>order.by</code> can be of (a single) arbitrary class
(if <code>x</code> is shorter or longer than <code>order.by</code> it is
expanded accordingly),
but it is essential that <code>ORDER(order.by)</code> works. For other
functions it is assumed that <code>c()</code>, <code>length()</code>,
<code>MATCH()</code> and subsetting <code>[,</code> work. If this is not the case
for a particular index/date/time class, then methods for these 
generic functions should be created by the user. Note, that to achieve this,
new generic functions <code><a href="zoo.html#topic+ORDER">ORDER</a></code> and <code><a href="zoo.html#topic+MATCH">MATCH</a></code> are created in
the <code>zoo</code> package with default methods corresponding to
the non-generic base functions <code><a href="base.html#topic+order">order</a></code> 
and <code><a href="base.html#topic+match">match</a></code>. Note that the <code><a href="base.html#topic+order">order</a></code> 
and hence the default <code><a href="zoo.html#topic+ORDER">ORDER</a></code> typically work if there is a
<code><a href="base.html#topic+xtfrm">xtfrm</a></code> method. Furthermore, for certain (but not for all)
operations the index class should have an <code>as.numeric</code> method (in 
particular for regular series) and an <code>as.character</code> method might improve
printed output (see also below).
</p>
<p>The index observations <code>order.by</code> should typically be unique, such that
the observations can be totally ordered. Nevertheless, <code>zoo()</code> is able to create
<code>"zoo"</code> objects with duplicated indexes (with a warning) and simple methods such as <code>plot()</code>
or <code>summary()</code> will typically work for such objects. However, this is
not formally supported as the bulk of functionality provided in <span class="pkg">zoo</span> requires
unique index observations/time stamps. See below for an example how to remove
duplicated indexes.
</p>
<p>If a <code>frequency</code> is specified when creating a series via <code>zoo</code>, the
object returned is actually of class <code>"zooreg"</code> which inherits from <code>"zoo"</code>.
This is a subclass of <code>"zoo"</code> which relies on having a <code>"zoo"</code> series
with an additional <code>"frequency"</code> attribute (which has to comply with the
index of that series). Regular <code>"zooreg"</code> series can also be created by
<code><a href="zoo.html#topic+zooreg">zooreg</a></code>, the <code>zoo</code> analogue of <code><a href="stats.html#topic+ts">ts</a></code>. See the 
respective help page and <code><a href="zoo.html#topic+is.regular">is.regular</a></code> for further details.
</p>
<p>Methods to standard generics for <code>"zoo"</code> objects currently
include: <code>print</code> (see above), <code>summary</code>, <code>str</code>, <code>head</code>,
<code>tail</code>, <code>[</code> (subsetting), <code>rbind</code>, <code>cbind</code>, <code>merge</code>
(see <code><a href="zoo.html#topic+merge.zoo">merge.zoo</a></code>), <code>aggregate</code> (see <code><a href="zoo.html#topic+aggregate.zoo">aggregate.zoo</a></code>), <code>rev</code>, <code>split</code> (see <code><a href="zoo.html#topic+aggregate.zoo">aggregate.zoo</a></code>), <code>barplot</code>,
<code>plot</code> and <code>lines</code> (see <code><a href="zoo.html#topic+plot.zoo">plot.zoo</a></code>). For multivariate
<code>"zoo"</code> series with column names the <code>$</code> extractor is available,
behaving similar as for <code>"data.frame"</code> objects.  Methods are also
available for <code>median</code> and <code>quantile</code>.
</p>
<p><code>ifelse.zoo</code> is not a method (because <code>ifelse</code> is not a generic) 
but must be written out including the <code>.zoo</code> suffix.
</p>
<p>To &ldquo;prettify&rdquo; printed output of <code>"zoo"</code> series the generic 
function <code>index2char</code> is used for turning index values into character
values. It defaults to using <code>as.character</code> but can be customized
if a different printed display should be used (although this should not
be necessary, usually).
</p>
<p>The subsetting method <code>[</code> work essentially like the
corresponding functions for vectors or matrices respectively, i.e., takes
indexes of type <code>"numeric"</code>, <code>"integer"</code> or <code>"logical"</code>. But
additionally, it can be used to index with observations from the index class of
the series. If the index class of the series is one of the three classes above,
the corresponding index has to be encapsulated in <code>I()</code> to enforce usage of
the index class (see examples).   Subscripting by a zoo object whose
data contains logical values is undefined.
</p>
<p>Additionally, <code>zoo</code> provides several generic functions and methods
to work (a) on the data contained in a <code>"zoo"</code> object, (b) the
index (or time) attribute associated to it, and (c) on both data and
index:
</p>
<p>(a) The data contained in <code>"zoo"</code> objects can be extracted by
<code>coredata</code> (strips off all <code>"zoo"</code>-specific attributes) and modified
using <code>coredata&lt;-</code>. Both are new generic functions with methods for
<code>"zoo"</code> objects, see <code><a href="zoo.html#topic+coredata">coredata</a></code>.
</p>
<p>(b) The index associated with a <code>"zoo"</code> object can be extracted
by <code>index</code> and modified by <code>index&lt;-</code>. As the interpretation
of the index as &ldquo;time&rdquo; in time series applications is more natural,
there are also synonymous methods <code>time</code> and <code>time&lt;-</code>. The
start and the end of the index/time vector can be queried by
<code>start</code> and <code>end</code>. See <code><a href="quanteda.html#topic+index">index</a></code>.
</p>
<p>(c) To work on both data and index/time, <code>zoo</code> provides methods
<code>lag</code>, <code>diff</code> (see <code><a href="zoo.html#topic+lag.zoo">lag.zoo</a></code>) and <code>window</code>, 
<code>window&lt;-</code> (see <code><a href="zoo.html#topic+window.zoo">window.zoo</a></code>).
</p>
<p>In addition to standard group generic function (see <code><a href="methods.html#topic+Ops">Ops</a></code>),
the following mathematical operations are available as methods for
<code>"zoo"</code> objects: transpose <code>t</code> which coerces to a matrix 
first, and <code>cumsum</code>, <code>cumprod</code>, <code>cummin</code>, <code>cummax</code>
which are applied column wise.
</p>
<p>Coercion to and from <code>"zoo"</code> objects is available for objects of
various classes, in particular <code>"ts"</code>, <code>"irts"</code> and <code>"its"</code>
objects can be coerced to <code>"zoo"</code>, the reverse is available for
<code>"its"</code> and for <code>"irts"</code> (the latter in package <code>tseries</code>).
Furthermore, <code>"zoo"</code> objects can be coerced to vectors, matrices and
lists and data frames (dropping the index/time attribute). See <code><a href="zoo.html#topic+as.zoo">as.zoo</a></code>.
</p>
<p>Several methods are available for <code>NA</code> handling in the data of 
<code>"zoo"</code> objects: 
<code><a href="zoo.html#topic+na.aggregate">na.aggregate</a></code> which uses group means to fill in <code>NA</code>
values,
<code><a href="zoo.html#topic+na.approx">na.approx</a></code> which uses linear interpolation to fill 
in <code>NA</code> values. 
<code><a href="stats.html#topic+na.contiguous">na.contiguous</a></code> which extracts the longest consecutive 
stretch of non-missing values in a <code>"zoo"</code> object,
<code><a href="data.table.html#topic+na.fill">na.fill</a></code> which uses fixed specified values to replace <code>NA</code>
values,
<code><a href="zoo.html#topic+na.locf">na.locf</a></code> which
replaces <code>NA</code>s by the last previous non-<code>NA</code>, 
<code><a href="stats.html#topic+na.omit">na.omit</a></code> which returns a <code>"zoo"</code>
object with incomplete observations removed,
<code><a href="zoo.html#topic+na.spline">na.spline</a></code> which uses spline interpolation to fill 
in <code>NA</code> values and
<code><a href="zoo.html#topic+na.StructTS">na.StructTS</a></code> which uses a seasonal Kalman filter to fill in
<code>NA</code> values,
<code><a href="zoo.html#topic+na.trim">na.trim</a></code> which trims runs of <code>NA</code>s off the beginning and
end but not in the interior.  Yet another <code>NA</code> routine can be found in
the <code>stinepack</code> package where <code>na.stinterp</code>
performs Stineman interpolation.
</p>
<p>A typical task to be performed on ordered observations is to evaluate some
function, e.g., computing the mean, in a window of observations that is moved
over the full sample period. The generic function <code><a href="data.table.html#topic+rollapply">rollapply</a></code>
provides this functionality for arbitrary functions and more efficient versions
<code><a href="data.table.html#topic+rollmean">rollmean</a></code>, <code><a href="zoo.html#topic+rollmax">rollmax</a></code>, <code><a href="zoo.html#topic+rollmedian">rollmedian</a></code> are
available for the mean, maximum and median respectively.
</p>
<p>The <span class="pkg">zoo</span> package has an <code>as.Date</code> <code>numeric</code> method
which is similar to the one in the core of <span class="rlang"><b>R</b></span> except that the
<code>origin</code> argument defaults to January 1, 1970 (whereas the one
in the core of <span class="rlang"><b>R</b></span> has no default).
</p>
<p>Note that since <code>zoo</code> uses date/time classes from base <span class="rlang"><b>R</b></span> and 
other packages, it may inherit bugs or problems with those date/time classes.
Currently, there is one such known problem with the <code>c</code> method for
the <code>POSIXct</code> class in base <span class="rlang"><b>R</b></span>:
If <code>x</code> and <code>y</code> are <code>POSIXct</code> objects with <code>tzone</code>
attributes, the attribute will always be dropped in <code>c(x, y)</code>, even
if it is the same across both <code>x</code> and <code>y</code>. Although this is documented
at <code><a href="base.html#topic+DateTimeClasses">c.POSIXct</a></code>, one may want to employ a workaround
as shown at <a href="https://stat.ethz.ch/pipermail/r-devel/2010-August/058112.html">https://stat.ethz.ch/pipermail/r-devel/2010-August/058112.html</a>.
</p>


<h3>Value</h3>

<p>A vector or matrix with an <code>"index"</code> attribute of the same
dimension (<code>NROW(x)</code>) by which <code>x</code> is ordered.
</p>


<h3>References</h3>

<p>Achim Zeileis and Gabor Grothendieck (2005).
<span class="pkg">zoo</span>: S3 Infrastructure for Regular and Irregular Time Series.
<em>Journal of Statistical Software</em>, <b>14(6)</b>, 1-27.
URL http://www.jstatsoft.org/v14/i06/ and available as 
<code>vignette("zoo")</code>.
</p>
<p>Ajay Shah, Achim Zeileis and Gabor Grothendieck (2005).
<span class="pkg">zoo</span> Quick Reference.
Package vignette available as <code>vignette("zoo-quickref")</code>.  
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+zooreg">zooreg</a></code>, <code><a href="zoo.html#topic+plot.zoo">plot.zoo</a></code>, <code><a href="quanteda.html#topic+index">index</a></code>, <code><a href="zoo.html#topic+merge.zoo">merge.zoo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>suppressWarnings(RNGversion("3.5.0"))
set.seed(1)

## simple creation and plotting
x.Date &lt;- as.Date("2003-02-01") + c(1, 3, 7, 9, 14) - 1
x &lt;- zoo(rnorm(5), x.Date)
plot(x)
time(x)

## subsetting with numeric indexes
x[c(2, 4)]
## subsetting with index class
x[as.Date("2003-02-01") + c(2, 8)]

## different classes of indexes/times can be used, e.g. numeric vector
x &lt;- zoo(rnorm(5), c(1, 3, 7, 9, 14))
## subsetting with numeric indexes then uses observation numbers
x[c(2, 4)]
## subsetting with index class can be enforced by I()
x[I(c(3, 9))]

## visualization
plot(x)
## or POSIXct
y.POSIXct &lt;- ISOdatetime(2003, 02, c(1, 3, 7, 9, 14), 0, 0, 0)
y &lt;- zoo(rnorm(5), y.POSIXct)
plot(y)

## create a constant series
z &lt;- zoo(1, seq(4)[-2])

## create a 0-dimensional zoo series
z0 &lt;- zoo(, 1:4)

## create a 2-dimensional zoo series
z2 &lt;- zoo(matrix(1:12, 4, 3), as.Date("2003-01-01") + 0:3)

## create a factor zoo object
fz &lt;- zoo(gl(2,5), as.Date("2004-01-01") + 0:9)

## create a zoo series with 0 columns
z20 &lt;- zoo(matrix(nrow = 4, ncol = 0), 1:4)

## arithmetic on zoo objects intersects them first
x1 &lt;- zoo(1:5, 1:5)
x2 &lt;- zoo(2:6, 2:6)
10 * x1 + x2

## $ extractor for multivariate zoo series with column names
z &lt;- zoo(cbind(foo = rnorm(5), bar = rnorm(5)))
z$foo
z$xyz &lt;- zoo(rnorm(3), 2:4)
z

## add comments to a zoo object
comment(x1) &lt;- c("This is a very simple example of a zoo object.",
  "It can be recreated using this R code: example(zoo)")
## comments are not output by default but are still there
x1
comment(x1)

# ifelse does not work with zoo but this works
# to create a zoo object which equals x1 at
# time i if x1[i] &gt; x1[i-1] and 0 otherwise
(diff(x1) &gt; 0) * x1

## zoo series with duplicated indexes
z3 &lt;- zoo(1:8, c(1, 2, 2, 2, 3, 4, 5, 5))
plot(z3)
## remove duplicated indexes by averaging
lines(aggregate(z3, index(z3), mean), col = 2)
## or by using the last observation
lines(aggregate(z3, index(z3), tail, 1), col = 4)

## x1[x1 &gt; 3] is not officially supported since
## x1 &gt; 3 is of class "zoo", not "logical".
## Use one of these instead:
x1[which(x1 &gt; 3)]
x1[coredata(x1 &gt; 3)]
x1[as.logical(x1 &gt; 3)]
subset(x1, x1 &gt; 3)

## any class supporting the methods discussed can be used
## as an index class. Here are examples using complex numbers
## and letters as the time class.

z4 &lt;- zoo(11:15, complex(real = c(1, 3, 4, 5, 6), imag = c(0, 1, 0, 0, 1)))
merge(z4, lag(z4))

z5 &lt;- zoo(11:15, letters[1:5])
merge(z5, lag(z5))

# index values relative to 2001Q1
zz &lt;- zooreg(cbind(a = 1:10, b = 11:20), start = as.yearqtr(2000), freq = 4)
zz[] &lt;- mapply("/", as.data.frame(zz), coredata(zz[as.yearqtr("2001Q1")]))


## even though time index must be unique zoo (and read.zoo)
## will both allow creation of such illegal objects with
## a warning (rather than ana error) to give the user a 
## chance to fix them up.  Extracting and replacing times
## and aggregate.zoo will still work.
## Not run: 
# this gives a warning
# and then creates an illegal zoo object
z6 &lt;- zoo(11:15, c(1, 1, 2, 2, 5))
z6

# fix it up by averaging duplicates
aggregate(z6, identity, mean)

# or, fix it up by taking last in each set of duplicates
aggregate(z6, identity, tail, 1)

# fix it up via interpolation of duplicate times
time(z6) &lt;- na.approx(ifelse(duplicated(time(z6)), NA, time(z6)), na.rm = FALSE)
# if there is a run of equal times at end they
# wind up as NAs and we cannot have NA times
z6 &lt;- z6[!is.na(time(z6))]
z6

x1. &lt;- x1 &lt;- zoo (matrix (1:12, nrow = 3), as.Date("2008-08-01") + 0:2)
colnames (x1) &lt;- c ("A", "B", "C", "D")
x2 &lt;- zoo (matrix (1:12, nrow = 3), as.Date("2008-08-01") + 1:3)
colnames (x2) &lt;- c ("B", "C", "D", "E")

both.dates = as.Date (intersect (index (t1), index (t2)))
both.cols = intersect (colnames (t1), colnames (t2))

x1[both.dates, both.cols]
## there is "[.zoo" but no "[&lt;-.zoo" however four of the following
## five examples work

## wrong
## x1[both.dates, both.cols] &lt;- x2[both.dates, both.cols]

# 4 correct alternatives
# #1
window(x1, both.dates)[, both.cols] &lt;- x2[both.dates, both.cols]

# #2. restore x1 and show a different way
x1 &lt;- x1.
window(x1, both.dates)[, both.cols] &lt;- window(x2, both.dates)[, both.cols]

# #3. restore x1 and show a different way
x1 &lt;- x1.
x1[time(x1) 

# #4. restore x1 and show a different way
x1 &lt;- x1.
x1[time(x1) 


## End(Not run)

</code></pre>

<hr>
<h2 id='zooreg'>Regular zoo Series</h2><span id='topic+zooreg'></span><span id='topic+frequency.zooreg'></span><span id='topic+frequency.zoo'></span><span id='topic+deltat.zooreg'></span><span id='topic+deltat.zoo'></span><span id='topic+cycle.zooreg'></span><span id='topic+cycle.zoo'></span><span id='topic+as.zooreg'></span><span id='topic+as.zooreg.default'></span><span id='topic+as.zooreg.ts'></span><span id='topic+as.zooreg.its'></span><span id='topic+as.zooreg.xts'></span><span id='topic+as.ts.zooreg'></span><span id='topic+as.zoo.zooreg'></span><span id='topic+as.zooreg.zoo'></span><span id='topic+index+3C-.zooreg'></span><span id='topic+time+3C-.zooreg'></span><span id='topic+lag.zooreg'></span>

<h3>Description</h3>

<p><code>zooreg</code> is the creator for the S3 class <code>"zooreg"</code>
for regular <code>"zoo"</code> series. It inherits from <code>"zoo"</code>
and is the analogue to <code><a href="stats.html#topic+ts">ts</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zooreg(data, start = 1, end = numeric(), frequency = 1, 
  deltat = 1, ts.eps = getOption("ts.eps"), order.by = NULL,
  calendar = getOption("zoo.calendar", TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zooreg_+3A_data">data</code></td>
<td>
<p>a numeric vector, matrix or a factor.</p>
</td></tr>
<tr><td><code id="zooreg_+3A_start">start</code></td>
<td>
<p>the time of the first observation.  Either a single number or
a vector of two integers, which specify a natural time unit
and a (1-based) number of samples into the time unit.</p>
</td></tr>
<tr><td><code id="zooreg_+3A_end">end</code></td>
<td>
<p>the time of the last observation, specified in the same way
as <code>start</code>.</p>
</td></tr>
<tr><td><code id="zooreg_+3A_frequency">frequency</code></td>
<td>
<p>the number of observations per unit of time.</p>
</td></tr>
<tr><td><code id="zooreg_+3A_deltat">deltat</code></td>
<td>
<p>the fraction of the sampling period between successive
observations; e.g., 1/12 for monthly data.  Only one of
<code>frequency</code> or <code>deltat</code> should be provided.</p>
</td></tr>
<tr><td><code id="zooreg_+3A_ts.eps">ts.eps</code></td>
<td>
<p>time series comparison tolerance.  Frequencies are considered
equal if their absolute difference is less than <code>ts.eps</code>.</p>
</td></tr>
<tr><td><code id="zooreg_+3A_order.by">order.by</code></td>
<td>
<p>a vector by which the observations in <code>x</code>
are ordered. If this is specified the arguments <code>start</code> and
<code>end</code> are ignored and <code>zoo(data, order.by, frequency)</code> is
called. See <code><a href="zoo.html#topic+zoo">zoo</a></code> for more information.</p>
</td></tr>
<tr><td><code id="zooreg_+3A_calendar">calendar</code></td>
<td>
<p>logical. Should <code><a href="zoo.html#topic+yearqtr">yearqtr</a></code> or <code><a href="zoo.html#topic+yearmon">yearmon</a></code>
be used for a numeric time index with frequency 4 or 12, respectively?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Strictly regular series are those whose time points are equally spaced.
Weakly regular series are strictly regular time series in which some
of the points may have been removed but still have the original
underlying frequency associated with them.
<code>"zooreg"</code> is a subclass of <code>"zoo"</code> that is used to represent both weakly
and strictly regular series. Internally, it is the same as <code>"zoo"</code> except 
it also has a <code>"frequency"</code> attribute. Its index class is more restricted 
than <code>"zoo"</code>. The index: 1. must be numeric or a class which can be coerced
via <code>as.numeric</code> (such as <code><a href="zoo.html#topic+yearmon">yearmon</a></code>, <code><a href="zoo.html#topic+yearqtr">yearqtr</a></code>,
<code><a href="base.html#topic+Date">Date</a></code>, <code><a href="base.html#topic+POSIXct">POSIXct</a></code>, <code><a href="tis.html#topic+tis">tis</a></code>, 
<code><a href="xts.html#topic+xts">xts</a></code>, etc.). 
2. when converted to numeric
must be expressible as multiples of 1/frequency. 3.
group generic functions <code><a href="methods.html#topic+Ops">Ops</a></code> should be defined, i.e.,
adding/subtracting a numeric to/from the index class should produce the correct
value of the index class again.
</p>
<p><code>zooreg</code> is the <code>zoo</code> analogue to <code><a href="stats.html#topic+ts">ts</a></code>. The arguments
are almost identical, only in the case where <code>order.by</code> is specified,
<code><a href="zoo.html#topic+zoo">zoo</a></code> is called with <code>zoo(data, order.by, frequency)</code>. It
creates a regular series of class <code>"zooreg"</code> which inherits from <code>"zoo"</code>.
It is essentially a <code>"zoo"</code> series with an additional <code>"frequency"</code>
attribute. In the creation of <code>"zooreg"</code> objects (via <code><a href="zoo.html#topic+zoo">zoo</a></code>,
<code><a href="zoo.html#topic+zooreg">zooreg</a></code>, or coercion functions) it is always check whether the
index specified complies with the frequency specified.
</p>
<p>The class <code>"zooreg"</code> offers two advantages over code <code>"ts"</code>: 1. The
index does not have to be plain numeric (although that is the default), it just
must be coercible to numeric, thus printing and plotting can be customized.
2. This class can not only represent strictly regular series, but also series
with an underlying regularity, i.e., where some observations from a regular grid
are omitted.
</p>
<p>Hence, <code>"zooreg"</code> is a bridge between <code>"ts"</code> and <code>"zoo"</code> and
can be employed to coerce back and forth between the two classes. The coercion
function <code>as.zoo.ts</code> returns therefore an object of class <code>"zooreg"</code>
inheriting from <code>"zoo"</code>. Coercion between <code>"zooreg"</code> and <code>"zoo"</code>
is also available and drops or tries to add a frequency respectively.
</p>
<p>For checking whether a series is strictly regular or does have an underlying
regularity the generic function <code><a href="zoo.html#topic+is.regular">is.regular</a></code> can be used.
</p>
<p>Methods to standard generics for regular series such as <code><a href="stats.html#topic+frequency">frequency</a></code>,
<code><a href="stats.html#topic+deltat">deltat</a></code> and <code><a href="stats.html#topic+cycle">cycle</a></code> are available for both <code>"zooreg"</code>
and <code>"zoo"</code> objects. In the latter case, it is checked first (in a data-driven way)
whether the series is in fact regular or not.
</p>
<p><code>as.zooreg.tis</code> has a <code>class</code> argument whose value represents the
class of the index of the <code>zooreg</code> object into which the <code>tis</code>
object is converted.  The default value is <code>"ti"</code>.  Note that the 
frequency of the <code>zooreg</code> object will not necessarily be the same
as the frequency of the <code>tis</code> object that it is converted from.  
</p>


<h3>Value</h3>

<p>An object of class <code>"zooreg"</code> which inherits from <code>"zoo"</code>.
It is essentially a <code>"zoo"</code> series with a <code>"frequency"</code>
attribute.
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+zoo">zoo</a></code>, <code><a href="zoo.html#topic+is.regular">is.regular</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## equivalent specifications of a quarterly series
## starting in the second quarter of 1959.
zooreg(1:10, frequency = 4, start = c(1959, 2))
as.zoo(ts(1:10, frequency = 4, start = c(1959, 2)))
zoo(1:10, seq(1959.25, 1961.5, by = 0.25), frequency = 4)

## use yearqtr class for indexing the same series
z &lt;- zoo(1:10, yearqtr(seq(1959.25, 1961.5, by = 0.25)), frequency = 4)
z
z[-(3:4)]

## create a regular series with a "Date" index
zooreg(1:5, start = as.Date("2000-01-01"))
## or with "yearmon" index
zooreg(1:5, end = yearmon(2000))

## lag and diff (as diff is defined in terms of lag)
## act differently on zoo and zooreg objects!
## lag.zoo moves a point to the adjacent time whereas
## lag.zooreg moves a point by deltat
x &lt;- c(1, 2, 3, 6)
zz &lt;- zoo(x, x)
zr &lt;- as.zooreg(zz)
lag(zz, k = -1)
lag(zr, k = -1)
diff(zz)
diff(zr)

## lag.zooreg wihtout and with na.pad
lag(zr, k = -1)
lag(zr, k = -1, na.pad = TRUE)

## standard methods available for regular series
frequency(z)
deltat(z)
cycle(z)
cycle(z[-(3:4)])

zz  &lt;-  zoo(1:6, as.Date(c("1960-01-29", "1960-02-29", "1960-03-31",
  "1960-04-29", "1960-05-31", "1960-06-30")))
# this converts zz to "zooreg" and then to "ts" expanding it to a daily
# series which is 154 elements long, most with NAs.
## Not run: 
length(as.ts(zz)) # 154

## End(Not run)
# probably a monthly "ts" series rather than a daily one was wanted.
# This variation of the last line gives a result only 6 elements long.
length(as.ts(aggregate(zz, as.yearmon, c))) # 6

zzr &lt;- as.zooreg(zz)

dd &lt;- as.Date(c("2000-01-01", "2000-02-01", "2000-03-01", "2000-04-01"))
zrd &lt;- as.zooreg(zoo(1:4, dd))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
