<!DOCTYPE html><html lang="en"><head><title>Help for package IDSL.FSA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {IDSL.FSA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fragmentation_spectra_annotator'>
<p>Fragmentation Spectra Annotator</p></a></li>
<li><a href='#FSA_aggregate'>
<p>aggregation method for FSA</p></a></li>
<li><a href='#FSA_annotation_text_repel'>
<p>FSA annotation text repel</p></a></li>
<li><a href='#FSA_dir.create'>
<p>FSA_dir.create</p></a></li>
<li><a href='#FSA_FSdb_xlsxAnalyzer'>
<p>FSA FSdb xlsx Analyzer</p></a></li>
<li><a href='#FSA_loadRdata'>
<p>FSA loadRdata</p></a></li>
<li><a href='#FSA_locate_regex'>
<p>FSA Locate regex</p></a></li>
<li><a href='#FSA_logRecorder'>
<p>FSA logRecorder</p></a></li>
<li><a href='#FSA_message'>
<p>FSA message</p></a></li>
<li><a href='#FSA_msp_annotator'>
<p>FSA msp annotator</p></a></li>
<li><a href='#FSA_msp2Cytoscape'>
<p>FSA Cytoscape Files Generator</p></a></li>
<li><a href='#FSA_plotFSdb2Spectra'>
<p>plot FSdb to Spectra</p></a></li>
<li><a href='#FSA_R.aggregate'>
<p>aggregate function for IDSL.FSA</p></a></li>
<li><a href='#FSA_spectra_marker_generator'>
<p>FSA Spectra Marker Generator</p></a></li>
<li><a href='#FSA_SpectraSimilarity_xlsxAnalyzer'>
<p>FSA SpectraSimilarity xlsx Analyzer</p></a></li>
<li><a href='#FSA_uniqueMSPblockTagger'>
<p>FSA Unique MSP Block Tagger</p></a></li>
<li><a href='#FSA_uniqueMSPblockTaggerUntargeted'>
<p>FSA_uniqueMSPblockTaggerUntargeted</p></a></li>
<li><a href='#FSA_workflow'>
<p>FSA workflow</p></a></li>
<li><a href='#FSA_xlsxAnalyzer'>
<p>FSA xlsx Analyzer</p></a></li>
<li><a href='#FSdb_file_generator'>
<p>FSdb file generator</p></a></li>
<li><a href='#FSdb_subsetter'>
<p>FSdb subsetter</p></a></li>
<li><a href='#FSdb2msp'>
<p>Fragmentation Spectra DataBase (FSDB) to MSP</p></a></li>
<li><a href='#FSdb2PeakXcolSubsetter'>
<p>FSdb2PeakXcolSubsetter</p></a></li>
<li><a href='#FSdb2precursorType'>
<p>Precursor Types from Fragmentation Spectra DataBase (FSDB)</p></a></li>
<li><a href='#mgf2msp'>
<p>MGF to MSP</p></a></li>
<li><a href='#msp2FSdb'>
<p>msp to Fragmentation Spectra DataBase (FSDB)</p></a></li>
<li><a href='#msp2TrainingMatrix'>
<p>msp to Fragmentation Spectra DataBase (FSDB)</p></a></li>
<li><a href='#mspPosNegSplitter'>
<p>MSP Pos/Neg Splitter</p></a></li>
<li><a href='#plotFSdb2SpectraCore'>
<p>plot spectra from FSdb core</p></a></li>
<li><a href='#spectra_1A1B_mixer'>
<p>Mixer 1:1 spectra A and B</p></a></li>
<li><a href='#spectra_integrator'>
<p>Spectra Integrator</p></a></li>
<li><a href='#spectra_ion_filter'>
<p>Spectra Ion Filter</p></a></li>
<li><a href='#spectral_entropy_calculator'>
<p>Spectral Entropy Calculator</p></a></li>
<li><a href='#spectral_entropy_similarity_score'>
<p>Spectral Entropy Calculator</p></a></li>
<li><a href='#stackedSpectra'>
<p>Example for a stacked spectra</p></a></li>
<li><a href='#UFSA_element_sorter'>
<p>Element Sorter</p></a></li>
<li><a href='#UFSA_formula_vector_generator'>
<p>Molecular Formula Vector Generator</p></a></li>
<li><a href='#UFSA_hill_molecular_formula_printer'>
<p>Print Hill Molecular Formula</p></a></li>
<li><a href='#UFSA_ionization_pathway_deconvoluter'>
<p>Ionization Pathway Deconvoluter</p></a></li>
<li><a href='#UFSA_precursorType_corrector'>
<p>UFA Precursor Type Corrector</p></a></li>
<li><a href='#xlsx2msp'>
<p>xlsx to MSP</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fragmentation Spectra Analysis (FSA)</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>readxl</td>
</tr>
<tr>
<td>Author:</td>
<td>Sadjad Fakouri-Baygi
    <a href="https://orcid.org/0000-0002-6864-6911"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Dinesh Barupal <a href="https://orcid.org/0000-0002-9954-8628"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dinesh Barupal &lt;dinesh.barupal@mssm.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The 'IDSL.FSA' package was designed to annotate standard .msp (mass spectra format) and .mgf (Mascot generic format) files using mass spectral entropy similarity, dot product (cosine) similarity, and normalized Euclidean mass error (NEME) followed by intelligent pre-filtering steps for rapid spectra searches. 'IDSL.FSA' also provides a number of modules to convert and manipulate .msp and .mgf files. The 'IDSL.FSA' workflow was integrated in the 'IDSL.CSA' and 'IDSL.NPA' packages introduced in &lt;<a href="https://doi.org/10.1021%2Facs.analchem.3c00376">doi:10.1021/acs.analchem.3c00376</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/idslme/idsl.fsa">https://github.com/idslme/idsl.fsa</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/idslme/idsl.fsa/issues">https://github.com/idslme/idsl.fsa/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Archs:</td>
<td>i386, x64</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-27 21:27:09 UTC; sfbaygi</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-29 14:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fragmentation_spectra_annotator'>
Fragmentation Spectra Annotator
</h2><span id='topic+fragmentation_spectra_annotator'></span>

<h3>Description</h3>

<p>This module annotates fragmentation spectra from .MSP files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fragmentation_spectra_annotator(path, MSPfile = "", libFSdb,
libFSdbIDlist, targetedPrecursorType = NA, ratio2basePeak4nSpectraMarkers = 0,
allowedNominalMass = FALSE, allowedWeightedSpectralEntropy = TRUE,
noiseRemovalRatio = 0.01, roundingDigitPrefiltering = 1, minMatchedNumPeaks = 1,
massError = 0, maxNEME = 0, minIonRangeDifference = 0, minCosineSimilarity,
minEntropySimilarity, minRatioMatchedNspectraMarkers,
spectralEntropyDeviationPrefiltering, massErrorPrecursor = NA, RTtolerance = NA,
exportSpectraParameters = NULL, number_processing_threads = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fragmentation_spectra_annotator_+3A_path">path</code></td>
<td>

<p>Address of .msp file(s)
</p>
</td></tr>
<tr><td><code id="fragmentation_spectra_annotator_+3A_mspfile">MSPfile</code></td>
<td>

<p>name of the .msp file
</p>
</td></tr>
<tr><td><code id="fragmentation_spectra_annotator_+3A_libfsdb">libFSdb</code></td>
<td>

<p>A converted .msp library reference file using the 'msp2FSdb' module which is an FSDB produced by the IDSL.FSA package.
</p>
</td></tr>
<tr><td><code id="fragmentation_spectra_annotator_+3A_libfsdbidlist">libFSdbIDlist</code></td>
<td>

<p>Ion markers object from the FSDB reference
</p>
</td></tr>
<tr><td><code id="fragmentation_spectra_annotator_+3A_targetedprecursortype">targetedPrecursorType</code></td>
<td>

<p>A vector of targeted precursor types
</p>
</td></tr>
<tr><td><code id="fragmentation_spectra_annotator_+3A_ratio2basepeak4nspectramarkers">ratio2basePeak4nSpectraMarkers</code></td>
<td>

<p>Ratio of peaks in fragmentation spectra to the basepeak to calculate minimum qualified number of matched abundant peaks
</p>
</td></tr>
<tr><td><code id="fragmentation_spectra_annotator_+3A_allowednominalmass">allowedNominalMass</code></td>
<td>

<p>c(TRUE, FALSE). Select 'TRUE' only for nominal mass analysis.
</p>
</td></tr>
<tr><td><code id="fragmentation_spectra_annotator_+3A_allowedweightedspectralentropy">allowedWeightedSpectralEntropy</code></td>
<td>

<p>c(TRUE, FALSE). Weighted entropy to transform low abundant signals prior to calculating entropy similarity score. Please see the reference for details on wight transformation.
</p>
</td></tr>
<tr><td><code id="fragmentation_spectra_annotator_+3A_noiseremovalratio">noiseRemovalRatio</code></td>
<td>

<p>noise removal ratio ([0 - 1])relative to the basepeak to measure entropy similarity score.
</p>
</td></tr>
<tr><td><code id="fragmentation_spectra_annotator_+3A_roundingdigitprefiltering">roundingDigitPrefiltering</code></td>
<td>

<p>Level of pre-filtering
</p>
</td></tr>
<tr><td><code id="fragmentation_spectra_annotator_+3A_minmatchednumpeaks">minMatchedNumPeaks</code></td>
<td>

<p>Minimum matched number of peaks
</p>
</td></tr>
<tr><td><code id="fragmentation_spectra_annotator_+3A_masserror">massError</code></td>
<td>

<p>Mass accuracy in Da
</p>
</td></tr>
<tr><td><code id="fragmentation_spectra_annotator_+3A_maxneme">maxNEME</code></td>
<td>

<p>Maximum value for Normalized Euclidean Mass Error (NEME) in mDa
</p>
</td></tr>
<tr><td><code id="fragmentation_spectra_annotator_+3A_minionrangedifference">minIonRangeDifference</code></td>
<td>

<p>Minimum distance (Da) between lowest and highest matched m/z to prevent matching only isotopic envelopes
</p>
</td></tr>
<tr><td><code id="fragmentation_spectra_annotator_+3A_mincosinesimilarity">minCosineSimilarity</code></td>
<td>

<p>Minimum cosine similarity score
</p>
</td></tr>
<tr><td><code id="fragmentation_spectra_annotator_+3A_minentropysimilarity">minEntropySimilarity</code></td>
<td>

<p>Minimum entropy similarity score
</p>
</td></tr>
<tr><td><code id="fragmentation_spectra_annotator_+3A_minratiomatchednspectramarkers">minRatioMatchedNspectraMarkers</code></td>
<td>

<p>Minimum percentage of detection of abundant library peaks in percentage
</p>
</td></tr>
<tr><td><code id="fragmentation_spectra_annotator_+3A_spectralentropydeviationprefiltering">spectralEntropyDeviationPrefiltering</code></td>
<td>

<p>Spectral entropy deviation for pre-filtering
</p>
</td></tr>
<tr><td><code id="fragmentation_spectra_annotator_+3A_masserrorprecursor">massErrorPrecursor</code></td>
<td>

<p>Mass accuracy (Da) to find precursor m/z in .msp files
</p>
</td></tr>
<tr><td><code id="fragmentation_spectra_annotator_+3A_rttolerance">RTtolerance</code></td>
<td>

<p>Retention time tolerance (min)
</p>
</td></tr>
<tr><td><code id="fragmentation_spectra_annotator_+3A_exportspectraparameters">exportSpectraParameters</code></td>
<td>

<p>Parameters for export MS/MS match figures
</p>
</td></tr>
<tr><td><code id="fragmentation_spectra_annotator_+3A_number_processing_threads">number_processing_threads</code></td>
<td>

<p>Number of processing threads for multi-threaded processing
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of matched spectra
</p>

<hr>
<h2 id='FSA_aggregate'>
aggregation method for FSA
</h2><span id='topic+FSA_aggregate'></span>

<h3>Description</h3>

<p>This module is to optimize the 'indexVec' variable by removing elements that have redundant 'idVec' numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSA_aggregate(idVec, variableVec, indexVec, targetVar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FSA_aggregate_+3A_idvec">idVec</code></td>
<td>

<p>a vector of id numbers. Repeated id numbers are allowed
</p>
</td></tr>
<tr><td><code id="FSA_aggregate_+3A_variablevec">variableVec</code></td>
<td>

<p>a vector of variable of the interest such as RT, m/z, etc.
</p>
</td></tr>
<tr><td><code id="FSA_aggregate_+3A_indexvec">indexVec</code></td>
<td>

<p>a vector of indices
</p>
</td></tr>
<tr><td><code id="FSA_aggregate_+3A_targetvar">targetVar</code></td>
<td>

<p>the targeted value in 'variableVec'
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a clean indexVec after removing redundant 'idVec'.
</p>

<hr>
<h2 id='FSA_annotation_text_repel'>
FSA annotation text repel
</h2><span id='topic+FSA_annotation_text_repel'></span>

<h3>Description</h3>

<p>This function is to set annotations on the spectra plots with a reasonable distance to avoid overlying annotations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSA_annotation_text_repel(FSAspectra, nGridX, nGridY)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FSA_annotation_text_repel_+3A_fsaspectra">FSAspectra</code></td>
<td>

<p>FSAspectra
</p>
</td></tr>
<tr><td><code id="FSA_annotation_text_repel_+3A_ngridx">nGridX</code></td>
<td>

<p>number of grids on the x-axis
</p>
</td></tr>
<tr><td><code id="FSA_annotation_text_repel_+3A_ngridy">nGridY</code></td>
<td>

<p>number of grids on the y-axis
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>labels
</p>

<hr>
<h2 id='FSA_dir.create'>
FSA_dir.create
</h2><span id='topic+FSA_dir.create'></span>

<h3>Description</h3>

<p>A module to create directories after removing the existing directory with the same name to prevent data interferences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSA_dir.create(folder, allowedUnlink = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FSA_dir.create_+3A_folder">folder</code></td>
<td>

<p>folder
</p>
</td></tr>
<tr><td><code id="FSA_dir.create_+3A_allowedunlink">allowedUnlink</code></td>
<td>

<p>allowedUnlink
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>when the original folder was deleted and recreated successfully, 'TRUE' is returned by this function.
</p>

<hr>
<h2 id='FSA_FSdb_xlsxAnalyzer'>
FSA FSdb xlsx Analyzer
</h2><span id='topic+FSA_FSdb_xlsxAnalyzer'></span>

<h3>Description</h3>

<p>This function processes the spreadsheet of the 'FSDB' tab to ensure the parameter inputs are consistent with the requirements of the IDSL.FSA pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSA_FSdb_xlsxAnalyzer(spreadsheet)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FSA_FSdb_xlsxAnalyzer_+3A_spreadsheet">spreadsheet</code></td>
<td>

<p>FSA spreadsheet
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the FSDB parameters to feed the 'FSdb_file_generator' function.
</p>

<hr>
<h2 id='FSA_loadRdata'>
FSA loadRdata
</h2><span id='topic+FSA_loadRdata'></span>

<h3>Description</h3>

<p>This function loads .Rdata files into a variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSA_loadRdata(fileName)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FSA_loadRdata_+3A_filename">fileName</code></td>
<td>

<p>is an '.Rdata' file.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The called variable into the new assigned variable name.
</p>

<hr>
<h2 id='FSA_locate_regex'>
FSA Locate regex
</h2><span id='topic+FSA_locate_regex'></span>

<h3>Description</h3>

<p>Locate indices of the pattern in the string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSA_locate_regex(string, pattern, ignore.case = FALSE, perl = FALSE, fixed = FALSE,
useBytes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FSA_locate_regex_+3A_string">string</code></td>
<td>

<p>a string as character
</p>
</td></tr>
<tr><td><code id="FSA_locate_regex_+3A_pattern">pattern</code></td>
<td>

<p>a pattern to screen
</p>
</td></tr>
<tr><td><code id="FSA_locate_regex_+3A_ignore.case">ignore.case</code></td>
<td>

<p>ignore.case
</p>
</td></tr>
<tr><td><code id="FSA_locate_regex_+3A_perl">perl</code></td>
<td>

<p>perl
</p>
</td></tr>
<tr><td><code id="FSA_locate_regex_+3A_fixed">fixed</code></td>
<td>

<p>fixed
</p>
</td></tr>
<tr><td><code id="FSA_locate_regex_+3A_usebytes">useBytes</code></td>
<td>

<p>useBytes
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns 'NULL' when no matches are detected for the pattern.
</p>


<h3>Value</h3>

<p>A 2-column matrix of location indices. The first and second columns represent start and end positions, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pattern &lt;- "Cl"
string &lt;- "NaCl.5HCl"
Location_Cl &lt;- FSA_locate_regex(string, pattern)
</code></pre>

<hr>
<h2 id='FSA_logRecorder'>
FSA logRecorder
</h2><span id='topic+FSA_logRecorder'></span>

<h3>Description</h3>

<p>FSA_logRecorder
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSA_logRecorder(messageQuote, allowedPrinting = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FSA_logRecorder_+3A_messagequote">messageQuote</code></td>
<td>

<p>messageQuote
</p>
</td></tr>
<tr><td><code id="FSA_logRecorder_+3A_allowedprinting">allowedPrinting</code></td>
<td>

<p>allowedPrinting
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a line of communication messages is exported to the console and the log .txt file.
</p>

<hr>
<h2 id='FSA_message'>
FSA message
</h2><span id='topic+FSA_message'></span>

<h3>Description</h3>

<p>FSA_message
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSA_message(messageQuote, failedMessage= TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FSA_message_+3A_messagequote">messageQuote</code></td>
<td>

<p>messageQuote
</p>
</td></tr>
<tr><td><code id="FSA_message_+3A_failedmessage">failedMessage</code></td>
<td>

<p>failedMessage
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a line of communication messages is exported to the console.
</p>

<hr>
<h2 id='FSA_msp_annotator'>
FSA msp annotator
</h2><span id='topic+FSA_msp_annotator'></span>

<h3>Description</h3>

<p>This function arranges the parameters for the annotation process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSA_msp_annotator(PARAM_SPEC, libFSdb, address_input_msp, output_path,
allowedVerbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FSA_msp_annotator_+3A_param_spec">PARAM_SPEC</code></td>
<td>

<p>a parameter driven from the 'FSA_SpectraSimilarity_xlsxAnalyzer' module.
</p>
</td></tr>
<tr><td><code id="FSA_msp_annotator_+3A_libfsdb">libFSdb</code></td>
<td>

<p>a converted .msp library reference files (FSDB) using the 'msp2FSdb' module
</p>
</td></tr>
<tr><td><code id="FSA_msp_annotator_+3A_address_input_msp">address_input_msp</code></td>
<td>

<p>address of the .msp files
</p>
</td></tr>
<tr><td><code id="FSA_msp_annotator_+3A_output_path">output_path</code></td>
<td>

<p>output path
</p>
</td></tr>
<tr><td><code id="FSA_msp_annotator_+3A_allowedverbose">allowedVerbose</code></td>
<td>

<p>c(TRUE, FALSE). A 'TRUE' allowedVerbose provides messages about the flow of the function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of matched annotated spectra stored in the output directory.
</p>

<hr>
<h2 id='FSA_msp2Cytoscape'>
FSA Cytoscape Files Generator
</h2><span id='topic+FSA_msp2Cytoscape'></span>

<h3>Description</h3>

<p>This function generates necessary files from pairwise MSP blocks analysis to create Cytoscape networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSA_msp2Cytoscape(path, MSPfile = "", mspVariableVector = NULL,
mspNodeID = NULL, massError = 0.01, RTtolerance = NA, minEntropySimilarity = 0.75,
allowedNominalMass = FALSE, allowedWeightedSpectralEntropy = TRUE,
noiseRemovalRatio = 0.01, number_processing_threads = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FSA_msp2Cytoscape_+3A_path">path</code></td>
<td>

<p>address of .msp file or an FSDB
</p>
</td></tr>
<tr><td><code id="FSA_msp2Cytoscape_+3A_mspfile">MSPfile</code></td>
<td>

<p>name of .msp file
</p>
</td></tr>
<tr><td><code id="FSA_msp2Cytoscape_+3A_mspvariablevector">mspVariableVector</code></td>
<td>

<p>a vector of msp variables
</p>
</td></tr>
<tr><td><code id="FSA_msp2Cytoscape_+3A_mspnodeid">mspNodeID</code></td>
<td>

<p>msp Node ID which is the ID that is required for the &lsquo;specsim&rsquo; ID generation
</p>
</td></tr>
<tr><td><code id="FSA_msp2Cytoscape_+3A_masserror">massError</code></td>
<td>

<p>Mass accuracy in Da
</p>
</td></tr>
<tr><td><code id="FSA_msp2Cytoscape_+3A_rttolerance">RTtolerance</code></td>
<td>

<p>Retention time tolerance (min) to match msp blocks. Select <em>NA</em> to ignore retention time match. This option is so helpful to find co-occurring compounds.
</p>
</td></tr>
<tr><td><code id="FSA_msp2Cytoscape_+3A_minentropysimilarity">minEntropySimilarity</code></td>
<td>

<p>Minimum entropy similarity score
</p>
</td></tr>
<tr><td><code id="FSA_msp2Cytoscape_+3A_allowednominalmass">allowedNominalMass</code></td>
<td>

<p>c(TRUE, FALSE). Select 'TRUE' only for nominal mass analysis.
</p>
</td></tr>
<tr><td><code id="FSA_msp2Cytoscape_+3A_allowedweightedspectralentropy">allowedWeightedSpectralEntropy</code></td>
<td>

<p>c(TRUE, FALSE). Weighted entropy to measure entropy similarity score.
</p>
</td></tr>
<tr><td><code id="FSA_msp2Cytoscape_+3A_noiseremovalratio">noiseRemovalRatio</code></td>
<td>

<p>noise removal ratio relative to the basepeak to measure entropy similarity score (in percent)
</p>
</td></tr>
<tr><td><code id="FSA_msp2Cytoscape_+3A_number_processing_threads">number_processing_threads</code></td>
<td>

<p>Number of processing threads for multi-threaded processing
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>node_attributes_dataFrame</code></td>
<td>

<p>node_attributes dataframe. A string to store using 'writeTable' function of R after a tab separation.
</p>
</td></tr>
<tr><td><code>edge_dataFrame</code></td>
<td>

<p>edge dataframe. A string to store using the 'writeTable' function of R after a tab separation.
</p>
</td></tr>
<tr><td><code>correlation_network</code></td>
<td>

<p>correlation_network dataframe. A string to store using the 'writeTable' function of R after a tab separation.
</p>
</td></tr>
<tr><td><code>FSDB</code></td>
<td>

<p>Fragmentation spectra database (FSDB) object
</p>
</td></tr>
<tr><td><code>exclusionMSPnoideid</code></td>
<td>

<p>A vector of MSP node ids which can be excluded to create a library of unique MSP blocks. 
</p>
</td></tr>
<tr><td><code>filteredNetworkSIF</code></td>
<td>

<p>A filtered network in the cytoscape SIF format that does not have redundant MSP blocks within a RT window. 
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Shannon, P., Markiel, A., Ozier, O., Baliga, N.S., Wang, J.T., Ramage, D., Amin, N., Schwikowski, B. and Ideker, T., (2003). Cytoscape: a software environment for integrated models of biomolecular interaction networks. <em>Genome research</em>, 13(11), 2498-2504, <a href="https://doi.org/10.1101/gr.1239303">doi:10.1101/gr.1239303</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path_extdata &lt;- system.file("extdata", package = "IDSL.FSA")
mspFileName &lt;- "Kynurenine_Kynurenic_acid.msp"
##
listCytoscape &lt;- FSA_msp2Cytoscape(path = path_extdata,
MSPfile = mspFileName, mspVariableVector = c("Name", "Collision_energy"),
mspNodeID = NULL, massError = 0.01, RTtolerance = NA, minEntropySimilarity = 0,
noiseRemovalRatio = 0, allowedNominalMass = FALSE,
allowedWeightedSpectralEntropy = TRUE, number_processing_threads = 1)
##
FSDB &lt;- listCytoscape[["FSDB"]]
##
temp_wd &lt;- tempdir() # just a temporary folder to save results
##
write.table(listCytoscape[["node_attributes_dataFrame"]], paste0(temp_wd,
"/node_attributes_dataFrame.txt"), quote = FALSE, sep = "\t", row.names = FALSE,
col.names = FALSE)
##
write.table(listCytoscape[["correlation_network"]], paste0(temp_wd,
"/correlation_network.sif"), quote = FALSE, sep = "\t", row.names = FALSE,
col.names = FALSE)
##
write.table(listCytoscape[["edge_dataFrame"]], paste0(temp_wd,
"/edge_dataFrame.txt"), quote = FALSE, sep = "\t", row.names = FALSE,
col.names = FALSE)
##

</code></pre>

<hr>
<h2 id='FSA_plotFSdb2Spectra'>
plot FSdb to Spectra
</h2><span id='topic+FSA_plotFSdb2Spectra'></span>

<h3>Description</h3>

<p>plot FSdb to Spectra
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSA_plotFSdb2Spectra(path, allowedUnlink = TRUE, annexName = "", FSdb,
selectedFSdbIDs = NULL, number_processing_threads = 1, allowedVerbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FSA_plotFSdb2Spectra_+3A_path">path</code></td>
<td>

<p>Address of .msp file(s)
</p>
</td></tr>
<tr><td><code id="FSA_plotFSdb2Spectra_+3A_allowedunlink">allowedUnlink</code></td>
<td>

<p>allowedUnlink
</p>
</td></tr>
<tr><td><code id="FSA_plotFSdb2Spectra_+3A_annexname">annexName</code></td>
<td>

<p>annexName
</p>
</td></tr>
<tr><td><code id="FSA_plotFSdb2Spectra_+3A_fsdb">FSdb</code></td>
<td>

<p>FSdb
</p>
</td></tr>
<tr><td><code id="FSA_plotFSdb2Spectra_+3A_selectedfsdbids">selectedFSdbIDs</code></td>
<td>

<p>selected FSdb IDs. When 'NULL', the entire FSDB blocks are plotted. 
</p>
</td></tr>
<tr><td><code id="FSA_plotFSdb2Spectra_+3A_number_processing_threads">number_processing_threads</code></td>
<td>

<p>Number of processing threads for multi-threaded processing
</p>
</td></tr>
<tr><td><code id="FSA_plotFSdb2Spectra_+3A_allowedverbose">allowedVerbose</code></td>
<td>

<p>c(TRUE, FALSE). A 'TRUE' allowedVerbose provides messages about the flow of the function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>spectra_figure object
</p>

<hr>
<h2 id='FSA_R.aggregate'>
aggregate function for IDSL.FSA
</h2><span id='topic+FSA_R.aggregate'></span>

<h3>Description</h3>

<p>This module ensures that the 'aggregate' function of R returns a list type of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSA_R.aggregate(FSAvec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FSA_R.aggregate_+3A_fsavec">FSAvec</code></td>
<td>

<p>a vector of data
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>listIDFSAvec
</p>

<hr>
<h2 id='FSA_spectra_marker_generator'>
FSA Spectra Marker Generator
</h2><span id='topic+FSA_spectra_marker_generator'></span>

<h3>Description</h3>

<p>This function generates spectra markers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSA_spectra_marker_generator(FSdb, ratio2basePeak4nSpectraMarkers = 0,
aggregationLevel = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FSA_spectra_marker_generator_+3A_fsdb">FSdb</code></td>
<td>

<p>FSdb object from the 'msp2FSdb' module
</p>
</td></tr>
<tr><td><code id="FSA_spectra_marker_generator_+3A_ratio2basepeak4nspectramarkers">ratio2basePeak4nSpectraMarkers</code></td>
<td>

<p>Ratio of peaks in fragmentation spectra to the basepeak to calculate minimum qualified number of matched abundant peaks
</p>
</td></tr>
<tr><td><code id="FSA_spectra_marker_generator_+3A_aggregationlevel">aggregationLevel</code></td>
<td>

<p>c(NA, 0, 1, 2, 3). When 'NA', this function returns a matrix for the spectra markers. When integer numbers are used, the ion marker masses are grouped by a rounding digit equal to this number.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>spectraMarkerMass</code></td>
<td>

<p>a grouped or a matrix of ion marker masses corresponding to FSdb ids
</p>
</td></tr>
<tr><td><code>nSpectraMarkers</code></td>
<td>

<p>number of spectra markers for each FSdb id
</p>
</td></tr>
</table>

<hr>
<h2 id='FSA_SpectraSimilarity_xlsxAnalyzer'>
FSA SpectraSimilarity xlsx Analyzer
</h2><span id='topic+FSA_SpectraSimilarity_xlsxAnalyzer'></span>

<h3>Description</h3>

<p>This function processes the spreadsheet of the 'SpectraSimilarity' tab to ensure the parameter inputs are consistent with the requirements of the IDSL.FSA pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSA_SpectraSimilarity_xlsxAnalyzer(spreadsheet)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FSA_SpectraSimilarity_xlsxAnalyzer_+3A_spreadsheet">spreadsheet</code></td>
<td>

<p>FSA spreadsheet
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the FSA SpectraSimilarity parameters to feed the 'FSA_msp_annotator' module.
</p>

<hr>
<h2 id='FSA_uniqueMSPblockTagger'>
FSA Unique MSP Block Tagger
</h2><span id='topic+FSA_uniqueMSPblockTagger'></span>

<h3>Description</h3>

<p>This function removes similar MSP blocks. This function aggregates MSP blocks based on the 'Name' values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSA_uniqueMSPblockTagger(path, MSPfile = "", aggregateBy = "Name",
massError = 0.01, RTtolerance = NA, minEntropySimilarity = 0.75,
noiseRemovalRatio = 0.01, allowedNominalMass = FALSE,
allowedWeightedSpectralEntropy = TRUE, plotSpectra = FALSE,
number_processing_threads = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FSA_uniqueMSPblockTagger_+3A_path">path</code></td>
<td>

<p>Address of .msp file or an FSDB
</p>
</td></tr>
<tr><td><code id="FSA_uniqueMSPblockTagger_+3A_mspfile">MSPfile</code></td>
<td>

<p>name of .msp file
</p>
</td></tr>
<tr><td><code id="FSA_uniqueMSPblockTagger_+3A_aggregateby">aggregateBy</code></td>
<td>

<p>a variable to aggregate the MSP blocks based on
</p>
</td></tr>
<tr><td><code id="FSA_uniqueMSPblockTagger_+3A_masserror">massError</code></td>
<td>

<p>Mass accuracy in Da
</p>
</td></tr>
<tr><td><code id="FSA_uniqueMSPblockTagger_+3A_rttolerance">RTtolerance</code></td>
<td>

<p>Retention time tolerance (min) to match msp blocks. Select <em>NA</em> to ignore retention time match.
</p>
</td></tr>
<tr><td><code id="FSA_uniqueMSPblockTagger_+3A_minentropysimilarity">minEntropySimilarity</code></td>
<td>

<p>Minimum entropy similarity score
</p>
</td></tr>
<tr><td><code id="FSA_uniqueMSPblockTagger_+3A_noiseremovalratio">noiseRemovalRatio</code></td>
<td>

<p>noise removal ratio relative to the basepeak to measure entropy similarity score (in percent)
</p>
</td></tr>
<tr><td><code id="FSA_uniqueMSPblockTagger_+3A_allowednominalmass">allowedNominalMass</code></td>
<td>

<p>c(TRUE, FALSE). Select 'TRUE' only for nominal mass analysis.
</p>
</td></tr>
<tr><td><code id="FSA_uniqueMSPblockTagger_+3A_allowedweightedspectralentropy">allowedWeightedSpectralEntropy</code></td>
<td>

<p>c(TRUE, FALSE). Weighted entropy to measure entropy similarity score.
</p>
</td></tr>
<tr><td><code id="FSA_uniqueMSPblockTagger_+3A_plotspectra">plotSpectra</code></td>
<td>

<p>c(TRUE, FALSE)
</p>
</td></tr>
<tr><td><code id="FSA_uniqueMSPblockTagger_+3A_number_processing_threads">number_processing_threads</code></td>
<td>

<p>Number of processing threads for multi-threaded processing
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of similar MSP blocks is returned at the end and a subsetted .msp and FSDB files are saved in the 'path' directory.
</p>

<hr>
<h2 id='FSA_uniqueMSPblockTaggerUntargeted'>
FSA_uniqueMSPblockTaggerUntargeted
</h2><span id='topic+FSA_uniqueMSPblockTaggerUntargeted'></span>

<h3>Description</h3>

<p>FSA_uniqueMSPblockTaggerUntargeted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSA_uniqueMSPblockTaggerUntargeted(path, MSPfile_vector,
minCSAdetectionFrequency = 20, minEntropySimilarity = 0.75, massError = 0.01,
massErrorPrecursor = 0.01, RTtolerance = 0.1, noiseRemovalRatio = 0.01,
allowedNominalMass = FALSE, allowedWeightedSpectralEntropy = TRUE,
plotSpectra = FALSE, number_processing_threads = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FSA_uniqueMSPblockTaggerUntargeted_+3A_path">path</code></td>
<td>

<p>Address of .msp file(s)
</p>
</td></tr>
<tr><td><code id="FSA_uniqueMSPblockTaggerUntargeted_+3A_mspfile_vector">MSPfile_vector</code></td>
<td>

<p>A vector of names of .msp files or one .msp file name.
</p>
</td></tr>
<tr><td><code id="FSA_uniqueMSPblockTaggerUntargeted_+3A_mincsadetectionfrequency">minCSAdetectionFrequency</code></td>
<td>

<p>minimum CSA detection frequency
</p>
</td></tr>
<tr><td><code id="FSA_uniqueMSPblockTaggerUntargeted_+3A_minentropysimilarity">minEntropySimilarity</code></td>
<td>

<p>minimum EntropySimilarity
</p>
</td></tr>
<tr><td><code id="FSA_uniqueMSPblockTaggerUntargeted_+3A_masserror">massError</code></td>
<td>

<p>Mass accuracy in Da
</p>
</td></tr>
<tr><td><code id="FSA_uniqueMSPblockTaggerUntargeted_+3A_masserrorprecursor">massErrorPrecursor</code></td>
<td>

<p>Mass accuracy (Da) to find precursor m/z in .msp files
</p>
</td></tr>
<tr><td><code id="FSA_uniqueMSPblockTaggerUntargeted_+3A_rttolerance">RTtolerance</code></td>
<td>

<p>Retention time tolerance (min)
</p>
</td></tr>
<tr><td><code id="FSA_uniqueMSPblockTaggerUntargeted_+3A_noiseremovalratio">noiseRemovalRatio</code></td>
<td>

<p>noise removal ratio ([0 - 1])relative to the basepeak to measure entropy similarity score.
</p>
</td></tr>
<tr><td><code id="FSA_uniqueMSPblockTaggerUntargeted_+3A_allowednominalmass">allowedNominalMass</code></td>
<td>

<p>c(TRUE, FALSE). Select 'TRUE' only for nominal mass analysis.
</p>
</td></tr>
<tr><td><code id="FSA_uniqueMSPblockTaggerUntargeted_+3A_allowedweightedspectralentropy">allowedWeightedSpectralEntropy</code></td>
<td>

<p>c(TRUE, FALSE). Weighted entropy to transform low abundant signals prior to calculating entropy similarity score. Please see the reference for details on wight transformation.
</p>
</td></tr>
<tr><td><code id="FSA_uniqueMSPblockTaggerUntargeted_+3A_plotspectra">plotSpectra</code></td>
<td>

<p>c(TRUE, FALSE)
</p>
</td></tr>
<tr><td><code id="FSA_uniqueMSPblockTaggerUntargeted_+3A_number_processing_threads">number_processing_threads</code></td>
<td>

<p>Number of processing threads for multi-threaded processing
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>uniqueMSPvariants
</p>

<hr>
<h2 id='FSA_workflow'>
FSA workflow
</h2><span id='topic+FSA_workflow'></span>

<h3>Description</h3>

<p>This function executes the FSA workflow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSA_workflow(spreadsheet)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FSA_workflow_+3A_spreadsheet">spreadsheet</code></td>
<td>

<p>FSA spreadsheet
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function organizes the FSA file processing for better performance using the template spreadsheet.
</p>

<hr>
<h2 id='FSA_xlsxAnalyzer'>
FSA xlsx Analyzer
</h2><span id='topic+FSA_xlsxAnalyzer'></span>

<h3>Description</h3>

<p>This function processes the spreadsheet of the FSA parameters to ensure the parameter inputs are consistent with the requirements of the IDSL.FSA pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSA_xlsxAnalyzer(spreadsheet)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FSA_xlsxAnalyzer_+3A_spreadsheet">spreadsheet</code></td>
<td>

<p>FSA spreadsheet
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the FSA parameters to feed the FSA_workflow function.
</p>

<hr>
<h2 id='FSdb_file_generator'>
FSdb file generator
</h2><span id='topic+FSdb_file_generator'></span>

<h3>Description</h3>

<p>This function generates FSDB objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSdb_file_generator(PARAM_FSdb, output_path = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FSdb_file_generator_+3A_param_fsdb">PARAM_FSdb</code></td>
<td>

<p>'PARAM_FSdb' parameters obtained by the 'FSA_FSdb_xlsxAnalyzer' function.
</p>
</td></tr>
<tr><td><code id="FSdb_file_generator_+3A_output_path">output_path</code></td>
<td>

<p>output_path
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An FSDB object
</p>

<hr>
<h2 id='FSdb_subsetter'>
FSdb subsetter
</h2><span id='topic+FSdb_subsetter'></span>

<h3>Description</h3>

<p>FSdb subsetter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSdb_subsetter(FSdb, inclusionIDs = NULL, exclusionIDs = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FSdb_subsetter_+3A_fsdb">FSdb</code></td>
<td>

<p>FSdb
</p>
</td></tr>
<tr><td><code id="FSdb_subsetter_+3A_inclusionids">inclusionIDs</code></td>
<td>

<p>inclusionIDs
</p>
</td></tr>
<tr><td><code id="FSdb_subsetter_+3A_exclusionids">exclusionIDs</code></td>
<td>

<p>exclusionIDs
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>subsetted FSdb
</p>

<hr>
<h2 id='FSdb2msp'>
Fragmentation Spectra DataBase (FSDB) to MSP
</h2><span id='topic+FSdb2msp'></span>

<h3>Description</h3>

<p>This function converts FSDB R objects into .msp standard files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSdb2msp(path, FSdbFileName = "", UnweightMSP = FALSE,
number_processing_threads = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FSdb2msp_+3A_path">path</code></td>
<td>

<p>address of .msp file(s)
</p>
</td></tr>
<tr><td><code id="FSdb2msp_+3A_fsdbfilename">FSdbFileName</code></td>
<td>

<p>name of the FSDB library name including '.Rdata' extension
</p>
</td></tr>
<tr><td><code id="FSdb2msp_+3A_unweightmsp">UnweightMSP</code></td>
<td>

<p>to unweight fragmentation patterns
</p>
</td></tr>
<tr><td><code id="FSdb2msp_+3A_number_processing_threads">number_processing_threads</code></td>
<td>

<p>Number of processing threads for multi-threaded processing
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The .msp file is stored in the same folder
</p>

<hr>
<h2 id='FSdb2PeakXcolSubsetter'>
FSdb2PeakXcolSubsetter
</h2><span id='topic+FSdb2PeakXcolSubsetter'></span>

<h3>Description</h3>

<p>FSdb2PeakXcolSubsetter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSdb2PeakXcolSubsetter(FSdb_address, peak_alignment_folder,
metavariable = "idsl.ipa_collective_peakids", number_processing_threads = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FSdb2PeakXcolSubsetter_+3A_fsdb_address">FSdb_address</code></td>
<td>

<p>FSdb_address
</p>
</td></tr>
<tr><td><code id="FSdb2PeakXcolSubsetter_+3A_peak_alignment_folder">peak_alignment_folder</code></td>
<td>

<p>peak_alignment_folder
</p>
</td></tr>
<tr><td><code id="FSdb2PeakXcolSubsetter_+3A_metavariable">metavariable</code></td>
<td>

<p>metavariable
</p>
</td></tr>
<tr><td><code id="FSdb2PeakXcolSubsetter_+3A_number_processing_threads">number_processing_threads</code></td>
<td>

<p>Number of processing threads for multi-threaded processing
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>peakXcol</code></td>
<td>

<p>peakXcol
</p>
</td></tr>
<tr><td><code>peak_height</code></td>
<td>

<p>peak_height
</p>
</td></tr>
<tr><td><code>peak_area</code></td>
<td>

<p>peak_area
</p>
</td></tr>
<tr><td><code>peak_R13C</code></td>
<td>

<p>peak_R13C
</p>
</td></tr>
</table>

<hr>
<h2 id='FSdb2precursorType'>
Precursor Types from Fragmentation Spectra DataBase (FSDB)
</h2><span id='topic+FSdb2precursorType'></span>

<h3>Description</h3>

<p>This function finds potential ionization pathways for molecular formulas using a vector of InChIKey values from an FSDB. This function only searches for the first 14 InChIKey letters; and therefore, may result with multiple potential precursor types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSdb2precursorType(InChIKeyVector, libFSdb, tableIndicator = "Frequency",
number_processing_threads = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FSdb2precursorType_+3A_inchikeyvector">InChIKeyVector</code></td>
<td>

<p>A vector of InChIKey values. This value may contain whole InChIKey strings or first 14 InChIKey letters.
</p>
</td></tr>
<tr><td><code id="FSdb2precursorType_+3A_libfsdb">libFSdb</code></td>
<td>

<p>A converted MSP library reference file using the 'msp2FSdb' module which is an FSDB produced by the IDSL.FSA package.
</p>
</td></tr>
<tr><td><code id="FSdb2precursorType_+3A_tableindicator">tableIndicator</code></td>
<td>

<p>c(&quot;Frequency&quot;, &quot;PrecursorMZ&quot;). To show frequency or a median of 'PrecursorMZ' values in the output dataframe for each precursor type.
</p>
</td></tr>
<tr><td><code id="FSdb2precursorType_+3A_number_processing_threads">number_processing_threads</code></td>
<td>

<p>Number of processing threads for multi-threaded processing
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of frequency for each InChIKey in the FSDB. The matrix column headers represent precursor types.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>address_input_msp &lt;- system.file("extdata", package = "IDSL.FSA")
MSPfile_vector &lt;- c("Kynurenine_Kynurenic_acid.msp")
libFSdb &lt;- msp2FSdb(path = address_input_msp, MSPfile_vector)
##
InChIKeyVector &lt;- c("HCZHHEIFKROPDY-UHFFFAOYSA-N", "YGPSJZOEDVAXAB-QMMMGPOBSA-N")
precursor_type_table &lt;- FSdb2precursorType(InChIKeyVector, libFSdb,
tableIndicator = "Frequency", number_processing_threads = 1)
</code></pre>

<hr>
<h2 id='mgf2msp'>
MGF to MSP
</h2><span id='topic+mgf2msp'></span>

<h3>Description</h3>

<p>This function converts .mgf (Mascot generic format) files into the .msp (mass spectra) format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgf2msp(path, MGFfile = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgf2msp_+3A_path">path</code></td>
<td>

<p>address of the .mgf file.
</p>
</td></tr>
<tr><td><code id="mgf2msp_+3A_mgffile">MGFfile</code></td>
<td>

<p>name of the file with the .mgf extension.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The .msp files are saved in the same location.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
temp_wd &lt;- tempdir() # just a temporary folder
path_extdata &lt;- system.file("extdata", package = "IDSL.FSA")
MGFfile &lt;- "Training_000.mgf"
file.copy(from = paste0(path_extdata, "/", MGFfile), to = temp_wd)
mgf2msp(path = temp_wd, MGFfile)

</code></pre>

<hr>
<h2 id='msp2FSdb'>
msp to Fragmentation Spectra DataBase (FSDB)
</h2><span id='topic+msp2FSdb'></span>

<h3>Description</h3>

<p>This function converts .msp (mass spectra format) files into a readable R object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msp2FSdb(path, MSPfile_vector = "", massIntegrationWindow = 0,
allowedNominalMass = FALSE, allowedWeightedSpectralEntropy = TRUE,
noiseRemovalRatio = 0.01, number_processing_threads = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msp2FSdb_+3A_path">path</code></td>
<td>

<p>Address of .msp file(s)
</p>
</td></tr>
<tr><td><code id="msp2FSdb_+3A_mspfile_vector">MSPfile_vector</code></td>
<td>

<p>A vector of names of .msp files or one .msp file name.
</p>
</td></tr>
<tr><td><code id="msp2FSdb_+3A_massintegrationwindow">massIntegrationWindow</code></td>
<td>

<p>Mass window in Da to integrate adjacent peaks in the fragmentation spectra
</p>
</td></tr>
<tr><td><code id="msp2FSdb_+3A_allowednominalmass">allowedNominalMass</code></td>
<td>

<p>c(TRUE, FALSE). Select 'TRUE' only for nominal mass analysis.
</p>
</td></tr>
<tr><td><code id="msp2FSdb_+3A_allowedweightedspectralentropy">allowedWeightedSpectralEntropy</code></td>
<td>

<p>c(TRUE, FALSE). Weighted entropy to transform low abundant signals prior to calculating entropy similarity score. Please see the reference for details on wight transformation.
</p>
</td></tr>
<tr><td><code id="msp2FSdb_+3A_noiseremovalratio">noiseRemovalRatio</code></td>
<td>

<p>noise removal ratio ([0 - 1])relative to the basepeak to measure entropy similarity score.
</p>
</td></tr>
<tr><td><code id="msp2FSdb_+3A_number_processing_threads">number_processing_threads</code></td>
<td>

<p>Number of processing threads for multi-threaded processing
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>logFSdb</code></td>
<td>

<p>Parameters used to create the FSDB object
</p>
</td></tr>
<tr><td><code>PrecursorMZ</code></td>
<td>

<p>A vector of precursor m/z values
</p>
</td></tr>
<tr><td><code>Precursor Type</code></td>
<td>

<p>A vector of precursor adduct types
</p>
</td></tr>
<tr><td><code>Retention Time</code></td>
<td>

<p>A vector of retention time values
</p>
</td></tr>
<tr><td><code>Num Peaks</code></td>
<td>

<p>A vector of num peaks values indicating number of ions for each fragment spectra
</p>
</td></tr>
<tr><td><code>Spectral Entropy</code></td>
<td>

<p>A vector of spectral entropy values
</p>
</td></tr>
<tr><td><code>FragmentList</code></td>
<td>

<p>A list of fragment ions
</p>
</td></tr>
<tr><td><code>MSPLibraryParameters</code></td>
<td>

<p>A dataframe of tabulated headers and their values for each msp block
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function was designed not only to achieve the fastest computational speed; but also can standardize .msp files that were generated by inconsistent settings.
</p>


<h3>References</h3>

<p>Li, Y., Kind, T., Folz, J., Vaniya, A., Mehta, S.S. and Fiehn, O. (2021). Spectral entropy outperforms MS/MS dot product similarity for small-molecule compound identification. <em>Nature methods</em>, 18(12), 1524-1531, <a href="https://doi.org/10.1038/s41592-021-01331-z">doi:10.1038/s41592-021-01331-z</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path_extdata &lt;- system.file("extdata", package = "IDSL.FSA")
MSPfile &lt;- c("Kynurenine_Kynurenic_acid.msp")
sampleFSdb &lt;- msp2FSdb(path = path_extdata, MSPfile)
</code></pre>

<hr>
<h2 id='msp2TrainingMatrix'>
msp to Fragmentation Spectra DataBase (FSDB)
</h2><span id='topic+msp2TrainingMatrix'></span>

<h3>Description</h3>

<p>This function creates an aligned table from the spectra in the .msp file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msp2TrainingMatrix(path, MSPfile = "", minDetectionFreq = 1,
selectedFSdbIDs = NULL, dimension = "wide", massAccuracy = 0.01,
allowedNominalMass = FALSE, allowedWeightedSpectralEntropy = TRUE,
noiseRemovalRatio = 0.01, number_processing_threads = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msp2TrainingMatrix_+3A_path">path</code></td>
<td>

<p>Address of .msp file or an FSDB
</p>
</td></tr>
<tr><td><code id="msp2TrainingMatrix_+3A_mspfile">MSPfile</code></td>
<td>

<p>A .msp file name or FSDB in .Rdata format
</p>
</td></tr>
<tr><td><code id="msp2TrainingMatrix_+3A_mindetectionfreq">minDetectionFreq</code></td>
<td>

<p>A minimum detection frequency for an ion across the entire spectra
</p>
</td></tr>
<tr><td><code id="msp2TrainingMatrix_+3A_selectedfsdbids">selectedFSdbIDs</code></td>
<td>

<p>selected MSP block/FSDB IDs to limit the screening to specific ion blocks
</p>
</td></tr>
<tr><td><code id="msp2TrainingMatrix_+3A_dimension">dimension</code></td>
<td>

<p>c(&quot;wide&quot;, &quot;long&quot;). *wide* or *long* alignment matrix output
</p>
</td></tr>
<tr><td><code id="msp2TrainingMatrix_+3A_massaccuracy">massAccuracy</code></td>
<td>

<p>A mass accuracy (Da)
</p>
</td></tr>
<tr><td><code id="msp2TrainingMatrix_+3A_allowednominalmass">allowedNominalMass</code></td>
<td>

<p>c(TRUE, FALSE). Select 'TRUE' only for nominal mass analysis.
</p>
</td></tr>
<tr><td><code id="msp2TrainingMatrix_+3A_allowedweightedspectralentropy">allowedWeightedSpectralEntropy</code></td>
<td>

<p>c(TRUE, FALSE). Weighted entropy to transform low abundant signals prior to calculating entropy similarity score. Please see the reference for details on wight transformation.
</p>
</td></tr>
<tr><td><code id="msp2TrainingMatrix_+3A_noiseremovalratio">noiseRemovalRatio</code></td>
<td>

<p>noise removal ratio ([0 - 1])relative to the basepeak to measure entropy similarity score.
</p>
</td></tr>
<tr><td><code id="msp2TrainingMatrix_+3A_number_processing_threads">number_processing_threads</code></td>
<td>

<p>Number of processing threads for multi-threaded processing
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A FSDB file (.Rdata) and aligned spectra table (.csv) are stored in the same directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
temp_wd &lt;- tempdir() # just a temporary folder
path_extdata &lt;- system.file("extdata", package = "IDSL.FSA")
MSPfile &lt;- "Kynurenine_Kynurenic_acid.msp"
file.copy(from = paste0(path_extdata, "/", MSPfile), to = temp_wd)
msp2TrainingMatrix(path = temp_wd, MSPfile, minDetectionFreq = 1)

</code></pre>

<hr>
<h2 id='mspPosNegSplitter'>
MSP Pos/Neg Splitter
</h2><span id='topic+mspPosNegSplitter'></span>

<h3>Description</h3>

<p>This function separates the positive and negative MSP blocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mspPosNegSplitter(path, MSPfile = "", number_processing_threads = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mspPosNegSplitter_+3A_path">path</code></td>
<td>

<p>address of the .msp file.
</p>
</td></tr>
<tr><td><code id="mspPosNegSplitter_+3A_mspfile">MSPfile</code></td>
<td>

<p>name of the file with the .msp extension.
</p>
</td></tr>
<tr><td><code id="mspPosNegSplitter_+3A_number_processing_threads">number_processing_threads</code></td>
<td>

<p>Number of processing threads for multi-threaded processing
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The .msp files are saved in the same location with '_Neg.msp' and '_Pos.msp' extensions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
temp_wd &lt;- tempdir() # just a temporary folder
path_extdata &lt;- system.file("extdata", package = "IDSL.FSA")
MSPfile &lt;- "Kynurenine_Kynurenic_acid.msp"
file.copy(from = paste0(path_extdata, "/", MSPfile), to = temp_wd)
mspPosNegSplitter(temp_wd, MSPfile)

</code></pre>

<hr>
<h2 id='plotFSdb2SpectraCore'>
plot spectra from FSdb core
</h2><span id='topic+plotFSdb2SpectraCore'></span>

<h3>Description</h3>

<p>This function plots spectra figures from FSdb objects generated using the 'msp2FSdb' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotFSdb2SpectraCore(FSdb, index)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotFSdb2SpectraCore_+3A_fsdb">FSdb</code></td>
<td>

<p>FSdb
</p>
</td></tr>
<tr><td><code id="plotFSdb2SpectraCore_+3A_index">index</code></td>
<td>

<p>index
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>spectra_figure object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## To create the FSdb object
temp_wd &lt;- tempdir() # just a temporary folder
path_extdata &lt;- system.file("extdata", package = "IDSL.FSA")
MSPfile &lt;- c("Kynurenine_Kynurenic_acid.msp")
file.copy(from = paste0(path_extdata, "/", MSPfile), to = temp_wd)
FSdb &lt;- msp2FSdb(path = temp_wd, MSPfile)
## To plot spectra
index &lt;- 1
plotFSdb2SpectraCore(FSdb, index)

</code></pre>

<hr>
<h2 id='spectra_1A1B_mixer'>
Mixer 1:1 spectra A and B
</h2><span id='topic+spectra_1A1B_mixer'></span>

<h3>Description</h3>

<p>This function creates 1:1 mixed AB spectra for spectral entropy calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectra_1A1B_mixer(PEAK_A, PEAK_B, massError = 0, allowedNominalMass = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spectra_1A1B_mixer_+3A_peak_a">PEAK_A</code></td>
<td>

<p>A matrix (m/z, int) of fragmentation spectra
</p>
</td></tr>
<tr><td><code id="spectra_1A1B_mixer_+3A_peak_b">PEAK_B</code></td>
<td>

<p>A matrix (m/z, int) of fragmentation spectra
</p>
</td></tr>
<tr><td><code id="spectra_1A1B_mixer_+3A_masserror">massError</code></td>
<td>

<p>Mass accuracy in Da
</p>
</td></tr>
<tr><td><code id="spectra_1A1B_mixer_+3A_allowednominalmass">allowedNominalMass</code></td>
<td>

<p>c(TRUE, FALSE). Select 'TRUE' only for nominal mass analysis.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of 1:1 mixing spectra. First and second columns represent intensity-weighted average m/z and cumulated intensity, respectively.
</p>

<hr>
<h2 id='spectra_integrator'>
Spectra Integrator
</h2><span id='topic+spectra_integrator'></span>

<h3>Description</h3>

<p>This function integrates individual m/z peaks from multiple chromatogram scans (spectra) into summed m/z peaks using a mass accuracy or nominal masses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectra_integrator(stackedSpectra, massError = 0, allowedNominalMass = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spectra_integrator_+3A_stackedspectra">stackedSpectra</code></td>
<td>

<p>A matrix of two columns of the stacked spectra. First and second columns should represent m/z and intensity, respectively.
</p>
</td></tr>
<tr><td><code id="spectra_integrator_+3A_masserror">massError</code></td>
<td>

<p>Mass accuracy in Da
</p>
</td></tr>
<tr><td><code id="spectra_integrator_+3A_allowednominalmass">allowedNominalMass</code></td>
<td>

<p>c(TRUE, FALSE). Select 'TRUE' only for nominal mass analysis.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of integrated spectra. First and second columns represent intensity-weighted average m/z and cumulated intensity, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(stackedSpectra)
massError &lt;- 0.005 # Da
Integrated_spectra &lt;- spectra_integrator(stackedSpectra[, 1:2], massError)
</code></pre>

<hr>
<h2 id='spectra_ion_filter'>
Spectra Ion Filter
</h2><span id='topic+spectra_ion_filter'></span>

<h3>Description</h3>

<p>This function can detect m/z peaks that are related to each other across selected spectra lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectra_ion_filter(spectraList, indexSpectraList = length(spectraList), massError,
minPercentageDetectedScans = 10, rsdCutoff = 0, pearsonRHOthreshold = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spectra_ion_filter_+3A_spectralist">spectraList</code></td>
<td>

<p>a list of matrices of m/z and intensity values for each chromatogram scan
</p>
</td></tr>
<tr><td><code id="spectra_ion_filter_+3A_indexspectralist">indexSpectraList</code></td>
<td>

<p>a vector of spectra indices for the analysis. This vector should have at least 3 elements to run this function.
</p>
</td></tr>
<tr><td><code id="spectra_ion_filter_+3A_masserror">massError</code></td>
<td>

<p>required mass error for m/z values
</p>
</td></tr>
<tr><td><code id="spectra_ion_filter_+3A_rsdcutoff">rsdCutoff</code></td>
<td>

<p>Relative standard deviations (in percent) to remove constant peaks (usually noisy peaks)
</p>
</td></tr>
<tr><td><code id="spectra_ion_filter_+3A_minpercentagedetectedscans">minPercentageDetectedScans</code></td>
<td>

<p>Minimum percentage of detected scans for an m/z peak
</p>
</td></tr>
<tr><td><code id="spectra_ion_filter_+3A_pearsonrhothreshold">pearsonRHOthreshold</code></td>
<td>

<p>A threshold for pairwise Pearson's correlation coefficient across the selected spectra lists. This feature is recommended to find co-occurring peaks within a chromatographic peak. This feature may be used to eliminate instrument noises from MS2 data channels within an MS1 chromatographic peak for DDA analysis.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of m/z and cumulated intensities across the 'indexSpectraList' spectra
</p>

<hr>
<h2 id='spectral_entropy_calculator'>
Spectral Entropy Calculator
</h2><span id='topic+spectral_entropy_calculator'></span>

<h3>Description</h3>

<p>This module calculates spectral entropy for a fragmentation pattern using a method described by the reference paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectral_entropy_calculator(FragmentList, allowedWeightedSpectralEntropy = TRUE,
noiseRemovalRatio = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spectral_entropy_calculator_+3A_fragmentlist">FragmentList</code></td>
<td>

<p>A matrix (m/z, int) of fragmentation pattern after intensity adjustment
</p>
</td></tr>
<tr><td><code id="spectral_entropy_calculator_+3A_allowedweightedspectralentropy">allowedWeightedSpectralEntropy</code></td>
<td>

<p>c(TRUE, FALSE). Weighted entropy to transform low abundant signals prior to calculating entropy similarity score. Please see the reference for details on weight transformation.
</p>
</td></tr>
<tr><td><code id="spectral_entropy_calculator_+3A_noiseremovalratio">noiseRemovalRatio</code></td>
<td>

<p>noise removal ratio ([0 - 1])relative to the basepeak to measure entropy similarity score.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>spectralEntropy</code></td>
<td>

<p>spectral entropy
</p>
</td></tr>
<tr><td><code>NumPeaks</code></td>
<td>

<p>NumPeaks
</p>
</td></tr>
<tr><td><code>FragmentList</code></td>
<td>

<p>A matrix of two-columns after intensity normalization relative to summation of intensities AND entropy weight transformation when is selected.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>noise removal on intensities should be performed prior to feeding to this function
</p>


<h3>References</h3>

<p>Li, Y., Kind, T., Folz, J., Vaniya, A., Mehta, S.S. and Fiehn, O. (2021). Spectral entropy outperforms MS/MS dot product similarity for small-molecule compound identification. <em>Nature methods</em>, 18(12), 1524-1531, <a href="https://doi.org/10.1038/s41592-021-01331-z">doi:10.1038/s41592-021-01331-z</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FragmentList &lt;- cbind(seq(50, 600, length.out = 10), seq(10, 90, length.out = 10))
SE &lt;- spectral_entropy_calculator(FragmentList)
print(SE[[1]])
</code></pre>

<hr>
<h2 id='spectral_entropy_similarity_score'>
Spectral Entropy Calculator
</h2><span id='topic+spectral_entropy_similarity_score'></span>

<h3>Description</h3>

<p>This module measures similarity of spectral entropies between 'PEAK_A' and 'PEAK_B' fragment spectra using a method described by the reference paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectral_entropy_similarity_score(PEAK_A, S_PEAK_A, PEAK_B, S_PEAK_B, massError,
allowedNominalMass = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spectral_entropy_similarity_score_+3A_peak_a">PEAK_A</code></td>
<td>

<p>A matrix (m/z, int) of fragmentation spectra
</p>
</td></tr>
<tr><td><code id="spectral_entropy_similarity_score_+3A_s_peak_a">S_PEAK_A</code></td>
<td>

<p>Spectral entropy of PEAK_A
</p>
</td></tr>
<tr><td><code id="spectral_entropy_similarity_score_+3A_peak_b">PEAK_B</code></td>
<td>

<p>A matrix (m/z, int) of fragmentation spectra
</p>
</td></tr>
<tr><td><code id="spectral_entropy_similarity_score_+3A_s_peak_b">S_PEAK_B</code></td>
<td>

<p>Spectral entropy of PEAK_B
</p>
</td></tr>
<tr><td><code id="spectral_entropy_similarity_score_+3A_masserror">massError</code></td>
<td>

<p>Mass accuracy in Da
</p>
</td></tr>
<tr><td><code id="spectral_entropy_similarity_score_+3A_allowednominalmass">allowedNominalMass</code></td>
<td>

<p>c(TRUE, FALSE). Select 'TRUE' only for nominal mass analysis.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>spectral entropy similarity between 0 - 1
</p>


<h3>References</h3>

<p>Li, Y., Kind, T., Folz, J., Vaniya, A., Mehta, S.S. and Fiehn, O. (2021). Spectral entropy outperforms MS/MS dot product similarity for small-molecule compound identification. <em>Nature methods</em>, 18(12), 1524-1531, <a href="https://doi.org/10.1038/s41592-021-01331-z">doi:10.1038/s41592-021-01331-z</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>allowedWeightedSpectralEntropy &lt;- TRUE
##
A &lt;- cbind(seq(50, 160, length.out = 10), seq(10, 90, length.out = 10))
sA &lt;- spectral_entropy_calculator(A, allowedWeightedSpectralEntropy)
S_PEAK_A &lt;- sA[[1]]
PEAK_A &lt;- sA[[3]]
##
B &lt;- cbind(seq(50, 160, length.out = 10), seq(50, 60, length.out = 10))
sB &lt;- spectral_entropy_calculator(A, allowedWeightedSpectralEntropy)
S_PEAK_B &lt;- sB[[1]]
PEAK_B &lt;- sB[[3]]
##
allowedNominalMass = TRUE
entropyScore &lt;- spectral_entropy_similarity_score(PEAK_A, S_PEAK_A, PEAK_B,
S_PEAK_B, allowedNominalMass)
</code></pre>

<hr>
<h2 id='stackedSpectra'>
Example for a stacked spectra
</h2><span id='topic+stackedSpectra'></span>

<h3>Description</h3>

<p>A data to test the 'spectra_integrator' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("stackedSpectra")</code></pre>


<h3>Format</h3>


<dl>
<dt><code>mz</code></dt><dd><p>a numeric vector of m/z values</p>
</dd>
<dt><code>int</code></dt><dd><p>a numeric vector of intensities</p>
</dd>
<dt><code>scan_number</code></dt><dd><p>a numeric vector of chromatogram scan numbers</p>
</dd>
</dl>



<h3>Details</h3>

<p>The 'scan_number' column is not necessary to test the 'spectra_integrator' function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(stackedSpectra)
</code></pre>

<hr>
<h2 id='UFSA_element_sorter'>
Element Sorter
</h2><span id='topic+UFSA_element_sorter'></span>

<h3>Description</h3>

<p>This function sorts 84 elements in the periodic table for molecular formula deconvolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UFSA_element_sorter()
</code></pre>


<h3>Value</h3>

<p>A string vector of elements
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Elements &lt;- UFSA_element_sorter()
</code></pre>

<hr>
<h2 id='UFSA_formula_vector_generator'>
Molecular Formula Vector Generator
</h2><span id='topic+UFSA_formula_vector_generator'></span>

<h3>Description</h3>

<p>This function convert a molecular formulas into a numerical vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UFSA_formula_vector_generator(molecular_formula, Elements, LElements = length(Elements),
allowedRedundantElements = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UFSA_formula_vector_generator_+3A_molecular_formula">molecular_formula</code></td>
<td>

<p>molecular formula
</p>
</td></tr>
<tr><td><code id="UFSA_formula_vector_generator_+3A_elements">Elements</code></td>
<td>

<p>a string vector of elements. This value must be driven from the 'element_sorter' function.
</p>
</td></tr>
<tr><td><code id="UFSA_formula_vector_generator_+3A_lelements">LElements</code></td>
<td>

<p>number of elements. To speed up loop calculations, consider calculating the number of elements outside of the loop.
</p>
</td></tr>
<tr><td><code id="UFSA_formula_vector_generator_+3A_allowedredundantelements">allowedRedundantElements</code></td>
<td>

<p>'TRUE' should be used to deconvolute molecular formulas with redundant elements (e.g. CO2CH3O), and 'FALSE' should be used to skip such complex molecular formulas.(default value)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical vector for the molecular formula. This function returns a vector of -Inf values when the molecular formula has elements not listed in the 'Elements' string vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>molecular_formula &lt;- "C12H2Br5Cl3O"
Elements &lt;- UFSA_element_sorter()
mol_vec &lt;- UFSA_formula_vector_generator(molecular_formula, Elements)
##
regenerated_molecular_formula &lt;- UFSA_hill_molecular_formula_printer(Elements, mol_vec)
</code></pre>

<hr>
<h2 id='UFSA_hill_molecular_formula_printer'>
Print Hill Molecular Formula
</h2><span id='topic+UFSA_hill_molecular_formula_printer'></span>

<h3>Description</h3>

<p>This function produces molecular formulas from a list numerical vectors in the Hill notation system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UFSA_hill_molecular_formula_printer(MolVecMat, Elements, LElements = length(Elements))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UFSA_hill_molecular_formula_printer_+3A_molvecmat">MolVecMat</code></td>
<td>

<p>A matrix of numerical vectors of molecular formulas in each row.
</p>
</td></tr>
<tr><td><code id="UFSA_hill_molecular_formula_printer_+3A_elements">Elements</code></td>
<td>

<p>A vector string of the used elements.
</p>
</td></tr>
<tr><td><code id="UFSA_hill_molecular_formula_printer_+3A_lelements">LElements</code></td>
<td>

<p>LElements
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of molecular formulas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Elements &lt;- c("C", "H", "O", "N", "Br", "Cl")
MoleFormVec1 &lt;- c(2, 6, 1, 0, 0, 0) # C2H6O
MoleFormVec2 &lt;- c(8, 10, 2, 4, 0 ,0) # C8H10N4O2
MoleFormVec3 &lt;- c(12, 2, 1, 0, 5, 3) # C12H2Br5Cl3O
MolVecMat &lt;- rbind(MoleFormVec1, MoleFormVec2, MoleFormVec3)
H_MolF &lt;- UFSA_hill_molecular_formula_printer(MolVecMat, Elements)
</code></pre>

<hr>
<h2 id='UFSA_ionization_pathway_deconvoluter'>
Ionization Pathway Deconvoluter
</h2><span id='topic+UFSA_ionization_pathway_deconvoluter'></span>

<h3>Description</h3>

<p>This function deconvolutes ionization pathways into a coefficient and a numerical vector to simplify prediction ionization pathways.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UFSA_ionization_pathway_deconvoluter(IonPathways, Elements, LElements = length(Elements))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UFSA_ionization_pathway_deconvoluter_+3A_ionpathways">IonPathways</code></td>
<td>

<p>A vector of ionization pathways. Pathways should be like [Coeff*M+ADD1-DED1+...] where &quot;Coeff&quot; should be an integer between 1-9 and ADD1 and DED1 may be ionization pathways. ex: 'IonPathways &lt;- c(&quot;[M]+&quot;, &quot;[M+H]+&quot;, &quot;[2M-Cl]-&quot;, &quot;[3M+CO2-H2O+Na-KO2+HCl-NH4]-&quot;)'
</p>
</td></tr>
<tr><td><code id="UFSA_ionization_pathway_deconvoluter_+3A_elements">Elements</code></td>
<td>

<p>A vector string of the used elements
</p>
</td></tr>
<tr><td><code id="UFSA_ionization_pathway_deconvoluter_+3A_lelements">LElements</code></td>
<td>

<p>Counts of elements
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of adduct calculation values for each ionization pathway.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Elements &lt;- UFSA_element_sorter()
IonPathways &lt;- c("[M]+", "[M+H]+", "[2M-Cl]-", "[3M+CO2-H2O+Na-KO2+HCl-NH4]-")
Ion_DC &lt;- UFSA_ionization_pathway_deconvoluter(IonPathways, Elements)
</code></pre>

<hr>
<h2 id='UFSA_precursorType_corrector'>
UFA Precursor Type Corrector
</h2><span id='topic+UFSA_precursorType_corrector'></span>

<h3>Description</h3>

<p>Precursor type corrector from MSP files. This function initially attempts to standardize the precursor types to be consistent with the 'ionization_pathway_deconvoluter' module of the IDSL.SUFA package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UFSA_precursorType_corrector(precursorType, ionMode = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UFSA_precursorType_corrector_+3A_precursortype">precursorType</code></td>
<td>

<p>precursorType
</p>
</td></tr>
<tr><td><code id="UFSA_precursorType_corrector_+3A_ionmode">ionMode</code></td>
<td>

<p>ionMode
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>correctedPrecursorType
</p>


<h3>Examples</h3>

<pre><code class='language-R'>uncorrectedPrecursorType &lt;- c("[M]+", "[M+H]+", "[2M-Cl]-", "[3M+COO-H2O+Na-KO2+HCl-NH4]-")
precursorType &lt;- UFSA_precursorType_corrector(uncorrectedPrecursorType, ionMode = NULL)
</code></pre>

<hr>
<h2 id='xlsx2msp'>
xlsx to MSP
</h2><span id='topic+xlsx2msp'></span>

<h3>Description</h3>

<p>This function creates .msp files from an organized spreadsheet of fragmentation data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xlsx2msp(path, xlsxFileName = "", number_processing_threads = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xlsx2msp_+3A_path">path</code></td>
<td>

<p>address of the spreadsheet
</p>
</td></tr>
<tr><td><code id="xlsx2msp_+3A_xlsxfilename">xlsxFileName</code></td>
<td>

<p>name of the file with the .xlsx extension.
</p>
</td></tr>
<tr><td><code id="xlsx2msp_+3A_number_processing_threads">number_processing_threads</code></td>
<td>

<p>Number of processing threads for multi-threaded processing
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The .msp files are saved in the same location.
</p>


<h3>Note</h3>

<p>The spreadsheet should have only one column for the following headers (case-sensitive): c('ID', 'mz_fragment', 'int_fragment', 'Name')
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
temp_wd &lt;- tempdir() # just a temporary folder
path_extdata &lt;- system.file("extdata", package = "IDSL.FSA")
xlsxFileName &lt;- "PFAS_MSe.xlsx"
file.copy(from = paste0(path_extdata, "/", xlsxFileName), to = temp_wd)
xlsx2msp(temp_wd, xlsxFileName)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
