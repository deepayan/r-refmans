<!DOCTYPE html><html><head><title>Help for package netregR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {netregR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#build_blocklist'><p>build list of time blocks that are correlated based on the maximum time and type of temporal model</p>
#'</a></li>
<li><a href='#build_exchangeable_matrix'><p>Build an exchangeable matrix of sparseMatrix class</p></a></li>
<li><a href='#build_phi_matrix'><p>Build intermediate C(phi,n) matrix in inversion of Exchangeable variance matrix</p></a></li>
<li><a href='#calculate_matrix_params'><p>calculate parameter estimates for different types of matrices, i.e. 6a, 6b, etc.</p></a></li>
<li><a href='#calculate_parameter_inverse'><p>Invert matrix parameters based on inputs.</p></a></li>
<li><a href='#coef.lmnet'><p>Coef S3 generic for class lmnet</p></a></li>
<li><a href='#combine'><p>Find all possible combinations of elements in two vectors, or all combinations of all elements in one without repeats</p></a></li>
<li><a href='#dyad'><p>Dyad map from nodes i,j &ndash;&gt; dyad d</p></a></li>
<li><a href='#eigen_exch'><p>Eigenvalues of exchangeable matrices</p>
if calcall == TRUE, then output eigenvalues with multiplicities
Outputs eigenvectors when directed==FALSE</a></li>
<li><a href='#eigen_exch_time'><p>Compute eigenvalues of covariance matrices of jointly exchangeable errors with repeated observations</p></a></li>
<li><a href='#GEE_est_time'><p>Perform GEE estimate / IRWLS of coefficients for temporal data</p></a></li>
<li><a href='#GEE.est'><p>Perform GEE estimate / IRWLS of coefficients</p></a></li>
<li><a href='#inputs_lmnet'><p>Input preprocessing</p></a></li>
<li><a href='#interactions'><p>Social interaction data set</p></a></li>
<li><a href='#invert_exchangeable_matrix'><p>Invert an exchangeable matrix</p></a></li>
<li><a href='#lmnet'><p>Linear regression for network response</p></a></li>
<li><a href='#make.positive.var'><p>Replace negative eigenvalues with zeros in variance matrix</p></a></li>
<li><a href='#mat.net'><p>Matricize a network vector (without diagonal)</p></a></li>
<li><a href='#meat.DC.row'><p>Calculate DC meat using rows of X, e</p></a></li>
<li><a href='#meat.E.row'><p>Calculate E meat using rows of X, e</p></a></li>
<li><a href='#meatABC'><p>Matrix product of A^TBC where B is a short list of parameters</p>
A and C must be matrices
B is parameterized by phi, row.list, and assumed symmetric without repeats, with phi[1] along diagonal</a></li>
<li><a href='#model.matrix.lmnet'><p>model.matrix S3 generic for class lmnet</p></a></li>
<li><a href='#node_gen_time'><p>Make complete node indices for temporal relational data</p></a></li>
<li><a href='#node_preprocess'><p>Pre-processes data for ordering etc.</p></a></li>
<li><a href='#node_preprocess_time'><p>Pre-processes data for ordering, FOR TEMPORAL DATA, etc.</p></a></li>
<li><a href='#node.gen'><p>Generate node pairs for complete network</p></a></li>
<li><a href='#node.set'><p>Generate node sets of various overlapping dyad pairs</p></a></li>
<li><a href='#param_est'><p>Calculate parameter estimates using rows of e</p></a></li>
<li><a href='#param_est_single_ilist'><p>Given matrix of time blocks and a particular exchangeable parameter set (within each block),</p>
calculate a single parameter/phi. ASSUMES NO MISSING DATA</a></li>
<li><a href='#plot.lmnet'><p>Plot S3 generic for class lmnet</p></a></li>
<li><a href='#print.lmnet'><p>Print S3 generic for class lmnet</p></a></li>
<li><a href='#print.summary.lmnet'><p>Print S3 generic for class summary.lmnet</p></a></li>
<li><a href='#print.summary.vnet'><p>Print S3 generic for summary.vnet object</p></a></li>
<li><a href='#print.vnet'><p>Print S3 generic for vnet object</p></a></li>
<li><a href='#row_list_missing'><p>Generate row list based on nodes input with missingness</p></a></li>
<li><a href='#row_list_time'><p>Make row list for complete temporal relational data</p></a></li>
<li><a href='#rphi'><p>Generate positive definite phi set</p></a></li>
<li><a href='#Sigma.ind'><p>Generate list indicator matrix of overlapping dyads</p></a></li>
<li><a href='#summary.lmnet'><p>Summary S3 generic for class lmnet</p></a></li>
<li><a href='#summary.vnet'><p>Summary S3 generic for vnet object</p></a></li>
<li><a href='#symm_square_root'><p>Compute symmetric square root of A, assuming it is real, symmetric, positive definite</p></a></li>
<li><a href='#vcov.lmnet'><p>vcov S3 generic for class lmnet</p></a></li>
<li><a href='#vec.net'><p>Vectorize a network matrix (without diagonal)</p></a></li>
<li><a href='#vnet'><p>Variance computation for linear regression of network response</p></a></li>
<li><a href='#wolf'><p>Wolf network data set</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Regression of Network Responses</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Regress network responses (both directed and undirected) onto covariates of interest that may be actor-, relation-, or network-valued. In addition, compute principled variance estimates of the coefficients assuming that the errors are jointly exchangeable. Missing data is accommodated. Additionally implements building and inversion of covariance matrices under joint exchangeability, and  generates random covariance matrices from this class. For more detail on methods, see Marrs, Fosdick, and McCormick (2017) &lt;<a href="https://doi.org/10.48550/arXiv.1701.05530">doi:10.48550/arXiv.1701.05530</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, stats, graphics, utils</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, knitcitations</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-08-01 21:32:03 UTC; fmarrs3</td>
</tr>
<tr>
<td>Author:</td>
<td>Frank W. Marrs [aut, cre],
  Bailey K. Fosdick [aut],
  Tyler H. McCormick [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Frank W. Marrs &lt;frank.marrs@colostate.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-08-01 23:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='build_blocklist'>build list of time blocks that are correlated based on the maximum time and type of temporal model
#'</h2><span id='topic+build_blocklist'></span>

<h3>Description</h3>

<p>build list of time blocks that are correlated based on the maximum time and type of temporal model
#'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_blocklist(tmax, type = "EI")
</code></pre>

<hr>
<h2 id='build_exchangeable_matrix'>Build an exchangeable matrix of sparseMatrix class</h2><span id='topic+build_exchangeable_matrix'></span>

<h3>Description</h3>

<p>Build an exchangeable matrix of sparseMatrix class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_exchangeable_matrix(n, phi, directed = TRUE, dyads = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_exchangeable_matrix_+3A_n">n</code></td>
<td>
<p>Number of actors in the network, scalar numeric.</p>
</td></tr>
<tr><td><code id="build_exchangeable_matrix_+3A_phi">phi</code></td>
<td>
<p>Appropriate-length vector of parameters, must be length 5 or 6 for directed=<code>TRUE</code> or length 2 or 3 for directed=<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="build_exchangeable_matrix_+3A_directed">directed</code></td>
<td>
<p>Optional logical indicator of whether input data is for a directed network, default is <code>TRUE</code>. Undirected data format is lower triangle of adjacencey matrix.</p>
</td></tr>
<tr><td><code id="build_exchangeable_matrix_+3A_dyads">dyads</code></td>
<td>
<p>Optional numeric vector of dyads to subset the matrix to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function builds a covariance matrix in the exchangeable class from the vector of parameters input. See Marrs et.al. (2017).
</p>


<h3>Value</h3>

<table>
<tr><td><code>out</code></td>
<td>
<p>Exchangeable matrix.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Marrs, F. W., Fosdick, B. K., &amp; McCormick, T. H., (2017). Standard errors for regression on relational data with exchangeable errors. arXiv preprint arXiv:1701.05530.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rphi">rphi</a></code>, <code><a href="#topic+invert_exchangeable_matrix">invert_exchangeable_matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 5
build_exchangeable_matrix(n, rphi(n, seed=1))

</code></pre>

<hr>
<h2 id='build_phi_matrix'>Build intermediate C(phi,n) matrix in inversion of Exchangeable variance matrix</h2><span id='topic+build_phi_matrix'></span>

<h3>Description</h3>

<p>Build intermediate C(phi,n) matrix in inversion of Exchangeable variance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_phi_matrix(n, phi, directed = T, sta_flag = F)
</code></pre>

<hr>
<h2 id='calculate_matrix_params'>calculate parameter estimates for different types of matrices, i.e. 6a, 6b, etc.</h2><span id='topic+calculate_matrix_params'></span>

<h3>Description</h3>

<p>calculate parameter estimates for different types of matrices, i.e. 6a, 6b, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_matrix_params(ilist, e, tmax, type = "EI")
</code></pre>

<hr>
<h2 id='calculate_parameter_inverse'>Invert matrix parameters based on inputs.</h2><span id='topic+calculate_parameter_inverse'></span>

<h3>Description</h3>

<p>Invert matrix parameters based on inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_parameter_inverse(n, tmax, params, type = "EI")
</code></pre>

<hr>
<h2 id='coef.lmnet'>Coef S3 generic for class lmnet</h2><span id='topic+coef.lmnet'></span>

<h3>Description</h3>

<p>Coef S3 generic for class lmnet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmnet'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.lmnet_+3A_object">object</code></td>
<td>
<p>lmnet object</p>
</td></tr>
<tr><td><code id="coef.lmnet_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='combine'>Find all possible combinations of elements in two vectors, or all combinations of all elements in one without repeats</h2><span id='topic+combine'></span>

<h3>Description</h3>

<p>Find all possible combinations of elements in two vectors, or all combinations of all elements in one without repeats
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine(v1, v2 = NA)
</code></pre>

<hr>
<h2 id='dyad'>Dyad map from nodes i,j &ndash;&gt; dyad d</h2><span id='topic+dyad'></span>

<h3>Description</h3>

<p>Dyad map from nodes i,j &ndash;&gt; dyad d
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dyad(i.in, j.in, n.tot, directed = T)
</code></pre>

<hr>
<h2 id='eigen_exch'>Eigenvalues of exchangeable matrices
if calcall == TRUE, then output eigenvalues with multiplicities
Outputs eigenvectors when directed==FALSE</h2><span id='topic+eigen_exch'></span>

<h3>Description</h3>

<p>Eigenvalues of exchangeable matrices
if calcall == TRUE, then output eigenvalues with multiplicities
Outputs eigenvectors when directed==FALSE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigen_exch(n, phi, directed = FALSE, calcall = TRUE)
</code></pre>

<hr>
<h2 id='eigen_exch_time'>Compute eigenvalues of covariance matrices of jointly exchangeable errors with repeated observations</h2><span id='topic+eigen_exch_time'></span>

<h3>Description</h3>

<p>Compute eigenvalues of covariance matrices of jointly exchangeable errors with repeated observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigen_exch_time(n, tmax, params, directed, type)
</code></pre>

<hr>
<h2 id='GEE_est_time'>Perform GEE estimate / IRWLS of coefficients for temporal data</h2><span id='topic+GEE_est_time'></span>

<h3>Description</h3>

<p>TO DO:
eigenvalues / ndstop
fix for missingness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEE_est_time(Y, X, n, tmax, directed = TRUE, type = "EE",
  write_dir = NULL, missing = FALSE, tol.in = 1e-06, maxit = 10000,
  ndstop = TRUE, verbose = FALSE)
</code></pre>

<hr>
<h2 id='GEE.est'>Perform GEE estimate / IRWLS of coefficients</h2><span id='topic+GEE.est'></span>

<h3>Description</h3>

<p>Perform GEE estimate / IRWLS of coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEE.est(row.list, Y, X, n, directed = TRUE, beta_start = NULL,
  missing = FALSE, dyads = NULL, tol.in = 1e-06, maxit = 10000,
  ndstop = TRUE, verbose = FALSE)
</code></pre>

<hr>
<h2 id='inputs_lmnet'>Input preprocessing</h2><span id='topic+inputs_lmnet'></span>

<h3>Description</h3>

<p>Prepare covariates and optional response in adjacency matrix form. If undirected, the values are drawn from the lower triangle of the adjacency matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inputs_lmnet(Xlist, Y = NULL, directed = TRUE, add_intercept = TRUE,
  time_intercept = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inputs_lmnet_+3A_xlist">Xlist</code></td>
<td>
<p>List of <code class="reqn">n \times n \times tmax</code> matrices, possibly containing response matrix labeled &lsquo;Y&rsquo;. Diagonals (self-loops) are ignored.</p>
</td></tr>
<tr><td><code id="inputs_lmnet_+3A_y">Y</code></td>
<td>
<p>Optional <code class="reqn">n \times n \times tmax</code> response matrix. NAs in this matrix will be automatically removed. Diagonals (self-loops) are ignored.</p>
</td></tr>
<tr><td><code id="inputs_lmnet_+3A_directed">directed</code></td>
<td>
<p>Optional logical indicator of whether input data is for a directed network, default is <code>TRUE</code>. Undirected data format is lower triangle of adjacencey matrix.</p>
</td></tr>
<tr><td><code id="inputs_lmnet_+3A_add_intercept">add_intercept</code></td>
<td>
<p>Optional logical indicator of whether intercept should be added to X, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="inputs_lmnet_+3A_time_intercept">time_intercept</code></td>
<td>
<p>Optional logical indicator of whether separate intercept should be added to X for each observation of the relational matrix, default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a list of network covariates (in adjacency matrix form) and prepares them for the regression code <code>lmnet</code>. Accomodates 3-dimensional relational arrays with <code>tmax</code> repeated observations of the network (over time or context). Typical network data with a single observation may be input as matrices, i.e. <code>tmax = 1</code>.
</p>


<h3>Value</h3>

<p>A list of:
</p>
<table>
<tr><td><code>Y</code></td>
<td>
<p>Vector of responses (column-wise vectorization order) of appropriate length.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Matrix of covariates (column-wise vectorization order) of appropriate size.</p>
</td></tr>
<tr><td><code>nodes</code></td>
<td>
<p>2-column matrix (or 3-column for repeated observations) indicating directed relation pairs to which each entry in <code class="reqn">Y</code> and each row in <code class="reqn">X</code> corresponds.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+lmnet">lmnet</a></code>, <code><a href="#topic+vhat_exch">vhat_exch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># tmax = 1
set.seed(1)
n &lt;- 10
Xlist &lt;- list(matrix(rnorm(n^2),n,n), matrix(sample(c(0,1), n^2, replace=TRUE),n,n))
Xlist$Y &lt;- matrix(rnorm(n^2), n, n)
Xlist$Y[1:5] &lt;- NA
r &lt;- inputs_lmnet(Xlist)
r
lmnet(r$Y,r$X,nodes=r$nodes)

# tmax = 4
set.seed(1)
n &lt;- 10
tmax &lt;- 4
X1 &lt;- array(rnorm(n^2*tmax),c(n,n,tmax))
X2 &lt;- array(sample(c(0,1), n^2*tmax, replace=TRUE), c(n,n,tmax))
Xlist &lt;- list(X1, X2)
Xlist$Y &lt;- array(rnorm(n^2)*tmax, c(n, n, tmax))
Xlist$Y[1:5] &lt;- NA
r &lt;- inputs_lmnet(Xlist)
head(r$nodes)

</code></pre>

<hr>
<h2 id='interactions'>Social interaction data set</h2><span id='topic+interactions'></span>

<h3>Description</h3>

<p>A synthetic data set of standardized, directed interactions between 25 students in a seventh grade class.
</p>


<h3>Format</h3>

<p>A data set with four variables. Includes the true parameters.
</p>

<dl>
<dt>interactions</dt><dd><p>25 x 25 x 5 numeric array of directed relations</p>
</dd>
<dt>xbinary</dt><dd><p>25 x 25 x 5 numeric array of  binary indictors</p>
</dd>
<dt>xabs</dt><dd><p>25 x 25 x 5 numeric array of standardized absolute difference in indicated interest in each subject area</p>
</dd>
<dt>betatrue</dt><dd><p>Numeric vector of length 7 that contains true coefficients. The first two (value 1) pertain to <code>shared_project</code> and <code>grade_difference_abs</code>. The last three are separate intercepts for each observation of the network.</p>
</dd>
<dt>Omegatrue</dt><dd><p>3000 x 3000 numeric matrix: the true covariance matrix of the errors.</p>
</dd>
<dt>phitrue</dt><dd><p>2x6 numeric matrix: true parameters of covariance matrix.</p>
</dd>
</dl>


<h3>Details</h3>

<p>We generated a symthetic data set form a true linear model with jointly exchangeable errors. The interactions (the outcomes) between 25 students represent normalized, directed relations between them in 5 different contexts (texts). The observation could be, for instance, the standardized number of characters texted from one student to another over a month pertaining to five subjects: school, friends, family, significant others, and popular culture. The first covariate, <code>xbinary</code>, indicates whether both students indicated in a survey that they were interested in each topic. The second covariate, <code>xabs</code>, measures the absolute, standardized difference in number of characters in total texts of each student of each subject area.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("interactions")

</code></pre>

<hr>
<h2 id='invert_exchangeable_matrix'>Invert an exchangeable matrix</h2><span id='topic+invert_exchangeable_matrix'></span>

<h3>Description</h3>

<p>Invert an exchangeable matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invert_exchangeable_matrix(n, phi, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invert_exchangeable_matrix_+3A_n">n</code></td>
<td>
<p>Number of actors in the network, scalar numeric.</p>
</td></tr>
<tr><td><code id="invert_exchangeable_matrix_+3A_phi">phi</code></td>
<td>
<p>Appropriate-length vector of parameters, must be length 5 or 6 for directed=<code>TRUE</code> or length 2 or 3 for directed=<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="invert_exchangeable_matrix_+3A_directed">directed</code></td>
<td>
<p>Optional logical indicator of whether input data is for a directed network, default is <code>TRUE</code>. Undirected data format is lower triangle of adjacencey matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function inverts a covariance matrix of the exchangeable class in a manner much faster than the direct inverse, and the computational cost does not scale with n. See Marrs et. al. (2017). This approach will only work for complete networks.
</p>


<h3>Value</h3>

<table>
<tr><td><code>out</code></td>
<td>
<p>Parameters of inverted matrix of exchangeable class.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Marrs, F. W., Fosdick, B. K., &amp; McCormick, T. H., (2017). Standard errors for regression on relational data with exchangeable errors. arXiv preprint arXiv:1701.05530.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rphi">rphi</a></code>, <code><a href="#topic+build_exchangeable_matrix">build_exchangeable_matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 10
phi &lt;- rphi(n, seed=1)
p &lt;- invert_exchangeable_matrix(n, phi)
I1 &lt;- build_exchangeable_matrix(n, phi) %*% build_exchangeable_matrix(n, p)
range(I1 -  diag(n*(n-1)))   # it works

</code></pre>

<hr>
<h2 id='lmnet'>Linear regression for network response</h2><span id='topic+lmnet'></span>

<h3>Description</h3>

<p>This function takes <code class="reqn">X</code> and <code class="reqn">Y</code> values and fits the multiple linear regression <code class="reqn">Y = X \beta + \epsilon</code> and returns standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmnet(Y, X, directed = TRUE, tmax = 1, nodes = NULL, reweight = FALSE,
  type = "exchangeable", tol = 1e-06, maxit = 10000, ndstop = TRUE,
  verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmnet_+3A_y">Y</code></td>
<td>
<p>Vector of relations to be regress, of length <code class="reqn">d</code>. Column-wise vectorization of adjacency matrix without diagonal entries (self-loops).</p>
</td></tr>
<tr><td><code id="lmnet_+3A_x">X</code></td>
<td>
<p>Matrix of covariates to be regressed upon, including intercept if intercept is desired, must have <code class="reqn">d</code> rows. Ordering of rows should match <code>Y</code> and optional input <code>nodes</code>.</p>
</td></tr>
<tr><td><code id="lmnet_+3A_directed">directed</code></td>
<td>
<p>Optional logical indicator of whether input data is for a directed network, default is <code>TRUE</code>. Undirected data format is lower triangle of adjacencey matrix.</p>
</td></tr>
<tr><td><code id="lmnet_+3A_tmax">tmax</code></td>
<td>
<p>Optional numeric of third dimension of relational data array, default is <code>1</code>, i.e. a relational matrix.</p>
</td></tr>
<tr><td><code id="lmnet_+3A_nodes">nodes</code></td>
<td>
<p>Optional <code class="reqn">d \times 2</code> matrix indicating the (directed) relation pairs to which each entry in <code class="reqn">Y</code> and each row in <code class="reqn">X</code> corresponds. If not input, complete network observation with column-wise vectorization of adjacency matrix without diagonal entries (self-loops) is assumed. The size <code class="reqn">d</code> and <code>directed</code> must correspond to an appropriate network of size <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="lmnet_+3A_reweight">reweight</code></td>
<td>
<p>Optional logical indicator of whether iteratively reweighted least squares should be used to compute estimate of <code class="reqn">\beta</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="lmnet_+3A_type">type</code></td>
<td>
<p>Optional character specifying degree of exchangeability of third dimension of array (when present, i.e. in temporal relational arrays). Default is <code>exchangeable</code>, and the remaining option is <code>independent</code>. Truncated inputs are accepted. See details below.</p>
</td></tr>
<tr><td><code id="lmnet_+3A_tol">tol</code></td>
<td>
<p>Optional numeric, tolerance of stopping criteria of iteratively reweighted least squares estimate of <code class="reqn">\beta</code>. Default is <code>tol=1e-6</code>.</p>
</td></tr>
<tr><td><code id="lmnet_+3A_maxit">maxit</code></td>
<td>
<p>Optional numeric, maximum number of iterations for iteratively reweighted least squares estimate of <code class="reqn">\beta</code>. Default is <code>maxit=1e4</code>.</p>
</td></tr>
<tr><td><code id="lmnet_+3A_ndstop">ndstop</code></td>
<td>
<p>Optional logical indicator of whether negative definite weighting matrix in iteratively reweighted least squares should stop the descent. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="lmnet_+3A_verbose">verbose</code></td>
<td>
<p>Optional logical indicator of whether information from iteratively reweighted least squares estimate of <code class="reqn">\beta</code> should be printed. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes <code class="reqn">X</code> and <code class="reqn">Y</code> values and fits the multiple linear regression <code class="reqn">Y = X \beta + \epsilon</code> by ordinary least squares or iteratively reweighted least squares as indicated by the input. The covariance structure is exchangeable from that of Marrs et. al. (2017). The standard errors and test statistics are based on the same paper.    
</p>
<p>The three dimensional relational array case, i.e. temporal relational data, requires a specification of the type of exchangeability in this third dimension. We may assume that different time periods are independent. On the other hand, we might assume each repeated observation is exchangeable (for example decomposing trade networks into sectors of trade: goods vs. services). See Figure 6a of Marrs et. al. (2017) for the exchangeable case and the surrounding discussion for the independent case.
</p>


<h3>Value</h3>

<table>
<tr><td><code>fit</code></td>
<td>
<p>An <code>lmnet</code> object containing summary information.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Marrs, F. W., Fosdick, B. K., &amp; McCormick, T. H., (2017). Standard errors for regression on relational data with exchangeable errors. arXiv preprint arXiv:1701.05530.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vhat_exch">vhat_exch</a></code>, <code><a href="#topic+inputs_lmnet">inputs_lmnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 10
d &lt;- n*(n-1)
X &lt;- cbind(1, rnorm(d), sample(c(0,1), d, replace=TRUE))
betatrue &lt;- rep(1,3)
Y &lt;- X %*% betatrue + rnorm(d)
fit &lt;- lmnet(Y,X)
fit
fit2 &lt;- lmnet(Y,X,reweight=TRUE)
fit2

</code></pre>

<hr>
<h2 id='make.positive.var'>Replace negative eigenvalues with zeros in variance matrix</h2><span id='topic+make.positive.var'></span>

<h3>Description</h3>

<p>Replace negative eigenvalues with zeros in variance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.positive.var(V.test)
</code></pre>

<hr>
<h2 id='mat.net'>Matricize a network vector (without diagonal)</h2><span id='topic+mat.net'></span>

<h3>Description</h3>

<p>Matricize a network vector (without diagonal)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat.net(V, directed = T)
</code></pre>

<hr>
<h2 id='meat.DC.row'>Calculate DC meat using rows of X, e</h2><span id='topic+meat.DC.row'></span>

<h3>Description</h3>

<p>Calculate DC meat using rows of X, e
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meat.DC.row(row.list, X, e)
</code></pre>

<hr>
<h2 id='meat.E.row'>Calculate E meat using rows of X, e</h2><span id='topic+meat.E.row'></span>

<h3>Description</h3>

<p>Calculate E meat using rows of X, e
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meat.E.row(row.list, X, e)
</code></pre>

<hr>
<h2 id='meatABC'>Matrix product of A^TBC where B is a short list of parameters
A and C must be matrices
B is parameterized by phi, row.list, and assumed symmetric without repeats, with phi[1] along diagonal</h2><span id='topic+meatABC'></span>

<h3>Description</h3>

<p>Matrix product of A^TBC where B is a short list of parameters
A and C must be matrices
B is parameterized by phi, row.list, and assumed symmetric without repeats, with phi[1] along diagonal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meatABC(row.list, phi, A, C, directed)
</code></pre>

<hr>
<h2 id='model.matrix.lmnet'>model.matrix S3 generic for class lmnet</h2><span id='topic+model.matrix.lmnet'></span>

<h3>Description</h3>

<p>model.matrix S3 generic for class lmnet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmnet'
model.matrix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix.lmnet_+3A_object">object</code></td>
<td>
<p>lmnet object</p>
</td></tr>
<tr><td><code id="model.matrix.lmnet_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='node_gen_time'>Make complete node indices for temporal relational data</h2><span id='topic+node_gen_time'></span>

<h3>Description</h3>

<p>Make complete node indices for temporal relational data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_gen_time(n, directed, tmax)
</code></pre>

<hr>
<h2 id='node_preprocess'>Pre-processes data for ordering etc.</h2><span id='topic+node_preprocess'></span>

<h3>Description</h3>

<p>Pre-processes data for ordering etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_preprocess(Y, X, directed, nodes, subtract = NULL)
</code></pre>

<hr>
<h2 id='node_preprocess_time'>Pre-processes data for ordering, FOR TEMPORAL DATA, etc.</h2><span id='topic+node_preprocess_time'></span>

<h3>Description</h3>

<p>TO-DO:
missing data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_preprocess_time(Y, X, directed, nodes, tmax, type, subtract = NULL)
</code></pre>

<hr>
<h2 id='node.gen'>Generate node pairs for complete network</h2><span id='topic+node.gen'></span>

<h3>Description</h3>

<p>Generate node pairs for complete network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node.gen(n, directed = T)
</code></pre>

<hr>
<h2 id='node.set'>Generate node sets of various overlapping dyad pairs</h2><span id='topic+node.set'></span>

<h3>Description</h3>

<p>Generate node sets of various overlapping dyad pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node.set(n.tot, directed = T)
</code></pre>

<hr>
<h2 id='param_est'>Calculate parameter estimates using rows of e</h2><span id='topic+param_est'></span>

<h3>Description</h3>

<p>Calculate parameter estimates using rows of e
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param_est(row.list, e)
</code></pre>

<hr>
<h2 id='param_est_single_ilist'>Given matrix of time blocks and a particular exchangeable parameter set (within each block),
calculate a single parameter/phi. ASSUMES NO MISSING DATA</h2><span id='topic+param_est_single_ilist'></span>

<h3>Description</h3>

<p>Given matrix of time blocks and a particular exchangeable parameter set (within each block),
calculate a single parameter/phi. ASSUMES NO MISSING DATA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param_est_single_ilist(ilist, blockmat, e, d.tot)
</code></pre>

<hr>
<h2 id='plot.lmnet'>Plot S3 generic for class lmnet</h2><span id='topic+plot.lmnet'></span>

<h3>Description</h3>

<p>Plot S3 generic for class lmnet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmnet'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lmnet_+3A_x">x</code></td>
<td>
<p>lmnet object</p>
</td></tr>
<tr><td><code id="plot.lmnet_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='print.lmnet'>Print S3 generic for class lmnet</h2><span id='topic+print.lmnet'></span>

<h3>Description</h3>

<p>Print S3 generic for class lmnet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmnet'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.lmnet_+3A_x">x</code></td>
<td>
<p>lmnet object</p>
</td></tr>
<tr><td><code id="print.lmnet_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='print.summary.lmnet'>Print S3 generic for class summary.lmnet</h2><span id='topic+print.summary.lmnet'></span>

<h3>Description</h3>

<p>Print S3 generic for class summary.lmnet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.lmnet'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.lmnet_+3A_x">x</code></td>
<td>
<p>summary.lmnet object</p>
</td></tr>
<tr><td><code id="print.summary.lmnet_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='print.summary.vnet'>Print S3 generic for summary.vnet object</h2><span id='topic+print.summary.vnet'></span>

<h3>Description</h3>

<p>Print S3 generic for summary.vnet object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.vnet'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.vnet_+3A_x">x</code></td>
<td>
<p>summary.vnet object</p>
</td></tr>
<tr><td><code id="print.summary.vnet_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='print.vnet'>Print S3 generic for vnet object</h2><span id='topic+print.vnet'></span>

<h3>Description</h3>

<p>Print S3 generic for vnet object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vnet'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.vnet_+3A_x">x</code></td>
<td>
<p>vnet object</p>
</td></tr>
<tr><td><code id="print.vnet_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='row_list_missing'>Generate row list based on nodes input with missingness</h2><span id='topic+row_list_missing'></span>

<h3>Description</h3>

<p>Generate row list based on nodes input with missingness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_list_missing(nodes, dyads, directed, subtract)
</code></pre>

<hr>
<h2 id='row_list_time'>Make row list for complete temporal relational data</h2><span id='topic+row_list_time'></span>

<h3>Description</h3>

<p>Make row list for complete temporal relational data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_list_time(n, directed, tmax, type)
</code></pre>

<hr>
<h2 id='rphi'>Generate positive definite phi set</h2><span id='topic+rphi'></span>

<h3>Description</h3>

<p>Generate positive definite phi set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rphi(n, seed = NULL, phi6 = FALSE, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rphi_+3A_n">n</code></td>
<td>
<p>Number of actors in the network, scalar numeric.</p>
</td></tr>
<tr><td><code id="rphi_+3A_seed">seed</code></td>
<td>
<p>Optional numeric seed to set, default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="rphi_+3A_phi6">phi6</code></td>
<td>
<p>Optional logical indicator of whether sixth parameter <code class="reqn">\phi_6</code> should be considered nonzero. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rphi_+3A_directed">directed</code></td>
<td>
<p>Optional logical indicator of whether input data is for a directed network, default is <code>TRUE</code>. Undirected data format is lower triangle of adjacencey matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a set of 5 (or 6, as appropriate) parameters that corresponds to positive definite exchangeable covariance matrix for a network of size <code>n</code>. See Marrs et. al. (2017).
</p>


<h3>Value</h3>

<table>
<tr><td><code>phi</code></td>
<td>
<p>Vector of parameters.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Marrs, F. W., Fosdick, B. K., &amp; McCormick, T. H.,  (2017). Standard errors for regression on relational data with exchangeable errors. arXiv preprint arXiv:1701.05530.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_exchangeable_matrix">build_exchangeable_matrix</a></code>, <code><a href="#topic+invert_exchangeable_matrix">invert_exchangeable_matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rphi(10, seed=1)

</code></pre>

<hr>
<h2 id='Sigma.ind'>Generate list indicator matrix of overlapping dyads</h2><span id='topic+Sigma.ind'></span>

<h3>Description</h3>

<p>Generate list indicator matrix of overlapping dyads
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sigma.ind(n.tot, directed, sta_flag = F)
</code></pre>

<hr>
<h2 id='summary.lmnet'>Summary S3 generic for class lmnet</h2><span id='topic+summary.lmnet'></span>

<h3>Description</h3>

<p>Summary S3 generic for class lmnet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmnet'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lmnet_+3A_object">object</code></td>
<td>
<p>lmnet object</p>
</td></tr>
<tr><td><code id="summary.lmnet_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='summary.vnet'>Summary S3 generic for vnet object</h2><span id='topic+summary.vnet'></span>

<h3>Description</h3>

<p>Summary S3 generic for vnet object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vnet'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.vnet_+3A_object">object</code></td>
<td>
<p>vnet object</p>
</td></tr>
<tr><td><code id="summary.vnet_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='symm_square_root'>Compute symmetric square root of A, assuming it is real, symmetric, positive definite</h2><span id='topic+symm_square_root'></span>

<h3>Description</h3>

<p>Compute symmetric square root of A, assuming it is real, symmetric, positive definite
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symm_square_root(A, prec = 15)
</code></pre>

<hr>
<h2 id='vcov.lmnet'>vcov S3 generic for class lmnet</h2><span id='topic+vcov.lmnet'></span>

<h3>Description</h3>

<p>vcov S3 generic for class lmnet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmnet'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.lmnet_+3A_object">object</code></td>
<td>
<p>lmnet object</p>
</td></tr>
<tr><td><code id="vcov.lmnet_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='vec.net'>Vectorize a network matrix (without diagonal)</h2><span id='topic+vec.net'></span>

<h3>Description</h3>

<p>Vectorize a network matrix (without diagonal)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec.net(A, directed = T)
</code></pre>

<hr>
<h2 id='vnet'>Variance computation for linear regression of network response</h2><span id='topic+vnet'></span><span id='topic+vhat_exch'></span>

<h3>Description</h3>

<p>Stand-alone estimation of exchangeable variance matrix based on residuals and design matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vnet(e = NULL, X = NULL, directed = TRUE, nodes = NULL,
  type = "exchangeable", tmax = 1, fit = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vnet_+3A_e">e</code></td>
<td>
<p>Optional vector of residuals, of length <code class="reqn">d</code>. Column-wise unfolding of adjacency matrix without diagonal entries (self-loops).</p>
</td></tr>
<tr><td><code id="vnet_+3A_x">X</code></td>
<td>
<p>Optional matrix of covariates from regression, must have <code class="reqn">d</code> rows.</p>
</td></tr>
<tr><td><code id="vnet_+3A_directed">directed</code></td>
<td>
<p>Optional logical indicator of whether input data is for a directed network, default is <code>TRUE</code>. Undirected data format is lower triangle of adjacencey matrix.</p>
</td></tr>
<tr><td><code id="vnet_+3A_nodes">nodes</code></td>
<td>
<p>Optional <code class="reqn">d \times 2</code> matrix indicating the (directed) relation pairs to which each entry in <code class="reqn">e</code> and each row in <code class="reqn">X</code> corresponds. If not input, complete network observation is assumed and the size <code class="reqn">d</code> and <code>directed</code> must correspond to an appropriate network of size <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="vnet_+3A_type">type</code></td>
<td>
<p>Optional string indicating whether the &lsquo;meat&rsquo; in the sandwich variance estimator is estimated using exchangeable theory (see Marrs et. al. (2017)) or using dyadic clustering (Fafchamps and Gubert (2007)).</p>
</td></tr>
<tr><td><code id="vnet_+3A_tmax">tmax</code></td>
<td>
<p>Optional numeric of third dimension of relational data array, default is <code>1</code>, i.e. a relational matrix. Currently only accepts <code>tmax = 1</code>.</p>
</td></tr>
<tr><td><code id="vnet_+3A_fit">fit</code></td>
<td>
<p>Optional fitted model object. One of either <code>fit</code> or the pair <code>(e, X)</code> must be specified. Defaults to <code>fit</code> if both entered. Designed around &lsquo;lmnet&rsquo; class but may work for others, such as &lsquo;lm&rsquo;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes <code class="reqn">X</code> and <code class="reqn">e</code> values computes the variance-covariance matrix of <code class="reqn">\hat{\beta}</code> that resulted in the residuals <code class="reqn">e = Y - X \hat{\beta}</code> assuming that the errors are exchangeable, as based on Marrs et. al. (2017) when <code>type = "exchangeable"</code>. When <code>type = "dyadic clustering"</code>, the theory from Fafchamps and Gubert (2007) is implemented.
</p>


<h3>Value</h3>

<p>A an object of class <code>vhat</code> containing summary information:
</p>
<table>
<tr><td><code>vhat</code></td>
<td>
<p>Estimated variance-covariance matrix of cofficient estimates <code class="reqn">\hat{\beta}</code>.</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>Vector of variance-covariance parameter estimates.</p>
</td></tr>
<tr><td><code>corrected</code></td>
<td>
<p>Logical of whether variance-covariance matrix was corrected from negative definite to positive semi-definite.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>See inputs.</p>
</td></tr>
<tr><td><code>tmax</code></td>
<td>
<p>See inputs.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Marrs, F. W., Fosdick, B. K., &amp; McCormick, T. H.,  (2017). Standard errors for regression on relational data with exchangeable errors. arXiv preprint arXiv:1701.05530.
</p>
<p>Fafchamps, M., &amp; Gubert, F. (2007). Risk sharing and network formation. American Economic Review, 97(2), 75-79.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmnet">lmnet</a></code>, <code><a href="#topic+inputs_lmnet">inputs_lmnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 10
d &lt;- n*(n-1)
X &lt;- cbind(1, rnorm(d), sample(c(0,1), d, replace=TRUE))
e &lt;- rnorm(d)
vnet(e=e,X=X)

</code></pre>

<hr>
<h2 id='wolf'>Wolf network data set</h2><span id='topic+wolf'></span>

<h3>Description</h3>

<p>A data set measuring dominance and its behavioral measures in a captive wolf pack.
</p>


<h3>Format</h3>

<p>A data set with three variables
</p>

<dl>
<dt>wolf</dt><dd><p>16 x 16 numeric matrix of dominance measures</p>
</dd>
<dt>wolf_age_diff</dt><dd><p>16 x 16 numeric matrix of difference in ages (column less row)</p>
</dd>
<dt>wolf_same_sex</dt><dd><p>16 x 16 numeric matrix of indicators of same sex</p>
</dd>
</dl>


<h3>Details</h3>

<p>This is data on a captive family of wolves in Arnheim, Germany. The 16 wolves studied here were housed in a large wooded enclosure and observed in 1978. This matrix displays deference acts. The number in a cell represents the number of occasions on which the row wolf was seen to exhibit a &quot;low posture&quot; display directed toward the column wolf. The behavior could involve approach or retreat, but the fact that it was performed in &quot;low posture&quot; suggests that it was deferent. Data obtained March 20, 2018 from <a href="http://moreno.ss.uci.edu/data.html#wolf">http://moreno.ss.uci.edu/data.html#wolf</a>.
</p>


<h3>Source</h3>

<p><a href="http://moreno.ss.uci.edu/data.html#wolf">http://moreno.ss.uci.edu/data.html#wolf</a>
</p>


<h3>References</h3>

<p>Jan A. R. A. M. van Hooff and Joep A. B. Wensing, &quot;Dominance and its behavioral measures in a captive wolf pack,&quot; Chapter 11 in Harry Frank, ed., Man and Wolf. Dordrecht: Junk, 1987, pp. 219-252.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("wolf")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
