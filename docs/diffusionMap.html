<!DOCTYPE html><html><head><title>Help for package diffusionMap</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {diffusionMap}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adapreg'><p>Adaptive Regression</p></a></li>
<li><a href='#adapreg.m'><p>Adaptive Regression</p></a></li>
<li><a href='#annulus'><p>Annulus toy data set</p></a></li>
<li><a href='#Chainlink'><p>Chainlink toy clustering data set</p></a></li>
<li><a href='#diffuse'><p>Compute diffusion map coordinates from pair-wise distances.</p></a></li>
<li><a href='#diffusionKmeans'><p>Diffusion K-means</p></a></li>
<li><a href='#distortionMin'><p>Distortion Minimization via K-means</p></a></li>
<li><a href='#epsilonCompute'><p>Compute default diffusion map epsilon.</p></a></li>
<li><a href='#nystrom'><p>Perform Nystrom Extension to estimate diffusion coordinates of data.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Diffusion Map</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements diffusion map method of data
    parametrization, including creation and visualization of
    diffusion map, clustering with diffusion K-means and
	  regression using adaptive regression model.
	  Richards (2009) &lt;<a href="https://doi.org/10.1088%2F0004-637X%2F691%2F1%2F32">doi:10.1088/0004-637X/691/1/32</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>scatterplot3d, graphics, igraph, Matrix, stats</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rcannood/diffusionMap">https://github.com/rcannood/diffusionMap</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-09-10 11:41:29 UTC; rcannood</td>
</tr>
<tr>
<td>Author:</td>
<td>Joseph Richards [aut] (joeyrichar),
  Robrecht Cannoodt <a href="https://orcid.org/0000-0003-3641-729X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre] (rcannood)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robrecht Cannoodt &lt;rcannood@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-09-10 22:50:18 UTC</td>
</tr>
</table>
<hr>
<h2 id='adapreg'>Adaptive Regression</h2><span id='topic+adapreg'></span>

<h3>Description</h3>

<p>Non-parametric adaptive regression method for diffusion map basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adapreg(D, y, mmax = min(50, length(y)), fold = NULL, nfolds = 10,
  nrep = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adapreg_+3A_d">D</code></td>
<td>
<p>n-by-n pairwise distance matrix for a data set with n points, or
alternatively output from the dist() function</p>
</td></tr>
<tr><td><code id="adapreg_+3A_y">y</code></td>
<td>
<p>vector of responses to model</p>
</td></tr>
<tr><td><code id="adapreg_+3A_mmax">mmax</code></td>
<td>
<p>maximum model size to consider</p>
</td></tr>
<tr><td><code id="adapreg_+3A_fold">fold</code></td>
<td>
<p>vector of integers of size n specifying the k-fold
cross-validation allocation.  Default does nfolds-fold CV by
sample(1:nfolds,length(y),replace=T)</p>
</td></tr>
<tr><td><code id="adapreg_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds to do CV.  If fold is supplied, nfolds is
ignored</p>
</td></tr>
<tr><td><code id="adapreg_+3A_nrep">nrep</code></td>
<td>
<p>number of times optimization algorithm is run (with random
initializations).  Higher nrep allows algorithm to avoid getting stuck in
local minima</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fits an adaptive regression model leaving as free parameters both the
diffusion map localness parameter, epsilon, and the size of the regression
model, m.  The adaptive regression model is the expansion of the response
function on the first m diffusion map basis functions.
</p>
<p>This routine searches for the optimal (epsilon,m) by minimizing the
cross-validation risk (CV MSE) of the regression estimate.  The function
uses <code><a href="stats.html#topic+optimize">optimize()</a></code> to search over an appropriate range of epsilon
and calls the function <code><a href="#topic+adapreg.m">adapreg.m()</a></code> to find the optimal m for
each epsilon.
</p>
<p>Default uses 10-fold cross-validation to choose the optimal model size.
User may also supply a vector of fold allocations.  For instance,
sample(1:10,length(y),replace=T) does 10-fold CV while 1:length(y) performs
leave-one-out CV.
</p>


<h3>Value</h3>

<p>The returned value is a list with components
</p>
<table>
<tr><td><code>mincvrisk</code></td>
<td>
<p>minimum cross-validation risk for the adaptive regression
model for the given epsilon</p>
</td></tr> <tr><td><code>mopt</code></td>
<td>
<p>size of the optimal regression
model.  If mopt == mmax, it is advised to increase mmax.</p>
</td></tr>
<tr><td><code>epsopt</code></td>
<td>
<p>optimal value of epsilon used in diffusion map construction</p>
</td></tr>
<tr><td><code>y.hat</code></td>
<td>
<p>predictions of the response, y-hat, for the optimal model</p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>coefficients of the optimal model</p>
</td></tr>
</table>


<h3>References</h3>

<p>Richards, J. W., Freeman, P. E., Lee, A. B., and Schafer, C. M., (2009), ApJ, 691, 32
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diffuse">diffuse()</a></code>,<code><a href="#topic+adapreg.m">adapreg.m()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(scatterplot3d)
## trig function on circle
t=seq(-pi,pi,.01)
x=cbind(cos(t),sin(t))
y = cos(3*t) + rnorm(length(t),0,.1)
tcol = topo.colors(32)
colvec = floor((y-min(y))/(max(y)-min(y))*32); colvec[colvec==0] = 1
scatterplot3d(x[,1],x[,2],y,color=tcol[colvec],pch=20,
  main="Cosine function supported on circle",angle=55,
  cex.main=2,col.axis="gray",cex.symbols=2,cex.lab=2,
  xlab=expression("x"[1]),ylab=expression("x"[2]),zlab="y")

D = as.matrix(dist(x))
# do 10-fold cross-validation to optimize (epsilon, m):
AR = adapreg(D,y, mmax=5,nfolds=2,nrep=2)
print(paste("optimal model size:",AR$mopt,"; optimal epsilon:",
  round(AR$epsopt,4),"; min. CV risk:",round(AR$mincvrisk,5)))
plot(y,AR$y.hat,ylab=expression(hat("y")),cex.lab=1.5,cex.main=1.5,
  main="Predictions")
abline(0,1,col=2,lwd=2)
</code></pre>

<hr>
<h2 id='adapreg.m'>Adaptive Regression</h2><span id='topic+adapreg.m'></span>

<h3>Description</h3>

<p>Non-parametric adaptive regression method for diffusion map basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adapreg.m(epsilon, D, y, mmax = min(50, length(y)), fold = NULL,
  nfolds = 10, objfun = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adapreg.m_+3A_epsilon">epsilon</code></td>
<td>
<p>diffusion map kernel parameter</p>
</td></tr>
<tr><td><code id="adapreg.m_+3A_d">D</code></td>
<td>
<p>n-by-n pairwise distance matrix for a data set with n points, or
alternatively output from the dist() function</p>
</td></tr>
<tr><td><code id="adapreg.m_+3A_y">y</code></td>
<td>
<p>vector of responses to model</p>
</td></tr>
<tr><td><code id="adapreg.m_+3A_mmax">mmax</code></td>
<td>
<p>maximum model size to consider</p>
</td></tr>
<tr><td><code id="adapreg.m_+3A_fold">fold</code></td>
<td>
<p>vector of integers of size n specifying the k-fold
cross-validation allocation.  Default does nfolds-fold CV by
sample(1:nfolds,length(y),replace=T)</p>
</td></tr>
<tr><td><code id="adapreg.m_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds to do CV.  If fold is supplied, nfolds is
ignored</p>
</td></tr>
<tr><td><code id="adapreg.m_+3A_objfun">objfun</code></td>
<td>
<p>if the function is to be passed into an optimization routine
(such as minimize()), then this needs to be set to TRUE, so that only the
minimal CV risk is returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fits an adaptive regression model using the estimated diffusion map
coordinates of a data set, while holding epsilon fixed and optimizing over
m.  The adaptive regression model is the expansion of the response function
on the first m diffusion map basis functions.
</p>
<p>For a given epsilon value, this routine finds the optimal m by minimizing
the cross-validation risk (CV MSE) of the regression estimate.  To optimize
over (epsilon,m), use the function <code><a href="#topic+adapreg">adapreg()</a></code>.
</p>
<p>Default uses 10-fold cross-validation to choose the optimal model size.
User may also supply a vector of fold allocations.  For instance,
sample(1:10,length(y),replace=T) does 10-fold CV while 1:length(y) does
leave-one-out CV.
</p>


<h3>Value</h3>

<p>The returned value is a list with components
</p>
<table>
<tr><td><code>mincvrisk</code></td>
<td>
<p>minimum cross-validation risk for the adaptive regression
model for the given epsilon</p>
</td></tr> <tr><td><code>mopt</code></td>
<td>
<p>size of the optimal regression
model.  If mopt equals mmax, it is advised to increase mmax.</p>
</td></tr>
<tr><td><code>cvrisk</code></td>
<td>
<p>vector of CV risk estimates for model sizes from 1:mmax</p>
</td></tr>
<tr><td><code>epsilon</code></td>
<td>
<p>value of epsilon used in diffusion map construction</p>
</td></tr>
<tr><td><code>y.hat</code></td>
<td>
<p>predictions of the response, y-hat, for the optimal model</p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>coefficients of the optimal model</p>
</td></tr>
</table>
<p>If objfun is set to TRUE, then the returned value is the minimum
cross-validation risk for the adaptive regression model for the given
epsilon.
</p>


<h3>References</h3>

<p>Richards, J. W., Freeman, P. E., Lee, A. B., and Schafer, C. M.,
(2009), ApJ, 691, 32
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diffuse">diffuse()</a></code>,<code><a href="#topic+adapreg">adapreg()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(stats)
library(scatterplot3d)
## trig function on circle
t=seq(-pi,pi,.01)
x=cbind(cos(t),sin(t))
y = cos(3*t) + rnorm(length(t),0,.1)
tcol = topo.colors(32)
colvec = floor((y-min(y))/(max(y)-min(y))*32); colvec[colvec==0] = 1
scatterplot3d(x[,1],x[,2],y,color=tcol[colvec],pch=20,
  main="Cosine function supported on circle",angle=55,
  cex.main=2,col.axis="gray",cex.symbols=2,cex.lab=2,
  xlab=expression("x"[1]),ylab=expression("x"[2]),zlab="y")

D = as.matrix(dist(x))
# leave-one-out cross-validation:
AR = adapreg.m(.01,D,y,fold=1:length(y))
print(paste("optimal model size:",AR$mopt,"; min. CV risk:",
  round(AR$mincvrisk,4)))
par(mfrow=c(2,1),mar=c(5,5,4,1))
plot(AR$cvrisks,typ='b',xlab="Model size",ylab="CV risk",
  cex.lab=1.5,cex.main=1.5,main="CV risk estimates")
plot(y,AR$y.hat,ylab=expression(hat("y")),cex.lab=1.5,cex.main=1.5,
  main="Predictions")
abline(0,1,col=2,lwd=2)

## swiss roll data
N=2000
t = (3*pi/2)*(1+2*runif(N));  height = runif(N);
X = cbind(t*cos(t), height, t*sin(t))
X = scale(X) + matrix(rnorm(N*3,0,0.05),N,3)
tcol = topo.colors(32)
colvec = floor((t-min(t))/(max(t)-min(t))*32); colvec[colvec==0] = 1
scatterplot3d(X,pch=18,color=tcol[colvec],xlab=expression("x"[1]),
  ylab=expression("x"[2]),zlab=expression("x"[3]),cex.lab=1.5,
  main="Swiss Roll, Noise = 0.05",cex.main=1.5,xlim=c(-2,2),
  ylim=c(-2,2),zlim=c(-2,2),col.axis="gray")

D = as.matrix(dist(X))
# 10-fold cross-validation:
AR = adapreg.m(.2,D,t,mmax=25,nfolds=5)
print(paste("optimal model size:",AR$mopt,"; min. CV risk:",
  round(AR$mincvrisk,4)))
par(mfrow=c(2,1),mar=c(5,5,4,1))
plot(AR$cvrisks,typ='b',xlab="Model size",ylab="CV risk",
  cex.lab=1.5,cex.main=1.5,main="CV risk estimates")
plot(t,AR$y.hat,ylab=expression(hat("t")),cex.lab=1.5,cex.main=1.5,
  main="Predictions")
abline(0,1,col=2,lwd=2)
</code></pre>

<hr>
<h2 id='annulus'>Annulus toy data set</h2><span id='topic+annulus'></span>

<h3>Description</h3>

<p>The annulus data frame has 1000 rows and 2 columns. 500 data points are
from the noisy annulus and 500 data points reside within the annulus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annulus
</code></pre>


<h3>Format</h3>

<p>Data are in two dimensions.</p>

<hr>
<h2 id='Chainlink'>Chainlink toy clustering data set</h2><span id='topic+Chainlink'></span>

<h3>Description</h3>

<p>The Chainlink data frame has 1000 rows and 3 columns.  The data are of two
interlocking 3-dimensional rings. 500 data points are from one ring and 500
from the other ring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Chainlink
</code></pre>


<h3>Format</h3>

<p>The data are in 3 dimensions, C1, C2, and C3.</p>


<h3>Source</h3>

<p><a href="http://www.uni-marburg.de/fb12/datenbionik/data?language_sync=1">http://www.uni-marburg.de/fb12/datenbionik/data?language_sync=1</a>
</p>


<h3>References</h3>

<p>Ultsch, A.: Clustering with SOM: U*C, In Proc. Workshop on
Self-Organizing Maps, Paris, France, (2005) , pp. 75-82
</p>

<hr>
<h2 id='diffuse'>Compute diffusion map coordinates from pair-wise distances.</h2><span id='topic+diffuse'></span>

<h3>Description</h3>

<p>Uses the pair-wise distance matrix for a data set to compute the diffusion
map coefficients.  Computes the Markov transition probability matrix, and
its eigenvalues and left &amp; right eigenvectors.  Returns a 'dmap' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffuse(D, eps.val = epsilonCompute(D), neigen = NULL, t = 0,
  maxdim = 50, delta = 10^-5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffuse_+3A_d">D</code></td>
<td>
<p>n-by-n pairwise distance matrix for a data set with n points, or
alternatively output from the dist() function</p>
</td></tr>
<tr><td><code id="diffuse_+3A_eps.val">eps.val</code></td>
<td>
<p>epsilon parameter for the diffusion weight matrix,
exp(-D$^2$/(eps.val)).  Default is to use the epsilon corresponding to the
median distance to the 0.01*n nearest neighbor</p>
</td></tr>
<tr><td><code id="diffuse_+3A_neigen">neigen</code></td>
<td>
<p>number of dimensions of final diffusion map representation.
Default uses number of dimensions corresponding to a 95% drop-off in
eigenvalue multiplier.</p>
</td></tr>
<tr><td><code id="diffuse_+3A_t">t</code></td>
<td>
<p>optional time-scale parameter in the diffusion map.  The
(recommended) default uses multiscale geometry.</p>
</td></tr>
<tr><td><code id="diffuse_+3A_maxdim">maxdim</code></td>
<td>
<p>the maximum number of diffusion map dimensions returned if
95% drop-off is not attained.</p>
</td></tr>
<tr><td><code id="diffuse_+3A_delta">delta</code></td>
<td>
<p>sparsity cut-off for the symmetric graph Laplacian.  Default of
10^-5 is used.  Higher value induces more sparsity in Laplacian (and faster
computations)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Diffusion map is a powerful tool for data parametrization that exploits the
natural geometry of a data set.  Diffusion map uses local interactions
between data points, propogated to larger scales, to construct a global
representation of the data.
</p>
<p>The parameter eps.val controls the degree of localness in the diffusion
weight matrix.  For most statisitical inference problems using diffusion
map, results should be optimized over eps.val.  Generally a good starting
point is to pick eps.val as $2*$med.knn$^2$, where med.knn is the median
distance to the kth nearest neighbor, and k is chosen 1-2% of n.  The
default uses 1% of n.
</p>
<p>Computation of the diffusion map coordinates requires singular value
decomposition of the normalized graph Laplacian.  This operation is
optimized for speed by exploiting the sparseness of the graph Laplacian and
by using ARPACK for fast matrix decomposition.  Increasing the sparseness
parameter, delta, will speed up the algorithm.
</p>


<h3>Value</h3>

<p>The returned value is an object of 'class' 'diffuse'.
</p>
<p>The function 'plot' is used to plot the diffusion coordinates in 1, 2, or 3
dimensions.  The function 'print' displays the computed eigen-multipliers
and the value of epsilon used.
</p>
<p>An object of class 'dmap' is a list containing the following components:
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>matrix of n diffusion map coordinates, entered column-wise (does
not include the trivial coordinate)</p>
</td></tr> <tr><td><code>phi0</code></td>
<td>
<p> trivial left eigenvector
of Markov matrix (stationary distribution of Markov random walk) in
diffusion map construction</p>
</td></tr> <tr><td><code>eigenvals</code></td>
<td>
<p>eigen-values of the svd of the
symmetric graph Laplacian</p>
</td></tr> <tr><td><code>eigenmult</code></td>
<td>
<p>eigen-multipliers of the
diffusion map</p>
</td></tr> <tr><td><code>psi</code></td>
<td>
<p>right eigenvectors of the Markov matrix (first row
is the trivial right eigenvector)</p>
</td></tr> <tr><td><code>phi</code></td>
<td>
<p>left eigenvectors of the
Markov matrix (first row is the trivial left eigenvector)</p>
</td></tr>
<tr><td><code>neigen</code></td>
<td>
<p>number of diffusion map dimensions used</p>
</td></tr> <tr><td><code>epsilon</code></td>
<td>
<p>the
value of epsilon used</p>
</td></tr>
</table>


<h3>References</h3>

<p>Coifman, R. R., &amp; Lafon, S., (2006), Appl. Comput. Harmon.
Anal., 21, 5
</p>
<p>Lafon, S., &amp; Lee, A., (2006), IEEE Trans. Pattern Anal. and Mach. Intel.,
28, 1393
</p>
<p>Richards, J. W., Freeman, P. E., Lee, A. B., Schafer, C. M., (2009), ApJ,
691, 32
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(stats)
## example with noisy spiral
n=2000
t=runif(n)^.7*10
al=.15;bet=.5;
x1=bet*exp(al*t)*cos(t)+rnorm(n,0,.1)
y1=bet*exp(al*t)*sin(t)+rnorm(n,0,.1)
plot(x1,y1,pch=20,main="Noisy spiral")
D = dist(cbind(x1,y1))
dmap = diffuse(D,neigen=10) # compute diffusion map
par(mfrow=c(2,1))
plot(t,dmap$X[,1],pch=20,axes=FALSE,xlab="spiral parameter",ylab="1st diffusion coefficient")
box()
plot(1:10,dmap$eigenmult,typ='h',xlab="diffusion map dimension",ylab="eigen-multipliers")

## example with annulus data set
data(annulus)
plot(annulus,main="Annulus Data",pch=20,cex=.7)
D = dist(annulus) # use Euclidean distance
dmap = diffuse(D,eps.val=.1) # compute diffusion map &amp; plot
print(dmap)
plot(dmap)
</code></pre>

<hr>
<h2 id='diffusionKmeans'>Diffusion K-means</h2><span id='topic+diffusionKmeans'></span>

<h3>Description</h3>

<p>Clusters a data set based on its diffusion coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffusionKmeans(dmap, K, params = c(), Niter = 10, epsilon = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffusionKmeans_+3A_dmap">dmap</code></td>
<td>
<p>a '&quot;dmap&quot;' object, computed by diffuse()</p>
</td></tr>
<tr><td><code id="diffusionKmeans_+3A_k">K</code></td>
<td>
<p>number of clusters</p>
</td></tr>
<tr><td><code id="diffusionKmeans_+3A_params">params</code></td>
<td>
<p>optional parameters for each data point.  Entry can be a
vector of length n, or a matrix with n rows. If this argument is given,
cluster centroid parameters are returned.</p>
</td></tr>
<tr><td><code id="diffusionKmeans_+3A_niter">Niter</code></td>
<td>
<p>number of K-means iterations performed.</p>
</td></tr>
<tr><td><code id="diffusionKmeans_+3A_epsilon">epsilon</code></td>
<td>
<p>stopping criterion for relative change in distortion for each
K-means iteration</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A '&quot;dmap&quot;' object computed by diffuse() is the input, so diffuse() must be
performed first.  Function is written this way so the K-means parameters may
be varied without having to recompute the diffusion map coordinates in each
run.
</p>
<p>Diffusion K-means is a special form of spectral clustering.  It is a unique
algorithm because the eigenvectors of the symmetric Laplacian are weighted
in such a way to guarantee that Euclidean distance in diffusion space will
be approximately equal to the diffusion distance between objects.
Clustering by Euclidean distance in diffusion space exploits this fact.
</p>


<h3>Value</h3>

<p>The returned value is a list with components
</p>
<table>
<tr><td><code>part</code></td>
<td>
<p>final labelling of data from K-means. n-dimensional vector with
integers between 1 and K</p>
</td></tr> <tr><td><code>cent</code></td>
<td>
<p> K geometric centroids found by
K-means</p>
</td></tr> <tr><td><code>D</code></td>
<td>
<p>minimum of total distortion (loss function of K-means)
found across K-means runs</p>
</td></tr> <tr><td><code>DK</code></td>
<td>
<p>n by k matrix of squared (Euclidean)
distances from each point to every centroid for the optimal K-means run</p>
</td></tr>
<tr><td><code>centparams</code></td>
<td>
<p>optional parameters for each centroid.  Only returned if
params is specified in the function call.  Is a matrix with k rows.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Lafon, S., &amp; Lee, A., (2006), IEEE Trans. Pattern Anal. and
Mach. Intel., 28, 1393
</p>
<p>Richards, J. W., Freeman, P. E., Lee, A. B., and Schafer, C. M., (2009),
ApJ, 691, 32
</p>
<p>Richards, J. W., Freeman, P. E., Lee, A. B., Schafer, C. M., (2009), MNRAS,
Volume 399, Issue 2, pp. 1044-1057
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diffuse">diffuse()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(scatterplot3d)

## example with annulus data set
data(annulus)
par(mfrow=c(2,1))
plot(annulus,main="Annulus Data",pch=20,cex=.7)
D = dist(annulus) # use Euclidean distance
dmap = diffuse(D,eps.val=0.05) # compute diffusion map
k=2  # number of clusters
dkmeans = diffusionKmeans(dmap, k)
plot(annulus,main="Colored by diffusion K-means clustering",pch=20,
   cex=.7,col=dkmeans$part)
table(dkmeans$part,c(rep(1,500),rep(2,500)))


## example with Chainlink data set
data(Chainlink)
lab.col = c(rep("red",500),rep("blue",500)); n=1000
scatterplot3d(Chainlink$C1,Chainlink$C2,Chainlink$C3,color=lab.col,
   main="Chainlink Data") # plot Chainlink data
D = dist(Chainlink) # use Euclidean distance
dmap = diffuse(D,neigen=3,eps.val=.01) # compute diffusion map &amp; plot
plot(dmap)
dkmeans = diffusionKmeans(dmap, K=2)
col.dkmeans=ifelse(dkmeans$part==1,"red","blue")
scatterplot3d(Chainlink,color=col.dkmeans,
   main="Chainlink Data, colored by diff. K-means class")
table(dkmeans$part,lab.col)
</code></pre>

<hr>
<h2 id='distortionMin'>Distortion Minimization via K-means</h2><span id='topic+distortionMin'></span>

<h3>Description</h3>

<p>Runs one K-means loop based on the diffusion coordinates of a data set,
beginning from an initial set of cluster centers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distortionMin(X, phi0, K, c0, epsilon = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distortionMin_+3A_x">X</code></td>
<td>
<p>diffusion coordinates, each row corresponds to a data point</p>
</td></tr>
<tr><td><code id="distortionMin_+3A_phi0">phi0</code></td>
<td>
<p>trivial left eigenvector of Markov matrix (stationary
distribution of Markov random walk) in diffusion map construction</p>
</td></tr>
<tr><td><code id="distortionMin_+3A_k">K</code></td>
<td>
<p>number of clusters</p>
</td></tr>
<tr><td><code id="distortionMin_+3A_c0">c0</code></td>
<td>
<p>initial cluster centers</p>
</td></tr>
<tr><td><code id="distortionMin_+3A_epsilon">epsilon</code></td>
<td>
<p>stopping criterion for relative change in distortion</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used by diffusionKmeans().
</p>


<h3>Value</h3>

<p>The returned value is a list with components
</p>
<table>
<tr><td><code>S</code></td>
<td>
<p> labelling from K-means loop. n-dimensional vector with integers
between 1 and K</p>
</td></tr> <tr><td><code>c</code></td>
<td>
<p> K geometric centroids found by K-means</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>minimum of total distortion (loss function of K-means) found in
K-means run</p>
</td></tr> <tr><td><code>DK</code></td>
<td>
<p>n by k matrix of squared (Euclidean) distances from
each point to every centroid</p>
</td></tr>
</table>


<h3>References</h3>

<p>Lafon, S., &amp; Lee, A., (2006), IEEE Trans. Pattern Anal. and
Mach. Intel., 28, 1393
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diffusionKmeans">diffusionKmeans()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(annulus)
n = dim(annulus)[1]
D = dist(annulus) # use Euclidean distance
dmap = diffuse(D,0.03) # compute diffusion map
km = distortionMin(dmap$X,dmap$phi0,2,dmap$X[sample(n,2),])
plot(annulus,col=km$S,pch=20)
table(km$S,c(rep(1,500),rep(2,500)))
</code></pre>

<hr>
<h2 id='epsilonCompute'>Compute default diffusion map epsilon.</h2><span id='topic+epsilonCompute'></span>

<h3>Description</h3>

<p>Uses the pair-wise distances to estimate a diffusion map epsilon value by
the median p*n-th nearest neighbor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epsilonCompute(D, p = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epsilonCompute_+3A_d">D</code></td>
<td>
<p>n-by-n pairwise distance matrix for a data set with n points, or
alternatively output from the dist() function</p>
</td></tr>
<tr><td><code id="epsilonCompute_+3A_p">p</code></td>
<td>
<p>distances to p*n-th nearest neighbor are used.  Default value is
.01</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function is used as the default value in diffuse().  For inference problems,
it is advised that the results be optimized over epsilon.
</p>


<h3>Value</h3>

<table>
<tr><td><code>epsilon</code></td>
<td>
<p>value of epsilon to be used in diffusion map</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+diffuse">diffuse()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(annulus)
D = dist(annulus) # use Euclidean distance
epsilonCompute(D,.005)
epsilonCompute(D,.01)
epsilonCompute(D,.05)
epsilonCompute(D,.1)
</code></pre>

<hr>
<h2 id='nystrom'>Perform Nystrom Extension to estimate diffusion coordinates of data.</h2><span id='topic+nystrom'></span>

<h3>Description</h3>

<p>Given the diffusion map coordinates of a training data set, estimates the
diffusion map coordinates of a new set of data using the pairwise distance
matrix from the new data to the original data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nystrom(dmap, Dnew, sigma = dmap$epsilon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nystrom_+3A_dmap">dmap</code></td>
<td>
<p>a '&quot;dmap&quot;' object from the original data set, computed by
diffuse()</p>
</td></tr>
<tr><td><code id="nystrom_+3A_dnew">Dnew</code></td>
<td>
<p>distance matrix between each new data point and every point in
the training data set.  Matrix is m-by-n, where m is the number of data
points in the new set and n is the number of training data points</p>
</td></tr>
<tr><td><code id="nystrom_+3A_sigma">sigma</code></td>
<td>
<p>scalar giving the size of the Nystrom extension kernel.
Default uses the tuning parameter of the original diffusion map</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Often, it is computationally infeasible to compute the exact diffusion map
coordinates for large data sets.  In this case, one may use the exact
diffusion coordinates of a training data set to extend to a new data set
using the Nystrom approximation.
</p>
<p>A Gaussian kernel is used: exp(-D(x,y)^2/sigma).  The default value of sigma
is the epsilon value used in the construction of the original diffusion map.
Other methods to select sigma, such as Algorithm 2 in Lafon, Keller, and
Coifman (2006) have been proposed.
</p>
<p>The dimensionality of the diffusion map representation of the new data set
will be the same as the dimensionality of the diffusion map constructed on
the original data.
</p>


<h3>Value</h3>

<p>The estimated diffusion coordinates for the new data, a matrix of
dimensions m by p, where p is the dimensionality of the input diffusion map
</p>


<h3>References</h3>

<p>Freeman, P. E., Newman, J. A., Lee, A. B., Richards, J. W., and
Schafer, C. M. (2009), MNRAS, Volume 398, Issue 4, pp. 2012-2021
</p>
<p>Lafon, S., Keller, Y., and Coifman, R. R. (2006), IEEE Trans. Pattern Anal.
and Mach. Intel., 28, 1784
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diffuse">diffuse()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(stats)
Norig = 1000
Next = 4000
t=runif(Norig+Next)^.7*10
al=.15;bet=.5;
x1=bet*exp(al*t)*cos(t)+rnorm(length(t),0,.1)
y1=bet*exp(al*t)*sin(t)+rnorm(length(t),0,.1)

D = as.matrix(dist(cbind(x1,y1)))
Dorig = D[1:Norig,1:Norig] # training distance matrix
DExt = D[(Norig+1):(Norig+Next),1:Norig] # new data distance matrix
# compute original diffusion map
dmap = diffuse(Dorig,neigen=2)
 # use Nystrom extension
dmapExt = nystrom(dmap,DExt)
plot(dmapExt[,1:2],pch=8,col=2,
  main="Diffusion map, black = original, red = new data",
  xlab="1st diffusion coefficient",ylab="2nd diffusion coefficient")
points(dmap$X[,1:2],pch=19,cex=.5)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
