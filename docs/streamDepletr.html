<!DOCTYPE html><html lang="en"><head><title>Help for package streamDepletr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {streamDepletr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#apportion_inverse'><p>Distribute streamflow depletion within a stream network using inverse distance weighting.</p></a></li>
<li><a href='#apportion_polygon'><p>Distribute streamflow depletion within a stream network using web distance Thiessen polygons.</p></a></li>
<li><a href='#apportion_web'><p>Distribute streamflow depletion within a stream network using web distance weighting.</p></a></li>
<li><a href='#apportion_wedge'><p>Distribute streamflow depletion between two streams in a wedge-shaped aquifer.</p></a></li>
<li><a href='#depletion_max_distance'><p>Calculate maximum distance at which streamflow depletion will exceed a user-selected threshold. Note that this only considers a single stream - depletion apportionment does not occur.</p></a></li>
<li><a href='#discharge_df'><p>Streamflow for Sixmile Creek and Dorn Creek.</p></a></li>
<li><a href='#glover'><p>Streamflow depletion with fully-penetrating stream and no streambed.</p></a></li>
<li><a href='#hantush'><p>Streamflow depletion in partially penetrating stream with semipervious streambed.</p></a></li>
<li><a href='#hunt'><p>Streamflow depletion in partially penetrating stream with semipervious streambed.</p></a></li>
<li><a href='#induce_infiltration_rate'><p>Calculate the pumping rate at which pumping will induce infiltration from stream.</p></a></li>
<li><a href='#induce_infiltration_time'><p>Calculate the critical time at which stream transitions from gaining to losing.</p></a></li>
<li><a href='#intermittent_pumping'><p>Streamflow depletion for an intermittent pumping schedule using superposition.</p></a></li>
<li><a href='#prep_reach_dist'><p>Calculate the distance from a well to each reach within a stream network. This function splits a polyline stream network up into a series of evenly spaced points and</p>
calculates the distance from each of those points to a well.</a></li>
<li><a href='#stream_lines'><p>Stream network for Sixmile Creek Watershed, Wisconsin, USA. Extracted from US NHDPlus v2.1 national seamless dataset.</p></a></li>
<li><a href='#streambed_conductance'><p>Estimate streambed conductance.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Estimate Streamflow Depletion Due to Groundwater Pumping</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of analytical models for estimating streamflow 
    depletion due to groundwater pumping, and other related tools. Functions
    are broadly split into two groups: (1) analytical streamflow depletion
    models, which estimate streamflow depletion for a single stream reach
    resulting from groundwater pumping; and (2) depletion apportionment 
    equations, which distribute estimated streamflow depletion among multiple
    stream reaches within a stream network. See Zipper et al. (2018) &lt;<a href="https://doi.org/10.1029%2F2018WR022707">doi:10.1029/2018WR022707</a>&gt;
    for more information on depletion apportionment equations and Zipper et
    al. (2019) &lt;<a href="https://doi.org/10.1029%2F2018WR024403">doi:10.1029/2018WR024403</a>&gt; for more information on analytical
    depletion functions, which combine analytical models and depletion apportionment
    equations.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sam Zipper &lt;samzipper@ku.edu&gt;</td>
</tr>
<tr>
<td>Copyright:</td>
<td>Foundry Spatial Ltd.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/FoundrySpatial/streamDepletr">https://github.com/FoundrySpatial/streamDepletr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/FoundrySpatial/streamDepletr/issues">https://github.com/FoundrySpatial/streamDepletr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rmpfr, dplyr, sf</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, ggplot2, tidyr, scales</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-19 18:36:29 UTC; s947z036</td>
</tr>
<tr>
<td>Author:</td>
<td>Sam Zipper <a href="https://orcid.org/0000-0002-8735-5757"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Ben Kerr [ctb],
  Tom Gleeson <a href="https://orcid.org/0000-0001-9493-7707"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Qiang Li <a href="https://orcid.org/0000-0003-2221-6905"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [rev],
  Foundry Spatial Ltd. [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-19 21:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='apportion_inverse'>Distribute streamflow depletion within a stream network using inverse distance weighting.</h2><span id='topic+apportion_inverse'></span>

<h3>Description</h3>

<p>Distribute streamflow depletion within a stream network using inverse distance weighting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apportion_inverse(
  reach_dist,
  w,
  max_dist = Inf,
  min_frac = 0,
  reach_name = NULL,
  dist_name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apportion_inverse_+3A_reach_dist">reach_dist</code></td>
<td>
<p>data frame with two columns: <code>reach</code>, which is a grouping variable with
the name of each stream reach, and <code>dist</code> which is the distance of that stream reach to
the well of interest. There can be more than one <code>dist</code> per <code>reach</code>; the function
will automatically find the minimum. Columns can either be named exactly as defined here, or
set using <code>reach_name</code> and <code>dist_name</code>.</p>
</td></tr>
<tr><td><code id="apportion_inverse_+3A_w">w</code></td>
<td>
<p>inverse distance weighting factor; 1 for inverse distance, 2 for inverse distance squared.</p>
</td></tr>
<tr><td><code id="apportion_inverse_+3A_max_dist">max_dist</code></td>
<td>
<p>the maximum distance of a stream to be depleted; defaults to <code>Inf</code>, which means all reaches will be considered.</p>
</td></tr>
<tr><td><code id="apportion_inverse_+3A_min_frac">min_frac</code></td>
<td>
<p>the minimum <code>frac_depletion</code> to be returned; defaults to <code>0</code>, which means all reaches will be considered.
If <code>min_frac &gt; 0</code> and some reaches have an estimated <code>frac_depletion &lt; min_frac</code>, depletion in those reaches will be set to 0
and that depletion will be reallocated based on the proportional depletion in the remaining reaches.</p>
</td></tr>
<tr><td><code id="apportion_inverse_+3A_reach_name">reach_name</code></td>
<td>
<p>The name of the column in <code>reach_dist</code> indicating your stream reach grouping variable. If set to <code>NULL</code> (default), it will assume that the column name is <code>reach</code>.</p>
</td></tr>
<tr><td><code id="apportion_inverse_+3A_dist_name">dist_name</code></td>
<td>
<p>The name of the column in <code>reach_dist</code> indicating your distance variable. If set to <code>NULL</code> (default), it will assume that the column name is <code>dist</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since analytical models assume the presence of 1 (or sometimes 2) linear streams, the <code>apportion_*</code> functions
can be used to distribute that depletion to various reaches within a real stream network. These geometric functions are described
in Zipper et al (2018), which found that <code>apportion_web</code> a weighting factor (<code>w</code>) of 2 produced the best results.
</p>


<h3>Value</h3>

<p>A data frame with two columns:
</p>

<dl>
<dt>reach</dt><dd><p>the grouping variable input in <code>reach_dist</code></p>
</dd>
<dt>frac_depletion</dt><dd><p>the proportion of streamflow depletion from the well occurring in that reach.</p>
</dd>
</dl>



<h3>References</h3>

<p>Zipper, SC, T Dallemagne, T Gleeson, TC Boerman, A Hartmann (2018). Groundwater Pumping Impacts
on Real Stream Networks: Testing the Performance of Simple Management Tools. Water Resources Research.
doi:10.1029/2018WR022707.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reach_dist &lt;- data.frame(reach = seq(1,5), dist = c(100, 150, 900, 300, 200))
apportion_inverse(reach_dist, w = 2)
apportion_inverse(reach_dist, w = 2, max_dist = 500)

reach_dist &lt;- data.frame(reach = c("A", "A", "A", "B", "B"), dist = c(100, 150, 900, 300, 200))
apportion_inverse(reach_dist, w = 1)
apportion_inverse(reach_dist, w = 1, max_dist = 500)
</code></pre>

<hr>
<h2 id='apportion_polygon'>Distribute streamflow depletion within a stream network using web distance Thiessen polygons.</h2><span id='topic+apportion_polygon'></span>

<h3>Description</h3>

<p>Distribute streamflow depletion within a stream network using web distance Thiessen polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apportion_polygon(
  reach_dist_lon_lat,
  wel_lon,
  wel_lat,
  coord_crs,
  max_dist = Inf,
  min_frac = 0,
  reach_name = NULL,
  dist_name = NULL,
  lon_name = NULL,
  lat_name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apportion_polygon_+3A_reach_dist_lon_lat">reach_dist_lon_lat</code></td>
<td>
<p>data frame with four columns: <code>reach</code>, which is a grouping variable with
the name of each stream reach; <code>dist</code> which is the distance of a point on that stream reach to
the well of interest; <code>lon</code> which is the longitude of that point on the stream; and
<code>lat</code> which is the latitude of that point on the stream. There can (and likely will) be multiple rows per <code>reach</code>.
Columns can either be named exactly as defined here, or set using <code>reach_name</code>, <code>dist_name</code>, <code>lon_name</code>, and <code>lat_name</code>.</p>
</td></tr>
<tr><td><code id="apportion_polygon_+3A_wel_lon">wel_lon</code></td>
<td>
<p>longitude of well</p>
</td></tr>
<tr><td><code id="apportion_polygon_+3A_wel_lat">wel_lat</code></td>
<td>
<p>latitude of well</p>
</td></tr>
<tr><td><code id="apportion_polygon_+3A_coord_crs">coord_crs</code></td>
<td>
<p>coordinate reference system for sf or sfc object (create with <code>sf::st_crs</code>).</p>
</td></tr>
<tr><td><code id="apportion_polygon_+3A_max_dist">max_dist</code></td>
<td>
<p>the maximum distance of a stream to be depleted; defaults to <code>Inf</code>, which means all reaches will be considered.</p>
</td></tr>
<tr><td><code id="apportion_polygon_+3A_min_frac">min_frac</code></td>
<td>
<p>the minimum <code>frac_depletion</code> to be returned; defaults to <code>0</code>, which means all reaches will be considered.
If <code>min_frac &gt; 0</code> and some reaches have an estimated <code>frac_depletion &lt; min_frac</code>, depletion in those reaches will be set to 0
and that depletion will be reallocated based on the proportional depletion in the remaining reaches.</p>
</td></tr>
<tr><td><code id="apportion_polygon_+3A_reach_name">reach_name</code></td>
<td>
<p>The name of the column in <code>reach_dist</code> indicating your stream reach grouping variable. If set to <code>NULL</code> (default), it will assume that the column name is <code>reach</code>.</p>
</td></tr>
<tr><td><code id="apportion_polygon_+3A_dist_name">dist_name</code></td>
<td>
<p>The name of the column in <code>reach_dist</code> indicating your distance variable. If set to <code>NULL</code> (default), it will assume that the column name is <code>dist</code>.</p>
</td></tr>
<tr><td><code id="apportion_polygon_+3A_lon_name">lon_name</code></td>
<td>
<p>The name of the column in <code>reach_dist</code> indicating your longitude variable. If set to <code>NULL</code> (default), it will assume that the column name is <code>lon</code>.</p>
</td></tr>
<tr><td><code id="apportion_polygon_+3A_lat_name">lat_name</code></td>
<td>
<p>The name of the column in <code>reach_dist</code> indicating your latitude variable. If set to <code>NULL</code> (default), it will assume that the column name is <code>lat</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since analytical models assume the presence of 1 (or sometimes 2) linear streams, the <code>apportion_*</code> functions
can be used to distribute that depletion to various reaches within a real stream network. These geometric functions are described
in Zipper et al (2018), which found that <code>apportion_web</code> a weighting factor (<code>w</code>) of 2 produced the best results.
</p>


<h3>Value</h3>

<p>A data frame with two columns:
</p>

<dl>
<dt>reach</dt><dd><p>the grouping variable input in <code>reach_dist</code></p>
</dd>
<dt>frac_depletion</dt><dd><p>the proportion of streamflow depletion from the well occurring in that reach.</p>
</dd>
</dl>



<h3>References</h3>

<p>Zipper, SC, T Dallemagne, T Gleeson, TC Boerman, A Hartmann (2018). Groundwater Pumping Impacts
on Real Stream Networks: Testing the Performance of Simple Management Tools. Water Resources Research.
doi:10.1029/2018WR022707.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rdll &lt;- prep_reach_dist(wel_lon = 295500, wel_lat = 4783200,
   stream_sf = stream_lines, reach_id = "reach", stream_pt_spacing = 5)
apportion_polygon(reach_dist_lon_lat = rdll, wel_lon = 295500, wel_lat = 4783200,
   max_dist = 5000, coord_crs = sf::st_crs(stream_lines))
apportion_polygon(reach_dist_lon_lat = rdll, wel_lon = 295500, wel_lat = 4783200,
   max_dist = 5000, min_frac = 0.05, coord_crs = sf::st_crs(stream_lines))
</code></pre>

<hr>
<h2 id='apportion_web'>Distribute streamflow depletion within a stream network using web distance weighting.</h2><span id='topic+apportion_web'></span>

<h3>Description</h3>

<p>Distribute streamflow depletion within a stream network using web distance weighting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apportion_web(
  reach_dist,
  w,
  max_dist = Inf,
  min_frac = 0,
  reach_name = NULL,
  dist_name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apportion_web_+3A_reach_dist">reach_dist</code></td>
<td>
<p>data frame with two columns: <code>reach</code>, which is a grouping variable with
the name of each stream reach, and <code>dist</code> which is the distance of a point on that stream reach to
the well of interest. There can (and likely will) be more than one <code>dist</code> per <code>reach</code>;
if there is only one dist per reach, results will be the same as the <a href="#topic+apportion_inverse">apportion_inverse</a> method.
Columns can either be named exactly as defined here, or set using <code>reach_name</code> and <code>dist_name</code>.</p>
</td></tr>
<tr><td><code id="apportion_web_+3A_w">w</code></td>
<td>
<p>weighting factor; 1 for web, 2 for web squared.</p>
</td></tr>
<tr><td><code id="apportion_web_+3A_max_dist">max_dist</code></td>
<td>
<p>the maximum distance of a stream to be depleted; defaults to <code>Inf</code>, which means all reaches will be considered.</p>
</td></tr>
<tr><td><code id="apportion_web_+3A_min_frac">min_frac</code></td>
<td>
<p>the minimum <code>frac_depletion</code> to be returned; defaults to <code>0</code>, which means all reaches will be considered.
If <code>min_frac &gt; 0</code> and some reaches have an estimated <code>frac_depletion &lt; min_frac</code>, depletion in those reaches will be set to 0
and that depletion will be reallocated based on the proportional depletion in the remaining reaches.</p>
</td></tr>
<tr><td><code id="apportion_web_+3A_reach_name">reach_name</code></td>
<td>
<p>The name of the column in <code>reach_dist</code> indicating your stream reach grouping variable. If set to <code>NULL</code> (default), it will assume that the column name is <code>reach</code>.</p>
</td></tr>
<tr><td><code id="apportion_web_+3A_dist_name">dist_name</code></td>
<td>
<p>The name of the column in <code>reach_dist</code> indicating your distance variable. If set to <code>NULL</code> (default), it will assume that the column name is <code>dist</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since analytical models assume the presence of 1 (or sometimes 2) linear streams, the <code>apportion_*</code> functions
can be used to distribute that depletion to various reaches within a real stream network. These geometric functions are described
in Zipper et al (2018), which found that <code>apportion_web</code> a weighting factor (<code>w</code>) of 2 produced the best results.
</p>


<h3>Value</h3>

<p>A data frame with two columns:
</p>

<dl>
<dt>reach</dt><dd><p>the grouping variable input in <code>reach_dist</code></p>
</dd>
<dt>frac_depletion</dt><dd><p>the proportion of streamflow depletion from the well occurring in that reach.</p>
</dd>
</dl>



<h3>References</h3>

<p>Zipper, SC, T Dallemagne, T Gleeson, TC Boerman, A Hartmann (2018). Groundwater Pumping Impacts
on Real Stream Networks: Testing the Performance of Simple Management Tools. Water Resources Research.
doi:10.1029/2018WR022707.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reach_dist &lt;- data.frame(reach = seq(1,5),
  dist = c(100, 150, 900, 300, 200))
apportion_web(reach_dist, w = 2)  # same as inverse because there's only one dist per reach
apportion_web(reach_dist, w = 2, max_dist = 500)

reach_dist &lt;- data.frame(reach = c("A", "A", "A", "B", "B"),
  dist = c(100, 150, 900, 300, 200))
apportion_web(reach_dist, w = 1)
apportion_web(reach_dist, w = 1, max_dist = 500)
</code></pre>

<hr>
<h2 id='apportion_wedge'>Distribute streamflow depletion between two streams in a wedge-shaped aquifer.</h2><span id='topic+apportion_wedge'></span>

<h3>Description</h3>

<p>Distribute streamflow depletion between two streams in a wedge-shaped aquifer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apportion_wedge(angle_total, angle_well)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apportion_wedge_+3A_angle_total">angle_total</code></td>
<td>
<p>angle [radians] between the two streams.</p>
</td></tr>
<tr><td><code id="apportion_wedge_+3A_angle_well">angle_well</code></td>
<td>
<p>angle [radians] from the first (lower boundary) stream and the well.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes that streams are two linear tributaries which meet at the origin. This function
specifically corresponds to Equations 18 and 19 in Yeh et al. (2008).
</p>


<h3>Value</h3>

<p>A numeric of length two with the proportion of steady-state
capture fraction from the first (lower) and second (upper) streams.
</p>


<h3>References</h3>

<p>Yeh, HD, YC Chang, VA Zlotnik (2008). Stream depletion rate and volume from groundwater pumping in
wedge-shaped aquifers. Journal of Hydrology 349(3): 501-511. doi:10.1029/2018WR022707.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>apportion_wedge(angle_total = (50*pi/2), angle_well = (10*pi/2))

apportion_wedge(angle_total = (50*pi/2), angle_well = (25*pi/2))
</code></pre>

<hr>
<h2 id='depletion_max_distance'>Calculate maximum distance at which streamflow depletion will exceed a user-selected threshold. Note that this only considers a single stream - depletion apportionment does not occur.</h2><span id='topic+depletion_max_distance'></span>

<h3>Description</h3>

<p>Calculate maximum distance at which streamflow depletion will exceed a user-selected threshold. Note that this only considers a single stream - depletion apportionment does not occur.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depletion_max_distance(
  Qf_thres = 0.01,
  d_interval = 100,
  d_min = NULL,
  d_max = 5000,
  method = "glover",
  t,
  S,
  Tr,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="depletion_max_distance_+3A_qf_thres">Qf_thres</code></td>
<td>
<p>streamflow depletion fraction (<code>Qf</code>) threshold used to define maximum distance. Defaults to 0.01 (1%).</p>
</td></tr>
<tr><td><code id="depletion_max_distance_+3A_d_interval">d_interval</code></td>
<td>
<p>interval to use for testing; this defines the spatial resolution at which output will be returned [L]</p>
</td></tr>
<tr><td><code id="depletion_max_distance_+3A_d_min">d_min</code></td>
<td>
<p>minimum search distance [L]. If 'Qf' &lt; 'Qf_thres' at 'd_min', function will return 'd_min' and a warning.
If &lsquo;d_min'=NULL (default), 'd_min' will be set to 'd_interval&rsquo;'</p>
</td></tr>
<tr><td><code id="depletion_max_distance_+3A_d_max">d_max</code></td>
<td>
<p>maximum search distance [L]. If 'Qf' &gt; 'Qf_thres' at 'd_max', function will return 'd_max' and a warning.</p>
</td></tr>
<tr><td><code id="depletion_max_distance_+3A_method">method</code></td>
<td>
<p>analytical solution to use (options= 'glover', 'hunt'). Defaults to 'glover'.</p>
</td></tr>
<tr><td><code id="depletion_max_distance_+3A_t">t</code></td>
<td>
<p>time you want output for [T]</p>
</td></tr>
<tr><td><code id="depletion_max_distance_+3A_s">S</code></td>
<td>
<p>aquifer storage coefficient (specific yield if unconfined; storativity if confined)</p>
</td></tr>
<tr><td><code id="depletion_max_distance_+3A_tr">Tr</code></td>
<td>
<p>aquifer transmissivity [L2/T]</p>
</td></tr>
<tr><td><code id="depletion_max_distance_+3A_...">...</code></td>
<td>
<p>any other inputs required for your <code>method</code> of choice; for example, <code>hunt</code> needs <code>lmda</code> (streambed conductance)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful for the 'Expanding' stream proximity criteria described in Zipper et al. (2018).
</p>


<h3>Value</h3>

<p>A numeric of the distance at which streamflow depletion fraction (<code>Qf</code>) drops below the threshold at time 't'.
</p>


<h3>References</h3>

<p>Zipper, SC, T Gleeson, B Kerr, JK Howard, MM Rohde, J Carah, J Zimmerman (2018). Rapid and accurate estimates
of streamflow depletion caused by groundwater pumping using analytical depletion functions. EarthArXiv.
doi:10.31223/osf.io/uqbd7.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>depletion_max_distance(method = "glover", t = 730, S = 0.1, Tr = 100)
depletion_max_distance(Qf_thres = 0.001, method = "glover", t = 730, S = 0.1, Tr = 100)
depletion_max_distance(Qf_thres = 0.001, method = "hunt", t = 730, S = 0.1, Tr = 100, lmda = 0.01)
depletion_max_distance(Qf_thres = 0.001, method = "hunt", t = 7300, S = 0.1, Tr = 100, lmda = 0.01)
</code></pre>

<hr>
<h2 id='discharge_df'>Streamflow for Sixmile Creek and Dorn Creek.</h2><span id='topic+discharge_df'></span>

<h3>Description</h3>

<p>Daily discharge data for the 2014-2015 water years for the US Geological Survey
gauging stations DORN (SPRING) CREEK AT CT HIGHWAY M NR WAUNAKEE,WI (station ID 05427930)
and SIXMILE CREEK @ COUNTY TRNK HGHWY M NR WAUNAKEE,WI (station ID 05427910).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discharge_df
</code></pre>


<h3>Format</h3>

<p>A data frame with 1450 rows and 2 variables:
</p>

<dl>
<dt>date</dt><dd><p>date of streamflow measurement</p>
</dd>
<dt>Q_m3d</dt><dd><p>discharge, in cubic meters per day</p>
</dd>
<dt>stream</dt><dd><p>name of stream for each stream reach (Sixmile Creek or Dorn Creek)</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p><a href="https://waterdata.usgs.gov/nwis/dv?referred_module=sw&amp;agency_code=USGS&amp;site_no=05427910">https://waterdata.usgs.gov/nwis/dv?referred_module=sw&amp;agency_code=USGS&amp;site_no=05427910</a>
</p>
<p><a href="https://waterdata.usgs.gov/nwis/dv?referred_module=sw&amp;agency_code=USGS&amp;site_no=05427930">https://waterdata.usgs.gov/nwis/dv?referred_module=sw&amp;agency_code=USGS&amp;site_no=05427930</a>
</p>

<hr>
<h2 id='glover'>Streamflow depletion with fully-penetrating stream and no streambed.</h2><span id='topic+glover'></span>

<h3>Description</h3>

<p>Streamflow depletion with fully-penetrating stream and no streambed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glover(t, d, S, Tr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glover_+3A_t">t</code></td>
<td>
<p>times you want output for [T]</p>
</td></tr>
<tr><td><code id="glover_+3A_d">d</code></td>
<td>
<p>distance from well to stream [L]</p>
</td></tr>
<tr><td><code id="glover_+3A_s">S</code></td>
<td>
<p>aquifer storage coefficient (specific yield if unconfined; storativity if confined)</p>
</td></tr>
<tr><td><code id="glover_+3A_tr">Tr</code></td>
<td>
<p>aquifer transmissivity [L2/T]</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is described in Glover &amp; Balmer (1954) based on work by Theis (1941). It contains numerous assumptions:
</p>

<ul>
<li><p> Horizontal flow &gt;&gt; vertical flow (Dupuit assumptions hold)
</p>
</li>
<li><p> Homogeneous, isotropic aquifer
</p>
</li>
<li><p> Constant <code>Tr</code>: Aquifer is confined, or if unconfined change in head is small relative to aquifer thickness
</p>
</li>
<li><p> Stream is straight, infinitely long, and remains in hydraulic connection to aquifer
</p>
</li>
<li><p> Constant stream stage
</p>
</li>
<li><p> No changes in recharge due to pumping
</p>
</li>
<li><p> No streambank storage
</p>
</li>
<li><p> Constant pumping rate
</p>
</li>
<li><p> Aquifer extends to infinity
</p>
</li>
<li><p> Stream fully penetrates through aquifer (see <a href="#topic+hunt">hunt</a> or <a href="#topic+hantush">hantush</a> for partially penetrating stream)
</p>
</li>
<li><p> No streambed resistance to flow (see <a href="#topic+hunt">hunt</a> or <a href="#topic+hantush">hantush</a> for streambed resistance)
</p>
</li></ul>



<h3>Value</h3>

<p>A numeric of <code>Qf</code>, streamflow depletion as fraction of pumping rate [-].
If the pumping rate of the well (<code>Qw</code>; [L3/T]) is known, you can calculate volumetric streamflow depletion [L3/T] as <code>Qf*Qw</code>
</p>


<h3>References</h3>

<p>Glover, RE, and GG Balmer (1954).River Depletion Resulting from Pumping a Well near a River.
Eos, Transactions American Geophysical Union 35(3): 468-70. doi:10.1029/TR035i003p00468.
</p>
<p>Theis, CV (1941). The Effect of a Well on the Flow of a Nearby Stream.
Eos, Transactions American Geophysical Union 22(3): 734-38. https://doi.org/10.1029/TR022i003p00734.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>glover(t = 1.5777e8, d = 1000, S = 0.2, Tr = 0.1)   # Glover &amp; Balmer (1954) Table 1, Well 1
glover(t = 1.5777e8, d = 5000, S = 0.2, Tr = 0.1)   # Glover &amp; Balmer (1954) Table 1, Well 2
glover(t = 1.5777e8, d = 10000, S = 0.2, Tr = 0.1)  # Glover &amp; Balmer (1954) Table 1, Well 3
</code></pre>

<hr>
<h2 id='hantush'>Streamflow depletion in partially penetrating stream with semipervious streambed.</h2><span id='topic+hantush'></span>

<h3>Description</h3>

<p>Streamflow depletion in partially penetrating stream with semipervious streambed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hantush(t, d, S, Kh, b, Kriv, briv, prec = 80)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hantush_+3A_t">t</code></td>
<td>
<p>times you want output for [T]</p>
</td></tr>
<tr><td><code id="hantush_+3A_d">d</code></td>
<td>
<p>distance from well to stream [L]</p>
</td></tr>
<tr><td><code id="hantush_+3A_s">S</code></td>
<td>
<p>aquifer storage coefficient (specific yield if unconfined; storativity if confined)</p>
</td></tr>
<tr><td><code id="hantush_+3A_kh">Kh</code></td>
<td>
<p>aquifer horizontal hydraulic conductivity [L/T]</p>
</td></tr>
<tr><td><code id="hantush_+3A_b">b</code></td>
<td>
<p>aquifer saturated thickness [L]</p>
</td></tr>
<tr><td><code id="hantush_+3A_kriv">Kriv</code></td>
<td>
<p>streambed semipervious layer hydraulic conductivity [L/T]</p>
</td></tr>
<tr><td><code id="hantush_+3A_briv">briv</code></td>
<td>
<p>streambed semipervious layer thickness [L]</p>
</td></tr>
<tr><td><code id="hantush_+3A_prec">prec</code></td>
<td>
<p>precision for <code>Rmpfr</code> package for storing huge numbers; 80 seems to generally work but tweak this if you get weird results. Reducing this value will reduce accuracy but speed up computation time. If set to 'NULL', the 'mpfr' function is not used which can address an occasional issue on Mac computers but lead to problems under some combinations of 'Tr' and 'lmda'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is described in Hantush (1965). As the leakance term <code>(b*Kh/Kriv)</code> approaches 0 this is equivalent to <a href="#topic+glover">glover</a>. It contains numerous assumptions:
</p>

<ul>
<li><p> Horizontal flow &gt;&gt; vertical flow (Dupuit assumptions hold)
</p>
</li>
<li><p> Homogeneous, isotropic aquifer
</p>
</li>
<li><p> Constant <code>Tr</code>: Aquifer is confined, or if unconfined change in head is small relative to aquifer thickness
</p>
</li>
<li><p> Stream is straight, infinitely long, and remains in hydraulic connection to aquifer
</p>
</li>
<li><p> Constant stream stage
</p>
</li>
<li><p> No changes in recharge due to pumping
</p>
</li>
<li><p> No streambank storage
</p>
</li>
<li><p> Constant pumping rate
</p>
</li>
<li><p> Aquifer extends to infinity
</p>
</li></ul>



<h3>Value</h3>

<p>A numeric of <code>Qf</code>, streamflow depletion as fraction of pumping rate [-].
If the pumping rate of the well (<code>Qw</code>; [L3/T]) is known, you can calculate volumetric streamflow depletion [L3/T] as <code>Qf*Qw</code>
</p>


<h3>References</h3>

<p>Hantush, MS (1965). Wells near Streams with Semipervious Beds. Journal of Geophysical Research 70(12): 2829-38. doi:10.1029/JZ070i012p02829.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hantush(t = 1826, d = 1000, S = 0.2, Kh = 86.4, b = 100, Kriv = 0.0864, briv = 1)

Qf &lt;- hantush(t = seq(1, 1826), d = 1000, S = 0.2, Kh = 86.4, b = 100, Kriv = 0.0864, briv = 1)
plot(x = seq(1, 1826), y = Qf, type = "l")
</code></pre>

<hr>
<h2 id='hunt'>Streamflow depletion in partially penetrating stream with semipervious streambed.</h2><span id='topic+hunt'></span>

<h3>Description</h3>

<p>Streamflow depletion in partially penetrating stream with semipervious streambed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hunt(t, d, S, Tr, lmda, lmda_max = Inf, prec = 80)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hunt_+3A_t">t</code></td>
<td>
<p>times you want output for [T]</p>
</td></tr>
<tr><td><code id="hunt_+3A_d">d</code></td>
<td>
<p>distance from well to stream [L]</p>
</td></tr>
<tr><td><code id="hunt_+3A_s">S</code></td>
<td>
<p>aquifer storage coefficient (specific yield if unconfined; storativity if confined)</p>
</td></tr>
<tr><td><code id="hunt_+3A_tr">Tr</code></td>
<td>
<p>aquifer transmissivity [L2/T]</p>
</td></tr>
<tr><td><code id="hunt_+3A_lmda">lmda</code></td>
<td>
<p>streambed conductance term, lambda [L/T]. Can be estimated with <code>streambed_conductance</code>.</p>
</td></tr>
<tr><td><code id="hunt_+3A_lmda_max">lmda_max</code></td>
<td>
<p>maximum allowed 'lmda' [L/T]. If 'lmda' is too high, exp and erfc calculations in Hunt solution are not computationally possible, so you may need to artifically reduce 'lmda' using this term.</p>
</td></tr>
<tr><td><code id="hunt_+3A_prec">prec</code></td>
<td>
<p>precision for <code>Rmpfr</code> package for storing huge numbers; 80 seems to generally work but tweak this if you get weird results. Reducing this value will reduce accuracy but speed up computation time. If set to 'NULL', the 'mpfr' function is not used which can address an occasional issue on Mac computers but lead to problems under some combinations of 'Tr' and 'lmda'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is described in Hunt (1999). When <code>lmda</code> term gets very large, this is equivalent to <a href="#topic+glover">glover</a>. It contains numerous assumptions:
</p>

<ul>
<li><p> Horizontal flow &gt;&gt; vertical flow (Dupuit assumptions hold)
</p>
</li>
<li><p> Homogeneous, isotropic aquifer
</p>
</li>
<li><p> Constant <code>Tr</code>: Aquifer is confined, or if unconfined change in head is small relative to aquifer thickness
</p>
</li>
<li><p> Stream is straight, infinitely long, and remains in hydraulic connection to aquifer
</p>
</li>
<li><p> Constant stream stage
</p>
</li>
<li><p> No changes in recharge due to pumping
</p>
</li>
<li><p> No streambank storage
</p>
</li>
<li><p> Constant pumping rate
</p>
</li>
<li><p> Aquifer extends to infinity
</p>
</li></ul>



<h3>Value</h3>

<p>A numeric of <code>Qf</code>, streamflow depletion as fraction of pumping rate [-].
If the pumping rate of the well (<code>Qw</code>; [L3/T]) is known, you can calculate volumetric streamflow depletion [L3/T] as <code>Qf*Qw</code>
</p>


<h3>References</h3>

<p>Hunt, B (1999). Unsteady Stream Depletion from Ground Water Pumping.
Ground Water 37 (1): 98-102. doi:10.1111/j.1745-6584.1999.tb00962.x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hunt(t = 1826, d = 1000, S = 0.2, Tr = 8640, lmda = 864)    # ~equal to glover because lmda=Tr
hunt(t = 1826, d = 1000, S = 0.2, Tr = 8640, lmda = 0.864)  # less depletion due to lower lmda

lmda &lt;- streambed_conductance(w = 10, Kriv = 0.0864, briv = 1) # estimate lmda
hunt(t = 1826, d = 1000, S = 0.2, Tr = 8640, lmda = lmda)

Qf &lt;- hunt(t = seq(1, 1826), d = 1000, S = 0.2, Tr = 8640, lmda = 0.864)
plot(x = seq(1, 1826), y = Qf, type = "l")
</code></pre>

<hr>
<h2 id='induce_infiltration_rate'>Calculate the pumping rate at which pumping will induce infiltration from stream.</h2><span id='topic+induce_infiltration_rate'></span>

<h3>Description</h3>

<p>Calculate the pumping rate at which pumping will induce infiltration from stream.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>induce_infiltration_rate(d, Qa)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="induce_infiltration_rate_+3A_d">d</code></td>
<td>
<p>distance from well to stream [L]</p>
</td></tr>
<tr><td><code id="induce_infiltration_rate_+3A_qa">Qa</code></td>
<td>
<p>ambient groundwater inflow rate per unit length of stream [L2/T]</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This calculates the critical pumping rate above which induced infiltration due to groundwater pumping will occur,
based on the <a href="#topic+glover">glover</a> model of streamflow depletion. Derived in Wilson (1993) Eq. 5.
</p>
<p>Assumptions:
</p>

<ul>
<li><p> Groundwater flow is perpendicular to stream
</p>
</li>
<li><p> Horizontal flow &gt;&gt; vertical flow (Dupuit assumptions hold)
</p>
</li>
<li><p> Homogeneous, isotropic aquifer
</p>
</li>
<li><p> Constant <code>Tr</code>: Aquifer is confined, or if unconfined change in head is small relative to aquifer thickness
</p>
</li>
<li><p> Stream is straight, infinitely long, and remains in hydraulic connection to aquifer
</p>
</li>
<li><p> Constant stream stage
</p>
</li>
<li><p> No changes in recharge due to pumping
</p>
</li>
<li><p> No streambank storage
</p>
</li>
<li><p> Constant pumping rate
</p>
</li>
<li><p> Aquifer extends to infinity
</p>
</li>
<li><p> Stream fully penetrates through aquifer
</p>
</li>
<li><p> No streambed resistance to flow (see <a href="#topic+hunt">hunt</a> or <a href="#topic+hantush">hantush</a> for streambed resistance)
</p>
</li></ul>



<h3>Value</h3>

<p>A numeric of <code>Qc</code>, critical pumping rate above which induced infiltration due to groundwater pumping will occur [L3/T].
</p>


<h3>References</h3>

<p>Wilson, JL (1993). Induced Infiltration in Aquifers with Ambient Flow. Water Resources Research
29(10): 3503-12. doi:10.1029/93WR01393.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>induce_infiltration_rate(d = 100, Qa = 10)
induce_infiltration_rate(d = 100, Qa = 50)
induce_infiltration_rate(d = 500, Qa = 50)
</code></pre>

<hr>
<h2 id='induce_infiltration_time'>Calculate the critical time at which stream transitions from gaining to losing.</h2><span id='topic+induce_infiltration_time'></span>

<h3>Description</h3>

<p>Calculate the critical time at which stream transitions from gaining to losing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>induce_infiltration_time(d, S, Tr, Qa, Qw)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="induce_infiltration_time_+3A_d">d</code></td>
<td>
<p>distance from well to stream [L]</p>
</td></tr>
<tr><td><code id="induce_infiltration_time_+3A_s">S</code></td>
<td>
<p>aquifer storage coefficient (specific yield if unconfined; storativity if confined)</p>
</td></tr>
<tr><td><code id="induce_infiltration_time_+3A_tr">Tr</code></td>
<td>
<p>aquifer transmissivity [L2/T]</p>
</td></tr>
<tr><td><code id="induce_infiltration_time_+3A_qa">Qa</code></td>
<td>
<p>ambient groundwater inflow rate per unit length of stream [L2/T]</p>
</td></tr>
<tr><td><code id="induce_infiltration_time_+3A_qw">Qw</code></td>
<td>
<p>well pumping rate [L3/T]</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This calculates the critical time at which induced infiltration due to groundwater pumping begins,
based on the <a href="#topic+glover">glover</a> model of streamflow depletion. Derived in Chen (2003) Eq. 4.
</p>
<p>Assumptions:
</p>

<ul>
<li><p> Groundwater flow is perpendicular to stream
</p>
</li>
<li><p> Horizontal flow &gt;&gt; vertical flow (Dupuit assumptions hold)
</p>
</li>
<li><p> Homogeneous, isotropic aquifer
</p>
</li>
<li><p> Constant <code>Tr</code>: Aquifer is confined, or if unconfined change in head is small relative to aquifer thickness
</p>
</li>
<li><p> Stream is straight, infinitely long, and remains in hydraulic connection to aquifer
</p>
</li>
<li><p> Constant stream stage
</p>
</li>
<li><p> No changes in recharge due to pumping
</p>
</li>
<li><p> No streambank storage
</p>
</li>
<li><p> Constant pumping rate
</p>
</li>
<li><p> Aquifer extends to infinity
</p>
</li>
<li><p> Stream fully penetrates through aquifer
</p>
</li>
<li><p> No streambed resistance to flow (see <a href="#topic+hunt">hunt</a> or <a href="#topic+hantush">hantush</a> for streambed resistance)
</p>
</li></ul>



<h3>Value</h3>

<p>A numeric of <code>tc</code>, the critical time at which induced infiltration begins [T].
</p>


<h3>References</h3>

<p>Chen, X (2003). Analysis of Pumping-Induced Stream-Aquifer Interactions for Gaining Streams.
Journal of Hydrology 275(1): 1-11. doi:10.1016/S0022-1694(02)00320-7
</p>


<h3>Examples</h3>

<pre><code class='language-R'># recreate Figure 2 in Chen (2003)
Qa &lt;- c(0.0001, 0.0003, 0.0005, 0.0008, 0.001)
tc &lt;- induce_infiltration_time(d = 575, S = 0.2, Tr = 100*15, Qa = Qa, Qw = 2727)
plot(x = (pi * Qa * 100 * 15 * 575 / 2727), y = tc, log = "y")
</code></pre>

<hr>
<h2 id='intermittent_pumping'>Streamflow depletion for an intermittent pumping schedule using superposition.</h2><span id='topic+intermittent_pumping'></span>

<h3>Description</h3>

<p>Streamflow depletion for an intermittent pumping schedule using superposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intermittent_pumping(t, starts, stops, rates, method = "glover", d, S, Tr, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intermittent_pumping_+3A_t">t</code></td>
<td>
<p>times you want output for [T]</p>
</td></tr>
<tr><td><code id="intermittent_pumping_+3A_starts">starts</code></td>
<td>
<p>vector of times to start pumping [T] (must be same length as stops and rates)</p>
</td></tr>
<tr><td><code id="intermittent_pumping_+3A_stops">stops</code></td>
<td>
<p>vector of times pumping stops [T] (must be same length as starts and rates)</p>
</td></tr>
<tr><td><code id="intermittent_pumping_+3A_rates">rates</code></td>
<td>
<p>vector of pumping rates [L3/T] (must be same length as starts and stops)</p>
</td></tr>
<tr><td><code id="intermittent_pumping_+3A_method">method</code></td>
<td>
<p>analytical solution to use (options= 'glover', 'hunt'). Defaults to 'glover'.</p>
</td></tr>
<tr><td><code id="intermittent_pumping_+3A_d">d</code></td>
<td>
<p>distance from well to stream [L]</p>
</td></tr>
<tr><td><code id="intermittent_pumping_+3A_s">S</code></td>
<td>
<p>aquifer storage coefficient (specific yield if unconfined; storativity if confined)</p>
</td></tr>
<tr><td><code id="intermittent_pumping_+3A_tr">Tr</code></td>
<td>
<p>aquifer transmissivity [L2/T]</p>
</td></tr>
<tr><td><code id="intermittent_pumping_+3A_...">...</code></td>
<td>
<p>any other inputs required for your <code>method</code> of choice; for example, <a href="#topic+hunt">hunt</a> needs <code>lmda</code> (streambed conductance)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function superimposes wells and image wells to calculate a timeseries of streamflow depletion.
Unlike the streamflow depletion models (e.g. <a href="#topic+glover">glover</a>, <a href="#topic+hunt">hunt</a>) this is not fractional depletion (<code>Qf</code>)
because there can be different pumping rates at different times.
</p>


<h3>Value</h3>

<p>A numeric of <code>Qs</code>, streamflow depletion rate [L3/T].
</p>


<h3>References</h3>

<p>Jenkins, C.T. (1968). Techniques for Computing Rate and Volume of Stream Depletion
by Wells. Ground Water 6(2): 37-46. doi:10.1111/j.1745-6584.1968.tb01641.x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Qs &lt;- intermittent_pumping(t = seq(0, 1000, 5),
 starts = seq(0, 900, 10), stops = seq(9, 909, 10), rates = seq(1, 1000, length.out=91),
 method = "hunt", d = 100, S = 0.1, Tr = 100, lmda = 10)

Qs &lt;- intermittent_pumping(t = seq(0, 1000, 5),
 starts = seq(0, 900, 10), stops = seq(9, 909, 10), rates = seq(1, 1000, length.out=91),
 method = "hunt", d = 100, S = 0.1, Tr = 100, lmda = 100000, lmda_max = 10)
</code></pre>

<hr>
<h2 id='prep_reach_dist'>Calculate the distance from a well to each reach within a stream network. This function splits a polyline stream network up into a series of evenly spaced points and
calculates the distance from each of those points to a well.</h2><span id='topic+prep_reach_dist'></span>

<h3>Description</h3>

<p>Calculate the distance from a well to each reach within a stream network. This function splits a polyline stream network up into a series of evenly spaced points and
calculates the distance from each of those points to a well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_reach_dist(
  wel_lon,
  wel_lat,
  stream_sf,
  reach_id,
  stream_pt_spacing,
  nseed = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep_reach_dist_+3A_wel_lon">wel_lon</code></td>
<td>
<p>longitude of well</p>
</td></tr>
<tr><td><code id="prep_reach_dist_+3A_wel_lat">wel_lat</code></td>
<td>
<p>latitude of well</p>
</td></tr>
<tr><td><code id="prep_reach_dist_+3A_stream_sf">stream_sf</code></td>
<td>
<p>simple feature collection of stream lines, i.e., loaded from a shapefile using <code>sf::st_read</code>.</p>
</td></tr>
<tr><td><code id="prep_reach_dist_+3A_reach_id">reach_id</code></td>
<td>
<p>string indicating name of column in <code>stream_sf</code> that has the unique identifier for each stream line segment.</p>
</td></tr>
<tr><td><code id="prep_reach_dist_+3A_stream_pt_spacing">stream_pt_spacing</code></td>
<td>
<p>distance between points used for sampling each stream reach. The actual distance
between points will be close to this (but not necessarily exact) due to sampling rounding error. The finer
spacing you use, the more accurate your results will be but the function will run slower and use more memory.</p>
</td></tr>
<tr><td><code id="prep_reach_dist_+3A_nseed">nseed</code></td>
<td>
<p>seed for random number generator (this is used to convert stream polylines to points)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with four columns:
</p>

<dl>
<dt>reach</dt><dd><p>a grouping variable with the name of each stream reach</p>
</dd>
<dt>dist</dt><dd><p>distance of a point on that stream reach to the well of interest</p>
</dd>
<dt>lat</dt><dd><p>latitude of that point</p>
</dd>
<dt>lon</dt><dd><p>longitude of that point</p>
</dd>
</dl>

<p>This data frame can be plugged directly into <a href="#topic+apportion_inverse">apportion_inverse</a>, <a href="#topic+apportion_polygon">apportion_polygon</a> (if <code>latlon=T</code>),
or <a href="#topic+apportion_web">apportion_web</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rdll &lt;- prep_reach_dist(wel_lon = 295500, wel_lat = 4783200,
   stream_sf = stream_lines, reach_id = "reach", stream_pt_spacing = 5)
head(rdll)
</code></pre>

<hr>
<h2 id='stream_lines'>Stream network for Sixmile Creek Watershed, Wisconsin, USA. Extracted from US NHDPlus v2.1 national seamless dataset.</h2><span id='topic+stream_lines'></span>

<h3>Description</h3>

<p>Stream network for Sixmile Creek Watershed, Wisconsin, USA. Extracted from US NHDPlus v2.1 national seamless dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stream_lines
</code></pre>


<h3>Format</h3>

<p>A simple feature LINESTRONG collection with 49 rows and 2 variables:
</p>

<dl>
<dt>reach</dt><dd><p>identifier code for each stream reach</p>
</dd>
<dt>stream</dt><dd><p>name of stream for each stream reach (Sixmile Creek or Dorn Creek)</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p><a href="http://www.horizon-systems.com/NHDPlusData/NHDPlusV21/Data/NationalData/">http://www.horizon-systems.com/NHDPlusData/NHDPlusV21/Data/NationalData/</a>
</p>

<hr>
<h2 id='streambed_conductance'>Estimate streambed conductance.</h2><span id='topic+streambed_conductance'></span>

<h3>Description</h3>

<p>Estimate streambed conductance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>streambed_conductance(w, Kriv, briv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="streambed_conductance_+3A_w">w</code></td>
<td>
<p>stream width [L]</p>
</td></tr>
<tr><td><code id="streambed_conductance_+3A_kriv">Kriv</code></td>
<td>
<p>streambed semipervious layer hydraulic conductivity [L/T].
Reeves et al. (2009) estimate this as the vertical hydraulic
conductivity of the aquifer (<code>Kv</code>; L/T), which is itself often estimated
as 10% of the horizontal hydraulic conductivity (<code>Kh*0.1</code>; L/T)</p>
</td></tr>
<tr><td><code id="streambed_conductance_+3A_briv">briv</code></td>
<td>
<p>streambed semipervious layer thickness [L]
Reeves et al. (2009) estimate this as the vertical distance from
the streambed to the top of the well screen, or the length of the
well screen, whichever is greater [L].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric of <code>lmda</code>, the streambed conductance term [L/T]
</p>


<h3>References</h3>

<p>Reeves, HW, DA Hamilton, PW Seelbach, and AJ Asher (2009). Ground-Water-Withdrawal Component of the
Michigan Water-Withdrawal Screening Tool. USGS Scientific Investigations Report, Reston VA.
https://pubs.usgs.gov/sir/2009/5003/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>streambed_conductance(w = 10, Kriv = 0.0864, briv = 1)
streambed_conductance(w = 5, Kriv = 0.0864, briv = 1)
streambed_conductance(w = 10, Kriv = 0.864, briv = 1)
streambed_conductance(w = 10, Kriv = 0.0864, briv = 0.1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
