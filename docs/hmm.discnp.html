<!DOCTYPE html><html><head><title>Help for package hmm.discnp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hmm.discnp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anova.hmm.discnp'>
<p>Anova for hmm.discnp models</p></a></li>
<li><a href='#ccprSim'>
<p>Simulated monocyte counts and psychosis symptoms.</p></a></li>
<li><a href='#cnvrtRho'>
<p>Convert Rho between forms.</p></a></li>
<li><a href='#fitted.hmm.discnp'>
<p>Fitted values of a discrete non-parametric hidden Markov</p>
model.</a></li>
<li><a href='#hmm'>
<p>Fit a hidden Markov model to discrete data.</p></a></li>
<li><a href='#hmm.discnp-internal'><p>Internal hmm.discnp functions.</p></a></li>
<li><a href='#hydroDat'>
<p>Canadian hydrological data sets.</p></a></li>
<li><a href='#lesionCount'><p>Multiple sclerosis lesion counts for three patients.</p></a></li>
<li><a href='#logLikHmm'>
<p>Log likelihood of a hidden Markov model</p></a></li>
<li><a href='#misstify'>
<p>Insert missing values.</p></a></li>
<li><a href='#mps'><p> Most probable states.</p></a></li>
<li><a href='#nafracCalc'>
<p>Calculate fractions of missing values.</p></a></li>
<li><a href='#pr'>
<p>Probability of state sequences.</p></a></li>
<li><a href='#predict.hmm.discnp'>
<p>Predicted values of a discrete non-parametric hidden Markov</p>
model.</a></li>
<li><a href='#rhmm'>
<p>Simulate discrete data from a non-parametric hidden Markov model.</p></a></li>
<li><a href='#scovmat'>
<p>Simulation based covariance matrix.</p></a></li>
<li><a href='#sp'>
<p>Calculate the conditional state probabilities.</p></a></li>
<li><a href='#squantCI'>
<p>Simulation-quantile based confidence intervals.</p></a></li>
<li><a href='#SydColDisc'><p>Discretised version of coliform counts in sea-water samples</p></a></li>
<li><a href='#update.hmm.discnp'>
<p>Update a fitted <code>hmm.discnp</code> model.</p></a></li>
<li><a href='#viterbi'><p> Most probable state sequence.</p></a></li>
<li><a href='#weissData'>
<p>Data from &ldquo;An Introduction to Discrete-Valued Time Series&rdquo;</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>3.0-9</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-09-26</td>
</tr>
<tr>
<td>Title:</td>
<td>Hidden Markov Models with Discrete Non-Parametric Observation
Distributions</td>
</tr>
<tr>
<td>Author:</td>
<td>Rolf Turner</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rolf Turner &lt;r.turner@auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>nnet (&ge; 7.3.12)</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits hidden Markov models with discrete non-parametric 
	observation distributions to data sets.  The observations may
	be univariate or bivariate. Simulates data from such models.
	Finds most probable underlying hidden states, the most
	probable sequences of such states, and the log likelihood
	of a collection of observations given the parameters of
	the model.  Auxiliary predictors are accommodated in the
        univariate setting.</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-26 08:27:50 UTC; rolf</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-26 09:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='anova.hmm.discnp'>
Anova for hmm.discnp models
</h2><span id='topic+anova.hmm.discnp'></span>

<h3>Description</h3>

<p>Performs a likelihood ratio test to compare two discrete non-parametric
hidden Markov models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hmm.discnp'
anova(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.hmm.discnp_+3A_object">object</code></td>
<td>

<p>An object of class &ldquo;hmm.discnp&rdquo; as returned by the
function <code><a href="#topic+hmm">hmm</a>()</code>.
</p>
</td></tr>
<tr><td><code id="anova.hmm.discnp_+3A_...">...</code></td>
<td>

<p>A second object of class &ldquo;hmm.discnp&rdquo;.  There must be
only <em>one</em> such object.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with entries
</p>
<table>
<tr><td><code>stat</code></td>
<td>
<p>The likelihood ratio statistic.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The degrees of freedom.</p>
</td></tr>
<tr><td><code>pvalue</code></td>
<td>
<p>The p-value of the test.</p>
</td></tr>
</table>
<p>This list has an attribute &ldquo;details&rdquo; which is a vector
consisting of the first and second log likelihoods and the associated
numbers of parameters, in order of these numbers of parameters.
(See <b>Warning</b>.)
</p>


<h3>Warning</h3>

<p>Hidden Markov models can be numerically delicate and the fitting
algorithm can converge to a local maximum of the likelihood surface
which is not the global maximum.  Thus it is entirely possible
for the log likelihood of the model with the greater number of
parameters to be <em>smaller</em> than that of the model with the
lesser number of parameters.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a><br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmm">hmm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xxx  &lt;- with(SydColDisc,split(y,f=list(locn,depth)))
fit1 &lt;- hmm(xxx,K=1,itmax=10)
fit2 &lt;- hmm(xxx,K=2,itmax=10)
anova(fit1,fit2)
</code></pre>

<hr>
<h2 id='ccprSim'>
Simulated monocyte counts and psychosis symptoms.
</h2><span id='topic+ccprSim'></span>

<h3>Description</h3>

<p>Discretised values of monocyte counts, and ratings of level of
psychosis simulated from a model fitted to a data set consisting of
observations made on a number of patients from the Northern District
Health Board system.  The real data must be kept confidential due
to ethics constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    data("ccprSim")
</code></pre>


<h3>Format</h3>

<p>The object <code>ccprSim</code> is a list of length 1258.  Each entry
of this list is to be considered to correspond to an individual
subject.  The entries consist of matrices having two columns
named <code>cellCount</code> and <code>psychosisRating</code>.  The number
of rows of these matrices varies from entry to entry of the list
(i.e. from subject to subject).
</p>
<p>Most of the entries of these matrices are <code>NA</code>.  The entries
are temporally ordered and correspond to the number of weeks
from the start of observation.  Observations in the real
data set were made only when the patient in question visted a
physician and so weeks in which no visit was made resulted in an
&ldquo;observation&rdquo; of <code>NA</code>.  The object <code>ccprSim</code>
was simulated in such a way as to imitate this characteristic.
The fraction of missing observations in each variate (i.e.
<code>cellCount</code> and <code>psychosisRating</code> is roughly
commensurate with the corresponding fractions in the real data.
</p>
<p>The values in the first column of each matrix (the
<code>cellCount</code> column) consist of integers from 1 to 5 and
are to be interpreted as indicators of cell counts in units of
<code class="reqn">10^9</code> cells per litre, discretised according to the
following scale:
</p>

<ul>
<li> <p><code class="reqn">0.0 \leq c \leq 0.3</code>
<code class="reqn">\leftrightarrow</code> 1
</p>
</li>
<li> <p><code class="reqn">0.3 &lt; c \leq 0.5</code>
<code class="reqn">\leftrightarrow</code> 2
</p>
</li>
<li> <p><code class="reqn">0.5 &lt; c \leq 0.7</code>
<code class="reqn">\leftrightarrow</code> 3
</p>
</li>
<li> <p><code class="reqn">0.7 &lt; c \leq 1.0</code>
<code class="reqn">\leftrightarrow</code> 4
</p>
</li>
<li> <p><code class="reqn">1.0 &lt; c \leq 2.0</code>
<code class="reqn">\leftrightarrow</code> 5
</p>
</li></ul>

<p>where <code class="reqn">c</code> represents &ldquo;count&rdquo;.
</p>
<p>The values in the second column of each matrix (the
<code>psychosisRating</code> column consist of integers from 0 to
4 and are to be interpreted as indicators of a physician's
assessment of the level of pschosis of the patient.  A value of
0 corresponds to &ldquo;no symptoms&rdquo;; a value of 4 corresponds
to &ldquo;severe&rdquo;.
</p>
<p>The question of essential interest in respect of the real data
was &ldquo;Is there any association between the cell count
values and the psychosis ratings?&rdquo;  More specifically it was
&ldquo;Can the level of psychosis be <em>predicted</em> from
the cell counts?&rdquo;
</p>


<h3>Source</h3>

<p>The real data, on the basis of which these data were simulated, were
supplied by Dr. Jonathan Williams, Northern District Health Board.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  # Takes too long.
    fit &lt;- hmm(ccprSim,K=2,indep=FALSE,itmax=5,verbose=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='cnvrtRho'>
Convert Rho between forms.
</h2><span id='topic+cnvrtRho'></span>

<h3>Description</h3>

<p>Converts a matrix specification of the emission probabilities
(in which the probabilities are simply the entries of the matrix)
to a data frame specification (in which the probabilities are
a logistic-style function of the parameters) or vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cnvrtRho(Rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cnvrtRho_+3A_rho">Rho</code></td>
<td>
<p>A specification of the emission probabilities of a
discrete valued hidden Markov model.  It may be either a
matrix of these probabilities, in which case it is converted
to a three column data frame, or it may be a three column
data frame, in which case it is converted to a matrix
of probabilities.  See <code><a href="#topic+hmm">hmm</a>()</code> for more details
about the structure of <code>Rho</code>, in either form.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data frame specification of <code>Rho</code> allows
for predictor variables <code>x</code>.  If <code>Rho</code> is of the
data frame form, and is designed to allow for predictor
variables, then it will have more than three columns and
cannot be converted to the matrix form.  In such
cases <code>cnvrtRho</code> will throw an error.
</p>


<h3>Value</h3>

<p>A data frame if the argument <code>Rho</code> is a matrix,
or a matrix if the argument <code>Rho</code> is a data
frame.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a><br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmm">hmm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Yval &lt;- LETTERS[1:10]
Tpm  &lt;- matrix(c(0.75,0.25,0.25,0.75),ncol=2,byrow=TRUE)
Rho  &lt;- cbind(c(rep(1,5),rep(0,5)),c(rep(0,5),rep(1,5)))/5
rownames(Rho) &lt;- Yval
newRho &lt;- cnvrtRho(Rho)
oldRho &lt;- cnvrtRho(newRho)
</code></pre>

<hr>
<h2 id='fitted.hmm.discnp'>
Fitted values of a discrete non-parametric hidden Markov
model.
</h2><span id='topic+fitted.hmm.discnp'></span>

<h3>Description</h3>

<p>Calculates the fitted values of a discrete non-parametric hidden
Markov model.  If the data are numeric these are the conditional
expectations of the observations, given the entire observation
sequence (and the estimated parameters of the model).  If the data
are categorical (whence &ldquo;expectations&rdquo; make no sense) the
&ldquo;fitted values&rdquo; are taken to be the probabilities of
each of the possible values of the observations, at each time
point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hmm.discnp'
fitted(object, warn=TRUE, drop=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.hmm.discnp_+3A_object">object</code></td>
<td>

<p>An object of class <code>hmm.discnp</code> as returned by
<code><a href="#topic+hmm">hmm</a>()</code>.
</p>
</td></tr>
<tr><td><code id="fitted.hmm.discnp_+3A_warn">warn</code></td>
<td>

<p>Logical scalar.  See the help for <code><a href="#topic+sp">sp</a>()</code>.
</p>
</td></tr>
<tr><td><code id="fitted.hmm.discnp_+3A_drop">drop</code></td>
<td>

<p>Logical scalar.  If there is a single sequence of observations
(i.e. if <code>object[["y"]]</code> consists of a matrix or a list of
length 1) and if <code>drop</code> is <code>TRUE</code> then the returned value
is a single entity (matrix, list of two matrices, or 3-dimensional
array, depending on circumstances.  Otherwise the returned value
is a list of such entities, one for each observation sequence.
</p>
</td></tr>
<tr><td><code id="fitted.hmm.discnp_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The observation sequence(s) must be present in <code>object</code> (which
will be the case if <code>object</code> was returned by <code>hmm()</code>
and if the argument <code>keep.y</code> was set to <code>TRUE</code>).
If it is not present an error is thrown.
</p>
<p>However, if such an error is thrown, do not despair!  You
<em>do not</em> have to start from scratch when fitting your
model with <code>keep.y==TRUE</code>.  If <code>fit</code> is your fitted
model that you obtained <em>without</em> setting <code>keep.y==TRUE</code>,
then you can just re-fit the model using <code>fit</code> as the
starting values: </p>
<pre>
      fit2 &lt;- hmm(&lt;whatever&gt;,par0=fit,keep.y=TRUE)
  </pre>
<p>This will of course converge instantaneously.  You could also do:
</p>
<pre>
      fit2 &lt;- update(fit,data=&lt;whatever&gt;,keep.y=TRUE)
  </pre>


<h3>Value</h3>

<p>If the observations consist of a single sequence and if
<code>drop</code> is <code>TRUE</code> then the returned value consists
of a single object (matrix, list of two matrices, or 3-dimensional
array, depending on circumstances; see below).  Otherwise the
returned value is a list of such objects, one for each observation
sequence.
</p>
<p>If the observations are numeric then the object corresponding
to each observation sequence is a matrix.  If the model is
univariate (see <code><a href="#topic+hmm">hmm</a>()</code>) then matrix has a single
column constituting the sequence of fitted values corresponding to
the observations in the given sequence.  The number of rows is the
number of observations and the entry in row <code>t</code> is the fitted
value (conditional expection) corresponding to the observation made
at time <code>t</code>. If the model is bivariate (either independent
or dependent) then the matrix has two columns corresponding
respectively to the two variables in the bivariate model.
</p>
<p>If the observations are categorical then the nature of the object
returned changes substantially depending on whether the data are
univariate, bivariate independent or bivariate dependent.  (See
<code><a href="#topic+hmm">hmm</a>()</code>.
</p>
<p>In the unvariate case the object corresponding to each sequence
is a matrix, the number of rows of which is the number of
observations and the number of columns of which is the number of
unique <em>possible</em> values of the observations. The entry of
this matrix in row <code>t</code> and column <code>j</code> is the conditional
probability that an emission, at time <code>t</code>, is equal to
<code class="reqn">u_i</code> where <code class="reqn">u_1, \dots, u_m</code>
are the unique possible values.
</p>
<p>In the bivariate independent case the object is a <em>list</em>
of two matrices, each of which is of the same nature as that
produced in the univariate case, corresponding respectively to
the first and second of the two variables.
</p>
<p>In the bivariate dependent case the object is a 3-dimensional
array of dimension <code class="reqn">m_1 \times m_2 \times n</code>
where <code class="reqn">m_1</code> is the number of unique possible values
of the first variable, <code class="reqn">m_2</code> is the number of unique
possible values of the second variable, and <code class="reqn">n</code> is the number
of observations.  The <code>(i,j,t)-th</code> entry of this array is
the conditional probability that an emission, at time <code>t</code>,
is equal to <code class="reqn">(u_i,v_j)</code> where the <code class="reqn">u_i</code>
are the unique possible values of the first variable and the
<code class="reqn">v_j</code> are the unique possible values of the second
variable.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a><br />
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sp">sp</a>()</code> <code>link{predict.hmm.discnp}()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- matrix(c(0.7,0.3,0.1,0.9),2,2,byrow=TRUE)
R &lt;- matrix(c(0.5,0,0.1,0.1,0.3,
              0.1,0.1,0,0.3,0.5),5,2)
set.seed(42)
lll &lt;- sample(250:350,20,TRUE)
y   &lt;- rhmm(ylengths=lll,nsim=1,drop=TRUE,tpm=P,Rho=R)
fit &lt;- hmm(y,K=2,verb=TRUE,keep.y=TRUE,itmax=10)
fv  &lt;- fitted(fit)
</code></pre>

<hr>
<h2 id='hmm'>
Fit a hidden Markov model to discrete data.
</h2><span id='topic+hmm'></span>

<h3>Description</h3>

<p>Effects a maximum likelihood fit of a hidden Markov model
to discrete data where the observations come from one of a
number of finite discrete distributions, depending on the
(hidden) state of the Markov chain.  These distributions (the
&ldquo;emission probabilities&rdquo;) are specified non-parametrically.
The observations may be univariate, independent bivariate,
or dependent bivariate.  By default this function uses the EM
algorithm.  In the univariate setting it may alternatively use
a &ldquo;brute force&rdquo; method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm(y, yval=NULL, par0=NULL, K=NULL, rand.start=NULL,
    method=c("EM","bf","LM","SD"), hglmethod=c("fortran","oraw","raw"),
    optimiser=c("nlm","optim"), optimMethod=NULL, stationary=cis,
    mixture=FALSE, cis=TRUE, indep=NULL, tolerance=1e-4, digits=NULL,
    verbose=FALSE, itmax=200, crit=c("PCLL","L2","Linf","ABSGRD"),
    X=NULL,keep.y=FALSE, keep.X=keep.y,
    addIntercept=TRUE, lmc=10, hessian=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_+3A_y">y</code></td>
<td>

<p>A vector or a list of vectors, or one or two column matrix
(bivariate setting) or a list of such matrices; missing values
are allowed.  If <code>y</code> is a vector, or list of vectors (of
discrete data) these vectors are coerced to one column matrices.
The entries of these vectors or matrices may be numeric or
character and are assumed to constitute  discrete data.
</p>
</td></tr> <tr><td><code id="hmm_+3A_yval">yval</code></td>
<td>

<p>A vector (of length <code>m</code>, say) of possible values for the
data or a list of two such vectors (of lengths <code>m1</code> and
<code>m2</code>, say, one for each of the two variates in the bivariate
settings).  These vectors default to the sorted unique values of
the respective variates as provided in <code>y</code>.  If <code>yval</code>
is supplied and any value of <code>y</code> does not match some value
of <code>yval</code>, then an error is thrown.
</p>
<p>The argument <code>yval</code> is provided so as to allow for fitting
of models to data in which some of the data values &ldquo;of interest&rdquo;
were never observed.  The estimated emission probabilities of such
&ldquo;never observed&rdquo; values will of course be zero.
</p>
</td></tr> <tr><td><code id="hmm_+3A_par0">par0</code></td>
<td>

<p>An optional (<em>named</em>) list of starting values for the
parameters of the model, with components <code>tpm</code> (transition
probability matrix), <em>optionally</em> <code>ispd</code> (initial state
probability distribution) and <code>Rho</code>.  The object <code>Rho</code>
specifies the probability that the observations take on each of
the possible  values of the variate or variates, given the state
of the hidden Markov chain.  See <b>Details</b>.  Note that in
the case of independent bivariate data <code>Rho</code> is a list
of two matrices.  These matrices may (and in general will)
have different row dimensions, but must have identical column
dimensions (equal to <code>K</code>, the number of states; see below).
</p>
<p>If the model is stationary (i.e. if <code>stationary</code> is
<code>TRUE</code>) then you should almost surely not specify the
<code>ispd</code> component of <code>par0</code>.  If you do specify it,
it really only makes sense to specify it to be the stationary
distribution determined by <code>tpm</code> and this is a waste of
time since this is what the code will take <code>ispd</code> to be if
you leave it unspecified.
</p>
<p>If <code>par0</code> is not specified, starting values are created by
the (undocumented) function <code>init.all()</code>.
</p>
</td></tr>
<tr><td><code id="hmm_+3A_k">K</code></td>
<td>

<p>The number of states in the hidden Markov chain; if <code>par0</code>
is not specified <code>K</code> <em>MUST</em> be; if <code>par0</code> is
specified, <code>K</code> is ignored.
</p>
<p>Note that <code>K=1</code> is acceptable; if <code>K</code> is 1 then
all observations are treated as being independent and the
non-parametric estimate of the distribution of the observations
is calculated in the &ldquo;obvious&rdquo; way.
</p>
</td></tr>
<tr><td><code id="hmm_+3A_rand.start">rand.start</code></td>
<td>

<p>Either a logical scalar or a list consisting of two logical
scalars which must be named <code>tpm</code> and <code>Rho</code>.  If the
former, it is converted internally into a list with entries
named <code>tpm</code> and <code>Rho</code>, both having the same value as
the original argument.  If <code>tpm</code> is TRUE then the function
init.all() chooses entries for the starting value of <code>tpm</code>
at random; likewise for <code>Rho</code>.  If left <code>NULL</code>, this
argument defaults to <code>list(tpm=FALSE,Rho=FALSE)</code>.
</p>
</td></tr>
<tr><td><code id="hmm_+3A_method">method</code></td>
<td>

<p>Character string, either <code>"bf"</code>, <code>"EM"</code>,
<code>"LM"</code> or <code>"SD"</code> (i.e. use numerical maximisation
via either <code>nlm()</code> or <code>optim()</code>, the EM algorithm, the
Levenberg-Marquardt algorithm, or the method of steepest descent).
May be abbreviated.  Currently the <code>"bf"</code>, <code>"LM"</code> and
<code>"SD"</code> methods can be used only in the univariate setting,
handle only stationary models (see below) and do not do mixtures.
</p>
</td></tr>
<tr><td><code id="hmm_+3A_hglmethod">hglmethod</code></td>
<td>

<p>Character string; one of <code>"fortran"</code>, <code>"oraw"</code> or
<code>"raw"</code>.  May be abbreviated. This argument determines the
procedure by which the hessian, gradient and log likelihood of
the model and data are calculated.  If this is argument is equal
to <code>"fortran"</code> (the default) then (obviously!) dynamically
loaded fortran subroutines are used.  The other two possibilities
effect the calculations in raw R; <code>"oraw"</code> (&ldquo;o&rdquo;
for &ldquo;original&rdquo; uses code that is essentially a direct
transcription of the fortran code, do-loops being replaced by
for-loops.  With method <code>"raw"</code> the for-loops are eliminated
and matrix-vector calculations are applied.  The <code>"oraw"</code>
method is about 25 times slower than the <code>"fortran"</code> method
and the <code>"raw"</code> method is (surprisingly?) even worse;
it is more than 30 times slower.  The &ldquo;raw&rdquo; methods are
present mainly for debugging purposes and would not usually be
used in practice.  This argument is used only if the <code>method</code>
is <code>"LM"</code> or <code>"SD"</code> (and is involved only peripherally
in the latter instance).  It is ignored otherwise.
</p>
</td></tr>
<tr><td><code id="hmm_+3A_optimiser">optimiser</code></td>
<td>

<p>Character string specifying the optimiser to use when the
&ldquo;<code>"bf"</code>&rdquo; method of optimisation is chosen.  It should be
one of <code>"nlm"</code> or <code>"optim"</code>, and may be abbreviated.
Ignored unless <code>method="bf"</code>.
</p>
</td></tr>
<tr><td><code id="hmm_+3A_optimmethod">optimMethod</code></td>
<td>

<p>Character string specifying the optimisation method to be used by
<code><a href="stats.html#topic+optim">optim</a>()</code>.  Should be one of <code>"Nelder-Mead"</code>,
<code>"BFGS"</code>, <code>"CG"</code>, <code>"L-BFGS-B"</code>, <code>"SANN"</code>, or
<code>"Brent"</code>.  Ignored if the <code>method</code> is not <code>"bf"</code>
or if the optimiser is not <code>"optim"</code>.
</p>
</td></tr>
<tr><td><code id="hmm_+3A_stationary">stationary</code></td>
<td>

<p>Logical scalar.  If <code>TRUE</code> then the model is fitted under
the stationarity assumption, i.e. that the Markov chain was in
steady state at the time that observations commenced. In this
case  the initial state probability distribution is estimated
as the stationary distribution determined by the (estimated)
transition probability matrix.  Otherwise if <code>cis</code> (see
below) is <code>TRUE</code> the initial state probability distribution
is estimated as the mean of the vectors of conditional
probabilities of the states, given the observation sequences,
at time <code>t=1</code>.  If <code>stationary</code> is <code>TRUE</code> and
<code>cis</code> is <code>FALSE</code> an error is thrown.  Currently if
the method is <code>"bf"</code>, <code>"LM"</code> or <code>"SD"</code>, and
<code>stationary</code> is <code>FALSE</code>, then an error is thrown.
</p>
</td></tr>
<tr><td><code id="hmm_+3A_mixture">mixture</code></td>
<td>

<p>A logical scalar; if TRUE then a mixture model (all rows of the
transition probability matrix are identical) is fitted rather
than a general hidden Markov model.  Currently an error is
thrown if <code>mixture=TRUE</code> and the method is
<code>"bf"</code>, <code>"LM"</code> or <code>"SD"</code>.
</p>
</td></tr>
<tr><td><code id="hmm_+3A_cis">cis</code></td>
<td>

<p>A logical scalar specifying whether there should be a
<b>constant</b> <b>initial</b> <b>state</b> probability
distribution.  If <code>stationary</code> is <code>FALSE</code> and <code>cis</code>
is <code>FALSE</code> then the initial state probability distribution
for a given observation sequence is equal to 1 where the (first)
maximum of the vector of conditional probabilities of the states,
given the observation sequences, at time <code>t=1</code>, occurs,
and is 0 elsewhere.  If <code>stationary</code> is <code>TRUE</code> and
<code>cis</code> is <code>FALSE</code> an error is given.
</p>
</td></tr>
<tr><td><code id="hmm_+3A_indep">indep</code></td>
<td>

<p>Logical scalar.  Should the bivariate model be fitted under the
assumption that the two variables are (conditionally) independent
give the state?  If this argument is left as <code>NULL</code> its
value is inferred from the structure of <code>Rho</code> in <code>par0</code>
if the latter is supplied.  If the data are bivariate and neither
<code>indep</code> nor <code>par0</code> is supplied, then an error is given.
If the data are bivariate and if the value of <code>indep</code>
is inconsistent with the structure of <code>par0$Rho</code> then an
error is given. If the data are univariate then <code>indep</code>
is ignored.
</p>
</td></tr>
<tr><td><code id="hmm_+3A_tolerance">tolerance</code></td>
<td>

<p>If the value of the quantity used for the stopping criterion
is less than tolerance then the algorithm is considered to
have converged.  Ignored if <code>method="bf"</code>.  Defaults to
<code>1e-4</code>.
</p>
</td></tr>
<tr><td><code id="hmm_+3A_digits">digits</code></td>
<td>

<p>Integer scalar.  The number of digits to which to print out
&ldquo;progress reports&rdquo; (when <code>verbose</code> is <code>TRUE</code>).
There is a &ldquo;sensible&rdquo; default (calculated from
<code>tolerance</code>).  Not used if the method is <code>"bf"</code>.
</p>
</td></tr>
<tr><td><code id="hmm_+3A_verbose">verbose</code></td>
<td>

<p>A logical scalar determining whether to print out details of
the progress of the algorithm.  If the method is <code>"EM"</code>,
<code>"LM"</code> or <code>"SD"</code> then when <code>verbose</code> is <code>TRUE</code>
information about the convergence criteria is printed out at
every step that the algorithm takes.  If <code>method="bf"</code> then
the value of <code>verbose</code> determines the value of the argument
<code>print.level</code> of <code><a href="stats.html#topic+nlm">nlm</a>()</code> or the value of the
argument <code>trace</code> of <code><a href="stats.html#topic+optim">optim</a>()</code>.  In the first
case, if <code>verbose</code> is <code>TRUE</code> then <code>print.level</code>
is set to 2, otherwise it is set to 0.  In the second case,
if <code>verbose</code> is <code>TRUE</code> then <code>trace</code> is set to 6,
otherwise it is set to 0.
</p>
</td></tr>
<tr><td><code id="hmm_+3A_itmax">itmax</code></td>
<td>

<p>When the method is <code>"EM"</code>, <code>"LM"</code> or <code>"SD"</code>
this is the maximum number of steps that the algorithm takes.
If the convergence criterion has not been met by the time
<code>itmax</code> steps have been performed, a warning message
is printed out, and the function stops.  A value is returned by
the function anyway, with the logical component <code>converged</code> set
to <code>FALSE</code>.  When <code>method="bf"</code> the <code>itmax</code> argument
is passed to <code>nlm()</code> as the value of <code>iterlim</code>
or to <code>optim()</code> as the value of <code>maxit</code>.  If the
(somewhat obscure) convergence criteria of <code>nlm()</code> or
<code>optim()</code>  have not been met by the time <code>itmax</code>
&ldquo;iterations&rdquo; have been performed, the algorithm ceases.
In this case, if <code>nlm()</code> is used.  the value of <code>code</code>
in the object returned set equal to 4 and if <code>optim()</code>
is used then the value of <code>convergence</code> returned is set
equal to 1.  Note that the value of <code>code</code>, respectively
<code>convergence</code> is returned as the <code>converged</code> component
of the object returned by <code>hmm()</code>.  A value of 1 indicates
successful completion of the <code>nlm()</code> procedure.  A value of
0 indicates successful completion of the <code>optim()</code> procedure.
</p>
</td></tr>
<tr><td><code id="hmm_+3A_crit">crit</code></td>
<td>

<p>The name of the stopping criterion used.  When <code>method="EM"</code>
it must be one of <code>"PCLL"</code> (percent change in log-likelihood;
the default), <code>"L2"</code> (L-2 norm, i.e.  square root of sum of
squares of change in coefficients), or <code>"Linf"</code> (L-infinity
norm, i.e.  maximum absolute value of change in coefficients).
When <code>method="LM"</code> or <code>method="SD"</code> there is a fourth
possibility, namely <code>"ABSGRD"</code> the (maximum) absolute value
of the gradient.  It may not be advisable to use this criterion
in the current context (i.e. that of discrete non-parametric
distributions).  See <b>Warnings</b>.  This argument defaults
to <code>"PCLL"</code>.  It is ignored if <code>method="bf"</code>.
(The <code>nlm()</code> and <code>optim()</code> functions have their own
obscure stopping criteria.)
</p>
</td></tr>
<tr><td><code id="hmm_+3A_x">X</code></td>
<td>
<p>An optional <em>numeric</em> matrix, or a list of such
matrices, of &ldquo;auxiliary&rdquo; <em>predictors</em>.  The use of
such predictors is (currently, at least) applicable only in the
univariate emissions setting.  If <code>X</code> is a list it must be
of the same length as <code>y</code> and all entries of this list must
have the same number of columns.  If the columns of any entry
of the list are named, then they must be named for <em>all</em>
entries, and the column names must be the <em>same</em> for all
entries. The number of rows of each entry must be equal to the
length of the corresponding entry of <code>y</code>. If <code>X</code> is
a matrix then <code>y</code> should be a vector or one-column matrix
(or a list with a single entry equal to such).
</p>
<p>There may be at most one constant column in <code>X</code> or the
components thereof.  If there are <em>any</em> constant columns
there must be precisely one (in all components of <code>X</code>),
it must be the first column and all of its entries must be equal
to <code>1</code>.  If the columns have names, the names of this first
column must be <code>"Intercept"</code>.
</p>
<p>Note that <code>X</code> (or its entries) must be a <em>numeric</em>
matrix (or must be numeric matrices) &mdash; not data frames!  Factor
predictors are not permitted.  It may be possible to use factor
predictors by supplying <code>X</code> or its entries as the output of
<code><a href="stats.html#topic+model.matrix">model.matrix</a>()</code>; this will depend on circumstances.
</p>
<p>The fitted coefficients that are produced when <code>X</code> is supplied,
are (to put it mildly) a bit difficult to interpret.  See
<b>Fitted Coefficients of Auxiliary Predictors</b> for
some discussion.
</p>
</td></tr>
<tr><td><code id="hmm_+3A_keep.y">keep.y</code></td>
<td>

<p>Logical scalar; should the observations <code>y</code> be returned as
a component of the value of this function?
</p>
</td></tr>
<tr><td><code id="hmm_+3A_keep.x">keep.X</code></td>
<td>

<p>Logical scalar; should the predictors <code>X</code> be returned as
a component of the value of this function?  Note that the
value of <code>keep.X</code> will be silently set equal to <code>FALSE</code>
unless it actually &ldquo;makes sense&rdquo; to keep <code>X</code>.  I.e.
unless the observations are <em>univariate</em>
and <code>X</code> is actually supplied, i.e. is
not <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="hmm_+3A_addintercept">addIntercept</code></td>
<td>

<p>Logical scalar.  Should a column of ones, corresponding to
an intercept term, be prepended to each of the matrices in
the list <code>X</code>?   If each of these matrices already has an
initial column of ones, then setting <code>addIntercept=TRUE</code>
results in an error being thrown.  If this is not the case,
then by default an initial column of ones is added.
</p>
</td></tr>
<tr><td><code id="hmm_+3A_lmc">lmc</code></td>
<td>

<p>Numeric scalar.  The (initial) &ldquo;Levenberg-Marquardt
correction&rdquo; parameter.  Used only if <code>method="LM"</code>,
otherwise ignored.
</p>
</td></tr>
<tr><td><code id="hmm_+3A_hessian">hessian</code></td>
<td>

<p>Logical scalar.  Should the hessian matrix be
returned?  This argument is relevant only if <code>method="bf"</code>
(in which case it is passed along to <code>hmmNumOpt()</code>) and is
ignored otherwise.  This argument should be set to <code>TRUE</code>
only if you <em>really</em> want the hessian matrix.  Setting it
to <code>TRUE</code> causes a substantial delay between the time when
<code>hmm()</code> finishes its iterations and when it actually returns
a value.
</p>
</td></tr>
<tr><td><code id="hmm_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code>hmmNumOpt()</code>.
There is one noteworthy argument <code>useAnalGrad</code> which is used
&ldquo;directly&rdquo; by <code>hmmNumOpt()</code>.  This argument is a
logical scalar and if it is <code>TRUE</code> then calls to <code>nlm()</code>
or <code>optim()</code> are structured so that an analytic calculation
of the gradient vector (implemented by the internal function
<code>get.gl()</code> is applied.  If it is <code>FALSE</code> then finite
difference methods are used to calculate the gradient vector.
If this argument is not specified it defaults to <code>FALSE</code>.
Note that the name of this argument <b>cannot be abbreviated</b>.
</p>
<p>Other &ldquo;additional arguments&rdquo; may be supplied for the
control of <code><a href="stats.html#topic+nlm">nlm</a>()</code> and are passed on appropriately
to <code>nlm()</code>.  These are used only if <code>method="bf"</code>
and if <code>optimiser="nlm"</code>.  These &ldquo;...&rdquo; arguments
might typically include <code>gradtol</code>, <code>stepmax</code> and
<code>steptol</code>.  They should <b>NOT</b> include <code>print.level</code>
or <code>iterlim</code>.  The former argument is automatically passed
to <code>nlm()</code> as <code>0</code> if <code>verbose</code> is <code>FALSE</code>
and as <code>2</code> if <code>verbose</code> is <code>TRUE</code>.  The latter
argument is automatically passed to <code>nlm()</code> with the value
of <code>itmax</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><b>Univariate case:</b>
In the univariate case the emission probabilities are specified by
means of a data frame <code>Rho</code>.  The first column of <code>Rho</code>,
named <code>"y"</code>, is a factor consisting of the possible values
of the emissions, repeated <code>K</code> times (where <code>K</code> is
the number of states).  The second column, named <code>states</code>,
is a factor consisting of integer values <code>1, 2, ..., K</code>.
Each of these values is repeated <code>m</code> times where <code>m</code>
is the length of <code>yval</code>.   Further columns of <code>Rho</code>
are numeric and consist of coefficients of the linear predictor of
the probabilities of the various values of <code>y</code>.  If <code>X</code>
is <code>NULL</code> then <code>Rho</code> has only one further column named
<code>Intercept</code>.
</p>
<p>If <code>X</code> is not <code>NULL</code> then the <code>Intercept</code>
column is present only if <code>addIntercept</code> is <code>TRUE</code>.
There as many (other, in addition to the possible <code>Intercept</code>
column) numeric columns as there are columns in <code>X</code> or in
the matrices in the list <code>X</code>.  The names of these columns
are taken to be the column names of <code>X</code> or the <em>first</em>
entry of <code>X</code> if such column names are present.  Otherwise the
names default to <code>V1</code>, <code>V2</code> ....
</p>
<p>The probabilities of the emissions taking on their
various possible values are given by
</p>
<p style="text-align: center;"><code class="reqn">\Pr(Y = y_i | \boldsymbol{x}, \textrm{state}=S) =
   \ell_i/\sum_{j=1}^m \ell_j</code>
</p>

<p>where <code class="reqn">\ell_j</code> is the <code class="reqn">j\textrm{th}</code>
entry of <code class="reqn">\boldsymbol{\beta}^{\top}\boldsymbol{x}</code>
and  where in turn <code class="reqn">\boldsymbol{x}</code> is the vector
of predictors and <code class="reqn">\boldsymbol{\beta}</code> is the
coefficient vector in the linear predicator that corresponds to
<code class="reqn">y_i</code> and the hidden state <code class="reqn">S</code>.  For identifiability the
vectors <code class="reqn">\boldsymbol{\beta}</code> corresponding to
the first value of <code class="reqn">Y</code> (the first level of <code>Rho$y</code>) are
set equal to the zero vector for all values of the state <code class="reqn">S</code>.
</p>
<p>Note that the <code>Rho</code> component of the starting values
<code>par0</code> may be specified as a <em>matrix</em> of probabilities,
with rows corresponding to possible values of the observations and
columns corresponding to states.  That is the <code>Rho</code> component
of <code>par0</code> may be provided in the form <code class="reqn">\textrm{Rho} =
   [\rho_{ij}]</code> where <code class="reqn">\rho_{ij} = \Pr(Y = y_i
   | S = j)</code>.  This is permissible
as long as <code>X</code> is <code>NULL</code> and may be found to be more
convenient and intuitive.  If the starting value for <code>Rho</code>
is provided in matrix form it is (silently) converted internally
into the data frame form, by the (undocumented) function
<code>cnvrtRho()</code>.
</p>
<p>When argument <code>X</code> is <em>not</em> <code>NULL</code>, it is
difficult to specify a &ldquo;reasonable&rdquo; value for the
<code>Rho</code> component of <code>par0</code>.  One might try to specify
<code>par0$Rho</code> in the data frame form.  The question of how
to specify the columns of <code>par0$Rho</code> corresponding to the
auxiliary predictors (columns of <code>X</code> or of the entries of
<code>X</code>) is a thorny one.
</p>
<p>It is permissible in these circumstances to specify
<code>par0$Rho</code> as a matrix of probabilities, just as one
would do if <code>X</code> were <code>NULL</code>.  In this setting the
(undocumented) function <code>checkStartVal()</code> converts the
matrix of probabilities to data frame form and then appends
columns, all of whose entries are 0, corresponding to the
auxiliary predictors.  When <code>par0</code> is unspecified, the
(undocumented) function <code>init.all()</code> performs similar
construction to accommodate a non-<code>NULL</code> value of <code>X</code>.
Whether the resulting starting value for <code>Rho</code> makes any
real sense, is questionable.  However little else can be done.
</p>
</li>
<li> <p><b>Independent bivariate case:</b> the emission
probabilities are specified by a list of two matrices.
In this setting <code class="reqn">\Pr(Y_1,Y_2) = (y_{i1},y_{i2}) | S = j) =
   \rho^{(1)}_{i_1,j} \rho^{(2)}_{i_2,j}</code> where <code class="reqn">R^{(k)} =
   [\rho^{(k)}_{ij}]</code> (<code class="reqn">k = 1,2</code>) are the
two emission probability matrices.
</p>
</li>
<li> <p><b>Dependent bivariate case:</b> the emission probabilities
are specified by a three dimensional array.  In this setting
<code class="reqn">\Pr((Y_1,Y_2) = (y_{i1},y_{i2}) | S = j) = \rho_{i_1,i_2,j}</code> where
<code class="reqn">R = [\rho_{ijk}]</code> is the emission probability array.
</p>
</li></ul>

<p>The hard work of calculating the recursive probabilities used
to fit the model is done by a Fortran subroutine <code>recurse</code>
(actually coded in Ratfor) which is dynamically loaded.  In the
univariate case, when <code>X</code> is provided, the estimation of the
&ldquo;linear predictor&rdquo; vectors <code class="reqn">\boldsymbol{\beta}</code>
is handled by the function <code>multinom()</code> from the <code>nnet</code>
package.  Note that this is a &ldquo;Recommended&rdquo; package
and is thereby automatically available (i.e. does not have to
be installed).
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>Rho</code></td>
<td>

<p>The fitted value of the data frame, list of two matrices,
or array <code>Rho</code> (in the case of a univariate model, a
bivariate independent model or a bivariate dependent model
respectively) specifying the distributions of the observations
(the &ldquo;emission&rdquo; probabilities).
</p>
</td></tr>
<tr><td><code>Rho.matrix</code></td>
<td>

<p>Present <em>only</em> in the univariate setting.  A matrix
whose entries are the (fitted) emission probabilities,
row corresponding to values of the emissions and columns
to states.  The columns sum to 1.  This component provides
the same information as <code>Rho</code>, but in a more readily
interpretable form.
</p>
</td></tr>
<tr><td><code>tpm</code></td>
<td>

<p>The fitted value of the transition probability matrix <code>tpm</code>.
</p>
</td></tr>
<tr><td><code>stationary</code></td>
<td>

<p>Logical scalar; the value of the <code>stationary</code> argument.
</p>
</td></tr>
<tr><td><code>ispd</code></td>
<td>

<p>The fitted initial state probability distribution, or a matrix
of initial state probability distributions, one (column) of
<code>ispd</code> for each observation sequence.
</p>
<p>If <code>stationary</code> is <code>TRUE</code> then <code>ispd</code> is assumed
to be the (unique) stationary distribution for the chain,
and thereby determined by the transition probability matrix
<code>tpm</code>.  If <code>stationary</code> is <code>FALSE</code> and <code>cis</code>
is <code>TRUE</code> then <code>ispd</code> is estimated as the mean of the
vectors of conditional probabilities of the states, given the
observation sequences, at time <code>t=1</code>.
</p>
<p>If <code>cis</code> is <code>FALSE</code> then <code>ispd</code> is a matrix
whose columns are the vectors of conditional probabilities of
the states, given the observation sequences, at time <code>t=1</code>,
as described above.  (If there is only one observation sequence,
then this &mdash; one-column &mdash; matrix is converted into a vector.)
</p>
</td></tr>
<tr><td><code>log.like</code></td>
<td>

<p>The final (maximal, we hope!) value of the log likelihood, as
determined by the maximisation procedure.
</p>
</td></tr>
<tr><td><code>grad</code></td>
<td>

<p>The gradient of the log likelihood.  Present only if the
method is <code>"LM"</code> or <code>"bf"</code> and in the latter
case then only if the optimiser is <code>nlm()</code>.
</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>

<p>The hessian of the log likelihood.  Present only if the
method is <code>"LM"</code> or <code>"bf"</code>.
</p>
</td></tr>
<tr><td><code>stopCrit</code></td>
<td>

<p>A vector of the (final) values of the stopping criteria, with
names <code>"PCLL"</code>, <code>"L2"</code>, <code>"Linf"</code> unless the method
is <code>"LM"</code> or <code>"SD"</code> in which case this vector has a
fourth entry named <code>"ABSGRD"</code>.
</p>
</td></tr>
<tr><td><code>par0</code></td>
<td>

<p>The starting values used by the algorithms.  Either the argument
<code>par0</code>, or a similar object with either or both components
(<code>tpm</code> and <code>Rho</code>) being created by <code>rand.start()</code>.
</p>
</td></tr>
<tr><td><code>npar</code></td>
<td>

<p>The number of parameters in the fitted model.  Equal to
<code>nispar + ntpmpar + nrhopar</code> where (1) <code>nispar</code> is
<code>0</code> if <code>stationary</code> is <code>TRUE</code> and is <code>K-1</code>
otherwise; (2) <code>ntpmpar</code> is <code>K*(K-1)</code> (3) <code>nrhopar</code>
is
</p>

<ul>
<li> <p><code>(nrow(Rho) - K)*(ncol(Rho)-2)</code> for univariate models
</p>
</li>
<li> <p><code>K*(sum(sapply(Rho,nrow))-K)</code> for bivariate independent models
</p>
</li>
<li> <p><code>prod(dim(Rho))-K</code> for bivariate dependent models.
</p>
</li></ul>

</td></tr>
<tr><td><code>bicm</code></td>
<td>

<p>Numeric scalar.  The number by which <code>npar</code> is multiplied
to form the <code>BIC</code> criterion.  It is essentially the log
of the number of observations.  See the code of <code>hmm()</code>
for details.
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>A logical scalar indicating whether the algorithm converged.
If the EM, LM or steepest descent algorithm was used it simply
indicates whether the stopping criterion was met before
the maximum number (<code>itmax</code>) of steps was exceeded.
If <code>method="bf"</code> then <code>converged</code> is based on the
<code>code</code> component of the object returned by the optimiser
when <code><a href="stats.html#topic+nlm">nlm</a>()</code> was used, or on the <code>convergence</code>
component when <code><a href="stats.html#topic+optim">optim</a>()</code> was used.  In these
cases <code>converged</code> has an <em>attribute</em> (<code>code</code>
or <code>convergence</code> respectively) giving the (integer) value
of the relevant component.
</p>
<p>Note that in the <code>nlm()</code> case a value of <code>code</code>
equal to 2 indicates &ldquo;probable&rdquo; convergence, and a value
of 3 indicates &ldquo;possible&rdquo; convergence.  However in this
context <code>converged</code> is set equal to <code>TRUE</code> <em>only</em>
if <code>code</code> is 1.
</p>
</td></tr>
<tr><td><code>nstep</code></td>
<td>

<p>The number of steps performed by the algorithm if the method
was <code>"EM"</code>, <code>"LM"</code> or <code>"SD"</code>.  The value of
<code>nstep</code> is set equal to the <code>iterations</code> component of
the value returned by <code>nlm()</code> if <code>method="bf"</code>.
</p>
</td></tr>
<tr><td><code>prior.emsteps</code></td>
<td>

<p>The number of EM steps that were taken before the method was
switched from <code>"EM"</code> to <code>"bf"</code> or to <code>"LM"</code>.
Present only in values returned under the <code>"bf"</code> or
<code>"LM"</code> methods after a switch from <code>"EM"</code> and is
equal to <code>0</code> if either of these methods was specified in
the initial call (rather than arising as the result of a switch).
</p>
</td></tr>
<tr><td><code>ylengths</code></td>
<td>

<p>Integer vector of the lengths of the observation sequences
(number of rows if the observations are in the form of
one or two column matrices).
</p>
</td></tr>
<tr><td><code>nafrac</code></td>
<td>

<p>A real number between 0 and 1 or a pair (two dimensional vector)
of such numbers.  Each number is the the fraction of missing values
if the corresponding components of the observations.
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>

<p>An object of class <code>"tidyList"</code>.  It is a tidied up version
of the observations; i.e. the observations <code>y</code> after the
application of the undocumented function <code>tidyList()</code>.
Present only if <code>keep.y</code> is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code>X</code></td>
<td>

<p>An object of class <code>"tidyList"</code>.  It is tidied up version
of the predictor matrix or list of predictor matrices; i.e. the
argument <code>X</code> after the application of <code>tidyList()</code>
(with argument <code>rp</code> set to <code>"predictor"</code>.  Present only
if <code>X</code> is supplied, is an appropriate argument, and if
<code>keep.X</code> is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code>parity</code></td>
<td>

<p>Character string; <code>"univar"</code> if the data were univariate,
<code>"bivar"</code> if they were bivariate.
</p>
</td></tr>
<tr><td><code>numeric</code></td>
<td>

<p>Logical scalar; <code>TRUE</code> if the (original) data were numeric,
<code>FALSE</code> otherwise.
</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>

<p>The value of AIC <code>= -2*log.like + 2*npar</code> for the fitted
model.
</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>

<p>The value of BIC <code>= -2*log.like + log(nobs)*npar</code> for the fitted
model.  In the forgoing <code>nobs</code> is the number of observations.
This is the number of <em>non-missing</em> values in <code>unlist(y)</code>
in the univariate setting and one half of this number in the
bivariate setting.
</p>
</td></tr>
<tr><td><code>args</code></td>
<td>

<p>A list of argument values supplied.  This component is
returned in the interest of making results reproducible.
It is also needed to facilitate the updating of a model
via the update method for the class <code>hmm.discnp</code>,
<code><a href="#topic+update.hmm.discnp">update.hmm.discnp</a>()</code>.
</p>
<p>It has components:
</p>

<ul>
<li> <p><code>method</code>
</p>
</li>
<li> <p><code>optimiser</code>
</p>
</li>
<li> <p><code>optimMethod</code>
</p>
</li>
<li> <p><code>stationary</code>
</p>
</li>
<li> <p><code>mixture</code>
</p>
</li>
<li> <p><code>cis</code>
</p>
</li>
<li> <p><code>tolerance</code>
</p>
</li>
<li> <p><code>itmax</code>
</p>
</li>
<li> <p><code>crit</code>
</p>
</li>
<li> <p><code>addIntercept</code>
</p>
</li></ul>

</td></tr>
</table>


<h3>Thanks</h3>

<p>A massive nest of bugs was eliminated in the transition from version
3.0-8 to version 3.0-9.  These bugs arose in the context of using
auxiliary predictor variables (argument <code>X</code>).  The handling of
such auxiliary predictors was completely messed up.  I am grateful
to Leah Walker for pointing out the problem to me.
</p>


<h3>Warnings</h3>

<p>The ordering of the (hidden) states can be arbitrary.  What the
estimation procedure decides to call &ldquo;state 1&rdquo; may not be
what <em>you</em> think of as being state number 1.  The ordering
of the states will be affected by the starting values used.
</p>
<p>Some experiences with using the <code>"ABSGRD"</code> stopping
criterion indicate that it may be problematic in the context of
discrete non-parametric distributions.  For example a value of
1854.955 was returned after 200 LM steps in one (non-convergent,
of course!)  attempt at fitting a model.  The stopping criterion
<code>"PCLL"</code> in this example took the &ldquo;reasonable&rdquo;
value of 0.03193748 when iterations ceased.
</p>


<h3>Notes &mdash; Various</h3>

<p>This function <em>used</em> to have an argument <code>newstyle</code>,
a logical scalar (defaulting to <code>TRUE</code>) indicating whether
(in the univariate setting) the emission probabilities
should be represented in &ldquo;logistic&rdquo; form.   (See
<b>Details</b>, <b>Univariate case:</b>, above.)  Now the
emission probabilities are <em>always</em> represented in the
&ldquo;logistic&rdquo; form.   The component <code>Rho</code> of the
starting parameter values <code>par0</code> may still be supplied
as a matrix of probabilities (with columns summing to 1), but
this component is converted (internally, silently) to the
logistic form.
</p>
<p>The object returned by this function also has (in the univariate
setting), in addition to the component <code>Rho</code>, a component
<code>Rho.matrix</code> giving the emission probabilities in the
more readily interpretable matrix-of-probabilities form. (See
<b>Value</b> above.)
</p>
<p>The package <em>used</em> to require the argument <code>y</code> to
be a <em>matrix</em> in the case of multiple observed sequences.
If the series were of unequal length the user was expected to
pad them out with NAs to equalize the lengths.
</p>
<p>The old matrix format for multiple observation sequences was
permitted for a while (and the matrix was internally changed into
a list) but this is no longer allowed.  If <code>y</code> is indeed
given as a matrix then this corresponds to a single observation
sequence and it must have one (univariate setting) or two
(bivariate setting) columns which constitute the observations
of the respective variates.
</p>
<p>If <code>K=1</code> then <code>tpm</code>, <code>ispd</code>, <code>converged</code>,
and <code>nstep</code> are all set equal to <code>NA</code> in the list
returned by this function.
</p>
<p>The estimate of <code>ispd</code> in the non-stationary setting
is inevitably very poor, unless the number of sequences of
observations (the length of the list <code>y</code>) is very large.
We have in effect &ldquo;less than one&rdquo; relevant observation for
each such sequence.
</p>
<p>The returned values of <code>tpm</code> and <code>Rho</code> (or the entries
of <code>Rho</code> when <code>Rho</code> is a list) have dimension names.
These are formed from the argument <code>yval</code> if this is
supplied, otherwise from the sorted unique values of the
observations in <code>y</code>.  Likewise the returned value of
<code>ispd</code> is a named vector, the names being the same as the
row (and column) names of <code>tpm</code>.
</p>
<p>If <code>method</code> is equal to <code>"EM"</code> there may be a
<em>decrease</em> (!!!) in the log likelihood at some EM step.
This is &ldquo;theoretically impossible&rdquo; but can occur in
practice due to an intricacy in the way that the EM algorithm
treats <code>ispd</code> when <code>stationary</code> is <code>TRUE</code>.
It turns out to be effectively impossible to maximise the expected
log likelihood unless the term in that quantity corresponding
to <code>ispd</code> is ignored (whence it <em>is</em> ignored).
Ignoring this term is &ldquo;asymptotically negligible&rdquo; but
can have the unfortunate effect of occasionally leading to a
decrease in the log likelihood.
</p>
<p>If such a decrease is detected, then the algorithm terminates
and issues a message to the effect that the decrease occurred.
The message suggests that another method be used and that perhaps
the results from the penultimate EM step (which are returned by
this function) be used as starting values.
</p>
<p>It seems to me that it <em>should</em> be the case that such a
decrease in the log likelihood can occur only if <code>stationary</code>
is <code>TRUE</code>.  However I have encountered instances in which
a decrease occurred when <code>stationary</code> was <code>FALSE</code>.
I have yet to figure out/track down what is going on here.
</p>


<h3>Note on <code>method</code></h3>

<p>If the <code>method</code> is <code>"EM"</code> it is actually possible
for the log likelihood to <em>decrease</em> at some EM step.
This is &ldquo;impossible in an ideal world&rdquo; but can happen
to the fact the EM algorithm, as implemented in this package
at least, cannot maximise the expected log likelihood if the
component corresponding to the initial state probability
distribution is taken into consideration.  This component
should ideally be maximised subject to the constraint that
<code>t(P)%*%ispd = ispd</code>, but this constraint seems to
effectively impossible to impose.  Lagrangian multipliers
don't cut it.  Hence the summand in question is ignored at
the M-step.  This usually works alright since the summand
is asymptotically negligible, but things can sometimes go
wrong.  If such a decrease occurs, an error is thrown.
</p>
<p>In previous versions of this package, instead of throwing
an error the <code>hmm()</code> function would automatically switch
to either the <code>"bf"</code> or the <code>"LM"</code> method, depending
whether a matrix <code>X</code> of auxiliary predictors is supplied,
starting from the penultimate parameter estimates produced
by the EM algorithm.   However this appears not to be a good
idea; those &ldquo;penultimate estimates&rdquo; appear not to be
good starting values for the other methods.  Hence an error
is now thrown and the user is explicitly instructed to invoke
a different method, &ldquo;starting from scratch&rdquo;.
</p>


<h3>Fitted Coefficients of the Predictors</h3>

<p>It is of course of interest to understand the meaning of the
coefficients that are fitted to the predictors in the model.
If <code>X</code> is supplied then the number of predictors is (as a rule)
one (for the intercept) plus the number of columns in each entry
of <code>X</code>.  We say &ldquo;as a rule&rdquo; because, e.g., the entries
of <code>X</code> could each have an &ldquo;intercept&rdquo; column, or the
<code>addIntercept</code> argument could be <code>FALSE</code>.  If <code>X</code>
is not supplied there is only one predictor, named <code>Intercept</code>.
</p>
<p>The interpretation of these predictor coefficients is a bit subtle.
To get an idea of what it's all about, consider the output from
example <code>4</code>.  (See <b>Examples</b>).  The fitted coefficients
in question are to be found in columns 3 and onward of the component
<code>Rho</code> of the object returned by <code>hmm()</code>.  In the context
of example <code>4</code>, this object is <code>fit.wap</code>.  (The suffix
<code>wap</code> stands for &ldquo;with auxiliary predictors&rdquo;.)
</p>
<pre>
  fit.wap$Rho
       y state Intercept     ma.com      nh.com     bo.com
  1   lo     1 1.3810463  0.4527982 -3.27161353 -1.9563915
  2  mlo     1 0.1255631 -1.1402546 -1.37713744  0.5946980
  3    m     1 0.7356526  0.1523734 -2.70841817 -0.1794645
  4  mhi     1 0.8479798 -0.2438988 -1.12544989 -0.9650320
  5   hi     1 0.0000000  0.0000000  0.00000000  0.0000000
  6   lo     2 3.9439410 -0.8355306 -0.77702276  1.4963631
  7  mlo     2 2.6189880 -1.9373885 -0.09190623  0.8316870
  8    m     2 2.1457317 -1.7276183  0.19524655 -0.3249485
  9  mhi     2 1.8834139 -1.3760011 -0.59806309  1.2828365
  10  hi     2 0.0000000  0.0000000  0.00000000  0.0000000
</pre>
<p>If you multiply the matrix consisting of the predictor coefficients
(columns 3 to 6 of <code>Rho</code> in this instance) times a vector of
predictors you get, for each state, the &ldquo;exponential form&rdquo;
of the probabilities (&ldquo;pre-probabilities&rdquo;) for each of the
possible <code>y</code>-values, given the vector of predictors.
</p>
<p>E.g. set <code>x &lt;- c(1,1,0,0)</code>. This vector picks up the intercept
and indicates that the Malabar outfall has been commissioned,
the North Head outfall has not been commissioned, and the Bondi
Offshore outfall has not been commissioned.
</p>
<p>Now set:
</p>
<pre>
    pp1 &lt;- (as.matrix(fit.wap$Rho)[,3:6]%*%x)[1:5]
    pp2 &lt;- (as.matrix(fit.wap$Rho)[,3:6]%*%x)[6:10]
</pre>
<p>Note that <code>pp1</code> consists of &ldquo;exponential
probabilities&rdquo; corresponding to state 1, and <code>pp2</code>
consists of &ldquo;exponential probabilities&rdquo; corresponding
to state 2.  To convert the foregoing pre-probabilities to the
actual probabilities of the <code>y</code>-values, we apply the &mdash;
undocumented &mdash; function <code>expForm2p()</code>:
</p>
<pre>
    p1 &lt;- expForm2p(pp1)
    p2 &lt;- expForm2p(pp2)
</pre>
<p>The value of <code>p1</code> is
</p>
<pre>
[1] 0.52674539 0.03051387 0.20456767 0.15400019 0.08417288
</pre>
<p>and that of <code>p2</code> is
</p>
<pre>
[1] 0.78428283 0.06926632 0.05322204 0.05819340 0.03503541
</pre>
<p>Note that <code>p1</code> and <code>p2</code> each sum to 1, as they should/must
do.  This says, e.g., that when the system is in state 2, and
Malabar has been commissioned but North Head and Bondi Offshore
have not, the (estimated) probability that <code>y</code> is <code>"mhi"</code>
(medium-high) is 0.05819340.
</p>
<p>It may be of some interest to test the hypothesis that the predictors
have any actual predictive power at all:
</p>
<pre>
    fit.nap &lt;- hmm(xxx,yval=Yval,K=2,verb=TRUE)
    # "nap" &lt;--&gt; no aux. preds
</pre>
<p>There is a bit of a problem here, in that the likelihood <em>decreases</em>
at EM step 65.  (See the warning message.)
</p>
<p>We can check on this problem by refitting using method=&quot;LM&quot;.
</p>
<pre>
    fit.nap.lm &lt;- hmm(xxx,yval=Yval,par0=fit.nap,method="LM",verb=TRUE)
</pre>
<p>Doing so produces only a small improvement in the log likelihood
(from -1821.425 to -1820.314), so we really could have ignored the
problem. We can now do <code>anova(fit.wap,fit.nap)</code> which gives
</p>
<pre>
    $stat
    [1] 153.5491

    $df
    [1] 24

    $pvalue
    [1] 7.237102e-21
</pre>
<p>Thus the p-value is effectively zero, saying that in this instance
the auxiliary predictors appear to have a &ldquo;significant&rdquo; impact on
the fit.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a><br />
</p>


<h3>References</h3>

<p>Rabiner, L. R., &quot;A tutorial on hidden Markov models and selected
applications in speech recognition,&quot; Proc. IEEE vol. 77,
pp. 257 &ndash; 286, 1989.
</p>
<p>Zucchini, W. and Guttorp, P., &quot;A hidden Markov model for
space-time precipitation,&quot; Water Resources Research vol.  27,
pp. 1917-1923, 1991.
</p>
<p>MacDonald, I. L., and Zucchini, W., &quot;Hidden Markov and Other
Models for Discrete-valued Time Series&quot;, Chapman &amp; Hall,
London, 1997.
</p>
<p>Liu, Limin, &quot;Hidden Markov Models for Precipitation in a Region
of Atlantic Canada&quot;, Master's Report, University of New Brunswick,
1997.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rhmm">rhmm</a>()</code>, <code><a href="#topic+mps">mps</a>()</code>,
<code><a href="#topic+viterbi">viterbi</a>()</code></p>


<h3>Examples</h3>

<pre><code class='language-R'># TO DO: Create one or more bivariate examples.
#
# The value of itmax in the following examples is so much
# too small as to be risible.  This is just to speed up the
# R CMD check process.
# 1.
Yval &lt;- LETTERS[1:10]
Tpm  &lt;- matrix(c(0.75,0.25,0.25,0.75),ncol=2,byrow=TRUE)
Rho  &lt;- cbind(c(rep(1,5),rep(0,5)),c(rep(0,5),rep(1,5)))/5
rownames(Rho) &lt;- Yval
set.seed(42)
xxx  &lt;- rhmm(ylengths=rep(1000,5),nsim=1,tpm=Tpm,Rho=Rho,yval=Yval,drop=TRUE)
fit  &lt;- hmm(xxx,par0=list(tpm=Tpm,Rho=Rho),itmax=10)
print(fit$Rho) # A data frame
print(cnvrtRho(fit$Rho)) # A matrix of probabilities
                         # whose columns sum to 1.

# 2.
# See the help for logLikHmm() for how to generate y.num.
## Not run: 
   fit.num     &lt;- hmm(y.num,K=2,verb=TRUE,itmax=10)
   fit.num.mix &lt;- hmm(y.num,K=2,verb=TRUE,mixture=TRUE,itmax=10)
   print(fit.num[c("tpm","Rho")])

## End(Not run)
# Note that states 1 and 2 get swapped.

# 3.
xxx &lt;- with(SydColDisc,split(y,f=list(locn,depth)))
Yval &lt;- c("lo","mlo","m","mhi","hi")
# Two states: above and below the thermocline.
fitSydCol &lt;- hmm(xxx,yval=Yval,K=2,verb=TRUE,itmax=10)

# 4.
X &lt;- split(SydColDisc[,c("ma.com","nh.com","bo.com")],
           f=with(SydColDisc,list(locn,depth)))
X &lt;- lapply(X,function(x){
                 as.matrix(as.data.frame(lapply(x,as.numeric)))-1})
fit.wap &lt;- hmm(xxx,yval=Yval,K=2,X=X,verb=TRUE,itmax=10)
# wap &lt;--&gt; with auxiliary predictors.

# 5.
## Not run:  # Takes too long.
fitlm &lt;- hmm(xxx,yval=Yval,K=2,method="LM",verb=TRUE)
fitem &lt;- hmm(xxx,yval=Yval,K=2,verb=TRUE)
# Algorithm terminates due to a decrease in the log likelihood
# at EM step 64.
newfitlm &lt;- hmm(xxx,yval=Yval,par0=fitem,method="LM",verb=TRUE)
# The log likelihood improves from -1900.988 to -1820.314

## End(Not run)

# 6.
fitLesCount &lt;- hmm(lesionCount,K=2,itmax=10) # Two states: relapse and remission.
</code></pre>

<hr>
<h2 id='hmm.discnp-internal'>Internal hmm.discnp functions.</h2><span id='topic++5B.multipleHmmDataSets'></span><span id='topic+check.yval'></span><span id='topic+checkConstColumns'></span><span id='topic+checkStartVal'></span><span id='topic+checkyXoK'></span><span id='topic+derivf'></span><span id='topic+derivp'></span><span id='topic+derivpi'></span><span id='topic+ell'></span><span id='topic+expForm2p'></span><span id='topic+ffun'></span><span id='topic+forgethgl'></span><span id='topic+orgethgl'></span><span id='topic+rgethgl'></span><span id='topic+get.hgl'></span><span id='topic+get.gl'></span><span id='topic+get.hgl'></span><span id='topic+get.l'></span><span id='topic+getIspd'></span><span id='topic+getRho'></span><span id='topic+getTpm'></span><span id='topic+hmmBD'></span><span id='topic+hmmBI'></span><span id='topic+hmmNumOpt'></span><span id='topic+hmmLM'></span><span id='topic+hmmSD'></span><span id='topic+hmmUV'></span><span id='topic+init.all'></span><span id='topic+lmstep'></span><span id='topic+lse'></span><span id='topic+msRho'></span><span id='topic+makeDat'></span><span id='topic+ordinal'></span><span id='topic+ordinalsuffix'></span><span id='topic+paramExtract'></span><span id='topic+p2expForm'></span><span id='topic+phi2rho'></span><span id='topic+predictEngineHmmDiscnp'></span><span id='topic+recurse'></span><span id='topic+reparam'></span><span id='topic+revise.ispd'></span><span id='topic+revise.rho'></span><span id='topic+revise.tpm'></span><span id='topic+rho2phi'></span><span id='topic+simference'></span><span id='topic+steepest'></span><span id='topic+tidyList'></span><span id='topic+zeta2p'></span><span id='topic+zeta2Rho'></span>

<h3>Description</h3>

<p>Internal hmm.discnp functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multipleHmmDataSets'
x[i]
check.yval(yval, Rho, type, warn=TRUE)
checkConstColumns(y,prednames)
checkStartVal(par0,K,indep,yval,rand.start,mixture,prednames)
checkyXoK(y, X)
derivf(theta, K)
derivp(theta, K)
derivpi(ispd, tpm, npar, dp)
ell(phi, G)
expForm2p(x)
ffun(Dat, Rho, type)
forgethgl(fy, y, ymiss, tpm, ispd, d1pi, d2pi, npar, d1p,
          d2p, m, d1f, d2f)
orgethgl(fy, y, ymiss, tpm, xispd, d1pi, d2pi, npar, d1p,
          d2p, m, d1f, d2f)
rgethgl(fy, y, ymiss, tpm, xispd, d1pi, d2pi, npar, d1p,
          d2p, m, d1f, d2f)
get.gl(theta, K, y)
get.hgl(theta, K, y, hglmethod)
get.l(theta, K, y)
getIspd(pars, K)
getRho(pars, K, rhovals, stationary, prednames)
getTpm(pars, K, stationary)
hmmBD(y, par0, K, stationary,
      mixture, cis, tolerance, digits, verbose,
      itmax, crit, bicm)
hmmBI(y, par0, K, stationary,
      mixture, cis, tolerance, digits, verbose,
      itmax, crit, bicm)
hmmNumOpt(Dat, par0, stationary, verbose, itmax, bicm, rhovals, npar, optimiser,
          optimMethod, hessian=FALSE, ...)
hmmLM(y, par0, itmax=200, crit, lmc=10, tolerance,
      bicm, rhovals, hglmethod, digits=NULL, verbose=FALSE) 
hmmSD(y, par0, itmax=200, crit, tolerance,
      bicm, rhovals, hglmethod, digits=NULL, verbose=FALSE) 
hmmUV(y, par0, K, method,
      hglmethod, optimiser, optimMethod, stationary,
      mixture, cis, tolerance, digits, verbose,
      itmax, crit, bicm, X, addIntercept, lmc, hessian, ...)
init.all(K, rand.start, mixture, indep, yval, prednames)
lmstep(theta, K, y, lmc, hglmethod)
lse(z)
msRho(Rho0, G)
makeDat(y, X, addIntercept)
ordinal(k)
ordinalsuffix(k)
paramExtract(Rho)
p2expForm(x)
phi2rho(phi, ijk)
predictEngineHmmDiscnp(stateProbs,Rho,numb,drop)
recurse(fy, tpm, ispd, lns)
reparam(object, expForm=TRUE, stationary=NULL)
revise.ispd(tpm=NULL, gamma=NULL, lns=NULL, cis=TRUE)
revise.rho(Dat, gamma, type)
revise.tpm(xi, mixture)
rho2phi(Rho)
simference(object, expForm=TRUE, seed=NULL,nsim=100,verbose=TRUE)
steepest(K, y, theta)
tidyList(y, rp=c("response","predictor"),addIntercept=NULL, yval=NULL)
</code></pre>


<h3>Details</h3>

<p>These functions are auxiliary and are not intended to be called
by the user.
</p>

<hr>
<h2 id='hydroDat'>
Canadian hydrological data sets.
</h2><span id='topic+linLandFlows'></span><span id='topic+ftLiardFlows'></span><span id='topic+portMannFlows'></span><span id='topic+portMannSedLoads'></span><span id='topic+portMannSedCon'></span>

<h3>Description</h3>

<p>Five data sets obtained from the &ldquo;HYDAT&rdquo; database,
Environment and Climate Change Canada's database of historical
hydrometric data.  The data were obtained using the <code>tidyhydat</code>
package.  The data have been trimmed so that there are no gaps in
the observation dates and are presented in &ldquo;raw&rdquo; form and in
discretised form as deciles of the residuals (difference between
raw values and the daily mean over years).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    data("linLandFlows")
    data("ftLiardFlows")
    data("portMannFlows")
    data("portMannSedLoads")
    data("portMannSedCon")
</code></pre>


<h3>Format</h3>

<p>Data frames with observations on the following 3 variables.
</p>

<dl>
<dt><code>Date</code></dt><dd><p>Dates on which observations were made.</p>
</dd>
<dt><code>Value</code></dt><dd><p>Numeric vector of observation values.</p>
</dd>
<dt><code>mean</code></dt><dd><p>The mean over years of <code>Value</code>.</p>
</dd>
<dt><code>resid</code></dt><dd><p>The difference <code>Value - mean</code>.</p>
</dd>
<dt><code>deciles</code></dt><dd><p>A factor with levels <code>d1</code>, ..., <code>d10</code>,
which are the deciles of the variable <code>resid</code></p>
</dd>
</dl>



<h3>Details</h3>

<p>The variable <code>mean</code> was calculated as follows:
</p>
<pre>
        yday &lt;- as.POSIXlt(X$Date)$yday
        mn   &lt;- tapply(X$Value,yday,mean,na.rm=TRUE)
        mean &lt;- mn[as.character(yday)]
   </pre>
<p>where <code>X</code> is the data set being processed.
</p>
<p>The data set <code>linLandFlows</code> originally consisted of 2008 observations;
there were 1980 observations after &ldquo;trimming&rdquo;.
The data set <code>ftLiardFlows</code> originally consisted of 22364 observations;
there were 11932 observations after &ldquo;trimming&rdquo;.
The data set <code>portMannFlows</code> originally consisted of 6455 observations;
there were 3653 observations after &ldquo;trimming&rdquo;.
The data set <code>portMannSedLoads</code> consists of 2771 observations;
no observations were trimmed.
The data set <code>portMannSedCon</code> consists of 4597 observations;
no observations were trimmed.
</p>
<p>The units of the &ldquo;Flows&rdquo; variables are cubic metres per
second (<code class="reqn">m^3/s</code>); the units of &ldquo;portMannSedLoads&rdquo;
are tonnes; the units of &ldquo;portMannSedCon&rdquo; are milligrams
per litre (mg/l).
</p>
<p>The &ldquo;linLandFlows&rdquo; data were obtained at the Lindberg
Landing hydrometric station on the Liard River in the Northwest
Territories of Canada.  The &ldquo;ftLiardFlows&rdquo; data were
obtained at the Fort Liard hydrometric station on the Liard River
in the Northwest Territories of Canada.  The &ldquo;portMann&rdquo;
data were obtained at the hydrometric station located at the
Port Mann pumping station on the Fraser River in the Province
of British Columbia in Canada.
</p>


<h3>Source</h3>

<p>Environment and Climate Change Canada's database &ldquo;HYDAT&rdquo;,
a database of historical hydrometric data.  The data were obtained
vis the <code>tidyhydat</code> package, which is available from &ldquo;CRAN&rdquo;,
<code>https://cran.r-project.org</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- hmm(linLandFlows$deciles,K=4,itmax=10)
</code></pre>

<hr>
<h2 id='lesionCount'>Multiple sclerosis lesion counts for three patients.</h2><span id='topic+lesionCount'></span>

<h3>Description</h3>

<p>Lesion counts for three multiple sclerosis patients.
The counts were obtained by magnetic resonance imaging,
and were observed at monthly intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  lesionCount
</code></pre>


<h3>Format</h3>

<p>A list with three components each component being the sequence
of counts for a given patient and consisting of a vector with
non-negative integer entries.
</p>


<h3>Modelling</h3>

<p>The hidden Markov models applied to these data by Albert et al.
and by MacKay and Petkau were much more complex and elaborate than
those fitted in the examples in this package.  See the references
for details.
</p>


<h3>Source</h3>

<p>The data were originally studied by Albert et al., (1994).
They are were also analyzed by Altman and Petkau (2005).
The data were kindly provided by Prof. Altman.
</p>


<h3>References</h3>

<p>Albert, P. S., McFarland, H. F., Smith, M. E., and Frank, J. A.
Time series for modelling counts from a relapsing-remitting disease:
application to modelling disease activity in multiple sclerosis.
<em>Statistics in Medicine</em> <b>13</b> (1994) 453&ndash;466.
</p>
<p>Altman, Rachel MacKay, and Petkau, A. John.  Application
of hidden Markov models to multiple sclerosis lesion count data.
<em>Statistics in Medicine</em> <b>24</b> (2005) 2335&ndash;2344.
</p>

<hr>
<h2 id='logLikHmm'>
Log likelihood of a hidden Markov model
</h2><span id='topic+logLikHmm'></span>

<h3>Description</h3>

<p>Calculate the log likelihood of a hidden Markov model with
discrete non-parametric observation distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLikHmm(y, model=NULL, tpm=NULL, ispd=NULL, Rho=NULL, X=NULL,
          addIntercept=NULL, warn=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLikHmm_+3A_y">y</code></td>
<td>

<p>A vector, or list of vectors, or a one or two column matrix or a
list of such matrics, whose entries consist of observations from
a hidden Markov model with discrete non-parametric observation
distributions.
</p>
</td></tr>
<tr><td><code id="logLikHmm_+3A_model">model</code></td>
<td>
<p>An object specifying a hidden Markov model, usually
returned by <code><a href="#topic+hmm">hmm</a>()</code>.
</p>
</td></tr>
<tr><td><code id="logLikHmm_+3A_tpm">tpm</code></td>
<td>
<p>The transition probability matrix of the Markov chain.
Ignored (and extracted from <code>model</code>) if <code>model</code>
is non-<code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="logLikHmm_+3A_ispd">ispd</code></td>
<td>
<p>The vector of probabilities specifying the initial
state probability distribution, or a matrix each of whose columns
is a trivial (&ldquo;delta function&rdquo;) vector specifying the
&ldquo;most probable&rdquo; initial state for each observation sequence.
If <code>ispd</code> is missing then <code>ispd</code> is calculated as the
stationary distribution determined by <code>tpm</code>.  Ignored (and
extracted from <code>model</code>) if <code>model</code> is non-<code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="logLikHmm_+3A_rho">Rho</code></td>
<td>
<p>An object specifying the &ldquo;emission&rdquo; probabilities
of the observations.  (See the <b>Details</b> in the help for
<code><a href="#topic+hmm">hmm</a>()</code>.)  Ignored (and extracted from <code>model</code>)
if <code>model</code> is non-<code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="logLikHmm_+3A_x">X</code></td>
<td>
<p>An optional <em>numeric</em> matrix, or a list of such
matrices, of <em>predictors</em>.  The use of such predictors is
(currently, at least) applicable only in the univariate emissions
setting.  If <code>X</code> is a list it must be of the same length as
<code>y</code> and all entries of this list must have the same number
of columns.  The number of rows of each entry must be equal to
the length of the corresponding entry of <code>y</code>. If <code>X</code>
is a matrix then <code>y</code> should be a vector or one-column matrix
(or a list with a single entry equal to such).
</p>
</td></tr>
<tr><td><code id="logLikHmm_+3A_addintercept">addIntercept</code></td>
<td>

<p>Logical scalar.  See the documentation of <code><a href="#topic+hmm">hmm</a>()</code>.
If this argument is not specified, and if <code>model</code> is
<code>NULL</code> then an error is thrown.
</p>
</td></tr>
<tr><td><code id="logLikHmm_+3A_warn">warn</code></td>
<td>
<p>Logical scalar; should a warning be issued if <code>Rho</code>
hasn't got relevant dimension names?  (Note that if this is so,
then the corresponding dimension names are formed from the sorted
unique values of <code>y</code> or of the appropriate column(s) of <code>y</code>.
And if <em>this</em> is so, then the user should be sure that the
ordering of the entries of <code>Rho</code> corresponds properly to the
the sorted unique values of <code>y</code>.)  This argument is passed
to the utility function <code>check.yval()</code> which actually issues
the warning if <code>warn=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>y</code> is not provided the function simply returns the
<code>log.like</code> component of <code>model</code> (which could be
<code>NULL</code> if <code>model</code> was not produced by <code>hmm()</code>.
</p>
<p>The observation values (the entries of the vector or matrix <code>y</code>,
or of the vectors or matrices which constitute the entries of
<code>y</code> if <code>y</code> is a list) must be consistent with the
appropriate dimension names of <code>Rho</code> or of its entries when
<code>Rho</code> is a list.  More specifically, if <code>Rho</code> has dimension
names (or its entries have dimension names) then the observation
values must all be found as entries of the appropriate dimension
name vector.  If a vector of dimension names is <code>NULL</code> then
the corresponding dimension must be equal to the number of unique
observations of the appropriate variate.  integers between <code>1</code>
and <code>nrow(Rho)</code>.
</p>


<h3>Value</h3>

<p>The loglikehood of <code>y</code> given the parameter values specified
in <code>par</code>.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a><br />
</p>


<h3>References</h3>

<p>See <code><a href="#topic+hmm">hmm</a>()</code> for references.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmm">hmm</a>()</code>, <code><a href="#topic+pr">pr</a>()</code>, <code><a href="#topic+sp">sp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># TO DO:  One or more bivariate examples.
P &lt;- matrix(c(0.7,0.3,0.1,0.9),2,2,byrow=TRUE)
R &lt;- matrix(c(0.5,0,0.1,0.1,0.3,
              0.1,0.1,0,0.3,0.5),5,2)
set.seed(42)
lll   &lt;- sample(250:350,20,TRUE)
set.seed(909)
y.num &lt;- rhmm(ylengths=lll,nsim=1,tpm=P,Rho=R,drop=TRUE)
set.seed(909)
y.let &lt;- rhmm(ylengths=lll,nsim=1,tpm=P,Rho=R,yval=letters[1:5],drop=TRUE)
row.names(R) &lt;- 1:5
ll1   &lt;- logLikHmm(y.num,tpm=P,Rho=R)
row.names(R) &lt;- letters[1:5]
ll2   &lt;- logLikHmm(y.let,tpm=P,Rho=R)
ll3   &lt;- logLikHmm(y.let,tpm=P,Rho=R,ispd=c(0.5,0.5))
fit   &lt;- hmm(y.num,K=2,itmax=10)
ll4   &lt;- logLikHmm(y.num,fit) # Use the fitted rather than the "true" parameters.
</code></pre>

<hr>
<h2 id='misstify'>
Insert missing values.
</h2><span id='topic+misstify'></span>

<h3>Description</h3>

<p>Insert missing values into data simulated by <code>rhmm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>misstify(y, nafrac, fep = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="misstify_+3A_y">y</code></td>
<td>

<p>A data set (vector or matrix with one or two columns, whose
entries consitute discrete data, or a list of such vectors
or matrices) or a list of such data sets (objects of class
<code>"multipleHmmDataSets"</code> such as might be generated by
<code><a href="#topic+rhmm">rhmm</a>()</code>
</p>
</td></tr>
<tr><td><code id="misstify_+3A_nafrac">nafrac</code></td>
<td>
<p>A numeric vector, some entries of which could
be ignored. (See below.) Those which do not get ignored
must be probabilities <em>strictly</em> less than 1.  (Having
<em>everything</em> missing makes no sense!)
</p>
<p>The vector <code>nafrac</code> will be replicated to have
an &ldquo;appropriate&rdquo; length.  If <code>y</code> is of class
<code>"multipleHmmDataSets"</code> then this length is <code>length(y)</code>
if the data are univariate and is <code>2*length(y)</code> if the data
are bivariate.  In the former case the entries of the replicated
vector from the fraction of missing values in the corresponding
data set.  In the latter case the odd numbered entries form the
fraction of missing values for the first variable and the even
numbered entries the fraction for the second variable.  If <code>y</code>
is not of class <code>"multipleHmmDataSets"</code> then this length is
either 1 (univariate case) or 2 (bivariate case).
</p>
<p>Note that replication discards entries that are not needed to
make up the required length, and such entries are thereby ignored.
E.g. <code>rep(c(0.2,0.7,1.6),length=2)</code> yields <code>[1] 0.2 0.7</code>,
i.e. the entry <code>1.6</code> is ignored.
</p>
<p>The fraction(s) of missing values in a given data set may be
determined by <code><a href="#topic+nafracCalc">nafracCalc</a>()</code>.
</p>
</td></tr>
<tr><td><code id="misstify_+3A_fep">fep</code></td>
<td>

<p>&ldquo;First entry present&rdquo;.  A list with one or two
entries, the first being a logical scalar (which might be named
<code>"present"</code>.  If there is a second entry it should be a scalar
probability (which might be named <code>"p2"</code>).  In an application
of interest, observation sequences always begin at an observed
event, i.e. at a time point at which the &ldquo;emission&rdquo; has at
least one non-missing value.  If <code>fep[[1]]</code> is <code>TRUE</code>
the <code>NA</code>s will be inserted in such a way that the resulting
data have this characteristic.  If <code>fep</code> is left <code>NULL</code>
then its first (possibly only) entry is set to <code>TRUE</code>.
</p>
<p>For <em>bivariate</em> data, <code>fep[[2]]</code> specifies the probabilty
that <em>both</em> values of the initial pair of observations are
non-missing.  In this case one of the entries of the initial pair
is chosen to be &ldquo;potentially&rdquo; missing, with probabilities
<code>nafrac/sum(nafrac)</code>.  This entry is left non-missing with
probability <code>fep[[2]]</code>.  (The other entry is always left
non-missing.)
</p>
<p>If the data are univariate or if <code>fep[[1]]</code> is <code>FALSE</code>,
then <code>fep[[2]]</code> is ignored.  If the data are bivariate
and <code>fep[[2]]</code> is not specified, it defaults to the (estimated)
conditional probability that both entries of the initial pair
of observations are present given that at least one is present,
under the assumption of independence of these events.  I.e. it is
set equal to <code>prod(1-nafrac)/(1-prod(1-nafrac))</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with a structure similar to that of <code>y</code>, containing
the same data as <code>y</code> but with some of these data having been
replaced by missing values (<code>NA</code>).  In particular, if <code>y</code>
is of class <code>"multipleHmmDataSets"</code> then so is the returned
value.
</p>
<p>Note that <code><a href="#topic+rhmm">rhmm</a>()</code> calls upon <code>misstify()</code> to effect
the replacement of a certain fraction of the simulated observations
by missing values.  If <code>rhmm()</code> is applied to a fitted model,
then by default, this &ldquo;certain fraction&rdquo; is determined, using
<code>nafracCalc()</code>, from the data set to which the model was fitted.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a><br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rhmm">rhmm</a>()</code> <code><a href="#topic+nafracCalc">nafracCalc</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- matrix(c(0.7,0.3,0.1,0.9),2,2,byrow=TRUE)
R &lt;- matrix(c(0.5,0,0.1,0.1,0.3,
              0.1,0.1,0,0.3,0.5),5,2)
set.seed(42)
lll   &lt;- sample(250:350,20,TRUE)
y1    &lt;- rhmm(ylengths=lll,nsim=1,tpm=P,Rho=R)
y1m   &lt;- misstify(y1,nafrac=0.5,fep=list(TRUE))
y2    &lt;- rhmm(ylengths=lll,nsim=5,tpm=P,Rho=R)
set.seed(127)
y2m   &lt;- misstify(y2,nafrac=0.5,fep=list(TRUE))
nafracCalc(y2m) # A list all of whose entries are close to 0.5.
set.seed(127)
y2ma  &lt;- lapply(y2,misstify,nafrac=0.5,fep=list(TRUE))
## Not run: 
    nafracCalc(y2ma) # Throws an error.

## End(Not run)
sapply(y2ma,nafracCalc) # Effectively the same as nafracCalc(y2m).
</code></pre>

<hr>
<h2 id='mps'> Most probable states. </h2><span id='topic+mps'></span>

<h3>Description</h3>

<p>Calculates the most probable hidden state underlying each
observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mps(y, model = NULL, tpm, Rho, ispd=NULL, warn=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mps_+3A_y">y</code></td>
<td>
<p>The observations for which the underlying most
probable hidden states are required.  May be a sequence
of observations in the form of a vector or a one or two
column matrix, or a list each component of which constitutes
a (replicate) sequence of observations.  It may also be
an object of class <code>"multipleHmmDataSets"</code> as returned
by <code><a href="#topic+rhmm">rhmm</a>()</code> with <code>nsim&gt;1</code>.
</p>
<p>If <code>y</code> is missing, it is extracted from
<code>model</code> (whence it will <em>not</em> be of class
<code>"multipleHmmDataSets"</code>!) provided that <code>model</code> and
its <code>y</code> component are not <code>NULL</code>.  Otherwise an error
is given.
</p>
</td></tr>
<tr><td><code id="mps_+3A_model">model</code></td>
<td>
<p> An object describing a fitted hidden Markov
model, as returned by <code><a href="#topic+hmm">hmm</a>()</code>.  In order to
make any kind of sense, <code>model</code> should bear some
reasonable relationship to <code>y</code>.
</p>
</td></tr>
<tr><td><code id="mps_+3A_tpm">tpm</code></td>
<td>
<p> The transition probability matrix for a hidden
Markov model; ignored if <code>model</code> is non-null. Should
bear some reasonable relationship to <code>y</code>.
</p>
</td></tr>
<tr><td><code id="mps_+3A_rho">Rho</code></td>
<td>
<p>An object specifying the probability distributions of
the observations (&ldquo;emission&rdquo; probabilities) for a hidden
Markov model.  See <code><a href="#topic+hmm">hmm</a>()</code>.  Ignored if <code>model</code>
is non-null. Should bear some reasonable relationship to <code>y</code>.
</p>
</td></tr>
<tr><td><code id="mps_+3A_ispd">ispd</code></td>
<td>
<p>A vector specifying the initial state probability
distribution for a hidden Markov model, or a matrix each of whose
columns are trivial (&ldquo;delta function&rdquo;) vectors specifying
the &ldquo;most probable&rdquo; initial state for each observation
sequence.
</p>
<p>This argument is ignored if <code>model</code> is non-null. It should
bear some reasonable relationship to <code>y</code>.  If both <code>ispd</code>
and <code>model</code> are <code>NULL</code> then <code>ispd</code> is taken to
be the stationary distribution of the chain, calculated from
<code>tpm</code>.
</p>
</td></tr>
<tr><td><code id="mps_+3A_warn">warn</code></td>
<td>
<p>Logical scalar; in the bivariate setting, should a
warning be issued if the two matrices constituting <code>Rho</code>
(bivariate independent case) or the array constituting <code>Rho</code>
(bivariate dependent case) have not got relevant dimension names?
(Note that if this is so, then the corresponding dimension names
are formed from the sorted unique values of the appropriate
columns of <code>y</code>.  And if <em>this</em> is so, then the user
should be sure that the ordering of the entries of <code>Rho</code>
corresponds properly to the the sorted unique values of <code>y</code>.)
This argument is passed to the utility function <code>check.yval()</code>
which actually issues the warning if <code>warn=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each <code class="reqn">t</code> the maximum value of <code class="reqn">\gamma_t(i)</code>,
i.e. of the (estimated) probability that the state at time <code class="reqn">t</code>
is equal to <code class="reqn">i</code>, is calculated, and the value of the state
with the  corresponding index is returned.
</p>


<h3>Value</h3>

<p>If <code>y</code> is a single observation sequence, then the
value is a vector of corresponding most probable states.
</p>
<p>If <code>y</code> is a list of replicate sequences, then the value is
a list, the <code class="reqn">j</code>-th entry of which constitutes the vector of
most probable states underlying the <code class="reqn">j</code>-th replicate sequence.
</p>
<p>If <code>y</code> is of class <code>"multipleHmmDataSets"</code> then the
value returned is a list of lists of the sort described above.
</p>


<h3>Warning</h3>

<p>The <em>sequence of most probable states</em> as calculated by this
function will not in general be the <em>most probable sequence of
states</em>.  It may not even be a <em>possible</em> sequence of states.
This function looks at the state probabilities separately for each
time <code class="reqn">t</code>, and not at the states in their sequential context.
</p>
<p>To obtain the most probable sequence of states use
<code><a href="#topic+viterbi">viterbi</a>()</code>.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a><br />
</p>


<h3>References</h3>

<p>Rabiner, L. R., &quot;A tutorial on hidden Markov models and
selected applications in speech recognition,&quot; Proc. IEEE vol. 77,
pp. 257 &ndash; 286, 1989.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmm">hmm</a>()</code>, <code><a href="#topic+rhmm">rhmm</a>()</code>,
<code><a href="#topic+viterbi">viterbi</a>()</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
P &lt;- matrix(c(0.7,0.3,0.1,0.9),2,2,byrow=TRUE)
rownames(P) &lt;- 1:2
R &lt;- matrix(c(0.5,0,0.1,0.1,0.3,
              0.1,0.1,0,0.3,0.5),5,2)
set.seed(42)
lll   &lt;- sample(250:350,20,TRUE)
set.seed(909)
y.num &lt;- rhmm(ylengths=lll,nsim=1,tpm=P,Rho=R,drop=TRUE)
fit.num &lt;- hmm(y.num,K=2,verb=TRUE)
s.1 &lt;- mps(y.num,fit.num)
s.2 &lt;- mps(y.num,tpm=P,ispd=c(0.25,0.75),Rho=R)
# The order of the states has got swapped; 
# note that ifelse(s.1[[1]]=="1","2","1") is much
# more similar to s.2[[1]] than is s.1[[1]].

## End(Not run)
</code></pre>

<hr>
<h2 id='nafracCalc'>
Calculate fractions of missing values.
</h2><span id='topic+nafracCalc'></span>

<h3>Description</h3>

<p>Calculate the fraction (univariate case) or fractions (bivariate
case) of missing values in the data or in each component of the
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nafracCalc(y,drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nafracCalc_+3A_y">y</code></td>
<td>

<p>A vector or a one or two column matrix of discrete data or a
list of such vectors or matrices, or a <em>list</em> of such lists
(an object of class <code>"multipleHmmDataSets"</code> such as might
be produced by <code><a href="#topic+rhmm">rhmm</a>()</code>).
</p>
</td></tr>
<tr><td><code id="nafracCalc_+3A_drop">drop</code></td>
<td>

<p>Logical scalar. If <code>y</code> is of class
<code>"multipleHmmDataSets"</code> but actually consists of a
single data set, and if <code>drop</code> is <code>TRUE</code>, then the
returned value is not a list but rather the single component
that such a list &ldquo;would have had&rdquo; were <code>drop</code> equal
to <code>FALSE</code>.  This argument is ignored if <code>y</code> is not of
class <code>"multipleHmmDataSets"</code> or has length greater than 1.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>y</code> is <em>not</em> of class <code>"multipleHmmDataSets"</code>,
then the returned value is a scalar (between 0 and 1) if the data
are univariate or a pair (2-vector) of such scalars if the data
are bivariate.  The values are equal to the ratios of the total
count of missing values in the appropriate column to the total
number of observations.
</p>
<p>If <code>y</code> <em>is</em> of class <code>"multipleHmmDataSets"</code>,
and if <code>y</code> has length greater than 1 or <code>drop</code> is
<code>FALSE</code>, then the returned value is a <em>list</em> of such
scalars or 2-vectors, each corresponding to one of the data sets
constituting <code>y</code>.  If <code>y</code> has length equal to 1 and
<code>drop</code> is <code>TRUE</code>, then the returned value is the same
as if codey were not of class <code>"multipleHmmDataSets"</code>.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a><br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rhmm">rhmm</a>()</code> <code><a href="#topic+misstify">misstify</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xxx &lt;- with(SydColDisc,split(y,f=list(locn,depth)))
nafracCalc(xxx) # 0.7185199
</code></pre>

<hr>
<h2 id='pr'>
Probability of state sequences.
</h2><span id='topic+pr'></span>

<h3>Description</h3>

<p>Calculates the conditional probability of one or more state sequences,
given the corresponding observations sequences (and the model
parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr(s, y, model=NULL, tpm, Rho, ispd=NULL, warn=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_+3A_s">s</code></td>
<td>

<p>A sequence of states of the underlying Markov chain, or
a list of such sequences or a list of lists (!!!) of such
sequences.
</p>
</td></tr>
<tr><td><code id="pr_+3A_y">y</code></td>
<td>

<p>A data set to which a hidden Markov model might be fitted,
or a collection of such data sets in the form of an object
of class <code>"multipleHmmDataSets"</code> as returned by <code>rhmm()</code>
if the argument <code>nsim</code> is greater than 1.  In this latter
case <code>s</code> must be a list of the same length as <code>y</code>,
and <code>pr()</code> is applied recursively to each pair of entries
of <code>s</code> and <code>y</code>.
</p>
<p>If <code>y</code> consists of a single observation sequence, it is used
with each of the state sequences in <code>s</code> in turn.  Otherwise
the length of the list <code>y</code> must be the same as the length of
the list <code>s</code>. (If not, then an error is given).  If <code>y</code>
is missing, it is extracted from <code>model</code> (whence it will
<em>not</em> be of class <code>"multipleHmmDataSets"</code>!) provided
that <code>model</code> and its <code>y</code> component are not <code>NULL</code>.
Otherwise an error is given.
</p>
</td></tr>
<tr><td><code id="pr_+3A_model">model</code></td>
<td>

<p>An object of class <code>hmm.discnp</code> as returned by
<code><a href="#topic+hmm">hmm</a>()</code>.
</p>
</td></tr>
<tr><td><code id="pr_+3A_tpm">tpm</code></td>
<td>

<p>The transition probability matrix of the chain.  Ignored (and
extracted from <code>model</code> instead) if <code>model</code> is not
<code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="pr_+3A_rho">Rho</code></td>
<td>

<p>An object specifying the &ldquo;emission&rdquo; probabilities of
observations, given the underlying state.  See <code><a href="#topic+hmm">hmm</a>()</code>.
Ignored (and extracted from <code>model</code> instead) if <code>model</code>
is not <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="pr_+3A_ispd">ispd</code></td>
<td>

<p>The vector specifying the initial state probability distribution
of the Markov chain.  Ignored (and extracted from <code>model</code>
instead) if <code>model</code> is not <code>NULL</code>.  If both <code>ispd</code>
and <code>model</code> are NULL then <code>ispd</code> is taken to be the
stationary distribution of the chain, calculated from <code>tpm</code>.
</p>
</td></tr>
<tr><td><code id="pr_+3A_warn">warn</code></td>
<td>
<p>Logical scalar; should a warning be issued if <code>Rho</code>
hasn't got relevant dimension names?  (Note that if this is so,
then the corresponding dimension names are formed from the sorted
unique values of <code>y</code> or of the appropriate column(s) of <code>y</code>.
And if <em>this</em> is so, then the user should be sure that the
ordering of the entries of <code>Rho</code> corresponds properly to the
the sorted unique values of <code>y</code>.)  This argument is passed
to the utility function <code>check.yval()</code> which actually issues
the warning if <code>warn=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The probability of <code>s</code> given <code>y</code>, or a vector of such
probabilities if <code>s</code> and <code>y</code> are lists, or a list of
such vectors if <code>y</code> is of class <code>"multipleHmmDataSets"</code>.
</p>


<h3>Warning</h3>

<p>The conditional probabilities will be tiny if the sequences
involved are of any substantial length.  Underflow may be a
problem.  The implementation of the calculations is not
sophisticated.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a><br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmm">hmm</a>()</code>, <code><a href="#topic+mps">mps</a>()</code>,
<code><a href="#topic+viterbi">viterbi</a>()</code>, <code><a href="#topic+sp">sp</a>()</code>,
<code><a href="#topic+fitted.hmm.discnp">fitted.hmm.discnp</a>()</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
P &lt;- matrix(c(0.7,0.3,0.1,0.9),2,2,byrow=TRUE)
R &lt;- matrix(c(0.5,0,0.1,0.1,0.3,
              0.1,0.1,0,0.3,0.5),5,2)
set.seed(42)
lll   &lt;- sample(250:350,20,TRUE)
set.seed(909)
y.num &lt;- rhmm(ylengths=lll,nsim=1,tpm=P,Rho=R,drop=TRUE)
fit.num &lt;- hmm(y.num,K=2,keep.y=TRUE,verb=TRUE)
# Using fitted parmeters.
s.vit.1   &lt;- viterbi(y.num,fit.num)
pr.vit.1  &lt;- pr(s.vit.1,model=fit.num)
# Using true parameters from which y.num was generated.
s.vit.2   &lt;- viterbi(y.num,tpm=P,Rho=R)
pr.vit.2  &lt;- pr(s.vit.2,y.num,tpm=P,Rho=R)
set.seed(202)
y.mult &lt;- rhmm(fit.num,nsim=4)
s.vit.3 &lt;- viterbi(y.mult,tpm=fit.num$tpm,Rho=fit.num$Rho)
pr.vit.3  &lt;- pr(s.vit.3,y.mult,tpm=fit.num$tpm,Rho=fit.num$Rho)

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.hmm.discnp'>
Predicted values of a discrete non-parametric hidden Markov
model.
</h2><span id='topic+predict.hmm.discnp'></span>

<h3>Description</h3>

<p>Calculates predicted values given a specification of a discrete
non-parametric hidden Markov model.  The specification may be
provided in the form of a <code>hmm.discnp</code> object as returned
by <code>hmm()</code> or in the form of &ldquo;components&rdquo; of such
a model:  the data <code>y</code>, the transition probability matrix
<code>tpm</code>, the emission probabilities <code>Rho</code>, etc.  If the
data are numeric then these predicted values are the conditional
expectations of the observations, given the entire observation
sequence (and the &mdash; possibly estimated &mdash; parameters of the
model).  If the data are categorical (whence &ldquo;expectations&rdquo;
make no sense) the &ldquo;predicted values&rdquo; are taken to be the
probabilities of each of the possible values of the observations,
at each time point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hmm.discnp'
predict(object, y = NULL, tpm=NULL, Rho=NULL,
                             ispd=NULL, X=NULL,addIntercept=NULL,
                             warn=TRUE, drop=TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.hmm.discnp_+3A_object">object</code></td>
<td>

<p>If not <code>NULL</code>, an object of class <code>hmm.discnp</code> as returned by
<code><a href="#topic+hmm">hmm</a>()</code>.
</p>
</td></tr>
<tr><td><code id="predict.hmm.discnp_+3A_y">y</code></td>
<td>
<p>A data structure to which the fitted model <code>object</code>
<em>could</em> have been fitted.  If <code>y</code> is NULL, an attempt
is made to extract <code>y</code> from <code>model</code>.
</p>
</td></tr>
<tr><td><code id="predict.hmm.discnp_+3A_tpm">tpm</code>, <code id="predict.hmm.discnp_+3A_rho">Rho</code>, <code id="predict.hmm.discnp_+3A_ispd">ispd</code>, <code id="predict.hmm.discnp_+3A_x">X</code>, <code id="predict.hmm.discnp_+3A_addintercept">addIntercept</code>, <code id="predict.hmm.discnp_+3A_warn">warn</code></td>
<td>

<p>See the help for <code><a href="#topic+sp">sp</a>()</code>.
</p>
</td></tr>
<tr><td><code id="predict.hmm.discnp_+3A_drop">drop</code></td>
<td>
<p>Logical scalar.  See the help for
<code><a href="#topic+fitted.hmm.discnp">fitted.hmm.discnp</a>()</code>.
</p>
</td></tr>
<tr><td><code id="predict.hmm.discnp_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is essentially the same as
<code><a href="#topic+fitted.hmm.discnp">fitted.hmm.discnp</a>()</code>.  The main difference is
that it allows the calculation of fitted/predicted values for a
data object <code>y</code> possibly different from that to which the
model was fitted.  Note that if both the argument <code>y</code> and
<code>object[["y"]]</code> are present, the &ldquo;argument&rdquo; value takes
precedence.  This function also allows the model to be specfied
in terms of individual components rather than as a fitted model
of class <code>"hmm.discnp"</code>.  These components, (<code>tpm</code>,
<code>Rho</code>, <code>ispd</code>, <code>X</code>, <code>addIntercept</code>) if
supplied, <em>take precedence</em> over the corresponding components
of <code>object</code>.  The opposite applies with <code>sp()</code>.  The
function <code>fitted.hmm.discnp()</code> makes use <em>only</em>
of the components of <code>object</code>.
</p>


<h3>Value</h3>

<p>See the help for <code><a href="#topic+fitted.hmm.discnp">fitted.hmm.discnp</a>()</code>.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a><br />
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sp">sp</a>()</code> <code>link{fitted.hmm.discnp}()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- matrix(c(0.7,0.3,0.1,0.9),2,2,byrow=TRUE)
R &lt;- matrix(c(0.5,0,0.1,0.1,0.3,
              0.1,0.1,0,0.3,0.5),5,2)
set.seed(42)
ll1  &lt;- sample(250:350,20,TRUE)
y1   &lt;- rhmm(ylengths=ll1,nsim=1,tpm=P,Rho=R,drop=TRUE)
fit  &lt;- hmm(y1,K=2,verb=TRUE,keep.y=TRUE,itmax=10)
fv   &lt;- fitted(fit)
set.seed(176)
ll2  &lt;- sample(250:350,20,TRUE)
y2   &lt;- rhmm(ylengths=ll2,nsim=1,tpm=P,Rho=R,drop=TRUE)
pv   &lt;- predict(fit,y=y2)
yval &lt;- letters[1:5]
set.seed(171)
y3   &lt;- rhmm(ylengths=ll2,yval=yval,nsim=1,tpm=P,Rho=R,drop=TRUE)
fit3 &lt;- hmm(y3,K=2,verb=TRUE,keep.y=TRUE,itmax=10)
pv3  &lt;- predict(fit3) # Same as fitted(fit3).
</code></pre>

<hr>
<h2 id='rhmm'>
Simulate discrete data from a non-parametric hidden Markov model.
</h2><span id='topic+rhmm'></span><span id='topic+rhmm.default'></span><span id='topic+rhmm.hmm.discnp'></span>

<h3>Description</h3>

<p>Simulates one or more replicates of discrete data
from a model such as is fitted by the function <code>hmm()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhmm(model,...,nsim,verbose=FALSE)
## Default S3 method:
rhmm(model, ..., nsim=1, verbose=FALSE, ylengths,
                       nafrac=NULL, fep=NULL, tpm, Rho, ispd=NULL, yval=NULL,
                       drop=TRUE, forceNumeric=TRUE)
## S3 method for class 'hmm.discnp'
rhmm(model, ..., nsim=1, verbose=FALSE, inMiss=TRUE,
                          fep=NULL, drop=TRUE, forceNumeric=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rhmm_+3A_model">model</code></td>
<td>

<p>An object of class <code>hmm.discnp</code>.  This will have the form of
a list specifying a hidden Markov model with discrete emissions
and emission probabilities specified non-parametrically, i.e.
by means of some form of table or tables.  Usually this will
be an object returned by <code><a href="#topic+hmm">hmm</a>()</code>.  This argument is
ignored by the default method.
</p>
</td></tr>
<tr><td><code id="rhmm_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
<tr><td><code id="rhmm_+3A_nsim">nsim</code></td>
<td>

<p>Integer scalar; the number of data sets to be simulated.
</p>
</td></tr>
<tr><td><code id="rhmm_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar.  If <code>TRUE</code> then the overall index
of the simulated value that has been reached is printed out every
1000 iterations.  Useful for reassurance when very &ldquo;large&rdquo;
simulations are undertaken.
</p>
</td></tr>
<tr><td><code id="rhmm_+3A_ylengths">ylengths</code></td>
<td>

<p>Integer values vector specify the lengths (or number of rows
in the bivariate setting) of the individual observation
sequences constituting a data set.
</p>
</td></tr>
<tr><td><code id="rhmm_+3A_nafrac">nafrac</code></td>
<td>

<p>See <code><a href="#topic+misstify">misstify</a>()</code> for an explanation of this argument.
If specified a fraction <code>nafrac[[j]]</code> of column <code>j</code>
of the data will be randomly set equal to <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="rhmm_+3A_fep">fep</code></td>
<td>

<p>&ldquo;First entry present&rdquo;.  See <code><a href="#topic+misstify">misstify</a>()</code>
for an explanation of this argument.
</p>
</td></tr>
<tr><td><code id="rhmm_+3A_tpm">tpm</code></td>
<td>

<p>The transition probability matrix for the underlying hidden
Markov chain(s).  Note that the rows of <code>tpm</code> must sum to 1.
Ignored if <code>ncol(Rho)==1</code>.  Ignored by the <code>hmm.discnp</code>
method and extracted from <code>model</code>.
</p>
</td></tr>
<tr><td><code id="rhmm_+3A_rho">Rho</code></td>
<td>

<p>An object specifying the probability distribution of the
observations, given the state of the underlying hidden Markov chain.
(I.e. the &ldquo;emission&rdquo; probabilities.)  See <code><a href="#topic+hmm">hmm</a>()</code>.
Note that <code>Rho</code> can be such that the number of states is 1, in
which case the simulated data are i.i.d. from the single distribution
specified by <code>Rho</code>.  Ignored by the <code>hmm.discnp</code> method
and extracted from <code>model</code>.
</p>
</td></tr>
<tr><td><code id="rhmm_+3A_ispd">ispd</code></td>
<td>
<p>A vector specifying the initial state probability
distribution of the chain.  If this is not specified it is taken
to be the stationary distribution of the chain, calculated from
<code>tpm</code>.  Ignored by the <code>hmm.discnp</code> method and extracted
from <code>model</code>.
</p>
</td></tr>
<tr><td><code id="rhmm_+3A_yval">yval</code></td>
<td>
<p>Vector of possible values of the observations, or (in
the bivariate setting) a list of two such vectors.  If not supplied
it is formed from the levels of the factor constituting the <code>y</code>
column of <code>Rho</code> (univariate case) or from appropriate dimension
names associated with <code>Rho</code> (bivariate case).  Ignored by the
<code>hmm.discnp</code> method.
</p>
</td></tr>
<tr><td><code id="rhmm_+3A_drop">drop</code></td>
<td>

<p>Logical scalar; if <code>TRUE</code> then lists of length 1 are
replaced by their first entry.  In particular if <code>nsim</code>
is 1 and if <code>drop</code> is <code>TRUE</code> then the list to be
returned by this function (see below) is replaced by its first and only
entry.  Also if <code>ylengths</code> is of length 1 (so that each
entry of the returned value contains only a single sequence of
of simulated observations) then each list of such sequences
is replaced by its first and only entry.
</p>
</td></tr>
<tr><td><code id="rhmm_+3A_inmiss">inMiss</code></td>
<td>

<p>Logical scalar; if <code>TRUE</code> then missing values will
be randomly inserted into the data in the fraction
<code>nafrac</code> determined from <code>object</code>.
</p>
</td></tr>
<tr><td><code id="rhmm_+3A_forcenumeric">forceNumeric</code></td>
<td>

<p>Logical scalar; if <code>TRUE</code> then if all of the possible
values of the observations can be interpreted as numeric
(by <code>as.numeric()</code>) then they are so interpreted.
That is, the value returned will consist of a collection
of numeric sequences, rather than a collection of sequences
of values of categorical variables.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>nsim&gt;1</code> or <code>drop</code> is <code>FALSE</code> then the value
returned is a list of length <code>nsim</code>.  Each entry of this
list is in turn a list of the same length as <code>ylengths</code>,
each component of which is an independent  vector or matrix of
simulated observations.  The length or number of rows of component
<code>i</code> of this list is equal to <code>ylengths[i]</code>.  The values
of the observations are entries of <code>yval</code> or of <em>its</em>
entries when <code>yval</code> is a list.
</p>
<p>If <code>nsim=1</code> and <code>drop</code> is <code>TRUE</code> then the (&ldquo;outer&rdquo;)
list described above is replaced by its first and only entry
</p>
<p>If the length of <code>ylengths</code> is <code>1</code> and <code>drop</code> is
<code>TRUE</code> then each &ldquo;inner&rdquo; list described above is
replaced by its first and only entry.
</p>


<h3>Note</h3>

<p>You may find it useful to avail yourself of the function
<code><a href="#topic+nafracCalc">nafracCalc</a>()</code> to determine the fraction of missing
values in a given existing (presumably &ldquo;real&rdquo;) data set.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a><br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmm">hmm</a>()</code> <code><a href="#topic+nafracCalc">nafracCalc</a>()</code>
<code><a href="#topic+misstify">misstify</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># To do: one or more bivariate examples.
## Not run: 
    y &lt;- list(linLandFlows$deciles,ftLiardFlows$deciles)
    fit &lt;- hmm(y,K=3)
    simX &lt;- rhmm(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='scovmat'>
Simulation based covariance matrix.
</h2><span id='topic+scovmat'></span>

<h3>Description</h3>

<p>Produces an estimate of the covariance matrix of the parameter
estimates in a model fitted by <code>hmm.discnp</code>.  Uses a method
based on simulation (or &ldquo;parametric bootstrapping&rdquo;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scovmat(object, expForm=TRUE, seed = NULL, nsim=100, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scovmat_+3A_object">object</code></td>
<td>

<p>An object of class <code>hmm.discnp</code> as returned by <code><a href="#topic+hmm">hmm</a>()</code>.
</p>
</td></tr>
<tr><td><code id="scovmat_+3A_expform">expForm</code></td>
<td>

<p>Logical scalar.  Should the covariance matrix produced
be that of the estimates of the parameters expressed in
&ldquo;exponential&rdquo; (or &ldquo;smooth&rdquo; or &ldquo;logistic&rdquo;)
form?  If <code>expForm=FALSE</code> then the parameter estimates
considered are &ldquo;raw&rdquo; probabilities, with redundancies
(last column of <code>tpm</code>; last row of <code>Rho</code>) removed.
</p>
</td></tr>
<tr><td><code id="scovmat_+3A_seed">seed</code></td>
<td>

<p>Integer scalar serving as a seed for the random number generator.
If left <code>NULL</code> the seed itself is chosen randomly from the
set of integers between 1 and <code class="reqn">10^5</code>.
</p>
</td></tr>
<tr><td><code id="scovmat_+3A_nsim">nsim</code></td>
<td>

<p>A positive integer.  The number of simulations upon which
the covariance matrix estimate will be based.
</p>
</td></tr>
<tr><td><code id="scovmat_+3A_verbose">verbose</code></td>
<td>

<p>Logical scalar; if <code>TRUE</code>, iteration counts will be
printed out during each of the simulation and model-fitting
stages.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is currently applicable only to models fitted to
univariate data.  If there are <em>predictors</em> in the model,
then only the exponential form of the parameters may be used,
i.e. <code>expForm</code> <em>must</em> be <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A (positive definite) matrix which is an estimate of the
covariance of the parameter estimates from the fitted model
specified by <code>object</code>.  It has row and column labels
which indicate the parameters to which its entries pertain,
in a reasonably perspicuous manner.
</p>
<p>This matrix has an attribute <code>seed</code> (the random number
generation seed that was used) so that the calculations can
be reproduced.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a><br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+squantCI">squantCI</a>()</code> <code>link{rhmm}()</code> <code>link{hmm)}()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
y   &lt;- list(lindLandFlows$deciles,ftLiardFlows$deciles)
fit &lt;- hmm(y,K=3)
ccc &lt;- scovmat(fit,nsim=100)

## End(Not run)
</code></pre>

<hr>
<h2 id='sp'>
Calculate the conditional state probabilities.
</h2><span id='topic+sp'></span>

<h3>Description</h3>

<p>Returns the probabilities that the underlying hidden
state is equal to each of the possible state values,
at each time point, given the observation sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp(y, model = NULL, tpm=NULL, Rho=NULL, ispd=NULL, X=NULL,
   addIntercept=NULL, warn=TRUE, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp_+3A_y">y</code></td>
<td>
<p>The observations on the basis of which the probabilities
of the underlying hidden states are to be calculated.  May be
a vector of a one or two column matrix of observations, or
a list each component of which is such a vector or matrix.
If <code>y</code> is missing it is set equal to the <code>y</code> component
of <code>model</code>, given that that argument is non-<code>NULL</code>
and that that component exists.  Otherwise an error is given.
</p>
</td></tr>
<tr><td><code id="sp_+3A_model">model</code></td>
<td>

<p>An object of class <code>hmm.discnp</code> as returned by
<code><a href="#topic+hmm">hmm</a>()</code>.
</p>
</td></tr>
<tr><td><code id="sp_+3A_tpm">tpm</code></td>
<td>

<p>The transition probability matrix for the underlying hidden
Markov chain.  Ignored if <code>model</code> is not <code>NULL</code>
(in which case <code>tpm</code> is extracted from <code>model</code>).
</p>
</td></tr>
<tr><td><code id="sp_+3A_rho">Rho</code></td>
<td>

<p>An object specifying the distribution of the observations, given
the underlying state.  I.e. the &ldquo;emission&rdquo; probabilities.
See <code><a href="#topic+hmm">hmm</a>()</code>.  Ignored if <code>model</code> is not
<code>NULL</code> (in which case <code>Rho</code> is extracted from
<code>model</code>).
</p>
</td></tr>
<tr><td><code id="sp_+3A_ispd">ispd</code></td>
<td>

<p>Vector specifying the initial state probability distribution
of the underlying hidden Markov chain.  Ignored if <code>model</code>
is not <code>NULL</code> (in which case <code>ispd</code> is extracted from
<code>model</code>).  If both <code>model[["ispd"]]</code> and <code>ispd</code>
are NULL then <code>ispd</code> is calculated to be the stationary
distribution of the chain as determined by <code>tpm</code>.
</p>
</td></tr>
<tr><td><code id="sp_+3A_x">X</code></td>
<td>
<p>An optional <em>numeric</em> matrix, or a list of
such matrices, of <em>predictors</em>.  Ignored if <code>model</code>
is not <code>NULL</code> (in which case <code>X</code> is extracted from
<code>model</code>).
</p>
<p>The use of such predictors is (currently, at least) applicable
only in the univariate emissions setting.  If <code>X</code> is a list it
must be of the same length as <code>y</code> and all entries of this list
must have the same number of columns.  The number of rows of each
entry must be equal to the length of the corresponding entry of
<code>y</code>. If <code>X</code> is a matrix then <code>y</code> should be a vector
or one-column matrix (or a list with a single entry equal to such).
</p>
</td></tr>
<tr><td><code id="sp_+3A_addintercept">addIntercept</code></td>
<td>

<p>Logical scalar.  See the documentation of <code><a href="#topic+hmm">hmm</a>()</code>.
Ignored if <code>model</code> is not <code>NULL</code> (in which case
<code>addIntercept</code> is extracted from <code>model</code>).
</p>
</td></tr>
<tr><td><code id="sp_+3A_warn">warn</code></td>
<td>
<p>Logical scalar; should a warning be issued if <code>Rho</code>
hasn't got relevant dimension names?  (Note that if this is so,
then the corresponding dimension names are formed from the sorted
unique values of <code>y</code> or of the appropriate column(s) of <code>y</code>.
And if <em>this</em> is so, then the user should be sure that the
ordering of the entries of <code>Rho</code> corresponds properly to the
the sorted unique values of <code>y</code>.)  This argument is passed
to the utility function <code>check.yval()</code> which actually issues
the warning if <code>warn=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="sp_+3A_drop">drop</code></td>
<td>
<p>Logical scalar.  If <code>y</code> is a matrix, or a
list of length 1, and if <code>drop</code> is <code>FALSE</code> then the
returned value is a list whose sole entry is the matrix that
would have been returned were <code>drop</code> equal to <code>TRUE</code>.
The argument <code>drop</code> is ignored if <code>y</code> is a list of
length greater than 1.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that in contrast to <code>predict.hmm.discnp()</code>, components
in <code>model</code> take precendence over individually supplied
components (<code>tpm</code>, <code>Rho</code>, <code>ispd</code>, <code>X</code>
and <code>addIntercept</code>).
</p>


<h3>Value</h3>

<p>If <code>y</code> is a single matrix of observations or a list of
length 1, and if <code>drop</code> is <code>TRUE</code> then the returned
value is a matrix whose rows correspond to the states of
the hidden Markov chain, and whose columns correspond to the
observation times.  Otherwise  the returned value is a list of such
matrices, one for each matrix of observations.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a><br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmm">hmm</a>()</code>, <code><a href="#topic+mps">mps</a>()</code>,
<code><a href="#topic+viterbi">viterbi</a>()</code>, <code><a href="#topic+pr">pr</a>()</code>,
<code><a href="#topic+fitted.hmm.discnp">fitted.hmm.discnp</a>()</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- matrix(c(0.7,0.3,0.1,0.9),2,2,byrow=TRUE)
R &lt;- matrix(c(0.5,0,0.1,0.1,0.3,
              0.1,0.1,0,0.3,0.5),5,2)
set.seed(42)
y    &lt;- rhmm(ylengths=rep(300,20),nsim=1,tpm=P,Rho=R,drop=TRUE)
fit  &lt;- hmm(y,K=2,verb=TRUE,keep.y=TRUE,itmax=10)
cpe1 &lt;- sp(model=fit) # Using the estimated parameters.
cpe2 &lt;- sp(y,tpm=P,Rho=R,warn=FALSE) # Using the ``true'' parameters.
# The foregoing would issue a warning that Rho had no row names
# were it not for the fact that "warn" has been set to FALSE.
</code></pre>

<hr>
<h2 id='squantCI'>
Simulation-quantile based confidence intervals.
</h2><span id='topic+squantCI'></span>

<h3>Description</h3>

<p>Calculates estimates of confidence intervals for the parameters of a
model fitted by <code>hmm.discnp</code>.  Uses a method based quantiles
of estimates produced by simulation (or &ldquo;parametric
bootstrapping&rdquo;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>squantCI(object, expForm = TRUE, seed = NULL, alpha = 0.05,
         nsim=100, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="squantCI_+3A_object">object</code></td>
<td>

<p>An object of class <code>hmm.discnp</code> as returned by <code><a href="#topic+hmm">hmm</a>()</code>.
</p>
</td></tr>
<tr><td><code id="squantCI_+3A_expform">expForm</code></td>
<td>

<p>Logical scalar.  Should the confidence intervals produced
be for the parameters expressed in &ldquo;exponential&rdquo;
(or &ldquo;smooth&rdquo; or &ldquo;logistic&rdquo;) form?
If <code>expForm=FALSE</code> then the parameters considered are
&ldquo;raw&rdquo; probabilities, with redundancies (last column of
<code>tpm</code>; last row of <code>Rho</code>) removed.
</p>
</td></tr>
<tr><td><code id="squantCI_+3A_seed">seed</code></td>
<td>

<p>Integer scalar serving as a seed for the random number generator.
If left <code>NULL</code> the seed itself is chosen randomly from the
set of integers between 1 and <code class="reqn">10^5</code>.
</p>
</td></tr>
<tr><td><code id="squantCI_+3A_alpha">alpha</code></td>
<td>

<p>Positive real number strictly between 0 and 1.  A set of
<code>100*(1-alpha)</code>% confidence intervals will be produced.
</p>
</td></tr>
<tr><td><code id="squantCI_+3A_nsim">nsim</code></td>
<td>

<p>A positive integer.  The number of simulations upon which
the confidence interval estimates will be based.
</p>
</td></tr>
<tr><td><code id="squantCI_+3A_verbose">verbose</code></td>
<td>

<p>Logical scalar; if <code>TRUE</code>, iteration counts will be
printed out during each of the simulation and model-fitting
stages.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is currently applicable only to models fitted to
univariate data.  If there are <em>predictors</em> in the model,
then only the exponential form of the parameters may be used,
i.e. <code>expForm</code> <em>must</em> be <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A <code>npar</code>-by-2 matrix (where <code>npar</code> is the number
of &ldquo;independent&rdquo; parameters in the model) whose rows
form the estimated confidence intervals.  (The first entry of
each row is the lower bound of a confidence interval for the
corresponding parameter, and the second entry is the upper bound.
The row labels indicate the parameters to which each row pertains,
in a reasonably perspicuous manner.  The column labels indicate
the relevant quantiles in percentages.
</p>
<p>This matrix has an attribute <code>seed</code> (the random number
generation seed that was used) so that the calculations can
be reproduced.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a><br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scovmat">scovmat</a>()</code> <code>link{rhmm}()</code> <code>link{hmm)}()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
y   &lt;- list(lindLandFlows$deciles,ftLiardFlows$deciles)
fit &lt;- hmm(y,K=3)
CIs &lt;- squantCI(fit,nsim=100)

## End(Not run)
</code></pre>

<hr>
<h2 id='SydColDisc'>Discretised version of coliform counts in sea-water samples</h2><span id='topic+SydColDisc'></span>

<h3>Description</h3>

<p>Discretised version of counts of faecal coliform bacteria in sea water
samples collected at seven locations near Sydney NSW, Australia.
There were four &ldquo;controls&rdquo;: Longreef, Bondi East, Port
Hacking &ldquo;50&rdquo;, and Port Hacking &ldquo;100&rdquo; and three
&ldquo;outfalls&rdquo;: Bondi Offshore, Malabar Offshore and North
Head Offshore.  At each location measurements were made at four
depths: 0, 20, 40, and 60 meters.  A large fraction of the counts
are missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SydColDisc</code></pre>


<h3>Format</h3>

<p>A data frame with 5432 observations on the following 6 variables.
</p>

<dl>
<dt><code>y</code></dt><dd><p>A factor consisting of a discretisation of counts
of faecal coliform count bacteria in sea water samples.  The
original measures were obtained by a repeated dilution process.</p>
</dd>
</dl>
<p>The data were discretised using the <code><a href="base.html#topic+cut">cut</a>()</code>
function with breaks given by <code>c(0,1,5,25,200,Inf)</code> and
labels equal to <code>c("lo","mlo","m","mhi","hi")</code>.
</p>
<dl>
<dt><code>locn</code></dt><dd><p>a factor with levels <code>Longreef</code>,
<code>Bondi East</code>, <code>Port Hacking 50</code>, <code>Port Hacking
    100</code>, <code>Bondi Offshore</code>, <code>Malabar Offshore</code> and
<code>North Head Offshore</code>.</p>
</dd>
<dt><code>depth</code></dt><dd><p>a factor with levels <code>0</code> (0 metres),
<code>20</code> (20 metres), <code>40</code> (40 metres), <code>60</code> (60 metres).</p>
</dd>
<dt><code>ma.com</code></dt><dd><p>A factor with levels <code>no</code> and <code>yes</code>,
indicating whether the Malabar sewage outfall had been commissioned.</p>
</dd>
<dt><code>nh.com</code></dt><dd><p>A factor with levels <code>no</code> and <code>yes</code>,
indicating whether the North Head sewage outfall had been commissioned.</p>
</dd>
<dt><code>bo.com</code></dt><dd><p>A factor with levels <code>no</code> and <code>yes</code>,
indicating whether the Bondi Offshore sewage outfall had been commissioned.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The observations corresponding to each location-depth combination
constitute a (discrete valued) time series.  The sampling
interval is ostensibly 1 week; distinct time series are ostensibly
synchronous.  The measurements were made over a 194 week period.
Due to exigencies of weather, the unreliabitity of boats and
other factors the collection times were actually highly irregular
and have been rounded to the neares week.  Often no sample was
obtained at a given site within a week of the putative collection
time, in which the observed count is given as a missing value. In
fact over <b>75%</b> of the counts are missing.  See Turner et
al. (1998) for more detail.
</p>


<h3>Modelling</h3>

<p>The hidden Markov models applied in the paper Turner et
al. (1998) and in the paper Turner (2008) used a numeric version
of the response in this data set.  The numeric response was
essentially a square root transformation of the original data,
and the resulting values were modelled in terms of a Poisson
distribution.  See the references for details.
</p>


<h3>Source</h3>

<p>The original data were kindly supplied by Geoff Coade, of the
New South Wales Environment Protection Authority (Australia)
</p>


<h3>References</h3>

<p>T. Rolf Turner, Murray A. Cameron, and Peter J. Thomson.  Hidden
Markov chains in generalized linear models.  <em>Canadian J. Statist.</em>
<b>26</b> (1998) 107 &ndash; 125.
</p>
<p>Rolf Turner.  Direct maximization of the likelihood of a hidden
Markov model.  <em>Comp. Statist. Data Anal.</em> <b>52</b> (2008)
4147&ndash;4160.
</p>

<hr>
<h2 id='update.hmm.discnp'>
Update a fitted <code>hmm.discnp</code> model.
</h2><span id='topic+update.hmm.discnp'></span>

<h3>Description</h3>

<p>An <code>update()</code> method for objects of class <code>hmm.discnp</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hmm.discnp'
update(object,..., data, Kplus1=FALSE,
        tpm2=NULL, verbose=FALSE, method=NULL, optimiser=NULL,
        stationary=NULL, mixture=NULL, cis=NULL, tolerance=NULL,
        itmax=NULL, crit=NULL, X=NULL, addIntercept=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.hmm.discnp_+3A_object">object</code></td>
<td>

<p>An object of class <code>hmm.discnp</code> as returned by <code><a href="#topic+hmm">hmm</a>()</code>.
</p>
</td></tr>
<tr><td><code id="update.hmm.discnp_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
<tr><td><code id="update.hmm.discnp_+3A_data">data</code></td>
<td>

<p>The data set to which the (updated) model is to be fitted.  See the
description of the <code>y</code> argument of <code><a href="#topic+hmm">hmm</a>()</code> for more
detail.
</p>
</td></tr>
<tr><td><code id="update.hmm.discnp_+3A_kplus1">Kplus1</code></td>
<td>

<p>Logical scalar.  Should the number of states be incremented by 1?
If so then <code>tpm</code> (the transition probability matrix) is re-formed
by <code>rbind()</code>-ing on a row all of whose entries are <code>1/K</code>
(where <code>K</code> is the &ldquo;old&rdquo; number of states) and then
<code>cbind()</code>-ing on a column of zeroes.  The emission probability
matrix <code>Rho</code> is reformed by <code>cbind()</code>-ing on a column all
of whose entries are <code>1/m</code> where <code>m</code> is the number of discrete
values of the emissions.
</p>
<p>Note that the intial likelihood of the &ldquo;new&rdquo; model with
<code>K+1</code> states will (should?) be exactly the same as that of
of the &ldquo;old&rdquo; fitted <code>K</code>-state model.
</p>
<p>The <code>Kplus1</code> argument is provided mainly so as to provide a
set of starting values for the fitting process which will guarantee
the log likelihood of a <code>K+1</code>-state model will be at least as
large as that of a <code>K</code>-state model fitted to the same data set.
</p>
<p>Experience indicates that when <code>Kplus1=TRUE</code> is used, the
fitting process does not &ldquo;move very far&rdquo; from the maximum
log likelihood found for the <code>K</code>-state model.  It is then
advisable to try (many) random starting values so as to (try to)
find the &ldquo;true&rdquo; maximum for the <code>K+1</code>-state model.
</p>
</td></tr>
<tr><td><code id="update.hmm.discnp_+3A_tpm2">tpm2</code></td>
<td>

<p>The transtion probability matrix to use when updating a model
fitted with <code>K=1</code> and <code>Kplus1=TRUE</code>. This argument
is ignored otherwise.  The default value of this argument is
<code>matrix(0.5,2,2)</code>.  The value of <code>tpm2</code> makes no
difference to the <em>initial</em> value of the likelihood
of the <code>K=2</code> model (which will be identical to the
likelihood of the fitted <code>K=1</code> model that is being
updated).  Any two-by-two transition probability matrix
&ldquo;will do&rdquo;.  However the value of <code>tpm2</code> could
conceivably have an impact on the final likelihood of the
<code>K=2</code> model to which the fitting procedure converges.
This is particularly true if the <code>method</code> is (or is
switched to) <code>"LM"</code>.
</p>
</td></tr>
<tr><td><code id="update.hmm.discnp_+3A_verbose">verbose</code></td>
<td>

<p>See the help for <code>hmm()</code>.
</p>
</td></tr>
<tr><td><code id="update.hmm.discnp_+3A_method">method</code></td>
<td>

<p>See the help for <code>hmm()</code>.
</p>
</td></tr>
<tr><td><code id="update.hmm.discnp_+3A_optimiser">optimiser</code></td>
<td>

<p>See the help for <code>hmm()</code>.
</p>
</td></tr>
<tr><td><code id="update.hmm.discnp_+3A_stationary">stationary</code></td>
<td>

<p>See the help for <code>hmm()</code>.
</p>
</td></tr>
<tr><td><code id="update.hmm.discnp_+3A_mixture">mixture</code></td>
<td>

<p>See the help for <code>hmm()</code>.
</p>
</td></tr>
<tr><td><code id="update.hmm.discnp_+3A_cis">cis</code></td>
<td>

<p>See the help for <code>hmm()</code>.
</p>
</td></tr>
<tr><td><code id="update.hmm.discnp_+3A_tolerance">tolerance</code></td>
<td>

<p>See the help for <code>hmm()</code>.
</p>
</td></tr>
<tr><td><code id="update.hmm.discnp_+3A_itmax">itmax</code></td>
<td>

<p>See the help for <code>hmm()</code>.
</p>
</td></tr>
<tr><td><code id="update.hmm.discnp_+3A_crit">crit</code></td>
<td>

<p>See the help for <code>hmm()</code>.
</p>
</td></tr>
<tr><td><code id="update.hmm.discnp_+3A_x">X</code></td>
<td>

<p>See the help for <code>hmm()</code>.
</p>
</td></tr>
<tr><td><code id="update.hmm.discnp_+3A_addintercept">addIntercept</code></td>
<td>

<p>See the help for <code>hmm()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Except for argument <code>X</code>, any arguments that are left <code>NULL</code>
have their values supplied from the <code>args</code> component of <code>object</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>hmm.discnp</code> with an additional component
<code>init.log.like</code> which is the initial log likelihood
calculated at the starting values of the parameters (which may
be modified from the parameters returned in the object being
updated, if <code>Kplus1</code> is <code>TRUE</code>).  The calculation is
done by the function <code>logLikHmm()</code>.  Barring the strange and
unforeseen, <code>init.log.like</code> should be (reassuringly) equal
to <code>object$log.like</code>.  See <code><a href="#topic+hmm">hmm</a>()</code> for details of
the other components of the returned value.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a><br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmm">hmm</a>()</code> <code><a href="#topic+rhmm.hmm.discnp">rhmm.hmm.discnp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(294)
fit  &lt;- hmm(WoodPeweeSong,K=2,rand.start=list(tpm=TRUE,Rho=TRUE),itmax=10)
xxx  &lt;- rhmm(fit,nsim=1)
sfit &lt;- update(fit,data=xxx,itmax=10)
yyy  &lt;- with(SydColDisc,split(y,f=list(locn,depth)))
f1   &lt;- hmm(yyy,K=1)
f2   &lt;- update(f1,data=yyy,Kplus1=TRUE) # Big improvement, but ...
## Not run: 
g2   &lt;- hmm(yyy,K=2) # Substantially better than f2. 

## End(Not run)
</code></pre>

<hr>
<h2 id='viterbi'> Most probable state sequence. </h2><span id='topic+viterbi'></span>

<h3>Description</h3>

<p>Calculates &ldquo;the&rdquo; most probable state sequence underlying
each of one or more replicate observation sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viterbi(y, model = NULL, tpm, Rho, ispd=NULL,log=FALSE, warn=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="viterbi_+3A_y">y</code></td>
<td>
<p>The observations for which the most probable sequence(s)
of underlying hidden states are required.  May be a sequence of
observations in the form of a vector or a one or two column matrix,
or a list each component of which constitutes a (replicate)
sequence of observations.  It may also be an object of class
<code>"multipleHmmDataSets"</code> as returned by <code><a href="#topic+rhmm">rhmm</a>()</code>
with <code>nsim&gt;1</code>.
</p>
<p>If <code>y</code> is missing, it is extracted from
<code>model</code> (whence it will <em>not</em> be of class
<code>"multipleHmmDataSets"</code>!) provided that <code>model</code> and
its <code>y</code> component are not <code>NULL</code>.  Otherwise an error
is given.
</p>
</td></tr>
<tr><td><code id="viterbi_+3A_model">model</code></td>
<td>
<p> An object describing a hidden Markov model, as
fitted to the data set <code>y</code> by <code><a href="#topic+hmm">hmm</a>()</code>.</p>
</td></tr>
<tr><td><code id="viterbi_+3A_tpm">tpm</code></td>
<td>
<p> The transition probability matrix for a hidden
Markov model; ignored if <code>model</code> is non-null.</p>
</td></tr>
<tr><td><code id="viterbi_+3A_rho">Rho</code></td>
<td>
<p>An object specifying the probability distributions
of the observations for a hidden Markov model.  See
<code><a href="#topic+hmm">hmm</a>()</code>. Ignored if <code>model</code> is non-null. Should
bear some reasonable relationship to <code>y</code>.
</p>
<p>If <code>Rho</code> has dimension names (or if its entries have
dimension names in the case where <code>Rho</code> is a list) then the
appropriate dimension names must include all corresponding values
of the observations.  If a relevant vector of dimension names is
<code>NULL</code> then it is formed as the sort unique values of the
approprate columns of the observation matrices.   In this case the
corresponding dimensions must match the number of unique values.</p>
</td></tr>
<tr><td><code id="viterbi_+3A_ispd">ispd</code></td>
<td>
<p> The initial state probability distribution for a hidden
Markov model; ignored if <code>model</code> is non-null. Should
bear some reasonable relationship to <code>y</code>. If <code>model</code>
and <code>ispd</code> are both <code>NULL</code> then <code>ispd</code> is set
equal to the stationary distribution calculated from <code>tpm</code>.</p>
</td></tr>
<tr><td><code id="viterbi_+3A_log">log</code></td>
<td>
<p>Logical scalar.  Should logarithms be used in the
recursive calculations of the probabilities involved in the
Viterbi algorithm, so as to avoid underflow?  If <code>log</code> is
<code>FALSE</code> then underflow is avoided instead by a normalization
procedure.  The quantity <code>delta</code> (see Rabiner 1989, page 264)
is replaced by <code>delta/sum(delta)</code> at each step.  It should
actually make no difference whether <code>log</code> is set to <code>TRUE</code>.
I just included the option because I could.  Also the <code>HMM</code>
package uses the logarithm approach so setting <code>log=TRUE</code>
might be of interest if comparisons are to be made between
results from the two packages.
</p>
</td></tr>
<tr><td><code id="viterbi_+3A_warn">warn</code></td>
<td>
<p>Logical scalar; should a warning be issued if <code>Rho</code>
hasn't got relevant dimension names?  (Note that if this is so,
then the corresponding dimension names are formed from the sorted
unique values of <code>y</code> or of the appropriate column(s) of <code>y</code>.
And if <em>this</em> is so, then the user should be sure that the
ordering of the entries of <code>Rho</code> corresponds properly to the
the sorted unique values of <code>y</code>.)  This argument is passed
to the utility function <code>check.yval()</code> which actually issues
the warning if <code>warn=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applies the Viterbi algorithm to calculate &ldquo;the&rdquo; most probable
robable state sequence underlying each observation sequences.
</p>


<h3>Value</h3>

<p>If <code>y</code> consists of a single observation sequence, the
value is the underlying most probable observation sequence,
or a matrix whose columns consist of such sequences if there
is more than one (equally) most probable sequence.
</p>
<p>If <code>y</code> consists of a list of observation sequences, the
value is a list each entry of which is of the form described
above.
</p>
<p>If <code>y</code> is of class <code>"multipleHmmDataSets"</code> then the
value returned is a list of lists of the sort described above.
</p>


<h3>Warning</h3>

<p>There <em>may</em> be more than one equally most probable state
sequence underlying a given observation sequence.  This phenomenon
can occur but appears to be unlikely to do so in practice.
</p>


<h3>Thanks</h3>

<p>The correction made to the code so as to avoid underflow
problems was made due to an inquiry and suggestion from
Owen Marshall.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a><br />
</p>


<h3>References</h3>

<p>Rabiner, L. R., &quot;A tutorial on hidden Markov models and
selected applications in speech recognition,&quot; Proc. IEEE vol. 77,
pp. 257 &ndash; 286, 1989.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmm">hmm</a>()</code>, <code><a href="#topic+rhmm">rhmm</a>()</code>,
<code><a href="#topic+mps">mps</a>()</code>, <code><a href="#topic+pr">pr</a>()</code></p>


<h3>Examples</h3>

<pre><code class='language-R'># See the help for logLikHmm() for how to generate y.num and y.let.
## Not run: 
fit.num     &lt;- hmm(y.num,K=2,verb=TRUE,keep.y=TRUE)
v.1         &lt;- viterbi(model=fit.num)
rownames(R) &lt;- 1:5 # Avoids a (harmless) warning.
v.2         &lt;- viterbi(y.num,tpm=P,Rho=R)
# P and R as in the help for logLikHmm() and for sp().

# Note that the order of the states has gotten swapped; 3-v.1[[1]]
# is identical to v.2[[1]]; for other k = 2, ..., 20, 3-v.1[[k]]
# is much more similar to v.2[[k]] than is v.1[[k]].

fit.let &lt;- hmm(y.let,K=2,verb=TRUE,keep.y=TRUE))
v.3 &lt;- viterbi(model=fit.let)
rownames(R) &lt;- letters[1:5]
v.4 &lt;- viterbi(y.let,tpm=P,Rho=R)

## End(Not run)
</code></pre>

<hr>
<h2 id='weissData'>
Data from &ldquo;An Introduction to Discrete-Valued Time Series&rdquo;
</h2><span id='topic+weissData'></span><span id='topic+Bovine'></span><span id='topic+Cryptosporidiosis'></span><span id='topic+Downloads'></span><span id='topic+EricssonB_Jul2'></span><span id='topic+FattyLiver'></span><span id='topic+FattyLiver2'></span><span id='topic+goldparticle380'></span><span id='topic+Hanta'></span><span id='topic+InfantEEGsleepstates'></span><span id='topic+IPs'></span><span id='topic+LegionnairesDisease'></span><span id='topic+OffshoreRigcountsAlaska'></span><span id='topic+PriceStability'></span><span id='topic+Strikes'></span><span id='topic+WoodPeweeSong'></span>

<h3>Description</h3>

<p>Data sets from the book
&ldquo;An Introduction to Discrete-Valued Time Series&rdquo; by
Christian H. Wei.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    data(Bovine)
    data(Cryptosporidiosis)
    data(Downloads)
    data(EricssonB_Jul2)
    data(FattyLiver)
    data(FattyLiver2)
    data(goldparticle380)
    data(Hanta)
    data(InfantEEGsleepstates)
    data(IPs)
    data(LegionnairesDisease)
    data(OffshoreRigcountsAlaska)
    data(PriceStability)
    data(Strikes)
    data(WoodPeweeSong)
</code></pre>


<h3>Format</h3>


<ul>
<li> <p><code>Bovine</code>
A character vector of length 8419.
</p>
</li>
<li> <p><code>Cryptosporidiosis</code>
A numeric (integer) vector of length 365.
</p>
</li>
<li> <p><code>Downloads</code>
A numeric (integer) vector of length 267.
</p>
</li>
<li> <p><code>EricssonB_Jul2</code>
A numeric (integer) vector of length 460.
</p>
</li>
<li> <p><code>FattyLiver2</code>
A numeric (integer) vector of length 449.
</p>
</li>
<li> <p><code>FattyLiver</code>
A numeric (integer) vector of length 928.
</p>
</li>
<li> <p><code>goldparticle380</code>
A numeric (integer) vector of length 380.
</p>
</li>
<li> <p><code>Hanta</code>
A numeric (integer) vector of length 52.
</p>
</li>
<li> <p><code>InfantEEGsleepstates</code>
A character vector of length 107.
</p>
</li>
<li> <p><code>IPs</code>
A numeric (integer) vector of length 241.
</p>
</li>
<li> <p><code>LegionnairesDisease</code>
A numeric (integer) vector of length 365.
</p>
</li>
<li> <p><code>OffshoreRigcountsAlaska</code>
A numeric (integer) vector of length 417.
</p>
</li>
<li> <p><code>PriceStability</code>
A numeric (integer) vector of length 152.
</p>
</li>
<li> <p><code>Strikes</code>
A numeric (integer) vector of length 108.
</p>
</li>
<li> <p><code>WoodPeweeSong</code>
A numeric (integer) vector of length 1327.
</p>
</li></ul>



<h3>Details</h3>

<p>For detailed information about each of these data sets, see the
book cited in the <b>References</b>.
</p>
<p>Note that the data sets <code>Cryptosporidiosis</code>
and <code>LegionnairesDisease</code> are actually
called <br /> <code>Cryptosporidiosis_02-08</code> and
<code>LegionnairesDisease_02-08</code> in the given reference.
The <br /> &ldquo;suffixes&rdquo; were removed since the minus sign causes
problems in a variable name in <code>R</code>.
</p>


<h3>Source</h3>

<p>These data sets were kindly provided by Prof. Christian
H. Wei.  The package author is also pleased
to acknowledge the kind permission granted by Prof. Kurt
Brnns (Professor Emeritus of Economics at
Ume University) to include the Ericsson time series
data set (<code>EricssonB_Jul2</code>).
</p>


<h3>References</h3>

<p>Christian H. Wei (2018).  <em>An
Introduction to Discrete-Valued Time Series</em>.  Chichester: John
Wiley &amp; Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit1 &lt;- hmm(WoodPeweeSong,K=2,verbose=TRUE)
# EM converges in 6 steps --- suspicious.
set.seed(321)
fit2 &lt;- hmm(WoodPeweeSong,K=2,verbose=TRUE,rand.start=list(tpm=TRUE,Rho=TRUE))
# 52 steps --- note the huge difference between fit1$log.like and fit2$log.like!
set.seed(321)
fit3 &lt;- hmm(WoodPeweeSong,K=2,verbose=TRUE,method="bf",
            rand.start=list(tpm=TRUE,Rho=TRUE))
# log likelihood essentially the same as for fit2

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
