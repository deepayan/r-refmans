<!DOCTYPE html><html><head><title>Help for package SeqDetect</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SeqDetect}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bpi_challenge_2019_test1'><p>BPI 2019 challenge test</p></a></li>
<li><a href='#c_to_string'><p>String list formatting function</p></a></li>
<li><a href='#classify'><p>Pre-classifying method</p></a></li>
<li><a href='#cleanKeys+2CHybridSequenceClassifier-method'><p>Sequence Detector Method: clean keys and tokens in machines (ETTs)</p></a></li>
<li><a href='#clone+2CHybridSequenceClassifier-method'><p>Sequence Detector Method: clone the Sequence Detector object</p></a></li>
<li><a href='#compressMachines+2CHybridSequenceClassifier-method'><p>Sequence Detector Method: compress machines (ETTs)</p></a></li>
<li><a href='#deserializeFromList'><p>Sequence Detector Method: deserialize Sequence Detector object from external list</p></a></li>
<li><a href='#getMachineIdentifiers+2CHybridSequenceClassifier-method'><p>Sequence Detector Method: retrieve machine identifiers (ETTs)</p></a></li>
<li><a href='#HSC_PC'><p>Abstract pre-classifier class</p></a></li>
<li><a href='#HSC_PC_Attribute'><p>Attribute pre-classifier</p></a></li>
<li><a href='#HSC_PC_Binning'><p>Binning pre-classifier</p></a></li>
<li><a href='#HSC_PC_None'><p>Straight-through pre-classifier</p></a></li>
<li><a href='#HSC_PP'><p>Pre-processor top-level class</p></a></li>
<li><a href='#HybridSequenceClassifier-class'><p>Sequence Detector</p></a></li>
<li><a href='#induceSubmachine+2CHybridSequenceClassifier-method'><p>Sequence Detector Method: ETT projection</p></a></li>
<li><a href='#mergeMachines+2CHybridSequenceClassifier-method'><p>Sequence Detector Method: merge machines (ETTs)</p></a></li>
<li><a href='#plotMachines+2CHybridSequenceClassifier-method'><p>Sequence Detector Method: plot machines (ETTs)</p></a></li>
<li><a href='#preprocess'><p>Pre-processing method</p></a></li>
<li><a href='#printMachines+2CHybridSequenceClassifier-method'><p>Sequence Detector Method: printout machines (ETTs)</p></a></li>
<li><a href='#process+2CHybridSequenceClassifier-method'><p>Sequence Detector Method: processing input data streams</p></a></li>
<li><a href='#sales_dataset_test'><p>Sales time-series test</p></a></li>
<li><a href='#sepsis_dataset_test'><p>Sepsis dataset test</p></a></li>
<li><a href='#serialize+2CHybridSequenceClassifier-method'><p>Sequence Detector Method: serialize the Sequence Detector object</p></a></li>
<li><a href='#serializeToList+2CHybridSequenceClassifier-method'><p>Sequence Detector Method: serialize and externalize Sequence Detector object</p></a></li>
<li><a href='#setInputDefinitions+2CHybridSequenceClassifier-method'><p>Sequence Detector Method: redefine all input definitions</p></a></li>
<li><a href='#setOutputPattern+2CHybridSequenceClassifier-method'><p>Sequence Detector Method: assign output symbols</p></a></li>
<li><a href='#setPreclassifier+2CHybridSequenceClassifier-method'><p>Sequence Detector Method: re-set the pre-classifier object</p></a></li>
<li><a href='#setPreprocessor+2CHybridSequenceClassifier-method'><p>Sequence Detector Method: re-set the pre-processor object</p></a></li>
<li><a href='#synthetic_test_agenda'><p>Synthetic process test</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sequence and Latent Process Detector</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-03-02</td>
</tr>
<tr>
<td>Author:</td>
<td>Dalibor Krleža</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dalibor Krleža &lt;dalibor.krleza@fer.hr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Sequence detector in this package contains a specific automaton model that can be used to learn and detect data and process sequences.
    Automaton model in this package is capable of learning and tracing sequences. Automaton model can be found in Krleža, Vrdoljak, Brčić (2019) &lt;<a href="https://doi.org/10.1109%2FACCESS.2019.2955245">doi:10.1109/ACCESS.2019.2955245</a>&gt;.
    This research has been partly supported under Competitiveness and Cohesion Operational Programme from the European Regional and Development Fund, as part of the Integrated Anti-Fraud System project no. KK.01.2.1.01.0041. This research has also been partly supported by the European Regional Development Fund under the grant KK.01.1.1.01.0009.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), Rcpp (&ge; 1.0.3), eventdataR</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, dplyr, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>xtable</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RcppModules:</td>
<td>ETT</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>xtable, dplyr</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++14</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-03-02 09:09:05 UTC; dkrleza</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-03-02 14:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='bpi_challenge_2019_test1'>BPI 2019 challenge test</h2><span id='topic+bpi_challenge_2019_test1'></span>

<h3>Description</h3>

<p>A single sales process flow from the BPI 2019 challenge event log was taken to perform the Sequence Detector testing.
The results are available in [1].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bpi_challenge_2019_test1()
</code></pre>


<h3>Value</h3>

<p>None
</p>


<h3>References</h3>

<p>[1] D. Krleža, B. Vrdoljak, and M. Brčić, Latent Process Discovery using Evolving Tokenized Transducer, <em>IEEE Access</em>, vol. 7, pp. 169657 - 169676, Dec. 2019
</p>

<hr>
<h2 id='c_to_string'>String list formatting function</h2><span id='topic+c_to_string'></span>

<h3>Description</h3>

<p>A method that formats an input list made of strings into a single output string.
The output string is formatted as <em>[e1,e2,...,en]</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_to_string(var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_to_string_+3A_var">var</code></td>
<td>
<p>(list) - A string list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(character) - An output string made of the input list elements, formatted as <em>[e1,e2,...,en]</em>.
</p>

<hr>
<h2 id='classify'>Pre-classifying method</h2><span id='topic+classify'></span>

<h3>Description</h3>

<p>An abstract method that needs to be implemented by classes that derive <code><a href="#topic+HSC_PC">HSC_PC</a></code>.
It performs classification on the input event stream.
See the SeqDetect vignette for details on how to implement a <code><a href="#topic+HSC_PC">HSC_PC</a></code> derived class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify(x, stream, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classify_+3A_x">x</code></td>
<td>
<p>(<code><a href="#topic+HSC_PC">HSC_PC</a></code>) - A pre-classifier object</p>
</td></tr>
<tr><td><code id="classify_+3A_stream">stream</code></td>
<td>
<p>(data.frame) - An input event stream</p>
</td></tr>
<tr><td><code id="classify_+3A_...">...</code></td>
<td>
<p>An additional list of parameters needed for the used pre-classifier.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(data.frame) - An output, a consolidated stream. Each row in the output data.frame must have <em>.clazz</em> field, containing the row classification value.
</p>

<hr>
<h2 id='cleanKeys+2CHybridSequenceClassifier-method'>Sequence Detector Method: clean keys and tokens in machines (ETTs)</h2><span id='topic+cleanKeys+2CHybridSequenceClassifier-method'></span>

<h3>Description</h3>

<p>Sequence Detector method for removing tokens.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'HybridSequenceClassifier'
cleanKeys(machine_id=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cleanKeys+2B2CHybridSequenceClassifier-method_+3A_machine_id">machine_id</code></td>
<td>
<p>(character) - An identifier of the machine (ETT) whose token needs to be removed. If NULL, all machines tokens are removed.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+HybridSequenceClassifier">HybridSequenceClassifier</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st &lt;- data.frame(product=c("P45","P134","P45","P134","P134","P45","P134"),
                 sales=c(2,12,18,16,18,24,8),
                 alert=c(NA,NA,NA,NA,NA,"Alert P45","Alert P134"))
input_streams &lt;- list(stream=st)
pp &lt;- HSC_PP(c("product","sales"),"sequence_id",auto_id=TRUE)
pc &lt;- HSC_PC_Binning(0,100,40,"sales")
hsc &lt;- HybridSequenceClassifier(c("product","sales","sequence_id"),
       "sequence_id","sequence_id","product",pc,pp)
hsc$process(input_streams)
hsc$cleanKeys()
</code></pre>

<hr>
<h2 id='clone+2CHybridSequenceClassifier-method'>Sequence Detector Method: clone the Sequence Detector object</h2><span id='topic+clone+2CHybridSequenceClassifier-method'></span>

<h3>Description</h3>

<p>Sequence Detector method for cloning. Clones the Sequence Detector object and all its ETTs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'HybridSequenceClassifier'
clone()
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+HybridSequenceClassifier">HybridSequenceClassifier</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st &lt;- data.frame(product=c("P45","P134","P45","P134","P134","P45","P134"),
                 sales=c(2,12,18,16,18,24,8),
                 alert=c(NA,NA,NA,NA,NA,"Alert P45","Alert P134"))
input_streams &lt;- list(stream=st)
pp &lt;- HSC_PP(c("product","sales"),"sequence_id",auto_id=TRUE)
pc &lt;- HSC_PC_Binning(0,100,40,"sales")
hsc &lt;- HybridSequenceClassifier(c("product","sales","sequence_id"),
       "sequence_id","sequence_id","product",pc,pp)
hsc$process(input_streams)

tt &lt;- data.frame(product=c("P672","P113","P983","P23872","P5","P672","P2982","P983","P672",
                           "P991","P983","P113","P2982","P344"),
                 sales=c(2,11,12,98,8,18,298,16,24,25,18,16,43,101),alert=NA)
test_streams &lt;- list(stream=tt)
hsc2 &lt;- hsc$clone()
hsc2$process(test_streams,learn=FALSE)
</code></pre>

<hr>
<h2 id='compressMachines+2CHybridSequenceClassifier-method'>Sequence Detector Method: compress machines (ETTs)</h2><span id='topic+compressMachines+2CHybridSequenceClassifier-method'></span>

<h3>Description</h3>

<p>Sequence Detector method for compressing machines by isolating common isomorphic sub-structured into child ETTs. See the SeqDetect vignette for details and examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'HybridSequenceClassifier'
compressMachines(ratio=0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compressMachines+2B2CHybridSequenceClassifier-method_+3A_ratio">ratio</code></td>
<td>
<p>(numeric) - A minimal isomorphic overlap between ETTs to be eligible for compression. Using this parameter too low (e.g. &lt;0.5) might lead to overfragmentation of ETTs.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+HybridSequenceClassifier">HybridSequenceClassifier</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st &lt;- data.frame(product=c("P45","P134","P45","P134","P134","P45","P134"),
                 sales=c(2,12,18,16,18,24,8),
                 alert=c(NA,NA,NA,NA,NA,"Alert P45","Alert P134"))
input_streams &lt;- list(stream=st)
pp &lt;- HSC_PP(c("product","sales"),"sequence_id",auto_id=TRUE)
pc &lt;- HSC_PC_Binning(0,100,40,"sales")
hsc &lt;- HybridSequenceClassifier(c("product","sales","sequence_id"),
       "sequence_id","sequence_id","product",pc,pp)
hsc$process(input_streams)
hsc$compressMachines()
</code></pre>

<hr>
<h2 id='deserializeFromList'>Sequence Detector Method: deserialize Sequence Detector object from external list</h2><span id='topic+deserializeFromList'></span>

<h3>Description</h3>

<p>Sequence Detector method for deserializing from a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deserializeFromList(l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deserializeFromList_+3A_l">l</code></td>
<td>
<p>(list) - A list containing a Sequence Detector details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(HybridSequenceClassifier) - Returns a deserialized Sequence Detector object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HybridSequenceClassifier-class">HybridSequenceClassifier-class</a></code>,
<code><a href="#topic+serializeToList+2CHybridSequenceClassifier-method">serializeToList,HybridSequenceClassifier-method</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st &lt;- data.frame(product=c("P45","P134","P45","P134","P134","P45","P134"),
                 sales=c(2,12,18,16,18,24,8),
                 alert=c(NA,NA,NA,NA,NA,"Alert P45","Alert P134"))
input_streams &lt;- list(stream=st)
pp &lt;- HSC_PP(c("product","sales"),"sequence_id",auto_id=TRUE)
pc &lt;- HSC_PC_Binning(0,100,40,"sales")
hsc &lt;- HybridSequenceClassifier(c("product","sales","sequence_id"),
       "sequence_id","sequence_id","product",pc,pp)
hsc$process(input_streams)

hsc_list &lt;- hsc$serializeToList()
saveRDS(hsc_list,"test_list.RDS")


new_hsc_list &lt;- readRDS("test_list.RDS")
file.remove("test_list.RDS")
hsc2 &lt;- deserializeFromList(new_hsc_list)
</code></pre>

<hr>
<h2 id='getMachineIdentifiers+2CHybridSequenceClassifier-method'>Sequence Detector Method: retrieve machine identifiers (ETTs)</h2><span id='topic+getMachineIdentifiers+2CHybridSequenceClassifier-method'></span>

<h3>Description</h3>

<p>Sequence Detector method for retrieving list of machine identifiers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'HybridSequenceClassifier'
getMachineIdentifiers()
</code></pre>


<h3>Value</h3>

<p>(list) A list of strings, represeting machine identifiers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HybridSequenceClassifier">HybridSequenceClassifier</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st &lt;- data.frame(product=c("P45","P134","P45","P134","P134","P45","P134"),
                 sales=c(2,12,18,16,18,24,8),
                 alert=c(NA,NA,NA,NA,NA,"Alert P45","Alert P134"))
input_streams &lt;- list(stream=st)
pp &lt;- HSC_PP(c("product","sales"),"sequence_id",auto_id=TRUE)
pc &lt;- HSC_PC_Binning(0,100,40,"sales")
hsc &lt;- HybridSequenceClassifier(c("product","sales","sequence_id"),
       "sequence_id","sequence_id","product",pc,pp)
res &lt;- hsc$process(input_streams)
message(hsc$getMachineIdentifiers())
</code></pre>

<hr>
<h2 id='HSC_PC'>Abstract pre-classifier class</h2><span id='topic+HSC_PC'></span>

<h3>Description</h3>

<p>All pre-classifiers must inherit this class. A pre-classifier instance cannot be directly created by this abstract class.
</p>


<h3>See Also</h3>

<p><a href="#topic+HSC_PC_None">HSC_PC_None</a>,<a href="#topic+HSC_PC_Attribute">HSC_PC_Attribute</a>,<a href="#topic+HSC_PC_Binning">HSC_PC_Binning</a>
</p>

<hr>
<h2 id='HSC_PC_Attribute'>Attribute pre-classifier</h2><span id='topic+HSC_PC_Attribute'></span>

<h3>Description</h3>

<p>Extends the <a href="#topic+HSC_PC">HSC_PC</a> abstract class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HSC_PC_Attribute(field)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HSC_PC_Attribute_+3A_field">field</code></td>
<td>
<p>(character) - Field taken as the classification value from the input event stream.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A pre-classifier takes classification from the predefined field in the input event stream and copies these values to the
<em>.clazz</em> field. The rest of the input event stream remains unmodified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>event_stream &lt;- data.frame(product=c("P45","P134","P45","P134","P134","P45","P134"),
                           sales=c(2,12,18,16,18,24,8),
                           alert=c(NA,NA,NA,NA,NA,"Alert P45","Alert P134"))
pc &lt;- HSC_PC_Attribute("sales")
cons_stream &lt;- classify(pc,event_stream)
</code></pre>

<hr>
<h2 id='HSC_PC_Binning'>Binning pre-classifier</h2><span id='topic+HSC_PC_Binning'></span>

<h3>Description</h3>

<p>Extends the <a href="#topic+HSC_PC">HSC_PC</a> abstract class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HSC_PC_Binning(min_value, max_value, bins, value_field)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HSC_PC_Binning_+3A_min_value">min_value</code></td>
<td>
<p>(numeric) - Minimal value.</p>
</td></tr>
<tr><td><code id="HSC_PC_Binning_+3A_max_value">max_value</code></td>
<td>
<p>(numeric) - Maximal value:</p>
</td></tr>
<tr><td><code id="HSC_PC_Binning_+3A_bins">bins</code></td>
<td>
<p>(integer) - A number of bins that needs to be created.</p>
</td></tr>
<tr><td><code id="HSC_PC_Binning_+3A_value_field">value_field</code></td>
<td>
<p>(character) - The name of the value field in the input event stream.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A pre-classifier takes performs binning on a value field of the input event stream.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>event_stream &lt;- data.frame(product=c("P45","P134","P45","P134","P134","P45","P134"),
                           sales=c(2,12,18,16,18,24,8),
                           alert=c(NA,NA,NA,NA,NA,"Alert P45","Alert P134"))
pc &lt;- HSC_PC_Binning(0,100,40,"sales")
cons_stream &lt;- classify(pc,event_stream)
# Minimal value = 0, Maximal value = 100, 40 bins, values taken from the field named *sales*
</code></pre>

<hr>
<h2 id='HSC_PC_None'>Straight-through pre-classifier</h2><span id='topic+HSC_PC_None'></span>

<h3>Description</h3>

<p>Extends the <a href="#topic+HSC_PC">HSC_PC</a> abstract class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HSC_PC_None()
</code></pre>


<h3>Details</h3>

<p>A pre-classifier class that does not contain any classifier. It passes an input event stream straight through without any modifications.
The only thing is to check whether the input event stream contains <em>.clazz</em> field, which should carry classification and input symbols for Sequence Detector ETTs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>event_stream &lt;- data.frame(product=c("P45","P134","P45","P134","P134","P45","P134"),
                           sales=c(2,12,18,16,18,24,8),
                           alert=c(NA,NA,NA,NA,NA,"Alert P45","Alert P134"),
                           .clazz=c(2,12,18,16,18,24,8))
pc &lt;- HSC_PC_None()
cons_stream &lt;- classify(pc,event_stream)
</code></pre>

<hr>
<h2 id='HSC_PP'>Pre-processor top-level class</h2><span id='topic+HSC_PP'></span>

<h3>Description</h3>

<p>Class that needs to be derived to create new pre-processors. A pre-processor can be directly instantiated from the HSC_PP class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HSC_PP(fields, timestamp_field, create_unique_key = FALSE,
  auto_id = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HSC_PP_+3A_fields">fields</code></td>
<td>
<p>(vector) - The complete list of fields in the input data streams that needs to be present in the output event stream</p>
</td></tr>
<tr><td><code id="HSC_PP_+3A_timestamp_field">timestamp_field</code></td>
<td>
<p>(character) - The name of the sequencing field. Could be autogenerated by the pre-processor, or already present in the input data streams. Used for ordering of the output event stream.</p>
</td></tr>
<tr><td><code id="HSC_PP_+3A_create_unique_key">create_unique_key</code></td>
<td>
<p>(logical) - If TRUE, the pre-processor adds field named <em>.key</em> to the output event stream comprising a unique key (1) for all data items.</p>
</td></tr>
<tr><td><code id="HSC_PP_+3A_auto_id">auto_id</code></td>
<td>
<p>(logical) - If TRUE, the pre-processor generates autoincremented values and assigns then to the <em>timestamp_field</em>. Can be used when input data streams do not comprise any timing information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Example 1</strong><br />
<code>pp &lt;- HSC_PP(c("product","time","sales"),"time")</code> - Creates a new HSC_PP pre-processor that uses <em>time</em> field for ordering of the output event stream.<br />
</p>
<p><strong>Example 2</strong><br />
<code>pp &lt;- HSC_PP(c("product","sales"),"sequence_id",auto_id=TRUE)</code> - Creates a new HSC_PP pre-processor that has no time field. Instead, the pre-processor adds the <em>sequence_id</em> field and generates autoincremented values for it.<br />
</p>
<p><strong>Example 3</strong><br />
<code>pp &lt;- HSC_PP(c("sequence_val"),"sequence_id",create_unique_key=TRUE,auto_id=TRUE)</code> - Creates a new HSC_PP pre-processor that has no time and no key field. The pre-processor adds the <em>sequence_id</em> field and generates autoincremented values for it. Also, the <em>.key=1</em> column is added to all output events.<br />
</p>

<hr>
<h2 id='HybridSequenceClassifier-class'>Sequence Detector</h2><span id='topic+HybridSequenceClassifier-class'></span><span id='topic+HybridSequenceClassifier'></span>

<h3>Description</h3>

<p>The Sequence Detector class.
</p>


<h3>Details</h3>

<p>Instantiates a Sequence Detector object. Constructor takes a number of parameters that define pre-processing
and pre-classification stages, as well as the structure of the input consolidated data stream.
These stages can be redefined again later using <code><a href="#topic+setInputDefinitions+2CHybridSequenceClassifier-method">setInputDefinitions,HybridSequenceClassifier-method</a></code> method.
See the SeqDetect vignette for examples.
</p>


<h3>Fields</h3>


<dl>
<dt>fields</dt><dd><p>(vector, character) - A vector of all relevant consolidated data stream fields.</p>
</dd>
<dt>timestamp_start_field</dt><dd><p>(character) - A name of the field having starting time point values.</p>
</dd>
<dt>timestamp_finish_field</dt><dd><p>(character) - A name of the field having finishing time point values.</p>
</dd>
<dt>context_field</dt><dd><p>(character) - A name of the context identifier field (key field). If NULL, then <em>.key</em> field is used for retrieving context identifier values.</p>
</dd>
<dt>preclassifier</dt><dd><p>(<a href="#topic+HSC_PC">HSC_PC</a>) - A pre-classifier object. If NULL, the Sequence Detector creates new <em>HSC_PC_None</em> pre-classifier, which means that the input consolidated data stream must have <em>.clazz</em> field for retrieving classification values (input symbols in the underlying ETTs).</p>
</dd>
<dt>preprocessor</dt><dd><p>(<a href="#topic+HSC_PP">HSC_PP</a>) - A pre-processing object. If NULL, the Sequence Detector creates new <em>HSC_PP</em> pre-processor having the same fields as define in the <em>fields</em> parameter, and ordering timestamp field as defined in <em>timestamp_start_field</em>.</p>
</dd>
<dt>decay_descriptors</dt><dd><p>(list) - A list of decay descriptors. If NULL, token decay machanism is not used. Descriptor structure can be seen in vignettes.</p>
</dd>
<dt>pattern_field</dt><dd><p>(character) - A name of the field having output symbol values, i.e., relational ETT classification output.</p>
</dd>
<dt>time_series_sequence_stats</dt><dd><p>(logical) - If TRUE, ETTs are instructed to create sequence statistics. This is used whe having input time-series data streams. If FALSE, the sequence statistics are not created.</p>
</dd>
<dt>reuse_states</dt><dd><p>(logical) - The parameter defined in [1]. ETTs are created so that each ETT have a state that represents each input symbol.</p>
</dd>
<dt>parallel_execution</dt><dd><p>(logical) - Force parallel execution of ETTs in the Sequence Detector object. Useful when we expect higher number of ETTs in the same Sequence Detector.</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>cleanKeys(machine_id=NULL)</code></dt><dd>
<p>Sequence Detector method for removing tokens and keys<br /><code><a href="#topic+cleanKeys+2CHybridSequenceClassifier-method">cleanKeys,HybridSequenceClassifier-method</a></code>
</p>
</dd>
<dt><code>clone()</code></dt><dd>
<p>Sequence Detector method for cloning<br /><code><a href="#topic+clone+2CHybridSequenceClassifier-method">clone,HybridSequenceClassifier-method</a></code>
</p>
</dd>
<dt><code>compressMachines(ratio=0.5)</code></dt><dd>
<p>Sequence Detector method for compressing the underlying set of ETTs<br /><code><a href="#topic+compressMachines+2CHybridSequenceClassifier-method">compressMachines,HybridSequenceClassifier-method</a></code>
</p>
</dd>
<dt><code>getMachineIdentifiers()</code></dt><dd>
<p>Sequence Detector method for retrieving identifiers for the underlying set of ETTs<br /><code><a href="#topic+getMachineIdentifiers+2CHybridSequenceClassifier-method">getMachineIdentifiers,HybridSequenceClassifier-method</a></code>
</p>
</dd>
<dt><code>induceSubmachine(threshold, isolate=FALSE)</code></dt><dd>
<p>Sequence Detector method for performing statistical projections on the underlying set of ETTs<br /><code><a href="#topic+induceSubmachine+2CHybridSequenceClassifier-method">induceSubmachine,HybridSequenceClassifier-method</a></code>
</p>
</dd>
<dt><code>mergeMachines()</code></dt><dd>
<p>Sequence Detector method for merging the underlying set of ETTs<br /><code><a href="#topic+mergeMachines+2CHybridSequenceClassifier-method">mergeMachines,HybridSequenceClassifier-method</a></code>
</p>
</dd>
<dt><code>plotMachines(machine_id=NULL)</code></dt><dd>
<p>Sequence Detector method for plotting the underlying set of ETTs<br /><code><a href="#topic+plotMachines+2CHybridSequenceClassifier-method">plotMachines,HybridSequenceClassifier-method</a></code>
</p>
</dd>
<dt><code>printMachines(machine_id=NULL, state=NULL, print_cache=TRUE, print_keys=TRUE)</code></dt><dd>
<p>Sequence Detector method for printing the underlying set of ETTs to the R console<br /><code><a href="#topic+printMachines+2CHybridSequenceClassifier-method">printMachines,HybridSequenceClassifier-method</a></code>
</p>
</dd>
<dt><code>process(streams, learn=TRUE, give_explain=TRUE, threshold=NULL, debug=FALSE, out_filename=NULL, ...)</code></dt><dd>
<p>Sequence Detector method for processing an input streams slice<br /><code><a href="#topic+process+2CHybridSequenceClassifier-method">process,HybridSequenceClassifier-method</a></code>
</p>
</dd>
<dt><code>serialize()</code></dt><dd>
<p>Sequence Detector method for serializing the underlying set of ETTs definitions<br /><code><a href="#topic+serialize+2CHybridSequenceClassifier-method">serialize,HybridSequenceClassifier-method</a></code>
</p>
</dd>
<dt><code>serializeToList()</code></dt><dd>
<p>Sequence Detector method for serializing the underlying set of ETTs definitions to the list<br /><code><a href="#topic+serializeToList+2CHybridSequenceClassifier-method">serializeToList,HybridSequenceClassifier-method</a></code>
</p>
</dd>
<dt><code>setOutputPattern(states=c(), transitions=c(), pattern, machine_id=NULL)</code></dt><dd>
<p>Sequence Detector method for setting the output alphabet to the underlying set of ETTs<br /><code><a href="#topic+setOutputPattern+2CHybridSequenceClassifier-method">setOutputPattern,HybridSequenceClassifier-method</a></code>
</p>
</dd>
<dt><code>setPreprocessor(preprocessor)</code></dt><dd>
<p>Sequence Detector method for setting the pre-processor<br /><code><a href="#topic+setPreprocessor+2CHybridSequenceClassifier-method">setPreprocessor,HybridSequenceClassifier-method</a></code>
</p>
</dd>
<dt><code>setPreclassifier(preclassifier)</code></dt><dd>
<p>Sequence Detector method for setting the pre-classifier<br /><code><a href="#topic+setPreclassifier+2CHybridSequenceClassifier-method">setPreclassifier,HybridSequenceClassifier-method</a></code>
</p>
</dd>
<dt><code>setInputDefinitions(fields, timestamp_start_field, timestamp_finish_field, context_field=NULL, preclassifier=NULL, preprocessor=NULL, pattern_field=NULL)</code></dt><dd>
<p>Sequence Detector method for redefining the input definitions<br /><code><a href="#topic+setInputDefinitions+2CHybridSequenceClassifier-method">setInputDefinitions,HybridSequenceClassifier-method</a></code>
</p>
</dd>
</dl>


<h3>References</h3>

<p>[1] D. Krleža, B. Vrdoljak, and M. Brčić, Latent Process Discovery using Evolving Tokenized Transducer, <em>IEEE Access</em>, vol. 7, pp. 169657 - 169676, Dec. 2019
</p>

<hr>
<h2 id='induceSubmachine+2CHybridSequenceClassifier-method'>Sequence Detector Method: ETT projection</h2><span id='topic+induceSubmachine+2CHybridSequenceClassifier-method'></span>

<h3>Description</h3>

<p>Sequence Detector method for ETT projections. See the SeqDetect vignette for proper usage and cases. All projection changes are performed on the same Sequence Detector object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'HybridSequenceClassifier'
induceSubmachine(threshold,isolate=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="induceSubmachine+2B2CHybridSequenceClassifier-method_+3A_threshold">threshold</code></td>
<td>
<p>(integer) - A threshold for the ETT projection. All transitions that have invocation statistic above the threshold are moved to a submachine.</p>
</td></tr>
<tr><td><code id="induceSubmachine+2B2CHybridSequenceClassifier-method_+3A_isolate">isolate</code></td>
<td>
<p>(logical) - After the regular sequences are moved the the submachine, the original parent can be removed, leaving only the most regular sequences. If TRUE, the parent ETT is removed and only the most regular sequences are left.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns:<br />
TRUE - projection was performed successfully<br />
FALSE - no projection was performed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HybridSequenceClassifier">HybridSequenceClassifier</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st &lt;- data.frame(product=c("P1","P2"),sales=c(5,76),alert=c(NA,NA))
for(i in 1:400) {
  st &lt;- rbind(st,data.frame(product=c("P1","P2"),sales=c(10,58),alert=c(NA,NA)))
  st &lt;- rbind(st,data.frame(product=c("P1","P2"),sales=c(20,31),alert=c(NA,NA)))
}
st &lt;- rbind(st,data.frame(product=c("P1","P2"),sales=c(30,11),
                          alert=c("Sequence 1","Sequence 2")))
input_streams &lt;- list(stream=st)
pp &lt;- HSC_PP(c("product","sales","alert"),"sequence_id",auto_id=TRUE)
pc &lt;- HSC_PC_Attribute("sales")
hsc &lt;- HybridSequenceClassifier(c("sequence_id","product","sales","alert"),"sequence_id",
                                         "sequence_id",context_field="product",preclassifier=pc,
                                         preprocessor=pp,reuse_states=TRUE,pattern_field="alert")
hsc$process(input_streams,learn=TRUE)
hsc$cleanKeys()
hsc$induceSubmachine(200,isolate=TRUE)
hsc$printMachines()
</code></pre>

<hr>
<h2 id='mergeMachines+2CHybridSequenceClassifier-method'>Sequence Detector Method: merge machines (ETTs)</h2><span id='topic+mergeMachines+2CHybridSequenceClassifier-method'></span>

<h3>Description</h3>

<p>Sequence Detector method for merging machines. See the SeqDetect vignette for details and examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'HybridSequenceClassifier'
mergeMachines()
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+HybridSequenceClassifier">HybridSequenceClassifier</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ldf1 &lt;- data.frame(product=c("P1","P1","P1","P1"),sequence_id=c(1,3,5,7),
                   sales=c(5,76,123,1),alert=c(NA,NA,NA,"Alert P1"))
ldf2 &lt;- data.frame(product=c("P2","P2","P2","P2"),sequence_id=c(2,4,6,8),
                   sales=c(21,76,123,42),alert=c(NA,NA,NA,"Alert P2"))
input_streams &lt;- list(stream1=ldf1,stream2=ldf2)
pp &lt;- HSC_PP(c("product","sales","alert","sequence_id"),"sequence_id")
pc &lt;- HSC_PC_Attribute("sales")
hsc &lt;- HybridSequenceClassifier(c("sequence_id","product","sales","alert"),
                                         "sequence_id","sequence_id",context_field="product",
                                         preclassifier=pc,preprocessor=pp,reuse_states=TRUE,
                                         pattern_field="alert")
hsc$process(input_streams,learn=TRUE)
hsc$cleanKeys()
hsc$mergeMachines()
hsc$printMachines()
</code></pre>

<hr>
<h2 id='plotMachines+2CHybridSequenceClassifier-method'>Sequence Detector Method: plot machines (ETTs)</h2><span id='topic+plotMachines+2CHybridSequenceClassifier-method'></span>

<h3>Description</h3>

<p>Sequence Detector method for plotting of machines in the Sequence Detector object. Plotting is following the output symbols of the states and transitions. For machines that don't have a small output alphabet could not be plotted fully and correctly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'HybridSequenceClassifier'
plotMachines(machine_id=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMachines+2B2CHybridSequenceClassifier-method_+3A_machine_id">machine_id</code></td>
<td>
<p>(character) - A machine identifier that needs to be plotted. If NULL, all machines are plotted.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+HybridSequenceClassifier">HybridSequenceClassifier</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ldf1 &lt;- data.frame(product=c("P1","P1","P1","P1"),sequence_id=c(1,3,5,7),
                   sales=c(5,76,123,1),alert=c(NA,NA,NA,"Alert P1"))
ldf2 &lt;- data.frame(product=c("P2","P2","P2","P2"),sequence_id=c(2,4,6,8),
                   sales=c(21,76,123,42),alert=c(NA,NA,NA,"Alert P2"))
input_streams &lt;- list(stream1=ldf1,stream2=ldf2)
pp &lt;- HSC_PP(c("product","sales","alert","sequence_id"),"sequence_id")
pc &lt;- HSC_PC_Attribute("sales")
hsc &lt;- HybridSequenceClassifier(c("sequence_id","product","sales","alert"),
                                         "sequence_id","sequence_id",context_field="product",
                                         preclassifier=pc,preprocessor=pp,reuse_states=TRUE,
                                         pattern_field="alert")
hsc$process(input_streams,learn=TRUE)
hsc$cleanKeys()
hsc$mergeMachines()
hsc$plotMachines()
</code></pre>

<hr>
<h2 id='preprocess'>Pre-processing method</h2><span id='topic+preprocess'></span>

<h3>Description</h3>

<p>A method that all pre-processor classes need to implement. It is the code that aggregates and consolidates input data streams into one output event stream.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preprocess(x, streams, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preprocess_+3A_x">x</code></td>
<td>
<p>The pre-processor object.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_streams">streams</code></td>
<td>
<p>A named list that comprises input data streams. Each input data stream is a data frame comprising fields declared while creating the <a href="#topic+HSC_PP">HSC_PP</a> object.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_...">...</code></td>
<td>
<p>An additional list of parameters that can be used by the pre-proccessor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input streams can be created as</p>
<pre>streams -&gt; list(stream1=x1,stream2=x2,....)
</pre>
<p>where <em>x1</em> is a data frame and <em>stream1</em> is the name of the stream. All examnples can be seen in the SeqDetect vignette.
</p>


<h3>Value</h3>

<p>Returns a list that comprises:
</p>

<ul>
<li> <p><em>obj</em> - A returning pre-processor object. Passed in the subsequent invocation as <em>x</em>.
</p>
</li>
<li> <p><em>res</em> - An output event stream. A resulting data frame representing the output event stream that is ordered according to the timestamp / sequence field and comprises all declared fields.
</p>
</li></ul>


<hr>
<h2 id='printMachines+2CHybridSequenceClassifier-method'>Sequence Detector Method: printout machines (ETTs)</h2><span id='topic+printMachines+2CHybridSequenceClassifier-method'></span>

<h3>Description</h3>

<p>Sequence Detector method for printing out the machines (ETTs) in the Sequence Detector object. See The SeqDetect vignette for proper usage and cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'HybridSequenceClassifier'
printMachines(machine_id=NULL,state=NULL,print_cache=TRUE,print_keys=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printMachines+2B2CHybridSequenceClassifier-method_+3A_machine_id">machine_id</code></td>
<td>
<p>(character) - If defined, printout only machine that has the supplied identifier. If NULL, printout all machines.</p>
</td></tr>
<tr><td><code id="printMachines+2B2CHybridSequenceClassifier-method_+3A_state">state</code></td>
<td>
<p>(character) - If defined, printout only states that have the supplied identifier. If NULL, printout all states.</p>
</td></tr>
<tr><td><code id="printMachines+2B2CHybridSequenceClassifier-method_+3A_print_cache">print_cache</code></td>
<td>
<p>(logical) - Switch for printout of the cache. If FALSE, the cache printout is omitted. The cache can be quite big for each machine and state, and could potentially blur the printout.</p>
</td></tr>
<tr><td><code id="printMachines+2B2CHybridSequenceClassifier-method_+3A_print_keys">print_keys</code></td>
<td>
<p>(logical) - Switch for printout of the current token set. If FALSE, the token set printout is omitted. The number of tokens can be considerable, and could potentially blur the printout.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+HybridSequenceClassifier">HybridSequenceClassifier</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ldf1 &lt;- data.frame(product=c("P1","P1","P1","P1"),sequence_id=c(1,3,5,7),
                   sales=c(5,76,123,1),alert=c(NA,NA,NA,"Alert P1"))
ldf2 &lt;- data.frame(product=c("P2","P2","P2","P2"),sequence_id=c(2,4,6,8),
                   sales=c(21,76,123,42),alert=c(NA,NA,NA,"Alert P2"))
input_streams &lt;- list(stream1=ldf1,stream2=ldf2)
pp &lt;- HSC_PP(c("product","sales","alert","sequence_id"),"sequence_id")
pc &lt;- HSC_PC_Attribute("sales")
hsc &lt;- HybridSequenceClassifier(c("sequence_id","product","sales","alert"),
                                         "sequence_id","sequence_id",context_field="product",
                                         preclassifier=pc,preprocessor=pp,reuse_states=TRUE,
                                         pattern_field="alert")
hsc$process(input_streams,learn=TRUE)
hsc$cleanKeys()
hsc$mergeMachines()
hsc$printMachines()
</code></pre>

<hr>
<h2 id='process+2CHybridSequenceClassifier-method'>Sequence Detector Method: processing input data streams</h2><span id='topic+process+2CHybridSequenceClassifier-method'></span>

<h3>Description</h3>

<p>Sequence Detector method for processing of input data streams. See the SeqDetect vignette for proper usage and cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'HybridSequenceClassifier'
process(streams,learn=TRUE,give_explain=TRUE,threshold=NULL,debug=FALSE,
out_filename=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process+2B2CHybridSequenceClassifier-method_+3A_streams">streams</code></td>
<td>
<p>(list, data.frame) - A named list that comprises input data streams. Each list element is a data frame that represents one input data stream.</p>
</td></tr>
<tr><td><code id="process+2B2CHybridSequenceClassifier-method_+3A_learn">learn</code></td>
<td>
<p>(logical) - Are ETTs in the Sequence Detector extendable? If TRUE, the Sequence Detector learns new sequences from the supplied input data streams.</p>
</td></tr>
<tr><td><code id="process+2B2CHybridSequenceClassifier-method_+3A_give_explain">give_explain</code></td>
<td>
<p>(logical) - Determines elements that will be returned by the method. If TRUE, output explanation and sequence statistical analysis will be returned as well.</p>
</td></tr>
<tr><td><code id="process+2B2CHybridSequenceClassifier-method_+3A_threshold">threshold</code></td>
<td>
<p>(integer) - Needed threshold for the pushing mechanism. Pushing will work only for transitions that are above the supplied threshold. If NULL, all transitions are taken in consideration.</p>
</td></tr>
<tr><td><code id="process+2B2CHybridSequenceClassifier-method_+3A_debug">debug</code></td>
<td>
<p>(logical) - A switch for debug printout.</p>
</td></tr>
<tr><td><code id="process+2B2CHybridSequenceClassifier-method_+3A_out_filename">out_filename</code></td>
<td>
<p>(character) - A filename where the consolidated data stream should be written. The written file is in the CSV format. If NULL, file writing is skipped.</p>
</td></tr>
<tr><td><code id="process+2B2CHybridSequenceClassifier-method_+3A_...">...</code></td>
<td>
<p> - An additional list of parameters passed into pre-processor and pre-classifier.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that comprises the following elements:
</p>

<ul>
<li><p>stream - The consolidated stream.
</p>
</li></ul>

<p>If <em>give_explain</em> is TRUE then an additional element is:
</p>

<ul>
<li><p>explanation - Actual and potential output symbols for each data item of the consolidated data stream.
</p>
</li></ul>

<p>If <em>give_explain</em> is TRUE and <em>time_series_sequence_stats</em> is TRUE then an additional element is:
</p>

<ul>
<li><p>sequences - The complete sequence statistics for the input time-series data.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+HybridSequenceClassifier">HybridSequenceClassifier</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st &lt;- data.frame(product=c("P45","P134","P45","P134","P134","P45","P134"),
                 sales=c(2,12,18,16,18,24,8),
                 alert=c(NA,NA,NA,NA,NA,"Alert P45","Alert P134"))
input_streams &lt;- list(stream=st)
pp &lt;- HSC_PP(c("product","sales"),"sequence_id",auto_id=TRUE)
pc &lt;- HSC_PC_Binning(0,100,40,"sales")
hsc &lt;- HybridSequenceClassifier(c("product","sales","sequence_id"),
       "sequence_id","sequence_id","product",pc,pp)
res &lt;- hsc$process(input_streams)
message(res)
</code></pre>

<hr>
<h2 id='sales_dataset_test'>Sales time-series test</h2><span id='topic+sales_dataset_test'></span>

<h3>Description</h3>

<p>Sales dataset taken from [2], which comprises 811 product one year sales quantities. We applied this dataset to test the Sequence Detector.
The results are available in [1]. The results of the test are various statistics on detected sequences.
The testing set of products is re-tested by simultaneously rising the projection threshold, until no more sequences could be detected or <em>max_th</em> parameter is reached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sales_dataset_test(learning_set = 1:20, testing_set = 21:40,
  th_increment = 1, max_th = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sales_dataset_test_+3A_learning_set">learning_set</code></td>
<td>
<p>(vector) - A set of products to learn ETTs in the Sequence Detector.</p>
</td></tr>
<tr><td><code id="sales_dataset_test_+3A_testing_set">testing_set</code></td>
<td>
<p>(vector) - A set of products to test previously learned sales numbers.</p>
</td></tr>
<tr><td><code id="sales_dataset_test_+3A_th_increment">th_increment</code></td>
<td>
<p>(integer) - A threshold increment between two tests.</p>
</td></tr>
<tr><td><code id="sales_dataset_test_+3A_max_th">max_th</code></td>
<td>
<p>(integer) - Maximal thershold for testing. When reached, no further tests and no further threshold increment is done. If NULL, re-testing is done while there are some sequences detected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that comprises sequence statistics for all tests and thresholds.
</p>


<h3>References</h3>

<p>[1] D. Krleža, B. Vrdoljak, and M. Brčić, Latent Process Discovery using Evolving Tokenized Transducer, <em>IEEE Access</em>, vol. 7, pp. 169657 - 169676, Dec. 2019 <br />
[2] S. C. Tan and J. P. San Lau, Time series clustering: A superior alternative for market basket analysis, in Proceedings of the First International Conference on Advanced Data and Information Engineering (DaEng-2013), Singapore, 2014, pp. 241–248.
</p>

<hr>
<h2 id='sepsis_dataset_test'>Sepsis dataset test</h2><span id='topic+sepsis_dataset_test'></span>

<h3>Description</h3>

<p><a href="eventdataR.html#topic+sepsis">sepsis</a> dataset is taken from the package <em>eventdataR</em> and used to test the Sequence Detector. The results are
available in [1].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sepsis_dataset_test(induce_biomarker_decision_tree = TRUE,
  threshold = 75, debug = FALSE, hsc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sepsis_dataset_test_+3A_induce_biomarker_decision_tree">induce_biomarker_decision_tree</code></td>
<td>
<p>(logical) - If FALSE, &quot;Biomarker assessment&quot; is one activity ignoring biomarker values.
If TRUE, based on the biomarker values, several distinct &quot;Biomarker assessment&quot; activities are inferred.</p>
</td></tr>
<tr><td><code id="sepsis_dataset_test_+3A_threshold">threshold</code></td>
<td>
<p>(numeric) - Projection threshold.</p>
</td></tr>
<tr><td><code id="sepsis_dataset_test_+3A_debug">debug</code></td>
<td>
<p>(logical) - Switch for debug printout.</p>
</td></tr>
<tr><td><code id="sepsis_dataset_test_+3A_hsc">hsc</code></td>
<td>
<p>(HybridSequenceClassifier) - An existing Sequence Detector that should be used instead of creating a new one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>References</h3>

<p>[1] D. Krleža, B. Vrdoljak, and M. Brčić, Latent Process Discovery using Evolving Tokenized Transducer, <em>IEEE Access</em>, vol. 7, pp. 169657 - 169676, Dec. 2019
</p>

<hr>
<h2 id='serialize+2CHybridSequenceClassifier-method'>Sequence Detector Method: serialize the Sequence Detector object</h2><span id='topic+serialize+2CHybridSequenceClassifier-method'></span>

<h3>Description</h3>

<p>Sequence Detector method for serializing. User needs to serialize the Sequence Detector object before saving. If not performed, Sequence Detector C++ part of the object is not saved properly, and cannot be restored later.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'HybridSequenceClassifier'
serialize()
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+HybridSequenceClassifier">HybridSequenceClassifier</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st &lt;- data.frame(product=c("P45","P134","P45","P134","P134","P45","P134"),
                 sales=c(2,12,18,16,18,24,8),
                 alert=c(NA,NA,NA,NA,NA,"Alert P45","Alert P134"))
input_streams &lt;- list(stream=st)
pp &lt;- HSC_PP(c("product","sales"),"sequence_id",auto_id=TRUE)
pc &lt;- HSC_PC_Binning(0,100,40,"sales")
hsc &lt;- HybridSequenceClassifier(c("product","sales","sequence_id"),
       "sequence_id","sequence_id","product",pc,pp)
res &lt;- hsc$process(input_streams)
hsc$serialize()
#saveRDS(hsc,"test.RDS")
# Previous line is commented due to the CRAN checking policies
</code></pre>

<hr>
<h2 id='serializeToList+2CHybridSequenceClassifier-method'>Sequence Detector Method: serialize and externalize Sequence Detector object</h2><span id='topic+serializeToList+2CHybridSequenceClassifier-method'></span>

<h3>Description</h3>

<p>Sequence Detector method for serializing to a list. The list can be saved, loaded and deserialized into a Sequence Detector object again using <code><a href="#topic+deserializeFromList">deserializeFromList</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'HybridSequenceClassifier'
serializeToList()
</code></pre>


<h3>Value</h3>

<p>Returns a list that comprises all Sequence Detector details. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HybridSequenceClassifier">HybridSequenceClassifier</a></code>,
<code><a href="#topic+deserializeFromList">deserializeFromList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st &lt;- data.frame(product=c("P45","P134","P45","P134","P134","P45","P134"),
                 sales=c(2,12,18,16,18,24,8),
                alert=c(NA,NA,NA,NA,NA,"Alert P45","Alert P134"))
input_streams &lt;- list(stream=st)
pp &lt;- HSC_PP(c("product","sales"),"sequence_id",auto_id=TRUE)
pc &lt;- HSC_PC_Binning(0,100,40,"sales")
hsc &lt;- HybridSequenceClassifier(c("product","sales","sequence_id"),
       "sequence_id","sequence_id","product",pc,pp)
res &lt;- hsc$process(input_streams)
hsc_list &lt;- hsc$serializeToList()
#saveRDS(hsc_list,"test_list.RDS")
# Previous line is commented due to the CRAN checking policies
</code></pre>

<hr>
<h2 id='setInputDefinitions+2CHybridSequenceClassifier-method'>Sequence Detector Method: redefine all input definitions</h2><span id='topic+setInputDefinitions+2CHybridSequenceClassifier-method'></span>

<h3>Description</h3>

<p>A method for redefining the Sequence Detector input parameters. This method is useful when we want to reuse an existing Sequence Detector for a different set of input data streams. Based on the ETT definition, after the pre-processing and pre-classification stages we need to have a consolidated data frame that comprises context identifier, sequence fields (timestamps or incremental value) and classification values (an input symbol). Not everything can be redefined and needs to be left as defined at the time of Sequence Detector instantiation, such as decay descriptors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'HybridSequenceClassifier'
setInputDefinitions(fields, timestamp_start_field, timestamp_finish_field, 
context_field=NULL, preclassifier=NULL, preprocessor=NULL, pattern_field=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setInputDefinitions+2B2CHybridSequenceClassifier-method_+3A_fields">fields</code></td>
<td>
<p>(vector, character) - A vector of all relevant consolidated data stream fields.</p>
</td></tr>
<tr><td><code id="setInputDefinitions+2B2CHybridSequenceClassifier-method_+3A_timestamp_start_field">timestamp_start_field</code></td>
<td>
<p>(character) - A name of the field having starting time point values.</p>
</td></tr>
<tr><td><code id="setInputDefinitions+2B2CHybridSequenceClassifier-method_+3A_timestamp_finish_field">timestamp_finish_field</code></td>
<td>
<p>(character) - A name of the field having finishing time point values.</p>
</td></tr>
<tr><td><code id="setInputDefinitions+2B2CHybridSequenceClassifier-method_+3A_context_field">context_field</code></td>
<td>
<p>(character) - A name of the context identifier field (key field). If NULL, then <em>.key</em> field is used for retrieving context identifier values.</p>
</td></tr>
<tr><td><code id="setInputDefinitions+2B2CHybridSequenceClassifier-method_+3A_preclassifier">preclassifier</code></td>
<td>
<p>(<a href="#topic+HSC_PC">HSC_PC</a>) - A pre-classifier object. If NULL, the Sequence Detector creates new <em>HSC_PC_None</em> pre-classifier, which means that the input consolidated data stream must have <em>.clazz</em> field for retrieving classification values (input symbols in the underlying ETTs).</p>
</td></tr>
<tr><td><code id="setInputDefinitions+2B2CHybridSequenceClassifier-method_+3A_preprocessor">preprocessor</code></td>
<td>
<p>(<a href="#topic+HSC_PP">HSC_PP</a>) - A pre-processing object. If NULL, the Sequence Detector creates new <em>HSC_PP</em> pre-processor having the same fields as define in the <em>fields</em> parameter, and ordering timestamp field as defined in <em>timestamp_start_field</em>.</p>
</td></tr>
<tr><td><code id="setInputDefinitions+2B2CHybridSequenceClassifier-method_+3A_pattern_field">pattern_field</code></td>
<td>
<p>(character) - A name of the field having output symbol values, i.e., relational ETT classification output.</p>
</td></tr>
</table>

<hr>
<h2 id='setOutputPattern+2CHybridSequenceClassifier-method'>Sequence Detector Method: assign output symbols</h2><span id='topic+setOutputPattern+2CHybridSequenceClassifier-method'></span>

<h3>Description</h3>

<p>Sequence Detector method for assigning output symbols to states and transitions. See the SeqDetect vignette for proper usage and cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'HybridSequenceClassifier'
setOutputPattern(states=c(),transitions=c(),pattern,machine_id=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setOutputPattern+2B2CHybridSequenceClassifier-method_+3A_states">states</code></td>
<td>
<p>(vector,character) - A character vector that comprises state identifiers. The supplied symbol (output alphabet, pattern parameter) is assigned to these states.</p>
</td></tr>
<tr><td><code id="setOutputPattern+2B2CHybridSequenceClassifier-method_+3A_transitions">transitions</code></td>
<td>
<p>(vector,character) - A character vector that comprises transition identifiers. The supplied symbol (output alphabet, pattern parameter) is assigned to these transitions.</p>
</td></tr>
<tr><td><code id="setOutputPattern+2B2CHybridSequenceClassifier-method_+3A_pattern">pattern</code></td>
<td>
<p>(character) - An output symbol, an element of the output alphabet, that needs to be assigned to supplied states and transitions.</p>
</td></tr>
<tr><td><code id="setOutputPattern+2B2CHybridSequenceClassifier-method_+3A_machine_id">machine_id</code></td>
<td>
<p>(character) - If defined, the output symbol assignment applies only to the machine having this identifier. If NULL, the output symbol assignment applies to all machines (ETTs) in this Sequence Detector object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+HybridSequenceClassifier">HybridSequenceClassifier</a></code>
</p>

<hr>
<h2 id='setPreclassifier+2CHybridSequenceClassifier-method'>Sequence Detector Method: re-set the pre-classifier object</h2><span id='topic+setPreclassifier+2CHybridSequenceClassifier-method'></span>

<h3>Description</h3>

<p>Sequence Detector method for re-setting the pre-classifier object. This might be desirable when we want to use already existing Sequence Detector for new input data streams, having different structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'HybridSequenceClassifier'
setPreclassifier(preclassifier)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setPreclassifier+2B2CHybridSequenceClassifier-method_+3A_preclassifier">preclassifier</code></td>
<td>
<p>(<code><a href="#topic+HSC_PC">HSC_PC</a></code>) - New pre-classifier object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+HybridSequenceClassifier">HybridSequenceClassifier</a></code>
</p>

<hr>
<h2 id='setPreprocessor+2CHybridSequenceClassifier-method'>Sequence Detector Method: re-set the pre-processor object</h2><span id='topic+setPreprocessor+2CHybridSequenceClassifier-method'></span>

<h3>Description</h3>

<p>Sequence Detector method for re-setting the pre-processor object. This might be desirable when we want to use already existing Sequence Detector for new input data streams, having different structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'HybridSequenceClassifier'
setPreprocessor(preprocessor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setPreprocessor+2B2CHybridSequenceClassifier-method_+3A_preprocessor">preprocessor</code></td>
<td>
<p>(<code><a href="#topic+HSC_PP">HSC_PP</a></code>) - New pre-processor object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+HybridSequenceClassifier">HybridSequenceClassifier</a></code>
</p>

<hr>
<h2 id='synthetic_test_agenda'>Synthetic process test</h2><span id='topic+synthetic_test_agenda'></span>

<h3>Description</h3>

<p>A synthetic process that was introduced in the process mining agenda [1].
The original event log introduced in [1] did not comprise any timestamps, and a process discovery algorithm was intended to infer this based on the event position in the log.
ETT and new process discovery algorithms require events to have at least some sort of timing, and this was added for this test.
It is worth noticing that the given event log has some parallel activities, which should be detected by the process discovery algorithm.
The final results of this test are described in [2].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synthetic_test_agenda(label_aspect=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="synthetic_test_agenda_+3A_label_aspect">label_aspect</code></td>
<td>
<p>(numeric) - A vector of all relevant consolidated data stream fields.</p>
</td></tr>
</table>


<h3>References</h3>

<p>[1] W. M. P. van der Aalst and A. J. M. M. Weijters, Process mining: a research agenda, <em>Computers in Industry</em>, vol. 53, no. 2, pp. 231&ndash;244, Apr. 2004<br /> 
[2] D. Krleža, B. Vrdoljak, and M. Brčić, Latent Process Discovery using Evolving Tokenized Transducer, <em>IEEE Access</em>, vol. 7, pp. 169657 - 169676, Dec. 2019
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
