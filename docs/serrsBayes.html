<!DOCTYPE html><html lang="en"><head><title>Help for package serrsBayes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {serrsBayes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#computeLogLikelihood'><p>Compute the log-likelihood.</p></a></li>
<li><a href='#copyLogProposals'><p>Initialise the vector of Metropolis-Hastings proposals.</p></a></li>
<li><a href='#effectiveSampleSize'><p>Compute the effective sample size (ESS) of the particles.</p></a></li>
<li><a href='#fitSpectraMCMC'><p>Fit the model using Markov chain Monte Carlo.</p></a></li>
<li><a href='#fitSpectraSMC'><p>Fit the model using Sequential Monte Carlo (SMC).</p></a></li>
<li><a href='#fitVoigtIBIS'><p>Fit the model with Voigt peaks using iterated batch importance sampling (IBIS).</p></a></li>
<li><a href='#fitVoigtPeaksSMC'><p>Fit the model with Voigt peaks using Sequential Monte Carlo (SMC).</p></a></li>
<li><a href='#getBsplineBasis'><p>Compute cubic B-spline basis functions for the given wavenumbers.</p></a></li>
<li><a href='#getVoigtParam'><p>Compute the pseudo-Voigt mixing ratio for each peak.</p></a></li>
<li><a href='#lsTamra'><p>Surface-enhanced Raman spectram of tetramethylrhodamine+DNA (T20)</p></a></li>
<li><a href='#marginalMetropolisUpdate'><p>Update all of the parameters using a single Metropolis-Hastings step.</p></a></li>
<li><a href='#methanol'><p>Raman spectrum of methanol (CH3OH)</p></a></li>
<li><a href='#mhUpdateVoigt'><p>Update the parameters of the Voigt peaks using marginal Metropolis-Hastings.</p></a></li>
<li><a href='#mixedVoigt'><p>Compute the spectral signature using Voigt peaks.</p></a></li>
<li><a href='#resampleParticles'><p>Resample in place to avoid expensive copying of data structures, using a permutation</p>
of the ancestry vector.</a></li>
<li><a href='#residualResampling'><p>Compute an ancestry vector for residual resampling of the SMC particles.</p></a></li>
<li><a href='#result'><p>SMC particles for TAMRA+DNA (T20)</p></a></li>
<li><a href='#result2'><p>SMC particles for methanol (CH3OH)</p></a></li>
<li><a href='#reWeightParticles'><p>Update the importance weights of each particle.</p></a></li>
<li><a href='#serrsBayes'><p>Bayesian modelling and quantification of Raman spectroscopy</p></a></li>
<li><a href='#sumDexp'><p>Sum log-likelihoods of i.i.d. exponential.</p></a></li>
<li><a href='#sumDlogNorm'><p>Sum log-likelihoods of i.i.d. lognormal.</p></a></li>
<li><a href='#sumDnorm'><p>Sum log-likelihoods of Gaussian.</p></a></li>
<li><a href='#weightedGaussian'><p>Compute the spectral signature using Gaussian peaks.</p></a></li>
<li><a href='#weightedLorentzian'><p>Compute the spectral signature using Lorentzian peaks.</p></a></li>
<li><a href='#weightedMean'><p>Compute the weighted arithmetic means of the particles.</p></a></li>
<li><a href='#weightedVariance'><p>Compute the weighted variance of the particles.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Modelling of Raman Spectroscopy</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-06-28</td>
</tr>
<tr>
<td>Description:</td>
<td>Sequential Monte Carlo (SMC) algorithms for fitting a generalised additive
    mixed model (GAMM) to surface-enhanced resonance Raman spectroscopy (SERRS),
    using the method of Moores et al. (2016) &lt;<a href="https://doi.org/10.48550/arXiv.1604.07299">doi:10.48550/arXiv.1604.07299</a>&gt;. Multivariate
    observations of SERRS are highly collinear and lend themselves to a reduced-rank
    representation. The GAMM separates the SERRS signal into three components: a
    sequence of Lorentzian, Gaussian, or pseudo-Voigt peaks; a smoothly-varying baseline;
    and additive white noise. The parameters of each component of the model are estimated
    iteratively using SMC. The posterior distributions of the parameters given the observed
    spectra are represented as a population of weighted particles.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE [expanded from: GPL (&ge; 2) | file LICENSE]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mooresm/serrsBayes">https://github.com/mooresm/serrsBayes</a>,
<a href="https://mooresm.github.io/serrsBayes/">https://mooresm.github.io/serrsBayes/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mooresm/serrsBayes/issues">https://github.com/mooresm/serrsBayes/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), Matrix, truncnorm, splines</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.3), methods</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, Hmisc</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-06-28 10:24:02 UTC; matt</td>
</tr>
<tr>
<td>Author:</td>
<td>Matt Moores <a href="https://orcid.org/0000-0003-4531-3572"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Jake Carson <a href="https://orcid.org/0000-0002-7896-0971"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Benjamin Moskowitz [ctb],
  Kirsten Gracie [dtc],
  Karen Faulds <a href="https://orcid.org/0000-0002-5567-7399"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [dtc],
  Mark Girolami [aut],
  Engineering and Physical Sciences Research Council [fnd] (EPSRC
    programme grant ref: EP/L014165/1),
  University of Warwick [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matt Moores &lt;mmoores@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-06-28 12:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='computeLogLikelihood'>Compute the log-likelihood.</h2><span id='topic+computeLogLikelihood'></span>

<h3>Description</h3>

<p>This is an internal function that is only exposed on the public API for unit testing purposes.
It computes the log-likelihood of the spline and the noise, once the spectral signature has
been subtracted from the observed data. Thus, it can be used with either Lorentzian, Gaussian,
or pseudo-Voigt broadening functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeLogLikelihood(
  obsi,
  lambda,
  prErrNu,
  prErrSS,
  basisMx,
  eigVal,
  precMx,
  xTx,
  aMx,
  ruMx
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeLogLikelihood_+3A_obsi">obsi</code></td>
<td>
<p>Vector of residuals after the spectral signature has been subtracted.</p>
</td></tr>
<tr><td><code id="computeLogLikelihood_+3A_lambda">lambda</code></td>
<td>
<p>smoothing parameter of the penalised B-spline.</p>
</td></tr>
<tr><td><code id="computeLogLikelihood_+3A_prerrnu">prErrNu</code></td>
<td>
<p>hyperparameter of the additive noise</p>
</td></tr>
<tr><td><code id="computeLogLikelihood_+3A_prerrss">prErrSS</code></td>
<td>
<p>hyperparameter of the additive noise</p>
</td></tr>
<tr><td><code id="computeLogLikelihood_+3A_basismx">basisMx</code></td>
<td>
<p>Matrix of B-spline basis functions</p>
</td></tr>
<tr><td><code id="computeLogLikelihood_+3A_eigval">eigVal</code></td>
<td>
<p>eigenvalues of the Demmler-Reinsch factorisation</p>
</td></tr>
<tr><td><code id="computeLogLikelihood_+3A_precmx">precMx</code></td>
<td>
<p>precision matrix for the spline</p>
</td></tr>
<tr><td><code id="computeLogLikelihood_+3A_xtx">xTx</code></td>
<td>
<p>sparse matrix cross-product</p>
</td></tr>
<tr><td><code id="computeLogLikelihood_+3A_amx">aMx</code></td>
<td>
<p>orthoganal matrix A from the Demmler-Reinsch factorisation</p>
</td></tr>
<tr><td><code id="computeLogLikelihood_+3A_rumx">ruMx</code></td>
<td>
<p>product of Ru from the Demmler-Reinsch factorisation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The logarithm of the likelihood.
</p>

<hr>
<h2 id='copyLogProposals'>Initialise the vector of Metropolis-Hastings proposals.</h2><span id='topic+copyLogProposals'></span>

<h3>Description</h3>

<p>This is an internal function that is only exposed on the public API for unit testing purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copyLogProposals(nPK, T_Prop_Theta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="copyLogProposals_+3A_npk">nPK</code></td>
<td>
<p>number of Raman peaks in the spectral signature</p>
</td></tr>
<tr><td><code id="copyLogProposals_+3A_t_prop_theta">T_Prop_Theta</code></td>
<td>
<p>Vector of logarithms of the MH proposals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of proposals
</p>

<hr>
<h2 id='effectiveSampleSize'>Compute the effective sample size (ESS) of the particles.</h2><span id='topic+effectiveSampleSize'></span>

<h3>Description</h3>

<p>The ESS is a &quot;rule of thumb&quot; for assessing the degeneracy of
the importance distribution:
</p>
<p style="text-align: center;"><code class="reqn">ESS = \frac{(\sum_{q=1}^Q w_q)^2}{\sum_{q=1}^Q w_q^2}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>effectiveSampleSize(log_weights)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="effectiveSampleSize_+3A_log_weights">log_weights</code></td>
<td>
<p>logarithms of the importance weights of each particle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the effective sample size, a scalar between 0 and Q
</p>


<h3>References</h3>

<p>Liu, JS (2001) &quot;Monte Carlo Strategies in Scientific Computing.&quot; Springer, NY, pp. 34&ndash;36.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(100)
effectiveSampleSize(log(x))
</code></pre>

<hr>
<h2 id='fitSpectraMCMC'>Fit the model using Markov chain Monte Carlo.</h2><span id='topic+fitSpectraMCMC'></span>

<h3>Description</h3>

<p>Fit the model using Markov chain Monte Carlo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitSpectraMCMC(wl, spc, peakWL, lPriors, sd_mh, niter = 10000, nchains = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitSpectraMCMC_+3A_wl">wl</code></td>
<td>
<p>Vector of <code>nwl</code> wavenumbers at which the spetra are observed.</p>
</td></tr>
<tr><td><code id="fitSpectraMCMC_+3A_spc">spc</code></td>
<td>
<p><code>n_y * nwl</code> Matrix of observed Raman spectra.</p>
</td></tr>
<tr><td><code id="fitSpectraMCMC_+3A_peakwl">peakWL</code></td>
<td>
<p>Vector of locations for each peak (cm^-1)</p>
</td></tr>
<tr><td><code id="fitSpectraMCMC_+3A_lpriors">lPriors</code></td>
<td>
<p>List of hyperparameters for the prior distributions.</p>
</td></tr>
<tr><td><code id="fitSpectraMCMC_+3A_sd_mh">sd_mh</code></td>
<td>
<p>Vector of <code>2 * npeaks</code> bandwidths for the random walk proposals.</p>
</td></tr>
<tr><td><code id="fitSpectraMCMC_+3A_niter">niter</code></td>
<td>
<p>number of MCMC iterations per chain.</p>
</td></tr>
<tr><td><code id="fitSpectraMCMC_+3A_nchains">nchains</code></td>
<td>
<p>number of concurrent MCMC chains.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a List containing MCMC samples for the model parameters:
</p>

<dl>
<dt><code>amplitude</code></dt><dd><p><code>niter * nchains * npeaks</code> Array of amplitudes.</p>
</dd>
<dt><code>scale</code></dt><dd><p><code>niter * nchains * npeaks</code> Array of scale parameters.</p>
</dd>
<dt><code>sigma</code></dt><dd><p><code>niter * nchains</code> Matrix of standard deviations.</p>
</dd>
<dt><code>n_acc</code></dt><dd><p>The number of RWMH proposals that were accepted.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+marginalMetropolisUpdate">marginalMetropolisUpdate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wavenumbers &lt;- seq(200,600,by=10)
spectra &lt;- matrix(nrow=1, ncol=length(wavenumbers))
peakLocations &lt;- c(300,500)
peakAmplitude &lt;- c(10000,4000)
peakScale &lt;- c(10, 15)
signature &lt;- weightedLorentzian(peakLocations, peakScale, peakAmplitude, wavenumbers)
baseline &lt;- 1000*cos(wavenumbers/200) + 2*wavenumbers
spectra[1,] &lt;- signature + baseline + rnorm(length(wavenumbers),0,200)
lPriors &lt;- list(scale.mu=log(11.6) - (0.4^2)/2, scale.sd=0.4, bl.smooth=10^11, bl.knots=20,
                amp.mu=5000, amp.sd=5000, noise.sd=200, noise.nu=4)
rw_bw &lt;- c(100, 100, 2, 2)
result &lt;- fitSpectraMCMC(wavenumbers, spectra, peakLocations, lPriors, rw_bw, 500)
result$n_acc
</code></pre>

<hr>
<h2 id='fitSpectraSMC'>Fit the model using Sequential Monte Carlo (SMC).</h2><span id='topic+fitSpectraSMC'></span>

<h3>Description</h3>

<p>Fit the model using Sequential Monte Carlo (SMC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitSpectraSMC(
  wl,
  spc,
  peakWL,
  lPriors,
  conc = rep(1, nrow(spc)),
  npart = 10000,
  rate = 0.9,
  minESS = npart/2,
  destDir = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitSpectraSMC_+3A_wl">wl</code></td>
<td>
<p>Vector of <code>nwl</code> wavenumbers at which the spetra are observed.</p>
</td></tr>
<tr><td><code id="fitSpectraSMC_+3A_spc">spc</code></td>
<td>
<p><code>n_y * nwl</code> Matrix of observed Raman spectra.</p>
</td></tr>
<tr><td><code id="fitSpectraSMC_+3A_peakwl">peakWL</code></td>
<td>
<p>Vector of locations for each peak (cm^-1)</p>
</td></tr>
<tr><td><code id="fitSpectraSMC_+3A_lpriors">lPriors</code></td>
<td>
<p>List of hyperparameters for the prior distributions.</p>
</td></tr>
<tr><td><code id="fitSpectraSMC_+3A_conc">conc</code></td>
<td>
<p>Vector of <code>n_y</code> nanomolar (nM) dye concentrations for each observation.</p>
</td></tr>
<tr><td><code id="fitSpectraSMC_+3A_npart">npart</code></td>
<td>
<p>number of SMC particles to use for the importance sampling distribution.</p>
</td></tr>
<tr><td><code id="fitSpectraSMC_+3A_rate">rate</code></td>
<td>
<p>the target rate of reduction in the effective sample size (ESS).</p>
</td></tr>
<tr><td><code id="fitSpectraSMC_+3A_miness">minESS</code></td>
<td>
<p>minimum effective sample size, below which the particles are resampled.</p>
</td></tr>
<tr><td><code id="fitSpectraSMC_+3A_destdir">destDir</code></td>
<td>
<p>destination directory to save intermediate results (for long-running computations)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a List containing weighted parameter values, known as particles:
</p>

<dl>
<dt><code>weights</code></dt><dd><p>Vector of importance weights for each particle.</p>
</dd>
<dt><code>beta</code></dt><dd><p><code>npart * npeaks</code> Matrix of regression coefficients for the amplitudes.</p>
</dd>
<dt><code>scale</code></dt><dd><p><code>npart * npeaks</code> Matrix of scale parameters.</p>
</dd>
<dt><code>sigma</code></dt><dd><p>Vector of <code>npart</code> standard deviations.</p>
</dd>
<dt><code>alpha</code></dt><dd><p><code>bl.knots * n_y * npart</code> Array of spline coefficients for the baseline.</p>
</dd>
<dt><code>basis</code></dt><dd><p>A dense <code>nwl * bl.knots</code> Matrix containing the values of the basis functions.</p>
</dd>
<dt><code>expFn</code></dt><dd><p><code>npart * nwl</code> Matrix containing the spectral signature.</p>
</dd>
<dt><code>ess</code></dt><dd><p>Vector containing the effective sample size (ESS) at each SMC iteration.</p>
</dd>
<dt><code>logEvidence</code></dt><dd><p>Vector containing the logarithm of the model evidence (marginal likelihood).</p>
</dd>
<dt><code>accept</code></dt><dd><p>Vector containing the Metropolis-Hastings acceptance rate at each SMC iteration.</p>
</dd>
<dt><code>sd.mh</code></dt><dd><p><code>niter * 2npeaks</code> Matrix of random walk MH bandwidths at each SMC iteration..</p>
</dd>
</dl>



<h3>References</h3>

<p>Chopin (2002) &quot;A Sequential Particle Filter Method for Static Models,&quot; Biometrika 89(3): 539&ndash;551,
doi: <a href="https://doi.org/10.1093/biomet/89.3.539">10.1093/biomet/89.3.539</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wavenumbers &lt;- seq(200,600,by=10)
spectra &lt;- matrix(nrow=1, ncol=length(wavenumbers))
peakLocations &lt;- c(300,500)
peakAmplitude &lt;- c(10000,4000)
peakScale &lt;- c(10, 15)
signature &lt;- weightedLorentzian(peakLocations, peakScale, peakAmplitude, wavenumbers)
baseline &lt;- 1000*cos(wavenumbers/200) + 2*wavenumbers
spectra[1,] &lt;- signature + baseline + rnorm(length(wavenumbers),0,200)
lPriors &lt;- list(scale.mu=log(11.6) - (0.4^2)/2, scale.sd=0.4, bl.smooth=10^11, bl.knots=20,
                beta.mu=5000, beta.sd=5000, noise.sd=200, noise.nu=4)
## Not run: 
result &lt;- fitSpectraSMC(wavenumbers, spectra, peakLocations, lPriors, npart=500)

## End(Not run)
</code></pre>

<hr>
<h2 id='fitVoigtIBIS'>Fit the model with Voigt peaks using iterated batch importance sampling (IBIS).</h2><span id='topic+fitVoigtIBIS'></span>

<h3>Description</h3>

<p>Fit the model with Voigt peaks using iterated batch importance sampling (IBIS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitVoigtIBIS(
  wl,
  spc,
  n,
  lResult,
  conc = rep(1, nrow(spc)),
  batch = rep(1, nrow(spc)),
  npart = 10000,
  rate = 0.9,
  mcAR = 0.234,
  mcSteps = 20,
  minESS = npart/2,
  minPart = npart,
  destDir = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitVoigtIBIS_+3A_wl">wl</code></td>
<td>
<p>Vector of <code>nwl</code> wavenumbers at which the spetra are observed.</p>
</td></tr>
<tr><td><code id="fitVoigtIBIS_+3A_spc">spc</code></td>
<td>
<p><code>n_y * nwl</code> Matrix of observed Raman spectra.</p>
</td></tr>
<tr><td><code id="fitVoigtIBIS_+3A_n">n</code></td>
<td>
<p>index of the new observation</p>
</td></tr>
<tr><td><code id="fitVoigtIBIS_+3A_lresult">lResult</code></td>
<td>
<p>List of results from the previous call to &ldquo;fitVoigtPeaksSMC&ldquo; or &ldquo;fitVoigtIBIS&ldquo;</p>
</td></tr>
<tr><td><code id="fitVoigtIBIS_+3A_conc">conc</code></td>
<td>
<p>Vector of <code>n_y</code> nanomolar (nM) dye concentrations for each observation.</p>
</td></tr>
<tr><td><code id="fitVoigtIBIS_+3A_batch">batch</code></td>
<td>
<p>identifies to which batch each observation belongs</p>
</td></tr>
<tr><td><code id="fitVoigtIBIS_+3A_npart">npart</code></td>
<td>
<p>number of SMC particles to use for the importance sampling distribution.</p>
</td></tr>
<tr><td><code id="fitVoigtIBIS_+3A_rate">rate</code></td>
<td>
<p>the target rate of reduction in the effective sample size (ESS).</p>
</td></tr>
<tr><td><code id="fitVoigtIBIS_+3A_mcar">mcAR</code></td>
<td>
<p>target acceptance rate for the MCMC kernel</p>
</td></tr>
<tr><td><code id="fitVoigtIBIS_+3A_mcsteps">mcSteps</code></td>
<td>
<p>number of iterations of the MCMC kernel</p>
</td></tr>
<tr><td><code id="fitVoigtIBIS_+3A_miness">minESS</code></td>
<td>
<p>minimum effective sample size, below which the particles are resampled.</p>
</td></tr>
<tr><td><code id="fitVoigtIBIS_+3A_minpart">minPart</code></td>
<td>
<p>target number of unique particles for the MCMC iterations</p>
</td></tr>
<tr><td><code id="fitVoigtIBIS_+3A_destdir">destDir</code></td>
<td>
<p>destination directory to save intermediate results (for long-running computations)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chopin (2002) &quot;A Sequential Particle Filter Method for Static Models,&quot; Biometrika 89(3): 539&ndash;551,
doi: <a href="https://doi.org/10.1093/biomet/89.3.539">10.1093/biomet/89.3.539</a>
</p>

<hr>
<h2 id='fitVoigtPeaksSMC'>Fit the model with Voigt peaks using Sequential Monte Carlo (SMC).</h2><span id='topic+fitVoigtPeaksSMC'></span>

<h3>Description</h3>

<p>Fit the model with Voigt peaks using Sequential Monte Carlo (SMC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitVoigtPeaksSMC(
  wl,
  spc,
  lPriors,
  conc = rep(1, nrow(spc)),
  npart = 10000,
  rate = 0.9,
  mcAR = 0.234,
  mcSteps = 20,
  minESS = npart/2,
  destDir = NA,
  minPart = npart
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitVoigtPeaksSMC_+3A_wl">wl</code></td>
<td>
<p>Vector of <code>nwl</code> wavenumbers at which the spetra are observed.</p>
</td></tr>
<tr><td><code id="fitVoigtPeaksSMC_+3A_spc">spc</code></td>
<td>
<p><code>n_y * nwl</code> Matrix of observed Raman spectra.</p>
</td></tr>
<tr><td><code id="fitVoigtPeaksSMC_+3A_lpriors">lPriors</code></td>
<td>
<p>List of hyperparameters for the prior distributions.</p>
</td></tr>
<tr><td><code id="fitVoigtPeaksSMC_+3A_conc">conc</code></td>
<td>
<p>Vector of <code>n_y</code> nanomolar (nM) dye concentrations for each observation.</p>
</td></tr>
<tr><td><code id="fitVoigtPeaksSMC_+3A_npart">npart</code></td>
<td>
<p>number of SMC particles to use for the importance sampling distribution.</p>
</td></tr>
<tr><td><code id="fitVoigtPeaksSMC_+3A_rate">rate</code></td>
<td>
<p>the target rate of reduction in the effective sample size (ESS).</p>
</td></tr>
<tr><td><code id="fitVoigtPeaksSMC_+3A_mcar">mcAR</code></td>
<td>
<p>target acceptance rate for the MCMC kernel</p>
</td></tr>
<tr><td><code id="fitVoigtPeaksSMC_+3A_mcsteps">mcSteps</code></td>
<td>
<p>number of iterations of the MCMC kernel</p>
</td></tr>
<tr><td><code id="fitVoigtPeaksSMC_+3A_miness">minESS</code></td>
<td>
<p>minimum effective sample size, below which the particles are resampled.</p>
</td></tr>
<tr><td><code id="fitVoigtPeaksSMC_+3A_destdir">destDir</code></td>
<td>
<p>destination directory to save intermediate results (for long-running computations)</p>
</td></tr>
<tr><td><code id="fitVoigtPeaksSMC_+3A_minpart">minPart</code></td>
<td>
<p>target number of unique particles for the MCMC iterations</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>wavenumbers &lt;- seq(200,600,by=10)
spectra &lt;- matrix(nrow=1, ncol=length(wavenumbers))
peakLocations &lt;- c(300,500)
peakAmplitude &lt;- c(10000,4000)
peakScale &lt;- c(10, 15)
signature &lt;- weightedLorentzian(peakLocations, peakScale, peakAmplitude, wavenumbers)
baseline &lt;- 1000*cos(wavenumbers/200) + 2*wavenumbers
spectra[1,] &lt;- signature + baseline + rnorm(length(wavenumbers),0,200)
lPriors &lt;- list(scaG.mu=log(11.6) - (0.4^2)/2, scaG.sd=0.4, scaL.mu=log(11.6) - (0.4^2)/2,
   scaL.sd=0.4, bl.smooth=5, bl.knots=20, loc.mu=peakLocations, loc.sd=c(5,5),
   beta.mu=c(5000,5000), beta.sd=c(5000,5000), noise.sd=200, noise.nu=4)
## Not run: 
result &lt;- fitVoigtPeaksSMC(wavenumbers, spectra, lPriors, npart=50, mcSteps=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='getBsplineBasis'>Compute cubic B-spline basis functions for the given wavenumbers.</h2><span id='topic+getBsplineBasis'></span>

<h3>Description</h3>

<p>This function computes penalised cubic B-splines using the method proposed by
Eilers &amp; Marx (1996). The spline coefficients can be computed efficiently
using sparse matrix algebra, as described in Sect. 2.3.3 of Green &amp; Silverman
(1994) and Appendix B of Ruppert, Wand &amp; Carroll (2003).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBsplineBasis(V, n.b, pen, prec = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getBsplineBasis_+3A_v">V</code></td>
<td>
<p>a <code>vector</code> of wavenumbers, <code class="reqn">\Delta \tilde{\nu}</code>.</p>
</td></tr>
<tr><td><code id="getBsplineBasis_+3A_n.b">n.b</code></td>
<td>
<p>the number of basis functions to use.</p>
</td></tr>
<tr><td><code id="getBsplineBasis_+3A_pen">pen</code></td>
<td>
<p>the smoothing penalty hyperparameter.</p>
</td></tr>
<tr><td><code id="getBsplineBasis_+3A_prec">prec</code></td>
<td>
<p>a constant scale factor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> containing:
</p>

<dl>
<dt><code>basis</code></dt><dd><p>A dense nwl by n.b matrix containing the values of the basis functions.</p>
</dd> 
<dt><code>precision</code></dt><dd><p>A sparse n.b by n.b <code>dsCMatrix</code>, the inverse of the prior covariance.</p>
</dd>
<dt><code>distance</code></dt><dd><p>The distance between each knot <code class="reqn">(cm^{-1})</code>.</p>
</dd>
<dt><code>knots</code></dt><dd><p>The knot locations.</p>
</dd>
</dl>



<h3>References</h3>

<p>Eilers, PHC &amp; Marx, BD (1996) &quot;Flexible smoothing with B-splines and
penalties,&quot; Statist. Sci.  11(2): 89&ndash;121, doi: <a href="https://doi.org/10.1214/ss/1038425655">10.1214/ss/1038425655</a>
</p>
<p>Green, PJ &amp; Silverman, BW (1994) &quot;Nonparametric Regression and
Generalized Linear Models: a roughness penalty approach&quot; Chapman &amp; Hall, Boca
Raton, FL, pp. 11&ndash;21.
</p>
<p>Ruppert, D; Wand, MP &amp; Carroll, RJ (2003) &quot;Semiparametric Regression&quot; CUP,
Cambridge, UK, pp. 336&ndash;340.
</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+sparseMatrix-class">sparseMatrix</a></code>
</p>

<hr>
<h2 id='getVoigtParam'>Compute the pseudo-Voigt mixing ratio for each peak.</h2><span id='topic+getVoigtParam'></span>

<h3>Description</h3>

<p>Calculates the mixing parameter <code class="reqn">\eta_j</code> from the scales of the Gaussian/Lorentzian
components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getVoigtParam(scale_G, scale_L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getVoigtParam_+3A_scale_g">scale_G</code></td>
<td>
<p>Vector of standard deviations <code class="reqn">\sigma_j</code> of the Gaussian components.</p>
</td></tr>
<tr><td><code id="getVoigtParam_+3A_scale_l">scale_L</code></td>
<td>
<p>Vector of scale parameters <code class="reqn">\phi_j</code> of the Lorentzian components.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, calculate a polynomial average of the scale parameters according to
the approximation of Thompson et al. (1987):
</p>
<p style="text-align: center;"><code class="reqn">f_{G,L} = (\sigma_j^5 + 2.69\sigma_j^4\phi_j + 2.42\sigma_j^3\phi_j^2 + 4.47\sigma_j^2\phi_j^3 + 0.07\sigma_j\phi_j^4 + \phi_j^5)^{1/5} </code>
</p>

<p>Then the Voigt mixing parameter <code class="reqn">\eta_j</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn">\eta_j = 1.36\frac{\phi_j}{f_{G,L}} - 0.47(\frac{\phi_j}{f_{G,L}})^2 + 0.11(\frac{\phi_j}{f_{G,L}})^3</code>
</p>



<h3>Value</h3>

<p>The Voigt mixing weights for each peak, between 0 (Gaussian) and 1 (Lorentzian).
</p>


<h3>References</h3>

<p>Thompson, Cox &amp; Hastings (1987) &quot;Rietveld refinement of Debye&ndash;Scherrer synchrotron X-ray data from <code class="reqn">Al_2 O_3</code>,&quot;
J. Appl. Crystallogr. 20(2): 79&ndash;83, doi: <a href="https://doi.org/10.1107/S0021889887087090">10.1107/S0021889887087090</a>
</p>

<hr>
<h2 id='lsTamra'>Surface-enhanced Raman spectram of tetramethylrhodamine+DNA (T20)</h2><span id='topic+lsTamra'></span>

<h3>Description</h3>

<p>Surface-enhanced Raman spectram of tetramethylrhodamine+DNA (T20)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsTamra
</code></pre>


<h3>Format</h3>

<p>A list containing 2 variables:
</p>

<dl>
<dt>wavenumbers</dt><dd><p>a numeric Vector of 2401 wavenumbers (cm^-1)</p>
</dd>
<dt>wavenumbers</dt><dd><p>a <code>1 * 2401</code> Matrix of intensity values (a.u.)</p>
</dd>
</dl>


<hr>
<h2 id='marginalMetropolisUpdate'>Update all of the parameters using a single Metropolis-Hastings step.</h2><span id='topic+marginalMetropolisUpdate'></span>

<h3>Description</h3>

<p>Updates all of the parameters using a single Metropolis-Hastings step, such that the
baseline cancels out in the MH ratio, using the marginalisation identity of Chib (1995).
If <code>npart &gt; 1</code>, then multiple MCMC chains will be executed independently in parallel using OpenMP.
This means that all functions used for the proposal distributions and to evaluate the MH ratio
need to be thread-safe. Specifically, no calls to <code>R::rnorm</code>, <code>R::dnorm</code>, nor their
Rcpp equivalents, can be made from within the parallel portion of the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginalMetropolisUpdate(
  spectra,
  n,
  conc,
  wavelengths,
  peakWL,
  betaMx,
  scaleMx,
  sigma,
  expMx,
  baselines,
  sd_mh,
  priors
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="marginalMetropolisUpdate_+3A_spectra">spectra</code></td>
<td>
<p><code>n_y * nwl</code> Matrix of observed Raman spectra.</p>
</td></tr>
<tr><td><code id="marginalMetropolisUpdate_+3A_n">n</code></td>
<td>
<p>number of observations to use in calculating the likelihood</p>
</td></tr>
<tr><td><code id="marginalMetropolisUpdate_+3A_conc">conc</code></td>
<td>
<p>Vector of <code>n</code> nanomolar (nM) dye concentrations</p>
</td></tr>
<tr><td><code id="marginalMetropolisUpdate_+3A_wavelengths">wavelengths</code></td>
<td>
<p>Vector of <code>nwl</code> wavenumbers at which the spetra are observed.</p>
</td></tr>
<tr><td><code id="marginalMetropolisUpdate_+3A_peakwl">peakWL</code></td>
<td>
<p>Vector of locations for each peak (cm^-1)</p>
</td></tr>
<tr><td><code id="marginalMetropolisUpdate_+3A_betamx">betaMx</code></td>
<td>
<p><code>npeaks * npart</code> Matrix of regression coefficients to update.</p>
</td></tr>
<tr><td><code id="marginalMetropolisUpdate_+3A_scalemx">scaleMx</code></td>
<td>
<p><code>npeaks * npart</code> Matrix of scale parameters to update.</p>
</td></tr>
<tr><td><code id="marginalMetropolisUpdate_+3A_sigma">sigma</code></td>
<td>
<p>Vector of <code>npart</code> standard deviations to update.</p>
</td></tr>
<tr><td><code id="marginalMetropolisUpdate_+3A_expmx">expMx</code></td>
<td>
<p><code>nwl * npart</code> Matrix of expectations of the Lorentzian or Gaussian function.</p>
</td></tr>
<tr><td><code id="marginalMetropolisUpdate_+3A_baselines">baselines</code></td>
<td>
<p><code>nKnots * n_y * npart</code> Array of smoothing splines.</p>
</td></tr>
<tr><td><code id="marginalMetropolisUpdate_+3A_sd_mh">sd_mh</code></td>
<td>
<p>Vector of <code>2 * npeaks</code> bandwidths for the random walk proposals.</p>
</td></tr>
<tr><td><code id="marginalMetropolisUpdate_+3A_priors">priors</code></td>
<td>
<p>List of hyperparameters for the prior distributions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of RWMH proposals that were accepted.
</p>


<h3>References</h3>

<p>Chib (1995) &quot;Marginal Likelihood from the Gibbs Output,&quot; JASA 90(432): 1313&ndash;1321,
doi: <a href="https://doi.org/10.1080/01621459.1995.10476635">10.1080/01621459.1995.10476635</a>
</p>
<p>Rosenthal (2000) &quot;Parallel computing and Monte Carlo algorithms&quot; Far East J. Theor. Stat. 4(2): 207&ndash;236,
URL: <a href="https://www.pphmj.com/abstract/1961.htm">https://www.pphmj.com/abstract/1961.htm</a>
</p>

<hr>
<h2 id='methanol'>Raman spectrum of methanol (CH3OH)</h2><span id='topic+methanol'></span>

<h3>Description</h3>

<p>Raman spectrum of methanol (CH3OH)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>methanol
</code></pre>


<h3>Format</h3>

<p>A list containing 2 variables:
</p>

<dl>
<dt>wavenumbers</dt><dd><p>a numeric Vector of 331 wavenumbers (cm^-1)</p>
</dd>
<dt>wavenumbers</dt><dd><p>a <code>1 * 331</code> Matrix of intensity values (a.u.)</p>
</dd>
</dl>


<hr>
<h2 id='mhUpdateVoigt'>Update the parameters of the Voigt peaks using marginal Metropolis-Hastings.</h2><span id='topic+mhUpdateVoigt'></span>

<h3>Description</h3>

<p>Updates all of the parameters (location, amplitude, std. dev., and scale) using a single Metropolis-
Hastings step, such that the baseline cancels out in the MH ratio, using the marginalisation identity
of Chib (1995).
Note: if <code>npart &gt; 1</code>, then multiple MCMC chains will be executed independently in parallel using
OpenMP. This means that all functions used for the proposal distributions and to evaluate the MH ratio
need to be thread-safe. Specifically, no calls to <code>R::rnorm</code>, <code>R::dnorm</code>, nor their
Rcpp equivalents, can be made from within the parallel portion of the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mhUpdateVoigt(
  spectra,
  n,
  kappa,
  conc,
  wavenum,
  thetaMx,
  logThetaMx,
  mhChol,
  priors
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mhUpdateVoigt_+3A_spectra">spectra</code></td>
<td>
<p><code>n_y * nwl</code> Matrix of observed Raman spectra.</p>
</td></tr>
<tr><td><code id="mhUpdateVoigt_+3A_n">n</code></td>
<td>
<p>number of observations to use in calculating the likelihood.</p>
</td></tr>
<tr><td><code id="mhUpdateVoigt_+3A_kappa">kappa</code></td>
<td>
<p>likelihood tempering parameter.</p>
</td></tr>
<tr><td><code id="mhUpdateVoigt_+3A_conc">conc</code></td>
<td>
<p>Vector of <code>n_y</code> nanomolar (nM) dye concentrations</p>
</td></tr>
<tr><td><code id="mhUpdateVoigt_+3A_wavenum">wavenum</code></td>
<td>
<p>Vector of <code>nwl</code> wavenumbers at which the spetra are observed.</p>
</td></tr>
<tr><td><code id="mhUpdateVoigt_+3A_thetamx">thetaMx</code></td>
<td>
<p><code>(4+npeaks*4) x npart</code> Matrix of parameter values for each peak.</p>
</td></tr>
<tr><td><code id="mhUpdateVoigt_+3A_logthetamx">logThetaMx</code></td>
<td>
<p><code>(4+npeaks*4) x npart</code> Matrix of logarithms of the parameters.</p>
</td></tr>
<tr><td><code id="mhUpdateVoigt_+3A_mhchol">mhChol</code></td>
<td>
<p>lower-triangular Cholesky factorisation of the covariance matrix for the random walk proposals.</p>
</td></tr>
<tr><td><code id="mhUpdateVoigt_+3A_priors">priors</code></td>
<td>
<p>List of hyperparameters for the prior distributions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of RWMH proposals that were accepted.
</p>


<h3>References</h3>

<p>Chib (1995) &quot;Marginal Likelihood from the Gibbs Output,&quot; JASA 90(432): 1313&ndash;1321,
doi: <a href="https://doi.org/10.1080/01621459.1995.10476635">10.1080/01621459.1995.10476635</a>
</p>
<p>Rosenthal (2000) &quot;Parallel computing and Monte Carlo algorithms&quot; Far East J. Theor. Stat. 4(2): 207&ndash;236,
URL: <a href="https://www.pphmj.com/abstract/1961.htm">https://www.pphmj.com/abstract/1961.htm</a>
</p>

<hr>
<h2 id='mixedVoigt'>Compute the spectral signature using Voigt peaks.</h2><span id='topic+mixedVoigt'></span>

<h3>Description</h3>

<p>Calculates the value of the pseudo-Voigt broadening function at the given wavenumbers,
given the parameters of the peaks. This function is thread-safe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixedVoigt(location, scale_G, scale_L, amplitude, wavenum)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixedVoigt_+3A_location">location</code></td>
<td>
<p>Vector of location parameters of the peaks (<code class="reqn">cm^{-1}</code>)</p>
</td></tr>
<tr><td><code id="mixedVoigt_+3A_scale_g">scale_G</code></td>
<td>
<p>Vector of standard deviations <code class="reqn">\sigma_j</code> of the Gaussian components.</p>
</td></tr>
<tr><td><code id="mixedVoigt_+3A_scale_l">scale_L</code></td>
<td>
<p>Vector of scale parameters <code class="reqn">\phi_j</code> of the Lorentzian components.</p>
</td></tr>
<tr><td><code id="mixedVoigt_+3A_amplitude">amplitude</code></td>
<td>
<p>Vector of amplitudes of the peaks (a.u.)</p>
</td></tr>
<tr><td><code id="mixedVoigt_+3A_wavenum">wavenum</code></td>
<td>
<p>Vector of wavenumbers at which to compute the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the pseudo-Voigt function at the given wavenumbers.
</p>


<h3>References</h3>

<p>Thompson, Cox &amp; Hastings (1987) &quot;Rietveld refinement of Debye&ndash;Scherrer synchrotron X-ray data from <code class="reqn">Al_2 O_3</code>,&quot;
J. Appl. Crystallogr. 20(2): 79&ndash;83, DOI: doi: <a href="https://doi.org/10.1107/S0021889887087090">10.1107/S0021889887087090</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Cal_V &lt;- seq(300,400,by=5)
  loc &lt;- c(320,350,375)
  scG &lt;- c(10,5,1)
  scL &lt;- c(3,20,7)
  amp &lt;- c(100,500,200)
  mixedVoigt(loc,scG,scL,amp,Cal_V)
</code></pre>

<hr>
<h2 id='resampleParticles'>Resample in place to avoid expensive copying of data structures, using a permutation
of the ancestry vector.</h2><span id='topic+resampleParticles'></span>

<h3>Description</h3>

<p>Resample in place to avoid expensive copying of data structures, using a permutation
of the ancestry vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resampleParticles(log_weights, ampMx, scaleMx, peaks, baselines, n_y, nwl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resampleParticles_+3A_log_weights">log_weights</code></td>
<td>
<p>logarithms of the importance weights of each particle</p>
</td></tr>
<tr><td><code id="resampleParticles_+3A_ampmx">ampMx</code></td>
<td>
<p><code>npeaks x npart</code> Matrix of amplitudes for each particle.</p>
</td></tr>
<tr><td><code id="resampleParticles_+3A_scalemx">scaleMx</code></td>
<td>
<p><code>npeaks x npart</code> Matrix of scale parameters for each particle.</p>
</td></tr>
<tr><td><code id="resampleParticles_+3A_peaks">peaks</code></td>
<td>
<p><code>nwl x npart</code> Matrix containing the expectation of the Lorentzian mixture.</p>
</td></tr>
<tr><td><code id="resampleParticles_+3A_baselines">baselines</code></td>
<td>
<p><code>nwl x n_y x npart</code> Array of smoothing splines.</p>
</td></tr>
<tr><td><code id="resampleParticles_+3A_n_y">n_y</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="resampleParticles_+3A_nwl">nwl</code></td>
<td>
<p>number of wavenumbers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of indices to the parents of the resampled particles.
</p>


<h3>References</h3>

<p>Murray, L.M., Lee, A. &amp; Jacob, P.E. (2015) &quot;Parallel resampling in the particle filter&quot; <a href="https://arxiv.org/abs/1301.4019">arXiv:1301.4019v3</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+residualResampling">residualResampling</a></code>
</p>

<hr>
<h2 id='residualResampling'>Compute an ancestry vector for residual resampling of the SMC particles.</h2><span id='topic+residualResampling'></span>

<h3>Description</h3>

<p>Compute an ancestry vector for residual resampling of the SMC particles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residualResampling(log_wt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residualResampling_+3A_log_wt">log_wt</code></td>
<td>
<p>logarithms of the importance weights of each particle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of indices to the particles that will be propagated forward to the next generation (i.e. the parents)
</p>


<h3>References</h3>

<p>Liu &amp; Chen (1998) &quot;Sequential Monte Carlo methods for dynamic systems,&quot; JASA 93(443): 1032-1044,
doi: <a href="https://doi.org/10.1080/01621459.1998.10473765">10.1080/01621459.1998.10473765</a>
</p>
<p>Douc, Cappe &amp; Moulines (2005) &quot;Comparison of resampling schemes for particle filtering&quot;
In Proc. 4th IEEE Int. Symp. ISPA, pp. 64-69, doi: <a href="https://doi.org/10.1109/ISPA.2005.195385">10.1109/ISPA.2005.195385</a>
</p>

<hr>
<h2 id='result'>SMC particles for TAMRA+DNA (T20)</h2><span id='topic+result'></span>

<h3>Description</h3>

<p>Posterior distribution for pseudo-Voigt parameters, obtained by running
'fitVoigtPeaksSMC' on a spectrum from Gracie et al. (Anal. Chem., 2016).
1000 SMC particles with 32 peaks. For details, see the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>result
</code></pre>


<h3>Format</h3>

<p>A list containing 15 variables:
</p>

<dl>
<dt>weights</dt><dd><p>normalised importance weights for each particle</p>
</dd>
<dt>location</dt><dd><p>location parameters of 32 peaks</p>
</dd>
<dt>beta</dt><dd><p>amplitudes of 32 peaks</p>
</dd>
<dt>scale_G</dt><dd><p>scale of the Gaussian (RBF) broadening</p>
</dd>
<dt>scale_L</dt><dd><p>scale of the Lorentzian (Cauchy) broadening</p>
</dd>
<dt>sigma</dt><dd><p>standard deviation of the additive white noise</p>
</dd>
<dt>lambda</dt><dd><p>smoothing parameter of the cubic B-splines</p>
</dd>
<dt>priors</dt><dd><p>List of informative priors</p>
</dd>
<dt>ess</dt><dd><p>history of the effective sample size</p>
</dd>
<dt>kappa</dt><dd><p>history of the likelihood tempering</p>
</dd>
<dt>accept</dt><dd><p>history of Metropolis-Hastings acceptance rates</p>
</dd>
<dt>mhSteps</dt><dd><p>history of Metropolis-Hastings steps</p>
</dd>
<dt>times</dt><dd><p>history of times for each SMC iteration</p>
</dd>
<dt>time</dt><dd><p>computation time taken by the SMC algorithm</p>
</dd>
</dl>


<hr>
<h2 id='result2'>SMC particles for methanol (CH3OH)</h2><span id='topic+result2'></span>

<h3>Description</h3>

<p>Posterior distribution for pseudo-Voigt parameters, obtained by running
'fitVoigtPeaksSMC' on a Raman spectrum of methanol with 4 peaks.
For details, refer to the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>result2
</code></pre>


<h3>Format</h3>

<p>A list containing 15 variables.
</p>

<hr>
<h2 id='reWeightParticles'>Update the importance weights of each particle.</h2><span id='topic+reWeightParticles'></span>

<h3>Description</h3>

<p>Update the importance weights of each particle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reWeightParticles(
  spectra,
  peaks,
  baselines,
  i,
  start,
  sigma,
  old_weights,
  alpha,
  idx
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reWeightParticles_+3A_spectra">spectra</code></td>
<td>
<p><code>n_y * nwl</code> Matrix of observed Raman spectra.</p>
</td></tr>
<tr><td><code id="reWeightParticles_+3A_peaks">peaks</code></td>
<td>
<p><code>nwl * npart</code> Matrix containing the spectral signatures for each observation.</p>
</td></tr>
<tr><td><code id="reWeightParticles_+3A_baselines">baselines</code></td>
<td>
<p><code>nwl * npart</code> Matrix containing the current values of the baselines.</p>
</td></tr>
<tr><td><code id="reWeightParticles_+3A_i">i</code></td>
<td>
<p>index of the current observation to use in calculating the likelihood</p>
</td></tr>
<tr><td><code id="reWeightParticles_+3A_start">start</code></td>
<td>
<p>index of the next wavelength to use in calculating the likelihood, permuted by <code>idx</code></p>
</td></tr>
<tr><td><code id="reWeightParticles_+3A_sigma">sigma</code></td>
<td>
<p>Vector of <code>npart</code> standard deviations for each particle.</p>
</td></tr>
<tr><td><code id="reWeightParticles_+3A_old_weights">old_weights</code></td>
<td>
<p>logarithms of the importance weights of each particle.</p>
</td></tr>
<tr><td><code id="reWeightParticles_+3A_alpha">alpha</code></td>
<td>
<p>the target learning rate for the reduction in effective sample size (ESS).</p>
</td></tr>
<tr><td><code id="reWeightParticles_+3A_idx">idx</code></td>
<td>
<p>permutation of the indices of the wavelengths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a List containing:
</p>

<dl>
<dt><code>ess</code></dt><dd><p>The effective sample size, after reweighting.</p>
</dd>
<dt><code>weights</code></dt><dd><p>Vector of updated importance weights.</p>
</dd>
<dt><code>index</code></dt><dd><p>index of the last wavelength used.</p>
</dd>
<dt><code>evidence</code></dt><dd><p>SMC estimate of the logarithm of the model evidence.</p>
</dd>
</dl>



<h3>References</h3>

<p>Pitt, dos Santos Silva, Giordani &amp; Kohn (2012)
&quot;On some properties of Markov chain Monte Carlo simulation methods based on the particle filter&quot;
J. Econometrics 171(2): 134&ndash;151,
DOI: doi: <a href="https://doi.org/10.1016/j.jeconom.2012.06.004">10.1016/j.jeconom.2012.06.004</a>
</p>
<p>Zhou, Johansen &amp; Aston (2015) &quot;Towards Automatic Model Comparison: An Adaptive Sequential Monte Carlo Approach&quot;
<a href="https://arxiv.org/abs/1303.3123">arXiv:1303.3123</a> [stat.ME]
</p>

<hr>
<h2 id='serrsBayes'>Bayesian modelling and quantification of Raman spectroscopy</h2><span id='topic+serrsBayes'></span>

<h3>Description</h3>

<p>This R package implements sequential Monte Carlo (SMC) algorithms for fitting a
generalised additive mixed model (GAMM) to Raman spectra. These multivariate observations are highly collinear
and lend themselves to a reduced-rank representation.  The GAMM separates the
hyperspectral signal into three components: a sequence of Lorentzian or Gaussian peaks; a
smoothly-varying baseline; and zero-mean, additive white noise. The parameters of each component of
the model are estimated iteratively using SMC. The posterior distributions of the parameters
given the observed spectra are represented as a population of weighted particles.
</p>


<h3>Details</h3>

<p>Raman spectroscopy can be used to identify molecules by the characteristic scattering of light from a laser.
The pattern of peaks in a Raman spectrum corresponds to the vibrational modes of the molecule. The shift in
wavenumber of the photons is proportional to the change in energy state, which is reflected in the locations
of the peaks. Surface-enhanced Raman scattering (SERS) is a technique that amplifies the Raman
signal using metallic substrates, such as nanoparticles. The laser can also be tuned to the resonant frequency
of the molecule, which is known as surface-enhanced resonance Raman scattering (SERRS). Under controlled experimental
conditions, the amplitudes of the peaks are linearly related to the concentration of the molecule, from the limit
of detection (LOD) up to monolayer coverage of the nanoparticle surface.
</p>
<p>The GAMM represents the peaks and baseline as continuous functions. The background fluorescence is modelled
using a penalised cubic spline, while the peaks are an additive mixture of squared exponential (Gaussian) or Lorentzian
(Cauchy) kernels:
</p>
<p style="text-align: center;"><code class="reqn">Y = \sum_{m=1}^M \alpha_{i,m}B_m(\nu_j) + \sum_{p=1}^P s(\nu_j | l_p, A_p, \phi_p) + \epsilon_{i,j}</code>
</p>

<p>where <code class="reqn">Y</code> is a matrix of hyperspectral observations <code class="reqn">y_{i,j}</code> that have been discretised at wavenumbers <code class="reqn">\nu_j</code>;
<code class="reqn">B_m</code> are the <code class="reqn">M</code> spline basis functions with coefficients <code class="reqn">\alpha_{i,m}</code>; <code class="reqn">s(\nu_j | l_p, A_p, \phi_p)</code> 
are the radial basis functions for each peak, with location <code class="reqn">l_p</code>, amplitude <code class="reqn">A_p</code>, and scale <code class="reqn">\phi_p</code> parameters.
<code class="reqn">\epsilon_{i,j}</code> is assumed to be zero mean, additive white noise with constant variance <code class="reqn">\sigma^2</code>.
</p>
<p>This model-based approach accounts for differences in resolution and experimental conditions,
enabling comparison and alignment of heterogeneous spectra. The relationship between concentration
and peak intensity can be quantified by fitting a Bayesian functional regression:
</p>
<p style="text-align: center;"><code class="reqn">A_p = c_i \beta_p</code>
</p>

<p>where <code class="reqn">c_i</code> is the nanomolar (nM) concentration of the molecule in the <code class="reqn">i</code>th spectrum,
<code class="reqn">c_{LOD} &lt; c_i &lt;= c_{MLC}</code>. The regression model produces highest posterior density (HPD) intervals for the
limit of detection of each peak. A consistent, unbiased estimate of the model evidence (also known as the marginal likelihood)
is also computed. This can be used to evaluate whether Gaussian or Lorentzian peaks are a better fit to the data.
</p>


<h3>Author(s)</h3>

<p>M. T. Moores, J. Carson &amp; M. Girolami
</p>
<p>Maintainer: Matt Moores &lt;mmoores@gmail.com&gt;
</p>


<h3>References</h3>

<p>Moores, Gracie, Carson, Faulds, Graham &amp; Girolami &quot;Bayesian modelling and quantification of Raman spectroscopy,&quot; <a href="https://arxiv.org/abs/1604.07299">arXiv preprint</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate some data with known parameter values
wavenumbers &lt;- seq(700,1400,by=2)
spectra &lt;- matrix(nrow=1, ncol=length(wavenumbers))
peakLocations &lt;- c(840,  960, 1140, 1220, 1290)
peakAmplitude &lt;- c(11500, 2500, 4000, 3000, 2500)
peakScale &lt;- c(10, 15, 20, 10, 12)
signature &lt;- weightedLorentzian(peakLocations, peakScale, peakAmplitude, wavenumbers)
baseline &lt;- 1000*cos(wavenumbers/200) + 2*wavenumbers
spectra[1,] &lt;- signature + baseline + rnorm(length(wavenumbers),0,200)
plot(wavenumbers, spectra[1,], type='l', xlab="Raman offset", ylab="intensity")
lines(wavenumbers, baseline, col=2, lty=4)
lines(wavenumbers, baseline + signature, col=4, lty=2)

# fit the model using SMC
lPriors &lt;- list(scale.mu=log(11.6) - (0.4^2)/2, scale.sd=0.4, bl.smooth=10^11, bl.knots=50,
                beta.mu=5000, beta.sd=5000, noise.sd=200, noise.nu=4)

## Not run: 
## takes approx. 1 minute for 100 SMC iterations with 10,000 particles
result &lt;- fitSpectraSMC(wavenumbers, spectra, peakLocations, lPriors)
plot.ts(result$ess, xlab="SMC iterations", ylab="ESS")

# sample 200 particles from the posterior distribution
samp.idx &lt;- sample.int(length(result$weights), 200, prob=result$weights)
plot(wavenumbers, spectra[1,], type='l', xlab="Raman offset", ylab="intensity")
for (pt in samp.idx) {
  bl.est &lt;- result$basis %*% result$alpha[,1,pt]
  lines(wavenumbers, bl.est, col="#C3000009")
  lines(wavenumbers, bl.est + result$expFn[pt,], col="#0000C309")
}

## End(Not run)
</code></pre>

<hr>
<h2 id='sumDexp'>Sum log-likelihoods of i.i.d. exponential.</h2><span id='topic+sumDexp'></span>

<h3>Description</h3>

<p>This is an internal function that is only exposed on the public API for unit testing purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumDexp(x, rate)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sumDexp_+3A_x">x</code></td>
<td>
<p>Vector of i.i.d. exponential random varibles</p>
</td></tr>
<tr><td><code id="sumDexp_+3A_rate">rate</code></td>
<td>
<p>parameter of the exponential distribution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sum of the log-likelihoods (log of the product of the likelihoods)
for independent, identically-distributed, exponential random variables. 
Note: this Rcpp function is thread-safe, unlike the equivalent alternatives.
</p>


<h3>Value</h3>

<p>log-likelihood of x
</p>


<h3>See Also</h3>

<p><code>sum(dexp(x, rate, log=TRUE))</code>
</p>

<hr>
<h2 id='sumDlogNorm'>Sum log-likelihoods of i.i.d. lognormal.</h2><span id='topic+sumDlogNorm'></span>

<h3>Description</h3>

<p>This is an internal function that is only exposed on the public API for unit testing purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumDlogNorm(x, meanlog, sdlog)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sumDlogNorm_+3A_x">x</code></td>
<td>
<p>Vector of i.i.d. lognormal random varibles</p>
</td></tr>
<tr><td><code id="sumDlogNorm_+3A_meanlog">meanlog</code></td>
<td>
<p>mean of the distribution on the log scale</p>
</td></tr>
<tr><td><code id="sumDlogNorm_+3A_sdlog">sdlog</code></td>
<td>
<p>standard deviation on the log scale</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sum of the log-likelihoods (log of the product of the likelihoods)
for independent, identically-distributed, lognormal random variables. 
Note: this Rcpp function is thread-safe, unlike the equivalent alternatives.
</p>


<h3>Value</h3>

<p>log-likelihood of x
</p>


<h3>See Also</h3>

<p><code>sum(dlnorm(x, meanlog, sdlog, log=TRUE))</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rlnorm(100)
sumDlogNorm(x,0,1)
</code></pre>

<hr>
<h2 id='sumDnorm'>Sum log-likelihoods of Gaussian.</h2><span id='topic+sumDnorm'></span>

<h3>Description</h3>

<p>This is an internal function that is only exposed on the public API for unit testing purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumDnorm(x, mean, sd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sumDnorm_+3A_x">x</code></td>
<td>
<p>Vector of i.i.d. Gaussian random varibles</p>
</td></tr>
<tr><td><code id="sumDnorm_+3A_mean">mean</code></td>
<td>
<p>Vector of means</p>
</td></tr>
<tr><td><code id="sumDnorm_+3A_sd">sd</code></td>
<td>
<p>Vector of standard deviations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sum of the log-likelihoods (log of the product of the likelihoods)
for independent, identically-distributed, Gaussian random variables.
Note: this Rcpp function is thread-safe, unlike the equivalent alternatives.
</p>


<h3>Value</h3>

<p>log-likelihood of x
</p>


<h3>See Also</h3>

<p><code>sum(dnorm(x, mean, sd, log=TRUE))</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- rnorm(100)
  mu &lt;- rep(0,length(x))
  sd &lt;- rep(1,length(x))
  sumDnorm(x,mu,sd)
</code></pre>

<hr>
<h2 id='weightedGaussian'>Compute the spectral signature using Gaussian peaks.</h2><span id='topic+weightedGaussian'></span>

<h3>Description</h3>

<p>Calculates the value of the squared exponential radial basis function at the given wavelengths,
given the parameters of the peaks. This function is thread-safe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightedGaussian(location, scale, amplitude, wavelengths)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weightedGaussian_+3A_location">location</code></td>
<td>
<p>Vector of location parameters of the peaks (mean).</p>
</td></tr>
<tr><td><code id="weightedGaussian_+3A_scale">scale</code></td>
<td>
<p>Vector of scale parameters of the peaks (standard deviation).</p>
</td></tr>
<tr><td><code id="weightedGaussian_+3A_amplitude">amplitude</code></td>
<td>
<p>Vector of amplitudes of the peaks.</p>
</td></tr>
<tr><td><code id="weightedGaussian_+3A_wavelengths">wavelengths</code></td>
<td>
<p>Vector of wavenumbers at which to compute the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the Gaussian function at the given wavelengths.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Cal_V &lt;- seq(300,400,by=5)
  loc &lt;- c(320,350,375)
  sca &lt;- c(10,5,18)
  amp &lt;- c(1000,5000,2000)
  weightedGaussian(loc,sca,amp,Cal_V)
</code></pre>

<hr>
<h2 id='weightedLorentzian'>Compute the spectral signature using Lorentzian peaks.</h2><span id='topic+weightedLorentzian'></span>

<h3>Description</h3>

<p>Calculates the value of the Lorentzian function at the given wavelengths,
given the parameters of the peaks. This function is thread-safe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightedLorentzian(location, scale, amplitude, wavelengths)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weightedLorentzian_+3A_location">location</code></td>
<td>
<p>Vector of location parameters of the peaks.</p>
</td></tr>
<tr><td><code id="weightedLorentzian_+3A_scale">scale</code></td>
<td>
<p>Vector of scale parameters of the peaks.</p>
</td></tr>
<tr><td><code id="weightedLorentzian_+3A_amplitude">amplitude</code></td>
<td>
<p>Vector of amplitudes of the peaks.</p>
</td></tr>
<tr><td><code id="weightedLorentzian_+3A_wavelengths">wavelengths</code></td>
<td>
<p>Vector of wavenumbers at which to compute the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the Lorentian function at the given wavelengths.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Cal_V &lt;- seq(300,400,by=5)
  loc &lt;- c(320,350,375)
  sca &lt;- c(10,5,18)
  amp &lt;- c(1000,5000,2000)
  weightedLorentzian(loc,sca,amp,Cal_V)
</code></pre>

<hr>
<h2 id='weightedMean'>Compute the weighted arithmetic means of the particles.</h2><span id='topic+weightedMean'></span>

<h3>Description</h3>

<p>This SMC estimate of the means can be used to centre independent Metropolis-Hastings proposals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightedMean(particles, log_weights)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weightedMean_+3A_particles">particles</code></td>
<td>
<p><code>npeaks * npart</code> Matrix of parameter values for each particle.</p>
</td></tr>
<tr><td><code id="weightedMean_+3A_log_weights">log_weights</code></td>
<td>
<p>logarithms of the importance weights of each particle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of means, one for each row.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+weighted.mean">weighted.mean</a></code>
</p>

<hr>
<h2 id='weightedVariance'>Compute the weighted variance of the particles.</h2><span id='topic+weightedVariance'></span>

<h3>Description</h3>

<p>This SMC estimate of the variance can be used to scale the bandwidth of adaptive,
Gaussian random walk Metropolis-Hastings proposals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightedVariance(particles, log_weights, mean)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weightedVariance_+3A_particles">particles</code></td>
<td>
<p><code>npeaks * npart</code> Matrix of parameter values for each particle.</p>
</td></tr>
<tr><td><code id="weightedVariance_+3A_log_weights">log_weights</code></td>
<td>
<p>logarithms of the importance weights of each particle.</p>
</td></tr>
<tr><td><code id="weightedVariance_+3A_mean">mean</code></td>
<td>
<p>Vector of weighted means of each particle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of variances, one for each row.
</p>


<h3>See Also</h3>

<p><code><a href="Hmisc.html#topic+wtd.stats">wtd.var</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
