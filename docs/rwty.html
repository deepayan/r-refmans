<!DOCTYPE html><html lang="en"><head><title>Help for package rwty</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rwty}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#analyze.rwty'><p>analyze.rwty, the main interface for rwty analyses and plots.</p></a></li>
<li><a href='#check.chains'><p>Function for checking suitability of chains for rwty analyses, auto-generating labels, etc</p></a></li>
<li><a href='#clade.freq'><p>Returns clade names and frequencies</p></a></li>
<li><a href='#combine.ptables'><p>Function for merging p tables for multiple MCMC chains</p></a></li>
<li><a href='#cumulative.freq'><p>Cumulative means of clade split frequencies.</p></a></li>
<li><a href='#estimate.autocorr.m'><p>Calculate sampling interval based on exponential semivariogram model.</p></a></li>
<li><a href='#fungus'><p>MrBayes output from analysis of Hibbett et al. data</p></a></li>
<li><a href='#load.multi'><p>Load all matching files from a directory into a list of rwty.chain objects</p></a></li>
<li><a href='#load.trees'><p>Custom functions to load tree lists so that rwty can do basic processing on the way in.</p></a></li>
<li><a href='#makeplot.acsf.cumulative'><p>Plot the Change in Split Frequencies (CSF) in sliding windows over the course of an MCMC.</p></a></li>
<li><a href='#makeplot.acsf.sliding'><p>Plot the Chaing in Split Frequencies (CSF) in sliding windows over the course of an MCMC.</p></a></li>
<li><a href='#makeplot.all.params'><p>Plotting all parameters</p></a></li>
<li><a href='#makeplot.asdsf'><p>Plot the Standard Deviation of Split Frequencies over the course of an MCMC.</p></a></li>
<li><a href='#makeplot.autocorr'><p>Make autocorrelation plots of tree topologies from MCMC analyses</p></a></li>
<li><a href='#makeplot.pairs'><p>Plotting parameters against each other</p></a></li>
<li><a href='#makeplot.param'><p>Plotting parameters</p></a></li>
<li><a href='#makeplot.pseudo.ess'><p>Plot the pseudo ESS of tree topologies from MCMC chains.</p></a></li>
<li><a href='#makeplot.splitfreq.matrix'><p>Plots a matrix of split frequency comparisons between multiple MCMC chains.</p></a></li>
<li><a href='#makeplot.splitfreqs.cumulative'><p>Plot cumulative split frequencies over the course of an MCMC</p></a></li>
<li><a href='#makeplot.splitfreqs.sliding'><p>Plot split frequencies in sliding windows over the course of an MCMC</p></a></li>
<li><a href='#makeplot.topology'><p>Plotting parameters</p></a></li>
<li><a href='#makeplot.treespace'><p>Plot chains in treespace.</p></a></li>
<li><a href='#parse.clades'><p>Rename clades for easy recall</p></a></li>
<li><a href='#print.rwty.chain'><p>Function for printing rwty.chain objects</p></a></li>
<li><a href='#salamanders'><p>MrBayes output from analysis of Williams et al. data</p></a></li>
<li><a href='#slide.freq'><p>Sliding window measurements of clade split frequencies.</p></a></li>
<li><a href='#topological.approx.ess'><p>Calculate the approximate Effective Sample Size (ESS) of tree topologies</p></a></li>
<li><a href='#topological.autocorr'><p>Calculate data for autocorrelation plots of tree topologies from MCMC analyses</p></a></li>
<li><a href='#topological.pseudo.ess'><p>Calculate the pseudo Effective Sample Size (ESS) of tree topologies</p></a></li>
<li><a href='#tree.dist.matrix'><p>Tree distance matrix calculation</p></a></li>
<li><a href='#treespace'><p>MDS scaling of treespace for a single tree list.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>R We There Yet? Visualizing MCMC Convergence in Phylogenetics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements various tests, visualizations, and metrics
    for diagnosing convergence of MCMC chains in phylogenetics.  It implements
    and automates many of the functions of the AWTY package in the R
    environment.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0), ape, ggplot2,</td>
</tr>
<tr>
<td>Imports:</td>
<td>reshape2, phangorn, coda, viridis, grid, plyr, ggdendro,
GGally, parallel,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-02-04 09:23:09 UTC; dwarren</td>
</tr>
<tr>
<td>Author:</td>
<td>Dan Warren [aut, cre],
  Anthony Geneva [aut],
  Rob Lanfear [aut],
  Luke Harmon [ctb],
  April Wright [ctb],
  Diego Mallo [ctb],
  Klaus Schliep [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dan Warren &lt;dan.l.warren@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-02-15 15:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='analyze.rwty'>analyze.rwty, the main interface for rwty analyses and plots.</h2><span id='topic+analyze.rwty'></span>

<h3>Description</h3>

<p>This is the main user interface to rwty.  It allows users to conduct simple
visualizations of MCMC chain performance with  very few arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze.rwty(chains, burnin = 0, window.size = 20,
  treespace.points = 100, n.clades = 20, min.freq = 0,
  fill.color = NA, filename = NA, overwrite = FALSE, facet = TRUE,
  free_y = FALSE, autocorr.intervals = 100, ess.reps = 20,
  treedist = "PD", params = NA, max.sampling.interval = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="analyze.rwty_+3A_chains">chains</code></td>
<td>
<p>A list of rwty.chain objects.</p>
</td></tr>
<tr><td><code id="analyze.rwty_+3A_burnin">burnin</code></td>
<td>
<p>The number of trees to eliminate as burnin.  Default value is zero.</p>
</td></tr>
<tr><td><code id="analyze.rwty_+3A_window.size">window.size</code></td>
<td>
<p>The number of trees to include in each windows of sliding window plots</p>
</td></tr>
<tr><td><code id="analyze.rwty_+3A_treespace.points">treespace.points</code></td>
<td>
<p>The number of trees to plot in the treespace plot. Default is 100</p>
</td></tr>
<tr><td><code id="analyze.rwty_+3A_n.clades">n.clades</code></td>
<td>
<p>The number of clades to include in plots of split frequencies over the course of the MCMC</p>
</td></tr>
<tr><td><code id="analyze.rwty_+3A_min.freq">min.freq</code></td>
<td>
<p>The minimum frequency for a node to be used for calculating ASDSF. Default is 0.1</p>
</td></tr>
<tr><td><code id="analyze.rwty_+3A_fill.color">fill.color</code></td>
<td>
<p>The name of a column in your log file that you would like to use as the fill colour of points in the treespace plots</p>
</td></tr>
<tr><td><code id="analyze.rwty_+3A_filename">filename</code></td>
<td>
<p>Name of an output file (e.g., &quot;output.pdf&quot;).  If none is supplied, rwty will not save outputs to file.</p>
</td></tr>
<tr><td><code id="analyze.rwty_+3A_overwrite">overwrite</code></td>
<td>
<p>Boolean variable saying whether output file should be overwritten, if it exists.</p>
</td></tr>
<tr><td><code id="analyze.rwty_+3A_facet">facet</code></td>
<td>
<p>A Boolean expression indicating whether multiple chains should be plotted as facet plots (default TRUE).</p>
</td></tr>
<tr><td><code id="analyze.rwty_+3A_free_y">free_y</code></td>
<td>
<p>TRUE/FALSE to turn free y scales on the facetted plots on or off (default FALSE). Only works if facet = TRUE.</p>
</td></tr>
<tr><td><code id="analyze.rwty_+3A_autocorr.intervals">autocorr.intervals</code></td>
<td>
<p>The maximum number of intervals to use for autocorrelation plots.</p>
</td></tr>
<tr><td><code id="analyze.rwty_+3A_ess.reps">ess.reps</code></td>
<td>
<p>The number of replicate analyses to do when calculating the pseudo ESS.</p>
</td></tr>
<tr><td><code id="analyze.rwty_+3A_treedist">treedist</code></td>
<td>
<p>the type of tree distance metric to use, can be 'PD' for path distance or 'RF' for Robinson Foulds distance.</p>
</td></tr>
<tr><td><code id="analyze.rwty_+3A_params">params</code></td>
<td>
<p>A vector of parameters to use when making the parameter correlation plots.  Defaults to the first two columns in the log table.</p>
</td></tr>
<tr><td><code id="analyze.rwty_+3A_max.sampling.interval">max.sampling.interval</code></td>
<td>
<p>The maximum sampling interval to use for generating autocorrelation plots</p>
</td></tr>
<tr><td><code id="analyze.rwty_+3A_...">...</code></td>
<td>
<p>Extra arguments to be passed to plotting and analysis functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output The output is a list containing the following plots:
</p>
<p>Plots of likelihood, model parameters, and tree topologies as a function of chain length (the first two only when output from MCMC parameters has been loaded along with the tree topologies).
</p>
<p>Plot of autocorrelation of tree topolgies at different sampling intervals along a chain 
</p>
<p>Plot of split frequencies calculated in sliding windows for the most variable clades
</p>
<p>Plot of change in split frequencies between sliding windows for all clades
</p>
<p>Plot of cumulative split frequencies as the MCMC progresses
</p>
<p>Plot of change in cumulative split frequencies as the MCMC progresses
</p>
<p>Heatmap and point depictions of chains in treespace.
</p>
<p>Plot of the Average Standard Deviation of Split Frequencies (ASDSF) between chains as the MCMC progresses
</p>
<p>Plot of pairwise correlations between split frequencies among chains  
</p>
<p>Plot of chains clustered by their pairwise ASDSF values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fungus)
p &lt;- analyze.rwty(fungus, burnin = 50, window.num = 50)
p

## End(Not run)
</code></pre>

<hr>
<h2 id='check.chains'>Function for checking suitability of chains for rwty analyses, auto-generating labels, etc</h2><span id='topic+check.chains'></span>

<h3>Description</h3>

<p>This function is automatically called by many other functions, but can be run manually as well.
It performs a number of tests of chain format, labels, lengths, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.chains(chains)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.chains_+3A_chains">chains</code></td>
<td>
<p>A list of rwty.chain objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>chains A list of rwty.chain objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fungus)
check.chains(fungus)

## End(Not run)
</code></pre>

<hr>
<h2 id='clade.freq'>Returns clade names and frequencies</h2><span id='topic+clade.freq'></span>

<h3>Description</h3>

<p>Uses ape functionality to get the frequencies and names of clades in an MCMC chain
or subset thereof.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clade.freq(x, start, end, rooted = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clade.freq_+3A_x">x</code></td>
<td>
<p>A multiPhylo or rwty.chain object</p>
</td></tr>
<tr><td><code id="clade.freq_+3A_start">start</code></td>
<td>
<p>The index of the first tree to consider in calcuating frequencies</p>
</td></tr>
<tr><td><code id="clade.freq_+3A_end">end</code></td>
<td>
<p>The index of the last tree to consider in calculating frequencies</p>
</td></tr>
<tr><td><code id="clade.freq_+3A_rooted">rooted</code></td>
<td>
<p>(TRUE/FALSE).  Tells RWTY whether your trees are rooted or not.</p>
</td></tr>
<tr><td><code id="clade.freq_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to ape's prop.part function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>clade.df A data froma containing clade names and frequencies
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fungus)
clade.freq(fungus$Fungus.Run1, start=10, end=100)

## End(Not run)
</code></pre>

<hr>
<h2 id='combine.ptables'>Function for merging p tables for multiple MCMC chains</h2><span id='topic+combine.ptables'></span>

<h3>Description</h3>

<p>This function is automatically called by some of the plot functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine.ptables(chains, burnin)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine.ptables_+3A_chains">chains</code></td>
<td>
<p>A list of rwty.chain objects.</p>
</td></tr>
<tr><td><code id="combine.ptables_+3A_burnin">burnin</code></td>
<td>
<p>The number of trees to eliminate as burnin</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ptable A data frame of likelihood values and model parameters for the supplied rwty.chain objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fungus)
combine.ptables(fungus, burnin=20)

## End(Not run)
</code></pre>

<hr>
<h2 id='cumulative.freq'>Cumulative means of clade split frequencies.</h2><span id='topic+cumulative.freq'></span>

<h3>Description</h3>

<p>This function calculates the cumulative mean split frequencies of clades as an MCMC progresses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumulative.freq(chains, burnin = 0, window.size = 20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cumulative.freq_+3A_chains">chains</code></td>
<td>
<p>A list of rwty.chain objects.</p>
</td></tr>
<tr><td><code id="cumulative.freq_+3A_burnin">burnin</code></td>
<td>
<p>The number of trees to eliminate as burnin. Defaults to zero.</p>
</td></tr>
<tr><td><code id="cumulative.freq_+3A_window.size">window.size</code></td>
<td>
<p>The number of trees to include in each window (note, specified as a number of sampled trees, not a number of generations)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of rwty.cumulative objects, one per chain in the input list of chains.
Each rwty.cumulative object contains the cumulative mean split frequencies of clades at sp
windows, and a translation table that converts clade groupings to factors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fungus)
cumulative.data &lt;- cumulative.freq(fungus, burnin=20)

## End(Not run)
</code></pre>

<hr>
<h2 id='estimate.autocorr.m'>Calculate sampling interval based on exponential semivariogram model.</h2><span id='topic+estimate.autocorr.m'></span>

<h3>Description</h3>

<p>This function uses an exponential semivariogram model to estimate the asymptotic topological distance, and
uses that to estimate the sampling interval at which topological distances have reached some fixed
proportion of that value (default 0.95).  It expects as input a data table output by rwty's topological.autocorr function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate.autocorr.m(dat, ac.cutoff = 0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate.autocorr.m_+3A_dat">dat</code></td>
<td>
<p>A data frame output from topological.autocorr.</p>
</td></tr>
<tr><td><code id="estimate.autocorr.m_+3A_ac.cutoff">ac.cutoff</code></td>
<td>
<p>Default 0.95. The proportion of the asymptotic topological distance to use as a cutoff for determining sampling interval. For example, if ac.cutoff = 0.9, then the minimum sampling interval returned is the one that guarantees a topological distance at least 0.9 times the asymptotic value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame consisting of the value matching the ac.cutoff proportion of the asymptotic 
topological distance for each chain.  This sampling interval estimates the interval at which topological distances
are no longer autocorrelated. If the value is larger than the largest sampling distance, the table records this as a value of -1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fungus)
## Not run: 
# To get a good estimate we need all sampling intervals
autocorr.intervals = as.integer(length(fungus[[1]]$trees)/21)
sampling.table &lt;- topological.autocorr(fungus, burnin = 20, autocorr.intervals = autocorr.intervals)
estimate.autocorr.m(sampling.table)

## End(Not run)
</code></pre>

<hr>
<h2 id='fungus'>MrBayes output from analysis of Hibbett et al. data</h2><span id='topic+fungus'></span>

<h3>Description</h3>

<p>This is the output from a MrBayes run of 10,000,000 generations using the analysis settings from the original .nex file.  
Sampling is one tree per 40,000 generations.  Four chains are included, each with its associated log file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fungus)
</code></pre>


<h3>Format</h3>

<p>A data frame with four chains of 251 phylogenetic trees and associated likelihood and parameter values.</p>


<h3>References</h3>

<p>Study reference: Hibbett D., Pine E., Langer E., Langer G., &amp; Donoghue M. 1997. Evolution of gilled
mushrooms and puffballs inferred from ribosomal DNA sequences. Proceedings of
the National Academy of Sciences of the United States of America, 94(22): 12002-12006.
</p>
<p>http://treebase.org/treebase-web/search/study/summary.html?id=271
</p>

<hr>
<h2 id='load.multi'>Load all matching files from a directory into a list of rwty.chain objects</h2><span id='topic+load.multi'></span>

<h3>Description</h3>

<p>Finds trees and log files based on format definition, returns rwty.chain objects containing both
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.multi(path = ".", format = "mb", labels = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load.multi_+3A_path">path</code></td>
<td>
<p>The path to the directory containing tree and log files</p>
</td></tr>
<tr><td><code id="load.multi_+3A_format">format</code></td>
<td>
<p>File format, which is used to find tree and log files.
Currently accepted values are &quot;mb&quot; for MrBayes, &quot;beast&quot; for BEAST, &quot;*beast&quot; for *BEAST, and &quot;revbayes&quot; for RevBayes.
If you would like RWTY to understand additional formats, please contact the authors and send us some sample data.</p>
</td></tr>
<tr><td><code id="load.multi_+3A_labels">labels</code></td>
<td>
<p>A vector of names to assign to chains as they are read in.</p>
</td></tr>
<tr><td><code id="load.multi_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to load.trees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output A list of rwty.chain objects containing the multiPhylos and the tables of values from the log files if available.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load.multi(path = "~/my trees/", format = "*beast")
</code></pre>

<hr>
<h2 id='load.trees'>Custom functions to load tree lists so that rwty can do basic processing on the way in.</h2><span id='topic+load.trees'></span>

<h3>Description</h3>

<p>Loads trees, looks for a log file of tree likelihoods and parameter values, returns an rwty.chain object containing both
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.trees(file, type = NA, format = "mb", gens.per.tree = NA,
  trim = 1, logfile = NA, skip = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load.trees_+3A_file">file</code></td>
<td>
<p>A path to a tree file containing an MCMC chain of trees</p>
</td></tr>
<tr><td><code id="load.trees_+3A_type">type</code></td>
<td>
<p>An argument that designates the type of tree file.  If &quot;nexus&quot;,
trees are loaded using ape's <code><a href="ape.html#topic+read.nexus">read.nexus</a></code> function.  Otherwise, it's <code><a href="ape.html#topic+read.tree">read.tree</a></code>.
If a &quot;format&quot; argument is passed, type will be determined from the format definition.</p>
</td></tr>
<tr><td><code id="load.trees_+3A_format">format</code></td>
<td>
<p>File format, which is used to find tree and log files.
Currently accepted values are &quot;mb&quot; for MrBayes, &quot;beast&quot; for BEAST, &quot;*beast&quot; for *BEAST, and &quot;revbayes&quot; for RevBayes.
If you would like RWTY to understand additional formats, please contact the authors and send us some sample data.</p>
</td></tr>
<tr><td><code id="load.trees_+3A_gens.per.tree">gens.per.tree</code></td>
<td>
<p>The number of generations separating trees.  If not provided, RWTY will attempt to calculate it automatically.</p>
</td></tr>
<tr><td><code id="load.trees_+3A_trim">trim</code></td>
<td>
<p>Used for thinning the chain.  If a number N is provided, RWTY keeps every Nth tree.</p>
</td></tr>
<tr><td><code id="load.trees_+3A_logfile">logfile</code></td>
<td>
<p>A path to a file containing model parameters and likelihoods.  If no path is provided but
a &quot;format&quot; argument is supplied, RWTY will attempt to find the log file automatically based on the format
definition.</p>
</td></tr>
<tr><td><code id="load.trees_+3A_skip">skip</code></td>
<td>
<p>The number of lines that must be skipped to get to the header of the log file.
MrBayes, for instance, prints a comment line at the top of the log file, so MrBayes files should be
read in with a skip value of 1.  If no &quot;skip&quot; value is provided but a &quot;format&quot; is supplied, RWTY will
attempt to read logs using the skip value from the format definition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output An rwty.chain object containing the multiPhylo and the table of values from the log file if available.
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+read.tree">read.tree</a></code>, <code><a href="ape.html#topic+read.nexus">read.nexus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load.trees(file="mytrees.t", format = "mb")
</code></pre>

<hr>
<h2 id='makeplot.acsf.cumulative'>Plot the Change in Split Frequencies (CSF) in sliding windows over the course of an MCMC.</h2><span id='topic+makeplot.acsf.cumulative'></span>

<h3>Description</h3>

<p>This function takes one or more rwty.chain ojects and returns a plot of CSF within each chain as the MCMC progresses.  
The solid line with points shows the Average Change in Split Frequencies (ACSF; it is average across the changes in split frequencies from all clades in the analysis) between this window and the previous window
The grey ribbon shows the upper and lower 95
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeplot.acsf.cumulative(chains, burnin = 0, window.size = 20,
  facet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeplot.acsf.cumulative_+3A_chains">chains</code></td>
<td>
<p>A list of rwty.chain objects.</p>
</td></tr>
<tr><td><code id="makeplot.acsf.cumulative_+3A_burnin">burnin</code></td>
<td>
<p>The number of trees to eliminate as burnin. Defaults to zero.</p>
</td></tr>
<tr><td><code id="makeplot.acsf.cumulative_+3A_window.size">window.size</code></td>
<td>
<p>The number of trees to include in each window (note, specified as a number of sampled trees, not a number of generations)</p>
</td></tr>
<tr><td><code id="makeplot.acsf.cumulative_+3A_facet">facet</code></td>
<td>
<p>(TRUE/FALSE). TRUE: return a single plot with one facet per chain; FALSE: return a list of individual plots with one plot per chain</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output A plof of the CSF between sliding windows over all chains
</p>
<p>acsf.plot A ggplot object, or list of ggplot objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fungus)
makeplot.acsf.cumulative(fungus, burnin=20)

## End(Not run)
</code></pre>

<hr>
<h2 id='makeplot.acsf.sliding'>Plot the Chaing in Split Frequencies (CSF) in sliding windows over the course of an MCMC.</h2><span id='topic+makeplot.acsf.sliding'></span>

<h3>Description</h3>

<p>This function takes one or more rwty.chain ojects and returns a plot of CSF within each chain as the MCMC progresses.  
The solid line with points shows the Average Change in Split Frequencies (ACSF) between this window and the previous window
The grey ribbon shows the upper and lower 95
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeplot.acsf.sliding(chains, burnin = 0, window.size = 20,
  facet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeplot.acsf.sliding_+3A_chains">chains</code></td>
<td>
<p>A list of rwty.chain objects.</p>
</td></tr>
<tr><td><code id="makeplot.acsf.sliding_+3A_burnin">burnin</code></td>
<td>
<p>The number of trees to eliminate as burnin. Defaults to zero.</p>
</td></tr>
<tr><td><code id="makeplot.acsf.sliding_+3A_window.size">window.size</code></td>
<td>
<p>The number of trees to include in each window (note, specified as a number of sampled trees, not a number of generations)</p>
</td></tr>
<tr><td><code id="makeplot.acsf.sliding_+3A_facet">facet</code></td>
<td>
<p>(TRUE/FALSE). TRUE: return a single plot with one facet per chain; FALSE: return a list of individual plots with one plot per chain</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output A plof of the CSF between sliding windows over all chains
</p>
<p>acsf.plot A ggplot object, or list of ggplot objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fungus)
makeplot.acsf.sliding(fungus, burnin=20)

## End(Not run)
</code></pre>

<hr>
<h2 id='makeplot.all.params'>Plotting all parameters</h2><span id='topic+makeplot.all.params'></span>

<h3>Description</h3>

<p>Plots all parameter values, including tree topologies (see makeplot.topology) over the length of the MCMC chain
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeplot.all.params(chains, burnin = 0, facet = TRUE, free_y = FALSE,
  strip = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeplot.all.params_+3A_chains">chains</code></td>
<td>
<p>A set of rwty.chain objects</p>
</td></tr>
<tr><td><code id="makeplot.all.params_+3A_burnin">burnin</code></td>
<td>
<p>The number of trees to omit as burnin.</p>
</td></tr>
<tr><td><code id="makeplot.all.params_+3A_facet">facet</code></td>
<td>
<p>Boolean denoting whether to make a facet plot.</p>
</td></tr>
<tr><td><code id="makeplot.all.params_+3A_free_y">free_y</code></td>
<td>
<p>TRUE/FALSE to turn free y scales on the facetted plots on or off (default FALSE). Only works if facet = TRUE.</p>
</td></tr>
<tr><td><code id="makeplot.all.params_+3A_strip">strip</code></td>
<td>
<p>Number indicating which column to strip off (i.e., strip=1 removes first column, which is necessary for most MCMC outputs in which the first column is just the generation).
You can skip multiple columns by passing a vector of columns to skip, e.g., strip=c(1,4,6).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>param.plot Returns a list of ggplot objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fungus)
makeplot.all.params(fungus, burnin=20)

## End(Not run)
</code></pre>

<hr>
<h2 id='makeplot.asdsf'>Plot the Standard Deviation of Split Frequencies over the course of an MCMC.</h2><span id='topic+makeplot.asdsf'></span>

<h3>Description</h3>

<p>This function takes two or more rwty.chain ojects and returns a plot of ASDSF as the run progresses.  
The solid line with points shows the Average Standard Deviation of Split Frequences at the current generation
The grey ribbon shows the upper and lower 95
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeplot.asdsf(chains, burnin = 0, window.size = 20, min.freq = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeplot.asdsf_+3A_chains">chains</code></td>
<td>
<p>A list of rwty.chain objects.</p>
</td></tr>
<tr><td><code id="makeplot.asdsf_+3A_burnin">burnin</code></td>
<td>
<p>The number of trees to eliminate as burnin. Defaults to zero.</p>
</td></tr>
<tr><td><code id="makeplot.asdsf_+3A_window.size">window.size</code></td>
<td>
<p>The number of trees between each point at which the ASDSFs is calculated (note, specified as a number of sampled trees, not a number of generations)</p>
</td></tr>
<tr><td><code id="makeplot.asdsf_+3A_min.freq">min.freq</code></td>
<td>
<p>The minimum frequency for a node to be used for calculating ASDSF.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output A cumulative plot of ASDSF across all chains
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fungus)
p &lt;- makeplot.asdsf(fungus, burnin = 20)
p

## End(Not run)
</code></pre>

<hr>
<h2 id='makeplot.autocorr'>Make autocorrelation plots of tree topologies from MCMC analyses</h2><span id='topic+makeplot.autocorr'></span>

<h3>Description</h3>

<p>This function takes a list of rwty.chain objects, and makes an
autocorrelation plot for each chain. Each plot shows the mean phylogenetic
distance at a series of sampling intervals. In really well behaved MCMC 
analyses, the mean distance will stay constant as the sampling interval 
increases. If there is autocorrelation, the mean distance will 
increase as the sampling interval increases, and is expected to level
off when the autocorrelation decreases to zero. The function calculates
path distances, though other distances could also be employed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeplot.autocorr(chains, burnin = 0, max.sampling.interval = NA,
  autocorr.intervals = 40, squared = FALSE, facet = FALSE,
  free_y = FALSE, treedist = "PD", use.all.samples = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeplot.autocorr_+3A_chains">chains</code></td>
<td>
<p>A list of rwty.chain objects.</p>
</td></tr>
<tr><td><code id="makeplot.autocorr_+3A_burnin">burnin</code></td>
<td>
<p>The number of trees to eliminate as burnin.</p>
</td></tr>
<tr><td><code id="makeplot.autocorr_+3A_max.sampling.interval">max.sampling.interval</code></td>
<td>
<p>The largest sampling interval for which you want to calculate the mean distance between pairs of trees (default is 10 percent of the length of the chain).</p>
</td></tr>
<tr><td><code id="makeplot.autocorr_+3A_autocorr.intervals">autocorr.intervals</code></td>
<td>
<p>The number of sampling intervals to use. These will be spaced evenly between 1 and the max.sampling.interval</p>
</td></tr>
<tr><td><code id="makeplot.autocorr_+3A_squared">squared</code></td>
<td>
<p>TRUE/FALSE use squared tree distances (necessary to calculate approximate ESS; default FALSE)</p>
</td></tr>
<tr><td><code id="makeplot.autocorr_+3A_facet">facet</code></td>
<td>
<p>TRUE/FALSE to turn facetting of the plot on or off (default FALSE)</p>
</td></tr>
<tr><td><code id="makeplot.autocorr_+3A_free_y">free_y</code></td>
<td>
<p>TRUE/FALSE to turn free y scales on the facetted plots on or off (default FALSE). Only works if facet = TRUE.</p>
</td></tr>
<tr><td><code id="makeplot.autocorr_+3A_treedist">treedist</code></td>
<td>
<p>the type of tree distance metric to use, can be 'PD' for path distance or 'RF' for Robinson Foulds distance</p>
</td></tr>
<tr><td><code id="makeplot.autocorr_+3A_use.all.samples">use.all.samples</code></td>
<td>
<p>(TRUE/FALSE). Whether to calculate autocorrelation from all possible pairs of trees in your chain. The default is FALSE, in which case 500 samples are taken at each sampling interval. This is sufficient to get reasonably accurate estimates of the approximate ESS. Setting this to TRUE will give you slightly more accurate ESS estimates, at the cost of potentially much longer execution times.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 plot object, with one line (facetting off) or facet
(facetting on) per rwty.chain object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fungus)
makeplot.autocorr(fungus, burnin = 20)

## End(Not run)
</code></pre>

<hr>
<h2 id='makeplot.pairs'>Plotting parameters against each other</h2><span id='topic+makeplot.pairs'></span>

<h3>Description</h3>

<p>Makes a plot matrix of each parameter against each other (including the topology) in your analysis. The default behaviour
is to just plot the first two columns of your parameter file (after removing the column for the generation number) as well
as the topological distance. This usually means that you see a pairs plot with the likelihood, the tree length, and the tree toppology. 
We do this because some parameter files contain so many columns that the plot matrix becomes too 
busy. To include parameters of your choice, use the 'parameters' argument. In this function, the topological distance is
calculate from the first tree in every chain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeplot.pairs(chains, burnin = 0, treedist = "PD", params = NA,
  strip = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeplot.pairs_+3A_chains">chains</code></td>
<td>
<p>A list of rwty.chain objects.</p>
</td></tr>
<tr><td><code id="makeplot.pairs_+3A_burnin">burnin</code></td>
<td>
<p>The number of trees to omit as burnin.</p>
</td></tr>
<tr><td><code id="makeplot.pairs_+3A_treedist">treedist</code></td>
<td>
<p>the type of tree distance metric to use, can be 'PD' for path distance or 'RF' for Robinson Foulds distance</p>
</td></tr>
<tr><td><code id="makeplot.pairs_+3A_params">params</code></td>
<td>
<p>'NA', 'all', or a vector of column names to include in the plot. 'NA' gives the default behaviour (see above). 'all' plots all columns (watch out!). Choose specific columns by name with a vector.</p>
</td></tr>
<tr><td><code id="makeplot.pairs_+3A_strip">strip</code></td>
<td>
<p>Number indicating which column to strip off (i.e., strip=1 removes first column, which is necessary for most MCMC outputs in which the first column is just the generation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pairs.plot Returns a ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(salamanders)
makeplot.pairs(salamanders[1], burnin=20)

# plot all the variables
makeplot.pairs(salamanders[1], burnin=20, params = 'all')

# plot specific the variables (note: you always get the topological distance)
makeplot.pairs(salamanders[1], burnin=20, params = c('pi.A.', 'pi.C.', 'pi.G.', 'pi.T.'))

## End(Not run)
</code></pre>

<hr>
<h2 id='makeplot.param'>Plotting parameters</h2><span id='topic+makeplot.param'></span>

<h3>Description</h3>

<p>Plots parameter values over the length of the MCMC chain
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeplot.param(chains, burnin = 0, parameter = "LnL", facet = TRUE,
  free_y = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeplot.param_+3A_chains">chains</code></td>
<td>
<p>A set of rwty.chain objects.</p>
</td></tr>
<tr><td><code id="makeplot.param_+3A_burnin">burnin</code></td>
<td>
<p>The number of trees to omit as burnin.</p>
</td></tr>
<tr><td><code id="makeplot.param_+3A_parameter">parameter</code></td>
<td>
<p>The column name of the parameter to plot.</p>
</td></tr>
<tr><td><code id="makeplot.param_+3A_facet">facet</code></td>
<td>
<p>Boolean denoting whether to make a facet plot.</p>
</td></tr>
<tr><td><code id="makeplot.param_+3A_free_y">free_y</code></td>
<td>
<p>TRUE/FALSE to turn free y scales on the facetted plots on or off (default FALSE). Only works if facet = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>param.plot Returns a ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fungus)
makeplot.param(fungus, burnin=20, parameter="pi.A.")

## End(Not run)
</code></pre>

<hr>
<h2 id='makeplot.pseudo.ess'>Plot the pseudo ESS of tree topologies from MCMC chains.</h2><span id='topic+makeplot.pseudo.ess'></span>

<h3>Description</h3>

<p>This function takes a list of rwty.chain objects, and plots the
pseudo ESS of the tree topologies from each chain, after removing burnin. 
Each caulcation is repeated n times, where in each replicate a random
tree from the chain is chosen as a 'focal' tree. The calculation works
by calculating the path distance of each tree in the chain
from the focal tree, and calculating the ESS of the resulting vector
of phylogenetic distances using the effectiveSize function from the 
coda package. NB this function requires the calculation of many
tree distances, so can take some time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeplot.pseudo.ess(chains, burnin = 0, n = 20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeplot.pseudo.ess_+3A_chains">chains</code></td>
<td>
<p>A list of rwty.chain objects.</p>
</td></tr>
<tr><td><code id="makeplot.pseudo.ess_+3A_burnin">burnin</code></td>
<td>
<p>The number of trees to eliminate as burnin</p>
</td></tr>
<tr><td><code id="makeplot.pseudo.ess_+3A_n">n</code></td>
<td>
<p>The number of replicate analyses to do</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pseudo.ess.plot A ggplot2 plot object, in which each chain is represented by a point
which represents the median pseudo ESS from the n replicates, and
whiskers representing the upper and lower 95
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fungus)
makeplot.pseudo.ess(fungus, burnin = 20, n = 10)

## End(Not run)
</code></pre>

<hr>
<h2 id='makeplot.splitfreq.matrix'>Plots a matrix of split frequency comparisons between multiple MCMC chains.</h2><span id='topic+makeplot.splitfreq.matrix'></span>

<h3>Description</h3>

<p>This function takes list of rwty.chain objects, and returns a scatterplot matrix
in which each plot shows the split frequencies of all clades that appear in one or both 
MCMC chains at least once. In the upper diagonal, we show the correlation between the split
frequencies (Pearson's R), and the Average Standard Deviation of the split frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeplot.splitfreq.matrix(chains, burnin = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeplot.splitfreq.matrix_+3A_chains">chains</code></td>
<td>
<p>A list of rwty.chain objects.</p>
</td></tr>
<tr><td><code id="makeplot.splitfreq.matrix_+3A_burnin">burnin</code></td>
<td>
<p>The number of trees to eliminate as burnin</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output A list of two plots: the first is a matrix of scatterplots, where each point is a clade, and the values are the split frequencies of that clade in the post-burnin trees of each chain. The second plot is a tree of the chains clustered by their ASDSFs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(salamanders)
makeplot.splitfreq.matrix(salamanders[1:4], burnin = 20)

## End(Not run)
</code></pre>

<hr>
<h2 id='makeplot.splitfreqs.cumulative'>Plot cumulative split frequencies over the course of an MCMC</h2><span id='topic+makeplot.splitfreqs.cumulative'></span>

<h3>Description</h3>

<p>Takes a list of rwty.chain objects.  
Plots the cumulative split frequencies of clades over the course of the MCMC. Stationarity is indicated by split frequencies levelling out.
Only plots the n.clades most variable clades, as measured by the standard deviation of the split frequencies of each clade across all windows.  
Each line in the plot represents a single clade. The colour of the line represents the standard deviation of the split frequencies of that clade across all sliding windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeplot.splitfreqs.cumulative(chains, burnin = 0, n.clades = 20,
  window.size = 20, facet = TRUE, rank = "wcsf")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeplot.splitfreqs.cumulative_+3A_chains">chains</code></td>
<td>
<p>A list of rwty.chain objects.</p>
</td></tr>
<tr><td><code id="makeplot.splitfreqs.cumulative_+3A_burnin">burnin</code></td>
<td>
<p>The number of trees to eliminate as burnin</p>
</td></tr>
<tr><td><code id="makeplot.splitfreqs.cumulative_+3A_n.clades">n.clades</code></td>
<td>
<p>The number of clades to plot</p>
</td></tr>
<tr><td><code id="makeplot.splitfreqs.cumulative_+3A_window.size">window.size</code></td>
<td>
<p>The number of trees to include in each window (note, specified as a number of sampled trees, not a number of generations)</p>
</td></tr>
<tr><td><code id="makeplot.splitfreqs.cumulative_+3A_facet">facet</code></td>
<td>
<p>(TRUE/FALSE). TRUE: return a single plot with one facet per chain; FALSE: return a list of individual plots with one plot per chain</p>
</td></tr>
<tr><td><code id="makeplot.splitfreqs.cumulative_+3A_rank">rank</code></td>
<td>
<p>('wcsf', 'sd'). How to rank the clades? By default, we plot the 20 'worst' clades. This parameter sets the definition of 'worst'. The default is to rank the by the weighted change in split frequencies (rank = 'wcsf'). This works by looking at the change in the cumulative split frequency over the course of the MCMC, and ranks the worst chains as those that do not level off (i.e. those that have changes near the end). We do this because in a well-behaved chain, we expect the cumulative split frequencies to level off once the chain has been run for long enough. So, any cumulative split frequencies which are still changing towards the end of your run are likely to indicate problematic clades. Specifically, we multiply the absolute change in split frequencies for each clade by a set of weights that increase linearly towards the end of the chain (the first observation gets a weight of zero, the final observation gets a weight of one). The original AWTY ranked clades by their standard deviations (higher SD = worse), so we include this as an option too. To do this, just set rank = 'sd'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>splitfreqs.plot Either a single ggplot2 object or a list of ggplot2 objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fungus)
makeplot.splitfreqs.cumulative(fungus, burnin = 20, n.clades=25)

## End(Not run)
</code></pre>

<hr>
<h2 id='makeplot.splitfreqs.sliding'>Plot split frequencies in sliding windows over the course of an MCMC</h2><span id='topic+makeplot.splitfreqs.sliding'></span>

<h3>Description</h3>

<p>Takes a list of rwty.chain objects.  
Plots the split frequencies of clades over the course of the MCMC, calculated from windows of a specified size.
Only plots the n.clades most variable clades, as measured by the standard deviation of the split frequencies of each clade across the MCMC.  
Each line in the plot represents a single clade. The colour of the line represents the standard deviation of the split frequencies of that clade across the MCMC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeplot.splitfreqs.sliding(chains, burnin = 0, n.clades = 20,
  window.size = 20, facet = TRUE, rank = "ess")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeplot.splitfreqs.sliding_+3A_chains">chains</code></td>
<td>
<p>A list of rwty.chain objects.</p>
</td></tr>
<tr><td><code id="makeplot.splitfreqs.sliding_+3A_burnin">burnin</code></td>
<td>
<p>The number of trees to eliminate as burnin</p>
</td></tr>
<tr><td><code id="makeplot.splitfreqs.sliding_+3A_n.clades">n.clades</code></td>
<td>
<p>The number of clades to plot</p>
</td></tr>
<tr><td><code id="makeplot.splitfreqs.sliding_+3A_window.size">window.size</code></td>
<td>
<p>The number of trees to include in each window (note, specified as a number of sampled trees, not a number of generations)</p>
</td></tr>
<tr><td><code id="makeplot.splitfreqs.sliding_+3A_facet">facet</code></td>
<td>
<p>(TRUE/FALSE). TRUE: return a single plot with one facet per chain; FALSE: return a list of individual plots with one plot per chain</p>
</td></tr>
<tr><td><code id="makeplot.splitfreqs.sliding_+3A_rank">rank</code></td>
<td>
<p>('ess', 'sd'). How to rank the clades? By default, we plot the 20 'worst' clades. This parameter sets the definition of 'worst'. The default is to rank the clades by increasing Effective Sample Size (i.e. the 20 worst clades are those with the lowest ESS), since in a sliding window plot we expect well-sampled splits to have a high value (rank = &quot;ess&quot;).  The original AWTY ranked clades by their standard deviations. To do this, just set rank = 'sd'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>splitfreqs.plot Either a single ggplot2 object or a list of ggplot2 objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fungus)
makeplot.splitfreqs.sliding(fungus, burnin = 20, n.clades=25)

## End(Not run)
</code></pre>

<hr>
<h2 id='makeplot.topology'>Plotting parameters</h2><span id='topic+makeplot.topology'></span>

<h3>Description</h3>

<p>Plots a trace of topological distances of trees over the length of the MCMC chain. The plot shows the path distance
of each tree in each chain from the last tree of the burnin of the first chain. If burnin is set to zero, then 
distances are calculated from the first tree of the first chain.
If required, the behaviour can be changed to plot the path distance of each tree from the last tree of the burnin
of each chain, using the independent.chains option. This is not recommended in most cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeplot.topology(chains, burnin = 0, facet = TRUE, free_y = FALSE,
  independent.chains = FALSE, treedist = "PD", approx.ess = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeplot.topology_+3A_chains">chains</code></td>
<td>
<p>A set of rwty.chain objects.</p>
</td></tr>
<tr><td><code id="makeplot.topology_+3A_burnin">burnin</code></td>
<td>
<p>The number of trees to omit as burnin.</p>
</td></tr>
<tr><td><code id="makeplot.topology_+3A_facet">facet</code></td>
<td>
<p>TRUE/FALSE denoting whether to make a facet plot (default TRUE)</p>
</td></tr>
<tr><td><code id="makeplot.topology_+3A_free_y">free_y</code></td>
<td>
<p>TRUE/FALSE to turn free y scales on the facetted plots on or off (default FALSE). Only works if facet = TRUE.</p>
</td></tr>
<tr><td><code id="makeplot.topology_+3A_independent.chains">independent.chains</code></td>
<td>
<p>TRUE/FALSE if FALSE (the default) then the plots show the distance of each tree from the last tree of the burnin of the first chain. If TRUE, the plots show the distance of each tree from the first tree of the chain in which that tree appears. The TRUE option should only be used in the case that different chains represent analyses of different genes or datasets.</p>
</td></tr>
<tr><td><code id="makeplot.topology_+3A_treedist">treedist</code></td>
<td>
<p>the type of tree distance metric to use, can be 'PD' for path distance or 'RF' for Robinson Foulds distance</p>
</td></tr>
<tr><td><code id="makeplot.topology_+3A_approx.ess">approx.ess</code></td>
<td>
<p>TRUE/FALSE do you want the approximate topological ess to be calculated and displayed for each chain?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>topology.trace.plot Returns a ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fungus)
makeplot.topology(fungus, burnin=20)

## End(Not run)
</code></pre>

<hr>
<h2 id='makeplot.treespace'>Plot chains in treespace.</h2><span id='topic+makeplot.treespace'></span>

<h3>Description</h3>

<p>This function will take list of rwty.chains objects and produce plots of chains in treespace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeplot.treespace(chains, burnin = 0, n.points = 100,
  fill.color = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeplot.treespace_+3A_chains">chains</code></td>
<td>
<p>A list of one or more rwty.chain objects</p>
</td></tr>
<tr><td><code id="makeplot.treespace_+3A_burnin">burnin</code></td>
<td>
<p>The number of samples to remove from the start of the chain as burnin</p>
</td></tr>
<tr><td><code id="makeplot.treespace_+3A_n.points">n.points</code></td>
<td>
<p>The number of points on each plot</p>
</td></tr>
<tr><td><code id="makeplot.treespace_+3A_fill.color">fill.color</code></td>
<td>
<p>The name of any column in your parameter file that you would like to use as a fill colour for the points of the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two ggplot objects: one plots the points in treespace, the other shows a heatmap of the same points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fungus)

p &lt;- makeplot.treespace(fungus, burnin = 20, fill.color = 'LnL')
# Treespace plot for all the fungus data

# NB: these data indicate significant problems: the chains are sampling very 
# different parts of tree space.
#
# View the points plotted in treespace (these data indicate significant problems)
p$treespace.points.plot

# View the heatmap of the same data
# Note that this data is so pathologically bad that the heatmap is not
# very useful. It is more useful on better behaved datasets
p$treespace.heatmap

# we can also plot different parameters as the fill colour.
# e.g. we can plot the first two fungus chains with likelihood as the fill
makeplot.treespace(fungus[1:2], burnin = 100, fill.color = 'LnL')

# or with tree length as the fill
makeplot.treespace(fungus[1:2], burnin = 100, fill.color = 'TL')

# you can colour the plot with any parameter in your ptable
# to see which parameters you have you can simply do this:
names(fungus[[1]]$ptable)

## End(Not run)
</code></pre>

<hr>
<h2 id='parse.clades'>Rename clades for easy recall</h2><span id='topic+parse.clades'></span>

<h3>Description</h3>

<p>Converts a list of clades (e.g., &quot;1 2 3 4&quot; as a clade) and
returns a list of parsed clades, converting numbers to names using a set of trees.
Called internally by the slide and cumulative analyses, not user-facing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse.clades(clades, treelist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse.clades_+3A_clades">clades</code></td>
<td>
<p>A list of clades, as in the first column of a cladetable in an rwty.slide or rwty.cumulative object.</p>
</td></tr>
<tr><td><code id="parse.clades_+3A_treelist">treelist</code></td>
<td>
<p>A list of trees, used for getting tip names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output A list of clades with parsed tip names
</p>

<hr>
<h2 id='print.rwty.chain'>Function for printing rwty.chain objects</h2><span id='topic+print.rwty.chain'></span>

<h3>Description</h3>

<p>This function is automatically called when printing a rwty.chain object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rwty.chain'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.rwty.chain_+3A_x">x</code></td>
<td>
<p>A rwty.chain object</p>
</td></tr>
<tr><td><code id="print.rwty.chain_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed on to next function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary of the contents of the chain
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fungus)
fungus$Fungus.Run1
</code></pre>

<hr>
<h2 id='salamanders'>MrBayes output from analysis of Williams et al. data</h2><span id='topic+salamanders'></span>

<h3>Description</h3>

<p>This is the output from a MrBayes run of 25,000,000 generations using the analysis settings from the original .nex files.  
Sampling is one tree per 100,000 generations.  Data is from alignments of three separate sequences, two chains per alignment, each with its associated log file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(salamanders)
</code></pre>


<h3>Format</h3>

<p>A data frame with six chains (two each from three separate alignments) of 251 phylogenetic trees and associated likelihood and parameter values.</p>


<h3>References</h3>

<p>Study reference: Williams JS, Niedzwiecki JH, Weisrock DW (2013) Species tree reconstruction of a poorly resolved clade of salamanders (Ambystomatidae) using multiple nuclear loci. Molecular Phylogenetics and Evolution 68(3): 671-682. http://dx.doi.org/10.1016/j.ympev.2013.04.013
</p>
<p>Dryad reference: Williams JS, Niedzwiecki JH, Weisrock DW (2013) Data from: Species tree reconstruction of a poorly resolved clade of salamanders (Ambystomatidae) using multiple nuclear loci. Dryad Digital Repository. http://dx.doi.org/10.5061/dryad.2gq14
</p>
<p>http://datadryad.org/resource/doi:10.5061/dryad.2gq14
</p>

<hr>
<h2 id='slide.freq'>Sliding window measurements of clade split frequencies.</h2><span id='topic+slide.freq'></span>

<h3>Description</h3>

<p>This function takes sliding windows of a specified length over an MCMC chain
and calculates the split frequency of clades within that window.  It
allows users to see whether the chain is visiting different areas of treespace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slide.freq(chains, burnin = 0, window.size = 20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slide.freq_+3A_chains">chains</code></td>
<td>
<p>A list of rwty.chain objects.</p>
</td></tr>
<tr><td><code id="slide.freq_+3A_burnin">burnin</code></td>
<td>
<p>The number of trees to eliminate as burnin. Defaults to zero.</p>
</td></tr>
<tr><td><code id="slide.freq_+3A_window.size">window.size</code></td>
<td>
<p>The number of trees to include in each window (note, specified as a number of sampled trees, not a number of generations)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of rwty.slide objects, one per chain in the input list of chains.
Each rwty.slide object contains the frequencies of clades in the sliding
windows, and a translation table that converts clade groupings to factors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fungus)
slide.data &lt;- slide.freq(fungus, burnin=20)\

## End(Not run)
</code></pre>

<hr>
<h2 id='topological.approx.ess'>Calculate the approximate Effective Sample Size (ESS) of tree topologies</h2><span id='topic+topological.approx.ess'></span>

<h3>Description</h3>

<p>This function takes a list of rwty.chain objects, and calculates the
pseudo ESS of the trees from each chain, after removing burnin.
The calculation uses the autocorrelation among squared topological distances between
trees to calculate an approximate ESS of tree topologies for each chain.
NB this function requires the calculation of many many
tree distances, so can take some time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topological.approx.ess(chains, burnin = 0, max.sampling.interval = 100,
  treedist = "PD", use.all.samples = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="topological.approx.ess_+3A_chains">chains</code></td>
<td>
<p>A list of rwty.chain objects.</p>
</td></tr>
<tr><td><code id="topological.approx.ess_+3A_burnin">burnin</code></td>
<td>
<p>The number of trees to eliminate as burnin</p>
</td></tr>
<tr><td><code id="topological.approx.ess_+3A_max.sampling.interval">max.sampling.interval</code></td>
<td>
<p>The largest sampling interval you want to use to calculate the ESS. Every sampling interval up to and including this number will be sampled. Higher is better, but also slower. In general, setting this number to 100 (the default) should be fine for most cases. However, if you get an upper bound on the ESS estimate (i.e. ESS&lt;x) rather than a point estimate (i.e. ESS = x) then that indicates a higher max.sampling.interval would be better, because the algorithm could not find the asymptote on the autocorrelation plot with the current max.sampling.interval.</p>
</td></tr>
<tr><td><code id="topological.approx.ess_+3A_treedist">treedist</code></td>
<td>
<p>the type of tree distance metric to use, can be 'PD' for path distance or 'RF' for Robinson Foulds distance</p>
</td></tr>
<tr><td><code id="topological.approx.ess_+3A_use.all.samples">use.all.samples</code></td>
<td>
<p>(TRUE/FALSE). Whether to calculate autocorrelation from all possible pairs of trees in your chain. The default is FALSE, in which case 500 samples are taken at each sampling interval. Setting this to TRUE will give you slightly more accurate ESS estimates, at the cost of potentially much longer execution times.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one row per chain, and columns describing the
approximate ESS and the name of the chain.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fungus)
topological.approx.ess(fungus, burnin = 20)

## End(Not run)
</code></pre>

<hr>
<h2 id='topological.autocorr'>Calculate data for autocorrelation plots of tree topologies from MCMC analyses</h2><span id='topic+topological.autocorr'></span>

<h3>Description</h3>

<p>This function takes a list of rwty.chain objects, and calculates the
mean phylogenetic distance at a series of roughly even sampling intervals.
In really well behaved MCMC analyses, the mean distance will stay constant
as the sampling interval increases. If there is autocorrelation, it will 
increase as the sampling interval increases, and is expected to level
off when the autocorrelation decreases to zero. The function calculates
path distances, though other distances could also be employed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topological.autocorr(chains, burnin = 0, max.sampling.interval = NA,
  autocorr.intervals = 100, squared = FALSE, treedist = "PD",
  use.all.samples = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="topological.autocorr_+3A_chains">chains</code></td>
<td>
<p>A list of rwty.chain objects.</p>
</td></tr>
<tr><td><code id="topological.autocorr_+3A_burnin">burnin</code></td>
<td>
<p>The number of trees to eliminate as burnin</p>
</td></tr>
<tr><td><code id="topological.autocorr_+3A_max.sampling.interval">max.sampling.interval</code></td>
<td>
<p>The largest sampling interval for which you want to calculate the mean distance between pairs of trees (default is 10 percent of the length of the list of trees).</p>
</td></tr>
<tr><td><code id="topological.autocorr_+3A_autocorr.intervals">autocorr.intervals</code></td>
<td>
<p>The number of sampling intervals to use. These will be spaced evenly between 1 and the max.sampling.interval</p>
</td></tr>
<tr><td><code id="topological.autocorr_+3A_squared">squared</code></td>
<td>
<p>TRUE/FALSE use squared tree distances (necessary to calculate approximate ESS)</p>
</td></tr>
<tr><td><code id="topological.autocorr_+3A_treedist">treedist</code></td>
<td>
<p>the type of tree distance metric to use, can be 'PD' for path distance or 'RF' for Robinson Foulds distance</p>
</td></tr>
<tr><td><code id="topological.autocorr_+3A_use.all.samples">use.all.samples</code></td>
<td>
<p>(TRUE/FALSE). Whether to calculate autocorrelation from all possible pairs of trees in your chain. The default is FALSE, in which case 500 samples are taken at each sampling interval. This is sufficient to get reasonably accurate estimates of the approximate ESS. Setting this to TRUE will give you slightly more accurate ESS estimates, at the cost of potentially much longer execution times.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one row per sampling interval, per chain. 
The first column is the sampling interval. The second column is the mean 
path distance between pairs of trees from that sampling interval. The third
column is the chain ID.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fungus)
topological.autocorr(fungus, burnin = 20)

## End(Not run)
</code></pre>

<hr>
<h2 id='topological.pseudo.ess'>Calculate the pseudo Effective Sample Size (ESS) of tree topologies</h2><span id='topic+topological.pseudo.ess'></span>

<h3>Description</h3>

<p>This function takes a list of rwty.chain objects, and calculates the
pseudo ESS of the trees from each chain, after removing burnin. 
Each caulcation is repeated n times, where in each replicate a random
tree from the chain is chosen as a 'focal' tree. The calculation works
by calculating the path distance of each tree in the chain
from the focal tree, and calculating the ESS of the resulting vector
of phylogenetic distances using the effectiveSize function from the 
coda package. NB this function requires the calculation of many many
tree distances, so can take some time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topological.pseudo.ess(chains, burnin = 0, n = 20, treedist = "PD")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="topological.pseudo.ess_+3A_chains">chains</code></td>
<td>
<p>A list of rwty.chain objects.</p>
</td></tr>
<tr><td><code id="topological.pseudo.ess_+3A_burnin">burnin</code></td>
<td>
<p>The number of trees to eliminate as burnin</p>
</td></tr>
<tr><td><code id="topological.pseudo.ess_+3A_n">n</code></td>
<td>
<p>The number of replicate analyses to do</p>
</td></tr>
<tr><td><code id="topological.pseudo.ess_+3A_treedist">treedist</code></td>
<td>
<p>the type of tree distance metric to use, can be 'PD' for path distance or 'RF' for Robinson Foulds distance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one row per chain, and columns describing the
median ESS, the upper and lower 95
replicates performed, and the name of the chain.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fungus)
topological.pseudo.ess(fungus, burnin = 20, n = 20)

## End(Not run)
</code></pre>

<hr>
<h2 id='tree.dist.matrix'>Tree distance matrix calculation</h2><span id='topic+tree.dist.matrix'></span>

<h3>Description</h3>

<p>This function takes a list of trees and returns a distance matrix
populated with Robinson-Foulds tree distances between all trees
in the list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree.dist.matrix(trees)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tree.dist.matrix_+3A_trees">trees</code></td>
<td>
<p>a multiPhylo object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RF A distance matrix of RF distances
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fungus)
tree.dist.matrix(fungus$Fungus.Run1$trees)

## End(Not run)
</code></pre>

<hr>
<h2 id='treespace'>MDS scaling of treespace for a single tree list.</h2><span id='topic+treespace'></span>

<h3>Description</h3>

<p>This function constructs a distance matrix from a list of trees
and uses multi-dimensional scaling to collapse it to a two-
dimensional tree space for plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treespace(chains, n.points = 100, burnin = 0, fill.color = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treespace_+3A_chains">chains</code></td>
<td>
<p>A list of 1 or more rwty.chain objects.</p>
</td></tr>
<tr><td><code id="treespace_+3A_n.points">n.points</code></td>
<td>
<p>The minimum number of points you want in your plot.</p>
</td></tr>
<tr><td><code id="treespace_+3A_burnin">burnin</code></td>
<td>
<p>The number of trees to eliminate as burnin. Default is zero.</p>
</td></tr>
<tr><td><code id="treespace_+3A_fill.color">fill.color</code></td>
<td>
<p>The name of the column from the log table that that you would like to use to colour the points in the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the points and a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fungus)
treespace(fungus, n.points=50, burnin=20, fill.color="LnL")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
