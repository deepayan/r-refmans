<!DOCTYPE html><html><head><title>Help for package qgg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qgg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acc'><p>Compute prediction accuracy for a quantitative or binary trait</p></a></li>
<li><a href='#adjLD'><p>LD pruning of summary statistics</p></a></li>
<li><a href='#adjLDStat'><p>Check concordance between marker effect and sparse LD matrix.</p></a></li>
<li><a href='#adjStat'><p>Adjustment of marker summary statistics using clumping and thresholding</p></a></li>
<li><a href='#adjustB'><p>Adjust B-values</p></a></li>
<li><a href='#adjustMapLD'><p>Adjust Linkage Disequilibrium (LD) Using Map Information</p></a></li>
<li><a href='#auc'><p>Compute AUC</p></a></li>
<li><a href='#computeROC'><p>Compute Receiver Operating Curve statistics</p></a></li>
<li><a href='#gbayes'><p>Bayesian linear regression models</p></a></li>
<li><a href='#gblup'><p>Compute Genomic BLUP values</p></a></li>
<li><a href='#getG'><p>Get elements from genotype matrix stored in PLINK bedfiles</p></a></li>
<li><a href='#getGRM'><p>Extract elements from genomic relationship matrix (GRM) stored on disk</p></a></li>
<li><a href='#getLD'><p>Retrieve Sparse LD Matrix for a Given Chromosome</p></a></li>
<li><a href='#getLDsets'><p>Get marker LD sets</p></a></li>
<li><a href='#getMap'><p>Retrieve the map for specified rsids on a given chromosome.</p></a></li>
<li><a href='#getMarkers'><p>Retrieve marker rsids in a specified genome region.</p></a></li>
<li><a href='#getPos'><p>Retrieve the positions for specified rsids on a given chromosome.</p></a></li>
<li><a href='#getSparseLD'><p>Extract Sparse Linkage Disequilibrium (LD) Information</p></a></li>
<li><a href='#gfilter'><p>Filter genetic marker data based on different quality measures</p></a></li>
<li><a href='#glma'><p>Single marker association analysis using linear models or linear mixed models</p></a></li>
<li><a href='#gmap'><p>Finemapping using Bayesian Linear Regression Models</p></a></li>
<li><a href='#gprep'><p>Prepare genotype data for all statistical analyses</p></a></li>
<li><a href='#greml'><p>Genomic rescticted maximum likelihood (GREML) analysis</p></a></li>
<li><a href='#grm'><p>Computing the genomic relationship matrix (GRM)</p></a></li>
<li><a href='#gscore'><p>Genomic scoring based on single marker summary statistics</p></a></li>
<li><a href='#gsea'><p>Gene set enrichment analysis</p></a></li>
<li><a href='#gsim'><p>Genomic simulation</p></a></li>
<li><a href='#gsolve'><p>Solve linear mixed model equations</p></a></li>
<li><a href='#hwe'><p>Perform Hardy Weinberg Equilibrium Test</p></a></li>
<li><a href='#ldsc'><p>LD score regression</p></a></li>
<li><a href='#ldscore'><p>Compute LD (Linkage Disequilibrium) Scores for a Given Chromosome.</p></a></li>
<li><a href='#mapSets'><p>Map Sets to RSIDs</p></a></li>
<li><a href='#mapStat'><p>Map marker summary statistics to Glist</p></a></li>
<li><a href='#mergeGRM'><p>Merge multiple GRMlist objects</p></a></li>
<li><a href='#mtadj'><p>Adjustment of marker effects using correlated trait information</p></a></li>
<li><a href='#plotBayes'><p>Plot fit from gbayes</p></a></li>
<li><a href='#plotForest'><p>Forest plot</p></a></li>
<li><a href='#plotLD'><p>Plot LD Matrix</p></a></li>
<li><a href='#plotROC'><p>Plot Receiver Operating Curves</p></a></li>
<li><a href='#predict_auc_mt_cc'><p>Expected AUC for prediction of a binary trait using information on correlated binary trait</p></a></li>
<li><a href='#predict_auc_mt_continuous'><p>Expected AUC for prediction of a binary trait using information on a correlated continuous trait</p></a></li>
<li><a href='#predict_auc_st'><p>Expected AUC for prediction of a binary trait</p></a></li>
<li><a href='#predict_r2_mt'><p>Expected R2 for multiple trait prediction of continuous traits</p></a></li>
<li><a href='#predict_r2_st'><p>Expected R2 for single trait prediction of a continuous trait</p></a></li>
<li><a href='#qcStat'><p>Quality Control of Marker Summary Statistics</p></a></li>
<li><a href='#rnag'><p>Compute Nagelkerke R2</p></a></li>
<li><a href='#splitWithOverlap'><p>Split Vector with Overlapping Segments</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Tools for Quantitative Genetic Analyses</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-06</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Soerensen &lt;peter.sorensen@r-qgg.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an infrastructure for efficient processing of large-scale genetic and phenotypic data including core functions for: 1) fitting linear mixed models, 2) constructing marker-based genomic relationship matrices, 3) estimating genetic parameters (heritability and correlation), 4) performing genomic prediction and genetic risk profiling, and 5) single or multi-marker association analyses.
    Rohde et al. (2019) &lt;<a href="https://doi.org/10.1101%2F503631">doi:10.1101/503631</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.5), data.table, parallel, statmod, stats,
MCMCpack, MASS, coda, corpcor</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/psoerensen/qgg">https://github.com/psoerensen/qgg</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/psoerensen/qgg/issues">https://github.com/psoerensen/qgg/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-07 11:03:11 UTC; au223366</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Soerensen [aut, cre],
  Palle Duun Rohde [aut],
  Izel Fourie Soerensen [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-07 11:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='acc'>Compute prediction accuracy for a quantitative or binary trait</h2><span id='topic+acc'></span>

<h3>Description</h3>

<p>Compute prediction accuracy for a quantitative or binary trait
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acc(yobs = NULL, ypred = NULL, typeoftrait = "quantitative")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acc_+3A_yobs">yobs</code></td>
<td>
<p>is a vector of observed phenotypes</p>
</td></tr>
<tr><td><code id="acc_+3A_ypred">ypred</code></td>
<td>
<p>is a vector of predicted phenotypes</p>
</td></tr>
<tr><td><code id="acc_+3A_typeoftrait">typeoftrait</code></td>
<td>
<p>is a character with possible values &quot;binary&quot; or &quot;quantitative&quot; (default)</p>
</td></tr>
</table>

<hr>
<h2 id='adjLD'>LD pruning of summary statistics</h2><span id='topic+adjLD'></span>

<h3>Description</h3>

<p>Perform LD pruning of summary statistics before they are used in gene set enrichment analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjLD(
  stat = NULL,
  Glist = NULL,
  chr = NULL,
  statistics = "p-value",
  r2 = 0.9,
  ldSets = NULL,
  threshold = 1,
  method = "pruning"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjLD_+3A_stat">stat</code></td>
<td>
<p>A data frame with marker summary statistics. Ensure that it is in the correct format.</p>
</td></tr>
<tr><td><code id="adjLD_+3A_glist">Glist</code></td>
<td>
<p>List of information about the genotype matrix stored on disk.</p>
</td></tr>
<tr><td><code id="adjLD_+3A_chr">chr</code></td>
<td>
<p>Chromosome(s) being processed.</p>
</td></tr>
<tr><td><code id="adjLD_+3A_statistics">statistics</code></td>
<td>
<p>Specify what type of statistics (&quot;b&quot;, &quot;z&quot;, or &quot;p-value&quot;) is being processed. Default is &quot;p-value&quot;.</p>
</td></tr>
<tr><td><code id="adjLD_+3A_r2">r2</code></td>
<td>
<p>Threshold used in the clumping/pruning procedure. Default is 0.9.</p>
</td></tr>
<tr><td><code id="adjLD_+3A_ldsets">ldSets</code></td>
<td>
<p>List of marker sets - names correspond to row names in 'stat'.</p>
</td></tr>
<tr><td><code id="adjLD_+3A_threshold">threshold</code></td>
<td>
<p>P-value threshold used in LD pruning.</p>
</td></tr>
<tr><td><code id="adjLD_+3A_method">method</code></td>
<td>
<p>Method used in adjustment for linkage disequilibrium. Options are &quot;pruning&quot; or &quot;clumping&quot;. Default is &quot;pruning&quot;.</p>
</td></tr>
</table>

<hr>
<h2 id='adjLDStat'>Check concordance between marker effect and sparse LD matrix.</h2><span id='topic+adjLDStat'></span>

<h3>Description</h3>

<p>Check concordance between predicted and observed marker effect. Marker effect is predicted based on sparse LD matrix in Glist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjLDStat(
  stat = NULL,
  Glist = NULL,
  chr = NULL,
  region = NULL,
  msize = NULL,
  threshold = 1e-05,
  overlap = NULL,
  niter = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjLDStat_+3A_stat">stat</code></td>
<td>
<p>data frame with marker summary statistics (see required format above)</p>
</td></tr>
<tr><td><code id="adjLDStat_+3A_glist">Glist</code></td>
<td>
<p>list of information about genotype matrix stored on disk</p>
</td></tr>
<tr><td><code id="adjLDStat_+3A_chr">chr</code></td>
<td>
<p>chromosome for which marker effect is checked</p>
</td></tr>
<tr><td><code id="adjLDStat_+3A_region">region</code></td>
<td>
<p>genome region (in base pairs) for which marker effect is checked</p>
</td></tr>
<tr><td><code id="adjLDStat_+3A_msize">msize</code></td>
<td>
<p>is the number of markers used in the prediction</p>
</td></tr>
<tr><td><code id="adjLDStat_+3A_threshold">threshold</code></td>
<td>
<p>p-value threshold used for chisquare test for difference between observed and predicted marker effects</p>
</td></tr>
<tr><td><code id="adjLDStat_+3A_overlap">overlap</code></td>
<td>
<p>is the number of markers overlapping between adjacent genome region</p>
</td></tr>
<tr><td><code id="adjLDStat_+3A_niter">niter</code></td>
<td>
<p>is the number of iteration used for detecting outliers</p>
</td></tr>
</table>

<hr>
<h2 id='adjStat'>Adjustment of marker summary statistics using clumping and thresholding</h2><span id='topic+adjStat'></span>

<h3>Description</h3>

<p>Adjust marker summary statistics using linkage disequilibrium information from Glist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjStat(
  stat = NULL,
  Glist = NULL,
  chr = NULL,
  statistics = "b",
  r2 = 0.9,
  ldSets = NULL,
  threshold = 1,
  header = NULL,
  method = "pruning"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjStat_+3A_stat">stat</code></td>
<td>
<p>A data frame with marker summary statistics (see required format above).</p>
</td></tr>
<tr><td><code id="adjStat_+3A_glist">Glist</code></td>
<td>
<p>List of information about genotype matrix stored on disk.</p>
</td></tr>
<tr><td><code id="adjStat_+3A_chr">chr</code></td>
<td>
<p>Chromosome(s) being processed.</p>
</td></tr>
<tr><td><code id="adjStat_+3A_statistics">statistics</code></td>
<td>
<p>Specify what type of statistics (&quot;b&quot; or &quot;z&quot;) is being processed. Default is &quot;b&quot;.</p>
</td></tr>
<tr><td><code id="adjStat_+3A_r2">r2</code></td>
<td>
<p>Threshold used in clumping/pruning procedure. Default is 0.9.</p>
</td></tr>
<tr><td><code id="adjStat_+3A_ldsets">ldSets</code></td>
<td>
<p>List of marker sets - names correspond to row names in 'stat'.</p>
</td></tr>
<tr><td><code id="adjStat_+3A_threshold">threshold</code></td>
<td>
<p>P-value threshold used in clumping procedure. Default is 1.</p>
</td></tr>
<tr><td><code id="adjStat_+3A_header">header</code></td>
<td>
<p>Character vector with column names to be excluded in the LD adjustment.</p>
</td></tr>
<tr><td><code id="adjStat_+3A_method">method</code></td>
<td>
<p>Method used in adjustment for linkage disequilibrium. Default is &quot;clumping&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Required input format for summary statistics:
</p>
<p>stat can be a data.frame(rsids, chr, pos, ea, nea, eaf, b, seb, stat, p, n) (single trait)
</p>
<p>stat can be a list(marker=(rsids, chr, pos, ea, nea, eaf), b, seb, stat, p, n) (multiple trait)
</p>
<p>For details about the summary statistics format, see the main function description.
</p>


<h3>Author(s)</h3>

<p>Peter Soerensen
</p>

<hr>
<h2 id='adjustB'>Adjust B-values</h2><span id='topic+adjustB'></span>

<h3>Description</h3>

<p>This function adjusts the B-values based on the LD structure and other parameters.
The adjustment is done in subsets, and a plot of observed vs. predicted values is produced for each subset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjustB(
  b = NULL,
  LD = NULL,
  msize = NULL,
  overlap = NULL,
  shrink = 0.001,
  threshold = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjustB_+3A_b">b</code></td>
<td>
<p>A numeric vector containing the B-values to be adjusted. If NULL (default), no adjustments are made.</p>
</td></tr>
<tr><td><code id="adjustB_+3A_ld">LD</code></td>
<td>
<p>A matrix representing the linkage disequilibrium (LD) structure.</p>
</td></tr>
<tr><td><code id="adjustB_+3A_msize">msize</code></td>
<td>
<p>An integer specifying the size of the subsets.</p>
</td></tr>
<tr><td><code id="adjustB_+3A_overlap">overlap</code></td>
<td>
<p>An integer specifying the overlap size between consecutive subsets.</p>
</td></tr>
<tr><td><code id="adjustB_+3A_shrink">shrink</code></td>
<td>
<p>A numeric value used for shrinkage. Default is 0.001.</p>
</td></tr>
<tr><td><code id="adjustB_+3A_threshold">threshold</code></td>
<td>
<p>A numeric value specifying the threshold. Default is 1e-8.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the adjusted B-values.
</p>

<hr>
<h2 id='adjustMapLD'>Adjust Linkage Disequilibrium (LD) Using Map Information</h2><span id='topic+adjustMapLD'></span>

<h3>Description</h3>

<p>Adjusts the linkage disequilibrium (LD) values based on map information, effective population size,
and sample size used for map construction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjustMapLD(LD = NULL, map = NULL, neff = 11600, nmap = 186, threshold = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjustMapLD_+3A_ld">LD</code></td>
<td>
<p>A matrix representing the linkage disequilibrium (LD) structure.</p>
</td></tr>
<tr><td><code id="adjustMapLD_+3A_map">map</code></td>
<td>
<p>A numeric vector containing the map information.</p>
</td></tr>
<tr><td><code id="adjustMapLD_+3A_neff">neff</code></td>
<td>
<p>An integer representing the effective population size. Default is 11600.</p>
</td></tr>
<tr><td><code id="adjustMapLD_+3A_nmap">nmap</code></td>
<td>
<p>An integer representing the sample size used for map construction. Default is 186.</p>
</td></tr>
<tr><td><code id="adjustMapLD_+3A_threshold">threshold</code></td>
<td>
<p>A numeric value specifying the threshold for setting LD to zero. Currently unused in the function. Default is 0.001.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix where each value is the adjusted LD based on the input map, effective population size, and map construction sample size.
</p>

<hr>
<h2 id='auc'>Compute AUC</h2><span id='topic+auc'></span>

<h3>Description</h3>

<p>Compute Area Under the Curve (AUC)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auc(yobs = NULL, ypred = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auc_+3A_yobs">yobs</code></td>
<td>
<p>is a vector of observed phenotypes</p>
</td></tr>
<tr><td><code id="auc_+3A_ypred">ypred</code></td>
<td>
<p>is a vector of predicted phenotypes</p>
</td></tr>
</table>

<hr>
<h2 id='computeROC'>Compute Receiver Operating Curve statistics</h2><span id='topic+computeROC'></span>

<h3>Description</h3>

<p>Compute ROC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeROC(yobs = NULL, ypred = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeROC_+3A_yobs">yobs</code></td>
<td>
<p>vector of observed phenotype</p>
</td></tr>
<tr><td><code id="computeROC_+3A_ypred">ypred</code></td>
<td>
<p>vector of predicted phenotype</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Palle Duun Rohde
</p>

<hr>
<h2 id='gbayes'>Bayesian linear regression models</h2><span id='topic+gbayes'></span>

<h3>Description</h3>

<p>Bayesian linear regression (BLR) models:
</p>
<p>- unified mapping of genetic variants, estimation of genetic parameters 
(e.g. heritability) and prediction of disease risk) 
</p>
<p>- handles different genetic architectures (few large, many small effects)
</p>
<p>- scale to large data (e.g. sparse LD)
</p>
<p>In the Bayesian multiple regression model the posterior density of the 
model parameters depend on the likelihood of the data given 
the parameters and a prior probability for the model parameters
</p>
<p>The prior density of marker effects defines whether the model will 
induce variable selection and shrinkage or shrinkage only. 
Also, the choice of prior will define the extent and type of shrinkage induced.
Ideally the choice of prior for the marker effect should reflect the genetic 
architecture of the trait, and will vary (perhaps a lot) across traits.
</p>
<p>The following prior distributions are provided:
</p>
<p>Bayes N: Assigning a Gaussian prior to marker effects implies that the posterior means are the 
BLUP estimates (same as Ridge Regression).
</p>
<p>Bayes L: Assigning a double-exponential or Laplace prior is the density used in 
the Bayesian LASSO
</p>
<p>Bayes A: similar to ridge regression but t-distribution prior (rather than Gaussian) 
for the marker effects ; variance comes from an inverse-chi-square distribution instead of being fixed. Estimation 
via Gibbs sampling. 
</p>
<p>Bayes C: uses a “rounded spike” (low-variance Gaussian) at origin many small 
effects can contribute to polygenic component, reduces the dimensionality of 
the model (makes Gibbs sampling feasible). 
</p>
<p>Bayes R: Hierarchical Bayesian mixture model with 4 Gaussian components, with 
variances scaled by 0, 0.0001 , 0.001 , and 0.01 .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbayes(
  y = NULL,
  X = NULL,
  W = NULL,
  stat = NULL,
  covs = NULL,
  trait = NULL,
  fit = NULL,
  Glist = NULL,
  chr = NULL,
  rsids = NULL,
  b = NULL,
  bm = NULL,
  seb = NULL,
  LD = NULL,
  n = NULL,
  formatLD = "dense",
  vg = NULL,
  vb = NULL,
  ve = NULL,
  ssg_prior = NULL,
  ssb_prior = NULL,
  sse_prior = NULL,
  lambda = NULL,
  scaleY = TRUE,
  h2 = NULL,
  pi = 0.001,
  updateB = TRUE,
  updateG = TRUE,
  updateE = TRUE,
  updatePi = TRUE,
  adjustE = TRUE,
  models = NULL,
  nug = 4,
  nub = 4,
  nue = 4,
  verbose = FALSE,
  msize = 100,
  mask = NULL,
  GRMlist = NULL,
  ve_prior = NULL,
  vg_prior = NULL,
  tol = 0.001,
  nit = 100,
  nburn = 0,
  nit_local = NULL,
  nit_global = NULL,
  method = "mixed",
  algorithm = "mcmc"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbayes_+3A_y">y</code></td>
<td>
<p>is a vector or matrix of phenotypes</p>
</td></tr>
<tr><td><code id="gbayes_+3A_x">X</code></td>
<td>
<p>is a matrix of covariates</p>
</td></tr>
<tr><td><code id="gbayes_+3A_w">W</code></td>
<td>
<p>is a matrix of centered and scaled genotypes</p>
</td></tr>
<tr><td><code id="gbayes_+3A_stat">stat</code></td>
<td>
<p>dataframe with marker summary statistics</p>
</td></tr>
<tr><td><code id="gbayes_+3A_covs">covs</code></td>
<td>
<p>is a list of summary statistics (output from internal cvs function)</p>
</td></tr>
<tr><td><code id="gbayes_+3A_trait">trait</code></td>
<td>
<p>is an integer used for selection traits in covs object</p>
</td></tr>
<tr><td><code id="gbayes_+3A_fit">fit</code></td>
<td>
<p>is a list of results from gbayes</p>
</td></tr>
<tr><td><code id="gbayes_+3A_glist">Glist</code></td>
<td>
<p>list of information about genotype matrix stored on disk</p>
</td></tr>
<tr><td><code id="gbayes_+3A_chr">chr</code></td>
<td>
<p>is the chromosome for which to fit BLR models</p>
</td></tr>
<tr><td><code id="gbayes_+3A_rsids">rsids</code></td>
<td>
<p>is a character vector of rsids</p>
</td></tr>
<tr><td><code id="gbayes_+3A_b">b</code></td>
<td>
<p>is a vector or matrix of marginal marker effects</p>
</td></tr>
<tr><td><code id="gbayes_+3A_bm">bm</code></td>
<td>
<p>is a vector or matrix of adjusted marker effects for the BLR model</p>
</td></tr>
<tr><td><code id="gbayes_+3A_seb">seb</code></td>
<td>
<p>is a vector or matrix of standard error of marginal effects</p>
</td></tr>
<tr><td><code id="gbayes_+3A_ld">LD</code></td>
<td>
<p>is a list with sparse LD matrices</p>
</td></tr>
<tr><td><code id="gbayes_+3A_n">n</code></td>
<td>
<p>is a scalar or vector of number of observations for each trait</p>
</td></tr>
<tr><td><code id="gbayes_+3A_formatld">formatLD</code></td>
<td>
<p>is a character specifying LD format (formatLD=&quot;dense&quot; is default)</p>
</td></tr>
<tr><td><code id="gbayes_+3A_vg">vg</code></td>
<td>
<p>is a scalar or matrix of genetic (co)variances</p>
</td></tr>
<tr><td><code id="gbayes_+3A_vb">vb</code></td>
<td>
<p>is a scalar or matrix of marker (co)variances</p>
</td></tr>
<tr><td><code id="gbayes_+3A_ve">ve</code></td>
<td>
<p>is a scalar or matrix of residual (co)variances</p>
</td></tr>
<tr><td><code id="gbayes_+3A_ssg_prior">ssg_prior</code></td>
<td>
<p>is a scalar or matrix of prior genetic (co)variances</p>
</td></tr>
<tr><td><code id="gbayes_+3A_ssb_prior">ssb_prior</code></td>
<td>
<p>is a scalar or matrix of prior marker (co)variances</p>
</td></tr>
<tr><td><code id="gbayes_+3A_sse_prior">sse_prior</code></td>
<td>
<p>is a scalar or matrix of prior residual (co)variances</p>
</td></tr>
<tr><td><code id="gbayes_+3A_lambda">lambda</code></td>
<td>
<p>is a vector or matrix of lambda values</p>
</td></tr>
<tr><td><code id="gbayes_+3A_scaley">scaleY</code></td>
<td>
<p>is a logical; if TRUE y is centered and scaled</p>
</td></tr>
<tr><td><code id="gbayes_+3A_h2">h2</code></td>
<td>
<p>is the trait heritability</p>
</td></tr>
<tr><td><code id="gbayes_+3A_pi">pi</code></td>
<td>
<p>is the proportion of markers in each marker variance class (e.g. pi=c(0.999,0.001),used if method=&quot;ssvs&quot;)</p>
</td></tr>
<tr><td><code id="gbayes_+3A_updateb">updateB</code></td>
<td>
<p>is a logical for updating marker (co)variances</p>
</td></tr>
<tr><td><code id="gbayes_+3A_updateg">updateG</code></td>
<td>
<p>is a logical for updating genetic (co)variances</p>
</td></tr>
<tr><td><code id="gbayes_+3A_updatee">updateE</code></td>
<td>
<p>is a logical for updating residual (co)variances</p>
</td></tr>
<tr><td><code id="gbayes_+3A_updatepi">updatePi</code></td>
<td>
<p>is a logical for updating pi</p>
</td></tr>
<tr><td><code id="gbayes_+3A_adjuste">adjustE</code></td>
<td>
<p>is a logical for adjusting residual variance</p>
</td></tr>
<tr><td><code id="gbayes_+3A_models">models</code></td>
<td>
<p>is a list structure with models evaluated in bayesC</p>
</td></tr>
<tr><td><code id="gbayes_+3A_nug">nug</code></td>
<td>
<p>is a scalar or vector of prior degrees of freedom for prior genetic (co)variances</p>
</td></tr>
<tr><td><code id="gbayes_+3A_nub">nub</code></td>
<td>
<p>is a scalar or vector of prior degrees of freedom for marker (co)variances</p>
</td></tr>
<tr><td><code id="gbayes_+3A_nue">nue</code></td>
<td>
<p>is a scalar or vector of prior degrees of freedom for prior residual (co)variances</p>
</td></tr>
<tr><td><code id="gbayes_+3A_verbose">verbose</code></td>
<td>
<p>is a logical; if TRUE it prints more details during iteration</p>
</td></tr>
<tr><td><code id="gbayes_+3A_msize">msize</code></td>
<td>
<p>number of markers used in compuation of sparseld</p>
</td></tr>
<tr><td><code id="gbayes_+3A_mask">mask</code></td>
<td>
<p>is a vector or matrix of TRUE/FALSE specifying if marker should be ignored</p>
</td></tr>
<tr><td><code id="gbayes_+3A_grmlist">GRMlist</code></td>
<td>
<p>is a list providing information about GRM matrix stored in binary files on disk</p>
</td></tr>
<tr><td><code id="gbayes_+3A_ve_prior">ve_prior</code></td>
<td>
<p>is a scalar or matrix of prior residual (co)variances</p>
</td></tr>
<tr><td><code id="gbayes_+3A_vg_prior">vg_prior</code></td>
<td>
<p>is a scalar or matrix of prior genetic (co)variances</p>
</td></tr>
<tr><td><code id="gbayes_+3A_tol">tol</code></td>
<td>
<p>is tolerance, i.e. convergence criteria used in gbayes</p>
</td></tr>
<tr><td><code id="gbayes_+3A_nit">nit</code></td>
<td>
<p>is the number of iterations</p>
</td></tr>
<tr><td><code id="gbayes_+3A_nburn">nburn</code></td>
<td>
<p>is the number of burnin iterations</p>
</td></tr>
<tr><td><code id="gbayes_+3A_nit_local">nit_local</code></td>
<td>
<p>is the number of local iterations</p>
</td></tr>
<tr><td><code id="gbayes_+3A_nit_global">nit_global</code></td>
<td>
<p>is the number of global iterations</p>
</td></tr>
<tr><td><code id="gbayes_+3A_method">method</code></td>
<td>
<p>specifies the methods used (method=&quot;bayesN&quot;,&quot;bayesA&quot;,&quot;bayesL&quot;,&quot;bayesC&quot;,&quot;bayesR&quot;)</p>
</td></tr>
<tr><td><code id="gbayes_+3A_algorithm">algorithm</code></td>
<td>
<p>specifies the algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list structure including
</p>
<table>
<tr><td><code>b</code></td>
<td>
<p>vector or matrix (mxt) of posterior means for marker effects</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>vector or matrix (mxt) of posterior means for marker inclusion probabilities</p>
</td></tr>
<tr><td><code>vb</code></td>
<td>
<p>scalar or vector (t) of posterior means for marker variances</p>
</td></tr>
<tr><td><code>vg</code></td>
<td>
<p>scalar or vector (t) of posterior means for genomic variances</p>
</td></tr>
<tr><td><code>ve</code></td>
<td>
<p>scalar or vector (t) of posterior means for residual variances</p>
</td></tr>
<tr><td><code>rb</code></td>
<td>
<p>matrix (txt) of posterior means for marker correlations</p>
</td></tr>
<tr><td><code>rg</code></td>
<td>
<p>matrix (txt) of posterior means for genomic correlations</p>
</td></tr>
<tr><td><code>re</code></td>
<td>
<p>matrix (txt) of posterior means for residual correlations</p>
</td></tr>
<tr><td><code>pi</code></td>
<td>
<p>vector (1xnmodels) of posterior probabilities for models</p>
</td></tr>
<tr><td><code>h2</code></td>
<td>
<p>vector (1xt) of posterior means for model probability</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p> a list current parameters (same information as item listed above) used for restart of the analysis</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>matrix (mxt) of marker information and effects used for genomic risk scoring</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Sørensen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Simulate data and test functions

W &lt;- matrix(rnorm(100000),nrow=1000)
set1 &lt;- sample(1:ncol(W),5)
set2 &lt;- sample(1:ncol(W),5)
sets &lt;- list(set1,set2)
g &lt;- rowSums(W[,c(set1,set2)])
e &lt;- rnorm(nrow(W),mean=0,sd=1)
y &lt;- g + e


fitM &lt;- gbayes(y=y, W=W, method="bayesN")
fitA &lt;- gbayes(y=y, W=W, method="bayesA")
fitL &lt;- gbayes(y=y, W=W, method="bayesL")
fitC &lt;- gbayes(y=y, W=W, method="bayesC")


</code></pre>

<hr>
<h2 id='gblup'>Compute Genomic BLUP values</h2><span id='topic+gblup'></span>

<h3>Description</h3>

<p>Compute Genomic BLUP values based on linear mixed model fit output from greml
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gblup(
  GRMlist = NULL,
  GRM = NULL,
  fit = NULL,
  ids = NULL,
  idsCLS = NULL,
  idsRWS = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gblup_+3A_grmlist">GRMlist</code></td>
<td>
<p>list providing information about GRM matrix stored in binary files on disk</p>
</td></tr>
<tr><td><code id="gblup_+3A_grm">GRM</code></td>
<td>
<p>list of one or more genomic relationship matrices</p>
</td></tr>
<tr><td><code id="gblup_+3A_fit">fit</code></td>
<td>
<p>list object output from greml function</p>
</td></tr>
<tr><td><code id="gblup_+3A_ids">ids</code></td>
<td>
<p>vector of ids for which BLUP values is computed</p>
</td></tr>
<tr><td><code id="gblup_+3A_idscls">idsCLS</code></td>
<td>
<p>vector of column ids in GRM for which BLUP values is computed</p>
</td></tr>
<tr><td><code id="gblup_+3A_idsrws">idsRWS</code></td>
<td>
<p>vector of row ids in GRM for which BLUP values is computed</p>
</td></tr>
</table>

<hr>
<h2 id='getG'>Get elements from genotype matrix stored in PLINK bedfiles</h2><span id='topic+getG'></span>

<h3>Description</h3>

<p>Extracts specific rows (based on ids or row numbers) and columns (based on rsids or column numbers) 
from a genotype matrix stored on disk. The extraction is based on provided arguments such as chromosome 
number, ids, rsids, etc. Genotypes can be optionally scaled and imputed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getG(
  Glist = NULL,
  chr = NULL,
  bedfiles = NULL,
  bimfiles = NULL,
  famfiles = NULL,
  ids = NULL,
  rsids = NULL,
  rws = NULL,
  cls = NULL,
  impute = TRUE,
  scale = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getG_+3A_glist">Glist</code></td>
<td>
<p>A list structure containing information about genotypes stored on disk.</p>
</td></tr>
<tr><td><code id="getG_+3A_chr">chr</code></td>
<td>
<p>An integer representing the chromosome for which the genotype matrix is to be extracted. 
It is required.</p>
</td></tr>
<tr><td><code id="getG_+3A_bedfiles">bedfiles</code></td>
<td>
<p>A vector of filenames for the PLINK bed-file.</p>
</td></tr>
<tr><td><code id="getG_+3A_bimfiles">bimfiles</code></td>
<td>
<p>A vector of filenames for the PLINK bim-file.</p>
</td></tr>
<tr><td><code id="getG_+3A_famfiles">famfiles</code></td>
<td>
<p>A vector of filenames for the PLINK fam-file.</p>
</td></tr>
<tr><td><code id="getG_+3A_ids">ids</code></td>
<td>
<p>A vector of individual IDs for whom the genotype data needs to be extracted.</p>
</td></tr>
<tr><td><code id="getG_+3A_rsids">rsids</code></td>
<td>
<p>A vector of SNP identifiers for which the genotype data needs to be extracted.</p>
</td></tr>
<tr><td><code id="getG_+3A_rws">rws</code></td>
<td>
<p>A vector of row numbers to be extracted from the genotype matrix.</p>
</td></tr>
<tr><td><code id="getG_+3A_cls">cls</code></td>
<td>
<p>A vector of column numbers to be extracted from the genotype matrix.</p>
</td></tr>
<tr><td><code id="getG_+3A_impute">impute</code></td>
<td>
<p>A logical or integer. If TRUE, missing genotypes are replaced with their expected values 
(2 times the allele frequency). If set to an integer, missing values are replaced by that integer.</p>
</td></tr>
<tr><td><code id="getG_+3A_scale">scale</code></td>
<td>
<p>A logical. If TRUE, the genotype markers are scaled to have a mean of zero and variance of one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function facilitates the extraction of specific genotype data from storage based on various criteria. 
The extracted genotype data can be optionally scaled or imputed. If rsids are provided that are not found 
in the 'Glist', a warning is raised.
</p>


<h3>Value</h3>

<p>A matrix with extracted genotypic data. Rows correspond to individuals, and columns correspond 
to SNPs. Row names are set to individual IDs, and column names are set to rsids.
</p>

<hr>
<h2 id='getGRM'>Extract elements from genomic relationship matrix (GRM) stored on disk</h2><span id='topic+getGRM'></span>

<h3>Description</h3>

<p>Extract elements from genomic relationship matrix (GRM) (whole or subset) stored on disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGRM(
  GRMlist = NULL,
  ids = NULL,
  idsCLS = NULL,
  idsRWS = NULL,
  cls = NULL,
  rws = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGRM_+3A_grmlist">GRMlist</code></td>
<td>
<p>list providing information about GRM matrix stored in binary files on disk</p>
</td></tr>
<tr><td><code id="getGRM_+3A_ids">ids</code></td>
<td>
<p>vector of ids in GRM to be extracted</p>
</td></tr>
<tr><td><code id="getGRM_+3A_idscls">idsCLS</code></td>
<td>
<p>vector of column ids in GRM to be extracted</p>
</td></tr>
<tr><td><code id="getGRM_+3A_idsrws">idsRWS</code></td>
<td>
<p>vector of row ids in GRM to be extracted</p>
</td></tr>
<tr><td><code id="getGRM_+3A_cls">cls</code></td>
<td>
<p>vector of columns in GRM to be extracted</p>
</td></tr>
<tr><td><code id="getGRM_+3A_rws">rws</code></td>
<td>
<p>vector of rows in GRM to be extracted</p>
</td></tr>
</table>

<hr>
<h2 id='getLD'>Retrieve Sparse LD Matrix for a Given Chromosome</h2><span id='topic+getLD'></span>

<h3>Description</h3>

<p>Extracts and returns a sparse LD (Linkage Disequilibrium) matrix for the specified chromosome based on genotypic data provided in 'Glist'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLD(Glist = NULL, chr = NULL, rsids = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLD_+3A_glist">Glist</code></td>
<td>
<p>A list structure containing genotypic data, including rsids for LD calculation ('rsidsLD'), LD file locations ('ldfiles'), and 'msize' which indicates the size for surrounding region to consider for LD.</p>
</td></tr>
<tr><td><code id="getLD_+3A_chr">chr</code></td>
<td>
<p>A specific chromosome from which LD sets need to be extracted.</p>
</td></tr>
<tr><td><code id="getLD_+3A_rsids">rsids</code></td>
<td>
<p>A vector of rsids that need to be included in the sparse LD matrix. Default is NULL, implying all rsids in the chromosome will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function constructs the LD matrix by reading LD values from binary files stored in 'Glist$ldfiles'.
Each column of the matrix represents a SNP from 'rsidsLD', and rows represent LD values for surrounding SNPs. 
The main diagonal (msize + 1 row) is set to 1 for all SNPs.
</p>


<h3>Value</h3>

<p>A matrix containing LD values. The matrix is of size (msize * 2 + 1) x mchr, where mchr is the number of rsids in the chromosome.
The returned matrix has column names corresponding to rsids in the chromosome, and row names representing relative positions to the current SNP, from -msize to msize.
</p>

<hr>
<h2 id='getLDsets'>Get marker LD sets</h2><span id='topic+getLDsets'></span>

<h3>Description</h3>

<p>Extracts marker LD sets based on a sparse LD matrix stored in the Glist object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLDsets(Glist = NULL, chr = NULL, r2 = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLDsets_+3A_glist">Glist</code></td>
<td>
<p>A list structure containing information about genotypes stored on disk.</p>
</td></tr>
<tr><td><code id="getLDsets_+3A_chr">chr</code></td>
<td>
<p>A numeric value specifying the chromosome for which LD sets are to be extracted.</p>
</td></tr>
<tr><td><code id="getLDsets_+3A_r2">r2</code></td>
<td>
<p>A numeric threshold, defaulting to 0.5, used for extracting LD sets.</p>
</td></tr>
</table>

<hr>
<h2 id='getMap'>Retrieve the map for specified rsids on a given chromosome.</h2><span id='topic+getMap'></span>

<h3>Description</h3>

<p>Fetch the map associated with provided rsids for a given chromosome from the list 'Glist'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMap(Glist = NULL, chr = NULL, rsids = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMap_+3A_glist">Glist</code></td>
<td>
<p>A list structure with information about genotypes stored on disk.</p>
</td></tr>
<tr><td><code id="getMap_+3A_chr">chr</code></td>
<td>
<p>A chromosome from which the map is retrieved.</p>
</td></tr>
<tr><td><code id="getMap_+3A_rsids">rsids</code></td>
<td>
<p>A vector of rsids for which the map is needed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the map corresponding to the specified rsids on the given chromosome.
</p>

<hr>
<h2 id='getMarkers'>Retrieve marker rsids in a specified genome region.</h2><span id='topic+getMarkers'></span>

<h3>Description</h3>

<p>Get marker rsids (reference SNP cluster IDs) from a specified genome region 
based on markers present in 'Glist'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMarkers(Glist = NULL, chr = NULL, region = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMarkers_+3A_glist">Glist</code></td>
<td>
<p>A list structure with information about genotypes stored on disk.</p>
</td></tr>
<tr><td><code id="getMarkers_+3A_chr">chr</code></td>
<td>
<p>A chromosome from which markers are extracted.</p>
</td></tr>
<tr><td><code id="getMarkers_+3A_region">region</code></td>
<td>
<p>A genome region (in base pairs) from which markers are extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of rsids that fall within the specified region on the given chromosome.
</p>

<hr>
<h2 id='getPos'>Retrieve the positions for specified rsids on a given chromosome.</h2><span id='topic+getPos'></span>

<h3>Description</h3>

<p>Fetch the genomic positions associated with provided rsids for a given chromosome from the list 'Glist'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPos(Glist = NULL, chr = NULL, rsids = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPos_+3A_glist">Glist</code></td>
<td>
<p>A list structure with information about genotypes stored on disk.</p>
</td></tr>
<tr><td><code id="getPos_+3A_chr">chr</code></td>
<td>
<p>A chromosome from which the positions are retrieved.</p>
</td></tr>
<tr><td><code id="getPos_+3A_rsids">rsids</code></td>
<td>
<p>A vector of rsids for which the positions are needed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the positions corresponding to the specified rsids on the given chromosome.
</p>

<hr>
<h2 id='getSparseLD'>Extract Sparse Linkage Disequilibrium (LD) Information</h2><span id='topic+getSparseLD'></span>

<h3>Description</h3>

<p>Retrieves and formats linkage disequilibrium (LD) data from binary files based on a specified chromosome and LD threshold.
It provides options for returning the data in sparse or dense format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSparseLD(
  Glist = NULL,
  chr = NULL,
  r2 = 0,
  onebased = TRUE,
  rsids = NULL,
  format = "sparse"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSparseLD_+3A_glist">Glist</code></td>
<td>
<p>A list containing details such as the LD file path, msize, rsids for LD.</p>
</td></tr>
<tr><td><code id="getSparseLD_+3A_chr">chr</code></td>
<td>
<p>A numeric value representing the chromosome for which LD data is to be extracted.</p>
</td></tr>
<tr><td><code id="getSparseLD_+3A_r2">r2</code></td>
<td>
<p>A numeric value specifying the LD threshold for extraction. Default is 0.</p>
</td></tr>
<tr><td><code id="getSparseLD_+3A_onebased">onebased</code></td>
<td>
<p>A logical value indicating whether indices are one-based (default) or zero-based.</p>
</td></tr>
<tr><td><code id="getSparseLD_+3A_rsids">rsids</code></td>
<td>
<p>A vector of rsids for which the LD data needs to be extracted in dense format. Default is NULL.</p>
</td></tr>
<tr><td><code id="getSparseLD_+3A_format">format</code></td>
<td>
<p>A character string specifying the format of the result, either &quot;sparse&quot; (default) or &quot;dense&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If 'format' is &quot;sparse&quot;, a list with two components: 'indices' and 'values'. Each component is a list 
of length equal to the number of rsids in the specified chromosome. If 'format' is &quot;dense&quot;, a matrix with rows 
and columns named after the rsids is returned.
</p>

<hr>
<h2 id='gfilter'>Filter genetic marker data based on different quality measures</h2><span id='topic+gfilter'></span>

<h3>Description</h3>

<p>Quality control is a critical step for working with summary statistics (in particular
for external). 
Processing and quality control of GWAS summary statistics includes:                                                                      
</p>
<p>- map marker ids (rsids/cpra (chr, pos, ref, alt)) to LD reference panel data 
- check effect allele (flip EA, EAF, Effect)
- check effect allele frequency
- thresholds for MAF and HWE
- exclude INDELS, CG/AT and MHC region
- remove duplicated marker ids
- check which build version
- check for concordance between marker effect and LD data
</p>
<p>External summary statistics format:
marker, chr, pos, effect_allele, non_effect_allele, effect_allele_freq, effect, effect_se, stat, p, n    
</p>
<p>Internal summary statistics format:
rsids, chr, pos, a1, a2, af, b, seb, stat, p, n
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gfilter(
  Glist = NULL,
  excludeMAF = 0.01,
  excludeMISS = 0.05,
  excludeINFO = NULL,
  excludeCGAT = TRUE,
  excludeINDEL = TRUE,
  excludeDUPS = TRUE,
  excludeHWE = 1e-12,
  excludeMHC = FALSE,
  assembly = "GRCh37"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gfilter_+3A_glist">Glist</code></td>
<td>
<p>A list containing information about the genotype matrix stored on disk.</p>
</td></tr>
<tr><td><code id="gfilter_+3A_excludemaf">excludeMAF</code></td>
<td>
<p>A scalar threshold. Exclude markers with a minor allele frequency (MAF) below this threshold. Default is 0.01.</p>
</td></tr>
<tr><td><code id="gfilter_+3A_excludemiss">excludeMISS</code></td>
<td>
<p>A scalar threshold. Exclude markers with missingness (MISS) above this threshold. Default is 0.05.</p>
</td></tr>
<tr><td><code id="gfilter_+3A_excludeinfo">excludeINFO</code></td>
<td>
<p>A scalar threshold. Exclude markers with an info score (INFO) below this threshold. Default is 0.8.</p>
</td></tr>
<tr><td><code id="gfilter_+3A_excludecgat">excludeCGAT</code></td>
<td>
<p>A logical value; if TRUE exclude markers if the alleles are ambiguous (i.e., either CG or AT combinations).</p>
</td></tr>
<tr><td><code id="gfilter_+3A_excludeindel">excludeINDEL</code></td>
<td>
<p>A logical value; if TRUE exclude markers that are insertions or deletions (INDELs).</p>
</td></tr>
<tr><td><code id="gfilter_+3A_excludedups">excludeDUPS</code></td>
<td>
<p>A logical value; if TRUE exclude markers if their identifiers are duplicated.</p>
</td></tr>
<tr><td><code id="gfilter_+3A_excludehwe">excludeHWE</code></td>
<td>
<p>A scalar threshold. Exclude markers where the p-value for the Hardy-Weinberg Equilibrium test is below this threshold. Default is 0.01.</p>
</td></tr>
<tr><td><code id="gfilter_+3A_excludemhc">excludeMHC</code></td>
<td>
<p>A logical value; if TRUE exclude markers located within the MHC region.</p>
</td></tr>
<tr><td><code id="gfilter_+3A_assembly">assembly</code></td>
<td>
<p>A character string indicating the name of the genome assembly (e.g., &quot;GRCh38&quot;).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Soerensen
</p>

<hr>
<h2 id='glma'>Single marker association analysis using linear models or linear mixed models</h2><span id='topic+glma'></span>

<h3>Description</h3>

<p>The function glma performs single marker association analysis between genotype markers and the phenotype
either based on linear model analysis (LMA) or mixed linear model analysis (MLMA).
</p>
<p>The basic MLMA approach involves 1) building a genetic relationship matrix (GRM) that models genome-wide
sample structure, 2) estimating the contribution of the GRM to phenotypic variance using a random effects model
(with or without additional fixed effects) and 3) computing association statistics that account for this component
on phenotypic variance.
</p>
<p>MLMA methods are the method of choice when conducting association mapping in the presence of sample structure,
including geographic population structure, family relatedness and/or cryptic relatedness. MLMA methods prevent
false positive associations and increase power. The general recommendation when using MLMA is to exclude candidate
markers from the GRM. This can be efficiently implemented via a leave-one-chromosome-out analysis.
Further, it is recommend that analyses of randomly ascertained quantitative traits should include all markers
(except for the candidate marker and markers in LD with the candidate marker) in the GRM, except as follows.
First, the set of markers included in the GRM can be pruned by LD to reduce running time (with association
statistics still computed for all markers). Second, genome-wide significant markers of large effect should be
conditioned out as fixed effects or as an additional random effect (if a large number of associated markers).
Third, when population stratification is less of a concern, it may be useful using the top associated markers
selected based on the global maximum from out-of sample predictive accuracy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glma(
  y = NULL,
  X = NULL,
  W = NULL,
  Glist = NULL,
  chr = NULL,
  fit = NULL,
  verbose = FALSE,
  statistic = "mastor",
  ids = NULL,
  rsids = NULL,
  msize = 100,
  scale = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glma_+3A_y">y</code></td>
<td>
<p>vector or matrix of phenotypes</p>
</td></tr>
<tr><td><code id="glma_+3A_x">X</code></td>
<td>
<p>design matrix for factors modeled as fixed effects</p>
</td></tr>
<tr><td><code id="glma_+3A_w">W</code></td>
<td>
<p>matrix of centered and scaled genotypes</p>
</td></tr>
<tr><td><code id="glma_+3A_glist">Glist</code></td>
<td>
<p>list of information about genotype matrix stored on disk</p>
</td></tr>
<tr><td><code id="glma_+3A_chr">chr</code></td>
<td>
<p>chromosome for which summary statistics are computed</p>
</td></tr>
<tr><td><code id="glma_+3A_fit">fit</code></td>
<td>
<p>list of information about linear mixed model fit (output from greml)</p>
</td></tr>
<tr><td><code id="glma_+3A_verbose">verbose</code></td>
<td>
<p>is a logical; if TRUE it prints more details during optimization</p>
</td></tr>
<tr><td><code id="glma_+3A_statistic">statistic</code></td>
<td>
<p>single marker test statistic used (currently based on the &quot;mastor&quot; statistics).</p>
</td></tr>
<tr><td><code id="glma_+3A_ids">ids</code></td>
<td>
<p>vector of individuals used in the analysis</p>
</td></tr>
<tr><td><code id="glma_+3A_rsids">rsids</code></td>
<td>
<p>vector of marker rsids used in the analysis</p>
</td></tr>
<tr><td><code id="glma_+3A_msize">msize</code></td>
<td>
<p>number of genotype markers used for batch processing</p>
</td></tr>
<tr><td><code id="glma_+3A_scale">scale</code></td>
<td>
<p>logical if TRUE the genotypes have been scaled to mean zero and variance one</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe (if number of traits = 1) else a list including
</p>
<table>
<tr><td><code>coef</code></td>
<td>
<p>single marker coefficients</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>standard error of coefficients</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>single marker test statistic</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>p-value</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Soerensen
</p>


<h3>References</h3>

<p>Chen, W. M., &amp; Abecasis, G. R. (2007). Family-based association tests for genomewide association scans. The American Journal of Human Genetics, 81(5), 913-926.
</p>
<p>Loh, P. R., Tucker, G., Bulik-Sullivan, B. K., Vilhjalmsson, B. J., Finucane, H. K., Salem, R. M., ... &amp; Patterson, N. (2015). Efficient Bayesian mixed-model analysis increases association power in large cohorts. Nature genetics, 47(3), 284-290.
</p>
<p>Kang, H. M., Sul, J. H., Zaitlen, N. A., Kong, S. Y., Freimer, N. B., Sabatti, C., &amp; Eskin, E. (2010). Variance component model to account for sample structure in genome-wide association studies. Nature genetics, 42(4), 348-354.
</p>
<p>Lippert, C., Listgarten, J., Liu, Y., Kadie, C. M., Davidson, R. I., &amp; Heckerman, D. (2011). FaST linear mixed models for genome-wide association studies. Nature methods, 8(10), 833-835.
</p>
<p>Listgarten, J., Lippert, C., Kadie, C. M., Davidson, R. I., Eskin, E., &amp; Heckerman, D. (2012). Improved linear mixed models for genome-wide association studies. Nature methods, 9(6), 525-526.
</p>
<p>Listgarten, J., Lippert, C., &amp; Heckerman, D. (2013). FaST-LMM-Select for addressing confounding from spatial structure and rare variants. Nature Genetics, 45(5), 470-471.
</p>
<p>Lippert, C., Quon, G., Kang, E. Y., Kadie, C. M., Listgarten, J., &amp; Heckerman, D. (2013). The benefits of selecting phenotype-specific variants for applications of mixed models in genomics. Scientific reports, 3.
</p>
<p>Zhou, X., &amp; Stephens, M. (2012). Genome-wide efficient mixed-model analysis for association studies. Nature genetics, 44(7), 821-824.
</p>
<p>Svishcheva, G. R., Axenovich, T. I., Belonogova, N. M., van Duijn, C. M., &amp; Aulchenko, Y. S. (2012). Rapid variance components-based method for whole-genome association analysis. Nature genetics, 44(10), 1166-1170.
</p>
<p>Yang, J., Zaitlen, N. A., Goddard, M. E., Visscher, P. M., &amp; Price, A. L. (2014). Advantages and pitfalls in the application of mixed-model association methods. Nature genetics, 46(2), 100-106.
</p>
<p>Bulik-Sullivan, B. K., Loh, P. R., Finucane, H. K., Ripke, S., Yang, J., Patterson, N., ... &amp; Schizophrenia Working Group of the Psychiatric Genomics Consortium. (2015). LD Score regression distinguishes confounding from polygenicity in genome-wide association studies. Nature genetics, 47(3), 291-295.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate data
W &lt;- matrix(rnorm(1000000), ncol = 1000)
	colnames(W) &lt;- as.character(1:ncol(W))
	rownames(W) &lt;- as.character(1:nrow(W))
y &lt;- rowSums(W[, 1:10]) + rowSums(W[, 501:510]) + rnorm(nrow(W))

# Create model
data &lt;- data.frame(y = y, mu = 1)
fm &lt;- y ~ 0 + mu
X &lt;- model.matrix(fm, data = data)

# Linear model analyses and single marker association test
stat &lt;- glma(y=y,X=X,W = W)

head(stat)


# Compute GRM
GRM &lt;- grm(W = W)

# Estimate variance components using REML analysis
fit &lt;- greml(y = y, X = X, GRM = list(GRM), verbose = TRUE)

# Single marker association test
stat &lt;- glma(fit = fit, W = W)

head(stat)




</code></pre>

<hr>
<h2 id='gmap'>Finemapping using Bayesian Linear Regression Models</h2><span id='topic+gmap'></span>

<h3>Description</h3>

<p>In the Bayesian multiple regression model, the posterior density of the model parameters depends
on the likelihood of the data given the parameters and a prior probability for the model parameters.
The choice of the prior for marker effects can influence the type and extent of shrinkage induced in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmap(
  y = NULL,
  X = NULL,
  W = NULL,
  stat = NULL,
  trait = NULL,
  sets = NULL,
  fit = NULL,
  Glist = NULL,
  chr = NULL,
  rsids = NULL,
  ids = NULL,
  b = NULL,
  bm = NULL,
  seb = NULL,
  mask = NULL,
  LD = NULL,
  n = NULL,
  vg = NULL,
  vb = NULL,
  ve = NULL,
  ssg_prior = NULL,
  ssb_prior = NULL,
  sse_prior = NULL,
  lambda = NULL,
  scaleY = TRUE,
  shrinkLD = FALSE,
  shrinkCor = FALSE,
  formatLD = "dense",
  pruneLD = TRUE,
  r2 = 0.05,
  checkLD = TRUE,
  h2 = NULL,
  pi = 0.001,
  updateB = TRUE,
  updateG = TRUE,
  updateE = TRUE,
  updatePi = TRUE,
  adjustE = TRUE,
  models = NULL,
  checkConvergence = FALSE,
  critVe = 3,
  critVg = 5,
  critVb = 5,
  critPi = 3,
  ntrial = 1,
  nug = 4,
  nub = 4,
  nue = 4,
  verbose = FALSE,
  msize = 100,
  threshold = NULL,
  ve_prior = NULL,
  vg_prior = NULL,
  tol = 0.001,
  nit = 100,
  nburn = 50,
  nit_local = NULL,
  nit_global = NULL,
  method = "bayesC",
  algorithm = "mcmc"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmap_+3A_y">y</code></td>
<td>
<p>A vector or matrix of phenotypes.</p>
</td></tr>
<tr><td><code id="gmap_+3A_x">X</code></td>
<td>
<p>A matrix of covariates.</p>
</td></tr>
<tr><td><code id="gmap_+3A_w">W</code></td>
<td>
<p>A matrix of centered and scaled genotypes.</p>
</td></tr>
<tr><td><code id="gmap_+3A_stat">stat</code></td>
<td>
<p>Dataframe with marker summary statistics.</p>
</td></tr>
<tr><td><code id="gmap_+3A_trait">trait</code></td>
<td>
<p>Integer used for selection traits in covs object.</p>
</td></tr>
<tr><td><code id="gmap_+3A_sets">sets</code></td>
<td>
<p>A list of character vectors where each vector represents a set of items. If the names
of the sets are not provided, they are named as &quot;Set1&quot;, &quot;Set2&quot;, etc.</p>
</td></tr>
<tr><td><code id="gmap_+3A_fit">fit</code></td>
<td>
<p>List of results from gbayes.</p>
</td></tr>
<tr><td><code id="gmap_+3A_glist">Glist</code></td>
<td>
<p>List of information about genotype matrix stored on disk.</p>
</td></tr>
<tr><td><code id="gmap_+3A_chr">chr</code></td>
<td>
<p>Chromosome for which to fit BLR models.</p>
</td></tr>
<tr><td><code id="gmap_+3A_rsids">rsids</code></td>
<td>
<p>Character vector of rsids.</p>
</td></tr>
<tr><td><code id="gmap_+3A_ids">ids</code></td>
<td>
<p>vector of individuals used in the study</p>
</td></tr>
<tr><td><code id="gmap_+3A_b">b</code></td>
<td>
<p>Vector or matrix of marginal marker effects.</p>
</td></tr>
<tr><td><code id="gmap_+3A_bm">bm</code></td>
<td>
<p>Vector or matrix of adjusted marker effects for the BLR model.</p>
</td></tr>
<tr><td><code id="gmap_+3A_seb">seb</code></td>
<td>
<p>Vector or matrix of standard error of marginal effects.</p>
</td></tr>
<tr><td><code id="gmap_+3A_mask">mask</code></td>
<td>
<p>Vector or matrix specifying if marker should be ignored.</p>
</td></tr>
<tr><td><code id="gmap_+3A_ld">LD</code></td>
<td>
<p>List with sparse LD matrices.</p>
</td></tr>
<tr><td><code id="gmap_+3A_n">n</code></td>
<td>
<p>Scalar or vector of number of observations for each trait.</p>
</td></tr>
<tr><td><code id="gmap_+3A_vg">vg</code></td>
<td>
<p>Scalar or matrix of genetic (co)variances.</p>
</td></tr>
<tr><td><code id="gmap_+3A_vb">vb</code></td>
<td>
<p>Scalar or matrix of marker (co)variances.</p>
</td></tr>
<tr><td><code id="gmap_+3A_ve">ve</code></td>
<td>
<p>Scalar or matrix of residual (co)variances.</p>
</td></tr>
<tr><td><code id="gmap_+3A_ssg_prior">ssg_prior</code></td>
<td>
<p>Scalar or matrix of prior genetic (co)variances.</p>
</td></tr>
<tr><td><code id="gmap_+3A_ssb_prior">ssb_prior</code></td>
<td>
<p>Scalar or matrix of prior marker (co)variances.</p>
</td></tr>
<tr><td><code id="gmap_+3A_sse_prior">sse_prior</code></td>
<td>
<p>Scalar or matrix of prior residual (co)variances.</p>
</td></tr>
<tr><td><code id="gmap_+3A_lambda">lambda</code></td>
<td>
<p>Vector or matrix of lambda values</p>
</td></tr>
<tr><td><code id="gmap_+3A_scaley">scaleY</code></td>
<td>
<p>Logical indicating if y should be scaled.</p>
</td></tr>
<tr><td><code id="gmap_+3A_shrinkld">shrinkLD</code></td>
<td>
<p>Logical indicating if LD should be shrunk.</p>
</td></tr>
<tr><td><code id="gmap_+3A_shrinkcor">shrinkCor</code></td>
<td>
<p>Logical indicating if cor should be shrunk.</p>
</td></tr>
<tr><td><code id="gmap_+3A_formatld">formatLD</code></td>
<td>
<p>Character specifying LD format (default is &quot;dense&quot;).</p>
</td></tr>
<tr><td><code id="gmap_+3A_pruneld">pruneLD</code></td>
<td>
<p>Logical indicating if LD pruning should be applied.</p>
</td></tr>
<tr><td><code id="gmap_+3A_r2">r2</code></td>
<td>
<p>Scalar providing value for r2 threshold used in pruning</p>
</td></tr>
<tr><td><code id="gmap_+3A_checkld">checkLD</code></td>
<td>
<p>Logical indicating if LD matches summary statistics.</p>
</td></tr>
<tr><td><code id="gmap_+3A_h2">h2</code></td>
<td>
<p>Trait heritability.</p>
</td></tr>
<tr><td><code id="gmap_+3A_pi">pi</code></td>
<td>
<p>Proportion of markers in each marker variance class.</p>
</td></tr>
<tr><td><code id="gmap_+3A_updateb">updateB</code></td>
<td>
<p>Logical indicating if marker (co)variances should be updated.</p>
</td></tr>
<tr><td><code id="gmap_+3A_updateg">updateG</code></td>
<td>
<p>Logical indicating if genetic (co)variances should be updated.</p>
</td></tr>
<tr><td><code id="gmap_+3A_updatee">updateE</code></td>
<td>
<p>Logical indicating if residual (co)variances should be updated.</p>
</td></tr>
<tr><td><code id="gmap_+3A_updatepi">updatePi</code></td>
<td>
<p>Logical indicating if pi should be updated.</p>
</td></tr>
<tr><td><code id="gmap_+3A_adjuste">adjustE</code></td>
<td>
<p>Logical indicating if residual variance should be adjusted.</p>
</td></tr>
<tr><td><code id="gmap_+3A_models">models</code></td>
<td>
<p>List structure with models evaluated in bayesC.</p>
</td></tr>
<tr><td><code id="gmap_+3A_checkconvergence">checkConvergence</code></td>
<td>
<p>Logical indicating if convergences should be checked.</p>
</td></tr>
<tr><td><code id="gmap_+3A_critve">critVe</code></td>
<td>
<p>Scalar providing value for z-score threshold used in checking convergence for Ve</p>
</td></tr>
<tr><td><code id="gmap_+3A_critvg">critVg</code></td>
<td>
<p>Scalar providing value for z-score threshold used in checking convergence for Vg</p>
</td></tr>
<tr><td><code id="gmap_+3A_critvb">critVb</code></td>
<td>
<p>Scalar providing value for z-score threshold used in checking convergence for Vg</p>
</td></tr>
<tr><td><code id="gmap_+3A_critpi">critPi</code></td>
<td>
<p>Scalar providing value for z-score threshold used in checking convergence for Pi</p>
</td></tr>
<tr><td><code id="gmap_+3A_ntrial">ntrial</code></td>
<td>
<p>Integer providing number of trials used if convergence is not obtaines</p>
</td></tr>
<tr><td><code id="gmap_+3A_nug">nug</code></td>
<td>
<p>Scalar or vector of prior degrees of freedom for genetic (co)variances.</p>
</td></tr>
<tr><td><code id="gmap_+3A_nub">nub</code></td>
<td>
<p>Scalar or vector of prior degrees of freedom for marker (co)variances.</p>
</td></tr>
<tr><td><code id="gmap_+3A_nue">nue</code></td>
<td>
<p>Scalar or vector of prior degrees of freedom for residual (co)variances.</p>
</td></tr>
<tr><td><code id="gmap_+3A_verbose">verbose</code></td>
<td>
<p>Logical; if TRUE, it prints more details during iteration.</p>
</td></tr>
<tr><td><code id="gmap_+3A_msize">msize</code></td>
<td>
<p>Integer providing number of markers used in computation of sparseld</p>
</td></tr>
<tr><td><code id="gmap_+3A_threshold">threshold</code></td>
<td>
<p>Scalar providing value for threshold used in adjustment of B</p>
</td></tr>
<tr><td><code id="gmap_+3A_ve_prior">ve_prior</code></td>
<td>
<p>Scalar or matrix of prior residual (co)variances.</p>
</td></tr>
<tr><td><code id="gmap_+3A_vg_prior">vg_prior</code></td>
<td>
<p>Scalar or matrix of prior genetic (co)variances.</p>
</td></tr>
<tr><td><code id="gmap_+3A_tol">tol</code></td>
<td>
<p>Convergence criteria used in gbayes.</p>
</td></tr>
<tr><td><code id="gmap_+3A_nit">nit</code></td>
<td>
<p>Number of iterations.</p>
</td></tr>
<tr><td><code id="gmap_+3A_nburn">nburn</code></td>
<td>
<p>Number of burnin iterations.</p>
</td></tr>
<tr><td><code id="gmap_+3A_nit_local">nit_local</code></td>
<td>
<p>Number of local iterations.</p>
</td></tr>
<tr><td><code id="gmap_+3A_nit_global">nit_global</code></td>
<td>
<p>Number of global iterations.</p>
</td></tr>
<tr><td><code id="gmap_+3A_method">method</code></td>
<td>
<p>Method used (e.g. &quot;bayesN&quot;,&quot;bayesA&quot;,&quot;bayesL&quot;,&quot;bayesC&quot;,&quot;bayesR&quot;).</p>
</td></tr>
<tr><td><code id="gmap_+3A_algorithm">algorithm</code></td>
<td>
<p>Specifies the algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements Bayesian linear regression models to provide unified mapping of 
genetic variants, estimate genetic parameters (e.g. heritability), and predict disease risk.
It is designed to handle various genetic architectures and scale efficiently with large datasets.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li><p><code>bm</code>Vector or matrix of posterior means for marker effects.
</p>
</li>
<li><p><code>dm</code>Vector or matrix of posterior means for marker inclusion probabilities.
</p>
</li>
<li><p><code>vb</code>Scalar or vector of posterior means for marker variances.
</p>
</li>
<li><p><code>vg</code>Scalar or vector of posterior means for genomic variances.
</p>
</li>
<li><p><code>ve</code>Scalar or vector of posterior means for residual variances.
</p>
</li>
<li><p><code>rb</code>Matrix of posterior means for marker correlations.
</p>
</li>
<li><p><code>rg</code>Matrix of posterior means for genomic correlations.
</p>
</li>
<li><p><code>re</code>Matrix of posterior means for residual correlations.
</p>
</li>
<li><p><code>pi</code>Vector of posterior probabilities for models.
</p>
</li>
<li><p><code>h2</code>Vector of posterior means for model probability.
</p>
</li>
<li><p><code>param</code>List of current parameters used for restarting the analysis.
</p>
</li>
<li><p><code>stat</code>Matrix of marker information and effects used for genomic risk scoring.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Peter Sørensen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Plink bed/bim/fam files
bedfiles &lt;- system.file("extdata", paste0("sample_chr",1:2,".bed"), package = "qgg")
bimfiles &lt;- system.file("extdata", paste0("sample_chr",1:2,".bim"), package = "qgg")
famfiles &lt;- system.file("extdata", paste0("sample_chr",1:2,".fam"), package = "qgg")

# Prepare Glist
Glist &lt;- gprep(study="Example", bedfiles=bedfiles, bimfiles=bimfiles, famfiles=famfiles)

# Simulate phenotype
sim &lt;- gsim(Glist=Glist, chr=1, nt=1)

# Compute single marker summary statistics
stat &lt;- glma(y=sim$y, Glist=Glist, scale=FALSE)
str(stat)

# Define fine-mapping regions 
sets &lt;- Glist$rsids
Glist$chr[[1]] &lt;- gsub("21","1",Glist$chr[[1]]) 
Glist$chr[[2]] &lt;- gsub("22","2",Glist$chr[[2]]) 

# Fine map
fit &lt;- gmap(Glist=Glist, stat=stat, sets=sets, verbose=FALSE, 
            method="bayesC", nit=1500, nburn=500, pi=0.001)
            
fit$post  # Posterior inference for every fine-mapped region
fit$conv  # Convergence statistics for every fine-mapped region

# Posterior inference for marker effect
head(fit$stat)             

</code></pre>

<hr>
<h2 id='gprep'>Prepare genotype data for all statistical analyses</h2><span id='topic+gprep'></span>

<h3>Description</h3>

<p>All functions in qgg relies on a simple data infrastructure that takes five main input sources;
phenotype data (y), covariate data (X), genotype data (G or Glist), a genomic relationship
matrix (GRM or GRMlist) and genetic marker sets (sets).
</p>
<p>The genotypes are stored in a matrix (n x m (individuals x markers)) in memory (G) or in a
binary file on disk (Glist).
</p>
<p>It is only for small data sets that the genotype matrix (G) can stored in memory. For large data
sets the genotype matrix has to stored in a binary file on disk (Glist). Glist is as a list
structure that contains information about the genotypes in the binary file.
</p>
<p>The gprep function prepares the Glist, and is required for downstream analyses of large-scale
genetic data. Typically, the Glist is prepared once, and saved as an *.Rdata-file.
</p>
<p>The gprep function reads genotype information from binary PLINK files, and creates the Glist
object that contains general information about the genotypes such as reference alleles,
allele frequencies and missing genotypes, and construct a binary file on the disk that contains
the genotypes as allele counts of the alternative allele (memory usage = (n x m)/4 bytes).
</p>
<p>The gprep function can also be used to prepare sparse ld matrices.
The r2 metric used is the pairwise correlation between markers (allele count alternative allele)
in a specified region of the genome. The marker genotype is allele count of the alternative allele
which is assumed to be centered and scaled.
</p>
<p>The Glist structure is used as input parameter for a number of qgg core functions including:
1) construction of genomic relationship matrices (grm), 2) construction of sparse ld matrices,
3) estimating genomic parameters (greml), 4) single marker association analyses (glma),
5) gene set enrichment analyses (gsea), and 6) genomic prediction from genotypes
and phenotypes (gsolve) or genotypes and summary statistics (gscore).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gprep(
  Glist = NULL,
  task = "prepare",
  study = NULL,
  fnBED = NULL,
  ldfiles = NULL,
  bedfiles = NULL,
  bimfiles = NULL,
  famfiles = NULL,
  mapfiles = NULL,
  ids = NULL,
  rsids = NULL,
  assembly = NULL,
  overwrite = FALSE,
  msize = 100,
  r2 = NULL,
  kb = NULL,
  cm = NULL,
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gprep_+3A_glist">Glist</code></td>
<td>
<p>A list containing information about the genotype matrix stored on disk.</p>
</td></tr>
<tr><td><code id="gprep_+3A_task">task</code></td>
<td>
<p>A character string specifying the task to perform. Possible tasks are &quot;prepare&quot; (default), &quot;sparseld&quot;, &quot;ldscores&quot;, &quot;ldsets&quot;, and &quot;geneticmap&quot;.</p>
</td></tr>
<tr><td><code id="gprep_+3A_study">study</code></td>
<td>
<p>The name of the study.</p>
</td></tr>
<tr><td><code id="gprep_+3A_fnbed">fnBED</code></td>
<td>
<p>Path and filename of the .bed binary file used to store genotypes on disk.</p>
</td></tr>
<tr><td><code id="gprep_+3A_ldfiles">ldfiles</code></td>
<td>
<p>Path and filename of the .ld binary files used for storing the sparse LD matrix on disk.</p>
</td></tr>
<tr><td><code id="gprep_+3A_bedfiles">bedfiles</code></td>
<td>
<p>A vector of filenames for the PLINK bed-files.</p>
</td></tr>
<tr><td><code id="gprep_+3A_bimfiles">bimfiles</code></td>
<td>
<p>A vector of filenames for the PLINK bim-files.</p>
</td></tr>
<tr><td><code id="gprep_+3A_famfiles">famfiles</code></td>
<td>
<p>A vector of filenames for the PLINK fam-files.</p>
</td></tr>
<tr><td><code id="gprep_+3A_mapfiles">mapfiles</code></td>
<td>
<p>A vector of filenames for the mapfiles.</p>
</td></tr>
<tr><td><code id="gprep_+3A_ids">ids</code></td>
<td>
<p>A vector of individual identifiers used in the study.</p>
</td></tr>
<tr><td><code id="gprep_+3A_rsids">rsids</code></td>
<td>
<p>A vector of marker rsids used in the study.</p>
</td></tr>
<tr><td><code id="gprep_+3A_assembly">assembly</code></td>
<td>
<p>Character string indicating the name of the assembly.</p>
</td></tr>
<tr><td><code id="gprep_+3A_overwrite">overwrite</code></td>
<td>
<p>A logical value; if TRUE, the binary genotype/LD file will be overwritten.</p>
</td></tr>
<tr><td><code id="gprep_+3A_msize">msize</code></td>
<td>
<p>Number of markers used in the computation of sparseld.</p>
</td></tr>
<tr><td><code id="gprep_+3A_r2">r2</code></td>
<td>
<p>A threshold value (more context might be beneficial, e.g., threshold for what?).</p>
</td></tr>
<tr><td><code id="gprep_+3A_kb">kb</code></td>
<td>
<p>Size of the genomic region in kilobases (kb).</p>
</td></tr>
<tr><td><code id="gprep_+3A_cm">cm</code></td>
<td>
<p>Size of the genomic region in centimorgans (cm).</p>
</td></tr>
<tr><td><code id="gprep_+3A_ncores">ncores</code></td>
<td>
<p>Number of processing cores to be used for genotype processing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list structure (Glist) with information about the genotypes.
</p>


<h3>Author(s)</h3>

<p>Peter Soerensen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bedfiles &lt;- system.file("extdata", "sample_chr1.bed", package = "qgg")
bimfiles &lt;- system.file("extdata", "sample_chr1.bim", package = "qgg")
famfiles &lt;- system.file("extdata", "sample_chr1.fam", package = "qgg")

Glist &lt;- gprep(study="Example", bedfiles=bedfiles, bimfiles=bimfiles,
             famfiles=famfiles)

</code></pre>

<hr>
<h2 id='greml'>Genomic rescticted maximum likelihood (GREML) analysis</h2><span id='topic+greml'></span>

<h3>Description</h3>

<p>The greml function is used for the estimation of genomic parameters (co-variance, heritability and correlation)
for linear mixed models using restricted maximum likelihood estimation (REML) and genomic prediction using
best linear unbiased prediction (BLUP).
</p>
<p>The linear mixed model can account for multiple genetic factors (fixed and random genetic marker effects),
adjust for complex family relationships or population stratification and adjust for other non-genetic factors
including lifestyle characteristics. Different genetic architectures (infinitesimal, few large and many
small effects) is accounted for by modeling genetic markers in different sets as fixed or random effects
and by specifying individual genetic marker weights. Different genetic models (e.g. additive and non-additive)
can be specified by providing additive and non-additive genomic relationship matrices (GRMs) (constructed using grm).
The GRMs can be accessed from the R environment or from binary files stored on disk facilitating the analyses of
large-scale genetic data.
</p>
<p>The output contains estimates of variance components, fixed and random effects, first and second derivatives of
log-likelihood and the asymptotic standard deviation of parameter estimates.
</p>
<p>Assessment of predictive accuracy (including correlation and R2, and AUC for binary phenotypes) can be obtained
by providing greml with a data frame, or a list that contains sample IDs used in the validation (see examples for details).
</p>
<p>Genomic parameters can also be estimated with DMU (http://www.dmu.agrsci.dk/DMU/) if interface =”DMU”.
This option requires DMU to be installed locally, and the path to the DMU binary files has to be specified
(see examples below for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>greml(
  y = NULL,
  X = NULL,
  GRMlist = NULL,
  GRM = NULL,
  theta = NULL,
  ids = NULL,
  validate = NULL,
  maxit = 100,
  tol = 1e-05,
  bin = NULL,
  ncores = 1,
  wkdir = getwd(),
  verbose = FALSE,
  interface = "R",
  fm = NULL,
  data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="greml_+3A_y">y</code></td>
<td>
<p>is a vector or matrix of phenotypes</p>
</td></tr>
<tr><td><code id="greml_+3A_x">X</code></td>
<td>
<p>is a design matrix for factors modeled as fixed effects</p>
</td></tr>
<tr><td><code id="greml_+3A_grmlist">GRMlist</code></td>
<td>
<p>is a list providing information about GRM matrix stored in binary files on disk</p>
</td></tr>
<tr><td><code id="greml_+3A_grm">GRM</code></td>
<td>
<p>is a list of one or more genomic relationship matrices</p>
</td></tr>
<tr><td><code id="greml_+3A_theta">theta</code></td>
<td>
<p>is a vector of initial values of co-variance for REML estimation</p>
</td></tr>
<tr><td><code id="greml_+3A_ids">ids</code></td>
<td>
<p>is a vector of individuals used in the analysis</p>
</td></tr>
<tr><td><code id="greml_+3A_validate">validate</code></td>
<td>
<p>is a data frame or list of individuals used in cross-validation (one column/row for each validation set)</p>
</td></tr>
<tr><td><code id="greml_+3A_maxit">maxit</code></td>
<td>
<p>is the maximum number of iterations used in REML analysis</p>
</td></tr>
<tr><td><code id="greml_+3A_tol">tol</code></td>
<td>
<p>is tolerance, i.e. convergence criteria used in REML</p>
</td></tr>
<tr><td><code id="greml_+3A_bin">bin</code></td>
<td>
<p>is the directory for fortran binaries (e.g. DMU binaries dmu1 and dmuai)</p>
</td></tr>
<tr><td><code id="greml_+3A_ncores">ncores</code></td>
<td>
<p>is the number of cores used for the analysis</p>
</td></tr>
<tr><td><code id="greml_+3A_wkdir">wkdir</code></td>
<td>
<p>is the working directory used for REML</p>
</td></tr>
<tr><td><code id="greml_+3A_verbose">verbose</code></td>
<td>
<p>is a logical; if TRUE it prints more details during optimization</p>
</td></tr>
<tr><td><code id="greml_+3A_interface">interface</code></td>
<td>
<p>is used for specifying whether to use R or Fortran implementations of REML</p>
</td></tr>
<tr><td><code id="greml_+3A_fm">fm</code></td>
<td>
<p>is a formula with model statement for the linear mixed model</p>
</td></tr>
<tr><td><code id="greml_+3A_data">data</code></td>
<td>
<p>is a data frame containing the phenotypic observations and fixed factors specified in the model statements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list structure including:
</p>
<table>
<tr><td><code>llik</code></td>
<td>
<p>log-likelihood at convergence</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>covariance estimates from REML</p>
</td></tr>
<tr><td><code>asd</code></td>
<td>
<p>asymptotic standard deviation</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>vector of fixed effect estimates</p>
</td></tr>
<tr><td><code>varb</code></td>
<td>
<p>vector of variances of fixed effect estimates</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>vector or matrix of random effect estimates</p>
</td></tr>
<tr><td><code>e</code></td>
<td>
<p>vector or matrix of residual effects</p>
</td></tr>
<tr><td><code>accuracy</code></td>
<td>
<p>matrix of prediction accuracies (only returned if [validate?] is provided)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Soerensen
</p>


<h3>References</h3>

<p>Lee, S. H., &amp; van der Werf, J. H. (2006). An efficient variance component approach implementing an average information REML suitable for combined LD and linkage mapping with a general complex pedigree. Genetics Selection Evolution, 38(1), 25.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Simulate data
W &lt;- matrix(rnorm(1000000), ncol = 1000)
	colnames(W) &lt;- as.character(1:ncol(W))
	rownames(W) &lt;- as.character(1:nrow(W))
y &lt;- rowSums(W[, 1:10]) + rowSums(W[, 501:510]) + rnorm(nrow(W))

# Create model
data &lt;- data.frame(y = y, mu = 1)
fm &lt;- y ~ 0 + mu
X &lt;- model.matrix(fm, data = data)

# Compute GRM
GRM &lt;- grm(W = W)

# REML analyses
fitG &lt;- greml(y = y, X = X, GRM = list(GRM))


# REML analyses and cross validation

# Create marker sets
setsGB &lt;- list(A = colnames(W)) # gblup model
setsGF &lt;- list(C1 = colnames(W)[1:500], C2 = colnames(W)[501:1000]) # gfblup model
setsGT &lt;- list(C1 = colnames(W)[1:10], C2 = colnames(W)[501:510]) # true model

GB &lt;- lapply(setsGB, function(x) {grm(W = W[, x])})
GF &lt;- lapply(setsGF, function(x) {grm(W = W[, x])})
GT &lt;- lapply(setsGT, function(x) {grm(W = W[, x])})

n &lt;- length(y)
fold &lt;- 10
nvalid &lt;- 5

validate &lt;- replicate(nvalid, sample(1:n, as.integer(n / fold)))
cvGB &lt;- greml(y = y, X = X, GRM = GB, validate = validate)
cvGF &lt;- greml(y = y, X = X, GRM = GF, validate = validate)
cvGT &lt;- greml(y = y, X = X, GRM = GT, validate = validate)

cvGB$accuracy
cvGF$accuracy
cvGT$accuracy



</code></pre>

<hr>
<h2 id='grm'>Computing the genomic relationship matrix (GRM)</h2><span id='topic+grm'></span>

<h3>Description</h3>

<p>The grm function is used to compute a genomic relationship matrix (GRM) based on all,
or a subset of marker genotypes. GRM for additive, and non-additive (dominance and
epistasis) genetic models can be constructed. The output of the grm function can either be a
within-memory GRM object (n x n matrix), or a GRM-list which is a list structure that
contains information about the GRM stored in a binary file on the disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grm(
  Glist = NULL,
  GRMlist = NULL,
  ids = NULL,
  rsids = NULL,
  rws = NULL,
  cls = NULL,
  W = NULL,
  method = "add",
  scale = TRUE,
  msize = 100,
  ncores = 1,
  fnG = NULL,
  overwrite = FALSE,
  returnGRM = FALSE,
  miss = NA,
  impute = TRUE,
  pedigree = NULL,
  task = "grm"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grm_+3A_glist">Glist</code></td>
<td>
<p>list providing information about genotypes stored on disk</p>
</td></tr>
<tr><td><code id="grm_+3A_grmlist">GRMlist</code></td>
<td>
<p>list providing information about GRM matrix stored in binary files on disk</p>
</td></tr>
<tr><td><code id="grm_+3A_ids">ids</code></td>
<td>
<p>vector of individuals used for computing GRM</p>
</td></tr>
<tr><td><code id="grm_+3A_rsids">rsids</code></td>
<td>
<p>vector marker rsids used for computing GRM</p>
</td></tr>
<tr><td><code id="grm_+3A_rws">rws</code></td>
<td>
<p>rows in genotype matrix used for computing GRM</p>
</td></tr>
<tr><td><code id="grm_+3A_cls">cls</code></td>
<td>
<p>columns in genotype matrix used for computing GRM</p>
</td></tr>
<tr><td><code id="grm_+3A_w">W</code></td>
<td>
<p>matrix of centered and scaled genotypes</p>
</td></tr>
<tr><td><code id="grm_+3A_method">method</code></td>
<td>
<p>indicator of method used for computing GRM: additive (add, default), dominance (dom) or epistasis (epi-pairs or epi-hadamard (all genotype markers))</p>
</td></tr>
<tr><td><code id="grm_+3A_scale">scale</code></td>
<td>
<p>logical if TRUE the genotypes in Glist has been scaled to mean zero and variance one</p>
</td></tr>
<tr><td><code id="grm_+3A_msize">msize</code></td>
<td>
<p>number of genotype markers used for batch processing</p>
</td></tr>
<tr><td><code id="grm_+3A_ncores">ncores</code></td>
<td>
<p>number of cores used to compute the GRM</p>
</td></tr>
<tr><td><code id="grm_+3A_fng">fnG</code></td>
<td>
<p>name of the binary file used for storing the GRM on disk</p>
</td></tr>
<tr><td><code id="grm_+3A_overwrite">overwrite</code></td>
<td>
<p>logical if TRUE the binary file fnG will be overwritten</p>
</td></tr>
<tr><td><code id="grm_+3A_returngrm">returnGRM</code></td>
<td>
<p>logical if TRUE function returns the GRM matrix to the R environment</p>
</td></tr>
<tr><td><code id="grm_+3A_miss">miss</code></td>
<td>
<p>the missing code (miss=NA is default) used for missing values in the genotype data</p>
</td></tr>
<tr><td><code id="grm_+3A_impute">impute</code></td>
<td>
<p>if missing values in the genotype matrix W then mean impute</p>
</td></tr>
<tr><td><code id="grm_+3A_pedigree">pedigree</code></td>
<td>
<p>is a dataframe with pedigree information</p>
</td></tr>
<tr><td><code id="grm_+3A_task">task</code></td>
<td>
<p>either computation of GRM (task=&quot;grm&quot;  which is default) or eigenvalue decomposition of GRM (task=&quot;eigen&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a genomic relationship matrix (GRM) if returnGRM=TRUE else a list structure (GRMlist) with information about the GRM  stored on disk
</p>


<h3>Author(s)</h3>

<p>Peter Soerensen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate data
W &lt;- matrix(rnorm(1000000), ncol = 1000)
	colnames(W) &lt;- as.character(1:ncol(W))
	rownames(W) &lt;- as.character(1:nrow(W))

# Compute GRM
GRM &lt;- grm(W = W)



# Eigen value decompostion GRM
eig &lt;- grm(GRM=GRM, task="eigen")


</code></pre>

<hr>
<h2 id='gscore'>Genomic scoring based on single marker summary statistics</h2><span id='topic+gscore'></span>

<h3>Description</h3>

<p>Computes genomic predictions using single marker summary statistics and observed genotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gscore(
  Glist = NULL,
  chr = NULL,
  bedfiles = NULL,
  bimfiles = NULL,
  famfiles = NULL,
  stat = NULL,
  fit = NULL,
  ids = NULL,
  scaleMarker = TRUE,
  scaleGRS = TRUE,
  impute = TRUE,
  msize = 100,
  ncores = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gscore_+3A_glist">Glist</code></td>
<td>
<p>List of information about genotype matrix. Default is NULL.</p>
</td></tr>
<tr><td><code id="gscore_+3A_chr">chr</code></td>
<td>
<p>Chromosome for which genomic scores is computed. Default is NULL.</p>
</td></tr>
<tr><td><code id="gscore_+3A_bedfiles">bedfiles</code></td>
<td>
<p>Names of the PLINK bed-files. Default is NULL.</p>
</td></tr>
<tr><td><code id="gscore_+3A_bimfiles">bimfiles</code></td>
<td>
<p>Names of the PLINK bim-files. Default is NULL.</p>
</td></tr>
<tr><td><code id="gscore_+3A_famfiles">famfiles</code></td>
<td>
<p>Names of the PLINK fam-files. Default is NULL.</p>
</td></tr>
<tr><td><code id="gscore_+3A_stat">stat</code></td>
<td>
<p>Matrix of single marker effects. Default is NULL.</p>
</td></tr>
<tr><td><code id="gscore_+3A_fit">fit</code></td>
<td>
<p>Fit object output from gbayes. Default is NULL.</p>
</td></tr>
<tr><td><code id="gscore_+3A_ids">ids</code></td>
<td>
<p>Vector of individuals used in the analysis. Default is NULL.</p>
</td></tr>
<tr><td><code id="gscore_+3A_scalemarker">scaleMarker</code></td>
<td>
<p>Logical; if TRUE the genotype markers are scaled to mean zero and variance one. Default is TRUE.</p>
</td></tr>
<tr><td><code id="gscore_+3A_scalegrs">scaleGRS</code></td>
<td>
<p>Logical; if TRUE the GRS are scaled to mean zero and variance one. Default is TRUE.</p>
</td></tr>
<tr><td><code id="gscore_+3A_impute">impute</code></td>
<td>
<p>Logical; if TRUE, missing genotypes are set to its expected value (2*af where af is allele frequency). Default is TRUE.</p>
</td></tr>
<tr><td><code id="gscore_+3A_msize">msize</code></td>
<td>
<p>Number of genotype markers used for batch processing. Default is 100.</p>
</td></tr>
<tr><td><code id="gscore_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores used in the analysis. Default is 1.</p>
</td></tr>
<tr><td><code id="gscore_+3A_verbose">verbose</code></td>
<td>
<p>Logical; if TRUE, more details are printed during optimization. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the genomic scores based on the provided parameters.
</p>


<h3>Author(s)</h3>

<p>Peter Soerensen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Plink bed/bim/fam files
 bedfiles &lt;- system.file("extdata", paste0("sample_chr",1:2,".bed"), package = "qgg")
 bimfiles &lt;- system.file("extdata", paste0("sample_chr",1:2,".bim"), package = "qgg")
 famfiles &lt;- system.file("extdata", paste0("sample_chr",1:2,".fam"), package = "qgg")
 
 # Summarize bed/bim/fam files
 Glist &lt;- gprep(study="Example", bedfiles=bedfiles, bimfiles=bimfiles, famfiles=famfiles)
 
 # Simulate phenotype
 sim &lt;- gsim(Glist=Glist, chr=1, nt=1)
 
 # Compute single marker summary statistics
 stat &lt;- glma(y=sim$y, Glist=Glist, scale=FALSE)
 
 # Compute genomic scores
 gsc &lt;- gscore(Glist = Glist, stat = stat)
 
</code></pre>

<hr>
<h2 id='gsea'>Gene set enrichment analysis</h2><span id='topic+gsea'></span>

<h3>Description</h3>

<p>The function gsea can perform several different gene set enrichment analyses. The general procedure is to obtain
single marker statistics (e.g. summary statistics), from which it is possible to compute and evaluate a test statistic
for a set of genetic markers that measures a joint degree of association between the marker set and the phenotype.
The marker set is defined by a genomic feature such as genes, biological pathways, gene interactions,
gene expression profiles etc.
</p>
<p>Currently, four types of gene set enrichment analyses can be conducted with gsea; sum-based, count-based,
score-based, and our own developed method, the covariance association test (CVAT). For details and comparisons of
test statistics consult doi:10.1534/genetics.116.189498.
</p>
<p>The sum test is based on the sum of all marker summary statistics located within the feature set. The single marker
summary statistics can be obtained from linear model analyses (from PLINK or using the qgg glma approximation),
or from single or multiple component REML analyses (GBLUP or GFBLUP) from the greml function. The sum test is powerful
if the genomic feature harbors many genetic markers that have small to moderate effects.
</p>
<p>The count-based method is based on counting the number of markers within a genomic feature that show association
(or have single marker p-value below a certain threshold) with the phenotype. Under the null hypothesis (that the
associated markers are picked at random from the total number of markers, thus, no enrichment of markers in any
genomic feature) it is assumed that the observed count statistic is a realization from a hypergeometric distribution.
</p>
<p>The score-based approach is based on the product between the scaled genotypes in a genomic feature and the residuals
from the liner mixed model (obtained from greml).
</p>
<p>The covariance association test (CVAT) is derived from the fit object from greml (GBLUP or GFBLUP), and measures
the covariance between the total genomic effects for all markers and the genomic effects of the markers within the
genomic feature.
</p>
<p>The distribution of the test statistics obtained from the sum-based, score-based and CVAT is unknown, therefore
a circular permutation approach is used to obtain an empirical distribution of test statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsea(
  stat = NULL,
  sets = NULL,
  Glist = NULL,
  W = NULL,
  fit = NULL,
  g = NULL,
  e = NULL,
  threshold = 0.05,
  method = "sum",
  nperm = 1000,
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsea_+3A_stat">stat</code></td>
<td>
<p>vector or matrix of single marker statistics (e.g. coefficients, t-statistics, p-values)</p>
</td></tr>
<tr><td><code id="gsea_+3A_sets">sets</code></td>
<td>
<p>list of marker sets - names corresponds to row names in stat</p>
</td></tr>
<tr><td><code id="gsea_+3A_glist">Glist</code></td>
<td>
<p>list providing information about genotypes stored on disk</p>
</td></tr>
<tr><td><code id="gsea_+3A_w">W</code></td>
<td>
<p>matrix of centered and scaled genotypes (used if method = cvat or score)</p>
</td></tr>
<tr><td><code id="gsea_+3A_fit">fit</code></td>
<td>
<p>list object obtained from a linear mixed model fit using the greml function</p>
</td></tr>
<tr><td><code id="gsea_+3A_g">g</code></td>
<td>
<p>vector (or matrix) of genetic effects obtained from a linear mixed model fit (GBLUP of GFBLUP)</p>
</td></tr>
<tr><td><code id="gsea_+3A_e">e</code></td>
<td>
<p>vector (or matrix) of residual effects obtained from a linear mixed model fit (GBLUP of GFBLUP)</p>
</td></tr>
<tr><td><code id="gsea_+3A_threshold">threshold</code></td>
<td>
<p>used if method='hyperg' (threshold=0.05 is default)</p>
</td></tr>
<tr><td><code id="gsea_+3A_method">method</code></td>
<td>
<p>including sum, cvat, hyperg, score</p>
</td></tr>
<tr><td><code id="gsea_+3A_nperm">nperm</code></td>
<td>
<p>number of permutations used for obtaining an empirical p-value</p>
</td></tr>
<tr><td><code id="gsea_+3A_ncores">ncores</code></td>
<td>
<p>number of cores used in the analysis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe or a list including
</p>
<table>
<tr><td><code>stat</code></td>
<td>
<p>marker set test statistics</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>number of markers in the set</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>enrichment p-value for marker set</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Soerensen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 # Simulate data
 W &lt;- matrix(rnorm(1000000), ncol = 1000)
 colnames(W) &lt;- as.character(1:ncol(W))
 rownames(W) &lt;- as.character(1:nrow(W))
 y &lt;- rowSums(W[, 1:10]) + rowSums(W[, 501:510]) + rnorm(nrow(W))

 # Create model
 data &lt;- data.frame(y = y, mu = 1)
 fm &lt;- y ~ 0 + mu
 X &lt;- model.matrix(fm, data = data)

 # Single marker association analyses
 stat &lt;- glma(y=y,X=X,W=W)

 # Create marker sets
 f &lt;- factor(rep(1:100,each=10), levels=1:100)
 sets &lt;- split(as.character(1:1000),f=f)

 # Set test based on sums
 b2 &lt;- stat[,"stat"]**2
 names(b2) &lt;- rownames(stat)
 mma &lt;- gsea(stat = b2, sets = sets, method = "sum", nperm = 100)
 head(mma)

 # Set test based on hyperG
 p &lt;- stat[,"p"]
 names(p) &lt;- rownames(stat)
 mma &lt;- gsea(stat = p, sets = sets, method = "hyperg", threshold = 0.05)
 head(mma)


 G &lt;- grm(W=W)
 fit &lt;- greml(y=y, X=X, GRM=list(G=G), theta=c(10,1))

 # Set test based on cvat
 mma &lt;- gsea(W=W,fit = fit, sets = sets, nperm = 1000, method="cvat")
 head(mma)

 # Set test based on score
 mma &lt;- gsea(W=W,fit = fit, sets = sets, nperm = 1000, method="score")
 head(mma)


</code></pre>

<hr>
<h2 id='gsim'>Genomic simulation</h2><span id='topic+gsim'></span>

<h3>Description</h3>

<p>Simulate Genotype and Phenotype Data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsim(Glist = NULL, chr = 1, nt = 1, W = NULL, n = 1000, m = 1000, rsids = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsim_+3A_glist">Glist</code></td>
<td>
<p>A list of information about the genotype matrix. Default is 'NULL'.</p>
</td></tr>
<tr><td><code id="gsim_+3A_chr">chr</code></td>
<td>
<p>The chromosome(s) being used in the simulation. Default is 1.</p>
</td></tr>
<tr><td><code id="gsim_+3A_nt">nt</code></td>
<td>
<p>Number of traits. Default is 1.</p>
</td></tr>
<tr><td><code id="gsim_+3A_w">W</code></td>
<td>
<p>Matrix of centered and scaled genotypes. Default is 'NULL'.</p>
</td></tr>
<tr><td><code id="gsim_+3A_n">n</code></td>
<td>
<p>Number of individuals. Default is 1000.</p>
</td></tr>
<tr><td><code id="gsim_+3A_m">m</code></td>
<td>
<p>Number of markers. Default is 1000.</p>
</td></tr>
<tr><td><code id="gsim_+3A_rsids">rsids</code></td>
<td>
<p>A character vector of rsids. Default is 'NULL'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simulates genotype and phenotype data based on the 'Glist', which is 
information about the genotype matrix.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>y</code>: Phenotypes.
</p>
</li>
<li> <p><code>W</code>: Matrix of centered and scaled genotypes.
</p>
</li>
<li> <p><code>e</code>: Errors.
</p>
</li>
<li> <p><code>g</code>: Genotype effect.
</p>
</li>
<li> <p><code>b0</code>, <code>b1</code>: Coefficients.
</p>
</li>
<li> <p><code>set0</code>, <code>set1</code>: Selected markers.
</p>
</li>
<li> <p><code>causal</code>: Causal markers.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Peter Soerensen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Plink bed/bim/fam files
bedfiles &lt;- system.file("extdata", paste0("sample_chr",1:2,".bed"), package = "qgg")
bimfiles &lt;- system.file("extdata", paste0("sample_chr",1:2,".bim"), package = "qgg")
famfiles &lt;- system.file("extdata", paste0("sample_chr",1:2,".fam"), package = "qgg")

# Summarize bed/bim/fam files
Glist &lt;- gprep(study="Example", bedfiles=bedfiles, bimfiles=bimfiles, famfiles=famfiles)

# Simulate phenotype
sim &lt;- gsim(Glist=Glist, chr=1, nt=1)
head(sim$y)
head(sim$e)
head(sim$causal)

</code></pre>

<hr>
<h2 id='gsolve'>Solve linear mixed model equations</h2><span id='topic+gsolve'></span>

<h3>Description</h3>

<p>The gsolve function is used for solving of linear mixed model equations. The algorithm used to solve the equation
system is based on a Gauss-Seidel (GS) method (matrix-free with residual updates) that handles large data sets.
</p>
<p>The linear mixed model fitted can account for multiple traits, multiple genetic factors (fixed or random genetic
marker effects), adjust for complex family relationships or population stratification, and adjust for other
non-genetic factors including lifestyle characteristics. Different genetic architectures (infinitesimal,
few large and many small effects) is accounted for by modeling genetic markers in different sets as fixed or
random effects and by specifying individual genetic marker weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsolve(
  y = NULL,
  X = NULL,
  GRM = NULL,
  va = NULL,
  ve = NULL,
  Glist = NULL,
  W = NULL,
  ids = NULL,
  rsids = NULL,
  sets = NULL,
  scale = TRUE,
  lambda = NULL,
  weights = FALSE,
  maxit = 500,
  tol = 1e-05,
  method = "gsru",
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsolve_+3A_y">y</code></td>
<td>
<p>vector or matrix of phenotypes</p>
</td></tr>
<tr><td><code id="gsolve_+3A_x">X</code></td>
<td>
<p>design matrix of fixed effects</p>
</td></tr>
<tr><td><code id="gsolve_+3A_grm">GRM</code></td>
<td>
<p>genetic relationship matrix</p>
</td></tr>
<tr><td><code id="gsolve_+3A_va">va</code></td>
<td>
<p>genetic variance</p>
</td></tr>
<tr><td><code id="gsolve_+3A_ve">ve</code></td>
<td>
<p>residual variance</p>
</td></tr>
<tr><td><code id="gsolve_+3A_glist">Glist</code></td>
<td>
<p>list of information about genotype matrix stored on disk</p>
</td></tr>
<tr><td><code id="gsolve_+3A_w">W</code></td>
<td>
<p>matrix of centered and scaled genotypes</p>
</td></tr>
<tr><td><code id="gsolve_+3A_ids">ids</code></td>
<td>
<p>vector of individuals used in the analysis</p>
</td></tr>
<tr><td><code id="gsolve_+3A_rsids">rsids</code></td>
<td>
<p>vector of marker rsids used in the analysis</p>
</td></tr>
<tr><td><code id="gsolve_+3A_sets">sets</code></td>
<td>
<p>list containing marker sets rsids</p>
</td></tr>
<tr><td><code id="gsolve_+3A_scale">scale</code></td>
<td>
<p>logical if TRUE the genotypes in Glist will be scaled to mean zero and variance one</p>
</td></tr>
<tr><td><code id="gsolve_+3A_lambda">lambda</code></td>
<td>
<p>overall shrinkage factor</p>
</td></tr>
<tr><td><code id="gsolve_+3A_weights">weights</code></td>
<td>
<p>vector of single marker weights used in BLUP</p>
</td></tr>
<tr><td><code id="gsolve_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations used in the Gauss-Seidel procedure</p>
</td></tr>
<tr><td><code id="gsolve_+3A_tol">tol</code></td>
<td>
<p>tolerance, i.e. the maximum allowed difference between two consecutive iterations of the solver to declare convergence</p>
</td></tr>
<tr><td><code id="gsolve_+3A_method">method</code></td>
<td>
<p>used in solver (currently only methods=&quot;gsru&quot;: gauss-seidel with resiudal update)</p>
</td></tr>
<tr><td><code id="gsolve_+3A_ncores">ncores</code></td>
<td>
<p>number of cores used in the analysis</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Soerensen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate data
W &lt;- matrix(rnorm(1000000), ncol = 1000)
	colnames(W) &lt;- as.character(1:ncol(W))
	rownames(W) &lt;- as.character(1:nrow(W))
m &lt;- ncol(W)
causal &lt;- sample(1:ncol(W),50)
y &lt;- rowSums(W[,causal]) + rnorm(nrow(W),sd=sqrt(50))

X &lt;- model.matrix(y~1)

Sg &lt;- 50
Se &lt;- 50
h2 &lt;- Sg/(Sg+Se)
lambda &lt;- Se/(Sg/m)
lambda &lt;- m*(1-h2)/h2

# BLUP of single marker effects and total genomic effects based on Gauss-Seidel procedure
fit &lt;- gsolve( y=y, X=X, W=W, lambda=lambda)

</code></pre>

<hr>
<h2 id='hwe'>Perform Hardy Weinberg Equilibrium Test</h2><span id='topic+hwe'></span>

<h3>Description</h3>

<p>Perform Hardy Weinberg Equilibrium Test ££(HWE)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hwe(Glist = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hwe_+3A_glist">Glist</code></td>
<td>
<p>is a list structure with information about genotypes stored on disk</p>
</td></tr>
</table>

<hr>
<h2 id='ldsc'>LD score regression</h2><span id='topic+ldsc'></span>

<h3>Description</h3>

<p>The ldsc function is used for LDSC analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ldsc(
  Glist = NULL,
  ldscores = NULL,
  z = NULL,
  b = NULL,
  seb = NULL,
  af = NULL,
  stat = NULL,
  n = NULL,
  intercept = TRUE,
  what = "h2",
  SE.h2 = FALSE,
  SE.rg = FALSE,
  blk = 200
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ldsc_+3A_glist">Glist</code></td>
<td>
<p>list of information about genotype matrix stored on disk</p>
</td></tr>
<tr><td><code id="ldsc_+3A_ldscores">ldscores</code></td>
<td>
<p>vector of LD scores (optional as LD scores are stored within Glist)</p>
</td></tr>
<tr><td><code id="ldsc_+3A_z">z</code></td>
<td>
<p>matrix of z statistics for n traits</p>
</td></tr>
<tr><td><code id="ldsc_+3A_b">b</code></td>
<td>
<p>matrix of marker effects for n traits if z matrix not is given</p>
</td></tr>
<tr><td><code id="ldsc_+3A_seb">seb</code></td>
<td>
<p>matrix of standard errors of marker effects for n traits if z matrix not is given</p>
</td></tr>
<tr><td><code id="ldsc_+3A_af">af</code></td>
<td>
<p>vector of allele frequencies</p>
</td></tr>
<tr><td><code id="ldsc_+3A_stat">stat</code></td>
<td>
<p>dataframe with marker summary statistics</p>
</td></tr>
<tr><td><code id="ldsc_+3A_n">n</code></td>
<td>
<p>vector of sample sizes for the traits (element i corresponds to column vector i in z matrix)</p>
</td></tr>
<tr><td><code id="ldsc_+3A_intercept">intercept</code></td>
<td>
<p>logical if TRUE the LD score regression includes intercept</p>
</td></tr>
<tr><td><code id="ldsc_+3A_what">what</code></td>
<td>
<p>either computation of heritability (what=&quot;h2&quot;) or genetic correlation between traits (what=&quot;rg&quot;)</p>
</td></tr>
<tr><td><code id="ldsc_+3A_se.h2">SE.h2</code></td>
<td>
<p>logical if TRUE standard errors and significance for the heritability estimates are computed using a block jackknife approach</p>
</td></tr>
<tr><td><code id="ldsc_+3A_se.rg">SE.rg</code></td>
<td>
<p>logical if TRUE standard errors and significance for the genetic correlations are computed using a block jackknife approach</p>
</td></tr>
<tr><td><code id="ldsc_+3A_blk">blk</code></td>
<td>
<p>numeric size of the blocks used in the jackknife estimation of standard error (default = 200)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of heritability estimates when what=&quot;h2&quot;, and if SE.h2=TRUE standard errors (SE) and significance levels (P) are returned. 
If what=&quot;rg&quot; an n-by-n matrix of correlations is returned where the diagonal elements being h2 estimates. 
If SE.rg=TRUE a list is returned with n-by-n matrices of genetic correlations, estimated standard errors and significance levels.
</p>


<h3>Author(s)</h3>

<p>Peter Soerensen
</p>
<p>Palle Duun Rohde
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Plink bed/bim/fam files
 #bedfiles &lt;- system.file("extdata", paste0("sample_chr",1:2,".bed"), package = "qgg")
 #bimfiles &lt;- system.file("extdata", paste0("sample_chr",1:2,".bim"), package = "qgg")
 #famfiles &lt;- system.file("extdata", paste0("sample_chr",1:2,".fam"), package = "qgg")
 #
 ## Summarize bed/bim/fam files
 #Glist &lt;- gprep(study="Example", bedfiles=bedfiles, bimfiles=bimfiles, famfiles=famfiles)

 #
 ## Filter rsids based on MAF, missingness, HWE
 #rsids &lt;-  gfilter(Glist = Glist, excludeMAF=0.05, excludeMISS=0.05, excludeHWE=1e-12) 
 #
 ## Compute sparse LD (msize=size of LD window)
 ##ldfiles &lt;- system.file("extdata", paste0("sample_chr",1:2,".ld"), package = "qgg")
 ##Glist &lt;- gprep(Glist, task="sparseld", msize=200, rsids=rsids, ldfiles=ldfiles, overwrite=TRUE)
 #
 #
 ##Simulate data
 #W1 &lt;- getG(Glist, chr=1, scale=TRUE)
 #W2 &lt;- getG(Glist, chr=2, scale=TRUE)

 #W &lt;- cbind(W1,W2)
 #causal &lt;- sample(1:ncol(W),5)

 #b1 &lt;- rnorm(length(causal))
 #b2 &lt;- rnorm(length(causal))
 #y1 &lt;- W[, causal]%*%b1 + rnorm(nrow(W))
 #y2 &lt;- W[, causal]%*%b2 + rnorm(nrow(W))

 #data1 &lt;- data.frame(y = y1, mu = 1)
 #data2 &lt;- data.frame(y = y2, mu = 1)
 #X1 &lt;- model.matrix(y ~ 0 + mu, data = data1)
 #X2 &lt;- model.matrix(y ~ 0 + mu, data = data2)

 ## Linear model analyses and single marker association test
 #maLM1 &lt;- lma(y=y1, X=X1,W = W)
 #maLM2 &lt;- lma(y=y2,X=X2,W = W)
 #
 ## Compute heritability and genetic correlations for trait 1 and 2
 #z1 &lt;- maLM1[,"stat"]
 #z2 &lt;- maLM2[,"stat"]

 #z &lt;- cbind(z1=z1,z2=z2)

 #h2 &lt;- ldsc(Glist, z=z, n=c(500,500), what="h2")
 #rg &lt;- ldsc(Glist, z=z, n=c(500,500), what="rg")



</code></pre>

<hr>
<h2 id='ldscore'>Compute LD (Linkage Disequilibrium) Scores for a Given Chromosome.</h2><span id='topic+ldscore'></span>

<h3>Description</h3>

<p>This function calculates LD scores for the specified chromosome(s) based on genotypic data provided in 'Glist'.
The LD score quantifies the amount of Linkage Disequilibrium at a given SNP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ldscore(
  Glist = NULL,
  chr = NULL,
  onebased = TRUE,
  nbytes = 4,
  cm = NULL,
  kb = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ldscore_+3A_glist">Glist</code></td>
<td>
<p>A list structure with genotypic data stored, including positions ('pos'), map information ('map'), rsids for LD calculation ('rsidsLD'), and LD file locations ('ldfiles').</p>
</td></tr>
<tr><td><code id="ldscore_+3A_chr">chr</code></td>
<td>
<p>A single chromosome or a vector of chromosomes for which LD scores need to be computed. Default is NULL, implying all chromosomes in 'Glist' will be used.</p>
</td></tr>
<tr><td><code id="ldscore_+3A_onebased">onebased</code></td>
<td>
<p>Logical, if 'TRUE', the indexing of positions and other genomic information is 1-based. Default is 'TRUE'.</p>
</td></tr>
<tr><td><code id="ldscore_+3A_nbytes">nbytes</code></td>
<td>
<p>The size (in bytes) of each numeric value to read from the binary LD files. Default is 4.</p>
</td></tr>
<tr><td><code id="ldscore_+3A_cm">cm</code></td>
<td>
<p>The threshold in centiMorgans for filtering LD values. Default is NULL.</p>
</td></tr>
<tr><td><code id="ldscore_+3A_kb">kb</code></td>
<td>
<p>The threshold in kilobases for filtering LD values. Default is NULL. If specified, it will be converted to base pairs internally.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the LD scores for each SNP by reading LD values from binary files stored in 'Glist$ldfiles'.
It can filter SNPs based on physical distance ('kb') or genetic map distance ('cm'). 
If both 'cm' and 'kb' are NULL, all LD values are used in computation.
</p>


<h3>Value</h3>

<p>A list containing computed LD scores for each chromosome in the input.
</p>

<hr>
<h2 id='mapSets'>Map Sets to RSIDs</h2><span id='topic+mapSets'></span>

<h3>Description</h3>

<p>This function maps sets to rsids. If a 'Glist' is provided, 'rsids' are extracted from the 'Glist'.
It returns a list of matched RSIDs for each set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapSets(sets = NULL, rsids = NULL, Glist = NULL, index = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapSets_+3A_sets">sets</code></td>
<td>
<p>A list of character vectors where each vector represents a set of items. If the names
of the sets are not provided, they are named as &quot;Set1&quot;, &quot;Set2&quot;, etc.</p>
</td></tr>
<tr><td><code id="mapSets_+3A_rsids">rsids</code></td>
<td>
<p>A character vector of RSIDs. If 'Glist' is provided, this parameter is ignored.</p>
</td></tr>
<tr><td><code id="mapSets_+3A_glist">Glist</code></td>
<td>
<p>A list containing an element 'rsids' which is a character vector of RSIDs.</p>
</td></tr>
<tr><td><code id="mapSets_+3A_index">index</code></td>
<td>
<p>A logical. If 'TRUE' (default), it returns indices of RSIDs; otherwise, it returns the RSID names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list where each element represents a set and contains matched RSIDs or their indices.
</p>

<hr>
<h2 id='mapStat'>Map marker summary statistics to Glist</h2><span id='topic+mapStat'></span>

<h3>Description</h3>

<p>Quality control is a critical step for working with summary statistics (in particular
for external). 
Processing and quality control of GWAS summary statistics includes:                                                                      
</p>
<p>- map marker ids (rsids/cpra (chr, pos, ref, alt)) to LD reference panel data 
</p>
<p>- check effect allele (flip EA, EAF, Effect)
</p>
<p>- check effect allele frequency
</p>
<p>- thresholds for MAF and HWE
</p>
<p>- exclude INDELS, CG/AT and MHC region
</p>
<p>- remove duplicated marker ids
</p>
<p>- check which build version
</p>
<p>- check for concordance between marker effect and LD data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapStat(
  Glist = NULL,
  stat = NULL,
  excludeMAF = 0.01,
  excludeMAFDIFF = 0.05,
  excludeINFO = 0.8,
  excludeCGAT = TRUE,
  excludeINDEL = TRUE,
  excludeDUPS = TRUE,
  excludeMHC = FALSE,
  excludeMISS = 0.05,
  excludeHWE = 1e-12
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapStat_+3A_glist">Glist</code></td>
<td>
<p>list of information about genotype matrix stored on disk</p>
</td></tr>
<tr><td><code id="mapStat_+3A_stat">stat</code></td>
<td>
<p>dataframe with marker summary statistics</p>
</td></tr>
<tr><td><code id="mapStat_+3A_excludemaf">excludeMAF</code></td>
<td>
<p>exclude marker if minor allele frequency (MAF) is below threshold (0.01 is default)</p>
</td></tr>
<tr><td><code id="mapStat_+3A_excludemafdiff">excludeMAFDIFF</code></td>
<td>
<p>exclude marker if minor allele frequency difference (MAFDIFF) between Glist$af and stat$af is above threshold (0.05 is default)</p>
</td></tr>
<tr><td><code id="mapStat_+3A_excludeinfo">excludeINFO</code></td>
<td>
<p>exclude marker if info score (INFO) is below threshold (0.8 is default)</p>
</td></tr>
<tr><td><code id="mapStat_+3A_excludecgat">excludeCGAT</code></td>
<td>
<p>exclude marker if alleles are ambigous (CG or AT)</p>
</td></tr>
<tr><td><code id="mapStat_+3A_excludeindel">excludeINDEL</code></td>
<td>
<p>exclude marker if it an insertion/deletion</p>
</td></tr>
<tr><td><code id="mapStat_+3A_excludedups">excludeDUPS</code></td>
<td>
<p>exclude marker id if duplicated</p>
</td></tr>
<tr><td><code id="mapStat_+3A_excludemhc">excludeMHC</code></td>
<td>
<p>exclude marker if located in MHC region</p>
</td></tr>
<tr><td><code id="mapStat_+3A_excludemiss">excludeMISS</code></td>
<td>
<p>exclude marker if missingness (MISS) is above threshold (0.05 is default)</p>
</td></tr>
<tr><td><code id="mapStat_+3A_excludehwe">excludeHWE</code></td>
<td>
<p>exclude marker if p-value for Hardy Weinberg Equilibrium test is below threshold (0.01 is default)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Soerensen
</p>

<hr>
<h2 id='mergeGRM'>Merge multiple GRMlist objects</h2><span id='topic+mergeGRM'></span>

<h3>Description</h3>

<p>Merge multiple GRMlist objects each with information about a 
genomic rfelationship matrix stored on disk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeGRM(GRMlist = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeGRM_+3A_grmlist">GRMlist</code></td>
<td>
<p>list providing information about GRM matrix stored in binary files on disk</p>
</td></tr>
</table>

<hr>
<h2 id='mtadj'>Adjustment of marker effects using correlated trait information</h2><span id='topic+mtadj'></span>

<h3>Description</h3>

<p>The 'mtadj' function uses selection index theory to determine the optimal weights across 'n' traits. 
These weights are then used to adjust marker effects by 'n' correlated traits. 
More details can be found [here](https://www.nature.com/articles/s41467-017-02769-6).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtadj(
  h2 = NULL,
  rg = NULL,
  stat = NULL,
  b = NULL,
  z = NULL,
  n = NULL,
  mtotal = NULL,
  meff = 60000,
  method = "ols",
  statistics = "z"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtadj_+3A_h2">h2</code></td>
<td>
<p>A vector of heritability estimates.</p>
</td></tr>
<tr><td><code id="mtadj_+3A_rg">rg</code></td>
<td>
<p>An n-by-n matrix of genetic correlations.</p>
</td></tr>
<tr><td><code id="mtadj_+3A_stat">stat</code></td>
<td>
<p>A dataframe containing marker summary statistics.</p>
</td></tr>
<tr><td><code id="mtadj_+3A_b">b</code></td>
<td>
<p>A matrix of marker effects.</p>
</td></tr>
<tr><td><code id="mtadj_+3A_z">z</code></td>
<td>
<p>A matrix of z-scores.</p>
</td></tr>
<tr><td><code id="mtadj_+3A_n">n</code></td>
<td>
<p>A vector indicating the sample size used to estimate marker effects for each trait.</p>
</td></tr>
<tr><td><code id="mtadj_+3A_mtotal">mtotal</code></td>
<td>
<p>Total number of markers.</p>
</td></tr>
<tr><td><code id="mtadj_+3A_meff">meff</code></td>
<td>
<p>Effective number of uncorrelated genomic segments (default = 60,000).</p>
</td></tr>
<tr><td><code id="mtadj_+3A_method">method</code></td>
<td>
<p>Method to estimate marker effects. Can be &quot;OLS&quot; (ordinary least square, default) or &quot;BLUP&quot; (best linear unbiased prediction).</p>
</td></tr>
<tr><td><code id="mtadj_+3A_statistics">statistics</code></td>
<td>
<p>Specifies which kind of statistics (&quot;b&quot; or &quot;z&quot;) should be used in the analysis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of adjusted marker effects for each trait.
</p>


<h3>Author(s)</h3>

<p>Palle Duun Rohde and Peter Soerensen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 #bedfiles &lt;- system.file("extdata", "sample_22.bed", package = "qgg")
 #bimfiles &lt;- system.file("extdata", "sample_22.bim", package = "qgg")
 #famfiles &lt;- system.file("extdata", "sample_22.fam", package = "qgg")
 #Glist &lt;- gprep(study="1000G", bedfiles=bedfiles, bimfiles=bimfiles,famfiles=famfiles)
 #Glist &lt;- gprep(Glist, task="sparseld",  msize=200)
 #
 ##Simulate data
 #set.seed(23)
 #
 #W &lt;- getG(Glist, chr=1, scale=TRUE)
 #causal &lt;- sample(1:ncol(W),50)
 #set1 &lt;- c(causal, sample(c(1:ncol(W))[-causal],10))
 #set2 &lt;- c(causal, sample(c(1:ncol(W))[-set1],10))
 #
 #b1 &lt;- rnorm(length(set1))
 #b2 &lt;- rnorm(length(set2))
 #y1 &lt;- W[, set1]%*%b1 + rnorm(nrow(W))
 #y2 &lt;- W[, set2]%*%b2 + rnorm(nrow(W))
 #
 ## Create model
 #data1 &lt;- data.frame(y = y1, mu = 1)
 #data2 &lt;- data.frame(y = y2, mu = 1)
 #X1 &lt;- model.matrix(y ~ 0 + mu, data = data1)
 #X2 &lt;- model.matrix(y ~ 0 + mu, data = data2)
 #
 ## Linear model analyses and single marker association test
 #maLM1 &lt;- glma(y=y1, X=X1,W = W)
 #maLM2 &lt;- glma(y=y2,X=X2,W = W)
 #
 ## Compute genetic parameters
 #z1 &lt;- maLM1[,"stat"]
 #z2 &lt;- maLM2[,"stat"]
 #
 #z &lt;- cbind(z1=z1,z2=z2)
 #
 #h2 &lt;- ldsc(Glist, z=z, n=c(500,500), what="h2")
 #rg &lt;- ldsc(Glist, z=z, n=c(500,500), what="rg")
 #
 ## Adjust summary statistics using estimated genetic parameters
 #b &lt;- cbind(b1=maLM1[,"b"],b2=maLM2[,"b"])
 #bm &lt;- mtadj( h2=h2, rg=rg, b=b, n=c(500,500), method="ols")
 
 
</code></pre>

<hr>
<h2 id='plotBayes'>Plot fit from gbayes</h2><span id='topic+plotBayes'></span>

<h3>Description</h3>

<p>Summary plots from gbayes fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBayes(fit = NULL, causal = NULL, what = "bm", chr = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotBayes_+3A_fit">fit</code></td>
<td>
<p>object from gbayes</p>
</td></tr>
<tr><td><code id="plotBayes_+3A_causal">causal</code></td>
<td>
<p>indices for &quot;causal&quot; markers</p>
</td></tr>
<tr><td><code id="plotBayes_+3A_what">what</code></td>
<td>
<p>character fro what to plot (e.g. &quot;trace&quot;, &quot;bpm&quot;, &quot;ve&quot;, &quot;vg&quot;, &quot;vb&quot;)</p>
</td></tr>
<tr><td><code id="plotBayes_+3A_chr">chr</code></td>
<td>
<p>chromosome to plot</p>
</td></tr>
</table>

<hr>
<h2 id='plotForest'>Forest plot</h2><span id='topic+plotForest'></span>

<h3>Description</h3>

<p>This function generates a forest plot, which is commonly used to visualize
effect sizes and their confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotForest(
  x = NULL,
  sd = NULL,
  cex = 1,
  mar = NULL,
  mai = NULL,
  xlim = NULL,
  pos = NULL,
  reorder = TRUE,
  xaxis = TRUE,
  main = NULL,
  xlab = "x"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotForest_+3A_x">x</code></td>
<td>
<p>A vector of point estimates or effect sizes.</p>
</td></tr>
<tr><td><code id="plotForest_+3A_sd">sd</code></td>
<td>
<p>A vector of standard deviations corresponding to the values in 'x'.</p>
</td></tr>
<tr><td><code id="plotForest_+3A_cex">cex</code></td>
<td>
<p>A numerical value indicating the amount by which plotting text and symbols should be scaled. Default is 1.</p>
</td></tr>
<tr><td><code id="plotForest_+3A_mar">mar</code></td>
<td>
<p>A numerical vector of the form 'c(bottom, left, top, right)' which gives the number of lines of margin to be specified on the four sides of the plot. Default is 'c(5,12,3,1)'.</p>
</td></tr>
<tr><td><code id="plotForest_+3A_mai">mai</code></td>
<td>
<p>A numerical vector indicating the margins in inches.</p>
</td></tr>
<tr><td><code id="plotForest_+3A_xlim">xlim</code></td>
<td>
<p>The x limits (x1, x2) of the plot.</p>
</td></tr>
<tr><td><code id="plotForest_+3A_pos">pos</code></td>
<td>
<p>Position of y-axis labels.</p>
</td></tr>
<tr><td><code id="plotForest_+3A_reorder">reorder</code></td>
<td>
<p>A logical value. If 'TRUE', data points are reordered based on the values in 'x'. Default is 'TRUE'.</p>
</td></tr>
<tr><td><code id="plotForest_+3A_xaxis">xaxis</code></td>
<td>
<p>A logical value. If 'TRUE', x-axis is drawn. Default is 'TRUE'.</p>
</td></tr>
<tr><td><code id="plotForest_+3A_main">main</code></td>
<td>
<p>An overall title for the plot.</p>
</td></tr>
<tr><td><code id="plotForest_+3A_xlab">xlab</code></td>
<td>
<p>A label for the x-axis. Default is &quot;x&quot;.</p>
</td></tr>
</table>

<hr>
<h2 id='plotLD'>Plot LD Matrix</h2><span id='topic+plotLD'></span>

<h3>Description</h3>

<p>Visualizes the linkage disequilibrium (LD) matrix using a color gradient.
The function produces an image plot with custom color mapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLD(LD = NULL, cols = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotLD_+3A_ld">LD</code></td>
<td>
<p>A matrix representing the LD values to be plotted. Each element should be 
a numeric value, typically between 0 and 1, representing the degree of LD.
Rows and columns of the matrix should correspond to specific genetic markers (e.g., SNPs).</p>
</td></tr>
<tr><td><code id="plotLD_+3A_cols">cols</code></td>
<td>
<p>A color palette to use for the plot. By default, it creates a blue gradient 
ranging from light blue ('#f0f3ff') to dark blue ('#0033BB').</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot visualizing the LD matrix. Row and column names of the LD matrix are used 
as labels on the x and y axes, respectively.
</p>

<hr>
<h2 id='plotROC'>Plot Receiver Operating Curves</h2><span id='topic+plotROC'></span>

<h3>Description</h3>

<p>Plot ROC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotROC(roc.data = NULL, cols = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotROC_+3A_roc.data">roc.data</code></td>
<td>
<p>data frame with ROC information (from computeROC)</p>
</td></tr>
<tr><td><code id="plotROC_+3A_cols">cols</code></td>
<td>
<p>which columns should be used in the ROC plot</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Palle Duun Rohde
</p>

<hr>
<h2 id='predict_auc_mt_cc'>Expected AUC for prediction of a binary trait using information on correlated binary trait</h2><span id='topic+predict_auc_mt_cc'></span>

<h3>Description</h3>

<p>Computes the expected Area Under the Curve (AUC) for predicting a binary trait using 
information on a correlated binary trait.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_auc_mt_cc(h2x, Nx, Kx, Px, h2y, Ny, Ky, Py, rg, Me, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_auc_mt_cc_+3A_h2x">h2x</code></td>
<td>
<p>Heritability of the target trait.</p>
</td></tr>
<tr><td><code id="predict_auc_mt_cc_+3A_nx">Nx</code></td>
<td>
<p>Number of samples for the target trait.</p>
</td></tr>
<tr><td><code id="predict_auc_mt_cc_+3A_kx">Kx</code></td>
<td>
<p>Prevalence of the target trait.</p>
</td></tr>
<tr><td><code id="predict_auc_mt_cc_+3A_px">Px</code></td>
<td>
<p>Case-control proportion of the target trait.</p>
</td></tr>
<tr><td><code id="predict_auc_mt_cc_+3A_h2y">h2y</code></td>
<td>
<p>Heritability of the correlated trait.</p>
</td></tr>
<tr><td><code id="predict_auc_mt_cc_+3A_ny">Ny</code></td>
<td>
<p>Number of samples for the correlated trait.</p>
</td></tr>
<tr><td><code id="predict_auc_mt_cc_+3A_ky">Ky</code></td>
<td>
<p>Prevalence of the correlated trait.</p>
</td></tr>
<tr><td><code id="predict_auc_mt_cc_+3A_py">Py</code></td>
<td>
<p>Case-control proportion of the correlated trait.</p>
</td></tr>
<tr><td><code id="predict_auc_mt_cc_+3A_rg">rg</code></td>
<td>
<p>Genetic correlation between the target and the correlated trait.</p>
</td></tr>
<tr><td><code id="predict_auc_mt_cc_+3A_me">Me</code></td>
<td>
<p>Number of independent chromosome segments.</p>
</td></tr>
<tr><td><code id="predict_auc_mt_cc_+3A_m">M</code></td>
<td>
<p>Number of markers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the expected AUC.
</p>

<hr>
<h2 id='predict_auc_mt_continuous'>Expected AUC for prediction of a binary trait using information on a correlated continuous trait</h2><span id='topic+predict_auc_mt_continuous'></span>

<h3>Description</h3>

<p>Computes the expected Area Under the Curve (AUC) for predicting a binary trait using 
information from a correlated continuous trait.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_auc_mt_continuous(h2x, Nx, Kx, Px, h2y, Ny, rg, Me, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_auc_mt_continuous_+3A_h2x">h2x</code></td>
<td>
<p>Heritability of the target trait.</p>
</td></tr>
<tr><td><code id="predict_auc_mt_continuous_+3A_nx">Nx</code></td>
<td>
<p>Number of samples for the target trait.</p>
</td></tr>
<tr><td><code id="predict_auc_mt_continuous_+3A_kx">Kx</code></td>
<td>
<p>Prevalence of the target trait.</p>
</td></tr>
<tr><td><code id="predict_auc_mt_continuous_+3A_px">Px</code></td>
<td>
<p>Case-control proportion of the target trait.</p>
</td></tr>
<tr><td><code id="predict_auc_mt_continuous_+3A_h2y">h2y</code></td>
<td>
<p>Heritability of the correlated trait.</p>
</td></tr>
<tr><td><code id="predict_auc_mt_continuous_+3A_ny">Ny</code></td>
<td>
<p>Number of samples for the correlated trait.</p>
</td></tr>
<tr><td><code id="predict_auc_mt_continuous_+3A_rg">rg</code></td>
<td>
<p>Genetic correlation between the target and correlated trait.</p>
</td></tr>
<tr><td><code id="predict_auc_mt_continuous_+3A_me">Me</code></td>
<td>
<p>Number of independent chromosome segments.</p>
</td></tr>
<tr><td><code id="predict_auc_mt_continuous_+3A_m">M</code></td>
<td>
<p>Number of markers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the expected AUC.
</p>

<hr>
<h2 id='predict_auc_st'>Expected AUC for prediction of a binary trait</h2><span id='topic+predict_auc_st'></span>

<h3>Description</h3>

<p>Computes the expected Area Under the Curve (AUC) for predicting a binary trait.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_auc_st(h2x, Nx, Kx, Px, Me, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_auc_st_+3A_h2x">h2x</code></td>
<td>
<p>Heritability of the target trait.</p>
</td></tr>
<tr><td><code id="predict_auc_st_+3A_nx">Nx</code></td>
<td>
<p>Number of samples for the target trait.</p>
</td></tr>
<tr><td><code id="predict_auc_st_+3A_kx">Kx</code></td>
<td>
<p>Prevalence of the target trait.</p>
</td></tr>
<tr><td><code id="predict_auc_st_+3A_px">Px</code></td>
<td>
<p>Case-control proportion of the target trait.</p>
</td></tr>
<tr><td><code id="predict_auc_st_+3A_me">Me</code></td>
<td>
<p>Number of independent chromosome segments.</p>
</td></tr>
<tr><td><code id="predict_auc_st_+3A_m">M</code></td>
<td>
<p>Number of markers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the expected AUC.
</p>

<hr>
<h2 id='predict_r2_mt'>Expected R2 for multiple trait prediction of continuous traits</h2><span id='topic+predict_r2_mt'></span>

<h3>Description</h3>

<p>Computes the expected R2 value for the multiple trait prediction of continuous traits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_r2_mt(h2x, Nx, h2y, Ny, rg, Me, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_r2_mt_+3A_h2x">h2x</code></td>
<td>
<p>Heritability of the target trait.</p>
</td></tr>
<tr><td><code id="predict_r2_mt_+3A_nx">Nx</code></td>
<td>
<p>Number of samples for the target trait.</p>
</td></tr>
<tr><td><code id="predict_r2_mt_+3A_h2y">h2y</code></td>
<td>
<p>Heritability of the correlated trait.</p>
</td></tr>
<tr><td><code id="predict_r2_mt_+3A_ny">Ny</code></td>
<td>
<p>Number of samples for the correlated trait.</p>
</td></tr>
<tr><td><code id="predict_r2_mt_+3A_rg">rg</code></td>
<td>
<p>Genetic correlation between the target and correlated trait.</p>
</td></tr>
<tr><td><code id="predict_r2_mt_+3A_me">Me</code></td>
<td>
<p>Number of independent chromosome segments.</p>
</td></tr>
<tr><td><code id="predict_r2_mt_+3A_m">M</code></td>
<td>
<p>Number of markers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the expected R2 for the multiple trait prediction.
</p>

<hr>
<h2 id='predict_r2_st'>Expected R2 for single trait prediction of a continuous trait</h2><span id='topic+predict_r2_st'></span>

<h3>Description</h3>

<p>Computes the expected R2 value for the single trait prediction of a continuous trait.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_r2_st(h2x, Nx, Me, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_r2_st_+3A_h2x">h2x</code></td>
<td>
<p>Heritability of the target trait.</p>
</td></tr>
<tr><td><code id="predict_r2_st_+3A_nx">Nx</code></td>
<td>
<p>Number of samples for the target trait.</p>
</td></tr>
<tr><td><code id="predict_r2_st_+3A_me">Me</code></td>
<td>
<p>Number of independent chromosome segments.</p>
</td></tr>
<tr><td><code id="predict_r2_st_+3A_m">M</code></td>
<td>
<p>Number of markers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the expected R2 for the single trait prediction.
</p>

<hr>
<h2 id='qcStat'>Quality Control of Marker Summary Statistics</h2><span id='topic+qcStat'></span>

<h3>Description</h3>

<p>Quality control is a fundamental step in GWAS summary statistics analysis.
The function is equipped to handle various tasks including mapping marker ids,
checking the effect allele and its frequency, determining build versions, and 
excluding data based on multiple criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qcStat(
  Glist = NULL,
  stat = NULL,
  excludeMAF = 0.01,
  excludeMAFDIFF = 0.05,
  excludeINFO = 0.8,
  excludeCGAT = TRUE,
  excludeINDEL = TRUE,
  excludeDUPS = TRUE,
  excludeMHC = FALSE,
  excludeMISS = 0.05,
  excludeHWE = 1e-12
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qcStat_+3A_glist">Glist</code></td>
<td>
<p>List containing information about genotype matrix stored on disk.</p>
</td></tr>
<tr><td><code id="qcStat_+3A_stat">stat</code></td>
<td>
<p>Data frame of marker summary statistics. It should either follow 
the &quot;internal&quot; or &quot;external&quot; format.</p>
</td></tr>
<tr><td><code id="qcStat_+3A_excludemaf">excludeMAF</code></td>
<td>
<p>Numeric. Exclusion threshold for minor allele frequency. Default is 0.01.</p>
</td></tr>
<tr><td><code id="qcStat_+3A_excludemafdiff">excludeMAFDIFF</code></td>
<td>
<p>Numeric. Threshold for excluding markers based on allele frequency difference. Default is 0.05.</p>
</td></tr>
<tr><td><code id="qcStat_+3A_excludeinfo">excludeINFO</code></td>
<td>
<p>Numeric. Exclusion threshold for info score. Default is 0.8.</p>
</td></tr>
<tr><td><code id="qcStat_+3A_excludecgat">excludeCGAT</code></td>
<td>
<p>Logical. Exclude ambiguous alleles (CG or AT). Default is TRUE.</p>
</td></tr>
<tr><td><code id="qcStat_+3A_excludeindel">excludeINDEL</code></td>
<td>
<p>Logical. Exclude insertion/deletion markers. Default is TRUE.</p>
</td></tr>
<tr><td><code id="qcStat_+3A_excludedups">excludeDUPS</code></td>
<td>
<p>Logical. Exclude markers with duplicated ids. Default is TRUE.</p>
</td></tr>
<tr><td><code id="qcStat_+3A_excludemhc">excludeMHC</code></td>
<td>
<p>Logical. Exclude markers located in MHC region. Default is FALSE.</p>
</td></tr>
<tr><td><code id="qcStat_+3A_excludemiss">excludeMISS</code></td>
<td>
<p>Numeric. Exclusion threshold for sample missingness. Default is 0.05.</p>
</td></tr>
<tr><td><code id="qcStat_+3A_excludehwe">excludeHWE</code></td>
<td>
<p>Numeric. Exclusion threshold for Hardy Weinberg Equilibrium test p-value. Default is 1e-12.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs quality control on GWAS summary statistics, which includes:
- Mapping marker ids to LD reference panel data.
- Checking effect allele, frequency, and build version.
- Excluding based on various criteria like MAF, HWE, INDELS, and more.
</p>
<p>The function works with both &quot;internal&quot; and &quot;external&quot; formats of summary statistics. 
When the summary statistics format is &quot;external&quot;, the function maps marker ids based 
on chr-pos-ref-alt information. It also aligns the effect allele with the LD reference 
panel and flips effect sizes if necessary. When allele frequencies are not provided, 
it uses the frequencies from the genotype data.
</p>
<p>Required headers for external summary statistics:
marker, chr, pos, ea, nea, eaf, b, seb, stat, p, n    
</p>
<p>Required headers for internal summary statistics:
rsids, chr, pos, ea, nea, eaf, b, seb, stat, p, n
</p>


<h3>Value</h3>

<p>A data frame with processed and quality-controlled summary statistics.
</p>


<h3>Author(s)</h3>

<p>Peter Soerensen
</p>

<hr>
<h2 id='rnag'>Compute Nagelkerke R2</h2><span id='topic+rnag'></span>

<h3>Description</h3>

<p>Compute Nagelkerke R2 ££ perhaps add: r2nag?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnag(yobs = NULL, ypred = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnag_+3A_yobs">yobs</code></td>
<td>
<p>is a vector of observed phenotypes</p>
</td></tr>
<tr><td><code id="rnag_+3A_ypred">ypred</code></td>
<td>
<p>is a vector of predicted phenotypes</p>
</td></tr>
</table>

<hr>
<h2 id='splitWithOverlap'>Split Vector with Overlapping Segments</h2><span id='topic+splitWithOverlap'></span>

<h3>Description</h3>

<p>Splits a vector into segments of a specified length with a specified overlap.
The function returns a list where each element contains a segment of the vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitWithOverlap(vec, seg.length, overlap)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitWithOverlap_+3A_vec">vec</code></td>
<td>
<p>A numeric or character vector to be split.</p>
</td></tr>
<tr><td><code id="splitWithOverlap_+3A_seg.length">seg.length</code></td>
<td>
<p>An integer specifying the length of each segment.</p>
</td></tr>
<tr><td><code id="splitWithOverlap_+3A_overlap">overlap</code></td>
<td>
<p>An integer specifying the number of overlapping elements between consecutive segments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list where each element is a segment of the input vector. The segments can overlap based on the specified overlap.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
