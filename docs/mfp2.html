<!DOCTYPE html><html lang="en-US"><head><title>Help for package mfp2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mfp2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#apply_acd'><p>Function to apply Approximate Cumulative Distribution (ACD)</p></a></li>
<li><a href='#apply_shift_scale'><p>Shift and scale vector x</p></a></li>
<li><a href='#art'><p>Artificial dataset with continuous response</p></a></li>
<li><a href='#assign_df'><p>Helper to assign degrees of freedom</p></a></li>
<li><a href='#calculate_df'><p>Helper to calculates the final degrees of freedom for the selected model</p></a></li>
<li><a href='#calculate_f_test'><p>Function to compute F-statistic and p-value from deviances</p></a></li>
<li><a href='#calculate_lr_test'><p>Function to calculate p-values for likelihood-ratio test</p></a></li>
<li><a href='#calculate_model_metrics'><p>Function to compute model metrics to be used within <code>mfp2</code></p></a></li>
<li><a href='#calculate_number_fp_powers'><p>Calculates the total number of fractional polynomial powers in adjustment variables.</p></a></li>
<li><a href='#calculate_standard_error'><p>Helper function to compute standard error of a partial predictor</p></a></li>
<li><a href='#center_matrix'><p>Simple function to center data</p></a></li>
<li><a href='#coef.mfp2'><p>Extract coefficients from object of class <code>mfp2</code></p></a></li>
<li><a href='#convert_powers_list_to_matrix'><p>Helper to convert a nested list with same or different length into a matrix</p></a></li>
<li><a href='#create_dummy_variables'><p>Simple function to create dummy variables for ordinal and nominal variables</p></a></li>
<li><a href='#create_fp_terms'><p>Helper to create overview table of fp terms</p></a></li>
<li><a href='#deviance_gaussian'><p>Deviance computations as used in mfp in stata</p></a></li>
<li><a href='#ensure_length'><p>Helper function to ensure vectors have a specified length</p></a></li>
<li><a href='#find_best_fp_cycle'><p>Helper to run cycles of the mfp algorithm</p></a></li>
<li><a href='#find_best_fp_step'><p>Function to estimate the best FP functions for a single variable</p></a></li>
<li><a href='#find_best_fp1_for_acd'><p>Function to fit univariable FP1 models for acd transformation</p></a></li>
<li><a href='#find_best_fpm_step'><p>Function to find the best FP functions of given degree for a single variable</p></a></li>
<li><a href='#find_scale_factor'><p>Function that calculates an integer used to scale predictor</p></a></li>
<li><a href='#find_shift_factor'><p>Function that calculates a value used to shift predictor</p></a></li>
<li><a href='#fit_acd'><p>Function to estimate approximate cumulative distribution (ACD)</p></a></li>
<li><a href='#fit_cox'><p>Function that fits Cox proportional hazards models</p></a></li>
<li><a href='#fit_glm'><p>Function that fits generalized linear models</p></a></li>
<li><a href='#fit_linear_step'><p>Function to fit linear model for variable of interest</p></a></li>
<li><a href='#fit_mfp'><p>Function for fitting a model using the MFP or MFPA algorithm</p></a></li>
<li><a href='#fit_model'><p>Function that fits models supported by <code>mfp2</code></p></a></li>
<li><a href='#fit_null_step'><p>Function to fit null model excluding variable of interest</p></a></li>
<li><a href='#fp'><p>Helper to assign attributes to a variable undergoing FP-transformation</p></a></li>
<li><a href='#fracplot'><p>Plot response functions from a fitted <code>mfp2</code> object</p></a></li>
<li><a href='#gbsg'><p>Breast cancer dataset used in the Royston and Sauerbrei (2008) book.</p></a></li>
<li><a href='#generate_combinations_with_replacement'><p>Helper function to generate combinations with replacement</p></a></li>
<li><a href='#generate_powers_fp'><p>Function that generates a matrix of FP powers for any degree</p></a></li>
<li><a href='#generate_transformations_fp'><p>Function to generate all requested FP transformations for a single variable</p></a></li>
<li><a href='#get_selected_variable_names'><p>Helper function to extract selected variables from fitted <code>mfp2</code> object</p></a></li>
<li><a href='#mfp2'><p>Multivariable Fractional Polynomial Models with Extensions</p></a></li>
<li><a href='#name_transformed_variables'><p>Helper function to name transformed variables</p></a></li>
<li><a href='#order_variables'><p>Helper to order variables for mfp2 algorithm</p></a></li>
<li><a href='#pima'><p>Pima Indians dataset used in the Royston and Sauerbrei (2008) book.</p></a></li>
<li><a href='#predict.mfp2'><p>Predict Method for <code>mfp2</code> Fits</p></a></li>
<li><a href='#prepare_newdata_for_predict'><p>Helper function to prepare newdata for predict function</p></a></li>
<li><a href='#print_mfp_step'><p>Function for verbose printing of function selection procedure (FSP)</p></a></li>
<li><a href='#print.mfp2'><p>Print method for objects of class <code>mfp2</code></p></a></li>
<li><a href='#prostate'><p>Prostate cancer dataset used in the Royston and Sauerbrei (2008) book.</p></a></li>
<li><a href='#reset_acd'><p>Helper to reset acd transformation for variables with few values</p></a></li>
<li><a href='#select_ic'><p>Function selection procedure based on information criteria</p></a></li>
<li><a href='#select_linear'><p>Helper to select between null and linear term for a single variable</p></a></li>
<li><a href='#select_ra2'><p>Function selection procedure based on closed testing procedure</p></a></li>
<li><a href='#select_ra2_acd'><p>Function selection procedure for ACD based on closed testing procedure</p></a></li>
<li><a href='#summary.mfp2'><p>Summarizing <code>mfp2</code> model fits</p></a></li>
<li><a href='#transform_data_step'><p>Function to extract and transform adjustment variables</p></a></li>
<li><a href='#transform_matrix'><p>Function to transform each column of matrix using final FP powers or acd</p></a></li>
<li><a href='#transform_vector_fp'><p>Functions to transform a variable using fractional polynomial powers or acd</p></a></li>
<li><a href='#transform_vector_power'><p>Simple function to transform vector by a single power</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariable Fractional Polynomial Models with Extensions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-13</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2 (&ge; 3.4.0), stats, survival, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat (&ge; 3.0.0), xfun, rmarkdown, formatR,
patchwork, spelling</td>
</tr>
<tr>
<td>Description:</td>
<td>Multivariable fractional polynomial algorithm simultaneously selects variables and functional forms in both generalized linear models and Cox proportional hazard models. Key references for this algorithm are Royston and Altman (1994)&lt;<a href="https://doi.org/10.2307%2F2986270">doi:10.2307/2986270</a>&gt; and Sauerbrei and Royston (2008, ISBN:978-0-470-02842-1). In addition, it can model a 'sigmoid' relationship between variable x and an outcome variable y using the approximate cumulative distribution transformation proposed by Royston (2014) &lt;<a href="https://doi.org/10.1177%2F1536867X1401400206">doi:10.1177/1536867X1401400206</a>&gt;. This feature distinguishes it from a standard fractional polynomial function, which lacks the ability to achieve such modeling.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/EdwinKipruto/mfp2">https://github.com/EdwinKipruto/mfp2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/EdwinKipruto/mfp2/issues">https://github.com/EdwinKipruto/mfp2/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Edwin Kipruto [aut, cre],
  Michael Kammer [aut],
  Patrick Royston [aut],
  Willi Sauerbrei [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Edwin Kipruto &lt;edwin.kipruto@uniklinik-freiburg.de&gt;</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-14 08:39:49 UTC; Edwin Kipruto</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-14 18:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='apply_acd'>Function to apply Approximate Cumulative Distribution (ACD)</h2><span id='topic+apply_acd'></span>

<h3>Description</h3>

<p>Applies the acd transformation as outlined in Royston (2014) and Royston and
Sauerbrei (2016).
Designed to work with the output of <code><a href="#topic+fit_acd">fit_acd()</a></code>, Please refer to the corresponding
documentation for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_acd(x, beta0, beta1, power, shift, scale, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_acd_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="apply_acd_+3A_beta0">beta0</code>, <code id="apply_acd_+3A_beta1">beta1</code></td>
<td>
<p>each a numeric value, representing the coefficients of
the FP1 model for the ACD transformation.</p>
</td></tr>
<tr><td><code id="apply_acd_+3A_power">power</code></td>
<td>
<p>a numeric value, estimated power to be used in the FP1 model for
the ACD transformation.</p>
</td></tr>
<tr><td><code id="apply_acd_+3A_shift">shift</code></td>
<td>
<p>a numeric value that is used to shift the values of <code>x</code> to
positive values.</p>
</td></tr>
<tr><td><code id="apply_acd_+3A_scale">scale</code></td>
<td>
<p>a numeric value used to scale <code>x</code>.</p>
</td></tr>
<tr><td><code id="apply_acd_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The transformed input vector <code>x</code>.
</p>

<hr>
<h2 id='apply_shift_scale'>Shift and scale vector x</h2><span id='topic+apply_shift_scale'></span>

<h3>Description</h3>

<p>A function that is used to shift x values to positive values if it contains
negative or zero values.If all values of x are positive then the original
values of x is returned without shifting but scaled if the scaling factor is
not equal to 1. If x has already been shifted and scaled then the function does
nothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_shift_scale(x, scale = NULL, shift = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_shift_scale_+3A_x">x</code></td>
<td>
<p>A vector of predictor variable</p>
</td></tr>
<tr><td><code id="apply_shift_scale_+3A_scale">scale</code></td>
<td>
<p>scaling factors for x of interest. Must be positive integers.
Default is NULL and  scaling factors are automatically estimated using
find_scale_factor() function else it uses user supplied scaling factors. If no scaling
is needed just use scale = 1</p>
</td></tr>
<tr><td><code id="apply_shift_scale_+3A_shift">shift</code></td>
<td>
<p>adjustment factors required for shifting x to positive
values. Default is NULL and adjustment factors are estimated automatically
using find_shift_factor() function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value that has been shifted and scaled.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = 1:1000
apply_shift_scale(x)

</code></pre>

<hr>
<h2 id='art'>Artificial dataset with continuous response</h2><span id='topic+art'></span>

<h3>Description</h3>

<p>The ART data set mimics the GBSG breast cancer study in terms of the
distribution of predictors and correlation structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(art)
</code></pre>


<h3>Format</h3>

<p>The dataset has 250 observations and 10 covariates
</p>

<dl>
<dt>y</dt><dd><p>Continuous response variable.</p>
</dd>
<dt>x1, x3, x5-x7, x10</dt><dd><p>Continuous covariates.</p>
</dd>
<dt>x2</dt><dd><p>Binary variable.</p>
</dd>
<dt>x4</dt><dd><p>Ordinal variable with 3 levels.</p>
</dd>
<dt>x8</dt><dd><p>Binary variable.</p>
</dd>
<dt>x9</dt><dd><p>Nominal variable with 3 levels.</p>
</dd>
</dl>


<hr>
<h2 id='assign_df'>Helper to assign degrees of freedom</h2><span id='topic+assign_df'></span>

<h3>Description</h3>

<p>Determine the number of unique values in a variable. To be used in <code><a href="#topic+mfp2">mfp2()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_df(x, df_default = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assign_df_+3A_x">x</code></td>
<td>
<p>input matrix.</p>
</td></tr>
<tr><td><code id="assign_df_+3A_df_default">df_default</code></td>
<td>
<p>default df to be used. Default is 4.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Variables with fewer than or equal to three unique values, for example,
will be assigned df = 1. df = 2 will be assigned to variables with 4-5
unique values, and df = 4 will be assigned to variables with unique values
greater than or equal to 6.
</p>


<h3>Value</h3>

<p>Vector of length <code>ncol(x)</code> with degrees of freedom for each variable in <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1:100, nrow = 10)
assign_df(x)

</code></pre>

<hr>
<h2 id='calculate_df'>Helper to calculates the final degrees of freedom for the selected model</h2><span id='topic+calculate_df'></span>

<h3>Description</h3>

<p>To be used in <code><a href="#topic+fit_mfp">fit_mfp()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_df(p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_df_+3A_p">p</code></td>
<td>
<p>power of a variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An example calculation: if p is the power(s) and p = c(1,2), then df = 4
but if x = NA then df = 0.
</p>


<h3>Value</h3>

<p>returns numeric value denoting the number of degrees of freedom (df).
</p>

<hr>
<h2 id='calculate_f_test'>Function to compute F-statistic and p-value from deviances</h2><span id='topic+calculate_f_test'></span>

<h3>Description</h3>

<p>Alternative to likelihood ratio tests in normal / Gaussian error models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_f_test(deviances, dfs_resid, n_obs, d1 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_f_test_+3A_deviances">deviances</code></td>
<td>
<p>a numeric vector of length 2 with deviances. Typically
ordered in increasing order (i.e. null model first, then full model) and
used to test the difference <code>deviances[1] - deviances[2]</code>.</p>
</td></tr>
<tr><td><code id="calculate_f_test_+3A_dfs_resid">dfs_resid</code></td>
<td>
<p>a numeric vector with residual degrees of freedom.</p>
</td></tr>
<tr><td><code id="calculate_f_test_+3A_n_obs">n_obs</code></td>
<td>
<p>a numeric value with the number of observations.</p>
</td></tr>
<tr><td><code id="calculate_f_test_+3A_d1">d1</code></td>
<td>
<p>a numeric value giving <code>d1</code> in the formula below directly as
the number of additional degrees of freedom in model 2 compared to model 1.
In this case <code>dfs_resid</code> must be a single numeric value giving the residual
df for model 2. This interface is sometimes more convenient than to specify
both residual dfs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses formula on page 23 from here: https://www.stata.com/manuals/rfp.pdf:
</p>
<p style="text-align: center;"><code class="reqn">F = \frac{d_2}{d_1} (exp(\frac{D_2 - D_1}{n}) - 1),</code>
</p>

<p>where <code class="reqn">D</code> refers to deviances of two models 1 and 2.
<code class="reqn">d1</code> is the number of additional parameters used in in model 2 as
compared to model 1, i.e. <code>dfs_resid[1] - dfs_resid[2]</code>.
<code class="reqn">d2</code> is the number of residual degrees of freedom minus the number of
estimated powers for model 2, i.e. <code>dfs_resid[2]</code>.
#' The p-value then results from the use of a F-distribution with
(d1, d2) degrees of freedom.
</p>
<p>Note that this computation is completely equivalent to the computation
of a F-test using sum of squared errors as in e.g. Kutner at al. (2004),
p 263. The formula there is given as
</p>
<p style="text-align: center;"><code class="reqn">F = \frac{SSE(R) - SSE(F)}{df_R - df_F} / \frac{SSE(F)}{df_F},</code>
</p>

<p>where the <code class="reqn">df</code> terms refer to residual degrees of freedom, and <code class="reqn">R</code>
and <code class="reqn">F</code> to the reduced (model 1) and full model (model 2), respectively.
</p>


<h3>Value</h3>

<p>A list with three entries giving the test statistic and p-value for the F-test
for the comparison of <code>deviance[1]</code> to <code>deviance[2]</code>.
</p>

<ul>
<li> <p><code>statistic</code>: test statistic.
</p>
</li>
<li> <p><code>pvalue</code>: p-value.
</p>
</li>
<li> <p><code>dev_diff</code>: difference in deviances tested.
</p>
</li></ul>



<h3>References</h3>

<p>Kutner, M.H., et al., 2004. <em>Applied linear statistical models.
McGraw-Hill Irwin.</em>
</p>

<hr>
<h2 id='calculate_lr_test'>Function to calculate p-values for likelihood-ratio test</h2><span id='topic+calculate_lr_test'></span>

<h3>Description</h3>

<p>Function to calculate p-values for likelihood-ratio test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_lr_test(logl, dfs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_lr_test_+3A_logl">logl</code></td>
<td>
<p>a numeric vector of length 2 with log-likelihoods. Typically
ordered in increasing order (i.e. null model first, then full model) and
used to test the ratio <code>logl[1] / logl[2]</code>.</p>
</td></tr>
<tr><td><code id="calculate_lr_test_+3A_dfs">dfs</code></td>
<td>
<p>a numeric vector with degrees of freedom.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses Wilk's theorem that -2log(LR) (LR = likelihood ratio) asymptotically
approaches a Chi-square distribution under the null hypothesis that both
likelihoods are equal.
</p>
<p>Model likelihoods can then be compared by computing
D = -2 log(likelihood reduced model / likelihood full model), and then
use a Chi-square distribution with df_full - df_reduced degrees
of freedom to derive a p-value.
</p>
<p>This is basically the same way as <code><a href="stats.html#topic+anova">stats::anova()</a></code> implements the
likelihood ratio test.
</p>


<h3>Value</h3>

<p>A list with two entries for the likelihood ratio test for the ratio
<code>logl[1] / logl[2]</code>.
</p>

<ul>
<li> <p><code>statistic</code>: test statistic.
</p>
</li>
<li> <p><code>pvalue</code>: p-value
</p>
</li></ul>


<hr>
<h2 id='calculate_model_metrics'>Function to compute model metrics to be used within <code>mfp2</code></h2><span id='topic+calculate_model_metrics'></span>

<h3>Description</h3>

<p>Mostly used within an mfp step to compare between the different fp models
of a variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_model_metrics(obj, n_obs, df_additional = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_model_metrics_+3A_obj">obj</code></td>
<td>
<p>a list returned by <code><a href="#topic+fit_model">fit_model()</a></code> representing a glm or Cox model
fit.</p>
</td></tr>
<tr><td><code id="calculate_model_metrics_+3A_n_obs">n_obs</code></td>
<td>
<p>a numeric value indicating the number of observations for the
data used to fit <code>obj</code>.</p>
</td></tr>
<tr><td><code id="calculate_model_metrics_+3A_df_additional">df_additional</code></td>
<td>
<p>a numeric value indicating the number of additional
degrees of freedom to be accounted for in the computations of AIC and BIC.
These may be necessary when a model uses FP terms, as these add another
degree of freedom per estimated power.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the following entries:
</p>

<ul>
<li> <p><code>df</code>: number of degrees of freedom of model (i.e. coefficients plus
<code>df_additional</code>).
</p>
</li>
<li> <p><code>deviance_rs</code>: &quot;deviance&quot;, i.e. minus twice the log likelihood.
This is not the usual definition of deviance used by R, which is defined as
twice the difference between the log likelihoods of the saturated model
(one parameter per observation) and the null (or reduced) model.
It is, however, the definition used in Royston and Sauerbrei (2008) and in
<code>mfp</code>. For selection of fps this does not really play a role, as the common
factor would be cancelled anyway when comparing models based on deviances.
</p>
</li>
<li> <p><code>sse</code>: sum of squared residuals as returned by <code><a href="#topic+fit_model">fit_model()</a></code>.
</p>
</li>
<li> <p><code>deviance_gaussian</code>: deviance computed by <code><a href="#topic+deviance_gaussian">deviance_gaussian()</a></code>,
applicable to Gaussian models and used for F-test computations.
</p>
</li>
<li> <p><code>aic</code>: Akaike information criterion, defined as
<code style="white-space: pre;">&#8288;-2logL + 2(df + df_additional)&#8288;</code>.
</p>
</li>
<li> <p><code>bic</code>: Bayesian information criterion, defined as
<code style="white-space: pre;">&#8288;-2logL + log(n_obs)(df + df_additional)&#8288;</code>.
</p>
</li>
<li> <p><code>df_resid</code>: residual degrees of freedom, defined as <code>n_obs - df</code>.
For consistency with stata we subtract the scale parameter from <code>df</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Royston, P. and Sauerbrei, W., 2008. <em>Multivariable Model - Building:
A Pragmatic Approach to Regression Anaylsis based on Fractional Polynomials
for Modelling Continuous Variables. John Wiley &amp; Sons.</em><br />
</p>

<hr>
<h2 id='calculate_number_fp_powers'>Calculates the total number of fractional polynomial powers in adjustment variables.</h2><span id='topic+calculate_number_fp_powers'></span>

<h3>Description</h3>

<p>This function takes a list <code>x</code> containing fractional polynomial powers for all variables
and calculates the total number of powers across the variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_number_fp_powers(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_number_fp_powers_+3A_x">x</code></td>
<td>
<p>A list of fractional polynomial powers for all variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value denoting total number of fractional polynomial powers in the adjustment
variables.
</p>

<hr>
<h2 id='calculate_standard_error'>Helper function to compute standard error of a partial predictor</h2><span id='topic+calculate_standard_error'></span>

<h3>Description</h3>

<p>To be used in <code><a href="#topic+predict.mfp2">predict.mfp2()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_standard_error(model, X, xref = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_standard_error_+3A_model">model</code></td>
<td>
<p>fitted <code>mfp2</code> object.</p>
</td></tr>
<tr><td><code id="calculate_standard_error_+3A_x">X</code></td>
<td>
<p>transformed input matrix with variables of interest for partial predictor.</p>
</td></tr>
<tr><td><code id="calculate_standard_error_+3A_xref">xref</code></td>
<td>
<p>transformed reference value for variable of interest. Default is
<code>NULL</code>, in which case this function computes standard errors without reference
values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See pages 91-92 and following in the book by Royston and Sauerbrei 2008
for the formulas and mathematical details.
</p>


<h3>Value</h3>

<p>Standard error.
</p>


<h3>References</h3>

<p>Royston, P. and Sauerbrei, W., 2008. <em>Multivariable Model - Building:
A Pragmatic Approach to Regression Anaylsis based on Fractional Polynomials
for Modelling Continuous Variables. John Wiley &amp; Sons.</em><br />
</p>

<hr>
<h2 id='center_matrix'>Simple function to center data</h2><span id='topic+center_matrix'></span>

<h3>Description</h3>

<p>Simple function to center data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center_matrix(mat, centers = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="center_matrix_+3A_mat">mat</code></td>
<td>
<p>a transformed data matrix.</p>
</td></tr>
<tr><td><code id="center_matrix_+3A_centers">centers</code></td>
<td>
<p>a vector of centering values. Length must be equal to the
number of columns in <code>mat</code>. If <code>NULL</code> (default) then
centering values are determined by the function (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Centering is done by means for continuous variables (i.e. more than 2
distinct values), and the minimum for binary variables.
</p>
<p>It is assumed all categorical variables in the data are represented by
binary dummy variables.
</p>


<h3>Value</h3>

<p>Transformed data matrix. Has an attribute <code>scaled:center</code> that stores
values used for centering.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat = matrix(1:100, nrow = 10)
center_matrix(mat)

</code></pre>

<hr>
<h2 id='coef.mfp2'>Extract coefficients from object of class <code>mfp2</code></h2><span id='topic+coef.mfp2'></span>

<h3>Description</h3>

<p>This function is a method for the generic <code><a href="stats.html#topic+coef">stats::coef()</a></code> function for
objects of class <code>mfp2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mfp2'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.mfp2_+3A_object">object</code></td>
<td>
<p>an object of class <code>mfp2</code>, usually, a result of a call to
<code><a href="#topic+mfp2">mfp2()</a></code>.</p>
</td></tr>
<tr><td><code id="coef.mfp2_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named numeric vector of coefficients extracted from the model <code>object</code>.
</p>

<hr>
<h2 id='convert_powers_list_to_matrix'>Helper to convert a nested list with same or different length into a matrix</h2><span id='topic+convert_powers_list_to_matrix'></span>

<h3>Description</h3>

<p>To be used in <code><a href="#topic+fit_mfp">fit_mfp()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_powers_list_to_matrix(power_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_powers_list_to_matrix_+3A_power_list">power_list</code></td>
<td>
<p>list of powers created in <code>fit_mfp()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix.
</p>

<hr>
<h2 id='create_dummy_variables'>Simple function to create dummy variables for ordinal and nominal variables</h2><span id='topic+create_dummy_variables'></span>

<h3>Description</h3>

<p>Simple function to create dummy variables for ordinal and nominal variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_dummy_variables(
  data,
  var_ordinal = NULL,
  var_nominal = NULL,
  drop_variables = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_dummy_variables_+3A_data">data</code></td>
<td>
<p>A dataframe containing the ordinal variable.</p>
</td></tr>
<tr><td><code id="create_dummy_variables_+3A_var_ordinal">var_ordinal</code></td>
<td>
<p>Names of ordinal variables in the data for which dummy variables should be created.</p>
</td></tr>
<tr><td><code id="create_dummy_variables_+3A_var_nominal">var_nominal</code></td>
<td>
<p>Names of nominal variables in the data for which dummy variables should be created.</p>
</td></tr>
<tr><td><code id="create_dummy_variables_+3A_drop_variables">drop_variables</code></td>
<td>
<p>Specifies whether to drop the original variables after dummy variables have
been created. The default value is FALSE, and the original variables are kept in the data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates dummy variables based on ordinal and categorical coding described in
the Royston and Sauerbrei (2008) book (Chapter 3, Table 3.5). It uses the levels of
the categorical variable if they exist; otherwise, it will extract the unique values of the
variable, sort them, and use them as levels. We recommend that the user sets the levels of
categorical variables and specifies their reference group. You can use the factor() function in
base R. If the levels are 1, 2, and 3, then 1 will be the reference group. On the other hand,
if the levels are 3, 2, and 1, then 3 will be the reference group. In brief, the first
level will be taken as the reference group.
</p>


<h3>Value</h3>

<p>A dataframe with new dummy variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("gbsg")
# create dummy variable for grade using ordinal coding
gbsg &lt;- create_dummy_variables(gbsg, var_ordinal = "grade", drop_variables = TRUE)
head(gbsg)

</code></pre>

<hr>
<h2 id='create_fp_terms'>Helper to create overview table of fp terms</h2><span id='topic+create_fp_terms'></span>

<h3>Description</h3>

<p>To be used in <code><a href="#topic+fit_mfp">fit_mfp()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_fp_terms(fp_powers, acdx, df, select, alpha, criterion)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_fp_terms_+3A_fp_powers">fp_powers</code></td>
<td>
<p>powers of the created FP terms.</p>
</td></tr>
<tr><td><code id="create_fp_terms_+3A_acdx">acdx</code></td>
<td>
<p>a logical vector of length nvars indicating which continuous
variables should undergo the approximate cumulative distribution (ACD)
transformation.</p>
</td></tr>
<tr><td><code id="create_fp_terms_+3A_df">df</code></td>
<td>
<p>a numeric vector of length nvars of degrees of freedom.</p>
</td></tr>
<tr><td><code id="create_fp_terms_+3A_select">select</code></td>
<td>
<p>a numeric vector of length nvars indicating significance levels
for backward elimination.</p>
</td></tr>
<tr><td><code id="create_fp_terms_+3A_alpha">alpha</code></td>
<td>
<p>a numeric vector of length nvars indicating significance levels
for tests between FP models of different degrees.</p>
</td></tr>
<tr><td><code id="create_fp_terms_+3A_criterion">criterion</code></td>
<td>
<p>a character string defining the criterion used to select
variables and FP models of different degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with overview of all fp terms. Each row represents a variable,
with rownames giving the name of the variable. Variables with acd
transformation are prefixed by <code>A_</code> by the <code>print</code> and <code>summary</code> methods.
The dataframe comprises the following columns:
</p>

<ul>
<li> <p><code>df_initial</code>: initial degrees of freedom.
</p>
</li>
<li> <p><code>select</code>: significance level for backward elimination.
</p>
</li>
<li> <p><code>alpha</code>: significance level for fractional polyomial terms.
</p>
</li>
<li> <p><code>selected</code>: logical value encoding presence in the model.
</p>
</li>
<li> <p><code>df_final</code>: final estimated degrees of freedom.
</p>
</li>
<li> <p><code>acd</code>: logical value encoding use of ACD transformation.
</p>
</li>
<li> <p><code>powerN</code>: one or more columns with the final estimated fp powers (numbered
1 to N).
</p>
</li></ul>


<hr>
<h2 id='deviance_gaussian'>Deviance computations as used in mfp in stata</h2><span id='topic+deviance_gaussian'></span>

<h3>Description</h3>

<p>Deviance computations as used in mfp in stata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deviance_gaussian(rss, weights, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deviance_gaussian_+3A_rss">rss</code></td>
<td>
<p>residual sum of squares.</p>
</td></tr>
<tr><td><code id="deviance_gaussian_+3A_weights">weights</code></td>
<td>
<p>numeric vector of weights used in computation of <code>rss</code>.</p>
</td></tr>
<tr><td><code id="deviance_gaussian_+3A_n">n</code></td>
<td>
<p>number of observations used to compute <code>rss</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this is not the usual formula of deviance used in R, but
uses the formula found here https://www.stata.com/manuals/rfp.pdf.
</p>
<p>It can be applied for normal error models, but should not be used for other
kinds of glms.
</p>


<h3>Value</h3>

<p>A numeric value representing the deviance of a Gaussian model.
</p>

<hr>
<h2 id='ensure_length'>Helper function to ensure vectors have a specified length</h2><span id='topic+ensure_length'></span>

<h3>Description</h3>

<p>Used to make sure dimensions of matrix rows match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensure_length(x, size, fill = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensure_length_+3A_x">x</code></td>
<td>
<p>input vector or matrix.</p>
</td></tr>
<tr><td><code id="ensure_length_+3A_size">size</code></td>
<td>
<p>length or size of <code>x</code> which is desired.</p>
</td></tr>
<tr><td><code id="ensure_length_+3A_fill">fill</code></td>
<td>
<p>value to fill in if <code>x</code> is not of desired length or size.</p>
</td></tr>
</table>

<hr>
<h2 id='find_best_fp_cycle'>Helper to run cycles of the mfp algorithm</h2><span id='topic+find_best_fp_cycle'></span>

<h3>Description</h3>

<p>This function estimates the best FP functions for all predictors in the
current cycle. To be used in <code><a href="#topic+fit_mfp">fit_mfp()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_best_fp_cycle(
  x,
  y,
  powers_current,
  df,
  weights,
  offset,
  family,
  criterion,
  select,
  alpha,
  keep,
  powers,
  method,
  strata,
  verbose,
  ftest,
  control,
  rownames,
  nocenter,
  acdx
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_best_fp_cycle_+3A_x">x</code></td>
<td>
<p>an input matrix of dimensions nobs x nvars. Does not contain
intercept, but columns are already expanded into dummy variables as
necessary. Data are assumed to be shifted and scaled.</p>
</td></tr>
<tr><td><code id="find_best_fp_cycle_+3A_y">y</code></td>
<td>
<p>a vector for the response variable or a <code>Surv</code> object.</p>
</td></tr>
<tr><td><code id="find_best_fp_cycle_+3A_powers_current">powers_current</code></td>
<td>
<p>a list of length equal to the number of variables,
indicating the fp powers to be used in the current step for all variables
(except <code>xi</code>).</p>
</td></tr>
<tr><td><code id="find_best_fp_cycle_+3A_df">df</code></td>
<td>
<p>a numeric vector of length nvars of degrees of freedom.</p>
</td></tr>
<tr><td><code id="find_best_fp_cycle_+3A_weights">weights</code></td>
<td>
<p>a vector of observation weights of length nobs.</p>
</td></tr>
<tr><td><code id="find_best_fp_cycle_+3A_offset">offset</code></td>
<td>
<p>a vector of length nobs of offsets.</p>
</td></tr>
<tr><td><code id="find_best_fp_cycle_+3A_family">family</code></td>
<td>
<p>a character string representing a family object.</p>
</td></tr>
<tr><td><code id="find_best_fp_cycle_+3A_criterion">criterion</code></td>
<td>
<p>a character string defining the criterion used to select
variables and FP models of different degrees.</p>
</td></tr>
<tr><td><code id="find_best_fp_cycle_+3A_select">select</code></td>
<td>
<p>a numeric vector of length nvars indicating significance levels
for backward elimination.</p>
</td></tr>
<tr><td><code id="find_best_fp_cycle_+3A_alpha">alpha</code></td>
<td>
<p>a numeric vector of length nvars indicating significance levels
for tests between FP models of different degrees.</p>
</td></tr>
<tr><td><code id="find_best_fp_cycle_+3A_keep">keep</code></td>
<td>
<p>a character vector with names of variables to be kept
in the model.</p>
</td></tr>
<tr><td><code id="find_best_fp_cycle_+3A_powers">powers</code></td>
<td>
<p>a named list of numeric values that sets the permitted FP
powers for each covariate.</p>
</td></tr>
<tr><td><code id="find_best_fp_cycle_+3A_method">method</code></td>
<td>
<p>a character string specifying the method for tie handling in
Cox regression model.</p>
</td></tr>
<tr><td><code id="find_best_fp_cycle_+3A_strata">strata</code></td>
<td>
<p>a factor of all possible combinations of stratification
variables. Returned from <code><a href="survival.html#topic+strata">survival::strata()</a></code>.</p>
</td></tr>
<tr><td><code id="find_best_fp_cycle_+3A_verbose">verbose</code></td>
<td>
<p>a logical; run in verbose mode.</p>
</td></tr>
<tr><td><code id="find_best_fp_cycle_+3A_ftest">ftest</code></td>
<td>
<p>a logical indicating the use of the F-test for Gaussian models.</p>
</td></tr>
<tr><td><code id="find_best_fp_cycle_+3A_control">control</code></td>
<td>
<p>a list with parameters for model fit. See <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>
or <code><a href="stats.html#topic+glm">stats::glm()</a></code> for details.</p>
</td></tr>
<tr><td><code id="find_best_fp_cycle_+3A_rownames">rownames</code></td>
<td>
<p>passed to <code><a href="survival.html#topic+agreg.fit">survival::coxph.fit()</a></code>.</p>
</td></tr>
<tr><td><code id="find_best_fp_cycle_+3A_nocenter">nocenter</code></td>
<td>
<p>a numeric vector with a list of values for fitting Cox
models. See <code><a href="survival.html#topic+coxph">survival::coxph()</a></code> for details.</p>
</td></tr>
<tr><td><code id="find_best_fp_cycle_+3A_acdx">acdx</code></td>
<td>
<p>a logical vector of length nvars indicating which continuous
variables should undergo the approximate cumulative distribution (ACD)
transformation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A cycle is defined as a complete pass through all the predictors in the input
matrix <code>x</code>, while a step is defined as the assessment of a single predictor.
This algorithm is described in Sauerbrei et al. (2006) and given in detail
in Royston and Sauerbrei (2008), in particular chapter 6.
</p>
<p>Briefly, a cycle works as follows: it takes as input the data matrix along with
a set of current best fp powers for each variable. In each step, the fp
powers of a single covariate are assessed, while adjusting for other
covariates. Adjustment variables are transformed using their current
fp powers (this is done in <code><a href="#topic+transform_data_step">transform_data_step()</a></code>) and the fp powers
of the variable of interest are tested using the closed test procedure
(conducted in <code><a href="#topic+find_best_fp_step">find_best_fp_step()</a></code>).
Some of the adjustment variables may have their fp power set to <code>NA</code>,
which means they were not selected from the working model and are not used
in that step. The results from all steps are returned, completing a cycle.
</p>
<p>Note that in each cycle every variable is evaluated.This includes variables
that may have been eliminated in previous cycles. They will re-enter each
new cycle for potential inclusion in the working model or to be re-evaluated
for elimination.
</p>
<p>The current adjustment set is always given through the current fp powers,
which are updated in each step (denoted as <code>powers_current</code>).
</p>


<h3>Value</h3>

<p>current FP powers
</p>


<h3>References</h3>

<p>Royston, P. and Sauerbrei, W., 2008. <em>Multivariable Model - Building:
A Pragmatic Approach to Regression Anaylsis based on Fractional Polynomials
for Modelling Continuous Variables. John Wiley &amp; Sons.</em><br />
Sauerbrei, W., Meier-Hirmer, C., Benner, A. and Royston, P., 2006.
<em>Multivariable regression model building by using fractional
polynomials: Description of SAS, STATA and R programs.
Comput Stat Data Anal, 50(12): 3464-85.</em>
Sauerbrei, W. and Royston, P., 1999. <em>Building multivariable prognostic
and diagnostic models: transformation of the predictors by using fractional
polynomials. J Roy Stat Soc a Sta, 162:71-94.</em>
</p>

<hr>
<h2 id='find_best_fp_step'>Function to estimate the best FP functions for a single variable</h2><span id='topic+find_best_fp_step'></span>

<h3>Description</h3>

<p>See <code><a href="#topic+mfp2">mfp2()</a></code> for a brief summary on the notation used here and
<code><a href="#topic+fit_mfp">fit_mfp()</a></code> for an overview of the fitting procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_best_fp_step(
  x,
  y,
  xi,
  weights,
  offset,
  df,
  powers_current,
  family,
  criterion,
  select,
  alpha,
  keep,
  powers,
  method,
  strata,
  nocenter,
  acdx,
  ftest,
  control,
  rownames,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_best_fp_step_+3A_x">x</code></td>
<td>
<p>an input matrix of dimensions nobs x nvars. Does not contain
intercept, but columns are already expanded into dummy variables as
necessary. Data are assumed to be shifted and scaled.</p>
</td></tr>
<tr><td><code id="find_best_fp_step_+3A_y">y</code></td>
<td>
<p>a vector for the response variable or a <code>Surv</code> object.</p>
</td></tr>
<tr><td><code id="find_best_fp_step_+3A_xi">xi</code></td>
<td>
<p>a character string indicating the name of the current variable
of interest, for which the best fractional polynomial transformation is
to be estimated in the current step.</p>
</td></tr>
<tr><td><code id="find_best_fp_step_+3A_weights">weights</code></td>
<td>
<p>a vector of observation weights of length nobs.</p>
</td></tr>
<tr><td><code id="find_best_fp_step_+3A_offset">offset</code></td>
<td>
<p>a vector of length nobs of offsets.</p>
</td></tr>
<tr><td><code id="find_best_fp_step_+3A_df">df</code></td>
<td>
<p>a numeric vector indicating the maximum degrees of freedom for the
variable of interest <code>xi</code>.</p>
</td></tr>
<tr><td><code id="find_best_fp_step_+3A_powers_current">powers_current</code></td>
<td>
<p>a list of length equal to the number of variables,
indicating the fp powers to be used in the current step for all variables
(except <code>xi</code>).</p>
</td></tr>
<tr><td><code id="find_best_fp_step_+3A_family">family</code></td>
<td>
<p>a character string representing a family object.</p>
</td></tr>
<tr><td><code id="find_best_fp_step_+3A_criterion">criterion</code></td>
<td>
<p>a character string defining the criterion used to select
variables and FP models of different degrees.</p>
</td></tr>
<tr><td><code id="find_best_fp_step_+3A_select">select</code></td>
<td>
<p>a numeric value indicating the significance level
for backward elimination of <code>xi</code>.</p>
</td></tr>
<tr><td><code id="find_best_fp_step_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value indicating the significance level
for tests between FP models of different degrees for <code>xi</code>.</p>
</td></tr>
<tr><td><code id="find_best_fp_step_+3A_keep">keep</code></td>
<td>
<p>a character vector with names of variables to be kept
in the model.</p>
</td></tr>
<tr><td><code id="find_best_fp_step_+3A_powers">powers</code></td>
<td>
<p>a named list of numeric values that sets the permitted FP
powers for each covariate.</p>
</td></tr>
<tr><td><code id="find_best_fp_step_+3A_method">method</code></td>
<td>
<p>a character string specifying the method for tie handling in
Cox regression.</p>
</td></tr>
<tr><td><code id="find_best_fp_step_+3A_strata">strata</code></td>
<td>
<p>a factor of all possible combinations of stratification
variables. Returned from <code><a href="survival.html#topic+strata">survival::strata()</a></code>.</p>
</td></tr>
<tr><td><code id="find_best_fp_step_+3A_nocenter">nocenter</code></td>
<td>
<p>a numeric vector with a list of values for fitting Cox
models. See <code><a href="survival.html#topic+coxph">survival::coxph()</a></code> for details.</p>
</td></tr>
<tr><td><code id="find_best_fp_step_+3A_acdx">acdx</code></td>
<td>
<p>a logical vector of length nvars indicating continuous variables
to undergo the approximate cumulative distribution (ACD) transformation.</p>
</td></tr>
<tr><td><code id="find_best_fp_step_+3A_ftest">ftest</code></td>
<td>
<p>a logical indicating the use of the F-test for Gaussian models.</p>
</td></tr>
<tr><td><code id="find_best_fp_step_+3A_control">control</code></td>
<td>
<p>a list with parameters for model fit.</p>
</td></tr>
<tr><td><code id="find_best_fp_step_+3A_rownames">rownames</code></td>
<td>
<p>a parameter for Cox models.</p>
</td></tr>
<tr><td><code id="find_best_fp_step_+3A_verbose">verbose</code></td>
<td>
<p>a logical; run in verbose mode.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function selection procedure (FSP) is used if the p-value criterion is
chosen, whereas the criteria AIC and BIC select the model with the smallest
AIC and BIC, respectively.
</p>
<p>It uses transformations for all other variables to assess the FP form of
the current variable of interest. This function covers three main use cases:
</p>

<ul>
<li><p> the linear case (<code>df = 1</code>) to test between null and linear models (see
<code><a href="#topic+select_linear">select_linear()</a></code>). This step differs from the mfp case because
linear models only use 1 df, while estimation of (every) fp power adds
another df. This is also the case applied for categorical variables for
which <code>df</code> are set to 1.
</p>
</li>
<li><p> the case that an acd transformation is requested (<code>acdx</code> is <code>TRUE</code>
for <code>xi</code>) for the variable of interest (see <code><a href="#topic+find_best_fpm_step">find_best_fpm_step()</a></code>).
</p>
</li>
<li><p> the (usual) case of the normal mfp algorithm to assess non-linear
functional forms (see <code><a href="#topic+find_best_fpm_step">find_best_fpm_step()</a></code>).
</p>
</li></ul>

<p>Note that these cases do not encompass the setting that a variable is not
selected, because the evaluation is done for each variable in each cycle.
A variable which was de-selected in earlier cycles may be added to the
working model again. Also see <code><a href="#topic+find_best_fp_cycle">find_best_fp_cycle()</a></code>.
</p>
<p>The adjustment in each step uses the current fp powers given in
<code>powers_current</code> for all other variables to determine the adjustment set
and transformations in the  working model.
</p>
<p>Note that the algorithm starts by setting all <code>df = 1</code>, and higher fps
are evaluated in turn starting from the first step in the first cycle.
</p>


<h3>Value</h3>

<p>A numeric vector indicating the best powers for <code>xi</code>. Entries can be
<code>NA</code> if variable is to be removed from the working model. Note that this
vector may include up to two <code>NA</code> entries when ACD transformation is
requested, but otherwise is either a vector with all numeric entries, or a
single <code>NA</code>.
</p>


<h3>Functional form selection</h3>

<p>There are 3 criteria to decide for the current best functional form of a
continuous variable.
</p>
<p>The first option for <code>criterion = "pvalue"</code> is the function selection
procedure as outlined in e.g. Chapters 4 and 6 of Royston and
Sauerbrei (2008), also abbreviated as &quot;RA2&quot;.
It is a closed testing procedure and is implemented in <code><a href="#topic+select_ra2">select_ra2()</a></code> and
extended for ACD transformation in <code><a href="#topic+select_ra2_acd">select_ra2_acd()</a></code> according to
Royston and Sauerbrei (2016).
</p>
<p>For the other criteria <code>aic</code> and <code>bic</code> all FP models up to the desired degree
are fitted and the model with the lowest value for the information criteria
is chosen as the final one. This is implemented in <code><a href="#topic+select_ic">select_ic()</a></code>.
</p>


<h3>References</h3>

<p>Royston, P. and Sauerbrei, W., 2008. <em>Multivariable Model - Building:
A Pragmatic Approach to Regression Anaylsis based on Fractional Polynomials
for Modelling Continuous Variables. John Wiley &amp; Sons.</em><br />
</p>
<p>Royston, P. and Sauerbrei, W., 2016. <em>mfpa: Extension of mfp using the
ACD covariate transformation for enhanced parametric multivariable modeling.
The Stata Journal, 16(1), pp.72-87.</em>
</p>

<hr>
<h2 id='find_best_fp1_for_acd'>Function to fit univariable FP1 models for acd transformation</h2><span id='topic+find_best_fp1_for_acd'></span>

<h3>Description</h3>

<p>To be used in <code><a href="#topic+fit_acd">fit_acd()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_best_fp1_for_acd(x, y, powers)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_best_fp1_for_acd_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="find_best_fp1_for_acd_+3A_y">y</code></td>
<td>
<p>normal cdf of rank transform of <code>x</code>.</p>
</td></tr>
<tr><td><code id="find_best_fp1_for_acd_+3A_powers">powers</code></td>
<td>
<p>a vector of allowed FP powers. The default value is <code>NULL</code>,
meaning that the set <code class="reqn">S = (-2, -1, -0.5, 0, 0.5, 1, 2, 3)</code> is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The best FP power with smallest deviance and the fitted model.
</p>

<hr>
<h2 id='find_best_fpm_step'>Function to find the best FP functions of given degree for a single variable</h2><span id='topic+find_best_fpm_step'></span>

<h3>Description</h3>

<p>Handles the FP1 and the higher order FP cases. For parameter definitions, see
<code><a href="#topic+find_best_fp_step">find_best_fp_step()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_best_fpm_step(x, xi, degree, y, powers_current, powers, acdx, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_best_fpm_step_+3A_x">x</code></td>
<td>
<p>an input matrix of dimensions nobs x nvars. Does not contain
intercept, but columns are already expanded into dummy variables as
necessary. Data are assumed to be shifted and scaled.</p>
</td></tr>
<tr><td><code id="find_best_fpm_step_+3A_xi">xi</code></td>
<td>
<p>a character string indicating the name of the current variable
of interest, for which the best fractional polynomial transformation is
to be estimated in the current step.</p>
</td></tr>
<tr><td><code id="find_best_fpm_step_+3A_degree">degree</code></td>
<td>
<p>degrees of freedom for fp transformation of <code>xi</code>.</p>
</td></tr>
<tr><td><code id="find_best_fpm_step_+3A_y">y</code></td>
<td>
<p>a vector for the response variable or a <code>Surv</code> object.</p>
</td></tr>
<tr><td><code id="find_best_fpm_step_+3A_powers_current">powers_current</code></td>
<td>
<p>a list of length equal to the number of variables,
indicating the fp powers to be used in the current step for all variables
(except <code>xi</code>).</p>
</td></tr>
<tr><td><code id="find_best_fpm_step_+3A_powers">powers</code></td>
<td>
<p>a named list of numeric values that sets the permitted FP
powers for each covariate.</p>
</td></tr>
<tr><td><code id="find_best_fpm_step_+3A_acdx">acdx</code></td>
<td>
<p>a logical vector of length nvars indicating continuous variables
to undergo the approximate cumulative distribution (ACD) transformation.</p>
</td></tr>
<tr><td><code id="find_best_fpm_step_+3A_...">...</code></td>
<td>
<p>passed to <code>fit_model()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;best&quot; model is determined by the highest likelihood (or smallest
deviance by our definition as minus twice the log-likelihood). This is also
the case for the use of information criteria, as all models investigated in
this function have the same df, so the penalization term is equal for all
models and only their likelihoods differ.
</p>
<p>Note that the estimation of each fp power adds a degree of freedom. Thus,
all fp1s have 2 df, all fp2s have 4 df and so on.
</p>
<p>In the case that <code>degree = 1</code>, the linear model (fp power of 1) is NOT
returned, as it is not considered to be a fractional polynomial in this
algorithm.
A linear model has only one df, whereas the same function regarded as fp
would have 2 fp.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>

<ul>
<li> <p><code>acd</code>: logical indicating if an ACD transformation was applied for <code>xi</code>.
</p>
</li>
<li> <p><code>powers</code>: fp powers investigated in step.
</p>
</li>
<li> <p><code>power_best</code>: the best power found. <code>power_best</code> will always be a
two-column matrix when an ACD transformation is used, otherwise the number
of columns will depend on <code>degree</code>.
</p>
</li>
<li> <p><code>metrics</code>: a matrix with performance indices for all models investigated.
Same number of rows as, and indexed by, <code>powers</code>.
</p>
</li>
<li> <p><code>model_best</code>: row index of best model in <code>metrics</code>.
</p>
</li></ul>



<h3>ACD transformation</h3>

<p>This function also handles the case of ACD transformations if <code>acdx</code> is set
to <code>TRUE</code> for <code>xi</code>. In this case, if <code>degree = 1</code>, then 7 models are
assessed (like for the non-acd case it excludes the linear case),
and if <code>degree = 2</code>, then 64 models are assessed (unlike the 36 models
for non-acd transformation). Other settings for <code>degree</code> are currently not
supported when used with ACD transformations.
</p>

<hr>
<h2 id='find_scale_factor'>Function that calculates an integer used to scale predictor</h2><span id='topic+find_scale_factor'></span>

<h3>Description</h3>

<p>Function that calculates an integer used to scale predictor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_scale_factor(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_scale_factor_+3A_x">x</code></td>
<td>
<p>a numeric vector already shifted to positive values (see
<code><a href="#topic+find_shift_factor">find_shift_factor()</a></code>). This function requires at least 2 distinct values to
work.
</p>
<p>#' @examples
x = 1:1000
find_scale_factor(x)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on why scaling is useful see the corresponding section in the
documentation of <code><a href="#topic+mfp2">mfp2()</a></code>.
</p>
<p>The determination of the scaling factor is independent (i.e. not affected
by) shifts in the input data, as it only depends on the range of the
input data.
</p>
<p>Note that the estimation of powers is unaffected by scaling, the same powers
are found for scaled input data. In extreme cases scaling is necessary to
preserve accuracy, see Royston and Sauerbrei (2008).
This formula uses the scaling formula from Section 4.11.1 of
Royston and Sauerbrei (2008). Further information can also be found in the
Stata manual for mfp at https://www.stata.com/manuals/rfp.pdf.
</p>


<h3>Value</h3>

<p>An integer that can be used to scale <code>x</code> to a reasonable range. For binary
variables 1 is returned.
</p>


<h3>References</h3>

<p>Royston, P., and Sauerbrei, W., 2008. <em>Multivariable Model - Building:
A Pragmatic Approach to Regression Anaylsis based on Fractional Polynomials
for Modelling Continuous Variables. John Wiley &amp; Sons.</em>
</p>

<hr>
<h2 id='find_shift_factor'>Function that calculates a value used to shift predictor</h2><span id='topic+find_shift_factor'></span>

<h3>Description</h3>

<p>Function that calculates a value used to shift predictor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_shift_factor(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_shift_factor_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on why shifting is necessary see the corresponding section in the
documentation of <code><a href="#topic+mfp2">mfp2()</a></code>.
</p>
<p>This function implements the formula in Section 4.7 of Royston and
Sauerbrei (2008).
</p>


<h3>Value</h3>

<p>A numeric value that can be used to shift <code>x</code> to positive values.
If all values are positive, or if <code>x</code> is binary then 0 is returned.
</p>


<h3>References</h3>

<p>Royston, P., and Sauerbrei, W., 2008. <em>Multivariable Model - Building:
A Pragmatic Approach to Regression Anaylsis based on Fractional Polynomials
for Modelling Continuous Variables. John Wiley &amp; Sons.</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = 1:1000
find_shift_factor(x)

</code></pre>

<hr>
<h2 id='fit_acd'>Function to estimate approximate cumulative distribution (ACD)</h2><span id='topic+fit_acd'></span>

<h3>Description</h3>

<p>Fits ACD transformation as outlined in Royston (2014). The ACD transformation
smoothly maps the observed distribution of a continuous covariate x onto one scale,
namely, that of an approximate uniform distribution on the interval (0, 1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_acd(x, powers = NULL, shift = 0, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_acd_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="fit_acd_+3A_powers">powers</code></td>
<td>
<p>a vector of allowed FP powers. The default value is <code>NULL</code>,
meaning that the set <code class="reqn">S = (-2, -1, -0.5, 0, 0.5, 1, 2, 3)</code> is used.</p>
</td></tr>
<tr><td><code id="fit_acd_+3A_shift">shift</code></td>
<td>
<p>a numeric that is used to shift the values of <code>x</code> to positive
values. The default value is 0, meaning no shifting is conducted.
If <code>NULL</code>, then the program will estimate an appropriate shift automatically
(see <code><a href="#topic+find_shift_factor">find_shift_factor()</a></code>).</p>
</td></tr>
<tr><td><code id="fit_acd_+3A_scale">scale</code></td>
<td>
<p>a numeric used to scale <code>x</code>. The default value is 1, meaning
no scaling is conducted. If <code>NULL</code>, then the program will estimate
an appropriate scaling factor automatically (see <code><a href="#topic+find_scale_factor">find_scale_factor()</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Briefly, the estimation works as follows. First, the input data are shifted
to positive values and scaled as requested. Then
</p>
<p style="text-align: center;"><code class="reqn">z = \Phi^{-1}(\frac{rank(x) - 0.5}{n}) </code>
</p>

<p>is computed, where <code class="reqn">n</code> is the number of elements in <code>x</code>,
with ties in the ranks handled as averages. To approximate <code class="reqn">z</code>,
an FP1 model (least squares) is used, i.e.
<code class="reqn">E(z) = \beta_0 + \beta_1 (x)^p</code>, where <code class="reqn">p</code> is chosen such that it
provides the best fitting model among all possible FP1 models.
The ACD transformation is then given as
</p>
<p style="text-align: center;"><code class="reqn">acd(x) = \Phi(\hat{z}),</code>
</p>

<p>where the fitted values of the estimated model are used.
If the relationship between a response Y and acd(x) is linear,
say, <code class="reqn">E(Y) = \beta_0 + \beta_1 acd(x)</code>, the relationship between Y
and x is nonlinear and is typically sigmoid in shape.
The parameters <code class="reqn">\beta_0</code> and <code class="reqn">\beta_0 + \beta_1</code> in such a model are
interpreted as the expected values of Y at the minimum and maximum of x,
that is, at acd(x) = 0 and 1, respectively.
The parameter <code class="reqn">\beta_1</code> represents the range of predictions of <code class="reqn">E(Y)</code>
across the whole observed distribution of x (Royston 2014).
</p>


<h3>Value</h3>

<p>A list is returned with components
</p>

<ul>
<li> <p><code>acd</code>: the acd transformed input data.
</p>
</li>
<li> <p><code>beta0</code>: intercept of estimated model.
</p>
</li>
<li> <p><code>beta1</code>: coefficient of estimated model.
</p>
</li>
<li> <p><code>power</code>: estimated power.
</p>
</li>
<li> <p><code>shift</code>: shift value used for computations.
</p>
</li>
<li> <p><code>scale</code>: scaling factor used for computations.
</p>
</li></ul>



<h3>References</h3>

<p>Royston, P. and Sauerbrei, W. (2016). <em>mfpa: Extension of mfp using the
ACD covariate transformation for enhanced parametric multivariable modeling.
The Stata Journal, 16(1), pp.72-87.</em>
</p>
<p>Royston, P. (2014). <em>A smooth covariate rank transformation for use in
regression models with a sigmoid dose–response function. The Stata Journal,
14(2), 329-341</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(42)
x = apply_shift_scale(rnorm(100))
y = rnorm(100)
fit_acd(x, y)

</code></pre>

<hr>
<h2 id='fit_cox'>Function that fits Cox proportional hazards models</h2><span id='topic+fit_cox'></span>

<h3>Description</h3>

<p>Function that fits Cox proportional hazards models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_cox(
  x,
  y,
  strata,
  weights,
  offset,
  control,
  method,
  rownames,
  nocenter,
  fast = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_cox_+3A_x">x</code></td>
<td>
<p>a matrix of predictors excluding intercept with nobs observations.</p>
</td></tr>
<tr><td><code id="fit_cox_+3A_y">y</code></td>
<td>
<p>a <code>Surv</code> object.</p>
</td></tr>
<tr><td><code id="fit_cox_+3A_strata">strata</code>, <code id="fit_cox_+3A_control">control</code>, <code id="fit_cox_+3A_rownames">rownames</code>, <code id="fit_cox_+3A_nocenter">nocenter</code></td>
<td>
<p>passed to <code><a href="survival.html#topic+agreg.fit">survival::coxph.fit()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_cox_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of length nobs of 'prior weights' to be used
in the fitting process.</p>
</td></tr>
<tr><td><code id="fit_cox_+3A_offset">offset</code></td>
<td>
<p>a numeric vector of length nobs of of a priori known component
to be included in the linear predictor during fitting.</p>
</td></tr>
<tr><td><code id="fit_cox_+3A_method">method</code></td>
<td>
<p>a character string specifying the method for tie handling.
See <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_cox_+3A_fast">fast</code></td>
<td>
<p>a logical which determines how the model is fitted. The default
<code>TRUE</code> uses fast fitting routines (i.e. <code><a href="survival.html#topic+agreg.fit">survival::coxph.fit()</a></code>), while
<code>FALSE</code>uses the normal fitting routines (<code><a href="survival.html#topic+coxph">survival::coxph()</a></code>) (used for
the final output of <code>mfp2</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>

<ul>
<li> <p><code>logl</code>: the log likelihood of the fitted model.
</p>
</li>
<li> <p><code>coefficients</code>: regression coefficients.
</p>
</li>
<li> <p><code>df</code>: number of parameters (degrees of freedom).
</p>
</li>
<li> <p><code>sse</code>: residual sum of squares (not used).
</p>
</li>
<li> <p><code>fit</code>: the fitted model object.
</p>
</li></ul>


<hr>
<h2 id='fit_glm'>Function that fits generalized linear models</h2><span id='topic+fit_glm'></span>

<h3>Description</h3>

<p>Function that fits generalized linear models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_glm(x, y, family, weights, offset, fast = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_glm_+3A_x">x</code></td>
<td>
<p>a matrix of predictors with nobs observations.</p>
</td></tr>
<tr><td><code id="fit_glm_+3A_y">y</code></td>
<td>
<p>a vector for the outcome variable.</p>
</td></tr>
<tr><td><code id="fit_glm_+3A_family">family</code></td>
<td>
<p>a family function e.g. <code>stats::gaussian()</code>.</p>
</td></tr>
<tr><td><code id="fit_glm_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of length nobs of 'prior weights' to be used
in the fitting process. see <code><a href="stats.html#topic+glm">stats::glm()</a></code> for details.</p>
</td></tr>
<tr><td><code id="fit_glm_+3A_offset">offset</code></td>
<td>
<p>a numeric vector of length nobs of of a priori known component
to be included in the linear predictor during fitting.</p>
</td></tr>
<tr><td><code id="fit_glm_+3A_fast">fast</code></td>
<td>
<p>a logical which determines how the model is fitted. The default
<code>TRUE</code> uses fast fitting routines (i.e. <code><a href="stats.html#topic+glm">stats::glm.fit()</a></code>), while <code>FALSE</code>
uses the normal fitting routines (<code><a href="stats.html#topic+glm">stats::glm()</a></code>) (used for the final output
of <code>mfp2</code>).
The difference is mainly due to the fact that normal fitting routines have
to handle data.frames, which is a lot slower than using the model matrix
and outcome vectors directly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>

<ul>
<li> <p><code>logl</code>: the log likelihood of the fitted model.
</p>
</li>
<li> <p><code>coefficients</code>: regression coefficients.
</p>
</li>
<li> <p><code>df</code>: number of parameters (degrees of freedom).
</p>
</li>
<li> <p><code>sse</code>: residual sum of squares.
</p>
</li>
<li> <p><code>fit</code>: the fitted model object.
</p>
</li></ul>


<hr>
<h2 id='fit_linear_step'>Function to fit linear model for variable of interest</h2><span id='topic+fit_linear_step'></span>

<h3>Description</h3>

<p>&quot;Linear&quot; model here refers to a model which includes the variable
of interest <code>xi</code> with a fp power of 1. Note that <code>xi</code> may be ACD transformed
if indicated by <code>acdx[xi]</code>.
For parameter definitions, see <code><a href="#topic+find_best_fp_step">find_best_fp_step()</a></code>. All parameters
captured by <code>...</code> are passed on to <code><a href="#topic+fit_model">fit_model()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_linear_step(x, xi, y, powers_current, powers, acdx, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_linear_step_+3A_x">x</code></td>
<td>
<p>an input matrix of dimensions nobs x nvars. Does not contain
intercept, but columns are already expanded into dummy variables as
necessary. Data are assumed to be shifted and scaled.</p>
</td></tr>
<tr><td><code id="fit_linear_step_+3A_xi">xi</code></td>
<td>
<p>a character string indicating the name of the current variable
of interest, for which the best fractional polynomial transformation is
to be estimated in the current step.</p>
</td></tr>
<tr><td><code id="fit_linear_step_+3A_y">y</code></td>
<td>
<p>a vector for the response variable or a <code>Surv</code> object.</p>
</td></tr>
<tr><td><code id="fit_linear_step_+3A_powers_current">powers_current</code></td>
<td>
<p>a list of length equal to the number of variables,
indicating the fp powers to be used in the current step for all variables
(except <code>xi</code>).</p>
</td></tr>
<tr><td><code id="fit_linear_step_+3A_powers">powers</code></td>
<td>
<p>a named list of numeric values that sets the permitted FP
powers for each covariate.</p>
</td></tr>
<tr><td><code id="fit_linear_step_+3A_acdx">acdx</code></td>
<td>
<p>a logical vector of length nvars indicating continuous variables
to undergo the approximate cumulative distribution (ACD) transformation.</p>
</td></tr>
<tr><td><code id="fit_linear_step_+3A_...">...</code></td>
<td>
<p>passed to <code>fit_model()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two entries:
</p>

<ul>
<li> <p><code>powers</code>: fp power(s) of <code>xi</code> (or its ACD transformation) in fitted model.
</p>
</li>
<li> <p><code>metrics</code>: a matrix with performance indices for fitted model.
</p>
</li></ul>


<hr>
<h2 id='fit_mfp'>Function for fitting a model using the MFP or MFPA algorithm</h2><span id='topic+fit_mfp'></span>

<h3>Description</h3>

<p>This function is not exported and is intended to be called from
the <code><a href="#topic+mfp2">mfp2()</a></code> function. While most parameters are explained in
the documentation of <code>mfp2()</code>, their form may differ in this
function. Note that this function does not check its arguments
and expects that its input has been prepared in <code>mfp2()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_mfp(
  x,
  y,
  weights,
  offset,
  cycles,
  scale,
  shift,
  df,
  center,
  family,
  criterion,
  select,
  alpha,
  keep,
  xorder,
  powers,
  method,
  strata,
  nocenter,
  acdx,
  ftest,
  control,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_mfp_+3A_x">x</code></td>
<td>
<p>an input matrix of dimensions nobs x nvars. Does not contain
intercept, but columns are already expanded into dummy variables as
necessary. Data are assumed to be shifted and scaled.</p>
</td></tr>
<tr><td><code id="fit_mfp_+3A_y">y</code></td>
<td>
<p>a vector for the response variable or a <code>Surv</code> object.</p>
</td></tr>
<tr><td><code id="fit_mfp_+3A_weights">weights</code></td>
<td>
<p>a vector of observation weights of length nobs.</p>
</td></tr>
<tr><td><code id="fit_mfp_+3A_offset">offset</code></td>
<td>
<p>a vector of length nobs of offsets.</p>
</td></tr>
<tr><td><code id="fit_mfp_+3A_cycles">cycles</code></td>
<td>
<p>an integer representing the maximum number of
iteration cycles during which FP powers for all predictor are updated.</p>
</td></tr>
<tr><td><code id="fit_mfp_+3A_scale">scale</code></td>
<td>
<p>a numeric vector of length nvars of scaling factors. Not applied,
but re-ordered to conform to <code>xorder</code>.</p>
</td></tr>
<tr><td><code id="fit_mfp_+3A_shift">shift</code></td>
<td>
<p>a numeric vector of length nvars of shifts. Not applied,
but re-ordered to conform to <code>xorder</code>.</p>
</td></tr>
<tr><td><code id="fit_mfp_+3A_df">df</code></td>
<td>
<p>a numeric vector of length nvars of degrees of freedom.</p>
</td></tr>
<tr><td><code id="fit_mfp_+3A_center">center</code></td>
<td>
<p>a logical vector of length nvars indicating if variables are
to be centered.</p>
</td></tr>
<tr><td><code id="fit_mfp_+3A_family">family</code></td>
<td>
<p>a character string representing a family object.</p>
</td></tr>
<tr><td><code id="fit_mfp_+3A_criterion">criterion</code></td>
<td>
<p>a character string defining the criterion used to select
variables and FP models of different degrees.</p>
</td></tr>
<tr><td><code id="fit_mfp_+3A_select">select</code></td>
<td>
<p>a numeric vector of length nvars indicating significance levels
for backward elimination.</p>
</td></tr>
<tr><td><code id="fit_mfp_+3A_alpha">alpha</code></td>
<td>
<p>a numeric vector of length nvars indicating significance levels
for tests between FP models of different degrees.</p>
</td></tr>
<tr><td><code id="fit_mfp_+3A_keep">keep</code></td>
<td>
<p>a character vector with names of variables to be kept
in the model.</p>
</td></tr>
<tr><td><code id="fit_mfp_+3A_xorder">xorder</code></td>
<td>
<p>a string determining the order of entry of the covariates
into the model-selection algorithm.</p>
</td></tr>
<tr><td><code id="fit_mfp_+3A_powers">powers</code></td>
<td>
<p>a named list of numeric values that sets the permitted FP
powers for each covariate.</p>
</td></tr>
<tr><td><code id="fit_mfp_+3A_method">method</code></td>
<td>
<p>a character string specifying the method for tie handling in
Cox regression model.</p>
</td></tr>
<tr><td><code id="fit_mfp_+3A_strata">strata</code></td>
<td>
<p>a factor of all possible combinations of stratification
variables. Returned from <code><a href="survival.html#topic+strata">survival::strata()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_mfp_+3A_nocenter">nocenter</code></td>
<td>
<p>a numeric vector with a list of values for fitting Cox
models. See <code><a href="survival.html#topic+coxph">survival::coxph()</a></code> for details.</p>
</td></tr>
<tr><td><code id="fit_mfp_+3A_acdx">acdx</code></td>
<td>
<p>a logical vector of length nvars indicating which continuous
variables should undergo the approximate cumulative distribution (ACD)
transformation.</p>
</td></tr>
<tr><td><code id="fit_mfp_+3A_ftest">ftest</code></td>
<td>
<p>a logical indicating the use of the F-test for Gaussian models.</p>
</td></tr>
<tr><td><code id="fit_mfp_+3A_control">control</code></td>
<td>
<p>a list with parameters for model fit. See <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>
or <code><a href="stats.html#topic+glm">stats::glm()</a></code> for details.</p>
</td></tr>
<tr><td><code id="fit_mfp_+3A_verbose">verbose</code></td>
<td>
<p>a logical; run in verbose mode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <code><a href="#topic+mfp2">mfp2()</a></code> for details on the returned object.
</p>


<h3>Algorithm</h3>


<ul>
<li><p> Step 1: order variables according to <code>xorder</code>. This step may involve
fitting a regression model to determine order of significance.
</p>
</li>
<li><p> Step 2: input data pre-processing. Setting initial powers for fractional
polynomial terms, checking if acd transformation is required and allowed.
Note that the initial powers of all variables are always set to 1, and higher
FPs are only evaluated in turn for each variables in the first cycle of the
algorithm. See e.g. Sauerbrei and Royston (1999).
</p>
</li>
<li><p> Step 3: run mfp algorithm cycles. See <code><a href="#topic+find_best_fp_cycle">find_best_fp_cycle()</a></code> for more
details.
</p>
</li>
<li><p> Step 4: fit final model using estimated powers.
</p>
</li></ul>



<h3>References</h3>

<p>Sauerbrei, W. and Royston, P., 1999. <em>Building multivariable prognostic
and diagnostic models: transformation of the predictors by using fractional
polynomials. J Roy Stat Soc a Sta, 162:71-94.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mfp2">mfp2()</a></code>, <code><a href="#topic+find_best_fp_cycle">find_best_fp_cycle()</a></code>
</p>

<hr>
<h2 id='fit_model'>Function that fits models supported by <code>mfp2</code></h2><span id='topic+fit_model'></span>

<h3>Description</h3>

<p>Fits generalized linear models and Cox proportional hazard models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_model(
  x,
  y,
  family = "gaussian",
  weights = NULL,
  offset = NULL,
  method = NULL,
  strata = NULL,
  control = NULL,
  rownames = NULL,
  nocenter = NULL,
  fast = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_model_+3A_x">x</code></td>
<td>
<p>a matrix of predictors (excluding intercept) with column names.
If column names are not provided they are set according to
<code>colnames(x, do.NULL = FALSE)</code>.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_y">y</code></td>
<td>
<p>a vector for the outcome variable for glms, and a <code>Surv</code> object
for Cox models.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_family">family</code></td>
<td>
<p>a character strong specifying glm family to be used, or &quot;cox&quot;
for Cox models. The default family is set to 'Gaussian'.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_method">method</code></td>
<td>
<p>a character string specifying the method for tie handling.
See <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_strata">strata</code>, <code id="fit_model_+3A_control">control</code>, <code id="fit_model_+3A_weights">weights</code>, <code id="fit_model_+3A_offset">offset</code>, <code id="fit_model_+3A_rownames">rownames</code>, <code id="fit_model_+3A_nocenter">nocenter</code></td>
<td>
<p>parameters for Cox
or glm. See <code><a href="survival.html#topic+coxph">survival::coxph()</a></code> or <code><a href="stats.html#topic+glm">stats::glm()</a></code> for details.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_fast">fast</code></td>
<td>
<p>passed to <code><a href="#topic+fit_glm">fit_glm()</a></code> and <code><a href="#topic+fit_cox">fit_cox()</a></code>.
</p>
<p>@return
A list with the following components:
</p>

<ul>
<li> <p><code>logl</code>: the log likelihood of the fitted model.
</p>
</li>
<li> <p><code>coefficients</code>: regression coefficients.
</p>
</li>
<li> <p><code>df</code>: number of parameters (degrees of freedom).
</p>
</li>
<li> <p><code>sse</code>: residual sum of squares.
</p>
</li>
<li> <p><code>fit</code>: the object returned by the fitting procedure.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Computations rely on <code><a href="#topic+fit_glm">fit_glm()</a></code> and <code><a href="#topic+fit_cox">fit_cox()</a></code>.
</p>

<hr>
<h2 id='fit_null_step'>Function to fit null model excluding variable of interest</h2><span id='topic+fit_null_step'></span>

<h3>Description</h3>

<p>&quot;Null&quot; model here refers to a model which does not include the variable
of interest <code>xi</code>.
For parameter definitions, see <code><a href="#topic+find_best_fp_step">find_best_fp_step()</a></code>. All parameters
captured by <code>...</code> are passed on to <code><a href="#topic+fit_model">fit_model()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_null_step(x, xi, y, powers_current, powers, acdx, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_null_step_+3A_x">x</code></td>
<td>
<p>an input matrix of dimensions nobs x nvars. Does not contain
intercept, but columns are already expanded into dummy variables as
necessary. Data are assumed to be shifted and scaled.</p>
</td></tr>
<tr><td><code id="fit_null_step_+3A_xi">xi</code></td>
<td>
<p>a character string indicating the name of the current variable
of interest, for which the best fractional polynomial transformation is
to be estimated in the current step.</p>
</td></tr>
<tr><td><code id="fit_null_step_+3A_y">y</code></td>
<td>
<p>a vector for the response variable or a <code>Surv</code> object.</p>
</td></tr>
<tr><td><code id="fit_null_step_+3A_powers_current">powers_current</code></td>
<td>
<p>a list of length equal to the number of variables,
indicating the fp powers to be used in the current step for all variables
(except <code>xi</code>).</p>
</td></tr>
<tr><td><code id="fit_null_step_+3A_powers">powers</code></td>
<td>
<p>a named list of numeric values that sets the permitted FP
powers for each covariate.</p>
</td></tr>
<tr><td><code id="fit_null_step_+3A_acdx">acdx</code></td>
<td>
<p>a logical vector of length nvars indicating continuous variables
to undergo the approximate cumulative distribution (ACD) transformation.</p>
</td></tr>
<tr><td><code id="fit_null_step_+3A_...">...</code></td>
<td>
<p>passed to <code>fit_model()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two entries:
</p>

<ul>
<li> <p><code>powers</code>: fp power(s) of <code>xi</code> in fitted model - in this case <code>NA</code>.
</p>
</li>
<li> <p><code>metrics</code>: a matrix with performance indices for fitted model.
</p>
</li></ul>


<hr>
<h2 id='fp'>Helper to assign attributes to a variable undergoing FP-transformation</h2><span id='topic+fp'></span><span id='topic+fp2'></span>

<h3>Description</h3>

<p>Used in formula interface to <code>mfp2()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fp(
  x,
  df = 4,
  alpha = 0.05,
  select = 0.05,
  shift = NULL,
  scale = NULL,
  center = TRUE,
  acdx = FALSE,
  powers = NULL
)

fp2(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fp_+3A_x">x</code></td>
<td>
<p>a vector representing a continuous variable undergoing
fp-transformation.</p>
</td></tr>
<tr><td><code id="fp_+3A_df">df</code>, <code id="fp_+3A_alpha">alpha</code>, <code id="fp_+3A_select">select</code>, <code id="fp_+3A_shift">shift</code>, <code id="fp_+3A_scale">scale</code>, <code id="fp_+3A_center">center</code>, <code id="fp_+3A_acdx">acdx</code></td>
<td>
<p>See <code><a href="#topic+mfp2">mfp2()</a></code>) for details.</p>
</td></tr>
<tr><td><code id="fp_+3A_powers">powers</code></td>
<td>
<p>a vector of powers to be evaluated for <code>x</code>. Default is <code>NULL</code>
and <code>powers = c(-2, -1, -0.5, 0, 0.5, 1, 2, 3)</code> will be used.</p>
</td></tr>
<tr><td><code id="fp_+3A_...">...</code></td>
<td>
<p>used in alias <code>fp2</code> to pass arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector <code>x</code> with new attributes relevant for fp-transformation. All
arguments passed to this function will be stored as attributes.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fp2()</code>: Alias for <code>fp()</code> - use in formula when both <code>mfp</code> and <code>mfp2</code> are loaded to avoid name shadowing.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
xr = 1:10
fp(xr)
fp2(xr)
</code></pre>

<hr>
<h2 id='fracplot'>Plot response functions from a fitted <code>mfp2</code> object</h2><span id='topic+fracplot'></span><span id='topic+plot_mfp'></span>

<h3>Description</h3>

<p>Plots the partial linear predictors with confidence limits
against the selected covariate(s) of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fracplot(
  model,
  terms = NULL,
  partial_only = FALSE,
  type = c("terms", "contrasts"),
  ref = NULL,
  terms_seq = c("data", "equidistant"),
  alpha = 0.05,
  color_points = "#AAAAAA",
  color_line = "#000000",
  color_fill = "#000000",
  shape = 1,
  size_points = 1,
  linetype = "solid",
  linewidth = 1,
  alpha_fill = 0.1
)

plot_mfp(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fracplot_+3A_model">model</code></td>
<td>
<p>fitted <code>mfp2</code> model.</p>
</td></tr>
<tr><td><code id="fracplot_+3A_terms">terms</code></td>
<td>
<p>character vector with variable names to be plotted.</p>
</td></tr>
<tr><td><code id="fracplot_+3A_partial_only">partial_only</code></td>
<td>
<p>a logical value indicating whether only the partial
predictor (component) is drawn (<code>TRUE</code>), or also component-plus-residual
(<code>FALSE</code>, the default). Only used if <code>type = "terms"</code>. See below for details.</p>
</td></tr>
<tr><td><code id="fracplot_+3A_type">type</code>, <code id="fracplot_+3A_ref">ref</code>, <code id="fracplot_+3A_terms_seq">terms_seq</code></td>
<td>
<p>arguments of <code><a href="#topic+predict.mfp2">predict.mfp2()</a></code>. Only
<code>type = "terms"</code> and <code>type = "contrasts"</code> are supported by this function.</p>
</td></tr>
<tr><td><code id="fracplot_+3A_alpha">alpha</code></td>
<td>
<p><code>alpha</code> argument of <code><a href="#topic+predict.mfp2">predict.mfp2()</a></code>.</p>
</td></tr>
<tr><td><code id="fracplot_+3A_color_line">color_line</code>, <code id="fracplot_+3A_linetype">linetype</code>, <code id="fracplot_+3A_linewidth">linewidth</code></td>
<td>
<p><code>ggplot2</code> properties of line for
partial predictor.</p>
</td></tr>
<tr><td><code id="fracplot_+3A_color_fill">color_fill</code>, <code id="fracplot_+3A_alpha_fill">alpha_fill</code></td>
<td>
<p><code>ggplot2</code> properties of ribbon for confidence
interval.</p>
</td></tr>
<tr><td><code id="fracplot_+3A_shape">shape</code>, <code id="fracplot_+3A_size_points">size_points</code>, <code id="fracplot_+3A_color_points">color_points</code></td>
<td>
<p><code>ggplot2</code> properties of drawn
data points.</p>
</td></tr>
<tr><td><code id="fracplot_+3A_...">...</code></td>
<td>
<p>used in alias <code>plot_mfp</code> to pass arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The confidence limits of the partial linear predictors or contrasts are
obtained from the variance–covariance matrix of the final fitted model,
which takes into account the uncertainty in estimating the model parameters
but not the FP powers. This can lead to narrow confidence intervals. A simple
way to obtain more realistic confidence intervals within the FP is by using
bootstrap, which is not currently implemented. See Royston and Sauerbrei (2008)
chapter 4.9.2 for guidance on conducting bootstrapping within
the FP class.
</p>
<p>The component-plus-residual, is the partial linear predictor plus residuals,
where deviance residuals are used in generalized linear regression models,
while martingale residuals are used in Cox models, as done in Stata mfp program.
This kind of plot is only available if <code>type = "terms"</code>.
</p>


<h3>Value</h3>

<p>A list of <code>ggplot2</code> plot objects, one for each term requested. Can be
drawn as individual plots or facetted / combined easily using e.g.
<code>patchwork::wrap_plots</code> and further customized.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>plot_mfp()</code>: Alias for fracplot.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+predict.mfp2">predict.mfp2()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Gaussian
data("prostate")
x = as.matrix(prostate[,2:8])
y = as.numeric(prostate$lpsa)
# default interface
fit = mfp2(x, y, verbose = FALSE)
fracplot(fit) # generate plots

</code></pre>

<hr>
<h2 id='gbsg'>Breast cancer dataset used in the Royston and Sauerbrei (2008) book.</h2><span id='topic+gbsg'></span>

<h3>Description</h3>

<p>Breast cancer dataset used in the Royston and Sauerbrei (2008) book.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gbsg)
</code></pre>


<h3>Format</h3>

<p>A dataset with 686 observations and 11 variables.
</p>

<dl>
<dt>id</dt><dd><p>Patient identifier.</p>
</dd>
<dt>age</dt><dd><p>Age in years.</p>
</dd>
<dt>meno</dt><dd><p>Menopausal status (0 = premeno, 1 = postmeno).</p>
</dd>
<dt>size</dt><dd><p>Tumor size (mm).</p>
</dd>
<dt>grade</dt><dd><p>Tumor grade.</p>
</dd>
<dt>nodes</dt><dd><p>Number of positive lymph nodes.</p>
</dd>
<dt>enodes</dt><dd><p>exp(-0.12*nodes).</p>
</dd>
<dt>pgr</dt><dd><p>Progesterone receptor status.</p>
</dd>
<dt>er</dt><dd><p>Estrogen receptor status.</p>
</dd>
<dt>hormon</dt><dd><p>Tamoxifen treatment.</p>
</dd>
<dt>rectime</dt><dd><p>Time (days) to death or cancer recurrence.</p>
</dd>
<dt>censrec</dt><dd><p>Censoring (0 = censored, 1 = event).</p>
</dd>
</dl>


<hr>
<h2 id='generate_combinations_with_replacement'>Helper function to generate combinations with replacement</h2><span id='topic+generate_combinations_with_replacement'></span>

<h3>Description</h3>

<p>This very simple helper generates combinations with replacement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_combinations_with_replacement(x, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_combinations_with_replacement_+3A_x">x</code></td>
<td>
<p>vector of elements to choose from.</p>
</td></tr>
<tr><td><code id="generate_combinations_with_replacement_+3A_k">k</code></td>
<td>
<p>number of elements to choose.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is replicating the functionality from <code>arrangements::combinations</code> with
<code>replace = TRUE</code>. Note that base R function <code>utils::combn</code> only returns
combinations without replacement, thus pairs like (0, 0) are not in the
output.
</p>
<p>Note that this function is extremely inefficient and only intended to be
used with small use cases, i.e. small k. This is typically the case in the
context of MFP, but a warning is given if this is not the case since the
algorithm may take a while to compute the combinations, and even longer
to do model selection.
</p>


<h3>Value</h3>

<p>A m x k matrix, where m is the number of combinations.
</p>

<hr>
<h2 id='generate_powers_fp'>Function that generates a matrix of FP powers for any degree</h2><span id='topic+generate_powers_fp'></span><span id='topic+generate_powers_acd'></span>

<h3>Description</h3>

<p>Function that generates a matrix of FP powers for any degree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_powers_fp(degree = NULL, powers = NULL)

generate_powers_acd(degree = NULL, powers = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_powers_fp_+3A_degree">degree</code></td>
<td>
<p>The degree of fractional polynomial. For example,
degree = 1 is FP1 and returns 8 powers; degree 2 is FP2 and
returns 36 pairs of powers; degree 3 is FP3 and returns 120
triples of powers, and so on. If the ACD transformation is used,
this degree is assumed to be 2.</p>
</td></tr>
<tr><td><code id="generate_powers_fp_+3A_powers">powers</code></td>
<td>
<p>the set of allowed powers for the fractional polynomials.
Default is <code>NULL</code> and the set <code class="reqn">(-2, -1, -0.5, 0, 0.5, 1, 2, 3)</code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For FP powers, this function returns all combinations of the powers of
length <code>degree</code>, that is all pairs in which each entry is taken from the
set <code>powers</code>, but no pair is repeated (i.e. the order of the entries does
not matter).
Thus, for the default set of powers and degree 2, this function returns
36 combinations.
</p>
<p>For ACD powers, this function simply returns all possible tuples of
powers of length n.
Thus, for the default set of powers, this function returns 8 possible
powers, and for degree 2 it returns 64 pairs of powers. Higher degrees
are not supported by the function. In case that <code>degree = 0</code> or <code>degree = 1</code>,
the first column of the matrix representing untransformed data are set to
<code>NA</code> to indicate that the normal data do not play a role. Higher degrees
than two are not supported.
</p>


<h3>Value</h3>

<p>A matrix of powers with degree columns and rows depending on the <code>degree</code>.
For ACD powers always a matrix with two columns. For normal fps each row
will be sorted in increasing order (in alignment with
how <code><a href="#topic+transform_vector_fp">transform_vector_fp()</a></code> processes the data).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>generate_powers_acd()</code>: Function to generate acd powers.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>powx &lt;- c(-2, -1, -0.5, 0, 0.5, 1, 2, 3)
generate_powers_fp(degree = 2, powers = powx)
generate_powers_acd(degree = 2, powers = powx)

</code></pre>

<hr>
<h2 id='generate_transformations_fp'>Function to generate all requested FP transformations for a single variable</h2><span id='topic+generate_transformations_fp'></span><span id='topic+generate_transformations_acd'></span>

<h3>Description</h3>

<p>Function to generate all requested FP transformations for a single variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_transformations_fp(x, degree, powers)

generate_transformations_acd(x, degree, powers)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_transformations_fp_+3A_x">x</code></td>
<td>
<p>a numeric vector of length nobs assumed to have been shifted and
scaled.</p>
</td></tr>
<tr><td><code id="generate_transformations_fp_+3A_degree">degree</code></td>
<td>
<p>numeric indicating the degree of FPs. Assumed to be 2 for acd
transformation.</p>
</td></tr>
<tr><td><code id="generate_transformations_fp_+3A_powers">powers</code></td>
<td>
<p>a vector of allowed FP powers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any FP transformation is given by a vector of powers, e.g. (p1, p2) for
degree 2. These correspond to powers x^p1 and x^p2. Thus, we only need to
consider combinations of all values in <code>powers</code>, since order of the entries
does not matter. See <code><a href="#topic+generate_powers_fp">generate_powers_fp()</a></code>.
A special case are repeated powers, i.e. p1 = p2. In this case, the repeated
entries are multiplied by log(x) (see <code><a href="#topic+transform_vector_fp">transform_vector_fp()</a></code>).
</p>
<p>When the ACD transformation is requested, then all pairs of length 2
are considered, i.e. 64. See <code><a href="#topic+generate_powers_acd">generate_powers_acd()</a></code>.
</p>
<p>If <code>degree = 0</code> then these functions return the data unchanged for fp,
or simply the acd transformation of the input variable, i.e. in both cases
the power is set to 1 (linear).
</p>


<h3>Value</h3>

<p>A list with two entries:
</p>

<ul>
<li> <p><code>data</code>: a list with length equal to the number of possible FPs for the
variable of interest. Each entry is a matrix with degree many columns,
and nobs observations comprising the FP transformed input variable.
For example, for degree = 2 and nobs = 10, each entry is a 10 x 2 matrix.
Values are not centered. If <code>degree = 0</code>, the single entry has a single
column.
</p>
</li>
<li> <p><code>powers</code>: the associated FP powers for each entry in data.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>generate_transformations_acd()</code>: Function to generate acd transformations.
</p>
</li></ul>

<hr>
<h2 id='get_selected_variable_names'>Helper function to extract selected variables from fitted <code>mfp2</code> object</h2><span id='topic+get_selected_variable_names'></span>

<h3>Description</h3>

<p>Simply extracts all variables for which not all powers are estimated to
be <code>NA</code>. The names refer to the original names in the dataset and do not
include transformations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_selected_variable_names(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_selected_variable_names_+3A_object">object</code></td>
<td>
<p>fitted <code>mfp2</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of names, ordered as defined by <code>xorder</code> in <code><a href="#topic+mfp2">mfp2()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Gaussian model
data("prostate")
x = as.matrix(prostate[,2:8])
y = as.numeric(prostate$lpsa)
# default interface
fit = mfp2(x, y, verbose = FALSE)
get_selected_variable_names(fit)

</code></pre>

<hr>
<h2 id='mfp2'>Multivariable Fractional Polynomial Models with Extensions</h2><span id='topic+mfp2'></span><span id='topic+mfp2.default'></span><span id='topic+mfp2.formula'></span>

<h3>Description</h3>

<p>Selects the multivariable fractional polynomial (MFP) model that best predicts
the outcome variable. It also has the ability to model a sigmoid relationship
between <code>x</code> and an outcome variable <code>y</code> using the approximate cumulative
distribution (ACD) transformation proposed by Royston (2014).
This function provides two interfaces for input data: one for inputting
data matrix <code>x</code> and  outcome vector <code>y</code> directly and the other for using a
<code>formula</code> object together with a dataframe <code>data</code>. Both interfaces are
equivalent in terms of functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfp2(x, ...)

## Default S3 method:
mfp2(
  x,
  y,
  weights = NULL,
  offset = NULL,
  cycles = 5,
  scale = NULL,
  shift = NULL,
  df = 4,
  center = TRUE,
  subset = NULL,
  family = c("gaussian", "poisson", "binomial", "cox"),
  criterion = c("pvalue", "aic", "bic"),
  select = 0.05,
  alpha = 0.05,
  keep = NULL,
  xorder = c("ascending", "descending", "original"),
  powers = NULL,
  ties = c("breslow", "efron", "exact"),
  strata = NULL,
  nocenter = NULL,
  acdx = NULL,
  ftest = FALSE,
  control = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'formula'
mfp2(
  formula,
  data,
  weights = NULL,
  offset = NULL,
  cycles = 5,
  scale = NULL,
  shift = NULL,
  df = 4,
  center = TRUE,
  subset = NULL,
  family = c("gaussian", "poisson", "binomial", "cox"),
  criterion = c("pvalue", "aic", "bic"),
  select = 0.05,
  alpha = 0.05,
  keep = NULL,
  xorder = c("ascending", "descending", "original"),
  powers = NULL,
  ties = c("breslow", "efron", "exact"),
  strata = NULL,
  nocenter = NULL,
  ftest = FALSE,
  control = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mfp2_+3A_x">x</code></td>
<td>
<p>for <code>mfp2.default</code>: <code>x</code> is an input matrix of dimensions
nobs x nvars. Each row is an observation vector.</p>
</td></tr>
<tr><td><code id="mfp2_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="mfp2_+3A_y">y</code></td>
<td>
<p>for <code>mfp2.default</code>: <code>y</code> is a vector for the response variable.
For <code>family = "binomial"</code> it should be  a vector with two levels (see
<code><a href="stats.html#topic+glm">stats::glm()</a></code>). For <code>family = "cox"</code> it must be a <code><a href="survival.html#topic+Surv">survival::Surv()</a></code> object
containing 2 columns.</p>
</td></tr>
<tr><td><code id="mfp2_+3A_weights">weights</code></td>
<td>
<p>a vector of observation weights of length nobs.
Default is <code>NULL</code> which assigns a weight of 1 to each observation.</p>
</td></tr>
<tr><td><code id="mfp2_+3A_offset">offset</code></td>
<td>
<p>a vector of length nobs that is included in the linear
predictor. Useful for the poisson family (e.g. log of exposure time).
Default is <code>NULL</code> which assigns an offset  of 0 to each observation.
If supplied, then values must also be supplied to the <code>predict()</code> function.</p>
</td></tr>
<tr><td><code id="mfp2_+3A_cycles">cycles</code></td>
<td>
<p>an integer, specifying the maximum number of iteration cycles.
Default is 5.</p>
</td></tr>
<tr><td><code id="mfp2_+3A_scale">scale</code></td>
<td>
<p>a numeric vector of length nvars or single numeric specifying
scaling factors. If a single numeric, then the value will be replicated as
necessary. The formula interface <code>mfp2.formula</code> only supports single numeric
input to set a default value, individual values can be set using <code>fp</code> terms
in the <code>formula</code> input.
Default is <code>NULL</code> which lets the program estimate the scaling factors
(see Details section). If scaling is not required set <code>scale = 1</code> to disable
it.</p>
</td></tr>
<tr><td><code id="mfp2_+3A_shift">shift</code></td>
<td>
<p>a numeric vector of length nvars or a single numeric specifying
shift terms. If a single numeric, then the value will be replicated as
necessary. The formula interface <code>mfp2.formula</code> only supports single numeric
input to set a default value, individual values can be set using <code>fp</code> terms
in the <code>formula</code> input.
Default is <code>NULL</code> which lets the program estimate the shifts
(see Details section). If shifting is not required, set <code>shift = 0</code> to
disable it.</p>
</td></tr>
<tr><td><code id="mfp2_+3A_df">df</code></td>
<td>
<p>a numeric vector of length nvars or a single numeric that sets the
(default) degrees of freedom (df) for each predictor. If a single numeric,
then the value will be replicated as necessary. The formula interface
<code>mfp2.formula</code> only supports single numeric input to set a default value,
individual values can be set using <code>fp</code> terms in the <code>formula</code> input.
The df (not counting the intercept) are twice the degree of a fractional
polynomial (FP). For example, an FP2 has 4 df, while FPm has 2*m df.
The program overrides default df based on the number of distinct (unique)
values for a variable as follows:
2-3 distinct values are assigned <code>df = 1</code> (linear), 4-5 distinct values are
assigned <code>df = min(2, default)</code> and &gt;= 6 distinct values are assigned
<code>df = default</code>.</p>
</td></tr>
<tr><td><code id="mfp2_+3A_center">center</code></td>
<td>
<p>a logical determining whether variables are centered before
final model fitting. The default <code>TRUE</code> implies mean centering, except for
binary covariates, where the covariate is centered using the lower of the two
distinct values of the covariate. See Details section below.</p>
</td></tr>
<tr><td><code id="mfp2_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process. Default is <code>NULL</code> and all observations are
used. See Details below.</p>
</td></tr>
<tr><td><code id="mfp2_+3A_family">family</code></td>
<td>
<p>a character string representing a <code>glm()</code> family object as well
as Cox models. For more information, see details section below.</p>
</td></tr>
<tr><td><code id="mfp2_+3A_criterion">criterion</code></td>
<td>
<p>a character string specifying the criterion used to select
variables and FP models of different degrees.
Default is to use p-values in which case the user can specify
the nominal significance level (or use default level of 0.05) for variable and
functional form selection (see <code>select</code> and <code>alpha</code> parameters below).
If the user specifies the BIC (<code>bic</code>) or AIC (<code>aic</code>) criteria the program
ignores the nominal significance levels and selects variables and functional
forms using the chosen information criterion.</p>
</td></tr>
<tr><td><code id="mfp2_+3A_select">select</code></td>
<td>
<p>a numeric vector of length nvars or a single numeric that
sets the nominal significance levels for variable selection on each predictor
by backward elimination. If a single numeric, then the value will be replicated
as necessary. The formula interface <code>mfp2.formula</code> only supports single numeric
input to set a default value, individual values can be set using <code>fp</code> terms
in the <code>formula</code> input. The default nominal significance level is 0.05
for all variables. Setting the nominal significance level to be 1 for
certain variables forces them into the model, leaving all other variables
to be selected.</p>
</td></tr>
<tr><td><code id="mfp2_+3A_alpha">alpha</code></td>
<td>
<p>a numeric vector of length nvars or a single numeric that
sets the significance levels for testing between FP models of
different degrees. If a single numeric, then the value will be replicated
as necessary. The formula interface <code>mfp2.formula</code> only supports single numeric
input to set a default value, individual values can be set using <code>fp</code> terms
in the <code>formula</code> input. The default nominal significance level is 0.05 for all
variables.</p>
</td></tr>
<tr><td><code id="mfp2_+3A_keep">keep</code></td>
<td>
<p>a character vector with names of variables to be kept
in the model. In case that <code>criterion = "pvalue"</code>, this is equivalent to
setting the selection level for the variables in <code>keep</code> to 1.
However, this option also keeps the specified variables in the model when
using the BIC or AIC criteria.</p>
</td></tr>
<tr><td><code id="mfp2_+3A_xorder">xorder</code></td>
<td>
<p>a string determining the order of entry of the covariates
into the model-selection algorithm. The default is <code>ascending</code>, which enters
them by ascending p-values, or decreasing order of significance in a
multiple regression (i.e. most significant first).
<code>descending</code> places them in reverse significance order, whereas
<code>original</code> respects the original order in <code>x</code>.</p>
</td></tr>
<tr><td><code id="mfp2_+3A_powers">powers</code></td>
<td>
<p>a named list of numeric values that sets the permitted FP
powers for each covariate. The default is NULL, and each covariate is assigned
<code>powers = c(-2, -1, -0.5, 0, 0.5, 1, 2, 3)</code>, where 0 means the natural
logarithm. Powers are sorted before further
processing in the program. If some variables are not assigned powers, the
default powers will be assigned. The formula interface offers two options
for supplying powers: through the 'powers' argument and the 'fp()' function.
So, if the user supplies powers in both options for a certain variable, the
powers supplied through 'fp()' will be given preference.For the algorithm to
select the powers, each variable must have a minimum of two powers. If the
users wants to use one power, they should first transform their variables
before using <code>mfp2()</code> function and specify appropriate df</p>
</td></tr>
<tr><td><code id="mfp2_+3A_ties">ties</code></td>
<td>
<p>a character string specifying the method for tie handling in
Cox regression. If there are no tied death times all the methods are
equivalent. Default is the Breslow method. This argument is used for Cox
models only and has no effect on other model families.
See <code><a href="survival.html#topic+coxph">survival::coxph()</a></code> for details.</p>
</td></tr>
<tr><td><code id="mfp2_+3A_strata">strata</code></td>
<td>
<p>a numeric vector or matrix of variables that define strata
to be used for stratification in a Cox model. A new factor, whose levels are
all possible combinations of the variables supplied will be created.
Default is <code>NULL</code> and a Cox model without stratification would be fitted.
See <code><a href="survival.html#topic+coxph">survival::coxph()</a></code> for details.</p>
</td></tr>
<tr><td><code id="mfp2_+3A_nocenter">nocenter</code></td>
<td>
<p>a numeric vector with a list of values for fitting Cox
models. See <code><a href="survival.html#topic+coxph">survival::coxph()</a></code> for details.</p>
</td></tr>
<tr><td><code id="mfp2_+3A_acdx">acdx</code></td>
<td>
<p>a numeric vector of names of continuous variables to undergo
the approximate cumulative distribution (ACD) transformation.
It also invokes the function-selection procedure to determine the
best-fitting FP1(p1, p2) model (see Details section). Not present in the
formula interface <code>mfp2.formula</code> and to be set using <code>fp</code> terms in the
<code>formula</code> input.
The variable representing the ACD transformation of <code>x</code> is named <code>A_x</code>.</p>
</td></tr>
<tr><td><code id="mfp2_+3A_ftest">ftest</code></td>
<td>
<p>a logical; for normal error models with small samples, critical
points from the F-distribution can be used instead of Chi-Square
distribution. Default <code>FALSE</code> uses the latter. This argument is used for
Gaussian models only and has no effect for other model families.</p>
</td></tr>
<tr><td><code id="mfp2_+3A_control">control</code></td>
<td>
<p>a list object with parameters controlling model fit details.
Returned by either <code><a href="stats.html#topic+glm.control">stats::glm.control()</a></code> or <code><a href="survival.html#topic+coxph.control">survival::coxph.control()</a></code>.
Default is <code>NULL</code> to use default parameters for the given model class.</p>
</td></tr>
<tr><td><code id="mfp2_+3A_verbose">verbose</code></td>
<td>
<p>a logical; run in verbose mode.</p>
</td></tr>
<tr><td><code id="mfp2_+3A_formula">formula</code></td>
<td>
<p>for <code>mfp2.formula</code>: an object of class <code>formula</code>: a symbolic
description of the model to be fitted. Special <code>fp</code> terms can be used to
define fp-transformations. The details of model specification are given
under ‘Details’.</p>
</td></tr>
<tr><td><code id="mfp2_+3A_data">data</code></td>
<td>
<p>for <code>mfp2.formula</code>: a <code>data.frame</code> which contains all variables
specified in <code>formula</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mfp2()</code> returns an object of class inheriting from <code>glm</code> or <code>copxh</code>,
depending on the <code>family</code> parameter.
</p>
<p>The function <code>summary()</code> (i.e. <code><a href="#topic+summary.mfp2">summary.mfp2()</a></code>) can be used to obtain or
print a summary of the results.
The generic accessor function <code>coef()</code> can be used to extract the vector of
coefficients from the fitted model object.
The generic <code>predict()</code> can be used to obtain predictions from the fitted
model object.
</p>
<p>An object of class <code>mfp2</code> is a list containing all entries as for <code>glm</code>
or <code>coxph</code>, and in addition the following entries:
</p>

<ul>
<li><p> convergence_mfp: logical value indicating convergence of mfp algorithm.
</p>
</li>
<li><p> fp_terms: a data.frame with information on fractional polynomial
terms.
</p>
</li>
<li><p> transformations: a data.frame with information on shifting, scaling
and centering for all variables.
</p>
</li>
<li><p> fp_powers: a list with all powers of fractional polynomial terms.
Each entry of the list is named according to the transformation of the
variable.
</p>
</li>
<li><p> acd: a vector with information for which variables the acd
transformation was applied.
</p>
</li>
<li><p> x_original: the scaled and shifted input matrix but without
transformations.
</p>
</li>
<li><p> y: the original outcome variable.
</p>
</li>
<li><p> x: the final transformed input matrix used to fit the final model.
</p>
</li>
<li><p> call_mfp: the call to the <code>mfp2()</code> function.
</p>
</li>
<li><p> family_string: the family stored as character string.
</p>
</li></ul>

<p>The <code>mfp2</code> object may contain further information depending on family.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>mfp2(default)</code>: Default method using input matrix <code>x</code> and outcome vector <code>y</code>.
</p>
</li>
<li> <p><code>mfp2(formula)</code>: Provides formula interface for <code>mfp2</code>.
</p>
</li></ul>


<h3>Brief summary of FPs</h3>

<p>In the following we denote fractional polynomials for a variable <code class="reqn">x</code> by
increasing complexity as either FP1 or FP2. In this example,
<code class="reqn">FP2(p1, p2)</code> for <code class="reqn">p1\neq p2</code> is the most flexible FP transformation,
where </p>
<p style="text-align: center;"><code class="reqn">FP2(p1, p2) = \beta_1 x^{p1} + \beta_2 x^{p2}.</code>
</p>

<p>When <code class="reqn">p1 = p2</code> (repeated powers), the FP2 model is given by
</p>
<p style="text-align: center;"><code class="reqn">FP2(p1, p2) = \beta_1 x^{p1} + \beta_2 x^{p1}log(x).</code>
</p>

<p>The powers <code class="reqn">p1</code> and <code class="reqn">p2</code> are usually chosen from a predefined set
of powers <code class="reqn">S = {(-2, -1, -0.5, 0, 0.5, 1, 2, 3)}</code> where the power
of 0 indicates the natural logarithm. The best FP2 is then estimated by using a
closed testing procedure that seeks the best combination from all 36 pairs of
powers <code class="reqn">(p1, p2)</code>. Functions that only involve a single power of
the variable are denoted as FP1, i.e.
</p>
<p style="text-align: center;"><code class="reqn">FP1(p1) = \beta_1 x^{p1}.</code>
</p>

<p>For details see e.g. Sauerbrei et al (2006).
</p>


<h3>Details on <code>family</code> option</h3>

<p><code>mfp2()</code> supports the family object as used by <code><a href="stats.html#topic+glm">stats::glm()</a></code>. The built in
families are specified via a character string. <code>mfp2(..., family = "binomial")</code>
fits a logistic regression model, while <code>mfp2(..., family = "gaussian")</code>
fits a linear regression (ordinary least squares) model.
</p>
<p>For Cox models, the response should preferably be a <code>Surv</code> object,
created by the <code><a href="survival.html#topic+Surv">survival::Surv()</a></code> function, and the <code>family = "cox"</code>.
Only right-censored data are currently supported. To fit stratified Cox
models, the <code>strata</code> option can be used, or alternatively <code>strata</code> terms
can be included in the model formula when using the formula interface
<code>mfp2.formula</code>.
</p>


<h3>Details on shifting, scaling, centering</h3>

<p>Fractional polynomials are defined only for positive variables due to the
use of logarithms and other powers. Thus, <code>mfp2()</code> estimates shifts for
each variables to ensure positivity or assumes that the variables are
already positive when computing fractional powers of the input variables
in case that shifting is disabled manually.
</p>
<p>If the values of the variables are too large or too small, it is important to
conduct variable scaling to reduce the chances of numerical underflow or
overflow which can lead to inaccuracies and difficulties in estimating the
model. Scaling can be done automatically or by directly specifying the
scaling values so that the magnitude of the <code>x</code> values are not too extreme.
By default scaling factors are estimated by the program as follows.
</p>
<p>After adjusting the location of <code class="reqn">x</code> so that its minimum value is positive,
creating <code class="reqn">x'</code>, automatic scaling will divide each value of <code class="reqn">x'</code> by
<code class="reqn">10^p</code> where the exponent <code class="reqn">p</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">p = sign(k) \times floor(|k|) \quad \text{where} \quad k = log_{10} (max(x')- min(x'))</code>
</p>

<p>The FP transformation of <code class="reqn">x'</code> is centered on the mean of the observed
values of <code class="reqn">x'</code>. For example, for the FP1 model <code class="reqn">\beta_0 + \beta_1x^p</code>,
the actual model fitted by the software would be
<code class="reqn">\beta'_0 + \beta'_1(x'^p-mean(x'^p))</code>. This approach ensures that
the revised constant <code class="reqn">\beta'_0</code> or baseline hazard function in a Cox
model retains a meaningful interpretation.
</p>
<p>So in brief: shifting is required to make input values positive, scaling
helps to bring the values to a reasonable range. Both operations are
conducted before estimating the FP powers for an input variable.
Centering, however, is done after estimating the FP functions for each
variable.
Centering before estimating the FP powers may result in different powers and
should be avoided. Also see <code><a href="#topic+transform_vector_fp">transform_vector_fp()</a></code> for some more details.
</p>


<h3>Details on the <code>subset</code> argument</h3>

<p>Note that subsetting occurs after data pre-processing (shifting and scaling),
but before model selection and fitting. In detail, when the option <code>subset</code> is
used and scale, shift or centering values are to be estimated, then <code>mfp2()</code>
first estimates these parameters using the full dataset (no subsetting).
It then conduct subsetting before proceeding to perform model selection and
fitting on the specified subset of the data.
</p>
<p>Therefore, subsetting in <code>mfp2()</code> is not equivalent to subsetting the data
before passing it to <code>mfp2()</code>, and thus cannot be used to implement, for example,
cross-validation or to remove <code>NA</code>. These tasks should be done by the caller
beforehand. However, it does allow to use the same data pre-processing
for different subsets of the data. An example use case is when separate
models are to be estimated for women and men in the dataset, but a common
data pre-processing should be applied. In this case the <code>subset</code> option
can be used to restrict model selection to either women or men, but the
data processing (e.g. shifting factors) will be shared between the two models.
</p>


<h3>Details on  approximate cumulative distribution transformation</h3>

<p>The approximate cumulative distribution (ACD) transformation (Royston 2014)
converts each predictor, <code class="reqn">x</code>, smoothly to an approximation, <code class="reqn">acd(x)</code>,
of its empirical cumulative distribution function.
This is done by smoothing a probit transformation of
the scaled ranks of <code class="reqn">x</code>. <code class="reqn">acd(x)</code> could be used instead of <code class="reqn">x</code>
as a covariate. This has the advantage of providing sigmoid curves, something
that regular FP functions cannot achieve.
Details of the precise definition and some possible uses of the ACD
transformation in a univariate context are given by Royston (2014).
Royston and Sauerbrei (2016) describes how one could go further and replace FP2
functions with a pair of FP1 functions, one in <code class="reqn">x</code> and the other in
<code class="reqn">acd(x)</code>.
</p>
<p>This alternative class of four-parameter functions provides about
the same flexibility as the standard FP2 family, but the ACD component offers
the additional possibility of sigmoid functions.
Royston (2014) discusses how the extended class of functions known as
<code class="reqn">FP1(p1, p2)</code>, namely
</p>
<p style="text-align: center;"><code class="reqn">FP1(p1, p2) = \beta_1 x^{p1} + \beta_2 acd(x)^{p2}</code>
</p>

<p>can be fitted optimally by seeking the best combination of all 64 pairs of
powers (p1, p2). The optimisation is invoked by use of the <code>acdx</code> parameter.
Royston (2014) also described simplification of the chosen function through
model reduction by applying significance testing to six sub-families of
functions,M1-M6, giving models M1 (most complex) through M6 (null):
</p>

<ul>
<li><p> M1: FP1(p1, p2) (no simplification)
</p>
</li>
<li><p> M2: FP1(p1, .) (regular FP1 function of <code class="reqn">x</code>)
</p>
</li>
<li><p> M3: FP1(., p2) (regular FP1 function of <code class="reqn">acd(x)</code>)
</p>
</li>
<li><p> M4: FP1(1, .) (linear function of <code class="reqn">x</code>)
</p>
</li>
<li><p> M5: FP1(., 1) (linear function of <code class="reqn">acd(x)</code>)
</p>
</li>
<li><p> M6: Null (<code class="reqn">x</code> omitted entirely)
</p>
</li></ul>

<p>Selection among these six sub-functions is performed by a closed test
procedure known as the function-selection pocedure FSPA.
It maintains the family-wise type 1 error
probability for selecting <code class="reqn">x</code> at the value determined by the
<code>select</code> parameter. To obtain a 'final' model, a structured sequence of up
to five tests is carried out, the first at the significance level specified
by the <code>select</code> parameter, and the remainder at the significance level
provided by the <code>alpha</code> option.
The sequence of tests is as follows:
</p>

<ul>
<li><p> Test 1: Compare the deviances of models 6 and 1 on 4 d.f.
If not significant then stop and omit <code class="reqn">x</code>, otherwise continue to step 2.
</p>
</li>
<li><p> Test 2: Compare the deviances of models 4 and 1 on 3 d.f.
If not significant then accept model 4 and stop. Otherwise, continue to step 3.
</p>
</li>
<li><p> Test 3: Compare the deviance of models 2 and 1 on 2 d.f.
If not significant then accept model 2 and stop. Otherwise continue to step 4.
</p>
</li>
<li><p> Test 4: Compare the deviance of models 3 and 1 on 2 d.f.
If significant then model 1 cannot be simplified; accept model 1 and stop.
Otherwise continue to step 5.
</p>
</li>
<li><p> Test 5: Compare the deviances of models 5 and 3 on 1 d.f.
If significant then model 3 cannot be simplified; accept model 3.
Otherwise, accept model 5. End of procedure.
</p>
</li></ul>

<p>The result is the selection of one of the six models.
</p>


<h3>Details on model specification using a <code>formula</code></h3>

<p><code>mfp2</code> supports model specifications using two different interfaces: one
which allows passing of the data matrix <code>x</code> and outcome vector <code>y</code> directly
(as done in e.g. <code><a href="stats.html#topic+glm">stats::glm.fit()</a></code> or <code>glmnet</code>) and another which conforms
to the formula interface used by many commonly used R modelling functions
such as <code><a href="stats.html#topic+glm">stats::glm()</a></code> or <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>.
</p>
<p>Both interfaces are equivalent in terms of possible fitted models, only the
details of specification differ. In the standard interface all details
regarding FP-transformations are given as vectors. In the formula interface
all details are specified using special <code>fp()</code> function. These support the
specification of degrees of freedom (<code>df</code>), nominal significance level for
variable selection (<code>select</code>), nominal significance level for functional form
selection (<code>alpha</code>), shift values (<code>shift</code>), scale values (<code>scale</code>),
centering (<code>center</code>) and the ACD-transformation (<code>acd</code>). Values specified
through <code>fp()</code> function override the values specified as defaults and passed to
the <code>mfp2()</code> function.
</p>
<p>The formula may also contain <code>strata</code> terms to fit stratified Cox models, or
an <code>offset</code> term to specify a model offset.
</p>
<p>Note that for a formula using <code>.</code>, such as <code>y ~ .</code> the <code>mfp2()</code> function may not
fit a linear model, but may perform variable and functional form selection
using FP-transformations, depending on the default settings of <code>df</code>,
<code>select</code> and <code>alpha</code> passed as arguments to <code>mfp2()</code>.
For example, using <code>y ~ .</code> with default settings means that <code>mfp2()</code> will
apply FP transformation with 4 df to all continuous variables and use alpha
equal to 0.05 to select functional forms, along with the selection algorithm
with a significance level of 0.05 for all variables.
</p>


<h3>Compatibility with <code>mfp</code> package</h3>

<p><code>mfp2</code> is an extension of the <code>mfp</code> package and can be used to reproduce
the results from a model fitted by <code>mfp</code>. Since both packages implement the
MFP algorithm, they use functions with the same names (e.g <code>fp()</code>). Therefore,
if you load both packages using a call to <code>library</code>, there will
be namespace conflicts and only the functions from the package loaded last
will work properly.
</p>


<h3>Convergence and Troubleshooting</h3>

<p>Typically, <code>mfp2</code> requires two to four cycles to achieve convergence. Lack of
convergence involves oscillation between two or more models and is extremely
rare. If the model does not converge, you can try changing the nominal
significance levels for variable (<code>select</code>) or function selection (<code>alpha</code>).
</p>


<h3>References</h3>

<p>Royston, P. and Sauerbrei, W., 2008. <em>Multivariable Model - Building:
A Pragmatic Approach to Regression Anaylsis based on Fractional Polynomials
for Modelling Continuous Variables. John Wiley &amp; Sons.</em><br />
</p>
<p>Sauerbrei, W., Meier-Hirmer, C., Benner, A. and Royston, P., 2006.
<em>Multivariable regression model building by using fractional
polynomials: Description of SAS, STATA and R programs.
Comput Stat Data Anal, 50(12): 3464-85.</em><br />
</p>
<p>Royston, P. 2014. <em>A smooth covariate rank transformation for use in
regression models with a sigmoid dose-response function.
Stata Journal 14(2): 329-341.</em><br />
</p>
<p>Royston, P. and Sauerbrei, W., 2016. <em>mfpa: Extension of mfp using the
ACD covariate transformation for enhanced parametric multivariable modeling.
The Stata Journal, 16(1), pp.72-87.</em><br />
</p>
<p>Sauerbrei, W. and Royston, P., 1999. <em>Building multivariable prognostic
and diagnostic models: transformation of the predictors by using fractional
polynomials. J Roy Stat Soc a Sta, 162:71-94.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.mfp2">summary.mfp2()</a></code>, <code><a href="#topic+coef.mfp2">coef.mfp2()</a></code>, <code><a href="#topic+predict.mfp2">predict.mfp2()</a></code>, <code><a href="#topic+fp">fp()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Gaussian model
data("prostate")
x = as.matrix(prostate[,2:8])
y = as.numeric(prostate$lpsa)
# default interface
fit1 = mfp2(x, y, verbose = FALSE)
fit1$fp_terms
fracplot(fit1) # generate plots
summary(fit1)
# formula interface
fit1b = mfp2(lpsa ~ fp(age) + fp(svi, df = 1) + fp(pgg45) + fp(cavol) + fp(weight) +
fp(bph) + fp(cp), data = prostate)

# logistic regression model
data("pima")
xx &lt;- as.matrix(pima[, 2:9])
yy &lt;- as.vector(pima$y)
fit2 &lt;- mfp2(xx, yy, family = "binomial", verbose = FALSE)
fit2$fp_terms

# Cox regression model
data("gbsg")
# create dummy variable for grade using ordinal coding
gbsg &lt;- create_dummy_variables(gbsg, var_ordinal = "grade", drop_variables = TRUE)
xd &lt;- as.matrix(gbsg[, -c(1, 6, 10, 11)])
yd &lt;- survival::Surv(gbsg$rectime, gbsg$censrec)
# fit mfp and keep hormon in the model
fit3 &lt;- mfp2(xd, yd, family = "cox", keep = "hormon", verbose = FALSE)
fit3$fp_terms

</code></pre>

<hr>
<h2 id='name_transformed_variables'>Helper function to name transformed variables</h2><span id='topic+name_transformed_variables'></span>

<h3>Description</h3>

<p>Helper function to name transformed variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name_transformed_variables(name, n_powers, acd = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="name_transformed_variables_+3A_name">name</code></td>
<td>
<p>character with name of variable being transformed.</p>
</td></tr>
<tr><td><code id="name_transformed_variables_+3A_n_powers">n_powers</code></td>
<td>
<p>number of resulting variables from FP-transformation.</p>
</td></tr>
<tr><td><code id="name_transformed_variables_+3A_acd">acd</code></td>
<td>
<p>logical indicating the use of ACD-transformation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of names of length <code>n_powers</code>.
</p>

<hr>
<h2 id='order_variables'>Helper to order variables for mfp2 algorithm</h2><span id='topic+order_variables'></span><span id='topic+order_variables_by_significance'></span>

<h3>Description</h3>

<p>To be used in <code><a href="#topic+fit_mfp">fit_mfp()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_variables(xorder = "ascending", x = NULL, ...)

order_variables_by_significance(
  xorder,
  x,
  y,
  family,
  weights,
  offset,
  strata,
  method,
  control,
  nocenter
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="order_variables_+3A_xorder">xorder</code></td>
<td>
<p>a string determining the order of entry of the covariates
into the model-selection algorithm. The default is <code>ascending</code>, which enters
them by ascending p-values, or decreasing order of significance in a
multiple regression (i.e. most significant first).
<code>descending</code> places them in reverse significance order, whereas
<code>original</code> respects the original order in <code>x</code>.</p>
</td></tr>
<tr><td><code id="order_variables_+3A_x">x</code></td>
<td>
<p>a design matrix of dimension n * p where n is the number of
observations and p the number of predictors including intercept for glms,
or excluding intercept for Cox models.</p>
</td></tr>
<tr><td><code id="order_variables_+3A_...">...</code></td>
<td>
<p>passed to <code>order_variables_by_significance</code>.</p>
</td></tr>
<tr><td><code id="order_variables_+3A_y">y</code></td>
<td>
<p>a vector of responses for glms, or a <code>Surv</code> object generated using
the <code><a href="survival.html#topic+Surv">survival::Surv()</a></code> function for Cox models.</p>
</td></tr>
<tr><td><code id="order_variables_+3A_family">family</code></td>
<td>
<p>a character string naming a family function supported by
<code>glm()</code> or &quot;cox&quot; for Cox models.</p>
</td></tr>
<tr><td><code id="order_variables_+3A_weights">weights</code>, <code id="order_variables_+3A_offset">offset</code></td>
<td>
<p>parameters for both glm and Cox models, see either
<code><a href="stats.html#topic+glm">stats::glm()</a></code> or <code><a href="survival.html#topic+coxph">survival::coxph()</a></code> depending on family.</p>
</td></tr>
<tr><td><code id="order_variables_+3A_strata">strata</code>, <code id="order_variables_+3A_method">method</code>, <code id="order_variables_+3A_control">control</code>, <code id="order_variables_+3A_nocenter">nocenter</code></td>
<td>
<p>Cox model specific parameters, see
<code><a href="survival.html#topic+coxph">survival::coxph()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the variable names in <code>x</code>, ordered according to <code>xorder</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>order_variables_by_significance()</code>: Order by significance in regression model. The
number of columns of <code>x</code> should be greater than 1 for Cox models.
</p>
</li></ul>

<hr>
<h2 id='pima'>Pima Indians dataset used in the Royston and Sauerbrei (2008) book.</h2><span id='topic+pima'></span>

<h3>Description</h3>

<p>The dataset arises from an investigation of potential predictors of
the onset of diabetes in a cohort of 768 female Pima Indians of whom 268
developed diabetes. Missing values were imputed using the ice procedure
for Stata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pima)
</code></pre>


<h3>Format</h3>

<p>A dataset with 768 observations and 9 variables.
</p>

<dl>
<dt>id</dt><dd><p>Patient identifier.</p>
</dd>
<dt>pregnant</dt><dd><p>Number of times pregnant.</p>
</dd>
<dt>glucose</dt><dd><p>Plasma glucose concentration at 2h in an oral glucose tolerance test.</p>
</dd>
<dt>diastolic</dt><dd><p>Diastolic blood pressure in mmHg.</p>
</dd>
<dt>triceps</dt><dd><p>Triceps skin fold thickness in mm.</p>
</dd>
<dt>insulin</dt><dd><p>2-h serum insulin.</p>
</dd>
<dt>bmi</dt><dd><p>Body mass index.</p>
</dd>
<dt>diabetes</dt><dd><p>Diabetes pedigree function.</p>
</dd>
<dt>age</dt><dd><p>Age in years.</p>
</dd>
<dt>y</dt><dd><p>Binary outcome variable (diabetes, yes/no).</p>
</dd>
</dl>


<hr>
<h2 id='predict.mfp2'>Predict Method for <code>mfp2</code> Fits</h2><span id='topic+predict.mfp2'></span>

<h3>Description</h3>

<p>Obtains predictions from an <code>mfp2</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mfp2'
predict(
  object,
  newdata = NULL,
  type = NULL,
  terms = NULL,
  terms_seq = c("equidistant", "data"),
  alpha = 0.05,
  ref = NULL,
  strata = NULL,
  newoffset = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.mfp2_+3A_object">object</code></td>
<td>
<p>a fitted object of class <code>mfp2</code>.</p>
</td></tr>
<tr><td><code id="predict.mfp2_+3A_newdata">newdata</code></td>
<td>
<p>optionally, a matrix with column names in which to look for
variables with which to predict. See <code><a href="#topic+mfp2">mfp2()</a></code> for details.</p>
</td></tr>
<tr><td><code id="predict.mfp2_+3A_type">type</code></td>
<td>
<p>the type of prediction required.  The default is on the
scale of the linear predictors. See <code>predict.glm()</code> or <code>predict.coxph()</code> for
details. In case <code>type = "terms"</code>, see the Section on <code style="white-space: pre;">&#8288;Terms prediction&#8288;</code>.
In case <code>type = "contrasts"</code>, see the Section on <code>Contrasts</code>.</p>
</td></tr>
<tr><td><code id="predict.mfp2_+3A_terms">terms</code></td>
<td>
<p>a character vector of variable names specifying for which
variables term or contrast predictions are desired.
Only used in case <code>type = "terms"</code> or <code>type = "contrasts"</code>.
If <code>NULL</code> (the default) then all selected variables in the final model will
be used. In any case, only variables used in the final model are used, even
if more variable names are passed.</p>
</td></tr>
<tr><td><code id="predict.mfp2_+3A_terms_seq">terms_seq</code></td>
<td>
<p>a character string specifying how the range of variable
values for term predictions are handled. The default <code>equidistant</code> computes
the range of the data range and generates an equidistant sequence of
100 points from the minimum to the maximum values to properly show the functional
form estimated in the final model.
The option <code>data</code> uses the observed data values directly, but these may not
adequately reflect the functional form of the data, especially when extreme
values or influential points are present.</p>
</td></tr>
<tr><td><code id="predict.mfp2_+3A_alpha">alpha</code></td>
<td>
<p>significance level used for computing confidence
intervals in terms prediction.</p>
</td></tr>
<tr><td><code id="predict.mfp2_+3A_ref">ref</code></td>
<td>
<p>a named list of reference values used when <code>type = "contrasts"</code>.
Note that any variable requested in <code>terms</code>, but not having an entry in this
list (or if the entry is <code>NULL</code>) then the mean value (or minimum for binary
variables) will be used as reference. Values are specified on the original
scale of the variable since the program will internally scale it using the
scaling factors obtained from <code><a href="#topic+find_scale_factor">find_scale_factor()</a></code>. By default, this function
uses the means (for continuous variables) and minima (for binary variables) as
reference values.</p>
</td></tr>
<tr><td><code id="predict.mfp2_+3A_strata">strata</code></td>
<td>
<p>stratum levels used for predictions.</p>
</td></tr>
<tr><td><code id="predict.mfp2_+3A_newoffset">newoffset</code></td>
<td>
<p>A vector of offsets used for predictions. This parameter is important when
newdata is supplied. The offsets will be directly added to the linear predictor without any
transformations.</p>
</td></tr>
<tr><td><code id="predict.mfp2_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>predict.glm()</code> or <code>predict.coxph()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To prepare the <code>newdata</code> for prediction, this function applies any
necessary shifting and scaling based on the factors obtained from the
training data.
It is important to note that if the shifting factors are not sufficiently
large as estimated from the training data, variables in <code>newdata</code> may end up
with negative values, which can cause prediction errors if non-linear
functional forms are used. A warning is given in this case by the function.
The next step involves transforming the data using the selected
fractional polynomial (FP) powers. If necessary, centering of variables is
conducted. Once the transformation (and centering) is complete, the
transformed data is passed to either <code>predict.glm()</code> or <code>predict.coxph()</code>,
depending on the chosen family of models and when type is not
<code>terms</code> and <code>contrasts</code>.
</p>


<h3>Value</h3>

<p>For any <code>type</code> other than <code>"terms"</code> the output conforms to the output
of <code>predict.glm()</code> or <code>predict.coxph()</code>.
</p>
<p>If <code>type = "terms"</code> or <code>type = "contrasts"</code>, then a named list with entries
for each variable requested in <code>terms</code> (excluding those not present in the
final model).
Each entry is a <code>data.frame</code> with the following columns:
</p>

<ul>
<li> <p><code>variable</code>: variable values on original scale.
</p>
</li>
<li> <p><code>variable_pre</code>: variable with pre-transformation applied, i.e. shifted,
scaled and centered as required.
</p>
</li>
<li> <p><code>value</code>: partial linear predictor or contrast (depending on <code>type</code>).
</p>
</li>
<li> <p><code>se</code>: standard error of partial linear predictor or contrast.
</p>
</li>
<li> <p><code>lower</code>: lower limit of confidence interval.
</p>
</li>
<li> <p><code>upper</code>: upper limit of confidence interval.
</p>
</li></ul>



<h3>Terms prediction</h3>

<p>This function allows to compute the partial linear predictors
for each variable selected into the final model if <code>type = "terms"</code>. Note
that the results returned from this function are different from those of
<code>predict.glm()</code> and <code>predict.coxph()</code> since these functions do not take
into account that a single variable can be represented by multiple terms.
This functionality is useful to assess model fit, since it also allows to
draw data points based on residuals.
</p>


<h3>Contrasts</h3>

<p>This functions allows to compute contrasts with reference to a specified
variable value if <code>type = "contrasts"</code>. In this case, the fitted partial
predictors will be centered at the reference value (i.e. 0), and also
confidence intervals will have width 0 at that point.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mfp2">mfp2()</a></code>, <code><a href="stats.html#topic+predict.glm">stats::predict.glm()</a></code>, <code><a href="survival.html#topic+predict.coxph">survival::predict.coxph()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Gaussian model
data("prostate")
x = as.matrix(prostate[,2:8])
y = as.numeric(prostate$lpsa)
# default interface
fit1 = mfp2(x, y, verbose = FALSE)
predict(fit1) # make predictions

</code></pre>

<hr>
<h2 id='prepare_newdata_for_predict'>Helper function to prepare newdata for predict function</h2><span id='topic+prepare_newdata_for_predict'></span>

<h3>Description</h3>

<p>To be used in <code><a href="#topic+predict.mfp2">predict.mfp2()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_newdata_for_predict(
  object,
  newdata,
  strata = NULL,
  offset = NULL,
  apply_pre = TRUE,
  apply_center = TRUE,
  check_binary = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepare_newdata_for_predict_+3A_object">object</code></td>
<td>
<p>fitted <code>mfp2</code> model object.</p>
</td></tr>
<tr><td><code id="prepare_newdata_for_predict_+3A_newdata">newdata</code></td>
<td>
<p>dataset to be prepared for predictions. Its columns can be
a subset of the columns used for fitting the model.</p>
</td></tr>
<tr><td><code id="prepare_newdata_for_predict_+3A_strata">strata</code>, <code id="prepare_newdata_for_predict_+3A_offset">offset</code></td>
<td>
<p>passed from <code><a href="#topic+predict.mfp2">predict.mfp2()</a></code>.</p>
</td></tr>
<tr><td><code id="prepare_newdata_for_predict_+3A_apply_pre">apply_pre</code></td>
<td>
<p>logical indicating wether the fitted pre-transformation
is applied or not.</p>
</td></tr>
<tr><td><code id="prepare_newdata_for_predict_+3A_apply_center">apply_center</code></td>
<td>
<p>logical indicating whether the fitted centers are applied
after transformation or not.</p>
</td></tr>
<tr><td><code id="prepare_newdata_for_predict_+3A_check_binary">check_binary</code></td>
<td>
<p>passed to <code><a href="#topic+transform_vector_fp">transform_vector_fp()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of transformed newdata
</p>

<hr>
<h2 id='print_mfp_step'>Function for verbose printing of function selection procedure (FSP)</h2><span id='topic+print_mfp_step'></span><span id='topic+print_mfp_pvalue_step'></span><span id='topic+print_mfp_ic_step'></span>

<h3>Description</h3>

<p>Function for verbose printing of function selection procedure (FSP)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_mfp_step(xi, criterion, fit)

print_mfp_pvalue_step(xi, fit, criterion)

print_mfp_ic_step(xi, fit, criterion)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_mfp_step_+3A_xi">xi</code></td>
<td>
<p>a character string indicating the name of the current variable
of interest, for which the best fractional polynomial transformation is
to be estimated in the current step.</p>
</td></tr>
<tr><td><code id="print_mfp_step_+3A_criterion">criterion</code></td>
<td>
<p>a character string defining the criterion used to select
variables and FP models of different degrees.</p>
</td></tr>
<tr><td><code id="print_mfp_step_+3A_fit">fit</code></td>
<td>
<p>intermediary model fit in <code>mfp_step</code>.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>print_mfp_pvalue_step()</code>: Helper for verbose printing based on p-value.
</p>
</li>
<li> <p><code>print_mfp_ic_step()</code>: Helper for verbose printing based on information criterion.
</p>
</li></ul>

<hr>
<h2 id='print.mfp2'>Print method for objects of class <code>mfp2</code></h2><span id='topic+print.mfp2'></span>

<h3>Description</h3>

<p>Enhances printing by information on data processing and fractional
polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mfp2'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.mfp2_+3A_x">x</code></td>
<td>
<p><code>mfp2</code> object to be printed.</p>
</td></tr>
<tr><td><code id="print.mfp2_+3A_...">...</code></td>
<td>
<p>passed to <code>print</code> methods of underlying model class. A useful
option as the <code>digits</code> argument, indicating printed digits.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Two dataframes: the first one contains preprocessing parameters (shifting, scaling, and
centering), and the second one includes additional parameters such as <code>df</code>, <code>select</code>, and
<code>alpha</code> passed through <code>mfp2</code>. It also returns a list of the final model fitted, which can be
either a GLM or Cox model depending on the chosen family.
</p>

<hr>
<h2 id='prostate'>Prostate cancer dataset used in the Royston and Sauerbrei (2008) book.</h2><span id='topic+prostate'></span>

<h3>Description</h3>

<p>Prostate cancer dataset used in the Royston and Sauerbrei (2008) book.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(prostate)
</code></pre>


<h3>Format</h3>

<p>A dataset with 97 observations and 8 variables.
</p>

<dl>
<dt>obsno</dt><dd><p>Observation number.</p>
</dd>
<dt>age</dt><dd><p>Age in years.</p>
</dd>
<dt>svi</dt><dd><p>Seminal vessel invasion (yes/no).</p>
</dd>
<dt>pgg45</dt><dd><p>Percentage Gleason score 4 or 5.</p>
</dd>
<dt>cavol</dt><dd><p>Cancer volume (mm).</p>
</dd>
<dt>weight</dt><dd><p>Prostate weight (g).</p>
</dd>
<dt>bph</dt><dd><p>Amount of benign prostatic hyperplasia (g).</p>
</dd>
<dt>cp</dt><dd><p>Amount of capsular penetration (g).</p>
</dd>
<dt>lpsa</dt><dd><p>Log PSA concentration (outcome variable).</p>
</dd>
</dl>


<hr>
<h2 id='reset_acd'>Helper to reset acd transformation for variables with few values</h2><span id='topic+reset_acd'></span>

<h3>Description</h3>

<p>To be used in <code><a href="#topic+fit_mfp">fit_mfp()</a></code>.
This function resets the <code>acdx</code> parameter (logical vector) of variables with
less than 5 distinct values to <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reset_acd(x, acdx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reset_acd_+3A_x">x</code></td>
<td>
<p>a design matrix of dimension nobs x nvars where nvars is the number
of predictors excluding an intercept.</p>
</td></tr>
<tr><td><code id="reset_acd_+3A_acdx">acdx</code></td>
<td>
<p>a named logical vector of length nvars indicating which continuous
variables should undergo the approximate cumulative distribution (ACD)
transformation. May be ordered differently than the columns of <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vector of same length as <code>acdx</code>.
</p>

<hr>
<h2 id='select_ic'>Function selection procedure based on information criteria</h2><span id='topic+select_ic'></span><span id='topic+select_ic_acd'></span>

<h3>Description</h3>

<p>Used in <code><a href="#topic+find_best_fp_step">find_best_fp_step()</a></code> when <code>criterion = "aic"</code> or <code>"bic"</code>.
For parameter explanations, see <code><a href="#topic+find_best_fp_step">find_best_fp_step()</a></code>. All parameters
captured by <code>...</code> are passed on to <code><a href="#topic+fit_model">fit_model()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_ic(
  x,
  xi,
  keep,
  degree,
  acdx,
  y,
  powers_current,
  powers,
  criterion,
  ftest,
  select,
  alpha,
  ...
)

select_ic_acd(
  x,
  xi,
  keep,
  degree,
  acdx,
  y,
  powers_current,
  powers,
  criterion,
  ftest,
  select,
  alpha,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_ic_+3A_x">x</code></td>
<td>
<p>an input matrix of dimensions nobs x nvars. Does not contain
intercept, but columns are already expanded into dummy variables as
necessary. Data are assumed to be shifted and scaled.</p>
</td></tr>
<tr><td><code id="select_ic_+3A_xi">xi</code></td>
<td>
<p>a character string indicating the name of the current variable
of interest, for which the best fractional polynomial transformation is
to be estimated in the current step.</p>
</td></tr>
<tr><td><code id="select_ic_+3A_keep">keep</code></td>
<td>
<p>a character vector with names of variables to be kept
in the model.</p>
</td></tr>
<tr><td><code id="select_ic_+3A_degree">degree</code></td>
<td>
<p>integer &gt; 0 giving the degree for the FP transformation.</p>
</td></tr>
<tr><td><code id="select_ic_+3A_acdx">acdx</code></td>
<td>
<p>a logical vector of length nvars indicating continuous variables
to undergo the approximate cumulative distribution (ACD) transformation.</p>
</td></tr>
<tr><td><code id="select_ic_+3A_y">y</code></td>
<td>
<p>a vector for the response variable or a <code>Surv</code> object.</p>
</td></tr>
<tr><td><code id="select_ic_+3A_powers_current">powers_current</code></td>
<td>
<p>a list of length equal to the number of variables,
indicating the fp powers to be used in the current step for all variables
(except <code>xi</code>).</p>
</td></tr>
<tr><td><code id="select_ic_+3A_powers">powers</code></td>
<td>
<p>a named list of numeric values that sets the permitted FP
powers for each covariate.</p>
</td></tr>
<tr><td><code id="select_ic_+3A_criterion">criterion</code></td>
<td>
<p>a character string defining the criterion used to select
variables and FP models of different degrees.</p>
</td></tr>
<tr><td><code id="select_ic_+3A_ftest">ftest</code></td>
<td>
<p>a logical indicating the use of the F-test for Gaussian models.</p>
</td></tr>
<tr><td><code id="select_ic_+3A_select">select</code></td>
<td>
<p>a numeric value indicating the significance level
for backward elimination of <code>xi</code>.</p>
</td></tr>
<tr><td><code id="select_ic_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value indicating the significance level
for tests between FP models of different degrees for <code>xi</code>.</p>
</td></tr>
<tr><td><code id="select_ic_+3A_...">...</code></td>
<td>
<p>passed to fitting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case an information criterion is used to select the best model the
selection procedure simply fits all relevant models and selects the best
one according to the given criterion.
</p>
<p>&quot;Relevant&quot; models for a given degree are the null model excluding the
variable of interest, the linear model and all best FP models up to the
specified degree.
</p>
<p>In case an ACD transformation is requested, then the models assessed
are the null model, the linear model in x and A(x), the best FP1 models in
x and A(x), and the best FP1(x, A(x)) model.
</p>
<p>Note that the &quot;best&quot; FPx model used in this function are given by the models
using a FPx transformation for the variable of interest and having the
highest likelihood of all such models given the current powers for all other
variables, as outlined in Section 4.8 of Royston and Sauerbrei (2008).
These best FPx models are computed in <code><a href="#topic+find_best_fpm_step">find_best_fpm_step()</a></code>.
Keep in mind that for a fixed number of degrees of freedom (i.e. fixed m),
the model with the highest likelihood is the same as the model with the best
information criterion of any kind since all the models share the same
penalty term.
</p>
<p>When a variable is forced into the model by including it in <code>keep</code>, then
this function will not exclude it from the model (by setting its power to
<code>NA</code>), but will only choose its functional form.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>

<ul>
<li> <p><code>keep</code>: logical indicating if <code>xi</code> is forced into model.
</p>
</li>
<li> <p><code>acd</code>: logical indicating if an ACD transformation was applied for <code>xi</code>,
i.e. <code>FALSE</code> in this case.
</p>
</li>
<li> <p><code>powers</code>: (best) fp powers investigated in step, indexing <code>metrics</code>.
Ordered by increasing complexity, i.e. null, linear, FP1, FP2 and so on.
For ACD transformation, it is null, linear, linear(., A(x)), FP1(x, .),
FP1(., A(x)) and FP1(x, A(x)).
</p>
</li>
<li> <p><code>power_best</code>: a numeric vector with the best power found. The returned
best power may be <code>NA</code>, indicating the variable has been removed from the
model.
</p>
</li>
<li> <p><code>metrics</code>: a matrix with performance indices for all best models
investigated. Same number of rows as, and indexed by, <code>powers</code>.
</p>
</li>
<li> <p><code>model_best</code>: row index of best model in <code>metrics</code>.
</p>
</li>
<li> <p><code>pvalue</code>: p-value for comparison of linear and null model, <code>NA</code> in this
case..
</p>
</li>
<li> <p><code>statistic</code>: test statistic used, depends on <code>ftest</code>, <code>NA</code> in this
case.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>select_ic_acd()</code>: Function to select ACD based transformation.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+select_ra2">select_ra2()</a></code>
</p>

<hr>
<h2 id='select_linear'>Helper to select between null and linear term for a single variable</h2><span id='topic+select_linear'></span>

<h3>Description</h3>

<p>To be used in <code><a href="#topic+find_best_fp_step">find_best_fp_step()</a></code>. Only used if <code>df = 1</code> for a variable.
Handles all criteria for selection.
For parameter explanations, see <code><a href="#topic+find_best_fp_step">find_best_fp_step()</a></code>. All parameters
captured by <code>...</code> are passed on to <code><a href="#topic+fit_model">fit_model()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_linear(
  x,
  xi,
  keep,
  degree,
  acdx,
  y,
  powers_current,
  powers,
  criterion,
  ftest,
  select,
  alpha,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_linear_+3A_x">x</code></td>
<td>
<p>an input matrix of dimensions nobs x nvars. Does not contain
intercept, but columns are already expanded into dummy variables as
necessary. Data are assumed to be shifted and scaled.</p>
</td></tr>
<tr><td><code id="select_linear_+3A_xi">xi</code></td>
<td>
<p>a character string indicating the name of the current variable
of interest, for which the best fractional polynomial transformation is
to be estimated in the current step.</p>
</td></tr>
<tr><td><code id="select_linear_+3A_keep">keep</code></td>
<td>
<p>a character vector with names of variables to be kept
in the model.</p>
</td></tr>
<tr><td><code id="select_linear_+3A_degree">degree</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="select_linear_+3A_acdx">acdx</code></td>
<td>
<p>a logical vector of length nvars indicating continuous variables
to undergo the approximate cumulative distribution (ACD) transformation.</p>
</td></tr>
<tr><td><code id="select_linear_+3A_y">y</code></td>
<td>
<p>a vector for the response variable or a <code>Surv</code> object.</p>
</td></tr>
<tr><td><code id="select_linear_+3A_powers_current">powers_current</code></td>
<td>
<p>a list of length equal to the number of variables,
indicating the fp powers to be used in the current step for all variables
(except <code>xi</code>).</p>
</td></tr>
<tr><td><code id="select_linear_+3A_powers">powers</code></td>
<td>
<p>a named list of numeric values that sets the permitted FP
powers for each covariate.</p>
</td></tr>
<tr><td><code id="select_linear_+3A_criterion">criterion</code></td>
<td>
<p>a character string defining the criterion used to select
variables and FP models of different degrees.</p>
</td></tr>
<tr><td><code id="select_linear_+3A_ftest">ftest</code></td>
<td>
<p>a logical indicating the use of the F-test for Gaussian models.</p>
</td></tr>
<tr><td><code id="select_linear_+3A_select">select</code></td>
<td>
<p>a numeric value indicating the significance level
for backward elimination of <code>xi</code>.</p>
</td></tr>
<tr><td><code id="select_linear_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value indicating the significance level
for tests between FP models of different degrees for <code>xi</code>.</p>
</td></tr>
<tr><td><code id="select_linear_+3A_...">...</code></td>
<td>
<p>passed to fitting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assesses a single variable of interest <code>xi</code> regarding its
functional form in the current working model as indicated by
<code>powers_current</code>, with the choice between a excluding <code>xi</code> (&quot;null model&quot;) and
including a linear term (&quot;linear fp&quot;) for <code>xi</code>.
</p>
<p>Note that this function handles an ACD transformation for <code>xi</code> as well.
</p>
<p>When a variable is forced into the model by including it in <code>keep</code>, then
this function will not exclude it from the model (by setting its power to
<code>NA</code>), but will only choose the linear model.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>

<ul>
<li> <p><code>keep</code>: logical indicating if <code>xi</code> is forced into model.
</p>
</li>
<li> <p><code>acd</code>: logical indicating if an ACD transformation was applied for <code>xi</code>.
</p>
</li>
<li> <p><code>powers</code>: fp powers investigated in step, indexing <code>metrics</code>.
</p>
</li>
<li> <p><code>power_best</code>: a numeric vector with the best power found. The returned
best power may be <code>NA</code>, indicating the variable has been removed from the
model.
</p>
</li>
<li> <p><code>metrics</code>: a matrix with performance indices for all models investigated.
Same number of rows as, and indexed by, <code>powers</code>.
</p>
</li>
<li> <p><code>model_best</code>: row index of best model in <code>metrics</code>.
</p>
</li>
<li> <p><code>pvalue</code>: p-value for comparison of linear and null model.
</p>
</li>
<li> <p><code>statistic</code>: test statistic used, depends on <code>ftest</code>.
</p>
</li></ul>


<hr>
<h2 id='select_ra2'>Function selection procedure based on closed testing procedure</h2><span id='topic+select_ra2'></span>

<h3>Description</h3>

<p>Used in <code><a href="#topic+find_best_fp_step">find_best_fp_step()</a></code> when <code>criterion = "pvalue"</code>.
For parameter explanations, see <code><a href="#topic+find_best_fp_step">find_best_fp_step()</a></code>. All parameters
captured by <code>...</code> are passed on to <code><a href="#topic+fit_model">fit_model()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_ra2(
  x,
  xi,
  keep,
  degree,
  acdx,
  y,
  powers_current,
  powers,
  criterion,
  ftest,
  select,
  alpha,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_ra2_+3A_x">x</code></td>
<td>
<p>an input matrix of dimensions nobs x nvars. Does not contain
intercept, but columns are already expanded into dummy variables as
necessary. Data are assumed to be shifted and scaled.</p>
</td></tr>
<tr><td><code id="select_ra2_+3A_xi">xi</code></td>
<td>
<p>a character string indicating the name of the current variable
of interest, for which the best fractional polynomial transformation is
to be estimated in the current step.</p>
</td></tr>
<tr><td><code id="select_ra2_+3A_keep">keep</code></td>
<td>
<p>a character vector with names of variables to be kept
in the model.</p>
</td></tr>
<tr><td><code id="select_ra2_+3A_degree">degree</code></td>
<td>
<p>integer &gt; 0 giving the degree for the FP transformation.</p>
</td></tr>
<tr><td><code id="select_ra2_+3A_acdx">acdx</code></td>
<td>
<p>a logical vector of length nvars indicating continuous variables
to undergo the approximate cumulative distribution (ACD) transformation.</p>
</td></tr>
<tr><td><code id="select_ra2_+3A_y">y</code></td>
<td>
<p>a vector for the response variable or a <code>Surv</code> object.</p>
</td></tr>
<tr><td><code id="select_ra2_+3A_powers_current">powers_current</code></td>
<td>
<p>a list of length equal to the number of variables,
indicating the fp powers to be used in the current step for all variables
(except <code>xi</code>).</p>
</td></tr>
<tr><td><code id="select_ra2_+3A_powers">powers</code></td>
<td>
<p>a named list of numeric values that sets the permitted FP
powers for each covariate.</p>
</td></tr>
<tr><td><code id="select_ra2_+3A_criterion">criterion</code></td>
<td>
<p>a character string defining the criterion used to select
variables and FP models of different degrees.</p>
</td></tr>
<tr><td><code id="select_ra2_+3A_ftest">ftest</code></td>
<td>
<p>a logical indicating the use of the F-test for Gaussian models.</p>
</td></tr>
<tr><td><code id="select_ra2_+3A_select">select</code></td>
<td>
<p>a numeric value indicating the significance level
for backward elimination of <code>xi</code>.</p>
</td></tr>
<tr><td><code id="select_ra2_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value indicating the significance level
for tests between FP models of different degrees for <code>xi</code>.</p>
</td></tr>
<tr><td><code id="select_ra2_+3A_...">...</code></td>
<td>
<p>passed to fitting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case <code>criterion = "pvalue"</code> the function selection procedure as outlined
in Chapters 4 and 6 of Royston and Sauerbrei (2008) is used.
</p>

<ul>
<li> <p><em>Step 1</em>: test the best FPm function against a null model at level
<code>select</code> with 2m df. If not significant, the variable is excluded.
Otherwise continue with step 2.
</p>
</li>
<li> <p><em>Step 2</em>: test the best FPm versus a linear model at level <code>alpha</code>
with 2m - 1 df. If not significant, use a linear model.
Otherwise continue with step 3.
</p>
</li>
<li> <p><em>Step 3</em>: test the best FPm versus the best FP1 at
level <code>alpha</code> with 2m - 2 df. If not significant, use the best FP1 model.
Otherwise, repeat this step for all remaining higher order FPs until
FPm-1, which is tested at level <code>alpha</code> with 2 df against FPm.
If the final test is not significant, use a FPm-1 model, otherwise use FPm.
</p>
</li></ul>

<p>Note that the &quot;best&quot; FPx model used in each step is given by the model using
a FPx transformation for the variable of interest and having the highest
likelihood of all such models given the current powers for all other
variables, as outlined in Section 4.8 of Royston and Sauerbrei (2008).
These best FPx models are computed in <code><a href="#topic+find_best_fpm_step">find_best_fpm_step()</a></code>.
</p>
<p>When a variable is forced into the model by including it in <code>keep</code>, then
this function will not exclude it from the model (by setting its power to
<code>NA</code>), but will only choose its functional form.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>

<ul>
<li> <p><code>keep</code>: logical indicating if <code>xi</code> is forced into model.
</p>
</li>
<li> <p><code>acd</code>: logical indicating if an ACD transformation was applied for <code>xi</code>,
i.e. <code>FALSE</code> in this case.
</p>
</li>
<li> <p><code>powers</code>: (best) fp powers investigated in step, indexing <code>metrics</code>.
Always starts with highest power, then null, then linear, then FP in
increasing degree (e.g. FP2, null, linear, FP1).
</p>
</li>
<li> <p><code>power_best</code>: a numeric vector with the best power found. The returned
best power may be <code>NA</code>, indicating the variable has been removed from the
model.
</p>
</li>
<li> <p><code>metrics</code>: a matrix with performance indices for all models investigated.
Same number of rows as, and indexed by, <code>powers</code>.
</p>
</li>
<li> <p><code>model_best</code>: row index of best model in <code>metrics</code>.
</p>
</li>
<li> <p><code>pvalue</code>: p-value for comparison of linear and null model.
</p>
</li>
<li> <p><code>statistic</code>: test statistic used, depends on <code>ftest</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Royston, P. and Sauerbrei, W., 2008. <em>Multivariable Model - Building:
A Pragmatic Approach to Regression Anaylsis based on Fractional Polynomials
for Modelling Continuous Variables. John Wiley &amp; Sons.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select_ra2_acd">select_ra2_acd()</a></code>
</p>

<hr>
<h2 id='select_ra2_acd'>Function selection procedure for ACD based on closed testing procedure</h2><span id='topic+select_ra2_acd'></span>

<h3>Description</h3>

<p>Used in <code><a href="#topic+find_best_fp_step">find_best_fp_step()</a></code> when <code>criterion = "pvalue"</code> and an
ACD transformation is requested for <code>xi</code>.
For parameter explanations, see <code><a href="#topic+find_best_fp_step">find_best_fp_step()</a></code>. All parameters
captured by <code>...</code> are passed on to <code><a href="#topic+fit_model">fit_model()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_ra2_acd(
  x,
  xi,
  keep,
  degree,
  acdx,
  y,
  powers_current,
  powers,
  criterion,
  ftest,
  select,
  alpha,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_ra2_acd_+3A_x">x</code></td>
<td>
<p>an input matrix of dimensions nobs x nvars. Does not contain
intercept, but columns are already expanded into dummy variables as
necessary. Data are assumed to be shifted and scaled.</p>
</td></tr>
<tr><td><code id="select_ra2_acd_+3A_xi">xi</code></td>
<td>
<p>a character string indicating the name of the current variable
of interest, for which the best fractional polynomial transformation is
to be estimated in the current step.</p>
</td></tr>
<tr><td><code id="select_ra2_acd_+3A_keep">keep</code></td>
<td>
<p>a character vector with names of variables to be kept
in the model.</p>
</td></tr>
<tr><td><code id="select_ra2_acd_+3A_degree">degree</code></td>
<td>
<p>integer &gt; 0 giving the degree for the FP transformation.</p>
</td></tr>
<tr><td><code id="select_ra2_acd_+3A_acdx">acdx</code></td>
<td>
<p>a logical vector of length nvars indicating continuous variables
to undergo the approximate cumulative distribution (ACD) transformation.</p>
</td></tr>
<tr><td><code id="select_ra2_acd_+3A_y">y</code></td>
<td>
<p>a vector for the response variable or a <code>Surv</code> object.</p>
</td></tr>
<tr><td><code id="select_ra2_acd_+3A_powers_current">powers_current</code></td>
<td>
<p>a list of length equal to the number of variables,
indicating the fp powers to be used in the current step for all variables
(except <code>xi</code>).</p>
</td></tr>
<tr><td><code id="select_ra2_acd_+3A_powers">powers</code></td>
<td>
<p>a named list of numeric values that sets the permitted FP
powers for each covariate.</p>
</td></tr>
<tr><td><code id="select_ra2_acd_+3A_criterion">criterion</code></td>
<td>
<p>a character string defining the criterion used to select
variables and FP models of different degrees.</p>
</td></tr>
<tr><td><code id="select_ra2_acd_+3A_ftest">ftest</code></td>
<td>
<p>a logical indicating the use of the F-test for Gaussian models.</p>
</td></tr>
<tr><td><code id="select_ra2_acd_+3A_select">select</code></td>
<td>
<p>a numeric value indicating the significance level
for backward elimination of <code>xi</code>.</p>
</td></tr>
<tr><td><code id="select_ra2_acd_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value indicating the significance level
for tests between FP models of different degrees for <code>xi</code>.</p>
</td></tr>
<tr><td><code id="select_ra2_acd_+3A_...">...</code></td>
<td>
<p>passed to fitting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extends the algorithm used in <code><a href="#topic+select_ra2">select_ra2()</a></code> to allow the
usage of ACD transformations. The implementation follows the description
in Royston and Sauerbrei (2016). The procedure is outlined in detail in
the corresponding section in the documentation of <code><a href="#topic+mfp2">mfp2()</a></code>.
</p>
<p>When a variable is forced into the model by including it in <code>keep</code>, then
this function will not exclude it from the model (by setting its power to
<code>NA</code>), but will only choose its functional form.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>

<ul>
<li> <p><code>keep</code>: logical indicating if <code>xi</code> is forced into model.
</p>
</li>
<li> <p><code>acd</code>: logical indicating if an ACD transformation was applied for <code>xi</code>,
i.e. <code>FALSE</code> in this case.
</p>
</li>
<li> <p><code>powers</code>: (best) fp powers investigated in step, indexing <code>metrics</code>.
Ordering: FP1(x, A(x)), null, linear, FP1(x, .), linear(., A(x)),
FP1(., A(x)).
</p>
</li>
<li> <p><code>power_best</code>: a numeric vector with the best power found. The returned
best power may be <code>NA</code>, indicating the variable has been removed from the
model.
</p>
</li>
<li> <p><code>metrics</code>: a matrix with performance indices for all models investigated.
Same number of rows as, and indexed by, <code>powers</code>.
</p>
</li>
<li> <p><code>model_best</code>: row index of best model in <code>metrics</code>.
</p>
</li>
<li> <p><code>pvalue</code>: p-value for comparison of linear and null model.
</p>
</li>
<li> <p><code>statistic</code>: test statistic used, depends on <code>ftest</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Royston, P. and Sauerbrei, W., 2016. <em>mfpa: Extension of mfp using the
ACD covariate transformation for enhanced parametric multivariable modeling.
The Stata Journal, 16(1), pp.72-87.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select_ra2">select_ra2()</a></code>
</p>

<hr>
<h2 id='summary.mfp2'>Summarizing <code>mfp2</code> model fits</h2><span id='topic+summary.mfp2'></span>

<h3>Description</h3>

<p>This function is a method for the generic <code><a href="base.html#topic+summary">base::summary()</a></code> function for
objects of class <code>mfp2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mfp2'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.mfp2_+3A_object">object</code></td>
<td>
<p>an object of class <code>mfp2</code>, usually, a result of a call to
<code><a href="#topic+mfp2">mfp2()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.mfp2_+3A_...">...</code></td>
<td>
<p>further arguments passed to the summary functions for <code>glm()</code>
(<code><a href="stats.html#topic+summary.glm">stats::summary.glm()</a></code>, i.e. families supported by <code>glm()</code>) or <code>coxph()</code>
(<code><a href="survival.html#topic+summary.coxph">survival::summary.coxph()</a></code>, if <code>object$family = "cox"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object returned from <code><a href="stats.html#topic+summary.glm">stats::summary.glm()</a></code> or
<code><a href="survival.html#topic+summary.coxph">survival::summary.coxph()</a></code>, depending on the family parameter of <code>object</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mfp2">mfp2()</a></code>, <code><a href="stats.html#topic+glm">stats::glm()</a></code>, <code><a href="stats.html#topic+summary.glm">stats::summary.glm()</a></code>, <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>,
<code><a href="survival.html#topic+summary.coxph">survival::summary.coxph()</a></code>
</p>

<hr>
<h2 id='transform_data_step'>Function to extract and transform adjustment variables</h2><span id='topic+transform_data_step'></span>

<h3>Description</h3>

<p>Function to extract and transform adjustment variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_data_step(x, xi, powers_current, df, powers, acdx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform_data_step_+3A_x">x</code></td>
<td>
<p>a matrix of predictors that includes the variable of interest <code>xi</code>.
It is assumed that continuous variables have already been shifted and scaled.</p>
</td></tr>
<tr><td><code id="transform_data_step_+3A_xi">xi</code></td>
<td>
<p>name of the continuous predictor for which the FP function will be
estimated. There are no binary or two-level variables allowed. All variables
except <code>xi</code> are referred to as &quot;adjustment variables&quot;.</p>
</td></tr>
<tr><td><code id="transform_data_step_+3A_powers_current">powers_current</code></td>
<td>
<p>a named list of FP powers of all variables of interest,
including <code>xi</code>. Note that these powers are updated during backfitting or MFP
cycles.</p>
</td></tr>
<tr><td><code id="transform_data_step_+3A_df">df</code></td>
<td>
<p>a numeric vector of degrees of freedom for <code>xi</code>.</p>
</td></tr>
<tr><td><code id="transform_data_step_+3A_powers">powers</code></td>
<td>
<p>a set of allowed FP powers.</p>
</td></tr>
<tr><td><code id="transform_data_step_+3A_acdx">acdx</code></td>
<td>
<p>a logical vector indicating the use of acd transformation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After extracting the adjustment variables this function, using their
corresponding FP powers stored in <code>powers_current</code>, transforms them.
This is necessary When evaluating x of interest, as we must account for other
variables, which can be transformed or untransformed, depending on the
individual powers. It's worth noting that some powers can be NA, indicating
that the variable has been left out of the adjustment variables. It also
returns the FP data, which is dependent on the degrees of freedom. For example,
<code>df = 2</code> is equivalent to FP degree one, resulting in the generation of 8
variables. If <code>acdx</code> for the current variables of interest is set to <code>TRUE</code>,
however, 64 variables are generated.
</p>
<p>When <code>df = 1</code>, this function returns data unchanged, i.e. a &quot;linear&quot;
transformation with power equal to 1. In case <code>acdx[xi] = TRUE</code>, the
acd transformation is applied.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<ul>
<li> <p><code>powers_fp</code>: fp powers used for <code>data_fp</code>.
</p>
</li>
<li> <p><code>data_fp</code>: a list with all possible fp transformations for <code>xi</code>, see the
<code>data</code> component of the output of <code><a href="#topic+generate_transformations_fp">generate_transformations_fp()</a></code> and
<code><a href="#topic+generate_transformations_acd">generate_transformations_acd()</a></code>.
</p>
</li>
<li> <p><code>powers_adj</code>: fp powers for adjustment variables in <code>data_adj</code>.
</p>
</li>
<li> <p><code>data_adj</code>: adjustment data, i.e. transformed input data for adjustment
variables.
</p>
</li></ul>


<hr>
<h2 id='transform_matrix'>Function to transform each column of matrix using final FP powers or acd</h2><span id='topic+transform_matrix'></span>

<h3>Description</h3>

<p>Function to transform each column of matrix using final FP powers or acd
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_matrix(
  x,
  power_list,
  center,
  acdx,
  keep_x_order = FALSE,
  acd_parameter_list = NULL,
  check_binary = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform_matrix_+3A_x">x</code></td>
<td>
<p>a matrix with all continuous variables shifted and scaled.</p>
</td></tr>
<tr><td><code id="transform_matrix_+3A_power_list">power_list</code></td>
<td>
<p>a named list of FP powers to be applied to the columns of
<code>x</code>. Only variables named in this list are transformed.</p>
</td></tr>
<tr><td><code id="transform_matrix_+3A_center">center</code></td>
<td>
<p>a named logical vector specifying whether the columns in <code>x</code>
should be centered. Centering will occur after transformations and will be
done separately for each individual column of the transformed data matrix.</p>
</td></tr>
<tr><td><code id="transform_matrix_+3A_acdx">acdx</code></td>
<td>
<p>a named logical vector specifying the use of acd transformation.</p>
</td></tr>
<tr><td><code id="transform_matrix_+3A_keep_x_order">keep_x_order</code></td>
<td>
<p>a logical indicating whether the order of columns
should be kept as in the input matrix <code>x</code>, of if the columns should be
ordered according to <code>power_list</code>. The default is <code>FALSE</code>, since
the ordering by <code>power_list</code> reflects the <code>xorder</code> argument in <code><a href="#topic+mfp2">mfp2()</a></code>.</p>
</td></tr>
<tr><td><code id="transform_matrix_+3A_acd_parameter_list">acd_parameter_list</code></td>
<td>
<p>a named list. Only required when transformation
are to be applied to new data. Entries must correspond to the entries where
<code>acdx</code> is set to <code>TRUE</code>. Each components is to be passed to
<code><a href="#topic+transform_vector_acd">transform_vector_acd()</a></code>. The default value <code>NULL</code> indicates that the
parameters for the acd transformations are to be estimated.</p>
</td></tr>
<tr><td><code id="transform_matrix_+3A_check_binary">check_binary</code></td>
<td>
<p>passed to <code><a href="#topic+transform_vector_fp">transform_vector_fp()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on the transformations see <code><a href="#topic+transform_vector_fp">transform_vector_fp()</a></code> and
<code><a href="#topic+transform_vector_acd">transform_vector_acd()</a></code>.
</p>


<h3>Value</h3>

<p>If all elements of <code>power_list</code> are <code>NA</code> then this function returns <code>NULL</code>.
Otherwise a list with three entries: the first <code>x_transformed</code> is a matrix
with transformed variables as named in <code>power_list</code>.
The number of columns may possibly be different to the
input matrix due to higher order FP transformations.
The second entry <code>centers</code> stores the values used to center the variables if
for any variable <code>center = TRUE</code> (note that usually all variables are
centered, or none of them).
The third entry <code>acd_parameter</code> stores a named list of estimated
<code>acd_parameters</code>. May be empty if no ACD transformation is applied.
</p>


<h3>Column names</h3>

<p>Generally the original variable names are suffixed with &quot;.i&quot;, where
i enumerates the powers for a given variable in <code>power_list</code>. If a term
uses an acd transformation, then the variable is prefixed with <code>A_</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = matrix(1:100, nrow = 10)
colnames(x) = paste0("x", 1:ncol(x))
powx = setNames(replicate(ncol(x), c(1,2), simplify = FALSE), colnames(x))
center = setNames(rep(FALSE, ncol(x)), colnames(x))
acdx = setNames(rep(FALSE, ncol(x)), colnames(x))
transform_matrix(x, powx, center, acdx)

</code></pre>

<hr>
<h2 id='transform_vector_fp'>Functions to transform a variable using fractional polynomial powers or acd</h2><span id='topic+transform_vector_fp'></span><span id='topic+transform_vector_acd'></span>

<h3>Description</h3>

<p>These functions generate fractional polynomials for a variable similar to
<code>fracgen</code> in Stata. <code>transform_vector_acd</code> generates the acd transformation
for a variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_vector_fp(
  x,
  power = 1,
  scale = 1,
  shift = 0,
  name = NULL,
  check_binary = TRUE
)

transform_vector_acd(
  x,
  power = c(1, 1),
  shift = 0,
  powers = NULL,
  scale = 1,
  acd_parameter = NULL,
  name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform_vector_fp_+3A_x">x</code></td>
<td>
<p>a vector of a predictor variable.</p>
</td></tr>
<tr><td><code id="transform_vector_fp_+3A_power">power</code></td>
<td>
<p>a numeric vector indicating the FP power. Default is 1 (linear).
Must be a vector of length 2 for acd transformation. Ignores <code>NA</code>, unless
an ACD transformation is applied in which case power must be a numeric
vector of length 2, and <code>NA</code> indicated which parts are used for the final
FP.</p>
</td></tr>
<tr><td><code id="transform_vector_fp_+3A_scale">scale</code></td>
<td>
<p>scaling factor for x of interest. Must be a positive integer
or <code>NULL</code>. Default is 1, meaning no scaling is applied.
If <code>NULL</code>, then scaling factors are automatically estimated by the
program.</p>
</td></tr>
<tr><td><code id="transform_vector_fp_+3A_shift">shift</code></td>
<td>
<p>shift required for shifting x to positive values. Default is 0,
meaning no shift is applied. If <code>NULL</code> then the shift is estimated
automatically using the Royston and Sauerbrei formula iff any <code>x</code> &lt;= 0.</p>
</td></tr>
<tr><td><code id="transform_vector_fp_+3A_name">name</code></td>
<td>
<p>character used to define names for the output matrix. Default
is <code>NULL</code>, meaning the output will have unnamed columns.</p>
</td></tr>
<tr><td><code id="transform_vector_fp_+3A_check_binary">check_binary</code></td>
<td>
<p>a logical indicating whether or not input <code>x</code> is checked
if it is a binary variable (i.e. has only two distinct values). The default
<code>TRUE</code> usually only needs to changed when this function is to be used to
transform data for predictions. See Details.</p>
</td></tr>
<tr><td><code id="transform_vector_fp_+3A_powers">powers</code></td>
<td>
<p>passed to <code><a href="#topic+fit_acd">fit_acd()</a></code>.</p>
</td></tr>
<tr><td><code id="transform_vector_fp_+3A_acd_parameter">acd_parameter</code></td>
<td>
<p>a list usually returned by <code><a href="#topic+fit_acd">fit_acd()</a></code>. In particular,
it must have components that define <code>beta0</code>, <code>beta1</code>, <code>power</code>, <code>shift</code> and
<code>scale</code> which are to be applied when using the acd transformation in
new data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fp transformation generally transforms <code>x</code> as follows. For each pi in
<code>power</code> = (p1, p2, ..., pn) it creates a variable x^pi and returns the
collection of variables as a matrix. It may process the data using
shifting and scaling as desired. Centering has to be done after the
data is transformed using these functions, if desired.
</p>
<p>A special case are repeated powers, i.e. when some pi = pj. In this case,
the fp transformations are given by x^pi and x^pi * log(x). In case
more than 2 powers are repeated they are repeatedly multiplied with
log(x) terms, e.g. pi = pj = pk leads to x^pi, x^pi * log(x) and
x^pi * log(x)^2.
</p>
<p>Note that the powers pi are assumed to be sorted. That is, this function
sorts them, then proceeds to compute the transformation. For example,
the output will be the same for <code>power = c(1, 1, 2)</code> and
<code>power = c(1, 2, 1)</code>. This is done to make sense of repeated powers and
to uniquely define FPs. In case an ACD transformation is used, there is a
specific order in which powers are processed, which is always the same (but
not necessarily sorted).
Thus, throughout the whole package powers will always be given and processed
in either sorted, or ACD specific order and the columns of the matrix
returned by this function will always align with the powers used
throughout this package.
</p>
<p>Binary variables are not transformed, unless <code>check_binary</code> is set to
<code>FALSE</code>. This is usually not necessary, the only special case to set it to
<code>FALSE</code> is when a single value is to be transformed during prediction (e.g.
to transform a reference value). When this is done, binary variables are
still returned unchanged, but a single value from a continuous variable will
be transformed as desired by the fitted transformations. For model fit,
<code>check_binary</code> should always be at its default value.
</p>


<h3>Value</h3>

<p>Returns a matrix of transformed variable(s). The number of columns
depends on the number of powers provided, the number of rows is equal to the
length of <code>x</code>. The columns are sorted by increased power.
If all powers are <code>NA</code>, then this function returns <code>NULL</code>.
In case an acd transformation is applied, the output is a list with two
entries. The first <code>acd</code> is the matrix of transformed variables, the acd
term is returned as the last column of the matrix (i.e. in case that the
power for the normal data is <code>NA</code>, then it is the only column in the matrix).
The second entry <code>acd_parameter</code> returns a list of estimated parameters
for the ACD transformation, or simply the input <code>acd_parameter</code> if it was
not <code>NULL</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>transform_vector_acd()</code>: Function to generate acd transformation.
</p>
</li></ul>


<h3>Data processing</h3>

<p>An important note on data processing. Variables are shifted and scaled
before being transformed by any powers. That is to ensure positive values
and reasonable scales. Note that scaling does not change the estimated
powers, see also <code><a href="#topic+find_scale_factor">find_scale_factor()</a></code>.
</p>
<p>However, they may be centered after transformation. This is not done by
these functions.
That is to ensure that the correlation between variables stay intact,
as centering before transformation would affect them. This is described
in Sauerbrei et al (2006), as well as in the Stata manual of <code>mfp</code>.
Also, centering is not recommended, and should only be done for the final
model if desired.
</p>


<h3>References</h3>

<p>Sauerbrei, W., Meier-Hirmer, C., Benner, A. and Royston, P., 2006.
<em>Multivariable regression model building by using fractional
polynomials: Description of SAS, STATA and R programs.
Comput Stat Data Anal, 50(12): 3464-85.</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z = 1:10
transform_vector_fp(z)
transform_vector_acd(z)
</code></pre>

<hr>
<h2 id='transform_vector_power'>Simple function to transform vector by a single power</h2><span id='topic+transform_vector_power'></span>

<h3>Description</h3>

<p>Simple function to transform vector by a single power
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_vector_power(x, power = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform_vector_power_+3A_x">x</code></td>
<td>
<p>a vector of a predictor variable.</p>
</td></tr>
<tr><td><code id="transform_vector_power_+3A_power">power</code></td>
<td>
<p>single power.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of transformed values if power is not equal to 1
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
