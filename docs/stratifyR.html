<!DOCTYPE html><html><head><title>Help for package stratifyR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stratifyR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anaemia'><p>Micronutrient data on Anaemia in Fiji</p></a></li>
<li><a href='#create.mat'><p>To create and store calculated values of the objective function</p></a></li>
<li><a href='#data.alloc'><p>To calculate the stratum sample sizes (nh) for a fixed sample size (n)</p>
directly based on the data</a></li>
<li><a href='#data.optim'><p>To implement the Dynamic Programming (DP) solution procedure on the stratification</p>
problem presented in the form of a Mathematical Programming Problem (MPP)</a></li>
<li><a href='#data.root'><p>To calculate the objective function values</p></a></li>
<li><a href='#distr.alloc'><p>To calculate the stratum sample sizes (nh) for a fixed sample size (n) based</p>
on the hypothetical distribution of the data</a></li>
<li><a href='#distr.optim'><p>To implement the Dynamic Programming (DP) solution procedure on the stratification</p>
problem presented in the form of a Mathematical Programming Problem (MPP)</a></li>
<li><a href='#distr.root'><p>Calculate the objective function values</p></a></li>
<li><a href='#erf'><p>To calculate the error for a normal variable</p></a></li>
<li><a href='#get.dist'><p>To identify the best-fit distribution of a univariate data</p></a></li>
<li><a href='#hies'><p>Household Income Expenditure Survey (HIES) in Fiji</p></a></li>
<li><a href='#math'><p>Mathematics Marks for First-year University Students</p></a></li>
<li><a href='#minim.val'><p>To identify the minimum value out of two given sets of values</p></a></li>
<li><a href='#mode.val'><p>To calculate the modal value of the data</p></a></li>
<li><a href='#realloc'><p>To re-allocate the stratum sample sizes (nh)</p></a></li>
<li><a href='#strata.data'><p>Stratification of Univariate Survey Population Using the Data</p></a></li>
<li><a href='#strata.distr'><p>Stratification of Univariate Survey Population Using the Distribution</p></a></li>
<li><a href='#sugarcane'><p>Sugarcane Farming Data in Fiji</p></a></li>
<li><a href='#summary.strata'><p>This method formats and outputs the final results to the R console</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Optimal Stratification of Univariate Populations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-11-28</td>
</tr>
<tr>
<td>Author:</td>
<td>Karuna G. Reddy [aut, cre],
  M. G. M. Khan [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Karuna G. Reddy &lt;karuna.reddy@usp.ac.fj&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The stratification of univariate populations under stratified sampling designs is implemented according to Khan et al. (2002) &lt;<a href="https://doi.org/10.1177%2F0008068320020518">doi:10.1177/0008068320020518</a>&gt; and Khan et al. (2015) &lt;<a href="https://doi.org/10.1080%2F02664763.2015.1018674">doi:10.1080/02664763.2015.1018674</a>&gt; in this library. It determines the Optimum Strata Boundaries (OSB) and Optimum Sample Sizes (OSS) for the study variable, y, using the best-fit frequency distribution of a survey variable (if data is available) or a hypothetical distribution (if data is not available). The method formulates the problem of determining the OSB as mathematical programming problem which is solved by using a dynamic programming technique. If a dataset of the population is available to the surveyor, the method estimates its best-fit distribution and determines the OSB and OSS under Neyman allocation directly. When the dataset is not available, stratification is made based on the assumption that the values of the study variable, y, are available as hypothetical realizations of proxy values of y from recent surveys. Thus, it requires certain distributional assumptions about the study variable. At present, it handles stratification for the populations where the study variable follows a continuous distribution, namely, Pareto, Triangular, Right-triangular, Weibull, Gamma, Exponential, Uniform, Normal, Log-normal and Cauchy distributions. </td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), fitdistrplus, zipfR, stats, actuar, triangle,
mc2d</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-12-06 23:42:47 UTC; karunareddy</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-12-07 08:20:02 UTC</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
</table>
<hr>
<h2 id='anaemia'>Micronutrient data on Anaemia in Fiji</h2><span id='topic+anaemia'></span>

<h3>Description</h3>

<p>The Anaemia data comes from the Fiji National Nutritional Survey
in 2004 on the &quot;Micronutrient Status of Women in Fiji&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(anaemia)
</code></pre>


<h3>Format</h3>

<p>A population data frame with 724 rows on some of the key
components collected in the survey. The variables are:
</p>

<dl>
<dt><code>Haemoglobin</code></dt><dd><p>Level of Haemoglobin (mmol/L)</p>
</dd>
<dt><code>Iron</code></dt><dd><p>Level of Iron (ng/mL)</p>
</dd>
<dt><code>Folate</code></dt><dd><p>Level of Folate (mmol/L)</p>
</dd>
</dl>



<h3>Source</h3>

<p>This survey was conducted by the Ministry of Heath in Fiji. More details can be found at: <a href="http://ghdx.healthdata.org/record/fiji-national-nutrition-survey-2004">http://ghdx.healthdata.org/record/fiji-national-nutrition-survey-2004</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(anaemia)
head(anaemia)
Iron &lt;- anaemia$Iron
min(Iron); max(Iron)
hist(anaemia$Haemoglobin)
boxplot(anaemia$Folate)

</code></pre>

<hr>
<h2 id='create.mat'>To create and store calculated values of the objective function</h2><span id='topic+create.mat'></span>

<h3>Description</h3>

<p>This function creates a matrix whose rows and columns depend on the
range or distance of the data and the number of strata solutions that the 
user is seeking to compute. The matrix stores the objective function values
calculated by the algorithm only to be accessed later for the purpose of
presenting the OSB.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.mat(my_env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create.mat_+3A_my_env">my_env</code></td>
<td>
<p>The environment my_env has various constants stored
from earlier operations dealing with information on the data</p>
</td></tr>
</table>


<h3>Value</h3>

<p> stores numerical quantities of the objective function
and stores in the two matrices inside the my_env to be accessed by other
functions
</p>


<h3>Author(s)</h3>

<p>Karuna Reddy &lt;karuna.reddy@usp.ac.fj&gt;<br />
MGM Khan &lt;khan_mg@usp.ac.fj&gt;
</p>

<hr>
<h2 id='data.alloc'>To calculate the stratum sample sizes (nh) for a fixed sample size (n) 
directly based on the data</h2><span id='topic+data.alloc'></span>

<h3>Description</h3>

<p>This function is called towards the final stages of the stratification process
after OSB have been determined. It uses the boundaries to calculate the stratum 
sample allocations using Neyman allocation for all individual strata using the 
raw data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.alloc(data, my_env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.alloc_+3A_data">data</code></td>
<td>
<p>A vector: provided as an input to the function</p>
</td></tr>
<tr><td><code id="data.alloc_+3A_my_env">my_env</code></td>
<td>
<p>The environment my_env has various constants and outputs stored
from earlier operations through various other functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p> calculates and stores quantities such as nh, Nh, Vh, etc.
in the my_env to be accessed and printed as outputs
</p>


<h3>Author(s)</h3>

<p>Karuna Reddy &lt;karuna.reddy@usp.ac.fj&gt;<br />
MGM Khan &lt;khan_mg@usp.ac.fj&gt;
</p>

<hr>
<h2 id='data.optim'>To implement the Dynamic Programming (DP) solution procedure on the stratification
problem presented in the form of a Mathematical Programming Problem (MPP)</h2><span id='topic+data.optim'></span>

<h3>Description</h3>

<p>This function uses the Dynamic Programming (DP) solution procedure in solving the
objective function for the univariate stratification problem. It calculates
the objective function values using the brute-force algorithm and stores those
values in the matrices and keeps a copy in my_env so that a global minimum
could be obtained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.optim(k, n, incf, minYk, maxYk, isFirstRun = TRUE, my_env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.optim_+3A_k">k</code></td>
<td>
<p>A numeric: number of strata</p>
</td></tr>
<tr><td><code id="data.optim_+3A_n">n</code></td>
<td>
<p>A numeric: is the distance*1000</p>
</td></tr>
<tr><td><code id="data.optim_+3A_incf">incf</code></td>
<td>
<p>A numeric: 10e-3 when k=1 and 10e-5 for k&gt;=2</p>
</td></tr>
<tr><td><code id="data.optim_+3A_minyk">minYk</code></td>
<td>
<p>A numeric: index to access minimum elements in the matrix</p>
</td></tr>
<tr><td><code id="data.optim_+3A_maxyk">maxYk</code></td>
<td>
<p>A numeric: index to access maximum elements in the matrix</p>
</td></tr>
<tr><td><code id="data.optim_+3A_isfirstrun">isFirstRun</code></td>
<td>
<p>A boolean: TRUE/FALSE parameter</p>
</td></tr>
<tr><td><code id="data.optim_+3A_my_env">my_env</code></td>
<td>
<p>The environment my_env has various constants and calculations stored
from earlier opeartions through various other functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns the array filled with calculations of objective
function values
</p>


<h3>Author(s)</h3>

<p>Karuna Reddy &lt;karuna.reddy@usp.ac.fj&gt;<br /> M
GM Khan &lt;khan_mg@usp.ac.fj&gt;
</p>

<hr>
<h2 id='data.root'>To calculate the objective function values</h2><span id='topic+data.root'></span>

<h3>Description</h3>

<p>This function is called within other important functions in the stratifyR
package to calculate the objective function values at systematic incremental
progressions of stratum width and range of the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.root(d, y, c, my_env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.root_+3A_d">d</code></td>
<td>
<p>A numeric: distance or range of data</p>
</td></tr>
<tr><td><code id="data.root_+3A_y">y</code></td>
<td>
<p>A numeric: stratum width</p>
</td></tr>
<tr><td><code id="data.root_+3A_c">c</code></td>
<td>
<p>A numeric: stratum cost</p>
</td></tr>
<tr><td><code id="data.root_+3A_my_env">my_env</code></td>
<td>
<p>The environment my_env contains the constants and outputs
from various calculations carried out by other key functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns the value of the objective function
</p>


<h3>Author(s)</h3>

<p>Karuna Reddy &lt;karuna.reddy@usp.ac.fj&gt;<br /> MGM Khan &lt;khan_mg@usp.ac.fj&gt;
</p>

<hr>
<h2 id='distr.alloc'>To calculate the stratum sample sizes (nh) for a fixed sample size (n) based
on the hypothetical distribution of the data</h2><span id='topic+distr.alloc'></span>

<h3>Description</h3>

<p>This function is called towards the final stages of the stratification process
after OSB have been determined. It uses the boundaries to calculate the stratum
sample allocations using Neyman allocation for all individual strata using the
underlying distribution of the population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distr.alloc(my_env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distr.alloc_+3A_my_env">my_env</code></td>
<td>
<p>The environment my_env which has various constants and outputs stored
from earlier operations through various other functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p> calculates and stores quantities such as nh, Nh, Vh, etc.
in the my_env to be accessed and printed as outputs
</p>


<h3>Author(s)</h3>

<p>Karuna Reddy &lt;karuna.reddy@usp.ac.fj&gt;<br /> MGM Khan &lt;khan_mg@usp.ac.fj&gt;
</p>

<hr>
<h2 id='distr.optim'>To implement the Dynamic Programming (DP) solution procedure on the stratification
problem presented in the form of a Mathematical Programming Problem (MPP)</h2><span id='topic+distr.optim'></span>

<h3>Description</h3>

<p>This function uses the Dynamic Programming (DP) solution procedure in solving the
objective function for the univariate stratification problem. It calculates
the objective function values using the brute-force algorithm and stores those
values in the matrices and keeps a copy in my_env so that a global minimum
could be obtained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distr.optim(k, n, incf, minYk, maxYk, isFirstRun = TRUE, my_env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distr.optim_+3A_k">k</code></td>
<td>
<p>A numeric: number of strata</p>
</td></tr>
<tr><td><code id="distr.optim_+3A_n">n</code></td>
<td>
<p>A numeric: is the distance*1000</p>
</td></tr>
<tr><td><code id="distr.optim_+3A_incf">incf</code></td>
<td>
<p>A numeric: 10e-3 when k=1 and 10e-5 for k&gt;=2</p>
</td></tr>
<tr><td><code id="distr.optim_+3A_minyk">minYk</code></td>
<td>
<p>A numeric: index to access minimum elements in the matrix</p>
</td></tr>
<tr><td><code id="distr.optim_+3A_maxyk">maxYk</code></td>
<td>
<p>A numeric: index to access maximum elements in the matrix</p>
</td></tr>
<tr><td><code id="distr.optim_+3A_isfirstrun">isFirstRun</code></td>
<td>
<p>A boolean: TRUE/FALSE parameter</p>
</td></tr>
<tr><td><code id="distr.optim_+3A_my_env">my_env</code></td>
<td>
<p>My environment my_env has various constants and calculations stored
from earlier opeartions through various other functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns the array filled with calculations of objective
function values
</p>


<h3>Author(s)</h3>

<p>Karuna Reddy &lt;karuna.reddy@usp.ac.fj&gt;<br /> MGM Khan &lt;khan_mg@usp.ac.fj&gt;
</p>

<hr>
<h2 id='distr.root'>Calculate the objective function values</h2><span id='topic+distr.root'></span>

<h3>Description</h3>

<p>This function is called within other important functions in the package
to calculate the objective function values at systematic incremental
progressions of stratum width and range of the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distr.root(d, y, c, my_env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distr.root_+3A_d">d</code></td>
<td>
<p>A numeric: distance or range of data</p>
</td></tr>
<tr><td><code id="distr.root_+3A_y">y</code></td>
<td>
<p>A numeric: stratum width</p>
</td></tr>
<tr><td><code id="distr.root_+3A_c">c</code></td>
<td>
<p>A numeric: stratum cost</p>
</td></tr>
<tr><td><code id="distr.root_+3A_my_env">my_env</code></td>
<td>
<p>My environment my_env contains the constants and outputs
from various calculations carried out by other key functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns the value of the objective function
</p>


<h3>Author(s)</h3>

<p>Karuna Reddy &lt;karuna.reddy@usp.ac.fj&gt;<br />
MGM Khan &lt;khan_mg@usp.ac.fj&gt;
</p>

<hr>
<h2 id='erf'>To calculate the error for a normal variable</h2><span id='topic+erf'></span>

<h3>Description</h3>

<p>This function calculates the value of the error according to the          
normally distributed variable using the idea presented in   
Abramowitz and Stegun (2011)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>erf(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="erf_+3A_x">x</code></td>
<td>
<p>The data that is provided</p>
</td></tr>
</table>


<h3>Value</h3>

<p> Gives the error for a normal variable
</p>


<h3>Author(s)</h3>

<p>Karuna Reddy &lt;karuna.reddy@usp.ac.fj&gt;<br />
MGM Khan &lt;khan_mg@usp.ac.fj&gt;
</p>

<hr>
<h2 id='get.dist'>To identify the best-fit distribution of a univariate data</h2><span id='topic+get.dist'></span>

<h3>Description</h3>

<p>This function is called at the start of the stratification process where the
best-fit distribution and it parameters are estimated and returned for further
processing towards the computation of stratum boundaries. It basically takes in
the data and fits it with a list of 10 possible distributions and computes
the parameters for all given distributions. It selects the best-fit distribution
to be the one with the lowest AIC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.dist(data, my_env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.dist_+3A_data">data</code></td>
<td>
<p>A vector: usually a column in a given data frame</p>
</td></tr>
<tr><td><code id="get.dist_+3A_my_env">my_env</code></td>
<td>
<p>My environment my_env has various constants and data that are
used by the get.dist() function</p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns a list which contains the best-fit distribution and
its estimated parameters
</p>


<h3>Author(s)</h3>

<p>Karuna Reddy &lt;karuna.reddy@usp.ac.fj&gt;<br /> MGM Khan &lt;khan_mg@usp.ac.fj&gt;
</p>

<hr>
<h2 id='hies'>Household Income Expenditure Survey (HIES) in Fiji</h2><span id='topic+hies'></span>

<h3>Description</h3>

<p>The hies data comes from the HIES survey conducted
in Fiji in the year 2010. The data contains only two aspects
of the survey.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hies)
</code></pre>


<h3>Format</h3>

<p>A data frame with 3566 observations on two of
the major quantities collected in the survey. The
variables are:
</p>

<dl>
<dt><code>Expenditure</code></dt><dd><p>Level of expenditure (FJD)</p>
</dd>
<dt><code>Income</code></dt><dd><p>Level of income (FJD)</p>
</dd>
</dl>



<h3>Source</h3>

<p>This survey was conducted in 2010 by the Bureau of Statistics (FIBoS) - Fiji Government.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hies$Income)
min(hies$Income); max(hies$Income)
hist(hies$Income)
boxplot(hies$Income)

</code></pre>

<hr>
<h2 id='math'>Mathematics Marks for First-year University Students</h2><span id='topic+math'></span>

<h3>Description</h3>

<p>The data contains the mathematics coursework marks, final
examination marks and grades obtained by students in a
first year mathematics course at The University
level in the year 2010 in Fiji.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(math)
</code></pre>


<h3>Format</h3>

<p>A data frame with 353 observations which represent
mathematics marks and grades for first year math students at
university level. The variable is as follows:
</p>

<dl>
<dt><code>cw</code></dt><dd><p>Coursework marks in 1st year mathematics (0-50)</p>
</dd>
<dt><code>end_exam</code></dt><dd><p>The end of semester examination marks
maths (0-50)</p>
</dd>
<dt><code>final_marks</code></dt><dd><p>Final examination marks in
maths, which is an addition of the cw and end_exam (0-100)</p>
</dd>
<dt><code>grade</code></dt><dd><p>The grade obtained by the student based on the final marks</p>
</dd></dl>



<h3>Source</h3>

<p>The data was obtained by a masters students at USP, Fiji.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(math)
min(math$final_marks); max(math$final_marks)
hist(math$final_marks)
boxplot(math$final_marks)

</code></pre>

<hr>
<h2 id='minim.val'>To identify the minimum value out of two given sets of values</h2><span id='topic+minim.val'></span>

<h3>Description</h3>

<p>This function is called in data.optim() or distr.optim()
which basically compares and returns the smaller value out
of two given sets of values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minim.val(val1, val2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minim.val_+3A_val1">val1</code></td>
<td>
<p>A numeric: the first value</p>
</td></tr>
<tr><td><code id="minim.val_+3A_val2">val2</code></td>
<td>
<p>A numeric: the second value</p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns the minimum value
</p>


<h3>Author(s)</h3>

<p>Karuna Reddy &lt;karuna.reddy@usp.ac.fj&gt;<br />
MGM Khan &lt;khan_mg@usp.ac.fj&gt;
</p>

<hr>
<h2 id='mode.val'>To calculate the modal value of the data</h2><span id='topic+mode.val'></span>

<h3>Description</h3>

<p>This function calculates the value of the mode of the data
that is provided
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mode.val(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mode.val_+3A_x">x</code></td>
<td>
<p>The data that is provided</p>
</td></tr>
</table>


<h3>Value</h3>

<p> Gives the mode
</p>


<h3>Author(s)</h3>

<p>Karuna Reddy &lt;karuna.reddy@usp.ac.fj&gt;<br />
MGM Khan &lt;khan_mg@usp.ac.fj&gt;
</p>

<hr>
<h2 id='realloc'>To re-allocate the stratum sample sizes (nh)</h2><span id='topic+realloc'></span>

<h3>Description</h3>

<p>This function re-calculates or re-allocate the stratum sample sizes 
(nh) after it has already been initially allocated via Neyman
allocation. This is applied to resolve the problem of oversampling 
in one or more of the strata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>realloc(h, x, nh, Nh, nume, my_env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="realloc_+3A_h">h</code></td>
<td>
<p>A numeric: the no. of strata</p>
</td></tr>
<tr><td><code id="realloc_+3A_x">x</code></td>
<td>
<p>A vector: the osb that has been calculated</p>
</td></tr>
<tr><td><code id="realloc_+3A_nh">nh</code></td>
<td>
<p>A vector: the stratum sample sizes that have been initially calculated</p>
</td></tr>
<tr><td><code id="realloc_+3A_nh">Nh</code></td>
<td>
<p>A vector: the stratum population sizes that have been initially calculated</p>
</td></tr>
<tr><td><code id="realloc_+3A_nume">nume</code></td>
<td>
<p>A numeric: the numerator total</p>
</td></tr>
<tr><td><code id="realloc_+3A_my_env">my_env</code></td>
<td>
<p>The environment my_env has various constants and outputs stored
from earlier opeartions through various other functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p> calculates and presents the new re-allocate stratum samples
</p>


<h3>Author(s)</h3>

<p>Karuna Reddy &lt;karuna.reddy@usp.ac.fj&gt;<br />
MGM Khan &lt;khan_mg@usp.ac.fj&gt;
</p>

<hr>
<h2 id='strata.data'>Stratification of Univariate Survey Population Using the Data</h2><span id='topic+strata.data'></span>

<h3>Description</h3>

<p>This function takes in the univariate population data
(argument <code>data</code>) and a fixed sample size (n)
to compute the optimum stratum boundaries (OSB) for a
given number of strata (L), optimum sample sizes (nh),
etc. directly from the data. The main idea used is from
Khan et al (2008) whereby the problem of stratification
is formulated into a Mathematical Programming Problem (MPP)
using the best-fit frequency distribution and its parameters
estimated from the data. This MPP is then solved for the
OSB using a Dynamic Programming (DP) solution procedure.
</p>
<p>This function takes in the univariate population data
(argument <code>data</code>) and a fixed sample size (n)
to compute the optimum stratum boundaries (OSB) for a
given number of strata (L), optimum sample sizes (nh),
etc. directly from the data. The main idea used is from
Khan et al (2008) whereby the problem of stratification
is formulated into a Mathematical Programming Problem (MPP)
using the best-fit frequency distribution and its parameters
estimated from the data. This MPP is then solved for the
OSB using a Dynamic Programming (DP) solution procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strata.data(data, h, n, cost = FALSE, ch = NULL)

strata.data(data, h, n, cost = FALSE, ch = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strata.data_+3A_data">data</code></td>
<td>
<p>A vector of values of the survey variable y for
which the OSB are determined</p>
</td></tr>
<tr><td><code id="strata.data_+3A_h">h</code></td>
<td>
<p>A numeric: denotes the number of strata to be created.</p>
</td></tr>
<tr><td><code id="strata.data_+3A_n">n</code></td>
<td>
<p>A numeric: denotes a fixed total sample size.</p>
</td></tr>
<tr><td><code id="strata.data_+3A_cost">cost</code></td>
<td>
<p>A logical: has default cost=FALSE. If it is a stratum-cost problem,
cost=TRUE, with which, one must provide the Ch parameter.</p>
</td></tr>
<tr><td><code id="strata.data_+3A_ch">ch</code></td>
<td>
<p>A numeric: denotes a vector of stratum costs. When cost=FALSE, it 
has a default of NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>strata.data</code> returns Optimum Strata Boundaries (OSB),
stratum weights (Wh), stratum variances (Vh), Optimum Sample Sizes
(nh), stratum population sizes (Nh) and sampling fraction (fh).
</p>
<p><code>strata.data</code> returns Optimum Strata Boundaries (OSB),
stratum weights (Wh), stratum variances (Vh), Optimum Sample Sizes
(nh), stratum population sizes (Nh) and sampling fraction (fh).
</p>


<h3>Author(s)</h3>

<p>Karuna Reddy &lt;karuna.reddy@usp.ac.fj&gt;<br /> MGM Khan &lt;khan_mg@usp.ac.fj&gt;
</p>
<p>Karuna Reddy &lt;karuna.reddy@usp.ac.fj&gt;<br /> MGM Khan &lt;khan_mg@usp.ac.fj&gt;
</p>


<h3>See Also</h3>

<p><code>strata.distr</code>
</p>
<p><code>strata.distr</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data &lt;- rweibull(1000, shape=2, scale = 1.5)
hist(data)
obj &lt;- strata.data(data, h = 2, n=300)
summary(obj)
#-------------------------------------------------------------
data(anaemia)
Iron &lt;- anaemia$Iron
res &lt;- strata.data(Iron, h = 2, n=350)
summary(res)
#-------------------------------------------------------------
data(SHS) #Household Spending data from stratification package
weight &lt;- SHS$WEIGHT
hist(weight); length(weight)
res &lt;- strata.data(weight, h = 2, n=500)
summary(res)
#-------------------------------------------------------------
data(sugarcane)
Production &lt;- sugarcane$Production
hist(Production)
res &lt;- strata.data(Production, h = 2, n=1000)
summary(res)
#-------------------------------------------------------------
#The function be dynamically used to visualize the the strata boundaries, 
#for 2 strata, over the density (or observations) of the "mag" variable 
#from the quakes data (with purrr and ggplot2 packages loaded).
output &lt;- quakes %&gt;%
          pluck("mag") %&gt;%
          strata.data(h = 2, n = 300)
quakes %&gt;% 
      ggplot(aes(x = mag)) +
      geom_density(fill = "blue", colour = "black", alpha = 0.3) +
      geom_vline(xintercept = output$OSB, linetype = "dotted", color = "red")
#-------------------------------------------------------------

## End(Not run)

## Not run: 
data &lt;- rweibull(1000, shape=2, scale = 1.5)
hist(data)
obj &lt;- strata.data(data, h = 2, n=300)
summary(obj)
#-------------------------------------------------------------
data(anaemia)
Iron &lt;- anaemia$Iron
res &lt;- strata.data(Iron, h = 2, n=350)
summary(res)
#-------------------------------------------------------------
data(SHS) #Household Spending data from stratification package
weight &lt;- SHS$WEIGHT
hist(weight); length(weight)
res &lt;- strata.data(weight, h = 2, n=500)
summary(res)
#-------------------------------------------------------------
data(sugarcane)
Production &lt;- sugarcane$Production
hist(Production)
res &lt;- strata.data(Production, h = 2, n=1000)
summary(res)
#-------------------------------------------------------------
#The function be dynamically used to visualize the the strata boundaries, 
#for 2 strata, over the density (or observations) of the "mag" variable 
#from the quakes data (with purrr and ggplot2 packages loaded).
output &lt;- quakes %&gt;%
          pluck("mag") %&gt;%
          strata.data(h = 2, n = 300)
quakes %&gt;% 
      ggplot(aes(x = mag)) +
      geom_density(fill = "blue", colour = "black", alpha = 0.3) +
      geom_vline(xintercept = output$OSB, linetype = "dotted", color = "red")
#-------------------------------------------------------------

## End(Not run)

</code></pre>

<hr>
<h2 id='strata.distr'>Stratification of Univariate Survey Population Using the Distribution</h2><span id='topic+strata.distr'></span>

<h3>Description</h3>

<p>This function takes in the underlying hypothetical distribution and
its parameter(s) of the survey variable, the initial value and
the range of the population, the fixed sample size (n) and the
fixed population size (N) to compute the optimum stratum boundaries
(OSB) for a given number of strata (L), optimum sample sizes (nh),
etc. The main idea used is from Khan et al. (2008) whereby the
problem of stratification is fromulated into a Mathematical Programming
Problem (MPP) using the best-fit frequency distribution and its
parameter estimates of the data. This MPP is then solved for the
optimal solutions using the Dynamic Programming (DP) solution procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strata.distr(
  h,
  initval,
  dist,
  distr = c("pareto", "triangle", "rtriangle", "weibull", "gamma", "exp", "unif",
    "norm", "lnorm", "cauchy"),
  params = c(shape = 0, scale = 0, rate = 0, gamma = 0, location = 0, mean = 0, sd = 0,
    meanlog = 0, sdlog = 0, min = 0, max = 0, mode = 0),
  n,
  N,
  cost = FALSE,
  ch = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strata.distr_+3A_h">h</code></td>
<td>
<p>A numeric: denotes the number of strata to be created.</p>
</td></tr>
<tr><td><code id="strata.distr_+3A_initval">initval</code></td>
<td>
<p>A numeric: denotes the initial value of the population</p>
</td></tr>
<tr><td><code id="strata.distr_+3A_dist">dist</code></td>
<td>
<p>A numeric: denotes distance (or range) of the population</p>
</td></tr>
<tr><td><code id="strata.distr_+3A_distr">distr</code></td>
<td>
<p>A character: denotes the name of the distribution that
characterizes the population</p>
</td></tr>
<tr><td><code id="strata.distr_+3A_params">params</code></td>
<td>
<p>A list: contains the values of all parameters of the distribution</p>
</td></tr>
<tr><td><code id="strata.distr_+3A_n">n</code></td>
<td>
<p>A numeric: denotes the fixed total sample size.</p>
</td></tr>
<tr><td><code id="strata.distr_+3A_n">N</code></td>
<td>
<p>A numeric: denotes the fixed total population size.</p>
</td></tr>
<tr><td><code id="strata.distr_+3A_cost">cost</code></td>
<td>
<p>A logical: has default cost=FALSE. If it is a stratum-cost problem,
cost=TRUE, with which one must provide the Ch parameter.</p>
</td></tr>
<tr><td><code id="strata.distr_+3A_ch">ch</code></td>
<td>
<p>A numeric: denotes a vector of stratum costs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>strata.distr</code> returns Optimum Strata Boundaries (OSB),
stratum weights (Wh), stratum costs (Ch), stratum variances (Vh), Optimum Sample Sizes
(nh), stratum population sizes (Nh).
</p>


<h3>Author(s)</h3>

<p>Karuna Reddy &lt;karuna.reddy@usp.ac.fj&gt;<br /> MGM Khan &lt;khan_mg@usp.ac.fj&gt;
</p>


<h3>See Also</h3>

<p><code>strata.data</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Assume data has initial value of 1.5, distance of 33 and follows
#weibull distribution with estimated parameters as shape=2.15 and scale=13.5
#To compute the OSB, OSS, etc. with fixed sample n=500, we use:
res &lt;- strata.distr(h=2, initval=1.5, dist=33, distr = "weibull",
params = c(shape=2.15, scale=13.5), n=500, N=2000, cost=FALSE)
summary(res)
#-------------------------------------------------------------
#Assume data has initial value of 1, distance of 10415 and follows
#lnorm distribution with estimated parameters as meanlog=5.5 and sdlog=1.5
#To compute the OSB, OSS, etc. with fixed sample n=500, we use:
res &lt;- strata.distr(h=2, initval=1, dist=10415, distr = "lnorm",
params = c(meanlog=5.5, sdlog=1.5), n=500, N=12000)
summary(res)
#-------------------------------------------------------------
#Assume data has initial value of 2, distance of 68 and follows
#gamma distribution with estimated parameters as shape=3.8 and rate=0.55
#To compute the OSB, OSS, etc. with fixed sample n=500, we use:
res &lt;- strata.distr(h=2, initval=0.65, dist=68, distr = "gamma",
params = c(shape=3.8, rate=0.55), n=500, N=10000)
summary(res)
#-------------------------------------------------------------
#The function be dynamically used to visualize the the strata boundaries, 
#for 2 strata, over the density (or observations) of the "mag" variable 
#from the quakes data (with purrr and ggplot2 packages loaded).
res &lt;- strata.distr(h=2, initval=4, dist=2.4, distr = "lnorm", 
          params = c(meanlog=1.52681032, sdlog=0.08503554), n=300, N=1000)
quakes %&gt;% 
      ggplot(aes(x = mag)) +
      geom_density(fill = "blue", colour = "black", alpha = 0.3) +
      geom_vline(xintercept = res$OSB, linetype = "dotted", color = "red")
#-------------------------------------------------------------

## End(Not run)

</code></pre>

<hr>
<h2 id='sugarcane'>Sugarcane Farming Data in Fiji</h2><span id='topic+sugarcane'></span>

<h3>Description</h3>

<p>The sugarcane data shows the disposition area (land
area under cane) for individual sugarcane farms
and their cane productions with the incomes/earnings
for the year 2010 in Fiji.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sugarcane)
</code></pre>


<h3>Format</h3>

<p>A data frame with 13894 observations corresponding to individual farms.
The following are the variables:
</p>

<dl>
<dt><code>DispArea</code></dt><dd><p>Disposition area (or land area under cane) (hactares)</p>
</dd>
<dt><code>Production</code></dt><dd><p>The amount of sugarcane produced in the farm (tonnes)</p>
</dd>
<dt><code>Income</code></dt><dd><p>Net income or money paid to farmers) (in FJD)</p>
</dd></dl>



<h3>Source</h3>

<p>This data was obtained from the Fiji Sugar Corporation in Fiji.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sugarcane$Production)
head(sugarcane$Production)
Production &lt;- sugarcane$Production
min(Production); max(Production)
hist(Production)
boxplot(Production)

</code></pre>

<hr>
<h2 id='summary.strata'>This method formats and outputs the final results to the R console</h2><span id='topic+summary.strata'></span>

<h3>Description</h3>

<p>This function defines the method for the &quot;strata&quot; class that has been created 
in the constructor function (strata.data() or strata.distr()) where all computed 
objects, via other relevant functions, are collated and passed as a list. The 
function extracts all individual objects from the &quot;strata&quot; class object and combines 
them into dataframes before writing the formatted outputs to the console. This 
is used for both cases, depending on either the data or a hypothetical distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'strata'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.strata_+3A_object">object</code></td>
<td>
<p>A list: An object of class &quot;strata&quot;.</p>
</td></tr>
<tr><td><code id="summary.strata_+3A_...">...</code></td>
<td>
<p>Any data type: This argument can be any particular argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns the formatted output
</p>


<h3>Author(s)</h3>

<p>Karuna Reddy &lt;karuna.reddy@usp.ac.fj&gt;<br /> MGM Khan &lt;khan_mg@usp.ac.fj&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data &lt;- rweibull(1000, shape=2, scale = 1.5)
res &lt;- strata.data(data, h = 2, n=300)
summary(res)

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
