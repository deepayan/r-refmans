<!DOCTYPE html><html lang="en"><head><title>Help for package clustra</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {clustra}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#clustra-package'><p>clustra-package</p></a></li>
<li><a href='#allpair_RandIndex'><p>allpair_RandIndex: helper for replicated cluster comparison</p></a></li>
<li><a href='#bp10k'><p>Simulated blood pressure data</p></a></li>
<li><a href='#check_df'><p>Checks if non-empty groups have enough data for spline fit</p>
degrees of freedom.</a></li>
<li><a href='#clustra'><p>Cluster longitudinal trajectories over time</p></a></li>
<li><a href='#clustra_rand'><p>clustra_rand: Rand Index cluster evaluation</p></a></li>
<li><a href='#clustra_sil'><p>clustra_sil: Prepare silhouette plot data for several k or for a previous</p>
clustra run</a></li>
<li><a href='#deltime'><p>Timing function</p></a></li>
<li><a href='#gen_traj_data'><p>Data Generators</p></a></li>
<li><a href='#gendata'><p>gendata</p></a></li>
<li><a href='#ic_fun'><p>Function to test information criteria. Not exported and used by internal</p>
function <code>kchoose</code>.</a></li>
<li><a href='#kchoose'><p>A test function to evaluate information criteria for several k values. Not</p>
exported and only for debugging internal use.</a></li>
<li><a href='#mse_g'><p>Various Loss functions used internally by clustra</p></a></li>
<li><a href='#oneid'><p>Generates data for one <code>id</code></p></a></li>
<li><a href='#plot_sample'><p>Plots a sample of ids in a small mutiples layout</p></a></li>
<li><a href='#plot_silhouette'><p>Plots a list item, a silhouette, from the result of <code>clustra_sil</code> along</p>
with the average silhouette value. Typically used via
<code>lapply(list, plot_silhouette)</code></a></li>
<li><a href='#plot_smooths'><p>plot_smooths</p></a></li>
<li><a href='#pred_g'><p>Function to predict for new data based on fitted gam object.</p></a></li>
<li><a href='#rand_plot'><p>Matrix plot of Rand Index comparison of replicated clusters</p></a></li>
<li><a href='#start_groups'><p>Function to assign starting groups.</p></a></li>
<li><a href='#tps_g'><p>Fits a thin plate spline to a single group with</p>
<code>bam</code>.</a></li>
<li><a href='#traj_rep'><p>Function to run trajectories inside mclapply with one core.</p></a></li>
<li><a href='#trajectories'><p>Cluster longitudinal trajectories over time.</p></a></li>
<li><a href='#xit_report'><p>xit_report</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-04</td>
</tr>
<tr>
<td>Title:</td>
<td>Clustering Longitudinal Trajectories</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, graphics, grDevices, methods, mgcv, MixSim,
parallel, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>haven, knitr, rmarkdown</td>
</tr>
<tr>
<td>Description:</td>
<td>Clusters longitudinal trajectories over time (can be unequally 
    spaced, unequal length time series and/or partially overlapping series) on
    a common time axis. Performs k-means clustering on a single continuous 
    variable measured over time, where each mean is defined by a thin plate 
    spline fit to all points in a cluster. Distance is MSE across trajectory 
    points to cluster spline. Provides graphs of derived cluster splines, 
    silhouette plots, and Adjusted Rand Index evaluations of the number
    of clusters. Scales well to large data with multicore parallelism available
    to speed computation.</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-2-Clause">BSD 2-clause License</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>George Ostrouchov &lt;go@tennessee.edu&gt;</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-08 15:04:21 UTC; ost</td>
</tr>
<tr>
<td>Author:</td>
<td>George Ostrouchov [aut, cre],
  David Gagnon [aut],
  Hanna Gerlovin [aut],
  Chen Wei-Chen [ctb],
  Schmidt Drew [ctb],
  Oak Ridge National Laboratory [cph],
  U.S. Department of Veteran's Affairs [fnd] (Project: Million Veteran
    Program Data Core)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-10 21:33:14 UTC</td>
</tr>
</table>
<hr>
<h2 id='clustra-package'>clustra-package</h2><span id='topic+clustra-package'></span>

<h3>Description</h3>

<p>Clusters trajectories (unequally spaced and unequal length time series) on
a common time axis. Clustering proceeds by an EM algorithm that iterates
switching between fitting a thin plate spline (TPS) to combined responses
within each cluster (M-step) and reassigning cluster membership based on the
nearest fitted TPS (E-step). Initial cluster assignments are random or
distant trajectories. The fitting is done with the <em>mgcv</em> package function
<em>bam</em>, which scales well to very large data sets. Additional parallelism
available via multicore on unix and mac platforms.
</p>


<h3>Details</h3>

<p>This research is based on data from the Million Veteran Program, Office of
Research and Development, Veterans Health Administration, and was supported
by award No.~MVP000. This research used resources from the Knowledge
Discovery Infrastructure (KDI) at Oak Ridge National Laboratory, which is
supported by the Office of Science of the US Department of Energy under
Contract No. DE-AC05-00OR22725.
</p>
<p>This research used resources of the Compute and Data Environment
for Science (CADES) at the Oak Ridge National Laboratory, which is supported
by the Office of Science of the U.S. Department of Energy under Contract No.
DE-AC05-00OR22725.
</p>


<h3>Author(s)</h3>

<p>George Ostrouchov, David Gagnon, Hanna Gerlovin
</p>

<hr>
<h2 id='allpair_RandIndex'>allpair_RandIndex: helper for replicated cluster comparison</h2><span id='topic+allpair_RandIndex'></span>

<h3>Description</h3>

<p>Runs <code><a href="MixSim.html#topic+RandIndex">RandIndex</a></code> for all pairs of cluster results in its
list input and produces a matrix for use by <code><a href="#topic+rand_plot">rand_plot</a></code>.
Understands replicates within <code>k</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allpair_RandIndex(results)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allpair_RandIndex_+3A_results">results</code></td>
<td>
<p>A list with each element packed internally by the
<code><a href="#topic+clustra_rand">clustra_rand</a></code> function with elements:
</p>

<ul>
<li> <p><code>k</code> - number of clusters
</p>
</li>
<li> <p><code>rep</code> - replicate number
</p>
</li>
<li> <p><code>deviance</code> - final deviance
</p>
</li>
<li> <p><code>group</code> - integer cluster assignments
Note that item order is assumed to be the same across all <code>rep</code> and <code>k</code> but
<code>group</code> numbering need not be same. The algorithm only examines if pairs of
items are in same or different clusters within each <code>results</code> list element.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with <code><a href="MixSim.html#topic+RandIndex">RandIndex</a></code> for all pairs from
trajectories results. The data frame names and its format is intended to be
the input for <code><a href="#topic+rand_plot">rand_plot</a></code>. Note that all pairs is the lower
triangle plus diagonal of an all-pairs symmetric matrix.
</p>

<hr>
<h2 id='bp10k'>Simulated blood pressure data</h2><span id='topic+bp10k'></span>

<h3>Description</h3>

<p>A sample of 10,000 individuals from the full 80,000 individuals in a dataset
available on GitHub at
https://github.com/MVP-CHAMPION/clustra-SAS/raw/main/bp_data/simulated_data_27June2023.csv.gz
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bp10k
</code></pre>


<h3>Format</h3>



<h4><code>bp10k</code></h4>

<p>A &quot;data.table&quot; and &quot;data.frame&quot; with 167,277 rows and 4 columns:
</p>

<dl>
<dt>id</dt><dd><p>An integer in 1:80000.</p>
</dd>
<dt>group</dt><dd><p>An integer in 1:5.</p>
</dd>
<dt>time</dt><dd><p>An integer between -365 and 730, giving observation day with
reference to an intervention at time 0.</p>
</dd>
<dt>response</dt><dd><p>The systolic blood pressure on that day.</p>
</dd>
</dl>




<h3>Details</h3>

<p>The full data set contains 80,000 individuals, each with an average of about
17 observations in 5 clusters with scatter. The individuals are generated
from a 5-cluster thin spline model of actual blood pressures collected from
roughly the same number of individuals at U.S. Department of Veterans Affairs
facilities in connection with the MVP-CHAMPION project. Each cluster-mean
generated individual has a random number of observations at random times with
one observation at intervention time 0, and with added standard normal error.
The resulting data has 1,353,910 rows and 4 columns.
</p>

<hr>
<h2 id='check_df'>Checks if non-empty groups have enough data for spline fit
degrees of freedom.</h2><span id='topic+check_df'></span>

<h3>Description</h3>

<p>Checks if non-empty groups have enough data for spline fit
degrees of freedom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_df(group, loss, data, maxdf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_df_+3A_group">group</code></td>
<td>
<p>An integer vector of group membership for each id.</p>
</td></tr>
<tr><td><code id="check_df_+3A_loss">loss</code></td>
<td>
<p>A matrix with rows of computed loss values of each id across all models
as columns.</p>
</td></tr>
<tr><td><code id="check_df_+3A_data">data</code></td>
<td>
<p>A data.table with data. See <code><a href="#topic+trajectories">trajectories</a></code>.</p>
</td></tr>
<tr><td><code id="check_df_+3A_maxdf">maxdf</code></td>
<td>
<p>Fitting parameters. See <code><a href="#topic+trajectories">trajectories</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When a group has insufficient data for <code>maxdf</code>, its nearest model loss
values are set to <code>Inf</code>, and new nearest model is assigned. The check
repeats until all groups have sufficient data.
</p>


<h3>Value</h3>

<p>Returns the vector of group membership of id's either unchanged or changed
to have sufficient data in non-zero groups.
</p>

<hr>
<h2 id='clustra'>Cluster longitudinal trajectories over time</h2><span id='topic+clustra'></span>

<h3>Description</h3>

<p>The usual top level function for clustering longitudinal trajectories. After
initial setup, it calls <code><a href="#topic+trajectories">trajectories</a></code> to perform k-means
clustering on continuous <code>response</code> measured over <code>time</code>, where each mean
is defined by a thin plate spline fit to all points in a cluster. See
<code>clustra_vignette.Rmd</code> for examples of use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustra(
  data,
  k,
  starts = "random",
  maxdf = 30,
  conv = c(10, 0),
  mccores = 1,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clustra_+3A_data">data</code></td>
<td>
<p>Data frame or, preferably, also a data.table with response measurements, one
response per observation. Required variables are (id, time, response).
Other variables are ignored.</p>
</td></tr>
<tr><td><code id="clustra_+3A_k">k</code></td>
<td>
<p>Number of clusters</p>
</td></tr>
<tr><td><code id="clustra_+3A_starts">starts</code></td>
<td>
<p>One of c(&quot;random&quot;, &quot;distant&quot;) or an integer vector
with values 1:k corresponding to unique ids of starting cluster assignments.
For &quot;random&quot;, starting clusters are assigned
at random.
For &quot;distant&quot;, a FastMap-like algorithm selects k distant ids to
which TPS models are fit and used as starting cluster centers to which ids
are classified. Only id with more than median number of time points are
used. Distance from an id to a TPS model is median absolute difference
at id time points. Starting with a random id, distant ids are selected
sequentially as the id with the largest minimum absolute distance to
previous selections (a maximin concept). The first random selection is
discarded and the next k selected ids are kept. Their TPS fits become the
first cluster centers to
which all ids are classified. See comments in code and
DOI: 10.1109/TPAMI.2005.164 for the FastMap analogy.</p>
</td></tr>
<tr><td><code id="clustra_+3A_maxdf">maxdf</code></td>
<td>
<p>Fitting parameters. See <code><a href="#topic+trajectories">trajectories</a></code>.</p>
</td></tr>
<tr><td><code id="clustra_+3A_conv">conv</code></td>
<td>
<p>Fitting parameters. See <code><a href="#topic+trajectories">trajectories</a></code>.</p>
</td></tr>
<tr><td><code id="clustra_+3A_mccores">mccores</code></td>
<td>
<p>See <code><a href="#topic+trajectories">trajectories</a></code>.</p>
</td></tr>
<tr><td><code id="clustra_+3A_verbose">verbose</code></td>
<td>
<p>Logical to turn on more output during fit iterations.</p>
</td></tr>
<tr><td><code id="clustra_+3A_...">...</code></td>
<td>
<p>Additional parameters of optional plotting under <code>verbose = 2</code>. At this time,
only <code>xlim</code> and <code>ylim</code> are allowed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list returned by <code><a href="#topic+trajectories">trajectories</a></code> plus one more element <code>ido</code>,
giving the original id numbers is invisibly returned. Invisible returns are
useful for repeated runs that explore verbose clustra output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(13)
data = gen_traj_data(n_id = c(50, 100), types = c(1, 2), 
                     intercepts = c(100, 80), m_obs = 20, 
                     s_range = c(-365, -14), e_range = c(0.5*365, 2*365))
cl = clustra(data, k = 2, maxdf = 20, conv = c(5, 0), verbose = TRUE)
tabulate(data$group)
tabulate(data$true_group)

</code></pre>

<hr>
<h2 id='clustra_rand'>clustra_rand: Rand Index cluster evaluation</h2><span id='topic+clustra_rand'></span>

<h3>Description</h3>

<p>Performs <code><a href="#topic+trajectories">trajectories</a></code> runs for several <em>k</em> and several random
start replicates within <em>k</em>. Returns a data frame with a Rand Index
comparison between all pairs of clusterings. This data frame is typically
input to <code><a href="#topic+rand_plot">rand_plot</a></code> to produce a heat map with the Adjusted
Rand Index results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustra_rand(
  data,
  k,
  starts = "random",
  mccores = 1,
  replicates = 10,
  maxdf = 30,
  conv = c(10, 0),
  save = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clustra_rand_+3A_data">data</code></td>
<td>
<p>The data (see <code><a href="#topic+clustra">clustra</a></code> description).</p>
</td></tr>
<tr><td><code id="clustra_rand_+3A_k">k</code></td>
<td>
<p>Vector of k values to try.</p>
</td></tr>
<tr><td><code id="clustra_rand_+3A_starts">starts</code></td>
<td>
<p>See <code><a href="#topic+clustra">clustra</a></code>.</p>
</td></tr>
<tr><td><code id="clustra_rand_+3A_mccores">mccores</code></td>
<td>
<p>Number of cores for replicate parallelism via mclapply.</p>
</td></tr>
<tr><td><code id="clustra_rand_+3A_replicates">replicates</code></td>
<td>
<p>Number of replicates for each k.</p>
</td></tr>
<tr><td><code id="clustra_rand_+3A_maxdf">maxdf</code></td>
<td>
<p>Fitting parameters. See <code>link{trajectories}</code>.</p>
</td></tr>
<tr><td><code id="clustra_rand_+3A_conv">conv</code></td>
<td>
<p>Fitting parameters. See <code>link{trajectories}</code>.</p>
</td></tr>
<tr><td><code id="clustra_rand_+3A_save">save</code></td>
<td>
<p>Logical. When TRUE, save all results as file <code>results.Rdata</code>.</p>
</td></tr>
<tr><td><code id="clustra_rand_+3A_verbose">verbose</code></td>
<td>
<p>Logical. When TRUE, information about each run of clustra (but not iterations
within) is printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <code><a href="#topic+allpair_RandIndex">allpair_RandIndex</a></code>.
</p>

<hr>
<h2 id='clustra_sil'>clustra_sil: Prepare silhouette plot data for several k or for a previous
clustra run</h2><span id='topic+clustra_sil'></span>

<h3>Description</h3>

<p>Performs <code><a href="#topic+clustra">clustra</a></code> runs for several k and prepares silhouette
plot data. Computes a proxy silhouette index based on distances to cluster
centers rather than trajectory pairs. The cost is essentially that of
running clustra for several k as this information is available directly from
clustra. Can also reuse a previous clustra run and produce data for a single
silhouette plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustra_sil(
  data,
  kv = NULL,
  starts = "random",
  mccores = 1,
  maxdf = 30,
  conv = c(10, 0),
  save = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clustra_sil_+3A_data">data</code></td>
<td>
<p>A data.frame (see the <code>data</code> parameter of <code><a href="#topic+trajectories">trajectories</a></code>).
Alternatively, the output from a completed <code>clustra</code> run can be used, in
which case <code>kv</code> is left as <code>NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="clustra_sil_+3A_kv">kv</code></td>
<td>
<p>Vector of <code>clustra</code> <code>k</code> values to run. If <code>data</code> is the output from a
completed <code>clustra</code> run, leave <code>kv</code> as NULL.</p>
</td></tr>
<tr><td><code id="clustra_sil_+3A_starts">starts</code></td>
<td>
<p>See <code><a href="#topic+clustra">clustra</a></code>.</p>
</td></tr>
<tr><td><code id="clustra_sil_+3A_mccores">mccores</code></td>
<td>
<p>See <code><a href="#topic+trajectories">trajectories</a></code>.</p>
</td></tr>
<tr><td><code id="clustra_sil_+3A_maxdf">maxdf</code></td>
<td>
<p>Fitting parameters. See <code><a href="#topic+trajectories">trajectories</a></code>.</p>
</td></tr>
<tr><td><code id="clustra_sil_+3A_conv">conv</code></td>
<td>
<p>Fitting parameters. See <code><a href="#topic+trajectories">trajectories</a></code>.</p>
</td></tr>
<tr><td><code id="clustra_sil_+3A_save">save</code></td>
<td>
<p>Logical. When TRUE, save all results as file <code>clustra_sil.Rdata</code>.</p>
</td></tr>
<tr><td><code id="clustra_sil_+3A_verbose">verbose</code></td>
<td>
<p>Logical. When TRUE, information about each run of clustra is printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When given the raw data as the first parameter (input <code>data</code> parameter of
<code><a href="#topic+trajectories">trajectories</a></code>), <code>kv</code> specifies a vector of <code>k</code> parameters for
<code>clustra</code> and produces data for silhouette plots of each of them.
Alternatively, the input can be the output from a single <code>clustra</code> run, in
which case data for a single silhouette plot will be made without running
<code>clustra</code>.
</p>


<h3>Value</h3>

<p>Invisibly returns a list of length <code>length(kv)</code>, where each element is
a matrix with <code>nrow(data)</code> rows and three columns <code>cluster</code>, <code>neighbor</code>,
<code>silhouette</code>. The matrix in each element of this list can be used to draw a
silhouette plot. When the input was a completed <code>clustra</code> run, the output is a
list with a single element for a single silhouette plot.
</p>

<hr>
<h2 id='deltime'>Timing function</h2><span id='topic+deltime'></span><span id='topic+deltimeT'></span>

<h3>Description</h3>

<p>Timing function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deltime(ltime = proc.time()["elapsed"], text = NULL, units = FALSE, nl = FALSE)

deltimeT(ltime, text)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deltime_+3A_ltime">ltime</code></td>
<td>
<p>Result of last call to deltime.</p>
</td></tr>
<tr><td><code id="deltime_+3A_text">text</code></td>
<td>
<p>Text to display along with elapsed time since <code>ltime</code>.</p>
</td></tr>
<tr><td><code id="deltime_+3A_units">units</code></td>
<td>
<p>Logical. If TRUE, print units</p>
</td></tr>
<tr><td><code id="deltime_+3A_nl">nl</code></td>
<td>
<p>Logical. If TRUE, a newline is added at the end.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>&quot;elapsed&quot; component of current <code><a href="base.html#topic+proc.time">proc.time</a></code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>deltimeT()</code>: A shortcut frequent use. Requires ltime and text
parameters, includes units, and adds a newline after message.
</p>
</li></ul>

<hr>
<h2 id='gen_traj_data'>Data Generators</h2><span id='topic+gen_traj_data'></span>

<h3>Description</h3>

<p>Generates a collection of longitudinal responses with possibly varying
lengths and varying numbers of observations. Support is
<code>start</code> . . . 0 . . . <code>end</code>, where
<code>start</code>~uniform(s_range) and <code>end</code>~uniform(e_range), so that
all trajectories are aligned at 0 but can start and end at different times.
Zero is the intervention time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_traj_data(
  n_id,
  types,
  intercepts,
  m_obs,
  s_range,
  e_range,
  noise = c(0, abs(mean(intercepts)/20)),
  min_obs = 3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_traj_data_+3A_n_id">n_id</code></td>
<td>
<p>Vector whose length is the number of clusters, giving the number of id's to
generate in each cluster.</p>
</td></tr>
<tr><td><code id="gen_traj_data_+3A_types">types</code></td>
<td>
<p>A vector of integers from <code>c(1, 2, 3)</code> of same length as n_id, indicating
curve type: constant, sine portion, sigmoid portion, respectively.</p>
</td></tr>
<tr><td><code id="gen_traj_data_+3A_intercepts">intercepts</code></td>
<td>
<p>A vector of first responses at minimum time for the curve base vectors of
same length as n_id. Each <code>type</code>-<code>intercept</code> combination should be unique for
unique clusters.</p>
</td></tr>
<tr><td><code id="gen_traj_data_+3A_m_obs">m_obs</code></td>
<td>
<p>Mean number of observation per id. Provides <code>lambda</code> parameter in
<code><a href="stats.html#topic+rpois">rpois</a></code>.</p>
</td></tr>
<tr><td><code id="gen_traj_data_+3A_s_range">s_range</code></td>
<td>
<p>A vector of length 2, giving the min and max limits of uniformly generated
start observation time.</p>
</td></tr>
<tr><td><code id="gen_traj_data_+3A_e_range">e_range</code></td>
<td>
<p>A vector of length 2, giving the min and max limits of uniformly generated
end observation time.</p>
</td></tr>
<tr><td><code id="gen_traj_data_+3A_noise">noise</code></td>
<td>
<p>Vector of length 2 giving the <em>mean</em> and <em>sd</em> of added N(mean, sd) noise.</p>
</td></tr>
<tr><td><code id="gen_traj_data_+3A_min_obs">min_obs</code></td>
<td>
<p>Minimum number of observations in addition to zero time observation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data table with one response per row and four columns:
<code>id</code>, <code>time</code>, <code>response</code>, and <code>true_group</code>.
</p>


<h3>Details</h3>

<p>Generate longitudinal data for a response variable. Trajectories start
at time uniformly distributed in s_range and end at time uniformly
distributed in e_range. Number of observations in a trajectory is
Poisson(m_obs). The result is a number of trajectories, all starting at
time 0, with different time spans, and with independently different numbers
of observations within the time spans. Each trajectory follows one of three
possible response functions possibly with a different mean and with added
N(mean, sd) error.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = gen_traj_data(n_id = c(50, 100), types = c(1, 2), 
  intercepts = c(100, 80), m_obs = 20, s_range = c(-365, -14), 
  e_range = c(0.5*365, 2*365))
head(data)
tail(data)

</code></pre>

<hr>
<h2 id='gendata'>gendata</h2><span id='topic+gendata'></span>

<h3>Description</h3>

<p>Generates data for up to three trajectory clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gendata(n_id, types, intercepts, m_obs, s_range, e_range, min_obs, noise)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gendata_+3A_n_id">n_id</code></td>
<td>
<p>See parameters of <code><a href="#topic+gen_traj_data">gen_traj_data</a></code>.</p>
</td></tr>
<tr><td><code id="gendata_+3A_types">types</code></td>
<td>
<p>See parameters of <code><a href="#topic+gen_traj_data">gen_traj_data</a></code>.</p>
</td></tr>
<tr><td><code id="gendata_+3A_intercepts">intercepts</code></td>
<td>
<p>See parameters of <code><a href="#topic+gen_traj_data">gen_traj_data</a></code>.</p>
</td></tr>
<tr><td><code id="gendata_+3A_m_obs">m_obs</code></td>
<td>
<p>See parameters of <code><a href="#topic+gen_traj_data">gen_traj_data</a></code>.</p>
</td></tr>
<tr><td><code id="gendata_+3A_s_range">s_range</code></td>
<td>
<p>See parameters of <code><a href="#topic+gen_traj_data">gen_traj_data</a></code>.</p>
</td></tr>
<tr><td><code id="gendata_+3A_e_range">e_range</code></td>
<td>
<p>See parameters of <code><a href="#topic+gen_traj_data">gen_traj_data</a></code>.</p>
</td></tr>
<tr><td><code id="gendata_+3A_min_obs">min_obs</code></td>
<td>
<p>See parameters of <code><a href="#topic+gen_traj_data">gen_traj_data</a></code>.</p>
</td></tr>
<tr><td><code id="gendata_+3A_noise">noise</code></td>
<td>
<p>See parameters of <code><a href="#topic+gen_traj_data">gen_traj_data</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Time support of each <code>id</code> is at least <code style="white-space: pre;">&#8288;s . . . 0 . . . . e&#8288;</code>, where <code>s</code> is in
<code>s_range</code> and <code>e</code> is in <code>e_range</code>.
</p>


<h3>Value</h3>

<p>A list of length <code>sum(n_id)</code>, where each element is a matrix output by <code><a href="#topic+oneid">oneid</a></code>.
</p>

<hr>
<h2 id='ic_fun'>Function to test information criteria. Not exported and used by internal
function <code>kchoose</code>.</h2><span id='topic+ic_fun'></span>

<h3>Description</h3>

<p>Function to test information criteria. Not exported and used by internal
function <code>kchoose</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ic_fun(cl, data, fn)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ic_fun_+3A_cl">cl</code></td>
<td>
<p>Output from <code>clustra</code> function.</p>
</td></tr>
<tr><td><code id="ic_fun_+3A_data">data</code></td>
<td>
<p>A valid data set for <code>clustra</code>.</p>
</td></tr>
<tr><td><code id="ic_fun_+3A_fn">fn</code></td>
<td>
<p>Character file name for output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numerical value of computed AIC. Also writes a line of computed information
criteria to <code>fn</code> file for each k.
</p>

<hr>
<h2 id='kchoose'>A test function to evaluate information criteria for several k values. Not
exported and only for debugging internal use.</h2><span id='topic+kchoose'></span>

<h3>Description</h3>

<p>A test function to evaluate information criteria for several k values. Not
exported and only for debugging internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kchoose(K, var = 5, maxdf = 10, mc = 1, fn = "ic.txt")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kchoose_+3A_k">K</code></td>
<td>
<p>Integer vector of k values to try.</p>
</td></tr>
<tr><td><code id="kchoose_+3A_var">var</code></td>
<td>
<p>A numerical value of noise variance in generated data.</p>
</td></tr>
<tr><td><code id="kchoose_+3A_maxdf">maxdf</code></td>
<td>
<p>Fitting parameters. See <code><a href="#topic+trajectories">trajectories</a></code>.</p>
</td></tr>
<tr><td><code id="kchoose_+3A_mc">mc</code></td>
<td>
<p>Number of cores to use. Increase up to largest k, or number of cores
available, whichever is less. (On hyperthreaded cores, up to 2x number of
cores.)</p>
</td></tr>
<tr><td><code id="kchoose_+3A_fn">fn</code></td>
<td>
<p>Character file name for output.</p>
</td></tr>
</table>

<hr>
<h2 id='mse_g'>Various Loss functions used internally by clustra</h2><span id='topic+mse_g'></span><span id='topic+mae_g'></span><span id='topic+mme_g'></span><span id='topic+mxe_g'></span>

<h3>Description</h3>

<p>Various Loss functions used internally by clustra
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mse_g(pred, id, response)

mae_g(pred, id, response)

mme_g(pred, id, response)

mxe_g(pred, id, response)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mse_g_+3A_pred">pred</code></td>
<td>
<p>Vector of predicted values.</p>
</td></tr>
<tr><td><code id="mse_g_+3A_id">id</code></td>
<td>
<p>Integer vector of group assignments.</p>
</td></tr>
<tr><td><code id="mse_g_+3A_response">response</code></td>
<td>
<p>Vector of response values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value. For mse_g(), returns the mean-squared error. For mae_g(),
returns mean absolute error. For mme_g(), returns median absolute error.
For mxe_g(), returns the
maximum absolute error.
</p>

<hr>
<h2 id='oneid'>Generates data for one <code>id</code></h2><span id='topic+oneid'></span>

<h3>Description</h3>

<p>Generates data for one <code>id</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneid(id, n_obs, type, intercept, start, end, smin, emax, noise)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oneid_+3A_id">id</code></td>
<td>
<p>A unique integer.</p>
</td></tr>
<tr><td><code id="oneid_+3A_n_obs">n_obs</code></td>
<td>
<p>An integer number of observations to produce.</p>
</td></tr>
<tr><td><code id="oneid_+3A_type">type</code></td>
<td>
<p>Response type, 1 is constant, 2 is a sin curve portion, and 3 is a sigmoid
portion.</p>
</td></tr>
<tr><td><code id="oneid_+3A_intercept">intercept</code></td>
<td>
<p>Used to set response at <code>smin</code> time value (not 0) and shift all responses
accordingly.</p>
</td></tr>
<tr><td><code id="oneid_+3A_start">start</code></td>
<td>
<p>Negative integer giving time of first observation.</p>
</td></tr>
<tr><td><code id="oneid_+3A_end">end</code></td>
<td>
<p>Positive integer giving time of last observation.</p>
</td></tr>
<tr><td><code id="oneid_+3A_smin">smin</code></td>
<td>
<p>The smallest possible <code>start</code> value among all <code>id</code>s. Used to align with
intercept and then dropped.</p>
</td></tr>
<tr><td><code id="oneid_+3A_emax">emax</code></td>
<td>
<p>The largest possible <code>end</code> value among all <code>id</code>s. Used to scale sin and
sigmoid support.</p>
</td></tr>
<tr><td><code id="oneid_+3A_noise">noise</code></td>
<td>
<p>Standard deviation of zero mean Gaussian noise added to response functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>n_obs</code> by 4 matrix with columns <code>id</code>, <code>time</code>, <code>response</code>, <code>true_group</code>.
</p>

<hr>
<h2 id='plot_sample'>Plots a sample of ids in a small mutiples layout</h2><span id='topic+plot_sample'></span>

<h3>Description</h3>

<p>Plots a sample of ids in a small mutiples layout
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_sample(dat, layout = c(3, 3), sample = prod(layout), group = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_sample_+3A_dat">dat</code></td>
<td>
<p>A data frame with a few id trajectories to plot.</p>
</td></tr>
<tr><td><code id="plot_sample_+3A_layout">layout</code></td>
<td>
<p>The small multiples layout as c(rows, columns).</p>
</td></tr>
<tr><td><code id="plot_sample_+3A_sample">sample</code></td>
<td>
<p>If zero, all data in dat are displayed. If &gt;0 a sample of that many data
points from dat are displayed.</p>
</td></tr>
<tr><td><code id="plot_sample_+3A_group">group</code></td>
<td>
<p>If not NULL, a character string giving the variable name in data that should
color the data points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the number of trajectories plotted.
</p>

<hr>
<h2 id='plot_silhouette'>Plots a list item, a silhouette, from the result of <code>clustra_sil</code> along
with the average silhouette value. Typically used via
<code>lapply(list, plot_silhouette)</code></h2><span id='topic+plot_silhouette'></span>

<h3>Description</h3>

<p>Plots a list item, a silhouette, from the result of <code>clustra_sil</code> along
with the average silhouette value. Typically used via
<code>lapply(list, plot_silhouette)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_silhouette(sil)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_silhouette_+3A_sil">sil</code></td>
<td>
<p>A data frame that is a list item returned by <code>clustra_sil</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns invisibly the average silhouette value.
</p>

<hr>
<h2 id='plot_smooths'>plot_smooths</h2><span id='topic+plot_smooths'></span>

<h3>Description</h3>

<p>Plots data and smooths from <code>clustra</code> output or internally from within
<code>start_groups()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_smooths(
  data,
  fits = NULL,
  max.data = 1e+05,
  select.data = NULL,
  group = "group",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_smooths_+3A_data">data</code></td>
<td>
<p>The data. If after <code>clustra</code> run, it includes resulting clusters as group.</p>
</td></tr>
<tr><td><code id="plot_smooths_+3A_fits">fits</code></td>
<td>
<p>The <code>tps</code> component of <code>clustra</code> output or internal <code>start_groups</code> fits.
If fits are supplied and <code>select.data</code> is NULL, the data is colored by
clusters. If NULL, or if <code>select.data</code> is not NULL, the data is black points.</p>
</td></tr>
<tr><td><code id="plot_smooths_+3A_max.data">max.data</code></td>
<td>
<p>The maximum number of data points to plot. If zero,
no points are plotted (overrides select.data). Use <code>Inf</code> value to plot all
points.</p>
</td></tr>
<tr><td><code id="plot_smooths_+3A_select.data">select.data</code></td>
<td>
<p>Either NULL or a list of length k, each element a data.frame (like data)
with time and response components. The select.data points will be
highlighted with cluster colors on the plot. This is used internally in the
<code>start_groups</code> function to show the selected starting points. In this case,
also the <code>fits</code> parameter can contain TPS fits to the starting points.</p>
</td></tr>
<tr><td><code id="plot_smooths_+3A_group">group</code></td>
<td>
<p>Character variable name in <code>data</code> to color the clusters. A NULL will produce
a b&amp;w point plot.</p>
</td></tr>
<tr><td><code id="plot_smooths_+3A_...">...</code></td>
<td>
<p>Other parameters to <code>plot</code> function, such as <code>xlim</code> or <code>ylim</code> axis limits.</p>
</td></tr>
</table>

<hr>
<h2 id='pred_g'>Function to predict for new data based on fitted gam object.</h2><span id='topic+pred_g'></span>

<h3>Description</h3>

<p>Function to predict for new data based on fitted gam object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred_g(tps, newdata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pred_g_+3A_tps">tps</code></td>
<td>
<p>Output structure of <code><a href="mgcv.html#topic+bam">bam</a></code>.</p>
</td></tr>
<tr><td><code id="pred_g_+3A_newdata">newdata</code></td>
<td>
<p>See <code><a href="#topic+clustra">clustra</a></code> description of data parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of predicted values corresponding to rows of newdata.
If gam object is NULL, NULL is returned instead.
</p>

<hr>
<h2 id='rand_plot'>Matrix plot of Rand Index comparison of replicated clusters</h2><span id='topic+rand_plot'></span>

<h3>Description</h3>

<p>Matrix plot of Rand Index comparison of replicated clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rand_plot(rand_pairs, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rand_plot_+3A_rand_pairs">rand_pairs</code></td>
<td>
<p>A data frame result of <code><a href="#topic+allpair_RandIndex">allpair_RandIndex</a></code></p>
</td></tr>
<tr><td><code id="rand_plot_+3A_name">name</code></td>
<td>
<p>Character string file name for pdf plot. If omitted or NULL, plot will
render to current graphics device.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible. Full path name of file with plot.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen and George Ostrouchov
</p>


<h3>References</h3>

<p>Wei-chen Chen, George Ostrouchov, David Pugmire, Prabhat, and Michael Wehner.
2013. A Parallel EM Algorithm for Model-Based Clustering Applied to the
Exploration of Large Spatio-Temporal Data. Technometrics, 55:4, 513-523.
</p>
<p>Sorts replicates within cluster K
Assumes K starts from 2
</p>

<hr>
<h2 id='start_groups'>Function to assign starting groups.</h2><span id='topic+start_groups'></span>

<h3>Description</h3>

<p>Either a random assignment of k approximately equal size clusters or a
FastMap-like algorithm that sequentially selects k distant ids
from those that have more than the median number of observations. TPS fits
to these ids are used as cluster centers for a starting group assignment.
A user supplied starting assignment is also possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>start_groups(k, data, starts, maxdf, conv, mccores = 1, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="start_groups_+3A_k">k</code></td>
<td>
<p>Number of clusters (groups).</p>
</td></tr>
<tr><td><code id="start_groups_+3A_data">data</code></td>
<td>
<p>Data.table with response measurements, one per observation.
Column names are id, time, response, group. Note that <code>id</code>s are assumed
sequential starting from 1. This affects expanding group numbers to ids.</p>
</td></tr>
<tr><td><code id="start_groups_+3A_starts">starts</code></td>
<td>
<p>Type of start groups generated. See <code><a href="#topic+clustra">clustra</a></code>.</p>
</td></tr>
<tr><td><code id="start_groups_+3A_maxdf">maxdf</code></td>
<td>
<p>Fitting parameters. See <code><a href="#topic+trajectories">trajectories</a></code>.</p>
</td></tr>
<tr><td><code id="start_groups_+3A_conv">conv</code></td>
<td>
<p>Fitting parameters. See <code><a href="#topic+trajectories">trajectories</a></code>.</p>
</td></tr>
<tr><td><code id="start_groups_+3A_mccores">mccores</code></td>
<td>
<p>See <code><a href="#topic+trajectories">trajectories</a></code>.</p>
</td></tr>
<tr><td><code id="start_groups_+3A_verbose">verbose</code></td>
<td>
<p>Turn on more output for debugging. Values 0, 1, 2, 3 add more output. 2 and
3 produce graphs during iterations - use carefully!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector corresponding to unique <code>id</code>s, giving group number
assignments.
</p>
<p>For <code>distant</code>, each sequential selection takes an id that has the largest
minimum distance from smooth TPS fits (&lt;= 5 deg) of previous selections.
The distance of an id to a single TPS is the median absolute error across
the id time points. Distance of an id to a set of TPS is the minimum of
the individual distances. We pick the id that has the maximum of such
a minimum of medians.
</p>

<hr>
<h2 id='tps_g'>Fits a thin plate spline to a single group with
<code><a href="mgcv.html#topic+bam">bam</a></code>.</h2><span id='topic+tps_g'></span>

<h3>Description</h3>

<p>Fits a thin plate spline to a single group (one list element) in data with
<code><a href="mgcv.html#topic+bam">bam</a></code>. Uses data from only one group rather than a
zero weights approach. Zero weights would result in
incorrect crossvalidation sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tps_g(g, data, maxdf, nthreads)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tps_g_+3A_g">g</code></td>
<td>
<p>Integer group number.</p>
</td></tr>
<tr><td><code id="tps_g_+3A_data">data</code></td>
<td>
<p>A list of group-separated data using lapply with
<code>data.table::copy(data[group == g])</code> from original data in
<code><a href="#topic+clustra">clustra</a></code> description.</p>
</td></tr>
<tr><td><code id="tps_g_+3A_maxdf">maxdf</code></td>
<td>
<p>See <code><a href="#topic+trajectories">trajectories</a></code> description.</p>
</td></tr>
<tr><td><code id="tps_g_+3A_nthreads">nthreads</code></td>
<td>
<p>Controls <code><a href="mgcv.html#topic+bam">bam</a></code> threads.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class &quot;gam&quot;. See <code><a href="mgcv.html#topic+bam">bam</a></code> value.
If group data has zero rows, NULL is returned instead.
</p>

<hr>
<h2 id='traj_rep'>Function to run trajectories inside mclapply with one core.</h2><span id='topic+traj_rep'></span>

<h3>Description</h3>

<p>Function to run trajectories inside mclapply with one core.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traj_rep(group, data, k, maxdf, conv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="traj_rep_+3A_group">group</code></td>
<td>
<p>Vector of starting group values for unique id's.</p>
</td></tr>
<tr><td><code id="traj_rep_+3A_data">data</code></td>
<td>
<p>The data (see <code><a href="#topic+clustra">clustra</a></code> description).</p>
</td></tr>
<tr><td><code id="traj_rep_+3A_k">k</code></td>
<td>
<p>Integer number of clusters.</p>
</td></tr>
<tr><td><code id="traj_rep_+3A_maxdf">maxdf</code></td>
<td>
<p>Fitting parameters. See <code><a href="#topic+trajectories">trajectories</a></code>.</p>
</td></tr>
<tr><td><code id="traj_rep_+3A_conv">conv</code></td>
<td>
<p>Fitting parameters. See <code><a href="#topic+trajectories">trajectories</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See return of <code><a href="#topic+trajectories">trajectories</a></code>.
</p>

<hr>
<h2 id='trajectories'>Cluster longitudinal trajectories over time.</h2><span id='topic+trajectories'></span>

<h3>Description</h3>

<p>Performs k-means clustering on continuous <code>response</code> measured over <code>time</code>,
where each mean is defined by a thin plate spline fit to all points in a
cluster. Typically, this function is called by <code><a href="#topic+clustra">clustra</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trajectories(
  data,
  k,
  group,
  maxdf,
  conv = c(10, 0),
  mccores = 1,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trajectories_+3A_data">data</code></td>
<td>
<p>Data table or data frame with response measurements, one per observation.
Column names are <code>id</code>, <code>time</code>, <code>response</code>, <code>group</code>. Note that
<code>id</code>s must be sequential starting from 1. This affects expanding group
numbers to <code>id</code>s.</p>
</td></tr>
<tr><td><code id="trajectories_+3A_k">k</code></td>
<td>
<p>Number of clusters (groups)</p>
</td></tr>
<tr><td><code id="trajectories_+3A_group">group</code></td>
<td>
<p>Vector of initial group numbers corresponding to <code>id</code>s.</p>
</td></tr>
<tr><td><code id="trajectories_+3A_maxdf">maxdf</code></td>
<td>
<p>Integer. Basis dimension of smooth term. See <code><a href="mgcv.html#topic+s">s</a></code> function
parameter <code>k</code>, in package <code>mgcv</code>.</p>
</td></tr>
<tr><td><code id="trajectories_+3A_conv">conv</code></td>
<td>
<p>A vector of length two, <code>c(iter, minchange)</code>, where <code>iter</code> is the maximum
number of EM iterations and <code>minchange</code> is the minimum percentage of subjects
changing group to continue iterations. Setting <code>minchange</code> to zero continues
iterations until no more changes occur or <code>maxiter</code> is reached.</p>
</td></tr>
<tr><td><code id="trajectories_+3A_mccores">mccores</code></td>
<td>
<p>Integer number of cores to use by <code>mclapply</code> sections. Parallelization is
over <code>k</code>, the number of clusters.</p>
</td></tr>
<tr><td><code id="trajectories_+3A_verbose">verbose</code></td>
<td>
<p>Logical, whether to produce debug output. A value &gt; 1 will plot tps fit lines
in each iteration.</p>
</td></tr>
<tr><td><code id="trajectories_+3A_...">...</code></td>
<td>
<p>See <code><a href="#topic+clustra">clustra</a></code> for allowed <code>...</code> parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>

<ul>
<li> <p><code>deviance</code> - The final deviance in each cluster added across clusters.
</p>
</li>
<li> <p><code>group</code> - Integer vector of group assignments corresponding to unique <code>id</code>s.
</p>
</li>
<li> <p><code>loss</code> - Numeric matrix with rows corresponding to unique <code>id</code>s and one
column for each cluster. Each entry is the mean squared loss for the data in
the <code>id</code> relative to the cluster model.
</p>
</li>
<li> <p><code>k</code> - An integer giving the requested number of clusters.
</p>
</li>
<li> <p><code>k_cl</code> - An integer giving the converged number of clusters. Can be
smaller than <code>k</code> when some clusters become too small for degrees of freedom
during convergence.
</p>
</li>
<li> <p><code>data_group</code> - An integer vector, giving group assignment as expanded into
all <code>id</code> time points.
</p>
</li>
<li> <p><code>tps</code> - A list with <code>k_cl</code> elements, each an object returned by the
<code>mgcv::bam</code> fit of a cluster thin plate spline model.
</p>
</li>
<li> <p><code>iterations</code> - An integer giving the number of iterations taken.
</p>
</li>
<li> <p><code>counts</code> - An integer vector giving the number of <code>id</code>s in each cluster.
</p>
</li>
<li> <p><code>counts_df</code> - An integer vector giving the total number of observations in
each cluster (sum of the number of observations for <code>id</code>s belonging to the
cluster).
</p>
</li>
<li> <p><code>changes</code> - An integer, giving the number of <code>id</code>s that changed clusters in
the last iteration. This is zero if converged.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>George Ostrouchov and David Gagnon
</p>

<hr>
<h2 id='xit_report'>xit_report</h2><span id='topic+xit_report'></span>

<h3>Description</h3>

<p>Examines trajectories output to name what was concluded, such as
convergence, maximum iterations reached, a zero cluster, etc. Multiple
conclusions are possible as not all are mutually exclusive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xit_report(cl, maxdf, conv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xit_report_+3A_cl">cl</code></td>
<td>
<p>Output structure from <code><a href="#topic+trajectories">trajectories</a></code> function</p>
</td></tr>
<tr><td><code id="xit_report_+3A_maxdf">maxdf</code></td>
<td>
<p>Fitting parameters. See <code><a href="#topic+trajectories">trajectories</a></code>.</p>
</td></tr>
<tr><td><code id="xit_report_+3A_conv">conv</code></td>
<td>
<p>Fitting parameters. See <code><a href="#topic+trajectories">trajectories</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL or a character vector of exit criteria satisfied.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
