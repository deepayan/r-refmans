<!DOCTYPE html><html lang="en"><head><title>Help for package MCMC.qpcr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MCMC.qpcr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#amp.eff'>
<p>amplification efficiencies and experimental Cq1 (optional column)</p></a></li>
<li><a href='#beckham.data'>
<p>Cellular heat stress response data.</p></a></li>
<li><a href='#beckham.eff'>
<p>amplification efficiencies for beckham.data</p></a></li>
<li><a href='#coral.stress'>
<p>RT-qPCR of stress response in coral Porites astreoides</p></a></li>
<li><a href='#cq2counts'>
<p>Prepares qRT-PCR data for mcmc.qpcr analysis</p></a></li>
<li><a href='#cq2genorm'>
<p>Reformats raw Ct data for geNorm analysis (non-parametric selection of</p>
stable control genes) as implemented in selectHKgenes function (package SLqPCR)</a></li>
<li><a href='#cq2log'>
<p>Prepares qRT-PCR data for mcmc.qpcr analysis using lognormal and &quot;classic&quot; (normalization-based) models</p></a></li>
<li><a href='#diagnostic.mcmc'>
<p>Plots three diagnostic plots to check the validity of the assumptions of linear model analysis.</p></a></li>
<li><a href='#dilutions'>
<p>Data to determine amplification efficiency</p></a></li>
<li><a href='#getNormalizedData'>
<p>Extracts qPCR model predictions</p></a></li>
<li><a href='#HPDplot'>
<p>Plotting fixed effects for all genes for a single combination of factors</p></a></li>
<li><a href='#HPDplotBygene'>
<p>Plots qPCR analysis results for individual genes.</p></a></li>
<li><a href='#HPDplotBygeneBygroup'>
<p>Plots qPCR analysis results for individual genes</p></a></li>
<li><a href='#HPDpoints'>
<p>HPDplot, HPDpoints</p></a></li>
<li><a href='#HPDsummary'>
<p>Summarizes and plots results of mcmc.qpcr function series.</p></a></li>
<li><a href='#mcmc.converge.check'>
<p>MCMC diagnostic plots</p></a></li>
<li><a href='#mcmc.pval'>
<p>calculates p-value based on Bayesian z-score or MCMC sampling</p></a></li>
<li><a href='#mcmc.qpcr'>
<p>Analyzes qRT-PCR data using generalized linear mixed model</p></a></li>
<li><a href='#MCMC.qpcr-package'>
<p>Bayesian analysis of qRT-PCR data</p></a></li>
<li><a href='#mcmc.qpcr.classic'>
<p>Analyzes qRT-PCR data using &quot;classic&quot; model, based on multigene normalization.</p></a></li>
<li><a href='#mcmc.qpcr.lognormal'>
<p>Fits a lognormal linear mixed model to qRT-PCR data.</p></a></li>
<li><a href='#normalize.qpcr'>
<p>Internal function called by mcmc.qpcr.classic</p></a></li>
<li><a href='#outlierSamples'>
<p>detects outlier samples in qPCR data</p></a></li>
<li><a href='#padj.hpdsummary'>
<p>Adjusts p-values within an HPDsummary() object for multiple comparisons</p></a></li>
<li><a href='#padj.qpcr'>
<p>Calculates adjusted p-values corrected for multiple comparisons</p></a></li>
<li><a href='#PrimEff'>
<p>Determines qPCR amplification efficiencies from dilution series</p></a></li>
<li><a href='#softNorm'>
<p>Accessory function to mcmc.qpcr() to perform soft normalization</p></a></li>
<li><a href='#summaryPlot'>
<p>Wrapper function for ggplot2 to make bar and line graphs of</p>
mcmc.qpcr() results</a></li>
<li><a href='#trellisByGene'>
<p>For two-way designs, plots mcmc.qpcr model predictions gene by gene</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Analysis of qRT-PCR Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-03-27</td>
</tr>
<tr>
<td>Author:</td>
<td>Mikhail V. Matz</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mikhail V. Matz &lt;matz@utexas.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Quantitative RT-PCR data are analyzed using generalized linear mixed models based on lognormal-Poisson error distribution, fitted using MCMC. Control genes are not required but can be incorporated as Bayesian priors or, when template abundances correlate with conditions, as trackers of global effects (common to all genes). The package also implements a lognormal model for higher-abundance data and a "classic" model involving multi-gene normalization on a by-sample basis. Several plotting functions are included to extract and visualize results. The detailed tutorial is available here: <a href="https://matzlab.weebly.com/uploads/7/6/2/2/76229469/mcmc.qpcr.tutorial.v1.2.4.pdf">https://matzlab.weebly.com/uploads/7/6/2/2/76229469/mcmc.qpcr.tutorial.v1.2.4.pdf</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>MCMCglmm,ggplot2,coda</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-03-29 01:04:05 UTC; c-monstr</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-03-29 04:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='amp.eff'>
amplification efficiencies and experimental Cq1 (optional column)
</h2><span id='topic+amp.eff'></span>

<h3>Description</h3>

<p>Fold-amplification within each PCR cycle for each qRT-PCR assay. Determined by qPCR of
serial dilutions of the template (see Pfaffl 2001, Nucleic Acids Res 29:00)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(amp.eff)</code></pre>


<h3>Format</h3>

<p>A data frame with 17 observations on the following 3 variables.
</p>

<dl>
<dt><code>gene</code></dt><dd><p>a factor with levels <code>actin</code> <code>adk</code> <code>c3</code> <code>chrom</code> <code>clect</code> <code>eif3h</code> <code>g3pdh</code> <code>gsp2</code> <code>hsp16</code> <code>hsp60</code> <code>hsp90</code> <code>nd5</code> <code>r18s</code> <code>rpl11</code> <code>spon2</code> <code>tgoln</code> <code>ubl3</code></p>
</dd>
<dt><code>efficiency</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Cq1</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(amp.eff)
</code></pre>

<hr>
<h2 id='beckham.data'>
Cellular heat stress response data.
</h2><span id='topic+beckham.data'></span>

<h3>Description</h3>

<p>A typical qRT-PCR dataset where a series of treatments are compared to the global control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(beckham.data)</code></pre>


<h3>Format</h3>

<p>A data frame with 45 observations on the following 13 variables.
</p>

<dl>
<dt><code>sample</code></dt><dd><p>cDNA sample (biological replicate): a factor with levels <code>a</code> <code>b</code> <code>c</code> <code>d</code> <code>e</code> <code>f</code> <code>g</code> <code>h</code> <code>i</code> <code>j</code> <code>k</code> <code>l</code> <code>m</code> <code>n</code> <code>o</code></p>
</dd>
<dt><code>tr</code></dt><dd><p>treatment: a factor with levels <code>ctl</code>:control <code>hs</code>:heat stress <code>pshs</code>:pre-stress followed by heat stress</p>
</dd>
<dt><code>time</code></dt><dd><p>hours of heat stress exposure: a numeric vector</p>
</dd>
<dt><code>gapdh</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>hsp110</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>hspb</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>egr</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>gadd</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>dnajb1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>dnajb4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>atf</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>dnaja4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>fos</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Includes global control (ctl), heat stressed cells (hs), and cells pre-stressed by mild heating prior to heat stress (pshs).
Two time points: one hour and three hours.
</p>


<h3>Source</h3>

<p>data for Figure 6 in Beckham et al. Microarray analysis of cellular thermotolerance. 
Lasers Surg Med. 2010 Dec;42(10):752-65. doi: 10.1002/lsm.20983
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(beckham.data)
</code></pre>

<hr>
<h2 id='beckham.eff'>
amplification efficiencies for beckham.data
</h2><span id='topic+beckham.eff'></span>

<h3>Description</h3>

<p>amplification efficiencies for beckham.data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(beckham.eff)</code></pre>


<h3>Format</h3>

<p>A data frame with 11 observations on the following 2 variables.
</p>

<dl>
<dt><code>gene</code></dt><dd><p>a factor with levels <code>atf</code> <code>dnaja4</code> <code>dnajb1</code> <code>dnajb4</code> <code>egr</code> <code>fos</code> <code>gadd</code> <code>gapdh</code> <code>hsp110</code> <code>hspb</code> <code>r18s</code></p>
</dd>
<dt><code>eficiency</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Beckham et al. Microarray analysis of cellular thermotolerance. 
Lasers Surg Med. 2010 Dec;42(10):752-65. doi: 10.1002/lsm.20983
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(beckham.eff)
</code></pre>

<hr>
<h2 id='coral.stress'>
RT-qPCR of stress response in coral Porites astreoides
</h2><span id='topic+coral.stress'></span>

<h3>Description</h3>

<p>Timepoint one is one day of heat-light stress; timepoint two is recovery from it
the next day. Controls are the fragments never exposed to stress. Individual denotes
a coral colony that yielded several fragments for different treatments. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(coral.stress)</code></pre>


<h3>Format</h3>

<p>A data frame with 64 observations on the following 19 variables.
</p>

<dl>
<dt><code>sample</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>individual</code></dt><dd><p>a factor with levels <code>s1</code> <code>s12</code> <code>s13</code> <code>s15</code> <code>s2</code> <code>s4</code> <code>s5</code> <code>s8</code></p>
</dd>
<dt><code>condition</code></dt><dd><p>a factor with levels <code>control</code> <code>heat</code></p>
</dd>
<dt><code>timepoint</code></dt><dd><p>a factor with levels <code>one</code> <code>two</code></p>
</dd>
<dt><code>hsp16</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>actin</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>adk</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>c3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>chrom</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>clect</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>eif3h</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>g3pdh</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>gsp2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>hsp60</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>hsp90</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>nd5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>rpl11</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>spon2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>ubl3</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(coral.stress)
</code></pre>

<hr>
<h2 id='cq2counts'>
Prepares qRT-PCR data for mcmc.qpcr analysis
</h2><span id='topic+cq2counts'></span>

<h3>Description</h3>

<p>Converts Cq values into molecule counts,
and stacks the dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cq2counts(data, genecols, condcols, effic, Cq1 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cq2counts_+3A_data">data</code></td>
<td>

<p>Raw qRT-PCR dataset, one Cq column per gene, plus columns containing factors. The Cq 
columns, in addition to the proper Cq values, may contain NA (missing data) and -1, 
which means no amplification observed (i.e., zero target molecules at the start of qPCR 
reaction). 
Column headers are either gene names or factor names. 
Any number of fixed factors is allowed; any number of random factors that are gene-specific 
scalars (such as effect of genotype, or block)
Must have a column called &quot;sample&quot;, denoting individual cDNA preps.
Technical replicates should not be averaged, they should be represented as independent
rows with the same sample ID.
</p>
</td></tr>
<tr><td><code id="cq2counts_+3A_genecols">genecols</code></td>
<td>

<p>columns that contain Cq data
</p>
</td></tr>
<tr><td><code id="cq2counts_+3A_condcols">condcols</code></td>
<td>

<p>columns corresponding to factors, including &quot;sample&quot; factor
</p>
</td></tr>
<tr><td><code id="cq2counts_+3A_effic">effic</code></td>
<td>

<p>The PCR efficiency data for each of the analyzed genes. This is data frame with two columns:
gene name (must exactly match the headers of gene columns in Cq data table!) and efficiency (fold-
amplification per PCR cycle, determined from qPCR of serial dilutions; see PrimEff() function )
</p>
</td></tr>
<tr><td><code id="cq2counts_+3A_cq1">Cq1</code></td>
<td>

<p>The Cq of a single molecule. If left unspecified, it will be calculated from the efficiency (E)
using approximate formula Cq1=51.6-7.56*E, derived empirically for Roche's LightCycler 480. 
Cq1 does not seem to have much effect on relative quantification results unless it is 
wildly off (by 2-3 cycles). For an unknown qPCR instrument a single Cq1=37 could be assumed
for all genes. 
</p>
<p>Note: If all experimental Cq values are less than 30, Cq1 variation (within a reasonable range, 35-39)
will not have any effect on the results whatsoever, so just go for Cq1=37.  
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe with a single response variable column (&quot;count&quot;), gene column 
(&quot;gene&quot;) and several columns containing factors.
</p>
<p>Note: The purpose of Cq to counts conversion is to enable generalized linear model analysis,
which would take care of the heteroscedasticity and occasional 'empty' amplification trials 
for low-abundant targets. Although this works well, the absolute values of molecule counts returned by 
cq2counts are still approximate, so they should not be relied upon for true single-molecule analysis.
</p>


<h3>Author(s)</h3>

<p>Mikhail V. Matz, UT Austin
&lt;matz@utexas.edu&gt;
</p>


<h3>References</h3>

<p>Matz MV, Wright RM, Scott JG (2013) No Control Genes Required: Bayesian Analysis of qRT-PCR Data. PLoS ONE 8(8): e71448. doi:10.1371/journal.pone.0071448
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(coral.stress) 
data(amp.eff) 
genecolumns=c(5:19) # specifying where the Ct data are in the data table
conditions=c(1:4) # specifying data table columns containing factors  
# calculating molecule counts and reformatting:
dd=cq2counts(data=coral.stress,genecols=genecolumns,
condcols=conditions,effic=amp.eff,Cq1=37) 

</code></pre>

<hr>
<h2 id='cq2genorm'>
Reformats raw Ct data for geNorm analysis (non-parametric selection of
stable control genes) as implemented in selectHKgenes function (package SLqPCR)
</h2><span id='topic+cq2genorm'></span>

<h3>Description</h3>

<p>Does similar procedures as cq2log, but in the end converts the data into
relative expression values, leaves it unstacked, and removes factor columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cq2genorm(data, genes, effic, noamp=38)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cq2genorm_+3A_data">data</code></td>
<td>

<p>raw qRT-PCR data; see help for cq2counts for details on formatting
</p>
</td></tr>
<tr><td><code id="cq2genorm_+3A_genes">genes</code></td>
<td>

<p>Vector of names of the potential control genes. Make sure you select only the  potential control genes for this analysis, otherwise geNorm might prefer actual responsive genes if they co-vary and have very low variance.
</p>
</td></tr>
<tr><td><code id="cq2genorm_+3A_effic">effic</code></td>
<td>

<p>PCR efficiency data for each of the analyzed genes; see help for cq2counts for details on formatting. 
</p>
</td></tr>
<tr><td><code id="cq2genorm_+3A_noamp">noamp</code></td>
<td>

<p>what to do about Ct values '-1', denoting no amplification. By default, these will be assigned 
an arbitrarily low expression value corresponding to slightly less than one molecule. Specify 
'noamp=NA' if you want to skip samples containing any of these.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See cq2counts help page for details.
</p>


<h3>Value</h3>

<p>A dataset to be fed into the function selectHKgenes (package SLqPCR).
</p>


<h3>Author(s)</h3>

<p>Mikhail V. Matz, UT Austin
</p>


<h3>References</h3>

<p>Matz MV, Wright RM, Scott JG (2013) No Control Genes Required: Bayesian Analysis of qRT-PCR Data. PLoS ONE 8(8): e71448. doi:10.1371/journal.pone.0071448
</p>

<hr>
<h2 id='cq2log'>
Prepares qRT-PCR data for mcmc.qpcr analysis using lognormal and &quot;classic&quot; (normalization-based) models
</h2><span id='topic+cq2log'></span>

<h3>Description</h3>

<p>Log-transforms and efficiency-corrects Cq values, converting them to natural logs fo relative abundances,
and stacks the dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cq2log(data, genecols, condcols, effic, noamp = 38, stacked=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cq2log_+3A_data">data</code></td>
<td>

<p>Raw qRT-PCR dataset, one Cq column per gene, plus columns containing factors. The Cq 
columns, in addition to the proper Cq values, may contain NA (missing data) and -1, 
which means no amplification observed (i.e., zero target molecules at the start of qPCR 
reaction). 
Column headers are either gene names or factor names. 
Any number of fixed factors is allowed; any number of random factors that are gene-specific 
scalars (such as effect of genotype, or block)
Must have a column called &quot;sample&quot;, denoting individual cDNA preps.
Technical replicates should not be averaged, they should be represented as independent
rows with the same sample ID.
</p>
</td></tr>
<tr><td><code id="cq2log_+3A_genecols">genecols</code></td>
<td>

<p>columns containing Cq data
</p>
</td></tr>
<tr><td><code id="cq2log_+3A_condcols">condcols</code></td>
<td>

<p>columns corresponding to factors, including &quot;sample&quot; factor
</p>
</td></tr>
<tr><td><code id="cq2log_+3A_effic">effic</code></td>
<td>

<p>The PCR efficiency data for each of the analyzed genes. This is data frame with two columns:
gene name (must exactly match the headers of gene columns in Cq data table!) and efficiency (fold-
amplification per PCR cycle, determined from qPCR of serial dilutions; see PrimEff() function )
</p>
</td></tr>
<tr><td><code id="cq2log_+3A_noamp">noamp</code></td>
<td>

<p>Value to replace instances of no amplification with. These instances would be coded by -1 in the data
table. Specify 'noamp=NA' if you want to disregard them, but by default they will be converted into an arbitrarily low value, 38  
</p>
</td></tr>
<tr><td><code id="cq2log_+3A_stacked">stacked</code></td>
<td>

<p>Logical: whether to return stacked data for mcmc.qpcr modeling, or the originally-formatted table.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The models that process cq2log output are expected to work well for datasets that don't have too many Cq values above 30 and don't have instances of no amplification. For examples, see cq2counts function.	
</p>


<h3>Value</h3>

<p>Returns a dataframe with a single response variable column (&quot;count&quot;, even though it is actually a log-transformed relative abundance value), gene column (&quot;gene&quot;) and several columns containing factors.
</p>


<h3>Author(s)</h3>

<p>Mikhail V. Matz, UT Austin
</p>


<h3>References</h3>

<p>Matz MV, Wright RM, Scott JG (2013) No Control Genes Required: Bayesian Analysis of qRT-PCR Data. PLoS ONE 8(8): e71448. doi:10.1371/journal.pone.0071448
</p>

<hr>
<h2 id='diagnostic.mcmc'>
Plots three diagnostic plots to check the validity of the assumptions of linear model analysis.
</h2><span id='topic+diagnostic.mcmc'></span>

<h3>Description</h3>

<p>Predicted vs observed plot tests for linearity, Scale-location plot tests for homoscedasticity, and Normal QQ plot tests for normality of the residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnostic.mcmc(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diagnostic.mcmc_+3A_model">model</code></td>
<td>

<p>MCMCglmm object (a model fitted by mcmc.qpcr or mcmc.qpcr.gauss), obtained with additional options, 'pl=T, pr=T'
</p>
</td></tr>
<tr><td><code id="diagnostic.mcmc_+3A_...">...</code></td>
<td>

<p>Various plot() options to modify color, shape and size of the plotteed points.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with three panels.	
</p>


<h3>Author(s)</h3>

<p>Mikhail V. Matz, UT Austin
&lt;matz@utexas.edu&gt;
</p>


<h3>References</h3>

<p>Matz MV, Wright RM, Scott JG (2013) No Control Genes Required: Bayesian Analysis of qRT-PCR Data. PLoS ONE 8(8): e71448. doi:10.1371/journal.pone.0071448
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# loading Cq data and amplification efficiencies
data(coral.stress) 
data(amp.eff) 
# extracting a subset of data 
cs.short=subset(coral.stress, timepoint=="one")

genecolumns=c(5,6,16,17) # specifying columns corresponding to genes of interest
conditions=c(1:4) # specifying columns containing factors  

# calculating molecule counts and reformatting:
dd=cq2counts(data=cs.short,genecols=genecolumns,
condcols=conditions,effic=amp.eff,Cq1=37) 

# fitting the model
mm=mcmc.qpcr(
	fixed="condition",
	data=dd,
	controls=c("nd5","rpl11"),
	pr=TRUE,pl=TRUE, # these flags are necessary for diagnostics
	nitt=4000 # remove this line when analyzing real data!
)
diagnostic.mcmc(mm)

</code></pre>

<hr>
<h2 id='dilutions'>
Data to determine amplification efficiency
</h2><span id='topic+dilutions'></span>

<h3>Description</h3>

<p>Cq data for a series of four-fold dilutions for two targets; the input for PrimEff()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dilutions)</code></pre>


<h3>Format</h3>

<p>A data frame with 76 observations on the following 3 variables.
</p>

<dl>
<dt><code>dna</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>cq</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>gene</code></dt><dd><p>a factor with levels <code>chrom</code> <code>eif3h</code></p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(dilutions)
PrimEff(dilutions)
</code></pre>

<hr>
<h2 id='getNormalizedData'>
Extracts qPCR model predictions
</h2><span id='topic+getNormalizedData'></span>

<h3>Description</h3>

<p>Generates a table of model-derived log2-transformed transcript abundances without global sample effects (i.e., corresponding to efficiency-corrected and normalized qPCR data)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNormalizedData(model, data, controls=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getNormalizedData_+3A_model">model</code></td>
<td>

<p>qPCR model: the output of mcmc.qpcr or mcmc.qpcr.lognormal function fitted with two additional options: random=&quot;sample&quot;, pr=TRUE . These options do not change the inferences of main effects but make it possible to retain among-sample variation of expression for each gene while still subtracting the global sample effects (i.e., perform &quot;normalization&quot;)
</p>
</td></tr>
<tr><td><code id="getNormalizedData_+3A_data">data</code></td>
<td>

<p>The dataset that was analysed to generate the model (output of cq2counts or cq2log functions)
</p>
</td></tr>
<tr><td><code id="getNormalizedData_+3A_controls">controls</code></td>
<td>

<p>List of control genes; required if the mcmc.qpcr model was fit with the option normalize=TRUE
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list of two data frames. The first one, normData, is the model-predicted log2-transformed transcript abundances table. It has one column per gene and one row per sample. The second data frame, conditions, is a table of experimental conditions corresponding to the normData table.
</p>


<h3>Author(s)</h3>

<p>Mikhail V. Matz, University of Texas at Austin
&lt;matz@utexas.edu&gt;
</p>


<h3>References</h3>

<p>Matz MV, Wright RM, Scott JG (2013) No Control Genes Required: Bayesian Analysis of qRT-PCR Data. PLoS ONE 8(8): e71448. doi:10.1371/journal.pone.0071448
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MCMC.qpcr)

# loading Cq data and amplification efficiencies
data(coral.stress) 
data(amp.eff) 

genecolumns=c(5,6,16,17) # specifying columns corresponding to genes of interest
conditions=c(1:4) # specifying columns containing factors  

# calculating molecule counts and reformatting:
dd=cq2counts(data=coral.stress,genecols=genecolumns,
condcols=conditions,effic=amp.eff,Cq1=37) 

# fitting the model (must include random="sample", pr=TRUE options)
mm=mcmc.qpcr(
	fixed="condition",
	data=dd,
	controls=c("nd5","rpl11"),
	nitt=4000,
	pr=TRUE,
	random="sample"
)

# extracting model predictions
pp=getNormalizedData(mm,dd)

# here is the normalized data:
pp$normData

# and here are the corresponding conditions:
pp$conditions

# putting them together for plotting:
ppcombo=cbind(stack(pp$normData),rep(pp$conditions))
names(ppcombo)[1:2]=c("expression","gene")

# plotting boxplots of normalized data:
ggplot(ppcombo,aes(condition,expression,colour=timepoint))+
	geom_boxplot()+
	facet_wrap(~gene,scales="free")+
	theme_bw()
</code></pre>

<hr>
<h2 id='HPDplot'>
Plotting fixed effects for all genes for a single combination of factors
</h2><span id='topic+HPDplot'></span>

<h3>Description</h3>

<p>Calculates and plots posterior means with 95% credible intervals for specified 
fixed effects (or their combination) for all genes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HPDplot(model, factors, factors2 = NULL, ylimits = NULL, 
hpdtype = "w", inverse = FALSE, jitter = 0, plot = TRUE, grid = TRUE, 
zero = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HPDplot_+3A_model">model</code></td>
<td>

<p>The output of mcmc.qpcr function.
</p>
</td></tr>
<tr><td><code id="HPDplot_+3A_factors">factors</code></td>
<td>

<p>A vector of names of fixed effects of interest; see details.
</p>
</td></tr>
<tr><td><code id="HPDplot_+3A_factors2">factors2</code></td>
<td>

<p>A second vector of fixed effect names to be subtracted from the first; see details.
</p>
</td></tr>
<tr><td><code id="HPDplot_+3A_ylimits">ylimits</code></td>
<td>

<p>Y-limits for the plot such as c(-3,6); autoscale by default.
</p>
</td></tr>
<tr><td><code id="HPDplot_+3A_hpdtype">hpdtype</code></td>
<td>

<p>Specify hpdtype=&quot;l&quot; to plot the upper and lower 95% credible limits as a continuous
dashed line across all genes. This is useful to compare credible intervals among several models on the same plot. 
By default (hpdtype=&quot;w&quot;) the limits are plotted as whiskers around each point.
</p>
</td></tr>
<tr><td><code id="HPDplot_+3A_inverse">inverse</code></td>
<td>

<p>Plot the inverse of the result.
</p>
</td></tr>
<tr><td><code id="HPDplot_+3A_jitter">jitter</code></td>
<td>

<p>For hpdtype=&quot;w&quot;, shifts the plotted values and whiskers by the specified distance along
the x axis (reasonable jitter values are 0.15 or -0.15, for example). This helps plot 
several results (different models or factor combinations) on the same plot (use 
HPDpoints to add to existing plot) 
</p>
</td></tr>
<tr><td><code id="HPDplot_+3A_plot">plot</code></td>
<td>

<p>if plot = FALSE the function returns a table of calculated posterior modes, means, upper 
and lower 95% credible limits (all on log(2) scale), and two types of p-values: derived from Bayesian z-scores, 
and derived directly from MCMC sample. 
</p>
<p>All such outputs for a given experiment should be concatenated
with rbind and processed by padj.qpcr() function to adjust the p-values for multiple comparisons 
(disregarding the entries corresponding to control genes)
</p>
</td></tr>
<tr><td><code id="HPDplot_+3A_grid">grid</code></td>
<td>

<p>Whether to draw vertical grid lines to separate genes. 
</p>
</td></tr>
<tr><td><code id="HPDplot_+3A_zero">zero</code></td>
<td>

<p>Whether to draw a horizontal line at 0. 
</p>
</td></tr>
<tr><td><code id="HPDplot_+3A_...">...</code></td>
<td>

<p>Various plot() options; such as col (color of lines and symbols), pch (type of symbol),
main (plot title) etc. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use summary(MCMCglmm object) first to see what fixed effect names are actually used 
in the output. For example, if summary shows:
</p>
<p>gene1:conditionheat<br />
gene2:conditionheat<br />
....<br />
gene1:timepointtwo<br />
gene2:timepointtwo<br />
....<br />
gene1:conditionheat:timepointtwo<br />
gene2:conditionheat:timepointtwo
</p>
<p>, it is possible to specify factors=&quot;conditionheat&quot; to plot only the effects of the heat.
</p>
<p>If a vector of several fixed effect names is given, for example: 
factors=c(&quot;timepointtwo&quot;,&quot;treatmentheat:timepointtwo&quot;)
the function will plot the posterior mean and credible interval for the sum of these 
effects.
</p>
<p>If a second vector is also given, for example,<br /> 
factors=c(&quot;f1&quot;,&quot;f2&quot;), factors2=c(&quot;f3&quot;,&quot;f4&quot;)<br />
the function will plot the difference between the sums of these two groups of factors.
This is useful for pairwise analysis of differences in complicated designs.
</p>


<h3>Value</h3>

<p>A plot or a table (plot = F).
</p>
<p>Use the function HPDpoints() if you need to add graphs to already existing plot.
</p>


<h3>Author(s)</h3>

<p>Mikhail V. Matz, UT Austin
&lt;matz@utexas.edu&gt;
</p>


<h3>References</h3>

<p>Matz MV, Wright RM, Scott JG (2013) No Control Genes Required: Bayesian Analysis of qRT-PCR Data. PLoS ONE 8(8): e71448. doi:10.1371/journal.pone.0071448
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# loading Cq data and amplification efficiencies
data(coral.stress) 
data(amp.eff) 
# extracting a subset of data 
cs.short=subset(coral.stress, timepoint=="one")

genecolumns=c(5,6,16,17) # specifying columns corresponding to genes of interest
conditions=c(1:4) # specifying columns containing factors  

# calculating molecule counts and reformatting:
dd=cq2counts(data=cs.short,genecols=genecolumns,
condcols=conditions,effic=amp.eff,Cq1=37) 

# fitting the model
mm=mcmc.qpcr(
	fixed="condition",
	data=dd,
	controls=c("nd5","rpl11"),
	nitt=3000,burnin=2000 # remove this line when analyzing real data!
)

# plotting log2(fold change) in response to heat stress for all genes
HPDplot(model=mm,factors="conditionheat",main="response to heat stress")

</code></pre>

<hr>
<h2 id='HPDplotBygene'>
Plots qPCR analysis results for individual genes.
</h2><span id='topic+HPDplotBygene'></span>

<h3>Description</h3>

<p>For a particular gene, plots model-predicted values (and credible intervals) for a series of specified  fixed effect combinations (&quot;conditions&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HPDplotBygene(model, gene, conditions, pval = "mcmc", newplot = T, 
ylimits = NULL, inverse = F, jitter = 0, plot = T, yscale = "log2", 
interval = "ci", grid = F, zero = F, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HPDplotBygene_+3A_model">model</code></td>
<td>

<p>model object produced by MCMC.qpcr()
</p>
</td></tr>
<tr><td><code id="HPDplotBygene_+3A_gene">gene</code></td>
<td>

<p>name of the gene to plot
</p>
</td></tr>
<tr><td><code id="HPDplotBygene_+3A_conditions">conditions</code></td>
<td>

<p>A list naming the conditions to plot and defining them as combination of fixed effects (See example below). '0' denotes gene-specific intercept.
</p>
</td></tr>
<tr><td><code id="HPDplotBygene_+3A_pval">pval</code></td>
<td>

<p>Type of p-value to report: 'mcmc' - MCMC-based (default), 'z' - based on Bayesian z-score. Use 'z' to approximate p-values lower than 2/[MCMC sample size] (with default MCMC.qpcr settings, this comes to 0.002) 
</p>
</td></tr>
<tr><td><code id="HPDplotBygene_+3A_newplot">newplot</code></td>
<td>

<p>When TRUE, a new plot should be created. When FALSE, or a graph will be added to an existing plot.
</p>
</td></tr>
<tr><td><code id="HPDplotBygene_+3A_ylimits">ylimits</code></td>
<td>

<p>Y-limits for the plot such as c(-3,6); autoscale by default.
</p>
</td></tr>
<tr><td><code id="HPDplotBygene_+3A_inverse">inverse</code></td>
<td>

<p>When TRUE, the inverse of the data will be plotted.
</p>
</td></tr>
<tr><td><code id="HPDplotBygene_+3A_jitter">jitter</code></td>
<td>

<p>Shifts the plotted values and whiskers by the specified distance along
the x axis (reasonable jitter values are 0.15 or -0.15, for example). This helps plot 
several graphs on the same plot without overlapping. 
</p>
</td></tr>
<tr><td><code id="HPDplotBygene_+3A_plot">plot</code></td>
<td>

<p>When FALSE, no plot will be generated; the function will just list mean pairwise differences and p-values.
</p>
</td></tr>
<tr><td><code id="HPDplotBygene_+3A_yscale">yscale</code></td>
<td>

<p>Scale on which to represent the data. In all mcmc.qpcr models the model scale is natural logarithm, which
I prefer to translate into log2 or log10 (if the differences are orders of magnitude) for better human readability. 
The default is 'log2'; other options are 'log10' and 'native' (no rescaling of the model data). 
There is also a beta-option 'proportion', which is not useful for qPCR. It was added to cannibalize HPDplotBygene 
function for plotting results of the model operating with arcsin-square root
transfromed proportions. With yscale=&quot;proportions&quot;, the plot will be on the original proportion scale but the tukey-like 
differences will still be reported on the asin(sqrt()) transformed scale.
</p>
</td></tr>
<tr><td><code id="HPDplotBygene_+3A_interval">interval</code></td>
<td>

<p>'ci' (default) will plot 95% credible limits of the posterior distribution, 'sd' will plot the mean plus/minus one standard deviation of the posterior.
</p>
</td></tr>
<tr><td><code id="HPDplotBygene_+3A_grid">grid</code></td>
<td>

<p>When TRUE, a vertical grid separating conditions will be added
</p>
</td></tr>
<tr><td><code id="HPDplotBygene_+3A_zero">zero</code></td>
<td>

<p>When TRUE, a y=0 line will be added.
</p>
</td></tr>
<tr><td><code id="HPDplotBygene_+3A_...">...</code></td>
<td>

<p>Various plot() options.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generates a point-whiskers plot, lists pairwise mean differenes between all conditions, calculates and lists pairwise p-values (not corrected for multiple testing). 
</p>


<h3>Author(s)</h3>

<p>Mikhal V. Matz, UT Austin, matz@utexas.edu
</p>


<h3>References</h3>

<p>Matz MV, Wright RM, Scott JG (2013) No Control Genes Required: Bayesian Analysis of qRT-PCR Data. PLoS ONE 8(8): e71448. doi:10.1371/journal.pone.0071448
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# loading Cq data and amplification efficiencies
data(coral.stress) 
data(amp.eff) 
# extracting a subset of data 
cs.short=subset(coral.stress, timepoint=="one")

genecolumns=c(5,6,16,17) # specifying columns corresponding to genes of interest
conditions=c(1:4) # specifying columns containing factors  

# calculating molecule counts and reformatting:
dd=cq2counts(data=cs.short,genecols=genecolumns,
condcols=conditions,effic=amp.eff,Cq1=37) 

# fitting the model
mm=mcmc.qpcr(
	fixed="condition",
	data=dd,
	controls=c("nd5","rpl11"),
	nitt=3000,burnin=2000 # remove this line when analyzing real data!
)

# plotting abundances of individual genes across all conditions
# step 1: defining conditions
cds=list(
  control=list(factors=0), # gene-specific intercept
  stress=list(factors=c(0,"conditionheat")) # multiple effects will be summed up
  )

# step 2: plotting gene after gene on the same panel
HPDplotBygene(model=mm,gene="actin",conditions=cds,col="cyan3",
pch=17,jitter=-0.1,ylim=c(-3.5,15),pval="z")
HPDplotBygene(model=mm,gene="hsp16",conditions=cds,
newplot=FALSE,col="coral",pch=19,jitter=0.1,pval="z")

# step 3: adding legend
legend(0.5,10,"actin",lty=1,col="cyan3",pch=17,bty="n")
legend(0.5,7,"hsp16",lty=1,col="coral",pch=19,bty="n")

</code></pre>

<hr>
<h2 id='HPDplotBygeneBygroup'>
Plots qPCR analysis results for individual genes
</h2><span id='topic+HPDplotBygeneBygroup'></span>

<h3>Description</h3>

<p>For a specified gene, makes overlayed plots such as produced by HPDplotBygene()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HPDplotBygeneBygroup(model, gene, group1, group2, group3 = NULL, 
interval = "ci", colors = c("coral", "cyan3", "grey50"), 
symbols = c(19, 17, 15), jitter = 0.16, yscale = "log2", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HPDplotBygeneBygroup_+3A_model">model</code></td>
<td>

<p>model object produced by mcmc.qpcr()
</p>
</td></tr>
<tr><td><code id="HPDplotBygeneBygroup_+3A_gene">gene</code></td>
<td>

<p>name of the gene to plot
</p>
</td></tr>
<tr><td><code id="HPDplotBygeneBygroup_+3A_group1">group1</code></td>
<td>

<p>Combination of factors defining the first group (see HPDplotBygene() for details). 
</p>
</td></tr>
<tr><td><code id="HPDplotBygeneBygroup_+3A_group2">group2</code></td>
<td>

<p>Combination of factors defining the second group.
</p>
</td></tr>
<tr><td><code id="HPDplotBygeneBygroup_+3A_group3">group3</code></td>
<td>

<p>(optional) Combination of factors defining the third group.
</p>
</td></tr>
<tr><td><code id="HPDplotBygeneBygroup_+3A_interval">interval</code></td>
<td>

<p>'ci' (default) will plot 95% credible limits of the posterior distribution, 'sd' will plot the mean plus/minus one standard deviation of the posterior.
</p>
</td></tr>
<tr><td><code id="HPDplotBygeneBygroup_+3A_colors">colors</code></td>
<td>

<p>Colors to use for different groups (see ?par -&gt; col).
</p>
</td></tr>
<tr><td><code id="HPDplotBygeneBygroup_+3A_symbols">symbols</code></td>
<td>

<p>Symbols to use for different groups (see ?par -&gt; pch).
</p>
</td></tr>
<tr><td><code id="HPDplotBygeneBygroup_+3A_jitter">jitter</code></td>
<td>

<p>Jitter distance between groups.
</p>
</td></tr>
<tr><td><code id="HPDplotBygeneBygroup_+3A_yscale">yscale</code></td>
<td>

<p>Scale on which to represent the data. In all mcmc.qpcr models the model scale is natural logarithm, which
I prefer to translate into log2 or log10 (if the differences are orders of magnitude) for better human readability. 
The default is 'log2'; other options are 'log10' and 'native' (no rescaling of the model data). 
There is also a beta-option 'proportion', which is not useful for qPCR. It was added to cannibalize HPDplotBygene 
function for plotting results of the model operating with arcsin-square root
transfromed proportions. With yscale=&quot;proportions&quot;, the plot will be on the original proportion scale but the tukey-like 
differences will still be reported on the asin(sqrt()) transformed scale.
</p>
</td></tr>
<tr><td><code id="HPDplotBygeneBygroup_+3A_...">...</code></td>
<td>

<p>additional parameters for HPDplotBygene() function, such as pval (see HPDplotBygene() help)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generates a point-whiskers plot, lists pairwise mean differenes between all conditions, calculates and lists pairwise p-values (not corrected for multiple testing). 
</p>


<h3>Author(s)</h3>

<p>Mikhal V. Matz, UT Austin
&lt;matz@utexas.edu&gt;
</p>


<h3>References</h3>

<p>Matz MV, Wright RM, Scott JG (2013) No Control Genes Required: Bayesian Analysis of qRT-PCR Data. PLoS ONE 8(8): e71448. doi:10.1371/journal.pone.0071448
</p>

<hr>
<h2 id='HPDpoints'>
HPDplot, HPDpoints
</h2><span id='topic+HPDpoints'></span>

<h3>Description</h3>

<p>Calculates and plots posterior means with 95% credible intervals for specified 
fixed effects (or their combination) for all genes. HPDpoints only adds graphs to an existing plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HPDpoints(model, factors, factors2 = NULL, ylimits = NULL, 
hpdtype = "w", inverse = F, jitter = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HPDpoints_+3A_model">model</code></td>
<td>

<p>The output of mcmc.qpcr function.
</p>
</td></tr>
<tr><td><code id="HPDpoints_+3A_factors">factors</code></td>
<td>

<p>A vector of names of fixed effects of interest; see details.
</p>
</td></tr>
<tr><td><code id="HPDpoints_+3A_factors2">factors2</code></td>
<td>

<p>A second vector of fixed effect names to be subtracted from the first; see details.
</p>
</td></tr>
<tr><td><code id="HPDpoints_+3A_ylimits">ylimits</code></td>
<td>

<p>Y-limits for the plot such as c(-3,6); autoscale by default.
</p>
</td></tr>
<tr><td><code id="HPDpoints_+3A_hpdtype">hpdtype</code></td>
<td>

<p>Specify hpdtype=&quot;l&quot; to plot the upper and lower 95% credible limits as a continuous
dashed line across all genes. By default (hpdtype=&quot;w&quot;) the limits are plotted as whiskers around
each point.
</p>
</td></tr>
<tr><td><code id="HPDpoints_+3A_inverse">inverse</code></td>
<td>

<p>Plot the inverse of the result.
</p>
</td></tr>
<tr><td><code id="HPDpoints_+3A_jitter">jitter</code></td>
<td>

<p>For hpdtype=&quot;w&quot;, shifts the plotted values and whiskers by the specified distance along
the x axis (reasonable jitter values are 0.15 or -0.15, for example). 
</p>
</td></tr>
<tr><td><code id="HPDpoints_+3A_...">...</code></td>
<td>

<p>Various plot() options; such as col (color of lines and symbols), pch (type of symbol),
main (plot title) etc. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See details in HPDplot()
</p>


<h3>Value</h3>

<p>A graph added to a plot.
</p>


<h3>Author(s)</h3>

<p>Mikhail V. Matz, UT Austin
&lt;matz@utexas.edu&gt;
</p>


<h3>References</h3>

<p>Matz MV, Wright RM, Scott JG (2013) No Control Genes Required: Bayesian Analysis of qRT-PCR Data. PLoS ONE 8(8): e71448. doi:10.1371/journal.pone.0071448
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# loading Cq data and amplification efficiencies
data(coral.stress) 
data(amp.eff) 
# extracting a subset of data 
cs.short=subset(coral.stress, timepoint=="one")

genecolumns=c(5,6,16,17) # specifying columns corresponding to genes of interest
conditions=c(1:4) # specifying columns containing factors  

# calculating molecule counts and reformatting:
dd=cq2counts(data=cs.short,genecols=genecolumns,
condcols=conditions,effic=amp.eff,Cq1=37) 

# fitting the model
mm=mcmc.qpcr(
	fixed="condition",
	data=dd,
	controls=c("nd5","rpl11"),
	nitt=4000 # remove this line when analyzing real data!
)

# plotting log2(fold change) in response to heat stress for all genes
HPDplot(model=mm,factors="conditionheat",main="response to heat stress")

</code></pre>

<hr>
<h2 id='HPDsummary'>
Summarizes and plots results of mcmc.qpcr function series.
</h2><span id='topic+HPDsummary'></span>

<h3>Description</h3>

<p>Calculates abundances of each gene across factor combinations;
calculates pairwise differences between all factor combinations
and their significances for each gene;
plots results as bar or line graphs with credible intervals (ggplot2)
NOTE: only works for experiments involving a single multi-level fixed factor
or two fully crossed multi-level fixed factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HPDsummary(model, data, xgroup=NULL,genes = NA, relative = FALSE, 
log.base = 2, summ.plot = TRUE, ptype="z", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HPDsummary_+3A_model">model</code></td>
<td>

<p>Model generated by mcmc.qpcr(),mcmc.qpcr.lognormal() or mcmc.qpcr.classic()
</p>
</td></tr>
<tr><td><code id="HPDsummary_+3A_data">data</code></td>
<td>

<p>Dataset used to build the model (returned by cq2counts() or cq2log())
</p>
</td></tr>
<tr><td><code id="HPDsummary_+3A_xgroup">xgroup</code></td>
<td>

<p>The factor to form the x-axis of the plot. By default the first factor in the model will be used.
</p>
</td></tr>
<tr><td><code id="HPDsummary_+3A_genes">genes</code></td>
<td>

<p>A vector of gene names to summarize and plot. If left unspecified, all 
genes will be summarized.
</p>
</td></tr>
<tr><td><code id="HPDsummary_+3A_relative">relative</code></td>
<td>

<p>Whether to plot absolute transcript abundances (relative = FALSE) or fold-
changes relative to the sample that is considered to be &quot;global control&quot; 
(relative = TRUE). The &quot;global control&quot; is the combination of factors 
that served as a reference during model fitting, either because it is 
alphanumerically first (that happens by default) or because it has been 
explicitly designated as such using relevel() function (see tutorial). 
</p>
</td></tr>
<tr><td><code id="HPDsummary_+3A_log.base">log.base</code></td>
<td>

<p>Base of the logarithm to use.
</p>
</td></tr>
<tr><td><code id="HPDsummary_+3A_summ.plot">summ.plot</code></td>
<td>

<p>By default, the function generates a summary plot, which is a line-points-95% 
credible intervals plot of log(absolute abundances) with 'relative=FALSE' 
and a more typical bar graph of log(fold change relative to the control), 
again with 95%  credible intervals, with 'relative=TRUE'. Specify 
'summ.plot=FALSE' if you don't want the summary plot.
</p>
</td></tr>
<tr><td><code id="HPDsummary_+3A_ptype">ptype</code></td>
<td>

<p>Which type of p-values to use. By default p-values based on the Bayesian 
z-score are used. Specify 'ptype=&quot;mcmc&quot;' to output more conventional p-values 
based on MCMC sampling (these will be limited on the lower end by the size of 
MCMC sample).
</p>
</td></tr>
<tr><td><code id="HPDsummary_+3A_...">...</code></td>
<td>

<p>Additional options for summaryPlot() function. Among those, 'x.order' can be a 
vector specifying the order of factor levels on the x-axis.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three items:
</p>
<table role = "presentation">
<tr><td><code>summary</code></td>
<td>
<p> Summary table containing calculated abundances, their SD 
and 95% credible limits</p>
</td></tr>
<tr><td><code>geneWise</code></td>
<td>
<p>A series of matrices listing pairwise differences between 
factor combinations (upper triangle) and corresponding p-values (lower triangle)</p>
</td></tr>
<tr><td><code>ggPlot</code></td>
<td>
<p>the ggplot2 object for plotting. See http://docs.ggplot2.org/0.9.2.1/theme.html for ways 
to modify it, such as add text, rotate labels, change fonts, etc. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mikhail V. Matz, University of Texas at Austin
&lt;matz@utexas.edu&gt;
</p>


<h3>References</h3>

<p>Matz MV, Wright RM, Scott JG (2013) No Control Genes Required: Bayesian Analysis 
of qRT-PCR Data. PLoS ONE 8(8): e71448. doi:10.1371/journal.pone.0071448
</p>


<h3>See Also</h3>

<p>See function summaryPlot() for plotting the summary table in other ways.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(beckham.data)
data(beckham.eff)

# analysing the first 5 genes 
# (to try it with all 10 genes, change the line below to gcol=4:13)
gcol=4:8 
ccol=1:3 # columns containing experimental conditions

# recalculating into molecule counts, reformatting
qs=cq2counts(data=beckham.data,genecols=gcol,
condcols=ccol,effic=beckham.eff,Cq1=37)

# creating a single factor, 'treatment.time', out of 'tr' and 'time'
qs$treatment.time=as.factor(paste(qs$tr,qs$time,sep="."))

# fitting a naive model
naive=mcmc.qpcr(
	fixed="treatment.time",
	data=qs,
	nitt=3000,burnin=2000 # remove this line in actual analysis!
)

#summary plot of inferred abundances
# s1=HPDsummary(model=naive,data=qs)

#summary plot of fold-changes relative to the global control
s0=HPDsummary(model=naive,data=qs,relative=TRUE)

# pairwise differences and their significances for each gene:
s0$geneWise

</code></pre>

<hr>
<h2 id='mcmc.converge.check'>
MCMC diagnostic plots
</h2><span id='topic+mcmc.converge.check'></span>

<h3>Description</h3>

<p>A wrapper function for plot.MCMCglmm to plot diagnostic convergence plots for selected fixed effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc.converge.check(model, factors, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmc.converge.check_+3A_model">model</code></td>
<td>

<p>output of mcmc.qpcr (or any MCMCglmm class object)
</p>
</td></tr>
<tr><td><code id="mcmc.converge.check_+3A_factors">factors</code></td>
<td>

<p>A vector of names of fixed effects of interest; see details in HPDplot help page.
</p>
</td></tr>
<tr><td><code id="mcmc.converge.check_+3A_...">...</code></td>
<td>

<p>other options to pass to plot.MCMCglmm
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A series of plots for each gene-specific fixed effect.
</p>
<p>The MCMC trace plot is on the left, to see if there is convergence (lack of systematic
trend) and no autocorrelation (no low-frequency waves). If lack of convergence is suspected, 
try increasing number of iterations and burnin by specifying, for example, nitt=50000,
burnin=5000, as additional options for mcmc.qpcr. If autocorrelation is present, increase 
thinning interval by specifying thin=20 in mcmc.qpcr (you might wish to increase the number of iterations,
nitt, to keep the size of MCMC sample the same)
</p>
<p>The right plot is posterior density distribution.
</p>


<h3>Author(s)</h3>

<p>Mikhail V. Matz, UT Austin
</p>


<h3>References</h3>

<p>Matz MV, Wright RM, Scott JG (2013) No Control Genes Required: Bayesian Analysis of qRT-PCR Data. PLoS ONE 8(8): e71448. doi:10.1371/journal.pone.0071448
</p>

<hr>
<h2 id='mcmc.pval'>
calculates p-value based on Bayesian z-score or MCMC sampling
</h2><span id='topic+mcmc.pval'></span>

<h3>Description</h3>

<p>Accessory function to HPD... function series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc.pval(dat, testlim = 0, sided = 2, ptype="z")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmc.pval_+3A_dat">dat</code></td>
<td>

<p>a table of MCMC samples
</p>
</td></tr>
<tr><td><code id="mcmc.pval_+3A_testlim">testlim</code></td>
<td>

<p>positive value to test whether the posterior crosses it (for variance components)
</p>
</td></tr>
<tr><td><code id="mcmc.pval_+3A_sided">sided</code></td>
<td>

<p>sidedness of the test
</p>
</td></tr>
<tr><td><code id="mcmc.pval_+3A_ptype">ptype</code></td>
<td>

<p>'z' for z-score based p-values, 'mcmc' for standard sampling based p-values
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of calculated Bayesian p-values. For standard 'mcmc' p=values, the minimal possible value is 1/(MCMC sample size).
z-score based p-values are useful to approximate very low p-values with limited MCMC sample sizes.
</p>


<h3>Author(s)</h3>

<p>Mikhail Matz, UT Austin
&lt;matz@utexas.edu&gt;
</p>

<hr>
<h2 id='mcmc.qpcr'>
Analyzes qRT-PCR data using generalized linear mixed model
</h2><span id='topic+mcmc.qpcr'></span>

<h3>Description</h3>

<p>Wrapper function for MCMCglmm by Jarrod Hadfield, designed for qRT-PCR data 
analysis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc.qpcr(fixed=NULL, globalFixed=NULL, random = NULL, globalRandom=NULL, data, 
controls = NULL, normalize=FALSE, include = NULL, m.fix = 1.2, v.fix = NULL, 
geneSpecRes=TRUE, Covar=FALSE, vprior="uninf", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmc.qpcr_+3A_fixed">fixed</code></td>
<td>

<p>desired combination of fixed effects, as a text string. Do not use &quot;*&quot; symbol, list
it fully, such as: 'factor1+factor2+factor1:factor2'. 
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr_+3A_globalfixed">globalFixed</code></td>
<td>

<p>Vector of fixed covariates (categorical or continuous) that are expected to affect
all genes in the sample in the same way. These would be typically related to quality 
and/or quantity of RNA, such as RIN value.
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr_+3A_random">random</code></td>
<td>

<p>A vector of names for gene-specific scalar random effects, such as 'c(&quot;effect1&quot;,&quot;effect2&quot;)'.
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr_+3A_globalrandom">globalRandom</code></td>
<td>

<p>Random covariates (categorical only) affecting all genes, similar to globalFixed. 
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr_+3A_data">data</code></td>
<td>

<p>output of the cq2counts() function
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr_+3A_controls">controls</code></td>
<td>

<p>Vector of control gene names. These will be pushed to the back of the gene list during
model fitting, in the reverse order. Controls are NOT NECESSARY for the analysis.
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr_+3A_normalize">normalize</code></td>
<td>

<p>If controls are specified, requiring 'normalize=TRUE' will perform &quot;soft normalization&quot;:
the geometric mean of control genes will be used to infer global effects 
(common to all genes) across conditions; these will be subtracted when summarizing the data
with HPDsummary(). Use this option when template abundances are correlated with 
conditions. Note that this is different from normalizing data within each sample, as per
Vandesompele et al 2002; this would be &quot;hard normalization&quot; (use mcmc.qpcr.classic() if you want it).
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr_+3A_include">include</code></td>
<td>

<p>How many of the control genes ('controls') to actually incorporate as priors during model
fitting. If left unspecified, all the 'controls' will be used. If 'include=0', the model
will be fitted without using any of the control genes as priors. If 'include' equals some number 
less than the number of 'controls', 
only the first 'include' of them will be used as priors. In all these cases, 
the 'controls' will appear in the same order in the output, in the end of the gene list
rather than according to their alphabetical position among other genes. This is useful when 
visually comparing the results of models fitted with different number of control genes, using 
HPDplot and HPDpoints functions. 
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr_+3A_m.fix">m.fix</code></td>
<td>

<p>Allowed average fold-change of the control genes in response to any fixed factor combination.
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr_+3A_v.fix">v.fix</code></td>
<td>

<p>Allowed residual fold-change deviation of the control genes. Applies to the residual variation term.
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr_+3A_genespecres">geneSpecRes</code></td>
<td>

<p>Whether the model should include gene-specific residuals.
Keep it TRUE unless the model fails to converge. 
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr_+3A_covar">Covar</code></td>
<td>

<p>Whether the random effects should be fitted with covariances. This option might require setting vprior=&quot;iw&quot; or vprior=&quot;iw01&quot; (see below)
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr_+3A_vprior">vprior</code></td>
<td>

<p>The default prior is an uninformative inverse Wishart with assumed variance (V) at 1 
and the degree of belief parameter (nu) at 0. With 'prior=&quot;iw&quot;' and 'prior=&quot;iw01&quot;' nu is equal  [number of genes]-0.998, resulting in a weakly informative prior that is commonly used in this type of inference. vprior=&quot;iw&quot; will assume large prior variance (1), vprior=&quot;iw01&quot; will assume small prior variance (0.1). 
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr_+3A_...">...</code></td>
<td>

<p>other options for MCMCglmm function, such as nitt (number of iterations), thin (tinning interval), and burnin (number of initial iterations to disregard). For a more precise inference specify 'nitt=45000, thin=20, burnin=5000'. See MCMCglmm documentation for more details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function constructs priors and runs an MCMC chain to fit a Poisson-lognormal generalized linear mixed model to the counts data.
</p>
<p>The fixed effects for the model by default assume a gene-specific intercept, and gene-specific effect for each of the listed fixed factors. 
</p>
<p>The user-specified random effects are all assumed to be gene-specific with no covariances. 
</p>
<p>There is also a universal random factor: the scalar random effect of sample,
which accounts for the unequal template loading. 
</p>
<p>Residual variances are assumed to be gene-specific with no covariances, with weakly informative inverse Wishart prior (variance=1, nu=[number of genes]-0.998).
</p>
<p>The priors for fixed effects are diffuse gaussians with 
a mean at 0 and very large variances (1e+8), except for control genes, for which the prior variances are defined 
by the m.fix parameter. For the gene-specific random effects and residual variation, non-informative priors are used to achieve results equivalent to ML estimation. For control genes, when v.fix parameter is specified, it will be used to restrict residial variance. 
</p>
<p>Both m.fix and v.fix parameters should be specified as allowed average fold-change, so the lowest they can go is 1 (no variation). 
</p>
<p>All control genes share the same m.fix and v.fix parameters.
</p>


<h3>Value</h3>

<p>An MCMCglmm object. HPDsummary() function within this package summaizes these data, 
calculates all gene-wise credible intervals and p-values, and plots the results either 
as line-point-whiskers graph or a bar-whiskers graph using ggplot2 functions. 
</p>
<p>HPDsummary() only works for experiments with a single multilevel factor or two fully 
crossed multilevel factors. Use finctions HPDplot(), HPDplotBygene() and HPDplotBygeneBygroup() 
to summarize and plot more complicated designs.
</p>
<p>For more useful operations on MCMCglmm objects, such as posterior.mode(), HPDinterval(),
and plot(), see documentation for MCMCglmm package.
</p>


<h3>Author(s)</h3>

<p>Mikhail V. Matz, University of Texas at Austin
&lt;matz@utexas.edu&gt;
</p>


<h3>References</h3>

<p>Matz MV, Wright RM, Scott JG (2013) No Control Genes Required: Bayesian Analysis of qRT-PCR Data. PLoS ONE 8(8): e71448. doi:10.1371/journal.pone.0071448
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(beckham.data)
data(beckham.eff)

# analysing the first 5 genes 
# (to try it with all 10 genes, change the line below to gcol=4:13)
gcol=4:8 
ccol=1:3 # columns containing experimental conditions

# recalculating into molecule counts, reformatting
qs=cq2counts(data=beckham.data,genecols=gcol,
condcols=ccol,effic=beckham.eff,Cq1=37)

# creating a single factor, 'treatment.time', out of 'tr' and 'time'
qs$treatment.time=as.factor(paste(qs$tr,qs$time,sep="."))

# fitting a naive model
naive=mcmc.qpcr(
	fixed="treatment.time",
	data=qs,
	nitt=3000,burnin=2000 # remove this line in actual analysis!
)

#summary plot of inferred abundances
#s1=HPDsummary(model=naive,data=qs)

#summary plot of fold-changes relative to the global control
s0=HPDsummary(model=naive,data=qs,relative=TRUE)

# pairwise differences and their significances for each gene:
s0$geneWise

</code></pre>

<hr>
<h2 id='MCMC.qpcr-package'>
Bayesian analysis of qRT-PCR data
</h2><span id='topic+MCMC.qpcr'></span>

<h3>Description</h3>

<p>This package implements generalized linear mixed model analysis of qRT-PCR data 
so that the increase of variance towards higher Ct values is properly dealt with, 
and the lack of amplification is informative (function mcmc.qpcr). Sample-loading effects, 
gene-specific variances, and responses of all genes to each factor combination are all jointly 
estimated within a single model. The control genes can be specified as priors, with 
adjustable degree of expected stability. The analysis also works well without any 
control gene specifications. 
</p>
<p>For higher-abundance datasets, a lognormal model is implemented that does not require 
Cq to counts conversion (function mcmc.qpcr.lognormal).
</p>
<p>For higher-abundance datasets datasets in which the quality and/or quantity of RNA samples 
varies systematically (rather than randomly) across conditions, the analysis based on 
multigene normalization is implemented (function mcmc.qpcr.classic).
</p>
<p>The package includes several functions for plotting the results and calculating statistical
significance (HPDplot, HPDplotBygene, HPDplotBygeneBygroup).
</p>
<p>The detailed step-by-step tutorial is here:
http://www.bio.utexas.edu/research/matz_lab/matzlab/Methods_files/mcmc.qpcr.tutorial.pdf.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: MCMC.qpcr</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: 1.2.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: 2016-11-07</td>
</tr>
<tr>
 <td style="text-align: left;">
License: GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Mikhail V. Matz, University of Texas at Austin
&lt;matz@utexas.edu&gt;
</p>


<h3>References</h3>

<p>Matz MV, Wright RM, Scott JG (2013) No Control Genes Required: Bayesian Analysis of qRT-PCR Data. PLoS ONE 8(8): e71448. doi:10.1371/journal.pone.0071448
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(beckham.data)
data(beckham.eff)

# analysing the first 5 genes 
# (to try it with all 10 genes, change the line below to gcol=4:13)
gcol=4:8 
ccol=1:3 # columns containing experimental conditions

# recalculating into molecule counts, reformatting
qs=cq2counts(data=beckham.data,genecols=gcol,
condcols=ccol,effic=beckham.eff,Cq1=37)

# creating a single factor, 'treatment.time', out of 'tr' and 'time'
qs$treatment.time=as.factor(paste(qs$tr,qs$time,sep="."))

# fitting a naive model
naive=mcmc.qpcr(
	fixed="treatment.time",
	data=qs,
	nitt=3000,burnin=2000 # remove this line in actual analysis!
)

#summary plot of inferred abundances
#s1=HPDsummary(model=naive,data=qs)

#summary plot of fold-changes relative to the global control
s0=HPDsummary(model=naive,data=qs,relative=TRUE)

#correcting p-values for multiple comparisons
s0.adj=padj.hpdsummary(s0,controls=c("gapdh"))

# pairwise differences and their significances for each gene:
s0.adj$geneWise

</code></pre>

<hr>
<h2 id='mcmc.qpcr.classic'>
Analyzes qRT-PCR data using &quot;classic&quot; model, based on multigene normalization.
</h2><span id='topic+mcmc.qpcr.classic'></span>

<h3>Description</h3>

<p>Normalizes the data using specified control genes, fits a single model to estimate changes at all genes. Use for datasets with not too many Cq values above 30.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc.qpcr.classic(fixed = NULL, globalFixed = NULL, random = NULL, globalRandom = NULL,
data, controls, genebysample = TRUE, geneSpecRes=FALSE, center = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmc.qpcr.classic_+3A_fixed">fixed</code></td>
<td>

<p>desired combination of fixed effects, as a text string. Do not use &quot;*&quot; symbol, list
it fully, such as: 'factor1+factor2+factor1:factor2'. 
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr.classic_+3A_globalfixed">globalFixed</code></td>
<td>

<p>Vector of fixed covariates (categorical or continuous) that are expected to affect
all genes in the sample in the same way. These would be typically related to quality 
and/or quantity of RNA, such as RIN value.
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr.classic_+3A_random">random</code></td>
<td>

<p>A vector of names for gene-specific scalar random effects, such as 'c(&quot;effect1&quot;,&quot;effect2&quot;)'.
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr.classic_+3A_globalrandom">globalRandom</code></td>
<td>

<p>Random covariates (categorical only) affecting all genes, similar to globalFixed. 
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr.classic_+3A_data">data</code></td>
<td>

<p>output of the cq2log() function
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr.classic_+3A_controls">controls</code></td>
<td>

<p>Vector of control gene names. These will be pushed to the back of the gene list during model fitting,
in the reverse order.
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr.classic_+3A_genebysample">genebysample</code></td>
<td>

<p>Whether random gene by sample interactions should be
modeled as an additional random effect. If the model fails to converge, specify 'genebysample=F'. 
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr.classic_+3A_genespecres">geneSpecRes</code></td>
<td>

<p>Whether the model should include gene-specific residuals.
This was the default in MCMC.qpcr v.1.0; now it is switched off
since it does not have any visible effect on the results (as long as genebysample=TRUE), 
and only makes the model converge slower or fail to converge.  
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr.classic_+3A_center">center</code></td>
<td>

<p>Whether to center the normalized log-transformed Cq values arond the mean for each gene. Centering does not affect the inference; it only makes the plots of the results more comprehensible (in my opinion). 
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr.classic_+3A_...">...</code></td>
<td>

<p>other options for MCMCglmm function, such as nitt (number of iterations), thin (tinning interval), and burnin (number of initial iterations to disregard). For a more precise inference (but longer runs) specify 'nitt=45000, thin=20, burnin=5000'. See MCMCglmm documentation for more details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes an as input the log-transformed relative abundance values, performs multigene normalization as per Vandesompele et al 2002, and runs an MCMC chain to fit a lognormal linear mixed model to estimate gene expression changes jointly at all genes. It is very powerful, as long as the average stability of control genes can be trusted. 
</p>
<p>This function requires data prepared by cq2log function and must have the control genes specified; otherwise the arguments and syntax are similar to the mcmc.qpcr function.
</p>


<h3>Value</h3>

<p>An MCMCglmm object. See mcmc.qpcr function for details and examples.
</p>


<h3>Author(s)</h3>

<p>Mikhail V. Matz, University of Texas at Austin
</p>


<h3>References</h3>

<p>Matz MV, Wright RM, Scott JG (2013) No Control Genes Required: Bayesian Analysis of qRT-PCR Data. PLoS ONE 8(8): e71448. doi:10.1371/journal.pone.0071448
</p>

<hr>
<h2 id='mcmc.qpcr.lognormal'>
Fits a lognormal linear mixed model to qRT-PCR data. 
</h2><span id='topic+mcmc.qpcr.lognormal'></span>

<h3>Description</h3>

<p>Use in combination with cq2log(), on datasets without too many Cq values above 30. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc.qpcr.lognormal(fixed=NULL, globalFixed=NULL, random = NULL, globalRandom=NULL, data, 
controls = NULL, normalize=FALSE, include = NULL, m.fix = 1.2, v.fix = NULL, 
geneSpecRes=TRUE, Covar=FALSE, vprior="uninf", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmc.qpcr.lognormal_+3A_fixed">fixed</code></td>
<td>

<p>desired combination of fixed effects, as a text string. Do not use &quot;*&quot; symbol, list
it fully, such as: 'factor1+factor2+factor1:factor2'. 
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr.lognormal_+3A_globalfixed">globalFixed</code></td>
<td>

<p>Vector of fixed covariates (categorical or continuous) that are expected to affect
all genes in the sample in the same way. These would be typically related to quality 
and/or quantity of RNA, such as RIN value.
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr.lognormal_+3A_random">random</code></td>
<td>

<p>A vector of names for gene-specific scalar random effects, such as 'c(&quot;effect1&quot;,&quot;effect2&quot;)'.
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr.lognormal_+3A_globalrandom">globalRandom</code></td>
<td>

<p>Random covariates (categorical only) affecting all genes, similar to globalFixed. 
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr.lognormal_+3A_data">data</code></td>
<td>

<p>output of the cq2counts() function
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr.lognormal_+3A_controls">controls</code></td>
<td>

<p>Vector of control gene names. These will be pushed to the back of the gene list during
model fitting, in the reverse order. Controls are NOT NECESSARY for the analysis.
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr.lognormal_+3A_normalize">normalize</code></td>
<td>

<p>If controls are specified, requiring 'normalize=TRUE' will perform &quot;soft normalization&quot;:
the geometric mean of control genes will be used to infer global effects 
(common to all genes) across conditions; these will be subtracted when summarizing the data
with HPDsummary(). Use this option when template abundances are correlated with 
conditions. Note that this is different from normalizing data within each sample, as per
Vandesompele et al 2002; this would be &quot;hard normalization&quot; (use mcmc.qpcr.classic() if you want it).
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr.lognormal_+3A_include">include</code></td>
<td>

<p>How many of the control genes ('controls') to actually incorporate as priors during model
fitting. If left unspecified, all the 'controls' will be used. If 'include=0', the model
will be fitted without using any of the control genes as priors. If 'include' equals some number 
less than the number of 'controls', 
only the first 'include' of them will be used as priors. In all these cases, 
the 'controls' will appear in the same order in the output, in the end of the gene list
rather than according to their alphabetical position among other genes. This is useful when 
visually comparing the results of models fitted with different number of control genes, using 
HPDplot and HPDpoints functions. 
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr.lognormal_+3A_m.fix">m.fix</code></td>
<td>

<p>Allowed average fold-change of the control genes in response to any fixed factor combination.
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr.lognormal_+3A_v.fix">v.fix</code></td>
<td>

<p>Allowed residual fold-change deviation of the control genes. Applies to the residual variation term.
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr.lognormal_+3A_genespecres">geneSpecRes</code></td>
<td>

<p>Whether the model should include gene-specific residuals.
Keep it TRUE unless the model fails to converge. 
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr.lognormal_+3A_covar">Covar</code></td>
<td>

<p>Whether the random effects should be fitted with covariances. This option might require setting vprior=&quot;iw&quot; or vprior=&quot;iw01&quot; (see below)
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr.lognormal_+3A_vprior">vprior</code></td>
<td>

<p>The default prior is an uninformative inverse Wishart with assumed variance (V) at 1 
and the degree of belief parameter (nu) at 0. With 'prior=&quot;iw&quot;' and 'prior=&quot;iw01&quot;' nu is equal  [number of genes]-0.998, resulting in a weakly informative prior that is commonly used in this type of inference. vprior=&quot;iw&quot; will assume large prior variance (1), vprior=&quot;iw01&quot; will assume small prior variance (0.1). 
</p>
</td></tr>
<tr><td><code id="mcmc.qpcr.lognormal_+3A_...">...</code></td>
<td>

<p>other options for MCMCglmm function, such as nitt (number of iterations), thin (tinning interval), and burnin (number of initial iterations to disregard). For a more precise inference specify 'nitt=45000, thin=20, burnin=5000'. See MCMCglmm documentation for more details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function constructs priors and runs an MCMC chain to fit a lognormal linear mixed model to the log-transformed relative abundances data. The data for this function must be prepared by cq2log instead of cq2counts function; otherwise, the arguments and syntax are identical to mcmc.qpcr function.
</p>


<h3>Value</h3>

<p>An MCMCglmm object. See mcmc.qpcr function for details and examples.
</p>


<h3>Author(s)</h3>

<p>Mikhail V. Matz, University of Texas at Austin
</p>


<h3>References</h3>

<p>Matz MV, Wright RM, Scott JG (2013) No Control Genes Required: Bayesian Analysis of qRT-PCR Data. PLoS ONE 8(8): e71448. doi:10.1371/journal.pone.0071448
</p>

<hr>
<h2 id='normalize.qpcr'>
Internal function called by mcmc.qpcr.classic
</h2><span id='topic+normalize.qpcr'></span>

<h3>Description</h3>

<p>Performs multigene normalization as per Vandesompele et al 2002, centers the resulting gene expression values around the gene's means
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize.qpcr(data, controls, center = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalize.qpcr_+3A_data">data</code></td>
<td>

<p>The output of cq2log()
</p>
</td></tr>
<tr><td><code id="normalize.qpcr_+3A_controls">controls</code></td>
<td>

<p>Vector of control genes, such as 'controls=c(&quot;eif3h&quot;,&quot;nd5&quot;,&quot;rpl11&quot;)'
</p>
</td></tr>
<tr><td><code id="normalize.qpcr_+3A_center">center</code></td>
<td>

<p>Whether to perform centering around mean or not.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>normalized dataset
</p>


<h3>Author(s)</h3>

<p>Mikhail Matz, UT Austin
</p>


<h3>References</h3>

<p>Matz MV, Wright RM, Scott JG (2013) No Control Genes Required: Bayesian Analysis of qRT-PCR Data. PLoS ONE 8(8): e71448. doi:10.1371/journal.pone.0071448
</p>

<hr>
<h2 id='outlierSamples'>
detects outlier samples in qPCR data 
</h2><span id='topic+outlierSamples'></span>

<h3>Description</h3>

<p>reports samples that have too little starting material relative to others (by default, less by two standard deviations) 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outlierSamples(model, data, z.cutoff = -2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="outlierSamples_+3A_model">model</code></td>
<td>

<p>qPCR model: the output of mcmc.qpcr or mcmc.qpcr.lognormal function fitted with pr=TRUE option 
</p>
</td></tr>
<tr><td><code id="outlierSamples_+3A_data">data</code></td>
<td>

<p>The dataset that was analysed to generate the model (output of cq2counts or cq2log functions)
</p>
</td></tr>
<tr><td><code id="outlierSamples_+3A_z.cutoff">z.cutoff</code></td>
<td>

<p>z-score cutoff to report an outlier sample.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing outlier sample names. 
</p>


<h3>Author(s)</h3>

<p>Mikhail V. Matz, University of Texas at Austin
&lt;matz@utexas.edu&gt;
</p>


<h3>References</h3>

<p>Matz MV, Wright RM, Scott JG (2013) No Control Genes Required: Bayesian Analysis of qRT-PCR Data. PLoS ONE 8(8): e71448. doi:10.1371/journal.pone.0071448
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading Cq data and amplification efficiencies
data(coral.stress) 
data(amp.eff) 
# extracting a subset of data 
cs.short=subset(coral.stress, timepoint=="one")

genecolumns=c(5,6,16,17) # specifying columns corresponding to genes of interest
conditions=c(1:4) # specifying columns containing factors  

# calculating molecule counts and reformatting:
dd=cq2counts(data=cs.short,genecols=genecolumns,
condcols=conditions,effic=amp.eff,Cq1=37) 

# fitting the model
mm=mcmc.qpcr(
	fixed="condition",
	data=dd,
	controls=c("nd5","rpl11"),
	nitt=4000, # remove this line when analyzing real data!
	pr=TRUE
)

# detecting outliers
outliers=outlierSamples(mm,dd)

# removing outliers
dd=dd[!(dd$sample %in% outliers),]

</code></pre>

<hr>
<h2 id='padj.hpdsummary'>
Adjusts p-values within an HPDsummary() object for multiple comparisons 
</h2><span id='topic+padj.hpdsummary'></span>

<h3>Description</h3>

<p>Replaces raw p-values in an object returned by HPDsummary() 
by adjusted p-values corrected for multiple comparisons.
Disregards the entries corresponding to control genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>padj.hpdsummary(hpdsumm, controls = NULL, method = "BH")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="padj.hpdsummary_+3A_hpdsumm">hpdsumm</code></td>
<td>

<p>Output of HPDsummary()
</p>
</td></tr>
<tr><td><code id="padj.hpdsummary_+3A_controls">controls</code></td>
<td>

<p>A vector of control gene names
</p>
</td></tr>
<tr><td><code id="padj.hpdsummary_+3A_method">method</code></td>
<td>

<p>p-value correction method (see function p.adjust), default is Benjamini-Hochberg
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>HPDsummary object with original p-values replaced by the corrected ones.
</p>


<h3>Author(s)</h3>

<p>Mikhail V. Matz, matz@mail.utexas.edu
</p>


<h3>References</h3>

<p>Matz MV, Wright RM, Scott JG (2013) No Control Genes Required: 
Bayesian Analysis of qRT-PCR Data. PLoS ONE 8(8): e71448.
doi:10.1371/journal.pone.0071448
</p>

<hr>
<h2 id='padj.qpcr'>
Calculates adjusted p-values corrected for multiple comparisons
</h2><span id='topic+padj.qpcr'></span>

<h3>Description</h3>

<p>Takes the output of HPDplot(...,plot=FALSE), adds two columns of adjusted p-values (z and mcmc)
Disregards the entries corresponding to control genes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>padj.qpcr(data, controls = NULL, method = "BH")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="padj.qpcr_+3A_data">data</code></td>
<td>

<p>Output of HPDplot(...,plot=FALSE); may be several several such outputs concatenated with rbind
</p>
</td></tr>
<tr><td><code id="padj.qpcr_+3A_controls">controls</code></td>
<td>

<p>A vector of control gene names
</p>
</td></tr>
<tr><td><code id="padj.qpcr_+3A_method">method</code></td>
<td>

<p>p-value correction method (see function p.adjust), default is Benjamini-Hochberg
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The dataframe derived from the input, with added columns &quot;padj.z&quot; and &quot;padj.mcmc&quot;.
See tutorial for examples.
</p>


<h3>Author(s)</h3>

<p>Mikhail V. Matz, matz@mail.utexas.edu
</p>


<h3>References</h3>

<p>Matz MV, Wright RM, Scott JG (2013) No Control Genes Required: Bayesian Analysis of qRT-PCR Data. PLoS ONE 8(8): e71448. doi:10.1371/journal.pone.0071448
</p>

<hr>
<h2 id='PrimEff'>
Determines qPCR amplification efficiencies from dilution series
</h2><span id='topic+PrimEff'></span>

<h3>Description</h3>

<p>Runs linear regression on Cq versus log2(RNA concentration), plots graph,
reports slope (ideally should be -1), and efficiency (with 95 percent credible 
limits)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PrimEff(data, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PrimEff_+3A_data">data</code></td>
<td>

<p>a dataframe containing three columns. First is RNA concentration. This could be
absolute as well as relative concentration (1/dilution factor). 
Second is the Cq value. Third is gene name. Replicate the same name across 
all the corresponding RNA concentrations. The dataframe may contain data for 
multiple genes.
</p>
</td></tr>
<tr><td><code id="PrimEff_+3A_plot">plot</code></td>
<td>

<p>set plot=FALSE if the plot is not required
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Run with at least 8 2-fold dilutions per gene
</p>


<h3>Value</h3>

<p>Plots the regression and under it, the values of slope and efficiency 
(plus and minus one SD). The dataframe may contain 
data for multiple genes, which will all be plotted 
together (so the reasonable limit is something like 25 genes)
</p>
<p>Also returns a dataframe with columns: gene, efficiency, plus one SD, minus one SD, and intercept.
</p>


<h3>Author(s)</h3>

<p>Mikhail V. Matz, UT Austin
&lt;matz@utexas.edu&gt;
</p>


<h3>References</h3>

<p>Matz MV, Wright RM, Scott JG (2013) No Control Genes Required: Bayesian Analysis of qRT-PCR Data. PLoS ONE 8(8): e71448. doi:10.1371/journal.pone.0071448
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dilutions)
PrimEff(dilutions)

</code></pre>

<hr>
<h2 id='softNorm'>
Accessory function to mcmc.qpcr() to perform soft normalization
</h2><span id='topic+softNorm'></span>

<h3>Description</h3>

<p>adds a fake NORM gene with counts equal to geometric mean of conrtol genes,
removes control genes from the dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>softNorm(data,controls)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="softNorm_+3A_data">data</code></td>
<td>

<p>The dataset; output of cq2counts()
</p>
</td></tr>
<tr><td><code id="softNorm_+3A_controls">controls</code></td>
<td>

<p>Vector fo control gene names
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified dataset with NORM gene set as the reference, and no control genes
</p>


<h3>Author(s)</h3>

<p>Mikhail Matz, UT Austin
&lt;matz@utexas.edu&gt;
</p>

<hr>
<h2 id='summaryPlot'>
Wrapper function for ggplot2 to make bar and line graphs of 
mcmc.qpcr() results
</h2><span id='topic+summaryPlot'></span>

<h3>Description</h3>

<p>This function is called automatically by HPDsummary() and also
can be used separately to plot the results produced by HPDsummary() 
with more plotting options 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryPlot(data, xgroup, facet = NA, type = "bar", x.order = NA, 
whiskers = "ci", genes = NA, log.base=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summaryPlot_+3A_data">data</code></td>
<td>

<p>A summary table generated by HPDplot(), it is the first element in the 
returned list.
</p>
</td></tr>
<tr><td><code id="summaryPlot_+3A_xgroup">xgroup</code></td>
<td>

<p>Which factor will be used to form the x axis (for 2-way designs).
</p>
</td></tr>
<tr><td><code id="summaryPlot_+3A_facet">facet</code></td>
<td>

<p>The factor by which the plot will be split into facets (for 2-way designs).
</p>
</td></tr>
<tr><td><code id="summaryPlot_+3A_type">type</code></td>
<td>

<p>Two types are supported: &quot;bar&quot; and &quot;line&quot; (&quot;line&quot; also has points). 
&quot;bar&quot; is more useful to plot fold-changes returned when HPDsummary() 
is run with the option 'relative=TRUE'. &quot;line&quot; is better for plotting 
actual inferred transcript abundances across factor levels; it is particularly 
good for time courses and other cases when multiple factor levels must be 
compared to each other. &quot;bar&quot; is good to plot log(fold-changes) relative to 
global control.  
</p>
</td></tr>
<tr><td><code id="summaryPlot_+3A_x.order">x.order</code></td>
<td>

<p>A vector giving the order of factor levels on the x-axis. If unspecified, 
an alphanumeric order will be used.
</p>
</td></tr>
<tr><td><code id="summaryPlot_+3A_whiskers">whiskers</code></td>
<td>

<p>The interval indicated by the whiskers. Default is &quot;ci&quot;, the 95% credible 
interval; another option is &quot;sd&quot; - standard deviation of the posterior.
</p>
</td></tr>
<tr><td><code id="summaryPlot_+3A_genes">genes</code></td>
<td>

<p>Vector of gene names to plot. By default, all genes in the summary will be plotted.
</p>
</td></tr>
<tr><td><code id="summaryPlot_+3A_log.base">log.base</code></td>
<td>

<p>Base of the logarithm to indicate on y-axis (does not affect plotting).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function invokes ggplot() functon from the ggplot2 package to plot 
the results either as a single panel (one-way designs) or a multi-panel 
(2-way designs, one panel per level of the factor specified by 'facet' argument).
</p>


<h3>Value</h3>

<p>A ggplot object. See http://docs.ggplot2.org/0.9.2.1/theme.html for ways 
to modify it, such as add text, rotate labels, change fonts, etc.
</p>


<h3>Author(s)</h3>

<p>Mikhail V. Matz, University of Texas at Austin
&lt;matz@utexas.edu&gt;
</p>


<h3>References</h3>

<p>Matz MV, Wright RM, Scott JG (2013) No Control Genes Required: Bayesian 
Analysis of qRT-PCR Data. PLoS ONE 8(8): e71448. doi:10.1371/journal.pone.0071448
</p>

<hr>
<h2 id='trellisByGene'>
For two-way designs, plots mcmc.qpcr model predictions gene by gene
</h2><span id='topic+trellisByGene'></span>

<h3>Description</h3>

<p>For each gene, plots model-predicted values and 95% credible intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trellisByGene(modelSummary,xFactor,groupFactor,
nrow=2,lineWidth=0.4,whiskerWidth=0.2,pointSize=2.5,
facetScales="free_y",ylab="log(abundance)",
legendPos="bottom",posDodge=0.3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trellisByGene_+3A_modelsummary">modelSummary</code></td>
<td>

<p>two-way design model summary produced by HPDsummary()
</p>
</td></tr>
<tr><td><code id="trellisByGene_+3A_xfactor">xFactor</code></td>
<td>

<p>factor to form the x-axis
</p>
</td></tr>
<tr><td><code id="trellisByGene_+3A_groupfactor">groupFactor</code></td>
<td>

<p>factor to form separate lines on the plot
</p>
</td></tr>
<tr><td><code id="trellisByGene_+3A_nrow">nrow</code></td>
<td>

<p>number of rows in the resulting trellis plot
</p>
</td></tr>
<tr><td><code id="trellisByGene_+3A_linewidth">lineWidth</code></td>
<td>

<p>line width, passed as 'lwd' to geom_errorbar function (ggplot2)
</p>
</td></tr>
<tr><td><code id="trellisByGene_+3A_whiskerwidth">whiskerWidth</code></td>
<td>

<p>width of the line denoting 95% CI margin, passed as 'width' to geom_errorbar function (ggplot2)
</p>
</td></tr>
<tr><td><code id="trellisByGene_+3A_pointsize">pointSize</code></td>
<td>

<p>passed as 'size' to geom_point function of ggplot2
</p>
</td></tr>
<tr><td><code id="trellisByGene_+3A_facetscales">facetScales</code></td>
<td>

<p>passed as 'scales' to facet_wrap function of ggplot2
</p>
</td></tr>
<tr><td><code id="trellisByGene_+3A_ylab">ylab</code></td>
<td>

<p>y-axis label
</p>
</td></tr>
<tr><td><code id="trellisByGene_+3A_legendpos">legendPos</code></td>
<td>

<p>passed as 'legend.position' to theme function of ggplot2
</p>
</td></tr>
<tr><td><code id="trellisByGene_+3A_posdodge">posDodge</code></td>
<td>

<p>position dodge, increase for more jitter
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 type object
</p>


<h3>Author(s)</h3>

<p>Mikhal V. Matz, UT Austin, matz@utexas.edu
</p>


<h3>References</h3>

<p>Matz MV, Wright RM, Scott JG (2013) No Control Genes Required: Bayesian Analysis of qRT-PCR Data. PLoS ONE 8(8): e71448. doi:10.1371/journal.pone.0071448
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# loading Cq data and amplification efficiencies
data(coral.stress) 
data(amp.eff) 

genecolumns=c(5,6,16,17) # specifying columns corresponding to genes of interest
conditions=c(1:4) # specifying columns containing factors  

# calculating molecule counts and reformatting:
dd=cq2counts(data=coral.stress,genecols=genecolumns,
condcols=conditions,effic=amp.eff,Cq1=37) 

# fitting the 2-way model
mm=mcmc.qpcr(
	fixed="condition+timepoint+condition:timepoint",
	data=dd,
	nitt=4000 # remark this line to analyze real data!
)

# summarizing results
ss=HPDsummary(mm,data=dd,summ.plot=FALSE)

# plotting predicted means and 95% CIs gene by gene
trellisByGene(ss,xFactor="condition",groupFactor="timepoint")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
