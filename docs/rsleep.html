<!DOCTYPE html><html><head><title>Help for package rsleep</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rsleep}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#a7'><p>A7 spindle detection algorithm</p></a></li>
<li><a href='#adanorm'><p>Adaptive Normalization of a Signal</p></a></li>
<li><a href='#bandpass'><p>Bandpass Filter Function</p></a></li>
<li><a href='#bands_psd'><p>Compute power spectral density of bands listed in the bands argument.</p></a></li>
<li><a href='#chambon2018'><p>Deep Learning Architecture for Temporal Sleep Stage Classification model implementation in Keras.</p></a></li>
<li><a href='#check_events'><p>Check events dataframe format compliance.</p></a></li>
<li><a href='#choi2018'><p>Convolutional neural network for real-time apnea-hypopnea event detection during sleep</p></a></li>
<li><a href='#ckappa'><p>Computes Cohen's Kappa for agreement in the case of 2 raters.</p></a></li>
<li><a href='#clean_oximetry'><p>Clean Oximetry Signal</p></a></li>
<li><a href='#create_xts'><p>Create an XTS Object from Resampled Signals</p></a></li>
<li><a href='#detect_apneic_events'><p>Detect Apneic Events in SpO2 Signal Data</p></a></li>
<li><a href='#detect_rem'><p>Detection of Rapid-Eye Movements (REMs)</p></a></li>
<li><a href='#detect_rpeaks'><p>Detect R peaks in a raw ECG signal.</p></a></li>
<li><a href='#epochs'><p>Split signals into consecutive, non-overlaping epochs according to an events dataframe or an epoch duration.</p></a></li>
<li><a href='#hypnogram'><p>Filter and reorder an events dataframe or a hypnodensity to keep only sleep stages related-events.</p></a></li>
<li><a href='#normalize_cycles'><p>Normalize sleep cycles scored on Noxturnal software from start and stop flags to unique events.</p></a></li>
<li><a href='#periods'><p>Get a dataframe of sleep periods from a hypnogram, continuous or by stages.</p></a></li>
<li><a href='#plot_event'><p>Highlight a scored event over a signal.</p></a></li>
<li><a href='#plot_hypnodensity'><p>Plot a hypnodensity graph.</p></a></li>
<li><a href='#plot_hypnogram'><p>Plot a hypnogram from an events dataframe.</p></a></li>
<li><a href='#psm'><p>Power spectral density using adaptive sine multitaper.</p></a></li>
<li><a href='#pwelch'><p>Power spectral density using Welch's method.</p></a></li>
<li><a href='#read_events_compumedics'><p>Read a stages export from Compumedics software in .txt format.</p></a></li>
<li><a href='#read_events_ndb'><p>Read events from a Resmed Noxturnal .ndb file.</p></a></li>
<li><a href='#read_events_noxturnal'><p>Read a Noxturnal events file (Unicode CSV format)</p></a></li>
<li><a href='#read_events_profusion'><p>Read a annotation file from Compumedics Profusion software in XML format.</p></a></li>
<li><a href='#read_events_sleepedfx'><p>Read a SleepEDFX events file EDF+</p></a></li>
<li><a href='#read_mdf'><p>Read a Morpheo Data Format (MDF) directory to a list.</p></a></li>
<li><a href='#schwabedal2018'><p>Automated Classification of Sleep Stages in Mice with Deep Learning model implementation in Keras.</p></a></li>
<li><a href='#score_mice'><p>Score mice sleep from European Data Format (EDF) files.</p></a></li>
<li><a href='#score_psg'><p>Score 30 seconds epochs from European Data Format (EDF) files.</p></a></li>
<li><a href='#segmentation'><p>Split signals into consecutive, overlapping segments.</p></a></li>
<li><a href='#smooth_hypnogram'><p>Smooth hypnogram epoch, simulating human scorers behaviour.</p></a></li>
<li><a href='#smooth_liang2012'><p>Smooth hypnogram according to the 11 rules described by Liang &amp; Al.</p></a></li>
<li><a href='#spectrogram'><p>Plot the spectrogram of signal.</p></a></li>
<li><a href='#stages_stats'><p>Get stages related statistics in a named vector.</p></a></li>
<li><a href='#train_batches'><p>Trains a model from files batches.</p></a></li>
<li><a href='#transitions'><p>Count and format stages transitions.</p></a></li>
<li><a href='#tst90'><p>Compute TST90, the percentage of time during sleep with an oxygen saturation below 90.</p></a></li>
<li><a href='#write_batches_mice'><p>Write batches from mice records</p></a></li>
<li><a href='#write_batches_psg'><p>Generates files batches from PSG data.</p></a></li>
<li><a href='#write_channel'><p>Write a timeserie to disk using Morpheo Data Format (MDF) guidelines.</p></a></li>
<li><a href='#write_hypnogram_compumedics'><p>Write a XML file containing scored stages for Compumedics software.</p></a></li>
<li><a href='#write_mdf'><p>Write a European Data Format (EDF) record file to disk using Morpheo Data Format (MDF) guidelines</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Sleep Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.12</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolbox for sleep data processing, visualization and analysis. Tools for state of the art automatic sleep stages scoring.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rsleep.org/">https://rsleep.org/</a>, <a href="https://github.com/boupetch/rsleep">https://github.com/boupetch/rsleep</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/boupetch/rsleep/issues">https://github.com/boupetch/rsleep/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, dplyr, edfReader, ggplot2, jsonlite, psd, signal, xml2,
readr, xts</td>
</tr>
<tr>
<td>Suggests:</td>
<td>caret, gridExtra, keras, knitr, reshape2, rmarkdown,
testthat, RSQLite, DBI, SleepCycles, devtools</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-09 15:17:50 UTC; paul</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul Bouchequet <a href="https://orcid.org/0000-0002-4033-2929"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul Bouchequet &lt;paul.bouchequet@frenchkpi.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-09 23:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='a7'>A7 spindle detection algorithm</h2><span id='topic+a7'></span>

<h3>Description</h3>

<p>A sleep spindle detection algorithm that emulates human expert spindle scoring
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a7(
  x,
  sRate,
  window = 0.3,
  step = 0.1,
  butter_order = 5,
  A7absSigPow = 1.25,
  A7relSigPow = 1.6,
  A7sigmaCov = 1.3,
  A7sigmaCorr = 0.69
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="a7_+3A_x">x</code></td>
<td>
<p>EEG signal in uV.</p>
</td></tr>
<tr><td><code id="a7_+3A_srate">sRate</code></td>
<td>
<p>Sample rate of the signal.</p>
</td></tr>
<tr><td><code id="a7_+3A_window">window</code></td>
<td>
<p>Size of the window in seconds. Default: 0.3</p>
</td></tr>
<tr><td><code id="a7_+3A_step">step</code></td>
<td>
<p>Size of the step between windows in seconds. Default: 0.1</p>
</td></tr>
<tr><td><code id="a7_+3A_butter_order">butter_order</code></td>
<td>
<p>Order of the Butterworth filters. Default: 5</p>
</td></tr>
<tr><td><code id="a7_+3A_a7abssigpow">A7absSigPow</code></td>
<td>
<p>A7absSigPow treshold. Default: 1.25</p>
</td></tr>
<tr><td><code id="a7_+3A_a7relsigpow">A7relSigPow</code></td>
<td>
<p>A7relSigPow treshold. Default: 1.6</p>
</td></tr>
<tr><td><code id="a7_+3A_a7sigmacov">A7sigmaCov</code></td>
<td>
<p>A7sigmaCov treshold. Default: 1.3</p>
</td></tr>
<tr><td><code id="a7_+3A_a7sigmacorr">A7sigmaCorr</code></td>
<td>
<p>A7sigmaCorr treshold. Default: 0.69</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A sleep spindle detection algorithm based on 4 features 
computed along segmented signal according to 'window' size 
and 'step' size parameters. 
</p>
<p>1. Absolute sigma power
</p>
<p style="text-align: center;"><code class="reqn">A7absSigPow = \log_{10} \left( \sum_{i=1}^{N} \frac{EEG\sigma_{i}^2}{N} \right)</code>
</p>

<p>2. Relative sigma power 
</p>
<p style="text-align: center;"><code class="reqn">A7relSigPow = zscore\left( \log_{10} \left( \frac{PSA_{11-16Hz}}{PSA_{4.5-30Hz}} \right) \right)</code>
</p>

<p>3. Sigma covariance 
</p>
<p style="text-align: center;"><code class="reqn">A7sigmaCov = zscore\left( \log_{10} \left( \frac{1}{N} \sum_{i=1}^{N} \left( EEG_{bf_i} - \mu_{EEG_{bf}} \right) \left( EEG_{\sigma_i} - \mu_{EEG_{\sigma}} \right) \right) \right)</code>
</p>

<p>4. Sigma correlation
</p>
<p style="text-align: center;"><code class="reqn">A7sigmaCor = \frac{\text{cov}(EEG_{bf}, EEG_{\sigma})}{sd_{EEG_{bf}} * sd_{EEG_{\sigma}}}</code>
</p>



<h3>Value</h3>

<p>Detected spindles and associated features.
</p>


<h3>References</h3>

<p>Lacourse, K., Delfrate, J., Beaudry, J., Peppard, P., &amp; Warby, S. C. (2019). A sleep spindle detection algorithm that emulates human expert spindle scoring. In Journal of Neuroscience Methods (Vol. 316, pp. 3–11). Elsevier BV. https://doi.org/10.1016/j.jneumeth.2018.08.014
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tryCatch({
  fpath &lt;- paste0(tempdir(),"c3m2_n2_200hz_uv.csv")

  download.file(
    url = "https://rsleep.org/data/c3m2_n2_200hz_uv.csv",
    destfile = fpath)

  # Read only a sample of the EEG signal
  s = read.csv(fpath,header = FALSE)[,1][25000:45000]

  file.remove(fpath)

  a7_results = a7(s, 200)

  # Plot the first detected spindle
  data = data.frame(x=s,index=seq_along(s))
  a = a7_results$spindles$idxStart[1]
  b = a7_results$spindles$idxEnd[1]
  data = data[(data$index &lt;= (b+600)) &amp; (data$index &gt;= (a-600)), ]
  library(ggplot2)
  ggplot(data, aes(x = index, y = x)) +
    geom_line() +
    geom_line(data = subset(data, index &gt;= a &amp; index &lt;= b), aes(x = index, y = x), color = "red") +
    labs(x = "Signal index", y = "C3-M2") +
    theme_minimal()
  
  # Visualise features distribution 

  hist(a7_results$df$absSigPow,main = "A7absSigPow")

  hist(a7_results$df$relSigPow,main = "A7relSigPow")

  hist(a7_results$df$sigmaCov,main = "A7sigmaCov")

  hist(a7_results$df$sigmaCorr,main = "A7sigmaCorr") 
 }, error = function(e) {
  print("Error executing this example, check your internet connection.")
  })
</code></pre>

<hr>
<h2 id='adanorm'>Adaptive Normalization of a Signal</h2><span id='topic+adanorm'></span>

<h3>Description</h3>

<p>This function implements an adaptive normalization method on a given respiratory signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adanorm(x, sRate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adanorm_+3A_x">x</code></td>
<td>
<p>Numeric vector representing the input signal to be normalized.</p>
</td></tr>
<tr><td><code id="adanorm_+3A_srate">sRate</code></td>
<td>
<p>Integer value representing the sampling rate of the signal (number of samples per second).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is designed to preserve the parts of the signal where the amplitude of respiration
is small, typically when the body maintains a sleeping posture for extended periods.
</p>
<p>Adaptive normalization first segments the signal into 1 second window
before computing <code class="reqn">A(k)</code> and  is based on the following equations:
</p>
<p>Equation (1) - Mean absolute deviation:
</p>
<p style="text-align: center;"><code class="reqn">A(k) = \frac{1}{fs} \sum_{i=k \cdot fs}^{(k+1) \cdot fs - 1} \left| x(i) \right|</code>
</p>

<p>Equation (2) - Standard deviation:
</p>
<p style="text-align: center;"><code class="reqn">\sigma(k) = \sqrt{\frac{1}{fs-1} \sum_{i=k \cdot fs}^{(k+1) \cdot fs - 1} (x(i) - \bar{x}(k))^2}</code>
</p>

<p>Equation (3) - Adaptive normalization factor, initialized to 1.
</p>
<p style="text-align: center;"><code class="reqn">F_{\text{norm}}(k) = \min\left(0.95F_{\text{norm}}(k-1) + 0.05A(k), 0.95F_{\text{norm}}(k-1) + 0.05\sigma(k)\right)</code>
</p>



<h3>Value</h3>

<p>Numeric vector representing the adaptively normalized signal.
</p>


<h3>References</h3>

<p>Choi, S. H., Yoon, H., Kim, H. S., Kim, H. B., Kwon, H. B., Oh, S. M., Lee, Y. J., &amp; Park, K. S. (2018). Real-time apnea-hypopnea event detection during sleep by convolutional neural networks. In Computers in Biology and Medicine (Vol. 100, pp. 123–131). Elsevier BV. https://doi.org/10.1016/j.compbiomed.2018.06.028
</p>

<hr>
<h2 id='bandpass'>Bandpass Filter Function</h2><span id='topic+bandpass'></span>

<h3>Description</h3>

<p>This function applies a bandpass filter to a signal. 
It first normalizes the high and low frequencies based on the Nyquist frequency,
then creates a Butterworth filter using the 'signal::butter' function,
and finally applies the filter to the signal using 'signal::filtfilt'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bandpass(x, high, low, sRate, order = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bandpass_+3A_x">x</code></td>
<td>
<p>A numeric vector representing the signal to be filtered.</p>
</td></tr>
<tr><td><code id="bandpass_+3A_high">high</code></td>
<td>
<p>The high cutoff frequency for the bandpass filter.</p>
</td></tr>
<tr><td><code id="bandpass_+3A_low">low</code></td>
<td>
<p>The low cutoff frequency for the bandpass filter.</p>
</td></tr>
<tr><td><code id="bandpass_+3A_srate">sRate</code></td>
<td>
<p>The sampling rate of the signal.</p>
</td></tr>
<tr><td><code id="bandpass_+3A_order">order</code></td>
<td>
<p>The order of the Butterworth filter, defaulting to 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector representing the filtered signal.
</p>


<h3>References</h3>

<p>If applicable, add references here.
</p>


<h3>See Also</h3>

<p><code><a href="signal.html#topic+butter">butter</a></code>, <code><a href="signal.html#topic+filtfilt">filtfilt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample_signal &lt;- sin(seq(0, 10, length.out = 1000))
filtered_signal &lt;- bandpass(sample_signal, high = 0.3, low = 0.1, sRate = 100)
</code></pre>

<hr>
<h2 id='bands_psd'>Compute power spectral density of bands listed in the bands argument.</h2><span id='topic+bands_psd'></span>

<h3>Description</h3>

<p>'bands_psd' calculates power spectral densities estimates on bands. Bands are computed from spectrogram bands equal or greater than lower limit and inferior to the upper limit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bands_psd(signal, sRate, bands, normalize = FALSE, method = "pwelch")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bands_psd_+3A_signal">signal</code></td>
<td>
<p>Numerical vector of the signal.</p>
</td></tr>
<tr><td><code id="bands_psd_+3A_srate">sRate</code></td>
<td>
<p>Signal sample rate in Hertz.</p>
</td></tr>
<tr><td><code id="bands_psd_+3A_bands">bands</code></td>
<td>
<p>A list of bands to compute with lower and upper limits in the form 'list(c(0,4),c(4,8))&ldquo;</p>
</td></tr>
<tr><td><code id="bands_psd_+3A_normalize">normalize</code></td>
<td>
<p>A band to normalize (divide) by. Defaults to 'c(0.5,40)'. Can be set up to FALSE for raw results. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="bands_psd_+3A_method">method</code></td>
<td>
<p>Character. Method to use to compute power spectral density. &quot;pwelch&quot; or &quot;psm&quot;. Defaults to &quot;pwelch&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of bands powers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>signal &lt;- sin(seq(0,100,0.01))
bands_psd(bands = list(c(0,4),c(4,8)), signal = signal, sRate = 200)
</code></pre>

<hr>
<h2 id='chambon2018'>Deep Learning Architecture for Temporal Sleep Stage Classification model implementation in Keras.</h2><span id='topic+chambon2018'></span>

<h3>Description</h3>

<p>Keras implementation of the deep learning architecture described by Chambon &amp; Al in &quot;A Deep Learning Architecture for Temporal Sleep Stage Classification Using Multivariate and Multimodal Time Series&quot;. Consecutives polysomnography (PSG) epochs are supposed to be input to the model to fit on categorized stages as output. 'write_batches_psg()' function writes files batches with the right format for 'x' and 'y' values. The model can then be trained using the 'train_batches()' function. 'score_psg()' uses this model to predict PSG epochs from a raw European Data Format (EDF) record.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chambon2018(channels = 6, samples = 6300)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chambon2018_+3A_channels">channels</code></td>
<td>
<p>Integer. Number of channels in each input.</p>
</td></tr>
<tr><td><code id="chambon2018_+3A_samples">samples</code></td>
<td>
<p>Integer. Number of samples in each channel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Keras sequential model.
</p>


<h3>References</h3>

<p>Chambon, S., Galtier, M., Arnal, P., Wainrib, G. and Gramfort, A. (2018) A Deep Learning Architecture for Temporal Sleep Stage Classification Using Multivariate and Multimodal Time Series. IEEE Trans. on Neural Systems and Rehabilitation Engineering 26:(758-769).
</p>

<hr>
<h2 id='check_events'>Check events dataframe format compliance.</h2><span id='topic+check_events'></span>

<h3>Description</h3>

<p>Check events dataframe format compliance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_events(events)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_events_+3A_events">events</code></td>
<td>
<p>Events dataframe. Dataframe must contain <code>begin</code> (<code>POSIXt</code>), <code>end</code> (<code>POSIXt</code>) and <code>event</code> (<code>character</code>) columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean, according to the events dataframe format compliance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>events &lt;- data.frame(begin = as.POSIXct(c(1536967800,1536967830,1536967860), origin = "1970-01-01"))
events$end &lt;- as.POSIXct(c(1536967830,1536967860,1536967890), origin = "1970-01-01")
events$event = c("N3","N3","REM")
rsleep::check_events(events)
</code></pre>

<hr>
<h2 id='choi2018'>Convolutional neural network for real-time apnea-hypopnea event detection during sleep</h2><span id='topic+choi2018'></span>

<h3>Description</h3>

<p>Keras implementation of the deep learning architecture described by Choi &amp; Al in &quot;Real-time apnea-hypopnea event detection during sleep by convolutional neural network&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choi2018(segment_size = 160)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="choi2018_+3A_segment_size">segment_size</code></td>
<td>
<p>Integer. The size of the segment to predict.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Keras sequential model.
</p>


<h3>References</h3>

<p>Choi SH, Yoon H, Kim HS, et al. Real-time apnea-hypopnea event detection during sleep by convolutional neural networks. Computers in Biology and Medicine. 2018;100:123-131.
</p>

<hr>
<h2 id='ckappa'>Computes Cohen's Kappa for agreement in the case of 2 raters.</h2><span id='topic+ckappa'></span>

<h3>Description</h3>

<p>Cohen’s kappa coefficient value is a robust statistical measure of inter-rater agreement published in 1960 by Jacob Cohen. It has been reused by numerous studies in sleep medicine to measure the accuracy of predictions, especially for automatic sleep staging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ckappa(observed, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ckappa_+3A_observed">observed</code></td>
<td>
<p>The vector of observed values (truth).</p>
</td></tr>
<tr><td><code id="ckappa_+3A_predicted">predicted</code></td>
<td>
<p>The vector of predicted values.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cohen J. A Coefficient of Agreement for Nominal Scales. Educational and Psychological Measurement. 1960;20:37-46.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>observed = c("AWA", "N1", "N2", "N3", "REM")
predicted = c("AWA", "AWA", "N2", "N3", "REM")
ckappa(observed, predicted)
</code></pre>

<hr>
<h2 id='clean_oximetry'>Clean Oximetry Signal</h2><span id='topic+clean_oximetry'></span>

<h3>Description</h3>

<p>This function processes an oximetry signal vector to remove values below a specified threshold. 
It is designed to enhance the quality of oximetry data by replacing sub-threshold impossible values 
with the nearest valid data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_oximetry(oximetry, threshold = 70)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_oximetry_+3A_oximetry">oximetry</code></td>
<td>
<p>A numeric vector representing the oximetry signal. 
Each element corresponds to an oximetry reading.</p>
</td></tr>
<tr><td><code id="clean_oximetry_+3A_threshold">threshold</code></td>
<td>
<p>A numeric value setting the minimum acceptable oximetry value. 
Default is 70. Values in 'oximetry' below this threshold will be 
replaced with the nearest value above the threshold or an average 
of the nearest valid values on either side.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function iterates through the 'oximetry' vector. For each value below the 'threshold',
it searches for the nearest valid value (above the threshold) to the left and right. 
If both neighbors are found, it replaces the sub-threshold value with their average. 
If only one valid neighbor is found, it uses that value. 
</p>
<p>The algorithm ensures that the processed signal retains the general pattern of the 
original data while mitigating the impact of anomalously low readings.
</p>


<h3>Value</h3>

<p>A numeric vector of the same length as 'oximetry'. 
Sub-threshold values are replaced based on nearby valid readings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oximetry_data &lt;- c(91, 92, 91, 34, 92, 93, 91)
clean_oximetry(oximetry_data)

</code></pre>

<hr>
<h2 id='create_xts'>Create an XTS Object from Resampled Signals</h2><span id='topic+create_xts'></span>

<h3>Description</h3>

<p>This function takes multiple signals and their corresponding sample rates, 
resamples the signals to the highest sample rate among them, and creates 
an xts (eXtensible Time Series) object with the resampled signals aligned 
according to a provided start time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_xts(signals, sample_rates, start_time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_xts_+3A_signals">signals</code></td>
<td>
<p>A list of numeric vectors representing the signals. 
Each signal in the list should correspond to one sample rate 
in the 'sample_rates' argument.</p>
</td></tr>
<tr><td><code id="create_xts_+3A_sample_rates">sample_rates</code></td>
<td>
<p>A numeric vector containing the sample rates for each 
signal in 'signals'. The length of 'sample_rates' must 
match the length of 'signals'.</p>
</td></tr>
<tr><td><code id="create_xts_+3A_start_time">start_time</code></td>
<td>
<p>The start time for the xts object. This can be a character 
string or an object that can be converted to POSIXct. The 
time is assumed to be in UTC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An xts object containing the resampled signals, with each column 
representing one of the original signals, resampled to the highest 
sample rate among them. The xts object's index starts from 
'start_time' and increments at a rate of 1 divided by the maximum 
sample rate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>signals &lt;- list(rnorm(100), rnorm(100))
sample_rates &lt;- c(1, 2)
start_time &lt;- "2020-01-01 00:00:00"
xts_data &lt;- create_xts(signals, sample_rates, start_time)
plot(xts_data)

</code></pre>

<hr>
<h2 id='detect_apneic_events'>Detect Apneic Events in SpO2 Signal Data</h2><span id='topic+detect_apneic_events'></span>

<h3>Description</h3>

<p>This function implements the algorithm described by Jund &amp; Al in &quot;Real-Time Automatic Apneic Event Detection Using Nocturnal Pulse Oximetry&quot;, 2018.
It analyzes a given SpO2 signal to detect apneic events. It works by resampling the input signal
and applying a series of checks to identify potential apnea instances. The algorithm uses a state machine
with different blocks representing various stages of detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_apneic_events(spo2, sRate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect_apneic_events_+3A_spo2">spo2</code></td>
<td>
<p>A numeric vector representing the SpO2 signal data.</p>
</td></tr>
<tr><td><code id="detect_apneic_events_+3A_srate">sRate</code></td>
<td>
<p>The original sampling rate of the SpO2 signal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of numeric vectors. Each vector represents a detected apneic event, containing the start and end
indices of the event in the resampled signal.
</p>


<h3>References</h3>

<p>Jung, D. W., Hwang, S. H., Cho, J. G., Choi, B. H., Baek, H. J., Lee, Y. J., Jeong, D.-U., &amp; Park, K. S. (2018). Real-Time Automatic Apneic Event Detection Using Nocturnal Pulse Oximetry. In IEEE Transactions on Biomedical Engineering (Vol. 65, Issue 3, pp. 706–712). Institute of Electrical and Electronics Engineers (IEEE). https://doi.org/10.1109/tbme.2017.2715405
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage
spo2_sample &lt;- c(98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88)
sample_rate &lt;- 1  # Assuming 1 Hz sampling rate
detected_apneas &lt;- detect_apneic_events(spo2_sample, sample_rate)
print(detected_apneas)

</code></pre>

<hr>
<h2 id='detect_rem'>Detection of Rapid-Eye Movements (REMs)</h2><span id='topic+detect_rem'></span>

<h3>Description</h3>

<p>Implements the algorithm detailed in Agarwal &amp;Al. &quot;Detection of Rapid-Eye Movements in Sleep Studies.&quot;
This function processes electrooculography (EOG) signals to detect rapid-eye 
movements (REMs) characteristic of REM sleep, applying filters, artifact detection, and angle-based 
inclusion criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_rem(
  roc,
  loc,
  sRate,
  l = 0.5,
  art = 500,
  nip = 120,
  cc = -0.2,
  da = 45,
  dadiff = 15
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect_rem_+3A_roc">roc</code></td>
<td>
<p>Right outer canthus EOG signal vector.</p>
</td></tr>
<tr><td><code id="detect_rem_+3A_loc">loc</code></td>
<td>
<p>Left outer canthus EOG signal vector.</p>
</td></tr>
<tr><td><code id="detect_rem_+3A_srate">sRate</code></td>
<td>
<p>Sampling rate of the EOG signals in Hz.</p>
</td></tr>
<tr><td><code id="detect_rem_+3A_l">l</code></td>
<td>
<p>Window length in seconds for REM detection (default is 0.5).</p>
</td></tr>
<tr><td><code id="detect_rem_+3A_art">art</code></td>
<td>
<p>Artifact threshold, max amplitude allowed in EOG signals to consider the data valid (default is 500).</p>
</td></tr>
<tr><td><code id="detect_rem_+3A_nip">nip</code></td>
<td>
<p>Negative Inflexion Point threshold for REM detection (default is 120).</p>
</td></tr>
<tr><td><code id="detect_rem_+3A_cc">cc</code></td>
<td>
<p>Correlation coefficient threshold for inclusion of a REM event. Negative correlation 
indicates potential REM (default is -0.2).</p>
</td></tr>
<tr><td><code id="detect_rem_+3A_da">da</code></td>
<td>
<p>Desired angle for REM detection (default is 45 degrees).</p>
</td></tr>
<tr><td><code id="detect_rem_+3A_dadiff">dadiff</code></td>
<td>
<p>Acceptable deviation from the desired angle for one eye, if the other eye compensates 
with a larger deviation (default is 15 degrees).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function processes the EOG signals by applying a band-pass Butterworth filter to isolate 
frequencies between 1 and 5 Hz, typical for REMs. It then computes the artifact measure and evaluates 
the signal for REM events based on the slope of the EOG signal segments, correlation between left and 
right signals, and other criteria derived from the REM detection algorithm described by Agarwal et al.
The function returns a list containing filtered EOG signals, artifact measures, and detected REM events
with their characteristics and validity based on the algorithm's criteria.
</p>


<h3>Value</h3>

<p>A list with the following elements:
- 'rocf': Filtered right outer canthus EOG signal.
- 'locf': Filtered left outer canthus EOG signal.
- 'block_art': Maximum absolute amplitude in the EOG channels for the detection block, used for artifact measurement.
- 'cpm': Product of inverted left and right EOG signals, part of REM detection criteria.
- 'cn': Conditioned signal based on 'cpm', with values below a threshold set to 0.
- 'crems': Data frame of candidate REMs with indices, characteristics, and validity flag.
- 'rems': Subset of 'crems' containing only the valid REM events.
</p>


<h3>References</h3>

<p>Agarwal, R., Takeuchi, T., Laroche, S., &amp; Gotman, J. (2005). Detection of Rapid-Eye Movements in 
Sleep Studies. IEEE Transactions on Biomedical Engineering, 52(8), 1390–1396. 
https://doi.org/10.1109/TBME.2005.851512
</p>

<hr>
<h2 id='detect_rpeaks'>Detect R peaks in a raw ECG signal.</h2><span id='topic+detect_rpeaks'></span>

<h3>Description</h3>

<p>'detect_rpeaks' implements the first part of the Pan &amp; Tompkins algorithms to detect R peaks from a raw ECG signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_rpeaks(
  signal,
  sRate,
  lowcut = 0,
  highcut = 15,
  filter_order = 1,
  integration_window = 15,
  refractory = 200,
  return_index = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect_rpeaks_+3A_signal">signal</code></td>
<td>
<p>Numerical vector of ECG signal.</p>
</td></tr>
<tr><td><code id="detect_rpeaks_+3A_srate">sRate</code></td>
<td>
<p>ECG signal sample rate.</p>
</td></tr>
<tr><td><code id="detect_rpeaks_+3A_lowcut">lowcut</code></td>
<td>
<p>Butterworth bandpass filter low cut value.</p>
</td></tr>
<tr><td><code id="detect_rpeaks_+3A_highcut">highcut</code></td>
<td>
<p>Butterworth bandpass filter high cut value.</p>
</td></tr>
<tr><td><code id="detect_rpeaks_+3A_filter_order">filter_order</code></td>
<td>
<p>Butterworth bandpass filter order value.</p>
</td></tr>
<tr><td><code id="detect_rpeaks_+3A_integration_window">integration_window</code></td>
<td>
<p>Convolution window size.</p>
</td></tr>
<tr><td><code id="detect_rpeaks_+3A_refractory">refractory</code></td>
<td>
<p>Minimal space between peaks in milliseconds.</p>
</td></tr>
<tr><td><code id="detect_rpeaks_+3A_return_index">return_index</code></td>
<td>
<p>If TRUE, the index for each R peak is returned instead of the timing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of detected R peaks, expressed in seconds* from the start of the signal. This vector can be used in RHRV using 'RHRV::LoadBeatVector()'.
</p>
<p>*(or samples if return_index is TRUE)
</p>


<h3>References</h3>

<p>Pan, Jiapu, and Willis J. Tompkins. &quot;A real-time QRS detection algorithm.&quot; IEEE Trans. Biomed. Eng 32, no. 3 (1985): 230-236.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tryCatch({
  path &lt;- paste0(tempdir(),"rec_1.dat")
  download.file("https://rsleep.org/data/rec_1.sdat",path)
  ecg &lt;- readBin(path,integer(),500*30)
  peaks &lt;- detect_rpeaks(ecg, sRate = 500)
  unlink(path)
  print(peaks)
  ecg.df &lt;- data.frame(ECG = ecg,Seconds = c(1:length(ecg))/500)
  library(ggplot2)
  ggplot(ecg.df,aes(x = Seconds,y = ECG)) +
    geom_line() + 
    theme_bw() +
    geom_vline(
      data.frame(p = peaks),
      mapping = aes(xintercept = p),
      linetype="dashed",
      color = "red")
}, error = function(e) {
  print("Error executing this example, check your internet connection.")
  })
</code></pre>

<hr>
<h2 id='epochs'>Split signals into consecutive, non-overlaping epochs according to an events dataframe or an epoch duration.</h2><span id='topic+epochs'></span>

<h3>Description</h3>

<p>Split long signals into a list of consecutive epochs according to an events dataframe or an epoch duration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epochs(
  signals,
  sRates,
  resample = max(sRates),
  epoch = 30,
  startTime = 0,
  padding = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epochs_+3A_signals">signals</code></td>
<td>
<p>A list of numeric vectors containing signals, or a single vector containing one signal.</p>
</td></tr>
<tr><td><code id="epochs_+3A_srates">sRates</code></td>
<td>
<p>A vector or list of integer values of the signals sample rates.</p>
</td></tr>
<tr><td><code id="epochs_+3A_resample">resample</code></td>
<td>
<p>The sample rate to resample all signals. Defaults to to the max of the provided sample rates.</p>
</td></tr>
<tr><td><code id="epochs_+3A_epoch">epoch</code></td>
<td>
<p>Epochs reference. Can be an events dataframe or the number of seconds of each epoc Defaults to 30.</p>
</td></tr>
<tr><td><code id="epochs_+3A_starttime">startTime</code></td>
<td>
<p>The start timestamp of the signal, used to join events to epoch.</p>
</td></tr>
<tr><td><code id="epochs_+3A_padding">padding</code></td>
<td>
<p>Number of previous and next epochs to pad the current epoch with. This functionnality is mostly used to enrich deep learning datasets. Defaults to 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of signal chunks
</p>


<h3>Examples</h3>

<pre><code class='language-R'>epochs(list(rep(c(1,2,3,4),100),rep(c(5,6,7,8),100)),4,4,1,padding = 2)
</code></pre>

<hr>
<h2 id='hypnogram'>Filter and reorder an events dataframe or a hypnodensity to keep only sleep stages related-events.</h2><span id='topic+hypnogram'></span>

<h3>Description</h3>

<p>Remove non-sleep stages events and reorder dataframe rows using the <code>begin</code> column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypnogram(
  events,
  labels = c("N3", "N2", "N1", "REM", "AWA"),
  startTime = 946681200,
  epoch_duration = 30,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hypnogram_+3A_events">events</code></td>
<td>
<p>Events dataframe. Dataframe must have <code>begin</code> (<code>POSIXt</code>), <code>end</code> (<code>POSIXt</code>) and <code>event</code></p>
</td></tr>
<tr><td><code id="hypnogram_+3A_labels">labels</code></td>
<td>
<p>Sleep stages labels. Defaults to <code>c("N3","N2","N1","REM","AWA")</code>.</p>
</td></tr>
<tr><td><code id="hypnogram_+3A_starttime">startTime</code></td>
<td>
<p>Hypnogram start time. Used when a hypnodensity dataframe is passed as events. Defaults to 946681200.</p>
</td></tr>
<tr><td><code id="hypnogram_+3A_epoch_duration">epoch_duration</code></td>
<td>
<p>Epoch duration in seconds. Used when a hypnodensity dataframe is passed as events. Defaults to 30.</p>
</td></tr>
<tr><td><code id="hypnogram_+3A_plot">plot</code></td>
<td>
<p>Plot the hypnogram or in not using <code>ggplot2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Hypnogram dataframe or plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tryCatch({
  fpath &lt;- paste0(tempdir(),"/15012016HD.csv")

  download.file("https://rsleep.org/data/15012016HD.csv",fpath, method="curl")

  events &lt;- read_events_noxturnal(fpath)

  unlink(fpath)

  hypnogram(events)
 }, error = function(e) {
  print("Error executing this example, check your internet connection.")
  })
</code></pre>

<hr>
<h2 id='normalize_cycles'>Normalize sleep cycles scored on Noxturnal software from start and stop flags to unique events.</h2><span id='topic+normalize_cycles'></span>

<h3>Description</h3>

<p>Normalize sleep cycles scored on Noxturnal software from start and stop flags to unique events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_cycles(events)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_cycles_+3A_events">events</code></td>
<td>
<p>Events dataframe. Dataframe must have <code>begin</code> (<code>POSIXt</code>), <code>end</code> (<code>POSIXt</code>) and <code>event</code>. Cycles flags must be named <code>Activity-CLASSICstart</code>, <code>Activity-BNstart</code>, <code>Activity-BNend</code>, <code>Activity-REMstart</code>, <code>Activity-REMend</code>, <code>Activity-ENstart</code> or <code>Activity-ENend</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cycles &lt;- data.frame(event = c("Activity-CLASSICstart","Activity-CLASSICend"))
cycles$begin &lt;- as.POSIXct(c("2016-01-16 01:13:30","2016-01-16 01:15:30"))
cycles$end &lt;- as.POSIXct(c("2016-01-16 01:13:30","2016-01-16 01:15:30"))
normalize_cycles(cycles)
</code></pre>

<hr>
<h2 id='periods'>Get a dataframe of sleep periods from a hypnogram, continuous or by stages.</h2><span id='topic+periods'></span>

<h3>Description</h3>

<p>Get a dataframe of sleep periods from a hypnogram, continuous or by stages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>periods(
  hypnogram,
  mode = "continuous",
  stages = c("N1", "N2", "N3", "N4", "REM")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="periods_+3A_hypnogram">hypnogram</code></td>
<td>
<p>A hypnogram dataframe. Dataframe must contain <code>begin</code> (<code>POSIXt</code>), <code>end</code> (<code>POSIXt</code>) and <code>event</code> (<code>character</code>) columns.</p>
</td></tr>
<tr><td><code id="periods_+3A_mode">mode</code></td>
<td>
<p>Period mode. <code>"continuous"</code> computes periods of N1, N2, N3 or REM sleep, regardless of stage. <code>"stages"</code> computes periods of sleep by stage.</p>
</td></tr>
<tr><td><code id="periods_+3A_stages">stages</code></td>
<td>
<p>Stages to include in periods. Defaults to 'c(&quot;N1&quot;, &quot;N2&quot;, &quot;N3&quot;, &quot;N4&quot;, &quot;REM&quot;)'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of periods with their begin and stop times, duration and stages for stage mode.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tryCatch({
library(ggplot2)

download.file(
 "https://rsleep.org/data/hypnodensity.csv",
 "hypnodensity.csv")

hypnodensity &lt;- read.csv2("hypnodensity.csv")

unlink("hypnodensity.csv")

events &lt;- hypnogram(hypnodensity)

periods_continuous &lt;- periods(events, mode = "continuous")

ggplot(periods_continuous, aes(x=duration)) + geom_histogram(bins = 30)

periods_stages &lt;- periods(events, mode = "stages")
 
ggplot(periods_stages, aes(x=event,y=duration,color=event)) + geom_boxplot()
}, error = function(e) {
  print("Error executing this example, check your internet connection.")
  })
</code></pre>

<hr>
<h2 id='plot_event'>Highlight a scored event over a signal.</h2><span id='topic+plot_event'></span>

<h3>Description</h3>

<p>Highlight a scored event over a signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_event(signal, sRate, sig_start, event_start, event_end, window = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_event_+3A_signal">signal</code></td>
<td>
<p>The signal vector.</p>
</td></tr>
<tr><td><code id="plot_event_+3A_srate">sRate</code></td>
<td>
<p>Sample rate of the signal.</p>
</td></tr>
<tr><td><code id="plot_event_+3A_sig_start">sig_start</code></td>
<td>
<p>Date-Time value of the signal start.</p>
</td></tr>
<tr><td><code id="plot_event_+3A_event_start">event_start</code></td>
<td>
<p>Date-Time value of the event start.</p>
</td></tr>
<tr><td><code id="plot_event_+3A_event_end">event_end</code></td>
<td>
<p>Date-Time value of the event end.</p>
</td></tr>
<tr><td><code id="plot_event_+3A_window">window</code></td>
<td>
<p>Number of seconds of signal to plot before, and after.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the highlighted event over the signal.
</p>

<hr>
<h2 id='plot_hypnodensity'>Plot a hypnodensity graph.</h2><span id='topic+plot_hypnodensity'></span>

<h3>Description</h3>

<p>Plot a hypnodensity graph using 'ggplot2'. Hypnodensity can be read from file or returned by the 'score_stages_edf' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_hypnodensity(
  hypnodensity,
  stages = c("AWA", "REM", "N1", "N2", "N3"),
  colors = c("#5BBCD6", "#FF0000", "#00A08A", "#F2AD00", "#F98400")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_hypnodensity_+3A_hypnodensity">hypnodensity</code></td>
<td>
<p>A hypnodensity dataframe as returned by the 'score_stages_edf' function.</p>
</td></tr>
<tr><td><code id="plot_hypnodensity_+3A_stages">stages</code></td>
<td>
<p>Vector of stages labels to plot.</p>
</td></tr>
<tr><td><code id="plot_hypnodensity_+3A_colors">colors</code></td>
<td>
<p>Vector of colors to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'ggplot2' hypnodensity graph.
</p>


<h3>References</h3>

<p>Stephansen, J.B., Olesen, A.N., Olsen, M., Ambati, A., Leary, E.B., Moore, H.E., Carrillo, O., Lin, L., Han, F., Yan, H. and Sun, Y.L., 2018. Neural network analysis of sleep stages enables efficient diagnosis of narcolepsy. Nature communications, 9(1), p.5229.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tryCatch({
download.file("https://rsleep.org/data/hypnodensity.csv", "hypnodensity.csv")

hypnodensity &lt;- read.csv2("hypnodensity.csv")

unlink("hypnodensity.csv")

plot_hypnodensity(hypnodensity)
}, error = function(e) {
  print("Error executing this example, check your internet connection.")
  })
</code></pre>

<hr>
<h2 id='plot_hypnogram'>Plot a hypnogram from an events dataframe.</h2><span id='topic+plot_hypnogram'></span>

<h3>Description</h3>

<p>Plot a hypnogram from an events dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_hypnogram(events, labels = c("N3", "N2", "N1", "REM", "AWA"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_hypnogram_+3A_events">events</code></td>
<td>
<p>Events dataframe. Dataframe must have <code>begin</code> (<code>POSIXt</code>), <code>end</code> (<code>POSIXt</code>) and <code>event</code></p>
</td></tr>
<tr><td><code id="plot_hypnogram_+3A_labels">labels</code></td>
<td>
<p>Sleep stages labels. Defaults to <code>c("N3","N2","N1","REM","AWA")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hypnogram &lt;- data.frame(begin = as.POSIXlt(
c(1536967800,1536967830,1536967860),origin = "1970-01-01"))
hypnogram$end &lt;- as.POSIXlt(c(1536967830,1536967860,1536967890), 
origin = "1970-01-01")
hypnogram$event = c("N3","N3","REM")
plot_hypnogram(hypnogram)

</code></pre>

<hr>
<h2 id='psm'>Power spectral density using adaptive sine multitaper.</h2><span id='topic+psm'></span>

<h3>Description</h3>

<p>Power spectral density using adaptive sine multitaper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psm(x, sRate, length = 0, show = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psm_+3A_x">x</code></td>
<td>
<p>Signal vector.</p>
</td></tr>
<tr><td><code id="psm_+3A_srate">sRate</code></td>
<td>
<p>Sample rate of the signal.</p>
</td></tr>
<tr><td><code id="psm_+3A_length">length</code></td>
<td>
<p>periodogram resolution. 0 default to not resize.</p>
</td></tr>
<tr><td><code id="psm_+3A_show">show</code></td>
<td>
<p>todo</p>
</td></tr>
</table>


<h3>Value</h3>

<p>peridodogram plotted or raw.
</p>


<h3>References</h3>

<p>Barbour, A. J. and R. L. Parker (2014), psd: Adaptive, sine multitaper power spectral density estimation for R, Computers &amp; Geosciences, Volume 63, February 2014, Pages 1-8, ISSN 0098-3004, http://dx.doi.org/10.1016/j.cageo.2013.09.015
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sin(c(1:10000))
psd &lt;- psm(x, 200, 100)
head(psd)
</code></pre>

<hr>
<h2 id='pwelch'>Power spectral density using Welch's method.</h2><span id='topic+pwelch'></span>

<h3>Description</h3>

<p>Power spectral density using Welch's method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pwelch(x, sRate, points = 0, overlap = 0, padding = 0, show = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pwelch_+3A_x">x</code></td>
<td>
<p>Signal vector.</p>
</td></tr>
<tr><td><code id="pwelch_+3A_srate">sRate</code></td>
<td>
<p>Sample rate of the signal.</p>
</td></tr>
<tr><td><code id="pwelch_+3A_points">points</code></td>
<td>
<p>todo</p>
</td></tr>
<tr><td><code id="pwelch_+3A_overlap">overlap</code></td>
<td>
<p>todo</p>
</td></tr>
<tr><td><code id="pwelch_+3A_padding">padding</code></td>
<td>
<p>todo</p>
</td></tr>
<tr><td><code id="pwelch_+3A_show">show</code></td>
<td>
<p>todo</p>
</td></tr>
</table>


<h3>Value</h3>

<p>peridodogram plotted or raw
</p>


<h3>References</h3>

<p>Welch, P. “The Use of Fast Fourier Transform for the Estimation of Power Spectra: A Method Based on Time Averaging over Short, Modified Periodograms.” IEEE Transactions on Audio and Electroacoustics 15, no. 2 (June 1967): 70–73. https://doi.org/10.1109/TAU.1967.1161901.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sin(c(1:10000))
psd &lt;- pwelch(sin(c(1:10000)), 200)
head(psd)
</code></pre>

<hr>
<h2 id='read_events_compumedics'>Read a stages export from Compumedics software in .txt format.</h2><span id='topic+read_events_compumedics'></span>

<h3>Description</h3>

<p>Read a stages export from Compumedics software in .txt format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_events_compumedics(
  txt,
  startTime = as.POSIXlt("2000-01-01"),
  labels = c(AWA = 0, N1 = 1, N2 = 2, N3 = 3, REM = 5)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_events_compumedics_+3A_txt">txt</code></td>
<td>
<p>txt file path.</p>
</td></tr>
<tr><td><code id="read_events_compumedics_+3A_starttime">startTime</code></td>
<td>
<p>Character string or date object of the hypnogram start.</p>
</td></tr>
<tr><td><code id="read_events_compumedics_+3A_labels">labels</code></td>
<td>
<p>Labels and values as a named list. Defaults to c(&quot;AWA&quot; = 0, &quot;N1&quot; = 1, &quot;N2&quot; = 2, &quot;N3&quot; = 3, &quot;REM&quot; = 5).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of stages.
</p>

<hr>
<h2 id='read_events_ndb'>Read events from a Resmed Noxturnal .ndb file.</h2><span id='topic+read_events_ndb'></span>

<h3>Description</h3>

<p>Read events from a Resmed Noxturnal .ndb file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_events_ndb(data_file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_events_ndb_+3A_data_file">data_file</code></td>
<td>
<p>.ndb file path.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An events dataframe.
</p>

<hr>
<h2 id='read_events_noxturnal'>Read a Noxturnal events file (Unicode CSV format)</h2><span id='topic+read_events_noxturnal'></span>

<h3>Description</h3>

<p>Read a Noxturnal events file (Unicode CSV format)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_events_noxturnal(dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_events_noxturnal_+3A_dir">dir</code></td>
<td>
<p>Noxturnal events file path.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of scored events.
</p>

<hr>
<h2 id='read_events_profusion'>Read a annotation file from Compumedics Profusion software in XML format.</h2><span id='topic+read_events_profusion'></span>

<h3>Description</h3>

<p>Read a annotation file from Compumedics Profusion software in XML format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_events_profusion(xml, startTime = as.POSIXlt("1970-01-01 00:00:00"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_events_profusion_+3A_xml">xml</code></td>
<td>
<p>XML file path.</p>
</td></tr>
<tr><td><code id="read_events_profusion_+3A_starttime">startTime</code></td>
<td>
<p>Character string or date object of the hypnogram start.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of stages and events.
</p>

<hr>
<h2 id='read_events_sleepedfx'>Read a SleepEDFX events file EDF+</h2><span id='topic+read_events_sleepedfx'></span>

<h3>Description</h3>

<p>Read a SleepEDFX events file EDF+
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_events_sleepedfx(dir, update = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_events_sleepedfx_+3A_dir">dir</code></td>
<td>
<p>EDF+ path</p>
</td></tr>
<tr><td><code id="read_events_sleepedfx_+3A_update">update</code></td>
<td>
<p>merge N3 and N4 or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of scored events.
</p>

<hr>
<h2 id='read_mdf'>Read a Morpheo Data Format (MDF) directory to a list.</h2><span id='topic+read_mdf'></span>

<h3>Description</h3>

<p>Read a Morpheo Data Format (MDF) directory to a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_mdf(mdfPath, channels = c(NA), metadata = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_mdf_+3A_mdfpath">mdfPath</code></td>
<td>
<p>character. MDF path.</p>
</td></tr>
<tr><td><code id="read_mdf_+3A_channels">channels</code></td>
<td>
<p>character. Channels to read.</p>
</td></tr>
<tr><td><code id="read_mdf_+3A_metadata">metadata</code></td>
<td>
<p>boolean. Read or not the metadata.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list.
</p>


<h3>References</h3>

<p>P. Bouchequet, D. Jin, G. Solelhac, M. Chennaoui, D. Leger, &quot;Morpheo Data Format (MDF), un nouveau format de données simple, robuste et performant pour stocker et analyser les enregistrements de sommeil&quot;, Médecine du Sommeil, vol. 15, n 1, p. 48/49, march 2018.
</p>

<hr>
<h2 id='schwabedal2018'>Automated Classification of Sleep Stages in Mice with Deep Learning model implementation in Keras.</h2><span id='topic+schwabedal2018'></span>

<h3>Description</h3>

<p>Model inspired by the article &quot;Automated Classification of Sleep Stages and EEG Artifacts in Mice with Deep Learning&quot;. Implemented using Keras. Adapted to use minimum 2 channels and to not score artifact epochs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>schwabedal2018(channels = 2, samples = 8000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="schwabedal2018_+3A_channels">channels</code></td>
<td>
<p>Number of channels in each input.</p>
</td></tr>
<tr><td><code id="schwabedal2018_+3A_samples">samples</code></td>
<td>
<p>Number of samples in each channel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Keras sequential model.
</p>


<h3>References</h3>

<p>Schwabedal, Justus T. C., Daniel Sippel, Moritz D. Brandt, and Stephan Bialonski. “Automated Classification of Sleep Stages and EEG Artifacts in Mice with Deep Learning.” ArXiv:1809.08443 [Cs, q-Bio], September 22, 2018. http://arxiv.org/abs/1809.08443.
</p>

<hr>
<h2 id='score_mice'>Score mice sleep from European Data Format (EDF) files.</h2><span id='topic+score_mice'></span>

<h3>Description</h3>

<p>Score mice sleep from European Data Format (EDF) files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score_mice(edf, model, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score_mice_+3A_edf">edf</code></td>
<td>
<p>Character. European Data Format (EDF) file path.</p>
</td></tr>
<tr><td><code id="score_mice_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
<tr><td><code id="score_mice_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. Display or not status messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing predicted hypnodensity values of the record.
</p>

<hr>
<h2 id='score_psg'>Score 30 seconds epochs from European Data Format (EDF) files.</h2><span id='topic+score_psg'></span>

<h3>Description</h3>

<p>Score 30 seconds epochs from European Data Format (EDF) files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score_psg(
  edf,
  channels = c("C3-M2", "C4-M1", "O1-M2", "E1-M2", "E2-M1", "1-2"),
  model = chambon2018(6, 3 * 30 * 70),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score_psg_+3A_edf">edf</code></td>
<td>
<p>Character. European Data Format (EDF) file path.</p>
</td></tr>
<tr><td><code id="score_psg_+3A_channels">channels</code></td>
<td>
<p>A vector containing the channels names if names differ from 'c(&quot;C3-M2&quot;,&quot;C4-M1&quot;,&quot;O1-M2&quot;,&quot;E1-M2&quot;,&quot;E2-M1&quot;,&quot;1-2&quot;)'.</p>
</td></tr>
<tr><td><code id="score_psg_+3A_model">model</code></td>
<td>
<p>The Keras model.</p>
</td></tr>
<tr><td><code id="score_psg_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. Display or not status messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing predicted hypnodensity values of the record.
</p>


<h3>References</h3>

<p>Chambon, S., Galtier, M., Arnal, P., Wainrib, G. and Gramfort, A. (2018) A Deep Learning Architecture for Temporal Sleep Stage Classification Using Multivariate and Multimodal Time Series. IEEE Trans. on Neural Systems and Rehabilitation Engineering 26:(758-769).
</p>
<p>Kemp, B., Värri, A., Rosa, A.C., Nielsen, K.D. and Gade, J., 1992. A simple format for exchange of digitized polygraphic recordings. Electroencephalography and clinical neurophysiology, 82(5), pp.391-393.
</p>

<hr>
<h2 id='segmentation'>Split signals into consecutive, overlapping segments.</h2><span id='topic+segmentation'></span>

<h3>Description</h3>

<p>Split signals into consecutive, overlapping segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segmentation(
  signals,
  sRates,
  segments_size = 10,
  step = 1,
  padding = 0,
  resample = max(sRates),
  return_index = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segmentation_+3A_signals">signals</code></td>
<td>
<p>A list of numeric vectors containing signals, or a single vector containing one signal.</p>
</td></tr>
<tr><td><code id="segmentation_+3A_srates">sRates</code></td>
<td>
<p>A vector or list of integer values of the signals sample rates.</p>
</td></tr>
<tr><td><code id="segmentation_+3A_segments_size">segments_size</code></td>
<td>
<p>The size of segments, in seconds.</p>
</td></tr>
<tr><td><code id="segmentation_+3A_step">step</code></td>
<td>
<p>The step between segments, in seconds.</p>
</td></tr>
<tr><td><code id="segmentation_+3A_padding">padding</code></td>
<td>
<p>umber of previous and next epochs to pad the current epoch with. Defaults to 0.</p>
</td></tr>
<tr><td><code id="segmentation_+3A_resample">resample</code></td>
<td>
<p>The sample rate to resample all signals. Defaults to to the max of the provided sample rates.</p>
</td></tr>
<tr><td><code id="segmentation_+3A_return_index">return_index</code></td>
<td>
<p>If TRUE, the index of segments is returned instead of the segments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of segments.
</p>


<h3>References</h3>

<p>Choi SH, Yoon H, Kim HS, et al. Real-time apnea-hypopnea event detection during sleep by convolutional neural networks. Computers in Biology and Medicine. 2018;100:123-131.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>computed_segments = segmentation(
  signals = list(c(sin(1:1000)),c(cos(1:1000))),
  sRates = c(1, 1),
  segments_size = 5,
  resample = 1)
dim(computed_segments)
plot(computed_segments[1,,1], type = "l")
plot(computed_segments[2,,1], type = "l")
</code></pre>

<hr>
<h2 id='smooth_hypnogram'>Smooth hypnogram epoch, simulating human scorers behaviour.</h2><span id='topic+smooth_hypnogram'></span>

<h3>Description</h3>

<p>Smooth hypnograms epoch, simulating human scorers behaviour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_hypnogram(hypnogram, event = "N2", neighbors = "REM", count = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_hypnogram_+3A_hypnogram">hypnogram</code></td>
<td>
<p>A hypnogram dataframe.</p>
</td></tr>
<tr><td><code id="smooth_hypnogram_+3A_event">event</code></td>
<td>
<p>Central stage label.</p>
</td></tr>
<tr><td><code id="smooth_hypnogram_+3A_neighbors">neighbors</code></td>
<td>
<p>Extremities stages labels.</p>
</td></tr>
<tr><td><code id="smooth_hypnogram_+3A_count">count</code></td>
<td>
<p>Number of consecutive central stages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A hypnogram dataframe.
</p>


<h3>References</h3>

<p>Liang, Sheng-Fu, Chin-En Kuo, Yu-Han Hu, Yu-Hsiang Pan, and Yung-Hung Wang. &quot;Automatic stage scoring of single-channel sleep EEG by using multiscale entropy and autoregressive models.&quot; IEEE Transactions on Instrumentation and Measurement 61, no. 6 (2012): 1649-1657.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hypnogram &lt;- data.frame(begin = as.POSIXlt(
c(1536967800,1536967830,1536967860),origin = "1970-01-01"))
hypnogram$end &lt;- as.POSIXlt(c(1536967830,1536967860,1536967890), 
origin = "1970-01-01")
hypnogram$event = c("REM","N2","REM")
smooth_hypnogram(hypnogram, "N2","REM",1)
</code></pre>

<hr>
<h2 id='smooth_liang2012'>Smooth hypnogram according to the 11 rules described by Liang &amp; Al.</h2><span id='topic+smooth_liang2012'></span>

<h3>Description</h3>

<p>Smooth hypnogram according to the 11 rules described by Liang &amp; Al.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_liang2012(hypnogram)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_liang2012_+3A_hypnogram">hypnogram</code></td>
<td>
<p>A hypnogram dataframe.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A smoothed hypnogram dataframe.
</p>


<h3>References</h3>

<p>Liang, Sheng-Fu, Chin-En Kuo, Yu-Han Hu, and Yu-Shian Cheng. “A Rule-Based Automatic Sleep Staging Method.” Journal of Neuroscience Methods 205, no. 1 (March 2012): 169–76. https://doi.org/10.1016/j.jneumeth.2011.12.022.
</p>

<hr>
<h2 id='spectrogram'>Plot the spectrogram of signal.</h2><span id='topic+spectrogram'></span>

<h3>Description</h3>

<p>'spectrogram' resamples signal and use the 'specgram' function from the 'signal' library to compute the spectrogram. Results resolution can be then reduced to quickly plot large signals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectrogram(
  signal,
  sRate,
  maxFreq = 25,
  n = 1024,
  window = n,
  overlap = 0,
  cols = c(rep("#3B9AB2", 9), "#78B7C5", "#EBCC2A", "#E1AF00", rep("#F21A00", 6)),
  freq = 4,
  plot = TRUE,
  startTime = as.POSIXct("1970/01/01 00:00:00")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectrogram_+3A_signal">signal</code></td>
<td>
<p>Numerical vector of the signal.</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_srate">sRate</code></td>
<td>
<p>Signal sample rate in Hertz.</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_maxfreq">maxFreq</code></td>
<td>
<p>Maximal frequency to plot in Hertz. Signal will be resampled at maxFreq*2 sample rate.</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_n">n</code></td>
<td>
<p>The size of the Fourier transform window.</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_window">window</code></td>
<td>
<p>Shape of the fourier transform window, defaults to n.</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_overlap">overlap</code></td>
<td>
<p>Overlap with previous window, defaults to 0.</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_cols">cols</code></td>
<td>
<p>Color scale used for the underlying plot function.</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_freq">freq</code></td>
<td>
<p>Aggregate frequency used to lower spectrogram resolution. Defaults to 4.</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_plot">plot</code></td>
<td>
<p>Boolean, plot or not the spectrogram.</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_starttime">startTime</code></td>
<td>
<p>Posixct of the signal start. Adjust the x axis labels accordingly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A spectrogram.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(signal)
spectrogram(chirp(seq(-2, 15, by = 0.001), 400, 10, 100, 'quadratic'),20,n=1024)
</code></pre>

<hr>
<h2 id='stages_stats'>Get stages related statistics in a named vector.</h2><span id='topic+stages_stats'></span>

<h3>Description</h3>

<p><code>stages_stats</code> computes stages related statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stages_stats(e)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stages_stats_+3A_e">e</code></td>
<td>
<p>Events dataframe. Dataframe must have <code>begin</code> (<code>POSIXt</code>), <code>end</code> (<code>POSIXt</code>) and <code>event</code> (<code>character</code>) columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>stages vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e &lt;- data.frame(begin = as.POSIXlt(seq(from = 0, to = 30*10, by = 30),origin = "1970-01-01"))
e$end &lt;- as.POSIXlt(seq(from = 30, to = 30*11, by = 30), origin = "1970-01-01")
e$event = c("AWA","N1","N2","N3","N3","REM","N2","REM","N2","REM","AWA")
stages_stats(e)
</code></pre>

<hr>
<h2 id='train_batches'>Trains a model from files batches.</h2><span id='topic+train_batches'></span>

<h3>Description</h3>

<p>Trains a model from files batches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>train_batches(model, batches, epochs = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="train_batches_+3A_model">model</code></td>
<td>
<p>Keras model.</p>
</td></tr>
<tr><td><code id="train_batches_+3A_batches">batches</code></td>
<td>
<p>Character vector of batches files.</p>
</td></tr>
<tr><td><code id="train_batches_+3A_epochs">epochs</code></td>
<td>
<p>Integer. Number of epochs to train the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A trained and serialized Keras model.
</p>

<hr>
<h2 id='transitions'>Count and format stages transitions.</h2><span id='topic+transitions'></span>

<h3>Description</h3>

<p>Count and format stages transitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transitions(
  hypnogram,
  stages = c("AWA", "REM", "N1", "N2", "N3", "NREM"),
  format = "vector"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transitions_+3A_hypnogram">hypnogram</code></td>
<td>
<p>A hypnogram dataframe. Dataframe must contain <code>begin</code> (<code>POSIXt</code>), <code>end</code> (<code>POSIXt</code>) and <code>event</code> (<code>character</code>) columns.</p>
</td></tr>
<tr><td><code id="transitions_+3A_stages">stages</code></td>
<td>
<p>Stages to include in transitions Defaults to <code>c("N1", "N2", "N3", "N4", "REM")</code>.</p>
</td></tr>
<tr><td><code id="transitions_+3A_format">format</code></td>
<td>
<p>Set the return format. 'vector', 'dataframe' or 'heatmap'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Count of stages transitions in selected format.
</p>


<h3>References</h3>

<p>Swihart BJ, Punjabi NM, Crainiceanu CM. Modeling sleep fragmentation in sleep hypnograms: An instance of fast, scalable discrete-state, discrete-time analyses. Comput Stat Data Anal. 2015 Sep;89:1-11. doi: 10.1016/j.csda.2015.03.001. PMID: 27182097; PMCID: PMC4865264.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tryCatch({
download.file("https://rsleep.org/data/hypnodensity.csv", "hypnodensity.csv")

hypnodensity &lt;- read.csv2("hypnodensity.csv")

unlink("hypnodensity.csv")

events &lt;- hypnogram(hypnodensity)

transitions(events)

transitions(events, format = "dataframe")

transitions(events, format = "heatmap")

# 3 Dimensions sleep transitions
levels(events$event)[levels(events$event)=="N1"] &lt;- "NREM"
levels(events$event)[levels(events$event)=="N2"] &lt;- "NREM"
levels(events$event)[levels(events$event)=="N3"] &lt;- "NREM"

round(
  transitions(
    events, 
    format = "dataframe")/(
      sum(transitions(events)))*100,2)
}, error = function(e) {
  print("Error executing this example, check your internet connection.")
  })
</code></pre>

<hr>
<h2 id='tst90'>Compute TST90, the percentage of time during sleep with an oxygen saturation below 90.</h2><span id='topic+tst90'></span>

<h3>Description</h3>

<p>Compute TST90, the percentage of time during sleep with an oxygen saturation below 90.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tst90(spo2_signal, sRate, startTime, hypnogram)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tst90_+3A_spo2_signal">spo2_signal</code></td>
<td>
<p>The SpO2 signal vector.</p>
</td></tr>
<tr><td><code id="tst90_+3A_srate">sRate</code></td>
<td>
<p>The SpO2 signal vector sample rate.</p>
</td></tr>
<tr><td><code id="tst90_+3A_starttime">startTime</code></td>
<td>
<p>The SpO2 signal start time.</p>
</td></tr>
<tr><td><code id="tst90_+3A_hypnogram">hypnogram</code></td>
<td>
<p>Events dataframe containing hypnogram.</p>
</td></tr>
</table>

<hr>
<h2 id='write_batches_mice'>Write batches from mice records</h2><span id='topic+write_batches_mice'></span>

<h3>Description</h3>

<p>Write batches from mice records
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_batches_mice(
  records,
  events,
  batches_path = "./",
  batch_size = 128,
  classes_nb = 3,
  padding = 2,
  resample = 400,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_batches_mice_+3A_records">records</code></td>
<td>
<p>Character. Records paths</p>
</td></tr>
<tr><td><code id="write_batches_mice_+3A_events">events</code></td>
<td>
<p>List of events</p>
</td></tr>
<tr><td><code id="write_batches_mice_+3A_batches_path">batches_path</code></td>
<td>
<p>Path to write batches</p>
</td></tr>
<tr><td><code id="write_batches_mice_+3A_batch_size">batch_size</code></td>
<td>
<p>size of each batch</p>
</td></tr>
<tr><td><code id="write_batches_mice_+3A_classes_nb">classes_nb</code></td>
<td>
<p>number of classes</p>
</td></tr>
<tr><td><code id="write_batches_mice_+3A_padding">padding</code></td>
<td>
<p>consecutive epochs to add</p>
</td></tr>
<tr><td><code id="write_batches_mice_+3A_resample">resample</code></td>
<td>
<p>resample rate</p>
</td></tr>
<tr><td><code id="write_batches_mice_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. Display or not status messages.</p>
</td></tr>
</table>

<hr>
<h2 id='write_batches_psg'>Generates files batches from PSG data.</h2><span id='topic+write_batches_psg'></span>

<h3>Description</h3>

<p>Generates train batches from PSG data to be used by the 'train_batches()' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_batches_psg(
  records,
  events,
  batches_path = tempdir(),
  channels = c("C3-M2", "C4-M1", "O1-M2", "E1-M2", "E2-M1", "1-2"),
  resample = 70,
  padding = 1,
  batches_size = 1024,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_batches_psg_+3A_records">records</code></td>
<td>
<p>Character vector of EDF files paths to be included in the train batches.</p>
</td></tr>
<tr><td><code id="write_batches_psg_+3A_events">events</code></td>
<td>
<p>List of events dataframes containing hypnograms corresponding to EDF records in 'records' parameter.</p>
</td></tr>
<tr><td><code id="write_batches_psg_+3A_batches_path">batches_path</code></td>
<td>
<p>Character. Path where batches files will be saved.</p>
</td></tr>
<tr><td><code id="write_batches_psg_+3A_channels">channels</code></td>
<td>
<p>Character vector. Channels labels to include in the dataset.</p>
</td></tr>
<tr><td><code id="write_batches_psg_+3A_resample">resample</code></td>
<td>
<p>Integer. Sample rate to resample selected signals.</p>
</td></tr>
<tr><td><code id="write_batches_psg_+3A_padding">padding</code></td>
<td>
<p>Epochs added before and after each epoch.</p>
</td></tr>
<tr><td><code id="write_batches_psg_+3A_batches_size">batches_size</code></td>
<td>
<p>Number of epochs in each batch file.</p>
</td></tr>
<tr><td><code id="write_batches_psg_+3A_verbose">verbose</code></td>
<td>
<p>Boolean, display status messages or not.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chambon, S., Galtier, M., Arnal, P., Wainrib, G. and Gramfort, A. (2018) A Deep Learning Architecture for Temporal Sleep Stage Classification Using Multivariate and Multimodal Time Series. IEEE Trans. on Neural Systems and Rehabilitation Engineering 26:(758-769).
</p>

<hr>
<h2 id='write_channel'>Write a timeserie to disk using Morpheo Data Format (MDF) guidelines.</h2><span id='topic+write_channel'></span>

<h3>Description</h3>

<p>Write a timeserie to disk using Morpheo Data Format (MDF) guidelines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_channel(channel, signals, headers, mdfPath, endian = .Platform$endian)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_channel_+3A_channel">channel</code></td>
<td>
<p>character. Channel name.</p>
</td></tr>
<tr><td><code id="write_channel_+3A_signals">signals</code></td>
<td>
<p>list. European Data Format (EDF) signals list.</p>
</td></tr>
<tr><td><code id="write_channel_+3A_headers">headers</code></td>
<td>
<p>list. European Data Format (EDF) file headers.</p>
</td></tr>
<tr><td><code id="write_channel_+3A_mdfpath">mdfPath</code></td>
<td>
<p>character. Morpheo Data Format (MDF) directory path.</p>
</td></tr>
<tr><td><code id="write_channel_+3A_endian">endian</code></td>
<td>
<p>character. Endianess. <code>"big"</code> or <code>"little"</code>. Defaults to platform endian.</p>
</td></tr>
</table>


<h3>References</h3>

<p>P. Bouchequet, D. Jin, G. Solelhac, M. Chennaoui, D. Leger, &quot;Morpheo Data Format (MDF), un nouveau format de données simple, robuste et performant pour stocker et analyser les enregistrements de sommeil&quot;, Médecine du Sommeil, vol. 15, n 1, p. 48-49, march 2018.
</p>

<hr>
<h2 id='write_hypnogram_compumedics'>Write a XML file containing scored stages for Compumedics software.</h2><span id='topic+write_hypnogram_compumedics'></span>

<h3>Description</h3>

<p>Write a XML file containing scored stages for Compumedics software.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_hypnogram_compumedics(hypnogram, filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_hypnogram_compumedics_+3A_hypnogram">hypnogram</code></td>
<td>
<p>A rsleep hypnogram dataframe.</p>
</td></tr>
<tr><td><code id="write_hypnogram_compumedics_+3A_filename">filename</code></td>
<td>
<p>character File name to write on disk.</p>
</td></tr>
</table>

<hr>
<h2 id='write_mdf'>Write a European Data Format (EDF) record file to disk using Morpheo Data Format (MDF) guidelines</h2><span id='topic+write_mdf'></span>

<h3>Description</h3>

<p>Write a European Data Format (EDF) record file to disk using Morpheo Data Format (MDF) guidelines. Target directory is erased if it already exists. Signals are stored in binary file, events and metadata in JavaScript Object Notation (JSON) files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_mdf(
  edfPath,
  mdfPath,
  channels = c(NA),
  events = c(),
  endian = .Platform$endian
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_mdf_+3A_edfpath">edfPath</code></td>
<td>
<p>character. European Data Format (EDF) file path.</p>
</td></tr>
<tr><td><code id="write_mdf_+3A_mdfpath">mdfPath</code></td>
<td>
<p>character. Morpheo Data Format (MDF) directory path.</p>
</td></tr>
<tr><td><code id="write_mdf_+3A_channels">channels</code></td>
<td>
<p>character. Vector of channels labels to write.</p>
</td></tr>
<tr><td><code id="write_mdf_+3A_events">events</code></td>
<td>
<p>dataframe. Events dataframe to write. Events dataframe. Dataframe must contain <code>begin</code> (<code>POSIXt</code>), <code>end</code> (<code>POSIXt</code>) and <code>event</code> (<code>character</code>) columns.</p>
</td></tr>
<tr><td><code id="write_mdf_+3A_endian">endian</code></td>
<td>
<p>character. Endianess. <code>"big"</code> or <code>"little"</code>. Defaults to platform endian.</p>
</td></tr>
</table>


<h3>References</h3>

<p>P. Bouchequet, D. Jin, G. Solelhac, M. Chennaoui, D. Leger, &quot;Morpheo Data Format (MDF), un nouveau format de données simple, robuste et performant pour stocker et analyser les enregistrements de sommeil&quot;, Médecine du Sommeil, vol. 15, n 1, p. 48/49, march 2018.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
