<!DOCTYPE html><html><head><title>Help for package Qest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Qest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#internals'><p>Internal Functions</p></a></li>
<li><a href='#invQ'>
<p>Inverse of Quantile Function</p></a></li>
<li><a href='#Qcoxph'>
<p>Q-Estimation of Proportional Hazards Regression Models</p></a></li>
<li><a href='#Qcoxph.control'>
<p>Auxiliary for Controlling Qcoxph Fitting</p></a></li>
<li><a href='#Qest'>
<p>Q-Estimation</p></a></li>
<li><a href='#Qest-package'>
<p>Quantile-Based Estimator</p></a></li>
<li><a href='#Qest.control'>
<p>Auxiliary for Controlling Qest Fitting</p></a></li>
<li><a href='#Qfamily'><p>Family Objects for Qest</p></a></li>
<li><a href='#Qlm'>
<p>Q-Estimation of Linear Regression Models</p></a></li>
<li><a href='#Qlm.fit'>
<p>Fitter Functions for Quantile-based Linear Models</p></a></li>
<li><a href='#summary.Qest'>
<p>Summarizing Q-estimators</p></a></li>
<li><a href='#wtrunc'><p>Weighting Function for <code>Qest</code>, <code>Qlm</code>, and <code>Qcoxph</code>.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Quantile-Based Estimator</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Gianluca Sottile [aut, cre],
  Paolo Frumento [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Quantile-based estimators (Q-estimators) can be used to fit any parametric distribution, using its quantile function. Q-estimators are usually more robust than standard maximum likelihood estimators. The method is described in: Sottile G. and Frumento P. (2022). Robust estimation and regression with parametric quantile functions. &lt;<a href="https://doi.org/10.1016%2Fj.csda.2022.107471">doi:10.1016/j.csda.2022.107471</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>pch, survival, matrixStats, methods, utils</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.sciencedirect.com/science/article/abs/pii/S0167947322000512">https://www.sciencedirect.com/science/article/abs/pii/S0167947322000512</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-23 12:44:22 UTC; gianlucasottile</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-23 13:42:53 UTC</td>
</tr>
</table>
<hr>
<h2 id='internals'>Internal Functions</h2><span id='topic+internals'></span><span id='topic+expit'></span><span id='topic+logit'></span><span id='topic+pmax0'></span><span id='topic+num.fun'></span><span id='topic+formatPerc'></span><span id='topic+Ltau'></span><span id='topic+minabs'></span><span id='topic+invJ'></span><span id='topic+tensorX'></span><span id='topic+buildTau'></span><span id='topic+callwtau'></span><span id='topic+callQ'></span><span id='topic+start.Qest'></span><span id='topic+start.Qest.family'></span><span id='topic+rq.fit.br2'></span><span id='topic+Qest.sgs.internal'></span><span id='topic+Qest.gs.internal'></span><span id='topic+Qest.gs'></span><span id='topic+Qest.newton'></span><span id='topic+Qlm.bfun'></span><span id='topic+start.Qlm'></span><span id='topic+scalevars.Qlm'></span><span id='topic+descalecoef.Qlm'></span><span id='topic+Qlm.sgs.internal'></span><span id='topic+Qlm.gs.internal'></span><span id='topic+Qlm.gs'></span><span id='topic+Qlm.newton'></span><span id='topic+plfcox'></span><span id='topic+scalevars.Qcoxph'></span><span id='topic+descalecoef.Qcoxph'></span><span id='topic+check.singularities'></span><span id='topic+starting.points.Qcox'></span><span id='topic+adjust.coef'></span><span id='topic+agsurv.Qcoxph'></span><span id='topic+basehaz.Qcoxph'></span><span id='topic+coxsurv.fit.Qcoxph'></span><span id='topic+seg.lm.fit1'></span><span id='topic+gs'></span><span id='topic+myg'></span><span id='topic+dlist'></span><span id='topic+omega'></span><span id='topic+choose_eps'></span><span id='topic+derQtheta'></span><span id='topic+der2Qtheta'></span><span id='topic+intA'></span><span id='topic+findp'></span><span id='topic+findAp'></span><span id='topic+A_beta_fun'></span><span id='topic+A_gamma_fun'></span><span id='topic+A_beta_beta_fun'></span><span id='topic+A_gamma_gamma_mix_fun'></span><span id='topic+A_gamma_gamma_fun'></span><span id='topic+A_beta_gamma_fun'></span><span id='topic+coxBB'></span><span id='topic+derQtheta.gamma'></span><span id='topic+der2Qtheta.gamma'></span><span id='topic+findAp.gamma'></span><span id='topic+QestGamma.ee.u'></span><span id='topic+QestGamma.ee.c'></span><span id='topic+QestGamma.ee.ct'></span><span id='topic+tau.pois'></span><span id='topic+ppoisC'></span><span id='topic+dpoisC'></span><span id='topic+qpoisC.955'></span><span id='topic+qpoisC.me'></span><span id='topic+qpoisC.bisec'></span><span id='topic+qpoisC'></span><span id='topic+derQtheta.pois'></span><span id='topic+der2Qtheta.pois'></span><span id='topic+findp.pois'></span><span id='topic+findAp.pois'></span><span id='topic+QestPois.ee.u'></span><span id='topic+QestUnif.ee.u'></span><span id='topic+QestNorm.ee.u'></span><span id='topic+QestNorm.ee.c'></span><span id='topic+QestNorm.ee.ct'></span><span id='topic+Qest.ee.u'></span><span id='topic+Qest.ee.c'></span><span id='topic+Qest.ee.ct'></span><span id='topic+QCox.ee.c'></span><span id='topic+QCox.ee.ct'></span><span id='topic+Qlm.ee.u'></span><span id='topic+Qest.covar'></span><span id='topic+Qcox.covar'></span><span id='topic+Qlm.covar'></span><span id='topic+Loss'></span><span id='topic+coxLoss'></span><span id='topic+qlmLoss'></span><span id='topic+print.Qest'></span><span id='topic+print.summary.Qest'></span><span id='topic+confint.Qest'></span><span id='topic+vcov.Qest'></span><span id='topic+summary.Qlm'></span><span id='topic+print.summary.Qlm'></span><span id='topic+vcov.Qlm'></span><span id='topic+print.Qcoxph'></span><span id='topic+summary.Qcoxph'></span><span id='topic+print.summary.Qcoxph'></span><span id='topic+survfit.Qcoxph'></span><span id='topic+residuals.Qcoxph'></span><span id='topic+predict.Qcoxph'></span>

<h3>Description</h3>

<p>Functions for internal use only, or not yet documented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expit(x)
logit(x)
pmax0(x)
num.fun(dx,fx)
formatPerc(probs, digits)
Ltau(opt, tau)
minabs(x1,x2)
invJ(J, type)
tensorX(X)
buildTau(ntau, wtau = NULL, nobs, wtauoptions = NULL)
callwtau(wtau, tau, opt)
callQ(Q, theta, tau, data)
start.Qest(z, y, d, x, w, tau, Q, opt, start, data, type, control)
start.Qest.family(z, y, d, x, w, tau, wtau, wtauoptions,
  Q, opt, start, data, type, control)
rq.fit.br2(x, y, tau = 0.5)


Qest.sgs.internal(theta, type, tol, maxit, alpha0, ee, display, eps, n.it, ...)
Qest.gs.internal(theta, type, tol, maxit, alpha0, ee, display, eps, n.it, ...)
Qest.gs(theta, type, tol, maxit, alpha0, ee, display, eps, ...)
Qest.newton(theta, type, tol, maxit, safeit, alpha0, display, eps, ...)


Qlm.bfun(wtau, ...)
start.Qlm(x, y, w, start, ok, Stats)
scalevars.Qlm(X,y)
descalecoef.Qlm(theta, Stats)

Qlm.sgs.internal(theta, type, tol, maxit, alpha0, ee, display, n.it, y, X, w, bfun)
Qlm.gs.internal(theta, type, tol, maxit, alpha0, ee, display, n.it, y, X, w, bfun)
Qlm.gs(theta, type, tol, maxit, alpha0, ee, display, y, X, w, bfun)
Qlm.newton(theta, type = "u", tol, maxit, safeit, alpha0, display, y, X, w, bfun)


plfcox(y, knots, deriv = 0)
scalevars.Qcoxph(X,z,y,knots)
descalecoef.Qcoxph(theta, Stats)
check.singularities(X, scaleVars)
starting.points.Qcox(X, Y, n, w, mf, knots)
adjust.coef(theta)
agsurv.Qcoxph(y, x, wt, risk, fit)
basehaz.Qcoxph(fit, centered = TRUE, se.fit = FALSE)
coxsurv.fit.Qcoxph(ctype, stype, se.fit, varmat, cluster,
  y, x, wt, risk, position, strata, oldid, y2, x2, risk2,
  strata2, id2, unlist = TRUE, fit)
seg.lm.fit1(y,XREG,Z,PSI,return.all.sol=FALSE)


gs(theta0, f, ..., tol = 1e-4, maxit = 100)
myg(theta, f, f0, eps, ...)
dlist(x1,x2)
omega(d, tau, type, Fy, Fz)
choose_eps(Q, theta, y, data, eps0, obj = 0.01)
derQtheta(theta, eps, Q, Q1, data, tau, ind)
der2Qtheta(theta, eps, Q, Qtheta1, data, tau)
intA(A, tau, ifun = TRUE)
findp(y, tau, Q1)
findAp(p,tau,A)


A_beta_fun(BB)
A_gamma_fun(BB)
A_beta_beta_fun(BB)
A_gamma_gamma_mix_fun(BB)
A_gamma_gamma_fun(BB)
A_beta_gamma_fun(BB)
coxBB(theta, y, X, knots, tau)


derQtheta.gamma(Q)
der2Qtheta.gamma(Q, Qtheta)
findAp.gamma(atau, tau, dtau, p, int = TRUE)
QestGamma.ee.u(theta, eps, z, y, d, Q, w, data, tau, J = FALSE, EE)
QestGamma.ee.c(theta, eps, z, y, d, Q, w, data, tau, J = FALSE, EE)
QestGamma.ee.ct(theta, eps, z, y, d, Q, w, data, tau, J = FALSE, EE)


tau.pois(tau)
ppoisC(y, lambda)
dpoisC(y, lambda)
qpoisC.955(z, lambda)
qpoisC.me(log.lambda, A, B)
qpoisC.bisec(tau, lambda)
qpoisC(obj)

derQtheta.pois(Q)
der2Qtheta.pois(Q, Qtheta)
findp.pois(y, tau, Q1, Fy, theta)
findAp.pois(p, tau, A)
QestPois.ee.u(theta, eps, z, y, d, Q, w, data, tau, J = FALSE, EE)


QestUnif.ee.u(theta, eps, z, y, d, Q, w, data, tau, J = FALSE, EE)


QestNorm.ee.u(theta, eps, z, y, d, Q, w, data, tau, J = FALSE, EE)
QestNorm.ee.c(theta, eps, z, y, d, Q, w, data, tau, J = FALSE, EE)
QestNorm.ee.ct(theta, eps, z, y, d, Q, w, data, tau, J = FALSE, EE)


Qest.ee.u(theta, eps, z, y, d, Q, w, data, tau, J = FALSE, EE)
Qest.ee.c(theta, eps, z, y, d, Q, w, data, tau, J = FALSE, EE)
Qest.ee.ct(theta, eps, z, y, d, Q, w, data, tau, J = FALSE, EE)
QCox.ee.c(theta, eps, z, y, d, X, w, knots, tau, J = FALSE, EE)
QCox.ee.ct(theta, eps, z, y, d, X, w, knots, tau, J = FALSE, EE)
Qlm.ee.u(theta, X, w, bfun, EE, J = FALSE)


Qest.covar(fit, eps, w)
Qcox.covar(theta, z, y, d, X, w, knots, tau, type)
Qlm.covar(g.i, w, H)


Loss(w, d, tau, type, Fy, Fz)
coxLoss(theta, z, y, d, X, w, knots, tau, type, Fy, Fz)
qlmLoss(theta, y, X, w, bfun)

## S3 method for class 'Qest'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'summary.Qest'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'Qest'
confint(object, parm, level = 0.95, ...)
## S3 method for class 'Qest'
vcov(object, ...)

## S3 method for class 'Qlm'
summary(object, correlation = FALSE,
  symbolic.cor = FALSE, ...)
## S3 method for class 'summary.Qlm'
print(x, digits = max(3L, getOption("digits") - 3L),
  symbolic.cor = x$symbolic.cor, signif.stars = getOption("show.signif.stars"),
  ...)
## S3 method for class 'Qlm'
vcov(object, ...)

## S3 method for class 'Qcoxph'
print(x, digits = max(1L, getOption("digits") - 3L),
  signif.stars = FALSE, ...)
## S3 method for class 'Qcoxph'
summary(object, conf.int = 0.95, scale = 1, ...)
## S3 method for class 'summary.Qcoxph'
print(x, digits = max(getOption("digits") - 3, 3),
  signif.stars = getOption  ("show.signif.stars"), ...)
## S3 method for class 'Qcoxph'
survfit(formula, newdata, se.fit = TRUE, conf.int = 0.95,
  individual = FALSE, stype = 2, ctype, conf.type = c("log", "log-log",
  "plain","none", "logit", "arcsin"), censor = TRUE, start.time, id,
  influence = FALSE, na.action = na.pass, type, ...)
## S3 method for class 'Qcoxph'
residuals(object, type = c("martingale", "deviance", "score",
  "schoenfeld", "dfbeta", "dfbetas", "scaledsch", "partial"),
  collapse = FALSE, weighted = FALSE, ...)
## S3 method for class 'Qcoxph'
predict(object, newdata, type = c("lp", "risk", "expected",
  "terms", "survival"), se.fit = FALSE, na.action = na.pass,
  terms = names(object$assign), collapse, reference = c("strata", "sample"),
  ...)
</code></pre>


<h3>Value</h3>

<p>No return value, internal functions.
</p>

<hr>
<h2 id='invQ'>
Inverse of Quantile Function
</h2><span id='topic+invQ'></span>

<h3>Description</h3>

<p>Auxiliary function to compute cumulative distribution function (CDF) by inverting a quantile function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invQ(Q, theta, y, data, n.it = 17)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invQ_+3A_q">Q</code></td>
<td>

<p>any parametric quantile function of the form <code>Q(theta, tau, data)</code>.
</p>
</td></tr>
<tr><td><code id="invQ_+3A_theta">theta</code></td>
<td>

<p>a vector of model parameters.
</p>
</td></tr>
<tr><td><code id="invQ_+3A_y">y</code></td>
<td>

<p>vector of observations to evaluate the CDF.
</p>
</td></tr>
<tr><td><code id="invQ_+3A_data">data</code></td>
<td>

<p>data frame containing the variables used in the Q() function.
</p>
</td></tr>
<tr><td><code id="invQ_+3A_n.it">n.it</code></td>
<td>

<p>the number of iterations (see &ldquo;details&rdquo;).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a parametric quantile function <code class="reqn">Q(\tau | \theta)</code>, the CDF is defined as <code class="reqn">F(y | \theta) = Q^{-1}(y | \theta)</code>. Alternatively, <code class="reqn">F(y | \theta)</code> corresponds to the value <code class="reqn">\tau*</code> such that <code class="reqn">Q(\tau* | \theta) = y</code>. Starting from <code class="reqn">\tau = 0.5</code>, a bisection algorithm is used to evaluate numerically <code class="reqn">\tau*</code>. The maximum error is given by <code>1/2^(n.it + 1)</code>.
</p>


<h3>Value</h3>

<p>a vector of CDF values.
</p>


<h3>Author(s)</h3>

<p>Maintainer: Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Qest">Qest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ex. 1 Normal model

# Quantile function of a linear model.
Qlinmod &lt;- function(theta, tau, data){
  sigma &lt;- exp(theta[1])
  beta &lt;- theta[-1]
  X &lt;- model.matrix( ~ x1 + x2, data = data)
  qnorm(tau, X %*% beta, sigma)
}

n &lt;- 100
x1 &lt;- rnorm(n)
x2 &lt;- runif(n,0,3)
theta &lt;- c(1,4,1,2)

# generate the data
U &lt;- runif(n)
y &lt;- Qlinmod(theta, U, data.frame(x1,x2))

# Given y and theta, evaluate U = F(y)
invQ(Qlinmod, theta, y, data.frame(x1,x2))

</code></pre>

<hr>
<h2 id='Qcoxph'>
Q-Estimation of Proportional Hazards Regression Models
</h2><span id='topic+Qcoxph'></span>

<h3>Description</h3>

<p>Fit proportional hazards regression models using Q-estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qcoxph(formula, weights, start, data, knots, wtau = NULL,
    control = Qcoxph.control(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Qcoxph_+3A_formula">formula</code></td>
<td>

<p>an object of class &ldquo;formula&rdquo; (or one that can be coerced to that class): a symbolic description of the model to be fitted. Use <code>Surv(time, event) ~ x</code>, if the data are right-censored, and <code>Surv(time, time2, event)  ~ x</code>, if the data are right-censored and left-truncated (<code>time &lt; time2</code>, <code>time</code> can be <code>-Inf</code>).
</p>
</td></tr>
<tr><td><code id="Qcoxph_+3A_weights">weights</code></td>
<td>

<p>an optional vector of weights to be used in the fitting process. The weights will always be normalized to sum to the sample size. This implies that, for example, using double weights will <em>not</em> halve the standard errors.
</p>
</td></tr>
<tr><td><code id="Qcoxph_+3A_start">start</code></td>
<td>

<p>optional starting values for the coefficients of the linear predictor.
</p>
</td></tr>
<tr><td><code id="Qcoxph_+3A_data">data</code></td>
<td>

<p>an optional data frame, list or environment (or object coercible by <code>as.data.frame</code> to a data frame) containing the variables in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>Qcoxph</code> is called.
</p>
</td></tr>
<tr><td><code id="Qcoxph_+3A_knots">knots</code></td>
<td>

<p>knots to create the basis of a piecewise linear function. If <code>knots</code> is a vector of at least two elements, it is used to identify the exact position of <em>all</em> knots, including boundaries. If <code>knots</code> is a scalar, its value is used to determine the number of internal knots (<code>knots = 0</code> is allowed, and fits an Exponential model). If <code>knots</code> is missing, by default <code>max(1, min(floor(n.events/30), 3))</code> internal knots are used. Unless a vector of <code>knots</code> is provided by the user, the &ldquo;optimal&rdquo; position of the knots will be identified using the method described in Muggeo (2008). If this fails, the knots are positioned at the empirical quantiles of the observed events.
</p>
</td></tr>
<tr><td><code id="Qcoxph_+3A_wtau">wtau</code></td>
<td>

<p>an optional function that assigns a different weight to each quantile. By default, all quantiles in (0,1) have the same weight. Please check the documentation of <code><a href="#topic+wtrunc">wtrunc</a></code> for built-in weighting functions.
</p>
</td></tr>
<tr><td><code id="Qcoxph_+3A_control">control</code></td>
<td>

<p>a list of operational parameters. This is usually passed through <code><a href="#topic+Qcoxph.control">Qcoxph.control</a></code>.
</p>
</td></tr>
<tr><td><code id="Qcoxph_+3A_...">...</code></td>
<td>

<p>additional arguments for <code>wtau</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates a proportional hazards model, allowing for right-censored and left-truncated data. The syntax and output of <code>Qcoxph</code> are almost identical to those of <code><a href="survival.html#topic+coxph">coxph</a></code>, but the parameters are estimated using Q-estimation (Sottile and Frumento, 2020). This method can be used to obtain outlier-robust estimators of the regression coefficients.
</p>
<p>The quantile function of a proportional hazards model is given by
</p>
<p style="text-align: center;"><code class="reqn">Q(\tau | x) = H0^{-1}(-exp{-x'\beta} log(1 - \tau))</code>
</p>

<p>where <code class="reqn">H0</code> is the baseline cumulative hazard function. In <code>Qcoxph</code>, <code class="reqn">H0</code> is parametrized by a piecewise linear function identified by the provided <code>knots</code>. As the number of knots increases, the baseline hazard becomes arbitrarily flexible.
</p>
<p>Estimation is carried out by finding the zeroes of a set of integrals equation. The optional argument <code>wtau</code> permits assigning a different weight to each quantile in (0,1). It is possible to choose <code>wtau</code> to be a discontinuous function (e.g., <code>wtau = function(tau){tau &lt; 0.95}</code>). However, this may occasionally result in poorly estimated of the standard errors.
</p>
<p>The estimation algorithm is briefly described in the documentation of <code><a href="#topic+Qcoxph.control">Qcoxph.control</a></code>.
</p>


<h3>Value</h3>

<p>an object of classes &ldquo;Qcoxph&rdquo;, &ldquo;coxph&rdquo;, and &ldquo;Qest&rdquo;. See <code><a href="survival.html#topic+coxph.object">coxph.object</a></code> for details. All the S3 methods that are available for &ldquo;coxph&rdquo; objects will also work with a &ldquo;Qcoxph&rdquo; object.
</p>
<p>An object of class &ldquo;Qcoxph&rdquo; is a list containing at least the following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>the covariance matrix of the coefficients.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>number of iterations used.</p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>
<p>the vector of linear predictors, one per subject. Note that this vector has not been centered, see <code><a href="survival.html#topic+predict.coxph">predict.coxph</a></code> for details.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the martingale residuals.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>vector of column means of the X matrix. Subsequent survival curves are adjusted to this value.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of observations used in the fit.</p>
</td></tr>
<tr><td><code>nevent</code></td>
<td>
<p>the number of events used in the fit.</p>
</td></tr>
<tr><td><code>concordance</code></td>
<td>
<p>a vector of length 6, containing the number of pairs that are concordant, discordant, tied on x, tied on y, and tied on both, followed by the standard error of the concordance statistic.</p>
</td></tr>
<tr><td><code>terms</code>, <code>assign</code>, <code>formula</code>, <code>call</code>, <code>y</code></td>
<td>
<p>other objects used for prediction.</p>
</td></tr>
<tr><td><code>obj.function</code></td>
<td>
<p>the objective function of the model. Please, interpret with care: read the note in the documentation of <code><a href="#topic+Qest">Qest</a></code>.</p>
</td></tr>
<tr><td><code>internal</code></td>
<td>
<p>internal objects.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Frumento &lt;paolo.frumento@unipi.it&gt;, Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;
</p>


<h3>References</h3>

<p>Sottile G, and Frumento P (2022). <em>Robust estimation and regression with parametric quantile functions.</em> Computational Statistics and Data Analysis. &lt;doi:10.1016/j.csda.2022.107471&gt;
</p>
<p>Muggeo VMR (2008). <em>Segmented: an R package to fit regression models with broken-line relationships.</em> R News 8/1, 20â€“25.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Qest">Qest</a></code>, for general Q-estimation, and <code><a href="#topic+Qlm">Qlm</a></code>, for Q-estimation of linear models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# A proportional-hazards Weibull model

n &lt;- 100
x &lt;- runif(n,0,3)
shape &lt;- 2
t &lt;- rweibull(n, shape = shape, scale = (1/exp(2 + 2*x))^(1/shape)) # time-to-event
c &lt;- runif(n,0,1) # censoring variable
y &lt;- pmin(t,c) # observed response
d &lt;- (t &lt;= c) # event indicator

require(survival)
m1 &lt;- coxph(Surv(y,d) ~ x) # standard Cox model
m2 &lt;- Qcoxph(Surv(y,d) ~ x) # Q-estimator

</code></pre>

<hr>
<h2 id='Qcoxph.control'>
Auxiliary for Controlling Qcoxph Fitting
</h2><span id='topic+Qcoxph.control'></span>

<h3>Description</h3>

<p>Auxiliary function for controlling <code>Qcoxph</code> fitting. Estimation proceeds in three steps: (i) evaluation of starting points; (iia) stochastic gradient-based optimization (iib) standard gradient-based optimization; and (iii) Newton-Raphson. Step (i) is based on a preliminary fit of a Cox model via <code>coxph</code>. Steps (iia) and (iib) find an approximate solution, and make sure that the Jacobian matrix is well-defined. Finally, step (iii) finds a more precise solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qcoxph.control(tol = 1e-8, maxit, safeit, alpha0, display = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Qcoxph.control_+3A_tol">tol</code></td>
<td>

<p>tolerance for convergence of Newton-Raphson algorithm, default is 1e-8.
</p>
</td></tr>
<tr><td><code id="Qcoxph.control_+3A_maxit">maxit</code></td>
<td>

<p>maximum number of iterations of Newton-Raphson algorithm. If not provided, a default is computed as <code>50 + 25*npar</code>, where <code>npar</code> is the total number of parameters.
</p>
</td></tr>
<tr><td><code id="Qcoxph.control_+3A_safeit">safeit</code></td>
<td>

<p>maximum number of iterations of gradient-search algorithm. If not provided, a default is computed as <code>10 + 5*npar</code>, where <code>npar</code> is the total number of parameters.
</p>
</td></tr>
<tr><td><code id="Qcoxph.control_+3A_alpha0">alpha0</code></td>
<td>

<p>step size for the preliminary gradient-based iterations. If estimation fails, you can try choosing a small value of <code>alpha0</code>. If <code>alpha0</code> is missing, an adaptive choiche will be made internally.
</p>
</td></tr>
<tr><td><code id="Qcoxph.control_+3A_display">display</code></td>
<td>

<p>Logical. If <code>TRUE</code>, tracing information on the progress of the optimization is printed on screen. Default is <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If called with no arguments, <code>Qcoxph.control()</code> returns a list with the current settings of these parameters. Any arguments included in the call sets those parameters to the new values, and then silently returns.
</p>


<h3>Value</h3>

<p>A list with named elements as in the argument list
</p>


<h3>Author(s)</h3>

<p>Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;
Paolo Frumento &lt;paolo.frumento@unipi.it&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Qcoxph">Qcoxph</a></code>
</p>

<hr>
<h2 id='Qest'>
Q-Estimation
</h2><span id='topic+Qest'></span>

<h3>Description</h3>

<p>An implementation of the quantile-based estimators described in Sottile and Frumento (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qest(formula, Q, weights, start, data, ntau = 199, wtau = NULL,
  control = Qest.control(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Qest_+3A_formula">formula</code></td>
<td>

<p>a two-sided formula of the form <code>y ~ x</code>. Note that the parametric model is identified through <code>Q</code>, and not through <code>formula</code>, that only identifies the response and the predictors. Use <code>Surv(time, event)</code>, if the data are right-censored, and <code>Surv(start, stop, event)</code>, if the data are right-censored and left-truncated (<code>start &lt; stop</code>, <code>start</code> can be <code>-Inf</code>).
</p>
</td></tr>
<tr><td><code id="Qest_+3A_q">Q</code></td>
<td>

<p>a parametric quantile function of the form <code>Q(theta, tau, data)</code>. Alternatively, a
character string naming a <code>Qfamily</code> function, a <code>Qfamily</code> function itself, or the
result of a call to a <code>Qfamily</code> function. See <code><a href="#topic+Qfamily">Qfamily</a></code> for details.
</p>
</td></tr>
<tr><td><code id="Qest_+3A_weights">weights</code></td>
<td>

<p>an optional vector of weights to be used in the fitting process. The weights will always be normalized to sum to the sample size. This implies that, for example, using double weights will <em>not</em> halve the standard errors.
</p>
</td></tr>
<tr><td><code id="Qest_+3A_start">start</code></td>
<td>

<p>a vector of starting values. <code>NA</code>s are allowed, but will be internally replaced by zeroes. Make sure that the quantile function is well-defined at <code>theta = start</code>. The size of <code>start</code> is also used to identify the number of parameters in the model. You <em>must</em> supply starting points, unless you are fitting a model defined by a <code>Qfamily</code>.
</p>
</td></tr>
<tr><td><code id="Qest_+3A_data">data</code></td>
<td>

<p>an optional data frame, list or environment (or object coercible by <code>as.data.frame</code> to a data frame) containing the variables in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>Qest</code> is called.
</p>
</td></tr>
<tr><td><code id="Qest_+3A_ntau">ntau</code></td>
<td>

<p>the number of points for numerical integration (see &ldquo;Details&rdquo;). Default <code>ntau = 199</code>.
</p>
</td></tr>
<tr><td><code id="Qest_+3A_wtau">wtau</code></td>
<td>

<p>an optional function that assigns a different weight to each quantile. By default, all quantiles in (0,1) have the same weight. Please check the documentation of <code><a href="#topic+wtrunc">wtrunc</a></code> for built-in weighting functions.
</p>
</td></tr>
<tr><td><code id="Qest_+3A_control">control</code></td>
<td>

<p>a list of operational parameters. This is usually passed through <code><a href="#topic+Qest.control">Qest.control</a></code>.
</p>
</td></tr>
<tr><td><code id="Qest_+3A_...">...</code></td>
<td>

<p>additional arguments for <code>wtau</code> and <code>Q</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A parametric model, <code class="reqn">Q(\tau | \theta, x)</code>, is used to describe the conditional quantile function of an outcome <code class="reqn">Y</code>, given a vector <code class="reqn">x</code> of covariates. The model parameters, <code class="reqn">\theta</code>, are estimated by minimizing the (weighted) integral, with respect to <code class="reqn">\tau</code>, of the loss function of standard quantile regression. If the data are censored or truncated, <code class="reqn">\theta</code> is estimated by solving a set of estimating equations. In either case, numerical integration is required to calculate the objective function: a grid of <code>ntau</code> points in <code>(0,1)</code> is used.  The estimation algorithm is briefly described in the documentation of <code><a href="#topic+Qest.control">Qest.control</a></code>.
</p>
<p>The optional argument <code>wtau</code> can be used to attribute a different weight to each quantile. Although it is possible to choose <code>wtau</code> to be a discontinuous function (e.g., <code>wtau = function(tau){tau &lt; 0.95}</code>), this may occasionally result in poorly estimated standard errors.
</p>
<p>The quantile function <code>Q</code> must have at least the following three arguments: <code>theta, tau, data</code>, in this order. The first argument, <code>theta</code>, is a vector (not a matrix) of parameters' values. The second argument, <code>tau</code>, is the order of the quantile. When <code>Q</code> receives a <code>n*ntau</code> matrix of <code>tau</code> values, it must return a <code>n*ntau</code> matrix of quantiles. The third argument, <code>data</code>, is a data frame that includes the predictors used by <code>Q</code>.
</p>
<p>If <code>Q</code> is identified by one <code><a href="#topic+Qfamily">Qfamily</a></code>, everything becomes much simpler. It is not necessary to implement your own quantile function, and the starting points are not required. Note that <code>ntau</code> is ignored if <code>Q = Qnorm</code> or <code>Q = Qunif</code>.
</p>
<p>Please check the documentation of <code><a href="#topic+Qfamily">Qfamily</a></code> to see the available built-in distributions. A convenient Q-based implementation of the standard linear regression model is offered by <code><a href="#topic+Qlm">Qlm</a></code>. Proportional hazards models are implemented in <code><a href="#topic+Qcoxph">Qcoxph</a></code>.
</p>


<h3>Value</h3>

<p>a list with the following elements:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients.</p>
</td></tr>
<tr><td><code>std.errs</code></td>
<td>
<p>a named vector of estimated standard errors.</p>
</td></tr>
<tr><td><code>covar</code></td>
<td>
<p>the estimated covariance matrix of the estimators.</p>
</td></tr>
<tr><td><code>obj.function</code></td>
<td>
<p>the value of the minimized loss function. If the data are censored or truncated, a meaningful loss function which, however, is not the function being minimized (see &ldquo;Note&rdquo;).</p>
</td></tr>
<tr><td><code>ee</code></td>
<td>
<p>the values of the estimating equations at the solution. If the data are neither censored nor truncated, the partial derivatives of the loss function.</p>
</td></tr>
<tr><td><code>jacobian</code></td>
<td>
<p>the jacobian at the solution. If the data are neither censored nor truncated, the matrix of second derivatives of the loss function.</p>
</td></tr>
<tr><td><code>CDF</code>, <code>PDF</code></td>
<td>
<p>the fitted values of the cumulative distribution function (CDF) and the probability density function (PDF).</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>logical. The convergence status.</p>
</td></tr>
<tr><td><code>n.it</code></td>
<td>
<p>the number of iterations.</p>
</td></tr>
<tr><td><code>internal</code></td>
<td>
<p>internal elements.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>NOTE 1. If the data are censored or truncated, estimation is carried out by solving estimating equations, and no associated loss is present. In this case, a meaningful value of <code>obj.function</code> is the integrated loss [equation 1 of Sottile and Frumento (2022)] in which the indicator function <code class="reqn">I(y \le Q(\tau | \theta, x))</code> has been replaced with one of the expressions presented in equations 6 and 7 of the paper. The resulting loss, however, is not the function being minimized.
</p>
<p>NOTE 2. To prevent computational problems, avoid situations in which some of the estimated parameters are expected to be very small or very large. For example, standardize the predictors, and normalize the response. Avoid as much as possible parameters with bounded support. For example, model a variance/rate/shape parameter on the log scale, e.g., <code class="reqn">\sigma = exp(\theta)</code>. Carefully select the starting points, and make sure that <code>Q(start, ...)</code> is well-defined. If <code>Q</code> is identified by one <code><a href="#topic+Qfamily">Qfamily</a></code>, all these recommendations can be ignored.
</p>
<p>NOTE 3. You should <em>not</em> use <code>Qest</code> to fit parametric models describing discrete distributions, where the quantile function is piecewise constant. You can try, but the optimization algorithm will most likely fail. The predefined family <code>Qpois</code> allows to fit a Poisson distribution by using a continuous version of its quantile function (see <code><a href="#topic+Qfamily">Qfamily</a></code>).
</p>


<h3>Author(s)</h3>

<p>Paolo Frumento &lt;paolo.frumento@unipi.it&gt;, Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;
</p>


<h3>References</h3>

<p>Sottile G, and Frumento P (2022). <em>Robust estimation and regression with parametric quantile functions.</em> Computational Statistics and Data Analysis. &lt;doi:10.1016/j.csda.2022.107471&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Qest.control">Qest.control</a></code>, for operational parameters, and <code><a href="#topic+summary.Qest">summary.Qest</a></code>, for model summary. <code><a href="#topic+Qfamily">Qfamily</a></code>, for the available built-in distributions. <code><a href="#topic+wtrunc">wtrunc</a></code> for built-in weighting functions (<code>wtau</code> argument). <code><a href="#topic+Qlm">Qlm</a></code>, for Q-estimation of the standard normal (linear) regression model; <code><a href="#topic+Qcoxph">Qcoxph</a></code>, for proportional hazards models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ex1. Normal model

# Quantile function of a linear model
Qlinmod &lt;- function(theta, tau, data){
  sigma &lt;- exp(theta[1])
  beta &lt;- theta[-1]
  X &lt;- model.matrix( ~ x1 + x2, data = data)
  qnorm(tau, X %*% beta, sigma)
}

n &lt;- 100
x1 &lt;- rnorm(n)
x2 &lt;- runif(n,0,3)
theta &lt;- c(1,4,1,2)
y &lt;- Qlinmod(theta, runif(n), data.frame(x1,x2)) # generate the data

m1 &lt;- Qest(y ~ x1 + x2, Q = Qlinmod, start = c(NA,NA,NA,NA)) # User-defined quantile function
summary(m1)

m2 &lt;- Qest(y ~ x1 + x2, Q = Qnorm) # Qfamily
summary(m2)

m3 &lt;- Qlm(y ~ x1 + x2)
summary(m3) # using 'Qlm' is much simpler and faster, with identical results





# Ex2. Weibull model with proportional hazards

# Quantile function
QWeibPH &lt;- function(theta, tau, data){
  shape &lt;- exp(theta[1])
  beta &lt;- theta[-1]
  X &lt;- model.matrix(~ x1 + x2, data = data)
  qweibull(tau, shape = shape, scale = (1/exp(X %*% beta))^(1/shape))
}

n &lt;- 100
x1 &lt;- rbinom(n,1,0.5)
x2 &lt;- runif(n,0,3)
theta &lt;- c(2,-0.5,1,1)

t &lt;- QWeibPH(theta, runif(n), data.frame(x1,x2)) # time-to-event
c &lt;- runif(n,0.5,1.5) # censoring variable
y &lt;- pmin(t,c) # observed response
d &lt;- (t &lt;= c) # event indicator

m1 &lt;- Qest(Surv(y,d) ~ x1 + x2, Q = QWeibPH, start = c(NA,NA,NA,NA))
summary(m1)

m2 &lt;- Qcoxph(Surv(y,d) ~ x1 + x2)
summary(m2) # using 'Qcoxph' is much simpler and faster (but not identical)




# Ex3. A Gamma model

# Quantile function
Qgm &lt;- function(theta, tau, data){
  a &lt;- exp(theta[1])
  b &lt;- exp(theta[2])
  qgamma(tau, shape = a, scale = b)
}
n &lt;- 100
theta &lt;- c(2,-1)
y &lt;- rgamma(n, shape = exp(theta[1]), scale = exp(theta[2]))

m1 &lt;- Qest(y ~ 1, Q = Qgm, start = c(NA, NA)) # User-defined quantile function
m2 &lt;- Qest(y ~ 1, Q = Qgamma) # Qfamily
m3 &lt;- Qest(y ~ 1, Q = Qgamma, wtau = function(tau, h) dnorm((tau - 0.5)/h), h = 0.2)
# In m3, more weight is assigned to quantiles around the median




# Ex4. A Poisson model

# Quantile function
n &lt;- 100
x1 &lt;- runif(n)
x2 &lt;- rbinom(n,1,0.5)
y &lt;- rpois(n, exp(1.5 -0.5*x1 + x2))
m1 &lt;- Qest(y ~ x1 + x2, Q = Qpois) # Use a Qfamily! See "Note"
m2 &lt;- Qest(y + runif(n) ~ x1 + x2, Q = Qpois) # Use jittering! See the documentation of "Qfamily"

</code></pre>

<hr>
<h2 id='Qest-package'>
Quantile-Based Estimator
</h2><span id='topic+Qest-package'></span>

<h3>Description</h3>

<p>Quantile-based estimators (Q-estimators) can be used to fit any parametric distribution, using its quantile function. Q-estimators are usually more robust than standard maximum likelihood estimators. The method is described in: Sottile G. and Frumento P. (2022). Robust estimation and regression with parametric quantile functions. &lt;doi:10.1016/j.csda.2022.107471&gt;.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> Qest</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-01-22</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> Qest</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Quantile-Based Estimator</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Gianluca", "Sottile", role=c("aut", "cre"), email = "gianluca.sottile@unipa.it"),
	     person("Paolo", "Frumento", role=c("aut")))</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Gianluca Sottile [aut, cre],
  	Paolo Frumento [aut]</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Quantile-based estimators (Q-estimators) can be used to fit any parametric distribution, using its quantile function. Q-estimators are usually more robust than standard maximum likelihood estimators. The method is described in: Sottile G. and Frumento P. (2022). Robust estimation and regression with parametric quantile functions. &lt;doi:10.1016/j.csda.2022.107471&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> pch, survival, matrixStats, methods, utils</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://www.sciencedirect.com/science/article/abs/pii/S0167947322000512</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
Qcoxph                  Q-Estimation of Proportional Hazards Regression
                        Models
Qcoxph.control          Auxiliary for Controlling Qcoxph Fitting
Qest                    Q-Estimation
Qest-package            Quantile-Based Estimator
Qest.control            Auxiliary for Controlling Qest Fitting
Qfamily                 Family Objects for Qest
Qlm                     Q-Estimation of Linear Regression Models
Qlm.fit                 Fitter Functions for Quantile-based Linear
                        Models
invQ                    Inverse of Quantile Function
summary.Qest            Summarizing Q-estimators
wtrunc                  Weighting Function for 'Qest', 'Qlm', and
                        'Qcoxph'.
</pre>


<h3>Author(s)</h3>

<p>Gianluca Sottile [aut, cre],
  	Paolo Frumento [aut]
</p>
<p>Maintainer: Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;
</p>


<h3>References</h3>

<p>Sottile G, and Frumento P (2022). <em>Robust estimation and regression with parametric quantile functions.</em> Computational Statistics and Data Analysis. &lt;doi:10.1016/j.csda.2022.107471&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Qest">Qest</a></code>, <code><a href="#topic+Qlm">Qlm</a></code>, <code><a href="#topic+Qcoxph">Qcoxph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Qest(y ~ x, Q, start) # General-purpose Q-estimator
Qlm(y ~ x) # Q-estimation of linear models
Qcoxph(Surv(time, event) ~ x) # Q-estimation of proportional hazards models

## End(Not run)
</code></pre>

<hr>
<h2 id='Qest.control'>
Auxiliary for Controlling Qest Fitting
</h2><span id='topic+Qest.control'></span>

<h3>Description</h3>

<p>Auxiliary function for controlling <code>Qest</code> fitting. Estimation proceeds in three steps: (i) evaluation of starting points; (iia) stochastic gradient-based optimization (iib) standard gradient-based optimization; and (iii) Newton-Raphson. Step (i) is initialized at the provided starting values (the <code>start</code> argument of <code>Qest</code>), and utilizes a preliminary flexible model, estimated with <code><a href="pch.html#topic+pchreg">pchreg</a></code>, to generate a cheap guess of the model parameters. If you have good starting points, you can skip step (i) by setting <code>restart = FALSE</code>. Steps (iia) and (iib) find an approximate solution, and make sure that the Jacobian matrix is well-defined. Finally, step (iii) finds a more precise solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qest.control(tol = 1e-8, maxit, safeit, alpha0, display = FALSE, restart = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Qest.control_+3A_tol">tol</code></td>
<td>

<p>tolerance for convergence of Newton-Raphson algorithm, default is 1e-8.
</p>
</td></tr>
<tr><td><code id="Qest.control_+3A_maxit">maxit</code></td>
<td>

<p>maximum number of iterations of Newton-Raphson algorithm. If not provided, a default is computed as <code>50 + 25*npar</code>, where <code>npar</code> is the number of parameters.
</p>
</td></tr>
<tr><td><code id="Qest.control_+3A_safeit">safeit</code></td>
<td>

<p>maximum number of iterations of gradient-search algorithm. If not provided, a default is computed as <code>10 + 5*npar</code>, where <code>npar</code> is the number of parameters.
</p>
</td></tr>
<tr><td><code id="Qest.control_+3A_alpha0">alpha0</code></td>
<td>

<p>step size for the preliminary gradient-based iterations. If estimation fails, you can try choosing a small value of <code>alpha0</code>. If <code>alpha0</code> is missing, an adaptive choiche will be made internally.
</p>
</td></tr>
<tr><td><code id="Qest.control_+3A_display">display</code></td>
<td>

<p>Logical. If <code>TRUE</code>, tracing information on the progress of the optimization is printed on screen. Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="Qest.control_+3A_restart">restart</code></td>
<td>

<p>Logical. If <code>FALSE</code> (the default), step (i) is not performed, and the provided starting points are directly passed to step (ii). This may save you some time, but is not recommended unless you are confident about your choice of initial values. When <code>restart = TRUE</code>, the provided starting points are used to initialize step (i).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If called with no arguments, <code>Qest.control()</code> returns a list with the current settings of these parameters. Any arguments included in the call sets those parameters to the new values, and then silently returns.
</p>


<h3>Value</h3>

<p>A list with named elements as in the argument list
</p>


<h3>Note</h3>

<p>Step (i) is not performed, and <code>restart</code> is ignored, if the quantile function is one of the available <code><a href="#topic+Qfamily">Qfamily</a></code>.</p>


<h3>Author(s)</h3>

<p>Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;
Paolo Frumento &lt;paolo.frumento@unipi.it&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Qest">Qest</a></code> and <code><a href="#topic+Qlm">Qlm</a></code>
</p>

<hr>
<h2 id='Qfamily'>Family Objects for Qest</h2><span id='topic+Qfamily'></span><span id='topic+Qnorm'></span><span id='topic+Qgamma'></span><span id='topic+Qpois'></span><span id='topic+Qunif'></span>

<h3>Description</h3>

<p>Family objects are used to specify the model to be fitted by <code><a href="#topic+Qest">Qest</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qnorm()
Qgamma()
Qpois(offset = NULL)
Qunif(min = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Qfamily_+3A_offset">offset</code></td>
<td>
<p>an optional vector of offsets for a Poisson model.</p>
</td></tr>
<tr><td><code id="Qfamily_+3A_min">min</code></td>
<td>
<p>logical. If <kbd>TRUE</kbd>, fit a <code class="reqn">U(a, b)</code> distribution. If <kbd>FALSE</kbd>, fit a <code class="reqn">U(0, b)</code> distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>Qfamily</code> object can be used to identify a certain type of distribution within a call to <code>Qest</code>. You can supply either the name of the family, or the function itself, or a call to it. For example, the following are equivalent: <code>Qest(formula, "Qpois")</code>, <code>Qest(formula, Qpois)</code>, and <code>Qest(formula, Qpois())</code>. The latter syntax can be used to pass additional arguments, if any.
</p>
<p>The <code>Qnorm</code> family fits a normal homoskedastic model in which the mean is described by a linear predictor. The parameters are: <code>log(sigma), beta</code>. <code>Qest(formula, Qnorm)</code> is equivalent to <code>Qlm(formula)</code>, but returns a very basic output. However, <code>Qest</code> allows for censored and truncated data, while <code>Qlm</code> does not.
</p>
<p>The <code>Qgamma</code> family fits a Gamma distribution in which the log-scale is modeled by a linear predictor. The model parameters are: <code>log(shape), beta</code>.
</p>
<p>The <code>Qpois</code> family fits a Poisson distribution in which the log-rate is modeled by a linear predictor. In reality, to obtain a continuous quantile function, <code>qpois</code> is replaced by the inverse, <em>with respect to</em> <code class="reqn">y</code>, of the upper regularized gamma function, <code class="reqn">Q(y,\lambda)</code>. It is recommended to apply <code>Qpois</code> to a jittered response (i.e., <code>y + runif(n)</code>).
</p>
<p>The <code>Qunif</code> family fits a Uniform distribution <code class="reqn">U(a,b)</code> in which both <code class="reqn">a</code> and <code class="reqn">b</code> are modeled by linear predictors. The design matrix, however, is the same for <code class="reqn">a</code> and <code class="reqn">b</code>. Use <code>Qunif(min = FALSE)</code> to fit a <code class="reqn">U(0,b)</code> model. The parameters are: <code>beta_a, beta_b</code>, or only <code>beta_b</code> if <code>min = FALSE</code>.
</p>
<p>The families <code>Qnorm</code> and <code>Qgamma</code> can be used when the data are censored or truncated, while <code>Qpois</code> and <code>Qunif</code> cannot. All families can be estimated without covariates, using <code>formula = ~ 1</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"Qfamily"</code> that contains all the necessary information to be passed to <code>Qest</code>.
</p>


<h3>Author(s)</h3>

<p>Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;, Paolo Frumento &lt;paolo.frumento@unipi.it&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Qest">Qest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 250
x &lt;- runif(n)
eta &lt;- 1 + 2*x # linear predictor

# Normal model
y &lt;- rnorm(n, eta, exp(1))
m1 &lt;- Qest(y ~ x, Qnorm)
# Use Qlm(y ~ x) instead!

# Gamma model
y &lt;- rgamma(n, shape = exp(1), scale = exp(eta))
m2 &lt;- Qest(y ~ x, Qgamma)

# Poisson model
y &lt;- rpois(n, exp(eta))
m3 &lt;- Qest(y ~ x, Qpois)
m4 &lt;- Qest(y + runif(n) ~ x, Qpois) # Jittering is recommended

# Uniform model
y &lt;- runif(n, 0, eta)
m5 &lt;- Qest(y ~ x, Qunif(min = TRUE))  # U(a,b)
m6 &lt;- Qest(y ~ x, Qunif(min = FALSE)) # U(0,b)
</code></pre>

<hr>
<h2 id='Qlm'>
Q-Estimation of Linear Regression Models
</h2><span id='topic+Qlm'></span>

<h3>Description</h3>

<p>Use Q-estimation to fit a Normal model in which the mean is a linear function of the predictors, and the variance is constant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qlm(formula, data, subset, weights, na.action, start = NULL, contrasts = NULL,
  wtau = NULL, control = Qest.control(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Qlm_+3A_formula">formula</code></td>
<td>

<p>an object of class &ldquo;formula&rdquo; (or one that can be coerced to that class): a symbolic description of the model to be fitted.
</p>
</td></tr>
<tr><td><code id="Qlm_+3A_data">data</code></td>
<td>

<p>an optional data frame, list or environment (or object coercible by <code>as.data.frame</code> to a data frame) containing the variables in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>Qlm</code> is called.
</p>
</td></tr>
<tr><td><code id="Qlm_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be used in the fitting process.
</p>
</td></tr>
<tr><td><code id="Qlm_+3A_weights">weights</code></td>
<td>

<p>an optional vector of weights to be used in the fitting process. The weights will always be normalized to sum to the sample size. This implies that, for example, using double weights will <em>not</em> halve the standard errors.
</p>
</td></tr>
<tr><td><code id="Qlm_+3A_na.action">na.action</code></td>
<td>

<p>a function which indicates what should happen when the data contain <code>NA</code>s. See <code><a href="stats.html#topic+lm">lm</a></code>.
</p>
</td></tr>
<tr><td><code id="Qlm_+3A_start">start</code></td>
<td>

<p>optional starting values for the regression coefficients.
</p>
</td></tr>
<tr><td><code id="Qlm_+3A_contrasts">contrasts</code></td>
<td>

<p>an optional list. See the <code>contrasts.arg</code> of <code>model.matrix.default</code>.
</p>
</td></tr>
<tr><td><code id="Qlm_+3A_wtau">wtau</code></td>
<td>

<p>an optional function that assigns a different weight to each quantile. By default, all quantiles in (0,1) have the same weight. Please check the documentation of <code><a href="#topic+wtrunc">wtrunc</a></code> for built-in weighting functions.
</p>
</td></tr>
<tr><td><code id="Qlm_+3A_control">control</code></td>
<td>

<p>a list of operational parameters. See <code>Qest.control</code> for details.
</p>
</td></tr>
<tr><td><code id="Qlm_+3A_...">...</code></td>
<td>

<p>additional arguments for <code>wtau</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used exactly as <code><a href="stats.html#topic+lm">lm</a></code>, but estimates the model parameters as in <code><a href="#topic+Qest">Qest</a></code>. Using Q-estimation allows to obtain outlier-robust estimators of the regression coefficients. The optional argument <code>wtau</code> permits assigning a different weight to each quantile in (0,1). It is possible to choose <code>wtau</code> to be a discontinuous function (e.g., <code>wtau = function(tau){tau &lt; 0.95}</code>). However, this may occasionally result in poorly estimated of the standard errors.
</p>
<p>Note that <code>Qlm</code>, like <code>lm</code>, does not support censored or truncated data.
</p>


<h3>Value</h3>

<p>Qlm returns an object of classes &ldquo;Qlm&rdquo;, &ldquo;lm&rdquo;, and &ldquo;Qest&rdquo;.
The generic accessor functions <code>summary</code>, <code>coefficients</code>, <code>fitted.values</code>, and <code>residuals</code> can be used to extract infromation from a &ldquo;Qlm&rdquo; object.
</p>
<p>An object of class &ldquo;Qlm&rdquo; is a list containing at least the following elements:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients.</p>
</td></tr>
<tr><td><code>std.errs</code></td>
<td>
<p>a named vector of standard errors.</p>
</td></tr>
<tr><td><code>covar</code></td>
<td>
<p>the estimated covariance matrix of the estimators.</p>
</td></tr>
<tr><td><code>dispersion</code></td>
<td>
<p>the estimated dispersion parameter (residual variance).</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the working residuals.</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>the estimated degrees of freedom.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted values.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>the residual degrees of freedom.</p>
</td></tr>
<tr><td><code>obj.function</code></td>
<td>
<p>the value of the minimized loss function.</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>the first derivatives of the minimized loss function.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>the matrix of second derivatives of the minimized loss function.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>logical. The convergence status.</p>
</td></tr>
<tr><td><code>n.it</code></td>
<td>
<p>the number of iterations.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>control parameters.</p>
</td></tr>
<tr><td><code>xlevels</code></td>
<td>
<p>(only where relevant) a record of the levels of the factors used in fitting.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the &ldquo;terms&rdquo; object used.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>if requested (the default), the model frame used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;, Paolo Frumento &lt;paolo.frumento@unipi.it&gt;
</p>


<h3>References</h3>

<p>Sottile G, and Frumento P (2022). <em>Robust estimation and regression with parametric quantile functions.</em> Computational Statistics and Data Analysis. &lt;doi:10.1016/j.csda.2022.107471&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Qest">Qest</a></code>, for general Q-estimation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
n &lt;- 100
x1 &lt;- rnorm(n)
x2 &lt;- runif(n,0,3)
theta &lt;- c(1,4,1,2)
y &lt;- rnorm(n, 4 + x1 + 2*x2, 1)

m1 &lt;- Qlm(y ~ x1 + x2)
summary(m1)
</code></pre>

<hr>
<h2 id='Qlm.fit'>
Fitter Functions for Quantile-based Linear Models
</h2><span id='topic+Qlm.fit'></span>

<h3>Description</h3>

<p>This is the basic computing engine called by &ldquo;Qlm&rdquo; used to fit quantile-based linear models. This function should only be used directly by experienced users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qlm.fit(y, X, w = rep(1, nobs), start = NULL, wtau = NULL,
  control = Qest.control(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Qlm.fit_+3A_y">y</code></td>
<td>

<p>vector of observations of length n.
</p>
</td></tr>
<tr><td><code id="Qlm.fit_+3A_x">X</code></td>
<td>

<p>design matrix of dimension n * p.
</p>
</td></tr>
<tr><td><code id="Qlm.fit_+3A_w">w</code></td>
<td>

<p>an optional vector of weights to be used in the fitting process.
</p>
</td></tr>
<tr><td><code id="Qlm.fit_+3A_start">start</code></td>
<td>

<p>starting values for the parameters in the linear predictor.
</p>
</td></tr>
<tr><td><code id="Qlm.fit_+3A_wtau">wtau</code></td>
<td>

<p>an optional function that assigns a different weight to each quantile. By default, all quantiles in (0,1) have the same weight.
</p>
</td></tr>
<tr><td><code id="Qlm.fit_+3A_control">control</code></td>
<td>

<p>a list of operational parameters. This is usually passed through <code><a href="#topic+Qest.control">Qest.control</a></code>.
</p>
</td></tr>
<tr><td><code id="Qlm.fit_+3A_...">...</code></td>
<td>

<p>additional arguments for <code>wtau</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a &ldquo;list&rdquo; with components
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>p vector</p>
</td></tr>
<tr><td><code>std.errs</code></td>
<td>
<p>p vector</p>
</td></tr>
<tr><td><code>covar</code></td>
<td>
<p>p x p matrix</p>
</td></tr>
<tr><td><code>dispersion</code></td>
<td>
<p>estimated dispersion parameter</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>n vector</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>integer, giving the rank</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>n vector</p>
</td></tr>
<tr><td><code>qr</code></td>
<td>
<p>the QR decomposition, see &ldquo;qr&rdquo;</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>degrees of freedom of residuals</p>
</td></tr>
<tr><td><code>obj.function</code></td>
<td>
<p>the minimized loss function</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>p vector</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>p x p matrix</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>logical. The convergence status</p>
</td></tr>
<tr><td><code>n.it</code></td>
<td>
<p>the number of iterations</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>control elements</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;, Paolo Frumento &lt;paolo.frumento@unipi.it&gt;
</p>


<h3>References</h3>

<p>Sottile G, and Frumento P (2022). <em>Robust estimation and regression with parametric quantile functions.</em> Computational Statistics and Data Analysis. &lt;doi:10.1016/j.csda.2022.107471&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Qlm">Qlm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ex. 1 Normal model

set.seed(1234)
n &lt;- 100
x1 &lt;- rnorm(n)
x2 &lt;- runif(n,0,3)
y &lt;- rnorm(n, 4 + x1 + 2*x2, 1)
X &lt;- cbind(1, x1, x2)
w &lt;- rep.int(1, n)

m &lt;- Qlm.fit(y = y, X = X, w = w, control = Qest.control(display = TRUE))

</code></pre>

<hr>
<h2 id='summary.Qest'>
Summarizing Q-estimators
</h2><span id='topic+summary.Qest'></span>

<h3>Description</h3>

<p>Summary method for class &ldquo;Qest&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Qest'
summary(object, covar = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Qest_+3A_object">object</code></td>
<td>

<p>an object of class &ldquo;Qest&rdquo;.
</p>
</td></tr>
<tr><td><code id="summary.Qest_+3A_covar">covar</code></td>
<td>

<p>logical; if TRUE, the variance covariance matrix of the estimated parameters is returned.
</p>
</td></tr>
<tr><td><code id="summary.Qest_+3A_...">...</code></td>
<td>

<p>for future methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a summary of the most relevant information on model parameters, standard errors, and convergence status.
</p>


<h3>Value</h3>

<p>The function <code>summary.Qest</code> computes and returns a list of summary statistics of the fitted model given in object, using the &quot;call&quot; and &quot;terms&quot; from its argument, plus
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a matrix with 4 columns reporting the estimated coefficients, the estimated standard errors, the corresponding z-values (coef/se), and the two-sided p-values.</p>
</td></tr>
<tr><td><code>obj.function</code></td>
<td>
<p>the value of the minimized loss function (see <code><a href="#topic+Qest">Qest</a></code> for details).</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code>npar</code></td>
<td>
<p>the number of free parameters.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the number of iterations.</p>
</td></tr>
<tr><td><code>covar</code></td>
<td>
<p>only if <kbd>covar = TRUE</kbd>, the estimated covariance matrix.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>a character string defined as follows: <code>"c"</code> for right-censored data; <code>"ct"</code> for left-truncated, right-censored data; and <code>"u"</code> otherwise.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;
</p>


<h3>References</h3>

<p>Sottile G, and Frumento P (2022). <em>Robust estimation and regression with parametric quantile functions.</em> Computational Statistics and Data Analysis. &lt;doi:10.1016/j.csda.2022.107471&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Qest">Qest</a></code>, for model fitting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Quantile function of an Exponential model
Qexp &lt;- function(theta, tau, data){
  qexp(tau, exp(theta))
}

y &lt;- rexp(100, exp(1))
m1 &lt;- Qest(y ~ 1, Q = Qexp, start = NA)
summary(m1)
summary(m1, covar = TRUE)
</code></pre>

<hr>
<h2 id='wtrunc'>Weighting Function for <code>Qest</code>, <code>Qlm</code>, and <code>Qcoxph</code>.</h2><span id='topic+wtrunc'></span>

<h3>Description</h3>

<p>This function can be used within a call to <code>Qest</code>, <code>Qlm</code>, or <code>Qcoxph</code> to assign a different weight to each quantile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wtrunc(tau, delta.left = 0.05, delta.right = 0.05, smooth = FALSE, sigma = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wtrunc_+3A_tau">tau</code></td>
<td>
<p>a vector of quantiles.</p>
</td></tr>
<tr><td><code id="wtrunc_+3A_delta.left">delta.left</code>, <code id="wtrunc_+3A_delta.right">delta.right</code></td>
<td>
<p>proportion of quantiles to be removed from the left and righ tail. The weighting function is <code>1</code> in the interval <code>(delta.left, 1 - delta.right)</code>, and zero elsewhere. Default is <code>delta.left = 0.05</code> and <code>delta.right = 0.05</code>. When a weighting function is used to counteract the effect of extreme observations, <code>delta.left</code> is a guess for the proportion of outliers on the left tail; and <code>delta.right</code> is a guess for the proportion of outliers on the right tail.</p>
</td></tr>
<tr><td><code id="wtrunc_+3A_smooth">smooth</code></td>
<td>
<p>if <code>smooth = TRUE</code> the indicator functions used to construct <code>wtrunc(tau)</code> are replaced by integrated Gaussian kernels. Default <code>smooth = FALSE</code>.</p>
</td></tr>
<tr><td><code id="wtrunc_+3A_sigma">sigma</code></td>
<td>
<p>the bandwith of a Gaussian kernel. This parameter controls the smoothness of the weighting function, and is ignored if <code>smooth = FALSE</code>. Default <code>sigma = 0.01</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Within a call to <code><a href="#topic+Qest">Qest</a></code>, <code><a href="#topic+Qlm">Qlm</a></code>, or <code><a href="#topic+Qcoxph">Qcoxph</a></code>, one may want to assign a different weight to each quantile through the optional argument <code>wtau</code>. This can be done for reasons of efficiency, or to counteract the presence of outliers. While <code>wtau</code> can be any user-defined function, one can use <code>wtrunc</code> as a shortcut to construct a weighting function that truncates a certain subset of quantiles in the tails of the distribution. For instance, the estimator defined by <code>Qest(..., wtau = wtrunc, delta.left = 0.05, delta.right = 0.1)</code> only uses quantiles in the interval (0.05, 0.90) to fit the model. In this example, <code>delta.left = 0.05</code> is a guess for the proportion of outliers on the left tail; and <code>delta.right</code> is a guess for the proportion of outliers on the right tail.
Use <code>smooth = TRUE</code> to replace the indicator functions involved in <code>wtrunc</code> with smooth functions. Introducing a weighting function that only assigns a positive weight to the quantiles that correspond to the &ldquo;healthy&rdquo; part of the distribution allows to deal with any level of contamination by outliers.
</p>


<h3>Value</h3>

<p>A vector of weights assigned to each quantile.
</p>


<h3>Author(s)</h3>

<p>Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;, Paolo Frumento &lt;paolo.frumento@unipi.it&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Qest">Qest</a></code>, <code><a href="#topic+Qlm">Qlm</a></code>, <code><a href="#topic+Qcoxph">Qcoxph</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
taus &lt;- seq(0, 1, length.out = 1000)

### zero weight to quantiles above 0.95
plot(taus, wtrunc(taus, delta.left = 0, delta.right = 0.05),
  type = "l", lwd = 1.5)
# smooth counterpart
lines(taus, wtrunc(taus, delta.left = 0, delta.right = 0.05,
  smooth = TRUE, sigma = .01), col = 2, lwd = 1.5)
lines(taus, wtrunc(taus, delta.left = 0, delta.right = 0.05,
  smooth = TRUE, sigma = .05), col = 3, lwd = 1.5)

### zero weight to quantiles below 0.05
plot(taus, wtrunc(taus, delta.left = 0.05, delta.right = 0),
  type = "l", lwd = 1.5)
# smooth counterpart
lines(taus, wtrunc(taus, delta.left = 0.05, delta.right = 0,
  smooth = TRUE, sigma = .01), col = 2, lwd = 1.5)
lines(taus, wtrunc(taus, delta.left = 0.05, delta.right = 0,
  smooth = TRUE, sigma = .05), col = 3, lwd = 1.5)


### zero weight to quantiles below 0.05 and above 0.90
plot(taus, wtrunc(taus, delta.left = 0.05, delta.right = 0.10),
  type = "l", lwd = 1.5)
# smooth counterpart
lines(taus, wtrunc(taus, delta.left = 0.05, delta.right = 0.10,
  smooth = TRUE, sigma = .01), col = 2, lwd = 1.5)
lines(taus, wtrunc(taus, delta.left = 0.05, delta.right = 0.10,
  smooth = TRUE, sigma = .05), col = 3, lwd = 1.5)


### Use wtrunc in Qest, Qlm, Qcoxph
# Qest(..., wtau = wtrunc, delta.left = 0.05, delta.right = 0.1)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
