<!DOCTYPE html><html><head><title>Help for package gMOIP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gMOIP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gMOIP-package'><p>gMOIP: Tools for 2D and 3D Plots of Single and Multi-Objective Linear/Integer Programming Models</p></a></li>
<li><a href='#.checkPts'><p>Check if point input is okay</p></a></li>
<li><a href='#.getRanges'><p>Get ranges of the bounding box margins</p></a></li>
<li><a href='#.mToDirection'><p>Convert min/max to direction (1/-1)</p></a></li>
<li><a href='#.sizeM'><p>Estimate 1 em in pixels in the resulting png.</p></a></li>
<li><a href='#addNDSet'><p>Add discrete points to a non-dominated set and classify them into extreme supported, non-extreme</p>
supported, non-supported.</a></li>
<li><a href='#addNDSet2D'><p>Add 2D discrete points to a non-dominated set and classify them into extreme</p>
supported, non-extreme supported, non-supported.</a></li>
<li><a href='#addRays'><p>Add all points on the bounding box hit by the rays.</p></a></li>
<li><a href='#binaryPoints'><p>Binary (0-1) points in the feasible region (Ax&lt;=b).</p></a></li>
<li><a href='#classifyNDSet'><p>Classify a set of nondominated points</p></a></li>
<li><a href='#convexHull'><p>Find the convex hull of a set of points.</p></a></li>
<li><a href='#cornerPoints'><p>Calculate the corner points for the polytope Ax&lt;=b.</p></a></li>
<li><a href='#cornerPointsCont'><p>Calculate the corner points for the polytope Ax&lt;=b assuming all variables are</p>
continuous.</a></li>
<li><a href='#criterionPoints'><p>Calculate the criterion points of a set of points and ranges to find the set</p>
of non-dominated points (Pareto points) and classify them into extreme
supported, non-extreme supported, non-supported.</a></li>
<li><a href='#df2String'><p>Convert each row to a string.</p></a></li>
<li><a href='#dimFace'><p>Return the dimension of the convex hull of a set of points.</p></a></li>
<li><a href='#finalize3D'><p>Finalize the RGL window.</p></a></li>
<li><a href='#genNDSet'><p>Generate a sample of nondominated points.</p></a></li>
<li><a href='#genSample'><p>Generate a sample of points in dimension $p$.</p></a></li>
<li><a href='#getTexture'><p>Save a point symbol as a temporary file.</p></a></li>
<li><a href='#gMOIPTheme'><p>The <code>ggplot</code> theme for the package</p></a></li>
<li><a href='#hullSegment'><p>Find segments (lines) of a face.</p></a></li>
<li><a href='#inHull'><p>Efficient test for points inside a convex hull in p dimensions.</p></a></li>
<li><a href='#ini3D'><p>Initialize the RGL window.</p></a></li>
<li><a href='#integerPoints'><p>Integer points in the feasible region (Ax&lt;=b).</p></a></li>
<li><a href='#loadView'><p>Help function to load the view angle for the RGL 3D plot from a file or matrix</p></a></li>
<li><a href='#mergeLists'><p>Merge two lists to one</p></a></li>
<li><a href='#plotCones2D'><p>Plot a cone defined by a point in 2D.</p></a></li>
<li><a href='#plotCones3D'><p>Plot a cone defined by a point in 3D.</p></a></li>
<li><a href='#plotCriterion2D'><p>Create a plot of the criterion space of a bi-objective problem</p></a></li>
<li><a href='#plotHull2D'><p>Plot the convex hull of a set of points in 2D.</p></a></li>
<li><a href='#plotHull3D'><p>Plot the convex hull of a set of points in 3D.</p></a></li>
<li><a href='#plotLines2D'><p>Plot the lines of a linear mathematical program (Ax = b)</p></a></li>
<li><a href='#plotMTeX3D'><p>Plot TeX in the margin</p></a></li>
<li><a href='#plotNDSet2D'><p>Create a plot of a discrete non-dominated set.</p></a></li>
<li><a href='#plotPlane3D'><p>Plot a plane in 3D.</p></a></li>
<li><a href='#plotPoints3D'><p>Plot points in 3D.</p></a></li>
<li><a href='#plotPolygon3D'><p>Plot a polygon.</p></a></li>
<li><a href='#plotPolytope'><p>Plot the polytope (bounded convex set) of a linear mathematical program (Ax &lt;= b)</p></a></li>
<li><a href='#plotPolytope2D'><p>Plot the polytope (bounded convex set) of a linear mathematical program</p></a></li>
<li><a href='#plotPolytope3D'><p>Plot the polytope (bounded convex set) of a linear mathematical program</p></a></li>
<li><a href='#plotRectangle3D'><p>Plot a rectangle defined by two corner points.</p></a></li>
<li><a href='#plotTeX3D'><p>Plot TeX at a position.</p></a></li>
<li><a href='#plotTitleTeX3D'><p>Draw boxes, axes and other text outside the data using TeX strings.</p></a></li>
<li><a href='#pngSize'><p>To size of the png file.</p></a></li>
<li><a href='#saveView'><p>Help function to save the view angle for the RGL 3D plot</p></a></li>
<li><a href='#slices'><p>Find all corner points in the slices define for each fixed integer combination.</p></a></li>
<li><a href='#texToPng'><p>Convert LaTeX to a png file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for 2D and 3D Plots of Single and Multi-Objective
Linear/Integer Programming Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://relund.github.io/gMOIP/">https://relund.github.io/gMOIP/</a>, <a href="https://github.com/relund/gMOIP/">https://github.com/relund/gMOIP/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/relund/gMOIP/issues">https://github.com/relund/gMOIP/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Make 2D and 3D plots of linear programming (LP), 
    integer linear programming (ILP), or mixed integer linear programming (MILP) models 
    with up to three objectives. Plots of both the solution and criterion space are possible.
    For instance the non-dominated (Pareto) set for bi-objective LP/ILP/MILP programming models 
    (see vignettes for an overview). The package also contains an function for checking if a point
    is inside the convex hull.</td>
</tr>
<tr>
<td>License:</td>
<td></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggrepel, geometry, ggplot2, rgl, MASS, Matrix, grDevices,
stats, Rfast, plyr, tidyselect, tidyr, tibble, purrr, dplyr,
rlang, png, sp, eaf</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tikzDevice, grid, gridExtra, knitr, rmarkdown, roxygen2,
ggsci, magrittr, scales, pdftools, testthat (&ge; 2.1.0),
webshot2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-21 20:03:49 UTC; au15463</td>
</tr>
<tr>
<td>Author:</td>
<td>Lars Relund Nielsen
    <a href="https://orcid.org/0000-0002-4802-3071"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lars Relund Nielsen &lt;lars@relund.dk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-21 21:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='gMOIP-package'>gMOIP: Tools for 2D and 3D Plots of Single and Multi-Objective Linear/Integer Programming Models</h2><span id='topic+gMOIP'></span><span id='topic+gMOIP-package'></span>

<h3>Description</h3>

<p>Make 2D and 3D plots of linear programming (LP), integer linear programming (ILP), or mixed integer linear programming (MILP) models with up to three objectives. Plots of both the solution and criterion space are possible. For instance the non-dominated (Pareto) set for bi-objective LP/ILP/MILP programming models (see vignettes for an overview). The package also contains an function for checking if a point is inside the convex hull.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Lars Relund Nielsen <a href="mailto:lars@relund.dk">lars@relund.dk</a> (<a href="https://orcid.org/0000-0002-4802-3071">ORCID</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotPolytope">plotPolytope()</a></code>, <code><a href="#topic+plotCriterion2D">plotCriterion2D()</a></code> and <code><a href="#topic+plotHull3D">plotHull3D()</a></code>.
</p>

<hr>
<h2 id='.checkPts'>Check if point input is okay</h2><span id='topic+.checkPts'></span>

<h3>Description</h3>

<p>Check if point input is okay
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.checkPts(pts, p = NULL, warn = FALSE, stopUnique = TRUE, asDF = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".checkPts_+3A_pts">pts</code></td>
<td>
<p>Point input.</p>
</td></tr>
<tr><td><code id=".checkPts_+3A_p">p</code></td>
<td>
<p>Desired dimension of points.</p>
</td></tr>
<tr><td><code id=".checkPts_+3A_warn">warn</code></td>
<td>
<p>Output warnings.</p>
</td></tr>
<tr><td><code id=".checkPts_+3A_stopunique">stopUnique</code></td>
<td>
<p>Stop if rows not are unique.</p>
</td></tr>
<tr><td><code id=".checkPts_+3A_asdf">asDF</code></td>
<td>
<p>Return as data frame otherwise as matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Point input converted to a matrix.
</p>

<hr>
<h2 id='.getRanges'>Get ranges of the bounding box margins</h2><span id='topic+.getRanges'></span>

<h3>Description</h3>

<p>Get ranges of the bounding box margins
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getRanges(expand = 1.03, ranges = par3d("bbox"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getRanges_+3A_expand">expand</code></td>
<td>
<p>Expand margins.</p>
</td></tr>
<tr><td><code id=".getRanges_+3A_ranges">ranges</code></td>
<td>
<p>The bounding box.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with ranges.
</p>

<hr>
<h2 id='.mToDirection'>Convert min/max to direction (1/-1)</h2><span id='topic+.mToDirection'></span>

<h3>Description</h3>

<p>Convert min/max to direction (1/-1)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.mToDirection(m, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".mToDirection_+3A_m">m</code></td>
<td>
<p>Min/max vector.</p>
</td></tr>
<tr><td><code id=".mToDirection_+3A_p">p</code></td>
<td>
<p>Number of objectives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A direction vector (min = 1 and max = -1)
</p>

<hr>
<h2 id='.sizeM'>Estimate 1 em in pixels in the resulting png.</h2><span id='topic+.sizeM'></span>

<h3>Description</h3>

<p>Estimate 1 em in pixels in the resulting png.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.sizeM(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".sizeM_+3A_...">...</code></td>
<td>
<p>Arguments parsed on to <code>texToPng</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The width and size of the png.
</p>

<hr>
<h2 id='addNDSet'>Add discrete points to a non-dominated set and classify them into extreme supported, non-extreme
supported, non-supported.</h2><span id='topic+addNDSet'></span>

<h3>Description</h3>

<p>Add discrete points to a non-dominated set and classify them into extreme supported, non-extreme
supported, non-supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addNDSet(
  pts,
  nDSet = NULL,
  crit = "max",
  keepDom = FALSE,
  dubND = FALSE,
  classify = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addNDSet_+3A_pts">pts</code></td>
<td>
<p>A data frame with points to add (a column for each objective).</p>
</td></tr>
<tr><td><code id="addNDSet_+3A_ndset">nDSet</code></td>
<td>
<p>A data frame with current non-dominated set (NULL if none yet). Column names of the
p objectives must be <code style="white-space: pre;">&#8288;z1, ..., zp&#8288;</code>.</p>
</td></tr>
<tr><td><code id="addNDSet_+3A_crit">crit</code></td>
<td>
<p>A max or min vector. If length one assume all objectives are optimized in the same
direction.</p>
</td></tr>
<tr><td><code id="addNDSet_+3A_keepdom">keepDom</code></td>
<td>
<p>Keep dominated points in output.</p>
</td></tr>
<tr><td><code id="addNDSet_+3A_dubnd">dubND</code></td>
<td>
<p>Duplicated non-dominated points are classified as non-dominated.</p>
</td></tr>
<tr><td><code id="addNDSet_+3A_classify">classify</code></td>
<td>
<p>Non-dominated points are classified into supported extreme (<code>se</code>), supported
non-extreme (<code>sne</code>) and unsupported (<code>us</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with a column for each objective (<code>z</code> columns) and <code>nd</code> (non-dominated).
Moreover if <code>classify</code> then columns <code>se</code>, <code>sne</code>, <code>us</code> and <code>cls</code>.
</p>


<h3>Author(s)</h3>

<p>Lars Relund <a href="mailto:lars@relund.dk">lars@relund.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nDSet &lt;- data.frame(z1=c(12,14,16,18), z2=c(18,16,12,4))
pts &lt;- data.frame(z1 = c(18,18,14,15,15), z2=c(2,6,14,14,16))
addNDSet(pts, nDSet, crit = "max")
addNDSet(pts, nDSet, crit = "max", keepDom = TRUE)
addNDSet(pts, nDSet, crit = "min")
addNDSet(c(2,2), nDSet, crit = "max")
addNDSet(c(2,2), nDSet, crit = "min")


nDSet &lt;- data.frame(z1=c(12,14,16,18), z2=c(18,16,12,4), z3 = c(1,7,0,6))
pts &lt;- data.frame(z1=c(12,14,16,18), z2=c(18,16,12,4), z3 = c(2,2,2,6))
crit = c("min", "min", "max")
di &lt;- c(1,1,-1)
li &lt;- c(-1,20)
ini3D(argsPlot3d = list(xlim = li, ylim = li, zlim = li))
plotCones3D(nDSet, direction = di, argsPolygon3d = list(color = "green", alpha = 1),
            drawPoint = FALSE)
plotHull3D(nDSet, addRays = TRUE, direction = di)
plotPoints3D(nDSet, argsPlot3d = list(col = "red"), addText = "coord")
plotPoints3D(pts, addText = "coord")
finalize3D()
addNDSet(pts, nDSet, crit, dubND = FALSE)
addNDSet(pts, nDSet, crit, dubND = TRUE)
addNDSet(pts, nDSet, crit, dubND = TRUE, keepDom = TRUE)
addNDSet(pts, nDSet, crit, dubND = TRUE, keepDom = TRUE, classify = FALSE)

</code></pre>

<hr>
<h2 id='addNDSet2D'>Add 2D discrete points to a non-dominated set and classify them into extreme
supported, non-extreme supported, non-supported.</h2><span id='topic+addNDSet2D'></span>

<h3>Description</h3>

<p>Add 2D discrete points to a non-dominated set and classify them into extreme
supported, non-extreme supported, non-supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addNDSet2D(pts, nDSet = NULL, crit = "max", keepDom = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addNDSet2D_+3A_pts">pts</code></td>
<td>
<p>A data frame. It is assumed that z1 and z2 are in the two first columns.</p>
</td></tr>
<tr><td><code id="addNDSet2D_+3A_ndset">nDSet</code></td>
<td>
<p>A data frame with current non-dominated set (NULL is none yet).</p>
</td></tr>
<tr><td><code id="addNDSet2D_+3A_crit">crit</code></td>
<td>
<p>Either max or min.</p>
</td></tr>
<tr><td><code id="addNDSet2D_+3A_keepdom">keepDom</code></td>
<td>
<p>Keep dominated points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns z1 and z2, <code>nD</code> (non-dominated),
<code>ext</code> (extreme), <code>nonExt</code> (non-extreme supported).
</p>


<h3>Author(s)</h3>

<p>Lars Relund <a href="mailto:lars@relund.dk">lars@relund.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nDSet &lt;- data.frame(z1=c(12,14,16,18), z2=c(18,16,12,4))
pts &lt;- data.frame(z1 = c(18,18,14,15,15), z2=c(2,6,14,14,16))
addNDSet2D(pts, nDSet, crit = "max")
addNDSet2D(pts, nDSet, crit = "max", keepDom = TRUE)
addNDSet2D(pts, nDSet, crit = "min")
</code></pre>

<hr>
<h2 id='addRays'>Add all points on the bounding box hit by the rays.</h2><span id='topic+addRays'></span>

<h3>Description</h3>

<p>Add all points on the bounding box hit by the rays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addRays(
  pts,
  m = apply(pts, 2, min) - 5,
  M = apply(pts, 2, max) + 5,
  direction = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addRays_+3A_pts">pts</code></td>
<td>
<p>A data frame with all points</p>
</td></tr>
<tr><td><code id="addRays_+3A_m">m</code></td>
<td>
<p>Minimum values of the bounding box.</p>
</td></tr>
<tr><td><code id="addRays_+3A_m">M</code></td>
<td>
<p>Maximum values of the bounding box.</p>
</td></tr>
<tr><td><code id="addRays_+3A_direction">direction</code></td>
<td>
<p>Ray direction. If i'th entry is positive, consider the i'th column of the <code>pts</code>
plus a value greater than on equal zero. If negative, consider the i'th column of the <code>pts</code>
minus a value greater than on equal zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The points merged with the points on the bounding box. The column <code>pt</code> equals 1 if
points from <code>pts</code> and zero otherwise.
</p>


<h3>Note</h3>

<p>Assume that <code>pts</code> has been checked using <code><a href="#topic+.checkPts">.checkPts()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pts &lt;- genNDSet(3,10)[,1:3]
addRays(pts)
addRays(pts, dir = c(1,-1,1))
addRays(pts, dir = c(-1,-1,1), m = c(0,0,0), M = c(100,100,100))
pts &lt;- genSample(5,20)[,1:5]
addRays(pts)
</code></pre>

<hr>
<h2 id='binaryPoints'>Binary (0-1) points in the feasible region (Ax&lt;=b).</h2><span id='topic+binaryPoints'></span>

<h3>Description</h3>

<p>Binary (0-1) points in the feasible region (Ax&lt;=b).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binaryPoints(A, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binaryPoints_+3A_a">A</code></td>
<td>
<p>Constraint matrix.</p>
</td></tr>
<tr><td><code id="binaryPoints_+3A_b">b</code></td>
<td>
<p>Right hand side.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with all binary points inside the feasible region.
</p>


<h3>Note</h3>

<p>Do a simple enumeration of all binary points. Will not work if <code>ncol(A)</code> large.
</p>


<h3>Author(s)</h3>

<p>Lars Relund <a href="mailto:lars@relund.dk">lars@relund.dk</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix( c(3,-2, 1, 2, 4,-2,-3, 2, 1), nc = 3, byrow = TRUE)
b &lt;- c(10, 12, 3)
binaryPoints(A, b)

A &lt;- matrix(c(9, 10, 2, 4, -3, 2), ncol = 2, byrow = TRUE)
b &lt;- c(90, 27, 3)
binaryPoints(A, b)
</code></pre>

<hr>
<h2 id='classifyNDSet'>Classify a set of nondominated points</h2><span id='topic+classifyNDSet'></span>

<h3>Description</h3>

<p>The classification is supported (true/false), extreme (true/false), supported non-extreme
(true/false)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classifyNDSet(pts, direction = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classifyNDSet_+3A_pts">pts</code></td>
<td>
<p>A set of non-dominated points. It is assumed that <code>ncol(pts)</code> equals the number of
objectives ($p$).</p>
</td></tr>
<tr><td><code id="classifyNDSet_+3A_direction">direction</code></td>
<td>
<p>Ray direction. If i'th entry is positive, consider the i'th column of the <code>pts</code>
plus a value greater than on equal zero (minimize objective $i$). If negative, consider the
i'th column of the <code>pts</code> minus a value greater than on equal zero (maximize objective $i$).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ND set with classification columns.
</p>


<h3>Note</h3>

<p>It is assumed that <code>pts</code> are nondominated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pts &lt;- matrix(c(0,0,1, 0,1,0, 1,0,0, 0.5,0.2,0.5, 0.25,0.5,0.25), ncol = 3, byrow = TRUE)
ini3D(argsPlot3d = list(xlim = c(min(pts[,1])-2,max(pts[,1])+2),
  ylim = c(min(pts[,2])-2,max(pts[,2])+2),
  zlim = c(min(pts[,3])-2,max(pts[,3])+2)))
plotHull3D(pts, addRays = TRUE, argsPolygon3d = list(alpha = 0.5), useRGLBBox = TRUE)
pts &lt;- classifyNDSet(pts[,1:3])
plotPoints3D(pts[pts$se,1:3], argsPlot3d = list(col = "red"))
plotPoints3D(pts[pts$sne,1:3], argsPlot3d = list(col = "black"))
plotPoints3D(pts[pts$us,1:3], argsPlot3d = list(col = "blue"))
plotCones3D(pts[,1:3], rectangle = TRUE, argsPolygon3d = list(alpha = 1))
finalize3D()
pts

pts &lt;- matrix(c(0,0,1, 0,1,0, 1,0,0, 0.2,0.1,0.1, 0.1,0.45,0.45), ncol = 3, byrow = TRUE)
di &lt;- -1 # maximize
ini3D(argsPlot3d = list(xlim = c(min(pts[,1])-1,max(pts[,1])+1),
  ylim = c(min(pts[,2])-1,max(pts[,2])+1),
  zlim = c(min(pts[,3])-1,max(pts[,3])+1)))
plotHull3D(pts, addRays = TRUE, argsPolygon3d = list(alpha = 0.5), direction = di,
           addText = "coord")
pts &lt;- classifyNDSet(pts[,1:3], direction = di)
plotPoints3D(pts[pts$se,1:3], argsPlot3d = list(col = "red"))
plotPoints3D(pts[pts$sne,1:3], argsPlot3d = list(col = "black"))
plotPoints3D(pts[pts$us,1:3], argsPlot3d = list(col = "blue"))
plotCones3D(pts[,1:3], rectangle = TRUE, argsPolygon3d = list(alpha = 1), direction = di)
finalize3D()
pts

pts &lt;- matrix(c(0,0,1, 0,0,1, 0,1,0, 0.5,0.2,0.5, 1,0,0, 0.5,0.2,0.5, 0.25,0.5,0.25), ncol = 3,
              byrow = TRUE)
classifyNDSet(pts)

pts &lt;- genNDSet(3,15)[,1:3]
ini3D(argsPlot3d = list(xlim = c(0,max(pts$z1)+2),
  ylim = c(0,max(pts$z2)+2),
  zlim = c(0,max(pts$z3)+2)))
plotHull3D(pts[, 1:3], addRays = TRUE, argsPolygon3d = list(alpha = 0.5))
pts &lt;- classifyNDSet(pts[,1:3])
plotPoints3D(pts[pts$se,1:3], argsPlot3d = list(col = "red"))
plotPoints3D(pts[pts$sne,1:3], argsPlot3d = list(col = "black"))
plotPoints3D(pts[pts$us,1:3], argsPlot3d = list(col = "blue"))
finalize3D()
pts

pts &lt;- genNDSet(3, 15, keepDom = FALSE, argsSphere = list(below = FALSE, factor = 10))[,1:3]
ini3D(argsPlot3d = list(xlim = c(0,max(pts$z1)+2),
  ylim = c(0,max(pts$z2)+2),
  zlim = c(0,max(pts$z3)+2)))
plotHull3D(pts[, 1:3], addRays = TRUE, argsPolygon3d = list(alpha = 0.5))
pts &lt;- classifyNDSet(pts[,1:3])
plotPoints3D(pts[pts$se,1:3], argsPlot3d = list(col = "red"))
plotPoints3D(pts[pts$sne,1:3], argsPlot3d = list(col = "black"))
plotPoints3D(pts[pts$us,1:3], argsPlot3d = list(col = "blue"))
finalize3D()
pts

</code></pre>

<hr>
<h2 id='convexHull'>Find the convex hull of a set of points.</h2><span id='topic+convexHull'></span>

<h3>Description</h3>

<p>Find the convex hull of a set of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convexHull(
  pts,
  addRays = FALSE,
  useRGLBBox = FALSE,
  direction = 1,
  tol = mean(mean(abs(pts))) * sqrt(.Machine$double.eps) * 2,
  m = apply(pts, 2, min) - 5,
  M = apply(pts, 2, max) + 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convexHull_+3A_pts">pts</code></td>
<td>
<p>A matrix with a point in each row.</p>
</td></tr>
<tr><td><code id="convexHull_+3A_addrays">addRays</code></td>
<td>
<p>Add the ray defined by <code>direction</code>.</p>
</td></tr>
<tr><td><code id="convexHull_+3A_userglbbox">useRGLBBox</code></td>
<td>
<p>Use the RGL bounding box when add rays.</p>
</td></tr>
<tr><td><code id="convexHull_+3A_direction">direction</code></td>
<td>
<p>Ray direction. If i'th entry is positive, consider the i'th column of <code>pts</code>
plus a value greater than on equal zero (minimize objective $i$). If negative, consider the
i'th column of <code>pts</code> minus a value greater than on equal zero (maximize objective $i$).</p>
</td></tr>
<tr><td><code id="convexHull_+3A_tol">tol</code></td>
<td>
<p>Tolerance on standard deviation if using PCA.</p>
</td></tr>
<tr><td><code id="convexHull_+3A_m">m</code></td>
<td>
<p>Minimum values of the bounding box.</p>
</td></tr>
<tr><td><code id="convexHull_+3A_m">M</code></td>
<td>
<p>Maximum values of the bounding box.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with <code>hull</code> equal a matrix with row indices of the vertices defining each
facet in the hull and <code>pts</code> equal the input points (and dummy points) and columns:
<code>pt</code>, true if a point in the original input; false if a dummy point (a point on a ray).
<code>vtx</code>, TRUE if a vertex in the hull.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1D
pts&lt;-matrix(c(1,2,3), ncol = 1, byrow = TRUE)
dimFace(pts) # a line
convexHull(pts)
convexHull(pts, addRays = TRUE)

## 2D
pts&lt;-matrix(c(1,1, 2,2), ncol = 2, byrow = TRUE)
dimFace(pts) # a line
convexHull(pts)
plotHull2D(pts, drawPoints = TRUE)
convexHull(pts, addRays = TRUE)
plotHull2D(pts, addRays = TRUE, drawPoints = TRUE)
pts&lt;-matrix(c(1,1, 2,2, 0,1), ncol = 2, byrow = TRUE)
dimFace(pts) # a polygon
convexHull(pts)
plotHull2D(pts, drawPoints = TRUE)
convexHull(pts, addRays = TRUE, direction = c(-1,1))
plotHull2D(pts, addRays = TRUE, direction = c(-1,1), addText = "coord")

## 3D
pts&lt;-matrix(c(1,1,1), ncol = 3, byrow = TRUE)
dimFace(pts) # a point
convexHull(pts)
pts&lt;-matrix(c(0,0,0,1,1,1,2,2,2,3,3,3), ncol = 3, byrow = TRUE)
dimFace(pts) # a line
convexHull(pts)
pts&lt;-matrix(c(0,0,0,0,1,1,0,2,2,0,0,2), ncol = 3, byrow = TRUE)
dimFace(pts) # a polygon
convexHull(pts)
convexHull(pts, addRays = TRUE)
pts&lt;-matrix(c(1,0,0,1,1,1,1,2,2,3,1,1), ncol = 3, byrow = TRUE)
dimFace(pts) # a polygon
convexHull(pts) # a polyhedron
pts&lt;-matrix(c(1,1,1,2,2,1,2,1,1,1,1,2), ncol = 3, byrow = TRUE)
dimFace(pts) # a polytope (polyhedron)
convexHull(pts)

ini3D(argsPlot3d = list(xlim = c(0,3), ylim = c(0,3), zlim = c(0,3)))
pts&lt;-matrix(c(1,1,1,2,2,1,2,1,1,1,1,2), ncol = 3, byrow = TRUE)
plotPoints3D(pts)
plotHull3D(pts, argsPolygon3d = list(color = "red"))
convexHull(pts)
plotHull3D(pts, addRays = TRUE)
convexHull(pts, addRays = TRUE)
finalize3D()

</code></pre>

<hr>
<h2 id='cornerPoints'>Calculate the corner points for the polytope Ax&lt;=b.</h2><span id='topic+cornerPoints'></span>

<h3>Description</h3>

<p>Calculate the corner points for the polytope Ax&lt;=b.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cornerPoints(A, b, type = rep("c", ncol(A)), nonneg = rep(TRUE, ncol(A)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cornerPoints_+3A_a">A</code></td>
<td>
<p>Constraint matrix.</p>
</td></tr>
<tr><td><code id="cornerPoints_+3A_b">b</code></td>
<td>
<p>Right hand side.</p>
</td></tr>
<tr><td><code id="cornerPoints_+3A_type">type</code></td>
<td>
<p>A character vector of same length as number of variables. If
entry k is 'i' variable <code class="reqn">k</code> must be integer and if 'c' continuous.</p>
</td></tr>
<tr><td><code id="cornerPoints_+3A_nonneg">nonneg</code></td>
<td>
<p>A boolean vector of same length as number of variables. If
entry k is TRUE then variable k must be non-negative.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with a corner point in each row.
</p>


<h3>Author(s)</h3>

<p>Lars Relund <a href="mailto:lars@relund.dk">lars@relund.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix( c(3,-2, 1, 2, 4,-2,-3, 2, 1), nc = 3, byrow = TRUE)
b &lt;- c(10, 12, 3)
cornerPoints(A, b, type = c("c", "c", "c"))
cornerPoints(A, b, type = c("i", "i", "i"))
cornerPoints(A, b, type = c("i", "c", "c"))
</code></pre>

<hr>
<h2 id='cornerPointsCont'>Calculate the corner points for the polytope Ax&lt;=b assuming all variables are
continuous.</h2><span id='topic+cornerPointsCont'></span>

<h3>Description</h3>

<p>Calculate the corner points for the polytope Ax&lt;=b assuming all variables are
continuous.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cornerPointsCont(A, b, nonneg = rep(TRUE, ncol(A)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cornerPointsCont_+3A_a">A</code></td>
<td>
<p>Constraint matrix.</p>
</td></tr>
<tr><td><code id="cornerPointsCont_+3A_b">b</code></td>
<td>
<p>Right hand side.</p>
</td></tr>
<tr><td><code id="cornerPointsCont_+3A_nonneg">nonneg</code></td>
<td>
<p>A boolean vector of same length as number of variables. If
entry k is TRUE then variable k must be non-negative.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with a corner point in each row.
</p>


<h3>Author(s)</h3>

<p>Lars Relund <a href="mailto:lars@relund.dk">lars@relund.dk</a>
</p>

<hr>
<h2 id='criterionPoints'>Calculate the criterion points of a set of points and ranges to find the set
of non-dominated points (Pareto points) and classify them into extreme
supported, non-extreme supported, non-supported.</h2><span id='topic+criterionPoints'></span>

<h3>Description</h3>

<p>Calculate the criterion points of a set of points and ranges to find the set
of non-dominated points (Pareto points) and classify them into extreme
supported, non-extreme supported, non-supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>criterionPoints(pts, obj, crit, labels = "coord")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="criterionPoints_+3A_pts">pts</code></td>
<td>
<p>A data frame with a column for each variable in the solution
space (can also be a <code>rangePoints</code>).</p>
</td></tr>
<tr><td><code id="criterionPoints_+3A_obj">obj</code></td>
<td>
<p>A p x n matrix(one row for each criterion).</p>
</td></tr>
<tr><td><code id="criterionPoints_+3A_crit">crit</code></td>
<td>
<p>Either <code>max</code> or <code>min</code>.</p>
</td></tr>
<tr><td><code id="criterionPoints_+3A_labels">labels</code></td>
<td>
<p>If <code>NULL</code> or &quot;n&quot; don't add any labels (empty string). If
equals <code>coord</code>, labels are the solution space coordinates. Otherwise number all
points from one based on the solution space points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns <code style="white-space: pre;">&#8288;x1, ..., xn, z1, ..., zp, lbl (label), nD (non-dominated), ext (extreme), nonExt (non-extreme supported)&#8288;</code>.
</p>


<h3>Author(s)</h3>

<p>Lars Relund <a href="mailto:lars@relund.dk">lars@relund.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix( c(3, -2, 1, 2, 4, -2, -3, 2, 1), nc = 3, byrow = TRUE)
b &lt;- c(10,12,3)
pts &lt;- integerPoints(A, b)
obj &lt;- matrix( c(1,-3,1,-1,1,-1), byrow = TRUE, ncol = 3 )
criterionPoints(pts, obj, crit = "max", labels = "numb")
</code></pre>

<hr>
<h2 id='df2String'>Convert each row to a string.</h2><span id='topic+df2String'></span>

<h3>Description</h3>

<p>Convert each row to a string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df2String(df, round = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df2String_+3A_df">df</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="df2String_+3A_round">round</code></td>
<td>
<p>How many digits to round</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of strings.
</p>

<hr>
<h2 id='dimFace'>Return the dimension of the convex hull of a set of points.</h2><span id='topic+dimFace'></span>

<h3>Description</h3>

<p>Return the dimension of the convex hull of a set of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimFace(pts, dim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimFace_+3A_pts">pts</code></td>
<td>
<p>A matrix/data frame/vector that can be converted to a matrix with a row for each
point.</p>
</td></tr>
<tr><td><code id="dimFace_+3A_dim">dim</code></td>
<td>
<p>The dimension of the points, i.e. assume that column 1-dim specify the points. If
NULL assume that the dimension are the number of columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The dimension of the object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## In 1D
pts &lt;- matrix(c(3), ncol = 1, byrow = TRUE)
dimFace(pts)
pts &lt;- matrix(c(1,3,4), ncol = 1, byrow = TRUE)
dimFace(pts)

## In 2D
pts &lt;- matrix(c(3,3,6,3,3,6), ncol = 2, byrow = TRUE)
dimFace(pts)
pts &lt;- matrix(c(1,1,2,2,3,3), ncol = 2, byrow = TRUE)
dimFace(pts)
pts &lt;- matrix(c(0,0), ncol = 2, byrow = TRUE)
dimFace(pts)

## In 3D
pts &lt;- c(3,3,3,6,3,3,3,6,3,6,6,3)
dimFace(pts, dim = 3)
pts &lt;- matrix( c(1,1,1), ncol = 3, byrow = TRUE)
dimFace(pts)
pts &lt;- matrix( c(1,1,1,2,2,2), ncol = 3, byrow = TRUE)
dimFace(pts)
pts &lt;- matrix(c(2,2,2,3,2,2), ncol=3, byrow= TRUE)
dimFace(pts)
pts &lt;- matrix(c(0,0,0,0,1,1,0,2,2,0,5,2,0,6,1), ncol = 3, byrow = TRUE)
dimFace(pts)
pts &lt;- matrix(c(0,0,0,0,1,1,0,2,2,0,0,2,1,1,1), ncol = 3, byrow = TRUE)
dimFace(pts)

## In 4D
pts &lt;- matrix(c(2,2,2,3,2,2,3,4,1,2,3,4), ncol=4, byrow= TRUE)
dimFace(pts,)
</code></pre>

<hr>
<h2 id='finalize3D'>Finalize the RGL window.</h2><span id='topic+finalize3D'></span>

<h3>Description</h3>

<p>Finalize the RGL window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finalize3D(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="finalize3D_+3A_...">...</code></td>
<td>
<p>Further arguments passed on the the RGL plotting functions. This must be done as
lists. Currently the following arguments are supported:
</p>

<ul>
<li> <p><code>argsAxes3d</code>: A list of arguments for <code><a href="rgl.html#topic+axes3d">rgl::axes3d</a></code>.
</p>
</li>
<li> <p><code>argsTitle3d</code>: A list of arguments for <code><a href="rgl.html#topic+axes3d">rgl::title3d</a></code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>The RGL object (using <code><a href="rgl.html#topic+rglIds">rgl::highlevel()</a></code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ini3D()
pts&lt;-matrix(c(1,1,1,5,5,5), ncol = 3, byrow = TRUE)
plotPoints3D(pts)
finalize3D()

ini3D()
pts&lt;-matrix(c(1,1,1,5,5,5), ncol = 3, byrow = TRUE)
plotPoints3D(pts)
finalize3D(argsAxes3d = list(edges = "bbox"))

</code></pre>

<hr>
<h2 id='genNDSet'>Generate a sample of nondominated points.</h2><span id='topic+genNDSet'></span>

<h3>Description</h3>

<p>Generate a sample of nondominated points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genNDSet(
  p,
  n,
  range = c(1, 100),
  random = FALSE,
  sphere = TRUE,
  planes = FALSE,
  box = FALSE,
  keepDom = FALSE,
  crit = "min",
  dubND = FALSE,
  classify = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genNDSet_+3A_p">p</code></td>
<td>
<p>Dimension of the points.</p>
</td></tr>
<tr><td><code id="genNDSet_+3A_n">n</code></td>
<td>
<p>Number nondominated points generated.</p>
</td></tr>
<tr><td><code id="genNDSet_+3A_range">range</code></td>
<td>
<p>The range of the points in each dimension (a vector or matrix with <code>p</code> rows).</p>
</td></tr>
<tr><td><code id="genNDSet_+3A_random">random</code></td>
<td>
<p>Random sampling.</p>
</td></tr>
<tr><td><code id="genNDSet_+3A_sphere">sphere</code></td>
<td>
<p>Generate points on a sphere.</p>
</td></tr>
<tr><td><code id="genNDSet_+3A_planes">planes</code></td>
<td>
<p>Generate points between two planes.</p>
</td></tr>
<tr><td><code id="genNDSet_+3A_box">box</code></td>
<td>
<p>Generate points in boxes.</p>
</td></tr>
<tr><td><code id="genNDSet_+3A_keepdom">keepDom</code></td>
<td>
<p>Keep dominated points also.</p>
</td></tr>
<tr><td><code id="genNDSet_+3A_crit">crit</code></td>
<td>
<p>Criteria used (a vector of min/max).</p>
</td></tr>
<tr><td><code id="genNDSet_+3A_dubnd">dubND</code></td>
<td>
<p>Should duplicated non-dominated points be considered as non-dominated.</p>
</td></tr>
<tr><td><code id="genNDSet_+3A_classify">classify</code></td>
<td>
<p>Non-dominated points are classified into supported extreme (<code>se</code>), supported
non-extreme (<code>sne</code>) and unsupported (<code>us</code>)</p>
</td></tr>
<tr><td><code id="genNDSet_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code><a href="#topic+genSample">genSample</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with <code>p+1</code> columns (last one indicate if dominated or not).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Random
range &lt;- matrix(c(1,100, 50, 100, 10, 50), ncol = 2, byrow = TRUE)
pts &lt;- genNDSet(3, 5, range = range, random = TRUE, keepDom = TRUE)
head(pts)
Rfast::colMinsMaxs(as.matrix(pts[, 1:3]))
ini3D(FALSE, argsPlot3d = list(xlim = c(min(pts[,1])-2,max(pts[,1])+10),
  ylim = c(min(pts[,2])-2,max(pts[,2])+10),
  zlim = c(min(pts[,3])-2,max(pts[,3])+10)))
plotPoints3D(pts[,1:3])
plotPoints3D(pts[pts$nd,1:3], argsPlot3d = list(col = "red", size = 10))
plotCones3D(pts[pts$nd,1:3], argsPolygon3d = list(alpha = 1))
finalize3D()


## Between planes
range &lt;- matrix(c(1,10000, 1,10000), ncol = 2, byrow = TRUE)
pts &lt;- genNDSet(2, 50, range = range, planes = TRUE, classify = TRUE)
head(pts)
Rfast::colMinsMaxs(as.matrix(pts[, 1:2]))
plot(pts[, 1:2])

range &lt;- matrix(c(1,100, 50,100, 10, 50), ncol = 2, byrow = TRUE)
center &lt;- rowMeans(range)
planeU &lt;- c(rep(1, 3), -1.2*sum(rowMeans(range)))
planeL &lt;- c(rep(1, 3), -0.8*sum(rowMeans(range)))
pts &lt;- genNDSet(3, 50, range = range, planes = TRUE, keepDom = TRUE, classify = TRUE,
   argsPlanes = list(center = center, planeU = planeU, planeL = planeL))
head(pts)
Rfast::colMinsMaxs(as.matrix(pts[, 1:3]))
ini3D(FALSE, argsPlot3d = list(xlim = c(min(pts[,1])-2,max(pts[,1])+10),
  ylim = c(min(pts[,2])-2,max(pts[,2])+10),
  zlim = c(min(pts[,3])-2,max(pts[,3])+10),
  box = TRUE, axes = TRUE))
plotPoints3D(pts[,1:3])
plotPoints3D(pts[pts$nd,1:3], argsPlot3d = list(col = "red", size = 10))
rgl::planes3d(planeL[1], planeL[2], planeL[3], planeL[4], alpha = 0.5)
rgl::planes3d(planeU[1], planeU[2], planeU[3], planeU[4], alpha = 0.5)
finalize3D()


## On a sphere
ini3D()
range &lt;- c(1,100)
cent &lt;- rep(range[1] + (range[2]-range[1])/2, 3)
pts &lt;- genNDSet(3, 20, range = range, sphere = TRUE, keepDom = TRUE,
       argsSphere = list(center = cent))
rgl::spheres3d(cent, radius=49.5, color = "grey100", alpha=0.1)
plotPoints3D(pts)
plotPoints3D(pts[pts$nd,], argsPlot3d = list(col = "red", size = 10))
rgl::planes3d(cent[1],cent[2],cent[3],-sum(cent^2), alpha = 0.5, col = "red")
finalize3D()

ini3D()
cent &lt;- c(100,100,100)
r &lt;- 75
planeC &lt;- c(cent+r/3)
planeC &lt;- c(planeC, -sum(planeC^2))
pts &lt;- genNDSet(3, 20, keepDom = TRUE,
  argsSphere = list(center = cent, radius = r, below = FALSE, plane = planeC, factor = 6))
rgl::spheres3d(cent, radius=r, color = "grey100", alpha=0.1)
plotPoints3D(pts)
plotPoints3D(pts[pts$nd,], argsPlot3d = list(col = "red", size = 10))
rgl::planes3d(planeC[1],planeC[2],planeC[3],planeC[4], alpha = 0.5, col = "red")
finalize3D()

</code></pre>

<hr>
<h2 id='genSample'>Generate a sample of points in dimension $p$.</h2><span id='topic+genSample'></span>

<h3>Description</h3>

<p>Generate a sample of points in dimension $p$.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genSample(
  p,
  n,
  range = c(1, 100),
  random = FALSE,
  sphere = TRUE,
  planes = FALSE,
  box = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genSample_+3A_p">p</code></td>
<td>
<p>Dimension of the points.</p>
</td></tr>
<tr><td><code id="genSample_+3A_n">n</code></td>
<td>
<p>Number of samples generated.</p>
</td></tr>
<tr><td><code id="genSample_+3A_range">range</code></td>
<td>
<p>The range of the points in each dimension (a vector or matrix with <code>p</code> rows).</p>
</td></tr>
<tr><td><code id="genSample_+3A_random">random</code></td>
<td>
<p>Random sampling.</p>
</td></tr>
<tr><td><code id="genSample_+3A_sphere">sphere</code></td>
<td>
<p>Generate points on a sphere.</p>
</td></tr>
<tr><td><code id="genSample_+3A_planes">planes</code></td>
<td>
<p>Generate points between two planes.</p>
</td></tr>
<tr><td><code id="genSample_+3A_box">box</code></td>
<td>
<p>Generate points in boxes.</p>
</td></tr>
<tr><td><code id="genSample_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to the method for generating points. This must be done as
lists (see examples). Currently the following arguments are supported:
</p>

<ul>
<li> <p><code>argsPlanes</code>: A list of arguments for generating points between planes and in the cube
defined by the range:
</p>

<ul>
<li> <p><code>center</code>: A point between the planes (default <code>rowMeans(range)</code>).
</p>
</li>
<li> <p><code>planeU</code>: The upper plane (default <code>c(rep(1, p), -1.2*sum(center))</code>).
</p>
</li>
<li> <p><code>planeL</code>: The lower plane (default <code>c(rep(1, p), -0.8*sum(center))</code>).
</p>
</li></ul>

</li>
<li> <p><code>argsSphere</code>: A list of arguments for generating points on a sphere:
</p>

<ul>
<li> <p><code>radius</code>: The radius of the sphere.
</p>
</li>
<li> <p><code>center</code>: The center of the sphere.
</p>
</li>
<li> <p><code>plane</code>: The plane used.
</p>
</li>
<li> <p><code>below</code>: Either true (generate points below the plane), false (generate points above the
plane) or <code>NULL</code> (generated on the whole sphere).
</p>
</li>
<li> <p><code>factor</code>: If using a plane. Then the factor to multiply <code>n</code> with, so generate enough points
below/above the plane.
</p>
</li>
<li> <p><code>closeToPlane</code>: If TRUE only return points close to the plane.
</p>
</li></ul>

</li>
<li> <p><code>argsBox</code>: A list of arguments for generating points inside boxes:
</p>

<ul>
<li> <p><code>intervals</code>: Number of intervals to split the length of the range into. That is, each
range is divided into <code>intervals</code> (sub)intervals and only the lowest/highest
subrange is used.
</p>
</li>
<li> <p><code>cor</code>: How to correlate indices. If <code>'idxAlt'</code> then alternate the intervals (high/low)
for each dimension. For instance if <code>p = 3</code> and the first dimension is in the high
interval range then the second will be in the low interval range and third in the
high interval range again. If <code>idxRand</code> then choose the low/high interval range
for each dimension based on <code>prHigh</code>. If <code>idxSplit</code> then select
<code>floor(p/2):ceiling(p/2)</code> dimensions for the high interval range and the other for
the low interval range.
</p>
</li>
<li> <p><code>prHigh</code>: Probability for choosing the high interval range in each dimension.
</p>
</li></ul>

</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Note having ranges with different length when using the sphere method, doesn't make
sense. The best option is properly to use a center and radius here. Moreover, as for higher
<code>p</code> you may have to use a larger radius than half of the desired interval range.
</p>


<h3>Value</h3>

<p>A matrix with <code>p</code> columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Using random
## p = 2
range &lt;- matrix(c(1,100, 50,100), ncol = 2, byrow = TRUE )
pts &lt;- genSample(2, 1000, range = range, random = TRUE)
head(pts)
Rfast::colMinsMaxs(as.matrix(pts))
plot(pts)


## p = 3
range &lt;- matrix(c(1,100, 50,100, 10,50), ncol = 2, byrow = TRUE )
ini3D()
pts &lt;- genSample(3, 1000, range = range, random = TRUE)
head(pts)
Rfast::colMinsMaxs(as.matrix(pts))
plotPoints3D(pts)
finalize3D()


## other p
p &lt;- 10
range &lt;- c(1,100)
pts &lt;- genSample(p, 1000, range = range, random = TRUE)
head(pts)
Rfast::colMinsMaxs(as.matrix(pts))


### Using planes
## p = 2
range &lt;- matrix(c(1,100, 50,100), ncol = 2, byrow = TRUE )
center &lt;- rowMeans(range)
planeU &lt;- c(rep(1, 2), -1.5*sum(rowMeans(range)))
planeL &lt;- c(rep(1, 2), -0.7*sum(rowMeans(range)))
pts &lt;- genSample(2, 1000, range = range, planes = TRUE,
   argsPlanes = list(center = center, planeU = planeU, planeL = planeL))
head(pts)
Rfast::colMinsMaxs(as.matrix(pts))
plot(pts)


## p = 3
range &lt;- matrix(c(1,100, 50,100, 10, 50), ncol = 2, byrow = TRUE )
center &lt;- rowMeans(range)
planeU &lt;- c(rep(1, 3), -1.2*sum(rowMeans(range)))
planeL &lt;- c(rep(1, 3), -0.6*sum(rowMeans(range)))
pts &lt;- genSample(3, 1000, range = range, planes = TRUE,
   argsPlanes = list(center = center, planeU = planeU, planeL = planeL))
head(pts)
Rfast::colMinsMaxs(as.matrix(pts))
ini3D(argsPlot3d = list(box = TRUE, axes = TRUE))
plotPoints3D(pts)
rgl::planes3d(planeL[1], planeL[2], planeL[3], planeL[4], alpha = 0.5)
rgl::planes3d(planeU[1], planeU[2], planeU[3], planeU[4], alpha = 0.5)
finalize3D()



### Using sphere
## p = 2
range &lt;- c(1,100)
cent &lt;- rep(range[1] + (range[2]-range[1])/2, 2)
pts &lt;- genSample(2, 1000, range = range)
dim(pts)
Rfast::colMinsMaxs(as.matrix(pts))
plot(pts, asp=1)
abline(sum(cent^2)/cent[1], -cent[2]/cent[1])

cent &lt;- c(100,100)
r &lt;- 75
planeC &lt;- c(cent+r/3)
planeC &lt;- c(planeC, -sum(planeC^2))
pts &lt;- genSample(2, 100,
  argsSphere = list(center = cent, radius = r, below = FALSE, plane = planeC, factor = 6))
dim(pts)
Rfast::colMinsMaxs(as.matrix(pts))
plot(pts, asp=1)
abline(-planeC[3]/planeC[1], -planeC[2]/planeC[1])

pts &lt;- genSample(2, 100, argsSphere = list(center = cent, radius = r, below = NULL))
dim(pts)
Rfast::colMinsMaxs(as.matrix(pts))
plot(pts, asp=1)


## p = 3
ini3D()
range &lt;- c(1,100)
cent &lt;- rep(range[1] + (range[2]-range[1])/2, 3)
pts &lt;- genSample(3, 1000, range = range)
dim(pts)
Rfast::colMinsMaxs(as.matrix(pts))
rgl::spheres3d(cent, radius=49.5, color = "grey100", alpha=0.1)
plotPoints3D(pts)
rgl::planes3d(cent[1],cent[2],cent[3],-sum(cent^2), alpha = 0.5, col = "red")
finalize3D()

ini3D()
cent &lt;- c(100,100,100)
r &lt;- 75
planeC &lt;- c(cent+r/3)
planeC &lt;- c(planeC, -sum(planeC^2))
pts &lt;- genSample(3, 100,
  argsSphere = list(center = cent, radius = r, below = FALSE, plane = planeC, factor = 6))
rgl::spheres3d(cent, radius=r, color = "grey100", alpha=0.1)
plotPoints3D(pts)
rgl::planes3d(planeC[1],planeC[2],planeC[3],planeC[4], alpha = 0.5, col = "red")
finalize3D()

ini3D()
pts &lt;- genSample(3, 10000, argsSphere = list(center = cent, radius = r, below = NULL))
Rfast::colMinsMaxs(as.matrix(pts))
rgl::spheres3d(cent, radius=r, color = "grey100", alpha=0.1)
plotPoints3D(pts)
finalize3D()


## Other p
p &lt;- 10
cent &lt;- rep(0,p)
r &lt;- 100
pts &lt;- genSample(p, 100000, argsSphere = list(center = cent, radius = r, below = NULL))
head(pts)
Rfast::colMinsMaxs(as.matrix(pts))
apply(pts,1, function(x){sqrt(sum((x-cent)^2))}) # test should be approx. equal to radius


### Using box
## p = 2
range &lt;- matrix(c(1,100, 50,100), ncol = 2, byrow = TRUE )
pts &lt;- genSample(2, 1000, range = range, box = TRUE, argsBox = list(cor = "idxAlt"))
head(pts)
Rfast::colMinsMaxs(as.matrix(pts))
plot(pts)

pts &lt;- genSample(2, 1000, range = range, box = TRUE, argsBox = list(cor = "idxAlt",
                 intervals = 6))
plot(pts)

pts &lt;- genSample(2, 1000, range = range, box = TRUE, argsBox = list(cor = "idxRand"))
plot(pts)
pts &lt;- genSample(2, 1000, range = range, box = TRUE,
                 argsBox = list(cor = "idxRand", prHigh = c(0.1,0.6)))
points(pts, pch = 3, col = "red")
pts &lt;- genSample(2, 1000, range = range, box = TRUE,
                 argsBox = list(cor = "idxRand", prHigh = c(0,0)))
points(pts, pch = 4, col = "blue")

pts &lt;- genSample(2, 1000, range = range, box = TRUE, argsBox = list(cor = "idxSplit"))
plot(pts)


## p = 3
range &lt;- matrix(c(1,100, 1,200, 1,50), ncol = 2, byrow = TRUE )
ini3D(argsPlot3d = list(box = TRUE, axes = TRUE))
pts &lt;- genSample(3, 1000, range = range, box = TRUE, , argsBox = list(cor = "idxAlt"))
head(pts)
Rfast::colMinsMaxs(as.matrix(pts))
plotPoints3D(pts)
finalize3D()

ini3D(argsPlot3d = list(box = TRUE, axes = TRUE))
pts &lt;- genSample(3, 1000, range = range, box = TRUE, ,
                 argsBox = list(cor = "idxAlt", intervals = 6))
plotPoints3D(pts)
finalize3D()

ini3D(argsPlot3d = list(box = TRUE, axes = TRUE))
pts &lt;- genSample(3, 1000, range = range, box = TRUE, , argsBox = list(cor = "idxRand"))
plotPoints3D(pts)
pts &lt;- genSample(3, 1000, range = range, box = TRUE, ,
                 argsBox = list(cor = "idxRand", prHigh = c(0.1,0.6,0.1)))
plotPoints3D(pts, argsPlot3d = list(col="red"))
finalize3D()

ini3D(argsPlot3d = list(box = TRUE, axes = TRUE))
pts &lt;- genSample(3, 1000, range = range, box = TRUE, , argsBox = list(cor = "idxSplit"))
plotPoints3D(pts)
finalize3D()


## other p
p &lt;- 10
range &lt;- c(1,100)
pts &lt;- genSample(p, 1000, range = range, box = TRUE, argsBox = list(cor = "idxSplit"))
head(pts)
Rfast::colMinsMaxs(as.matrix(pts))
</code></pre>

<hr>
<h2 id='getTexture'>Save a point symbol as a temporary file.</h2><span id='topic+getTexture'></span>

<h3>Description</h3>

<p>Save a point symbol as a temporary file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTexture(pch = 16, cex = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTexture_+3A_pch">pch</code></td>
<td>
<p>Point number/symbol.</p>
</td></tr>
<tr><td><code id="getTexture_+3A_cex">cex</code></td>
<td>
<p>Point size</p>
</td></tr>
<tr><td><code id="getTexture_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The file name.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Pch shapes
generateRPointShapes&lt;-function(){
   oldPar&lt;-par()
   par(font=2, mar=c(0.5,0,0,0))
   y=rev(c(rep(1,6),rep(2,5), rep(3,5), rep(4,5), rep(5,5)))
   x=c(rep(1:5,5),6)
   plot(x, y, pch = 0:25, cex=1.5, ylim=c(1,5.5), xlim=c(1,6.5),
        axes=FALSE, xlab="", ylab="", bg="blue")
   text(x, y, labels=0:25, pos=3)
   par(mar=oldPar$mar,font=oldPar$font )
}
generateRPointShapes()

getTexture()

</code></pre>

<hr>
<h2 id='gMOIPTheme'>The <code>ggplot</code> theme for the package</h2><span id='topic+gMOIPTheme'></span>

<h3>Description</h3>

<p>The <code>ggplot</code> theme for the package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gMOIPTheme(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gMOIPTheme_+3A_...">...</code></td>
<td>
<p>Further arguments parsed to <code><a href="ggplot2.html#topic+theme">ggplot2::theme()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The theme object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pts &lt;- matrix(c(1,1), ncol = 2, byrow = TRUE)
plotHull2D(pts)
pts1 &lt;- matrix(c(2,2, 3,3), ncol = 2, byrow = TRUE)
pts2 &lt;- matrix(c(1,1, 2,2, 0,1), ncol = 2, byrow = TRUE)
ggplot2::ggplot() +
  plotHull2D(pts2, drawPoints = TRUE, addText = "coord", drawPlot = FALSE) +
  plotHull2D(pts1, drawPoints = TRUE, drawPlot = FALSE) +
  gMOIPTheme() +
  ggplot2::xlab(expression(x[1])) +
  ggplot2::ylab(expression(x[2]))
</code></pre>

<hr>
<h2 id='hullSegment'>Find segments (lines) of a face.</h2><span id='topic+hullSegment'></span>

<h3>Description</h3>

<p>Find segments (lines) of a face.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hullSegment(
  vertices,
  hull = geometry::convhulln(vertices),
  tol = mean(mean(abs(vertices))) * sqrt(.Machine$double.eps)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hullSegment_+3A_vertices">vertices</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;m x p&#8288;</code> array of vertices of the convex hull, as used by
<code><a href="geometry.html#topic+convhulln">geometry::convhulln()</a></code>.</p>
</td></tr>
<tr><td><code id="hullSegment_+3A_hull">hull</code></td>
<td>
<p>Tessellation (or triangulation) generated by <code><a href="geometry.html#topic+convhulln">geometry::convhulln()</a></code> If hull is
left empty or not supplied, then it will be generated.</p>
</td></tr>
<tr><td><code id="hullSegment_+3A_tol">tol</code></td>
<td>
<p>Tolerance on the tests for inclusion in the convex hull. You can
think of <code>tol</code> as the distance a point may possibly lie outside the hull, and
still be perceived as on the surface of the hull. Because of numerical slop
nothing can ever be done exactly here. I might guess a semi-intelligent
value of <code>tol</code> to be
</p>
<p><code style="white-space: pre;">&#8288;tol = 1.e-13*mean(abs(vertices(:)))&#8288;</code>
</p>
<p>In higher dimensions, the numerical issues of floating point arithmetic
will probably suggest a larger value of <code>tol</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with segments.
</p>


<h3>Author(s)</h3>

<p>Lars Relund <a href="mailto:lars@relund.dk">lars@relund.dk</a>
</p>

<hr>
<h2 id='inHull'>Efficient test for points inside a convex hull in p dimensions.</h2><span id='topic+inHull'></span>

<h3>Description</h3>

<p>Efficient test for points inside a convex hull in p dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inHull(
  pts,
  vertices,
  hull = NULL,
  tol = mean(mean(abs(as.matrix(vertices)))) * sqrt(.Machine$double.eps)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inHull_+3A_pts">pts</code></td>
<td>
<p>A <code class="reqn">nxp</code> array to test, <code class="reqn">n</code> data points, in dimension <code class="reqn">p</code>. If you have
many points to test, it is most efficient to call this function once with the entire set.</p>
</td></tr>
<tr><td><code id="inHull_+3A_vertices">vertices</code></td>
<td>
<p>A <code class="reqn">mxp</code> array of vertices of the convex hull. May contain redundant
(non-vertex) points.</p>
</td></tr>
<tr><td><code id="inHull_+3A_hull">hull</code></td>
<td>
<p>Tessellation (or triangulation) generated by <code>convhulln</code> (only works if the dimension
of the hull is <code class="reqn">p</code>). If hull is <code>NULL</code>, then it will be generated.</p>
</td></tr>
<tr><td><code id="inHull_+3A_tol">tol</code></td>
<td>
<p>Tolerance on the tests for inclusion in the convex hull. You can think of <code>tol</code> as the
difference a point value may be different from the values of the hull, and still be perceived
as on the surface of the hull. Because of numerical slop nothing can ever be done exactly here.
In higher dimensions, the numerical issues of floating point arithmetic will probably suggest a
larger value of <code>tol</code>. <code>tol</code> is not used if the dimension of the hull is larger than one and
not equal <code class="reqn">p</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector of length <code class="reqn">n</code> with values 1 (inside hull), -1 (outside hull) or 0
(on hull to precision indicated by <code>tol</code>).
</p>


<h3>Note</h3>

<p>Some of the code are inspired by the <a href="https://www.mathworks.com/matlabcentral/fileexchange/10226-inhull">Matlab code</a> by
John D'Errico and
<a href="https://stat.ethz.ch/pipermail/r-help/2009-December/415377.html">how to find a point inside a hull</a>.
If the dimension of the hull is below <code class="reqn">p</code> then PCA may be used to check (a
warning will be given).
</p>


<h3>Author(s)</h3>

<p>Lars Relund <a href="mailto:lars@relund.dk">lars@relund.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## In 1D
vertices &lt;- matrix(4, ncol = 1)
pt &lt;- matrix(c(2,4), ncol = 1, byrow = TRUE)
inHull(pt, vertices)
vertices &lt;- matrix(c(1,4), ncol = 1)
pt &lt;- matrix(c(1,3,4,5), ncol = 1, byrow = TRUE)
inHull(pt, vertices)

## In 2D
vertices &lt;- matrix(c(2,4), ncol = 2)
pt &lt;- matrix(c(2,4, 1,1), ncol = 2, byrow = TRUE)
inHull(pt, vertices)
vertices &lt;- matrix(c(0,0, 3,3), ncol = 2, byrow = TRUE)
pt &lt;- matrix(c(0,0, 1,1, 2,2, 3,3, 4,4), ncol = 2, byrow = TRUE)
inHull(pt, vertices)
vertices &lt;- matrix(c(0,0, 0,3, 3,0), ncol = 2, byrow = TRUE)
pt &lt;- matrix(c(0,0, 1,1, 4,4), ncol = 2, byrow = TRUE)
inHull(pt, vertices)


## in 3D
vertices &lt;- matrix(c(2,2,2), ncol = 3, byrow = TRUE)
pt &lt;- matrix(c(1,1,1, 3,3,3, 2,2,2, 3,3,2), ncol = 3, byrow = TRUE)
inHull(pt, vertices)

vertices &lt;- matrix(c(2,2,2, 4,4,4), ncol = 3, byrow = TRUE)
ini3D()
plotHull3D(vertices)
pt &lt;- matrix(c(1,1,1, 2,2,2, 3,3,3, 4,4,4, 3,3,2), ncol = 3, byrow = TRUE)
plotPoints3D(pt, addText = TRUE)
finalize3D()
inHull(pt, vertices)

vertices &lt;- matrix(c(1,0,0, 1,1,0, 1,0,1), ncol = 3, byrow = TRUE)
ini3D()
plotHull3D(vertices)
pt &lt;- matrix(c(1,0.1,0.2, 3,3,2), ncol = 3, byrow = TRUE)
plotPoints3D(pt, addText = TRUE)
finalize3D()
inHull(pt, vertices)

vertices &lt;- matrix(c(2,2,2, 2,4,4, 2,2,4, 4,4,2, 4,2,2, 2,4,2, 4,2,4, 4,4,4), ncol = 3,
            byrow = TRUE)
ini3D()
plotHull3D(vertices)
pt &lt;- matrix(c(1,1,1, 3,3,3, 2,2,2, 3,3,2), ncol = 3, byrow = TRUE)
plotPoints3D(pt, addText = TRUE)
finalize3D()
inHull(pt, vertices)


## In 5D
vertices &lt;- matrix(c(4,0,0,0,0, 0,4,0,0,0, 0,0,4,0,0, 0,0,0,4,0, 0,0,0,0,4, 0,0,0,0,0),
            ncol = 5, byrow = TRUE)
pt &lt;- matrix(c(0.1,0.1,0.1,0.1,0.1, 3,3,3,3,3, 2,0,0,0,0), ncol = 5, byrow = TRUE)
inHull(pt, vertices)
</code></pre>

<hr>
<h2 id='ini3D'>Initialize the RGL window.</h2><span id='topic+ini3D'></span>

<h3>Description</h3>

<p>Initialize the RGL window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ini3D(new = TRUE, clear = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ini3D_+3A_new">new</code></td>
<td>
<p>A new window is opened (otherwise the current is cleared).</p>
</td></tr>
<tr><td><code id="ini3D_+3A_clear">clear</code></td>
<td>
<p>Clear the current RGL window.</p>
</td></tr>
<tr><td><code id="ini3D_+3A_...">...</code></td>
<td>
<p>Further arguments passed on the the RGL plotting functions. This must be done as
lists. Currently the following arguments are supported:
</p>

<ul>
<li> <p><code>argsPlot3d</code>: A list of arguments for <code><a href="rgl.html#topic+plot3d">rgl::plot3d</a></code>.
</p>
</li>
<li> <p><code>argsAspect3d</code>: A list of arguments for <code><a href="rgl.html#topic+aspect3d">rgl::aspect3d</a></code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL (invisible).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ini3D()
pts&lt;-matrix(c(1,1,1,5,5,5), ncol = 3, byrow = TRUE)
plotPoints3D(pts)
finalize3D()

lim &lt;- c(-1, 7)
ini3D(argsPlot3d = list(xlim = lim, ylim = lim, zlim = lim))
plotPoints3D(pts)
finalize3D()

</code></pre>

<hr>
<h2 id='integerPoints'>Integer points in the feasible region (Ax&lt;=b).</h2><span id='topic+integerPoints'></span>

<h3>Description</h3>

<p>Integer points in the feasible region (Ax&lt;=b).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integerPoints(A, b, nonneg = rep(TRUE, ncol(A)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integerPoints_+3A_a">A</code></td>
<td>
<p>Constraint matrix.</p>
</td></tr>
<tr><td><code id="integerPoints_+3A_b">b</code></td>
<td>
<p>Right hand side.</p>
</td></tr>
<tr><td><code id="integerPoints_+3A_nonneg">nonneg</code></td>
<td>
<p>A boolean vector of same length as number of variables. If
entry k is TRUE then variable k must be non-negative.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with all integer points inside the feasible region.
</p>


<h3>Note</h3>

<p>Do a simple enumeration of all integer points between min and max values found using the continuous polytope.
</p>


<h3>Author(s)</h3>

<p>Lars Relund <a href="mailto:lars@relund.dk">lars@relund.dk</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix( c(3,-2, 1, 2, 4,-2,-3, 2, 1), nc = 3, byrow = TRUE)
b &lt;- c(10, 12, 3)
integerPoints(A, b)

A &lt;- matrix(c(9, 10, 2, 4, -3, 2), ncol = 2, byrow = TRUE)
b &lt;- c(90, 27, 3)
integerPoints(A, b)
</code></pre>

<hr>
<h2 id='loadView'>Help function to load the view angle for the RGL 3D plot from a file or matrix</h2><span id='topic+loadView'></span>

<h3>Description</h3>

<p>Help function to load the view angle for the RGL 3D plot from a file or matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadView(
  fname = "view.RData",
  v = NULL,
  clear = TRUE,
  close = FALSE,
  zoom = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadView_+3A_fname">fname</code></td>
<td>
<p>The file name of the view.</p>
</td></tr>
<tr><td><code id="loadView_+3A_v">v</code></td>
<td>
<p>The view matrix.</p>
</td></tr>
<tr><td><code id="loadView_+3A_clear">clear</code></td>
<td>
<p>Call <code><a href="rgl.html#topic+scene">rgl::clear3d()</a></code>.</p>
</td></tr>
<tr><td><code id="loadView_+3A_close">close</code></td>
<td>
<p>Call <code><a href="rgl.html#topic+open3d">rgl::close3d()</a></code>.</p>
</td></tr>
<tr><td><code id="loadView_+3A_zoom">zoom</code></td>
<td>
<p>Zoom level.</p>
</td></tr>
<tr><td><code id="loadView_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code><a href="rgl.html#topic+viewpoint">rgl::view3d()</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lars Relund <a href="mailto:lars@relund.dk">lars@relund.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
view &lt;- matrix( c(-0.412063330411911, -0.228006735444069, 0.882166087627411, 0,
0.910147845745087, -0.0574885793030262, 0.410274744033813, 0, -0.042830865830183,
0.97196090221405, 0.231208890676498, 0, 0, 0, 0, 1), nc = 4)

loadView(v = view)
A &lt;- matrix( c(3, 2, 5, 2, 1, 1, 1, 1, 3, 5, 2, 4), nc = 3, byrow = TRUE)
b &lt;- c(55, 26, 30, 57)
obj &lt;- c(20, 10, 15)
plotPolytope(A, b, plotOptimum = TRUE, obj = obj, labels = "coord")

# Try to modify the angle in the RGL window
saveView(print = TRUE)  # get the view angle to insert into R code

</code></pre>

<hr>
<h2 id='mergeLists'>Merge two lists to one</h2><span id='topic+mergeLists'></span>

<h3>Description</h3>

<p>Merge two lists to one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeLists(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeLists_+3A_a">a</code></td>
<td>
<p>First list.</p>
</td></tr>
<tr><td><code id="mergeLists_+3A_b">b</code></td>
<td>
<p>Second list.</p>
</td></tr>
</table>

<hr>
<h2 id='plotCones2D'>Plot a cone defined by a point in 2D.</h2><span id='topic+plotCones2D'></span>

<h3>Description</h3>

<p>The cones are defined as the point plus/minus rays of R2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCones2D(
  pts,
  drawPoint = TRUE,
  drawLines = TRUE,
  drawPolygons = TRUE,
  direction = 1,
  rectangle = FALSE,
  drawPlot = TRUE,
  m = apply(pts, 2, min) - 5,
  M = apply(pts, 2, max) + 5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCones2D_+3A_pts">pts</code></td>
<td>
<p>A matrix with a point in each row.</p>
</td></tr>
<tr><td><code id="plotCones2D_+3A_drawpoint">drawPoint</code></td>
<td>
<p>Draw the points defining the cone.</p>
</td></tr>
<tr><td><code id="plotCones2D_+3A_drawlines">drawLines</code></td>
<td>
<p>Draw lines of the cone.</p>
</td></tr>
<tr><td><code id="plotCones2D_+3A_drawpolygons">drawPolygons</code></td>
<td>
<p>Draw polygons of the cone.</p>
</td></tr>
<tr><td><code id="plotCones2D_+3A_direction">direction</code></td>
<td>
<p>Ray direction. If i'th entry is positive, consider the i'th column of <code>pts</code>
plus a value greater than on equal zero (minimize objective $i$). If negative, consider the
i'th column of <code>pts</code> minus a value greater than on equal zero (maximize objective $i$).</p>
</td></tr>
<tr><td><code id="plotCones2D_+3A_rectangle">rectangle</code></td>
<td>
<p>Draw the cone as a rectangle.</p>
</td></tr>
<tr><td><code id="plotCones2D_+3A_drawplot">drawPlot</code></td>
<td>
<p>Draw the <code>ggplot</code>. Set to FALSE if you want to combine hulls in a single plot.</p>
</td></tr>
<tr><td><code id="plotCones2D_+3A_m">m</code></td>
<td>
<p>Minimum values of the bounding box.</p>
</td></tr>
<tr><td><code id="plotCones2D_+3A_m">M</code></td>
<td>
<p>Maximum values of the bounding box.</p>
</td></tr>
<tr><td><code id="plotCones2D_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <a href="#topic+plotHull2D">plotHull2D</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
plotCones2D(c(4,4), drawLines = FALSE, drawPoint = TRUE,
           argsGeom_point = list(col = "red", size = 10),
           argsGeom_polygon = list(alpha = 0.5), rectangle = TRUE)
plotCones2D(c(1,1), rectangle = FALSE)
plotCones2D(matrix(c(3,3,2,2), ncol = 2, byrow = TRUE))

## The Danish flag
lst &lt;- list(argsGeom_polygon = list(alpha = 0.85, fill = "red"),
            drawPlot = FALSE, drawPoint = FALSE, drawLines = FALSE)
p1 &lt;- do.call(plotCones2D, args = c(list(c(2,4), direction = 1), lst))
p2 &lt;- do.call(plotCones2D, args = c(list(c(1,2), direction = -1), lst))
p3 &lt;- do.call(plotCones2D, args = c(list(c(2,2), direction = c(1,-1)), lst))
p4 &lt;- do.call(plotCones2D, args = c(list(c(1,4), direction = c(-1,1)), lst))
ggplot() + p1 + p2 + p3 + p4 + theme_void()
</code></pre>

<hr>
<h2 id='plotCones3D'>Plot a cone defined by a point in 3D.</h2><span id='topic+plotCones3D'></span>

<h3>Description</h3>

<p>The cones are defined as the point plus R3+.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCones3D(
  pts,
  drawPoint = TRUE,
  drawLines = TRUE,
  drawPolygons = TRUE,
  direction = 1,
  rectangle = FALSE,
  useRGLBBox = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCones3D_+3A_pts">pts</code></td>
<td>
<p>A matrix with a point in each row.</p>
</td></tr>
<tr><td><code id="plotCones3D_+3A_drawpoint">drawPoint</code></td>
<td>
<p>Draw the points defining the cone.</p>
</td></tr>
<tr><td><code id="plotCones3D_+3A_drawlines">drawLines</code></td>
<td>
<p>Draw lines of the cone.</p>
</td></tr>
<tr><td><code id="plotCones3D_+3A_drawpolygons">drawPolygons</code></td>
<td>
<p>Draw polygons of the cone.</p>
</td></tr>
<tr><td><code id="plotCones3D_+3A_direction">direction</code></td>
<td>
<p>Ray direction. If i'th entry is positive, consider the i'th column of <code>pts</code>
plus a value greater than on equal zero (minimize objective $i$). If negative, consider the
i'th column of <code>pts</code> minus a value greater than on equal zero (maximize objective $i$).</p>
</td></tr>
<tr><td><code id="plotCones3D_+3A_rectangle">rectangle</code></td>
<td>
<p>Draw the cone as a rectangle.</p>
</td></tr>
<tr><td><code id="plotCones3D_+3A_userglbbox">useRGLBBox</code></td>
<td>
<p>Use the RGL bounding box as ray limits for the cone.</p>
</td></tr>
<tr><td><code id="plotCones3D_+3A_...">...</code></td>
<td>
<p>Further arguments passed on the the RGL plotting functions. This must be done as
lists (see examples). Currently the following arguments are supported:
</p>

<ul>
<li> <p><code>argsPlot3d</code>: A list of arguments for <code><a href="rgl.html#topic+plot3d">rgl::plot3d</a></code>.
</p>
</li>
<li> <p><code>argsSegments3d</code>: A list of arguments for <code><a href="rgl.html#topic+primitives">rgl::segments3d</a></code>.
</p>
</li>
<li> <p><code>argsPolygon3d</code>: A list of arguments for <code><a href="rgl.html#topic+polygon3d">rgl::polygon3d</a></code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Object ids (invisible).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ini3D(argsPlot3d = list(xlim = c(0,6), ylim = c(0,6), zlim = c(0,6)))
plotCones3D(c(4,4,4), drawLines = FALSE, drawPoint = TRUE,
           argsPlot3d = list(col = "red", size = 10),
           argsPolygon3d = list(alpha = 1), rectangle = TRUE)
plotCones3D(c(1,1,1), rectangle = FALSE)
plotCones3D(matrix(c(3,3,3,2,2,2), ncol = 3, byrow = TRUE))
finalize3D()

ini3D(argsPlot3d = list(xlim = c(0,6), ylim = c(0,6), zlim = c(0,6)))
plotCones3D(c(4,4,4), direction = 1)
plotCones3D(c(2,2,2), direction = -1)
plotCones3D(c(4,2,2), direction = c(1,-1,-1))
ids &lt;- plotCones3D(c(2,2,4), direction = c(-1,-1,1))
finalize3D()
# pop3d(id = ids) # remove last cone

</code></pre>

<hr>
<h2 id='plotCriterion2D'>Create a plot of the criterion space of a bi-objective problem</h2><span id='topic+plotCriterion2D'></span>

<h3>Description</h3>

<p>Create a plot of the criterion space of a bi-objective problem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCriterion2D(
  A,
  b,
  obj,
  type = rep("c", ncol(A)),
  nonneg = rep(TRUE, ncol(A)),
  crit = "max",
  addTriangles = FALSE,
  addHull = TRUE,
  plotFeasible = TRUE,
  latex = FALSE,
  labels = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCriterion2D_+3A_a">A</code></td>
<td>
<p>The constraint matrix.</p>
</td></tr>
<tr><td><code id="plotCriterion2D_+3A_b">b</code></td>
<td>
<p>Right hand side.</p>
</td></tr>
<tr><td><code id="plotCriterion2D_+3A_obj">obj</code></td>
<td>
<p>A p x n matrix(one row for each criterion).</p>
</td></tr>
<tr><td><code id="plotCriterion2D_+3A_type">type</code></td>
<td>
<p>A character vector of same length as number of variables. If
entry k is 'i' variable <code class="reqn">k</code> must be integer and if 'c' continuous.</p>
</td></tr>
<tr><td><code id="plotCriterion2D_+3A_nonneg">nonneg</code></td>
<td>
<p>A boolean vector of same length as number of variables. If
entry k is TRUE then variable k must be non-negative.</p>
</td></tr>
<tr><td><code id="plotCriterion2D_+3A_crit">crit</code></td>
<td>
<p>Either max or min (only used if add the iso-profit line).</p>
</td></tr>
<tr><td><code id="plotCriterion2D_+3A_addtriangles">addTriangles</code></td>
<td>
<p>Add search triangles defined by the non-dominated extreme
points.</p>
</td></tr>
<tr><td><code id="plotCriterion2D_+3A_addhull">addHull</code></td>
<td>
<p>Add the convex hull and the rays.</p>
</td></tr>
<tr><td><code id="plotCriterion2D_+3A_plotfeasible">plotFeasible</code></td>
<td>
<p>If <code>True</code> then plot the criterion points/slices.</p>
</td></tr>
<tr><td><code id="plotCriterion2D_+3A_latex">latex</code></td>
<td>
<p>If true make latex math labels for TikZ.</p>
</td></tr>
<tr><td><code id="plotCriterion2D_+3A_labels">labels</code></td>
<td>
<p>If <code>NULL</code> don't add any labels. If 'n' no labels but show the points. If equal
<code>coord</code> add coordinates to the points. Otherwise number all points from one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>ggplot</code> object.
</p>


<h3>Note</h3>

<p>Currently only points are checked for dominance. That is, for MILP
models some nondominated points may in fact be dominated by a segment.
</p>


<h3>Author(s)</h3>

<p>Lars Relund <a href="mailto:lars@relund.dk">lars@relund.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Set up 2D plot
# Function for plotting the solution and criterion space in one plot (two variables)
plotBiObj2D &lt;- function(A, b, obj,
   type = rep("c", ncol(A)),
   crit = "max",
   faces = rep("c", ncol(A)),
   plotFaces = TRUE,
   plotFeasible = TRUE,
   plotOptimum = FALSE,
   labels = "numb",
   addTriangles = TRUE,
   addHull = TRUE)
{
   p1 &lt;- plotPolytope(A, b, type = type, crit = crit, faces = faces, plotFaces = plotFaces,
                      plotFeasible = plotFeasible, plotOptimum = plotOptimum, labels = labels)
   p2 &lt;- plotCriterion2D(A, b, obj, type = type, crit = crit, addTriangles = addTriangles,
                         addHull = addHull, plotFeasible = plotFeasible, labels = labels)
   gridExtra::grid.arrange(p1, p2, nrow = 1)
}


### Bi-objective problem with two variables
A &lt;- matrix(c(-3,2,2,4,9,10), ncol = 2, byrow = TRUE)
b &lt;- c(3,27,90)

## LP model
obj &lt;- matrix(
   c(7, -10, # first criterion
     -10, -10), # second criterion
   nrow = 2)
plotBiObj2D(A, b, obj, addTriangles = FALSE)


## ILP models with different criteria (maximize)
obj &lt;- matrix(c(7, -10, -10, -10), nrow = 2)
plotBiObj2D(A, b, obj, type = rep("i", ncol(A)))
obj &lt;- matrix(c(3, -1, -2, 2), nrow = 2)
plotBiObj2D(A, b, obj, type = rep("i", ncol(A)))
obj &lt;- matrix(c(-7, -1, -5, 5), nrow = 2)
plotBiObj2D(A, b, obj, type = rep("i", ncol(A)))
obj &lt;- matrix(c(-1, -1, 2, 2), nrow = 2)
plotBiObj2D(A, b, obj, type = rep("i", ncol(A)))

## ILP models with different criteria (minimize)
obj &lt;- matrix(c(7, -10, -10, -10), nrow = 2)
plotBiObj2D(A, b, obj, type = rep("i", ncol(A)), crit = "min")
obj &lt;- matrix(c(3, -1, -2, 2), nrow = 2)
plotBiObj2D(A, b, obj, type = rep("i", ncol(A)), crit = "min")
obj &lt;- matrix(c(-7, -1, -5, 5), nrow = 2)
plotBiObj2D(A, b, obj, type = rep("i", ncol(A)), crit = "min")
obj &lt;- matrix(c(-1, -1, 2, 2), nrow = 2)
plotBiObj2D(A, b, obj, type = rep("i", ncol(A)), crit = "min")


# More examples
## MILP model (x1 integer) with different criteria (maximize)
obj &lt;- matrix(c(7, -10, -10, -10), nrow = 2)
plotBiObj2D(A, b, obj, type = c("i", "c"))
obj &lt;- matrix(c(3, -1, -2, 2), nrow = 2)
plotBiObj2D(A, b, obj, type = c("i", "c"))
obj &lt;- matrix(c(-7, -1, -5, 5), nrow = 2)
plotBiObj2D(A, b, obj, type = c("i", "c"))
obj &lt;- matrix(c(-1, -1, 2, 2), nrow = 2)
plotBiObj2D(A, b, obj, type = c("i", "c"))

## MILP model (x2 integer) with different criteria (minimize)
obj &lt;- matrix(c(7, -10, -10, -10), nrow = 2)
plotBiObj2D(A, b, obj, type = c("c", "i"), crit = "min")
obj &lt;- matrix(c(3, -1, -2, 2), nrow = 2)
plotBiObj2D(A, b, obj, type = c("c", "i"), crit = "min")
obj &lt;- matrix(c(-7, -1, -5, 5), nrow = 2)
plotBiObj2D(A, b, obj, type = c("c", "i"), crit = "min")
obj &lt;- matrix(c(-1, -1, 2, 2), nrow = 2)
plotBiObj2D(A, b, obj, type = c("c", "i"), crit = "min")


### Set up 3D plot

# Function for plotting the solution and criterion space in one plot (three variables)
plotBiObj3D &lt;- function(A, b, obj,
                        type = rep("c", ncol(A)),
                        crit = "max",
                        faces = rep("c", ncol(A)),
                        plotFaces = TRUE,
                        plotFeasible = TRUE,
                        plotOptimum = FALSE,
                        labels = "numb",
                        addTriangles = TRUE,
                        addHull = TRUE)
{
   plotPolytope(A, b, type = type, crit = crit, faces = faces, plotFaces = plotFaces,
                plotFeasible = plotFeasible, plotOptimum = plotOptimum, labels = labels)
   plotCriterion2D(A, b, obj, type = type, crit = crit, addTriangles = addTriangles,
                   addHull = addHull, plotFeasible = plotFeasible, labels = labels)
}

### Bi-objective problem with three variables
loadView &lt;- function(fname = "view.RData", v = NULL) {
   if (!is.null(v)) {
      rgl::view3d(userMatrix = v)
   } else {
      if (file.exists(fname)) {
         load(fname)
         rgl::view3d(userMatrix = view)
      } else {
         warning(paste0("Can'TRUE load view in file ", fname, "!"))
      }
   }
}

## Ex
view &lt;- matrix( c(-0.452365815639496, -0.446501553058624, 0.77201122045517, 0, 0.886364221572876,
                  -0.320795893669128, 0.333835482597351, 0, 0.0986008867621422, 0.835299551486969,
                  0.540881276130676, 0, 0, 0, 0, 1), nc = 4)
loadView(v = view)
Ab &lt;- matrix( c(
   1, 1, 2, 5,
   2, -1, 0, 3,
   -1, 2, 1, 3,
   0, -3, 5, 2
), nc = 4, byrow = TRUE)
A &lt;- Ab[,1:3]
b &lt;- Ab[,4]
obj &lt;- matrix(c(1, -6, 3, -4, 1, 6), nrow = 2)

# LP model
plotBiObj3D(A, b, obj, crit = "min", addTriangles = FALSE)

# ILP model
plotBiObj3D(A, b, obj, type = c("i","i","i"), crit = "min")

# MILP model
plotBiObj3D(A, b, obj, type = c("c","i","i"), crit = "min")
plotBiObj3D(A, b, obj, type = c("i","c","i"), crit = "min")
plotBiObj3D(A, b, obj, type = c("i","i","c"), crit = "min")
plotBiObj3D(A, b, obj, type = c("i","c","c"), crit = "min")
plotBiObj3D(A, b, obj, type = c("c","i","c"), crit = "min")
plotBiObj3D(A, b, obj, type = c("c","c","i"), crit = "min")


## Ex
view &lt;- matrix( c(0.976349174976349, -0.202332556247711, 0.0761845782399178, 0, 0.0903248339891434,
                  0.701892614364624, 0.706531345844269, 0, -0.196427255868912, -0.682940244674683,
                  0.703568696975708, 0, 0, 0, 0, 1), nc = 4)
loadView(v = view)
A &lt;- matrix( c(
   -1, 1, 0,
   1, 4, 0,
   2, 1, 0,
   3, -4, 0,
   0, 0, 4
), nc = 3, byrow = TRUE)
b &lt;- c(5, 45, 27, 24, 10)
obj &lt;- matrix(c(1, -6, 3, -4, 1, 6), nrow = 2)

# LP model
plotBiObj3D(A, b, obj, crit = "min", addTriangles = FALSE, labels = "coord")

# ILP model
plotBiObj3D(A, b, obj, type = c("i","i","i"))

# MILP model
plotBiObj3D(A, b, obj, type = c("c","i","i"))
plotBiObj3D(A, b, obj, type = c("i","c","i"), plotFaces = FALSE)
plotBiObj3D(A, b, obj, type = c("i","i","c"))
plotBiObj3D(A, b, obj, type = c("i","c","c"), plotFaces = FALSE)
plotBiObj3D(A, b, obj, type = c("c","i","c"), plotFaces = FALSE)
plotBiObj3D(A, b, obj, type = c("c","c","i"))


## Ex
view &lt;- matrix( c(-0.812462985515594, -0.029454167932272, 0.582268416881561, 0, 0.579295456409454,
                  -0.153386667370796, 0.800555109977722, 0, 0.0657325685024261, 0.987727105617523,
                  0.14168381690979, 0, 0, 0, 0, 1), nc = 4)
loadView(v = view)
A &lt;- matrix( c(
   1, 1, 1,
   3, 0, 1
), nc = 3, byrow = TRUE)
b &lt;- c(10, 24)
obj &lt;- matrix(c(1, -6, 3, -4, 1, 6), nrow = 2)

# LP model
plotBiObj3D(A, b, obj, crit = "min", addTriangles = FALSE, labels = "coord")

# ILP model
plotBiObj3D(A, b, obj, type = c("i","i","i"), crit = "min", labels = "n")

# MILP model
plotBiObj3D(A, b, obj, type = c("c","i","i"), crit = "min")
plotBiObj3D(A, b, obj, type = c("i","c","i"), crit = "min")
plotBiObj3D(A, b, obj, type = c("i","i","c"), crit = "min")
plotBiObj3D(A, b, obj, type = c("i","c","c"), crit = "min")
plotBiObj3D(A, b, obj, type = c("c","i","c"), crit = "min", plotFaces = FALSE)
plotBiObj3D(A, b, obj, type = c("c","c","i"), crit = "min", plotFaces = FALSE)


## Ex
view &lt;- matrix( c(-0.412063330411911, -0.228006735444069, 0.882166087627411, 0, 0.910147845745087,
                  -0.0574885793030262, 0.410274744033813, 0, -0.042830865830183, 0.97196090221405,
                  0.231208890676498, 0, 0, 0, 0, 1), nc = 4)
loadView(v = view)
A &lt;- matrix( c(
3, 2, 5,
2, 1, 1,
1, 1, 3,
5, 2, 4
), nc = 3, byrow = TRUE)
b &lt;- c(55, 26, 30, 57)
obj &lt;- matrix(c(1, -6, 3, -4, 1, -1), nrow = 2)

# LP model
plotBiObj3D(A, b, obj, crit = "min", addTriangles = FALSE, labels = "coord")

# ILP model
plotBiObj3D(A, b, obj, type = c("i","i","i"), crit = "min", labels = "n")

# MILP model
plotBiObj3D(A, b, obj, type = c("c","i","i"), crit = "min", labels = "n")
plotBiObj3D(A, b, obj, type = c("i","c","i"), crit = "min", labels = "n", plotFaces = FALSE)
plotBiObj3D(A, b, obj, type = c("i","i","c"), crit = "min", labels = "n")
plotBiObj3D(A, b, obj, type = c("i","c","c"), crit = "min", labels = "n")
plotBiObj3D(A, b, obj, type = c("c","i","c"), crit = "min", labels = "n", plotFaces = FALSE)
plotBiObj3D(A, b, obj, type = c("c","c","i"), crit = "min", labels = "n")

</code></pre>

<hr>
<h2 id='plotHull2D'>Plot the convex hull of a set of points in 2D.</h2><span id='topic+plotHull2D'></span>

<h3>Description</h3>

<p>Plot the convex hull of a set of points in 2D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHull2D(
  pts,
  drawPoints = FALSE,
  drawLines = TRUE,
  drawPolygons = TRUE,
  addText = FALSE,
  addRays = FALSE,
  direction = 1,
  drawPlot = TRUE,
  drawBBoxHull = FALSE,
  m = apply(pts, 2, min) - 5,
  M = apply(pts, 2, max) + 5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotHull2D_+3A_pts">pts</code></td>
<td>
<p>A matrix with a point in each row.</p>
</td></tr>
<tr><td><code id="plotHull2D_+3A_drawpoints">drawPoints</code></td>
<td>
<p>Draw the points.</p>
</td></tr>
<tr><td><code id="plotHull2D_+3A_drawlines">drawLines</code></td>
<td>
<p>Draw lines of the facets.</p>
</td></tr>
<tr><td><code id="plotHull2D_+3A_drawpolygons">drawPolygons</code></td>
<td>
<p>Fill the hull.</p>
</td></tr>
<tr><td><code id="plotHull2D_+3A_addtext">addText</code></td>
<td>
<p>Add text to the points. Currently <code>coord</code> (coordinates), <code>rownames</code> (rownames)
and <code>both</code> supported or a vector with text.</p>
</td></tr>
<tr><td><code id="plotHull2D_+3A_addrays">addRays</code></td>
<td>
<p>Add the ray defined by <code>direction</code>.</p>
</td></tr>
<tr><td><code id="plotHull2D_+3A_direction">direction</code></td>
<td>
<p>Ray direction. If i'th entry is positive, consider the i'th column of <code>pts</code>
plus a value greater than on equal zero (minimize objective $i$). If negative, consider the
i'th column of <code>pts</code> minus a value greater than on equal zero (maximize objective $i$).</p>
</td></tr>
<tr><td><code id="plotHull2D_+3A_drawplot">drawPlot</code></td>
<td>
<p>Draw the <code>ggplot</code>. Set to FALSE if you want to combine hulls in a single plot.</p>
</td></tr>
<tr><td><code id="plotHull2D_+3A_drawbboxhull">drawBBoxHull</code></td>
<td>
<p>If <code>addRays</code> then draw the hull areas hitting the bounding box also.</p>
</td></tr>
<tr><td><code id="plotHull2D_+3A_m">m</code></td>
<td>
<p>Minimum values of the bounding box.</p>
</td></tr>
<tr><td><code id="plotHull2D_+3A_m">M</code></td>
<td>
<p>Maximum values of the bounding box.</p>
</td></tr>
<tr><td><code id="plotHull2D_+3A_...">...</code></td>
<td>
<p>Further arguments passed on the the <code>ggplot</code> plotting functions. This must be done as
lists. Currently the following arguments are supported:
</p>

<ul>
<li> <p><code>argsGeom_point</code>: A list of arguments for <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point</a></code>.
</p>
</li>
<li> <p><code>argsGeom_path</code>: A list of arguments for <code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_path</a></code>.
</p>
</li>
<li> <p><code>argsGeom_polygon</code>: A list of arguments for <code><a href="ggplot2.html#topic+geom_polygon">ggplot2::geom_polygon</a></code>.
</p>
</li>
<li> <p><code>argsGeom_label</code>: A list of arguments for <code><a href="ggplot2.html#topic+geom_text">ggplot2::geom_label</a></code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>ggplot</code> object if <code>drawPlot = TRUE</code>; otherwise, a list of <code>ggplot</code> components.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
pts&lt;-matrix(c(1,1), ncol = 2, byrow = TRUE)
plotHull2D(pts)
pts1&lt;-matrix(c(2,2, 3,3), ncol = 2, byrow = TRUE)
plotHull2D(pts1, drawPoints = TRUE)
plotHull2D(pts1, drawPoints = TRUE, addRays = TRUE, addText = "coord")
plotHull2D(pts1, drawPoints = TRUE, addRays = TRUE, addText = "coord", drawBBoxHull = TRUE)
plotHull2D(pts1, drawPoints = TRUE, addRays = TRUE, direction = -1, addText = "coord")
pts2&lt;-matrix(c(1,1, 2,2, 0,1), ncol = 2, byrow = TRUE)
plotHull2D(pts2, drawPoints = TRUE, addText = "coord")
plotHull2D(pts2, drawPoints = TRUE, addRays = TRUE, addText = "coord")
plotHull2D(pts2, drawPoints = TRUE, addRays = TRUE, direction = -1, addText = "coord")
## Combine hulls
ggplot() +
  plotHull2D(pts2, drawPoints = TRUE, addText = "coord", drawPlot = FALSE) +
  plotHull2D(pts1, drawPoints = TRUE, drawPlot = FALSE) +
  gMOIPTheme() +
  xlab(expression(x[1])) +
  ylab(expression(x[2]))

# Plotting an LP
A &lt;- matrix(c(-3,2,2,4,9,10), ncol = 2, byrow = TRUE)
b &lt;- c(3,27,90)
obj &lt;- c(7.75, 10)
pts3 &lt;- cornerPoints(A, b)
plotHull2D(pts3, drawPoints = TRUE, addText = "coord", argsGeom_polygon = list(fill = "red"))
</code></pre>

<hr>
<h2 id='plotHull3D'>Plot the convex hull of a set of points in 3D.</h2><span id='topic+plotHull3D'></span>

<h3>Description</h3>

<p>Plot the convex hull of a set of points in 3D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHull3D(
  pts,
  drawPoints = FALSE,
  drawLines = TRUE,
  drawPolygons = TRUE,
  addText = FALSE,
  addRays = FALSE,
  useRGLBBox = TRUE,
  direction = 1,
  drawBBoxHull = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotHull3D_+3A_pts">pts</code></td>
<td>
<p>A matrix with a point in each row.</p>
</td></tr>
<tr><td><code id="plotHull3D_+3A_drawpoints">drawPoints</code></td>
<td>
<p>Draw the points.</p>
</td></tr>
<tr><td><code id="plotHull3D_+3A_drawlines">drawLines</code></td>
<td>
<p>Draw lines of the facets.</p>
</td></tr>
<tr><td><code id="plotHull3D_+3A_drawpolygons">drawPolygons</code></td>
<td>
<p>Fill the facets.</p>
</td></tr>
<tr><td><code id="plotHull3D_+3A_addtext">addText</code></td>
<td>
<p>Add text to the points. Currently <code>coord</code> (coordinates), <code>rownames</code> (rownames)
and <code>both</code> supported or a vector with text.</p>
</td></tr>
<tr><td><code id="plotHull3D_+3A_addrays">addRays</code></td>
<td>
<p>Add the ray defined by <code>direction</code>.</p>
</td></tr>
<tr><td><code id="plotHull3D_+3A_userglbbox">useRGLBBox</code></td>
<td>
<p>Use the RGL bounding box when add rays.</p>
</td></tr>
<tr><td><code id="plotHull3D_+3A_direction">direction</code></td>
<td>
<p>Ray direction. If i'th entry is positive, consider the i'th column of <code>pts</code>
plus a value greater than on equal zero (minimize objective $i$). If negative, consider the
i'th column of <code>pts</code> minus a value greater than on equal zero (maximize objective $i$).</p>
</td></tr>
<tr><td><code id="plotHull3D_+3A_drawbboxhull">drawBBoxHull</code></td>
<td>
<p>If <code>addRays</code> then draw the hull areas hitting the bounding box also.</p>
</td></tr>
<tr><td><code id="plotHull3D_+3A_...">...</code></td>
<td>
<p>Further arguments passed on the the RGL plotting functions. This must be done as
lists (see examples). Currently the following arguments are supported:
</p>

<ul>
<li> <p><code>argsPlot3d</code>: A list of arguments for <code><a href="rgl.html#topic+plot3d">rgl::plot3d</a></code>.
</p>
</li>
<li> <p><code>argsSegments3d</code>: A list of arguments for <code><a href="rgl.html#topic+primitives">rgl::segments3d</a></code>.
</p>
</li>
<li> <p><code>argsPolygon3d</code>: A list of arguments for <code><a href="rgl.html#topic+polygon3d">rgl::polygon3d</a></code>.
</p>
</li>
<li> <p><code>argsShade3d</code>: A list of arguments for <code><a href="rgl.html#topic+mesh3d">rgl::shade3d</a></code>.
</p>
</li>
<li> <p><code>argsText3d</code>: A list of arguments for <code><a href="rgl.html#topic+texts">rgl::text3d</a></code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with hull, <code>pts</code> classified and object ids (invisible).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ini3D()
pts&lt;-matrix(c(0,0,0), ncol = 3, byrow = TRUE)
plotHull3D(pts) # a point
pts&lt;-matrix(c(1,1,1,2,2,2,3,3,3), ncol = 3, byrow = TRUE)
plotHull3D(pts, drawPoints = TRUE) # a line
pts&lt;-matrix(c(1,0,0,1,1,1,1,2,2,3,1,1,3,3,3), ncol = 3, byrow = TRUE)
plotHull3D(pts, drawLines = FALSE, argsPolygon3d = list(alpha=0.6)) # a polygon
pts&lt;-matrix(c(5,5,5,10,10,5,10,5,5,5,5,10), ncol = 3, byrow = TRUE)
lst &lt;- plotHull3D(pts, argsPolygon3d = list(alpha=0.9), argsSegments3d = list(color="red"))
finalize3D()
# pop3d(id = lst$ids) # remove last hull

## Using addRays
pts &lt;- data.frame(x = c(1,3), y = c(1,3), z = c(1,3))
ini3D(argsPlot3d = list(xlim = c(0,max(pts$x)+10),
  ylim = c(0,max(pts$y)+10),
  zlim = c(0,max(pts$z)+10)))
plotHull3D(pts, drawPoints = TRUE, addRays = TRUE, , drawBBoxHull = FALSE)
plotHull3D(c(4,4,4), drawPoints = TRUE, addRays = TRUE)
finalize3D()

pts &lt;- data.frame(x = c(4,2.5,1), y = c(1,2.5,4), z = c(1,2.5,4))
ini3D(argsPlot3d = list(xlim = c(0,max(pts$x)+10),
  ylim = c(0,max(pts$y)+10),
  zlim = c(0,max(pts$z)+10)))
plotHull3D(pts, drawPoints = TRUE, addRays = TRUE)
finalize3D()

pts &lt;- matrix(c(
  0, 4, 8,
  0, 8, 4,
  8, 4, 0,
  4, 8, 0,
  4, 0, 8,
  8, 0, 4,
  4, 4, 4,
  6, 6, 6
  ), ncol = 3, byrow = TRUE)
ini3D(FALSE, argsPlot3d = list(xlim = c(min(pts[,1])-2,max(pts[,1])+10),
  ylim = c(min(pts[,2])-2,max(pts[,2])+10),
  zlim = c(min(pts[,3])-2,max(pts[,3])+10)))
plotHull3D(pts, drawPoints = TRUE, addText = "coord")
plotHull3D(pts, addRays = TRUE)
finalize3D()

pts &lt;- genNDSet(3, 100, dubND = FALSE)
pts &lt;- as.data.frame(pts[,1:3])

ini3D(argsPlot3d = list(
  xlim = c(0,max(pts[,1])+10),
  ylim = c(0,max(pts[,2])+10),
  zlim = c(0,max(pts[,3])+10)))
plotHull3D(pts, drawPoints = TRUE, addRays = TRUE)
finalize3D()

ini3D(argsPlot3d = list(
  xlim = c(0,max(pts[,1])+10),
  ylim = c(0,max(pts[,2])+10),
  zlim = c(0,max(pts[,3])+10)))
plotHull3D(pts, drawPoints = TRUE, drawPolygons = TRUE, addText = "coord", addRays = TRUE)
finalize3D()

ini3D(argsPlot3d = list(
  xlim = c(0,max(pts[,1])+10),
  ylim = c(0,max(pts[,2])+10),
  zlim = c(0,max(pts[,3])+10)))
plotHull3D(pts, drawPoints = TRUE, drawLines = FALSE,
  argsPolygon3d = list(alpha = 1), addRays = TRUE)
finalize3D()

ini3D(argsPlot3d = list(
  xlim = c(0,max(pts[,1])+10),
  ylim = c(0,max(pts[,2])+10),
  zlim = c(0,max(pts[,3])+10)))
plotHull3D(pts, drawPoints = TRUE, argsPolygon3d = list(color = "red"), addRays = TRUE)
plotCones3D(pts, argsPolygon3d = list(alpha = 1), rectangle = TRUE)
finalize3D()

</code></pre>

<hr>
<h2 id='plotLines2D'>Plot the lines of a linear mathematical program (Ax = b)</h2><span id='topic+plotLines2D'></span>

<h3>Description</h3>

<p>Plot the lines of a linear mathematical program (Ax = b)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLines2D(A, b, nonneg = rep(TRUE, ncol(A)), latex = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotLines2D_+3A_a">A</code></td>
<td>
<p>The constraint matrix.</p>
</td></tr>
<tr><td><code id="plotLines2D_+3A_b">b</code></td>
<td>
<p>Right hand side.</p>
</td></tr>
<tr><td><code id="plotLines2D_+3A_nonneg">nonneg</code></td>
<td>
<p>A boolean vector of same length as number of variables. If
entry k is TRUE then variable k must be non-negative and the line is plotted too.</p>
</td></tr>
<tr><td><code id="plotLines2D_+3A_latex">latex</code></td>
<td>
<p>If <code>True</code> make latex math labels for TikZ.</p>
</td></tr>
<tr><td><code id="plotLines2D_+3A_...">...</code></td>
<td>
<p>Further arguments passed on the the <code>ggplot</code> plotting functions. This must be done as
lists. Currently the following arguments are supported:
</p>

<ul>
<li> <p><code>argsTheme</code>: A list of arguments for <code><a href="ggplot2.html#topic+theme">ggplot2::theme</a></code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>Note</h3>

<p>In general you will properly use <code><a href="#topic+plotPolytope">plotPolytope()</a></code> instead of this function.
</p>


<h3>Author(s)</h3>

<p>Lars Relund <a href="mailto:lars@relund.dk">lars@relund.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotPolytope">plotPolytope()</a></code>.
</p>

<hr>
<h2 id='plotMTeX3D'>Plot TeX in the margin</h2><span id='topic+plotMTeX3D'></span>

<h3>Description</h3>

<p>Plot TeX in the margin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMTeX3D(tex, edge, line = 0, at = NULL, pos = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMTeX3D_+3A_tex">tex</code></td>
<td>
<p>TeX string</p>
</td></tr>
<tr><td><code id="plotMTeX3D_+3A_edge">edge</code></td>
<td>
<p>The position at which to draw the axis or text.</p>
</td></tr>
<tr><td><code id="plotMTeX3D_+3A_line">line</code></td>
<td>
<p>The &ldquo;line&rdquo; of the plot margin to draw the label on.</p>
</td></tr>
<tr><td><code id="plotMTeX3D_+3A_at">at</code></td>
<td>
<p>The value of a coordinate at which to draw the axis.</p>
</td></tr>
<tr><td><code id="plotMTeX3D_+3A_pos">pos</code></td>
<td>
<p>The position at which to draw the axis or text.</p>
</td></tr>
<tr><td><code id="plotMTeX3D_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+plotTeX3D">plotTeX3D()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object IDs of objects added to the scene.
</p>

<hr>
<h2 id='plotNDSet2D'>Create a plot of a discrete non-dominated set.</h2><span id='topic+plotNDSet2D'></span>

<h3>Description</h3>

<p>Create a plot of a discrete non-dominated set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotNDSet2D(
  points,
  crit,
  addTriangles = FALSE,
  addHull = TRUE,
  latex = FALSE,
  labels = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotNDSet2D_+3A_points">points</code></td>
<td>
<p>Data frame with non-dominated points.</p>
</td></tr>
<tr><td><code id="plotNDSet2D_+3A_crit">crit</code></td>
<td>
<p>Either max or min (only used if add the iso-profit line). A vector is currently not
supported.</p>
</td></tr>
<tr><td><code id="plotNDSet2D_+3A_addtriangles">addTriangles</code></td>
<td>
<p>Add search triangles defined by the non-dominated extreme points.</p>
</td></tr>
<tr><td><code id="plotNDSet2D_+3A_addhull">addHull</code></td>
<td>
<p>Add the convex hull and the rays.</p>
</td></tr>
<tr><td><code id="plotNDSet2D_+3A_latex">latex</code></td>
<td>
<p>If true make latex math labels for TikZ.</p>
</td></tr>
<tr><td><code id="plotNDSet2D_+3A_labels">labels</code></td>
<td>
<p>If <code>NULL</code> don't add any labels. If 'n' no labels but show the points. If equal
<code>coord</code> add coordinates to the points. Otherwise number all points from one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>ggplot</code> object.
</p>


<h3>Note</h3>

<p>Currently only points are checked for dominance. That is, for MILP models some
nondominated points may in fact be dominated by a segment.
</p>


<h3>Author(s)</h3>

<p>Lars Relund <a href="mailto:lars@relund.dk">lars@relund.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- data.frame(z1=c(12,14,16,18,18,18,14,15,15), z2=c(18,16,12,4,2,6,14,14,16))
points &lt;- addNDSet(dat, crit = "min", keepDom = TRUE)
plotNDSet2D(points, crit = "min", addTriangles = TRUE)
plotNDSet2D(points, crit = "min", addTriangles = FALSE)
plotNDSet2D(points, crit = "min", addTriangles = TRUE, addHull = FALSE)
points &lt;- addNDSet(dat, crit = "max", keepDom = TRUE)
plotNDSet2D(points, crit = "max", addTriangles = TRUE)
plotNDSet2D(points, crit = "max", addHull = FALSE)
</code></pre>

<hr>
<h2 id='plotPlane3D'>Plot a plane in 3D.</h2><span id='topic+plotPlane3D'></span>

<h3>Description</h3>

<p>Plot a plane in 3D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPlane3D(
  normal,
  point = NULL,
  offset = 0,
  useShade = TRUE,
  useLines = FALSE,
  usePoints = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPlane3D_+3A_normal">normal</code></td>
<td>
<p>Normal to the plane.</p>
</td></tr>
<tr><td><code id="plotPlane3D_+3A_point">point</code></td>
<td>
<p>A point on the plane.</p>
</td></tr>
<tr><td><code id="plotPlane3D_+3A_offset">offset</code></td>
<td>
<p>The offset of the plane (only used if <code>point = NULL</code>).</p>
</td></tr>
<tr><td><code id="plotPlane3D_+3A_useshade">useShade</code></td>
<td>
<p>Plot shade of the plane.</p>
</td></tr>
<tr><td><code id="plotPlane3D_+3A_uselines">useLines</code></td>
<td>
<p>Plot lines inside the plane.</p>
</td></tr>
<tr><td><code id="plotPlane3D_+3A_usepoints">usePoints</code></td>
<td>
<p>Plot point shapes inside the plane.</p>
</td></tr>
<tr><td><code id="plotPlane3D_+3A_...">...</code></td>
<td>
<p>Further arguments passed on the the RGL plotting functions. This must be done as
lists (see examples). Currently the following arguments are supported:
</p>

<ul>
<li> <p><code>argsPlanes3d</code>: A list of arguments for <code><a href="rgl.html#topic+planes">rgl::planes3d()</a></code> used when <code>useShade = TRUE</code>.
</p>
</li>
<li> <p><code>argsLines</code>: A list of arguments for <code><a href="rgl.html#topic+persp3d">rgl::persp3d()</a></code> when <code>useLines = TRUE</code>. Moreover, the list
may contain <code>lines</code>: number of lines.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL (invisible)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ini3D(argsPlot3d = list(xlim = c(-1,10), ylim = c(-1,10), zlim = c(-1,10)) )
plotPlane3D(c(1,1,1), point = c(1,1,1))
plotPoints3D(c(1,1,1))
plotPlane3D(c(1,2,1), point = c(2,2,2), argsPlanes3d = list(color="red"))
plotPoints3D(c(2,2,2))
plotPlane3D(c(2,1,1), offset = -6, argsPlanes3d = list(color="blue"))
plotPlane3D(c(2,1,1), argsPlanes3d = list(color="green"))
finalize3D()

ini3D(argsPlot3d = list(xlim = c(-1,10), ylim = c(-1,10), zlim = c(-1,10)) )
plotPlane3D(c(1,1,1), point = c(1,1,1), useLines = TRUE, useShade = TRUE)
ids &lt;- plotPlane3D(c(1,2,1), point = c(2,2,2), argsLines = list(col="blue", lines = 100),
            useLines = TRUE)
finalize3D()
# pop3d(id = ids) # remove last plane

</code></pre>

<hr>
<h2 id='plotPoints3D'>Plot points in 3D.</h2><span id='topic+plotPoints3D'></span>

<h3>Description</h3>

<p>Plot points in 3D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPoints3D(pts, addText = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPoints3D_+3A_pts">pts</code></td>
<td>
<p>A vector or matrix with the points.</p>
</td></tr>
<tr><td><code id="plotPoints3D_+3A_addtext">addText</code></td>
<td>
<p>Add text to the points. Currently <code>coord</code> (coordinates), <code>rownames</code> (rownames)
and <code>both</code> supported or a vector with the text.</p>
</td></tr>
<tr><td><code id="plotPoints3D_+3A_...">...</code></td>
<td>
<p>Further arguments passed on the the RGL plotting functions. This must be done as
lists (see examples). Currently the following arguments are supported:
</p>

<ul>
<li> <p><code>argsPlot3d</code>: A list of arguments for <code><a href="rgl.html#topic+plot3d">rgl::plot3d</a></code>.
</p>
</li>
<li> <p><code>argsPch3d</code>: A list of arguments for <code><a href="rgl.html#topic+pch3d">rgl::pch3d</a></code>.
</p>
</li>
<li> <p><code>argsText3d</code>: A list of arguments for <code><a href="rgl.html#topic+texts">rgl::text3d</a></code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Object ids (invisible).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ini3D()
pts&lt;-matrix(c(1,1,1,5,5,5), ncol = 3, byrow = TRUE)
plotPoints3D(pts)
plotPoints3D(c(2,3,3), argsPlot3d = list(col = "red", size = 10))
plotPoints3D(c(3,2,3), argsPlot3d = list(col = "blue", size = 10, type="p"))
plotPoints3D(c(1.5,1.5,1.5), argsPlot3d = list(col = "blue", size = 10, type="p"))
plotPoints3D(c(2,2,2, 1,1,1), addText = "coord")
ids &lt;- plotPoints3D(c(3,3,3, 4,4,4), addText = "rownames")
finalize3D()
rgl::rglwidget()
# pop3d(ids) # remove the last again

</code></pre>

<hr>
<h2 id='plotPolygon3D'>Plot a polygon.</h2><span id='topic+plotPolygon3D'></span>

<h3>Description</h3>

<p>Plot a polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPolygon3D(
  pts,
  useShade = TRUE,
  useLines = FALSE,
  usePoints = FALSE,
  useFrame = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPolygon3D_+3A_pts">pts</code></td>
<td>
<p>Vertices.</p>
</td></tr>
<tr><td><code id="plotPolygon3D_+3A_useshade">useShade</code></td>
<td>
<p>Plot shade of the polygon.</p>
</td></tr>
<tr><td><code id="plotPolygon3D_+3A_uselines">useLines</code></td>
<td>
<p>Plot lines inside the polygon.</p>
</td></tr>
<tr><td><code id="plotPolygon3D_+3A_usepoints">usePoints</code></td>
<td>
<p>Plot point shapes inside the polygon.</p>
</td></tr>
<tr><td><code id="plotPolygon3D_+3A_useframe">useFrame</code></td>
<td>
<p>Plot a frame around the polygon.</p>
</td></tr>
<tr><td><code id="plotPolygon3D_+3A_...">...</code></td>
<td>
<p>Further arguments passed on the RGL plotting functions. This must be done as
lists (see examples). Currently the following arguments are supported:
</p>

<ul>
<li> <p><code>argsShade</code>: A list of arguments for <code><a href="rgl.html#topic+polygon3d">rgl::polygon3d</a></code> (n &gt; 4 vertices),
<code><a href="rgl.html#topic+primitives">rgl::triangles3d()</a></code> (n = 3 vertices) and <code><a href="rgl.html#topic+primitives">rgl::quads3d()</a></code> (n = 4 vertices)
if <code>useShade = TRUE</code>.
</p>
</li>
<li> <p><code>argsFrame</code>: A list of arguments for <code><a href="rgl.html#topic+primitives">rgl::lines3d</a></code> if <code>useFrame = TRUE</code>.
</p>
</li>
<li> <p><code>argsPoints</code>: A list of arguments for <code><a href="rgl.html#topic+shade3d">rgl::shade3d</a></code> if <code>usePoints = TRUE</code>. It is important
to give a texture using <code>texture</code>. A texture can be set using <code><a href="#topic+getTexture">getTexture()</a></code>.
</p>
</li>
<li> <p><code>argsLines</code>: A list of arguments for <code><a href="rgl.html#topic+persp3d">rgl::persp3d()</a></code> when <code>useLines = TRUE</code>. Moreover, the list
may contain <code>lines</code>: number of lines.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Object ids (invisible).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pts &lt;- data.frame(x = c(1,0,0,0.4), y = c(0,1,0,0.3), z = c(0,0,1,0.3))
pts &lt;- data.frame(x = c(1,0,0), y = c(0,1,0), z = c(0,0,1))

ini3D()
plotPolygon3D(pts)
finalize3D()

ini3D()
plotPolygon3D(pts, argsShade = list(color = "red", alpha = 1))
finalize3D()

ini3D()
plotPolygon3D(pts, useFrame = TRUE, argsShade = list(color = "red", alpha = 0.5),
              argsFrame = list(color = "green"))
finalize3D()

ini3D()
plotPolygon3D(pts, useFrame = TRUE, useLines = TRUE, useShade = TRUE,
              argsShade = list(color = "red", alpha = 0.2),
              argsLines = list(color = "blue"))
finalize3D()

ini3D()
ids &lt;- plotPolygon3D(pts, usePoints = TRUE, useFrame = TRUE,
              argsPoints = list(texture = getTexture(pch = 16, cex = 20)))
finalize3D()
# pop3d(id = ids) # remove object again

# In general you have to finetune size and numbers when you use textures
# Different pch
for (i in 0:3) {
  fname &lt;- getTexture(pch = 15+i, cex = 30)
  ini3D(TRUE)
  plotPolygon3D(pts, usePoints = TRUE, argsPoints = list(texture = fname))
  finalize3D()
}

# Size of pch
for (i in 1:4) {
  fname &lt;- getTexture(pch = 15+i, cex = 10 * i)
  ini3D(TRUE)
  plotPolygon3D(pts, usePoints = TRUE, argsPoints = list(texture = fname))
  finalize3D()
}

# Number of pch
fname &lt;- getTexture(pch = 16, cex = 20)
for (i in 1:4) {
  ini3D(TRUE)
  plotPolygon3D(pts, usePoints = TRUE,
                argsPoints = list(texture = fname, texcoords = rbind(pts$x, pts$y, pts$z)*5*i))
  finalize3D()
}

</code></pre>

<hr>
<h2 id='plotPolytope'>Plot the polytope (bounded convex set) of a linear mathematical program (Ax &lt;= b)</h2><span id='topic+plotPolytope'></span>

<h3>Description</h3>

<p>This is a wrapper function calling <code><a href="#topic+plotPolytope2D">plotPolytope2D()</a></code> (2D graphics) and
<code><a href="#topic+plotPolytope3D">plotPolytope3D()</a></code> (3D graphics).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPolytope(
  A,
  b,
  obj = NULL,
  type = rep("c", ncol(A)),
  nonneg = rep(TRUE, ncol(A)),
  crit = "max",
  faces = type,
  plotFaces = TRUE,
  plotFeasible = TRUE,
  plotOptimum = FALSE,
  latex = FALSE,
  labels = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPolytope_+3A_a">A</code></td>
<td>
<p>The constraint matrix.</p>
</td></tr>
<tr><td><code id="plotPolytope_+3A_b">b</code></td>
<td>
<p>Right hand side.</p>
</td></tr>
<tr><td><code id="plotPolytope_+3A_obj">obj</code></td>
<td>
<p>A vector with objective coefficients.</p>
</td></tr>
<tr><td><code id="plotPolytope_+3A_type">type</code></td>
<td>
<p>A character vector of same length as number of variables. If
entry k is 'i' variable <code class="reqn">k</code> must be integer and if 'c' continuous.</p>
</td></tr>
<tr><td><code id="plotPolytope_+3A_nonneg">nonneg</code></td>
<td>
<p>A boolean vector of same length as number of variables. If
entry k is TRUE then variable k must be non-negative.</p>
</td></tr>
<tr><td><code id="plotPolytope_+3A_crit">crit</code></td>
<td>
<p>Either max or min (only used if add the iso-profit line)</p>
</td></tr>
<tr><td><code id="plotPolytope_+3A_faces">faces</code></td>
<td>
<p>A character vector of same length as number of variables. If
entry k is 'i' variable <code class="reqn">k</code> must be integer and if 'c' continuous.
Useful if e.g. want to show the linear relaxation of an IP.</p>
</td></tr>
<tr><td><code id="plotPolytope_+3A_plotfaces">plotFaces</code></td>
<td>
<p>If <code>True</code> then plot the faces.</p>
</td></tr>
<tr><td><code id="plotPolytope_+3A_plotfeasible">plotFeasible</code></td>
<td>
<p>If <code>True</code> then plot the feasible points/segments
(relevant for IPLP/MILP).</p>
</td></tr>
<tr><td><code id="plotPolytope_+3A_plotoptimum">plotOptimum</code></td>
<td>
<p>Show the optimum corner solution point (if alternative solutions
only one is shown) and add the iso-profit line.</p>
</td></tr>
<tr><td><code id="plotPolytope_+3A_latex">latex</code></td>
<td>
<p>If <code>True</code> make latex math labels for TikZ.</p>
</td></tr>
<tr><td><code id="plotPolytope_+3A_labels">labels</code></td>
<td>
<p>If <code>NULL</code> don't add any labels. If 'n' no labels but show the points. If equal
<code>coord</code> add coordinates to the points. Otherwise number all points from one.</p>
</td></tr>
<tr><td><code id="plotPolytope_+3A_...">...</code></td>
<td>
<p>If 2D, further arguments passed on the the <code>ggplot</code> plotting functions. This must be
done as lists. Currently the following arguments are supported:
</p>

<ul>
<li> <p><code>argsFaces</code>: A list of arguments for <code><a href="#topic+plotHull2D">plotHull2D</a></code>.
</p>
</li>
<li> <p><code>argsFeasible</code>: A list of arguments for <code>ggplot2</code> functions:
</p>

<ul>
<li> <p><code>geom_point</code>: A list of arguments for <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point</a></code>.
</p>
</li>
<li> <p><code>geom_line</code>: A list of arguments for <code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_line</a></code>.
</p>
</li></ul>

</li>
<li> <p><code>argsLabels</code>: A list of arguments for <code>ggplot2</code> functions:
</p>

<ul>
<li> <p><code>geom_text</code>: A list of arguments for <code><a href="ggplot2.html#topic+geom_text">ggplot2::geom_text</a></code>.
</p>
</li></ul>

</li>
<li> <p><code>argsOptimum</code>:
</p>

<ul>
<li> <p><code>geom_point</code>: A list of arguments for <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point</a></code>.
</p>
</li>
<li> <p><code>geom_abline</code>: A list of arguments for <code><a href="ggplot2.html#topic+geom_abline">ggplot2::geom_abline</a></code>.
</p>
</li>
<li> <p><code>geom_label</code>: A list of arguments for <code><a href="ggplot2.html#topic+geom_text">ggplot2::geom_label</a></code>.
</p>
</li></ul>

</li>
<li> <p><code>argsTheme</code>: A list of arguments for <code><a href="ggplot2.html#topic+theme">ggplot2::theme</a></code>.
</p>
</li></ul>

<p>If 3D further arguments passed on the the RGL plotting functions. This must be done as
lists. Currently the following arguments are supported:
</p>

<ul>
<li> <p><code>argsAxes3d</code>: A list of arguments for <code><a href="rgl.html#topic+axes3d">rgl::axes3d</a></code>.
</p>
</li>
<li> <p><code>argsPlot3d</code>: A list of arguments for <code><a href="rgl.html#topic+plot3d">rgl::plot3d</a></code> to open the RGL window.
</p>
</li>
<li> <p><code>argsTitle3d</code>: A list of arguments for <code><a href="rgl.html#topic+axes3d">rgl::title3d</a></code>.
</p>
</li>
<li> <p><code>argsFaces</code>: A list of arguments for <code><a href="#topic+plotHull3D">plotHull3D</a></code>.
</p>
</li>
<li> <p><code>argsFeasible</code>: A list of arguments for RGL functions:
</p>

<ul>
<li> <p><code>points3d</code>: A list of arguments for <code><a href="rgl.html#topic+primitives">rgl::points3d</a></code>.
</p>
</li>
<li> <p><code>segments3d</code>: A list of arguments for <code><a href="rgl.html#topic+primitives">rgl::segments3d</a></code>.
</p>
</li>
<li> <p><code>triangles3d</code>: A list of arguments for <code><a href="rgl.html#topic+primitives">rgl::triangles3d</a></code>.
</p>
</li></ul>

</li>
<li> <p><code>argsLabels</code>: A list of arguments for RGL functions:
</p>

<ul>
<li> <p><code>points3d</code>: A list of arguments for <code><a href="rgl.html#topic+primitives">rgl::points3d</a></code>.
</p>
</li>
<li> <p><code>text3d</code>: A list of arguments for <code><a href="rgl.html#topic+texts">rgl::text3d</a></code>.
</p>
</li></ul>

</li>
<li> <p><code>argsOptimum</code>: A list of arguments for RGL functions:
</p>

<ul>
<li> <p><code>points3d</code>: A list of arguments for <code><a href="rgl.html#topic+primitives">rgl::points3d</a></code>.
</p>
</li></ul>

</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>If 2D a <code>ggplot</code> object. If 3D a RGL window with the 3D plot.
</p>


<h3>Note</h3>

<p>The feasible region defined by the constraints must be bounded (i.e. no extreme rays)
otherwise you may see strange results.
</p>


<h3>Author(s)</h3>

<p>Lars Relund <a href="mailto:lars@relund.dk">lars@relund.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### 2D examples ####
# Define the model max/min coeff*x st. Ax&lt;=b, x&gt;=0
A &lt;- matrix(c(-3,2,2,4,9,10), ncol = 2, byrow = TRUE)
b &lt;- c(3,27,90)
obj &lt;- c(7.75, 10)

## LP model
# The polytope with the corner points
plotPolytope(
   A,
   b,
   obj,
   type = rep("c", ncol(A)),
   crit = "max",
   faces = rep("c", ncol(A)),
   plotFaces = TRUE,
   plotFeasible = TRUE,
   plotOptimum = FALSE,
   labels = NULL,
   argsFaces = list(argsGeom_polygon = list(fill = "red"))
)
# With optimum and labels:
plotPolytope(
   A,
   b,
   obj,
   type = rep("c", ncol(A)),
   crit = "max",
   faces = rep("c", ncol(A)),
   plotFaces = TRUE,
   plotFeasible = TRUE,
   plotOptimum = TRUE,
   labels = "coord",
   argsOptimum = list(lty="solid")
)
# Minimize:
plotPolytope(
   A,
   b,
   obj,
   type = rep("c", ncol(A)),
   crit = "min",
   faces = rep("c", ncol(A)),
   plotFaces = TRUE,
   plotFeasible = TRUE,
   plotOptimum = TRUE,
   labels = "n"
)
# Note return a ggplot so can e.g. add other labels on e.g. the axes:
p &lt;- plotPolytope(
   A,
   b,
   obj,
   type = rep("c", ncol(A)),
   crit = "max",
   faces = rep("c", ncol(A)),
   plotFaces = TRUE,
   plotFeasible = TRUE,
   plotOptimum = TRUE,
   labels = "coord"
)
p + ggplot2::xlab("x") + ggplot2::ylab("y")

# More examples

## LP-model with no non-negativity constraints
A &lt;- matrix(c(-3, 2, 2, 4, 9, 10, 1, -2), ncol = 2, byrow = TRUE)
b &lt;- c(3, 27, 90, 2)
obj &lt;- c(7.75, 10)
plotPolytope(
   A,
   b,
   obj,
   type = rep("c", ncol(A)),
   nonneg = rep(FALSE, ncol(A)),
   crit = "max",
   faces = rep("c", ncol(A)),
   plotFaces = TRUE,
   plotFeasible = TRUE,
   plotOptimum = FALSE,
   labels = NULL
)



## The package don't plot feasible regions that are unbounded e.g if we drop the 2 and 3 constraint
A &lt;- matrix(c(-3,2), ncol = 2, byrow = TRUE)
b &lt;- c(3)
obj &lt;- c(7.75, 10)
# Wrong plot
plotPolytope(
   A,
   b,
   obj,
   type = rep("c", ncol(A)),
   crit = "max",
   faces = rep("c", ncol(A)),
   plotFaces = TRUE,
   plotFeasible = TRUE,
   plotOptimum = FALSE,
   labels = NULL
)
# One solution is to add a bounding box and check if the bounding box is binding
A &lt;- rbind(A, c(1,0), c(0,1))
b &lt;- c(b, 10, 10)
plotPolytope(
   A,
   b,
   obj,
   type = rep("c", ncol(A)),
   crit = "max",
   faces = rep("c", ncol(A)),
   plotFaces = TRUE,
   plotFeasible = TRUE,
   plotOptimum = FALSE,
   labels = NULL
)


## ILP model
A &lt;- matrix(c(-3,2,2,4,9,10), ncol = 2, byrow = TRUE)
b &lt;- c(3,27,90)
obj &lt;- c(7.75, 10)
# ILP model with LP faces:
plotPolytope(
   A,
   b,
   obj,
   type = rep("i", ncol(A)),
   crit = "max",
   faces = rep("c", ncol(A)),
   plotFaces = TRUE,
   plotFeasible = TRUE,
   plotOptimum = TRUE,
   labels = "coord",
   argsLabels = list(size = 4, color = "blue"),
   argsFeasible = list(color = "red", size = 3)
)
#ILP model with IP faces:
plotPolytope(
   A,
   b,
   obj,
   type = rep("i", ncol(A)),
   crit = "max",
   faces = rep("i", ncol(A)),
   plotFaces = TRUE,
   plotFeasible = TRUE,
   plotOptimum = TRUE,
   labels = "coord"
)


## MILP model
A &lt;- matrix(c(-3,2,2,4,9,10), ncol = 2, byrow = TRUE)
b &lt;- c(3,27,90)
obj &lt;- c(7.75, 10)
# Second coordinate integer
plotPolytope(
   A,
   b,
   obj,
   type = c("c", "i"),
   crit = "max",
   faces = c("c", "i"),
   plotFaces = FALSE,
   plotFeasible = TRUE,
   plotOptimum = TRUE,
   labels = "coord",
   argsFeasible = list(color = "red")
)
# First coordinate integer and with LP faces:
plotPolytope(
   A,
   b,
   obj,
   type = c("i", "c"),
   crit = "max",
   faces = c("c", "c"),
   plotFaces = TRUE,
   plotFeasible = TRUE,
   plotOptimum = TRUE,
   labels = "coord"
)
# First coordinate integer and with LP faces:
plotPolytope(
   A,
   b,
   obj,
   type = c("i", "c"),
   crit = "max",
   faces = c("i", "c"),
   plotFaces = TRUE,
   plotFeasible = TRUE,
   plotOptimum = TRUE,
   labels = "coord"
)




#### 3D examples ####

# Ex 1
view &lt;- matrix( c(-0.412063330411911, -0.228006735444069, 0.882166087627411, 0, 0.910147845745087,
                  -0.0574885793030262, 0.410274744033813, 0, -0.042830865830183, 0.97196090221405,
                  0.231208890676498, 0, 0, 0, 0, 1), nc = 4)
loadView(v = view)
A &lt;- matrix( c(
   3, 2, 5,
   2, 1, 1,
   1, 1, 3,
   5, 2, 4
), nc = 3, byrow = TRUE)
b &lt;- c(55, 26, 30, 57)
obj &lt;- c(20, 10, 15)
# LP model
plotPolytope(A, b, plotOptimum = TRUE, obj = obj, labels = "coord")
plotPolytope(A, b, plotOptimum = TRUE, obj = obj, labels = "coord",
             argsFaces = list(drawLines = FALSE, argsPolygon3d = list(alpha = 0.95)),
             argsLabels = list(points3d = list(color = "blue")))
# ILP model
plotPolytope(A, b, faces = c("c","c","c"), type = c("i","i","i"), plotOptimum = TRUE, obj = obj)
# MILP model
plotPolytope(A, b, faces = c("c","c","c"), type = c("i","c","i"), plotOptimum = TRUE, obj = obj)
plotPolytope(A, b, faces = c("c","c","c"), type = c("c","i","i"), plotOptimum = TRUE, obj = obj)
plotPolytope(A, b, faces = c("c","c","c"), type = c("i","i","c"), plotOptimum = TRUE, obj = obj)
plotPolytope(A, b, faces = c("c","c","c"), type = c("i","i","c"), plotFaces = FALSE)
plotPolytope(A, b, type = c("i","c","c"), plotOptimum = TRUE, obj = obj, plotFaces = FALSE)
plotPolytope(A, b, type = c("c","i","c"), plotOptimum = TRUE, obj = obj, plotFaces = FALSE)
plotPolytope(A, b, type = c("c","c","i"), plotOptimum = TRUE, obj = obj, plotFaces = FALSE)

# Ex 2
view &lt;- matrix( c(-0.812462985515594, -0.029454167932272, 0.582268416881561, 0, 0.579295456409454,
                  -0.153386667370796, 0.800555109977722, 0, 0.0657325685024261, 0.987727105617523,
                  0.14168381690979, 0, 0, 0, 0, 1), nc = 4)
loadView(v = view)
A &lt;- matrix( c(
   1, 1, 1,
   3, 0, 1
), nc = 3, byrow = TRUE)
b &lt;- c(10, 24)
obj &lt;- c(20, 10, 15)
plotPolytope(A, b, plotOptimum = TRUE, obj = obj, labels = "coord")
# ILP model
plotPolytope(A, b, faces = c("c","c","c"), type = c("i","i","i"), plotOptimum = TRUE, obj = obj)
# MILP model
plotPolytope(A, b, faces = c("c","c","c"), type = c("i","c","i"), plotOptimum = TRUE, obj = obj)
plotPolytope(A, b, faces = c("c","c","c"), type = c("c","i","i"), plotOptimum = TRUE, obj = obj)
plotPolytope(A, b, faces = c("c","c","c"), type = c("i","i","c"), plotOptimum = TRUE, obj = obj)
plotPolytope(A, b, faces = c("c","c","c"), type = c("i","i","c"), plotFaces = FALSE)
plotPolytope(A, b, type = c("i","c","c"), plotOptimum = TRUE, obj = obj, plotFaces = FALSE)
plotPolytope(A, b, type = c("c","i","c"), plotOptimum = TRUE, obj = obj, plotFaces = FALSE)
plotPolytope(A, b, type = c("c","c","i"), plotOptimum = TRUE, obj = obj, plotFaces = FALSE)

# Ex 3
view &lt;- matrix( c(0.976349174976349, -0.202332556247711, 0.0761845782399178, 0, 0.0903248339891434,
                  0.701892614364624, 0.706531345844269, 0, -0.196427255868912, -0.682940244674683,
                  0.703568696975708, 0, 0, 0, 0, 1), nc = 4)
loadView(v = view)
A &lt;- matrix( c(
   -1, 1, 0,
   1, 4, 0,
   2, 1, 0,
   3, -4, 0,
   0, 0, 4
), nc = 3, byrow = TRUE)
b &lt;- c(5, 45, 27, 24, 10)
obj &lt;- c(5, 45, 15)
plotPolytope(A, b, plotOptimum = TRUE, obj = obj, labels = "coord")
# ILP model
plotPolytope(A, b, faces = c("c","c","c"), type = c("i","i","i"), plotOptimum = TRUE, obj = obj)
# MILP model
plotPolytope(A, b, faces = c("c","c","c"), type = c("i","c","i"), plotOptimum = TRUE, obj = obj)
plotPolytope(A, b, faces = c("c","c","c"), type = c("c","i","i"), plotOptimum = TRUE, obj = obj)
plotPolytope(A, b, faces = c("c","c","c"), type = c("i","i","c"), plotOptimum = TRUE, obj = obj)
plotPolytope(A, b, faces = c("c","c","c"), type = c("i","i","c"), plotFaces = FALSE)
plotPolytope(A, b, type = c("i","c","c"), plotOptimum = TRUE, obj = obj, plotFaces = FALSE)
plotPolytope(A, b, type = c("c","i","c"), plotOptimum = TRUE, obj = obj, plotFaces = FALSE)
plotPolytope(A, b, type = c("c","c","i"), plotOptimum = TRUE, obj = obj, plotFaces = FALSE)

# Ex 4
view &lt;- matrix( c(-0.452365815639496, -0.446501553058624, 0.77201122045517, 0, 0.886364221572876,
                  -0.320795893669128, 0.333835482597351, 0, 0.0986008867621422, 0.835299551486969,
                  0.540881276130676, 0, 0, 0, 0, 1), nc = 4)
loadView(v = view)
Ab &lt;- matrix( c(
   1, 1, 2, 5,
   2, -1, 0, 3,
   -1, 2, 1, 3,
   0, -3, 5, 2
   #   0, 1, 0, 4,
   #   1, 0, 0, 4
), nc = 4, byrow = TRUE)
A &lt;- Ab[,1:3]
b &lt;- Ab[,4]
obj = c(1,1,3)
plotPolytope(A, b, plotOptimum = TRUE, obj = obj, labels = "coord")
# ILP model
plotPolytope(A, b, faces = c("c","c","c"), type = c("i","i","i"), plotOptimum = TRUE, obj = obj)
# MILP model
plotPolytope(A, b, faces = c("c","c","c"), type = c("i","c","i"), plotOptimum = TRUE, obj = obj)
plotPolytope(A, b, faces = c("c","c","c"), type = c("c","i","i"), plotOptimum = TRUE, obj = obj)
plotPolytope(A, b, faces = c("c","c","c"), type = c("i","i","c"), plotOptimum = TRUE, obj = obj)
plotPolytope(A, b, faces = c("c","c","c"), type = c("i","i","c"), plotFaces = FALSE)
plotPolytope(A, b, type = c("i","c","c"), plotOptimum = TRUE, obj = obj, plotFaces = FALSE)
plotPolytope(A, b, type = c("c","i","c"), plotOptimum = TRUE, obj = obj, plotFaces = FALSE)
plotPolytope(A, b, faces = c("c","c","c"), type = c("c","c","i"), plotOptimum = TRUE, obj = obj)

</code></pre>

<hr>
<h2 id='plotPolytope2D'>Plot the polytope (bounded convex set) of a linear mathematical program</h2><span id='topic+plotPolytope2D'></span>

<h3>Description</h3>

<p>Plot the polytope (bounded convex set) of a linear mathematical program
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPolytope2D(
  A,
  b,
  obj = NULL,
  type = rep("c", ncol(A)),
  nonneg = rep(TRUE, ncol(A)),
  crit = "max",
  faces = rep("c", ncol(A)),
  plotFaces = TRUE,
  plotFeasible = TRUE,
  plotOptimum = FALSE,
  latex = FALSE,
  labels = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPolytope2D_+3A_a">A</code></td>
<td>
<p>The constraint matrix.</p>
</td></tr>
<tr><td><code id="plotPolytope2D_+3A_b">b</code></td>
<td>
<p>Right hand side.</p>
</td></tr>
<tr><td><code id="plotPolytope2D_+3A_obj">obj</code></td>
<td>
<p>A vector with objective coefficients.</p>
</td></tr>
<tr><td><code id="plotPolytope2D_+3A_type">type</code></td>
<td>
<p>A character vector of same length as number of variables. If
entry k is 'i' variable <code class="reqn">k</code> must be integer and if 'c' continuous.</p>
</td></tr>
<tr><td><code id="plotPolytope2D_+3A_nonneg">nonneg</code></td>
<td>
<p>A boolean vector of same length as number of variables. If
entry k is TRUE then variable k must be non-negative.</p>
</td></tr>
<tr><td><code id="plotPolytope2D_+3A_crit">crit</code></td>
<td>
<p>Either max or min (only used if add the iso-profit line)</p>
</td></tr>
<tr><td><code id="plotPolytope2D_+3A_faces">faces</code></td>
<td>
<p>A character vector of same length as number of variables. If
entry k is 'i' variable <code class="reqn">k</code> must be integer and if 'c' continuous.
Useful if e.g. want to show the linear relaxation of an IP.</p>
</td></tr>
<tr><td><code id="plotPolytope2D_+3A_plotfaces">plotFaces</code></td>
<td>
<p>If <code>True</code> then plot the faces.</p>
</td></tr>
<tr><td><code id="plotPolytope2D_+3A_plotfeasible">plotFeasible</code></td>
<td>
<p>If <code>True</code> then plot the feasible points/segments
(relevant for ILP/MILP).</p>
</td></tr>
<tr><td><code id="plotPolytope2D_+3A_plotoptimum">plotOptimum</code></td>
<td>
<p>Show the optimum corner solution point (if alternative solutions
only one is shown) and add the iso-profit line.</p>
</td></tr>
<tr><td><code id="plotPolytope2D_+3A_latex">latex</code></td>
<td>
<p>If <code>True</code> make latex math labels for TikZ.</p>
</td></tr>
<tr><td><code id="plotPolytope2D_+3A_labels">labels</code></td>
<td>
<p>If <code>NULL</code> don't add any labels. If 'n' no labels but show the points. If equal
<code>coord</code> add coordinates to the points. Otherwise number all points from one.</p>
</td></tr>
<tr><td><code id="plotPolytope2D_+3A_...">...</code></td>
<td>
<p>Further arguments passed on the the <code>ggplot</code> plotting functions. This must be done as
lists. Currently the following arguments are supported:
</p>

<ul>
<li> <p><code>argsFaces</code>: A list of arguments for <code><a href="#topic+plotHull2D">plotHull2D</a></code>.
</p>
</li>
<li> <p><code>argsFeasible</code>: A list of arguments for <code>ggplotl2</code> functions:
</p>

<ul>
<li> <p><code>geom_point</code>: A list of arguments for <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point</a></code>.
</p>
</li>
<li> <p><code>geom_line</code>: A list of arguments for <code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_line</a></code>.
</p>
</li></ul>

</li>
<li> <p><code>argsLabels</code>: A list of arguments for <code>ggplotl2</code> functions:
</p>

<ul>
<li> <p><code>geom_text</code>: A list of arguments for <code><a href="ggplot2.html#topic+geom_text">ggplot2::geom_text</a></code>.
</p>
</li></ul>

</li>
<li> <p><code>argsOptimum</code>:
</p>

<ul>
<li> <p><code>geom_point</code>: A list of arguments for <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point</a></code>.
</p>
</li>
<li> <p><code>geom_abline</code>: A list of arguments for <code><a href="ggplot2.html#topic+geom_abline">ggplot2::geom_abline</a></code>.
</p>
</li>
<li> <p><code>geom_label</code>: A list of arguments for <code><a href="ggplot2.html#topic+geom_text">ggplot2::geom_label</a></code>.
</p>
</li></ul>

</li>
<li> <p><code>argsTheme</code>: A list of arguments for <code><a href="ggplot2.html#topic+theme">ggplot2::theme</a></code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>Note</h3>

<p>In general use <code><a href="#topic+plotPolytope">plotPolytope()</a></code> instead of this function. The feasible region defined by the constraints must be bounded otherwise you may see
strange results.
</p>


<h3>Author(s)</h3>

<p>Lars Relund <a href="mailto:lars@relund.dk">lars@relund.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotPolytope">plotPolytope()</a></code> for examples.
</p>

<hr>
<h2 id='plotPolytope3D'>Plot the polytope (bounded convex set) of a linear mathematical program</h2><span id='topic+plotPolytope3D'></span>

<h3>Description</h3>

<p>Plot the polytope (bounded convex set) of a linear mathematical program
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPolytope3D(
  A,
  b,
  obj = NULL,
  type = rep("c", ncol(A)),
  nonneg = rep(TRUE, ncol(A)),
  crit = "max",
  faces = rep("c", ncol(A)),
  plotFaces = TRUE,
  plotFeasible = TRUE,
  plotOptimum = FALSE,
  latex = FALSE,
  labels = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPolytope3D_+3A_a">A</code></td>
<td>
<p>The constraint matrix.</p>
</td></tr>
<tr><td><code id="plotPolytope3D_+3A_b">b</code></td>
<td>
<p>Right hand side.</p>
</td></tr>
<tr><td><code id="plotPolytope3D_+3A_obj">obj</code></td>
<td>
<p>A vector with objective coefficients.</p>
</td></tr>
<tr><td><code id="plotPolytope3D_+3A_type">type</code></td>
<td>
<p>A character vector of same length as number of variables. If
entry k is 'i' variable <code class="reqn">k</code> must be integer and if 'c' continuous.</p>
</td></tr>
<tr><td><code id="plotPolytope3D_+3A_nonneg">nonneg</code></td>
<td>
<p>A boolean vector of same length as number of variables. If
entry k is TRUE then variable k must be non-negative.</p>
</td></tr>
<tr><td><code id="plotPolytope3D_+3A_crit">crit</code></td>
<td>
<p>Either max or min (only used if add the iso-profit line)</p>
</td></tr>
<tr><td><code id="plotPolytope3D_+3A_faces">faces</code></td>
<td>
<p>A character vector of same length as number of variables. If
entry k is 'i' variable <code class="reqn">k</code> must be integer and if 'c' continuous.
Useful if e.g. want to show the linear relaxation of an IP.</p>
</td></tr>
<tr><td><code id="plotPolytope3D_+3A_plotfaces">plotFaces</code></td>
<td>
<p>If <code>True</code> then plot the faces.</p>
</td></tr>
<tr><td><code id="plotPolytope3D_+3A_plotfeasible">plotFeasible</code></td>
<td>
<p>If <code>True</code> then plot the feasible points/segments
(relevant for ILP/MILP).</p>
</td></tr>
<tr><td><code id="plotPolytope3D_+3A_plotoptimum">plotOptimum</code></td>
<td>
<p>Show the optimum corner solution point (if alternative solutions
only one is shown) and add the iso-profit line.</p>
</td></tr>
<tr><td><code id="plotPolytope3D_+3A_latex">latex</code></td>
<td>
<p>If <code>True</code> make latex math labels for TikZ.</p>
</td></tr>
<tr><td><code id="plotPolytope3D_+3A_labels">labels</code></td>
<td>
<p>If <code>NULL</code> don't add any labels. If 'n' no labels but show the points. If equal
<code>coord</code> add coordinates to the points. Otherwise number all points from one.</p>
</td></tr>
<tr><td><code id="plotPolytope3D_+3A_...">...</code></td>
<td>
<p>Further arguments passed on the the RGL plotting functions. This must be done as
lists. Currently the following arguments are supported:
</p>

<ul>
<li> <p><code>argsAxes3d</code>: A list of arguments for <code><a href="rgl.html#topic+axes3d">rgl::axes3d</a></code>.
</p>
</li>
<li> <p><code>argsPlot3d</code>: A list of arguments for <code><a href="rgl.html#topic+plot3d">rgl::plot3d</a></code> to open the RGL window.
</p>
</li>
<li> <p><code>argsTitle3d</code>: A list of arguments for <code><a href="rgl.html#topic+axes3d">rgl::title3d</a></code>.
</p>
</li>
<li> <p><code>argsFaces</code>: A list of arguments for <code><a href="#topic+plotHull3D">plotHull3D</a></code>.
</p>
</li>
<li> <p><code>argsFeasible</code>: A list of arguments for RGL functions:
</p>

<ul>
<li> <p><code>points3d</code>: A list of arguments for <code><a href="rgl.html#topic+primitives">rgl::points3d</a></code>.
</p>
</li>
<li> <p><code>segments3d</code>: A list of arguments for <code><a href="rgl.html#topic+primitives">rgl::segments3d</a></code>.
</p>
</li>
<li> <p><code>triangles3d</code>: A list of arguments for <code><a href="rgl.html#topic+primitives">rgl::triangles3d</a></code>.
</p>
</li></ul>

</li>
<li> <p><code>argsLabels</code>: A list of arguments for RGL functions:
</p>

<ul>
<li> <p><code>points3d</code>: A list of arguments for <code><a href="rgl.html#topic+primitives">rgl::points3d</a></code>.
</p>
</li>
<li> <p><code>text3d</code>: A list of arguments for <code><a href="rgl.html#topic+texts">rgl::text3d</a></code>.
</p>
</li></ul>

</li>
<li> <p><code>argsOptimum</code>: A list of arguments for RGL functions:
</p>

<ul>
<li> <p><code>points3d</code>: A list of arguments for <code><a href="rgl.html#topic+primitives">rgl::points3d</a></code>.
</p>
</li></ul>

</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A RGL window with 3D plot.
</p>


<h3>Note</h3>

<p>In general use <code><a href="#topic+plotPolytope">plotPolytope()</a></code> instead of this function. The feasible region defined by the constraints must be bounded otherwise you may see
strange results.
</p>


<h3>Author(s)</h3>

<p>Lars Relund <a href="mailto:lars@relund.dk">lars@relund.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotPolytope">plotPolytope()</a></code> for examples.
</p>

<hr>
<h2 id='plotRectangle3D'>Plot a rectangle defined by two corner points.</h2><span id='topic+plotRectangle3D'></span>

<h3>Description</h3>

<p>The rectangle is defined by {x|a &lt;= x &lt;= b} where a is the minimum values and
b is the maximum values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRectangle3D(a, b, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRectangle3D_+3A_a">a</code></td>
<td>
<p>A vector of length 3.</p>
</td></tr>
<tr><td><code id="plotRectangle3D_+3A_b">b</code></td>
<td>
<p>A vector of length 3.</p>
</td></tr>
<tr><td><code id="plotRectangle3D_+3A_...">...</code></td>
<td>
<p>Further arguments passed on the the RGL plotting functions. This must be done as
lists (see examples). Currently the following arguments are supported:
</p>

<ul>
<li> <p><code>argsPlot3d</code>: A list of arguments for <code><a href="rgl.html#topic+plot3d">rgl::plot3d</a></code>.
</p>
</li>
<li> <p><code>argsSegments3d</code>: A list of arguments for <code><a href="rgl.html#topic+primitives">rgl::segments3d</a></code>.
</p>
</li>
<li> <p><code>argsPolygon3d</code>: A list of arguments for <code><a href="rgl.html#topic+polygon3d">rgl::polygon3d</a></code>.
</p>
</li>
<li> <p><code>argsShade3d</code>: A list of arguments for <code><a href="rgl.html#topic+mesh3d">rgl::shade3d</a></code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Object ids (invisible).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ini3D()
plotRectangle3D(c(0,0,0), c(1,1,1))
plotRectangle3D(c(1,1,1), c(4,4,3), drawPoints = TRUE, drawLines = FALSE,
           argsPlot3d = list(size=2, type="s", alpha=0.3))
ids &lt;- plotRectangle3D(c(2,2,2), c(3,3,2.5), argsPolygon3d = list(alpha = 1) )
finalize3D()
# pop3d(id = ids) remove last object

</code></pre>

<hr>
<h2 id='plotTeX3D'>Plot TeX at a position.</h2><span id='topic+plotTeX3D'></span>

<h3>Description</h3>

<p>Plot TeX at a position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTeX3D(
  x,
  y,
  z,
  tex,
  cex = graphics::par("cex"),
  fixedSize = FALSE,
  size = 480,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTeX3D_+3A_x">x</code></td>
<td>
<p>Coordinate.</p>
</td></tr>
<tr><td><code id="plotTeX3D_+3A_y">y</code></td>
<td>
<p>Coordinate.</p>
</td></tr>
<tr><td><code id="plotTeX3D_+3A_z">z</code></td>
<td>
<p>Coordinate.</p>
</td></tr>
<tr><td><code id="plotTeX3D_+3A_tex">tex</code></td>
<td>
<p>TeX string.</p>
</td></tr>
<tr><td><code id="plotTeX3D_+3A_cex">cex</code></td>
<td>
<p>Expansion factor (you properly have to fine tune it).</p>
</td></tr>
<tr><td><code id="plotTeX3D_+3A_fixedsize">fixedSize</code></td>
<td>
<p>Fix the size of the object (no scaling when zoom).</p>
</td></tr>
<tr><td><code id="plotTeX3D_+3A_size">size</code></td>
<td>
<p>Size of the generated png.</p>
</td></tr>
<tr><td><code id="plotTeX3D_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="rgl.html#topic+sprites">rgl::sprites3d()</a></code> and <code><a href="#topic+texToPng">texToPng()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The shape ID of the displayed object is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tex0 &lt;- "$\\mathbb{R}_{\\geqq}$"
tex1 &lt;- "\\LaTeX"
tex2 &lt;- "This is a title"
ini3D(argsPlot3d = list(xlim = c(0, 2), ylim = c(0, 2), zlim = c(0, 2)))
plotTeX3D(0.75,0.75,0.75, tex0)
plotTeX3D(0.5,0.5,0.5, tex0, cex = 2)
plotTeX3D(1,1,1, tex2)
finalize3D()
ini3D(new = TRUE, argsPlot3d = list(xlim = c(0, 200), ylim = c(0, 200), zlim = c(0, 200)))
plotTeX3D(75,75,75, tex0)
plotTeX3D(50,50,50, tex1)
plotTeX3D(100,100,100, tex2)
finalize3D()

## End(Not run)
</code></pre>

<hr>
<h2 id='plotTitleTeX3D'>Draw boxes, axes and other text outside the data using TeX strings.</h2><span id='topic+plotTitleTeX3D'></span>

<h3>Description</h3>

<p>Draw boxes, axes and other text outside the data using TeX strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTitleTeX3D(
  main = NULL,
  sub = NULL,
  xlab = NULL,
  ylab = NULL,
  zlab = NULL,
  line = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTitleTeX3D_+3A_main">main</code></td>
<td>
<p>The main title for the plot.</p>
</td></tr>
<tr><td><code id="plotTitleTeX3D_+3A_sub">sub</code></td>
<td>
<p>The subtitle for the plot.</p>
</td></tr>
<tr><td><code id="plotTitleTeX3D_+3A_xlab">xlab</code></td>
<td>
<p>The axis labels for the plot .</p>
</td></tr>
<tr><td><code id="plotTitleTeX3D_+3A_ylab">ylab</code></td>
<td>
<p>The axis labels for the plot .</p>
</td></tr>
<tr><td><code id="plotTitleTeX3D_+3A_zlab">zlab</code></td>
<td>
<p>The axis labels for the plot .</p>
</td></tr>
<tr><td><code id="plotTitleTeX3D_+3A_line">line</code></td>
<td>
<p>The &ldquo;line&rdquo; of the plot margin to draw the label on.</p>
</td></tr>
<tr><td><code id="plotTitleTeX3D_+3A_...">...</code></td>
<td>
<p>Additional parameters which are passed to <code><a href="#topic+plotMTeX3D">plotMTeX3D</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rectangular prism holding the 3D plot has 12 edges.  They are identified
using 3 character strings.  The first character (<code style="white-space: pre;">&#8288;x', &#8288;</code>y', or <code style="white-space: pre;">&#8288;z') selects the direction of the axis.  The next two characters are each &#8288;</code>-' or <code style="white-space: pre;">&#8288;+', selecting the lower or upper end of one of the other coordinates.  If only one or two characters are given, the remaining characters default to &#8288;</code>-'.
For example <code>edge = 'x+'</code> draws an x-axis at the high level of y and the
low level of z.
</p>
<p>By default, <code>axes3d</code> uses the <code><a href="rgl.html#topic+bbox3d">bbox3d</a></code> function to draw the axes.
The labels will move so that they do not obscure the data.  Alternatively,
a vector of arguments as described above may be used, in which case
fixed axes are drawn using <code>axis3d</code>.
</p>
<p>If <code>pos</code> is a numeric vector of length 3, <code>edge</code> determines
the direction of the axis and the tick marks, and the values of the
other two coordinates in <code>pos</code> determine the position.  See the
examples.
</p>


<h3>Value</h3>

<p>The object IDs of objects added to the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ini3D(argsPlot3d = list(xlim = c(0, 2), ylim = c(0, 2), zlim = c(0, 2)))
plotTitleTeX3D(main = "\\LaTeX", sub = "subtitle $\\alpha$",
               xlab = "$x^1_2$", ylab = "$\\beta$", zlab = "$x\\cdot y$")
finalize3D()

## End(Not run)
</code></pre>

<hr>
<h2 id='pngSize'>To size of the png file.</h2><span id='topic+pngSize'></span>

<h3>Description</h3>

<p>To size of the png file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pngSize(png)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pngSize_+3A_png">png</code></td>
<td>
<p>Png file name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with width and height.
</p>

<hr>
<h2 id='saveView'>Help function to save the view angle for the RGL 3D plot</h2><span id='topic+saveView'></span>

<h3>Description</h3>

<p>Help function to save the view angle for the RGL 3D plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveView(fname = "view.RData", overwrite = FALSE, print = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveView_+3A_fname">fname</code></td>
<td>
<p>The file name of the view.</p>
</td></tr>
<tr><td><code id="saveView_+3A_overwrite">overwrite</code></td>
<td>
<p>Overwrite existing file.</p>
</td></tr>
<tr><td><code id="saveView_+3A_print">print</code></td>
<td>
<p>Print the view so can be copied to R code (no file is saved).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL (invisible).
</p>


<h3>Note</h3>

<p>Only save if the file name don't exists.
</p>


<h3>Author(s)</h3>

<p>Lars Relund <a href="mailto:lars@relund.dk">lars@relund.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
view &lt;- matrix( c(-0.412063330411911, -0.228006735444069, 0.882166087627411, 0,
0.910147845745087, -0.0574885793030262, 0.410274744033813, 0, -0.042830865830183,
0.97196090221405, 0.231208890676498, 0, 0, 0, 0, 1), nc = 4)

loadView(v = view)
A &lt;- matrix( c(3, 2, 5, 2, 1, 1, 1, 1, 3, 5, 2, 4), nc = 3, byrow = TRUE)
b &lt;- c(55, 26, 30, 57)
obj &lt;- c(20, 10, 15)
plotPolytope(A, b, plotOptimum = TRUE, obj = obj, labels = "coord")

# Try to modify the angle in the RGL window
saveView(print = TRUE)  # get the view angle to insert into R code

</code></pre>

<hr>
<h2 id='slices'>Find all corner points in the slices define for each fixed integer combination.</h2><span id='topic+slices'></span>

<h3>Description</h3>

<p>Find all corner points in the slices define for each fixed integer combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slices(
  A,
  b,
  type = rep("c", ncol(A)),
  nonneg = rep(TRUE, ncol(A)),
  collapse = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slices_+3A_a">A</code></td>
<td>
<p>The constraint matrix.</p>
</td></tr>
<tr><td><code id="slices_+3A_b">b</code></td>
<td>
<p>Right hand side.</p>
</td></tr>
<tr><td><code id="slices_+3A_type">type</code></td>
<td>
<p>A character vector of same length as number of variables. If
entry k is 'i' variable <code class="reqn">k</code> must be integer and if 'c' continuous.</p>
</td></tr>
<tr><td><code id="slices_+3A_nonneg">nonneg</code></td>
<td>
<p>A boolean vector of same length as number of variables. If
entry k is TRUE then variable k must be non-negative.</p>
</td></tr>
<tr><td><code id="slices_+3A_collapse">collapse</code></td>
<td>
<p>Collapse list to a data frame with unique points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the corner points (one entry for each slice).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix( c(3, -2, 1,2, 4, -2,-3, 2, 1), nc = 3, byrow = TRUE)
b &lt;- c(10,12,3)
slices(A, b, type=c("i","c","i"))

A &lt;- matrix(c(9,10,2,4,-3,2), ncol = 2, byrow = TRUE)
b &lt;- c(90,27,3)
slices(A, b, type=c("c","i"), collapse = TRUE)
</code></pre>

<hr>
<h2 id='texToPng'>Convert LaTeX to a png file</h2><span id='topic+texToPng'></span>

<h3>Description</h3>

<p>Convert LaTeX to a png file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>texToPng(
  tex,
  width = NULL,
  height = NULL,
  dpi = 72,
  viewPng = FALSE,
  fontsize = 12,
  calcM = FALSE,
  crop = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="texToPng_+3A_tex">tex</code></td>
<td>
<p>TeX string. Remember to escape backslash with \.</p>
</td></tr>
<tr><td><code id="texToPng_+3A_width">width</code></td>
<td>
<p>Width of the png.</p>
</td></tr>
<tr><td><code id="texToPng_+3A_height">height</code></td>
<td>
<p>Height of the png (<code>width</code> are ignored).</p>
</td></tr>
<tr><td><code id="texToPng_+3A_dpi">dpi</code></td>
<td>
<p>Dpi of the png. Not used if <code>width</code> or <code>height</code> are specified.</p>
</td></tr>
<tr><td><code id="texToPng_+3A_viewpng">viewPng</code></td>
<td>
<p>View the result in the plots window.</p>
</td></tr>
<tr><td><code id="texToPng_+3A_fontsize">fontsize</code></td>
<td>
<p>Front size used in the LaTeX document.</p>
</td></tr>
<tr><td><code id="texToPng_+3A_calcm">calcM</code></td>
<td>
<p>Estimate 1 em in pixels in the resulting png.</p>
</td></tr>
<tr><td><code id="texToPng_+3A_crop">crop</code></td>
<td>
<p>Call command line program <code>pdfcrop</code> (must be installed).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The filename of the png or a list if <code>calcM = TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tex &lt;- "$\\mathbb{R}_{\\geqq}$"
texToPng(tex, viewPng = TRUE)
texToPng(tex, fontsize = 20, viewPng = TRUE)
texToPng(tex, height = 50, fontsize = 10, viewPng = TRUE)
texToPng(tex, height = 50, fontsize = 50, viewPng = TRUE)
tex &lt;- "MMM"
texToPng(tex, dpi=72, calcM = TRUE)
texToPng(tex, width = 100, calcM = TRUE)
f &lt;- texToPng(tex, dpi=300)
pngSize(f)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
