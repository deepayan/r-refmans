<!DOCTYPE html><html><head><title>Help for package RWDataPlyr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RWDataPlyr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RWDataPlyr-package'><p>RWDataPlyr: Read and Manipulate Data from 'RiverWare'</p></a></li>
<li><a href='#as_rwd_agg'><p>Coerce lists, matrices, and data.frames to RiverWare data aggregators</p></a></li>
<li><a href='#createSlotAggList'><p>Creates a list for use by <code>getDataForAllScens</code>.</p></a></li>
<li><a href='#getArrayPctl'><p>Get values at the input exceedance levels for the entire array by date</p></a></li>
<li><a href='#getArrayThresholdExceedance'><p>Get values at the input exceedance levels for the entire array by date</p></a></li>
<li><a href='#getDataForAllScens'><p>Get and aggregate data from an rdf file(s)</p></a></li>
<li><a href='#getTraceAvg'><p>Get the average annual value for each trace</p></a></li>
<li><a href='#getTraceMax'><p>Get the annual maximum for each trace</p></a></li>
<li><a href='#getTraceMin'><p>Get the annual minimum for each trace</p></a></li>
<li><a href='#getTraceMonthVal'><p>Get values that meet a month requirement</p></a></li>
<li><a href='#getTraceSum'><p>Get the annual sum for each trace</p></a></li>
<li><a href='#is_rdf'><p>Test if the object is an rdf</p></a></li>
<li><a href='#is_rwd_agg'><p>Test if the object is a rwd_agg</p></a></li>
<li><a href='#is_slot_agg_list'><p>Test if the object is a slot_agg_list</p></a></li>
<li><a href='#keyRdf'><p>Example rdf file with monthly data.</p></a></li>
<li><a href='#rbind.rwd_agg'><p>Combine RiverWare data aggregators</p></a></li>
<li><a href='#rdf_aggregate'><p>Aggregate RiverWare output for one or more scenarios</p></a></li>
<li><a href='#rdf_get_slot'><p>Get a slot out of an rdf object</p></a></li>
<li><a href='#rdf_get_timespan'><p>Returns the simulation timespan from an rdf</p></a></li>
<li><a href='#rdf_slot_names'><p>Returns all slots contained in an rdf file.</p></a></li>
<li><a href='#rdf_to_rwtbl'><p>Convert an rdf to a tibble</p></a></li>
<li><a href='#rdfSlotToXTS'><p>Get one slot out of an rdf list and put it in an XTS object</p></a></li>
<li><a href='#read_rw_csv'><p>Read RiverWare/RiverSMART produced csv files</p></a></li>
<li><a href='#read_rwd_agg'><p>Read in a rwd_agg file</p></a></li>
<li><a href='#read.rdf'><p>Read an rdf file into R.</p></a></li>
<li><a href='#rw_scen_gen_names'><p>Create a vector of scenarios from different dimensions</p></a></li>
<li><a href='#rwd_agg'><p>Class to specify how to aggregate RiverWare data</p></a></li>
<li><a href='#rwd_agg_template'><p>Create a <code>rwd_agg</code> template</p></a></li>
<li><a href='#rwslot_annual_sum'><p>Simple aggregation functions for monthly matrix data</p></a></li>
<li><a href='#rwtbl_get_scen_folder'><p>Map a scenario name to the original scenario folder</p></a></li>
<li><a href='#rwtbl_slot_names'><p>List the slot names in a tbl_df</p></a></li>
<li><a href='#rwtbl_var_to_slot'><p>Map a variable name to the RiverWare slot name</p></a></li>
<li><a href='#scen_data'><p>Example aggregated scenario data</p></a></li>
<li><a href='#slot_agg_list'><p>A class to control how RiverWare data are aggregated</p></a></li>
<li><a href='#sysRdf'><p>Example rdf file with annual data.</p></a></li>
<li><a href='#ym_get_wateryear'><p>Get the water year from a year-month (yearmon) value</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.6.4</td>
</tr>
<tr>
<td>Title:</td>
<td>Read and Manipulate Data from 'RiverWare'</td>
</tr>
<tr>
<td>Description:</td>
<td>A tool to read and manipulate data generated from 'RiverWare'(TM) 
    <a href="http://www.riverware.org/">http://www.riverware.org/</a> simulations. 'RiverWare' and 'RiverSMART' 
    generate data in "rdf", "csv", and "nc" format. This package provides an 
    interface to read, aggregate, and summarize data from one or more 
    simulations in a 'dplyr' pipeline.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/BoulderCodeHub/RWDataPlyr">https://github.com/BoulderCodeHub/RWDataPlyr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/BoulderCodeHub/RWDataPlyr/issues">https://github.com/BoulderCodeHub/RWDataPlyr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.10.0), dplyr (&ge; 0.7.0), methods, stats,
tibble, tidyr, tools, utils, feather, xts, zoo, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bookdown, knitr, rmarkdown, testthat, covr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/publicdomain/zero/1.0/legalcode">CC0</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>This software is in the public domain because it contains
materials that originally came from the U.S. Bureau of
Reclamation, an agency of the U.S. Department of Interior.</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-04-16 22:05:45 UTC; RAButler</td>
</tr>
<tr>
<td>Author:</td>
<td>Alan Butler [aut, cre],
  Cameron Bracken [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alan Butler &lt;rabutler@usbr.gov&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-04-17 08:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='RWDataPlyr-package'>RWDataPlyr: Read and Manipulate Data from 'RiverWare'</h2><span id='topic+RWDataPlyr'></span><span id='topic+RWDataPlyr-package'></span>

<h3>Description</h3>

<p>A tool to read and manipulate data generated from 'RiverWare'(TM) 
&lt;http://www.riverware.org/&gt; simulations. 'RiverWare' and 'RiverSMART' 
generate data in &quot;rdf&quot;, &quot;csv&quot;, and &quot;nc&quot; format. This package provides an 
interface to read, aggregate, and summarize data from one or more 
simulations in a 'dplyr' pipeline.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Alan Butler <a href="mailto:rabutler@usbr.gov">rabutler@usbr.gov</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Cameron Bracken
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/BoulderCodeHub/RWDataPlyr">https://github.com/BoulderCodeHub/RWDataPlyr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/BoulderCodeHub/RWDataPlyr/issues">https://github.com/BoulderCodeHub/RWDataPlyr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='as_rwd_agg'>Coerce lists, matrices, and data.frames to RiverWare data aggregators</h2><span id='topic+as_rwd_agg'></span><span id='topic+as_rwd_agg.data.frame'></span><span id='topic+as_rwd_agg.list'></span><span id='topic+as_rwd_agg.matrix'></span><span id='topic+as_rwd_agg.default'></span><span id='topic+as.rwd_agg'></span>

<h3>Description</h3>

<p>S3 generic for coercing from lists, matrices, and data.frames to <a href="#topic+rwd_agg">rwd_agg</a>
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_rwd_agg(x, ...)

## S3 method for class 'data.frame'
as_rwd_agg(x, ...)

## S3 method for class 'list'
as_rwd_agg(x, ...)

## S3 method for class 'matrix'
as_rwd_agg(x, ...)

## Default S3 method:
as_rwd_agg(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_rwd_agg_+3A_x">x</code></td>
<td>
<p>A list. Each element of the list must have the same length.</p>
</td></tr>
<tr><td><code id="as_rwd_agg_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to individual methods.</p>
</td></tr>
</table>

<hr>
<h2 id='createSlotAggList'>Creates a list for use by <code><a href="#topic+getDataForAllScens">getDataForAllScens</a></code>.</h2><span id='topic+createSlotAggList'></span>

<h3>Description</h3>

<p>Deprecated: please use <code><a href="#topic+slot_agg_list">slot_agg_list()</a></code> instead, which returns the same
list, but now as a &quot;slot_agg_list&quot; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createSlotAggList(iData)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createSlotAggList_+3A_idata">iData</code></td>
<td>
<p>Either an N x 4 character matrix or a character with an absolute
or relative path to a csv file.</p>
</td></tr>
</table>

<hr>
<h2 id='getArrayPctl'>Get values at the input exceedance levels for the entire array by date</h2><span id='topic+getArrayPctl'></span>

<h3>Description</h3>

<p>Get values at the input exceedance levels for the entire array by date
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getArrayPctl(rdfXTS, pctlLevels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getArrayPctl_+3A_rdfxts">rdfXTS</code></td>
<td>
<p>Object returned by <code><a href="#topic+rdfSlotToXTS">rdfSlotToXTS</a></code></p>
</td></tr>
<tr><td><code id="getArrayPctl_+3A_pctllevels">pctlLevels</code></td>
<td>
<p>Decimal value(s) for the desired exceedance levels with
0.0&lt;value&lt;1.0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an XTS object with the selected slot data at the input exceedance
levels
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pe &lt;- RWDataPlyr:::rdfSlotToXTS(keyRdf, 'Mead.Pool Elevation')
pe105090 &lt;- RWDataPlyr:::getArrayPctl(pe, c(0.1, 0.5, 0.9))

</code></pre>

<hr>
<h2 id='getArrayThresholdExceedance'>Get values at the input exceedance levels for the entire array by date</h2><span id='topic+getArrayThresholdExceedance'></span>

<h3>Description</h3>

<p>Get values at the input exceedance levels for the entire array by date
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getArrayThresholdExceedance(rdfXTS, valueIn, comparison)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getArrayThresholdExceedance_+3A_rdfxts">rdfXTS</code></td>
<td>
<p>XTS object returned by <code><a href="#topic+rdfSlotToXTS">rdfSlotToXTS</a></code></p>
</td></tr>
<tr><td><code id="getArrayThresholdExceedance_+3A_valuein">valueIn</code></td>
<td>
<p>Numeric value for the desired threshold to compare the data
against</p>
</td></tr>
<tr><td><code id="getArrayThresholdExceedance_+3A_comparison">comparison</code></td>
<td>
<p>String 'GT' or 'LT' for a greater-than or less-than
comparison</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an XTS object with the frequency in which the array of traces exceed
a threshold
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pe &lt;- RWDataPlyr:::rdfSlotToXTS(keyRdf, 'Mead.Pool Elevation')
peLT3575 &lt;- RWDataPlyr:::getArrayThresholdExceedance(pe, 3575, 'LT')

</code></pre>

<hr>
<h2 id='getDataForAllScens'>Get and aggregate data from an rdf file(s)</h2><span id='topic+getDataForAllScens'></span>

<h3>Description</h3>

<p><code>getDataForAllScens()</code> gets slot data from multiple rdf files and/or multiple
scenarios, aggregates it, and saves it as a data.frame. The slot data can be
aggregated in multiple ways (see <a href="#topic+slot_agg_list">slot_agg_list</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDataForAllScens(
  scenFolders,
  scenNames,
  slotAggList,
  scenPath,
  oFile = NULL,
  retFile = NULL,
  findAllSlots = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDataForAllScens_+3A_scenfolders">scenFolders</code></td>
<td>
<p>A string vector containing the folder names (scenarios)
that the rdf files are saved in.</p>
</td></tr>
<tr><td><code id="getDataForAllScens_+3A_scennames">scenNames</code></td>
<td>
<p>A string vector containing the scenario names.  This should
be the same length as <code>scenFolders</code>. The scenario names are used as
attributes to the data in the <code>Scenario</code> column.</p>
</td></tr>
<tr><td><code id="getDataForAllScens_+3A_slotagglist">slotAggList</code></td>
<td>
<p>The slot aggregation list. Either an object of class
<a href="#topic+slot_agg_list">slot_agg_list</a> or a &quot;special&quot; list with the keyword <code>"all"</code>. If, it is
a <a href="#topic+slot_agg_list">slot_agg_list</a>, see that documentation for how to control the
aggregation methods used in this function. If all of the slots in an
entire rdf are desired, use a list of lists with each entry containing an
rdf file and the keyword <code>"all"</code> for the slots, e.g.,
<code>list(list(rdf = 'KeySlots.rdf',slots = 'all'))</code>. If this option is used,
the function will return raw monthly, or annual data, i.e., no aggregation
methods will be applied to the data in the rdf file.</p>
</td></tr>
<tr><td><code id="getDataForAllScens_+3A_scenpath">scenPath</code></td>
<td>
<p>An absolute or relative path to the folder containing
<code>scenFolders</code>.</p>
</td></tr>
<tr><td><code id="getDataForAllScens_+3A_ofile">oFile</code></td>
<td>
<p>If not <code>NULL</code>, then an absolute or relative path with the file
name of the location the table will be saved to. Valid file types are
.csv, .txt, or .feather.</p>
</td></tr>
<tr><td><code id="getDataForAllScens_+3A_retfile">retFile</code></td>
<td>
<p>Deprecated. Data are always returned invisibly.</p>
</td></tr>
<tr><td><code id="getDataForAllScens_+3A_findallslots">findAllSlots</code></td>
<td>
<p>Boolean; if <code>TRUE</code> (default), then the function will
abort if it cannot find a particular slot. If <code>FALSE</code>, then the
function will continue, even if a slot cannot be found. If a slot is not
found, then the function will return <code>-99</code> for the Trace, Year, and Value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame returned invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slot_agg_list">slot_agg_list()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get a specified set of slots and apply some aggregation method to them
# get the data from two scenarios
scenFolders &lt;- c('ISM1988_2014,2007Dems,IG,Most', 
  'ISM1988_2014,2007Dems,IG,2002') 
# slotAggTable.csv lists the slots to obtain, and the aggregation method to 
# apply to them
slotAggList &lt;- slot_agg_list(
  system.file('extdata','SlotAggTable.csv',package = 'RWDataPlyr')
)
scenPath &lt;- system.file('extdata','Scenario/',package = 'RWDataPlyr')
# expect Deprecated warning
testthat::expect_warning(
  keyData &lt;- getDataForAllScens(
    scenFolders, 
    scenNames = scenFolders, 
    slotAggList = slotAggList, 
    scenPath = scenPath
  )
)

# get all of the data from the KeySlots rdf file
scenFolders &lt;- scenFolders[1] # only one scenario
slotAggList &lt;- list(list(rdf = 'KeySlots.rdf', slots = 'all'))
# will return monthly data for all slots in KeySlots.rdf
# expect Deprecated warning
testthat::expect_warning(
  allData &lt;- getDataForAllScens(
    scenFolders, 
    scenNames = scenFolders, 
    slotAggList = slotAggList, 
    scenPath = scenPath
  )
)

</code></pre>

<hr>
<h2 id='getTraceAvg'>Get the average annual value for each trace</h2><span id='topic+getTraceAvg'></span>

<h3>Description</h3>

<p>Get the average annual value for each trace
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTraceAvg(rdfXTS, yearType)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTraceAvg_+3A_rdfxts">rdfXTS</code></td>
<td>
<p>XTS object returned by <code><a href="#topic+rdfSlotToXTS">rdfSlotToXTS</a></code></p>
</td></tr>
<tr><td><code id="getTraceAvg_+3A_yeartype">yearType</code></td>
<td>
<p>String 'CY' or 'WY' denoting a Calendar Year (Jan-1 to
Dec-31) or Water Year (Oct-1 to Sep-30)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an XTS object with the selected slot annual average
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pe &lt;- RWDataPlyr:::rdfSlotToXTS(keyRdf, 'Mead.Pool Elevation')
peWY &lt;- RWDataPlyr:::getTraceAvg(pe, 'WY')

</code></pre>

<hr>
<h2 id='getTraceMax'>Get the annual maximum for each trace</h2><span id='topic+getTraceMax'></span>

<h3>Description</h3>

<p>Get the annual maximum for each trace
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTraceMax(rdfXTS, yearType)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTraceMax_+3A_rdfxts">rdfXTS</code></td>
<td>
<p>XTS object returned by <code><a href="#topic+rdfSlotToXTS">rdfSlotToXTS</a></code></p>
</td></tr>
<tr><td><code id="getTraceMax_+3A_yeartype">yearType</code></td>
<td>
<p>String 'CY' or 'WY' denoting a Calendar Year (Jan-1 to
Dec-31) or Water Year (Oct-1 to Sep-30)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an XTS object with the selected slot annual maximum
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pe &lt;- RWDataPlyr:::rdfSlotToXTS(keyRdf, 'Mead.Pool Elevation')
peWY &lt;- RWDataPlyr:::getTraceMax(pe, 'WY')

</code></pre>

<hr>
<h2 id='getTraceMin'>Get the annual minimum for each trace</h2><span id='topic+getTraceMin'></span>

<h3>Description</h3>

<p>Get the annual minimum for each trace
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTraceMin(rdfXTS, yearType)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTraceMin_+3A_rdfxts">rdfXTS</code></td>
<td>
<p>XTS object returned by <code><a href="#topic+rdfSlotToXTS">rdfSlotToXTS</a></code></p>
</td></tr>
<tr><td><code id="getTraceMin_+3A_yeartype">yearType</code></td>
<td>
<p>String 'CY' or 'WY' denoting a Calendar Year (Jan-1 to
Dec-31) or Water Year (Oct-1 to Sep-30)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an XTS object with the selected slot annual minimum
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pe &lt;- RWDataPlyr:::rdfSlotToXTS(keyRdf, 'Mead.Pool Elevation')
peWY &lt;- RWDataPlyr:::getTraceMin(pe, 'WY')

</code></pre>

<hr>
<h2 id='getTraceMonthVal'>Get values that meet a month requirement</h2><span id='topic+getTraceMonthVal'></span>

<h3>Description</h3>

<p>Get values that meet a month requirement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTraceMonthVal(rdfXTS, month)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTraceMonthVal_+3A_rdfxts">rdfXTS</code></td>
<td>
<p>XTS object returned by <code><a href="#topic+rdfSlotToXTS">rdfSlotToXTS</a></code></p>
</td></tr>
<tr><td><code id="getTraceMonthVal_+3A_month">month</code></td>
<td>
<p>Integer month(s) as a single value or a vector with 1&lt;=month&lt;=12</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an XTS object with the selected slot data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pe &lt;- RWDataPlyr:::rdfSlotToXTS(keyRdf, 'Mead.Pool Elevation')
peJanFeb &lt;- RWDataPlyr:::getTraceMonthVal(pe, c(1, 2))

</code></pre>

<hr>
<h2 id='getTraceSum'>Get the annual sum for each trace</h2><span id='topic+getTraceSum'></span>

<h3>Description</h3>

<p>Get the annual sum for each trace
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTraceSum(rdfXTS, yearType)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTraceSum_+3A_rdfxts">rdfXTS</code></td>
<td>
<p>XTS object returned by <code><a href="#topic+rdfSlotToXTS">rdfSlotToXTS</a></code></p>
</td></tr>
<tr><td><code id="getTraceSum_+3A_yeartype">yearType</code></td>
<td>
<p>String 'CY' or 'WY' denoting a Calendar Year (Jan-1 to
Dec-31) or Water Year (Oct-1 to Sep-30)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an XTS object with the selected slot annual sum
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pe &lt;- RWDataPlyr:::rdfSlotToXTS(keyRdf, 'Mead.Pool Elevation')
peWY &lt;- RWDataPlyr:::getTraceSum(pe, 'WY')

</code></pre>

<hr>
<h2 id='is_rdf'>Test if the object is an rdf</h2><span id='topic+is_rdf'></span><span id='topic+is.rdf'></span>

<h3>Description</h3>

<p>Test if the object is an rdf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_rdf(x)

is.rdf(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_rdf_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the object inherits from the <code>rdf</code> class.
</p>

<hr>
<h2 id='is_rwd_agg'>Test if the object is a rwd_agg</h2><span id='topic+is_rwd_agg'></span><span id='topic+is.rwd_agg'></span>

<h3>Description</h3>

<p>Test if the object is a rwd_agg
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_rwd_agg(x)

is.rwd_agg(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_rwd_agg_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the object inherits from the <code>rwd_agg</code> class.
</p>

<hr>
<h2 id='is_slot_agg_list'>Test if the object is a slot_agg_list</h2><span id='topic+is_slot_agg_list'></span><span id='topic+is.slot_agg_list'></span>

<h3>Description</h3>

<p>Test if the object is a slot_agg_list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_slot_agg_list(x)

is.slot_agg_list(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_slot_agg_list_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the object inherits from the <code>slot_agg_list</code> class.
</p>

<hr>
<h2 id='keyRdf'>Example rdf file with monthly data.</h2><span id='topic+keyRdf'></span>

<h3>Description</h3>

<p>An example of an rdf file that has already been read into R via
<code><a href="#topic+read.rdf">read.rdf()</a></code>. This example contains 39 slots, at the monthly
timestep for 11 years and 25 runs. Slots include pool elevation,
flow, and flags. Use this with <code><a href="#topic+rdf_slot_names">rdf_slot_names()</a></code> or
<code><a href="#topic+rdf_get_slot">rdf_get_slot()</a></code> to use the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keyRdf
</code></pre>


<h3>Format</h3>

<p>A multi level list. <code>keyRdf$meta</code> provides a description
of the RiverWare run used to generate this data.
</p>


<h3>Source</h3>

<p>Bureau of Reclamation, 2016
</p>

<hr>
<h2 id='rbind.rwd_agg'>Combine RiverWare data aggregators</h2><span id='topic+rbind.rwd_agg'></span><span id='topic+cbind.rwd_agg'></span>

<h3>Description</h3>

<p>Take a sequence of <code>rwd_agg</code> arguments (or vector, matrix, or data.frames)
and combine by rows. If the objects are not <code>rwd_agg</code> objects they will be
combined through the default <code>rbind()</code> method, and then verified that they
meet all constraints to be a valid <code>rwd_agg</code> object. <code>cbind()</code> will fail for
<code>rwd_agg</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rwd_agg'
rbind(..., deparse.level = 1)

## S3 method for class 'rwd_agg'
cbind(..., deparse.level = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind.rwd_agg_+3A_...">...</code></td>
<td>
<p>(generalized) vectors or matrices.  These can be given as named
arguments.  Other <span class="rlang"><b>R</b></span> objects may be coerced as appropriate, or S4
methods may be used: see sections &lsquo;Details&rsquo; and
&lsquo;Value&rsquo;.  (For the <code>"data.frame"</code> method of <code>cbind</code>
these can be further arguments to <code><a href="base.html#topic+data.frame">data.frame</a></code> such as
<code>stringsAsFactors</code>.)</p>
</td></tr>
<tr><td><code id="rbind.rwd_agg_+3A_deparse.level">deparse.level</code></td>
<td>
<p>integer controlling the construction of labels in
the case of non-matrix-like arguments (for the default method):<br />
<code>deparse.level = 0</code> constructs no labels; the default,<br />
<code>deparse.level = 1 or 2</code> constructs labels from the argument
names, see the &lsquo;Value&rsquo; section below.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
ra1 &lt;- rwd_agg(data.frame(
  file = "KeySlots.rdf",
  slot = "Powell.Pool Elevation",
  period = "wy",
  summary = "min",
  eval = "&lt;",
  t_s = 3550,
  variable = "powellLt3550",
  stringsAsFactors = FALSE
))

ra2 &lt;- read_rwd_agg(
  system.file(
    "extdata/rwd_agg_files/passing_aggs.csv", 
    package = "RWDataPlyr"
  )
)

rbind(ra1, ra2)

## Not run: 
# will fail because you cannot have repeating variable names
rbind(ra1, ra1)

# will also fail
cbind(ra1, ra2)

## End(Not run)

</code></pre>

<hr>
<h2 id='rdf_aggregate'>Aggregate RiverWare output for one or more scenarios</h2><span id='topic+rdf_aggregate'></span><span id='topic+rw_scen_aggregate'></span>

<h3>Description</h3>

<p>Process the user specified <code>rwd_agg</code> object for one or more scenarios to
aggregate and summarize RiverWare output data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdf_aggregate(
  agg,
  rdf_dir = ".",
  scenario = NULL,
  keep_cols = FALSE,
  nans_are = "0",
  find_all_slots = TRUE,
  cpp = TRUE,
  verbose = TRUE
)

rw_scen_aggregate(
  scenarios,
  agg,
  scen_dir = ".",
  nans_are = "0",
  keep_cols = FALSE,
  file = NULL,
  scen_names = NULL,
  find_all_slots = TRUE,
  cpp = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdf_aggregate_+3A_agg">agg</code></td>
<td>
<p>A <a href="#topic+rwd_agg">rwd_agg</a> object specifying the rdfs, slots, and
aggregation methods to use.</p>
</td></tr>
<tr><td><code id="rdf_aggregate_+3A_rdf_dir">rdf_dir</code></td>
<td>
<p>The top level directory that contains the rdf files. See
<strong>Directory Structure</strong>.</p>
</td></tr>
<tr><td><code id="rdf_aggregate_+3A_scenario">scenario</code></td>
<td>
<p>An optional parameter, that if it is not <code>NULL</code> or <code>NA</code>
(default) will be added to the tibble as another variable. Coerced to a
character if it is not already a character.</p>
</td></tr>
<tr><td><code id="rdf_aggregate_+3A_keep_cols">keep_cols</code></td>
<td>
<p>Either boolean, or a character vector of column names to
keep in the returned tibble. The values of <code>keep_cols</code> work as follows:
</p>

<ul>
<li> <p><code>FALSE</code> (default) only includes the defaults columns:
<code>TraceNumber</code>, <code>ObjectSlot</code>, and <code>Value</code>. <code>Scenario</code> is also returned if
<code>scenario</code> is specified.
</p>
</li>
<li> <p><code>TRUE</code>, all columns are returned.
</p>
</li>
<li><p> A character vector, e.g., <code>c("ObjectName", "Units")</code>, allows the user to
include other columns that are not always required, in addition to the
&quot;default&quot; set of columns. If any of the values in <code>keep_cols</code> are not
found, a warning will post, but all other columns will be returned.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rdf_aggregate_+3A_nans_are">nans_are</code></td>
<td>
<p>Either &quot;0&quot; or &quot;error&quot;. If &quot;0&quot;, then <code>NaN</code>s in the rwtbl are
treated as 0s. If &quot;error&quot;, then any <code>NaN</code>s will cause an error in this
function.</p>
</td></tr>
<tr><td><code id="rdf_aggregate_+3A_find_all_slots">find_all_slots</code></td>
<td>
<p>Boolean; if <code>TRUE</code> (default), then the function will
abort if it cannot find a particular slot. If <code>FALSE</code>, then the function
will continue, even if a slot cannot be found. If a slot is not found,
then the function will return <code>-99</code> for the Trace, and <code>NaN</code> for Year, and
Value.</p>
</td></tr>
<tr><td><code id="rdf_aggregate_+3A_cpp">cpp</code></td>
<td>
<p>Boolean; if <code>TRUE</code> (default), then use <a href="#topic+rdf_to_rwtbl2">rdf_to_rwtbl2</a>, which
relies on C++, otherwise, use original <a href="#topic+rdf_to_rwtbl">rdf_to_rwtbl</a> function.</p>
</td></tr>
<tr><td><code id="rdf_aggregate_+3A_verbose">verbose</code></td>
<td>
<p>Boolean; if <code>TRUE</code> (default), then print out status of
processing the scenario(s) and the slots in each scenario.</p>
</td></tr>
<tr><td><code id="rdf_aggregate_+3A_scenarios">scenarios</code></td>
<td>
<p>A character vector of scenario folders. This is usually a
vector of folder names, where each folder name contains one scenario worth
of data. <code>scenarios</code> can be named or unnamed. The names are used as the
scenario name in the returned <code>tbl_df</code>. Scenario names can also be
specified through the <code>scen_names</code> argument. If <code>scen_names</code> is specified,
<code>scenarios</code> should not already have names. If <code>scen_names</code> is not specified
and, <code>scenarios</code> is not already named, then the scenario folders will also
be used as the scenario names. See <strong>Directory Structure</strong>.</p>
</td></tr>
<tr><td><code id="rdf_aggregate_+3A_scen_dir">scen_dir</code></td>
<td>
<p>File path to the directory that contains the scenario
folders. <strong>Directory Structure</strong>.</p>
</td></tr>
<tr><td><code id="rdf_aggregate_+3A_file">file</code></td>
<td>
<p>Optionally save the <code>tbl_df</code> of aggregated scenario data as a
.txt, .csv, or .feather file. If <code>file</code> is specified, then the data are
saved in the specified output format.</p>
</td></tr>
<tr><td><code id="rdf_aggregate_+3A_scen_names">scen_names</code></td>
<td>
<p>An alternative way to specify scenario names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rdf_aggregate()</code> aggregates a single scenario of data by processing a
<a href="#topic+rwd_agg">rwd_agg</a> object.
</p>
<p>In both cases, the user specifies the <a href="#topic+rwd_agg">rwd_agg</a>, which
determines the slots that are aggregated, and how they are aggregated. See
<a href="#topic+rwd_agg">rwd_agg</a> for more details on how it should be specified.
</p>
<p>See the <strong>Directory Structure</strong> section for how to specify <code>scenarios</code>,
<code>scen_dir</code>, and <code>rdf_dir</code>.
</p>
<p><code>rw_scen_aggregate()</code> aggregates multiple scenarios of data. It processes the
<a href="#topic+rwd_agg">rwd_agg</a> object (<code>agg</code>) for each single scenario, and then binds all of the
individual scenario data together into a single <code>tbl_df</code>.
</p>


<h3>Value</h3>

<p>A <code>tbl_df</code> containing all aggregated and summarized data for all of
the specified <code>scenarios</code>.
</p>


<h3>Directory Structure</h3>

<p>RiverWare and RiverSMART typically write data into an expected directory
structure. The below shows an example directory structure and corresponding
variable names for <code>rw_scen_aggregate()</code> and <code>rdf_aggregate()</code>. (In the
example below, C:/user/crss/CRSS.Jan2017/Scenario is the more complete
directory setup for the data included in <code>system.file("extdata/Scenario/")</code>.)
</p>
<pre>
C:/user/crss
|
|- CRSS.Jan2017
|    - model
|    - ruleset
|    - Scenario
|         - ISM1988_2014,2007Dems,IG,Most
|         - ISM1988_2014,2007Dems,IG,2002 
|    - ...
|- CRSS.Jan2018
|    - model
|    - ... (same general setup as CRSS.Jan2017)
</pre>
<p>To get one scenario's data, <code>rdf_aggregate()</code> can be called with <code>rdf_dir</code>
set to &quot;C:/user/crss/CRSS.Jan2017/Scenario/ISM1988_2014,2007Dems,IG,Most&quot;.
(<code>scenario</code> can optionally be specified to git a scenario name.)
</p>
<p>To aggregate multiple scenarios of data together, <code>rw_scen_aggregate()</code>
should be called with <code>scen_dir</code> set to &quot;C:/user/CRSS/CRSS.Jan2017/Scenario&quot;
and <code>scenarios</code> set to
<code>c("ISM1988_2014,2007Dems,IG,Most", "ISM1988_2014,2007Dems,IG,2002")</code>.
(Optionally, <code>scenarios</code> can be named, or <code>scen_names</code> specified to use
scenario names that are different from the above scenario folders.)
</p>
<p>Finally, to aggregate scenario data from both CRSS.Jan2017 and CRSS.Jan2018,
<code>rw_scen_aggregate()</code> should be called with <code>scen_dir</code> set to
&quot;C:/users/crss/&quot;. <code>scenarios</code> can then be set to
<code>c("CRSS.Jan2017/Scenario/ISM1988_2014,2007Dems,IG,Most","CRSS.Jan2018/Scenario/ISM1988_2014,2007Dems,IG,Most")</code>,
assuming the same scenario exists in both folders. In this case it is
advisable to also specify <code>scen_names</code> or name <code>scenarios</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># rdf_aggregate() ----------

rdfPath &lt;- system.file(
  "extdata/Scenario/ISM1988_2014,2007Dems,IG,Most", 
  package = "RWDataPlyr"
)

rwa &lt;- read_rwd_agg(
  system.file(
    "extdata/rwd_agg_files/passing_aggs.csv", 
    package = "RWDataPlyr"
  )
)

x &lt;- rdf_aggregate(rwa[1,], rdf_dir = rdfPath, scenario = "Most")

# rw_scen_aggregate() ----------

scens &lt;- c("ISM1988_2014,2007Dems,IG,2002", "ISM1988_2014,2007Dems,IG,Most")
scenNames &lt;- c("2002", "Most")
namedScens &lt;- scens
names(namedScens) &lt;- scenNames

scenPath &lt;- system.file("extdata/Scenario", package = "RWDataPlyr")

rwa &lt;- read_rwd_agg(
  system.file(
    "extdata/rwd_agg_files/passing_aggs.csv", 
    package = "RWDataPlyr"
  )
)

x &lt;- rw_scen_aggregate(namedScens, agg = rwa[1,], scen_dir = scenPath)

# y will be identical to x

y &lt;- rw_scen_aggregate(
  scens, 
  agg = rwa[1,], 
  scen_dir = scenPath, 
  scen_names = scenNames
)

identical(x, y) # is TRUE

</code></pre>

<hr>
<h2 id='rdf_get_slot'>Get a slot out of an rdf object</h2><span id='topic+rdf_get_slot'></span><span id='topic+rdfSlotToMatrix'></span>

<h3>Description</h3>

<p><code>rdf_get_slot()</code> gets a slot from an <code>rdf</code> object and creates a matrix with
rows indexing through time and columns indexing over traces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdf_get_slot(rdf, slot)

rdfSlotToMatrix(rdf, slot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdf_get_slot_+3A_rdf">rdf</code></td>
<td>
<p>An <code>rdf</code> object.</p>
</td></tr>
<tr><td><code id="rdf_get_slot_+3A_slot">slot</code></td>
<td>
<p>Character slot name that exists in the <code>rdf</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with traces as columns and timesteps as rows.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>rdfSlotToMatrix</code>: Deprecated version of <code>rdf_get_slot()</code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>pe &lt;- rdf_get_slot(keyRdf, "Mead.Pool Elevation")

</code></pre>

<hr>
<h2 id='rdf_get_timespan'>Returns the simulation timespan from an rdf</h2><span id='topic+rdf_get_timespan'></span>

<h3>Description</h3>

<p><code>rdf_get_timespan()</code> gets the simulation timespan from an <code>rdf</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdf_get_timespan(rdf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdf_get_timespan_+3A_rdf">rdf</code></td>
<td>
<p>An <code>rdf</code> object (likely from <code><a href="#topic+read.rdf">read.rdf()</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named character vector with two elements. The first element, named
<code>"start"</code>, includes the start date of the simulation. The second element,
named <code>"end"</code>, includes the end date of the simulation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rdf_get_timespan(keyRdf)

</code></pre>

<hr>
<h2 id='rdf_slot_names'>Returns all slots contained in an rdf file.</h2><span id='topic+rdf_slot_names'></span><span id='topic+getSlotsInRdf'></span>

<h3>Description</h3>

<p><code>rdf_slot_names()</code> returns a character vector of all slots contained within
an rdf object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdf_slot_names(rdf)

getSlotsInRdf(rdf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdf_slot_names_+3A_rdf">rdf</code></td>
<td>
<p>An <code>rdf</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getSlotsInRdf</code>: Deprecated version of <code>rdf_slot_names()</code>
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+read.rdf">read.rdf()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rdf_slot_names(keyRdf)

</code></pre>

<hr>
<h2 id='rdf_to_rwtbl'>Convert an rdf to a tibble</h2><span id='topic+rdf_to_rwtbl'></span><span id='topic+rdf_to_rwtbl2'></span>

<h3>Description</h3>

<p><code>rdf_to_rwtbl()</code> converts an rdf list to a tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdf_to_rwtbl(rdf, scenario = NULL, keep_cols = FALSE, add_ym = TRUE)

rdf_to_rwtbl2(file, scenario = NA_character_, keep_cols = FALSE, add_ym = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdf_to_rwtbl_+3A_rdf">rdf</code></td>
<td>
<p>An rdf object (from <code><a href="#topic+read_rdf">read_rdf()</a></code>).</p>
</td></tr>
<tr><td><code id="rdf_to_rwtbl_+3A_scenario">scenario</code></td>
<td>
<p>An optional parameter, that if it is not <code>NULL</code> or <code>NA</code>
(default) will be added to the tibble as another variable. Coerced to a
character if it is not already a character.</p>
</td></tr>
<tr><td><code id="rdf_to_rwtbl_+3A_keep_cols">keep_cols</code></td>
<td>
<p>Either boolean, or a character vector of column names to
keep in the returned tibble. The values of <code>keep_cols</code> work as follows:
</p>

<ul>
<li> <p><code>FALSE</code> (default) only includes the defaults columns: <code>Timestep</code>,
<code>TraceNumber</code>, <code>ObjectSlot</code>, and <code>Value</code>. <code>Scenario</code> is also returned if
<code>scenario</code> is specified.
</p>
</li>
<li> <p><code>TRUE</code>, all columns are returned.
</p>
</li>
<li><p> A character vector, e.g., <code>c("ObjectName", "Units")</code>, allows the user to
include other columns that are not always required, in addition to the
&quot;default&quot; set of columns. If any of the values in <code>keep_cols</code> are not
found, a warning will post, but all other columns will be returned.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rdf_to_rwtbl_+3A_add_ym">add_ym</code></td>
<td>
<p>Boolean that controls whether or not <code>Year</code> and <code>Month</code> columns
are added to the returned tibble. If <code>TRUE</code> (default), they will be added,
and if <code>FALSE</code> they will not be added. They are constructed from the dates
in the <code>Timestep</code> column.</p>
</td></tr>
<tr><td><code id="rdf_to_rwtbl_+3A_file">file</code></td>
<td>
<p>The relative or absolute rdf filename.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rdf object is converted to a data frame, and then converted to a
<code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>. All of the <code>meta</code> entries in the rdf object
are stored as attributes in the returned tibble. These attributes are:
<code>mrm_config_name</code>, <code>owner</code>, <code>description</code>, <code>create_date</code>, and <code>n_traces</code>.
</p>
<p>If the rdf contains a scalar slot(s), the scalar slot value(s) will be
repeated for every timestep.
</p>


<h3>Value</h3>

<p>A tbl_df with additional attributes from the rdf object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_rdf">read_rdf()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rdftbl &lt;- rdf_to_rwtbl(keyRdf)
# same as previous, except you do not want "Year" and "Month" columns
rdftbl &lt;- rdf_to_rwtbl(keyRdf, add_ym = FALSE)
# but you do want to keep the object name seperately:
rdftbl &lt;- rdf_to_rwtbl(keyRdf, add_ym = FALSE, keep_cols = "Object")
rdftbl &lt;- rdf_to_rwtbl(sysRdf, scenario = "ISM1988_2014,2007Dems,IG,2002")

# rdf_to_rwtbl2 wants a file path instead of an rdf object
rdfPath &lt;- system.file(
  "extdata/Scenario/ISM1988_2014,2007Dems,IG,Most/KeySlots.rdf", 
  package = "RWDataPlyr"
)
rdftbl &lt;- rdf_to_rwtbl2(rdfPath)

</code></pre>

<hr>
<h2 id='rdfSlotToXTS'>Get one slot out of an rdf list and put it in an XTS object</h2><span id='topic+rdfSlotToXTS'></span>

<h3>Description</h3>

<p><code>rdfSlotToXTS</code> Takes a list created by <code><a href="#topic+read.rdf">read.rdf</a></code> and
convert the nested slot values over the multiple traces into an XTS array
indexing over traces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdfSlotToXTS(rdf, slot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdfSlotToXTS_+3A_rdf">rdf</code></td>
<td>
<p>list returned by <code><a href="#topic+read.rdf">read.rdf</a></code></p>
</td></tr>
<tr><td><code id="rdfSlotToXTS_+3A_slot">slot</code></td>
<td>
<p>string of slot name that exists in <code>rdf</code> that will be
converted to a matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an XTS object with the selected slot data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pe &lt;- RWDataPlyr:::rdfSlotToXTS(keyRdf, 'Mead.Pool Elevation')

</code></pre>

<hr>
<h2 id='read_rw_csv'>Read RiverWare/RiverSMART produced csv files</h2><span id='topic+read_rw_csv'></span>

<h3>Description</h3>

<p><code>read_rw_csv()</code> reads in a CSV file created from RiverWare. If the CSV
file does not contain column names that RiverWare always uses (see Details),
then it assumes that the CSV file was not created from RiverWare and throws
an error. It also removes spaces from the column names, and adjusts the
<code>Object.Slot</code> and <code style="white-space: pre;">&#8288;Slot Value&#8288;</code> columns to be <code>ObjectSlot</code> and <code>Value</code>,
respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_rw_csv(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_rw_csv_+3A_file">file</code></td>
<td>
<p>The name of the file which the data are to be read from. Either
an absolute or relative path.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The required column names are: <code style="white-space: pre;">&#8288;Run Number&#8288;</code>, <code style="white-space: pre;">&#8288;Trace Number&#8288;</code>, <code>Object.Slot</code>,
<code>Timestep</code>, <code style="white-space: pre;">&#8288;Slot Value&#8288;</code>. See the CSV output section of the
<a href="http://www.riverware.org/HelpSystem/index.html#page/SolutionApproaches/Solutions_MRM.4.5.html#ww477402">RiverWare documentation</a>
for more information on the other optional column names.
</p>
<p>This function uses <code><a href="data.table.html#topic+fread">data.table::fread()</a></code> to read in
the CSV file, and forces it to expect a CSV file, expect headers, and return
<code>data.frame</code>.
</p>


<h3>Value</h3>

<p>A tibble (data frame) containing the data in the csv.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.rdf">read.rdf()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zz &lt;- read_rw_csv(system.file(
  "extdata/Scenario/ISM1988_2014,2007Dems,IG,Most",
  "KeySlots.csv",
  package = "RWDataPlyr"
))

</code></pre>

<hr>
<h2 id='read_rwd_agg'>Read in a rwd_agg file</h2><span id='topic+read_rwd_agg'></span>

<h3>Description</h3>

<p><code>read_rwd_agg()</code> reads in a csv file and creates a <a href="#topic+rwd_agg">rwd_agg</a> object.
Therefore, if the csv file is not properly formatted to contain the correct
information for a <a href="#topic+rwd_agg">rwd_agg</a> object, it will fail. <code><a href="#topic+rwd_agg_template">rwd_agg_template()</a></code> will
create a blank template file for the user to fill in, which has the correct
headers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_rwd_agg(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_rwd_agg_+3A_file">file</code></td>
<td>
<p>The csv file to be read in and converted</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+rwd_agg_template">rwd_agg_template()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>read_rwd_agg( 
  system.file(
    "extdata/rwd_agg_files/passing_aggs.csv", 
    package = "RWDataPlyr"
  )
)

</code></pre>

<hr>
<h2 id='read.rdf'>Read an rdf file into R.</h2><span id='topic+read.rdf'></span><span id='topic+read.rdf2'></span><span id='topic+read_rdf'></span>

<h3>Description</h3>

<p><code>read.rdf()</code> reads an rdf file into R and formats it as a multi-level list
containing all of the metadata included in the rdf file.  rdf files are
generated by RiverWare and are documented in the
<a href="http://www.riverware.org/HelpSystem/index.html">RiverWare documentation</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.rdf(iFile, rdf = TRUE)

read.rdf2(iFile)

read_rdf(iFile, rdf = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.rdf_+3A_ifile">iFile</code></td>
<td>
<p>The input rdf file that will be read into R.</p>
</td></tr>
<tr><td><code id="read.rdf_+3A_rdf">rdf</code></td>
<td>
<p>Boolean; if <code>TRUE</code>, then an rdf object is returned. If <code>FALSE</code>,
then a character vector is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>read.rdf()</code>uses <code><a href="data.table.html#topic+fread">data.table::fread()</a></code> to read in the file, which provides
performance benefits as compared to earlier versions of the function.
</p>
<p><code>read.rdf2()</code> is deprecated and will be removed in a future release.
</p>


<h3>Value</h3>

<p>An rdf object or character vector.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>read.rdf2</code>: Deprecated version of <code>read.rdf()</code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>zz &lt;- read_rdf(system.file(
  'extdata/Scenario/ISM1988_2014,2007Dems,IG,Most', 
  "KeySlots.rdf", 
  package = "RWDataPlyr"
))

</code></pre>

<hr>
<h2 id='rw_scen_gen_names'>Create a vector of scenarios from different dimensions</h2><span id='topic+rw_scen_gen_names'></span><span id='topic+makeAllScenNames'></span>

<h3>Description</h3>

<p><code>rw_scen_gen_names()</code> creates a vector of full scenario names by combining
multiple dimensions together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rw_scen_gen_names(dim1, dim2, ..., sep = ",")

makeAllScenNames(dim1, dim2, ..., sep = ",")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rw_scen_gen_names_+3A_dim1">dim1</code></td>
<td>
<p>A character vector with all of the first dimension's names.</p>
</td></tr>
<tr><td><code id="rw_scen_gen_names_+3A_dim2">dim2</code></td>
<td>
<p>A character vector with all of the second dimension's names.</p>
</td></tr>
<tr><td><code id="rw_scen_gen_names_+3A_...">...</code></td>
<td>
<p>As many individual character vectors as necessary for the
remaining dimension's names.</p>
</td></tr>
<tr><td><code id="rw_scen_gen_names_+3A_sep">sep</code></td>
<td>
<p>The character used to separate the different dimension names.
Defaults to<code>","</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Many RiverWare runs are specified by multiple dimensions (or assumptions),
and RiverSMART creates folder names by combining the dimension names together
for a full scenario name. <code>rw_scen_gen_names()</code> makes it quick to create all
of the full scenario names by passing in the names of the individual
dimensions and creating all possible combinations of all dimensions.
</p>
<p>For example, the RiverWare run might consist of a supply dimension and a
demand dimension, each consisting of two scenarios. This would result in four
total scenarios.
</p>
<p>The function will work with two or more dimensions, as there is no need for
this function if there is only one dimension.
</p>


<h3>Value</h3>

<p>A character vector of all possible combinations of the dimensions.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>makeAllScenNames</code>: Deprecated version of <code>rw_scen_gen_names()</code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>rw_scen_gen_names("DNF", "CT", c("IG", "NA"), c("MTOM", "24-MS"))
rw_scen_gen_names("DNF", "CT", c("IG", "NA"), sep = "_")

</code></pre>

<hr>
<h2 id='rwd_agg'>Class to specify how to aggregate RiverWare data</h2><span id='topic+rwd_agg'></span>

<h3>Description</h3>

<p><code>rwd_agg()</code> creates a RiverWare data aggregator (<code>rwd_agg</code>) object, which
lets users specify how specific RiverWare slots should be aggregated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwd_agg(x = NULL, rdfs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rwd_agg_+3A_x">x</code></td>
<td>
<p>A data.frame with required column names and valid entries; see
<em>Details</em> and <em>Aggregation Specification</em> sections.</p>
</td></tr>
<tr><td><code id="rwd_agg_+3A_rdfs">rdfs</code></td>
<td>
<p>A vector of rdf names; see <em>Details</em> and
<em>Aggregation Specification</em> sections.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rwd_agg</code> objects can be created in three ways:
</p>

<ol>
<li><p> By providing a data.frame, with the following expected columns <code>file</code>,
<code>slot</code>, <code>period</code>, <code>summary</code>, <code>eval</code>, <code>t_s</code>, and <code>variable</code>. Each row in the
data.frame should include all of the information for how each individual
slot will be aggregated. See the <em>Aggregation Specification</em> section below
for details on how to specify each column.
</p>
</li>
<li><p> By providing a vector of rdf files. If specified in this manor, all of the
slots in each rdf file will be read in to a <code>rwtbl</code>, but will not be
aggregated/summarized.
</p>
<p>In this case, the <code>variable</code> names are automatically constructed from the
<code>ObjectSlot</code> names. The variable names are constructed as the all lower
case version of the object_slot name. If the slot name is &quot;Pool Elevation&quot;,
it is shortened to &quot;pe&quot;, otherwise the full object and slot name are used.
If there are any spaces, they are replaced with underscores.
</p>
</li>
<li><p> By reading in a csv file with <code><a href="#topic+read_rwd_agg">read_rwd_agg()</a></code>. This csv file must have
the correct column names and meet other requirements described below. To
ensure it has the correct column names, <code><a href="#topic+rwd_agg_template">rwd_agg_template()</a></code> can be used
to create a blank csv file for the user to fill in.
</p>
</li></ol>



<h3>Aggregation Specification</h3>

<p>In order to specify how each slot should be aggregated, each column should
include specific keywords, which are described below. It is up to the user
to specify which rdf file contains each slot. In a general case, the user
specifies the <code>slot</code> that is found in a specific rdf file (<code>file</code>). A
<code>summary</code> function is applied to a subset <code>period</code> of the <code>slot</code>, and then
compared (<code>eval</code>) to a threshold (<code>t_s</code>) and saved as the <code>variable</code>.
</p>

<ul>
<li> <p><em>file:</em> specifies the rdf file that contains the slot.
</p>
</li>
<li> <p><em>slot:</em> the full RiverWare slot name, i.e., &quot;Object.Slot&quot;.
</p>
</li>
<li> <p><em>period:</em> the period that the slot should be summarized over. This should
either be a function name, a full month name (found in <a href="base.html#topic+month.name">month.name</a>), or
the keyword &quot;asis&quot;.
</p>

<ul>
<li> <p><em>function name:</em> Specifying a function name allows for pre-specified
or custom functions to group together several months in the <em>period</em>.
This package provides the following functions: <code>cy()</code>, <code>wy()</code>,
<code>eocy()</code>, and <code>eowy()</code>. <code>cy()</code> indicates the data will be summarized
over the calendar year, i.e., January - December, while <code>wy()</code>
summarizes over the water year, i.e., October - September. <code>eocy()</code>
selects the end of the calendar year, and <code>eowy()</code> selects the end of
the water year. When specified in the <code>slot_agg</code> object, leave off the
parenthesis, i.e., only specify the function name. If <code>wy()</code> is
specified, the function will remove data for any water years that have
less than 7 months of data. This &quot;tolerance&quot; is specified by the
<code>rwdataplyr.wy_month_tol</code> option, and can be modified by updating this
option to another number. For standard monthly data that starts in
January and ends in December, this results in keeping the first water
year, since it includes 9 months of data, and removing the final water
year, since it includes only three months of data. Setting this option
to 0 will result in keeping any water year data that has at least one
month of data; setting this option to 11, ensures that there must be
a full water year of data for that year to be kept.
</p>
<p>This can also be a user specified custom function; see the
<em>Custom Period Functions</em> section for details on constructing the custom
functions.
</p>
</li>
<li> <p><em>full month name:</em> When the full month name is specified, data will
be filtered to only include data for that particular month. To select
multiple months of data, use a function as described above. If the
month specified is not found in <a href="base.html#topic+month.name">month.name</a>, an error will occur.
</p>
</li>
<li> <p><em>asis:</em> If the keyword &quot;asis&quot; is specified, the data is returned for
its native timestep, i.e, monthly data will return monthly data and
annual data will return annual.
</p>
</li></ul>

</li>
<li> <p><em>summary:</em> the summary function that should be applied to the period
specified as a function name, or <code>NA</code>. If the <code>period</code> specified is &quot;asis&quot;
or returns only one month, e.g., <code>eocy()</code>, then the summary should be <code>NA</code>.
The summary function should only return one value; for that reason, most
of the <code>Summary</code> <a href="methods.html#topic+S4groupGeneric">S4groupGeneric</a>s work. Notably, <code>range()</code> will not
since it returns two values. There is no reason that a custom function
will not work here, but it has not been tested.
</p>
</li>
<li> <p><em>eval:</em> the comparison operator to use (see the <code>Compare</code>
<a href="methods.html#topic+S4groupGeneric">S4groupGeneric</a>s). If no comparison is desired, then <code>NA</code> should be used.
If <code>eval</code> is specified the value returned from applying the <code>summary</code> to
the <code>period</code> will be compared to the threshold specified by <code>t_s</code>. The
results of the comparison are returned as 0 and 1 instead of <code>TRUE</code> and
<code>FALSE</code>.
</p>
</li>
<li> <p><em>t_s:</em> either the threshold to be compared to if <code>eval</code> is not <code>NA</code> or a
value to scale the result by, e.g,. 0.001 to convert from acre-ft to
thousand acre-ft. <code>NA</code> can also be specified to not scale the data.
</p>
</li>
<li> <p><em>variable:</em> the variable name that will be used to identify the results
of applying the period, summary, comparison/scaling to. All variable names
should be unique.
</p>
</li></ul>

<p>For example, to determine if the minimum water year elevation at Lake Powell
is below elevation 3550 feet, the following would be specified:</p>
<pre>data.frame(
  file = "KeySlots.rdf",
  slot = "Powell.Pool Elevation",
  period = "wy",
  summary = "min",
  eval = "&lt;",
  t_s = 3550,
  variable = "powellLt3550",
  stringsAsFactors = FALSE
)
</pre>


<h3>Custom Period Functions</h3>

<p>Users can specify custom period functions to make it easier to group months
together in custom ways. For example a function could return all of the
summer months, or the more complicated case groups months across different
calendar years together. In fact, <code>wy()</code> is an example of a function that
does this; another example might be grouping December - February together
for winter months.
</p>
<p>The custom period function should return a list with three elements:
</p>

<ul>
<li> <p><code>fun</code> - a function that will modify a rwtbl and properly determine the
new <code>Year</code>s based on the custom period.
</p>
</li>
<li> <p><code>filter_months</code> - the months that should be grouped together.
</p>
</li>
<li> <p><code>group_tbl</code> - how to group the returned rwtbl; likely either <code>c("Year")</code> or
<code>c("Year", "Month")</code>
</p>
</li></ul>

<p>See the &quot;RWDataPlyr Workflow&quot; vignette for example implementations of both
the summer and winter custom functions described above.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rwd_agg_template">rwd_agg_template()</a></code>, <code><a href="#topic+read_rwd_agg">read_rwd_agg()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># determine if Powell's minimum water year elevation is &lt; 3550'
rwd_agg(
  data.frame(
    file = "KeySlots.rdf",
    slot = "Powell.Pool Elevation",
    period = "wy",
    summary = "min",
    eval = "&lt;",
    t_s = 3550,
    variable = "powellLt3550",
    stringsAsFactors = FALSE
  )
)

# get all the monthly slots in KeySlots.rdf
rwd_agg(rdfs = "KeySlots.rdf")

</code></pre>

<hr>
<h2 id='rwd_agg_template'>Create a <code>rwd_agg</code> template</h2><span id='topic+rwd_agg_template'></span>

<h3>Description</h3>

<p><code>rwd_agg_template()</code> creates a template csv file to use to create a RiverWare
data aggregator (<a href="#topic+rwd_agg">rwd_agg</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwd_agg_template(file, path = ".", examples = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rwd_agg_template_+3A_file">file</code></td>
<td>
<p>The file name to use for the template</p>
</td></tr>
<tr><td><code id="rwd_agg_template_+3A_path">path</code></td>
<td>
<p>The path to create the template at</p>
</td></tr>
<tr><td><code id="rwd_agg_template_+3A_examples">examples</code></td>
<td>
<p>Boolean; When <code>FALSE</code> (default), the template includes only
headers. When <code>TRUE</code>, the template will include several examples of
specifying how each slot should be summarized.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+read_rwd_agg">read_rwd_agg()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rwd_agg_template(file = "rwa_slots.csv", path = tempdir())
rwd_agg_template(file = "rwa_slots.csv", path = tempdir(), examples = TRUE)

</code></pre>

<hr>
<h2 id='rwslot_annual_sum'>Simple aggregation functions for monthly matrix data</h2><span id='topic+rwslot_annual_sum'></span><span id='topic+sumMonth2Annual'></span><span id='topic+rwslot_annual_min'></span><span id='topic+getMinAnnValue'></span><span id='topic+rwslot_annual_max'></span><span id='topic+getMaxAnnValue'></span><span id='topic+rwslot_fwaac'></span>

<h3>Description</h3>

<p>A family of functions that take a matrix containing monthly data (months by
traces) that has a &quot;timespan&quot; attribute, annualizes the data by summing, or
finding the minimum or maximum monthly values. Returns a years by traces
matrix. Matrices returned by <code><a href="#topic+rdf_get_slot">rdf_get_slot()</a></code> have the timespan attribute
added to them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwslot_annual_sum(rwslot, multFactor = 1)

sumMonth2Annual(rwslot, multFactor = 1)

rwslot_annual_min(rwslot)

getMinAnnValue(rwslot)

rwslot_annual_max(rwslot)

getMaxAnnValue(rwslot)

rwslot_fwaac(mass, flow)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rwslot_annual_sum_+3A_rwslot">rwslot</code></td>
<td>
<p>A matrix (months by traces) such as that returned by
<code><a href="#topic+rdf_get_slot">rdf_get_slot()</a></code>. Function will error if the <code>rwslot</code> does not contain
&quot;regular&quot; monthly data, i.e., the data must start in January and end in
December, or start in October and end in September (water year), and the
<code>rwslot</code> must have the timespan attribute.</p>
</td></tr>
<tr><td><code id="rwslot_annual_sum_+3A_multfactor">multFactor</code></td>
<td>
<p>A factor the annual sum will be multiplied by.  Can be used
to convert from flow to volume, or to scale all results in another manor.</p>
</td></tr>
<tr><td><code id="rwslot_annual_sum_+3A_mass">mass</code></td>
<td>
<p>A matrix (months by traces), such as that returned by
<code><a href="#topic+rdf_get_slot">rdf_get_slot()</a></code>, of mass in tons.</p>
</td></tr>
<tr><td><code id="rwslot_annual_sum_+3A_flow">flow</code></td>
<td>
<p>A matrix (months by traces), such as that returned by
<code><a href="#topic+rdf_get_slot">rdf_get_slot()</a></code>, of flow in acre-ft/month.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Other functions: Annual matrix (years x traces)
</p>
<p><code>rwslot_fwaac()</code>: Annual matrix (years x traces). Units are mg/L.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>sumMonth2Annual</code>: Deprecated version of <code>rwslot_annual_sum()</code>.
</p>
</li>
<li> <p><code>rwslot_annual_min</code>: finds the minimum annual value
for all years and traces.
</p>
</li>
<li> <p><code>getMinAnnValue</code>: Deprecated version of <code>rwslot_annual_min()</code>.
</p>
</li>
<li> <p><code>rwslot_annual_max</code>: finds the maximum annual value for all years and
traces.
</p>
</li>
<li> <p><code>getMaxAnnValue</code>: Deprecated version of <code>rwslot_annual_max()</code>.
</p>
</li>
<li> <p><code>rwslot_fwaac</code>: calculates the flow-weighted average annual
concentration (fwaac). Given mass and flow at the monthly basis, the
flow-weighted average annual concentration is computed. <code>mass</code> and <code>flow</code>
should be monthly data. <code>rwslot_fwaac()</code> expects flow to be in acre-ft/month
and mass to be in tons; however, there are no checks to ensure this is true.
Return value will be in mg/L.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+rdf_get_slot">rdf_get_slot()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zz &lt;- rdf_get_slot(keyRdf, 'Powell.Outflow')

# returns in original units, e.g., acre-ft
annualTotVal &lt;- rwslot_annual_sum(zz)

# returns in scaled units, e.g., kaf
annualTotVal &lt;- rwslot_annual_sum(zz, 0.001) 

pe &lt;- rdf_get_slot(keyRdf,'Mead.Pool Elevation')
peMax &lt;- rwslot_annual_min(pe)

pe &lt;- rdf_get_slot(keyRdf,'Mead.Pool Elevation')
peMax &lt;- rwslot_annual_max(pe)

flow &lt;- rdf_get_slot(keyRdf,'Powell.Outflow')
# make up mass, since it's not stored in the example data
rr &lt;- matrix(
  rnorm((nrow(flow) * ncol(flow)), mean = 1000, sd = 200), 
  nrow = nrow(flow), 
  ncol = ncol(flow)
)
mass &lt;- flow / 1000000 * rr^2 - rr + 1500 
fwaac &lt;- rwslot_fwaac(mass, flow) 

</code></pre>

<hr>
<h2 id='rwtbl_get_scen_folder'>Map a scenario name to the original scenario folder</h2><span id='topic+rwtbl_get_scen_folder'></span>

<h3>Description</h3>

<p><code>rwtbl_get_scen_folder()</code> provides the original file path to the scenario
folder for the specified scenario name(s) (<code>scenarios</code>). If <code>scenarios</code> are
not found in <code>rwtblsmmry</code>, a warning message is posted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwtbl_get_scen_folder(rwtblsmmry, scenarios)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rwtbl_get_scen_folder_+3A_rwtblsmmry">rwtblsmmry</code></td>
<td>
<p>A tbl_df of summarized RiverWare data; likely output from
<code><a href="#topic+rw_scen_aggregate">rw_scen_aggregate()</a></code>.</p>
</td></tr>
<tr><td><code id="rwtbl_get_scen_folder_+3A_scenarios">scenarios</code></td>
<td>
<p>A vector of scenario names to map to scenario folders.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of scenario folders; <code>character(0)</code> if none of the
<code>scenarios</code> are found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rwtbl_get_scen_folder(scen_data, "Most")
rwtbl_get_scen_folder(scen_data, c("Most", "2002"))

</code></pre>

<hr>
<h2 id='rwtbl_slot_names'>List the slot names in a tbl_df</h2><span id='topic+rwtbl_slot_names'></span>

<h3>Description</h3>

<p><code>rwtbl_slot_names()</code> lists all of the slot names found in a <code>tbl_df</code> object
containing RiverWare output data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwtbl_slot_names(rwtbl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rwtbl_slot_names_+3A_rwtbl">rwtbl</code></td>
<td>
<p>A <code>tbl_df</code> object with RiverWare output. Must contain the
<code>ObjectSlot</code> column.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a <code>tbl_df</code> object that is returned by <code><a href="#topic+rdf_to_rwtbl">rdf_to_rwtbl()</a></code> or
<code><a href="#topic+read_rw_csv">read_rw_csv()</a></code>, return all of the Object.Slot names found in the data
frame. These are the unique full slot names found in the <code>ObjectSlot</code>
column.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rdf_to_rwtbl">rdf_to_rwtbl()</a></code>, <code><a href="#topic+read_rw_csv">read_rw_csv()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rwtbl &lt;- rdf_to_rwtbl(keyRdf)
rwtbl_slot_names(rwtbl)

</code></pre>

<hr>
<h2 id='rwtbl_var_to_slot'>Map a variable name to the RiverWare slot name</h2><span id='topic+rwtbl_var_to_slot'></span>

<h3>Description</h3>

<p><code>rwtbl_var_to_slot()</code> provides the RiverWare slot name that was used to
create the specified variable name (<code>varname</code>). If <code>varname</code> is not found in
<code>rwtblsmmry</code>, a warning message is posted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwtbl_var_to_slot(rwtblsmmry, varname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rwtbl_var_to_slot_+3A_rwtblsmmry">rwtblsmmry</code></td>
<td>
<p>A tbl_df of summarized RiverWare data; likely output from
<code><a href="#topic+rw_scen_aggregate">rw_scen_aggregate()</a></code>.</p>
</td></tr>
<tr><td><code id="rwtbl_var_to_slot_+3A_varname">varname</code></td>
<td>
<p>A vector of variable names to map to slot names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the found slot names. <code>character(0)</code> if no
variable names were found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rwtbl_var_to_slot(scen_data, "peLt1000")
rwtbl_var_to_slot(scen_data, c("peLt1000", "peEocy"))

</code></pre>

<hr>
<h2 id='scen_data'>Example aggregated scenario data</h2><span id='topic+scen_data'></span>

<h3>Description</h3>

<p>An example of the tbl_df returned by <code><a href="#topic+rw_scen_aggregate">rw_scen_aggregate()</a></code> containing two
scenarios of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scen_data
</code></pre>


<h3>Format</h3>

<p>An object of class <code>grouped_df</code> (inherits from <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 720 rows and 6 columns.
</p>

<hr>
<h2 id='slot_agg_list'>A class to control how RiverWare data are aggregated</h2><span id='topic+slot_agg_list'></span>

<h3>Description</h3>

<p><code>"slot_agg_list"</code> is a class that contains a set of RiverWare slots, which
rdf file they are found in, and a set of keywords that are used to control
how <code><a href="#topic+getDataForAllScens">getDataForAllScens()</a></code> aggregates RiverWare data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slot_agg_list(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slot_agg_list_+3A_x">x</code></td>
<td>
<p>Either an Nx4 character matrix or a character with an absolute
or relative path to a csv file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>slot_agg_list</code> class, contains a list that includes: which rdf file to
find each slot in, how to aggregate and process the slot data, and any
thresholds or scaling factors. The function can either read in a csv file or
start from an N x 4 or N x 5 string matrix (the 5th column is optional).
</p>
<p>The csv file and the matrix should be in the form of an Nx4 or Nx5 matrix.
Each row is a single slot, aggregation, and threshold combination. If you
want to compare a single slot value to multiple thresholds, it needs to have
one row for each threshold. The first column is the rdf the slot is found in.
The second column is the slot name. The third column is the aggregation
method that will be applied to the slot (see below for a list of the
aggregation methods).  The fourth column is a scaling factor or threshold to
compare the slot data to. The fifth column is an optional column; if
specified, the 5th column will be used for the variable name for the
data.frame created by <code><a href="#topic+getDataForAllScens">getDataForAllScens()</a></code>. If it is not specified
the variable name will be created by concatenating the slot, aggregation
method, and threshold/scaling factor using '_' to separate the columns.
Below is an example table. All values should be strings except for <code>NA</code>,
if specified as a matrix in R.
</p>

<table>
<tr>
 <td style="text-align: center;">
<strong>rdf</strong> </td><td style="text-align: center;"> <strong>Slot</strong> </td><td style="text-align: center;"> <strong>Aggregation Method</strong> </td><td style="text-align: center;">
<strong>Threshold or Scaling Factor</strong> </td><td style="text-align: center;"> <strong>Variable Name (optional)</strong></td>
</tr>
<tr>
 <td style="text-align: center;">
'KeySlots.rdf' </td><td style="text-align: center;"> 'Mead.Pool Elevation' </td><td style="text-align: center;"> 'EOCY' </td><td style="text-align: center;"> NA </td><td style="text-align: center;"> Mead EOCY Elevation</td>
</tr>
<tr>
 <td style="text-align: center;">
'KeySlots.rdf' </td><td style="text-align: center;"> 'Mead.Pool Elevation' </td><td style="text-align: center;"> 'AnnMinLTE' </td><td style="text-align: center;"> '1100' </td><td style="text-align: center;"> Mead &lt; 1,100</td>
</tr>
<tr>
 <td style="text-align: center;">
'KeySlots.rdf' </td><td style="text-align: center;"> 'Mead.Pool Elevation' </td><td style="text-align: center;"> 'AnnMinLTE' </td><td style="text-align: center;"> '1060' </td><td style="text-align: center;"> Mead &lt; 1,060</td>
</tr>
<tr>
 <td style="text-align: center;">
'Other.rdf' </td><td style="text-align: center;"> 'Powell.Outflow' </td><td style="text-align: center;"> 'AnnualSum' </td><td style="text-align: center;"> '0.001' </td><td style="text-align: center;"> Powell Annual Release</td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>The above table lists each slot, the rdf the slot is saved in, the summary
function, the threshold to be used to scale the data by or compare the data
to, and an optionally specified variable name. The threshold and scaling
factors are described in more detail below. For example, the first row will
result in compiling all end-of-December values for Mead's pool elevation.
The data will not be scaled, and <code><a href="#topic+getDataForAllScens">getDataForAllScens()</a></code> will look in
KeySlots.rdf for the &quot;Mead.Pool Elevation&quot; slot. The second row will find
the annual minimum Mead pool elevation and see if it is less than or equal
to 1,100' feet in the second line and less than or equal to 1,060' feet in
the third row.
</p>
<p>To scale the data by a value less than 1, use decimals rather than fractions,
as shown in the fourth row. If the Variable Name column was not specified,
the variable name for the first row would be <code style="white-space: pre;">&#8288;Mead.Pool Elevation_EOCY_1&#8288;</code>
<code>NA</code> is replaced with a 1 when constructing the variable names.
</p>
<p>See the <strong>Aggregation Methods</strong> section for available aggregation methods.
</p>


<h3>Value</h3>

<p>A  <code>slot_agg_list</code>  object.
</p>


<h3>Aggregation Methods</h3>

<p>The available aggregation methods are as follows. The behavior of the
&quot;Threshold or scaling factor&quot; are described and a bold <strong>&quot;Threshold&quot;</strong> or
<strong>&quot;Scaled&quot;</strong> indicates which is used by the aggregation method. For scaling
factors, a value of <code>NA</code> will not scale the data.
</p>

<dl>
<dt>'AnnMin'</dt><dd><p>Returns the minimum annual <strong>scaled</strong> value.</p>
</dd>
<dt>'AnnMax'</dt><dd><p>Returns the maximum annual <strong>scaled</strong> value.</p>
</dd>
<dt>'AnnualSum'</dt><dd><p>Returns the annual <strong>scaled</strong> sum.</p>
</dd>
<dt>'AnnMinLTE'</dt><dd><p>Checks to see if the annual minimum value is less than or
equal to a <strong>threshold.</strong> Returns 1 if it is less than or equal to
the <strong>threshold</strong> and 0 otherwise.</p>
</dd>
<dt>'AnnualRaw'</dt><dd><p>Returns the annual <strong>scaled</strong> data. This aggregation
method should only be used if the rdf file contains only annual data. For
rdf files that include monthly data and only an annual value is desired, the
EOCY aggregation method should be used. This differs from the Monthly
aggregation method, only in the timestep naming.</p>
</dd>
<dt>'BOCY'</dt><dd><p>Beginning-of-calendar year values are reported and
<strong>scaled</strong>. Any values that are NaNs are changed to 0s.</p>
</dd>
<dt>'EOCY'</dt><dd><p>End-of-calendar year values are reported and <strong>scaled</strong>.
Any values that are NaNs are changed to 0s.</p>
</dd>
<dt>'EOCYGTE'</dt><dd><p>Checks to see if the end-of-calendar year values are
greater than or equal to a <strong>threshold</strong>. Returns 1 if it is greater
than or equal to the <strong>threshold</strong> and 0 otherwise.</p>
</dd>
<dt>'EOCYLTE'</dt><dd><p>Checks to see if the end-of-calendar year values are less
than or equal to a <strong>threshold</strong>. Returns 1 if it is less than or
equal to the <strong>threshold</strong> and 0 otherwise.</p>
</dd>
<dt>'EOWY'</dt><dd><p>End-of-water year values are reported and <strong>scaled</strong>.
Any values that are NaNs are changed to 0s.</p>
</dd>
<dt>'Monthly'</dt><dd><p>Returns the monthly <strong>scaled</strong> data.</p>
</dd>
<dt>'WYMaxLTE'</dt><dd><p>Checks to see if the maximum water year value is less than
or equal to a <strong>threshold.</strong> Returns 1 if it is less than or equal to
the <strong>threshold</strong> and 0 otherwise. This can be used to determine if an
entire water year is below a <strong>threshold</strong>. The water year is defined
as October through September of the next year. For the first year, only
January through September are evaluated as RiverWare does not typically
export pre-simulation data.</p>
</dd>
<dt>'WYMinLTE'</dt><dd><p>Checks to see if the minimum water year value is less than
or equal to a <strong>threshold.</strong> Returns 1 if it is less than or equal to
the <strong>threshold</strong> and 0 otherwise. The water year is defined as October
through September of the next year. For the first year, only January through
September are evaluated as RiverWare does not typically export
pre-simulation data.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+getDataForAllScens">getDataForAllScens()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read in a csv file that contains the data
slot_agg_list(
  system.file('extdata','SlotAggTable.csv',package = 'RWDataPlyr')
)

# or specify as a matrix
slot_agg_matrix &lt;- matrix(
  c("KeySlots.rdf", "Powell.Outflow", "AnnualSum", ".001", "powellAnnRel", 
  "KeySlots.rdf", "Mead.Pool Elevatoin", "AnnMinLTE", "1050", "meadLt1050"), 
  nrow = 2, 
  byrow = TRUE
)
slot_agg_list(slot_agg_matrix)

</code></pre>

<hr>
<h2 id='sysRdf'>Example rdf file with annual data.</h2><span id='topic+sysRdf'></span>

<h3>Description</h3>

<p>An example of an rdf file that has already been read into R via
<code><a href="#topic+read.rdf">read.rdf()</a></code>. This example contains 23 slots, at the annual
timestep for 11 years and 25 runs. Slots only include
flags. Use this with <code><a href="#topic+rdf_slot_names">rdf_slot_names()</a></code> or
<code><a href="#topic+rdf_get_slot">rdf_get_slot()</a></code> to use the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sysRdf
</code></pre>


<h3>Format</h3>

<p>A multi level list. <code>sysRdf$meta</code> provides a description
of the RiverWare run used to generate this data.
</p>


<h3>Source</h3>

<p>Bureau of Reclamation, 2016
</p>

<hr>
<h2 id='ym_get_wateryear'>Get the water year from a year-month (yearmon) value</h2><span id='topic+ym_get_wateryear'></span><span id='topic+getWYFromYearmon'></span>

<h3>Description</h3>

<p><code>ym_get_wateryear()</code> returns the water year (assumed to be October -
September) from a <a href="zoo.html#topic+yearmon">zoo::yearmon</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ym_get_wateryear(ym)

getWYFromYearmon(ym)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ym_get_wateryear_+3A_ym">ym</code></td>
<td>
<p>An object of class <a href="zoo.html#topic+yearmon">zoo::yearmon</a>, or something that can be
successfully converted to <a href="zoo.html#topic+yearmon">zoo::yearmon</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the argument is not already a yearmon object, it will attempt to convert
it to a <a href="zoo.html#topic+yearmon">zoo::yearmon</a>. This may result in unexpected results. For example,
the string <code>"12-1-1906"</code> can be converted to a <a href="zoo.html#topic+yearmon">zoo::yearmon</a>, however, it
will not convert to <code>"Dec 1906"</code> as you might desire. It will convert to
<code>"Jan 0012"</code> since it is not a format expected by <code><a href="zoo.html#topic+as.yearmon">zoo::as.yearmon()</a></code>.
Therefore, a warning is posted when the function attempts to convert to
<a href="zoo.html#topic+yearmon">zoo::yearmon</a>, and it is safer to ensure <code>ym</code> is already a <a href="zoo.html#topic+yearmon">zoo::yearmon</a>.
</p>


<h3>Value</h3>

<p>The water year as a numeric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ym_get_wateryear(zoo::as.yearmon(c("Dec 1906", "Oct 1945", "Jul 1955")))
ym_get_wateryear("2000-11")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
