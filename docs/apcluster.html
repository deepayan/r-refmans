<!DOCTYPE html><html><head><title>Help for package apcluster</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {apcluster}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#apcluster-package'><p>APCluster Package</p></a></li>
<li><a href='#aggExCluster'><p>Exemplar-based Agglomerative Clustering</p></a></li>
<li><a href='#AggExResult-class'><p>Class &quot;AggExResult&quot;</p></a></li>
<li><a href='#apcluster'><p>Affinity Propagation</p></a></li>
<li><a href='#apclusterDemo'><p>Affinity Propagation Demo</p></a></li>
<li><a href='#apclusterK'><p>Affinity Propagation for Pre-defined Number of Clusters</p></a></li>
<li><a href='#apclusterL'><p>Leveraged Affinity Propagation</p></a></li>
<li><a href='#APResult-class'><p>Class &quot;APResult&quot;</p></a></li>
<li><a href='#coerce-methods'><p>Coercion of cluster hierarchies</p></a></li>
<li><a href='#conversions'><p>Conversions Between Dense and Sparse Similarity Matrices</p></a></li>
<li><a href='#cutree-methods'><p>Cut Out Clustering Level from Cluster Hierarchy</p></a></li>
<li><a href='#ExClust-class'><p>Class &quot;ExClust&quot;</p></a></li>
<li><a href='#heatmap'><p>Plot Heatmap</p></a></li>
<li><a href='#labels-methods'><p>Generate label vector from clustering result</p></a></li>
<li><a href='#plot'><p>Plot Clustering Results</p></a></li>
<li><a href='#preferenceRange'><p>Determine Meaningful Ranges for Input Preferences</p></a></li>
<li><a href='#show-methods'><p>Display Clustering Result Objects</p></a></li>
<li><a href='#similarities'><p>Methods for Computing Similarity Matrices</p></a></li>
<li><a href='#sort-methods'><p>Sort clusters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Affinity Propagation Clustering</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.11</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-19</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.1), methods, Matrix, stats, graphics, grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>Author:</td>
<td>Ulrich Bodenhofer [aut, cre],
        Johannes Palme [ctb],
	Chrats Melkonian [ctb],
	Andreas Kothmeier [aut],
	Nikola Kostic [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ulrich Bodenhofer &lt;bodenhofer@bioinf.jku.at&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements Affinity Propagation clustering introduced by Frey and
	Dueck (2007) &lt;<a href="https://doi.org/10.1126%2Fscience.1136800">doi:10.1126/science.1136800</a>&gt;. The algorithms are largely
        analogous to the 'Matlab' code published by Frey and Dueck.
        The package further provides leveraged affinity propagation and an
        algorithm for exemplar-based agglomerative clustering that can also be
        used to join clusters obtained from affinity propagation. Various
        plotting functions are available for analyzing clustering results.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Collate:</td>
<td>AllClasses.R AllGenerics.R access-methods.R coerce-methods.R
show-methods.R labels-methods.R length-methods.R revDend.R
heatmap-methods.R plot-methods.R cutree-methods.R
sort-methods.R aggExCluster-methods.R apcluster-methods.R
apclusterL-methods.R apclusterK-methods.R apclusterDemo.R
preferenceRange-methods.R similarity.R simpleDist.R
conversions.R</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.bioinf.jku.at/software/apcluster/">http://www.bioinf.jku.at/software/apcluster/</a>
<a href="https://github.com/UBod/apcluster">https://github.com/UBod/apcluster</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-19 11:03:51 UTC; ulrich</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-19 18:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='apcluster-package'>APCluster Package</h2><span id='topic+apcluster-package'></span>

<h3>Description</h3>

<p>The apcluster package implements affinity propagation according to
Frey and Dueck and a method for exemplar-based agglomerative clustering.
It further offers various functions for plotting clustering results.
</p>


<h3>Details</h3>

<p>The central function is <code><a href="#topic+apcluster">apcluster</a></code>. It runs affinity
propagation on a given similarity matrix or it creates a similarity matrix
for a given data set and similarity measure and runs affinity propagation
on this matrix. The function returns an <code><a href="#topic+APResult-class">APResult</a></code> 
object from which the clustering itself and information about the affinity 
propagation run can be obtained. Leveraged affinity propagation clustering 
<code><a href="#topic+apclusterL">apclusterL</a></code> allows efficient clustering of large datasets by 
using only a subset of the similarities. The package further implements 
an exemplar-based agglomerative clustering method <code><a href="#topic+aggExCluster">aggExCluster</a></code> 
that can be used for computing a complete cluster hierarchy, but also for 
joining fine-grained clusters previously obtained by affinity propagation 
clustering. Further functions are implemented to visualize the
results and to create distance matrices.
</p>


<h3>Author(s)</h3>

<p>Ulrich Bodenhofer, Andreas Kothmeier, Johannes Palme,
Chrats Melkonian &amp; Nikola Kostic
<a href="mailto:apcluster@bioinf.jku.at">apcluster@bioinf.jku.at</a></p>


<h3>References</h3>

<p><a href="http://www.bioinf.jku.at/software/apcluster/">http://www.bioinf.jku.at/software/apcluster/</a>
</p>
<p>Bodenhofer, U., Kothmeier, A., and Hochreiter, S. (2011)
APCluster: an R package for affinity propagation clustering.
<em>Bioinformatics</em> <b>27</b>, 2463-2464.
DOI: <a href="https://doi.org/10.1093/bioinformatics/btr406">doi:10.1093/bioinformatics/btr406</a>.
</p>
<p>Frey, B. J. and Dueck, D. (2007) Clustering by passing messages
between data points. <em>Science</em> <b>315</b>, 972-976.
DOI: <a href="https://doi.org/10.1126/science.1136800">doi:10.1126/science.1136800</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create two Gaussian clouds
cl1 &lt;- cbind(rnorm(100, 0.2, 0.05), rnorm(100, 0.8, 0.06))
cl2 &lt;- cbind(rnorm(100, 0.7, 0.08), rnorm(100, 0.3, 0.05))
x &lt;- rbind(cl1, cl2)

## compute similarity matrix (negative squared Euclidean)
sim &lt;- negDistMat(x, r=2)

## run affinity propagation
apres &lt;- apcluster(sim, details=TRUE)

## show details of clustering results
show(apres)

## plot information about clustering run
plot(apres)

## plot clustering result
plot(apres, x)

## employ agglomerative clustering to join clusters
aggres &lt;- aggExCluster(sim, apres)

## show information
show(aggres)
show(cutree(aggres, 2))

## plot dendrogram
plot(aggres)

## plot clustering result for k=2 clusters
plot(aggres, x, k=2)

## plot heatmap
heatmap(apres, sim)

## leveraged apcluster
apresL &lt;- apclusterL(s=negDistMat(r=2), x=x,  frac=0.2, sweeps=3)

## show details of clustering results
show(apresL)

## plot clustering result
plot(apresL, x)
</code></pre>

<hr>
<h2 id='aggExCluster'>Exemplar-based Agglomerative Clustering</h2><span id='topic+aggExCluster'></span><span id='topic+aggexcluster'></span><span id='topic+aggExCluster-methods'></span><span id='topic+aggExCluster+2Cmatrix+2Cmissing-method'></span><span id='topic+aggExCluster+2Cmatrix+2CExClust-method'></span><span id='topic+aggExCluster+2CMatrix+2Cmissing-method'></span><span id='topic+aggExCluster+2CMatrix+2CExClust-method'></span><span id='topic+aggExCluster+2Cmissing+2CExClust-method'></span><span id='topic+aggExCluster+2Cfunction+2CANY-method'></span><span id='topic+aggExCluster+2Ccharacter+2CANY-method'></span>

<h3>Description</h3>

<p>Runs exemplar-based agglomerative clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix,missing'
aggExCluster(s, x, includeSim=FALSE)
## S4 method for signature 'matrix,ExClust'
aggExCluster(s, x, includeSim=FALSE)
## S4 method for signature 'Matrix,missing'
aggExCluster(s, x, includeSim=FALSE)
## S4 method for signature 'Matrix,ExClust'
aggExCluster(s, x, includeSim=FALSE)
## S4 method for signature 'missing,ExClust'
aggExCluster(s, x, includeSim=TRUE)
## S4 method for signature 'function,ANY'
aggExCluster(s, x, includeSim=TRUE, ...)
## S4 method for signature 'character,ANY'
aggExCluster(s, x, includeSim=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggExCluster_+3A_s">s</code></td>
<td>
<p>an <code class="reqn">l\times l</code> similarity matrix or a similarity
function either specified as the name of a package-provided
similarity function as character string or a user provided
function object</p>
</td></tr> 
<tr><td><code id="aggExCluster_+3A_x">x</code></td>
<td>
<p>either a prior clustering of class <code><a href="#topic+ExClust-class">ExClust</a></code> (or
<code><a href="#topic+APResult-class">APResult</a></code>) or, if called with <code>s</code> being a
function or function name, input data to be clustered (see
<code><a href="#topic+apcluster">apcluster</a></code> for a detailed specification)</p>
</td></tr>
<tr><td><code id="aggExCluster_+3A_includesim">includeSim</code></td>
<td>
<p>if <code>TRUE</code>, the similarity matrix (either computed
internally or passed via the <code>s</code> argument) is stored to the
slot <code>sim</code> of the returned
<code><a href="#topic+AggExResult-class">AggExResult</a></code> object. The default is <code>FALSE</code>
if <code>aggExCluster</code> has been called for a similarity matrix,
otherwise the default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="aggExCluster_+3A_...">...</code></td>
<td>
<p>all other arguments are passed to the selected 
similarity function as they are.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>aggExCluster</code> performs agglomerative clustering.
Unlike other methods, e.g., the ones implemented in <code><a href="stats.html#topic+hclust">hclust</a></code>,
<code>aggExCluster</code> is computing exemplars for each cluster and
its merging objective is geared towards the identification of
meaningful exemplars, too.
</p>
<p>For each pair of clusters, the merging objective is computed as
follows:
</p>

<ol>
<li><p>An intermediate cluster is created as the union
of the two clusters.
</p>
</li>
<li><p>The potential exemplar is selected from the intermediate
cluster as the sample that has the largest average similarity
to all other samples in the intermediate cluster.
</p>
</li>
<li><p>Then the average similarity of the exemplar with all
samples in the first cluster and the average similarity with
all samples in the second cluster is computed. These two values
measure how well the joint exemplar describes the samples in the
two clusters.
</p>
</li>
<li><p>The merging objective is finally computed as the
average of the two measures above. Hence, we can consider the
merging objective as some kind of &ldquo;balanced average
similarity to the joint exemplar&rdquo;.
</p>
</li></ol>

<p>In each step, all pairs of clusters are considered and
the pair with the largest merging objective is actually merged.
The joint exemplar is then chosen as the exemplar of the merged
cluster.
</p>
<p><code>aggExCluster</code> can be used in two ways, either by performing
agglomerative clustering of an entire data set or by performing
agglomerative clustering of data previously clustered by
affinity propagation or another clustering algorithm.
</p>

<ol>
<li><p>Agglomerative clustering of an entire data set can be
accomplished either by calling <code>aggExCluster</code> on a
quadratic similarity matrix without further argument or by
calling <code>aggExCluster</code> for a function or function name
along with data to be clustered (as argument <code>x</code>).
A full agglomeration run is performed that starts from <code>l</code>
clusters (all samples in separate one-element clusters) and ends
with one cluster (all samples in one single cluster).  
</p>
</li>
<li><p>Agglomerative clustering starting from a given clustering
result can be accomplished by calling <code>aggExCluster</code> for
an <code><a href="#topic+APResult-class">APResult</a></code> or <code><a href="#topic+ExClust-class">ExClust</a></code>
object passed as parameter <code>x</code>. The similarity matrix
can either be passed as argument <code>s</code> or, if missing,
<code>aggExCluster</code> looks if the similarity matrix is
included in the clustering object <code>x</code>. A cluster hierarchy
with numbers of clusters ranging from the
number of clusters in <code>x</code> down to 1 is created.  
</p>
</li></ol>

<p>The result is stored in an <code><a href="#topic+AggExResult-class">AggExResult</a></code> object.
The slot <code>height</code> is filled with the merging
objective of each of the <code>maxNoClusters-1</code> merges. The slot
<code>order</code> contains a permutation of the samples/clusters for
dendrogram plotting. The algorithm for computing this permutation
is the same as the one used in <code><a href="stats.html#topic+hclust">hclust</a></code>. If <code>aggExCluster</code>
was called for an entire data set, the slot <code>label</code>
contains the names of the objects to be clustered (if available,
otherwise the indices are used). If <code>aggExCluster</code> was called
for a prior clustering, then labels are set to &lsquo;Cluster 1&rsquo;,
&lsquo;Cluster 2&rsquo;, etc.
</p>


<h3>Value</h3>

<p>Upon successful completion, the function returns an
<code><a href="#topic+AggExResult-class">AggExResult</a></code> object.
</p>


<h3>Note</h3>

<p>Similarity matrices can be supplied in dense or sparse
format. Note, however, that sparse matrices are converted to full
dense matrices before clustering which may lead to memory and/or
performance bottlenecks for larger data sets.</p>


<h3>Author(s)</h3>

<p>Ulrich Bodenhofer, Johannes Palme &amp; Nikola Kostic
<a href="mailto:apcluster@bioinf.jku.at">apcluster@bioinf.jku.at</a></p>


<h3>References</h3>

<p><a href="http://www.bioinf.jku.at/software/apcluster/">http://www.bioinf.jku.at/software/apcluster/</a>
</p>
<p>Bodenhofer, U., Kothmeier, A., and Hochreiter, S. (2011)
APCluster: an R package for affinity propagation clustering.
<em>Bioinformatics</em> <b>27</b>, 2463-2464.
DOI: <a href="https://doi.org/10.1093/bioinformatics/btr406">doi:10.1093/bioinformatics/btr406</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AggExResult-class">AggExResult</a></code>, <code><a href="#topic+apcluster-methods">apcluster-methods</a></code>,  
<code><a href="#topic+plot-methods">plot-methods</a></code>, <code><a href="#topic+heatmap-methods">heatmap-methods</a></code>,
<code><a href="#topic+cutree-methods">cutree-methods</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## create two Gaussian clouds
cl1 &lt;- cbind(rnorm(50, 0.2, 0.05), rnorm(50, 0.8, 0.06))
cl2 &lt;- cbind(rnorm(50, 0.7, 0.08), rnorm(50, 0.3, 0.05))
x &lt;- rbind(cl1, cl2)

## compute agglomerative clustering from scratch
aggres1 &lt;- aggExCluster(negDistMat(r=2), x)

## show results
show(aggres1)

## plot dendrogram
plot(aggres1)

## plot heatmap along with dendrogram
heatmap(aggres1)

## plot level with two clusters
plot(aggres1, x, k=2)

## run affinity propagation
apres &lt;- apcluster(negDistMat(r=2), x, q=0.7)

## create hierarchy of clusters determined by affinity propagation
aggres2 &lt;- aggExCluster(x=apres)

## show results
show(aggres2)

## plot dendrogram
plot(aggres2)
plot(aggres2, showSamples=TRUE)

## plot heatmap
heatmap(aggres2)

## plot level with two clusters
plot(aggres2, x, k=2)
</code></pre>

<hr>
<h2 id='AggExResult-class'>Class &quot;AggExResult&quot;</h2><span id='topic+AggExResult-class'></span><span id='topic+AggExResult'></span><span id='topic+aggexresult'></span><span id='topic++5B+2CAggExResult+2Cindex+2Cmissing+2Cmissing-method'></span><span id='topic++5B+5B+2CAggExResult+2Cindex+2Cmissing-method'></span><span id='topic+length+2CAggExResult-method'></span><span id='topic+similarity+2CAggExResult-method'></span>

<h3>Description</h3>

<p>S4 class for storing results of exemplar-based
agglomerative clustering</p>


<h3>Objects</h3>

<p>Objects of this class can be created by calling <code><a href="#topic+aggExCluster">aggExCluster</a></code>
for a given similarity matrix.
</p>


<h3>Slots</h3>

<p>The following slots are defined for <a href="#topic+AggExResult">AggExResult</a> objects:
</p>

<dl>
<dt><code>l</code>:</dt><dd><p>number of samples in the data set</p>
</dd>
<dt><code>sel</code>:</dt><dd><p>subset of samples used for leveraged clustering 
(empty for normal clustering)</p>
</dd>
<dt><code>maxNoClusters</code>:</dt><dd><p>maximum number of clusters in the 
cluster hierarchy, i.e. it
contains clusterings with 1 - <code>maxNoClusters</code> clusters.</p>
</dd>
<dt><code>exemplars</code>:</dt><dd><p>list of length <code>maxNoClusters</code>;
the <code>i</code>-th component of the list is a vector of <code>i</code>
exemplars (corresponding to the level with <code>i</code> clusters).</p>
</dd>
<dt><code>clusters</code>:</dt><dd><p>list of length <code>maxNoClusters</code>;
the <code>i</code>-th component of <code>clusters</code> is a list of <code>i</code>
clusters, each of which is a vector of sample indices.</p>
</dd>
<dt><code>merge</code>:</dt><dd><p>a <code>maxNoClusters-1</code> by 2 matrix that
contains the merging hierarchy; fully analogous to the
slot <code>merge</code> in the class <code><a href="stats.html#topic+hclust">hclust</a></code>.</p>
</dd>
<dt><code>height</code>:</dt><dd><p>a vector of length <code>maxNoClusters-1</code> that
contains the merging objective of each merge; largely analogous to
the slot <code>height</code> in the class <code><a href="stats.html#topic+hclust">hclust</a></code> except
that the slot <code>height</code> in <code>AggExResult</code> objects is
supposed to be non-increasing, since <code><a href="#topic+aggExCluster">aggExCluster</a></code>
is based on similarities, whereas <code><a href="stats.html#topic+hclust">hclust</a></code> uses
dissimilarities.</p>
</dd>
<dt><code>order</code>:</dt><dd><p>a vector containing a permutation of indices
that can be used for plotting proper dendrograms without crossing
branches; fully analogous to the
slot <code>order</code> in the class <code><a href="stats.html#topic+hclust">hclust</a></code>.</p>
</dd>
<dt><code>labels</code>:</dt><dd><p>a character vector containing labels of
clustered objects used for plotting dendrograms.</p>
</dd> 
<dt><code>sim</code>:</dt><dd><p>similarity matrix; only available if
<code><a href="#topic+aggExCluster">aggExCluster</a></code> was called with similarity
function and <code>includeSim=TRUE</code>.</p>
</dd>
<dt><code>call</code>:</dt><dd><p>method call used to produce this
clustering result</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x="AggExResult")</code>: see
<code><a href="#topic+plot-methods">plot-methods</a></code></p>
</dd>
<dt>plot</dt><dd><p><code>signature(x="AggExResult", y="matrix")</code>: see
<code><a href="#topic+plot-methods">plot-methods</a></code></p>
</dd>
<dt>heatmap</dt><dd><p><code>signature(x="AggExResult")</code>: see
<code><a href="#topic+heatmap-methods">heatmap-methods</a></code></p>
</dd>
<dt>heatmap</dt><dd><p><code>signature(x="AggExResult", y="matrix")</code>: see
<code><a href="#topic+heatmap-methods">heatmap-methods</a></code></p>
</dd>
<dt>show</dt><dd><p><code>signature(object="AggExResult")</code>: see
<code><a href="#topic+show-methods">show-methods</a></code></p>
</dd>
<dt>cutree</dt><dd><p><code>signature(object="AggExResult", k="ANY",
	h="ANY")</code>: see <code><a href="#topic+cutree-methods">cutree-methods</a></code></p>
</dd>
<dt>length</dt><dd><p><code>signature(x="AggExResult")</code>: gives the number of
clustering levels in the clustering result.</p>
</dd>
<dt>as.hclust</dt><dd><p><code>signature(x="AggExResult")</code>: see
<code><a href="methods.html#topic+coerce-methods">coerce-methods</a></code></p>
</dd>
<dt>as.dendrogram</dt><dd><p><code>signature(object="AggExResult")</code>: see
<code><a href="methods.html#topic+coerce-methods">coerce-methods</a></code></p>
</dd>
</dl>



<h3>Accessors</h3>

<p>In the following code snippets, <code>x</code> is an <code>AggExResult</code> object.
</p>

<dl>
<dt>[[</dt><dd><p><code>signature(x="AggExResult", i="index", j="missing")</code>:
<code>x[[i]]</code> returns an object of class
<code><a href="#topic+ExClust-class">ExClust</a></code> corresponding to the clustering level
with <code>i</code> clusters; synonymous to <code><a href="#topic+cutree">cutree</a>(x, i)</code>.
</p>
</dd>
<dt>[</dt><dd><p><code>signature(x="AggExResult", i="index", j="missing",
      drop="missing")</code>: <code>x[i]</code> returns a list of <code><a href="#topic+ExClust-class">ExClust</a></code>
objects with all clustering levels specified in vector <code>i</code>.
So, the list has as many components as the argument <code>i</code> has
elements. A list is returned even if <code>i</code> is a single level.
</p>
</dd>
<dt>similarity</dt><dd><p><code>signature(x="AggExResult")</code>: gives the similarity
matrix.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ulrich Bodenhofer, Andreas Kothmeier &amp; Johannes Palme
<a href="mailto:apcluster@bioinf.jku.at">apcluster@bioinf.jku.at</a></p>


<h3>References</h3>

<p><a href="http://www.bioinf.jku.at/software/apcluster/">http://www.bioinf.jku.at/software/apcluster/</a>
</p>
<p>Bodenhofer, U., Kothmeier, A., and Hochreiter, S. (2011)
APCluster: an R package for affinity propagation clustering.
<em>Bioinformatics</em> <b>27</b>, 2463-2464.
DOI: <a href="https://doi.org/10.1093/bioinformatics/btr406">doi:10.1093/bioinformatics/btr406</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aggExCluster">aggExCluster</a></code>, <code><a href="#topic+show-methods">show-methods</a></code>,
<code><a href="#topic+plot-methods">plot-methods</a></code>, <code><a href="#topic+cutree-methods">cutree-methods</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## create two Gaussian clouds
cl1 &lt;- cbind(rnorm(50, 0.2, 0.05), rnorm(50, 0.8, 0.06))
cl2 &lt;- cbind(rnorm(50, 0.7, 0.08), rnorm(50, 0.3, 0.05))
x &lt;- rbind(cl1, cl2)

## compute similarity matrix (negative squared Euclidean)
sim &lt;- negDistMat(x, r=2)

## compute agglomerative clustering from scratch
aggres1 &lt;- aggExCluster(sim)

## show results
show(aggres1)

## plot dendrogram
plot(aggres1)

## plot heatmap along with dendrogram
heatmap(aggres1, sim)

## plot level with two clusters
plot(aggres1, x, k=2)

## run affinity propagation
apres &lt;- apcluster(sim, q=0.7)

## create hierarchy of clusters determined by affinity propagation
aggres2 &lt;- aggExCluster(sim, apres)

## show results
show(aggres2)

## plot dendrogram
plot(aggres2)

## plot heatmap
heatmap(aggres2, sim)

## plot level with two clusters
plot(aggres2, x, k=2)
</code></pre>

<hr>
<h2 id='apcluster'>Affinity Propagation</h2><span id='topic+apcluster'></span><span id='topic+apcluster-methods'></span><span id='topic+apcluster+2Cmatrix+2Cmissing-method'></span><span id='topic+apcluster+2CdgTMatrix+2Cmissing-method'></span><span id='topic+apcluster+2CsparseMatrix+2Cmissing-method'></span><span id='topic+apcluster+2CMatrix+2Cmissing-method'></span><span id='topic+apcluster+2Ccharacter+2CANY-method'></span><span id='topic+apcluster+2Cfunction+2CANY-method'></span>

<h3>Description</h3>

<p>Runs affinity propagation clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix,missing'
apcluster(s, x, p=NA, q=NA, maxits=1000,
    convits=100, lam=0.9, includeSim=FALSE, details=FALSE,
    nonoise=FALSE, seed=NA)
## S4 method for signature 'dgTMatrix,missing'
apcluster(s, x, p=NA, q=NA, maxits=1000,
    convits=100, lam=0.9, includeSim=FALSE, details=FALSE,
    nonoise=FALSE, seed=NA)
## S4 method for signature 'sparseMatrix,missing'
apcluster(s, x, ...)
## S4 method for signature 'Matrix,missing'
apcluster(s, x, ...)
## S4 method for signature 'character,ANY'
apcluster(s, x, p=NA, q=NA, maxits=1000,
    convits=100, lam=0.9, includeSim=TRUE, details=FALSE,
    nonoise=FALSE, seed=NA, ...)
## S4 method for signature 'function,ANY'
apcluster(s, x, p=NA, q=NA, maxits=1000,
    convits=100, lam=0.9, includeSim=TRUE, details=FALSE,
    nonoise=FALSE, seed=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apcluster_+3A_s">s</code></td>
<td>
<p>an <code class="reqn">l\times l</code> similarity matrix or a similarity
function either specified as the name of a package-provided
similarity function as character string or a user provided
function object. <code>s</code> may also be a sparse matrix according to
the <span class="pkg">Matrix</span> package. Internally, <code>apcluster</code> uses the
<code><a href="Matrix.html#topic+dgTMatrix-class">dgTMatrix</a></code> class; all other sparse matrices are
cast to this class (if possible, otherwise the function quits with
an error). If <code>s</code> is any other object of class
<code><a href="Matrix.html#topic+Matrix-class">Matrix</a></code>, <code>s</code> is cast to a regular matrix
internally (if possible, otherwise the function quits with
an error).</p>
</td></tr> 
<tr><td><code id="apcluster_+3A_x">x</code></td>
<td>
<p>input data to be clustered; if <code>x</code> is a matrix or data
frame, rows are interpreted as samples and columns are 
interpreted as features; apart from matrices or data frames, 
<code>x</code> may be any other structured data type that
contains multiple data items - provided that an appropriate
<code><a href="base.html#topic+length">length</a></code> function is available that
returns the number of items</p>
</td></tr>
<tr><td><code id="apcluster_+3A_p">p</code></td>
<td>
<p>input preference; can be a vector that specifies
individual preferences for each data point. If scalar,
the same value is used for all data points. If <code>NA</code>,
exemplar preferences are initialized according to the
distribution of non-Inf values in <code>s</code>. How this
is done is controlled by the parameter <code>q</code>.</p>
</td></tr>
<tr><td><code id="apcluster_+3A_q">q</code></td>
<td>
<p>if <code>p=NA</code>, exemplar preferences are initialized
according to the distribution of non-Inf values in <code>s</code>.
If <code>q=NA</code>, exemplar preferences are set to the median
of non-Inf values in <code>s</code>. If <code>q</code> is a value
between 0 and 1, the sample quantile with threshold
<code>q</code> is used, whereas <code>q=0.5</code> again results in
the median.</p>
</td></tr>
<tr><td><code id="apcluster_+3A_maxits">maxits</code></td>
<td>
<p>maximal number of iterations that should be executed</p>
</td></tr>
<tr><td><code id="apcluster_+3A_convits">convits</code></td>
<td>
<p>the algorithm terminates if the examplars have not
changed for <code>convits</code> iterations</p>
</td></tr>
<tr><td><code id="apcluster_+3A_lam">lam</code></td>
<td>
<p>damping factor; should be a value in the range [0.5, 1);
higher values correspond to heavy damping which may be
needed if oscillations occur</p>
</td></tr>
<tr><td><code id="apcluster_+3A_includesim">includeSim</code></td>
<td>
<p>if <code>TRUE</code>, the similarity matrix (either computed
internally or passed via the <code>s</code> argument) is stored to the
slot <code>sim</code> of the returned
<code><a href="#topic+APResult-class">APResult</a></code> object. The default is <code>FALSE</code>
if <code>apcluster</code> has been called for a similarity matrix,
otherwise the default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="apcluster_+3A_details">details</code></td>
<td>
<p>if <code>TRUE</code>, more detailed information about the
algorithm's progress is stored in the output object
(see <code><a href="#topic+APResult-class">APResult</a></code>)</p>
</td></tr>
<tr><td><code id="apcluster_+3A_nonoise">nonoise</code></td>
<td>
<p><code>apcluster</code> adds a small amount of noise to
<code>s</code> to prevent degenerate cases; if <code>TRUE</code>,
this is disabled</p>
</td></tr>
<tr><td><code id="apcluster_+3A_seed">seed</code></td>
<td>
<p>for reproducibility, the seed of the random number
generator can be set to a fixed value before
adding noise (see above), if <code>NA</code>, the seed remains
unchanged</p>
</td></tr>
<tr><td><code id="apcluster_+3A_...">...</code></td>
<td>
<p>for the methods with signatures <code>character,ANY</code> and
<code>function,ANY</code>, all other arguments are passed to the selected 
similarity function as they are; for the methods with signatures
<code>Matrix,missing</code> and <code>sparseMatrix,missing</code>, further
arguments are passed on to the <code>apcluster</code> methods with
signatures <code>Matrix,missing</code> and <code>dgTMatrix,missing</code>,
respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Affinity Propagation clusters data using a set of
real-valued pairwise data point similarities as input. Each cluster
is represented by a cluster center data point (the so-called exemplar). 
The method is iterative and searches for clusters maximizing
an objective function called net similarity.
</p>
<p>When called with a similarity matrix as input (which may also be a
sparse matrix according to the <span class="pkg">Matrix</span> package), the function performs
AP clustering. When called with the name of a package-provided
similarity function or a user-provided similarity function object and 
input data, the function first computes the similarity matrix before
performing AP clustering. The similarity
matrix is returned for later use as part of the
<code><a href="#topic+APResult-class">APResult</a></code>
object depending on whether <code>includeSim</code> was set to <code>TRUE</code> (see
argument description above).
</p>
<p>Apart from minor adaptations and optimizations, the AP
clustering functionality of the function <code>apcluster</code> is 
largely analogous to Frey's and Dueck's Matlab code
(see <a href="https://psi.toronto.edu/research/affinity-propagation-clustering-by-message-passing/">https://psi.toronto.edu/research/affinity-propagation-clustering-by-message-passing/</a>).
</p>
<p>The new argument <code>q</code> allows for better controlling the number of
clusters without knowing the distribution of similarity
values. A meaningful range for the parameter <code>p</code> can be determined
using the function <code><a href="#topic+preferenceRange">preferenceRange</a></code>. Alternatively, a
certain fixed number of clusters may be desirable. For this purpose,
the function <code><a href="#topic+apclusterK">apclusterK</a></code> is available.
</p>


<h3>Value</h3>

<p>Upon successful completion, the function returns an
<code><a href="#topic+APResult-class">APResult</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Ulrich Bodenhofer, Andreas Kothmeier, Johannes Palme &amp;
Chrats Melkonian
<a href="mailto:apcluster@bioinf.jku.at">apcluster@bioinf.jku.at</a></p>


<h3>References</h3>

<p><a href="http://www.bioinf.jku.at/software/apcluster/">http://www.bioinf.jku.at/software/apcluster/</a>
</p>
<p>Frey, B. J. and Dueck, D. (2007) Clustering by passing messages
between data points. <em>Science</em> <b>315</b>, 972-976.
DOI: <a href="https://doi.org/10.1126/science.1136800">doi:10.1126/science.1136800</a>.
</p>
<p>Bodenhofer, U., Kothmeier, A., and Hochreiter, S. (2011)
APCluster: an R package for affinity propagation clustering.
<em>Bioinformatics</em> <b>27</b>, 2463-2464.
DOI: <a href="https://doi.org/10.1093/bioinformatics/btr406">doi:10.1093/bioinformatics/btr406</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+APResult">APResult</a></code>, <code><a href="#topic+show-methods">show-methods</a></code>,
<code><a href="#topic+plot-methods">plot-methods</a></code>, <code><a href="#topic+labels-methods">labels-methods</a></code>,
<code><a href="#topic+preferenceRange">preferenceRange</a></code>, <code><a href="#topic+apclusterL-methods">apclusterL-methods</a></code>, 
<code><a href="#topic+apclusterK">apclusterK</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## create two Gaussian clouds
cl1 &lt;- cbind(rnorm(100, 0.2, 0.05), rnorm(100, 0.8, 0.06))
cl2 &lt;- cbind(rnorm(50, 0.7, 0.08), rnorm(50, 0.3, 0.05))
x &lt;- rbind(cl1, cl2)

## compute similarity matrix and run affinity propagation 
## (p defaults to median of similarity)
apres &lt;- apcluster(negDistMat(r=2), x, details=TRUE)

## show details of clustering results
show(apres)

## plot clustering result
plot(apres, x)

## plot heatmap
heatmap(apres)

## run affinity propagation with default preference of 10% quantile
## of similarities; this should lead to a smaller number of clusters
## reuse similarity matrix from previous run
apres &lt;- apcluster(s=apres@sim, q=0.1)
show(apres)
plot(apres, x)

## now try the same with RBF kernel
sim &lt;- expSimMat(x, r=2)
apres &lt;- apcluster(s=sim, q=0.2)
show(apres)
plot(apres, x)

## create sparse similarity matrix
cl1 &lt;- cbind(rnorm(20, 0.2, 0.05), rnorm(20, 0.8, 0.06))
cl2 &lt;- cbind(rnorm(20, 0.7, 0.08), rnorm(20, 0.3, 0.05))
x &lt;- rbind(cl1, cl2)

sim &lt;- negDistMat(x, r=2)
ssim &lt;- as.SparseSimilarityMatrix(sim, lower=-0.2)

## run apcluster() on the sparse similarity matrix
apres &lt;- apcluster(ssim, q=0)
apres
</code></pre>

<hr>
<h2 id='apclusterDemo'>Affinity Propagation Demo</h2><span id='topic+apclusterDemo'></span>

<h3>Description</h3>

<p>Runs affinity propagation demo for randomly generated data set
according to Frey and Dueck
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apclusterDemo(l=100, d=2, seed=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apclusterDemo_+3A_l">l</code></td>
<td>
<p>number of data points to be generated</p>
</td></tr>
<tr><td><code id="apclusterDemo_+3A_d">d</code></td>
<td>
<p>dimension of data to be created</p>
</td></tr>
<tr><td><code id="apclusterDemo_+3A_seed">seed</code></td>
<td>
<p>for reproducibility, the seed of the random number
generator can be set to a fixed value; if <code>NA</code>,
the seed remains unchanged</p>
</td></tr>
<tr><td><code id="apclusterDemo_+3A_...">...</code></td>
<td>
<p>all other arguments are passed on to 
<code><a href="#topic+apcluster">apcluster</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>apclusterDemo</code> creates <code>l</code> <code>d</code>-dimensional
data points that are uniformly distributed in <code class="reqn">[0,1]^d</code>. Affinity
propagation is executed for this data set with default parameters.
Alternative settings can be passed to <code><a href="#topic+apcluster">apcluster</a></code> with
additional arguments. After completion of affinity propagation,
the results are shown and the performance measures are plotted.
</p>
<p>This function corresponds to the demo function in the original
Matlab code of Frey and Dueck. We warn the user, however, that
uniformly distributed data are not necessarily ideal for demonstrating
clustering, as there can never be real clusters in uniformly
distributed data - all clusters found must be random artefacts.
</p>


<h3>Value</h3>

<p>Upon successful completion, the function returns an invisible list
with three components. The first is the data set that has been
created, the second is the similarity matrix, and the third is an
<code><a href="#topic+APResult-class">APResult</a></code> object with the clustering results (see
examples below).
</p>


<h3>Author(s)</h3>

<p>Ulrich Bodenhofer, Andreas Kothmeier &amp; Johannes Palme
<a href="mailto:apcluster@bioinf.jku.at">apcluster@bioinf.jku.at</a></p>


<h3>References</h3>

<p><a href="http://www.bioinf.jku.at/software/apcluster/">http://www.bioinf.jku.at/software/apcluster/</a>
</p>
<p>Frey, B. J. and Dueck, D. (2007) Clustering by passing messages
between data points. <em>Science</em> <b>315</b>, 972-976.
DOI: <a href="https://doi.org/10.1126/science.1136800">doi:10.1126/science.1136800</a>.
</p>
<p>Bodenhofer, U., Kothmeier, A., and Hochreiter, S. (2011)
APCluster: an R package for affinity propagation clustering.
<em>Bioinformatics</em> <b>27</b>, 2463-2464.
DOI: <a href="https://doi.org/10.1093/bioinformatics/btr406">doi:10.1093/bioinformatics/btr406</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+APResult-class">APResult</a></code>, <code><a href="#topic+plot-methods">plot-methods</a></code>,
<code><a href="#topic+apcluster">apcluster</a></code>, <code><a href="#topic+apclusterL">apclusterL</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## create random data set and run affinity propagation
apd &lt;- apclusterDemo()

## plot clustering result along with data set
plot(apd[[3]], apd[[1]])
</code></pre>

<hr>
<h2 id='apclusterK'>Affinity Propagation for Pre-defined Number of Clusters</h2><span id='topic+apclusterK'></span><span id='topic+apclusterK-methods'></span><span id='topic+apclusterK+2Cmatrix+2Cmissing-method'></span><span id='topic+apclusterK+2CMatrix+2Cmissing-method'></span><span id='topic+apclusterK+2CdgTMatrix+2Cmissing-method'></span><span id='topic+apclusterK+2CsparseMatrix+2Cmissing-method'></span><span id='topic+apclusterK+2Ccharacter+2CANY-method'></span><span id='topic+apclusterK+2Cfunction+2CANY-method'></span>

<h3>Description</h3>

<p>Runs affinity propagation clustering for a given similarity matrix
adjusting input preferences iteratively in order to achieve a desired
number of clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix,missing'
apclusterK(s, x, K, prc=10, bimaxit=20, exact=FALSE,
     maxits=1000, convits=100, lam=0.9, includeSim=FALSE, details=FALSE,
     nonoise=FALSE, seed=NA, verbose=TRUE)
## S4 method for signature 'Matrix,missing'
apclusterK(s, x, K, ...)
## S4 method for signature 'dgTMatrix,missing'
apclusterK(s, x, K, prc=10, bimaxit=20,
     exact=FALSE, maxits=1000, convits=100, lam=0.9, includeSim=FALSE,
     details=FALSE, nonoise=FALSE, seed=NA, verbose=TRUE)
## S4 method for signature 'sparseMatrix,missing'
apclusterK(s, x, K, ...)
## S4 method for signature 'function,ANY'
apclusterK(s, x, K, prc=10, bimaxit=20, exact=FALSE,
     maxits=1000, convits=100, lam=0.9, includeSim=TRUE, details=FALSE,
     nonoise=FALSE, seed=NA, verbose=TRUE, ...)
## S4 method for signature 'character,ANY'
apclusterK(s, x, K, prc=10, bimaxit=20, exact=FALSE,
     maxits=1000, convits=100, lam=0.9, includeSim=TRUE, details=FALSE,
     nonoise=FALSE, seed=NA, verbose=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apclusterK_+3A_s">s</code></td>
<td>
<p>an <code class="reqn">l\times l</code> similarity matrix in sparse or dense
format or a similarity
function either specified as the name of a package-provided
similarity function as character string or a user provided
function object.</p>
</td></tr> 
<tr><td><code id="apclusterK_+3A_x">x</code></td>
<td>
<p>input data to be clustered; if <code>x</code> is a matrix or data
frame, rows are interpreted as samples and columns are 
interpreted as features; apart from matrices or data frames, 
<code>x</code> may be any other structured data type that
contains multiple data items - provided that an appropriate
<code><a href="base.html#topic+length">length</a></code> function is available that
returns the number of items</p>
</td></tr>
<tr><td><code id="apclusterK_+3A_k">K</code></td>
<td>
<p>desired number of clusters</p>
</td></tr>
<tr><td><code id="apclusterK_+3A_prc">prc</code></td>
<td>
<p>the algorithm stops if the number of clusters does not
deviate more than prc percent from desired value K; set to 0 if you
want to have exactly K clusters</p>
</td></tr>
<tr><td><code id="apclusterK_+3A_bimaxit">bimaxit</code></td>
<td>
<p>maximum number of bisection steps to perform; note that
no warning is issued if the number of clusters is still not in
the desired range</p>
</td></tr>
<tr><td><code id="apclusterK_+3A_exact">exact</code></td>
<td>
<p>flag indicating whether or not to compute the initial
preference range exactly (see <code><a href="#topic+preferenceRange">preferenceRange</a></code>)</p>
</td></tr>
<tr><td><code id="apclusterK_+3A_maxits">maxits</code></td>
<td>
<p>maximal number of iterations that <code><a href="#topic+apcluster">apcluster</a></code>
should execute</p>
</td></tr>
<tr><td><code id="apclusterK_+3A_convits">convits</code></td>
<td>
<p><code><a href="#topic+apcluster">apcluster</a></code> terminates if the examplars have not
changed for <code>convits</code> iterations</p>
</td></tr>
<tr><td><code id="apclusterK_+3A_lam">lam</code></td>
<td>
<p>damping factor for  <code><a href="#topic+apcluster">apcluster</a></code>; should be a value in
the range [0.5, 1);
higher values correspond to heavy damping which may be
needed if oscillations occur</p>
</td></tr>
<tr><td><code id="apclusterK_+3A_includesim">includeSim</code></td>
<td>
<p>if <code>TRUE</code>, the similarity matrix (either computed
internally or passed via the <code>s</code> argument) is stored to the
slot <code>sim</code> of the returned
<code><a href="#topic+APResult-class">APResult</a></code> object. The default is <code>FALSE</code>
if <code>apclusterK</code> has been called for a similarity matrix,
otherwise the default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="apclusterK_+3A_details">details</code></td>
<td>
<p>if <code>TRUE</code>, more detailed information about the
algorithm's progress is stored in the output object
(see <code><a href="#topic+APResult-class">APResult</a></code>)</p>
</td></tr>
<tr><td><code id="apclusterK_+3A_nonoise">nonoise</code></td>
<td>
<p><code><a href="#topic+apcluster">apcluster</a></code> adds a small amount of noise to
<code>s</code> to prevent degenerate cases; if <code>TRUE</code>,
this is disabled</p>
</td></tr>
<tr><td><code id="apclusterK_+3A_seed">seed</code></td>
<td>
<p>for reproducibility, the seed of the random number
generator can be set to a fixed value, if <code>NA</code>,
the seed remains unchanged</p>
</td></tr>
<tr><td><code id="apclusterK_+3A_verbose">verbose</code></td>
<td>
<p>flag indicating whether status information should be
displayed during bisection</p>
</td></tr>
<tr><td><code id="apclusterK_+3A_...">...</code></td>
<td>
<p>for the methods with signatures <code>character,ANY</code> and
<code>function,ANY</code>, all other arguments are passed to the selected 
similarity function as they are; for the methods with signatures
<code>Matrix,missing</code> and <code>sparseMatrix,missing</code>, further
arguments are passed on to the <code>apclusterK</code> methods with
signatures <code>Matrix,missing</code> and <code>dgTMatrix,missing</code>,
respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>apclusterK</code> first runs <code><a href="#topic+preferenceRange">preferenceRange</a></code> to determine
the range of meaningful choices of the input preference <code>p</code>. Then
it decreases <code>p</code> exponentially for a few iterations to obtain a
good initial guess for <code>p</code>. If the number of clusters is still
too far from the desired goal, bisection is applied.
</p>
<p>When called with a similarity matrix as input, the function performs
the procedure described above. When called with the name of a package-provided
similarity function or a user-provided similarity function object and 
input data, the function first computes the similarity matrix before
running <code>apclusterK</code> on this similarity matrix. The similarity
matrix is returned for later use as part of the APResult object
depending on whether <code>includeSim</code> was set to <code>TRUE</code> (see
argument description above).
</p>
<p>Apart from minor adaptations and optimizations, the implementation is
largely analogous to Frey's and Dueck's Matlab code
(see <a href="https://psi.toronto.edu/research/affinity-propagation-clustering-by-message-passing/">https://psi.toronto.edu/research/affinity-propagation-clustering-by-message-passing/</a>).
</p>


<h3>Value</h3>

<p>Upon successful completion, the function returns a
<code><a href="#topic+APResult-class">APResult</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Ulrich Bodenhofer &amp; Andreas Kothmeier
<a href="mailto:apcluster@bioinf.jku.at">apcluster@bioinf.jku.at</a></p>


<h3>References</h3>

<p><a href="http://www.bioinf.jku.at/software/apcluster/">http://www.bioinf.jku.at/software/apcluster/</a>
</p>
<p>Frey, B. J. and Dueck, D. (2007) Clustering by passing messages
between data points. <em>Science</em> <b>315</b>, 972-976.
DOI: <a href="https://doi.org/10.1126/science.1136800">doi:10.1126/science.1136800</a>.
</p>
<p>Bodenhofer, U., Kothmeier, A., and Hochreiter, S. (2011)
APCluster: an R package for affinity propagation clustering.
<em>Bioinformatics</em> <b>27</b>, 2463-2464.
DOI: <a href="https://doi.org/10.1093/bioinformatics/btr406">doi:10.1093/bioinformatics/btr406</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apcluster">apcluster</a></code>, <code><a href="#topic+preferenceRange">preferenceRange</a></code>,
<code><a href="#topic+APResult-class">APResult</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## create three Gaussian clouds
cl1 &lt;- cbind(rnorm(70, 0.2, 0.05), rnorm(70, 0.8, 0.06))
cl2 &lt;- cbind(rnorm(50, 0.7, 0.08), rnorm(50, 0.3, 0.05))
cl3 &lt;- cbind(rnorm(60, 0.8, 0.04), rnorm(60, 0.8, 0.05))
x &lt;- rbind(cl1, cl2, cl3)

## run affinity propagation such that 3 clusters are obtained
apres &lt;- apclusterK(negDistMat(r=2), x, K=3)

## show details of clustering results
show(apres)

## plot clustering result
plot(apres, x)

## create sparse similarity matrix
cl1 &lt;- cbind(rnorm(20, 0.2, 0.05), rnorm(20, 0.8, 0.06))
cl2 &lt;- cbind(rnorm(20, 0.7, 0.08), rnorm(20, 0.3, 0.05))
x &lt;- rbind(cl1, cl2)

sim &lt;- negDistMat(x, r=2)
ssim &lt;- as.SparseSimilarityMatrix(sim, lower=-0.2)

## run apcluster() on the sparse similarity matrix
apres &lt;- apclusterK(ssim, K=2)
apres
</code></pre>

<hr>
<h2 id='apclusterL'>Leveraged Affinity Propagation</h2><span id='topic+apclusterL'></span><span id='topic+apclusterL-methods'></span><span id='topic+apclusterL+2Cmatrix+2Cmissing-method'></span><span id='topic+apclusterL+2Ccharacter+2CANY-method'></span><span id='topic+apclusterL+2Cfunction+2CANY-method'></span>

<h3>Description</h3>

<p>Runs leveraged affinity propagation clustering</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix,missing'
apclusterL(s, x,
          sel, p=NA, q=NA, maxits=1000, convits=100, lam=0.9,
          includeSim=FALSE, nonoise=FALSE, seed=NA)
## S4 method for signature 'character,ANY'
apclusterL(s, x, 
          frac, sweeps, p=NA, q=NA, maxits=1000, convits=100, lam=0.9,
          includeSim=TRUE, nonoise=FALSE, seed=NA, ...)
## S4 method for signature 'function,ANY'
apclusterL(s, x,
          frac, sweeps, p=NA, q=NA, maxits=1000, convits=100, lam=0.9,
          includeSim=TRUE, nonoise=FALSE, seed=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apclusterL_+3A_s">s</code></td>
<td>
<p>an <code class="reqn">l \times length(sel)</code> similarity 
matrix or a similarity function either specified as the name of 
a package provided similarity function as character string or a 
user provided function object for similarity calculation.
If <code>s</code> is supplied as a similarity matrix, the columns
must correspond to the same sub-selection of samples as
specified in the <code>sel</code> argument and must be in the same
increasing order.
For a package- or user-defined similarity function, additional 
parameters can be specified as appropriate for the chosen method 
and are passed on to the similarity function via the <code>...</code> 
argument (see below). See the package vignette for a non-trivial 
example or supplying a user-defined similarity measure.</p>
</td></tr>
<tr><td><code id="apclusterL_+3A_x">x</code></td>
<td>
<p>input data to be clustered; if <code>x</code> is a matrix or data
frame, rows are interpreted as samples and columns are interpreted 
as features; apart from matrices or data frames, <code>x</code> may be 
any other structured data type that contains multiple data items - 
provided that an appropriate <code><a href="base.html#topic+length">length</a></code> 
function is available that returns the number of items</p>
</td></tr>
<tr><td><code id="apclusterL_+3A_frac">frac</code></td>
<td>
<p>fraction of samples that should be used for leveraged 
clustering. The similarity matrix will be generated for
all samples against a random fraction of the samples as 
specified by this parameter.</p>
</td></tr>
<tr><td><code id="apclusterL_+3A_sweeps">sweeps</code></td>
<td>
<p>number of sweeps of leveraged clustering performed 
with changing randomly selected subset of samples.</p>
</td></tr>
<tr><td><code id="apclusterL_+3A_sel">sel</code></td>
<td>
<p>selected sample indices; a vector containing the 
sample indices of the sample subset used for leveraged 
AP clustering in increasing order.</p>
</td></tr>
<tr><td><code id="apclusterL_+3A_p">p</code></td>
<td>
<p>input preference; can be a vector that specifies
individual preferences for each data point. If scalar,
the same value is used for all data points. If <code>NA</code>,
exemplar preferences are initialized according to the
distribution of non-Inf values in <code>s</code>. How this
is done is controlled by the parameter <code>q</code>. See also
<code><a href="#topic+apcluster">apcluster</a></code>.</p>
</td></tr>
<tr><td><code id="apclusterL_+3A_q">q</code></td>
<td>
<p>if <code>p=NA</code>, exemplar preferences are initialized
according to the distribution of non-Inf values in <code>s</code>.
If <code>q=NA</code>, exemplar preferences are set to the median
of non-Inf values in <code>s</code>. If <code>q</code> is a value
between 0 and 1, the sample quantile with threshold
<code>q</code> is used, whereas <code>q=0.5</code> again results in
the median. See also <code><a href="#topic+apcluster">apcluster</a></code>.</p>
</td></tr>
<tr><td><code id="apclusterL_+3A_maxits">maxits</code></td>
<td>
<p>maximal number of iterations that should be executed</p>
</td></tr>
<tr><td><code id="apclusterL_+3A_convits">convits</code></td>
<td>
<p>the algorithm terminates if the examplars have not
changed for <code>convits</code> iterations</p>
</td></tr>
<tr><td><code id="apclusterL_+3A_lam">lam</code></td>
<td>
<p>damping factor; should be a value in the range [0.5, 1);
higher values correspond to heavy damping which may be needed 
if oscillations occur</p>
</td></tr>
<tr><td><code id="apclusterL_+3A_includesim">includeSim</code></td>
<td>
<p>if <code>TRUE</code>, the similarity matrix (either computed
internally or passed via the <code>s</code> argument) is stored to the
slot <code>sim</code> of the returned
<code><a href="#topic+APResult-class">APResult</a></code> object. The default is <code>FALSE</code>
if <code>apclusterL</code> has been called for a similarity matrix,
otherwise the default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="apclusterL_+3A_nonoise">nonoise</code></td>
<td>
<p><code>apcluster</code> adds a small amount of noise to
<code>s</code> to prevent degenerate cases; if <code>TRUE</code>,
this is disabled</p>
</td></tr>
<tr><td><code id="apclusterL_+3A_seed">seed</code></td>
<td>
<p>for reproducibility, the seed of the random number
generator can be set to a fixed value before
adding noise (see above), if <code>NA</code>, the seed remains
unchanged</p>
</td></tr>
<tr><td><code id="apclusterL_+3A_...">...</code></td>
<td>
<p>all other arguments are passed to the selected 
similarity function as they are; note that possible name conflicts between
arguments of <code>apcluster</code> and arguments of the similarity
function may occur; therefore, we recommend to write user-defined
similarity functions without additional parameters or to use
closures to fix parameters (such as, in the example below);</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Affinity Propagation clusters data using a set of
real-valued pairwise similarities as input. Each cluster
is represented by a representative cluster center (the so-called exemplar). 
The method is iterative and searches for clusters maximizing
an objective function called net similarity.
</p>
<p>Leveraged Affinity Propagation reduces dynamic and static load for 
large datasets. Only a subset of the samples are considered
in the clustering process assuming that they provide already enough
information about the cluster structure.
</p>
<p>When called with input data and the name of a package provided or a user 
provided similarity function the function selects a random sample subset
according to the <code>frac</code> parameter, calculates a rectangular 
similarity matrix of all samples against this subset and repeats 
affinity propagation <code>sweep</code> times. A new sample subset is used 
for each repetition. The clustering result of the sweep with the highest 
net similarity is returned. Any parameters specific to the chosen 
method of similarity calculation can be passed to <code>apcluster</code> 
in addition to the parameters described above. The similarity matrix 
for the best trial is also returned in the result object when requested 
by the user (argument <code>includeSim</code>).
</p>
<p>When called with a rectangular similarity matrix (which represents a 
column subset of the full similarity matrix) the function performs 
AP clustering on this similarity matrix. The information 
about the selected samples is passed to clustering with the 
parameter <code>sel</code>. This function is only needed when the user needs full
control of distance calculation or sample subset selection.
</p>
<p>Apart from minor adaptations and optimizations, the implementation 
of the function <code>apclusterL</code>
is largely analogous to Frey's and Dueck's Matlab code
(see <a href="https://psi.toronto.edu/research/affinity-propagation-clustering-by-message-passing/">https://psi.toronto.edu/research/affinity-propagation-clustering-by-message-passing/</a>).</p>


<h3>Value</h3>

<p>Upon successful completion, both functions returns an
<code><a href="#topic+APResult-class">APResult</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Ulrich Bodenhofer, Andreas Kothmeier &amp; Johannes Palme
<a href="mailto:apcluster@bioinf.jku.at">apcluster@bioinf.jku.at</a></p>


<h3>References</h3>

<p><a href="http://www.bioinf.jku.at/software/apcluster/">http://www.bioinf.jku.at/software/apcluster/</a>
</p>
<p>Frey, B. J. and Dueck, D. (2007) Clustering by passing messages
between data points. <em>Science</em> <b>315</b>, 972-976.
DOI: <a href="https://doi.org/10.1126/science.1136800">doi:10.1126/science.1136800</a>.
</p>
<p>Bodenhofer, U., Kothmeier, A., and Hochreiter, S. (2011)
APCluster: an R package for affinity propagation clustering.
<em>Bioinformatics</em> <b>27</b>, 2463-2464.
DOI: <a href="https://doi.org/10.1093/bioinformatics/btr406">doi:10.1093/bioinformatics/btr406</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+APResult-class">APResult</a></code>, <code><a href="#topic+show-methods">show-methods</a></code>,
<code><a href="#topic+plot-methods">plot-methods</a></code>, <code><a href="#topic+labels-methods">labels-methods</a></code>,
<code><a href="#topic+preferenceRange">preferenceRange</a></code>, <code><a href="#topic+apcluster-methods">apcluster-methods</a></code>,
<code><a href="#topic+apclusterK">apclusterK</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## create two Gaussian clouds
cl1 &lt;- cbind(rnorm(150, 0.2, 0.05), rnorm(150, 0.8, 0.06))
cl2 &lt;- cbind(rnorm(100, 0.7, 0.08), rnorm(100, 0.3, 0.05))
x &lt;- rbind(cl1, cl2)

## leveraged apcluster
apres &lt;- apclusterL(negDistMat(r=2), x, frac=0.2, sweeps=3, p=-0.2)

## show details of leveraged clustering results
show(apres)

## plot leveraged clustering result
plot(apres, x)

## plot heatmap of clustering result
heatmap(apres)

## show net similarities of single sweeps
apres@netsimLev

## show samples on which best sweep was based
apres@sel
</code></pre>

<hr>
<h2 id='APResult-class'>Class &quot;APResult&quot;</h2><span id='topic+APResult-class'></span><span id='topic+APResult'></span><span id='topic+apresult'></span><span id='topic+similarity'></span><span id='topic++5B+2CAPResult+2Cindex+2Cmissing+2Cmissing-method'></span><span id='topic++5B+5B+2CAPResult+2Cindex+2Cmissing-method'></span><span id='topic+length+2CAPResult-method'></span><span id='topic+similarity+2CAPResult-method'></span>

<h3>Description</h3>

<p>S4 class for storing results of affinity propagation
clustering. It extends the class <code><a href="#topic+ExClust-class">ExClust</a></code>.</p>


<h3>Objects</h3>

<p>Objects of this class can be created by calling <code><a href="#topic+apcluster">apcluster</a></code>
or <code><a href="#topic+apclusterL">apclusterL</a></code> for a given similarity matrix or calling
one of these procedures with a data set and a similarity measure.
</p>


<h3>Slots</h3>

<p>The following slots are defined for <a href="#topic+APResult">APResult</a> objects. Most names
are taken from Frey's and Dueck's original Matlab package:
</p>

<dl>
<dt><code>sweeps</code>:</dt><dd><p>number of times leveraged clustering ran with 
different subsets of samples</p>
</dd>
<dt><code>it</code>:</dt><dd><p>number of iterations the algorithm ran</p>
</dd>
<dt><code>p</code>:</dt><dd><p>input preference (either set by user or
computed by <code><a href="#topic+apcluster">apcluster</a></code> or
<code><a href="#topic+apclusterL">apclusterL</a></code>)</p>
</dd>
<dt><code>netsim</code>:</dt><dd><p>final total net similarity, defined as the
sum of <code>expref</code> and <code>dpsim</code>
(see below)</p>
</dd>
<dt><code>dpsim</code>:</dt><dd><p>final sum of similarities of data points to
exemplars</p>
</dd>
<dt><code>expref</code>:</dt><dd><p>final sum of preferences of the identified
exemplars</p>
</dd>
<dt><code>netsimLev</code>:</dt><dd><p>total net similarity of the individual 
sweeps for leveraged clustering; only
available for leveraged clustering</p>
</dd>
<dt><code>netsimAll</code>:</dt><dd><p>vector containing the total net similarity
for each iteration; only available if
<code><a href="#topic+apcluster">apcluster</a></code> was called with
<code>details=TRUE</code></p>
</dd>
<dt><code>exprefAll</code>:</dt><dd><p>vector containing the sum of preferences
of the identified exemplars
for each iteration; only available if
<code><a href="#topic+apcluster">apcluster</a></code> was called with
<code>details=TRUE</code></p>
</dd>
<dt><code>dpsimAll</code>:</dt><dd><p>vector containing the sum of similarities
of data points to exemplars
for each iteration; only available if
<code><a href="#topic+apcluster">apcluster</a></code> was called with
<code>details=TRUE</code></p>
</dd>
<dt><code>idxAll</code>:</dt><dd><p>matrix with sample-to-exemplar indices
for each iteration; only available if
<code><a href="#topic+apcluster">apcluster</a></code> was called with
<code>details=TRUE</code></p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"ExClust"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x="APResult")</code>: see
<code><a href="#topic+plot-methods">plot-methods</a></code></p>
</dd>
<dt>plot</dt><dd><p><code>signature(x="ExClust", y="matrix")</code>: see
<code><a href="#topic+plot-methods">plot-methods</a></code></p>
</dd>
<dt>heatmap</dt><dd><p><code>signature(x="ExClust")</code>: see
<code><a href="#topic+heatmap-methods">heatmap-methods</a></code></p>
</dd>
<dt>heatmap</dt><dd><p><code>signature(x="ExClust", y="matrix")</code>: see
<code><a href="#topic+heatmap-methods">heatmap-methods</a></code></p>
</dd>
<dt>show</dt><dd><p><code>signature(object="APResult")</code>: see
<code><a href="#topic+show-methods">show-methods</a></code></p>
</dd>
<dt>labels</dt><dd><p><code>signature(object="APResult")</code>: see
<code><a href="#topic+labels-methods">labels-methods</a></code></p>
</dd>
<dt>cutree</dt><dd><p><code>signature(object="APResult")</code>: see
<code><a href="#topic+cutree-methods">cutree-methods</a></code></p>
</dd>
<dt>length</dt><dd><p><code>signature(x="APResult")</code>: gives the number of
clusters.</p>
</dd>
<dt>sort</dt><dd><p><code>signature(x="ExClust")</code>: see
<code><a href="#topic+sort-methods">sort-methods</a></code></p>
</dd>
<dt>as.hclust</dt><dd><p><code>signature(x="ExClust")</code>: see
<code><a href="methods.html#topic+coerce-methods">coerce-methods</a></code></p>
</dd>
<dt>as.dendrogram</dt><dd><p><code>signature(object="ExClust")</code>: see
<code><a href="methods.html#topic+coerce-methods">coerce-methods</a></code></p>
</dd>
</dl>



<h3>Accessors</h3>

<p>In the following code snippets, <code>x</code> is an <code>APResult</code> object.
</p>

<dl>
<dt>[[</dt><dd><p><code>signature(x="APResult", i="index", j="missing")</code>:
<code>x[[i]]</code> returns the i-th cluster as a list of indices
of samples belonging to the i-th cluster.
</p>
</dd>
<dt>[</dt><dd><p><code>signature(x="APResult", i="index", j="missing",
      drop="missing")</code>: <code>x[i]</code> returns a list of integer vectors with the
indices  of samples belonging to this cluster. The list has as
many components as the argument <code>i</code> has elements. A list is
returned even if <code>i</code> is a single integer.
</p>
</dd>
<dt>similarity</dt><dd><p><code>signature(x="APResult")</code>: gives the similarity
matrix.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ulrich Bodenhofer, Andreas Kothmeier &amp; Johannes Palme
<a href="mailto:apcluster@bioinf.jku.at">apcluster@bioinf.jku.at</a></p>


<h3>References</h3>

<p><a href="http://www.bioinf.jku.at/software/apcluster/">http://www.bioinf.jku.at/software/apcluster/</a>
</p>
<p>Bodenhofer, U., Kothmeier, A., and Hochreiter, S. (2011)
APCluster: an R package for affinity propagation clustering.
<em>Bioinformatics</em> <b>27</b>, 2463-2464.
DOI: <a href="https://doi.org/10.1093/bioinformatics/btr406">doi:10.1093/bioinformatics/btr406</a>.
</p>
<p>Frey, B. J. and Dueck, D. (2007) Clustering by passing messages
between data points. <em>Science</em> <b>315</b>, 972-976.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apcluster">apcluster</a></code>, <code><a href="#topic+apclusterL">apclusterL</a></code>, 
<code><a href="#topic+show-methods">show-methods</a></code>, <code><a href="#topic+plot-methods">plot-methods</a></code>, 
<code><a href="#topic+labels-methods">labels-methods</a></code>, <code><a href="#topic+cutree-methods">cutree-methods</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## create two Gaussian clouds
cl1 &lt;- cbind(rnorm(100, 0.2, 0.05), rnorm(100, 0.8, 0.06))
cl2 &lt;- cbind(rnorm(50, 0.7, 0.08), rnorm(50, 0.3, 0.05))
x &lt;- rbind(cl1, cl2)

## compute similarity matrix (negative squared Euclidean)
sim &lt;- negDistMat(x, r=2)

## run affinity propagation
apres &lt;- apcluster(sim, details=TRUE)

## show details of clustering results
show(apres)

## plot information about clustering run
plot(apres)

## plot clustering result
plot(apres, x)

## plot heatmap
heatmap(apres, sim)
</code></pre>

<hr>
<h2 id='coerce-methods'>Coercion of cluster hierarchies</h2><span id='topic+as.hclust'></span><span id='topic+as.dendrogram'></span><span id='topic+as.hclust+2CAggExResult-method'></span><span id='topic+as.hclust+2CExClust-method'></span><span id='topic+as.dendrogram+2CAggExResult-method'></span><span id='topic+as.dendrogram+2CExClust-method'></span>

<h3>Description</h3>

<p>Functions for coercing clustering object to hclust and dendrogram objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'AggExResult'
as.hclust(x, base=0.05)
## S4 method for signature 'ExClust'
as.hclust(x, base=0.05, ...)
## S4 method for signature 'AggExResult'
as.dendrogram(object, base=0.05, useNames=TRUE)
## S4 method for signature 'ExClust'
as.dendrogram(object, base=0.05, useNames=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coerce-methods_+3A_x">x</code></td>
<td>
<p>a clustering result object of class
<code><a href="#topic+APResult-class">APResult</a></code>, <code><a href="#topic+ExClust-class">ExClust</a></code>,
or <code><a href="#topic+AggExResult-class">AggExResult</a></code></p>
</td></tr>
<tr><td><code id="coerce-methods_+3A_object">object</code></td>
<td>
<p>a clustering result object of class
<code><a href="#topic+APResult-class">APResult</a></code>, <code><a href="#topic+ExClust-class">ExClust</a></code>,
or <code><a href="#topic+AggExResult-class">AggExResult</a></code></p>
</td></tr>
<tr><td><code id="coerce-methods_+3A_base">base</code></td>
<td>
<p>fraction of height used for the very first join; defaults
to 0.05, i.e. the first join appears at 5% of the total height of the
dendrogram (see details below).</p>
</td></tr>
<tr><td><code id="coerce-methods_+3A_usenames">useNames</code></td>
<td>
<p>if <code>TRUE</code> (default), the labels of the dendrogram
are the sample/cluster names (if available); otherwise, the labels
are indices.</p>
</td></tr>
<tr><td><code id="coerce-methods_+3A_...">...</code></td>
<td>
<p>all other arguments are passed on to
<code><a href="#topic+aggExCluster">aggExCluster</a></code> (see details below).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If called for an <code><a href="#topic+AggExResult-class">AggExResult</a></code> object,
<code>as.hclust</code> creates an <code><a href="stats.html#topic+hclust">hclust</a></code> object.
The heights are transformed to the interval from <code>base</code> (height
of lowest join) to 1 (height of highest join).
If called for an <code><a href="#topic+ExClust-class">ExClust</a></code> or
<code><a href="#topic+APResult-class">APResult</a></code> object, <code><a href="#topic+aggExCluster">aggExCluster</a></code> is
called internally to create a cluster hierarchy first. This is only
possible if the pairwise similarities are included in the <code>sim</code>
slot of <code>x</code> (see <code><a href="#topic+aggExCluster">aggExCluster</a></code> on how to ensure
this).
</p>
<p>If <code>x</code> is an <code><a href="#topic+AggExResult-class">AggExResult</a></code> object obtained by
clustering an entire data set, <code>as.hclust</code> produces a complete
hierarchy. If, however, <code>x</code> is an <code><a href="#topic+ExClust-class">ExClust</a></code> (or
<code><a href="#topic+APResult-class">APResult</a></code>) object or an
<code><a href="#topic+AggExResult-class">AggExResult</a></code> obtained by running
<code><a href="#topic+aggExCluster">aggExCluster</a></code> on an <code><a href="#topic+ExClust-class">ExClust</a></code> or
<code><a href="#topic+APResult-class">APResult</a></code> object, then <code>as.hclust</code> produces
a hierarchy of clusters, not of samples.
</p>
<p>If called for an <code><a href="#topic+AggExResult-class">AggExResult</a></code> object,
<code>as.dendrogram</code> creates an
<code><a href="stats.html#topic+dendrogram">dendrogram</a></code> object.
Analogously to <code>as.hclust</code>, the heights are transformed to the
interval ranging from <code>base</code> (height
of lowest join) to 1 (height of highest join). So, any information
about heights of merges is lost. If the original join heights are
relevant, call <code><a href="#topic+plot">plot</a></code> on the original
<code><a href="#topic+AggExResult-class">AggExResult</a></code> object directly without coercing it
to a <code><a href="stats.html#topic+dendrogram">dendrogram</a></code> object first.
If called for an <code><a href="#topic+ExClust-class">ExClust</a></code> or
<code><a href="#topic+APResult-class">APResult</a></code> object, <code><a href="#topic+aggExCluster">aggExCluster</a></code> is
called first to create a cluster hierarchy. Again this is only
possible if the pairwise similarities are included in the <code>sim</code>
slot of <code>object</code>.
</p>
<p>If <code>object</code> is an <code><a href="#topic+AggExResult-class">AggExResult</a></code> object obtained by
clustering an entire data set, <code>as.dendrogram</code> produces a complete
dendrogram. If <code>object</code> is an <code><a href="#topic+ExClust-class">ExClust</a></code> (or
<code><a href="#topic+APResult-class">APResult</a></code>) object or an
<code><a href="#topic+AggExResult-class">AggExResult</a></code> obtained by previously running
<code><a href="#topic+aggExCluster">aggExCluster</a></code> on an <code><a href="#topic+ExClust-class">ExClust</a></code> or
<code><a href="#topic+APResult-class">APResult</a></code> object, then <code>as.dendrogram</code> produces
a complete dendrogram of all samples, too, but with the difference
that entire clusters of the previous <code><a href="#topic+ExClust-class">ExClust</a></code> or
<code><a href="#topic+APResult-class">APResult</a></code> object are not further split up
hierarchically.
Consequently, if <code>x</code> is not a complete cluster hierarchy, but a
hierarchy of clusters, <code>as.dendrogram(as.hclust(x))</code> produces a
dendrogram of clusters, whereas <code>as.dendrogram(x)</code> in any case
produces a dendrogram of samples (with the special property mentioned
above).
</p>


<h3>Value</h3>

<p>see details above
</p>


<h3>Author(s)</h3>

<p>Ulrich Bodenhofer, Andreas Kothmeier &amp; Johannes Palme
<a href="mailto:apcluster@bioinf.jku.at">apcluster@bioinf.jku.at</a></p>


<h3>References</h3>

<p><a href="http://www.bioinf.jku.at/software/apcluster/">http://www.bioinf.jku.at/software/apcluster/</a>
</p>
<p>Bodenhofer, U., Kothmeier, A., and Hochreiter, S. (2011)
APCluster: an R package for affinity propagation clustering.
<em>Bioinformatics</em> <b>27</b>, 2463-2464.
DOI: <a href="https://doi.org/10.1093/bioinformatics/btr406">doi:10.1093/bioinformatics/btr406</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+APResult-class">APResult</a></code>,
<code><a href="#topic+AggExResult-class">AggExResult</a></code>, <code><a href="#topic+ExClust-class">ExClust</a></code>,
<code><a href="#topic+heatmap-methods">heatmap-methods</a></code>, <code><a href="#topic+apcluster">apcluster</a></code>, 
<code><a href="#topic+apclusterL">apclusterL</a></code>, <code><a href="#topic+aggExCluster">aggExCluster</a></code>, 
<code><a href="#topic+cutree-methods">cutree-methods</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## create two Gaussian clouds
cl1 &lt;- cbind(rnorm(20, 0.2, 0.05), rnorm(20, 0.8, 0.06))
cl2 &lt;- cbind(rnorm(20, 0.7, 0.08), rnorm(20, 0.3, 0.05))
x &lt;- rbind(cl1, cl2)

## run affinity propagation
apres &lt;- apcluster(negDistMat(r=2), x, q=0.7, details=TRUE)

## perform agglomerative clustering of affinity propagation clusters
aggres1 &lt;- aggExCluster(x=apres)

## compute and plot dendrogram
dend1 &lt;- as.dendrogram(aggres1)
dend1
plot(dend1)

## compute and show dendrogram computed from hclust object
dend2 &lt;- as.dendrogram(as.hclust(aggres1))
dend2
plot(dend2)

## perform agglomerative clustering of whole data set
aggres2 &lt;- aggExCluster(negDistMat(r=2), x)

## compute and plot dendrogram
dend3 &lt;- as.dendrogram(aggres2)
dend3
plot(dend3)
</code></pre>

<hr>
<h2 id='conversions'>Conversions Between Dense and Sparse Similarity Matrices</h2><span id='topic+conversions'></span><span id='topic+as.SparseSimilarityMatrix'></span><span id='topic+as.DenseSimilarityMatrix'></span><span id='topic+as.SparseSimilarityMatrix-methods'></span><span id='topic+as.DenseSimilarityMatrix-method'></span><span id='topic+as.SparseSimilarityMatrix+2Cmatrix-method'></span><span id='topic+as.DenseSimilarityMatrix+2Cmatrix-method'></span><span id='topic+as.SparseSimilarityMatrix+2CsparseMatrix-method'></span><span id='topic+as.DenseSimilarityMatrix+2CsparseMatrix-method'></span><span id='topic+as.SparseSimilarityMatrix+2CMatrix-method'></span><span id='topic+as.DenseSimilarityMatrix+2CMatrix-method'></span>

<h3>Description</h3>

<p>Converts a dense similarity matrix into a sparse one or vice versa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
as.SparseSimilarityMatrix(s, lower=-Inf)
## S4 method for signature 'Matrix'
as.SparseSimilarityMatrix(s, lower=-Inf)
## S4 method for signature 'sparseMatrix'
as.SparseSimilarityMatrix(s, lower=-Inf)
## S4 method for signature 'matrix'
as.DenseSimilarityMatrix(s, fill=-Inf)
## S4 method for signature 'Matrix'
as.DenseSimilarityMatrix(s, fill=-Inf)
## S4 method for signature 'sparseMatrix'
as.DenseSimilarityMatrix(s, fill=-Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conversions_+3A_s">s</code></td>
<td>
<p>a similarity matrix in sparse or dense format (see details
below)</p>
</td></tr>
<tr><td><code id="conversions_+3A_lower">lower</code></td>
<td>
<p>cut-off threshold to apply when converting similarity
matrices into sparse format. All similarities lower than or equal to
<code>lower</code> will be omitted from the result. The default is
<code>-Inf</code>), i.e. only <code>-Inf</code> values are removed.</p>
</td></tr>
<tr><td><code id="conversions_+3A_fill">fill</code></td>
<td>
<p>value to fill in for entries that are missing from sparse
similarity matrix 's' (defaults to <code>-Inf</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>as.SparseSimilarityMatrix</code> takes a matrix argument,
removes all diagonal elements and all values that are lower than or
equal to the cut-off threshold <code>lower</code> and returns a sparse
matrix of class <code><a href="Matrix.html#topic+dgTMatrix-class">dgTMatrix</a></code>.
</p>
<p>If the function <code>as.DenseSimilarityMatrix</code> is called for a
sparse matrix (class <code><a href="Matrix.html#topic+sparseMatrix-class">sparseMatrix</a></code> or any
class derived from this class), a dense matrix is returned, where all
values that were missing in the sparse matrix are replaced with
<code>fill</code>.
</p>
<p><code>as.DenseSimilarityMatrix</code> can also be called for dense
<code><a href="base.html#topic+matrix">matrix</a></code> and <code><a href="Matrix.html#topic+Matrix-class">Matrix</a></code> objects.
In this case, <code>as.DenseSimilarityMatrix</code> assumes that the
matrices have three columns that encode for a sparse matrix
in the same way as the Matlab implementation of Frey's and Dueck's
sparse affinity propagation accepts it:
the first column contains 1-based row indices, the second column
contains 1-based column indices, and the third column contains the
similarity values. The same format is also accepted by
<code>as.SparseSimilarityMatrix</code> to convert a sparse similarity matrix
of this format into a <code><a href="Matrix.html#topic+dgTMatrix-class">dgTMatrix</a></code> object.
Note that, for matrices of this format,
<code>as.DenseSimilarityMatrix</code> replaces the deprectated function
<code>sparseToFull</code> that was used in older versions of the package.
</p>
<p>Note that <code>as.SparseSimilarityMatrix</code> and
<code>as.DenseSimilarityMatrix</code> are no S4 coercion methods.
There are no classes named <code>SparseSimilarityMatrix</code>
or <code>DenseSimilarityMatrix</code>.
</p>


<h3>Value</h3>

<p>returns a square similarity matrix in sparse format (class
<code><a href="Matrix.html#topic+dgTMatrix-class">dgTMatrix</a></code> or in dense format (standard class
<code><a href="base.html#topic+matrix">matrix</a></code>).</p>


<h3>Author(s)</h3>

<p>Ulrich Bodenhofer
<a href="mailto:apcluster@bioinf.jku.at">apcluster@bioinf.jku.at</a></p>


<h3>References</h3>

<p><a href="http://www.bioinf.jku.at/software/apcluster/">http://www.bioinf.jku.at/software/apcluster/</a>
</p>
<p>Frey, B. J. and Dueck, D. (2007) Clustering by passing messages
between data points. <em>Science</em> <b>315</b>, 972-976.
DOI: <a href="https://doi.org/10.1126/science.1136800">doi:10.1126/science.1136800</a>.
</p>
<p>Bodenhofer, U., Kothmeier, A., and Hochreiter, S. (2011)
APCluster: an R package for affinity propagation clustering.
<em>Bioinformatics</em> <b>27</b>, 2463-2464.
DOI: <a href="https://doi.org/10.1093/bioinformatics/btr406">doi:10.1093/bioinformatics/btr406</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create similarity matrix in sparse format according to Frey and Dueck
sp &lt;- matrix(c(1, 2, 0.5, 3, 1, 0.2, 5, 4, -0.2, 3, 4, 1.2), 4, 3, byrow=TRUE)
sp

## perform conversions
as.DenseSimilarityMatrix(sp, fill=0)
as.SparseSimilarityMatrix(sp)

## create dense similarity matrix
cl1 &lt;- cbind(rnorm(20, 0.2, 0.05), rnorm(20, 0.8, 0.06))
cl2 &lt;- cbind(rnorm(20, 0.7, 0.08), rnorm(20, 0.3, 0.05))
x &lt;- rbind(cl1, cl2)

sim &lt;- negDistMat(x, r=2)
ssim &lt;- as.SparseSimilarityMatrix(sim, lower=-0.2)

## run apcluster() on the sparse similarity matrix
apres &lt;- apcluster(ssim, q=0)
apres
</code></pre>

<hr>
<h2 id='cutree-methods'>Cut Out Clustering Level from Cluster Hierarchy</h2><span id='topic+cutree'></span><span id='topic+cutree-methods'></span><span id='topic+cutree+2CAggExResult-method'></span><span id='topic+cutree+2CAPResult-method'></span>

<h3>Description</h3>

<p>Cut out a clustering level from a cluster hierarchy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'AggExResult'
cutree(tree, k, h)
## S4 method for signature 'APResult'
cutree(tree, k, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutree-methods_+3A_tree">tree</code></td>
<td>
<p>an object of class <code><a href="#topic+AggExResult-class">AggExResult</a></code>
containing a cluster hierarchy; may also be an object of
class <code><a href="#topic+APResult-class">APResult</a></code></p>
</td></tr>
<tr><td><code id="cutree-methods_+3A_k">k</code></td>
<td>
<p>the level (i.e. the number of clusters) to be selected</p>
</td></tr>
<tr><td><code id="cutree-methods_+3A_h">h</code></td>
<td>
<p>alternatively, the level can be selected by specifying a
cut-off for the merging objective</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>cutree</code> extracts a clustering level from a
cluster hierarchy stored in an <code><a href="#topic+AggExResult-class">AggExResult</a></code>
object. Which level is selected can be determined by one of the
two arguments <code>k</code> and <code>h</code> (see above). If both <code>k</code> and
<code>h</code> are specified, <code>k</code> overrides <code>h</code>. This is
done largely analogous to the standard function 
<code><a href="stats.html#topic+cutree">cutree</a></code>. The differences are (1) that
only one level can be extracted at a time and (2) that an
<code><a href="#topic+ExClust-class">ExClust</a></code> is returned instead of an index list.
</p>
<p>The function <code>cutree</code> may further be used to convert an
<code><a href="#topic+APResult-class">APResult</a></code> object into an
<code><a href="#topic+ExClust-class">ExClust</a></code> object. In this case, the arguments
<code>k</code> and <code>h</code> are ignored.
</p>


<h3>Value</h3>

<p>returns an object of class <code><a href="#topic+ExClust-class">ExClust</a></code>
</p>


<h3>Author(s)</h3>

<p>Ulrich Bodenhofer &amp; Andreas Kothmeier
<a href="mailto:apcluster@bioinf.jku.at">apcluster@bioinf.jku.at</a></p>


<h3>References</h3>

<p><a href="http://www.bioinf.jku.at/software/apcluster/">http://www.bioinf.jku.at/software/apcluster/</a>
</p>
<p>Bodenhofer, U., Kothmeier, A., and Hochreiter, S. (2011)
APCluster: an R package for affinity propagation clustering.
<em>Bioinformatics</em> <b>27</b>, 2463-2464.
DOI: <a href="https://doi.org/10.1093/bioinformatics/btr406">doi:10.1093/bioinformatics/btr406</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AggExResult-class">AggExResult</a></code>,
<code><a href="#topic+ExClust-class">ExClust</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## create two simple clusters
x &lt;- c(1, 2, 3, 7, 8, 9)
names(x) &lt;- c("a", "b", "c", "d", "e", "f")

## compute similarity matrix (negative squared distance)
sim &lt;- negDistMat(x, r=2)

## run affinity propagation
aggres &lt;- aggExCluster(sim)

## show details of clustering results
show(aggres)

## retrieve clustering with 2 clusters
cutree(aggres, 2)

## retrieve clustering with cut-off h=-1
cutree(aggres, h=-1)
</code></pre>

<hr>
<h2 id='ExClust-class'>Class &quot;ExClust&quot;</h2><span id='topic+ExClust-class'></span><span id='topic+ExClust'></span><span id='topic+exclust'></span><span id='topic++5B+2CExClust+2Cindex+2Cmissing+2Cmissing-method'></span><span id='topic++5B+5B+2CExClust+2Cindex+2Cmissing-method'></span><span id='topic+length+2CExClust-method'></span><span id='topic+similarity+2CExClust-method'></span>

<h3>Description</h3>

<p>S4 class for storing exemplar-based clusterings</p>


<h3>Objects</h3>

<p>Objects of this class can be created by calling <code><a href="#topic+cutree">cutree</a></code>
to cut out a clustering level from a cluster hierarchy
of class <code><a href="#topic+AggExResult-class">AggExResult</a></code>. Moreover,
<code><a href="#topic+cutree">cutree</a></code> can also be used to convert an object of
class <code><a href="#topic+APResult-class">APResult</a></code> to class <code>ExClust</code>.
</p>


<h3>Slots</h3>

<p>The following slots are defined for <a href="#topic+ExClust">ExClust</a> objects:
</p>

<dl>
<dt><code>l</code>:</dt><dd><p>number of samples in the data set</p>
</dd>
<dt><code>sel</code>:</dt><dd><p>subset of samples used for leveraged clustering</p>
</dd>
<dt><code>exemplars</code>:</dt><dd><p>vector containing indices of exemplars</p>
</dd>
<dt><code>clusters</code>:</dt><dd><p>list containing the clusters; the i-th
component is a vector of indices of
data points belonging to the i-th
exemplar (including the exemplar itself)</p>
</dd>
<dt><code>idx</code>:</dt><dd><p>vector of length <code>l</code> realizing a
sample-to-exemplar mapping; the i-th entry
contains the index of the exemplar the i-th
sample belongs to</p>
</dd>
<dt><code>sim</code>:</dt><dd><p>similarity matrix; only available if
the preceding clustering method was called with
<code>includeSim=TRUE</code>.</p>
</dd>
<dt><code>call</code>:</dt><dd><p>method call of the preceding clustering method</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x="ExClust")</code>: see
<code><a href="#topic+plot-methods">plot-methods</a></code></p>
</dd>
<dt>plot</dt><dd><p><code>signature(x="ExClust", y="matrix")</code>: see
<code><a href="#topic+plot-methods">plot-methods</a></code></p>
</dd>
<dt>heatmap</dt><dd><p><code>signature(x="ExClust")</code>: see
<code><a href="#topic+heatmap-methods">heatmap-methods</a></code></p>
</dd>
<dt>heatmap</dt><dd><p><code>signature(x="ExClust", y="matrix")</code>: see
<code><a href="#topic+heatmap-methods">heatmap-methods</a></code></p>
</dd>
<dt>show</dt><dd><p><code>signature(object="ExClust")</code>: see
<code><a href="#topic+show-methods">show-methods</a></code></p>
</dd>
<dt>labels</dt><dd><p><code>signature(object="ExClust")</code>: see
<code><a href="#topic+labels-methods">labels-methods</a></code></p>
</dd>
<dt>cutree</dt><dd><p><code>signature(object="ExClust", k="ANY", h="ANY")</code>: see
<code><a href="#topic+cutree-methods">cutree-methods</a></code></p>
</dd>
<dt>length</dt><dd><p><code>signature(x="ExClust")</code>: gives the number of
clusters.</p>
</dd>
<dt>sort</dt><dd><p><code>signature(x="ExClust")</code>: see
<code><a href="#topic+sort-methods">sort-methods</a></code></p>
</dd>
<dt>as.hclust</dt><dd><p><code>signature(x="ExClust")</code>: see
<code><a href="methods.html#topic+coerce-methods">coerce-methods</a></code></p>
</dd>
<dt>as.dendrogram</dt><dd><p><code>signature(object="ExClust")</code>: see
<code><a href="methods.html#topic+coerce-methods">coerce-methods</a></code></p>
</dd>
</dl>



<h3>Accessors</h3>

<p>In the following code snippets, <code>x</code> is an <code>ExClust</code> object.
</p>

<dl>
<dt>[[</dt><dd><p><code>signature(x="ExClust", i="index", j="missing")</code>:
<code>x[[i]]</code> returns the i-th cluster as a list of indices
of samples belonging to the i-th cluster.
</p>
</dd>
<dt>[</dt><dd><p><code>signature(x="ExClust", i="index", j="missing",
      drop="missing")</code>: <code>x[i]</code> returns a list of integer vectors with the
indices  of samples belonging to this cluster. The list has as
many components as the argument <code>i</code> has elements. A list is
returned even if <code>i</code> is a single integer.
</p>
</dd>
<dt>similarity</dt><dd><p><code>signature(x="ExClust")</code>: gives the similarity
matrix.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ulrich Bodenhofer, Andreas Kothmeier &amp; Johannes Palme
<a href="mailto:apcluster@bioinf.jku.at">apcluster@bioinf.jku.at</a></p>


<h3>References</h3>

<p><a href="http://www.bioinf.jku.at/software/apcluster/">http://www.bioinf.jku.at/software/apcluster/</a>
</p>
<p>Bodenhofer, U., Kothmeier, A., and Hochreiter, S. (2011)
APCluster: an R package for affinity propagation clustering.
<em>Bioinformatics</em> <b>27</b>, 2463-2464.
DOI: <a href="https://doi.org/10.1093/bioinformatics/btr406">doi:10.1093/bioinformatics/btr406</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aggExCluster">aggExCluster</a></code>, <code><a href="#topic+show-methods">show-methods</a></code>,
<code><a href="#topic+plot-methods">plot-methods</a></code>, <code><a href="#topic+labels-methods">labels-methods</a></code>,
<code><a href="#topic+cutree-methods">cutree-methods</a></code>, <code><a href="#topic+AggExResult-class">AggExResult</a></code>,
<code><a href="#topic+APResult-class">APResult</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## create two Gaussian clouds
cl1 &lt;- cbind(rnorm(20, 0.2, 0.05), rnorm(20, 0.8, 0.06))
cl2 &lt;- cbind(rnorm(25, 0.7, 0.08), rnorm(25, 0.3, 0.05))
x &lt;- rbind(cl1, cl2)

## compute similarity matrix (negative squared Euclidean)
sim &lt;- negDistMat(x, r=2)

## run affinity propagation
aggres &lt;- aggExCluster(sim)

## extract level with two clusters
excl &lt;- cutree(aggres, k=2)

## show details of clustering results
show(excl)

## plot information about clustering run
plot(excl, x)
</code></pre>

<hr>
<h2 id='heatmap'>Plot Heatmap</h2><span id='topic+heatmap'></span><span id='topic+heatmap-methods'></span><span id='topic+heatmap+2CExClust+2Cmissing-method'></span><span id='topic+heatmap+2CExClust+2Cmatrix-method'></span><span id='topic+heatmap+2CExClust+2CMatrix-method'></span><span id='topic+heatmap+2CExClust+2CsparseMatrix-method'></span><span id='topic+heatmap+2CAggExResult+2Cmissing-method'></span><span id='topic+heatmap+2CAggExResult+2Cmatrix-method'></span><span id='topic+heatmap+2Cmissing+2Cmatrix-method'></span><span id='topic+heatmap+2Cmatrix+2Cmissing-method'></span>

<h3>Description</h3>

<p>Functions for Plotting of Heatmap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ExClust,missing'
heatmap(x, y, ...)
## S4 method for signature 'ExClust,matrix'
heatmap(x, y, ...)
## S4 method for signature 'ExClust,Matrix'
heatmap(x, y, ...)
## S4 method for signature 'ExClust,sparseMatrix'
heatmap(x, y, ...)
## S4 method for signature 'AggExResult,missing'
heatmap(x, y, ...)
## S4 method for signature 'AggExResult,matrix'
heatmap(x, y, Rowv=TRUE, Colv=TRUE,
    sideColors=NULL, col=heat.colors(12),
    base=0.05,  add.expr, margins=c(5, 5, 2),
    cexRow=max(min(35 / nrow(y), 1), 0.1),
    cexCol=max(min(35 / ncol(y), 1), 0.1), main=NULL, dendScale=1,
    barScale=1, legend=c("none", "col"), ...)
## S4 method for signature 'matrix,missing'
heatmap(x, y, ...)
## S4 method for signature 'missing,matrix'
heatmap(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heatmap_+3A_x">x</code></td>
<td>
<p>a clustering result object of class
<code><a href="#topic+APResult-class">APResult</a></code>, <code><a href="#topic+ExClust-class">ExClust</a></code>,
or <code><a href="#topic+AggExResult-class">AggExResult</a></code>; for compatibility, <code>x</code>
may also be a similarity matrix (see details below).</p>
</td></tr>
<tr><td><code id="heatmap_+3A_y">y</code></td>
<td>
<p>a similarity matrix</p>
</td></tr>
<tr><td><code id="heatmap_+3A_sidecolors">sideColors</code></td>
<td>
<p>character vector of colors to be used for plotting color
bars that visualize clusters of the finest clustering level in
<code>x</code>. This is done in a fashion similar to using
<code>RowSideColors</code> or <code>ColSideColors</code> in the standard
<code><a href="stats.html#topic+heatmap">heatmap</a></code> function. However, color bars
are plotted either on both sides or not at all. The
<code>sideColors</code> argument determines the coloring of both
horizontal and vertical bars.
If <code>sideColors</code> is shorter than the number of clusters in the finest
clustering level, <code>sideColors</code> is recycled. In any case, a
minimum number of two colors (two elements of sideColors) is
required. If <code>NA</code>, no color bars are plotted.
If <code>NULL</code> (default), color bars are only plotted if
the finest cluster level does not only consist of single samples.
In this case, the <code><a href="grDevices.html#topic+rainbow">rainbow</a></code> function is used to
compute the vector of colors which is shuffled such that dissimilar
colors are placed next to each other in the color bar.</p>
</td></tr>
<tr><td><code id="heatmap_+3A_col">col</code></td>
<td>
<p>color ramp used for the heatmap image; see
<code><a href="graphics.html#topic+image">image</a></code></p>
</td></tr>
<tr><td><code id="heatmap_+3A_rowv">Rowv</code></td>
<td>
<p>determines whether or not a row dendrogram should be
plotted. If <code>FALSE</code> or <code>NA</code>, no row dendrogram is
plotted. In any other
case, a row dendrogram is plotted unless the number of clusters in
the finest clustering level is less than 2. Note that, in the
latter case, the actual values in <code>Rowv</code> are ignored, so this
argument cannot be used to supply a previously computed dendrogram
or re-ordering of elements as in the standard
<code><a href="stats.html#topic+heatmap">heatmap</a></code> function.</p>
</td></tr>
<tr><td><code id="heatmap_+3A_colv">Colv</code></td>
<td>
<p>determines whether or not a column dendrogram should be
plotted. Fully analogous to <code>Rowv</code>, except that column
dendrograms are never plotted if the similarity  matrix <code>y</code>
is non-quadratic.</p>
</td></tr>
<tr><td><code id="heatmap_+3A_base">base</code></td>
<td>
<p>fraction of height used for the very first join in
dendrograms; see <code><a href="#topic+coerce-methods">coerce-methods</a></code>.</p>
</td></tr>
<tr><td><code id="heatmap_+3A_add.expr">add.expr</code>, <code id="heatmap_+3A_margins">margins</code>, <code id="heatmap_+3A_cexrow">cexRow</code>, <code id="heatmap_+3A_cexcol">cexCol</code>, <code id="heatmap_+3A_main">main</code></td>
<td>
<p>largely analogous to the standard
<code><a href="stats.html#topic+heatmap">heatmap</a></code> function; to omit row/column
labeling, set <code>cexRow</code>/<code>cexCol</code> to <code>0</code>.
The default for <code>margins</code> is a vector of length 3, where the
third element is the right-hand side margin for the color legend
(see <code>legend</code> argument). It remains unused (and can also be
omitted) if no color legend is plotted.</p>
</td></tr>
<tr><td><code id="heatmap_+3A_dendscale">dendScale</code></td>
<td>
<p>factor scaling the width of vertical and height of
horizontal dendrograms; values have to be larger than 0 and no
larger than 2. The default is 1 which corresponds to the same size
as the dendrograms plot by the standard
<code><a href="stats.html#topic+heatmap">heatmap</a></code> function</p>
</td></tr>
<tr><td><code id="heatmap_+3A_barscale">barScale</code></td>
<td>
<p>factor scaling the width of color bars; values have to
be larger than 0 and no larger than 4. The default is 1 which
corresponds to half the width of the color bars plot by the standard
<code><a href="stats.html#topic+heatmap">heatmap</a></code> function</p>
</td></tr>
<tr><td><code id="heatmap_+3A_legend">legend</code></td>
<td>
<p>if <code>"col"</code>, then a color legend similar to 
<code><a href="graphics.html#topic+filled.contour">filled.contour</a></code> is added on
the right-hand side of the heatmap plot; if <code>"none"</code> (default),
no such legend is added.</p>
</td></tr>
<tr><td><code id="heatmap_+3A_...">...</code></td>
<td>
<p>see details below</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>heatmap</code> functions provide plotting of heatmaps from several
different types of input object. The implementation is similar to the standard
graphics function <code><a href="stats.html#topic+heatmap">heatmap</a></code>. 
Plotting heatmaps via the <code><a href="#topic+plot">plot</a></code> command as available in previous 
versions of this package is still available for backward 
compatibility.
</p>
<p>If <code>heatmap</code> is called for objects of classes
<code><a href="#topic+APResult-class">APResult</a></code> or <code><a href="#topic+ExClust-class">ExClust</a></code>,
a heatmap of the similarity matrix in slot <code>sim</code> of the parameter
<code>x</code> is created with clusters grouped together and highlighted in
different colors. The order of clusters is determined by running 
<code><a href="#topic+aggExCluster">aggExCluster</a></code> on the clustering result <code>x</code>. This
variant of <code>heatmap</code> returns an  invisible
<code><a href="#topic+AggExResult-class">AggExResult</a></code> object.
</p>
<p>If <code>heatmap</code> is called for an <code><a href="#topic+AggExResult-class">AggExResult</a></code>
object that contains all levels of clustering, the heatmap is
displayed with the corresponding clustering dendrogram. If the
<code><a href="#topic+AggExResult-class">AggExResult</a></code> object is the result of running
<code><a href="#topic+aggExCluster">aggExCluster</a></code> on a prior clustering result, the same heatmap
plot is produced as if <code>heatmap</code> had been called on this
prior clustering result, however, returning the cluster hierarchy's
<code><a href="stats.html#topic+dendrogram">dendrogram</a></code>. In the latter case, color bars are plotted
to visualize the prior clustering result (see description of
argument <code>sideColors</code> above).
</p>
<p>All variants described above only work if the input object <code>x</code>
contains a slot <code>sim</code> with the similarity matrix (which is only
the case if the preceding clustering method has been called with
<code>includeSim=TRUE</code>). In case the slot <code>sim</code> of <code>x</code> does not
contain the similarity matrix, the similarity matrix must be supplied
as second argument <code>y</code>.
</p>
<p>All variants described above internally use <code>heatmap</code> with signature
<code>AggExResult,matrix</code>, so all arguments list above can be used for
all variants, as they are passed through using the <code>...</code>
argument. All other arguments, analogously to the standard 
<code><a href="stats.html#topic+heatmap">heatmap</a></code> function, are passed on to the
standard function <code><a href="graphics.html#topic+image">image</a></code>. This is
particularly useful for using alternative color schemes via the
<code>col</code> argument.
</p>
<p>The two variants with one of the two arguments being a matrix and one
being missing are just wrappers around the standard
<code><a href="stats.html#topic+heatmap">heatmap</a></code> function with the aim to provide
compatibility with this standard case.
</p>


<h3>Value</h3>

<p>see details above
</p>


<h3>Note</h3>

<p>Similarity matrices can be supplied in dense or sparse
format. Note, however, that sparse matrices are converted to full
dense matrices before plotting heatmaps which may lead to memory and/or
performance bottlenecks for larger data sets.</p>


<h3>Author(s)</h3>

<p>Ulrich Bodenhofer, Andreas Kothmeier &amp; Johannes Palme
<a href="mailto:apcluster@bioinf.jku.at">apcluster@bioinf.jku.at</a></p>


<h3>References</h3>

<p><a href="http://www.bioinf.jku.at/software/apcluster/">http://www.bioinf.jku.at/software/apcluster/</a>
</p>
<p>Bodenhofer, U., Kothmeier, A., and Hochreiter, S. (2011)
APCluster: an R package for affinity propagation clustering.
<em>Bioinformatics</em> <b>27</b>, 2463-2464.
DOI: <a href="https://doi.org/10.1093/bioinformatics/btr406">doi:10.1093/bioinformatics/btr406</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+APResult-class">APResult</a></code>,
<code><a href="#topic+AggExResult-class">AggExResult</a></code>, <code><a href="#topic+ExClust-class">ExClust</a></code>,
<code><a href="#topic+apcluster">apcluster</a></code>, <code><a href="#topic+apclusterL">apclusterL</a></code>, 
<code><a href="#topic+aggExCluster">aggExCluster</a></code>, <code><a href="#topic+cutree-methods">cutree-methods</a></code>,
<code><a href="#topic+plot-methods">plot-methods</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## create two Gaussian clouds
cl1 &lt;- cbind(rnorm(50, 0.2, 0.05), rnorm(50, 0.8, 0.06))
cl2 &lt;- cbind(rnorm(50, 0.7, 0.08), rnorm(50, 0.3, 0.05))
x &lt;- rbind(cl1, cl2)

## run affinity propagation using negative squared Euclidean
apres &lt;- apcluster(negDistMat(r=2), x, p=-0.1)

## plot heatmap clustering run
heatmap(apres)

## rerun affinity propagation
## reuse similarity matrix from previous run
apres2 &lt;- apcluster(s=apres@sim, q=0.6)

## plot heatmap of second run
heatmap(apres2, apres@sim)

## with alternate heatmap coloring, alternating color bars, and no dendrograms
heatmap(apres2, apres@sim, Rowv=NA, Colv=NA,
        sideColors=c("darkgreen", "yellowgreen"), col=terrain.colors(12))

## perform agglomerative clustering of affinity propagation clusters
aggres1 &lt;- aggExCluster(apres@sim, apres2)

## plot heatmap
heatmap(cutree(aggres1, 2), apres@sim)

## perform agglomerative clustering of whole data set
aggres2 &lt;- aggExCluster(negDistMat(r=2), x)

## show heatmap along with dendrogram
heatmap(aggres2)
</code></pre>

<hr>
<h2 id='labels-methods'>Generate label vector from clustering result</h2><span id='topic+labels'></span><span id='topic+labels-methods'></span><span id='topic+labels+2CAPResult-method'></span><span id='topic+labels+2CExClust-method'></span>

<h3>Description</h3>

<p>Generate a label vector from an clustering result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ExClust'
labels(object, type="names")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labels-methods_+3A_object">object</code></td>
<td>
<p>object of class <code><a href="#topic+APResult-class">APResult</a></code>
or <code><a href="#topic+ExClust-class">ExClust</a></code></p>
</td></tr>
<tr><td><code id="labels-methods_+3A_type">type</code></td>
<td>
<p>specifies which kind of label vector should be
created, see details below</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>labels</code> creates a label vector from a clustering
result. Which kind of labels are produced is controlled by the
argument <code>type</code>:
</p>

<dl>
<dt>&ldquo;names&rdquo;</dt><dd><p>(default) returns the name of the exemplar
to which each
data sample belongs to; if no names are available, the function
stops with an error;</p>
</dd>
<dt>&ldquo;enum&rdquo;</dt><dd><p>returns the index of the cluster to which
each data sample belongs to, where clusters are enumerated
consecutively from 1 to the number of clusters (analogous to
other clustering methods like <code><a href="stats.html#topic+kmeans">kmeans</a></code>);</p>
</dd>
<dt>&ldquo;exemplars&rdquo;</dt><dd><p>returns the index of the exemplar to
which each data sample belongs to, where indices of exemplars are
within the original data, which is nothing else but the slot
<code>object@idx</code> with attributes removed.</p>
</dd></dl>



<h3>Value</h3>

<p>returns a label vector as long as the number of samples in the
original data set
</p>


<h3>Author(s)</h3>

<p>Ulrich Bodenhofer &amp; Andreas Kothmeier
<a href="mailto:apcluster@bioinf.jku.at">apcluster@bioinf.jku.at</a></p>


<h3>References</h3>

<p><a href="http://www.bioinf.jku.at/software/apcluster/">http://www.bioinf.jku.at/software/apcluster/</a>
</p>
<p>Bodenhofer, U., Kothmeier, A., and Hochreiter, S. (2011)
APCluster: an R package for affinity propagation clustering.
<em>Bioinformatics</em> <b>27</b>, 2463-2464.
DOI: <a href="https://doi.org/10.1093/bioinformatics/btr406">doi:10.1093/bioinformatics/btr406</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+APResult-class">APResult</a></code>,
<code><a href="#topic+ExClust-class">ExClust</a></code>, <code><a href="#topic+cutree">cutree</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## create two simple clusters
x &lt;- c(1, 2, 3, 7, 8, 9)
names(x) &lt;- c("a", "b", "c", "d", "e", "f")

## compute similarity matrix (negative squared distance)
sim &lt;- negDistMat(x, r=2)

## run affinity propagation
apres &lt;- apcluster(sim)

## show details of clustering results
show(apres)

## label vector (names of exemplars)
labels(apres)

## label vector (consecutive index of exemplars)
labels(apres, type="enum")

## label vector (index of exemplars within original data set)
labels(apres, type="exemplars")

## now with agglomerative clustering
aggres &lt;- aggExCluster(sim)

## label (names of exemplars)
labels(cutree(aggres, 2))
</code></pre>

<hr>
<h2 id='plot'>Plot Clustering Results</h2><span id='topic+plot'></span><span id='topic+plot-methods'></span><span id='topic+plot+2CAPResult+2Cmissing-method'></span><span id='topic+plot+2CExClust+2Cmissing-method'></span><span id='topic+plot+2CExClust+2Cmatrix-method'></span><span id='topic+plot+2CExClust+2Cdata.frame-method'></span><span id='topic+plot+2CAggExResult+2Cmissing-method'></span><span id='topic+plot+2CAggExResult+2Cmatrix-method'></span><span id='topic+plot+2CAggExResult+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>Functions for Visualizing Clustering Results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'APResult,missing'
plot(x, y, type=c("netsim", "dpsim", "expref"),
    xlab="# Iterations", ylab="Similarity", ...)
## S4 method for signature 'ExClust,matrix'
plot(x, y, connect=TRUE, xlab="", ylab="",
labels=NA, limitNo=15, ...)
## S4 method for signature 'ExClust,data.frame'
plot(x, y, connect=TRUE, xlab="",
ylab="", labels=NA, limitNo=15, ...)
## S4 method for signature 'AggExResult,missing'
plot(x, y, main="Cluster dendrogram",
    xlab="", ylab="", ticks=4, digits=2, base=0.05, showSamples=FALSE,
    horiz=FALSE, ...)
## S4 method for signature 'AggExResult,matrix'
plot(x, y, k=NA, h=NA, ...)
## S4 method for signature 'AggExResult,data.frame'
plot(x, y, k=NA, h=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>a clustering result object of class
<code><a href="#topic+APResult-class">APResult</a></code>, <code><a href="#topic+ExClust-class">ExClust</a></code>,
or <code><a href="#topic+AggExResult-class">AggExResult</a></code></p>
</td></tr>
<tr><td><code id="plot_+3A_y">y</code></td>
<td>
<p>a matrix or data frame (see details below)</p>
</td></tr>
<tr><td><code id="plot_+3A_type">type</code></td>
<td>
<p>a string or array of strings indicating which
performance measures should be plotted; valid values are
<code>"netsim"</code>, <code>"dpsim"</code>, and <code>"expref"</code>
which can be used in any combination or order;
all other strings are ignored (for the meaning see
<code><a href="#topic+APResult-class">APResult</a></code>)</p>
</td></tr>
<tr><td><code id="plot_+3A_xlab">xlab</code>, <code id="plot_+3A_ylab">ylab</code></td>
<td>
<p>labels for axes of 2D plots; ignored if <code>y</code> has
more than two columns</p>
</td></tr>
<tr><td><code id="plot_+3A_labels">labels</code></td>
<td>
<p>names used for variables in scatter plot matrix
(displayed if <code>y</code> has more than two columns). If <code>NA</code>
(default), column names are used. If no column names are available,
labels such as <code>x[, 2]</code> are displayed.</p>
</td></tr>
<tr><td><code id="plot_+3A_limitno">limitNo</code></td>
<td>
<p>if the number of columns/features in <code>y</code> is too large,
problems may occur when attempting to plot a scatter plot matrix.
To avoid problems, the <code>plot</code> method throws an error if the
number of columns exceeds <code>limitNo</code>. For special applications,
users can increase the value (15 by default). If <code>limitNo</code>
is set to <code>NA</code> or any other non-numeric value, the limit is
ignored entirely. Please note that attempting to plot scatter plot
matrices with too many features may corrupt the graphics device.
So users are making changes at their own risk. If plotting of many
features is necessary, make sure that the graphics device is large
enough to accommodate the plot (e.g. by using a sufficiently large
graphics file device).</p>
</td></tr>
<tr><td><code id="plot_+3A_connect">connect</code></td>
<td>
<p>used only if clustering is plotted on original data,
ignored otherwise. If <code>connect</code> is <code>TRUE</code>, lines are
drawn connecting exemplars with their cluster members.</p>
</td></tr>
<tr><td><code id="plot_+3A_main">main</code></td>
<td>
<p>title of plot</p>
</td></tr>
<tr><td><code id="plot_+3A_ticks">ticks</code></td>
<td>
<p>number of ticks used for the axis on the left side of the
plot (applies to dendrogram plots only, see below)</p>
</td></tr>
<tr><td><code id="plot_+3A_digits">digits</code></td>
<td>
<p>number of digits used for the axis tickmarks on the left
side of the plot (applies to dendrogram plots only, see below)</p>
</td></tr>
<tr><td><code id="plot_+3A_base">base</code></td>
<td>
<p>fraction of height used for the very first join; defaults
to 0.05, i.e. the first join appears at 5% of the total height of the
dendrogram.</p>
</td></tr>
<tr><td><code id="plot_+3A_showsamples">showSamples</code></td>
<td>
<p>if <code>TRUE</code>, a complete cluster hierarchy is
shown, otherwise, in case that <code>x</code> is a hierarchy of clusters,
the dendrogram of clusters is shown. For backward compatibility, the
default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_horiz">horiz</code></td>
<td>
<p>if <code>TRUE</code>, the dendrogram is plotted horizontally
(analogous to <code><a href="stats.html#topic+plot.dendrogram">plot.dendrogram</a></code>).
The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_k">k</code></td>
<td>
<p>level to be selected when plotting a single clustering
level of cluster hierarchy (i.e. the number of clusters; see
<code><a href="#topic+cutree-methods">cutree-methods</a></code>)</p>
</td></tr>
<tr><td><code id="plot_+3A_h">h</code></td>
<td>
<p>cut-off to be used  when plotting a single clustering
level of cluster hierarchy (see <code><a href="#topic+cutree-methods">cutree-methods</a></code>)</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>all other arguments are passed to the plotting command that
are used internally, <code><a href="graphics.html#topic+plot">plot</a></code> or
<code><a href="stats.html#topic+heatmap">heatmap</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>plot</code> is called for an <code><a href="#topic+APResult-class">APResult</a></code> object
without specifying the second argument <code>y</code>,
a plot is created that displays graphs of performance
measures over execution time of the affinity propagation run.
This only works if <code><a href="#topic+apcluster">apcluster</a></code> was called with
<code>details=TRUE</code>.
</p>
<p>If <code>plot</code> is called for an <code><a href="#topic+APResult-class">APResult</a></code> object
along with a matrix or data frame as argument <code>y</code>, then the dimensions of
the matrix determine the behavior of <code>plot</code>:
</p>

<ol>
<li><p>If the matrix <code>y</code> has two columns, <code>y</code> is
interpreted as the original data set. Then a plot of
the clustering result superimposed on the original
data set is created. Each cluster is displayed in a
different color. The exemplar of each cluster is highlighted
by a black square. If <code>connect</code> is <code>TRUE</code>, lines
connecting the cluster members to their exemplars are drawn.
This variant of <code>plot</code> does not return any value.
</p>
</li>
<li><p>If <code>y</code> has more than two columns, clustering results are
superimposed in a sort of scatter plot matrix. The variant
that <code>y</code> is interpreted as similarity matrix if it is
quadratic has been removed in version 1.3.2. Use
<code><a href="#topic+heatmap">heatmap</a></code> instead.
</p>
</li>
<li><p>If <code>y</code> has only one column, an error is displayed.
</p>
</li></ol>

<p>If <code>plot</code> is called for an <code><a href="#topic+ExClust-class">ExClust</a></code> object
along with a matrix or data frame as argument <code>y</code>, then
<code>plot</code> behaves exactly the same as described in the previous
paragraph.
</p>
<p>If <code>plot</code> is called for an <code><a href="#topic+AggExResult-class">AggExResult</a></code> object
without specifying the second argument <code>y</code>, then a dendrogram
plot is drawn. This variant returns an invisible
<code><a href="stats.html#topic+dendrogram">dendrogram</a></code> object. The <code>showSamples</code> argument
determines whether a complete dendrogram or a dendrogram of clusters
is plotted (see above). If the option <code>horiz=TRUE</code> is used, the
dendrogram is rotated. Note that, in this case, the margin to the
right of the plot may not be wide enough to accommodate long
cluster/sample labels. In such a case, the figure margins have to
be widened before <code>plot</code> is called.
</p>
<p>If <code>plot</code> is called for an <code><a href="#topic+AggExResult-class">AggExResult</a></code> object
along with a matrix or data frame <code>y</code>, <code>y</code> is
again interpreted
as original data set. If one of the two arguments <code>k</code> or
<code>h</code> is present, a clustering is cut out from the cluster hierarchy 
using <code><a href="#topic+cutree">cutree</a></code> and this clustering is displayed with the
original data set as described above. This variant of
<code>plot</code> returns an invisible <code><a href="#topic+ExClust-class">ExClust</a></code> object
containing the extracted clustering.
</p>


<h3>Value</h3>

<p>see details above
</p>


<h3>Author(s)</h3>

<p>Ulrich Bodenhofer, Andreas Kothmeier &amp; Johannes Palme
<a href="mailto:apcluster@bioinf.jku.at">apcluster@bioinf.jku.at</a></p>


<h3>References</h3>

<p><a href="http://www.bioinf.jku.at/software/apcluster/">http://www.bioinf.jku.at/software/apcluster/</a>
</p>
<p>Bodenhofer, U., Kothmeier, A., and Hochreiter, S. (2011)
APCluster: an R package for affinity propagation clustering.
<em>Bioinformatics</em> <b>27</b>, 2463-2464.
DOI: <a href="https://doi.org/10.1093/bioinformatics/btr406">doi:10.1093/bioinformatics/btr406</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+APResult-class">APResult</a></code>,
<code><a href="#topic+AggExResult-class">AggExResult</a></code>, <code><a href="#topic+ExClust-class">ExClust</a></code>,
<code><a href="#topic+heatmap-methods">heatmap-methods</a></code>, <code><a href="#topic+apcluster">apcluster</a></code>, 
<code><a href="#topic+apclusterL">apclusterL</a></code>, <code><a href="#topic+aggExCluster">aggExCluster</a></code>, 
<code><a href="#topic+cutree-methods">cutree-methods</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## create two Gaussian clouds
cl1 &lt;- cbind(rnorm(50, 0.2, 0.05), rnorm(50, 0.8, 0.06))
cl2 &lt;- cbind(rnorm(50, 0.7, 0.08), rnorm(50, 0.3, 0.05))
x &lt;- rbind(cl1, cl2)

## run affinity propagation
apres &lt;- apcluster(negDistMat(r=2), x, q=0.7, details=TRUE)

## plot information about clustering run
plot(apres)

## plot clustering result
plot(apres, x)

## perform agglomerative clustering of affinity propagation clusters
aggres1 &lt;- aggExCluster(x=apres)

## show dendrograms
plot(aggres1)
plot(aggres1, showSamples=TRUE)

## show clustering result for 4 clusters
plot(aggres1, x, k=4)

## perform agglomerative clustering of whole data set
aggres2 &lt;- aggExCluster(negDistMat(r=2), x)

## show dendrogram
plot(aggres2)

## show heatmap along with dendrogram
heatmap(aggres2)

## show clustering result for 2 clusters
plot(aggres2, x, k=2)

## cluster iris data set
data(iris)
apIris &lt;- apcluster(negDistMat(r=2), iris, q=0)
plot(apIris, iris)
</code></pre>

<hr>
<h2 id='preferenceRange'>Determine Meaningful Ranges for Input Preferences</h2><span id='topic+preferenceRange'></span><span id='topic+preferenceRange-methods'></span><span id='topic+preferenceRange+2Cmatrix-method'></span><span id='topic+preferenceRange+2CMatrix-method'></span><span id='topic+preferenceRange+2CdgTMatrix-method'></span><span id='topic+preferenceRange+2CsparseMatrix-method'></span>

<h3>Description</h3>

<p>Determines meaningful ranges for affinity propagation input preference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
preferenceRange(s, exact=FALSE)
## S4 method for signature 'Matrix'
preferenceRange(s, exact=FALSE)
## S4 method for signature 'dgTMatrix'
preferenceRange(s, exact=FALSE)
## S4 method for signature 'sparseMatrix'
preferenceRange(s, exact=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preferenceRange_+3A_s">s</code></td>
<td>
<p>an <code class="reqn">l\times l</code> similarity matrix in sparse or dense format</p>
</td></tr>
<tr><td><code id="preferenceRange_+3A_exact">exact</code></td>
<td>
<p>flag indicating whether exact ranges should be computed,
which is relatively slow; if bounds are sufficient,
supply <code>FALSE</code> (default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Affinity Propagation clustering relies on an appropriate choice
of input preferences. This function helps in finding a good choice by
determining meaningful lower and upper bounds.
</p>
<p>If the similarity matrix <code>s</code> is sparse or if it contains
<code>-Inf</code> similarities, only the similarities are taken into account
that are specified in <code>s</code> and larger than <code>-Inf</code>. In such
cases, the lower bound returned by <code>preferenceRange</code> need not
correspond to one or two clusters. Moreover, it may also happen in
degenerate cases that the lower bound exceeds the upper bound.
In such a case, no warning or error is issued, so it is the user's
responsibility to ensure a proper interpretation of the results.
The method <code><a href="#topic+apclusterK">apclusterK</a></code> makes use of this function
internally and checks the plausibility of the result
returned by <code>preferenceRange</code>.
</p>


<h3>Value</h3>

<p>returns a vector with two entries, the first of which is the minimal
input preference (which would lead to 1 or 2 clusters) and the second
of which is the maximal input prefence (which would lead to as many
clusters as data samples).
</p>


<h3>Author(s)</h3>

<p>Ulrich Bodenhofer &amp; Andreas Kothmeier
<a href="mailto:apcluster@bioinf.jku.at">apcluster@bioinf.jku.at</a></p>


<h3>References</h3>

<p><a href="http://www.bioinf.jku.at/software/apcluster/">http://www.bioinf.jku.at/software/apcluster/</a>
</p>
<p>Frey, B. J. and Dueck, D. (2007) Clustering by passing messages
between data points. <em>Science</em> <b>315</b>, 972-976.
DOI: <a href="https://doi.org/10.1126/science.1136800">doi:10.1126/science.1136800</a>.
</p>
<p>Bodenhofer, U., Kothmeier, A., and Hochreiter, S. (2011)
APCluster: an R package for affinity propagation clustering.
<em>Bioinformatics</em> <b>27</b>, 2463-2464.
DOI: <a href="https://doi.org/10.1093/bioinformatics/btr406">doi:10.1093/bioinformatics/btr406</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apcluster">apcluster</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## create two Gaussian clouds
cl1 &lt;- cbind(rnorm(100, 0.2, 0.05), rnorm(100, 0.8, 0.06))
cl2 &lt;- cbind(rnorm(50, 0.7, 0.08), rnorm(50, 0.3, 0.05))
x &lt;- rbind(cl1, cl2)

## create similarity matrix
sim &lt;- negDistMat(x, r=2)

## determine bounds
preferenceRange(sim)

## determine exact range
preferenceRange(sim, exact=TRUE)
</code></pre>

<hr>
<h2 id='show-methods'>Display Clustering Result Objects</h2><span id='topic+show'></span><span id='topic+show-methods'></span><span id='topic+show+2CAPResult-method'></span><span id='topic+show+2CExClust-method'></span><span id='topic+show+2CAggExResult-method'></span>

<h3>Description</h3>

<p>Display methods for S4 classes <code><a href="#topic+APResult-class">APResult</a></code>,
<code><a href="#topic+ExClust-class">ExClust</a></code>, and <code><a href="#topic+AggExResult-class">AggExResult</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'APResult'
show(object)
## S4 method for signature 'ExClust'
show(object)
## S4 method for signature 'AggExResult'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show-methods_+3A_object">object</code></td>
<td>
<p>an object of class
<code><a href="#topic+APResult-class">APResult</a></code>, <code><a href="#topic+ExClust-class">ExClust</a></code>, or
<code><a href="#topic+AggExResult-class">AggExResult</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>show</code> displays the most important information stored in
<code>object</code>.
</p>
<p>For <code><a href="#topic+APResult-class">APResult</a></code> objects,
the number of data samples, the number of clusters, the number of
iterations, the input preference, the final objective
function values, the vector of exemplars, the list of clusters and
for leveraged clustering the selected sample subset are printed.  
</p>
<p>For <code><a href="#topic+ExClust-class">ExClust</a></code> objects,
the number of data samples, the number of clusters,
the vector of exemplars, and list of clusters are printed.
</p>
<p>For <code><a href="#topic+AggExResult-class">AggExResult</a></code> objects,
only the number of data samples and the maximum
number of clusters are printed. For retrieving a particular
clustering level, use the function <code><a href="#topic+cutree">cutree</a></code>.
</p>
<p>For accessing more detailed information, it is necessary to
access the slots of <code>object</code> directly. Use
<code><a href="utils.html#topic+str">str</a></code> to get a compact overview of all slots of an object.
</p>


<h3>Value</h3>

<p><code>show</code> returns an invisible <code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Ulrich Bodenhofer, Andreas Kothmeier &amp; Johannes Palme
<a href="mailto:apcluster@bioinf.jku.at">apcluster@bioinf.jku.at</a></p>


<h3>References</h3>

<p><a href="http://www.bioinf.jku.at/software/apcluster/">http://www.bioinf.jku.at/software/apcluster/</a>
</p>
<p>Bodenhofer, U., Kothmeier, A., and Hochreiter, S. (2011)
APCluster: an R package for affinity propagation clustering.
<em>Bioinformatics</em> <b>27</b>, 2463-2464.
DOI: <a href="https://doi.org/10.1093/bioinformatics/btr406">doi:10.1093/bioinformatics/btr406</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+APResult-class">APResult</a></code>,
<code><a href="#topic+ExClust-class">ExClust</a></code>, <code><a href="#topic+AggExResult-class">AggExResult</a></code>,
<code><a href="#topic+cutree-methods">cutree-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create two Gaussian clouds
cl1 &lt;- cbind(rnorm(100, 0.2, 0.05), rnorm(100, 0.8, 0.06))
cl2 &lt;- cbind(rnorm(50, 0.7, 0.08), rnorm(50, 0.3, 0.05))
x &lt;- rbind(cl1, cl2)

## compute similarity matrix (negative squared Euclidean)
sim &lt;- negDistMat(x, r=2)

## run affinity propagation
apres &lt;- apcluster(sim)

## show details of clustering results
show(apres)

## apply agglomerative clustering to apres
aggres &lt;- aggExCluster(sim, apres)

## display overview of result
show(aggres)

## show clustering level with two clusters
show(cutree(aggres, 2))
</code></pre>

<hr>
<h2 id='similarities'>Methods for Computing Similarity Matrices</h2><span id='topic+similarities'></span><span id='topic+negDistMat'></span><span id='topic+expSimMat'></span><span id='topic+linSimMat'></span><span id='topic+corSimMat'></span><span id='topic+linKernel'></span>

<h3>Description</h3>

<p>Compute similarity matrices from data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>negDistMat(x, sel=NA, r=1, method="euclidean", p=2)
expSimMat(x, sel=NA, r=2, w=1, method="euclidean", p=2)
linSimMat(x, sel=NA, w=1, method="euclidean", p=2)
corSimMat(x, sel=NA, r=1, signed=TRUE, method="pearson")
linKernel(x, sel=NA, normalize=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="similarities_+3A_x">x</code></td>
<td>
<p>input data to be clustered; if <code>x</code> is a vector, it is
interpreted as a list of scalar values that are to be clustered;
if <code>x</code> is a matrix or data frame, rows are interpreted as
samples and columns are interpreted as features; in the case
that <code>x</code> is a data frame, only numerical columns/features are
taken into account, whereas categorical features are neglected. If
<code>x</code> is missing, all functions return a function that
can be used as similarity measure, in particular, as
<code>s</code> argument for <code><a href="#topic+apclusterL">apclusterL</a></code>.</p>
</td></tr>
<tr><td><code id="similarities_+3A_sel">sel</code></td>
<td>
<p>selected samples subset; vector of row indices
for x in increasing order (see details below)</p>
</td></tr>
<tr><td><code id="similarities_+3A_r">r</code></td>
<td>
<p>exponent (see details below)</p>
</td></tr>
<tr><td><code id="similarities_+3A_w">w</code></td>
<td>
<p>radius (see details below)</p>
</td></tr>
<tr><td><code id="similarities_+3A_signed">signed</code></td>
<td>
<p>take sign of correlation into account (see details below)</p>
</td></tr>
<tr><td><code id="similarities_+3A_normalize">normalize</code></td>
<td>
<p>see details below</p>
</td></tr>
<tr><td><code id="similarities_+3A_method">method</code></td>
<td>
<p>type of distance measure to be used; for <code>negDistMat</code>,
<code>expSimMat</code> and <code>linSimMat</code>, this argument is analogous to the
<code>method</code> argument of <code><a href="stats.html#topic+dist">dist</a></code>.
For <code>corSimMat</code>, this argument is analogous to the <code>method</code>
argument of <code><a href="stats.html#topic+cor">cor</a></code>.</p>
</td></tr>
<tr><td><code id="similarities_+3A_p">p</code></td>
<td>
<p>exponent for Minkowski distance; only used for
<code>method="minkowski"</code>, otherwise ignored. See
<code><a href="stats.html#topic+dist">dist</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>negDistMat</code> creates a square matrix of mutual
pairwise similarities of data vectors as negative distances. The
argument <code>r</code> (default is 1) is used to transform the resulting
distances by computing the r-th power (use <code>r=2</code> to obtain
negative squared distances as in Frey's and Dueck's demos), i.e.,
given a distance d, the resulting similarity is computed as
<code class="reqn">s=-d^r</code>. With the parameter <code>sel</code> a subset of samples
can be specified for distance calculation. In this case not the 
full distance matrix is computed but a rectangular similarity matrix
of all samples (rows) against the subset (cols) as needed for 
leveraged clustering. Internally, the computation of distances is 
done using an internal method derived from 
<code><a href="stats.html#topic+dist">dist</a></code>. All options of this function except 
<code>diag</code> and <code>upper</code> can be used, especially <code>method</code> 
which allows for selecting different distance measures.
Note that, since version 1.4.4. of the package, there is an additional
method <code>"discrepancy"</code> that implements Weyl's discrepancy measure.
</p>
<p><code>expSimMat</code> computes similarities in a way similar to
<code>negDistMat</code>, but the transformation of distances to similarities
is done in the following way:
</p>
<p style="text-align: center;"><code class="reqn">s=\exp\left(-\left(\frac{d}{w}\right)^r\right)</code>
</p>

<p>The parameter <code>sel</code> allows the creation of a rectangular
similarity matrix. As above, r is an exponent. The parameter w controls 
the speed of descent. <code>r=2</code> in conjunction with Euclidean 
distances corresponds to the well-known Gaussian/RBF kernel, 
whereas <code>r=1</code> corresponds to the Laplace kernel. Note that these
similarity measures can also be understood as fuzzy equality relations.
</p>
<p><code>linSimMat</code> provides another way of transforming distances
into similarities by applying the following transformation to a
distance d:
</p>
<p style="text-align: center;"><code class="reqn">s=\max\left(0,1-\frac{d}{w}\right)</code>
</p>

<p>Thw parameter <code>sel</code> is used again for creation of a rectangular
similarity matrix. Here <code>w</code> corresponds to a maximal radius of 
interest. Note that this is a fuzzy equality relation with respect to 
the Lukasiewicz t-norm.
</p>
<p>Unlike the above three functions, <code>linKernel</code> computes pairwise
similarities as scalar products of data vectors, i.e. it corresponds,
as the name suggests, to the &ldquo;linear kernel&rdquo;. Use parameter 
<code>sel</code> to compute only a submatrix of the full kernel matrix as 
described above. If <code>normalize=TRUE</code>, the values are scaled to 
the unit sphere in the following way (for two samples <code>x</code> and 
<code>y</code>:
</p>
<p style="text-align: center;"><code class="reqn">s=\frac{\vec{x}^T\vec{y}}{\|\vec{x}\| \|\vec{y}\|}</code>
</p>

<p>The function <code>corSimMat</code> computes pairwise similarities as
correlations. It uses <code>link[stats:cor]{cor}</code> internally.
The <code>method</code> argument is passed on to <code>link[stats:cor]{cor}</code>.
The argument <code>r</code> serves as an exponent with which the correlations
can be transformed. If <code>signed=TRUE</code> (default), negative correlations are
taken into account, i.e. two samples are maximally dissimilar if they
are negatively correlated. If <code>signed=FALSE</code>, similarities are
computed as absolute values of correlations, i.e. two samples are
maximally similar if they are positively or negatively correlated and
the two samples are maximally dissimilar if they are uncorrelated.
</p>
<p>Note that the naming of the argument <code>p</code> has been chosen for
consistency with <code><a href="stats.html#topic+dist">dist</a></code> and previous versions 
of the package. When using leveraged AP in
conjunction with the Minkowski distance, this leads to conflicts with
the input preference parameter <code>p</code> of
<code><a href="#topic+apclusterL">apclusterL</a></code>. In order to avoid that, use the above
functions without <code>x</code> argument to create a custom similarity
measure with fixed parameter <code>p</code> (see example below).
</p>


<h3>Value</h3>

<p>All functions listed above return square or rectangular matrices 
of similarities.
</p>


<h3>Author(s)</h3>

<p>Ulrich Bodenhofer, Andreas Kothmeier &amp; Johannes Palme
<a href="mailto:apcluster@bioinf.jku.at">apcluster@bioinf.jku.at</a></p>


<h3>References</h3>

<p><a href="http://www.bioinf.jku.at/software/apcluster/">http://www.bioinf.jku.at/software/apcluster/</a>
</p>
<p>Bodenhofer, U., Kothmeier, A., and Hochreiter, S. (2011)
APCluster: an R package for affinity propagation clustering.
<em>Bioinformatics</em> <b>27</b>, 2463-2464.
DOI: <a href="https://doi.org/10.1093/bioinformatics/btr406">doi:10.1093/bioinformatics/btr406</a>.
</p>
<p>Frey, B. J. and Dueck, D. (2007) Clustering by passing messages
between data points. <em>Science</em> <b>315</b>, 972-976.
DOI: <a href="https://doi.org/10.1126/science.1136800">doi:10.1126/science.1136800</a>.
</p>
<p>Micchelli, C. A. (1986) Interpolation of scattered data: distance
matrices and conditionally positive definite functions.
<em>Constr. Approx.</em> <b>2</b>, 11-20.
</p>
<p>De Baets, B. and Mesiar, R. (1997) Pseudo-metrics and T-equivalences.
<em>J. Fuzzy Math.</em> <b>5</b>, 471-481.
</p>
<p>Bauer, P., Bodenhofer, U., and Klement, E. P. (1996)
A fuzzy algorithm for pixel classification based on the discrepancy
norm.
In <em>Proc. 5th IEEE Int. Conf. on Fuzzy Systems</em>, volume III, pages
2007&ndash;2012, New Orleans, LA.
DOI: <a href="https://doi.org/10.1109/FUZZY.1996.552744">doi:10.1109/FUZZY.1996.552744</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>,
<code><a href="#topic+apcluster">apcluster</a></code>, <code><a href="#topic+apclusterL">apclusterL</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## create two Gaussian clouds
cl1 &lt;- cbind(rnorm(100, 0.2, 0.05), rnorm(100, 0.8, 0.06))
cl2 &lt;- cbind(rnorm(100, 0.7, 0.08), rnorm(100, 0.3, 0.05))
x &lt;- rbind(cl1, cl2)

## create negative distance matrix (default Euclidean)
sim1 &lt;- negDistMat(x)

## compute similarities as squared negative distances
## (in accordance with Frey's and Dueck's demos)
sim2 &lt;- negDistMat(x, r=2)

## compute RBF kernel
sim3 &lt;- expSimMat(x, r=2)

## compute similarities as squared negative distances
## all samples versus a randomly chosen subset 
## of 50 samples (for leveraged AP clustering)
sel &lt;- sort(sample(1:nrow(x), nrow(x)*0.25)) 
sim4 &lt;- negDistMat(x, sel, r=2)


## example of leveraged AP using Minkowski distance with non-default
## parameter p
cl1 &lt;- cbind(rnorm(150, 0.2, 0.05), rnorm(150, 0.8, 0.06))
cl2 &lt;- cbind(rnorm(100, 0.7, 0.08), rnorm(100, 0.3, 0.05))
x &lt;- rbind(cl1, cl2)

apres &lt;- apclusterL(s=negDistMat(method="minkowski", p=2.5, r=2),
                       x, frac=0.2, sweeps=3, p=-0.2)
show(apres)
</code></pre>

<hr>
<h2 id='sort-methods'>Sort clusters</h2><span id='topic+sort'></span><span id='topic+sort-methods'></span><span id='topic+sort+2CAPResult-method'></span><span id='topic+sort+2CExClust-method'></span>

<h3>Description</h3>

<p>Rearrange clusters according to sort criterion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ExClust'
sort(x, decreasing=FALSE,
                   sortBy=c("aggExCluster", "size",
                            "nameExemplar", "noExemplar"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort-methods_+3A_x">x</code></td>
<td>
<p>object of class <code><a href="#topic+APResult-class">APResult</a></code>
or <code><a href="#topic+ExClust-class">ExClust</a></code></p>
</td></tr>
<tr><td><code id="sort-methods_+3A_decreasing">decreasing</code></td>
<td>
<p>logical indicating if sorting should be done in
decreasing order, see details below</p>
</td></tr>
<tr><td><code id="sort-methods_+3A_sortby">sortBy</code></td>
<td>
<p>sort criterion, see details below</p>
</td></tr>
<tr><td><code id="sort-methods_+3A_...">...</code></td>
<td>
<p>further arguments are ignored; only defined for S3 method
consistency</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>sort</code> takes an <code><a href="#topic+APResult-class">APResult</a></code>
or <code><a href="#topic+ExClust-class">ExClust</a></code> clustering object <code>x</code> and creates
a new clustering object of the same class, but with clusters arranged
according to the sort criterion passed as argument <code>sortBy</code>:
</p>

<dl>
<dt>&ldquo;aggExCluster&rdquo;</dt><dd><p>(default) order clusters as they
would appear in the dendrogram produced by
<code><a href="#topic+aggExCluster">aggExCluster</a></code>. This is also the same ordering in
which the clusters are arranged by <code><a href="#topic+heatmap">heatmap</a></code>.
Note that this only works if the similarity matrix is included
in the input object <code>x</code>, otherwise an error message is
produced.</p>
</dd>
<dt>&ldquo;size&rdquo;</dt><dd><p>sorts clusters according to their size (from
small to large).</p>
</dd>
<dt>&ldquo;nameExemplar&rdquo;</dt><dd><p>sorts clusters according to the names
of the examplars (if available, otherwise an error is produced).</p>
</dd>
<dt>&ldquo;noExemplar&rdquo;</dt><dd><p>sorts clusters according to the indices
of the examplars.</p>
</dd>
</dl>

<p>If <code>decreasing</code> is <code>TRUE</code>, the order is reversed and, for
example, <code>sortBy="size"</code> sorts clusters with such that the larger
clusters come first.
</p>
<p>Note that the cluster numbers of <code>x</code> are not preserved by
<code>sort</code>, i.e. the cluster no. 1 of the object returned by
<code>sort</code> is the one that has been ranked first by <code>sort</code>,
which may not necessarily coincide with cluster no. 1 of the original
clustering object <code>x</code>.
</p>
<p>Note that this is an S3 method (whereas all other methods in this
package are S4 methods). This inconsistency has been introduced in
order to avoid interoperability problems with the <span class="pkg">BiocGenerics</span>
package which may overwrite the definition of the <code>sort</code> generic
if it is loaded after the <span class="pkg">apcluster</span> package.
</p>


<h3>Value</h3>

<p>returns a copy of <code>x</code>, but with slots <code>exemplars</code> and
<code>clusters</code> (see <code><a href="#topic+APResult-class">APResult</a></code>
or <code><a href="#topic+ExClust-class">ExClust</a></code>) reordered.
</p>


<h3>Author(s)</h3>

<p>Ulrich Bodenhofer
<a href="mailto:apcluster@bioinf.jku.at">apcluster@bioinf.jku.at</a></p>


<h3>References</h3>

<p><a href="http://www.bioinf.jku.at/software/apcluster/">http://www.bioinf.jku.at/software/apcluster/</a>
</p>
<p>Bodenhofer, U., Kothmeier, A., and Hochreiter, S. (2011)
APCluster: an R package for affinity propagation clustering.
<em>Bioinformatics</em> <b>27</b>, 2463-2464.
DOI: <a href="https://doi.org/10.1093/bioinformatics/btr406">doi:10.1093/bioinformatics/btr406</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+APResult-class">APResult</a></code>, <code><a href="#topic+ExClust-class">ExClust</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## create two Gaussian clouds
cl1 &lt;- cbind(rnorm(50,0.2,0.05),rnorm(50,0.8,0.06))
cl2 &lt;- cbind(rnorm(50,0.7,0.08),rnorm(50,0.3,0.05))
x &lt;- rbind(cl1,cl2)

## run affinity propagation
apres &lt;- apcluster(negDistMat(r=2), x, q=0.7)

show(apres)
## show dendrogram
plot(aggExCluster(x=apres))

## default sort order: like in heatmap or dendrogram
show(sort(apres))

## show dendrogram (note the different cluster numbers!)
plot(aggExCluster(x=sort(apres)))

## sort by size
show(sort(apres, decreasing=TRUE, sortBy="size"))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
