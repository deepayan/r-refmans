<!DOCTYPE html><html><head><title>Help for package matchr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {matchr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%.%'><p>Compose Functions</p></a></li>
<li><a href='#%fn%'><p>Create Function</p></a></li>
<li><a href='#bang'><p>Extract Result or Return</p></a></li>
<li><a href='#Enum'><p>Create Enumerated Type</p></a></li>
<li><a href='#enum_type'><p>Enum Type</p></a></li>
<li><a href='#Err'><p>Create an 'Err' Result</p></a></li>
<li><a href='#fallthrough'><p>Fall Through Match</p></a></li>
<li><a href='#into_option'><p>Convert Object into Option</p></a></li>
<li><a href='#into_result'><p>Convert Object into Result</p></a></li>
<li><a href='#is.enum'><p>Is Object an Enum</p></a></li>
<li><a href='#is.enum_type'><p>Check Enum Type</p></a></li>
<li><a href='#is.err'><p>Check if Result is an Err</p></a></li>
<li><a href='#is.none'><p>Check if Option is None</p></a></li>
<li><a href='#is.ok'><p>Check if Result is Ok</p></a></li>
<li><a href='#is.some'><p>Check if Option is Some</p></a></li>
<li><a href='#is.variant'><p>Check Enum Variant</p></a></li>
<li><a href='#Match'><p>Match Value Against Multiple Values</p></a></li>
<li><a href='#match_cond'><p>Check and Evaluate Match Condition</p></a></li>
<li><a href='#Matchply'><p>Match Each Object in List or Vector</p></a></li>
<li><a href='#None'><p>None</p></a></li>
<li><a href='#Ok'><p>Create an 'Ok' Result</p></a></li>
<li><a href='#Option'><p>Option</p></a></li>
<li><a href='#Result'><p>Result</p></a></li>
<li><a href='#Some'><p>Create an 'Some' Option</p></a></li>
<li><a href='#Try'><p>Execute Expression as Result</p></a></li>
<li><a href='#unwrap'><p>Extract the Value Contained in Enum</p></a></li>
<li><a href='#variant'><p>Enum Variant</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Pattern Matching and Enumerated Types in R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Christopher Mann &lt;cmann3@unl.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christopher Mann &lt;cmann3@unl.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Inspired by pattern matching and enum types in Rust
    and many functional programming languages, this package offers
    an updated version of the 'switch' function called 'Match' that
    accepts atomic values, functions, expressions, and enum variants.
    Conditions and return expressions are separated by '-&gt;' and 
    multiple conditions can be associated with the same return expression
    using '|'. 'Match' also includes support for 'fallthrough'. The 
    package also replicates the Result and Option enums from Rust.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), rlang, utils</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-07 14:25:34 UTC; chris</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-09 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25.+25'>Compose Functions</h2><span id='topic++25.+25'></span>

<h3>Description</h3>

<p>Combine two functions into a single function so that the <code>rhs</code> is called on the arguments first,
then the <code>lhs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %.% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25.+2B25_+3A_lhs">lhs</code></td>
<td>
<p>function to be called second</p>
</td></tr>
<tr><td><code id="+2B25.+2B25_+3A_rhs">rhs</code></td>
<td>
<p>function to be called first</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a composed function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sq_log &lt;- round %.% sqrt %.% log

Match(
  10:20,
  i %fn% (sq_log(i) &gt; 2) -&gt;
    "big",
  . -&gt;
    "small"
)
</code></pre>

<hr>
<h2 id='+25fn+25'>Create Function</h2><span id='topic++25fn+25'></span>

<h3>Description</h3>

<p>Syntactic sugar for creating a single-variable function. Can be conveniently used in <code><a href="#topic+Match">Match</a></code> statements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %fn% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25fn+2B25_+3A_lhs">lhs</code></td>
<td>
<p>symbol used to denote the function argument</p>
</td></tr>
<tr><td><code id="+2B25fn+2B25_+3A_rhs">rhs</code></td>
<td>
<p>expression that is converted to the function body. <code>rhs</code> may need to be surrounded
by parentheses is other infix operators are used due to precedence rules.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Match(
  "abc",
  is.numeric  -&gt; -1,
  i %fn% grepl("bc", i) -&gt; 0,
  is.character -&gt; 1
)

print_sq_log &lt;- i %fn% print(sqrt(log(i)))
print_sq_log(10)

</code></pre>

<hr>
<h2 id='bang'>Extract Result or Return</h2><span id='topic+bang'></span><span id='topic++21.Result'></span><span id='topic++21.Option'></span>

<h3>Description</h3>

<p>Returns the value contained inside of an <a href="#topic+Result">Result</a> or <a href="#topic+Option">Option</a> Enum or returns if failure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Result'
!x, ...

## S3 method for class 'Option'
!x, ...
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bang_+3A_x">x</code></td>
<td>
<p>Enumerated value of type <a href="#topic+Result">Result</a> or <a href="#topic+Option">Option</a> to unwrap</p>
</td></tr>
<tr><td><code id="bang_+3A_...">...</code></td>
<td>
<p>objects to be passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is similar to <code><a href="#topic+unwrap">unwrap</a></code> for <a href="#topic+Result">Result</a> and <a href="#topic+Option">Option</a> objects. However,
an <code>Err</code> or <code>None</code> variant does not cause execution to stop. Instead, the parent
function immediately returns the Enum intact. Inspired by the <code>?</code> operator in Rust.
</p>


<h3>Value</h3>

<p>an object of any class or <code>x</code> if failure.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>!.Result</code>: Unwrap Result if Ok, otherwise return the Err variant in the parent function.
</p>
</li>
<li> <p><code>!.Option</code>: Unwrap Option if Some, otherwise return the None variant in the parent function.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>is_big &lt;- function(x) {
  if (x &gt; 10) return(Ok(x))
  Err("This is small!")
}

# If 'x' is greater than 10, the value will be printed.
# Otherwise, an error is returned.
print_big &lt;- function(x) {
  print(!is_big(x))
}

</code></pre>

<hr>
<h2 id='Enum'>Create Enumerated Type</h2><span id='topic+Enum'></span>

<h3>Description</h3>

<p>An object inspired by enums in Rust and types in other functional languages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Enum(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Enum_+3A_...">...</code></td>
<td>
<p>Symbols specifying the named of the variant, or language call with the names and default values of objects
contained within the variant. Other values can be used as long as the variant is named. The first item in
<code>...</code> can optionally be a character string that names Enum.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>Enum</code> function creates a list of objects of class &quot;Enum&quot; *or* functions that generate &quot;Enum&quot; objects
similar to those found in Rust of similar languages. Symbols or characters passed to <code>Enum</code> become the new
variants. Language objects, i.e. a name followed by parentheses <code>name(...)</code>, associate the name with the
variant and create a function based on the arguments passed in <code>...</code>. When function is called, the
passed arguments are converted into a named list of class &quot;Enum&quot; and associated variant. Like functions, default
values can be given to the variants.
</p>
<p>Variants can be assigned specific values using '<code>=</code>'. For example, <code>Enum( Hello = "world" )</code> creates
an enum variant named &quot;Hello&quot; with the underlying value of <code>"world"</code>. If the initial variant is assigned a
single numeric value, then subsequent variants are automatically assigned the next highest value if possible,
similar to using <code>iota()</code> in Go. Variant names are not allowed to be numeric values or other non-symbolic
values.
</p>


<h3>Value</h3>

<p>a list of variants or variant generators
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Create a Linked List

# Node is an enum with two varieties: a link to the next node, and none
# 'Node$Some' is a function that accepts two values and generates the enum
# variant, while 'Node$Empty' is a variant
Node &lt;- Enum(
  Some(Val, Next),
  Empty
)

# Initialize an empty linked list, push values to the front
new_list &lt;- Node$Empty
new_list &lt;- Node$Some(1, new_list)
new_list &lt;- Node$Some(2, new_list)
new_list

# return the head of the list ('car') and tail ('cdr')
car &lt;- new_list$Val
cdr &lt;- new_list$Next


### RGB Colors

# The Color enum is provided with a named type "Color". All
# variants will have both "Enum" and "Color" as a class.
# Each variant is associated with a specific value.
Color &lt;- Enum(
  "Color",
  Black = c(0,0,0),
  Red   = c(255,0,0),
  Green = c(0, 255, 0),
  Blue  = c(0, 0, 255),
  White = c(255, 255, 255)
)

Color$Red

# This will generate an error since it is not a function
# Color$Black()


### Directions

# This enum creates a sequence of numbers associated with
# a particular direction. Enum automatically increments the
# values if the initial variant is assigned a single number
Direction &lt;- Enum(
  North = 1,
  East,
  South,
  West
)

# This will result in '5' since North is '1' and West is '4'
Direction$North + Direction$West

</code></pre>

<hr>
<h2 id='enum_type'>Enum Type</h2><span id='topic+enum_type'></span>

<h3>Description</h3>

<p>Return the enumerated type name of an object, if a name was provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enum_type(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enum_type_+3A_x">x</code></td>
<td>
<p>Enum object</p>
</td></tr>
<tr><td><code id="enum_type_+3A_...">...</code></td>
<td>
<p>objects passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character with the name of the enumerated type or <code>NULL</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Result$Ok("hello world!")
enum_type(x)  # "Result"
</code></pre>

<hr>
<h2 id='Err'>Create an 'Err' Result</h2><span id='topic+Err'></span>

<h3>Description</h3>

<p>Create an Enum variant of <code>Result</code> used to denote that function contained an error.
This allows the creation of safer functions that do not automatically stop, without using
<code>try</code> or <code>tryCatch</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Err(e)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Err_+3A_e">e</code></td>
<td>
<p>Object to be wrapped in the Enum variant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with a single value <code>e</code> and classes <code>"Result} and \code{"Enum</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grepl_safe &lt;- function(pattern, x)
{
  if (!is.character(pattern)){ return(Err("'pattern' in 'grepl_safe' was not a character value.")) }
  if (!is.character(x)){ return(Err("'x' in 'grepl_safe' was not a character value.")) }
  Ok(grepl(pattern, x))
}

#grepl_safe(123, 1:5)

</code></pre>

<hr>
<h2 id='fallthrough'>Fall Through Match</h2><span id='topic+fallthrough'></span>

<h3>Description</h3>

<p>Stop execution of current return expression in <code><a href="#topic+Match">Match</a></code>, then continue attempting to match conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fallthrough()
</code></pre>


<h3>Value</h3>

<p>Object of class 'fallthrough'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Match(
  "abc",
  is.character -&gt; {
    print("Found a character.")
    fallthrough()
  },
  "abc" -&gt; "start of the alphabet",
  .     -&gt; "found nothing"
)
</code></pre>

<hr>
<h2 id='into_option'>Convert Object into Option</h2><span id='topic+into_option'></span>

<h3>Description</h3>

<p>Create an <code><a href="#topic+Option">Option</a></code> out of an object. By default the object is wrapped in a <code>Some</code> variant.
<code>Ok</code> variants of <code><a href="#topic+Result">Result</a></code> are turned into <code>Some</code> Options, while <code>Err</code> variants are
turned into <code>None</code> Options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>into_option(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="into_option_+3A_x">x</code></td>
<td>
<p>Object to be converted</p>
</td></tr>
<tr><td><code id="into_option_+3A_...">...</code></td>
<td>
<p>Objects passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an Enum object of class <code>Option</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>an_error &lt;- Result$Err("hello world!")
into_option(an_error) # None

</code></pre>

<hr>
<h2 id='into_result'>Convert Object into Result</h2><span id='topic+into_result'></span>

<h3>Description</h3>

<p>Create a <code><a href="#topic+Result">Result</a></code> out of an object. By default the object is wrapped in an <code>Ok</code> variant.
<code>Some</code> variants of <code><a href="#topic+Option">Option</a></code> are turned into <code>Ok</code> Results, while <code>None</code> variants are
turned into <code>Err</code> Results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>into_result(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="into_result_+3A_x">x</code></td>
<td>
<p>Object to be converted</p>
</td></tr>
<tr><td><code id="into_result_+3A_...">...</code></td>
<td>
<p>Objects passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an Enum object of class <code>Result</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nothing &lt;- Option$None
into_result(nothing) # Err

</code></pre>

<hr>
<h2 id='is.enum'>Is Object an Enum</h2><span id='topic+is.enum'></span>

<h3>Description</h3>

<p>Test whether object has class <code><a href="#topic+Enum">Enum</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.enum(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.enum_+3A_x">x</code></td>
<td>
<p>object to be tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is an Enum, <code>FALSE</code> otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HelloEnum &lt;- Enum(
  "HelloEnum",
  Hello,
  World
)

# TRUE
is.enum(HelloEnum$Hello)

# FALSE
is.enum(5)

</code></pre>

<hr>
<h2 id='is.enum_type'>Check Enum Type</h2><span id='topic+is.enum_type'></span>

<h3>Description</h3>

<p>Test whether <code><a href="#topic+Enum">Enum</a></code> is also of class <code>type</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.enum_type(x, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.enum_type_+3A_x">x</code></td>
<td>
<p>object to be tested</p>
</td></tr>
<tr><td><code id="is.enum_type_+3A_type">type</code></td>
<td>
<p>character string denoting type to check.</p>
</td></tr>
<tr><td><code id="is.enum_type_+3A_...">...</code></td>
<td>
<p>objects passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> has enumerated type <code>type</code>, <code>FALSE</code> otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HelloEnum &lt;- Enum(
  "HelloEnum",
  Hello,
  World
)

# TRUE
is.enum_type(HelloEnum$Hello, "HelloEnum")

# FALSE
is.enum_type(HelloEnum$Hello, "Hello")
</code></pre>

<hr>
<h2 id='is.err'>Check if Result is an Err</h2><span id='topic+is.err'></span>

<h3>Description</h3>

<p>Test whether Result Enum is Ok or an Err.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.err(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.err_+3A_x">x</code></td>
<td>
<p>object to be tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is enumerated type of variant <code>Err</code>, <code>FALSE</code> otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sqrt_big &lt;- function(x) {
  if (x &gt; 1000){ return(Ok(sqrt(x))) }
  Err("Not large enough!")
}
x &lt;- sqrt_big(250)
is.err(x)  # TRUE

</code></pre>

<hr>
<h2 id='is.none'>Check if Option is None</h2><span id='topic+is.none'></span>

<h3>Description</h3>

<p>Test whether Option Enum is Some or None.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.none(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.none_+3A_x">x</code></td>
<td>
<p>object to be tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is enumerated type of variant <code>None</code>, <code>FALSE</code> otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
get_n &lt;- function(x, n) {
  if (n &gt; length(x)) return(None)
  Some(x[n])
}
obj &lt;- get_n(x, 6)
is.none(obj)  # TRUE
</code></pre>

<hr>
<h2 id='is.ok'>Check if Result is Ok</h2><span id='topic+is.ok'></span>

<h3>Description</h3>

<p>Test whether Result Enum is Ok or an Err.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.ok(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.ok_+3A_x">x</code></td>
<td>
<p>object to be tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is enumerated type of variant <code>Ok</code>, <code>FALSE</code> otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sqrt_big &lt;- function(x) {
  if (x &gt; 1000){ return(Ok(sqrt(x))) }
  Err("Not large enough!")
}
x &lt;- sqrt_big(250)
is.ok(x)  # FALSE

</code></pre>

<hr>
<h2 id='is.some'>Check if Option is Some</h2><span id='topic+is.some'></span>

<h3>Description</h3>

<p>Test whether Option Enum is Some or None.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.some(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.some_+3A_x">x</code></td>
<td>
<p>object to be tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is enumerated type of variant <code>Some</code>, <code>FALSE</code> otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
get_n &lt;- function(x, n) {
  if (n &gt; length(x)) return(None)
  Some(x[n])
}
obj &lt;- get_n(x, 6)
is.some(obj)  # FALSE
</code></pre>

<hr>
<h2 id='is.variant'>Check Enum Variant</h2><span id='topic+is.variant'></span>

<h3>Description</h3>

<p>Test whether <code><a href="#topic+Enum">Enum</a></code> is variant <code>variant</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.variant(x, variant, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.variant_+3A_x">x</code></td>
<td>
<p>object to be tested</p>
</td></tr>
<tr><td><code id="is.variant_+3A_variant">variant</code></td>
<td>
<p>character string denoting variant to check.</p>
</td></tr>
<tr><td><code id="is.variant_+3A_...">...</code></td>
<td>
<p>objects passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is enumerated type of variant <code>variant</code>, <code>FALSE</code> otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HelloEnum &lt;- Enum(
  "HelloEnum",
  Hello,
  World
)

# TRUE
is.variant(HelloEnum$Hello, "Hello")

# FALSE
is.variant(HelloEnum$Hello, "World")
</code></pre>

<hr>
<h2 id='Match'>Match Value Against Multiple Values</h2><span id='topic+Match'></span>

<h3>Description</h3>

<p>Functional programming style matching using <code>-&gt;</code> to separate
conditions from associated return values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Match(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Match_+3A_x">x</code></td>
<td>
<p>object to match</p>
</td></tr>
<tr><td><code id="Match_+3A_...">...</code></td>
<td>
<p>conditions used for matching, separated from the returned
value by <code>-&gt;</code>. Multiple conditions can be associated with the
same return value using <code>|</code>. Each matching statement must be
separated by a comma. See &quot;Details&quot; below. Use <code>.</code> to represent
the default *(else ...)* condition.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike <code><a href="base.html#topic+switch">switch</a></code>, <code>Match</code> accepts a variety of
different condition statements. These can character, numeric,
or logical values, functions, symbols, language objects, enums,
etc. For example, <code>"hello" -&gt; 1</code> tests whether the object is
equal to <code>"hello"</code>. If so, the function returns <code>1</code>,
otherwise the next condition is tested. <code>&lt;-</code> can also be used.
If so, the condition &amp; return expression are reversed: <code>1 &lt;- "hello"</code>
also tests <code>"hello"</code> and returns <code>1</code>.
</p>
<p>Each condition is tested sequentially by calling the appropriate method
of <code><a href="#topic+match_cond">match_cond</a></code>. If the condition is a character value, then
<code>match_cond.character</code> is called, and so on. If a match is
confirmed, the right-hand side is evaluated and returned.
</p>
<p>For atomic vectors - numeric, logical, or character - <code>Match</code> will
check for equality. All resulting values must be <code>TRUE</code> to match.
Lists and environments are checked using <code>identical</code>. If a
function is placed within the condition, then the function will be evaluated
on object <code>x</code>. If the result is logical and <code>TRUE</code>, then it is
considered a match. A non-logical result will be checked again using
<code><a href="#topic+match_cond">match_cond</a></code>. Failed function calls with an error are treated
as a non-match rather than stopping <code>Match</code>. Expressions are evaluated
similar to functions.
</p>
<p>The period <code>.</code> is a special condition in <code>Match</code>. When alone,
it is treated as the &quot;default&quot; condition that always matches. When used
as a call, though, it matches values within object <code>x</code> and/or attaches
the individual items within <code>x</code> for use in the return expression.
For example, <code>x = c(1, 2)</code> will be matched with the condition
<code>.(1, second)</code>. This is because the first values are identical
<code>(1 == 1)</code>. Furthermore, <code>second = 2</code> for use in the return
expression. Preface a symbol with <code>..</code> to evaluate it and check
for equality. <code>...</code> can be used to denote any number of unspecified
objects.
</p>
<p>The period call <code>.()</code> can also be used to test named member of <code>x</code>,
though all objects in <code>.()</code> must be named to do so. For example, the
condition <code>.(a = 5, b=)</code> tests whether <code>x</code> contains <code>"a"</code>
with a value of <code>5</code> and <code>"b"</code> with any value.
</p>
<p>If <code>function(...)</code> is used on the left hand side, then it may
need to be surrounded by parentheses for the parser to properly recognize
it. The <code>%fn%</code> infix function has be provided as syntactic sugar
for developing functions for matching.
</p>
<p>Similar to many functional languages, <code>(first:rest)</code> can be used
as a condition to extract the first element and the rest from any
vector as long as the vector is sufficiently long. Variables used on the
left hand side can be called on the right hand side expression.
</p>
<p>Matching an <code><a href="#topic+Enum">Enum</a></code> causes symbols to represent possible
variants. For example, <code>None -&gt; "none"</code> would try to match the
variant of <code>x</code> with <code>None</code>. If it succeeds, then <code>Match</code>
will return <code>"none"</code>. A function call on the left-hand side for an
Enum is treated as a variant and its inside arguments, which are made
available in the result expression. So, <code>Some(var) -&gt; sqrt(var)</code> would
attempt to match on the variant <code>Some</code>. If it matches, then the
inside is exposed as the variable <code>var</code> for the right-hand side to
use. The number of objects in the variant on the left-hand side must
match the number of objects inside of <code>x</code> or else an error will
populate.
</p>
<p>Regex conditions can be used when matching strings by surrounding the
expression in braces. For example, the condition &quot;[ab]*&quot; is equivalent
to using <code>grepl("\[ab\]*", ...)</code>. The braces must be the first and
last characters to trigger a regex match.
</p>
<p>Call <code><a href="#topic+fallthrough">fallthrough</a></code> within a return expression to stop evaluating
the expression and return to matching. This can be convenient for complex
matching conditions or to execute code for side-effects, such as printing.
</p>


<h3>Value</h3>

<p>an object based on the matched clause. An Error is produced if no
match is found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Matching to functions, characters, regex, and default
Match(
 "abc",
 is.numeric       -&gt; "Not a character!",
 is.character     -&gt; {
   print("Found a character!")
   fallthrough()
 },
 "a" | "b" | "c"  -&gt; "It's a letter!",
 "{bc}"           -&gt; "Contains 'bc'!",
 .                -&gt; "Can be anything!"
)


## Unwrapping a Result enum
val &lt;- Result$Ok("hello world!")

Match(
  val,
  Ok(w)  -&gt; w,
  Err(s) -&gt; s
)

## Using functions
# If 'function' is used on the lhs, surround in '()'
# Alternatively, use %fn% notation
Match(
  1:10,
  (function(i) mean(i) &lt; 5)  -&gt; TRUE,
  i %fn% (mean(i) &gt;= 5) -&gt; FALSE
)

## Extracting parts
x &lt;- list(a = 5, b = 6, c = 7)
Match(
  x,
  .(a=, d=2)  -&gt; "won't match, no 'd'",
  .(a=5, b=)  -&gt; "will match, a == '5'",
  (x:xs)      -&gt; {
    print(x)  # 5
    print(xs) # list(b=6, c=7)
    "will match, since not empty"
  },
  .           -&gt; "this matches anything!"
)

z     &lt;- c(1,2,3,4)
first &lt;- 1
Match(
  z,
  .(0, ...) -&gt; "no match, first is 1 not 0",
  .(1, 2)   -&gt; "no match, z has 4 elements",
  .(x, 2, ...) -&gt; paste("match, x = ", x),
  .(..first, ...) -&gt; "match, since 'first' == 1"
)


</code></pre>

<hr>
<h2 id='match_cond'>Check and Evaluate Match Condition</h2><span id='topic+match_cond'></span>

<h3>Description</h3>

<p>Called by <code><a href="#topic+Match">Match</a></code> the check whether a condition matches. Used to create custom methods for matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_cond(cond, x, do, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_cond_+3A_cond">cond</code></td>
<td>
<p>match condition</p>
</td></tr>
<tr><td><code id="match_cond_+3A_x">x</code></td>
<td>
<p>object being matched</p>
</td></tr>
<tr><td><code id="match_cond_+3A_do">do</code></td>
<td>
<p>return expression associated with the condition. If <code>cond</code> is matched with <code>x</code>, then <code>do</code>
should be evaluated and returned in a list with <code>TRUE</code>: <code>list(TRUE, eval(do))</code>.</p>
</td></tr>
<tr><td><code id="match_cond_+3A_...">...</code></td>
<td>
<p>arguments passed to evaluation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <code><a href="#topic+Match">Match</a></code> details for explanations about provided methods.
</p>


<h3>Value</h3>

<p><code>FALSE</code> if no match, or a list containing <code>TRUE</code> and the evaluated expression
</p>

<hr>
<h2 id='Matchply'>Match Each Object in List or Vector</h2><span id='topic+Matchply'></span>

<h3>Description</h3>

<p>Applies <code><a href="#topic+Match">Match</a></code> to each individual object within the input rather than matching the entire object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Matchply(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Matchply_+3A_x">x</code></td>
<td>
<p>a vector (including list) or expression object</p>
</td></tr>
<tr><td><code id="Matchply_+3A_...">...</code></td>
<td>
<p>conditions and expressions for matching. See <code><a href="#topic+Match">Match</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+Match">Match</a></code> for details on condition implementation. Default conditions using the
period <code>.</code> are highly recommended to prevent error.
</p>
<p><code>Matchply</code> is a wrapper to <code>lapply</code> and <code>sapply</code>, depending on the input object,
with <code>...</code> converted to a match statement for easy use.
</p>


<h3>Value</h3>

<p>vector depending on input <code>x</code>. By default, <code>sapply</code> is
used with <code>simplify = TRUE</code>. This could return a vector, matrix, list,
etc. When <code>simplify = FALSE</code> or a list is provided, the result will be
a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new_list &lt;- list(
  hello = "World!",
  nice  = 2,
  meet  = "u"
)

Matchply(
  new_list,
  is.numeric  -&gt; "found a number!",
  "{rld}"     -&gt; "maybe found 'World'!",
  "u" | "z"   -&gt; "found a letter",
  .  -&gt; "found nothing"
)

</code></pre>

<hr>
<h2 id='None'>None</h2><span id='topic+None'></span>

<h3>Description</h3>

<p>An Enum variant of <code>Option</code> used to denote that a function returned
no value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>None
</code></pre>


<h3>Format</h3>

<p>an empty list of classes <code>"Option"</code> and <code>"Enum"</code>
</p>

<hr>
<h2 id='Ok'>Create an 'Ok' Result</h2><span id='topic+Ok'></span>

<h3>Description</h3>

<p>Create an Enum variant of <code>Result</code> used to denote that function did not contain an error.
This allows the creation of safer functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ok(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ok_+3A_x">x</code></td>
<td>
<p>Object to be wrapped in the Enum variant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with a single value <code>x</code> and classes <code>"Result} and \code{"Enum</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grepl_safe &lt;- function(pattern, x)
{
  if (!is.character(pattern)){ return(Err("'pattern' in 'grepl_safe' was not a character value.")) }
  if (!is.character(x)){ return(Err("'x' in 'grepl_safe' was not a character value.")) }
  Ok(grepl(pattern, x))
}

#grepl_safe(123, 1:5)

</code></pre>

<hr>
<h2 id='Option'>Option</h2><span id='topic+Option'></span>

<h3>Description</h3>

<p>An Enum that mimics Rust's &quot;Option&quot; type. This is used to denote whether
a function returned an object or not, rather than returning <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Option
</code></pre>


<h3>Format</h3>

<p>list with 1 Enum generators and 1 Enum variant
</p>

<dl>
<dt>Some(x)</dt><dd><p>Wrap <code>x</code> in the 'Some' variant.</p>
</dd>
<dt>None</dt><dd><p>Variant denoting that nothing was returned.</p>
</dd>
</dl>


<hr>
<h2 id='Result'>Result</h2><span id='topic+Result'></span>

<h3>Description</h3>

<p>An Enum that mimics Rust's &quot;Result&quot; type. This is used to denote whether
a function contained an error without stopping execution and allowing the
error result to be unwrapped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Result
</code></pre>


<h3>Format</h3>

<p>list with 2 Enum generators
</p>

<dl>
<dt>Ok(x)</dt><dd><p>Wrap <code>x</code> in the 'Ok' variant.</p>
</dd>
<dt>Err(e)</dt><dd><p>Wrap <code>x</code> in the 'Err' variant.</p>
</dd>
</dl>


<hr>
<h2 id='Some'>Create an 'Some' Option</h2><span id='topic+Some'></span>

<h3>Description</h3>

<p>Create an Enum variant of <code>Option</code> used to denote that function returned a value.
This allows the creation of safer functions that extract values from other objects, without using
<code>try</code> or <code>tryCatch</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Some(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Some_+3A_x">x</code></td>
<td>
<p>Object to be wrapped in the Enum variant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with a single value <code>x</code> and classes <code>"Option} and \code{"Enum</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>subset_safe &lt;- function(x, index) {
  if (index &gt; length(x)){ return(None) }
  Some(x[index])
}

</code></pre>

<hr>
<h2 id='Try'>Execute Expression as Result</h2><span id='topic+Try'></span>

<h3>Description</h3>

<p>Evaluates given expression returning an <code>Err</code> <a href="#topic+Result">Result</a> if there is an error, otherwise an <code>Ok</code> Result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Try(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Try_+3A_expr">expr</code></td>
<td>
<p>expression to evaluate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result Enum of variant <code>Ok</code> or <code>Err</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This returns an Err
Try(sqrt + 1)

# This returns an Ok
Try(sqrt(5) + 1)
</code></pre>

<hr>
<h2 id='unwrap'>Extract the Value Contained in Enum</h2><span id='topic+unwrap'></span><span id='topic+unwrap_or'></span>

<h3>Description</h3>

<p>Returns the value contained inside of an enum variant. The function strips all relevant attributes from the
object, returning its bare value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unwrap(x, ...)

unwrap_or(x, alt, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unwrap_+3A_x">x</code></td>
<td>
<p>Enumerated value to unwrap</p>
</td></tr>
<tr><td><code id="unwrap_+3A_...">...</code></td>
<td>
<p>objects to be passed to methods.</p>
</td></tr>
<tr><td><code id="unwrap_+3A_alt">alt</code></td>
<td>
<p>Alternative value to be returned in case of failure</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>unwrap</code> is used to extract the inside objects of an <a href="#topic+Enum">Enum</a>. Unless the Enum was assigned a specific
value, the returned value will be a list with names equal to those in the Enum declaration.
</p>
<p><code><a href="#topic+Result">Result</a></code> and <code><a href="#topic+Option">Option</a></code> have associated <code>unwrap</code> methods that automatically
call an error and stop execution if the variant is either <code>Err(e)</code> or <code>None</code>, respectively.
<code>unwrap_or</code> allows the user to specify an alternative value in case of failure on the part of
<code>Result</code> or <code>Option</code>.
</p>


<h3>Value</h3>

<p>an object of any class.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>unwrap_or</code>: Extract the inside of Enum. If variant is 'Err' or 'None', the alternative is returned.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>Color &lt;- Enum(
  "Color",
  Black = c(0,0,0),
  Red   = c(255,0,0),
  Green = c(0, 255, 0),
  Blue  = c(0, 0, 255),
  White = c(255, 255, 255)
)

red_rgb &lt;- unwrap(Color$Red)
blue    &lt;- rev(red_rgb)
blue

new_err &lt;- Err("hello world!")
unwrap_or(new_err, "this is not an error")

</code></pre>

<hr>
<h2 id='variant'>Enum Variant</h2><span id='topic+variant'></span>

<h3>Description</h3>

<p>Return the variant name of an enumerated type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variant(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variant_+3A_x">x</code></td>
<td>
<p>Enum object</p>
</td></tr>
<tr><td><code id="variant_+3A_...">...</code></td>
<td>
<p>objects passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character with the name of the variant or <code>NULL</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Result$Ok("hello world!")
variant(x)  # "Ok"
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
