<!DOCTYPE html><html><head><title>Help for package rapport</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rapport}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rapport-package'><p><em>rapport</em>: an R engine for reproducible template generation</p></a></li>
<li><a href='#as.character.rapport.inputs'><p>Convert Inputs to Character</p></a></li>
<li><a href='#as.character.rapport.meta'><p>Convert Metadata to Character</p></a></li>
<li><a href='#as.yaml.bool'><p>Convert YAML booleans to R ones</p></a></li>
<li><a href='#check.input.value'><p>Check input value</p></a></li>
<li><a href='#check.input.value.class'><p>Check Input Value Class</p></a></li>
<li><a href='#check.report.chunks'><p>Check Report Chunks</p></a></li>
<li><a href='#check.tpl'><p>Check template validity</p></a></li>
<li><a href='#extract.meta'><p>Extract Template Metadata</p></a></li>
<li><a href='#get.tags'><p>Tag Values</p></a></li>
<li><a href='#guess.input'><p>Guess Input</p></a></li>
<li><a href='#guess.input.description'><p>Input Description</p></a></li>
<li><a href='#guess.input.label'><p>Input Label</p></a></li>
<li><a href='#guess.input.name'><p>Input Name Validation</p></a></li>
<li><a href='#guess.l'><p>Guess length-like fields</p></a></li>
<li><a href='#guess.old.input.length'><p>Deprecated input limits</p></a></li>
<li><a href='#guess.old.input.type'><p>Check Type</p></a></li>
<li><a href='#inputs-deprecated'><p>Deprecated Input Definition</p></a></li>
<li><a href='#is.rapport'><p>Rapport Object</p></a></li>
<li><a href='#ius2008'><p>Internet Usage Survey</p></a></li>
<li><a href='#print.rapport'><p>Prints rapport</p></a></li>
<li><a href='#print.rapport.info'><p>Print Template Header</p></a></li>
<li><a href='#print.rapport.inputs'><p>Print Template Inputs</p></a></li>
<li><a href='#print.rapport.meta'><p>Print Template Metadata</p></a></li>
<li><a href='#rapport'><p>Evaluate Template</p></a></li>
<li><a href='#rapport-helpers'><p><em>rapport helpers</em></p></a></li>
<li><a href='#rapport.body'><p>Template Body</p></a></li>
<li><a href='#rapport.check.template'><p>Check Rapport Template</p></a></li>
<li><a href='#rapport.docx'><p>Rapport to DOCX</p></a></li>
<li><a href='#rapport.example'><p>Template Examples</p></a></li>
<li><a href='#rapport.export'><p>Export rapport object</p></a></li>
<li><a href='#rapport.header'><p>Template Header</p></a></li>
<li><a href='#rapport.html'><p>Rapport to HTML</p></a></li>
<li><a href='#rapport.info'><p>Template Info</p></a></li>
<li><a href='#rapport.inputs'><p>Template Inputs</p></a></li>
<li><a href='#rapport.ls'><p>Package Templates</p></a></li>
<li><a href='#rapport.meta'><p>Header Metadata</p></a></li>
<li><a href='#rapport.odt'><p>Rapport to ODT</p></a></li>
<li><a href='#rapport.path'><p>Template Paths</p></a></li>
<li><a href='#rapport.path.add'><p>Add Template Path</p></a></li>
<li><a href='#rapport.path.remove'><p>Remove Template Path</p></a></li>
<li><a href='#rapport.path.reset'><p>Reset Template Paths</p></a></li>
<li><a href='#rapport.pdf'><p>Rapport to PDF</p></a></li>
<li><a href='#rapport.read'><p>Read Template</p></a></li>
<li><a href='#rapport.renew'><p>Renew deprecated template</p></a></li>
<li><a href='#rapport.rerun'><p>Reproduce Template</p></a></li>
<li><a href='#rapport.tangle'><p>Extract template chunk contents</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Maintainer:</td>
<td>Gergely Daróczi &lt;daroczig@rapporter.net&gt;</td>
</tr>
<tr>
<td>Title:</td>
<td>A Report Templating System</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>Facilitating the creation of reproducible statistical
    report templates. Once created, rapport templates can be exported to
    various external formats (HTML, LaTeX, PDF, ODT etc.) with pandoc as the
    converter backend.</td>
</tr>
<tr>
<td>Author:</td>
<td>Aleksandar Blagotić &lt;alex@rapporter.net&gt; and Gergely Daróczi
    &lt;daroczig@rapporter.net&gt;</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-04-11</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rapporter.github.io/rapport/">https://rapporter.github.io/rapport/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rapporter/rapport/issues">https://github.com/rapporter/rapport/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, utils, yaml, stringr, rapportools, pander</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>pandoc (https://johnmacfarlane.net/pandoc) for
exporting markdown files to other formats.</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-04-11 21:20:25 UTC; daroczig</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-04-11 21:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rapport-package'><em>rapport</em>: an R engine for reproducible template generation</h2><span id='topic+rapport-package'></span>

<h3>Description</h3>

<p><em>rapport</em> is an R package that facilitates creation of reproducible statistical report templates. Once created, <em>rapport</em> templates can be exported to various external formats: <em>HTML</em>, <em>LaTeX</em>, <em>PDF</em>, <em>ODT</em>, etc.
</p>


<h3>Details</h3>

<p>For detailed introductions please check out our homepage: <a href="https://rapporter.github.io/rapport/">https://rapporter.github.io/rapport/</a>.
</p>
<p>You may use the package-bundled templates with a minimal R knowledge - a quick tutorial is shown in the package demo: <code>demo(rapport, ask = FALSE)</code>.
</p>
<p>Apart from R, all you need to know to start writing your own templates is <em>Pandoc</em>'s markup syntax, and several <em>rapport</em>-specific conventions that allow the reproducible of the template. <em>rapport</em> uses <em>brew</em>-like tags to support dynamic inline and/or block evaluation of R code. Unlike many other report-writing conventions in R (<em>Sweave</em>, <em>brew</em>, <em>knitr</em>), <em>rapport</em> converts generated output to a convenient form via <em>pander</em> package and <code>pandoc</code> as the document converting backend. <em>rapport</em> also comes with support for plots: images are automatically saved to temporary file, and image path is returned or redrawn on demand.
</p>
<p>The output of <code>rapport</code> command depends on various package-specific options. Please skim through the summary of following options:
</p>

<ul>
<li> <p><code>rapport.user</code>: a (user)name to show in exported report (defaults to <code>"Anonymous"</code>)
</p>
</li>
<li> <p><code>rapport.file.name</code>: a general filename of generated images and exported documents without extension. Some helper pseudo-code would be replaced with handy strings while running <code><a href="#topic+rapport">rapport</a></code> and <code><a href="#topic+rapport.export">rapport.export</a></code>:
</p>

<ul>
<li> <p><code>%t</code>: unique random character strings based on <code><a href="base.html#topic+tempfile">tempfile</a></code>,
</p>
</li>
<li> <p><code>%T</code>: template name in action,
</p>
</li>
<li> <p><code>%n</code>: an auto-increment integer based on similar (plot) file names (see: <code>?evalsOptions</code>),
</p>
</li>
<li> <p><code>%N</code>: an auto-increment integer based on similar exported document's file name
</p>
</li></ul>

</li>
<li> <p><code>rapport.file.path</code>: a directory where generated images and exported documents would take place.
</p>
</li>
<li><p> By default <code><a href="#topic+rapport">rapport</a></code> function saves plots to image files (see the settings in <code>evalsOptions()</code>) and <code>print</code> method just shows the path(s) of the generated image(s). If you would like to see the plot(s) when calling <code><a href="#topic+rapport">rapport</a></code> function from an interactive R console, please set <code>evalsOptions('graph.recordplot')</code> and the global <code>rapport.graph.replay</code> option to <code>TRUE</code> beforehand. In that case all generated plots will be displayed after printing the <code>rapport</code> object. These options are set to <code>FALSE</code> by default although we find these settings really handy, as you can resize the images on the fly and export resized images to HTML/ODT/DOCX/PDF etc. If you would even like to save the actual environment of each generated plot (variables, data sets etc.) as an <code>RData</code> file, please set <code>evalsOptions('graph.env')</code> to <code>TRUE</code>.
</p>
</li>
<li> <p><code><a href="#topic+rapport">rapport</a></code> also has some options to set formatting style of numbers, characters and dates specified in <code>panderOptions()</code>
</p>
</li>
<li><p> the exported graphs can be customised via further <code>panderOptions</code>
</p>
</li></ul>



<h3>See Also</h3>

<p><code>pander</code> package: <a href="https://rapporter.github.io/pander/">https://rapporter.github.io/pander/</a>
</p>

<hr>
<h2 id='as.character.rapport.inputs'>Convert Inputs to Character</h2><span id='topic+as.character.rapport.inputs'></span>

<h3>Description</h3>

<p>Converts template inputs to character vector with YAML strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rapport.inputs'
as.character(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.character.rapport.inputs_+3A_x">x</code></td>
<td>
<p>template inputs object</p>
</td></tr>
<tr><td><code id="as.character.rapport.inputs_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='as.character.rapport.meta'>Convert Metadata to Character</h2><span id='topic+as.character.rapport.meta'></span>

<h3>Description</h3>

<p>Converts template metadata to character vector with YAML strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rapport.meta'
as.character(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.character.rapport.meta_+3A_x">x</code></td>
<td>
<p>template metadata object</p>
</td></tr>
<tr><td><code id="as.character.rapport.meta_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='as.yaml.bool'>Convert YAML booleans to R ones</h2><span id='topic+as.yaml.bool'></span>

<h3>Description</h3>

<p>We need this because of the silly R/YAML bug. Chillax, it's for internal use only, and since we're about to call it on bunch of places, we needed a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.yaml.bool(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.yaml.bool_+3A_x">x</code></td>
<td>
<p>a character vector with YAML booleans</p>
</td></tr>
</table>

<hr>
<h2 id='check.input.value'>Check input value</h2><span id='topic+check.input.value'></span>

<h3>Description</h3>

<p>A bit misleading title/function name - it validates input values, according to rules set in general input attributes (<code>length</code>) or class-specific ones (<code>nchar</code>, <code>nlevels</code> or <code>limit</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.input.value(
  input,
  value = NULL,
  attribute.name = c("length", "nchar", "nlevels", "limit")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.input.value_+3A_input">input</code></td>
<td>
<p>input item</p>
</td></tr>
<tr><td><code id="check.input.value_+3A_value">value</code></td>
<td>
<p>input value, either template-defined, or set by the user</p>
</td></tr>
<tr><td><code id="check.input.value_+3A_attribute.name">attribute.name</code></td>
<td>
<p>input attributes containing validation rules (defaults to <code>length</code>)</p>
</td></tr>
</table>

<hr>
<h2 id='check.input.value.class'>Check Input Value Class</h2><span id='topic+check.input.value.class'></span>

<h3>Description</h3>

<p>Checks the class of an input value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.input.value.class(
  value,
  class = c("character", "complex", "factor", "integer", "logical", "numeric", "raw"),
  input.name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.input.value.class_+3A_value">value</code></td>
<td>
<p>input value</p>
</td></tr>
<tr><td><code id="check.input.value.class_+3A_class">class</code></td>
<td>
<p>input class (defaults to <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="check.input.value.class_+3A_input.name">input.name</code></td>
<td>
<p>input name (used in messages)</p>
</td></tr>
</table>

<hr>
<h2 id='check.report.chunks'>Check Report Chunks</h2><span id='topic+check.report.chunks'></span>

<h3>Description</h3>

<p>Checks for warnings and errors in report chunks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.report.chunks(rp, what = c("errors", "warnings", "messages"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.report.chunks_+3A_rp">rp</code></td>
<td>
<p><code>rapport</code> object</p>
</td></tr>
<tr><td><code id="check.report.chunks_+3A_what">what</code></td>
<td>
<p>what fields to check. defaults to all</p>
</td></tr>
</table>

<hr>
<h2 id='check.tpl'>Check template validity</h2><span id='topic+check.tpl'></span>

<h3>Description</h3>

<p>Throw error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.tpl(
  txt,
  open.tag = get.tags("header.open"),
  close.tag = get.tags("header.close"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.tpl_+3A_txt">txt</code></td>
<td>
<p>character vector with template contents</p>
</td></tr>
<tr><td><code id="check.tpl_+3A_open.tag">open.tag</code></td>
<td>
<p>opening tag regexp</p>
</td></tr>
<tr><td><code id="check.tpl_+3A_close.tag">close.tag</code></td>
<td>
<p>closing tag regexp</p>
</td></tr>
<tr><td><code id="check.tpl_+3A_...">...</code></td>
<td>
<p>additional params for tag matching (see <code><a href="base.html#topic+grep">grep</a></code>)</p>
</td></tr>
</table>

<hr>
<h2 id='extract.meta'>Extract Template Metadata</h2><span id='topic+extract.meta'></span>

<h3>Description</h3>

<p>Check if template metadata field matches provided format, and return matched value in a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.meta(
  x,
  title,
  regex,
  short = NULL,
  trim.white = TRUE,
  mandatory = TRUE,
  default.value = NULL,
  field.length = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.meta_+3A_x">x</code></td>
<td>
<p>a string containing template metadata</p>
</td></tr>
<tr><td><code id="extract.meta_+3A_title">title</code></td>
<td>
<p>a string containing metadata field title (can be regex-powered)</p>
</td></tr>
<tr><td><code id="extract.meta_+3A_regex">regex</code></td>
<td>
<p>a string with regular expression to match field value</p>
</td></tr>
<tr><td><code id="extract.meta_+3A_short">short</code></td>
<td>
<p>a string with a short name for given metadata field</p>
</td></tr>
<tr><td><code id="extract.meta_+3A_trim.white">trim.white</code></td>
<td>
<p>a logical value indicating whether trailing and leading spaces of the given string should be removed before extraction</p>
</td></tr>
<tr><td><code id="extract.meta_+3A_mandatory">mandatory</code></td>
<td>
<p>a logical value indicating required field</p>
</td></tr>
<tr><td><code id="extract.meta_+3A_default.value">default.value</code></td>
<td>
<p>fallback to this value if non-mandatory field is not found/malformed</p>
</td></tr>
<tr><td><code id="extract.meta_+3A_field.length">field.length</code></td>
<td>
<p>maximum number of field characters (defaults to 1000)</p>
</td></tr>
<tr><td><code id="extract.meta_+3A_...">...</code></td>
<td>
<p>additional parameters for <code>grepl</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with matched content, or <code>NULL</code> if the field is not required
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    rapport:::extract.meta("Name: John Smith", "Name", "[[:alpha:]]+( [[:alpha:]]+)?")
    ## $name
    ## [1] "John Smith"

    rapport:::extract.meta("Name: John", "Name", "[[:alpha:]]+( [[:alpha:]]+)?")
    ## $name
    ## [1] "John"

## End(Not run)
</code></pre>

<hr>
<h2 id='get.tags'>Tag Values</h2><span id='topic+get.tags'></span>

<h3>Description</h3>

<p>Returns report tag vales (usually regexes): either user-defined, or the default ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.tags(
  tag.type = c("all", "header.open", "header.close", "comment.open", "comment.close"),
  preset = c("user", "default")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.tags_+3A_tag.type">tag.type</code></td>
<td>
<p>a character value with tag value name</p>
</td></tr>
<tr><td><code id="get.tags_+3A_preset">preset</code></td>
<td>
<p>a character value specifying which preset to return</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Default parameters are read from <code>options</code>:
</p>

<ul>
<li><p> 'header.open',
</p>
</li>
<li><p> 'header.close',
</p>
</li>
<li><p> 'comment.open',
</p>
</li>
<li><p> 'comment.close'.
</p>
</li></ul>



<h3>Value</h3>

<p>either a list (default) or a character value with tag regexes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get.tags()        # same as 'get.tags("all")'
get.tags("header.open")

## End(Not run)
</code></pre>

<hr>
<h2 id='guess.input'>Guess Input</h2><span id='topic+guess.input'></span>

<h3>Description</h3>

<p>Checks and returns valid input from YAML input definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess.input(input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guess.input_+3A_input">input</code></td>
<td>
<p>a named list containing input definition</p>
</td></tr>
</table>

<hr>
<h2 id='guess.input.description'>Input Description</h2><span id='topic+guess.input.description'></span>

<h3>Description</h3>

<p>Checks and returns input description.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess.input.description(description)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guess.input.description_+3A_description">description</code></td>
<td>
<p>a character string containing input description</p>
</td></tr>
</table>

<hr>
<h2 id='guess.input.label'>Input Label</h2><span id='topic+guess.input.label'></span>

<h3>Description</h3>

<p>Checks and returns input label.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess.input.label(label)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guess.input.label_+3A_label">label</code></td>
<td>
<p>a character string containing input label</p>
</td></tr>
</table>

<hr>
<h2 id='guess.input.name'>Input Name Validation</h2><span id='topic+guess.input.name'></span>

<h3>Description</h3>

<p>From v.<code>0.51</code> one or more characters that are not newline should do the trick. Note that white spaces will be trimmed from both ends in resulting string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess.input.name(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guess.input.name_+3A_name">name</code></td>
<td>
<p>a character value with input name</p>
</td></tr>
</table>

<hr>
<h2 id='guess.l'>Guess length-like fields</h2><span id='topic+guess.l'></span>

<h3>Description</h3>

<p>Since length, nchar, nlevels and limit have (almost) same format,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess.l(
  len,
  type = c("length", "nchar", "nlevels", "limit"),
  input.name = NULL,
  limit.class = c("numeric", "integer")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guess.l_+3A_len">len</code></td>
<td>
<p>length field value, either a number or a named list</p>
</td></tr>
<tr><td><code id="guess.l_+3A_type">type</code></td>
<td>
<p>type of length-like field</p>
</td></tr>
<tr><td><code id="guess.l_+3A_input.name">input.name</code></td>
<td>
<p>input name</p>
</td></tr>
<tr><td><code id="guess.l_+3A_limit.class">limit.class</code></td>
<td>
<p>input class to perform limit-specific checks</p>
</td></tr>
</table>

<hr>
<h2 id='guess.old.input.length'>Deprecated input limits</h2><span id='topic+guess.old.input.length'></span>

<h3>Description</h3>

<p>Guess deprecated input length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess.old.input.length(x, input.type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guess.old.input.length_+3A_x">x</code></td>
<td>
<p>a character string containing input length definition</p>
</td></tr>
<tr><td><code id="guess.old.input.length_+3A_input.type">input.type</code></td>
<td>
<p>a character string containing input type</p>
</td></tr>
</table>

<hr>
<h2 id='guess.old.input.type'>Check Type</h2><span id='topic+guess.old.input.type'></span>

<h3>Description</h3>

<p>Checks type of template input, based on provided sting. If input definition is syntactically correct, a list is returned, containing input type, size limits, and default value (for CSV options and boolean types only).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess.old.input.type(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guess.old.input.type_+3A_x">x</code></td>
<td>
<p>a character string containing input definition</p>
</td></tr>
</table>

<hr>
<h2 id='inputs-deprecated'>Deprecated Input Definition</h2><span id='topic+inputs-deprecated'></span>

<h3>Description</h3>

<p>As of version <code>0.5</code>, <code>rapport</code> relies on YAML syntax to define inputs. The following sections describe deprecated input definition syntax.
</p>


<h3>Details</h3>

<p><strong>Input Specifications</strong>
</p>
<p>Apart from <em>template metadata</em>, header also requires specification for template <em>inputs</em>. In most cases, <em>inputs</em> refer to variable names in provided dataset, but some inputs have special meaning inside <code>rapport</code>, and some of them don't have anything to do with provided dataset whatsoever. Most inputs can contain limit specification, and some inputs can also have a default value. At first we'll explain input specifications on the fly, and in following sections we'll discuss each part in thorough details. Let's start with a single dummy input specification:
</p>
<p><code>*foo.bar | numeric[1,6] | Numeric variable | A set of up to 6 numeric variables</code>
</p>
<p><strong>Required Inputs</strong>
</p>
<p>Asterisk sign (<code>*</code>) in front of an input name indicates a mandatory input. So it is possible to omit input (unless it's required, of course), but you may want to use this feature carefully, as you may end up with ugly output. If an input isn't mandatory,<code>NULL</code>is assigned to provided input name, and the object is stored in transient evaluation environment.
</p>
<p><strong>Input Name</strong>
</p>
<p><em>rapport</em> has its own naming conventions which are compatible, but different from traditional <strong>R</strong> naming conventions. Input name (&quot;foo.bar&quot; in previous example) must start with an alphabet letter, followed either by other alphabet letters or numbers, separated with <code>_</code> or <code>.</code>. For example, valid names are: <code>foo.bar</code>, <code>f00_bar</code>, or <code>Fo0_bar.input</code>. Input name length is limited on 30 characters by default. At any time you can check your desired input name with <code>check.name</code> function. Note that input names are case-sensitive, just like <code>symbol</code>s in <strong>R</strong>.
</p>
<p><strong>Input Type</strong>
</p>
<p><em>Input type</em> is specified in the second input block. It is the most (read: &quot;only&quot;) complex field in an input specification. It consists of <em>type specification</em>, <em>limit specification</em> and sometimes a <em>default value specification</em>. Most input types are compatible with eponymous <strong>R</strong> modes: <em>character</em>, <em>complex</em>, <em>logical</em>, <em>numeric</em>, or <strong>R</strong> classes like <em>factor</em>. Some are used as &quot;wildcards&quot;, like <em>variable</em>, and some do not refer to dataset variables at all: <em>boolean</em>, <em>number</em>, <em>string</em> and <em>option</em>. Here we'll discuss each input type thoroughly. We will use term <em>variable</em> to denote a vector taken from a dataset (for more details see documentation for <code>is.variable</code>). All inputs can be divided into two groups, depending on whether they require a dataset or not:
</p>

<ul>
<li> <p><strong>dataset inputs</strong>: </p>

<ul>
<li> <p><em>character</em> - matches a character variable
</p>
</li>
<li> <p><em>complex</em> - matches a character variable
</p>
</li>
<li> <p><em>numeric</em> - matches a numeric variable
</p>
</li>
<li> <p><em>factor</em> - matches a factor variable (i.e. R object of <code>factor</code> class)
</p>
</li>
<li> <p><em>variable</em> - matches any variable of previously defined types
</p>
</li></ul>

</li>
<li> <p><strong>standalone inputs</strong>: </p>

<ul>
<li> <p><em>string</em> - accepts an atomic character vector
</p>
</li>
<li> <p><em>number</em> - accepts an atomic numeric vector
</p>
</li>
<li> <p><em>boolean</em> - accepts a logical value
</p>
</li>
<li> <p><em>option</em> - accepts a comma-separated list of values, that are to be matched with <code><a href="base.html#topic+match.arg">match.arg</a></code>. The first value in a list is the default one.
</p>
</li></ul>

</li></ul>

<p>Now we'll make a little digression and talk about <strong>input limits</strong>. You may have noticed some additional stuff in type specification, e.g. <code>numeric[1,6]</code>. All dataset inputs, as well as *string* and *numeric standalone inputs* can contain <em>limit specifications</em>. If you want to bundle several variables from dataset or provide a vector with several string/numeric values, you can apply some rules within square brackets in <code>[a,b]</code> format, where <code>[a,b]</code> stands for &quot;from <code>a</code> to <code>b</code> inputs&quot;, e.g. <code>[1,6]</code> means &quot;from 1 to 6 inputs&quot;. Limit specifications can be left out, but even in that case implicit limit rules are applied - for variables, as well as boolean and option inputs it's <code>[1,1]</code>, for strings <code>[1,256]</code> and for number inputs <code>[-Inf,Inf]</code>.
</p>
<p><strong>Dataset inputs</strong> will match one or more variables from a dataset, and check its mode and/or class. <code>variable</code> type is a bit different, since it matches any kind of variable (not to confuse with <code>Any</code> type), but it still refers to variable(s) from a provided dataset. Dataset inputs cannot have default value, but can be optional (just leave out <code>*</code> sign in front of input name). Note that if you provide more than one variable name in <code>rapport</code> function call, that input will be stored as a <code>data.frame</code>, otherwise, it will be stored as a <em>variable</em> (atomic vector).
</p>
<p><strong>Standalone inputs</strong> are a bit different since they do not refer to any variables from a dataset. However, they are more complex than *dataset inputs*, especially because they can contain default values.
</p>

<ul>
<li> <p><strong>number</strong> and <strong>string</strong> inputs are defined with <code>number</code> and <code>string</code> respectively. They can also contain limit specifications, but the limits are treated in a slightly different manner. <code>number[-2.58,3]</code> will match any number within an interval from -2.58 to 3. If the limit specification is ommited, an implicit ones are assigned (<code>[-Inf,Inf]</code>. Limit specifications for string inputs define the range of characters that provided string can have, e.g. <code>string[1,6]</code> matches the string with at least 1 and at most 6 characters. If ommited, limit specifications for strings are implicitly set to <code>[1,256]</code>. <em>number</em> and <em>string</em> inputs can have <em>default value</em>, which can be defined by placing <code>=</code> after type/limit specification followed by default value. For instance, <code>number[1,6]=3.14</code> sets value <code>3.14</code> as default. Note that for number inputs an additional check will be applied to ensure that provided default number belongs to an interval defined in the limit specification (<code>[1,6]=7</code> will throw an error). For string inputs, the default value <code>string=foo</code> sets &quot;foo&quot; as default string value (note that you don't have to specify quotes unless they are the part of the default string). Default value will be checked to ensure that its length falls within the interval provided in the limit specification.
</p>
</li>
<li> <p><strong>boolean</strong> inputs can contain either <code>TRUE</code> or <code>FALSE</code> values. The specified value is the default one. They cannot contain limit specification, but implicitly the limits are set to <code>[1,1]</code>.
</p>
</li>
<li> <p><strong>option</strong> inputs are nothing more than a comma-separated list of strings. Even if you specify numbers in a list, they will be coerced to strings once the list is parsed. Values in <em>option</em> list will be placed in a character vector, and matched with <code>match.arg</code> function. That means that you could only choose one value from a list. Partial matches are allowed, and the first value in <em>option</em> list is the default one. Just like in <code>boolean</code> inputs, limits are implicitly set to <code>[1,1]</code>.
</p>
</li></ul>

<p><strong>Input Label and Description</strong>
</p>
<p>Third block in input definition is an input label. While <em>variable</em> can have its own label (see <code>label</code>), you may want to use the one defined in input specifications. At last, fourth block contains input description, which should be a lengthy description of current input. Note that all the fields in input specification are mandatory. You can cheat, though, by providing a non-space character (e.g. a dot) as an input label and/or description, but please don't do that unless you're testing the template. Labels and descriptions are meant to be informative.
</p>

<hr>
<h2 id='is.rapport'>Rapport Object</h2><span id='topic+is.rapport'></span>

<h3>Description</h3>

<p>Checks if provided R object is of <code>rapport</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.rapport(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.rapport_+3A_x">x</code></td>
<td>
<p>any R object to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical value indicating whether provided object is a <code>rapport</code> object
</p>

<hr>
<h2 id='ius2008'>Internet Usage Survey</h2><span id='topic+ius2008'></span>

<h3>Description</h3>

<p>This dataset contains data gathered in a survey of Internet usage in Serbian population in the period from April to May 2008. During 90-day period, there were gathered 709 valid responses via on-line distributed questionnaire.
</p>


<h3>Details</h3>

<p>However, this dataset does not contain the original data, as some random noise is added afterwards, in order to demonstrate functionality of <em>rapport</em> helpers.
</p>
<p>Dataset variables can be divided into 3 sets: <em>demographic data</em>, <em>Internet usage aspects</em> and <em>application usage/content preference</em>.
</p>
<p><strong>Demographic variables</strong>
</p>

<ul>
<li> <p><em>gender</em> - respondent's gender (factor with 2 levels: &quot;male&quot; and &quot;female&quot;)
</p>
</li>
<li> <p><em>age</em> - respondent's age
</p>
</li>
<li> <p><em>dwell</em> - dwelling (factor with 3 levels: &quot;village&quot;, &quot;small town&quot; and &quot;city&quot;)
</p>
</li>
<li> <p><em>student</em> - is respondent a student? (factor with 2 levels: &quot;no&quot; and &quot;yes&quot;)
</p>
</li>
<li> <p><em>partner</em> - partnership status (factor with 3 levels: &quot;single&quot;, &quot;in a relationship&quot; and &quot;married&quot;)
</p>
</li></ul>

<p><strong>Internet usage aspects</strong>
</p>
<p>Following variables depict various aspects of Internet usage:
</p>

<ul>
<li> <p><em>edu</em> - time spent on-line in educational purposes (expressed in hours)
</p>
</li>
<li> <p><em>leisure</em> - time spent on-line in leisure time (expressed in hours)
</p>
</li>
<li> <p><em>net.required</em> - is Internet access required for your profession? (factor with 5 levels: &quot;never&quot;, &quot;rarely&quot;, &quot;sometimes&quot;, &quot;often&quot; and &quot;always&quot;)
</p>
</li>
<li> <p><em>net.pay</em> - who pays for Internet access? (factor with 5 levels: &quot;parents&quot;, &quot;school/faculty&quot;, &quot;employer&quot;, &quot;self-funded&quot; and &quot;other&quot;)
</p>
</li>
<li> <p><em>net.use</em> - how long is respondent using Internet? (ordered factor with 7 levels, ranging from &quot;less than 6 months&quot; to &quot;more than 5 years&quot;)
</p>
</li></ul>

<p><strong>Application usage and on-line content preference</strong>
</p>
<p>These variables include data on the use of Internet applications and content available on the Internet. Practically, they contain responses from a set of 8 questions on a five-point Likert scale.
</p>

<ul>
<li> <p><em>chatim</em> - usage of chat and/or instant messaging applications
</p>
</li>
<li> <p><em>game</em> - usage of on-line games
</p>
</li>
<li> <p><em>surf</em> - frequency of web-surfing
</p>
</li>
<li> <p><em>email</em> - usage of e-mail applications
</p>
</li>
<li> <p><em>download</em> - frequency of file downloading
</p>
</li>
<li> <p><em>forum</em> - attendance at web-forums
</p>
</li>
<li> <p><em>socnet</em> - usage of social networking services
</p>
</li>
<li> <p><em>xxx</em> - traffic to pornographic websites
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Aleksandar Blagotic <a href="mailto:aca.blagotic@gmail.com">aca.blagotic@gmail.com</a>
</p>
<p>Dusan Vuckovic <a href="mailto:sylphs21125@gmail.com">sylphs21125@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rapport("example", ius2008, var = "it.leisure")

## End(Not run)
</code></pre>

<hr>
<h2 id='print.rapport'>Prints rapport</h2><span id='topic+print.rapport'></span>

<h3>Description</h3>

<p>Default print method for <code>rapport</code> class objects that shows evaluated report contents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rapport'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.rapport_+3A_x">x</code></td>
<td>
<p>any &quot;rapport&quot; class object</p>
</td></tr>
<tr><td><code id="print.rapport_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rapport('example', data = mtcars, var='hp')

## End(Not run)
</code></pre>

<hr>
<h2 id='print.rapport.info'>Print Template Header</h2><span id='topic+print.rapport.info'></span>

<h3>Description</h3>

<p>Prints out the contents of template header (both metadata and inputs) in human-readable format, so you can get insight about the template requirements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rapport.info'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.rapport.info_+3A_x">x</code></td>
<td>
<p>object of class <code>rp.header</code>. See <code><a href="#topic+rapport.header">rapport.header</a></code> for details.</p>
</td></tr>
<tr><td><code id="print.rapport.info_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='print.rapport.inputs'>Print Template Inputs</h2><span id='topic+print.rapport.inputs'></span>

<h3>Description</h3>

<p>Prints out the contents of template inputs in human-readable format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rapport.inputs'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.rapport.inputs_+3A_x">x</code></td>
<td>
<p>object of class <code>rapport.inputs</code>. See <code><a href="#topic+rapport.inputs">rapport.inputs</a></code> for details.</p>
</td></tr>
<tr><td><code id="print.rapport.inputs_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='print.rapport.meta'>Print Template Metadata</h2><span id='topic+print.rapport.meta'></span>

<h3>Description</h3>

<p>Prints out the contents of template metadata in human-readable format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rapport.meta'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.rapport.meta_+3A_x">x</code></td>
<td>
<p>object of class <code>rapport.meta</code>. See <code><a href="#topic+rapport.meta">rapport.meta</a></code> for details.</p>
</td></tr>
<tr><td><code id="print.rapport.meta_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='rapport'>Evaluate Template</h2><span id='topic+rapport'></span>

<h3>Description</h3>

<p>This is the central function in the <code>rapport</code> package, and hence eponymous. In following lines we'll use <code>rapport</code> to denote the function, not the package. <code>rapport</code> requires a template file, while dataset (<code>data</code> argument) can be optional, depending on the value of <code>Data required</code> field in template header. Template inputs are matched with <code>...</code> argument, and should be provided in <code>x = value</code> format, where <code>x</code> matches input name and <code>value</code>, wait for it... input value! See <code><a href="#topic+rapport.inputs">rapport.inputs</a></code> for more details on template inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rapport(
  fp,
  data = NULL,
  ...,
  env = .GlobalEnv,
  reproducible = FALSE,
  header.levels.offset = 0,
  graph.output = evalsOptions("graph.output"),
  file.name = getOption("rapport.file.name"),
  file.path = getOption("rapport.file.path"),
  graph.width = evalsOptions("width"),
  graph.height = evalsOptions("height"),
  graph.res = evalsOptions("res"),
  graph.hi.res = evalsOptions("hi.res"),
  graph.replay = evalsOptions("rapport.graph.recordplot")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rapport_+3A_fp">fp</code></td>
<td>
<p>a template file pointer (see <code>rapport:::rapport.read</code> for details)</p>
</td></tr>
<tr><td><code id="rapport_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> to be used in template</p>
</td></tr>
<tr><td><code id="rapport_+3A_...">...</code></td>
<td>
<p>matches template inputs in format 'key = &quot;value&quot;'</p>
</td></tr>
<tr><td><code id="rapport_+3A_env">env</code></td>
<td>
<p>the parent environment to be forked, in which temporary <code>new.env</code> template commands be evaluated</p>
</td></tr>
<tr><td><code id="rapport_+3A_reproducible">reproducible</code></td>
<td>
<p>a logical value indicating if the call and data should be stored in template object, thus making it reproducible (see <code><a href="#topic+rapport.rerun">rapport.rerun</a></code> for details)</p>
</td></tr>
<tr><td><code id="rapport_+3A_header.levels.offset">header.levels.offset</code></td>
<td>
<p>number added to header levels (handy when using nested templates)</p>
</td></tr>
<tr><td><code id="rapport_+3A_graph.output">graph.output</code></td>
<td>
<p>the required file format of saved plots (optional)</p>
</td></tr>
<tr><td><code id="rapport_+3A_file.name">file.name</code></td>
<td>
<p>set the file name of saved plots and exported documents. A simple character string might be provided where <code>%N</code> would be replaced by an auto-increment integer based on similar exported document's file name , <code>%n</code> an auto-increment integer based on similar (plot) file names (see: <code>?evalsOptions</code>), <code>%T</code> by the name of the template in action and <code>%t</code> by some uniqe random characters based on <code><a href="base.html#topic+tempfile">tempfile</a></code>.</p>
</td></tr>
<tr><td><code id="rapport_+3A_file.path">file.path</code></td>
<td>
<p>path of a directory where to store generated images and exported reports</p>
</td></tr>
<tr><td><code id="rapport_+3A_graph.width">graph.width</code></td>
<td>
<p>the required width of saved plots (optional)</p>
</td></tr>
<tr><td><code id="rapport_+3A_graph.height">graph.height</code></td>
<td>
<p>the required height of saved plots (optional)</p>
</td></tr>
<tr><td><code id="rapport_+3A_graph.res">graph.res</code></td>
<td>
<p>the required nominal resolution in ppi of saved plots (optional)</p>
</td></tr>
<tr><td><code id="rapport_+3A_graph.hi.res">graph.hi.res</code></td>
<td>
<p>logical value indicating if high resolution (1280x~1280) images would be also generated</p>
</td></tr>
<tr><td><code id="rapport_+3A_graph.replay">graph.replay</code></td>
<td>
<p>logical value indicating if plots need to be recorded for later replay (eg. while <code>print</code>ing <code>rapport</code> objects in R console)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Default parameters are read from <code>evalsOptions()</code> and the following <code>options</code>:
</p>

<ul>
<li><p> 'rapport.file.name',
</p>
</li>
<li><p> 'rapport.file.path',
</p>
</li></ul>



<h3>Value</h3>

<p>a list with <code>rapport</code> class.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rapport-package">rapport-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rapport('Example', ius2008, v = "leisure")
rapport('Descriptives', ius2008, var = "leisure")

## generating high resolution images also
rapport('Example', ius2008, v = "leisure", graph.hi.res = TRUE)
rapport.html('NormalityTest', ius2008, var = "leisure", graph.hi.res=T)
## generating only high resolution image
rapport('Example', ius2008, v = "leisure", graph.width = 1280, graph.height = 1280)
## nested templates cannot get custom setting, use custom rapport option:
options('graph.hi.res' = TRUE)
rapport('AnalyzeWizard', data=ius2008, variables=c('edu', 'game'))

## End(Not run)
</code></pre>

<hr>
<h2 id='rapport-helpers'><em>rapport helpers</em></h2><span id='topic+rapport-helpers'></span>

<h3>Description</h3>

<p><code>rapport</code> package comes with bunch of helper functions that make your template writing and report creation easier, although most of these helpers were migrated to the <code>rapportools</code> package.
</p>


<h3>Details</h3>

<p><em>Export helpers</em>
</p>

<ul>
<li> <p><code><a href="#topic+rapport.docx">rapport.docx</a></code>
</p>
</li>
<li> <p><code><a href="#topic+rapport.html">rapport.html</a></code>
</p>
</li>
<li> <p><code><a href="#topic+rapport.odt">rapport.odt</a></code>
</p>
</li>
<li> <p><code><a href="#topic+rapport.pdf">rapport.pdf</a></code>
</p>
</li>
<li> <p><code><a href="#topic+rapport.export">rapport.export</a></code>
</p>
</li></ul>

<p>Please load the <code>rapportools</code> package if you would use any of the below functions in the <code>.GlobalEnv</code>, or simply add <code>rapportools</code> to the required packages section in your template file. That latter is a lot cleaner solution.
</p>
<p><em>General purpose helpers</em>
</p>

<ul>
<li> <p><code><a href="rapportools.html#topic+adj.rle">adj.rle</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+alike.integer">alike.integer</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+capitalise">capitalise</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+catn">catn</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+fml">fml</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+is.boolean">is.boolean</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+is.empty">is.empty</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+is.number">is.number</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+is.string">is.string</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+is.tabular">is.tabular</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+is.variable">is.variable</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+messagef">messagef</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+pct">pct</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+stopf">stopf</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+tocamel">tocamel</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+trim.space">trim.space</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+vgsub">vgsub</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+warningf">warningf</a></code>
</p>
</li></ul>

<p><em>Summary statistics</em>
</p>

<ul>
<li> <p><code><a href="rapportools.html#topic+rp.desc">rp.desc</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+rp.freq">rp.freq</a></code>
</p>
</li></ul>

<p><em>Univariate descriptive statistics</em>
</p>

<ul>
<li> <p><code><a href="rapportools.html#topic+rp.iqr">rp.iqr</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+rp.max">rp.max</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+rp.mean">rp.mean</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+rp.median">rp.median</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+rp.min">rp.min</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+rp.missing">rp.missing</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+rp.percent">rp.percent</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+rp.range">rp.range</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+rp.sd">rp.sd</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+rp.se.mean">rp.se.mean</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+rp.sum">rp.sum</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+rp.valid">rp.valid</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+rp.var">rp.var</a></code>
</p>
</li></ul>

<p><em>Miscelaneous stats helpers</em>
</p>

<ul>
<li> <p><code><a href="rapportools.html#topic+htest">htest</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+htest.short">htest.short</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+kurtosis">kurtosis</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+skewness">skewness</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+lambda.test">lambda.test</a></code>
</p>
</li>
<li> <p><code><a href="rapportools.html#topic+rp.outlier">rp.outlier</a></code>
</p>
</li></ul>


<hr>
<h2 id='rapport.body'>Template Body</h2><span id='topic+rapport.body'></span><span id='topic+tpl.body'></span>

<h3>Description</h3>

<p>Returns contents of the template body.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rapport.body(fp, htag = get.tags("header.close"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rapport.body_+3A_fp">fp</code></td>
<td>
<p>a template file pointer (see <code>rapport:::rapport.read</code> for details)</p>
</td></tr>
<tr><td><code id="rapport.body_+3A_htag">htag</code></td>
<td>
<p>a string with closing body tag</p>
</td></tr>
<tr><td><code id="rapport.body_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="base.html#topic+grep">grep</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector with template body contents
</p>

<hr>
<h2 id='rapport.check.template'>Check Rapport Template</h2><span id='topic+rapport.check.template'></span><span id='topic+tpl.check'></span>

<h3>Description</h3>

<p>Checks if the examples of given template can be run without any error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rapport.check.template(fp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rapport.check.template_+3A_fp">fp</code></td>
<td>
<p>a character vector containing template name (&quot;.rapport&quot; extension is optional), file path or a text to be split by line breaks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If everything went fine and you get a list of <code>success</code> equals to <code>TRUE</code> values, otherwise <code>success</code> returns <code>FALSE</code> with additional <code>message</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rapport.check.template('Example')

## End(Not run)
</code></pre>

<hr>
<h2 id='rapport.docx'>Rapport to DOCX</h2><span id='topic+rapport.docx'></span>

<h3>Description</h3>

<p>This is a simple wrapper around <code><a href="#topic+rapport">rapport</a></code> and <code><a href="#topic+rapport.export">rapport.export</a></code>. Basically it works like <code><a href="#topic+rapport">rapport</a></code> but the returned class is exported at one go.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rapport.docx(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rapport.docx_+3A_...">...</code></td>
<td>
<p>parameters passed directly to <code><a href="#topic+rapport">rapport</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+rapport.export">rapport.export</a></code> <code><a href="#topic+rapport.html">rapport.html</a></code> <code><a href="#topic+rapport.pdf">rapport.pdf</a></code> <code><a href="#topic+rapport.odt">rapport.odt</a></code>
</p>

<hr>
<h2 id='rapport.example'>Template Examples</h2><span id='topic+rapport.example'></span><span id='topic+tpl.example'></span>

<h3>Description</h3>

<p>Displays template examples defined in <code>Example</code> section. Handy to check out what template does and how does it look like once it's rendered. If multiple examples are available, and <code>index</code> argument is <code>NULL</code>, you will be prompted for input. If only one example is available in the header, user is not prompted for input action, and given template is evaluated automatically. At any time you can provide an integer vector with example indices to <code>index</code> argument, and specified examples will be evaluated without prompting, thus returning a list of <code>rapport</code> objects. Example output can be easily exported to various formats (HTML, ODT, etc.) - check out documentation for <code>rapport.export</code> for more info.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rapport.example(fp, index = NULL, env = .GlobalEnv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rapport.example_+3A_fp">fp</code></td>
<td>
<p>a template file pointer (see <code>rapport:::rapport.read</code> for details)</p>
</td></tr>
<tr><td><code id="rapport.example_+3A_index">index</code></td>
<td>
<p>a numeric vector indicating the example index - meaningful only for templates with multiple examples. Accepts vector of integers to match IDs of template example. Using 'all' (character string) as index will return all examples.</p>
</td></tr>
<tr><td><code id="rapport.example_+3A_env">env</code></td>
<td>
<p>an environment where example will be evaluated (defaults to <code>.GlobalEnv</code>)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rapport.example('Example')
rapport.example('Example', 1:2)
rapport.example('Example', 'all')
rapport.example('Crosstable')
rapport.export(rapport.example('Crosstable'))

## End(Not run)
</code></pre>

<hr>
<h2 id='rapport.export'>Export rapport object</h2><span id='topic+rapport.export'></span><span id='topic+tpl.export'></span>

<h3>Description</h3>

<p>This function exports rapport class objects to various formats based on the <code>pander</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rapport.export(
  rp = NULL,
  file,
  append = FALSE,
  create = TRUE,
  open = TRUE,
  date = pander_return(Sys.time()),
  description = TRUE,
  format = "html",
  options = "",
  logo = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rapport.export_+3A_rp">rp</code></td>
<td>
<p>a rapport class object or list of rapport class objects</p>
</td></tr>
<tr><td><code id="rapport.export_+3A_file">file</code></td>
<td>
<p>filename of the generated document. Inherited from rapport class if not set. If <code>file</code> is set with path (not equal to <code>getwd()</code>), please set an absolute path for images (see: <code>evalsOptions()</code>).</p>
</td></tr>
<tr><td><code id="rapport.export_+3A_append">append</code></td>
<td>
<p>FALSE (new report created) or an R object (class of &quot;Report&quot;) to which the new report will be added</p>
</td></tr>
<tr><td><code id="rapport.export_+3A_create">create</code></td>
<td>
<p>should export really happen? It might be handy if you want to append several reports.</p>
</td></tr>
<tr><td><code id="rapport.export_+3A_open">open</code></td>
<td>
<p>open the exported document? Default set to TRUE.</p>
</td></tr>
<tr><td><code id="rapport.export_+3A_date">date</code></td>
<td>
<p>character string as the date field of the report. If not set, current time will be set.</p>
</td></tr>
<tr><td><code id="rapport.export_+3A_description">description</code></td>
<td>
<p>add <code>Description</code> of the rapport class (template)? Default set to TRUE.</p>
</td></tr>
<tr><td><code id="rapport.export_+3A_format">format</code></td>
<td>
<p>format of the wanted report. See Pandoc's user manual for details. In short, choose something like: <code>html</code>, <code>pdf</code>, <code>odt</code> or <code>docx</code>.</p>
</td></tr>
<tr><td><code id="rapport.export_+3A_options">options</code></td>
<td>
<p>options passed to <code>Pandoc.convert</code>.</p>
</td></tr>
<tr><td><code id="rapport.export_+3A_logo">logo</code></td>
<td>
<p>add rapport logo</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default this function tries to export the report to HTML with pandoc. Some default styles are applied. If you do not like those default settings, use your own <code>options</code> argument.
</p>
<p>Default parameters are read from global <code>options</code>:
</p>

<ul>
<li><p> 'rapport.user'
</p>
</li></ul>

<p>Please be sure to set <code>'rapport.user'</code> option with <code>options()</code> to get your name in the head of your generated reports!
</p>


<h3>Value</h3>

<p>filepath on <code>create = TRUE</code>, <code>Report</code> class otherwise
</p>


<h3>References</h3>

<p>John MacFarlane (2012): _Pandoc User's Guide_. <a href="https://johnmacfarlane.net/pandoc/README.html">https://johnmacfarlane.net/pandoc/README.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rapport.html">rapport.html</a></code> <code><a href="#topic+rapport.pdf">rapport.pdf</a></code> <code><a href="#topic+rapport.odt">rapport.odt</a></code> <code><a href="#topic+rapport.docx">rapport.docx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## eval some template
x &lt;- rapport('Example', data = mtcars, var="hp")

## try basic parameters
rapport.export(x)
rapport.export(x, file = 'demo')
rapport.export(x, file = 'demo', format = 'odt')

### append reports
# 1) Create a report object with the first report and do not export (optional)
report &lt;- rapport.export(x, create = F)
# 2) Append some other reports without exporting (optional)
report &lt;- rapport.export(x, create = F, append = report)
# 3) Export it!
rapport.export(append=report)
# 4) Export it to other formats too! (optional)
rapport.export(append=report, format='rst')

### exporting multiple reports at once
rapport.export(rapport.example('Example', 'all'))
rapport.export(rapport.example('Example', 'all'), format = 'odt')
rapport.export(list(rapport('univar-descriptive', data = mtcars, var = "hp"),
    rapport('Descriptives', data = mtcars, var = "mpg")))

### Never do this as being dumb:
rapport.export()

### Adding own custom CSS to exported HTML
rapport.export(x, options =
    sprintf('-c %s', system.file('templates/css/default.css', package='rapport')))

## End(Not run)
</code></pre>

<hr>
<h2 id='rapport.header'>Template Header</h2><span id='topic+rapport.header'></span><span id='topic+tpl.header'></span>

<h3>Description</h3>

<p>Returns <code>rapport</code> template header from provided path or a character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rapport.header(
  fp,
  open.tag = get.tags("header.open"),
  close.tag = get.tags("header.close"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rapport.header_+3A_fp">fp</code></td>
<td>
<p>a template file pointer (see <code>rapport:::rapport.read</code> for details)</p>
</td></tr>
<tr><td><code id="rapport.header_+3A_open.tag">open.tag</code></td>
<td>
<p>a string with opening tag (defaults to value of user-defined <code>"header.open"</code> tag)</p>
</td></tr>
<tr><td><code id="rapport.header_+3A_close.tag">close.tag</code></td>
<td>
<p>a string with closing tag (defaults to value of user-defined <code>"header.close"</code> tag)</p>
</td></tr>
<tr><td><code id="rapport.header_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="base.html#topic+grep">grep</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector with template header contents
</p>

<hr>
<h2 id='rapport.html'>Rapport to HTML</h2><span id='topic+rapport.html'></span>

<h3>Description</h3>

<p>This is a simple wrapper around <code><a href="#topic+rapport">rapport</a></code> and <code><a href="#topic+rapport.export">rapport.export</a></code>. Basically it works like <code><a href="#topic+rapport">rapport</a></code> but the returned class is exported at one go.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rapport.html(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rapport.html_+3A_...">...</code></td>
<td>
<p>parameters passed directly to <code><a href="#topic+rapport">rapport</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+rapport.export">rapport.export</a></code> <code><a href="#topic+rapport.pdf">rapport.pdf</a></code> <code><a href="#topic+rapport.odt">rapport.odt</a></code> <code><a href="#topic+rapport.docx">rapport.docx</a></code>
</p>

<hr>
<h2 id='rapport.info'>Template Info</h2><span id='topic+rapport.info'></span><span id='topic+tpl.info'></span>

<h3>Description</h3>

<p>Provides information about template metadata and/or inputs. See <code><a href="#topic+rapport.meta">rapport.meta</a></code> and <code><a href="#topic+rapport.inputs">rapport.inputs</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rapport.info(fp, meta = TRUE, inputs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rapport.info_+3A_fp">fp</code></td>
<td>
<p>a template file pointer (see <code>rapport:::rapport.read</code> for details)</p>
</td></tr>
<tr><td><code id="rapport.info_+3A_meta">meta</code></td>
<td>
<p>return template metadata? (defaults to <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="rapport.info_+3A_inputs">inputs</code></td>
<td>
<p>return template inputs? (defaults to <code>TRUE</code>)</p>
</td></tr>
</table>


<h3>See Also</h3>


<p><code><a href="#topic+rapport.meta">rapport.meta</a></code>
<code><a href="#topic+rapport.inputs">rapport.inputs</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rapport.info('Example')                    # return both metadata and inputs
rapport.info('Crosstable', inputs = FALSE) # return only template metadata
rapport.info('Correlation', meta = FALSE)  # return only template inputs

## End(Not run)
</code></pre>

<hr>
<h2 id='rapport.inputs'>Template Inputs</h2><span id='topic+rapport.inputs'></span><span id='topic+tpl.inputs'></span>

<h3>Description</h3>

<p>Displays summary for template inputs (if any). Note that as of version <code>0.5</code>, <code>rapport</code> template inputs should be defined using YAML syntax. See <code>deprecated-inputs</code> for details on old input syntax. The following sections describe new YAML input definition style.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rapport.inputs(fp, use.header = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rapport.inputs_+3A_fp">fp</code></td>
<td>
<p>a template file pointer (see <code>rapport:::rapport.read</code> for details)</p>
</td></tr>
<tr><td><code id="rapport.inputs_+3A_use.header">use.header</code></td>
<td>
<p>a logical value indicating whether the header section is provided in <code>h</code> argument</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Introduction</strong>
</p>
<p>The full power of <code>rapport</code> comes into play with <em>template inputs</em>. One can match inputs against dataset variables or custom <code>R</code> objects. The inputs provide means of assigning <code>R</code> objects to <code>symbol</code>s in the template evaluation environment. Inputs themselves do not handle only the template names, but also provide an extensive set of rules that each dataset variable/user-provided <code>R</code> object has to satisfy. The new YAML input specification takes advantage of <code>R</code> class system. The input attributes should resemble common <code>R</code> object attributes and methods.
</p>
<p>Inputs can be divided into two categories:
</p>

<ul>
<li> <p><em>dataset inputs</em>, i.e. the inputs that refer to named element of an |codeR object provided in <code>data</code> argument in <code>rapport</code> call. Currently, <code>rapport</code> supports only <code>data.frame</code> objects, but that may change in the (near) future.
</p>
</li>
<li> <p><em>standalone inputs</em> - the inputs that do not depend on the dataset. The user can just provide an <code>R</code> object of an appropriate class (and other input attributes) to match a <em>standalone</em> input.
</p>
</li></ul>

<p><strong>General input attributes</strong>
</p>
<p>Following attributes are available for all inputs:
</p>

<ul>
<li> <p><code>name</code> (character string, required) - input name. It acts as an identifier for a given input, and is required as such. Template cannot contain duplicate names. <code>rapport</code> inputs currently have custom naming conventions - see <code><a href="#topic+guess.input.name">guess.input.name</a></code> for details.
</p>
</li>
<li> <p><code>label</code> (character string) - input label. It can be blank, but it's useful to provide input label as <code>rapport</code> helpers use that information in plot labels and/or exported HTML tables. Defaults to empty string.
</p>
</li>
<li> <p><code>description</code> (character string) - similar to <code>label</code>, but should contain long description of given input.
</p>
</li>
<li> <p><code>class</code> (character string) - defines an input class. Currently supported input classes are: <code>character</code>, <code>complex</code>, <code>factor</code>, <code>integer</code>, <code>logical</code>, <code>numeric</code> and <code>raw</code> (all atomic vector classes are supported). Class attribute should usually be provided, but it can also be <code>NULL</code> (default) - in that case the input class will be guessed based on matched <code>R</code> object's value.
</p>
</li>
<li> <p><code>required</code> (logical value) - does the input require a value? Defaults to <code>FALSE</code>.
</p>
</li>
<li> <p><code>standalone</code> (logical value) - indicates that the input depends on a dataset. Defaults to <code>FALSE</code>.
</p>
</li>
<li> <p><code>length</code> (either an integer value or a named list with integer values) - provides a set of rules for input value's length. <code>length</code> attribute can be defined via:
</p>

<ul>
<li><p> an integer value, e.g. <code>length: 10</code>, which sets restriction to exactly 10 vectors or values.
</p>
</li>
<li><p> named list with <code>min</code> and/or <code>max</code> attributes nested under <code>length</code> attribute. This will define a range of values in which input length must must fall. Note that range limits are inclusive. Either <code>min</code> or <code>max</code> attribute can be omitted, and they will default to <code>1</code> and <code>Inf</code>, respectively.
</p>
</li></ul>

<p><strong>IMPORTANT!</strong> Note that <code>rapport</code> treats input length in a bit different manner. If you match a subset of 10 character vectors from the dataset, input length will be <code>10</code>, as you might expect. But if you select only one variable, length will be equal to <code>1</code>, and not to the number of vector elements. This stands both for standalone and dataset inputs. However, if you match a character vector against a standalone input, length will be stored correctly - as the number of vector elements.
</p>
</li>
<li> <p><code>value</code> (a vector of an appropriate class). This attribute only exists for standalone inputs. Provided value must satisfy rules defined in <code>class</code> and <code>length</code> attributes, as well as any other class-specific rules (see below).
</p>
</li></ul>

<p><strong>Class-specific attributes</strong>
</p>
<p><em>character</em>
</p>

<ul>
<li> <p><code>nchar</code> - restricts the number of characters of the input value. It accepts the same attribute format as <code>length</code>. If <code>NULL</code> (default), no checks will be performed.
</p>
</li>
<li> <p><code>regexp</code> (character string) - contains a string with regular expression. If non-<code>NULL</code>, all strings in a character vector must match the given regular expression. Defaults to <code>NULL</code> - no checks are applied.
</p>
</li>
<li> <p><code>matchable</code> (logical value) - if <code>TRUE</code>, <code>options</code> attribute must be provided, while <code>value</code> is optional, though recommended. <code>options</code> should contain values to be chosen from, just like <code>&lt;option&gt;</code> tag does when nested in <code>&lt;select&gt;</code> HTML tag, while <code>value</code> must contain a value from <code>options</code> or it can be omitted (<code>NULL</code>). <code>allow_multiple</code> will allow values from <code>options</code> list to be matched multiple times. Note that unlike previous versions of <code>rapport</code>, partial matching is not performed.
</p>
</li></ul>

<p><em>numeric</em>, <em>integer</em>
</p>

<ul>
<li> <p><code>limit</code> - similar to <code>length</code> attribute, but allows only <code>min</code> and <code>max</code> nested attributes. Unlike <code>length</code> attribute, <code>limit</code> checks input values rather than input length. <code>limit</code> attribute is <code>NULL</code> by default and the checks are performed only when <code>limit</code> is defined (non-<code>NULL</code>).
</p>
</li></ul>

<p><em>factor</em>
</p>

<ul>
<li> <p><code>nlevels</code> - accepts the same format as <code>length</code> attribute, but the check is performed rather on the number of factor levels.
</p>
</li>
<li> <p><code>matchable</code> - <em>ibid</em> as in character inputs (note that in previous versions of <code>rapport</code> matching was performed against factor levels - well, not any more, now we match against values to make it consistent with <code>character</code> inputs).
</p>
</li></ul>



<h3>See Also</h3>


<p><code><a href="#topic+rapport.meta">rapport.meta</a></code>
<code><a href="#topic+rapport.info">rapport.info</a></code>

</p>

<hr>
<h2 id='rapport.ls'>Package Templates</h2><span id='topic+rapport.ls'></span><span id='topic+tpl.list'></span>

<h3>Description</h3>

<p>Lists all templates bundled with current package build. By default, it will search for all <code>.rapport</code> files in current directory, path specified in <code>rapport.paths</code> option and package library path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rapport.ls(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rapport.ls_+3A_...">...</code></td>
<td>
<p>additional parameters for <code><a href="base.html#topic+dir">dir</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector with template files
</p>

<hr>
<h2 id='rapport.meta'>Header Metadata</h2><span id='topic+rapport.meta'></span><span id='topic+tpl.meta'></span>

<h3>Description</h3>

<p>Displays summary of template metadata stored in a header section. This part of template header consists of several YAML <code>key: value</code> pairs, which contain some basic information about the template, just much like the <code>DESCRIPTION</code> file in <code>R</code> packages does.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rapport.meta(fp, fields = NULL, use.header = FALSE, trim.white = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rapport.meta_+3A_fp">fp</code></td>
<td>
<p>a template file pointer (see <code>rapport:::rapport.read</code> for details)</p>
</td></tr>
<tr><td><code id="rapport.meta_+3A_fields">fields</code></td>
<td>
<p>a list of named lists containing key-value pairs of field titles and corresponding regexes</p>
</td></tr>
<tr><td><code id="rapport.meta_+3A_use.header">use.header</code></td>
<td>
<p>a logical value indicating if the character vector provided in <code>fp</code> argument contains only the header data (not the whole template)</p>
</td></tr>
<tr><td><code id="rapport.meta_+3A_trim.white">trim.white</code></td>
<td>
<p>a logical value indicating if the extra spaces should removed from header fields before extraction</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Current implementation supports following fields:
</p>

<ul>
<li> <p><code>title</code> - a template title (required)
</p>
</li>
<li> <p><code>author</code> - author's (nick)name (required)
</p>
</li>
<li> <p><code>description</code> - template description (required)
</p>
</li>
<li> <p><code>email</code> - author's email address
</p>
</li>
<li> <p><code>packages</code> - YAML list of packages required by the template (if any)
</p>
</li>
<li> <p><code>example</code> - example calls to <code>rapport</code> function, including template data and inputs
</p>
</li></ul>

<p>As of version <code>0.5</code>, <code>dataRequired</code> field is deprecated. <code>rapport</code> function will automatically detect if the template requires a dataset based on the presence of <em>standalone</em> inputs.
</p>


<h3>Value</h3>

<p>a named list with template metadata
</p>


<h3>See Also</h3>


<p><code><a href="#topic+rapport.inputs">rapport.inputs</a></code>
<code><a href="#topic+rapport.info">rapport.info</a></code>

</p>

<hr>
<h2 id='rapport.odt'>Rapport to ODT</h2><span id='topic+rapport.odt'></span>

<h3>Description</h3>

<p>This is a simple wrapper around <code><a href="#topic+rapport">rapport</a></code> and <code><a href="#topic+rapport.export">rapport.export</a></code>. Basically it works like <code><a href="#topic+rapport">rapport</a></code> but the returned class is exported at one go.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rapport.odt(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rapport.odt_+3A_...">...</code></td>
<td>
<p>parameters passed directly to <code><a href="#topic+rapport">rapport</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+rapport.export">rapport.export</a></code> <code><a href="#topic+rapport.html">rapport.html</a></code> <code><a href="#topic+rapport.pdf">rapport.pdf</a></code> <code><a href="#topic+rapport.docx">rapport.docx</a></code>
</p>

<hr>
<h2 id='rapport.path'>Template Paths</h2><span id='topic+rapport.path'></span><span id='topic+tpl.paths'></span>

<h3>Description</h3>

<p>List all custom paths where rapport will look for templates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rapport.path()
</code></pre>


<h3>Value</h3>

<p>a character vector with paths
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rapport.path()

## End(Not run)
</code></pre>

<hr>
<h2 id='rapport.path.add'>Add Template Path</h2><span id='topic+rapport.path.add'></span><span id='topic+tpl.paths.add'></span>

<h3>Description</h3>

<p>Adds a new element to custom paths' list where rapport will look for templates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rapport.path.add(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rapport.path.add_+3A_...">...</code></td>
<td>
<p>character vector of paths</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE on success (invisibly)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rapport.path.add('/tmp')
rapport.ls()

## End(Not run)
</code></pre>

<hr>
<h2 id='rapport.path.remove'>Remove Template Path</h2><span id='topic+rapport.path.remove'></span><span id='topic+tpl.paths.remove'></span>

<h3>Description</h3>

<p>Removes an element from custom paths' list where rapport will look for templates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rapport.path.remove(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rapport.path.remove_+3A_...">...</code></td>
<td>
<p>character vector of paths</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE on success (invisibly)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rapport.path()
rapport.path.add('/tmp')
rapport.path()
rapport.path.remove('/tmp')
rapport.path()

## End(Not run)
</code></pre>

<hr>
<h2 id='rapport.path.reset'>Reset Template Paths</h2><span id='topic+rapport.path.reset'></span><span id='topic+tpl.paths.reset'></span>

<h3>Description</h3>

<p>Resets to default (NULL) all custom paths where rapport will look for templates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rapport.path.reset()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rapport.path.reset()

## End(Not run)
</code></pre>

<hr>
<h2 id='rapport.pdf'>Rapport to PDF</h2><span id='topic+rapport.pdf'></span>

<h3>Description</h3>

<p>This is a simple wrapper around <code><a href="#topic+rapport">rapport</a></code> and <code><a href="#topic+rapport.export">rapport.export</a></code>. Basically it works like <code><a href="#topic+rapport">rapport</a></code> but the returned class is exported at one go.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rapport.pdf(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rapport.pdf_+3A_...">...</code></td>
<td>
<p>parameters passed directly to <code><a href="#topic+rapport">rapport</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+rapport.export">rapport.export</a></code> <code><a href="#topic+rapport.html">rapport.html</a></code> <code><a href="#topic+rapport.odt">rapport.odt</a></code> <code><a href="#topic+rapport.docx">rapport.docx</a></code>
</p>

<hr>
<h2 id='rapport.read'>Read Template</h2><span id='topic+rapport.read'></span><span id='topic+tpl.find'></span>

<h3>Description</h3>

<p>Reads file either from template name in system folder, file path (see <code>rapport.path</code>) or remote URL, and splits it into lines for easier handling by <em>rapport</em> internal parser.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rapport.read(fp, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rapport.read_+3A_fp">fp</code></td>
<td>
<p>a character string containing a template path, a template name (for package-bundled templates only), template contents separated by newline (<code>\n</code>), or a character vector with template contents.</p>
</td></tr>
<tr><td><code id="rapport.read_+3A_...">...</code></td>
<td>
<p>additional params for header tag matching (see <code><a href="base.html#topic+grep">grep</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector with template contents
</p>

<hr>
<h2 id='rapport.renew'>Renew deprecated template</h2><span id='topic+rapport.renew'></span><span id='topic+tpl.renew'></span>

<h3>Description</h3>

<p>Convert old-style template to new-style one (what we really do is just replacing old header syntax with YAML one).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rapport.renew(fp, file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rapport.renew_+3A_fp">fp</code></td>
<td>
<p>pointer to an old template (see <code>rapport:::rapport.read</code> for details)</p>
</td></tr>
<tr><td><code id="rapport.renew_+3A_file">file</code></td>
<td>
<p>a path to output file. If <code>NULL</code>, result will be flushed to stdout.</p>
</td></tr>
</table>

<hr>
<h2 id='rapport.rerun'>Reproduce Template</h2><span id='topic+rapport.rerun'></span><span id='topic+tpl.rerun'></span>

<h3>Description</h3>

<p>Runs template with data and arguments included in <code>rapport</code> object. In order to get reproducible example, you have to make sure that <code>reproducible</code> argument is set to <code>TRUE</code> in <code>rapport</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rapport.rerun(tpl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rapport.rerun_+3A_tpl">tpl</code></td>
<td>
<p>a <code>rapport</code> object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tmp &lt;- rapport("Example", mtcars, v = "hp", reproducible = TRUE)
rapport.rerun(tmp)

## End(Not run)
</code></pre>

<hr>
<h2 id='rapport.tangle'>Extract template chunk contents</h2><span id='topic+rapport.tangle'></span><span id='topic+tpl.tangle'></span>

<h3>Description</h3>

<p><code>rapport</code>'s alternative to <code><a href="utils.html#topic+Stangle">Stangle</a></code> - extracts contents of template chunks. If <code>file</code> argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rapport.tangle(fp, file = "", show.inline.chunks = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rapport.tangle_+3A_fp">fp</code></td>
<td>
<p>template file pointer (see <code>rapport:::rapport.read</code> for details)</p>
</td></tr>
<tr><td><code id="rapport.tangle_+3A_file">file</code></td>
<td>
<p>see <code>file</code> argument in <code><a href="base.html#topic+cat">cat</a></code> function documentation</p>
</td></tr>
<tr><td><code id="rapport.tangle_+3A_show.inline.chunks">show.inline.chunks</code></td>
<td>
<p>extract contents of inline chunks as well? (defaults to <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(invisibly) a list with either inline or block chunk contents
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
