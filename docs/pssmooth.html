<!DOCTYPE html><html><head><title>Help for package pssmooth</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pssmooth}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bootRiskCurve'><p>Bootstrap Estimation of Conditional Clinical Endpoint Risk under Placebo and Treatment Given Biomarker Response to Treatment in a Baseline Surrogate Measure</p>
Three-Phase Sampling Design</a></li>
<li><a href='#plotMCEPcurve'><p>Plotting of the Estimated Marginal Causal Effect Predictiveness Curve</p></a></li>
<li><a href='#riskCurve'><p>Estimation of Conditional Clinical Endpoint Risk under Placebo and Treatment Given Biomarker Response to Treatment in a Baseline Surrogate Measure Three-Phase Sampling Design</p></a></li>
<li><a href='#summary.riskCurve'><p>Summary of Point and Interval Estimation of a Marginal Causal Effect Predictiveness Curve</p></a></li>
<li><a href='#testConstancy'><p>Testing of the Null Hypotheses of a Flat and a Constant Marginal Causal Effect Predictiveness Curve</p></a></li>
<li><a href='#testEquality'><p>Testing of the Null Hypothesis of Equal Marginal Causal Effect Predictiveness Curves for Two Biomarkers, Endpoints, or Baseline Covariate Subgroups</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Flexible and Efficient Evaluation of Principal
Surrogates/Treatment Effect Modifiers</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mjuraska/pssmooth/issues">https://github.com/mjuraska/pssmooth/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Implements estimation and testing procedures for evaluating an intermediate biomarker response as a principal surrogate of a clinical response to treatment (i.e., principal stratification effect modification analysis), as described in Juraska M, Huang Y, and Gilbert PB (2020), Inference on treatment effect modification by biomarker response in a three-phase sampling design, Biostatistics, 21(3): 545-560 &lt;<a href="https://doi.org/10.1093%2Fbiostatistics%2Fkxy074">doi:10.1093/biostatistics/kxy074</a>&gt;. The methods avoid the restrictive 'placebo structural risk' modeling assumption common to past methods and further improve robustness by the use of nonparametric kernel smoothing for biomarker density estimation. A randomized controlled two-group clinical efficacy trial is assumed with an ordered categorical or continuous univariate biomarker response measured at a fixed timepoint post-randomization and with a univariate baseline surrogate measure allowed to be observed in only a subset of trial participants with an observed biomarker response (see the flexible three-phase sampling design in the paper for details). Bootstrap-based procedures are available for pointwise and simultaneous confidence intervals and testing of four relevant hypotheses. Summary and plotting functions are provided for estimation results.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mjuraska/pssmooth">https://github.com/mjuraska/pssmooth</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, osDesign, np, chngpt, MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-11-18 01:01:21 UTC; mjuraska</td>
</tr>
<tr>
<td>Author:</td>
<td>Michal Juraska [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michal Juraska &lt;mjuraska@fredhutch.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-11-18 13:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='bootRiskCurve'>Bootstrap Estimation of Conditional Clinical Endpoint Risk under Placebo and Treatment Given Biomarker Response to Treatment in a Baseline Surrogate Measure
Three-Phase Sampling Design</h2><span id='topic+bootRiskCurve'></span>

<h3>Description</h3>

<p>Estimates <code class="reqn">P\{Y(z)=1|S(1)=s_1\}</code>, <code class="reqn">z=0,1</code>, on a grid of <code class="reqn">s_1</code> values in bootstrap resamples (see <code><a href="#topic+riskCurve">riskCurve</a></code> for notation introduction). Cases
(<code class="reqn">Y=1</code>) and controls (<code class="reqn">Y=0</code>) are sampled separately yielding a fixed number of cases and controls in each bootstrap sample. Consequentially, the number of controls
with available phase 2 data varies across bootstrap samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootRiskCurve(
  formula,
  bsm,
  tx,
  data,
  pstype = c("continuous", "ordered"),
  bsmtype = c("continuous", "ordered"),
  bwtype = c("fixed", "generalized_nn", "adaptive_nn"),
  hinge = FALSE,
  weights = NULL,
  psGrid = NULL,
  iter,
  seed = NULL,
  saveFile = NULL,
  saveDir = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootRiskCurve_+3A_formula">formula</code></td>
<td>
<p>a formula object with the binary clinical endpoint on the left of the <code>~</code> operator. The first listed variable on the right must be the biomarker response
at <code class="reqn">t0</code> and all variables that follow, if any, are discrete baseline covariates specified in all fitted models that condition on them. Interactions and transformations
of the baseline covariates are allowed. All terms in the formula must be evaluable in the data frame <code>data</code>.</p>
</td></tr>
<tr><td><code id="bootRiskCurve_+3A_bsm">bsm</code></td>
<td>
<p>a character string specifying the variable name in <code>data</code> representing the baseline surrogate measure</p>
</td></tr>
<tr><td><code id="bootRiskCurve_+3A_tx">tx</code></td>
<td>
<p>a character string specifying the variable name in <code>data</code> representing the treatment group indicator</p>
</td></tr>
<tr><td><code id="bootRiskCurve_+3A_data">data</code></td>
<td>
<p>a data frame with one row per randomized participant endpoint-free at <code class="reqn">t_0</code> that contains at least the variables specified in <code>formula</code>, <code>bsm</code> and
<code>tx</code>. Values of <code>bsm</code> and the biomarker at <code class="reqn">t_0</code> that are unavailable are represented as <code>NA</code>.</p>
</td></tr>
<tr><td><code id="bootRiskCurve_+3A_pstype">pstype</code></td>
<td>
<p>a character string specifying whether the biomarker response shall be treated as a <code>continuous</code> (default) or <code>ordered</code> categorical variable in the
kernel density/probability estimation</p>
</td></tr>
<tr><td><code id="bootRiskCurve_+3A_bsmtype">bsmtype</code></td>
<td>
<p>a character string specifying whether the baseline surrogate measure shall be treated as a <code>continuous</code> (default) or <code>ordered</code> categorical variable in the
kernel density/probability estimation</p>
</td></tr>
<tr><td><code id="bootRiskCurve_+3A_bwtype">bwtype</code></td>
<td>
<p>a character string specifying the bandwidth type for continuous variables in the kernel density estimation. The options are <code>fixed</code> (default) for fixed
bandwidths, <code>generalized_nn</code> for generalized nearest neighbors, and <code>adaptive_nn</code> for adaptive nearest neighbors. As noted in the documentation of the function
<code>npcdensbw</code> in the <code>np</code> package: &quot;Adaptive nearest-neighbor bandwidths change with each sample realization in the set when estimating the density at the point <code class="reqn">x</code>.
Generalized nearest-neighbor bandwidths change with the point at which the density is estimated, <code class="reqn">x</code>. Fixed bandwidths are constant over the support of <code class="reqn">x</code>.&quot;</p>
</td></tr>
<tr><td><code id="bootRiskCurve_+3A_hinge">hinge</code></td>
<td>
<p>a logical value (<code>FALSE</code> by default) indicating whether a hinge model (Fong et al., 2017) shall be used for modeling the effect of <code class="reqn">S(z)</code> on the
clinical endpoint risk. A hinge model specifies that variability in <code class="reqn">S(z)</code> below the hinge point does not associate with the clinical endpoint risk. The hinge point
is reestimated in each bootstrap sample.</p>
</td></tr>
<tr><td><code id="bootRiskCurve_+3A_weights">weights</code></td>
<td>
<p>either a numeric vector of weights or a character string specifying the variable name in <code>data</code> representing weights applied to observations
in the phase 2 subset in order to make inference about the target population of all randomized participants endpoint-free at <code class="reqn">t_0</code>. The weights reflect that
the case:control ratio in the phase 2 subset is different from that in the target population and are passed on to GLMs in the estimation of the hinge point.
If <code>NULL</code> (default and recommended), weights for cases and controls are recalculated separately in each study group <em>within each bootstrap sample</em>; otherwise the
same specified vector of weights is used in each bootstrap sample.</p>
</td></tr>
<tr><td><code id="bootRiskCurve_+3A_psgrid">psGrid</code></td>
<td>
<p>a numeric vector of <code class="reqn">S(1)</code> values at which the conditional clinical endpoint risk in each study group is estimated. If <code>NULL</code> (default),
a grid of values spanning the range of observed values of the biomarker will be used.</p>
</td></tr>
<tr><td><code id="bootRiskCurve_+3A_iter">iter</code></td>
<td>
<p>the number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="bootRiskCurve_+3A_seed">seed</code></td>
<td>
<p>a seed of the random number generator supplied to <code>set.seed</code> for reproducibility</p>
</td></tr>
<tr><td><code id="bootRiskCurve_+3A_savefile">saveFile</code></td>
<td>
<p>a character string specifying the name of an <code>.RData</code> file storing the output list. If <code>NULL</code> (default), the output list will only be returned.</p>
</td></tr>
<tr><td><code id="bootRiskCurve_+3A_savedir">saveDir</code></td>
<td>
<p>a character string specifying a path for the output directory. If <code>NULL</code> (default), the output list will only be returned; otherwise, if
<code>saveFile</code> is specified, the output list will also be saved as an <code>.RData</code> file in the specified directory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>saveFile</code> and <code>saveDir</code> are both specified, the output list (named <code>bList</code>) is saved as an <code>.RData</code> file; otherwise it is returned only.
The output object is a list with the following components:
</p>

<ul>
<li> <p><code>psGrid</code>: a numeric vector of <code class="reqn">S(1)</code> values at which the conditional clinical endpoint risk is estimated in the components <code>plaRiskCurveBoot</code> and
<code>txRiskCurveBoot</code>
</p>
</li>
<li> <p><code>plaRiskCurveBoot</code>: a <code>length(psGrid)</code>-by-<code>iter</code> matrix of estimates of <code class="reqn">P\{Y(0)=1|S(1)=s_1\}</code> for <code class="reqn">s_1</code> in <code>psGrid</code>,
with columns representing bootstrap samples
</p>
</li>
<li> <p><code>txRiskCurveBoot</code>: a <code>length(psGrid)</code>-by-<code>iter</code> matrix of estimates of <code class="reqn">P\{Y(1)=1|S(1)=s_1\}</code> for <code class="reqn">s_1</code> in <code>psGrid</code>,
with columns representing bootstrap samples
</p>
</li>
<li> <p><code>cpointPboot</code>: if <code>hinge=TRUE</code>, a numeric vector of estimates of the hinge point in the placebo group in each bootstrap sample
</p>
</li>
<li> <p><code>cpointTboot</code>: if <code>hinge=TRUE</code>, a numeric vector of estimates of the hinge point in the treatment group in each bootstrap sample
</p>
</li></ul>



<h3>References</h3>

<p>Fong, Y., Huang, Y., Gilbert, P. B., and Permar, S. R. (2017), chngpt: threshold regression model estimation and inference, <em>BMC Bioinformatics</em>, 18.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+riskCurve">riskCurve</a></code>, <code><a href="#topic+summary.riskCurve">summary.riskCurve</a></code> and <code><a href="#topic+plotMCEPcurve">plotMCEPcurve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
Z &lt;- rep(0:1, each=n/2)
S &lt;- MASS::mvrnorm(n, mu=c(2,2,3), Sigma=matrix(c(1,0.9,0.7,0.9,1,0.7,0.7,0.7,1), nrow=3))
p &lt;- pnorm(drop(cbind(1,Z,(1-Z)*S[,2],Z*S[,3]) %*% c(-1.2,0.2,-0.02,-0.2)))
Y &lt;- sapply(p, function(risk){ rbinom(1,1,risk) })
X &lt;- rbinom(n,1,0.5)
# delete S(1) in placebo recipients
S[Z==0,3] &lt;- NA
# delete S(0) in treatment recipients
S[Z==1,2] &lt;- NA
# generate the indicator of being sampled into the phase 2 subset
phase2 &lt;- rbinom(n,1,0.4)
# delete Sb, S(0) and S(1) in controls not included in the phase 2 subset
S[Y==0 &amp; phase2==0,] &lt;- c(NA,NA,NA)
# delete Sb in cases not included in the phase 2 subset
S[Y==1 &amp; phase2==0,1] &lt;- NA
data &lt;- data.frame(X,Z,S[,1],ifelse(Z==0,S[,2],S[,3]),Y)
colnames(data) &lt;- c("X","Z","Sb","S","Y")
qS &lt;- quantile(data$S, probs=c(0.05,0.95), na.rm=TRUE)
grid &lt;- seq(qS[1], qS[2], length.out=3)

out &lt;- bootRiskCurve(formula=Y ~ S + factor(X), bsm="Sb", tx="Z", data=data,
                     psGrid=grid, iter=1, seed=10)

# alternatively, to save the .RData output file (no '&lt;-' needed):
bootRiskCurve(formula=Y ~ S + factor(X), bsm="Sb", tx="Z", data=data,
              psGrid=grid, iter=1, seed=10, saveFile="out.RData", saveDir="./")


</code></pre>

<hr>
<h2 id='plotMCEPcurve'>Plotting of the Estimated Marginal Causal Effect Predictiveness Curve</h2><span id='topic+plotMCEPcurve'></span>

<h3>Description</h3>

<p>Plots point estimates and, if available, pointwise and simultaneous Wald-type bootstrap confidence intervals for the specified marginal causal effect predictiveness (mCEP)
curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMCEPcurve(
  object,
  confLevel = 0.95,
  hingePoint = NULL,
  title = NULL,
  xLab = NULL,
  yLab = NULL,
  yLim = NULL,
  pType = c("l", "p")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMCEPcurve_+3A_object">object</code></td>
<td>
<p>an object returned by <code><a href="#topic+summary.riskCurve">summary.riskCurve</a></code></p>
</td></tr>
<tr><td><code id="plotMCEPcurve_+3A_conflevel">confLevel</code></td>
<td>
<p>the confidence level (0.95 by default) of pointwise and simultaneous confidence intervals</p>
</td></tr>
<tr><td><code id="plotMCEPcurve_+3A_hingepoint">hingePoint</code></td>
<td>
<p>the hinge point estimate (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="plotMCEPcurve_+3A_title">title</code></td>
<td>
<p>a character string specifying the plot title</p>
</td></tr>
<tr><td><code id="plotMCEPcurve_+3A_xlab">xLab</code></td>
<td>
<p>a character string specifying the x-axis label (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="plotMCEPcurve_+3A_ylab">yLab</code></td>
<td>
<p>a character string specifying the y-axis label (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="plotMCEPcurve_+3A_ylim">yLim</code></td>
<td>
<p>a numeric vector of length 2 specifying the y-axis range (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="plotMCEPcurve_+3A_ptype">pType</code></td>
<td>
<p>a character string specifying the type of plot. Possible options are <code>"l"</code> for lines (default) and <code>"p"</code> for points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. The function is called solely for plot generation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+riskCurve">riskCurve</a></code>, <code><a href="#topic+bootRiskCurve">bootRiskCurve</a></code> and <code><a href="#topic+summary.riskCurve">summary.riskCurve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
Z &lt;- rep(0:1, each=n/2)
S &lt;- MASS::mvrnorm(n, mu=c(2,2,3), Sigma=matrix(c(1,0.9,0.7,0.9,1,0.7,0.7,0.7,1), nrow=3))
p &lt;- pnorm(drop(cbind(1,Z,(1-Z)*S[,2],Z*S[,3]) %*% c(-1.2,0.2,-0.02,-0.2)))
Y &lt;- sapply(p, function(risk){ rbinom(1,1,risk) })
X &lt;- rbinom(n,1,0.5)
# delete S(1) in placebo recipients
S[Z==0,3] &lt;- NA
# delete S(0) in treatment recipients
S[Z==1,2] &lt;- NA
# generate the indicator of being sampled into the phase 2 subset
phase2 &lt;- rbinom(n,1,0.3)
# delete Sb, S(0) and S(1) in controls not included in the phase 2 subset
S[Y==0 &amp; phase2==0,] &lt;- c(NA,NA,NA)
# delete Sb in cases not included in the phase 2 subset
S[Y==1 &amp; phase2==0,1] &lt;- NA
data &lt;- data.frame(X,Z,S[,1],ifelse(Z==0,S[,2],S[,3]),Y)
colnames(data) &lt;- c("X","Z","Sb","S","Y")
qS &lt;- quantile(data$S, probs=c(0.05,0.95), na.rm=TRUE)
grid &lt;- seq(qS[1], qS[2], length.out=3)

out &lt;- riskCurve(formula=Y ~ S + factor(X), bsm="Sb", tx="Z", data=data, psGrid=grid)
boot &lt;- bootRiskCurve(formula=Y ~ S + factor(X), bsm="Sb", tx="Z", data=data,
                      psGrid=grid, iter=2, seed=10)
sout &lt;- summary(out, boot, contrast="te")
plotMCEPcurve(sout)


</code></pre>

<hr>
<h2 id='riskCurve'>Estimation of Conditional Clinical Endpoint Risk under Placebo and Treatment Given Biomarker Response to Treatment in a Baseline Surrogate Measure Three-Phase Sampling Design</h2><span id='topic+riskCurve'></span>

<h3>Description</h3>

<p>Estimates <code class="reqn">P\{Y(z)=1|S(1)=s_1\}</code>, <code class="reqn">z=0,1</code>, on a grid of <code class="reqn">s_1</code> values following the estimation method of Juraska, Huang, and Gilbert (2018), where <code class="reqn">Z</code> is the
treatment group indicator (<code class="reqn">Z=1</code>, treatment; <code class="reqn">Z=0</code>, placebo), <code class="reqn">S(z)</code> is a continuous or ordered categorical univariate biomarker under assignment to <code class="reqn">Z=z</code>
measured at fixed time <code class="reqn">t_0</code> after randomization, and <code class="reqn">Y</code> is a binary clinical endpoint (<code class="reqn">Y=1</code>, disease; <code class="reqn">Y=0</code>, no disease) measured after <code class="reqn">t_0</code>. The
estimator employs the generalized product kernel density/probability estimation method of Hall, Racine, and Li (2004) implemented in the <code>np</code> package. The risks
<code class="reqn">P\{Y(z)=1|S(z)=s_1,X=x\}</code>, <code class="reqn">z=0,1</code>, where <code class="reqn">X</code> is a vector of discrete baseline covariates, are estimated by fitting inverse probability-weighted logistic regression
models using the <code>osDesign</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riskCurve(
  formula,
  bsm,
  tx,
  data,
  pstype = c("continuous", "ordered"),
  bsmtype = c("continuous", "ordered"),
  bwtype = c("fixed", "generalized_nn", "adaptive_nn"),
  hinge = FALSE,
  weights = NULL,
  psGrid = NULL,
  saveFile = NULL,
  saveDir = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="riskCurve_+3A_formula">formula</code></td>
<td>
<p>a formula object with the binary clinical endpoint on the left of the <code>~</code> operator. The first listed variable on the right must be the biomarker response
at <code class="reqn">t0</code> and all variables that follow, if any, are discrete baseline covariates specified in all fitted models that condition on them. Interactions and transformations
of the baseline covariates are allowed. All terms in the formula must be evaluable in the data frame <code>data</code>.</p>
</td></tr>
<tr><td><code id="riskCurve_+3A_bsm">bsm</code></td>
<td>
<p>a character string specifying the variable name in <code>data</code> representing the baseline surrogate measure</p>
</td></tr>
<tr><td><code id="riskCurve_+3A_tx">tx</code></td>
<td>
<p>a character string specifying the variable name in <code>data</code> representing the treatment group indicator</p>
</td></tr>
<tr><td><code id="riskCurve_+3A_data">data</code></td>
<td>
<p>a data frame with one row per randomized participant endpoint-free at <code class="reqn">t_0</code> that contains at least the variables specified in <code>formula</code>, <code>bsm</code> and
<code>tx</code>. Values of <code>bsm</code> and the biomarker at <code class="reqn">t_0</code> that are unavailable are represented as <code>NA</code>.</p>
</td></tr>
<tr><td><code id="riskCurve_+3A_pstype">pstype</code></td>
<td>
<p>a character string specifying whether the biomarker response shall be treated as a <code>continuous</code> (default) or <code>ordered</code> categorical variable in the
kernel density/probability estimation</p>
</td></tr>
<tr><td><code id="riskCurve_+3A_bsmtype">bsmtype</code></td>
<td>
<p>a character string specifying whether the baseline surrogate measure shall be treated as a <code>continuous</code> (default) or <code>ordered</code> categorical variable in the
kernel density/probability estimation</p>
</td></tr>
<tr><td><code id="riskCurve_+3A_bwtype">bwtype</code></td>
<td>
<p>a character string specifying the bandwidth type for continuous variables in the kernel density estimation. The options are <code>fixed</code> (default) for fixed
bandwidths, <code>generalized_nn</code> for generalized nearest neighbors, and <code>adaptive_nn</code> for adaptive nearest neighbors. As noted in the documentation of the function
<code>npcdensbw</code> in the <code>np</code> package: &quot;Adaptive nearest-neighbor bandwidths change with each sample realization in the set when estimating the density at the point <code class="reqn">x</code>.
Generalized nearest-neighbor bandwidths change with the point at which the density is estimated, <code class="reqn">x</code>. Fixed bandwidths are constant over the support of <code class="reqn">x</code>.&quot;</p>
</td></tr>
<tr><td><code id="riskCurve_+3A_hinge">hinge</code></td>
<td>
<p>a logical value (<code>FALSE</code> by default) indicating whether a hinge model (Fong et al., 2017) shall be used for modeling the effect of <code class="reqn">S(z)</code> on the
clinical endpoint risk. A hinge model specifies that variability in <code class="reqn">S(z)</code> below the hinge point does not associate with the clinical endpoint risk.</p>
</td></tr>
<tr><td><code id="riskCurve_+3A_weights">weights</code></td>
<td>
<p>either a numeric vector of weights or a character string specifying the variable name in <code>data</code> representing weights applied to observations
in the phase 2 subset in order to make inference about the target population of all randomized participants endpoint-free at <code class="reqn">t_0</code>. The weights reflect that
the case:control ratio in the phase 2 subset is different from that in the target population and are passed on to GLMs in the estimation of the hinge point.
If <code>NULL</code> (default), weights for cases and controls are calculated separately in each study group.</p>
</td></tr>
<tr><td><code id="riskCurve_+3A_psgrid">psGrid</code></td>
<td>
<p>a numeric vector of <code class="reqn">S(1)</code> values at which the conditional clinical endpoint risk in each study group is estimated. If <code>NULL</code> (default),
a grid of values spanning the range of observed values of the biomarker will be used.</p>
</td></tr>
<tr><td><code id="riskCurve_+3A_savefile">saveFile</code></td>
<td>
<p>a character string specifying the name of an <code>.RData</code> file storing the output list. If <code>NULL</code> (default), the output list will only be returned.</p>
</td></tr>
<tr><td><code id="riskCurve_+3A_savedir">saveDir</code></td>
<td>
<p>a character string specifying a path for the output directory. If <code>NULL</code> (default), the output list will only be returned; otherwise, if
<code>saveFile</code> is specified, the output list will also be saved as an <code>.RData</code> file in the specified directory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>saveFile</code> and <code>saveDir</code> are both specified, the output list (named <code>oList</code>) is saved as an <code>.RData</code> file; otherwise it is returned only.
The output object (of class <code>riskCurve</code>) is a list with the following components:
</p>

<ul>
<li> <p><code>psGrid</code>: a numeric vector of <code class="reqn">S(1)</code> values at which the conditional clinical endpoint risk is estimated in the components <code>plaRiskCurve</code> and
<code>txRiskCurve</code>
</p>
</li>
<li> <p><code>plaRiskCurve</code>: a numeric vector of estimates of <code class="reqn">P\{Y(0)=1|S(1)=s_1\}</code> for <code class="reqn">s_1</code> in <code>psGrid</code>
</p>
</li>
<li> <p><code>txRiskCurve</code>: a numeric vector of estimates of <code class="reqn">P\{Y(1)=1|S(1)=s_1\}</code> for <code class="reqn">s_1</code> in <code>psGrid</code>
</p>
</li>
<li> <p><code>fOptBandwidths</code>: a <code>conbandwidth</code> object returned by the call of the function <code>npcdensbw</code> containing the optimal bandwidths, selected by likelihood
cross-validation, in the kernel estimation of the conditional density of <code class="reqn">S(1)</code> given the baseline surrogate measure and any other specified baseline covariates
</p>
</li>
<li> <p><code>gOptBandwidths</code>: a <code>conbandwidth</code> object returned by the call of the function <code>npcdensbw</code> or <code>npudensbw</code> containing the optimal bandwidths,
selected by likelihood cross-validation, in the kernel estimation of the conditional density of <code class="reqn">S(0)</code> given any specified baseline covariates or the marginal density
of <code class="reqn">S(0)</code> if no baseline covariates are specified in <code>formula</code>
</p>
</li>
<li> <p><code>cpointP</code>: if <code>hinge=TRUE</code>, the estimate of the hinge point in the placebo group
</p>
</li>
<li> <p><code>cpointT</code>: if <code>hinge=TRUE</code>, the estimate of the hinge point in the treatment group
</p>
</li></ul>



<h3>References</h3>

<p>Fong, Y., Huang, Y., Gilbert, P. B., and Permar, S. R. (2017), chngpt: threshold regression model estimation and inference, <em>BMC Bioinformatics</em>, 18.
</p>
<p>Hall, P., Racine, J., and Li, Q. (2004), Cross-validation and the estimation of conditional probability densities, <em>JASA</em> 99(468), 1015-1026.
</p>
<p>Juraska, M., Huang, Y., and Gilbert, P. B. (2020), Inference on treatment effect modification by biomarker response in a three-phase sampling design, Biostatistics, 21(3): 545-560, <a href="https://doi.org/10.1093/biostatistics/kxy074">https://doi.org/10.1093/biostatistics/kxy074</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bootRiskCurve">bootRiskCurve</a></code>, <code><a href="#topic+summary.riskCurve">summary.riskCurve</a></code> and <code><a href="#topic+plotMCEPcurve">plotMCEPcurve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
Z &lt;- rep(0:1, each=n/2)
S &lt;- MASS::mvrnorm(n, mu=c(2,2,3), Sigma=matrix(c(1,0.9,0.7,0.9,1,0.7,0.7,0.7,1), nrow=3))
p &lt;- pnorm(drop(cbind(1,Z,(1-Z)*S[,2],Z*S[,3]) %*% c(-1.2,0.2,-0.02,-0.2)))
Y &lt;- sapply(p, function(risk){ rbinom(1,1,risk) })
X &lt;- rbinom(n,1,0.5)
# delete S(1) in placebo recipients
S[Z==0,3] &lt;- NA
# delete S(0) in treatment recipients
S[Z==1,2] &lt;- NA
# generate the indicator of being sampled into the phase 2 subset
phase2 &lt;- rbinom(n,1,0.4)
# delete Sb, S(0) and S(1) in controls not included in the phase 2 subset
S[Y==0 &amp; phase2==0,] &lt;- c(NA,NA,NA)
# delete Sb in cases not included in the phase 2 subset
S[Y==1 &amp; phase2==0,1] &lt;- NA
data &lt;- data.frame(X,Z,S[,1],ifelse(Z==0,S[,2],S[,3]),Y)
colnames(data) &lt;- c("X","Z","Sb","S","Y")
qS &lt;- quantile(data$S, probs=c(0.05,0.95), na.rm=TRUE)
grid &lt;- seq(qS[1], qS[2], length.out=3)

out &lt;- riskCurve(formula=Y ~ S + factor(X), bsm="Sb", tx="Z", data=data, psGrid=grid)

# alternatively, to save the .RData output file (no '&lt;-' needed):
riskCurve(formula=Y ~ S + factor(X), bsm="Sb", tx="Z", data=data, saveFile="out.RData",
          saveDir="./")


</code></pre>

<hr>
<h2 id='summary.riskCurve'>Summary of Point and Interval Estimation of a Marginal Causal Effect Predictiveness Curve</h2><span id='topic+summary.riskCurve'></span>

<h3>Description</h3>

<p>Summarizes point estimates and pointwise and simultaneous Wald-type bootstrap confidence intervals for a specified marginal causal effect predictiveness (mCEP) curve (see,
e.g., Juraska, Huang, and Gilbert (2018) for the definition).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'riskCurve'
summary(
  object,
  boot = NULL,
  contrast = c("te", "rr", "logrr", "rd"),
  confLevel = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.riskCurve_+3A_object">object</code></td>
<td>
<p>an object of class <code>riskCurve</code>, typically returned by <code><a href="#topic+riskCurve">riskCurve</a></code></p>
</td></tr>
<tr><td><code id="summary.riskCurve_+3A_boot">boot</code></td>
<td>
<p>an object returned by <code><a href="#topic+bootRiskCurve">bootRiskCurve</a></code>. If <code>NULL</code> (default), only point estimates are reported.</p>
</td></tr>
<tr><td><code id="summary.riskCurve_+3A_contrast">contrast</code></td>
<td>
<p>a character string specifying the mCEP curve. It must be one of <code>te</code> (treatment efficacy), <code>rr</code> (relative risk), <code>logrr</code> (log relative risk), and <code>rd</code> (risk
difference [placebo minus treatment]).</p>
</td></tr>
<tr><td><code id="summary.riskCurve_+3A_conflevel">confLevel</code></td>
<td>
<p>the confidence level of pointwise and simultaneous confidence intervals</p>
</td></tr>
<tr><td><code id="summary.riskCurve_+3A_...">...</code></td>
<td>
<p>for other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing point and possibly interval estimates of the specified mCEP curve.
</p>


<h3>References</h3>

<p>Juraska, M., Huang, Y., and Gilbert, P. B. (2020), Inference on treatment effect modification by biomarker response in a three-phase sampling design, Biostatistics, 21(3): 545-560, <a href="https://doi.org/10.1093/biostatistics/kxy074">https://doi.org/10.1093/biostatistics/kxy074</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+riskCurve">riskCurve</a></code> and <code><a href="#topic+bootRiskCurve">bootRiskCurve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
Z &lt;- rep(0:1, each=n/2)
S &lt;- MASS::mvrnorm(n, mu=c(2,2,3), Sigma=matrix(c(1,0.9,0.7,0.9,1,0.7,0.7,0.7,1), nrow=3))
p &lt;- pnorm(drop(cbind(1,Z,(1-Z)*S[,2],Z*S[,3]) %*% c(-1.2,0.2,-0.02,-0.2)))
Y &lt;- sapply(p, function(risk){ rbinom(1,1,risk) })
# delete S(1) in placebo recipients
S[Z==0,3] &lt;- NA
# delete S(0) in treatment recipients
S[Z==1,2] &lt;- NA
# generate the indicator of being sampled into the phase 2 subset
phase2 &lt;- rbinom(n,1,0.4)
# delete Sb, S(0) and S(1) in controls not included in the phase 2 subset
S[Y==0 &amp; phase2==0,] &lt;- c(NA,NA,NA)
# delete Sb in cases not included in the phase 2 subset
S[Y==1 &amp; phase2==0,1] &lt;- NA
data &lt;- data.frame(Z,S[,1],ifelse(Z==0,S[,2],S[,3]),Y)
colnames(data) &lt;- c("Z","Sb","S","Y")
qS &lt;- quantile(data$S, probs=c(0.05,0.95), na.rm=TRUE)
grid &lt;- seq(qS[1], qS[2], length.out=2)

out &lt;- riskCurve(formula=Y ~ S, bsm="Sb", tx="Z", data=data, psGrid=grid)
boot &lt;- bootRiskCurve(formula=Y ~ S, bsm="Sb", tx="Z", data=data,
                      psGrid=grid, iter=2, seed=10)
summary(out, boot, contrast="te")

</code></pre>

<hr>
<h2 id='testConstancy'>Testing of the Null Hypotheses of a Flat and a Constant Marginal Causal Effect Predictiveness Curve</h2><span id='topic+testConstancy'></span>

<h3>Description</h3>

<p>Computes a two-sided p-value either from the test of {<code class="reqn">H_0^1: mCEP(s_1)=CE</code> for all <code class="reqn">s_1</code>}, where <code class="reqn">CE</code> is the overall causal treatment effect on the clinical
endpoint, or from the test of {<code class="reqn">H_0^2: mCEP(s_1)=c</code> for all <code class="reqn">s_1</code> in the interval <code>limS1</code> and a specified constant <code class="reqn">c</code>}, each against a general alternative
hypothesis. The testing procedures are described in Juraska, Huang, and Gilbert (2018) and are based on the simultaneous estimation method of Roy and Bose (1953).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testConstancy(
  object,
  boot,
  contrast = c("te", "rr", "logrr", "rd"),
  null = c("H01", "H02"),
  overallPlaRisk = NULL,
  overallTxRisk = NULL,
  MCEPconstantH02 = NULL,
  limS1 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testConstancy_+3A_object">object</code></td>
<td>
<p>an object returned by <code><a href="#topic+riskCurve">riskCurve</a></code></p>
</td></tr>
<tr><td><code id="testConstancy_+3A_boot">boot</code></td>
<td>
<p>an object returned by <code><a href="#topic+bootRiskCurve">bootRiskCurve</a></code></p>
</td></tr>
<tr><td><code id="testConstancy_+3A_contrast">contrast</code></td>
<td>
<p>a character string specifying the mCEP curve. It must be one of <code>te</code> (treatment efficacy), <code>rr</code> (relative risk), <code>logrr</code>
(log relative risk), and <code>rd</code> (risk difference [placebo minus treatment]).</p>
</td></tr>
<tr><td><code id="testConstancy_+3A_null">null</code></td>
<td>
<p>a character string specifying the null hypothesis to be tested; one of <code>H01</code> and <code>H02</code> as introduced above</p>
</td></tr>
<tr><td><code id="testConstancy_+3A_overallplarisk">overallPlaRisk</code></td>
<td>
<p>a numeric value of the estimated overall clinical endpoint risk in the placebo group. It is required when <code>null</code> equals <code>H01</code>.</p>
</td></tr>
<tr><td><code id="testConstancy_+3A_overalltxrisk">overallTxRisk</code></td>
<td>
<p>a numeric value of the estimated overall clinical endpoint risk in the treatment group. It is required when <code>null</code> equals <code>H01</code>.</p>
</td></tr>
<tr><td><code id="testConstancy_+3A_mcepconstanth02">MCEPconstantH02</code></td>
<td>
<p>the constant <code class="reqn">c</code> in the null hypothesis <code class="reqn">H_0^2</code>. It is required when <code>null</code> equals <code>H02</code>.</p>
</td></tr>
<tr><td><code id="testConstancy_+3A_lims1">limS1</code></td>
<td>
<p>a numeric vector of length 2 specifying an interval that is a subset of the support of <code class="reqn">S(1)</code> and that is used in the evaluation of the null hypothesis
<code class="reqn">H_0^2</code>. If <code>NULL</code> (default), then <code class="reqn">H_0^2</code> is evaluated for all <code class="reqn">s_1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the two-sided p-value from the test of either <code class="reqn">H_0^1</code> or <code class="reqn">H_0^2</code>.
</p>


<h3>References</h3>

<p>Juraska, M., Huang, Y., and Gilbert, P. B. (2020), Inference on treatment effect modification by biomarker response in a three-phase sampling design, Biostatistics, 21(3): 545-560, <a href="https://doi.org/10.1093/biostatistics/kxy074">https://doi.org/10.1093/biostatistics/kxy074</a>.
</p>
<p>Roy, S. N. and Bose, R. C. (1953), Simultaneous condence interval estimation, <em>The Annals of Mathematical Statistics</em>, 24, 513-536.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+riskCurve">riskCurve</a></code>, <code><a href="#topic+bootRiskCurve">bootRiskCurve</a></code> and <code><a href="#topic+testEquality">testEquality</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
Z &lt;- rep(0:1, each=n/2)
S &lt;- MASS::mvrnorm(n, mu=c(2,2,3), Sigma=matrix(c(1,0.9,0.7,0.9,1,0.7,0.7,0.7,1), nrow=3))
p &lt;- pnorm(drop(cbind(1,Z,(1-Z)*S[,2],Z*S[,3]) %*% c(-1.2,0.2,-0.02,-0.2)))
Y &lt;- sapply(p, function(risk){ rbinom(1,1,risk) })
X &lt;- rbinom(n,1,0.5)
# delete S(1) in placebo recipients
S[Z==0,3] &lt;- NA
# delete S(0) in treatment recipients
S[Z==1,2] &lt;- NA
# generate the indicator of being sampled into the phase 2 subset
phase2 &lt;- rbinom(n,1,0.4)
# delete Sb, S(0) and S(1) in controls not included in the phase 2 subset
S[Y==0 &amp; phase2==0,] &lt;- c(NA,NA,NA)
# delete Sb in cases not included in the phase 2 subset
S[Y==1 &amp; phase2==0,1] &lt;- NA
data &lt;- data.frame(X,Z,S[,1],ifelse(Z==0,S[,2],S[,3]),Y)
colnames(data) &lt;- c("X","Z","Sb","S","Y")
qS &lt;- quantile(data$S, probs=c(0.05,0.95), na.rm=TRUE)
grid &lt;- seq(qS[1], qS[2], length.out=3)

out &lt;- riskCurve(formula=Y ~ S + factor(X), bsm="Sb", tx="Z", data=data, psGrid=grid)
boot &lt;- bootRiskCurve(formula=Y ~ S + factor(X), bsm="Sb", tx="Z", data=data,
                      psGrid=grid, iter=2, seed=10)
fit &lt;- glm(Y ~ Z, data=data, family=binomial)
prob &lt;- predict(fit, newdata=data.frame(Z=0:1), type="response")

testConstancy(out, boot, contrast="te", null="H01", overallPlaRisk=prob[1],
              overallTxRisk=prob[2])
testConstancy(out, boot, contrast="te", null="H02", MCEPconstantH02=0, limS1=c(qS[1],1.5))


</code></pre>

<hr>
<h2 id='testEquality'>Testing of the Null Hypothesis of Equal Marginal Causal Effect Predictiveness Curves for Two Biomarkers, Endpoints, or Baseline Covariate Subgroups</h2><span id='topic+testEquality'></span>

<h3>Description</h3>

<p>Computes a two-sided p-value either from the test of {<code class="reqn">H_0^3: mCEP_1(s_1)=mCEP_2(s_1)</code> for all <code class="reqn">s_1</code> in <code>limS1</code>}, where <code class="reqn">mCEP_1</code> and <code class="reqn">mCEP_2</code> are
each associated with either a different biomarker (measured in the same units) or a different endpoint or both, or from the test of {<code class="reqn">H_0^4: mCEP(s_1|X=0)=
mCEP(s_1|X=1)</code> for all <code class="reqn">s_1</code> in <code>limS1</code>}, where <code class="reqn">X</code> is a baseline dichotomous phase 1 covariate of interest, each against a general alternative
hypothesis. The testing procedures are described in Juraska, Huang, and Gilbert (2018) and are based on the simultaneous estimation method of Roy and Bose (1953).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testEquality(
  object1,
  object2,
  boot1,
  boot2,
  contrast = c("te", "rr", "logrr", "rd"),
  null = c("H03", "H04"),
  limS1 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testEquality_+3A_object1">object1</code></td>
<td>
<p>an object returned by <code><a href="#topic+riskCurve">riskCurve</a></code> pertaining to either <code class="reqn">mCEP_1(s_1)</code> in <code class="reqn">H_0^3</code> or <code class="reqn">mCEP(s1|X=0)</code> in <code class="reqn">H_0^4</code></p>
</td></tr>
<tr><td><code id="testEquality_+3A_object2">object2</code></td>
<td>
<p>an object returned by <code><a href="#topic+riskCurve">riskCurve</a></code> pertaining to either <code class="reqn">mCEP_2(s_1)</code> in <code class="reqn">H_0^3</code> or <code class="reqn">mCEP(s1|X=1)</code> in <code class="reqn">H_0^4</code></p>
</td></tr>
<tr><td><code id="testEquality_+3A_boot1">boot1</code></td>
<td>
<p>an object returned by <code><a href="#topic+bootRiskCurve">bootRiskCurve</a></code> pertaining to either <code class="reqn">mCEP_1(s_1)</code> in <code class="reqn">H_0^3</code> or <code class="reqn">mCEP(s1|X=0)</code> in <code class="reqn">H_0^4</code></p>
</td></tr>
<tr><td><code id="testEquality_+3A_boot2">boot2</code></td>
<td>
<p>an object returned by <code><a href="#topic+bootRiskCurve">bootRiskCurve</a></code> pertaining to either <code class="reqn">mCEP_2(s_1)</code> in <code class="reqn">H_0^3</code> or <code class="reqn">mCEP(s1|X=1)</code> in <code class="reqn">H_0^4</code></p>
</td></tr>
<tr><td><code id="testEquality_+3A_contrast">contrast</code></td>
<td>
<p>a character string specifying the mCEP curve. It must be one of <code>te</code> (treatment efficacy), <code>rr</code> (relative risk), <code>logrr</code>
(log relative risk), and <code>rd</code> (risk difference [placebo minus treatment]).</p>
</td></tr>
<tr><td><code id="testEquality_+3A_null">null</code></td>
<td>
<p>a character string specifying the null hypothesis to be tested; one of <code>H03</code> and <code>H04</code> as introduced above</p>
</td></tr>
<tr><td><code id="testEquality_+3A_lims1">limS1</code></td>
<td>
<p>a numeric vector of length 2 specifying an interval that is a subset of the support of <code class="reqn">S(1)</code>. If <code>NULL</code> (default), then the specified null
hypothesis is evaluated for all <code class="reqn">s_1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the two-sided p-value from the test of either <code class="reqn">H_0^3</code> or <code class="reqn">H_0^4</code>.
</p>


<h3>References</h3>

<p>Juraska, M., Huang, Y., and Gilbert, P. B. (2020), Inference on treatment effect modification by biomarker response in a three-phase sampling design, Biostatistics, 21(3): 545-560, <a href="https://doi.org/10.1093/biostatistics/kxy074">https://doi.org/10.1093/biostatistics/kxy074</a>.
</p>
<p>Roy, S. N. and Bose, R. C. (1953), Simultaneous condence interval estimation, <em>The Annals of Mathematical Statistics</em>, 24, 513-536.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+riskCurve">riskCurve</a></code>, <code><a href="#topic+bootRiskCurve">bootRiskCurve</a></code> and <code><a href="#topic+testConstancy">testConstancy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
Z &lt;- rep(0:1, each=n/2)
S &lt;- MASS::mvrnorm(n, mu=c(2,2,3), Sigma=matrix(c(1,0.9,0.7,0.9,1,0.7,0.7,0.7,1), nrow=3))
p &lt;- pnorm(drop(cbind(1,Z,(1-Z)*S[,2],Z*S[,3]) %*% c(-1.2,0.2,-0.02,-0.2)))
Y &lt;- sapply(p, function(risk){ rbinom(1,1,risk) })
X &lt;- rbinom(n,1,0.5)
# delete S(1) in placebo recipients
S[Z==0,3] &lt;- NA
# delete S(0) in treatment recipients
S[Z==1,2] &lt;- NA
# generate the indicator of being sampled into the phase 2 subset
phase2 &lt;- rbinom(n,1,0.4)
# delete Sb, S(0) and S(1) in controls not included in the phase 2 subset
S[Y==0 &amp; phase2==0,] &lt;- c(NA,NA,NA)
# delete Sb in cases not included in the phase 2 subset
S[Y==1 &amp; phase2==0,1] &lt;- NA
data &lt;- data.frame(X,Z,S[,1],ifelse(Z==0,S[,2],S[,3]),Y)
colnames(data) &lt;- c("X","Z","Sb","S","Y")
qS &lt;- quantile(data$S, probs=c(0.05,0.95), na.rm=TRUE)
grid &lt;- seq(qS[1], qS[2], length.out=3)
out0 &lt;- riskCurve(formula=Y ~ S, bsm="Sb", tx="Z", data=data[data$X==0,], psGrid=grid)
out1 &lt;- riskCurve(formula=Y ~ S, bsm="Sb", tx="Z", data=data[data$X==1,], psGrid=grid)
boot0 &lt;- bootRiskCurve(formula=Y ~ S, bsm="Sb", tx="Z", data=data[data$X==0,],
                       psGrid=grid, iter=2, seed=10)
boot1 &lt;- bootRiskCurve(formula=Y ~ S, bsm="Sb", tx="Z", data=data[data$X==1,],
                       psGrid=grid, iter=2, seed=15)

testEquality(out0, out1, boot0, boot1, contrast="te", null="H04")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
