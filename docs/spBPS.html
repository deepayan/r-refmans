<!DOCTYPE html><html lang="en"><head><title>Help for package spBPS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spBPS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#spBPS-package'><p>spBPS: Bayesian Predictive Stacking for Scalable Geospatial Transfer Learning</p></a></li>
<li><a href='#arma_dist'><p>Compute the Euclidean distance matrix</p></a></li>
<li><a href='#bayesMvLMconjugate'><p>Gibbs sampler for Conjugate Bayesian Multivariate Linear Models</p></a></li>
<li><a href='#BPS_combine'><p>Combine subset models wiht BPS</p></a></li>
<li><a href='#BPS_post'><p>Perform the BPS sampling from posterior and posterior predictive given a set of stacking weights</p></a></li>
<li><a href='#BPS_post_MvT'><p>Perform the BPS sampling from posterior and posterior predictive given a set of stacking weights</p></a></li>
<li><a href='#BPS_postdraws'><p>Compute the BPS posterior samples given a set of stacking weights</p></a></li>
<li><a href='#BPS_postdraws_MvT'><p>Compute the BPS posterior samples given a set of stacking weights</p></a></li>
<li><a href='#BPS_pred'><p>Compute the BPS spatial prediction given a set of stacking weights</p></a></li>
<li><a href='#BPS_pred_MvT'><p>Compute the BPS spatial prediction given a set of stacking weights</p></a></li>
<li><a href='#BPS_PseudoBMA'><p>Combine subset models wiht Pseudo-BMA</p></a></li>
<li><a href='#BPS_weights'><p>Compute the BPS weights by convex optimization</p></a></li>
<li><a href='#BPS_weights_MvT'><p>Compute the BPS weights by convex optimization</p></a></li>
<li><a href='#conv_opt'><p>Solver for Bayesian Predictive Stacking of Predictive densities convex optimization problem</p></a></li>
<li><a href='#CVXR_opt'><p>Compute the BPS weights by convex optimization</p></a></li>
<li><a href='#d_pred_cpp'><p>Evaluate the density of a set of unobserved response with respect to the conditional posterior predictive</p></a></li>
<li><a href='#d_pred_cpp_MvT'><p>Evaluate the density of a set of unobserved response with respect to the conditional posterior predictive</p></a></li>
<li><a href='#dens_kcv'><p>Compute the KCV of the density evaluations for fixed values of the hyperparameters</p></a></li>
<li><a href='#dens_kcv_MvT'><p>Compute the KCV of the density evaluations for fixed values of the hyperparameters</p></a></li>
<li><a href='#dens_loocv'><p>Compute the LOOCV of the density evaluations for fixed values of the hyperparameters</p></a></li>
<li><a href='#dens_loocv_MvT'><p>Compute the LOOCV of the density evaluations for fixed values of the hyperparameters</p></a></li>
<li><a href='#expand_grid_cpp'><p>Build a grid from two vector (i.e. equivalent to <code>expand.grid()</code> in <code>R</code>)</p></a></li>
<li><a href='#fit_cpp'><p>Compute the parameters for the posteriors distribution of <code class="reqn">\beta</code> and <code class="reqn">\Sigma</code> (i.e. updated parameters)</p></a></li>
<li><a href='#fit_cpp_MvT'><p>Compute the parameters for the posteriors distribution of <code class="reqn">\beta</code> and <code class="reqn">\Sigma</code> (i.e. updated parameters)</p></a></li>
<li><a href='#forceSymmetry_cpp'><p>Function to subset data for meta-analysis</p></a></li>
<li><a href='#models_dens'><p>Return the CV predictive density evaluations for all the model combinations</p></a></li>
<li><a href='#models_dens_MvT'><p>Return the CV predictive density evaluations for all the model combinations</p></a></li>
<li><a href='#post_draws'><p>Sample R draws from the posterior distributions</p></a></li>
<li><a href='#post_draws_MvT'><p>Sample R draws from the posterior distributions</p></a></li>
<li><a href='#pred_bayesMvLMconjugate'><p>Predictive sampler for Conjugate Bayesian Multivariate Linear Models</p></a></li>
<li><a href='#r_pred_cond'><p>Draw from the conditional posterior predictive for a set of unobserved covariates</p></a></li>
<li><a href='#r_pred_cond_MvT'><p>Draw from the conditional posterior predictive for a set of unobserved covariates</p></a></li>
<li><a href='#r_pred_joint'><p>Draw from the joint posterior predictive for a set of unobserved covariates</p></a></li>
<li><a href='#r_pred_joint_MvT'><p>Draw from the joint posterior predictive for a set of unobserved covariates</p></a></li>
<li><a href='#r_pred_marg'><p>Draw from the marginals posterior predictive for a set of unobserved covariates</p></a></li>
<li><a href='#r_pred_marg_MvT'><p>Draw from the joint posterior predictive for a set of unobserved covariates</p></a></li>
<li><a href='#sample_index'><p>Function to sample integers (index)</p></a></li>
<li><a href='#spPredict_BPS'><p>Perform prediction for BPS accelerated models - loop over prediction set</p></a></li>
<li><a href='#subset_data'><p>Function to subset data for meta-analysis</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Bayesian Predictive Stacking for Scalable Geospatial Transfer
Learning</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0-4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luca Presicce &lt;l.presicce@campus.unimib.it&gt;</td>
</tr>
<tr>
<td>Author:</td>
<td>Luca Presicce <a href="https://orcid.org/0009-0005-7062-3523"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Sudipto Banerjee [aut]</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for Bayesian Predictive Stacking within the Bayesian transfer learning framework for geospatial artificial systems, as introduced in "Bayesian Transfer Learning for Artificially Intelligent Geospatial Systems: A Predictive Stacking Approach" (Presicce and Banerjee, 2024) &lt;<a href="https://doi.org/10.48550%2FarXiv.2410.09504">doi:10.48550/arXiv.2410.09504</a>&gt;. This methodology enables efficient Bayesian geostatistical modeling, utilizing predictive stacking to improve inference across spatial datasets. The core functions leverage 'C++' for high-performance computation, making the framework well-suited for large-scale spatial data analysis in parallel and distributed computing environments. Designed for scalability, it allows seamless application in computationally demanding scenarios.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 1.8.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, CVXR, mniw</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, mvnfast, foreach, parallel, doParallel,
tictoc, MBA, RColorBrewer, classInt, sp, fields, testthat (&ge;
3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-24 16:20:38 UTC; presi</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-25 09:20:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='spBPS-package'>spBPS: Bayesian Predictive Stacking for Scalable Geospatial Transfer Learning</h2><span id='topic+spBPS'></span><span id='topic+spBPS-package'></span>

<h3>Description</h3>

<p>Provides functions for Bayesian Predictive Stacking within the Bayesian transfer learning framework for geospatial artificial systems, as introduced in &quot;Bayesian Transfer Learning for Artificially Intelligent Geospatial Systems: A Predictive Stacking Approach&quot; (Presicce and Banerjee, 2024) <a href="https://doi.org/10.48550/arXiv.2410.09504">doi:10.48550/arXiv.2410.09504</a>. This methodology enables efficient Bayesian geostatistical modeling, utilizing predictive stacking to improve inference across spatial datasets. The core functions leverage 'C++' for high-performance computation, making the framework well-suited for large-scale spatial data analysis in parallel and distributed computing environments. Designed for scalability, it allows seamless application in computationally demanding scenarios.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Luca Presicce <a href="mailto:l.presicce@campus.unimib.it">l.presicce@campus.unimib.it</a> (<a href="https://orcid.org/0009-0005-7062-3523">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Sudipto Banerjee
</p>
</li></ul>


<hr>
<h2 id='arma_dist'>Compute the Euclidean distance matrix</h2><span id='topic+arma_dist'></span>

<h3>Description</h3>

<p>Compute the Euclidean distance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arma_dist(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arma_dist_+3A_x">X</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> (tipically of <code class="reqn">N</code> coordindates on <code class="reqn">\mathbb{R}^2</code> )</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+matrix">matrix</a> distance matrix of the elements of <code class="reqn">X</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compute the Distance matrix of dimension (n x n)
n &lt;- 100
p &lt;- 2
X &lt;- matrix(runif(n*p), nrow = n, ncol = p)
distance.matrix &lt;- arma_dist(X)

</code></pre>

<hr>
<h2 id='bayesMvLMconjugate'>Gibbs sampler for Conjugate Bayesian Multivariate Linear Models</h2><span id='topic+bayesMvLMconjugate'></span>

<h3>Description</h3>

<p>Gibbs sampler for Conjugate Bayesian Multivariate Linear Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesMvLMconjugate(Y, X, mu_B, V_B, nu, Psi, n_iter = 1000, burn_in = 500)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayesMvLMconjugate_+3A_y">Y</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> <code class="reqn">n \times q</code> of response variables</p>
</td></tr>
<tr><td><code id="bayesMvLMconjugate_+3A_x">X</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> <code class="reqn">n \times p</code> of predictors</p>
</td></tr>
<tr><td><code id="bayesMvLMconjugate_+3A_mu_b">mu_B</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> <code class="reqn">p \times q</code> prior mean for <code class="reqn">\beta</code></p>
</td></tr>
<tr><td><code id="bayesMvLMconjugate_+3A_v_b">V_B</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> <code class="reqn">p \times p</code> prior row covariance for <code class="reqn">\beta</code></p>
</td></tr>
<tr><td><code id="bayesMvLMconjugate_+3A_nu">nu</code></td>
<td>
<p><a href="base.html#topic+double">double</a> prior parameter for <code class="reqn">\Sigma</code></p>
</td></tr>
<tr><td><code id="bayesMvLMconjugate_+3A_psi">Psi</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> prior parameter for <code class="reqn">\Sigma</code></p>
</td></tr>
<tr><td><code id="bayesMvLMconjugate_+3A_n_iter">n_iter</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> iteration number for Gibbs sampler</p>
</td></tr>
<tr><td><code id="bayesMvLMconjugate_+3A_burn_in">burn_in</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> number of burn-in iteration</p>
</td></tr>
</table>


<h3>Value</h3>

<p>B_samples <a href="base.html#topic+array">array</a> of posterior sample for <code class="reqn">\beta</code>
</p>
<p>Sigma_samples <a href="base.html#topic+array">array</a> of posterior samples for <code class="reqn">\Sigma</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate data
n &lt;- 100
p &lt;- 3
q &lt;- 2
Y &lt;- matrix(rnorm(n*q), nrow = n, ncol = q)
X &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)

## Prior parameters
mu_B &lt;- matrix(0, p, q)
V_B &lt;- diag(10, p)
nu &lt;- 3
Psi &lt;- diag(q)

## Samples from posteriors
n_iter &lt;- 1000
burn_in &lt;- 500
set.seed(1234)
samples &lt;- spBPS::bayesMvLMconjugate(Y, X, mu_B, V_B, nu, Psi, n_iter, burn_in)

</code></pre>

<hr>
<h2 id='BPS_combine'>Combine subset models wiht BPS</h2><span id='topic+BPS_combine'></span>

<h3>Description</h3>

<p>Combine subset models wiht BPS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BPS_combine(fit_list, K, rp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BPS_combine_+3A_fit_list">fit_list</code></td>
<td>
<p><a href="base.html#topic+list">list</a> K fitted model outputs composed by two elements each: first named <code class="reqn">epd</code>, second named <code class="reqn">W</code></p>
</td></tr>
<tr><td><code id="BPS_combine_+3A_k">K</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> number of folds</p>
</td></tr>
<tr><td><code id="BPS_combine_+3A_rp">rp</code></td>
<td>
<p><a href="base.html#topic+double">double</a> percentage of observations to take into account for optimization (<code>default=1</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+matrix">matrix</a> posterior predictive density evaluations (each columns represent a different model)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate subsets of data
n &lt;- 100
p &lt;- 3
X &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)
Y &lt;- matrix(rnorm(n), nrow = n, ncol = 1)
crd &lt;- matrix(runif(n*2), nrow = n, ncol = 2)
data_part &lt;- subset_data(data = list(Y = Y, X = X, crd = crd), K = 10)

## Select competitive set of values for hyperparameters
delta_seq &lt;- c(0.1, 0.2, 0.3)
phi_seq &lt;- c(3, 4, 5)

## Perform Bayesian Predictive Stacking within subsets
fit_list &lt;- vector(length = 10, mode = "list")
for (i in 1:10) {
    Yi &lt;- data_part$Y_list[[i]]
    Xi &lt;- data_part$X_list[[i]]
    crd_i &lt;- data_part$crd_list[[i]]
    p &lt;- ncol(Xi)
    bps &lt;- spBPS::BPS_weights(data = list(Y = Yi, X = Xi),
                               priors = list(mu_b = matrix(rep(0, p)),
                                             V_b = diag(10, p),
                                             a = 2,
                                             b = 2), coords = crd_i,
                                             hyperpar = list(delta = delta_seq,
                                                             phi = phi_seq),
                                             K = 5)
     w_hat &lt;- bps$W
     epd &lt;- bps$epd
     fit_list[[i]] &lt;- list(epd, w_hat) }

## Combination weights between partitions using Bayesian Predictive Stacking
comb_bps &lt;- BPS_combine(fit_list = fit_list, K = 10, rp = 1)


</code></pre>

<hr>
<h2 id='BPS_post'>Perform the BPS sampling from posterior and posterior predictive given a set of stacking weights</h2><span id='topic+BPS_post'></span>

<h3>Description</h3>

<p>Perform the BPS sampling from posterior and posterior predictive given a set of stacking weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BPS_post(data, X_u, priors, coords, crd_u, hyperpar, W, R)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BPS_post_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elements: first named <code class="reqn">Y</code>, second named <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="BPS_post_+3A_x_u">X_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unobserved instances covariate matrix</p>
</td></tr>
<tr><td><code id="BPS_post_+3A_priors">priors</code></td>
<td>
<p><a href="base.html#topic+list">list</a> priors: named <code class="reqn">\mu_b</code>,<code class="reqn">V_b</code>,<code class="reqn">a</code>,<code class="reqn">b</code></p>
</td></tr>
<tr><td><code id="BPS_post_+3A_coords">coords</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> sample coordinates for X and Y</p>
</td></tr>
<tr><td><code id="BPS_post_+3A_crd_u">crd_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unboserved instances coordinates</p>
</td></tr>
<tr><td><code id="BPS_post_+3A_hyperpar">hyperpar</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elemets: first named <code class="reqn">\delta</code>, second named <code class="reqn">\phi</code></p>
</td></tr>
<tr><td><code id="BPS_post_+3A_w">W</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> set of stacking weights</p>
</td></tr>
<tr><td><code id="BPS_post_+3A_r">R</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> number of desired samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+list">list</a> BPS posterior predictive samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate subsets of data
n &lt;- 100
p &lt;- 3
X &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)
Y &lt;- matrix(rnorm(n), nrow = n, ncol = 1)
crd &lt;- matrix(runif(n*2), nrow = n, ncol = 2)
data_part &lt;- subset_data(data = list(Y = Y, X = X, crd = crd), K = 10)

## Select competetive set of values for hyperparameters
delta_seq &lt;- c(0.1, 0.2, 0.3)
phi_seq &lt;- c(3, 4, 5)
## Fit local models
fit_list &lt;- vector(length = 10, mode = "list")
for (i in 1:10) {
  Yi &lt;- data_part$Y_list[[i]]
  Xi &lt;- data_part$X_list[[i]]
  crd_i &lt;- data_part$crd_list[[i]]
  p &lt;- ncol(Xi)
  bps &lt;- spBPS::BPS_weights(data = list(Y = Yi, X = Xi),
                           priors = list(mu_b = matrix(rep(0, p)),
                                         V_b = diag(10, p),
                                         a = 2,
                                         b = 2), coords = crd_i,
                                         hyperpar = list(delta = delta_seq,
                                                         phi = phi_seq),
                                                         K = 5)
  w_hat &lt;- bps$W
  epd &lt;- bps$epd
  fit_list[[i]] &lt;- list(epd, w_hat) }

## Model combination weights between partitions using Bayesian Predictive Stacking
comb_bps &lt;- BPS_combine(fit_list = fit_list, K = 10, rp = 1)
Wbps &lt;- comb_bps$W
W_list &lt;- comb_bps$W_list

## Generate prediction points
m &lt;- 100
X_new &lt;- matrix(rnorm(m*p), nrow = m, ncol = p)
crd_new &lt;- matrix(runif(m*2), nrow = m, ncol = 2)

## Perform posterior and posterior predictive sampling
R &lt;- 250
subset_ind &lt;- sample(1:10, R, TRUE, Wbps)
postsmp_and_pred &lt;- vector(length = R, mode = "list")
for (r in 1:R) {
 ind_s &lt;- subset_ind[r]
 Ys &lt;- matrix(data_part$Y_list[[ind_s]])
 Xs &lt;- data_part$X_list[[ind_s]]
 crds &lt;- data_part$crd_list[[ind_s]]
 Ws &lt;- W_list[[ind_s]]
 result &lt;- spBPS::BPS_post(data = list(Y = Ys, X = Xs), coords = crds,
                           X_u = X_new, crd_u = crd_new,
                           priors = list(mu_b = matrix(rep(0, p)),
                                         V_b = diag(10, p),
                                         a = 2,
                                         b = 2),
                                         hyperpar = list(delta = delta_seq,
                                                         phi = phi_seq),
                                                         W = Ws, R = 1)
 postsmp_and_pred[[r]] &lt;- result}



</code></pre>

<hr>
<h2 id='BPS_post_MvT'>Perform the BPS sampling from posterior and posterior predictive given a set of stacking weights</h2><span id='topic+BPS_post_MvT'></span>

<h3>Description</h3>

<p>Perform the BPS sampling from posterior and posterior predictive given a set of stacking weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BPS_post_MvT(data, X_u, priors, coords, crd_u, hyperpar, W, R)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BPS_post_MvT_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elements: first named <code class="reqn">Y</code>, second named <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="BPS_post_MvT_+3A_x_u">X_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unobserved instances covariate matrix</p>
</td></tr>
<tr><td><code id="BPS_post_MvT_+3A_priors">priors</code></td>
<td>
<p><a href="base.html#topic+list">list</a> priors: named <code class="reqn">\mu_B</code>,<code class="reqn">V_r</code>,<code class="reqn">\Psi</code>,<code class="reqn">\nu</code></p>
</td></tr>
<tr><td><code id="BPS_post_MvT_+3A_coords">coords</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> sample coordinates for X and Y</p>
</td></tr>
<tr><td><code id="BPS_post_MvT_+3A_crd_u">crd_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unboserved instances coordinates</p>
</td></tr>
<tr><td><code id="BPS_post_MvT_+3A_hyperpar">hyperpar</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elemets: first named <code class="reqn">\alpha</code>, second named <code class="reqn">\phi</code></p>
</td></tr>
<tr><td><code id="BPS_post_MvT_+3A_w">W</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> set of stacking weights</p>
</td></tr>
<tr><td><code id="BPS_post_MvT_+3A_r">R</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> number of desired samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+list">list</a> BPS posterior predictive samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate subsets of data
n &lt;- 100
p &lt;- 3
q &lt;- 2
X &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)
Y &lt;- matrix(rnorm(n*q), nrow = n, ncol = q)
crd &lt;- matrix(runif(n*2), nrow = n, ncol = 2)
data_part &lt;- subset_data(data = list(Y = Y, X = X, crd = crd), K = 10)

## Select competitive set of values for hyperparameters
alfa_seq &lt;- c(0.7, 0.8, 0.9)
phi_seq &lt;- c(3, 4, 5)

## Fit local models
fit_list &lt;- vector(length = 10, mode = "list")
for (i in 1:10) {
    Yi &lt;- data_part$Y_list[[i]]
    Xi &lt;- data_part$X_list[[i]]
    crd_i &lt;- data_part$crd_list[[i]]
    bps &lt;- spBPS::BPS_weights_MvT(data = list(Y = Yi, X = Xi),
                              priors = list(mu_B = matrix(0, nrow = p, ncol = q),
                                            V_r = diag(10, p),
                                            Psi = diag(1, q),
                                            nu = 3), coords = crd_i,
                                            hyperpar = list(alpha = alfa_seq,
                                                            phi = phi_seq),
                                            K = 5)
     w_hat &lt;- bps$W
     epd &lt;- bps$epd
     fit_list[[i]] &lt;- list(epd, w_hat) }

## Model combination weights between partitions using Bayesian Predictive Stacking
comb_bps &lt;- BPS_combine(fit_list = fit_list, K = 10, rp = 1)
Wbps &lt;- comb_bps$W
W_list &lt;- comb_bps$W_list

## Generate prediction points
m &lt;- 100
X_new &lt;- matrix(rnorm(m*p), nrow = m, ncol = p)
crd_new &lt;- matrix(runif(m*2), nrow = m, ncol = 2)

## Perform posterior and posterior predictive sampling
R &lt;- 250
subset_ind &lt;- sample(1:10, R, TRUE, Wbps)
postsmp_and_pred &lt;- vector(length = R, mode = "list")
for (r in 1:R) {
  ind_s &lt;- subset_ind[r]
  Ys &lt;- data_part$Y_list[[ind_s]]
  Xs &lt;- data_part$X_list[[ind_s]]
  crds &lt;- data_part$crd_list[[ind_s]]
  Ws &lt;- W_list[[ind_s]]
  result &lt;- spBPS::BPS_post_MvT(data = list(Y = Ys, X = Xs), coords = crds,
                                X_u = X_new, crd_u = crd_new,
                                priors = list(mu_B = matrix(0, nrow = p, ncol = q),
                                              V_r = diag(10, p),
                                              Psi = diag(1, q),
                                              nu = 3),
                                              hyperpar = list(alpha = alfa_seq,
                                                              phi = phi_seq),
                                              W = Ws, R = 1)

  postsmp_and_pred[[r]] &lt;- result}



</code></pre>

<hr>
<h2 id='BPS_postdraws'>Compute the BPS posterior samples given a set of stacking weights</h2><span id='topic+BPS_postdraws'></span>

<h3>Description</h3>

<p>Compute the BPS posterior samples given a set of stacking weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BPS_postdraws(data, priors, coords, hyperpar, W, R)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BPS_postdraws_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elements: first named <code class="reqn">Y</code>, second named <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="BPS_postdraws_+3A_priors">priors</code></td>
<td>
<p><a href="base.html#topic+list">list</a> priors: named <code class="reqn">\mu_b</code>,<code class="reqn">V_b</code>,<code class="reqn">a</code>,<code class="reqn">b</code></p>
</td></tr>
<tr><td><code id="BPS_postdraws_+3A_coords">coords</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> sample coordinates for X and Y</p>
</td></tr>
<tr><td><code id="BPS_postdraws_+3A_hyperpar">hyperpar</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elemets: first named <code class="reqn">\delta</code>, second named <code class="reqn">\phi</code></p>
</td></tr>
<tr><td><code id="BPS_postdraws_+3A_w">W</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> set of stacking weights</p>
</td></tr>
<tr><td><code id="BPS_postdraws_+3A_r">R</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> number of desired samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+matrix">matrix</a> BPS posterior samples
</p>

<hr>
<h2 id='BPS_postdraws_MvT'>Compute the BPS posterior samples given a set of stacking weights</h2><span id='topic+BPS_postdraws_MvT'></span>

<h3>Description</h3>

<p>Compute the BPS posterior samples given a set of stacking weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BPS_postdraws_MvT(data, priors, coords, hyperpar, W, R, par)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BPS_postdraws_MvT_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elements: first named <code class="reqn">Y</code>, second named <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="BPS_postdraws_MvT_+3A_priors">priors</code></td>
<td>
<p><a href="base.html#topic+list">list</a> priors: named <code class="reqn">\mu_B</code>,<code class="reqn">V_r</code>,<code class="reqn">\Psi</code>,<code class="reqn">\nu</code></p>
</td></tr>
<tr><td><code id="BPS_postdraws_MvT_+3A_coords">coords</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> sample coordinates for X and Y</p>
</td></tr>
<tr><td><code id="BPS_postdraws_MvT_+3A_hyperpar">hyperpar</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elemets: first named <code class="reqn">\alpha</code>, second named <code class="reqn">\phi</code></p>
</td></tr>
<tr><td><code id="BPS_postdraws_MvT_+3A_w">W</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> set of stacking weights</p>
</td></tr>
<tr><td><code id="BPS_postdraws_MvT_+3A_r">R</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> number of desired samples</p>
</td></tr>
<tr><td><code id="BPS_postdraws_MvT_+3A_par">par</code></td>
<td>
<p>if <code>TRUE</code> only <code class="reqn">\beta</code> and <code class="reqn">\Sigma</code> are sampled (<code class="reqn">\omega</code> is omitted)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+matrix">matrix</a> BPS posterior samples
</p>

<hr>
<h2 id='BPS_pred'>Compute the BPS spatial prediction given a set of stacking weights</h2><span id='topic+BPS_pred'></span>

<h3>Description</h3>

<p>Compute the BPS spatial prediction given a set of stacking weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BPS_pred(data, X_u, priors, coords, crd_u, hyperpar, W, R)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BPS_pred_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elements: first named <code class="reqn">Y</code>, second named <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="BPS_pred_+3A_x_u">X_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unobserved instances covariate matrix</p>
</td></tr>
<tr><td><code id="BPS_pred_+3A_priors">priors</code></td>
<td>
<p><a href="base.html#topic+list">list</a> priors: named <code class="reqn">\mu_b</code>,<code class="reqn">V_b</code>,<code class="reqn">a</code>,<code class="reqn">b</code></p>
</td></tr>
<tr><td><code id="BPS_pred_+3A_coords">coords</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> sample coordinates for X and Y</p>
</td></tr>
<tr><td><code id="BPS_pred_+3A_crd_u">crd_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unboserved instances coordinates</p>
</td></tr>
<tr><td><code id="BPS_pred_+3A_hyperpar">hyperpar</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elemets: first named <code class="reqn">\delta</code>, second named <code class="reqn">\phi</code></p>
</td></tr>
<tr><td><code id="BPS_pred_+3A_w">W</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> set of stacking weights</p>
</td></tr>
<tr><td><code id="BPS_pred_+3A_r">R</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> number of desired samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+list">list</a> BPS posterior predictive samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate subsets of data
n &lt;- 100
p &lt;- 3
X &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)
Y &lt;- matrix(rnorm(n), nrow = n, ncol = 1)
crd &lt;- matrix(runif(n*2), nrow = n, ncol = 2)
data_part &lt;- subset_data(data = list(Y = Y, X = X, crd = crd), K = 10)

## Select competetive set of values for hyperparameters
delta_seq &lt;- c(0.1, 0.2, 0.3)
phi_seq &lt;- c(3, 4, 5)

## Fit local models
fit_list &lt;- vector(length = 10, mode = "list")
for (i in 1:10) {
    Yi &lt;- data_part$Y_list[[i]]
    Xi &lt;- data_part$X_list[[i]]
    crd_i &lt;- data_part$crd_list[[i]]
    p &lt;- ncol(Xi)
    bps &lt;- spBPS::BPS_weights(data = list(Y = Yi, X = Xi),
                               priors = list(mu_b = matrix(rep(0, p)),
                                             V_b = diag(10, p),
                                             a = 2,
                                             b = 2), coords = crd_i,
                                             hyperpar = list(delta = delta_seq,
                                                             phi = phi_seq),
                                             K = 5)
     w_hat &lt;- bps$W
     epd &lt;- bps$epd
     fit_list[[i]] &lt;- list(epd, w_hat) }

## Model combination weights between partitions using Bayesian Predictive Stacking
comb_bps &lt;- BPS_combine(fit_list = fit_list, K = 10, rp = 1)
Wbps &lt;- comb_bps$W
W_list &lt;- comb_bps$W_list

## Generate prediction points
m &lt;- 50
X_new &lt;- matrix(rnorm(m*p), nrow = m, ncol = p)
crd_new &lt;- matrix(runif(m*2), nrow = m, ncol = 2)

## Perform posterior predictive sampling
R &lt;- 250
subset_ind &lt;- sample(1:10, R, TRUE, Wbps)
predictions &lt;- vector(length = R, mode = "list")
for (r in 1:R) {
  ind_s &lt;- subset_ind[r]
  Ys &lt;- matrix(data_part$Y_list[[ind_s]])
  Xs &lt;- data_part$X_list[[ind_s]]
  crds &lt;- data_part$crd_list[[ind_s]]
  Ws &lt;- W_list[[ind_s]]
  result &lt;- spBPS::BPS_pred(data = list(Y = Ys, X = Xs), coords = crds,
                            X_u = X_new, crd_u = crd_new,
                            priors = list(mu_b = matrix(rep(0, p)),
                                          V_b = diag(10, p),
                                          a = 2,
                                          b = 2),
                                          hyperpar = list(delta = delta_seq,
                                                          phi = phi_seq),
                                          W = Ws, R = 1)

  predictions[[r]] &lt;- result}



</code></pre>

<hr>
<h2 id='BPS_pred_MvT'>Compute the BPS spatial prediction given a set of stacking weights</h2><span id='topic+BPS_pred_MvT'></span>

<h3>Description</h3>

<p>Compute the BPS spatial prediction given a set of stacking weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BPS_pred_MvT(data, X_u, priors, coords, crd_u, hyperpar, W, R)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BPS_pred_MvT_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elements: first named <code class="reqn">Y</code>, second named <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="BPS_pred_MvT_+3A_x_u">X_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unobserved instances covariate matrix</p>
</td></tr>
<tr><td><code id="BPS_pred_MvT_+3A_priors">priors</code></td>
<td>
<p><a href="base.html#topic+list">list</a> priors: named <code class="reqn">\mu_B</code>,<code class="reqn">V_r</code>,<code class="reqn">\Psi</code>,<code class="reqn">\nu</code></p>
</td></tr>
<tr><td><code id="BPS_pred_MvT_+3A_coords">coords</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> sample coordinates for X and Y</p>
</td></tr>
<tr><td><code id="BPS_pred_MvT_+3A_crd_u">crd_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unboserved instances coordinates</p>
</td></tr>
<tr><td><code id="BPS_pred_MvT_+3A_hyperpar">hyperpar</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elemets: first named <code class="reqn">\alpha</code>, second named <code class="reqn">\phi</code></p>
</td></tr>
<tr><td><code id="BPS_pred_MvT_+3A_w">W</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> set of stacking weights</p>
</td></tr>
<tr><td><code id="BPS_pred_MvT_+3A_r">R</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> number of desired samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+list">list</a> BPS posterior predictive samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate subsets of data
n &lt;- 100
p &lt;- 3
q &lt;- 2
X &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)
Y &lt;- matrix(rnorm(n*q), nrow = n, ncol = q)
crd &lt;- matrix(runif(n*2), nrow = n, ncol = 2)
data_part &lt;- subset_data(data = list(Y = Y, X = X, crd = crd), K = 10)

## Select competitive set of values for hyperparameters
alfa_seq &lt;- c(0.7, 0.8, 0.9)
phi_seq &lt;- c(3, 4, 5)

## Fit local models
fit_list &lt;- vector(length = 10, mode = "list")
for (i in 1:10) {
    Yi &lt;- data_part$Y_list[[i]]
    Xi &lt;- data_part$X_list[[i]]
    crd_i &lt;- data_part$crd_list[[i]]
    bps &lt;- spBPS::BPS_weights_MvT(data = list(Y = Yi, X = Xi),
                              priors = list(mu_B = matrix(0, nrow = p, ncol = q),
                                            V_r = diag(10, p),
                                            Psi = diag(1, q),
                                            nu = 3), coords = crd_i,
                                            hyperpar = list(alpha = alfa_seq,
                                                            phi = phi_seq),
                                            K = 5)
     w_hat &lt;- bps$W
     epd &lt;- bps$epd
     fit_list[[i]] &lt;- list(epd, w_hat) }

## Model combination weights between partitions using Bayesian Predictive Stacking
comb_bps &lt;- BPS_combine(fit_list = fit_list, K = 10, rp = 1)
Wbps &lt;- comb_bps$W
W_list &lt;- comb_bps$W_list

## Generate prediction points
m &lt;- 100
X_new &lt;- matrix(rnorm(m*p), nrow = m, ncol = p)
crd_new &lt;- matrix(runif(m*2), nrow = m, ncol = 2)

## Perform posterior predictive sampling
R &lt;- 250
subset_ind &lt;- sample(1:10, R, TRUE, Wbps)
predictions &lt;- vector(length = R, mode = "list")
for (r in 1:R) {
  ind_s &lt;- subset_ind[r]
  Ys &lt;- data_part$Y_list[[ind_s]]
  Xs &lt;- data_part$X_list[[ind_s]]
  crds &lt;- data_part$crd_list[[ind_s]]
  Ws &lt;- W_list[[ind_s]]
  result &lt;- spBPS::BPS_pred_MvT(data = list(Y = Ys, X = Xs), coords = crds,
                                X_u = X_new, crd_u = crd_new,
                                priors = list(mu_B = matrix(0, nrow = p, ncol = q),
                                              V_r = diag(10, p),
                                              Psi = diag(1, q),
                                              nu = 3),
                                              hyperpar = list(alpha = alfa_seq,
                                                              phi = phi_seq),
                                              W = Ws, R = 1)

  predictions[[r]] &lt;- result}



</code></pre>

<hr>
<h2 id='BPS_PseudoBMA'>Combine subset models wiht Pseudo-BMA</h2><span id='topic+BPS_PseudoBMA'></span>

<h3>Description</h3>

<p>Combine subset models wiht Pseudo-BMA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BPS_PseudoBMA(fit_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BPS_PseudoBMA_+3A_fit_list">fit_list</code></td>
<td>
<p><a href="base.html#topic+list">list</a> K fitted model outputs composed by two elements each: first named <code class="reqn">epd</code>, second named <code class="reqn">W</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+matrix">matrix</a> posterior predictive density evaluations (each columns represent a different model)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate subsets of data
n &lt;- 100
p &lt;- 3
X &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)
Y &lt;- matrix(rnorm(n), nrow = n, ncol = 1)
crd &lt;- matrix(runif(n*2), nrow = n, ncol = 2)
data_part &lt;- subset_data(data = list(Y = Y, X = X, crd = crd), K = 10)

## Select competitive set of values for hyperparameters
delta_seq &lt;- c(0.1, 0.2, 0.3)
phi_seq &lt;- c(3, 4, 5)

## Perform Bayesian Predictive Stacking within subsets
fit_list &lt;- vector(length = 10, mode = "list")
for (i in 1:10) {
    Yi &lt;- data_part$Y_list[[i]]
    Xi &lt;- data_part$X_list[[i]]
    crd_i &lt;- data_part$crd_list[[i]]
    p &lt;- ncol(Xi)
    bps &lt;- spBPS::BPS_weights(data = list(Y = Yi, X = Xi),
                               priors = list(mu_b = matrix(rep(0, p)),
                                             V_b = diag(10, p),
                                             a = 2,
                                             b = 2), coords = crd_i,
                                             hyperpar = list(delta = delta_seq,
                                                             phi = phi_seq),
                                             K = 5)
     w_hat &lt;- bps$W
     epd &lt;- bps$epd
     fit_list[[i]] &lt;- list(epd, w_hat) }

## Combination weights between partitions using Pseudo Bayesian Model Averaging
comb_bps &lt;- BPS_PseudoBMA(fit_list = fit_list)


</code></pre>

<hr>
<h2 id='BPS_weights'>Compute the BPS weights by convex optimization</h2><span id='topic+BPS_weights'></span>

<h3>Description</h3>

<p>Compute the BPS weights by convex optimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BPS_weights(data, priors, coords, hyperpar, K)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BPS_weights_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elements: first named <code class="reqn">Y</code>, second named <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="BPS_weights_+3A_priors">priors</code></td>
<td>
<p><a href="base.html#topic+list">list</a> priors: named <code class="reqn">\mu_b</code>,<code class="reqn">V_b</code>,<code class="reqn">a</code>,<code class="reqn">b</code></p>
</td></tr>
<tr><td><code id="BPS_weights_+3A_coords">coords</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> sample coordinates for X and Y</p>
</td></tr>
<tr><td><code id="BPS_weights_+3A_hyperpar">hyperpar</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elemets: first named <code class="reqn">\delta</code>, second named <code class="reqn">\phi</code></p>
</td></tr>
<tr><td><code id="BPS_weights_+3A_k">K</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> number of folds</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+matrix">matrix</a> posterior predictive density evaluations (each columns represent a different model)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate subsets of data
n &lt;- 100
p &lt;- 3
X &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)
Y &lt;- matrix(rnorm(n), nrow = n)
crd &lt;- matrix(runif(n*2), nrow = n, ncol = 2)

## Select competitive set of values for hyperparameters
delta_seq &lt;- c(0.1, 0.2, 0.3)
phi_seq &lt;- c(3, 4, 5)

## Perform Bayesian Predictive Stacking within subsets
bps &lt;- spBPS::BPS_weights(data = list(Y = Y, X = X),
                               priors = list(mu_b = matrix(rep(0, p)),
                                             V_b = diag(10, p),
                                             a = 2,
                                             b = 2), coords = crd,
                                             hyperpar = list(delta = delta_seq,
                                                             phi = phi_seq),
                                             K = 5)

</code></pre>

<hr>
<h2 id='BPS_weights_MvT'>Compute the BPS weights by convex optimization</h2><span id='topic+BPS_weights_MvT'></span>

<h3>Description</h3>

<p>Compute the BPS weights by convex optimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BPS_weights_MvT(data, priors, coords, hyperpar, K)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BPS_weights_MvT_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elements: first named <code class="reqn">Y</code>, second named <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="BPS_weights_MvT_+3A_priors">priors</code></td>
<td>
<p><a href="base.html#topic+list">list</a> priors: named <code class="reqn">\mu_B</code>,<code class="reqn">V_r</code>,<code class="reqn">\Psi</code>,<code class="reqn">\nu</code></p>
</td></tr>
<tr><td><code id="BPS_weights_MvT_+3A_coords">coords</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> sample coordinates for X and Y</p>
</td></tr>
<tr><td><code id="BPS_weights_MvT_+3A_hyperpar">hyperpar</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elemets: first named <code class="reqn">\alpha</code>, second named <code class="reqn">\phi</code></p>
</td></tr>
<tr><td><code id="BPS_weights_MvT_+3A_k">K</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> number of folds</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+matrix">matrix</a> posterior predictive density evaluations (each columns represent a different model)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate subsets of data
n &lt;- 100
p &lt;- 3
q &lt;- 2
X &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)
Y &lt;- matrix(rnorm(n*q), nrow = n, ncol = q)
crd &lt;- matrix(runif(n*2), nrow = n, ncol = 2)

## Select competitive set of values for hyperparameters
alfa_seq &lt;- c(0.7, 0.8, 0.9)
phi_seq &lt;- c(3, 4, 5)

## Perform Bayesian Predictive Stacking within subsets
bps &lt;- spBPS::BPS_weights_MvT(data = list(Y = Y, X = X),
                              priors = list(mu_B = matrix(0, nrow = p, ncol = q),
                                            V_r = diag(10, p),
                                            Psi = diag(1, q),
                                            nu = 3), coords = crd,
                                            hyperpar = list(alpha = alfa_seq,
                                                            phi = phi_seq),
                                            K = 5)


</code></pre>

<hr>
<h2 id='conv_opt'>Solver for Bayesian Predictive Stacking of Predictive densities convex optimization problem</h2><span id='topic+conv_opt'></span>

<h3>Description</h3>

<p>Solver for Bayesian Predictive Stacking of Predictive densities convex optimization problem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv_opt(scores)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conv_opt_+3A_scores">scores</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> <code class="reqn">N \times K</code> of expected predictive density evaluations for the K models considered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>W <a href="base.html#topic+matrix">matrix</a> of Bayesian Predictive Stacking weights for the K models considered
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate (randomly) K predictive scores for n observations
n &lt;- 50
K &lt;- 5
scores &lt;- matrix(runif(n*K), nrow = n, ncol = K)

## Find Bayesian Predictive Stacking weights
opt_weights &lt;- conv_opt(scores)

</code></pre>

<hr>
<h2 id='CVXR_opt'>Compute the BPS weights by convex optimization</h2><span id='topic+CVXR_opt'></span>

<h3>Description</h3>

<p>Compute the BPS weights by convex optimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CVXR_opt(scores)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CVXR_opt_+3A_scores">scores</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> <code class="reqn">N \times K</code> of expected predictive density evaluations for the K models considered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>conv_opt <a href="base.html#topic+function">function</a> to perform convex optimiazion with CVXR R package
</p>

<hr>
<h2 id='d_pred_cpp'>Evaluate the density of a set of unobserved response with respect to the conditional posterior predictive</h2><span id='topic+d_pred_cpp'></span>

<h3>Description</h3>

<p>Evaluate the density of a set of unobserved response with respect to the conditional posterior predictive
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_pred_cpp(data, X_u, Y_u, d_u, d_us, hyperpar, poster)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="d_pred_cpp_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elements: first named <code class="reqn">Y</code>, second named <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="d_pred_cpp_+3A_x_u">X_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unobserved instances covariate matrix</p>
</td></tr>
<tr><td><code id="d_pred_cpp_+3A_y_u">Y_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unobserved instances response matrix</p>
</td></tr>
<tr><td><code id="d_pred_cpp_+3A_d_u">d_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unobserved instances distance matrix</p>
</td></tr>
<tr><td><code id="d_pred_cpp_+3A_d_us">d_us</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> cross-distance between unobserved and observed instances matrix</p>
</td></tr>
<tr><td><code id="d_pred_cpp_+3A_hyperpar">hyperpar</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elemets: first named <code class="reqn">\delta</code>, second named <code class="reqn">\phi</code></p>
</td></tr>
<tr><td><code id="d_pred_cpp_+3A_poster">poster</code></td>
<td>
<p><a href="base.html#topic+list">list</a> output from <code>fit_cpp</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+vector">vector</a> posterior predictive density evaluations
</p>

<hr>
<h2 id='d_pred_cpp_MvT'>Evaluate the density of a set of unobserved response with respect to the conditional posterior predictive</h2><span id='topic+d_pred_cpp_MvT'></span>

<h3>Description</h3>

<p>Evaluate the density of a set of unobserved response with respect to the conditional posterior predictive
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_pred_cpp_MvT(data, X_u, Y_u, d_u, d_us, hyperpar, poster)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="d_pred_cpp_MvT_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elements: first named <code class="reqn">Y</code>, second named <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="d_pred_cpp_MvT_+3A_x_u">X_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unobserved instances covariate matrix</p>
</td></tr>
<tr><td><code id="d_pred_cpp_MvT_+3A_y_u">Y_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unobserved instances response matrix</p>
</td></tr>
<tr><td><code id="d_pred_cpp_MvT_+3A_d_u">d_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unobserved instances distance matrix</p>
</td></tr>
<tr><td><code id="d_pred_cpp_MvT_+3A_d_us">d_us</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> cross-distance between unobserved and observed instances matrix</p>
</td></tr>
<tr><td><code id="d_pred_cpp_MvT_+3A_hyperpar">hyperpar</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elemets: first named <code class="reqn">\alpha</code>, second named <code class="reqn">\phi</code></p>
</td></tr>
<tr><td><code id="d_pred_cpp_MvT_+3A_poster">poster</code></td>
<td>
<p><a href="base.html#topic+list">list</a> output from <code>fit_cpp</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+double">double</a> posterior predictive density evaluation
</p>

<hr>
<h2 id='dens_kcv'>Compute the KCV of the density evaluations for fixed values of the hyperparameters</h2><span id='topic+dens_kcv'></span>

<h3>Description</h3>

<p>Compute the KCV of the density evaluations for fixed values of the hyperparameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dens_kcv(data, priors, coords, hyperpar, K)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dens_kcv_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elements: first named <code class="reqn">Y</code>, second named <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="dens_kcv_+3A_priors">priors</code></td>
<td>
<p><a href="base.html#topic+list">list</a> priors: named <code class="reqn">\mu_b</code>,<code class="reqn">V_b</code>,<code class="reqn">a</code>,<code class="reqn">b</code></p>
</td></tr>
<tr><td><code id="dens_kcv_+3A_coords">coords</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> sample coordinates for X and Y</p>
</td></tr>
<tr><td><code id="dens_kcv_+3A_hyperpar">hyperpar</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elemets: first named <code class="reqn">\delta</code>, second named <code class="reqn">\phi</code></p>
</td></tr>
<tr><td><code id="dens_kcv_+3A_k">K</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> number of folds</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+vector">vector</a> posterior predictive density evaluations
</p>

<hr>
<h2 id='dens_kcv_MvT'>Compute the KCV of the density evaluations for fixed values of the hyperparameters</h2><span id='topic+dens_kcv_MvT'></span>

<h3>Description</h3>

<p>Compute the KCV of the density evaluations for fixed values of the hyperparameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dens_kcv_MvT(data, priors, coords, hyperpar, K)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dens_kcv_MvT_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elements: first named <code class="reqn">Y</code>, second named <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="dens_kcv_MvT_+3A_priors">priors</code></td>
<td>
<p><a href="base.html#topic+list">list</a> priors: named <code class="reqn">\mu_B</code>,<code class="reqn">V_r</code>,<code class="reqn">\Psi</code>,<code class="reqn">\nu</code></p>
</td></tr>
<tr><td><code id="dens_kcv_MvT_+3A_coords">coords</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> sample coordinates for X and Y</p>
</td></tr>
<tr><td><code id="dens_kcv_MvT_+3A_hyperpar">hyperpar</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elemets: first named <code class="reqn">\alpha</code>, second named <code class="reqn">\phi</code></p>
</td></tr>
<tr><td><code id="dens_kcv_MvT_+3A_k">K</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> number of folds</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+vector">vector</a> posterior predictive density evaluations
</p>

<hr>
<h2 id='dens_loocv'>Compute the LOOCV of the density evaluations for fixed values of the hyperparameters</h2><span id='topic+dens_loocv'></span>

<h3>Description</h3>

<p>Compute the LOOCV of the density evaluations for fixed values of the hyperparameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dens_loocv(data, priors, coords, hyperpar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dens_loocv_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elements: first named <code class="reqn">Y</code>, second named <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="dens_loocv_+3A_priors">priors</code></td>
<td>
<p><a href="base.html#topic+list">list</a> priors: named <code class="reqn">\mu_b</code>,<code class="reqn">V_b</code>,<code class="reqn">a</code>,<code class="reqn">b</code></p>
</td></tr>
<tr><td><code id="dens_loocv_+3A_coords">coords</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> sample coordinates for X and Y</p>
</td></tr>
<tr><td><code id="dens_loocv_+3A_hyperpar">hyperpar</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elemets: first named <code class="reqn">\delta</code>, second named <code class="reqn">\phi</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+vector">vector</a> posterior predictive density evaluations
</p>

<hr>
<h2 id='dens_loocv_MvT'>Compute the LOOCV of the density evaluations for fixed values of the hyperparameters</h2><span id='topic+dens_loocv_MvT'></span>

<h3>Description</h3>

<p>Compute the LOOCV of the density evaluations for fixed values of the hyperparameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dens_loocv_MvT(data, priors, coords, hyperpar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dens_loocv_MvT_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elements: first named <code class="reqn">Y</code>, second named <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="dens_loocv_MvT_+3A_priors">priors</code></td>
<td>
<p><a href="base.html#topic+list">list</a> priors: named <code class="reqn">\mu_B</code>,<code class="reqn">V_r</code>,<code class="reqn">\Psi</code>,<code class="reqn">\nu</code></p>
</td></tr>
<tr><td><code id="dens_loocv_MvT_+3A_coords">coords</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> sample coordinates for X and Y</p>
</td></tr>
<tr><td><code id="dens_loocv_MvT_+3A_hyperpar">hyperpar</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elemets: first named <code class="reqn">\alpha</code>, second named <code class="reqn">\phi</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+vector">vector</a> posterior predictive density evaluations
</p>

<hr>
<h2 id='expand_grid_cpp'>Build a grid from two vector (i.e. equivalent to <code>expand.grid()</code> in <code>R</code>)</h2><span id='topic+expand_grid_cpp'></span>

<h3>Description</h3>

<p>Build a grid from two vector (i.e. equivalent to <code>expand.grid()</code> in <code>R</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_grid_cpp(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand_grid_cpp_+3A_x">x</code></td>
<td>
<p><a href="base.html#topic+vector">vector</a> first vector of numeric elements</p>
</td></tr>
<tr><td><code id="expand_grid_cpp_+3A_y">y</code></td>
<td>
<p><a href="base.html#topic+vector">vector</a> second vector of numeric elements</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+matrix">matrix</a> expanded grid of combinations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a matrix from all combination of vectors
x &lt;- seq(0, 10, length.out = 100)
y &lt;- seq(-1, 1, length.out = 20)
grid &lt;- expand_grid_cpp(x = x, y = y)

</code></pre>

<hr>
<h2 id='fit_cpp'>Compute the parameters for the posteriors distribution of <code class="reqn">\beta</code> and <code class="reqn">\Sigma</code> (i.e. updated parameters)</h2><span id='topic+fit_cpp'></span>

<h3>Description</h3>

<p>Compute the parameters for the posteriors distribution of <code class="reqn">\beta</code> and <code class="reqn">\Sigma</code> (i.e. updated parameters)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_cpp(data, priors, coords, hyperpar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_cpp_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elements: first named <code class="reqn">Y</code>, second named <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="fit_cpp_+3A_priors">priors</code></td>
<td>
<p><a href="base.html#topic+list">list</a> priors: named <code class="reqn">\mu_b</code>,<code class="reqn">V_b</code>,<code class="reqn">a</code>,<code class="reqn">b</code></p>
</td></tr>
<tr><td><code id="fit_cpp_+3A_coords">coords</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> sample coordinates for X and Y</p>
</td></tr>
<tr><td><code id="fit_cpp_+3A_hyperpar">hyperpar</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elemets: first named <code class="reqn">\delta</code>, second named <code class="reqn">\phi</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+list">list</a> posterior update parameters
</p>

<hr>
<h2 id='fit_cpp_MvT'>Compute the parameters for the posteriors distribution of <code class="reqn">\beta</code> and <code class="reqn">\Sigma</code> (i.e. updated parameters)</h2><span id='topic+fit_cpp_MvT'></span>

<h3>Description</h3>

<p>Compute the parameters for the posteriors distribution of <code class="reqn">\beta</code> and <code class="reqn">\Sigma</code> (i.e. updated parameters)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_cpp_MvT(data, priors, coords, hyperpar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_cpp_MvT_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elements: first named <code class="reqn">Y</code>, second named <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="fit_cpp_MvT_+3A_priors">priors</code></td>
<td>
<p><a href="base.html#topic+list">list</a> priors: named <code class="reqn">\mu_B</code>,<code class="reqn">V_r</code>,<code class="reqn">\Psi</code>,<code class="reqn">\nu</code></p>
</td></tr>
<tr><td><code id="fit_cpp_MvT_+3A_coords">coords</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> sample coordinates for X and Y</p>
</td></tr>
<tr><td><code id="fit_cpp_MvT_+3A_hyperpar">hyperpar</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elemets: first named <code class="reqn">\alpha</code>, second named <code class="reqn">\phi</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+list">list</a> posterior update parameters
</p>

<hr>
<h2 id='forceSymmetry_cpp'>Function to subset data for meta-analysis</h2><span id='topic+forceSymmetry_cpp'></span>

<h3>Description</h3>

<p>Function to subset data for meta-analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forceSymmetry_cpp(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forceSymmetry_cpp_+3A_mat">mat</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> not-symmetric matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+matrix">matrix</a> symmetric matrix (lower triangular of <code>mat</code> is used)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Force matrix to be symmetric (avoiding numerical problems)
n &lt;- 4
X &lt;- matrix(runif(n*n), nrow = n, ncol = n)
X &lt;- forceSymmetry_cpp(mat = X)

</code></pre>

<hr>
<h2 id='models_dens'>Return the CV predictive density evaluations for all the model combinations</h2><span id='topic+models_dens'></span>

<h3>Description</h3>

<p>Return the CV predictive density evaluations for all the model combinations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>models_dens(data, priors, coords, hyperpar, useKCV, K)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="models_dens_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elements: first named <code class="reqn">Y</code>, second named <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="models_dens_+3A_priors">priors</code></td>
<td>
<p><a href="base.html#topic+list">list</a> priors: named <code class="reqn">\mu_b</code>,<code class="reqn">V_b</code>,<code class="reqn">a</code>,<code class="reqn">b</code></p>
</td></tr>
<tr><td><code id="models_dens_+3A_coords">coords</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> sample coordinates for X and Y</p>
</td></tr>
<tr><td><code id="models_dens_+3A_hyperpar">hyperpar</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elemets: first named <code class="reqn">\delta</code>, second named <code class="reqn">\phi</code></p>
</td></tr>
<tr><td><code id="models_dens_+3A_usekcv">useKCV</code></td>
<td>
<p>if <code>TRUE</code> K-fold cross validation is used instead of LOOCV (no <code>default</code>)</p>
</td></tr>
<tr><td><code id="models_dens_+3A_k">K</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> number of folds</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+matrix">matrix</a> posterior predictive density evaluations (each columns represent a different model)
</p>

<hr>
<h2 id='models_dens_MvT'>Return the CV predictive density evaluations for all the model combinations</h2><span id='topic+models_dens_MvT'></span>

<h3>Description</h3>

<p>Return the CV predictive density evaluations for all the model combinations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>models_dens_MvT(data, priors, coords, hyperpar, useKCV, K)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="models_dens_MvT_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elements: first named <code class="reqn">Y</code>, second named <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="models_dens_MvT_+3A_priors">priors</code></td>
<td>
<p><a href="base.html#topic+list">list</a> priors: named <code class="reqn">\mu_B</code>,<code class="reqn">V_r</code>,<code class="reqn">\Psi</code>,<code class="reqn">\nu</code></p>
</td></tr>
<tr><td><code id="models_dens_MvT_+3A_coords">coords</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> sample coordinates for X and Y</p>
</td></tr>
<tr><td><code id="models_dens_MvT_+3A_hyperpar">hyperpar</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elemets: first named <code class="reqn">\alpha</code>, second named <code class="reqn">\phi</code></p>
</td></tr>
<tr><td><code id="models_dens_MvT_+3A_usekcv">useKCV</code></td>
<td>
<p>if <code>TRUE</code> K-fold cross validation is used instead of LOOCV (no <code>default</code>)</p>
</td></tr>
<tr><td><code id="models_dens_MvT_+3A_k">K</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> number of folds</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+matrix">matrix</a> posterior predictive density evaluations (each columns represent a different model)
</p>

<hr>
<h2 id='post_draws'>Sample R draws from the posterior distributions</h2><span id='topic+post_draws'></span>

<h3>Description</h3>

<p>Sample R draws from the posterior distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_draws(poster, R, par, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="post_draws_+3A_poster">poster</code></td>
<td>
<p><a href="base.html#topic+list">list</a> output from <code>fit_cpp</code> function</p>
</td></tr>
<tr><td><code id="post_draws_+3A_r">R</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> number of posterior samples</p>
</td></tr>
<tr><td><code id="post_draws_+3A_par">par</code></td>
<td>
<p>if <code>TRUE</code> only <code class="reqn">\beta</code> and <code class="reqn">\sigma^2</code> are sampled (<code class="reqn">\omega</code> is omitted)</p>
</td></tr>
<tr><td><code id="post_draws_+3A_p">p</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> if <code>par = TRUE</code>, it specifies the column number of <code class="reqn">X</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+list">list</a> posterior samples
</p>

<hr>
<h2 id='post_draws_MvT'>Sample R draws from the posterior distributions</h2><span id='topic+post_draws_MvT'></span>

<h3>Description</h3>

<p>Sample R draws from the posterior distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_draws_MvT(poster, R, par, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="post_draws_MvT_+3A_poster">poster</code></td>
<td>
<p><a href="base.html#topic+list">list</a> output from <code>fit_cpp</code> function</p>
</td></tr>
<tr><td><code id="post_draws_MvT_+3A_r">R</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> number of posterior samples</p>
</td></tr>
<tr><td><code id="post_draws_MvT_+3A_par">par</code></td>
<td>
<p>if <code>TRUE</code> only <code class="reqn">\beta</code> and <code class="reqn">\Sigma</code> are sampled (<code class="reqn">\omega</code> is omitted)</p>
</td></tr>
<tr><td><code id="post_draws_MvT_+3A_p">p</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> if <code>par = TRUE</code>, it specifies the column number of <code class="reqn">X</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+list">list</a> posterior samples
</p>

<hr>
<h2 id='pred_bayesMvLMconjugate'>Predictive sampler for Conjugate Bayesian Multivariate Linear Models</h2><span id='topic+pred_bayesMvLMconjugate'></span>

<h3>Description</h3>

<p>Predictive sampler for Conjugate Bayesian Multivariate Linear Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred_bayesMvLMconjugate(X_new, B_samples, Sigma_samples)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pred_bayesMvLMconjugate_+3A_x_new">X_new</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> <code class="reqn">n_new \times p</code> of predictors for new data points</p>
</td></tr>
<tr><td><code id="pred_bayesMvLMconjugate_+3A_b_samples">B_samples</code></td>
<td>
<p><a href="base.html#topic+array">array</a> of posterior sample for <code class="reqn">\beta</code></p>
</td></tr>
<tr><td><code id="pred_bayesMvLMconjugate_+3A_sigma_samples">Sigma_samples</code></td>
<td>
<p><a href="base.html#topic+array">array</a> of posterior samples for <code class="reqn">\Sigma</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Y_pred <a href="base.html#topic+matrix">matrix</a> of posterior mean for response matrix Y predictions
</p>
<p>Y_pred_samples <a href="base.html#topic+array">array</a> of posterior predictive sample for response matrix Y
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate data
n &lt;- 100
p &lt;- 3
q &lt;- 2
Y &lt;- matrix(rnorm(n*q), nrow = n, ncol = q)
X &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)

## Prior parameters
mu_B &lt;- matrix(0, p, q)
V_B &lt;- diag(10, p)
nu &lt;- 3
Psi &lt;- diag(q)

## Samples from posteriors
n_iter &lt;- 1000
burn_in &lt;- 500
set.seed(1234)
samples &lt;- spBPS::bayesMvLMconjugate(Y, X, mu_B, V_B, nu, Psi, n_iter, burn_in)

## Extract posterior samples
B_samples &lt;- samples$B_samples
Sigma_samples &lt;- samples$Sigma_samples

## Samples from predictive posterior (based posterior samples)
m &lt;- 50
X_new &lt;- matrix(rnorm(m*p), nrow = m, ncol = p)
pred &lt;- spBPS::pred_bayesMvLMconjugate(X_new, B_samples, Sigma_samples)

</code></pre>

<hr>
<h2 id='r_pred_cond'>Draw from the conditional posterior predictive for a set of unobserved covariates</h2><span id='topic+r_pred_cond'></span>

<h3>Description</h3>

<p>Draw from the conditional posterior predictive for a set of unobserved covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_pred_cond(data, X_u, d_u, d_us, hyperpar, poster, post)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r_pred_cond_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elements: first named <code class="reqn">Y</code>, second named <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="r_pred_cond_+3A_x_u">X_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unobserved instances covariate matrix</p>
</td></tr>
<tr><td><code id="r_pred_cond_+3A_d_u">d_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unobserved instances distance matrix</p>
</td></tr>
<tr><td><code id="r_pred_cond_+3A_d_us">d_us</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> cross-distance between unobserved and observed instances matrix</p>
</td></tr>
<tr><td><code id="r_pred_cond_+3A_hyperpar">hyperpar</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elemets: first named <code class="reqn">\delta</code>, second named <code class="reqn">\phi</code></p>
</td></tr>
<tr><td><code id="r_pred_cond_+3A_poster">poster</code></td>
<td>
<p><a href="base.html#topic+list">list</a> output from <code>fit_cpp</code> function</p>
</td></tr>
<tr><td><code id="r_pred_cond_+3A_post">post</code></td>
<td>
<p><a href="base.html#topic+list">list</a> output from <code>post_draws</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+list">list</a> posterior predictive samples
</p>

<hr>
<h2 id='r_pred_cond_MvT'>Draw from the conditional posterior predictive for a set of unobserved covariates</h2><span id='topic+r_pred_cond_MvT'></span>

<h3>Description</h3>

<p>Draw from the conditional posterior predictive for a set of unobserved covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_pred_cond_MvT(data, X_u, d_u, d_us, hyperpar, poster, post)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r_pred_cond_MvT_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elements: first named <code class="reqn">Y</code>, second named <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="r_pred_cond_MvT_+3A_x_u">X_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unobserved instances covariate matrix</p>
</td></tr>
<tr><td><code id="r_pred_cond_MvT_+3A_d_u">d_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unobserved instances distance matrix</p>
</td></tr>
<tr><td><code id="r_pred_cond_MvT_+3A_d_us">d_us</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> cross-distance between unobserved and observed instances matrix</p>
</td></tr>
<tr><td><code id="r_pred_cond_MvT_+3A_hyperpar">hyperpar</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elemets: first named <code class="reqn">\alpha</code>, second named <code class="reqn">\phi</code></p>
</td></tr>
<tr><td><code id="r_pred_cond_MvT_+3A_poster">poster</code></td>
<td>
<p><a href="base.html#topic+list">list</a> output from <code>fit_cpp_MvT</code> function</p>
</td></tr>
<tr><td><code id="r_pred_cond_MvT_+3A_post">post</code></td>
<td>
<p><a href="base.html#topic+list">list</a> output from <code>post_draws_MvT</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+list">list</a> posterior predictive samples
</p>

<hr>
<h2 id='r_pred_joint'>Draw from the joint posterior predictive for a set of unobserved covariates</h2><span id='topic+r_pred_joint'></span>

<h3>Description</h3>

<p>Draw from the joint posterior predictive for a set of unobserved covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_pred_joint(data, X_u, d_u, d_us, hyperpar, poster, R)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r_pred_joint_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elements: first named <code class="reqn">Y</code>, second named <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="r_pred_joint_+3A_x_u">X_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unobserved instances covariate matrix</p>
</td></tr>
<tr><td><code id="r_pred_joint_+3A_d_u">d_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unobserved instances distance matrix</p>
</td></tr>
<tr><td><code id="r_pred_joint_+3A_d_us">d_us</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> cross-distance between unobserved and observed instances matrix</p>
</td></tr>
<tr><td><code id="r_pred_joint_+3A_hyperpar">hyperpar</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elemets: first named <code class="reqn">\delta</code>, second named <code class="reqn">\phi</code></p>
</td></tr>
<tr><td><code id="r_pred_joint_+3A_poster">poster</code></td>
<td>
<p><a href="base.html#topic+list">list</a> output from <code>fit_cpp</code> function</p>
</td></tr>
<tr><td><code id="r_pred_joint_+3A_r">R</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> number of posterior predictive samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+list">list</a> posterior predictive samples
</p>

<hr>
<h2 id='r_pred_joint_MvT'>Draw from the joint posterior predictive for a set of unobserved covariates</h2><span id='topic+r_pred_joint_MvT'></span>

<h3>Description</h3>

<p>Draw from the joint posterior predictive for a set of unobserved covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_pred_joint_MvT(data, X_u, d_u, d_us, hyperpar, poster, R)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r_pred_joint_MvT_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elements: first named <code class="reqn">Y</code>, second named <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="r_pred_joint_MvT_+3A_x_u">X_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unobserved instances covariate matrix</p>
</td></tr>
<tr><td><code id="r_pred_joint_MvT_+3A_d_u">d_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unobserved instances distance matrix</p>
</td></tr>
<tr><td><code id="r_pred_joint_MvT_+3A_d_us">d_us</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> cross-distance between unobserved and observed instances matrix</p>
</td></tr>
<tr><td><code id="r_pred_joint_MvT_+3A_hyperpar">hyperpar</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elemets: first named <code class="reqn">\alpha</code>, second named <code class="reqn">\phi</code></p>
</td></tr>
<tr><td><code id="r_pred_joint_MvT_+3A_poster">poster</code></td>
<td>
<p><a href="base.html#topic+list">list</a> output from <code>fit_cpp</code> function</p>
</td></tr>
<tr><td><code id="r_pred_joint_MvT_+3A_r">R</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> number of posterior predictive samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+list">list</a> posterior predictive samples
</p>

<hr>
<h2 id='r_pred_marg'>Draw from the marginals posterior predictive for a set of unobserved covariates</h2><span id='topic+r_pred_marg'></span>

<h3>Description</h3>

<p>Draw from the marginals posterior predictive for a set of unobserved covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_pred_marg(data, X_u, d_u, d_us, hyperpar, poster, R)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r_pred_marg_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elements: first named <code class="reqn">Y</code>, second named <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="r_pred_marg_+3A_x_u">X_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unobserved instances covariate matrix</p>
</td></tr>
<tr><td><code id="r_pred_marg_+3A_d_u">d_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unobserved instances distance matrix</p>
</td></tr>
<tr><td><code id="r_pred_marg_+3A_d_us">d_us</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> cross-distance between unobserved and observed instances matrix</p>
</td></tr>
<tr><td><code id="r_pred_marg_+3A_hyperpar">hyperpar</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elemets: first named <code class="reqn">\delta</code>, second named <code class="reqn">\phi</code></p>
</td></tr>
<tr><td><code id="r_pred_marg_+3A_poster">poster</code></td>
<td>
<p><a href="base.html#topic+list">list</a> output from <code>fit_cpp</code> function</p>
</td></tr>
<tr><td><code id="r_pred_marg_+3A_r">R</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> number of posterior predictive samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+list">list</a> posterior predictive samples
</p>

<hr>
<h2 id='r_pred_marg_MvT'>Draw from the joint posterior predictive for a set of unobserved covariates</h2><span id='topic+r_pred_marg_MvT'></span>

<h3>Description</h3>

<p>Draw from the joint posterior predictive for a set of unobserved covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_pred_marg_MvT(data, X_u, d_u, d_us, hyperpar, poster, R)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r_pred_marg_MvT_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elements: first named <code class="reqn">Y</code>, second named <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="r_pred_marg_MvT_+3A_x_u">X_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unobserved instances covariate matrix</p>
</td></tr>
<tr><td><code id="r_pred_marg_MvT_+3A_d_u">d_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unobserved instances distance matrix</p>
</td></tr>
<tr><td><code id="r_pred_marg_MvT_+3A_d_us">d_us</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> cross-distance between unobserved and observed instances matrix</p>
</td></tr>
<tr><td><code id="r_pred_marg_MvT_+3A_hyperpar">hyperpar</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elemets: first named <code class="reqn">\alpha</code>, second named <code class="reqn">\phi</code></p>
</td></tr>
<tr><td><code id="r_pred_marg_MvT_+3A_poster">poster</code></td>
<td>
<p><a href="base.html#topic+list">list</a> output from <code>fit_cpp</code> function</p>
</td></tr>
<tr><td><code id="r_pred_marg_MvT_+3A_r">R</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> number of posterior predictive samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+list">list</a> posterior predictive samples
</p>

<hr>
<h2 id='sample_index'>Function to sample integers (index)</h2><span id='topic+sample_index'></span>

<h3>Description</h3>

<p>Function to sample integers (index)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_index(size, length, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_index_+3A_size">size</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> dimension of the set to sample</p>
</td></tr>
<tr><td><code id="sample_index_+3A_length">length</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> number of elements to sample</p>
</td></tr>
<tr><td><code id="sample_index_+3A_p">p</code></td>
<td>
<p><a href="base.html#topic+vector">vector</a> sampling probabilities</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+vector">vector</a> sample of integers
</p>

<hr>
<h2 id='spPredict_BPS'>Perform prediction for BPS accelerated models - loop over prediction set</h2><span id='topic+spPredict_BPS'></span>

<h3>Description</h3>

<p>Perform prediction for BPS accelerated models - loop over prediction set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spPredict_BPS(data, X_u, priors, coords, crd_u, hyperpar, W, R, J)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spPredict_BPS_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elements: first named <code class="reqn">Y</code>, second named <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="spPredict_BPS_+3A_x_u">X_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unobserved instances covariate matrix</p>
</td></tr>
<tr><td><code id="spPredict_BPS_+3A_priors">priors</code></td>
<td>
<p><a href="base.html#topic+list">list</a> priors: named <code class="reqn">\mu_b</code>,<code class="reqn">V_b</code>,<code class="reqn">a</code>,<code class="reqn">b</code></p>
</td></tr>
<tr><td><code id="spPredict_BPS_+3A_coords">coords</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> sample coordinates for X and Y</p>
</td></tr>
<tr><td><code id="spPredict_BPS_+3A_crd_u">crd_u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> unboserved instances coordinates</p>
</td></tr>
<tr><td><code id="spPredict_BPS_+3A_hyperpar">hyperpar</code></td>
<td>
<p><a href="base.html#topic+list">list</a> two elemets: first named <code class="reqn">\delta</code>, second named <code class="reqn">\phi</code></p>
</td></tr>
<tr><td><code id="spPredict_BPS_+3A_w">W</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> set of stacking weights</p>
</td></tr>
<tr><td><code id="spPredict_BPS_+3A_r">R</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> number of desired samples</p>
</td></tr>
<tr><td><code id="spPredict_BPS_+3A_j">J</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> number of desired partition of prediction set</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+list">list</a> BPS posterior predictive samples
</p>

<hr>
<h2 id='subset_data'>Function to subset data for meta-analysis</h2><span id='topic+subset_data'></span>

<h3>Description</h3>

<p>Function to subset data for meta-analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_data(data, K)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset_data_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+list">list</a> three elements: first named <code class="reqn">Y</code>, second named <code class="reqn">X</code>, third named <code class="reqn">crd</code></p>
</td></tr>
<tr><td><code id="subset_data_+3A_k">K</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> number of desired subsets</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+list">list</a> subsets of data, and the set of indexes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a list of K random subsets given a list with Y, X, and crd
n &lt;- 100
p &lt;- 3
q &lt;- 2
X &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)
Y &lt;- matrix(rnorm(n*q), nrow = n, ncol = q)
crd &lt;- matrix(runif(n*2), nrow = n, ncol = 2)
subsets &lt;- subset_data(data = list(Y = Y, X = X, crd = crd), K = 10)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
