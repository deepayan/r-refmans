<!DOCTYPE html><html><head><title>Help for package ggDoE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggDoE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adapted_epitaxial'><p>Adapted epitaxial layer experiment</p></a></li>
<li><a href='#alias_matrix'><p>Color Map on Correlations</p></a></li>
<li><a href='#aliased_design'><p>D-efficient minimal aliasing design for five factors in 12 runs</p></a></li>
<li><a href='#boxcox_transform'><p>Box-Cox Transformations</p></a></li>
<li><a href='#design_to_tibble'><p>Convert an object of class 'design' to 'tibble'</p></a></li>
<li><a href='#gg_boxplots'><p>Boxplots using ggplot2</p></a></li>
<li><a href='#gg_lm'><p>Regression Diagnostic Plots with ggplot2</p></a></li>
<li><a href='#gg_rsm'><p>Contour plot(s) of a fitted linear model in ggplot2</p></a></li>
<li><a href='#girder_experiment'><p>Girder experiment</p></a></li>
<li><a href='#half_normal'><p>Half-Normal Effects Plots</p></a></li>
<li><a href='#interaction_effects'><p>Two-Factor interaction effects plot for a factorial design</p></a></li>
<li><a href='#lambda_plot'><p>Lambda Plot: Trace of t-statistics</p></a></li>
<li><a href='#main_effects'><p>Obtain main effect plots in a factorial design</p></a></li>
<li><a href='#original_epitaxial'><p>Original epitaxial layer experiment</p></a></li>
<li><a href='#pair_plots'><p>Two Dimensional Projections of Latin Hypercube Designs</p></a></li>
<li><a href='#pareto_plot'><p>Pareto Plot of Effects</p></a></li>
<li><a href='#pulp_experiment'><p>Reflectance Data, Pulp Experiment</p></a></li>
<li><a href='#theme_bw_nogrid'><p>Theme for plots used in 'ggDoE'</p></a></li>
<li><a href='#viridisPalette'><p>Simple viridisLite wrapper</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Modern Graphs for Design of Experiments with 'ggplot2'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jose Toledo Luna &lt;toledo60@protonmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Generate commonly used plots in the field of design of experiments using 'ggplot2'.
  'ggDoE' currently supports the following plots: alias matrix, box cox transformation, boxplots, lambda plot,
  regression diagnostic plots, half normal plots, main and interaction effect plots for factorial designs,
  contour plots for response surface methodology, Pareto plot, and two dimensional projections of a latin hypercube design.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ggdoe.netlify.app">https://ggdoe.netlify.app</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/toledo60/ggDoE/issues">https://github.com/toledo60/ggDoE/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2 (&ge; 3.4.0), insight (&ge; 0.19.5)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>roxygen2, tibble, MASS, viridisLite, ggrepel, patchwork,
unrepx, geomtextpath, rsm, lhs, DoE.base</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.7.0)</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-10 01:28:29 UTC; jtoledo</td>
</tr>
<tr>
<td>Author:</td>
<td>Jose Toledo Luna <a href="https://orcid.org/0000-0001-8559-0027"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-10 04:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adapted_epitaxial'>Adapted epitaxial layer experiment</h2><span id='topic+adapted_epitaxial'></span>

<h3>Description</h3>

<p>Same factors and levels as original epitaxial layer experiment but different data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adapted_epitaxial
</code></pre>


<h3>Format</h3>

<p>A tibble with 16 rows, 4 factors (A,B,C,D), and three responses (ybar,s2,lns2)
</p>


<h3>Source</h3>

<p>Wu, CF Jeff, and Michael S. Hamada. Experiments: planning, analysis, and optimization. John Wiley &amp; Sons, 2011
</p>

<hr>
<h2 id='alias_matrix'>Color Map on Correlations</h2><span id='topic+alias_matrix'></span>

<h3>Description</h3>

<p>Color Map on Correlations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alias_matrix(
  design,
  midpoint = 0.5,
  digits = 3,
  color_palette = "viridis",
  alpha = 1,
  direction = 1,
  showplot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alias_matrix_+3A_design">design</code></td>
<td>
<p>Design of experiment (Without response)</p>
</td></tr>
<tr><td><code id="alias_matrix_+3A_midpoint">midpoint</code></td>
<td>
<p>A midpoint value between (0,1) to split the color scheme of three colors</p>
</td></tr>
<tr><td><code id="alias_matrix_+3A_digits">digits</code></td>
<td>
<p>number of digits to round correlation values. Default is 3</p>
</td></tr>
<tr><td><code id="alias_matrix_+3A_color_palette">color_palette</code></td>
<td>
<p>A character string indicating the color map option to use. Eight options are available: &quot;viridis&quot;,&quot;cividis&quot;,&quot;magma&quot;,&quot;inferno&quot;,&quot;plasma&quot;,&quot;rocket&quot;,&quot;mako&quot;,&quot;turbo&quot;</p>
</td></tr>
<tr><td><code id="alias_matrix_+3A_alpha">alpha</code></td>
<td>
<p>The alpha transparency, a number in [0,1]</p>
</td></tr>
<tr><td><code id="alias_matrix_+3A_direction">direction</code></td>
<td>
<p>Sets the order of colors in the scale. If 1, the default, colors are ordered from darkest to lightest. If -1, the order of colors is reversed</p>
</td></tr>
<tr><td><code id="alias_matrix_+3A_showplot">showplot</code></td>
<td>
<p>logical indicating to show the correlation plot. If false, the correlation/alias matrix is returned. Default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>correlation matrix between main effects and interaction effects from the model.matrix. Alias matrix is also returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alias_matrix(design=aliased_design)
alias_matrix(design=aliased_design, color_palette = "plasma")
alias_matrix(design=aliased_design, color_palette = "magma", direction = -1)
</code></pre>

<hr>
<h2 id='aliased_design'>D-efficient minimal aliasing design for five factors in 12 runs</h2><span id='topic+aliased_design'></span>

<h3>Description</h3>

<p>D-efficient minimal aliasing design for five factors in 12 runs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aliased_design
</code></pre>


<h3>Format</h3>

<p>A tibble with 12 rows, 5 factors
</p>

<hr>
<h2 id='boxcox_transform'>Box-Cox Transformations</h2><span id='topic+boxcox_transform'></span>

<h3>Description</h3>

<p>Box-Cox Transformations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxcox_transform(
  model,
  lambda = seq(-2, 2, 1/10),
  showlambda = TRUE,
  lambdaSF = 3,
  showplot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxcox_transform_+3A_model">model</code></td>
<td>
<p>Model used for Box-Cox transformation</p>
</td></tr>
<tr><td><code id="boxcox_transform_+3A_lambda">lambda</code></td>
<td>
<p>sequence of lambda values to consider for plot. Default is seq(-2,2,1/10)</p>
</td></tr>
<tr><td><code id="boxcox_transform_+3A_showlambda">showlambda</code></td>
<td>
<p>Default is TRUE, show lambda values in plot</p>
</td></tr>
<tr><td><code id="boxcox_transform_+3A_lambdasf">lambdaSF</code></td>
<td>
<p>Digits to round lambda values shown in plot</p>
</td></tr>
<tr><td><code id="boxcox_transform_+3A_showplot">showplot</code></td>
<td>
<p>Default is TRUE, if false plot will not be shown and a tibble is returned with a 95% confidence interval for lambda and lambda value which maximizes log-likelihood</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Box-Cox transformation plot with 95% confidence interval of lambda values to consider
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- lm(s2 ~ (A+B+C+D),data = adapted_epitaxial)
boxcox_transform(model,lambda = seq(-5,5,0.2))
boxcox_transform(model,lambda = seq(-5,5,0.2),showplot=FALSE)
</code></pre>

<hr>
<h2 id='design_to_tibble'>Convert an object of class 'design' to 'tibble'</h2><span id='topic+design_to_tibble'></span>

<h3>Description</h3>

<p>Convert an object of class 'design' to 'tibble'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design_to_tibble(design)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="design_to_tibble_+3A_design">design</code></td>
<td>
<p>An object of class 'design'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Converted design to tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- DoE.base::fac.design(factor.names = list(temp = c(16,32),
time = c(4,12)),replications = 5, randomize = FALSE)
Thk &lt;- c(116.1, 106.7, 116.5, 123.2, 116.9, 107.5, 115.5, 125.1, 112.6, 105.9,
119.2, 124.5, 118.7, 107.1, 114.7, 124, 114.9, 106.5, 118.3, 124.7)
design &lt;- DoE.base::add.response(dat, Thk)
design
design_to_tibble(design)
</code></pre>

<hr>
<h2 id='gg_boxplots'>Boxplots using ggplot2</h2><span id='topic+gg_boxplots'></span>

<h3>Description</h3>

<p>Boxplots using ggplot2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_boxplots(
  data,
  x,
  y,
  group_var = NULL,
  jitter_points = FALSE,
  horizontal = FALSE,
  point_size = 1,
  alpha = 1,
  color_palette = NA,
  direction = 1,
  show_mean = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg_boxplots_+3A_data">data</code></td>
<td>
<p>provided dataset</p>
</td></tr>
<tr><td><code id="gg_boxplots_+3A_x">x</code></td>
<td>
<p>A character string indicating the factor of the data</p>
</td></tr>
<tr><td><code id="gg_boxplots_+3A_y">y</code></td>
<td>
<p>A character string indicating the response of the data</p>
</td></tr>
<tr><td><code id="gg_boxplots_+3A_group_var">group_var</code></td>
<td>
<p>A character string indicating the groups for facet_wrap</p>
</td></tr>
<tr><td><code id="gg_boxplots_+3A_jitter_points">jitter_points</code></td>
<td>
<p>Overlay jittered points to boxplots. Default is FALSE.</p>
</td></tr>
<tr><td><code id="gg_boxplots_+3A_horizontal">horizontal</code></td>
<td>
<p>Determine whether to change the orientation of the plot. Default is FALSE</p>
</td></tr>
<tr><td><code id="gg_boxplots_+3A_point_size">point_size</code></td>
<td>
<p>Change size of points (outliers) in boxplots</p>
</td></tr>
<tr><td><code id="gg_boxplots_+3A_alpha">alpha</code></td>
<td>
<p>The alpha transparency, a number in [0,1]</p>
</td></tr>
<tr><td><code id="gg_boxplots_+3A_color_palette">color_palette</code></td>
<td>
<p>A character string indicating the color map option to use. Eight options are available: &quot;viridis&quot;,&quot;cividis&quot;,&quot;magma&quot;,&quot;inferno&quot;,&quot;plasma&quot;,&quot;rocket&quot;,&quot;mako&quot;,&quot;turbo&quot;</p>
</td></tr>
<tr><td><code id="gg_boxplots_+3A_direction">direction</code></td>
<td>
<p>Sets the order of colors in the scale. If 1, the default, colors are ordered from darkest to lightest. If -1, the order of colors is reversed</p>
</td></tr>
<tr><td><code id="gg_boxplots_+3A_show_mean">show_mean</code></td>
<td>
<p>Display the mean for each boxplot. Default is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boxplots created with ggplot2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- ToothGrowth
data$dose &lt;- factor(data$dose,levels = c(0.5, 1, 2),labels = c("D0.5", "D1", "D2"))
gg_boxplots(data,y= "len",x= "dose",alpha=0.6)
gg_boxplots(data,y = "len",x= "dose",group_var = "supp",
alpha=0.6,color_palette = 'viridis',jitter_points=TRUE)
</code></pre>

<hr>
<h2 id='gg_lm'>Regression Diagnostic Plots with ggplot2</h2><span id='topic+gg_lm'></span>

<h3>Description</h3>

<p>Regression Diagnostic Plots with ggplot2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_lm(
  model,
  which_plots = 1:4,
  cooksD_type = 1,
  standard_errors = FALSE,
  point_size = 1.5,
  theme_color = "#21908CFF",
  n_columns = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg_lm_+3A_model">model</code></td>
<td>
<p>Model of class &quot;lm&quot; or &quot;glm&quot;</p>
</td></tr>
<tr><td><code id="gg_lm_+3A_which_plots">which_plots</code></td>
<td>
<p>Choose which diagnostic plots to choose from. <br /> Options are 1 = 'residual vs fitted', 2 = 'Normal-QQ',
3 = 'Scale-location', 4 = 'Residual vs Leverage', 5 = &quot;Cook's Distance&quot;. 6 = &quot;Collinearity&quot;. Default is 1:4</p>
</td></tr>
<tr><td><code id="gg_lm_+3A_cooksd_type">cooksD_type</code></td>
<td>
<p>An integer between 1 and 4 indicating the threshold to be computed for Cook's Distance plot. Default is 1. See details for threshold computation</p>
</td></tr>
<tr><td><code id="gg_lm_+3A_standard_errors">standard_errors</code></td>
<td>
<p>Display confidence interval around geom_smooth, FALSE by default</p>
</td></tr>
<tr><td><code id="gg_lm_+3A_point_size">point_size</code></td>
<td>
<p>Change size of points in plots</p>
</td></tr>
<tr><td><code id="gg_lm_+3A_theme_color">theme_color</code></td>
<td>
<p>Change color of the geom_smooth line and text labels for the respective diagnostic plot</p>
</td></tr>
<tr><td><code id="gg_lm_+3A_n_columns">n_columns</code></td>
<td>
<p>number of columns for grid layout. Default is 2</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Plot 5:</strong> &quot;Cook's Distance&quot;: A data point having a large Cook's distance indicates that the data point
strongly influences the fitted values of the model. The default threshold used for detecting or classifying observations as outers is <code class="reqn">4/n</code> (i.e cooksD_type=1)
where <code class="reqn">n</code> is the number of observations. The thresholds computed are as follows: <br />
</p>

<dl>
<dt>cooksD_type = 1: </dt><dd><p>4/n</p>
</dd>
<dt>cooksD_type = 2: </dt><dd><p>4/(n-p-1)</p>
</dd>
<dt>cooksD_type = 3: </dt><dd><p>1/(n-p-1)</p>
</dd>
<dt>cooksD_type = 4: </dt><dd><p>3* mean(cook's distance values)</p>
</dd>
</dl>

<p>where <code class="reqn">n</code> is the number of observations and <code class="reqn">p</code> is the number of predictors. <br />
</p>
<p><strong>Plot 6:</strong> &quot;Collinearity&quot;: Conisders the variance inflation factor (VIF) for multicollinearity: <br />
Tolerance = <code class="reqn">1 - R_j^2</code>, VIF = (1/Tolerance)
where <code class="reqn">R_j^2</code> is the coefficient of determination of a regression of predictor <code class="reqn">j</code> on all the other predictors.
A general rule of thumb is that VIFs exceeding 4 warrant further investigation, while VIFs exceeding 10 indicates a multicollinearity problem <br /> <br />
</p>


<h3>Value</h3>

<p>Regression diagnostic plots
</p>


<h3>References</h3>

<p>Belsley, D. A., Kuh, E., and Welsch, R. E. (1980). Regression Diagnostics: Identifying Influential Data and Sources of Collinearity. New York: John Wiley &amp; Sons.<br />
</p>
<p>Sheather, S. (2009). A modern approach to regression with R. Springer Science &amp; Business Media.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- lm(mpg ~ wt + am + gear, data = mtcars)
gg_lm(model)
</code></pre>

<hr>
<h2 id='gg_rsm'>Contour plot(s) of a fitted linear model in ggplot2</h2><span id='topic+gg_rsm'></span>

<h3>Description</h3>

<p>Contour plot(s) of a fitted linear model in ggplot2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_rsm(
  rsm_model,
  formula,
  decode = FALSE,
  n_columns = 2,
  text_size = 3,
  bins = 6,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg_rsm_+3A_rsm_model">rsm_model</code></td>
<td>
<p>Model of class &quot;rsm&quot;</p>
</td></tr>
<tr><td><code id="gg_rsm_+3A_formula">formula</code></td>
<td>
<p>A formula, or a list of formulas</p>
</td></tr>
<tr><td><code id="gg_rsm_+3A_decode">decode</code></td>
<td>
<p>This has an effect only if x is an rsm object or other model object that supports coded.data.
In such cases, if decode is TRUE, the coordinate axes are transformed to their decoded values.</p>
</td></tr>
<tr><td><code id="gg_rsm_+3A_n_columns">n_columns</code></td>
<td>
<p>number of columns for grid layout. Default is 2</p>
</td></tr>
<tr><td><code id="gg_rsm_+3A_text_size">text_size</code></td>
<td>
<p>size of text for labelled contour lines. Default is 3</p>
</td></tr>
<tr><td><code id="gg_rsm_+3A_bins">bins</code></td>
<td>
<p>Number of contour bins. Overridden by binwidth</p>
</td></tr>
<tr><td><code id="gg_rsm_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to contour(). For help with more arguments see ?rsm::contour.lm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid of contour plot(s) of a fitted linear model in 'ggplot2'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
heli.rsm &lt;- rsm::rsm(ave ~ SO(x1, x2, x3),data = rsm::heli)

gg_rsm(heli.rsm,formula = ~x1+x2+x3,at = rsm::xs(heli.rsm),n_columns=3)


## End(Not run)
</code></pre>

<hr>
<h2 id='girder_experiment'>Girder experiment</h2><span id='topic+girder_experiment'></span>

<h3>Description</h3>

<p>An experiment (Narayanan and Adorisio, 1983) to compare four methods for predicting the shear strength for steel plate girders.
Data for nine girders in the form of the ratio of predicted to observed load for these procedures are given.
Each of the four methods was used to predict the strength of each of the nine girders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>girder_experiment
</code></pre>


<h3>Format</h3>

<p>A tibble with 36 rows and 3 variables
</p>

<dl>
<dt>girders</dt><dd><p>A factor denoting one of the nine girders</p>
</dd>
<dt>method</dt><dd><p>A factor denoting one of the four methods for predicting the shear strength for steel plate girders: Aarau, Karlsruhe,Lehigh, Cardiff</p>
</dd>
<dt>response</dt><dd><p>The shear strength for steel plate girders</p>
</dd>
</dl>



<h3>Source</h3>

<p>Wu, CF Jeff, and Michael S. Hamada. Experiments: planning, analysis, and optimization. John Wiley &amp; Sons, 2011
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lm(response ~ method + girders, data = girder_experiment) |&gt;
anova()
</code></pre>

<hr>
<h2 id='half_normal'>Half-Normal Effects Plots</h2><span id='topic+half_normal'></span>

<h3>Description</h3>

<p>Half-Normal Effects Plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>half_normal(
  model,
  method = "Lenth",
  alpha = 0.05,
  label_active = FALSE,
  ref_line = FALSE,
  margin_errors = FALSE,
  point_color = "#21908CFF",
  showplot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="half_normal_+3A_model">model</code></td>
<td>
<p>object of class &quot;lm&quot;</p>
</td></tr>
<tr><td><code id="half_normal_+3A_method">method</code></td>
<td>
<p>Character value. Method to calculate PSE. Default is Lenth. Options include: Zahn, WZahn, Lenth, RMS, Dong, JuanPena, Daniel. See Details.</p>
</td></tr>
<tr><td><code id="half_normal_+3A_alpha">alpha</code></td>
<td>
<p>specify the significance level to compute margin of errors. Numeric significance level, between 0 and 1. Default is alpha=0.05</p>
</td></tr>
<tr><td><code id="half_normal_+3A_label_active">label_active</code></td>
<td>
<p>If TRUE, active effects are labeled if the effects cross the computed margin of error (ME). See method argument for more details</p>
</td></tr>
<tr><td><code id="half_normal_+3A_ref_line">ref_line</code></td>
<td>
<p>Dafault is TRUE, if FALSE the abline with slope (1/PSE) is not displayed. Reference line should follow along most points that are not considered outliers.</p>
</td></tr>
<tr><td><code id="half_normal_+3A_margin_errors">margin_errors</code></td>
<td>
<p>Default is FALSE, if TRUE the cutoffs for margin of errors (ME) and simultaneous margin of error (SME) are shown</p>
</td></tr>
<tr><td><code id="half_normal_+3A_point_color">point_color</code></td>
<td>
<p>Change color of points in plot</p>
</td></tr>
<tr><td><code id="half_normal_+3A_showplot">showplot</code></td>
<td>
<p>Default is TRUE, if FALSE plot will not be shown and a tibble is returned used to create the plot along with the calculated PSE,ME,SME</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method argument is a simple wrapper for the function PSE() from the unrepx R package.
For more details you can use ?unrepx::PSE(). The <em>method</em> arguement implements methods of estimating the standard error of
effects estimates from unreplicatd designs. The methods include
</p>

<dl>
<dt>Daniel: </dt><dd><p>The 68.3rd quantile of the absolute effects. See Daniel (1959) </p>
</dd>
<dt>Dong: </dt><dd><p>The RMS method, applied after excluding all
effects that exceed 2.5 * PSE(effects, &quot;SMedian&quot;) in absolute value. See Dong (1993)</p>
</dd>
<dt>JuanPena: </dt><dd><p>An iterated median method whereby we repeatedly calculate the
median of the absolute effects that don't exceed 3.5 times the previous median, until it stabilizes.
The estimate is the final median, divided by .6578. See Juan and Pena (1992).</p>
</dd>
<dt>Lenth (Default): </dt><dd><p>The SMedian method, applied after excluding all effects that exceed 2.5 * PSE(effects, &quot;SMedian&quot;)
in absolute value. See Lenth (1989)</p>
</dd>
<dt>RMS: </dt><dd><p>Square root of the mean of the squared effects. This is not a good PSE in the presence of active effects,
but it is provided for sake of comparisons</p>
</dd>
<dt>SMedian: </dt><dd><p>1.5 times the median of the absolute effects</p>
</dd>
<dt>Zahn, WZahn: </dt><dd><p>The Zahn method is the slope of the least-squares line fitted to the first m points of unrepx::hnplot(effects, horiz = FALSE),
where m = floor(.683 * length(effects)). (This line is fitted through the origin.)
The WZahn method is an experimental version of Zahn's method,
based on weighted least-squares
with weights decreasing linearly from m - .5 to .5, but bounded above by .65m</p>
</dd>
</dl>



<h3>Value</h3>

<p>A tibble with the absolute effects and half-normal quantiles. A ggplot2 version of halfnormal plot for factorial effects is returned
</p>


<h3>References</h3>

<p>Daniel, C (1959) Use of Half-Normal Plots in Interpreting Factorial Two-Level Experiments. Technometrics, 1(4), 311-341 <br /> <br />
Dong, F (1993) On the Identification of Active Contrasts in Unreplicated Fractional Factorials. Statistica Sinica 3, 209-217 <br /> <br />
Hamada and Balakrishnan (1998) Analyzing Unreplicated Factorial Experiments: A Review With Some New Proposals. Statistica Sinica 8, 1-41 <br /> <br />
Juan, J and Pena, D (1992) A Simple Method to Identify Significant Effects in Unreplicated Two-Level Factorial Designs. Communications in Statistics: Theory and Methods 21, 1383-1403 <br /> <br />
Lenth, R (1989) Quick and Easy Analysis of Unrelicated Factorials Technometrics 31(4), 469-473 <br /> <br />
Zahn, D (1975) Modifications of and Revised Critical Values for the Half-Normal Plot. Technometrics 17(2), 189-200
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- lm(ybar ~ (A+B+C+D)^4,data=adapted_epitaxial)
half_normal(model)
half_normal(model,method='Zahn',alpha=0.1,ref_line=TRUE,
            label_active=TRUE,margin_errors=TRUE)
</code></pre>

<hr>
<h2 id='interaction_effects'>Two-Factor interaction effects plot for a factorial design</h2><span id='topic+interaction_effects'></span>

<h3>Description</h3>

<p>Two-Factor interaction effects plot for a factorial design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interaction_effects(
  design,
  response,
  exclude_vars = c(),
  linetypes = c("solid", "dashed"),
  colors = c("#4260c9", "#d6443c"),
  n_columns = 2,
  showplot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interaction_effects_+3A_design">design</code></td>
<td>
<p>Design of experiment (Factorial Design)</p>
</td></tr>
<tr><td><code id="interaction_effects_+3A_response">response</code></td>
<td>
<p>A character string indicating the response of the data</p>
</td></tr>
<tr><td><code id="interaction_effects_+3A_exclude_vars">exclude_vars</code></td>
<td>
<p>A vector containing variables to exclude</p>
</td></tr>
<tr><td><code id="interaction_effects_+3A_linetypes">linetypes</code></td>
<td>
<p>Change linetypes. Default are ('solid','dashed)</p>
</td></tr>
<tr><td><code id="interaction_effects_+3A_colors">colors</code></td>
<td>
<p>Change color of lines/points. Default are (&quot;#4260c9&quot; ,&quot;#d6443c&quot;)</p>
</td></tr>
<tr><td><code id="interaction_effects_+3A_n_columns">n_columns</code></td>
<td>
<p>number of columns for facet grid. Default is 2</p>
</td></tr>
<tr><td><code id="interaction_effects_+3A_showplot">showplot</code></td>
<td>
<p>logical indicating to show the interaction effect plots. If false, a list of tibbles is returned used to obtain the interaction effects for each factor. Default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>interaction effects plot between two factors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>interaction_effects(adapted_epitaxial,response = 'ybar',exclude_vars = c('s2','lns2'))
</code></pre>

<hr>
<h2 id='lambda_plot'>Lambda Plot: Trace of t-statistics</h2><span id='topic+lambda_plot'></span>

<h3>Description</h3>

<p>Lambda Plot: Trace of t-statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda_plot(
  model,
  lambda = seq(-2, 2, by = 0.1),
  color_palette = "viridis",
  alpha = 1,
  direction = 1,
  showplot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambda_plot_+3A_model">model</code></td>
<td>
<p>Model of class &quot;lm&quot; or &quot;glm&quot;</p>
</td></tr>
<tr><td><code id="lambda_plot_+3A_lambda">lambda</code></td>
<td>
<p>sequence of lambda values to consider for plot. Default is seq(-2,2,0.1)</p>
</td></tr>
<tr><td><code id="lambda_plot_+3A_color_palette">color_palette</code></td>
<td>
<p>A character string indicating the color map option to use.
Eight options are available: &quot;viridis&quot;,&quot;cividis&quot;,&quot;magma&quot;,&quot;inferno&quot;,&quot;plasma&quot;,&quot;rocket&quot;,&quot;mako&quot;,&quot;turbo&quot;. Default is 'viridis'</p>
</td></tr>
<tr><td><code id="lambda_plot_+3A_alpha">alpha</code></td>
<td>
<p>The alpha transparency, a number in [0,1]</p>
</td></tr>
<tr><td><code id="lambda_plot_+3A_direction">direction</code></td>
<td>
<p>Sets the order of colors in the scale. If 1, the default, colors are ordered from darkest to lightest. If -1, the order of colors is reversed</p>
</td></tr>
<tr><td><code id="lambda_plot_+3A_showplot">showplot</code></td>
<td>
<p>logical indicating to show the main effect plots. If false, a list of tibbles is returned used to obtain the main effects for each factor. Default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Lambda plot for tracing t-staitics across different values of lambda (in ggplot2)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- lm(s2 ~ (A+B+C)^2,data=original_epitaxial)
lambda_plot(mod)
lambda_plot(mod,lambda = seq(0,2,0.1))
lambda_plot(mod,lambda = seq(0,2,0.1),showplot = FALSE)
</code></pre>

<hr>
<h2 id='main_effects'>Obtain main effect plots in a factorial design</h2><span id='topic+main_effects'></span>

<h3>Description</h3>

<p>Obtain main effect plots in a factorial design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>main_effects(
  design,
  response,
  exclude_vars = c(),
  n_columns = 2,
  color_palette = NA,
  alpha = 1,
  direction = 1,
  showplot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="main_effects_+3A_design">design</code></td>
<td>
<p>Design of experiment (Factorial Design)</p>
</td></tr>
<tr><td><code id="main_effects_+3A_response">response</code></td>
<td>
<p>A character string indicating the response of the data</p>
</td></tr>
<tr><td><code id="main_effects_+3A_exclude_vars">exclude_vars</code></td>
<td>
<p>A vector containing variables to exclude</p>
</td></tr>
<tr><td><code id="main_effects_+3A_n_columns">n_columns</code></td>
<td>
<p>number of columns for facet grid. Default is 2</p>
</td></tr>
<tr><td><code id="main_effects_+3A_color_palette">color_palette</code></td>
<td>
<p>A character string indicating the color map option to use. Eight options are available: &quot;viridis&quot;,&quot;cividis&quot;,&quot;magma&quot;,&quot;inferno&quot;,&quot;plasma&quot;,&quot;rocket&quot;,&quot;mako&quot;,&quot;turbo&quot;</p>
</td></tr>
<tr><td><code id="main_effects_+3A_alpha">alpha</code></td>
<td>
<p>The alpha transparency, a number in [0,1]</p>
</td></tr>
<tr><td><code id="main_effects_+3A_direction">direction</code></td>
<td>
<p>Sets the order of colors in the scale. If 1, the default, colors are ordered from darkest to lightest. If -1, the order of colors is reversed</p>
</td></tr>
<tr><td><code id="main_effects_+3A_showplot">showplot</code></td>
<td>
<p>logical indicating to show the main effect plots. If false, a list of data.frames is returned used to obtain the main effects for each factor. Default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Main effects plots, or a list of tibble with calculated main effects for each factors if showplot=FALSE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>main_effects(original_epitaxial,response='s2',exclude_vars = c('ybar','lns2'))
main_effects(original_epitaxial,response='ybar',exclude_vars=c('A','s2','lns2'),n_columns=3)
</code></pre>

<hr>
<h2 id='original_epitaxial'>Original epitaxial layer experiment</h2><span id='topic+original_epitaxial'></span>

<h3>Description</h3>

<p>One of the initial steps in fabricating integrated circuit (IC) devices is to grow an epitaxial layer on polished silicon wafers.
The wafers are mounted on a six-faceted cylinder (two wafers per facet), called a susceptor, which is spun inside a metal bell jar.
The jar is injected with chemical vapors through nozzles at the top of the jar and heated.
The process continues until the epitaxial layer grows to a desired thickness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>original_epitaxial
</code></pre>


<h3>Format</h3>

<p>A tibble with 16 observations, 4 factors (A,B,C,D), and three responses (ybar,s2,lns2)
</p>

<dl>
<dt>Factor A</dt><dd><p>Susceptor-rotation method. Low level is oscillating and high level is continuous</p>
</dd>
<dt>Factor B</dt><dd><p>Nozzle position. Low level is 2 and high level is 6</p>
</dd>
<dt>Factor C</dt><dd><p>Deposition temperature (Celsius). Low level is 1210 and high level is 1220</p>
</dd>
<dt>Factor D</dt><dd><p>Deposition time. Low level is low and high level is high</p>
</dd>
<dt>ybar</dt><dd><p>average thickness</p>
</dd>
<dt>s2</dt><dd><p>variance of thickness</p>
</dd>
<dt>lns2</dt><dd><p>log variance of thickness</p>
</dd>
</dl>



<h3>Details</h3>

<p>In the epitaxial layer growth process, suppose that the four experimental factors,
susceptor rotation method, nozzle position, deposition temperature, and deposition time (labeled A, B, Cand D)
are to be investigated at the two levels each.
</p>
<p>The purpose of this experiment is to find process conditions, that is, combinations of factor levels for A, B, C, and D,
under which the average thickness is close to the target 14.5 micrometre with variation as small as possible.
The most basic experimental design or plan is the full factorial design, which studies all possible combinations
of factors at two levels.
</p>


<h3>Source</h3>

<p>Wu, CF Jeff, and Michael S. Hamada. Experiments: planning, analysis, and optimization. John Wiley &amp; Sons, 2011
</p>

<hr>
<h2 id='pair_plots'>Two Dimensional Projections of Latin Hypercube Designs</h2><span id='topic+pair_plots'></span>

<h3>Description</h3>

<p>Two Dimensional Projections of Latin Hypercube Designs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pair_plots(
  design,
  point_color = "#21908CFF",
  grid = FALSE,
  point_size = 1.5,
  n_columns = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pair_plots_+3A_design">design</code></td>
<td>
<p>A Latin hypercube design. Can be matrix, or data.frame</p>
</td></tr>
<tr><td><code id="pair_plots_+3A_point_color">point_color</code></td>
<td>
<p>Change color of points in plots</p>
</td></tr>
<tr><td><code id="pair_plots_+3A_grid">grid</code></td>
<td>
<p>Logial argument. Specify if a grid should be added to each projection.
The grid is constructed using seq(0,1,length=nrows(design)+1). Default is FALSE</p>
</td></tr>
<tr><td><code id="pair_plots_+3A_point_size">point_size</code></td>
<td>
<p>Change size of points in plots</p>
</td></tr>
<tr><td><code id="pair_plots_+3A_n_columns">n_columns</code></td>
<td>
<p>number of columns for grid layout. Default is 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid of scatter plots from all two dimensional projections of a Latin hypercube design.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
X &lt;- lhs::randomLHS(n=15,k=4)
pair_plots(X,n_columns = 3)
</code></pre>

<hr>
<h2 id='pareto_plot'>Pareto Plot of Effects</h2><span id='topic+pareto_plot'></span>

<h3>Description</h3>

<p>Pareto Plot of Effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pareto_plot(
  model,
  alpha = 0.05,
  method = "Lenth",
  effect_colors = c("#F8766D", "#00BFC4"),
  margin_errors = TRUE,
  showplot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pareto_plot_+3A_model">model</code></td>
<td>
<p>Model of class &quot;lm&quot;</p>
</td></tr>
<tr><td><code id="pareto_plot_+3A_alpha">alpha</code></td>
<td>
<p>specify the significance level to compute margin of errors. Numeric significance level, between 0 and 1. Default is alpha=0.05</p>
</td></tr>
<tr><td><code id="pareto_plot_+3A_method">method</code></td>
<td>
<p>Character value. Method to calculate PSE. Default is Lenth. Options include: Zahn, WZahn, Lenth, RMS, Dong, JuanPena, Daniel. See Details.</p>
</td></tr>
<tr><td><code id="pareto_plot_+3A_effect_colors">effect_colors</code></td>
<td>
<p>Change colors of effects. Default are ('#F8766D','#00BFC4') for negative and positive effects, respectively.</p>
</td></tr>
<tr><td><code id="pareto_plot_+3A_margin_errors">margin_errors</code></td>
<td>
<p>Default is TRUE, if false the cutoffs for margin of errors (ME) and simultaneous margin of error (SME) are not shown</p>
</td></tr>
<tr><td><code id="pareto_plot_+3A_showplot">showplot</code></td>
<td>
<p>Default is TRUE, if false plot will not be shown and a tibble is returned with data used to create the pareto plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method argument is a simple wrapper for the function PSE() from the unrepx R package.
For more details you can use ?unrepx::PSE(). The <em>method</em> arguement implements methods of estimating the standard error of
effects estimates from unreplicatd designs. The methods include
</p>

<dl>
<dt>Daniel: </dt><dd><p>The 68.3rd quantile of the absolute effects. See Daniel (1959) </p>
</dd>
<dt>Dong: </dt><dd><p>The RMS method, applied after excluding all
effects that exceed 2.5 * PSE(effects, &quot;SMedian&quot;) in absolute value. See Dong (1993)</p>
</dd>
<dt>JuanPena: </dt><dd><p>An iterated median method whereby we repeatedly calculate the
median of the absolute effects that don't exceed 3.5 times the previous median, until it stabilizes.
The estimate is the final median, divided by .6578. See Juan and Pena (1992).</p>
</dd>
<dt>Lenth (Default): </dt><dd><p>The SMedian method, applied after excluding all effects that exceed 2.5 * PSE(effects, &quot;SMedian&quot;)
in absolute value. See Lenth (1989)</p>
</dd>
<dt>RMS: </dt><dd><p>Square root of the mean of the squared effects. This is not a good PSE in the presence of active effects,
but it is provided for sake of comparisons</p>
</dd>
<dt>SMedian: </dt><dd><p>1.5 times the median of the absolute effects</p>
</dd>
<dt>Zahn, WZahn: </dt><dd><p>The Zahn method is the slope of the least-squares line fitted to the first m points of unrepx::hnplot(effects, horiz = FALSE),
where m = floor(.683 * length(effects)). (This line is fitted through the origin.)
The WZahn method is an experimental version of Zahn's method,
based on weighted least-squares
with weights decreasing linearly from m - .5 to .5, but bounded above by .65m</p>
</dd>
</dl>



<h3>Value</h3>

<p>A bar plot with ordered effects, margin of error (ME) and simultaneous margin of error (SME) cutoffs.
</p>


<h3>References</h3>

<p>Daniel, C (1959) Use of Half-Normal Plots in Interpreting Factorial Two-Level Experiments. Technometrics, 1(4), 311-341 <br /> <br />
Dong, F (1993) On the Identification of Active Contrasts in Unreplicated Fractional Factorials. Statistica Sinica 3, 209-217 <br /> <br />
Hamada and Balakrishnan (1998) Analyzing Unreplicated Factorial Experiments: A Review With Some New Proposals. Statistica Sinica 8, 1-41 <br /> <br />
Juan, J and Pena, D (1992) A Simple Method to Identify Significant Effects in Unreplicated Two-Level Factorial Designs. Communications in Statistics: Theory and Methods 21, 1383-1403 <br /> <br />
Lenth, R (1989) Quick and Easy Analysis of Unrelicated Factorials Technometrics 31(4), 469-473 <br /> <br />
Zahn, D (1975) Modifications of and Revised Critical Values for the Half-Normal Plot. Technometrics 17(2), 189-200
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- lm(lns2 ~ (A+B+C+D)^4,data=original_epitaxial)
pareto_plot(m1)
pareto_plot(m1,method='Zahn',alpha=0.1)
</code></pre>

<hr>
<h2 id='pulp_experiment'>Reflectance Data, Pulp Experiment</h2><span id='topic+pulp_experiment'></span>

<h3>Description</h3>

<p>Plant performance is based on pulp brightness as measured by a reflectance meter.
Each of the four shift operators (denoted by A, B, C, and D) made five pulp handsheets from unbleached pulp.
Reflectance was read for each of the handsheets using a brightness tester
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pulp_experiment
</code></pre>


<h3>Format</h3>

<p>A tibble with 5 rows, and 4 variables (A,B,C,D)
</p>


<h3>Source</h3>

<p>Wu, CF Jeff, and Michael S. Hamada. Experiments: planning, analysis, and optimization. John Wiley &amp; Sons, 2011
</p>

<hr>
<h2 id='theme_bw_nogrid'>Theme for plots used in 'ggDoE'</h2><span id='topic+theme_bw_nogrid'></span>

<h3>Description</h3>

<p>Theme for plots used in 'ggDoE'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_bw_nogrid()
</code></pre>


<h3>Value</h3>

<p>A simple black and white theme without grid.major and grid.minor for ggplot objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
data &lt;- ToothGrowth
data$dose &lt;- factor(data$dose,levels = c(0.5, 1, 2),
                    labels = c("D0.5", "D1", "D2"))

ggplot(data, aes(x=dose, y=len)) +
 geom_boxplot()+
 theme_bw_nogrid()
</code></pre>

<hr>
<h2 id='viridisPalette'>Simple viridisLite wrapper</h2><span id='topic+viridisPalette'></span>

<h3>Description</h3>

<p>Simple viridisLite wrapper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viridisPalette(
  total_colors,
  color_palette = "viridis",
  alpha = 1,
  direction = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="viridisPalette_+3A_total_colors">total_colors</code></td>
<td>
<p>number of colors desired</p>
</td></tr>
<tr><td><code id="viridisPalette_+3A_color_palette">color_palette</code></td>
<td>
<p>A character string indicating the color map option to use. Eight options are available: &quot;viridis&quot;,&quot;cividis&quot;,&quot;magma&quot;,&quot;inferno&quot;,&quot;plasma&quot;,&quot;rocket&quot;,&quot;mako&quot;,&quot;turbo&quot;</p>
</td></tr>
<tr><td><code id="viridisPalette_+3A_alpha">alpha</code></td>
<td>
<p>The alpha transparency, a number in [0,1]</p>
</td></tr>
<tr><td><code id="viridisPalette_+3A_direction">direction</code></td>
<td>
<p>Sets the order of colors in the scale. If 1, the default, colors are ordered from darkest to lightest. If -1, the order of colors is reversed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Specified color palette of length 'total_colors'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>viridisPalette(5)
viridisPalette(5,color_palette='magma',alpha=0.5)
viridisPalette(5,color_palette='plasma',alpha=0.6,direction=-1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
