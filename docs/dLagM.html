<!DOCTYPE html><html><head><title>Help for package dLagM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dLagM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dLagM-package'>
<p>Implementation of Time Series Regression Models with Distributed Lag Models</p></a></li>
<li><a href='#ardlBound'>
<p>Implement ARDL bounds test</p></a></li>
<li><a href='#ardlBoundOrders'>
<p>Find optimal orders (lag structure) for ARDL bounds test</p></a></li>
<li><a href='#ardlDlm'>
<p>Implement finite autoregressive distributed lag model</p></a></li>
<li><a href='#dlm'>
<p>Implement finite distributed lag model</p></a></li>
<li><a href='#finiteDLMauto'>
<p>Find the optimal lag length for finite DLMs</p></a></li>
<li><a href='#forecast'>
<p>Compute forecasts for distributed lag models</p></a></li>
<li><a href='#GoF'>
<p>Compute goodness-of-fit measures for DLMs</p></a></li>
<li><a href='#grainProduction'><p>World oats, corn, rice, wheat production, CO2 emissions, temperature anomalies, cropland data</p></a></li>
<li><a href='#koyckDlm'>
<p>Implement distributed lag models with Koyck transformation</p></a></li>
<li><a href='#polyDlm'>
<p>Implement finite polynomial distributed lag model</p></a></li>
<li><a href='#rolCorPlot'>
<p>PLot the rolling correlations</p></a></li>
<li><a href='#sdPercentiles'>
<p>Test the significance of signal from rolling correlation analysis</p></a></li>
<li><a href='#seaLevelTempSOI'><p>Global mean sea level (GMSL), mean land and ocean temperature anomalies, and Southern Oscillation Index (SOI) data</p></a></li>
<li><a href='#sortScore'>
<p>Sort AIC, BIC, MASE, MAPE, sMAPE, MRAE, GMRAE, or MBRAE scores</p></a></li>
<li><a href='#sunspotTemp'><p>Sunspot numbers and mean temperature anomalies data</p></a></li>
<li><a href='#warming'><p>Global warming and vehicle production data</p></a></li>
<li><a href='#wheat'><p>World wheat production, CO2 emissions, and temperature anomalies data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Time Series Regression Models with Distributed Lag Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.13</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-02</td>
</tr>
<tr>
<td>Author:</td>
<td>Haydar Demirhan [aut, cre, cph] (&lt;https://orcid.org/0000-0002-8565-4710&gt;)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Haydar Demirhan &lt;haydar.demirhan@rmit.edu.au&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides time series regression models with one predictor using finite distributed lag models, polynomial (Almon) distributed lag models, geometric distributed lag models with Koyck transformation, and autoregressive distributed lag models. It also consists of functions for computation of h-step ahead forecasts from these models. See Demirhan (2020)(&lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0228812">doi:10.1371/journal.pone.0228812</a>&gt;) and Baltagi (2011)(&lt;<a href="https://doi.org/10.1007%2F978-3-642-20059-5">doi:10.1007/978-3-642-20059-5</a>&gt;) for more information.</td>
</tr>
<tr>
<td>Depends:</td>
<td>graphics, stats, nardl, dynlm, R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>AER, formula.tools, plyr , lmtest, strucchange, wavethresh,
MASS, roll, sandwich</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-02 04:48:33 UTC; haydardemirhan</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-02 06:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dLagM-package'>
Implementation of Time Series Regression Models with Distributed Lag Models
</h2><span id='topic+dLagM-package'></span>

<h3>Description</h3>

<p>Provides time series regression models with one predictor using finite distributed lag models, polynomial (Almon) distributed lag models, geometric distributed lag models with Koyck transformation, and autoregressive distributed lag models. It also consists of functions for computation of h-step ahead forecasts from these models. See Demirhan (2020)(&lt;doi:10.1371/journal.pone.0228812&gt;) and Baltagi (2011)(&lt;doi:10.1007/978-3-642-20059-5&gt;) for more information.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> dLagM</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1.13</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-10-02</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>To implement time series regression with finite distributed lag models, use <code>dlm</code> function.
</p>
<p>To implement time series regression with polynomial distributed lag models, use <code>polyDlm</code> function. 
</p>
<p>To implement time series regression with geometric distributed lag models with Koyck transformation, use <code>koyckDlm</code> function. 
</p>
<p>To implement time series regression with autoregressive distributed lag models, use <code>ardlDlm</code> function. 
</p>
<p>To implement ARDL Bounds test, use <code>ardlBound</code> function. 
</p>
<p>To produce forecasts for any of the models, use <code>forecast</code> function.
</p>
<p>To summarise the results of a model fitting, use <code>summary</code> function.
</p>


<h3>Author(s)</h3>

<p>Haydar Demirhan (https://orcid.org/0000-0002-8565-4710)
</p>
<p>Maintainer: Haydar Demirhan &lt;haydar.demirhan@rmit.edu.au&gt;
</p>
<p>Acknowledgements: The author acknowledges the testing effort of of Dr. Rogerio Porto (https://orcid.org/0000-0002-6663-9531) on forecasting function.
</p>


<h3>References</h3>

<p>B.H. Baltagi. <em>Econometrics</em>, Fifth Ed. Springer, 2011.
</p>
<p>H. Demirhan. dLagM: An R package for distributed lag models and ARDL bounds testing. <em>PLoS ONE</em>, 15(2): e0228812, 2020. DOI: 10.1371/journal.pone.0228812.
</p>
<p>R.C. Hill, W.E. Griffiths, G.G. Judge. <em>Undergraduate Econometrics</em>. Wiley, 2000. 
</p>
<p>J. Soren, A.Q. Philips. &quot;pss: Perform bounds test for cointegration and perform dynamic simulations.&quot;
</p>
<p>P.K. Narayan. The Saving and Investment Nexus for China: Evidence from cointegration tests. <em>Applied Economics</em> 37(17):1979-1990, 2005.
</p>
<p>M.H. Pesaran, S. Yongcheol, R.J. Smith. Bounds testing approaches to the analysis of level relationships. <em>Journal of Applied Econometrics</em> 16(3):289-326, 2001.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dlm">dlm</a></code>, <code><a href="#topic+polyDlm">polyDlm</a></code>, <code><a href="#topic+koyckDlm">koyckDlm</a></code>, <code><a href="#topic+ardlDlm">ardlDlm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# --- For examples, please refer to specific functions ---
</code></pre>

<hr>
<h2 id='ardlBound'>
Implement ARDL bounds test
</h2><span id='topic+ardlBound'></span>

<h3>Description</h3>

<p>Applies ARDL bounds test with the approach of Pesaran et al. (2001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ardlBound(data = NULL, formula = NULL, case = 3, p = NULL,  
          remove = NULL, autoOrder = FALSE, HAC = FALSE,
          ic = c("AIC", "BIC", "MASE", "GMRAE"), max.p = 15, 
          max.q = 15, ECM = TRUE, stability = TRUE)         
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ardlBound_+3A_data">data</code></td>
<td>

<p>A <code>data.frame</code> including all dependent and independent series. Column names this <code>data.frame</code> must match the variable names in <code>formula</code>.
</p>
</td></tr>
<tr><td><code id="ardlBound_+3A_formula">formula</code></td>
<td>
<p>A <code>formula</code> object showing the dependent and independent series. 
</p>
</td></tr>
<tr><td><code id="ardlBound_+3A_case">case</code></td>
<td>

<p>An integer up to 5 showing the case number. See details.
</p>
</td></tr>
<tr><td><code id="ardlBound_+3A_p">p</code></td>
<td>

<p>An integer representing the order of short-run response or a <code>data.frame</code> to specify a different order of short-run response for each variable.  
</p>
</td></tr>
<tr><td><code id="ardlBound_+3A_remove">remove</code></td>
<td>

<p>A list showing the elements to be removed from the model. It includes elements <code>p</code> as a list and <code>q</code> as a vector. See details.
</p>
</td></tr>
<tr><td><code id="ardlBound_+3A_autoorder">autoOrder</code></td>
<td>

<p>If <code>TRUE</code>, the order of ARDL will be found by the <code>ardlBounOrders</code> function.
</p>
</td></tr>
<tr><td><code id="ardlBound_+3A_hac">HAC</code></td>
<td>

<p>If <code>TRUE</code>, the Newey-West estimate of variance-covariance function is used in testing.
</p>
</td></tr>
<tr><td><code id="ardlBound_+3A_ic">ic</code></td>
<td>

<p>Information criterion to be used in the search for optimal orders.
</p>
</td></tr>
<tr><td><code id="ardlBound_+3A_max.p">max.p</code></td>
<td>

<p>Maximum order for the short-run coefficients.
</p>
</td></tr>
<tr><td><code id="ardlBound_+3A_max.q">max.q</code></td>
<td>

<p>Maximum auto-regressive order.
</p>
</td></tr>
<tr><td><code id="ardlBound_+3A_ecm">ECM</code></td>
<td>

<p>If <code>TRUE</code>, the error correction model corresponding to the <code>case</code> is also fitted and included in the outputs.
</p>
</td></tr>
<tr><td><code id="ardlBound_+3A_stability">stability</code></td>
<td>

<p>If both <code>ECM</code> and <code>stability</code> are <code>TRUE</code>, the CUSUM, CUSUM of squares, and MOSUM charts are generated over recursive residuals using the package <code>strucchange</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>case</code> takes the values 1 for &quot;no intercept, no trend&quot;, 2 for &quot;restricted intercept, no trend&quot;, 3 for &quot;unrestricted intercept, no trend&quot;, 
4 for &quot;unrestricted intercept, restricted trend&quot;, and 5 for &quot;unrestricted intercept, unrestricted trend.&quot; 
</p>
<p>If the argument <code>p</code> is entered as an integer, the same value is used to specify the order of short-run response for all variables.
</p>
<p>We follow the formulation of Pesaran et al. (2001). So, the upper limit of summations in the model formulation goes up to (p-1). User should consider this while setting the value(s) of <code>p</code>.
</p>
<p>The names of the element <code>p</code> of <code>remove</code> must match with those in the model. For example, to remove lags 2 and 4 of the first differences of X1 and X2 and remove the lags 2 and 5 of the dependent series, <code>remove</code> should be defined as <code>remove = list( p = list(dX1 = c(2,4), dX2 = c(2,4)), q = c(2,5) )</code>.
</p>
<p>Breusch-Godfrey and Ljung-Box tests are applied to test against the existence of autocorrelations in residuals and Breusch-Pagan test is applied to detect heteroskedasticity in residuals as a part of the bounds testing procedure. Ramsey's RESET test is conducted for correctness of functional form of the model.
</p>
<p>The recursive CUSUM chart is plotted by <code>epf</code> function from the <code>strucchange</code> package. The recursive CUSUM of squares plot is plotted by the <code>ardlBound</code> function using the recursive residuals generated by <code>recresid</code> function of <code>strucchange</code> package. The testing limits on the recursive CUSUM of squares plot are calculated as described by Brown et al. (1975) based in Table 1 of Durbin (1969). The recursive MOSUM chart is plotted when there is no NA MOSUM values are calculated.
</p>


<h3>Value</h3>

<table>
<tr><td><code>model</code></td>
<td>
<p>An object including the fitted model under the null and alternative hypotheses.</p>
</td></tr>
<tr><td><code>F.stat</code></td>
<td>
<p>The value of F-statistic coming out of the Wald test.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>p-orders in the lag structure.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>The number of independent series.</p>
</td></tr> 
<tr><td><code>bg</code></td>
<td>
<p>Breusch-Godfrey test results. Returns <code>NULL</code> if skipped.</p>
</td></tr>
<tr><td><code>lb</code></td>
<td>
<p>Ljung-Box test results. Returns <code>NULL</code> if skipped.</p>
</td></tr>
<tr><td><code>bp</code></td>
<td>
<p>Breusch-Pagan test results. Returns <code>NULL</code> if skipped.</p>
</td></tr>
<tr><td><code>sp</code></td>
<td>
<p>Shapiro-Wilk test results. Returns <code>NULL</code> if skipped.</p>
</td></tr>
<tr><td><code>ECM</code></td>
<td>
<p>A list including the error correction series in the element <code>EC.t</code>, the fitted error correction model in the element <code>EC.model</code>, and the coefficient of error correction part in the element <code>EC.beta</code>.</p>
</td></tr>
<tr><td><code>ARDL.model</code></td>
<td>
<p>A model object including the fitted ARDL model. Use this model object to display the long-run coefficients. To see the significance test results for the logn-run coefficients, use <code>summary()</code> function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Haydar Demirhan
</p>
<p>Maintainer: Haydar Demirhan &lt;haydar.demirhan@rmit.edu.au&gt;
</p>


<h3>References</h3>

<p>R.L. Brown, J. Durbin, J. M. Evans. Techniques for testing the constancy of regression relationships over time. Journal of the Royal Statistical Society - Series B, 37, 2, 149-192.
</p>
<p>C-S. J. Chu, K. Hornik, C-M. Kuan. MOSUM tests for parameter constancy. Biometrika, 82, 603-617, 1995.
</p>
<p>J. Durbin. Tests for serial correlation in regression analysis based on the periodogram of Least-Squares residuals. Biometrika, 56, 1, 1-15.
</p>
<p>P.K. Narayan. The Saving and Investment Nexus for China: Evidence from Cointegration Tests. <em>Applied Economics</em> 37(17):1979-1990, 2005.
</p>
<p>M.H. Pesaran, S. Yongcheol, R.J. Smith. Bounds testing approaches to the analysis of level relationships. <em>Journal of Applied Econometrics</em> 16(3):289-326, 2001.
</p>
<p>J.B. Ramsey. Tests for specification error in classical linear Least Squares regression analysis. Journal of the Royal Statistical Society - Series B, 31, 350-371, 1969.
</p>
<p>J. Soren, A.Q. Philips. &quot;pss: Perform bounds test for cointegration and perform dynamic simulations.&quot;
</p>
<p>A. Zeileis, F. Leisch, K. Hornik, C. Kleiber. strucchange: An R package for testing for structural change in linear regression models. Journal of Statistical Software, 7, 1-38, 2002.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(M1Germany)
data &lt;- M1Germany[1:144,]
model &lt;- ardlBound(data = data , formula = logprice ~ interest + logm1 , case = 2 , p = 2)

# Let ardlBoundOrders() function find the orders
model &lt;- ardlBound(data = data , formula = logprice ~ interest + logm1 , case = 2 , 
                    max.p = 3, max.q = 3)

## End(Not run)
</code></pre>

<hr>
<h2 id='ardlBoundOrders'>
Find optimal orders (lag structure) for ARDL bounds test
</h2><span id='topic+ardlBoundOrders'></span>

<h3>Description</h3>

<p>Computes optimal orders (lag structure) for the short-run relationships and autoregressive part of the ARDL model prior to ARDL bounds test with the approach of Pesaran et al. (2001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ardlBoundOrders(data = NULL , formula = NULL, ic = c("AIC", "BIC", "MASE", 
               "GMRAE"), max.p = 15,  max.q = 15, FullSearch = FALSE  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ardlBoundOrders_+3A_data">data</code></td>
<td>

<p>A <code>data.frame</code> including all dependent and independent series. Column names this <code>data.frame</code> must match the variable names in <code>formula</code>.
</p>
</td></tr>
<tr><td><code id="ardlBoundOrders_+3A_formula">formula</code></td>
<td>
<p>A <code>formula</code> object showing the dependent and independent series. 
</p>
</td></tr>
<tr><td><code id="ardlBoundOrders_+3A_ic">ic</code></td>
<td>

<p>Information criterion to be used in the serach for optimal orders.
</p>
</td></tr>
<tr><td><code id="ardlBoundOrders_+3A_max.p">max.p</code></td>
<td>

<p>Maximum order for the short-run coefficients.
</p>
</td></tr>
<tr><td><code id="ardlBoundOrders_+3A_max.q">max.q</code></td>
<td>

<p>Maximum auto-regressive order.
</p>
</td></tr>
<tr><td><code id="ardlBoundOrders_+3A_fullsearch">FullSearch</code></td>
<td>

<p>If <code>TURE</code>, a search over all possbilble models is implemented. See the details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>FullSearch = FALSE</code>, this function first assumes that all p-orders are equal for the short-run relationships and finds the optimal p-order and autoregressive orders. Then, it finds the best subset of p-orders allowing them to change for each series in the short-run relationship part of the ARDL model under alternative hypothesis of ARDL bounds test. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>p</code></td>
<td>
<p>An <code>integer</code> or <code>data.frame</code> object including p-orders for the short-run relationship part.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>The autoregressive order.</p>
</td></tr>
<tr><td><code>Stat.table</code></td>
<td>
<p>The selected statistic of all the considered models where all short-run relationship orders (p-orders) are equal.</p>
</td></tr>
<tr><td><code>Stat.p</code></td>
<td>
<p>The selected statistic of all possible combinations of short-run relationship orders (p-orders). The reported lag structure is the one that gives the minimum value to the chosen statistic among these combinations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Haydar Demirhan
</p>
<p>Maintainer: Haydar Demirhan &lt;haydar.demirhan@rmit.edu.au&gt;
</p>

<hr>
<h2 id='ardlDlm'>
Implement finite autoregressive distributed lag model
</h2><span id='topic+ardlDlm'></span>

<h3>Description</h3>

<p>Applies autoregressive distributed lag models of order (p , q) with one predictor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ardlDlm(formula = NULL , data = NULL , x = NULL , y = NULL , p = 1 , q = 1 , 
         remove = NULL , type = NULL )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ardlDlm_+3A_formula">formula</code></td>
<td>
<p>A <code>formula</code> object for the model to be fitted. In the case of multiple predictor series, the model should be entered via a formula object. 
</p>
</td></tr>
<tr><td><code id="ardlDlm_+3A_data">data</code></td>
<td>

<p>A <code>data.frame</code> including all dependent and independent series. In the case of multiple predictor series, the data should be entered via the <code>data</code> argument.
</p>
</td></tr>
<tr><td><code id="ardlDlm_+3A_x">x</code></td>
<td>

<p>A vector including the observations of predictor time series. This is not restricted to <code>ts</code> objects.
</p>
</td></tr>
<tr><td><code id="ardlDlm_+3A_y">y</code></td>
<td>

<p>A vector including the observations of dependent time series. This is not restricted to <code>ts</code> objects.
</p>
</td></tr>
<tr><td><code id="ardlDlm_+3A_p">p</code></td>
<td>

<p>An integer representing finite lag length.  
</p>
</td></tr>
<tr><td><code id="ardlDlm_+3A_q">q</code></td>
<td>

<p>An integer representing the order of autoregressive process.
</p>
</td></tr>  
<tr><td><code id="ardlDlm_+3A_remove">remove</code></td>
<td>

<p>A list object having two elements showing the lags of independent series with <code>p</code> and the autoregressive lags with <code>q</code> to be removed from the full model for each independent series. Please see the details for the construction of this argument.
</p>
</td></tr>
<tr><td><code id="ardlDlm_+3A_type">type</code></td>
<td>

<p>An integer taking 1 if only x and y vectors are entered, 2 if a formula and data matrix is entered. It can be left <code>NULL</code> since the correct value is checked and fixed by the code.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The autoregressive DLM is a flexible and parsimonious infinite distributed lag model. The model ARDL<code class="reqn">(p, q)</code> is written as
</p>
<p style="text-align: center;"><code class="reqn">      Y_{t} = \mu+ \beta_{0}X_{t}+\beta_{1}X_{t-1}+\cdots +\beta_{p}X_{t-p}+\gamma_{1}Y_{t-1}+\cdots+\gamma_{q}Y_{t-q}+e_{t}.     </code>
</p>

<p>When there is only one predictor series, both of <code>model</code> and <code>formula</code> objects can be used. But when they are supplied, both <code>x</code> and <code>y</code> arguments should be <code>NULL</code>.
</p>
<p>The variable names in <code>formula</code> must match with the names of variables in <code>data</code> argument and it must be in the form of a generic formula for R functions. 
</p>
<p>The argument <code>data</code> contains dependent series and independent series. 
</p>
<p>The argument <code>remove = list(p = list() , q = c())</code> is used to specify which lags of each independent series and the autoregressive lags of dependent series will be removed from the full model. Each element of the list <code>p</code> shows particular lags that will be removed from each independent series. To remove the main series from the model or to fit a model ARDL(0,q), include <code>0</code> within the elements of <code>p</code>. The element <code>q</code> is just a vector showing the autoregressive lags of dependent series to be removed. 
</p>
<p>To remove the intercept from the model, if a <code>formula</code> is entered, just include &quot;-1&quot; in the model formula. Otherwise, include &quot;-1&quot; in the element <code>q</code> of the list <code>remove</code>. See the examples below for implementation details.
</p>
<p>The standard function <code>summary()</code> prints model summary for the model of interest.
</p>


<h3>Value</h3>

<table>
<tr><td><code>model</code></td>
<td>
<p>An object of class <code>lm</code>. See the details of <a href="https://stat.ethz.ch/R-manual/R-devel/library/stats/html/lm.html"><code>lm</code></a> function.</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p>A vector composed of <code class="reqn">p</code> and <code class="reqn">q</code> orders.</p>
</td></tr>
<tr><td><code>removed.p</code></td>
<td>
<p>A list or vector showing the lags of independent series to be removed from the full model.</p>
</td></tr>
<tr><td><code>removed.q</code></td>
<td>
<p>A vector showing the autoregressive lags to be removed from the full model.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>Model formula of the fitted model. This is returned if multiple independent series are entered.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>A <code>data.frame</code> including all dependent and independent series. This is returned if multiple independent series are entered.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Haydar Demirhan
</p>
<p>Maintainer: Haydar Demirhan &lt;haydar.demirhan@rmit.edu.au&gt;
</p>


<h3>References</h3>

<p>B.H. Baltagi. <em>Econometrics</em>, Fifth Ed. Springer, 2011.
</p>
<p>R.C. Hill, W.E. Griffiths, G.G. Judge. <em>Undergraduate Econometrics</em>. Wiley, 2000. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Only one independent series

data(seaLevelTempSOI)
model.ardl = ardlDlm(x = seaLevelTempSOI$LandOcean,  
                     y = seaLevelTempSOI$GMSL, p = 1 , q = 1 )
summary(model.ardl)
# residuals(model.ardl)
# coef(model.ardl)
# fitted(model.ardl)

# Remove some lags
rem.p = c(0,1) # 0 removes the main effect of X.t
rem.q = c(1,3) 
remove = list(p = rem.p , q = rem.q)
model.ardl = ardlDlm(x = seaLevelTempSOI$LandOcean,  
                     y = seaLevelTempSOI$GMSL, p = 2 , q = 3 , remove = remove)
summary(model.ardl)

# To remove intercept as well
rem.q = c(1,3,-1) 
remove = list(p = rem.p , q = rem.q)
model.ardl = ardlDlm(x = seaLevelTempSOI$LandOcean,  
                     y = seaLevelTempSOI$GMSL, p = 2 , q = 3 , remove = remove)
summary(model.ardl)

# Multiple independent series
data(M1Germany)
data = M1Germany[1:144,]
model.ardlDlm  = ardlDlm(formula = logprice ~ interest + logm1, 
                         data = data.frame(data) , p = 2 , q = 1 )
summary(model.ardlDlm)

# To remove intercept as well
model.ardlDlm  = ardlDlm(formula = logprice ~ -1 + interest + logm1, 
                         data = data.frame(data) , p = 2 , q = 1 )
summary(model.ardlDlm)

rem.p = list(interest = c(0,2) , logm1 = c(0))
# Remove the main series of interest and logm1 and the secont lag of 
# interest from the model
rem.q = c(1)
remove = list(p = rem.p , q = rem.q)
remove
model.ardlDlm  = ardlDlm(formula = logprice ~ interest + logm1, 
                         data = data.frame(data) , p = 2 , q = 2 , 
                         remove = remove)
summary(model.ardlDlm) 
</code></pre>

<hr>
<h2 id='dlm'>
Implement finite distributed lag model
</h2><span id='topic+dlm'></span>

<h3>Description</h3>

<p>Applies distributed lag models with one or multiple predictor(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlm(formula , data , x , y , q , remove , type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dlm_+3A_formula">formula</code></td>
<td>
<p>A <code>formula</code> object for the model to be fitted. In the case of multiple predictor series, the model should be entered via a formula object. 
</p>
</td></tr>
<tr><td><code id="dlm_+3A_data">data</code></td>
<td>
<p>  A <code>data.frame</code> including all dependent and independent series. In the case of multiple predictor series, the data should be entered via the <code>data</code> argument.
</p>
</td></tr>
<tr><td><code id="dlm_+3A_x">x</code></td>
<td>

<p>A vector including the observations of predictor time series. This is not restricted to <code>ts</code> objects. If the series are supplied by <code>data</code> 
</p>
</td></tr>
<tr><td><code id="dlm_+3A_y">y</code></td>
<td>

<p>A vector including the observations of dependent time series. This is not restricted to <code>ts</code> objects.
</p>
</td></tr> 
<tr><td><code id="dlm_+3A_q">q</code></td>
<td>

<p>An integer representing finite lag length.
</p>
</td></tr>  
<tr><td><code id="dlm_+3A_remove">remove</code></td>
<td>

<p>A list object showing the lags to be removed from the model for each independent series in its elements. Please see the details for the construction of this argument.
</p>
</td></tr>
<tr><td><code id="dlm_+3A_type">type</code></td>
<td>

<p>An integer taking 1 if only x and y vectors are entered, 2 if a formula and data matrix is entered. It can be left <code>NULL</code> since the correct value is checked and fixed by the code.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When a decision made on a variable, some of the related variables would be effected through time. For example, when income tax rate is increased, this would reduce expenditures of consumers on goods and services, which reduces profits of suppliers, which reduces the demand for productive inputs, which reduces the profits of the input suppliers, and so on (Judge and Griffiths, 2000). These effects occur over the future time periods; hence, they are distributed across the time.    
</p>
<p>In a distributed-lag model, the effect of an independent variable <code class="reqn">X</code> on a dependent variable <code class="reqn">Y</code> occurs over the time. Therefore, DLMs are dynamic models. A linear finite DLM with one independent variable is written as follows:
</p>
<p style="text-align: center;"><code class="reqn">
      Y_{t} = \alpha +\sum_{s = 0}^{q}\beta_{s}X_{t-s}+\epsilon_{t},
      </code>
</p>

<p>where <code class="reqn">\epsilon_{t}</code> is a stationary error term with <code class="reqn">E(\epsilon_{t})=0, Var(\epsilon_{t})=\sigma^{2},Cov(\epsilon_{t},\epsilon_{s})=0</code>.
</p>
<p>When there is only one predictor series, both of <code>model</code> and <code>formula</code> objects can be used. But when they are supplied, both <code>x</code> and <code>y</code> arguments should be <code>NULL</code>.
</p>
<p>The variable names in <code>formula</code> must match with the names of variables in <code>data</code> argument and it must be in the form of a generic formula for R functions. 
</p>
<p>The argument <code>data</code> contains dependent series and independent series. Required lags of dependent series are generated by the <code>dlm</code> function automatically. 
</p>
<p>The argument <code>remove = list()</code> is used to specify which lags will be removed from the full model. Each element of the list <code>remove</code> shows particular lags that will be removed from each independent series. Notice that it is possible to fit a model with different lag lengths for each independent series by removing the appropriate lags of independent series with <code>remove</code> argument. To remove the main series from the model include <code>0</code> within the elements of <code>remove</code>.
</p>
<p>To remove the intercept from the model, if a <code>formula</code> is entered, just include &quot;-1&quot; in the model formula. Otherwise, include &quot;-1&quot; in the element <code>remove</code> of the list <code>remove</code>. See the examples below for implementation details.
</p>
<p>The standard function <code>summary()</code> prints model summary for the model of interest.
</p>


<h3>Value</h3>

<table>
<tr><td><code>model</code></td>
<td>
<p>An object of class <code>lm</code>.</p>
</td></tr>
<tr><td><code>designMatrix</code></td>
<td>
<p>The design matrix composed of transformed z-variables.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>The number of independent series. This is returned if multiple independent series are entered.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>The lag length.</p>
</td></tr>
<tr><td><code>removed</code></td>
<td>
<p>A list or vector showing the removed lags from the model for independent series. Returns <code>NULL</code> if the fitted model is full.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>Model formula of the fitted model. This is returned if multiple independent series are entered.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>A <code>data.frame</code> including all dependent and independent series. This is returned if multiple independent series are entered.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Haydar Demirhan
</p>
<p>Maintainer: Haydar Demirhan &lt;haydar.demirhan@rmit.edu.au&gt;
</p>


<h3>References</h3>

<p>B.H. Baltagi. <em>Econometrics</em>, Fifth Ed. Springer, 2011.
</p>
<p>R.C. Hill, W.E. Griffiths, G.G. Judge. <em>Undergraduate Econometrics</em>. Wiley, 2000. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Only one independent series
data(seaLevelTempSOI)
model.dlm = dlm(x = seaLevelTempSOI$LandOcean,  
                y = seaLevelTempSOI$GMSL , q = 5)
summary(model.dlm)
residuals(model.dlm)
coef(model.dlm)
fitted(model.dlm)

removed = list(x = c(1))
model.dlm = dlm(x = seaLevelTempSOI$LandOcean,  
                y = seaLevelTempSOI$GMSL , q = 5,
                remove = removed)
summary(model.dlm)

# Remove intercept as well
removed = list(x = c(1,-1))
model.dlm = dlm(x = seaLevelTempSOI$LandOcean,  
                y = seaLevelTempSOI$GMSL , q = 5,
                remove = removed)
summary(model.dlm)

removed = list(x = c(0,1))
model.dlm = dlm(x = seaLevelTempSOI$LandOcean,  
                y = seaLevelTempSOI$GMSL , q = 5,
                remove = removed)
summary(model.dlm)

model.dlm = dlm(formula =  GMSL ~ LandOcean , 
                 data = seaLevelTempSOI , q = 5)
summary(model.dlm)

removed = list(x = c(0,1))
model.dlm = dlm(formula =  GMSL ~ LandOcean , 
               data = seaLevelTempSOI , q = 5,
                remove = removed)
summary(model.dlm)

# Remove intercept as well
removed = list(x = c(0,-1))
model.dlm = dlm(formula =  GMSL ~ LandOcean , 
                data = seaLevelTempSOI , q = 2,
                remove = removed)
summary(model.dlm)

# Multiple independent series
data(M1Germany)
data = M1Germany[1:144,]
model.dlm  = dlm(formula = logprice ~ interest + logm1, 
                 data = data.frame(data) , q = 4)
summary(model.dlm)

removed = list(interest = c(1,3), logm1 = c(2))
removed
model.dlm  = dlm(formula = logprice ~ interest + logm1, 
                 data = data.frame(data) , q = 4 , remove = removed)
summary(model.dlm)

removed = list(interest = c(0,1,3), logm1 = c(0,2))
removed
model.dlm  = dlm(formula = logprice ~ interest + logm1, 
                 data = data.frame(data) , q = 4 , remove = removed)
summary(model.dlm)

removed = list( logm1 = c(1,2))
removed
model.dlm  = dlm(formula = logprice ~ interest + logm1, 
                 data = data.frame(data) , q = 4 , remove = removed)
summary(model.dlm)
</code></pre>

<hr>
<h2 id='finiteDLMauto'>
Find the optimal lag length for finite DLMs
</h2><span id='topic+finiteDLMauto'></span>

<h3>Description</h3>

<p>Fits finite DLMs for a range of lag lengths and orders the fitted models according to a desired measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finiteDLMauto(formula , data, x, y, q.min = 1, q.max = 10, k.order = NULL, 
              model.type = c("dlm","poly"), error.type = c("MASE","AIC",
                            "BIC","GMRAE", "MBRAE", "radj"), 
              trace = FALSE , type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="finiteDLMauto_+3A_formula">formula</code></td>
<td>
<p>A <code>formula</code> object for the model to be fitted. In the case of multiple predictor series, the model should be entered via a formula object.
</p>
</td></tr>
<tr><td><code id="finiteDLMauto_+3A_data">data</code></td>
<td>
<p>  A <code>data.frame</code> including all dependent and independent series. In the case of multiple predictor series, the data should be entered via the <code>data</code> argument.
</p>
</td></tr>
<tr><td><code id="finiteDLMauto_+3A_x">x</code></td>
<td>

<p>A vector including the observations of predictor time series. This is not restricted to <code>ts</code> objects.
</p>
</td></tr>
<tr><td><code id="finiteDLMauto_+3A_y">y</code></td>
<td>

<p>A vector including the observations of dependent time series. This is not restricted to <code>ts</code> objects.
</p>
</td></tr>
<tr><td><code id="finiteDLMauto_+3A_q.min">q.min</code></td>
<td>

<p>An integer representing the lower limit of the range of lag lengths to be considered. If missing, it will be set to 1.
</p>
</td></tr>
<tr><td><code id="finiteDLMauto_+3A_q.max">q.max</code></td>
<td>

<p>An integer representing the upper limit of the range of lag lengths to be considered. If missing, it will be set to 10.
</p>
</td></tr>
<tr><td><code id="finiteDLMauto_+3A_k.order">k.order</code></td>
<td>

<p>An integer representing order of polynomial distributed lags.
</p>
</td></tr>
<tr><td><code id="finiteDLMauto_+3A_model.type">model.type</code></td>
<td>

<p>The type of model to be fitted. If set to <code>dlm</code>, finite distributed lag models are fitted. If set to <code>poly</code>, polynomial distributed lag models are fitted. 
</p>
</td></tr>
<tr><td><code id="finiteDLMauto_+3A_error.type">error.type</code></td>
<td>

<p>The type of goodness-of-fit measure to be used for the selection of optimal lag length. The optimal lag length is determined according to desired goodness-of-fit measure.
</p>
</td></tr>
<tr><td><code id="finiteDLMauto_+3A_trace">trace</code></td>
<td>

<p>If <code>TRUE</code>, prints all of the goodness-of-fit measures for all fitted models.
</p>
</td></tr>  
<tr><td><code id="finiteDLMauto_+3A_type">type</code></td>
<td>

<p>An integer taking 1 if only x and y vectors are entered, 2 if a formula and data matrix is entered. It can be left <code>NULL</code> since the correct value is checked and fixed by the code.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When there is only one predictor series, both of <code>model</code> and <code>formula</code> objects can be used. But when they are supplied, both <code>x</code> and <code>y</code> arguments should be <code>NULL</code>.
</p>
<p>The variable names in <code>formula</code> must match with the names of variables in <code>data</code> argument and it must be in the form of a generic formula for R functions. 
</p>
<p>The argument <code>data</code> contains dependent series and independent series. Required lags of dependent series are generated by the <code>dlm</code> function automatically. 
</p>
<p>If <code>q.max</code> is entered greater than the length of the series, its value will be adjusted to have the length of the series for fitting the regression model.
</p>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> including the values of goodness-of-fit measures and corresponding lag lengths.
</p>


<h3>Author(s)</h3>

<p>Agung Andiojaya &lt;agung.andiojaya@gmail.com&gt;, Haydar Demirhan 
</p>
<p>Maintainer: Haydar Demirhan &lt;haydar.demirhan@rmit.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(dLagM)
# Multiple independent series
data(M1Germany)
data = M1Germany[1:44,]
# Run the search over finite DLMs according to AIC values
finiteDLMauto(formula = logprice ~ interest + logm1, 
              data = data.frame(data), q.min = 2, q.max = 5, 
              model.type = "dlm", error.type = "AIC", trace = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='forecast'>
Compute forecasts for distributed lag models
</h2><span id='topic+forecast'></span>

<h3>Description</h3>

<p>Computes forecasts for the finite distributed lag models, autoregressive distributed lag models, Koyck transformation of distributed lag models, and polynomial distributed lag models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forecast(model , x , h = 1 , interval = FALSE, level = 0.95 , nSim = 500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast_+3A_model">model</code></td>
<td>

<p>A fitted model by one of <code>dlm(), koyckDlm(), ployDlm()</code> or <code>ardlDlm</code> functions.
</p>
</td></tr>
<tr><td><code id="forecast_+3A_x">x</code></td>
<td>

<p>A vector or matrix including the new observations of independent time series. This is not restricted to <code>ts</code> objects. Please see the details for construction of this argument.
</p>
</td></tr> 
<tr><td><code id="forecast_+3A_h">h</code></td>
<td>

<p>The number of ahead forecasts.
</p>
</td></tr>  
<tr><td><code id="forecast_+3A_interval">interval</code></td>
<td>

<p>If <code>TRUE</code>, <code class="reqn">(1-\alpha)\%</code> prediction intervals for forecasts are displayed along with forecasts.
</p>
</td></tr>
<tr><td><code id="forecast_+3A_level">level</code></td>
<td>

<p>Confidence level of prediction interval. 
</p>
</td></tr>
<tr><td><code id="forecast_+3A_nsim">nSim</code></td>
<td>

<p>An integer showing the number of Monte Carlo simulations used to compute prediction intervals for forecasts.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function directly uses the model formula and estimates of model coefficients to find forecast one-by-one starting from the one-step ahead forecast. 
</p>
<p>Prediction intervals are found by the Monte Carlo approach using a Gaussian error distribution with zero mean and empirical variance of the dependent series.
</p>
<p>When the <code>model</code> argument includes multiple independent series, <code>x</code> must be entered as a matrix including the new observations of each independent series in its rows. The number of columns of <code>x</code> must be equal to the forecast horizon <code>h</code> and the rows of <code>x</code> must match with the independent series in the order they appear in the <code>data</code>.
</p>
<p>When <code>x</code> and <code>y</code> are used to fit the model and some elements of the model are removed, you must use <code>model</code> and <code>formula</code> instead of <code>x</code> and <code>y</code> to fit the model and send the new data as a matrix into the forecast() function.
</p>
<p>This function can still be used when some of the lags of independent series are removed from the model.
</p>


<h3>Value</h3>

<table>
<tr><td><code>forecasts</code></td>
<td>
<p>A vector including forecasts.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Haydar Demirhan
</p>
<p>Maintainer: Haydar Demirhan &lt;haydar.demirhan@rmit.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Only one independent series
data(seaLevelTempSOI)
#--- ARDL dlm ---
model.ardl = ardlDlm(x = seaLevelTempSOI$LandOcean,  y = seaLevelTempSOI$GMSL, p = 1 , q = 1 )
forecast(model = model.ardl , x = c(0.15, 0.45) , 
                h = 2 , interval = FALSE)
forecast(model = model.ardl , x = c(0.15, 0.45, 0.20) , 
                h = 3 , interval = FALSE)
             
# Multiple independent series
data(M1Germany)
data = M1Germany[1:144,]
model.ardlDlm1  = ardlDlm(formula = logprice ~ interest + logm1, 
       data = data.frame(data) , p = 2 , q = 1 )
x.new =  matrix(c(0.07 , 9.06 , 0.071 , 9.09, 0.08, 9.2), ncol = 3, 
                nrow = 2)
forecast(model = model.ardlDlm1 , x = x.new , h = 3 , 
                interval = TRUE, nSim = 100)       
       
rem.p = list(interest = c(1,2))
rem.q = c(1)
remove = list(p = rem.p , q = rem.q)
model.ardlDlm2  = ardlDlm(formula = logprice ~ interest + logm1, 
       data = data.frame(data) , p = 2 , q = 2 , 
       remove = remove)

forecast(model = model.ardlDlm2 , x = x.new , h = 2 , 
                interval = FALSE)  
                
#--- Finite dlm ---                
model.dlm = dlm(x = seaLevelTempSOI$LandOcean,  y = seaLevelTempSOI$GMSL,
                q = 2)
forecast(model = model.dlm , x = c(0.15, 0.45, 0.20) , h = 3)


# Multiple independent series
model.dlm  = dlm(formula = logprice ~ interest + logm1, 
          data = data.frame(data) , q = 4)

x.new =  matrix(c(0.07 , 9.06 , 0.071 , 9.09), 
                ncol = 2, nrow = 2)
forecast(model = model.dlm , x = x.new , h = 2 , 
            interval = FALSE)

# Some lags are removed:
# Remove lags 0 and 2 from "interest" and 
# lags 1 and 3 from "logm1"
removed = list(interest = c(0,2), logm1 = c(1,3))
removed
model.dlm  = dlm(formula = logprice ~ interest + logm1 -1, 
              data = data.frame(data) , q = 4 , remove = removed)

x.new =  matrix(c(0.07 , 9.06 , 0.071 , 9.09 , 0.079 , 9.19 , 
                  0.069 , 9.21) , ncol = 4, nrow = 2)
forecast(model = model.dlm , x = x.new , h = 4 , 
         interval = FALSE)
forecast(model = model.dlm , x = x.new , h = 4 , 
            interval = FALSE)
  
x.new =  matrix(c(0.07 , 9.06 , 0.071 , 9.09, 0.08 , 9.12), ncol = 3, 
                nrow = 2)
forecast(model = model.dlm , x = x.new , h = 3,  interval = FALSE)

#--- Koyck dlm --- 
model.koyck = koyckDlm(x = seaLevelTempSOI$LandOcean,  y = seaLevelTempSOI$GMSL)
forecast(model = model.koyck  , x = c(0.15, 0.45, 0.20), h = 3 , 
                interval = FALSE)

#--- Polynomial dlm ---         
model.poly = polyDlm(x = seaLevelTempSOI$LandOcean,  y = seaLevelTempSOI$GMSL, 
                q = 2 , k = 2 , show.beta = TRUE)
forecast(model = model.poly , x = c(0.15, 0.45) , h = 1 , 
                interval = FALSE)


## End(Not run)
</code></pre>

<hr>
<h2 id='GoF'>
Compute goodness-of-fit measures for DLMs
</h2><span id='topic+GoF'></span><span id='topic+MASE'></span><span id='topic+sMAPE'></span><span id='topic+MAPE'></span><span id='topic+MRAE'></span><span id='topic+GMRAE'></span><span id='topic+MBRAE'></span>

<h3>Description</h3>

<p>Computes mean absolute error (MAE), mean squared error (MSE), mean percentage error (MPE), symmetric mean absolute percentage error (sMAPE), mean absolute percentage error (MAPE), mean absolute scaled error (MASE), mean relative absolute error (MRAE), geometric mean relative absolute error (GMRAE), mean bounded relative absolute error (MBRAE), unscaled MBRAE (UMBRAE) for distributed lag models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GoF(model, ...)
MASE(model, ...)
sMAPE(model, ...)
MAPE(model, ...)
MRAE(model, ...)
GMRAE(model, ...)
MBRAE(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GoF_+3A_model">model</code></td>
<td>

<p>Model object fitted for time series data. 
</p>
</td></tr>
<tr><td><code id="GoF_+3A_...">...</code></td>
<td>

<p>Optionally, more fitted models.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>See Chen et al. (2017) for the definitions of MSE, MAE, MAPE, sMAPE, MRAE, GMRAE, MBRAE, UMBMRAE.
</p>
<p>Let <code class="reqn">e_{t} = Y_{t}-\hat{Y}_{t}</code> be the one-step-ahead forecast error. Then, a scaled error is defined as
</p>
<p style="text-align: center;"><code class="reqn">
q_{t}=\frac{e_{t}}{\frac{1}{n-1}\sum_{i=2}^{n}|Y_{i}-Y_{i-1}|},
</code>
</p>

<p>which is independent of the scale of the data. Mean absolute scaled error is defined as 
</p>
<p style="text-align: center;"><code class="reqn">
MASE = mean(|q_{t}|)
</code>
</p>

<p>(Hyndman and Koehler, 2006).
</p>
<p>Fitted models would be finite, polynomial, Koyck, ARDL DLMs, or linear model fitted with <code>lm()</code> function. This function also computes MASE values of multiple models when fed at the same time.
</p>


<h3>Author(s)</h3>

<p>Haydar Demirhan
</p>
<p>Maintainer: Haydar Demirhan &lt;haydar.demirhan@rmit.edu.au&gt;
</p>


<h3>References</h3>

<p>Chen, C.,  Twycross, J., Garibaldi, J.M. (2017). A new accuracy measure based on bounded relative error for time series forecasting. <em>PLoS ONE</em>,
12(3), e0174202.
</p>
<p>Hyndman, R.J. and Koehler, A.B. (2006). Another look at measures of forecast accuracy. <em>International Journal of Forecasting</em>, 22, 679-688.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(seaLevelTempSOI)
# Fit a bunch of polynomial DLMs
model.poly1 = polyDlm(x = seaLevelTempSOI$LandOcean, y = seaLevelTempSOI$GMSL, 
                     q = 2 , k = 2 , show.beta = TRUE)
model.poly2 = polyDlm(x = seaLevelTempSOI$LandOcean, y = seaLevelTempSOI$GMSL, 
                      q = 3 , k = 2 , show.beta = TRUE)
model.poly3 = polyDlm(x = seaLevelTempSOI$LandOcean, y = seaLevelTempSOI$GMSL, 
                      q = 4 , k = 2 , show.beta = TRUE)
MASE(model.poly1, model.poly2, model.poly3)

# Fit a bunch of finite DLMs
model.dlm1 = dlm(x = seaLevelTempSOI$LandOcean, y = seaLevelTempSOI$GMSL, q =2)
model.dlm2 = dlm(x = seaLevelTempSOI$LandOcean, y = seaLevelTempSOI$GMSL, q =3)
model.dlm3 = dlm(x = seaLevelTempSOI$LandOcean, y = seaLevelTempSOI$GMSL, q =4)
MASE(model.dlm1, model.dlm2, model.dlm3)
MBRAE(model.dlm1, model.dlm2, model.dlm3)
GoF(model.dlm1, model.dlm2, model.dlm3)

# Fit a linear model
model.lm = lm(GMSL ~ LandOcean , data = seaLevelTempSOI)
MASE(model.lm)
GoF(model.lm)

# Fit a Koyck model
model.koyck = koyckDlm(x = seaLevelTempSOI$LandOcean, y = seaLevelTempSOI$GMSL)
MASE(model.koyck)
GoF(model.koyck)

# Fit a bunch of ARDLs
model.ardl1 = ardlDlm(x = seaLevelTempSOI$LandOcean, y = seaLevelTempSOI$GMSL, p=1, q=2)
model.ardl2 = ardlDlm(x = seaLevelTempSOI$LandOcean, y = seaLevelTempSOI$GMSL, p=2, q=2)
model.ardl3 = ardlDlm(x = seaLevelTempSOI$LandOcean, y = seaLevelTempSOI$GMSL, p=3, q=2)
MASE(model.ardl1 , model.ardl2 , model.ardl3)
GoF(model.ardl1 , model.ardl2 , model.ardl3)

# Find MASEs of different model objects
MASE(model.ardl1 , model.dlm1 , model.poly1, model.lm)
GoF(model.ardl1 , model.dlm1 , model.poly1, model.lm)

## End(Not run)
</code></pre>

<hr>
<h2 id='grainProduction'>World oats, corn, rice, wheat production, CO2 emissions, temperature anomalies, cropland data</h2><span id='topic+grainProduction'></span>

<h3>Description</h3>

<p>This data set is composed of annual world total CO2 emissions, oats, corn, rice, and wheat production, cropland area, and annual average temperature anomalies series between 1961 and 2018.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(grainProduction)</code></pre>


<h3>Format</h3>

<p>Multiple time series
</p>
<p><code>CO2(Tons)</code> column shows the global mean annual carbon dioxide (CO2) emissions measured in tons.
</p>
<p><code>Land-OceanTempIndex(C)</code> column shows the land-ocean temperature index without smoothing.
</p>
<p><code>Cropland(1Mha)</code> column shows the annual cropland area in the world scale in million hectares.
</p>
<p><code>Oats(1Mt)</code> column shows the annual world oats production in million tons.
</p>
<p><code>Corn(1Mt)</code> column shows the annual world corn production in million tons.
</p>
<p><code>Rice(1Mt)</code> column shows the annual world rice production in million tons.
</p>
<p><code>Wheat(1Mt)</code> column shows the annual world wheat production in million tons.
</p>


<h3>Source</h3>

<p>CO2 emissions data: Hannah Ritchie and Max Roser (2020) - &quot;CO2 and Greenhouse Gas Emissions&quot;. Published online at OurWorldInData.org.
</p>
<p>Temperature anomalies data: NASA
</p>
<p>Grain production data: United States Department of Agriculture, Foreign Agricultural Service
</p>
<p>Cropland data: Food and Agriculture Organization of United Nations
</p>


<h3>References</h3>

<p>CO2 emissions data: https://ourworldindata.org/co2-and-other-greenhouse-gas-emissions
</p>
<p>Temperature anomalies: https://climate.nasa.gov/vital-signs/global-temperature/
</p>
<p>Grain production data: psd_grains_pulses.csv from https://apps.fas.usda.gov/psdonline/app/index.html#/app/downloads
</p>
<p>Cropland data: https://www.fao.org/faostat/en/#data/RL/visualize
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grainProduction)
oatsProduction.ts = ts(grainProduction[,5], start = 1961)
plot(oatsProduction.ts, main="Time series plot 
of world oats production series.")
</code></pre>

<hr>
<h2 id='koyckDlm'>
Implement distributed lag models with Koyck transformation
</h2><span id='topic+koyckDlm'></span>

<h3>Description</h3>

<p>Applies distributed lag models with Koyck transformation with one predictor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>koyckDlm(x , y , intercept)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="koyckDlm_+3A_x">x</code></td>
<td>

<p>A vector including the observations of predictor time series. This is not restricted to <code>ts</code> objects.
</p>
</td></tr>
<tr><td><code id="koyckDlm_+3A_y">y</code></td>
<td>

<p>A vector including the observations of dependent time series. This is not restricted to <code>ts</code> objects.
</p>
</td></tr>
<tr><td><code id="koyckDlm_+3A_intercept">intercept</code></td>
<td>

<p>Set to <code>TRUE</code> to inclue intercept in the model.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To deal with infinite DLMs, we can use the Koyck transformation. When we apply Koyck transformation, we get the following:
</p>
<p style="text-align: center;"><code class="reqn">
      Y_{t} - \phi Y_{t-1}  = \alpha (1-\phi)+\beta X_{t} + (\epsilon_{t}-\phi \epsilon_{t-1}).
      </code>
</p>

<p>When we solve this equation for <code class="reqn">Y_{t}</code>, we obtain Koyck DLM as follows:
</p>
<p style="text-align: center;"><code class="reqn">
 Y_{t} = \delta_{1} + \delta_{2} Y_{t-1} + \delta_{3} X_{t} + \nu_{t},
</code>
</p>

<p>where <code class="reqn">\delta_{1} = \alpha (1-\phi),\delta_{2}=\phi,\delta_{3}=\beta</code> and the random error after the transformation is <code class="reqn">\nu_{t}=(\epsilon_{t}-\phi \epsilon_{t-1})</code> (Judge and Griffiths, 2000).
</p>
<p>Then, instrumental variables estimation is employed to fit the model.
</p>
<p>The standard function <code>summary()</code> prints model summary for the model of interest.
</p>
<p>AIC/BIC of a fitted KOyck model is displayed by setting the <code>class</code> attribute of model to <code>lm</code>. See the example.
</p>


<h3>Value</h3>

<table>
<tr><td><code>model</code></td>
<td>
<p>An object of class <code>ivreg</code>. See the details of <a href="https://www.rdocumentation.org/packages/AER/versions/1.2-5/topics/ivreg"><code>ivreg</code></a> function.</p>
</td></tr>
<tr><td><code>geometric.coefficients</code></td>
<td>
<p>A vector composed of corresponding geometric distributed lag model coefficients.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Haydar Demirhan
</p>
<p>Maintainer: Haydar Demirhan &lt;haydar.demirhan@rmit.edu.au&gt;
</p>


<h3>References</h3>

<p>B.H. Baltagi. <em>Econometrics</em>, Fifth Ed. Springer, 2011.
</p>
<p>R.C. Hill, W.E. Griffiths, G.G. Judge. <em>Undergraduate Econometrics</em>. Wiley, 2000. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(seaLevelTempSOI)
model.koyck = koyckDlm(x = seaLevelTempSOI$LandOcean,  
                       y = seaLevelTempSOI$GMSL)
summary(model.koyck, diagnostics = TRUE)     
residuals(model.koyck)
coef(model.koyck)
fitted(model.koyck)
AIC(model.koyck)
BIC(model.koyck)
</code></pre>

<hr>
<h2 id='polyDlm'>
Implement finite polynomial distributed lag model
</h2><span id='topic+polyDlm'></span>

<h3>Description</h3>

<p>Applies polynomial distributed lag models with one predictor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyDlm(x , y , q , k , show.beta = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polyDlm_+3A_x">x</code></td>
<td>

<p>A vector including the observations of predictor time series. This is not restricted to <code>ts</code> objects.
</p>
</td></tr>
<tr><td><code id="polyDlm_+3A_y">y</code></td>
<td>

<p>A vector including the observations of dependent time series. This is not restricted to <code>ts</code> objects.
</p>
</td></tr> 
<tr><td><code id="polyDlm_+3A_q">q</code></td>
<td>

<p>An integer representing finite lag length.
</p>
</td></tr>  
<tr><td><code id="polyDlm_+3A_k">k</code></td>
<td>

<p>An integer representing order of polynomial distributed lags.
</p>
</td></tr>
<tr><td><code id="polyDlm_+3A_show.beta">show.beta</code></td>
<td>

<p>If <code>TRUE</code>, generates original beta parameters and associated t-tests and prints the results.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Finite distributed lag models, in general, suffer from the multicollinearity due to inclusion of the lags of the same variable in the model. To reduce the impact of this multicollinearity, a polynomial shape is imposed on the lag distribution (Judge and Griffiths, 2000). The resulting model is called Polynomial Distributed Lag model or Almond Distributed Lag Model. 
</p>
<p>Imposing a polynomial pattern on the lag distribution is equivalent to representing <code class="reqn">\beta</code> parameters with another $k$th order polynomial model of time. So, the effect of change in <code class="reqn">X_{t-s}</code> on the expected value of <code class="reqn">Y_{t}</code> is represented as follows:
</p>
<p style="text-align: center;"><code class="reqn">
  \frac{\partial E(Y_{t})}{\partial X_{t-s}}=\beta_{s}=\gamma_{0}+\gamma_{1}s+\gamma_{2}s^{2}+\cdots+\gamma_{k}s^{k}
</code>
</p>

<p>where <code class="reqn">s=0,\dots,q</code> (Judge and Griffiths, 2000). Then the model becomes:
</p>
<p style="text-align: center;"><code class="reqn">
  Y_{t} = \alpha +\gamma_{0}Z_{t0}+\gamma_{1}Z_{t1}+\gamma_{2}Z_{t2}+\cdots +\gamma_{k}Z_{tk}  + \epsilon_{t}.
</code>
</p>

<p>The standard function <code>summary()</code> prints model summary for the model of interest.
</p>


<h3>Value</h3>

<table>
<tr><td><code>model</code></td>
<td>
<p>An object of class <code>lm</code>.</p>
</td></tr>
<tr><td><code>designMatrix</code></td>
<td>
<p>The design matrix composed of transformed z-variables.</p>
</td></tr>
<tr><td><code>designMatrix.x</code></td>
<td>
<p>The design matrix composed of original x-variables.</p>
</td></tr>
<tr><td><code>beta.coefficients</code></td>
<td>
<p>Estimates and t-tests of original beta coefficients. This will be generated if <code>show.beta</code> is set to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Haydar Demirhan
</p>
<p>Maintainer: Haydar Demirhan &lt;haydar.demirhan@rmit.edu.au&gt;
</p>


<h3>References</h3>

<p>B.H. Baltagi. <em>Econometrics</em>, Fifth Ed. Springer, 2011.
</p>
<p>R.C. Hill, W.E. Griffiths, G.G. Judge. <em>Undergraduate Econometrics</em>. Wiley, 2000. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(seaLevelTempSOI)
model.poly = polyDlm(x = seaLevelTempSOI$LandOcean,  y = seaLevelTempSOI$GMSL , 
                     q = 4 , k = 2 , show.beta = TRUE)
summary(model.poly)
residuals(model.poly)
coef(model.poly)
fitted(model.poly)

</code></pre>

<hr>
<h2 id='rolCorPlot'>
PLot the rolling correlations
</h2><span id='topic+rolCorPlot'></span>

<h3>Description</h3>

<p>Plots the rolling correlations along with other required statistics to visualise the approach of Gershunov et al. (2001) to test the significance of signal from rolling correlation analysis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rolCorPlot(x , y , width, level = 0.95, main = NULL, 
           SDtest = TRUE, N = 500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rolCorPlot_+3A_x">x</code></td>
<td>

<p>A ts object.
</p>
</td></tr>
<tr><td><code id="rolCorPlot_+3A_y">y</code></td>
<td>

<p>A ts object.
</p>
</td></tr> 
<tr><td><code id="rolCorPlot_+3A_width">width</code></td>
<td>

<p>A numeric vector of window lengths of the rolling correlation analysis.
</p>
</td></tr> 
<tr><td><code id="rolCorPlot_+3A_level">level</code></td>
<td>

<p>Confidence level for intervals.
</p>
</td></tr> 
<tr><td><code id="rolCorPlot_+3A_main">main</code></td>
<td>

<p>The main title of the plot.
</p>
</td></tr> 
<tr><td><code id="rolCorPlot_+3A_sdtest">SDtest</code></td>
<td>

<p>Set to <code>TRUE</code> to run test the significance of signal from rolling correlation analysis along with plotting.
</p>
</td></tr> 
<tr><td><code id="rolCorPlot_+3A_n">N</code></td>
<td>

<p>An integer showing the number of series to be generated in Monte Carlo simulation.
</p>
</td></tr> 
</table>


<h3>Value</h3>

<table>
<tr><td><code>rolCor</code></td>
<td>

<p>A matrix showing rolling correlations for each <code>width</code> on its columns.
</p>
</td></tr>
<tr><td><code>rolcCor.avr.filtered</code></td>
<td>

<p>A vector showing average rolling correlations filtered by running median nonlinear filter against outliers.
</p>
</td></tr>
<tr><td><code>rolcCor.avr.raw</code></td>
<td>

<p>A vector showing unfiltered average rolling correlations.
</p>
</td></tr>
<tr><td><code>rolCor.sd</code></td>
<td>

<p>A vector showing standard deviations of rolling correlations for each <code>width</code>.
</p>
</td></tr>
<tr><td><code>rawCor</code></td>
<td>

<p>Pearson correlation between two series.
</p>
</td></tr>
<tr><td><code>sdPercentiles</code></td>
<td>

<p>Percentiles of MC distribution of standard deviations of rolling correlations as the test limits.
</p>
</td></tr>
<tr><td><code>test</code></td>
<td>

<p>A data frame showing the standard deviations of rolling correlations for each <code>width</code> along with <code>level</code> and (1-<code>level</code>) limits.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Haydar Demirhan
</p>
<p>Maintainer: Haydar Demirhan &lt;haydar.demirhan@rmit.edu.au&gt;
</p>


<h3>References</h3>

<p>Gershunov, A., Scheider, N., Barnett, T. (2001). Low-Frequency Modulation of the ENSO-Indian Monsoon Rainfall Relationship: Signal or Noise? <em>Journal of Climate</em>, 14, 2486 - 2492.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(wheat)
prod.ts &lt;-ts(wheat[,5], start = 1960)
CO2.ts &lt;- ts(wheat[,2], start = 1960)
rolCorPlot(x = prod.ts, y = CO2.ts , width = c(7, 11, 15), level = 0.95, N = 50)

## End(Not run)
</code></pre>

<hr>
<h2 id='sdPercentiles'>
Test the significance of signal from rolling correlation analysis
</h2><span id='topic+sdPercentiles'></span>

<h3>Description</h3>

<p>Implements the approach of Gershunov et al. (2001) to test the significance of signal from rolling correlation analysis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdPercentiles(n = 150, cor = 0.5, width = 5, N = 500, 
              percentiles = c(.05, .95))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdPercentiles_+3A_n">n</code></td>
<td>

<p>The length of the series in the rolling correlation analysis.
</p>
</td></tr>
<tr><td><code id="sdPercentiles_+3A_cor">cor</code></td>
<td>

<p>The magnitude of raw correaltion betweeen two time series in the rolling correlation analysis.
</p>
</td></tr> 
<tr><td><code id="sdPercentiles_+3A_width">width</code></td>
<td>

<p>Window length of the rolling correlation analysis.
</p>
</td></tr> 
<tr><td><code id="sdPercentiles_+3A_n">N</code></td>
<td>

<p>Number of Monte Carlo replications for simulations.
</p>
</td></tr> 
<tr><td><code id="sdPercentiles_+3A_percentiles">percentiles</code></td>
<td>

<p>Percentiles to be reported for the Monte Carlo distribution of standard deviations of rolling correlations for the given window width.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p><code>N</code> samples of correlated white noise series are generated with a magnitude of <code>cor</code>; rolling correlations analysis is applied with the window length of <code>width</code>; Monte Carlo distribution of standard deviations of rolling correlations are generated; and desired <code>percentiles</code> of the MC distribution of standard deviations are reported (Gershunov et al. 2001). 
</p>


<h3>Value</h3>

<table>
<tr><td><code>rollCorSd.limits</code></td>
<td>

<p>Percentiles of MC distribution of standard deviations of rolling correlations as the test limits.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Haydar Demirhan
</p>
<p>Maintainer: Haydar Demirhan &lt;haydar.demirhan@rmit.edu.au&gt;
</p>


<h3>References</h3>

<p>Gershunov, A., Scheider, N., Barnett, T. (2001). Low-Frequency Modulation of the ENSO-Indian Monsoon Rainfall Relationship: Signal or Noise? <em>Journal of Climate</em>, 14, 2486 - 2492.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sdPercentiles(n = 50, cor = 0.5, width = 5, N = 50, 
#              percentiles = c(.025, .975))
</code></pre>

<hr>
<h2 id='seaLevelTempSOI'>Global mean sea level (GMSL), mean land and ocean temperature anomalies, and Southern Oscillation Index (SOI) data</h2><span id='topic+seaLevelTempSOI'></span>

<h3>Description</h3>

<p>This data set is composed of monthly global mean sea level (compared to 1993-2008 average) series by CSIRO, land ocean temperature anomalies (1951-1980 as a baseline period) by GISS, NASA, and monthly Southern Oscillation Index (SOI) by Australian Government Bureau of Meteorology (BOM) between July 1885 and June 2013. GMSL and temperature anomalies series are smoothed and seasonally adjusted.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(seaLevelTempSOI)</code></pre>


<h3>Format</h3>

<p>Multiple time series</p>


<h3>Source</h3>

<p>Goddard Institute for Space Studies, NASA, US.
Marine and Atmospheric Research, CSIRO, Australia.
Australian Government Bureau of Meteorology (BOM).
</p>


<h3>References</h3>

<p>Church, J. A. and N.J. White (2011), Sea-level rise from the late 19th to the early 21st Century. Surveys in Geophysics, doi:10.1007/s10712-011-9119-1.
</p>
<p>https://www.cmar.csiro.au/sealevel/sl_data_cmar.html
</p>
<p>https://data.giss.nasa.gov/gistemp/graphs_v4/
</p>
<p>https://www.bom.gov.au/climate/current/soihtm1.shtml
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(seaLevelTempSOI)
level.ts &lt;- ts(seaLevelTempSOI[,1], start = c(1880,7), freq = 12)
temp.ts &lt;- ts(seaLevelTempSOI[,2], start = c(1880,7), freq = 12)
plot(level.ts, main="Time series plot of GMSL series.")
</code></pre>

<hr>
<h2 id='sortScore'>
Sort AIC, BIC, MASE, MAPE, sMAPE, MRAE, GMRAE, or MBRAE scores
</h2><span id='topic+sortScore'></span>

<h3>Description</h3>

<p>Displays sorted AIC, BIC, and MASE scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortScore(x, score = c("bic", "aic", "mase", "smape", "mape", "mrae", "gmrae", "mbrae"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortScore_+3A_x">x</code></td>
<td>

<p>A vector of AIC, BIC, MASE, MAPE, sMAPE, MRAE, GMRAE, or MBRAE values.
</p>
</td></tr>
<tr><td><code id="sortScore_+3A_score">score</code></td>
<td>

<p>The type of scores to be sorted.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function sorts the AIC, BIC, MASE, MAPE, sMAPE, MRAE, GMRAE, or MBRAE scores to display the smallest one at the top of a bunch of AIC, BIC, MASE, MAPE, sMAPE, MRAE, GMRAE, or MBRAE scores.
</p>


<h3>Author(s)</h3>

<p>Cameron Doyle
</p>
<p>Maintainer: Cameron Doyle &lt;cdoyle305@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(seaLevelTempSOI)
model.poly1 = polyDlm(x = seaLevelTempSOI$LandOcean,  y = seaLevelTempSOI$GMSL , 
                     q = 2 , k = 2 , show.beta = TRUE)
model.poly2 = polyDlm(x = seaLevelTempSOI$LandOcean,  y = seaLevelTempSOI$GMSL , 
                      q = 3 , k = 2 , show.beta = TRUE)
model.poly3 = polyDlm(x = seaLevelTempSOI$LandOcean,  y = seaLevelTempSOI$GMSL , 
                      q = 4 , k = 2 , show.beta = TRUE)

aic = AIC(model.poly1$model, model.poly2$model, model.poly3$model)
bic = BIC(model.poly1$model, model.poly2$model, model.poly3$model)
mase = MASE(model.poly1$model, model.poly2$model, model.poly3$model)
mbrae = MBRAE(model.poly1$model, model.poly2$model, model.poly3$model)

sortScore(aic , score = "aic")
sortScore(bic , score = "bic")
sortScore(mase , score = "mase")
sortScore(mbrae , score = "mbrae")

## End(Not run)
</code></pre>

<hr>
<h2 id='sunspotTemp'>Sunspot numbers and mean temperature anomalies data</h2><span id='topic+sunspotTemp'></span>

<h3>Description</h3>

<p>This data set is composed of monthly mean global surface temperature series by GISS NASA and sunspot numbers recorded by SWPC Space Weather Operations (SWO) between January 1991 and November 2019. </p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sunspotTemp)</code></pre>


<h3>Format</h3>

<p>Multiple time series</p>


<h3>Source</h3>

<p>Goddard Institute for Space Studies, NASA, US.
Space Weather Prediction Center National Oceanic and Atmospheric Administration, US.
</p>


<h3>References</h3>

<p>https://data.giss.nasa.gov/gistemp/graphs_v4/
</p>
<p>ftp://ftp.swpc.noaa.gov/pub/weekly/RecentIndices.txt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sunspotTemp)
sunspots.ts &lt;- ts(sunspotTemp[,3], start = c(1991,1), freq = 12)
temp.ts &lt;- ts(sunspotTemp[,4], start = c(1991,1), freq = 12)
plot(sunspots.ts, main="Time series plots 
of sunspot numbers series.")
</code></pre>

<hr>
<h2 id='warming'>Global warming and vehicle production data</h2><span id='topic+warming'></span>

<h3>Description</h3>

<p>This data set is composed of annual mean global warming series between 1997 and 2016 showing the change in global surface temperature relative to 1951-1980 average temperatures and the number of vehicles produced (in millions) within the same time span over the globe. </p>


<h3>Usage</h3>

<pre><code class='language-R'>data(warming)</code></pre>


<h3>Format</h3>

<p>Multiple time series</p>


<h3>Source</h3>

<p>Global Climate Center, NASA
Organisation Internationale des Constructeurs d'Automobiles (OICA)
</p>


<h3>References</h3>

<p>https://climate.nasa.gov/vital-signs/global-temperature/
</p>
<p>https://www.oica.net/category/production-statistics/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(warming)
vehicleWarming.ts = ts(warming[,2:3], start = 1997)
plot(vehicleWarming.ts, main="Time series plots 
of global warming and the nuber of produced motor 
vehciles series.")
</code></pre>

<hr>
<h2 id='wheat'>World wheat production, CO2 emissions, and temperature anomalies data</h2><span id='topic+wheat'></span>

<h3>Description</h3>

<p>This data set is composed of annual world total CO2 emissions, wheat production, harvested area, wheat production per hectare, and annual average temperature anomalies series between 1960 and 2017.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wheat)</code></pre>


<h3>Format</h3>

<p>Multiple time series
</p>
<p><code>CO2..ppm.</code> column shows the global mean annual concentration of carbon dioxide (CO2) measured in parts per million (ppm).
</p>
<p><code>CO2..tons</code> column shows the global mean annual carbon dioxide (CO2) emissions measured in tons.
</p>
<p><code>HarvestedArea..million.ha.</code> column shows the annual harvested area in the world scale in million hectare.
</p>
<p><code>Production..Mt.</code> column shows the annual world wheat production in million tons.
</p>
<p><code>ProducationPerArea</code> column shows the annual wheat production per hectare in tons.
</p>
<p><code>TempAnomaly..C.degrees.</code> column shows the land-ocean temperature index without smoothing.
</p>


<h3>Source</h3>

<p>Australian Government Department of Agriculture and Water Services, ABARES
CO2 and other Greenhouse Gas Emissions by Hannah Ritchie and Max Roser
</p>


<h3>References</h3>

<p>https://www.agriculture.gov.au/abares/research-topics/agricultural-commodities/agricultural-commodities-trade-data#australian-crop-report-data
</p>
<p>https://www.agriculture.gov.au/abares/research-topics/agricultural-outlook/data
</p>
<p>https://ourworldindata.org/co2-and-other-greenhouse-gas-emissions#annual-co2-emissions
</p>
<p>https://climate.nasa.gov/vital-signs/global-temperature/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wheat)
wheatProduction.ts = ts(wheat[,4], start = 1960)
plot(wheatProduction.ts, main="Time series plot 
of world wheat production series.")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
