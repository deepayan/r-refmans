<!DOCTYPE html><html><head><title>Help for package dowser</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dowser}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#airrClone-class'><p>S4 class defining a clone in Dowser</p></a></li>
<li><a href='#BiopsyTrees'><p>Example Ig lineage trees with biopsy reconstructions.</p></a></li>
<li><a href='#bootstrapTrees'><p>Deprecated! Please use findSwitches instead.</p></a></li>
<li><a href='#buildClonalGermline'><p><code>buildClonalGermline</code> Determine consensus clone sequence and create germline for clone</p></a></li>
<li><a href='#buildGermline'><p><code>buildGermline</code> reconstruct germline segments from alignment data</p></a></li>
<li><a href='#buildIgphyml'><p>Wrapper to build IgPhyML trees and infer intermediate nodes</p></a></li>
<li><a href='#buildPhylo'><p>Wrapper for alakazam::buildPhylipLineage</p></a></li>
<li><a href='#buildPML'><p>Wrapper for phangorn::optim.pml</p></a></li>
<li><a href='#buildPratchet'><p>Wrapper for phangorn::pratchet</p></a></li>
<li><a href='#buildRAxML'><p>Wrapper to build RAxML-ng trees and infer intermediate nodes</p></a></li>
<li><a href='#calcRF'><p>Finds the Robinson-Fould's cluster distance between phylogenies.</p></a></li>
<li><a href='#collapseNodes'><p>Collapse internal nodes with the same predicted sequence</p></a></li>
<li><a href='#colorTrees'><p>Get a color palette for a predefined set of trait values</p></a></li>
<li><a href='#condenseTrees'><p>Condense a set of equally parsimonious node labels into a single tree</p></a></li>
<li><a href='#correlationTest'><p>Run date randomization test for temporal signal on a set of trees.</p></a></li>
<li><a href='#createGermlines'><p>createGermlines Determine consensus clone sequence and create germline for clone</p></a></li>
<li><a href='#downsampleClone'><p><code>downsampleClone</code> Down-sample clone to maximum tip/switch ratio</p></a></li>
<li><a href='#dowser'><p>The dowser package</p></a></li>
<li><a href='#dowser-package'><p>dowser: B Cell Receptor Phylogenetics Toolkit</p></a></li>
<li><a href='#ExampleAirr'><p>Example AIRR database</p></a></li>
<li><a href='#ExampleClones'><p>Example Ig lineage trees</p></a></li>
<li><a href='#ExampleDbChangeo'><p>Example Change-O database</p></a></li>
<li><a href='#ExampleMixedClones'><p>Example Multiple Partition Trees</p></a></li>
<li><a href='#ExampleMixedDb'><p>Example Change-O database</p></a></li>
<li><a href='#findSwitches'><p>Create a bootstrap distribution for clone sequence alignments, and estimate</p>
trees for each bootstrap replicate.</a></li>
<li><a href='#formatClones'><p>Generate an ordered list of airrClone objects for lineage construction</p></a></li>
<li><a href='#getBootstraps'><p>Creates a bootstrap distribution for clone sequence alignments, and returns</p>
estimated trees for each bootstrap replicate as a nested list as a new input
tibble column.</a></li>
<li><a href='#getDivergence'><p>Get divergence from root of tree for each tip</p></a></li>
<li><a href='#getGermline'><p>getGermline get germline segment from specified receptor and segment</p></a></li>
<li><a href='#getNodeSeq'><p>Return IMGT gapped sequence of specified tree node</p></a></li>
<li><a href='#getPalette'><p>Get a color palette for a predefined set of trait values.</p>
'Germline' defaults to black unless specified.</a></li>
<li><a href='#getSeq'><p>Deprecated! Use getNodeSeq</p></a></li>
<li><a href='#getSubclones'><p>#' Deprecated! Use resolveLightChains</p></a></li>
<li><a href='#getSubTaxa'><p>Get the tip labels as part of a clade defined by an internal node</p></a></li>
<li><a href='#getTrees'><p>Estimate lineage tree topologies, branch lengths,</p>
and internal node states if desired</a></li>
<li><a href='#IsotypeTrees'><p>Example Ig lineage trees with isotype reconstructions.</p></a></li>
<li><a href='#makeAirrClone'><p>Generate a airrClone object for lineage construction</p></a></li>
<li><a href='#makeModelFile'><p>Make a parsimony model file</p></a></li>
<li><a href='#maskCodons'><p><code>maskCodons</code> Masks codons split by insertions</p></a></li>
<li><a href='#maskSequences'><p><code>maskSequences</code> Mask codons split by insertions in V gene</p></a></li>
<li><a href='#plotTrees'><p>Plot a tree with colored internal node labels using ggtree</p></a></li>
<li><a href='#readFasta'><p>Read a fasta file into a list of sequences</p>
<code>readFasta</code> reads a fasta file</a></li>
<li><a href='#readIMGT'><p><code>readIMGT</code> read in IMGT database</p></a></li>
<li><a href='#readLineages'><p>Read in all trees from a lineages file</p></a></li>
<li><a href='#readModelFile'><p>Read in a parsimony model file</p></a></li>
<li><a href='#reconIgPhyML'><p>Do IgPhyML maximum parsimony reconstruction</p></a></li>
<li><a href='#rerootTree'><p>Reroot phylogenetic tree to have its germline sequence at a zero-length branch</p>
to a node which is the direct ancestor of the tree's UCA. Assigns <code>uca</code>
to be the ancestral node to the tree's germline sequence, as <code>germid</code> as
the tree's germline sequence ID.</a></li>
<li><a href='#resolveLightChains'><p>Define subgroups within clones based on light chain rearrangements</p></a></li>
<li><a href='#resolvePolytomies'><p>Resolve polytomies to have the minimum number of single timepoint clades</p></a></li>
<li><a href='#runCorrelationTest'><p>Run correlationTest, based on https://doi.org/10.1111/2041-210X.12466</p></a></li>
<li><a href='#scaleBranches'><p>Scale branch lengths to represent either mutations or mutations per site.</p></a></li>
<li><a href='#stitchRegions'><p>stitchRegions Similar to stitchVDJ but with segment IDs</p>
instead of nulecotides</a></li>
<li><a href='#stitchVDJ'><p>stitchVDJ combines germline gene segments to a single string</p></a></li>
<li><a href='#testPS'><p>Performs PS (parsimony score) test on switch data</p></a></li>
<li><a href='#testSC'><p>Performs SC (switch count) test on switch data</p></a></li>
<li><a href='#testSP'><p>Performs SP (switch proportion) test on switch data</p></a></li>
<li><a href='#TimeTrees'><p>Example Ig lineage trees sampled over time.</p></a></li>
<li><a href='#treesToPDF'><p>Simple function for plotting a lot of trees into a pdf</p></a></li>
<li><a href='#writeLineageFile'><p>Write lineage file for IgPhyML use</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-21</td>
</tr>
<tr>
<td>Title:</td>
<td>B Cell Receptor Phylogenetics Toolkit</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a set of functions for inferring, visualizing, and analyzing B cell phylogenetic trees.
    Provides methods to 1) reconstruct unmutated ancestral sequences,
    2) build B cell phylogenetic trees using multiple methods,
    3) visualize trees with metadata at the tips,
    4) reconstruct intermediate sequences,
    5) detect biased ancestor-descendant relationships among metadata types
    Workflow examples available at documentation site (see URL).
    Citations:
    Hoehn et al (2022) &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1009885">doi:10.1371/journal.pcbi.1009885</a>&gt;,
    Hoehn et al (2021) &lt;<a href="https://doi.org/10.1101%2F2021.01.06.425648">doi:10.1101/2021.01.06.425648</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://dowser.readthedocs.io">https://dowser.readthedocs.io</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://bitbucket.org/kleinstein/dowser/issues">https://bitbucket.org/kleinstein/dowser/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0), ggplot2 (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>alakazam (&ge; 1.1.0), ape (&ge; 5.6), Biostrings, dplyr (&ge; 1.0),
ggtree, graphics, gridExtra, markdown, methods, phangorn (&ge;
2.7.1), phylotate, RColorBrewer, rlang, shazam (&ge; 1.1.1),
stats, stringr, tidyselect, tidyr, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'Data.R' 'Dowser.R' 'Clones.R' 'Classes.R' 'Plotting.R'
'Germlines.R' 'Statistics.R' 'TreeFunctions.R' 'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-22 00:48:57 UTC; ken</td>
</tr>
<tr>
<td>Author:</td>
<td>Kenneth Hoehn [aut, cre],
  Cole Jensen [ctb],
  Susanna Marquez [ctb],
  Jason Vander Heiden [ctb],
  Steven Kleinstein [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kenneth Hoehn &lt;kenneth.b.hoehn@dartmouth.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-22 05:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='airrClone-class'>S4 class defining a clone in Dowser</h2><span id='topic+airrClone-class'></span><span id='topic+airrClone'></span>

<h3>Description</h3>

<p><code>airrClone</code> defines a common data structure for perform lineage recontruction
from AIRR data, based heavily on alakazam::ChangeoClone.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>data.frame containing sequences and annotations. Contains the
columns <code>sequence_id</code> and <code>sequence</code>, as well as any additional 
sequence-specific annotation columns</p>
</dd>
<dt><code>clone</code></dt><dd><p>string defining the clone identifier</p>
</dd>
<dt><code>germline</code></dt><dd><p>string containing the heavy chain germline sequence for the clone</p>
</dd>
<dt><code>lgermline</code></dt><dd><p>string containing the light chain germline sequence for the clone</p>
</dd>
<dt><code>hlgermline</code></dt><dd><p>string containing the combined germline sequence for the clone</p>
</dd>
<dt><code>v_gene</code></dt><dd><p>string defining the V segment gene call</p>
</dd>
<dt><code>j_gene</code></dt><dd><p>string defining the J segment gene call</p>
</dd>
<dt><code>junc_len</code></dt><dd><p>numeric junction length (nucleotide count)</p>
</dd>
<dt><code>locus</code></dt><dd><p>index showing which locus represented at each site</p>
</dd>
<dt><code>region</code></dt><dd><p>index showing FWR/CDR region for each site</p>
</dd>
<dt><code>phylo_seq</code></dt><dd><p>sequence column used for phylogenetic tree building</p>
</dd>
<dt><code>numbers</code></dt><dd><p>index (usually IMGT) number of each site in <code>phylo_seq</code></p>
</dd>
</dl>


<h3>See Also</h3>

<p>See <a href="#topic+formatClones">formatClones</a> for use.
</p>

<hr>
<h2 id='BiopsyTrees'>Example Ig lineage trees with biopsy reconstructions.</h2><span id='topic+BiopsyTrees'></span>

<h3>Description</h3>

<p>Same as ExampleClones but with biopsies predicted at internal nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiopsyTrees
</code></pre>


<h3>Format</h3>

<p>A tibble of airrClone and phylo objects output by getTrees.
</p>

<ul>
<li>  <p><code>clone_id</code>:   Clonal cluster
</p>
</li>
<li>  <p><code>data</code>:       List of airrClone objects
</p>
</li>
<li>  <p><code>seqs</code>:       Number of sequences
</p>
</li>
<li>  <p><code>trees</code>:      List of phylo objects
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+BiopsyTrees">BiopsyTrees</a>
</p>

<hr>
<h2 id='bootstrapTrees'>Deprecated! Please use findSwitches instead.</h2><span id='topic+bootstrapTrees'></span>

<h3>Description</h3>

<p><code>bootstrapTrees</code> Phylogenetic bootstrap function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrapTrees(
  clones,
  bootstraps,
  nproc = 1,
  trait = NULL,
  dir = NULL,
  id = NULL,
  modelfile = NULL,
  build = "pratchet",
  exec = NULL,
  igphyml = NULL,
  fixtrees = FALSE,
  quiet = 0,
  rm_temp = TRUE,
  palette = NULL,
  resolve = 2,
  rep = NULL,
  keeptrees = TRUE,
  lfile = NULL,
  seq = NULL,
  downsample = FALSE,
  tip_switch = 20,
  boot_part = "locus",
  force_resolve = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrapTrees_+3A_clones">clones</code></td>
<td>
<p>tibble <code>airrClone</code> objects, the output of 
<a href="#topic+formatClones">formatClones</a></p>
</td></tr>
<tr><td><code id="bootstrapTrees_+3A_bootstraps">bootstraps</code></td>
<td>
<p>number of bootstrap replicates to perform</p>
</td></tr>
<tr><td><code id="bootstrapTrees_+3A_nproc">nproc</code></td>
<td>
<p>number of cores to parallelize computations</p>
</td></tr>
<tr><td><code id="bootstrapTrees_+3A_trait">trait</code></td>
<td>
<p>trait to use for parsimony models (required if 
<code>igphyml</code> specified)</p>
</td></tr>
<tr><td><code id="bootstrapTrees_+3A_dir">dir</code></td>
<td>
<p>directory where temporary files will be placed (required
if <code>igphyml</code> or <code>dnapars</code> specified)</p>
</td></tr>
<tr><td><code id="bootstrapTrees_+3A_id">id</code></td>
<td>
<p>unique identifer for this analysis (required if 
<code>igphyml</code> or <code>dnapars</code> specified)</p>
</td></tr>
<tr><td><code id="bootstrapTrees_+3A_modelfile">modelfile</code></td>
<td>
<p>file specifying parsimony model to use</p>
</td></tr>
<tr><td><code id="bootstrapTrees_+3A_build">build</code></td>
<td>
<p>program to use for tree building (phangorn, dnapars)</p>
</td></tr>
<tr><td><code id="bootstrapTrees_+3A_exec">exec</code></td>
<td>
<p>location of desired phylogenetic executable</p>
</td></tr>
<tr><td><code id="bootstrapTrees_+3A_igphyml">igphyml</code></td>
<td>
<p>location of igphyml executible if trait models desired</p>
</td></tr>
<tr><td><code id="bootstrapTrees_+3A_fixtrees">fixtrees</code></td>
<td>
<p>keep tree topologies fixed?
(bootstrapping will not be perfomed)</p>
</td></tr>
<tr><td><code id="bootstrapTrees_+3A_quiet">quiet</code></td>
<td>
<p>amount of rubbish to print to console</p>
</td></tr>
<tr><td><code id="bootstrapTrees_+3A_rm_temp">rm_temp</code></td>
<td>
<p>remove temporary files (default=TRUE)</p>
</td></tr>
<tr><td><code id="bootstrapTrees_+3A_palette">palette</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="bootstrapTrees_+3A_resolve">resolve</code></td>
<td>
<p>how should polytomies be resolved? 
0=none, 1=max parsminy, 2=max ambiguity + polytomy skipping,
3=max ambiguity</p>
</td></tr>
<tr><td><code id="bootstrapTrees_+3A_rep">rep</code></td>
<td>
<p>current bootstrap replicate (experimental)</p>
</td></tr>
<tr><td><code id="bootstrapTrees_+3A_keeptrees">keeptrees</code></td>
<td>
<p>keep trees estimated from bootstrap replicates? (TRUE)</p>
</td></tr>
<tr><td><code id="bootstrapTrees_+3A_lfile">lfile</code></td>
<td>
<p>lineage file input to igphyml if desired (experimental)</p>
</td></tr>
<tr><td><code id="bootstrapTrees_+3A_seq">seq</code></td>
<td>
<p>column name containing sequence information</p>
</td></tr>
<tr><td><code id="bootstrapTrees_+3A_downsample">downsample</code></td>
<td>
<p>downsample clones to have a maximum specified tip/switch ratio?</p>
</td></tr>
<tr><td><code id="bootstrapTrees_+3A_tip_switch">tip_switch</code></td>
<td>
<p>maximum allowed tip/switch ratio if downsample=TRUE</p>
</td></tr>
<tr><td><code id="bootstrapTrees_+3A_boot_part">boot_part</code></td>
<td>
<p>is  &quot;locus&quot; bootstrap columns for each locus separately</p>
</td></tr>
<tr><td><code id="bootstrapTrees_+3A_force_resolve">force_resolve</code></td>
<td>
<p>continue even if polytomy resolution fails?</p>
</td></tr>
<tr><td><code id="bootstrapTrees_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to tree building program</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of trees and/or switch counts for each bootstrap replicate.
</p>

<hr>
<h2 id='buildClonalGermline'><code>buildClonalGermline</code> Determine consensus clone sequence and create germline for clone</h2><span id='topic+buildClonalGermline'></span>

<h3>Description</h3>

<p>Determine consensus clone sequence and create germline for clone
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildClonalGermline(
  receptors,
  references,
  chain = "IGH",
  use_regions = FALSE,
  vonly = FALSE,
  seq = "sequence_alignment",
  id = "sequence_id",
  clone = "clone_id",
  v_call = "v_call",
  j_call = "j_call",
  j_germ_length = "j_germline_length",
  j_germ_aa_length = "j_germline_aa_length",
  amino_acid = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildClonalGermline_+3A_receptors">receptors</code></td>
<td>
<p>AIRR-table containing sequences from one clone</p>
</td></tr>
<tr><td><code id="buildClonalGermline_+3A_references">references</code></td>
<td>
<p>Full list of reference segments, see <a href="#topic+readIMGT">readIMGT</a></p>
</td></tr>
<tr><td><code id="buildClonalGermline_+3A_chain">chain</code></td>
<td>
<p>chain in <code>references</code> being analyzed</p>
</td></tr>
<tr><td><code id="buildClonalGermline_+3A_use_regions">use_regions</code></td>
<td>
<p>Return string of VDJ regions? (optional)</p>
</td></tr>
<tr><td><code id="buildClonalGermline_+3A_vonly">vonly</code></td>
<td>
<p>Return germline of only v segment?</p>
</td></tr>
<tr><td><code id="buildClonalGermline_+3A_seq">seq</code></td>
<td>
<p>Column name for sequence alignment</p>
</td></tr>
<tr><td><code id="buildClonalGermline_+3A_id">id</code></td>
<td>
<p>Column name for sequence ID</p>
</td></tr>
<tr><td><code id="buildClonalGermline_+3A_clone">clone</code></td>
<td>
<p>Column name for clone ID</p>
</td></tr>
<tr><td><code id="buildClonalGermline_+3A_v_call">v_call</code></td>
<td>
<p>Column name for V gene segment gene call</p>
</td></tr>
<tr><td><code id="buildClonalGermline_+3A_j_call">j_call</code></td>
<td>
<p>Column name for J gene segment gene call</p>
</td></tr>
<tr><td><code id="buildClonalGermline_+3A_j_germ_length">j_germ_length</code></td>
<td>
<p>Column name of J segment length within germline</p>
</td></tr>
<tr><td><code id="buildClonalGermline_+3A_j_germ_aa_length">j_germ_aa_length</code></td>
<td>
<p>Column name of J segment amino acid length (if amino_acid=TRUE)</p>
</td></tr>
<tr><td><code id="buildClonalGermline_+3A_amino_acid">amino_acid</code></td>
<td>
<p>Perform reconstruction on amino acid sequence (experimental)</p>
</td></tr>
<tr><td><code id="buildClonalGermline_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <a href="#topic+buildGermline">buildGermline</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Return object adds/edits following columns:
</p>

<ul>
<li>  <p><code>seq</code>:  Sequences potentially padded  same length as germline
</p>
</li>
<li>  <p><code>germline_alignment</code>: Full length germline
</p>
</li>
<li>  <p><code>germline_alignment_d_mask</code>: Full length, D region masked
</p>
</li>
<li>  <p><code>vonly</code>:   V gene segment of germline if vonly=TRUE
</p>
</li>
<li>  <p><code>regions</code>: String of VDJ segment in position if use_regions=TRUE
</p>
</li></ul>



<h3>Value</h3>

<p>Tibble with reconstructed germlines
</p>


<h3>See Also</h3>

<p><a href="#topic+createGermlines">createGermlines</a> <a href="#topic+buildGermline">buildGermline</a>, <a href="#topic+stitchVDJ">stitchVDJ</a>
</p>

<hr>
<h2 id='buildGermline'><code>buildGermline</code> reconstruct germline segments from alignment data</h2><span id='topic+buildGermline'></span>

<h3>Description</h3>

<p>Reconstruct germlines from alignment data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildGermline(
  receptor,
  references,
  seq = "sequence_alignment",
  id = "sequence_id",
  clone = "clone_id",
  v_call = "v_call",
  d_call = "d_call",
  j_call = "j_call",
  v_germ_start = "v_germline_start",
  v_germ_end = "v_germline_end",
  v_germ_length = "v_germline_length",
  d_germ_start = "d_germline_start",
  d_germ_end = "d_germline_end",
  d_germ_length = "d_germline_length",
  j_germ_start = "j_germline_start",
  j_germ_end = "j_germline_end",
  j_germ_length = "j_germline_length",
  np1_length = "np1_length",
  np2_length = "np2_length",
  amino_acid = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildGermline_+3A_receptor">receptor</code></td>
<td>
<p>row from AIRR-table containing sequence of interest</p>
</td></tr>
<tr><td><code id="buildGermline_+3A_references">references</code></td>
<td>
<p>list of reference segments. Must be specific to locus</p>
</td></tr>
<tr><td><code id="buildGermline_+3A_seq">seq</code></td>
<td>
<p>Column name for sequence alignment</p>
</td></tr>
<tr><td><code id="buildGermline_+3A_id">id</code></td>
<td>
<p>Column name for sequence ID</p>
</td></tr>
<tr><td><code id="buildGermline_+3A_clone">clone</code></td>
<td>
<p>Column name for clone ID</p>
</td></tr>
<tr><td><code id="buildGermline_+3A_v_call">v_call</code></td>
<td>
<p>Column name for V gene segment gene call</p>
</td></tr>
<tr><td><code id="buildGermline_+3A_d_call">d_call</code></td>
<td>
<p>Column name for D gene segment gene call</p>
</td></tr>
<tr><td><code id="buildGermline_+3A_j_call">j_call</code></td>
<td>
<p>Column name for J gene segment gene call</p>
</td></tr>
<tr><td><code id="buildGermline_+3A_v_germ_start">v_germ_start</code></td>
<td>
<p>Column name of index of V segment start within germline</p>
</td></tr>
<tr><td><code id="buildGermline_+3A_v_germ_end">v_germ_end</code></td>
<td>
<p>Column name of index of V segment end within germline</p>
</td></tr>
<tr><td><code id="buildGermline_+3A_v_germ_length">v_germ_length</code></td>
<td>
<p>Column name of index of V segment length within germline</p>
</td></tr>
<tr><td><code id="buildGermline_+3A_d_germ_start">d_germ_start</code></td>
<td>
<p>Column name of index of D segment start within germline</p>
</td></tr>
<tr><td><code id="buildGermline_+3A_d_germ_end">d_germ_end</code></td>
<td>
<p>Column name of index of D segment end within germline</p>
</td></tr>
<tr><td><code id="buildGermline_+3A_d_germ_length">d_germ_length</code></td>
<td>
<p>Column name of index of D segment length within germline</p>
</td></tr>
<tr><td><code id="buildGermline_+3A_j_germ_start">j_germ_start</code></td>
<td>
<p>Column name of index of J segment start within germline</p>
</td></tr>
<tr><td><code id="buildGermline_+3A_j_germ_end">j_germ_end</code></td>
<td>
<p>Column name of index of J segment end within germline</p>
</td></tr>
<tr><td><code id="buildGermline_+3A_j_germ_length">j_germ_length</code></td>
<td>
<p>Column name of index of J segment length within germline</p>
</td></tr>
<tr><td><code id="buildGermline_+3A_np1_length">np1_length</code></td>
<td>
<p>Column name in receptor specifying np1 segment length</p>
</td></tr>
<tr><td><code id="buildGermline_+3A_np2_length">np2_length</code></td>
<td>
<p>Column name in receptor specifying np2 segment length</p>
</td></tr>
<tr><td><code id="buildGermline_+3A_amino_acid">amino_acid</code></td>
<td>
<p>Perform reconstruction on amino acid sequence (experimental)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Return object contains multiple IMGT-gapped germlines:
</p>

<ul>
<li>  <p><code>full</code>:    Full length germline
</p>
</li>
<li>  <p><code>dmask</code>:   Full length germline with D region masked
</p>
</li>
<li>  <p><code>vonly</code>:   V gene segment of germline
</p>
</li>
<li>  <p><code>regions</code>: String showing VDJ segment of each position
</p>
</li></ul>



<h3>Value</h3>

<p>List of reconstructed germlines
</p>


<h3>See Also</h3>

<p><a href="#topic+buildClonalGermline">buildClonalGermline</a>, <a href="#topic+stitchVDJ">stitchVDJ</a>
</p>

<hr>
<h2 id='buildIgphyml'>Wrapper to build IgPhyML trees and infer intermediate nodes</h2><span id='topic+buildIgphyml'></span>

<h3>Description</h3>

<p>Wrapper to build IgPhyML trees and infer intermediate nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildIgphyml(
  clone,
  igphyml,
  trees = NULL,
  nproc = 1,
  temp_path = NULL,
  id = NULL,
  rseed = NULL,
  quiet = 0,
  rm_files = TRUE,
  rm_dir = NULL,
  partition = c("single", "cf", "hl", "hlf", "hlc", "hlcf"),
  omega = NULL,
  optimize = "lr",
  motifs = "FCH",
  hotness = "e,e,e,e,e,e",
  rates = NULL,
  asrc = 0.95,
  splitfreqs = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildIgphyml_+3A_clone">clone</code></td>
<td>
<p>list of <code>airrClone</code> objects</p>
</td></tr>
<tr><td><code id="buildIgphyml_+3A_igphyml">igphyml</code></td>
<td>
<p>igphyml executable</p>
</td></tr>
<tr><td><code id="buildIgphyml_+3A_trees">trees</code></td>
<td>
<p>list of tree topologies if desired</p>
</td></tr>
<tr><td><code id="buildIgphyml_+3A_nproc">nproc</code></td>
<td>
<p>number of cores for parallelization</p>
</td></tr>
<tr><td><code id="buildIgphyml_+3A_temp_path">temp_path</code></td>
<td>
<p>path to temporary directory</p>
</td></tr>
<tr><td><code id="buildIgphyml_+3A_id">id</code></td>
<td>
<p>IgPhyML run id</p>
</td></tr>
<tr><td><code id="buildIgphyml_+3A_rseed">rseed</code></td>
<td>
<p>random number seed if desired</p>
</td></tr>
<tr><td><code id="buildIgphyml_+3A_quiet">quiet</code></td>
<td>
<p>amount of rubbish to print</p>
</td></tr>
<tr><td><code id="buildIgphyml_+3A_rm_files">rm_files</code></td>
<td>
<p>remove temporary files?</p>
</td></tr>
<tr><td><code id="buildIgphyml_+3A_rm_dir">rm_dir</code></td>
<td>
<p>remove temporary directory?</p>
</td></tr>
<tr><td><code id="buildIgphyml_+3A_partition">partition</code></td>
<td>
<p>How to partition omegas along sequences (see details)</p>
</td></tr>
<tr><td><code id="buildIgphyml_+3A_omega">omega</code></td>
<td>
<p>omega parameters to estimate (see IgPhyML docs)</p>
</td></tr>
<tr><td><code id="buildIgphyml_+3A_optimize">optimize</code></td>
<td>
<p>optimize HLP rates (r), lengths (l), topology (t)</p>
</td></tr>
<tr><td><code id="buildIgphyml_+3A_motifs">motifs</code></td>
<td>
<p>motifs to consider (see IgPhyML docs)</p>
</td></tr>
<tr><td><code id="buildIgphyml_+3A_hotness">hotness</code></td>
<td>
<p>hotness parameters to estimate (see IgPhyML docs)</p>
</td></tr>
<tr><td><code id="buildIgphyml_+3A_rates">rates</code></td>
<td>
<p>comma delimited list showing which omega-defined partitions
get a separate rate (e.g. omega=e,e rates=0,1).</p>
</td></tr>
<tr><td><code id="buildIgphyml_+3A_asrc">asrc</code></td>
<td>
<p>Intermediate sequence cutoff probability</p>
</td></tr>
<tr><td><code id="buildIgphyml_+3A_splitfreqs">splitfreqs</code></td>
<td>
<p>Calculate codon frequencies on each partition separately?</p>
</td></tr>
<tr><td><code id="buildIgphyml_+3A_...">...</code></td>
<td>
<p>Additional arguments (not currently used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Partition options in rate order:
</p>

<ul>
<li>  <p><code>single</code>: 1 omega for whole sequence
</p>
</li>
<li>  <p><code>cf</code>: 2 omegas, 1 for all CDRs and 1 for all FWRs
</p>
</li>
<li>  <p><code>hl</code>: 2 omegas, 1 for heavy and 1 for light chain
</p>
</li>
<li>  <p><code>hlf</code>: 3 omegas, 1 for heavy FWR, 1 for all CDRs, and 1 for light FWRs
</p>
</li>
<li>  <p><code>hlc</code>: 3 omegas, 1 for all FWRs, 1 for heavy CDRs, and 1 for light CDRs
</p>
</li>
<li>  <p><code>hlcf</code>: 4 omegas, 1 for each heavy FWR, 1 for heavy CDR, 1 for light FWR, and 1 for light CDR
</p>
</li></ul>



<h3>Value</h3>

<p><code>phylo</code> object created by igphyml with nodes attribute
containing reconstructed sequences.
</p>

<hr>
<h2 id='buildPhylo'>Wrapper for alakazam::buildPhylipLineage</h2><span id='topic+buildPhylo'></span>

<h3>Description</h3>

<p>Wrapper for alakazam::buildPhylipLineage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildPhylo(
  clone,
  exec,
  temp_path = NULL,
  verbose = 0,
  rm_temp = TRUE,
  seq = "sequence",
  tree = NULL,
  onetree = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildPhylo_+3A_clone">clone</code></td>
<td>
<p><code>airrClone</code> object</p>
</td></tr>
<tr><td><code id="buildPhylo_+3A_exec">exec</code></td>
<td>
<p>dnapars or dnaml executable</p>
</td></tr>
<tr><td><code id="buildPhylo_+3A_temp_path">temp_path</code></td>
<td>
<p>path to temporary directory</p>
</td></tr>
<tr><td><code id="buildPhylo_+3A_verbose">verbose</code></td>
<td>
<p>amount of rubbish to print</p>
</td></tr>
<tr><td><code id="buildPhylo_+3A_rm_temp">rm_temp</code></td>
<td>
<p>remove temporary files?</p>
</td></tr>
<tr><td><code id="buildPhylo_+3A_seq">seq</code></td>
<td>
<p>sequece column in <code>airrClone</code> object</p>
</td></tr>
<tr><td><code id="buildPhylo_+3A_tree">tree</code></td>
<td>
<p>fixed tree topology if desired (currently does nothing
if specified)</p>
</td></tr>
<tr><td><code id="buildPhylo_+3A_onetree">onetree</code></td>
<td>
<p>Only sample one tree if multiple found.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>phylo</code> object created by dnapars or dnaml with nodes attribute
containing reconstructed sequences.
</p>

<hr>
<h2 id='buildPML'>Wrapper for phangorn::optim.pml</h2><span id='topic+buildPML'></span>

<h3>Description</h3>

<p>Wrapper for phangorn::optim.pml
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildPML(
  clone,
  seq = "sequence",
  sub_model = "GTR",
  gamma = FALSE,
  asr = "seq",
  asr_thresh = 0.05,
  tree = NULL,
  data_type = "DNA",
  optNni = TRUE,
  optQ = TRUE,
  verbose = FALSE,
  resolve_random = TRUE,
  quiet = 0,
  rep = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildPML_+3A_clone">clone</code></td>
<td>
<p><code>airrClone</code> object</p>
</td></tr>
<tr><td><code id="buildPML_+3A_seq">seq</code></td>
<td>
<p>sequece column in <code>airrClone</code> object</p>
</td></tr>
<tr><td><code id="buildPML_+3A_sub_model">sub_model</code></td>
<td>
<p>substitution model to use</p>
</td></tr>
<tr><td><code id="buildPML_+3A_gamma">gamma</code></td>
<td>
<p>gamma site rate variation?</p>
</td></tr>
<tr><td><code id="buildPML_+3A_asr">asr</code></td>
<td>
<p>return sequence or probability matrix?</p>
</td></tr>
<tr><td><code id="buildPML_+3A_asr_thresh">asr_thresh</code></td>
<td>
<p>threshold for including a nucleotide as an alternative</p>
</td></tr>
<tr><td><code id="buildPML_+3A_tree">tree</code></td>
<td>
<p>fixed tree topology if desired.</p>
</td></tr>
<tr><td><code id="buildPML_+3A_data_type">data_type</code></td>
<td>
<p>Are sequences DNA or AA?</p>
</td></tr>
<tr><td><code id="buildPML_+3A_optnni">optNni</code></td>
<td>
<p>Optimize tree topology</p>
</td></tr>
<tr><td><code id="buildPML_+3A_optq">optQ</code></td>
<td>
<p>Optimize Q matrix</p>
</td></tr>
<tr><td><code id="buildPML_+3A_verbose">verbose</code></td>
<td>
<p>Print error messages as they happen?</p>
</td></tr>
<tr><td><code id="buildPML_+3A_resolve_random">resolve_random</code></td>
<td>
<p>randomly resolve polytomies?</p>
</td></tr>
<tr><td><code id="buildPML_+3A_quiet">quiet</code></td>
<td>
<p>amount of rubbish to print to console</p>
</td></tr>
<tr><td><code id="buildPML_+3A_rep">rep</code></td>
<td>
<p>current bootstrap replicate (experimental)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>phylo</code> object created by phangorn::optim.pml with nodes
attribute containing reconstructed sequences.
</p>

<hr>
<h2 id='buildPratchet'>Wrapper for phangorn::pratchet</h2><span id='topic+buildPratchet'></span>

<h3>Description</h3>

<p>Wrapper for phangorn::pratchet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildPratchet(
  clone,
  seq = "sequence",
  asr = "seq",
  asr_thresh = 0.05,
  tree = NULL,
  asr_type = "MPR",
  verbose = 0,
  resolve_random = TRUE,
  data_type = "DNA"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildPratchet_+3A_clone">clone</code></td>
<td>
<p><code>airrClone</code> object</p>
</td></tr>
<tr><td><code id="buildPratchet_+3A_seq">seq</code></td>
<td>
<p>sequece column in <code>airrClone</code> object</p>
</td></tr>
<tr><td><code id="buildPratchet_+3A_asr">asr</code></td>
<td>
<p>return sequence or probability matrix?</p>
</td></tr>
<tr><td><code id="buildPratchet_+3A_asr_thresh">asr_thresh</code></td>
<td>
<p>threshold for including a nucleotide as an alternative</p>
</td></tr>
<tr><td><code id="buildPratchet_+3A_tree">tree</code></td>
<td>
<p>fixed tree topology if desired.</p>
</td></tr>
<tr><td><code id="buildPratchet_+3A_asr_type">asr_type</code></td>
<td>
<p>MPR or ACCTRAN</p>
</td></tr>
<tr><td><code id="buildPratchet_+3A_verbose">verbose</code></td>
<td>
<p>amount of rubbish to print</p>
</td></tr>
<tr><td><code id="buildPratchet_+3A_resolve_random">resolve_random</code></td>
<td>
<p>randomly resolve polytomies?</p>
</td></tr>
<tr><td><code id="buildPratchet_+3A_data_type">data_type</code></td>
<td>
<p>Are sequences DNA or AA?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>phylo</code> object created by phangorn::pratchet with nodes
attribute containing reconstructed sequences.
</p>

<hr>
<h2 id='buildRAxML'>Wrapper to build RAxML-ng trees and infer intermediate nodes</h2><span id='topic+buildRAxML'></span>

<h3>Description</h3>

<p>Wrapper to build RAxML-ng trees and infer intermediate nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildRAxML(
  clone,
  seq = "sequence",
  exec,
  model = "GTR",
  partition = NULL,
  rseed = 28,
  name = "run",
  starting_tree = NULL,
  from_getTrees = FALSE,
  rm_files = TRUE,
  asr = TRUE,
  rep = 1,
  dir = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildRAxML_+3A_clone">clone</code></td>
<td>
<p>list of <code>airrClone</code> objects</p>
</td></tr>
<tr><td><code id="buildRAxML_+3A_seq">seq</code></td>
<td>
<p>the phylo_seq option does this clone uses. Possible options are &quot;sequence&quot;, &quot;hlsequence&quot;, or &quot;lsequence&quot;</p>
</td></tr>
<tr><td><code id="buildRAxML_+3A_exec">exec</code></td>
<td>
<p>RAxML-ng executable</p>
</td></tr>
<tr><td><code id="buildRAxML_+3A_model">model</code></td>
<td>
<p>The DNA model to be used. GTR is the default.</p>
</td></tr>
<tr><td><code id="buildRAxML_+3A_partition">partition</code></td>
<td>
<p>A parameter that determines how branches are reported when partitioning. Options include NULL (default), 
scaled, unlinked, and linked</p>
</td></tr>
<tr><td><code id="buildRAxML_+3A_rseed">rseed</code></td>
<td>
<p>The random seed used for the parsimony inferences. This allows you to reproduce your results.</p>
</td></tr>
<tr><td><code id="buildRAxML_+3A_name">name</code></td>
<td>
<p>specifies the name of the output file</p>
</td></tr>
<tr><td><code id="buildRAxML_+3A_starting_tree">starting_tree</code></td>
<td>
<p>specifies a user starting tree file name and path in Newick format</p>
</td></tr>
<tr><td><code id="buildRAxML_+3A_from_gettrees">from_getTrees</code></td>
<td>
<p>A logical that indicates if the desired starting tree is from getTrees and not a newick file</p>
</td></tr>
<tr><td><code id="buildRAxML_+3A_rm_files">rm_files</code></td>
<td>
<p>remove temporary files?</p>
</td></tr>
<tr><td><code id="buildRAxML_+3A_asr">asr</code></td>
<td>
<p>computes the marginal ancestral states of a tree</p>
</td></tr>
<tr><td><code id="buildRAxML_+3A_rep">rep</code></td>
<td>
<p>Which repetition of the tree building is currently being run. Mainly for getBootstraps.</p>
</td></tr>
<tr><td><code id="buildRAxML_+3A_dir">dir</code></td>
<td>
<p>Where the output files are to be made.</p>
</td></tr>
<tr><td><code id="buildRAxML_+3A_...">...</code></td>
<td>
<p>Additional arguments (not currently used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>phylo</code> object created by RAxML-ng with nodes attribute
containing reconstructed sequences.
</p>

<hr>
<h2 id='calcRF'>Finds the Robinson-Fould's cluster distance between phylogenies.</h2><span id='topic+calcRF'></span>

<h3>Description</h3>

<p><code>calcRF</code> Calculates the RF distance between two phylogenetic trees with 
the same tips and tip labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcRF(tree_1, tree_2, nproc = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcRF_+3A_tree_1">tree_1</code></td>
<td>
<p>A <code>phylo</code> object</p>
</td></tr>
<tr><td><code id="calcRF_+3A_tree_2">tree_2</code></td>
<td>
<p>A <code>phylo</code> object</p>
</td></tr>
<tr><td><code id="calcRF_+3A_nproc">nproc</code></td>
<td>
<p>Number of cores to use for calculations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The RF cluster value for the two input trees.
</p>

<hr>
<h2 id='collapseNodes'>Collapse internal nodes with the same predicted sequence</h2><span id='topic+collapseNodes'></span>

<h3>Description</h3>

<p><code>collapseNodes</code> Node collapsing function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapseNodes(trees, tips = FALSE, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapseNodes_+3A_trees">trees</code></td>
<td>
<p>a tibble of <code>airrClone</code> objects, the output of <a href="#topic+getTrees">getTrees</a></p>
</td></tr>
<tr><td><code id="collapseNodes_+3A_tips">tips</code></td>
<td>
<p>collapse tips to internal nodes? (experimental)</p>
</td></tr>
<tr><td><code id="collapseNodes_+3A_check">check</code></td>
<td>
<p>check that collapsed nodes are consistent with original tree</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use plotTrees(trees)[[1]] + geom_label(aes(label=node)) + geom_tippoint() to show
node labels, and getSeq to return internal node sequences
</p>


<h3>Value</h3>

<p>A tibble with <code>phylo</code> objects that have had internal nodes collapsed.
</p>


<h3>See Also</h3>

<p><a href="#topic+getTrees">getTrees</a>
</p>

<hr>
<h2 id='colorTrees'>Get a color palette for a predefined set of trait values</h2><span id='topic+colorTrees'></span>

<h3>Description</h3>

<p><code>colorTree</code> Gets a color palette for a predefined set of trait values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorTrees(trees, palette, ambig = "blend")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colorTrees_+3A_trees">trees</code></td>
<td>
<p>list of phylo objects with assigned internal node states</p>
</td></tr>
<tr><td><code id="colorTrees_+3A_palette">palette</code></td>
<td>
<p>named vector of colors (see <a href="#topic+getPalette">getPalette</a>)</p>
</td></tr>
<tr><td><code id="colorTrees_+3A_ambig">ambig</code></td>
<td>
<p>how should ambiguous states be colored (blend or grey)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Trees must have node states represented in a &quot;states&quot; vector. By default,
ambiguous states (separated by &quot;,&quot;) have their colors blended. If
</p>


<h3>Value</h3>

<p>A list of colored trees
</p>


<h3>See Also</h3>

<p><a href="#topic+getPalette">getPalette</a>, <a href="#topic+getTrees">getTrees</a>, <a href="#topic+plotTrees">plotTrees</a>
</p>

<hr>
<h2 id='condenseTrees'>Condense a set of equally parsimonious node labels into a single tree</h2><span id='topic+condenseTrees'></span>

<h3>Description</h3>

<p><code>condenseTrees</code> Condenses a set of equally parsimonious node labels 
into a single tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condenseTrees(trees, states, palette = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condenseTrees_+3A_trees">trees</code></td>
<td>
<p>List of the same tree with equally parsimonious labels</p>
</td></tr>
<tr><td><code id="condenseTrees_+3A_states">states</code></td>
<td>
<p>States in model</p>
</td></tr>
<tr><td><code id="condenseTrees_+3A_palette">palette</code></td>
<td>
<p>Named vector with a color per state</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>phylo</code> object representing all represented internal node states
</p>

<hr>
<h2 id='correlationTest'>Run date randomization test for temporal signal on a set of trees.</h2><span id='topic+correlationTest'></span>

<h3>Description</h3>

<p><code>correlationTest</code> performs root-to-tip regression date randomization test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlationTest(
  clones,
  permutations = 1000,
  minlength = 0.001,
  perm_type = c("clustered", "uniform"),
  time = "time",
  sequence = "sequence_id",
  germline = "Germline",
  verbose = FALSE,
  polyresolve = TRUE,
  alternative = c("greater", "two.sided"),
  storeTree = FALSE,
  nproc = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlationTest_+3A_clones">clones</code></td>
<td>
<p>A <code>tibble</code> object containing airrClone and <code>phylo</code> objects</p>
</td></tr>
<tr><td><code id="correlationTest_+3A_permutations">permutations</code></td>
<td>
<p>Number of permutations to run</p>
</td></tr>
<tr><td><code id="correlationTest_+3A_minlength">minlength</code></td>
<td>
<p>Branch lengths to collapse in trees</p>
</td></tr>
<tr><td><code id="correlationTest_+3A_perm_type">perm_type</code></td>
<td>
<p>Permute among single timepoint clades or uniformly
among tips</p>
</td></tr>
<tr><td><code id="correlationTest_+3A_time">time</code></td>
<td>
<p>Column name holding numeric time information</p>
</td></tr>
<tr><td><code id="correlationTest_+3A_sequence">sequence</code></td>
<td>
<p>Column name holding sequence ID</p>
</td></tr>
<tr><td><code id="correlationTest_+3A_germline">germline</code></td>
<td>
<p>Germline sequence name</p>
</td></tr>
<tr><td><code id="correlationTest_+3A_verbose">verbose</code></td>
<td>
<p>Print lots of rubbish while running?</p>
</td></tr>
<tr><td><code id="correlationTest_+3A_polyresolve">polyresolve</code></td>
<td>
<p>Resolve polytomies to have a minimum number of 
single timepoint clades</p>
</td></tr>
<tr><td><code id="correlationTest_+3A_alternative">alternative</code></td>
<td>
<p>Is alternative that the randomized correlation are greater than 
or equal to observed, or greater/less than?</p>
</td></tr>
<tr><td><code id="correlationTest_+3A_storetree">storeTree</code></td>
<td>
<p>Store the tree used?</p>
</td></tr>
<tr><td><code id="correlationTest_+3A_nproc">nproc</code></td>
<td>
<p>Number of cores to use for calculations. Parallelizes by tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Object returned contains these columns which are added or modified from input:
</p>

<ul>
<li>  <p><code>data</code>: airrClone object, same as input but with additional columns 
&quot;cluster&quot; which correspond to permutation cluster, and &quot;divergence.&quot;
</p>
</li>
<li>  <p><code>slope</code>: Slope of linear regression between divergence and time.
</p>
</li>
<li>  <p><code>correlation</code>: Correlation between divergence and time.
</p>
</li>
<li>  <p><code>p</code>: p value of correlation compared to permuted correlations.
</p>
</li>
<li>  <p><code>random_correlation</code>: Mean correlation of permutation replicates.
</p>
</li>
<li>  <p><code>min_p</code>: Minimum p value of data, determined by either the number of
distinct clade/timepoint combinations or number of permutations.
</p>
</li>
<li>  <p><code>nposs</code>: Number of possible distinct timepoint/clade combinations.
</p>
</li>
<li>  <p><code>nclust</code>: Number of clusters used in permutation. If perm_type=&quot;uniform&quot;
this is the number of tips.
</p>
</li>
<li>  <p><code>p_gt/p_lt</code>: P value that permuted correlations are greater or less 
than observed correlation. Only returned if alternative = &quot;two.sided&quot;
</p>
</li>
<li>  <p><code>test_trees</code>:  The <a href="ape.html#topic+phylo">phylo</a> tree objects used, possibly with
resolved polytomies.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>tibble</code> with the same columns as clones, but additional
columns corresponding to test statistics for each clone.
</p>


<h3>See Also</h3>

<p>Uses output from <code>getTrees</code>.
</p>

<hr>
<h2 id='createGermlines'><a href="#topic+createGermlines">createGermlines</a> Determine consensus clone sequence and create germline for clone</h2><span id='topic+createGermlines'></span>

<h3>Description</h3>

<p><a href="#topic+createGermlines">createGermlines</a> Determine consensus clone sequence and create germline for clone
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createGermlines(
  data,
  references,
  locus = "locus",
  nproc = 1,
  seq = "sequence_alignment",
  v_call = "v_call",
  d_call = "d_call",
  j_call = "j_call",
  amino_acid = FALSE,
  id = "sequence_id",
  clone = "clone_id",
  v_germ_start = "v_germline_start",
  v_germ_end = "v_germline_end",
  v_germ_length = "v_germline_length",
  d_germ_start = "d_germline_start",
  d_germ_end = "d_germline_end",
  d_germ_length = "d_germline_length",
  j_germ_start = "j_germline_start",
  j_germ_end = "j_germline_end",
  j_germ_length = "j_germline_length",
  np1_length = "np1_length",
  np2_length = "np2_length",
  na.rm = TRUE,
  fields = NULL,
  verbose = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createGermlines_+3A_data">data</code></td>
<td>
<p>AIRR-table containing sequences from one clone</p>
</td></tr>
<tr><td><code id="createGermlines_+3A_references">references</code></td>
<td>
<p>Full list of reference segments, see <a href="#topic+readIMGT">readIMGT</a></p>
</td></tr>
<tr><td><code id="createGermlines_+3A_locus">locus</code></td>
<td>
<p>Name of the locus column in the input data</p>
</td></tr>
<tr><td><code id="createGermlines_+3A_nproc">nproc</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="createGermlines_+3A_seq">seq</code></td>
<td>
<p>Column name for sequence alignment</p>
</td></tr>
<tr><td><code id="createGermlines_+3A_v_call">v_call</code></td>
<td>
<p>Column name for V gene segment gene call</p>
</td></tr>
<tr><td><code id="createGermlines_+3A_d_call">d_call</code></td>
<td>
<p>Column name for D gene segment gene call</p>
</td></tr>
<tr><td><code id="createGermlines_+3A_j_call">j_call</code></td>
<td>
<p>Column name for J gene segment gene call</p>
</td></tr>
<tr><td><code id="createGermlines_+3A_amino_acid">amino_acid</code></td>
<td>
<p>Perform reconstruction on amino acid sequence (experimental)</p>
</td></tr>
<tr><td><code id="createGermlines_+3A_id">id</code></td>
<td>
<p>Column name for sequence ID</p>
</td></tr>
<tr><td><code id="createGermlines_+3A_clone">clone</code></td>
<td>
<p>Column name for clone ID</p>
</td></tr>
<tr><td><code id="createGermlines_+3A_v_germ_start">v_germ_start</code></td>
<td>
<p>Column name of index of V segment start within germline</p>
</td></tr>
<tr><td><code id="createGermlines_+3A_v_germ_end">v_germ_end</code></td>
<td>
<p>Column name of index of V segment end within germline</p>
</td></tr>
<tr><td><code id="createGermlines_+3A_v_germ_length">v_germ_length</code></td>
<td>
<p>Column name of index of V segment length within germline</p>
</td></tr>
<tr><td><code id="createGermlines_+3A_d_germ_start">d_germ_start</code></td>
<td>
<p>Column name of index of D segment start within germline</p>
</td></tr>
<tr><td><code id="createGermlines_+3A_d_germ_end">d_germ_end</code></td>
<td>
<p>Column name of index of D segment end within germline</p>
</td></tr>
<tr><td><code id="createGermlines_+3A_d_germ_length">d_germ_length</code></td>
<td>
<p>Column name of index of D segment length within germline</p>
</td></tr>
<tr><td><code id="createGermlines_+3A_j_germ_start">j_germ_start</code></td>
<td>
<p>Column name of index of J segment start within germline</p>
</td></tr>
<tr><td><code id="createGermlines_+3A_j_germ_end">j_germ_end</code></td>
<td>
<p>Column name of index of J segment end within germline</p>
</td></tr>
<tr><td><code id="createGermlines_+3A_j_germ_length">j_germ_length</code></td>
<td>
<p>Column name of index of J segment length within germline</p>
</td></tr>
<tr><td><code id="createGermlines_+3A_np1_length">np1_length</code></td>
<td>
<p>Column name in receptor specifying np1 segment length</p>
</td></tr>
<tr><td><code id="createGermlines_+3A_np2_length">np2_length</code></td>
<td>
<p>Column name in receptor specifying np2 segment length</p>
</td></tr>
<tr><td><code id="createGermlines_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove clones with failed germline reconstruction?</p>
</td></tr>
<tr><td><code id="createGermlines_+3A_fields">fields</code></td>
<td>
<p>Character vector of additional columns to use for grouping. 
Sequences with disjoint values in the specified fields 
will be considered as separate clones.</p>
</td></tr>
<tr><td><code id="createGermlines_+3A_verbose">verbose</code></td>
<td>
<p>amount of rubbish to print</p>
</td></tr>
<tr><td><code id="createGermlines_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <a href="#topic+buildGermline">buildGermline</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Return object adds/edits following columns:
</p>

<ul>
<li>  <p><code>seq</code>:  Sequences potentially padded  same length as germline
</p>
</li>
<li>  <p><code>germline_alignment</code>: Full length germline
</p>
</li>
<li>  <p><code>germline_alignment_d_mask</code>: Full length, D region masked
</p>
</li>
<li>  <p><code>vonly</code>:   V gene segment of germline if vonly=TRUE
</p>
</li>
<li>  <p><code>regions</code>: String of VDJ segment in position if use_regions=TRUE
</p>
</li></ul>



<h3>Value</h3>

<p>Tibble with reconstructed germlines
</p>


<h3>See Also</h3>

<p><a href="#topic+createGermlines">createGermlines</a> <a href="#topic+buildGermline">buildGermline</a>, <a href="#topic+stitchVDJ">stitchVDJ</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vdj_dir &lt;- system.file("extdata", "germlines", "imgt", "human", "vdj", package="dowser")
imgt &lt;- readIMGT(vdj_dir)
db &lt;- createGermlines(ExampleAirr[1,], imgt)
</code></pre>

<hr>
<h2 id='downsampleClone'><code>downsampleClone</code> Down-sample clone to maximum tip/switch ratio</h2><span id='topic+downsampleClone'></span>

<h3>Description</h3>

<p><code>downsampleClone</code> Down-sample clone to maximum tip/switch ratio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>downsampleClone(clone, trait, tip_switch = 20, tree = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="downsampleClone_+3A_clone">clone</code></td>
<td>
<p>an <a href="#topic+airrClone">airrClone</a> object</p>
</td></tr>
<tr><td><code id="downsampleClone_+3A_trait">trait</code></td>
<td>
<p>trait considered for rarefaction
<a href="#topic+getTrees">getTrees</a></p>
</td></tr>
<tr><td><code id="downsampleClone_+3A_tip_switch">tip_switch</code></td>
<td>
<p>maximum tip/switch ratio</p>
</td></tr>
<tr><td><code id="downsampleClone_+3A_tree">tree</code></td>
<td>
<p>a <code>phylo</code> tree object correspond to <code>clone</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with sequence for each locus at a specified <code>node</code>
in <code>tree</code>.
</p>

<hr>
<h2 id='dowser'>The dowser package</h2><span id='topic+dowser'></span>

<h3>Description</h3>

<p><code>dowser</code> is a phylogenetic analysis package as part of the Immcantation suite of tools.
For additional details regarding the use of the <code>dowser</code> package see the 
vignettes:<br />
<code>browseVignettes("dowser")</code>
</p>


<h3>References</h3>


<ol>
<li><p>  Hoehn KB, Pybus OG, Kleinstein SH (2022) Phylogenetic analysis of 
migration, differentiation, and class switching in B cells.
PLoS Computational Biology. https://doi.org/10.1371/journal.pcbi.1009885
</p>
</li></ol>


<hr>
<h2 id='dowser-package'>dowser: B Cell Receptor Phylogenetics Toolkit</h2><span id='topic+dowser-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>Provides a set of functions for inferring, visualizing, and analyzing B cell phylogenetic trees. Provides methods to 1) reconstruct unmutated ancestral sequences, 2) build B cell phylogenetic trees using multiple methods, 3) visualize trees with metadata at the tips, 4) reconstruct intermediate sequences, 5) detect biased ancestor-descendant relationships among metadata types Workflow examples available at documentation site (see URL). Citations: Hoehn et al (2022) doi: <a href="https://doi.org/10.1371/journal.pcbi.1009885">10.1371/journal.pcbi.1009885</a>, Hoehn et al (2021) doi: <a href="https://doi.org/10.1101/2021.01.06.425648">10.1101/2021.01.06.425648</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Kenneth Hoehn <a href="mailto:kenneth.b.hoehn@dartmouth.edu">kenneth.b.hoehn@dartmouth.edu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Steven Kleinstein <a href="mailto:steven.kleinstein@yale.edu">steven.kleinstein@yale.edu</a> [copyright holder]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Cole Jensen <a href="mailto:cole.jensen@yale.edu">cole.jensen@yale.edu</a> [contributor]
</p>
</li>
<li><p> Susanna Marquez <a href="mailto:susanna.marquez@yale.edu">susanna.marquez@yale.edu</a> [contributor]
</p>
</li>
<li><p> Jason Vander Heiden <a href="mailto:jason.vanderheiden@gmail.com">jason.vanderheiden@gmail.com</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://dowser.readthedocs.io">https://dowser.readthedocs.io</a>
</p>
</li>
<li><p> Report bugs at <a href="https://bitbucket.org/kleinstein/dowser/issues">https://bitbucket.org/kleinstein/dowser/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ExampleAirr'>Example AIRR database</h2><span id='topic+ExampleAirr'></span>

<h3>Description</h3>

<p>A small example database subset from Laserson and Vigneault et al, 2014.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExampleAirr
</code></pre>


<h3>Format</h3>

<p>A data.frame with the following AIRR style columns:
</p>

<ul>
<li>  <p><code>sequence_id</code>:           Sequence identifier
</p>
</li>
<li>  <p><code>sequence_alignment</code>:    IMGT-gapped observed sequence.
</p>
</li>
<li>  <p><code>germline_alignment_d_mask</code>:  IMGT-gapped germline sequence with N, P and 
D regions masked.
</p>
</li>
<li>  <p><code>v_call</code>:                V region allele assignments.
</p>
</li>
<li>  <p><code>v_call_genotyped</code>:      TIgGER corrected V region allele assignment.
</p>
</li>
<li>  <p><code>d_call</code>:                D region allele assignments.
</p>
</li>
<li>  <p><code>j_call</code>:                J region allele assignments.
</p>
</li>
<li>  <p><code>junction</code>:              Junction region sequence.
</p>
</li>
<li>  <p><code>junction_length</code>:       Length of the junction region in nucleotides.
</p>
</li>
<li>  <p><code>np1_length</code>:            Combined length of the N and P regions proximal
to the V region.
</p>
</li>
<li>  <p><code>np2_length</code>:            Combined length of the N and P regions proximal
to the J region.
</p>
</li>
<li>  <p><code>sample</code>:                Sample identifier. Time in relation to vaccination.
</p>
</li>
<li>  <p><code>isotype</code>:               Isotype assignment.
</p>
</li>
<li>  <p><code>duplicate_count</code>:       Copy count (number of duplicates) of the sequence.
</p>
</li>
<li>  <p><code>clone_id</code>:              Change-O assignment clonal group identifier.
</p>
</li></ul>



<h3>References</h3>


<ol>
<li><p>  Laserson U and Vigneault F, et al. High-resolution antibody dynamics of 
vaccine-induced immune responses. 
Proc Natl Acad Sci USA. 2014 111:4928-33.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+ExampleDbChangeo">ExampleDbChangeo</a> <a href="#topic+ExampleClones">ExampleClones</a>
</p>

<hr>
<h2 id='ExampleClones'>Example Ig lineage trees</h2><span id='topic+ExampleClones'></span>

<h3>Description</h3>

<p>A tibble of Ig lineage trees generated from the <code>ExampleAirr</code> file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExampleClones
</code></pre>


<h3>Format</h3>

<p>A tibble of airrClone and phylo objects output by getTrees.
</p>

<ul>
<li>  <p><code>clone_id</code>:   Clonal cluster
</p>
</li>
<li>  <p><code>data</code>:       List of airrClone objects
</p>
</li>
<li>  <p><code>seqs</code>:       Number of sequences
</p>
</li>
<li>  <p><code>trees</code>:      List of phylo objects
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+ExampleClones">ExampleClones</a>
</p>

<hr>
<h2 id='ExampleDbChangeo'>Example Change-O database</h2><span id='topic+ExampleDbChangeo'></span>

<h3>Description</h3>

<p>A small example database subset from Laserson and Vigneault et al, 2014.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExampleDbChangeo
</code></pre>


<h3>Format</h3>

<p>A data.frame with the following Change-O style columns:
</p>

<ul>
<li>  <p><code>SEQUENCE_ID</code>:           Sequence identifier
</p>
</li>
<li>  <p><code>SEQUENCE_IMGT</code>:         IMGT-gapped observed sequence.
</p>
</li>
<li>  <p><code>GERMLINE_IMGT_D_MASK</code>:  IMGT-gapped germline sequence with N, P and 
D regions masked.
</p>
</li>
<li>  <p><code>V_CALL</code>:                V region allele assignments.
</p>
</li>
<li>  <p><code>V_CALL_GENOTYPED</code>:      TIgGER corrected V region allele assignment.
</p>
</li>
<li>  <p><code>D_CALL</code>:                D region allele assignments.
</p>
</li>
<li>  <p><code>J_CALL</code>:                J region allele assignments.
</p>
</li>
<li>  <p><code>JUNCTION</code>:              Junction region sequence.
</p>
</li>
<li>  <p><code>JUNCTION_LENGTH</code>:       Length of the junction region in nucleotides.
</p>
</li>
<li>  <p><code>NP1_LENGTH</code>:            Combined length of the N and P regions proximal
to the V region.
</p>
</li>
<li>  <p><code>NP2_LENGTH</code>:            Combined length of the N and P regions proximal
to the J region.
</p>
</li>
<li>  <p><code>SAMPLE</code>:                Sample identifier. Time in relation to vaccination.
</p>
</li>
<li>  <p><code>ISOTYPE</code>:               Isotype assignment.
</p>
</li>
<li>  <p><code>DUPCOUNT</code>:              Copy count (number of duplicates) of the sequence.
</p>
</li>
<li>  <p><code>CLONE</code>:                 Change-O assignment clonal group identifier.
</p>
</li></ul>



<h3>References</h3>


<ol>
<li><p>  Laserson U and Vigneault F, et al. High-resolution antibody dynamics of 
vaccine-induced immune responses. 
Proc Natl Acad Sci USA. 2014 111:4928-33.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+ExampleAirr">ExampleAirr</a> <a href="#topic+ExampleClones">ExampleClones</a>
</p>

<hr>
<h2 id='ExampleMixedClones'>Example Multiple Partition Trees</h2><span id='topic+ExampleMixedClones'></span>

<h3>Description</h3>

<p>A small example database subset from Turner, J. S. et al. Human germinal centres 
engage memory and naive B cells after influenza vaccination. Nature 586, 127–132 (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExampleMixedClones
</code></pre>


<h3>Format</h3>

<p>A data.frame with the following Change-O style columns:
</p>

<ul>
<li>  <p><code>clone_id</code>:           Clonal cluster
</p>
</li>
<li>  <p><code>data</code>:               List of airrClone objects
</p>
</li>
<li>  <p><code>locus</code>:              Locus identifier.
</p>
</li>
<li>  <p><code>seqs</code>:               Number of sequences
</p>
</li>
<li> <p><code>igphyml_partitioned_trees</code>:      IgPhyML partitioned tree
</p>
</li>
<li> <p><code>raxml_partitioned_trees</code>:        RAxML partitioned tree
</p>
</li></ul>


<hr>
<h2 id='ExampleMixedDb'>Example Change-O database</h2><span id='topic+ExampleMixedDb'></span>

<h3>Description</h3>

<p>A small example database subset from Turner, J. S. et al. Human germinal centres 
engage memory and naive B cells after influenza vaccination. Nature 586, 127–132 (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExampleMixedDb
</code></pre>


<h3>Format</h3>

<p>A data.frame with the following Change-O style columns:
</p>

<ul>
<li>  <p><code>sequence_id</code>:           Sequence identifier
</p>
</li>
<li> <p><code>sequence</code>:               B cell sequence
</p>
</li>
<li> <p><code>productive</code>:             A logical indicating if the sequence is productive.
</p>
</li>
<li>  <p><code>v_call</code>:                V region allele assignments.
</p>
</li>
<li> <p><code>d_call</code>:                 D region allele assignments. 
</p>
</li>
<li>  <p><code>j_call</code>:                J region allele assignments.
</p>
</li>
<li>  <p><code>sequence_alignment</code>:    Sequence alignment.
</p>
</li>
<li> <p><code>germline_alignment</code>:     Germline alignment without gaps. 
</p>
</li>
<li> <p><code>junction</code>:               Junction
</p>
</li>
<li> <p><code>juncation_aa</code>:           Junction aa
</p>
</li>
<li> <p><code>vj_inframe</code>:             A logical to see if the vj genes are in frame
</p>
</li>
<li> <p><code>stop_codon</code>:             A indicator if there is a stop codon within the alignment
</p>
</li>
<li> <p><code>locus</code>:                  Locus identifier. 
</p>
</li>
<li> <p><code>v_sequence_start</code>:       Where the V gene starts
</p>
</li>
<li> <p><code>v_sequence_end</code>:         Where the V gene ends
</p>
</li>
<li> <p><code>v_germline_start</code>:       Where the V germline starts
</p>
</li>
<li> <p><code>v_germline_end</code>:         Where the V germline ends
</p>
</li>
<li> <p><code>np1_length</code>:             Length of np1
</p>
</li>
<li> <p><code>d_sequence_start</code>:       Where the D gene starts
</p>
</li>
<li> <p><code>d_sequence_end</code>:         Where the D gene ends
</p>
</li>
<li> <p><code>d_germline_start</code>:       Where the D germline starts
</p>
</li>
<li> <p><code>d_germline_end</code>:         Where the D germline ends
</p>
</li>
<li> <p><code>np2_length</code>:             Length of np2
</p>
</li>
<li> <p><code>j_sequence_start</code>:       Where the J gene starts
</p>
</li>
<li> <p><code>j_sequence_end</code>:         Where the J gene ends
</p>
</li>
<li> <p><code>j_germline_start</code>:       Where the J germline starts
</p>
</li>
<li> <p><code>j_germline_end</code>:         Where the J germline ends
</p>
</li>
<li>  <p><code>junction_length</code>:       Length of the junction region in nucleotides.
</p>
</li>
<li> <p><code>v_score</code>:                V score
</p>
</li>
<li> <p><code>v_identity</code>:             Identity score of V
</p>
</li>
<li> <p><code>v_support</code>:              V support
</p>
</li>
<li> <p><code>d_score</code>:                D score
</p>
</li>
<li> <p><code>d_identity</code>:             D identity 
</p>
</li>
<li> <p><code>d_support</code>:              D support
</p>
</li>
<li> <p><code>j_score</code>:                J score
</p>
</li>
<li> <p><code>j_support</code>:              J support
</p>
</li>
<li> <p><code>j_identity</code>:             J identity 
</p>
</li>
<li> <p><code>cell_id</code>:                Cell identifier 
</p>
</li>
<li> <p><code>consensus_count</code>:        Consensus count 
</p>
</li>
<li> <p><code>indels</code>:                 Logical if indels are present 
</p>
</li>
<li> <p><code>sequence_vdj</code>:           VDJ sequence
</p>
</li>
<li> <p><code>v_germ_start_vdj</code>:       Where the V germline starts on the VDJ
</p>
</li>
<li> <p><code>v_germ_end_vdj</code>:         Where the V germline ends on the VDJ
</p>
</li>
<li> <p><code>subject</code>:                Subject identifier 
</p>
</li>
<li> <p><code>timepoint</code>:              Day the sample was taken 
</p>
</li>
<li> <p><code>cell_type</code>:              Type of cell 
</p>
</li>
<li> <p><code>replicate</code>:              Replicate number 
</p>
</li>
<li>  <p><code>clone_id</code>:              Change-O assignment clonal group identifier.
</p>
</li>
<li> <p><code>seq_type</code>:               Identifier of data type (10x)
</p>
</li>
<li> <p><code>vj_gene</code>:                VJ gene
</p>
</li>
<li> <p><code>vj_alt_gene</code>:            Alternative VJ gene
</p>
</li>
<li> <p><code>v_germline_length</code>:      Length of the V germline segment
</p>
</li>
<li> <p><code>d_germline_length</code>:      Length of the D germline segment 
</p>
</li>
<li> <p><code>j_germline_lenght</code>:      Length of the J germline segment 
</p>
</li>
<li> <p><code>germline_alignment_d_mask</code>:  Germline alignment with gaps
</p>
</li></ul>


<hr>
<h2 id='findSwitches'>Create a bootstrap distribution for clone sequence alignments, and estimate 
trees for each bootstrap replicate.</h2><span id='topic+findSwitches'></span>

<h3>Description</h3>

<p><code>findSwitches</code> Phylogenetic bootstrap function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findSwitches(
  clones,
  permutations,
  trait,
  igphyml,
  fixtrees = FALSE,
  downsample = TRUE,
  tip_switch = 20,
  nproc = 1,
  dir = NULL,
  id = NULL,
  modelfile = NULL,
  build = "pratchet",
  exec = NULL,
  quiet = 0,
  rm_temp = TRUE,
  palette = NULL,
  resolve = 2,
  rep = NULL,
  keeptrees = FALSE,
  lfile = NULL,
  seq = NULL,
  boot_part = "locus",
  force_resolve = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findSwitches_+3A_clones">clones</code></td>
<td>
<p>tibble <code>airrClone</code> objects, the output of 
<a href="#topic+formatClones">formatClones</a></p>
</td></tr>
<tr><td><code id="findSwitches_+3A_permutations">permutations</code></td>
<td>
<p>number of bootstrap replicates to perform</p>
</td></tr>
<tr><td><code id="findSwitches_+3A_trait">trait</code></td>
<td>
<p>trait to use for parsimony models</p>
</td></tr>
<tr><td><code id="findSwitches_+3A_igphyml">igphyml</code></td>
<td>
<p>location of igphyml executible</p>
</td></tr>
<tr><td><code id="findSwitches_+3A_fixtrees">fixtrees</code></td>
<td>
<p>keep tree topologies fixed?
(bootstrapping will not be perfomed)</p>
</td></tr>
<tr><td><code id="findSwitches_+3A_downsample">downsample</code></td>
<td>
<p>downsample clones to have a maximum specified tip/switch ratio?</p>
</td></tr>
<tr><td><code id="findSwitches_+3A_tip_switch">tip_switch</code></td>
<td>
<p>maximum allowed tip/switch ratio if downsample=TRUE</p>
</td></tr>
<tr><td><code id="findSwitches_+3A_nproc">nproc</code></td>
<td>
<p>number of cores to parallelize computations</p>
</td></tr>
<tr><td><code id="findSwitches_+3A_dir">dir</code></td>
<td>
<p>directory where temporary files will be placed (required
if <code>igphyml</code> or <code>dnapars</code> specified)</p>
</td></tr>
<tr><td><code id="findSwitches_+3A_id">id</code></td>
<td>
<p>unique identifer for this analysis (required if 
<code>igphyml</code> or <code>dnapars</code> specified)</p>
</td></tr>
<tr><td><code id="findSwitches_+3A_modelfile">modelfile</code></td>
<td>
<p>file specifying parsimony model to use</p>
</td></tr>
<tr><td><code id="findSwitches_+3A_build">build</code></td>
<td>
<p>program to use for tree building (phangorn, dnapars)</p>
</td></tr>
<tr><td><code id="findSwitches_+3A_exec">exec</code></td>
<td>
<p>location of desired phylogenetic executable</p>
</td></tr>
<tr><td><code id="findSwitches_+3A_quiet">quiet</code></td>
<td>
<p>amount of rubbish to print to console</p>
</td></tr>
<tr><td><code id="findSwitches_+3A_rm_temp">rm_temp</code></td>
<td>
<p>remove temporary files (default=TRUE)</p>
</td></tr>
<tr><td><code id="findSwitches_+3A_palette">palette</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="findSwitches_+3A_resolve">resolve</code></td>
<td>
<p>how should polytomies be resolved? 
0=none, 1=max parsminy, 2=max ambiguity + polytomy skipping,
3=max ambiguity</p>
</td></tr>
<tr><td><code id="findSwitches_+3A_rep">rep</code></td>
<td>
<p>current bootstrap replicate (experimental)</p>
</td></tr>
<tr><td><code id="findSwitches_+3A_keeptrees">keeptrees</code></td>
<td>
<p>keep trees estimated from bootstrap replicates? (TRUE)</p>
</td></tr>
<tr><td><code id="findSwitches_+3A_lfile">lfile</code></td>
<td>
<p>lineage file input to igphyml if desired (experimental)</p>
</td></tr>
<tr><td><code id="findSwitches_+3A_seq">seq</code></td>
<td>
<p>column name containing sequence information</p>
</td></tr>
<tr><td><code id="findSwitches_+3A_boot_part">boot_part</code></td>
<td>
<p>is  &quot;locus&quot; bootstrap columns for each locus separately</p>
</td></tr>
<tr><td><code id="findSwitches_+3A_force_resolve">force_resolve</code></td>
<td>
<p>continue even if polytomy resolution fails?</p>
</td></tr>
<tr><td><code id="findSwitches_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to tree building program</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tree building details are the same as <a href="#topic+getTrees">getTrees</a>. 
If <code>keeptrees=TRUE</code> (default) the returned object will contain a list 
named &quot;trees&quot; which contains a list of estimated tree objects for each 
bootstrap replicate. The object is structured like: 
trees[[&lt;replicate&gt;]][[&lt;tree index&gt;]]. If <code>igphyml</code> is specified 
(as well as <code>trait</code>), the returned object 
will contain a <code>tibble</code> named &quot;switches&quot; containing switch count 
information. This object can be passed to <a href="#topic+testSP">testSP</a> and other functions 
to perform parsimony based trait value tests. 
</p>
<p>Trait values cannot contain values N, UCA, or NTIP. These are reserved for
use by test statistic functions.
</p>


<h3>Value</h3>

<p>A list of trees and/or switch counts for each bootstrap replicate.
</p>


<h3>See Also</h3>

<p>Uses output from <a href="#topic+formatClones">formatClones</a> with similar arguments to 
<a href="#topic+getTrees">getTrees</a>. Output can be visualized with <a href="#topic+plotTrees">plotTrees</a>, and tested
with <a href="#topic+testPS">testPS</a>, <a href="#topic+testSC">testSC</a>, and <a href="#topic+testSP">testSP</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(ExampleAirr)
ExampleAirr$sample_id &lt;- sample(ExampleAirr$sample_id)
clones &lt;- formatClones(ExampleAirr, trait="sample_id")

igphyml &lt;- "~/apps/igphyml/src/igphyml"
btrees &lt;- findSwitches(clones[1:2,], permutations=10, nproc=1,
   igphyml=igphyml, trait="sample_id")
plotTrees(btrees$trees[[4]])[[1]]
testPS(btrees$switches)

## End(Not run)
</code></pre>

<hr>
<h2 id='formatClones'>Generate an ordered list of airrClone objects for lineage construction</h2><span id='topic+formatClones'></span>

<h3>Description</h3>

<p><code>formatClones</code> takes a <code>data.frame</code> or <code>tibble</code> with AIRR or 
Change-O style columns as input and masks gap positions, masks ragged ends, 
removes duplicates sequences, and merges annotations associated with duplicate
sequences. If specified, it will un-merge duplicate sequences with different 
values specified in the <code>traits</code> option. It returns a list of <code>airrClone</code>
objects ordered by number of sequences which serve as input for lineage reconstruction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatClones(
  data,
  seq = "sequence_alignment",
  clone = "clone_id",
  subgroup = "clone_subgroup",
  id = "sequence_id",
  germ = "germline_alignment_d_mask",
  v_call = "v_call",
  j_call = "j_call",
  junc_len = "junction_length",
  mask_char = "N",
  max_mask = 0,
  pad_end = TRUE,
  text_fields = NULL,
  num_fields = NULL,
  seq_fields = NULL,
  add_count = TRUE,
  verbose = FALSE,
  collapse = TRUE,
  cell = "cell_id",
  locus = "locus",
  traits = NULL,
  mod3 = TRUE,
  randomize = TRUE,
  use_regions = TRUE,
  dup_singles = FALSE,
  nproc = 1,
  chain = "H",
  heavy = "IGH",
  filterstop = TRUE,
  minseq = 2,
  split_light = FALSE,
  light_traits = FALSE,
  majoronly = FALSE,
  columns = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatClones_+3A_data">data</code></td>
<td>
<p>data.frame containing the AIRR or Change-O data for a clone.
See <a href="#topic+makeAirrClone">makeAirrClone</a> for required columns and their defaults</p>
</td></tr>
<tr><td><code id="formatClones_+3A_seq">seq</code></td>
<td>
<p>name of the column containing observed DNA sequences. All 
sequences in this column must be multiple aligned.</p>
</td></tr>
<tr><td><code id="formatClones_+3A_clone">clone</code></td>
<td>
<p>name of the column containing the identifier for the clone. All 
entries in this column should be identical.</p>
</td></tr>
<tr><td><code id="formatClones_+3A_subgroup">subgroup</code></td>
<td>
<p>name of the column containing the identifier for the subgroup.</p>
</td></tr>
<tr><td><code id="formatClones_+3A_id">id</code></td>
<td>
<p>name of the column containing sequence identifiers.</p>
</td></tr>
<tr><td><code id="formatClones_+3A_germ">germ</code></td>
<td>
<p>name of the column containing germline DNA sequences. All entries 
in this column should be identical for any given clone, and they
must be multiple aligned with the data in the <code>seq</code> column.</p>
</td></tr>
<tr><td><code id="formatClones_+3A_v_call">v_call</code></td>
<td>
<p>name of the column containing V-segment allele assignments. All 
entries in this column should be identical to the gene level.</p>
</td></tr>
<tr><td><code id="formatClones_+3A_j_call">j_call</code></td>
<td>
<p>name of the column containing J-segment allele assignments. All 
entries in this column should be identical to the gene level.</p>
</td></tr>
<tr><td><code id="formatClones_+3A_junc_len">junc_len</code></td>
<td>
<p>name of the column containing the length of the junction as a 
numeric value. All entries in this column should be identical 
for any given clone.</p>
</td></tr>
<tr><td><code id="formatClones_+3A_mask_char">mask_char</code></td>
<td>
<p>character to use for masking and padding.</p>
</td></tr>
<tr><td><code id="formatClones_+3A_max_mask">max_mask</code></td>
<td>
<p>maximum number of characters to mask at the leading and trailing
sequence ends. If <code>NULL</code> then the upper masking bound will 
be automatically determined from the maximum number of observed 
leading or trailing Ns amongst all sequences. If set to <code>0</code> 
(default) then masking will not be performed.</p>
</td></tr>
<tr><td><code id="formatClones_+3A_pad_end">pad_end</code></td>
<td>
<p>if <code>TRUE</code> pad the end of each sequence with <code>mask_char</code>
to make every sequence the same length.</p>
</td></tr>
<tr><td><code id="formatClones_+3A_text_fields">text_fields</code></td>
<td>
<p>text annotation columns to retain and merge during duplicate removal.</p>
</td></tr>
<tr><td><code id="formatClones_+3A_num_fields">num_fields</code></td>
<td>
<p>numeric annotation columns to retain and sum during duplicate removal.</p>
</td></tr>
<tr><td><code id="formatClones_+3A_seq_fields">seq_fields</code></td>
<td>
<p>sequence annotation columns to retain and collapse during duplicate 
removal. Note, this is distinct from the <code>seq</code> and <code>germ</code> 
arguments, which contain the primary sequence data for the clone
and should not be repeated in this argument.</p>
</td></tr>
<tr><td><code id="formatClones_+3A_add_count">add_count</code></td>
<td>
<p>if <code>TRUE</code> add an additional annotation column called 
<code>COLLAPSE_COUNT</code> during duplicate removal that indicates the 
number of sequences that were collapsed.</p>
</td></tr>
<tr><td><code id="formatClones_+3A_verbose">verbose</code></td>
<td>
<p>passed on to <code>collapseDuplicates</code>. If <code>TRUE</code>, report the 
numbers of input, discarded and output sequences; otherwise, process
sequences silently.</p>
</td></tr>
<tr><td><code id="formatClones_+3A_collapse">collapse</code></td>
<td>
<p>collapse identical sequences?</p>
</td></tr>
<tr><td><code id="formatClones_+3A_cell">cell</code></td>
<td>
<p>name of the column containing cell assignment information</p>
</td></tr>
<tr><td><code id="formatClones_+3A_locus">locus</code></td>
<td>
<p>name of the column containing locus information</p>
</td></tr>
<tr><td><code id="formatClones_+3A_traits">traits</code></td>
<td>
<p>column ids to keep distinct during sequence collapse</p>
</td></tr>
<tr><td><code id="formatClones_+3A_mod3">mod3</code></td>
<td>
<p>pad sequences to length mutliple three?</p>
</td></tr>
<tr><td><code id="formatClones_+3A_randomize">randomize</code></td>
<td>
<p>randomize sequence order? Important if using PHYLIP</p>
</td></tr>
<tr><td><code id="formatClones_+3A_use_regions">use_regions</code></td>
<td>
<p>assign CDR/FWR regions?</p>
</td></tr>
<tr><td><code id="formatClones_+3A_dup_singles">dup_singles</code></td>
<td>
<p>Duplicate sequences in singleton clones to include them as trees?</p>
</td></tr>
<tr><td><code id="formatClones_+3A_nproc">nproc</code></td>
<td>
<p>number of cores to parallelize formating over.</p>
</td></tr>
<tr><td><code id="formatClones_+3A_chain">chain</code></td>
<td>
<p>if HL, include light chain information if available.</p>
</td></tr>
<tr><td><code id="formatClones_+3A_heavy">heavy</code></td>
<td>
<p>name of heavy chain locus (default = &quot;IGH&quot;)</p>
</td></tr>
<tr><td><code id="formatClones_+3A_filterstop">filterstop</code></td>
<td>
<p>only use sequences that do not contain an in-frame stop codon</p>
</td></tr>
<tr><td><code id="formatClones_+3A_minseq">minseq</code></td>
<td>
<p>minimum number of sequences per clone</p>
</td></tr>
<tr><td><code id="formatClones_+3A_split_light">split_light</code></td>
<td>
<p>split or lump subgroups? See <code>resolveLightChains</code>.</p>
</td></tr>
<tr><td><code id="formatClones_+3A_light_traits">light_traits</code></td>
<td>
<p>Include the traits from the light chain when concatenating and collapsing trees?</p>
</td></tr>
<tr><td><code id="formatClones_+3A_majoronly">majoronly</code></td>
<td>
<p>only return largest subgroup and sequences without light chains</p>
</td></tr>
<tr><td><code id="formatClones_+3A_columns">columns</code></td>
<td>
<p>additional data columns to include in output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for <a href="#topic+makeAirrClone">makeAirrClone</a>. Also removes whitespace,
;, :, and = from ids
</p>


<h3>Value</h3>

<p>A tibble of <a href="#topic+airrClone">airrClone</a> objects containing modified clones.
</p>


<h3>See Also</h3>

<p>Executes in order <a href="#topic+makeAirrClone">makeAirrClone</a>. Returns a tibble of 
<a href="#topic+airrClone">airrClone</a> objects 
which serve as input to <a href="#topic+getTrees">getTrees</a> and <a href="#topic+findSwitches">findSwitches</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ExampleAirr)
# Select two clones, for demonstration purpose
sel &lt;- c("3170", "3184")
clones &lt;- formatClones(ExampleAirr[ExampleAirr$clone_id %in% sel,],traits="sample_id")
</code></pre>

<hr>
<h2 id='getBootstraps'>Creates a bootstrap distribution for clone sequence alignments, and returns  
estimated trees for each bootstrap replicate as a nested list as a new input 
tibble column.</h2><span id='topic+getBootstraps'></span>

<h3>Description</h3>

<p><code>getBootstraps</code> Phylogenetic bootstrap function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBootstraps(
  clones,
  bootstraps,
  nproc = 1,
  bootstrap_nodes = TRUE,
  dir = NULL,
  id = NULL,
  build = "pratchet",
  exec = NULL,
  quiet = 0,
  rm_temp = TRUE,
  rep = NULL,
  seq = NULL,
  boot_part = "locus",
  by_codon = TRUE,
  starting_tree = FALSE,
  switches = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBootstraps_+3A_clones">clones</code></td>
<td>
<p>tibble <code>airrClone</code> objects, the output of 
<a href="#topic+formatClones">formatClones</a></p>
</td></tr>
<tr><td><code id="getBootstraps_+3A_bootstraps">bootstraps</code></td>
<td>
<p>number of bootstrap replicates to perform</p>
</td></tr>
<tr><td><code id="getBootstraps_+3A_nproc">nproc</code></td>
<td>
<p>number of cores to parallelize computations</p>
</td></tr>
<tr><td><code id="getBootstraps_+3A_bootstrap_nodes">bootstrap_nodes</code></td>
<td>
<p>a logical if the the nodes for each tree in the trees
column (required) should report their bootstrap value</p>
</td></tr>
<tr><td><code id="getBootstraps_+3A_dir">dir</code></td>
<td>
<p>directory where temporary files will be placed (required
if <code>igphyml</code> or <code>dnapars</code> specified)</p>
</td></tr>
<tr><td><code id="getBootstraps_+3A_id">id</code></td>
<td>
<p>unique identifer for this analysis (required if 
<code>igphyml</code> or <code>dnapars</code> specified)</p>
</td></tr>
<tr><td><code id="getBootstraps_+3A_build">build</code></td>
<td>
<p>program to use for tree building (phangorn, dnapars, igphyml)</p>
</td></tr>
<tr><td><code id="getBootstraps_+3A_exec">exec</code></td>
<td>
<p>location of desired phylogenetic executable</p>
</td></tr>
<tr><td><code id="getBootstraps_+3A_quiet">quiet</code></td>
<td>
<p>amount of rubbish to print to console</p>
</td></tr>
<tr><td><code id="getBootstraps_+3A_rm_temp">rm_temp</code></td>
<td>
<p>remove temporary files (default=TRUE)</p>
</td></tr>
<tr><td><code id="getBootstraps_+3A_rep">rep</code></td>
<td>
<p>current bootstrap replicate (experimental)</p>
</td></tr>
<tr><td><code id="getBootstraps_+3A_seq">seq</code></td>
<td>
<p>column name containing sequence information</p>
</td></tr>
<tr><td><code id="getBootstraps_+3A_boot_part">boot_part</code></td>
<td>
<p>is  &quot;locus&quot; bootstrap columns for each locus separately</p>
</td></tr>
<tr><td><code id="getBootstraps_+3A_by_codon">by_codon</code></td>
<td>
<p>a logical if the user wants to bootstrap by codon or by 
nucleotide. Default (codon based bootstrapping) is TRUE.</p>
</td></tr>
<tr><td><code id="getBootstraps_+3A_starting_tree">starting_tree</code></td>
<td>
<p>An indicator to use the existing trees column as the starting trees for RAxML</p>
</td></tr>
<tr><td><code id="getBootstraps_+3A_switches">switches</code></td>
<td>
<p>a logical indicator to allow findSwitches to do permutations.</p>
</td></tr>
<tr><td><code id="getBootstraps_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to tree building program</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input clones tibble with an additional column for the bootstrap replicate trees.
</p>

<hr>
<h2 id='getDivergence'>Get divergence from root of tree for each tip</h2><span id='topic+getDivergence'></span>

<h3>Description</h3>

<p><code>getDivergence</code> get sum of branch lengths leading from the 
root of the tree. If the germline sequence is included in the tree,
this will equal the germline divergence. If germline removed,
this will equal the MRCA divergence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDivergence(phy, minlength = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDivergence_+3A_phy">phy</code></td>
<td>
<p>Tree object</p>
</td></tr>
<tr><td><code id="getDivergence_+3A_minlength">minlength</code></td>
<td>
<p>Branch lengths to collapse in trees</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of each tip's divergence from the tree's root.
</p>

<hr>
<h2 id='getGermline'><a href="#topic+getGermline">getGermline</a> get germline segment from specified receptor and segment</h2><span id='topic+getGermline'></span>

<h3>Description</h3>

<p><a href="#topic+getGermline">getGermline</a> get germline segment from specified receptor and segment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGermline(
  receptor,
  references,
  segment,
  field,
  germ_start,
  germ_end,
  germ_length,
  germ_aa_start,
  germ_aa_length,
  amino_acid = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGermline_+3A_receptor">receptor</code></td>
<td>
<p>row from AIRR-table containing sequence of interest</p>
</td></tr>
<tr><td><code id="getGermline_+3A_references">references</code></td>
<td>
<p>list of reference segments. Must be specific to
locus and segment</p>
</td></tr>
<tr><td><code id="getGermline_+3A_segment">segment</code></td>
<td>
<p>Gene segment to search. Must be V, D, or J.</p>
</td></tr>
<tr><td><code id="getGermline_+3A_field">field</code></td>
<td>
<p>Column name for segment gene call (e.g. v_call)</p>
</td></tr>
<tr><td><code id="getGermline_+3A_germ_start">germ_start</code></td>
<td>
<p>Column name of index of segment start within germline 
segment (e.g. v_germline_start)</p>
</td></tr>
<tr><td><code id="getGermline_+3A_germ_end">germ_end</code></td>
<td>
<p>Similar to germ_start, but specifies end of segment 
(e.g. v_germline_end)</p>
</td></tr>
<tr><td><code id="getGermline_+3A_germ_length">germ_length</code></td>
<td>
<p>Similar to germ_start, but specifies length of segment
(e.g. v_germline_end)</p>
</td></tr>
<tr><td><code id="getGermline_+3A_germ_aa_start">germ_aa_start</code></td>
<td>
<p>Column name of index of segment start within germline 
segment in AA (if amino_acid=TRUE, e.g. v_germline_start)</p>
</td></tr>
<tr><td><code id="getGermline_+3A_germ_aa_length">germ_aa_length</code></td>
<td>
<p>Similar to germ_start, but specifies length of segment
in AA (if amino_acid=TRUE, e.g. v_germline_end)</p>
</td></tr>
<tr><td><code id="getGermline_+3A_amino_acid">amino_acid</code></td>
<td>
<p>Perform reconstruction on amino acid sequence (experimental)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String of germline sequence from specified segment aligned with the 
sequence in the seq column of <code>receptor</code>.
</p>

<hr>
<h2 id='getNodeSeq'>Return IMGT gapped sequence of specified tree node</h2><span id='topic+getNodeSeq'></span>

<h3>Description</h3>

<p><code>getNodeSeq</code> Sequence retrieval function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNodeSeq(data, node, tree = NULL, clone = NULL, gaps = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNodeSeq_+3A_data">data</code></td>
<td>
<p>a tibble of <code>airrClone</code> objects, the output of 
<a href="#topic+getTrees">getTrees</a></p>
</td></tr>
<tr><td><code id="getNodeSeq_+3A_node">node</code></td>
<td>
<p>numeric node in tree (see details)</p>
</td></tr>
<tr><td><code id="getNodeSeq_+3A_tree">tree</code></td>
<td>
<p>a <code>phylo</code> tree object containing <code>node</code></p>
</td></tr>
<tr><td><code id="getNodeSeq_+3A_clone">clone</code></td>
<td>
<p>if <code>tree</code> not specified, supply clone ID in <code>data</code></p>
</td></tr>
<tr><td><code id="getNodeSeq_+3A_gaps">gaps</code></td>
<td>
<p>add IMGT gaps to output sequences?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use plotTrees(trees)[[1]] + geom_label(aes(label=node))+geom_tippoint() to show
node labels, and getNodeSeq to return internal node sequences
</p>


<h3>Value</h3>

<p>A vector with sequence for each locus at a specified <code>node</code>
in <code>tree</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+getTrees">getTrees</a>
</p>

<hr>
<h2 id='getPalette'>Get a color palette for a predefined set of trait values. 
'Germline' defaults to black unless specified.</h2><span id='topic+getPalette'></span>

<h3>Description</h3>

<p><code>getPalette</code> Gets a color palette for a predefined set of trait values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPalette(states, palette)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPalette_+3A_states">states</code></td>
<td>
<p>states in model</p>
</td></tr>
<tr><td><code id="getPalette_+3A_palette">palette</code></td>
<td>
<p>The colorbrewer palette to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector with each state corresponding to a color
</p>


<h3>See Also</h3>

<p><a href="#topic+getTrees">getTrees</a>, <a href="#topic+plotTrees">plotTrees</a>
</p>

<hr>
<h2 id='getSeq'>Deprecated! Use getNodeSeq</h2><span id='topic+getSeq'></span>

<h3>Description</h3>

<p><code>getSeq</code> Sequence retrieval function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSeq(data, node, tree = NULL, clone = NULL, gaps = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSeq_+3A_data">data</code></td>
<td>
<p>a tibble of <code>airrClone</code> objects, the output of
<a href="#topic+getTrees">getTrees</a></p>
</td></tr>
<tr><td><code id="getSeq_+3A_node">node</code></td>
<td>
<p>numeric node in tree (see details)</p>
</td></tr>
<tr><td><code id="getSeq_+3A_tree">tree</code></td>
<td>
<p>a <code>phylo</code> tree object containing <code>node</code></p>
</td></tr>
<tr><td><code id="getSeq_+3A_clone">clone</code></td>
<td>
<p>if <code>tree</code> not specified, supply clone ID in <code>data</code></p>
</td></tr>
<tr><td><code id="getSeq_+3A_gaps">gaps</code></td>
<td>
<p>add IMGT gaps to output sequences?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with sequence for each locus at a specified <code>node</code>
in <code>tree</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+getTrees">getTrees</a>
</p>

<hr>
<h2 id='getSubclones'>#' Deprecated! Use resolveLightChains</h2><span id='topic+getSubclones'></span>

<h3>Description</h3>

<p><code>getSubClones</code> plots a tree or group of trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSubclones(
  heavy,
  light,
  nproc = 1,
  minseq = 1,
  id = "sequence_id",
  seq = "sequence_alignment",
  clone = "clone_id",
  cell = "cell_id",
  v_call = "v_call",
  j_call = "j_call",
  junc_len = "junction_length",
  nolight = "missing"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSubclones_+3A_heavy">heavy</code></td>
<td>
<p>a tibble containing heavy chain sequences with clone_id</p>
</td></tr>
<tr><td><code id="getSubclones_+3A_light">light</code></td>
<td>
<p>a tibble containing light chain sequences</p>
</td></tr>
<tr><td><code id="getSubclones_+3A_nproc">nproc</code></td>
<td>
<p>number of cores for parallelization</p>
</td></tr>
<tr><td><code id="getSubclones_+3A_minseq">minseq</code></td>
<td>
<p>minimum number of sequences per clone</p>
</td></tr>
<tr><td><code id="getSubclones_+3A_id">id</code></td>
<td>
<p>name of the column containing sequence identifiers.</p>
</td></tr>
<tr><td><code id="getSubclones_+3A_seq">seq</code></td>
<td>
<p>name of the column containing observed DNA sequences. All 
sequences in this column must be multiple aligned.</p>
</td></tr>
<tr><td><code id="getSubclones_+3A_clone">clone</code></td>
<td>
<p>name of the column containing the identifier for the clone. All 
entries in this column should be identical.</p>
</td></tr>
<tr><td><code id="getSubclones_+3A_cell">cell</code></td>
<td>
<p>name of the column containing identifier for cells.</p>
</td></tr>
<tr><td><code id="getSubclones_+3A_v_call">v_call</code></td>
<td>
<p>name of the column containing V-segment allele assignments. All 
entries in this column should be identical to the gene level.</p>
</td></tr>
<tr><td><code id="getSubclones_+3A_j_call">j_call</code></td>
<td>
<p>name of the column containing J-segment allele assignments. All 
entries in this column should be identical to the gene level.</p>
</td></tr>
<tr><td><code id="getSubclones_+3A_junc_len">junc_len</code></td>
<td>
<p>name of the column containing the length of the junction as a 
numeric value. All entries in this column should be identical 
for any given clone.</p>
</td></tr>
<tr><td><code id="getSubclones_+3A_nolight">nolight</code></td>
<td>
<p>string to use to indicate a missing light chain</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble containing
</p>

<hr>
<h2 id='getSubTaxa'>Get the tip labels as part of a clade defined by an internal node</h2><span id='topic+getSubTaxa'></span>

<h3>Description</h3>

<p><code>getSubTaxa</code> Gets the tip labels from a clade
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSubTaxa(node, tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSubTaxa_+3A_node">node</code></td>
<td>
<p>node number that defines the target clade</p>
</td></tr>
<tr><td><code id="getSubTaxa_+3A_tree">tree</code></td>
<td>
<p><code>phylo</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing tip labels of the clade
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get taxa from all subtrees
data(BiopsyTrees)
tree &lt;- BiopsyTrees$trees[[8]]
all_subtrees &lt;- lapply(1:length(tree$nodes), function(x)getSubTaxa(x, tree))

</code></pre>

<hr>
<h2 id='getTrees'>Estimate lineage tree topologies, branch lengths,
and internal node states if desired</h2><span id='topic+getTrees'></span>

<h3>Description</h3>

<p><code>getTrees</code> Tree building function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTrees(
  clones,
  trait = NULL,
  id = NULL,
  dir = NULL,
  modelfile = NULL,
  build = "pratchet",
  exec = NULL,
  igphyml = NULL,
  fixtrees = FALSE,
  nproc = 1,
  quiet = 0,
  rm_temp = TRUE,
  palette = NULL,
  seq = NULL,
  collapse = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTrees_+3A_clones">clones</code></td>
<td>
<p>a tibble of <code>airrClone</code> objects, the output of
<a href="#topic+formatClones">formatClones</a></p>
</td></tr>
<tr><td><code id="getTrees_+3A_trait">trait</code></td>
<td>
<p>trait to use for parsimony models (required if
<code>igphyml</code> specified)</p>
</td></tr>
<tr><td><code id="getTrees_+3A_id">id</code></td>
<td>
<p>unique identifer for this analysis (required if
<code>igphyml</code> or <code>dnapars</code> specified)</p>
</td></tr>
<tr><td><code id="getTrees_+3A_dir">dir</code></td>
<td>
<p>directory where temporary files will be placed.</p>
</td></tr>
<tr><td><code id="getTrees_+3A_modelfile">modelfile</code></td>
<td>
<p>file specifying parsimony model to use</p>
</td></tr>
<tr><td><code id="getTrees_+3A_build">build</code></td>
<td>
<p>program to use for tree building (pratchet, pml,
dnapars, dnaml, igphyml)</p>
</td></tr>
<tr><td><code id="getTrees_+3A_exec">exec</code></td>
<td>
<p>location of desired phylogenetic executable</p>
</td></tr>
<tr><td><code id="getTrees_+3A_igphyml">igphyml</code></td>
<td>
<p>optional location of igphyml executible for parsimony</p>
</td></tr>
<tr><td><code id="getTrees_+3A_fixtrees">fixtrees</code></td>
<td>
<p>if TRUE, use supplied tree topologies</p>
</td></tr>
<tr><td><code id="getTrees_+3A_nproc">nproc</code></td>
<td>
<p>number of cores to parallelize computations</p>
</td></tr>
<tr><td><code id="getTrees_+3A_quiet">quiet</code></td>
<td>
<p>amount of rubbish to print to console</p>
</td></tr>
<tr><td><code id="getTrees_+3A_rm_temp">rm_temp</code></td>
<td>
<p>remove temporary files (default=TRUE)</p>
</td></tr>
<tr><td><code id="getTrees_+3A_palette">palette</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="getTrees_+3A_seq">seq</code></td>
<td>
<p>column name containing sequence information</p>
</td></tr>
<tr><td><code id="getTrees_+3A_collapse">collapse</code></td>
<td>
<p>Collapse internal nodes with identical sequences?</p>
</td></tr>
<tr><td><code id="getTrees_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to tree building programs</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates phylogenetic tree topologies and branch lengths for a list of
<code>airrClone</code> objects. By default, it will use phangnorn::pratchet to
estimate maximum parsimony tree topologies, and ape::acctran to estimate
branch lengths. If <code>igpyhml</code> is specified, internal node <code>trait</code>
values will be predicted by maximum parsimony. In this case, <code>dir</code> will
need to be specified as a temporary directory to place all the intermediate
files (will be created if not available). Further, <code>id</code> will need to
specified to serve as a unique identifier for the temporary files. This
should be chosen to ensure that multiple <code>getTrees</code> calls using the same
<code>dir</code> do not overwrite each others files.
</p>
<p><code>modelfile</code> is written automatically if not specified, but doesn't
include any constraints. Intermediate files are deleted by default. This can
be toggled using (<code>rm_files</code>).
</p>
<p>For examples and vignettes, see https://dowser.readthedocs.io
</p>


<h3>Value</h3>

<p>A list of <code>phylo</code> objects in the same order as <code>data</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+formatClones">formatClones</a>, <a href="#topic+findSwitches">findSwitches</a>, <a href="#topic+buildPhylo">buildPhylo</a>,
<a href="#topic+buildPratchet">buildPratchet</a>, <a href="#topic+buildPML">buildPML</a>, <a href="#topic+buildIgphyml">buildIgphyml</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ExampleClones)

trees &lt;- getTrees(ExampleClones[10,])
plotTrees(trees)[[1]]

## Not run: 
data(ExampleClones)

trees &lt;- getTrees(ExampleClones[10,],igphyml="/path/to/igphyml",
         id="temp",dir="temp", trait="sample_id")
plotTrees(trees)[[1]]

## End(Not run)
</code></pre>

<hr>
<h2 id='IsotypeTrees'>Example Ig lineage trees with isotype reconstructions.</h2><span id='topic+IsotypeTrees'></span>

<h3>Description</h3>

<p>Same as ExampleClones but with isotypes predicted at internal nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IsotypeTrees
</code></pre>


<h3>Format</h3>

<p>A tibble of airrClone and phylo objects output by getTrees.
</p>

<ul>
<li>  <p><code>clone_id</code>:   Clonal cluster
</p>
</li>
<li>  <p><code>data</code>:       List of airrClone objects
</p>
</li>
<li>  <p><code>seqs</code>:       Number of sequences
</p>
</li>
<li>  <p><code>trees</code>:      List of phylo objects
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+IsotypeTrees">IsotypeTrees</a>
</p>

<hr>
<h2 id='makeAirrClone'>Generate a airrClone object for lineage construction</h2><span id='topic+makeAirrClone'></span>

<h3>Description</h3>

<p><code>makeAirrClone</code> takes a data.frame with AIRR or Change-O style columns as input and 
masks gap positions, masks ragged ends, removes duplicates sequences, and merges 
annotations associated with duplicate sequences. It returns a <code>airrClone</code> 
object which serves as input for lineage reconstruction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeAirrClone(
  data,
  id = "sequence_id",
  seq = "sequence_alignment",
  germ = "germline_alignment_d_mask",
  v_call = "v_call",
  j_call = "j_call",
  junc_len = "junction_length",
  clone = "clone_id",
  subgroup = "clone_subgroup",
  mask_char = "N",
  max_mask = 0,
  pad_end = TRUE,
  text_fields = NULL,
  num_fields = NULL,
  seq_fields = NULL,
  add_count = TRUE,
  verbose = FALSE,
  collapse = TRUE,
  chain = "H",
  heavy = NULL,
  cell = "cell_id",
  locus = "locus",
  traits = NULL,
  mod3 = TRUE,
  randomize = TRUE,
  use_regions = TRUE,
  dup_singles = FALSE,
  light_traits = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeAirrClone_+3A_data">data</code></td>
<td>
<p>data.frame containing the AIRR or Change-O data for a clone. See Details
for the list of required columns and their default values.</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_id">id</code></td>
<td>
<p>name of the column containing sequence identifiers.</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_seq">seq</code></td>
<td>
<p>name of the column containing observed DNA sequences. All 
sequences in this column must be multiple aligned.</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_germ">germ</code></td>
<td>
<p>name of the column containing germline DNA sequences. All entries 
in this column should be identical for any given clone, and they
must be multiple aligned with the data in the <code>seq</code> column.</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_v_call">v_call</code></td>
<td>
<p>name of the column containing V-segment allele assignments. All 
entries in this column should be identical to the gene level.</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_j_call">j_call</code></td>
<td>
<p>name of the column containing J-segment allele assignments. All 
entries in this column should be identical to the gene level.</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_junc_len">junc_len</code></td>
<td>
<p>name of the column containing the length of the junction as a 
numeric value. All entries in this column should be identical 
for any given clone.</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_clone">clone</code></td>
<td>
<p>name of the column containing the identifier for the clone. All 
entries in this column should be identical.</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_subgroup">subgroup</code></td>
<td>
<p>name of the column containing the identifier for the subgroup.</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_mask_char">mask_char</code></td>
<td>
<p>character to use for masking and padding.</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_max_mask">max_mask</code></td>
<td>
<p>maximum number of characters to mask at the leading and trailing
sequence ends. If <code>NULL</code> then the upper masking bound will 
be automatically determined from the maximum number of observed 
leading or trailing Ns amongst all sequences. If set to <code>0</code> 
(default) then masking will not be performed.</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_pad_end">pad_end</code></td>
<td>
<p>if <code>TRUE</code> pad the end of each sequence with <code>mask_char</code>
to make every sequence the same length.</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_text_fields">text_fields</code></td>
<td>
<p>text annotation columns to retain and merge during duplicate removal.</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_num_fields">num_fields</code></td>
<td>
<p>numeric annotation columns to retain and sum during duplicate removal.</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_seq_fields">seq_fields</code></td>
<td>
<p>sequence annotation columns to retain and collapse during duplicate 
removal. Note, this is distinct from the <code>seq</code> and <code>germ</code> 
arguments, which contain the primary sequence data for the clone
and should not be repeated in this argument.</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_add_count">add_count</code></td>
<td>
<p>if <code>TRUE</code> add an additional annotation column called 
<code>COLLAPSE_COUNT</code> during duplicate removal that indicates the 
number of sequences that were collapsed.</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_verbose">verbose</code></td>
<td>
<p>passed on to <code>collapseDuplicates</code>. If <code>TRUE</code>, report the 
numbers of input, discarded and output sequences; otherwise, process
sequences silently.</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_collapse">collapse</code></td>
<td>
<p>collapse identical sequences?</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_chain">chain</code></td>
<td>
<p>if HL, include light chain information if available.</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_heavy">heavy</code></td>
<td>
<p>name of heavy chain locus (default = &quot;IGH&quot;)</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_cell">cell</code></td>
<td>
<p>name of the column containing cell assignment information</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_locus">locus</code></td>
<td>
<p>name of the column containing locus information</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_traits">traits</code></td>
<td>
<p>column ids to keep distinct during sequence collapse</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_mod3">mod3</code></td>
<td>
<p>pad sequences to length mutliple three?</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_randomize">randomize</code></td>
<td>
<p>randomize sequence order? Important if using PHYLIP</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_use_regions">use_regions</code></td>
<td>
<p>assign CDR/FWR regions?</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_dup_singles">dup_singles</code></td>
<td>
<p>Duplicate sequences in singleton clones to include them as trees?</p>
</td></tr>
<tr><td><code id="makeAirrClone_+3A_light_traits">light_traits</code></td>
<td>
<p>Include the traits from the light chain when concatenating and collapsing trees?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input data.frame (<code>data</code>) must columns for each of the required column name 
arguments: <code>id</code>, <code>seq</code>, <code>germ</code>, <code>v_call</code>, <code>j_call</code>, 
<code>junc_len</code>, and <code>clone</code>.  
Additional annotation columns specified in the <code>traits</code>, <code>text_fields</code>, 
<code>num_fields</code> or <code>seq_fields</code> arguments will be retained in the <code>data</code> 
slot of the return object, but are not required. These options differ by their behavior
among collapsed sequences. Identical sequences that differ by any values specified in the
<code>traits</code> option will be kept distinct. Identical sequences that differ only by
values in the <code>num_fields</code> option will be collapsed and the values of their 
<code>num_fields</code> columns will be added together. Similar behavior occurs with 
<code>text_fields</code> but the unique values will concatenated with a comma.
</p>
<p>The default columns are IMGT-gapped sequence columns, but this is not a requirement. 
However, all sequences (both observed and germline) must be multiple aligned using
some scheme for both proper duplicate removal and lineage reconstruction. 
</p>
<p>The value for the germline sequence, V-segment gene call, J-segment gene call, 
junction length, and clone identifier are determined from the first entry in the 
<code>germ</code>, <code>v_call</code>, <code>j_call</code>, <code>junc_len</code> and <code>clone</code> columns, 
respectively. For any given clone, each value in these columns should be identical.
</p>
<p>To allow for cases where heavy and light chains are used, this function returns three
sequence columns for heavy chains (sequence), light chain (lsequence, empty if none 
available), and concatenated heavy+light chain (hlsequence). These contain sequences
in alignment with germline, lgermline, and hlgermline slots, respectively. The sequence
column used for build trees is specified in the <code>phylo_seq</code> slot. Importantly, 
this column is also the sequence column that also has uninformative columns removed
by <code>cleanAlignment</code>. It is highly likely we will change this system to a single 
<code>sequence</code> and <code>germline</code> slot in the near future.
</p>
<p>The airrClone object also contains vectors <code>locus</code>, <code>region</code>, and 
<code>numbers</code>, which contain the locus, IMGT region, and IMGT number for each position
in the sequence column specified in <code>phylo_seq</code>. If IMGT-gapped sequences are not 
supplied, this will likely result in an error. Specify <code>use_regions=FALSE</code> if not
using IMGT-gapped sequences
</p>


<h3>Value</h3>

<p>A <a href="#topic+airrClone">airrClone</a> object containing the modified clone.
</p>


<h3>See Also</h3>

<p>Returns an <a href="#topic+airrClone">airrClone</a>. See <a href="#topic+formatClones">formatClones</a> to generate an 
ordered list of airrClone objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ExampleAirr)
airr_clone &lt;- makeAirrClone(ExampleAirr[ExampleAirr$clone_id=="3184",])
</code></pre>

<hr>
<h2 id='makeModelFile'>Make a parsimony model file</h2><span id='topic+makeModelFile'></span>

<h3>Description</h3>

<p><code>makeModelFile</code> Filler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeModelFile(file, states, constraints = NULL, exceptions = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeModelFile_+3A_file">file</code></td>
<td>
<p>model file name to write.</p>
</td></tr>
<tr><td><code id="makeModelFile_+3A_states">states</code></td>
<td>
<p>vector of states to include in model.</p>
</td></tr>
<tr><td><code id="makeModelFile_+3A_constraints">constraints</code></td>
<td>
<p>constraints to add to model.</p>
</td></tr>
<tr><td><code id="makeModelFile_+3A_exceptions">exceptions</code></td>
<td>
<p>vector of comma-separated states that are 
exceptions to constraints</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently the only option for <code>constraints</code> is &quot;irrev&quot;, which
forbids switches moving from left to right in the <code>states</code> vector.
</p>


<h3>Value</h3>

<p>Name of model file
</p>


<h3>See Also</h3>

<p><a href="#topic+readModelFile">readModelFile</a>, <a href="#topic+getTrees">getTrees</a>, <a href="#topic+findSwitches">findSwitches</a>
</p>

<hr>
<h2 id='maskCodons'><code>maskCodons</code> Masks codons split by insertions</h2><span id='topic+maskCodons'></span>

<h3>Description</h3>

<p><code>maskCodons</code> Masks codons split by insertions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maskCodons(
  id,
  q,
  s,
  keep_alignment = FALSE,
  gap_opening = 5,
  gap_extension = 1,
  keep_insertions = FALSE,
  mask = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maskCodons_+3A_id">id</code></td>
<td>
<p>sequence id</p>
</td></tr>
<tr><td><code id="maskCodons_+3A_q">q</code></td>
<td>
<p>(query) un-aligned input sequence (sequence)</p>
</td></tr>
<tr><td><code id="maskCodons_+3A_s">s</code></td>
<td>
<p>(subject) aligned input sequence (sequence_alignment)</p>
</td></tr>
<tr><td><code id="maskCodons_+3A_keep_alignment">keep_alignment</code></td>
<td>
<p>store q and s alignments</p>
</td></tr>
<tr><td><code id="maskCodons_+3A_gap_opening">gap_opening</code></td>
<td>
<p>gap opening penalty (Biostrings::pairwiseALignment)</p>
</td></tr>
<tr><td><code id="maskCodons_+3A_gap_extension">gap_extension</code></td>
<td>
<p>gap extension penalty (Biostrings::pairwiseALignment)</p>
</td></tr>
<tr><td><code id="maskCodons_+3A_keep_insertions">keep_insertions</code></td>
<td>
<p>return removed insertion sequences?</p>
</td></tr>
<tr><td><code id="maskCodons_+3A_mask">mask</code></td>
<td>
<p>if FALSE, don't mask codons</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs global alignment of q and s, masks codons in s that are split by 
insertions (see example)
masking_note notes codon positions in subject_alignment sequence that were 
masked, if found.
subject_alignment contains subject sequence aligned to query (q) sequence
query_alignment contains query sequence aligned to subject (q) sequence
sequence_masked will be NA if frameshift or alignment error detected/
</p>


<h3>Value</h3>

<p>A list with split codons masked, if found (sequence_masked).
</p>


<h3>See Also</h3>

<p><a href="#topic+maskSequences">maskSequences</a>, Biostrings::pairwiseAlignment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s = "ATCATCATC..."
q = "ATCTTTATCATC"
print(maskCodons(1,q,s,TRUE))

s &lt;- "ATCATCATC..."
q &lt;- "ATTTTCATCATC"
print(maskCodons("test",q,s,keep_alignment=TRUE,keep_insertions=TRUE))
</code></pre>

<hr>
<h2 id='maskSequences'><code>maskSequences</code> Mask codons split by insertions in V gene</h2><span id='topic+maskSequences'></span>

<h3>Description</h3>

<p><code>maskSequences</code> Mask codons split by insertions in V gene
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maskSequences(
  data,
  sequence_id = "sequence_id",
  sequence = "sequence",
  sequence_alignment = "sequence_alignment",
  v_sequence_start = "v_sequence_start",
  v_sequence_end = "v_sequence_end",
  v_germline_start = "v_germline_start",
  v_germline_end = "v_germline_end",
  junction_length = "junction_length",
  keep_alignment = FALSE,
  keep_insertions = FALSE,
  mask_codons = TRUE,
  mask_cdr3 = TRUE,
  nproc = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maskSequences_+3A_data">data</code></td>
<td>
<p>BCR data table</p>
</td></tr>
<tr><td><code id="maskSequences_+3A_sequence_id">sequence_id</code></td>
<td>
<p>sequence id column</p>
</td></tr>
<tr><td><code id="maskSequences_+3A_sequence">sequence</code></td>
<td>
<p>input sequence column (query)</p>
</td></tr>
<tr><td><code id="maskSequences_+3A_sequence_alignment">sequence_alignment</code></td>
<td>
<p>aligned (IMGT-gapped) sequence column (subject)</p>
</td></tr>
<tr><td><code id="maskSequences_+3A_v_sequence_start">v_sequence_start</code></td>
<td>
<p>V gene start position in sequence</p>
</td></tr>
<tr><td><code id="maskSequences_+3A_v_sequence_end">v_sequence_end</code></td>
<td>
<p>V gene end position in sequence</p>
</td></tr>
<tr><td><code id="maskSequences_+3A_v_germline_start">v_germline_start</code></td>
<td>
<p>V gene start position in sequence_alignment</p>
</td></tr>
<tr><td><code id="maskSequences_+3A_v_germline_end">v_germline_end</code></td>
<td>
<p>V gene end position in sequence_alignment</p>
</td></tr>
<tr><td><code id="maskSequences_+3A_junction_length">junction_length</code></td>
<td>
<p>name of junction_length column</p>
</td></tr>
<tr><td><code id="maskSequences_+3A_keep_alignment">keep_alignment</code></td>
<td>
<p>store alignment of query and subject sequences?</p>
</td></tr>
<tr><td><code id="maskSequences_+3A_keep_insertions">keep_insertions</code></td>
<td>
<p>return removed insertion sequences?</p>
</td></tr>
<tr><td><code id="maskSequences_+3A_mask_codons">mask_codons</code></td>
<td>
<p>mask split codons?</p>
</td></tr>
<tr><td><code id="maskSequences_+3A_mask_cdr3">mask_cdr3</code></td>
<td>
<p>mask CDR3 sequences?</p>
</td></tr>
<tr><td><code id="maskSequences_+3A_nproc">nproc</code></td>
<td>
<p>number of cores to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs global alignment of sequence and sequence_alignment, 
masking codons in sequence_alignment that are split by insertions (see examples)
masking_note notes codon positions in subject_alignment sequence that 
were masked, if found.
subject_alignment contains subject sequence aligned to query sequence (only 
if keep_alignment=TRUE)
query_alignment contains query sequence aligned to subject sequence (only if 
keep_alignment=TRUE)
sequence_masked will be NA if frameshift or alignment error detected. This 
will be noted
insertions column will be returned if keep_insertions=TRUE, contains a
comma-separated list of each &lt;position in query alignment&gt;-&lt;sequence&gt;. See example.
in masking_note.
</p>


<h3>Value</h3>

<p>A tibble with masked sequence in sequence_masked column, 
as well as other columns.
</p>


<h3>See Also</h3>

<p><a href="#topic+maskCodons">maskCodons</a>, Biostrings::pairwiseAlignment.
</p>

<hr>
<h2 id='plotTrees'>Plot a tree with colored internal node labels using ggtree</h2><span id='topic+plotTrees'></span>

<h3>Description</h3>

<p><code>plotTrees</code> plots a tree or group of trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTrees(
  trees,
  nodes = FALSE,
  tips = NULL,
  tipsize = NULL,
  scale = 0.01,
  palette = "Dark2",
  base = FALSE,
  layout = "rectangular",
  node_nums = FALSE,
  tip_nums = FALSE,
  title = TRUE,
  labelsize = NULL,
  common_scale = FALSE,
  ambig = "grey",
  bootstrap_scores = FALSE,
  tip_palette = NULL,
  node_palette = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTrees_+3A_trees">trees</code></td>
<td>
<p>A tibble containing <code>phylo</code> and <code>airrClone</code>
objects</p>
</td></tr>
<tr><td><code id="plotTrees_+3A_nodes">nodes</code></td>
<td>
<p>color internal nodes if possible?</p>
</td></tr>
<tr><td><code id="plotTrees_+3A_tips">tips</code></td>
<td>
<p>color tips if possible?</p>
</td></tr>
<tr><td><code id="plotTrees_+3A_tipsize">tipsize</code></td>
<td>
<p>size of tip shape objects</p>
</td></tr>
<tr><td><code id="plotTrees_+3A_scale">scale</code></td>
<td>
<p>width of branch length scale bar</p>
</td></tr>
<tr><td><code id="plotTrees_+3A_palette">palette</code></td>
<td>
<p>color palette for tips and/or nodes. Can supply a named vector
for all tip states, or a palette named passed to
ggplot2::scale_color_brewer (e.g. &quot;Dark2&quot;, &quot;Paired&quot;, &quot;Set1&quot;) or
ggplot2::scale_color_distiller (e.g. RdYlBu) or</p>
</td></tr>
<tr><td><code id="plotTrees_+3A_base">base</code></td>
<td>
<p>recursion base case (don't edit)</p>
</td></tr>
<tr><td><code id="plotTrees_+3A_layout">layout</code></td>
<td>
<p>rectangular or circular tree layout?</p>
</td></tr>
<tr><td><code id="plotTrees_+3A_node_nums">node_nums</code></td>
<td>
<p>plot internal node numbers?</p>
</td></tr>
<tr><td><code id="plotTrees_+3A_tip_nums">tip_nums</code></td>
<td>
<p>plot tip numbers?</p>
</td></tr>
<tr><td><code id="plotTrees_+3A_title">title</code></td>
<td>
<p>use clone id as title?</p>
</td></tr>
<tr><td><code id="plotTrees_+3A_labelsize">labelsize</code></td>
<td>
<p>text size</p>
</td></tr>
<tr><td><code id="plotTrees_+3A_common_scale">common_scale</code></td>
<td>
<p>strecth plots so branches are on same scale?
determined by sequence with highest divergence</p>
</td></tr>
<tr><td><code id="plotTrees_+3A_ambig">ambig</code></td>
<td>
<p>How to color ambiguous node reconstructions? (grey or blend)</p>
</td></tr>
<tr><td><code id="plotTrees_+3A_bootstrap_scores">bootstrap_scores</code></td>
<td>
<p>Show bootstrap scores for internal nodes? See getBootstraps.</p>
</td></tr>
<tr><td><code id="plotTrees_+3A_tip_palette">tip_palette</code></td>
<td>
<p>deprecated, use palette</p>
</td></tr>
<tr><td><code id="plotTrees_+3A_node_palette">node_palette</code></td>
<td>
<p>deprecated, use palette</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function uses <code>ggtree</code> functions to plot tree topologlies estimated by 
<a href="#topic+getTrees">getTrees</a>, and <a href="#topic+findSwitches">findSwitches</a>. Object can be further modified with 
<code>ggtree</code> functions. Please check out 
https://bioconductor.org/packages/devel/bioc/vignettes/ggtree/inst/doc/ggtree.html and
cite <code>ggtree</code> in addition to <code>dowser</code> if you use this function.
</p>


<h3>Value</h3>

<p>a grob containing a tree plotted by <code>ggtree</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+getTrees">getTrees</a>, <a href="#topic+findSwitches">findSwitches</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ExampleClones)
trees &lt;- getTrees(ExampleClones[10,])
plotTrees(trees)[[1]]
</code></pre>

<hr>
<h2 id='readFasta'>Read a fasta file into a list of sequences
<code>readFasta</code> reads a fasta file</h2><span id='topic+readFasta'></span>

<h3>Description</h3>

<p>Read a fasta file into a list of sequences
<code>readFasta</code> reads a fasta file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readFasta(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readFasta_+3A_file">file</code></td>
<td>
<p>FASTA file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of sequences
</p>

<hr>
<h2 id='readIMGT'><code>readIMGT</code> read in IMGT database</h2><span id='topic+readIMGT'></span>

<h3>Description</h3>

<p>Loads all reference germlines from an Immcantation-formatted IMGT database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readIMGT(dir, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readIMGT_+3A_dir">dir</code></td>
<td>
<p>directory containing Immcantation-formatted IMGT database</p>
</td></tr>
<tr><td><code id="readIMGT_+3A_quiet">quiet</code></td>
<td>
<p>print warnings?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input directory must be formatted to Immcantation standard.
See https://changeo.readthedocs.io/en/stable/examples/igblast.html for example
of how to download.
</p>


<h3>Value</h3>

<p>List of lists, leading to IMGT-gapped nucleotide sequences.
Structure of object is list[[locus]][[segment]]
locus refers to locus (e.g. IGH, IGK, TRA)
segment refers to gene segment caegory (V, D, or J)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># vdj_dir contains a minimal example of reference germlines 
# (IGHV3-11*05, IGHD3-10*01 and IGHJ5*02)
# which are the gene assignments for ExamapleDb[1,]
vdj_dir &lt;- system.file("extdata", "germlines", "imgt", "human", "vdj", package="dowser")
imgt &lt;- readIMGT(vdj_dir)
</code></pre>

<hr>
<h2 id='readLineages'>Read in all trees from a lineages file</h2><span id='topic+readLineages'></span>

<h3>Description</h3>

<p>Read in all trees from a lineages file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readLineages(
  file,
  states = NULL,
  palette = NULL,
  run_id = "",
  quiet = TRUE,
  append = NULL,
  format = "nexus",
  type = "jointpars"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readLineages_+3A_file">file</code></td>
<td>
<p>IgPhyML lineage file</p>
</td></tr>
<tr><td><code id="readLineages_+3A_states">states</code></td>
<td>
<p>states in parsimony model</p>
</td></tr>
<tr><td><code id="readLineages_+3A_palette">palette</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="readLineages_+3A_run_id">run_id</code></td>
<td>
<p>id used for IgPhyML run</p>
</td></tr>
<tr><td><code id="readLineages_+3A_quiet">quiet</code></td>
<td>
<p>avoid printing rubbish on screen?</p>
</td></tr>
<tr><td><code id="readLineages_+3A_append">append</code></td>
<td>
<p>string appended to fasta files</p>
</td></tr>
<tr><td><code id="readLineages_+3A_format">format</code></td>
<td>
<p>format of input file with trees</p>
</td></tr>
<tr><td><code id="readLineages_+3A_type">type</code></td>
<td>
<p>Read in parsimony reconstructions or ancestral sequence
reconstructions? &quot;jointpars&quot; reads in parsimony states, 
others read in sequences in internal nodes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of phylo objects from <code>file</code>.
</p>

<hr>
<h2 id='readModelFile'>Read in a parsimony model file</h2><span id='topic+readModelFile'></span>

<h3>Description</h3>

<p><code>readModelFile</code> Filler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readModelFile(file, useambig = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readModelFile_+3A_file">file</code></td>
<td>
<p>parimony model file.</p>
</td></tr>
<tr><td><code id="readModelFile_+3A_useambig">useambig</code></td>
<td>
<p>use ambiguous naming as specified in the file?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector containing the states of the model
</p>


<h3>See Also</h3>

<p><a href="#topic+makeModelFile">makeModelFile</a>, <a href="#topic+findSwitches">findSwitches</a>, <a href="#topic+getTrees">getTrees</a>
</p>

<hr>
<h2 id='reconIgPhyML'>Do IgPhyML maximum parsimony reconstruction</h2><span id='topic+reconIgPhyML'></span>

<h3>Description</h3>

<p><code>reconIgPhyML</code> IgPhyML parsimony reconstruction function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconIgPhyML(
  file,
  modelfile,
  id,
  igphyml = "igphyml",
  mode = "switches",
  type = "recon",
  nproc = 1,
  quiet = 0,
  rm_files = FALSE,
  rm_dir = NULL,
  states = NULL,
  palette = NULL,
  resolve = 2,
  rseed = NULL,
  force_resolve = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reconIgPhyML_+3A_file">file</code></td>
<td>
<p>IgPhyML lineage file (see writeLineageFile)</p>
</td></tr>
<tr><td><code id="reconIgPhyML_+3A_modelfile">modelfile</code></td>
<td>
<p>File specifying parsimony model</p>
</td></tr>
<tr><td><code id="reconIgPhyML_+3A_id">id</code></td>
<td>
<p>id for IgPhyML run</p>
</td></tr>
<tr><td><code id="reconIgPhyML_+3A_igphyml">igphyml</code></td>
<td>
<p>location of igphyml executable</p>
</td></tr>
<tr><td><code id="reconIgPhyML_+3A_mode">mode</code></td>
<td>
<p>return trees or count switches? (switches or trees)</p>
</td></tr>
<tr><td><code id="reconIgPhyML_+3A_type">type</code></td>
<td>
<p>get observed switches or permuted switches?</p>
</td></tr>
<tr><td><code id="reconIgPhyML_+3A_nproc">nproc</code></td>
<td>
<p>cores to use for parallelization</p>
</td></tr>
<tr><td><code id="reconIgPhyML_+3A_quiet">quiet</code></td>
<td>
<p>amount of rubbish to print</p>
</td></tr>
<tr><td><code id="reconIgPhyML_+3A_rm_files">rm_files</code></td>
<td>
<p>remove temporary files?</p>
</td></tr>
<tr><td><code id="reconIgPhyML_+3A_rm_dir">rm_dir</code></td>
<td>
<p>remove temporary directory?</p>
</td></tr>
<tr><td><code id="reconIgPhyML_+3A_states">states</code></td>
<td>
<p>states in parsimony model</p>
</td></tr>
<tr><td><code id="reconIgPhyML_+3A_palette">palette</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="reconIgPhyML_+3A_resolve">resolve</code></td>
<td>
<p>level of polytomy resolution. 0=none, 
1=maximum parsimony, 2=maximum ambiguity</p>
</td></tr>
<tr><td><code id="reconIgPhyML_+3A_rseed">rseed</code></td>
<td>
<p>random number seed if desired</p>
</td></tr>
<tr><td><code id="reconIgPhyML_+3A_force_resolve">force_resolve</code></td>
<td>
<p>continue even if polytomy resolution fails?</p>
</td></tr>
<tr><td><code id="reconIgPhyML_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a tibble of switch counts or a list
of trees with internal nodes predicted by parsimony.
</p>

<hr>
<h2 id='rerootTree'>Reroot phylogenetic tree to have its germline sequence at a zero-length branch
to a node which is the direct ancestor of the tree's UCA. Assigns <code>uca</code>
to be the ancestral node to the tree's germline sequence, as <code>germid</code> as
the tree's germline sequence ID.</h2><span id='topic+rerootTree'></span>

<h3>Description</h3>

<p>Reroot phylogenetic tree to have its germline sequence at a zero-length branch
to a node which is the direct ancestor of the tree's UCA. Assigns <code>uca</code>
to be the ancestral node to the tree's germline sequence, as <code>germid</code> as
the tree's germline sequence ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rerootTree(tree, germline, min = 0.001, verbose = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rerootTree_+3A_tree">tree</code></td>
<td>
<p>An ape <code>phylo</code> object</p>
</td></tr>
<tr><td><code id="rerootTree_+3A_germline">germline</code></td>
<td>
<p>ID of the tree's predicted germline sequence</p>
</td></tr>
<tr><td><code id="rerootTree_+3A_min">min</code></td>
<td>
<p>Maximum allowed branch length from germline to root</p>
</td></tr>
<tr><td><code id="rerootTree_+3A_verbose">verbose</code></td>
<td>
<p>amount of rubbish to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>phylo</code> object rooted at the specified germline
</p>

<hr>
<h2 id='resolveLightChains'>Define subgroups within clones based on light chain rearrangements</h2><span id='topic+resolveLightChains'></span>

<h3>Description</h3>

<p><code>resolveLightChains</code> resolve light chain V and J subgroups within a clone
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolveLightChains(
  data,
  nproc = 1,
  minseq = 1,
  locus = "locus",
  heavy = "IGH",
  id = "sequence_id",
  seq = "sequence_alignment",
  clone = "clone_id",
  cell = "cell_id",
  v_call = "v_call",
  j_call = "j_call",
  junc_len = "junction_length",
  nolight = "missing"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resolveLightChains_+3A_data">data</code></td>
<td>
<p>a tibble containing heavy and light chain sequences with clone_id</p>
</td></tr>
<tr><td><code id="resolveLightChains_+3A_nproc">nproc</code></td>
<td>
<p>number of cores for parallelization</p>
</td></tr>
<tr><td><code id="resolveLightChains_+3A_minseq">minseq</code></td>
<td>
<p>minimum number of sequences per clone</p>
</td></tr>
<tr><td><code id="resolveLightChains_+3A_locus">locus</code></td>
<td>
<p>name of column containing locus values</p>
</td></tr>
<tr><td><code id="resolveLightChains_+3A_heavy">heavy</code></td>
<td>
<p>value of heavy chains in locus column. All other values will be 
treated as light chains</p>
</td></tr>
<tr><td><code id="resolveLightChains_+3A_id">id</code></td>
<td>
<p>name of the column containing sequence identifiers.</p>
</td></tr>
<tr><td><code id="resolveLightChains_+3A_seq">seq</code></td>
<td>
<p>name of the column containing observed DNA sequences. All 
sequences in this column must be multiple aligned.</p>
</td></tr>
<tr><td><code id="resolveLightChains_+3A_clone">clone</code></td>
<td>
<p>name of the column containing the identifier for the clone. All 
entries in this column should be identical.</p>
</td></tr>
<tr><td><code id="resolveLightChains_+3A_cell">cell</code></td>
<td>
<p>name of the column containing identifier for cells.</p>
</td></tr>
<tr><td><code id="resolveLightChains_+3A_v_call">v_call</code></td>
<td>
<p>name of the column containing V-segment allele assignments. All 
entries in this column should be identical to the gene level.</p>
</td></tr>
<tr><td><code id="resolveLightChains_+3A_j_call">j_call</code></td>
<td>
<p>name of the column containing J-segment allele assignments. All 
entries in this column should be identical to the gene level.</p>
</td></tr>
<tr><td><code id="resolveLightChains_+3A_junc_len">junc_len</code></td>
<td>
<p>name of the column containing the length of the junction as a 
numeric value. All entries in this column should be identical 
for any given clone.</p>
</td></tr>
<tr><td><code id="resolveLightChains_+3A_nolight">nolight</code></td>
<td>
<p>string to use to indicate a missing light chain</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1. Make temporary array containing light chain clones
2. Enumerate all possible V, J, and junction length combinations
3. Determine which combination is the most frequent
4. Assign sequences with that combination to clone t
5. Copy those sequences to return array
6. Remove all cells with that combination from temp array
7. Repeat 1-6 until temporary array zero.
If there is more than rearrangement with the same V/J
in the same cell, pick the one with the highest non-ambiguous
characters. Cells with missing light chains are grouped with their
subgroup with the closest matching heavy chain (Hamming distance)
then the largest and lowest index subgroup if ties are present.
</p>
<p>Outputs of the function are 
1. clone_subgroup which identifies the light chain VJ rearrangement that sequence belongs to within it's clone
2. clone_subgroup_id which combines the clone_id variable and the clone_subgroup variable by a &quot;_&quot;. 
3. vj_cell which combines the vj_gene and vj_alt_cell columns by a &quot;,&quot;.
</p>


<h3>Value</h3>

<p>a tibble containing the same data as inputting, but with the column clone_subgroup
added. This column contains subgroups within clones that contain distinct light chain
V and J genes, with at most one light chain per cell.
</p>

<hr>
<h2 id='resolvePolytomies'>Resolve polytomies to have the minimum number of single timepoint clades</h2><span id='topic+resolvePolytomies'></span>

<h3>Description</h3>

<p>Resolve polytomies to have the minimum number of single timepoint clades
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolvePolytomies(
  phy,
  clone,
  minlength = 0.001,
  time = "time",
  sequence = "sequence_id",
  germline = "Germline",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resolvePolytomies_+3A_phy">phy</code></td>
<td>
<p>Tree object</p>
</td></tr>
<tr><td><code id="resolvePolytomies_+3A_clone">clone</code></td>
<td>
<p>airrClone data object corresponding to <code>phy</code></p>
</td></tr>
<tr><td><code id="resolvePolytomies_+3A_minlength">minlength</code></td>
<td>
<p>Branch lengths to collapse in trees</p>
</td></tr>
<tr><td><code id="resolvePolytomies_+3A_time">time</code></td>
<td>
<p>Column name holding numeric time information</p>
</td></tr>
<tr><td><code id="resolvePolytomies_+3A_sequence">sequence</code></td>
<td>
<p>Column name holding sequence ID</p>
</td></tr>
<tr><td><code id="resolvePolytomies_+3A_germline">germline</code></td>
<td>
<p>Germline sequence name</p>
</td></tr>
<tr><td><code id="resolvePolytomies_+3A_verbose">verbose</code></td>
<td>
<p>Print lots of rubbish while running?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Iteratively identifies polytomies (clusters of &lt; minlength branches),
prunes each descendant branch, combines clades with the same timepoint
before grouping them back together. Checks to make sure that the divergence
of each tip is the same after resolution.
</p>


<h3>Value</h3>

<p>A <code>phylo</code> tree object in which polytomies are resolved to 
have the minimum number of single timepoint clades.
</p>


<h3>See Also</h3>

<p>Uses output from <a href="#topic+getTrees">getTrees</a> during <a href="#topic+correlationTest">correlationTest</a>.
</p>

<hr>
<h2 id='runCorrelationTest'>Run correlationTest, based on https://doi.org/10.1111/2041-210X.12466</h2><span id='topic+runCorrelationTest'></span>

<h3>Description</h3>

<p><code>runCorrelationTest</code> performs root-to-tip regression permutation test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runCorrelationTest(
  phy,
  clone,
  permutations,
  minlength = 0.001,
  polyresolve = TRUE,
  permutation = c("clustered", "uniform"),
  time = "time",
  sequence = "sequence_id",
  germline = "Germline",
  verbose = TRUE,
  alternative = c("greater", "two.sided")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runCorrelationTest_+3A_phy">phy</code></td>
<td>
<p>Tree object</p>
</td></tr>
<tr><td><code id="runCorrelationTest_+3A_clone">clone</code></td>
<td>
<p>airrClone data object corresponding to <code>phy</code></p>
</td></tr>
<tr><td><code id="runCorrelationTest_+3A_permutations">permutations</code></td>
<td>
<p>Number of permutations to run</p>
</td></tr>
<tr><td><code id="runCorrelationTest_+3A_minlength">minlength</code></td>
<td>
<p>Branch lengths to collapse in trees</p>
</td></tr>
<tr><td><code id="runCorrelationTest_+3A_polyresolve">polyresolve</code></td>
<td>
<p>Resolve polytomies to have a minimum number of 
single timepoint clades</p>
</td></tr>
<tr><td><code id="runCorrelationTest_+3A_permutation">permutation</code></td>
<td>
<p>Permute among single timepoint clades or uniformly
among tips</p>
</td></tr>
<tr><td><code id="runCorrelationTest_+3A_time">time</code></td>
<td>
<p>Column name holding numeric time information</p>
</td></tr>
<tr><td><code id="runCorrelationTest_+3A_sequence">sequence</code></td>
<td>
<p>Column name holding sequence ID</p>
</td></tr>
<tr><td><code id="runCorrelationTest_+3A_germline">germline</code></td>
<td>
<p>Germline sequence name</p>
</td></tr>
<tr><td><code id="runCorrelationTest_+3A_verbose">verbose</code></td>
<td>
<p>Print lots of rubbish while running?</p>
</td></tr>
<tr><td><code id="runCorrelationTest_+3A_alternative">alternative</code></td>
<td>
<p>Is alternative that the randomized correlation are greater than 
or equal to observed, or greater/less than?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="#topic+correlationTest">correlationTest</a> for details
</p>


<h3>Value</h3>

<p>A list of statistics from running the permutation test.
</p>


<h3>See Also</h3>

<p><a href="#topic+correlationTest">correlationTest</a>.
</p>

<hr>
<h2 id='scaleBranches'>Scale branch lengths to represent either mutations or mutations per site.</h2><span id='topic+scaleBranches'></span>

<h3>Description</h3>

<p><code>scaleBranches</code> Branch length scaling function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleBranches(clones, edge_type = "mutations")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaleBranches_+3A_clones">clones</code></td>
<td>
<p>a tibble of <code>airrClone</code> and <code>phylo</code> objects,
the output of <a href="#topic+getTrees">getTrees</a>.</p>
</td></tr>
<tr><td><code id="scaleBranches_+3A_edge_type">edge_type</code></td>
<td>
<p>Either <code>genetic_distance</code> (mutations per site) or 
<code>mutations</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses clones$trees[[1]]$edge_type to determine how branches are currently scaled.
</p>


<h3>Value</h3>

<p>A tibble with <code>phylo</code> objects that have had branch lengths 
rescaled as specified.
</p>


<h3>See Also</h3>

<p><a href="#topic+getTrees">getTrees</a>
</p>

<hr>
<h2 id='stitchRegions'><a href="#topic+stitchRegions">stitchRegions</a> Similar to <a href="#topic+stitchVDJ">stitchVDJ</a> but with segment IDs 
instead of nulecotides</h2><span id='topic+stitchRegions'></span>

<h3>Description</h3>

<p><a href="#topic+stitchRegions">stitchRegions</a> Similar to <a href="#topic+stitchVDJ">stitchVDJ</a> but with segment IDs 
instead of nulecotides
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stitchRegions(
  receptor,
  v_seq,
  d_seq,
  j_seq,
  np1_length = "np1_length",
  np2_length = "np1_length",
  n1_length = "n1_length",
  p3v_length = "p3v_length",
  p5d_length = "p5d_length",
  p3d_length = "p3d_length",
  n2_length = "n2_length",
  p5j_length = "p5j_length",
  np1_aa_length = "np1_aa_length",
  np2_aa_length = "np2_aa_length",
  amino_acid = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stitchRegions_+3A_receptor">receptor</code></td>
<td>
<p>row from AIRR-table containing sequence of interest</p>
</td></tr>
<tr><td><code id="stitchRegions_+3A_v_seq">v_seq</code></td>
<td>
<p>germline V segment sequence from <a href="#topic+getGermline">getGermline</a></p>
</td></tr>
<tr><td><code id="stitchRegions_+3A_d_seq">d_seq</code></td>
<td>
<p>germline D segment sequence from <a href="#topic+getGermline">getGermline</a></p>
</td></tr>
<tr><td><code id="stitchRegions_+3A_j_seq">j_seq</code></td>
<td>
<p>germline J segment sequence from <a href="#topic+getGermline">getGermline</a></p>
</td></tr>
<tr><td><code id="stitchRegions_+3A_np1_length">np1_length</code></td>
<td>
<p>Column name in receptor specifying np1 segment length 
(e.g. np1_length)</p>
</td></tr>
<tr><td><code id="stitchRegions_+3A_np2_length">np2_length</code></td>
<td>
<p>Column name in receptor specifying np2 segment length 
(e.g. np1_length)</p>
</td></tr>
<tr><td><code id="stitchRegions_+3A_n1_length">n1_length</code></td>
<td>
<p>Column name in receptor specifying n1 segment length 
(experimental)</p>
</td></tr>
<tr><td><code id="stitchRegions_+3A_p3v_length">p3v_length</code></td>
<td>
<p>Column name in receptor specifying p3v segment length 
(experimental)</p>
</td></tr>
<tr><td><code id="stitchRegions_+3A_p5d_length">p5d_length</code></td>
<td>
<p>Column name in receptor specifying p5d segment length 
(experimental)</p>
</td></tr>
<tr><td><code id="stitchRegions_+3A_p3d_length">p3d_length</code></td>
<td>
<p>Column name in receptor specifying p3d segment length 
(experimental)</p>
</td></tr>
<tr><td><code id="stitchRegions_+3A_n2_length">n2_length</code></td>
<td>
<p>Column name in receptor specifying n2 segment length 
(experimental)</p>
</td></tr>
<tr><td><code id="stitchRegions_+3A_p5j_length">p5j_length</code></td>
<td>
<p>Column name in receptor specifying p5j segment length 
(experimental)</p>
</td></tr>
<tr><td><code id="stitchRegions_+3A_np1_aa_length">np1_aa_length</code></td>
<td>
<p>Column name in receptor specifying np1 segment length 
in AA (if amino_acid=TRUE, e.g. np1_length)</p>
</td></tr>
<tr><td><code id="stitchRegions_+3A_np2_aa_length">np2_aa_length</code></td>
<td>
<p>Column name in receptor specifying np2 segment length 
in AA (if amino_acid=TRUE, e.g. np1_length)</p>
</td></tr>
<tr><td><code id="stitchRegions_+3A_amino_acid">amino_acid</code></td>
<td>
<p>Perform reconstruction on amino acid sequence (experimental)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Full length germline VDJ sequence with segment IDs instead of 
nucleotides.
</p>


<h3>See Also</h3>

<p><a href="#topic+stitchVDJ">stitchVDJ</a>
</p>

<hr>
<h2 id='stitchVDJ'><a href="#topic+stitchVDJ">stitchVDJ</a> combines germline gene segments to a single string</h2><span id='topic+stitchVDJ'></span>

<h3>Description</h3>

<p><a href="#topic+stitchVDJ">stitchVDJ</a> combines germline gene segments to a single string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stitchVDJ(
  receptor,
  v_seq,
  d_seq,
  j_seq,
  np1_length = "np1_length",
  np2_length = "np2_length",
  np1_aa_length = "np1_aa_length",
  np2_aa_length = "np2_aa_length",
  amino_acid = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stitchVDJ_+3A_receptor">receptor</code></td>
<td>
<p>row from AIRR-table containing sequence of interest</p>
</td></tr>
<tr><td><code id="stitchVDJ_+3A_v_seq">v_seq</code></td>
<td>
<p>germline V segment sequence from <a href="#topic+getGermline">getGermline</a></p>
</td></tr>
<tr><td><code id="stitchVDJ_+3A_d_seq">d_seq</code></td>
<td>
<p>germline D segment sequence from <a href="#topic+getGermline">getGermline</a></p>
</td></tr>
<tr><td><code id="stitchVDJ_+3A_j_seq">j_seq</code></td>
<td>
<p>germline J segment sequence from <a href="#topic+getGermline">getGermline</a></p>
</td></tr>
<tr><td><code id="stitchVDJ_+3A_np1_length">np1_length</code></td>
<td>
<p>Column name in receptor specifying np1 segment length 
(e.g. np1_length)</p>
</td></tr>
<tr><td><code id="stitchVDJ_+3A_np2_length">np2_length</code></td>
<td>
<p>Column name in receptor specifying np2 segment length 
(e.g. np1_length)</p>
</td></tr>
<tr><td><code id="stitchVDJ_+3A_np1_aa_length">np1_aa_length</code></td>
<td>
<p>Column name in receptor specifying np1 segment length 
in AA (if amino_acid=TRUE, e.g. np1_length)</p>
</td></tr>
<tr><td><code id="stitchVDJ_+3A_np2_aa_length">np2_aa_length</code></td>
<td>
<p>Column name in receptor specifying np2 segment length 
in AA (if amino_acid=TRUE, e.g. np1_length)</p>
</td></tr>
<tr><td><code id="stitchVDJ_+3A_amino_acid">amino_acid</code></td>
<td>
<p>Perform reconstruction on amino acid sequence (experimental)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Full length germline VDJ sequence aligned with aligned with the 
sequence in the <code>seq</code> column of <code>receptor</code>.
</p>

<hr>
<h2 id='testPS'>Performs PS (parsimony score) test on switch data</h2><span id='topic+testPS'></span>

<h3>Description</h3>

<p><code>testPS</code> performs a PS test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testPS(
  switches,
  bylineage = FALSE,
  pseudocount = 0,
  alternative = c("less", "two.sided", "greater")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testPS_+3A_switches">switches</code></td>
<td>
<p>Data frame from findSwitches</p>
</td></tr>
<tr><td><code id="testPS_+3A_bylineage">bylineage</code></td>
<td>
<p>Perform test for each lineage individually? (FALSE)</p>
</td></tr>
<tr><td><code id="testPS_+3A_pseudocount">pseudocount</code></td>
<td>
<p>Pseudocount for P value calculations</p>
</td></tr>
<tr><td><code id="testPS_+3A_alternative">alternative</code></td>
<td>
<p>Perform one-sided (<code>greater</code> or <code>less</code>)
or <code>two.sided</code> test</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Output data table columns:
RECON = PS for observed data
PERMUTE = PS for permuted data
DELTA = RECON - PERMUTE
PLT = p value for DELTA &lt; 0
PGT = p value for DELTA &lt; 0
</p>

<ul>
<li>  <p><code>RECON</code>: PS for observed data.
</p>
</li>
<li>  <p><code>PERMUTE</code>: PS for permuted data.
</p>
</li>
<li>  <p><code>DELTA</code>:  RECON - PERMUTE.
</p>
</li>
<li>  <p><code>PLT</code>: p value that DELTA &lt; 0
</p>
</li>
<li>  <p><code>PGT</code>: p value that DELTA &gt; 0
</p>
</li>
<li>  <p><code>STAT</code>: Statistic used (PS).
</p>
</li>
<li>  <p><code>REP</code>: Bootstrap repetition.
</p>
</li>
<li>  <p><code>REPS</code>: Total number of ootstrap repetition.
</p>
</li></ul>



<h3>Value</h3>

<p>A list containing a <code>tibble</code> with mean PS statistics, and another 
with PS statistics per repetition.
</p>


<h3>See Also</h3>

<p>Uses output from <a href="#topic+findSwitches">findSwitches</a>. Related to <a href="#topic+testSP">testSP</a>
and <a href="#topic+testSC">testSC</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
igphyml &lt;- "~/apps/igphyml/src/igphyml"
data(ExampleAirr)
ExampleAirr$sample_id &lt;- sample(ExampleAirr$sample_id)
clones &lt;- formatClones(ExampleAirr, trait="sample_id")
btrees &lt;- findSwitches(clones[1:2], bootstraps=10, nproc=1,
   igphyml=igphyml, trait="sample_id")
testPS(btrees$switches)

## End(Not run)
</code></pre>

<hr>
<h2 id='testSC'>Performs SC (switch count) test on switch data</h2><span id='topic+testSC'></span>

<h3>Description</h3>

<p><code>testSC</code> performs an SC test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testSC(
  switches,
  dropzeroes = TRUE,
  bylineage = FALSE,
  pseudocount = 0,
  from = NULL,
  to = NULL,
  permuteAll = FALSE,
  alternative = c("two.sided", "greater", "less")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testSC_+3A_switches">switches</code></td>
<td>
<p>Data frame from findSwitches</p>
</td></tr>
<tr><td><code id="testSC_+3A_dropzeroes">dropzeroes</code></td>
<td>
<p>Drop switches with zero counts?</p>
</td></tr>
<tr><td><code id="testSC_+3A_bylineage">bylineage</code></td>
<td>
<p>Perform test for each lineage individually?</p>
</td></tr>
<tr><td><code id="testSC_+3A_pseudocount">pseudocount</code></td>
<td>
<p>Pseudocount for P value calculations</p>
</td></tr>
<tr><td><code id="testSC_+3A_from">from</code></td>
<td>
<p>Include only switches from this state?</p>
</td></tr>
<tr><td><code id="testSC_+3A_to">to</code></td>
<td>
<p>Include only switches to this state?</p>
</td></tr>
<tr><td><code id="testSC_+3A_permuteall">permuteAll</code></td>
<td>
<p>Permute among trees?</p>
</td></tr>
<tr><td><code id="testSC_+3A_alternative">alternative</code></td>
<td>
<p>Perform one-sided (<code>greater</code> or <code>less</code>)
or <code>two.sided</code> test</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Output data table columns:
RECON = SC for observed data
PERMUTE = SC for permuted data
DELTA = RECON - PERMUTE
PLT = p value for DELTA &lt; 0
PGT = p value for DELTA &lt; 0
</p>

<ul>
<li>  <p><code>FROM</code>: State going from.
</p>
</li>
<li>  <p><code>TO</code>: State going to.
</p>
</li>
<li>  <p><code>RECON</code>: SC for observed data.
</p>
</li>
<li>  <p><code>PERMUTE</code>: SC for permuted data.
</p>
</li>
<li>  <p><code>DELTA</code>:  RECON - PERMUTE.
</p>
</li>
<li>  <p><code>PLT</code>: p value that DELTA &lt; 0
</p>
</li>
<li>  <p><code>PGT</code>: p value that DELTA &gt; 0
</p>
</li>
<li>  <p><code>STAT</code>: Statistic used (SC).
</p>
</li>
<li>  <p><code>REP</code>: Bootstrap repetition.
</p>
</li>
<li>  <p><code>REPS</code>: Total number of ootstrap repetition.
</p>
</li></ul>



<h3>Value</h3>

<p>A list containing a <code>tibble</code> with mean SC statistics, and another 
with SC statistics per repetition.
</p>


<h3>See Also</h3>

<p>Uses output from <a href="#topic+findSwitches">findSwitches</a>. Related to <a href="#topic+testPS">testPS</a>
and <a href="#topic+testSP">testSP</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
igphyml &lt;- "~/apps/igphyml/src/igphyml"
data(ExampleAirr)
ExampleAirr$sample_id = sample(ExampleAirr$sample_id)
clones = formatClones(ExampleAirr, trait="sample_id")
btrees = findSwitches(clones[1:2], bootstraps=100, nproc=1,
   igphyml=igphyml, trait="sample_id", id="temp", dir="temp")
testSC(btrees$switches)

## End(Not run)
</code></pre>

<hr>
<h2 id='testSP'>Performs SP (switch proportion) test on switch data</h2><span id='topic+testSP'></span>

<h3>Description</h3>

<p><code>testSP</code> performs an SP test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testSP(
  switches,
  permuteAll = FALSE,
  from = NULL,
  to = NULL,
  dropzeroes = TRUE,
  bylineage = FALSE,
  pseudocount = 0,
  alternative = c("greater", "two.sided", "less"),
  tip_switch = 20,
  exclude = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testSP_+3A_switches">switches</code></td>
<td>
<p>Data frame from findSwitches</p>
</td></tr>
<tr><td><code id="testSP_+3A_permuteall">permuteAll</code></td>
<td>
<p>Permute among trees?</p>
</td></tr>
<tr><td><code id="testSP_+3A_from">from</code></td>
<td>
<p>Include only switches from this state?</p>
</td></tr>
<tr><td><code id="testSP_+3A_to">to</code></td>
<td>
<p>Include only switches to this state?</p>
</td></tr>
<tr><td><code id="testSP_+3A_dropzeroes">dropzeroes</code></td>
<td>
<p>Drop switches with zero counts?</p>
</td></tr>
<tr><td><code id="testSP_+3A_bylineage">bylineage</code></td>
<td>
<p>Perform test for each lineage individually?</p>
</td></tr>
<tr><td><code id="testSP_+3A_pseudocount">pseudocount</code></td>
<td>
<p>Pseudocount for P value calculations</p>
</td></tr>
<tr><td><code id="testSP_+3A_alternative">alternative</code></td>
<td>
<p>Perform one-sided (<code>greater</code> or <code>less</code>)
or <code>two.sided</code> test</p>
</td></tr>
<tr><td><code id="testSP_+3A_tip_switch">tip_switch</code></td>
<td>
<p>maximum tip/switch ratio</p>
</td></tr>
<tr><td><code id="testSP_+3A_exclude">exclude</code></td>
<td>
<p>exclude clones with tip/switch ratio &gt; <code>tip_switch</code>?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Output data table columns:
RECON = SP for observed data
PERMUTE = SP for permuted data
DELTA = RECON - PERMUTE
PLT = p value for DELTA &lt; 0
PGT = p value for DELTA &lt; 0
</p>

<ul>
<li>  <p><code>FROM</code>: State going from.
</p>
</li>
<li>  <p><code>TO</code>: State going to.
</p>
</li>
<li>  <p><code>RECON</code>: SP for observed data.
</p>
</li>
<li>  <p><code>PERMUTE</code>: SP for permuted data.
</p>
</li>
<li>  <p><code>DELTA</code>:  RECON - PERMUTE.
</p>
</li>
<li>  <p><code>PLT</code>: p value that DELTA &lt; 0
</p>
</li>
<li>  <p><code>PGT</code>: p value that DELTA &gt; 0
</p>
</li>
<li>  <p><code>STAT</code>: Statistic used (SP).
</p>
</li>
<li>  <p><code>REP</code>: Bootstrap repetition.
</p>
</li>
<li>  <p><code>REPS</code>: Total number of ootstrap repetition.
</p>
</li></ul>



<h3>Value</h3>

<p>A list containing a <code>tibble</code> with mean SP statistics, and another 
with SP statistics per repetition.
</p>


<h3>See Also</h3>

<p>Uses output from <a href="#topic+findSwitches">findSwitches</a>. Related to <a href="#topic+testPS">testPS</a>
and <a href="#topic+testSC">testSC</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
igphyml &lt;- "~/apps/igphyml/src/igphyml"
data(ExampleAirr)
ExampleAirr$sample_id = sample(ExampleAirr$sample_id)
clones = formatClones(ExampleAirr, trait="sample_id")
btrees = findSwitches(clones[1:2], bootstraps=10, nproc=1,
   igphyml=igphyml, trait="sample_id")
testSP(btrees$switches)

## End(Not run)
</code></pre>

<hr>
<h2 id='TimeTrees'>Example Ig lineage trees sampled over time.</h2><span id='topic+TimeTrees'></span>

<h3>Description</h3>

<p>Same as ExampleClones but with timepoint as a trait value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TimeTrees
</code></pre>


<h3>Format</h3>

<p>A tibble of airrClone and phylo objects output by getTrees.
</p>

<ul>
<li>  <p><code>clone_id</code>:   Clonal cluster
</p>
</li>
<li>  <p><code>data</code>:       List of airrClone objects
</p>
</li>
<li>  <p><code>seqs</code>:       Number of sequences
</p>
</li>
<li>  <p><code>trees</code>:      List of phylo objects
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+TimeTrees">TimeTrees</a>
</p>

<hr>
<h2 id='treesToPDF'>Simple function for plotting a lot of trees into a pdf</h2><span id='topic+treesToPDF'></span>

<h3>Description</h3>

<p><code>treesToPDF</code> exports trees to a pdf in an orderly fashion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treesToPDF(plots, file, nrow = 2, ncol = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treesToPDF_+3A_plots">plots</code></td>
<td>
<p>list of tree plots (from plotTrees)</p>
</td></tr>
<tr><td><code id="treesToPDF_+3A_file">file</code></td>
<td>
<p>output file name</p>
</td></tr>
<tr><td><code id="treesToPDF_+3A_nrow">nrow</code></td>
<td>
<p>number of rows per page</p>
</td></tr>
<tr><td><code id="treesToPDF_+3A_ncol">ncol</code></td>
<td>
<p>number of columns per page</p>
</td></tr>
<tr><td><code id="treesToPDF_+3A_...">...</code></td>
<td>
<p>optional arguments passed to grDevices::pdf</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a PDF of tree plots
</p>


<h3>See Also</h3>

<p><a href="#topic+plotTrees">plotTrees</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(ExampleClones)
trees &lt;- getTrees(ExampleClones[10,])
plots &lt;- plotTrees(trees)
treesToPDF(plots,"test.pdf",width=5,height=6)

## End(Not run)
</code></pre>

<hr>
<h2 id='writeLineageFile'>Write lineage file for IgPhyML use</h2><span id='topic+writeLineageFile'></span>

<h3>Description</h3>

<p>Write lineage file for IgPhyML use
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeLineageFile(
  data,
  trees = NULL,
  dir = ".",
  id = "N",
  rep = NULL,
  trait = NULL,
  empty = TRUE,
  partition = "single",
  heavy = "IGH"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeLineageFile_+3A_data">data</code></td>
<td>
<p>list of <code>airrClone</code> objects</p>
</td></tr>
<tr><td><code id="writeLineageFile_+3A_trees">trees</code></td>
<td>
<p>list of <code>phylo</code> objects corresponding to <code>data</code></p>
</td></tr>
<tr><td><code id="writeLineageFile_+3A_dir">dir</code></td>
<td>
<p>directory to write file</p>
</td></tr>
<tr><td><code id="writeLineageFile_+3A_id">id</code></td>
<td>
<p>id used for IgPhyML run</p>
</td></tr>
<tr><td><code id="writeLineageFile_+3A_rep">rep</code></td>
<td>
<p>bootstrap replicate</p>
</td></tr>
<tr><td><code id="writeLineageFile_+3A_trait">trait</code></td>
<td>
<p>string appended to sequence id in fasta files</p>
</td></tr>
<tr><td><code id="writeLineageFile_+3A_empty">empty</code></td>
<td>
<p>output uninformative sequences?</p>
</td></tr>
<tr><td><code id="writeLineageFile_+3A_partition">partition</code></td>
<td>
<p>how to partition omegas</p>
</td></tr>
<tr><td><code id="writeLineageFile_+3A_heavy">heavy</code></td>
<td>
<p>name of heavy chain locus</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Name of created lineage file.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
