<!DOCTYPE html><html><head><title>Help for package spmodel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spmodel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AIC.spmodel'><p>Compute AIC and AICc of fitted model objects</p></a></li>
<li><a href='#anova.spmodel'><p>Compute analysis of variance and likelihood ratio tests of fitted model objects</p></a></li>
<li><a href='#augment.spmodel'><p>Augment data with information from fitted model objects</p></a></li>
<li><a href='#caribou'><p>A caribou forage experiment</p></a></li>
<li><a href='#coef.spmodel'><p>Extract fitted model coefficients</p></a></li>
<li><a href='#confint.spmodel'><p>Confidence intervals for fitted model parameters</p></a></li>
<li><a href='#cooks.distance.spmodel'><p>Compute Cook's distance</p></a></li>
<li><a href='#covmatrix'><p>Create a covariance matrix</p></a></li>
<li><a href='#deviance.spmodel'><p>Fitted model deviance</p></a></li>
<li><a href='#dispersion_initial'><p>Create a dispersion parameter initial object</p></a></li>
<li><a href='#dispersion_params'><p>Create a dispersion parameter object</p></a></li>
<li><a href='#esv'><p>Compute the empirical semivariogram</p></a></li>
<li><a href='#fitted.spmodel'><p>Extract model fitted values</p></a></li>
<li><a href='#formula.spmodel'><p>Model formulae</p></a></li>
<li><a href='#glance.spmodel'><p>Glance at a fitted model object</p></a></li>
<li><a href='#glances'><p>Glance at many fitted model objects</p></a></li>
<li><a href='#hatvalues.spmodel'><p>Compute leverage (hat) values</p></a></li>
<li><a href='#influence.spmodel'><p>Regression diagnostics</p></a></li>
<li><a href='#labels.spmodel'><p>Find labels from object</p></a></li>
<li><a href='#logLik.spmodel'><p>Extract log-likelihood</p></a></li>
<li><a href='#loocv'><p>Perform leave-one-out cross validation</p></a></li>
<li><a href='#model.frame.spmodel'><p>Extract the model frame from a fitted model object</p></a></li>
<li><a href='#model.matrix.spmodel'><p>Extract the model matrix from a fitted model object</p></a></li>
<li><a href='#moose'><p>Moose counts and presence in Alaska, USA</p></a></li>
<li><a href='#moose_preds'><p>Locations at which to predict moose counts and presence in Alaska, USA</p></a></li>
<li><a href='#moss'><p>Heavy metals in mosses near a mining road in Alaska, USA</p></a></li>
<li><a href='#plot.spmodel'><p>Plot fitted model diagnostics</p></a></li>
<li><a href='#predict.spmodel'><p>Model predictions (Kriging)</p></a></li>
<li><a href='#print.spmodel'><p>Print values</p></a></li>
<li><a href='#pseudoR2'><p>Compute a pseudo r-squared</p></a></li>
<li><a href='#randcov_initial'><p>Create a random effects covariance parameter initial object</p></a></li>
<li><a href='#randcov_params'><p>Create a random effects covariance parameter object</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#residuals.spmodel'><p>Extract fitted model residuals</p></a></li>
<li><a href='#seal'><p>Estimated harbor-seal trends from abundance data in southeast Alaska, USA</p></a></li>
<li><a href='#spautor'><p>Fit spatial autoregressive models</p></a></li>
<li><a href='#spautorRF'><p>Fit random forest spatial residual models</p></a></li>
<li><a href='#spcov_initial'><p>Create a spatial covariance parameter initial object</p></a></li>
<li><a href='#spcov_params'><p>Create a spatial covariance parameter object</p></a></li>
<li><a href='#spgautor'><p>Fit spatial generalized autoregressive models</p></a></li>
<li><a href='#spglm'><p>Fit spatial generalized linear models</p></a></li>
<li><a href='#splm'><p>Fit spatial linear models</p></a></li>
<li><a href='#splmRF'><p>Fit random forest spatial residual models</p></a></li>
<li><a href='#spmodel-package'><p>spmodel: Spatial Statistical Modeling and Prediction</p></a></li>
<li><a href='#sprbeta'><p>Simulate a spatial beta random variable</p></a></li>
<li><a href='#sprbinom'><p>Simulate a spatial binomial random variable</p></a></li>
<li><a href='#sprgamma'><p>Simulate a spatial gamma random variable</p></a></li>
<li><a href='#sprinvgauss'><p>Simulate a spatial inverse gaussian random variable</p></a></li>
<li><a href='#sprnbinom'><p>Simulate a spatial negative binomial random variable</p></a></li>
<li><a href='#sprnorm'><p>Simulate a spatial normal (Gaussian) random variable</p></a></li>
<li><a href='#sprpois'><p>Simulate a spatial Poisson random variable</p></a></li>
<li><a href='#sulfate'><p>Sulfate atmospheric deposition in the conterminous USA</p></a></li>
<li><a href='#sulfate_preds'><p>Locations at which to predict sulfate atmospheric deposition in the conterminous USA</p></a></li>
<li><a href='#summary.spmodel'><p>Summarize a fitted model object</p></a></li>
<li><a href='#tidy.spmodel'><p>Tidy a fitted model object</p></a></li>
<li><a href='#varcomp'><p>Variability component comparison</p></a></li>
<li><a href='#vcov.spmodel'><p>Calculate variance-covariance matrix for a fitted model object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Spatial Statistical Modeling and Prediction</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit, summarize, and predict for a variety of spatial statistical models applied to point-referenced and areal (lattice) data. Parameters are estimated using various methods. Additional modeling features include anisotropy, non-spatial random effects, partition factors, big data approaches, and more. Model-fit statistics are used to summarize, visualize, and compare models. Predictions at unobserved locations are readily obtainable. For additional details, see Dumelle et al. (2023) &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0282524">doi:10.1371/journal.pone.0282524</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, generics, Matrix, sf, stats, tibble, parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat (&ge; 3.0.0), ggplot2, ranger,
statmod</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://usepa.github.io/spmodel/">https://usepa.github.io/spmodel/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/USEPA/spmodel/issues">https://github.com/USEPA/spmodel/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-08 21:17:56 UTC; MDUMELLE</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Dumelle <a href="https://orcid.org/0000-0002-3393-5529"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Matt Higham [aut],
  Jay M. Ver Hoef [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Dumelle &lt;Dumelle.Michael@epa.gov&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-09 10:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AIC.spmodel'>Compute AIC and AICc of fitted model objects</h2><span id='topic+AIC.spmodel'></span><span id='topic+AIC.splm'></span><span id='topic+AIC.spautor'></span><span id='topic+AIC.spglm'></span><span id='topic+AIC.spgautor'></span><span id='topic+AICc'></span><span id='topic+AICc.splm'></span><span id='topic+AICc.spautor'></span><span id='topic+AICc.spglm'></span><span id='topic+AICc.spgautor'></span>

<h3>Description</h3>

<p>Compute AIC and AICc for one or
several fitted model objects for which a log-likelihood
value can be obtained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splm'
AIC(object, ..., k = 2)

## S3 method for class 'spautor'
AIC(object, ..., k = 2)

## S3 method for class 'spglm'
AIC(object, ..., k = 2)

## S3 method for class 'spgautor'
AIC(object, ..., k = 2)

AICc(object, ..., k = 2)

## S3 method for class 'splm'
AICc(object, ..., k = 2)

## S3 method for class 'spautor'
AICc(object, ..., k = 2)

## S3 method for class 'spglm'
AICc(object, ..., k = 2)

## S3 method for class 'spgautor'
AICc(object, ..., k = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC.spmodel_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>
where <code>estmethod</code> is <code>"ml"</code> or <code>"reml"</code>.</p>
</td></tr>
<tr><td><code id="AIC.spmodel_+3A_...">...</code></td>
<td>
<p>Optionally more fitted model objects.</p>
</td></tr>
<tr><td><code id="AIC.spmodel_+3A_k">k</code></td>
<td>
<p>The penalty parameter, taken to be 2. Currently not allowed to differ
from 2 (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When comparing models fit by maximum or restricted maximum
likelihood, the smaller the AIC or AICc, the better the fit. The AICc contains
a correction to AIC for small sample sizes. The theory of
AIC and AICc requires that the log-likelihood has been maximized, and hence,
no AIC or AICc methods exist for models where <code>estmethod</code> is not
<code>"ml"</code> or <code>"reml"</code>. Additionally, AIC and AICc comparisons between <code>"ml"</code>
and <code>"reml"</code> models are meaningless &ndash; comparisons should only be made
within a set of models estimated using <code>"ml"</code> or a set of models estimated
using <code>"reml"</code>. AIC and AICc comparisons for <code>"reml"</code> must
use the same fixed effects. To vary the covariance parameters and
fixed effects simultaneously, use <code>"ml"</code>.
</p>
<p>Hoeting et al. (2006) defines that spatial AIC as
<code class="reqn">-2loglik + 2(estparams)</code> and the spatial AICc as
<code class="reqn">-2loglik + 2n(estparams) / (n - estparams - 1)</code>, where <code class="reqn">n</code> is the sample size
and <code class="reqn">estparams</code> is the number of estimated parameters. For <code>"ml"</code>, <code class="reqn">estparams</code> is
the number of estimated covariance parameters plus the number of estimated
fixed effects. For <code>"reml"</code>, <code class="reqn">estparams</code> is the number of estimated covariance
parameters.
</p>


<h3>Value</h3>

<p>If just one object is provided, a numeric value with the corresponding
AIC or AICc.
</p>
<p>If multiple objects are provided, a <code>data.frame</code> with rows corresponding
to the objects and columns representing the number of parameters estimated
(<code>df</code>) and the AIC or AICc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
AIC(spmod)
AICc(spmod)
</code></pre>

<hr>
<h2 id='anova.spmodel'>Compute analysis of variance and likelihood ratio tests of fitted model objects</h2><span id='topic+anova.spmodel'></span><span id='topic+anova.splm'></span><span id='topic+anova.spautor'></span><span id='topic+anova.spglm'></span><span id='topic+anova.spgautor'></span><span id='topic+tidy.anova.splm'></span><span id='topic+tidy.anova.spautor'></span><span id='topic+tidy.anova.spglm'></span><span id='topic+tidy.anova.spgautor'></span>

<h3>Description</h3>

<p>Compute analysis of variance tables for a fitted model object or
a likelihood ratio test for two fitted model objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splm'
anova(object, ..., test = TRUE, Terms, L)

## S3 method for class 'spautor'
anova(object, ..., test = TRUE, Terms, L)

## S3 method for class 'spglm'
anova(object, ..., test = TRUE, Terms, L)

## S3 method for class 'spgautor'
anova(object, ..., test = TRUE, Terms, L)

## S3 method for class 'anova.splm'
tidy(x, ...)

## S3 method for class 'anova.spautor'
tidy(x, ...)

## S3 method for class 'anova.spglm'
tidy(x, ...)

## S3 method for class 'anova.spgautor'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.spmodel_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>.</p>
</td></tr>
<tr><td><code id="anova.spmodel_+3A_...">...</code></td>
<td>
<p>An additional fitted model object.</p>
</td></tr>
<tr><td><code id="anova.spmodel_+3A_test">test</code></td>
<td>
<p>A logical value indicating whether p-values from asymptotic Chi-squared
hypothesis tests should be returned. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="anova.spmodel_+3A_terms">Terms</code></td>
<td>
<p>An optional character or integer vector that specifies terms in the model
used to jointly compute test statistics and p-values (if <code>test = TRUE</code>)
against a null hypothesis of zero. <code>Terms</code> is only used when a single fitted model
object is passed to the function. If <code>Terms</code> is a character vector, it
should contain the names of the fixed effect terms. If <code>Terms</code> is an integer
vector, it should correspond to the order (starting at one) of the names
of the fixed effect terms. The easiest way to obtain the names of
all possible terms is to run <code>tidy(anova(object))$effects</code> (the
integer representation matches the positions of this vector).</p>
</td></tr>
<tr><td><code id="anova.spmodel_+3A_l">L</code></td>
<td>
<p>An optional numeric matrix or list specifying linear combinations
of the coefficients in the model used to compute test statistics
and p-values (if <code>test = TRUE</code>) for coefficient constraints corresponding to a null
hypothesis of zero. <code>L</code> is only used when a single fitted model
object is passed to the function. If <code>L</code> is a numeric matrix, its rows
indicate coefficient constraints and its columns
represent coefficients. Then a single hypothesis test is conducted
against a null hypothesis of zero.
If <code>L</code> is a list, each list element is a numeric matrix specified as above.
Then separate hypothesis tests are conducted. The easiest
way to obtain all possible coefficients is to run <code>tidy(object)$term</code>.</p>
</td></tr>
<tr><td><code id="anova.spmodel_+3A_x">x</code></td>
<td>
<p>An object from <code>anova(object)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When one fitted model object is present, <code>anova()</code>
performs a general linear hypothesis test corresponding to some hypothesis
specified by a matrix of constraints. If <code>Terms</code> and <code>L</code> are not specified,
each model term is tested against zero (which correspond to type III or marginal
hypothesis tests from classical ANOVA). If <code>Terms</code> is specified and <code>L</code>
is not specified, all terms are tested jointly against zero. When <code>L</code> is
specified, the linear combinations of terms specified by <code>L</code> are jointly
tested against zero.
</p>
<p>When two fitted model objects are present, one must be a &quot;reduced&quot;
model nested in a &quot;full&quot; model. Then <code>anova()</code> performs a likelihood ratio test.
</p>


<h3>Value</h3>

<p>When one fitted model object is present, <code>anova()</code>
returns a data frame with degrees of
freedom (<code>Df</code>), test statistics (<code>Chi2</code>), and p-values
(<code>Pr(&gt;Chi2)</code> if <code>test = TRUE</code>) corresponding
to asymptotic Chi-squared hypothesis tests for each model term.
</p>
<p>When two fitted model objects are present, <code>anova()</code> returns a data frame
with the difference in degrees of freedom between the full and reduced model (<code>Df</code>), a test
statistic (<code>Chi2</code>), and a p-value corresponding to the likelihood ratio test
(<code>Pr(&gt;Chi2)</code> if <code>test = TRUE</code>).
</p>
<p>Whether one or two fitted model objects are provided,
<code>tidy()</code> can be used
to obtain tidy tibbles of the <code>anova(object)</code> output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># one-model anova
spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
anova(spmod)
tidy(anova(spmod))
# see terms
tidy(anova(spmod))$effects
tidy(anova(spmod, Terms = c("water", "tarp")))
# same as
tidy(anova(spmod, Terms = c(2, 3)))
# likelihood ratio test
lmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "none"
)
tidy(anova(spmod, lmod))
</code></pre>

<hr>
<h2 id='augment.spmodel'>Augment data with information from fitted model objects</h2><span id='topic+augment.spmodel'></span><span id='topic+augment.splm'></span><span id='topic+augment.spautor'></span><span id='topic+augment.spglm'></span><span id='topic+augment.spgautor'></span>

<h3>Description</h3>

<p>Augment accepts a fitted model object and a data set and adds
information about each observation in the data set. New columns always
begin with a <code>.</code> prefix to avoid overwriting columns in the original
data set.
</p>
<p>Augment behaves differently depending on whether the original data or new data
requires augmenting. Typically, when augmenting the original data, only the fitted
model object is specified, and when augmenting new data, the fitted model object
and <code>newdata</code> is specified. When augmenting the original data, diagnostic
statistics are augmented to each row in the data set. When augmenting new data,
predictions and optional intervals or standard errors are augmented to each
row in the new data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splm'
augment(
  x,
  drop = TRUE,
  newdata = NULL,
  se_fit = FALSE,
  interval = c("none", "confidence", "prediction"),
  level = 0.95,
  local,
  ...
)

## S3 method for class 'spautor'
augment(
  x,
  drop = TRUE,
  newdata = NULL,
  se_fit = FALSE,
  interval = c("none", "confidence", "prediction"),
  level = 0.95,
  local,
  ...
)

## S3 method for class 'spglm'
augment(
  x,
  drop = TRUE,
  newdata = NULL,
  type = c("link", "response"),
  se_fit = FALSE,
  interval = c("none", "confidence", "prediction"),
  newdata_size,
  level = 0.95,
  local = local,
  var_correct = TRUE,
  ...
)

## S3 method for class 'spgautor'
augment(
  x,
  drop = TRUE,
  newdata = NULL,
  type = c("link", "response"),
  se_fit = FALSE,
  interval = c("none", "confidence", "prediction"),
  newdata_size,
  level = 0.95,
  local,
  var_correct = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.spmodel_+3A_x">x</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+splm">splm()</a></code> or <code><a href="#topic+spautor">spautor()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.spmodel_+3A_drop">drop</code></td>
<td>
<p>A logical indicating whether to drop extra variables in the
fitted model object <code>x</code> when augmenting. The default for <code>drop</code> is <code>TRUE</code>.
<code>drop</code> is ignored if augmenting <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="augment.spmodel_+3A_newdata">newdata</code></td>
<td>
<p>A data frame or tibble containing observations requiring prediction.
All of the original explanatory variables used to create the fitted model object <code>x</code>
must be present in <code>newdata</code>. Defaults to <code>NULL</code>, which indicates
that nothing has been passed to <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="augment.spmodel_+3A_se_fit">se_fit</code></td>
<td>
<p>Logical indicating whether or not a <code>.se.fit</code> column should
be added to augmented output. Passed to <code>predict()</code> and
defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="augment.spmodel_+3A_interval">interval</code></td>
<td>
<p>Character indicating the type of confidence interval columns to
add to the augmented <code>newdata</code> output. Passed to <code>predict()</code> and defaults
to <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="augment.spmodel_+3A_level">level</code></td>
<td>
<p>Tolerance/confidence level. The default is <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="augment.spmodel_+3A_local">local</code></td>
<td>
<p>A list or logical. If a list, specific list elements described
in <code><a href="#topic+predict.spmodel">predict.spmodel()</a></code> control the big data approximation behavior.
If a logical, <code>TRUE</code> chooses default list elements for the list version
of <code>local</code> as specified in <code><a href="#topic+predict.spmodel">predict.spmodel()</a></code>. Defaults to <code>FALSE</code>,
which performs exact computations.</p>
</td></tr>
<tr><td><code id="augment.spmodel_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
<tr><td><code id="augment.spmodel_+3A_type">type</code></td>
<td>
<p>The scale (<code>response</code> or <code>link</code>) of predictions obtained
using <code>spglm()</code> or <code>spgautor</code> objects.</p>
</td></tr>
<tr><td><code id="augment.spmodel_+3A_newdata_size">newdata_size</code></td>
<td>
<p>The <code>size</code> value for each observation in <code>newdata</code>
used when predicting for the binomial family.</p>
</td></tr>
<tr><td><code id="augment.spmodel_+3A_var_correct">var_correct</code></td>
<td>
<p>A logical indicating whether to return the corrected prediction
variances when predicting via models fit using <code>spglm()</code> or <code>spgautor()</code>. The default is
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>augment()</code> returns a tibble with the same class as
<code>data</code>. That is, if <code>data</code> is
an <code>sf</code> object, then the augmented object (obtained via <code>augment(x)</code>)
will be an <code>sf</code> object as well. When augmenting <code>newdata</code>, the
augmented object has the same class as <code>data</code>.
</p>
<p>Missing response values from the original data can be augmented as if
they were a <code>newdata</code> object by providing <code>x$newdata</code> to the
<code>newdata</code> argument (where <code>x</code> is the name of the fitted model
object). This is the only way to compute predictions for
<code><a href="#topic+spautor">spautor()</a></code> and <code><a href="#topic+spgautor">spgautor()</a></code> fitted model objects.
</p>


<h3>Value</h3>

<p>When augmenting the original data set, a tibble with additional columns
</p>

<ul>
<li> <p><code>.fitted</code> Fitted value
</p>
</li>
<li> <p><code>.resid</code> Response residual (the difference between observed and fitted values)
</p>
</li>
<li> <p><code>.hat</code> Leverage (diagonal of the hat matrix)
</p>
</li>
<li> <p><code>.cooksd</code> Cook's distance
</p>
</li>
<li> <p><code>.std.resid</code> Standardized residuals
</p>
</li>
<li> <p><code>.se.fit</code> Standard error of the fitted value.
</p>
</li></ul>

<p>When augmenting a new data set, a tibble with additional columns
</p>

<ul>
<li> <p><code>.fitted</code> Predicted (or fitted) value
</p>
</li>
<li> <p><code>.lower</code> Lower bound on interval
</p>
</li>
<li> <p><code>.upper</code> Upper bound on interval
</p>
</li>
<li> <p><code>.se.fit</code> Standard error of the predicted (or fitted) value
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+tidy.spmodel">tidy.spmodel()</a></code> <code><a href="#topic+glance.spmodel">glance.spmodel()</a></code> <code><a href="#topic+predict.spmodel">predict.spmodel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
augment(spmod)
spmod_sulf &lt;- splm(sulfate ~ 1, data = sulfate, spcov_type = "exponential")
augment(spmod_sulf)
augment(spmod_sulf, newdata = sulfate_preds)
# missingness in original data
spmod_seal &lt;- spautor(log_trend ~ 1, data = seal, spcov_type = "car")
augment(spmod_seal)
augment(spmod_seal, newdata = spmod_seal$newdata)
</code></pre>

<hr>
<h2 id='caribou'>A caribou forage experiment</h2><span id='topic+caribou'></span>

<h3>Description</h3>

<p>A caribou forage experiment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caribou
</code></pre>


<h3>Format</h3>

<p>A <code>tibble</code> with 30 rows and 5 columns:
</p>

<ul>
<li><p> water: A factor representing whether water was added. Takes values
<code>N</code> (no water added) and <code>Y</code> (water added).
</p>
</li>
<li><p> tarp: A factor representing tarp cover. Takes values <code>clear</code>
(a clear tarp), <code>shade</code> (a shade tarp), and <code>none</code> (no tarp).
</p>
</li>
<li><p> z: The percentage of nitrogen.
</p>
</li>
<li><p> x: The x-coordinate.
</p>
</li>
<li><p> y: The y-coordinate.
</p>
</li></ul>



<h3>Source</h3>

<p>These data were provided by Elizabeth Lenart of the Alaska Department
of Fish and Game.  The data were used in the publication listed in References.
</p>


<h3>References</h3>

<p>Lenart, E.A., Bowyer, R.T., Ver Hoef, J.M. and Ruess, R.W. 2002.
Climate Change and Caribou: Effects of Summer Weather on Forage. Canadian
Journal of Zoology 80: 664-678.
</p>

<hr>
<h2 id='coef.spmodel'>Extract fitted model coefficients</h2><span id='topic+coef.spmodel'></span><span id='topic+coef.splm'></span><span id='topic+coefficients.splm'></span><span id='topic+coef.spautor'></span><span id='topic+coefficients.spautor'></span><span id='topic+coef.spglm'></span><span id='topic+coefficients.spglm'></span><span id='topic+coef.spgautor'></span><span id='topic+coefficients.spgautor'></span>

<h3>Description</h3>

<p>coef extracts fitted model coefficients from
fitted model objects. <code>coefficients</code> is an alias for it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splm'
coef(object, type = "fixed", ...)

## S3 method for class 'splm'
coefficients(object, type = "fixed", ...)

## S3 method for class 'spautor'
coef(object, type = "fixed", ...)

## S3 method for class 'spautor'
coefficients(object, type = "fixed", ...)

## S3 method for class 'spglm'
coef(object, type = "fixed", ...)

## S3 method for class 'spglm'
coefficients(object, type = "fixed", ...)

## S3 method for class 'spgautor'
coef(object, type = "fixed", ...)

## S3 method for class 'spgautor'
coefficients(object, type = "fixed", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.spmodel_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>.</p>
</td></tr>
<tr><td><code id="coef.spmodel_+3A_type">type</code></td>
<td>
<p><code>"fixed"</code> for fixed effect coefficients, <code>"spcov"</code> for
spatial covariance parameter coefficients, or <code>"randcov"</code> for random effect
variance coefficients. Defaults to <code>"fixed"</code>. If <code>type = "spcov"</code>, the
coefficient vector is an <code><a href="#topic+spcov_params">spcov_params()</a></code> object (which means that has class
matching the spatial covariance function used).</p>
</td></tr>
<tr><td><code id="coef.spmodel_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of coefficients.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
coef(spmod)
coefficients(spmod)
coef(spmod, type = "spcov")
</code></pre>

<hr>
<h2 id='confint.spmodel'>Confidence intervals for fitted model parameters</h2><span id='topic+confint.spmodel'></span><span id='topic+confint.splm'></span><span id='topic+confint.spautor'></span><span id='topic+confint.spglm'></span><span id='topic+confint.spgautor'></span>

<h3>Description</h3>

<p>Computes confidence intervals for one or more parameters in a fitted
model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splm'
confint(object, parm, level = 0.95, ...)

## S3 method for class 'spautor'
confint(object, parm, level = 0.95, ...)

## S3 method for class 'spglm'
confint(object, parm, level = 0.95, ...)

## S3 method for class 'spgautor'
confint(object, parm, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.spmodel_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>.</p>
</td></tr>
<tr><td><code id="confint.spmodel_+3A_parm">parm</code></td>
<td>
<p>A specification of which parameters are to be given confidence
intervals (a character vector of names). If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="confint.spmodel_+3A_level">level</code></td>
<td>
<p>The confidence level required. The default is <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="confint.spmodel_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Gaussian-based confidence intervals (two-sided and equal-tailed) for the
fixed effect coefficients based on the confidence level specified by <code>level</code>.
For <code><a href="#topic+spglm">spglm()</a></code> or <code><a href="#topic+spgautor">spgautor()</a></code> fitted model objects, confidence intervals are
on the link scale.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
confint(spmod)
confint(spmod, parm = "waterY", level = 0.90)
</code></pre>

<hr>
<h2 id='cooks.distance.spmodel'>Compute Cook's distance</h2><span id='topic+cooks.distance.spmodel'></span><span id='topic+cooks.distance.splm'></span><span id='topic+cooks.distance.spautor'></span><span id='topic+cooks.distance.spglm'></span><span id='topic+cooks.distance.spgautor'></span>

<h3>Description</h3>

<p>Compute the Cook's distance for each observation from a fitted
model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splm'
cooks.distance(model, ...)

## S3 method for class 'spautor'
cooks.distance(model, ...)

## S3 method for class 'spglm'
cooks.distance(model, ...)

## S3 method for class 'spgautor'
cooks.distance(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cooks.distance.spmodel_+3A_model">model</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>.</p>
</td></tr>
<tr><td><code id="cooks.distance.spmodel_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cook's distance measures the influence of an observation on a fitted
model object. If an observation is influential, its omission from the data
noticeably impacts parameter estimates. The larger the Cook's distance, the
larger the influence.
</p>


<h3>Value</h3>

<p>A vector of Cook's distance values for each observation from the
fitted model object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+augment.spmodel">augment.spmodel()</a></code> <code><a href="#topic+hatvalues.spmodel">hatvalues.spmodel()</a></code> <code><a href="#topic+influence.spmodel">influence.spmodel()</a></code> <code><a href="#topic+residuals.spmodel">residuals.spmodel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
cooks.distance(spmod)
</code></pre>

<hr>
<h2 id='covmatrix'>Create a covariance matrix</h2><span id='topic+covmatrix'></span><span id='topic+covmatrix.splm'></span><span id='topic+covmatrix.spautor'></span><span id='topic+covmatrix.spglm'></span><span id='topic+covmatrix.spgautor'></span>

<h3>Description</h3>

<p>Create a covariance matrix from a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covmatrix(object, newdata, ...)

## S3 method for class 'splm'
covmatrix(object, newdata, ...)

## S3 method for class 'spautor'
covmatrix(object, newdata, ...)

## S3 method for class 'spglm'
covmatrix(object, newdata, ...)

## S3 method for class 'spgautor'
covmatrix(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covmatrix_+3A_object">object</code></td>
<td>
<p>A fitted model object (e.g., <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>).</p>
</td></tr>
<tr><td><code id="covmatrix_+3A_newdata">newdata</code></td>
<td>
<p>If omitted, the covariance matrix of
the observed data is returned. If provided, <code>newdata</code> is
a data frame or <code>sf</code> object that contains coordinate information
required to construct the covariance between <code>newdata</code> and
the observed data. If a data frame, <code>newdata</code>
must contain variables that represent coordinates having the same name as
the coordinates from the observed data used to fit <code>object</code>. If an
<code>sf</code> object, coordinates are obtained from the geometry of <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="covmatrix_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>newdata</code> is omitted, the covariance matrix of the observed
data, which has dimension n x n, where n is the sample size used to fit <code>object</code>.
If <code>newdata</code> is provided, the covariance matrix between the unobserved (new)
data and the observed data, which has dimension m x n, where m is the number of
new observations and n is the sample size used to fit <code>object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
covmatrix(spmod)
</code></pre>

<hr>
<h2 id='deviance.spmodel'>Fitted model deviance</h2><span id='topic+deviance.spmodel'></span><span id='topic+deviance.splm'></span><span id='topic+deviance.spautor'></span><span id='topic+deviance.spglm'></span><span id='topic+deviance.spgautor'></span>

<h3>Description</h3>

<p>Returns the deviance of a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splm'
deviance(object, ...)

## S3 method for class 'spautor'
deviance(object, ...)

## S3 method for class 'spglm'
deviance(object, ...)

## S3 method for class 'spgautor'
deviance(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deviance.spmodel_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>,
where <code>estmethod</code> is <code>"ml"</code> or <code>"reml"</code>.</p>
</td></tr>
<tr><td><code id="deviance.spmodel_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For objects estimated using <code>"ml"</code> or <code>"reml"</code>,
the deviance is twice the difference in log-likelihoods between the
saturated (perfect-fit) model and the fitted model.
</p>


<h3>Value</h3>

<p>The deviance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
deviance(spmod)
</code></pre>

<hr>
<h2 id='dispersion_initial'>Create a dispersion parameter initial object</h2><span id='topic+dispersion_initial'></span>

<h3>Description</h3>

<p>Create a dispersion parameter initial object that specifies
initial and/or known values to use while estimating the dispersion parameter
with <code><a href="#topic+spglm">spglm()</a></code> or <code><a href="#topic+spgautor">spgautor()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dispersion_initial(family, dispersion, known)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dispersion_initial_+3A_family">family</code></td>
<td>
<p>The generalized linear model family describing the distribution
of the response variable to be used. <code>"poisson"</code>, <code>"nbinomial"</code>, <code>"binomial"</code>,
<code>"beta"</code>, <code>"Gamma"</code>, and <code>"inverse.gaussian"</code>.</p>
</td></tr>
<tr><td><code id="dispersion_initial_+3A_dispersion">dispersion</code></td>
<td>
<p>The value of the dispersion parameter.</p>
</td></tr>
<tr><td><code id="dispersion_initial_+3A_known">known</code></td>
<td>
<p>A character vector indicating whether the dispersion parameter is to be
assumed known. The value <code>"dispersion"</code> or <code>"given"</code> is assumes
the dispersion parameter is known.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>dispersion_initial</code> list is later passed to <code><a href="#topic+spglm">spglm()</a></code> or <code><a href="#topic+spgautor">spgautor()</a></code>.
</p>
<p>The variance function of an individual <code class="reqn">y</code> (given <code class="reqn">\mu</code>)
for each generalized linear model family is given below:
</p>

<ul>
<li><p> family: <code class="reqn">Var(y)</code>
</p>
</li>
<li><p> poisson: <code class="reqn">\mu \phi</code>
</p>
</li>
<li><p> nbinomial: <code class="reqn">\mu + \mu^2 / \phi</code>
</p>
</li>
<li><p> binomial: <code class="reqn">n \mu (1 - \mu) \phi</code>
</p>
</li>
<li><p> beta: <code class="reqn">\mu (1 - \mu) / (1 + \phi)</code>
</p>
</li>
<li><p> Gamma: <code class="reqn">\mu^2 / \phi</code>
</p>
</li>
<li><p> inverse.gaussian: <code class="reqn">\mu^2 / \phi</code>
</p>
</li></ul>

<p>The parameter <code class="reqn">\phi</code> is a dispersion parameter that influences <code class="reqn">Var(y)</code>.
For the <code>poisson</code> and <code>binomial</code> families, <code class="reqn">\phi</code> is always
one. Note that this inverse Gaussian parameterization is different than a
standard inverse Gaussian parameterization, which has variance <code class="reqn">\mu^3 / \lambda</code>.
Setting <code class="reqn">\phi = \lambda / \mu</code> yields our parameterization, which is
preferred for computational stability. Also note that the dispersion parameter
is often defined in the literature as <code class="reqn">V(\mu) \phi</code>, where <code class="reqn">V(\mu)</code> is the variance
function of the mean. We do not use this parameterization, which is important
to recognize while interpreting dispersion parameter estimates using <code><a href="#topic+spglm">spglm()</a></code> or <code><a href="#topic+spgautor">spgautor()</a></code>.
For more on generalized linear model constructions, see McCullagh and
Nelder (1989).
</p>


<h3>Value</h3>

<p>A list with two elements: <code>initial</code> and <code>is_known</code>.
<code>initial</code> is a named numeric vector indicating the dispersion parameters
with a specified initial and/or known value. <code>is_known</code> is a named
numeric vector indicating whether the dispersion parameters in
<code>initial</code> is known or not. The class of the list
matches the value given to the <code>family</code> argument.
</p>


<h3>References</h3>

<p>McCullagh P. and Nelder, J. A. (1989) <em>Generalized Linear Models</em>. London: Chapman and Hall.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># known dispersion value 1
dispersion_initial("nbinomial", dispersion = 1, known = "dispersion")
</code></pre>

<hr>
<h2 id='dispersion_params'>Create a dispersion parameter object</h2><span id='topic+dispersion_params'></span>

<h3>Description</h3>

<p>Create a dispersion parameter object for use with other
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dispersion_params(family, dispersion)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dispersion_params_+3A_family">family</code></td>
<td>
<p>The generalized linear model family describing the distribution
of the response variable to be used. <code>"poisson"</code>, <code>"nbinomial"</code>, <code>"binomial"</code>,
<code>"beta"</code>, <code>"Gamma"</code>, and <code>"inverse.gaussian"</code>.</p>
</td></tr>
<tr><td><code id="dispersion_params_+3A_dispersion">dispersion</code></td>
<td>
<p>The value of the dispersion parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variance function of an individual <code class="reqn">y</code> (given <code class="reqn">\mu</code>)
for each generalized linear model family is given below:
</p>

<ul>
<li><p> family: <code class="reqn">Var(y)</code>
</p>
</li>
<li><p> poisson: <code class="reqn">\mu \phi</code>
</p>
</li>
<li><p> nbinomial: <code class="reqn">\mu + \mu^2 / \phi</code>
</p>
</li>
<li><p> binomial: <code class="reqn">n \mu (1 - \mu) \phi</code>
</p>
</li>
<li><p> beta: <code class="reqn">\mu (1 - \mu) / (1 + \phi)</code>
</p>
</li>
<li><p> Gamma: <code class="reqn">\mu^2 / \phi</code>
</p>
</li>
<li><p> inverse.gaussian: <code class="reqn">\mu^2 / \phi</code>
</p>
</li></ul>

<p>The parameter <code class="reqn">\phi</code> is a dispersion parameter that influences <code class="reqn">Var(y)</code>.
For the <code>poisson</code> and <code>binomial</code> families, <code class="reqn">\phi</code> is always
one. Note that this inverse Gaussian parameterization is different than a
standard inverse Gaussian parameterization, which has variance <code class="reqn">\mu^3 / \lambda</code>.
Setting <code class="reqn">\phi = \lambda / \mu</code> yields our parameterization, which is
preferred for computational stability. Also note that the dispersion parameter
is often defined in the literature as <code class="reqn">V(\mu) \phi</code>, where <code class="reqn">V(\mu)</code> is the variance
function of the mean. We do not use this parameterization, which is important
to recognize while interpreting dispersion parameter estimates using <code><a href="#topic+spglm">spglm()</a></code> or <code><a href="#topic+spgautor">spgautor()</a></code>.
For more on generalized linear model constructions, see McCullagh and
Nelder (1989).
</p>


<h3>Value</h3>

<p>A named numeric vector with class <code>family</code> containing the dispersion.
</p>


<h3>References</h3>

<p>McCullagh P. and Nelder, J. A. (1989) <em>Generalized Linear Models</em>. London: Chapman and Hall.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dispersion_params("beta", dispersion = 1)
</code></pre>

<hr>
<h2 id='esv'>Compute the empirical semivariogram</h2><span id='topic+esv'></span>

<h3>Description</h3>

<p>Compute the empirical semivariogram for varying bin sizes and
cutoff values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>esv(
  formula,
  data,
  xcoord,
  ycoord,
  dist_matrix,
  bins = 15,
  cutoff,
  partition_factor
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="esv_+3A_formula">formula</code></td>
<td>
<p>A formula describing the fixed effect structure.</p>
</td></tr>
<tr><td><code id="esv_+3A_data">data</code></td>
<td>
<p>A data frame or <code>sf</code> object containing the variables in <code>formula</code>
and geographic information.</p>
</td></tr>
<tr><td><code id="esv_+3A_xcoord">xcoord</code></td>
<td>
<p>Name of the variable in <code>data</code> representing the x-coordinate.
Can be quoted or unquoted. Not required if <code>data</code> is an <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="esv_+3A_ycoord">ycoord</code></td>
<td>
<p>Name of the variable in <code>data</code> representing the y-coordinate.
Can be quoted or unquoted. Not required if <code>data</code> is an <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="esv_+3A_dist_matrix">dist_matrix</code></td>
<td>
<p>A distance matrix to be used instead of providing coordinate names.</p>
</td></tr>
<tr><td><code id="esv_+3A_bins">bins</code></td>
<td>
<p>The number of equally spaced bins. The default is 15.</p>
</td></tr>
<tr><td><code id="esv_+3A_cutoff">cutoff</code></td>
<td>
<p>The maximum distance considered.
The default is half the diagonal of the bounding box from the coordinates.</p>
</td></tr>
<tr><td><code id="esv_+3A_partition_factor">partition_factor</code></td>
<td>
<p>An optional formula specifying the partition factor.
If specified, semivariances are only computed for observations sharing the
same level of the partition factor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The empirical semivariogram is a tool used to visualize and model
spatial dependence by estimating the semivariance of a process at varying distances.
For a constant-mean process, the
semivariance at distance <code class="reqn">h</code> is denoted <code class="reqn">\gamma(h)</code> and defined as
<code class="reqn">0.5 * Var(z1  - z2)</code>. Under second-order stationarity,
<code class="reqn">\gamma(h) = Cov(0) - Cov(h)</code>, where <code class="reqn">Cov(h)</code> is the covariance function at distance <code>h</code>. Typically the residuals from an ordinary
least squares fit defined by <code>formula</code> are second-order stationary with
mean zero. These residuals are used to compute the empirical semivariogram.
At a distance <code>h</code>, the empirical semivariance is
<code class="reqn">1/N(h) \sum (r1 - r2)^2</code>, where <code class="reqn">N(h)</code> is the number of (unique)
pairs in the set of observations whose distance separation is <code>h</code> and
<code>r1</code> and <code>r2</code> are residuals corresponding to observations whose
distance separation is <code>h</code>. In spmodel, these distance bins actually
contain observations whose distance separation is <code>h +- c</code>,
where <code>c</code> is a constant determined implicitly by <code>bins</code>. Typically,
only observations whose distance separation is below some cutoff are used
to compute the empirical semivariogram (this cutoff is determined by <code>cutoff</code>).
</p>
<p>When using <code><a href="#topic+splm">splm()</a></code> with <code>estmethod</code> as <code>"sv-wls"</code>, the empirical
semivariogram is calculated internally and used to estimate spatial
covariance parameters.
</p>


<h3>Value</h3>

<p>A data frame with distance bins (<code>bins</code>), the  average distance
(<code>dist</code>), the semivariance (<code>gamma</code>), and the
number of (unique) pairs (<code>np</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>esv(sulfate ~ 1, sulfate)
</code></pre>

<hr>
<h2 id='fitted.spmodel'>Extract model fitted values</h2><span id='topic+fitted.spmodel'></span><span id='topic+fitted.splm'></span><span id='topic+fitted.values.splm'></span><span id='topic+fitted.spautor'></span><span id='topic+fitted.values.spautor'></span><span id='topic+fitted.spglm'></span><span id='topic+fitted.values.spglm'></span><span id='topic+fitted.spgautor'></span><span id='topic+fitted.values.spgautor'></span>

<h3>Description</h3>

<p>Extract fitted values from fitted model objects. <code>fitted.values</code>
is an alias.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splm'
fitted(object, type = "response", ...)

## S3 method for class 'splm'
fitted.values(object, type = "response", ...)

## S3 method for class 'spautor'
fitted(object, type = "response", ...)

## S3 method for class 'spautor'
fitted.values(object, type = "response", ...)

## S3 method for class 'spglm'
fitted(object, type = "response", ...)

## S3 method for class 'spglm'
fitted.values(object, type = "response", ...)

## S3 method for class 'spgautor'
fitted(object, type = "response", ...)

## S3 method for class 'spgautor'
fitted.values(object, type = "response", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.spmodel_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>.</p>
</td></tr>
<tr><td><code id="fitted.spmodel_+3A_type">type</code></td>
<td>
<p><code>"response"</code> for fitted values of the response, <code>"spcov"</code>
for fitted values of the spatial random errors, or <code>"randcov"</code> for
fitted values of the random effects. If from <code>spglm()</code> or <code>spgautor()</code>,
<code>"link"</code> for fitted values on the link scale. The default is <code>"response"</code>.</p>
</td></tr>
<tr><td><code id="fitted.spmodel_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>type</code> is <code>"response"</code>, the fitted values
for each observation are the standard fitted values <code class="reqn">X \hat{\beta}</code>.
When <code>type</code> is <code>"spcov"</code> the fitted values for each observation
are (generally) the best linear unbiased predictors of the spatial dependent and spatial
independent random error. When <code>type</code> is <code>"randcov"</code>, the fitted
values for each level of each random effect are (generally) the best linear unbiased
predictors of the corresponding random effect. The fitted values for <code>type</code>
<code>"spcov"</code> and <code>"randcov"</code> can generally be used to check assumptions
for each component of the fitted model object (e.g., check a Gaussian assumption).
</p>


<h3>Value</h3>

<p>The fitted values according to <code>type</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
fitted(spmod)
fitted.values(spmod)
fitted(spmod, type = "spcov")
</code></pre>

<hr>
<h2 id='formula.spmodel'>Model formulae</h2><span id='topic+formula.spmodel'></span><span id='topic+formula.splm'></span><span id='topic+formula.spautor'></span><span id='topic+formula.spglm'></span><span id='topic+formula.spgautor'></span>

<h3>Description</h3>

<p>Return formula used by a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splm'
formula(x, ...)

## S3 method for class 'spautor'
formula(x, ...)

## S3 method for class 'spglm'
formula(x, ...)

## S3 method for class 'spgautor'
formula(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.spmodel_+3A_x">x</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>.</p>
</td></tr>
<tr><td><code id="formula.spmodel_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The formula used by a fitted model object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
formula(spmod)
</code></pre>

<hr>
<h2 id='glance.spmodel'>Glance at a fitted model object</h2><span id='topic+glance.spmodel'></span><span id='topic+glance.splm'></span><span id='topic+glance.spautor'></span><span id='topic+glance.spglm'></span><span id='topic+glance.spgautor'></span>

<h3>Description</h3>

<p>Returns a row of model
summaries from a fitted model object. Glance returns the same number of columns for all models
and estimation methods. If a particular summary is undefined for a model
or estimation method (e.g., likelihood statistics for estimation methods
<code>"sv-wls"</code> or <code>"sv-cl"</code> of <code>splm()</code> objects), <code>NA</code> is returned for that summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splm'
glance(x, ...)

## S3 method for class 'spautor'
glance(x, ...)

## S3 method for class 'spglm'
glance(x, ...)

## S3 method for class 'spgautor'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.spmodel_+3A_x">x</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.spmodel_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single-row tibble with columns
</p>

<ul>
<li> <p><code>n</code> The sample size.
</p>
</li>
<li> <p><code>p</code> The number of fixed effects.
</p>
</li>
<li> <p><code>npar</code> The number of estimated covariance parameters.
</p>
</li>
<li> <p><code>value</code> The optimized value of the fitting function
</p>
</li>
<li> <p><code>AIC</code> The AIC.
</p>
</li>
<li> <p><code>AICc</code> The AICc.
</p>
</li>
<li> <p><code>logLik</code> The log-likelihood
</p>
</li>
<li> <p><code>deviance</code> The deviance.
</p>
</li>
<li> <p><code>pseudo.r.squared</code> The pseudo r-squared
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+AIC.spmodel">AIC.spmodel()</a></code> <code><a href="#topic+AICc">AICc()</a></code> <code><a href="#topic+logLik.spmodel">logLik.spmodel()</a></code> <code><a href="#topic+deviance.spmodel">deviance.spmodel()</a></code> <code><a href="#topic+pseudoR2">pseudoR2()</a></code> <code><a href="#topic+tidy.spmodel">tidy.spmodel()</a></code> <code><a href="#topic+augment.spmodel">augment.spmodel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
glance(spmod)
</code></pre>

<hr>
<h2 id='glances'>Glance at many fitted model objects</h2><span id='topic+glances'></span><span id='topic+glances.splm'></span><span id='topic+glances.spautor'></span><span id='topic+glances.splm_list'></span><span id='topic+glances.spautor_list'></span><span id='topic+glances.spglm'></span><span id='topic+glances.spgautor'></span><span id='topic+glances.spglm_list'></span><span id='topic+glances.spgautor_list'></span>

<h3>Description</h3>

<p><code>glances()</code> repeatedly calls <code>glance()</code> on several
fitted model objects and binds the output together, sorted by a column of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glances(object, ..., sort_by = "AICc", decreasing = FALSE)

## S3 method for class 'splm'
glances(object, ..., sort_by = "AICc", decreasing = FALSE)

## S3 method for class 'spautor'
glances(object, ..., sort_by = "AICc", decreasing = FALSE)

## S3 method for class 'splm_list'
glances(object, ..., sort_by = "AICc", decreasing = FALSE)

## S3 method for class 'spautor_list'
glances(object, ..., sort_by = "AICc", decreasing = FALSE)

## S3 method for class 'spglm'
glances(object, ..., sort_by = "AICc", decreasing = FALSE)

## S3 method for class 'spgautor'
glances(object, ..., sort_by = "AICc", decreasing = FALSE)

## S3 method for class 'spglm_list'
glances(object, ..., sort_by = "AICc", decreasing = FALSE)

## S3 method for class 'spgautor_list'
glances(object, ..., sort_by = "AICc", decreasing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glances_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>.</p>
</td></tr>
<tr><td><code id="glances_+3A_...">...</code></td>
<td>
<p>Additional fitted model objects. Ignored
if <code>object</code> has class <code>splm_list</code>, <code>spautor_list</code>, <code>spglm_list</code>, or <code>spgautor_list</code>.</p>
</td></tr>
<tr><td><code id="glances_+3A_sort_by">sort_by</code></td>
<td>
<p>Sort by a <code>glance</code> statistic (i.e., the name of a column
output from <code>glance()</code> or the order of model input (<code>sort_by = "order"</code>).
The default is <code>"AICc"</code>.</p>
</td></tr>
<tr><td><code id="glances_+3A_decreasing">decreasing</code></td>
<td>
<p>Should <code>sort_by</code> be decreasing or not? The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble where each row represents the output of <code>glance()</code> for
each fitted model object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "none"
)
spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
glances(lmod, spmod)
glances(lmod, spmod, sort_by = "logLik", decreasing = TRUE)
</code></pre>

<hr>
<h2 id='hatvalues.spmodel'>Compute leverage (hat) values</h2><span id='topic+hatvalues.spmodel'></span><span id='topic+hatvalues.splm'></span><span id='topic+hatvalues.spautor'></span><span id='topic+hatvalues.spglm'></span><span id='topic+hatvalues.spgautor'></span>

<h3>Description</h3>

<p>Compute the leverage (hat) value for each observation from a fitted
model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splm'
hatvalues(model, ...)

## S3 method for class 'spautor'
hatvalues(model, ...)

## S3 method for class 'spglm'
hatvalues(model, ...)

## S3 method for class 'spgautor'
hatvalues(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hatvalues.spmodel_+3A_model">model</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>.</p>
</td></tr>
<tr><td><code id="hatvalues.spmodel_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Leverage values measure how far an observation's explanatory variables
are relative to the average of the explanatory variables. In other words, observations with high
leverage are typically considered to have an extreme or unusual combination of explanatory
variables. Leverage values are the diagonal of the hat (projection) matrix.
The larger the hat value, the larger the leverage.
</p>


<h3>Value</h3>

<p>A vector of leverage (hat) values for each observation from the
fitted model object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+augment.spmodel">augment.spmodel()</a></code> <code><a href="#topic+cooks.distance.spmodel">cooks.distance.spmodel()</a></code> <code><a href="#topic+influence.spmodel">influence.spmodel()</a></code> <code><a href="#topic+residuals.spmodel">residuals.spmodel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
hatvalues(spmod)
</code></pre>

<hr>
<h2 id='influence.spmodel'>Regression diagnostics</h2><span id='topic+influence.spmodel'></span><span id='topic+influence.splm'></span><span id='topic+influence.spautor'></span><span id='topic+influence.spglm'></span><span id='topic+influence.spgautor'></span>

<h3>Description</h3>

<p>Provides basic quantities which are used in forming
a wide variety of diagnostics for checking the quality of fitted model objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splm'
influence(model, ...)

## S3 method for class 'spautor'
influence(model, ...)

## S3 method for class 'spglm'
influence(model, ...)

## S3 method for class 'spgautor'
influence(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="influence.spmodel_+3A_model">model</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>.</p>
</td></tr>
<tr><td><code id="influence.spmodel_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code><a href="#topic+residuals.spmodel">residuals.spmodel()</a></code>, <code><a href="#topic+hatvalues.spmodel">hatvalues.spmodel()</a></code>,
and <code><a href="#topic+cooks.distance.spmodel">cooks.distance.spmodel()</a></code> and puts the results into a tibble. It is
primarily used when calling <code><a href="#topic+augment.spmodel">augment.spmodel()</a></code>.
</p>


<h3>Value</h3>

<p>A tibble with residuals (<code>.resid</code>), leverage values (<code>.hat</code>),
cook's distance (<code>.cooksd</code>), and standardized residuals (<code>.std.resid</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+augment.spmodel">augment.spmodel()</a></code> <code><a href="#topic+cooks.distance.spmodel">cooks.distance.spmodel()</a></code> <code><a href="#topic+hatvalues.spmodel">hatvalues.spmodel()</a></code> <code><a href="#topic+residuals.spmodel">residuals.spmodel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
influence(spmod)
</code></pre>

<hr>
<h2 id='labels.spmodel'>Find labels from object</h2><span id='topic+labels.spmodel'></span><span id='topic+labels.splm'></span><span id='topic+labels.spautor'></span><span id='topic+labels.spglm'></span><span id='topic+labels.spgautor'></span>

<h3>Description</h3>

<p>Find a suitable set of labels from a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splm'
labels(object, ...)

## S3 method for class 'spautor'
labels(object, ...)

## S3 method for class 'spglm'
labels(object, ...)

## S3 method for class 'spgautor'
labels(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labels.spmodel_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>.</p>
</td></tr>
<tr><td><code id="labels.spmodel_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing the terms used for the fixed effects
from a fitted model object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
labels(spmod)
</code></pre>

<hr>
<h2 id='logLik.spmodel'>Extract log-likelihood</h2><span id='topic+logLik.spmodel'></span><span id='topic+logLik.splm'></span><span id='topic+logLik.spautor'></span><span id='topic+logLik.spglm'></span><span id='topic+logLik.spgautor'></span>

<h3>Description</h3>

<p>Find the log-likelihood of a fitted model when <code>estmethod</code>
is <code>"ml"</code> or <code>"reml"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splm'
logLik(object, ...)

## S3 method for class 'spautor'
logLik(object, ...)

## S3 method for class 'spglm'
logLik(object, ...)

## S3 method for class 'spgautor'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.spmodel_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code> where <code>estmethod</code>
is <code>"ml"</code> or <code>"reml"</code>.</p>
</td></tr>
<tr><td><code id="logLik.spmodel_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-likelihood.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
logLik(spmod)
</code></pre>

<hr>
<h2 id='loocv'>Perform leave-one-out cross validation</h2><span id='topic+loocv'></span><span id='topic+loocv.splm'></span><span id='topic+loocv.spautor'></span><span id='topic+loocv.spglm'></span><span id='topic+loocv.spgautor'></span>

<h3>Description</h3>

<p>Perform leave-one-out cross validation with options for computationally
efficient approximations for big data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loocv(object, ...)

## S3 method for class 'splm'
loocv(object, cv_predict = FALSE, se.fit = FALSE, local, ...)

## S3 method for class 'spautor'
loocv(object, cv_predict = FALSE, se.fit = FALSE, local, ...)

## S3 method for class 'spglm'
loocv(object, cv_predict = FALSE, se.fit = FALSE, local, ...)

## S3 method for class 'spgautor'
loocv(object, cv_predict = FALSE, se.fit = FALSE, local, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loocv_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>.</p>
</td></tr>
<tr><td><code id="loocv_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
<tr><td><code id="loocv_+3A_cv_predict">cv_predict</code></td>
<td>
<p>A logical indicating whether the leave-one-out fitted values
should be returned. Defaults to <code>FALSE</code>. If <code>object</code> is from <code><a href="#topic+spglm">spglm()</a></code> or <code><a href="#topic+spgautor">spgautor()</a></code>,
the fitted values returned are on the link scale.</p>
</td></tr>
<tr><td><code id="loocv_+3A_se.fit">se.fit</code></td>
<td>
<p>A logical indicating whether the leave-one-out
prediction standard errors should be returned. Defaults to <code>FALSE</code>.
If <code>object</code> is from <code><a href="#topic+spglm">spglm()</a></code> or <code><a href="#topic+spgautor">spgautor()</a></code>,
the standard errors correspond to the fitted values returned on the link scale.</p>
</td></tr>
<tr><td><code id="loocv_+3A_local">local</code></td>
<td>
<p>A list or logical. If a list, specific list elements described
in <code><a href="#topic+predict.spmodel">predict.spmodel()</a></code> control the big data approximation behavior.
If a logical, <code>TRUE</code> chooses default list elements for the list version
of <code>local</code> as specified in <code><a href="#topic+predict.spmodel">predict.spmodel()</a></code>. Defaults to <code>FALSE</code>,
which performs exact computations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each observation is held-out from the data set and the remaining data
are used to make a prediction for the held-out observation. This is compared
to the true value of the observation and several fit statistics are computed:
bias, mean-squared-prediction error (MSPE), root-mean-squared-prediction
error (RMSPE), and the squared correlation (cor2) between the observed data
and leave-one-out predictions (regarded as a prediction version of r-squared
appropriate for comparing across spatial and nonspatial models). Generally,
bias should be near zero for well-fitting models. The lower the MSPE and RMSPE,
the better the model fit (according to the leave-out-out criterion).
The higher the cor2, the better the model fit (according to the leave-out-out
criterion). cor2 is not returned when <code>object</code> was fit using
<code>spglm()</code> or <code>spgautor()</code>, as it is only applicable here for linear models.
</p>


<h3>Value</h3>

<p>If <code>cv_predict = FALSE</code> and <code>se.fit = FALSE</code>,
a fit statistics tibble (with bias, MSPE, RMSPE, and cor2; see Details).
If <code>cv_predict = TRUE</code> or <code>se.fit = TRUE</code>,
a list with elements: <code>stats</code>, a fit statistics tibble
(with bias, MSPE, RMSPE, and cor2; see Details); <code>cv_predict</code>, a numeric vector
with leave-one-out predictions for each observation (if <code>cv_predict = TRUE</code>);
and <code>se.fit</code>, a numeric vector with leave-one-out prediction standard
errors for each observation (if <code>se.fit = TRUE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
loocv(spmod)
loocv(spmod, cv_predict = TRUE, se.fit = TRUE)
</code></pre>

<hr>
<h2 id='model.frame.spmodel'>Extract the model frame from a fitted model object</h2><span id='topic+model.frame.spmodel'></span><span id='topic+model.frame.splm'></span><span id='topic+model.frame.spautor'></span><span id='topic+model.frame.spglm'></span><span id='topic+model.frame.spgautor'></span>

<h3>Description</h3>

<p>Extract the model frame from a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splm'
model.frame(formula, ...)

## S3 method for class 'spautor'
model.frame(formula, ...)

## S3 method for class 'spglm'
model.frame(formula, ...)

## S3 method for class 'spgautor'
model.frame(formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.frame.spmodel_+3A_formula">formula</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>.</p>
</td></tr>
<tr><td><code id="model.frame.spmodel_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A model frame that contains the variables used by the formula
for the fitted model object.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+model.frame">stats::model.frame()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
model.frame(spmod)
</code></pre>

<hr>
<h2 id='model.matrix.spmodel'>Extract the model matrix from a fitted model object</h2><span id='topic+model.matrix.spmodel'></span><span id='topic+model.matrix.splm'></span><span id='topic+model.matrix.spautor'></span><span id='topic+model.matrix.spglm'></span><span id='topic+model.matrix.spgautor'></span>

<h3>Description</h3>

<p>Extract the model matrix (X) from a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splm'
model.matrix(object, ...)

## S3 method for class 'spautor'
model.matrix(object, ...)

## S3 method for class 'spglm'
model.matrix(object, ...)

## S3 method for class 'spgautor'
model.matrix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix.spmodel_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>.</p>
</td></tr>
<tr><td><code id="model.matrix.spmodel_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The model matrix (of the fixed effects), whose rows represent
observations and whose columns represent explanatory variables corresponding
to each fixed effect.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+model.matrix">stats::model.matrix()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
model.matrix(spmod)
</code></pre>

<hr>
<h2 id='moose'>Moose counts and presence in Alaska, USA</h2><span id='topic+moose'></span>

<h3>Description</h3>

<p>Moose counts and presence in Alaska, USA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moose
</code></pre>


<h3>Format</h3>

<p>An <code>sf</code> object with 218 rows and 5 columns.
</p>

<ul>
<li><p> elev: The elevation.
</p>
</li>
<li><p> strat: A factor representing strata (used for sampling). Can take values <code>L</code> and <code>M</code>.
</p>
</li>
<li><p> count: The count (number) of moose observed.
</p>
</li>
<li><p> presence: A binary factor representing whether no moose were observed (value <code>0</code>) or at least one moose was observed
(va ue <code>1</code>).
</p>
</li>
<li><p> geometry: <code>POINT</code> geometry representing coordinates in an Alaska
Albers projection (EPSG: 3338).
</p>
</li></ul>



<h3>Source</h3>

<p>Alaska Department of Fish and Game, Division of Wildlife Conservation has released
this data set under the CC0 license.
</p>

<hr>
<h2 id='moose_preds'>Locations at which to predict moose counts and presence in Alaska, USA</h2><span id='topic+moose_preds'></span>

<h3>Description</h3>

<p>Locations at which to predict moose counts and presence in Alaska, USA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moose_preds
</code></pre>


<h3>Format</h3>

<p>An <code>sf</code> object with 100 rows and 3 columns.
</p>

<ul>
<li><p> elev: The elevation.
</p>
</li>
<li><p> strat: A factor representing strata (used for sampling). Can take values <code>L</code> and <code>M</code>.
</p>
</li>
<li><p> geometry: <code>POINT</code> geometry representing coordinates in an Alaska
Albers projection (EPSG: 3338).
</p>
</li></ul>



<h3>Source</h3>

<p>Alaska Department of Fish and Game, Division of Wildlife Conservation has released
this data set under the CC0 license.
</p>

<hr>
<h2 id='moss'>Heavy metals in mosses near a mining road in Alaska, USA</h2><span id='topic+moss'></span>

<h3>Description</h3>

<p>Heavy metals in mosses near a mining road in Alaska, USA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moss
</code></pre>


<h3>Format</h3>

<p>An <code>sf</code> object with 365 rows and 10 columns:
</p>

<ul>
<li><p> sample: A factor with a sample identifier. Some samples were
replicated in the field or laboratory. As a result, there are 318 unique
sample identifiers.
</p>
</li>
<li><p> field_dup: A factor representing field duplicate. Takes values <code>1</code>
and <code>2</code>.
</p>
</li>
<li><p> lab_rep: A factor representing laboratory replicate. Takes values <code>1</code>
and <code>2</code>.
</p>
</li>
<li><p> year: A factor representing year. Takes values <code>2001</code> and <code>2006</code>.
</p>
</li>
<li><p> sideroad: A factor representing direction relative to the haul road.
Takes values <code>N</code> (north of the haul road) and <code>S</code> (south
of the haul road).
</p>
</li>
<li><p> log_dist2road: The log of distance (in meters) to the haul road.
</p>
</li>
<li><p> log_Zn: The log of zinc concentration in moss tissue (mg/kg).
</p>
</li>
<li><p> geometry: <code>POINT</code> geometry representing coordinates in an Alaska
Albers projection (EPSG: 3338).
</p>
</li></ul>



<h3>Source</h3>

<p>Data were obtained from Peter Neitlich and Linda Hasselbach of the National
Park Service.  Data were used in the publications listed in References.
</p>


<h3>References</h3>

<p>Neitlich, P.N., Ver Hoef, J.M., Berryman, S. D., Mines, A., Geiser, L.H.,
Hasselbach, L.M., and Shiel, A. E. 2017. Trends in Spatial Patterns of Heavy
Metal Deposition on National Park Service Lands Along the Red Dog Mine Haul
Road, Alaska, 2001-2006. PLOS ONE 12(5):e0177936 DOI:10.1371/journal.pone.0177936
</p>
<p>Hasselbach, L., Ver Hoef, J.M., Ford, J., Neitlich, P., Berryman, S., Wolk B.
and Bohle, T. 2005. Spatial Patterns of Cadmium, Lead and Zinc Deposition
on National Park Service Lands in the Vicinity of Red Dog Mine, Alaska.
Science of the Total Environment 348: 211-230.
</p>

<hr>
<h2 id='plot.spmodel'>Plot fitted model diagnostics</h2><span id='topic+plot.spmodel'></span><span id='topic+plot.splm'></span><span id='topic+plot.spautor'></span><span id='topic+plot.spglm'></span><span id='topic+plot.spgautor'></span>

<h3>Description</h3>

<p>Plot fitted model diagnostics such as residuals vs fitted values,
quantile-quantile, scale-location, Cook's distance, residuals vs leverage,
Cook's distance vs leverage, a fitted spatial covariance function, and a
fitted anisotropic level curve of equal correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splm'
plot(x, which, ...)

## S3 method for class 'spautor'
plot(x, which, ...)

## S3 method for class 'spglm'
plot(x, which, ...)

## S3 method for class 'spgautor'
plot(x, which, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.spmodel_+3A_x">x</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.spmodel_+3A_which">which</code></td>
<td>
<p>An integer vector taking on values between 1 and 7, which indicates
the plots to return. Available plots are described in Details. If <code>which</code>
has length greater than one, additional plots are stepped through in order
using <code>&lt;Return&gt;</code>. The default for <code><a href="#topic+splm">splm()</a></code> and <code><a href="#topic+spglm">spglm()</a></code> fitted model objects is
<code>which = c(1, 2, 7)</code>. The default for <code><a href="#topic+spautor">spautor()</a></code> and <code><a href="#topic+spgautor">spgautor()</a></code> fitted model objects
is <code>which = c(1, 2)</code>.</p>
</td></tr>
<tr><td><code id="plot.spmodel_+3A_...">...</code></td>
<td>
<p>Other arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all fitted model objects,, the values of <code>which</code> make the
corresponding plot:
</p>

<ul>
<li><p> 1: Standardized residuals vs fitted values (of the response)
</p>
</li>
<li><p> 2: Normal quantile-quantile plot of standardized residuals
</p>
</li>
<li><p> 3: Scale-location plot of standardized residuals
</p>
</li>
<li><p> 4: Cook's distance
</p>
</li>
<li><p> 5: Standardized residuals vs leverage
</p>
</li>
<li><p> 6: Cook's distance vs leverage
</p>
</li></ul>

<p>For <code><a href="#topic+splm">splm()</a></code> and <code><a href="#topic+spglm">spglm()</a></code> fitted model objects, there are two additional values of <code>which</code>:
</p>

<ul>
<li><p> 7: Fitted spatial covariance function vs distance
</p>
</li>
<li><p> 8: Fitted anisotropic level curve of equal correlation
</p>
</li></ul>



<h3>Value</h3>

<p>No return value. Function called for plotting side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
plot(spmod)
plot(spmod, which = c(1, 2, 4, 6))
</code></pre>

<hr>
<h2 id='predict.spmodel'>Model predictions (Kriging)</h2><span id='topic+predict.spmodel'></span><span id='topic+predict.splm'></span><span id='topic+predict.spautor'></span><span id='topic+predict.splm_list'></span><span id='topic+predict.spautor_list'></span><span id='topic+predict.splmRF'></span><span id='topic+predict.spautorRF'></span><span id='topic+predict.splmRF_list'></span><span id='topic+predict.spautorRF_list'></span><span id='topic+predict.spglm'></span><span id='topic+predict.spgautor'></span><span id='topic+predict.spglm_list'></span><span id='topic+predict.spgautor_list'></span>

<h3>Description</h3>

<p>Predicted values and intervals based on a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splm'
predict(
  object,
  newdata,
  se.fit = FALSE,
  interval = c("none", "confidence", "prediction"),
  level = 0.95,
  local,
  ...
)

## S3 method for class 'spautor'
predict(
  object,
  newdata,
  se.fit = FALSE,
  interval = c("none", "confidence", "prediction"),
  level = 0.95,
  local,
  ...
)

## S3 method for class 'splm_list'
predict(
  object,
  newdata,
  se.fit = FALSE,
  interval = c("none", "confidence", "prediction"),
  level = 0.95,
  local,
  ...
)

## S3 method for class 'spautor_list'
predict(
  object,
  newdata,
  se.fit = FALSE,
  interval = c("none", "confidence", "prediction"),
  level = 0.95,
  local,
  ...
)

## S3 method for class 'splmRF'
predict(object, newdata, local, ...)

## S3 method for class 'spautorRF'
predict(object, newdata, local, ...)

## S3 method for class 'splmRF_list'
predict(object, newdata, local, ...)

## S3 method for class 'spautorRF_list'
predict(object, newdata, local, ...)

## S3 method for class 'spglm'
predict(
  object,
  newdata,
  type = c("link", "response"),
  se.fit = FALSE,
  interval = c("none", "confidence", "prediction"),
  newdata_size,
  level = 0.95,
  local,
  var_correct = TRUE,
  ...
)

## S3 method for class 'spgautor'
predict(
  object,
  newdata,
  type = c("link", "response"),
  se.fit = FALSE,
  interval = c("none", "confidence", "prediction"),
  newdata_size,
  level = 0.95,
  local,
  var_correct = TRUE,
  ...
)

## S3 method for class 'spglm_list'
predict(
  object,
  newdata,
  type = c("link", "response"),
  se.fit = FALSE,
  interval = c("none", "confidence", "prediction"),
  newdata_size,
  level = 0.95,
  local,
  var_correct = TRUE,
  ...
)

## S3 method for class 'spgautor_list'
predict(
  object,
  newdata,
  type = c("link", "response"),
  se.fit = FALSE,
  interval = c("none", "confidence", "prediction"),
  newdata_size,
  level = 0.95,
  local,
  var_correct = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.spmodel_+3A_object">object</code></td>
<td>
<p>A fitted model object.</p>
</td></tr>
<tr><td><code id="predict.spmodel_+3A_newdata">newdata</code></td>
<td>
<p>A data frame or <code>sf</code> object in which to
look for variables with which to predict. If a data frame, <code>newdata</code>
must contain all variables used by <code>formula(object)</code> and all variables
representing coordinates. If an <code>sf</code> object, <code>newdata</code> must contain
all variables used by <code>formula(object)</code> and coordinates are obtained
from the geometry of <code>newdata</code>. If omitted, missing data from the
fitted model object are used.</p>
</td></tr>
<tr><td><code id="predict.spmodel_+3A_se.fit">se.fit</code></td>
<td>
<p>A logical indicating if standard errors are returned.
The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="predict.spmodel_+3A_interval">interval</code></td>
<td>
<p>Type of interval calculation. The default is <code>"none"</code>.
Other options are <code>"confidence"</code> (for confidence intervals) and
<code>"prediction"</code> (for prediction intervals).</p>
</td></tr>
<tr><td><code id="predict.spmodel_+3A_level">level</code></td>
<td>
<p>Tolerance/confidence level. The default is <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="predict.spmodel_+3A_local">local</code></td>
<td>
<p>A optional logical or list controlling the big data approximation. If omitted, <code>local</code>
is set to <code>TRUE</code> or <code>FALSE</code> based on the sample size of the fitted
model object and/or the prediction size of <code>newdata</code> &ndash; if the sample
size or prediction size exceeds 5000, <code>local</code> is
set to <code>TRUE</code>, otherwise it is set to <code>FALSE</code>. If <code>FALSE</code>, no big data approximation
is implemented. If a list is provided, the following arguments detail the big
data approximation:
</p>

<ul>
<li> <p><code>method</code>: The big data approximation method. If <code>method = "all"</code>,
all observations are used and <code>size</code> is ignored. If <code>method = "distance"</code>,
the <code>size</code> data observations closest (in terms of Euclidean distance)
to the observation requiring prediction are used.
If <code>method = "covariance"</code>, the <code>size</code> data observations
with the highest covariance with the observation requiring prediction are used.
If random effects and partition factors are not used in estimation and
the spatial covariance function is monotone decreasing,
<code>"distance"</code> and <code>"covariance"</code> are equivalent. The default
is <code>"covariance"</code>. Only used with models fit using <code><a href="#topic+splm">splm()</a></code> or <code><a href="#topic+spglm">spglm()</a></code>.
</p>
</li>
<li> <p><code>size</code>: The number of data observations to use when <code>method</code>
is <code>"distance"</code> or <code>"covariance"</code>. The default is 100. Only used
with models fit using <code><a href="#topic+splm">splm()</a></code> or <code><a href="#topic+spglm">spglm()</a></code>.
</p>
</li>
<li> <p><code>parallel</code>: If <code>TRUE</code>, parallel processing via the
parallel package is automatically used. The default is <code>FALSE</code>.
</p>
</li>
<li> <p><code>ncores</code>: If <code>parallel = TRUE</code>, the number of cores to
parallelize over. The default is the number of available cores on your machine.
</p>
</li></ul>

<p>When <code>local</code> is a list, at least one list element must be provided to
initialize default arguments for the other list elements.
If <code>local</code> is <code>TRUE</code>, defaults for <code>local</code> are chosen such
that <code>local</code> is transformed into
<code>list(size = 100, method = "covariance", parallel = FALSE)</code>.</p>
</td></tr>
<tr><td><code id="predict.spmodel_+3A_...">...</code></td>
<td>
<p>Other arguments. Only used for models fit using <code>splmRF()</code>
or <code>spautorRF()</code> where <code>...</code> indicates other
arguments to <code>ranger::predict.ranger()</code>.</p>
</td></tr>
<tr><td><code id="predict.spmodel_+3A_type">type</code></td>
<td>
<p>The scale (<code>response</code> or <code>link</code>) of predictions obtained
using <code>spglm()</code> or <code>spgautor</code> objects.</p>
</td></tr>
<tr><td><code id="predict.spmodel_+3A_newdata_size">newdata_size</code></td>
<td>
<p>The <code>size</code> value for each observation in <code>newdata</code>
used when predicting for the binomial family.</p>
</td></tr>
<tr><td><code id="predict.spmodel_+3A_var_correct">var_correct</code></td>
<td>
<p>A logical indicating whether to return the corrected prediction
variances when predicting via models fit using <code>spglm()</code> or <code>spgautor()</code>. The default is
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>splm</code> and <code>spautor</code> objects, the (empirical) best linear unbiased predictions (i.e., Kriging
predictions) at each site are returned when <code>interval</code> is <code>"none"</code>
or <code>"prediction"</code> alongside standard errors. Prediction intervals
are also returned if <code>interval</code> is <code>"prediction"</code>. When
<code>interval</code> is <code>"confidence"</code>, the estimated mean is returned
alongside standard errors and confidence intervals for the mean. For <code>splm_list</code>
and <code>spautor_list</code> objects, predictions and associated intervals and standard errors are returned
for each list element.
</p>
<p>For <code>splmRF</code> or <code>spautorRF</code> objects, random forest spatial residual
model predictions are computed by combining the random forest prediction with
the (empirical) best linear unbiased prediction for the residual. Fox et al. (2020)
call this approach random forest regression Kriging. For <code>splmRF_list</code>
or <code>spautorRF</code> objects,
predictions are returned for each list element.
</p>


<h3>Value</h3>

<p>For <code>splm</code> or <code>spautor</code> objects, if <code>se.fit</code> is <code>FALSE</code>, <code>predict()</code> returns
a vector of predictions or a matrix of predictions with column names
<code>fit</code>, <code>lwr</code>, and <code>upr</code> if <code>interval</code> is <code>"confidence"</code>
or <code>"prediction"</code>. If <code>se.fit</code> is <code>TRUE</code>, a list with the following components is returned:
</p>

<ul>
<li> <p><code>fit</code>: vector or matrix as above
</p>
</li>
<li> <p><code>se.fit</code>: standard error of each fit
</p>
</li></ul>

<p>For <code>splm_list</code> or <code>spautor_list</code> objects, a list that contains relevant quantities for each
list element.
</p>
<p>For <code>splmRF</code> or <code>spautorRF</code> objects, a vector of predictions. For <code>splmRF_list</code>
or <code>spautorRF_list</code> objects, a list that contains relevant quantities for each list element.
</p>


<h3>References</h3>

<p>Fox, E.W., Ver Hoef, J. M., &amp; Olsen, A. R. (2020). Comparing spatial
regression to random forests for large environmental data sets.
<em>PloS one</em>, 15(3), e0229509.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(sulfate ~ 1,
  data = sulfate,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
predict(spmod, sulfate_preds)
predict(spmod, sulfate_preds, interval = "prediction")
augment(spmod, newdata = sulfate_preds, interval = "prediction")

sulfate$var &lt;- rnorm(NROW(sulfate)) # add noise variable
sulfate_preds$var &lt;- rnorm(NROW(sulfate_preds)) # add noise variable
sprfmod &lt;- splmRF(sulfate ~ var, data = sulfate, spcov_type = "exponential")
predict(sprfmod, sulfate_preds)

</code></pre>

<hr>
<h2 id='print.spmodel'>Print values</h2><span id='topic+print.spmodel'></span><span id='topic+print.splm'></span><span id='topic+print.spautor'></span><span id='topic+print.summary.splm'></span><span id='topic+print.summary.spautor'></span><span id='topic+print.anova.splm'></span><span id='topic+print.anova.spautor'></span><span id='topic+print.spglm'></span><span id='topic+print.spgautor'></span><span id='topic+print.summary.spglm'></span><span id='topic+print.summary.spgautor'></span><span id='topic+print.anova.spglm'></span><span id='topic+print.anova.spgautor'></span>

<h3>Description</h3>

<p>Print fitted model objects and summaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splm'
print(x, digits = max(3L, getOption("digits") - 3L), ...)

## S3 method for class 'spautor'
print(x, digits = max(3L, getOption("digits") - 3L), ...)

## S3 method for class 'summary.splm'
print(
  x,
  digits = max(3L, getOption("digits") - 3L),
  signif.stars = getOption("show.signif.stars"),
  ...
)

## S3 method for class 'summary.spautor'
print(
  x,
  digits = max(3L, getOption("digits") - 3L),
  signif.stars = getOption("show.signif.stars"),
  ...
)

## S3 method for class 'anova.splm'
print(
  x,
  digits = max(getOption("digits") - 2L, 3L),
  signif.stars = getOption("show.signif.stars"),
  ...
)

## S3 method for class 'anova.spautor'
print(
  x,
  digits = max(getOption("digits") - 2L, 3L),
  signif.stars = getOption("show.signif.stars"),
  ...
)

## S3 method for class 'spglm'
print(x, digits = max(3L, getOption("digits") - 3L), ...)

## S3 method for class 'spgautor'
print(x, digits = max(3L, getOption("digits") - 3L), ...)

## S3 method for class 'summary.spglm'
print(
  x,
  digits = max(3L, getOption("digits") - 3L),
  signif.stars = getOption("show.signif.stars"),
  ...
)

## S3 method for class 'summary.spgautor'
print(
  x,
  digits = max(3L, getOption("digits") - 3L),
  signif.stars = getOption("show.signif.stars"),
  ...
)

## S3 method for class 'anova.spglm'
print(
  x,
  digits = max(getOption("digits") - 2L, 3L),
  signif.stars = getOption("show.signif.stars"),
  ...
)

## S3 method for class 'anova.spgautor'
print(
  x,
  digits = max(getOption("digits") - 2L, 3L),
  signif.stars = getOption("show.signif.stars"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.spmodel_+3A_x">x</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code> or output from
<code>summary(x)</code> or or <code>anova(x)</code>.</p>
</td></tr>
<tr><td><code id="print.spmodel_+3A_digits">digits</code></td>
<td>
<p>The number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="print.spmodel_+3A_...">...</code></td>
<td>
<p>Other arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="print.spmodel_+3A_signif.stars">signif.stars</code></td>
<td>
<p>Logical. If <code>TRUE</code>, significance stars are printed for each coefficient</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Printed fitted model objects and summaries with formatting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
print(spmod)
print(summary(spmod))
print(anova(spmod))
</code></pre>

<hr>
<h2 id='pseudoR2'>Compute a pseudo r-squared</h2><span id='topic+pseudoR2'></span><span id='topic+pseudoR2.splm'></span><span id='topic+pseudoR2.spautor'></span><span id='topic+pseudoR2.spglm'></span><span id='topic+pseudoR2.spgautor'></span>

<h3>Description</h3>

<p>Compute a pseudo r-squared for a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudoR2(object, ...)

## S3 method for class 'splm'
pseudoR2(object, adjust = FALSE, ...)

## S3 method for class 'spautor'
pseudoR2(object, adjust = FALSE, ...)

## S3 method for class 'spglm'
pseudoR2(object, adjust = FALSE, ...)

## S3 method for class 'spgautor'
pseudoR2(object, adjust = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudoR2_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>.</p>
</td></tr>
<tr><td><code id="pseudoR2_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
<tr><td><code id="pseudoR2_+3A_adjust">adjust</code></td>
<td>
<p>A logical indicating whether the pseudo r-squared
should be adjusted to account for the number of explanatory variables. The
default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several pseudo r-squared statistics exist for in the literature.
We define this pseudo r-squared as one minus the ratio of the deviance of a full model
relative to the deviance of a null (intercept only) model. This pseudo r-squared
can be viewed as a generalization of the classical r-squared definition
seen as one minus the ratio of error sums of squares from the full model relative
to the error sums of squares from the null model. If adjusted, the adjustment
is analogous to the the classical r-squared adjustment.
</p>


<h3>Value</h3>

<p>The pseudo r-squared as a numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
pseudoR2(spmod)
</code></pre>

<hr>
<h2 id='randcov_initial'>Create a random effects covariance parameter initial object</h2><span id='topic+randcov_initial'></span>

<h3>Description</h3>

<p>Create a random effects (co)variance parameter initial object that specifies
initial and/or known values to use while estimating random effect variances
with modeling functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randcov_initial(..., known)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randcov_initial_+3A_...">...</code></td>
<td>
<p>Arguments to <code>randcov_params()</code>.</p>
</td></tr>
<tr><td><code id="randcov_initial_+3A_known">known</code></td>
<td>
<p>A character vector indicating which random effect variances are to be
assumed known. The value <code>"given"</code> is shorthand for assuming all
random effect variances given to <code>randcov_initial()</code> are assumed known.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A random effect is specified as <code class="reqn">Zu</code>, where <code class="reqn">Z</code> is the random
effects design matrix and <code>u</code> is the random effect. The covariance of
<code class="reqn">Zu</code> is <code class="reqn">\sigma 2 ZZ^T</code>, where <code class="reqn">\sigma 2</code> is the random effect
variance, and <code class="reqn">Z^T</code> is the transpose of <code class="reqn">Z</code>.
</p>


<h3>Value</h3>

<p>A list with two elements: <code>initial</code> and <code>is_known</code>.
<code>initial</code> is a named numeric vector indicating the random effect variances
with specified initial and/or known values. <code>is_known</code> is a named
logical vector indicating whether the random effect variances in
<code>initial</code> are known or not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>randcov_initial(group = 1)
randcov_initial(group = 1, known = "group")
</code></pre>

<hr>
<h2 id='randcov_params'>Create a random effects covariance parameter object</h2><span id='topic+randcov_params'></span>

<h3>Description</h3>

<p>Create a random effects covariance parameter object for use with other
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randcov_params(..., nm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randcov_params_+3A_...">...</code></td>
<td>
<p>A named vector (or vectors) whose names represent the name of each random
effect and whose values represent the variance of each random effect. If
unnamed, <code>nm</code> is used to set names.</p>
</td></tr>
<tr><td><code id="randcov_params_+3A_nm">nm</code></td>
<td>
<p>A character vector of names to assign to <code>...</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Names of the random effects should match eligible names given to
<code>random</code> in modeling functions. While with the <code>random</code>
argument to these functions, an
intercept is implicitly assumed, with <code>randcov_params</code>, an intercept must be
explicitly specified. That is, while with <code>random</code>, <code>x | group</code>
is shorthand for <code>(1 | group) + (x | group)</code>, with <code>randcov_params</code>,
<code>x | group</code> implies just <code>x | group</code>, which means that if <code>1 | group</code>
is also desired, it must be explicitly specified.
</p>


<h3>Value</h3>

<p>A named numeric vector of random effect covariance parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>randcov_params(group = 1, subgroup = 2)
randcov_params(1, 2, nm = c("group", "subgroup"))
# same as
randcov_params("1 | group" = 1, "1 | subgroup" = 2)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+tidy'></span><span id='topic+glance'></span><span id='topic+augment'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+augment">augment</a></code>, <code><a href="generics.html#topic+glance">glance</a></code>, <code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
</dl>

<hr>
<h2 id='residuals.spmodel'>Extract fitted model residuals</h2><span id='topic+residuals.spmodel'></span><span id='topic+residuals.splm'></span><span id='topic+resid.splm'></span><span id='topic+rstandard.splm'></span><span id='topic+residuals.spautor'></span><span id='topic+resid.spautor'></span><span id='topic+rstandard.spautor'></span><span id='topic+residuals.spglm'></span><span id='topic+resid.spglm'></span><span id='topic+rstandard.spglm'></span><span id='topic+residuals.spgautor'></span><span id='topic+resid.spgautor'></span><span id='topic+rstandard.spgautor'></span>

<h3>Description</h3>

<p>Extract residuals from a fitted model object.
<code>resid</code> is an alias.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splm'
residuals(object, type = "response", ...)

## S3 method for class 'splm'
resid(object, type = "response", ...)

## S3 method for class 'splm'
rstandard(model, ...)

## S3 method for class 'spautor'
residuals(object, type = "response", ...)

## S3 method for class 'spautor'
resid(object, type = "response", ...)

## S3 method for class 'spautor'
rstandard(model, ...)

## S3 method for class 'spglm'
residuals(object, type = "deviance", ...)

## S3 method for class 'spglm'
resid(object, type = "deviance", ...)

## S3 method for class 'spglm'
rstandard(model, ...)

## S3 method for class 'spgautor'
residuals(object, type = "deviance", ...)

## S3 method for class 'spgautor'
resid(object, type = "deviance", ...)

## S3 method for class 'spgautor'
rstandard(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.spmodel_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>.</p>
</td></tr>
<tr><td><code id="residuals.spmodel_+3A_type">type</code></td>
<td>
<p><code>"response"</code> for response residuals, <code>"pearson"</code>
for Pearson residuals, or <code>"standardized"</code> for standardized residuals.
For <code><a href="#topic+splm">splm()</a></code> and <code><a href="#topic+spautor">spautor()</a></code> fitted model objects, the default is <code>"response"</code>.
For <code><a href="#topic+spglm">spglm()</a></code> and <code><a href="#topic+spgautor">spgautor()</a></code> fitted model objects, deviance residuals are
also available (<code>"deviance"</code>) and are the default residual type.</p>
</td></tr>
<tr><td><code id="residuals.spmodel_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
<tr><td><code id="residuals.spmodel_+3A_model">model</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The response residuals are taken as the response minus the fitted values
for the response: <code class="reqn">y - X \hat{\beta}</code>. The Pearson residuals are the
response residuals pre-multiplied by their inverse square root.
The standardized residuals are Pearson residuals divided by the square
root of one minus the leverage (hat) value. The standardized residuals are often used to
check model assumptions, as they have mean zero and variance approximately one.
</p>
<p><code>rstandard()</code> is an alias for <code>residuals(model, type = "standardized")</code>.
</p>


<h3>Value</h3>

<p>The residuals as a numeric vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+augment.spmodel">augment.spmodel()</a></code> <code><a href="#topic+cooks.distance.spmodel">cooks.distance.spmodel()</a></code> <code><a href="#topic+hatvalues.spmodel">hatvalues.spmodel()</a></code> <code><a href="#topic+influence.spmodel">influence.spmodel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
residuals(spmod)
resid(spmod)
residuals(spmod, type = "pearson")
residuals(spmod, type = "standardized")
rstandard(spmod)
</code></pre>

<hr>
<h2 id='seal'>Estimated harbor-seal trends from abundance data in southeast Alaska, USA</h2><span id='topic+seal'></span>

<h3>Description</h3>

<p>Estimated harbor-seal trends from abundance data in southeast Alaska, USA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seal
</code></pre>


<h3>Format</h3>

<p>A <code>sf</code> object with 62 rows and 2 columns:
</p>

<ul>
<li><p> log_trend: The log of the estimated harbor-seal trends from abundance data.
</p>
</li>
<li><p> geometry: <code>POLYGON</code> geometry representing polygons in an Alaska
Albers projection (EPSG: 3338).
</p>
</li></ul>



<h3>Source</h3>

<p>These data were collected by the Polar Ecosystem Program of the Marine
Mammal Laboratory of the Alaska Fisheries Science Center of NOAA Fisheries.
The data were used in the publication listed in References.
</p>


<h3>References</h3>

<p>Ver Hoef, J.M., Peterson, E. E., Hooten, M. B., Hanks, E. M., and Fortin, M.-J. 2018.
Spatial Autoregressive Models for Statistical Inference from Ecological Data.
Ecological Monographs, 88: 36-59. DOI: 10.1002/ecm.1283.
</p>

<hr>
<h2 id='spautor'>Fit spatial autoregressive models</h2><span id='topic+spautor'></span>

<h3>Description</h3>

<p>Fit spatial linear models for areal data (i.e., spatial autoregressive models)
using a variety of estimation methods, allowing for random effects,
partition factors, and row standardization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spautor(
  formula,
  data,
  spcov_type,
  spcov_initial,
  estmethod = "reml",
  random,
  randcov_initial,
  partition_factor,
  W,
  row_st = TRUE,
  M,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spautor_+3A_formula">formula</code></td>
<td>
<p>A two-sided linear formula describing the fixed effect structure
of the model, with the response to the left of the <code>~</code> operator and
the terms, separated by <code>+</code> operators, on the right.</p>
</td></tr>
<tr><td><code id="spautor_+3A_data">data</code></td>
<td>
<p>A data frame or <code>sf</code> object that contains
the variables in <code>fixed</code>, <code>random</code>, and <code>partition_factor</code>,
as well as potentially geographical information.</p>
</td></tr>
<tr><td><code id="spautor_+3A_spcov_type">spcov_type</code></td>
<td>
<p>The spatial covariance type. Available options include
<code>"car"</code> and <code>"sar"</code>. Parameterizations of each spatial covariance type are
available in Details. When <code>spcov_type</code> is specified, relevant spatial
covariance parameters are assumed unknown, requiring estimation.
<code>spcov_type</code> is not required (and is
ignored) if <code>spcov_initial</code> is provided.  Multiple values can be
provided in a character vector. Then <code>spautor()</code> is called iteratively
for each element and a list is returned for each model fit.
The default for <code>spcov_type</code> is <code>"car"</code>.</p>
</td></tr>
<tr><td><code id="spautor_+3A_spcov_initial">spcov_initial</code></td>
<td>
<p>An object from <code><a href="#topic+spcov_initial">spcov_initial()</a></code> specifying initial and/or
known values for the spatial covariance parameters.
Not required if <code>spcov_type</code> is provided. Multiple <code><a href="#topic+spcov_initial">spcov_initial()</a></code>
objects can be provided in a list. Then <code>spautor()</code> is called iteratively
for each element and a list is returned for each model fit.</p>
</td></tr>
<tr><td><code id="spautor_+3A_estmethod">estmethod</code></td>
<td>
<p>The estimation method. Available options include
<code>"reml"</code> for restricted maximum likelihood and <code>"ml"</code> for maximum
likelihood The default is
<code>"reml"</code>.</p>
</td></tr>
<tr><td><code id="spautor_+3A_random">random</code></td>
<td>
<p>A one-sided linear formula describing the random effect structure
of the model. Terms are specified to the right of the <code>~ operator</code>.
Each term has the structure <code>x1 + ... + xn | g1/.../gm</code>, where <code>x1 + ... + xn</code>
specifies the model for the random effects and <code>g1/.../gm</code> is the grouping
structure. Separate terms are separated by <code>+</code> and must generally
be wrapped in parentheses. Random intercepts are added to each model
implicitly when at least  one other variable is defined.
If a random intercept is not desired, this must be explicitly
defined (e.g., <code>x1 + ... + xn - 1 | g1/.../gm</code>). If only a random intercept
is desired for a grouping structure, the random intercept must be specified
as <code>1 | g1/.../gm</code>. Note that <code>g1/.../gm</code> is shorthand for <code>(1 | g1/.../gm)</code>.
If only random intercepts are desired and the shorthand notation is used,
parentheses can be omitted.</p>
</td></tr>
<tr><td><code id="spautor_+3A_randcov_initial">randcov_initial</code></td>
<td>
<p>An optional object specifying initial and/or
known values for the random effect variances.</p>
</td></tr>
<tr><td><code id="spautor_+3A_partition_factor">partition_factor</code></td>
<td>
<p>A one-sided linear formula with a single term
specifying the partition factor.  The partition factor assumes observations
from different levels of the partition factor are uncorrelated.</p>
</td></tr>
<tr><td><code id="spautor_+3A_w">W</code></td>
<td>
<p>Weight matrix specifying the neighboring structure used.
Not required if <code>data</code> is an <code>sf</code> polygon object,
as <code>W</code> is calculated internally using queen contiguity. If calculated internally,
<code>W</code> is computed using <code>sf::st_intersects()</code>.</p>
</td></tr>
<tr><td><code id="spautor_+3A_row_st">row_st</code></td>
<td>
<p>A logical indicating whether row standardization be performed on
<code>W</code>. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="spautor_+3A_m">M</code></td>
<td>
<p><code>M</code> matrix satisfying the car symmetry condition. The car
symmetry condition states that <code class="reqn">(I - range * W)^{-1}M</code> is symmetric, where
<code class="reqn">I</code> is an identity matrix, <code class="reqn">range</code> is a constant that controls the
spatial dependence, <code>W</code> is the weights matrix,
and <code class="reqn">^{-1}</code> represents the inverse operator.
<code>M</code> is required for car models
when <code>W</code> is provided and <code>row_st</code> is <code>FALSE</code>.  When <code>M</code>,
is required, the default is the identity matrix. <code>M</code> must be diagonal
or given as a vector or one-column matrix assumed to be the diagonal.</p>
</td></tr>
<tr><td><code id="spautor_+3A_...">...</code></td>
<td>
<p>Other arguments to <code>stats::optim()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spatial linear model for areal data (i.e., spatial autoregressive model)
can be written as
<code class="reqn">y = X \beta + \tau + \epsilon</code>, where <code class="reqn">X</code> is the fixed effects design
matrix, <code class="reqn">\beta</code> are the fixed effects, <code class="reqn">\tau</code> is random error that is
spatially dependent, and <code class="reqn">\epsilon</code> is random error that is spatially
independent. Together, <code class="reqn">\tau</code> and <code class="reqn">\epsilon</code> are modeled using
a spatial covariance function, expressed as
<code class="reqn">de * R + ie * I</code>, where <code class="reqn">de</code> is the dependent error variance, <code class="reqn">R</code>
is a matrix that controls the spatial dependence structure among observations,
<code class="reqn">ie</code> is the independent error variance, and <code class="reqn">I</code> is
an identity matrix. Note that <code class="reqn">de</code> and <code class="reqn">ie</code> must be non-negative while <code class="reqn">range</code>
must be between the reciprocal of the maximum
eigenvalue of <code>W</code> and the reciprocal of the minimum eigenvalue of
<code>W</code>.
</p>
<p><code>spcov_type</code> Details: Parametric forms for <code class="reqn">R</code> are given below:
</p>

<ul>
<li><p> car: <code class="reqn">(I - range * W)^{-1}M</code>, weights matrix <code class="reqn">W</code>,
symmetry condition matrix <code class="reqn">M</code>
</p>
</li>
<li><p> sar: <code class="reqn">[(I - range * W)(I - range * W)^T]^{-1}</code>,
weights matrix <code class="reqn">W</code>, <code class="reqn">^T</code> indicates matrix transpose
</p>
</li></ul>

<p>If there are observations with no neighbors, they are given a unique variance
parameter called <code>extra</code>, which must be non-negative.
</p>
<p><code>estmethod</code> Details: The various estimation methods are
</p>

<ul>
<li> <p><code>reml</code>: Maximize the restricted log-likelihood.
</p>
</li>
<li> <p><code>ml</code>: Maximize the log-likelihood.
</p>
</li></ul>

<p>By default, all spatial covariance parameters except <code>ie</code>
as well as all random effect variance parameters
are assumed unknown, requiring estimation. <code>ie</code> is assumed zero and known by default
(in contrast to models fit using <code><a href="#topic+splm">splm()</a></code>, where <code>ie</code> is assumed
unknown by default). To change this default behavior, specify <code>spcov_initial</code>
(an <code>NA</code> value for <code>ie</code> in <code>spcov_initial</code> to assume
<code>ie</code> is unknown, requiring estimation).
</p>
<p><code>random</code> Details: If random effects are used, the model
can be written as <code class="reqn">y = X \beta + Z1u1 + ... Zjuj + \tau + \epsilon</code>,
where each Z is a random effects design matrix and each u is a random effect.
</p>
<p><code>partition_factor</code> Details:  The partition factor can be represented in matrix form as <code class="reqn">P</code>, where
elements of <code class="reqn">P</code> equal one for observations in the same level of the partition
factor and zero otherwise. The covariance matrix involving only the
spatial and random effects components is then multiplied element-wise
(Hadmard product) by <code class="reqn">P</code>, yielding the final covariance matrix.
</p>
<p>Observations with <code>NA</code> response values are removed for model
fitting, but their values can be predicted afterwards by running
<code>predict(object)</code>. This is the only way to perform prediction for
<code>spautor()</code> models (i.e., the prediction locations must be known prior
to estimation).
</p>


<h3>Value</h3>

<p>A list with many elements that store information about
the fitted model object. If <code>spcov_type</code> or <code>spcov_initial</code> are
length one, the list has class <code>spautor</code>. Many generic functions that
summarize model fit are available for <code>spautor</code> objects, including
<code>AIC</code>, <code>AICc</code>, <code>anova</code>, <code>augment</code>, <code>coef</code>,
<code>cooks.distance</code>, <code>covmatrix</code>, <code>deviance</code>, <code>fitted</code>, <code>formula</code>,
<code>glance</code>, <code>glances</code>, <code>hatvalues</code>, <code>influence</code>,
<code>labels</code>, <code>logLik</code>, <code>loocv</code>, <code>model.frame</code>, <code>model.matrix</code>,
<code>plot</code>, <code>predict</code>, <code>print</code>, <code>pseudoR2</code>, <code>summary</code>,
<code>terms</code>, <code>tidy</code>, <code>update</code>, <code>varcomp</code>, and <code>vcov</code>. If
<code>spcov_type</code> or <code>spcov_initial</code> are length greater than one, the
list has class <code>spautor_list</code> and each element in the list has class
<code>spautor</code>. <code>glances</code> can be used to summarize <code>spautor_list</code>
objects, and the aforementioned <code>spautor</code> generics can be used on each
individual list element (model fit).
</p>


<h3>Note</h3>

<p>This function does not perform any internal scaling. If optimization is not
stable due to large extremely large variances, scale relevant variables
so they have variance 1 before optimization.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- spautor(log_trend ~ 1, data = seal, spcov_type = "car")
summary(spmod)
</code></pre>

<hr>
<h2 id='spautorRF'>Fit random forest spatial residual models</h2><span id='topic+spautorRF'></span>

<h3>Description</h3>

<p>Fit random forest residual spatial linear models
for areal data (i.e., spatial autoregressive models) using
random forest to fit the mean and a spatial linear model to fit the residuals.
The spatial linear model fit to the residuals can incorporate
a variety of estimation methods, allowing for random effects,
partition factors, and row standardization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spautorRF(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spautorRF_+3A_formula">formula</code></td>
<td>
<p>A two-sided linear formula describing the fixed effect structure
of the model, with the response to the left of the <code>~</code> operator and
the terms on the right, separated by <code>+</code> operators.</p>
</td></tr>
<tr><td><code id="spautorRF_+3A_data">data</code></td>
<td>
<p>A data frame or <code>sf</code> object object that contains
the variables in <code>fixed</code>, <code>random</code>, and <code>partition_factor</code>
as well as geographical information. If an <code>sf</code> object is
provided with <code>POINT</code> geometries, the x-coordinates and y-coordinates
are used directly. If an <code>sf</code> object is
provided with <code>POLYGON</code> geometries, the x-coordinates and y-coordinates
are taken as the centroids of each polygon.</p>
</td></tr>
<tr><td><code id="spautorRF_+3A_...">...</code></td>
<td>
<p>Additional named arguments to <code><a href="ranger.html#topic+ranger">ranger::ranger()</a></code> or <code><a href="#topic+spautor">spautor()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The random forest residual spatial linear model is described by
Fox et al. (2020). A random forest model is fit to the mean portion of the
model specified by <code>formula</code> using <code><a href="ranger.html#topic+ranger">ranger::ranger()</a></code>. Residuals
are computed and used as the response variable in an intercept-only spatial
linear model fit using <code><a href="#topic+spautor">spautor()</a></code>. This model object is intended for use with
<code>predict()</code> to perform prediction, also called random forest
regression Kriging.
</p>


<h3>Value</h3>

<p>A list with several elements to be used with <code>predict()</code>. These
elements include the function call (named <code>call</code>), the random forest object
fit to the mean (named <code>ranger</code>),
the spatial linear model object fit to the residuals
(named <code>spautor</code> or <code>spautor_list</code>), and an object can contain data for
locations at which to predict (called <code>newdata</code>). The <code>newdata</code>
object contains the set of
observations in <code>data</code> whose response variable is <code>NA</code>.
If <code>spcov_type</code> or <code>spcov_initial</code> (which are passed to <code><a href="#topic+spautor">spautor()</a></code>)
are length one, the list has class <code>spautorRF</code> and the spatial linear
model object fit to the residuals is called <code>spautor</code>, which has
class <code>spautor</code>. If
<code>spcov_type</code> or <code>spcov_initial</code> are length greater than one, the
list has class <code>spautorRF_list</code> and the spatial linear model object
fit to the residuals is called <code>spautor_list</code>, which has class <code>spautor_list</code>.
and contains several objects, each with class <code>spautor</code>.
</p>


<h3>References</h3>

<p>Fox, E.W., Ver Hoef, J. M., &amp; Olsen, A. R. (2020). Comparing spatial
regression to random forests for large environmental data sets.
<em>PloS one</em>, 15(3), e0229509.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
seal$var &lt;- rnorm(NROW(seal)) # add noise variable
sprfmod &lt;- spautorRF(log_trend ~ var, data = seal, spcov_type = "car")
predict(sprfmod)

</code></pre>

<hr>
<h2 id='spcov_initial'>Create a spatial covariance parameter initial object</h2><span id='topic+spcov_initial'></span>

<h3>Description</h3>

<p>Create a spatial covariance parameter initial object that specifies
initial and/or known values to use while estimating spatial covariance parameters
with <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spcov_initial(spcov_type, de, ie, range, extra, rotate, scale, known)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spcov_initial_+3A_spcov_type">spcov_type</code></td>
<td>
<p>The spatial covariance function type. Available options include
<code>"exponential"</code>, <code>"spherical"</code>, <code>"gaussian"</code>,
<code>"triangular"</code>, <code>"circular"</code>, <code>"cubic"</code>,
<code>"pentaspherical"</code>, <code>"cosine"</code>, <code>"wave"</code>,
<code>"jbessel"</code>, <code>"gravity"</code>, <code>"rquad"</code>,
<code>"magnetic"</code>, <code>"matern"</code>, <code>"cauchy"</code>, <code>"pexponential"</code>,
<code>"car"</code>, <code>"sar"</code>, and <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="spcov_initial_+3A_de">de</code></td>
<td>
<p>The spatially dependent (correlated) random error variance. Commonly referred to as
a partial sill.</p>
</td></tr>
<tr><td><code id="spcov_initial_+3A_ie">ie</code></td>
<td>
<p>The spatially independent (uncorrelated) random error variance. Commonly referred to as
a nugget.</p>
</td></tr>
<tr><td><code id="spcov_initial_+3A_range">range</code></td>
<td>
<p>The correlation parameter.</p>
</td></tr>
<tr><td><code id="spcov_initial_+3A_extra">extra</code></td>
<td>
<p>An extra covariance parameter used when <code>spcov_type</code> is
<code>"matern"</code>, <code>"cauchy"</code>, <code>"pexponential"</code>, <code>"car"</code>, or
<code>"sar"</code>.</p>
</td></tr>
<tr><td><code id="spcov_initial_+3A_rotate">rotate</code></td>
<td>
<p>Anisotropy rotation parameter (from 0 to <code class="reqn">\pi</code> radians).
Not used if <code>spcov_type</code> is <code>"car"</code> or <code>"sar"</code>.</p>
</td></tr>
<tr><td><code id="spcov_initial_+3A_scale">scale</code></td>
<td>
<p>Anisotropy scale parameter (from 0 to 1).
Not used if <code>spcov_type</code> is <code>"car"</code> or <code>"sar"</code>.</p>
</td></tr>
<tr><td><code id="spcov_initial_+3A_known">known</code></td>
<td>
<p>A character vector indicating which spatial covariance parameters are to be
assumed known. The value <code>"given"</code> is shorthand for assuming all
spatial covariance parameters given to <code>spcov_initial()</code> are assumed known.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>spcov_initial</code> list is later passed to <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>.
<code>NA</code> values can be given for <code>ie</code>, <code>rotate</code>, and <code>scale</code>, which lets
these functions find initial values for parameters that are sometimes
otherwise assumed known (e.g., <code>rotate</code> and <code>scale</code> with <code><a href="#topic+splm">splm()</a></code> and <code><a href="#topic+spglm">spglm()</a></code>
and <code>ie</code> with <code><a href="#topic+spautor">spautor()</a></code> and <code><a href="#topic+spgautor">spgautor()</a></code>).
The spatial covariance functions can be generally expressed as
<code class="reqn">de * R + ie * I</code>, where <code class="reqn">de</code> is <code>de</code> above, <code class="reqn">R</code>
is a matrix that controls the spatial dependence structure among observations,
<code class="reqn">h</code>, <code class="reqn">ie</code> is <code>ie</code> above, and <code class="reqn">I</code> is and identity matrix.
Note that <code class="reqn">de</code> and <code class="reqn">ie</code> must be non-negative while <code class="reqn">range</code>
must be positive, except when <code>spcov_type</code> is <code>car</code> or <code>sar</code>,
in which case <code class="reqn">range</code> must be between the reciprocal of the maximum
eigenvalue of <code>W</code> and the reciprocal of the minimum eigenvalue of
<code>W</code>. Parametric forms for <code class="reqn">R</code> are given below, where <code class="reqn">\eta = h / range</code>:
</p>

<ul>
<li><p> exponential: <code class="reqn">exp(- \eta )</code>
</p>
</li>
<li><p> spherical: <code class="reqn">(1 - 1.5\eta + 0.5\eta^3) * I(h &lt;= range)</code>
</p>
</li>
<li><p> gaussian: <code class="reqn">exp(- \eta^2 )</code>
</p>
</li>
<li><p> triangular: <code class="reqn">(1 - \eta) * I(h &lt;= range)</code>
</p>
</li>
<li><p> circular: <code class="reqn">(1 - (2 / \pi) * (m * sqrt(1 - m^2) + sin^{-1}(m))) * I(h &lt;= range), m = min(\eta, 1)</code>
</p>
</li>
<li><p> cubic: <code class="reqn">(1 - 7\eta^2 + 8.75\eta^3 - 3.5\eta^5 + 0.75\eta^7) * I(h &lt;= range)</code>
</p>
</li>
<li><p> pentaspherical: <code class="reqn">(1 - 1.875\eta + 1.25\eta^3 - 0.375\eta^5) * I(h &lt;= range)</code>
</p>
</li>
<li><p> cosine: <code class="reqn">cos(\eta)</code>
</p>
</li>
<li><p> wave: <code class="reqn">sin(\eta) / \eta * I(h &gt; 0) + I(h = 0)</code>
</p>
</li>
<li><p> jbessel: <code class="reqn">Bj(h * range)</code>, Bj is Bessel-J function
</p>
</li>
<li><p> gravity: <code class="reqn">(1 + \eta^2)^{-0.5}</code>
</p>
</li>
<li><p> rquad: <code class="reqn">(1 + \eta^2)^{-1}</code>
</p>
</li>
<li><p> magnetic: <code class="reqn">(1 + \eta^2)^{-1.5}</code>
</p>
</li>
<li><p> matern: <code class="reqn">2^{1 - extra}/ \Gamma(extra) * \alpha^{extra} * Bk(\alpha, extra)</code>, <code class="reqn">\alpha = (2extra * \eta)^{0.5}</code>, Bk is Bessel-K function wit  order <code class="reqn">1/5 \le extra \le 5</code>
</p>
</li>
<li><p> cauchy: <code class="reqn">(1 + \eta^2)^{-extra}</code>, <code class="reqn">extra &gt; 0</code>
</p>
</li>
<li><p> pexponential: <code class="reqn">exp(h^{extra}/range)</code>, <code class="reqn">0 &lt; extra \le 2</code>
</p>
</li>
<li><p> car: <code class="reqn">(I - range * W)^{-1} * M</code>, weights matrix <code class="reqn">W</code>,
symmetry condition matrix <code class="reqn">M</code>, observations with no neighbors
are given a unique variance
parameter called <code class="reqn">extra</code>, <code class="reqn">extra \ge 0</code>.
</p>
</li>
<li><p> sar: <code class="reqn">[(I - range * W)(I - range * W)^T]^{-1}</code>,
weights matrix <code class="reqn">W</code>, <code class="reqn">^T</code> indicates matrix transpose,
observations with no neighbors are given a unique variance
parameter called <code class="reqn">extra</code>, <code class="reqn">extra \ge 0</code>.
</p>
</li>
<li><p> none: <code class="reqn">0</code>
</p>
</li></ul>

<p>All spatial covariance functions are valid in one spatial dimension. All
spatial covariance functions except <code>triangular</code> and <code>cosine</code> are
valid in two dimensions.
</p>
<p>When the spatial covariance function is <code>car</code> or <code>sar</code>, <code>extra</code>
represents the variance parameter for the observations in <code>W</code> without
at least one neighbor (other than itself) &ndash; these are called unconnected
observations. <code>extra</code> is only used if there is at least one unconnected
observation.
</p>


<h3>Value</h3>

<p>A list with two elements: <code>initial</code> and <code>is_known</code>.
<code>initial</code> is a named numeric vector indicating the spatial covariance parameters
with specified initial and/or known values. <code>is_known</code> is a named
numeric vector indicating whether the spatial covariance parameters in
<code>initial</code> are known or not. The class of the list
matches the value given to the <code>spcov_type</code> argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># known de value 1 and initial range value 0.4
spcov_initial("exponential", de = 1, range = 0.4, known = c("de"))
# known ie value 0 and known range value 1
spcov_initial("gaussian", ie = 0, range = 1, known = c("given"))
# ie given NA
spcov_initial("car", ie = NA)
</code></pre>

<hr>
<h2 id='spcov_params'>Create a spatial covariance parameter object</h2><span id='topic+spcov_params'></span>

<h3>Description</h3>

<p>Create a spatial covariance parameter object for use with other
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spcov_params(spcov_type, de, ie, range, extra, rotate = 0, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spcov_params_+3A_spcov_type">spcov_type</code></td>
<td>
<p>The spatial covariance function type. Available options include
<code>"exponential"</code>, <code>"spherical"</code>, <code>"gaussian"</code>,
<code>"triangular"</code>, <code>"circular"</code>, <code>"cubic"</code>,
<code>"pentaspherical"</code>, <code>"cosine"</code>, <code>"wave"</code>,
<code>"jbessel"</code>, <code>"gravity"</code>, <code>"rquad"</code>,
<code>"magnetic"</code>, <code>"matern"</code>, <code>"cauchy"</code>, <code>"pexponential"</code>,
<code>"car"</code>, <code>"sar"</code>, and <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="spcov_params_+3A_de">de</code></td>
<td>
<p>The spatially dependent (correlated) random error variance. Commonly referred to as
a partial sill.</p>
</td></tr>
<tr><td><code id="spcov_params_+3A_ie">ie</code></td>
<td>
<p>The spatially independent (uncorrelated) random error variance. Commonly referred to as
a nugget.</p>
</td></tr>
<tr><td><code id="spcov_params_+3A_range">range</code></td>
<td>
<p>The correlation parameter.</p>
</td></tr>
<tr><td><code id="spcov_params_+3A_extra">extra</code></td>
<td>
<p>An extra covariance parameter used when <code>spcov_type</code> is
<code>"matern"</code>, <code>"cauchy"</code>, <code>"pexponential"</code>, <code>"car"</code>, or
<code>"sar"</code>.</p>
</td></tr>
<tr><td><code id="spcov_params_+3A_rotate">rotate</code></td>
<td>
<p>Anisotropy rotation parameter (from 0 to <code class="reqn">\pi</code> radians).
A value of 0 (the default) implies no rotation.
Not used if <code>spcov_type</code> is <code>"car"</code> or <code>"sar"</code>.</p>
</td></tr>
<tr><td><code id="spcov_params_+3A_scale">scale</code></td>
<td>
<p>Anisotropy scale parameter (from 0 to 1).
A value of 1 (the default) implies no scaling.
Not used if <code>spcov_type</code> is <code>"car"</code> or <code>"sar"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generally, all arguments to <code>spcov_params</code> must be specified, though
default arguments are often chosen based on <code>spcov_type</code>.
When <code>spcov_type</code> is <code>car</code> or
<code>sar</code>, <code>ie</code> is assumed to be 0 unless specified otherwise.
For full parameterizations of all spatial covariance
functions, see <code><a href="#topic+spcov_initial">spcov_initial()</a></code>.
</p>


<h3>Value</h3>

<p>A named numeric vector of spatial covariance parameters with class <code>spcov_type</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spcov_params("exponential", de = 1, ie = 1, range = 1)
</code></pre>

<hr>
<h2 id='spgautor'>Fit spatial generalized autoregressive models</h2><span id='topic+spgautor'></span>

<h3>Description</h3>

<p>Fit spatial generalized linear models for areal data
(i.e., spatial generalized autoregressive models)
using a variety of estimation methods, allowing for random effects,
partition factors, and row standardization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spgautor(
  formula,
  family,
  data,
  spcov_type,
  spcov_initial,
  dispersion_initial,
  estmethod = "reml",
  random,
  randcov_initial,
  partition_factor,
  W,
  row_st = TRUE,
  M,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spgautor_+3A_formula">formula</code></td>
<td>
<p>A two-sided linear formula describing the fixed effect structure
of the model, with the response to the left of the <code>~</code> operator and
the terms, separated by <code>+</code> operators, on the right.</p>
</td></tr>
<tr><td><code id="spgautor_+3A_family">family</code></td>
<td>
<p>The generalized linear model family describing the distribution
of the response variable to be used. Available options
<code>"poisson"</code>, <code>"nbinomial"</code>, <code>"binomial"</code>,
<code>"beta"</code>, <code>"Gamma"</code>, and <code>"inverse.gaussian"</code>.
Can be quoted or unquoted. Note that the <code>family</code> argument
only takes a single value, rather than the list structure used by <a href="stats.html#topic+glm">stats::glm</a>.
See Details for more.</p>
</td></tr>
<tr><td><code id="spgautor_+3A_data">data</code></td>
<td>
<p>A data frame or <code>sf</code> object that contains
the variables in <code>fixed</code>, <code>random</code>, and <code>partition_factor</code>,
as well as potentially geographical information.</p>
</td></tr>
<tr><td><code id="spgautor_+3A_spcov_type">spcov_type</code></td>
<td>
<p>The spatial covariance type. Available options include
<code>"car"</code> and <code>"sar"</code>. Parameterizations of each spatial covariance type are
available in Details. When <code>spcov_type</code> is specified, relevant spatial
covariance parameters are assumed unknown, requiring estimation.
<code>spcov_type</code> is not required (and is
ignored) if <code>spcov_initial</code> is provided.  Multiple values can be
provided in a character vector. Then <code>spgautor()</code> is called iteratively
for each element and a list is returned for each model fit.
The default for <code>spcov_type</code> is <code>"car"</code>.</p>
</td></tr>
<tr><td><code id="spgautor_+3A_spcov_initial">spcov_initial</code></td>
<td>
<p>An object from <code><a href="#topic+spcov_initial">spcov_initial()</a></code> specifying initial and/or
known values for the spatial covariance parameters.
Not required if <code>spcov_type</code> is provided. Multiple <code><a href="#topic+spcov_initial">spcov_initial()</a></code>
objects can be provided in a list. Then <code>spgautor()</code> is called iteratively
for each element and a list is returned for each model fit.</p>
</td></tr>
<tr><td><code id="spgautor_+3A_dispersion_initial">dispersion_initial</code></td>
<td>
<p>An object from <code><a href="#topic+dispersion_initial">dispersion_initial()</a></code> specifying
initial and/or known values for the dispersion parameter for the
<code>"nbinomial"</code>, <code>"beta"</code>, <code>"Gamma"</code>, and <code>"inverse.gaussian"</code> families.
<code>family</code> is ignored if <code>dispersion_initial</code> is provided.</p>
</td></tr>
<tr><td><code id="spgautor_+3A_estmethod">estmethod</code></td>
<td>
<p>The estimation method. Available options include
<code>"reml"</code> for restricted maximum likelihood and <code>"ml"</code> for maximum
likelihood The default is
<code>"reml"</code>.</p>
</td></tr>
<tr><td><code id="spgautor_+3A_random">random</code></td>
<td>
<p>A one-sided linear formula describing the random effect structure
of the model. Terms are specified to the right of the <code>~ operator</code>.
Each term has the structure <code>x1 + ... + xn | g1/.../gm</code>, where <code>x1 + ... + xn</code>
specifies the model for the random effects and <code>g1/.../gm</code> is the grouping
structure. Separate terms are separated by <code>+</code> and must generally
be wrapped in parentheses. Random intercepts are added to each model
implicitly when at least  one other variable is defined.
If a random intercept is not desired, this must be explicitly
defined (e.g., <code>x1 + ... + xn - 1 | g1/.../gm</code>). If only a random intercept
is desired for a grouping structure, the random intercept must be specified
as <code>1 | g1/.../gm</code>. Note that <code>g1/.../gm</code> is shorthand for <code>(1 | g1/.../gm)</code>.
If only random intercepts are desired and the shorthand notation is used,
parentheses can be omitted.</p>
</td></tr>
<tr><td><code id="spgautor_+3A_randcov_initial">randcov_initial</code></td>
<td>
<p>An optional object specifying initial and/or
known values for the random effect variances.</p>
</td></tr>
<tr><td><code id="spgautor_+3A_partition_factor">partition_factor</code></td>
<td>
<p>A one-sided linear formula with a single term
specifying the partition factor.  The partition factor assumes observations
from different levels of the partition factor are uncorrelated.</p>
</td></tr>
<tr><td><code id="spgautor_+3A_w">W</code></td>
<td>
<p>Weight matrix specifying the neighboring structure used.
Not required if <code>data</code> is an <code>sf</code> polygon object,
as <code>W</code> is calculated internally using queen contiguity. If calculated internally,
<code>W</code> is computed using <code>sf::st_intersects()</code>.</p>
</td></tr>
<tr><td><code id="spgautor_+3A_row_st">row_st</code></td>
<td>
<p>A logical indicating whether row standardization be performed on
<code>W</code>. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="spgautor_+3A_m">M</code></td>
<td>
<p><code>M</code> matrix satisfying the car symmetry condition. The car
symmetry condition states that <code class="reqn">(I - range * W)^{-1}M</code> is symmetric, where
<code class="reqn">I</code> is an identity matrix, <code class="reqn">range</code> is a constant that controls the
spatial dependence, <code>W</code> is the weights matrix,
and <code class="reqn">^{-1}</code> represents the inverse operator.
<code>M</code> is required for car models
when <code>W</code> is provided and <code>row_st</code> is <code>FALSE</code>.  When <code>M</code>,
is required, the default is the identity matrix. <code>M</code> must be diagonal
or given as a vector or one-column matrix assumed to be the diagonal.</p>
</td></tr>
<tr><td><code id="spgautor_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="stats.html#topic+optim">stats::optim()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spatial generalized linear model for areal data
(i.e., spatial generalized autoregressive model) can be written as
<code class="reqn">g(\mu) = \eta = X \beta + \tau + \epsilon</code>, where <code class="reqn">\mu</code> is the expectation
of the response (<code class="reqn">y</code>) given the random errors, <code class="reqn">g(.)</code> is called
a link function which links together the <code class="reqn">\mu</code> and <code class="reqn">\eta</code>,
<code class="reqn">X</code> is the fixed effects design
matrix, <code class="reqn">\beta</code> are the fixed effects, <code class="reqn">\tau</code> is random error that is
spatially dependent, and <code class="reqn">\epsilon</code> is random error that is spatially
independent.
</p>
<p>There are six generalized linear model
families available: <code>poisson</code> assumes <code class="reqn">y</code> is a Poisson random variable
<code>nbinomial</code> assumes <code class="reqn">y</code> is a negative binomial random
variable, <code>binomial</code> assumes <code class="reqn">y</code> is a binomial random variable,
<code>beta</code> assumes <code class="reqn">y</code> is a beta random variable,
<code>Gamma</code> assumes <code class="reqn">y</code> is a gamma random
variable, and <code>inverse.gaussian</code> assumes <code class="reqn">y</code> is an inverse Gaussian
random variable.
</p>
<p>The supports for <code class="reqn">y</code> for each family are given below:
</p>

<ul>
<li><p> family: support of <code class="reqn">y</code>
</p>
</li>
<li><p> poisson: <code class="reqn">0 \le y</code>; <code class="reqn">y</code> an integer
</p>
</li>
<li><p> nbinomial: <code class="reqn">0 \le y</code>; <code class="reqn">y</code> an integer
</p>
</li>
<li><p> binomial: <code class="reqn">0 \le y</code>; <code class="reqn">y</code> an integer
</p>
</li>
<li><p> beta: <code class="reqn">0 &lt; y &lt; 1</code>
</p>
</li>
<li><p> Gamma: <code class="reqn">0 &lt; y</code>
</p>
</li>
<li><p> inverse.gaussian: <code class="reqn">0 &lt; y</code>
</p>
</li></ul>

<p>The generalized linear model families
and the parameterizations of their link functions are given
below:
</p>

<ul>
<li><p> family: link function
</p>
</li>
<li><p> poisson: <code class="reqn">g(\mu) = log(\eta)</code> (log link)
</p>
</li>
<li><p> nbinomial: <code class="reqn">g(\mu) = log(\eta)</code> (log link)
</p>
</li>
<li><p> binomial: <code class="reqn">g(\mu) = log(\eta / (1 - \eta))</code> (logit link)
</p>
</li>
<li><p> beta: <code class="reqn">g(\mu) = log(\eta / (1 - \eta))</code> (logit link)
</p>
</li>
<li><p> Gamma: <code class="reqn">g(\mu) = log(\eta)</code> (log link)
</p>
</li>
<li><p> inverse.gaussian: <code class="reqn">g(\mu) = log(\eta)</code> (log link)
</p>
</li></ul>

<p>The variance function of an individual <code class="reqn">y</code> (given <code class="reqn">\mu</code>)
for each generalized linear model family is given below:
</p>

<ul>
<li><p> family: <code class="reqn">Var(y)</code>
</p>
</li>
<li><p> poisson: <code class="reqn">\mu \phi</code>
</p>
</li>
<li><p> nbinomial: <code class="reqn">\mu + \mu^2 / \phi</code>
</p>
</li>
<li><p> binomial: <code class="reqn">n \mu (1 - \mu) \phi</code>
</p>
</li>
<li><p> beta: <code class="reqn">\mu (1 - \mu) / (1 + \phi)</code>
</p>
</li>
<li><p> Gamma: <code class="reqn">\mu^2 / \phi</code>
</p>
</li>
<li><p> inverse.gaussian: <code class="reqn">\mu^2 / \phi</code>
</p>
</li></ul>

<p>The parameter <code class="reqn">\phi</code> is a dispersion parameter that influences <code class="reqn">Var(y)</code>.
For the <code>poisson</code> and <code>binomial</code> families, <code class="reqn">\phi</code> is always
one. Note that this inverse Gaussian parameterization is different than a
standard inverse Gaussian parameterization, which has variance <code class="reqn">\mu^3 / \lambda</code>.
Setting <code class="reqn">\phi = \lambda / \mu</code> yields our parameterization, which is
preferred for computational stability. Also note that the dispersion parameter
is often defined in the literature as <code class="reqn">V(\mu) \phi</code>, where <code class="reqn">V(\mu)</code> is the variance
function of the mean. We do not use this parameterization, which is important
to recognize while interpreting dispersion parameter estimates.
For more on generalized linear model constructions, see McCullagh and
Nelder (1989).
</p>
<p>Together, <code class="reqn">\tau</code> and <code class="reqn">\epsilon</code> are modeled using
a spatial covariance function, expressed as
<code class="reqn">de * R + ie * I</code>, where <code class="reqn">de</code> is the dependent error variance, <code class="reqn">R</code>
is a matrix that controls the spatial dependence structure among observations,
<code class="reqn">ie</code> is the independent error variance, and <code class="reqn">I</code> is
an identity matrix. Note that <code class="reqn">de</code> and <code class="reqn">ie</code> must be non-negative while <code class="reqn">range</code>
must be between the reciprocal of the maximum
eigenvalue of <code>W</code> and the reciprocal of the minimum eigenvalue of
<code>W</code>. Recall that <code class="reqn">\tau</code> and <code class="reqn">\epsilon</code> are modeled on the link scale,
not the inverse link (response) scale. Random effects are also modeled on the link scale.
</p>
<p><code>spcov_type</code> Details: Parametric forms for <code class="reqn">R</code> are given below:
</p>

<ul>
<li><p> car: <code class="reqn">(I - range * W)^{-1}M</code>, weights matrix <code class="reqn">W</code>,
symmetry condition matrix <code class="reqn">M</code>
</p>
</li>
<li><p> sar: <code class="reqn">[(I - range * W)(I - range * W)^T]^{-1}</code>,
weights matrix <code class="reqn">W</code>, <code class="reqn">^T</code> indicates matrix transpose
</p>
</li></ul>

<p>If there are observations with no neighbors, they are given a unique variance
parameter called <code>extra</code>, which must be non-negative.
</p>
<p><code>estmethod</code> Details: The various estimation methods are
</p>

<ul>
<li> <p><code>reml</code>: Maximize the restricted log-likelihood.
</p>
</li>
<li> <p><code>ml</code>: Maximize the log-likelihood.
</p>
</li></ul>

<p>Note that the likelihood being optimized is obtained using the Laplace approximation.
</p>
<p>By default, all spatial covariance parameters except <code>ie</code>
as well as all random effect variance parameters
are assumed unknown, requiring estimation. <code>ie</code> is assumed zero and known by default
(in contrast to models fit using <code><a href="#topic+spglm">spglm()</a></code>, where <code>ie</code> is assumed
unknown by default). To change this default behavior, specify <code>spcov_initial</code>
(an <code>NA</code> value for <code>ie</code> in <code>spcov_initial</code> to assume
<code>ie</code> is unknown, requiring estimation).
</p>
<p><code>random</code> Details: If random effects are used, the model
can be written as <code class="reqn">y = X \beta + Z1u1 + ... Zjuj + \tau + \epsilon</code>,
where each Z is a random effects design matrix and each u is a random effect.
</p>
<p><code>partition_factor</code> Details:  The partition factor can be represented in matrix form as <code class="reqn">P</code>, where
elements of <code class="reqn">P</code> equal one for observations in the same level of the partition
factor and zero otherwise. The covariance matrix involving only the
spatial and random effects components is then multiplied element-wise
(Hadmard product) by <code class="reqn">P</code>, yielding the final covariance matrix.
</p>
<p>Observations with <code>NA</code> response values are removed for model
fitting, but their values can be predicted afterwards by running
<code>predict(object)</code>. This is the only way to perform prediction for
<code>spgautor()</code> models (i.e., the prediction locations must be known prior
to estimation).
</p>


<h3>Value</h3>

<p>A list with many elements that store information about
the fitted model object. If <code>spcov_type</code> or <code>spcov_initial</code> are
length one, the list has class <code>spgautor</code>. Many generic functions that
summarize model fit are available for <code>spgautor</code> objects, including
<code>AIC</code>, <code>AICc</code>, <code>anova</code>, <code>augment</code>, <code>coef</code>,
<code>cooks.distance</code>, <code>covmatrix</code>, <code>deviance</code>, <code>fitted</code>, <code>formula</code>,
<code>glance</code>, <code>glances</code>, <code>hatvalues</code>, <code>influence</code>,
<code>labels</code>, <code>logLik</code>, <code>loocv</code>, <code>model.frame</code>, <code>model.matrix</code>,
<code>plot</code>, <code>predict</code>, <code>print</code>, <code>pseudoR2</code>, <code>summary</code>,
<code>terms</code>, <code>tidy</code>, <code>update</code>, <code>varcomp</code>, and <code>vcov</code>. If
<code>spcov_type</code> or <code>spcov_initial</code> are length greater than one, the
list has class <code>spgautor_list</code> and each element in the list has class
<code>spgautor</code>. <code>glances</code> can be used to summarize <code>spgautor_list</code>
objects, and the aforementioned <code>spgautor</code> generics can be used on each
individual list element (model fit).
</p>


<h3>Note</h3>

<p>This function does not perform any internal scaling. If optimization is not
stable due to large extremely large variances, scale relevant variables
so they have variance 1 before optimization.
</p>


<h3>References</h3>

<p>McCullagh P. and Nelder, J. A. (1989) <em>Generalized Linear Models</em>. London: Chapman and Hall.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spgmod &lt;- spgautor(I(log_trend^2) ~ 1, family = "Gamma", data = seal, spcov_type = "car")
summary(spgmod)
</code></pre>

<hr>
<h2 id='spglm'>Fit spatial generalized linear models</h2><span id='topic+spglm'></span>

<h3>Description</h3>

<p>Fit spatial generalized linear models for point-referenced data (i.e.,
generalized geostatistical models) using
a variety of estimation methods, allowing for random effects,
anisotropy, partition factors, and big data methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spglm(
  formula,
  family,
  data,
  spcov_type,
  xcoord,
  ycoord,
  spcov_initial,
  dispersion_initial,
  estmethod = "reml",
  anisotropy = FALSE,
  random,
  randcov_initial,
  partition_factor,
  local,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spglm_+3A_formula">formula</code></td>
<td>
<p>A two-sided linear formula describing the fixed effect structure
of the model, with the response to the left of the <code>~</code> operator and
the terms on the right, separated by <code>+</code> operators.</p>
</td></tr>
<tr><td><code id="spglm_+3A_family">family</code></td>
<td>
<p>The generalized linear model family describing the distribution
of the response variable to be used. Available options
<code>"poisson"</code>, <code>"nbinomial"</code>, <code>"binomial"</code>,
<code>"beta"</code>, <code>"Gamma"</code>, and <code>"inverse.gaussian"</code>.
Can be quoted or unquoted. Note that the <code>family</code> argument
only takes a single value, rather than the list structure used by <a href="stats.html#topic+glm">stats::glm</a>.
See Details for more.</p>
</td></tr>
<tr><td><code id="spglm_+3A_data">data</code></td>
<td>
<p>A data frame or <code>sf</code> object object that contains
the variables in <code>fixed</code>, <code>random</code>, and <code>partition_factor</code>
as well as geographical information. If an <code>sf</code> object is
provided with <code>POINT</code> geometries, the x-coordinates and y-coordinates
are used directly. If an <code>sf</code> object is
provided with <code>POLYGON</code> geometries, the x-coordinates and y-coordinates
are taken as the centroids of each polygon.</p>
</td></tr>
<tr><td><code id="spglm_+3A_spcov_type">spcov_type</code></td>
<td>
<p>The spatial covariance type. Available options include
<code>"exponential"</code>, <code>"spherical"</code>, <code>"gaussian"</code>,
<code>"triangular"</code>, <code>"circular"</code>, <code>"cubic"</code>,
<code>"pentaspherical"</code>, <code>"cosine"</code>, <code>"wave"</code>,
<code>"jbessel"</code>, <code>"gravity"</code>, <code>"rquad"</code>,
<code>"magnetic"</code>, <code>"matern"</code>, <code>"cauchy"</code>, <code>"pexponential"</code>,
and <code>"none"</code>. Parameterizations of each spatial covariance type are
available in Details. Multiple spatial covariance types can be provided as
a character vector, and then <code>spglm()</code> is called iteratively for each
element and a list is returned for each model fit. The default for
<code>spcov_type</code> is <code>"exponential"</code>. When <code>spcov_type</code> is
specified, all unknown spatial covariance parameters are estimated.
<code>spcov_type</code> is ignored if <code>spcov_initial</code> is provided.</p>
</td></tr>
<tr><td><code id="spglm_+3A_xcoord">xcoord</code></td>
<td>
<p>The name of the column in <code>data</code> representing the x-coordinate.
Can be quoted or unquoted. Not required if <code>data</code> is an <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="spglm_+3A_ycoord">ycoord</code></td>
<td>
<p>The name of the column in <code>data</code> representing the y-coordinate.
Can be quoted or unquoted. Not required if <code>data</code> is an <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="spglm_+3A_spcov_initial">spcov_initial</code></td>
<td>
<p>An object from <code><a href="#topic+spcov_initial">spcov_initial()</a></code> specifying initial and/or
known values for the spatial covariance parameters. Multiple <code><a href="#topic+spcov_initial">spcov_initial()</a></code>
objects can be provided in a list. Then <code>spglm()</code> is called iteratively
for each element and a list is returned for each model fit.</p>
</td></tr>
<tr><td><code id="spglm_+3A_dispersion_initial">dispersion_initial</code></td>
<td>
<p>An object from <code><a href="#topic+dispersion_initial">dispersion_initial()</a></code> specifying
initial and/or known values for the dispersion parameter for the
<code>"nbinomial"</code>, <code>"beta"</code>, <code>"Gamma"</code>, and <code>"inverse.gaussian"</code> families.
<code>family</code> is ignored if <code>dispersion_initial</code> is provided.</p>
</td></tr>
<tr><td><code id="spglm_+3A_estmethod">estmethod</code></td>
<td>
<p>The estimation method. Available options include
<code>"reml"</code> for restricted maximum likelihood and <code>"ml"</code> for maximum
likelihood. The default is
<code>"reml"</code>.</p>
</td></tr>
<tr><td><code id="spglm_+3A_anisotropy">anisotropy</code></td>
<td>
<p>A logical indicating whether (geometric) anisotropy should
be modeled. Not required if <code>spcov_initial</code> is provided with 1) <code>rotate</code>
assumed unknown or assumed known and non-zero or 2) <code>scale</code> assumed unknown
or assumed known and less than one. When <code>anisotropy</code> is <code>TRUE</code>,
computational times can significantly increase. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="spglm_+3A_random">random</code></td>
<td>
<p>A one-sided linear formula describing the random effect structure
of the model. Terms are specified to the right of the <code>~ operator</code>.
Each term has the structure <code>x1 + ... + xn | g1/.../gm</code>, where <code>x1 + ... + xn</code>
specifies the model for the random effects and <code>g1/.../gm</code> is the grouping
structure. Separate terms are separated by <code>+</code> and must generally
be wrapped in parentheses. Random intercepts are added to each model
implicitly when at least  one other variable is defined.
If a random intercept is not desired, this must be explicitly
defined (e.g., <code>x1 + ... + xn - 1 | g1/.../gm</code>). If only a random intercept
is desired for a grouping structure, the random intercept must be specified
as <code>1 | g1/.../gm</code>. Note that <code>g1/.../gm</code> is shorthand for <code>(1 | g1/.../gm)</code>.
If only random intercepts are desired and the shorthand notation is used,
parentheses can be omitted.</p>
</td></tr>
<tr><td><code id="spglm_+3A_randcov_initial">randcov_initial</code></td>
<td>
<p>An optional object specifying initial and/or
known values for the random effect variances.</p>
</td></tr>
<tr><td><code id="spglm_+3A_partition_factor">partition_factor</code></td>
<td>
<p>A one-sided linear formula with a single term
specifying the partition factor.  The partition factor assumes observations
from different levels of the partition factor are uncorrelated.</p>
</td></tr>
<tr><td><code id="spglm_+3A_local">local</code></td>
<td>
<p>An optional logical or list controlling the big data approximation.
If omitted, <code>local</code> is set
to <code>TRUE</code> or <code>FALSE</code> based on the sample size (the number of
non-missing observations in <code>data</code>) &ndash; if the sample size exceeds 3,000,
<code>local</code> is set to <code>TRUE</code>. Otherwise it is set to <code>FALSE</code>.
If <code>FALSE</code>, no big data approximation is implemented.
If a list is provided, the following arguments detail the big
data approximation:
</p>

<ul>
<li> <p><code>index: </code>The group indexes. Observations in different
levels of <code>index</code> are assumed to be uncorrelated for the
purposes of estimation. If <code>index</code> is not provided, it is
determined by specifying <code>method</code> and either <code>size</code> or <code>groups</code>.
</p>
</li>
<li> <p><code>method</code>: The big data approximation method used to determine <code>index</code>. Ignored
if <code>index</code> is provided. If <code>method = "random"</code>,
observations are randomly assigned to <code>index</code> based on <code>size</code>.
If <code>method = "kmeans"</code>, observations assigned to <code>index</code>
based on k-means clustering on the coordinates with <code>groups</code> clusters. The default
is <code>"kmeans"</code>. Note that both methods have a random component, which
means that you may get different results from separate model fitting calls.
To ensure consistent results, specify <code>index</code> or set a seed via
<code>base::set.seed()</code>.
</p>
</li>
<li> <p><code>size</code>: The number of observations in each <code>index</code> group
when <code>method</code> is <code>"random"</code>. If the number of observations
is not divisible by <code>size</code>, some levels get <code>size - 1</code> observations.
The default is 100.
</p>
</li>
<li> <p><code>groups: </code>The number of <code>index</code> groups. If <code>method</code>
is <code>"random"</code>, <code>size</code> is <code class="reqn">ceiling(n / groups)</code>, where
<code class="reqn">n</code> is the sample size. Automatically determined if <code>size</code>
is specified. If <code>method</code> is <code>"kmeans"</code>, <code>groups</code>
is the number of clusters.
</p>
</li>
<li> <p><code>var_adjust: </code>The approach for adjusting the variance-covariance
matrix of the fixed effects. <code>"none"</code> for no adjustment, <code>"theoretical"</code>
for the theoretically-correct adjustment,
<code>"pooled"</code> for the pooled adjustment, and <code>"empirical"</code> for the
empirical adjustment. The default is <code>"theoretical"</code>.
</p>
</li>
<li> <p><code>parallel</code>: If <code>TRUE</code>, parallel processing via the
parallel package is automatically used. The default is <code>FALSE</code>.
</p>
</li>
<li> <p><code>ncores</code>: If <code>parallel = TRUE</code>, the number of cores to
parallelize over. The default is the number of available cores on your machine.
</p>
</li></ul>

<p>When <code>local</code> is a list, at least one list element must be provided to
initialize default arguments for the other list elements.
If <code>local</code> is <code>TRUE</code>, defaults for <code>local</code> are chosen such
that <code>local</code> is transformed into
<code>list(size = 100, method = "kmeans", var_adjust = "theoretical", parallel = FALSE)</code>.</p>
</td></tr>
<tr><td><code id="spglm_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="#topic+esv">esv()</a></code> or <code><a href="stats.html#topic+optim">stats::optim()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spatial generalized linear model for point-referenced data
(i.e., generalized geostatistical model) can be written as
<code class="reqn">g(\mu) = \eta = X \beta + \tau + \epsilon</code>, where <code class="reqn">\mu</code> is the expectation
of the response (<code class="reqn">y</code>) given the random errors, <code class="reqn">g(.)</code> is called
a link function which links together the <code class="reqn">\mu</code> and <code class="reqn">\eta</code>,
<code class="reqn">X</code> is the fixed effects design
matrix, <code class="reqn">\beta</code> are the fixed effects, <code class="reqn">\tau</code> is random error that is
spatially dependent, and <code class="reqn">\epsilon</code> is random error that is spatially
independent.
</p>
<p>There are six generalized linear model
families available: <code>poisson</code> assumes <code class="reqn">y</code> is a Poisson random variable
<code>nbinomial</code> assumes <code class="reqn">y</code> is a negative binomial random
variable, <code>binomial</code> assumes <code class="reqn">y</code> is a binomial random variable,
<code>beta</code> assumes <code class="reqn">y</code> is a beta random variable,
<code>Gamma</code> assumes <code class="reqn">y</code> is a gamma random
variable, and <code>inverse.gaussian</code> assumes <code class="reqn">y</code> is an inverse Gaussian
random variable.
</p>
<p>The supports for <code class="reqn">y</code> for each family are given below:
</p>

<ul>
<li><p> family: support of <code class="reqn">y</code>
</p>
</li>
<li><p> poisson: <code class="reqn">0 \le y</code>; <code class="reqn">y</code> an integer
</p>
</li>
<li><p> nbinomial: <code class="reqn">0 \le y</code>; <code class="reqn">y</code> an integer
</p>
</li>
<li><p> binomial: <code class="reqn">0 \le y</code>; <code class="reqn">y</code> an integer
</p>
</li>
<li><p> beta: <code class="reqn">0 &lt; y &lt; 1</code>
</p>
</li>
<li><p> Gamma: <code class="reqn">0 &lt; y</code>
</p>
</li>
<li><p> inverse.gaussian: <code class="reqn">0 &lt; y</code>
</p>
</li></ul>

<p>The generalized linear model families
and the parameterizations of their link functions are given
below:
</p>

<ul>
<li><p> family: link function
</p>
</li>
<li><p> poisson: <code class="reqn">g(\mu) = log(\eta)</code> (log link)
</p>
</li>
<li><p> nbinomial: <code class="reqn">g(\mu) = log(\eta)</code> (log link)
</p>
</li>
<li><p> binomial: <code class="reqn">g(\mu) = log(\eta / (1 - \eta))</code> (logit link)
</p>
</li>
<li><p> beta: <code class="reqn">g(\mu) = log(\eta / (1 - \eta))</code> (logit link)
</p>
</li>
<li><p> Gamma: <code class="reqn">g(\mu) = log(\eta)</code> (log link)
</p>
</li>
<li><p> inverse.gaussian: <code class="reqn">g(\mu) = log(\eta)</code> (log link)
</p>
</li></ul>

<p>The variance function of an individual <code class="reqn">y</code> (given <code class="reqn">\mu</code>)
for each generalized linear model family is given below:
</p>

<ul>
<li><p> family: <code class="reqn">Var(y)</code>
</p>
</li>
<li><p> poisson: <code class="reqn">\mu \phi</code>
</p>
</li>
<li><p> nbinomial: <code class="reqn">\mu + \mu^2 / \phi</code>
</p>
</li>
<li><p> binomial: <code class="reqn">n \mu (1 - \mu) \phi</code>
</p>
</li>
<li><p> beta: <code class="reqn">\mu (1 - \mu) / (1 + \phi)</code>
</p>
</li>
<li><p> Gamma: <code class="reqn">\mu^2 / \phi</code>
</p>
</li>
<li><p> inverse.gaussian: <code class="reqn">\mu^2 / \phi</code>
</p>
</li></ul>

<p>The parameter <code class="reqn">\phi</code> is a dispersion parameter that influences <code class="reqn">Var(y)</code>.
For the <code>poisson</code> and <code>binomial</code> families, <code class="reqn">\phi</code> is always
one. Note that this inverse Gaussian parameterization is different than a
standard inverse Gaussian parameterization, which has variance <code class="reqn">\mu^3 / \lambda</code>.
Setting <code class="reqn">\phi = \lambda / \mu</code> yields our parameterization, which is
preferred for computational stability. Also note that the dispersion parameter
is often defined in the literature as <code class="reqn">V(\mu) \phi</code>, where <code class="reqn">V(\mu)</code> is the variance
function of the mean. We do not use this parameterization, which is important
to recognize while interpreting dispersion estimates.
For more on generalized linear model constructions, see McCullagh and
Nelder (1989).
</p>
<p>Together, <code class="reqn">\tau</code> and <code class="reqn">\epsilon</code> are modeled using
a spatial covariance function, expressed as
<code class="reqn">de * R + ie * I</code>, where <code class="reqn">de</code> is the dependent error variance, <code class="reqn">R</code>
is a correlation matrix that controls the spatial dependence structure among observations,
<code class="reqn">ie</code> is the independent error variance, and <code class="reqn">I</code> is
an identity matrix. Recall that <code class="reqn">\tau</code> and <code class="reqn">\epsilon</code> are modeled on the link scale,
not the inverse link (response) scale. Random effects are also modeled on the link scale.
</p>
<p><code>spcov_type</code> Details: Parametric forms for <code class="reqn">R</code> are given below, where <code class="reqn">\eta = h / range</code>
for <code class="reqn">h</code> distance between observations:
</p>

<ul>
<li><p> exponential: <code class="reqn">exp(- \eta )</code>
</p>
</li>
<li><p> spherical: <code class="reqn">(1 - 1.5\eta + 0.5\eta^3) * I(h &lt;= range)</code>
</p>
</li>
<li><p> gaussian: <code class="reqn">exp(- \eta^2 )</code>
</p>
</li>
<li><p> triangular: <code class="reqn">(1 - \eta) * I(h &lt;= range)</code>
</p>
</li>
<li><p> circular: <code class="reqn">(1 - (2 / \pi) * (m * sqrt(1 - m^2) + sin^{-1}(m))) * I(h &lt;= range), m = min(\eta, 1)</code>
</p>
</li>
<li><p> cubic: <code class="reqn">(1 - 7\eta^2 + 8.75\eta^3 - 3.5\eta^5 + 0.75\eta^7) * I(h &lt;= range)</code>
</p>
</li>
<li><p> pentaspherical: <code class="reqn">(1 - 1.875\eta + 1.25\eta^3 - 0.375\eta^5) * I(h &lt;= range)</code>
</p>
</li>
<li><p> cosine: <code class="reqn">cos(\eta)</code>
</p>
</li>
<li><p> wave: <code class="reqn">sin(\eta) / \eta * I(h &gt; 0) + I(h = 0)</code>
</p>
</li>
<li><p> jbessel: <code class="reqn">Bj(h * range)</code>, Bj is Bessel-J function
</p>
</li>
<li><p> gravity: <code class="reqn">(1 + \eta^2)^{-0.5}</code>
</p>
</li>
<li><p> rquad: <code class="reqn">(1 + \eta^2)^{-1}</code>
</p>
</li>
<li><p> magnetic: <code class="reqn">(1 + \eta^2)^{-1.5}</code>
</p>
</li>
<li><p> matern: <code class="reqn">2^{1 - extra}/ \Gamma(extra) * \alpha^{extra} * Bk(\alpha, extra)</code>, <code class="reqn">\alpha = (2extra * \eta)^{0.5}</code>, Bk is Bessel-K function with order <code class="reqn">1/5 \le extra \le 5</code>
</p>
</li>
<li><p> cauchy: <code class="reqn">(1 + \eta^2)^{-extra}</code>, <code class="reqn">extra &gt; 0</code>
</p>
</li>
<li><p> pexponential: <code class="reqn">exp(h^{extra}/range)</code>, <code class="reqn">0 &lt; extra \le 2</code>
</p>
</li>
<li><p> none: <code class="reqn">0</code>
</p>
</li></ul>

<p>All spatial covariance functions are valid in one spatial dimension. All
spatial covariance functions except <code>triangular</code> and <code>cosine</code> are
valid in two dimensions.
</p>
<p><code>estmethod</code> Details: The various estimation methods are
</p>

<ul>
<li> <p><code>reml</code>: Maximize the restricted log-likelihood.
</p>
</li>
<li> <p><code>ml</code>: Maximize the log-likelihood.
</p>
</li></ul>

<p>Note that the likelihood being optimized is obtained using the Laplace approximation.
</p>
<p><code>anisotropy</code> Details: By default, all spatial covariance parameters except <code>rotate</code>
and <code>scale</code> as well as all random effect variance parameters
are assumed unknown, requiring estimation. If either <code>rotate</code> or <code>scale</code>
are given initial values other than 0 and 1 (respectively) or are assumed unknown
in <code><a href="#topic+spcov_initial">spcov_initial()</a></code>, <code>anisotropy</code> is implicitly set to <code>TRUE</code>.
(Geometric) Anisotropy is modeled by transforming a covariance function that
decays differently in different directions to one that decays equally in all
directions via rotation and scaling of the original coordinates. The rotation is
controlled by the <code>rotate</code> parameter in <code class="reqn">[0, \pi]</code> radians. The scaling
is controlled by the <code>scale</code> parameter in <code class="reqn">[0, 1]</code>. The anisotropy
correction involves first a rotation of the coordinates clockwise by <code>rotate</code> and then a
scaling of the coordinates' minor axis by the reciprocal of <code>scale</code>. The spatial
covariance is then computed using these transformed coordinates.
</p>
<p><code>random</code> Details: If random effects are used, the model
can be written as <code class="reqn">y = X \beta + Z1u1 + ... Zjuj + \tau + \epsilon</code>,
where each Z is a random effects design matrix and each u is a random effect.
</p>
<p><code>partition_factor</code> Details: The partition factor can be represented in matrix form as <code class="reqn">P</code>, where
elements of <code class="reqn">P</code> equal one for observations in the same level of the partition
factor and zero otherwise. The covariance matrix involving only the
spatial and random effects components is then multiplied element-wise
(Hadmard product) by <code class="reqn">P</code>, yielding the final covariance matrix.
</p>
<p><code>local</code> Details: The big data approximation works by sorting observations into different levels
of an index variable. Observations in different levels of the index variable
are assumed to be uncorrelated for the purposes of model fitting. Sparse matrix methods are then implemented
for significant computational gains. Parallelization generally further speeds up
computations when data sizes are larger than a few thousand. Both the <code>"random"</code> and <code>"kmeans"</code> values of <code>method</code>
in <code>local</code> have random components. That means you may get slightly different
results when using the big data approximation and rerunning <code>spglm()</code> with the same code. For consistent results,
either set a seed via <code>base::set.seed()</code> or specify <code>index</code> to <code>local</code>.
</p>
<p>Observations with <code>NA</code> response values are removed for model
fitting, but their values can be predicted afterwards by running
<code>predict(object)</code>.
</p>


<h3>Value</h3>

<p>A list with many elements that store information about
the fitted model object. If <code>spcov_type</code> or <code>spcov_initial</code> are
length one, the list has class <code>spglm</code>. Many generic functions that
summarize model fit are available for <code>spglm</code> objects, including
<code>AIC</code>, <code>AICc</code>, <code>anova</code>, <code>augment</code>, <code>coef</code>,
<code>cooks.distance</code>, <code>covmatrix</code>, <code>deviance</code>, <code>fitted</code>, <code>formula</code>,
<code>glance</code>, <code>glances</code>, <code>hatvalues</code>, <code>influence</code>,
<code>labels</code>, <code>logLik</code>, <code>loocv</code>, <code>model.frame</code>, <code>model.matrix</code>,
<code>plot</code>, <code>predict</code>, <code>print</code>, <code>pseudoR2</code>, <code>summary</code>,
<code>terms</code>, <code>tidy</code>, <code>update</code>, <code>varcomp</code>, and <code>vcov</code>. If
<code>spcov_type</code> or <code>spcov_initial</code> are length greater than one, the
list has class <code>spglm_list</code> and each element in the list has class
<code>spglm</code>. <code>glances</code> can be used to summarize <code>spglm_list</code>
objects, and the aforementioned <code>spglm</code> generics can be used on each
individual list element (model fit).
</p>


<h3>Note</h3>

<p>This function does not perform any internal scaling. If optimization is not
stable due to large extremely large variances, scale relevant variables
so they have variance 1 before optimization.
</p>


<h3>References</h3>

<p>McCullagh P. and Nelder, J. A. (1989) <em>Generalized Linear Models</em>. London: Chapman and Hall.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spgmod &lt;- spglm(presence ~ elev,
  family = "binomial", data = moose,
  spcov_type = "exponential"
)
summary(spgmod)
</code></pre>

<hr>
<h2 id='splm'>Fit spatial linear models</h2><span id='topic+splm'></span>

<h3>Description</h3>

<p>Fit spatial linear models for point-referenced data (i.e.,
geostatistical models) using
a variety of estimation methods, allowing for random effects,
anisotropy, partition factors, and big data methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splm(
  formula,
  data,
  spcov_type,
  xcoord,
  ycoord,
  spcov_initial,
  estmethod = "reml",
  weights = "cressie",
  anisotropy = FALSE,
  random,
  randcov_initial,
  partition_factor,
  local,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splm_+3A_formula">formula</code></td>
<td>
<p>A two-sided linear formula describing the fixed effect structure
of the model, with the response to the left of the <code>~</code> operator and
the terms on the right, separated by <code>+</code> operators.</p>
</td></tr>
<tr><td><code id="splm_+3A_data">data</code></td>
<td>
<p>A data frame or <code>sf</code> object object that contains
the variables in <code>fixed</code>, <code>random</code>, and <code>partition_factor</code>
as well as geographical information. If an <code>sf</code> object is
provided with <code>POINT</code> geometries, the x-coordinates and y-coordinates
are used directly. If an <code>sf</code> object is
provided with <code>POLYGON</code> geometries, the x-coordinates and y-coordinates
are taken as the centroids of each polygon.</p>
</td></tr>
<tr><td><code id="splm_+3A_spcov_type">spcov_type</code></td>
<td>
<p>The spatial covariance type. Available options include
<code>"exponential"</code>, <code>"spherical"</code>, <code>"gaussian"</code>,
<code>"triangular"</code>, <code>"circular"</code>, <code>"cubic"</code>,
<code>"pentaspherical"</code>, <code>"cosine"</code>, <code>"wave"</code>,
<code>"jbessel"</code>, <code>"gravity"</code>, <code>"rquad"</code>,
<code>"magnetic"</code>, <code>"matern"</code>, <code>"cauchy"</code>, <code>"pexponential"</code>,
and <code>"none"</code>. Parameterizations of each spatial covariance type are
available in Details. Multiple spatial covariance types can be provided as
a character vector, and then <code>splm()</code> is called iteratively for each
element and a list is returned for each model fit. The default for
<code>spcov_type</code> is <code>"exponential"</code>. When <code>spcov_type</code> is
specified, all unknown spatial covariance parameters are estimated.
<code>spcov_type</code> is ignored if <code>spcov_initial</code> is provided.</p>
</td></tr>
<tr><td><code id="splm_+3A_xcoord">xcoord</code></td>
<td>
<p>The name of the column in <code>data</code> representing the x-coordinate.
Can be quoted or unquoted. Not required if <code>data</code> is an <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="splm_+3A_ycoord">ycoord</code></td>
<td>
<p>The name of the column in <code>data</code> representing the y-coordinate.
Can be quoted or unquoted. Not required if <code>data</code> is an <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="splm_+3A_spcov_initial">spcov_initial</code></td>
<td>
<p>An object from <code><a href="#topic+spcov_initial">spcov_initial()</a></code> specifying initial and/or
known values for the spatial covariance parameters. Multiple <code><a href="#topic+spcov_initial">spcov_initial()</a></code>
objects can be provided in a list. Then <code>splm()</code> is called iteratively
for each element and a list is returned for each model fit.</p>
</td></tr>
<tr><td><code id="splm_+3A_estmethod">estmethod</code></td>
<td>
<p>The estimation method. Available options include
<code>"reml"</code> for restricted maximum likelihood, <code>"ml"</code> for maximum
likelihood, <code>"sv-wls"</code> for semivariogram weighted least squares,
and <code>"sv-cl"</code> for semivariogram composite likelihood. The default is
<code>"reml"</code>.</p>
</td></tr>
<tr><td><code id="splm_+3A_weights">weights</code></td>
<td>
<p>Weights to use when <code>estmethod</code> is <code>"sv-wls"</code>. Available
options include <code>"cressie"</code>, <code>"cressie-dr"</code>, <code>"cressie-nopairs"</code>,
<code>"cressie-dr-nopairs"</code>, <code>"pairs"</code>, <code>"pairs-invd"</code>,
<code>"pairs-invrd"</code>, and <code>"ols"</code>. Parameterizations for each weight
are available in Details. The default is <code>"cressie"</code>.</p>
</td></tr>
<tr><td><code id="splm_+3A_anisotropy">anisotropy</code></td>
<td>
<p>A logical indicating whether (geometric) anisotropy should
be modeled. Not required if <code>spcov_initial</code> is provided with 1) <code>rotate</code>
assumed unknown or assumed known and non-zero or 2) <code>scale</code> assumed unknown
or assumed known and less than one. When <code>anisotropy</code> is <code>TRUE</code>,
computational times can significantly increase. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="splm_+3A_random">random</code></td>
<td>
<p>A one-sided linear formula describing the random effect structure
of the model. Terms are specified to the right of the <code>~ operator</code>.
Each term has the structure <code>x1 + ... + xn | g1/.../gm</code>, where <code>x1 + ... + xn</code>
specifies the model for the random effects and <code>g1/.../gm</code> is the grouping
structure. Separate terms are separated by <code>+</code> and must generally
be wrapped in parentheses. Random intercepts are added to each model
implicitly when at least  one other variable is defined.
If a random intercept is not desired, this must be explicitly
defined (e.g., <code>x1 + ... + xn - 1 | g1/.../gm</code>). If only a random intercept
is desired for a grouping structure, the random intercept must be specified
as <code>1 | g1/.../gm</code>. Note that <code>g1/.../gm</code> is shorthand for <code>(1 | g1/.../gm)</code>.
If only random intercepts are desired and the shorthand notation is used,
parentheses can be omitted.</p>
</td></tr>
<tr><td><code id="splm_+3A_randcov_initial">randcov_initial</code></td>
<td>
<p>An optional object specifying initial and/or
known values for the random effect variances.</p>
</td></tr>
<tr><td><code id="splm_+3A_partition_factor">partition_factor</code></td>
<td>
<p>A one-sided linear formula with a single term
specifying the partition factor.  The partition factor assumes observations
from different levels of the partition factor are uncorrelated.</p>
</td></tr>
<tr><td><code id="splm_+3A_local">local</code></td>
<td>
<p>An optional logical or list controlling the big data approximation.
If omitted, <code>local</code> is set
to <code>TRUE</code> or <code>FALSE</code> based on the sample size (the number of
non-missing observations in <code>data</code>) &ndash; if the sample size exceeds 5,000,
<code>local</code> is set to <code>TRUE</code>. Otherwise it is set to <code>FALSE</code>.
If <code>FALSE</code>, no big data approximation is implemented.
If a list is provided, the following arguments detail the big
data approximation:
</p>

<ul>
<li> <p><code>index: </code>The group indexes. Observations in different
levels of <code>index</code> are assumed to be uncorrelated for the
purposes of estimation. If <code>index</code> is not provided, it is
determined by specifying <code>method</code> and either <code>size</code> or <code>groups</code>.
</p>
</li>
<li> <p><code>method</code>: The big data approximation method used to determine <code>index</code>. Ignored
if <code>index</code> is provided. If <code>method = "random"</code>,
observations are randomly assigned to <code>index</code> based on <code>size</code>.
If <code>method = "kmeans"</code>, observations assigned to <code>index</code>
based on k-means clustering on the coordinates with <code>groups</code> clusters. The default
is <code>"kmeans"</code>. Note that both methods have a random component, which
means that you may get different results from separate model fitting calls.
To ensure consistent results, specify <code>index</code> or set a seed via
<code>base::set.seed()</code>.
</p>
</li>
<li> <p><code>size</code>: The number of observations in each <code>index</code> group
when <code>method</code> is <code>"random"</code>. If the number of observations
is not divisible by <code>size</code>, some levels get <code>size - 1</code> observations.
The default is 100.
</p>
</li>
<li> <p><code>groups: </code>The number of <code>index</code> groups. If <code>method</code>
is <code>"random"</code>, <code>size</code> is <code class="reqn">ceiling(n / groups)</code>, where
<code class="reqn">n</code> is the sample size. Automatically determined if <code>size</code>
is specified. If <code>method</code> is <code>"kmeans"</code>, <code>groups</code>
is the number of clusters.
</p>
</li>
<li> <p><code>var_adjust: </code>The approach for adjusting the variance-covariance
matrix of the fixed effects. <code>"none"</code> for no adjustment, <code>"theoretical"</code>
for the theoretically-correct adjustment,
<code>"pooled"</code> for the pooled adjustment, and <code>"empirical"</code> for the
empirical adjustment. The default is <code>"theoretical"</code>.
</p>
</li>
<li> <p><code>parallel</code>: If <code>TRUE</code>, parallel processing via the
parallel package is automatically used. The default is <code>FALSE</code>.
</p>
</li>
<li> <p><code>ncores</code>: If <code>parallel = TRUE</code>, the number of cores to
parallelize over. The default is the number of available cores on your machine.
</p>
</li></ul>

<p>When <code>local</code> is a list, at least one list element must be provided to
initialize default arguments for the other list elements.
If <code>local</code> is <code>TRUE</code>, defaults for <code>local</code> are chosen such
that <code>local</code> is transformed into
<code>list(size = 100, method = "kmeans", var_adjust = "theoretical", parallel = FALSE)</code>.</p>
</td></tr>
<tr><td><code id="splm_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="#topic+esv">esv()</a></code> or <code>stats::optim()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spatial linear model for point-referenced data
(i.e., geostatistical model) can be written as
<code class="reqn">y = X \beta + \tau + \epsilon</code>, where <code class="reqn">X</code> is the fixed effects design
matrix, <code class="reqn">\beta</code> are the fixed effects, <code class="reqn">\tau</code> is random error that is
spatially dependent, and <code class="reqn">\epsilon</code> is random error that is spatially
independent. Together, <code class="reqn">\tau</code> and <code class="reqn">\epsilon</code> are modeled using
a spatial covariance function, expressed as
<code class="reqn">de * R + ie * I</code>, where <code class="reqn">de</code> is the dependent error variance, <code class="reqn">R</code>
is a correlation matrix that controls the spatial dependence structure among observations,
<code class="reqn">ie</code> is the independent error variance, and <code class="reqn">I</code> is
an identity matrix.
</p>
<p><code>spcov_type</code> Details: Parametric forms for <code class="reqn">R</code> are given below, where <code class="reqn">\eta = h / range</code>
for <code class="reqn">h</code> distance between observations:
</p>

<ul>
<li><p> exponential: <code class="reqn">exp(- \eta )</code>
</p>
</li>
<li><p> spherical: <code class="reqn">(1 - 1.5\eta + 0.5\eta^3) * I(h &lt;= range)</code>
</p>
</li>
<li><p> gaussian: <code class="reqn">exp(- \eta^2 )</code>
</p>
</li>
<li><p> triangular: <code class="reqn">(1 - \eta) * I(h &lt;= range)</code>
</p>
</li>
<li><p> circular: <code class="reqn">(1 - (2 / \pi) * (m * sqrt(1 - m^2) + sin^{-1}(m))) * I(h &lt;= range), m = min(\eta, 1)</code>
</p>
</li>
<li><p> cubic: <code class="reqn">(1 - 7\eta^2 + 8.75\eta^3 - 3.5\eta^5 + 0.75\eta^7) * I(h &lt;= range)</code>
</p>
</li>
<li><p> pentaspherical: <code class="reqn">(1 - 1.875\eta + 1.25\eta^3 - 0.375\eta^5) * I(h &lt;= range)</code>
</p>
</li>
<li><p> cosine: <code class="reqn">cos(\eta)</code>
</p>
</li>
<li><p> wave: <code class="reqn">sin(\eta) / \eta * I(h &gt; 0) + I(h = 0)</code>
</p>
</li>
<li><p> jbessel: <code class="reqn">Bj(h * range)</code>, Bj is Bessel-J function
</p>
</li>
<li><p> gravity: <code class="reqn">(1 + \eta^2)^{-0.5}</code>
</p>
</li>
<li><p> rquad: <code class="reqn">(1 + \eta^2)^{-1}</code>
</p>
</li>
<li><p> magnetic: <code class="reqn">(1 + \eta^2)^{-1.5}</code>
</p>
</li>
<li><p> matern: <code class="reqn">2^{1 - extra}/ \Gamma(extra) * \alpha^{extra} * Bk(\alpha, extra)</code>, <code class="reqn">\alpha = (2extra * \eta)^{0.5}</code>, Bk is Bessel-K function with order <code class="reqn">1/5 \le extra \le 5</code>
</p>
</li>
<li><p> cauchy: <code class="reqn">(1 + \eta^2)^{-extra}</code>, <code class="reqn">extra &gt; 0</code>
</p>
</li>
<li><p> pexponential: <code class="reqn">exp(h^{extra}/range)</code>, <code class="reqn">0 &lt; extra \le 2</code>
</p>
</li>
<li><p> none: <code class="reqn">0</code>
</p>
</li></ul>

<p>All spatial covariance functions are valid in one spatial dimension. All
spatial covariance functions except <code>triangular</code> and <code>cosine</code> are
valid in two dimensions.
</p>
<p><code>estmethod</code> Details: The various estimation methods are
</p>

<ul>
<li> <p><code>reml</code>: Maximize the restricted log-likelihood.
</p>
</li>
<li> <p><code>ml</code>: Maximize the log-likelihood.
</p>
</li>
<li> <p><code>sv-wls</code>: Minimize the semivariogram weighted least squares loss.
</p>
</li>
<li> <p><code>sv-cl</code>: Minimize the semivariogram composite likelihood loss.
</p>
</li></ul>

<p><code>anisotropy</code> Details: By default, all spatial covariance parameters except <code>rotate</code>
and <code>scale</code> as well as all random effect variance parameters
are assumed unknown, requiring estimation. If either <code>rotate</code> or <code>scale</code>
are given initial values other than 0 and 1 (respectively) or are assumed unknown
in <code><a href="#topic+spcov_initial">spcov_initial()</a></code>, <code>anisotropy</code> is implicitly set to <code>TRUE</code>.
(Geometric) Anisotropy is modeled by transforming a covariance function that
decays differently in different directions to one that decays equally in all
directions via rotation and scaling of the original coordinates. The rotation is
controlled by the <code>rotate</code> parameter in <code class="reqn">[0, \pi]</code> radians. The scaling
is controlled by the <code>scale</code> parameter in <code class="reqn">[0, 1]</code>. The anisotropy
correction involves first a rotation of the coordinates clockwise by <code>rotate</code> and then a
scaling of the coordinates' minor axis by the reciprocal of <code>scale</code>. The spatial
covariance is then computed using these transformed coordinates.
</p>
<p><code>random</code> Details: If random effects are used (the estimation method must be <code>"reml"</code> or
<code>"ml"</code>), the model
can be written as <code class="reqn">y = X \beta + Z1u1 + ... Zjuj + \tau + \epsilon</code>,
where each Z is a random effects design matrix and each u is a random effect.
</p>
<p><code>partition_factor</code> Details: The partition factor can be represented in matrix form as <code class="reqn">P</code>, where
elements of <code class="reqn">P</code> equal one for observations in the same level of the partition
factor and zero otherwise. The covariance matrix involving only the
spatial and random effects components is then multiplied element-wise
(Hadmard product) by <code class="reqn">P</code>, yielding the final covariance matrix.
</p>
<p><code>local</code> Details: The big data approximation works by sorting observations into different levels
of an index variable. Observations in different levels of the index variable
are assumed to be uncorrelated for the purposes of model fitting. Sparse matrix methods are then implemented
for significant computational gains. Parallelization generally further speeds up
computations when data sizes are larger than a few thousand. Both the <code>"random"</code> and <code>"kmeans"</code> values of <code>method</code>
in <code>local</code> have random components. That means you may get slightly different
results when using the big data approximation and rerunning <code>splm()</code> with the same code. For consistent results,
either set a seed via <code>base::set.seed()</code> or specify <code>index</code> to <code>local</code>.
</p>
<p>Observations with <code>NA</code> response values are removed for model
fitting, but their values can be predicted afterwards by running
<code>predict(object)</code>.
</p>


<h3>Value</h3>

<p>A list with many elements that store information about
the fitted model object. If <code>spcov_type</code> or <code>spcov_initial</code> are
length one, the list has class <code>splm</code>. Many generic functions that
summarize model fit are available for <code>splm</code> objects, including
<code>AIC</code>, <code>AICc</code>, <code>anova</code>, <code>augment</code>, <code>coef</code>,
<code>cooks.distance</code>, <code>covmatrix</code>, <code>deviance</code>, <code>fitted</code>, <code>formula</code>,
<code>glance</code>, <code>glances</code>, <code>hatvalues</code>, <code>influence</code>,
<code>labels</code>, <code>logLik</code>, <code>loocv</code>, <code>model.frame</code>, <code>model.matrix</code>,
<code>plot</code>, <code>predict</code>, <code>print</code>, <code>pseudoR2</code>, <code>summary</code>,
<code>terms</code>, <code>tidy</code>, <code>update</code>, <code>varcomp</code>, and <code>vcov</code>. If
<code>spcov_type</code> or <code>spcov_initial</code> are length greater than one, the
list has class <code>splm_list</code> and each element in the list has class
<code>splm</code>. <code>glances</code> can be used to summarize <code>splm_list</code>
objects, and the aforementioned <code>splm</code> generics can be used on each
individual list element (model fit).
</p>


<h3>Note</h3>

<p>This function does not perform any internal scaling. If optimization is not
stable due to large extremely large variances, scale relevant variables
so they have variance 1 before optimization.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
summary(spmod)
</code></pre>

<hr>
<h2 id='splmRF'>Fit random forest spatial residual models</h2><span id='topic+splmRF'></span>

<h3>Description</h3>

<p>Fit random forest spatial residual models
for point-referenced data (i.e., geostatistical models) using
random forest to fit the mean and a spatial linear model to fit the residuals.
The spatial linear model fit to the residuals can incorporate variety of estimation methods,
allowing for random effects, anisotropy, partition factors, and big data methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splmRF(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splmRF_+3A_formula">formula</code></td>
<td>
<p>A two-sided linear formula describing the fixed effect structure
of the model, with the response to the left of the <code>~</code> operator and
the terms on the right, separated by <code>+</code> operators.</p>
</td></tr>
<tr><td><code id="splmRF_+3A_data">data</code></td>
<td>
<p>A data frame or <code>sf</code> object object that contains
the variables in <code>fixed</code>, <code>random</code>, and <code>partition_factor</code>
as well as geographical information. If an <code>sf</code> object is
provided with <code>POINT</code> geometries, the x-coordinates and y-coordinates
are used directly. If an <code>sf</code> object is
provided with <code>POLYGON</code> geometries, the x-coordinates and y-coordinates
are taken as the centroids of each polygon.</p>
</td></tr>
<tr><td><code id="splmRF_+3A_...">...</code></td>
<td>
<p>Additional named arguments to <code><a href="ranger.html#topic+ranger">ranger::ranger()</a></code> or <code><a href="#topic+splm">splm()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The random forest residual spatial linear model is described by
Fox et al. (2020). A random forest model is fit to the mean portion of the
model specified by <code>formula</code> using <code>ranger::ranger()</code>. Residuals
are computed and used as the response variable in an intercept-only spatial
linear model fit using <code><a href="#topic+splm">splm()</a></code>. This model object is intended for use with
<code>predict()</code> to perform prediction, also called random forest
regression Kriging.
</p>


<h3>Value</h3>

<p>A list with several elements to be used with <code>predict()</code>. These
elements include the function call (named <code>call</code>), the random forest object
fit to the mean (named <code>ranger</code>),
the spatial linear model object fit to the residuals
(named <code>splm</code> or <code>splm_list</code>), and an object can contain data for
locations at which to predict (called <code>newdata</code>). The <code>newdata</code>
object contains the set of
observations in <code>data</code> whose response variable is <code>NA</code>.
If <code>spcov_type</code> or <code>spcov_initial</code> (which are passed to <code><a href="#topic+splm">splm()</a></code>)
are length one, the list has class <code>splmRF</code> and the spatial linear
model object fit to the residuals is called <code>splm</code>, which has
class <code>splm</code>. If
<code>spcov_type</code> or <code>spcov_initial</code> are length greater than one, the
list has class <code>splmRF_list</code> and the spatial linear model object
fit to the residuals is called <code>splm_list</code>, which has class <code>splm_list</code>.
and contains several objects, each with class <code>splm</code>.
</p>
<p>An <code>splmRF</code> object to be used with <code>predict()</code>. There are
three elements: <code>ranger</code>, the output from fitting the mean model with
<code><a href="ranger.html#topic+ranger">ranger::ranger()</a></code>; <code>splm</code>, the output from fitting the spatial
linear model to the ranger residuals; and <code>newdata</code>, the <code>newdata</code>
object, if relevant.
</p>


<h3>Note</h3>

<p>This function does not perform any internal scaling. If optimization is not
stable due to large extremely large variances, scale relevant variables
so they have variance 1 before optimization.
</p>


<h3>References</h3>

<p>Fox, E.W., Ver Hoef, J. M., &amp; Olsen, A. R. (2020). Comparing spatial
regression to random forests for large environmental data sets.
<em>PloS one</em>, 15(3), e0229509.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sulfate$var &lt;- rnorm(NROW(sulfate)) # add noise variable
sulfate_preds$var &lt;- rnorm(NROW(sulfate_preds)) # add noise variable
sprfmod &lt;- splmRF(sulfate ~ var, data = sulfate, spcov_type = "exponential")
predict(sprfmod, sulfate_preds)

</code></pre>

<hr>
<h2 id='spmodel-package'>spmodel: Spatial Statistical Modeling and Prediction</h2><span id='topic+spmodel'></span><span id='topic+spmodel-package'></span>

<h3>Description</h3>

<p>Fit, summarize, and predict for a variety of spatial statistical models applied to point-referenced and areal (lattice) data. Parameters are estimated using various methods. Additional modeling features include anisotropy, non-spatial random effects, partition factors, big data approaches, and more. Model-fit statistics are used to summarize, visualize, and compare models. Predictions at unobserved locations are readily obtainable. For additional details, see Dumelle et al. (2023) <a href="https://doi.org/10.1371/journal.pone.0282524">doi:10.1371/journal.pone.0282524</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michael Dumelle <a href="mailto:Dumelle.Michael@epa.gov">Dumelle.Michael@epa.gov</a> (<a href="https://orcid.org/0000-0002-3393-5529">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Matt Higham <a href="mailto:mhigham@stlawu.edu">mhigham@stlawu.edu</a>
</p>
</li>
<li><p> Jay M. Ver Hoef <a href="mailto:jay.verhoef@noaa.gov">jay.verhoef@noaa.gov</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://usepa.github.io/spmodel/">https://usepa.github.io/spmodel/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/USEPA/spmodel/issues">https://github.com/USEPA/spmodel/issues</a>
</p>
</li></ul>


<hr>
<h2 id='sprbeta'>Simulate a spatial beta random variable</h2><span id='topic+sprbeta'></span>

<h3>Description</h3>

<p>Simulate a spatial beta random variable with a specific
mean and covariance structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sprbeta(
  spcov_params,
  dispersion = 1,
  mean = 0,
  samples = 1,
  data,
  randcov_params,
  partition_factor,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sprbeta_+3A_spcov_params">spcov_params</code></td>
<td>
<p>An <code><a href="#topic+spcov_params">spcov_params()</a></code> object.</p>
</td></tr>
<tr><td><code id="sprbeta_+3A_dispersion">dispersion</code></td>
<td>
<p>The dispersion value.</p>
</td></tr>
<tr><td><code id="sprbeta_+3A_mean">mean</code></td>
<td>
<p>A numeric vector representing the mean. <code>mean</code> must have length 1
(in which case it is recycled) or length equal
to the number of rows in <code>data</code>. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="sprbeta_+3A_samples">samples</code></td>
<td>
<p>The number of independent samples to generate. The default
is <code>1</code>.</p>
</td></tr>
<tr><td><code id="sprbeta_+3A_data">data</code></td>
<td>
<p>A data frame or <code>sf</code> object containing spatial information.</p>
</td></tr>
<tr><td><code id="sprbeta_+3A_randcov_params">randcov_params</code></td>
<td>
<p>A <code><a href="#topic+randcov_params">randcov_params()</a></code> object.</p>
</td></tr>
<tr><td><code id="sprbeta_+3A_partition_factor">partition_factor</code></td>
<td>
<p>A formula indicating the partition factor.</p>
</td></tr>
<tr><td><code id="sprbeta_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+sprnorm">sprnorm()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of <code>spcov_params</code>, <code>mean</code>, and <code>randcov_params</code>
are assumed to be on the link scale. They are used to simulate a latent normal (Gaussian)
response variable using <code><a href="#topic+sprnorm">sprnorm()</a></code>. This latent variable is the
conditional mean used with <code>dispersion</code> to simulate a beta random variable.
</p>


<h3>Value</h3>

<p>If <code>samples</code> is 1, a vector of random variables for each row of <code>data</code>
is returned. If <code>samples</code> is greater than one, a matrix of random variables
is returned, where the rows correspond to each row of <code>data</code> and the columns
correspond to independent samples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spcov_params_val &lt;- spcov_params("exponential", de = 0.2, ie = 0.1, range = 1)
sprbeta(spcov_params_val, data = caribou, xcoord = x, ycoord = y)
sprbeta(spcov_params_val, samples = 5, data = caribou, xcoord = x, ycoord = y)
</code></pre>

<hr>
<h2 id='sprbinom'>Simulate a spatial binomial random variable</h2><span id='topic+sprbinom'></span>

<h3>Description</h3>

<p>Simulate a spatial binomial random variable with a specific
mean and covariance structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sprbinom(
  spcov_params,
  mean = 0,
  size = 1,
  samples = 1,
  data,
  randcov_params,
  partition_factor,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sprbinom_+3A_spcov_params">spcov_params</code></td>
<td>
<p>An <code><a href="#topic+spcov_params">spcov_params()</a></code> object.</p>
</td></tr>
<tr><td><code id="sprbinom_+3A_mean">mean</code></td>
<td>
<p>A numeric vector representing the mean. <code>mean</code> must have length 1
(in which case it is recycled) or length equal
to the number of rows in <code>data</code>. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="sprbinom_+3A_size">size</code></td>
<td>
<p>A numeric vector representing the sample size for each binomial trial.
The default is <code>1</code>, which corresponds to a Bernoulli trial for each observation.</p>
</td></tr>
<tr><td><code id="sprbinom_+3A_samples">samples</code></td>
<td>
<p>The number of independent samples to generate. The default
is <code>1</code>.</p>
</td></tr>
<tr><td><code id="sprbinom_+3A_data">data</code></td>
<td>
<p>A data frame or <code>sf</code> object containing spatial information.</p>
</td></tr>
<tr><td><code id="sprbinom_+3A_randcov_params">randcov_params</code></td>
<td>
<p>A <code><a href="#topic+randcov_params">randcov_params()</a></code> object.</p>
</td></tr>
<tr><td><code id="sprbinom_+3A_partition_factor">partition_factor</code></td>
<td>
<p>A formula indicating the partition factor.</p>
</td></tr>
<tr><td><code id="sprbinom_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+sprnorm">sprnorm()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of <code>spcov_params</code>, <code>mean</code>, and <code>randcov_params</code>
are assumed to be on the link scale. They are used to simulate a latent normal (Gaussian)
response variable using <code><a href="#topic+sprnorm">sprnorm()</a></code>. This latent variable is the
conditional mean used with <code>dispersion</code> to simulate a binomial random variable.
</p>


<h3>Value</h3>

<p>If <code>samples</code> is 1, a vector of random variables for each row of <code>data</code>
is returned. If <code>samples</code> is greater than one, a matrix of random variables
is returned, where the rows correspond to each row of <code>data</code> and the columns
correspond to independent samples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spcov_params_val &lt;- spcov_params("exponential", de = 0.2, ie = 0.1, range = 1)
sprbinom(spcov_params_val, data = caribou, xcoord = x, ycoord = y)
sprbinom(spcov_params_val, samples = 5, data = caribou, xcoord = x, ycoord = y)
</code></pre>

<hr>
<h2 id='sprgamma'>Simulate a spatial gamma random variable</h2><span id='topic+sprgamma'></span>

<h3>Description</h3>

<p>Simulate a spatial gamma random variable with a specific
mean and covariance structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sprgamma(
  spcov_params,
  dispersion = 1,
  mean = 0,
  samples = 1,
  data,
  randcov_params,
  partition_factor,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sprgamma_+3A_spcov_params">spcov_params</code></td>
<td>
<p>An <code><a href="#topic+spcov_params">spcov_params()</a></code> object.</p>
</td></tr>
<tr><td><code id="sprgamma_+3A_dispersion">dispersion</code></td>
<td>
<p>The dispersion value.</p>
</td></tr>
<tr><td><code id="sprgamma_+3A_mean">mean</code></td>
<td>
<p>A numeric vector representing the mean. <code>mean</code> must have length 1
(in which case it is recycled) or length equal
to the number of rows in <code>data</code>. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="sprgamma_+3A_samples">samples</code></td>
<td>
<p>The number of independent samples to generate. The default
is <code>1</code>.</p>
</td></tr>
<tr><td><code id="sprgamma_+3A_data">data</code></td>
<td>
<p>A data frame or <code>sf</code> object containing spatial information.</p>
</td></tr>
<tr><td><code id="sprgamma_+3A_randcov_params">randcov_params</code></td>
<td>
<p>A <code><a href="#topic+randcov_params">randcov_params()</a></code> object.</p>
</td></tr>
<tr><td><code id="sprgamma_+3A_partition_factor">partition_factor</code></td>
<td>
<p>A formula indicating the partition factor.</p>
</td></tr>
<tr><td><code id="sprgamma_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+sprnorm">sprnorm()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of <code>spcov_params</code>, <code>mean</code>, and <code>randcov_params</code>
are assumed to be on the link scale. They are used to simulate a latent normal (Gaussian)
response variable using <code><a href="#topic+sprnorm">sprnorm()</a></code>. This latent variable is the
conditional mean used with <code>dispersion</code> to simulate a gamma random variable.
</p>


<h3>Value</h3>

<p>If <code>samples</code> is 1, a vector of random variables for each row of <code>data</code>
is returned. If <code>samples</code> is greater than one, a matrix of random variables
is returned, where the rows correspond to each row of <code>data</code> and the columns
correspond to independent samples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spcov_params_val &lt;- spcov_params("exponential", de = 0.2, ie = 0.1, range = 1)
sprgamma(spcov_params_val, data = caribou, xcoord = x, ycoord = y)
sprgamma(spcov_params_val, samples = 5, data = caribou, xcoord = x, ycoord = y)
</code></pre>

<hr>
<h2 id='sprinvgauss'>Simulate a spatial inverse gaussian random variable</h2><span id='topic+sprinvgauss'></span>

<h3>Description</h3>

<p>Simulate a spatial inverse gaussian random variable with a specific
mean and covariance structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sprinvgauss(
  spcov_params,
  dispersion = 1,
  mean = 0,
  samples = 1,
  data,
  randcov_params,
  partition_factor,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sprinvgauss_+3A_spcov_params">spcov_params</code></td>
<td>
<p>An <code><a href="#topic+spcov_params">spcov_params()</a></code> object.</p>
</td></tr>
<tr><td><code id="sprinvgauss_+3A_dispersion">dispersion</code></td>
<td>
<p>The dispersion value.</p>
</td></tr>
<tr><td><code id="sprinvgauss_+3A_mean">mean</code></td>
<td>
<p>A numeric vector representing the mean. <code>mean</code> must have length 1
(in which case it is recycled) or length equal
to the number of rows in <code>data</code>. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="sprinvgauss_+3A_samples">samples</code></td>
<td>
<p>The number of independent samples to generate. The default
is <code>1</code>.</p>
</td></tr>
<tr><td><code id="sprinvgauss_+3A_data">data</code></td>
<td>
<p>A data frame or <code>sf</code> object containing spatial information.</p>
</td></tr>
<tr><td><code id="sprinvgauss_+3A_randcov_params">randcov_params</code></td>
<td>
<p>A <code><a href="#topic+randcov_params">randcov_params()</a></code> object.</p>
</td></tr>
<tr><td><code id="sprinvgauss_+3A_partition_factor">partition_factor</code></td>
<td>
<p>A formula indicating the partition factor.</p>
</td></tr>
<tr><td><code id="sprinvgauss_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+sprnorm">sprnorm()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of <code>spcov_params</code>, <code>mean</code>, and <code>randcov_params</code>
are assumed to be on the link scale. They are used to simulate a latent normal (Gaussian)
response variable using <code><a href="#topic+sprnorm">sprnorm()</a></code>. This latent variable is the
conditional mean used with <code>dispersion</code> to simulate a inverse gaussian random variable.
</p>


<h3>Value</h3>

<p>If <code>samples</code> is 1, a vector of random variables for each row of <code>data</code>
is returned. If <code>samples</code> is greater than one, a matrix of random variables
is returned, where the rows correspond to each row of <code>data</code> and the columns
correspond to independent samples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spcov_params_val &lt;- spcov_params("exponential", de = 0.2, ie = 0.1, range = 1)
sprinvgauss(spcov_params_val, data = caribou, xcoord = x, ycoord = y)
sprinvgauss(spcov_params_val, samples = 5, data = caribou, xcoord = x, ycoord = y)
</code></pre>

<hr>
<h2 id='sprnbinom'>Simulate a spatial negative binomial random variable</h2><span id='topic+sprnbinom'></span>

<h3>Description</h3>

<p>Simulate a spatial negative binomial random variable with a specific
mean and covariance structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sprnbinom(
  spcov_params,
  dispersion = 1,
  mean = 0,
  samples = 1,
  data,
  randcov_params,
  partition_factor,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sprnbinom_+3A_spcov_params">spcov_params</code></td>
<td>
<p>An <code><a href="#topic+spcov_params">spcov_params()</a></code> object.</p>
</td></tr>
<tr><td><code id="sprnbinom_+3A_dispersion">dispersion</code></td>
<td>
<p>The dispersion value.</p>
</td></tr>
<tr><td><code id="sprnbinom_+3A_mean">mean</code></td>
<td>
<p>A numeric vector representing the mean. <code>mean</code> must have length 1
(in which case it is recycled) or length equal
to the number of rows in <code>data</code>. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="sprnbinom_+3A_samples">samples</code></td>
<td>
<p>The number of independent samples to generate. The default
is <code>1</code>.</p>
</td></tr>
<tr><td><code id="sprnbinom_+3A_data">data</code></td>
<td>
<p>A data frame or <code>sf</code> object containing spatial information.</p>
</td></tr>
<tr><td><code id="sprnbinom_+3A_randcov_params">randcov_params</code></td>
<td>
<p>A <code><a href="#topic+randcov_params">randcov_params()</a></code> object.</p>
</td></tr>
<tr><td><code id="sprnbinom_+3A_partition_factor">partition_factor</code></td>
<td>
<p>A formula indicating the partition factor.</p>
</td></tr>
<tr><td><code id="sprnbinom_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+sprnorm">sprnorm()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of <code>spcov_params</code>, <code>mean</code>, and <code>randcov_params</code>
are assumed to be on the link scale. They are used to simulate a latent normal (Gaussian)
response variable using <code><a href="#topic+sprnorm">sprnorm()</a></code>. This latent variable is the
conditional mean used with <code>dispersion</code> to simulate a negative binomial random variable.
</p>


<h3>Value</h3>

<p>If <code>samples</code> is 1, a vector of random variables for each row of <code>data</code>
is returned. If <code>samples</code> is greater than one, a matrix of random variables
is returned, where the rows correspond to each row of <code>data</code> and the columns
correspond to independent samples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spcov_params_val &lt;- spcov_params("exponential", de = 0.2, ie = 0.1, range = 1)
sprnbinom(spcov_params_val, data = caribou, xcoord = x, ycoord = y)
sprnbinom(spcov_params_val, samples = 5, data = caribou, xcoord = x, ycoord = y)
</code></pre>

<hr>
<h2 id='sprnorm'>Simulate a spatial normal (Gaussian) random variable</h2><span id='topic+sprnorm'></span><span id='topic+sprnorm.exponential'></span><span id='topic+sprnorm.none'></span><span id='topic+sprnorm.car'></span>

<h3>Description</h3>

<p>Simulate a spatial normal (Gaussian) random variable with a specific
mean and covariance structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sprnorm(
  spcov_params,
  mean = 0,
  samples = 1,
  data,
  randcov_params,
  partition_factor,
  ...
)

## S3 method for class 'exponential'
sprnorm(
  spcov_params,
  mean = 0,
  samples = 1,
  data,
  randcov_params,
  partition_factor,
  xcoord,
  ycoord,
  ...
)

## S3 method for class 'none'
sprnorm(
  spcov_params,
  mean = 0,
  samples = 1,
  data,
  randcov_params,
  partition_factor,
  ...
)

## S3 method for class 'car'
sprnorm(
  spcov_params,
  mean = 0,
  samples = 1,
  data,
  randcov_params,
  partition_factor,
  W,
  row_st = TRUE,
  M,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sprnorm_+3A_spcov_params">spcov_params</code></td>
<td>
<p>An <code><a href="#topic+spcov_params">spcov_params()</a></code> object.</p>
</td></tr>
<tr><td><code id="sprnorm_+3A_mean">mean</code></td>
<td>
<p>A numeric vector representing the mean. <code>mean</code> must have length 1
(in which case it is recycled) or length equal
to the number of rows in <code>data</code>. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="sprnorm_+3A_samples">samples</code></td>
<td>
<p>The number of independent samples to generate. The default
is <code>1</code>.</p>
</td></tr>
<tr><td><code id="sprnorm_+3A_data">data</code></td>
<td>
<p>A data frame or <code>sf</code> object containing spatial information.</p>
</td></tr>
<tr><td><code id="sprnorm_+3A_randcov_params">randcov_params</code></td>
<td>
<p>A <code><a href="#topic+randcov_params">randcov_params()</a></code> object.</p>
</td></tr>
<tr><td><code id="sprnorm_+3A_partition_factor">partition_factor</code></td>
<td>
<p>A formula indicating the partition factor.</p>
</td></tr>
<tr><td><code id="sprnorm_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
<tr><td><code id="sprnorm_+3A_xcoord">xcoord</code></td>
<td>
<p>Name of the column in <code>data</code> representing the x-coordinate.
Can be quoted or unquoted. Not required if <code>data</code> are an <code>sf</code>
object.</p>
</td></tr>
<tr><td><code id="sprnorm_+3A_ycoord">ycoord</code></td>
<td>
<p>Name of the column in <code>data</code> representing the y-coordinate.
Can be quoted or unquoted. Not required if <code>data</code> are an <code>sf</code>
object.</p>
</td></tr>
<tr><td><code id="sprnorm_+3A_w">W</code></td>
<td>
<p>Weight matrix specifying the neighboring structure used for car and
sar models. Not required if <code>data</code> are an <code>sf</code>
polygon object and <code>W</code> should be calculated internally (using queen contiguity).</p>
</td></tr>
<tr><td><code id="sprnorm_+3A_row_st">row_st</code></td>
<td>
<p>A logical indicating whether row standardization be performed on
<code>W</code>. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sprnorm_+3A_m">M</code></td>
<td>
<p>M matrix satisfying the car symmetry condition. The car
symmetry condition states that <code class="reqn">(I - range * W)^{-1}M</code> is symmetric, where
<code class="reqn">I</code> is an identity matrix, <code class="reqn">range</code> is a constant that controls the
spatial dependence, <code>W</code> is the weights matrix,
and <code class="reqn">^{-1}</code> represents the inverse operator.
<code>M</code> is required for car models
when <code>W</code> is provided and <code>row_st</code> is <code>FALSE</code>.  When <code>M</code>,
is required, the default is the identity matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Random variables are simulated via the product of the covariance matrix's
square (Cholesky) root and independent standard normal random variables
with mean 0 and variance 1. Computing the square root is a significant
computational burden and likely unfeasible for sample sizes much past 10,000.
Because this square root only needs to be computed once, however, it is
nearly the sample computational cost to call <code>sprnorm()</code> for any value
of <code>samples</code>.
</p>
<p>Only methods for the <code>exponential</code>, <code>none</code>, and <code>car</code>
covariance functions are documented here,
but methods exist for all other spatial covariance functions defined in
<code><a href="#topic+spcov_initial">spcov_initial()</a></code>. Syntax for the <code>exponential</code> method is the same
as syntax for <code>spherical</code>, <code>gaussian</code>, <code>triangular</code>,
<code>circular</code>, <code>cubic</code>, <code>pentaspherical</code>, <code>cosine</code>, <code>wave</code>,
<code>jbessel</code>, <code>gravity</code>, <code>rquad</code>, <code>magnetic</code>, <code>matern</code>,
<code>cauchy</code>, and <code>pexponential</code> methods. Syntax for
the <code>car</code> method is the same as syntax for the <code>sar</code> method. The
<code>extra</code> parameter for car and sar models is ignored when all observations have
neighbors.
</p>


<h3>Value</h3>

<p>If <code>samples</code> is 1, a vector of random variables for each row of <code>data</code>
is returned. If <code>samples</code> is greater than one, a matrix of random variables
is returned, where the rows correspond to each row of <code>data</code> and the columns
correspond to independent samples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spcov_params_val &lt;- spcov_params("exponential", de = 1, ie = 1, range = 1)
sprnorm(spcov_params_val, data = caribou, xcoord = x, ycoord = y)
sprnorm(spcov_params_val, mean = 1:30, samples = 5, data = caribou, xcoord = x, ycoord = y)
</code></pre>

<hr>
<h2 id='sprpois'>Simulate a spatial Poisson random variable</h2><span id='topic+sprpois'></span>

<h3>Description</h3>

<p>Simulate a spatial Poisson random variable with a specific
mean and covariance structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sprpois(
  spcov_params,
  mean = 0,
  samples = 1,
  data,
  randcov_params,
  partition_factor,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sprpois_+3A_spcov_params">spcov_params</code></td>
<td>
<p>An <code><a href="#topic+spcov_params">spcov_params()</a></code> object.</p>
</td></tr>
<tr><td><code id="sprpois_+3A_mean">mean</code></td>
<td>
<p>A numeric vector representing the mean. <code>mean</code> must have length 1
(in which case it is recycled) or length equal
to the number of rows in <code>data</code>. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="sprpois_+3A_samples">samples</code></td>
<td>
<p>The number of independent samples to generate. The default
is <code>1</code>.</p>
</td></tr>
<tr><td><code id="sprpois_+3A_data">data</code></td>
<td>
<p>A data frame or <code>sf</code> object containing spatial information.</p>
</td></tr>
<tr><td><code id="sprpois_+3A_randcov_params">randcov_params</code></td>
<td>
<p>A <code><a href="#topic+randcov_params">randcov_params()</a></code> object.</p>
</td></tr>
<tr><td><code id="sprpois_+3A_partition_factor">partition_factor</code></td>
<td>
<p>A formula indicating the partition factor.</p>
</td></tr>
<tr><td><code id="sprpois_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+sprnorm">sprnorm()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of <code>spcov_params</code>, <code>mean</code>, and <code>randcov_params</code>
are assumed to be on the link scale. They are used to simulate a latent normal (Gaussian)
response variable using <code><a href="#topic+sprnorm">sprnorm()</a></code>. This latent variable is the
conditional mean used with <code>dispersion</code> to simulate a Poisson random variable.
</p>


<h3>Value</h3>

<p>If <code>samples</code> is 1, a vector of random variables for each row of <code>data</code>
is returned. If <code>samples</code> is greater than one, a matrix of random variables
is returned, where the rows correspond to each row of <code>data</code> and the columns
correspond to independent samples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spcov_params_val &lt;- spcov_params("exponential", de = 0.2, ie = 0.1, range = 1)
sprpois(spcov_params_val, data = caribou, xcoord = x, ycoord = y)
sprpois(spcov_params_val, samples = 5, data = caribou, xcoord = x, ycoord = y)
</code></pre>

<hr>
<h2 id='sulfate'>Sulfate atmospheric deposition in the conterminous USA</h2><span id='topic+sulfate'></span>

<h3>Description</h3>

<p>Sulfate atmospheric deposition in the conterminous USA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sulfate
</code></pre>


<h3>Format</h3>

<p>An <code>sf</code> object with 197 rows and 2 columns.
</p>

<ul>
<li><p> sulfate: Total wet deposition sulfate in kilograms per hectare.
</p>
</li>
<li><p> geometry: <code>POINT</code> geometry representing coordinates in a
Conus Albers projection (EPSG: 5070).
</p>
</li></ul>



<h3>Source</h3>

<p>These data were used in the publication listed in References. Data were downloaded from the
National Atmospheric Deposition Program National Trends Network.
</p>


<h3>References</h3>

<p>Zimmerman, D.L. (1994). Statistical analysis of spatial data. Pages 375-402 in
<em> Statistical Methods for Physical Science</em>, J. Stanford and
S. Vardeman (eds.), Academic Press: New York.
</p>

<hr>
<h2 id='sulfate_preds'>Locations at which to predict sulfate atmospheric deposition in the conterminous USA</h2><span id='topic+sulfate_preds'></span>

<h3>Description</h3>

<p>Locations at which to predict sulfate atmospheric deposition in the conterminous USA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sulfate_preds
</code></pre>


<h3>Format</h3>

<p>An <code>sf</code> object with 197 rows and 1 column.
</p>

<ul>
<li><p> geometry: <code>POINT</code> geometry representing coordinates in a
Conus Albers projection (EPSG: 5070).
</p>
</li></ul>



<h3>Source</h3>

<p>These data were used in the publication listed in References. Data were downloaded from
the National Atmospheric Deposition Program National Trends Network.
</p>


<h3>References</h3>

<p>Zimmerman, D.L. (1994). Statistical analysis of spatial data. Pages 375-402 in
<em> Statistical Methods for Physical Science</em>, J. Stanford and
S. Vardeman (eds.), Academic Press: New York.
</p>

<hr>
<h2 id='summary.spmodel'>Summarize a fitted model object</h2><span id='topic+summary.spmodel'></span><span id='topic+summary.splm'></span><span id='topic+summary.spautor'></span><span id='topic+summary.spglm'></span><span id='topic+summary.spgautor'></span>

<h3>Description</h3>

<p>Summarize a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splm'
summary(object, ...)

## S3 method for class 'spautor'
summary(object, ...)

## S3 method for class 'spglm'
summary(object, ...)

## S3 method for class 'spgautor'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.spmodel_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.spmodel_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary()</code> creates a summary of a fitted model object
intended to be printed using <code>print()</code>. This summary contains
useful information like the original function call, residuals,
a coefficients table, a pseudo r-squared, and estimated covariance
parameters.
</p>


<h3>Value</h3>

<p>A list with several fitted model quantities used to create
informative summaries when printing.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.spmodel">print.spmodel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
summary(spmod)
</code></pre>

<hr>
<h2 id='tidy.spmodel'>Tidy a fitted model object</h2><span id='topic+tidy.spmodel'></span><span id='topic+tidy.splm'></span><span id='topic+tidy.spautor'></span><span id='topic+tidy.spglm'></span><span id='topic+tidy.spgautor'></span>

<h3>Description</h3>

<p>Tidy a fitted model object into a summarized tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splm'
tidy(x, conf.int = FALSE, conf.level = 0.95, effects = "fixed", ...)

## S3 method for class 'spautor'
tidy(x, conf.int = FALSE, conf.level = 0.95, effects = "fixed", ...)

## S3 method for class 'spglm'
tidy(x, conf.int = FALSE, conf.level = 0.95, effects = "fixed", ...)

## S3 method for class 'spgautor'
tidy(x, conf.int = FALSE, conf.level = 0.95, effects = "fixed", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.spmodel_+3A_x">x</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.spmodel_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence interval
in the tidied output. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.spmodel_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval if
<code>conf.int</code> is <code>TRUE</code>. Must be strictly greater than 0 and less than 1.
The default is 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.spmodel_+3A_effects">effects</code></td>
<td>
<p>The type of effects to tidy. Available options are <code>"fixed"</code>
(fixed effects), <code>"spcov"</code> (spatial covariance parameters),
and <code>"randcov"</code> (random effect variances). The default is <code>"fixed"</code>.</p>
</td></tr>
<tr><td><code id="tidy.spmodel_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidy tibble of summary information <code>effects</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glance.spmodel">glance.spmodel()</a></code> <code><a href="#topic+augment.spmodel">augment.spmodel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
tidy(spmod)
tidy(spmod, effects = "spcov")
</code></pre>

<hr>
<h2 id='varcomp'>Variability component comparison</h2><span id='topic+varcomp'></span><span id='topic+varcomp.splm'></span><span id='topic+varcomp.spautor'></span><span id='topic+varcomp.spglm'></span><span id='topic+varcomp.spgautor'></span>

<h3>Description</h3>

<p>Compare the proportion of total variability explained by the fixed effects
and each variance parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varcomp(object, ...)

## S3 method for class 'splm'
varcomp(object, ...)

## S3 method for class 'spautor'
varcomp(object, ...)

## S3 method for class 'spglm'
varcomp(object, ...)

## S3 method for class 'spgautor'
varcomp(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varcomp_+3A_object">object</code></td>
<td>
<p>A fitted model object (e.g., from <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>).</p>
</td></tr>
<tr><td><code id="varcomp_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble that partitions the the total variability by the fixed effects
and each variance parameter. The proportion of variability explained by the
fixed effects is the pseudo R-squared obtained by <code>psuedoR2()</code>. The
remaining proportion is spread accordingly among each variance parameter:
<code>"de"</code>, <code>"ie"</code>, and if random effects are used, each named random effect.
If <code>spautor()</code> objects have unconnected sites, a list is returned with three elements:
<code>"connected"</code> for a variability comparison among the connected sites;
<code>"unconnected"</code> for a variability comparison among the unconnected
sites; and <code>"ratio"</code> for the ratio of the variance of the connected
sites relative to the variance of the unconnected sites.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
varcomp(spmod)
</code></pre>

<hr>
<h2 id='vcov.spmodel'>Calculate variance-covariance matrix for a fitted model object</h2><span id='topic+vcov.spmodel'></span><span id='topic+vcov.splm'></span><span id='topic+vcov.spautor'></span><span id='topic+vcov.spglm'></span><span id='topic+vcov.spgautor'></span>

<h3>Description</h3>

<p>Calculate variance-covariance matrix for a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splm'
vcov(object, ...)

## S3 method for class 'spautor'
vcov(object, ...)

## S3 method for class 'spglm'
vcov(object, var_correct = TRUE, ...)

## S3 method for class 'spgautor'
vcov(object, var_correct = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.spmodel_+3A_object">object</code></td>
<td>
<p>A fitted model object from <code><a href="#topic+splm">splm()</a></code>, <code><a href="#topic+spautor">spautor()</a></code>, <code><a href="#topic+spglm">spglm()</a></code>, or <code><a href="#topic+spgautor">spgautor()</a></code>.</p>
</td></tr>
<tr><td><code id="vcov.spmodel_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used (needed for generic consistency).</p>
</td></tr>
<tr><td><code id="vcov.spmodel_+3A_var_correct">var_correct</code></td>
<td>
<p>A logical indicating whether to return the corrected variance-covariance
matrix for models fit using <code><a href="#topic+spglm">spglm()</a></code> or <code><a href="#topic+spgautor">spgautor()</a></code>. The default is
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The variance-covariance matrix of coefficients obtained via <code>coef()</code>.
Currently, only the variance-covariance matrix of the fixed effects is supported.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmod &lt;- splm(z ~ water + tarp,
  data = caribou,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
vcov(spmod)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
