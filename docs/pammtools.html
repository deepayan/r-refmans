<!DOCTYPE html><html><head><title>Help for package pammtools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pammtools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#add_cif'><p>Add cumulative incidence function to data</p></a></li>
<li><a href='#add_hazard'><p>Add predicted (cumulative) hazard to data set</p></a></li>
<li><a href='#add_surv_prob'><p>Add survival probability estimates</p></a></li>
<li><a href='#add_tdc'><p>Add time-dependent covariate to a data set</p></a></li>
<li><a href='#add_term'><p>Embeds the data set with the specified (relative) term contribution</p></a></li>
<li><a href='#as_ped'><p>Transform data to Piece-wise Exponential Data (PED)</p></a></li>
<li><a href='#as_ped_cr'><p>Competing risks trafo</p></a></li>
<li><a href='#as.data.frame.crps'><p>Transform crps object to data.frame</p></a></li>
<li><a href='#calc_ci'><p>Calculate confidence intervals</p></a></li>
<li><a href='#combine_df'><p>Create a data frame from all combinations of data frames</p></a></li>
<li><a href='#compute_cumu_diff'><p>Calculate difference in cumulative hazards and respective standard errors</p></a></li>
<li><a href='#cumulative'><p>Formula specials for defining  time-dependent covariates</p></a></li>
<li><a href='#daily'><p>Time-dependent covariates of the <code>patient</code> data set.</p></a></li>
<li><a href='#dplyr_verbs'><p><code>dplyr</code> Verbs for <code>ped</code>-Objects</p></a></li>
<li><a href='#fcumu'><p>A formula special used to handle cumulative effect specifications</p></a></li>
<li><a href='#geom_hazard'><p>(Cumulative) (Step-) Hazard Plots.</p></a></li>
<li><a href='#geom_stepribbon'><p>Step ribbon plots.</p></a></li>
<li><a href='#get_cif'><p>Calculate CIF for one cause</p></a></li>
<li><a href='#get_cumu_coef'><p>Extract cumulative coefficients (cumulative hazard differences)</p></a></li>
<li><a href='#get_cumu_eff'><p>Calculate (or plot) cumulative effect for all time-points of the follow-up</p></a></li>
<li><a href='#get_cumu_hazard'><p>Calculate cumulative hazard</p></a></li>
<li><a href='#get_cumulative'><p>Expand time-dependent covariates to functionals</p></a></li>
<li><a href='#get_cut'><p>Obtain interval break points</p></a></li>
<li><a href='#get_event_types'><p>Exctract event types</p></a></li>
<li><a href='#get_hazard'><p>Calculate predicted hazard</p></a></li>
<li><a href='#get_intervals'><p>Information on intervals in which times fall</p></a></li>
<li><a href='#get_laglead'><p>Construct or extract data that represents a lag-lead window</p></a></li>
<li><a href='#get_lhs_vars'><p>Extract variables from the left-hand-side of a formula</p></a></li>
<li><a href='#get_ped_form'><p>Extract variables from the left-hand-side of a formula</p></a></li>
<li><a href='#get_plotinfo'><p>Extract plot information for all special model terms</p></a></li>
<li><a href='#get_sim_ci'><p>Calculate simulation based confidence intervals</p></a></li>
<li><a href='#get_surv_prob'><p>Calculate survival probabilities</p></a></li>
<li><a href='#get_tdc_form'><p>Extract variables from the left-hand-side of a formula</p></a></li>
<li><a href='#get_tdc_vars'><p>Extract variables from the left-hand-side of a formula</p></a></li>
<li><a href='#get_term'><p>Extract partial effects for specified model terms</p></a></li>
<li><a href='#get_terms'><p>Extract the partial effects of non-linear model terms</p></a></li>
<li><a href='#gg_fixed'><p>Forrest plot of fixed coefficients</p></a></li>
<li><a href='#gg_laglead'><p>Plot Lag-Lead windows</p></a></li>
<li><a href='#gg_partial'><p>Visualize effect estimates for specific covariate combinations</p></a></li>
<li><a href='#gg_re'><p>Plot Normal QQ plots for random effects</p></a></li>
<li><a href='#gg_slice'><p>Plot 1D (smooth) effects</p></a></li>
<li><a href='#gg_smooth'><p>Plot smooth 1d terms of gam objects</p></a></li>
<li><a href='#gg_tensor'><p>Plot tensor product effects</p></a></li>
<li><a href='#has_tdc'><p>Checks if data contains timd-dependent covariates</p></a></li>
<li><a href='#int_info'><p>Create start/end times and interval information</p></a></li>
<li><a href='#make_newdata'><p>Construct a data frame suitable for prediction</p></a></li>
<li><a href='#make_time_mat'><p>Create matrix components for cumulative effects</p></a></li>
<li><a href='#modus'><p>Calculate the modus</p></a></li>
<li><a href='#nest_tdc'><p>Create nested data frame from data with time-dependent covariates</p></a></li>
<li><a href='#pamm'><p>Fit a piece-wise exponential additive model</p></a></li>
<li><a href='#pammtools'><p>pammtools: Piece-wise exponential Additive Mixed Modeling tools.</p></a></li>
<li><a href='#patient'><p>Survival data of critically ill ICU patients</p></a></li>
<li><a href='#ped_info'><p>Extract interval information and median/modus values for covariates</p></a></li>
<li><a href='#predictSurvProb.pamm'><p>S3 method for pamm objects for compatibility with package pec</p></a></li>
<li><a href='#prep_concurrent'><p>Extract information on concurrent effects</p></a></li>
<li><a href='#rpexp'><p>Draw random numbers from piece-wise exponential distribution.</p></a></li>
<li><a href='#sample_info'><p>Extract information of the sample contained in a data set</p></a></li>
<li><a href='#seq_range'><p>Generate a sequence over the range of a vector</p></a></li>
<li><a href='#sim_pexp'><p>Simulate survival times from the piece-wise exponential distribution</p></a></li>
<li><a href='#sim_pexp_cr'><p>Simulate data for competing risks scenario</p></a></li>
<li><a href='#simdf_elra'><p>Simulated data with cumulative effects</p></a></li>
<li><a href='#split_data'><p>Function to transform data without time-dependent covariates into piece-wise</p>
exponential data format</a></li>
<li><a href='#split_data_multistate'><p>Split data to obtain recurrent event data in PED format</p></a></li>
<li><a href='#staph'><p>Time until staphylococcus aureaus infection in children, with possible recurrence</p></a></li>
<li><a href='#tidy_fixed'><p>Extract fixed coefficient table from model object</p></a></li>
<li><a href='#tidy_re'><p>Extract random effects in tidy data format.</p></a></li>
<li><a href='#tidy_smooth'><p>Extract 1d smooth objects in tidy data format.</p></a></li>
<li><a href='#tidy_smooth2d'><p>Extract 2d smooth objects in tidy format.</p></a></li>
<li><a href='#tumor'><p>Stomach area tumor data</p></a></li>
<li><a href='#warn_about_new_time_points'><p>Warn if new t_j are used</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Piece-Wise Exponential Additive Mixed Modeling Tools for
Survival Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.93</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-24</td>
</tr>
<tr>
<td>Description:</td>
<td>The Piece-wise exponential (Additive Mixed) Model
    (PAMM; Bender and others (2018) &lt;<a href="https://doi.org/10.1177%2F1471082X17748083">doi:10.1177/1471082X17748083</a>&gt;) is a
    powerful model class for the analysis of survival (or time-to-event) data,
    based on Generalized Additive (Mixed) Models (GA(M)Ms). It offers intuitive specification and robust estimation of complex survival models with stratified baseline hazards, random effects, time-varying effects, time-dependent covariates and cumulative effects (Bender and others (2019)), as well as support for left-truncated, competing risks and recurrent events data.
    pammtools provides tidy workflow for survival analysis with PAMMs,
    including data simulation, transformation and other functions for data
    preprocessing and model post-processing as well as visualization.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>mgcv, survival (&ge; 2.39-5), checkmate, magrittr, rlang, tidyr
(&ge; 1.0.0), ggplot2 (&ge; 3.2.2), dplyr (&ge; 1.0.0), purrr (&ge;
0.2.3), tibble, lazyeval, Formula, mvtnorm, pec, vctrs (&ge;
0.3.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>coxme, eha, etm, scam, TBFmultinomial</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://adibender.github.io/pammtools/">https://adibender.github.io/pammtools/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/adibender/pammtools/issues">https://github.com/adibender/pammtools/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-25 09:45:24 UTC; ab</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Bender <a href="https://orcid.org/0000-0001-5628-8611"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Fabian Scheipl <a href="https://orcid.org/0000-0001-8172-3603"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Philipp Kopper <a href="https://orcid.org/0000-0002-5037-7135"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Lukas Burk <a href="https://orcid.org/0000-0001-7528-3795"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Bender &lt;andreas.bender@stat.uni-muenchen.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-25 10:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic++25+3E+25">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='add_cif'>Add cumulative incidence function to data</h2><span id='topic+add_cif'></span><span id='topic+add_cif.default'></span>

<h3>Description</h3>

<p>Add cumulative incidence function to data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_cif(newdata, object, ...)

## Default S3 method:
add_cif(
  newdata,
  object,
  ci = TRUE,
  overwrite = FALSE,
  alpha = 0.05,
  n_sim = 500L,
  cause_var = "cause",
  time_var = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_cif_+3A_newdata">newdata</code></td>
<td>
<p> A data frame or list containing the values of the model covariates at which predictions
are required. If this is not provided then predictions corresponding to the
original data are returned. If <code>newdata</code> is provided then
it should contain all the variables needed for prediction: a
warning is generated if not. See details for use with <code>link{linear.functional.terms}</code>. </p>
</td></tr>
<tr><td><code id="add_cif_+3A_object">object</code></td>
<td>
<p> a fitted <code>gam</code> object as produced by <code>gam()</code>.
</p>
</td></tr>
<tr><td><code id="add_cif_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code> and
<code><a href="#topic+get_hazard">get_hazard</a></code></p>
</td></tr>
<tr><td><code id="add_cif_+3A_ci">ci</code></td>
<td>
<p><code>logical</code>. Indicates if confidence intervals should be
calculated. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="add_cif_+3A_overwrite">overwrite</code></td>
<td>
<p>Should hazard columns be overwritten if already present in
the data set? Defaults to <code>FALSE</code>. If <code>TRUE</code>, columns with names
<code>c("hazard", "se", "lower", "upper")</code> will be overwritten.</p>
</td></tr>
<tr><td><code id="add_cif_+3A_alpha">alpha</code></td>
<td>
<p>The alpha level for confidence/credible intervals.</p>
</td></tr>
<tr><td><code id="add_cif_+3A_n_sim">n_sim</code></td>
<td>
<p>Number of simulations (draws from posterior of estimated coefficients)
on which estimation of CIFs and their confidence/credible intervals will be
based on.</p>
</td></tr>
<tr><td><code id="add_cif_+3A_cause_var">cause_var</code></td>
<td>
<p>Character. Column name of the 'cause' variable.</p>
</td></tr>
<tr><td><code id="add_cif_+3A_time_var">time_var</code></td>
<td>
<p>Name of the variable used for the baseline hazard. If
not given, defaults to <code>"tend"</code> for <code><a href="mgcv.html#topic+gam">gam</a></code> fits, else
<code>"interval"</code>. The latter is assumed to be a factor, the former
numeric.</p>
</td></tr>
</table>

<hr>
<h2 id='add_hazard'>Add predicted (cumulative) hazard to data set</h2><span id='topic+add_hazard'></span><span id='topic+add_hazard.default'></span><span id='topic+add_cumu_hazard'></span>

<h3>Description</h3>

<p>Add (cumulative) hazard based on the provided data set and model.
If <code>ci=TRUE</code> confidence intervals (CI) are also added. Their width can
be controlled via the <code>se_mult</code> argument. The method by which the
CI are calculated can be specified by <code>ci_type</code>.
This is a wrapper around
<code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code>. When <code>reference</code> is specified, the
(log-)hazard ratio is calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_hazard(newdata, object, ...)

## Default S3 method:
add_hazard(
  newdata,
  object,
  reference = NULL,
  type = c("response", "link"),
  ci = TRUE,
  se_mult = 2,
  ci_type = c("default", "delta", "sim"),
  overwrite = FALSE,
  time_var = NULL,
  ...
)

add_cumu_hazard(
  newdata,
  object,
  ci = TRUE,
  se_mult = 2,
  overwrite = FALSE,
  time_var = NULL,
  interval_length = "intlen",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_hazard_+3A_newdata">newdata</code></td>
<td>
<p> A data frame or list containing the values of the model covariates at which predictions
are required. If this is not provided then predictions corresponding to the
original data are returned. If <code>newdata</code> is provided then
it should contain all the variables needed for prediction: a
warning is generated if not. See details for use with <code>link{linear.functional.terms}</code>. </p>
</td></tr>
<tr><td><code id="add_hazard_+3A_object">object</code></td>
<td>
<p> a fitted <code>gam</code> object as produced by <code>gam()</code>.
</p>
</td></tr>
<tr><td><code id="add_hazard_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code> and
<code><a href="#topic+get_hazard">get_hazard</a></code></p>
</td></tr>
<tr><td><code id="add_hazard_+3A_reference">reference</code></td>
<td>
<p>A data frame with number of rows equal to <code>nrow(newdata)</code> or
one, or a named list with (partial) covariate specifications. See examples.</p>
</td></tr>
<tr><td><code id="add_hazard_+3A_type">type</code></td>
<td>
<p>Either <code>"response"</code> or <code>"link"</code>. The former calculates
hazard, the latter the log-hazard.</p>
</td></tr>
<tr><td><code id="add_hazard_+3A_ci">ci</code></td>
<td>
<p><code>logical</code>. Indicates if confidence intervals should be
calculated. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="add_hazard_+3A_se_mult">se_mult</code></td>
<td>
<p>Factor by which standard errors are multiplied for calculating
the confidence intervals.</p>
</td></tr>
<tr><td><code id="add_hazard_+3A_ci_type">ci_type</code></td>
<td>
<p>The method by which standard errors/confidence intervals
will be calculated. Default transforms the linear predictor at
respective intervals. <code>"delta"</code> calculates CIs based on the standard
error calculated by the Delta method. <code>"sim"</code> draws the
property of interest from its posterior based on the normal distribution of
the estimated coefficients. See <a href="https://adibender.github.io/simpamm/confidence-intervals.html">here</a>
for details and empirical evaluation.</p>
</td></tr>
<tr><td><code id="add_hazard_+3A_overwrite">overwrite</code></td>
<td>
<p>Should hazard columns be overwritten if already present in
the data set? Defaults to <code>FALSE</code>. If <code>TRUE</code>, columns with names
<code>c("hazard", "se", "lower", "upper")</code> will be overwritten.</p>
</td></tr>
<tr><td><code id="add_hazard_+3A_time_var">time_var</code></td>
<td>
<p>Name of the variable used for the baseline hazard. If
not given, defaults to <code>"tend"</code> for <code><a href="mgcv.html#topic+gam">gam</a></code> fits, else
<code>"interval"</code>. The latter is assumed to be a factor, the former
numeric.</p>
</td></tr>
<tr><td><code id="add_hazard_+3A_interval_length">interval_length</code></td>
<td>
<p>The variable in newdata containing the interval lengths.
Can be either bare unquoted variable name or character. Defaults to <code>"intlen"</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code>,
<code><a href="#topic+add_surv_prob">add_surv_prob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped &lt;- tumor[1:50,] %&gt;% as_ped(Surv(days, status)~ age)
pam &lt;- mgcv::gam(ped_status ~ s(tend)+age, data = ped, family=poisson(), offset=offset)
ped_info(ped) %&gt;% add_hazard(pam, type="link")
ped_info(ped) %&gt;% add_hazard(pam, type = "response")
ped_info(ped) %&gt;% add_cumu_hazard(pam)
</code></pre>

<hr>
<h2 id='add_surv_prob'>Add survival probability estimates</h2><span id='topic+add_surv_prob'></span>

<h3>Description</h3>

<p>Given suitable data (i.e. data with all columns used for estimation of the model),
this functions adds a column <code>surv_prob</code> containing survival probabilities
for the specified covariate and follow-up information (and CIs
<code>surv_lower</code>, <code>surv_upper</code> if <code>ci=TRUE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_surv_prob(
  newdata,
  object,
  ci = TRUE,
  se_mult = 2,
  overwrite = FALSE,
  time_var = NULL,
  interval_length = "intlen",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_surv_prob_+3A_newdata">newdata</code></td>
<td>
<p> A data frame or list containing the values of the model covariates at which predictions
are required. If this is not provided then predictions corresponding to the
original data are returned. If <code>newdata</code> is provided then
it should contain all the variables needed for prediction: a
warning is generated if not. See details for use with <code>link{linear.functional.terms}</code>. </p>
</td></tr>
<tr><td><code id="add_surv_prob_+3A_object">object</code></td>
<td>
<p> a fitted <code>gam</code> object as produced by <code>gam()</code>.
</p>
</td></tr>
<tr><td><code id="add_surv_prob_+3A_ci">ci</code></td>
<td>
<p><code>logical</code>. Indicates if confidence intervals should be
calculated. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="add_surv_prob_+3A_se_mult">se_mult</code></td>
<td>
<p>Factor by which standard errors are multiplied for calculating
the confidence intervals.</p>
</td></tr>
<tr><td><code id="add_surv_prob_+3A_overwrite">overwrite</code></td>
<td>
<p>Should hazard columns be overwritten if already present in
the data set? Defaults to <code>FALSE</code>. If <code>TRUE</code>, columns with names
<code>c("hazard", "se", "lower", "upper")</code> will be overwritten.</p>
</td></tr>
<tr><td><code id="add_surv_prob_+3A_time_var">time_var</code></td>
<td>
<p>Name of the variable used for the baseline hazard. If
not given, defaults to <code>"tend"</code> for <code><a href="mgcv.html#topic+gam">gam</a></code> fits, else
<code>"interval"</code>. The latter is assumed to be a factor, the former
numeric.</p>
</td></tr>
<tr><td><code id="add_surv_prob_+3A_interval_length">interval_length</code></td>
<td>
<p>The variable in newdata containing the interval lengths.
Can be either bare unquoted variable name or character. Defaults to <code>"intlen"</code>.</p>
</td></tr>
<tr><td><code id="add_surv_prob_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code> and
<code><a href="#topic+get_hazard">get_hazard</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code>,
<code><a href="#topic+add_surv_prob">add_surv_prob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped &lt;- tumor[1:50,] %&gt;% as_ped(Surv(days, status)~ age)
pam &lt;- mgcv::gam(ped_status ~ s(tend)+age, data=ped, family=poisson(), offset=offset)
ped_info(ped) %&gt;% add_surv_prob(pam, ci=TRUE)
</code></pre>

<hr>
<h2 id='add_tdc'>Add time-dependent covariate to a data set</h2><span id='topic+add_tdc'></span>

<h3>Description</h3>

<p>Given a data set in standard format (with one row per subject/observation),
this function adds a column with the specified exposure time points
and a column with respective exposures, created from <code>rng_fun</code>.
This function should usually only be used to create data sets passed
to <code><a href="#topic+sim_pexp">sim_pexp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_tdc(data, tz, rng_fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_tdc_+3A_data">data</code></td>
<td>
<p>A data set with variables specified in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="add_tdc_+3A_tz">tz</code></td>
<td>
<p>A numeric vector of exposure times (relative to the
beginning of the follow-up time <code>t</code>)</p>
</td></tr>
<tr><td><code id="add_tdc_+3A_rng_fun">rng_fun</code></td>
<td>
<p>A random number generating function that creates
the time-dependent covariates at time points <code>tz</code>.
First argument of the function should be <code>n</code>, the number of
random numbers to generate. Within <code>add_tdc</code>, <code>n</code> will be set
to <code>length(tz)</code>.</p>
</td></tr>
<tr><td><code id="add_tdc_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>

<hr>
<h2 id='add_term'>Embeds the data set with the specified (relative) term contribution</h2><span id='topic+add_term'></span>

<h3>Description</h3>

<p>Adds the contribution of a specific term to the
linear predictor to the data specified by <code>newdata</code>.
Essentially a wrapper to <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code>, with <code>type="terms"</code>.
Thus most arguments and their documentation below is from <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_term(newdata, object, term, reference = NULL, ci = TRUE, se_mult = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_term_+3A_newdata">newdata</code></td>
<td>
<p> A data frame or list containing the values of the model covariates at which predictions
are required. If this is not provided then predictions corresponding to the
original data are returned. If <code>newdata</code> is provided then
it should contain all the variables needed for prediction: a
warning is generated if not. See details for use with <code>link{linear.functional.terms}</code>. </p>
</td></tr>
<tr><td><code id="add_term_+3A_object">object</code></td>
<td>
<p> a fitted <code>gam</code> object as produced by <code>gam()</code>.
</p>
</td></tr>
<tr><td><code id="add_term_+3A_term">term</code></td>
<td>
<p>A character (vector) or regular expression indicating for
which term(s) information should be extracted and added to data set.</p>
</td></tr>
<tr><td><code id="add_term_+3A_reference">reference</code></td>
<td>
<p>A data frame with number of rows equal to <code>nrow(newdata)</code> or
one, or a named list with (partial) covariate specifications. See examples.</p>
</td></tr>
<tr><td><code id="add_term_+3A_ci">ci</code></td>
<td>
<p><code>logical</code>. Indicates if confidence intervals should be
calculated. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="add_term_+3A_se_mult">se_mult</code></td>
<td>
<p>The factor by which standard errors are multiplied to form
confidence intervals.</p>
</td></tr>
<tr><td><code id="add_term_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
ped &lt;- as_ped(tumor, Surv(days, status)~ age, cut = seq(0, 2000, by = 100))
pam &lt;- mgcv::gam(ped_status ~ s(tend) + s(age), family = poisson(),
  offset = offset, data = ped)
#term contribution for sequence of ages
s_age &lt;- ped %&gt;% make_newdata(age = seq_range(age, 50)) %&gt;%
  add_term(pam, term = "age")
ggplot(s_age, aes(x = age, y = fit)) + geom_line() +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = .3)
# term contribution relative to mean age
s_age2 &lt;- ped %&gt;% make_newdata(age = seq_range(age, 50)) %&gt;%
  add_term(pam, term = "age", reference = list(age = mean(.$age)))
ggplot(s_age2, aes(x = age, y = fit)) + geom_line() +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = .3)
</code></pre>

<hr>
<h2 id='as_ped'>Transform data to Piece-wise Exponential Data (PED)</h2><span id='topic+as_ped'></span><span id='topic+as_ped.data.frame'></span><span id='topic+as_ped.nested_fdf'></span><span id='topic+as_ped.list'></span><span id='topic+is.ped'></span><span id='topic+as_ped.ped'></span><span id='topic+as_ped.pamm'></span><span id='topic+as_ped_multistate'></span>

<h3>Description</h3>

<p>This is the general data transformation function provided by the
<code>pammtools</code> package. Two main applications must be distinguished:
</p>

<ol>
<li><p> Transformation of standard time-to-event data.
</p>
</li>
<li><p> Transformation of left-truncated time-to-event data.
</p>
</li>
<li><p> Transformation of time-to-event data with time-dependent covariates (TDC).
</p>
</li></ol>

<p>For the latter, the type of effect one wants to estimate is also
important for the data transformation step.
In any case, the data transformation is specified by a two sided formula.
In case of TDCs, the right-hand-side of the formula can contain formula specials
<code>concurrent</code> and <code>cumulative</code>.
See the <a href="https://adibender.github.io/pammtools//articles/data-transformation.html">data-transformation</a>
vignette for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_ped(data, ...)

## S3 method for class 'data.frame'
as_ped(
  data,
  formula,
  cut = NULL,
  max_time = NULL,
  tdc_specials = c("concurrent", "cumulative"),
  censor_code = 0L,
  transition = character(),
  timescale = c("gap", "calendar"),
  min_events = 1L,
  ...
)

## S3 method for class 'nested_fdf'
as_ped(data, formula, ...)

## S3 method for class 'list'
as_ped(
  data,
  formula,
  tdc_specials = c("concurrent", "cumulative"),
  censor_code = 0L,
  ...
)

is.ped(x)

## S3 method for class 'ped'
as_ped(data, newdata, ...)

## S3 method for class 'pamm'
as_ped(data, newdata, ...)

as_ped_multistate(
  data,
  formula,
  cut = NULL,
  max_time = NULL,
  tdc_specials = c("concurrent", "cumulative"),
  censor_code = 0L,
  transition = character(),
  timescale = c("gap", "calendar"),
  min_events = 1L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_ped_+3A_data">data</code></td>
<td>
<p>Either an object inheriting from data frame or in case of
time-dependent covariates a list of data frames (of length 2), where the first data frame
contains the time-to-event information and static covariates while the second
(and potentially further data frames) contain information on time-dependent
covariates and the times at which they have been observed.</p>
</td></tr>
<tr><td><code id="as_ped_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code>data.frame</code> method and
eventually to <code><a href="survival.html#topic+survSplit">survSplit</a></code></p>
</td></tr>
<tr><td><code id="as_ped_+3A_formula">formula</code></td>
<td>
<p>A two sided formula with a <code><a href="survival.html#topic+Surv">Surv</a></code> object
on the left-hand-side and covariate specification on the right-hand-side (RHS).
The RHS can be an extended formula, which specifies how TDCs should be transformed
using specials <code>concurrent</code> and <code>cumulative</code>. The left hand-side can
be in start-stop-notation. This, however, is only used to create left-truncated
data and does not support the full functionality.</p>
</td></tr>
<tr><td><code id="as_ped_+3A_cut">cut</code></td>
<td>
<p>Split points, used to partition the follow up into intervals.
If unspecified, all unique event times will be used.</p>
</td></tr>
<tr><td><code id="as_ped_+3A_max_time">max_time</code></td>
<td>
<p>If <code>cut</code> is unspecified, this will be the last
possible event time. All event times after <code>max_time</code>
will be administratively censored at <code>max_time</code>.</p>
</td></tr>
<tr><td><code id="as_ped_+3A_tdc_specials">tdc_specials</code></td>
<td>
<p>A character vector. Names of potential specials in
<code>formula</code> for concurrent and or cumulative effects.</p>
</td></tr>
<tr><td><code id="as_ped_+3A_censor_code">censor_code</code></td>
<td>
<p>Specifies the value of the status variable that indicates censoring.
Often this will be <code>0</code>, which is the default.</p>
</td></tr>
<tr><td><code id="as_ped_+3A_x">x</code></td>
<td>
<p>any R object.</p>
</td></tr>
<tr><td><code id="as_ped_+3A_newdata">newdata</code></td>
<td>
<p>A new data set (<code>data.frame</code>) that contains the same
variables that were used to create the PED object (<code>data</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame class <code>ped</code> in piece-wise exponential data format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tumor[1:3, ]
tumor[1:3, ] %&gt;% as_ped(Surv(days, status)~ age + sex, cut = c(0, 500, 1000))
tumor[1:3, ] %&gt;% as_ped(Surv(days, status)~ age + sex)
## Not run: 
data("cgd", package = "frailtyHL")
cgd2 &lt;- cgd %&gt;%
 select(id, tstart, tstop, enum, status, age) %&gt;%
 filter(enum %in% c(1:2))
ped_re &lt;- as_ped_multistate(
  formula = Surv(tstart, tstop, status) ~ age + enum,
  data = cgd2,
 transition = "enum",
 timescale = "calendar")

## End(Not run)
</code></pre>

<hr>
<h2 id='as_ped_cr'>Competing risks trafo</h2><span id='topic+as_ped_cr'></span>

<h3>Description</h3>

<p>This is the general data transformation function provided by the
<code>pammtools</code> package. Two main applications must be distinguished:
</p>

<ol>
<li><p> Transformation of standard time-to-event data.
</p>
</li>
<li><p> Transformation of left-truncated time-to-event data.
</p>
</li>
<li><p> Transformation of time-to-event data with time-dependent covariates (TDC).
</p>
</li></ol>

<p>For the latter, the type of effect one wants to estimate is also
important for the data transformation step.
In any case, the data transformation is specified by a two sided formula.
In case of TDCs, the right-hand-side of the formula can contain formula specials
<code>concurrent</code> and <code>cumulative</code>.
See the <a href="https://adibender.github.io/pammtools//articles/data-transformation.html">data-transformation</a>
vignette for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_ped_cr(
  data,
  formula,
  cut = NULL,
  max_time = NULL,
  tdc_specials = c("concurrent", "cumulative"),
  censor_code = 0L,
  combine = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_ped_cr_+3A_data">data</code></td>
<td>
<p>Either an object inheriting from data frame or in case of
time-dependent covariates a list of data frames (of length 2), where the first data frame
contains the time-to-event information and static covariates while the second
(and potentially further data frames) contain information on time-dependent
covariates and the times at which they have been observed.</p>
</td></tr>
<tr><td><code id="as_ped_cr_+3A_formula">formula</code></td>
<td>
<p>A two sided formula with a <code><a href="survival.html#topic+Surv">Surv</a></code> object
on the left-hand-side and covariate specification on the right-hand-side (RHS).
The RHS can be an extended formula, which specifies how TDCs should be transformed
using specials <code>concurrent</code> and <code>cumulative</code>. The left hand-side can
be in start-stop-notation. This, however, is only used to create left-truncated
data and does not support the full functionality.</p>
</td></tr>
<tr><td><code id="as_ped_cr_+3A_cut">cut</code></td>
<td>
<p>Split points, used to partition the follow up into intervals.
If unspecified, all unique event times will be used.</p>
</td></tr>
<tr><td><code id="as_ped_cr_+3A_max_time">max_time</code></td>
<td>
<p>If <code>cut</code> is unspecified, this will be the last
possible event time. All event times after <code>max_time</code>
will be administratively censored at <code>max_time</code>.</p>
</td></tr>
<tr><td><code id="as_ped_cr_+3A_tdc_specials">tdc_specials</code></td>
<td>
<p>A character vector. Names of potential specials in
<code>formula</code> for concurrent and or cumulative effects.</p>
</td></tr>
<tr><td><code id="as_ped_cr_+3A_censor_code">censor_code</code></td>
<td>
<p>Specifies the value of the status variable that indicates censoring.
Often this will be <code>0</code>, which is the default.</p>
</td></tr>
<tr><td><code id="as_ped_cr_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code>data.frame</code> method and
eventually to <code><a href="survival.html#topic+survSplit">survSplit</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame class <code>ped</code> in piece-wise exponential data format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tumor[1:3, ]
tumor[1:3, ] %&gt;% as_ped(Surv(days, status)~ age + sex, cut = c(0, 500, 1000))
tumor[1:3, ] %&gt;% as_ped(Surv(days, status)~ age + sex)
## Not run: 
data("cgd", package = "frailtyHL")
cgd2 &lt;- cgd %&gt;%
 select(id, tstart, tstop, enum, status, age) %&gt;%
 filter(enum %in% c(1:2))
ped_re &lt;- as_ped_multistate(
  formula = Surv(tstart, tstop, status) ~ age + enum,
  data = cgd2,
 transition = "enum",
 timescale = "calendar")

## End(Not run)
</code></pre>

<hr>
<h2 id='as.data.frame.crps'>Transform crps object to data.frame</h2><span id='topic+as.data.frame.crps'></span>

<h3>Description</h3>

<p>A<code>as.data.frame</code> S3 method for objects of class <code><a href="pec.html#topic+crps">crps</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'crps'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.crps_+3A_x">x</code></td>
<td>
<p>An object of class <code>crps</code>. See <code><a href="pec.html#topic+crps">crps</a></code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.crps_+3A_row.names">row.names</code></td>
<td>
<p><code>NULL</code> or a character vector giving the row
names for the data frame.  Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="as.data.frame.crps_+3A_optional">optional</code></td>
<td>
<p>logical. If <code>TRUE</code>, setting row names and
converting column names (to syntactic names: see
<code><a href="base.html#topic+make.names">make.names</a></code>) is optional.  Note that all of <span class="rlang"><b>R</b></span>'s
<span class="pkg">base</span> package <code>as.data.frame()</code> methods use
<code>optional</code> only for column names treatment, basically with the
meaning of <code><a href="base.html#topic+data.frame">data.frame</a>(*, check.names = !optional)</code>.
See also the <code>make.names</code> argument of the <code>matrix</code> method.</p>
</td></tr>
<tr><td><code id="as.data.frame.crps_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from methods.</p>
</td></tr>
</table>

<hr>
<h2 id='calc_ci'>Calculate confidence intervals</h2><span id='topic+calc_ci'></span>

<h3>Description</h3>

<p>Given 2 column matrix or data frame, returns 3 column data.frame
with coefficient estimate plus lower and upper borders of the
95% confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_ci(ftab)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_ci_+3A_ftab">ftab</code></td>
<td>
<p>A table with two columns, containing coefficients in the first
column and standard-errors in the second column.</p>
</td></tr>
</table>

<hr>
<h2 id='combine_df'>Create a data frame from all combinations of data frames</h2><span id='topic+combine_df'></span>

<h3>Description</h3>

<p>Works like <code><a href="base.html#topic+expand.grid">expand.grid</a></code> but for data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_df(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_df_+3A_...">...</code></td>
<td>
<p>Data frames that should be combined to one data frame.
Elements of first df vary fastest, elements of last df vary slowest.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>combine_df(
  data.frame(x=1:3, y=3:1),
  data.frame(x1=c("a", "b"), x2=c("c", "d")),
  data.frame(z=c(0, 1)))
</code></pre>

<hr>
<h2 id='compute_cumu_diff'>Calculate difference in cumulative hazards and respective standard errors</h2><span id='topic+compute_cumu_diff'></span>

<h3>Description</h3>

<p>CIs are calculated by sampling coefficients from their posterior and
calculating the cumulative hazard difference <code>nsim</code> times. The CI
are obtained by the 2.5\
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_cumu_diff(d1, d2, model, alpha = 0.05, nsim = 100L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_cumu_diff_+3A_d1">d1</code></td>
<td>
<p>A data set used as <code>newdata</code> in <code>predict.gam</code></p>
</td></tr>
<tr><td><code id="compute_cumu_diff_+3A_d2">d2</code></td>
<td>
<p>See <code>d1</code></p>
</td></tr>
<tr><td><code id="compute_cumu_diff_+3A_model">model</code></td>
<td>
<p>A model object for which a predict method is implemented which
returns the design matrix (e.g., <code>mgcv::gam</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='cumulative'>Formula specials for defining  time-dependent covariates</h2><span id='topic+cumulative'></span><span id='topic+concurrent'></span><span id='topic+has_special'></span>

<h3>Description</h3>

<p>So far, two specials are implemented. <code>concurrent</code> is used when
the goal is to estimate a concurrent effect of the TDC. <code>cumulative</code>
is used when the goal is to estimate a cumulative effect of the TDC. These
should usually not be called directly but rather as part of the <code>formula</code>
argument to <code>as_ped</code>.
See the <a href="https://adibender.github.io/pammtools//articles/data-transformation.html">vignette on data transformation</a>
for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumulative(..., tz_var, ll_fun = function(t, tz) t &gt;= tz, suffix = NULL)

concurrent(..., tz_var, lag = 0, suffix = NULL)

has_special(formula, special = "cumulative")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumulative_+3A_...">...</code></td>
<td>
<p>For <code>concurrent</code> variables that will be transformed to
covariate matrices. The number of columns of each covariate depends on <code>tz</code>.
Usually, elements that will be specified here are <code>time</code> (which should be
the name of the time-variable used on the LHS of the formula argument to
<code>as_ped</code>), <code>tz</code> which is the variable containing information on
the times at which the TDC was observed (can be wrapped in <code>latency</code>) and
the TDCs that share the same <code>tz</code> and Lag-lead window (<code>ll_fun</code>).</p>
</td></tr>
<tr><td><code id="cumulative_+3A_tz_var">tz_var</code></td>
<td>
<p>The name of the variable that stores information on the
times at which the TDCs specified in this term where observed.</p>
</td></tr>
<tr><td><code id="cumulative_+3A_ll_fun">ll_fun</code></td>
<td>
<p>Function that specifies how the lag-lead matrix
should be constructed. First argument is the follow up time
second argument is the time of exposure.</p>
</td></tr>
<tr><td><code id="cumulative_+3A_lag">lag</code></td>
<td>
<p>a single positive number giving the time lag between for
a concurrent effect to occur (i.e., the TDC at time of exposure <code>t-lag</code>
affects the hazard in the interval containing follow-up time <code>t</code>).
Defaults to 0.</p>
</td></tr>
<tr><td><code id="cumulative_+3A_formula">formula</code></td>
<td>
<p>A two sided formula with a <code><a href="survival.html#topic+Surv">Surv</a></code> object
on the left-hand-side and covariate specification on the right-hand-side (RHS).
The RHS can be an extended formula, which specifies how TDCs should be transformed
using specials <code>concurrent</code> and <code>cumulative</code>. The left hand-side can
be in start-stop-notation. This, however, is only used to create left-truncated
data and does not support the full functionality.</p>
</td></tr>
<tr><td><code id="cumulative_+3A_special">special</code></td>
<td>
<p>The name of the special whose existence in the
<code>formula</code> should be checked</p>
</td></tr>
</table>

<hr>
<h2 id='daily'>Time-dependent covariates of the <code><a href="#topic+patient">patient</a></code> data set.</h2><span id='topic+daily'></span>

<h3>Description</h3>

<p>This data set contains the time-dependent covariates (TDCs) for the <code><a href="#topic+patient">patient</a></code>
data set. Note that nutrition was protocoled for at most 12 days after
ICU admission. The data set includes:
</p>

<dl>
<dt>CombinedID</dt><dd><p>Unique patient identifier. Can be used to merge with
<code><a href="#topic+patient">patient</a></code> data</p>
</dd>
<dt>Study_Day</dt><dd><p>The calendar (!) day at which calories (or proteins) were
administered</p>
</dd>
<dt>caloriesPercentage</dt><dd><p>The percentage of target calories supplied to the
patient by the ICU staff</p>
</dd>
<dt>proteinGproKG</dt><dd><p>The amount of protein supplied to the patient by the
ICU staff</p>
</dd></dl>



<h3>Usage</h3>

<pre><code class='language-R'>daily
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 18797 rows and 4 columns.
</p>

<hr>
<h2 id='dplyr_verbs'><code>dplyr</code> Verbs for <code>ped</code>-Objects</h2><span id='topic+dplyr_verbs'></span><span id='topic+arrange'></span><span id='topic+filter'></span><span id='topic+distinct'></span><span id='topic+full_join'></span><span id='topic+group_by'></span><span id='topic+inner_join'></span><span id='topic+left_join'></span><span id='topic+mutate'></span><span id='topic+rename'></span><span id='topic+right_join'></span><span id='topic+sample_frac'></span><span id='topic+sample_n'></span><span id='topic+select'></span><span id='topic+slice'></span><span id='topic+summarise'></span><span id='topic+transmute'></span><span id='topic+ungroup'></span><span id='topic+arrange.ped'></span><span id='topic+group_by.ped'></span><span id='topic+ungroup.ped'></span><span id='topic+distinct.ped'></span><span id='topic+filter.ped'></span><span id='topic+sample_n.ped'></span><span id='topic+sample_frac.ped'></span><span id='topic+slice.ped'></span><span id='topic+select.ped'></span><span id='topic+mutate.ped'></span><span id='topic+rename.ped'></span><span id='topic+summarise.ped'></span><span id='topic+summarize.ped'></span><span id='topic+transmute.ped'></span><span id='topic+inner_join.ped'></span><span id='topic+full_join.ped'></span><span id='topic+left_join.ped'></span><span id='topic+right_join.ped'></span>

<h3>Description</h3>

<p>See <code>dplyr</code> documentation of the respective functions for
description and examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ped'
arrange(.data, ...)

## S3 method for class 'ped'
group_by(.data, ..., .add = FALSE)

## S3 method for class 'ped'
ungroup(x, ...)

## S3 method for class 'ped'
distinct(.data, ..., .keep_all = FALSE)

## S3 method for class 'ped'
filter(.data, ...)

## S3 method for class 'ped'
sample_n(tbl, size, replace = FALSE, weight = NULL, .env = NULL, ...)

## S3 method for class 'ped'
sample_frac(tbl, size = 1, replace = FALSE, weight = NULL, .env = NULL, ...)

## S3 method for class 'ped'
slice(.data, ...)

## S3 method for class 'ped'
select(.data, ...)

## S3 method for class 'ped'
mutate(.data, ...)

## S3 method for class 'ped'
rename(.data, ...)

## S3 method for class 'ped'
summarise(.data, ...)

## S3 method for class 'ped'
summarize(.data, ...)

## S3 method for class 'ped'
transmute(.data, ...)

## S3 method for class 'ped'
inner_join(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

## S3 method for class 'ped'
full_join(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

## S3 method for class 'ped'
left_join(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

## S3 method for class 'ped'
right_join(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dplyr_verbs_+3A_.data">.data</code></td>
<td>
<p>an  object of class <code>ped</code>, see <code><a href="#topic+as_ped">as_ped</a></code>.</p>
</td></tr>
<tr><td><code id="dplyr_verbs_+3A_...">...</code></td>
<td>
<p>see <code>dplyr</code> documentation</p>
</td></tr>
<tr><td><code id="dplyr_verbs_+3A_x">x</code></td>
<td>
<p>an  object of class <code>ped</code>, see <code><a href="#topic+as_ped">as_ped</a></code>.</p>
</td></tr>
<tr><td><code id="dplyr_verbs_+3A_tbl">tbl</code></td>
<td>
<p>an  object of class <code>ped</code>, see <code><a href="#topic+as_ped">as_ped</a></code>.</p>
</td></tr>
<tr><td><code id="dplyr_verbs_+3A_size">size</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt;
For <code>sample_n()</code>, the number of rows to select.
For <code>sample_frac()</code>, the fraction of rows to select.
If <code>tbl</code> is grouped, <code>size</code> applies to each group.</p>
</td></tr>
<tr><td><code id="dplyr_verbs_+3A_replace">replace</code></td>
<td>
<p>Sample with or without replacement?</p>
</td></tr>
<tr><td><code id="dplyr_verbs_+3A_weight">weight</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Sampling weights.
This must evaluate to a vector of non-negative numbers the same length as
the input. Weights are automatically standardised to sum to 1.</p>
</td></tr>
<tr><td><code id="dplyr_verbs_+3A_.env">.env</code></td>
<td>
<p>DEPRECATED.</p>
</td></tr>
<tr><td><code id="dplyr_verbs_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="dplyr_verbs_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="dplyr_verbs_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="dplyr_verbs_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a modified <code>ped</code> object (except for <code>do</code>)
</p>

<hr>
<h2 id='fcumu'>A formula special used to handle cumulative effect specifications</h2><span id='topic+fcumu'></span>

<h3>Description</h3>

<p>Can be used in the second part of the formula specification provided
to <code><a href="#topic+sim_pexp">sim_pexp</a></code> and should only be used in this
context.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fcumu(..., by = NULL, f_xyz, ll_fun)
</code></pre>

<hr>
<h2 id='geom_hazard'>(Cumulative) (Step-) Hazard Plots.</h2><span id='topic+geom_hazard'></span><span id='topic+GeomHazard'></span><span id='topic+geom_stephazard'></span><span id='topic+GeomStepHazard'></span><span id='topic+geom_surv'></span><span id='topic+GeomSurv'></span>

<h3>Description</h3>

<p><code>geom_hazard</code> is an extension of the <code>geom_line</code>, and
is optimized for (cumulative) hazard plots. Essentially, it adds a (0,0)
row to the data, if not already the case. Stolen from the
<code>RmcdrPlugin.KMggplot2</code> (slightly modified).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_hazard(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_stephazard(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  direction = "vh",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_surv(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_hazard_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_hazard_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_hazard_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_hazard_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_hazard_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_hazard_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_hazard_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_hazard_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_hazard_+3A_direction">direction</code></td>
<td>
<p>direction of stairs: 'vh' for vertical then horizontal,
'hv' for horizontal then vertical, or 'mid' for step half-way between
adjacent x-values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+geom_line">geom_line</a></code>,
<code><a href="ggplot2.html#topic+geom_step">geom_step</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(pammtools)
ped &lt;- tumor[10:50,] %&gt;% as_ped(Surv(days, status)~1)
pam &lt;- mgcv::gam(ped_status ~ s(tend), data=ped, family = poisson(), offset = offset)
ndf &lt;- make_newdata(ped, tend = unique(tend)) %&gt;% add_hazard(pam)
# piece-wise constant hazards
ggplot(ndf, aes(x = tend, y = hazard)) +
 geom_vline(xintercept = c(0, ndf$tend[c(1, (nrow(ndf)-2):nrow(ndf))]), lty = 3) +
 geom_hline(yintercept = c(ndf$hazard[1:3], ndf$hazard[nrow(ndf)]), lty = 3) +
 geom_stephazard() +
 geom_step(col=2) +
 geom_step(col=2, lty = 2, direction="vh")

# comulative hazard
ndf &lt;- ndf %&gt;% add_cumu_hazard(pam)
ggplot(ndf, aes(x = tend, y = cumu_hazard)) +
 geom_hazard() +
 geom_line(col=2) # doesn't start at (0, 0)

# survival probability
ndf &lt;- ndf %&gt;% add_surv_prob(pam)
ggplot(ndf, aes(x = tend, y = surv_prob)) +
 geom_surv() +
 geom_line(col=2) # doesn't start at c(0,1)
</code></pre>

<hr>
<h2 id='geom_stepribbon'>Step ribbon plots.</h2><span id='topic+geom_stepribbon'></span><span id='topic+GeomStepribbon'></span>

<h3>Description</h3>

<p><code>geom_stepribbon</code> is an extension of the <code>geom_ribbon</code>, and
is optimized for Kaplan-Meier plots with pointwise confidence intervals
or a confidence band. The default <code>direction</code>-argument <code>"hv"</code> is
appropriate for right-continuous step functions like the hazard rates etc
returned by <code>pammtools</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_stepribbon(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  direction = "hv",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_stepribbon_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_stepribbon_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_stepribbon_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_stepribbon_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_stepribbon_+3A_direction">direction</code></td>
<td>
<p>direction of stairs: 'vh' for vertical then horizontal,
'hv' for horizontal then vertical, or 'mid' for step half-way between
adjacent x-values.</p>
</td></tr>
<tr><td><code id="geom_stepribbon_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_stepribbon_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_stepribbon_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_stepribbon_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+geom_ribbon">geom_ribbon</a></code> <code>geom_stepribbon</code>
inherits from <code>geom_ribbon</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
huron &lt;- data.frame(year = 1875:1972, level = as.vector(LakeHuron))
h &lt;- ggplot(huron, aes(year))
h + geom_stepribbon(aes(ymin = level - 1, ymax = level + 1), fill = "grey70") +
    geom_step(aes(y = level))
h + geom_ribbon(aes(ymin = level - 1, ymax = level + 1), fill = "grey70") +
    geom_line(aes(y = level))
</code></pre>

<hr>
<h2 id='get_cif'>Calculate CIF for one cause</h2><span id='topic+get_cif'></span><span id='topic+get_cif.default'></span>

<h3>Description</h3>

<p>Calculate CIF for one cause
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cif(newdata, object, ...)

## Default S3 method:
get_cif(
  newdata,
  object,
  ci,
  time_var,
  alpha,
  n_sim,
  cause_var,
  coefs,
  V,
  sim_coef_mat,
  ...
)
</code></pre>

<hr>
<h2 id='get_cumu_coef'>Extract cumulative coefficients (cumulative hazard differences)</h2><span id='topic+get_cumu_coef'></span><span id='topic+get_cumu_coef.gam'></span><span id='topic+get_cumu_coef.aalen'></span><span id='topic+get_cumu_coef.cox.aalen'></span>

<h3>Description</h3>

<p>These functions are designed to extract (or mimic) the cumulative coefficients
usually used in additive hazards models (Aalen model) to depict (time-varying)
covariate effects. For PAMMs, these are the differences
between the cumulative hazard rates where all covariates except one have the
identical values. For a numeric covariate of interest, this calculates
<code class="reqn">\Lambda(t|x+1) - \Lambda(t|x)</code>.  For non-numeric covariates
the cumulative hazard of the reference level is subtracted from
the cumulative hazards evaluated at all non reference levels. Standard
errors are calculated using the delta method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cumu_coef(model, data = NULL, terms, ...)

## S3 method for class 'gam'
get_cumu_coef(model, data, terms, ...)

## S3 method for class 'aalen'
get_cumu_coef(model, data = NULL, terms, ci = TRUE, ...)

## S3 method for class 'cox.aalen'
get_cumu_coef(model, data = NULL, terms, ci = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cumu_coef_+3A_model">model</code></td>
<td>
<p>Object from which to extract cumulative coefficients.</p>
</td></tr>
<tr><td><code id="get_cumu_coef_+3A_data">data</code></td>
<td>
<p>Additional data if necessary.</p>
</td></tr>
<tr><td><code id="get_cumu_coef_+3A_terms">terms</code></td>
<td>
<p>A character vector of variables for which the cumulative
coefficient should be calculated.</p>
</td></tr>
<tr><td><code id="get_cumu_coef_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="get_cumu_coef_+3A_ci">ci</code></td>
<td>
<p>Logical. Indicates if confidence intervals should be returned as
well.</p>
</td></tr>
</table>

<hr>
<h2 id='get_cumu_eff'>Calculate (or plot) cumulative effect for all time-points of the follow-up</h2><span id='topic+get_cumu_eff'></span><span id='topic+gg_cumu_eff'></span>

<h3>Description</h3>

<p>Calculate (or plot) cumulative effect for all time-points of the follow-up
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cumu_eff(data, model, term, z1, z2 = NULL, se_mult = 2)

gg_cumu_eff(data, model, term, z1, z2 = NULL, se_mult = 2, ci = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cumu_eff_+3A_data">data</code></td>
<td>
<p>Data used to fit the <code>model</code>.</p>
</td></tr>
<tr><td><code id="get_cumu_eff_+3A_model">model</code></td>
<td>
<p>A suitable model object which will be used to estimate the
partial effect of <code>term</code>.</p>
</td></tr>
<tr><td><code id="get_cumu_eff_+3A_term">term</code></td>
<td>
<p>A character string indicating the model term for which partial
effects should be plotted.</p>
</td></tr>
<tr><td><code id="get_cumu_eff_+3A_z1">z1</code></td>
<td>
<p>The exposure profile for which to calculate the cumulative effect.
Can be either a single number or a vector of same length as unique observation
time points.</p>
</td></tr>
<tr><td><code id="get_cumu_eff_+3A_z2">z2</code></td>
<td>
<p>If provided, calculated cumulative effect is for the difference
between the two exposure profiles (g(z1,t)-g(z2,t)).</p>
</td></tr>
<tr><td><code id="get_cumu_eff_+3A_se_mult">se_mult</code></td>
<td>
<p>Multiplicative factor used to calculate confidence intervals
(e.g., lower = fit - 2*se).</p>
</td></tr>
<tr><td><code id="get_cumu_eff_+3A_ci">ci</code></td>
<td>
<p>Logical. Indicates if confidence intervals for the <code>term</code>
of interest should be calculated/plotted. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='get_cumu_hazard'>Calculate cumulative hazard</h2><span id='topic+get_cumu_hazard'></span>

<h3>Description</h3>

<p>Calculate cumulative hazard
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cumu_hazard(
  newdata,
  object,
  ci = TRUE,
  ci_type = c("default", "delta", "sim"),
  time_var = NULL,
  se_mult = 2,
  interval_length = "intlen",
  nsim = 100L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cumu_hazard_+3A_newdata">newdata</code></td>
<td>
<p> A data frame or list containing the values of the model covariates at which predictions
are required. If this is not provided then predictions corresponding to the
original data are returned. If <code>newdata</code> is provided then
it should contain all the variables needed for prediction: a
warning is generated if not. See details for use with <code>link{linear.functional.terms}</code>. </p>
</td></tr>
<tr><td><code id="get_cumu_hazard_+3A_object">object</code></td>
<td>
<p> a fitted <code>gam</code> object as produced by <code>gam()</code>.
</p>
</td></tr>
<tr><td><code id="get_cumu_hazard_+3A_ci">ci</code></td>
<td>
<p><code>logical</code>. Indicates if confidence intervals should be
calculated. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_cumu_hazard_+3A_ci_type">ci_type</code></td>
<td>
<p>The method by which standard errors/confidence intervals
will be calculated. Default transforms the linear predictor at
respective intervals. <code>"delta"</code> calculates CIs based on the standard
error calculated by the Delta method. <code>"sim"</code> draws the
property of interest from its posterior based on the normal distribution of
the estimated coefficients. See <a href="https://adibender.github.io/simpamm/confidence-intervals.html">here</a>
for details and empirical evaluation.</p>
</td></tr>
<tr><td><code id="get_cumu_hazard_+3A_time_var">time_var</code></td>
<td>
<p>Name of the variable used for the baseline hazard. If
not given, defaults to <code>"tend"</code> for <code><a href="mgcv.html#topic+gam">gam</a></code> fits, else
<code>"interval"</code>. The latter is assumed to be a factor, the former
numeric.</p>
</td></tr>
<tr><td><code id="get_cumu_hazard_+3A_se_mult">se_mult</code></td>
<td>
<p>Factor by which standard errors are multiplied for calculating
the confidence intervals.</p>
</td></tr>
<tr><td><code id="get_cumu_hazard_+3A_interval_length">interval_length</code></td>
<td>
<p>The variable in newdata containing the interval lengths.
Can be either bare unquoted variable name or character. Defaults to <code>"intlen"</code>.</p>
</td></tr>
<tr><td><code id="get_cumu_hazard_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code> and
<code><a href="#topic+get_hazard">get_hazard</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='get_cumulative'>Expand time-dependent covariates to functionals</h2><span id='topic+get_cumulative'></span><span id='topic+expand_cumulative'></span>

<h3>Description</h3>

<p>Given formula specification on how time-dependent covariates affect the
outcome, creates respective functional covariate as well as auxiliary
matrices for time/latency etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cumulative(data, formula)

expand_cumulative(data, func, n_func)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cumulative_+3A_data">data</code></td>
<td>
<p>Data frame (or similar) in which variables specified in ...
will be looked for</p>
</td></tr>
<tr><td><code id="get_cumulative_+3A_formula">formula</code></td>
<td>
<p>A formula containing <code>cumulative</code> specials,
that specify the type of cumulative effect one wants to estimate. For details
see the vignettes on data transformation and time-dependent covariates.</p>
</td></tr>
<tr><td><code id="get_cumulative_+3A_func">func</code></td>
<td>
<p>Single evaluated <code><a href="#topic+cumulative">cumulative</a></code> term.</p>
</td></tr>
</table>

<hr>
<h2 id='get_cut'>Obtain interval break points</h2><span id='topic+get_cut'></span><span id='topic+get_cut.default'></span>

<h3>Description</h3>

<p>Default method words for data frames.
The list method applies the default method to each data set within the list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cut(data, formula, cut = NULL, ...)

## Default S3 method:
get_cut(data, formula, cut = NULL, max_time = NULL, event = 1L, ...)
</code></pre>

<hr>
<h2 id='get_event_types'>Exctract event types</h2><span id='topic+get_event_types'></span>

<h3>Description</h3>

<p>Given a formula that specifies the status variable of the outcome, this function
extracts the different event types (except for censoring, specified by
<code>censor_code</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_event_types(data, formula, censor_code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_event_types_+3A_data">data</code></td>
<td>
<p>Either an object inheriting from data frame or in case of
time-dependent covariates a list of data frames (of length 2), where the first data frame
contains the time-to-event information and static covariates while the second
(and potentially further data frames) contain information on time-dependent
covariates and the times at which they have been observed.</p>
</td></tr>
<tr><td><code id="get_event_types_+3A_formula">formula</code></td>
<td>
<p>A two sided formula with a <code><a href="survival.html#topic+Surv">Surv</a></code> object
on the left-hand-side and covariate specification on the right-hand-side (RHS).
The RHS can be an extended formula, which specifies how TDCs should be transformed
using specials <code>concurrent</code> and <code>cumulative</code>. The left hand-side can
be in start-stop-notation. This, however, is only used to create left-truncated
data and does not support the full functionality.</p>
</td></tr>
<tr><td><code id="get_event_types_+3A_censor_code">censor_code</code></td>
<td>
<p>Specifies the value of the status variable that indicates censoring.
Often this will be <code>0</code>, which is the default.</p>
</td></tr>
</table>

<hr>
<h2 id='get_hazard'>Calculate predicted hazard</h2><span id='topic+get_hazard'></span><span id='topic+get_hazard.default'></span>

<h3>Description</h3>

<p>Calculate predicted hazard
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_hazard(object, newdata, ...)

## Default S3 method:
get_hazard(
  object,
  newdata,
  reference = NULL,
  ci = TRUE,
  type = c("response", "link"),
  ci_type = c("default", "delta", "sim"),
  time_var = NULL,
  se_mult = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_hazard_+3A_object">object</code></td>
<td>
<p> a fitted <code>gam</code> object as produced by <code>gam()</code>.
</p>
</td></tr>
<tr><td><code id="get_hazard_+3A_newdata">newdata</code></td>
<td>
<p> A data frame or list containing the values of the model covariates at which predictions
are required. If this is not provided then predictions corresponding to the
original data are returned. If <code>newdata</code> is provided then
it should contain all the variables needed for prediction: a
warning is generated if not. See details for use with <code>link{linear.functional.terms}</code>. </p>
</td></tr>
<tr><td><code id="get_hazard_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code> and
<code><a href="#topic+get_hazard">get_hazard</a></code></p>
</td></tr>
<tr><td><code id="get_hazard_+3A_reference">reference</code></td>
<td>
<p>A data frame with number of rows equal to <code>nrow(newdata)</code> or
one, or a named list with (partial) covariate specifications. See examples.</p>
</td></tr>
<tr><td><code id="get_hazard_+3A_ci">ci</code></td>
<td>
<p><code>logical</code>. Indicates if confidence intervals should be
calculated. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_hazard_+3A_type">type</code></td>
<td>
<p>Either <code>"response"</code> or <code>"link"</code>. The former calculates
hazard, the latter the log-hazard.</p>
</td></tr>
<tr><td><code id="get_hazard_+3A_ci_type">ci_type</code></td>
<td>
<p>The method by which standard errors/confidence intervals
will be calculated. Default transforms the linear predictor at
respective intervals. <code>"delta"</code> calculates CIs based on the standard
error calculated by the Delta method. <code>"sim"</code> draws the
property of interest from its posterior based on the normal distribution of
the estimated coefficients. See <a href="https://adibender.github.io/simpamm/confidence-intervals.html">here</a>
for details and empirical evaluation.</p>
</td></tr>
<tr><td><code id="get_hazard_+3A_time_var">time_var</code></td>
<td>
<p>Name of the variable used for the baseline hazard. If
not given, defaults to <code>"tend"</code> for <code><a href="mgcv.html#topic+gam">gam</a></code> fits, else
<code>"interval"</code>. The latter is assumed to be a factor, the former
numeric.</p>
</td></tr>
<tr><td><code id="get_hazard_+3A_se_mult">se_mult</code></td>
<td>
<p>Factor by which standard errors are multiplied for calculating
the confidence intervals.</p>
</td></tr>
</table>

<hr>
<h2 id='get_intervals'>Information on intervals in which times fall</h2><span id='topic+get_intervals'></span><span id='topic+get_intervals.default'></span>

<h3>Description</h3>

<p>Information on intervals in which times fall
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_intervals(x, times, ...)

## Default S3 method:
get_intervals(x, times, left.open = TRUE, rightmost.closed = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_intervals_+3A_x">x</code></td>
<td>
<p>An object from which interval information can be obtained,
see <code><a href="#topic+int_info">int_info</a></code>.</p>
</td></tr>
<tr><td><code id="get_intervals_+3A_times">times</code></td>
<td>
<p>A vector of times for which corresponding interval information
should be returned.</p>
</td></tr>
<tr><td><code id="get_intervals_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="base.html#topic+findInterval">findInterval</a></code>.</p>
</td></tr>
<tr><td><code id="get_intervals_+3A_left.open">left.open</code></td>
<td>
<p>logical; if true all the intervals are open at left
and closed at right; in the formulas below, <code class="reqn">\le</code> should be
swapped with <code class="reqn">&lt;</code> (and <code class="reqn">&gt;</code> with <code class="reqn">\ge</code>), and
<code>rightmost.closed</code> means &lsquo;leftmost is closed&rsquo;.  This may
be useful, e.g., in survival analysis computations.</p>
</td></tr>
<tr><td><code id="get_intervals_+3A_rightmost.closed">rightmost.closed</code></td>
<td>
<p>logical; if true, the rightmost interval,
<code>vec[N-1] .. vec[N]</code> is treated as <em>closed</em>, see below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing information on intervals in which
values of <code>times</code> fall.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+findInterval">findInterval</a></code> <code><a href="#topic+int_info">int_info</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(111018)
brks &lt;- c(0, 4.5, 5, 10, 30)
int_info(brks)
x &lt;- runif (3, 0, 30)
x
get_intervals(brks, x)
</code></pre>

<hr>
<h2 id='get_laglead'>Construct or extract data that represents a lag-lead window</h2><span id='topic+get_laglead'></span><span id='topic+get_laglead.default'></span><span id='topic+get_laglead.data.frame'></span>

<h3>Description</h3>

<p>Constructs lag-lead window data set from raw inputs or from data objects
with suitable information stored in attributes, e.g., objects created
by <code><a href="#topic+as_ped">as_ped</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_laglead(x, ...)

## Default S3 method:
get_laglead(x, tz, ll_fun, ...)

## S3 method for class 'data.frame'
get_laglead(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_laglead_+3A_x">x</code></td>
<td>
<p>Either a numeric vector of follow-up cut points or a suitable object.</p>
</td></tr>
<tr><td><code id="get_laglead_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="get_laglead_+3A_tz">tz</code></td>
<td>
<p>A vector of exposure times</p>
</td></tr>
<tr><td><code id="get_laglead_+3A_ll_fun">ll_fun</code></td>
<td>
<p>Function that specifies how the lag-lead matrix
should be constructed. First argument is the follow up time
second argument is the time of exposure.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>get_laglead(0:10, tz=-5:5, ll_fun=function(t, tz) { t &gt;= tz + 2 &amp; t &lt;= tz + 2 + 3})
gg_laglead(0:10, tz=-5:5, ll_fun=function(t, tz) { t &gt;= tz + 2 &amp; t &lt;= tz + 2 + 3})
</code></pre>

<hr>
<h2 id='get_lhs_vars'>Extract variables from the left-hand-side of a formula</h2><span id='topic+get_lhs_vars'></span><span id='topic+get_rhs_vars'></span>

<h3>Description</h3>

<p>Extract variables from the left-hand-side of a formula
</p>
<p>Extract variables from the right-hand side of a formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_lhs_vars(formula)

get_rhs_vars(formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_lhs_vars_+3A_formula">formula</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='get_ped_form'>Extract variables from the left-hand-side of a formula</h2><span id='topic+get_ped_form'></span>

<h3>Description</h3>

<p>Extract variables from the left-hand-side of a formula
</p>
<p>Extract variables from the right-hand side of a formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ped_form(
  formula,
  data = NULL,
  tdc_specials = c("concurrent", "cumulative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ped_form_+3A_formula">formula</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='get_plotinfo'>Extract plot information for all special model terms</h2><span id='topic+get_plotinfo'></span>

<h3>Description</h3>

<p>Given a <code>mgcv</code> <code><a href="mgcv.html#topic+gamObject">gamObject</a></code>, returns the information
used for the default plots produced by <code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_plotinfo(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_plotinfo_+3A_x">x</code></td>
<td>
<p> a fitted <code>gam</code> object as produced by <code>gam()</code>.</p>
</td></tr>
<tr><td><code id="get_plotinfo_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='get_sim_ci'>Calculate simulation based confidence intervals</h2><span id='topic+get_sim_ci'></span>

<h3>Description</h3>

<p>Calculate simulation based confidence intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sim_ci(newdata, object, alpha = 0.05, nsim = 100L, ...)
</code></pre>

<hr>
<h2 id='get_surv_prob'>Calculate survival probabilities</h2><span id='topic+get_surv_prob'></span>

<h3>Description</h3>

<p>Calculate survival probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_surv_prob(
  newdata,
  object,
  ci = TRUE,
  ci_type = c("default", "delta", "sim"),
  se_mult = 2L,
  time_var = NULL,
  interval_length = "intlen",
  nsim = 100L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_surv_prob_+3A_newdata">newdata</code></td>
<td>
<p> A data frame or list containing the values of the model covariates at which predictions
are required. If this is not provided then predictions corresponding to the
original data are returned. If <code>newdata</code> is provided then
it should contain all the variables needed for prediction: a
warning is generated if not. See details for use with <code>link{linear.functional.terms}</code>. </p>
</td></tr>
<tr><td><code id="get_surv_prob_+3A_object">object</code></td>
<td>
<p> a fitted <code>gam</code> object as produced by <code>gam()</code>.
</p>
</td></tr>
<tr><td><code id="get_surv_prob_+3A_ci">ci</code></td>
<td>
<p><code>logical</code>. Indicates if confidence intervals should be
calculated. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_surv_prob_+3A_se_mult">se_mult</code></td>
<td>
<p>Factor by which standard errors are multiplied for calculating
the confidence intervals.</p>
</td></tr>
<tr><td><code id="get_surv_prob_+3A_time_var">time_var</code></td>
<td>
<p>Name of the variable used for the baseline hazard. If
not given, defaults to <code>"tend"</code> for <code><a href="mgcv.html#topic+gam">gam</a></code> fits, else
<code>"interval"</code>. The latter is assumed to be a factor, the former
numeric.</p>
</td></tr>
<tr><td><code id="get_surv_prob_+3A_interval_length">interval_length</code></td>
<td>
<p>The variable in newdata containing the interval lengths.
Can be either bare unquoted variable name or character. Defaults to <code>"intlen"</code>.</p>
</td></tr>
<tr><td><code id="get_surv_prob_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code> and
<code><a href="#topic+get_hazard">get_hazard</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='get_tdc_form'>Extract variables from the left-hand-side of a formula</h2><span id='topic+get_tdc_form'></span>

<h3>Description</h3>

<p>Extract variables from the left-hand-side of a formula
</p>
<p>Extract variables from the right-hand side of a formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_tdc_form(
  formula,
  data = NULL,
  tdc_specials = c("concurrent", "cumulative"),
  invert = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_tdc_form_+3A_formula">formula</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='get_tdc_vars'>Extract variables from the left-hand-side of a formula</h2><span id='topic+get_tdc_vars'></span>

<h3>Description</h3>

<p>Extract variables from the left-hand-side of a formula
</p>
<p>Extract variables from the right-hand side of a formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_tdc_vars(formula, specials = "cumulative", data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_tdc_vars_+3A_formula">formula</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='get_term'>Extract partial effects for specified model terms</h2><span id='topic+get_term'></span>

<h3>Description</h3>

<p>Extract partial effects for specified model terms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_term(data, fit, term, n = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_term_+3A_data">data</code></td>
<td>
<p>A data frame containing variables used to fit the model. Only
first row will be used.</p>
</td></tr>
<tr><td><code id="get_term_+3A_fit">fit</code></td>
<td>
<p>A fitted object of class <code><a href="mgcv.html#topic+gam">gam</a></code>.</p>
</td></tr>
<tr><td><code id="get_term_+3A_term">term</code></td>
<td>
<p>The (non-linear) model term of interest.</p>
</td></tr>
<tr><td><code id="get_term_+3A_n">n</code></td>
<td>
<p>Specify the output sequence either by supplying the
length of the sequence with <code>n</code>, or the spacing between value
with <code>by</code>. Specifying both is an error.
</p>
<p>I recommend that you name these arguments in order to make it clear to
the reader.</p>
</td></tr>
<tr><td><code id="get_term_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+seq_range">seq_range</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='get_terms'>Extract the partial effects of non-linear model terms</h2><span id='topic+get_terms'></span>

<h3>Description</h3>

<p>This function basically creates a new <code>df</code> from <code>data</code> for
each term in <code>terms</code>, creating a range from minimum and maximum of the
<code>predict(fit, newdata=df, type="terms")</code>. Terms are then
stacked to a tidy data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_terms(data, fit, terms, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_terms_+3A_data">data</code></td>
<td>
<p>A data frame containing variables used to fit the model. Only
first row will be used.</p>
</td></tr>
<tr><td><code id="get_terms_+3A_fit">fit</code></td>
<td>
<p>A fitted object of class <code><a href="mgcv.html#topic+gam">gam</a></code>.</p>
</td></tr>
<tr><td><code id="get_terms_+3A_terms">terms</code></td>
<td>
<p>A character vector (can be length one). Specifies the terms
for which partial effects will be returned</p>
</td></tr>
<tr><td><code id="get_terms_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+seq_range">seq_range</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with 5 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
fit &lt;- coxph(Surv(time, status) ~ pspline(karno) + pspline(age), data=veteran)
terms_df &lt;- veteran %&gt;% get_terms(fit, terms = c("karno", "age"))
head(terms_df)
tail(terms_df)
</code></pre>

<hr>
<h2 id='gg_fixed'>Forrest plot of fixed coefficients</h2><span id='topic+gg_fixed'></span>

<h3>Description</h3>

<p>Given a model object, returns a data frame with columns <code>variable</code>,
<code>coef</code> (coefficient), <code>ci_lower</code> (lower 95\
<code>ci_upper</code> (upper 95\
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_fixed(x, intercept = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg_fixed_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="gg_fixed_+3A_intercept">intercept</code></td>
<td>
<p>Logical, indicating whether intercept term should be included.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="gg_fixed_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy_fixed">tidy_fixed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- mgcv::gam(Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width + Species,
 data=iris)
gg_fixed(g, intercept=TRUE)
gg_fixed(g)
</code></pre>

<hr>
<h2 id='gg_laglead'>Plot Lag-Lead windows</h2><span id='topic+gg_laglead'></span><span id='topic+gg_laglead.default'></span><span id='topic+gg_laglead.LL_df'></span><span id='topic+gg_laglead.nested_fdf'></span>

<h3>Description</h3>

<p>Given data defining a Lag-lead window, returns respective plot as a
<code>ggplot2</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_laglead(x, ...)

## Default S3 method:
gg_laglead(x, tz, ll_fun, ...)

## S3 method for class 'LL_df'
gg_laglead(
  x,
  high_col = "grey20",
  low_col = "whitesmoke",
  grid_col = "lightgrey",
  ...
)

## S3 method for class 'nested_fdf'
gg_laglead(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg_laglead_+3A_x">x</code></td>
<td>
<p>Either a numeric vector of follow-up cut points or a suitable object.</p>
</td></tr>
<tr><td><code id="gg_laglead_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="gg_laglead_+3A_tz">tz</code></td>
<td>
<p>A vector of exposure times</p>
</td></tr>
<tr><td><code id="gg_laglead_+3A_ll_fun">ll_fun</code></td>
<td>
<p>Function that specifies how the lag-lead matrix
should be constructed. First argument is the follow up time
second argument is the time of exposure.</p>
</td></tr>
<tr><td><code id="gg_laglead_+3A_high_col">high_col</code></td>
<td>
<p>Color used to highlight exposure times within the lag-lead window.</p>
</td></tr>
<tr><td><code id="gg_laglead_+3A_low_col">low_col</code></td>
<td>
<p>Color of exposure times outside the lag-lead window.</p>
</td></tr>
<tr><td><code id="gg_laglead_+3A_grid_col">grid_col</code></td>
<td>
<p>Color of grid lines.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>get_laglead
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1: supply t, tz, ll_fun directly
 gg_laglead(1:10, tz=-5:5,
  ll_fun=function(t, tz) { t &gt;= tz + 2 &amp; t &lt;= tz + 2 + 3})

## Example 2: extract information on t, tz, ll_from data with respective attributes
data("simdf_elra", package = "pammtools")
gg_laglead(simdf_elra)
</code></pre>

<hr>
<h2 id='gg_partial'>Visualize effect estimates for specific covariate combinations</h2><span id='topic+gg_partial'></span><span id='topic+gg_partial_ll'></span><span id='topic+get_partial_ll'></span>

<h3>Description</h3>

<p>Depending on the plot function and input, creates either a 1-dimensional slices,
bivariate surface or  (1D) cumulative effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_partial(data, model, term, ..., reference = NULL, ci = TRUE)

gg_partial_ll(
  data,
  model,
  term,
  ...,
  reference = NULL,
  ci = FALSE,
  time_var = "tend"
)

get_partial_ll(
  data,
  model,
  term,
  ...,
  reference = NULL,
  ci = FALSE,
  time_var = "tend"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg_partial_+3A_data">data</code></td>
<td>
<p>Data used to fit the <code>model</code>.</p>
</td></tr>
<tr><td><code id="gg_partial_+3A_model">model</code></td>
<td>
<p>A suitable model object which will be used to estimate the
partial effect of <code>term</code>.</p>
</td></tr>
<tr><td><code id="gg_partial_+3A_term">term</code></td>
<td>
<p>A character string indicating the model term for which partial
effects should be plotted.</p>
</td></tr>
<tr><td><code id="gg_partial_+3A_...">...</code></td>
<td>
<p>Covariate specifications (expressions) that will be evaluated
by looking for variables in <code>x</code>. Must be of the form <code>z = f(z)</code>
where <code>z</code> is a variable in the data set and <code>f</code> a known
function that can be usefully applied to <code>z</code>. Note that this is also
necessary for single value specifications (e.g. <code>age = c(50)</code>).
For data in PED (piece-wise exponential data) format, one can also specify
the time argument, but see &quot;Details&quot; an &quot;Examples&quot; below.</p>
</td></tr>
<tr><td><code id="gg_partial_+3A_reference">reference</code></td>
<td>
<p>If specified, should be a list with covariate value pairs,
e.g. <code>list(x1 = 1, x2=50)</code>. The calculated partial effect will be relative
to an observation specified in <code>reference</code>.</p>
</td></tr>
<tr><td><code id="gg_partial_+3A_ci">ci</code></td>
<td>
<p>Logical. Indicates if confidence intervals for the <code>term</code>
of interest should be calculated/plotted. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="gg_partial_+3A_time_var">time_var</code></td>
<td>
<p>The name of the variable that was used in <code>model</code> to
represent follow-up time.</p>
</td></tr>
</table>

<hr>
<h2 id='gg_re'>Plot Normal QQ plots for random effects</h2><span id='topic+gg_re'></span>

<h3>Description</h3>

<p>Plot Normal QQ plots for random effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_re(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg_re_+3A_x">x</code></td>
<td>
<p> a fitted <code>gam</code> object as produced by <code>gam()</code>.</p>
</td></tr>
<tr><td><code id="gg_re_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy_re">tidy_re</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pammtools)
data("patient")
ped &lt;- patient %&gt;%
 dplyr::slice(1:100) %&gt;%
 as_ped(Surv(Survdays, PatientDied)~ ApacheIIScore + CombinedicuID, id="CombinedID")
pam &lt;- mgcv::gam(ped_status ~ s(tend) + ApacheIIScore + s(CombinedicuID, bs="re"),
 data=ped, family=poisson(), offset=offset)
gg_re(pam)
plot(pam, select = 2)
</code></pre>

<hr>
<h2 id='gg_slice'>Plot 1D (smooth) effects</h2><span id='topic+gg_slice'></span>

<h3>Description</h3>

<p>Flexible, high-level plotting function for (non-linear) effects conditional
on further covariate specifications and potentially relative to
a comparison specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_slice(data, model, term, ..., reference = NULL, ci = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg_slice_+3A_data">data</code></td>
<td>
<p>Data used to fit the <code>model</code>.</p>
</td></tr>
<tr><td><code id="gg_slice_+3A_model">model</code></td>
<td>
<p>A suitable model object which will be used to estimate the
partial effect of <code>term</code>.</p>
</td></tr>
<tr><td><code id="gg_slice_+3A_term">term</code></td>
<td>
<p>A character string indicating the model term for which partial
effects should be plotted.</p>
</td></tr>
<tr><td><code id="gg_slice_+3A_...">...</code></td>
<td>
<p>Covariate specifications (expressions) that will be evaluated
by looking for variables in <code>x</code>. Must be of the form <code>z = f(z)</code>
where <code>z</code> is a variable in the data set and <code>f</code> a known
function that can be usefully applied to <code>z</code>. Note that this is also
necessary for single value specifications (e.g. <code>age = c(50)</code>).
For data in PED (piece-wise exponential data) format, one can also specify
the time argument, but see &quot;Details&quot; an &quot;Examples&quot; below.</p>
</td></tr>
<tr><td><code id="gg_slice_+3A_reference">reference</code></td>
<td>
<p>If specified, should be a list with covariate value pairs,
e.g. <code>list(x1 = 1, x2=50)</code>. The calculated partial effect will be relative
to an observation specified in <code>reference</code>.</p>
</td></tr>
<tr><td><code id="gg_slice_+3A_ci">ci</code></td>
<td>
<p>Logical. Indicates if confidence intervals for the <code>term</code>
of interest should be calculated/plotted. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ped &lt;- tumor[1:200, ] %&gt;% as_ped(Surv(days, status) ~ . )
model &lt;- mgcv::gam(ped_status~s(tend) + s(age, by = complications), data=ped,
  family = poisson(), offset=offset)
make_newdata(ped, age = seq_range(age, 20), complications = levels(complications))
gg_slice(ped, model, "age", age=seq_range(age, 20), complications=levels(complications))
gg_slice(ped, model, "age", age=seq_range(age, 20), complications=levels(complications),
 ci = FALSE)
gg_slice(ped, model, "age", age=seq_range(age, 20), complications=levels(complications),
  reference=list(age = 50))
</code></pre>

<hr>
<h2 id='gg_smooth'>Plot smooth 1d terms of gam objects</h2><span id='topic+gg_smooth'></span><span id='topic+gg_smooth.default'></span>

<h3>Description</h3>

<p>Given a gam model this convenience function returns a plot of all
smooth terms contained in the model. If more than one smooth is present, the
different smooth are faceted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_smooth(x, ...)

## Default S3 method:
gg_smooth(x, fit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg_smooth_+3A_x">x</code></td>
<td>
<p>A data frame or object of class <code>ped</code>.</p>
</td></tr>
<tr><td><code id="gg_smooth_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+get_terms">get_terms</a></code></p>
</td></tr>
<tr><td><code id="gg_smooth_+3A_fit">fit</code></td>
<td>
<p>A model object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object.
</p>


<h3>See Also</h3>

<p>get_terms
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g1 &lt;- mgcv::gam(Sepal.Length ~ s(Sepal.Width) + s(Petal.Length), data=iris)
gg_smooth(iris, g1, terms=c("Sepal.Width", "Petal.Length"))
</code></pre>

<hr>
<h2 id='gg_tensor'>Plot tensor product effects</h2><span id='topic+gg_tensor'></span>

<h3>Description</h3>

<p>Given a gam model this convenience function returns a <code>ggplot2</code> object
depicting 2d smooth terms specified in the model as heat/contour plots. If
more than one 2d smooth term is present individual terms are faceted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_tensor(x, ci = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg_tensor_+3A_x">x</code></td>
<td>
<p> a fitted <code>gam</code> object as produced by <code>gam()</code>.</p>
</td></tr>
<tr><td><code id="gg_tensor_+3A_ci">ci</code></td>
<td>
<p>A logical value indicating whether confidence intervals should be
calculated and returned. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="gg_tensor_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy_smooth2d">tidy_smooth2d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- mgcv::gam(Sepal.Length ~ te(Sepal.Width, Petal.Length), data=iris)
gg_tensor(g)
gg_tensor(g, ci=TRUE)
gg_tensor(update(g, .~. + te(Petal.Width, Petal.Length)))
</code></pre>

<hr>
<h2 id='has_tdc'>Checks if data contains timd-dependent covariates</h2><span id='topic+has_tdc'></span>

<h3>Description</h3>

<p>Checks if data contains timd-dependent covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_tdc(data, id_var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_tdc_+3A_data">data</code></td>
<td>
<p>A data frame (potentially) containing time-dependent covariates.</p>
</td></tr>
<tr><td><code id="has_tdc_+3A_id_var">id_var</code></td>
<td>
<p>A character indicating the grouping variable. For each covariate
it will be checked if their values change within a group specified by
<code>id_var</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical. <code>TRUE</code> if data contains time-dependent covariates, else <code>FALSE</code>.
</p>

<hr>
<h2 id='int_info'>Create start/end times and interval information</h2><span id='topic+int_info'></span><span id='topic+int_info.default'></span><span id='topic+int_info.data.frame'></span><span id='topic+int_info.ped'></span><span id='topic+int_info.pamm'></span>

<h3>Description</h3>

<p>Given interval breaks points, returns data frame with information on
interval start time, interval end time, interval length and a factor
variable indicating the interval (left open intervals). If an object of class
<code>ped</code> is provided, extracts unique interval information from object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int_info(x, ...)

## Default S3 method:
int_info(x, min_time = 0L, ...)

## S3 method for class 'data.frame'
int_info(x, min_time = 0L, ...)

## S3 method for class 'ped'
int_info(x, ...)

## S3 method for class 'pamm'
int_info(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="int_info_+3A_x">x</code></td>
<td>
<p>A numeric vector of cut points in which the follow-up should be
partitioned in or object of class <code>ped</code>.</p>
</td></tr>
<tr><td><code id="int_info_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="int_info_+3A_min_time">min_time</code></td>
<td>
<p>Only intervals that have lower borders larger than
this value will be included in the resulting data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the start and end times of the
intervals specified by the <code>x</code> argument. Additionally, the interval
length, interval mid-point and a factor variable indicating the intervals.
</p>


<h3>See Also</h3>

<p>as_ped ped_info
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create interval information from cut points
int_info(c(1, 2.3, 5))

## extract interval information used to create ped object
tdf &lt;- data.frame(time=c(1, 2.3, 5), status=c(0, 1, 0))
ped &lt;- tdf %&gt;% as_ped(Surv(time, status)~., id="id")
int_info(ped)

</code></pre>

<hr>
<h2 id='make_newdata'>Construct a data frame suitable for prediction</h2><span id='topic+make_newdata'></span><span id='topic+make_newdata.default'></span><span id='topic+make_newdata.ped'></span><span id='topic+make_newdata.fped'></span>

<h3>Description</h3>

<p>This functions provides a flexible interface to create a data set that
can be plugged in as <code>newdata</code> argument to a suitable  <code>predict</code>
function (or similar).
The function is particularly useful in combination with one of the
<code>add_*</code> functions, e.g., <code><a href="#topic+add_term">add_term</a></code>,
<code><a href="#topic+add_hazard">add_hazard</a></code>, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_newdata(x, ...)

## Default S3 method:
make_newdata(x, ...)

## S3 method for class 'ped'
make_newdata(x, ...)

## S3 method for class 'fped'
make_newdata(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_newdata_+3A_x">x</code></td>
<td>
<p>A data frame (or object that inherits from <code>data.frame</code>).</p>
</td></tr>
<tr><td><code id="make_newdata_+3A_...">...</code></td>
<td>
<p>Covariate specifications (expressions) that will be evaluated
by looking for variables in <code>x</code>. Must be of the form <code>z = f(z)</code>
where <code>z</code> is a variable in the data set and <code>f</code> a known
function that can be usefully applied to <code>z</code>. Note that this is also
necessary for single value specifications (e.g. <code>age = c(50)</code>).
For data in PED (piece-wise exponential data) format, one can also specify
the time argument, but see &quot;Details&quot; an &quot;Examples&quot; below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the type of variables in <code>x</code>, mean or modus values
will be used for variables not specified in ellipsis
(see also <code><a href="#topic+sample_info">sample_info</a></code>). If <code>x</code> is an object
that inherits from class <code>ped</code>, useful data set completion will be
attempted depending on variables specified in ellipsis. This is especially
useful, when creating a data set with different time points, e.g. to
calculate survival probabilities over time (<code><a href="#topic+add_surv_prob">add_surv_prob</a></code>)
or to calculate a time-varying covariate effects (<code><a href="#topic+add_term">add_term</a></code>).
To do so, the time variable has to be specified in <code>...</code>, e.g.,
<code>tend = seq_range(tend, 20)</code>. The problem with this specification is that
not all values produced by <code>seq_range(tend, 20)</code> will be actual values
of <code>tend</code> used at the stage of estimation (and in general, it will
often be tedious to specify exact <code>tend</code> values). <code>make_newdata</code>
therefore finds the correct interval and sets <code>tend</code> to the respective
interval endpoint. For example, if the intervals of the PED object are
<code class="reqn">(0,1], (1,2]</code> then <code>tend = 1.5</code> will be set to <code>2</code> and the
remaining time-varying information (e.g. offset) completed accordingly.
See examples below.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># General functionality
tumor %&gt;% make_newdata()
tumor %&gt;% make_newdata(age=c(50))
tumor %&gt;% make_newdata(days=seq_range(days, 3), age=c(50, 55))
tumor %&gt;% make_newdata(days=seq_range(days, 3), status=unique(status), age=c(50, 55))
# mean/modus values of unspecified variables are calculated over whole data
tumor %&gt;% make_newdata(sex=unique(sex))
tumor %&gt;% group_by(sex) %&gt;% make_newdata()

# Examples for PED data
ped &lt;- tumor %&gt;% slice(1:3) %&gt;% as_ped(Surv(days, status)~., cut = c(0, 500, 1000))
ped %&gt;% make_newdata(age=c(50, 55))

# if time information is specified, other time variables will be specified
# accordingly and offset calculated correctly
ped %&gt;% make_newdata(tend = c(1000), age = c(50, 55))
ped %&gt;% make_newdata(tend = unique(tend))
ped %&gt;% group_by(sex) %&gt;% make_newdata(tend = unique(tend))

# tend is set to the end point of respective interval:
ped &lt;- tumor %&gt;% as_ped(Surv(days, status)~.)
seq_range(ped$tend, 3)
make_newdata(ped, tend = seq_range(tend, 3))
</code></pre>

<hr>
<h2 id='make_time_mat'>Create matrix components for cumulative effects</h2><span id='topic+make_time_mat'></span><span id='topic+make_latency_mat'></span><span id='topic+make_lag_lead_mat'></span><span id='topic+make_z_mat'></span>

<h3>Description</h3>

<p>These functions are called internally by <code><a href="#topic+get_cumulative">get_cumulative</a></code> and
should usually not be called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_time_mat(data, nz)

make_latency_mat(data, tz)

make_lag_lead_mat(data, tz, ll_fun = function(t, tz) t &gt;= tz)

make_z_mat(data, z_var, nz, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_time_mat_+3A_data">data</code></td>
<td>
<p>A data set (or similar) from which meta information on cut-points,
interval-specific time, covariates etc. can be obtained.</p>
</td></tr>
<tr><td><code id="make_time_mat_+3A_z_var">z_var</code></td>
<td>
<p>Which should be transformed into functional covariate format
suitable to fit cumulative effects in <code>mgcv::gam</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='modus'>Calculate the modus</h2><span id='topic+modus'></span>

<h3>Description</h3>

<p>Calculate the modus
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modus(var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modus_+3A_var">var</code></td>
<td>
<p>A atomic vector</p>
</td></tr>
</table>

<hr>
<h2 id='nest_tdc'>Create nested data frame from data with time-dependent covariates</h2><span id='topic+nest_tdc'></span><span id='topic+nest_tdc.default'></span><span id='topic+nest_tdc.list'></span>

<h3>Description</h3>

<p>Provides methods to nest data with time-dependent covariates (TDCs).
A <code>formula</code> must be provided where the right hand side (RHS) contains
the structure of the TDCs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_tdc(data, formula, ...)

## Default S3 method:
nest_tdc(data, formula, ...)

## S3 method for class 'list'
nest_tdc(data, formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_tdc_+3A_data">data</code></td>
<td>
<p>A suitable data structure (e.g. unnested data frame with
concurrent TDCs or a list where each element is a data frame, potentially
containing TDCs as specified in the RHS of <code>formula</code>).
Only TDCs present in <code>formula</code> will be returned.</p>
</td></tr>
<tr><td><code id="nest_tdc_+3A_formula">formula</code></td>
<td>
<p>A two sided formula with a two part RHS, where the second
part indicates the structure of the TDC structure.</p>
</td></tr>
<tr><td><code id="nest_tdc_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td></tr>
</table>

<hr>
<h2 id='pamm'>Fit a piece-wise exponential additive model</h2><span id='topic+pamm'></span><span id='topic+is.pamm'></span><span id='topic+print.pamm'></span><span id='topic+summary.pamm'></span><span id='topic+plot.pamm'></span>

<h3>Description</h3>

<p>A thin wrapper around <code><a href="mgcv.html#topic+gam">gam</a></code>, however, some arguments are
prespecified:
<code>family=poisson()</code> and <code>offset=data$offset</code>.
These two can not be overwritten. In many cases it will also be advisable to
set <code>method="REML"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamm(formula, data = list(), ..., trafo_args = NULL, engine = "gam")

is.pamm(x)

## S3 method for class 'pamm'
print(x, ...)

## S3 method for class 'pamm'
summary(object, ...)

## S3 method for class 'pamm'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pamm_+3A_formula">formula</code></td>
<td>
<p> A GAM formula, or a list of formulae (see <code><a href="mgcv.html#topic+formula.gam">formula.gam</a></code> and also <code><a href="mgcv.html#topic+gam.models">gam.models</a></code>). 
These are exactly like the formula for a GLM except that smooth terms, <code><a href="mgcv.html#topic+s">s</a></code>, <code><a href="mgcv.html#topic+te">te</a></code>, <code><a href="mgcv.html#topic+ti">ti</a></code> 
and <code><a href="mgcv.html#topic+t2">t2</a></code>, can be added to the right hand side to specify that the linear predictor depends on smooth functions of predictors (or linear functionals of these).
</p>
</td></tr>
<tr><td><code id="pamm_+3A_data">data</code></td>
<td>
<p> A data frame or list containing the model response variable and 
covariates required by the formula. By default the variables are taken 
from <code>environment(formula)</code>: typically the environment from 
which <code>gam</code> is called.</p>
</td></tr>
<tr><td><code id="pamm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>engine</code>.</p>
</td></tr>
<tr><td><code id="pamm_+3A_trafo_args">trafo_args</code></td>
<td>
<p>A named list. If data is not in PED format, <code>as_ped</code>
will be called internally with arguments provided in <code>trafo_args</code>.</p>
</td></tr>
<tr><td><code id="pamm_+3A_engine">engine</code></td>
<td>
<p>Character name of the function that will be called to fit the
model. The intended entries are either <code>"gam"</code> or <code>"bam"</code>
(both from package <code>mgcv</code>).</p>
</td></tr>
<tr><td><code id="pamm_+3A_x">x</code></td>
<td>
<p>Any R object.</p>
</td></tr>
<tr><td><code id="pamm_+3A_object">object</code></td>
<td>
<p>An object of class <code>pamm</code> as returned by <code><a href="#topic+pamm">pamm</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+gam">gam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped &lt;- tumor[1:100, ] %&gt;%
 as_ped(Surv(days, status) ~ complications, cut = seq(0, 3000, by = 50))
pam &lt;- pamm(ped_status ~ s(tend) + complications, data = ped)
summary(pam)
## Alternatively
pamm(
 ped_status ~ s(tend) + complications,
 data = tumor[1:100, ],
trafo_args = list(formula = Surv(days, status)~complications))
</code></pre>

<hr>
<h2 id='pammtools'>pammtools: Piece-wise exponential Additive Mixed Modeling tools.</h2><span id='topic+pammtools'></span>

<h3>Description</h3>

<p><code>pammtools</code> provides functions and utilities that facilitate fitting
Piece-wise Exponential Additive Mixed Models (PAMMs), including data
transformation and other convenience functions for pre- and post-processing
as well as plotting.
</p>


<h3>Details</h3>

<p>The best way to get an overview of the functionality provided and how to
fit PAMMs is to view the vignettes
available at <a href="https://adibender.github.io/pammtools/articles/">https://adibender.github.io/pammtools/articles/</a>.
A summary of the vignettes' content is given below:
</p>

<ul>
<li> <p><a href="https://adibender.github.io/pammtools/articles/basics.html">basics</a>:
Introduction to PAMMs and basic modeling.
</p>
</li>
<li> <p><a href="https://adibender.github.io/pammtools/articles/baseline.html">baseline</a>:
Shows how to estimate and visualize baseline model (without covariates) and
comparison to respective Cox-PH model.
</p>
</li>
<li> <p><a href="https://adibender.github.io/pammtools/articles/convenience.html">convenience</a>:
Convenience functions for post-processing and plotting PAMMs.
</p>
</li>
<li> <p><a href="https://adibender.github.io/pammtools/articles/data-transformation.html">data-transformation</a>:
Transforming data into a format suitable to fit PAMMs.
</p>
</li>
<li> <p><a href="https://adibender.github.io/pammtools/articles/frailty.html">frailty</a>:
Specifying &quot;frailty&quot; terms, i.e., random effects for PAMMs.
</p>
</li>
<li> <p><a href="https://adibender.github.io/pammtools/articles/splines.html">splines</a>:
Specifying spline smooth terms for PAMMs.
</p>
</li>
<li> <p><a href="https://adibender.github.io/pammtools/articles/strata.html">strata</a>:
Specifying stratified models in which each level of a grouping variable has a
different baseline hazard.
</p>
</li>
<li> <p><a href="https://adibender.github.io/pammtools/articles/tdcovar.html">tdcovar</a>:
Dealing with time-dependent covariates.
</p>
</li>
<li> <p><a href="https://adibender.github.io/pammtools/articles/tveffects.html">tveffects</a>:
Specifying time-varying effects.
</p>
</li>
<li> <p><a href="https://adibender.github.io/pammtools/articles/left-truncation.html">left-truncation</a>:
Estimation for left-truncated data.
</p>
</li>
<li> <p><a href="https://adibender.github.io/pammtools/articles/competing-risks.html">competing-risks</a>:
Competing risks analysis.
</p>
</li></ul>



<h3>References</h3>

<p>Bender, Andreas, Andreas Groll, and Fabian Scheipl. 2018.
A Generalized Additive Model Approach to Time-to-Event Analysis
Statistical Modelling, February. https://doi.org/10.1177/1471082X17748083.
</p>
<p>Bender, Andreas, Fabian Scheipl, Wolfgang Hartl, Andrew G. Day, and Helmut Kchenhoff. 2019.
Penalized Estimation of Complex, Non-Linear Exposure-Lag-Response Associations.
Biostatistics 20 (2): 31531. https://doi.org/10.1093/biostatistics/kxy003.
</p>
<p>Bender, Andreas, and Fabian Scheipl. 2018.
pammtools: Piece-Wise Exponential Additive Mixed Modeling Tools.
ArXiv:1806.01042 <a href="ggplot2.html#topic+Stat">Stat</a>, June. https://arxiv.org/abs/1806.01042.
</p>

<hr>
<h2 id='patient'>Survival data of critically ill ICU patients</h2><span id='topic+patient'></span>

<h3>Description</h3>

<p>A data set containing the survival time (or hospital release time) among
other covariates.
The full data is available <a href="https://github.com/adibender/elra-biostats">here</a>.
The following variables are provided:
</p>

<dl>
<dt>Year</dt><dd><p>The year of ICU Admission</p>
</dd>
<dt>CombinedicuID</dt><dd><p>Intensive Care Unit (ICU) ID</p>
</dd>
<dt>CombinedID</dt><dd><p>Patient identificator</p>
</dd>
<dt>Survdays</dt><dd><p>Survival time of patients. Here it is assumed that patients
survive until t=30 if released from hospital.</p>
</dd>
<dt>PatientDied</dt><dd><p>Status indicator; 1=death, 0=censoring</p>
</dd>
<dt>survhosp</dt><dd><p>Survival time in hospital. Here it is assumed that patients
are censored at time of hospital release (potentially informative)</p>
</dd>
<dt>Gender</dt><dd><p>Male or female</p>
</dd>
<dt>Age</dt><dd><p>The patients age at Admission</p>
</dd>
<dt>AdmCatID</dt><dd><p>Admission category: medical, surgical elective or surgical emergency</p>
</dd>
<dt>ApacheIIScore</dt><dd><p>The patient's Apache II Score at Admission</p>
</dd>
<dt>BMI</dt><dd><p>Patient's Body Mass Index</p>
</dd>
<dt>DiagID2</dt><dd><p>Diagnosis at admission in 9 categories</p>
</dd>  </dl>



<h3>Usage</h3>

<pre><code class='language-R'>patient
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 2000 rows and 12 columns.
</p>

<hr>
<h2 id='ped_info'>Extract interval information and median/modus values for covariates</h2><span id='topic+ped_info'></span><span id='topic+ped_info.ped'></span>

<h3>Description</h3>

<p>Given an object of class <code>ped</code>, returns data frame with one row for each
interval containing interval information, mean values for numerical
variables and modus for non-numeric variables in the data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ped_info(ped)

## S3 method for class 'ped'
ped_info(ped)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ped_info_+3A_ped">ped</code></td>
<td>
<p>An object of class <code>ped</code> as returned by
<code><a href="#topic+as_ped">as_ped</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one row for each unique interval in <code>ped</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+int_info">int_info</a></code>, <code><a href="#topic+sample_info">sample_info</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped &lt;- tumor[1:4,] %&gt;% as_ped(Surv(days, status)~ sex + age)
ped_info(ped)
</code></pre>

<hr>
<h2 id='predictSurvProb.pamm'>S3 method for pamm objects for compatibility with package pec</h2><span id='topic+predictSurvProb.pamm'></span>

<h3>Description</h3>

<p>S3 method for pamm objects for compatibility with package pec
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pamm'
predictSurvProb(object, newdata, times, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictSurvProb.pamm_+3A_object">object</code></td>
<td>
<p>A fitted model from which to extract predicted survival
probabilities</p>
</td></tr>
<tr><td><code id="predictSurvProb.pamm_+3A_newdata">newdata</code></td>
<td>
<p>A data frame containing predictor variable combinations for
which to compute predicted survival probabilities.</p>
</td></tr>
<tr><td><code id="predictSurvProb.pamm_+3A_times">times</code></td>
<td>
<p>A vector of times in the range of the response variable, e.g.
times when the response is a survival object, at which to return the
survival probabilities.</p>
</td></tr>
<tr><td><code id="predictSurvProb.pamm_+3A_...">...</code></td>
<td>
<p>Additional arguments that are passed on to the current method.</p>
</td></tr>
</table>

<hr>
<h2 id='prep_concurrent'>Extract information on concurrent effects</h2><span id='topic+prep_concurrent'></span><span id='topic+prep_concurrent.list'></span>

<h3>Description</h3>

<p>Extract information on concurrent effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_concurrent(x, formula, ...)

## S3 method for class 'list'
prep_concurrent(x, formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_concurrent_+3A_x">x</code></td>
<td>
<p>A suitable object from which variables contained in
<code>formula</code> can be extracted.</p>
</td></tr>
<tr><td><code id="prep_concurrent_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td></tr>
</table>

<hr>
<h2 id='rpexp'>Draw random numbers from piece-wise exponential distribution.</h2><span id='topic+rpexp'></span>

<h3>Description</h3>

<p>This is a copy of the same function from <code>rpexp</code> from package
<span class="pkg">msm</span>.
Copied here to reduce dependencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpexp(n = 1, rate = 1, t = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpexp_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="rpexp_+3A_rate">rate</code></td>
<td>
<p>vector of rates.</p>
</td></tr>
<tr><td><code id="rpexp_+3A_t">t</code></td>
<td>
<p>vector of the same length as <code>rate</code>, giving the times at
which the rate changes. The first element of <code>t</code> should be 0,
and <code>t</code> should be in increasing order.</p>
</td></tr>
</table>

<hr>
<h2 id='sample_info'>Extract information of the sample contained in a data set</h2><span id='topic+sample_info'></span><span id='topic+sample_info.data.frame'></span><span id='topic+sample_info.ped'></span><span id='topic+sample_info.fped'></span>

<h3>Description</h3>

<p>Given a data set and grouping variables, this function returns mean values
for numeric variables and modus for characters and factors. Usually
this function should not be called directly but will rather be called
as part of a call to <code>make_newdata</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_info(x)

## S3 method for class 'data.frame'
sample_info(x)

## S3 method for class 'ped'
sample_info(x)

## S3 method for class 'fped'
sample_info(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_info_+3A_x">x</code></td>
<td>
<p>A data frame (or object that inherits from <code>data.frame</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing sample information (for each group).
If applied to an object of class <code>ped</code>, the sample means of the
original data is returned.
Note: When applied to a <code>ped</code> object, that doesn't contain covariates
(only interval information), returns data frame with 0 columns.
</p>

<hr>
<h2 id='seq_range'>Generate a sequence over the range of a vector</h2><span id='topic+seq_range'></span>

<h3>Description</h3>

<p>Stolen from
<a href="https://github.com/tidyverse/modelr/blob/master/R/seq_range.R">here</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_range(x, n, by, trim = NULL, expand = NULL, pretty = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_range_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="seq_range_+3A_n">n</code>, <code id="seq_range_+3A_by">by</code></td>
<td>
<p>Specify the output sequence either by supplying the
length of the sequence with <code>n</code>, or the spacing between value
with <code>by</code>. Specifying both is an error.
</p>
<p>I recommend that you name these arguments in order to make it clear to
the reader.</p>
</td></tr>
<tr><td><code id="seq_range_+3A_trim">trim</code></td>
<td>
<p>Optionally, trim values off the tails.
<code>trim / 2 * length(x)</code> values are removed from each tail.</p>
</td></tr>
<tr><td><code id="seq_range_+3A_expand">expand</code></td>
<td>
<p>Optionally, expand the range by <code>expand * (1 + range(x)</code>
(computed after trimming).</p>
</td></tr>
<tr><td><code id="seq_range_+3A_pretty">pretty</code></td>
<td>
<p>If <code>TRUE</code>, will generate a pretty sequence. If <code>n</code>
is supplied, this will use <code><a href="base.html#topic+pretty">pretty</a>()</code> instead of
<code><a href="base.html#topic+seq">seq</a>()</code>. If <code>by</code> is supplied, it will round the first
value to a multiple of <code>by</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rcauchy(100)
seq_range(x, n = 10)
seq_range(x, n = 10, trim = 0.1)
seq_range(x, by = 1, trim = 0.1)

# Make pretty sequences
y &lt;- runif (100)
seq_range(y, n = 10)
seq_range(y, n = 10, pretty = TRUE)
seq_range(y, n = 10, expand = 0.5, pretty = TRUE)

seq_range(y, by = 0.1)
seq_range(y, by = 0.1, pretty = TRUE)
</code></pre>

<hr>
<h2 id='sim_pexp'>Simulate survival times from the piece-wise exponential distribution</h2><span id='topic+sim_pexp'></span>

<h3>Description</h3>

<p>Simulate survival times from the piece-wise exponential distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_pexp(formula, data, cut)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_pexp_+3A_formula">formula</code></td>
<td>
<p>An extended formula that specifies the linear predictor.
If you want to include a smooth baseline
or time-varying effects, use <code>t</code> within your formula as
if it was a covariate in the data, although it is not and should not
be included in the <code>data</code> provided to <code>sim_pexp</code>. See examples
below.</p>
</td></tr>
<tr><td><code id="sim_pexp_+3A_data">data</code></td>
<td>
<p>A data set with variables specified in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="sim_pexp_+3A_cut">cut</code></td>
<td>
<p>A sequence of time-points starting with 0.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
library(dplyr)
library(pammtools)

# set number of observations/subjects
n &lt;- 250
# create data set with variables which will affect the hazard rate.
df &lt;- cbind.data.frame(x1 = runif (n, -3, 3), x2 = runif (n, 0, 6)) %&gt;%
 as_tibble()
# the formula which specifies how covariates affet the hazard rate
f0 &lt;- function(t) {
 dgamma(t, 8, 2) *6
}
form &lt;- ~ -3.5 + f0(t) -0.5*x1 + sqrt(x2)
set.seed(24032018)
sim_df &lt;- sim_pexp(form, df, 1:10)
head(sim_df)
plot(survfit(Surv(time, status)~1, data = sim_df ))

# for control, estimate with Cox PH
mod &lt;- coxph(Surv(time, status) ~ x1 + pspline(x2), data=sim_df)
coef(mod)[1]
layout(matrix(1:2, nrow=1))
termplot(mod, se = TRUE)

# and using PAMs
layout(1)
ped &lt;- sim_df %&gt;% as_ped(Surv(time, status)~., max_time=10)
library(mgcv)
pam &lt;- gam(ped_status ~ s(tend) + x1 + s(x2), data=ped, family=poisson, offset=offset)
coef(pam)[2]
plot(pam, page=1)

## Not run: 
# Example 2: Functional covariates/cumulative coefficients
# function to generate one exposure profile, tz is a vector of time points
# at which TDC z was observed
rng_z = function(nz) {
  as.numeric(arima.sim(n = nz, list(ar = c(.8, -.6))))
}
# two different exposure times  for two different exposures
tz1 &lt;- 1:10
tz2 &lt;- -5:5
# generate exposures and add to data set
df &lt;- df %&gt;%
  add_tdc(tz1, rng_z) %&gt;%
  add_tdc(tz2, rng_z)
df

# define tri-variate function of time, exposure time and exposure z
ft &lt;- function(t, tmax) {
  -1*cos(t/tmax*pi)
}
fdnorm &lt;- function(x) (dnorm(x,1.5,2)+1.5*dnorm(x,7.5,1))
wpeak2 &lt;- function(lag) 15*dnorm(lag,8,10)
wdnorm &lt;- function(lag) 5*(dnorm(lag,4,6)+dnorm(lag,25,4))
f_xyz1 &lt;- function(t, tz, z) {
  ft(t, tmax=10) * 0.8*fdnorm(z)* wpeak2(t - tz)
}
f_xyz2 &lt;- function(t, tz, z) {
  wdnorm(t-tz) * z
}

# define lag-lead window function
ll_fun &lt;- function(t, tz) {t &gt;= tz}
ll_fun2 &lt;- function(t, tz) {t - 2 &gt;= tz}
# simulate data with cumulative effect
sim_df &lt;- sim_pexp(
  formula = ~ -3.5 + f0(t) -0.5*x1 + sqrt(x2)|
     fcumu(t, tz1, z.tz1, f_xyz=f_xyz1, ll_fun=ll_fun) +
     fcumu(t, tz2, z.tz2, f_xyz=f_xyz2, ll_fun=ll_fun2),
  data = df,
  cut = 0:10)

## End(Not run)
</code></pre>

<hr>
<h2 id='sim_pexp_cr'>Simulate data for competing risks scenario</h2><span id='topic+sim_pexp_cr'></span>

<h3>Description</h3>

<p>Simulate data for competing risks scenario
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_pexp_cr(formula, data, cut)
</code></pre>

<hr>
<h2 id='simdf_elra'>Simulated data with cumulative effects</h2><span id='topic+simdf_elra'></span>

<h3>Description</h3>

<p>This is data simulated using the <code><a href="#topic+sim_pexp">sim_pexp</a></code> function.
It contains two time-constant and two time-dependent covariates (observed
on different exposure time grids). The code used for simulation is
contained in the examples of <code>?sim_pexp</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simdf_elra
</code></pre>


<h3>Format</h3>

<p>An object of class <code>nested_fdf</code> (inherits from <code>sim_df</code>, <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 250 rows and 9 columns.
</p>

<hr>
<h2 id='split_data'>Function to transform data without time-dependent covariates into piece-wise
exponential data format</h2><span id='topic+split_data'></span>

<h3>Description</h3>

<p>Function to transform data without time-dependent covariates into piece-wise
exponential data format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_data(
  formula,
  data,
  cut = NULL,
  max_time = NULL,
  multiple_id = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_data_+3A_formula">formula</code></td>
<td>
<p>A two sided formula with a <code><a href="survival.html#topic+Surv">Surv</a></code> object
on the left-hand-side and covariate specification on the right-hand-side (RHS).
The RHS can be an extended formula, which specifies how TDCs should be transformed
using specials <code>concurrent</code> and <code>cumulative</code>. The left hand-side can
be in start-stop-notation. This, however, is only used to create left-truncated
data and does not support the full functionality.</p>
</td></tr>
<tr><td><code id="split_data_+3A_data">data</code></td>
<td>
<p>Either an object inheriting from data frame or in case of
time-dependent covariates a list of data frames (of length 2), where the first data frame
contains the time-to-event information and static covariates while the second
(and potentially further data frames) contain information on time-dependent
covariates and the times at which they have been observed.</p>
</td></tr>
<tr><td><code id="split_data_+3A_cut">cut</code></td>
<td>
<p>Split points, used to partition the follow up into intervals.
If unspecified, all unique event times will be used.</p>
</td></tr>
<tr><td><code id="split_data_+3A_max_time">max_time</code></td>
<td>
<p>If <code>cut</code> is unspecified, this will be the last
possible event time. All event times after <code>max_time</code>
will be administratively censored at <code>max_time</code>.</p>
</td></tr>
<tr><td><code id="split_data_+3A_multiple_id">multiple_id</code></td>
<td>
<p>Are occurences of same id allowed (per transition).
Defaults to <code>FALSE</code>, but is sometimes set to <code>TRUE</code>, e.g., in case of
multi-state models with back transitions.</p>
</td></tr>
<tr><td><code id="split_data_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code>data.frame</code> method and
eventually to <code><a href="survival.html#topic+survSplit">survSplit</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+survSplit">survSplit</a></code>
</p>

<hr>
<h2 id='split_data_multistate'>Split data to obtain recurrent event data in PED format</h2><span id='topic+split_data_multistate'></span>

<h3>Description</h3>

<p>Currently, the input data must be in start-stop notation for each spell and
contain a colum that indicates the spell (event number).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_data_multistate(
  formula,
  data,
  transition = character(),
  cut = NULL,
  max_time = NULL,
  event = 1L,
  min_events = 1L,
  timescale = c("gap", "calendar"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_data_multistate_+3A_formula">formula</code></td>
<td>
<p>A two sided formula with a <code><a href="survival.html#topic+Surv">Surv</a></code> object
on the left-hand-side and covariate specification on the right-hand-side (RHS).
The RHS can be an extended formula, which specifies how TDCs should be transformed
using specials <code>concurrent</code> and <code>cumulative</code>. The left hand-side can
be in start-stop-notation. This, however, is only used to create left-truncated
data and does not support the full functionality.</p>
</td></tr>
<tr><td><code id="split_data_multistate_+3A_data">data</code></td>
<td>
<p>Either an object inheriting from data frame or in case of
time-dependent covariates a list of data frames (of length 2), where the first data frame
contains the time-to-event information and static covariates while the second
(and potentially further data frames) contain information on time-dependent
covariates and the times at which they have been observed.</p>
</td></tr>
<tr><td><code id="split_data_multistate_+3A_transition">transition</code></td>
<td>
<p>A character indicating the column in data that indicates the
event/episode number for recurrent events.</p>
</td></tr>
<tr><td><code id="split_data_multistate_+3A_cut">cut</code></td>
<td>
<p>Split points, used to partition the follow up into intervals.
If unspecified, all unique event times will be used.</p>
</td></tr>
<tr><td><code id="split_data_multistate_+3A_max_time">max_time</code></td>
<td>
<p>If <code>cut</code> is unspecified, this will be the last
possible event time. All event times after <code>max_time</code>
will be administratively censored at <code>max_time</code>.</p>
</td></tr>
<tr><td><code id="split_data_multistate_+3A_event">event</code></td>
<td>
<p>The value that encodes the occurrence of an event in the data set.</p>
</td></tr>
<tr><td><code id="split_data_multistate_+3A_min_events">min_events</code></td>
<td>
<p>Minimum number of events for each event number.</p>
</td></tr>
<tr><td><code id="split_data_multistate_+3A_timescale">timescale</code></td>
<td>
<p>Defines the timescale for the recurrent event data transformation.
Defaults to <code>"gaptime"</code>.</p>
</td></tr>
<tr><td><code id="split_data_multistate_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code>data.frame</code> method and
eventually to <code><a href="survival.html#topic+survSplit">survSplit</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+survSplit">survSplit</a></code>
</p>

<hr>
<h2 id='staph'>Time until staphylococcus aureaus infection in children, with possible recurrence</h2><span id='topic+staph'></span>

<h3>Description</h3>

<p>This dataset originates from the Drakenstein child health study.
The data contains the following variables:
</p>

<dl>
<dt>id</dt><dd><p>Randomly generated unique child ID</p>
</dd>
<dt>t.start</dt><dd><p>The time at which the child enters the risk set for the $k$-th event</p>
</dd>
<dt>t.stop</dt><dd><p>Time of $k$-th infection or censoring</p>
</dd></dl>
<p>.
</p>
<dl>
<dt>enum</dt><dd><p>Event number. Maximum of 6.</p>
</dd>
<dt>hiv</dt><dd></dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>staph
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 374 rows and 6 columns.
</p>

<hr>
<h2 id='tidy_fixed'>Extract fixed coefficient table from model object</h2><span id='topic+tidy_fixed'></span><span id='topic+tidy_fixed.gam'></span><span id='topic+tidy_fixed.coxph'></span>

<h3>Description</h3>

<p>Given a model object, returns a data frame with columns <code>variable</code>,
<code>coef</code> (coefficient), <code>ci_lower</code> (lower 95\
<code>ci_upper</code> (upper 95\
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_fixed(x, ...)

## S3 method for class 'gam'
tidy_fixed(x, intercept = FALSE, ...)

## S3 method for class 'coxph'
tidy_fixed(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_fixed_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="tidy_fixed_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="tidy_fixed_+3A_intercept">intercept</code></td>
<td>
<p>Should intercept also be returned? Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
gc &lt;- coxph(Surv(days, status)~age + sex, data = tumor)
tidy_fixed(gc)
</code></pre>

<hr>
<h2 id='tidy_re'>Extract random effects in tidy data format.</h2><span id='topic+tidy_re'></span>

<h3>Description</h3>

<p>Extract random effects in tidy data format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_re(x, keep = c("fit", "main", "xlab", "ylab"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_re_+3A_x">x</code></td>
<td>
<p> a fitted <code>gam</code> object as produced by <code>gam()</code>.</p>
</td></tr>
<tr><td><code id="tidy_re_+3A_keep">keep</code></td>
<td>
<p>A vector of variables to keep.</p>
</td></tr>
<tr><td><code id="tidy_re_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+qqline">qqline</a></code>
</p>

<hr>
<h2 id='tidy_smooth'>Extract 1d smooth objects in tidy data format.</h2><span id='topic+tidy_smooth'></span>

<h3>Description</h3>

<p>Extract 1d smooth objects in tidy data format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_smooth(x, keep = c("x", "fit", "se", "xlab", "ylab"), ci = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_smooth_+3A_x">x</code></td>
<td>
<p> a fitted <code>gam</code> object as produced by <code>gam()</code>.</p>
</td></tr>
<tr><td><code id="tidy_smooth_+3A_keep">keep</code></td>
<td>
<p>A vector of variables to keep.</p>
</td></tr>
<tr><td><code id="tidy_smooth_+3A_ci">ci</code></td>
<td>
<p>A logical value indicating whether confidence intervals should be
calculated and returned. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tidy_smooth_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='tidy_smooth2d'>Extract 2d smooth objects in tidy format.</h2><span id='topic+tidy_smooth2d'></span>

<h3>Description</h3>

<p>Extract 2d smooth objects in tidy format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_smooth2d(
  x,
  keep = c("x", "y", "fit", "se", "xlab", "ylab", "main"),
  ci = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_smooth2d_+3A_x">x</code></td>
<td>
<p> a fitted <code>gam</code> object as produced by <code>gam()</code>.</p>
</td></tr>
<tr><td><code id="tidy_smooth2d_+3A_keep">keep</code></td>
<td>
<p>A vector of variables to keep.</p>
</td></tr>
<tr><td><code id="tidy_smooth2d_+3A_ci">ci</code></td>
<td>
<p>A logical value indicating whether confidence intervals should be
calculated and returned. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tidy_smooth2d_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='tumor'>Stomach area tumor data</h2><span id='topic+tumor'></span>

<h3>Description</h3>

<p>Information on patients treated for a cancer disease
located in the stomach area.
The data set includes:
</p>

<dl>
<dt>days</dt><dd><p>Time from operation until death in days.</p>
</dd>
<dt>status</dt><dd><p>Event indicator (0 = censored, 1 = death).</p>
</dd>
<dt>age</dt><dd><p>The subject's age.</p>
</dd>
<dt>sex</dt><dd><p>The subject's sex (male/female).</p>
</dd>
<dt>charlson_score</dt><dd><p>Charlson comorbidity score, 1-6.</p>
</dd>
<dt>transfusion</dt><dd><p>Has subject received transfusions (no/yes).</p>
</dd>
<dt>complications</dt><dd><p>Did major complications occur during operation (no/yes).</p>
</dd>
<dt>metastases</dt><dd><p>Did the tumor develop metastases? (no/yes).</p>
</dd>
<dt>resection</dt><dd><p>Was the operation accompanied by a major resection (no/yes).</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>tumor
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 776 rows and 9 columns.
</p>

<hr>
<h2 id='warn_about_new_time_points'>Warn if new t_j are used</h2><span id='topic+warn_about_new_time_points'></span><span id='topic+warn_about_new_time_points.pamm'></span>

<h3>Description</h3>

<p>Warn if new t_j are used
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warn_about_new_time_points(object, newdata, ...)

## S3 method for class 'pamm'
warn_about_new_time_points(object, newdata, ...)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
