<!DOCTYPE html><html><head><title>Help for package clarify</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {clarify}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#clarify-package'><p>clarify: Simulation-Based Inference for Regression Models</p></a></li>
<li><a href='#misim'><p>Simulate model coefficients after multiple imputation</p></a></li>
<li><a href='#plot.clarify_adrf'><p>Plot marginal predictions from <code>sim_adrf()</code></p></a></li>
<li><a href='#plot.clarify_est'><p>Plotting and inference for <code>clarify_est</code> objects</p></a></li>
<li><a href='#plot.clarify_setx'><p>Plot marginal predictions from <code>sim_setx()</code></p></a></li>
<li><a href='#sim'><p>Simulate model parameters</p></a></li>
<li><a href='#sim_adrf'><p>Compute an average dose-response function</p></a></li>
<li><a href='#sim_ame'><p>Compute average marginal effects</p></a></li>
<li><a href='#sim_apply'><p>Apply a function to simulated parameter values</p></a></li>
<li><a href='#sim_setx'><p>Compute predictions and first differences at set values</p></a></li>
<li><a href='#transform.clarify_est'><p>#' Transform and combine <code>clarify_est</code> objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulation-Based Inference for Regression Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs simulation-based inference as an alternative to the delta method for obtaining valid confidence intervals and p-values for regression post-estimation quantities, such as average marginal effects and predictions at representative values. This framework for simulation-based inference is especially useful when the resulting quantity is not normally distributed and the delta method approximation fails. The methodology is described in King, Tomz, and Wittenberg (2000) &lt;<a href="https://doi.org/10.2307%2F2669316">doi:10.2307/2669316</a>&gt;. 'clarify' is meant to replace some of the functionality of the archived package 'Zelig'; see the vignette "Translating Zelig to clarify" for replicating this functionality.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2 (&ge; 3.4.0), pbapply (&ge; 1.7-0), chk (&ge; 0.9.0), rlang
(&ge; 1.0.6), insight (&ge; 0.19.11), marginaleffects (&ge; 0.20.0),
mvnfast (&ge; 0.2.6)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), MatchIt (&ge; 4.0.0), parallel, knitr,
rmarkdown, Amelia, MASS, betareg, survey, estimatr, fixest,
logistf, geepack, rms, robustbase, robust, AER, ivreg, mgcv,
sandwich</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/iqss/clarify">https://github.com/iqss/clarify</a>, <a href="https://iqss.github.io/clarify/">https://iqss.github.io/clarify/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/iqss/clarify/issues">https://github.com/iqss/clarify/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-30 16:19:45 UTC; ngreifer</td>
</tr>
<tr>
<td>Author:</td>
<td>Noah Greifer <a href="https://orcid.org/0000-0003-3067-7154"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Steven Worthington
    <a href="https://orcid.org/0000-0001-9550-5797"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Stefano Iacus <a href="https://orcid.org/0000-0002-4884-0047"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Gary King <a href="https://orcid.org/0000-0002-5327-7631"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Noah Greifer &lt;ngreifer@iq.harvard.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-30 16:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='clarify-package'>clarify: Simulation-Based Inference for Regression Models</h2><span id='topic+clarify'></span><span id='topic+clarify-package'></span>

<h3>Description</h3>

<p>Performs simulation-based inference as an alternative to the delta method for obtaining valid confidence intervals and p-values for regression post-estimation quantities, such as average marginal effects and predictions at representative values. This framework for simulation-based inference is especially useful when the resulting quantity is not normally distributed and the delta method approximation fails. The methodology is described in King, Tomz, and Wittenberg (2000) <a href="https://doi.org/10.2307/2669316">doi:10.2307/2669316</a>. 'clarify' is meant to replace some of the functionality of the archived package 'Zelig'; see the vignette &quot;Translating Zelig to clarify&quot; for replicating this functionality.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Noah Greifer <a href="mailto:ngreifer@iq.harvard.edu">ngreifer@iq.harvard.edu</a> (<a href="https://orcid.org/0000-0003-3067-7154">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Steven Worthington <a href="mailto:sworthington@iq.harvard.edu">sworthington@iq.harvard.edu</a> (<a href="https://orcid.org/0000-0001-9550-5797">ORCID</a>)
</p>
</li>
<li><p> Stefano Iacus <a href="mailto:siacus@iq.harvard.edu">siacus@iq.harvard.edu</a> (<a href="https://orcid.org/0000-0002-4884-0047">ORCID</a>)
</p>
</li>
<li><p> Gary King <a href="mailto:king@harvard.edu">king@harvard.edu</a> (<a href="https://orcid.org/0000-0002-5327-7631">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/iqss/clarify">https://github.com/iqss/clarify</a>
</p>
</li>
<li> <p><a href="https://iqss.github.io/clarify/">https://iqss.github.io/clarify/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/iqss/clarify/issues">https://github.com/iqss/clarify/issues</a>
</p>
</li></ul>


<hr>
<h2 id='misim'>Simulate model coefficients after multiple imputation</h2><span id='topic+misim'></span>

<h3>Description</h3>

<p><code>misim()</code> simulates model parameters from multivariate normal or t distributions after multiple imputation that are then used by <code><a href="#topic+sim_apply">sim_apply()</a></code> to calculate quantities of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>misim(fitlist, n = 1000, vcov = NULL, coefs = NULL, dist = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="misim_+3A_fitlist">fitlist</code></td>
<td>
<p>a list of model fits, one for each imputed dataset, or a <code>mira</code> object (the output of a call to <code>with()</code> applied to a <code>mids</code> object in <code>mice</code>).</p>
</td></tr>
<tr><td><code id="misim_+3A_n">n</code></td>
<td>
<p>the number of simulations to run for each imputed dataset; default is 1000. More is always better but resulting calculations will take longer.</p>
</td></tr>
<tr><td><code id="misim_+3A_vcov">vcov</code></td>
<td>
<p>a square covariance matrix of the coefficient covariance estimates, a function to use to extract it from <code>fit</code>, or a list thereof with an element for each imputed dataset. By default, uses <code><a href="stats.html#topic+vcov">stats::vcov()</a></code> or <code><a href="insight.html#topic+get_varcov">insight::get_varcov()</a></code> if that doesn't work.</p>
</td></tr>
<tr><td><code id="misim_+3A_coefs">coefs</code></td>
<td>
<p>a vector of coefficient estimates, a function to use to extract it from <code>fit</code>, or a list thereof with an element for each imputed dataset. By default, uses <code><a href="stats.html#topic+coef">stats::coef()</a></code> or <code><a href="insight.html#topic+get_parameters">insight::get_parameters()</a></code> if that doesn't work.</p>
</td></tr>
<tr><td><code id="misim_+3A_dist">dist</code></td>
<td>
<p>a character vector containing the name of the multivariate distribution(s) to use to draw simulated coefficients. Should be one of <code>"normal"</code> (multivariate normal distribution) or <code>"t_{#}"</code> (multivariate t distribution), where <code style="white-space: pre;">&#8288;{#}&#8288;</code> corresponds to the desired degrees of freedom (e.g., <code>"t_100"</code>). If <code>NULL</code>, the right distributions to use will be determined based on heuristics; see <code><a href="#topic+sim">sim()</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>misim()</code> essentially combines multiple <code>sim()</code> calls applied to a list of model fits, each fit in an imputed dataset, into a single combined pool of simulated coefficients. When simulation-based inference is to be used with multiply imputed data, many imputations are required; see Zhou and Reiter (2010).
</p>


<h3>Value</h3>

<p>A <code>clarify_misim</code> object, which inherits from <code>clarify_sim</code> and has the following components:
</p>
<table>
<tr><td><code>sim.coefs</code></td>
<td>
<p>a matrix containing the simulated coefficients with a column for each coefficient and a row for each simulation for each imputation</p>
</td></tr>
<tr><td><code>coefs</code></td>
<td>
<p>a matrix containing the original coefficients extracted from <code>fitlist</code> or supplied to <code>coefs</code>, with a row per imputation.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>the list of model fits supplied to <code>fitlist</code></p>
</td></tr>
<tr><td><code>imp</code></td>
<td>
<p>a identifier of which imputed dataset each set of simulated coefficients corresponds to.</p>
</td></tr>
</table>
<p>The <code>"dist"</code> attribute contains <code>"normal"</code> if the coefficients were sampled from a multivariate normal distribution and <code>"t({df})"</code> if sampled from a multivariate t distribution. The <code>"clarify_hash"</code> attribute contains a unique hash generated by <code><a href="rlang.html#topic+hash">rlang::hash()</a></code>.
</p>


<h3>References</h3>

<p>Zhou, X., &amp; Reiter, J. P. (2010). A Note on Bayesian Inference After Multiple Imputation. <em>The American Statistician</em>, 64(2), 159–163. <a href="https://doi.org/10.1198/tast.2010.09109">doi:10.1198/tast.2010.09109</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+sim">sim()</a></code> for simulating model coefficients for a single dataset
</p>
</li>
<li> <p><code><a href="#topic+sim_apply">sim_apply()</a></code> for applying a function to each set of simulated coefficients
</p>
</li>
<li> <p><code><a href="#topic+sim_ame">sim_ame()</a></code> for computing average marginal effects in each simulation draw
</p>
</li>
<li> <p><code><a href="#topic+sim_setx">sim_setx()</a></code> for computing marginal predictions and first differences at typical values in each simulation draw
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data("africa", package = "Amelia")

# Multiple imputation using Amelia
a.out &lt;- Amelia::amelia(x = africa, m = 10,
                        cs = "country",
                        ts = "year", logs = "gdp_pc",
                        p2s = 0)

fits &lt;- with(a.out, lm(gdp_pc ~ infl * trade))

# Simulate coefficients
s &lt;- misim(fits)
s

</code></pre>

<hr>
<h2 id='plot.clarify_adrf'>Plot marginal predictions from <code>sim_adrf()</code></h2><span id='topic+plot.clarify_adrf'></span>

<h3>Description</h3>

<p><code>plot.clarify_adrf()</code> plots the output of <code><a href="#topic+sim_adrf">sim_adrf()</a></code>. For the average dose-response function (ADRF, requested with <code>contrast = "adrf"</code> in <code>sim_adrf()</code>), this is a plot of the average marginal mean of the outcome against the requested values of the focal predictor; for the average marginal effects function (AMEF, requested with <code>contrast = "amef"</code> in <code>sim_adrf()</code>), this is a plot of the instantaneous average marginal effect of the focal predictor on the outcome against the requested values of the focal predictor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clarify_adrf'
plot(
  x,
  ci = TRUE,
  level = 0.95,
  method = "quantile",
  baseline,
  color = "black",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.clarify_adrf_+3A_x">x</code></td>
<td>
<p>a <code>clarify_adrf</code> object resulting from a call to <code><a href="#topic+sim_adrf">sim_adrf()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.clarify_adrf_+3A_ci">ci</code></td>
<td>
<p><code>logical</code>; whether to display confidence bands for the estimates. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.clarify_adrf_+3A_level">level</code></td>
<td>
<p>the confidence level desired. Default is .95 for 95% confidence intervals.</p>
</td></tr>
<tr><td><code id="plot.clarify_adrf_+3A_method">method</code></td>
<td>
<p>the method used to compute confidence bands. Can be <code>"wald"</code> to use a Normal approximation or <code>"quantile"</code> to use the simulated sampling distribution (default). See <code><a href="#topic+summary.clarify_est">summary.clarify_est()</a></code> for details. Abbreviations allowed.</p>
</td></tr>
<tr><td><code id="plot.clarify_adrf_+3A_baseline">baseline</code></td>
<td>
<p><code>logical</code>; whether to include a horizontal line at <code>y = 0</code> on the plot. Default is <code>FALSE</code> for the ADRF (since 0 might not be in the range of the outcome) and <code>TRUE</code> for the AMEF.</p>
</td></tr>
<tr><td><code id="plot.clarify_adrf_+3A_color">color</code></td>
<td>
<p>the color of the line and confidence band in the plot.</p>
</td></tr>
<tr><td><code id="plot.clarify_adrf_+3A_...">...</code></td>
<td>
<p>for <code>plot()</code>, further arguments passed to <code><a href="ggplot2.html#topic+geom_density">ggplot2::geom_density()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These plots are produced using <code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_line()</a></code> and <code><a href="ggplot2.html#topic+geom_ribbon">ggplot2::geom_ribbon()</a></code>. The confidence bands should be interpreted pointwise (i.e., they do not account for simultaneous inference).
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.clarify_est">summary.clarify_est()</a></code> for computing p-values and confidence intervals for the estimated quantities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See help("sim_adrf") for examples

</code></pre>

<hr>
<h2 id='plot.clarify_est'>Plotting and inference for <code>clarify_est</code> objects</h2><span id='topic+plot.clarify_est'></span><span id='topic+summary.clarify_est'></span><span id='topic+confint.clarify_est'></span>

<h3>Description</h3>

<p><code>summary()</code> tabulates the estimates and confidence intervals and (optionally) p-values from a <code>clarify_est</code> object. <code>confint()</code> computes confidence intervals. <code>plot()</code> plots the &quot;posterior&quot; distribution of estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clarify_est'
plot(
  x,
  parm,
  ci = TRUE,
  level = 0.95,
  method = "quantile",
  reference = FALSE,
  ncol = 3,
  ...
)

## S3 method for class 'clarify_est'
summary(object, parm, level = 0.95, method = "quantile", null = NA, ...)

## S3 method for class 'clarify_est'
confint(object, parm, level = 0.95, method = "quantile", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.clarify_est_+3A_parm">parm</code></td>
<td>
<p>a vector of the names or indices of the estimates to plot. If unspecified, all estimates will be displayed.</p>
</td></tr>
<tr><td><code id="plot.clarify_est_+3A_ci">ci</code></td>
<td>
<p><code>logical</code>; whether to display confidence interval limits for the estimates. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.clarify_est_+3A_level">level</code></td>
<td>
<p>the confidence level desired. Default is .95 for 95% confidence intervals.</p>
</td></tr>
<tr><td><code id="plot.clarify_est_+3A_method">method</code></td>
<td>
<p>the method used to compute p-values and confidence intervals. Can be <code>"wald"</code> to use a Normal approximation or <code>"quantile"</code> to use the simulated sampling distribution (default). See Details. Abbreviations allowed.</p>
</td></tr>
<tr><td><code id="plot.clarify_est_+3A_reference">reference</code></td>
<td>
<p><code>logical</code>; whether to overlay a normal density reference distribution over the plots. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.clarify_est_+3A_ncol">ncol</code></td>
<td>
<p>the number of columns used when wrapping multiple plots; default is 3.</p>
</td></tr>
<tr><td><code id="plot.clarify_est_+3A_...">...</code></td>
<td>
<p>for <code>plot()</code>, further arguments passed to <code><a href="ggplot2.html#topic+geom_density">ggplot2::geom_density()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.clarify_est_+3A_object">object</code>, <code id="plot.clarify_est_+3A_x">x</code></td>
<td>
<p>a <code>clarify_est</code> object; the output of a call to <code><a href="#topic+sim_apply">sim_apply()</a></code> or its wrappers.</p>
</td></tr>
<tr><td><code id="plot.clarify_est_+3A_null">null</code></td>
<td>
<p>the values of the parameters under the null hypothesis for the p-value calculations. Should have length equal to the number of quantities estimated, or one, in which case it will be recycled, or it can be a named vector with just the names of quantities for which null values are to be set. Set values to <code>NA</code> to omit p-values for those quantities. When all values are <code>NA</code>, the default, no p-values are produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary()</code> uses the estimates computed from the original model as its estimates and uses the simulated parameters for inference only, in line with the recommendations of Rainey (2023).
</p>
<p>When <code>method = "wald"</code>, the standard deviation of the simulation estimates is used as the standard error, which is used in the z-statistics and the confidence intervals. The p-values and confidence intervals are valid only when the sampling distribution of the resulting statistic is normal (which can be assessed using <code>plot()</code>). When <code>method = "quantile"</code>, the confidence interval is calculated using the quantiles of the simulation estimates corresponding to <code>level</code>, and the p-value is calculated as twice the proportion of simulation estimates less than or greater than <code>null</code>, whichever is smaller; this is equivalent to inverting the confidence interval but is only truly valid when the true sampling distribution is only a location shift from the sampling distribution under the null hypothesis and should therefore be interpreted with caution. Using <code style="white-space: pre;">&#8288;"method = "quantile"&#8288;</code> (the default) is recommended because the confidence intervals will be valid even if the sampling distribution is not Normally distributed. The precision of the p-values and confidence intervals depends on the number of simulations requested (the value of <code>n</code> supplied to <code><a href="#topic+sim">sim()</a></code>).
</p>
<p>The plots are produced using <code><a href="ggplot2.html#topic+geom_density">ggplot2::geom_density()</a></code> and can be customized with <span class="pkg">ggplot2</span> functions. When <code>reference = TRUE</code>, a reference Normal distribution is produced using the empirical mean and standard deviation of the simulated values. A blue references line is plotted at the median of the simulated values. For Wald-based inference to be valid, the reference distribution should overlap with the empirical distribution, in which case the quantile-based and Wald-based intervals should be similar. For quantile-based inference to be valid, the median of the estimates should overlap with the estimated value; this is a necessary but not sufficient condition, though.
</p>


<h3>Value</h3>

<p>For <code>summary()</code>, a <code>summary.clarify_est</code> object, which is a matrix containing the coefficient estimates, standard errors, test statistics, p-values, and confidence intervals. Not all columns will be present depending on the arguments supplied to <code>summary()</code>.
</p>
<p>For <code>confint()</code>, a matrix containing the confidence intervals for the requested quantities.
</p>
<p>For <code>plot()</code>, a <code>ggplot</code> object.
</p>


<h3>References</h3>

<p>Rainey, C. (2023). A careful consideration of CLARIFY: Simulation-induced bias in point estimates of quantities of interest. <em>Political Science Research and Methods</em>, 1–10. <a href="https://doi.org/10.1017/psrm.2023.8">doi:10.1017/psrm.2023.8</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+sim_apply">sim_apply()</a></code> for applying a function to each set of simulated coefficients
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data("lalonde", package = "MatchIt")
fit &lt;- glm(I(re78 &gt; 0) ~ treat + age + race + nodegree + re74,
          data = lalonde)

s &lt;- sim(fit, n = 100)

# Compute average marginal means for `treat`
est &lt;- sim_ame(s, var = "treat", verbose = FALSE)
coef(est)

# Compute average marginal effects on risk difference
# (RD) and risk ratio (RR) scale
est &lt;- transform(est,
                 RD = `E[Y(1)]` - `E[Y(0)]`,
                 RR = `E[Y(1)]` / `E[Y(0)]`)

# Compute confidence intervals and p-values,
# using given null values for computing p-values
summary(est, null = c(`RD` = 0, `RR` = 1))

# Same tests using normal approximation and alternate
# syntax for `null`
summary(est, null = c(NA, NA, 0, 1),
        normal = TRUE)

# Plot the RD and RR with a reference distribution
plot(est, parm = c("RD", "RR"), reference = TRUE,
     ci = FALSE)

# Plot the RD and RR with quantile confidence bounds
plot(est, parm = c("RD", "RR"), ci = TRUE)

</code></pre>

<hr>
<h2 id='plot.clarify_setx'>Plot marginal predictions from <code>sim_setx()</code></h2><span id='topic+plot.clarify_setx'></span>

<h3>Description</h3>

<p><code>plot.clarify_sext()</code> plots the output of <code><a href="#topic+sim_setx">sim_setx()</a></code>, providing graphics similar to those of <code><a href="#topic+plot.clarify_est">plot.clarify_est()</a></code> but with features specifically for plot marginal predictions. For continues predictors, this is a plot of the marginal predictions and their confidence bands across levels of the predictor. Otherwise, this is is a plot of simulated sampling distribution of the marginal predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clarify_setx'
plot(
  x,
  var = NULL,
  ci = TRUE,
  level = 0.95,
  method = "quantile",
  reference = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.clarify_setx_+3A_x">x</code></td>
<td>
<p>a <code>clarify_est</code> object resulting from a call to <code><a href="#topic+sim_setx">sim_setx()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.clarify_setx_+3A_var">var</code></td>
<td>
<p>the name of the focal varying predictor, i.e., the variable to be on the x-axis of the plot. All other variables with varying set values will be used to color the resulting plot. See Details. Ignored if no predictors vary or if only one predictor varies in the reference grid or if <code>x1</code> was specified in <code>sim_setx()</code>. If not set, will use the predictor with the greatest number of unique values specified in the reference grid.</p>
</td></tr>
<tr><td><code id="plot.clarify_setx_+3A_ci">ci</code></td>
<td>
<p><code>logical</code>; whether to display confidence intervals or bands for the estimates. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.clarify_setx_+3A_level">level</code></td>
<td>
<p>the confidence level desired. Default is .95 for 95% confidence intervals.</p>
</td></tr>
<tr><td><code id="plot.clarify_setx_+3A_method">method</code></td>
<td>
<p>the method used to compute confidence intervals or bands. Can be <code>"wald"</code> to use a Normal approximation or <code>"quantile"</code> to use the simulated sampling distribution (default). See <code><a href="#topic+summary.clarify_est">summary.clarify_est()</a></code> for details. Abbreviations allowed.</p>
</td></tr>
<tr><td><code id="plot.clarify_setx_+3A_reference">reference</code></td>
<td>
<p><code>logical</code>; whether to overlay a normal density reference distribution over the plots. Default is <code>FALSE</code>. Ignored when variables other than the focal varying predictor vary.</p>
</td></tr>
<tr><td><code id="plot.clarify_setx_+3A_...">...</code></td>
<td>
<p>for <code>plot()</code>, further arguments passed to <code><a href="ggplot2.html#topic+geom_density">ggplot2::geom_density()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot()</code> creates one of two kinds of plots depending on how the reference grid was specified in the call to <code>sim_setx()</code> and what <code>var</code> is set to. When the focal varying predictor (i.e., the one set in <code>var</code>) is numeric and takes on three or more unique values in the reference grid, the produced plot is a line graph displaying the value of the marginal prediction (denoted as <code>E[Y|X]</code>) across values of the focal varying predictor, with confidence bands displayed when <code>ci = TRUE</code>. If other predictors also vary, lines for different values will be displayed in different colors. These plots are produced using <code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_line()</a></code> and <code><a href="ggplot2.html#topic+geom_ribbon">ggplot2::geom_ribbon()</a></code>
</p>
<p>When the focal varying predictor is a factor or character or only takes on two or fewer values in the reference grid, the produced plot is a density plot of the simulated predictions, similar to the plot resulting from <code><a href="#topic+plot.clarify_est">plot.clarify_est()</a></code>. When other variables vary, densities for different values will be displayed in different colors. These plots are produced using <code><a href="ggplot2.html#topic+geom_density">ggplot2::geom_density()</a></code>.
</p>
<p>Marginal predictions are identified by the corresponding levels of the predictors that vary. The user should keep track of whether the non-varying predictors are set at specified or automatically set &quot;typical&quot; levels.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.clarify_est">summary.clarify_est()</a></code> for computing p-values and confidence intervals for the estimated quantities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See help("sim_setx") for examples

</code></pre>

<hr>
<h2 id='sim'>Simulate model parameters</h2><span id='topic+sim'></span>

<h3>Description</h3>

<p><code>sim()</code> simulates model parameters from a multivariate normal or t distribution that are then used by <code><a href="#topic+sim_apply">sim_apply()</a></code> to calculate quantities of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim(fit, n = 1000, vcov = NULL, coefs = NULL, dist = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_+3A_fit">fit</code></td>
<td>
<p>a model fit, such as the output of a call to <code><a href="stats.html#topic+lm">lm()</a></code> or <code><a href="stats.html#topic+glm">glm()</a></code>. Can be left unspecified if <code>coefs</code> and <code>vcov</code> are not functions.</p>
</td></tr>
<tr><td><code id="sim_+3A_n">n</code></td>
<td>
<p>the number of simulations to run; default is 1000. More is always better but resulting calculations will take longer.</p>
</td></tr>
<tr><td><code id="sim_+3A_vcov">vcov</code></td>
<td>
<p>either a square covariance matrix of the coefficient covariance estimates or a function to use to extract it from <code>fit</code>. By default, uses <code><a href="stats.html#topic+vcov">stats::vcov()</a></code> or <code><a href="insight.html#topic+get_varcov">insight::get_varcov()</a></code> if that doesn't work.</p>
</td></tr>
<tr><td><code id="sim_+3A_coefs">coefs</code></td>
<td>
<p>either a vector of coefficient estimates or a function to use to extract it from <code>fit</code>. By default, uses <code><a href="stats.html#topic+coef">stats::coef()</a></code> or <code><a href="insight.html#topic+get_parameters">insight::get_parameters()</a></code> if that doesn't work.</p>
</td></tr>
<tr><td><code id="sim_+3A_dist">dist</code></td>
<td>
<p>a string containing the name of the multivariate distribution to use to draw simulated coefficients. Should be one of <code>"normal"</code> (multivariate normal distribution) or <code>"t({#})"</code> (multivariate t distribution), where <code style="white-space: pre;">&#8288;{#}&#8288;</code> corresponds to the desired degrees of freedom (e.g., <code>"t(100)"</code>). If <code>NULL</code>, the right distribution to use will be determined based on heuristics; see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>dist</code> is <code>NULL</code>, <code>sim()</code> samples from a multivariate normal or t distribution depending on the degrees of freedom extracted from <code>insight::get_df(., type = "wald")</code>. If <code>Inf</code>, a normal distribution will be used; otherwise, a t-distribution with the returned degrees of freedom will be used. Models not supported by <code>insight</code> will use a normal distribution.
</p>
<p>When a multivariate normal is used, it is sampled from with means equal to the estimated coefficients and the parameter covariance matrix as the covariance matrix using <code><a href="mvnfast.html#topic+rmvn">mvnfast::rmvn()</a></code>. When a multivariate t distribution is used, it is sampled from with means equal to the estimated coefficients and scaling matrix equal to <code>cov*(df - 2)/df</code>, where <code>cov</code> is the parameter covariance matrix and <code>df</code> is the residual degrees of freedom for the model, using <code><a href="mvnfast.html#topic+rmvt">mvnfast::rmvt()</a></code>.
</p>


<h3>Value</h3>

<p>A <code>clarify_sim</code> object, which has the following components:
</p>
<table>
<tr><td><code>sim.coefs</code></td>
<td>
<p>a matrix containing the simulated coefficients with a column for each coefficient and a row for each simulation</p>
</td></tr>
<tr><td><code>coefs</code></td>
<td>
<p>the original coefficients extracted from <code>fit</code> or supplied to <code>coefs</code>.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>the covariance matrix of the coefficients extracted from <code>fit</code> or supplied to <code>vcov</code></p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>the original model fit supplied to <code>fit</code></p>
</td></tr>
</table>
<p>The <code>"dist"</code> attribute contains <code>"normal"</code> if the coefficients were sampled from a multivariate normal distribution and <code>"t(df)"</code> if sampled from a multivariate t distribution. The <code>"clarify_hash"</code> attribute contains a unique hash generated by <code><a href="rlang.html#topic+hash">rlang::hash()</a></code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+misim">misim()</a></code> for simulating model coefficients after multiple imputation
</p>
</li>
<li> <p><code><a href="#topic+sim_apply">sim_apply()</a></code> for applying a function to each set of simulated coefficients
</p>
</li>
<li> <p><code><a href="#topic+sim_ame">sim_ame()</a></code> for computing average marginal effects in each simulation draw
</p>
</li>
<li> <p><code><a href="#topic+sim_setx">sim_setx()</a></code> for computing marginal predictions and first differences at typical values in each simulation draw
</p>
</li>
<li> <p><code><a href="#topic+sim_adrf">sim_adrf()</a></code> for computing average dose-response functions in each simulation draw
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde", package = "MatchIt")
fit &lt;- lm(re78 ~ treat * (age + race + nodegree + re74), data = lalonde)

# Simulate coefficients
s &lt;- sim(fit)
s

## Could also use a robust covariance matrix, e.g.,
s &lt;- sim(fit, vcov = "HC3")

# Simulated coefficients assuming a normal distribution
# for coefficients; default for `lm` objects is a t-
# distribution
s &lt;- sim(fit, dist = "normal")
s

</code></pre>

<hr>
<h2 id='sim_adrf'>Compute an average dose-response function</h2><span id='topic+sim_adrf'></span><span id='topic+print.clarify_adrf'></span>

<h3>Description</h3>

<p><code>sim_adrf()</code> is a wrapper for <code><a href="#topic+sim_apply">sim_apply()</a></code> that computes average dose-response functions (ADRFs) and average marginal effect functions (AMEFs). An ADRF describes the relationship between values a focal variable can take and the expected value of the outcome were all units to be given each value of the variable. An AMEF describes the relationship between values a focal variable can take and the derivative of ADRF at each value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_adrf(
  sim,
  var,
  subset = NULL,
  by = NULL,
  contrast = "adrf",
  at = NULL,
  n = 21,
  outcome = NULL,
  type = NULL,
  eps = 1e-05,
  verbose = TRUE,
  cl = NULL
)

## S3 method for class 'clarify_adrf'
print(x, digits = NULL, max.ests = 6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_adrf_+3A_sim">sim</code></td>
<td>
<p>a <code>clarify_sim</code> object; the output of a call to <code><a href="#topic+sim">sim()</a></code> or
<code><a href="#topic+misim">misim()</a></code>.</p>
</td></tr>
<tr><td><code id="sim_adrf_+3A_var">var</code></td>
<td>
<p>the name of a variable for which the ADRF or AMEF is to be computed. This variable must be present in the model supplied to <code>sim()</code> and must be a numeric variable taking on more than two unique values.</p>
</td></tr>
<tr><td><code id="sim_adrf_+3A_subset">subset</code></td>
<td>
<p>optional; a vector used to subset the data used to compute the ADRF or AMEF. This will be evaluated within the original dataset used to fit the model using <code><a href="base.html#topic+subset">subset()</a></code>, so nonstandard evaluation is allowed.</p>
</td></tr>
<tr><td><code id="sim_adrf_+3A_by">by</code></td>
<td>
<p>a one-sided formula or character vector containing the names of variables for which to stratify the estimates. Each quantity will be computed within each level of the complete cross of the variables specified in <code>by</code>.</p>
</td></tr>
<tr><td><code id="sim_adrf_+3A_contrast">contrast</code></td>
<td>
<p>a string naming the type of quantity to be produced: <code>"adrf"</code> for the ADRF (the default) or <code>"amef"</code> for the AMEF.</p>
</td></tr>
<tr><td><code id="sim_adrf_+3A_at">at</code></td>
<td>
<p>the levels of the variable named in <code>var</code> at which to evaluate the ADRF or AMEF. Should be a vector of numeric values corresponding to possible levels of <code>var</code>. If <code>NULL</code>, will be set to a range from slightly below the lowest observed value of <code>var</code> to slightly above the largest value.</p>
</td></tr>
<tr><td><code id="sim_adrf_+3A_n">n</code></td>
<td>
<p>when <code>at = NULL</code>, the number of points to evaluate the ADRF or AMEF. Default is 21. Ignored when <code>at</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="sim_adrf_+3A_outcome">outcome</code></td>
<td>
<p>a string containing the name of the outcome or outcome level for multivariate (multiple outcomes) or multi-category outcomes. Ignored for univariate (single outcome) and binary outcomes.</p>
</td></tr>
<tr><td><code id="sim_adrf_+3A_type">type</code></td>
<td>
<p>a string containing the type of predicted values (e.g., the link or the response). Passed to <code><a href="marginaleffects.html#topic+get_predict">marginaleffects::get_predict()</a></code> and eventually to <code>predict()</code> in most cases. The default and allowable option depend on the type of model supplied, but almost always corresponds to the response scale (e.g., predicted probabilities for binomial models).</p>
</td></tr>
<tr><td><code id="sim_adrf_+3A_eps">eps</code></td>
<td>
<p>when <code>contrast = "amef"</code>, the value by which to shift the value of <code>var</code> to approximate the derivative. See Details.</p>
</td></tr>
<tr><td><code id="sim_adrf_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>; whether to display a text progress bar indicating
progress and estimated time remaining for the procedure. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sim_adrf_+3A_cl">cl</code></td>
<td>
<p>a cluster object created by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>, or an
integer to indicate the number of child-processes (integer values are
ignored on Windows) for parallel evaluations. See <code><a href="pbapply.html#topic+pbapply">pbapply::pblapply()</a></code> for
details. If <code>NULL</code>, no parallelization will take place.</p>
</td></tr>
<tr><td><code id="sim_adrf_+3A_x">x</code></td>
<td>
<p>a <code>clarify_adrf</code> object.</p>
</td></tr>
<tr><td><code id="sim_adrf_+3A_digits">digits</code></td>
<td>
<p>the minimum number of significant digits to be used; passed to <code><a href="base.html#topic+print.data.frame">print.data.frame()</a></code>.</p>
</td></tr>
<tr><td><code id="sim_adrf_+3A_max.ests">max.ests</code></td>
<td>
<p>the maximum number of estimates to display.</p>
</td></tr>
<tr><td><code id="sim_adrf_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ADRF is composed of average marginal means across levels of the focal predictor. For each level of the focal predictor, predicted values of the outcome are computed after setting the value of the predictor to that level, and those values of the outcome are averaged across all units in the sample to arrive at an average marginal mean. Thus, the ADRF represent the relationship between the &quot;dose&quot; (i.e., the level of the focal predictor) and the average &quot;response&quot; (i.e., the outcome variable). It is the continuous analog to the average marginal effect computed for a binary predictor, e.g., using <code><a href="#topic+sim_ame">sim_ame()</a></code>. Although inference can be at each level of the predictor or between two levels of the predictor, typically a plot of the ADRF is the most useful relevant quantity. These can be requested using <code><a href="#topic+plot.clarify_adrf">plot.clarify_adrf()</a></code>.
</p>
<p>The AMEF is the derivative of the ADRF; if we call the derivative of the ADRF at each point a &quot;treatment effect&quot; (i.e., the rate at which the outcome changes corresponding to a small change in the predictor, or &quot;treatment&quot;), the AMEF is a function that relates the size of the treatment effect to the level of the treatment. The shape of the AMEF is usually of less importance than the value of the AMEF at each level of the predictor, which corresponds to the size of the treatment effect at the corresponding level. The AMEF is computed by computing the ADRF at each level of the focal predictor specified in <code>at</code>, shifting the predictor value by a tiny amount (control by <code>eps</code>), and computing the ratio of the change in the outcome to the shift, then averaging this value across all units. This quantity is related the the average marginal effect of a continuous predictor as computed by <code><a href="#topic+sim_ame">sim_ame()</a></code>, but rather than average these treatment effects across all observed levels of the treatment, the AMEF is a function evaluated at each possible level of the treatment. The &quot;tiny amount&quot; used is <code>eps</code> times the standard deviation of <code>var</code>.
</p>


<h3>Value</h3>

<p>A <code>clarify_adrf</code> object, which inherits from <code>clarify_est</code> and is similar to
the output of <code>sim_apply()</code>, with the additional attributes <code>"var"</code> containing
the variable named in <code>var</code>, <code>"by"</code> containing the names of the variables specified in <code>by</code> (if any), <code>"at"</code> containing values at which the ADRF or AMEF is evaluated, and <code>"contrast"</code> containing the argument supplied to <code>contrast</code>. For an ADRF, the average marginal means will be named
<code>E[Y({v})]</code>, where <code>{v}</code> is replaced with the values in <code>at</code>. For an AMEF, the average marginal effects will be
named <code>dY/d({x})|{a}</code> where <code>{x}</code> is replaced with <code>var</code> and <code>{a}</code> is replaced by the values in <code>at</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.clarify_adrf">plot.clarify_adrf()</a></code> for plotting the ADRF or AMEF; <code><a href="#topic+sim_ame">sim_ame()</a></code> for computing average marginal effects; <code><a href="#topic+sim_apply">sim_apply()</a></code>, which provides a general interface to computing any
quantities for simulation-based inference; <code><a href="#topic+summary.clarify_est">summary.clarify_est()</a></code> for computing
p-values and confidence intervals for the estimated quantities.
</p>
<p><code><a href="marginaleffects.html#topic+slopes">marginaleffects::avg_slopes()</a></code> and <code><a href="marginaleffects.html#topic+predictions">marginaleffects::avg_predictions()</a></code> for delta method-based implementations of computing average marginal effects and average marginal means.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("lalonde", package = "MatchIt")

# Fit the model
fit &lt;- glm(I(re78 &gt; 0) ~ treat + age + race +
             married + re74,
           data = lalonde, family = binomial)

# Simulate coefficients
set.seed(123)
s &lt;- sim(fit, n = 100)

# ADRF for `age`
est &lt;- sim_adrf(s, var = "age",
                at = seq(15, 55, length.out = 6),
                verbose = FALSE)
est
plot(est)

# AMEF for `age`
est &lt;- sim_adrf(s, var = "age", contrast = "amef",
               at = seq(15, 55, length.out = 6),
               verbose = FALSE)
est
summary(est)
plot(est)

# ADRF for `age` within levels of `married`
est &lt;- sim_adrf(s, var = "age",
                at = seq(15, 55, length.out = 6),
                by = ~married,
                verbose = FALSE)
est
plot(est)

## Difference between ADRFs
est_diff &lt;- est[7:12] - est[1:6]
plot(est_diff) + ggplot2::labs(y = "Diff")
</code></pre>

<hr>
<h2 id='sim_ame'>Compute average marginal effects</h2><span id='topic+sim_ame'></span><span id='topic+print.clarify_ame'></span>

<h3>Description</h3>

<p><code>sim_ame()</code> is a wrapper for <code><a href="#topic+sim_apply">sim_apply()</a></code> that computes average
marginal effects, the average effect of changing a single variable from one
value to another (i.e., from one category to another for categorical
variables or a tiny change for continuous variables).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_ame(
  sim,
  var,
  subset = NULL,
  by = NULL,
  contrast = NULL,
  outcome = NULL,
  type = NULL,
  eps = 1e-05,
  verbose = TRUE,
  cl = NULL
)

## S3 method for class 'clarify_ame'
print(x, digits = NULL, max.ests = 6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_ame_+3A_sim">sim</code></td>
<td>
<p>a <code>clarify_sim</code> object; the output of a call to <code><a href="#topic+sim">sim()</a></code> or
<code><a href="#topic+misim">misim()</a></code>.</p>
</td></tr>
<tr><td><code id="sim_ame_+3A_var">var</code></td>
<td>
<p>either the names of the variables for which marginal effects are
to be computed or a named list containing the values the variables should
take. See Details.</p>
</td></tr>
<tr><td><code id="sim_ame_+3A_subset">subset</code></td>
<td>
<p>optional; a vector used to subset the data used to compute the
marginal effects. This will be evaluated within the original dataset used
to fit the model using <code><a href="base.html#topic+subset">subset()</a></code>, so nonstandard evaluation is allowed.</p>
</td></tr>
<tr><td><code id="sim_ame_+3A_by">by</code></td>
<td>
<p>a one-sided formula or character vector containing the names of
variables for which to stratify the estimates. Each quantity will be
computed within each level of the complete cross of the variables specified
in <code>by</code>.</p>
</td></tr>
<tr><td><code id="sim_ame_+3A_contrast">contrast</code></td>
<td>
<p>a string containing the name of a contrast between the
average marginal means when the variable named in <code>var</code> is categorical and
takes on two values. Allowed options include <code>"diff"</code> for the difference in
means (also <code>"rd"</code>), <code>"rr"</code> for the risk ratio (also <code>"irr"</code>), <code style="white-space: pre;">&#8288;"log(rr):&#8288;</code>
for the log risk ratio (also <code>"log(irr)"</code>), <code>"sr"</code> for the survival ratio,
<code style="white-space: pre;">&#8288;"log(sr):&#8288;</code> for the log survival ratio, <code>"srr"</code> for the switch relative
risk (also <code>"grrr"</code>), <code>"or"</code> for the odds ratio, <code>"log(or)"</code> for the log
odds ratio, and <code>"nnt"</code> for the number needed to treat. These options are
not case sensitive, but the parentheses must be included if present.</p>
</td></tr>
<tr><td><code id="sim_ame_+3A_outcome">outcome</code></td>
<td>
<p>a string containing the name of the outcome or outcome level
for multivariate (multiple outcomes) or multi-category outcomes. Ignored
for univariate (single outcome) and binary outcomes.</p>
</td></tr>
<tr><td><code id="sim_ame_+3A_type">type</code></td>
<td>
<p>a string containing the type of predicted values (e.g., the link
or the response). Passed to <code><a href="marginaleffects.html#topic+get_predict">marginaleffects::get_predict()</a></code> and eventually
to <code>predict()</code> in most cases. The default and allowable option depend on
the type of model supplied, but almost always corresponds to the response
scale (e.g., predicted probabilities for binomial models).</p>
</td></tr>
<tr><td><code id="sim_ame_+3A_eps">eps</code></td>
<td>
<p>when the variable named in <code>var</code> is continuous, the value by which
to change the variable values to approximate the derivative. See Details.</p>
</td></tr>
<tr><td><code id="sim_ame_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>; whether to display a text progress bar indicating
progress and estimated time remaining for the procedure. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sim_ame_+3A_cl">cl</code></td>
<td>
<p>a cluster object created by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>, or an
integer to indicate the number of child-processes (integer values are
ignored on Windows) for parallel evaluations. See <code><a href="pbapply.html#topic+pbapply">pbapply::pblapply()</a></code> for
details. If <code>NULL</code>, no parallelization will take place.</p>
</td></tr>
<tr><td><code id="sim_ame_+3A_x">x</code></td>
<td>
<p>a <code>clarify_ame</code> object.</p>
</td></tr>
<tr><td><code id="sim_ame_+3A_digits">digits</code></td>
<td>
<p>the minimum number of significant digits to be used; passed to <code><a href="base.html#topic+print.data.frame">print.data.frame()</a></code>.</p>
</td></tr>
<tr><td><code id="sim_ame_+3A_max.ests">max.ests</code></td>
<td>
<p>the maximum number of estimates to display.</p>
</td></tr>
<tr><td><code id="sim_ame_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sim_ame()</code> computes average adjusted predictions or average marginal effects depending on which variables are named in <code>var</code> and how they are specified. Canonically, <code>var</code> should be specified as a named list with the value(s) each variable should be set to. For example, specifying <code>var = list(x1 = 0:1)</code> computes average adjusted predictions setting <code>x1</code> to 0 and 1. Specifying a variable's values as <code>NULL</code>, e.g., <code>list(x1 = NULL)</code>, is equivalent to requesting average adjusted predictions at each unique value of the variable when that variable is binary or a factor or character and requests the average marginal effect of that variable otherwise. Specifying an unnamed entry in the list with a string containing the value of that variable, e.g., <code>list("x1")</code> is equivalent to specifying <code>list(x1 = NULL)</code>. Similarly, supplying a vector with the names of the variables is equivalent to specifying a list, e.g., <code>var = "x1"</code> is equivalent to <code>var = list(x1 = NULL)</code>.
</p>
<p>Multiple variables can be supplied to <code>var</code> at the same time to set the corresponding variables to those values. If all values are specified directly or the variables are categorical, e.g., <code>list(x1 = 0:1, x2 = c(5, 10))</code>, this computes average adjusted predictions at each combination of the supplied variables. If any one variable's values is specified as <code>NULL</code> and the variable is continuous, the average marginal effect of that variable will be computed with the other variables set to their corresponding combinations. For example, if <code>x2</code> is a continuous variable, specifying <code>var = list(x1 = 0:1, x2 = NULL)</code> requests the average marginal effect of <code>x2</code> computed first setting <code>x1</code> to 0 and then setting <code>x1</code> to 1. The average marginal effect can only be computed for one variable at a time.
</p>
<p>Below are some examples of specifications and what they request, assuming <code>x1</code> is a binary variable taking on values of 0 and 1 and <code>x2</code> is a continuous variable:
</p>

<ul>
<li> <p><code>list(x1 = 0:1)</code>, <code>list(x1 = NULL)</code>, <code>list("x1")</code>, <code>"x1"</code> &ndash; the average adjusted predictions setting <code>x1</code> to 0 and to 1
</p>
</li>
<li> <p><code>list(x2 = NULL)</code>, <code>list("x2")</code>, <code>"x2"</code> &ndash; the average marginal effect of <code>x2</code>
</p>
</li>
<li> <p><code>list(x2 = c(5, 10))</code> &ndash; the average adjusted predictions setting <code>x2</code> to 5 and to 10
</p>
</li>
<li> <p><code>list(x1 = 0:1, x2 = c(5, 10))</code>, <code>list("x1", x2 = c(5, 10))</code> &ndash; the average adjusted predictions setting <code>x1</code> and <code>x2</code> in a full cross of 0, 1 and 5, 10, respectively (e.g., (0, 5), (0, 10), (1, 5), and (1, 10))
</p>
</li>
<li> <p><code>list(x1 = 0:1, "x2")</code>, <code>list("x1", "x2")</code>, <code>c("x1", "x2")</code> &ndash; the average marginal effects of <code>x2</code> setting <code>x1</code> to 0 and to 1
</p>
</li></ul>

<p>The average adjusted prediction is the average predicted outcome
value after setting all units' value of a variable to a specified level. (This quantity
has several names, including the average potential outcome, average marginal mean, and standardized mean). When exactly two average adjusted predictions are requested, a contrast
between them can be requested by supplying an argument
to <code>contrast</code> (see Effect Measures section below). Contrasts can be manually computed using <code><a href="base.html#topic+transform">transform()</a></code>
afterward as well; this is required when multiple average adjusted predictions are requested (i.e., because a single variable was supplied to <code>var</code> with more than two levels or a combination of multiple variables was supplied).
</p>
<p>A marginal effect is the instantaneous rate of change
corresponding to changing a unit's observed value of a variable by a tiny amount
and considering to what degree the predicted outcome changes. The ratio of
the change in the predicted outcome to the change in the value of the variable is
the marginal effect; these are averaged across the sample to arrive at an
average marginal effect. The &quot;tiny amount&quot; used is <code>eps</code> times the standard
deviation of the focal variable.
</p>
<p>The difference between using <code>by</code> or <code>subset</code> vs. <code>var</code> is that <code>by</code> and <code>subset</code> subset the data when computing the requested quantity, whereas <code>var</code> sets the corresponding variable to given a value for all units. For example, using <code>by = ~v</code> computes the quantity of interest separately for each subset of the data defined by <code>v</code>, whereas setting <code>var = list(., "v")</code> computes the quantity of interest for all units setting their value of <code>v</code> to its unique values. The resulting quantities have different interpretations. Both <code>by</code> and <code>var</code> can be used simultaneously.
</p>


<h4>Effect measures</h4>

<p>The effect measures specified in <code>contrast</code> are defined below. Typically only
<code>"diff"</code> is appropriate for continuous outcomes and <code>"diff"</code> or <code>"irr"</code> are
appropriate for count outcomes; the rest are appropriate for binary outcomes.
For a focal variable with two levels, <code>0</code> and <code>1</code>, and an outcome <code>Y</code>, the
average marginal means will be denoted in the below formulas as <code>E[Y(0)]</code> and
<code>E[Y(1)]</code>, respectively.</p>

<table>
<tr>
 <td style="text-align: left;">
   <code>contrast</code> </td><td style="text-align: left;"> <strong>Description</strong> </td><td style="text-align: left;"> <strong>Formula</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"diff"</code>/<code>"rd"</code> </td><td style="text-align: left;"> Mean/risk difference </td><td style="text-align: left;"> <code>E[Y(1)] - E[Y(0)]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"rr"</code>/<code>"irr"</code> </td><td style="text-align: left;"> Risk ratio/incidence rate ratio </td><td style="text-align: left;"> <code>E[Y(1)] / E[Y(0)]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"sr"</code> </td><td style="text-align: left;"> Survival ratio </td><td style="text-align: left;"> <code>(1 - E[Y(1)]) / (1 - E[Y(0)])</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"srr"</code>/<code>"grrr"</code> </td><td style="text-align: left;"> Switch risk ratio </td><td style="text-align: left;"> <code>1 - sr</code> if <code>E[Y(1)] &gt; E[Y(0)]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>rr - 1</code> if <code>E[Y(1)] &lt; E[Y(0)]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>0</code> otherwise </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"or"</code> </td><td style="text-align: left;"> Odds ratio </td><td style="text-align: left;"> <code>O[Y(1)] / O[Y(0)]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> where <code>O[Y(.)]</code> = <code>E[Y(.)] / (1 - E[Y(.)])</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"nnt"</code> </td><td style="text-align: left;"> Number needed to treat </td><td style="text-align: left;"> <code>1 / rd</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The <code>log(.)</code> versions are defined by taking the <code><a href="base.html#topic+log">log()</a></code> (natural log) of the
corresponding effect measure.
</p>



<h3>Value</h3>

<p>A <code>clarify_ame</code> object, which inherits from <code>clarify_est</code> and is
similar to the output of <code>sim_apply()</code>, with the additional attributes
<code>"var"</code> containing the variable values specified in <code>var</code> and <code>"by"</code> containing the
names of the variables specified in <code>by</code> (if any). The average adjusted
predictions will be named <code>E[Y({v})]</code>, where <code>{v}</code> is replaced with the
values the variables named in <code>var</code> take on. The average marginal effect for a
continuous <code>var</code> will be named <code>E[dY/d({x})]</code> where <code>{x}</code> is replaced with
<code>var</code>. When <code>by</code> is specified, the average adjusted predictions will be named
<code>E[Y({v})|{b}]</code> and the average marginal effect <code>E[dY/d({x})|{b}]</code> where
<code>{b}</code> is a comma-separated list of of values of the <code>by</code> variables at which
the quantity is computed. See examples.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_apply">sim_apply()</a></code>, which provides a general interface to computing any
quantities for simulation-based inference; <code><a href="#topic+plot.clarify_est">plot.clarify_est()</a></code> for plotting the
output of a call to <code>sim_ame()</code>; <code><a href="#topic+summary.clarify_est">summary.clarify_est()</a></code> for computing
p-values and confidence intervals for the estimated quantities.
</p>
<p><code><a href="marginaleffects.html#topic+predictions">marginaleffects::avg_predictions()</a></code>, <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code> and <code><a href="marginaleffects.html#topic+slopes">marginaleffects::avg_slopes()</a></code> for delta method-based implementations of computing average marginal effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("lalonde", package = "MatchIt")

# Fit the model
fit &lt;- glm(I(re78 &gt; 0) ~ treat + age + race +
             married + re74,
           data = lalonde, family = binomial)

# Simulate coefficients
set.seed(123)
s &lt;- sim(fit, n = 100)

# Average marginal effect of `age`
est &lt;- sim_ame(s, var = "age", verbose = FALSE)
summary(est)

# Contrast between average adjusted predictions
# for `treat`
est &lt;- sim_ame(s, var = "treat", contrast = "rr",
               verbose = FALSE)
summary(est)

# Average adjusted predictions for `race`; need to follow up
# with contrasts for specific levels
est &lt;- sim_ame(s, var = "race", verbose = FALSE)

est &lt;- transform(est,
                 `RR(h,b)` = `E[Y(hispan)]` / `E[Y(black)]`)

summary(est)

# Average adjusted predictions for `treat` within levels of
# `married`, first using `subset` and then using `by`
est0 &lt;- sim_ame(s, var = "treat", subset = married == 0,
                contrast = "rd", verbose = FALSE)
names(est0) &lt;- paste0(names(est0), "|married=0")
est1 &lt;- sim_ame(s, var = "treat", subset = married == 1,
                contrast = "rd", verbose = FALSE)
names(est1) &lt;- paste0(names(est1), "|married=1")

summary(cbind(est0, est1))

est &lt;- sim_ame(s, var = "treat", by = ~married,
               contrast = "rd", verbose = FALSE)

est
summary(est)

# Average marginal effect of `age` within levels of
# married*race
est &lt;- sim_ame(s, var = "age", by = ~married + race,
               verbose = FALSE)
est
summary(est, null = 0)

# Comparing AMEs between married and unmarried for
# each level of `race`
est_diff &lt;- est[4:6] - est[1:3]
names(est_diff) &lt;- paste0("AME_diff|", levels(lalonde$race))
summary(est_diff)

# Average adjusted predictions at a combination of `treat`
# and `married`
est &lt;- sim_ame(s, var = c("treat", "married"),
               verbose = FALSE)
est

# Average marginal effect of `age` setting `married` to 1
est &lt;- sim_ame(s, var = list("age", married = 1),
               verbose = FALSE)
</code></pre>

<hr>
<h2 id='sim_apply'>Apply a function to simulated parameter values</h2><span id='topic+sim_apply'></span>

<h3>Description</h3>

<p><code>sim_apply()</code> applies a function that produces quantities of
interest to each set of simulated coefficients produced by <code><a href="#topic+sim">sim()</a></code>; these
calculated quantities form the posterior sampling distribution for the
quantities of interest. Capabilities are available for parallelization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_apply(sim, FUN, verbose = TRUE, cl = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_apply_+3A_sim">sim</code></td>
<td>
<p>a <code>clarify_sim</code> object; the output of a call to <code><a href="#topic+sim">sim()</a></code> or
<code><a href="#topic+misim">misim()</a></code>.</p>
</td></tr>
<tr><td><code id="sim_apply_+3A_fun">FUN</code></td>
<td>
<p>a function to be applied to each set of simulated coefficients.
See Details.</p>
</td></tr>
<tr><td><code id="sim_apply_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>; whether to display a text progress bar indicating
progress and estimated time remaining for the procedure. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sim_apply_+3A_cl">cl</code></td>
<td>
<p>a cluster object created by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>, or an
integer to indicate the number of child-processes (integer values are
ignored on Windows) for parallel evaluations. See <code><a href="pbapply.html#topic+pbapply">pbapply::pblapply()</a></code> for
details. If <code>NULL</code>, no parallelization will take place.</p>
</td></tr>
<tr><td><code id="sim_apply_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sim_apply()</code> applies a function, <code>FUN</code>, to each set of simulated
coefficients, similar to <code><a href="base.html#topic+apply">apply()</a></code>. This function should return a numeric
vector containing one or more estimated quantities. This should be a named
vector to more easily keep track of the meaning of each estimated quantity.
Care should be taken to ensure that the returned vector is the same length
each time <code>FUN</code> is called. <code>NA</code>s are allowed in the output but should be
avoided if possible.
</p>
<p>The arguments to <code>FUN</code> can be specified in a few ways. If <code>FUN</code> has an
argument called <code>coefs</code>, a simulated set of coefficients will be passed to
this argument, and <code>FUN</code> should compute and return a quantity based on the
coefficients (e.g., the difference between two coefficients if one wants to
test whether two coefficients are equal). If <code>FUN</code> has an argument called
<code>fit</code>, a model fit object of the same type as the one originally supplied
to <code>sim()</code> (e.g., an <code>lm</code> or <code>glm</code> object) will be passed to this argument,
where the coefficients of the fit object have been replaced by the
simulated coefficients generated by <code>sim()</code>, and <code>FUN</code> should compute and
return a quantity based on the model fit (e.g., a computation based on the
output of <code>predict()</code>). If neither <code>coefs</code> nor <code>fit</code> are the names of
arguments to <code>FUN</code>, the model fit object with replaced coefficients will be
supplied to the first argument of <code>FUN</code>.
</p>
<p>When custom coefficients are supplied to <code>sim()</code>, i.e., when the <code>coefs</code>
argument to <code>sim()</code> is not left at its default value, <code>FUN</code> must accept a
<code>coefs</code> argument and a warning will be thrown if it accepts a <code>fit</code>
argument. This is because <code>sim_apply()</code> does not know how to reconstruct
the original fit object with the new coefficients inserted. The quantities
computed by <code>sim_apply()</code> must therefore be computed directly from the
coefficients.
</p>
<p>If <code>FUN</code> is not supplied at all, the simulated values of the coefficients will be returned in the output with a warning. Set <code>FUN</code> to <code>NULL</code> or <code>verbose</code> to <code>FALSE</code> to suppress this warning.
</p>


<h4><code>sim_apply()</code> with multiply imputed data</h4>

<p>When using <code><a href="#topic+misim">misim()</a></code> and <code>sim_apply()</code> with multiply imputed data, the
coefficients are supplied to the model fit corresponding to the imputation
identifier associated with each set of coefficients, which means if <code>FUN</code>
uses a dataset extracted from a model (e.g., using <code><a href="insight.html#topic+get_data">insight::get_data()</a></code>), it will do so from the model fit in
the corresponding imputation.
</p>
<p>The original estimates (see Value below) are computed as the mean of the
estimates across the imputations using the original coefficients averaged
across imputations. That is, first, the coefficients estimated in the
models in the imputed datasets are combined to form a single set of pooled
coefficients; then, for each imputation, the quantities of interest are
computed using the pooled coefficients; finally, the mean of the resulting
estimates across the imputations are taken as the &quot;original&quot; estimates.
Note this procedure is only valid for quantities with symmetric sampling
distributions, which excludes quantities like risk ratios and odds ratios,
but includes log risk ratios and log odds ratios. The desired quantities
can be transformed from their log versions using
<code><a href="base.html#topic+transform">transform()</a></code>.
</p>



<h3>Value</h3>

<p>A <code>clarify_est</code> object, which is a matrix with a column for each
estimated quantity and a row for each simulation. The original estimates
(<code>FUN</code> applied to the original coefficients or model fit object) are stored
in the attribute <code>"original"</code>. The <code>"sim_hash"</code> attribute contains the
simulation hash produced by <code>sim()</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+sim">sim()</a></code> for generating the simulated coefficients
</p>
</li>
<li> <p><code><a href="#topic+summary.clarify_est">summary.clarify_est()</a></code> for computing p-values and confidence intervals for
the estimated quantities
</p>
</li>
<li> <p><code><a href="#topic+plot.clarify_est">plot.clarify_est()</a></code> for plotting estimated
quantities and their simulated posterior sampling distribution.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde", package = "MatchIt")
fit &lt;- lm(re78 ~ treat + age + race + nodegree + re74,
          data = lalonde)
coef(fit)

set.seed(123)
s &lt;- sim(fit, n = 500)

# Function to compare predicted values for two units
# using `fit` argument
sim_fun &lt;- function(fit) {
  pred1 &lt;- unname(predict(fit, newdata = lalonde[1,]))
  pred2 &lt;- unname(predict(fit, newdata = lalonde[2,]))
  c(pred1 = pred1, pred2 = pred2)
}

est &lt;- sim_apply(s, sim_fun, verbose = FALSE)

# Add difference between predicted values as
# additional quantity
est &lt;- transform(est, `diff 1-2` = pred1 - pred2)

# Examine estimates and confidence intervals
summary(est)

# Function to compare coefficients using `coefs`
# argument
sim_fun &lt;- function(coefs) {
  setNames(coefs["racewhite"] - coefs["racehispan"],
           "wh - his")
}

est &lt;- sim_apply(s, sim_fun, verbose = FALSE)

# Examine estimates and confidence intervals
summary(est)

# Another way to do the above:
est &lt;- sim_apply(s, FUN = NULL)
est &lt;- transform(est,
                 `wh - his` = `racewhite` - `racehispan`)

summary(est, parm = "wh - his")

</code></pre>

<hr>
<h2 id='sim_setx'>Compute predictions and first differences at set values</h2><span id='topic+sim_setx'></span><span id='topic+print.clarify_setx'></span>

<h3>Description</h3>

<p><code>sim_setx()</code> is a wrapper for <code><a href="#topic+sim_apply">sim_apply()</a></code> that computes predicted values of
the outcome at specified values of the predictors, sometimes called marginal
predictions. One can also compute the difference between two marginal
predictions (the &quot;first difference&quot;). Although any function that accepted
<code>clarify_est</code> objects can be used with <code>sim_setx()</code> output objects, a
special plotting function, <code><a href="#topic+plot.clarify_setx">plot.clarify_setx()</a></code>, can be used to plot marginal
predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_setx(
  sim,
  x = list(),
  x1 = list(),
  outcome = NULL,
  type = NULL,
  verbose = TRUE,
  cl = NULL
)

## S3 method for class 'clarify_setx'
print(x, digits = NULL, max.ests = 6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_setx_+3A_sim">sim</code></td>
<td>
<p>a <code>clarify_sim</code> object; the output of a call to <code><a href="#topic+sim">sim()</a></code> or
<code><a href="#topic+misim">misim()</a></code>.</p>
</td></tr>
<tr><td><code id="sim_setx_+3A_x">x</code></td>
<td>
<p>a data.frame containing a reference grid of predictor values or a named list of values each predictor should take defining such a
reference grid, e.g., <code>list(v1 = 1:4, v2 = c("A", "B"))</code>.
Any omitted predictors are fixed at a &quot;typical&quot; value. See Details.
When <code>x1</code> is specified, <code>x</code> should identify a single reference unit.
</p>
<p>For <code>print()</code>, a <code>clarify_setx</code> object.</p>
</td></tr>
<tr><td><code id="sim_setx_+3A_x1">x1</code></td>
<td>
<p>a data.frame or named list of the value each predictor should take to compute the
first difference from the predictor combination specified in <code>x</code>. <code>x1</code> can
only identify a single unit. See Details.</p>
</td></tr>
<tr><td><code id="sim_setx_+3A_outcome">outcome</code></td>
<td>
<p>a string containing the name of the outcome or outcome level for multivariate (multiple outcomes) or multi-category outcomes. Ignored for univariate (single outcome) and binary outcomes.</p>
</td></tr>
<tr><td><code id="sim_setx_+3A_type">type</code></td>
<td>
<p>a string containing the type of predicted values (e.g., the link or the response). Passed to <code><a href="marginaleffects.html#topic+get_predict">marginaleffects::get_predict()</a></code> and eventually to <code>predict()</code> in most cases. The default and allowable option depend on the type of model supplied, but almost always corresponds to the response scale (e.g., predicted probabilities for binomial models).</p>
</td></tr>
<tr><td><code id="sim_setx_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>; whether to display a text progress bar indicating
progress and estimated time remaining for the procedure. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sim_setx_+3A_cl">cl</code></td>
<td>
<p>a cluster object created by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>, or an
integer to indicate the number of child-processes (integer values are
ignored on Windows) for parallel evaluations. See <code><a href="pbapply.html#topic+pbapply">pbapply::pblapply()</a></code> for
details. If <code>NULL</code>, no parallelization will take place.</p>
</td></tr>
<tr><td><code id="sim_setx_+3A_digits">digits</code></td>
<td>
<p>the minimum number of significant digits to be used; passed to <code><a href="base.html#topic+print.data.frame">print.data.frame()</a></code>.</p>
</td></tr>
<tr><td><code id="sim_setx_+3A_max.ests">max.ests</code></td>
<td>
<p>the maximum number of estimates to display.</p>
</td></tr>
<tr><td><code id="sim_setx_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>x</code> is a named list of predictor values, they will be crossed
to form a reference grid for the marginal predictions. Any predictors not
set in <code>x</code> are assigned their &quot;typical&quot; value, which, for factor,
character, logical, and binary variables is the mode, for numeric variables
is the mean, and for ordered variables is the median. These values can be
seen in the <code>"setx"</code> attribute of the output object. If <code>x</code> is empty, a
prediction will be made at a point corresponding to the typical value of
every predictor. Estimates are identified (in <code>summary()</code>, etc.) only by
the variables that differ across predictions.
</p>
<p>When <code>x1</code> is supplied, the first difference is computed, which here is
considered as the difference between two marginal predictions. One marginal
prediction must be specified in <code>x</code> and another, ideally with a single
predictor changed, specified in <code>x1</code>.
</p>


<h3>Value</h3>

<p>a <code>clarify_setx</code> object, which inherits from <code>clarify_est</code> and is similar to the output of <code>sim_apply()</code>, with the following additional attributes:
</p>

<ul>
<li> <p><code>"setx"</code> - a data frame containing the values at which predictions are to be made
</p>
</li>
<li> <p><code>"fd"</code> - whether or not the first difference is to be computed; set to <code>TRUE</code> if <code>x1</code> is specified and <code>FALSE</code> otherwise
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+sim_apply">sim_apply()</a></code>, which provides a general interface to computing any
quantities for simulation-based inference; <code><a href="#topic+plot.clarify_setx">plot.clarify_setx()</a></code> for plotting the
output of a call to <code>sim_setx()</code>; <code><a href="#topic+summary.clarify_est">summary.clarify_est()</a></code> for computing
p-values and confidence intervals for the estimated quantities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("lalonde", package = "MatchIt")

fit &lt;- lm(re78 ~ treat + age + educ + married + race + re74,
          data = lalonde)

# Simulate coefficients
set.seed(123)
s &lt;- sim(fit, n = 100)

# Predicted values at specified values of values, typical
# values for other predictors
est &lt;- sim_setx(s, x = list(treat = 0:1,
                            re74 = c(0, 10000)),
                verbose = FALSE)
summary(est)
plot(est)

# Predicted values at specified grid of values, typical
# values for other predictors
est &lt;- sim_setx(s, x = list(age = c(20, 25, 30, 35),
                            married = 0:1),
                verbose = FALSE)
summary(est)
plot(est)

# First differences of treat at specified value of
# race, typical values for other predictors
est &lt;- sim_setx(s, x = data.frame(treat = 0, race = "hispan"),
                x1 = data.frame(treat = 1, race = "hispan"),
                verbose = FALSE)
summary(est)
plot(est)

</code></pre>

<hr>
<h2 id='transform.clarify_est'>#' Transform and combine <code>clarify_est</code> objects</h2><span id='topic+transform.clarify_est'></span><span id='topic+cbind.clarify_est'></span>

<h3>Description</h3>

<p><code>transform()</code> modifies a <code>clarify_est</code> object by allowing for the calculation of new quantities from the existing quantities without re-simulating them. <code>cbind()</code> binds two <code>clarify_est</code> objects together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clarify_est'
transform(`_data`, ...)

## S3 method for class 'clarify_est'
cbind(..., deparse.level = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform.clarify_est_+3A__data">_data</code></td>
<td>
<p>the <code>clarify_est</code> object to be transformed.</p>
</td></tr>
<tr><td><code id="transform.clarify_est_+3A_...">...</code></td>
<td>
<p>for <code>transform()</code>, arguments in the form <code>name = value</code>, where <code>name</code> is the name of a new quantity to be computed and <code>value</code> is an expression that is a function of the existing quantities corresponding to the new quantity to be computed. See Details. For <code>cbind()</code>, <code>clarify_est</code> objects to be combined.</p>
</td></tr>
<tr><td><code id="transform.clarify_est_+3A_deparse.level">deparse.level</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>transform()</code>, the expression on the right side of the <code>=</code> should use the names of the existing quantities (e.g., <code>`E[Y(1)]` - `E[Y(1)]`</code>), with <code style="white-space: pre;">&#8288;`&#8288;</code> appropriately included when the quantity name include parentheses or brackets. Alternatively, it can use indexes prefixed by <code>.b</code>, e.g., <code>.b2 - .b1</code>, to refer to the corresponding quantity by position. This can aid in computing derived quantities of quantities with complicated names. (Note that if a quantity is named something like <code>.b1</code>, it will need to be referred to by position rather than name, as the position-based label takes precedence). See examples. Setting an existing value to <code>NULL</code> will remove that quantity from the object.
</p>
<p><code>cbind()</code> does not rename the quanities or check for uniqueness of the names, so it is important to rename them yourself prior to combining the objects.
</p>


<h3>Value</h3>

<p>A <code>clarify_est</code> object, either with new columns added (when using <code>transform()</code>) or combining two <code>clarify_est</code> objects. Note that any type attributes corresponding to the <code>sim_apply()</code> wrapper used (e.g., <code>sim_ame()</code>) is lost when using either function. This can affect any helper functions (e.g., <code>plot()</code>) designed to work with the output of specific wrappers.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+transform">transform()</a></code>, <code><a href="base.html#topic+cbind">cbind()</a></code>, <code><a href="#topic+sim">sim()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("lalonde", package = "MatchIt")

# Fit the model
fit &lt;- lm(re78 ~ treat * (age + educ + race +
             married + re74 + re75),
           data = lalonde)

# Simulate coefficients
set.seed(123)
s &lt;- sim(fit, n = 100)

# Average adjusted predictions for `treat` within
# subsets of `race`
est_b &lt;- sim_ame(s, var = "treat", verbose = FALSE,
                 subset = race == "black")
est_b

est_h &lt;- sim_ame(s, var = "treat", verbose = FALSE,
                 subset = race == "hispan")
est_h

# Compute differences between adjusted predictions
est_b &lt;- transform(est_b,
                   diff = `E[Y(1)]` - `E[Y(0)]`)
est_b

est_h &lt;- transform(est_h,
                   diff = `E[Y(1)]` - `E[Y(0)]`)
est_h

# Bind estimates together after renaming
names(est_b) &lt;- paste0(names(est_b), "_b")
names(est_h) &lt;- paste0(names(est_h), "_h")

est &lt;- cbind(est_b, est_h)
est

# Compute difference in race-specific differences
est &lt;- transform(est,
                 `diff-diff` = .b6 - .b3)

summary(est,
        parm = c("diff_b", "diff_h", "diff-diff"))

# Remove last quantity by using `NULL`
transform(est, `diff-diff` = NULL)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
