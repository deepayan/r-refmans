<!DOCTYPE html><html><head><title>Help for package matrixsampling</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {matrixsampling}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rinvwishart'><p>Inverse-Wishart sampler</p></a></li>
<li><a href='#rmatrixbeta'><p>Matrix Beta sampler</p></a></li>
<li><a href='#rmatrixbetaII'><p>Matrix Beta II sampler</p></a></li>
<li><a href='#rmatrixCHIIkind2'><p>Sampler of the matrix variate type II confluent hypergeometric kind two</p>
distribution</a></li>
<li><a href='#rmatrixCHIkind2'><p>Sampler of the matrix variate type I confluent hypergeometric kind two</p>
distribution</a></li>
<li><a href='#rmatrixCHkind1'><p>Sampler of the matrix variate confluent hypergometric kind one distribution</p></a></li>
<li><a href='#rmatrixgamma'><p>Matrix Gamma sampler</p></a></li>
<li><a href='#rmatrixit'><p>Matrix inverted-t sampler</p></a></li>
<li><a href='#rmatrixnormal'><p>Matrix normal sampler</p></a></li>
<li><a href='#rmatrixt'><p>Matrix t sampler</p></a></li>
<li><a href='#rwishart'><p>Wishart sampler</p></a></li>
<li><a href='#rwishart_chol'><p>Sampling Cholesky factor of a Wishart matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulations of Matrix Variate Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-08-24</td>
</tr>
<tr>
<td>Author:</td>
<td>Stéphane Laurent</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stéphane Laurent &lt;laurent_step@outlook.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides samplers for various matrix variate distributions: Wishart, inverse-Wishart, normal, t, inverted-t, Beta type I, Beta type II, Gamma, confluent hypergeometric. Allows to simulate the noncentral Wishart distribution without the integer restriction on the degrees of freedom.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stla/matrixsampling">https://github.com/stla/matrixsampling</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stla/matrixsampling/issues">https://github.com/stla/matrixsampling/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, keep</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-08-24 19:32:02 UTC; SDL96354</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-08-24 22:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rinvwishart'>Inverse-Wishart sampler</h2><span id='topic+rinvwishart'></span>

<h3>Description</h3>

<p>Samples the inverse-Wishart distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rinvwishart(n, nu, Omega, epsilon = 0, checkSymmetry = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rinvwishart_+3A_n">n</code></td>
<td>
<p>sample size, a positive integer</p>
</td></tr>
<tr><td><code id="rinvwishart_+3A_nu">nu</code></td>
<td>
<p>degrees of freedom, must satisfy <code>nu &gt; p-1</code>, where <code>p</code> is
the dimension (the order of <code>Omega</code>)</p>
</td></tr>
<tr><td><code id="rinvwishart_+3A_omega">Omega</code></td>
<td>
<p>scale matrix, a positive definite real matrix</p>
</td></tr>
<tr><td><code id="rinvwishart_+3A_epsilon">epsilon</code></td>
<td>
<p>threshold to force invertibility in the algorithm; see Details</p>
</td></tr>
<tr><td><code id="rinvwishart_+3A_checksymmetry">checkSymmetry</code></td>
<td>
<p>logical, whether to check the symmetry of <code>Omega</code>;
if <code>FALSE</code>, only the upper triangular part of <code>Omega</code> is used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse-Wishart distribution with scale matrix
&Omega; is
defined as the inverse of the Wishart distribution with scale matrix
&Omega;<sup>-1</sup>
and same number of degrees of freedom.
The argument <code>epsilon</code> is a threshold whose role is to guarantee
the invertibility of the sampled Wishart distributions.
See Details in <code><a href="#topic+rwishart">rwishart</a></code>.
</p>


<h3>Value</h3>

<p>A numeric three-dimensional array;
simulations are stacked along the third dimension (see example).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nu &lt;- 6
p &lt;- 3
Omega &lt;- toeplitz(p:1)
IWsims &lt;- rinvwishart(10000, nu, Omega)
dim(IWsims) # 3 3 10000
apply(IWsims, 1:2, mean) # approximately Omega/(nu-p-1)
# the epsilon argument:
IWsims &lt;- tryCatch(rinvwishart(10000, nu=p+0.001, Omega),
                   error=function(e) e)
IWsims &lt;- tryCatch(rinvwishart(10000, nu=p+0.001, Omega, epsilon=1e-8),
                   error=function(e) e)
</code></pre>

<hr>
<h2 id='rmatrixbeta'>Matrix Beta sampler</h2><span id='topic+rmatrixbeta'></span>

<h3>Description</h3>

<p>Samples a matrix Beta (type I) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmatrixbeta(n, p, a, b, Theta1 = NULL, Theta2 = NULL, def = 1,
  checkSymmetry = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmatrixbeta_+3A_n">n</code></td>
<td>
<p>sample size, a positive integer</p>
</td></tr>
<tr><td><code id="rmatrixbeta_+3A_p">p</code></td>
<td>
<p>dimension, a positive integer</p>
</td></tr>
<tr><td><code id="rmatrixbeta_+3A_a">a</code>, <code id="rmatrixbeta_+3A_b">b</code></td>
<td>
<p>parameters of the distribution, positive numbers with constraints given
in Details</p>
</td></tr>
<tr><td><code id="rmatrixbeta_+3A_theta1">Theta1</code></td>
<td>
<p>numerator noncentrality parameter, a positive semidefinite real
matrix of order <code>p</code>; setting it to <code>NULL</code> (default) is
equivalent to setting it to the zero matrix</p>
</td></tr>
<tr><td><code id="rmatrixbeta_+3A_theta2">Theta2</code></td>
<td>
<p>denominator noncentrality parameter, a positive semidefinite real
matrix of order <code>p</code>; setting it to <code>NULL</code> (default) is
equivalent to setting it to the zero matrix</p>
</td></tr>
<tr><td><code id="rmatrixbeta_+3A_def">def</code></td>
<td>
<p><code>1</code> or <code>2</code>, the definition used; see Details</p>
</td></tr>
<tr><td><code id="rmatrixbeta_+3A_checksymmetry">checkSymmetry</code></td>
<td>
<p>logical, whether to check the symmetry of <code>Theta1</code>
and <code>Theta2</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Beta random matrix <code class="reqn">U</code> is defined as follows.
Take two independent Wishart random matrices
S<sub>1</sub> ~ W<sub>p</sub>(2a,I<sub>p</sub>,&Theta;<sub>1</sub>)
and
S<sub>2</sub> ~ W<sub>p</sub>(2b,I<sub>p</sub>,&Theta;<sub>2</sub>).
</p>

<ul>
<li> <p><strong>definition 1</strong>:
U = (S<sub>1</sub>+S<sub>2</sub>)<sup>-&frac12;</sup>S<sub>1</sub>(S<sub>1</sub>+S<sub>2</sub>)<sup>-&frac12;</sup>
</p>
</li>
<li> <p><strong>definition 2</strong>:
U = S<sub>1</sub><sup>&frac12;</sup>(S<sub>1</sub>+S<sub>2</sub>)<sup>-1</sup>S<sub>1</sub><sup>&frac12;</sup>
</p>
</li></ul>

<p>In the central case, the two definitions yield the same distribution.
Under definition 2, the Beta distribution is related to the Beta type II
distribution by
U ~ V(I+V)<sup>-1</sup>.
</p>
<p>Parameters <code>a</code> and <code>b</code> are positive numbers that satisfy the
following constraints:
</p>

<ul>
<li><p> if both <code>Theta1</code> and <code>Theta2</code> are the null matrix,
<code>a+b &gt; (p-1)/2</code>; if <code>a &lt; (p-1)/2</code>, it must be half an integer;
if <code>b &lt; (p-1)/2</code>, it must be half an integer
</p>
</li>
<li><p> if <code>Theta1</code> is not the null matrix, <code>a &gt;= (p-1)/2</code>;
if <code>b &lt; (p-1)/2</code>, it must be half an integer
</p>
</li>
<li><p> if <code>Theta2</code> is not the null matrix, <code>b &gt;= (p-1)/2</code>;
if <code>a &lt; (p-1)/2</code>, it must be half an integer</p>
</li></ul>



<h3>Value</h3>

<p>A numeric three-dimensional array;
simulations are stacked along the third dimension (see example).
</p>


<h3>Warning</h3>

<p>Definition 2 requires the calculation of the square root of
S<sub>1</sub> ~ W<sub>p</sub>(2a,I<sub>p</sub>,&Theta;<sub>1</sub>)
(see Details). While S<sub>1</sub> is always
positive semidefinite in theory, it could happen that the simulation of
S<sub>1</sub> is not positive semidefinite,
especially when <code>a</code> is small. In this case the calculation of the square root
will return <code>NaN</code>.
</p>


<h3>Note</h3>

<p>The matrix variate Beta distribution is usually defined only for
<code class="reqn">a &gt; (p-1)/2</code> and <code class="reqn">b &gt; (p-1)/2</code>. In this case, a random matrix <code class="reqn">U</code>
generated from this distribution satisfies <code class="reqn">0 &lt; U &lt; I</code>.
For an half integer <code class="reqn">a \le (p-1)/2</code>, it satisfies <code class="reqn">0 \le U &lt; I</code>
and <code class="reqn">rank(U)=2a</code>.
For an half integer <code class="reqn">b \le (p-1)/2</code>, it satisfies <code class="reqn">0 &lt; U \le I</code>
and <code class="reqn">rank(I-U)=2b</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Bsims &lt;- rmatrixbeta(10000, 3, 1, 1)
dim(Bsims) # 3 3 10000
</code></pre>

<hr>
<h2 id='rmatrixbetaII'>Matrix Beta II sampler</h2><span id='topic+rmatrixbetaII'></span>

<h3>Description</h3>

<p>Samples a matrix Beta type II distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmatrixbetaII(n, p, a, b, Theta1 = NULL, Theta2 = NULL, def = 1,
  checkSymmetry = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmatrixbetaII_+3A_n">n</code></td>
<td>
<p>sample size, a positive integer</p>
</td></tr>
<tr><td><code id="rmatrixbetaII_+3A_p">p</code></td>
<td>
<p>dimension, a positive integer</p>
</td></tr>
<tr><td><code id="rmatrixbetaII_+3A_a">a</code>, <code id="rmatrixbetaII_+3A_b">b</code></td>
<td>
<p>parameters of the distribution, positive numbers with constraints given
in Details</p>
</td></tr>
<tr><td><code id="rmatrixbetaII_+3A_theta1">Theta1</code></td>
<td>
<p>numerator noncentrality parameter, a positive semidefinite real
matrix of order <code>p</code>; setting it to <code>NULL</code> (default) is
equivalent to setting it to the zero matrix</p>
</td></tr>
<tr><td><code id="rmatrixbetaII_+3A_theta2">Theta2</code></td>
<td>
<p>denominator noncentrality parameter, a positive semidefinite real
matrix of order <code>p</code>; setting it to <code>NULL</code> (default) is
equivalent to setting it to the zero matrix</p>
</td></tr>
<tr><td><code id="rmatrixbetaII_+3A_def">def</code></td>
<td>
<p><code>1</code> or <code>2</code>, the definition used; see Details</p>
</td></tr>
<tr><td><code id="rmatrixbetaII_+3A_checksymmetry">checkSymmetry</code></td>
<td>
<p>logical, whether to check the symmetry of <code>Theta1</code>
and <code>Theta2</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Beta type II random matrix <code class="reqn">V</code> is defined as follows.
Take two independent Wishart random matrices
S<sub>1</sub> ~ W<sub>p</sub>(2a,I<sub>p</sub>,&Theta;<sub>1</sub>)
and
S<sub>2</sub> ~ W<sub>p</sub>(2b,I<sub>p</sub>,&Theta;<sub>2</sub>).
</p>

<ul>
<li> <p><strong>definition 1</strong>:
V = S<sub>2</sub><sup>-&frac12;</sup>S<sub>1</sub>S<sub>2</sub><sup>-&frac12;</sup>
</p>
</li>
<li> <p><strong>definition 2</strong>:
V = S<sub>1</sub><sup>&frac12;</sup>S<sub>2</sub><sup>-1</sup>S<sub>1</sub><sup>&frac12;</sup>
</p>
</li></ul>

<p>In the central case, the two definitions yield the same distribution.
Under definition 2, the Beta type II distribution is related to the Beta
distribution by
V ~ U(I-U)<sup>-1</sup>.
</p>
<p>Parameters <code>a</code> and <code>b</code> are positive numbers that satisfy the
following constraints:
</p>

<ul>
<li><p> in any case, <code>b &gt; (p-1)/2</code>
</p>
</li>
<li><p> if <code>Theta1</code> is the null matrix and <code>a &lt; (p-1)/2</code>, then
<code>a</code> must be half an integer
</p>
</li>
<li><p> if <code>Theta1</code> is not the null matrix, <code>a &gt;= (p-1)/2</code></p>
</li></ul>



<h3>Value</h3>

<p>A numeric three-dimensional array;
simulations are stacked along the third dimension (see example).
</p>


<h3>Warning</h3>

<p>The issue described in the <strong>Warning</strong> section of <code><a href="#topic+rmatrixbeta">rmatrixbeta</a></code>
also concerns <code>rmatrixbetaII</code>.
</p>


<h3>Note</h3>

<p>The matrix variate Beta distribution of type II is usually defined only for
<code class="reqn">a &gt; (p-1)/2</code> and <code class="reqn">b &gt; (p-1)/2</code>. In this case, a random matrix <code class="reqn">V</code>
generated from this distribution satisfies <code class="reqn">V &gt; 0</code>.
For an half integer <code class="reqn">a \le (p-1)/2</code>, it satisfies <code class="reqn">V \ge 0</code> and
<code class="reqn">rank(V)=2a</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Bsims &lt;- rmatrixbetaII(10000, 3, 1, 1.5)
dim(Bsims) # 3 3 10000
</code></pre>

<hr>
<h2 id='rmatrixCHIIkind2'>Sampler of the matrix variate type II confluent hypergeometric kind two
distribution</h2><span id='topic+rmatrixCHIIkind2'></span>

<h3>Description</h3>

<p>Samples the matrix variate type II confluent hypergeometric kind two
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmatrixCHIIkind2(n, nu, alpha, beta, theta = 1, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmatrixCHIIkind2_+3A_n">n</code></td>
<td>
<p>sample size, a positive integer</p>
</td></tr>
<tr><td><code id="rmatrixCHIIkind2_+3A_nu">nu</code></td>
<td>
<p>shape parameter, a positive number; if <code>nu &lt; (p-1)/2</code>,
then <code>nu</code> must be a half integer</p>
</td></tr>
<tr><td><code id="rmatrixCHIIkind2_+3A_alpha">alpha</code>, <code id="rmatrixCHIIkind2_+3A_beta">beta</code></td>
<td>
<p>shape parameters; <code>alpha &gt; (p-1)/2</code>,
<code>beta &lt; nu + 1</code></p>
</td></tr>
<tr><td><code id="rmatrixCHIIkind2_+3A_theta">theta</code></td>
<td>
<p>scale parameter, a positive number</p>
</td></tr>
<tr><td><code id="rmatrixCHIIkind2_+3A_p">p</code></td>
<td>
<p>dimension (order of the sampled matrices), an integer greater than
or equal to one</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric three-dimensional array;
simulations are stacked along the third dimension.
</p>


<h3>References</h3>

<p>A. K. Gupta &amp; D. K. Nagar. <em>Matrix Variate Distributions</em>.
Chapman &amp; Hall/CRC, Boca Raton (2000).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nu &lt;- 5; alpha &lt;- 13; beta &lt;- 4; theta &lt;- 2; p &lt;- 2
sims &lt;- rmatrixCHIIkind2(50000, nu, alpha, beta, theta, p)
# simulations of the trace
trsims &lt;- apply(sims, 3, function(X) sum(diag(X)))
mean(trsims)
p * theta * nu * (nu+(p+1)/2-beta) / (alpha+nu+(p+1)/2-beta)
</code></pre>

<hr>
<h2 id='rmatrixCHIkind2'>Sampler of the matrix variate type I confluent hypergeometric kind two
distribution</h2><span id='topic+rmatrixCHIkind2'></span>

<h3>Description</h3>

<p>Samples the matrix variate type I confluent hypergeometric kind two
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmatrixCHIkind2(n, nu, alpha, beta, theta = 1, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmatrixCHIkind2_+3A_n">n</code></td>
<td>
<p>sample size, a positive integer</p>
</td></tr>
<tr><td><code id="rmatrixCHIkind2_+3A_nu">nu</code></td>
<td>
<p>shape parameter, a positive number; if <code>nu &lt; (p-1)/2</code>,
then <code>nu</code> must be a half integer</p>
</td></tr>
<tr><td><code id="rmatrixCHIkind2_+3A_alpha">alpha</code>, <code id="rmatrixCHIkind2_+3A_beta">beta</code></td>
<td>
<p>shape parameters; <code>alpha &gt; nu + (p-1)/2</code>,
<code>beta &lt; nu + 1</code></p>
</td></tr>
<tr><td><code id="rmatrixCHIkind2_+3A_theta">theta</code></td>
<td>
<p>scale parameter, a positive number</p>
</td></tr>
<tr><td><code id="rmatrixCHIkind2_+3A_p">p</code></td>
<td>
<p>dimension (order of the sampled matrices), an integer greater than
or equal to one</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric three-dimensional array;
simulations are stacked along the third dimension.
</p>


<h3>References</h3>

<p>A. K. Gupta &amp; D. K. Nagar. <em>Matrix Variate Distributions</em>.
Chapman &amp; Hall/CRC, Boca Raton (2000).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nu &lt;- 5; alpha &lt;- 13; beta &lt;- 4; theta &lt;- 2; p &lt;- 2
sims &lt;- rmatrixCHIkind2(50000, nu, alpha, beta, theta, p)
# simulations of the trace
trsims &lt;- apply(sims, 3, function(X) sum(diag(X)))
mean(trsims)
p * theta * nu * (nu+(p+1)/2-beta) / (alpha-nu-(p+1)/2)
</code></pre>

<hr>
<h2 id='rmatrixCHkind1'>Sampler of the matrix variate confluent hypergometric kind one distribution</h2><span id='topic+rmatrixCHkind1'></span>

<h3>Description</h3>

<p>Samples the matrix variate confluent hypergometric kind one distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmatrixCHkind1(n, nu, alpha, beta, theta = 1, Sigma = NULL, p,
  checkSymmetry = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmatrixCHkind1_+3A_n">n</code></td>
<td>
<p>sample size, a positive integer</p>
</td></tr>
<tr><td><code id="rmatrixCHkind1_+3A_nu">nu</code></td>
<td>
<p>shape parameter, a positive number; if <code>nu &lt; (p-1)/2</code>,
where <code>p</code> is the dimension (the order of <code>Sigma</code>), then <code>nu</code>
must be a half integer</p>
</td></tr>
<tr><td><code id="rmatrixCHkind1_+3A_alpha">alpha</code>, <code id="rmatrixCHkind1_+3A_beta">beta</code></td>
<td>
<p>shape parameters with the following constraints:
<code>b = a</code> or <code>b &gt; a &gt; nu + (p-1)/2</code></p>
</td></tr>
<tr><td><code id="rmatrixCHkind1_+3A_theta">theta</code></td>
<td>
<p>scale parameter, a positive number</p>
</td></tr>
<tr><td><code id="rmatrixCHkind1_+3A_sigma">Sigma</code></td>
<td>
<p>scale matrix, a symmetric positive definite matrix, or
<code>NULL</code> for the identity matrix of order <code>p</code></p>
</td></tr>
<tr><td><code id="rmatrixCHkind1_+3A_p">p</code></td>
<td>
<p>if <code>Sigma</code> is <code>NULL</code>, this sets <code>Sigma</code> to the
identity matrix of order <code>p</code>; ignored if <code>Sigma</code> is not <code>NULL</code></p>
</td></tr>
<tr><td><code id="rmatrixCHkind1_+3A_checksymmetry">checkSymmetry</code></td>
<td>
<p>logical, whether to check that <code>Sigma</code> is a
symmetric positive definite matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric three-dimensional array;
simulations are stacked along the third dimension.
</p>


<h3>Note</h3>

<p>For <code>alpha = beta</code>, this is the matrix variate Gamma distribution
with parameters <code>nu</code>, <code>theta</code>, <code>Sigma</code>.
</p>


<h3>References</h3>

<p>Gupta &amp; al.
Properties of Matrix Variate Confluent Hypergeometric Function Distribution.
<em>Journal of Probability and Statistics</em>
vol. 2016, Article ID 2374907, 12 pages, 2016.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nu &lt;- 5; alpha &lt;- 10; beta &lt;- 12; theta &lt;- 2; p &lt;- 3; Sigma &lt;- toeplitz(3:1)
CHsims &lt;- rmatrixCHkind1(10000, nu, alpha, beta, theta, Sigma)
# simulations of the trace
sims &lt;- apply(CHsims, 3, function(X) sum(diag(X)))
mean(sims)
theta * nu * (nu-beta+(p+1)/2) / (nu-alpha+(p+1)/2) * sum(diag(Sigma))
</code></pre>

<hr>
<h2 id='rmatrixgamma'>Matrix Gamma sampler</h2><span id='topic+rmatrixgamma'></span>

<h3>Description</h3>

<p>Samples a matrix Gamma distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmatrixgamma(n, nu, theta, Sigma = NULL, p, checkSymmetry = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmatrixgamma_+3A_n">n</code></td>
<td>
<p>sample size, a positive integer</p>
</td></tr>
<tr><td><code id="rmatrixgamma_+3A_nu">nu</code></td>
<td>
<p>shape parameter, a positive number; if <code>nu &lt; (p-1)/2</code>,
where <code>p</code> is the dimension (the order of <code>Sigma</code>), then <code>nu</code>
must be a half integer</p>
</td></tr>
<tr><td><code id="rmatrixgamma_+3A_theta">theta</code></td>
<td>
<p>scale parameter, a positive number</p>
</td></tr>
<tr><td><code id="rmatrixgamma_+3A_sigma">Sigma</code></td>
<td>
<p>scale matrix, a symmetric positive definite matrix, or
<code>NULL</code> for the identity matrix of order <code>p</code></p>
</td></tr>
<tr><td><code id="rmatrixgamma_+3A_p">p</code></td>
<td>
<p>if <code>Sigma</code> is <code>NULL</code>, this sets <code>Sigma</code> to the
identity matrix of order <code>p</code>; ignored if <code>Sigma</code> is not <code>NULL</code></p>
</td></tr>
<tr><td><code id="rmatrixgamma_+3A_checksymmetry">checkSymmetry</code></td>
<td>
<p>logical, whether to check that <code>Sigma</code> is a
symmetric positive definite matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the distribution of
&theta;/2&times;S where
S ~ W<sub>p</sub>(2&nu;,&Sigma;).
</p>


<h3>Value</h3>

<p>A numeric three-dimensional array;
simulations are stacked along the third dimension.
</p>


<h3>References</h3>

<p>Gupta &amp; al.
Properties of Matrix Variate Confluent Hypergeometric Function Distribution.
<em>Journal of Probability and Statistics</em>
vol. 2016, Article ID 2374907, 12 pages, 2016.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nu &lt;- 3; theta &lt;- 4; Sigma &lt;- toeplitz(2:1)
Gsims &lt;- rmatrixgamma(10000, nu, theta, Sigma)
apply(Gsims, c(1,2), mean) # should be nu * theta * Sigma
nu * theta * Sigma
</code></pre>

<hr>
<h2 id='rmatrixit'>Matrix inverted-t sampler</h2><span id='topic+rmatrixit'></span>

<h3>Description</h3>

<p>Samples the matrix inverted-t distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmatrixit(n, nu, M, U, V, checkSymmetry = TRUE, keep = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmatrixit_+3A_n">n</code></td>
<td>
<p>sample size, a positive integer</p>
</td></tr>
<tr><td><code id="rmatrixit_+3A_nu">nu</code></td>
<td>
<p>degrees of freedom, any positive number or an
integer strictly greater than <code>1-nrow(M)</code></p>
</td></tr>
<tr><td><code id="rmatrixit_+3A_m">M</code></td>
<td>
<p>mean matrix, without constraints</p>
</td></tr>
<tr><td><code id="rmatrixit_+3A_u">U</code></td>
<td>
<p>columns covariance matrix, a positive semidefinite matrix of order equal
to <code>nrow(M)</code></p>
</td></tr>
<tr><td><code id="rmatrixit_+3A_v">V</code></td>
<td>
<p>rows covariance matrix, a positive semidefinite matrix of order equal
to <code>ncol(M)</code></p>
</td></tr>
<tr><td><code id="rmatrixit_+3A_checksymmetry">checkSymmetry</code></td>
<td>
<p>logical, whether to check the symmetry of <code>U</code> and <code>V</code></p>
</td></tr>
<tr><td><code id="rmatrixit_+3A_keep">keep</code></td>
<td>
<p>logical, whether to return an array with class <span class="pkg"><a href="keep.html#topic+keep">keep</a></span></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric three-dimensional array;
simulations are stacked along the third dimension (see example).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nu &lt;- 0
m &lt;- 2
p &lt;- 3
M &lt;- matrix(1, m, p)
U &lt;- toeplitz(m:1)
V &lt;- toeplitz(p:1)
ITsims &lt;- rmatrixit(10000, nu, M, U, V)
dim(ITsims) # 2 3 10000
apply(ITsims, 1:2, mean) # approximates M
vecITsims &lt;- t(apply(ITsims, 3, function(X) c(t(X))))
round(cov(vecITsims),2) # approximates 1/(nu+m+p-1) * kronecker(U,V)
</code></pre>

<hr>
<h2 id='rmatrixnormal'>Matrix normal sampler</h2><span id='topic+rmatrixnormal'></span>

<h3>Description</h3>

<p>Samples the matrix normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmatrixnormal(n, M, U, V, checkSymmetry = TRUE, keep = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmatrixnormal_+3A_n">n</code></td>
<td>
<p>sample size, a positive integer</p>
</td></tr>
<tr><td><code id="rmatrixnormal_+3A_m">M</code></td>
<td>
<p>mean matrix, without constraints</p>
</td></tr>
<tr><td><code id="rmatrixnormal_+3A_u">U</code></td>
<td>
<p>columns covariance matrix, a positive semidefinite matrix of order equal
to <code>nrow(M)</code></p>
</td></tr>
<tr><td><code id="rmatrixnormal_+3A_v">V</code></td>
<td>
<p>rows covariance matrix, a positive semidefinite matrix of order equal
to <code>ncol(M)</code></p>
</td></tr>
<tr><td><code id="rmatrixnormal_+3A_checksymmetry">checkSymmetry</code></td>
<td>
<p>logical, whether to check the symmetry of <code>U</code> and <code>V</code></p>
</td></tr>
<tr><td><code id="rmatrixnormal_+3A_keep">keep</code></td>
<td>
<p>logical, whether to return an array with class <span class="pkg"><a href="keep.html#topic+keep">keep</a></span></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric three-dimensional array;
simulations are stacked along the third dimension (see example).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- 3
p &lt;- 2
M &lt;- matrix(1, m, p)
U &lt;- toeplitz(m:1)
V &lt;- toeplitz(p:1)
MNsims &lt;- rmatrixnormal(10000, M, U, V)
dim(MNsims) # 3 2 10000
apply(MNsims, 1:2, mean) # approximates M
vecMNsims &lt;- t(apply(MNsims, 3, function(X) c(t(X))))
round(cov(vecMNsims)) # approximates kronecker(U,V)
</code></pre>

<hr>
<h2 id='rmatrixt'>Matrix t sampler</h2><span id='topic+rmatrixt'></span>

<h3>Description</h3>

<p>Samples the matrix t-distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmatrixt(n, nu, M, U, V, checkSymmetry = TRUE, keep = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmatrixt_+3A_n">n</code></td>
<td>
<p>sample size, a positive integer</p>
</td></tr>
<tr><td><code id="rmatrixt_+3A_nu">nu</code></td>
<td>
<p>degrees of freedom, a positive number</p>
</td></tr>
<tr><td><code id="rmatrixt_+3A_m">M</code></td>
<td>
<p>mean matrix, without constraints</p>
</td></tr>
<tr><td><code id="rmatrixt_+3A_u">U</code></td>
<td>
<p>columns covariance matrix, a positive semidefinite matrix of order equal
to <code>nrow(M)</code></p>
</td></tr>
<tr><td><code id="rmatrixt_+3A_v">V</code></td>
<td>
<p>rows covariance matrix, a positive semidefinite matrix of order equal
to <code>ncol(M)</code></p>
</td></tr>
<tr><td><code id="rmatrixt_+3A_checksymmetry">checkSymmetry</code></td>
<td>
<p>logical, whether to check the symmetry of <code>U</code> and <code>V</code></p>
</td></tr>
<tr><td><code id="rmatrixt_+3A_keep">keep</code></td>
<td>
<p>logical, whether to return an array with class <span class="pkg"><a href="keep.html#topic+keep">keep</a></span></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric three-dimensional array;
simulations are stacked along the third dimension (see example).
</p>


<h3>Note</h3>

<p>When <code>p=1</code> and <code>V=nu</code> or when <code>m=1</code> and <code>U=nu</code>, the
distribution is the multivariate t-distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nu &lt;- 4
m &lt;- 2
p &lt;- 3
M &lt;- matrix(1, m, p)
U &lt;- toeplitz(m:1)
V &lt;- toeplitz(p:1)
Tsims &lt;- rmatrixt(10000, nu, M, U, V)
dim(Tsims) # 2 3 10000
apply(Tsims, 1:2, mean) # approximates M
vecTsims &lt;- t(apply(Tsims, 3, function(X) c(t(X))))
round(cov(vecTsims), 1) # approximates 1/(nu-2) * kronecker(U,V)
## the `keep` class is nice when m=1 or p=1:
Tsims &lt;- rmatrixt(2, nu, M=1:3, U=diag(3), V=1)
Tsims[,,1] # dimensions 3 1
# without `keep`, dimensions are lost:
rmatrixt(2, nu, M=1:3, U=diag(3), V=1, keep=FALSE)[,,1]
</code></pre>

<hr>
<h2 id='rwishart'>Wishart sampler</h2><span id='topic+rwishart'></span>

<h3>Description</h3>

<p>Samples a Wishart distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwishart(n, nu, Sigma, Theta = NULL, epsilon = 0,
  checkSymmetry = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rwishart_+3A_n">n</code></td>
<td>
<p>sample size, a positive integer</p>
</td></tr>
<tr><td><code id="rwishart_+3A_nu">nu</code></td>
<td>
<p>degrees of freedom, a positive number;
if <code>nu &lt; p-1</code> where <code>p</code> is the dimension (the order of <code>Sigma</code>),
must be an integer;
in the noncentral case (i.e. when <code>Theta</code> is not the null matrix), <code>nu</code>
must satisfy <code>nu &gt;= p-1</code></p>
</td></tr>
<tr><td><code id="rwishart_+3A_sigma">Sigma</code></td>
<td>
<p>scale matrix, a positive semidefinite real matrix</p>
</td></tr>
<tr><td><code id="rwishart_+3A_theta">Theta</code></td>
<td>
<p>noncentrality parameter, a positive semidefinite real matrix of
same order as <code>Sigma</code>; setting it to <code>NULL</code> (default) is
equivalent to setting it to the zero matrix</p>
</td></tr>
<tr><td><code id="rwishart_+3A_epsilon">epsilon</code></td>
<td>
<p>a number involved in the algorithm only if it positive; its role
is to guarantee the invertibility of the sampled matrices; see Details</p>
</td></tr>
<tr><td><code id="rwishart_+3A_checksymmetry">checkSymmetry</code></td>
<td>
<p>logical, whether to check the symmetry of <code>Sigma</code>
and <code>Theta</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>epsilon</code> is a threshold whose role is to guarantee
that the algorithm samples invertible matrices when <code>nu &gt; p-1</code> and
<code>Sigma</code> is positive definite.
The sampled matrices are theoretically invertible under these conditions,
but due to numerical issues, they are not always invertible when
<code>nu</code> is close to <code>p-1</code>, i.e. when <code>nu-p+1</code> is small.
In this case, the chi-squared distributions involved in the algorithm can
generate zero values or values close to zero, yielding the non-invertibility
of the sampled matrices. These values are replaced with <code>epsilon</code> if they are
smaller than <code>epsilon</code>.
</p>


<h3>Value</h3>

<p>A numeric three-dimensional array;
simulations are stacked along the third dimension (see example).
</p>


<h3>Note</h3>

<p>A sampled Wishart matrix is always positive semidefinite.
It is positive definite if <code>nu &gt; p-1</code> and <code>Sigma</code> is positive
definite, in theory (see Details).
</p>
<p>In the noncentral case, i.e. when <code>Theta</code> is not null, the Ahdida &amp; Alfonsi
algorithm is used if <code>nu</code> is not an integer and <code>p-1 &lt; nu &lt; 2p-1</code>, or
if <code>nu = p-1</code>. The simulations are slower in this case.
</p>


<h3>References</h3>

<p>A. Ahdida &amp; A. Alfonsi. Exact and high-order discretization schemes
for Wishart processes and their affine extensions.
<em>The Annals of Applied Probability</em> <strong>23</strong>, 2013, 1025-1073.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nu &lt;- 4
p &lt;- 3
Sigma &lt;- toeplitz(p:1)
Theta &lt;- diag(p)
Wsims &lt;- rwishart(10000, nu, Sigma, Theta)
dim(Wsims) # 3 3 10000
apply(Wsims, 1:2, mean) # approximately nu*Sigma+Theta
# the epsilon argument:
Wsims_det &lt;- apply(rwishart(10000, nu=p-1+0.001, Sigma), 3, det)
length(which(Wsims_det &lt; .Machine$double.eps))
Wsims_det &lt;- apply(rwishart(10000, nu=p-1+0.001, Sigma, epsilon=1e-8), 3, det)
length(which(Wsims_det &lt; .Machine$double.eps))
</code></pre>

<hr>
<h2 id='rwishart_chol'>Sampling Cholesky factor of a Wishart matrix</h2><span id='topic+rwishart_chol'></span>

<h3>Description</h3>

<p>Samples the lower triangular Cholesky factor of a Wishart random matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwishart_chol(n, nu, Sigma, epsilon = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rwishart_chol_+3A_n">n</code></td>
<td>
<p>sample size, a positive integer</p>
</td></tr>
<tr><td><code id="rwishart_chol_+3A_nu">nu</code></td>
<td>
<p>degrees of freedom, a number strictly greater than <code>p-1</code>,
where <code>p</code> is the dimension (the order of <code>Sigma</code>)</p>
</td></tr>
<tr><td><code id="rwishart_chol_+3A_sigma">Sigma</code></td>
<td>
<p>scale matrix, a positive definite real matrix</p>
</td></tr>
<tr><td><code id="rwishart_chol_+3A_epsilon">epsilon</code></td>
<td>
<p>a number involved in the algorithm only if it positive; its role
is to guarantee the invertibility of the sampled matrices; see Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>epsilon</code> is a threshold whose role is to guarantee
that the algorithm samples invertible matrices.
The matrices sampled by the algorithm are theoretically invertible.
However, because of numerical precision, they are not always invertible when
<code>nu</code> is close to <code>p-1</code>, i.e. when <code>nu-p+1</code> is small. In this case,
the simulations of chi-squared distributions involved in the algorithm can
generate zero values or values close to zero, yielding the non-invertibility
of the sampled matrices. These values are replaced with <code>epsilon</code> if they are
smaller than <code>epsilon</code>.
</p>


<h3>Value</h3>

<p>A numeric three-dimensional array;
simulations are stacked along the third dimension (see example).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nu &lt;- 4
p &lt;- 3
Sigma &lt;- diag(p)
Wsims &lt;- rwishart_chol(10000, nu, Sigma)
dim(Wsims) # 3 3 10000
Wsims[,,1]
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
