<!DOCTYPE html><html><head><title>Help for package sparsebnUtils</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sparsebnUtils}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.data.frame.sparsebnData'><p>Convert a sparsebnData object back to a data.frame</p></a></li>
<li><a href='#as.edgeList'><p>as.edgeList</p></a></li>
<li><a href='#as.sparse'><p>as.sparse</p></a></li>
<li><a href='#coerce_discrete'><p>Recode discrete data</p></a></li>
<li><a href='#count.interventions'><p>Count the number of rows under intervention</p></a></li>
<li><a href='#count.levels'><p>Count the number of levels per variable</p></a></li>
<li><a href='#degrees'><p>Degree distribution of a graph</p></a></li>
<li><a href='#edgeList'><p>edgeList class</p></a></li>
<li><a href='#estimate.parameters'><p>Estimate the parameters of a Bayesian network</p></a></li>
<li><a href='#fit_glm_dag'><p>Inference in Bayesian networks</p></a></li>
<li><a href='#fit_multinom_dag'><p>Inference in discrete Bayesian networks</p></a></li>
<li><a href='#generate.lambdas'><p>generate.lambdas</p></a></li>
<li><a href='#get.adjacency.matrix.edgeList'><p>get.adjacency.matrix</p></a></li>
<li><a href='#get.covariance'><p>Covariance and precision matrices</p></a></li>
<li><a href='#get.lambdas'><p>get.lambdas</p></a></li>
<li><a href='#get.nodes'><p>get.nodes</p></a></li>
<li><a href='#get.solution'><p>Select solutions from a solution path</p></a></li>
<li><a href='#is.obs'><p>Check if data is observational</p></a></li>
<li><a href='#is.zero.edgeList'><p>is.zero</p></a></li>
<li><a href='#num.edges.edgeList'><p>num.edges</p></a></li>
<li><a href='#num.nodes.edgeList'><p>num.nodes</p></a></li>
<li><a href='#num.samples'><p>num.samples</p></a></li>
<li><a href='#openCytoscape'><p>Display graphs in Cytoscape</p></a></li>
<li><a href='#permute.nodes'><p>Permute the order of nodes in a graph</p></a></li>
<li><a href='#pick_family'><p>Utility functions</p></a></li>
<li><a href='#plot.edgeList'><p>Plot a fitted Bayesian network object</p></a></li>
<li><a href='#random.dag'><p>Generate random DAGs</p></a></li>
<li><a href='#random.graph'><p>Generate random DAGs</p></a></li>
<li><a href='#random.spd'><p>Generate a random positive definite matrix</p></a></li>
<li><a href='#resetGraphPackage'><p>Change data structure for representing graphs internally</p></a></li>
<li><a href='#select'><p>Select solutions from a solution path</p></a></li>
<li><a href='#select.parameter'><p>Tuning parameter selection</p></a></li>
<li><a href='#setPlotPackage'><p>Change default plotting mechanism</p></a></li>
<li><a href='#show.parents'><p>Inspect subgraph</p></a></li>
<li><a href='#sparse'><p>sparse class</p></a></li>
<li><a href='#sparsebn-messages'><p>Messages</p></a></li>
<li><a href='#sparsebnData'><p>sparsebnData class</p></a></li>
<li><a href='#sparsebnFit'><p>sparsebnFit class</p></a></li>
<li><a href='#sparsebnPath'><p>sparsebnPath class</p></a></li>
<li><a href='#sparsebnUtils'><p>sparsebnUtils: Utilities for the sparsebn package.</p></a></li>
<li><a href='#specify.prior'><p>Build a black list based on prior knowledge</p></a></li>
<li><a href='#to_bn'><p>Conversion between graph types</p></a></li>
<li><a href='#to_edgeList'><p>Conversion to edgeList object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Utilities for Learning Sparse Bayesian Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-01-26</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bryon Aragam &lt;sparsebn@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of tools for representing and estimating sparse Bayesian networks from continuous and discrete data, as described in Aragam, Gu, and Zhou (2017) &lt;<a href="https://doi.org/10.48550/arXiv.1703.04025">doi:10.48550/arXiv.1703.04025</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, stats, utils, methods, nnet</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bnlearn, graph, igraph, network, RCy3, testthat</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/itsrainingdata/sparsebnUtils">https://github.com/itsrainingdata/sparsebnUtils</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/itsrainingdata/sparsebnUtils/issues">https://github.com/itsrainingdata/sparsebnUtils/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-27 02:07:48 UTC; zigmund-3</td>
</tr>
<tr>
<td>Author:</td>
<td>Bryon Aragam [aut, cre],
  Jiaying Gu [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-27 06:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.data.frame.sparsebnData'>Convert a sparsebnData object back to a data.frame</h2><span id='topic+as.data.frame.sparsebnData'></span>

<h3>Description</h3>

<p>Convert a sparsebnData object back to a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sparsebnData'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.sparsebnData_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+sparsebnData">sparsebnData</a></code> object.</p>
</td></tr>
<tr><td><code id="as.data.frame.sparsebnData_+3A_...">...</code></td>
<td>
<p>(optional) additional argument to <code>as.data.frame</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='as.edgeList'>as.edgeList</h2><span id='topic+as.edgeList'></span>

<h3>Description</h3>

<p>Methods for coercing other <code>R</code> objects to <code><a href="#topic+edgeList">edgeList</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.edgeList(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.edgeList_+3A_x">x</code></td>
<td>
<p>A compatible <code>R</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+edgeList">edgeList</a></code>
</p>

<hr>
<h2 id='as.sparse'>as.sparse</h2><span id='topic+as.sparse'></span>

<h3>Description</h3>

<p>Methods for coercing other <code>R</code> objects to <code><a href="#topic+sparse">sparse</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.sparse(x, index = "R", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.sparse_+3A_x">x</code></td>
<td>
<p>A compatible <code>R</code> object.</p>
</td></tr>
<tr><td><code id="as.sparse_+3A_index">index</code></td>
<td>
<p><code>"R"</code> or <code>"C"</code>, depending on whether to use R- or C-style indexing.</p>
</td></tr>
<tr><td><code id="as.sparse_+3A_...">...</code></td>
<td>
<p>other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+sparse">sparse</a></code>
</p>

<hr>
<h2 id='coerce_discrete'>Recode discrete data</h2><span id='topic+coerce_discrete'></span><span id='topic+coerce_discrete.factor'></span><span id='topic+coerce_discrete.numeric'></span><span id='topic+coerce_discrete.integer'></span><span id='topic+coerce_discrete.character'></span><span id='topic+coerce_discrete.data.frame'></span><span id='topic+coerce_discrete.sparsebnData'></span>

<h3>Description</h3>

<p>Recodes discrete data so that the levels correspond to <code>0...n-1</code>, where <code>n</code>
is the total number of levels in a discrete factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coerce_discrete(x)

## S3 method for class 'factor'
coerce_discrete(x)

## S3 method for class 'numeric'
coerce_discrete(x)

## S3 method for class 'integer'
coerce_discrete(x)

## S3 method for class 'character'
coerce_discrete(x)

## S3 method for class 'data.frame'
coerce_discrete(x)

## S3 method for class 'sparsebnData'
coerce_discrete(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coerce_discrete_+3A_x">x</code></td>
<td>
<p>an R object to coerce.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assumes data is unordered. Ordered factors are not supported at this time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
coerce_discrete(x) # output: 0 1 2 3 4

x &lt;- c("high", "normal", "high", "low")
coerce_discrete(x) # output: 0 2 0 1

</code></pre>

<hr>
<h2 id='count.interventions'>Count the number of rows under intervention</h2><span id='topic+count.interventions'></span>

<h3>Description</h3>

<p>Returns the number of rows with at least one intervention
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count.interventions(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count.interventions_+3A_data">data</code></td>
<td>
<p>a <code><a href="#topic+sparsebnData">sparsebnData</a></code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='count.levels'>Count the number of levels per variable</h2><span id='topic+count.levels'></span>

<h3>Description</h3>

<p>Returns the number of levels per variable as an ordered vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count.levels(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count.levels_+3A_data">data</code></td>
<td>
<p>a <code><a href="#topic+sparsebnData">sparsebnData</a></code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='degrees'>Degree distribution of a graph</h2><span id='topic+degrees'></span>

<h3>Description</h3>

<p>Returns a <code>data.frame</code> with summary statistics on the total degree,
in-degree, and out-degree of each node in the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degrees(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degrees_+3A_x">x</code></td>
<td>
<p>an <code>edgeList</code> object</p>
</td></tr>
</table>

<hr>
<h2 id='edgeList'>edgeList class</h2><span id='topic+edgeList'></span><span id='topic+is.edgeList'></span><span id='topic+print.edgeList'></span><span id='topic+summary.edgeList'></span>

<h3>Description</h3>

<p>Convenience wrapper class for a (column-major) edge list. Each component of the list
corresponds to a node, and each component is an integer vector whose components are the parents
of this node in the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.edgeList(x)

## S3 method for class 'edgeList'
print(x, maxsize = 20, ...)

## S3 method for class 'edgeList'
summary(object, ...)

edgeList(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edgeList_+3A_x">x</code></td>
<td>
<p>A list containing parents for each node in a graph. The length of this list
should be the same as the number of nodes in the graph.</p>
</td></tr>
<tr><td><code id="edgeList_+3A_maxsize">maxsize</code></td>
<td>
<p>Maximum number of nodes to print out. If
<code>num.nodes(x) &gt; maxsize</code>, then a simple summary will be printed
instead.</p>
</td></tr>
<tr><td><code id="edgeList_+3A_...">...</code></td>
<td>
<p>(optional) additional arguments.</p>
</td></tr>
<tr><td><code id="edgeList_+3A_object">object</code></td>
<td>
<p>an object of type <code>edgeList</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Also inherits from <code><a href="base.html#topic+list">list</a></code>.
</p>


<h3>Methods</h3>

<p><code><a href="#topic+get.adjacency.matrix">get.adjacency.matrix</a></code>,
<code><a href="#topic+num.nodes">num.nodes</a></code>, <code><a href="#topic+num.edges">num.edges</a></code>
</p>

<hr>
<h2 id='estimate.parameters'>Estimate the parameters of a Bayesian network</h2><span id='topic+estimate.parameters'></span>

<h3>Description</h3>

<p>Given the structure of a Bayesian network, estimate the parameters (weights) using ordinary least
squares (for Gaussian data) or logistic regression (for discrete data).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate.parameters(fit, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.parameters_+3A_fit">fit</code></td>
<td>
<p>fitted <code><a href="#topic+sparsebnFit">sparsebnFit</a></code> or <code><a href="#topic+sparsebnPath">sparsebnPath</a></code> object containing the Bayesian network structure to fit.</p>
</td></tr>
<tr><td><code id="estimate.parameters_+3A_data">data</code></td>
<td>
<p>Data to use for fitting.</p>
</td></tr>
<tr><td><code id="estimate.parameters_+3A_...">...</code></td>
<td>
<p>(optional) additional arguments to pass to <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The low-level fitting methods are <code><a href="#topic+fit_glm_dag">fit_glm_dag</a></code> (for continuous data)
and <code><a href="#topic+fit_multinom_dag">fit_multinom_dag</a></code> (for discrete data).
</p>

<hr>
<h2 id='fit_glm_dag'>Inference in Bayesian networks</h2><span id='topic+fit_glm_dag'></span>

<h3>Description</h3>

<p>Basic computing engine called by <code><a href="#topic+estimate.parameters">estimate.parameters</a></code> for fitting parameters
in a Bayesian network. Should not be used directly unless by experienced users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_glm_dag(parents, dat, call = "lm.fit", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_glm_dag_+3A_parents">parents</code></td>
<td>
<p><code><a href="#topic+edgeList">edgeList</a></code> object.</p>
</td></tr>
<tr><td><code id="fit_glm_dag_+3A_dat">dat</code></td>
<td>
<p>Data.</p>
</td></tr>
<tr><td><code id="fit_glm_dag_+3A_call">call</code></td>
<td>
<p>Either <code>"lm.fit"</code> or <code>"glm.fit"</code>.</p>
</td></tr>
<tr><td><code id="fit_glm_dag_+3A_...">...</code></td>
<td>
<p>If <code>call = "glm.fit"</code>, specify <code>family</code> here. Also allows for other parameters to <code>lm.fit</code> and <code>glm.fit</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can call either <code><a href="stats.html#topic+lm.fit">lm.fit</a></code> or <code><a href="stats.html#topic+glm.fit">glm.fit</a></code>, with any choice of family.
</p>

<hr>
<h2 id='fit_multinom_dag'>Inference in discrete Bayesian networks</h2><span id='topic+fit_multinom_dag'></span>

<h3>Description</h3>

<p>Given the structure of a Bayesian network, estimate the parameters
using multinomial logistic regression. For each node <code class="reqn">i</code>, regress
<code class="reqn">i</code> onto its parents set using <code><a href="nnet.html#topic+multinom">multinom</a></code>
in package <code><a href="nnet.html#topic+nnet">nnet</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_multinom_dag(parents, dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_multinom_dag_+3A_parents">parents</code></td>
<td>
<p>An <code><a href="#topic+edgeList">edgeList</a></code> object.</p>
</td></tr>
<tr><td><code id="fit_multinom_dag_+3A_dat">dat</code></td>
<td>
<p>Data, a dataframe or matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with with one component for each node in the graph.
Each node is a coefficient matrix for the parents of that node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### construct a random data set
x &lt;- c(0,1,0,1,0)
y &lt;- c(1,0,1,0,1)
z &lt;- c(0,1,2,1,0)
a &lt;- c(1,1,1,0,0)
b &lt;- c(0,0,1,1,1)
dat &lt;- data.frame(x, y, z, a, b)

### randomly construct an edgelist of a graph
nnode &lt;- ncol(dat)
li &lt;- vector("list", length = nnode)
li[[1]] &lt;- c(2L,4L)
li[[2]] &lt;- c(3L,4L,5L)
li[[3]] &lt;- integer(0)
li[[4]] &lt;- integer(0)
li[[5]] &lt;- integer(0)
edgeL &lt;- edgeList(li)

### run fit_multinom_dag
fit.multinom &lt;- fit_multinom_dag(edgeL, dat)

</code></pre>

<hr>
<h2 id='generate.lambdas'>generate.lambdas</h2><span id='topic+generate.lambdas'></span>

<h3>Description</h3>

<p>Convenience function for creating a grid of lambdas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.lambdas(
  lambda.max,
  lambdas.ratio = 0.001,
  lambdas.length = 50,
  scale = "linear"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.lambdas_+3A_lambda.max">lambda.max</code></td>
<td>
<p>Maximum value of lambda; in terms of the algorithm this is the initial value
of the regularization parameter in the solution path.</p>
</td></tr>
<tr><td><code id="generate.lambdas_+3A_lambdas.ratio">lambdas.ratio</code></td>
<td>
<p>Ratio between the maximum lambda value and the minimum lambda value in the solution
path.</p>
</td></tr>
<tr><td><code id="generate.lambdas_+3A_lambdas.length">lambdas.length</code></td>
<td>
<p>Number of values to include.</p>
</td></tr>
<tr><td><code id="generate.lambdas_+3A_scale">scale</code></td>
<td>
<p>Which scale to use: Either <code>"linear"</code> or <code>"log"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Section 5.3 of <a href="https://jmlr.org/papers/v16/aragam15a.html">Aragam and Zhou (2015)</a>
for a discussion of regularization paths (also, solution paths).
</p>

<hr>
<h2 id='get.adjacency.matrix.edgeList'>get.adjacency.matrix</h2><span id='topic+get.adjacency.matrix.edgeList'></span><span id='topic+get.adjacency.matrix'></span><span id='topic+get.adjacency.matrix.sparsebnFit'></span><span id='topic+get.adjacency.matrix.sparsebnPath'></span>

<h3>Description</h3>

<p>Extracts the adjacency matrix of the associated graph object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'edgeList'
get.adjacency.matrix(x)

get.adjacency.matrix(x)

## S3 method for class 'sparsebnFit'
get.adjacency.matrix(x)

## S3 method for class 'sparsebnPath'
get.adjacency.matrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.adjacency.matrix.edgeList_+3A_x">x</code></td>
<td>
<p>any <code>R</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code>
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>edgeList</code>: Convert internal <code>edgeList</code> representation to an adjacency matrix
</p>
</li>
<li> <p><code>sparsebnFit</code>: Retrieves <code>edges</code> slot and converts to an adjacency matrix
</p>
</li>
<li> <p><code>sparsebnPath</code>: Retrieves all <code>edges</code> slots in the solution path, converts to an adjacency matrix, and returns as a list
</p>
</li></ul>

<hr>
<h2 id='get.covariance'>Covariance and precision matrices</h2><span id='topic+get.covariance'></span><span id='topic+get.precision'></span>

<h3>Description</h3>

<p>Methods for computing covariance and precision matrices given an estimated directed graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.covariance(x, data, ...)

get.precision(x, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.covariance_+3A_x">x</code></td>
<td>
<p>fitted <code><a href="#topic+sparsebnFit">sparsebnFit</a></code> or <code><a href="#topic+sparsebnPath">sparsebnPath</a></code> object.</p>
</td></tr>
<tr><td><code id="get.covariance_+3A_data">data</code></td>
<td>
<p>data as <code><a href="#topic+sparsebnData">sparsebnData</a></code> object.</p>
</td></tr>
<tr><td><code id="get.covariance_+3A_...">...</code></td>
<td>
<p>(optional) additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For Gaussian data, the precision matrix corresponds to an undirected graphical model for the
distribution. This undirected graph can be tied to the corresponding directed graphical model;
see Sections 2.1 and 2.2 (equation (6)) of Aragam and Zhou (2015) for more details.
</p>


<h3>Value</h3>

<p>Covariance (or precision) matrix as <code><a href="Matrix.html#topic+Matrix">Matrix</a></code> object.
</p>

<hr>
<h2 id='get.lambdas'>get.lambdas</h2><span id='topic+get.lambdas'></span><span id='topic+get.lambdas.sparsebnPath'></span>

<h3>Description</h3>

<p>Extracts the lambda values from a <code><a href="#topic+sparsebnPath">sparsebnPath</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.lambdas(x)

## S3 method for class 'sparsebnPath'
get.lambdas(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.lambdas_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+sparsebnPath">sparsebnPath</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of <code>numeric</code> lambda values in fitted object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>sparsebnPath</code>: Returns a vector of lambda values defining the solution path of a <code><a href="#topic+sparsebnPath">sparsebnPath</a></code> object.
</p>
</li></ul>

<hr>
<h2 id='get.nodes'>get.nodes</h2><span id='topic+get.nodes'></span><span id='topic+get.nodes.sparsebnFit'></span><span id='topic+get.nodes.sparsebnPath'></span>

<h3>Description</h3>

<p>Returns the node names associated with a fitted object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.nodes(x)

## S3 method for class 'sparsebnFit'
get.nodes(x)

## S3 method for class 'sparsebnPath'
get.nodes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.nodes_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+sparsebnFit">sparsebnFit</a></code> or <code><a href="#topic+sparsebnPath">sparsebnPath</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of <code>character</code> names.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>sparsebnFit</code>: Returns the node names from a <code><a href="#topic+sparsebnFit">sparsebnFit</a></code> object.
</p>
</li>
<li> <p><code>sparsebnPath</code>: Returns the node names from a <code><a href="#topic+sparsebnPath">sparsebnPath</a></code> object.
</p>
</li></ul>

<hr>
<h2 id='get.solution'>Select solutions from a solution path</h2><span id='topic+get.solution'></span>

<h3>Description</h3>

<p>Choose solutions from a solution path based on number of edges, value of
regularization parameter lambda, or index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.solution(x, edges, lambda, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.solution_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+sparsebnPath">sparsebnPath</a></code> object.</p>
</td></tr>
<tr><td><code id="get.solution_+3A_edges">edges</code></td>
<td>
<p>number of edges to search for.</p>
</td></tr>
<tr><td><code id="get.solution_+3A_lambda">lambda</code></td>
<td>
<p>value of regularization parameter to search for.</p>
</td></tr>
<tr><td><code id="get.solution_+3A_index">index</code></td>
<td>
<p>integer index to select.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>edges</code> (resp. <code>lambda</code>), the solution with the closest number
of edges (resp. regularization parameter) is returned. If there is no match
within a tolerance of 0.1 for <code>lambda</code>, nothing is returned. Fuzzy matching
is not used for when selecting by <code>index</code>.
</p>
<p>If there is more than one match (for example, by number of edges), then
the first such estimate is returned. Note that <code>select(x, index = j)</code>
is equivalent to (but slightly slower than) <code>x[[j]]</code>.
</p>

<hr>
<h2 id='is.obs'>Check if data is observational</h2><span id='topic+is.obs'></span>

<h3>Description</h3>

<p>Returns TRUE if the data contains no interventions, i.e. is purely observational
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.obs(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.obs_+3A_data">data</code></td>
<td>
<p>a <code><a href="#topic+sparsebnData">sparsebnData</a></code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='is.zero.edgeList'>is.zero</h2><span id='topic+is.zero.edgeList'></span><span id='topic+is.zero'></span>

<h3>Description</h3>

<p>Determines whether or not the object is the same as the null or zero object from its class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'edgeList'
is.zero(x)

is.zero(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.zero.edgeList_+3A_x">x</code></td>
<td>
<p>a fitted object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>edgeList</code>: Determines whether or not the object represents a null graph with no edges.
</p>
</li></ul>

<hr>
<h2 id='num.edges.edgeList'>num.edges</h2><span id='topic+num.edges.edgeList'></span><span id='topic+num.edges'></span><span id='topic+num.edges.sparsebnFit'></span><span id='topic+num.edges.sparsebnPath'></span>

<h3>Description</h3>

<p>Extracts the number of edges of the associated graph object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'edgeList'
num.edges(x)

num.edges(x)

## S3 method for class 'sparsebnFit'
num.edges(x)

## S3 method for class 'sparsebnPath'
num.edges(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.edges.edgeList_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+sparsebnFit">sparsebnFit</a></code> or <code><a href="#topic+sparsebnPath">sparsebnPath</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of edges as <code>integer</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>edgeList</code>: Extracts the number of edges of <a href="#topic+edgeList">edgeList</a> object.
</p>
</li>
<li> <p><code>sparsebnFit</code>: Extracts the number of edges of <a href="#topic+sparsebnFit">sparsebnFit</a> object.
</p>
</li>
<li> <p><code>sparsebnPath</code>: Extracts the number of edges of <a href="#topic+sparsebnPath">sparsebnPath</a> object.
</p>
</li></ul>

<hr>
<h2 id='num.nodes.edgeList'>num.nodes</h2><span id='topic+num.nodes.edgeList'></span><span id='topic+num.nodes'></span><span id='topic+num.nodes.sparsebnFit'></span><span id='topic+num.nodes.sparsebnPath'></span>

<h3>Description</h3>

<p>Extracts the number of nodes of the associated graph object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'edgeList'
num.nodes(x)

num.nodes(x)

## S3 method for class 'sparsebnFit'
num.nodes(x)

## S3 method for class 'sparsebnPath'
num.nodes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.nodes.edgeList_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+sparsebnFit">sparsebnFit</a></code> or <code><a href="#topic+sparsebnPath">sparsebnPath</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of nodes as <code>integer</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>edgeList</code>: Extracts the number of nodes of <a href="#topic+edgeList">edgeList</a> object.
</p>
</li>
<li> <p><code>sparsebnFit</code>: Extracts the number of nodes of <a href="#topic+sparsebnFit">sparsebnFit</a> object.
</p>
</li>
<li> <p><code>sparsebnPath</code>: Extracts the number of nodes of <a href="#topic+sparsebnPath">sparsebnPath</a> object.
</p>
</li></ul>

<hr>
<h2 id='num.samples'>num.samples</h2><span id='topic+num.samples'></span><span id='topic+num.samples.sparsebnData'></span><span id='topic+num.samples.sparsebnFit'></span><span id='topic+num.samples.sparsebnPath'></span>

<h3>Description</h3>

<p>Extracts the number of samples used to estimate the associated object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.samples(x)

## S3 method for class 'sparsebnData'
num.samples(x)

## S3 method for class 'sparsebnFit'
num.samples(x)

## S3 method for class 'sparsebnPath'
num.samples(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.samples_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+sparsebnFit">sparsebnFit</a></code> or <code><a href="#topic+sparsebnPath">sparsebnPath</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of samples as <code>integer</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>sparsebnData</code>: Extracts the number of samples of <a href="#topic+sparsebnData">sparsebnData</a> object.
</p>
</li>
<li> <p><code>sparsebnFit</code>: Extracts the number of samples of <a href="#topic+sparsebnFit">sparsebnFit</a> object.
</p>
</li>
<li> <p><code>sparsebnPath</code>: Extracts the number of samples of <a href="#topic+sparsebnPath">sparsebnPath</a> object.
</p>
</li></ul>

<hr>
<h2 id='openCytoscape'>Display graphs in Cytoscape</h2><span id='topic+openCytoscape'></span>

<h3>Description</h3>

<p>NOTE: This method is currently experimental and under development!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>openCytoscape(x, title, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="openCytoscape_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+sparsebnFit">sparsebnFit</a></code> object or other graph object.</p>
</td></tr>
<tr><td><code id="openCytoscape_+3A_title">title</code></td>
<td>
<p>A character string, this is the name you will see on the Cytoscape
network window. Multiple windows with the same name are not
permitted. See <code><a href="RCy3.html#topic+createNetworkFromGraph">createNetworkFromGraph</a></code> for more
details.</p>
</td></tr>
<tr><td><code id="openCytoscape_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="RCy3.html#topic+createNetworkFromGraph">createNetworkFromGraph</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Displays the selected graph in the Cytoscape application. Note that this
requires that Cytoscape is installed on the user's system, and that the
RCy3 package is installed and properly configured. Cytoscape can be
downloaded at <a href="https://cytoscape.org/">https://cytoscape.org/</a>.
</p>

<hr>
<h2 id='permute.nodes'>Permute the order of nodes in a graph</h2><span id='topic+permute.nodes'></span>

<h3>Description</h3>

<p>Randomize the order of the nodes in a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permute.nodes(x, perm = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permute.nodes_+3A_x">x</code></td>
<td>
<p>Graph as <code><a href="#topic+edgeList">edgeList</a></code> object.</p>
</td></tr>
<tr><td><code id="permute.nodes_+3A_perm">perm</code></td>
<td>
<p>Permutation to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Useful for obfuscating the
topological sort in a DAG, which is often the default output of methods
that generate a random DAG. Output is graph isomorphic to input.
</p>


<h3>Value</h3>

<p>Permuted graph as <code><a href="#topic+edgeList">edgeList</a></code> object.
</p>

<hr>
<h2 id='pick_family'>Utility functions</h2><span id='topic+pick_family'></span><span id='topic+reIndexC'></span><span id='topic+reIndexR'></span><span id='topic+default_max_iters'></span><span id='topic+default_alpha'></span><span id='topic+sparsebn-functions'></span><span id='topic+check_if_matrix'></span><span id='topic+check_if_data_matrix'></span><span id='topic+check_if_complete_data'></span><span id='topic+check_if_numeric_data'></span><span id='topic+check_null'></span><span id='topic+check_na'></span><span id='topic+count_nas'></span><span id='topic+list_classes'></span><span id='topic+auto_generate_levels'></span><span id='topic+auto_count_levels'></span><span id='topic+check_list_class'></span><span id='topic+check_list_numeric'></span><span id='topic+check_list_names'></span><span id='topic+col_classes'></span><span id='topic+capitalize'></span><span id='topic+recode_levels'></span><span id='topic+convert_factor_to_discrete'></span><span id='topic+cor_vector_ivn'></span><span id='topic+pmatch_numeric'></span><span id='topic+zero_threshold'></span>

<h3>Description</h3>

<p>Various utility functions for packages in the <code>sparsebn</code> family
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_family(x)

reIndexC(x)

reIndexR(x)

default_max_iters(numnode)

default_alpha()

check_if_matrix(m)

check_if_data_matrix(df)

check_if_complete_data(df)

check_if_numeric_data(df)

check_null(x)

check_na(x)

count_nas(df)

list_classes(li)

auto_generate_levels(df)

auto_count_levels(df)

check_list_class(li, check.class)

check_list_numeric(li)

check_list_names(li, check.names)

col_classes(X)

capitalize(string)

recode_levels(x)

convert_factor_to_discrete(x)

cor_vector_ivn(data, ivn = NULL)

pmatch_numeric(x, table, tol = 0.1)

zero_threshold()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_family_+3A_x">x</code></td>
<td>
<p>a compatible object.</p>
</td></tr>
<tr><td><code id="pick_family_+3A_numnode">numnode</code></td>
<td>
<p><code>integer</code> number of nodes.</p>
</td></tr>
<tr><td><code id="pick_family_+3A_m">m</code></td>
<td>
<p>a <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="pick_family_+3A_df">df</code></td>
<td>
<p>a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="pick_family_+3A_li">li</code></td>
<td>
<p>a <code>list</code>.</p>
</td></tr>
<tr><td><code id="pick_family_+3A_check.class">check.class</code></td>
<td>
<p><code>character</code> class name to compare against.</p>
</td></tr>
<tr><td><code id="pick_family_+3A_check.names">check.names</code></td>
<td>
<p><code>character</code> names to compare against.</p>
</td></tr>
<tr><td><code id="pick_family_+3A_x">X</code></td>
<td>
<p>a matrix.</p>
</td></tr>
<tr><td><code id="pick_family_+3A_string">string</code></td>
<td>
<p>a <code>character</code> string.</p>
</td></tr>
<tr><td><code id="pick_family_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="pick_family_+3A_ivn">ivn</code></td>
<td>
<p>list of interventions (see <code><a href="#topic+sparsebnData">sparsebnData</a></code>).</p>
</td></tr>
<tr><td><code id="pick_family_+3A_table">table</code></td>
<td>
<p>table of values to compare against.</p>
</td></tr>
<tr><td><code id="pick_family_+3A_tol">tol</code></td>
<td>
<p>maximum tolerance used for matching.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.edgeList'>Plot a fitted Bayesian network object</h2><span id='topic+plot.edgeList'></span>

<h3>Description</h3>

<p>Plots the graph object associated with the output of a learning algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'edgeList'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.edgeList_+3A_x">x</code></td>
<td>
<p>fitted object to plot.</p>
</td></tr>
<tr><td><code id="plot.edgeList_+3A_...">...</code></td>
<td>
<p>(optional) additional arguments to plotting mechanism.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.sparsebnFit</code> uses some default settings to make large graphs
easier to interpret, but these settings can be over-ridden.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setPlotPackage">setPlotPackage</a></code>, <code><a href="#topic+getPlotPackage">getPlotPackage</a></code>
</p>

<hr>
<h2 id='random.dag'>Generate random DAGs</h2><span id='topic+random.dag'></span>

<h3>Description</h3>

<p>Generate a random DAG with fixed number of edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random.dag(nnode, nedge, FUN = NULL, permute = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.dag_+3A_nnode">nnode</code></td>
<td>
<p>Number of nodes in the DAG.</p>
</td></tr>
<tr><td><code id="random.dag_+3A_nedge">nedge</code></td>
<td>
<p>Number of edges in the DAG.</p>
</td></tr>
<tr><td><code id="random.dag_+3A_fun">FUN</code></td>
<td>
<p>Optional function to be used as a random number generator.</p>
</td></tr>
<tr><td><code id="random.dag_+3A_permute">permute</code></td>
<td>
<p>If <code>TRUE</code>, order of nodes will be randomly permuted.
If <code>FALSE</code>, output will be ordered according to its
topological sort, i.e. with a lower-triangular adjacency matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>FUN can be any function whose first argument is called <code>n</code>. This
allows for both random and deterministic outputs.
</p>


<h3>Value</h3>

<p>An (weighted) adjacency matrix.
</p>

<hr>
<h2 id='random.graph'>Generate random DAGs</h2><span id='topic+random.graph'></span>

<h3>Description</h3>

<p>Generate a random graph with fixed number of edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random.graph(nnode, nedge, acyclic = TRUE, loops = FALSE, permute = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.graph_+3A_nnode">nnode</code></td>
<td>
<p>Number of nodes in the graph.</p>
</td></tr>
<tr><td><code id="random.graph_+3A_nedge">nedge</code></td>
<td>
<p>Number of edges in the graph.</p>
</td></tr>
<tr><td><code id="random.graph_+3A_acyclic">acyclic</code></td>
<td>
<p>If <code>TRUE</code>, output will be an acyclic graph.</p>
</td></tr>
<tr><td><code id="random.graph_+3A_loops">loops</code></td>
<td>
<p>If <code>TRUE</code>, output may include self-loops.</p>
</td></tr>
<tr><td><code id="random.graph_+3A_permute">permute</code></td>
<td>
<p>If <code>TRUE</code>, order of nodes will be randomly permuted.
If <code>FALSE</code>, output will be ordered according to its
topological sort, i.e. with a lower-triangular adjacency matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+edgeList">edgeList</a></code> object containing a list of parents for each node.
</p>

<hr>
<h2 id='random.spd'>Generate a random positive definite matrix</h2><span id='topic+random.spd'></span>

<h3>Description</h3>

<p>Generate a random positive definite matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random.spd(nnode, eigenvalues = NULL, num.ortho = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.spd_+3A_nnode">nnode</code></td>
<td>
<p>Number of nodes in the matrix.</p>
</td></tr>
<tr><td><code id="random.spd_+3A_eigenvalues">eigenvalues</code></td>
<td>
<p>Vector of eigenvalues desired in output. If this
has fewer than nnode values, the remainder are filled in as zero.</p>
</td></tr>
<tr><td><code id="random.spd_+3A_num.ortho">num.ortho</code></td>
<td>
<p>Number of random Householder reflections to compose.</p>
</td></tr>
</table>

<hr>
<h2 id='resetGraphPackage'>Change data structure for representing graphs internally</h2><span id='topic+resetGraphPackage'></span><span id='topic+setGraphPackage'></span><span id='topic+getGraphPackage'></span>

<h3>Description</h3>

<p>Changes the output of the main algorithms to be compatible with other packages in the R ecosystem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resetGraphPackage(coerce = TRUE)

setGraphPackage(pkg, matchPlot = TRUE, coerce = FALSE)

getGraphPackage()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resetGraphPackage_+3A_coerce">coerce</code></td>
<td>
<p>If <code>TRUE</code>, then all <code><a href="#topic+sparsebnFit">sparsebnFit</a></code> and <code><a href="#topic+sparsebnPath">sparsebnPath</a></code> objects in the global environment will be coerced to be compatible with the selected package. This will overwrite your existing data.</p>
</td></tr>
<tr><td><code id="resetGraphPackage_+3A_pkg">pkg</code></td>
<td>
<p>The desired package; default value is <code>NULL</code> corresponding to <a href="#topic+edgeList">edgeList</a>. Possible values are <code>"sparsebn"</code>, <code>"igraph"</code>, <code>"graph"</code>, <code>"bnlearn"</code>, and <code>"network"</code>.</p>
</td></tr>
<tr><td><code id="resetGraphPackage_+3A_matchplot">matchPlot</code></td>
<td>
<p>Force the underlying plotting mechanism to match the selected package (see <a href="#topic+setPlotPackage">setPlotPackage</a>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sparsebn</code> is compatible with four different data structures for representing graphs:
<a href="#topic+edgeList">edgeList</a> (default), <a href="graph.html#topic+graphNEL-class">graphNEL-class</a> (from the <code>graph</code> package),
<a href="igraph.html#topic+igraph">igraph</a> (from the <a href="igraph.html#topic+igraph">igraph</a> package), and <a href="network.html#topic+network">network</a> (from
<a href="network.html#topic+network-package">network-package</a>). <a href="#topic+edgeList">edgeList</a> is provided by default in <code>sparsebn</code>, however,
the other three options require that extra packages are installed.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>resetGraphPackage</code>: Reset all data to default <code><a href="#topic+edgeList">edgeList</a></code> format and set graph package back to default <code>"sparsebn"</code>.
</p>
</li>
<li> <p><code>getGraphPackage</code>: Returns the current choice of graph package ( <code>NULL</code> corresponds to no selection)
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+setPlotPackage">setPlotPackage</a></code>, <code><a href="#topic+getPlotPackage">getPlotPackage</a></code>
</p>

<hr>
<h2 id='select'>Select solutions from a solution path</h2><span id='topic+select'></span>

<h3>Description</h3>

<p>Choose solutions from a solution path based on number of edges, value of
regularization parameter lambda, or index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select(x, edges, lambda, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+sparsebnPath">sparsebnPath</a></code> object.</p>
</td></tr>
<tr><td><code id="select_+3A_edges">edges</code></td>
<td>
<p>number of edges to search for.</p>
</td></tr>
<tr><td><code id="select_+3A_lambda">lambda</code></td>
<td>
<p>value of regularization parameter to search for.</p>
</td></tr>
<tr><td><code id="select_+3A_index">index</code></td>
<td>
<p>integer index to select.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>edges</code> (resp. <code>lambda</code>), the solution with the closest number
of edges (resp. regularization parameter) is returned. If there is no match
within a tolerance of 0.1 for <code>lambda</code>, nothing is returned. Fuzzy matching
is not used for when selecting by <code>index</code>.
</p>
<p>If there is more than one match (for example, by number of edges), then
the first such estimate is returned. Note that <code>select(x, index = j)</code>
is equivalent to (but slightly slower than) <code>x[[j]]</code>.
</p>

<hr>
<h2 id='select.parameter'>Tuning parameter selection</h2><span id='topic+select.parameter'></span>

<h3>Description</h3>

<p>Choose the best DAG model according to the criterion described in <a href="http://www.stat.ucla.edu/~zhou/publications/Fu13-JASA.pdf">Fu and Zhou (2013)</a>
(Section 3.4).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select.parameter(x, data, type = "profile", alpha = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select.parameter_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+sparsebnPath">sparsebnPath</a></code> object.</p>
</td></tr>
<tr><td><code id="select.parameter_+3A_data">data</code></td>
<td>
<p><code><a href="#topic+sparsebnData">sparsebnData</a></code> containing the original data.</p>
</td></tr>
<tr><td><code id="select.parameter_+3A_type">type</code></td>
<td>
<p>either &quot;<code>profile</code>&quot; or &quot;<code>full</code>&quot;, default is <code>profile</code>.</p>
</td></tr>
<tr><td><code id="select.parameter_+3A_alpha">alpha</code></td>
<td>
<p>tuning parameter for selection between 0.05 and 0.1, default is 0.5 (see equation (11) in <a href="http://www.stat.ucla.edu/~zhou/publications/Fu13-JASA.pdf">Fu and Zhou (2013)</a>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code><a href="#topic+sparsebnPath">sparsebnPath</a></code> objects represents a <em>solution path</em> which depends on the regularization parameter lambda.
Model selection is usually based on an estimated prediction error, and commonly used model selection
methods include the Bayesian information criterion (BIC) and cross-validation (CV) among others. It
is well-known that these criteria tend to produce overly complex models in practice, so instead we
employ an empirical model selection criterion that works well in practice. As lambda is decreased and
thus the model complexity increases, the log-likelihood of the estimated graph will increase. An
increase in model complexity, which is represented by an increase in the total number of predicted
edges, is desirable only if there is a substantial increase in the log-likelihood. In order to select
an optimal parameter, this method computes successive difference ratios between the increase in
log-likelihood and the increase in number of edges and balances these quantities appropriately. For
specific details, please see Section 3.4 in <a href="http://www.stat.ucla.edu/~zhou/publications/Fu13-JASA.pdf">Fu and Zhou (2013)</a>.
</p>

<hr>
<h2 id='setPlotPackage'>Change default plotting mechanism</h2><span id='topic+setPlotPackage'></span><span id='topic+getPlotPackage'></span>

<h3>Description</h3>

<p>Changes the default plotting mechanism used by <code>sparsebn</code> to plot output and fitted objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPlotPackage(pkg)

getPlotPackage()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setPlotPackage_+3A_pkg">pkg</code></td>
<td>
<p>The desired package; default value is <code>igraph</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For plotting, <code>sparsebn</code> can use one of three packages: <code>graph</code> (see also <code>Rgraphviz</code>),
<a href="igraph.html#topic+igraph">igraph</a> (see <a href="igraph.html#topic+plot.igraph">plot.igraph</a>), and <a href="network.html#topic+network-package">network-package</a> (see <a href="network.html#topic+plot.network">plot.network</a>).
Note that plotting requires that (at least one of) these extra packages are installed.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getPlotPackage</code>: Returns the current choice of plotting mechanism
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+setGraphPackage">setGraphPackage</a></code>, <code><a href="#topic+getGraphPackage">getGraphPackage</a></code>
</p>

<hr>
<h2 id='show.parents'>Inspect subgraph</h2><span id='topic+show.parents'></span>

<h3>Description</h3>

<p>Print out the edge list corresponding to a subset of nodes in a graph. Useful
for inspecting particular nodes of interest in a large graph. Out is indexed
by children, with the parents of each node listed to the right of each child.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show.parents(x, nodes, nchar = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show.parents_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+sparsebnFit">sparsebnFit</a></code> object.</p>
</td></tr>
<tr><td><code id="show.parents_+3A_nodes">nodes</code></td>
<td>
<p><code>character</code> vector containing names of nodes to show.</p>
</td></tr>
<tr><td><code id="show.parents_+3A_nchar">nchar</code></td>
<td>
<p><code>integer</code> indicating how many characters of each parent to show in
printed output. Use this to control how the output appears on screen, larger
numbers allow for longer node names but may present formatting issues for
large graphs. Defaults to 4.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses partial matching, duplicates are OK and will be duplicated in output.
</p>

<hr>
<h2 id='sparse'>sparse class</h2><span id='topic+sparse'></span><span id='topic+is.sparse'></span>

<h3>Description</h3>

<p>Low-level representation of sparse matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse(x, ...)

is.sparse(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparse_+3A_x">x</code></td>
<td>
<p>Various <code>R</code> objects.</p>
</td></tr>
<tr><td><code id="sparse_+3A_...">...</code></td>
<td>
<p>(optional) additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An alternative data structure for storing sparse matrices in R using the (row, column, value)
format. Internally it is stored as a list with three components, each vectors, that contain
the rows / columns / values of the nonzero elements.
</p>

<hr>
<h2 id='sparsebn-messages'>Messages</h2><span id='topic+sparsebn-messages'></span><span id='topic+input_not_sparsebnData'></span><span id='topic+alg_input_data_frame'></span><span id='topic+has_missing_values'></span><span id='topic+invalid_pkg_specification'></span><span id='topic+pkg_not_installed'></span><span id='topic+global_coerce_warning'></span><span id='topic+feature_not_supported'></span><span id='topic+invalid_class'></span><span id='topic+dag_summary'></span><span id='topic+empty_dag_summary'></span><span id='topic+data_not_numeric'></span><span id='topic+invalid_type_input'></span>

<h3>Description</h3>

<p>Warning and error messages for use in the <code>sparsebn</code> family
</p>


<h3>Usage</h3>

<pre><code class='language-R'>input_not_sparsebnData(data)

alg_input_data_frame()

has_missing_values(count)

invalid_pkg_specification()

pkg_not_installed(pkg)

global_coerce_warning(pkg)

feature_not_supported(feature)

invalid_class(actual, expected)

dag_summary(nnode, nedge)

empty_dag_summary(nnode)

data_not_numeric(indices)

invalid_type_input(types)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparsebn-messages_+3A_data">data</code></td>
<td>
<p>data object.</p>
</td></tr>
<tr><td><code id="sparsebn-messages_+3A_count">count</code></td>
<td>
<p>number of missing values.</p>
</td></tr>
<tr><td><code id="sparsebn-messages_+3A_pkg">pkg</code></td>
<td>
<p>package name.</p>
</td></tr>
<tr><td><code id="sparsebn-messages_+3A_feature">feature</code></td>
<td>
<p>feature name.</p>
</td></tr>
<tr><td><code id="sparsebn-messages_+3A_actual">actual</code></td>
<td>
<p>class input by user.</p>
</td></tr>
<tr><td><code id="sparsebn-messages_+3A_expected">expected</code></td>
<td>
<p>class input expected by function.</p>
</td></tr>
<tr><td><code id="sparsebn-messages_+3A_nnode">nnode</code></td>
<td>
<p>number of nodes in a DAG.</p>
</td></tr>
<tr><td><code id="sparsebn-messages_+3A_nedge">nedge</code></td>
<td>
<p>number of edges in a DAG.</p>
</td></tr>
<tr><td><code id="sparsebn-messages_+3A_indices">indices</code></td>
<td>
<p>invalid indices</p>
</td></tr>
<tr><td><code id="sparsebn-messages_+3A_types">types</code></td>
<td>
<p>valid input types</p>
</td></tr>
</table>

<hr>
<h2 id='sparsebnData'>sparsebnData class</h2><span id='topic+sparsebnData'></span><span id='topic+is.sparsebnData'></span><span id='topic+sparsebnData.data.frame'></span><span id='topic+sparsebnData.matrix'></span><span id='topic+print.sparsebnData'></span><span id='topic+summary.sparsebnData'></span><span id='topic+plot.sparsebnData'></span>

<h3>Description</h3>

<p>This class stores data that may contain interventions on some or all of the
observations. It also allows for the degenerate case with no interventions,
i.e. purely observational data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsebnData(x, ...)

is.sparsebnData(x)

## S3 method for class 'data.frame'
sparsebnData(x, type, levels = NULL, ivn = NULL, ...)

## S3 method for class 'matrix'
sparsebnData(x, type, levels = NULL, ivn = NULL, ...)

## S3 method for class 'sparsebnData'
print(x, n = 5L, ...)

## S3 method for class 'sparsebnData'
summary(object, n = 5L, ...)

## S3 method for class 'sparsebnData'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparsebnData_+3A_x">x</code></td>
<td>
<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> or <code><a href="base.html#topic+matrix">matrix</a></code> object.</p>
</td></tr>
<tr><td><code id="sparsebnData_+3A_...">...</code></td>
<td>
<p>(optional) additional arguments.</p>
</td></tr>
<tr><td><code id="sparsebnData_+3A_type">type</code></td>
<td>
<p>either '<code>discrete</code>' or '<code>continuous</code>'.</p>
</td></tr>
<tr><td><code id="sparsebnData_+3A_levels">levels</code></td>
<td>
<p>(optional) <code><a href="base.html#topic+list">list</a></code> of levels for each node. If omitted, levels will be automatically
detected from <code><a href="base.html#topic+unique">unique</a></code>.</p>
</td></tr>
<tr><td><code id="sparsebnData_+3A_ivn">ivn</code></td>
<td>
<p>(optional) <code><a href="base.html#topic+list">list</a></code> of interventions for each observation. If omitted, data is assumed to be
purely observational.</p>
</td></tr>
<tr><td><code id="sparsebnData_+3A_n">n</code></td>
<td>
<p>(optional) number of rows from data matrix to print.</p>
</td></tr>
<tr><td><code id="sparsebnData_+3A_object">object</code></td>
<td>
<p>an object of type <code>sparsebnData</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The structure of a <code>sparsebnData</code> object is very simple: It contains a
<code>data.frame</code> object, a type identifier (i.e. discrete or continuous),
a list of factor levels, and a list of interventions.
</p>

<ul>
<li><p> The <code>levels</code> list should be the same size as the number of nodes
and consist of names of the different levels for each node. Each level should
be coded to be from 0...<code class="reqn">k</code>-1 where <code class="reqn">k</code> is the number of levels for a
particular variable (see below for more).
</p>
</li>
<li><p> The <code>ivn</code> list should be the same size as the number of rows in
the dataset, and each component indicates which column(s) in the dataset is
(are) under intervention. If an observation has no interventions, then the
corresponding component is <code>NULL</code>. Thus, if the data is purely
observational, this list should contain only <code>NULL</code> values.
</p>
</li></ul>

<p>Presently, only levels coded as 0,1,...,<code class="reqn">k</code>-1 are supported (<code class="reqn">k</code> = the number of levels for a
variable). Future releases are planned to support more general factor levels. The level 0 corresponds
to the baseline level or measurement.
</p>
<p>Also inherits from <code><a href="base.html#topic+list">list</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>(<code><a href="base.html#topic+data.frame">data.frame</a></code>) Dataset.</p>
</dd>
<dt><code>type</code></dt><dd><p>(<code><a href="base.html#topic+character">character</a></code>) Type of data: Either &quot;continuous&quot;, &quot;discrete&quot;, or &quot;mixed&quot;.</p>
</dd>
<dt><code>levels</code></dt><dd><p>(<code><a href="base.html#topic+list">list</a></code>) List of levels for each column in <code>data</code>.</p>
</dd>
<dt><code>ivn</code></dt><dd><p>(<code><a href="base.html#topic+list">list</a></code>) List of columns under intervention for each row in <code>data</code>.</p>
</dd>
</dl>



<h3>Methods</h3>

<p><code><a href="base.html#topic+print">print</a></code>
<code><a href="#topic+num.samples">num.samples</a></code>
<code><a href="#topic+is.obs">is.obs</a></code>
<code><a href="#topic+count.levels">count.levels</a></code>
<code><a href="#topic+count.interventions">count.interventions</a></code>
<code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Generate a random continuous dataset
mat &lt;- matrix(rnorm(1000), nrow = 20)
dat &lt;- sparsebnData(mat, type = "continuous") # purely observational data with continuous variables

### Discrete data
mat &lt;- rbind(c(0,2,0),
             c(1,1,0),
             c(1,0,3),
             c(0,1,0))
dat.levels &lt;- list(c(0,1), c(0,1,2), c(0,1,2,3))
dat &lt;- sparsebnData(mat,
                    type = "discrete",
                    levels = dat.levels) # purely observational data with discrete variables

dat.ivn &lt;- list(c(1),   # first observation was intervened at node 1
                c(1),   # second observation was intervened at node 1
                c(2,3), # third observation was intervened at nodes 2 and 3
                c(1,3)) # fourth observation was intervened at nodes 1 and 3
dat &lt;- sparsebnData(mat,
                    type = "discrete",
                    levels = dat.levels,
                    ivn = dat.ivn) # specify intervention rows

</code></pre>

<hr>
<h2 id='sparsebnFit'>sparsebnFit class</h2><span id='topic+sparsebnFit'></span><span id='topic+is.sparsebnFit'></span><span id='topic+print.sparsebnFit'></span><span id='topic+summary.sparsebnFit'></span><span id='topic+plot.sparsebnFit'></span>

<h3>Description</h3>

<p>Main class for representing DAG estimates. Represents a single DAG estimate in a solution path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsebnFit(x)

is.sparsebnFit(x)

## S3 method for class 'sparsebnFit'
print(x, maxsize = 20, ...)

## S3 method for class 'sparsebnFit'
summary(object, ...)

## S3 method for class 'sparsebnFit'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparsebnFit_+3A_x">x</code></td>
<td>
<p>A <code>list</code> or an object of type <code>sparsebnFit</code>. Should only be used internally.</p>
</td></tr>
<tr><td><code id="sparsebnFit_+3A_maxsize">maxsize</code></td>
<td>
<p>If the number of nodes in a graph is <code class="reqn">\le</code> <code>maxsize</code>, then the entire
graph is printed to screen, otherwise a short summary is displayed instead.</p>
</td></tr>
<tr><td><code id="sparsebnFit_+3A_...">...</code></td>
<td>
<p>(optional) additional arguments.</p>
</td></tr>
<tr><td><code id="sparsebnFit_+3A_object">object</code></td>
<td>
<p>an object of type <code>sparsebnFit</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main class for storing and manipulating the output of <code><a href="sparsebn.html#topic+estimate.dag">estimate.dag</a></code>.
The main slot of interest is <code>edges</code>, which stores the graph as an <code><a href="#topic+edgeList">edgeList</a></code>
object. If desired, this slot can be changed to hold a <code><a href="graph.html#topic+graphNEL">graphNEL</a></code>,
<code><a href="igraph.html#topic+igraph">igraph</a></code>, or <code><a href="network.html#topic+network">network</a></code> object if desired (see
<code><a href="#topic+setGraphPackage">setGraphPackage</a></code>). For anything beyond simply inspecting the graph, it is recommended
to use one of these packages.
</p>
<p>Since <code>edgeList</code>s do not contain information on the node names, the second slot
<code>nodes</code> stores this information. The indices in <code>edges</code> are in one-to-one
correspondence with the names in the <code>nodes</code> vector. The <code>lambda</code> slot stores
the regularization parameter used to estimate the graph.
</p>
<p>Other slots include <code>nedge</code>, for the number of edges; <code>pp</code>, for p = number of nodes;
<code>nn</code>, for n = number of samples, and <code>time</code>, for the time in seconds needed to
estimate this graph. Note that these slots are mainly for internal use, and in particular
it is best to query the number of nodes via <code><a href="#topic+num.nodes">num.nodes</a></code>, the number of edges
via <code><a href="#topic+num.edges">num.edges</a></code>, and the number of samples via <code><a href="#topic+num.samples">num.samples</a></code>.
</p>
<p>By default, only small graphs are printed, but this behaviour can be overridden via the
<code>maxsize</code> argument to <code>print</code>. To view a list of parents for a specific subset of
nodes, use <code><a href="#topic+show.parents">show.parents</a></code>.
</p>
<p>Generally speaking, it should not be necessary to construct a <code>sparsebnFit</code> object
manually. Furthermore, these estimates should always be wrapped up in a <code><a href="#topic+sparsebnPath">sparsebnPath</a></code>
object, but can be handled separately if desired (be careful!).
</p>


<h3>Slots</h3>


<dl>
<dt><code>edges</code></dt><dd><p>(<code><a href="#topic+edgeList">edgeList</a></code>) Edge list of estimated DAG (see <code><a href="#topic+edgeList">edgeList</a></code>).</p>
</dd>
<dt><code>nodes</code></dt><dd><p>(<code><a href="base.html#topic+character">character</a></code>) Vector of node names.</p>
</dd>
<dt><code>lambda</code></dt><dd><p>(<code><a href="base.html#topic+numeric">numeric</a></code>) Value of lambda for this estimate.</p>
</dd>
<dt><code>nedge</code></dt><dd><p>(<code><a href="base.html#topic+integer">integer</a></code>) Number of edges in this estimate.</p>
</dd>
<dt><code>pp</code></dt><dd><p>(<code><a href="base.html#topic+integer">integer</a></code>) Number of nodes.</p>
</dd>
<dt><code>nn</code></dt><dd><p>(<code><a href="base.html#topic+integer">integer</a></code>) Number of observations this estimate was based on.</p>
</dd>
<dt><code>time</code></dt><dd><p>(<code><a href="base.html#topic+numeric">numeric</a></code>) Time in seconds to generate this estimate.</p>
</dd>
</dl>



<h3>Methods</h3>

<p><code><a href="#topic+get.adjacency.matrix">get.adjacency.matrix</a></code>,
<code><a href="#topic+num.nodes">num.nodes</a></code>,
<code><a href="#topic+num.edges">num.edges</a></code>,
<code><a href="#topic+num.samples">num.samples</a></code>,
<code><a href="#topic+show.parents">show.parents</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
### Learn the cytometry network
library(sparsebn)
data(cytometryContinuous) # from the sparsebn package
cyto.data &lt;- sparsebnData(cytometryContinuous[["data"]], type = "continuous")
cyto.learn &lt;- estimate.dag(cyto.data)

### Inspect the output
class(cyto.learn[[1]])
print(cyto.learn[[2]])
show.parents(cyto.learn[[1]], c("raf", "mek", "plc"))

### Manipulate a particular graph
cyto.fit &lt;- cyto.learn[[7]]
num.nodes(cyto.fit)
num.edges(cyto.fit)
show.parents(cyto.fit, c("raf", "mek", "plc"))
plot(cyto.fit)

### Use graph package instead of edgeLists
setGraphPackage("graph", coerce = TRUE) # set sparsebn to use graph package
cyto.edges &lt;- cyto.fit$edges
degree(cyto.edges)       # only available with graph package
isConnected(cyto.edges)  # only available with graph package

## End(Not run)

</code></pre>

<hr>
<h2 id='sparsebnPath'>sparsebnPath class</h2><span id='topic+sparsebnPath'></span><span id='topic+is.sparsebnPath'></span><span id='topic+print.sparsebnPath'></span><span id='topic+summary.sparsebnPath'></span><span id='topic+plot.sparsebnPath'></span>

<h3>Description</h3>

<p>Convenience wrapper class for solution paths of DAG learning algorithms: This class represents an entire
solution path of an algorithm. Its components are of type <code><a href="#topic+sparsebnFit">sparsebnFit</a></code>. Also inherits
from <code><a href="base.html#topic+list">list</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsebnPath(x)

is.sparsebnPath(x)

## S3 method for class 'sparsebnPath'
print(x, verbose = FALSE, ...)

## S3 method for class 'sparsebnPath'
summary(object, ...)

## S3 method for class 'sparsebnPath'
plot(x, labels = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparsebnPath_+3A_x">x</code></td>
<td>
<p>A <code>list</code> or an object of type <code>sparsebnPath</code>. Should only be used internally.</p>
</td></tr>
<tr><td><code id="sparsebnPath_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, then each estimate in the solution path is printed separately. Do not use for
large graphs or large solution paths. (default = <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="sparsebnPath_+3A_...">...</code></td>
<td>
<p>(optional) additional arguments.</p>
</td></tr>
<tr><td><code id="sparsebnPath_+3A_object">object</code></td>
<td>
<p>an object of type <code>sparsebnPath</code></p>
</td></tr>
<tr><td><code id="sparsebnPath_+3A_labels">labels</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. Whether or not to print out
labels with summary information for each plot in the solution path.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each value of lambda in the (discrete) solution path corresponds to a single DAG estimate (see <a href="https://jmlr.org/papers/v16/aragam15a.html">Aragam and Zhou (2015)</a> for details).
Internally, this estimate is represented by a <code><a href="#topic+sparsebnFit">sparsebnFit</a></code> object. The full solution
path is then represented as a <code><a href="base.html#topic+list">list</a></code> of <code><a href="#topic+sparsebnFit">sparsebnFit</a></code> objects: This class is essentially a wrapper for this list.
</p>
<p>Most methods for <code><a href="#topic+sparsebnPath">sparsebnPath</a></code> objects simply apply <code><a href="base.html#topic+lapply">lapply</a></code> to the
object in question. The exceptions to this rule apply when the output will always be the same
for every component; e.g. <code><a href="#topic+num.nodes">num.nodes</a></code> and <code><a href="#topic+num.samples">num.samples</a></code>.
</p>


<h3>Methods</h3>

<p><code><a href="#topic+get.adjacency.matrix">get.adjacency.matrix</a></code>, <code><a href="#topic+get.lambdas">get.lambdas</a></code>,
<code><a href="#topic+num.nodes">num.nodes</a></code>, <code><a href="#topic+num.edges">num.edges</a></code>, <code><a href="#topic+num.samples">num.samples</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
### Learn the cytometry network
library(sparsebn)
data(cytometryContinuous) # from the sparsebn package
cyto.data &lt;- sparsebnData(cytometryContinuous[["data"]], type = "continuous")
cyto.learn &lt;- estimate.dag(cyto.data)

### Inspect the output
class(cyto.learn)
print(cyto.learn)
plot(cyto.learn)

## End(Not run)

</code></pre>

<hr>
<h2 id='sparsebnUtils'>sparsebnUtils: Utilities for the sparsebn package.</h2><span id='topic+sparsebnUtils'></span>

<h3>Description</h3>

<p>A set of tools for representing and estimating sparse Bayesian
networks from continuous and discrete data.
</p>


<h3>Details</h3>

<p>This package provides various S3 classes for making it easy to estimate
graphical models from data:
</p>

<ul>
<li> <p><code><a href="#topic+sparsebnData">sparsebnData</a></code> for managing experimental data with interventions.
</p>
</li>
<li> <p><code><a href="#topic+sparsebnFit">sparsebnFit</a></code> for representing the output of a DAG learning algorithm.
</p>
</li>
<li> <p><code><a href="#topic+sparsebnPath">sparsebnPath</a></code> for representing a solution path of estimates.
</p>
</li></ul>

<p>The package also provides methods for manipulating these objects and for estimating
parameters in graphical models:
</p>

<ul>
<li> <p><code><a href="#topic+estimate.parameters">estimate.parameters</a></code> for directed graphs.
</p>
</li>
<li> <p><code><a href="#topic+get.precision">get.precision</a></code> for undirected graphs.
</p>
</li>
<li> <p><code><a href="#topic+get.covariance">get.covariance</a></code> for covariance matrices.
</p>
</li></ul>

<p>Internally, all graph objects may be stored as <code><a href="#topic+edgeList">edgeList</a>s</code> (default),
or using <code>graphNEL</code>, <code>igraph</code>, <code>bnlearn</code>, or <code>network</code> objects.
</p>

<hr>
<h2 id='specify.prior'>Build a black list based on prior knowledge</h2><span id='topic+specify.prior'></span>

<h3>Description</h3>

<p>Utility for specifying known root and leaf nodes in a network, to be used
in conjunction with the <code>blacklist</code> argument of network estimation
methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specify.prior(roots = NULL, leaves = NULL, nodes, indices = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specify.prior_+3A_roots">roots</code></td>
<td>
<p>Vector of root nodes. May be character or integer.</p>
</td></tr>
<tr><td><code id="specify.prior_+3A_leaves">leaves</code></td>
<td>
<p>Vector of leaf nodes. May be character or integer.</p>
</td></tr>
<tr><td><code id="specify.prior_+3A_nodes">nodes</code></td>
<td>
<p>Full vector of node names of the entire network. Both
<code>roots</code> and <code>leaves</code> must be a subset of this vector.</p>
</td></tr>
<tr><td><code id="specify.prior_+3A_indices">indices</code></td>
<td>
<p>Logical: Return indices or character names?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Builds an (m+k)x2 matrix, where m is the number of user-specified root
nodes and k is the number of user-specified leaf nodes.
</p>

<ul>
<li><p> A <em>root</em> node is any node without any parents, i.e. with no
incoming edges.
</p>
</li>
<li><p> A <em>leaf</em> node is any node without any children, i.e. with no
outgoing edges.
</p>
</li></ul>


<hr>
<h2 id='to_bn'>Conversion between graph types</h2><span id='topic+to_bn'></span><span id='topic+to_graphNEL'></span><span id='topic+to_igraph'></span><span id='topic+to_network'></span><span id='topic+sparsebn-compat'></span>

<h3>Description</h3>

<p>These methods convert graph objects (e.g. <code><a href="#topic+edgeList">edgeList</a></code>)
and objects containing graph data (e.g. <code><a href="#topic+sparsebnFit">sparsebnFit</a></code>,
<code><a href="#topic+sparsebnPath">sparsebnPath</a></code>) to other formats including <code><a href="igraph.html#topic+igraph">igraph</a></code>,
<code><a href="graph.html#topic+graphNEL">graphNEL</a></code>, <code><a href="network.html#topic+network">network</a></code>, and
<code><a href="bnlearn.html#topic+bn-class">bn-class</a></code>.
</p>
<p>Only graph objects are modified with these methods. For example, if the input
is either <code><a href="#topic+sparsebnFit">sparsebnFit</a></code> or <code><a href="#topic+sparsebnPath">sparsebnPath</a></code>,
the output will still be a <code><a href="#topic+sparsebnFit">sparsebnFit</a></code> or <code><a href="#topic+sparsebnPath">sparsebnPath</a></code>
object. Only the <code>edges</code> slots will be converted to a different graph type.
This will be the case for the default output from <code><a href="sparsebn.html#topic+estimate.dag">estimate.dag</a></code>,
so that metadata from the learning phase is not lost during conversion.
If, on the other hand, the input is already an <code><a href="#topic+edgeList">edgeList</a></code>, then the
output will directly be a graph object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_bn(x)

to_graphNEL(x)

to_igraph(x)

to_network(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_bn_+3A_x">x</code></td>
<td>
<p>An object of type <code><a href="#topic+sparsebnPath">sparsebnPath</a></code>, <code><a href="#topic+sparsebnFit">sparsebnFit</a></code>,
<code><a href="#topic+edgeList">edgeList</a></code>, <code><a href="igraph.html#topic+igraph">igraph</a></code>, <code><a href="graph.html#topic+graphNEL">graphNEL</a></code>,
<code><a href="network.html#topic+network">network</a></code>, or <code><a href="bnlearn.html#topic+bn-class">bn-class</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>to_igraph</code> converts sparsebn objects to <code><a href="igraph.html#topic+igraph">igraph</a></code>-compatible
objects.
</p>
<p><code>to_graph</code> converts sparsebn objects to <code><a href="graph.html#topic+graphNEL">graphNEL</a></code>-compatible
objects.
</p>
<p><code>to_network</code> converts sparsebn objects to <code><a href="network.html#topic+network">network</a></code>-compatible
objects.
</p>
<p><code>to_bn</code> converts sparsebn objects to <code><a href="bnlearn.html#topic+bn-class">bn-class</a></code>-compatible
objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Learn the cytometry network
library(sparsebn)
data(cytometryContinuous)
cyto.data &lt;- sparsebnData(cytometryContinuous[["data"]],
                          type = "continuous",
                          ivn = cytometryContinuous[["ivn"]])
cyto.learn &lt;- estimate.dag(data = cyto.data)

### The output is a sparsebnPath object, which is a list of sparsebnFit objects
class(cyto.learn)
class(cyto.learn[[1]])

### Convert to igraph
cyto.igraph &lt;- to_igraph(cyto.learn)
class(cyto.igraph)       # not an igraph object!
class(cyto.igraph[[1]]$edges) # the graph data in the 'edges' slot is converted to igraph
gr &lt;- cyto.igraph[[1]]$edges

### Different behaviour when input is already an edgeList
edgeL &lt;- cyto.learn[[1]]$edges
gr &lt;- to_igraph(edgeL) # input is edgeList, not sparsebnFit or sparsebnPath
class(gr)              # igraph object

## End(Not run)

</code></pre>

<hr>
<h2 id='to_edgeList'>Conversion to edgeList object</h2><span id='topic+to_edgeList'></span><span id='topic+to_edgeList.sparsebnFit'></span>

<h3>Description</h3>

<p><code>to_edgeList</code> converts an object to an <code><a href="#topic+edgeList">edgeList</a></code> object. Works on both fitted
objects and graphs themselves. In the first case, every underlying 'edges' component is converted to
<code><a href="#topic+edgeList">edgeList</a></code>. In the second, the conversion applies directly to the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_edgeList(x)

## S3 method for class 'sparsebnFit'
to_edgeList(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_edgeList_+3A_x">x</code></td>
<td>
<p>An object of type <code><a href="#topic+sparsebnPath">sparsebnPath</a></code>, <code><a href="#topic+sparsebnFit">sparsebnFit</a></code>, <code><a href="graph.html#topic+graphNEL-class">graphNEL-class</a></code>,
<code><a href="igraph.html#topic+igraph">igraph</a></code>, or <code><a href="network.html#topic+network">network</a></code>.</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>sparsebnFit</code>: description
</p>
</li></ul>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
