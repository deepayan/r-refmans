<!DOCTYPE html><html><head><title>Help for package rock</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rock}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_html_tags'><p>Add HTML tags to a source</p></a></li>
<li><a href='#apply_graph_theme'><p>Apply multiple DiagrammeR global graph attributes</p></a></li>
<li><a href='#base30toNumeric'><p>Conversion between base10 and base30</p></a></li>
<li><a href='#cat0'><p>Concatenate to screen without spaces</p></a></li>
<li><a href='#checkPkgs'><p>Check for presence of a package</p></a></li>
<li><a href='#ci_get_item'><p>Get an item in a specific language</p></a></li>
<li><a href='#ci_heatmap'><p>Create a heatmap showing issues with items</p></a></li>
<li><a href='#ci_import_nrm_spec'><p>Import a Narrative Response Model specification</p></a></li>
<li><a href='#clean_source'><p>Cleaning &amp; editing sources</p></a></li>
<li><a href='#cleaned_source_to_utterance_vector'><p>Convert a character vector into an utterance vector</p></a></li>
<li><a href='#code_freq_hist'><p>Create a frequency histogram for codes</p></a></li>
<li><a href='#code_source'><p>Add one or more codes to one or more sources</p></a></li>
<li><a href='#codebook_fromSpreadsheet'><p>Import a code book specification from a spreadsheet</p></a></li>
<li><a href='#codebook_to_pdf'><p>Convert a codebook specification to PDF</p></a></li>
<li><a href='#codeIds_to_codePaths'><p>Replace code identifiers with their full paths</p></a></li>
<li><a href='#codePaths_to_namedVector'><p>Get a vector to find the full paths based on the leaf code identifier</p></a></li>
<li><a href='#codingSchemes_get_all'><p>Convenience function to get a list of all available coding schemes</p></a></li>
<li><a href='#collapse_occurrences'><p>Collapse the occurrences in utterances into groups</p></a></li>
<li><a href='#collect_coded_fragments'><p>Create an overview of coded fragments</p></a></li>
<li><a href='#compress_with_sum'><p>Vector compression helper functions</p></a></li>
<li><a href='#convert_df_to_source'><p>Convert 'rectangular' or spreadsheet-format data to one or more sources</p></a></li>
<li><a href='#convertToNumeric'><p>Conveniently convert vectors to numeric</p></a></li>
<li><a href='#create_codingScheme'><p>Create a coding scheme</p></a></li>
<li><a href='#create_cooccurrence_matrix'><p>Create a co-occurrence matrix</p></a></li>
<li><a href='#css'><p>Create HTML fragment with CSS styling</p></a></li>
<li><a href='#doc_to_txt'><p>Convert a document (.docx, .pdf, .odt, .rtf, or .html) to a plain text file</p></a></li>
<li><a href='#exampleCodebook_1'><p>An very rudimentary example codebook specification</p></a></li>
<li><a href='#expand_attributes'><p>Expand categorical attribute variables to a series of dichotomous variables</p></a></li>
<li><a href='#export_codes_to_txt'><p>Export codes to a plain text file</p></a></li>
<li><a href='#export_mergedSourceDf_to_csv'><p>Export a merged source data frame</p></a></li>
<li><a href='#export_to_html'><p>Export parsed sources to HTML or Markdown</p></a></li>
<li><a href='#exportToHTML'><p>Exporting tables to HTML</p></a></li>
<li><a href='#extract_codings_by_coderId'><p>Extract the codings by each coder using the coderId</p></a></li>
<li><a href='#form_to_rmd_template'><p>Convert a (pre)registration form to an R Markdown template</p></a></li>
<li><a href='#generate_uids'><p>Generate utterance identifiers (UIDs)</p></a></li>
<li><a href='#generic_recoding'><p>Generic underlying recoding function</p></a></li>
<li><a href='#get_childCodeIds'><p>Get the code identifiers a code's descendents</p></a></li>
<li><a href='#get_dataframe_from_nested_list'><p>Return all values from a nested list in a dataframe</p></a></li>
<li><a href='#get_source_filter'><p>Create a filter to select utterances in a source</p></a></li>
<li><a href='#get_state_transition_df'><p>Get the state transition data frame</p></a></li>
<li><a href='#get_state_transition_dot'><p>Get the state transition data frame</p></a></li>
<li><a href='#get_state_transition_table'><p>Get the state transition table</p></a></li>
<li><a href='#get_utterances_and_codes_from_source'><p>Get utterances and codes from source</p></a></li>
<li><a href='#get_vectors_from_nested_list'><p>Return one or more values from a nested list in a list of vectors</p></a></li>
<li><a href='#heading'><p>Print a heading</p></a></li>
<li><a href='#heatmap_basic'><p>Generic convenience function to create a heatmap</p></a></li>
<li><a href='#inspect_coded_sources'><p>Read sources from a directory, parse them, and show coded fragments and code tree</p></a></li>
<li><a href='#load_source'><p>Load a source from a file or a string</p></a></li>
<li><a href='#mask_source'><p>Masking sources</p></a></li>
<li><a href='#match_consecutive_delimiters'><p>Match the corresponding indices of (YAML) delimiters in a sequential list</p></a></li>
<li><a href='#merge_sources'><p>Merge source files by different coders</p></a></li>
<li><a href='#number_as_xl_date'><p>Convert a number to a date using Excel's system</p></a></li>
<li><a href='#opts'><p>Options for the rock package</p></a></li>
<li><a href='#parse_source'><p>Parsing sources</p></a></li>
<li><a href='#parse_source_by_coderId'><p>Parsing sources separately for each coder</p></a></li>
<li><a href='#parsed_sources_to_ena_network'><p>Create an ENA network out of one or more parsed sources</p></a></li>
<li><a href='#prepend_ids_to_source'><p>Prepending unique utterance identifiers</p></a></li>
<li><a href='#prereg_initialize'><p>Initialize a (pre)registration</p></a></li>
<li><a href='#print.rock_graphList'><p>Plot the graphs in a list of graphs</p></a></li>
<li><a href='#qna_to_tlm'><p>Convert a QNA network to Linear Topic Map format</p></a></li>
<li><a href='#rbind_df_list'><p>Bind lots of dataframes together rowwise</p></a></li>
<li><a href='#rbind_dfs'><p>Simple alternative for rbind.fill or bind_rows</p></a></li>
<li><a href='#read_spreadsheet'><p>Convenience function to read spreadsheet-like files</p></a></li>
<li><a href='#recode_addChildCodes'><p>Add child codes under a parent code</p></a></li>
<li><a href='#recode_delete'><p>Remove one or more codes</p></a></li>
<li><a href='#recode_merge'><p>Merge two or more codes</p></a></li>
<li><a href='#recode_move'><p>Move one or more codes to a different parent</p></a></li>
<li><a href='#recode_rename'><p>Rename one or more codes</p></a></li>
<li><a href='#recode_split'><p>Split a code into multiple codes</p></a></li>
<li><a href='#repeatStr'><p>Repeat a string a number of times</p></a></li>
<li><a href='#resultsOverview_allCodedFragments'><p>Show all coded fragments</p></a></li>
<li><a href='#rock'><p>rock: A Reproducible Open Coding Kit</p></a></li>
<li><a href='#root_from_codePaths'><p>Get the roots from a vector with code paths</p></a></li>
<li><a href='#rpe_create_source_with_items'><p>Create a source with items to code for Response Process Evaluation</p></a></li>
<li><a href='#save_workspace'><p>Save your justifications to a file</p></a></li>
<li><a href='#show_attribute_table'><p>Show a table with all attributes in the RStudio viewer and/or console</p></a></li>
<li><a href='#show_fullyMergedCodeTrees'><p>Show the fully merged code tree(s)</p></a></li>
<li><a href='#show_inductive_code_tree'><p>Show the inductive code tree(s)</p></a></li>
<li><a href='#split_long_lines'><p>Split long lines</p></a></li>
<li><a href='#stripCodePathRoot'><p>Strip the root from a code path</p></a></li>
<li><a href='#sync_streams'><p>Synchronize multiple streams</p></a></li>
<li><a href='#sync_vector'><p>Sync (expand or compress) a vector</p></a></li>
<li><a href='#syncing_df_compress'><p>Compress a vector or data frame</p></a></li>
<li><a href='#syncing_df_expand'><p>Expand a vector or data frame</p></a></li>
<li><a href='#template_ci_heatmap_1_to_pdf'><p>Create a templated report for cognitive interviews</p></a></li>
<li><a href='#template_codebook_to_pdf'><p>Convert a codebook specification to PDF</p></a></li>
<li><a href='#vecTxt'><p>Easily parse a vector into a character value</p></a></li>
<li><a href='#wrapVector'><p>Wrap all elements in a vector</p></a></li>
<li><a href='#write_source'><p>Write a source to a file</p></a></li>
<li><a href='#yaml_delimiter_indices'><p>Get indices of YAML delimiters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Reproducible Open Coding Kit</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-21</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gjalt-Jorn Peters &lt;rock@opens.science&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The Reproducible Open Coding Kit ('ROCK', and this package, 'rock')
  was developed to facilitate reproducible and open coding, specifically
  geared towards qualitative research methods. Although it is a
  general-purpose toolkit, three specific applications have been
  implemented, specifically an interface to the 'rENA' package that
  implements Epistemic Network Analysis ('ENA'), means to process notes
  from Cognitive Interviews ('CIs'), and means to work with decentralized
  construct taxonomies ('DCTs'). The 'ROCK' and this 'rock' package are described
  in the ROCK book <a href="https://rockbook.org">https://rockbook.org</a> and more information, such as tutorials,
  is available at <a href="https://rock.science">https://rock.science</a>.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.com/r-packages/rock/-/issues">https://gitlab.com/r-packages/rock/-/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rock.opens.science">https://rock.opens.science</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.tree (&ge; 1.1.0), dplyr (&ge; 0.7.8), DiagrammeR (&ge; 1.0.0),
DiagrammeRsvg (&ge; 0.1), ggplot2 (&ge; 3.2.0), glue (&ge; 1.3.0),
graphics (&ge; 3.0.0), htmltools (&ge; 0.5.0), markdown (&ge; 1.1),
purrr (&ge; 0.2.5), stats (&ge; 3.0.0), utils (&ge; 3.5.0), yaml (&ge;
2.2.0), yum (&ge; 0.1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, googlesheets4, haven (&ge; 2.4), justifier (&ge; 0.2),
knitr, limonaid, openxlsx (&ge; 4.2), pdftools, preregr (&ge;
0.1.9), readxl, rmarkdown, rvest, rstudioapi, striprtf,
testthat, writexl, XLConnect, xml2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-21 09:38:24 UTC; gjalt</td>
</tr>
<tr>
<td>Author:</td>
<td>Gjalt-Jorn Peters <a href="https://orcid.org/0000-0002-0336-9589"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Szilvia Zorgo <a href="https://orcid.org/0000-0002-6916-2097"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-21 15:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_html_tags'>Add HTML tags to a source</h2><span id='topic+add_html_tags'></span>

<h3>Description</h3>

<p>This function adds HTML tags to a source to allow pretty printing/viewing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_html_tags(
  x,
  context = NULL,
  codeClass = rock::opts$get(codeClass),
  codeValueClass = rock::opts$get(codeValueClass),
  idClass = rock::opts$get(idClass),
  sectionClass = rock::opts$get(sectionClass),
  uidClass = rock::opts$get(uidClass),
  contextClass = rock::opts$get(contextClass),
  utteranceClass = rock::opts$get(utteranceClass)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_html_tags_+3A_x">x</code></td>
<td>
<p>A character vector with the source</p>
</td></tr>
<tr><td><code id="add_html_tags_+3A_context">context</code></td>
<td>
<p>Optionally, lines to pass the contextClass</p>
</td></tr>
<tr><td><code id="add_html_tags_+3A_codeclass">codeClass</code>, <code id="add_html_tags_+3A_codevalueclass">codeValueClass</code>, <code id="add_html_tags_+3A_idclass">idClass</code>, <code id="add_html_tags_+3A_sectionclass">sectionClass</code>, <code id="add_html_tags_+3A_uidclass">uidClass</code>, <code id="add_html_tags_+3A_contextclass">contextClass</code>, <code id="add_html_tags_+3A_utteranceclass">utteranceClass</code></td>
<td>
<p>The classes to use for, respectively, codes, code values,
class instance identifiers (such as case
identifiers or coder identifiers), section breaks, utterance
identifiers, context, and full utterances. All <code style="white-space: pre;">&#8288;&lt;span&gt;&#8288;</code> elements except
for the full utterances, which are placed in <code style="white-space: pre;">&#8288;&lt;div&gt;&#8288;</code> elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The character vector with the replacements made.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Add tags to a mini example source
add_html_tags("[[cid=participant1]]
This is something this participant may have said.
Just like this. [[thisIsACode]]
---paragraph-break---
And another utterance.");
</code></pre>

<hr>
<h2 id='apply_graph_theme'>Apply multiple DiagrammeR global graph attributes</h2><span id='topic+apply_graph_theme'></span>

<h3>Description</h3>

<p>Apply multiple DiagrammeR global graph attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_graph_theme(graph, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_graph_theme_+3A_graph">graph</code></td>
<td>
<p>The <a href="DiagrammeR.html#topic+DiagrammeR">DiagrammeR::DiagrammeR</a> graph to apply the attributes to.</p>
</td></tr>
<tr><td><code id="apply_graph_theme_+3A_...">...</code></td>
<td>
<p>One or more character vectors of length three, where the first element is
the attribute, the second the value, and the third, the attribute type (<code>graph</code>,
<code>node</code>, or <code>edge</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <a href="DiagrammeR.html#topic+DiagrammeR">DiagrammeR::DiagrammeR</a> graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exampleSource &lt;- '
---
codes:
  -
    id: parentCode
    label: Parent code
    children:
      -
        id: childCode1
      -
        id: childCode2
  -
    id: childCode3
    label: Child Code
    parentId: parentCode
    children: [grandChild1, grandChild2]
---
';
parsedSource &lt;-
  parse_source(text=exampleSource);
miniGraph &lt;-
  apply_graph_theme(data.tree::ToDiagrammeRGraph(parsedSource$deductiveCodeTrees),
                    c("color", "#0000AA", "node"),
                    c("shape", "triangle", "node"),
                    c("fontcolor", "#FF0000", "node"));
### This line should be run when executing this example as test, because
### rendering a DiagrammeR graph takes quite long
## Not run: 
DiagrammeR::render_graph(miniGraph);

## End(Not run)
</code></pre>

<hr>
<h2 id='base30toNumeric'>Conversion between base10 and base30</h2><span id='topic+base30toNumeric'></span><span id='topic+base30conversion'></span><span id='topic+numericToBase30'></span>

<h3>Description</h3>

<p>The conversion functions from base10 to base30 and vice versa are
used by the <code><a href="#topic+generate_uids">generate_uids()</a></code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base30toNumeric(x)

numericToBase30(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base30toNumeric_+3A_x">x</code></td>
<td>
<p>The vector to convert (numeric for <code>numericToBase30</code>,
character for <code>base30toNumeric</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The symbols to represent the 'base 30' system are the 0-9
followed by the alphabet without vowels but including the y. This
vector is available as <code>base30</code>.
</p>


<h3>Value</h3>

<p>The converted vector (numeric for <code>base30toNumeric</code>, character for <code>numericToBase30</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>numericToBase30(654321);
base30toNumeric(numericToBase30(654321));
</code></pre>

<hr>
<h2 id='cat0'>Concatenate to screen without spaces</h2><span id='topic+cat0'></span>

<h3>Description</h3>

<p>The cat0 function is to cat what paste0 is to paste; it
simply makes concatenating many strings without a separator easier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat0(..., sep = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cat0_+3A_...">...</code></td>
<td>
<p>The character vector(s) to print; passed to <a href="base.html#topic+cat">cat</a>.</p>
</td></tr>
<tr><td><code id="cat0_+3A_sep">sep</code></td>
<td>
<p>The separator to pass to <a href="base.html#topic+cat">cat</a>, of course, <code>""</code> by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing (invisible <code>NULL</code>, like <a href="base.html#topic+cat">cat</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cat0("The first variable is '", names(mtcars)[1], "'.");
</code></pre>

<hr>
<h2 id='checkPkgs'>Check for presence of a package</h2><span id='topic+checkPkgs'></span>

<h3>Description</h3>

<p>This function efficiently checks for the presence of a package
without loading it (unlike <code><a href="base.html#topic+library">library()</a></code> or <code><a href="base.html#topic+require">require()</a></code>.
This is useful to force yourself to use the package::function
syntax for addressing functions; you can make sure required packages
are installed, but their namespace won't attach to the search path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkPkgs(
  ...,
  install = FALSE,
  load = FALSE,
  repos = "https://cran.rstudio.com"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkPkgs_+3A_...">...</code></td>
<td>
<p>A series of packages. If the packages are named, the
names are the package names, and the values are the minimum required
package versions (see the second example).</p>
</td></tr>
<tr><td><code id="checkPkgs_+3A_install">install</code></td>
<td>
<p>Whether to install missing packages from <code>repos</code>.</p>
</td></tr>
<tr><td><code id="checkPkgs_+3A_load">load</code></td>
<td>
<p>Whether to load packages (which is exactly <em>not</em> the point
of this function, but hey, YMMV).</p>
</td></tr>
<tr><td><code id="checkPkgs_+3A_repos">repos</code></td>
<td>
<p>The repository to use if installing packages; default
is the RStudio repository.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, a vector of the available packages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rock::checkPkgs('base');

### Require a version
rock::checkPkgs(rock = "0.5.0");

### This will show the error message
tryCatch(
  rock::checkPkgs(
    base = "99",
    stats = "42.5",
    ufs = 20
  ),
  error = print
);

</code></pre>

<hr>
<h2 id='ci_get_item'>Get an item in a specific language</h2><span id='topic+ci_get_item'></span>

<h3>Description</h3>

<p>This function takes a Narrative Response Model specification as used in
NRM-based cognitive interviews, and composes an item based on the
specified template for that item, the specified stimuli, and the
requested language.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_get_item(nrm_spec, item_id, language)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_get_item_+3A_nrm_spec">nrm_spec</code></td>
<td>
<p>The Narrative Response Model specification.</p>
</td></tr>
<tr><td><code id="ci_get_item_+3A_item_id">item_id</code></td>
<td>
<p>The identifier of the requested item.</p>
</td></tr>
<tr><td><code id="ci_get_item_+3A_language">language</code></td>
<td>
<p>The language of the stimuli.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character value with the item.
</p>

<hr>
<h2 id='ci_heatmap'>Create a heatmap showing issues with items</h2><span id='topic+ci_heatmap'></span>

<h3>Description</h3>

<p>When conducting cognitive interviews, it can be useful to quickly inspect
the code distributions for each item. These heatmaps facilitate that
process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_heatmap(
  x,
  nrmSpec = NULL,
  language = nrmSpec$defaultLanguage,
  wrapLabels = 80,
  itemOrder = NULL,
  itemLabels = NULL,
  itemIdentifier = "uiid",
  codingScheme = "peterson",
  itemlab = NULL,
  codelab = NULL,
  freqlab = "Count",
  plotTitle = "Cognitive Interview Heatmap",
  fillScale = ggplot2::scale_fill_viridis_c(),
  theme = ggplot2::theme_minimal()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_heatmap_+3A_x">x</code></td>
<td>
<p>The object with the parsed coded source(s) as resulting from a
call to <code><a href="#topic+parse_source">parse_source()</a></code> or <code><a href="#topic+parse_sources">parse_sources()</a></code>.</p>
</td></tr>
<tr><td><code id="ci_heatmap_+3A_nrmspec">nrmSpec</code></td>
<td>
<p>Optionally, an imported Narrative Response Model
specification, as imported with <code><a href="#topic+ci_import_nrm_spec">ci_import_nrm_spec()</a></code>, which will
then be used to obtain the item labels.</p>
</td></tr>
<tr><td><code id="ci_heatmap_+3A_language">language</code></td>
<td>
<p>If <code>nrmSpec</code> is specified, the language to use.</p>
</td></tr>
<tr><td><code id="ci_heatmap_+3A_wraplabels">wrapLabels</code></td>
<td>
<p>Whether to wrap the labels; if not <code>NULL</code>, the
number of character to wrap at.</p>
</td></tr>
<tr><td><code id="ci_heatmap_+3A_itemorder">itemOrder</code>, <code id="ci_heatmap_+3A_itemlabels">itemLabels</code></td>
<td>
<p>Instead of specifying an NRM specification,
you can also directly specify the item order and item labels. <code>itemOrder</code>
is a character vector of item identifiers, and <code>itemLabels</code> is a named
character vector of item labels, where each value's name is the
corresponding item identifier. If <code>itemLabels</code> is provided but <code>itemOrder</code>
is not, the order of the <code>itemLabel</code> is used.</p>
</td></tr>
<tr><td><code id="ci_heatmap_+3A_itemidentifier">itemIdentifier</code></td>
<td>
<p>The column identifying the items; the class instance
identifier prefix, e.g. if item identifiers are specified as
<code style="white-space: pre;">&#8288;[[uiid:familySize_7djdy62d]]&#8288;</code>, the <code>itemIdentifier</code> to pass here
is <code>"uiid"</code>.</p>
</td></tr>
<tr><td><code id="ci_heatmap_+3A_codingscheme">codingScheme</code></td>
<td>
<p>The coding scheme, either as a string if it represents
one of the cognitive interviewig coding schemes provided with the <code>rock</code>
package, or as a coding scheme resulting from a call
to <code><a href="#topic+create_codingScheme">create_codingScheme()</a></code>.</p>
</td></tr>
<tr><td><code id="ci_heatmap_+3A_itemlab">itemlab</code>, <code id="ci_heatmap_+3A_codelab">codelab</code>, <code id="ci_heatmap_+3A_freqlab">freqlab</code></td>
<td>
<p>Labels to use for the item and code axes
and for the frequency color legend (<code>NULL</code> to omit the label).</p>
</td></tr>
<tr><td><code id="ci_heatmap_+3A_plottitle">plotTitle</code></td>
<td>
<p>The title to use for the plot</p>
</td></tr>
<tr><td><code id="ci_heatmap_+3A_fillscale">fillScale</code></td>
<td>
<p>Convenient way to specify the fill scale (the colours)</p>
</td></tr>
<tr><td><code id="ci_heatmap_+3A_theme">theme</code></td>
<td>
<p>Convenient way to specify the <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> theme.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The heatmap as a ggplot2 plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>examplePath &lt;- file.path(system.file(package="rock"), 'extdata');
parsedCI &lt;- rock::parse_source(
  file.path(examplePath,
            "ci_example_1.rock")
);

rock::ci_heatmap(parsedCI,
                 codingScheme = "peterson");
</code></pre>

<hr>
<h2 id='ci_import_nrm_spec'>Import a Narrative Response Model specification</h2><span id='topic+ci_import_nrm_spec'></span><span id='topic+print.rock_ci_nrm'></span>

<h3>Description</h3>

<p>Narrative Response Models are a description of the theory of how a
measurement instrument that measures a psychological construct works,
geared towards conducting cognitive interviews to verify the validity
of that measurement instrument. One a Narrative Response Model has been
imported, it can be used to generate interview schemes, overview of each
item's narrative response model, and combined with coded cognitive
interview notes or transcripts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_import_nrm_spec(
  x,
  read_ss_args = list(exportGoogleSheet = TRUE),
  defaultLanguage = NULL,
  silent = rock::opts$get("silent")
)

## S3 method for class 'rock_ci_nrm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_import_nrm_spec_+3A_x">x</code></td>
<td>
<p>A path to a file or an URL to a Google Sheet, passed
to <code><a href="#topic+read_spreadsheet">read_spreadsheet()</a></code>.</p>
</td></tr>
<tr><td><code id="ci_import_nrm_spec_+3A_read_ss_args">read_ss_args</code></td>
<td>
<p>A named list with arguments to pass to
<code><a href="#topic+read_spreadsheet">read_spreadsheet()</a></code>.</p>
</td></tr>
<tr><td><code id="ci_import_nrm_spec_+3A_defaultlanguage">defaultLanguage</code></td>
<td>
<p>Language to set as default language (by default,
i.e. if <code>NULL</code>, the first language is used).</p>
</td></tr>
<tr><td><code id="ci_import_nrm_spec_+3A_silent">silent</code></td>
<td>
<p>Whether to be silent or chatty.</p>
</td></tr>
<tr><td><code id="ci_import_nrm_spec_+3A_...">...</code></td>
<td>
<p>Additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>rock_ci_nrm</code> object.
</p>

<hr>
<h2 id='clean_source'>Cleaning &amp; editing sources</h2><span id='topic+clean_source'></span><span id='topic+clean_sources'></span><span id='topic+search_and_replace_in_source'></span><span id='topic+search_and_replace_in_sources'></span><span id='topic+wordwrap_source'></span>

<h3>Description</h3>

<p>These functions can be used to 'clean' one or more sources or perform search and
replace taks. Cleaning consists of two operations: splitting the source at
utterance markers, and conducting search and replaces using regular expressions.
</p>
<p>These functions can be used to 'clean' one or more sources or perform search and
replace taks. Cleaning consists of two operations: splitting the source at
utterance markers, and conducting search and replaces using regular expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_source(
  input,
  output = NULL,
  replacementsPre = rock::opts$get("replacementsPre"),
  replacementsPost = rock::opts$get("replacementsPost"),
  extraReplacementsPre = NULL,
  extraReplacementsPost = NULL,
  removeNewlines = FALSE,
  removeTrailingNewlines = TRUE,
  rlWarn = rock::opts$get(rlWarn),
  utteranceSplits = rock::opts$get("utteranceSplits"),
  preventOverwriting = rock::opts$get("preventOverwriting"),
  encoding = rock::opts$get("encoding"),
  silent = rock::opts$get("silent")
)

clean_sources(
  input,
  output,
  outputPrefix = "",
  outputSuffix = "_cleaned",
  recursive = TRUE,
  filenameRegex = ".*",
  replacementsPre = rock::opts$get(replacementsPre),
  replacementsPost = rock::opts$get(replacementsPost),
  extraReplacementsPre = NULL,
  extraReplacementsPost = NULL,
  removeNewlines = FALSE,
  utteranceSplits = rock::opts$get(utteranceSplits),
  preventOverwriting = rock::opts$get(preventOverwriting),
  encoding = rock::opts$get(encoding),
  silent = rock::opts$get(silent)
)

search_and_replace_in_source(
  input,
  replacements = NULL,
  output = NULL,
  preventOverwriting = TRUE,
  encoding = "UTF-8",
  rlWarn = rock::opts$get(rlWarn),
  silent = FALSE
)

search_and_replace_in_sources(
  input,
  output,
  replacements = NULL,
  outputPrefix = "",
  outputSuffix = "_postReplacing",
  preventOverwriting = rock::opts$get("preventOverwriting"),
  recursive = TRUE,
  filenameRegex = ".*",
  encoding = rock::opts$get("encoding"),
  silent = rock::opts$get("silent")
)

wordwrap_source(
  input,
  output = NULL,
  length = 60,
  removeNewlines = FALSE,
  removeTrailingNewlines = TRUE,
  rlWarn = rock::opts$get(rlWarn),
  preventOverwriting = rock::opts$get("preventOverwriting"),
  encoding = rock::opts$get(encoding),
  silent = rock::opts$get(silent),
  utteranceMarker = rock::opts$get("utteranceMarker")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_source_+3A_input">input</code></td>
<td>
<p>For <code>clean_source</code> and <code>search_and_replace_in_source</code>, either a character
vector containing the text of the relevant source <em>or</em> a path to a file that contains
the source text; for <code>clean_sources</code> and <code>search_and_replace_in_sources</code>, a path to a
directory that contains the sources to clean.</p>
</td></tr>
<tr><td><code id="clean_source_+3A_output">output</code></td>
<td>
<p>For <code>clean_source</code> and <code>search_and_replace_in_source</code>, if not <code>NULL</code>,
this is the name (and path) of the file in which to save the processed source (if it
<em>is</em> <code>NULL</code>, the result will be returned visibly). For <code>clean_sources</code> and
<code>search_and_replace_in_sources</code>, <code>output</code> is mandatory and is the path to the
directory where to store the processed sources. This path will be created with a
warning if it does not exist. An exception is if &quot;<code>same</code>&quot; is specified - in that
case, every file will be written to the same directory it was read from.</p>
</td></tr>
<tr><td><code id="clean_source_+3A_replacementspre">replacementsPre</code>, <code id="clean_source_+3A_replacementspost">replacementsPost</code></td>
<td>
<p>Each is a list of two-element vectors,
where the first element in each vector contains a regular expression to search for
in the source(s), and the second element contains the replacement (these are passed
as <code>perl</code> regular expressions; see <code><a href="base.html#topic+regex">regex</a></code> for more information).
Instead of regular expressions, simple words or phrases can also be entered of
course (since those are valid regular expressions). <code>replacementsPre</code> are executed
before the <code>utteranceSplits</code> are applied; <code>replacementsPost</code> afterwards.</p>
</td></tr>
<tr><td><code id="clean_source_+3A_extrareplacementspre">extraReplacementsPre</code>, <code id="clean_source_+3A_extrareplacementspost">extraReplacementsPost</code></td>
<td>
<p>To perform more replacements
than the default set, these can be conveniently specified in <code>extraReplacementsPre</code>
and <code>extraReplacementsPost</code>. This prevents you from having to
manually copypaste the list of defaults to retain it.</p>
</td></tr>
<tr><td><code id="clean_source_+3A_removenewlines">removeNewlines</code></td>
<td>
<p>Whether to remove all newline characters from the source before
starting to clean them. <strong>Be careful</strong>: if the source contains YAML fragments, these
will also be affected by this, and will probably become invalid!</p>
</td></tr>
<tr><td><code id="clean_source_+3A_removetrailingnewlines">removeTrailingNewlines</code></td>
<td>
<p>Whether to remove trailing newline characters
(i.e. at the end of a character value in a character vector);</p>
</td></tr>
<tr><td><code id="clean_source_+3A_rlwarn">rlWarn</code></td>
<td>
<p>Whether to let <code><a href="base.html#topic+readLines">readLines()</a></code> warn, e.g. if files do not end
with a newline character.</p>
</td></tr>
<tr><td><code id="clean_source_+3A_utterancesplits">utteranceSplits</code></td>
<td>
<p>This is a vector of regular expressions that specify where to
insert breaks between utterances in the source(s). Such breakes are specified using
<code>utteranceMarker</code>.</p>
</td></tr>
<tr><td><code id="clean_source_+3A_preventoverwriting">preventOverwriting</code></td>
<td>
<p>Whether to prevent overwriting of output files.</p>
</td></tr>
<tr><td><code id="clean_source_+3A_encoding">encoding</code></td>
<td>
<p>The encoding of the source(s).</p>
</td></tr>
<tr><td><code id="clean_source_+3A_silent">silent</code></td>
<td>
<p>Whether to suppress the warning about not editing the cleaned source.</p>
</td></tr>
<tr><td><code id="clean_source_+3A_outputprefix">outputPrefix</code>, <code id="clean_source_+3A_outputsuffix">outputSuffix</code></td>
<td>
<p>The prefix and suffix to add to the
filenames when writing the processed files to disk.</p>
</td></tr>
<tr><td><code id="clean_source_+3A_recursive">recursive</code></td>
<td>
<p>Whether to search all subdirectories (<code>TRUE</code>) as well or not.</p>
</td></tr>
<tr><td><code id="clean_source_+3A_filenameregex">filenameRegex</code></td>
<td>
<p>A regular expression to match against located files; only
files matching this regular expression are processed.</p>
</td></tr>
<tr><td><code id="clean_source_+3A_replacements">replacements</code></td>
<td>
<p>The strings to search &amp; replace, as a list of two-element vectors,
where the first element in each vector contains a regular expression to search for
in the source(s), and the second element contains the replacement (these are passed
as <code>perl</code> regular expressions; see <code><a href="base.html#topic+regex">regex</a></code> for more information).
Instead of regular expressions, simple words or phrases can also be entered of
course (since those are valid regular expressions).</p>
</td></tr>
<tr><td><code id="clean_source_+3A_length">length</code></td>
<td>
<p>At how many characters to word wrap.</p>
</td></tr>
<tr><td><code id="clean_source_+3A_utterancemarker">utteranceMarker</code></td>
<td>
<p>The character(s) between utterances (i.e. marking where
one utterance ends and the next one starts). By default, this is a line
break, and only change this if you know what you are doing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cleaning functions, when called with their default arguments, will do the following:
</p>

<ul>
<li><p> Double periods (<code>..</code>) will be replaced with single periods (<code>.</code>)
</p>
</li>
<li><p> Four or more periods (<code>...</code> or <code>.....</code>) will be replaced with three periods
</p>
</li>
<li><p> Three or more newline characters will be replaced by one newline character (which
will become more, if the sentence before that character marks the end of an
utterance)
</p>
</li>
<li><p> All sentences will become separate utterances (in a semi-smart manner;
specifically, breaks in speaking, if represented by three periods, are not
considered sentence ends, wheread ellipses (&quot;…&quot; or unicode 2026, see the example) <em>are</em>.
</p>
</li>
<li><p> If there are comma's without a space following them, a space will be inserted.
</p>
</li></ul>

<p>The cleaning functions, when called with their default arguments, will do the following:
</p>

<ul>
<li><p> Double periods (<code>..</code>) will be replaced with single periods (<code>.</code>)
</p>
</li>
<li><p> Four or more periods (<code>...</code> or <code>.....</code>) will be replaced with three periods
</p>
</li>
<li><p> Three or more newline characters will be replaced by one newline character (which
will become more, if the sentence before that character marks the end of an
utterance)
</p>
</li>
<li><p> All sentences will become separate utterances (in a semi-smart manner;
specifically, breaks in speaking, if represented by three periods, are not
considered sentence ends, wheread ellipses (&quot;…&quot; or unicode 2026, see the example) <em>are</em>.
</p>
</li>
<li><p> If there are comma's without a space following them, a space will be inserted.
</p>
</li></ul>



<h3>Value</h3>

<p>A character vector for <code>clean_source</code>, or a list of character vectors,
for <code>clean_sources</code>.
</p>
<p>A character vector for <code>clean_source</code>, or a list of character vectors,
for <code>clean_sources</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exampleSource &lt;-
"Do you like icecream?


Well, that depends\u2026 Sometimes, when it's..... Nice. Then I do,
but otherwise... not really, actually."

### Default settings:
cat(clean_source(exampleSource));

### First remove existing newlines:
cat(clean_source(exampleSource,
                 removeNewlines=TRUE));

### Example with a YAML fragment
exampleWithYAML &lt;-
c(
  "Do you like icecream?",
  "",
  "",
  "Well, that depends\u2026 Sometimes, when it's..... Nice.",
  "Then I do,",
  "but otherwise... not really, actually.",
  "",
  "---",
  "This acts as some YAML. So this won't be split.",
  "Not real YAML, mind... It just has the delimiters, really.",
  "---",
  "This is an utterance again."
);

cat(
  rock::clean_source(
    exampleWithYAML
  ),
  sep="\n"
);

exampleSource &lt;-
"Do you like icecream?


Well, that depends\u2026 Sometimes, when it's..... Nice. Then I do,
but otherwise... not really, actually."

### Simple text replacements:
cat(search_and_replace_in_source(exampleSource,
                                 replacements=list(c("\u2026", "..."),
                                                   c("Nice", "Great"))));

### Using a regular expression to capitalize all words following
### a period:
cat(search_and_replace_in_source(exampleSource,
                                 replacements=list(c("\\.(\\s*)([a-z])", ".\\1\\U\\2"))));

exampleSource &lt;-
"Do you like icecream?


Well, that depends\u2026 Sometimes, when it's..... Nice. Then I do,
but otherwise... not really, actually."

### Default settings:
cat(clean_source(exampleSource));

### First remove existing newlines:
cat(clean_source(exampleSource,
                 removeNewlines=TRUE));

### Example with a YAML fragment
exampleWithYAML &lt;-
c(
  "Do you like icecream?",
  "",
  "",
  "Well, that depends\u2026 Sometimes, when it's..... Nice.",
  "Then I do,",
  "but otherwise... not really, actually.",
  "",
  "---",
  "This acts as some YAML. So this won't be split.",
  "Not real YAML, mind... It just has the delimiters, really.",
  "---",
  "This is an utterance again."
);

cat(
  rock::clean_source(
    exampleWithYAML
  ),
  sep="\n"
);

</code></pre>

<hr>
<h2 id='cleaned_source_to_utterance_vector'>Convert a character vector into an utterance vector</h2><span id='topic+cleaned_source_to_utterance_vector'></span>

<h3>Description</h3>

<p>Utterance vectors are split by the utterance marker. Note that if <code>x</code> has
more than one element, the separate elements will remain separate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleaned_source_to_utterance_vector(
  x,
  utteranceMarker = rock::opts$get("utteranceMarker"),
  fixed = FALSE,
  perl = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cleaned_source_to_utterance_vector_+3A_x">x</code></td>
<td>
<p>The character vector.</p>
</td></tr>
<tr><td><code id="cleaned_source_to_utterance_vector_+3A_utterancemarker">utteranceMarker</code></td>
<td>
<p>The utterance marker (by default, a newline
character conform the ROCK standard).</p>
</td></tr>
<tr><td><code id="cleaned_source_to_utterance_vector_+3A_fixed">fixed</code></td>
<td>
<p>Whether the <code>utteranceMarker</code> is a regular expression.</p>
</td></tr>
<tr><td><code id="cleaned_source_to_utterance_vector_+3A_perl">perl</code></td>
<td>
<p>If the <code>utteranceMarker</code> is a regular expression, whether it is
a perl regular expression.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with separate utterances, split
by <code>utteranceMarker</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cleaned_source_to_utterance_vector("first\nsecond\nthird");
</code></pre>

<hr>
<h2 id='code_freq_hist'>Create a frequency histogram for codes</h2><span id='topic+code_freq_hist'></span>

<h3>Description</h3>

<p>Create a frequency histogram for codes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>code_freq_hist(
  x,
  codes = ".*",
  sortByFreq = "decreasing",
  forceRootStripping = FALSE,
  trimSourceIdentifiers = 20,
  ggplot2Theme = ggplot2::theme(legend.position = "bottom"),
  silent = rock::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="code_freq_hist_+3A_x">x</code></td>
<td>
<p>A parsed source(s) object.</p>
</td></tr>
<tr><td><code id="code_freq_hist_+3A_codes">codes</code></td>
<td>
<p>A regular expression to select codes to include.</p>
</td></tr>
<tr><td><code id="code_freq_hist_+3A_sortbyfreq">sortByFreq</code></td>
<td>
<p>Whether to sort by frequency decreasingly
(<code>decreasing</code>, the default), increasingly (<code>increasing</code>),
or alphabetically (<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="code_freq_hist_+3A_forcerootstripping">forceRootStripping</code></td>
<td>
<p>Force the stripping of roots, even if they are
different.</p>
</td></tr>
<tr><td><code id="code_freq_hist_+3A_trimsourceidentifiers">trimSourceIdentifiers</code></td>
<td>
<p>If not <code>NULL</code>, the number of character to trim
the source identifiers to.</p>
</td></tr>
<tr><td><code id="code_freq_hist_+3A_ggplot2theme">ggplot2Theme</code></td>
<td>
<p>Can be used to specify theme elements for the plot.</p>
</td></tr>
<tr><td><code id="code_freq_hist_+3A_silent">silent</code></td>
<td>
<p>Whether to be chatty or silent.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Get a path to one example file
exampleFile &lt;-
  file.path(examplePath, "example-1.rock");

### Load example source
loadedExample &lt;- rock::parse_source(exampleFile);

### Show code frequencies
code_freq_hist(loadedExample);
</code></pre>

<hr>
<h2 id='code_source'>Add one or more codes to one or more sources</h2><span id='topic+code_source'></span><span id='topic+code_sources'></span>

<h3>Description</h3>

<p>These functions add codes to one or more
sources that were read with one of the
<code>loading_sources</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>code_source(
  input,
  codes,
  indices = NULL,
  output = NULL,
  decisionLabel = NULL,
  justification = NULL,
  justificationFile = NULL,
  preventOverwriting = rock::opts$get("preventOverwriting"),
  rlWarn = rock::opts$get(rlWarn),
  encoding = rock::opts$get("encoding"),
  silent = rock::opts$get("silent")
)

code_sources(
  input,
  codes,
  output = NULL,
  indices = NULL,
  outputPrefix = "",
  outputSuffix = "_coded",
  decisionLabel = NULL,
  justification = NULL,
  justificationFile = NULL,
  recursive = TRUE,
  filenameRegex = ".*",
  preventOverwriting = rock::opts$get("preventOverwriting"),
  encoding = rock::opts$get("encoding"),
  silent = rock::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="code_source_+3A_input">input</code></td>
<td>
<p>The source, or list of sources, as
produced by one of the <code>loading_sources</code> functions.</p>
</td></tr>
<tr><td><code id="code_source_+3A_codes">codes</code></td>
<td>
<p>A named character vector, where each element
is the code to be added to the matching utterance, and
the corresponding name is either an utterance identifier
(in which case the utterance with that identifier will be
coded with that code), a code (in which case all utterances
with that code will be coded with the new code as well), a
digit (in which case the utterance at that line number in
the source will be coded with that
code), or a regular expression, in which case all utterances
matching that regular expression will be coded with that
source. If specifying an utterance ID or code, make sure
that the code delimiters are included (normally, two square
brackets).</p>
</td></tr>
<tr><td><code id="code_source_+3A_indices">indices</code></td>
<td>
<p>If <code>input</code> is a source as loaded by
<code>loading_sources</code>, <code>indices</code> can be used to pass a logical
vector of the same length as <code>input</code>
that indicates to which utterance the code in <code>codes</code> should be
applied. Note that if <code>indices</code> is provided, only the first
element of <code>codes</code> is used, and its name is ignored.</p>
</td></tr>
<tr><td><code id="code_source_+3A_output">output</code></td>
<td>
<p>If specified, the coded source will be written here.</p>
</td></tr>
<tr><td><code id="code_source_+3A_decisionlabel">decisionLabel</code></td>
<td>
<p>A description of the (coding) decision that was taken.</p>
</td></tr>
<tr><td><code id="code_source_+3A_justification">justification</code></td>
<td>
<p>The justification for this action.</p>
</td></tr>
<tr><td><code id="code_source_+3A_justificationfile">justificationFile</code></td>
<td>
<p>If specified, the justification is appended to
this file. If not, it is saved to the <code>justifier::workspace()</code>. This can
then be saved or displayed at the end of the R Markdown file or R script
using <code>justifier::save_workspace()</code>.</p>
</td></tr>
<tr><td><code id="code_source_+3A_preventoverwriting">preventOverwriting</code></td>
<td>
<p>Whether to prevent overwriting existing files.</p>
</td></tr>
<tr><td><code id="code_source_+3A_rlwarn">rlWarn</code></td>
<td>
<p>Whether to let <code><a href="base.html#topic+readLines">readLines()</a></code> warn, e.g. if files do not end
with a newline character.</p>
</td></tr>
<tr><td><code id="code_source_+3A_encoding">encoding</code></td>
<td>
<p>The encoding to use.</p>
</td></tr>
<tr><td><code id="code_source_+3A_silent">silent</code></td>
<td>
<p>Whether to be chatty or quiet.</p>
</td></tr>
<tr><td><code id="code_source_+3A_outputprefix">outputPrefix</code>, <code id="code_source_+3A_outputsuffix">outputSuffix</code></td>
<td>
<p>A prefix and/or suffix to prepend and/or
append to the filenames to distinguish them from the input filenames.</p>
</td></tr>
<tr><td><code id="code_source_+3A_recursive">recursive</code></td>
<td>
<p>Whether to also read files from all subdirectories
of the <code>input</code> directory</p>
</td></tr>
<tr><td><code id="code_source_+3A_filenameregex">filenameRegex</code></td>
<td>
<p>Only input files matching this patterns will be read.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the coded source object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Get a path to one example file
exampleFile &lt;-
  file.path(examplePath, "example-1.rock");

### Parse single example source
loadedExample &lt;- rock::load_source(exampleFile);

### Show line 71
cat(loadedExample[71]);

### Specify the rules to code all utterances
### containing "Ipsum" with the code 'ipsum' and
### all utterances containing the code
codeSpecs &lt;-
  c("(?i)ipsum" = "ipsum",
    "BC|AD|\\d\\d\\d\\ds" = "timeRef");

### Apply rules
codedExample &lt;- code_source(loadedExample,
                            codeSpecs);

### Show line 71
cat(codedExample[71]);

### Also add code "foo" to utterances with code 'ipsum'
moreCodedExample &lt;- code_source(codedExample,
                                c("[[ipsum]]" = "foo"));

### Show line 71
cat(moreCodedExample[71]);

### Use the 'indices' argument to add the code 'bar' to
### line 71
overCodedExample &lt;- code_source(moreCodedExample,
                                "bar",
                                indices=71);

cat(overCodedExample[71]);

</code></pre>

<hr>
<h2 id='codebook_fromSpreadsheet'>Import a code book specification from a spreadsheet</h2><span id='topic+codebook_fromSpreadsheet'></span>

<h3>Description</h3>

<p>Import a code book specification from a spreadsheet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codebook_fromSpreadsheet(
  x,
  localBackup = NULL,
  exportGoogleSheet = TRUE,
  xlsxPkg = c("rw_xl", "openxlsx", "XLConnect"),
  silent = rock::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="codebook_fromSpreadsheet_+3A_x">x</code></td>
<td>
<p>The URL or path to a file.</p>
</td></tr>
<tr><td><code id="codebook_fromSpreadsheet_+3A_localbackup">localBackup</code></td>
<td>
<p>If not <code>NULL</code>, a valid filename to write a local
backup to.</p>
</td></tr>
<tr><td><code id="codebook_fromSpreadsheet_+3A_exportgooglesheet">exportGoogleSheet</code></td>
<td>
<p>If <code>x</code> is a URL to a Google Sheet, instead of using
the <code>googlesheets4</code> package to download the data, by passing
<code>exportGoogleSheet=TRUE</code>, an export link will be produced and the data
will be downloaded as Excel spreadsheet.</p>
</td></tr>
<tr><td><code id="codebook_fromSpreadsheet_+3A_xlsxpkg">xlsxPkg</code></td>
<td>
<p>Which package to use to work with Excel spreadsheets.</p>
</td></tr>
<tr><td><code id="codebook_fromSpreadsheet_+3A_silent">silent</code></td>
<td>
<p>Whether to be silent or chatty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The code book specification as a <code>rock</code> code book object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### This requires an active internet connection
if (FALSE) {
  gs_url &lt;- paste0(
    "https://docs.google.com/spreadsheets/d/",
    "1gVx5uhYzqcTH6Jq7AYmsLvHSBaYaT-23c7ZhZF4jmps"
  );
  codebook &lt;- rock::codebook_fromSpreadsheet(gs_url);
}
</code></pre>

<hr>
<h2 id='codebook_to_pdf'>Convert a codebook specification to PDF</h2><span id='topic+codebook_to_pdf'></span>

<h3>Description</h3>

<p>Use this function to export your codebook specification to a PDF
file. To embed it in an R Markdown file, use
!!! CREATE rock::knit_codebook() !!!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codebook_to_pdf(
  x,
  file,
  author = NULL,
  headingLevel = 1,
  silent = rock::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="codebook_to_pdf_+3A_x">x</code></td>
<td>
<p>The codebook object (as produced by a call to
<code><a href="#topic+codebook_fromSpreadsheet">codebook_fromSpreadsheet()</a></code>).</p>
</td></tr>
<tr><td><code id="codebook_to_pdf_+3A_file">file</code></td>
<td>
<p>The filename to save the codebook to.</p>
</td></tr>
<tr><td><code id="codebook_to_pdf_+3A_author">author</code></td>
<td>
<p>The author to specify in the PDF.</p>
</td></tr>
<tr><td><code id="codebook_to_pdf_+3A_headinglevel">headingLevel</code></td>
<td>
<p>The level of the top-most headings.</p>
</td></tr>
<tr><td><code id="codebook_to_pdf_+3A_silent">silent</code></td>
<td>
<p>Whether to be silent or chatty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x, invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Use a temporary file to write to
tmpFile &lt;- tempfile(fileext = ".pdf");

### Load an example (pre)registration specification
data("exampleCodebook_1", package = "rock");

rock::codebook_to_pdf(
  exampleCodebook_1,
  file = tmpFile
);

</code></pre>

<hr>
<h2 id='codeIds_to_codePaths'>Replace code identifiers with their full paths</h2><span id='topic+codeIds_to_codePaths'></span>

<h3>Description</h3>

<p>This function replaces the column names in the <code>mergedSourceDf</code> data frame
in a <code>rock_parsedSource</code> or <code>rock_parsedSources</code> object with the full paths
to those code identifiers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codeIds_to_codePaths(
  x,
  stripRootsFromCodePaths = rock::opts$get("stripRootsFromCodePaths")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="codeIds_to_codePaths_+3A_x">x</code></td>
<td>
<p>A <code>rock_parsedSource</code> or <code>rock_parsedSources</code> object as returned by
a call to <code><a href="#topic+parse_source">parse_source()</a></code> or <code><a href="#topic+parse_sources">parse_sources()</a></code>.</p>
</td></tr>
<tr><td><code id="codeIds_to_codePaths_+3A_striprootsfromcodepaths">stripRootsFromCodePaths</code></td>
<td>
<p>Whether to strip the roots first (i.e. the
type of code)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An adapted <code>rock_parsedSource</code> or <code>rock_parsedSources</code> object.
</p>

<hr>
<h2 id='codePaths_to_namedVector'>Get a vector to find the full paths based on the leaf code identifier</h2><span id='topic+codePaths_to_namedVector'></span>

<h3>Description</h3>

<p>This function names a vector with the leaf code
using the <code>codeTreeMarker</code> stored in the <a href="#topic+opts">opts</a> object as marker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codePaths_to_namedVector(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="codePaths_to_namedVector_+3A_x">x</code></td>
<td>
<p>A vector of code paths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The named vector of code paths.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>codePaths_to_namedVector(
  c("codes&gt;reason&gt;parent_feels",
    "codes&gt;reason&gt;child_feels")
);
</code></pre>

<hr>
<h2 id='codingSchemes_get_all'>Convenience function to get a list of all available coding schemes</h2><span id='topic+codingSchemes_get_all'></span>

<h3>Description</h3>

<p>Convenience function to get a list of all available coding schemes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codingSchemes_get_all()
</code></pre>


<h3>Value</h3>

<p>A list of all available coding schemes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rock::codingSchemes_get_all();
</code></pre>

<hr>
<h2 id='collapse_occurrences'>Collapse the occurrences in utterances into groups</h2><span id='topic+collapse_occurrences'></span>

<h3>Description</h3>

<p>This function collapses all occurrences into groups
sharing the same identifier, by default the <code>stanzaId</code>
identifier (<code style="white-space: pre;">&#8288;[[sid=..]]&#8288;</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_occurrences(
  parsedSource,
  collapseBy = "stanzaId",
  columns = NULL,
  logical = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_occurrences_+3A_parsedsource">parsedSource</code></td>
<td>
<p>The parsed sources as provided by <code><a href="#topic+parse_source">parse_source()</a></code>.</p>
</td></tr>
<tr><td><code id="collapse_occurrences_+3A_collapseby">collapseBy</code></td>
<td>
<p>The column in the <code>sourceDf</code> (in the <code>parsedSource</code> object)
to collapse by (i.e. the column specifying the groups to collapse).</p>
</td></tr>
<tr><td><code id="collapse_occurrences_+3A_columns">columns</code></td>
<td>
<p>The columns to collapse; if unspecified (i.e. <code>NULL</code>), all
codes stored in the <code>code</code> object in the <code>codings</code> object in the
<code>parsedSource</code> object are taken (i.e. all used codes in the <code>parsedSource</code>
object).</p>
</td></tr>
<tr><td><code id="collapse_occurrences_+3A_logical">logical</code></td>
<td>
<p>Whether to return the counts of the occurrences (<code>FALSE</code>) or
simply whether any code occurreded in the group at all (<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with one row for each value of of <code>collapseBy</code> and columns
for <code>collapseBy</code> and each of the <code>columns</code>, with in the cells the counts (if
<code>logical</code> is <code>FALSE</code>) or <code>TRUE</code> or <code>FALSE</code> (if <code>logical</code> is <code>TRUE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
exampleFile &lt;-
  system.file("extdata", "example-1.rock", package="rock");

### Parse example source
parsedExample &lt;-
  rock::parse_source(exampleFile);

### Collapse logically, using a code (either occurring or not):
collapsedExample &lt;-
  rock::collapse_occurrences(parsedExample,
                             collapseBy = 'childCode1');

### Show result: only two rows left after collapsing,
### because 'childCode1' is either 0 or 1:
collapsedExample;

### Collapse using weights (i.e. count codes in each segment):
collapsedExample &lt;-
  rock::collapse_occurrences(parsedExample,
                             collapseBy = 'childCode1',
                             logical=FALSE);


</code></pre>

<hr>
<h2 id='collect_coded_fragments'>Create an overview of coded fragments</h2><span id='topic+collect_coded_fragments'></span>

<h3>Description</h3>

<p>Collect all coded utterances and optionally add some context
(utterances before and utterances after) to create an overview
of all coded fragments per code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collect_coded_fragments(
  x,
  codes = ".*",
  context = 0,
  includeDescendents = FALSE,
  attributes = NULL,
  heading = NULL,
  headingLevel = 3,
  add_html_tags = TRUE,
  cleanUtterances = FALSE,
  output = NULL,
  outputViewer = "viewer",
  template = "default",
  rawResult = FALSE,
  includeCSS = TRUE,
  codeHeadingFormatting = rock::opts$get("codeHeadingFormatting"),
  includeBootstrap = rock::opts$get("includeBootstrap"),
  preventOverwriting = rock::opts$get("preventOverwriting"),
  silent = rock::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collect_coded_fragments_+3A_x">x</code></td>
<td>
<p>The parsed source(s) as provided by <code>rock::parse_source</code>
or <code>rock::parse_sources</code>.</p>
</td></tr>
<tr><td><code id="collect_coded_fragments_+3A_codes">codes</code></td>
<td>
<p>The regular expression that matches the codes to include,
or a character vector with codes or regular expressions for codes (which
will be prepended with &quot;<code>^</code>&quot; and appended with &quot;<code>$</code>&quot;, and then
concatenated using &quot;<code>|</code>&quot; as a separator, to create a regular expression
matching all codes).</p>
</td></tr>
<tr><td><code id="collect_coded_fragments_+3A_context">context</code></td>
<td>
<p>How many utterances before and after the target
utterances to include in the fragments. If two values, the first is the
number of utterances before, and the second, the number of utterances
after the target utterances.</p>
</td></tr>
<tr><td><code id="collect_coded_fragments_+3A_includedescendents">includeDescendents</code></td>
<td>
<p>Whether to also collect the fragments coded with
descendent codes (i.e. child codes, 'grand child codes', etc; in other
words, whether to collect the fragments recursively).</p>
</td></tr>
<tr><td><code id="collect_coded_fragments_+3A_attributes">attributes</code></td>
<td>
<p>To only select coded utterances matching one or more
values for one or more attributes, pass a list where every element's
name is a valid (i.e. occurring) attribute name, and every element is a
character value with a regular expression specifying all values for that
attribute to select.</p>
</td></tr>
<tr><td><code id="collect_coded_fragments_+3A_heading">heading</code></td>
<td>
<p>Optionally, a title to include in the output. The title
will be prefixed with <code>headingLevel</code> hashes (<code style="white-space: pre;">&#8288;#&#8288;</code>), and the codes with
<code>headingLevel+1</code> hashes. If <code>NULL</code> (the default), a heading will be
generated that includes the collected codes if those are five or less.
If a character value is specified, that will be used. To omit a heading,
set to anything that is not <code>NULL</code> or a character vector (e.g. <code>FALSE</code>).
If no heading is used, the code prefix will be <code>headingLevel</code> hashes,
instead of <code>headingLevel+1</code> hashes.</p>
</td></tr>
<tr><td><code id="collect_coded_fragments_+3A_headinglevel">headingLevel</code></td>
<td>
<p>The number of hashes to insert before the headings.</p>
</td></tr>
<tr><td><code id="collect_coded_fragments_+3A_add_html_tags">add_html_tags</code></td>
<td>
<p>Whether to add HTML tags to the result.</p>
</td></tr>
<tr><td><code id="collect_coded_fragments_+3A_cleanutterances">cleanUtterances</code></td>
<td>
<p>Whether to use the clean or the raw utterances
when constructing the fragments (the raw versions contain all codes). Note that
this should be set to <code>FALSE</code> to have <code>add_html_tags</code> be of the most use.</p>
</td></tr>
<tr><td><code id="collect_coded_fragments_+3A_output">output</code></td>
<td>
<p>Here, a path and filename can be provided where the
result will be written. If provided, the result will be returned
invisibly.</p>
</td></tr>
<tr><td><code id="collect_coded_fragments_+3A_outputviewer">outputViewer</code></td>
<td>
<p>If showing output, where to show the output: in
the console (<code>outputViewer='console'</code>) or in the viewer
(<code>outputViewer='viewer'</code>), e.g. the RStudio viewer. You'll usually want
the latter when outputting HTML, and otherwise the former. Set to <code>FALSE</code>
to not output anything to the console or the viewer.</p>
</td></tr>
<tr><td><code id="collect_coded_fragments_+3A_template">template</code></td>
<td>
<p>The template to load; either the name of one
of the ROCK templates (currently, only 'default' is available), or
the path and filename of a CSS file.</p>
</td></tr>
<tr><td><code id="collect_coded_fragments_+3A_rawresult">rawResult</code></td>
<td>
<p>Whether to return the raw result, a list of the
fragments, or one character value in markdown format.</p>
</td></tr>
<tr><td><code id="collect_coded_fragments_+3A_includecss">includeCSS</code></td>
<td>
<p>Whether to include the ROCK CSS in the returned HTML.</p>
</td></tr>
<tr><td><code id="collect_coded_fragments_+3A_codeheadingformatting">codeHeadingFormatting</code></td>
<td>
<p>A character value of the
form <code style="white-space: pre;">&#8288;%s *(path: %s)*&#8288;</code> (the default) or <code style="white-space: pre;">&#8288;\n\n### %s\n\n*path:* ``%s``\n\n&#8288;</code>.
The first <code style="white-space: pre;">&#8288;%s&#8288;</code> is replaced by the code identifier; the second <code style="white-space: pre;">&#8288;%s&#8288;</code> by the
corresponding path in the code tree.</p>
</td></tr>
<tr><td><code id="collect_coded_fragments_+3A_includebootstrap">includeBootstrap</code></td>
<td>
<p>Whether to include the default bootstrap CSS.</p>
</td></tr>
<tr><td><code id="collect_coded_fragments_+3A_preventoverwriting">preventOverwriting</code></td>
<td>
<p>Whether to prevent overwriting of output files.</p>
</td></tr>
<tr><td><code id="collect_coded_fragments_+3A_silent">silent</code></td>
<td>
<p>Whether to provide (<code>FALSE</code>) or suppress (<code>TRUE</code>) more detailed progress updates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the output is optimized for inclusion in an R Markdown
document. To optimize output for the R console or a plain text
file, without any HTML codes, set <code>add_html_tags</code> to FALSE, and
potentially set <code>cleanUtterances</code> to only return the utterances,
without the codes.
</p>


<h3>Value</h3>

<p>Either a list of character vectors, or a single character value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Get a path to one example file
exampleFile &lt;-
  file.path(
    examplePath, "example-1.rock"
  );

### Parse single example source
parsedExample &lt;-
  rock::parse_source(
    exampleFile
  );

### Show organised coded fragments in Markdown
cat(
  rock::collect_coded_fragments(
    parsedExample
  )
);

### Only for the codes containing 'Code2'
cat(
  rock::collect_coded_fragments(
    parsedExample,
    'Code2'
  )
);

</code></pre>

<hr>
<h2 id='compress_with_sum'>Vector compression helper functions</h2><span id='topic+compress_with_sum'></span><span id='topic+compress_with_or'></span>

<h3>Description</h3>

<p>These functions can help when compressing vectors. They always compress
their input (<code>x</code>) into a single element by various means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compress_with_sum(x)

compress_with_or(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compress_with_sum_+3A_x">x</code></td>
<td>
<p>The vector to compress</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>compress_with_sum</code> computes the sum of the elements, doing its best to
convert all input values to numeric values.
<code>compress_with_or</code> returns <code>0</code> if all elements are <code>FALSE</code>, <code>0</code>, <code>NA</code> or
empty character values (<code>""</code>), and <code>1</code> otherwise.
</p>


<h3>Value</h3>

<p>The compressed element
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rock::compress_with_sum(c(1, '1', 0));
rock::compress_with_or(c(1, '1', 0));
rock::compress_with_or(c(0, '', 0, FALSE));
</code></pre>

<hr>
<h2 id='convert_df_to_source'>Convert 'rectangular' or spreadsheet-format data to one or more sources</h2><span id='topic+convert_df_to_source'></span><span id='topic+convert_csv_to_source'></span><span id='topic+convert_csv2_to_source'></span><span id='topic+convert_xlsx_to_source'></span><span id='topic+convert_sav_to_source'></span>

<h3>Description</h3>

<p>These functions first import data from a 'data format', such as spreadsheets
in <code>.xlsx</code> format, comma-separated values files (<code>.csv</code>), or SPSS data
files (<code>.sav</code>). You can also just use R data frames (imported however you
want). These functions then use the columns you specified to convert these
data to one (<code>oneFile=TRUE</code>) or more (<code>oneFile=FALSE</code>) <code>rock</code>
source file(s), optionally including class instance
identifiers (such as case identifiers to identify participants, or location
identifiers, or moment identifiers, etc) and using those to link the
utterances to attributes from columns you specified. You can also precode
the utterances with codes you specify (if you ever would want to for some
reason).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_df_to_source(
  data,
  output = NULL,
  omit_empty_rows = TRUE,
  cols_to_utterances = NULL,
  cols_to_ciids = NULL,
  cols_to_codes = NULL,
  cols_to_attributes = NULL,
  utterance_classId = NULL,
  oneFile = TRUE,
  cols_to_sourceFilename = cols_to_ciids,
  cols_in_sourceFilename_sep = "=",
  sourceFilename_prefix = "source_",
  sourceFilename_suffix = "",
  ciid_labels = NULL,
  ciid_separator = "=",
  attributesFile = NULL,
  preventOverwriting = rock::opts$get(preventOverwriting),
  encoding = rock::opts$get(encoding),
  silent = rock::opts$get(silent)
)

convert_csv_to_source(
  file,
  importArgs = NULL,
  omit_empty_rows = TRUE,
  output = NULL,
  cols_to_utterances = NULL,
  cols_to_ciids = NULL,
  cols_to_codes = NULL,
  cols_to_attributes = NULL,
  oneFile = TRUE,
  cols_to_sourceFilename = cols_to_ciids,
  cols_in_sourceFilename_sep = "=",
  sourceFilename_prefix = "source_",
  sourceFilename_suffix = "",
  ciid_labels = NULL,
  ciid_separator = "=",
  attributesFile = NULL,
  preventOverwriting = rock::opts$get(preventOverwriting),
  encoding = rock::opts$get(encoding),
  silent = rock::opts$get(silent)
)

convert_csv2_to_source(
  file,
  importArgs = NULL,
  omit_empty_rows = TRUE,
  output = NULL,
  cols_to_utterances = NULL,
  cols_to_ciids = NULL,
  cols_to_codes = NULL,
  cols_to_attributes = NULL,
  oneFile = TRUE,
  cols_to_sourceFilename = cols_to_ciids,
  cols_in_sourceFilename_sep = "=",
  sourceFilename_prefix = "source_",
  sourceFilename_suffix = "",
  ciid_labels = NULL,
  ciid_separator = "=",
  attributesFile = NULL,
  preventOverwriting = rock::opts$get(preventOverwriting),
  encoding = rock::opts$get(encoding),
  silent = rock::opts$get(silent)
)

convert_xlsx_to_source(
  file,
  importArgs = list(),
  omit_empty_rows = TRUE,
  output = NULL,
  cols_to_utterances = NULL,
  cols_to_ciids = NULL,
  cols_to_codes = NULL,
  cols_to_attributes = NULL,
  oneFile = TRUE,
  cols_to_sourceFilename = cols_to_ciids,
  cols_in_sourceFilename_sep = "=",
  sourceFilename_prefix = "source_",
  sourceFilename_suffix = "",
  ciid_labels = NULL,
  ciid_separator = "=",
  attributesFile = NULL,
  preventOverwriting = rock::opts$get(preventOverwriting),
  encoding = rock::opts$get(encoding),
  silent = rock::opts$get(silent)
)

convert_sav_to_source(
  file,
  importArgs = NULL,
  omit_empty_rows = TRUE,
  output = NULL,
  cols_to_utterances = NULL,
  cols_to_ciids = NULL,
  cols_to_codes = NULL,
  cols_to_attributes = NULL,
  oneFile = TRUE,
  cols_to_sourceFilename = cols_to_ciids,
  cols_in_sourceFilename_sep = "=",
  sourceFilename_prefix = "source_",
  sourceFilename_suffix = "",
  ciid_labels = NULL,
  ciid_separator = "=",
  attributesFile = NULL,
  preventOverwriting = rock::opts$get(preventOverwriting),
  encoding = rock::opts$get(encoding),
  silent = rock::opts$get(silent)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_df_to_source_+3A_data">data</code></td>
<td>
<p>The data frame containing the data to convert.</p>
</td></tr>
<tr><td><code id="convert_df_to_source_+3A_output">output</code></td>
<td>
<p>If <code>oneFile=TRUE</code> (the default), the name (and path)
of the file in which to save the processed source (if it is <code>NULL</code>, the
resulting character vector will be returned visibly instead of invisibly).
Note that the ROCK convention is to use <code>.rock</code> as extension.
If <code>oneFile=FALSE</code>, the path to which to write the
sources (if it is <code>NULL</code>, as a result a list of character vectors will be
returned visibly instead of invisibly).</p>
</td></tr>
<tr><td><code id="convert_df_to_source_+3A_omit_empty_rows">omit_empty_rows</code></td>
<td>
<p>Whether to omit rows where the values in the columns
specified to convert to utterances are all empty (or contain only
whitespace).</p>
</td></tr>
<tr><td><code id="convert_df_to_source_+3A_cols_to_utterances">cols_to_utterances</code></td>
<td>
<p>The names of the columns to convert to utterances,
as a character vector.</p>
</td></tr>
<tr><td><code id="convert_df_to_source_+3A_cols_to_ciids">cols_to_ciids</code></td>
<td>
<p>The names of the columns to convert to class instance
identifiers (e.g. case identifiers), as a named character vector, with
the values being the column names in the data frame, and the names being the
class instance identifiers (e.g. <code>"sourceId"</code>, <code>"fieldId"</code>, <code>"caseId"</code>, etc).</p>
</td></tr>
<tr><td><code id="convert_df_to_source_+3A_cols_to_codes">cols_to_codes</code></td>
<td>
<p>The names of the columns to convert to codes (i.e.
codes appended to every utterance), as a character vector. When writing codes,
it is not possible to also write multiple utterance columns
(i.e. <code>utterance_classId</code> must be <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="convert_df_to_source_+3A_cols_to_attributes">cols_to_attributes</code></td>
<td>
<p>The names of the columns to convert to attributes,
as a named character vector, where each name is the name of the class
instance identifier to attach the attribute to. If only one column is passed
in <code>cols_to_ciids</code>, names can be omitted and a regular unnamed character
vector can be passed.</p>
</td></tr>
<tr><td><code id="convert_df_to_source_+3A_utterance_classid">utterance_classId</code></td>
<td>
<p>When specifying multiple columns with utterances,
and <code>utterance_classId</code> is not <code>NULL</code>, the column names are considered to be
class instance identifiers, and specified above each utterance using the
class identifier specified here (e.g. &quot;<code>utterance_classId="originalColName"</code>&quot;
yields something like &quot;<code style="white-space: pre;">&#8288;[[originalColName=colName_1]]&#8288;</code>&quot; above all utterances
from the column named <code>colName_1</code>). When writing multiple utterance columns,
it is not possible to also write codes (i.e. <code>cols_to_codes</code> must be <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="convert_df_to_source_+3A_onefile">oneFile</code></td>
<td>
<p>Whether to store everything in one source, or create one
source for each row of the data (if this is set to <code>FALSE</code>, make sure that
<code>cols_to_sourceFilename</code> specifies one or more columns that together
uniquely identify each row; also, in that case, <code>output</code> must be an existing
directory on your PC).</p>
</td></tr>
<tr><td><code id="convert_df_to_source_+3A_cols_to_sourcefilename">cols_to_sourceFilename</code></td>
<td>
<p>The columns to use as unique part of the
filename of each source. These will be concatenated using
<code>cols_in_sourceFilename_sep</code> as a separator. Note that the final string
<em>must</em> be unique for each row in the dataset, otherwise the filenames for
multiple rows will be the same and will be overwritten! By default, the
columns specified with class instance identifiers are used.</p>
</td></tr>
<tr><td><code id="convert_df_to_source_+3A_cols_in_sourcefilename_sep">cols_in_sourceFilename_sep</code></td>
<td>
<p>The separator to use when concatenating
the <code>cols_to_sourceFilename</code>.</p>
</td></tr>
<tr><td><code id="convert_df_to_source_+3A_sourcefilename_prefix">sourceFilename_prefix</code>, <code id="convert_df_to_source_+3A_sourcefilename_suffix">sourceFilename_suffix</code></td>
<td>
<p>Strings that are
prepended and appended to the <code>col_to_sourceFilename</code> to create the full
filenames. Note that <code>.rock</code> will always be added to the end as extension.</p>
</td></tr>
<tr><td><code id="convert_df_to_source_+3A_ciid_labels">ciid_labels</code></td>
<td>
<p>The labels for the class instance identifiers. Class
instance identifiers have brief codes used in coding (e.g. 'cid' is the
default for Case Identifiers, often used to identify participants) as well
as more 'readable' labels that are used in the attributes (e.g. 'caseId' is
the default class instance identifier for Case Identifiers). These can be
specified here as a named vector, with each element being the label and
the element's name the identifier.</p>
</td></tr>
<tr><td><code id="convert_df_to_source_+3A_ciid_separator">ciid_separator</code></td>
<td>
<p>The separator for the class instance identifier - by
default, either an equals sign (<code>=</code>) or a colon (<code>:</code>) are supported, but
an equals sign is less ambiguous.</p>
</td></tr>
<tr><td><code id="convert_df_to_source_+3A_attributesfile">attributesFile</code></td>
<td>
<p>Optionally, a file to write the attributes to if you
don't want them to be written to the source file(s).</p>
</td></tr>
<tr><td><code id="convert_df_to_source_+3A_preventoverwriting">preventOverwriting</code></td>
<td>
<p>Whether to prevent overwriting of output files.</p>
</td></tr>
<tr><td><code id="convert_df_to_source_+3A_encoding">encoding</code></td>
<td>
<p>The encoding of the source(s).</p>
</td></tr>
<tr><td><code id="convert_df_to_source_+3A_silent">silent</code></td>
<td>
<p>Whether to suppress the warning about not editing the cleaned source.</p>
</td></tr>
<tr><td><code id="convert_df_to_source_+3A_file">file</code></td>
<td>
<p>The path to a file containing the data to convert.</p>
</td></tr>
<tr><td><code id="convert_df_to_source_+3A_importargs">importArgs</code></td>
<td>
<p>Optionally, a list with named elements representing
arguments to pass when importing the file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A source as a character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example files
examplePath &lt;-
  system.file("extdata", package="rock");

### Get a path to file with example data frame
exampleFile &lt;-
  file.path(examplePath, "spreadsheet-import-test.csv");

### Read data into a data frame
dat &lt;-
  read.csv(exampleFile);

### Convert data frame to a source
source_from_df &lt;-
  convert_df_to_source(
    dat,
    cols_to_utterances = c("open_question_1",
                           "open_question_2"),
    cols_to_ciids = c(cid = "id"),
    cols_to_attributes = c("age", "gender"),
    cols_to_codes = c("code_1", "code_2"),
    ciid_labels = c(cid = "caseId")
 );

### Show the result
cat(
  source_from_df,
  sep = "\n"
);
</code></pre>

<hr>
<h2 id='convertToNumeric'>Conveniently convert vectors to numeric</h2><span id='topic+convertToNumeric'></span>

<h3>Description</h3>

<p>Tries to 'smartly' convert factor and character vectors to numeric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertToNumeric(vector, byFactorLabel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertToNumeric_+3A_vector">vector</code></td>
<td>
<p>The vector to convert.</p>
</td></tr>
<tr><td><code id="convertToNumeric_+3A_byfactorlabel">byFactorLabel</code></td>
<td>
<p>When converting factors, whether to do this
by their label value (<code>TRUE</code>) or their level value (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The converted vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rock::convertToNumeric(as.character(1:8));
</code></pre>

<hr>
<h2 id='create_codingScheme'>Create a coding scheme</h2><span id='topic+create_codingScheme'></span><span id='topic+codingScheme_peterson'></span><span id='topic+codingScheme_levine'></span><span id='topic+codingScheme_willis'></span>

<h3>Description</h3>

<p>This function can be used to specify a coding scheme that can then
be used in analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_codingScheme(
  id,
  label,
  codes,
  codingInstructions = NULL,
  description = "",
  source = ""
)

codingScheme_peterson

codingScheme_levine

codingScheme_willis
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_codingScheme_+3A_id">id</code></td>
<td>
<p>An identifier for this coding scheme, consisting only of
letters, numbers, and underscores (and not starting with a number).</p>
</td></tr>
<tr><td><code id="create_codingScheme_+3A_label">label</code></td>
<td>
<p>A short human-readable label for the coding scheme.</p>
</td></tr>
<tr><td><code id="create_codingScheme_+3A_codes">codes</code></td>
<td>
<p>A character vector with the codes in this scheme.</p>
</td></tr>
<tr><td><code id="create_codingScheme_+3A_codinginstructions">codingInstructions</code></td>
<td>
<p>Coding instructions; a named character vector,
where each element is a code's coding instruction, and each element's name
is the corresponding code.</p>
</td></tr>
<tr><td><code id="create_codingScheme_+3A_description">description</code></td>
<td>
<p>A description of this coding scheme (i.e. for information
that does not fit in the label).</p>
</td></tr>
<tr><td><code id="create_codingScheme_+3A_source">source</code></td>
<td>
<p>Optionally, a description, reference, or URL of a source
for this coding scheme.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>rock_codingScheme</code> of length 5.
</p>
<p>An object of class <code>rock_codingScheme</code> of length 5.
</p>
<p>An object of class <code>rock_codingScheme</code> of length 5.
</p>


<h3>Details</h3>

<p>A number of coding schemes for cognitive interviews are provided:
</p>

<dl>
<dt>codingScheme_peterson</dt><dd><p>Coding scheme from Peterson, Peterson &amp;
Powell, 2017</p>
</dd>
<dt>codingScheme_levine</dt><dd><p>Coding scheme from Levine, Fowler &amp;
Brown, 2005</p>
</dd>
<dt>codingScheme_willis</dt><dd><p>Coding scheme from Willis, 1999</p>
</dd>
</dl>



<h3>Value</h3>

<p>The coding scheme object.
</p>

<hr>
<h2 id='create_cooccurrence_matrix'>Create a co-occurrence matrix</h2><span id='topic+create_cooccurrence_matrix'></span>

<h3>Description</h3>

<p>This function creates a co-occurrence matrix based on one or more
coded sources. Optionally, it plots a heatmap, simply by calling
the <code><a href="stats.html#topic+heatmap">stats::heatmap()</a></code> function on that matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_cooccurrence_matrix(
  x,
  codes = x$convenience$codingLeaves,
  plotHeatmap = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_cooccurrence_matrix_+3A_x">x</code></td>
<td>
<p>The parsed source(s) as provided by <code>rock::parse_source</code> or <code>rock::parse_sources</code>.</p>
</td></tr>
<tr><td><code id="create_cooccurrence_matrix_+3A_codes">codes</code></td>
<td>
<p>The codes to include; by default, takes all codes.</p>
</td></tr>
<tr><td><code id="create_cooccurrence_matrix_+3A_plotheatmap">plotHeatmap</code></td>
<td>
<p>Whether to plot the heatmap.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The co-occurrence matrix; a <code>matrix</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Parse a selection of example sources in that directory
parsedExamples &lt;-
  rock::parse_sources(
    examplePath,
    regex = "(test|example)(.txt|.rock)"
  );

### Create cooccurrence matrix
rock::create_cooccurrence_matrix(parsedExamples);

</code></pre>

<hr>
<h2 id='css'>Create HTML fragment with CSS styling</h2><span id='topic+css'></span>

<h3>Description</h3>

<p>Create HTML fragment with CSS styling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>css(
  template = "default",
  includeBootstrap = rock::opts$get("includeBootstrap")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="css_+3A_template">template</code></td>
<td>
<p>The template to load; either the name of one
of the ROCK templates (currently, only 'default' is available), or
the path and filename of a CSS file.</p>
</td></tr>
<tr><td><code id="css_+3A_includebootstrap">includeBootstrap</code></td>
<td>
<p>Whether to include the default bootstrap CSS.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with the HTML fragment.
</p>

<hr>
<h2 id='doc_to_txt'>Convert a document (.docx, .pdf, .odt, .rtf, or .html) to a plain text file</h2><span id='topic+doc_to_txt'></span>

<h3>Description</h3>

<p>This used to be a thin wrapper around <code>textreadr::read_document()</code> that also
writes the result to <code>output</code>, doing its best to correctly write UTF-8
(based on the approach recommended in <a href="https://tomizonor.wordpress.com/2013/04/17/file-utf8-windows/">this blog post</a>). However,
<code>textreadr</code> was archived from CRAN. It now directly wraps the functions
that <code>textreadr</code> wraps: <code>pdftools::pdf_text()</code>, <code>striprtf::read_rtf</code>, and
it uses <code>xml2</code> to import <code>.docx</code> and <code>.odt</code> files, and <code>rvest</code> to import
<code>.html</code> files, using the code from the <code>textreadr</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doc_to_txt(
  input,
  output = NULL,
  encoding = rock::opts$get("encoding"),
  newExt = NULL,
  preventOverwriting = rock::opts$get("preventOverwriting"),
  silent = rock::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doc_to_txt_+3A_input">input</code></td>
<td>
<p>The path to the input file.</p>
</td></tr>
<tr><td><code id="doc_to_txt_+3A_output">output</code></td>
<td>
<p>The path and filename to write to. If this is a path to
an existing directory (without a filename specified), the <code>input</code> filename
will be used, and the extension will be replaced with <code>extension</code>.</p>
</td></tr>
<tr><td><code id="doc_to_txt_+3A_encoding">encoding</code></td>
<td>
<p>The encoding to use when writing the text file.</p>
</td></tr>
<tr><td><code id="doc_to_txt_+3A_newext">newExt</code></td>
<td>
<p>The extension to append: only used if <code>output = NULL</code> and
<code>newExt</code> is not <code>NULL</code>, in which case the output will be written to a file
with the same name as <code>input</code> but with <code>newExt</code> as extension.</p>
</td></tr>
<tr><td><code id="doc_to_txt_+3A_preventoverwriting">preventOverwriting</code></td>
<td>
<p>Whether to prevent overwriting existing files.</p>
</td></tr>
<tr><td><code id="doc_to_txt_+3A_silent">silent</code></td>
<td>
<p>Whether to the silent or chatty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The converted source, as a character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### This example requires the {xml2} package
if (requireNamespace("xml2", quietly = TRUE)) {
  print(
    rock::doc_to_txt(
      input = system.file(
        "extdata/doc-to-test.docx", package="rock"
      )
    )
  );
}
</code></pre>

<hr>
<h2 id='exampleCodebook_1'>An very rudimentary example codebook specification</h2><span id='topic+exampleCodebook_1'></span>

<h3>Description</h3>

<p>This is a simple and relatively short codebook
specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exampleCodebook_1
</code></pre>


<h3>Format</h3>

<p>An example of a codebook specification
</p>

<hr>
<h2 id='expand_attributes'>Expand categorical attribute variables to a series of dichotomous variables</h2><span id='topic+expand_attributes'></span>

<h3>Description</h3>

<p>Expand categorical attribute variables to a series of dichotomous variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_attributes(
  data,
  attributes,
  valueLabels = NULL,
  prefix = "",
  glue = "__",
  suffix = "",
  falseValue = 0,
  trueValue = 1,
  valueFirst = TRUE,
  append = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_attributes_+3A_data">data</code></td>
<td>
<p>The data frame, normally the <code style="white-space: pre;">&#8288;$qdt&#8288;</code> data frame that
exists in the object returned by a call to <code><a href="#topic+parse_sources">parse_sources()</a></code>.</p>
</td></tr>
<tr><td><code id="expand_attributes_+3A_attributes">attributes</code></td>
<td>
<p>The name of the attribute(s) to expand.</p>
</td></tr>
<tr><td><code id="expand_attributes_+3A_valuelabels">valueLabels</code></td>
<td>
<p>It's possible to use different names for the created
variables than the values of the attributes. This can be set with the
<code>valueLabels</code> argument. If only one attribute is specified, pass a named
vector for <code>valueLabels</code>, and if multiple attributes are specified, pass
a named list of named vectors, where the name of each vector corresponds to
an attribute passed in <code>attributes</code>. The names of the vector elements
must correspond to the values of the attributes (see the example).</p>
</td></tr>
<tr><td><code id="expand_attributes_+3A_prefix">prefix</code>, <code id="expand_attributes_+3A_suffix">suffix</code></td>
<td>
<p>The prefix and suffix to add to the variables names
that are returned.</p>
</td></tr>
<tr><td><code id="expand_attributes_+3A_glue">glue</code></td>
<td>
<p>The glue to paste the first part ad the second part of the
composite variable name together.</p>
</td></tr>
<tr><td><code id="expand_attributes_+3A_falsevalue">falseValue</code>, <code id="expand_attributes_+3A_truevalue">trueValue</code></td>
<td>
<p>The values to set for rows that, respectively,
do not match and do match an attribute value.</p>
</td></tr>
<tr><td><code id="expand_attributes_+3A_valuefirst">valueFirst</code></td>
<td>
<p>Whether to insert the attribute value first, or the
attribute name, in the composite variable names.</p>
</td></tr>
<tr><td><code id="expand_attributes_+3A_append">append</code></td>
<td>
<p>Whether to append the columns to the supplied data
frame or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Get a path to one example file
exampleFile &lt;-
  file.path(examplePath, "example-1.rock");

### Parse single example source
parsedExample &lt;- rock::parse_source(exampleFile);

### Create a categorical attribute column
parsedExample$qdt$age_group &lt;-
  c(rep(c("&lt;18", "18-30", "31-60", "&gt;60"),
        each=19),
    rep(c("&lt;18", "&gt;60"),
        time = c(3, 4)));

### Expand to four logical columns
parsedExample$qdt &lt;-
  rock::expand_attributes(
    parsedExample$qdt,
    "age_group",
    valueLabels =
      c(
        "&lt;18" = "youngest",
        "18-30" = "youngish",
        "31-60" = "oldish",
        "&gt;60" = "oldest"
       ),
    valueFirst = FALSE
);

### Show some of the result
table(parsedExample$qdt$age_group,
      parsedExample$qdt$age_group__youngest);
table(parsedExample$qdt$age_group,
      parsedExample$qdt$age_group__oldish);
</code></pre>

<hr>
<h2 id='export_codes_to_txt'>Export codes to a plain text file</h2><span id='topic+export_codes_to_txt'></span>

<h3>Description</h3>

<p>These function can be used to convert one or more parsed sources to HTML,
or to convert all sources to tabbed sections in Markdown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_codes_to_txt(
  input,
  output = NULL,
  codeTree = "fullyMergedCodeTrees",
  codingScheme = "codes",
  regex = ".*",
  onlyChildrenOf = NULL,
  leavesOnly = TRUE,
  includePath = TRUE,
  preventOverwriting = rock::opts$get(preventOverwriting),
  encoding = rock::opts$get(encoding),
  silent = rock::opts$get(silent)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_codes_to_txt_+3A_input">input</code></td>
<td>
<p>An object of class <code>rock_parsedSource</code> (as resulting from a call
to <code>parse_source</code>) or of class <code>rock_parsedSources</code> (as resulting from a call
to <code>parse_sources</code>.</p>
</td></tr>
<tr><td><code id="export_codes_to_txt_+3A_output">output</code></td>
<td>
<p>THe filename to write to.</p>
</td></tr>
<tr><td><code id="export_codes_to_txt_+3A_codetree">codeTree</code></td>
<td>
<p>Codes from which code tree to export the codes. Valid options
are <code>fullyMergedCodeTrees</code>, <code>extendedDeductiveCodeTrees</code>, <code>deductiveCodeTrees</code>,
and <code>inductiveCodeTrees</code>.</p>
</td></tr>
<tr><td><code id="export_codes_to_txt_+3A_codingscheme">codingScheme</code></td>
<td>
<p>With the ROCK, it's possible to use multiple coding scheme's
in parallel. The ROCK default is called <code>codes</code> (using the double square brackets
as code delimiters), but other delimiters can be used as well, and give a different
name. Use <code>codingScheme</code> to specify which code tree you want to export, if you
have multiple.</p>
</td></tr>
<tr><td><code id="export_codes_to_txt_+3A_regex">regex</code></td>
<td>
<p>An optional regular expression: only codes matching this regular
expression will be selected.</p>
</td></tr>
<tr><td><code id="export_codes_to_txt_+3A_onlychildrenof">onlyChildrenOf</code></td>
<td>
<p>A character vector of one or more regular expressions that
specify codes within which to search. For example, if the code tree contains codes
<code>parent1</code> and <code>parent2</code>, and each have a number of child codes, and <code>parent</code> is
passed as <code>onlyChildrenOf</code>, only the codes within <code>parent</code> are selected.</p>
</td></tr>
<tr><td><code id="export_codes_to_txt_+3A_leavesonly">leavesOnly</code></td>
<td>
<p>Whether to only write the leaves (i.e. codes that don't have
children) or all codes in the code tree.</p>
</td></tr>
<tr><td><code id="export_codes_to_txt_+3A_includepath">includePath</code></td>
<td>
<p>Whether to only return the code itself (e.g. <code>code</code>) or also
include the path to the root (e.g. <code style="white-space: pre;">&#8288;code1&gt;code2&gt;code&#8288;</code>).</p>
</td></tr>
<tr><td><code id="export_codes_to_txt_+3A_preventoverwriting">preventOverwriting</code></td>
<td>
<p>Whether to prevent overwriting of output files.</p>
</td></tr>
<tr><td><code id="export_codes_to_txt_+3A_encoding">encoding</code></td>
<td>
<p>The encoding to use when writing the exported source(s).</p>
</td></tr>
<tr><td><code id="export_codes_to_txt_+3A_silent">silent</code></td>
<td>
<p>Whether to suppress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Parse a selection of example sources in that directory
parsedExamples &lt;-
  rock::parse_sources(
    examplePath,
    regex = "(test|example)(.txt|.rock)"
  );

### Show results of exporting the codes
rock::export_codes_to_txt(parsedExamples);

### Only show select a narrow set of codes
rock::export_codes_to_txt(
  parsedExamples,
  leavesOnly=TRUE,
  includePath=FALSE,
  onlyChildrenOf = "inductFather",
  regex="3|5"
);

</code></pre>

<hr>
<h2 id='export_mergedSourceDf_to_csv'>Export a merged source data frame</h2><span id='topic+export_mergedSourceDf_to_csv'></span><span id='topic+export_mergedSourceDf_to_csv2'></span><span id='topic+export_mergedSourceDf_to_xlsx'></span><span id='topic+export_mergedSourceDf_to_sav'></span>

<h3>Description</h3>

<p>Export a merged source data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_mergedSourceDf_to_csv(
  x,
  file,
  exportArgs = list(fileEncoding = rock::opts$get("encoding")),
  preventOverwriting = rock::opts$get("preventOverwriting"),
  silent = rock::opts$get("silent")
)

export_mergedSourceDf_to_csv2(
  x,
  file,
  exportArgs = list(fileEncoding = rock::opts$get("encoding")),
  preventOverwriting = rock::opts$get("preventOverwriting"),
  silent = rock::opts$get("silent")
)

export_mergedSourceDf_to_xlsx(
  x,
  file,
  exportArgs = NULL,
  preventOverwriting = rock::opts$get("preventOverwriting"),
  silent = rock::opts$get("silent")
)

export_mergedSourceDf_to_sav(
  x,
  file,
  exportArgs = NULL,
  preventOverwriting = rock::opts$get("preventOverwriting"),
  silent = rock::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_mergedSourceDf_to_csv_+3A_x">x</code></td>
<td>
<p>The object with parsed sources.</p>
</td></tr>
<tr><td><code id="export_mergedSourceDf_to_csv_+3A_file">file</code></td>
<td>
<p>The file to export to.</p>
</td></tr>
<tr><td><code id="export_mergedSourceDf_to_csv_+3A_exportargs">exportArgs</code></td>
<td>
<p>Optionally, arguments to pass to the function to use to
export.</p>
</td></tr>
<tr><td><code id="export_mergedSourceDf_to_csv_+3A_preventoverwriting">preventOverwriting</code></td>
<td>
<p>Whether to prevent overwriting if the file already
exists.</p>
</td></tr>
<tr><td><code id="export_mergedSourceDf_to_csv_+3A_silent">silent</code></td>
<td>
<p>Whether to be silent or chatty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Silently, the object with parsed sources.
</p>

<hr>
<h2 id='export_to_html'>Export parsed sources to HTML or Markdown</h2><span id='topic+export_to_html'></span><span id='topic+export_to_markdown'></span>

<h3>Description</h3>

<p>These function can be used to convert one or more parsed sources to HTML,
or to convert all sources to tabbed sections in Markdown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_to_html(
  input,
  output = NULL,
  template = "default",
  fragment = FALSE,
  preventOverwriting = rock::opts$get(preventOverwriting),
  encoding = rock::opts$get(encoding),
  silent = rock::opts$get(silent)
)

export_to_markdown(
  input,
  heading = "Sources",
  headingLevel = 2,
  template = "default",
  silent = rock::opts$get(silent)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_to_html_+3A_input">input</code></td>
<td>
<p>An object of class <code>rock_parsedSource</code> (as resulting from a call
to <code>parse_source</code>) or of class <code>rock_parsedSources</code> (as resulting from a call
to <code>parse_sources</code>.</p>
</td></tr>
<tr><td><code id="export_to_html_+3A_output">output</code></td>
<td>
<p>For <code>export_to_html</code>, either NULL to not write any files,
or, if <code>input</code> is a single <code>rock_parsedSource</code>, the filename to write to,
and if <code>input</code> is a <code>rock_parsedSources</code> object, the path to write to.
This path will be created with a warning if it does not exist.</p>
</td></tr>
<tr><td><code id="export_to_html_+3A_template">template</code></td>
<td>
<p>The template to load; either the name of one
of the ROCK templates (currently, only 'default' is available), or
the path and filename of a CSS file.</p>
</td></tr>
<tr><td><code id="export_to_html_+3A_fragment">fragment</code></td>
<td>
<p>Whether to include the CSS and HTML tags (<code>FALSE</code>) or just
return the fragment(s) with the source(s) (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="export_to_html_+3A_preventoverwriting">preventOverwriting</code></td>
<td>
<p>For <code>export_to_html</code>, whether to prevent overwriting
of output files.</p>
</td></tr>
<tr><td><code id="export_to_html_+3A_encoding">encoding</code></td>
<td>
<p>For <code>export_to_html</code>, the encoding to use when writing
the exported source(s).</p>
</td></tr>
<tr><td><code id="export_to_html_+3A_silent">silent</code></td>
<td>
<p>Whether to suppress messages.</p>
</td></tr>
<tr><td><code id="export_to_html_+3A_heading">heading</code>, <code id="export_to_html_+3A_headinglevel">headingLevel</code></td>
<td>
<p>For</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector or a list of character vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Parse a selection of example sources in that directory
parsedExamples &lt;- rock::parse_sources(
  examplePath,
  regex = "(test|example)(.txt|.rock)"
);

### Export results to a temporary directory
tmpDir &lt;- tempdir(check = TRUE);
prettySources &lt;-
  export_to_html(input = parsedExamples,
                 output = tmpDir);

### Show first one
print(prettySources[[1]]);

</code></pre>

<hr>
<h2 id='exportToHTML'>Exporting tables to HTML</h2><span id='topic+exportToHTML'></span>

<h3>Description</h3>

<p>This function exports data frames or matrices to
HTML, sending output to one or more of the console,
viewer, and one or more files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exportToHTML(
  input,
  output = rock::opts$get("tableOutput"),
  tableOutputCSS = rock::opts$get("tableOutputCSS")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exportToHTML_+3A_input">input</code></td>
<td>
<p>Either a <code>data.frame</code>, <code>table</code>, or <code>matrix</code>,
or a list with three elements: <code>pre</code>, <code>input</code>, and <code>post</code>.
The <code>pre</code> and <code>post</code> are simply prepended and postpended to
the HTML generated based on the <code>input$input</code> element.</p>
</td></tr>
<tr><td><code id="exportToHTML_+3A_output">output</code></td>
<td>
<p>The output: a character vector with one or more
of &quot;<code>console</code>&quot; (the raw concatenated input, without conversion
to HTML), &quot;<code>viewer</code>&quot;, which uses the RStudio viewer if available,
and one or more filenames in existing directories.</p>
</td></tr>
<tr><td><code id="exportToHTML_+3A_tableoutputcss">tableOutputCSS</code></td>
<td>
<p>The CSS to use for the HTML table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the (potentially concatenated) <code>input</code> as character
vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exportToHTML(mtcars[1:5, 1:5]);
</code></pre>

<hr>
<h2 id='extract_codings_by_coderId'>Extract the codings by each coder using the coderId</h2><span id='topic+extract_codings_by_coderId'></span>

<h3>Description</h3>

<p>Extract the codings by each coder using the coderId
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_codings_by_coderId(
  input,
  recursive = TRUE,
  filenameRegex = ".*",
  postponeDeductiveTreeBuilding = TRUE,
  ignoreOddDelimiters = FALSE,
  encoding = rock::opts$get(encoding),
  silent = rock::opts$get(silent)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_codings_by_coderId_+3A_input">input</code></td>
<td>
<p>The directory with the sources.</p>
</td></tr>
<tr><td><code id="extract_codings_by_coderId_+3A_recursive">recursive</code></td>
<td>
<p>Whether to also process subdirectories.</p>
</td></tr>
<tr><td><code id="extract_codings_by_coderId_+3A_filenameregex">filenameRegex</code></td>
<td>
<p>Only files matching this regular expression will be processed.</p>
</td></tr>
<tr><td><code id="extract_codings_by_coderId_+3A_postponedeductivetreebuilding">postponeDeductiveTreeBuilding</code></td>
<td>
<p>Whether to build deductive code trees, or only
store YAML fragments.</p>
</td></tr>
<tr><td><code id="extract_codings_by_coderId_+3A_ignoreodddelimiters">ignoreOddDelimiters</code></td>
<td>
<p>Whether to throw an error when encountering an odd number of
YAML delimiters.</p>
</td></tr>
<tr><td><code id="extract_codings_by_coderId_+3A_encoding">encoding</code></td>
<td>
<p>The encoding of the files to read.</p>
</td></tr>
<tr><td><code id="extract_codings_by_coderId_+3A_silent">silent</code></td>
<td>
<p>Whether to be chatty or silent.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with the read sources.
</p>

<hr>
<h2 id='form_to_rmd_template'>Convert a (pre)registration form to an R Markdown template</h2><span id='topic+form_to_rmd_template'></span>

<h3>Description</h3>

<p>This function creates an R Markdown template from a {preregr}
(pre)registrations form specification. Pass it the URL to a Google
Sheet holding the (pre)registration form specification (in {preregr}
format), see the
&quot;<a href="https://r-packages.gitlab.io/preregr/articles/creating_form_from_spreadsheet.html">Creating a form from a spreadsheet</a>&quot;
vignette), the path to a file with a spreadsheet holding such a
specification, or a loaded or imported {preregr} (pre)registration form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>form_to_rmd_template(
  x,
  file = NULL,
  title = NULL,
  author = NULL,
  date = "`r format(Sys.time(), \"%H:%M:%S on %Y-%m-%d %Z (UTC%z)\")`",
  output = "html_document",
  yaml = list(title = title, author = author, date = date, output = output),
  includeYAML = TRUE,
  chunkOpts = "echo=FALSE, results='hide'",
  justify = FALSE,
  headingLevel = 1,
  showSpecification = FALSE,
  preventOverwriting = rock::opts$get("preventOverwriting"),
  silent = rock::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="form_to_rmd_template_+3A_x">x</code></td>
<td>
<p>The (pre)registration form (as produced by a call
to <code>preregr::form_create()</code> or <code>preregr::import_from_html()</code>) or
initialized <code>preregr</code> object (as produced by a call to
<code>preregr::prereg_initialize()</code> or <code>preregr::import_from_html()</code>); or, for
the printing method, the R Markdown template produced by a call to
<code>preregr::form_to_rmd_template()</code>.</p>
</td></tr>
<tr><td><code id="form_to_rmd_template_+3A_file">file</code></td>
<td>
<p>Optionally, a file to save the html to.</p>
</td></tr>
<tr><td><code id="form_to_rmd_template_+3A_title">title</code></td>
<td>
<p>The title to specify in the template's YAML front matter.</p>
</td></tr>
<tr><td><code id="form_to_rmd_template_+3A_author">author</code></td>
<td>
<p>The author to specify in the template's YAML front matter.</p>
</td></tr>
<tr><td><code id="form_to_rmd_template_+3A_date">date</code></td>
<td>
<p>The date to specify in the template's YAML front matter.</p>
</td></tr>
<tr><td><code id="form_to_rmd_template_+3A_output">output</code></td>
<td>
<p>The output format to specify in the template's YAML
front matter.</p>
</td></tr>
<tr><td><code id="form_to_rmd_template_+3A_yaml">yaml</code></td>
<td>
<p>It is also possible to specify the YAML front matter directly
using this argument. If used, it overrides anything specified in <code>title</code>,
<code>author</code>, <code>date</code> and <code>output</code>.</p>
</td></tr>
<tr><td><code id="form_to_rmd_template_+3A_includeyaml">includeYAML</code></td>
<td>
<p>Whether to include the YAML front matter or omit it.</p>
</td></tr>
<tr><td><code id="form_to_rmd_template_+3A_chunkopts">chunkOpts</code></td>
<td>
<p>The chunk options to set for the chunks in the template.</p>
</td></tr>
<tr><td><code id="form_to_rmd_template_+3A_justify">justify</code></td>
<td>
<p>Whether to use <code>preregr::prereg_specify()</code> as function for
specifying the (pre)registration content (if <code>FALSE</code>), or
<code>preregr::prereg_justify()</code> (if <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="form_to_rmd_template_+3A_headinglevel">headingLevel</code></td>
<td>
<p>The level of the top-most heading to use (the
title of the (pre)registration form).</p>
</td></tr>
<tr><td><code id="form_to_rmd_template_+3A_showspecification">showSpecification</code></td>
<td>
<p>Whether to show the specification in the Rmd
output. When <code>FALSE</code>, the <code>preregr</code> option <code>silent</code> is set to <code>TRUE</code> at
the start of the Rmd template; otherwise, it is set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="form_to_rmd_template_+3A_preventoverwriting">preventOverwriting</code></td>
<td>
<p>Set to <code>FALSE</code> to override overwrite prevention.</p>
</td></tr>
<tr><td><code id="form_to_rmd_template_+3A_silent">silent</code></td>
<td>
<p>Whether to be silent or chatty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x, invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>preregr::form_create(
  title = "Example form",
  version = "0.1.0"
) |&gt;
  preregr::form_to_rmd_template();
</code></pre>

<hr>
<h2 id='generate_uids'>Generate utterance identifiers (UIDs)</h2><span id='topic+generate_uids'></span>

<h3>Description</h3>

<p>This function generates utterance identifiers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_uids(x, origin = Sys.time())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_uids_+3A_x">x</code></td>
<td>
<p>The number of identifiers te generate.</p>
</td></tr>
<tr><td><code id="generate_uids_+3A_origin">origin</code></td>
<td>
<p>The origin to use when generating the actual
identifiers. These identifiers are the present UNIX timestamp
(i.e. the number of seconds elapsed since the UNIX epoch,
the first of january 1970), accurate to two decimal places
(i.e. to centiseconds), converted to the base 30 system using
<code><a href="#topic+numericToBase30">numericToBase30()</a></code>. By default, the present time is used as
origin, one one centisecond is added for every identifiers to
generate. <code>origin</code> can be set to other values to work with
different origins (of course, don't use this unless you
understand very well what you're doing!).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of UIDs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rock::generate_uids(5);

### Show how UIDs are the converted date/time
x &lt;- rock::generate_uids(1);
x;
x_UID &lt;- gsub(
  "\\[\\[uid=(.*)\\]\\]",
  "\\1",
  x
);
x_as_nr &lt;- rock::base30toNumeric(x_UID);
x_as_timestamp &lt;- x_as_nr / 100;
x_as_date &lt;-
  as.POSIXct(
    x_as_timestamp,
    origin = "1970-01-01",
    tz = "UTC"
  );
x_as_date
</code></pre>

<hr>
<h2 id='generic_recoding'>Generic underlying recoding function</h2><span id='topic+generic_recoding'></span>

<h3>Description</h3>

<p>This function contains the general set of actions that are always used
when recoding a source (e.g. check the input, document the
justification, etc). Users should normally never call this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generic_recoding(
  input,
  codes,
  func,
  filenameRegex = ".*",
  filter = TRUE,
  output = NULL,
  outputPrefix = "",
  outputSuffix = "_recoded",
  decisionLabel = NULL,
  justification = NULL,
  justificationFile = NULL,
  preventOverwriting = rock::opts$get("preventOverwriting"),
  encoding = rock::opts$get("encoding"),
  silent = rock::opts$get("silent"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generic_recoding_+3A_input">input</code></td>
<td>
<p>One of 1) a character string specifying the path to a file
with a source; 2) an object with a loaded source as produced by a call
to <code><a href="#topic+load_source">load_source()</a></code>; 3) a character string specifying the path to a
directory containing one or more sources; 4) or an object with a list of
loaded sources as produced by a call to <code><a href="#topic+load_sources">load_sources()</a></code>.</p>
</td></tr>
<tr><td><code id="generic_recoding_+3A_codes">codes</code></td>
<td>
<p>The codes to process</p>
</td></tr>
<tr><td><code id="generic_recoding_+3A_func">func</code></td>
<td>
<p>The function to apply.</p>
</td></tr>
<tr><td><code id="generic_recoding_+3A_filenameregex">filenameRegex</code></td>
<td>
<p>Only process files matching this regular expression.</p>
</td></tr>
<tr><td><code id="generic_recoding_+3A_filter">filter</code></td>
<td>
<p>Optionally, a filter to apply to specify a subset of the
source(s) to process (see <code><a href="#topic+get_source_filter">get_source_filter()</a></code>).</p>
</td></tr>
<tr><td><code id="generic_recoding_+3A_output">output</code></td>
<td>
<p>If specified, the coded source will be written here.</p>
</td></tr>
<tr><td><code id="generic_recoding_+3A_outputprefix">outputPrefix</code>, <code id="generic_recoding_+3A_outputsuffix">outputSuffix</code></td>
<td>
<p>The prefix and suffix to add to the
filenames when writing the processed files to disk, in case multiple
sources are passed as input.</p>
</td></tr>
<tr><td><code id="generic_recoding_+3A_decisionlabel">decisionLabel</code></td>
<td>
<p>A description of the (recoding) decision that was taken.</p>
</td></tr>
<tr><td><code id="generic_recoding_+3A_justification">justification</code></td>
<td>
<p>The justification for this action.</p>
</td></tr>
<tr><td><code id="generic_recoding_+3A_justificationfile">justificationFile</code></td>
<td>
<p>If specified, the justification is appended to
this file. If not, it is saved to the <code>justifier::workspace()</code>. This can
then be saved or displayed at the end of the R Markdown file or R script
using <code>justifier::save_workspace()</code>.</p>
</td></tr>
<tr><td><code id="generic_recoding_+3A_preventoverwriting">preventOverwriting</code></td>
<td>
<p>Whether to prevent overwriting existing files
when writing the files to <code>output</code>.</p>
</td></tr>
<tr><td><code id="generic_recoding_+3A_encoding">encoding</code></td>
<td>
<p>The encoding to use.</p>
</td></tr>
<tr><td><code id="generic_recoding_+3A_silent">silent</code></td>
<td>
<p>Whether to be chatty or quiet.</p>
</td></tr>
<tr><td><code id="generic_recoding_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code>fnc</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the recoded source(s) or source(s) object.
</p>

<hr>
<h2 id='get_childCodeIds'>Get the code identifiers a code's descendents</h2><span id='topic+get_childCodeIds'></span><span id='topic+get_descendentCodeIds'></span>

<h3>Description</h3>

<p>Get the code identifiers of all children, or all descendents (i.e. including
grand-children, grand-grand-children, etc) of a code with a given identifier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_childCodeIds(
  x,
  parentCodeId,
  returnNodes = FALSE,
  includeParentCode = FALSE
)

get_descendentCodeIds(x, parentCodeId, includeParentCode = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_childCodeIds_+3A_x">x</code></td>
<td>
<p>The parsed sources object</p>
</td></tr>
<tr><td><code id="get_childCodeIds_+3A_parentcodeid">parentCodeId</code></td>
<td>
<p>The code identifier of the parent code</p>
</td></tr>
<tr><td><code id="get_childCodeIds_+3A_returnnodes">returnNodes</code></td>
<td>
<p>For <code>get_childCodeIds()</code>, set this to <code>TRUE</code> to return
a list of nodes, not just the code identifiers.</p>
</td></tr>
<tr><td><code id="get_childCodeIds_+3A_includeparentcode">includeParentCode</code></td>
<td>
<p>Whether to include the parent code
identifier in the result</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with code identifiers (or a list of nodes)
</p>

<hr>
<h2 id='get_dataframe_from_nested_list'>Return all values from a nested list in a dataframe</h2><span id='topic+get_dataframe_from_nested_list'></span>

<h3>Description</h3>

<p>Return all values from a nested list in a dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dataframe_from_nested_list(x, nestingIn = "children")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dataframe_from_nested_list_+3A_x">x</code></td>
<td>
<p>The nested list</p>
</td></tr>
<tr><td><code id="get_dataframe_from_nested_list_+3A_nestingin">nestingIn</code></td>
<td>
<p>The name containing the nested lists</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nestedList &lt;-
  list(
    id = "x",
    value = "value for x",
    children = list(
      list(
        id = "y",
        value = "value for y"
      ),
      list(
        id = "z",
        value = "value for z"
      )
    )
  );
str(nestedList);
get_dataframe_from_nested_list(nestedList);
</code></pre>

<hr>
<h2 id='get_source_filter'>Create a filter to select utterances in a source</h2><span id='topic+get_source_filter'></span>

<h3>Description</h3>

<p>This function takes a character vector with regular expressions,
a numeric vector with numeric indices, or a logical vector that is either
as long as the source or has length 1; and then always returns a logical
vector of the same length as the source.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_source_filter(
  source,
  filter,
  ignore.case = TRUE,
  invert = FALSE,
  perl = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_source_filter_+3A_source">source</code></td>
<td>
<p>The source to produce the filter for.</p>
</td></tr>
<tr><td><code id="get_source_filter_+3A_filter">filter</code></td>
<td>
<p>THe filtering criterion: a character vector with regular expressions,
a numeric vector with numeric indices, or a logical vector that is either
as long as the source or has length 1.</p>
</td></tr>
<tr><td><code id="get_source_filter_+3A_ignore.case">ignore.case</code></td>
<td>
<p>Whether to apply the regular expression case sensitively
or not (see <code><a href="base.html#topic+grep">base::grepl()</a></code>).</p>
</td></tr>
<tr><td><code id="get_source_filter_+3A_invert">invert</code></td>
<td>
<p>Whether to invert the result or not (i.e. whether the filter
specifies what you want to select (<code>invert=FALSE</code>) or what you don't want
to select (<code>invert=TRUE</code>)).</p>
</td></tr>
<tr><td><code id="get_source_filter_+3A_perl">perl</code></td>
<td>
<p>Whether the regular expression (if <code>filter</code> is a character
vector) is a perl regular expression or not (see <code><a href="base.html#topic+grep">base::grepl()</a></code>).</p>
</td></tr>
<tr><td><code id="get_source_filter_+3A_...">...</code></td>
<td>
<p>Any additional arguments are passed on to <code><a href="base.html#topic+grep">base::grepl()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of the same length as the source.
</p>

<hr>
<h2 id='get_state_transition_df'>Get the state transition data frame</h2><span id='topic+get_state_transition_df'></span>

<h3>Description</h3>

<p>Get the state transition data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_state_transition_df(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_state_transition_df_+3A_x">x</code></td>
<td>
<p>A state transition table as produced by a call
to <code><a href="#topic+get_state_transition_table">get_state_transition_table()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with columns <code>fromState</code>, <code>toState</code>,
and <code>nrOfTransitions</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Get a path to one example file
exampleFile &lt;-
  file.path(examplePath, "state-example-1.rock");

### Parse single example source
parsedExample &lt;- rock::parse_source(exampleFile);

### Show the state transition probabilities
exampleTable &lt;- rock::get_state_transition_table(
  parsedExample
);

exampleStateDf &lt;- rock::get_state_transition_df(
  exampleTable
);

</code></pre>

<hr>
<h2 id='get_state_transition_dot'>Get the state transition data frame</h2><span id='topic+get_state_transition_dot'></span>

<h3>Description</h3>

<p>Get the state transition data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_state_transition_dot(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_state_transition_dot_+3A_x">x</code></td>
<td>
<p>A state transition table as produced by a call
to <code><a href="#topic+get_state_transition_table">get_state_transition_table()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with columns <code>fromState</code>, <code>toState</code>,
and <code>nrOfTransitions</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Get a path to one example file
exampleFile &lt;-
  file.path(examplePath, "state-example-1.rock");

### Parse single example source
parsedExample &lt;- rock::parse_source(exampleFile);

### Show the state transition probabilities
exampleTable &lt;- rock::get_state_transition_table(
  parsedExample
);

exampleStateDf &lt;- rock::get_state_transition_df(
  exampleTable
);

exampleDotCode &lt;- rock::get_state_transition_dot(
  exampleStateDf
);

DiagrammeR::grViz(exampleDotCode);

</code></pre>

<hr>
<h2 id='get_state_transition_table'>Get the state transition table</h2><span id='topic+get_state_transition_table'></span>

<h3>Description</h3>

<p>Get the state transition table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_state_transition_table(x, classIdentifier = "state")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_state_transition_table_+3A_x">x</code></td>
<td>
<p>A parsed source document as provided by <code><a href="#topic+parse_source">parse_source()</a></code>.</p>
</td></tr>
<tr><td><code id="get_state_transition_table_+3A_classidentifier">classIdentifier</code></td>
<td>
<p>The identifier of the class that has the states to
looks at.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table, with the 'from' states as rows and the 'to' states as columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Get a path to one example file
exampleFile &lt;-
  file.path(examplePath, "state-example-1.rock");

### Parse single example source
parsedExample &lt;- rock::parse_source(exampleFile);

### Show the state transition probabilities
rock::get_state_transition_table(
  parsedExample
);

</code></pre>

<hr>
<h2 id='get_utterances_and_codes_from_source'>Get utterances and codes from source</h2><span id='topic+get_utterances_and_codes_from_source'></span>

<h3>Description</h3>

<p>This is a convenience function to use when displaying a source. It returns
an object with the raw and clean utterances in a source, as well as the
utterance identifiers and a list with vectors of the codes for each
utterance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_utterances_and_codes_from_source(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_utterances_and_codes_from_source_+3A_x">x</code></td>
<td>
<p>Either the result of a call to <code><a href="#topic+parse_source">parse_source()</a></code>, or
a path or text to pass to <code><a href="#topic+parse_source">parse_source()</a></code>.</p>
</td></tr>
<tr><td><code id="get_utterances_and_codes_from_source_+3A_...">...</code></td>
<td>
<p>Arguments to <code><a href="#topic+parse_source">parse_source()</a></code>, which is called to
parse the source.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing <code style="white-space: pre;">&#8288;$utterances_raw&#8288;</code>, <code style="white-space: pre;">&#8288;$utterances_clean&#8288;</code>, <code style="white-space: pre;">&#8288;$uids$&#8288;</code>,
<code style="white-space: pre;">&#8288;$codeMatches&#8288;</code>, and <code style="white-space: pre;">&#8288;$codesPerUtterance&#8288;</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Get a path to one example file
exampleFile &lt;-
  file.path(examplePath, "example-1.rock");

### Parse single example source
res &lt;-
  rock::get_utterances_and_codes_from_source(
    exampleFile
  );
</code></pre>

<hr>
<h2 id='get_vectors_from_nested_list'>Return one or more values from a nested list in a list of vectors</h2><span id='topic+get_vectors_from_nested_list'></span>

<h3>Description</h3>

<p>Return one or more values from a nested list in a list of vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_vectors_from_nested_list(x, valuesIn = NULL, nestingIn = "children")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_vectors_from_nested_list_+3A_x">x</code></td>
<td>
<p>The nested list</p>
</td></tr>
<tr><td><code id="get_vectors_from_nested_list_+3A_valuesin">valuesIn</code></td>
<td>
<p>The names holding the values to return (in vectors)</p>
</td></tr>
<tr><td><code id="get_vectors_from_nested_list_+3A_nestingin">nestingIn</code></td>
<td>
<p>The name containing the nested lists</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nestedList &lt;-
  list(
    id = "x",
    value = "value for x",
    children = list(
      list(
        id = "y",
        value = "value for y"
      ),
      list(
        id = "z",
        value = "value for z"
      )
    )
  );
str(nestedList);
get_vectors_from_nested_list(
  nestedList,
  c("id", "value")
);
</code></pre>

<hr>
<h2 id='heading'>Print a heading</h2><span id='topic+heading'></span>

<h3>Description</h3>

<p>This is just a convenience function to print a markdown or HTML heading at
a given 'depth'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heading(
  ...,
  headingLevel = rock::opts$get("defaultHeadingLevel"),
  output = "markdown",
  cat = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heading_+3A_...">...</code></td>
<td>
<p>The heading text: pasted together with no separator.</p>
</td></tr>
<tr><td><code id="heading_+3A_headinglevel">headingLevel</code></td>
<td>
<p>The level of the heading; the default can be set
with e.g. <code>rock::opts$set(defaultHeadingLevel=1)</code>.</p>
</td></tr>
<tr><td><code id="heading_+3A_output">output</code></td>
<td>
<p>Whether to output to HTML (&quot;<code>html</code>&quot;) or markdown (anything
else).</p>
</td></tr>
<tr><td><code id="heading_+3A_cat">cat</code></td>
<td>
<p>Whether to cat (print) the heading or just invisibly return it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The heading, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>heading("Hello ", "World", headingLevel=5);
### This produces: "\n\n##### Hello World\n\n"
</code></pre>

<hr>
<h2 id='heatmap_basic'>Generic convenience function to create a heatmap</h2><span id='topic+heatmap_basic'></span>

<h3>Description</h3>

<p>Generic convenience function to create a heatmap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatmap_basic(
  data,
  x,
  y,
  fill,
  xLab = x,
  yLab = y,
  fillLab = fill,
  plotTitle = "Heatmap",
  fillScale = ggplot2::scale_fill_viridis_c(),
  theme = ggplot2::theme_minimal()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heatmap_basic_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="heatmap_basic_+3A_x">x</code>, <code id="heatmap_basic_+3A_y">y</code>, <code id="heatmap_basic_+3A_fill">fill</code></td>
<td>
<p>The variables (columns) in <code>data</code> to use for the x axis,
y axis, and fill of the heatmap, respectively.</p>
</td></tr>
<tr><td><code id="heatmap_basic_+3A_xlab">xLab</code>, <code id="heatmap_basic_+3A_ylab">yLab</code>, <code id="heatmap_basic_+3A_filllab">fillLab</code></td>
<td>
<p>The labels to use for the x axis, y axis, and fill,
respectively</p>
</td></tr>
<tr><td><code id="heatmap_basic_+3A_plottitle">plotTitle</code></td>
<td>
<p>The plot title.</p>
</td></tr>
<tr><td><code id="heatmap_basic_+3A_fillscale">fillScale</code></td>
<td>
<p>The fill scale.</p>
</td></tr>
<tr><td><code id="heatmap_basic_+3A_theme">theme</code></td>
<td>
<p>The theme.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The heatmap, as a ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rock::heatmap_basic(mtcars, 'am', 'cyl', 'mpg');
</code></pre>

<hr>
<h2 id='inspect_coded_sources'>Read sources from a directory, parse them, and show coded fragments and code tree</h2><span id='topic+inspect_coded_sources'></span>

<h3>Description</h3>

<p>This function combines successive calls to <code><a href="#topic+parse_sources">parse_sources()</a></code>,
<code><a href="#topic+collect_coded_fragments">collect_coded_fragments()</a></code> and <code><a href="#topic+show_inductive_code_tree">show_inductive_code_tree()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inspect_coded_sources(
  path,
  parse_args = list(extension = "rock|dct", regex = NULL, recursive = TRUE,
    ignoreOddDelimiters = FALSE, encoding = rock::opts$get("encoding"), silent =
    rock::opts$get("silent")),
  fragments_args = list(codes = ".*", context = 0),
  inductive_tree_args = list(codes = ".*", output = "both", headingLevel = 3),
  deductive_tree_args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inspect_coded_sources_+3A_path">path</code></td>
<td>
<p>The path containing the sources to parse and inspect.</p>
</td></tr>
<tr><td><code id="inspect_coded_sources_+3A_parse_args">parse_args</code></td>
<td>
<p>The arguments to pass to <code><a href="#topic+parse_sources">parse_sources()</a></code>.</p>
</td></tr>
<tr><td><code id="inspect_coded_sources_+3A_fragments_args">fragments_args</code></td>
<td>
<p>The arguments to pass to <code><a href="#topic+collect_coded_fragments">collect_coded_fragments()</a></code>.</p>
</td></tr>
<tr><td><code id="inspect_coded_sources_+3A_inductive_tree_args">inductive_tree_args</code></td>
<td>
<p>The arguments to pass
to <code><a href="#topic+show_inductive_code_tree">show_inductive_code_tree()</a></code>.</p>
</td></tr>
<tr><td><code id="inspect_coded_sources_+3A_deductive_tree_args">deductive_tree_args</code></td>
<td>
<p>Not yet implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The parsedSources object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Inspect a selection of example sources - this takes too long
### to test, so hence the 'donttest' directive.

rock::inspect_coded_sources(
  examplePath,
  parse_args = list(regex = "test(.txt|.rock)")
);

</code></pre>

<hr>
<h2 id='load_source'>Load a source from a file or a string</h2><span id='topic+load_source'></span><span id='topic+load_sources'></span><span id='topic+loading_sources'></span>

<h3>Description</h3>

<p>These functions load one or more source(s) from a file or
a string and store it in memory for further processing.
Note that you'll probably want to clean the sources
first, using one of the <code><a href="#topic+clean_sources">clean_sources()</a></code> functions,
and you'll probably want to add utterance identifiers
to each utterance using one of the <code><a href="#topic+prepending_uids">prepending_uids()</a></code>
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_source(
  input,
  encoding = rock::opts$get("encoding"),
  silent = rock::opts$get("silent"),
  rlWarn = rock::opts$get(rlWarn),
  diligentWarnings = rock::opts$get("diligentWarnings")
)

load_sources(
  input,
  filenameRegex = ".*",
  ignoreRegex = NULL,
  recursive = TRUE,
  full.names = FALSE,
  encoding = rock::opts$get("encoding"),
  silent = rock::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_source_+3A_input">input</code></td>
<td>
<p>The filename or contents of the source
for <code>load_source</code> and the directory containing the
sources for <code>load_sources</code>.</p>
</td></tr>
<tr><td><code id="load_source_+3A_encoding">encoding</code></td>
<td>
<p>The encoding of the file(s).</p>
</td></tr>
<tr><td><code id="load_source_+3A_silent">silent</code></td>
<td>
<p>Whether to be chatty or quiet.</p>
</td></tr>
<tr><td><code id="load_source_+3A_rlwarn">rlWarn</code></td>
<td>
<p>Whether to let <code><a href="base.html#topic+readLines">readLines()</a></code> warn, e.g. if files do not end
with a newline character.</p>
</td></tr>
<tr><td><code id="load_source_+3A_diligentwarnings">diligentWarnings</code></td>
<td>
<p>Whether to display very diligent warnings.</p>
</td></tr>
<tr><td><code id="load_source_+3A_filenameregex">filenameRegex</code></td>
<td>
<p>A regular expression to match against located files; only
files matching this regular expression are processed.</p>
</td></tr>
<tr><td><code id="load_source_+3A_ignoreregex">ignoreRegex</code></td>
<td>
<p>Regular expression indicating which files to ignore. This
is a perl-style regular expression (see <a href="base.html#topic+regex">base::regex</a>).</p>
</td></tr>
<tr><td><code id="load_source_+3A_recursive">recursive</code></td>
<td>
<p>Whether to search all subdirectories (<code>TRUE</code>) as well or not.</p>
</td></tr>
<tr><td><code id="load_source_+3A_full.names">full.names</code></td>
<td>
<p>Whether to store source names as filenames only or whether
to include paths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, an R character vector of
classes <code>rock_source</code> and <code>character</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Get a path to one example file
exampleFile &lt;-
  file.path(examplePath, "example-1.rock");

### Parse single example source
loadedSource &lt;- rock::load_source(exampleFile);
</code></pre>

<hr>
<h2 id='mask_source'>Masking sources</h2><span id='topic+mask_source'></span><span id='topic+mask_sources'></span><span id='topic+mask_utterances'></span>

<h3>Description</h3>

<p>These functions can be used to mask a set of utterances or one or more sources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mask_source(
  input,
  output = NULL,
  proportionToMask = 1,
  preventOverwriting = rock::opts$get(preventOverwriting),
  encoding = rock::opts$get(encoding),
  rlWarn = rock::opts$get(rlWarn),
  maskRegex = "[[:alnum:]]",
  maskChar = "X",
  perl = TRUE,
  silent = rock::opts$get(silent)
)

mask_sources(
  input,
  output,
  proportionToMask = 1,
  outputPrefix = "",
  outputSuffix = "_masked",
  maskRegex = "[[:alnum:]]",
  maskChar = "X",
  perl = TRUE,
  recursive = TRUE,
  filenameRegex = ".*",
  filenameReplacement = c("_PRIVATE_", "_public_"),
  preventOverwriting = rock::opts$get(preventOverwriting),
  encoding = rock::opts$get(encoding),
  silent = rock::opts$get(silent)
)

mask_utterances(
  input,
  proportionToMask = 1,
  maskRegex = "[[:alnum:]]",
  maskChar = "X",
  perl = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mask_source_+3A_input">input</code></td>
<td>
<p>For <code>mask_utterance</code>, a character vector where each element is one
utterance; for <code>mask_source</code>, either a character vector containing the text of the
relevant source <em>or</em> a path to a file that contains the source text; for <code>mask_sources</code>,
a path to a directory that contains the sources to mask.</p>
</td></tr>
<tr><td><code id="mask_source_+3A_output">output</code></td>
<td>
<p>For <code>mask_source</code>, if not <code>NULL</code>, this is the name (and path) of the
file in which to save the processed source (if it <em>is</em> <code>NULL</code>, the result will be
returned visibly). For <code>mask_sources</code>, <code>output</code> is mandatory and is the path to the
directory where to store the processed sources. This path will be created with a
warning if it does not exist. An exception is if &quot;<code>same</code>&quot; is specified - in that
case, every file will be written to the same directory it was read from.</p>
</td></tr>
<tr><td><code id="mask_source_+3A_proportiontomask">proportionToMask</code></td>
<td>
<p>The proportion of utterances to mask, from 0 (none) to
1 (all).</p>
</td></tr>
<tr><td><code id="mask_source_+3A_preventoverwriting">preventOverwriting</code></td>
<td>
<p>Whether to prevent overwriting of output files.</p>
</td></tr>
<tr><td><code id="mask_source_+3A_encoding">encoding</code></td>
<td>
<p>The encoding of the source(s).</p>
</td></tr>
<tr><td><code id="mask_source_+3A_rlwarn">rlWarn</code></td>
<td>
<p>Whether to let <code><a href="base.html#topic+readLines">readLines()</a></code> warn, e.g. if files do not end
with a newline character.</p>
</td></tr>
<tr><td><code id="mask_source_+3A_maskregex">maskRegex</code></td>
<td>
<p>A regular expresssion (regex) specifying the characters to
mask (i.e. replace with the masking character).</p>
</td></tr>
<tr><td><code id="mask_source_+3A_maskchar">maskChar</code></td>
<td>
<p>The character to replace the character to mask with.</p>
</td></tr>
<tr><td><code id="mask_source_+3A_perl">perl</code></td>
<td>
<p>Whether the regular expression is a perl regex or not.</p>
</td></tr>
<tr><td><code id="mask_source_+3A_silent">silent</code></td>
<td>
<p>Whether to suppress the warning about not editing the cleaned source.</p>
</td></tr>
<tr><td><code id="mask_source_+3A_outputprefix">outputPrefix</code>, <code id="mask_source_+3A_outputsuffix">outputSuffix</code></td>
<td>
<p>The prefix and suffix to add to the
filenames when writing the processed files to disk.</p>
</td></tr>
<tr><td><code id="mask_source_+3A_recursive">recursive</code></td>
<td>
<p>Whether to search all subdirectories (<code>TRUE</code>) as well or not.</p>
</td></tr>
<tr><td><code id="mask_source_+3A_filenameregex">filenameRegex</code></td>
<td>
<p>A regular expression to match against located files; only
files matching this regular expression are processed.</p>
</td></tr>
<tr><td><code id="mask_source_+3A_filenamereplacement">filenameReplacement</code></td>
<td>
<p>A character vector with two elements that represent,
respectively, the <code>pattern</code> and <code>replacement</code> arguments of the <code><a href="base.html#topic+gsub">gsub()</a></code> function.
In other words, the first argument specifies a regular expression to search for
in every processed filename, and the second argument specifies a regular
expression that replaces any matches with the first argument. Set to <code>NULL</code> to
not perform any replacement on the output file name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector for <code>mask_utterance</code> and <code>mask_source</code>, or a list of
character vectors, for <code>mask_sources</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Mask text but not the codes
rock::mask_utterances(
  paste0(
    "Lorem ipsum dolor sit amet, consectetur adipiscing ",
    "elit. [[expAttitude_expectation_73dnt5z1&gt;earplugsFeelUnpleasant]]"
  )
)

</code></pre>

<hr>
<h2 id='match_consecutive_delimiters'>Match the corresponding indices of (YAML) delimiters in a sequential list</h2><span id='topic+match_consecutive_delimiters'></span>

<h3>Description</h3>

<p>This is just a convenience function that takes a vector of deliminaters
and returns a list of delimiter pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_consecutive_delimiters(
  x,
  errorOnInvalidX = FALSE,
  errorOnOdd = FALSE,
  onOddIgnoreFirst = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_consecutive_delimiters_+3A_x">x</code></td>
<td>
<p>The vector with delimiter indices</p>
</td></tr>
<tr><td><code id="match_consecutive_delimiters_+3A_erroroninvalidx">errorOnInvalidX</code></td>
<td>
<p>Whether to return <code>NA</code> (if <code>FALSE</code>) or throw an
error (if <code>TRUE</code>) when <code>x</code> is <code>NULL</code>, <code>NA</code>, or has less than 2 elements.</p>
</td></tr>
<tr><td><code id="match_consecutive_delimiters_+3A_erroronodd">errorOnOdd</code></td>
<td>
<p>Whether to throw an error if the number of delimiter
indices is odd.</p>
</td></tr>
<tr><td><code id="match_consecutive_delimiters_+3A_onoddignorefirst">onOddIgnoreFirst</code></td>
<td>
<p>If the number of delimiter indices is odd and no
error is thrown, whether to ignore the first (<code>TRUE</code>) or the last (<code>FALSE</code>)
delimiter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list where each element is a two-element vector with the two
consecutive delimiters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rock::match_consecutive_delimiters(
  c(1, 3, 5, 10, 19, 25, 30, 70)
);

exampleText &lt;- c(
  "some text",
  "delimiter",
  "more text",
  "delimiter",
  "filler text",
  "intentionally left blank",
  "delimiter",
  "final text",
  "delimiter"
);

rock::match_consecutive_delimiters(
  grep(
    "delimiter",
    exampleText
  )
);
</code></pre>

<hr>
<h2 id='merge_sources'>Merge source files by different coders</h2><span id='topic+merge_sources'></span>

<h3>Description</h3>

<p>This function takes sets of sources and merges them using the utterance
identifiers (UIDs) to match them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_sources(
  input,
  output,
  outputPrefix = "",
  outputSuffix = "_merged",
  primarySourcesRegex = ".*",
  primarySourcesIgnoreRegex = outputSuffix,
  primarySourcesPath = input,
  recursive = TRUE,
  primarySourcesRecursive = recursive,
  filenameRegex = ".*",
  primarySourcesFileList = NULL,
  sourcesFileList = NULL,
  postponeDeductiveTreeBuilding = TRUE,
  ignoreOddDelimiters = FALSE,
  preventOverwriting = rock::opts$get(preventOverwriting),
  encoding = rock::opts$get(encoding),
  silent = rock::opts$get(silent),
  inheritSilence = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_sources_+3A_input">input</code></td>
<td>
<p>The directory containing the input sources.</p>
</td></tr>
<tr><td><code id="merge_sources_+3A_output">output</code></td>
<td>
<p>The path to the directory where to store the merged sources.
This path will be created with a warning if it does not exist. An exception
is if &quot;<code>same</code>&quot; is specified - in that case, every file will be written to the
same directory it was read from.</p>
</td></tr>
<tr><td><code id="merge_sources_+3A_outputprefix">outputPrefix</code>, <code id="merge_sources_+3A_outputsuffix">outputSuffix</code></td>
<td>
<p>A pre- and/or suffix to add to the filename
when writing the merged sources (especially useful when writing them to the
same directory).</p>
</td></tr>
<tr><td><code id="merge_sources_+3A_primarysourcesregex">primarySourcesRegex</code></td>
<td>
<p>A regular expression that specifies how to
recognize the primary sources (i.e. the files used as the basis, to which
the codes from other sources are added).</p>
</td></tr>
<tr><td><code id="merge_sources_+3A_primarysourcesignoreregex">primarySourcesIgnoreRegex</code></td>
<td>
<p>A regular expression that specifies which
files to ignore as primary files.</p>
</td></tr>
<tr><td><code id="merge_sources_+3A_primarysourcespath">primarySourcesPath</code></td>
<td>
<p>The path containing the primary sources.</p>
</td></tr>
<tr><td><code id="merge_sources_+3A_recursive">recursive</code>, <code id="merge_sources_+3A_primarysourcesrecursive">primarySourcesRecursive</code></td>
<td>
<p>Whether to read files from
sub-directories (<code>TRUE</code>) or not.</p>
</td></tr>
<tr><td><code id="merge_sources_+3A_filenameregex">filenameRegex</code></td>
<td>
<p>Only files matching this regular expression are read.</p>
</td></tr>
<tr><td><code id="merge_sources_+3A_primarysourcesfilelist">primarySourcesFileList</code>, <code id="merge_sources_+3A_sourcesfilelist">sourcesFileList</code></td>
<td>
<p>Alternatively to using regular
expressions, lists of full paths and filenames to the primary sources and all
sources to process can be specified using these arguments. If this is used,
neither can be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="merge_sources_+3A_postponedeductivetreebuilding">postponeDeductiveTreeBuilding</code></td>
<td>
<p>Whether to imediately try to build the deductive
tree(s) based on the information in this file (<code>FALSE</code>) or whether to skip that. Skipping
this is useful if the full tree information is distributed over multiple files (in which case
you should probably call <code>parse_sources</code> instead of <code>parse_source</code>).</p>
</td></tr>
<tr><td><code id="merge_sources_+3A_ignoreodddelimiters">ignoreOddDelimiters</code></td>
<td>
<p>If an odd number of YAML delimiters is encountered, whether this
should result in an error (<code>FALSE</code>) or just be silently ignored (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="merge_sources_+3A_preventoverwriting">preventOverwriting</code></td>
<td>
<p>Whether to prevent overwriting existing files or not.</p>
</td></tr>
<tr><td><code id="merge_sources_+3A_encoding">encoding</code></td>
<td>
<p>The encoding of the file to read (in <code>file</code>).</p>
</td></tr>
<tr><td><code id="merge_sources_+3A_silent">silent</code></td>
<td>
<p>Whether to provide (<code>FALSE</code>) or suppress (<code>TRUE</code>) more detailed progress updates.</p>
</td></tr>
<tr><td><code id="merge_sources_+3A_inheritsilence">inheritSilence</code></td>
<td>
<p>If not silent, whether to let functions called
by <code>merge_sources</code> inherit that setting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, a list of the parsed, primary, and merged sources.
</p>

<hr>
<h2 id='number_as_xl_date'>Convert a number to a date using Excel's system</h2><span id='topic+number_as_xl_date'></span>

<h3>Description</h3>

<p>Convert a number to a date using Excel's system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>number_as_xl_date(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="number_as_xl_date_+3A_x">x</code></td>
<td>
<p>The number(s)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The date(s)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>preregr::number_as_xl_date(44113);
</code></pre>

<hr>
<h2 id='opts'>Options for the rock package</h2><span id='topic+opts'></span><span id='topic+set'></span><span id='topic+get'></span><span id='topic+reset'></span>

<h3>Description</h3>

<p>The <code>rock::opts</code> object contains three functions to set, get, and reset
options used by the rock package. Use <code>rock::opts$set</code> to set options,
<code>rock::opts$get</code> to get options, or <code>rock::opts$reset</code> to reset specific or
all options to their default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 4.
</p>


<h3>Details</h3>

<p>It is normally not necessary to get or set <code>rock</code> options. The defaults implement
the Reproducible Open Coding Kit (ROCK) standard, and deviating from these defaults
therefore means the processed sources and codes are not compatible and cannot be
processed by other software that implements the ROCK. Still, in some cases this
degree of customization might be desirable.
</p>
<p>The following arguments can be passed:
</p>

<dl>
<dt>...</dt><dd><p>For <code>rock::opts$set</code>, the dots can be used to specify the options
to set, in the format <code>option = value</code>, for example, <code>utteranceMarker = "\n"</code>. For
<code>rock::opts$reset</code>, a list of options to be reset can be passed.</p>
</dd>
<dt>option</dt><dd><p>For <code>rock::opts$set</code>, the name of the option to set.</p>
</dd>
<dt>default</dt><dd><p>For <code>rock::opts$get</code>, the default value to return if the
option has not been manually specified.</p>
</dd>
</dl>

<p>Some of the options that can be set (see <code>rock::opts$defaults</code> for the
full list):
</p>

<dl>
<dt>codeRegexes</dt><dd><p>A named character vector with one or more regular
expressions that specify how to extract the codes (that were used to code the
sources). These regular expressions <em>must</em> each contain one capturing group
to capture the codes.</p>
</dd>
<dt>idRegexes</dt><dd><p>A named character vector with one or more regular
expressions that specify how to extract the different types of
identifiers. These regular expressions <em>must</em> each contain one capturing group
to capture the identifiers.</p>
</dd>
<dt>sectionRegexes</dt><dd><p>A named character vector with one or more regular
expressions that specify how to extract the different types of sections.</p>
</dd>
<dt>autoGenerateIds</dt><dd><p>The names of the <code>idRegexes</code> that, if missing, should receive
autogenerated identifiers (which consist of 'autogenerated_' followed by an
incrementing number).</p>
</dd>
<dt>noCodes</dt><dd><p>This regular expression is matched with all codes after they have been
extracted using the <code>codeRegexes</code> regular expression (i.e. they're matched against the
codes themselves without, for example, the square brackets in the default code regex). Any
codes matching this <code>noCodes</code> regular expression will be <strong>ignored</strong>, i.e., removed from the
list of codes.</p>
</dd>
<dt>inductiveCodingHierarchyMarker</dt><dd><p>For inductive coding, this marker is used to indicate
hierarchical relationships between codes. The code at the left hand side of this marker will
be considered the parent code of the code on the right hand side. More than two levels
can be specified in one code (for example, if the <code>inductiveCodingHierarchyMarker</code> is '&gt;',
the code <code style="white-space: pre;">&#8288;grandparent&gt;child&gt;grandchild&#8288;</code> would indicate codes at three levels.</p>
</dd>
<dt>attributeContainers</dt><dd><p>The name of YAML fragments containing case attributes (e.g.
metadata, demographic variables, quantitative data about cases, etc).</p>
</dd>
<dt>codesContainers</dt><dd><p>The name of YAML fragments containing (parts of) deductive coding
trees.</p>
</dd>
<dt>delimiterRegEx</dt><dd><p>The regular expression that is used to extract the YAML fragments.</p>
</dd>
<dt>codeDelimiters</dt><dd><p>A character vector of two elements
specifying the opening and closing delimiters of codes (conform
the default ROCK convention, two square brackets). The square
brackets will be escaped; other characters will not, but will
be used as-is.</p>
</dd>
<dt>ignoreRegex</dt><dd><p>The regular expression that is used to delete lines before any other
processing. This can be used to enable adding comments to sources, which are then ignored
during analysis.</p>
</dd>
<dt>includeBootstrap</dt><dd><p>Whether to include the default bootstrap CSS.</p>
</dd>
<dt>utteranceMarker</dt><dd><p>How to specify breaks between utterances in the source(s). The
ROCK convention is to use a newline (<code style="white-space: pre;">&#8288;\\n&#8288;</code>).</p>
</dd>
<dt>coderId</dt><dd><p>A regular expression specifying the coder identifier, specified
similarly to the codeRegexes.</p>
</dd>
<dt>idForOmittedCoderIds</dt><dd><p>The identifier to use for utterances that do not
have a coder id (i.e. utterance that occur in a source that does not specify
a coder id, or above the line where a coder id is specified).</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>### Get the default utteranceMarker
rock::opts$get(utteranceMarker);

### Set it to a custom version, so that every line starts with a pipe
rock::opts$set(utteranceMarker = "\n|");

### Check that it worked
rock::opts$get(utteranceMarker);

### Reset this option to its default value
rock::opts$reset(utteranceMarker);

### Check that the reset worked, too
rock::opts$get(utteranceMarker);

</code></pre>

<hr>
<h2 id='parse_source'>Parsing sources</h2><span id='topic+parse_source'></span><span id='topic+parsing_sources'></span><span id='topic+parse_sources'></span><span id='topic+print.rock_parsedSource'></span><span id='topic+print.rock_parsedSources'></span><span id='topic+plot.rock_parsedSources'></span>

<h3>Description</h3>

<p>These function parse one (<code>parse_source</code>) or more (<code>parse_sources</code>) sources and the
contained identifiers, sections, and codes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_source(
  text,
  file,
  utteranceLabelRegexes = NULL,
  ignoreOddDelimiters = FALSE,
  checkClassInstanceIds = rock::opts$get(checkClassInstanceIds),
  postponeDeductiveTreeBuilding = FALSE,
  filesWithYAML = NULL,
  removeSectionBreakRows = rock::opts$get("removeSectionBreakRows"),
  removeIdentifierRows = rock::opts$get("removeIdentifierRows"),
  removeEmptyRows = rock::opts$get("removeEmptyRows"),
  rlWarn = rock::opts$get("rlWarn"),
  encoding = rock::opts$get("encoding"),
  silent = rock::opts$get("silent")
)

## S3 method for class 'rock_parsedSource'
print(x, prefix = "### ", ...)

parse_sources(
  path,
  extension = "rock|dct",
  regex = NULL,
  recursive = TRUE,
  removeSectionBreakRows = rock::opts$get("removeSectionBreakRows"),
  removeIdentifierRows = rock::opts$get("removeIdentifierRows"),
  removeEmptyRows = rock::opts$get("removeEmptyRows"),
  ignoreOddDelimiters = FALSE,
  checkClassInstanceIds = rock::opts$get(checkClassInstanceIds),
  mergeInductiveTrees = FALSE,
  encoding = rock::opts$get(encoding),
  silent = rock::opts$get(silent)
)

## S3 method for class 'rock_parsedSources'
print(x, prefix = "### ", ...)

## S3 method for class 'rock_parsedSources'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_source_+3A_text">text</code>, <code id="parse_source_+3A_file">file</code></td>
<td>
<p>As <code>text</code> or <code>file</code>, you can specify a <code>file</code> to read with
encoding <code>encoding</code>, which will then be read using <code><a href="base.html#topic+readLines">base::readLines()</a></code>. If the
argument is named <code>text</code>, whether it is the path to an existing file is checked
first, and if it is, that file is read. If the argument is named <code>file</code>, and it
does not point to an existing file, an error is produced (useful if calling
from other functions). A <code>text</code> should be a character vector where every
element is a line of the original source (like provided by <code><a href="base.html#topic+readLines">base::readLines()</a></code>);
although if a character vector of one element <em>and</em> including at least one
newline character (<code style="white-space: pre;">&#8288;\\n&#8288;</code>) is provided as <code>text</code>, it is split at the newline
characters using <code><a href="base.html#topic+strsplit">base::strsplit()</a></code>. Basically, this behavior means that the
first argument can be either a character vector or the path to a file; and if
you're specifying a file and you want to be certain that an error is thrown if
it doesn't exist, make sure to name it <code>file</code>.</p>
</td></tr>
<tr><td><code id="parse_source_+3A_utterancelabelregexes">utteranceLabelRegexes</code></td>
<td>
<p>Optionally, a list with two-element vectors
to preprocess utterances before they are stored as labels (these 'utterance
perl regular expression!</p>
</td></tr>
<tr><td><code id="parse_source_+3A_ignoreodddelimiters">ignoreOddDelimiters</code></td>
<td>
<p>If an odd number of YAML delimiters is encountered, whether this
should result in an error (<code>FALSE</code>) or just be silently ignored (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="parse_source_+3A_checkclassinstanceids">checkClassInstanceIds</code></td>
<td>
<p>Whether to check for the occurrence of class
instance identifiers specified in the attributes.</p>
</td></tr>
<tr><td><code id="parse_source_+3A_postponedeductivetreebuilding">postponeDeductiveTreeBuilding</code></td>
<td>
<p>Whether to imediately try to build the deductive
tree(s) based on the information in this file (<code>FALSE</code>) or whether to skip that. Skipping
this is useful if the full tree information is distributed over multiple files (in which case
you should probably call <code>parse_sources</code> instead of <code>parse_source</code>).</p>
</td></tr>
<tr><td><code id="parse_source_+3A_fileswithyaml">filesWithYAML</code></td>
<td>
<p>Any additional files to process to look for YAML fragments.</p>
</td></tr>
<tr><td><code id="parse_source_+3A_removesectionbreakrows">removeSectionBreakRows</code>, <code id="parse_source_+3A_removeidentifierrows">removeIdentifierRows</code>, <code id="parse_source_+3A_removeemptyrows">removeEmptyRows</code></td>
<td>
<p>Whether to
remove from the QDT, respectively: rows containing section breaks; rows
containing only (class instance) identifiers; and empty rows.</p>
</td></tr>
<tr><td><code id="parse_source_+3A_rlwarn">rlWarn</code></td>
<td>
<p>Whether to let <code><a href="base.html#topic+readLines">readLines()</a></code> warn, e.g. if files do not end
with a newline character.</p>
</td></tr>
<tr><td><code id="parse_source_+3A_encoding">encoding</code></td>
<td>
<p>The encoding of the file to read (in <code>file</code>).</p>
</td></tr>
<tr><td><code id="parse_source_+3A_silent">silent</code></td>
<td>
<p>Whether to provide (<code>FALSE</code>) or suppress (<code>TRUE</code>) more detailed progress updates.</p>
</td></tr>
<tr><td><code id="parse_source_+3A_x">x</code></td>
<td>
<p>The object to print.</p>
</td></tr>
<tr><td><code id="parse_source_+3A_prefix">prefix</code></td>
<td>
<p>The prefix to use before the 'headings' of the printed result.</p>
</td></tr>
<tr><td><code id="parse_source_+3A_...">...</code></td>
<td>
<p>Any additional arguments are passed on to the default print method.</p>
</td></tr>
<tr><td><code id="parse_source_+3A_path">path</code></td>
<td>
<p>The path containing the files to read.</p>
</td></tr>
<tr><td><code id="parse_source_+3A_extension">extension</code></td>
<td>
<p>The extension of the files to read; files with other extensions will
be ignored. Multiple extensions can be separated by a pipe (<code>|</code>).</p>
</td></tr>
<tr><td><code id="parse_source_+3A_regex">regex</code></td>
<td>
<p>Instead of specifing an extension, it's also possible to specify a regular
expression; only files matching this regular expression are read. If specified, <code>regex</code>
takes precedece over <code>extension</code>,</p>
</td></tr>
<tr><td><code id="parse_source_+3A_recursive">recursive</code></td>
<td>
<p>Whether to also process subdirectories (<code>TRUE</code>)
or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="parse_source_+3A_mergeinductivetrees">mergeInductiveTrees</code></td>
<td>
<p>Merge multiple inductive code trees into one; this
functionality is currently not yet implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>rock::parse_source()</code>, an object of class <code>rock_parsedSource</code>;
for <code>rock::parse_sources()</code>, an object of class <code>rock_parsedSources</code>. These
objects contain the original source(s) as well as the final data frame with
utterances and codes, as well as the code structures.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Get a path to one example file
exampleFile &lt;-
  file.path(examplePath, "example-1.rock");

### Parse single example source
parsedExample &lt;- rock::parse_source(exampleFile);

### Show inductive code tree for the codes
### extracted with the regular expression specified with
### the name 'codes':
parsedExample$inductiveCodeTrees$codes;

### If you want `rock` to be chatty, use:
parsedExample &lt;- rock::parse_source(exampleFile,
                                    silent=FALSE);

### Parse as selection of example sources in that directory
parsedExamples &lt;-
  rock::parse_sources(
    examplePath,
    regex = "(test|example)(.txt|.rock)"
  );

### Show combined inductive code tree for the codes
### extracted with the regular expression specified with
### the name 'codes':
parsedExamples$inductiveCodeTrees$codes;

### Show a souce coded with the Qualitative Network Approach
qnaExample &lt;-
  rock::parse_source(
    file.path(
      examplePath,
      "network-example-1.rock"
    )
  );

</code></pre>

<hr>
<h2 id='parse_source_by_coderId'>Parsing sources separately for each coder</h2><span id='topic+parse_source_by_coderId'></span><span id='topic+parse_sources_by_coderId'></span>

<h3>Description</h3>

<p>Parsing sources separately for each coder
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_source_by_coderId(
  input,
  ignoreOddDelimiters = FALSE,
  postponeDeductiveTreeBuilding = TRUE,
  rlWarn = rock::opts$get(rlWarn),
  encoding = "UTF-8",
  silent = TRUE
)

parse_sources_by_coderId(
  input,
  recursive = TRUE,
  filenameRegex = ".*",
  ignoreOddDelimiters = FALSE,
  postponeDeductiveTreeBuilding = TRUE,
  encoding = rock::opts$get(encoding),
  silent = rock::opts$get(silent)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_source_by_coderId_+3A_input">input</code></td>
<td>
<p>For <code>parse_source_by_coderId</code>, either a character vector
containing the text of the relevant source <em>or</em> a path to a file that
contains the source text; for <code>parse_sources_by_coderId</code>, a path to a
directory that contains the sources to parse.</p>
</td></tr>
<tr><td><code id="parse_source_by_coderId_+3A_ignoreodddelimiters">ignoreOddDelimiters</code></td>
<td>
<p>If an odd number of YAML delimiters is encountered, whether this
should result in an error (<code>FALSE</code>) or just be silently ignored (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="parse_source_by_coderId_+3A_postponedeductivetreebuilding">postponeDeductiveTreeBuilding</code></td>
<td>
<p>Whether to imediately try to build the deductive
tree(s) based on the information in this file (<code>FALSE</code>) or whether to skip that. Skipping
this is useful if the full tree information is distributed over multiple files (in which case
you should probably call <code>parse_sources</code> instead of <code>parse_source</code>).</p>
</td></tr>
<tr><td><code id="parse_source_by_coderId_+3A_rlwarn">rlWarn</code></td>
<td>
<p>Whether to let <code><a href="base.html#topic+readLines">readLines()</a></code> warn, e.g. if files do not end
with a newline character.</p>
</td></tr>
<tr><td><code id="parse_source_by_coderId_+3A_encoding">encoding</code></td>
<td>
<p>The encoding of the file to read (in <code>file</code>).</p>
</td></tr>
<tr><td><code id="parse_source_by_coderId_+3A_silent">silent</code></td>
<td>
<p>Whether to provide (<code>FALSE</code>) or suppress (<code>TRUE</code>) more detailed progress updates.</p>
</td></tr>
<tr><td><code id="parse_source_by_coderId_+3A_recursive">recursive</code></td>
<td>
<p>Whether to search all subdirectories (<code>TRUE</code>) as well or not.</p>
</td></tr>
<tr><td><code id="parse_source_by_coderId_+3A_filenameregex">filenameRegex</code></td>
<td>
<p>A regular expression to match against located files; only
files matching this regular expression are processed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>rock::parse_source_by_coderId()</code>, an object of
class <code>rock_parsedSource</code>; for <code>rock::parse_sources_by_coderId()</code>, an
object of class <code>rock_parsedSources</code>. These objects contain the original
source(s) as well as the final data frame with utterances and codes, as
well as the code structures.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Get a path to one example file
exampleFile &lt;-
  file.path(examplePath, "example-1.rock");

### Parse single example source
parsedExample &lt;- rock::parse_source_by_coderId(exampleFile);

</code></pre>

<hr>
<h2 id='parsed_sources_to_ena_network'>Create an ENA network out of one or more parsed sources</h2><span id='topic+parsed_sources_to_ena_network'></span>

<h3>Description</h3>

<p>Create an ENA network out of one or more parsed sources
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parsed_sources_to_ena_network(
  x,
  unitCols,
  conversationCols = "originalSource",
  codes = x$convenience$codingLeaves,
  metadata = x$convenience$attributesVars
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parsed_sources_to_ena_network_+3A_x">x</code></td>
<td>
<p>The parsed source(s) as provided by <code>rock::parse_source</code> or <code>rock::parse_sources</code>.</p>
</td></tr>
<tr><td><code id="parsed_sources_to_ena_network_+3A_unitcols">unitCols</code></td>
<td>
<p>The columns that together define units (e.g. utterances in each
source that belong together, for example because they're about the same topic).</p>
</td></tr>
<tr><td><code id="parsed_sources_to_ena_network_+3A_conversationcols">conversationCols</code></td>
<td>
<p>The columns that together define conversations (e.g. separate
sources, but can be something else, as well).</p>
</td></tr>
<tr><td><code id="parsed_sources_to_ena_network_+3A_codes">codes</code></td>
<td>
<p>The codes to include; by default, takes all codes.</p>
</td></tr>
<tr><td><code id="parsed_sources_to_ena_network_+3A_metadata">metadata</code></td>
<td>
<p>The columns in the merged source dataframe that contain the
metadata. By default, takes all read metadata.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of a call to <code>rENA::ena.plot.network()</code>, if that is
installed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Parse a selection of example sources in that directory
parsedExamples &lt;-
  rock::parse_sources(
    examplePath,
    regex = "(test|example)(.txt|.rock)"
  );

### Add something to indicate which units belong together; normally,
### these would probably be indicated using one of the identifier,
### for example the stanza identifiers, the sid's
nChunks &lt;- nrow(parsedExamples$mergedSourceDf) %/% 10;
parsedExamples$mergedSourceDf$units &lt;-
  c(rep(1:nChunks, each=10), rep(max(nChunks), nrow(parsedExamples$mergedSourceDf) - (10*nChunks)));

### Generate ENA plot

enaPlot &lt;-
  rock::parsed_sources_to_ena_network(parsedExamples,
                                      unitCols='units');

### Show the resulting plot
print(enaPlot);


</code></pre>

<hr>
<h2 id='prepend_ids_to_source'>Prepending unique utterance identifiers</h2><span id='topic+prepend_ids_to_source'></span><span id='topic+prepending_uids'></span><span id='topic+prepend_ids_to_sources'></span>

<h3>Description</h3>

<p>This function prepends unique utterance identifiers to each
utterance (line) in a source. Note that you'll probably want
to clean the sources using <code><a href="#topic+clean_sources">clean_sources()</a></code> first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepend_ids_to_source(
  input,
  output = NULL,
  origin = Sys.time(),
  rlWarn = rock::opts$get(rlWarn),
  preventOverwriting = rock::opts$get(preventOverwriting),
  encoding = rock::opts$get(encoding),
  silent = rock::opts$get(silent)
)

prepend_ids_to_sources(
  input,
  output = NULL,
  outputPrefix = "",
  outputSuffix = "_withUIDs",
  origin = Sys.time(),
  preventOverwriting = rock::opts$get(preventOverwriting),
  encoding = rock::opts$get(encoding),
  silent = rock::opts$get(silent)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepend_ids_to_source_+3A_input">input</code></td>
<td>
<p>The filename or contents of the source
for <code>prepend_ids_to_source</code> and the directory containing the
sources for <code>prepend_ids_to_sources</code>.</p>
</td></tr>
<tr><td><code id="prepend_ids_to_source_+3A_output">output</code></td>
<td>
<p>The filename where to write the resulting file for
<code>prepend_ids_to_source</code> and the directory where to write the
resulting files for <code>prepend_ids_to_sources</code></p>
</td></tr>
<tr><td><code id="prepend_ids_to_source_+3A_origin">origin</code></td>
<td>
<p>The time to use for the first identifier.</p>
</td></tr>
<tr><td><code id="prepend_ids_to_source_+3A_rlwarn">rlWarn</code></td>
<td>
<p>Whether to let <code><a href="base.html#topic+readLines">readLines()</a></code> warn, e.g. if files do not end
with a newline character.</p>
</td></tr>
<tr><td><code id="prepend_ids_to_source_+3A_preventoverwriting">preventOverwriting</code></td>
<td>
<p>Whether to overwrite existing files (<code>FALSE</code>)
or prevent that from happening (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="prepend_ids_to_source_+3A_encoding">encoding</code></td>
<td>
<p>The encoding of the file(s).</p>
</td></tr>
<tr><td><code id="prepend_ids_to_source_+3A_silent">silent</code></td>
<td>
<p>Whether to be chatty or quiet.</p>
</td></tr>
<tr><td><code id="prepend_ids_to_source_+3A_outputprefix">outputPrefix</code>, <code id="prepend_ids_to_source_+3A_outputsuffix">outputSuffix</code></td>
<td>
<p>The prefix and suffix to add to the
filenames when writing the processed files to disk.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The source with prepended uids, either invisible (if <code>output</code>
if specified) or visibly (if not).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Simple example
rock::prepend_ids_to_source(
  "brief\nexample\nsource"
);

### Example including fake YAML fragments
longerExampleText &lt;-
  c(
    "---",
    "First YAML fragment",
    "---",
    "So this is an utterance (i.e. outside of YAML)",
    "This, too.",
    "---",
    "Second fragment",
    "---",
    "Another real utterance outside of YAML",
    "Another one outside",
    "Last 'real utterance'"
  );

rock::prepend_ids_to_source(
  longerExampleText
);

</code></pre>

<hr>
<h2 id='prereg_initialize'>Initialize a (pre)registration</h2><span id='topic+prereg_initialize'></span>

<h3>Description</h3>

<p>To initialize a (pre)registration, pass the URL to a Google Sheet holding
the (pre)registration form specification (in {preregr} format), see the
&quot;<a href="https://r-packages.gitlab.io/preregr/articles/creating_form_from_spreadsheet.html">Creating a form from a spreadsheet</a>&quot;
vignette), the path to a file with a spreadsheet holding such a
specification, or a loaded or imported {preregr} (pre)registration form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prereg_initialize(x, initialText = "Unspecified")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prereg_initialize_+3A_x">x</code></td>
<td>
<p>The (pre)registration form specification, as a URL to a Google
Sheet or online file or as the path to a locally stored file.</p>
</td></tr>
<tr><td><code id="prereg_initialize_+3A_initialtext">initialText</code></td>
<td>
<p>The text to initialize every field with.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an introduction to working with {preregr} (pre)registrations,
see the
&quot;<a href="https://r-packages.gitlab.io/preregr/articles/specifying_prereg_content.html">Specifying preregistration content</a>&quot;
vignette.
</p>


<h3>Value</h3>

<p>The empty (pre)registration specification.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rock::prereg_initialize(
  "preregQE_v0_95"
);
</code></pre>

<hr>
<h2 id='print.rock_graphList'>Plot the graphs in a list of graphs</h2><span id='topic+print.rock_graphList'></span>

<h3>Description</h3>

<p>Plot the graphs in a list of graphs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rock_graphList'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.rock_graphList_+3A_x">x</code></td>
<td>
<p>The list of graphs</p>
</td></tr>
<tr><td><code id="print.rock_graphList_+3A_...">...</code></td>
<td>
<p>Any other arguments are passed to <code><a href="DiagrammeR.html#topic+render_graph">DiagrammeR::render_graph()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x, invisibly
</p>

<hr>
<h2 id='qna_to_tlm'>Convert a QNA network to Linear Topic Map format</h2><span id='topic+qna_to_tlm'></span>

<h3>Description</h3>

<p>The Linear Topic Map format, LTM (<a href="https://ontopia.net/download/ltm.html">https://ontopia.net/download/ltm.html</a>),
allows specification of networks in a human-readable format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qna_to_tlm(
  x,
  topicmapId = "rock_qna_topicmap",
  topicmapTitle = "A ROCK QNA Topic Map"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qna_to_tlm_+3A_x">x</code></td>
<td>
<p>The parsed source object (as produced by <code><a href="#topic+parse_source">parse_source()</a></code>),
or an object holding multiple parsed sources (as produced
by <code><a href="#topic+parse_sources">parse_sources()</a></code>).</p>
</td></tr>
<tr><td><code id="qna_to_tlm_+3A_topicmapid">topicmapId</code>, <code id="qna_to_tlm_+3A_topicmaptitle">topicmapTitle</code></td>
<td>
<p>The topic map's identifier and title.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is a single parsed source: a character vector holding the
Linear Topic Map specification; or, if multiple network coding schemes were
used in parallel, each in a list. If <code>x</code> contains multiple parseds sources,
a list of such objects (i.e., a list of vectors, or a list of lists of
vectors).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Read a souce coded with the Qualitative Network Approach
qnaExample &lt;-
  rock::parse_source(
    file.path(
      examplePath,
      "network-example-1.rock"
    )
  );

### Convert and show the topic map
cat(
  rock::qna_to_tlm(
    qnaExample
  ),
  sep="\n"
);

</code></pre>

<hr>
<h2 id='rbind_df_list'>Bind lots of dataframes together rowwise</h2><span id='topic+rbind_df_list'></span>

<h3>Description</h3>

<p>Bind lots of dataframes together rowwise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbind_df_list(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind_df_list_+3A_x">x</code></td>
<td>
<p>A list of dataframes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rbind_df_list(list(Orange, mtcars, ChickWeight));
</code></pre>

<hr>
<h2 id='rbind_dfs'>Simple alternative for rbind.fill or bind_rows</h2><span id='topic+rbind_dfs'></span>

<h3>Description</h3>

<p>Simple alternative for rbind.fill or bind_rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbind_dfs(x, y, clearRowNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind_dfs_+3A_x">x</code></td>
<td>
<p>One dataframe</p>
</td></tr>
<tr><td><code id="rbind_dfs_+3A_y">y</code></td>
<td>
<p>Another dataframe</p>
</td></tr>
<tr><td><code id="rbind_dfs_+3A_clearrownames">clearRowNames</code></td>
<td>
<p>Whether to clear row names (to avoid duplication)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The merged dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rbind_dfs(Orange, mtcars);
</code></pre>

<hr>
<h2 id='read_spreadsheet'>Convenience function to read spreadsheet-like files</h2><span id='topic+read_spreadsheet'></span>

<h3>Description</h3>

<p>Currently reads spreadsheets from Google Sheets or from <code>xlsx</code>, <code>csv</code>,
or <code>sav</code> files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_spreadsheet(
  x,
  sheet = NULL,
  columnDictionary = NULL,
  localBackup = NULL,
  exportGoogleSheet = FALSE,
  flattenSingleDf = FALSE,
  xlsxPkg = c("rw_xl", "openxlsx", "XLConnect"),
  failQuietly = FALSE,
  silent = rock::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_spreadsheet_+3A_x">x</code></td>
<td>
<p>The URL or path to a file.</p>
</td></tr>
<tr><td><code id="read_spreadsheet_+3A_sheet">sheet</code></td>
<td>
<p>Optionally, the name(s) of the worksheet(s) to select.</p>
</td></tr>
<tr><td><code id="read_spreadsheet_+3A_columndictionary">columnDictionary</code></td>
<td>
<p>Optionally, a dictionary with column names to
check for presence. A named list of vectors.</p>
</td></tr>
<tr><td><code id="read_spreadsheet_+3A_localbackup">localBackup</code></td>
<td>
<p>If not <code>NULL</code>, a valid filename to write a local
backup to.</p>
</td></tr>
<tr><td><code id="read_spreadsheet_+3A_exportgooglesheet">exportGoogleSheet</code></td>
<td>
<p>If <code>x</code> is a URL to a Google Sheet, instead of using
the <code>googlesheets4</code> package to download the data, by passing
<code>exportGoogleSheet=TRUE</code>, an export link will be produced and the data
will be downloaded as Excel spreadsheet.</p>
</td></tr>
<tr><td><code id="read_spreadsheet_+3A_flattensingledf">flattenSingleDf</code></td>
<td>
<p>Whether to return the result as a data frame if
only one data frame is returned as a result.</p>
</td></tr>
<tr><td><code id="read_spreadsheet_+3A_xlsxpkg">xlsxPkg</code></td>
<td>
<p>Which package to use to work with Excel spreadsheets.</p>
</td></tr>
<tr><td><code id="read_spreadsheet_+3A_failquietly">failQuietly</code></td>
<td>
<p>Whether to give an error when <code>x</code> is not a valid URL
or existing file, or just return <code>NULL</code> invisibly.</p>
</td></tr>
<tr><td><code id="read_spreadsheet_+3A_silent">silent</code></td>
<td>
<p>Whether to be silent or chatty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of dataframes, or, if only one data frame was loaded and
<code>flattenSingleDf</code> is <code>TRUE</code>, a data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### This requires an internet connection!
## Not run: 
read_spreadsheet(
  paste0(
    "https://docs.google.com/",
    "spreadsheets/d/",
    "1bHDzpCu4CwEa5_3_q_9vH2691XPhCS3e4Aj_HLhw_U8"
  )
);

## End(Not run)
</code></pre>

<hr>
<h2 id='recode_addChildCodes'>Add child codes under a parent code</h2><span id='topic+recode_addChildCodes'></span>

<h3>Description</h3>

<p>This function conditionally adds new child codes under a code. Where
<code><a href="#topic+recode_split">recode_split()</a></code> removes the original code (splitting
it into the new codes), this function retains the original, adding the new
codes as sub-codes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode_addChildCodes(
  input,
  codes,
  childCodes,
  filter = TRUE,
  output = NULL,
  filenameRegex = ".*",
  outputPrefix = "",
  outputSuffix = "_rcAdded",
  decisionLabel = NULL,
  justification = NULL,
  justificationFile = NULL,
  preventOverwriting = rock::opts$get("preventOverwriting"),
  encoding = rock::opts$get("encoding"),
  silent = rock::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode_addChildCodes_+3A_input">input</code></td>
<td>
<p>One of 1) a character string specifying the path to a file
with a source; 2) an object with a loaded source as produced by a call
to <code><a href="#topic+load_source">load_source()</a></code>; 3) a character string specifying the path to a directory
containing one or more sources; 4) or an object with a list of loaded
sources as produced by a call to <code><a href="#topic+load_sources">load_sources()</a></code>.</p>
</td></tr>
<tr><td><code id="recode_addChildCodes_+3A_codes">codes</code></td>
<td>
<p>A single character value with the code to add the child codes
to.</p>
</td></tr>
<tr><td><code id="recode_addChildCodes_+3A_childcodes">childCodes</code></td>
<td>
<p>A named list with specifying when to add which
child code. Each element of this list is a filtering criterion that will be
passed on to <code><a href="#topic+get_source_filter">get_source_filter()</a></code> to create the actual filter that
will be applied. The name of each element is the code that will be applied
to utterances matching that filter. When calling <code>recode_addChildCodes()</code>
for a single source, instead of passing the filtering criterion, it is also
possible to pass a filter (i.e. the result of the call to
<code><a href="#topic+get_source_filter">get_source_filter()</a></code>), which allows more finegrained control. Note
that these 'child code filters' and the corresponding codes are processed
sequentially in the order specified in <code>childCodes</code>. Any utterances coded
with the code specified in <code>codes</code> that do not match with any of the 'child
code filters' specified as the <code>childCodes</code> elements will remain unchanged.
To create a catch-all ('else') category, pass <code>".*"</code> or <code>TRUE</code> as
a filter (see the example).</p>
</td></tr>
<tr><td><code id="recode_addChildCodes_+3A_filter">filter</code></td>
<td>
<p>Optionally, a filter to apply to specify a subset of the
source(s) to process (see <code><a href="#topic+get_source_filter">get_source_filter()</a></code>).</p>
</td></tr>
<tr><td><code id="recode_addChildCodes_+3A_output">output</code></td>
<td>
<p>If specified, the recoded source(s) will be written here.</p>
</td></tr>
<tr><td><code id="recode_addChildCodes_+3A_filenameregex">filenameRegex</code></td>
<td>
<p>Only process files matching this regular expression.</p>
</td></tr>
<tr><td><code id="recode_addChildCodes_+3A_outputprefix">outputPrefix</code>, <code id="recode_addChildCodes_+3A_outputsuffix">outputSuffix</code></td>
<td>
<p>The prefix and suffix to add to the
filenames when writing the processed files to disk, in case multiple
sources are passed as input.</p>
</td></tr>
<tr><td><code id="recode_addChildCodes_+3A_decisionlabel">decisionLabel</code></td>
<td>
<p>A description of the (recoding) decision that was taken.</p>
</td></tr>
<tr><td><code id="recode_addChildCodes_+3A_justification">justification</code></td>
<td>
<p>The justification for this action.</p>
</td></tr>
<tr><td><code id="recode_addChildCodes_+3A_justificationfile">justificationFile</code></td>
<td>
<p>If specified, the justification is appended to
this file. If not, it is saved to the <code>justifier::workspace()</code>. This can
then be saved or displayed at the end of the R Markdown file or R script
using <code>justifier::save_workspace()</code>.</p>
</td></tr>
<tr><td><code id="recode_addChildCodes_+3A_preventoverwriting">preventOverwriting</code></td>
<td>
<p>Whether to prevent overwriting existing files
when writing the files to <code>output</code>.</p>
</td></tr>
<tr><td><code id="recode_addChildCodes_+3A_encoding">encoding</code></td>
<td>
<p>The encoding to use.</p>
</td></tr>
<tr><td><code id="recode_addChildCodes_+3A_silent">silent</code></td>
<td>
<p>Whether to be chatty or quiet.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the changed source(s) or source(s) object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Get a path to one example file
exampleFile &lt;-
  file.path(examplePath, "example-1.rock");

### Load example source
loadedExampleSource &lt;- rock::load_source(exampleFile);

### Split a code into two codes, showing progress (the backticks are
### used to be able to specify a name that starts with an underscore)
recoded_source &lt;-
  rock::recode_addChildCodes(
    loadedExampleSource,
    codes="childCode1",
    childCodes = list(
      `_and_` = " and ",
      `_book_` = "book",
      `_else_` = TRUE
    ),
    silent=FALSE
  );
</code></pre>

<hr>
<h2 id='recode_delete'>Remove one or more codes</h2><span id='topic+recode_delete'></span>

<h3>Description</h3>

<p>These functions remove one or more codes from a source, and make it easy to
justify that decision.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode_delete(
  input,
  codes,
  filter = TRUE,
  output = NULL,
  filenameRegex = ".*",
  outputPrefix = "",
  outputSuffix = "_rcDeleted",
  childrenReplaceParents = TRUE,
  recursiveDeletion = FALSE,
  decisionLabel = NULL,
  justification = NULL,
  justificationFile = NULL,
  preventOverwriting = rock::opts$get("preventOverwriting"),
  encoding = rock::opts$get("encoding"),
  silent = rock::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode_delete_+3A_input">input</code></td>
<td>
<p>One of 1) a character string specifying the path to a file
with a source; 2) an object with a loaded source as produced by a call
to <code><a href="#topic+load_source">load_source()</a></code>; 3) a character string specifying the path to a directory
containing one or more sources; 4) or an object with a list of loaded
sources as produced by a call to <code><a href="#topic+load_sources">load_sources()</a></code>.</p>
</td></tr>
<tr><td><code id="recode_delete_+3A_codes">codes</code></td>
<td>
<p>A character vector with codes to remove.</p>
</td></tr>
<tr><td><code id="recode_delete_+3A_filter">filter</code></td>
<td>
<p>Optionally, a filter to apply to specify a subset of the
source(s) to process (see <code><a href="#topic+get_source_filter">get_source_filter()</a></code>).</p>
</td></tr>
<tr><td><code id="recode_delete_+3A_output">output</code></td>
<td>
<p>If specified, the recoded source(s) will be written here.</p>
</td></tr>
<tr><td><code id="recode_delete_+3A_filenameregex">filenameRegex</code></td>
<td>
<p>Only process files matching this regular expression.</p>
</td></tr>
<tr><td><code id="recode_delete_+3A_outputprefix">outputPrefix</code>, <code id="recode_delete_+3A_outputsuffix">outputSuffix</code></td>
<td>
<p>The prefix and suffix to add to the
filenames when writing the processed files to disk, in case multiple
sources are passed as input.</p>
</td></tr>
<tr><td><code id="recode_delete_+3A_childrenreplaceparents">childrenReplaceParents</code></td>
<td>
<p>Whether children should be deleted (<code>FALSE</code>)
or take their parent code's place (<code>TRUE</code>). This is ignored if
<code>recursiveDeletion=TRUE</code>, in which case children are always deleted.</p>
</td></tr>
<tr><td><code id="recode_delete_+3A_recursivedeletion">recursiveDeletion</code></td>
<td>
<p>Whether to also delete a code's parents (<code>TRUE</code>),
if they have no other children, and keep doing this until the root is
reached, or whether to leave parent codes alone (<code>FALSE</code>). This takes
precedence over <code>childrenReplaceParents</code>.</p>
</td></tr>
<tr><td><code id="recode_delete_+3A_decisionlabel">decisionLabel</code></td>
<td>
<p>A description of the (recoding) decision that was taken.</p>
</td></tr>
<tr><td><code id="recode_delete_+3A_justification">justification</code></td>
<td>
<p>The justification for this action.</p>
</td></tr>
<tr><td><code id="recode_delete_+3A_justificationfile">justificationFile</code></td>
<td>
<p>If specified, the justification is appended to
this file. If not, it is saved to the <code>justifier::workspace()</code>. This can
then be saved or displayed at the end of the R Markdown file or R script
using <code>justifier::save_workspace()</code>.</p>
</td></tr>
<tr><td><code id="recode_delete_+3A_preventoverwriting">preventOverwriting</code></td>
<td>
<p>Whether to prevent overwriting existing files
when writing the files to <code>output</code>.</p>
</td></tr>
<tr><td><code id="recode_delete_+3A_encoding">encoding</code></td>
<td>
<p>The encoding to use.</p>
</td></tr>
<tr><td><code id="recode_delete_+3A_silent">silent</code></td>
<td>
<p>Whether to be chatty or quiet.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the recoded source(s) or source(s) object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Get a path to one example file
exampleFile &lt;-
  file.path(examplePath, "example-1.rock");

### Load example source
loadedExample &lt;- rock::load_source(exampleFile);

### Delete two codes, moving children to the codes' parents
recoded_source &lt;-
  rock::recode_delete(
    loadedExample,
    codes=c("childCode2", "childCode1"),
    silent=FALSE
  );

### Process an entire directory
list_of_recoded_sources &lt;-
  rock::recode_delete(
    examplePath,
    codes=c("childCode2", "childCode1"),
    silent=FALSE
  );

</code></pre>

<hr>
<h2 id='recode_merge'>Merge two or more codes</h2><span id='topic+recode_merge'></span>

<h3>Description</h3>

<p>This function merges two or more codes into one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode_merge(
  input,
  codes,
  mergeToCode,
  filter = TRUE,
  output = NULL,
  filenameRegex = ".*",
  outputPrefix = "",
  outputSuffix = "_rcMerged",
  decisionLabel = NULL,
  justification = NULL,
  justificationFile = NULL,
  preventOverwriting = rock::opts$get("preventOverwriting"),
  encoding = rock::opts$get("encoding"),
  silent = rock::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode_merge_+3A_input">input</code></td>
<td>
<p>One of 1) a character string specifying the path to a file
with a source; 2) an object with a loaded source as produced by a call
to <code><a href="#topic+load_source">load_source()</a></code>; 3) a character string specifying the path to a directory
containing one or more sources; 4) or an object with a list of loaded
sources as produced by a call to <code><a href="#topic+load_sources">load_sources()</a></code>.</p>
</td></tr>
<tr><td><code id="recode_merge_+3A_codes">codes</code></td>
<td>
<p>A character vector with the codes to merge.</p>
</td></tr>
<tr><td><code id="recode_merge_+3A_mergetocode">mergeToCode</code></td>
<td>
<p>A single character vector with the merged code.</p>
</td></tr>
<tr><td><code id="recode_merge_+3A_filter">filter</code></td>
<td>
<p>Optionally, a filter to apply to specify a subset of the
source(s) to process (see <code><a href="#topic+get_source_filter">get_source_filter()</a></code>).</p>
</td></tr>
<tr><td><code id="recode_merge_+3A_output">output</code></td>
<td>
<p>If specified, the recoded source(s) will be written here.</p>
</td></tr>
<tr><td><code id="recode_merge_+3A_filenameregex">filenameRegex</code></td>
<td>
<p>Only process files matching this regular expression.</p>
</td></tr>
<tr><td><code id="recode_merge_+3A_outputprefix">outputPrefix</code>, <code id="recode_merge_+3A_outputsuffix">outputSuffix</code></td>
<td>
<p>The prefix and suffix to add to the
filenames when writing the processed files to disk, in case multiple
sources are passed as input.</p>
</td></tr>
<tr><td><code id="recode_merge_+3A_decisionlabel">decisionLabel</code></td>
<td>
<p>A description of the (recoding) decision that was taken.</p>
</td></tr>
<tr><td><code id="recode_merge_+3A_justification">justification</code></td>
<td>
<p>The justification for this action.</p>
</td></tr>
<tr><td><code id="recode_merge_+3A_justificationfile">justificationFile</code></td>
<td>
<p>If specified, the justification is appended to
this file. If not, it is saved to the <code>justifier::workspace()</code>. This can
then be saved or displayed at the end of the R Markdown file or R script
using <code>justifier::save_workspace()</code>.</p>
</td></tr>
<tr><td><code id="recode_merge_+3A_preventoverwriting">preventOverwriting</code></td>
<td>
<p>Whether to prevent overwriting existing files
when writing the files to <code>output</code>.</p>
</td></tr>
<tr><td><code id="recode_merge_+3A_encoding">encoding</code></td>
<td>
<p>The encoding to use.</p>
</td></tr>
<tr><td><code id="recode_merge_+3A_silent">silent</code></td>
<td>
<p>Whether to be chatty or quiet.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the changed source(s) or source(s) object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Get a path to one example file
exampleFile &lt;-
  file.path(examplePath, "example-1.rock");

### Load example source
loadedExample &lt;- rock::load_source(exampleFile);

### Move two codes to a new parent, showing progress
recoded_source &lt;-
  rock::recode_merge(
    loadedExample,
    codes=c("childCode2", "grandchildCode2"),
    mergeToCode="mergedCode",
    silent=FALSE
  );
</code></pre>

<hr>
<h2 id='recode_move'>Move one or more codes to a different parent</h2><span id='topic+recode_move'></span>

<h3>Description</h3>

<p>These functions move a code to a different parent (and therefore,
ancestry) in one or more sources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode_move(
  input,
  codes,
  newAncestry,
  filter = TRUE,
  output = NULL,
  filenameRegex = ".*",
  outputPrefix = "",
  outputSuffix = "_rcMoved",
  decisionLabel = NULL,
  justification = NULL,
  justificationFile = NULL,
  preventOverwriting = rock::opts$get("preventOverwriting"),
  encoding = rock::opts$get("encoding"),
  silent = rock::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode_move_+3A_input">input</code></td>
<td>
<p>One of 1) a character string specifying the path to a file
with a source; 2) an object with a loaded source as produced by a call
to <code><a href="#topic+load_source">load_source()</a></code>; 3) a character string specifying the path to a directory
containing one or more sources; 4) or an object with a list of loaded
sources as produced by a call to <code><a href="#topic+load_sources">load_sources()</a></code>.</p>
</td></tr>
<tr><td><code id="recode_move_+3A_codes">codes</code></td>
<td>
<p>A character vector with codes to move.</p>
</td></tr>
<tr><td><code id="recode_move_+3A_newancestry">newAncestry</code></td>
<td>
<p>The new parent code, optionally including the partial
or full ancestry (i.e. the path of parent codes all the way up to the root).</p>
</td></tr>
<tr><td><code id="recode_move_+3A_filter">filter</code></td>
<td>
<p>Optionally, a filter to apply to specify a subset of the
source(s) to process (see <code><a href="#topic+get_source_filter">get_source_filter()</a></code>).</p>
</td></tr>
<tr><td><code id="recode_move_+3A_output">output</code></td>
<td>
<p>If specified, the recoded source(s) will be written here.</p>
</td></tr>
<tr><td><code id="recode_move_+3A_filenameregex">filenameRegex</code></td>
<td>
<p>Only process files matching this regular expression.</p>
</td></tr>
<tr><td><code id="recode_move_+3A_outputprefix">outputPrefix</code>, <code id="recode_move_+3A_outputsuffix">outputSuffix</code></td>
<td>
<p>The prefix and suffix to add to the
filenames when writing the processed files to disk, in case multiple
sources are passed as input.</p>
</td></tr>
<tr><td><code id="recode_move_+3A_decisionlabel">decisionLabel</code></td>
<td>
<p>A description of the (recoding) decision that was taken.</p>
</td></tr>
<tr><td><code id="recode_move_+3A_justification">justification</code></td>
<td>
<p>The justification for this action.</p>
</td></tr>
<tr><td><code id="recode_move_+3A_justificationfile">justificationFile</code></td>
<td>
<p>If specified, the justification is appended to
this file. If not, it is saved to the <code>justifier::workspace()</code>. This can
then be saved or displayed at the end of the R Markdown file or R script
using <code>justifier::save_workspace()</code>.</p>
</td></tr>
<tr><td><code id="recode_move_+3A_preventoverwriting">preventOverwriting</code></td>
<td>
<p>Whether to prevent overwriting existing files
when writing the files to <code>output</code>.</p>
</td></tr>
<tr><td><code id="recode_move_+3A_encoding">encoding</code></td>
<td>
<p>The encoding to use.</p>
</td></tr>
<tr><td><code id="recode_move_+3A_silent">silent</code></td>
<td>
<p>Whether to be chatty or quiet.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the changed source(s) or source(s) object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Get a path to one example file
exampleFile &lt;-
  file.path(examplePath, "example-1.rock");

### Load example source
loadedExample &lt;- rock::load_source(exampleFile);

### Move two codes to a new parent, showing progress
recoded_source &lt;-
  rock::recode_move(
    loadedExample,
    codes=c("childCode2", "childCode1"),
    newAncestry = "parentCode2",
    silent=FALSE
  );
</code></pre>

<hr>
<h2 id='recode_rename'>Rename one or more codes</h2><span id='topic+recode_rename'></span>

<h3>Description</h3>

<p>These functions rename one or more codes in one or more sources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode_rename(
  input,
  codes,
  filter = TRUE,
  output = NULL,
  filenameRegex = ".*",
  outputPrefix = "",
  outputSuffix = "_rcRenamed",
  decisionLabel = NULL,
  justification = NULL,
  justificationFile = NULL,
  preventOverwriting = rock::opts$get("preventOverwriting"),
  encoding = rock::opts$get("encoding"),
  silent = rock::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode_rename_+3A_input">input</code></td>
<td>
<p>One of 1) a character string specifying the path to a file
with a source; 2) an object with a loaded source as produced by a call
to <code><a href="#topic+load_source">load_source()</a></code>; 3) a character string specifying the path to a directory
containing one or more sources; 4) or an object with a list of loaded
sources as produced by a call to <code><a href="#topic+load_sources">load_sources()</a></code>.</p>
</td></tr>
<tr><td><code id="recode_rename_+3A_codes">codes</code></td>
<td>
<p>A named character vector with codes to rename. Each element
should be the new code, and the element's name should be the old code (so
e.g. <code>codes = c(oldcode1 = 'newcode1', oldcode2 = 'newcode2')</code>).</p>
</td></tr>
<tr><td><code id="recode_rename_+3A_filter">filter</code></td>
<td>
<p>Optionally, a filter to apply to specify a subset of the
source(s) to process (see <code><a href="#topic+get_source_filter">get_source_filter()</a></code>).</p>
</td></tr>
<tr><td><code id="recode_rename_+3A_output">output</code></td>
<td>
<p>If specified, the recoded source(s) will be written here.</p>
</td></tr>
<tr><td><code id="recode_rename_+3A_filenameregex">filenameRegex</code></td>
<td>
<p>Only process files matching this regular expression.</p>
</td></tr>
<tr><td><code id="recode_rename_+3A_outputprefix">outputPrefix</code>, <code id="recode_rename_+3A_outputsuffix">outputSuffix</code></td>
<td>
<p>The prefix and suffix to add to the
filenames when writing the processed files to disk, in case multiple
sources are passed as input.</p>
</td></tr>
<tr><td><code id="recode_rename_+3A_decisionlabel">decisionLabel</code></td>
<td>
<p>A description of the (recoding) decision that was taken.</p>
</td></tr>
<tr><td><code id="recode_rename_+3A_justification">justification</code></td>
<td>
<p>The justification for this action.</p>
</td></tr>
<tr><td><code id="recode_rename_+3A_justificationfile">justificationFile</code></td>
<td>
<p>If specified, the justification is appended to
this file. If not, it is saved to the <code>justifier::workspace()</code>. This can
then be saved or displayed at the end of the R Markdown file or R script
using <code>justifier::save_workspace()</code>.</p>
</td></tr>
<tr><td><code id="recode_rename_+3A_preventoverwriting">preventOverwriting</code></td>
<td>
<p>Whether to prevent overwriting existing files
when writing the files to <code>output</code>.</p>
</td></tr>
<tr><td><code id="recode_rename_+3A_encoding">encoding</code></td>
<td>
<p>The encoding to use.</p>
</td></tr>
<tr><td><code id="recode_rename_+3A_silent">silent</code></td>
<td>
<p>Whether to be chatty or quiet.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the changed source(s) or source(s) object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Get a path to one example file
exampleFile &lt;-
  file.path(examplePath, "example-1.rock");

### Load example source
loadedExample &lt;- rock::load_source(exampleFile);

### Move two codes to a new parent, showing progress
recoded_source &lt;-
  rock::recode_rename(
    loadedExample,
    codes=c(childCode2 = "grownUpCode2",
            grandchildCode2 = "almostChildCode2"),
    silent=FALSE
  );
</code></pre>

<hr>
<h2 id='recode_split'>Split a code into multiple codes</h2><span id='topic+recode_split'></span>

<h3>Description</h3>

<p>This function conditionally splits a code into multiple codes. Note that you
may want to use <code><a href="#topic+recode_addChildCodes">recode_addChildCodes()</a></code> instead to not lose the
original coding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode_split(
  input,
  codes,
  splitToCodes,
  filter = TRUE,
  output = NULL,
  filenameRegex = ".*",
  outputPrefix = "",
  outputSuffix = "_recoded",
  decisionLabel = NULL,
  justification = NULL,
  justificationFile = NULL,
  preventOverwriting = rock::opts$get("preventOverwriting"),
  encoding = rock::opts$get("encoding"),
  silent = rock::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode_split_+3A_input">input</code></td>
<td>
<p>One of 1) a character string specifying the path to a file
with a source; 2) an object with a loaded source as produced by a call
to <code><a href="#topic+load_source">load_source()</a></code>; 3) a character string specifying the path to a directory
containing one or more sources; 4) or an object with a list of loaded
sources as produced by a call to <code><a href="#topic+load_sources">load_sources()</a></code>.</p>
</td></tr>
<tr><td><code id="recode_split_+3A_codes">codes</code></td>
<td>
<p>A single character value with the code to split.</p>
</td></tr>
<tr><td><code id="recode_split_+3A_splittocodes">splitToCodes</code></td>
<td>
<p>A named list with specifying when to split to which
new code. Each element of this list is a filtering criterion that will be
passed on to <code><a href="#topic+get_source_filter">get_source_filter()</a></code> to create the actual filter that
will be applied. The name of each element is the code that will be applied
to utterances matching that filter. When calling <code>recode_split()</code> for a
single source, instead of passing the filtering criterion, it is also
possible to pass a filter (i.e. the result of the call to
<code><a href="#topic+get_source_filter">get_source_filter()</a></code>), which allows more finegrained control. Note
that these split filters and the corresponding codes are processed
sequentially in the order specified in <code>splitToCodes</code>. This means that once
an utterance that was coded with <code>codes</code> has been matched to one of these
'split filters' (and so, recoded with the corresponding 'split code', i.e.,
with the name of that split filter in <code>splitToCodes</code>), it will not be
recoded again even if it also matches with other split filters down the
line. Any utterances coded with the code to split up (i.e. specified in
<code>codes</code>) that do not match with any of the split filters specified as the
<code>splitToCodes</code> elements will not be recoded and so remain coded with
<code>codes</code>. To create a catch-all ('else') category, pass <code>".*"</code> or <code>TRUE</code> as
a filter (see the example).</p>
</td></tr>
<tr><td><code id="recode_split_+3A_filter">filter</code></td>
<td>
<p>Optionally, a filter to apply to specify a subset of the
source(s) to process (see <code><a href="#topic+get_source_filter">get_source_filter()</a></code>).</p>
</td></tr>
<tr><td><code id="recode_split_+3A_output">output</code></td>
<td>
<p>If specified, the recoded source(s) will be written here.</p>
</td></tr>
<tr><td><code id="recode_split_+3A_filenameregex">filenameRegex</code></td>
<td>
<p>Only process files matching this regular expression.</p>
</td></tr>
<tr><td><code id="recode_split_+3A_outputprefix">outputPrefix</code>, <code id="recode_split_+3A_outputsuffix">outputSuffix</code></td>
<td>
<p>The prefix and suffix to add to the
filenames when writing the processed files to disk, in case multiple
sources are passed as input.</p>
</td></tr>
<tr><td><code id="recode_split_+3A_decisionlabel">decisionLabel</code></td>
<td>
<p>A description of the (recoding) decision that was taken.</p>
</td></tr>
<tr><td><code id="recode_split_+3A_justification">justification</code></td>
<td>
<p>The justification for this action.</p>
</td></tr>
<tr><td><code id="recode_split_+3A_justificationfile">justificationFile</code></td>
<td>
<p>If specified, the justification is appended to
this file. If not, it is saved to the <code><a href="justifier.html#topic+workspace">justifier::workspace()</a></code>. This can
then be saved or displayed at the end of the R Markdown file or R script
using <code><a href="justifier.html#topic+save_workspace">justifier::save_workspace()</a></code>.</p>
</td></tr>
<tr><td><code id="recode_split_+3A_preventoverwriting">preventOverwriting</code></td>
<td>
<p>Whether to prevent overwriting existing files
when writing the files to <code>output</code>.</p>
</td></tr>
<tr><td><code id="recode_split_+3A_encoding">encoding</code></td>
<td>
<p>The encoding to use.</p>
</td></tr>
<tr><td><code id="recode_split_+3A_silent">silent</code></td>
<td>
<p>Whether to be chatty or quiet.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the changed source(s) or source(s) object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Get a path to one example file
exampleFile &lt;-
  file.path(examplePath, "example-1.rock");

### Load example source
loadedExample &lt;- rock::load_source(exampleFile);

### Split a code into two codes, showing progress
recoded_source &lt;-
  rock::recode_split(
    loadedExample,
    codes="childCode1",
    splitToCodes = list(
      and_REPLACED = " and ",
      book_REPLACED = "book",
      else_REPLACED = TRUE
    ),
    silent=FALSE
  );
</code></pre>

<hr>
<h2 id='repeatStr'>Repeat a string a number of times</h2><span id='topic+repeatStr'></span><span id='topic+repStr'></span>

<h3>Description</h3>

<p>Repeat a string a number of times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repeatStr(n = 1, str = " ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repeatStr_+3A_n">n</code>, <code id="repeatStr_+3A_str">str</code></td>
<td>
<p>Normally, respectively the frequency with which to
repeat the string and the string to repeat; but the order of the
inputs can be switched as well.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of length 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### 10 spaces:
repStr(10);

### Three euro symbols:
repStr("\u20ac", 3);
</code></pre>

<hr>
<h2 id='resultsOverview_allCodedFragments'>Show all coded fragments</h2><span id='topic+resultsOverview_allCodedFragments'></span>

<h3>Description</h3>

<p>Show all coded fragments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resultsOverview_allCodedFragments(
  x,
  root = "codes",
  context = 0,
  heading = NULL,
  headingLevel = 2,
  add_html_tags = TRUE,
  cleanUtterances = FALSE,
  output = NULL,
  outputViewer = "viewer",
  template = "default",
  includeCSS = TRUE,
  includeBootstrap = rock::opts$get("includeBootstrap"),
  preventOverwriting = rock::opts$get(preventOverwriting),
  silent = rock::opts$get(silent)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resultsOverview_allCodedFragments_+3A_x">x</code></td>
<td>
<p>The parsed source(s) as provided by <code>rock::parse_source</code>
or <code>rock::parse_sources</code>.</p>
</td></tr>
<tr><td><code id="resultsOverview_allCodedFragments_+3A_root">root</code></td>
<td>
<p>The root code</p>
</td></tr>
<tr><td><code id="resultsOverview_allCodedFragments_+3A_context">context</code></td>
<td>
<p>How many utterances before and after the target
utterances to include in the fragments. If two values, the first is the
number of utterances before, and the second, the number of utterances
after the target utterances.</p>
</td></tr>
<tr><td><code id="resultsOverview_allCodedFragments_+3A_heading">heading</code></td>
<td>
<p>Optionally, a title to include in the output. The title
will be prefixed with <code>headingLevel</code> hashes (<code style="white-space: pre;">&#8288;#&#8288;</code>), and the codes with
<code>headingLevel+1</code> hashes. If <code>NULL</code> (the default), a heading will be
generated that includes the collected codes if those are five or less.
If a character value is specified, that will be used. To omit a heading,
set to anything that is not <code>NULL</code> or a character vector (e.g. <code>FALSE</code>).
If no heading is used, the code prefix will be <code>headingLevel</code> hashes,
instead of <code>headingLevel+1</code> hashes.</p>
</td></tr>
<tr><td><code id="resultsOverview_allCodedFragments_+3A_headinglevel">headingLevel</code></td>
<td>
<p>The number of hashes to insert before the headings.</p>
</td></tr>
<tr><td><code id="resultsOverview_allCodedFragments_+3A_add_html_tags">add_html_tags</code></td>
<td>
<p>Whether to add HTML tags to the result.</p>
</td></tr>
<tr><td><code id="resultsOverview_allCodedFragments_+3A_cleanutterances">cleanUtterances</code></td>
<td>
<p>Whether to use the clean or the raw utterances
when constructing the fragments (the raw versions contain all codes). Note that
this should be set to <code>FALSE</code> to have <code>add_html_tags</code> be of the most use.</p>
</td></tr>
<tr><td><code id="resultsOverview_allCodedFragments_+3A_output">output</code></td>
<td>
<p>Here, a path and filename can be provided where the
result will be written. If provided, the result will be returned
invisibly.</p>
</td></tr>
<tr><td><code id="resultsOverview_allCodedFragments_+3A_outputviewer">outputViewer</code></td>
<td>
<p>If showing output, where to show the output: in
the console (<code>outputViewer='console'</code>) or in the viewer
(<code>outputViewer='viewer'</code>), e.g. the RStudio viewer. You'll usually want
the latter when outputting HTML, and otherwise the former. Set to <code>FALSE</code>
to not output anything to the console or the viewer.</p>
</td></tr>
<tr><td><code id="resultsOverview_allCodedFragments_+3A_template">template</code></td>
<td>
<p>The template to load; either the name of one
of the ROCK templates (currently, only 'default' is available), or
the path and filename of a CSS file.</p>
</td></tr>
<tr><td><code id="resultsOverview_allCodedFragments_+3A_includecss">includeCSS</code></td>
<td>
<p>Whether to include the ROCK CSS in the returned HTML.</p>
</td></tr>
<tr><td><code id="resultsOverview_allCodedFragments_+3A_includebootstrap">includeBootstrap</code></td>
<td>
<p>Whether to include the default bootstrap CSS.</p>
</td></tr>
<tr><td><code id="resultsOverview_allCodedFragments_+3A_preventoverwriting">preventOverwriting</code></td>
<td>
<p>Whether to prevent overwriting of output files.</p>
</td></tr>
<tr><td><code id="resultsOverview_allCodedFragments_+3A_silent">silent</code></td>
<td>
<p>Whether to provide (<code>FALSE</code>) or suppress (<code>TRUE</code>) more detailed progress updates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the coded fragments in a character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Get a path to one example file
exampleFile &lt;-
  file.path(
    examplePath, "example-1.rock"
  );

### Parse single example source
parsedExample &lt;-
  rock::parse_source(
    exampleFile
  );

### Show organised coded fragments in Markdown
cat(
  rock::resultsOverview_allCodedFragments(
    parsedExample
  )
);

</code></pre>

<hr>
<h2 id='rock'>rock: A Reproducible Open Coding Kit</h2><span id='topic+rock'></span>

<h3>Description</h3>

<p>This package implements an open standard for working with
qualitative data, as such, it has two parts: a file format/convention
and this R package that facilitates working with .rock files.
</p>


<h3>The ROCK File Format</h3>

<p>The .rock files are plain text files where a number of conventions are used
to add metadata. Normally these are the following conventions:
</p>

<ul>
<li><p> The smallest 'codeable unit' is called an utterance, and utterances are separated by newline characters (i.e. every line of the file is an utterance);
</p>
</li>
<li><p> Codes are in between double square brackets: <code style="white-space: pre;">&#8288;[[code1]]&#8288;</code> and <code style="white-space: pre;">&#8288;[[code2]]&#8288;</code>;
</p>
</li>
<li><p> Hierarchy in inductive code trees can be indicated using the greater than sign (<code>&gt;</code>): <code style="white-space: pre;">&#8288;[[parent1&gt;child1]]&#8288;</code>;
</p>
</li>
<li><p> Utterances can have unique identifiers called 'utterance identifiers' or 'UIDs', which are unique short alphanumeric strings placed in between double square brackets after 'uid:', e.g. <code style="white-space: pre;">&#8288;[[uid:73xk2q07]]&#8288;</code>;
</p>
</li>
<li><p> Deductive code trees can be specified using YAML
</p>
</li></ul>



<h3>The <code>rock</code> R Package Functions</h3>

<p>The most important functions are <code><a href="#topic+parse_source">parse_source()</a></code> to parse one source and <code><a href="#topic+parse_sources">parse_sources()</a></code>
to parse multiple sources simultaneously. <code><a href="#topic+clean_source">clean_source()</a></code> and <code><a href="#topic+clean_sources">clean_sources()</a></code> can be used
to clean sources, and <code><a href="#topic+prepend_ids_to_source">prepend_ids_to_source()</a></code> and <code><a href="#topic+prepend_ids_to_sources">prepend_ids_to_sources()</a></code> can be
used to quickly generate UIDs and prepend them to each utterance in a source.
</p>
<p>For analysis, <code><a href="#topic+create_cooccurrence_matrix">create_cooccurrence_matrix()</a></code>, <code><a href="#topic+collapse_occurrences">collapse_occurrences()</a></code>, and
<code><a href="#topic+collect_coded_fragments">collect_coded_fragments()</a></code> can be used.
</p>

<hr>
<h2 id='root_from_codePaths'>Get the roots from a vector with code paths</h2><span id='topic+root_from_codePaths'></span>

<h3>Description</h3>

<p>Get the roots from a vector with code paths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>root_from_codePaths(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="root_from_codePaths_+3A_x">x</code></td>
<td>
<p>A vector of code paths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the root of each element.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>root_from_codePaths(
  c("codes&gt;reason&gt;parent_feels",
    "codes&gt;reason&gt;child_feels")
);
</code></pre>

<hr>
<h2 id='rpe_create_source_with_items'>Create a source with items to code for Response Process Evaluation</h2><span id='topic+rpe_create_source_with_items'></span>

<h3>Description</h3>

<p>This function creates a plain text file, a <code>.rock</code> source, that can be
coded when conducting Response Process Evaluation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpe_create_source_with_items(
  data,
  iterationId,
  batchId,
  populationId,
  itemVarNames,
  metaquestionIdentifiers,
  metaquestionVarNames,
  itemContents,
  metaquestionContents,
  coderId,
  caseIds = NULL,
  outputFile = NULL,
  preventOverwriting = rock::opts$get("preventOverwriting"),
  encoding = rock::opts$get("encoding"),
  silent = rock::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpe_create_source_with_items_+3A_data">data</code></td>
<td>
<p>A (wide) data frame containing at least the participants'
answers to the items and to the meta questions (but optionally, the
iteration, batch, and population).</p>
</td></tr>
<tr><td><code id="rpe_create_source_with_items_+3A_iterationid">iterationId</code>, <code id="rpe_create_source_with_items_+3A_batchid">batchId</code>, <code id="rpe_create_source_with_items_+3A_populationid">populationId</code></td>
<td>
<p>If the iteration, batch, and
population identifiers are contained in the data frame passed as <code>data</code>,
the variable names holding that information for each participant;
otherwise, either a single value or a vector of length <code>nrow(data)</code> that
contains that information for each participant.</p>
</td></tr>
<tr><td><code id="rpe_create_source_with_items_+3A_itemvarnames">itemVarNames</code></td>
<td>
<p>The variable names with the participants' responses
to the items, in a named character vector, with each element's name being
the item's identifier, and each element the variable name in <code>data</code> holding
the participants' responses to the item.</p>
</td></tr>
<tr><td><code id="rpe_create_source_with_items_+3A_metaquestionidentifiers">metaquestionIdentifiers</code></td>
<td>
<p>A named list of unnamed character vectors,
with each character vector element specifying the identifier of a meta
question, and each list element (i.e. the name of each character vector)
specifying the item identifier that the meta questions in the corresponding
character vector belong to.</p>
</td></tr>
<tr><td><code id="rpe_create_source_with_items_+3A_metaquestionvarnames">metaquestionVarNames</code></td>
<td>
<p>The variable names with the participants'
responses to the meta questions, in a named character vector, with each
element's name being the meta question's identifier, and each element
the variable name in <code>data</code> holding the participants' responses to the
meta question.</p>
</td></tr>
<tr><td><code id="rpe_create_source_with_items_+3A_itemcontents">itemContents</code></td>
<td>
<p>A named character vector with each item's content, with
the values being the content and the names the item identifiers.</p>
</td></tr>
<tr><td><code id="rpe_create_source_with_items_+3A_metaquestioncontents">metaquestionContents</code></td>
<td>
<p>A named character vector with each meta
question's content, with the values being the content and the names the
meta question identifiers.</p>
</td></tr>
<tr><td><code id="rpe_create_source_with_items_+3A_coderid">coderId</code></td>
<td>
<p>The identifier of the coder that will code this source.</p>
</td></tr>
<tr><td><code id="rpe_create_source_with_items_+3A_caseids">caseIds</code></td>
<td>
<p>The variable name with the participants' case identifiers (i.e.
a unique identifier for each participant).</p>
</td></tr>
<tr><td><code id="rpe_create_source_with_items_+3A_outputfile">outputFile</code></td>
<td>
<p>Optionally, a file to write the source to.</p>
</td></tr>
<tr><td><code id="rpe_create_source_with_items_+3A_preventoverwriting">preventOverwriting</code></td>
<td>
<p>Whether to overwrite existing files (<code>FALSE</code>) or
prevent that from happening (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="rpe_create_source_with_items_+3A_encoding">encoding</code></td>
<td>
<p>The encoding to use when writing the source(s).</p>
</td></tr>
<tr><td><code id="rpe_create_source_with_items_+3A_silent">silent</code></td>
<td>
<p>Whether to the silent (<code>TRUE</code>) or chatty (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The created source, as a character vector (invisibly);
</p>

<hr>
<h2 id='save_workspace'>Save your justifications to a file</h2><span id='topic+save_workspace'></span>

<h3>Description</h3>

<p>When conducting analyses, you make many choices that ideally, you
document and justify. This function saves stored justifications to a
file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_workspace(
  file = rock::opts$get("justificationFile"),
  encoding = rock::opts$get("encoding"),
  append = FALSE,
  preventOverwriting = rock::opts$get("preventOverwriting"),
  silent = rock::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_workspace_+3A_file">file</code></td>
<td>
<p>If specified, the file to export the justification to.</p>
</td></tr>
<tr><td><code id="save_workspace_+3A_encoding">encoding</code></td>
<td>
<p>The encoding to use when writing the file.</p>
</td></tr>
<tr><td><code id="save_workspace_+3A_append">append</code></td>
<td>
<p>Whether to append to the file, or replace its contents.</p>
</td></tr>
<tr><td><code id="save_workspace_+3A_preventoverwriting">preventOverwriting</code></td>
<td>
<p>Whether to prevent overwriting an existing file.</p>
</td></tr>
<tr><td><code id="save_workspace_+3A_silent">silent</code></td>
<td>
<p>Whether to be silent or chatty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of a call to <code><a href="justifier.html#topic+export_justification">justifier::export_justification()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Get a path to one example file
exampleFile &lt;-
  file.path(examplePath, "example-1.rock");

### Load example source
loadedExample &lt;- rock::load_source(exampleFile);

### Split a code into two codes, showing progress (the backticks are
### used to be able to specify a name that starts with an underscore)
recoded_source &lt;-
  rock::recode_split(
    loadedExample,
    codes="childCode1",
    splitToCodes = list(
      `_and_` = " and ",
      `_book_` = "book",
      `_else_` = TRUE
    ),
    silent=FALSE,
    justification = "Because this seems like a good idea"
  );

### Save this workspace to a file
temporaryFilename &lt;- tempfile();
rock::save_workspace(file = temporaryFilename);
</code></pre>

<hr>
<h2 id='show_attribute_table'>Show a table with all attributes in the RStudio viewer and/or console</h2><span id='topic+show_attribute_table'></span>

<h3>Description</h3>

<p>Show a table with all attributes in the RStudio viewer and/or console
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_attribute_table(
  x,
  output = rock::opts$get("tableOutput"),
  tableOutputCSS = rock::opts$get("tableOutputCSS")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_attribute_table_+3A_x">x</code></td>
<td>
<p>A <code>rock_parsedSources</code> object (the result of a call to
<code>rock::parse_sources</code>).</p>
</td></tr>
<tr><td><code id="show_attribute_table_+3A_output">output</code></td>
<td>
<p>The output: a character vector with one or more
of &quot;<code>console</code>&quot; (the raw concatenated input, without conversion
to HTML), &quot;<code>viewer</code>&quot;, which uses the RStudio viewer if available,
and one or more filenames in existing directories.</p>
</td></tr>
<tr><td><code id="show_attribute_table_+3A_tableoutputcss">tableOutputCSS</code></td>
<td>
<p>The CSS to use for the HTML table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>, invisibly, unless being knitted into R Markdown,
in which case a <code><a href="knitr.html#topic+asis_output">knitr::asis_output()</a></code>-wrapped character vector is returned.
</p>

<hr>
<h2 id='show_fullyMergedCodeTrees'>Show the fully merged code tree(s)</h2><span id='topic+show_fullyMergedCodeTrees'></span>

<h3>Description</h3>

<p>Show the fully merged code tree(s)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_fullyMergedCodeTrees(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_fullyMergedCodeTrees_+3A_x">x</code></td>
<td>
<p>A parsed source(s) object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of a call to <code><a href="DiagrammeR.html#topic+render_graph">DiagrammeR::render_graph()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Get a path to one example file
exampleFile &lt;-
  file.path(examplePath, "example-1.rock");

### Load example source
loadedExample &lt;- rock::parse_source(exampleFile);

### Show merged code tree
show_fullyMergedCodeTrees(loadedExample);
</code></pre>

<hr>
<h2 id='show_inductive_code_tree'>Show the inductive code tree(s)</h2><span id='topic+show_inductive_code_tree'></span>

<h3>Description</h3>

<p>This function shows one or more inductive code trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_inductive_code_tree(
  x,
  codes = ".*",
  output = "both",
  headingLevel = 3,
  nodeStyle = list(shape = "box", fontname = "Arial"),
  edgeStyle = list(arrowhead = "none"),
  graphStyle = list(rankdir = "LR")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_inductive_code_tree_+3A_x">x</code></td>
<td>
<p>A <code>rock_parsedSources</code> object (the result of a call to
<code>rock::parse_sources</code>).</p>
</td></tr>
<tr><td><code id="show_inductive_code_tree_+3A_codes">codes</code></td>
<td>
<p>A regular expression: only code trees from codes coded
with a coding pattern with this name will be shown.</p>
</td></tr>
<tr><td><code id="show_inductive_code_tree_+3A_output">output</code></td>
<td>
<p>Whether to show the code tree in the console (<code>text</code>),
as a plot (<code>plot</code>), or both (<code>both</code>).</p>
</td></tr>
<tr><td><code id="show_inductive_code_tree_+3A_headinglevel">headingLevel</code></td>
<td>
<p>The level of the heading to insert when showing the
code tree as text.</p>
</td></tr>
<tr><td><code id="show_inductive_code_tree_+3A_nodestyle">nodeStyle</code>, <code id="show_inductive_code_tree_+3A_edgestyle">edgeStyle</code>, <code id="show_inductive_code_tree_+3A_graphstyle">graphStyle</code></td>
<td>
<p>Arguments to pass on to,
respectively, <code><a href="data.tree.html#topic+ToDiagrammeRGraph">data.tree::SetNodeStyle()</a></code>, <code><a href="data.tree.html#topic+ToDiagrammeRGraph">data.tree::SetEdgeStyle()</a></code>,
and <code><a href="data.tree.html#topic+ToDiagrammeRGraph">data.tree::SetGraphStyle()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>, invisibly, unless being knitted into R Markdown,
in which case a <code><a href="knitr.html#topic+asis_output">knitr::asis_output()</a></code>-wrapped character vector is returned.
</p>

<hr>
<h2 id='split_long_lines'>Split long lines</h2><span id='topic+split_long_lines'></span>

<h3>Description</h3>

<p>This function splits long lines at a given number of characters,
keeping words intact. It's basically a wrapper around <code><a href="base.html#topic+strwrap">strwrap()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_long_lines(
  x,
  length = 60,
  splitString = rock::opts$get("utteranceMarker")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_long_lines_+3A_x">x</code></td>
<td>
<p>The string (e.g. a source)</p>
</td></tr>
<tr><td><code id="split_long_lines_+3A_length">length</code></td>
<td>
<p>The maximum length</p>
</td></tr>
<tr><td><code id="split_long_lines_+3A_splitstring">splitString</code></td>
<td>
<p>The character to use to split lines.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cat(
  rock::split_long_lines(
    paste0(
      "Lorem ipsum dolor sit amet, consectetur adipiscing elit. ",
      "Vestibulum et dictum urna. Donec neque nunc, lacinia vitae ",
      "varius vitae, pretium quis nibh. Aliquam pulvinar, lacus ",
      "sed varius vulputate, justo nibh blandit quam, ",
      "nec sollicitudin velit augue eget erat."
    )
  )
);
</code></pre>

<hr>
<h2 id='stripCodePathRoot'>Strip the root from a code path</h2><span id='topic+stripCodePathRoot'></span>

<h3>Description</h3>

<p>This function strips the root (just the first element) from a code path,
using the <code>codeTreeMarker</code> stored in the <a href="#topic+opts">opts</a> object as marker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stripCodePathRoot(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stripCodePathRoot_+3A_x">x</code></td>
<td>
<p>A vector of code paths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified vector of code paths.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stripCodePathRoot("codes&gt;reason&gt;parent_feels");
</code></pre>

<hr>
<h2 id='sync_streams'>Synchronize multiple streams</h2><span id='topic+sync_streams'></span>

<h3>Description</h3>

<p>This function maps the codes from multiple streams onto a primary stream.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sync_streams(
  x,
  primaryStream,
  columns = NULL,
  anchorsCol = rock::opts$get("anchorsCol"),
  sourceId = rock::opts$get("sourceId"),
  streamId = rock::opts$get("streamId"),
  prependStreamIdToColName = FALSE,
  appendStreamIdToColName = FALSE,
  sep = " ",
  fill = TRUE,
  compressFun = NULL,
  compressFunPart = NULL,
  expandFun = NULL,
  colNameGlue = rock::opts$get("colNameGlue"),
  silent = rock::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sync_streams_+3A_x">x</code></td>
<td>
<p>The object with the parsed sources.</p>
</td></tr>
<tr><td><code id="sync_streams_+3A_primarystream">primaryStream</code></td>
<td>
<p>The identifier of the primary stream.</p>
</td></tr>
<tr><td><code id="sync_streams_+3A_columns">columns</code></td>
<td>
<p>The names of the column(s) to synchronize.</p>
</td></tr>
<tr><td><code id="sync_streams_+3A_anchorscol">anchorsCol</code></td>
<td>
<p>The column containing the anchors.</p>
</td></tr>
<tr><td><code id="sync_streams_+3A_sourceid">sourceId</code></td>
<td>
<p>The column containing the source identifiers.</p>
</td></tr>
<tr><td><code id="sync_streams_+3A_streamid">streamId</code></td>
<td>
<p>The column containing the stream identifiers.</p>
</td></tr>
<tr><td><code id="sync_streams_+3A_prependstreamidtocolname">prependStreamIdToColName</code>, <code id="sync_streams_+3A_appendstreamidtocolname">appendStreamIdToColName</code></td>
<td>
<p>Whether to append
or prepend the stream identifier before merging the dataframes together.</p>
</td></tr>
<tr><td><code id="sync_streams_+3A_sep">sep</code></td>
<td>
<p>When not specifying <code>compressFun</code> and <code>compressFunPart</code>, the
<code>paste</code> function is used to combine elements, and in that case, <code>sep</code> is
passed to <code>paste</code> as separator.</p>
</td></tr>
<tr><td><code id="sync_streams_+3A_fill">fill</code></td>
<td>
<p>When expanding streams, whether to duplicate elements to fill
the resulting vector. Ignored if <code>fillFun</code> is specified.</p>
</td></tr>
<tr><td><code id="sync_streams_+3A_compressfun">compressFun</code></td>
<td>
<p>If specified, when compressing streams, instead of pasting
elements together using separator <code>sep</code>, the vectors are passed to function
<code>compressFun</code>, which must accept a vector (to compress) and a single integer
(with the desired resulting length of the vector).</p>
</td></tr>
<tr><td><code id="sync_streams_+3A_compressfunpart">compressFunPart</code></td>
<td>
<p>A function to apply to the segments that are
automatically created; this can be passed instead of <code>compressFun</code>.</p>
</td></tr>
<tr><td><code id="sync_streams_+3A_expandfun">expandFun</code></td>
<td>
<p>If specified, when expanding streams, instead of potentially
filling the new larger vector with elements (if <code>fill</code> is <code>TRUE</code>), the
vectors are passed to function <code>expandFun</code>, which must accept a vector (to
compress) and a single integer (with the desired resulting length of
the vector).</p>
</td></tr>
<tr><td><code id="sync_streams_+3A_colnameglue">colNameGlue</code></td>
<td>
<p>When appending or prepending stream identifiers, the
character(s) to use as &quot;glue&quot; or separator.</p>
</td></tr>
<tr><td><code id="sync_streams_+3A_silent">silent</code></td>
<td>
<p>Whether to be silent (<code>TRUE</code>) or chatty (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object with parsd sources, <code>x</code>, with the synchronization results
added in the <code style="white-space: pre;">&#8288;$syncResults&#8288;</code> subobject.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get a directory with example sources
examplePath &lt;-
  file.path(
    system.file(package="rock"),
    'extdata',
    'streams'
  );

### Parse the sources
parsedSources &lt;- rock::parse_sources(
  examplePath
);

### Add a dataframe, syncing all streams to primary stream !
parsedSources &lt;- rock::sync_streams(
  parsedSources,
  primaryStream = "streamA",
  columns = c("Code1", "Code2", "Code3"),
  prependStreamIdToColName = TRUE
);

### Look at two examples
parsedSources$syncResults$mergedSourceDf[
  ,
  c("streamB_Code3", "streamC_Code1")
];
</code></pre>

<hr>
<h2 id='sync_vector'>Sync (expand or compress) a vector</h2><span id='topic+sync_vector'></span>

<h3>Description</h3>

<p>Sync (expand or compress) a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sync_vector(
  x,
  newLength,
  sep = " ",
  fill = TRUE,
  compressFun = NULL,
  expandFun = NULL,
  compressFunPart = NULL,
  silent = rock::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sync_vector_+3A_x">x</code></td>
<td>
<p>The vector</p>
</td></tr>
<tr><td><code id="sync_vector_+3A_newlength">newLength</code></td>
<td>
<p>The new length</p>
</td></tr>
<tr><td><code id="sync_vector_+3A_sep">sep</code></td>
<td>
<p>When not specifying <code>compressFun</code> and <code>compressFunPart</code>, the
<code>paste</code> function is used to combine elements, and in that case, <code>sep</code> is
passed to <code>paste</code> as separator.</p>
</td></tr>
<tr><td><code id="sync_vector_+3A_fill">fill</code></td>
<td>
<p>When expanding streams, whether to duplicate elements to fill
the resulting vector. Ignored if <code>fillFun</code> is specified.</p>
</td></tr>
<tr><td><code id="sync_vector_+3A_compressfun">compressFun</code></td>
<td>
<p>If specified, when compressing streams, instead of pasting
elements together using separator <code>sep</code>, the vectors are passed to function
<code>compressFun</code>, which must accept a vector (to compress) and a single integer
(with the desired resulting length of the vector).</p>
</td></tr>
<tr><td><code id="sync_vector_+3A_expandfun">expandFun</code></td>
<td>
<p>If specified, when expanding streams, instead of potentially
filling the new larger vector with elements (if <code>fill</code> is <code>TRUE</code>), the
vectors are passed to function <code>expandFun</code>, which must accept a vector (to
compress) and a single integer (with the desired resulting length of
the vector).</p>
</td></tr>
<tr><td><code id="sync_vector_+3A_compressfunpart">compressFunPart</code></td>
<td>
<p>A function to apply to the segments that are
automatically created; this can be passed instead of <code>compressFun</code>.</p>
</td></tr>
<tr><td><code id="sync_vector_+3A_silent">silent</code></td>
<td>
<p>Whether to be silent or chatty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The synced vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rock::sync_vector(letters[1:10], 15);
rock::sync_vector(letters[1:10], 5);
</code></pre>

<hr>
<h2 id='syncing_df_compress'>Compress a vector or data frame</h2><span id='topic+syncing_df_compress'></span><span id='topic+syncing_vector_compress'></span>

<h3>Description</h3>

<p>Compress a vector or data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syncing_df_compress(
  x,
  newLength,
  sep = " ",
  compressFun = NULL,
  compressFunPart = NULL,
  silent = rock::opts$get("silent")
)

syncing_vector_compress(
  x,
  newLength,
  sep = " ",
  compressFun = NULL,
  compressFunPart = NULL,
  silent = rock::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syncing_df_compress_+3A_x">x</code></td>
<td>
<p>The vector or data frame</p>
</td></tr>
<tr><td><code id="syncing_df_compress_+3A_newlength">newLength</code></td>
<td>
<p>The new length (or number of rows for a data frame)</p>
</td></tr>
<tr><td><code id="syncing_df_compress_+3A_sep">sep</code></td>
<td>
<p>When not specifying <code>compressFun</code> and <code>compressFunPart</code>, the
<code>paste</code> function is used to combine elements, and in that case, <code>sep</code> is
passed to <code>paste</code> as separator.</p>
</td></tr>
<tr><td><code id="syncing_df_compress_+3A_compressfun">compressFun</code></td>
<td>
<p>If specified, when compressing streams, instead of pasting
elements together using separator <code>sep</code>, the vectors are passed to function
<code>compressFun</code>, which must accept a vector (to compress) and a single integer
(with the desired resulting length of the vector).</p>
</td></tr>
<tr><td><code id="syncing_df_compress_+3A_compressfunpart">compressFunPart</code></td>
<td>
<p>A function to apply to the segments that are
automatically created; this can be passed instead of <code>compressFun</code>.</p>
</td></tr>
<tr><td><code id="syncing_df_compress_+3A_silent">silent</code></td>
<td>
<p>Whether to be silent or chatty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The compressed vector or data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rock::syncing_vector_compress(
  1:10,
  3
);

rock::syncing_df_compress(
  mtcars[, 1:4],
  6
);

rock::syncing_df_compress(
  mtcars[, 1:4],
  6,
  compressFunPart = mean
);
</code></pre>

<hr>
<h2 id='syncing_df_expand'>Expand a vector or data frame</h2><span id='topic+syncing_df_expand'></span><span id='topic+syncing_vector_expand'></span>

<h3>Description</h3>

<p>Expand a vector or data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syncing_df_expand(
  x,
  newLength,
  fill = TRUE,
  expandFun = NULL,
  silent = rock::opts$get("silent")
)

syncing_vector_expand(
  x,
  newLength,
  fill = TRUE,
  expandFun = NULL,
  silent = rock::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syncing_df_expand_+3A_x">x</code></td>
<td>
<p>The vector or data frame</p>
</td></tr>
<tr><td><code id="syncing_df_expand_+3A_newlength">newLength</code></td>
<td>
<p>The new length (or number of rows for a data frame)</p>
</td></tr>
<tr><td><code id="syncing_df_expand_+3A_fill">fill</code></td>
<td>
<p>When expanding streams, whether to duplicate elements to fill
the resulting vector. Ignored if <code>fillFun</code> is specified.</p>
</td></tr>
<tr><td><code id="syncing_df_expand_+3A_expandfun">expandFun</code></td>
<td>
<p>If specified, when expanding streams, instead of potentially
filling the new larger vector with elements (if <code>fill</code> is <code>TRUE</code>), the
vectors are passed to function <code>expandFun</code>, which must accept a vector (to
compress) and a single integer (with the desired resulting length of
the vector).</p>
</td></tr>
<tr><td><code id="syncing_df_expand_+3A_silent">silent</code></td>
<td>
<p>Whether to be silent or chatty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The expanded vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rock::syncing_vector_expand(letters[1:10], 15);
rock::syncing_vector_expand(letters[1:10], 15, fill=FALSE);
</code></pre>

<hr>
<h2 id='template_ci_heatmap_1_to_pdf'>Create a templated report for cognitive interviews</h2><span id='topic+template_ci_heatmap_1_to_pdf'></span>

<h3>Description</h3>

<p>Use this function to export a templated report for cognitive interviews.
To embed it in an R Markdown file, use
!!! CREATE rock::knit_codebook() !!!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>template_ci_heatmap_1_to_pdf(
  x,
  file,
  title = "Cognitive Interview: Heatmap and Coded Fragments",
  author = NULL,
  caption = "Heatmap",
  headingLevel = 1,
  silent = rock::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="template_ci_heatmap_1_to_pdf_+3A_x">x</code></td>
<td>
<p>The codebook object (as produced by a call to
<code><a href="#topic+parse_sources">parse_sources()</a></code>).</p>
</td></tr>
<tr><td><code id="template_ci_heatmap_1_to_pdf_+3A_file">file</code></td>
<td>
<p>The filename to save the codebook to.</p>
</td></tr>
<tr><td><code id="template_ci_heatmap_1_to_pdf_+3A_title">title</code></td>
<td>
<p>The title to use.</p>
</td></tr>
<tr><td><code id="template_ci_heatmap_1_to_pdf_+3A_author">author</code></td>
<td>
<p>The author to specify in the PDF.</p>
</td></tr>
<tr><td><code id="template_ci_heatmap_1_to_pdf_+3A_caption">caption</code></td>
<td>
<p>The caption for the heatmap.</p>
</td></tr>
<tr><td><code id="template_ci_heatmap_1_to_pdf_+3A_headinglevel">headingLevel</code></td>
<td>
<p>The level of the top-most headings.</p>
</td></tr>
<tr><td><code id="template_ci_heatmap_1_to_pdf_+3A_silent">silent</code></td>
<td>
<p>Whether to be silent or chatty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x, invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Use a temporary file to write to
tmpFile &lt;- tempfile(fileext = ".pdf");

### Load an example CI
examplePath &lt;- file.path(system.file(package="rock"), 'extdata');
parsedCI &lt;- parse_source(file.path(examplePath,
                                   "ci_example_1.rock"));

rock::template_ci_heatmap_1_to_pdf(
  parsedCI,
  file = tmpFile
);

</code></pre>

<hr>
<h2 id='template_codebook_to_pdf'>Convert a codebook specification to PDF</h2><span id='topic+template_codebook_to_pdf'></span>

<h3>Description</h3>

<p>Use this function to export your codebook specification to a PDF
file. To embed it in an R Markdown file, use
!!! CREATE rock::knit_codebook() !!!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>template_codebook_to_pdf(
  x,
  file,
  author = NULL,
  headingLevel = 1,
  silent = rock::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="template_codebook_to_pdf_+3A_x">x</code></td>
<td>
<p>The codebook object (as produced by a call to
<code><a href="#topic+codebook_fromSpreadsheet">codebook_fromSpreadsheet()</a></code>).</p>
</td></tr>
<tr><td><code id="template_codebook_to_pdf_+3A_file">file</code></td>
<td>
<p>The filename to save the codebook to.</p>
</td></tr>
<tr><td><code id="template_codebook_to_pdf_+3A_author">author</code></td>
<td>
<p>The author to specify in the PDF.</p>
</td></tr>
<tr><td><code id="template_codebook_to_pdf_+3A_headinglevel">headingLevel</code></td>
<td>
<p>The level of the top-most headings.</p>
</td></tr>
<tr><td><code id="template_codebook_to_pdf_+3A_silent">silent</code></td>
<td>
<p>Whether to be silent or chatty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x, invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Use a temporary file to write to
tmpFile &lt;- tempfile(fileext = ".pdf");

### Load an example codebook
data("exampleCodebook_1", package = "rock");

rock::template_codebook_to_pdf(
  exampleCodebook_1,
  file = tmpFile
);

</code></pre>

<hr>
<h2 id='vecTxt'>Easily parse a vector into a character value</h2><span id='topic+vecTxt'></span><span id='topic+vecTxtQ'></span>

<h3>Description</h3>

<p>Easily parse a vector into a character value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecTxt(
  vector,
  delimiter = ", ",
  useQuote = "",
  firstDelimiter = NULL,
  lastDelimiter = " &amp; ",
  firstElements = 0,
  lastElements = 1,
  lastHasPrecedence = TRUE
)

vecTxtQ(vector, useQuote = "'", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vecTxt_+3A_vector">vector</code></td>
<td>
<p>The vector to process.</p>
</td></tr>
<tr><td><code id="vecTxt_+3A_delimiter">delimiter</code>, <code id="vecTxt_+3A_firstdelimiter">firstDelimiter</code>, <code id="vecTxt_+3A_lastdelimiter">lastDelimiter</code></td>
<td>
<p>The delimiters
to use for respectively the middle, first
<code>firstElements</code>, and last <code>lastElements</code> elements.</p>
</td></tr>
<tr><td><code id="vecTxt_+3A_usequote">useQuote</code></td>
<td>
<p>This character string is pre- and appended to all elements;
so use this to quote all elements (<code>useQuote="'"</code>), doublequote all
elements (<code>useQuote='"'</code>), or anything else (e.g. <code>useQuote='|'</code>).
The only difference between <code>vecTxt</code> and <code>vecTxtQ</code> is that the
latter by default quotes the elements.</p>
</td></tr>
<tr><td><code id="vecTxt_+3A_firstelements">firstElements</code>, <code id="vecTxt_+3A_lastelements">lastElements</code></td>
<td>
<p>The number of elements for which to use
the first respective last delimiters</p>
</td></tr>
<tr><td><code id="vecTxt_+3A_lasthasprecedence">lastHasPrecedence</code></td>
<td>
<p>If the vector is very short, it's possible that the
sum of firstElements and lastElements is larger than the vector length. In
that case, downwardly adjust the number of elements to separate with the
first delimiter (<code>TRUE</code>) or the number of elements to separate with the
last delimiter (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="vecTxt_+3A_...">...</code></td>
<td>
<p>Any addition arguments to <code>vecTxtQ</code> are passed on to
<code>vecTxt</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of length 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vecTxtQ(names(mtcars));
</code></pre>

<hr>
<h2 id='wrapVector'>Wrap all elements in a vector</h2><span id='topic+wrapVector'></span>

<h3>Description</h3>

<p>Wrap all elements in a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrapVector(x, width = 0.9 * getOption("width"), sep = "\n", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrapVector_+3A_x">x</code></td>
<td>
<p>The character vector</p>
</td></tr>
<tr><td><code id="wrapVector_+3A_width">width</code></td>
<td>
<p>The number of</p>
</td></tr>
<tr><td><code id="wrapVector_+3A_sep">sep</code></td>
<td>
<p>The glue with which to combine the new lines</p>
</td></tr>
<tr><td><code id="wrapVector_+3A_...">...</code></td>
<td>
<p>Other arguments are passed to <code><a href="base.html#topic+strwrap">strwrap()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- wrapVector(
  c(
    "This is a sentence ready for wrapping",
    "So is this one, although it's a bit longer"
  ),
  width = 10
);

print(res);
cat(res, sep="\n");
</code></pre>

<hr>
<h2 id='write_source'>Write a source to a file</h2><span id='topic+write_source'></span><span id='topic+write_sources'></span><span id='topic+writing_sources'></span>

<h3>Description</h3>

<p>These functions write one or more source(s) from memory (as
loaded by <code><a href="#topic+load_source">load_source()</a></code> or <code><a href="#topic+load_sources">load_sources()</a></code> to a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_source(
  x,
  output,
  encoding = rock::opts$get("encoding"),
  preventOverwriting = rock::opts$get("preventOverwriting"),
  silent = rock::opts$get("silent")
)

write_sources(
  x,
  output,
  filenamePrefix = "",
  filenameSuffix = "_written",
  encoding = rock::opts$get("encoding"),
  silent = rock::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_source_+3A_x">x</code></td>
<td>
<p>The source(s).</p>
</td></tr>
<tr><td><code id="write_source_+3A_output">output</code></td>
<td>
<p>The filename (for <code>rock::write_source()</code>) or path (for
<code>rock::write_sources()</code>) to write to.</p>
</td></tr>
<tr><td><code id="write_source_+3A_encoding">encoding</code></td>
<td>
<p>The encoding to use.</p>
</td></tr>
<tr><td><code id="write_source_+3A_preventoverwriting">preventOverwriting</code></td>
<td>
<p>Whether to prevent against overwriting of the
file(s) to write. Set to <code>FALSE</code> to overwrite.</p>
</td></tr>
<tr><td><code id="write_source_+3A_silent">silent</code></td>
<td>
<p>Whether to be chatty or quiet.</p>
</td></tr>
<tr><td><code id="write_source_+3A_filenameprefix">filenamePrefix</code>, <code id="write_source_+3A_filenamesuffix">filenameSuffix</code></td>
<td>
<p>Optional prefixes or suffixes to pre-
or append to the filenames when writing the files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the input (<code>x</code>), to enable chaining in pipes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Get a path to one example file
exampleFile &lt;-
  file.path(examplePath, "example-1.rock");

### Get a temporary file to write to
tempFile &lt;- tempfile(fileext = ".rock")

### Pipe chain to load the example source; add a code;
### and write the result to disk
loadedSource &lt;-

  rock::load_source(exampleFile) |&gt;

  rock::code_source(c("Lorem Ipsum" = "lorumIpsum")) |&gt;

  rock::write_source(tempFile);

</code></pre>

<hr>
<h2 id='yaml_delimiter_indices'>Get indices of YAML delimiters</h2><span id='topic+yaml_delimiter_indices'></span>

<h3>Description</h3>

<p>Get indices of YAML delimiters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yaml_delimiter_indices(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yaml_delimiter_indices_+3A_x">x</code></td>
<td>
<p>The character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>yaml_delimiter_indices(
  c("not here",
    "---",
    "above this one",
    "but nothing here",
    "below this one, too",
    "---")
);
### [1] 2 6
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
