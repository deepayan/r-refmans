<!DOCTYPE html><html lang="en"><head><title>Help for package dsTidyverseClient</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dsTidyverseClient}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ds.arrange'><p>Order the rows of a data frame by the values of selected columns</p></a></li>
<li><a href='#ds.as_tibble'><p>Coerce a data frame or matrix to a tibble.</p></a></li>
<li><a href='#ds.bind_cols'><p>Bind multiple data frames by column</p></a></li>
<li><a href='#ds.bind_rows'><p>Bind multiple data frames by row.</p></a></li>
<li><a href='#ds.case_when'><p>A general vectorised if-else</p></a></li>
<li><a href='#ds.distinct'><p>Keep distinct/unique rows</p></a></li>
<li><a href='#ds.filter'><p>Keep rows that match a condition</p></a></li>
<li><a href='#ds.group_by'><p>Group by one or more variables</p></a></li>
<li><a href='#ds.group_keys'><p>Describe the groups within a grouped tibble or data frame</p></a></li>
<li><a href='#ds.if_else'><p>Vectorised if-else</p></a></li>
<li><a href='#ds.mutate'><p>Create, modify, and delete columns</p></a></li>
<li><a href='#ds.rename'><p>Rename columns</p></a></li>
<li><a href='#ds.select'><p>Keep or drop columns using their names and types</p></a></li>
<li><a href='#ds.slice'><p>Subset rows using their positions</p></a></li>
<li><a href='#ds.ungroup'><p>Remove grouping from a tibble or data frame</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>'DataSHIELD' 'Tidyverse' Clientside Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tim Cadman &lt;t.j.cadman@umcg.nl&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of selected 'Tidyverse' functions within 'DataSHIELD', an open-source federated analysis solution in R. Currently, 'DataSHIELD' contains very limited tools for data manipulation, so the aim of this package is to improve the researcher experience by implementing essential functions for data manipulation, including subsetting, filtering, grouping, and renaming variables. This is the clientside package which should be installed locally, and is used in conjuncture with the serverside package 'dsTidyverse' which is installed on the remote server holding the data. For more information, see <a href="https://www.tidyverse.org/">https://www.tidyverse.org/</a>, <a href="https://datashield.org/">https://datashield.org/</a> and <a href="https://github.com/molgenis/ds-tidyverse">https://github.com/molgenis/ds-tidyverse</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL (&ge; 2.1)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>DSI (&ge; 1.7.0), cli, rlang, assertthat</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), knitr, rmarkdown, DSLite, dsBase,
dsBaseClient, dsTidyverse, dplyr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://cran.obiba.org/">https://cran.obiba.org/</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-27 09:19:59 UTC; tcadman</td>
</tr>
<tr>
<td>Author:</td>
<td>Tim Cadman <a href="https://orcid.org/0000-0002-7682-5645"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Mariska Slofstra <a href="https://orcid.org/0000-0002-0400-0468"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Stuart Wheater [aut],
  Demetris Avraam [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-27 09:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='ds.arrange'>Order the rows of a data frame by the values of selected columns</h2><span id='topic+ds.arrange'></span>

<h3>Description</h3>

<p>DataSHIELD implentation of <code>dplyr::arrange</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ds.arrange(
  df.name = NULL,
  tidy_expr = NULL,
  .by_group = NULL,
  newobj = NULL,
  datasources = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ds.arrange_+3A_df.name">df.name</code></td>
<td>
<p>Character specifying a serverside data frame or tibble.</p>
</td></tr>
<tr><td><code id="ds.arrange_+3A_tidy_expr">tidy_expr</code></td>
<td>
<p>A list containing variables, or functions of variables. Use <code>dplyr::desc()</code> to sort a
variable in descending order.</p>
</td></tr>
<tr><td><code id="ds.arrange_+3A_.by_group">.by_group</code></td>
<td>
<p>If TRUE, will sort first by grouping variable. Applies to grouped data frames
only.</p>
</td></tr>
<tr><td><code id="ds.arrange_+3A_newobj">newobj</code></td>
<td>
<p>Character specifying name for new server-side data frame.</p>
</td></tr>
<tr><td><code id="ds.arrange_+3A_datasources">datasources</code></td>
<td>
<p>DataSHIELD connections object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for its side effects. An object (typically a data frame or tibble) with the name specified by <code>newobj</code> is created on the server.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ds.arrange(
  df.name = "mtcars",
  tidy_expr = list(drat),
  newobj = "sorted_df",
  datasources = conns
)

## End(Not run)
</code></pre>

<hr>
<h2 id='ds.as_tibble'>Coerce a data frame or matrix to a tibble.</h2><span id='topic+ds.as_tibble'></span>

<h3>Description</h3>

<p>DataSHIELD implementation of <code>tibble::as_tibble</code>. Currently only implemented
for data frames and tibbles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ds.as_tibble(
  x = NULL,
  .rows = NULL,
  .name_repair = "check_unique",
  rownames = NULL,
  newobj = NULL,
  datasources = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ds.as_tibble_+3A_x">x</code></td>
<td>
<p>A data frame or matrix.</p>
</td></tr>
<tr><td><code id="ds.as_tibble_+3A_.rows">.rows</code></td>
<td>
<p>The number of rows, useful to create a 0-column tibble or just as an additional
check.</p>
</td></tr>
<tr><td><code id="ds.as_tibble_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Treatment of problematic column names:
</p>

<ul>
<li><p> &quot;minimal&quot;: No name repair or checks, beyond basic existence.
</p>
</li>
<li><p> &quot;unique&quot;: Make sure names are unique and not empty.
</p>
</li>
<li><p> &quot;check_unique&quot;: (default value), no name repair, but check they are unique.
</p>
</li>
<li><p> &quot;universal&quot;: Make the names unique and syntactic.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ds.as_tibble_+3A_rownames">rownames</code></td>
<td>
<p>How to treat existing row names of a data frame or matrix:
</p>

<ul>
<li><p> 'NULL': remove row names. This is the default.
</p>
</li>
<li><p> 'NA': keep row names.
</p>
</li>
<li><p> A string: the name of a new column. Existing rownames are transferred
into this column and the <code>row.names</code> attribute is deleted.
No name repair is applied to the new column name, even if 'x' already contains
a column of that name.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ds.as_tibble_+3A_newobj">newobj</code></td>
<td>
<p>Character specifying name for new server-side data frame.</p>
</td></tr>
<tr><td><code id="ds.as_tibble_+3A_datasources">datasources</code></td>
<td>
<p>DataSHIELD connections object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for its side effects. A tibble with the name specified by <code>newobj</code> is created on the server.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ds.as_tibble(
  x = "mtcars",
  newobj = "mtcars_tib",
  datasources = conns
)

## End(Not run)
</code></pre>

<hr>
<h2 id='ds.bind_cols'>Bind multiple data frames by column</h2><span id='topic+ds.bind_cols'></span>

<h3>Description</h3>

<p>DataSHIELD implementation of <code>dplyr::bind_cols</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ds.bind_cols(
  to_combine = NULL,
  .name_repair = c("unique", "universal", "check_unique", "minimal"),
  newobj = NULL,
  datasources = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ds.bind_cols_+3A_to_combine">to_combine</code></td>
<td>
<p>Data frames to combine. Each argument can either be a data frame, a list that
could be a data frame, or a list of data frames. Columns are matched by name, and any missing
columns will be filled with NA.</p>
</td></tr>
<tr><td><code id="ds.bind_cols_+3A_.name_repair">.name_repair</code></td>
<td>
<p>One of &quot;unique&quot;, &quot;universal&quot;, or &quot;check_unique&quot;. See
<code>vctrs::vec_as_names()</code> for the meaning of these options.</p>
</td></tr>
<tr><td><code id="ds.bind_cols_+3A_newobj">newobj</code></td>
<td>
<p>Character specifying name for new server-side data frame.</p>
</td></tr>
<tr><td><code id="ds.bind_cols_+3A_datasources">datasources</code></td>
<td>
<p>datashield connections object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for its side effects. A data frame with the name specified by
<code>newobj</code> and the same type as the first element of <code>to_combine</code> is created on the
server.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## First log in to a DataSHIELD session with mtcars dataset loaded.

ds.bind_cols(
  to_combine = list(mtcars, mtcars),
  .name_repair = "universal",
  newobj = "test",
  datasources = conns
)

## Refer to the package vignette for more examples.

## End(Not run)
</code></pre>

<hr>
<h2 id='ds.bind_rows'>Bind multiple data frames by row.</h2><span id='topic+ds.bind_rows'></span>

<h3>Description</h3>

<p>DataSHIELD implementation of <code>dplyr::bind_rows</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ds.bind_rows(to_combine = NULL, .id = NULL, newobj = NULL, datasources = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ds.bind_rows_+3A_to_combine">to_combine</code></td>
<td>
<p>Data frames to combine. Each argument can either be a data frame, a list that
could be a data frame, or a list of data frames. Columns are matched by name, and any missing
columns will be filled with NA.</p>
</td></tr>
<tr><td><code id="ds.bind_rows_+3A_.id">.id</code></td>
<td>
<p>The name of an optional identifier column. Provide a string to create an output column
that identifies each input. The column will use names if available, otherwise it will use
positions.</p>
</td></tr>
<tr><td><code id="ds.bind_rows_+3A_newobj">newobj</code></td>
<td>
<p>Character specifying name for new server-side data frame.</p>
</td></tr>
<tr><td><code id="ds.bind_rows_+3A_datasources">datasources</code></td>
<td>
<p>datashield connections object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for its side effects. A data frame with the name specified by
<code>newobj</code> and the same type as the first element of <code>to_combine</code> is created on the
server.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## First log in to a DataSHIELD session with mtcars dataset loaded.

ds.bind_rows(
  to_combine = list(mtcars, mtcars),
  newobj = "test",
  datasources = conns
)

## Refer to the package vignette for more examples.

## End(Not run)
</code></pre>

<hr>
<h2 id='ds.case_when'>A general vectorised if-else</h2><span id='topic+ds.case_when'></span>

<h3>Description</h3>

<p>DataSHIELD implementation of <code>dplyr::case_when</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ds.case_when(
  tidy_expr = NULL,
  .default = NULL,
  .ptype = NULL,
  .size = NULL,
  newobj = NULL,
  datasources = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ds.case_when_+3A_tidy_expr">tidy_expr</code></td>
<td>
<p>A list containing a sequence of two-sided formulas:
</p>

<ul>
<li><p> The left hand side (LHS) determines which values match this case.
</p>
</li>
<li><p> The right hand side (RHS) provides the replacement value.
</p>
</li>
<li><p> The LHS inputs must evaluate to logical vectors.
</p>
</li>
<li><p> The RHS inputs will be coerced to their common type.
</p>
</li></ul>

<p>All inputs will be recycled to their common size. We encourage all LHS inputs to be the same size.
Recycling is mainly useful for RHS inputs, where you might supply a size 1 input that will be
recycled to the size of the LHS inputs. NULL inputs are ignored.</p>
</td></tr>
<tr><td><code id="ds.case_when_+3A_.default">.default</code></td>
<td>
<p>The value used when all of the LHS inputs return either FALSE or NA.</p>
</td></tr>
<tr><td><code id="ds.case_when_+3A_.ptype">.ptype</code></td>
<td>
<p>An optional prototype declaring the desired output type. If supplied, this overrides the common type of true, false, and missing.</p>
</td></tr>
<tr><td><code id="ds.case_when_+3A_.size">.size</code></td>
<td>
<p>An optional size declaring the desired output size. If supplied, this overrides the size of condition.</p>
</td></tr>
<tr><td><code id="ds.case_when_+3A_newobj">newobj</code></td>
<td>
<p>Character specifying name for new server-side data frame.</p>
</td></tr>
<tr><td><code id="ds.case_when_+3A_datasources">datasources</code></td>
<td>
<p>datashield connections object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for its side effects. A vector with the same size as the common
size computed from the inputs in <code>tidy_expr</code> and the same type as the common type of the
RHS inputs in <code>tidy_expr</code> is created on the server.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## First log in to a DataSHIELD session with mtcars dataset loaded.

ds.case_when(
  tidy_expr = list(
    mtcars$mpg &lt; 10 ~ "low",
    mtcars$mpg &gt;= 10 &amp; mtcars$mpg &lt; 20 ~ "medium",
    mtcars$mpg &gt;= 20 ~ "high"
  ),
  newobj = "test",
  datasources = conns
)

## Refer to the package vignette for more examples.

## End(Not run)
</code></pre>

<hr>
<h2 id='ds.distinct'>Keep distinct/unique rows</h2><span id='topic+ds.distinct'></span>

<h3>Description</h3>

<p>DataSHIELD implentation of <code>dplyr::distinct</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ds.distinct(
  df.name = NULL,
  tidy_expr = NULL,
  .keep_all = FALSE,
  newobj = NULL,
  datasources = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ds.distinct_+3A_df.name">df.name</code></td>
<td>
<p>Character specifying a serverside data frame or tibble.</p>
</td></tr>
<tr><td><code id="ds.distinct_+3A_tidy_expr">tidy_expr</code></td>
<td>
<p>Optionally, list of variables to use when determining uniqueness. If there are multiple rows
for a given combination of inputs, only the first row will be preserved. If omitted, will use all
variables in the data frame.</p>
</td></tr>
<tr><td><code id="ds.distinct_+3A_.keep_all">.keep_all</code></td>
<td>
<p>If TRUE, keep all variables in .data. If a combination of <code>expr</code> is not
distinct, this keeps the first row of values.</p>
</td></tr>
<tr><td><code id="ds.distinct_+3A_newobj">newobj</code></td>
<td>
<p>Character specifying name for new server-side data frame.</p>
</td></tr>
<tr><td><code id="ds.distinct_+3A_datasources">datasources</code></td>
<td>
<p>DataSHIELD connections object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for its side effects. An object (typically a data frame or tibble)
with the name specified by <code>newobj</code> is created on the server.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ds.distinct(
  df.name = "mtcars",
  expr = list(mpg, cyl),
  newobj = "distinct_df"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='ds.filter'>Keep rows that match a condition</h2><span id='topic+ds.filter'></span>

<h3>Description</h3>

<p>DataSHIELD implentation of <code>dplyr::filter</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ds.filter(
  df.name = NULL,
  tidy_expr = NULL,
  .by = NULL,
  .preserve = FALSE,
  newobj = NULL,
  datasources = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ds.filter_+3A_df.name">df.name</code></td>
<td>
<p>Character specifying a serverside data frame or tibble.</p>
</td></tr>
<tr><td><code id="ds.filter_+3A_tidy_expr">tidy_expr</code></td>
<td>
<p>List of expressions that return a logical value, and are defined in terms of the
variables in <code>df.name</code>.</p>
</td></tr>
<tr><td><code id="ds.filter_+3A_.by">.by</code></td>
<td>
<p>Optionally, a selection of columns to group by for just this operation, functioning as an alternative to <code>dplyr::group_by</code></p>
</td></tr>
<tr><td><code id="ds.filter_+3A_.preserve">.preserve</code></td>
<td>
<p>Relevant when the .data input is grouped. If .preserve = FALSE (the default),
the grouping structure is recalculated based on the resulting data, otherwise the grouping is
kept as is.</p>
</td></tr>
<tr><td><code id="ds.filter_+3A_newobj">newobj</code></td>
<td>
<p>Character specifying name for new server-side data frame.</p>
</td></tr>
<tr><td><code id="ds.filter_+3A_datasources">datasources</code></td>
<td>
<p>DataSHIELD connections object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for its side effects. An object (typically a data frame or tibble)
with the name specified by <code>newobj</code> is created on the server.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ds.filter(
  df.name = "mtcars",
  tidy_expr = list(cyl == 4 &amp; mpg &gt; 20),
  newobj = "filtered",
  datasources = conns
)

## End(Not run)
</code></pre>

<hr>
<h2 id='ds.group_by'>Group by one or more variables</h2><span id='topic+ds.group_by'></span>

<h3>Description</h3>

<p>DataSHIELD implentation of <code>dplyr::group_by</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ds.group_by(
  df.name = NULL,
  tidy_expr,
  .add = FALSE,
  .drop = TRUE,
  newobj = NULL,
  datasources = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ds.group_by_+3A_df.name">df.name</code></td>
<td>
<p>Character specifying a serverside data frame or tibble.</p>
</td></tr>
<tr><td><code id="ds.group_by_+3A_tidy_expr">tidy_expr</code></td>
<td>
<p>List of variables or computations to group by.</p>
</td></tr>
<tr><td><code id="ds.group_by_+3A_.add">.add</code></td>
<td>
<p>When FALSE, the default, <code>group_by()</code> will override existing groups. To add to the
existing groups, use .add = TRUE.</p>
</td></tr>
<tr><td><code id="ds.group_by_+3A_.drop">.drop</code></td>
<td>
<p>Drop groups formed by factor levels that don't appear in the data? The default is
TRUE except when .data has been previously grouped with .drop = FALSE.</p>
</td></tr>
<tr><td><code id="ds.group_by_+3A_newobj">newobj</code></td>
<td>
<p>Character specifying name for new server-side data frame.</p>
</td></tr>
<tr><td><code id="ds.group_by_+3A_datasources">datasources</code></td>
<td>
<p>DataSHIELD connections object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for its side effects. A grouped data frame with class grouped_df
<code>newobj</code> is created on the server, unless the combination of <code>tidy_expr</code> and <code>.add</code>
yields a empty set of grouping columns, in which case a tibble will be created on the server.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ds.group_by(
  df.name = "mtcars",
  expr = list(mpg, cyl),
  newobj = "grouped_df"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='ds.group_keys'>Describe the groups within a grouped tibble or data frame</h2><span id='topic+ds.group_keys'></span>

<h3>Description</h3>

<p>DataSHIELD implentation of <code>dplyr::group_keys</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ds.group_keys(df.name = NULL, datasources = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ds.group_keys_+3A_df.name">df.name</code></td>
<td>
<p>Character specifying a serverside tibble.</p>
</td></tr>
<tr><td><code id="ds.group_keys_+3A_datasources">datasources</code></td>
<td>
<p>DataSHIELD connections object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame describing the groups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
my_groups &lt;- ds.group_keys("grouped_df")

## End(Not run)
</code></pre>

<hr>
<h2 id='ds.if_else'>Vectorised if-else</h2><span id='topic+ds.if_else'></span>

<h3>Description</h3>

<p>DataSHIELD implementation of <code>dplyr::if_else</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ds.if_else(
  condition = NULL,
  true = NULL,
  false = NULL,
  missing = NULL,
  ptype = NULL,
  size = NULL,
  newobj = NULL,
  datasources = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ds.if_else_+3A_condition">condition</code></td>
<td>
<p>A list specifying a logical vector in tidyverse syntax, ie data and column names unquoted.</p>
</td></tr>
<tr><td><code id="ds.if_else_+3A_true">true</code></td>
<td>
<p>Vector to use for TRUE value of condition.</p>
</td></tr>
<tr><td><code id="ds.if_else_+3A_false">false</code></td>
<td>
<p>Vector to use for FALSE value of condition.</p>
</td></tr>
<tr><td><code id="ds.if_else_+3A_missing">missing</code></td>
<td>
<p>If not NULL, will be used as the value for NA values of condition. Follows the same size and type rules as true and false.</p>
</td></tr>
<tr><td><code id="ds.if_else_+3A_ptype">ptype</code></td>
<td>
<p>An optional prototype declaring the desired output type. If supplied, this overrides the common type of true, false, and missing.</p>
</td></tr>
<tr><td><code id="ds.if_else_+3A_size">size</code></td>
<td>
<p>An optional size declaring the desired output size. If supplied, this overrides the size of condition.</p>
</td></tr>
<tr><td><code id="ds.if_else_+3A_newobj">newobj</code></td>
<td>
<p>Character specifying name for new server-side data frame.</p>
</td></tr>
<tr><td><code id="ds.if_else_+3A_datasources">datasources</code></td>
<td>
<p>datashield connections object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for its side effects. A vector with the same size as
<code>condition</code> and the same type as the common type of <code>true</code>, <code>false</code>, and
<code>missing</code> is created on the server.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## First log in to a DataSHIELD session with mtcars dataset loaded.


## Refer to the package vignette for more examples.

## End(Not run)
</code></pre>

<hr>
<h2 id='ds.mutate'>Create, modify, and delete columns</h2><span id='topic+ds.mutate'></span>

<h3>Description</h3>

<p>DataSHIELD implementation of <code>dplyr::mutate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ds.mutate(
  df.name = NULL,
  tidy_expr = NULL,
  newobj = NULL,
  .keep = "all",
  .before = NULL,
  .after = NULL,
  datasources = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ds.mutate_+3A_df.name">df.name</code></td>
<td>
<p>Character specifying a serverside data frame or tibble.</p>
</td></tr>
<tr><td><code id="ds.mutate_+3A_tidy_expr">tidy_expr</code></td>
<td>
<p>List of tidyselect syntax to be passed to dplyr::mutate.</p>
</td></tr>
<tr><td><code id="ds.mutate_+3A_newobj">newobj</code></td>
<td>
<p>Character specifying name for new server-side data frame.</p>
</td></tr>
<tr><td><code id="ds.mutate_+3A_.keep">.keep</code></td>
<td>
<p>Control which columns from <code>df.name</code> are retained in the output. Options include:
</p>

<ul>
<li> <p><code>"all"</code>: Retains all columns from <code>df.name</code>. This is the default.
</p>
</li>
<li> <p><code>"used"</code>: Retains only the columns used in <code>tidy_expr</code> to create new columns.
</p>
</li>
<li> <p><code>"unused"</code>: Retains only the columns not used in <code>tidy_expr</code> to create new columns. This is useful if you generate new columns but no longer need the columns used to generate them.
</p>
</li>
<li> <p><code>"none"</code>: Doesn't retain any extra columns from <code>df.name</code>. Only the grouping variables and columns created by <code>tidy_expr</code> are kept.
</p>
</li></ul>

<p>Grouping columns and columns created by <code>tidy_expr</code> are always kept.</p>
</td></tr>
<tr><td><code id="ds.mutate_+3A_.before">.before</code></td>
<td>
<p>&lt;tidy-select&gt; Optionally, control where new columns should appear (the default is
to add to the right hand side). See <code>tidy_expr</code> for more details.</p>
</td></tr>
<tr><td><code id="ds.mutate_+3A_.after">.after</code></td>
<td>
<p>&lt;tidy-select&gt; Optionally, control where new columns should appear (the default is
to add to the right hand side). See <code>tidy_expr</code> for more details.</p>
</td></tr>
<tr><td><code id="ds.mutate_+3A_datasources">datasources</code></td>
<td>
<p>datashield connections object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for its side effects. An object (typically a data frame or tibble)
with the name specified by <code>newobj</code> is created on the server.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## First log in to a DataSHIELD session with mtcars dataset loaded.

ds.mutate(
  df.name = "mtcars",
  tidy_select = list(mpg_trans = cyl * 1000, new_var = (hp - drat) / qsec),
  newobj = "df_with_new_cols"
)

## Refer to the package vignette for more examples.

## End(Not run)
</code></pre>

<hr>
<h2 id='ds.rename'>Rename columns</h2><span id='topic+ds.rename'></span>

<h3>Description</h3>

<p>DataSHIELD implentation of <code>dplyr::rename</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ds.rename(df.name = NULL, tidy_expr = NULL, newobj = NULL, datasources = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ds.rename_+3A_df.name">df.name</code></td>
<td>
<p>Character specifying a serverside data frame or tibble.</p>
</td></tr>
<tr><td><code id="ds.rename_+3A_tidy_expr">tidy_expr</code></td>
<td>
<p>List with format new_name = old_name to rename selected variables.</p>
</td></tr>
<tr><td><code id="ds.rename_+3A_newobj">newobj</code></td>
<td>
<p>Character specifying name for new server-side data frame.</p>
</td></tr>
<tr><td><code id="ds.rename_+3A_datasources">datasources</code></td>
<td>
<p>DataSHIELD connections object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for its side effects. An object (typically a data frame or tibble)
with the name specified by <code>newobj</code> is created on the server.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## First log in to a DataSHIELD session with mtcars dataset loaded.

ds.rename(
  df.name = "mtcars",
  tidy_select = list(new_var_1 = mpg, new_var_2 = cyl),
  newobj = "df_renamed",
  dataources = conns
)

## Refer to the package vignette for more examples.

## End(Not run)
</code></pre>

<hr>
<h2 id='ds.select'>Keep or drop columns using their names and types</h2><span id='topic+ds.select'></span>

<h3>Description</h3>

<p>DataSHIELD implentation of <code>dplyr::select</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ds.select(df.name = NULL, tidy_expr = NULL, newobj = NULL, datasources = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ds.select_+3A_df.name">df.name</code></td>
<td>
<p>Character specifying a serverside data frame or tibble.</p>
</td></tr>
<tr><td><code id="ds.select_+3A_tidy_expr">tidy_expr</code></td>
<td>
<p>List of one or more unquoted expressions separated by commas. Variable names can
be used as if they were positions in the data frame, so expressions like x:y can be used to
select a range of variables.</p>
</td></tr>
<tr><td><code id="ds.select_+3A_newobj">newobj</code></td>
<td>
<p>Character specifying name for new server-side data frame.</p>
</td></tr>
<tr><td><code id="ds.select_+3A_datasources">datasources</code></td>
<td>
<p>DataSHIELD connections object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for its side effects. An object (typically a data frame or tibble)
with the name specified by <code>newobj</code> is created on the server.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ds.select(
  df.name = "mtcars",
  tidy_expr = list(mpg, starts_with("t")),
  newobj = "df_subset",
  dataources = conns
)

## End(Not run)
</code></pre>

<hr>
<h2 id='ds.slice'>Subset rows using their positions</h2><span id='topic+ds.slice'></span>

<h3>Description</h3>

<p>DataSHIELD implentation of <code>dplyr::slice</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ds.slice(
  df.name = NULL,
  tidy_expr = NULL,
  .by = NULL,
  .preserve = FALSE,
  newobj = NULL,
  datasources = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ds.slice_+3A_df.name">df.name</code></td>
<td>
<p>Character specifying a serverside data frame or tibble.</p>
</td></tr>
<tr><td><code id="ds.slice_+3A_tidy_expr">tidy_expr</code></td>
<td>
<p>List, provide either positive values to keep, or negative values to drop. The values
provided must be either all positive or all negative. Indices beyond the number of rows in the
input are silently ignored.</p>
</td></tr>
<tr><td><code id="ds.slice_+3A_.by">.by</code></td>
<td>
<p>Optionally, a selection of columns to group by for just this operation, functioning as
an alternative to <code>dplyr::group_by</code></p>
</td></tr>
<tr><td><code id="ds.slice_+3A_.preserve">.preserve</code></td>
<td>
<p>Relevant when the .data input is grouped. If .preserve = FALSE (the default),
the grouping structure is recalculated based on the resulting data, otherwise the grouping is
kept as is.</p>
</td></tr>
<tr><td><code id="ds.slice_+3A_newobj">newobj</code></td>
<td>
<p>Character specifying name for new server-side data frame.</p>
</td></tr>
<tr><td><code id="ds.slice_+3A_datasources">datasources</code></td>
<td>
<p>DataSHIELD connections object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for its side effects. An object (typically a data frame or tibble)
with the name specified by <code>newobj</code> is created on the server.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ds.slice(
  df.name = "mtcars",
  expr = list(1:10),
  .by = "cyl",
  newobj = "sliced_df"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='ds.ungroup'>Remove grouping from a tibble or data frame</h2><span id='topic+ds.ungroup'></span>

<h3>Description</h3>

<p>DataSHIELD implentation of <code>dplyr::ungroup</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ds.ungroup(x = NULL, newobj = NULL, datasources = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ds.ungroup_+3A_x">x</code></td>
<td>
<p>a tibble or data frame.</p>
</td></tr>
<tr><td><code id="ds.ungroup_+3A_newobj">newobj</code></td>
<td>
<p>Character specifying name for new server-side data frame.</p>
</td></tr>
<tr><td><code id="ds.ungroup_+3A_datasources">datasources</code></td>
<td>
<p>DataSHIELD connections object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for its side effects. An ungrouped data frame or tibble is
created on the server.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ds.ungroup("grouped_df")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
