<!DOCTYPE html><html lang="en"><head><title>Help for package fRegression</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fRegression}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fRegression-package'><p>Regression Modelling Package</p></a></li>
<li><a href='#coef-methods'><p>REG coefficients Methods</p></a></li>
<li><a href='#fitted-methods'><p>Extract Regression Model Fitted Values</p></a></li>
<li><a href='#formula-methods'><p>Extract Regression Model formula</p></a></li>
<li><a href='#fREG-class'><p>Class &quot;fREG&quot;</p></a></li>
<li><a href='#plot-methods'><p>Regression Model Plot Methods</p></a></li>
<li><a href='#predict-methods'><p>Regression Models Prediction Function</p></a></li>
<li><a href='#regFit'><p>Regression Modelling</p></a></li>
<li><a href='#RegressionTestsInterface'><p>Regression Tests</p></a></li>
<li><a href='#regSim'><p>Regression Model Simulation</p></a></li>
<li><a href='#residuals-methods'><p>Extract Regression Model Residuals</p></a></li>
<li><a href='#show-methods'><p>Regression Modelling Show Methods</p></a></li>
<li><a href='#summary-methods'><p>Regression Summary Methods</p></a></li>
<li><a href='#termPlot'><p>Regression Model Plot Methods</p></a></li>
<li><a href='#terms-methods'><p>Regression Model Plot Methods</p></a></li>
<li><a href='#vcov-methods'><p>Extract Regression Model vcov</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Rmetrics - Regression Based Decision and Prediction</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-11</td>
</tr>
<tr>
<td>Version:</td>
<td>4021.83</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions for linear and non-linear regression 
  modelling. It implements a wrapper for several regression models available 
  in the base and contributed packages of R. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>fBasics, lmtest, MASS, methods, mgcv, nnet, polspline, stats,
timeDate, timeSeries, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RUnit</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.rmetrics.org">https://www.rmetrics.org</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://r-forge.r-project.org/projects/rmetrics">https://r-forge.r-project.org/projects/rmetrics</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-11 09:25:20 UTC; paul</td>
</tr>
<tr>
<td>Author:</td>
<td>Diethelm Wuertz [aut],
  Tobias Setz [aut],
  Yohan Chalabi [aut],
  Paul J. Northrop [cre, ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul J. Northrop &lt;p.northrop@ucl.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-11 09:40:19 UTC</td>
</tr>
</table>
<hr>
<h2 id='fRegression-package'>Regression Modelling Package</h2><span id='topic+fRegression-package'></span><span id='topic+fRegression'></span>

<h3>Description</h3>

<p>The Rmetrics &quot;fRegression&quot; package is a collection of functions 
for linear and non-linear regression modelling.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
        Package:    </td><td style="text-align: left;"> fRegression</td>
</tr>
<tr>
 <td style="text-align: left;">
        Type:       </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
        Version:    </td><td style="text-align: left;"> R 3.0.1</td>
</tr>
<tr>
 <td style="text-align: left;">
        Date:       </td><td style="text-align: left;"> 2014</td>
</tr>
<tr>
 <td style="text-align: left;">
        License:    </td><td style="text-align: left;"> GPL Version 2 or later</td>
</tr>
<tr>
 <td style="text-align: left;">
        Copyright:  </td><td style="text-align: left;"> (c) 1999-2014 Rmetrics Association</td>
</tr>
<tr>
 <td style="text-align: left;">
        Repository: </td><td style="text-align: left;"> R-FORGE</td>
</tr>
<tr>
 <td style="text-align: left;">
        URL:        </td><td style="text-align: left;"> <a href="https://www.rmetrics.org">https://www.rmetrics.org</a>
    </td>
</tr>

</table>



<h3>1 Introduction</h3>

<p>Regression modelling, especially linear modelling, LM, is a widely
used application in financial engineering. In finance it mostly 
appears in form that a variable is modelled as a linear or more complex 
relationship as a function of other variables. For example the 
decision of buying or selling in a trading model may be triggered 
by the outcome of a regression model, e.g. neural networks are a 
well known tool in this field.
</p>


<h3>2 Fitting Regression Models</h3>

<p>Rmetrics has build a unique interface to several regression
models available in the base and contributed packages of R. 
The following regression models are interfaced and 
available through a common function <code>regFit</code>. The 
argument <code>use</code> allows to select the desired model:
</p>
<pre>
    regFit          fits regression models
    - lm            fits a linear model [stats]
    - rlm           fits a LM by robust regression [MASS]
    - glm           fits a generliazed linear model [stats]
    - gam           fits a generlized additive model [mgcv]
    - ppr           fits a projection pursuit regression model [stats]
    - nnet          fits a single hidden-layer neural network model [nnet]
    - polymars      fits an adaptive polynomial spline regression [polspline]
    </pre>
<p>An advantage of the <code>regFit</code> function is, that all the
underlying functions of its family can be called with the same
list of arguments, and the value returned is always an unique
object, an object of class <code>"fREG"</code> with the following slots:
<code>@call</code>, <code>@formula</code>, <code>@method</code>, <code>@data</code>, 
<code>@fit</code>, <code>@residuals</code>, <code>@fitted</code>, <code>@title</code>, 
and <code>@description</code>.
</p>
<p>Furthermore, independent of the selected regression model applied 
we can use the same S4 methods for all types of regressions. This 
includes, <code>print</code>,<code>plot</code>, <code>summary</code>, <code>predict</code>, 
<code>fitted</code>, <code>residuals</code>, <code>coef</code>, <code>vcov</code>, and 
<code>formula</code> methods.
</p>
<p>It is possible to add further regression models to this framework
either his own implementations or implementations available through 
other contributed R packages. Suggestions include <code>biglm</code>,
<code>earth</code> amongst others.
</p>


<h3>2 Simulation of Regression Models</h3>

<p>contains a function to simulate artificial regression models, 
mostly used for testing.
</p>
<pre>
    regSim          simulates artificial regression model data sets
    </pre>


<h3>3 Extractor Functions</h3>

<p>These generic functions are:
</p>
<pre>
    fitted          extracts fitted values from a fitted 'fREG' object
    residuals       extracts residuals from a fitted 'fREG' object
    coef            extracts coefficients from a fitted 'fREG' object
    formula         extracts formula expression from a fitted 'fREG' object
    vcov            extracts variance-covariance matrix of fitted parameters
    </pre>


<h3>4 Forecasting</h3>

<p>The function <code>predict</code> returns predicted values based on the 
fitted model object.
</p>
<pre>
    predict         forecasts from an object of class 'fREG'
    </pre>


<h3>4 Reporting Functions</h3>

<p>For printing and plotting use the functions:
</p>
<pre>
    print           prints the results from a regression fit
    plot            plots the results from a gression fit
    summary         returns a summary report       
    </pre>


<h3>About Rmetrics:</h3>

<p>The <code>fRegression</code> Rmetrics package is written for educational 
support in teaching &quot;Computational Finance and Financial Engineering&quot; 
and licensed under the GPL.
</p>

<hr>
<h2 id='coef-methods'>REG coefficients Methods</h2><span id='topic+coef-methods'></span><span id='topic+coef+2CANY-method'></span><span id='topic+coef+2CfREG-method'></span>

<h3>Description</h3>

<p>Extracts coefficients from a fitted regression model. 
</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;ANY&quot;</dt><dd>
<p>Generic function.
</p>
</dd>
<dt>object = &quot;fREG&quot;</dt><dd>
<p>Extractor function for coefficients.
</p>
</dd>
</dl>



<h3>Note</h3>

<p><code>coef</code> is a generic function which extracts the coefficients
from objects returned by modeling functions, here the <code>regFit</code>
and <code>gregFit</code> parameter estimation functions.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## regSim -
   x = regSim(model = "LM3", n = 50)
  
## regFit -
   fit = regFit(Y ~ X1 + X2 + X3, data = x, use = "lm")
   
## coef - 
   coef(fit)
</code></pre>

<hr>
<h2 id='fitted-methods'>Extract Regression Model Fitted Values</h2><span id='topic+fitted-methods'></span><span id='topic+fitted+2CANY-method'></span><span id='topic+fitted+2CfREG-method'></span>

<h3>Description</h3>

<p>Extracts fitted values from a fitted regression model. 
</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;ANY&quot;</dt><dd>
<p>Generic function
</p>
</dd>
<dt>object = &quot;fREG&quot;</dt><dd>
<p>Extractor function for fitted values.
</p>
</dd>
</dl>



<h3>Note</h3>

<p><code>fitted</code> is a generic function which extracts fitted values 
from objects returned by modeling functions, here the <code>regFit</code>
and <code>gregFit</code> parameter estimation functions.
</p>
<p>The class of the fitted values is the same as the class of the 
data input to the function <code>regFit</code> or <code>gregFit</code>. In
contrast the slot <code>fitted</code> returns a numeric vector.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## regSim -
   x.df = regSim(model = "LM3", n = 50)
  
## regFit -
   # Use data.frame input:
   fit = regFit(Y ~ X1 + X2 + X3, data = x.df, use = "lm")
   
## fitted - 
   val = slot(fit, "fitted")
   head(val)
   class(val)
   val = fitted(fit)
   head(val)
   class(val)
   
## regFit -
   # Convert to dummy timeSeries Object:
   library(timeSeries)
   x.tS = as.timeSeries(x.df)
   fit = regFit(Y ~ X1 + X2 + X3, data = x.tS, use = "lm")
   
## fitted - 
   val = slot(fit, "fitted")
   head(val)
   class(val)
   val = fitted(fit)
   head(val)
   class(val)
</code></pre>

<hr>
<h2 id='formula-methods'>Extract Regression Model formula</h2><span id='topic+formula-methods'></span><span id='topic+formula+2CANY-method'></span><span id='topic+formula+2CfREG-method'></span>

<h3>Description</h3>

<p>Extracts formula from a fitted regression model. 
</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;ANY&quot;</dt><dd>
<p>Generic function
</p>
</dd>
<dt>object = &quot;fGARCH&quot;</dt><dd>
<p>Formula
</p>
</dd>
</dl>



<h3>Note</h3>

<p><code>formula</code> is a generic function which extracts the formula
expression from objects returned by modeling functions, here the 
<code>regFit</code> and <code>gregFit</code> parameter estimation function. 
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## regSim -
   x = regSim(model = "LM3", n = 50)
  
## regFit -
   fit = regFit(Y ~ X1 + X2 + X3, data = x, use = "lm")
   
## formula - 
   formula(fit)
</code></pre>

<hr>
<h2 id='fREG-class'>Class &quot;fREG&quot;</h2><span id='topic+fREG-class'></span>

<h3>Description</h3>

 
<p>The class 'fREG' represents a fitted model of an heteroskedastic
time series process.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the function <code>regFit</code>. 
The returned object represents parameter estimates of linear and 
generalized linear models.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"call"</code>: 
the call of the <code>garch</code> function.
</p>
</dd> 
<dt><code>formula</code>:</dt><dd><p>Object of class <code>"formula"</code>: 
the formula used in parameter estimation.
</p>
</dd>   
<dt><code>family</code>:</dt><dd><p>Object of class <code>"character"</code>: 
the family objects provide a convenient way to specify 
the details of the models used by function <code>grefFit</code>
For details we refer to the documentation for the function
<code>glm</code> in R's base package on how such model fitting 
takes place. 
</p>
</dd>      
<dt><code>method</code>:</dt><dd><p>Object of class <code>"character"</code>: 
a string denoting the regression model in use, i.e. one
of those listed in the <code>use</code> argument of the function 
<code>regFit</code> or <code>gregFit</code>.
</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"list"</code>: 
a list with at least two entries named <code>x</code> containing the 
data frame used for the estimation, and <code>data</code> with the
object of the rectangular input data.
</p>
</dd>
<dt><code>fit</code>:</dt><dd><p>Object of class <code>"list"</code>: 
a list with the results from the parameter estimation. The entries
of the list depend on the selected algorithm, see below.
</p>
</dd>
<dt><code>residuals</code>:</dt><dd><p>Object of class <code>"numeric"</code>: 
a numeric vector with the residual values.
</p>
</dd>
<dt><code>fitted</code>:</dt><dd><p>Object of class <code>"numeric"</code>: 
a numeric vector with the fitted values.
</p>
</dd>
<dt><code>title</code>:</dt><dd><p>Object of class <code>"character"</code>: 
a title string.
</p>
</dd>
<dt><code>description</code>:</dt><dd><p>Object of class <code>"character"</code>: 
a string with a brief description.
</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "fREG")</code>: 
prints an object of class 'fREG'.
</p>
</dd>    
<dt>plot</dt><dd><p><code>signature(x = "fREG", y = "missing")</code>: 
plots an object of class 'fREG'.
</p>
</dd>  
<dt>summary</dt><dd><p><code>signature(object = "fREG")</code>: 
summarizes results and diagnostic analysis of an object 
of class 'fREG'.
</p>
</dd>
<dt>predict</dt><dd><p><code>signature(object = "fREG")</code>: 
forecasts mean and volatility from an object of class 'fREG'.
</p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "fREG")</code>: 
extracts fitted values from an object of class 'fREG'.
</p>
</dd>     
<dt>residuals</dt><dd><p><code>signature(object = "fREG")</code>: 
extracts fresiduals from an object of class 'fREG'.
</p>
</dd>
<dt>coef</dt><dd><p><code>signature(object = "fREG")</code>: 
extracts fitted coefficients from an object of class 'fREG'.
</p>
</dd>
<dt>formula</dt><dd><p><code>signature(x = "fREG")</code>: 
extracts formula expression from an object of class 'fREG'.
</p>
</dd> 
</dl>



<h3>Author(s)</h3>

<p>Diethelm Wuertz and Rmetrics Core Team.
</p>

<hr>
<h2 id='plot-methods'>Regression Model Plot Methods</h2><span id='topic+plot-methods'></span><span id='topic+plot+2CANY+2CANY-method'></span><span id='topic+plot+2CfREG+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plots results obtained from a fitted regression model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'fREG,missing'
plot(x, which = "ask", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot-methods_+3A_x">x</code></td>
<td>

<p>an object of class 'fREG'.
</p>
</td></tr> 
<tr><td><code id="plot-methods_+3A_which">which</code></td>
<td>

<p>a character string selecting which plot should be displayed.
By default <code>which="ask"</code> which allows to generate plots
interactively.
</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed to the underlying plot
functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plots are a set of graphs which are common to the regression
models implemented in the function <code>regFit</code>. This includes
linear regression models <code>use="lm"</code>, 
robust linear regression models <code>use="rlm"</code>, 
generalized linear regression models <code>use = "glm"</code>, 
generalized additive regression models <code>use = "gam"</code>, 
projection pursuit regression models <code>use = "ppr"</code>, 
neural network regression models <code>use = "nnet"</code>, and
polychotomous MARS models <code>use = "polymars"</code>.
</p>
<p>In addition one can also use the original plot functions of the
original models, .e.g. <code>plot(slot(object, "fit")</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>x = &quot;ANY&quot;, y = &quot;ANY&quot;</dt><dd>
<p>Generic function.
</p>
</dd>
<dt>x = &quot;fREG&quot;, y = &quot;missing&quot;</dt><dd>
<p>Plot function to display results obtained from a fitted 
regression model. 
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## regSim -
   x = regSim(model = "LM3", n = 50)
  
## regFit -
   fit = regFit(Y ~ X1 + X2 + X3, data = x, use = "lm")
   
## plot -
</code></pre>

<hr>
<h2 id='predict-methods'>Regression Models Prediction Function</h2><span id='topic+predict-methods'></span><span id='topic+predict+2CANY-method'></span><span id='topic+predict+2CfREG-method'></span>

<h3>Description</h3>

<p>Predicts a time series from a fitted regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'fREG'
predict(object, newdata, se.fit = FALSE, type = "response", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict-methods_+3A_newdata">newdata</code></td>
<td>

<p>new data.
</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_object">object</code></td>
<td>

<p>an object of class <code>fREG</code> as returned from the function
<code>regFit()</code>.
</p>
</td></tr>   
<tr><td><code id="predict-methods_+3A_se.fit">se.fit</code></td>
<td>

<p>a logical flag. Should standard errors be included?
By default <code>FALSE</code>.
</p>
</td></tr>  
<tr><td><code id="predict-methods_+3A_type">type</code></td>
<td>

<p>a character string by default <code>"response"</code>.
</p>
</td></tr>  
<tr><td><code id="predict-methods_+3A_...">...</code></td>
<td>

<p>arguments to be passed.
</p>
</td></tr>   
</table>


<h3>Value</h3>

<p>returns ...
</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;ANY&quot;</dt><dd>
<p>Generic function
</p>
</dd>
<dt>object = &quot;fREG&quot;</dt><dd>
<p>Predict method for regression models.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## regSim -
   x &lt;- regSim(model = "LM3", n = 50)
  
## regFit -
   fit &lt;- regFit(Y ~ X1 + X2 + X3, data = x, use = "lm")
</code></pre>

<hr>
<h2 id='regFit'>Regression Modelling</h2><span id='topic+regFit'></span><span id='topic+gregFit'></span>

<h3>Description</h3>

<p>Estimates the parameters of a regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    
regFit(formula, data, family = gaussian, 
    use = c("lm", "rlm", "glm", "gam", "ppr", "nnet", "polymars"), 
    title = NULL, description = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regFit_+3A_data">data</code></td>
<td>

<p><code>data</code> is the data frame containing the variables in the 
model. By default the variables are taken from 
<code>environment(formula)</code>, typically the environment from 
which <code>lm</code> is called.
</p>
</td></tr>
<tr><td><code id="regFit_+3A_description">description</code></td>
<td>

<p>a brief description of the project of type character.
</p>
</td></tr>
<tr><td><code id="regFit_+3A_family">family</code></td>
<td>

<p>a description of the error distribution and link function to be 
used in <code>glm</code> and <code>gam</code> models. See <code><a href="stats.html#topic+glm">glm</a></code> 
and <code><a href="stats.html#topic+family">family</a></code> for more details.
</p>
</td></tr>
<tr><td><code id="regFit_+3A_formula">formula</code></td>
<td>

<p>a symbolic description of the model to be fit.
<br />
A typical <code>glm</code> predictor has the form <code>response ~ terms</code> 
where <code>response</code> is the (numeric) response vector and <code>terms</code>
is a series of terms which specifies a (linear) predictor for 
<code>response</code>. For <code>binomial</code> models the response can also 
be specified as a <code>factor</code>.
<br />
A <code>gam</code> formula, see also <code>gam.models</code>, allows
that smooth terms can be added to the right hand side of the 
formula. See <code>gam.side.conditions</code> for details and 
examples.
</p>
</td></tr>  
<tr><td><code id="regFit_+3A_use">use</code></td>
<td>

<p>denotes the regression method by a character string used to fit 
the model.
<code>method</code> must be one of the strings in the default argument.<br />
<code>"lm"</code>, for linear regression models, <br />
<code>"rlm"</code>, for robust linear regression models, <br />
<code>"glm"</code> for generalized linear modelling, <br />
<code>"gam"</code> for generalized additive modelling, <br />
<code>"ppr"</code> for projection pursuit regression, <br />
<code>"nnet"</code> for feedforward neural network modelling, and <br />
<code>"polymars"</code> for polychotomous MARS.
</p>
</td></tr>    
<tr><td><code id="regFit_+3A_title">title</code></td>
<td>

<p>a character string which allows for a project title.
</p>
</td></tr>
<tr><td><code id="regFit_+3A_...">...</code></td>
<td>

<p>additional optional arguments to be passed to the underlying 
functions. For details we refer to inspect the following help 
pages: <code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>, <code>gam</code>,
<code><a href="stats.html#topic+ppr">ppr</a></code>, <code>polymars</code>, 
or <code>nnet</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>regFit</code> was created to provide a selection of
regression models working together with Rmetrics' <code>"timeSeries"</code>
objects and providing a common S4 object as the returned value. These
models include linear modeling, robust linear modeling, generalized
linear modeling, generalized additive modelling, projection pursuit
regression, neural networks, and polychotomous MARS models.<br />
</p>

<p><b>LM &ndash; Linear Modelling:</b>
<br /><br />  
Univariate linear regression analysis is a statistical methodology 
that assumes a linear relationship between some predictor variables 
and a response variable. The goal is to estimate the coefficients 
and to predict new data from the estimated linear relationship.
</p>
<p>R's base function
</p>
<p><code>lm(formula, data, subset, weights, na.action, method = "qr", </code><br />
<code> model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, </code><br /> 
<code> contrasts = NULL, offset, ...) </code><br />
</p>
<p>is used to fit linear models. It can be used to carry out regression, 
single stratum analysis of variance and analysis of covariance, although 
<code>aov</code> may provide a more convenient interface for these. 
</p>
<p>Rmetrics' function 
</p>
<p><code>regFit(formula, data, use = "lm", ...) </code><br />
</p>
<p>calls R's base function <code>lm</code> but with the difference that the
<code>data</code> argument, may be any rectangular object which can be 
transferred by the function <code>as.data.frame</code> into a data frame
with named columns, e.g. an object of class <code>"timeSeries"</code>. 
The function <code>regFit</code> returns an S4 object of class <code>"fREG"</code> 
whose slot <code>@fit</code> is the object as returned by the function 
<code>"lm"</code>. In addition we have S4 methods <code>fitted</code> and 
<code>residuals</code> which allow to retrieve the fitted values and the 
residuals as objects of same class as defined by the argument 
<code>data</code>.
</p>
<p>The function <code>plot.lm</code> provides four plots: a plot of residuals 
against fitted values, a Scale-Location plot of sqrt(| residuals |) 
against fitted values, a normal QQ plot, and a plot of Cook's 
distances versus row labels.<br /> 
<code>[stats:lm]</code>
<br />
</p>

<p><b>LM &ndash; Robust Linear Modelling:</b>
<br /><br />  
</p>
<p>To fit a linear model by robust regression using an M estimator R
offers the function 
</p>
<p><code>rlm(formula, data, weights, ..., subset, na.action, </code><br />
<code>  method = c("M", "MM", "model.frame"), </code><br />
<code>  wt.method = c("inv.var", "case"), </code><br />
<code>  model = TRUE, x.ret = TRUE, y.ret = FALSE, contrasts = NULL) </code><br />
</p>
<p>from package <code>MASS</code>. Again we can use the Rmetrics' wrapper
</p>
<p><code>regFit(formula, data, use = "rlm", ...) </code><br />
</p>
<p>which allows us to use for example S4 <code>timeSeries</code> objects as
input and to get the output as an S4 object with the known slots.<br />
<code>[MASS::rlm]</code>
<br />
</p>

<p><b>GLM &ndash; Generalized Linear Models:</b>
<br /><br />
Generalized linear modelling extends the linear model in two directions.
(i) with a monotonic differentiable link function describing how the 
expected values are related to the linear predictor, and (ii) with 
response variables having a probability distribution from an exponential 
family.<br />
</p>
<p>R's base function from package <code>stats</code> comes with the function
</p>
<p><code>glm(formula, family = gaussian, data, weights, subset, </code><br /> 
<code>  na.action, start = NULL, etastart, mustart, offset, </code><br />
<code>  control = glm.control(...), model = TRUE, method = "glm.fit", </code><br /> 
<code>  x = FALSE, y = TRUE, contrasts = NULL, ...) </code><br />
</p>
<p>Again we can use the Rmetrics' wrapper
</p>
<p><code>regFit(formula, data, use = "gam", ...) </code><br />
</p>
<p><code>[stats::glm]</code>
<br />
</p>

<p><b>GAM &ndash; Generalized Additive Models:</b>
<br /><br />  
An additive model generalizes a linear model by smoothing individually
each predictor term. A generalized additive model extends the additive
model in the same spirit as the generalized linear model extends the 
linear model, namely for allowing a link function and for allowing 
non-normal distributions from the exponential family.<br />
<code>[mgcv:gam]</code>
<br />
</p>

<p><b>PPR &ndash; Projection Pursuit Regression:</b>
<br /><br />  
The basic method is given by Friedman (1984), and is essentially 
the same code used by S-PLUS's <code>ppreg</code>. It is observed that 
this code is extremely sensitive to the compiler used. The algorithm 
first adds up to <code>max.terms</code>, by default <code>ppr.nterms</code>,
ridge terms one at a time; it will use less if it is unable to find 
a term to add that makes sufficient difference. The levels of 
optimization, argument <code>optlevel</code>, by default 2, differ in 
how thoroughly the models are refitted during this process.
At level 0 the existing ridge terms are not refitted.  At level 1
the projection directions are not refitted, but the ridge
functions and the regression coefficients are. Levels 2 and 3 refit 
all the terms; level 3 is more careful to re-balance the contributions
from each regressor at each step and so is a little less likely to
converge to a saddle point of the sum of squares criterion. The 
<code>plot</code> method plots Ridge functions for the projection pursuit 
regression fit.<br />
<code>[stats:ppr]</code>
<br />
</p>

<p><b>POLYMARS &ndash; Polychotomous MARS:</b>
<br /><br />
The algorithm employed by <code>polymars</code> is different from the 
MARS(tm) algorithm of Friedman (1991), though it has many similarities. 
Also the name <code>polymars</code> has been used for this algorithm well 
before MARS was trademarked.<br />
<code>[polyclass:polymars]</code>
<br />
</p>

<p><b>NNET &ndash; Feedforward Neural Network Regression:</b>
<br /><br />  
If the response in <code>formula</code> is a factor, an appropriate 
classification network is constructed; this has one output and 
entropy fit if the number of levels is two, and a number of 
outputs equal to the number of classes and a softmax output 
stage for more levels. If the response is not a factor, it is 
passed on unchanged to <code>nnet.default</code>. A quasi-Newton 
optimizer is used, written in <code>C</code>. <br />
<code>[nnet:nnet]</code>
</p>


<h3>Value</h3>

<p>returns an S4 object of class <code>"fREG"</code>.
</p>


<h3>Author(s)</h3>

<p>The R core team for the <code>lm</code> functions from R's <code>base</code> package, <br />
B.R. Ripley for the <code>glm</code> functions from R's <code>base</code> package, <br />
S.N. Wood for the <code>gam</code> functions from R's <code>mgcv</code> package, <br />
N.N. for the <code>ppr</code> functions from R's <code>modreg</code> package, <br />
M. O' Connors for the <code>polymars</code> functions from R's <code>?</code> package, <br />
The R core team for the <code>nnet</code> functions from R's <code>nnet</code> package, <br />
Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port.
</p>


<h3>References</h3>

<p>Belsley D.A., Kuh E., Welsch R.E. (1980);
<em>Regression Diagnostics</em>;
Wiley, New York.
</p>
<p>Dobson, A.J. (1990);
<em>An Introduction to Generalized Linear Models</em>;
Chapman and Hall, London.
</p>
<p>Draper N.R., Smith H. (1981);
<em>Applied Regression Analysis</em>; 
Wiley, New York.
</p>
<p>Friedman, J.H. (1991); 
<em>Multivariate Adaptive Regression Splines (with discussion)</em>,
The Annals of Statistics 19, 1&ndash;141.
</p>
<p>Friedman J.H., and Stuetzle W. (1981); 
<em>Projection Pursuit Regression</em>; 
Journal of the American Statistical Association 76, 817-823.
</p>
<p>Friedman J.H. (1984);
<em>SMART User's Guide</em>; 
Laboratory for Computational Statistics, 
Stanford University Technical Report No. 1.
</p>
<p>Green, Silverman (1994);
<em>Nonparametric Regression and Generalized Linear Models</em>;
Chapman and Hall.
</p>
<p>Gu, Wahba (1991); 
<em>Minimizing GCV/GML Scores with Multiple
Smoothing Parameters via the Newton Method</em>;
SIAM J. Sci. Statist. Comput. 12, 383-398.
</p>
<p>Hastie T., Tibshirani R. (1990);
<em>Generalized Additive Models</em>;
Chapman and Hall, London.
</p>
<p>Kooperberg Ch., Bose S., and  Stone C.J. (1997);
<em>Polychotomous Regression</em>,
Journal of the American Statistical Association 92, 117&ndash;127.
</p>
<p>McCullagh P., Nelder, J.A. (1989);
<em>Generalized Linear Models</em>;
Chapman and Hall, London.
</p>
<p>Myers R.H. (1986);
<em>Classical and Modern Regression with Applications</em>; 
Duxbury, Boston.
</p>
<p>Rousseeuw P.J., Leroy, A. (1987);
<em>Robust Regression and Outlier Detection</em>;
Wiley, New York.
</p>
<p>Seber G.A.F. (1977);
<em>Linear Regression Analysis</em>; 
Wiley, New York.
</p>
<p>Stone C.J., Hansen M., Kooperberg Ch., and Truong Y.K. (1997);
<em>The use of polynomial splines and their tensor products 
in extended linear modeling (with discussion)</em>.
</p>
<p>Venables, W.N., Ripley, B.D. (1999);
<em>Modern Applied Statistics with S-PLUS</em>; 
Springer, New York.
</p>
<p>Wahba (1990); 
<em>Spline Models of Observational Data</em>;
SIAM.
</p>
<p>Weisberg S. (1985);
<em>Applied Linear Regression</em>;  
Wiley, New York.
</p>
<p>Wood (2000); 
<em>Modelling and Smoothing Parameter Estimation  with
Multiple  Quadratic Penalties</em>;
JRSSB 62, 413-428.
</p>
<p>Wood (2001); 
<em>mgcv: GAMs and Generalized Ridge Regression for <span class="rlang"><b>R</b></span></em>.
R News 1, 20-25.
</p>
<p>Wood (2001);
<em>Thin Plate Regression Splines</em>.
</p>
<p>There exists a vast literature on regression. The references listed 
above are just a small sample of what is available. The book by 
Myers' is an introductory text book that covers discussions of much 
of the recent advances in regression technology. Seber's book is 
at a higher mathematical level and covers much of the classical theory 
of least squares.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## regSim -
   x &lt;- regSim(model = "LM3", n = 100)
  
   # LM       
   regFit(Y ~ X1 + X2 + X3, data = x, use = "lm") 
   # RLM      
   regFit(Y ~ X1 + X2 + X3, data = x, use = "rlm") 
   # AM       
   regFit(Y ~ X1 + X2 + X3, data = x, use = "gam")                
   # PPR      
   regFit(Y ~ X1 + X2 + X3, data = x, use = "ppr") 
   # NNET     
   regFit(Y ~ X1 + X2 + X3, data = x, use = "nnet") 
   # POLYMARS
   regFit(Y ~ X1 + X2 + X3, data = x, use = "polymars")
</code></pre>

<hr>
<h2 id='RegressionTestsInterface'>Regression Tests</h2><span id='topic+RegressionTestsInterface'></span><span id='topic+lmTest'></span><span id='topic+bgTest'></span><span id='topic+bpTest'></span><span id='topic+dwTest'></span><span id='topic+gqTest'></span><span id='topic+harvTest'></span><span id='topic+hmcTest'></span><span id='topic+rainTest'></span><span id='topic+resetTest'></span>

<h3>Description</h3>

<p>A collection and description of functions 
to test linear regression  models, including
tests for higher serial correlations, for 
heteroskedasticity, for autocorrelations 
of disturbances, for linearity, and functional 
relations.
<br />
</p>
<p>The methods are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>"bg"</code> </td><td style="text-align: left;"> Breusch--Godfrey test for higher order serial correlation, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"bp"</code> </td><td style="text-align: left;"> Breusch--Pagan test for heteroskedasticity, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"dw"</code> </td><td style="text-align: left;"> Durbin--Watson test for autocorrelation of disturbances, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"gq"</code> </td><td style="text-align: left;"> Goldfeld--Quandt test for heteroskedasticity, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"harv"</code> </td><td style="text-align: left;"> Harvey--Collier test for linearity, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"hmc"</code> </td><td style="text-align: left;"> Harrison--McCabe test for heteroskedasticity, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"rain"</code> </td><td style="text-align: left;"> Rainbow test for linearity, and </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"reset"</code> </td><td style="text-align: left;"> Ramsey's RESET test for functional relation. </td>
</tr>

</table>

<p>There is nothing new, it's just a wrapper to the underlying test
functions from R's contributed package <code>lmtest</code>. The functions
are available as &quot;Builtin&quot; functions. Nevertheless, the user can 
still install and use the original functions from <span class="rlang"><b>R</b></span>'s <code>lmtest</code> 
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmTest(formula, method = c("bg", "bp", "dw", "gq", "harv", "hmc", 
    "rain", "reset"), data = list(), ...)
    
bgTest(formula, order = 1, type = c("Chisq", "F"), data = list())
bpTest(formula, varformula = NULL, studentize = TRUE, data = list())
dwTest(formula, alternative = c("greater", "two.sided", "less"),
    iterations = 15, exact = NULL, tol = 1e-10, data = list())
gqTest(formula, point=0.5, order.by = NULL, data = list())
harvTest(formula, order.by = NULL, data = list())
hmcTest(formula, point = 0.5, order.by = NULL, simulate.p = TRUE, 
    nsim = 1000, plot = FALSE, data = list()) 
rainTest(formula, fraction = 0.5, order.by = NULL, center = NULL, 
    data = list())
resetTest(formula, power = 2:3, type = c("fitted", "regressor", "princomp"), 
    data = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RegressionTestsInterface_+3A_alternative">alternative</code></td>
<td>

<p>[dwTest] - <br />
a character string specifying the alternative hypothesis, either
<code>"greater"</code>, <code>"two.sided"</code>, or <code>"less"</code>.
</p>
</td></tr>
<tr><td><code id="RegressionTestsInterface_+3A_center">center</code></td>
<td>

<p>[rainTest] - <br />
a numeric value. If center is smaller than <code>1</code> it is 
interpreted as percentages of data, i.e. the subset is chosen 
that <code>n*fraction</code> observations are around observation 
number <code>n*center</code>. If <code>center</code> is greater than 
<code>1</code> it is interpreted to be the index of the center of 
the subset. By default center is <code>0.5</code>. If the Mahalanobis 
distance is chosen center is taken to be the mean regressor, 
but can be specified to be a k-dimensional vector if k is the 
number of regressors and should be in the range of the 
respective regressors. 
</p>
</td></tr>
<tr><td><code id="RegressionTestsInterface_+3A_data">data</code></td>
<td>

<p>an optional data frame containing the variables in the model. 
By default the variables are taken from the environment which 
<code>lmTest</code> and the other tests are called from.
</p>
</td></tr>
<tr><td><code id="RegressionTestsInterface_+3A_exact">exact</code></td>
<td>

<p>[dwTest] - <br />
a logical flag. If set to <code>FALSE</code> a normal approximation 
will be used to compute the p value, if <code>TRUE</code> the &quot;pan&quot; 
algorithm is used. The default is to use &quot;pan&quot; if the sample size 
is <code>&lt; 100</code>. 
</p>
</td></tr>
<tr><td><code id="RegressionTestsInterface_+3A_formula">formula</code></td>
<td>

<p>a symbolic description for the linear model to be tested.
</p>
</td></tr>
<tr><td><code id="RegressionTestsInterface_+3A_fraction">fraction</code></td>
<td>

<p>[rainTest] - <br />
a numeric value, by default 0.5. The percentage of observations 
in the subset is determined by <code>fraction*n</code> if <code>n</code> 
is the number of observations in the model. 
</p>
</td></tr>
<tr><td><code id="RegressionTestsInterface_+3A_iterations">iterations</code></td>
<td>

<p>[dwTest] - <br />
an integer specifying the number of iterations when calculating
the p-value with the &quot;pan&quot; algorithm. By default 15.
</p>
</td></tr>
<tr><td><code id="RegressionTestsInterface_+3A_method">method</code></td>
<td>

<p>the test method which should be applied.
</p>
</td></tr>
<tr><td><code id="RegressionTestsInterface_+3A_nsim">nsim</code></td>
<td>

<p>[hmcTest] - <br />
an integer value. Determines how many runs are used to 
simulate the p value, by default 1000.
</p>
</td></tr>
<tr><td><code id="RegressionTestsInterface_+3A_order">order</code></td>
<td>
 
<p>[bgTest] - <br />
an integer. The maximal order of serial correlation to be 
tested. By default 1.
</p>
</td></tr>
<tr><td><code id="RegressionTestsInterface_+3A_order.by">order.by</code></td>
<td>

<p>[gqTest][harvTest] - <br />
a formula. A formula with a single explanatory variable like 
<code>~ x</code>. Then the observations in the model are ordered by 
the size of <code>x</code>. If set to <code>NULL</code>, the default, the 
observations are assumed to be ordered (e.g. a time series). <br />
[rainTest] - <br />
either a formula or a string. A formula with a single explanatory 
variable like <code>~ x</code>. The observations in the model are 
ordered by the size of <code>x</code>. If set to <code>NULL</code>, the default, 
the observations are assumed to be ordered (e.g. a time series). 
If set to <code>"mahalanobis"</code> then the observations are ordered 
by their Mahalanobis distance of the data. 
</p>
</td></tr>       
<tr><td><code id="RegressionTestsInterface_+3A_plot">plot</code></td>
<td>

<p>[hmcTest] - <br />
a logical flag. If <code>TRUE</code> the test statistic for all  
possible breakpoints is plotted, the default is <code>FALSE</code>. 
</p>
</td></tr>   
<tr><td><code id="RegressionTestsInterface_+3A_point">point</code></td>
<td>

<p>[gqTest][hmcTest] - <br />
a numeric value. If point is smaller than <code>1</code> it is 
interpreted as percentages of data, i.e. <code>n*point</code> is 
taken to be the (potential) breakpoint in the variances, if 
<code>n</code> is the number of observations in the model. If 
<code>point</code> is greater than <code>1</code> it is interpreted to 
be the index of the breakpoint. By default <code>0.5</code>.
</p>
</td></tr>
<tr><td><code id="RegressionTestsInterface_+3A_power">power</code></td>
<td>

<p>[resetTest] - <br />
integers, by default <code>2:3</code>. A vector of positive integers 
indicating the powers of the variables that should be included. 
By default it is tested for a quadratic or cubic influence of 
the fitted response. 
</p>
</td></tr>
<tr><td><code id="RegressionTestsInterface_+3A_simulate.p">simulate.p</code></td>
<td>

<p>[hmcTest] - <br />
a logical. If <code>TRUE</code>, the default, a p-value will be 
assessed by simulation, otherwise the p-value is <code>NA</code>. 
</p>
</td></tr>
<tr><td><code id="RegressionTestsInterface_+3A_studentize">studentize</code></td>
<td>

<p>[bpTest] - <br /> 
a logical value. If set to <code>TRUE</code> 
Koenker's studentized version of the test statistic will 
be used. By default set to <code>TRUE</code>.
</p>
</td></tr> 
<tr><td><code id="RegressionTestsInterface_+3A_tol">tol</code></td>
<td>

<p>[dwTest] - <br />
the tolerance value. Eigenvalues computed have to be greater than 
<code>tol=1e-10</code> to be treated as non-zero. 
</p>
</td></tr>
<tr><td><code id="RegressionTestsInterface_+3A_type">type</code></td>
<td>

<p>[bgTest] - <br />
the type of test statistic to be returned. Either <code>"Chisq"</code> 
for the Chi-squared test statistic or <code>"F"</code> for the F test 
statistic. <br />
[resetTest] - <br />
a string indicating whether powers of the <code>"fitted"</code> 
response, the <code>"regressor"</code> variables (factors are left 
out) or the first principal component, <code>"princomp"</code>, of 
the regressor matrix should be included in the extended model. 
</p>
</td></tr>           
<tr><td><code id="RegressionTestsInterface_+3A_varformula">varformula</code></td>
<td>

<p>[bpTest] - <br />
a formula describing only the potential explanatory variables 
for the variance, no dependent variable needed. By default the 
same explanatory variables are taken as in the main regression 
model. 
</p>
</td></tr>   
<tr><td><code id="RegressionTestsInterface_+3A_...">...</code></td>
<td>

<p>[regTest] - <br />
additional arguments passed to the underlying lm test. Some of 
the tests can specify additional optional arguments like for
alternative hypothesis, the type of test statistic to be returned,
or others. All the optional arguments have default settings. 
</p>
</td></tr>   
</table>


<h3>Details</h3>

<p><b>bg &ndash; Breusch Godfrey Test:</b>
<br /><br />  
Under <code class="reqn">H_0</code> the test statistic is asymptotically Chi-squared 
with degrees of freedom as given in <code>parameter</code>.
If <code>type</code> is set to <code>"F"</code> the function returns
the exact F statistic which, under <code class="reqn">H_0</code>, follows an <code class="reqn">F</code>
distribution with degrees of freedom as given in <code>parameter</code>.
The starting values for the lagged residuals in the supplementary
regression are chosen to be 0.<br />
<code>[lmtest:bgtest]</code>
<br />
</p>
<p><b>bp &ndash; Breusch Pagan Test:</b>
<br /><br />
The Breusch&ndash;Pagan test fits a linear regression model to the 
residuals of a linear regression model (by default the same 
explanatory variables are taken as in the main regression
model) and rejects if too much of the variance
is explained by the additional explanatory variables.
Under <code class="reqn">H_0</code> the test statistic of the Breusch-Pagan test 
follows a chi-squared distribution with <code>parameter</code> 
(the number of regressors without the constant in the model) 
degrees of freedom.<br />  
<code>[lmtest:bptest]</code>
<br />
</p>
<p><b>dw &ndash; Durbin Watson Test:</b>
<br /><br />
The Durbin&ndash;Watson test has the null hypothesis that the autocorrelation
of the disturbances is 0; it can be tested against the alternative 
that it is greater than, not equal to, or less than 0 respectively. 
This can be specified by the <code>alternative</code> argument.
The null distribution of the Durbin-Watson test statistic is a linear
combination of chi-squared distributions. The p value is computed using a
Fortran version of the Applied Statistics Algorithm AS 153 by Farebrother
(1980, 1984). This algorithm is called &quot;pan&quot; or &quot;gradsol&quot;. For large sample
sizes the algorithm might fail to compute the p value; in that case a 
warning is printed and an approximate p value will be given; this p 
value is computed using a normal approximation with mean and variance 
of the Durbin-Watson test statistic.<br />
<code>[lmtest:dwtest]</code>
<br />
</p>
<p><b>gq &ndash; Goldfeld Quandt Test:</b>
<br /><br />
The Goldfeld&ndash;Quandt test compares the variances of two submodels
divided by a specified breakpoint and rejects if the variances differ.
Under <code class="reqn">H_0</code> the test statistic of the Goldfeld-Quandt test 
follows an F distribution with the degrees of freedom as given in 
<code>parameter</code>.<br />
<code>[lmtest:gqtest]</code>
<br />
</p>
<p><b>harv - Harvey Collier Test:</b>
<br /><br />
The Harvey-Collier test performs a t-test (with <code>parameter</code> 
degrees of freedom) on the recursive residuals. If the true relationship 
is not linear but convex or concave the mean of the recursive residuals 
should differ from 0 significantly.<br />
<code>[lmtest:harvtest]</code>
<br />
</p>
<p><b>hmc &ndash; Harrison McCabe Test:</b>
<br /><br />  
The Harrison&ndash;McCabe test statistic is the fraction of the residual 
sum of squares that relates to the fraction of the data before the 
breakpoint. Under <code class="reqn">H_0</code> the test statistic should be close to 
the size of this fraction, e.g. in the default case close to 0.5. 
The null hypothesis is reject if the statistic is too small.<br />
<code>[lmtest:hmctest]</code>
<br />
</p>
<p><b>rain &ndash; Rainbow Test:</b>
<br /><br />  
The basic idea of the Rainbow test is that even if the true 
relationship is non-linear, a good linear fit can be achieved 
on a subsample in the &quot;middle&quot; of the data. The null hypothesis 
is rejected whenever the overall fit is significantly inferior 
to the fit of the subsample. The test statistic under <code class="reqn">H_0</code> 
follows an F distribution with <code>parameter</code> degrees of 
freedom.<br />
<code>[lmtest:raintest]</code>
<br />
</p>
<p><b>reset &ndash; Ramsey's RESET Test</b>
<br /><br />  
RESET test is popular means of diagnostic for correctness of 
functional form. The basic assumption is that under the alternative, 
the model can be written by the regression
<code class="reqn"> y = X\beta + Z\gamma + u</code>.
<code>Z</code> is generated by taking powers either of the fitted response, 
the regressor variables or the first principal component of <code>X</code>. 
A standard F-Test is then applied to determine whether these additional 
variables have significant influence. The test statistic under 
<code class="reqn">H_0</code> follows an F distribution with <code>parameter</code> degrees 
of freedom.<br />
<code>[lmtest:reset]</code>
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>

<p>the value of the test statistic.
</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>

<p>the lag order.
</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>

<p>the p-value of the test.
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>a character string indicating what type of test was
performed.
</p>
</td></tr> 
<tr><td><code>data.name</code></td>
<td>

<p>a character string giving the name of the data.
</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>

<p>a character string describing the alternative
hypothesis.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The underlying <code>lmtest</code> package comes wit a lot of helpful
examples. We highly recommend to install the <code>lmtest</code> package
and to study the examples given therein.
</p>


<h3>Author(s)</h3>

<p>Achim Zeileis and Torsten Hothorn for the <code>lmtest</code> package, <br />
Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port.
</p>


<h3>References</h3>

<p>Breusch, T.S. (1979);
<em>Testing for Autocorrelation in Dynamic Linear Models</em>, 
Australian Economic Papers 17, 334&ndash;355.
</p>
<p>Breusch T.S. and Pagan A.R. (1979);
<em>A Simple Test for Heteroscedasticity and Random 
Coefficient Variation</em>,
Econometrica 47, 1287&ndash;1294
</p>
<p>Durbin J. and Watson G.S. (1950);
<em>Testing for Serial Correlation in Least Squares Regression I</em>,
Biometrika 37, 409&ndash;428.
</p>
<p>Durbin J. and Watson G.S. (1951);
<em>Testing for Serial Correlation in Least Squares Regression II</em>,
Biometrika 38, 159&ndash;178.
</p>
<p>Durbin J. and Watson G.S. (1971);
<em>Testing for Serial Correlation in Least Squares Regression III</em>,
Biometrika 58, 1&ndash;19.
</p>
<p>Farebrother R.W. (1980);
<em>Pan's Procedure for the Tail Probabilities of the
Durbin-Watson Statistic</em>,
Applied Statistics 29, 224&ndash;227.
</p>
<p>Farebrother R.W. (1984);
<em>The Distribution of a Linear Combination of
<code class="reqn">\chi^2</code> Random Variables</em>, 
Applied Statistics 33, 366&ndash;369.
</p>
<p>Godfrey, L.G. (1978);
<em>Testing Against General Autoregressive and
Moving Average Error Models when the Regressors Include Lagged
Dependent Variables</em>, 
Econometrica 46, 1293&ndash;1302.
</p>
<p>Goldfeld S.M. and Quandt R.E. (1965);
<em>Some Tests for Homoskedasticity</em>
Journal of the American Statistical Association 60, 539&ndash;547.
</p>
<p>Harrison M.J. and McCabe B.P.M. (1979);
<em>A Test for Heteroscedasticity based on Ordinary Least 
Squares Residuals</em>
Journal of the American Statistical Association 74, 494&ndash;499.
</p>
<p>Harvey A. and Collier P. (1977);
<em>Testing for Functional Misspecification in Regression 
Analysis</em>,
Journal of Econometrics 6, 103&ndash;119.
</p>
<p>Johnston, J. (1984); 
<em>Econometric Methods</em>, 
Third Edition, McGraw Hill Inc.
</p>
<p>Kraemer W. and Sonnberger H. (1986);
<em>The Linear Regression Model under Test</em>, 
Heidelberg: Physica.
</p>
<p>Racine J. and Hyndman R. (2002);
<em>Using R To Teach Econometrics</em>,
Journal of Applied Econometrics 17, 175&ndash;189.
</p>
<p>Ramsey J.B. (1969);
<em>Tests for Specification Error in Classical Linear Least 
Squares Regression Analysis</em>,
Journal of the Royal Statistical Society, Series B 31, 350&ndash;371.
</p>
<p>Utts J.M. (1982);
<em>The Rainbow Test for Lack of Fit in Regression</em>,
Communications in Statistics - Theory and Methods 11, 1801&ndash;1815.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## bg | dw -
   # Generate a Stationary and an AR(1) Series:
   x = rep(c(1, -1), 50)
   y1 = 1 + x + rnorm(100)
   # Perform Breusch-Godfrey Test for 1st order serial correlation:
   lmTest(y1 ~ x, "bg")
   # ... or for fourth order serial correlation:
   lmTest(y1 ~ x, "bg", order = 4)    
   # Compare with Durbin-Watson Test Results:
   lmTest(y1 ~ x, "dw")
   y2 = filter(y1, 0.5, method = "recursive")
   lmTest(y2 ~ x, "bg") 
   
## bp -
   # Generate a Regressor:
   x = rep(c(-1, 1), 50)
   # Generate heteroskedastic and homoskedastic Disturbances
   err1 = rnorm(100, sd = rep(c(1, 2), 50))
   err2 = rnorm(100)
   # Generate a Linear Relationship:
   y1 = 1 + x + err1
   y2 = 1 + x + err2
   # Perform Breusch-Pagan Test
   bp = lmTest(y1 ~ x, "bp")
   bp
   # Calculate Critical Value for 0.05 Level
   qchisq(0.95, bp$parameter)
   lmTest(y2 ~ x, "bp")
   
## dw -
   # Generate two AR(1) Error Terms 
   # with parameter rho = 0 (white noise) 
   # and rho = 0.9 respectively
   err1 = rnorm(100)
   # Generate Regressor and Dependent Variable
   x = rep(c(-1,1), 50)
   y1 = 1 + x + err1
   # Perform Durbin-Watson Test:
   lmTest(y1 ~ x, "dw")
   err2 = filter(err1, 0.9, method = "recursive")
   y2 = 1 + x + err2
   lmTest(y2 ~ x, "dw")
   
## gq -
   # Generate a Regressor:
   x = rep(c(-1, 1), 50)
   # Generate Heteroskedastic and Homoskedastic Disturbances:
   err1 = c(rnorm(50, sd = 1), rnorm(50, sd = 2))
   err2 = rnorm(100)
   # Generate a Linear Relationship:
   y1 = 1 + x + err1
   y2 = 1 + x + err2
   # Perform Goldfeld-Quandt Test:
   lmTest(y1 ~ x, "gq")
   lmTest(y2 ~ x, "gq")
   
## harv -
   # Generate a Regressor and Dependent Variable:
   x = 1:50
   y1 = 1 + x + rnorm(50)
   y2 = y1 + 0.3*x^2
   # Perform Harvey-Collier Test:
   harv = lmTest(y1 ~ x, "harv")
   harv
   # Calculate Critical Value vor 0.05 level:
   qt(0.95, harv$parameter)
   lmTest(y2 ~ x, "harv")
   
## hmc -
   # Generate a Regressor:
   x = rep(c(-1, 1), 50)
   # Generate Heteroskedastic and Homoskedastic Disturbances:
   err1 = c(rnorm(50, sd = 1), rnorm(50, sd = 2))
   err2 = rnorm(100)
   # Generate a Linear Relationship:
   y1 = 1 + x + err1
   y2 = 1 + x + err2
   # Perform Harrison-McCabe Test:
   lmTest(y1 ~ x, "hmc")
   lmTest(y2 ~ x, "hmc")
   
## rain -
   # Generate Series:
   x = c(1:30)
   y = x^2 + rnorm(30, 0, 2)
   # Perform rainbow Test
   rain = lmTest(y ~ x, "rain")
   rain
   # Compute Critical Value:
   qf(0.95, rain$parameter[1], rain$parameter[2]) 
   
## reset -
   # Generate Series:
   x = c(1:30)
   y1 = 1 + x + x^2 + rnorm(30)
   y2 = 1 + x + rnorm(30)
   # Perform RESET Test:
   lmTest(y1 ~ x , "reset", power = 2, type = "regressor")
   lmTest(y2 ~ x , "reset", power = 2, type = "regressor")          
</code></pre>

<hr>
<h2 id='regSim'>Regression Model Simulation</h2><span id='topic+regSim'></span><span id='topic+LM3'></span><span id='topic+LOGIT3'></span><span id='topic+GAM3'></span>

<h3>Description</h3>

<p>Simulates regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regSim(model = "LM3", n = 100, ...)

LM3(n = 100, seed = 4711)
LOGIT3(n = 100, seed = 4711)
GAM3(n = 100, seed = 4711)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regSim_+3A_model">model</code></td>
<td>

<p>a character string defining the function name from which the
regression model will be simulated.
</p>
</td></tr>   
<tr><td><code id="regSim_+3A_n">n</code></td>
<td>

<p>an integer value setting the length, i.e. the number of records
of the output series, an integer value. By default <code>n=100</code>.
</p>
</td></tr>
<tr><td><code id="regSim_+3A_seed">seed</code></td>
<td>

<p>an integer value, the recommended way to specify seeds for 
random number generation.
</p>
</td></tr>
<tr><td><code id="regSim_+3A_...">...</code></td>
<td>

<p>arguments to be passed to the underlying function specified by
the <code>model</code> argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>regSim</code> allows to simulate from various regression
models defined by one of the three example functions <code>LM3</code>,
<code>LOGIT3</code>, <code>GAM3</code> or by a user specified function.
</p>
<p>The examples are defined in the following way:
</p>
<p><code># LM3:</code><br />
<code>&gt; y = 0.75 * x1 + 0.25 * x2 - 0.5 * x3 + 0.1 * eps </code><br />
</p>
<p><code># LOGIT3:</code><br />
<code>&gt; y = 1 / (1 + exp(- 0.75 * x1 + 0.25 * x2 - 0.5 * x3 + eps)) </code><br />
</p>
<p><code># GAM3:</code><br />
<code>&gt; y = scale(scale(sin(2 * pi * x1)) + scale(exp(x2)) + scale(x3)) </code><br />
<code>&gt; y = y + 0.1 * rnorm(n, sd = sd(y))</code><br />
</p>
<p><code>"LM3"</code> models a liner regression model, <code>"LOGIT3"</code> a generalized
linear regression model expressed by a logit model, and <code>"GAM"</code> an
additive model. <code>x1</code>, <code>x2</code>, <code>x3</code>, and <code>eps</code> are random
normal deviates of length <code>n</code>.
</p>
<p>The <code>model</code> function should return an rectangular series defined 
as an object of class <code>data.frame</code>, <code>timeSeries</code> or <code>mts</code>
which can be accepted from the parameter estimation
functions <code>regFit</code> and <code>gregFit</code>.
</p>


<h3>Value</h3>

<p>The function <code>garchSim</code> returns an object of the same class 
as returned by the underlying function <code>match.fun(model)</code>.
These may be objects of class <code>data.frame</code>, <code>timeSeries</code> or
<code>mts</code>.
</p>


<h3>Note</h3>

<p>This function is still under development. For the future we plan, 
that the function <code>regSim</code> will be able to generate general
regression models.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## LM2 -
   # Data for a user defined linear regression model:
   LM2 = function(n){
     x = rnorm(n)
     y = rnorm(n)
     eps = 0.1 * rnorm(n)
     z = 0.5 + 0.75 * x + 0.25 * y + eps
     data.frame(Z = z, X = x, Y = y)
   }
   for (FUN in c("LM2", "LM3")) {
     cat(FUN, ":\n", sep = "")
     print(regSim(model = FUN, n = 10))
   }
</code></pre>

<hr>
<h2 id='residuals-methods'>Extract Regression Model Residuals</h2><span id='topic+residuals-methods'></span><span id='topic+residuals+2CANY-method'></span><span id='topic+residuals+2CfREG-method'></span>

<h3>Description</h3>

<p>Extracts residuals from a fitted regression object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'fREG'
residuals(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals-methods_+3A_object">object</code></td>
<td>

<p>an object of class <code>fREG</code> as returned from the function
<code>regFit()</code> or <code>gregFit()</code>.
</p>
</td></tr>    
</table>


<h3>Methods</h3>


<dl>
<dt>object = &quot;ANY&quot;</dt><dd>
<p>Generic function
</p>
</dd>
<dt>object = &quot;fREG&quot;</dt><dd>
<p>Residuals
</p>
</dd>
</dl>



<h3>Note</h3>

<p><code>residuals</code> is a generic function which extracts residual values 
from objects returned by modeling functions.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## regSim -
   x = regSim(model = "LM3", n = 50)
  
## regFit -
   fit = regFit(Y ~ X1 + X2 + X3, data = x, use = "lm")
   
## residuals - 
   residuals(fit)
</code></pre>

<hr>
<h2 id='show-methods'>Regression Modelling Show Methods</h2><span id='topic+show-methods'></span><span id='topic+show+2CANY-method'></span><span id='topic+show+2CfREG-method'></span>

<h3>Description</h3>

<p>Show methods for regression modelling. 
</p>


<h3>Details</h3>

<p>The show or print method returns the same information for all
supported regression models through the <code>use</code> argument in
the function <code>regFit</code>.
</p>
<p>These are the 'title', the 'formula', the 'family' and 
the 'model parameters'.
</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;ANY&quot;</dt><dd>
<p>Generic function.
</p>
</dd>
<dt>object = &quot;fREG&quot;</dt><dd>
<p>Print method for objects of class 'fREG'.
</p>
</dd> 
</dl>



<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## regSim -
   x &lt;- regSim(model = "LM3", n = 50)
  
## regFit -
   fit &lt;- regFit(Y ~ X1 + X2 + X3, data = x, use = "lm")
   
## print -
   print(fit)
</code></pre>

<hr>
<h2 id='summary-methods'>Regression Summary Methods</h2><span id='topic+summary-methods'></span><span id='topic+summary+2CANY-method'></span><span id='topic+summary+2CfREG-method'></span>

<h3>Description</h3>

<p>Summary methods for regressing modelling. 
</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;ANY&quot;</dt><dd>
<p>Generic function
</p>
</dd>
<dt>object = &quot;fREG&quot;</dt><dd>
<p>Summary method for objects of class 'fREG'.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## regSim -
   x &lt;- regSim(model = "LM3", n = 50)
  
## regFit -
   fit &lt;- regFit(Y ~ X1 + X2 + X3, data = x, use = "lm")
   
## summary
   summary(fit)
</code></pre>

<hr>
<h2 id='termPlot'>Regression Model Plot Methods</h2><span id='topic+termPlot.fREG'></span>

<h3>Description</h3>

<p>Plots results obtained from a fitted regression model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fREG'
termPlot(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="termPlot_+3A_model">model</code></td>
<td>

<p>an object of class 'fREG'.
</p>
</td></tr> 
<tr><td><code id="termPlot_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed to the underlying 
functions.
</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>x = &quot;ANY&quot;</dt><dd>
<p>Generic function.
</p>
</dd>
<dt>x = &quot;fREG&quot;</dt><dd>
<p>Term plot function. 
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## regSim -
   x &lt;- regSim(model = "LM3", n = 50)
  
## regFit -
   fit &lt;- regFit(Y ~ X1 + X2 + X3, data = x, use = "lm")
</code></pre>

<hr>
<h2 id='terms-methods'>Regression Model Plot Methods</h2><span id='topic+terms-methods'></span><span id='topic+terms+2CANY-method'></span><span id='topic+terms+2CfREG-method'></span>

<h3>Description</h3>

<p>Plots results obtained from a fitted regression model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'fREG'
terms(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="terms-methods_+3A_x">x</code></td>
<td>

<p>an object of class 'fREG'.
</p>
</td></tr> 
<tr><td><code id="terms-methods_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed to the underlying 
functions.
</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>x = &quot;ANY&quot;</dt><dd>
<p>Generic function.
</p>
</dd>
<dt>x = &quot;fREG&quot;</dt><dd>
<p>Terms extractor function. 
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## regSim -
   x &lt;- regSim(model = "LM3", n = 50)
  
## regFit -
   fit &lt;- regFit(Y ~ X1 + X2 + X3, data = x, use = "lm")
</code></pre>

<hr>
<h2 id='vcov-methods'>Extract Regression Model vcov</h2><span id='topic+vcov-methods'></span><span id='topic+vcov+2CANY-method'></span><span id='topic+vcov+2CfREG-method'></span>

<h3>Description</h3>

<p>Extracts vcov from a fitted regression model. 
</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;ANY&quot;</dt><dd>
<p>Generic function
</p>
</dd>
<dt>object = &quot;fREG&quot;</dt><dd>
<p>Extractor function for vcov.
</p>
</dd>
</dl>



<h3>Note</h3>

<p><code>vcov</code> is a generic function which extracts fitted values 
from objects returned by modeling functions, here the <code>regFit</code>
and <code>gregFit</code> parameter estimation functions.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## regSim -
   x &lt;- regSim(model = "LM3", n = 50)
  
## regFit -
   fit &lt;- regFit(Y ~ X1 + X2 + X3, data = x, use = "lm")
   
## vcov - 
   vcov(fit)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
