<!DOCTYPE html><html><head><title>Help for package ResistorArray</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ResistorArray}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#array.resistance'><p>Resistance between two arbitrary points on a regular lattice of</p>
unit resistors</a></li>
<li><a href='#circuit'><p>Mensurates a circuit given potentials of some nodes and current</p>
flow into the others</a></li>
<li><a href='#cube'><p>Specimen conductance matrices</p></a></li>
<li><a href='#currents'><p>Calculates currents in an arbitrary resistor array</p></a></li>
<li><a href='#hypercube'><p>Conductance matrix of a Boolean hypercube</p></a></li>
<li><a href='#ladder'><p>Jacob's ladder of resistors</p></a></li>
<li><a href='#makefullmatrix'><p>Conductance matrix for a lattice of unit resistors</p></a></li>
<li><a href='#platonic'><p>Adjacency of platonic solids</p></a></li>
<li><a href='#resistance'><p>Resistance for arbitrarily connected networks of resistors</p></a></li>
<li><a href='#ResistorArray-package'>
<p>Electrical Properties of Resistor Networks</p></a></li>
<li><a href='#series'><p>Conductance matrix for resistors in series</p></a></li>
<li><a href='#SquaredSquare'><p>A Squared square</p></a></li>
<li><a href='#Wu'><p>Wu's resistance matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0-32</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-01-30</td>
</tr>
<tr>
<td>Title:</td>
<td>Electrical Properties of Resistor Networks</td>
</tr>
<tr>
<td>Description:</td>
<td>Electrical properties of resistor networks using matrix methods.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RobinHankin/ResistorArray.git">https://github.com/RobinHankin/ResistorArray.git</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RobinHankin/ResistorArray/issues">https://github.com/RobinHankin/ResistorArray/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-01-29 20:45:58 UTC; rhankin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin K. S. Hankin
    <a href="https://orcid.org/0000-0001-5982-0415"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-01-29 22:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='array.resistance'>Resistance between two arbitrary points on a regular lattice of
unit resistors
</h2><span id='topic+array.resistance'></span>

<h3>Description</h3>

<p>Given two points on a regular lattice of electrical nodes joined by unit
resistors (as created by <code>makefullmatrix()</code>), returns the
resistance between the two points, or (optionally) the potentials of
each lattice point when unit current is fed into the first node, and the
second is earthed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>array.resistance(x.offset, y.offset, rows.of.resistors,
  cols.of.resistors, give.pots = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="array.resistance_+3A_x.offset">x.offset</code></td>
<td>
<p>Earthed node is at <code class="reqn">(0,0)</code>, second node is at
<code>(x.offset, y.offset)</code></p>
</td></tr>
<tr><td><code id="array.resistance_+3A_y.offset">y.offset</code></td>
<td>
<p>Earthed node is at <code class="reqn">(0,0)</code>, second node is at
<code>(x.offset, y.offset)</code></p>
</td></tr>
<tr><td><code id="array.resistance_+3A_rows.of.resistors">rows.of.resistors</code></td>
<td>
<p>Number of rows of resistors in the network
(positive integer)</p>
</td></tr>
<tr><td><code id="array.resistance_+3A_cols.of.resistors">cols.of.resistors</code></td>
<td>
<p>Number of columns of resistors in the network
(positive integer)</p>
</td></tr>
<tr><td><code id="array.resistance_+3A_give.pots">give.pots</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return a matrix
of potentials of the electrical nodes, and <code>FALSE</code> meaning to
return the resistance between the origin and the current input node</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the electrical network is effectively toroidal.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+makefullmatrix">makefullmatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>jj.approximate &lt;-  array.resistance(1,2,15,17,give=FALSE)
jj.exact &lt;- 4/pi-1/2
print(jj.exact - jj.approximate)

persp(array.resistance(4,0,14,16,give=TRUE),theta=50,r=1e9,expand=0.6)
</code></pre>

<hr>
<h2 id='circuit'>Mensurates a circuit given potentials of some nodes and current
flow into the others</h2><span id='topic+circuit'></span>

<h3>Description</h3>

<p>Given a conductance matrix, a vector of potentials at each node, and a
vector of current inputs  at each node (<code>NA</code> being interpreted as
&ldquo;unknown&rdquo;), this function determines the potentials at each
node, and the currents along each edge, of the whole circuit.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circuit(L, v, currents=0, use.inverse=FALSE, give.internal=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circuit_+3A_l">L</code></td>
<td>
<p>Conductance matrix</p>
</td></tr>
<tr><td><code id="circuit_+3A_v">v</code></td>
<td>
<p>Vector of potentials; one element per node.  Elements
with <code>NA</code> are interpreted
as &ldquo;free&rdquo; nodes, that is, nodes that are not kept at a fixed
potential.  The potential of these nodes is well defined by the other
nodes in the problem.  Note that such nodes must have
current inputs (which may be zero) specified by argument
<code>currents</code></p>
</td></tr>
<tr><td><code id="circuit_+3A_currents">currents</code></td>
<td>
<p>Vector of currents fed into each node.  The only
elements of this vector that are used are those that correspond to a
node with free potential (use <code>NA</code> for nodes that are at a
specified potential).  The idea is that each node has
<strong>either</strong> a specified voltage, <strong>or</strong> a specified current
is fed into it; not both, and not neither.
</p>
<p>Observe that feeding zero current into a node at free potential is
perfectly acceptable (and the usual case)</p>
</td></tr>
<tr><td><code id="circuit_+3A_use.inverse">use.inverse</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to use
<code>solve(A,b)</code> and <code>TRUE</code> meaning to use <code>solve(A)</code>, 
thus incurring the penalty of evaluating a matrix inverse, which is
typically to be avoided if possible.
</p>
<p>The default option should be faster most of the time, but YMMV</p>
</td></tr>
<tr><td><code id="circuit_+3A_give.internal">give.internal</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return also
a matrix showing the node-to-node currents, and default <code>FALSE</code>
meaning to omit this</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the value of Boolean argument <code>give.internal</code>,
return a list of either 2 or 4 elements:
</p>
<table>
<tr><td><code>potentials</code></td>
<td>
<p>A vector of potentials.  Note that the potentials of the
nodes whose potential was specified by input argument <code>v</code>
retain their original potentials; symbolically
<code>all(potentials[!is.na(v)] == v[!is.na(v)])</code></p>
</td></tr>
<tr><td><code>currents</code></td>
<td>
<p>Vector of currents required to maintain the system
with the potentials specified by input argument <code>v</code></p>
</td></tr>
<tr><td><code>internal.currents</code></td>
<td>
<p>Matrix showing current flow from node to
node.  Element <code>[i,j]</code> shows current flow from node <code>i</code> to
node <code>j</code>.  This and the next two elements only supplied if
argument <code>give.internal</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code>power</code></td>
<td>
<p>The power dissipated at each edge</p>
</td></tr>
<tr><td><code>total.power</code></td>
<td>
<p>Total power dissipated over the resistor network</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The SI unit of potential is the &ldquo;Volt&rdquo;; the SI unit of current
is the &ldquo;Ampere&rdquo;</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+resistance">resistance</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
#reproduce first example on ?cube:
v &lt;- c(0,rep(NA,5),1,NA)
circuit(cube(),v)
circuit(cube(),v+1000)

#  problem: The nodes  of a skeleton cube are at potentials
#  1,2,3,... volts.  What current is needed to maintain this?  Ans:
circuit(cube(),1:8)


#sanity check: maintain one node at 101 volts:
circuit(cube(),c(rep(NA,7),101))

#now, nodes 1-4 have potential 1,2,3,4 volts.  Nodes 5-8 each have one
#Amp shoved in them.  What is the potential of nodes 5-8, and what
#current is needed to maintain nodes 1-4 at their potential?
# Answer:
v &lt;- c(1:4,rep(NA,4))
currents &lt;- c(rep(NA,4),rep(1,4))
circuit(cube(),v,currents)

# Now back to the resistance of a skeleton cube across its sqrt(3)
# diagonal.  To do this, we hold node 1 at 0 Volts, node 7 at 1 Volt,
# and leave the rest floating (see argument v below); we
# seek the current at nodes 1 and 7
# and insist that the current flux into the other nodes is zero
# (see argument currents below):

circuit(L=cube(),v=c(0,NA,NA,NA,NA,NA,1,NA),currents=c(NA,0,0,0,0,0,NA,0))

# Thus the current is 1.2 ohms and the resistance (from V=IR)
# is just 1/1.2 = 5/6 ohms, as required.

</code></pre>

<hr>
<h2 id='cube'>Specimen conductance matrices</h2><span id='topic+cube'></span><span id='topic+tetrahedron'></span><span id='topic+octahedron'></span><span id='topic+dodecahedron'></span><span id='topic+icosahedron'></span><span id='topic+wheatstone'></span><span id='topic+Wheatstone'></span>

<h3>Description</h3>

<p>Various conductance matrices for simple resistor configurations
including a skeleton cube
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cube(x=1)
octahedron(x=1)
tetrahedron(x=1)
dodecahedron(x=1)
icosahedron(x=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cube_+3A_x">x</code></td>
<td>
<p>Resistance of each edge.  See details section</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>cube()</code> returns an eight-by-eight conductance matrix
for a skeleton cube of 12 resistors.  Each row/column corresponds to
one of the 8 vertices that are the electrical nodes of the compound
resistor.
</p>
<p>In one orientation, node 1 has position 000, node 2 position 001, node 3
position 101, node 4 position 100, node 5 position 010, node 6 position
011, node 7 position 111, and node 8 position 110.
</p>
<p>In <code>cube()</code>, <code>x</code> is a vector of twelve elements (a scalar
argument is interpreted as the resistance of each resistor)
representing the twelve resistances of a skeleton cube.  In the
orientation described below, the elements of <code>x</code> correspond to
<code class="reqn">R_{12}</code>, <code class="reqn">R_{14}</code>, <code class="reqn">R_{15}</code>,
<code class="reqn">R_{23}</code>, <code class="reqn">R_{26}</code>, <code class="reqn">R_{34}</code>,
<code class="reqn">R_{37}</code>, <code class="reqn">R_{48}</code>, <code class="reqn">R_{56}</code>,
<code class="reqn">R_{58}</code>, <code class="reqn">R_{67}</code>, <code class="reqn">R_{78}</code> (here
<code class="reqn">R_{ij}</code> is the resistancd between node <code class="reqn">i</code>  and
<code class="reqn">j</code>).  This series is obtainable by reading the rows given by
<code>platonic("cube")</code>.  The pattern is general: edges are ordered
first by the row number <code class="reqn">i</code>, then column number <code class="reqn">j</code>.
</p>
<p>In <code>octahedron()</code>, <code>x</code> is a vector of twelve elements (again
scalar argument is interpreted as the resistance of each resistor)
representing the twelve resistances of a skeleton octahedron.  If node 1
is &ldquo;top&rdquo; and node 6 is &ldquo;bottom&rdquo;, the elements of <code>x</code>
correspond to
<code class="reqn">R_{12}</code>, <code class="reqn">R_{13}</code>, <code class="reqn">R_{14}</code>,
<code class="reqn">R_{15}</code>, <code class="reqn">R_{23}</code>, <code class="reqn">R_{25}</code>,
<code class="reqn">R_{26}</code>, <code class="reqn">R_{34}</code>, <code class="reqn">R_{36}</code>, 
<code class="reqn">R_{45}</code>, <code class="reqn">R_{46}</code>, <code class="reqn">R_{56}</code>.
This may be read off from the rows of <code>platonic("octahedron")</code>.
</p>
<p>To do a Wheatstone bridge, use <code>tetrahedron()</code> with one of the
resistances <code>Inf</code>.  As a worked example, let us determine the
resistance of a Wheatstone bridge with four resistances one ohm and
one of two ohms; the two-ohm resistor is one of the ones touching the
earthed node.
</p>
<p>To do this, first draw a tetrahedron with four nodes.  Then say we
want the resistance between node 1 and node 3; thus edge 1-3 is the
infinite one.  <code>platonic("tetrahedron")</code> gives us the order of
the edges: 12, 13, 14, 23, 24, 34.  Thus the conductance matrix is
given by <code>jj &lt;- tetrahedron(c(2,Inf,1,1,1,1))</code> and the resistance
is given by <code>resistance(jj,1,3)</code> [compare the analytical answer
of 117/99 ohms].
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>F. J. van Steenwijk &ldquo;Equivalent resistors of polyhedral
resistive structures&rdquo;, American Journal of Physics, 66(1), January
1988.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 resistance(cube(),1,7)  #known to be 5/6 ohm
 resistance(cube(),1,2)  #known to be 7/12 ohm

 resistance(octahedron(),1,6) #known to be 1/2 ohm
 resistance(octahedron(),1,5) #known to be 5/12 ohm

 resistance(dodecahedron(),1,5) 

</code></pre>

<hr>
<h2 id='currents'>Calculates currents in an arbitrary resistor array</h2><span id='topic+currents'></span><span id='topic+currents.matrix'></span>

<h3>Description</h3>

<p>Calculates currents in an arbitrary resistor array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>currents(L, earth.node, input.node)
currents.matrix(L, earth.node, input.node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="currents_+3A_l">L</code></td>
<td>
<p>Lagrangian conductance matrix</p>
</td></tr>
<tr><td><code id="currents_+3A_earth.node">earth.node</code></td>
<td>
<p>Number of node that is earthed (that is, at a
potential of zero)</p>
</td></tr>
<tr><td><code id="currents_+3A_input.node">input.node</code></td>
<td>
<p>Number of node that has current put into it (a
notional one Amp)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The methods used by the two functions are different; see documentation for
<code>resistance()</code> for further details on input args 2 and 3
</p>


<h3>Value</h3>

<p>Function <code>currents()</code> returns a three column matrix, each row of
which corresponds to an edge.  The first two
columns show the node numbers specifying the edge, and the third shows
the current flowing along it.
</p>
<p>Function <code>current.matrix()</code> uses a different method to return a
matrix of the same size as the conductance matrix <code>L</code>.  Each
element of the returned matrix shows the current flowing along the
specified edge.
</p>


<h3>Note</h3>

<p>This function is essentially a simplified version of
<code>circuit()</code>.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>currents(cube(),1,7)
currents.matrix(cube(),1,7)

 #check above solution: print out the currents flowing into each node:
 zapsmall(apply(currents.matrix(cube(),1,7),1,sum))
</code></pre>

<hr>
<h2 id='hypercube'>Conductance matrix of a Boolean hypercube</h2><span id='topic+hypercube'></span>

<h3>Description</h3>

<p>Returns the conductance matrix of an n-dimensional hypercube
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypercube(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hypercube_+3A_n">n</code></td>
<td>
<p>Integer giving the dimension of the hypercube</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The row and columnnames give the coordinates of each node (which are
in binary order)
</p>


<h3>Value</h3>

<p>Returns a conductance matrix
</p>


<h3>Note</h3>

<p>In the case of a 3D cube, the nodes are in a different order from that
returned by <code>cube()</code> (which uses Maple's scheme).
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="http://f2.org/maths/resnet/">http://f2.org/maths/resnet/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cube">cube</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>hypercube(4)

resistance(hypercube(5),1,32)  # cf exact answer of 8/15 
resistance(hypercube(5),1,2)   # cf exact answer of n &lt;- 5; (2^n-1)/(n*2^(n-1))=31/80

</code></pre>

<hr>
<h2 id='ladder'>Jacob's ladder of resistors</h2><span id='topic+ladder'></span>

<h3>Description</h3>

<p>A potentially infinite resistor network.
Consider node 1 to be Earth.  Nodes <code class="reqn">2,\ldots,
  n</code>  are each connected to node 1 by a resistor.  For
<code class="reqn">1&lt;i&lt;n</code>, node <code class="reqn">i</code> is connected to node <code class="reqn">i+1</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ladder(n, x = 1, y = 1, z = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ladder_+3A_n">n</code></td>
<td>
<p>Number of nodes</p>
</td></tr>
<tr><td><code id="ladder_+3A_x">x</code></td>
<td>
<p>Resistance of resistors connected to node 1 (earth). Standard
recycling rules are used</p>
</td></tr>
<tr><td><code id="ladder_+3A_y">y</code></td>
<td>
<p>Resistance of the other  resistors (ie those not connected to
earth).  Standard recycling rules are used</p>
</td></tr>
<tr><td><code id="ladder_+3A_z">z</code></td>
<td>
<p>Resistance of <em>all</em> resistors in the network.  If
non-<code>NULL</code>, <code>x</code> and <code>y</code> are discarded</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a standard conductance matrix
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+cube">cube</a></code>, <code><a href="#topic+series">series</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
#  Resistance of an infinite Jacob's ladder with unit resistors is known
#  to be (sqrt(5)-1)/2:

 phi &lt;- (sqrt(5)-1)/2
 resistance(ladder(20),1,2) - phi
 resistance(ladder(60),1,2) - phi

 Wu(ladder(20))[1,2]-phi


# z is the resistance of all the resistors:

 ladder(n=8,z=1/(1:13))

# See how node 1 is the "earth", with resistors of conductance 1,2,...,7
#  connecting to nodes 2-8.  Then nodes 5 &amp; 6, say, are connected by a
#  resistor of conductance 11.

</code></pre>

<hr>
<h2 id='makefullmatrix'>Conductance matrix for a lattice of unit resistors</h2><span id='topic+makefullmatrix'></span><span id='topic+makefullmatrix_strict'></span>

<h3>Description</h3>

<p>Conductance matrix for a lattice of unit resistors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makefullmatrix(R, C)
makefullmatrix_strict(R, C,toroidal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makefullmatrix_+3A_r">R</code></td>
<td>
<p>Number of rows of nodes</p>
</td></tr>
<tr><td><code id="makefullmatrix_+3A_c">C</code></td>
<td>
<p>Number of columns of nodes</p>
</td></tr>
<tr><td><code id="makefullmatrix_+3A_toroidal">toroidal</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return a
toroidally connected lattice, and <code>FALSE</code> meaning to return a
lattice with edges</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The array produced by <code>makefullmatrix_strict(R,C,TRUE)</code> is
toroidally connected.
</p>
<p>Function <code>makefullmatrix()</code> is not entirely straightforward.  The
array produced is sort of toroidally connected.  I regard this
function as the canonical one because it is more elegant (see example
image).  Consider, for concreteness, the case with four rows and seven
columns of nodes giving 28 nodes altogether.  Number these columnwise
so the top row is 1,5,9,13,17,21,25.  Then number <code class="reqn">n</code> corresponds
to the row <code class="reqn">n</code> and column <code class="reqn">n</code> of the returned matrix.
</p>
<p>Now, &lsquo;interior&rsquo; nodes are as expected: node 6, for example, is
connected to 2,5,10,7.  And the wrapping is as expected in the
horizontal: 1-25, 2-26, 3-27, and 4-28, are all connected.
</p>
<p>However, the vertical wrapping is not as might be expected. One might
expect node 9, say, to be connected to 5,10 13,12; but in fact node 9
is connected to nodes 5,8,10,13.  So there is a Hamiltonian path
comprising entirely of vertical connections (function
<code>makefullmatrix_strict(R,C,TRUE)</code> returns the &ldquo;expected&rdquo;
adjacency graph).
</p>
<p>For the arrays returned by functions documented here, one can
determine pairwise resistances using function
<code>array.resistance()</code>.
</p>


<h3>Value</h3>

<p>Returns matrix of size <code class="reqn">RC\times RC</code>.  Note that this
matrix is singular.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+array.resistance">array.resistance</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>makefullmatrix(3,3)
image(makefullmatrix(4,7))              # A beautiful natural structure
image(makefullmatrix_strict(4,7,TRUE))  # A dog's breakfast
</code></pre>

<hr>
<h2 id='platonic'>Adjacency of platonic solids</h2><span id='topic+platonic'></span>

<h3>Description</h3>

<p>Gives the adjacency indices of the five Platonic solids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>platonic(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="platonic_+3A_a">a</code></td>
<td>
<p>String containing name of one of the five Platonic solids,
viz &ldquo;tetrahedron&rdquo;, &ldquo;cube&rdquo;, &ldquo;octahedron&rdquo;,
&ldquo;dodecahedron&rdquo;, &ldquo;icosahedron&rdquo;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a two column matrix <code>a</code>, the rows of which show the two
vertices of an edge.  Only
edges with <code>a[i,1]&lt;i[i,2]</code> are included.
</p>
<p>For the dodecahedron and icosahedron, the nodes are numbered as per
Maple's scheme.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+cube">cube</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>platonic("octahedron")
</code></pre>

<hr>
<h2 id='resistance'>Resistance for arbitrarily connected networks of resistors</h2><span id='topic+resistance'></span>

<h3>Description</h3>

<p>Given a resistance matrix, return the resistance between two specified nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resistance(A, earth.node, input.node, current.input.vector=NULL, give.pots = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resistance_+3A_a">A</code></td>
<td>
<p>Resistance matrix</p>
</td></tr>
<tr><td><code id="resistance_+3A_earth.node">earth.node</code></td>
<td>
<p>Number of node that is earthed</p>
</td></tr>
<tr><td><code id="resistance_+3A_input.node">input.node</code></td>
<td>
<p>Number of node at which <strong>current</strong> is put in: a
nominal 1 Amp</p>
</td></tr>
<tr><td><code id="resistance_+3A_current.input.vector">current.input.vector</code></td>
<td>
<p>Vector of
currents that are fed into each node.  If supplied, overrides the
value of <code>input.node</code>, and effectively sets <code>give.pots</code>
to <code>TRUE</code> because if various currents are fed into the network
at various points, the concept of &ldquo;resistance&rdquo; becomes
meaningless.
</p>
<p>Setting this argument to <code>c(0,...,0,1,0,..0)</code> (where the
&ldquo;1&rdquo; is element <code>jj</code>) is equivalent to not setting
<code>current.input.vector</code> and setting <code>input.node</code> to
<code>jj</code>. 
</p>
</td></tr>
<tr><td><code id="resistance_+3A_give.pots">give.pots</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return the
potential of each node (<code>out.node</code> being at zero potential);
and default <code>FALSE</code> meaning to return just the resistance between
<code>in.node</code> and <code>out.node</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function's connection to resistor physics is quite opaque.
It is effectively a matrix version of Kirchoff's law, that the
(algebraic) sum of currents into a node is zero.  
</p>


<h3>Note</h3>

<p>This function is essentially a newbie wrapper for <code>circuit()</code>,
which solves a much more general problem.  The function documented
here, however, is clearer and (possibly) faster; it also gives an
explicit resistance if <code>give.pots</code> is not set.
</p>
<p>Use function <code>currents()</code> (or <code>currents.matrix()</code>) to
calculate the currents flowing in the resistor array.  
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>


<ul>
<li><p> B. Bollob\'as, 1998.  <em>Modern Graph Theory</em>.  Springer.
</p>
</li>
<li><p> F. Y. Wu, 2004.  &ldquo;Theory of resistor networks: the two
point resistance&rdquo;, <em>Journal of Physics A</em>, volume 37, pp6653-6673
</p>
</li>
<li><p> G. Venezian 1994. &ldquo;On the resistance between two points
on a grid&rdquo;, <em>American Journal of Physics</em>, volume 62, number 11,
pp1000-1004.
</p>
</li>
<li><p> J. Cserti 2000.  &ldquo;Application of the lattice Green's
function for calculating the resistance of an infinte network of
resistors&rdquo;, <em>American Journal of Physics</em>, volume 68, number 10,
p896-906
</p>
</li>
<li><p> D. Atkinson and F. J. van Steenwijk 1999.  &ldquo;Infinite
resistive lattices&rdquo;, <em>American Journal of Physics</em>, volume 67,
number 6, pp486-492
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+array.resistance">array.resistance</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  resistance(cube(),earth.node=1, input.node=7) #known to be 5/6 ohm
  resistance(cube(),1,7, give=TRUE)
</code></pre>

<hr>
<h2 id='ResistorArray-package'>
Electrical Properties of Resistor Networks
</h2><span id='topic+ResistorArray-package'></span><span id='topic+ResistorArray'></span>

<h3>Description</h3>

<p>Electrical properties of resistor networks using matrix methods.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> ResistorArray</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0-32</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2019-01-30</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Electrical Properties of Resistor Networks</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Electrical properties of resistor networks using matrix methods.</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> person(given=c("Robin", "K. S."), family="Hankin", role = c("aut","cre"), email="hankin.robin@gmail.com", comment = c(ORCID = "0000-0001-5982-0415"))</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/RobinHankin/ResistorArray.git</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/RobinHankin/ResistorArray/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Index of help topics:
</p>
<pre>
ResistorArray-package   Electrical Properties of Resistor Networks
SquaredSquare           A Squared square
Wu                      Wu's resistance matrix
array.resistance        Resistance between two arbitrary points on a
                        regular lattice of unit resistors
circuit                 Mensurates a circuit given potentials of some
                        nodes and current flow into the others
cube                    Specimen conductance matrices
currents                Calculates currents in an arbitrary resistor
                        array
hypercube               Conductance matrix of a Boolean hypercube
ladder                  Jacob's ladder of resistors
makefullmatrix          Conductance matrix for a lattice of unit
                        resistors
platonic                Adjacency of platonic solids
resistance              Resistance for arbitrarily connected networks
                        of resistors
series                  Conductance matrix for resistors in series
</pre>


<h3>Author(s)</h3>

<p>NA
</p>


<h3>References</h3>

<p>R.K.S. Hankin 2006. &quot;Resistor networks in R: introducing the 'ResistorArray' package&quot;.
R News, volume 6, number 2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># resistance between opposite corners of a skeleton cube:
resistance(cube(),1,7)   # known to be 5/6 Ohm

# resistance of a Jacob's ladder:
 resistance(ladder(60),1,2)  # should be about (sqrt(5)-1)/2

# Google aptitude test:
 array.resistance(1,2,15,17)  # analytical answer 4/pi-1/2
</code></pre>

<hr>
<h2 id='series'>Conductance matrix for resistors in series</h2><span id='topic+series'></span>

<h3>Description</h3>

<p>Conductance matrix for resistors of arbitrary resistance in series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>series(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="series_+3A_x">x</code></td>
<td>
<p>The resistances of the resistors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Note:</strong> if <code>length(x)=n</code>, the function returns a
conductance matrix of size <code>n+1</code> by <code>n+1</code>, because <code>n</code>
resistors in series have <code>n+1</code> nodes to consider.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+cube">cube</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Resistance of four resistors in series:

resistance(series(rep(1,5)),1,5) ##sic!  FOUR resistors have FIVE nodes

## What current do we need to push into a circuit of five equal
## resistors in order to maintain the potentials at 1v, 2v, ..., 6v?

circuit(series(rep(1,5)),v=1:6)  #(obvious, isn't it?)


## Now, what is the resistance matrix of four nodes connected in series
## with resistances 1,2,3 ohms?

Wu(series(1:3))  #Yup, obvious again.

</code></pre>

<hr>
<h2 id='SquaredSquare'>A Squared square</h2><span id='topic+SquaredSquare'></span><span id='topic+squaredsquare'></span><span id='topic+Squaredsquare'></span>

<h3>Description</h3>

<p>A resistor network corresponding to a squared square
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SquaredSquare)
</code></pre>


<h3>Format</h3>

<p>Returns a conductance matrix
</p>


<h3>Details</h3>

<p>The nodes are ordered so that the potentials are in increasing order.
</p>


<h3>Source</h3>

<p>Bollobas 1998
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SquaredSquare)
resistance(SquaredSquare,1,13) # should be 1

circuit(L=SquaredSquare,currents=c(NA,rep(0,11),1),v=c(0,rep(NA,12)))$potentials
# should be in increasing order

</code></pre>

<hr>
<h2 id='Wu'>Wu's resistance matrix</h2><span id='topic+Wu'></span>

<h3>Description</h3>

<p>Returns a matrix <code>M</code> with <code>M[i,j]</code> is the resistance between
nodes <code>i</code> and <code>j</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Wu(L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Wu_+3A_l">L</code></td>
<td>
<p>Laplacian conductance matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Evaluates Wu's resistance matrix, as per his theorem on page 6656.
</p>


<h3>Value</h3>

<p>Returns a matrix of the same size as <code>L</code>, but whose elements are
the effective resistance between the nodes.
</p>


<h3>Note</h3>

<p>In the function, the sum is not from 2 to <code>n</code> as in Wu, but
from 1 to <code class="reqn">n-1</code>, because <code>eigen()</code>  orders the
eigenvalues from largest to smallest, not smallest to largest.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>F. Y. Wu, 2004. &ldquo;Theory of resistor networks: the two point resistance&rdquo;,
Journal of Physics A, volume 37, pp6653-6673
</p>


<h3>See Also</h3>

<p><code><a href="#topic+resistance">resistance</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
Wu(cube())

Wu(cube())[1,2] - resistance(cube(),1,2)

Wu(series(1:7))  # observe how resistance between, say, nodes 2
                 # and 5 is 9 (=2+3+4)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
