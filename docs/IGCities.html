<!DOCTYPE html><html><head><title>Help for package IGCities</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {IGCities}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#array_operator'><p>Array operator to mimic different-dimension-array element-wise operations in</p>
MATLAB. It receives as input two arrays of potentially different dimensions,
it resizes them to have same dimensions and finally performs the element-wise
operation.</a></li>
<li><a href='#av_income_simple'><p>Computes average income in each location, which is the weighted average of</p>
the income of the people living in the location.</a></li>
<li><a href='#commuting_matrix'><p>Function to transform travel times into iceberg commuting costs</p></a></li>
<li><a href='#density_development'><p>Computes residential and commercial floorspace supply and equilibrium prices.</p></a></li>
<li><a href='#inversionModel'><p>Function to invert model, so amenities, wages, productivities, and development density</p>
are chosen to match model to data.</a></li>
<li><a href='#living_amenities_simple'><p>Function to estimate amenity parameters of locations where users live.</p></a></li>
<li><a href='#productivity'><p>Computes productivity levels in each location</p></a></li>
<li><a href='#solveModel'><p>Function to solve counterfactuals.</p></a></li>
<li><a href='#sumDims'><p>Collapse array along one of the dimensions by adding the elements along that</p>
dimension.</a></li>
<li><a href='#sumDims2'><p>Collapse array 2 along one of the dimensions by adding the elements along that</p>
dimension.</a></li>
<li><a href='#wages_inversion'><p>Function to compute equilibrium wages that make the model labor in every</p>
location in equal to the observed data. It finds the w's
such that equation (3.2) holds.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Simulate Impact of Different Urban Policies Through a General
Equilibrium Model</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Develops a General Equilibrium (GE) Model, which estimates key variables such as wages, the number of residents and workers, the prices of the floor space, and its distribution between commercial and residential use, as in Ahlfeldt et al., (2015) <a href="https://onlinelibrary.wiley.com/doi/abs/10.3982/ECTA10876">https://onlinelibrary.wiley.com/doi/abs/10.3982/ECTA10876</a>. By doing so, the model allows understanding the economic influence of different urban policies.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-23 15:44:21 UTC; zarruk</td>
</tr>
<tr>
<td>Author:</td>
<td>David Zarruk [aut, cre],
  Roman Zarate [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Zarruk &lt;davidzarruk@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-25 18:47:51 UTC</td>
</tr>
</table>
<hr>
<h2 id='array_operator'>Array operator to mimic different-dimension-array element-wise operations in
MATLAB. It receives as input two arrays of potentially different dimensions,
it resizes them to have same dimensions and finally performs the element-wise
operation.</h2><span id='topic+array_operator'></span>

<h3>Description</h3>

<p>Array operator to mimic different-dimension-array element-wise operations in
MATLAB. It receives as input two arrays of potentially different dimensions,
it resizes them to have same dimensions and finally performs the element-wise
operation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>array_operator(array1, array2, operation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="array_operator_+3A_array1">array1</code></td>
<td>
<p>The first array</p>
</td></tr>
<tr><td><code id="array_operator_+3A_array2">array2</code></td>
<td>
<p>The second array</p>
</td></tr>
<tr><td><code id="array_operator_+3A_operation">operation</code></td>
<td>
<p>The operation. It can take values: '+', '-', '*',
'/' and '^'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array with dimensions equal to the &quot;largest&quot; input array. It is
the result of applying the operator element-wise to both input arrays.
</p>

<hr>
<h2 id='av_income_simple'>Computes average income in each location, which is the weighted average of
the income of the people living in the location.</h2><span id='topic+av_income_simple'></span>

<h3>Description</h3>

<p>Computes average income in each location, which is the weighted average of
the income of the people living in the location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>av_income_simple(lambda_ij_i, w_tr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="av_income_simple_+3A_lambda_ij_i">lambda_ij_i</code></td>
<td>
<p>NxN matrix - Probability of individuals in each
location of working in each location.</p>
</td></tr>
<tr><td><code id="av_income_simple_+3A_w_tr">w_tr</code></td>
<td>
<p>NxS - Wages in each location in each sector.</p>
</td></tr>
</table>

<hr>
<h2 id='commuting_matrix'>Function to transform travel times into iceberg commuting costs</h2><span id='topic+commuting_matrix'></span>

<h3>Description</h3>

<p>Function to transform travel times into iceberg commuting costs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>commuting_matrix(t_ij, epsilon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="commuting_matrix_+3A_t_ij">t_ij</code></td>
<td>
<p>NxN matrix - Travel time matrix across locations</p>
</td></tr>
<tr><td><code id="commuting_matrix_+3A_epsilon">epsilon</code></td>
<td>
<p>Float - Parameter that transforms travel times to commuting costs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A NxN matrix of commuting costs
</p>

<hr>
<h2 id='density_development'>Computes residential and commercial floorspace supply and equilibrium prices.</h2><span id='topic+density_development'></span>

<h3>Description</h3>

<p>Computes residential and commercial floorspace supply and equilibrium prices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>density_development(Q, K, w, L_j, y_bar, L_i, beta, alpha, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density_development_+3A_q">Q</code></td>
<td>
<p>Nx1 array - Floorspaces prices.</p>
</td></tr>
<tr><td><code id="density_development_+3A_k">K</code></td>
<td>
<p>Nx1 array - Land supply.</p>
</td></tr>
<tr><td><code id="density_development_+3A_w">w</code></td>
<td>
<p>NxS - Wages in each location in each sector.</p>
</td></tr>
<tr><td><code id="density_development_+3A_l_j">L_j</code></td>
<td>
<p>Nx1 matrix - Number of workers in each location.</p>
</td></tr>
<tr><td><code id="density_development_+3A_y_bar">y_bar</code></td>
<td>

<ul>
<li><p> Average income in each location.
</p>
</li></ul>
</td></tr>
<tr><td><code id="density_development_+3A_l_i">L_i</code></td>
<td>
<p>Nx1 matrix - Number of residents in each location.</p>
</td></tr>
<tr><td><code id="density_development_+3A_beta">beta</code></td>
<td>
<p>Float - Cobb-Douglas parameter output elasticity wrt labor.</p>
</td></tr>
<tr><td><code id="density_development_+3A_alpha">alpha</code></td>
<td>
<p>Float - Utility parameter that determines preferences for
consumption.</p>
</td></tr>
<tr><td><code id="density_development_+3A_mu">mu</code></td>
<td>
<p>Float - Floorspace prod function: output elast wrt capita, 1-mu wrt land.</p>
</td></tr>
</table>

<hr>
<h2 id='inversionModel'>Function to invert model, so amenities, wages, productivities, and development density
are chosen to match model to data.</h2><span id='topic+inversionModel'></span>

<h3>Description</h3>

<p>Function to invert model, so amenities, wages, productivities, and development density
are chosen to match model to data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inversionModel(
  N,
  L_i,
  L_j,
  Q,
  K,
  t_ij,
  alpha = 0.7,
  beta = 0.7,
  theta = 7,
  delta = 0.3585,
  rho = 0.9094,
  lambda = 0.01,
  epsilon = 0.01,
  mu = 0.3,
  eta = 0.1548,
  nu_init = 0.005,
  tol = 10^-10,
  maxiter = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inversionModel_+3A_n">N</code></td>
<td>
<p>Integer - Number of locations.</p>
</td></tr>
<tr><td><code id="inversionModel_+3A_l_i">L_i</code></td>
<td>
<p>Nx1 matrix - Number of residents in each location.</p>
</td></tr>
<tr><td><code id="inversionModel_+3A_l_j">L_j</code></td>
<td>
<p>Nx1 matrix - Number of workers in each location.</p>
</td></tr>
<tr><td><code id="inversionModel_+3A_q">Q</code></td>
<td>
<p>Nx1 matrix - Floorspace prices</p>
</td></tr>
<tr><td><code id="inversionModel_+3A_k">K</code></td>
<td>
<p>Nx1 matrix - Land area</p>
</td></tr>
<tr><td><code id="inversionModel_+3A_t_ij">t_ij</code></td>
<td>
<p>NxN matrix - Travel times across all possible locations.</p>
</td></tr>
<tr><td><code id="inversionModel_+3A_alpha">alpha</code></td>
<td>
<p>Float - Utility parameter that determines preferences for
consumption.</p>
</td></tr>
<tr><td><code id="inversionModel_+3A_beta">beta</code></td>
<td>
<p>Float - Output elasticity wrt labor</p>
</td></tr>
<tr><td><code id="inversionModel_+3A_theta">theta</code></td>
<td>
<p>Float - Commuting elasticity and migration elasticity.</p>
</td></tr>
<tr><td><code id="inversionModel_+3A_delta">delta</code></td>
<td>
<p>Float - Decay parameter agglomeration</p>
</td></tr>
<tr><td><code id="inversionModel_+3A_rho">rho</code></td>
<td>
<p>Float - Decay parameter congestion</p>
</td></tr>
<tr><td><code id="inversionModel_+3A_lambda">lambda</code></td>
<td>
<p>Float - Agglomeration force</p>
</td></tr>
<tr><td><code id="inversionModel_+3A_epsilon">epsilon</code></td>
<td>
<p>Float - Parameter that transforms travel times to commuting costs</p>
</td></tr>
<tr><td><code id="inversionModel_+3A_mu">mu</code></td>
<td>
<p>Float - Floorspace prod function: output elast wrt capital, 1-mu wrt land.</p>
</td></tr>
<tr><td><code id="inversionModel_+3A_eta">eta</code></td>
<td>
<p>Float - Congestion force</p>
</td></tr>
<tr><td><code id="inversionModel_+3A_nu_init">nu_init</code></td>
<td>
<p>Float - Convergence parameter to update wages.
Default nu=0.01.</p>
</td></tr>
<tr><td><code id="inversionModel_+3A_tol">tol</code></td>
<td>
<p>Int - tolerance factor</p>
</td></tr>
<tr><td><code id="inversionModel_+3A_maxiter">maxiter</code></td>
<td>
<p>Integer - Maximum number of iterations for convergence.
Default maxiter=1000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Equilibrium values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N=5
L_i = c(63, 261, 213, 182, 113)
L_j = c(86, 278, 189, 180, 99)
Q = c(2123, 1576, 1371, 1931, 1637)
K = c(0.44, 1.45, 1.15, 0.87, 0.58)
t_ij = rbind(c(0.0, 6.6, 5.5, 5.6, 6.4),
             c(6.7, 0.0, 3.9, 4.6, 4.4),
             c(5.5, 3.9, 0.0, 2.8, 3.0),
             c(5.6, 4.6, 2.8, 0.0, 2.7),
             c(6.4, 4.4, 3.0, 2.7, 0.0))

inversionModel(N=N,
               L_i=L_i,
               L_j=L_j,
               Q=Q,
               K=K,
               t_ij=t_ij)
               
</code></pre>

<hr>
<h2 id='living_amenities_simple'>Function to estimate amenity parameters of locations where users live.</h2><span id='topic+living_amenities_simple'></span>

<h3>Description</h3>

<p>Function to estimate amenity parameters of locations where users live.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>living_amenities_simple(theta, N, L_i, W_i, Q, K, alpha, t_ij, rho, eta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="living_amenities_simple_+3A_theta">theta</code></td>
<td>
<p>Float - Parameter that governs the reallocation of workers across
locations in the city. This parameter measures how sensible are migration
flows within the city to changes in real income.</p>
</td></tr>
<tr><td><code id="living_amenities_simple_+3A_n">N</code></td>
<td>
<p>Integer - Number of locations.</p>
</td></tr>
<tr><td><code id="living_amenities_simple_+3A_l_i">L_i</code></td>
<td>
<p>Nx1 matrix - Total residents.</p>
</td></tr>
<tr><td><code id="living_amenities_simple_+3A_w_i">W_i</code></td>
<td>
<p>Nx1 matrix - Market access measure in each location.</p>
</td></tr>
<tr><td><code id="living_amenities_simple_+3A_q">Q</code></td>
<td>
<p>Nx1 matrix - Floor space prices.</p>
</td></tr>
<tr><td><code id="living_amenities_simple_+3A_k">K</code></td>
<td>
<p>Nx1 matrix - Land area</p>
</td></tr>
<tr><td><code id="living_amenities_simple_+3A_alpha">alpha</code></td>
<td>
<p>Float - Para</p>
</td></tr>
<tr><td><code id="living_amenities_simple_+3A_t_ij">t_ij</code></td>
<td>
<p>NxN matrix - Travel times across locations.</p>
</td></tr>
<tr><td><code id="living_amenities_simple_+3A_rho">rho</code></td>
<td>
<p>Float - decay parameter for amenities.</p>
</td></tr>
<tr><td><code id="living_amenities_simple_+3A_eta">eta</code></td>
<td>
<p>Float - congestion force</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with the amenity distribution of living in each location.
</p>

<hr>
<h2 id='productivity'>Computes productivity levels in each location</h2><span id='topic+productivity'></span>

<h3>Description</h3>

<p>Computes productivity levels in each location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>productivity(N, Q, w, L_j, K, t_ij, delta, lambda, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="productivity_+3A_n">N</code></td>
<td>
<p>Float - Number of locations.</p>
</td></tr>
<tr><td><code id="productivity_+3A_q">Q</code></td>
<td>
<p>Nx1 matrix - Floorspace prices in each location.</p>
</td></tr>
<tr><td><code id="productivity_+3A_w">w</code></td>
<td>
<p>Nx1 matrix - wages in each location.</p>
</td></tr>
<tr><td><code id="productivity_+3A_l_j">L_j</code></td>
<td>
<p>Nx1 matrix - Employment in each location.</p>
</td></tr>
<tr><td><code id="productivity_+3A_k">K</code></td>
<td>
<p>Nx1 matrix - Land in each location.</p>
</td></tr>
<tr><td><code id="productivity_+3A_t_ij">t_ij</code></td>
<td>
<p>NxN matrix - Travel times matrix.</p>
</td></tr>
<tr><td><code id="productivity_+3A_delta">delta</code></td>
<td>
<p>Float - decay parameter agglomeration.</p>
</td></tr>
<tr><td><code id="productivity_+3A_lambda">lambda</code></td>
<td>
<p>Float - agglomeration force.</p>
</td></tr>
<tr><td><code id="productivity_+3A_beta">beta</code></td>
<td>
<p>Float - Output elasticity wrt labor</p>
</td></tr>
</table>

<hr>
<h2 id='solveModel'>Function to solve counterfactuals.</h2><span id='topic+solveModel'></span>

<h3>Description</h3>

<p>Function to solve counterfactuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solveModel(
  N,
  L_i,
  L_j,
  K,
  t_ij,
  a,
  b,
  varphi,
  w_eq,
  u_eq,
  Q_eq,
  ttheta_eq,
  alpha = 0.7,
  beta = 0.7,
  theta = 7,
  mu = 0.3,
  delta = 0.3585,
  lambda = 0.01,
  rho = 0.9094,
  eta = 0.1548,
  epsilon = 0.01,
  zeta = 0.95,
  tol = 10^-10,
  maxiter = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solveModel_+3A_n">N</code></td>
<td>
<p>Integer - Number of locations.</p>
</td></tr>
<tr><td><code id="solveModel_+3A_l_i">L_i</code></td>
<td>
<p>Nx1 array - Number of residents in each location</p>
</td></tr>
<tr><td><code id="solveModel_+3A_l_j">L_j</code></td>
<td>
<p>Nx1 array - Number of workers in each location</p>
</td></tr>
<tr><td><code id="solveModel_+3A_k">K</code></td>
<td>
<p>Nx1 array - Land supply</p>
</td></tr>
<tr><td><code id="solveModel_+3A_t_ij">t_ij</code></td>
<td>
<p>NxN matrix - Travel times across locations</p>
</td></tr>
<tr><td><code id="solveModel_+3A_a">a</code></td>
<td>
<p>Nx1 array - Total Factor Productivity in each location</p>
</td></tr>
<tr><td><code id="solveModel_+3A_b">b</code></td>
<td>
<p>Nx1 array - Vector of amenities in each location</p>
</td></tr>
<tr><td><code id="solveModel_+3A_varphi">varphi</code></td>
<td>
<p>Nx1 array - Density of development</p>
</td></tr>
<tr><td><code id="solveModel_+3A_w_eq">w_eq</code></td>
<td>
<p>Nx1 array - Initial vector of wages</p>
</td></tr>
<tr><td><code id="solveModel_+3A_u_eq">u_eq</code></td>
<td>
<p>Nx1 array - Initial vector of welfare</p>
</td></tr>
<tr><td><code id="solveModel_+3A_q_eq">Q_eq</code></td>
<td>
<p>Nx1 array - Initial price for floorspace</p>
</td></tr>
<tr><td><code id="solveModel_+3A_ttheta_eq">ttheta_eq</code></td>
<td>
<p>Nx1 array - Share of floorspace used commercially</p>
</td></tr>
<tr><td><code id="solveModel_+3A_alpha">alpha</code></td>
<td>
<p>Float - Exp. share in consumption, 1-alpha exp. share in housing</p>
</td></tr>
<tr><td><code id="solveModel_+3A_beta">beta</code></td>
<td>
<p>Float - Output elasticity with respect to labor</p>
</td></tr>
<tr><td><code id="solveModel_+3A_theta">theta</code></td>
<td>
<p>Float - Commuting and migration elasticity.</p>
</td></tr>
<tr><td><code id="solveModel_+3A_mu">mu</code></td>
<td>
<p>Float - Floorspace prod function: output elasticity wrt capital</p>
</td></tr>
<tr><td><code id="solveModel_+3A_delta">delta</code></td>
<td>
<p>Float - Decay parameter agglomeration force</p>
</td></tr>
<tr><td><code id="solveModel_+3A_lambda">lambda</code></td>
<td>
<p>Float - agglomeration externality</p>
</td></tr>
<tr><td><code id="solveModel_+3A_rho">rho</code></td>
<td>
<p>Float - decay parameter for amenities</p>
</td></tr>
<tr><td><code id="solveModel_+3A_eta">eta</code></td>
<td>
<p>Float - amenity externality</p>
</td></tr>
<tr><td><code id="solveModel_+3A_epsilon">epsilon</code></td>
<td>
<p>Float - Parameter that transforms travel times to commuting costs</p>
</td></tr>
<tr><td><code id="solveModel_+3A_zeta">zeta</code></td>
<td>
<p>Float - convergence parameter</p>
</td></tr>
<tr><td><code id="solveModel_+3A_tol">tol</code></td>
<td>
<p>Int - tolerance factor</p>
</td></tr>
<tr><td><code id="solveModel_+3A_maxiter">maxiter</code></td>
<td>
<p>Integer - Maximum number of iterations for convergence.
Default maxiter=1000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Counterfactual values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N=5
L_i = c(63, 261, 213, 182, 113)
L_j = c(86, 278, 189, 180, 99)
Q = c(2123, 1576, 1371, 1931, 1637)
K = c(0.44, 1.45, 1.15, 0.87, 0.58)
t_ij = rbind(c(0.0, 6.6, 5.5, 5.6, 6.4),
             c(6.7, 0.0, 3.9, 4.6, 4.4),
             c(5.5, 3.9, 0.0, 2.8, 3.0),
             c(5.6, 4.6, 2.8, 0.0, 2.7),
             c(6.4, 4.4, 3.0, 2.7, 0.0))

a = c(1.7, 1.7, 1.6, 1.8, 1.6)
b = c(2.2, 2.5, 2.4, 2.6, 2.3)
varphi = c(95, 219, 215, 167, 148)
w_eq = c(0.9, 1.0, 1.0, 1.0, 0.9)
u_eq = c(1.0, 1.3, 1.2, 1.2, 1.1)
Q_eq = c(1.2, 0.9, 0.8, 1.1, 0.9)
ttheta_eq = c(0.5, 0.4, 0.4, 0.4, 0.4)
solveModel(N=N,
           L_i=L_i,
           L_j=L_j,
           K=K,
           t_ij=t_ij,
           a=a,
           b=b,
           varphi=varphi,
           w_eq=w_eq,
           u_eq=u_eq,
           Q_eq=Q_eq,
           ttheta_eq=ttheta_eq)
           
</code></pre>

<hr>
<h2 id='sumDims'>Collapse array along one of the dimensions by adding the elements along that
dimension.</h2><span id='topic+sumDims'></span>

<h3>Description</h3>

<p>Collapse array along one of the dimensions by adding the elements along that
dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumDims(array, dimension)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumDims_+3A_array">array</code></td>
<td>
<p>Array to collapse along one dimension.</p>
</td></tr>
<tr><td><code id="sumDims_+3A_dimension">dimension</code></td>
<td>
<p>Dimension to collapse the array.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array that has been collapsed along the given dimension.
</p>

<hr>
<h2 id='sumDims2'>Collapse array 2 along one of the dimensions by adding the elements along that
dimension.</h2><span id='topic+sumDims2'></span>

<h3>Description</h3>

<p>Collapse array 2 along one of the dimensions by adding the elements along that
dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumDims2(array, dimension)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumDims2_+3A_array">array</code></td>
<td>
<p>Array to collapse along one dimension.</p>
</td></tr>
<tr><td><code id="sumDims2_+3A_dimension">dimension</code></td>
<td>
<p>Dimension to collapse the array.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array that has been collapsed along the given dimension.
</p>

<hr>
<h2 id='wages_inversion'>Function to compute equilibrium wages that make the model labor in every
location in equal to the observed data. It finds the w's
such that equation (3.2) holds.</h2><span id='topic+wages_inversion'></span>

<h3>Description</h3>

<p>Function to compute equilibrium wages that make the model labor in every
location in equal to the observed data. It finds the w's
such that equation (3.2) holds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wages_inversion(
  N,
  w_init,
  theta,
  tau,
  L_i,
  L_j,
  nu_init = 0.05,
  tol = 10^-10,
  maxiter = 10000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wages_inversion_+3A_n">N</code></td>
<td>
<p>Integer - Number of locations.</p>
</td></tr>
<tr><td><code id="wages_inversion_+3A_w_init">w_init</code></td>
<td>
<p>Initial vector of wages.</p>
</td></tr>
<tr><td><code id="wages_inversion_+3A_theta">theta</code></td>
<td>
<p>Float - Commuting elasticity.</p>
</td></tr>
<tr><td><code id="wages_inversion_+3A_tau">tau</code></td>
<td>
<p>NxN matrix - Commuting cost matrix across all locations.</p>
</td></tr>
<tr><td><code id="wages_inversion_+3A_l_i">L_i</code></td>
<td>
<p>Nx1 matrix - Number of residents in each location.</p>
</td></tr>
<tr><td><code id="wages_inversion_+3A_l_j">L_j</code></td>
<td>
<p>Nx1 matrix - Number of workers in each location.</p>
</td></tr>
<tr><td><code id="wages_inversion_+3A_nu_init">nu_init</code></td>
<td>
<p>Float - Convergence parameter to update wages.
Default nu=0.01.</p>
</td></tr>
<tr><td><code id="wages_inversion_+3A_tol">tol</code></td>
<td>
<p>Float - Maximum tolerable error for estimating total labor.
Default tol=10^-10.</p>
</td></tr>
<tr><td><code id="wages_inversion_+3A_maxiter">maxiter</code></td>
<td>
<p>Integer - Maximum number of iterations for convergence.
Default maxiter=10000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with equilibrium wages and probability of workers in each
location working in every other location.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
