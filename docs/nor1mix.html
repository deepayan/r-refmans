<!DOCTYPE html><html><head><title>Help for package nor1mix</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nor1mix}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nor1mix-package'><p>Normal aka Gaussian 1-d Mixture Models</p></a></li>
<li><a href='#clus2norMix'><p>Transform Clustering / Grouping to Normal Mixture</p></a></li>
<li><a href='#dnorMix'><p>Normal Mixture Density</p></a></li>
<li><a href='#llnorMix'><p>Likelihood, Parametrization and EM-Steps For 1D Normal Mixtures</p></a></li>
<li><a href='#MarronWand'><p>Marron-Wand Densities as 'norMix' Objects</p></a></li>
<li><a href='#norMix'><p>Mixtures of Univariate Normal Distributions</p></a></li>
<li><a href='#norMix2call'><p>Transform &quot;norMix&quot; object into Call, Expression or Function</p></a></li>
<li><a href='#norMixFit'><p>EM and MLE Estimation of Univariate Normal Mixtures</p></a></li>
<li><a href='#plot.norMix'><p>Plotting Methods for 'norMix' Objects</p></a></li>
<li><a href='#pnorMix'><p>Normal Mixture Cumulative Distribution and Quantiles</p></a></li>
<li><a href='#r.norMix'><p>Ratio of Normal Mixture to Corresponding Normal</p></a></li>
<li><a href='#rnorMix'><p>Generate 'Normal Mixture' Distributed Random Numbers</p></a></li>
<li><a href='#sort.norMix'><p>Sort Method for &quot;norMix&quot; Objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Normal aka Gaussian 1-d Mixture Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-05</td>
</tr>
<tr>
<td>Description:</td>
<td>Onedimensional Normal (i.e. Gaussian) Mixture Models (S3) Classes,
   for, e.g., density estimation or clustering algorithms research and teaching;
   providing the widely used Marron-Wand densities.  Efficient random
   number generation and graphics. Fitting to data by efficient ML (Maximum
   Likelihood) or traditional EM estimation.</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cluster, copula</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://curves-etc.r-forge.r-project.org/">https://curves-etc.r-forge.r-project.org/</a>,
<a href="https://r-forge.r-project.org/R/?group_id=846">https://r-forge.r-project.org/R/?group_id=846</a>,
<a href="https://r-forge.r-project.org/scm/viewvc.php/pkg/nor1mix/?root=curves-etc">https://r-forge.r-project.org/scm/viewvc.php/pkg/nor1mix/?root=curves-etc</a>,
svn://svn.r-forge.r-project.org/svnroot/curves-etc/pkg/nor1mix</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://r-forge.r-project.org/R/?group_id=846">https://r-forge.r-project.org/R/?group_id=846</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-05 18:14:12 UTC; maechler</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Maechler <a href="https://orcid.org/0000-0002-8685-9910"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Friedrich Leisch <a href="https://orcid.org/0000-0001-7278-1983"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (norMixEM()),
  Erik Jørgensen [ctb] (pnorMix(), qnorMix())</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Maechler &lt;maechler@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-06 09:53:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='nor1mix-package'>Normal aka Gaussian 1-d Mixture Models</h2><span id='topic+nor1mix-package'></span><span id='topic+nor1mix'></span>

<h3>Description</h3>

<p>Onedimensional Normal (i.e. Gaussian) Mixture Models (S3) Classes,
   for, e.g., density estimation or clustering algorithms research and teaching;
   providing the widely used Marron-Wand densities.  Efficient random
   number generation and graphics. Fitting to data by efficient ML (Maximum
   Likelihood) or traditional EM estimation.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> nor1mix</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Normal aka Gaussian 1-d Mixture Models</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.3-3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-04-05</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Martin", "Maechler", role = c("aut","cre"),
                    email = "maechler@stat.math.ethz.ch",
	            comment = c(ORCID = "0000-0002-8685-9910"))
	   , person("Friedrich", "Leisch", role = "ctb",
                    comment = c("norMixEM()", ORCID = "0000-0001-7278-1983"))
	   , person("Erik", "Jørgensen", role = "ctb", comment = "pnorMix(), qnorMix()")
          )</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Onedimensional Normal (i.e. Gaussian) Mixture Models (S3) Classes,
   for, e.g., density estimation or clustering algorithms research and teaching;
   providing the widely used Marron-Wand densities.  Efficient random
   number generation and graphics. Fitting to data by efficient ML (Maximum
   Likelihood) or traditional EM estimation.</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> stats, graphics</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> cluster, copula</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://curves-etc.r-forge.r-project.org/,
https://r-forge.r-project.org/R/?group_id=846,
https://r-forge.r-project.org/scm/viewvc.php/pkg/nor1mix/?root=curves-etc,
svn://svn.r-forge.r-project.org/svnroot/curves-etc/pkg/nor1mix</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://r-forge.r-project.org/R/?group_id=846</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Martin Maechler [aut, cre] (&lt;https://orcid.org/0000-0002-8685-9910&gt;),
  Friedrich Leisch [ctb] (norMixEM(),
    &lt;https://orcid.org/0000-0001-7278-1983&gt;),
  Erik Jørgensen [ctb] (pnorMix(), qnorMix())</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Martin Maechler &lt;maechler@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
MarronWand              Marron-Wand Densities as 'norMix' Objects
clus2norMix             Transform Clustering / Grouping to Normal
                        Mixture
dnorMix                 Normal Mixture Density
llnorMix                Likelihood, Parametrization and EM-Steps For 1D
                        Normal Mixtures
nor1mix-package         Normal aka Gaussian 1-d Mixture Models
norMix                  Mixtures of Univariate Normal Distributions
norMix2call             Transform "norMix" object into Call, Expression
                        or Function
norMixEM                EM and MLE Estimation of Univariate Normal
                        Mixtures
plot.norMix             Plotting Methods for 'norMix' Objects
pnorMix                 Normal Mixture Cumulative Distribution and
                        Quantiles
r.norMix                Ratio of Normal Mixture to Corresponding Normal
rnorMix                 Generate 'Normal Mixture' Distributed Random
                        Numbers
sort.norMix             Sort Method for "norMix" Objects
</pre>
<p>Note that direct Maximum Likelihood ML (via <code><a href="stats.html#topic+optim">optim</a>()</code>) is typically much
faster converging (and more reliably detecting convergence correctly),
notably thanks to a smart re-parametrization: use <code><a href="#topic+norMixMLE">norMixMLE</a>()</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler [aut, cre] (&lt;https://orcid.org/0000-0002-8685-9910&gt;),
  Friedrich Leisch [ctb] (norMixEM(),
    &lt;https://orcid.org/0000-0001-7278-1983&gt;),
  Erik Jørgensen [ctb] (pnorMix(), qnorMix())
</p>
<p>Maintainer: Martin Maechler &lt;maechler@stat.math.ethz.ch&gt;
</p>


<h3>See Also</h3>

<p>The Marron-Wand examples of normal (gaussian) mixtures <code><a href="#topic+MarronWand">MarronWand</a></code>.
</p>
<p>Multivariate distributions from copulas <code><a href="copula.html#topic+Mvdc">Mvdc</a></code>
from the <span class="pkg">copula</span> package can use <code><a href="#topic+norMix">norMix</a></code> marginals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   example(dnorMix)
   
</code></pre>

<hr>
<h2 id='clus2norMix'>Transform Clustering / Grouping to Normal Mixture</h2><span id='topic+clus2norMix'></span>

<h3>Description</h3>

<p>Simple transformation of a clustering or grouping to a normal mixture
object (class <code>"norMix"</code>, see, <code><a href="#topic+norMix">norMix</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clus2norMix(gr, x, name = deparse(sys.call()))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clus2norMix_+3A_gr">gr</code></td>
<td>
<p>a grouping/clustering vector with values in
<code class="reqn">\{1,..,K\}</code>; possibly a <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
<tr><td><code id="clus2norMix_+3A_x">x</code></td>
<td>
<p>numeric vector of (original) data (of the same length as <code>gr</code>).</p>
</td></tr>
<tr><td><code id="clus2norMix_+3A_name">name</code></td>
<td>
<p>name for <code><a href="#topic+norMix">norMix</a>()</code> object; constructed from
the call by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A call to <code><a href="#topic+norMix">norMix</a>()</code> with <code>(mu, sig2, w)</code> set to the
empirical values of the groups (as defined by <code><a href="base.html#topic+split">split</a>(x,gr)</code>.
</p>


<h3>Note</h3>

<p>Via this function, any simple clustering algorithm (such
<code><a href="cluster.html#topic+pam">pam</a></code>) can be used as simple mixture model
fitting procedure.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler, Dec. 2007</p>


<h3>See Also</h3>

<p><code><a href="#topic+norMix">norMix</a></code>; further <code><a href="cluster.html#topic+pam">pam</a>()</code> (or
<code><a href="cluster.html#topic+clara">clara</a>()</code>) from package <span class="pkg">cluster</span> for
sensible clusterings.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x9 &lt;- rnorMix(500, MW.nm9)
require("cluster")
pxc &lt;- pam(x9, k=3)
plot(pxc, which = 2)# silhouette

(nm.p9 &lt;- clus2norMix(pxc$clustering, x9))
plot(nm.p9, p.norm=FALSE)
lines(MW.nm9, col="thistle")
</code></pre>

<hr>
<h2 id='dnorMix'>Normal Mixture Density</h2><span id='topic+dnorMix'></span><span id='topic+dnorMixL'></span><span id='topic+dpnorMix'></span>

<h3>Description</h3>

<p>Evaluate the density function of the normal mixture specified as
<code><a href="#topic+norMix">norMix</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnorMix (x, obj,        log = FALSE)

dnorMixL(obj, x = NULL, log = FALSE, xlim = NULL, n = 511)
dpnorMix(x, obj, lower.tail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dnorMix_+3A_obj">obj</code></td>
<td>
<p>an object of class <code>norMix</code>.</p>
</td></tr>
<tr><td><code id="dnorMix_+3A_x">x</code></td>
<td>
<p>numeric vector with abscissa values where to evaluate the
density (and probability, for <code>dpnorMix()</code>).  For <code>dnorMixL()</code>
by default, when <code>NULL</code>, it is constructed
from <code>n</code> (and <code>xlim</code> if that is specified).</p>
</td></tr>
<tr><td><code id="dnorMix_+3A_log">log</code></td>
<td>
<p>logical indicating <em>log</em>-density values should be returned.</p>
</td></tr>
<tr><td><code id="dnorMix_+3A_xlim">xlim</code></td>
<td>
<p>range of abscissa values, used if <code>x == NULL</code>.  By default,
xlim is taken as mean plus/minus 3 standard deviations of the normal
mixture.</p>
</td></tr>
<tr><td><code id="dnorMix_+3A_n">n</code></td>
<td>
<p>number of abscissa values to generate if <code>x</code> is not specified.</p>
</td></tr>
<tr><td><code id="dnorMix_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dnorMix(x)</code> returns the numeric vector of density values
<code class="reqn">f(x)</code>, logged if <code>log</code> is TRUE.
</p>
<p><code>dnorMixL()</code> returns a list with components
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>the abscissa values.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the density values <code class="reqn">f(x)</code> as for <code>dnorMix()</code>.</p>
</td></tr>
</table>
<p><code>dpnorMix()</code> returns a list with components
</p>
<table>
<tr><td><code>d</code></td>
<td>
<p>the density values <code class="reqn">f(x)</code> as for <code>dnorMix()</code>.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the probability values <code class="reqn">F(x)</code> as for <code>pnorMix()</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+rnorMix">rnorMix</a></code> for random number generation, and
<code><a href="#topic+norMix">norMix</a></code> for the construction and further methods,
particularly <code><a href="#topic+plot.norMix">plot.norMix</a></code> which makes use <code>dnorMix</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ff &lt;- dnorMixL(MW.nm7)
 str(ff)
 plot(ff, type = "h", ylim = c(0,1)) # rather use plot(ff, ...)

 x &lt;- seq.int(-4,5, length.out = 501)
 dp &lt;- dpnorMix(x, MW.nm7)
 lines(x, dp$d, col = "tomato", lwd=3)
 lines(x, dp$p, col = 3, lwd=2)# does not fit y-wise
 stopifnot(all.equal(dp$d, dnorMix(x, MW.nm7), tolerance=1e-12),
           all.equal(dp$p, pnorMix(x, MW.nm7), tolerance=1e-12))
</code></pre>

<hr>
<h2 id='llnorMix'>Likelihood, Parametrization and EM-Steps For 1D Normal Mixtures</h2><span id='topic+llnorMix'></span><span id='topic+par2norMix'></span><span id='topic+nM2par'></span><span id='topic+estep.nm'></span><span id='topic+mstep.nm'></span><span id='topic+emstep.nm'></span>

<h3>Description</h3>

<p>These functions work with an almost unconstrained parametrization of
univariate normal mixtures.
</p>

<dl>
<dt><code>llnorMix(p, *)</code></dt><dd><p>computes the log likelihood,</p>
</dd>
<dt><code>obj &lt;- par2norMix(p)</code></dt><dd><p>maps parameter vector <code>p</code> to
a <code><a href="#topic+norMix">norMix</a></code> object <code>obj</code>,</p>
</dd>
<dt><code>p &lt;- nM2par(obj)</code></dt><dd><p>maps from a <code><a href="#topic+norMix">norMix</a></code>
object <code>obj</code> to parameter vector <code>p</code>,</p>
</dd>
</dl>

<p>where <code>p</code> is always a parameter vector in our parametrization.
</p>
<p>Partly for didactical reasons, the following functions provide the
basic ingredients for the EM algorithm (see also
<code><a href="#topic+norMixEM">norMixEM</a></code>) to parameter estimation:
</p>

<dl>
<dt><code>estep.nm(x, obj, p)</code></dt><dd><p>computes 1 E-step for the data
<code>x</code>, given <em>either</em> a <code>"norMix"</code> object <code>obj</code>
or parameter vector <code>p</code>.</p>
</dd>
<dt><code>mstep.nm(x, z)</code></dt><dd><p>computes 1 M-step for the data
<code>x</code> and the probability matrix <code>z</code>.</p>
</dd>
<dt><code>emstep.nm(x, obj)</code></dt><dd><p>computes 1 E- and 1 M-step for the data
<code>x</code> and the <code>"norMix"</code> object <code>obj</code>.</p>
</dd>
</dl>

<p>where again, <code>p</code> is a parameter vector in our parametrization,
<code>x</code> is the (univariate) data, and <code>z</code> is a <code class="reqn">n \times
    m</code> <code><a href="base.html#topic+matrix">matrix</a></code> of (posterior) conditional
probabilities, and <code class="reqn">\theta</code> is the full parameter vector of the
mixture model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llnorMix(p, x, m = (length(p) + 1)/3, trafo = c("clr1", "logit"))

par2norMix(p, trafo = c("clr1", "logit"), name = )

nM2par(obj, trafo = c("clr1", "logit"))

 estep.nm(x, obj, par)
 mstep.nm(x, z)
emstep.nm(x, obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llnorMix_+3A_p">p</code>, <code id="llnorMix_+3A_par">par</code></td>
<td>
<p>numeric vector: our parametrization of a univariate normal
mixture, see details.</p>
</td></tr>
<tr><td><code id="llnorMix_+3A_x">x</code></td>
<td>
<p>numeric: the data for which the likelihood is to be computed.</p>
</td></tr>
<tr><td><code id="llnorMix_+3A_m">m</code></td>
<td>
<p>integer number of mixture components; this is not to be
changed for a given <code>p</code>.</p>
</td></tr>
<tr><td><code id="llnorMix_+3A_trafo">trafo</code></td>
<td>
<p><code><a href="base.html#topic+character">character</a></code> string specifying the transformation
of the component weight <code>w</code> <code class="reqn">m</code>-vector (mathematical notation
in <code><a href="#topic+norMix">norMix</a></code>: <code class="reqn">\pi_j, j=1,\dots,m</code>) to an
<code class="reqn">m-1</code>-dimensional unconstrained parameter vector in our
parametrization.  <code>"logit"</code> has been hard-wired upto <span class="pkg">nor1mix</span>
version 1.2-3, and has been replaced <em>as default</em> in 2019 for <span class="pkg">nor1mix</span>
version 1.2-4 by <code>"clr1"</code> which is more symmetric and basically
Aitchinson's <b>c</b>entered <b>l</b>og <b>r</b>atio, see also CRAN package
<a href="https://CRAN.R-project.org/package=compositions"><span class="pkg">compositions</span></a>' <code>clr()</code>.</p>
</td></tr>
<tr><td><code id="llnorMix_+3A_name">name</code></td>
<td>
<p>(for <code>par2norMix()</code>:) a name for the <code>"norMix"</code>
object that is returned, uses a smart default.</p>
</td></tr>
<tr><td><code id="llnorMix_+3A_obj">obj</code></td>
<td>
<p>a <code>"norMix"</code> object, see <code><a href="#topic+norMix">norMix</a></code>.</p>
</td></tr>
<tr><td><code id="llnorMix_+3A_z">z</code></td>
<td>
<p>a <code class="reqn">n \times m</code> <code><a href="base.html#topic+matrix">matrix</a></code> of (posterior)
conditional probabilities,
<code class="reqn">z_{ij}= P(x_i \in C_j | \theta)</code>,
where <code class="reqn">C_j</code> denotes the <code class="reqn">j</code>-th group (&ldquo;cluster&rdquo;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We use a parametrization of a (finite) <code class="reqn">m</code>-component univariate normal mixture which
is particularly apt for likelihood maximization, namely, one whose
parameter space is <em>almost</em> a full <code class="reqn">\mathbf{I\hskip-0.22em R}^M</code>,
<code class="reqn">M = 3m-1</code>.
</p>
<p>For an <code class="reqn">m</code>-component mixture,
we map to and from a parameter vector <code class="reqn">\theta</code> (<code>== p</code> as <span class="rlang"><b>R</b></span>-vector)
of length <code class="reqn">3m-1</code>.  For mixture density
</p>
<p style="text-align: center;"><code class="reqn">\sum_{j=1}^m \pi_j \phi((t - \mu_j)/\sigma_j)/\sigma_j,</code>
</p>

<p>we transform the <code class="reqn">\pi_j</code> (for <code class="reqn">j \in 1,\dots,m</code>) via the transform specified by <code>trafo</code> (see below),
and log-transform the <code class="reqn">\sigma_j</code>.  Consequently, <code class="reqn">\theta</code> is
partitioned into
</p>

<dl>
<dt><code>p[ 1:(m-1)]</code>: </dt><dd><p>For
</p>

<dl>
<dt><code>trafo = "logit"</code>:</dt><dd>
<p><code>p[j]</code><code class="reqn">=
	    \mbox{logit}(\pi_{j+1})</code> and
<code class="reqn">\pi_1</code> is given implicitly as
<code class="reqn">\pi_1 = 1-\sum_{j=2}^m \pi_j</code>.</p>
</dd>
<dt><code>trafo = "clr1"</code>:</dt><dd><p>(<b>c</b>entered <b>l</b>og
<b>r</b>atio, omitting 1st element):
Set <code class="reqn">\ell_j := \ln(\pi_j)</code> for <code class="reqn">j = 1, \dots, m</code>, and
<code>p[j]</code><code class="reqn">= \ell_{j+1} - 1/m\sum_{j'=1}^m \ell_{j'}</code>
for <code class="reqn">j = 1, \dots, m-1</code>.</p>
</dd>
</dl>

</dd>
<dt><code>p[ m:(2m-1)]</code>: </dt><dd><p><code>p[m-1+ j]</code><code class="reqn">= \mu_j</code>, for j=1:m.</p>
</dd>
<dt><code>p[2m:(3m-1)]</code>: </dt><dd><p><code>p[2*m-1+ j]</code>
<code class="reqn">= \log(\sigma_j)</code>, i.e.,
<code class="reqn">\sigma_j^2 = exp(2*p[.+j])</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>llnorMix()</code> returns a number, namely the log-likelihood.
</p>
<p><code>par2norMix()</code> returns <code>"norMix"</code> object, see <code><a href="#topic+norMix">norMix</a></code>.
</p>
<p><code>nM2par()</code> returns the parameter vector <code class="reqn">\theta</code> of length <code class="reqn">3m-1</code>.
</p>
<p><code>estep.nm()</code> returns <code>z</code>, the matrix of (conditional) probabilities.
</p>
<p><code>mstep.nm()</code> returns the model parameters as a
<code><a href="base.html#topic+list">list</a></code> with components <code>w</code>, <code>mu</code>, and
<code>sigma</code>, corresponding to the arguments of <code><a href="#topic+norMix">norMix</a>()</code>.
(and see the 'Examples' on using <code><a href="base.html#topic+do.call">do.call</a>(norMix, *)</code> with it.)
</p>
<p><code>emstep.nm()</code> returns an <em>updated</em> <code>"norMix"</code> object.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="#topic+norMix">norMix</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code>.
Note that the log likelihood of a <code>"norMix"</code> object
is directly given by <code>sum(<a href="#topic+dnorMix">dnorMix</a>(x, obj, log=TRUE))</code>.
</p>
<p>To fit, using the EM algorithm, rather use <code><a href="#topic+norMixEM">norMixEM</a>()</code>
than the <code>e.step</code>, <code>m.step</code>, or <code>em.step</code> functions.
</p>
<p>Note that direct likelihood maximization, i.e., MLE, is typically
considerably more efficient than the EM, and typically converges well
with our parametrization, see <code><a href="#topic+norMixMLE">norMixMLE</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(obj &lt;- MW.nm10) # "the Claw" -- m = 6 components
length(pp &lt;- nM2par(obj)) # 17 == (3*6) - 1
par2norMix(pp)
## really the same as the initial 'obj' above

## Log likelihood (of very artificial data):
llnorMix(pp, x = seq.int(-2, 2, length.out = 1000))
set.seed(47)## of more realistic data:
x &lt;- rnorMix(1000, obj)
llnorMix(pp, x)

## Consistency check :  nM2par()  and  par2norMix()  are inverses
all.EQ &lt;- function(x,y, tol = 1e-15, ...) all.equal(x,y, tolerance=tol, ...)
stopifnot(all.EQ(pp, nM2par(par2norMix(pp))),
          all.EQ(obj, par2norMix(nM2par(obj)),
                    check.attributes=FALSE),
          ## Direct computation of log-likelihood:
          all.EQ(sum(dnorMix(x, obj, log=TRUE)),
                    llnorMix(pp, x))  )

## E- and M- steps : ------------------------------
rE1 &lt;- estep.nm(x, obj)
rE2 &lt;- estep.nm(x, par=pp) # the same as rE1
z &lt;- rE1
str( rM &lt;-  mstep.nm(x, z))
   (rEM &lt;- emstep.nm(x, obj))

stopifnot(all.EQ(rE1, rE2),
          all.EQ(rEM, do.call(norMix, c(rM, name=""))))
</code></pre>

<hr>
<h2 id='MarronWand'>Marron-Wand Densities as 'norMix' Objects</h2><span id='topic+MarronWand'></span><span id='topic+MW.nm1'></span><span id='topic+MW.nm2'></span><span id='topic+MW.nm2.old'></span><span id='topic+MW.nm3'></span><span id='topic+MW.nm4'></span><span id='topic+MW.nm5'></span><span id='topic+MW.nm6'></span><span id='topic+MW.nm7'></span><span id='topic+MW.nm8'></span><span id='topic+MW.nm9'></span><span id='topic+MW.nm10'></span><span id='topic+MW.nm11'></span><span id='topic+MW.nm12'></span><span id='topic+MW.nm13'></span><span id='topic+MW.nm14'></span><span id='topic+MW.nm15'></span><span id='topic+MW.nm16'></span>

<h3>Description</h3>

<p>The fifteen density examples used in Marron and Wand (1992)'s
simulation study have been used in quite a few subsequent studies,
can all be written as normal mixtures and are provided here for
convenience and didactical examples of normal mixtures.
Number 16 has been added by Jansen et al.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> MW.nm1	 # Gaussian
 MW.nm2	 # Skewed
 MW.nm2.old # Skewed(old)
 MW.nm3	 # Str Skew
 MW.nm4	 # Kurtotic
 MW.nm5	 # Outlier
 MW.nm6	 # Bimodal
 MW.nm7	 # Separated (bimodal)
 MW.nm8	 # Asymmetric Bimodal
 MW.nm9	 # Trimodal
 MW.nm10 # Claw
 MW.nm11 # Double Claw
 MW.nm12 # Asymmetric Claw
 MW.nm13 # Asymm. Double Claw
 MW.nm14 # Smooth   Comb
 MW.nm15 # Discrete Comb
 MW.nm16 # Distant Bimodal
</code></pre>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>Source</h3>

<p>They have been translated from Steve Marron's Matlab code,

now at

<a href="https://marronwebfiles.sites.oasis.unc.edu/OldResearch/parameters/nmpar.m">https://marronwebfiles.sites.oasis.unc.edu/OldResearch/parameters/nmpar.m</a>,
however for number 2, the Matlab code had <code>MW.nm2.old</code>; and I've
defined <code>MW.nm2</code> as from the Annals paper; see also the last
example below.
</p>


<h3>References</h3>

<p>Marron, S. and Wand, M. (1992)
Exact Mean Integrated Squared Error;
<em>Annals of Statistcs</em> <b>20</b>, 712&ndash;736.
</p>
<p>For number 16,<br />
P. Janssen, J. S. Marron, N. Veraverbeke and W. Sarle (1995)
Scale measures for bandwidth selection;
<em>Journal of Nonparametric Statistics</em> <b>5</b>, 359&ndash;380.
<a href="https://doi.org/10.1080/10485259508832654">doi:10.1080/10485259508832654</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MW.nm10
plot(MW.nm14)

## These are defined as norMix() calls in  ../R/zMarrWand-dens.R
nms &lt;- ls(pattern = "^MW.nm", "package:nor1mix")
nms &lt;- nms[order(as.numeric(substring(nms,6)))] # w/ warning for "2.old"
for(n in nms) {
   cat("\n",n,":\n"); print(get(n, "package:nor1mix"))
}

## Plot all of them:
op &lt;- par(mfrow=c(4,4), mgp = c(1.2, 0.5, 0), tcl = -0.2,
          mar = .1 + c(2,2,2,1), oma = c(0,0,3,0))
for(n in nms[-17]) plot(get(n, "package:nor1mix"))
mtext("The Marron-Wand Densities", outer= TRUE, font= 2, cex= 1.6)

## and their Q-Q-plots (not really fast):
prob &lt;- ppoints(N &lt;- 100)
for(n in nms[-17]) # qnorMix() using monotone spline inversion ==&gt; warning
   qqnorm(qnorMix(prob, get(n, "package:nor1mix")), main = n)
mtext("QQ-plots of Marron-Wand Densities", outer = TRUE,
      font = 2, cex = 1.6)
par(op)

## "object" overview:
cbind(sapply(nms, function(n) { o &lt;- get(n)
      sprintf("%-18s: K =%2d; rng = [%3.1f, %2.1f]",
              attr(o, "name"), nrow(o),
              min(o[,"mu"] - 3*o[,"sigma"]),
              max(o[,"mu"] + 3*o[,"sigma"]) )
             }))


## Note that Marron-Wand (1992), p.720  give #2 as
MW.nm2
## the parameters of which at first look quite different from
MW.nm2.old
## which has been the definition in the above "Source" Matlab code.
## It's easy to see that mu_{nm2} = -.3 + 1.2   * mu_{paper},
## and correspondigly,   s2_{nm2} =       1.2^2 * s2_{paper}
## such that they are "identical" apart from scale and location:
op. &lt;- par(mfrow=2:1, mgp= c(1.2,0.5,0), tcl= -0.2, mar=.1+c(2,2,2,1))
plot(MW.nm2)
plot(MW.nm2.old)
par(op.)
</code></pre>

<hr>
<h2 id='norMix'>Mixtures of Univariate Normal Distributions</h2><span id='topic+norMix'></span><span id='topic++5B.norMix'></span><span id='topic+is.norMix'></span><span id='topic+m.norMix'></span><span id='topic+mean.norMix'></span><span id='topic+var.norMix'></span><span id='topic+print.norMix'></span>

<h3>Description</h3>

<p>Objects of class <code>norMix</code> represent finite mixtures of
(univariate) normal (aka Gaussian) distributions.  Methods for
construction, printing, plotting, and basic computations are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norMix(mu, sig2 = rep(1,m), sigma = rep(1,m),
       w = NULL, name = NULL, long.name = FALSE)

is.norMix(obj)
 m.norMix(obj)
var.norMix(x, ...)
## S3 method for class 'norMix'
mean(x, ...)
## S3 method for class 'norMix'
print(x, ...)
## S3 method for class 'norMix'
x[i,j, drop=TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norMix_+3A_mu">mu</code></td>
<td>
<p>numeric vector of length <code class="reqn">K</code>, say, specifying the means
<code class="reqn">\mu</code> of the <code class="reqn">K</code> normal components.</p>
</td></tr>
<tr><td><code id="norMix_+3A_sig2">sig2</code></td>
<td>
<p><b>deprecated!</b> numeric vector of length <code class="reqn">K</code>,
specifying the variances <code class="reqn">\sigma^2</code> of the <code class="reqn">K</code> normal
components.  Do specify <code>sigma</code> instead!</p>
</td></tr>
<tr><td><code id="norMix_+3A_sigma">sigma</code></td>
<td>
<p>numeric vector of length <code class="reqn">K</code>, specifying the standard deviations
<code class="reqn">\sigma</code> of the <code class="reqn">K</code> normal components.</p>
</td></tr>
<tr><td><code id="norMix_+3A_w">w</code></td>
<td>
<p>numeric vector of length <code class="reqn">K</code>, specifying the mixture proportions
<code class="reqn">\pi_j</code> of the normal components, <code class="reqn">j = 1,\dots,K</code>.
Defaults to equal proportions</p>
</td></tr>
<tr><td><code id="norMix_+3A_name">name</code></td>
<td>
<p>optional name tag of the result (used for printing).</p>
</td></tr>
<tr><td><code id="norMix_+3A_long.name">long.name</code></td>
<td>
<p>logical indicating if the <code>name</code> attribute
should use punctuation and hence be slightly larger than by default.</p>
</td></tr>
<tr><td><code id="norMix_+3A_obj">obj</code>, <code id="norMix_+3A_x">x</code></td>
<td>
<p>an object of class <code>norMix</code>.</p>
</td></tr>
<tr><td><code id="norMix_+3A_i">i</code>, <code id="norMix_+3A_j">j</code>, <code id="norMix_+3A_drop">drop</code></td>
<td>
<p>for indexing, see the generic <code><a href="base.html#topic++5B">[</a></code> extractor function.</p>
</td></tr>
<tr><td><code id="norMix_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The (one dimensional) normal mixtures, <span class="rlang"><b>R</b></span> objects of class
<code>"norMix"</code>, are constructed by <code>norMix</code> and tested for by
<code>is.norMix</code>.  <code>m.norMix()</code> returns the number of mixture
components; the <code>mean()</code> method for <code><a href="base.html#topic+class">class</a> "norMix"</code>
returns the (theoretical / true) mean <code class="reqn">E[X]</code> and 
<code>var.norMix()</code> 
the true variance <code class="reqn">E[(X- E[X])^2]</code> where
<code class="reqn">X \sim \langle\mathit{norm.mixt}\rangle</code>.
</p>
<p>The subsetting aka &ldquo;extract&rdquo; method (<code>x[i,j]</code>; for generic
<code>[</code>)&mdash;when called as <code>x[i,]</code>&mdash;will typically return a
<code>"norMix"</code> object unless matrix indexing selects only one row in
which case <code>x[i, , drop=FALSE]</code> will return the normal mixture
(of one component only).
</p>
<p>For further methods (density, random number generation, fitting,
...), see below. 
</p>


<h3>Value</h3>

<p><code>norMix</code> returns objects of class <code>"norMix"</code> which are
currently implemented as 3-column matrix with column names <code>mu</code>,
<code>sigma</code>, and <code>w</code>, and further attributes.
The user should rarely need to access the underlying structure
directly.
</p>


<h3>Note</h3>

<p>For <em>estimation</em> of the parameters of such a normal mixture,
we provide a smart parametrization and an efficient implementation of
the direct MLE or also the EM algorithm, see
<code><a href="#topic+norMixMLE">norMixMLE</a>()</code> which includes <code>norMixEM()</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="#topic+dnorMix">dnorMix</a></code> for the density,
<code><a href="#topic+pnorMix">pnorMix</a></code> for the cumulative distribution
and the quantile function (<code>qnorMix</code>), and
<code><a href="#topic+rnorMix">rnorMix</a></code> for random numbers and
<code><a href="#topic+plot.norMix">plot.norMix</a></code>, the plot method.
</p>
<p><code><a href="#topic+MarronWand">MarronWand</a></code> has the Marron-Wand densities as normal mixtures.
</p>
<p><code><a href="#topic+norMixMLE">norMixMLE</a>()</code> and <code>norMixEM()</code> provide <em>fitting</em>
of univariate normal mixtures to data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex &lt;- norMix(mu = c(1,2,5))# defaults: sigma = 1, equal proportions ('w')
ex
plot(ex, p.comp = TRUE)# looks like a mixture of only 2; 'p.comp' plots components

## The 2nd Marron-Wand example, see also  ?MW.nm2
ex2 &lt;- norMix(name = "#2 Skewed",
                mu = c(0, .5, 13/12),
	     sigma = c(1, 2/3, 5/9),
		 w = c(.2, .2, .6))

m.norMix  (ex2)
mean      (ex2)
var.norMix(ex2)
(e23 &lt;- ex2[2:3,]) # (with re-normalized weights)
stopifnot(is.norMix(e23),
          all.equal(var.norMix(ex2),     719/1080, tol=1e-14),
          all.equal(var.norMix(ex ),      35/9,    tol=1e-14),
          all.equal(var.norMix(ex[2:3,]), 13/4,    tol=1e-14),
          all.equal(var.norMix(e23), 53^2/(12^3*4),tol=1e-14)
)

plot(ex2, log = "y")# maybe "revealing"
</code></pre>

<hr>
<h2 id='norMix2call'>Transform &quot;norMix&quot; object into Call, Expression or Function</h2><span id='topic+norMix2call'></span><span id='topic+as.expression.norMix'></span><span id='topic+as.function.norMix'></span>

<h3>Description</h3>

<p>E.g., for taking symbolic derivatives, it may be useful to get an <span class="rlang"><b>R</b></span>
<code><a href="base.html#topic+call">call</a></code>, <code><a href="base.html#topic+expression">expression</a></code>, or <code><a href="base.html#topic+function">function</a></code>
in / of <code>x</code> from a specific <code>"<a href="#topic+norMix">norMix</a>"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norMix2call(obj, oneArg = TRUE)
## S3 method for class 'norMix'
as.expression(x, oneArg = TRUE, ...)
## S3 method for class 'norMix'
  as.function(x, oneArg = TRUE, envir = parent.frame(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norMix2call_+3A_obj">obj</code>, <code id="norMix2call_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of <code><a href="base.html#topic+class">class</a></code> <code>"<a href="#topic+norMix">norMix</a>"</code>.</p>
</td></tr>
<tr><td><code id="norMix2call_+3A_onearg">oneArg</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> specifying if expressions of the form
<code>dnorm((x - mu)/sig)</code> should be used, i.e. <b>one Arg</b>ument
only, instead of <code>dnorm(x, mu, sig)</code>.</p>
</td></tr>
<tr><td><code id="norMix2call_+3A_envir">envir</code></td>
<td>
<p>an <code><a href="base.html#topic+environment">environment</a></code>; often the default is perfect.</p>
</td></tr>
<tr><td><code id="norMix2call_+3A_...">...</code></td>
<td>
<p>potentially further arguments (not used in any examples yet).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>according to the function used, an <span class="rlang"><b>R</b></span>  &lsquo;language&rsquo; object, i.e., a
<code><a href="base.html#topic+call">call</a></code>, <code><a href="base.html#topic+expression">expression</a></code>, or <code><a href="base.html#topic+function">function</a></code>, respectively.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="#topic+norMix">norMix</a></code>.  Note that <code><a href="stats.html#topic+deriv">deriv</a>()</code> currently only
works correctly in case of the default <code>oneArg = TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(cMW2 &lt;- norMix2call(MW.nm2))
deriv(cMW2, "x")

(fMW1 &lt;- as.function  (MW.nm1))
(eMW3 &lt;- as.expression(MW.nm3))
stopifnot(is.call      (cMW2),  is.call(norMix2call(MW.nm2, FALSE)),
          is.function  (fMW1),  is.function  (as.function  (MW.nm4)),
          is.expression(eMW3),  is.expression(as.expression(MW.nm5))
)
</code></pre>

<hr>
<h2 id='norMixFit'>EM and MLE Estimation of Univariate Normal Mixtures</h2><span id='topic+norMixEM'></span><span id='topic+norMixMLE'></span>

<h3>Description</h3>

<p>These functions estimate the parameters of a univariate (finite) normal
mixture using the EM algorithm or Likelihood Maximimization via
<code><a href="stats.html#topic+optim">optim</a>(.., method = "BFGS")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norMixEM(x, m, name = NULL, sd.min = 1e-07* diff(range(x))/m,
         trafo = c("clr1", "logit"),
         maxiter = 100, tol = sqrt(.Machine$double.eps), trace = 1)

norMixMLE(x, m, name = NULL, 
          trafo = c("clr1", "logit"),
          maxiter = 100, tol = sqrt(.Machine$double.eps), trace = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norMixFit_+3A_x">x</code></td>
<td>
<p>numeric: the data for which the parameters are to be estimated.</p>
</td></tr>
<tr><td><code id="norMixFit_+3A_m">m</code></td>
<td>
<p>integer or factor: If <code>m</code> has length 1 it specifies the
number of mixture components, otherwise it is taken to be a vector
of initial cluster assignments, see details below.</p>
</td></tr>
<tr><td><code id="norMixFit_+3A_name">name</code></td>
<td>
<p>character, passed to <code><a href="#topic+norMix">norMix</a></code>.  The default,
<code>NULL</code>, uses <code><a href="base.html#topic+match.call">match.call</a>()</code>.</p>
</td></tr>
<tr><td><code id="norMixFit_+3A_sd.min">sd.min</code></td>
<td>
<p>number: the minimal value that the normal components'
standard deviations (<code>sd</code>) are allowed to take.  A warning is
printed if some of the final <code>sd</code>'s are this boundary.</p>
</td></tr>
<tr><td><code id="norMixFit_+3A_trafo">trafo</code></td>
<td>
<p><code><a href="base.html#topic+character">character</a></code> string specifying the transformation
of the component weight <code>w</code> <code class="reqn">m</code>-vector (mathematical notation
in <code><a href="#topic+norMix">norMix</a></code>: <code class="reqn">\pi_j, j=1,\dots,m</code>) to an
<code class="reqn">(m-1)</code>-dimensional unconstrained parameter vector in our
parametrization.  See <code><a href="#topic+nM2par">nM2par</a></code> for details.</p>
</td></tr>
<tr><td><code id="norMixFit_+3A_maxiter">maxiter</code></td>
<td>
<p>integer: maximum number of EM iterations.</p>
</td></tr>
<tr><td><code id="norMixFit_+3A_tol">tol</code></td>
<td>
<p>numeric: EM iterations stop if relative changes of the
log-likelihood are smaller than <code>tol</code>.</p>
</td></tr>
<tr><td><code id="norMixFit_+3A_trace">trace</code></td>
<td>
<p>integer (or logical) specifying if the iterations should be
traced and how much output should be produced.  The default,
<code>1</code> prints a final one line summary, where <code>trace = 2</code>
produces one line of output per iteration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimation of univariate mixtures can be very sensitive to
initialization.  By default, <code>norMixEM</code> and <code>norMixLME</code>
<code><a href="base.html#topic+cut">cut</a></code> the data into <code class="reqn">m</code> groups of approximately equal
size.  See examples below for other initialization possibilities.
</p>
<p>The EM algorithm consists in repeated application of E- and M- steps
until convergence.  Mainly for didactical reasons, we also provide the
functions <code><a href="#topic+estep.nm">estep.nm</a></code>, <code>mstep.nm</code>, and
<code><a href="#topic+emstep.nm">emstep.nm</a></code>.
</p>
<p>The MLE, Maximum Likelihood Estimator, maximizes the likelihood using
<code><a href="stats.html#topic+optim">optim</a></code>, using the same advantageous parametrization as
<code><a href="#topic+llnorMix">llnorMix</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+norMix">norMix</a></code>.
</p>


<h3>Author(s)</h3>

<p>EM: Friedrich Leisch, originally; Martin Maechler vectorized it in
<code class="reqn">m</code>, added <code>trace</code> etc.
</p>
<p>MLE: M.Maechler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## use (mu, sigma)
ex  &lt;- norMix(mu = c(-1,2,5), sigma = c(1, 1/sqrt(2), sqrt(3)))
tools::assertWarning(verbose=TRUE,
           ## *deprecated* (using 'sig2' will *NOT* work in future!)
           ex. &lt;- norMix(mu = c(-1,2,5), sig2 = c(1, 0.5, 3))
       )
stopifnot(all.equal(ex, ex.))
plot(ex, col="gray", p.norm=FALSE)

x &lt;- rnorMix(100, ex)
lines(density(x))
rug(x)

## EM estimation may fail depending on random sample
ex1 &lt;- norMixEM(x, 3, trace=2) #-&gt; warning (sometimes)
ex1
plot(ex1)

## initialization by cut() into intervals of equal length:
ex2 &lt;- norMixEM(x, cut(x, 3))
ex2

## initialization by kmeans():
k3 &lt;- kmeans(x, 3)$cluster
ex3 &lt;- norMixEM(x, k3)
ex3

## Now, MLE instead of EM:
exM &lt;- norMixMLE(x, k3, tol = 1e-12, trace=4)
exM

## real data
data(faithful)
plot(density(faithful$waiting, bw = "SJ"), ylim=c(0,0.044))
rug(faithful$waiting)

(nmF &lt;- norMixEM(faithful$waiting, 2))
lines(nmF, col=2)
## are three components better?
nmF3 &lt;- norMixEM(faithful$waiting, 3, maxiter = 200)
lines(nmF3, col="forestgreen")
</code></pre>

<hr>
<h2 id='plot.norMix'>Plotting Methods for 'norMix' Objects</h2><span id='topic+plot.norMix'></span><span id='topic+lines.norMix'></span>

<h3>Description</h3>

<p>The <code>plot</code> and <code>lines</code> methods for <code><a href="#topic+norMix">norMix</a></code>
objects draw the normal mixture density, optionally additonally with a
fitted normal density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'norMix'
plot(x, type = "l", n = 511, xout = NULL, xlim = NULL, ylim,
      xlab = "x", ylab = "f(x)", main = attr(x, "name"), lwd = 1.4,
      p.norm = !p.comp, p.h0 = TRUE, p.comp = FALSE,
      parNorm = list(col = 2, lty = 2, lwd = 0.4),
      parH0 = list(col = 3, lty = 3, lwd = 0.4),
      parComp = list(col= "blue3", lty = 3, lwd = 0.4), ...)

## S3 method for class 'norMix'
lines(x, type = "l", n = 511, xout = NULL,
      lwd = 1.4, p.norm = FALSE, parNorm = list(col = 2, lty = 2, lwd = 0.4),
      ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.norMix_+3A_x">x</code></td>
<td>
<p>object of class <code>norMix</code>.</p>
</td></tr>
<tr><td><code id="plot.norMix_+3A_type">type</code></td>
<td>
<p>character denoting type of plot, see, e.g. <code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
<tr><td><code id="plot.norMix_+3A_n">n</code></td>
<td>
<p>number of points to generate if <code>xout</code> is unspecified.</p>
</td></tr>
<tr><td><code id="plot.norMix_+3A_xout">xout</code></td>
<td>
<p>numeric or <code>NULL</code> giving the abscissae at which to
draw the density.</p>
</td></tr>
<tr><td><code id="plot.norMix_+3A_xlim">xlim</code></td>
<td>
<p>range of x values to use; particularly important if
<code>xout</code> is not specified where <code>xlim</code> is passed to
<code><a href="#topic+dnorMix">dnorMix</a></code> and gets a smart default if unspecified.</p>
</td></tr>
<tr><td><code id="plot.norMix_+3A_ylim">ylim</code></td>
<td>
<p>range of y values to use; by default, if not specified (or
containing <code>NA</code>), a smart default is used.</p>
</td></tr>
<tr><td><code id="plot.norMix_+3A_xlab">xlab</code>, <code id="plot.norMix_+3A_ylab">ylab</code></td>
<td>
<p>labels for the x and y axis with defaults.</p>
</td></tr>
<tr><td><code id="plot.norMix_+3A_main">main</code></td>
<td>
<p>main title of plot, defaulting to the <code><a href="#topic+norMix">norMix</a></code>
name.</p>
</td></tr>
<tr><td><code id="plot.norMix_+3A_lwd">lwd</code></td>
<td>
<p>line width for plotting with a non-standard default.</p>
</td></tr>
<tr><td><code id="plot.norMix_+3A_p.norm">p.norm</code></td>
<td>
<p>logical indicating if the normal density with the same
mean and variance should be drawn as well.</p>
</td></tr>
<tr><td><code id="plot.norMix_+3A_p.h0">p.h0</code></td>
<td>
<p>logical indicating if the line <code class="reqn">y = 0</code> should be drawn.</p>
</td></tr>
<tr><td><code id="plot.norMix_+3A_p.comp">p.comp</code></td>
<td>
<p>logical indicating if the Gaussian components should
also be drawn individually.</p>
</td></tr>
<tr><td><code id="plot.norMix_+3A_parnorm">parNorm</code></td>
<td>
<p>graphical parameters for drawing the normal density if
<code>p.norm</code> is true.</p>
</td></tr>
<tr><td><code id="plot.norMix_+3A_parh0">parH0</code></td>
<td>
<p>graphical parameters for drawing the line <code class="reqn">y = 0</code> if
<code>p.h0</code> is true.</p>
</td></tr>
<tr><td><code id="plot.norMix_+3A_parcomp">parComp</code></td>
<td>
<p>graphical parameters for drawing the single components if
<code>p.comp</code> is true.</p>
</td></tr>
<tr><td><code id="plot.norMix_+3A_...">...</code></td>
<td>
<p>further arguments passed to and from methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="#topic+norMix">norMix</a></code> for the construction and further methods,
particularly <code><a href="#topic+dnorMix">dnorMix</a></code> which is used here.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(norMix(m=c(0,3), sigma = c(2,1))) # -&gt; var = c(2^2, 1) = c(4, 1)

plot(MW.nm4, p.norm=FALSE, p.comp = TRUE)
plot(MW.nm4, p.norm=FALSE, p.comp = TRUE, ylim = c(0, 2))# now works
stopifnot(all.equal(c(0,2), par("yaxp")[1:2], tol= 1e-15))

## Further examples in  ?norMix and  ?rnorMix
</code></pre>

<hr>
<h2 id='pnorMix'>Normal Mixture Cumulative Distribution and Quantiles</h2><span id='topic+pnorMix'></span><span id='topic+qnorMix'></span>

<h3>Description</h3>

<p>Compute cumulative probabilities or quantiles (the inverse) for a
normal mixture specified as <code><a href="#topic+norMix">norMix</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnorMix(q, obj, lower.tail = TRUE, log.p = FALSE)

qnorMix(p, obj, lower.tail = TRUE, log.p = FALSE,
        tol = .Machine$double.eps^0.25, maxiter = 1000, traceRootsearch = 0,
        method = c("interpQspline", "interpspline", "eachRoot", "root2"),
        l.interp = pmax(1, pmin(20, 1000 / m)), n.mu.interp = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnorMix_+3A_obj">obj</code></td>
<td>
<p>an object of class <code>norMix</code>.</p>
</td></tr>
<tr><td><code id="pnorMix_+3A_p">p</code></td>
<td>
<p>numeric vector of probabilities.  Note that for all
<code>method</code>s but <code>"eachRoot"</code>, <code>qnorMix(p, *)</code> works
with the full vector <code>p</code>, typically using (inverse)
interpolation approaches; consequently the result is very
slightly dependent on <code>p</code> as a whole.</p>
</td></tr>
<tr><td><code id="pnorMix_+3A_q">q</code></td>
<td>
<p>numeric vector of quantiles</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="pnorMix_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="pnorMix_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="pnorMix_+3A_tol">tol</code>, <code id="pnorMix_+3A_maxiter">maxiter</code></td>
<td>
<p>tolerance and maximal number of iterations for the
root search algorithm, see <code>method</code> below and <code><a href="stats.html#topic+uniroot">uniroot</a></code>.</p>
</td></tr>
<tr><td><code id="pnorMix_+3A_tracerootsearch">traceRootsearch</code></td>
<td>
<p>logical or integer in <code class="reqn">\{0,1,2,3\}</code>,
determining the amount of information printed during root search.</p>
</td></tr>
<tr><td><code id="pnorMix_+3A_method">method</code></td>
<td>
<p>a string specifying which algorithm is used for the
&ldquo;root search&rdquo;.  Originally, the only method was a
variation of <code>"eachRoot"</code>, which is the default now when only
very few quantiles are sought.  For large <code><a href="#topic+m.norMix">m.norMix</a>()</code>,
the default is set to <code>"root2"</code>, currently.</p>
</td></tr>
<tr><td><code id="pnorMix_+3A_l.interp">l.interp</code></td>
<td>
<p>positive integer for <code>method = "interQpspline"</code>
or <code>"interpspline"</code>, determining the number of values in each
&ldquo;mu-interval&rdquo;.</p>
</td></tr>
<tr><td><code id="pnorMix_+3A_n.mu.interp">n.mu.interp</code></td>
<td>
<p>positive integer for <code>method = "interQpspline"</code>
or <code>"interpspline"</code>, determining the (maximal) number of
mu-values to be used as knots for inverse interpolation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whereas the distribution function <code>pnorMix</code> is the trivial sum of
weighted normal probabilities (<code><a href="stats.html#topic+pnorm">pnorm</a></code>), its inverse,
<code>qnorMix</code> is computed numerically: For each <code>p</code> we search for
<code>q</code> such that <code>pnorMix(obj, q) == p</code>, i.e., <code class="reqn">f(q) = 0</code>
for <code>f(q) := pnorMix(obj, q) - p</code>.  This is a root finding
problem which can be solved by <code><a href="stats.html#topic+uniroot">uniroot</a>(f, lower,upper,*)</code>.
If <code>length(p) &lt;= 2</code> or <code>method = "eachRoot"</code>, this happens
one for one for the <em>sorted</em> p's.  Otherwise, we start by doing
this for the outermost non-trivial (<code class="reqn">0 &lt; p &lt; 1</code>) values of p.
</p>


<p>For <code>method = "interQpspline"</code> or <code>"interpspline"</code>, we now compute
<code>p. &lt;- <a href="#topic+pnorMix">pnorMix</a>(q., obj)</code> for values <code>q.</code> which are a grid
of length <code>l.interp</code> in each interval <code class="reqn">[q_j,q_{j+1}]</code>, where
<code class="reqn">q_j</code> are the &ldquo;X-extremes&rdquo; plus (a sub sequence of length
<code>n.mu.interp</code> of) the ordered <code>mu[j]</code>'s.
Then, we use <em>montone</em> inverse interpolation
(<code><a href="stats.html#topic+splinefun">splinefun</a>(q., p., method="monoH.FC")</code>) plus
a few (maximally <code>maxiter</code>, typically one!) Newton steps.
The default, <code>"interQpspline"</code>, additionally logit-transforms the
<code>p.</code> values to make the interpolation more linear.
This method is faster, particularly for large <code>length(p)</code>.
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as <code>p</code> or <code>q</code>, respectively.
</p>


<h3>Author(s)</h3>

<p>Very first version (for length-1 <code>p,q</code>) by
Erik Jørgensen <a href="mailto:Erik.Jorgensen@agrsci.dk">Erik.Jorgensen@agrsci.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dnorMix">dnorMix</a></code> for the density function.</p>


<h3>Examples</h3>

<pre><code class='language-R'>MW.nm3 # the "strange skew" one
plot(MW.nm3)
## now the cumlative :
x &lt;- seq(-4,4, length.out = 1001)
plot(x, pnorMix(x, MW.nm3), type="l", col=2)
## and some of its inverse :
pp &lt;- seq(.1, .9, by=.1)
plot(qnorMix(pp, MW.nm3), pp)

## The "true" median of a normal mixture:
median.norMix &lt;- function(x) qnorMix(1/2, x)
median.norMix(MW.nm3) ## -2.32
</code></pre>

<hr>
<h2 id='r.norMix'>Ratio of Normal Mixture to Corresponding Normal</h2><span id='topic+r.norMix'></span>

<h3>Description</h3>

<p>Compute <code class="reqn">r(x) = f(x)/ f0(x)</code> where <code class="reqn">f()</code> is a normal mixture
density and <code class="reqn">f0</code> the normal density with the same mean and
variance as <code class="reqn">f</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r.norMix(obj, x = NULL, xlim = NULL, n = 511, xy.return = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r.norMix_+3A_obj">obj</code></td>
<td>
<p>an object of class <code>norMix</code>.</p>
</td></tr>
<tr><td><code id="r.norMix_+3A_x">x</code></td>
<td>
<p>numeric vector with abscissa values where to evaluate the
density. Default is constructed from <code>n</code> (and <code>xlim</code> if
specified).</p>
</td></tr>
<tr><td><code id="r.norMix_+3A_xlim">xlim</code></td>
<td>
<p>range of abscissa values, used if <code>x == NULL</code>.  By default,
xlim taken as mean plus/minus 3 standard deviations of the normal mixture.</p>
</td></tr>
<tr><td><code id="r.norMix_+3A_n">n</code></td>
<td>
<p>number of abscissa values to generate if <code>x</code> is not specified.</p>
</td></tr>
<tr><td><code id="r.norMix_+3A_xy.return">xy.return</code></td>
<td>
<p>logical indicating if the result should be a list or
just a numeric vector, see below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It depends on <code>xy.return</code>.  If it's false,  a numeric vector of
the same length as <code>x</code>, if true (as per default), a list that can
be plotted, with components
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>abscissa values corresponding to argument <code>x</code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>corresponding values <code class="reqn">r(x)</code>.</p>
</td></tr>
<tr><td><code>f0</code></td>
<td>
<p>values of the moment matching normal density <code class="reqn">f0(x)</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The ratio function is used in certain semi-parametric density
estimation methods (and theory).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  d3 &lt;- norMix(m = 5*(0:2), w = c(0.6, 0.3, 0.1))
  plot(d3)
  rd3 &lt;- r.norMix(d3)
  str(rd3)
  stopifnot(rd3 $ y  == r.norMix(d3, xy.ret = FALSE))
  par(new = TRUE)
  plot(rd3, type = "l", col = 3, axes = FALSE, xlab = "", ylab="")
  axis(4, col.axis=3)
</code></pre>

<hr>
<h2 id='rnorMix'>Generate 'Normal Mixture' Distributed Random Numbers</h2><span id='topic+rnorMix'></span>

<h3>Description</h3>

<p>Generate <code>n</code> random numbers, distributed according to a normal
mixture.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnorMix(n, obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnorMix_+3A_n">n</code></td>
<td>
<p>the number of random numbers desired.</p>
</td></tr>
<tr><td><code id="rnorMix_+3A_obj">obj</code></td>
<td>
<p>an object of class <code>norMix</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a mixture of <code class="reqn">m</code>, i.e., <code>m.norMix(obj)</code>, components,
generate the number in each component as multinomial, and then use
<code><a href="stats.html#topic+rnorm">rnorm</a></code> for each.
</p>
<p>Note that the these integer (multinomial) numbers are generated via <code><a href="base.html#topic+sample">sample</a>()</code>,
which is by <code><a href="base.html#topic+.Random.seed">.Random.seed</a></code>, notably from
<code><a href="base.html#topic+RNGkind">RNGkind</a>(sample.kind = ..)</code> which changed with <span class="rlang"><b>R</b></span> version 3.6.0.
</p>


<h3>Value</h3>

<p>numeric vector of length <code>n</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dnorMix">dnorMix</a></code> for the density, and <code><a href="#topic+norMix">norMix</a></code>
for the construction and further methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorMix(5000, MW.nm10)
hist(x)# you don't see the claw
plot(density(x), ylim = c(0,0.6),
     main = "Estim. and true 'MW.nm10' density")
lines(MW.nm10, col = "orange")
</code></pre>

<hr>
<h2 id='sort.norMix'>Sort Method for &quot;norMix&quot; Objects</h2><span id='topic+sort.norMix'></span>

<h3>Description</h3>

<p>Sorting a <code>"norMix"</code> object (see <code><a href="#topic+norMix">norMix</a></code>),
sorts along the <code>mu</code> values; i.e., for the
default <code>decreasing = FALSE</code> the resulting <code>x[,"mu"]</code> are
sorted from left to right.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'norMix'
sort(x, decreasing = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort.norMix_+3A_x">x</code></td>
<td>
<p>an object of class <code>"norMix"</code>.</p>
</td></tr>
<tr><td><code id="sort.norMix_+3A_decreasing">decreasing</code></td>
<td>
<p>logicial indicating if sorting should be up or down.</p>
</td></tr>
<tr><td><code id="sort.norMix_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="base.html#topic+sort">sort</a>(x[,"mu"],*)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>"norMix"</code> object like <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sort(MW.nm9)
stopifnot(identical(MW.nm2, sort(MW.nm2)))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
