<!DOCTYPE html><html lang="en"><head><title>Help for package fdacluster</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fdacluster}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fdacluster-package'><p>fdacluster: Joint Clustering and Alignment of Functional Data</p></a></li>
<li><a href='#autoplot.caps'><p>Visualizes the result of a clustering strategy stored in a <code>caps</code> object with</p>
ggplot2</a></li>
<li><a href='#autoplot.mcaps'><p>Visualizes results of multiple clustering strategies using ggplot2</p></a></li>
<li><a href='#caps'><p>Class for clustering with amplitude and phase separation</p></a></li>
<li><a href='#compare_caps'><p>Generates results of multiple clustering strategies</p></a></li>
<li><a href='#diagnostic_plot'><p>Diagnostic plot for the result of a clustering strategy stored in a <code>caps</code></p>
object</a></li>
<li><a href='#fdadbscan'><p>Performs density-based clustering for functional data with amplitude and</p>
phase separation</a></li>
<li><a href='#fdadist'><p>Computes the distance matrix for functional data with amplitude and phase</p>
separation</a></li>
<li><a href='#fdahclust'><p>Performs hierarchical clustering for functional data with amplitude and phase</p>
separation</a></li>
<li><a href='#fdakmeans'><p>Performs k-means clustering for functional data with amplitude and phase</p>
separation</a></li>
<li><a href='#lp'><p>Linear and integer programming</p></a></li>
<li><a href='#plot.caps'><p>Plots the result of a clustering strategy stored in a <code>caps</code> object</p></a></li>
<li><a href='#plot.mcaps'><p>Plots results of multiple clustering strategies</p></a></li>
<li><a href='#sim30_caps'><p>A <code>caps</code> object from simulated data for examples</p></a></li>
<li><a href='#sim30_mcaps'><p>An <code>mcaps</code> object from simulated data for examples</p></a></li>
<li><a href='#simulated30'><p>Simulated data for examples</p></a></li>
<li><a href='#simulated30_sub'><p>Simulated data for examples</p></a></li>
<li><a href='#simulated90'><p>Simulated data from the CSDA paper</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Joint Clustering and Alignment of Functional Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementations of the k-means, hierarchical agglomerative and 
    DBSCAN clustering methods for functional data which allows for jointly 
    aligning and clustering curves. It supports functional data defined on 
    one-dimensional domains but possibly evaluating in multivariate codomains. 
    It supports functional data defined in arrays but also via the 'fd' and 
    'funData' classes for functional data defined in the 'fda' and 'funData' 
    packages respectively. It currently supports shift, dilation and affine 
    warping functions for functional data defined on the real line and uses the 
    SRVF framework to handle boundary-preserving warping for functional data 
    defined on a specific interval. Main reference for the k-means algorithm: 
    Sangalli L.M., Secchi P., Vantini S., Vitelli V. (2010) "k-mean alignment 
    for curve clustering" &lt;<a href="https://doi.org/10.1016%2Fj.csda.2009.12.008">doi:10.1016/j.csda.2009.12.008</a>&gt;. Main reference for 
    the SRVF framework: Tucker, J. D., Wu, W., &amp; Srivastava, A. (2013) 
    "Generative models for functional data using phase and amplitude separation" 
    &lt;<a href="https://doi.org/10.1016%2Fj.csda.2012.12.001">doi:10.1016/j.csda.2012.12.001</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, nloptr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fda, funData, future, knitr, rmarkdown, testthat (&ge; 3.0.0),
withr</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, cluster, dbscan, fdasrvf, future.apply, ggplot2, lpSolve,
nloptr, progressr, Rcpp, rlang, tibble</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://astamm.github.io/fdacluster/">https://astamm.github.io/fdacluster/</a>,
<a href="https://github.com/astamm/fdacluster">https://github.com/astamm/fdacluster</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-14 15:17:40 UTC; stamm-a</td>
</tr>
<tr>
<td>Author:</td>
<td>Aymeric Stamm <a href="https://orcid.org/0000-0002-8725-3654"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Laura Sangalli [ctb],
  Piercesare Secchi [ctb],
  Simone Vantini [ctb],
  Valeria Vitelli [ctb],
  Alessandro Zito [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aymeric Stamm &lt;aymeric.stamm@cnrs.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-14 16:50:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='fdacluster-package'>fdacluster: Joint Clustering and Alignment of Functional Data</h2><span id='topic+fdacluster'></span><span id='topic+fdacluster-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Implementations of the k-means, hierarchical agglomerative and DBSCAN clustering methods for functional data which allows for jointly aligning and clustering curves. It supports functional data defined on one-dimensional domains but possibly evaluating in multivariate codomains. It supports functional data defined in arrays but also via the 'fd' and 'funData' classes for functional data defined in the 'fda' and 'funData' packages respectively. It currently supports shift, dilation and affine warping functions for functional data defined on the real line and uses the SRVF framework to handle boundary-preserving warping for functional data defined on a specific interval. Main reference for the k-means algorithm: Sangalli L.M., Secchi P., Vantini S., Vitelli V. (2010) &quot;k-mean alignment for curve clustering&quot; <a href="https://doi.org/10.1016/j.csda.2009.12.008">doi:10.1016/j.csda.2009.12.008</a>. Main reference for the SRVF framework: Tucker, J. D., Wu, W., &amp; Srivastava, A. (2013) &quot;Generative models for functional data using phase and amplitude separation&quot; <a href="https://doi.org/10.1016/j.csda.2012.12.001">doi:10.1016/j.csda.2012.12.001</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Aymeric Stamm <a href="mailto:aymeric.stamm@cnrs.fr">aymeric.stamm@cnrs.fr</a> (<a href="https://orcid.org/0000-0002-8725-3654">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Laura Sangalli <a href="mailto:laura.sangalli@polimi.it">laura.sangalli@polimi.it</a> [contributor]
</p>
</li>
<li><p> Piercesare Secchi <a href="mailto:piercesare.secchi@polimi.it">piercesare.secchi@polimi.it</a> [contributor]
</p>
</li>
<li><p> Simone Vantini <a href="mailto:simone.vantini@polimi.it">simone.vantini@polimi.it</a> [contributor]
</p>
</li>
<li><p> Valeria Vitelli <a href="mailto:valeria.vitelli@medisin.uio.no">valeria.vitelli@medisin.uio.no</a> [contributor]
</p>
</li>
<li><p> Alessandro Zito <a href="mailto:zito.ales@gmail.com">zito.ales@gmail.com</a> [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Arthur, D., and S. Vassilvitskii. 2007. “K-Means++ the Advantages
of Careful Seeding.” In Proceedings of the Eighteenth Annual ACM-SIAM
Symposium on Discrete Algorithms, 1027–35.
</p>
<p>Marron, J. S., J. O. Ramsay, L. M. Sangalli, and A. Srivastava.
2014. “Statistics of Time Warpings and Phase Variations.”
</p>
<p>Marron, J. S., J. O. Ramsay, L. M. Sangalli, and A. Srivastava.
2015. “Functional Data Analysis of Amplitude and Phase Variation.”
Statistical Science, 468–84.
</p>
<p>Ramsay, J., and B. W. Silverman. 2005. Functional Data Analysis.
Springer Series in Statistics. Springer.
</p>
<p>Sangalli, L. M., P. Secchi, S. Vantini, and V. Vitelli. 2010.
“K-Mean Alignment for Curve Clustering.” Computational Statistics &amp; Data
Analysis 54 (5): 1219–33.
</p>
<p>Tucker, J. D., W. Wu, and A. Srivastava. 2013. “Generative Models
for Functional Data Using Phase and Amplitude Separation.” Computational
Statistics &amp; Data Analysis 61: 50–66.
</p>
<p>Vantini, S. 2012. “On the Definition of Phase and Amplitude
Variability in Functional Data Analysis.” Test 21 (4): 676–96.
https://doi.org/10.1007/s11749-011-0268-9.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://astamm.github.io/fdacluster/">https://astamm.github.io/fdacluster/</a>
</p>
</li>
<li> <p><a href="https://github.com/astamm/fdacluster">https://github.com/astamm/fdacluster</a>
</p>
</li></ul>


<hr>
<h2 id='autoplot.caps'>Visualizes the result of a clustering strategy stored in a <code>caps</code> object with
ggplot2</h2><span id='topic+autoplot.caps'></span>

<h3>Description</h3>

<p>This function creates a visualization of the result of the k-mean alignment
algorithm and invisibly returns the corresponding <a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a> object
which enable further customization of the plot. The user can choose to
visualize either the amplitude information data in which case original and
aligned curves are shown or the phase information data in which case the
estimated warping functions are shown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'caps'
autoplot(object, type = c("amplitude", "phase"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot.caps_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+caps">caps</a></code>.</p>
</td></tr>
<tr><td><code id="autoplot.caps_+3A_type">type</code></td>
<td>
<p>A string specifying the type of information to display. Choices
are <code>"amplitude"</code> for plotting the original and aligned curves which
represent amplitude information data or <code>"phase"</code> for plotting the
corresponding warping functions which represent phase information data.
Defaults to <code>"amplitude"</code>.</p>
</td></tr>
<tr><td><code id="autoplot.caps_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a> object invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ggplot2::autoplot(sim30_caps, type = "amplitude")
ggplot2::autoplot(sim30_caps, type = "phase")

</code></pre>

<hr>
<h2 id='autoplot.mcaps'>Visualizes results of multiple clustering strategies using ggplot2</h2><span id='topic+autoplot.mcaps'></span>

<h3>Description</h3>

<p>This is an S3 method implementation of the <code><a href="ggplot2.html#topic+autoplot">ggplot2::autoplot()</a></code> generic
for objects of class <code>mcaps</code> to visualize the performances of multiple
<code><a href="#topic+caps">caps</a></code> objects applied on the same data sets either in terms of WSS or in
terms of silhouette values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcaps'
autoplot(
  object,
  validation_criterion = c("wss", "silhouette"),
  what = c("mean", "distribution"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot.mcaps_+3A_object">object</code></td>
<td>
<p>An object of class <code>mcaps</code>.</p>
</td></tr>
<tr><td><code id="autoplot.mcaps_+3A_validation_criterion">validation_criterion</code></td>
<td>
<p>A string specifying the validation criterion to
be used for the comparison. Choices are <code>"wss"</code> or <code>"silhouette"</code>. Defaults
to <code>"wss"</code>.</p>
</td></tr>
<tr><td><code id="autoplot.mcaps_+3A_what">what</code></td>
<td>
<p>A string specifying the kind of information to display about the
validation criterion. Choices are <code>"mean"</code> (which plots the mean values) or
<code>"distribution"</code> (which plots the boxplots). Defaults to <code>"mean"</code>.</p>
</td></tr>
<tr><td><code id="autoplot.mcaps_+3A_...">...</code></td>
<td>
<p>Other arguments passed to specific methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- ggplot2::autoplot(sim30_mcaps)

</code></pre>

<hr>
<h2 id='caps'>Class for clustering with amplitude and phase separation</h2><span id='topic+caps'></span><span id='topic+as_caps'></span><span id='topic+is_caps'></span>

<h3>Description</h3>

<p>The k-means algorithm with joint amplitude and phase separation produces a
number of outputs. This class is meant to encapsulate them into a single
object for providing dedicated <code>S3</code> methods for e.g. plotting, summarizing,
etc. The name of the class stems from <strong>C</strong>lustering with <strong>A</strong>mplitude and
<strong>P</strong>hase <strong>S</strong>eparation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_caps(x)

is_caps(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="caps_+3A_x">x</code></td>
<td>
<p>A list coercible into an object of class <code><a href="#topic+caps">caps</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code><a href="#topic+caps">caps</a></code> is a list with the following components:
</p>

<ul>
<li> <p><code>original_curves</code>: A numeric matrix of shape <code class="reqn">N \times L \times M</code>
storing a sample with the <code class="reqn">N</code> <code class="reqn">L</code>-dimensional original curves
observed on grids of size <code class="reqn">M</code>.
</p>
</li>
<li> <p><code>original_grids</code>: A numeric matrix of size <code class="reqn">N \times M</code> storing the
grids of size <code class="reqn">M</code> on which original curves are evaluated;
</p>
</li>
<li> <p><code>aligned_grids</code>: A numeric matrix of size <code class="reqn">N \times M</code> storing the
grids of size <code class="reqn">M</code> on which original curves must be evaluated to be
aligned;
</p>
</li>
<li> <p><code>center_curves</code>: A numeric matrix of shape <code class="reqn">K \times L \times M</code>
storing the <code class="reqn">K</code> centers which are <code class="reqn">L</code>-dimensional curves observed on
a grid of size <code class="reqn">M</code>;
</p>
</li>
<li> <p><code>center_grids</code>: A numeric matrix of size <code class="reqn">K \times M</code> storing the grids
of size <code class="reqn">M</code> on which center curves are evaluated;
</p>
</li>
<li> <p><code>warpings</code>: A numeric matrix of shape <code class="reqn">N \times M</code> storing the
estimated warping functions for each of the <code class="reqn">N</code> curves evaluated on the
within-cluster common <code>grids</code> of size <code class="reqn">M</code>;
</p>
</li>
<li> <p><code>n_clusters</code>: An integer value storing the number of clusters;
</p>
</li>
<li> <p><code>memberships</code>: An integer vector of length <code class="reqn">N</code> storing the cluster ID
which each curve belongs to;
</p>
</li>
<li> <p><code>distances_to_center</code>: A numeric vector of length <code class="reqn">N</code> storing the
distance of each curve to the center of its cluster;
</p>
</li>
<li> <p><code>silhouettes</code>: A numeric vector of length <code class="reqn">N</code> storing the silhouette
values of each observation;
</p>
</li>
<li> <p><code>amplitude_variation</code>: A numeric value storing the fraction of total
variation explained by amplitude variability.
</p>
</li>
<li> <p><code>total_variation</code>: A numeric value storing the amount of total variation.
</p>
</li>
<li> <p><code>n_iterations</code>: An integer value storing the number of iterations
performed until convergence;
</p>
</li>
<li> <p><code>call_name</code>: A string storing the name of the function that was used to
produce the k-means alignment results;
</p>
</li>
<li> <p><code>call_args</code>: A list containing the exact arguments that were passed to
the function <code>call_name</code> that produced this output.
</p>
</li></ul>



<h3>Value</h3>

<p>The function <code><a href="#topic+as_caps">as_caps()</a></code> returns an object of class <code><a href="#topic+caps">caps</a></code>. The
function <code><a href="#topic+is_caps">is_caps()</a></code> returns a boolean which evaluates to <code>TRUE</code> is the
input object is of class <code><a href="#topic+caps">caps</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_caps(sim30_caps)
is_caps(sim30_caps)
</code></pre>

<hr>
<h2 id='compare_caps'>Generates results of multiple clustering strategies</h2><span id='topic+compare_caps'></span>

<h3>Description</h3>

<p>This function searches for clusters in the input data set using different
strategies and generates an object of class <code>mcaps</code> which stores multiple
objects of class <code><a href="#topic+caps">caps</a></code>. This is a helper function to facilitate comparison
of clustering methods and choice of an <em>optimal</em> one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_caps(
  x,
  y,
  n_clusters = 1:5,
  is_domain_interval = FALSE,
  transformation = c("identity", "srvf"),
  metric = c("l2", "normalized_l2", "pearson"),
  clustering_method = c("kmeans", "hclust-complete", "hclust-average", "hclust-single",
    "dbscan"),
  warping_class = c("none", "shift", "dilation", "affine", "bpd"),
  centroid_type = c("mean", "medoid", "median", "lowess", "poly"),
  cluster_on_phase = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_caps_+3A_x">x</code></td>
<td>
<p>A numeric vector of length <code class="reqn">M</code> or a numeric matrix of shape
<code class="reqn">N \times M</code> or an object of class <code><a href="funData.html#topic+funData-class">funData::funData</a></code>. If a numeric
vector or matrix, it specifies the grid(s) of size <code class="reqn">M</code> on which each of
the <code class="reqn">N</code> curves have been observed. If an object of class
<code><a href="funData.html#topic+funData-class">funData::funData</a></code>, it contains the whole functional data set and the <code>y</code>
argument is not used.</p>
</td></tr>
<tr><td><code id="compare_caps_+3A_y">y</code></td>
<td>
<p>Either a numeric matrix of shape <code class="reqn">N \times M</code> or a numeric array
of shape <code class="reqn">N \times L \times M</code> or an object of class <code><a href="fda.html#topic+fd">fda::fd</a></code>. If a
numeric matrix or array, it specifies the <code class="reqn">N</code>-sample of
<code class="reqn">L</code>-dimensional curves observed on grids of size <code class="reqn">M</code>. If an object
of class <code><a href="fda.html#topic+fd">fda::fd</a></code>, it contains all the necessary information about the
functional data set to be able to evaluate it on user-defined grids.</p>
</td></tr>
<tr><td><code id="compare_caps_+3A_n_clusters">n_clusters</code></td>
<td>
<p>An integer vector specifying a set of clustering partitions
to create. Defaults to <code>1:5</code>.</p>
</td></tr>
<tr><td><code id="compare_caps_+3A_is_domain_interval">is_domain_interval</code></td>
<td>
<p>A boolean specifying whether the sample of curves
is defined on a fixed interval. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="compare_caps_+3A_transformation">transformation</code></td>
<td>
<p>A string specifying the transformation to apply to the
original sample of curves. Choices are no transformation (<code>transformation = "identity"</code>) or square-root velocity function <code>transformation = "srvf"</code>.
Defaults to <code>"identity"</code>.</p>
</td></tr>
<tr><td><code id="compare_caps_+3A_metric">metric</code></td>
<td>
<p>A string specifying the metric used to compare curves. Choices
are <code>"l2"</code>, <code>"normalized_l2"</code> or <code>"pearson"</code>. If <code>transformation == "srvf"</code>, the metric <strong>must be</strong> <code>"l2"</code> because the SRVF transform maps
absolutely continuous functions to square-integrable functions. If
<code>transformation == "identity"</code> and <code>warping_class</code> is either <code>dilation</code> or
<code>affine</code>, the metric cab be either <code>"normalized_l2"</code> or <code>"pearson"</code>. The L2
distance is indeed <strong>not</strong> dilation-invariant or affine-invariant. The
metric can also be <code>"l2"</code> if <code>warping_class == "shift"</code>. Defaults to
<code>"l2"</code>.</p>
</td></tr>
<tr><td><code id="compare_caps_+3A_clustering_method">clustering_method</code></td>
<td>
<p>A character vector specifying one or more clustering
methods to be fit. Choices are <code>"kmeans"</code>, <code>"hclust-complete"</code>,
<code>"hclust-average"</code>, <code>"hclust-single"</code> or <code>"dbscan"</code>. Defaults to all of
them.</p>
</td></tr>
<tr><td><code id="compare_caps_+3A_warping_class">warping_class</code></td>
<td>
<p>A character vector specifying one or more classes of
warping functions to use for curve alignment. Choices are <code>"affine"</code>,
<code>"dilation"</code>, <code>"none"</code>, <code>"shift"</code> or <code>"bpd"</code>. Defaults to all of them.</p>
</td></tr>
<tr><td><code id="compare_caps_+3A_centroid_type">centroid_type</code></td>
<td>
<p>A character vector specifying one or more ways to
compute centroids. Choices are <code>"mean"</code>, <code>"medoid"</code>, <code>"median"</code>, <code>"lowess"</code>
or <code>"poly"</code>. Defaults to all of them.</p>
</td></tr>
<tr><td><code id="compare_caps_+3A_cluster_on_phase">cluster_on_phase</code></td>
<td>
<p>A boolean specifying whether clustering should be
based on phase variation or amplitude variation. Defaults to <code>FALSE</code> which
implies amplitude variation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mcaps</code> which is a <code><a href="tibble.html#topic+tibble">tibble::tibble</a></code> storing the
objects of class <code><a href="#topic+caps">caps</a></code> in correspondence of each combination of possible
choices from the input arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#----------------------------------
# Compare k-means results with k = 1, 2, 3, 4, 5 using mean centroid and
# various warping classes.
## Not run: 
sim30_mcaps &lt;- compare_caps(
  x = simulated30_sub$x,
  y = simulated30_sub$y,
  warping_class = c("none", "shift", "dilation", "affine"),
  clustering_method = "kmeans",
  centroid_type = "mean"
)

## End(Not run)

#----------------------------------
# Then visualize the results
# Either with ggplot2 via ggplot2::autoplot(sim30_mcaps)
# or using graphics::plot()
# You can visualize the WSS values:
plot(sim30_mcaps, validation_criterion = "wss", what = "mean")
plot(sim30_mcaps, validation_criterion = "wss", what = "distribution")
# Or the average silhouette values:
plot(sim30_mcaps, validation_criterion = "silhouette", what = "mean")
plot(sim30_mcaps, validation_criterion = "silhouette", what = "distribution")
</code></pre>

<hr>
<h2 id='diagnostic_plot'>Diagnostic plot for the result of a clustering strategy stored in a <code>caps</code>
object</h2><span id='topic+diagnostic_plot'></span>

<h3>Description</h3>

<p>This function plots the values of the distance to center and silhouette for
each observation. Observations are ordered within cluster by decreasing value
of silhouette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnostic_plot(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diagnostic_plot_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+caps">caps</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>diagnostic_plot(sim30_caps)
</code></pre>

<hr>
<h2 id='fdadbscan'>Performs density-based clustering for functional data with amplitude and
phase separation</h2><span id='topic+fdadbscan'></span>

<h3>Description</h3>

<p>This function extends <code>DBSCAN</code> to functional data. It includes the
possibility to separate amplitude and phase information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdadbscan(
  x,
  y,
  is_domain_interval = FALSE,
  transformation = c("identity", "srvf"),
  warping_class = c("none", "shift", "dilation", "affine", "bpd"),
  centroid_type = "mean",
  metric = c("l2", "normalized_l2", "pearson"),
  cluster_on_phase = FALSE,
  use_verbose = FALSE,
  warping_options = c(0.15, 0.15),
  maximum_number_of_iterations = 100L,
  number_of_threads = 1L,
  parallel_method = 0L,
  distance_relative_tolerance = 0.001,
  use_fence = FALSE,
  check_total_dissimilarity = TRUE,
  compute_overall_center = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fdadbscan_+3A_x">x</code></td>
<td>
<p>A numeric vector of length <code class="reqn">M</code> or a numeric matrix of shape
<code class="reqn">N \times M</code> or an object of class <code><a href="funData.html#topic+funData-class">funData::funData</a></code>. If a numeric
vector or matrix, it specifies the grid(s) of size <code class="reqn">M</code> on which each of
the <code class="reqn">N</code> curves have been observed. If an object of class
<code><a href="funData.html#topic+funData-class">funData::funData</a></code>, it contains the whole functional data set and the <code>y</code>
argument is not used.</p>
</td></tr>
<tr><td><code id="fdadbscan_+3A_y">y</code></td>
<td>
<p>Either a numeric matrix of shape <code class="reqn">N \times M</code> or a numeric array
of shape <code class="reqn">N \times L \times M</code> or an object of class <code><a href="fda.html#topic+fd">fda::fd</a></code>. If a
numeric matrix or array, it specifies the <code class="reqn">N</code>-sample of
<code class="reqn">L</code>-dimensional curves observed on grids of size <code class="reqn">M</code>. If an object
of class <code><a href="fda.html#topic+fd">fda::fd</a></code>, it contains all the necessary information about the
functional data set to be able to evaluate it on user-defined grids.</p>
</td></tr>
<tr><td><code id="fdadbscan_+3A_is_domain_interval">is_domain_interval</code></td>
<td>
<p>A boolean specifying whether the sample of curves
is defined on a fixed interval. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fdadbscan_+3A_transformation">transformation</code></td>
<td>
<p>A string specifying the transformation to apply to the
original sample of curves. Choices are no transformation (<code>transformation = "identity"</code>) or square-root velocity function <code>transformation = "srvf"</code>.
Defaults to <code>"identity"</code>.</p>
</td></tr>
<tr><td><code id="fdadbscan_+3A_warping_class">warping_class</code></td>
<td>
<p>A string specifying the class of warping functions.
Choices are no warping (<code>warping_class = "none"</code>), shift <code>y = x + b</code>
(<code>warping_class = "shift"</code>), dilation <code>y = ax</code> (<code>warping_class = "dilation"</code>), affine <code>y = ax + b</code> (<code>warping_class = "affine"</code>) or
boundary-preserving diffeomorphism (<code>warping_class = "bpd"</code>). Defaults to
<code>"none"</code>.</p>
</td></tr>
<tr><td><code id="fdadbscan_+3A_centroid_type">centroid_type</code></td>
<td>
<p>A string specifying the type of centroid to compute.
Choices are <code>"mean"</code>, <code>"median"</code> <code>"medoid"</code>, <code>"lowess"</code> or <code>"poly"</code>.
Defaults to <code>"mean"</code>. If LOWESS appproximation is chosen, the user can
append an integer between 0 and 100 as in <code>"lowess20"</code>. This number will be
used as the smoother span. This gives the proportion of points in the plot
which influence the smooth at each value. Larger values give more
smoothness. The default value is 10%. If polynomial approximation is
chosen, the user can append an positive integer as in <code>"poly3"</code>. This
number will be used as the degree of the polynomial model. The default
value is <code>4L</code>.</p>
</td></tr>
<tr><td><code id="fdadbscan_+3A_metric">metric</code></td>
<td>
<p>A string specifying the metric used to compare curves. Choices
are <code>"l2"</code>, <code>"normalized_l2"</code> or <code>"pearson"</code>. If <code>transformation == "srvf"</code>, the metric <strong>must be</strong> <code>"l2"</code> because the SRVF transform maps
absolutely continuous functions to square-integrable functions. If
<code>transformation == "identity"</code> and <code>warping_class</code> is either <code>dilation</code> or
<code>affine</code>, the metric cab be either <code>"normalized_l2"</code> or <code>"pearson"</code>. The L2
distance is indeed <strong>not</strong> dilation-invariant or affine-invariant. The
metric can also be <code>"l2"</code> if <code>warping_class == "shift"</code>. Defaults to
<code>"l2"</code>.</p>
</td></tr>
<tr><td><code id="fdadbscan_+3A_cluster_on_phase">cluster_on_phase</code></td>
<td>
<p>A boolean specifying whether clustering should be
based on phase variation or amplitude variation. Defaults to <code>FALSE</code> which
implies amplitude variation.</p>
</td></tr>
<tr><td><code id="fdadbscan_+3A_use_verbose">use_verbose</code></td>
<td>
<p>A boolean specifying whether the algorithm should output
details of the steps to the console. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fdadbscan_+3A_warping_options">warping_options</code></td>
<td>
<p>A numeric vector supplied as a helper to the chosen
<code>warping_class</code> to decide on warping parameter bounds. This is used only
when <code>warping_class != "srvf"</code>.</p>
</td></tr>
<tr><td><code id="fdadbscan_+3A_maximum_number_of_iterations">maximum_number_of_iterations</code></td>
<td>
<p>An integer specifying the maximum number
of iterations before the algorithm stops if no other convergence criterion
was met. Defaults to <code>100L</code>.</p>
</td></tr>
<tr><td><code id="fdadbscan_+3A_number_of_threads">number_of_threads</code></td>
<td>
<p>An integer value specifying the number of threads
used for parallelization. Defaults to <code>1L</code>. This is used only when
<code>warping_class != "srvf"</code>.</p>
</td></tr>
<tr><td><code id="fdadbscan_+3A_parallel_method">parallel_method</code></td>
<td>
<p>An integer value specifying the type of desired
parallelization for template computation, If <code>0L</code>, templates are computed
in parallel. If <code>1L</code>, parallelization occurs within a single template
computation (only for the medoid method as of now). Defaults to <code>0L</code>. This
is used only when <code>warping_class != "srvf"</code>.</p>
</td></tr>
<tr><td><code id="fdadbscan_+3A_distance_relative_tolerance">distance_relative_tolerance</code></td>
<td>
<p>A numeric value specifying a relative
tolerance on the distance update between two iterations. If all
observations have not sufficiently improved in that sense, the algorithm
stops. Defaults to <code>1e-3</code>. This is used only when <code>warping_class != "srvf"</code>.</p>
</td></tr>
<tr><td><code id="fdadbscan_+3A_use_fence">use_fence</code></td>
<td>
<p>A boolean specifying whether the fence algorithm should be
used to robustify the algorithm against outliers. Defaults to <code>FALSE</code>. This
is used only when <code>warping_class != "srvf"</code>.</p>
</td></tr>
<tr><td><code id="fdadbscan_+3A_check_total_dissimilarity">check_total_dissimilarity</code></td>
<td>
<p>A boolean specifying whether an additional
stopping criterion based on improvement of the total dissimilarity should
be used. Defaults to <code>TRUE</code>. This is used only when <code>warping_class != "srvf"</code>.</p>
</td></tr>
<tr><td><code id="fdadbscan_+3A_compute_overall_center">compute_overall_center</code></td>
<td>
<p>A boolean specifying whether the overall center
should be also computed. Defaults to <code>FALSE</code>. This is used only when
<code>warping_class != "srvf"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+caps">caps</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#----------------------------------
# Extracts 15 out of the 30 simulated curves in `simulated30_sub` data set
idx &lt;- c(1:5, 11:15)
x &lt;- simulated30_sub$x[idx, ]
y &lt;- simulated30_sub$y[idx, , ]

#----------------------------------
# Runs an HAC with affine alignment, searching for 2 clusters
out &lt;- fdadbscan(
  x = x,
  y = y,
  warping_class = "affine",
  metric = "normalized_l2"
)

#----------------------------------
# Then visualize the results
# Either with ggplot2 via ggplot2::autoplot(out)
# or using graphics::plot()
# You can visualize the original and aligned curves with:
plot(out, type = "amplitude")
# Or the estimated warping functions with:
plot(out, type = "phase")
</code></pre>

<hr>
<h2 id='fdadist'>Computes the distance matrix for functional data with amplitude and phase
separation</h2><span id='topic+fdadist'></span>

<h3>Description</h3>

<p>This function computes the matrix of pairwise distances between curves a
functional data sample. This can be achieved with or without phase and
amplitude separation, which can be done using a variety of warping classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdadist(
  x,
  y = NULL,
  is_domain_interval = FALSE,
  transformation = c("identity", "srvf"),
  warping_class = c("none", "shift", "dilation", "affine", "bpd"),
  metric = c("l2", "normalized_l2", "pearson"),
  cluster_on_phase = FALSE,
  labels = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fdadist_+3A_x">x</code></td>
<td>
<p>A numeric vector of length <code class="reqn">M</code> or a numeric matrix of shape
<code class="reqn">N \times M</code> or an object of class <code><a href="funData.html#topic+funData-class">funData::funData</a></code>. If a numeric
vector or matrix, it specifies the grid(s) of size <code class="reqn">M</code> on which each of
the <code class="reqn">N</code> curves have been observed. If an object of class
<code><a href="funData.html#topic+funData-class">funData::funData</a></code>, it contains the whole functional data set and the <code>y</code>
argument is not used.</p>
</td></tr>
<tr><td><code id="fdadist_+3A_y">y</code></td>
<td>
<p>Either a numeric matrix of shape <code class="reqn">N \times M</code> or a numeric array
of shape <code class="reqn">N \times L \times M</code> or an object of class <code><a href="fda.html#topic+fd">fda::fd</a></code>. If a
numeric matrix or array, it specifies the <code class="reqn">N</code>-sample of
<code class="reqn">L</code>-dimensional curves observed on grids of size <code class="reqn">M</code>. If an object
of class <code><a href="fda.html#topic+fd">fda::fd</a></code>, it contains all the necessary information about the
functional data set to be able to evaluate it on user-defined grids.</p>
</td></tr>
<tr><td><code id="fdadist_+3A_is_domain_interval">is_domain_interval</code></td>
<td>
<p>A boolean specifying whether the sample of curves
is defined on a fixed interval. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fdadist_+3A_transformation">transformation</code></td>
<td>
<p>A string specifying the transformation to apply to the
original sample of curves. Choices are no transformation (<code>transformation = "identity"</code>) or square-root velocity function <code>transformation = "srvf"</code>.
Defaults to <code>"identity"</code>.</p>
</td></tr>
<tr><td><code id="fdadist_+3A_warping_class">warping_class</code></td>
<td>
<p>A string specifying the class of warping functions.
Choices are no warping (<code>warping_class = "none"</code>), shift <code>y = x + b</code>
(<code>warping_class = "shift"</code>), dilation <code>y = ax</code> (<code>warping_class = "dilation"</code>), affine <code>y = ax + b</code> (<code>warping_class = "affine"</code>) or
boundary-preserving diffeomorphism (<code>warping_class = "bpd"</code>). Defaults to
<code>"none"</code>.</p>
</td></tr>
<tr><td><code id="fdadist_+3A_metric">metric</code></td>
<td>
<p>A string specifying the metric used to compare curves. Choices
are <code>"l2"</code>, <code>"normalized_l2"</code> or <code>"pearson"</code>. If <code>transformation == "srvf"</code>, the metric <strong>must be</strong> <code>"l2"</code> because the SRVF transform maps
absolutely continuous functions to square-integrable functions. If
<code>transformation == "identity"</code> and <code>warping_class</code> is either <code>dilation</code> or
<code>affine</code>, the metric cab be either <code>"normalized_l2"</code> or <code>"pearson"</code>. The L2
distance is indeed <strong>not</strong> dilation-invariant or affine-invariant. The
metric can also be <code>"l2"</code> if <code>warping_class == "shift"</code>. Defaults to
<code>"l2"</code>.</p>
</td></tr>
<tr><td><code id="fdadist_+3A_cluster_on_phase">cluster_on_phase</code></td>
<td>
<p>A boolean specifying whether clustering should be
based on phase variation or amplitude variation. Defaults to <code>FALSE</code> which
implies amplitude variation.</p>
</td></tr>
<tr><td><code id="fdadist_+3A_labels">labels</code></td>
<td>
<p>A character vector specifying curve labels. Defaults to <code>NULL</code>
which uses sequential numbers as labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="stats.html#topic+dist">stats::dist</a> object storing the distance matrix between the input
curves using the metric specified through the argument <code>metric</code> and the
warping class specified by the argument <code>warping_class</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>idx &lt;- c(1:5, 11:15, 21:25)
D &lt;- fdadist(simulated30_sub$x[idx, ], simulated30_sub$y[idx, , ])
</code></pre>

<hr>
<h2 id='fdahclust'>Performs hierarchical clustering for functional data with amplitude and phase
separation</h2><span id='topic+fdahclust'></span>

<h3>Description</h3>

<p>This function extends hierarchical agglomerative clustering to functional
data. It includes the possibility to separate amplitude and phase
information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdahclust(
  x,
  y = NULL,
  n_clusters = 1L,
  is_domain_interval = FALSE,
  transformation = c("identity", "srvf"),
  warping_class = c("none", "shift", "dilation", "affine", "bpd"),
  centroid_type = "mean",
  metric = c("l2", "normalized_l2", "pearson"),
  cluster_on_phase = FALSE,
  linkage_criterion = c("complete", "average", "single", "ward.D2"),
  use_verbose = FALSE,
  warping_options = c(0.15, 0.15),
  maximum_number_of_iterations = 100L,
  number_of_threads = 1L,
  parallel_method = 0L,
  distance_relative_tolerance = 0.001,
  use_fence = FALSE,
  check_total_dissimilarity = TRUE,
  compute_overall_center = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fdahclust_+3A_x">x</code></td>
<td>
<p>A numeric vector of length <code class="reqn">M</code> or a numeric matrix of shape
<code class="reqn">N \times M</code> or an object of class <code><a href="funData.html#topic+funData-class">funData::funData</a></code>. If a numeric
vector or matrix, it specifies the grid(s) of size <code class="reqn">M</code> on which each of
the <code class="reqn">N</code> curves have been observed. If an object of class
<code><a href="funData.html#topic+funData-class">funData::funData</a></code>, it contains the whole functional data set and the <code>y</code>
argument is not used.</p>
</td></tr>
<tr><td><code id="fdahclust_+3A_y">y</code></td>
<td>
<p>Either a numeric matrix of shape <code class="reqn">N \times M</code> or a numeric array
of shape <code class="reqn">N \times L \times M</code> or an object of class <code><a href="fda.html#topic+fd">fda::fd</a></code>. If a
numeric matrix or array, it specifies the <code class="reqn">N</code>-sample of
<code class="reqn">L</code>-dimensional curves observed on grids of size <code class="reqn">M</code>. If an object
of class <code><a href="fda.html#topic+fd">fda::fd</a></code>, it contains all the necessary information about the
functional data set to be able to evaluate it on user-defined grids.</p>
</td></tr>
<tr><td><code id="fdahclust_+3A_n_clusters">n_clusters</code></td>
<td>
<p>An integer value specifying the number of clusters.
Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="fdahclust_+3A_is_domain_interval">is_domain_interval</code></td>
<td>
<p>A boolean specifying whether the sample of curves
is defined on a fixed interval. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fdahclust_+3A_transformation">transformation</code></td>
<td>
<p>A string specifying the transformation to apply to the
original sample of curves. Choices are no transformation (<code>transformation = "identity"</code>) or square-root velocity function <code>transformation = "srvf"</code>.
Defaults to <code>"identity"</code>.</p>
</td></tr>
<tr><td><code id="fdahclust_+3A_warping_class">warping_class</code></td>
<td>
<p>A string specifying the class of warping functions.
Choices are no warping (<code>warping_class = "none"</code>), shift <code>y = x + b</code>
(<code>warping_class = "shift"</code>), dilation <code>y = ax</code> (<code>warping_class = "dilation"</code>), affine <code>y = ax + b</code> (<code>warping_class = "affine"</code>) or
boundary-preserving diffeomorphism (<code>warping_class = "bpd"</code>). Defaults to
<code>"none"</code>.</p>
</td></tr>
<tr><td><code id="fdahclust_+3A_centroid_type">centroid_type</code></td>
<td>
<p>A string specifying the type of centroid to compute.
Choices are <code>"mean"</code>, <code>"median"</code> <code>"medoid"</code>, <code>"lowess"</code> or <code>"poly"</code>.
Defaults to <code>"mean"</code>. If LOWESS appproximation is chosen, the user can
append an integer between 0 and 100 as in <code>"lowess20"</code>. This number will be
used as the smoother span. This gives the proportion of points in the plot
which influence the smooth at each value. Larger values give more
smoothness. The default value is 10%. If polynomial approximation is
chosen, the user can append an positive integer as in <code>"poly3"</code>. This
number will be used as the degree of the polynomial model. The default
value is <code>4L</code>.</p>
</td></tr>
<tr><td><code id="fdahclust_+3A_metric">metric</code></td>
<td>
<p>A string specifying the metric used to compare curves. Choices
are <code>"l2"</code>, <code>"normalized_l2"</code> or <code>"pearson"</code>. If <code>transformation == "srvf"</code>, the metric <strong>must be</strong> <code>"l2"</code> because the SRVF transform maps
absolutely continuous functions to square-integrable functions. If
<code>transformation == "identity"</code> and <code>warping_class</code> is either <code>dilation</code> or
<code>affine</code>, the metric cab be either <code>"normalized_l2"</code> or <code>"pearson"</code>. The L2
distance is indeed <strong>not</strong> dilation-invariant or affine-invariant. The
metric can also be <code>"l2"</code> if <code>warping_class == "shift"</code>. Defaults to
<code>"l2"</code>.</p>
</td></tr>
<tr><td><code id="fdahclust_+3A_cluster_on_phase">cluster_on_phase</code></td>
<td>
<p>A boolean specifying whether clustering should be
based on phase variation or amplitude variation. Defaults to <code>FALSE</code> which
implies amplitude variation.</p>
</td></tr>
<tr><td><code id="fdahclust_+3A_linkage_criterion">linkage_criterion</code></td>
<td>
<p>A string specifying which linkage criterion should
be used to compute distances between sets of curves. Choices are
<code>"complete"</code> for complete linkage, <code>"average"</code> for average linkage and
<code>"single"</code> for single linkage. See <code><a href="stats.html#topic+hclust">stats::hclust()</a></code> for more details.
Defaults to <code>"complete"</code>.</p>
</td></tr>
<tr><td><code id="fdahclust_+3A_use_verbose">use_verbose</code></td>
<td>
<p>A boolean specifying whether the algorithm should output
details of the steps to the console. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fdahclust_+3A_warping_options">warping_options</code></td>
<td>
<p>A numeric vector supplied as a helper to the chosen
<code>warping_class</code> to decide on warping parameter bounds. This is used only
when <code>warping_class != "srvf"</code>.</p>
</td></tr>
<tr><td><code id="fdahclust_+3A_maximum_number_of_iterations">maximum_number_of_iterations</code></td>
<td>
<p>An integer specifying the maximum number
of iterations before the algorithm stops if no other convergence criterion
was met. Defaults to <code>100L</code>.</p>
</td></tr>
<tr><td><code id="fdahclust_+3A_number_of_threads">number_of_threads</code></td>
<td>
<p>An integer value specifying the number of threads
used for parallelization. Defaults to <code>1L</code>. This is used only when
<code>warping_class != "srvf"</code>.</p>
</td></tr>
<tr><td><code id="fdahclust_+3A_parallel_method">parallel_method</code></td>
<td>
<p>An integer value specifying the type of desired
parallelization for template computation, If <code>0L</code>, templates are computed
in parallel. If <code>1L</code>, parallelization occurs within a single template
computation (only for the medoid method as of now). Defaults to <code>0L</code>. This
is used only when <code>warping_class != "srvf"</code>.</p>
</td></tr>
<tr><td><code id="fdahclust_+3A_distance_relative_tolerance">distance_relative_tolerance</code></td>
<td>
<p>A numeric value specifying a relative
tolerance on the distance update between two iterations. If all
observations have not sufficiently improved in that sense, the algorithm
stops. Defaults to <code>1e-3</code>. This is used only when <code>warping_class != "srvf"</code>.</p>
</td></tr>
<tr><td><code id="fdahclust_+3A_use_fence">use_fence</code></td>
<td>
<p>A boolean specifying whether the fence algorithm should be
used to robustify the algorithm against outliers. Defaults to <code>FALSE</code>. This
is used only when <code>warping_class != "srvf"</code>.</p>
</td></tr>
<tr><td><code id="fdahclust_+3A_check_total_dissimilarity">check_total_dissimilarity</code></td>
<td>
<p>A boolean specifying whether an additional
stopping criterion based on improvement of the total dissimilarity should
be used. Defaults to <code>TRUE</code>. This is used only when <code>warping_class != "srvf"</code>.</p>
</td></tr>
<tr><td><code id="fdahclust_+3A_compute_overall_center">compute_overall_center</code></td>
<td>
<p>A boolean specifying whether the overall center
should be also computed. Defaults to <code>FALSE</code>. This is used only when
<code>warping_class != "srvf"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of clusters is required as input because, with functional data,
once hierarchical clustering is performed, curves within clusters need to be
aligned to their corresponding centroid.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+caps">caps</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#----------------------------------
# Extracts 15 out of the 30 simulated curves in `simulated30_sub` data set
idx &lt;- c(1:5, 11:15, 21:25)
x &lt;- simulated30_sub$x[idx, ]
y &lt;- simulated30_sub$y[idx, , ]

#----------------------------------
# Runs an HAC with affine alignment, searching for 2 clusters
out &lt;- fdahclust(
  x = x,
  y = y,
  n_clusters = 2,
  warping_class = "affine",
  metric = "normalized_l2"
)

#----------------------------------
# Then visualize the results
# Either with ggplot2 via ggplot2::autoplot(out)
# or using graphics::plot()
# You can visualize the original and aligned curves with:
plot(out, type = "amplitude")
# Or the estimated warping functions with:
plot(out, type = "phase")
</code></pre>

<hr>
<h2 id='fdakmeans'>Performs k-means clustering for functional data with amplitude and phase
separation</h2><span id='topic+fdakmeans'></span>

<h3>Description</h3>

<p>This function provides implementations of the k-means clustering algorithm
for functional data, with possible joint amplitude and phase separation. A
number of warping class are implemented to achieve this separation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdakmeans(
  x,
  y = NULL,
  n_clusters = 1L,
  seeds = NULL,
  seeding_strategy = c("kmeans++", "exhaustive-kmeans++", "exhaustive", "hclust"),
  is_domain_interval = FALSE,
  transformation = c("identity", "srvf"),
  warping_class = c("none", "shift", "dilation", "affine", "bpd"),
  centroid_type = "mean",
  metric = c("l2", "normalized_l2", "pearson"),
  cluster_on_phase = FALSE,
  use_verbose = FALSE,
  warping_options = c(0.15, 0.15),
  maximum_number_of_iterations = 100L,
  number_of_threads = 1L,
  parallel_method = 0L,
  distance_relative_tolerance = 0.001,
  use_fence = FALSE,
  check_total_dissimilarity = TRUE,
  compute_overall_center = FALSE,
  add_silhouettes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fdakmeans_+3A_x">x</code></td>
<td>
<p>A numeric vector of length <code class="reqn">M</code> or a numeric matrix of shape
<code class="reqn">N \times M</code> or an object of class <code><a href="funData.html#topic+funData-class">funData::funData</a></code>. If a numeric
vector or matrix, it specifies the grid(s) of size <code class="reqn">M</code> on which each of
the <code class="reqn">N</code> curves have been observed. If an object of class
<code><a href="funData.html#topic+funData-class">funData::funData</a></code>, it contains the whole functional data set and the <code>y</code>
argument is not used.</p>
</td></tr>
<tr><td><code id="fdakmeans_+3A_y">y</code></td>
<td>
<p>Either a numeric matrix of shape <code class="reqn">N \times M</code> or a numeric array
of shape <code class="reqn">N \times L \times M</code> or an object of class <code><a href="fda.html#topic+fd">fda::fd</a></code>. If a
numeric matrix or array, it specifies the <code class="reqn">N</code>-sample of
<code class="reqn">L</code>-dimensional curves observed on grids of size <code class="reqn">M</code>. If an object
of class <code><a href="fda.html#topic+fd">fda::fd</a></code>, it contains all the necessary information about the
functional data set to be able to evaluate it on user-defined grids.</p>
</td></tr>
<tr><td><code id="fdakmeans_+3A_n_clusters">n_clusters</code></td>
<td>
<p>An integer value specifying the number of clusters.
Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="fdakmeans_+3A_seeds">seeds</code></td>
<td>
<p>An integer value or vector specifying the indices of the initial
centroids. If an integer vector, it is interpreted as the indices of the
intial centroids and should therefore be of length <code>n_clusters</code>. If an
integer value, it is interpreted as the index of the first initial centroid
and subsequent centroids are chosen according to the k-means++ strategy. It
can be <code>NULL</code> in which case the argument <code>seeding_strategy</code> is used to
automatically provide suitable indices. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fdakmeans_+3A_seeding_strategy">seeding_strategy</code></td>
<td>
<p>A character string specifying the strategy for
choosing the initial centroids in case the argument <code>seeds</code> is set to
<code>NULL</code>. Choices are
<a href="https://en.wikipedia.org/wiki/K-means%2B%2B"><code>"kmeans++"</code></a>,
<code>"exhaustive-kmeans++"</code> which performs an exhaustive search over the choice
of the first centroid, <code>"exhaustive"</code> which tries on all combinations of
initial centroids or <code>"hclust"</code> which first performs hierarchical
clustering using Ward's linkage criterion to identify initial centroids.
Defaults to <code>"kmeans++"</code>, which is the fastest strategy.</p>
</td></tr>
<tr><td><code id="fdakmeans_+3A_is_domain_interval">is_domain_interval</code></td>
<td>
<p>A boolean specifying whether the sample of curves
is defined on a fixed interval. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fdakmeans_+3A_transformation">transformation</code></td>
<td>
<p>A string specifying the transformation to apply to the
original sample of curves. Choices are no transformation (<code>transformation = "identity"</code>) or square-root velocity function <code>transformation = "srvf"</code>.
Defaults to <code>"identity"</code>.</p>
</td></tr>
<tr><td><code id="fdakmeans_+3A_warping_class">warping_class</code></td>
<td>
<p>A string specifying the class of warping functions.
Choices are no warping (<code>warping_class = "none"</code>), shift <code>y = x + b</code>
(<code>warping_class = "shift"</code>), dilation <code>y = ax</code> (<code>warping_class = "dilation"</code>), affine <code>y = ax + b</code> (<code>warping_class = "affine"</code>) or
boundary-preserving diffeomorphism (<code>warping_class = "bpd"</code>). Defaults to
<code>"none"</code>.</p>
</td></tr>
<tr><td><code id="fdakmeans_+3A_centroid_type">centroid_type</code></td>
<td>
<p>A string specifying the type of centroid to compute.
Choices are <code>"mean"</code>, <code>"median"</code> <code>"medoid"</code>, <code>"lowess"</code> or <code>"poly"</code>.
Defaults to <code>"mean"</code>. If LOWESS appproximation is chosen, the user can
append an integer between 0 and 100 as in <code>"lowess20"</code>. This number will be
used as the smoother span. This gives the proportion of points in the plot
which influence the smooth at each value. Larger values give more
smoothness. The default value is 10%. If polynomial approximation is
chosen, the user can append an positive integer as in <code>"poly3"</code>. This
number will be used as the degree of the polynomial model. The default
value is <code>4L</code>.</p>
</td></tr>
<tr><td><code id="fdakmeans_+3A_metric">metric</code></td>
<td>
<p>A string specifying the metric used to compare curves. Choices
are <code>"l2"</code>, <code>"normalized_l2"</code> or <code>"pearson"</code>. If <code>transformation == "srvf"</code>, the metric <strong>must be</strong> <code>"l2"</code> because the SRVF transform maps
absolutely continuous functions to square-integrable functions. If
<code>transformation == "identity"</code> and <code>warping_class</code> is either <code>dilation</code> or
<code>affine</code>, the metric cab be either <code>"normalized_l2"</code> or <code>"pearson"</code>. The L2
distance is indeed <strong>not</strong> dilation-invariant or affine-invariant. The
metric can also be <code>"l2"</code> if <code>warping_class == "shift"</code>. Defaults to
<code>"l2"</code>.</p>
</td></tr>
<tr><td><code id="fdakmeans_+3A_cluster_on_phase">cluster_on_phase</code></td>
<td>
<p>A boolean specifying whether clustering should be
based on phase variation or amplitude variation. Defaults to <code>FALSE</code> which
implies amplitude variation.</p>
</td></tr>
<tr><td><code id="fdakmeans_+3A_use_verbose">use_verbose</code></td>
<td>
<p>A boolean specifying whether the algorithm should output
details of the steps to the console. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fdakmeans_+3A_warping_options">warping_options</code></td>
<td>
<p>A numeric vector supplied as a helper to the chosen
<code>warping_class</code> to decide on warping parameter bounds. This is used only
when <code>warping_class != "srvf"</code>.</p>
</td></tr>
<tr><td><code id="fdakmeans_+3A_maximum_number_of_iterations">maximum_number_of_iterations</code></td>
<td>
<p>An integer specifying the maximum number
of iterations before the algorithm stops if no other convergence criterion
was met. Defaults to <code>100L</code>.</p>
</td></tr>
<tr><td><code id="fdakmeans_+3A_number_of_threads">number_of_threads</code></td>
<td>
<p>An integer value specifying the number of threads
used for parallelization. Defaults to <code>1L</code>. This is used only when
<code>warping_class != "srvf"</code>.</p>
</td></tr>
<tr><td><code id="fdakmeans_+3A_parallel_method">parallel_method</code></td>
<td>
<p>An integer value specifying the type of desired
parallelization for template computation, If <code>0L</code>, templates are computed
in parallel. If <code>1L</code>, parallelization occurs within a single template
computation (only for the medoid method as of now). Defaults to <code>0L</code>. This
is used only when <code>warping_class != "srvf"</code>.</p>
</td></tr>
<tr><td><code id="fdakmeans_+3A_distance_relative_tolerance">distance_relative_tolerance</code></td>
<td>
<p>A numeric value specifying a relative
tolerance on the distance update between two iterations. If all
observations have not sufficiently improved in that sense, the algorithm
stops. Defaults to <code>1e-3</code>. This is used only when <code>warping_class != "srvf"</code>.</p>
</td></tr>
<tr><td><code id="fdakmeans_+3A_use_fence">use_fence</code></td>
<td>
<p>A boolean specifying whether the fence algorithm should be
used to robustify the algorithm against outliers. Defaults to <code>FALSE</code>. This
is used only when <code>warping_class != "srvf"</code>.</p>
</td></tr>
<tr><td><code id="fdakmeans_+3A_check_total_dissimilarity">check_total_dissimilarity</code></td>
<td>
<p>A boolean specifying whether an additional
stopping criterion based on improvement of the total dissimilarity should
be used. Defaults to <code>TRUE</code>. This is used only when <code>warping_class != "srvf"</code>.</p>
</td></tr>
<tr><td><code id="fdakmeans_+3A_compute_overall_center">compute_overall_center</code></td>
<td>
<p>A boolean specifying whether the overall center
should be also computed. Defaults to <code>FALSE</code>. This is used only when
<code>warping_class != "srvf"</code>.</p>
</td></tr>
<tr><td><code id="fdakmeans_+3A_add_silhouettes">add_silhouettes</code></td>
<td>
<p>A boolean specifying whether silhouette values should
be computed for each observation for internal validation of the clustering
structure. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+caps">caps</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#----------------------------------
# Extracts 15 out of the 30 simulated curves in `simulated30_sub` data set
idx &lt;- c(1:5, 11:15, 21:25)
x &lt;- simulated30_sub$x[idx, ]
y &lt;- simulated30_sub$y[idx, , ]

#----------------------------------
# Runs a k-means clustering with affine alignment, searching for 2 clusters
out &lt;- fdakmeans(
  x = x,
  y = y,
  n_clusters = 2,
  warping_class = "affine",
  metric = "normalized_l2"
)

#----------------------------------
# Then visualize the results
# Either with ggplot2 via ggplot2::autoplot(out)
# or using graphics::plot()
# You can visualize the original and aligned curves with:
plot(out, type = "amplitude")
# Or the estimated warping functions with:
plot(out, type = "phase")
</code></pre>

<hr>
<h2 id='lp'>Linear and integer programming</h2><span id='topic+lp'></span>

<h3>Description</h3>

<p>Interface to <code>lp_solve</code> linear/integer programming system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lp(
  direction = "min",
  objective.in,
  const.mat,
  const.dir,
  const.rhs,
  transpose.constraints = TRUE,
  int.vec,
  presolve = 0,
  compute.sens = 0,
  binary.vec,
  all.int = FALSE,
  all.bin = FALSE,
  scale = 196,
  dense.const,
  num.bin.solns = 1,
  use.rw = FALSE,
  timeout = 0L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lp_+3A_direction">direction</code></td>
<td>
<p>Character string giving direction of optimization:
&quot;min&quot; (default) or &quot;max.&quot;</p>
</td></tr>
<tr><td><code id="lp_+3A_objective.in">objective.in</code></td>
<td>
<p>Numeric vector of coefficients of objective function</p>
</td></tr>
<tr><td><code id="lp_+3A_const.mat">const.mat</code></td>
<td>
<p>Matrix of numeric constraint coefficients, one row 
per constraint, one column per variable (unless transpose.constraints = 
FALSE; see below).</p>
</td></tr>
<tr><td><code id="lp_+3A_const.dir">const.dir</code></td>
<td>
<p>Vector of character strings giving the direction of 
the constraint: each value should be one of &quot;&lt;,&quot; &quot;&lt;=,&quot; &quot;=,&quot; &quot;==,&quot; &quot;&gt;,&quot; or &quot;&gt;=&quot;.
(In each pair the two values are identical.)</p>
</td></tr>
<tr><td><code id="lp_+3A_const.rhs">const.rhs</code></td>
<td>
<p>Vector of numeric values for the right-hand sides of 
the constraints.</p>
</td></tr>
<tr><td><code id="lp_+3A_transpose.constraints">transpose.constraints</code></td>
<td>
<p>By default each constraint occupies a row 
of const.mat, and that matrix needs to be transposed before being passed 
to the optimizing code.  For very large constraint matrices it may be wiser 
to construct the constraints in a matrix column-by-column. In that case set 
transpose.constraints to FALSE.</p>
</td></tr>
<tr><td><code id="lp_+3A_int.vec">int.vec</code></td>
<td>
<p>Numeric vector giving the indices of variables that are 
required to be integer. The length of this vector will therefore be the 
number of integer variables.</p>
</td></tr>
<tr><td><code id="lp_+3A_presolve">presolve</code></td>
<td>
<p>Numeric: presolve? Default 0 (no); any
non-zero value means &quot;yes.&quot; Currently ignored.</p>
</td></tr>
<tr><td><code id="lp_+3A_compute.sens">compute.sens</code></td>
<td>
<p>Numeric: compute sensitivity? Default 0 (no); any
non-zero value means &quot;yes.&quot;</p>
</td></tr>
<tr><td><code id="lp_+3A_binary.vec">binary.vec</code></td>
<td>
<p>Numeric vector like int.vec giving the indices of variables 
that are required to be binary.</p>
</td></tr>
<tr><td><code id="lp_+3A_all.int">all.int</code></td>
<td>
<p>Logical: should all variables be integer? Default: FALSE.</p>
</td></tr>
<tr><td><code id="lp_+3A_all.bin">all.bin</code></td>
<td>
<p>Logical: should all variables be binary? Default: FALSE.</p>
</td></tr>
<tr><td><code id="lp_+3A_scale">scale</code></td>
<td>
<p>Integer: value for lpSolve scaling. Details can be found in
the lpSolve documentation. Set to 0 for no scaling. Default: 196</p>
</td></tr>
<tr><td><code id="lp_+3A_dense.const">dense.const</code></td>
<td>
<p>Three column dense constraint array. This is ignored if
const.mat is supplied. Otherwise the columns are constraint number, column
number, and value; there should be one row for each non-zero entry in the
constraint matrix.</p>
</td></tr>
<tr><td><code id="lp_+3A_num.bin.solns">num.bin.solns</code></td>
<td>
<p>Integer: if all.bin=TRUE, the user can request up to
num.bin.solns optimal solutions to be returned.</p>
</td></tr>
<tr><td><code id="lp_+3A_use.rw">use.rw</code></td>
<td>
<p>Logical: if TRUE and num.bin.solns &gt; 1, write the lp out to a
file and read it back in for each solution after the first. This is just to
defeat a bug somewhere. Although the default is FALSE, we recommend you set
this to TRUE if you need num.bin.solns &gt; 1, until the bug is found.</p>
</td></tr>
<tr><td><code id="lp_+3A_timeout">timeout</code></td>
<td>
<p>Integer: timeout variable in seconds, defaults to 0L which means
no limit is set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls the <code>lp_solve</code> 5.5 solver. That system has many options
not supported here. The current version is maintained at
https://lpsolve.sourceforge.net/5.5/.
</p>
<p>Note that every variable is assumed to be &gt;= 0!
</p>


<h3>Value</h3>

<p>An <a href="lpSolve.html#topic+lp.object">lpSolve::lp.object</a> object.
</p>

<hr>
<h2 id='plot.caps'>Plots the result of a clustering strategy stored in a <code>caps</code> object</h2><span id='topic+plot.caps'></span>

<h3>Description</h3>

<p>This function creates a visualization of the result of the k-mean alignment
algorithm <strong>without</strong> returning the plot data as an object. The user can
choose to visualize either the amplitude information data in which case
original and aligned curves are shown or the phase information data in which
case the estimated warping functions are shown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'caps'
plot(x, type = c("amplitude", "phase"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.caps_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+caps">caps</a></code>.</p>
</td></tr>
<tr><td><code id="plot.caps_+3A_type">type</code></td>
<td>
<p>A string specifying the type of information to display. Choices
are <code>"amplitude"</code> for plotting the original and aligned curves which
represent amplitude information data or <code>"phase"</code> for plotting the
corresponding warping functions which represent phase information data.
Defaults to <code>"amplitude"</code>.</p>
</td></tr>
<tr><td><code id="plot.caps_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plot(sim30_caps, type = "amplitude")
plot(sim30_caps, type = "phase")
</code></pre>

<hr>
<h2 id='plot.mcaps'>Plots results of multiple clustering strategies</h2><span id='topic+plot.mcaps'></span>

<h3>Description</h3>

<p>This is an S3 method implementation of the <code><a href="graphics.html#topic+plot.default">graphics::plot()</a></code> generic for
objects of class <code>mcaps</code> to visualize the performances of multiple <code><a href="#topic+caps">caps</a></code>
objects applied on the same data sets either in terms of WSS or in terms of
silhouette values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcaps'
plot(
  x,
  validation_criterion = c("wss", "silhouette"),
  what = c("mean", "distribution"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mcaps_+3A_x">x</code></td>
<td>
<p>An object of class <code>mcaps</code>.</p>
</td></tr>
<tr><td><code id="plot.mcaps_+3A_validation_criterion">validation_criterion</code></td>
<td>
<p>A string specifying the validation criterion to
be used for the comparison. Choices are <code>"wss"</code> or <code>"silhouette"</code>. Defaults
to <code>"wss"</code>.</p>
</td></tr>
<tr><td><code id="plot.mcaps_+3A_what">what</code></td>
<td>
<p>A string specifying the kind of information to display about the
validation criterion. Choices are <code>"mean"</code> (which plots the mean values) or
<code>"distribution"</code> (which plots the boxplots). Defaults to <code>"mean"</code>.</p>
</td></tr>
<tr><td><code id="plot.mcaps_+3A_...">...</code></td>
<td>
<p>Other arguments passed to specific methods.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plot(sim30_mcaps)
</code></pre>

<hr>
<h2 id='sim30_caps'>A <code>caps</code> object from simulated data for examples</h2><span id='topic+sim30_caps'></span>

<h3>Description</h3>

<p>An object of class <code><a href="#topic+caps">caps</a></code> storing the result of the <code><a href="#topic+fdakmeans">fdakmeans()</a></code>
function applied on the data set <code><a href="#topic+simulated30">simulated30</a></code> using the affine warping
class and the Pearson metric and searching for 2 clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim30_caps
</code></pre>


<h3>Format</h3>

<p>An object of class <code><a href="#topic+caps">caps</a></code>.
</p>

<hr>
<h2 id='sim30_mcaps'>An <code>mcaps</code> object from simulated data for examples</h2><span id='topic+sim30_mcaps'></span>

<h3>Description</h3>

<p>An object of class <code>mcaps</code> storing the result of the <code><a href="#topic+compare_caps">compare_caps()</a></code>
function applied on the data set <code><a href="#topic+simulated30_sub">simulated30_sub</a></code> for comparing the
clustering structures found by the <code><a href="#topic+fdakmeans">fdakmeans()</a></code> function with <code>mean</code>
centroid type used with various classes of warping functions and varying
number of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim30_mcaps
</code></pre>


<h3>Format</h3>

<p>An object of class <code>mcaps</code> which is effectively a <a href="tibble.html#topic+tibble">tibble::tibble</a>
with 5 columns and as many rows as there are clustering strategies to
compare. The 5 column-variables are:
</p>

<ul>
<li> <p><code>n_clusters</code>: The number of clusters;
</p>
</li>
<li> <p><code>clustering_method</code>: The clustering method;
</p>
</li>
<li> <p><code>warping_class</code>: The class of warping functions used for curve alignment;
</p>
</li>
<li> <p><code>centroid_type</code>: The type of centroid used to compute a cluster
representative;
</p>
</li>
<li> <p><code>caps_obj</code>: The result of the corresponding clustering strategy as
objects of class <code><a href="#topic+caps">caps</a></code>.
</p>
</li></ul>


<hr>
<h2 id='simulated30'>Simulated data for examples</h2><span id='topic+simulated30'></span>

<h3>Description</h3>

<p>A data set containing 30 simulated uni-dimensional curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulated30
</code></pre>


<h3>Format</h3>

<p>A list with abscissas x and values y:
</p>

<dl>
<dt>x</dt><dd><p>Matrix 30x200;</p>
</dd>
<dt>y</dt><dd><p>Array 30x1x200.</p>
</dd>
</dl>


<hr>
<h2 id='simulated30_sub'>Simulated data for examples</h2><span id='topic+simulated30_sub'></span>

<h3>Description</h3>

<p>A data set containing 30 simulated uni-dimensional curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulated30_sub
</code></pre>


<h3>Format</h3>

<p>A list with abscissas x and values y:
</p>

<dl>
<dt>x</dt><dd><p>Matrix 30x30;</p>
</dd>
<dt>y</dt><dd><p>Array 30x1x30.</p>
</dd>
</dl>


<hr>
<h2 id='simulated90'>Simulated data from the CSDA paper</h2><span id='topic+simulated90'></span>

<h3>Description</h3>

<p>A data set containing 90 simulated uni-dimensional curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulated90
</code></pre>


<h3>Format</h3>

<p>A list with abscissas x and values y:
</p>

<dl>
<dt>x</dt><dd><p>Vector of size 100;</p>
</dd>
<dt>y</dt><dd><p>Matrix if size 90x100.</p>
</dd>
</dl>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
