<!DOCTYPE html><html><head><title>Help for package frechet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {frechet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#frechet'><p>frechet: Statistical Analysis for Random Objects and Non-Euclidean Data</p></a></li>
<li><a href='#color.bar'><p>Generate color bar/scale.</p></a></li>
<li><a href='#CovFIntegral'><p>Generalized Fréchet integrals of covariance matrix</p></a></li>
<li><a href='#CovFMean'><p>Fréchet mean of covariance matrices</p></a></li>
<li><a href='#CreateCovRegPlot'><p>Plots for Fréchet regression for covariance matrices.</p></a></li>
<li><a href='#CreateDensity'><p>Create density functions from raw data, histogram objects or frequency tables with bins</p></a></li>
<li><a href='#DenANOVA'><p>Fréchet ANOVA for Densities</p></a></li>
<li><a href='#DenCPD'><p>Fréchet Change Point Detection for Densities</p></a></li>
<li><a href='#DenFMean'><p>Fréchet means of densities.</p></a></li>
<li><a href='#DenFVar'><p>Fréchet Variance for Densities</p></a></li>
<li><a href='#dist4cov'><p>Distance between covariance matrices</p></a></li>
<li><a href='#dist4den'><p><code class="reqn">L^2</code> Wasserstein distance between two distributions.</p></a></li>
<li><a href='#expSphere'><p>Compute an exponential map for a unit hypersphere.</p></a></li>
<li><a href='#frameSphere'><p>Generate a &quot;natural&quot; frame (orthonormal basis)</p></a></li>
<li><a href='#GloCorReg'><p>Global Fréchet regression for correlation matrices</p></a></li>
<li><a href='#GloCovReg'><p>Global Fréchet regression of covariance matrices</p></a></li>
<li><a href='#GloDenReg'><p>Global density regression.</p></a></li>
<li><a href='#GloPointPrReg'><p>Global Cox point process regression.</p></a></li>
<li><a href='#GloSpheReg'><p>Global Fréchet Regression for Spherical Data</p></a></li>
<li><a href='#LocCorReg'><p>Local Fréchet regression for correlation matrices</p></a></li>
<li><a href='#LocCovReg'><p>Local Fréchet regression of covariance matrices</p></a></li>
<li><a href='#LocDenReg'><p>Local density regression.</p></a></li>
<li><a href='#LocPointPrReg'><p>Local Cox point process regression.</p></a></li>
<li><a href='#LocSpheReg'><p>Local Fréchet Regression for Spherical Data</p></a></li>
<li><a href='#logSphere'><p>Compute a log map for a unit hypersphere.</p></a></li>
<li><a href='#NetANOVA'><p>Fréchet ANOVA for Networks</p></a></li>
<li><a href='#NetCPD'><p>Fréchet Change Point Detection for Networks</p></a></li>
<li><a href='#NetFIntegral'><p>Generalized Fréchet integrals of network</p></a></li>
<li><a href='#NetFVar'><p>Fréchet Variance for Networks</p></a></li>
<li><a href='#ObjCov'><p>Object Covariance</p></a></li>
<li><a href='#plot.denReg'><p>Plots for Fréchet regression for univariate densities.</p></a></li>
<li><a href='#pol2car'><p>Transform polar to Cartesian coordinates</p></a></li>
<li><a href='#SpheGeoDist'><p>Geodesic distance on spheres.</p></a></li>
<li><a href='#SpheGeoGrad'><p>Compute gradient w.r.t. y of the geodesic distance <code class="reqn">\arccos(x^\top y)</code> on a unit hypersphere</p></a></li>
<li><a href='#SpheGeoHess'><p>Hessian <code class="reqn">\partial^2/\partial y \partial y^\top</code> of the geodesic distance <code class="reqn">\arccos(x^\top y)</code> on a unit hypersphere</p></a></li>
<li><a href='#VarObj'><p>Fréchet Variance Trajectory for densities</p></a></li>
<li><a href='#WassFIntegral'><p>Generalized Fréchet integrals of 1D distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Analysis for Random Objects and Non-Euclidean Data</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/functionaldata/tFrechet">https://github.com/functionaldata/tFrechet</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/functionaldata/tFrechet/issues">https://github.com/functionaldata/tFrechet/issues</a></td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-07</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yaqing Chen &lt;yqchen@stat.rutgers.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides implementation of statistical methods for random objects 
    lying in various metric spaces, which are not necessarily linear spaces. 
    The core of this package is Fréchet regression for random objects with 
    Euclidean predictors, which allows one to perform regression analysis 
    for non-Euclidean responses under some mild conditions. 
    Examples include distributions in 2-Wasserstein space, 
    covariance matrices endowed with power metric (with Frobenius metric 
    as a special case), Cholesky and log-Cholesky metrics, spherical data.  
    References: Petersen, A., &amp; Müller, H.-G. (2019) &lt;<a href="https://doi.org/10.1214%2F17-AOS1624">doi:10.1214/17-AOS1624</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>false</td>
</tr>
<tr>
<td>Imports:</td>
<td>boot, corrplot, e1071, fdadensity, fdapace (&ge; 0.5.5), Matrix,
methods, pracma, quadprog, osqp, stats, trust, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Rcpp (&ge; 0.11.5), testthat, igraph, mpoly, truncnorm</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-09 02:17:29 UTC; ychen</td>
</tr>
<tr>
<td>Author:</td>
<td>Yaqing Chen [aut, cre],
  Yidong Zhou [aut],
  Han Chen [aut],
  Alvaro Gajardo [aut],
  Jianing Fan [aut],
  Qixian Zhong [aut],
  Paromita Dubey [aut],
  Kyunghee Han [aut],
  Satarupa Bhattacharjee [aut],
  Changbo Zhu [ctb],
  Su I Iao [ctb],
  Poorbita Kundu [ctb],
  Petersen Alexander [aut],
  Hans-Georg Müller [cph, ths, aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-09 15:50:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='frechet'>frechet: Statistical Analysis for Random Objects and Non-Euclidean Data</h2><span id='topic+frechet'></span><span id='topic+frechet-package'></span>

<h3>Description</h3>

<p>Provides implementation of statistical methods for random objects 
lying in various metric spaces, which are not necessarily linear spaces. 
The core of this package is Fréchet regression for random objects with 
Euclidean predictors, which allows one to perform regression analysis 
for non-Euclidean responses under some mild conditions. 
Examples include distributions in 2-Wasserstein space, 
covariance matrices endowed with power metric (with Frobenius metric as a special case), Cholesky and log-Cholesky metrics.  
References: Petersen, A., &amp; Müller, H.-G. (2019) &lt;doi:10.1214/17-AOS1624&gt;.
</p>

<hr>
<h2 id='color.bar'>Generate color bar/scale.</h2><span id='topic+color.bar'></span>

<h3>Description</h3>

<p>Generate color bar/scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>color.bar(
  colVal = NULL,
  colBreaks = NULL,
  min = NULL,
  max = NULL,
  lut = NULL,
  nticks = 5,
  ticks = NULL,
  title = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="color.bar_+3A_colval">colVal</code></td>
<td>
<p>A numeric vector giving the variable values to which each color is corresponding. It overrides <code>min</code> (and <code>max</code>) if <code>min &gt; min(colVal)</code> (<code>max &lt; max(colVal)</code>).</p>
</td></tr>
<tr><td><code id="color.bar_+3A_colbreaks">colBreaks</code></td>
<td>
<p>A numeric vector giving the breaks dividing the range of variable into different colors. It overrides <code>min</code> and <code>max</code>.</p>
</td></tr>
<tr><td><code id="color.bar_+3A_min">min</code></td>
<td>
<p>A scalar giving the minimum value of the variable represented by colors.</p>
</td></tr>
<tr><td><code id="color.bar_+3A_max">max</code></td>
<td>
<p>A scalar giving the maximum value of the variable represented by colors.</p>
</td></tr>
<tr><td><code id="color.bar_+3A_lut">lut</code></td>
<td>
<p>Color vector. Default is <br />
<code>colorRampPalette(colors = c("pink","royalblue"))(length(colBreaks)-1)</code>.</p>
</td></tr>
<tr><td><code id="color.bar_+3A_nticks">nticks</code></td>
<td>
<p>An integer giving the number of ticks used in the axis of color bar.</p>
</td></tr>
<tr><td><code id="color.bar_+3A_ticks">ticks</code></td>
<td>
<p>A numeric vector giving the locations of ticks used in the axis of color bar; it overrides <code>nticks</code>.</p>
</td></tr>
<tr><td><code id="color.bar_+3A_title">title</code></td>
<td>
<p>A character giving the label of the variable according to which the color bar is generated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='CovFIntegral'>Generalized Fréchet integrals of covariance matrix</h2><span id='topic+CovFIntegral'></span>

<h3>Description</h3>

<p>Calculating generalized Fréchet integrals of covariance (equipped with Frobenius norm)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CovFIntegral(phi, t_out, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovFIntegral_+3A_phi">phi</code></td>
<td>
<p>An eigenfunction along which we want to project the network</p>
</td></tr>
<tr><td><code id="CovFIntegral_+3A_t_out">t_out</code></td>
<td>
<p>Support of <code>phi</code></p>
</td></tr>
<tr><td><code id="CovFIntegral_+3A_x">X</code></td>
<td>
<p>A three dimensional array of dimension <code>length(t_out) x m x m</code>, where <code>X[i,,]</code> is an m x m covariance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the following:
</p>
<table>
<tr><td><code>f</code></td>
<td>
<p>An adjacency matrix which corresponds to the Fréchet integral of <code>X</code> along <code>phi</code></p>
</td></tr>
</table>


<h3>References</h3>

<p><cite>Dubey, P., &amp; Müller, H. G. (2020). Functional models for time‐varying random objects. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 82(2), 275-327.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(5)
library(mpoly)
n &lt;- 100
N &lt;- 50
t_out &lt;- seq(0,1,length.out = N)

p2 &lt;- as.function(mpoly::jacobi(2,4,3),silent=TRUE)
p4 &lt;- as.function(mpoly::jacobi(4,4,3),silent=TRUE)
p6 &lt;- as.function(mpoly::jacobi(6,4,3),silent=TRUE)

# first three eigenfunctions
phi1 &lt;- function(t){
  p2(2*t-1)*t^(1.5)*(1-t)^2/(integrate(function(x) p2(2*x-1)^2*x^(3)*(1-x)^4,0,1))$value^(1/2)
}
phi2 &lt;- function(t){
  p4(2*t-1)*t^(1.5)*(1-t)^2/(integrate(function(x) p4(2*x-1)^2*x^(3)*(1-x)^4,0,1))$value^(1/2)
}
phi3 &lt;- function(t){
  p6(2*t-1)*t^(1.5)*(1-t)^2/(integrate(function(x) p6(2*x-1)^2*x^(3)*(1-x)^4,0,1))$value^(1/2)
}

# random component of covariance matrices
P12 &lt;- 0 ## elements between communities
Score &lt;- matrix(runif(n*4), nrow = n)
# first community
P1_cov &lt;- 0.5 + 0.4*Score[,1] %*% t(phi1(t_out)) + 0.1*Score[,2] %*% t(phi3(t_out))  
# second community
P2_cov &lt;- 0.5 + 0.3*Score[,3] %*% t(phi2(t_out)) + 0.1*Score[,4] %*% t(phi3(t_out))  
P1_diag &lt;- 2 #diagonal elements of the first community
P2_diag &lt;- 3 #diagonal elements of the second community

# create Network edge matrix 
N_net1 &lt;- 5 # first community number
N_net2 &lt;- 5 # second community number

# I: four dimension array of n x n matrix of squared distances between the time point u  
# of the ith process and process and the time point v of the jth object process, 
# e.g.: I[i,j,u,v] &lt;- d_F^2(X_i(u) X_j(v)).
I &lt;- array(0, dim = c(n,n,N,N))
for(u in 1:N){
  for(v in 1:N){
    #frobenius norm between two adjcent matrix  
    I[,,u,v] &lt;- outer(P1_cov[,u], P1_cov[,v], function(a1, a2) (a1-a2)^2*(N_net1^2-N_net1)) + 
      outer(P2_cov[,u], P2_cov[,v], function(a1, a2) (a1-a2)^2*(N_net2^2-N_net2)) 
  }
}

# check ObjCov work 
Cov_result &lt;- ObjCov(t_out, I, 3, smooth=FALSE)
Cov_result$lambda  # 0.266 0.15 0.04

# e.g. subj 2 
subj &lt;- 2
# X_mat is the network for varying times with X[i,,] 
# is the adjacency matrices for the ith time point
X_mat &lt;- array(0, c(N,(N_net1+N_net2), (N_net1+N_net2)))
for(i in 1:N){
  # edge between communities is P12
  Mat &lt;- matrix(P12, nrow = (N_net1+N_net2), ncol = (N_net1+N_net2)) 
  # edge within the first communitiy is P1
  Mat[1:N_net1, 1:N_net1] &lt;- P1_cov[subj, i] 
  # edge within the second community is P2
  Mat[(N_net1+1):(N_net1+N_net2), (N_net1+1):(N_net1+N_net2)] &lt;- P2_cov[subj, i] 
  diag(Mat) &lt;- c(rep(P1_diag,N_net1),rep(P2_diag, N_net2)) #diagonal element is 0 
  X_mat[i,,] &lt;- Mat
}
# output the functional principal network(adjacency matrice) of the second eigenfunction
CovFIntegral(Cov_result$phi[,2], t_out, X_mat)

</code></pre>

<hr>
<h2 id='CovFMean'>Fréchet mean of covariance matrices</h2><span id='topic+CovFMean'></span>

<h3>Description</h3>

<p>Fréchet mean computation for covariance matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CovFMean(M = NULL, optns = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovFMean_+3A_m">M</code></td>
<td>
<p>A q by q by n array (resp. a list of q by q matrices) where <code>M[,,i]</code> (resp. <code>M[[i]]</code>) contains the i-th covariance matrix of dimension q by q.</p>
</td></tr>
<tr><td><code id="CovFMean_+3A_optns">optns</code></td>
<td>
<p>A list of options control parameters specified by <code>list(name=value)</code>. See &lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available control options are
</p>

<dl>
<dt>metric</dt><dd><p>Metric type choice, <code>"frobenius"</code>, <code>"power"</code>, <code>"log_cholesky"</code>, <code>"cholesky"</code> - default: <code>"frobenius"</code> which corresponds to the power metric with <code>alpha</code> equal to 1.</p>
</dd>
<dt>alpha</dt><dd><p>The power parameter for the power metric, which can be any non-negative number. Default is 1 which corresponds to Frobenius metric.</p>
</dd>
<dt>weights</dt><dd><p>A vector of weights to compute the weighted barycenter. The length of <code>weights</code> is equal to the sample size n. Default is equal weights.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list containing the following fields:
</p>
<table>
<tr><td><code>Mout</code></td>
<td>
<p>A list containing the Fréchet mean of the covariance matrices in <code>M</code>.</p>
</td></tr>
<tr><td><code>optns</code></td>
<td>
<p>A list containing the <code>optns</code> parameters utilized.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li> <p><cite>Petersen, A. and Müller, H.-G. (2019). Fréchet regression for random objects with Euclidean predictors. The Annals of Statistics, 47(2), 691&ndash;719.</cite>
</p>
</li>
<li> <p><cite>Petersen, A., Deoni, S. and Müller, H.-G. (2019). Fréchet estimation of time-varying covariance matrices from sparse data, with application to the regional co-evolution of myelination in the developing brain. The Annals of Applied Statistics, 13(1), 393&ndash;419.</cite>
</p>
</li>
<li> <p><cite>Lin, Z. (2019). Riemannian geometry of symmetric positive definite matrices via Cholesky decomposition. Siam. J. Matrix. Anal, A. 40, 1353&ndash;1370.</cite>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#Example M input
n=10 #sample size
m=5 # dimension of covariance matrices
M &lt;- array(0,c(m,m,n))
for (i in 1:n){
 y0=rnorm(m)
 aux&lt;-diag(m)+y0%*%t(y0)
 M[,,i]&lt;-aux
}
Fmean=CovFMean(M=M,optns=list(metric="frobenius"))

</code></pre>

<hr>
<h2 id='CreateCovRegPlot'>Plots for Fréchet regression for covariance matrices.</h2><span id='topic+CreateCovRegPlot'></span>

<h3>Description</h3>

<p>Plots for Fréchet regression for covariance matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateCovRegPlot(x, optns = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateCovRegPlot_+3A_x">x</code></td>
<td>
<p>A <code>covReg</code> object obtained from <code><a href="#topic+CovFMean">CovFMean</a></code>, <code><a href="#topic+GloCovReg">GloCovReg</a></code> or <code><a href="#topic+LocCovReg">LocCovReg</a></code>.</p>
</td></tr>
<tr><td><code id="CreateCovRegPlot_+3A_optns">optns</code></td>
<td>
<p>A list of control options specified by <code>list(name=value)</code>. See 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available control options are
</p>

<dl>
<dt>ind.xout</dt><dd><p>A vector holding the indices of elements in <code>x$Mout</code> at which the plots will be made. Default is </p>

<ul>
<li> <p><code>1:length(x$Mout)</code> when <code>x$Mout</code> is of length no more than 3;
</p>
</li>
<li> <p><code>c(1,round(length(x$Mout)/2),length(x$Mout))</code> when <code>x$Mout</code> is of length greater than 3.
</p>
</li></ul>
</dd>
<dt>nrow</dt><dd><p>An integer &mdash; default: 1; subsequent figures will be drawn in an <code>optns$nrow</code>-by-<br />
<code>ceiling(length(ind.xout)/optns$nrow)</code> array.</p>
</dd>
<dt>plot.type</dt><dd><p>Character with two choices, &quot;continuous&quot; and &quot;categorical&quot;.
The former plots the correlations in a continuous scale of colors by magnitude
while the latter categorizes the positive and negative entries into two different colors.
Default is &quot;continuous&quot;</p>
</dd>
<dt>plot.clust</dt><dd><p>Character, the ordering method of the correlation matrix. 
<code>"original"</code> for original order (default);
<code>"AOE"</code> for the angular order of the eigenvectors;
<code>"FPC"</code> for the first principal component order;
<code>"hclust"</code> for the hierarchical clustering order, drawing 4 rectangles on the graph according to the hierarchical cluster;
<code>"alphabet"</code> for alphabetical order.</p>
</dd>
<dt>plot.method</dt><dd><p>Character, the visualization method of correlation matrix to be used.
Currently, it supports seven methods, named &quot;circle&quot; (default), &quot;square&quot;, &quot;ellipse&quot;, &quot;number&quot;, &quot;pie&quot;, &quot;shade&quot; and &quot;color&quot;. </p>
</dd>
<dt>CorrOut</dt><dd><p>Logical, indicating if output is shown as correlation or covariance matrix. Default is <code>FALSE</code> and corresponds to a covariance matrix.</p>
</dd>
<dt>plot.display</dt><dd><p>Character, &quot;full&quot; (default), &quot;upper&quot; or &quot;lower&quot;, display full matrix, lower triangular or upper triangular matrix.</p>
</dd>
</dl>



<h3>Value</h3>

<p>No return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example y input
n=20             # sample size
t=seq(0,1,length.out=100)       # length of data
x = matrix(runif(n),n)
theta1 = theta2 = array(0,n)
for(i in 1:n){
 theta1[i] = rnorm(1,x[i],x[i]^2)
 theta2[i] = rnorm(1,x[i]/2,(1-x[i])^2)
}
y = matrix(0,n,length(t))
phi1 = sqrt(3)*t
phi2 = sqrt(6/5)*(1-t/2)
y = theta1%*%t(phi1) + theta2 %*% t(phi2)
xout = matrix(c(0.25,0.5,0.75),3)
Cov_est=GloCovReg(x=x,y=y,xout=xout,optns=list(corrOut = FALSE, metric="power",alpha=3))
CreateCovRegPlot(Cov_est, optns = list(ind.xout = 2, plot.method = "shade"))

CreateCovRegPlot(Cov_est, optns = list(plot.method = "color"))

</code></pre>

<hr>
<h2 id='CreateDensity'>Create density functions from raw data, histogram objects or frequency tables with bins</h2><span id='topic+CreateDensity'></span>

<h3>Description</h3>

<p>Create kernel density estimate along the support of the raw data using the HADES method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateDensity(
  y = NULL,
  histogram = NULL,
  freq = NULL,
  bin = NULL,
  optns = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateDensity_+3A_y">y</code></td>
<td>
<p>A vector of raw readings.</p>
</td></tr>
<tr><td><code id="CreateDensity_+3A_histogram">histogram</code></td>
<td>
<p>A <code>histogram</code> object in R. Use this option when histogram object is only available, but not the raw data <code>y</code>. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="CreateDensity_+3A_freq">freq</code></td>
<td>
<p>A frequency vector. Use this option when frequency table is only available, but not the raw sample or the histogram object. The corresponding <code>bin</code> should be provided together. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="CreateDensity_+3A_bin">bin</code></td>
<td>
<p>A bin vector having its length with <code>length(freq)+1</code>. Use this option when frequency table is only available, but not the raw sample or the histogram object. The corresponding <code>freq</code> should be provided together.The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="CreateDensity_+3A_optns">optns</code></td>
<td>
<p>A list of options control parameters specified by <code>list(name=value)</code>. See &lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available control options are
</p>

<dl>
<dt>userBwMu</dt><dd><p>The bandwidth value for the smoothed mean function; positive numeric - default: determine automatically based on the data-driven bandwidth selector proposed by Sheather and Jones (1991)</p>
</dd>
<dt>nRegGrid</dt><dd><p>The number of support points the KDE; numeric - default: 101.</p>
</dd>
<dt>delta</dt><dd><p>The size of the bin to be used; numeric - default: <code>diff(range(y))/1000</code>. It only works when the raw sample is available.</p>
</dd>
<dt>kernel</dt><dd><p>smoothing kernel choice, <code>"rect"</code>, <code>"gauss"</code>, <code>"epan"</code>, <code>"gausvar"</code>, <code>"quar"</code> - default: <code>"gauss"</code>.</p>
</dd>
<dt>infSupport</dt><dd><p>logical if we expect the distribution to have infinite support or not; logical - default: <code>FALSE</code>.</p>
</dd>
<dt>outputGrid</dt><dd><p>User defined output grid for the support of the KDE, it overrides <code>nRegGrid</code>; numeric - default: <code>NULL</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list containing the following fields:
</p>
<table>
<tr><td><code>bw</code></td>
<td>
<p>The bandwidth used for smoothing.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>A vector of length <code>nRegGrid</code> with the values of the KDE's support points.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>A vector of length <code>nRegGrid</code> with the values of the KDE at the support points.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li> <p><cite>H.-G. Müller, J.L. Wang and W.B. Capra (1997). &quot;From lifetables to hazard rates: The transformation approach.&quot; Biometrika 84, 881&ndash;892.</cite>
</p>
</li>
<li> <p><cite>S.J. Sheather and M.C. Jones (1991). &quot;A reliable data-based bandwidth selection method for kernel density estimation.&quot; JRSS-B 53, 683&ndash;690.</cite>
</p>
</li>
<li> <p><cite>H.-G. Müller, U. Stadtmüller, and T. Schmitt. (1987) &quot;Bandwidth choice and confidence intervals for derivatives of noisy data.&quot; Biometrika 74, 743&ndash;749.</cite>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
### compact support case

# input: raw sample
set.seed(100)
n &lt;- 100
x0 &lt;-seq(0,1,length.out=51)
Y &lt;- rbeta(n,3,2)
f1 &lt;- CreateDensity(y=Y,optns = list(outputGrid=x0))

# input: histogram
histY &lt;- hist(Y)
f2 &lt;- CreateDensity(histogram=histY,optns = list(outputGrid=x0))

# input: frequency table with unequally spaced (random) bins
binY &lt;- c(0,sort(runif(9)),1)
freqY &lt;- c()
for (i in 1:(length(binY)-1)) {
  freqY[i] &lt;- length(which(Y&gt;binY[i] &amp; Y&lt;=binY[i+1]))
}
f3 &lt;- CreateDensity(freq=freqY, bin=binY,optns = list(outputGrid=x0))

# plot
plot(f1$x,f1$y,type='l',col=2,lty=2,lwd=2,
     xlim=c(0,1),ylim=c(0,2),xlab='domain',ylab='density')
points(f2$x,f2$y,type='l',col=3,lty=3,lwd=2)
points(f3$x,f3$y,type='l',col=4,lty=4,lwd=2)
points(x0,dbeta(x0,3,2),type='l',lwd=2)
legend('topleft',
       c('true','raw sample','histogram','frequency table (unequal bin)'),
       col=1:4,lty=1:4,lwd=3,bty='n')

### infinite support case

# input: raw sample
set.seed(100)
n &lt;- 200
x0 &lt;-seq(-3,3,length.out=101)
Y &lt;- rnorm(n)
f1 &lt;- CreateDensity(y=Y,optns = list(outputGrid=x0))

# input: histogram
histY &lt;- hist(Y)
f2 &lt;- CreateDensity(histogram=histY,optns = list(outputGrid=x0))

# input: frequency table with unequally spaced (random) bins
binY &lt;- c(-3,sort(runif(9,-3,3)),3)
freqY &lt;- c()
for (i in 1:(length(binY)-1)) {
  freqY[i] &lt;- length(which(Y&gt;binY[i] &amp; Y&lt;=binY[i+1]))
}
f3 &lt;- CreateDensity(freq=freqY, bin=binY,optns = list(outputGrid=x0))

# plot
plot(f1$x,f1$y,type='l',col=2,lty=2,lwd=2,
     xlim=c(-3,3),ylim=c(0,0.5),xlab='domain',ylab='density')
points(f2$x,f2$y,type='l',col=3,lty=3,lwd=2)
points(f3$x,f3$y,type='l',col=4,lty=4,lwd=2)
points(x0,dnorm(x0),type='l',lwd=2)
legend('topright',
       c('true','raw sample','histogram','frequency table (unequal bin)'),
       col=1:4,lty=1:4,lwd=3,bty='n')

</code></pre>

<hr>
<h2 id='DenANOVA'>Fréchet ANOVA for Densities</h2><span id='topic+DenANOVA'></span>

<h3>Description</h3>

<p>Fréchet analysis of variance for densities with respect to 
<code class="reqn">L^2</code>-Wasserstein distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DenANOVA(
  yin = NULL,
  hin = NULL,
  din = NULL,
  qin = NULL,
  supin = NULL,
  group = NULL,
  optns = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DenANOVA_+3A_yin">yin</code></td>
<td>
<p>A matrix or data frame or list holding the sample of measurements 
for the observed distributions. If <code>yin</code> is a matrix or data frame, 
each row holds the measurements for one distribution.</p>
</td></tr>
<tr><td><code id="DenANOVA_+3A_hin">hin</code></td>
<td>
<p>A list holding the histograms for the observed distributions.</p>
</td></tr>
<tr><td><code id="DenANOVA_+3A_din">din</code></td>
<td>
<p>A matrix or data frame or list holding the density functions. 
If <code>din</code> is a matrix or data frame, each row of <code>din</code> holds 
the density function for one distribution.</p>
</td></tr>
<tr><td><code id="DenANOVA_+3A_qin">qin</code></td>
<td>
<p>A matrix or data frame or list holding the quantile functions. 
If <code>qin</code> is a matrix or data frame, each row of <code>qin</code> holds 
the quantile function for one distribution.
Note that the input can be only one of the four <code>yin</code>, <code>hin</code>, 
<code>din</code>, and <code>qin</code>. If more than one of them are specified, 
<code>yin</code> overwrites <code>hin</code>, <code>hin</code> overwrites <code>din</code>, 
and <code>din</code> overwrites <code>qin</code>.</p>
</td></tr>
<tr><td><code id="DenANOVA_+3A_supin">supin</code></td>
<td>
<p>A matrix or data frame or list holding the support grids of 
the density functions in <code>din</code> or the quantile functions in <code>qin</code>. 
If <code>supin</code> is a matrix or data frame, each row of <code>supin</code> holds 
the support grid of the corresponding density function or quantile function.
Ignored if the input is <code>yin</code> or <code>hin</code>.
It can also be a vector if all density functions in <code>din</code> or 
all quantile functions in <code>qin</code> have the same support grid.</p>
</td></tr>
<tr><td><code id="DenANOVA_+3A_group">group</code></td>
<td>
<p>A vector containing the group memberships of the corresponding 
observed distributions in <code>yin</code> or <code>hin</code> or <code>din</code> or <code>qin</code>.</p>
</td></tr>
<tr><td><code id="DenANOVA_+3A_optns">optns</code></td>
<td>
<p>A list of control parameters specified by
<code>list(name = value)</code>. See 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available control options are 
</p>

<dl>
<dt>boot</dt><dd><p>Logical, also compute bootstrap <code class="reqn">p</code>-value if <code>TRUE</code>. 
Default is <code>FALSE</code>.</p>
</dd>
<dt>R</dt><dd><p>The number of bootstrap replicates. Only used when <code>boot</code> 
is <code>TRUE</code>. Default is 1000.</p>
</dd>
<dt>nqSup</dt><dd><p>A scalar giving the number of the support points for 
quantile functions based on which the <code class="reqn">L^2</code> Wasserstein distance 
(i.e., the <code class="reqn">L^2</code> distance between the quantile functions) is computed. 
Default is 201.</p>
</dd>
<dt>qSup</dt><dd><p>A numeric vector holding the support grid on [0, 1] based on 
which the <code class="reqn">L^2</code> Wasserstein distance (i.e., the <code class="reqn">L^2</code> distance 
between the quantile functions) is computed. It overrides <code>nqSup</code>.</p>
</dd>
<dt>bwDen</dt><dd><p>The bandwidth value used in <code>CreateDensity()</code> for
density estimation; positive numeric - default: determine automatically 
based on the data-driven bandwidth selector proposed by 
Sheather and Jones (1991).</p>
</dd>
<dt>ndSup</dt><dd><p>A scalar giving the number of support points the kernel density 
estimation used in <code>CreateDensity()</code>; numeric - default: 101.</p>
</dd>
<dt>dSup</dt><dd><p>User defined output grid for the support of 
kernel density estimation used in <code>CreateDensity()</code>, 
it overrides <code>ndSup</code>.</p>
</dd>
<dt>delta</dt><dd><p>A scalar giving the size of the bin to be used used in 
<code>CreateDensity()</code>; numeric - default: <code>diff(range(y))/1000</code>. 
It only works when the raw sample is available.</p>
</dd>
<dt>kernelDen</dt><dd><p>A character holding the type of kernel functions used in 
<code>CreateDensity()</code> for density estimation; <code>"rect"</code>, 
<code>"gauss"</code>, <code>"epan"</code>, <code>"gausvar"</code>, 
<code>"quar"</code> - default: <code>"gauss"</code>.</p>
</dd>
<dt>infSupport</dt><dd><p>logical if we expect the distribution to have 
infinite support or not, used in <code>CreateDensity()</code> for 
density estimation; logical - default: <code>FALSE</code></p>
</dd>
<dt>denLowerThreshold</dt><dd><p><code>FALSE</code> or a positive value giving 
the lower threshold of the densities used in <code>CreateDensity()</code>; 
default: <code>0.001 * mean(qin[,ncol(qin)] - qin[,1])</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code>DenANOVA</code> object &mdash; a list containing the following fields:
</p>
<table>
<tr><td><code>pvalAsy</code></td>
<td>
<p>a scalar holding the asymptotic <code class="reqn">p</code>-value.</p>
</td></tr>
<tr><td><code>pvalBoot</code></td>
<td>
<p>a scalar holding the bootstrap <code class="reqn">p</code>-value.
Returned if <code>optns$boot</code> is TRUE.</p>
</td></tr>
<tr><td><code>optns</code></td>
<td>
<p>the control options used.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li> <p><cite>Dubey, P. and Müller, H.G., 2019. Fréchet analysis of variance for random objects. Biometrika, 106(4), pp.803-821.</cite>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n1 &lt;- 100
n2 &lt;- 100
delta &lt;- 1
qSup &lt;- seq(0.01, 0.99, (0.99 - 0.01) / 50)
mu1 &lt;- rnorm(n1, mean = 0, sd = 0.5)
mu2 &lt;- rnorm(n2, mean = delta, sd = 0.5)
Y1 &lt;- lapply(1:n1, function(i) {
  qnorm(qSup, mu1[i], sd = 1)
})
Y2 &lt;- lapply(1:n2, function(i) {
  qnorm(qSup, mu2[i], sd = 1)
})
Ly &lt;- c(Y1, Y2)
Lx &lt;- qSup
group &lt;- c(rep(1, n1), rep(2, n2))
res &lt;- DenANOVA(qin = Ly, supin = Lx, group = group, optns = list(boot = TRUE))
res$pvalAsy # returns asymptotic pvalue
res$pvalBoot # returns bootstrap pvalue

</code></pre>

<hr>
<h2 id='DenCPD'>Fréchet Change Point Detection for Densities</h2><span id='topic+DenCPD'></span>

<h3>Description</h3>

<p>Fréchet change point detection for densities with respect to
<code class="reqn">L^2</code>-Wasserstein distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DenCPD(
  yin = NULL,
  hin = NULL,
  din = NULL,
  qin = NULL,
  supin = NULL,
  optns = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DenCPD_+3A_yin">yin</code></td>
<td>
<p>A matrix or data frame or list holding the sample of measurements
for the observed distributions. If <code>yin</code> is a matrix or data frame,
each row holds the measurements for one distribution.</p>
</td></tr>
<tr><td><code id="DenCPD_+3A_hin">hin</code></td>
<td>
<p>A list holding the histograms for the observed distributions.</p>
</td></tr>
<tr><td><code id="DenCPD_+3A_din">din</code></td>
<td>
<p>A matrix or data frame or list holding the density functions.
If <code>din</code> is a matrix or data frame, each row of <code>din</code> holds
the density function for one distribution.</p>
</td></tr>
<tr><td><code id="DenCPD_+3A_qin">qin</code></td>
<td>
<p>A matrix or data frame or list holding the quantile functions.
If <code>qin</code> is a matrix or data frame, each row of <code>qin</code> holds
the quantile function for one distribution.
Note that the input can be only one of the four <code>yin</code>, <code>hin</code>,
<code>din</code>, and <code>qin</code>. If more than one of them are specified,
<code>yin</code> overwrites <code>hin</code>, <code>hin</code> overwrites <code>din</code>,
and <code>din</code> overwrites <code>qin</code>.</p>
</td></tr>
<tr><td><code id="DenCPD_+3A_supin">supin</code></td>
<td>
<p>A matrix or data frame or list holding the support grids of
the density functions in <code>din</code> or the quantile functions in <code>qin</code>.
If <code>supin</code> is a matrix or data frame, each row of <code>supin</code> holds
the support grid of the corresponding density function or quantile function.
Ignored if the input is <code>yin</code> or <code>hin</code>.
It can also be a vector if all density functions in <code>din</code> or
all quantile functions in <code>qin</code> have the same support grid.</p>
</td></tr>
<tr><td><code id="DenCPD_+3A_optns">optns</code></td>
<td>
<p>A list of control parameters specified by
<code>list(name = value)</code>. See 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available control options are
</p>

<dl>
<dt>cutOff</dt><dd><p>A scalar between 0 and 1 indicating the interval,
i.e., [cutOff, 1 - cutOff], in which candidate change points lie.</p>
</dd>
<dt>Q</dt><dd><p>A scalar representing the number of Monte Carlo simulations to run
while approximating the critical value (stardized Brownian bridge).
Default is 1000.</p>
</dd>
<dt>boot</dt><dd><p>Logical, also compute bootstrap <code class="reqn">p</code>-value if <code>TRUE</code>.
Default is <code>FALSE</code>.</p>
</dd>
<dt>R</dt><dd><p>The number of bootstrap replicates. Only used when <code>boot</code>
is <code>TRUE</code>. Default is 1000.</p>
</dd>
<dt>nqSup</dt><dd><p>A scalar giving the number of the support points for
quantile functions based on which the <code class="reqn">L^2</code> Wasserstein distance
(i.e., the <code class="reqn">L^2</code> distance between the quantile functions) is computed.
Default is 201.</p>
</dd>
<dt>qSup</dt><dd><p>A numeric vector holding the support grid on [0, 1] based on
which the <code class="reqn">L^2</code> Wasserstein distance (i.e., the <code class="reqn">L^2</code> distance
between the quantile functions) is computed. It overrides <code>nqSup</code>.</p>
</dd>
<dt>bwDen</dt><dd><p>The bandwidth value used in <code>CreateDensity()</code> for
density estimation; positive numeric - default: determine automatically
based on the data-driven bandwidth selector proposed by
Sheather and Jones (1991).</p>
</dd>
<dt>ndSup</dt><dd><p>A scalar giving the number of support points the kernel density
estimation used in <code>CreateDensity()</code>; numeric - default: 101.</p>
</dd>
<dt>dSup</dt><dd><p>User defined output grid for the support of
kernel density estimation used in <code>CreateDensity()</code>,
it overrides <code>ndSup</code>.</p>
</dd>
<dt>delta</dt><dd><p>A scalar giving the size of the bin to be used used in
<code>CreateDensity()</code>; numeric - default: <code>diff(range(y))/1000</code>.
It only works when the raw sample is available.</p>
</dd>
<dt>kernelDen</dt><dd><p>A character holding the type of kernel functions used in
<code>CreateDensity()</code> for density estimation; <code>"rect"</code>,
<code>"gauss"</code>, <code>"epan"</code>, <code>"gausvar"</code>,
<code>"quar"</code> - default: <code>"gauss"</code>.</p>
</dd>
<dt>infSupport</dt><dd><p>logical if we expect the distribution to have
infinite support or not, used in <code>CreateDensity()</code> for
density estimation; logical - default: <code>FALSE</code></p>
</dd>
<dt>denLowerThreshold</dt><dd><p><code>FALSE</code> or a positive value giving
the lower threshold of the densities used in <code>CreateDensity()</code>;
default: <code>0.001 * mean(qin[,ncol(qin)] - qin[,1])</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code>DenCPD</code> object &mdash; a list containing the following fields:
</p>
<table>
<tr><td><code>tau</code></td>
<td>
<p>a scalar holding the estimated change point.</p>
</td></tr>
<tr><td><code>pvalAsy</code></td>
<td>
<p>a scalar holding the asymptotic <code class="reqn">p</code>-value.</p>
</td></tr>
<tr><td><code>pvalBoot</code></td>
<td>
<p>a scalar holding the bootstrap <code class="reqn">p</code>-value.
Returned if <code>optns$boot</code> is TRUE.</p>
</td></tr>
<tr><td><code>optns</code></td>
<td>
<p>the control options used.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li> <p><cite>Dubey, P. and Müller, H.G., 2020. Fréchet change-point detection. The Annals of Statistics, 48(6), pp.3312-3335.</cite>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n1 &lt;- 100
n2 &lt;- 200
delta &lt;- 0.75
qSup &lt;- seq(0.01, 0.99, (0.99 - 0.01) / 50)
mu1 &lt;- rnorm(n1, mean = delta, sd = 0.5)
mu2 &lt;- rnorm(n2, mean = 0, sd = 0.5)
Y1 &lt;- lapply(1:n1, function(i) {
  qnorm(qSup, mu1[i], sd = 1)
})
Y2 &lt;- lapply(1:n2, function(i) {
  qnorm(qSup, mu2[i], sd = 1)
})
Ly &lt;- c(Y1, Y2)
Lx &lt;- qSup
res &lt;- DenCPD(qin = Ly, supin = Lx, optns = list(boot = TRUE))
res$tau # returns the estimated change point
res$pvalAsy # returns asymptotic pvalue
res$pvalBoot # returns bootstrap pvalue
 
</code></pre>

<hr>
<h2 id='DenFMean'>Fréchet means of densities.</h2><span id='topic+DenFMean'></span>

<h3>Description</h3>

<p>Obtain Fréchet means of densities with respect to <code class="reqn">L^2</code>-Wasserstein distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DenFMean(yin = NULL, hin = NULL, qin = NULL, optns = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DenFMean_+3A_yin">yin</code></td>
<td>
<p>A matrix or list holding the sample of measurements for the observed distributions. If <code>yin</code> is a matrix, each row holds the measurements for one distribution.</p>
</td></tr>
<tr><td><code id="DenFMean_+3A_hin">hin</code></td>
<td>
<p>A list holding the histograms of an observed distribution.</p>
</td></tr>
<tr><td><code id="DenFMean_+3A_qin">qin</code></td>
<td>
<p>A matrix or list holding the quantile functions of the response. If <code>qin</code> is a matrix, each row holds the quantile function of an observed distribution taking values on <code>optns$qSup</code>.
Note that only one of the three <code>yin</code>, <code>hin</code>, and <code>qin</code> needs to be input.
If more than one of them are specified, <code>yin</code> overwrites <code>hin</code>, and <code>hin</code> overwrites <code>qin</code>.</p>
</td></tr>
<tr><td><code id="DenFMean_+3A_optns">optns</code></td>
<td>
<p>A list of options control parameters specified by <code>list(name=value)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available control options are <code>qSup</code>, <code>nqSup</code>, 
<code>bwDen</code>, <code>ndSup</code>, <code>dSup</code>, <code>delta</code>, 
<code>kernelDen</code>, <code>infSupport</code>, and <code>denLowerThreshold</code>. 
See <code><a href="#topic+LocDenReg">LocDenReg</a></code> for details.
</p>

<dl>
<dt>weights</dt><dd><p>A vector of weights to compute the weighted barycenter. The length of <code>weights</code> is equal to the sample size. Default is equal weights.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>dout</code></td>
<td>
<p>A numeric vector holding the density of the Fréchet mean.</p>
</td></tr>
<tr><td><code>dSup</code></td>
<td>
<p>A numeric vector giving the domain grid of <code>dout</code> when it is a matrix.</p>
</td></tr>
<tr><td><code>qout</code></td>
<td>
<p>A numeric vector holding the quantile function of the Fréchet mean.</p>
</td></tr>
<tr><td><code>qSup</code></td>
<td>
<p>A numeric vector giving the domain grid of <code>qout</code>.</p>
</td></tr>
<tr><td><code>optns</code></td>
<td>
<p>A list of control options used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>xin = seq(0,1,0.05)
yin = lapply(xin, function(x) {
  rnorm(100, rnorm(1,x + x^2,0.005), 0.05)
})
res &lt;- DenFMean(yin=yin)
plot(res)

</code></pre>

<hr>
<h2 id='DenFVar'>Fréchet Variance for Densities</h2><span id='topic+DenFVar'></span>

<h3>Description</h3>

<p>Obtain Fréchet variance for densities with respect to
<code class="reqn">L^2</code>-Wasserstein distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DenFVar(
  yin = NULL,
  hin = NULL,
  din = NULL,
  qin = NULL,
  supin = NULL,
  optns = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DenFVar_+3A_yin">yin</code></td>
<td>
<p>A matrix or data frame or list holding the sample of measurements 
for the observed distributions. If <code>yin</code> is a matrix or data frame, 
each row holds the measurements for one distribution.</p>
</td></tr>
<tr><td><code id="DenFVar_+3A_hin">hin</code></td>
<td>
<p>A list holding the histograms for the observed distributions.</p>
</td></tr>
<tr><td><code id="DenFVar_+3A_din">din</code></td>
<td>
<p>A matrix or data frame or list holding the density functions. 
If <code>din</code> is a matrix or data frame, each row of <code>din</code> holds 
the density function for one distribution.</p>
</td></tr>
<tr><td><code id="DenFVar_+3A_qin">qin</code></td>
<td>
<p>A matrix or data frame or list holding the quantile functions. 
If <code>qin</code> is a matrix or data frame, each row of <code>qin</code> holds 
the quantile function for one distribution.
Note that the input can be only one of the four <code>yin</code>, <code>hin</code>, 
<code>din</code>, and <code>qin</code>. If more than one of them are specified, 
<code>yin</code> overwrites <code>hin</code>, <code>hin</code> overwrites <code>din</code>, 
and <code>din</code> overwrites <code>qin</code>.</p>
</td></tr>
<tr><td><code id="DenFVar_+3A_supin">supin</code></td>
<td>
<p>A matrix or data frame or list holding the support grids of 
the density functions in <code>din</code> or the quantile functions in <code>qin</code>. 
If <code>supin</code> is a matrix or data frame, each row of <code>supin</code> holds 
the support grid of the corresponding density function or quantile function.
Ignored if the input is <code>yin</code> or <code>hin</code>.
It can also be a vector if all density functions in <code>din</code> or 
all quantile functions in <code>qin</code> have the same support grid.</p>
</td></tr>
<tr><td><code id="DenFVar_+3A_optns">optns</code></td>
<td>
<p>A list of control parameters specified by
<code>list(name = value)</code>. See 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available control options are 
</p>

<dl>
<dt>nqSup</dt><dd><p>A scalar giving the number of the support points for 
quantile functions based on which the <code class="reqn">L^2</code> Wasserstein distance 
(i.e., the <code class="reqn">L^2</code> distance between the quantile functions) is computed. 
Default is 201.</p>
</dd>
<dt>qSup</dt><dd><p>A numeric vector holding the support grid on [0, 1] based on 
which the <code class="reqn">L^2</code> Wasserstein distance (i.e., the <code class="reqn">L^2</code> distance 
between the quantile functions) is computed. It overrides <code>nqSup</code>.</p>
</dd>
<dt>bwDen</dt><dd><p>The bandwidth value used in <code>CreateDensity()</code> for
density estimation; positive numeric - default: determine automatically 
based on the data-driven bandwidth selector proposed by 
Sheather and Jones (1991).</p>
</dd>
<dt>ndSup</dt><dd><p>A scalar giving the number of support points the kernel density 
estimation used in <code>CreateDensity()</code>; numeric - default: 101.</p>
</dd>
<dt>dSup</dt><dd><p>User defined output grid for the support of 
kernel density estimation used in <code>CreateDensity()</code>, 
it overrides <code>ndSup</code>.</p>
</dd>
<dt>delta</dt><dd><p>A scalar giving the size of the bin to be used used in 
<code>CreateDensity()</code>; numeric - default: <code>diff(range(y))/1000</code>. 
It only works when the raw sample is available.</p>
</dd>
<dt>kernelDen</dt><dd><p>A character holding the type of kernel functions used in 
<code>CreateDensity()</code> for density estimation; <code>"rect"</code>, 
<code>"gauss"</code>, <code>"epan"</code>, <code>"gausvar"</code>, 
<code>"quar"</code> - default: <code>"gauss"</code>.</p>
</dd>
<dt>infSupport</dt><dd><p>logical if we expect the distribution to have 
infinite support or not, used in <code>CreateDensity()</code> for 
density estimation; logical - default: <code>FALSE</code></p>
</dd>
<dt>denLowerThreshold</dt><dd><p><code>FALSE</code> or a positive value giving 
the lower threshold of the densities used in <code>CreateDensity()</code>; 
default: <code>0.001 * mean(qin[,ncol(qin)] - qin[,1])</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list containing the following fields:
</p>
<table>
<tr><td><code>DenFVar</code></td>
<td>
<p>A scalar holding the Fréchet variance.</p>
</td></tr>
<tr><td><code>optns</code></td>
<td>
<p>A list of control options used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 100
mu &lt;- rnorm(n, mean = 0, sd = 0.5)
qSup &lt;- seq(0.01, 0.99, (0.99 - 0.01) / 50)
Ly &lt;- lapply(1:n, function(i) qnorm(qSup, mu[i], sd = 1))
Lx &lt;- qSup
res &lt;- DenFVar(qin = Ly, supin = Lx)
res$DenFVar
</code></pre>

<hr>
<h2 id='dist4cov'>Distance between covariance matrices</h2><span id='topic+dist4cov'></span>

<h3>Description</h3>

<p>Distance computation between two covariance matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist4cov(A = NULL, B = NULL, optns = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist4cov_+3A_a">A</code></td>
<td>
<p>an p by p matrix</p>
</td></tr>
<tr><td><code id="dist4cov_+3A_b">B</code></td>
<td>
<p>an p by p matrix</p>
</td></tr>
<tr><td><code id="dist4cov_+3A_optns">optns</code></td>
<td>
<p>A list of options control parameters specified by <code>list(name=value)</code>. See &lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available control options are 
</p>

<dl>
<dt>metric</dt><dd><p>Metric type choice, <code>"frobenius"</code>, <code>"power"</code>, <code>"log_cholesky"</code> and <code>"cholesky"</code> - default: <code>"frobenius"</code>, which corresponds to the power metric with <code>alpha</code> equal to 1.</p>
</dd>
<dt>alpha</dt><dd><p>The power parameter for the power metric, which can be any non-negative number. Default is 1 which corresponds to Frobenius metric.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list containing the following fields:
</p>
<table>
<tr><td><code>dist</code></td>
<td>
<p>the distance between covariance matrices <code>A</code> and <code>B</code>.</p>
</td></tr>
<tr><td><code>optns</code></td>
<td>
<p>A list containing the <code>optns</code> parameters utilized.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li> <p><cite>Petersen, A. and Müller, H.-G. (2016). Fréchet integration and adaptive metric selection for interpretable covariances of multivariate functional data. Biometrika, 103, 103&ndash;120.</cite>
</p>
</li>
<li> <p><cite>Petersen, A. and Müller, H.-G. (2019). Fréchet regression for random objects with Euclidean predictors. The Annals of Statistics, 47(2), 691&ndash;719.</cite>
</p>
</li>
<li> <p><cite>Petersen, A., Deoni, S. and Müller, H.-G. (2019). Fréchet estimation of time-varying covariance matrices from sparse data, with application to the regional co-evolution of myelination in the developing brain. The Annals of Applied Statistics, 13(1), 393&ndash;419.</cite>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># M input as array
m &lt;- 5 # dimension of covariance matrices
M &lt;- array(0,c(m,m,2))
for (i in 1:2) {
 y0 &lt;- rnorm(m)
 aux &lt;- diag(m) + y0 %*% t(y0)
 M[,,i] &lt;- aux
}
A &lt;- M[,,1]
B &lt;- M[,,2]
frobDist &lt;- dist4cov(A=A, B=B, optns=list(metric="frobenius"))
</code></pre>

<hr>
<h2 id='dist4den'><code class="reqn">L^2</code> Wasserstein distance between two distributions.</h2><span id='topic+dist4den'></span>

<h3>Description</h3>

<p><code class="reqn">L^2</code> Wasserstein distance between two distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist4den(d1 = NULL, d2 = NULL, fctn_type = NULL, optns = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist4den_+3A_d1">d1</code>, <code id="dist4den_+3A_d2">d2</code></td>
<td>
<p>Lists holding the density functions or quantile functions of the two distributions.
Each list consists of two numeric vectors <code>x</code> and <code>y</code> of the same length,
where <code>x</code> holds the support grid and <code>y</code> holds the values of the function.
Note that the type of functions representing the distributions in <code>d1</code> and <code>d2</code>
should be the same&mdash;either both are density functions, or both are quantile functions. 
If both are quantile functions, all elements in <code>d1$x</code> and <code>d2$x</code> must be between 0 and 1.
<code>d1$x</code> and <code>d2$x</code> may have different lengths.</p>
</td></tr>
<tr><td><code id="dist4den_+3A_fctn_type">fctn_type</code></td>
<td>
<p>Character vector of length 1 holding the function type in <code>d1</code> and <code>d2</code> 
representing the distributions: <code>"density"</code> (default), <code>"quantile"</code>.</p>
</td></tr>
<tr><td><code id="dist4den_+3A_optns">optns</code></td>
<td>
<p>A list of control parameters specified by <code>list(name=value)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available control options are:
</p>

<dl>
<dt>nqSup</dt><dd><p>A scalar giving the length of the support grid of quantile functions based on which the <code class="reqn">L^2</code> Wasserstein distance (i.e., the <code class="reqn">L^2</code> distance between the quantile functions) is computed. Default is 201.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A scalar holding the <code class="reqn">L^2</code> Wasserstein distance between <code>d1</code> and <code>d2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d1 &lt;- list(x = seq(-6,6,0.01))
d1$y &lt;- dnorm(d1$x)
d2 &lt;- list(x = d1$x + 1)
d2$y &lt;- dnorm(d2$x, mean = 1)
dist &lt;- dist4den(d1 = d1,d2 = d2)
</code></pre>

<hr>
<h2 id='expSphere'>Compute an exponential map for a unit hypersphere.</h2><span id='topic+expSphere'></span>

<h3>Description</h3>

<p>Compute an exponential map for a unit hypersphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expSphere(base, tg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expSphere_+3A_base">base</code></td>
<td>
<p>A unit vector of length <code class="reqn">m</code> holding the base point of the tangent space.</p>
</td></tr>
<tr><td><code id="expSphere_+3A_tg">tg</code></td>
<td>
<p>A vector of length <code class="reqn">m</code> of which the exponential map is taken.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A unit vector of length <code class="reqn">m</code>.
</p>

<hr>
<h2 id='frameSphere'>Generate a &quot;natural&quot; frame (orthonormal basis)</h2><span id='topic+frameSphere'></span>

<h3>Description</h3>

<p>Generate a &quot;natural&quot; frame (orthonormal basis) for the tangent space at <code>x</code> on the unit sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frameSphere(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frameSphere_+3A_x">x</code></td>
<td>
<p>A unit vector of length <code class="reqn">d</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first <code class="reqn">(i+1)</code> elements of the <code class="reqn">i</code>th basis vector are given by 
<code class="reqn">\sin\theta_i\prod_{j=1}^{i-1}\cos\theta_j</code>, <code class="reqn">\sin\theta_i\sin\theta_1 \prod_{j=2}^{i-1}\cos\theta_j</code>,
<code class="reqn">\sin\theta_i\sin\theta_2 \prod_{j=3}^{i-1}\cos\theta_j</code>, <code class="reqn">\dots</code>, <code class="reqn">\sin\theta_i\sin\theta_{i-1}</code>, <code class="reqn">-\cos\theta_i</code>, respectively.
The rest elements (if any) of the <code class="reqn">i</code>th basis vector are all zero.
</p>


<h3>Value</h3>

<p>A <code class="reqn">d</code>-by-<code class="reqn">(d-1)</code> matrix where columns hold the orthonormal basis of the tangent space at <code>x</code> on the unit sphere.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>frameSphere(c(1,0,0,0))
</code></pre>

<hr>
<h2 id='GloCorReg'>Global Fréchet regression for correlation matrices</h2><span id='topic+GloCorReg'></span>

<h3>Description</h3>

<p>Global Fréchet regression for correlation matrices
with Euclidean predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GloCorReg(x, M, xOut = NULL, optns = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GloCorReg_+3A_x">x</code></td>
<td>
<p>an n by p matrix or data frame of predictors.</p>
</td></tr>
<tr><td><code id="GloCorReg_+3A_m">M</code></td>
<td>
<p>a q by q by n array (resp. a list of q by q matrices) where
<code>M[, , i]</code> (resp. <code>M[[i]]</code>) contains the i-th correlation matrix
of dimension q by q.</p>
</td></tr>
<tr><td><code id="GloCorReg_+3A_xout">xOut</code></td>
<td>
<p>an m by p matrix or data frame of output predictor levels.
It can be a vector of length p if m = 1.</p>
</td></tr>
<tr><td><code id="GloCorReg_+3A_optns">optns</code></td>
<td>
<p>A list of options control parameters specified by
<code>list(name=value)</code>. See &lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available control options are
</p>

<dl>
<dt>metric</dt><dd><p>choice of metric. <code>'frobenius'</code> and <code>'power'</code> are supported,
which corresponds to Frobenius metric and Euclidean power metric,
respectively. Default is Frobenius metric.</p>
</dd>
<dt>alpha</dt><dd><p>the power for Euclidean power metric.
Default is 1 which corresponds to Frobenius metric.</p>
</dd>
<dt>digits</dt><dd><p>the integer indicating the number of decimal places (round)
to be kept in the output. Default is NULL, which means no round operation.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code>corReg</code> object &mdash; a list containing the following fields:
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p>a list of estimated correlation matrices at <code>x</code>.</p>
</td></tr>
<tr><td><code>predict</code></td>
<td>
<p>a list of estimated correlation matrices at <code>xOut</code>.
Included if <code>xOut</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code>RSquare</code></td>
<td>
<p>Fréchet coefficient of determination.</p>
</td></tr>
<tr><td><code>AdjRSquare</code></td>
<td>
<p>adjusted Fréchet coefficient of determination.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Frobenius distance between the true and
fitted correlation matrices.</p>
</td></tr>
<tr><td><code>xOut</code></td>
<td>
<p>the output predictor level used.</p>
</td></tr>
<tr><td><code>optns</code></td>
<td>
<p>the control options used.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li> <p><cite>Petersen, A. and Müller, H.-G. (2019). Fréchet regression for random objects with Euclidean predictors. The Annals of Statistics, 47(2), 691&ndash;719.</cite>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Generate simulation data
n &lt;- 100
q &lt;- 10
d &lt;- q * (q - 1) / 2
xOut &lt;- seq(0.1, 0.9, length.out = 9)
x &lt;- runif(n, min = 0, max = 1)
y &lt;- list()
for (i in 1:n) {
  yVec &lt;- rbeta(d, shape1 = x[i], shape2 = 1 - x[i])
  y[[i]] &lt;- matrix(0, nrow = q, ncol = q)
  y[[i]][lower.tri(y[[i]])] &lt;- yVec
  y[[i]] &lt;- y[[i]] + t(y[[i]])
  diag(y[[i]]) &lt;- 1
}
# Frobenius metric
fit1 &lt;- GloCorReg(x, y, xOut,
  optns = list(metric = "frobenius", digits = 5)
)
# Euclidean power metric
fit2 &lt;- GloCorReg(x, y, xOut,
  optns = list(metric = "power", alpha = .5)
)
</code></pre>

<hr>
<h2 id='GloCovReg'>Global Fréchet regression of covariance matrices</h2><span id='topic+GloCovReg'></span>

<h3>Description</h3>

<p>Global Fréchet regression of covariance matrices with Euclidean predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GloCovReg(x, y = NULL, M = NULL, xout, optns = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GloCovReg_+3A_x">x</code></td>
<td>
<p>An n by p matrix of predictors.</p>
</td></tr>
<tr><td><code id="GloCovReg_+3A_y">y</code></td>
<td>
<p>An n by l matrix, each row corresponds to an observation, l is the length of time points where the responses are observed. See 'metric' option in 'Details' for more details.</p>
</td></tr>
<tr><td><code id="GloCovReg_+3A_m">M</code></td>
<td>
<p>A q by q by n array (resp. a list of q by q matrices) where <code>M[,,i]</code> (resp. <code>M[[i]]</code>) contains the i-th covariance matrix of dimension q by q.  See 'metric' option in 'Details' for more details.</p>
</td></tr>
<tr><td><code id="GloCovReg_+3A_xout">xout</code></td>
<td>
<p>An m by p matrix of output predictor levels.</p>
</td></tr>
<tr><td><code id="GloCovReg_+3A_optns">optns</code></td>
<td>
<p>A list of options control parameters specified by <code>list(name=value)</code>. See &lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available control options are
</p>

<dl>
<dt>corrOut</dt><dd><p>Boolean indicating if output is shown as correlation or covariance matrix. Default is <code>FALSE</code> and corresponds to a covariance matrix.</p>
</dd>
<dt>metric</dt><dd><p>Metric type choice, <code>"frobenius"</code>, <code>"power"</code>, <code>"log_cholesky"</code>, <code>"cholesky"</code> - default: <code>"frobenius"</code> which corresponds to the power metric with <code>alpha</code> equal to 1.
For power (and Frobenius) metrics, either <code>y</code> or <code>M</code> must be input; <code>y</code> would override <code>M</code>. For Cholesky and log-Cholesky metrics, <code>M</code> must be input and <code>y</code> does not apply.</p>
</dd>
<dt>alpha</dt><dd><p>The power parameter for the power metric. Default is 1 which corresponds to Frobenius metric.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code>covReg</code> object &mdash; a list containing the following fields:
</p>
<table>
<tr><td><code>xout</code></td>
<td>
<p>An m by p matrix of output predictor levels.</p>
</td></tr>
<tr><td><code>Mout</code></td>
<td>
<p>A list of estimated conditional covariance or correlation matrices at <code>xout</code>.</p>
</td></tr>
<tr><td><code>optns</code></td>
<td>
<p>A list containing the <code>optns</code> parameters utilized.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li> <p><cite>Petersen, A. and Müller, H.-G. (2019). Fréchet regression for random objects with Euclidean predictors. The Annals of Statistics, 47(2), 691&ndash;719.</cite>
</p>
</li>
<li> <p><cite>Petersen, A., Deoni, S. and Müller, H.-G. (2019). Fréchet estimation of time-varying covariance matrices from sparse data, with application to the regional co-evolution of myelination in the developing brain. The Annals of Applied Statistics, 13(1), 393&ndash;419.</cite>
</p>
</li>
<li> <p><cite>Lin, Z. (2019). Riemannian geometry of symmetric positive definite matrices via Cholesky decomposition. Siam. J. Matrix. Anal, A. 40, 1353&ndash;1370.</cite>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#Example y input
n=50             # sample size
t=seq(0,1,length.out=100)       # length of data
x = matrix(runif(n),n)
theta1 = theta2 = array(0,n)
for(i in 1:n){
 theta1[i] = rnorm(1,x[i],x[i]^2)
 theta2[i] = rnorm(1,x[i]/2,(1-x[i])^2)
}
y = matrix(0,n,length(t))
phi1 = sqrt(3)*t
phi2 = sqrt(6/5)*(1-t/2)
y = theta1%*%t(phi1) + theta2 %*% t(phi2)
xout = matrix(c(0.25,0.5,0.75),3)
Cov_est=GloCovReg(x=x,y=y,xout=xout,optns=list(corrOut=FALSE,metric="power",alpha=3))
#Example M input
n=10 #sample size
m=5 # dimension of covariance matrices
M &lt;- array(0,c(m,m,n))
for (i in 1:n){
 y0=rnorm(m)
 aux&lt;-diag(m)+y0%*%t(y0)
 M[,,i]&lt;-aux
}
x=cbind(matrix(rnorm(n),n),matrix(rnorm(n),n)) #vector of predictor values
xout=cbind(runif(3),runif(3)) #output predictor levels
Cov_est=GloCovReg(x=x,M=M,xout=xout,optns=list(corrOut=FALSE,metric="power",alpha=3))

</code></pre>

<hr>
<h2 id='GloDenReg'>Global density regression.</h2><span id='topic+GloDenReg'></span>

<h3>Description</h3>

<p>Global Fréchet regression for densities with respect to <code class="reqn">L^2</code>-Wasserstein distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GloDenReg(
  xin = NULL,
  yin = NULL,
  hin = NULL,
  qin = NULL,
  xout = NULL,
  optns = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GloDenReg_+3A_xin">xin</code></td>
<td>
<p>An n by p matrix or a vector of length n (if p=1) with input measurements of the predictors.</p>
</td></tr>
<tr><td><code id="GloDenReg_+3A_yin">yin</code></td>
<td>
<p>A matrix or list holding the sample of observations of the response. If <code>yin</code> is a matrix, each row holds the observations of the response corresponding to a row in <code>xin</code>.</p>
</td></tr>
<tr><td><code id="GloDenReg_+3A_hin">hin</code></td>
<td>
<p>A list holding the histograms of the response corresponding to each row in <code>xin</code>.</p>
</td></tr>
<tr><td><code id="GloDenReg_+3A_qin">qin</code></td>
<td>
<p>A matrix or list holding the quantile functions of the response. If <code>qin</code> is a matrix, each row holds the quantile function of the response taking values on <code>optns$qSup</code> corresponding to a row in <code>xin</code>.
Note that only one of the three <code>yin</code>, <code>hin</code>, and <code>qin</code> needs to be input.
If more than one of them are specified, <code>yin</code> overwrites <code>hin</code>, and <code>hin</code> overwrites <code>qin</code>.</p>
</td></tr>
<tr><td><code id="GloDenReg_+3A_xout">xout</code></td>
<td>
<p>A k by p matrix or a vector of length k (if p=1) with output measurements of the predictors. Default is <code>xin</code>.</p>
</td></tr>
<tr><td><code id="GloDenReg_+3A_optns">optns</code></td>
<td>
<p>A list of control parameters specified by <code>list(name=value)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available control options are <code>qSup</code>, <code>nqSup</code>, 
<code>lower</code>, <code>upper</code>, <code>Rsquared</code>, <code>bwDen</code>, <code>ndSup</code>, <code>dSup</code>, 
<code>delta</code>, <code>kernelDen</code>, <code>infSupport</code>, and <code>denLowerThreshold</code>. 
<code>Rsquared</code> is explained as follows and see <code><a href="#topic+LocDenReg">LocDenReg</a></code> for the other options.
</p>

<dl>
<dt>Rsquared</dt><dd><p>A logical variable indicating whether R squared would be returned. Default is <code>FALSE</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>xout</code></td>
<td>
<p>Input <code>xout</code>.</p>
</td></tr>
<tr><td><code>dout</code></td>
<td>
<p>A matrix or list holding the output densities corresponding to <code>xout</code>. If <code>dout</code> is a matrix, each row gives a density and the domain grid is given in <code>dSup</code>. If <code>dout</code> is a list, each element is a list of two components, <code>x</code> and <code>y</code>, giving the domain grid and density function values, respectively.</p>
</td></tr>
<tr><td><code>dSup</code></td>
<td>
<p>A numeric vector giving the domain grid of <code>dout</code> when it is a matrix.</p>
</td></tr>
<tr><td><code>qout</code></td>
<td>
<p>A matrix holding the quantile functions of the output densities. Each row corresponds to a value in <code>xout</code>.</p>
</td></tr>
<tr><td><code>qSup</code></td>
<td>
<p>A numeric vector giving the domain grid of <code>qout</code>.</p>
</td></tr>
<tr><td><code>xin</code></td>
<td>
<p>Input <code>xin</code>.</p>
</td></tr>
<tr><td><code>din</code></td>
<td>
<p>Densities corresponding to the input <code>yin</code>, <code>hin</code> or <code>qin</code>.</p>
</td></tr>
<tr><td><code>qin</code></td>
<td>
<p>Quantile functions corresponding to the input <code>yin</code>, <code>hin</code> or <code>qin</code>.</p>
</td></tr>
<tr><td><code>Rsq</code></td>
<td>
<p>A scalar giving the R squared value if <code>optns$Rsquared = TRUE</code>.</p>
</td></tr>
<tr><td><code>optns</code></td>
<td>
<p>A list of control options used.</p>
</td></tr>
</table>


<h3>References</h3>

<p><cite>Petersen, A., &amp; Müller, H.-G. (2019). &quot;Fréchet regression for random objects with Euclidean predictors.&quot; The Annals of Statistics, 47(2), 691&ndash;719.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xin = seq(0,1,0.05)
yin = lapply(xin, function(x) {
  rnorm(100, rnorm(1,x,0.005), 0.05)
})
qSup = seq(0,1,0.02)
xout = seq(0,1,0.25)
res1 &lt;- GloDenReg(xin=xin, yin=yin, xout=xout, optns = list(qSup = qSup))
plot(res1)

hin = lapply(yin, function(y) hist(y, breaks = 50, plot=FALSE))
res2 &lt;- GloDenReg(xin=xin, hin=hin, xout=xout, optns = list(qSup = qSup))
plot(res2)

</code></pre>

<hr>
<h2 id='GloPointPrReg'>Global Cox point process regression.</h2><span id='topic+GloPointPrReg'></span>

<h3>Description</h3>

<p>Global Fréchet regression for replicated Cox point processes with respect to <code class="reqn">L^2</code>-Wasserstein distance on shape space and Euclidean 2-norm on intensity factor space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GloPointPrReg(xin = NULL, tin = NULL, T0 = NULL, xout = NULL, optns = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GloPointPrReg_+3A_xin">xin</code></td>
<td>
<p>An n by p matrix with input measurements of the predictors.</p>
</td></tr>
<tr><td><code id="GloPointPrReg_+3A_tin">tin</code></td>
<td>
<p>A list holding the sample of event times of each replicated point process, where the ith element of the list <code>tin</code> holds the event times of the point process corresponding to the ith row of <code>xin</code>.</p>
</td></tr>
<tr><td><code id="GloPointPrReg_+3A_t0">T0</code></td>
<td>
<p>A positive scalar that defines the time window [0,<code>T0</code>] where the replicated Cox point processes are observed.</p>
</td></tr>
<tr><td><code id="GloPointPrReg_+3A_xout">xout</code></td>
<td>
<p>A k by p matrix with output measurements of the predictors. Default is <code>xin</code>.</p>
</td></tr>
<tr><td><code id="GloPointPrReg_+3A_optns">optns</code></td>
<td>
<p>A list of control parameters specified by <code>list(name=value)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available control options are <code>bwDen</code> (see <code><a href="#topic+LocDenReg">LocDenReg</a></code> for this option description) and
</p>

<dl>
<dt>L</dt><dd><p>Upper Lipschitz constant for quantile space; numeric -default: 1e10.</p>
</dd>
<dt>M</dt><dd><p>Lower Lipschitz constant for quantile space; numeric -default: 1e-10.</p>
</dd>
<dt>dSup</dt><dd><p>User defined output grid for the support of kernel density estimation used in <code>CreateDensity()</code> for mapping from quantile space to shape space. This grid must be in [0,<code>T0</code>]. Default is an equidistant grid with <code>nqSup</code>+2 points.</p>
</dd>
<dt>nqSup</dt><dd><p>A scalar with the number of equidistant points in (0,1) used to obtain the empirical quantile function from each point process. Default: 500.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>xout</code></td>
<td>
<p>Input <code>xout</code>.</p>
</td></tr>
<tr><td><code>dSup</code></td>
<td>
<p>Support of each estimated (up to a constant) conditional intensity regression function in the columns of <code>intensityReg</code>.</p>
</td></tr>
<tr><td><code>intensityReg</code></td>
<td>
<p>A matrix of dimension <code>length(dSup)</code> by <code>nrow(xout)</code> holding the estimated intensity regression functions up to a constant over the support grid <code>dSup</code>, where each column corresponds to a predictor level in the corresponding row of <code>xout</code>.</p>
</td></tr>
<tr><td><code>xin</code></td>
<td>
<p>Input <code>xin</code>.</p>
</td></tr>
<tr><td><code>optns</code></td>
<td>
<p>A list of control options used.</p>
</td></tr>
</table>


<h3>References</h3>

<p><cite>Petersen, A., &amp; Müller, H.-G. (2019). &quot;Fréchet regression for random objects with Euclidean predictors.&quot; The Annals of Statistics, 47(2), 691&ndash;719.</cite>
</p>
<p><cite>Gajardo, Á. and Müller, H.-G. (2022). &quot;Cox Point Process Regression.&quot; IEEE Transactions on Information Theory, 68(2), 1133-1156.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n=100
alpha_n=sqrt(n)
alpha1=2.0
beta1=1.0
gridQ=seq(0,1,length.out=500+2)[2:(500+1)]
X=runif(n,0,1)#p=1
tau=matrix(0,nrow=n,ncol=1)
for(i in 1:n){
  tau[i]=alpha1+beta1*X[i]+truncnorm::rtruncnorm(1, a=-0.3, b=0.3, mean = 0, sd = 1.0)
}
Ni_n=matrix(0,nrow=n,ncol=1)
u0=0.4
u1=0.5
u2=0.05
u3=-0.01
tin=list()
for(i in 1:n){
  Ni_n[i]=rpois(1,alpha_n*tau[i])
  mu_x=u0+u1*X[i]+truncnorm::rtruncnorm(1,a=-0.1,b=0.1,mean=0,sd=1)
  sd_x=u2+u3*X[i]+truncnorm::rtruncnorm(1,a=-0.02,b=0.02,mean=0,sd=0.5)
  if(Ni_n[i]==0){
    tin[[i]]=c()
  }else{
    tin[[i]]=truncnorm::rtruncnorm(Ni_n[i],a=0,b=1,mean=mu_x,sd=sd_x) #Sample from truncated normal
  }
}
res=GloPointPrReg(
  xin=matrix(X,ncol=1),tin=tin,
  T0=1,xout=matrix(seq(0,1,length.out=10),ncol=1),
  optns=list(bwDen=0.1)
)

</code></pre>

<hr>
<h2 id='GloSpheReg'>Global Fréchet Regression for Spherical Data</h2><span id='topic+GloSpheReg'></span>

<h3>Description</h3>

<p>Global Fréchet regression for spherical data with respect to the geodesic distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GloSpheReg(xin = NULL, yin = NULL, xout = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GloSpheReg_+3A_xin">xin</code></td>
<td>
<p>A vector of length <code class="reqn">n</code> or an <code class="reqn">n</code>-by-<code class="reqn">p</code> matrix with input measurement points.</p>
</td></tr>
<tr><td><code id="GloSpheReg_+3A_yin">yin</code></td>
<td>
<p>An <code class="reqn">n</code>-by-<code class="reqn">m</code> matrix holding the spherical data, of which the sum of squares of elements within each row is 1.</p>
</td></tr>
<tr><td><code id="GloSpheReg_+3A_xout">xout</code></td>
<td>
<p>A vector of length <code class="reqn">k</code> or an <code class="reqn">k</code>-by-<code class="reqn">p</code>  with output measurement points; Default: the same grid as given in <code>xin</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>xout</code></td>
<td>
<p>Input <code>xout</code>.</p>
</td></tr>
<tr><td><code>yout</code></td>
<td>
<p>A <code class="reqn">k</code>-by-<code class="reqn">m</code> matrix holding the fitted responses, of which each row is a spherical vector, corresponding to each element in <code>xout</code>.</p>
</td></tr>
<tr><td><code>xin</code></td>
<td>
<p>Input <code>xin</code>.</p>
</td></tr>
<tr><td><code>yin</code></td>
<td>
<p>Input <code>yin</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p><cite>Petersen, A., &amp; Müller, H.-G. (2019). &quot;Fréchet regression for random objects with Euclidean predictors.&quot; The Annals of Statistics, 47(2), 691&ndash;719.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 101
xin &lt;- seq(-1,1,length.out = n)
theta_true &lt;- rep(pi/2,n)
phi_true &lt;- (xin + 1) * pi / 4
ytrue &lt;- apply( cbind( 1, phi_true, theta_true ), 1, pol2car )
yin &lt;- t( ytrue )
xout &lt;- xin
res &lt;- GloSpheReg(xin=xin, yin=yin, xout=xout)

</code></pre>

<hr>
<h2 id='LocCorReg'>Local Fréchet regression for correlation matrices</h2><span id='topic+LocCorReg'></span>

<h3>Description</h3>

<p>Local Fréchet regression for correlation matrices
with Euclidean predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LocCorReg(x, M, xOut = NULL, optns = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LocCorReg_+3A_x">x</code></td>
<td>
<p>an n by p matrix or data frame of predictors.</p>
</td></tr>
<tr><td><code id="LocCorReg_+3A_m">M</code></td>
<td>
<p>a q by q by n array (resp. a list of q by q matrices) where
<code>M[, , i]</code> (resp. <code>M[[i]]</code>) contains the i-th correlation matrix
of dimension q by q.</p>
</td></tr>
<tr><td><code id="LocCorReg_+3A_xout">xOut</code></td>
<td>
<p>an m by p matrix or data frame of output predictor levels.
It can be a vector of length p if m = 1.</p>
</td></tr>
<tr><td><code id="LocCorReg_+3A_optns">optns</code></td>
<td>
<p>A list of options control parameters specified by
<code>list(name=value)</code>. See &lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available control options are
</p>

<dl>
<dt>metric</dt><dd><p>choice of metric. <code>'frobenius'</code> and <code>'power'</code> are supported,
which corresponds to Frobenius metric and Euclidean power metric,
respectively. Default is Frobenius metric.</p>
</dd>
<dt>alpha</dt><dd><p>the power for Euclidean power metric. Default is 1 which
corresponds to Frobenius metric.</p>
</dd>
<dt>kernel</dt><dd><p>Name of the kernel function to be chosen from <code>'gauss'</code>,
<code>'rect'</code>, <code>'epan'</code>, <code>'gausvar'</code> and <code>'quar'</code>. Default is <code>'gauss'</code>.</p>
</dd>
<dt>bw</dt><dd><p>bandwidth for local Fréchet regression, if not entered
it would be chosen from cross validation.</p>
</dd>
<dt>digits</dt><dd><p>the integer indicating the number of decimal places (round)
to be kept in the output. Default is NULL, which means no round operation.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code>corReg</code> object &mdash; a list containing the following fields:
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p>a list of estimated correlation matrices at <code>x</code>.</p>
</td></tr>
<tr><td><code>predict</code></td>
<td>
<p>a list of estimated correlation matrices at <code>xOut</code>.
Included if <code>xOut</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Frobenius distance between the true and
fitted correlation matrices.</p>
</td></tr>
<tr><td><code>xOut</code></td>
<td>
<p>the output predictor level used.</p>
</td></tr>
<tr><td><code>optns</code></td>
<td>
<p>the control options used.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li> <p><cite>Petersen, A. and Müller, H.-G. (2019). Fréchet regression for random objects with Euclidean predictors. The Annals of Statistics, 47(2), 691&ndash;719.</cite>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Generate simulation data

n &lt;- 100
q &lt;- 10
d &lt;- q * (q - 1) / 2
xOut &lt;- seq(0.1, 0.9, length.out = 9)
x &lt;- runif(n, min = 0, max = 1)
y &lt;- list()
for (i in 1:n) {
  yVec &lt;- rbeta(d, shape1 = sin(pi * x[i]), shape2 = 1 - sin(pi * x[i]))
  y[[i]] &lt;- matrix(0, nrow = q, ncol = q)
  y[[i]][lower.tri(y[[i]])] &lt;- yVec
  y[[i]] &lt;- y[[i]] + t(y[[i]])
  diag(y[[i]]) &lt;- 1
}
# Frobenius metric
fit1 &lt;- LocCorReg(x, y, xOut,
  optns = list(metric = "frobenius", digits = 2)
)
# Euclidean power metric
fit2 &lt;- LocCorReg(x, y, xOut,
  optns = list(
    metric = "power", alpha = .5,
    kernel = "epan", bw = 0.08
  )
)

</code></pre>

<hr>
<h2 id='LocCovReg'>Local Fréchet regression of covariance matrices</h2><span id='topic+LocCovReg'></span>

<h3>Description</h3>

<p>Local Fréchet regression of covariance matrices with Euclidean predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LocCovReg(x, y = NULL, M = NULL, xout, optns = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LocCovReg_+3A_x">x</code></td>
<td>
<p>An n by p matrix of predictors.</p>
</td></tr>
<tr><td><code id="LocCovReg_+3A_y">y</code></td>
<td>
<p>An n by l matrix, each row corresponds to an observation, l is the length of time points where the responses are observed.  See 'metric' option in 'Details' for more details.</p>
</td></tr>
<tr><td><code id="LocCovReg_+3A_m">M</code></td>
<td>
<p>A q by q by n array (resp. a list of q by q matrices) where <code>M[,,i]</code> (resp. <code>M[[i]]</code>) contains the i-th covariance matrix of dimension q by q. See 'metric' option in 'Details' for more details.</p>
</td></tr>
<tr><td><code id="LocCovReg_+3A_xout">xout</code></td>
<td>
<p>An m by p matrix of output predictor levels.</p>
</td></tr>
<tr><td><code id="LocCovReg_+3A_optns">optns</code></td>
<td>
<p>A list of options control parameters specified by <code>list(name=value)</code>. See &lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available control options are
</p>

<dl>
<dt>corrOut</dt><dd><p>Boolean indicating if output is shown as correlation or covariance matrix. Default is <code>FALSE</code> and corresponds to a covariance matrix.</p>
</dd>
<dt>metric</dt><dd><p>Metric type choice, <code>"frobenius"</code>, <code>"power"</code>, <code>"log_cholesky"</code>, <code>"cholesky"</code> - default: <code>"frobenius"</code> which corresponds to the power metric with <code>alpha</code> equal to 1.
For power (and Frobenius) metrics, either <code>y</code> or <code>M</code> must be input; <code>y</code> would override <code>M</code>. For Cholesky and log-Cholesky metrics, <code>M</code> must be input and <code>y</code> does not apply.</p>
</dd>
<dt>alpha</dt><dd><p>The power parameter for the power metric. Default is 1 which corresponds to Frobenius metric.</p>
</dd>
<dt>bwMean</dt><dd><p>A vector of length p holding the bandwidths for conditional mean estimation if <code>y</code> is provided. If <code>bwMean</code> is not provided, it is chosen by cross validation.</p>
</dd>
<dt>bwCov</dt><dd><p>A vector of length p holding the bandwidths for conditional covariance estimation. If <code>bwCov</code> is not provided, it is chosen by cross validation.</p>
</dd>
<dt>kernel</dt><dd><p>Name of the kernel function to be chosen from <code>"rect"</code>, <code>"gauss"</code>, <code>"epan"</code>, <code>"gausvar"</code>, <code>"quar"</code>. Default is <code>"gauss"</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code>covReg</code> object &mdash; a list containing the following fields:
</p>
<table>
<tr><td><code>xout</code></td>
<td>
<p>An m by p matrix of output predictor levels.</p>
</td></tr>
<tr><td><code>Mout</code></td>
<td>
<p>A list of estimated conditional covariance or correlation matrices at <code>xout</code>.</p>
</td></tr>
<tr><td><code>optns</code></td>
<td>
<p>A list containing the <code>optns</code> parameters utilized.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li> <p><cite>Petersen, A. and Müller, H.-G. (2019). Fréchet regression for random objects with Euclidean predictors. The Annals of Statistics, 47(2), 691&ndash;719.</cite>
</p>
</li>
<li> <p><cite>Petersen, A., Deoni, S. and Müller, H.-G. (2019). Fréchet estimation of time-varying covariance matrices from sparse data, with application to the regional co-evolution of myelination in the developing brain. The Annals of Applied Statistics, 13(1), 393&ndash;419.</cite>
</p>
</li>
<li> <p><cite>Lin, Z. (2019). Riemannian geometry of symmetric positive definite matrices via Cholesky decomposition. Siam. J. Matrix. Anal, A. 40, 1353&ndash;1370.</cite>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
#Example y input
n=30             # sample size
t=seq(0,1,length.out=100)       # length of data
x = matrix(runif(n),n)
theta1 = theta2 = array(0,n)
for(i in 1:n){
 theta1[i] = rnorm(1,x[i],x[i]^2)
 theta2[i] = rnorm(1,x[i]/2,(1-x[i])^2)
}
y = matrix(0,n,length(t))
phi1 = sqrt(3)*t
phi2 = sqrt(6/5)*(1-t/2)
y = theta1%*%t(phi1) + theta2 %*% t(phi2)
xout = matrix(c(0.25,0.5,0.75),3)
Cov_est=LocCovReg(x=x,y=y,xout=xout,optns=list(corrOut=FALSE,metric="power",alpha=3))

#Example M input
n=30 #sample size
m=30 #dimension of covariance matrices
M &lt;- array(0,c(m,m,n))
for (i in 1:n){
 y0=rnorm(m)
 aux&lt;-15*diag(m)+y0%*%t(y0)
 M[,,i]&lt;-aux
}
x=matrix(rnorm(n),n)
xout = matrix(c(0.25,0.5,0.75),3) #output predictor levels
Cov_est=LocCovReg(x=x,M=M,xout=xout,optns=list(corrOut=FALSE,metric="power",alpha=0))

</code></pre>

<hr>
<h2 id='LocDenReg'>Local density regression.</h2><span id='topic+LocDenReg'></span>

<h3>Description</h3>

<p>Local Fréchet regression for densities with respect to <code class="reqn">L^2</code>-Wasserstein distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LocDenReg(
  xin = NULL,
  yin = NULL,
  hin = NULL,
  qin = NULL,
  xout = NULL,
  optns = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LocDenReg_+3A_xin">xin</code></td>
<td>
<p>An n by p matrix or a vector of length n if p=1 holding the n observations of the predictor.</p>
</td></tr>
<tr><td><code id="LocDenReg_+3A_yin">yin</code></td>
<td>
<p>A matrix or list holding the sample of observations of the response. If <code>yin</code> is a matrix, each row holds the observations of the response corresponding to a predictor value in the corresponding row of <code>xin</code>.</p>
</td></tr>
<tr><td><code id="LocDenReg_+3A_hin">hin</code></td>
<td>
<p>A list holding the histograms of the response corresponding to each predictor value in the corresponding row of <code>xin</code>.</p>
</td></tr>
<tr><td><code id="LocDenReg_+3A_qin">qin</code></td>
<td>
<p>A matrix or list holding the quantile functions of the response. If <code>qin</code> is a matrix, the support of the quantile functions should be the same (i.e., <code>optns$qSup</code>), and each row of <code>qin</code> holds the quantile function corresponding to a predictor value in the corresponding row of <code>xin</code>. If the quantile functions are evaluated on different grids, then <code>qin</code> should be a list, each element consisting of two components <code>x</code> and <code>y</code> holding the support grid and the corresponding values of the quantile functions, respectively.
Note that only one of the three <code>yin</code>, <code>hin</code>, and <code>qin</code> needs to be input.
If more than one of them are specified, <code>yin</code> overwrites <code>hin</code>, and <code>hin</code> overwrites <code>qin</code>.</p>
</td></tr>
<tr><td><code id="LocDenReg_+3A_xout">xout</code></td>
<td>
<p>An m by p matrix or a vector of length m if p=1 holding the m output predictor values. Default is <code>xin</code>.</p>
</td></tr>
<tr><td><code id="LocDenReg_+3A_optns">optns</code></td>
<td>
<p>A list of control parameters specified by <code>list(name=value)</code>. See &lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available control options are
</p>

<dl>
<dt>bwReg</dt><dd><p>A vector of length p used as the bandwidth for the Fréchet regression or <code>"CV"</code> (default), i.e., a data-adaptive selection done by cross-validation.</p>
</dd>
<dt>kernelReg</dt><dd><p>A character holding the type of kernel functions for local Fréchet regression for densities; <code>"rect"</code>, <code>"gauss"</code>, <code>"epan"</code>, <code>"gausvar"</code>, <code>"quar"</code> - default: <code>"gauss"</code>.</p>
</dd>
<dt>qSup</dt><dd><p>A numeric vector holding the grid on [0,1] quantile functions take value on. Default is an equidistant grid.</p>
</dd>
<dt>nqSup</dt><dd><p>A scalar giving the length of <code>qSup</code>. Default is 201.</p>
</dd>
<dt>lower</dt><dd><p>A scalar with the lower bound of the support of the distribution. Default is <code>NULL</code>.</p>
</dd>
<dt>upper</dt><dd><p>A scalar with the upper bound of the support of the distribution. Default is <code>NULL</code>.</p>
</dd>
<dt>bwRange</dt><dd><p>A 2 by p matrix whose columns contain the bandwidth selection range for each corresponding dimension of the predictor <code>xin</code> for the case when <code>bwReg</code> equals <code>"CV"</code>. Default is <code>NULL</code> and is automatically chosen by a data-adaptive method.</p>
</dd>
<dt>bwDen</dt><dd><p>The bandwidth value used in <code>CreateDensity()</code> for density estimation; positive numeric - default: determine automatically based on the data-driven bandwidth selector proposed by Sheather and Jones (1991).</p>
</dd>
<dt>ndSup</dt><dd><p>The number of support points the kernel density estimation uses in <code>CreateDensity()</code>; numeric - default: 101.</p>
</dd>
<dt>dSup</dt><dd><p>User defined output grid for the support of kernel density estimation used in <code>CreateDensity()</code>, it overrides <code>nRegGrid</code>; numeric - default: <code>NULL</code></p>
</dd>
<dt>delta</dt><dd><p>The size of the bin to be used used in <code>CreateDensity()</code>; numeric - default: <code>diff(range(y))/1000</code>. It only works when the raw sample is available.</p>
</dd>
<dt>kernelDen</dt><dd><p>A character holding the type of kernel functions used in <code>CreateDensity()</code> for density estimation; <code>"rect"</code>, <code>"gauss"</code>, <code>"epan"</code>, <code>"gausvar"</code>, <code>"quar"</code> - default: <code>"gauss"</code>.</p>
</dd>
<dt>infSupport</dt><dd><p>logical if we expect the distribution to have infinite support or not, used in <code>CreateDensity()</code> for density estimation; logical - default: <code>FALSE</code></p>
</dd>
<dt>denLowerThreshold</dt><dd><p><code>FALSE</code> or a positive value giving the lower threshold of the densities used in <code>CreateDensity()</code>; default: <code>0.001 * mean(qin[,ncol(qin)] - qin[,1])</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>xout</code></td>
<td>
<p>Input <code>xout</code>.</p>
</td></tr>
<tr><td><code>dout</code></td>
<td>
<p>A matrix or list holding the output densities corresponding to <code>xout</code>. If <code>dout</code> is a matrix, each row gives a density and the domain grid is given in <code>dSup</code>. If <code>dout</code> is a list, each element is a list of two components, <code>x</code> and <code>y</code>, giving the domain grid and density function values, respectively.</p>
</td></tr>
<tr><td><code>dSup</code></td>
<td>
<p>A numeric vector giving the domain grid of <code>dout</code> when it is a matrix.</p>
</td></tr>
<tr><td><code>qout</code></td>
<td>
<p>A matrix holding the quantile functions of the output densities. Each row corresponds to a value in <code>xout</code>.</p>
</td></tr>
<tr><td><code>qSup</code></td>
<td>
<p>A numeric vector giving the domain grid of <code>qout</code>.</p>
</td></tr>
<tr><td><code>xin</code></td>
<td>
<p>Input <code>xin</code>.</p>
</td></tr>
<tr><td><code>din</code></td>
<td>
<p>Densities corresponding to the input <code>yin</code>, <code>hin</code> or <code>qin</code>.</p>
</td></tr>
<tr><td><code>qin</code></td>
<td>
<p>Quantile functions corresponding to the input <code>yin</code>, <code>hin</code> or <code>qin</code>.</p>
</td></tr>
<tr><td><code>optns</code></td>
<td>
<p>A list of control options used.</p>
</td></tr>
</table>


<h3>References</h3>

<p><cite>Petersen, A., &amp; Müller, H.-G. (2019). &quot;Fréchet regression for random objects with Euclidean predictors.&quot; The Annals of Statistics, 47(2), 691&ndash;719.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
xin = seq(0,1,0.05)
yin = lapply(xin, function(x) {
  rnorm(100, rnorm(1,x + x^2,0.005), 0.05)
})
qSup = seq(0,1,0.02)
xout = seq(0,1,0.1)
res1 &lt;- LocDenReg(xin=xin, yin=yin, xout=xout, optns = list(bwReg = 0.12, qSup = qSup))
plot(res1)
xout &lt;- xin
hin = lapply(yin, function(y) hist(y, breaks = 50))
res2 &lt;- LocDenReg(xin=xin, hin=hin, xout=xout, optns = list(qSup = qSup))
plot(res2)

</code></pre>

<hr>
<h2 id='LocPointPrReg'>Local Cox point process regression.</h2><span id='topic+LocPointPrReg'></span>

<h3>Description</h3>

<p>Local Fréchet regression for replicated Cox point processes with respect to <code class="reqn">L^2</code>-Wasserstein distance on shape space and Euclidean 2-norm on intensity factor space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LocPointPrReg(xin = NULL, tin = NULL, T0 = NULL, xout = NULL, optns = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LocPointPrReg_+3A_xin">xin</code></td>
<td>
<p>An n by p matrix with input measurements of the predictors, where p is at most 2.</p>
</td></tr>
<tr><td><code id="LocPointPrReg_+3A_tin">tin</code></td>
<td>
<p>A list holding the sample of event times of each replicated point process, where the ith element of the list <code>tin</code> holds the event times of the point process corresponding to the ith row of <code>xin</code>.</p>
</td></tr>
<tr><td><code id="LocPointPrReg_+3A_t0">T0</code></td>
<td>
<p>A positive scalar that defines the time window [0,<code>T0</code>] where the replicated Cox point processes are observed.</p>
</td></tr>
<tr><td><code id="LocPointPrReg_+3A_xout">xout</code></td>
<td>
<p>A k by p matrix with output measurements of the predictors. Default is <code>xin</code>.</p>
</td></tr>
<tr><td><code id="LocPointPrReg_+3A_optns">optns</code></td>
<td>
<p>A list of control parameters specified by <code>list(name=value)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available control options are <code>bwDen</code>, <code>kernelReg</code> (see <code><a href="#topic+LocDenReg">LocDenReg</a></code> for these option descriptions) and
</p>

<dl>
<dt>L</dt><dd><p>Upper Lipschitz constant for quantile space; numeric -default: 1e10.</p>
</dd>
<dt>M</dt><dd><p>Lower Lipschitz constant for quantile space; numeric -default: 1e-10.</p>
</dd>
<dt>dSup</dt><dd><p>User defined output grid for the support of kernel density estimation used in <code>CreateDensity()</code> for mapping from quantile space to shape space. This grid must be in [0,<code>T0</code>]. Default is an equidistant with <code>nqSup</code>+2 points.</p>
</dd>
<dt>nqSup</dt><dd><p>A scalar with the number of equidistant points in (0,1) used to obtain the empirical quantile function from each point process. Default: 500.</p>
</dd>
<dt>bwReg</dt><dd><p>A vector of length p used as the bandwidth for the Fréchet regression or <code>"CV"</code> (default), i.e., a data-adaptive selection done by leave-one-out cross-validation.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>xout</code></td>
<td>
<p>Input <code>xout</code>.</p>
</td></tr>
<tr><td><code>dSup</code></td>
<td>
<p>Support of each estimated (up to a constant) conditional intensity regression function in the columns of <code>intensityReg</code>.</p>
</td></tr>
<tr><td><code>intensityReg</code></td>
<td>
<p>A matrix of dimension <code>length(dSup)</code> by <code>nrow(xout)</code> holding the estimated intensity regression functions up to a constant over the support grid <code>dSup</code>, where each column corresponds to a predictor level in the corresponding row of <code>xout</code>.</p>
</td></tr>
<tr><td><code>xin</code></td>
<td>
<p>Input <code>xin</code>.</p>
</td></tr>
<tr><td><code>optns</code></td>
<td>
<p>A list of control options used.</p>
</td></tr>
</table>


<h3>References</h3>

<p><cite>Petersen, A., &amp; Müller, H.-G. (2019). &quot;Fréchet regression for random objects with Euclidean predictors.&quot; The Annals of Statistics, 47(2), 691&ndash;719.</cite>
</p>
<p><cite>Gajardo, Á. and Müller, H.-G. (2022). &quot;Cox Point Process Regression.&quot; IEEE Transactions on Information Theory, 68(2), 1133-1156.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n=100
alpha_n=sqrt(n)
alpha1=2.0
beta1=1.0
gridQ=seq(0,1,length.out=500+2)[2:(500+1)]
X=runif(n,0,1)#p=1
tau=matrix(0,nrow=n,ncol=1)
for(i in 1:n){
  tau[i]=alpha1+beta1*X[i]+truncnorm::rtruncnorm(1, a=-0.3, b=0.3, mean = 0, sd = 1.0)
}
Ni_n=matrix(0,nrow=n,ncol=1)
u0=0.4
u1=0.5
u2=0.05
u3=-0.01
tin=list()
for(i in 1:n){
  Ni_n[i]=rpois(1,alpha_n*tau[i])
  mu_x=u0+u1*X[i]+truncnorm::rtruncnorm(1,a=-0.1,b=0.1,mean=0,sd=1)
  sd_x=u2+u3*X[i]+truncnorm::rtruncnorm(1,a=-0.02,b=0.02,mean=0,sd=0.5)
  if(Ni_n[i]==0){
    tin[[i]]=c()
  }else{
    tin[[i]]=truncnorm::rtruncnorm(Ni_n[i],a=0,b=1,mean=mu_x,sd=sd_x) #Sample from truncated normal
  }
}
res=LocPointPrReg(
  xin=matrix(X,ncol=1),
  tin=tin,T0=1,xout=matrix(seq(0,1,length.out=10),ncol=1),
  optns=list(bwDen=0.1,bwReg=0.1)
)

</code></pre>

<hr>
<h2 id='LocSpheReg'>Local Fréchet Regression for Spherical Data</h2><span id='topic+LocSpheReg'></span>

<h3>Description</h3>

<p>Local Fréchet regression for spherical data with respect to the geodesic distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LocSpheReg(xin = NULL, yin = NULL, xout = NULL, optns = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LocSpheReg_+3A_xin">xin</code></td>
<td>
<p>A vector of length n with input measurement points.</p>
</td></tr>
<tr><td><code id="LocSpheReg_+3A_yin">yin</code></td>
<td>
<p>An n by m matrix holding the spherical data, of which the sum of squares of elements within each row is 1.</p>
</td></tr>
<tr><td><code id="LocSpheReg_+3A_xout">xout</code></td>
<td>
<p>A vector of length k with output measurement points; Default: <code>xout = xin</code>.</p>
</td></tr>
<tr><td><code id="LocSpheReg_+3A_optns">optns</code></td>
<td>
<p>A list of options control parameters specified by <code>list(name=value)</code>. See &lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available control options are
</p>

<dl>
<dt>bw</dt><dd><p>A scalar used as the bandwidth or <code>"CV"</code> (default).</p>
</dd>
<dt>kernel</dt><dd><p>A character holding the type of kernel functions for local Fréchet regression for densities; <code>"rect"</code>, <code>"gauss"</code>, <code>"epan"</code>, <code>"gausvar"</code>, <code>"quar"</code> - default: <code>"gauss"</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>xout</code></td>
<td>
<p>Input <code>xout</code>.</p>
</td></tr>
<tr><td><code>yout</code></td>
<td>
<p>A k by m matrix holding the fitted responses, of which each row is a spherical vector, corresponding to each element in <code>xout</code>.</p>
</td></tr>
<tr><td><code>xin</code></td>
<td>
<p>Input <code>xin</code>.</p>
</td></tr>
<tr><td><code>yin</code></td>
<td>
<p>Input <code>yin</code>.</p>
</td></tr>
<tr><td><code>optns</code></td>
<td>
<p>A list of control options used.</p>
</td></tr>
</table>


<h3>References</h3>

<p><cite>Petersen, A., &amp; Müller, H.-G. (2019). &quot;Fréchet regression for random objects with Euclidean predictors.&quot; The Annals of Statistics, 47(2), 691&ndash;719.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 200
# simulate the data according to the simulation in Petersen &amp; Müller (2019)
xin &lt;- runif(n)
err_sd &lt;- 0.2
xout &lt;- seq(0,1,length.out = 51)

phi_true &lt;- acos(xin)
theta_true &lt;- pi * xin
ytrue &lt;- cbind(
  sin(phi_true) * cos(theta_true),
  sin(phi_true) * sin(theta_true),
  cos(phi_true)
)
basis &lt;- list(
  b1 = cbind(
    cos(phi_true) * cos(theta_true),
    cos(phi_true) * sin(theta_true),
    -sin(phi_true)
  ),
  b2 = cbind(
    sin(theta_true),
    -cos(theta_true),
    0
  )
)
yin_tg &lt;- basis$b1 * rnorm(n, mean = 0, sd = err_sd) + 
  basis$b2 * rnorm(n, mean = 0, sd = err_sd)
yin &lt;- t(sapply(seq_len(n), function(i) {
  tgNorm &lt;- sqrt(sum(yin_tg[i,]^2))
  if (tgNorm &lt; 1e-10) {
    return(ytrue[i,])
  } else {
    return(sin(tgNorm) * yin_tg[i,] / tgNorm + cos(tgNorm) * ytrue[i,])
  }
}))

res &lt;- LocSpheReg(xin=xin, yin=yin, xout=xout, optns = list(bw = 0.15, kernel = "epan"))

</code></pre>

<hr>
<h2 id='logSphere'>Compute a log map for a unit hypersphere.</h2><span id='topic+logSphere'></span>

<h3>Description</h3>

<p>Compute a log map for a unit hypersphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logSphere(base, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logSphere_+3A_base">base</code></td>
<td>
<p>A unit vector of length <code class="reqn">m</code> holding the base point of the tangent space.</p>
</td></tr>
<tr><td><code id="logSphere_+3A_x">x</code></td>
<td>
<p>A unit vector of length <code class="reqn">m</code> which the log map is taken.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tangent vector of length <code class="reqn">m</code>.
</p>

<hr>
<h2 id='NetANOVA'>Fréchet ANOVA for Networks</h2><span id='topic+NetANOVA'></span>

<h3>Description</h3>

<p>Fréchet analysis of variance for graph Laplacian matrices, 
covariance matrices, or correlation matrices 
with respect to the Frobenius distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NetANOVA(Ly = NULL, group = NULL, optns = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NetANOVA_+3A_ly">Ly</code></td>
<td>
<p>A list (length n) of m by m matrices or a m by m by n array where
<code>Ly[, , i]</code> contains an m by m matrix, which can be either graph 
Laplacian matrices or covariance matrices or correlation matrices.</p>
</td></tr>
<tr><td><code id="NetANOVA_+3A_group">group</code></td>
<td>
<p>A vector containing the group memberships of the corresponding 
matrices in <code>Ly</code>.</p>
</td></tr>
<tr><td><code id="NetANOVA_+3A_optns">optns</code></td>
<td>
<p>A list of control parameters specified by 
<code>list(name = value)</code>. See 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available control options are:
</p>

<dl>
<dt>boot</dt><dd><p>Logical, also compute bootstrap <code class="reqn">p</code>-value if <code>TRUE</code>. 
Default is <code>FALSE</code>.</p>
</dd>
<dt>R</dt><dd><p>The number of bootstrap replicates. Only used when <code>boot</code> 
is <code>TRUE</code>. Default is 1000.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code>NetANOVA</code> object &mdash; a list containing the following fields:
</p>
<table>
<tr><td><code>pvalAsy</code></td>
<td>
<p>A scalar holding the asymptotic <code class="reqn">p</code>-value.</p>
</td></tr>
<tr><td><code>pvalBoot</code></td>
<td>
<p>A scalar holding the bootstrap <code class="reqn">p</code>-value. 
Returned if <code>optns$boot</code> is TRUE.</p>
</td></tr>
<tr><td><code>optns</code></td>
<td>
<p>The control options used.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li> <p><cite>Dubey, P. and Müller, H.G., 2019. Fréchet analysis of variance for random objects. Biometrika, 106(4), pp.803-821.</cite>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n1 &lt;- 100
n2 &lt;- 100
gamma1 &lt;- 2
gamma2 &lt;- 3
Y1 &lt;- lapply(1:n1, function(i) {
  igraph::laplacian_matrix(igraph::sample_pa(n = 10, power = gamma1, 
                                             directed = FALSE), 
                           sparse = FALSE)
})
Y2 &lt;- lapply(1:n2, function(i) {
  igraph::laplacian_matrix(igraph::sample_pa(n = 10, power = gamma2, 
                                             directed = FALSE), 
                           sparse = FALSE)
})
Ly &lt;- c(Y1, Y2)
group &lt;- c(rep(1, n1), rep(2, n2))
res &lt;- NetANOVA(Ly, group, optns = list(boot = TRUE))
res$pvalAsy # returns asymptotic pvalue
res$pvalBoot # returns bootstrap pvalue

</code></pre>

<hr>
<h2 id='NetCPD'>Fréchet Change Point Detection for Networks</h2><span id='topic+NetCPD'></span>

<h3>Description</h3>

<p>Fréchet change point detection for graph Laplacian matrices, 
covariance matrices, or correlation matrices 
with respect to the Frobenius distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NetCPD(Ly = NULL, optns = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NetCPD_+3A_ly">Ly</code></td>
<td>
<p>A list (length n) of m by m matrices or a m by m by n array where
<code>Ly[, , i]</code> contains an m by m matrix, which can be either graph 
Laplacian matrices or covariance matrices or correlation matrices.</p>
</td></tr>
<tr><td><code id="NetCPD_+3A_optns">optns</code></td>
<td>
<p>A list of control parameters specified by 
<code>list(name = value)</code>. See 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available control options are:
</p>

<dl>
<dt>cutOff</dt><dd><p>A scalar between 0 and 1 indicating the interval,
i.e., [cutOff, 1 - cutOff], in which candidate change points lie.</p>
</dd>
<dt>Q</dt><dd><p>A scalar representing the number of Monte Carlo simulations to run
while approximating the critical value (stardized Brownian bridge).
Default is 1000.</p>
</dd>
<dt>boot</dt><dd><p>Logical, also compute bootstrap <code class="reqn">p</code>-value if <code>TRUE</code>. 
Default is <code>FALSE</code>.</p>
</dd>
<dt>R</dt><dd><p>The number of bootstrap replicates. Only used when <code>boot</code> 
is <code>TRUE</code>. Default is 1000.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code>NetCPD</code> object &mdash; a list containing the following fields:
</p>
<table>
<tr><td><code>tau</code></td>
<td>
<p>a scalar holding the estimated change point.</p>
</td></tr>
<tr><td><code>pvalAsy</code></td>
<td>
<p>A scalar holding the asymptotic <code class="reqn">p</code>-value.</p>
</td></tr>
<tr><td><code>pvalBoot</code></td>
<td>
<p>A scalar holding the bootstrap <code class="reqn">p</code>-value. 
Returned if <code>optns$boot</code> is TRUE.</p>
</td></tr>
<tr><td><code>optns</code></td>
<td>
<p>The control options used.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li> <p><cite>Dubey, P. and Müller, H.G., 2020. Fréchet change-point detection. The Annals of Statistics, 48(6), pp.3312-3335.</cite>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n1 &lt;- 100
n2 &lt;- 100
gamma1 &lt;- 2
gamma2 &lt;- 3
Y1 &lt;- lapply(1:n1, function(i) {
  igraph::laplacian_matrix(igraph::sample_pa(n = 10, power = gamma1, 
                                             directed = FALSE), 
                           sparse = FALSE)
})
Y2 &lt;- lapply(1:n2, function(i) {
  igraph::laplacian_matrix(igraph::sample_pa(n = 10, power = gamma2, 
                                             directed = FALSE), 
                           sparse = FALSE)
})
Ly &lt;- c(Y1, Y2)
res &lt;- NetCPD(Ly, optns = list(boot = TRUE))
res$tau # returns the estimated change point
res$pvalAsy # returns asymptotic pvalue
res$pvalBoot # returns bootstrap pvalue

</code></pre>

<hr>
<h2 id='NetFIntegral'>Generalized Fréchet integrals of network</h2><span id='topic+NetFIntegral'></span>

<h3>Description</h3>

<p>Calculating generalized Fréchet integrals of networks (equipped with Frobenius norm of adjacency matrices with zero diagonal elements and non negative off diagonal elements.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NetFIntegral(phi, t_out, X, U)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NetFIntegral_+3A_phi">phi</code></td>
<td>
<p>An eigenfunction along which we want to project the network</p>
</td></tr>
<tr><td><code id="NetFIntegral_+3A_t_out">t_out</code></td>
<td>
<p>Support of <code>phi</code></p>
</td></tr>
<tr><td><code id="NetFIntegral_+3A_x">X</code></td>
<td>
<p>A three dimensional array of dimension <code>length(t_out) x m x m</code>, where <code>X[i,,]</code> is an <code>m x m</code> network adjacency matrix. The diagonal elements of adjacency matrices are zero and the off diagonal entries lie between zero and <code>U</code>.</p>
</td></tr>
<tr><td><code id="NetFIntegral_+3A_u">U</code></td>
<td>
<p>Upper bound of off-diagonal entries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the following:
</p>
<table>
<tr><td><code>f</code></td>
<td>
<p>An adjacency matrix which corresponds to the Fréchet integral of <code>X</code> along <code>phi</code></p>
</td></tr>
</table>


<h3>References</h3>

<p><cite>Dubey, P., &amp; Müller, H. G. (2020). Functional models for time‐varying random objects. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 82(2), 275-327.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(5)
n &lt;- 100
N &lt;- 50
t_out &lt;- seq(0,1,length.out = N)
library(mpoly)
p2 &lt;- as.function(mpoly::jacobi(2,4,3),silent=TRUE)
p4 &lt;- as.function(mpoly::jacobi(4,4,3),silent=TRUE)
p6 &lt;- as.function(mpoly::jacobi(6,4,3),silent=TRUE)

# first three eigenfunctions
phi1 &lt;- function(t){
p2(2*t-1)*t^(1.5)*(1-t)^2 / (integrate(function(x) p2(2*x-1)^2*x^(3)*(1-x)^4,0,1))$value^(1/2)
}
phi2 &lt;- function(t){
p4(2*t-1)*t^(1.5)*(1-t)^2 / (integrate(function(x) p4(2*x-1)^2*x^(3)*(1-x)^4,0,1))$value^(1/2)
}
phi3 &lt;- function(t){
p6(2*t-1)*t^(1.5)*(1-t)^2 / (integrate(function(x) p6(2*x-1)^2*x^(3)*(1-x)^4,0,1))$value^(1/2)
}

# random component of adjacency matrices
P12 &lt;- 0.1 ## edge between compunities
Score &lt;- matrix(runif(n*4), nrow = n)
# edge within first community
P1_vec &lt;- 0.5 + 0.4*Score[,1] %*% t(phi1(t_out)) + 0.1*Score[,2] %*% t(phi3(t_out)) 
# edge within second community
P2_vec &lt;- 0.5 + 0.3*Score[,3] %*% t(phi2(t_out)) + 0.1*Score[,4] %*% t(phi3(t_out)) 

# create Network edge matrix
N_net1 &lt;- 5 # first community number
N_net2 &lt;- 5 # second community number

# I: four dimension array of n x n matrix of squared distances between the time point u 
# of the ith process and process and the time point v of the jth object process,
# e.g.: I[i,j,u,v] &lt;- d_F^2(X_i(u) X_j(v)).
I &lt;- array(0, dim = c(n,n,N,N))
for(u in 1:N){
  for(v in 1:N){
   #frobenius norm between two adjcent matrix
    I[,,u,v] &lt;- outer(P1_vec[,u], P1_vec[,v], function(a1, a2) (a1-a2)^2*(N_net1^2-N_net1)) +
      outer(P2_vec[,u], P2_vec[,v], function(a1, a2) (a1-a2)^2*(N_net2^2-N_net2))
  }
}


# check ObjCov work
Cov_result &lt;- ObjCov(t_out, I, 3, smooth=FALSE)
Cov_result$lambda  # 0.266 0.15 0.04

# sum((Cov_result$phi[,1] - phi1(t_out))^2) / sum(phi1(t_out)^2)
# sum((Cov_result$phi[,2] - phi2(t_out))^2) / sum(phi2(t_out)^2)
# sum((Cov_result$phi[,3] - phi3(t_out))^2) / sum(phi3(t_out)^2)

# e.g. subj 2
subj &lt;- 2
# X_mat is the network for varying times with X[i,,] is the adjacency matrices 
# for the ith time point
X_mat &lt;- array(0, c(N,(N_net1+N_net2), (N_net1+N_net2)))
for(i in 1:N){
  # edge between communities is P12
  Mat &lt;- matrix(P12, nrow = (N_net1+N_net2), ncol = (N_net1+N_net2)) 
  # edge within the first communitiy is P1
  Mat[1:N_net1, 1:N_net1] &lt;- P1_vec[subj, i] 
  # edge within the second community is P2
  Mat[(N_net1+1):(N_net1+N_net2), (N_net1+1):(N_net1+N_net2)] &lt;- P2_vec[subj, i] 
  diag(Mat) &lt;- 0 #diagonal element is 0
  X_mat[i,,] &lt;- Mat
}
# output the functional principal network(adjacency matrice) of the second eigenfunction
NetFIntegral(Cov_result$phi[,2], t_out, X_mat, 2)

</code></pre>

<hr>
<h2 id='NetFVar'>Fréchet Variance for Networks</h2><span id='topic+NetFVar'></span>

<h3>Description</h3>

<p>Obtain Fréchet variance for graph Laplacian matrices, 
covariance matrices, or correlation matrices 
with respect to the Frobenius distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NetFVar(Ly = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NetFVar_+3A_ly">Ly</code></td>
<td>
<p>A list (length n) of m by m matrices or a m by m by n array where
<code>Ly[, , i]</code> contains an m by m matrix, which can be either graph 
Laplacian matrices or covariance matrices or correlation matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following fields:
</p>
<table>
<tr><td><code>NetFVar</code></td>
<td>
<p>A scalar holding the Fréchet variance.</p>
</td></tr>
<tr><td><code>NetFMean</code></td>
<td>
<p>A matrix holding the Fréchet mean.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 100
U &lt;- pracma::randortho(10)
Ly &lt;- lapply(1:n, function(i) {
  U %*% diag(rexp(10, (1:10)/2)) %*% t(U)
})
res &lt;- NetFVar(Ly)
res$NetFVar
</code></pre>

<hr>
<h2 id='ObjCov'>Object Covariance</h2><span id='topic+ObjCov'></span>

<h3>Description</h3>

<p>Calculating covariance for time varying object data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ObjCov(tgrid, I, K, smooth = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ObjCov_+3A_tgrid">tgrid</code></td>
<td>
<p>Time grid for the time varying object data and covariance function</p>
</td></tr>
<tr><td><code id="ObjCov_+3A_i">I</code></td>
<td>
<p>A four dimension array of <code>n</code> x <code>n</code> matrix of squared distances between the time point u of the ith process and process and the time point v of the jth object process, 
e.g.: <code class="reqn">I[i,j,u,v] = d^2(X_i(u) X_j(v))</code></p>
</td></tr>
<tr><td><code id="ObjCov_+3A_k">K</code></td>
<td>
<p>Numbers of principal components</p>
</td></tr>
<tr><td><code id="ObjCov_+3A_smooth">smooth</code></td>
<td>
<p>Logical indicating if the smoothing is enabled when calculating the eigenvalues and eigenfunctions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the following:
</p>
<table>
<tr><td><code>C</code></td>
<td>
<p>Estimated object covariance (non-smooth) on the 2D grid of dimension <code>length(tgrid)</code> X <code>length(tgrid)</code></p>
</td></tr>
<tr><td><code>sC</code></td>
<td>
<p>Estimated object covariance (smooth) on the 2D grid of dimension <code>length(tgrid)</code> X <code>length(tgrid)</code></p>
</td></tr>
<tr><td><code>tgrid</code></td>
<td>
<p>Time grid for the time varying object data and covariance function</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>Numbers of principal components</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>Matrix of smooth eigenfunctions (dimension: <code>length(tgrid)</code> X <code>K</code>)</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Vector of eigenvalues of dimension <code>K</code> </p>
</td></tr>
</table>


<h3>References</h3>

<p><cite>Dubey, P., &amp; Müller, H. G. (2020). Functional models for time‐varying random objects. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 82(2), 275-327.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### functional covariate
phi1 &lt;- function(x) -cos(pi*x/10)/sqrt(5)
phi2 &lt;- function(x)  sin(pi*x/10)/sqrt(5)

lambdaX &lt;- c(4,2)
# training set
n &lt;- 100
N &lt;- 50
tgrid &lt;- seq(0,10,length.out = N)

Xi &lt;- matrix(rnorm(2*n),nrow=n,ncol=2)
CovX &lt;- lambdaX[1] * phi1(tgrid) %*% t(phi1(tgrid)) + lambdaX[2] * phi2(tgrid) %*% t(phi2(tgrid))
comp1 = lambdaX[1]^(1/2) * Xi[,1] %*% t(phi1(tgrid))
comp2 = lambdaX[2]^(1/2) * Xi[,2] %*% t(phi2(tgrid))
SampleX &lt;- comp1 + comp2

I &lt;- array(0, c(n,n,N,N))
for (u in 1:N){
  for (v in 1:N){
    temp1 &lt;- SampleX[,u]
   temp2 &lt;- SampleX[,v]
    I[,,u,v] &lt;- outer(temp1, temp2, function(v1,v2){
     (v1 - v2)^2
   })
 }
}

result_cov &lt;- ObjCov(tgrid, I, 2)
result_cov$lambda #4 2

sC &lt;- result_cov$sC
sum((sC-CovX)^2) / sum(sC^2)
sum((phi1(tgrid)-result_cov$phi[,1])^2)/sum(phi1(tgrid)^2)

</code></pre>

<hr>
<h2 id='plot.denReg'>Plots for Fréchet regression for univariate densities.</h2><span id='topic+plot.denReg'></span>

<h3>Description</h3>

<p>Plots for Fréchet regression for univariate densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'denReg'
plot(
  x,
  obj = NULL,
  prob = NULL,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  ylim = NULL,
  xlim = NULL,
  col.bar = TRUE,
  widrt = 4,
  col.lab = NULL,
  nticks = 5,
  ticks = NULL,
  add = FALSE,
  pos.prob = 0.9,
  colPalette = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.denReg_+3A_x">x</code></td>
<td>
<p>A <code>denReg</code> object, result of <code><a href="#topic+DenFMean">DenFMean</a></code>, <code><a href="#topic+GloDenReg">GloDenReg</a></code> or <code><a href="#topic+LocDenReg">LocDenReg</a></code>.</p>
</td></tr>
<tr><td><code id="plot.denReg_+3A_obj">obj</code></td>
<td>
<p>An integer indicating which output to be plotted; 1, 2, 3, 4, and 5 for <code>dout</code>, <code>qout</code>, <code>din</code>, <code>qin</code>, and reference chart for <code>qout</code>, respectively - default: 1.</p>
</td></tr>
<tr><td><code id="plot.denReg_+3A_prob">prob</code></td>
<td>
<p>A vector specifying the probability levels for reference chart if <code>obj</code> is set to 5. Default: <code>c(0.05,0.25,0.5,0.75,0.95)</code>.</p>
</td></tr>
<tr><td><code id="plot.denReg_+3A_xlab">xlab</code></td>
<td>
<p>Character holding the label for x-axis; default: <code>"Probability"</code> when <code>obj</code> is 2 or 4, <code>""</code> when <code>obj</code> is 1 or 3, <code>"x"</code> when <code>obj</code> is 5.</p>
</td></tr>
<tr><td><code id="plot.denReg_+3A_ylab">ylab</code></td>
<td>
<p>Character holding the label for y-axis; default: <code>"Quantile"</code> when <code>obj</code> is 2, 4, or 5, and <code>"Density"</code> when <code>obj</code> is 1 or 3.</p>
</td></tr>
<tr><td><code id="plot.denReg_+3A_main">main</code></td>
<td>
<p>Character holding the plot title; default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot.denReg_+3A_ylim">ylim</code></td>
<td>
<p>A numeric vector of length 2 holding the range of the y-axis to be drawn; default: automatically determined by the input <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.denReg_+3A_xlim">xlim</code></td>
<td>
<p>A numeric vector of length 2 holding the range of the x-axis to be drawn; default: automatically determined by the input <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.denReg_+3A_col.bar">col.bar</code></td>
<td>
<p>A logical variable indicating whether a color bar is presented on the right of the plot - default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.denReg_+3A_widrt">widrt</code></td>
<td>
<p>A scalar giving the width ratio between the main plot and the color bar - default: 4.</p>
</td></tr>
<tr><td><code id="plot.denReg_+3A_col.lab">col.lab</code></td>
<td>
<p>A character giving the color bar label.</p>
</td></tr>
<tr><td><code id="plot.denReg_+3A_nticks">nticks</code></td>
<td>
<p>An integer giving the number of ticks used in the axis of color bar.</p>
</td></tr>
<tr><td><code id="plot.denReg_+3A_ticks">ticks</code></td>
<td>
<p>A numeric vector giving the locations of ticks used in the axis of color bar; it overrides <code>nticks</code>.</p>
</td></tr>
<tr><td><code id="plot.denReg_+3A_add">add</code></td>
<td>
<p>Logical; only works when <code>obj</code> is 5. If <code>TRUE</code> add to an already existing plot. Taken as <code>FALSE</code> (with a warning if a different value is supplied) if no graphics device is open.</p>
</td></tr>
<tr><td><code id="plot.denReg_+3A_pos.prob">pos.prob</code></td>
<td>
<p><code>FALSE</code> or a scalar less than 0 or larger than 1. FALSE: no probability levels will be labeled on the quantile curves; a scalar between 0 and 1: indicating where to put the probability levels along the curves on growth charts: 0 and 1 correspond to left and right ends, respectively. Default: 0.9.</p>
</td></tr>
<tr><td><code id="plot.denReg_+3A_colpalette">colPalette</code></td>
<td>
<p>A function that takes an integer argument (the required number of colors) and returns a character vector of colors interpolating the given sequence
(e.g., <code><a href="grDevices.html#topic+heat.colors">heat.colors</a></code>, <code><a href="grDevices.html#topic+terrain.colors">terrain.colors</a></code> and functions created by <code><a href="grDevices.html#topic+colorRampPalette">colorRampPalette</a></code>).
Default is <code>colorRampPalette(colors = c("pink","royalblue"))</code> for more than one curves and <code>"black"</code> otherwise.</p>
</td></tr>
<tr><td><code id="plot.denReg_+3A_...">...</code></td>
<td>
<p>Can set up <code>lty</code>, <code>lwd</code>, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Note</h3>

<p>see <code><a href="#topic+DenFMean">DenFMean</a></code>, <code><a href="#topic+GloDenReg">GloDenReg</a></code> and <code><a href="#topic+LocDenReg">LocDenReg</a></code> for example code.
</p>

<hr>
<h2 id='pol2car'>Transform polar to Cartesian coordinates</h2><span id='topic+pol2car'></span>

<h3>Description</h3>

<p>Transform polar to Cartesian coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pol2car(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pol2car_+3A_p">p</code></td>
<td>
<p>A vector of length <code class="reqn">d</code> <code class="reqn">(d\ge 2)</code> with the first element being the radius and the others being the angles,
where <code>p[2]</code> takes values in <code class="reqn">[0,2\pi]</code> and <code>p[i]</code> takes values in <code class="reqn">[-\pi/2,\pi/2]</code>, for all <code class="reqn">i&gt;2</code> if any.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code class="reqn">d</code> holding the corresponding Cartesian coordinates 
</p>
<p style="text-align: center;"><code class="reqn">\left(r\prod_{i=1}^{d-1}\cos\theta_i, r\sin\theta_1\prod_{i=2}^{d-1}\cos\theta_i, r\sin\theta_2\prod_{i=3}^{d-1}\cos\theta_i,\dots, r\sin\theta_{d-2}\cos\theta_{d-1}, r\sin\theta_{d-1}\right),</code>
</p>

<p>where <code class="reqn">r</code> is given by <code>p[1]</code> and <code class="reqn">\theta_i</code> is given by <code>p[i+1]</code> for <code class="reqn">i=1,\dots,d-1</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pol2car(c(1, 0, pi/4)) # should equal c(1,0,1)/sqrt(2)
pol2car(c(1, pi, 0)) # should equal c(-1,0,0)
</code></pre>

<hr>
<h2 id='SpheGeoDist'>Geodesic distance on spheres.</h2><span id='topic+SpheGeoDist'></span>

<h3>Description</h3>

<p>Geodesic distance on spheres.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpheGeoDist(y1, y2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpheGeoDist_+3A_y1">y1</code>, <code id="SpheGeoDist_+3A_y2">y2</code></td>
<td>
<p>Two unit vectors, i.e., with <code class="reqn">L^2</code> norm equal to 1, of the same length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar holding the geodesic distance between <code>y1</code> and <code>y2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- 3
y1 &lt;- rnorm(d)
y1 &lt;- y1 / sqrt(sum(y1^2))
y2 &lt;- rnorm(d)
y2 &lt;- y2 / sqrt(sum(y2^2))
dist &lt;- SpheGeoDist(y1,y2)
</code></pre>

<hr>
<h2 id='SpheGeoGrad'>Compute gradient w.r.t. y of the geodesic distance <code class="reqn">\arccos(x^\top y)</code> on a unit hypersphere</h2><span id='topic+SpheGeoGrad'></span>

<h3>Description</h3>

<p>Compute gradient w.r.t. y of the geodesic distance <code class="reqn">\arccos(x^\top y)</code> on a unit hypersphere
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpheGeoGrad(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpheGeoGrad_+3A_x">x</code>, <code id="SpheGeoGrad_+3A_y">y</code></td>
<td>
<p>Two unit vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector holding gradient w.r.t. <code>y</code> of the geodesic distance between <code>x</code> and <code>y</code>.
</p>

<hr>
<h2 id='SpheGeoHess'>Hessian <code class="reqn">\partial^2/\partial y \partial y^\top</code> of the geodesic distance <code class="reqn">\arccos(x^\top y)</code> on a unit hypersphere</h2><span id='topic+SpheGeoHess'></span>

<h3>Description</h3>

<p>Hessian <code class="reqn">\partial^2/\partial y \partial y^\top</code> of the geodesic distance <code class="reqn">\arccos(x^\top y)</code> on a unit hypersphere
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpheGeoHess(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpheGeoHess_+3A_x">x</code>, <code id="SpheGeoHess_+3A_y">y</code></td>
<td>
<p>Two unit vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Hessian matrix.
</p>

<hr>
<h2 id='VarObj'>Fréchet Variance Trajectory for densities</h2><span id='topic+VarObj'></span>

<h3>Description</h3>

<p>Modeling time varying density objects with respect to $L^2$-Wasserstein distance by Fréchet variance trajectory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VarObj(tgrid, yin = NULL, hin = NULL, din = NULL, qin = NULL, optns = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VarObj_+3A_tgrid">tgrid</code></td>
<td>
<p>Time grid vector for the time varying object data.</p>
</td></tr>
<tr><td><code id="VarObj_+3A_yin">yin</code></td>
<td>
<p>An array or list of lists holding the samples of observations. If <code>yin</code> is an array, it has size <code>n</code> x <code>length(tgrid)</code> x numbers of samples holding the observation, such that <code>yin[i,j,]</code> holds the observations to the ith sample at the jth time grid. If <code>yin</code> is a list of lists, <code>yin[[i]][[j]]</code> holds the observations to the ith sample at the jth time grid.</p>
</td></tr>
<tr><td><code id="VarObj_+3A_hin">hin</code></td>
<td>
<p>A list of lists holding the histogram for each subject. <code>hin[[i]][[j]]</code> holds the histogram to the ith sample at the jth time grid.</p>
</td></tr>
<tr><td><code id="VarObj_+3A_din">din</code></td>
<td>
<p>A three dimension array of size <code>n</code> x <code>length(tgrid)</code> x <code>length(optns$dSup)</code> holding the observed densities, such that <code>din[i,j,]</code> holds the observed density function taking values on <code>optns$dSup</code> corresponding to the ith sample at the jth time grid.</p>
</td></tr>
<tr><td><code id="VarObj_+3A_qin">qin</code></td>
<td>
<p>A three dimension array of size <code>n</code> x <code>length(tgrid)</code> x <code>length(optns$qSup)</code> holding the observed quantiles, such that <code>din[i,j,]</code> holds the observed density function taking values on <code>optns$qSup</code> corresponding to the ith sample at the jth time grid.
Note that only one of <code>yin</code>, <code>hin</code>, <code>din</code> and <code>qin</code> needs to be input. If more than one of them are specified, <code>yin</code> overwrites <code>hin</code>, <code>hin</code> overwrites <code>din</code> and <code>din</code> overwrites <code>qin</code>.
where each row holds the observations for one subject on the common grid <code>tGrid</code>.</p>
</td></tr>
<tr><td><code id="VarObj_+3A_optns">optns</code></td>
<td>
<p>a list of options control parameters specified by <code>list(name=value)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available control options are <code>qSup</code>, <code>nqSup</code>, <code>dSup</code> and other options in FPCA of fdapace.
</p>


<h3>Value</h3>

<p>A list of the following:
</p>
<table>
<tr><td><code>tgridout</code></td>
<td>
<p>Time grid vector for the output time varying object data.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>Numbers of principal components.</p>
</td></tr>
<tr><td><code>nu</code></td>
<td>
<p>A vector of dimension <code>length(tgridout)</code> giving the mean function support on <code>tgridout</code> of the Fréchet variance function.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>A vector of dimension <code>K</code> containing eigenvalues.</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>A <code>length(tgridout)</code> X <code>K</code> matrix containing eigenfunctions support on <code>tgridout</code> of the Fréchet variance function.</p>
</td></tr>
<tr><td><code>xiEst</code></td>
<td>
<p>A <code>n</code> X <code>K</code> matrix containing the FPC estimates.</p>
</td></tr>
<tr><td><code>cumFVE</code></td>
<td>
<p>A vector of dimension <code>K</code> with the fraction of the cumulative total variance explained with each additional FPC.</p>
</td></tr>
<tr><td><code>FPCAObj</code></td>
<td>
<p>FPCA Object of Fréchet variance function.</p>
</td></tr>
<tr><td><code>tgridin</code></td>
<td>
<p>Input <code>tgrid</code>.</p>
</td></tr>
<tr><td><code>qSup</code></td>
<td>
<p>A vector of dimension <code>length(tgridin)</code> giving the domain grid of quantile functions <code>qout</code>.</p>
</td></tr>
<tr><td><code>qout</code></td>
<td>
<p>A three dimension array of dimension <code>n</code> x <code>length(tgridin)</code> x <code>length(qSup)</code> holding the observed quantiles, such that <code>qout[i,j,]</code> holds the observed density function taking values on <code>qSup</code> corresponding to the ith sample at the jth time grid.</p>
</td></tr>
<tr><td><code>qmean</code></td>
<td>
<p>A <code>length(tgridin)</code> X <code>length(qSup)</code> matrix containing the time varying Fréchet mean function.</p>
</td></tr>
<tr><td><code>VarTraj</code></td>
<td>
<p>A <code>n</code> X <code>length(tgridin)</code> matrix containing the variance trajectory.</p>
</td></tr>
</table>


<h3>References</h3>

<p><cite>Dubey, P., &amp; Müller, H. G. (2021). Modeling Time-Varying Random Objects and Dynamic Networks. Journal of the American Statistical Association, 1-33.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
#use yin 
tgrid = seq(1, 50, length.out = 50)
dSup = seq(-10, 60, length.out = 100)
yin = array(dim=c(30, 50, 100))
for(i in 1:30){
  yin[i,,] = t(sapply(tgrid, function(t){
    rnorm(100, mean = rnorm(1, mean = 1, sd = 1/t))
  }))
}
result1 = VarObj(tgrid, yin = yin)
plot(result1$phi[,1])
plot(result1$phi[,2])
yin2 = replicate(30, vector("list", 50), simplify = FALSE)
for(i in 1:30){
  for(j in 1:50){
    yin2[[i]][[j]] = yin[i,j,]
  }}
result1 = VarObj(tgrid, yin = yin2)

# use hin
tgrid = seq(1, 50, length.out = 50)
dSup = seq(-10, 60, length.out = 100)
hin =  replicate(30, vector("list", 50), simplify = FALSE)
for(i in 1:30){
  for (j in 1:50){
    hin[[i]][[j]] = hist(yin[i,j,])
  }
}
result2 = VarObj(tgrid, hin = hin)

# use din
tgrid = seq(1, 50, length.out = 50)
dSup = seq(-10, 60, length.out = 100)
din = array(dim=c(30, 50, 100))
for(i in 1:30){
  din[i,,] = t(sapply(tgrid, function(t){
    dnorm(dSup, mean = rnorm(1, mean = t, sd = 1/t))
  }))
}
result3 = VarObj(tgrid, din = din, optns=list(dSup = dSup))

# use qin
tgrid = seq(1, 50, length.out = 50)
qSup = seq(0.00001,1-0.00001,length.out = 100)
qin = array(dim=c(30, 50, 100))
for(i in 1:30){
  qin[i,,] = t(sapply(tgrid, function(t){
    qnorm(qSup, mean = rnorm(1, mean = t, sd = 1/t))
  }))
}
result4 = VarObj(tgrid, qin = qin, optns=list(qSup = round(qSup, 4)))

</code></pre>

<hr>
<h2 id='WassFIntegral'>Generalized Fréchet integrals of 1D distribution</h2><span id='topic+WassFIntegral'></span>

<h3>Description</h3>

<p>Calculating generalized Fréchet integrals of 1D distribution (equipped with Wasserstein distance)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WassFIntegral(phi, t_out, Q, Qout)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WassFIntegral_+3A_phi">phi</code></td>
<td>
<p>An eigenfunction along which we want to project the distribution</p>
</td></tr>
<tr><td><code id="WassFIntegral_+3A_t_out">t_out</code></td>
<td>
<p>Support of <code>phi</code></p>
</td></tr>
<tr><td><code id="WassFIntegral_+3A_q">Q</code></td>
<td>
<p>A <code>length(t_out)</code> X <code>length(Qout)</code> matrix whose jth row corresponds to the quantile function on grid <code>Qout</code> for the jth time point.</p>
</td></tr>
<tr><td><code id="WassFIntegral_+3A_qout">Qout</code></td>
<td>
<p>Support of the quantile valued process</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the following:
</p>
<table>
<tr><td><code>f</code></td>
<td>
<p>Quantile function corresponding to the frechet integral of <code>Q</code> along <code>phi</code></p>
</td></tr>
</table>


<h3>References</h3>

<p><cite>Dubey, P., &amp; Müller, H. G. (2020). Functional models for time‐varying random objects. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 82(2), 275-327.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulation as in the paper Dubey, P., &amp; Müller, H. G. (2020).
# Functional models for time‐varying random objects. 
# JRSSB, 82(2), 275-327.

n &lt;- 100
N &lt;- 50
t_out &lt;- seq(0,1,length.out = N)

phi1 &lt;- function(t){
  (t^2-0.5)/0.3416
}
phi2 &lt;- function(t){
  sqrt(3)*t
}
phi3 &lt;- function(t){
  (t^3 - 0.3571*t^2 - 0.6*t + 0.1786)/0.0895
}

Z &lt;- cbind(rnorm(n)*sqrt(12), rnorm(n), runif(n)*sqrt(72), runif(n)*sqrt(9))
mu_vec &lt;- 1 + Z[,1] %*% t(phi1(t_out)) + Z[,2] %*% t(phi3(t_out))
sigma_vec &lt;- 3 + Z[,3] %*% t(phi2(t_out)) + Z[,4] %*% t(phi3(t_out))

# grids of quantile function
Nq &lt;- 40
eps &lt;- 0.00001
Qout &lt;- seq(0+eps,1-eps,length.out=Nq)

# I: four dimension array of n x n matrix of squared distances 
# between the time point u of the ith process and 
# process and the time point v of the jth object process, 
# e.g.: I[i,j,u,v] &lt;- d_w^2(X_i(u) X_j(v)).
I &lt;- array(0, dim = c(n,n,N,N))
for(i in 1:n){
  for(j in 1:n){
    for(u in 1:N){
      for(v in 1:N){
        #wasserstein distance between distribution X_i(u) and X_j(v) 
        I[i,j,u,v] &lt;- (mu_vec[i,u] - mu_vec[j,v])^2 + (sigma_vec[i,u] - sigma_vec[j,v])^2
      }
    }
  }
}

# check ObjCov work 
Cov_result &lt;- ObjCov(t_out, I, 3)
#Cov_result$lambda #12 6 1.75

# calculate Q 
i &lt;- 6 # for the ith subject
Q &lt;- t(sapply(1:N, function(t){
  qnorm(Qout, mean = mu_vec[i,t], sd = sigma_vec[i,t])
}))

score_result &lt;- WassFIntegral(Cov_result$phi[,1], t_out, Q, Qout)
score_result$f

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
